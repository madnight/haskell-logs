00:00:21 <quchen> I tuned in too late, but did he come here to complain about GHC?
00:09:59 <mcstar> is the final name of 'stable hackage' decided yet?
00:10:48 <ion> suckage, for “stable, ultimate (ha)ckage”
00:11:21 <mcstar> i have a proposal
00:11:37 <mcstar> but then, it doesnt matter, does it?
00:16:30 <dmwit> :t \f g h x -> f.g.h$x
00:16:31 <lambdabot> (a -> b) -> (a1 -> a) -> (t -> a1) -> t -> b
00:17:05 <mcstar> anyway, im compelled to tell it
00:17:18 <mcstar> do you know those big ships? aircraft carriers?
00:17:36 <pnkbst> ah, Stable Hackage.  so many witty acronyms starting with SH to choose from
00:17:37 <mcstar> lets call it the haskell 'stable cabal currier'
00:18:11 <mcstar> i think it sounds quite good, doesnt it?
00:20:44 <k0001_> Current hack age.
00:21:48 <mcstar> will it be a collection of cabal files, ultimately? or is my name a misnomer?
00:24:40 <ARCADIVS> Is there a way to pipe standard input into ghci?
00:25:21 <mcstar> ghci < stufffromfile
00:26:04 <mcstar> also, stdin is already handled... so im not sure what you mean
00:27:19 <dmwit> "pipe standard input" is a nonsense phrase, as far as I can tell
00:28:28 <mcstar> dmwit: do you like my name suggestion?
00:28:50 <dmwit> not particularly
00:29:03 <mcstar> k, thanks, i appreciate honesty
00:30:12 <dmwit> For what it's worth, I don't actively dislike it. I just have a hard time getting worked up one way or the other about singleton names.
00:30:42 <dmwit> Now, naming _schemes_... that I can form opinions on. =)
00:31:12 <mcstar> :)
00:31:29 <mcstar> you mean, like chicken scheme, racket scheme...?
00:31:36 <dmwit> ;-)
00:32:26 <shachaf> dmwit: You like naming things, right?
00:32:34 <shachaf> @ty set
00:32:36 <lambdabot> Setting s t a b -> b -> s -> t
00:32:44 <shachaf> What should a version of set that takes the b argument last be called?
00:33:04 <shachaf> @ty ste -- not optimal
00:33:06 <lambdabot> Setting b c a1 a -> b -> a -> c
00:33:15 <shachaf> > (ste (upon last) "hello world") 'q'
00:33:17 <lambdabot>   "hello worlq"
00:35:58 <dmwit> "set" doesn't seem like the right name for the first one
00:36:20 <shachaf> Why not?
00:36:30 <shachaf> @ty (set (upon last) 'q')
00:36:31 <lambdabot> [Char] -> [Char]
00:36:40 <shachaf> > (set (upon last) 'q') "hi"
00:36:42 <lambdabot>   "hq"
00:37:11 <dmwit> :t last
00:37:13 <lambdabot> [a] -> a
00:37:15 <dmwit> magic
00:37:25 <dmwit> :t upon
00:37:26 <lambdabot> (Data.Data.Data s, Typeable a, Applicative f, Indexed Int k) => (s -> a) -> k (a -> f a) (s -> f s)
00:37:44 <shachaf> "You don't want to know"
00:37:53 <dmwit> yeah...
00:38:02 <dmwit> BFF style?
00:38:21 <dmwit> hm, no, can't be with that type
00:38:29 <shachaf> What's BFF style?
00:38:37 <dmwit> bidirectionalization-for-free
00:39:39 <shachaf> Oh, "that paper I haven't read yet"
00:40:07 <shachaf> Anyway, it traverses the structure with Data and replaces every element with an exception.
00:40:20 <shachaf> The it calls the accessor and forces the value to see which exception was raised.
00:40:29 <shachaf> n
00:40:35 <dmwit> oh $DEITY
00:40:51 <shachaf> It's not quite as efficient as you might want. :-)
00:41:56 <dmwit> You could always open a thesaurus.
00:42:03 <dmwit> "changeTo", maybe
00:42:23 <shachaf> dmwit: We never close the thesaurus over in #-lens
00:42:33 <edwardk> heh
00:42:41 <shachaf> Hmm, setTo?
00:42:56 <startling> so with optparse-applicative I want to apply some option parser if and only if some other flag is activated. This sounds monadic! But does the optparse-applicative API give me some way to do that kind of thing?
00:42:59 <edwardk> shachaf: for the flipped set?
00:43:05 <shachaf> @let setTo = ste
00:43:07 <lambdabot>  Defined.
00:43:08 <shachaf> > setTo _1 ('a',True) 5
00:43:10 <lambdabot>   (5,True)
00:43:20 <dmwit> "overhaul"
00:43:25 <shachaf> The "To" doesn't quite work since it's for the third argument.
00:43:35 <edwardk> yeah
00:43:48 <startling> I could use "optional" from the Alternative instance and then *>, but I don't know how I would make a parse that fails if a flag doesn't exist.
00:43:53 <startling> *parser
00:44:03 <dmwit> (upon last `makeIt` 'q') "hello, world"
00:44:39 <startling> (upon last `transmute` 'q')
00:45:36 <Ralith> for such a terrible thing, people spend way too much time playing with upon
00:45:52 <dmwit> startling: Yeah, that's monadic. You can get monadic-like things in some applicatives in Haskell by abusing laziness and infinite data structures, but it's not advised, especially if you're not in control of the implementation of the data structure and API.
00:45:52 <startling> :t upon
00:45:54 <lambdabot> (Data.Data.Data s, Typeable a, Applicative f, Indexed Int k) => (s -> a) -> k (a -> f a) (s -> f s)
00:46:20 <startling> dmwit, I feel like I'd be able to pull it off with "optional", though
00:46:42 <dmwit> :t optional
00:46:44 <lambdabot> Alternative f => f a -> f (Maybe a)
00:47:10 <startling> but I don't see a way to make some option parser fail if x flag doesn't exist.
00:47:18 <dmwit> don't see how that helps, really
00:47:44 <startling> optional (flagExists *> optParser)
00:49:43 <startling> oh, flag' seems promising.
00:55:21 <pnkbst> I like Stable Hackage is Pretty Stable (ships).  get it?  "it's stable, ship it"
00:57:59 <pnkbst> or stable hackage is not yesod
00:58:24 <mcstar> horse stable
00:58:54 <startling> pnkbst: SHINY is good
00:59:00 <dmwit> What if we left the "stable" bit out of the name? And the "Hackage" bit, too?
00:59:08 <dmwit> It's just a different product, sell it that way.
00:59:31 <shachaf> What if we left out the whole thing?
00:59:38 <dmwit> What if we did?
00:59:45 <mcstar> we need to name something...
00:59:49 <pnkbst> how wonderfully zenlike that would be
01:00:15 <dmwit> Somehow I've become a grumpy old man against my will and without growing old.
01:00:33 <mcstar> poetry
01:01:07 <alpounet> dmwit, especially considering it's duplicating features/ideas that will be in Hackage2 at some point...
01:01:17 <shachaf> Sources indicate that dmwit is old.
01:02:08 <mcstar> <30 id say
01:02:17 <mcstar> (<30)
01:02:32 <shachaf> Eh. We can round to the nearest 10.
01:02:39 <dmwit> alpounet: Well, "somebody else has vaporware implementing that" doesn't seem like a good reason to avoid releasing. So I'm not sure I'm on board with you on that particular complaint.
01:08:37 <alpounet> dmwit, nah it's not what i meant. i just wish these efforts were put on hackage2
01:08:55 <alpounet> instead of a separate project
01:09:14 <dmwit> Now that sentiment I can agree with.
01:09:53 <elliott> you wouldn't say that if you'd seen hackage2's codebase :p
01:10:13 * elliott kids
01:10:19 <elliott> (but it's not as nice as it could be...)
01:11:13 <alpounet> elliott, as a matter of fact, i have seen it
01:11:17 <alpounet> and started writing a patch
01:11:29 <elliott> then you are more productive than I :)
01:13:27 <alpounet> elliott, but Michael is already familiar with the Cabal code base, so that would be great if he could concentrate his efforts there.
01:13:39 <alpounet> okay, okay, hackage2 uses happstack, but come on :P
01:13:46 <elliott> I'm not a big fan of this stackage thing, yeah.
01:14:08 <elliott> but I also sort of think there might be more productive avenues to explore modernising Haskell's packaging stuff than hackage2
01:14:12 <startling> me neither. it sounds like you could just "release" it as a list of version numbers.
01:14:16 <startling> or a metapackage.
01:14:39 <startling> cabal install yesod-plus or whatever.
01:15:35 <alpounet> startling, well, if i remember correctly, there were two different ideas that would support a stackage-like thing and that are planned: having a specific tag for the "vetted" packages OR some kind of "stars" (rating) system
01:15:55 <startling> how would the stars be useful?
01:16:49 <dmwit> How would the stars be measured?
01:17:06 <alpounet> dmwit, that's what i'm trying to remember - dcoutts told me about this a while ago
01:17:12 <dmwit> If I install a thing and it builds, how many stars should I give it? If it doesn't build, how many stars should I give it?
01:17:23 <alpounet> but tbh, I'm not sure i remember. but i don't think it was about rating.
01:17:49 <alpounet> i mean, user rating
01:17:58 <dmwit> Oh, you're talking about planned Hackage2 features.
01:18:05 <alpounet> yes
01:18:12 <dmwit> Yeah, I guarantee the stars won't be used for rating stability, if they're made available.
01:18:24 <pnkbst> wouldn't the stars indicate the number of hoops you hod to jump through to make it build, averaged across all the users who installed?
01:18:39 <shachaf> "Three hoops out of five"
01:18:44 <pnkbst> five stars meaning that the whole community had it build perfectly?
01:18:53 <startling> "what's a Applicative??? I will remove this rating if you fix this"
01:18:54 <mcstar> no, 0
01:19:03 <pnkbst> yeah, that sucks
01:19:05 <arcatan> hmm, to me Stackage seems like rather nice idea. hmm.
01:19:10 <shachaf> You could show a yak with varying amounts of fur.
01:19:26 <startling> shachaf: the really good ones would come pre-shaven
01:19:30 <mcstar> or just a Common Hacker...
01:19:33 <alpounet> arcatan, having "vetted" sets of packages is nice. having it totally apart from the hackage code base isn't, imo.
01:21:06 <arcatan> alpounet: yeah, it'd be nice if Cabal supported that out-of-the-box
01:21:12 <klugez> startling: There's actually a metapackage yesod-platform with exact requirements right now.
01:22:18 <klugez> So Michael has tried that already.
01:24:25 <startling> klugez: oh, huh.
01:26:19 <ARCADIVS> I have a list like [["1"], ["2"]] and I need it to be a list like ["1","2"]. Is there a standard function for this?
01:26:35 <ramses_> ARCADIVS: concat
01:26:44 <ARCADIVS> Thanks. :)
01:28:14 * hackagebot network-conduit 0.6.2 - Stream socket data using conduits.  http://hackage.haskell.org/package/network-conduit-0.6.2 (MichaelSnoyman)
01:28:16 * hackagebot warp 1.3.5.1 - A fast, light-weight web server for WAI applications.  http://hackage.haskell.org/package/warp-1.3.5.1 (MichaelSnoyman)
01:29:10 <shachaf> Well...
01:29:23 <shachaf> > concat [["hello","there"],["san","francisco"]]
01:29:24 <lambdabot>   ["hello","there","san","francisco"]
01:29:26 <shachaf> > map concat [["hello","there"],["san","francisco"]]
01:29:28 <lambdabot>   ["hellothere","sanfrancisco"]
01:29:31 <shachaf> Which one do you want?
01:30:52 <elliott> > [["hello","there"],["san","francisco"]] ^. traverse
01:30:54 <lambdabot>   ["hello","there","san","francisco"]
01:31:01 <elliott> No, that's not right.
01:31:14 <elliott> Well, I guess it is
01:31:18 <shachaf> > [["hello","there"],["san","francisco"]] ^.. traverse
01:31:20 <lambdabot>   [["hello","there"],["san","francisco"]]
01:31:25 <shachaf> > [["hello","there"],["san","francisco"]] ^.. traverse.traverse
01:31:27 <lambdabot>   ["hello","there","san","francisco"]
01:31:32 <shachaf> > [["hello","there"],["san","francisco"]] ^.. traverse.traverse.traverse
01:31:34 <lambdabot>   "hellotheresanfrancisco"
01:31:37 <Guest21920> anyone got any inspired ideas on how I could import a user database with their MD5 passwords into happstack using an existing auth package?
01:31:53 <shachaf> Guest21920: You shouldn't use MD5 passwords. :-(
01:31:57 <mreh> I know
01:32:05 <shachaf> The first step ought to be converting them to something better.
01:32:11 <mreh> it's Drupal6
01:32:16 <mreh> it's Drupal6
01:32:47 <mreh> I'm not sure how it would be possible to convert them given its a one way hash, unless I use a rainbow table >:D
01:33:18 <t7> md5 is webscale
01:33:56 <shachaf> mreh: The standard thing would be to use some sort of good hash on the md5 hashes.
01:34:10 <shachaf> Then as users log in, you can replace their password entry with a "good hash" of the password directly.
01:34:14 <t7> bcrypt the md5s lol
01:34:18 <shachaf> Of course when I say "hash" I mean something like bcrypt.
01:34:28 <alpounet> mreh, there's happstack-authenticate
01:34:44 <mreh> alpounet: yeah, I know but it's SHA
01:34:55 <alpounet> oh, didn't know that.
01:34:56 <mreh> I'd have to augement the process with an extra step
01:35:16 <t7> shachaf: aparently the new php does this magic for you. when a user logs in it changes their password hash to the 'best' algorithm
01:35:39 <mreh> PHP doesn't authenticate users
01:35:53 <t7> php crypto standard lib thing
01:36:07 <t7> i dont use shitty php but i heard in a podcast or something
01:36:39 <alpounet> mreh, then your best shot is either to ask the happstack-authenticate maintainer(s) how you could plug md5 in there, or just keep the same db and use the appropriate db binding, or import everything in an acid-state db
01:36:52 <sopvop> t7: sure ;)
01:37:13 <mreh> Didn't I see a happstack "plugin" where someone would store the hash algorithm and an integer which was used for password stregthening
01:37:45 <mreh> i.e. n would perform 2^n iterations of the hash
01:37:59 <mreh> and you could upgrade your password strengthening as computers become faster
01:38:17 <shachaf> You should use PBKDF2 or something instead of iterating the hash.
01:38:18 <mreh> happstack-authenticate uses 512 iterations
01:38:22 <shachaf> Or bcrypt!
01:38:27 <shachaf> 512 is way too low.
01:38:33 <mreh> that's what I thought
01:38:37 <pnkbst> mreh: http://stackoverflow.com/questions/10771198/migrate-old-md5-passwords-to-bcrypt-passwords
01:38:46 <t7> but im running on a raspberry pi
01:39:17 <mreh> thanks for all the help guys :)
01:39:35 <shachaf> t7: I don't think your comments here are very helpful.
01:40:05 <ARCADIVS> I'm mapping read to some list like "map read ["1","2"]" but I can't seem to figure out how to add type signature. Any help?
01:40:24 <shachaf> map (read :: String -> Int) ["1","2"]
01:40:32 <shachaf> Alternatively, map read ["1","2"] :: [Int]
01:41:08 <ARCADIVS> Thank you!
01:41:10 <ARCADIVS> :)
01:42:51 <ARCADIVS> Finally I present to you my horrible creation:
01:42:58 <ARCADIVS> printf "sum $ map (read :: String -> Float) $ concat $ map (take 1) $ map words [\"%s\", \"%s\"]" "$(du status-right.sh | tr '\t' ' ')" "$(du status-left.sh | tr '\t' ' ')" | ghci
01:43:05 <latermuse> hehe
01:43:36 <latermuse> you are piping that to ghci
01:43:56 <ARCADIVS> Yeah.
01:44:01 <mcstar> no, he pasted it into the channel
01:44:17 * latermuse ha
01:47:19 <ARCADIVS> I didn't originally realize I would have to remove tabs from string literals for it to parse.
01:49:12 <ramses_> ARCADIVS: sum . map (read :: String -> Float) . concat . map (take 1 . words) $ ["1", "2"]
01:49:19 <mcstar> i cant imagine a reson other than 'for the heck of it' for you to do that
01:49:40 <mcstar> reason*
01:54:22 <watermind> this is off topic but sml seems so quiet right now... mind if I ask a question on simulating haskell's infinite streams in sml (which is strict)?
01:55:14 <watermind> I have 1. http://pastebin.com/TxD76hVj and 2. http://pastebin.com/b8KN7ifU   and only the first works, but the second is IMO more elegant
01:55:49 <watermind> is there a workaround to make the infinite stream ones work with the 2nd type
01:55:49 <mauke> The pastes TxD76hVj b8KN7ifU have been copied to http://hpaste.org/78804 http://hpaste.org/78805
01:56:59 <Jafet> mauke: nice script
01:57:31 <elliott> watermind: This really doesn't have anything to do with Haskell, and the majority of this channel won't be able to help with SML questions.
01:58:02 <osfameron> well, it's about simulating a haskell feature, so it's vaguely relevant, if the chan is quiet
01:58:06 <watermind> elliott: I know... I wouldn't ask it if the channel was busy
01:58:08 <Jafet> I don't see any variable update in that code, so it doesn't simulate Haskell
01:58:15 * hackagebot stylish-haskell 0.5.5.0 - Haskell code prettifier  http://hackage.haskell.org/package/stylish-haskell-0.5.5.0 (JasperVanDerJeugt)
01:58:17 <osfameron> if it's OT, you could ask in haskell-blah...
01:58:57 <shachaf> #haskell-blah isn't really for questions like that.
01:58:58 <watermind> elliott: and I thought some haskell users might be pretty good at simulating lazy eval in stric languages
01:59:05 <watermind> shachaf: thanks I didn't know that
01:59:10 <watermind> sorry about that
02:01:22 <osfameron> shachaf: I guess, but it's for overspill that people find *interesting*, which this might or might not be
02:05:10 <Jafet> Hmm, delay is an SML primitive.
02:08:14 <citizen93> Dear all, I am running a Windows 7 (x64), now I am trying to get a wxHaskell program running. Now I get the following error
02:08:15 <citizen93> Loading package wxc-0.90.0.4 ... ghc: panic! (the 'impossible' happened)
02:08:15 <citizen93>   (GHC version 7.4.2 for i386-unknown-mingw32):
02:08:15 <citizen93> 	loadArchive "C:\\wxWidgets-2.9.4\\lib\\gcc_dll\\libwxmsw29u_xrc.a": failed
02:08:30 <citizen93> how can I fix this? :(
02:11:20 <aristid> citizen93: what happened is impossible! you broke the universe :(
02:11:50 <aristid> citizen93: does the referenced file exist?
02:14:19 <mreh> forgive my ignorance, but I'd quite like to turn a String into a Data.BytString.ByteString
02:14:23 <mreh> how does one do this?
02:14:26 <dmwit> ?hackage encoding
02:14:26 <lambdabot> http://hackage.haskell.org/package/encoding
02:14:36 <dmwit> pack is the convenient, incorrect answer
02:15:05 <mreh> "it depends" is the correct answer I suppose ;)
02:15:36 <mreh> pack gives me String -> Data.ByteString.Char8.Bytestring
02:15:43 <aristid> mreh: it depends mostly on the encoding you want.
02:15:56 <dmwit> Data.ByteString.ByteString = Data.ByteString.Char8.ByteString
02:16:06 <aristid> if you want ASCII and ignore non-ASCII characters in the String, pack is in fact correct.
02:16:20 <dmwit> pack does not ignore non-ASCII characters.
02:16:21 <mreh> dmwit: no it isn't, each they both implement their own
02:16:36 <mreh> each module implements their own*
02:16:37 <aristid> dmwit: right, but if _he_ wants to ignore them:P
02:16:39 <dmwit> mreh: There is a lazy bytestring and a strict one, but no separate Char8 bytestring.
02:16:42 <dmwit> This I know.
02:17:23 <mreh> they're different types completely
02:17:41 <aristid> how does pack deal with codepoints above 255 again?
02:18:03 <mreh> doesn't it just treat them like two bytes
02:18:10 <dmwit> mreh: You're wrong, and instead of insisting you're right you should tell us why you think what you think.
02:18:22 <mreh> dmwit: I'm looking at the package source
02:18:41 <mreh> and each module implements its own Bytestring
02:18:44 <mreh> type
02:18:47 <aristid> mreh: no
02:19:07 <dmwit> mreh: What version of the package? Just so we're looking at the same thing.
02:19:12 <aristid> mreh: it redirects the type to Data.ByteString.Internal.ByteString or Data.ByteString.Lazy.Internal.ByteString.
02:19:31 <dmwit> I'm about 95% sure this choice hasn't changed, but I'm willing to give you the benefit of the doubt.
02:20:31 <aristid> it hasn't changed in bytestring 0.10.2.0.
02:20:36 <mreh> http://hackage.haskell.org/packages/archive/bytestring/0.10.2.0/doc/html/Data-ByteString.html
02:20:48 <aristid> mreh: haddock is not the same as source code.
02:20:59 <mreh> sure
02:21:10 <citizen93> @astrid, I have no idea :(
02:21:10 <lambdabot> Unknown command, try @list
02:21:12 <aristid> click on the little Source right to the link
02:21:24 <citizen93> I can give you the package if you want, I have installed all DLL's
02:21:35 <aristid> citizen93: i don't have windows so that won't help, sorry.
02:21:42 <citizen93> it's the ant program from ICFP
02:21:46 <citizen93> oh I see
02:22:02 <dmwit> citizen93: If you can reproduce a panic on the newest GHC, you should file a bug on GHC's bug tracker.
02:22:09 <mreh> dmwit, aristid: I believe you, sorry
02:22:59 <aristid> mreh: you don't have to believe us :P just check for yourself, properly
02:23:11 <citizen93> I can reproduce, but there is already a ticket
02:23:12 <mreh> I just did :)
02:23:19 <citizen93> with the same problem
02:23:28 <citizen93> http://www.haskell.org/pipermail/glasgow-haskell-bugs/2012-July/039313.html
02:24:19 <citizen93> I'm actually thinking about creating a Virtual Machine and installing an older version of Haskell Platform :(
02:24:22 <citizen93> just to get this running
02:27:09 <citizen93> Well anyways =), Thank you guys for being so helpful for all my little problems =)
02:27:12 <citizen93> cya!
02:27:18 <gienah> citizen93: that bug report says it would be fixed by using dynamic linking
02:27:25 <citizen93> yes
02:27:41 <citizen93> ...I have no idea how to do that :(
02:43:16 * hackagebot sym 0.2.2 - Permutations, patterns, and statistics  http://hackage.haskell.org/package/sym-0.2.2 (AndersClaesson)
02:51:41 <hpaste> idnar pasted “cabal-dev” at http://hpaste.org/78808
02:51:50 <idnar> :(
02:52:45 <dmwit> idnar: cabal install cabal-dev network haskell-platform cgi HTTP
02:53:12 <aristid> i thought HTTP was part of the platform?
02:53:24 <dmwit> wouldn't surprise me
02:53:30 <idnar> it is, that's why upgrading it is breaking everything
02:53:37 <typoclass> (haskell-platform is a cabal package now? how weird ...)
02:53:50 <idnar> well, not "breaking everything", but you know what I mean
02:53:51 <shachaf> The platform doesn't mean much.
02:54:18 <alpounet> idnar, ew, i guess your best shot would be to start with a fresh platform and package db, and install cabal-dev at that moment
02:54:30 <idnar> alpounet: this is a fresh platform
02:54:51 <typoclass> ... wait, i guess it makes sense. the platform is more or less a list of package names and versions. you could maybe even just stick it in the dependencies field
02:55:08 <dmwit> Why are we starting fresh?
02:55:58 <idnar> I just installed HP 2012.4.0.0 on OS X
02:56:08 <dmwit> You could also try cabal install cabal-dev --constraint "parsec installed" --verbose to see why it thinks reinstalling that is a good idea.
02:56:38 <idnar> it's reinstalling parsec because mtl is being downgraded
02:56:50 <apfel> FindSmallest :: [Int] -> Int  -  Syntax error in declaration (unexpected `::') .... why?
02:56:50 <dmwit> That's not the whole story.
02:57:03 <dmwit> (Why is mtl being downgraded?)
02:57:28 <shachaf> apfel: FindSmallest isn't a valid name.
02:57:33 <shachaf> Try findSmallest.
02:57:58 <typoclass> apfel: in haskell, function names always start with a lower-case letter. types start with an upper-case letter
02:57:59 <idnar> dmwit: cabal-dev depends on mtl >=1.1 && <2.1
02:58:18 <apfel> ok thanks
02:58:55 <idnar> dmwit: ...uh, I just ran your command and it completed without any errors
02:58:56 <dmwit> idnar: Does it? According to Hackage, it only depends on base and Cabal.
02:59:01 <idnar> so now I'm horribly confused
02:59:13 <fmap> dmwit: hackage lies
02:59:17 <dmwit> idnar: Right, you shouldn't make stuff up if you don't really know what's going on. =)
02:59:21 <idnar> I should say, /according to cabal info/ cabal-dev depends on mtl >=1.1 && <2.1
02:59:44 <dmwit> fmap: oh, lol, if flag(no-cabal-dev)
03:00:06 <fmap> yeah, apparently someone needs cabal-dev as a library (?)
03:00:24 <dmwit> idnar: Based on what fmap just told me, I bet you installed cabal-dev with the no-cabal-dev flag. =P
03:00:24 <idnar> however I don't seem to have a cabal-dev binary now
03:00:36 <idnar> so... yeah, I guess so
03:00:58 <dmwit> idnar: Well, you could try cabal unpack'ing cabal-dev, relaxing that constraint, and seeing what happens.
03:01:06 <dmwit> If it works, whine at the cabal-dev devs. =)
03:01:27 <idnar> heh
03:01:41 <idnar> maybe I should just stop bothering with cabal-dev
03:02:08 <dmwit> idnar: Seems that the github version has a looser constraint.
03:02:12 * fmap installed cabal-dev from git since cabal-dev's maintainers don't care enough to upload ghc-7.6-compatible package to hackage
03:02:20 <dmwit> https://github.com/creswick/cabal-dev/commit/80d7bc3c3ceef9deb9189cea87fb1fe3e50d6b4f
03:02:24 <fmap> so I guess whining doesn't work :]
03:02:44 <idnar> dmwit: aha
03:02:51 <idnar> only 6 months ago
03:03:16 * hackagebot simple-vec3 0.1.0.0 - Three-dimensional vectors of doubles with basic operations,  supporting Unbox and Storable class  http://hackage.haskell.org/package/simple-vec3-0.1.0.0 (DmitryDzhus)
03:03:46 <dmwit> fmap: package maintenance is hard work just to stand still
03:04:00 <idnar> https://github.com/creswick/cabal-dev/issues/74
03:04:24 <randomclown> exit
03:13:47 <ARCADIVS> Anybody want to talk about the pros and cons of these factorial functions? http://www.willamette.edu/~fruehr/haskell/evolution.html
03:15:11 <startling> ARCADIVS: why not just do fac n = product [1..n]
03:16:24 <startling> or even fac = product . enumFromTo 1
03:16:28 <ARCADIVS> I don't know. Are there any speed differences between these factorial functions?
03:16:37 <dmwit> Yes, very major ones.
03:17:18 <dmwit> In fact, the fastest one isn't even on there.
03:17:23 <shachaf> ARCADIVS: That page is a joke.
03:18:06 <shachaf> dmwit: What's the fastest one? foo n = go 1 n where go !a 1 = 1; go !a n = go (a*n) (n-1) or something like that?
03:18:16 <dmwit> it uses an associative fold
03:18:33 <shachaf> Pft. You're not talking about parallelizing, are you?
03:18:36 <dmwit> Integer multiplication is a bit faster when the multiplicands have similar magnitudes (same with addition).
03:18:48 <dmwit> No, but that would be even faster still. Good suggestion.
03:19:01 <shachaf> Ah, hmm.
03:19:18 <startling> ARCADIVS, you're not likely to care.
03:19:32 <ARCADIVS> You don't think so?
03:19:58 <startling> ARCADIVS: well, I'm assuming you're not dumb.
03:20:17 <dmwit> startling: I have actually written code that was useful and also involved computing a factorial.
03:20:20 <dsantiago> It seems to be well-known that Attoparsec is faster than Parsec. Does anyone know why it's faster?
03:20:35 <ARCADIVS> startling: how kind of you.
03:21:25 <dmwit> dsantiago: The haddocks have a good discussion of the tradeoffs. Do you find the discussion lacking?
03:21:50 <dsantiago> I'm not aware of the discussion you're talking about.
03:22:15 <dmwit> This tells me you didn't read the documentation. Shame on you.
03:24:50 <dsantiago> Yeah, I'll never get over it.
03:27:12 <ARCADIVS> My favourite Haskell feature is $.
03:27:34 <FireFly> The best part is when you realise that ($) is just an alias for id
03:27:49 <watermind> dmwit: what is an associative fold?
03:28:10 <merijn> watermind: A fold where the operator is associative
03:28:12 <dmwit> watermind: Well, you know how foldr is right-associative and foldl is left-associative?
03:28:59 <ARCADIVS> My least least favourite feature is . (function composition). I think leads to code obfuscation.
03:29:02 <shachaf> FireFly: Well, what do you say to this?
03:29:03 <watermind> merijn: dmwit: yes I understand it must be a fold which exploits the operation being associative
03:29:07 <shachaf> > runST $ return 5
03:29:08 <lambdabot>   5
03:29:10 <shachaf> > runST `id` return 5
03:29:10 <dmwit> There's also one that requires your operator be associative and makes no promises about left- or right-associating its operands.
03:29:11 <lambdabot>   Couldn't match expected type `forall s. GHC.ST.ST s a0'
03:29:11 <lambdabot>              with a...
03:29:12 <watermind> merijn: dmwit: just not sure how
03:29:26 <watermind> i.e. how an associative fold would exploit that
03:29:46 <dmwit> watermind: The simplest way is to take a list and coalesce adjacent elements with the operator along the whole list. This produces a list half as long. Repeat until the list is only one long.
03:29:49 <watermind> in a manner that makes it faster than a strict left fold
03:29:56 <merijn> watermind: If your fold is associative + commutative you can map-reduce it
03:30:08 <merijn> watermind: i.e. parallelise the fold
03:30:08 <shachaf> You don't really need commutativity, do you?
03:30:12 <FireFly> shachaf: probably "I haven't bothered to read up on ST yet"
03:30:14 <merijn> shachaf: Sure you do
03:30:26 <shachaf> Why?
03:30:31 <watermind> merijn: dmwit: ah but I thought you were talking with no parallelisation
03:30:36 <FireFly> shachaf: I presume it has to do with ($)'s type specialisation compared to plain id?
03:30:42 <dmwit> watermind: I am talking with no parallelisation.
03:30:56 <watermind> dmwit: then I don't see how that makes it faster
03:31:07 <dmwit> watermind: Yeah, it's a bit subtle.
03:31:14 <watermind> dmwit: oh oh
03:31:15 <shachaf> FireFly: Depending on the version of GHC, but yes.
03:31:25 <watermind> dmwit: I see your similar size integer comment
03:31:29 <merijn> shachaf: Actually, maybe you're right, but you'd have to sequentialise the merges
03:31:35 <dmwit> watermind: It's faster because the implementation of the operation is a bit faster by accident when you fold it this way, not because you invoke the operation fewer times or anything like that.
03:33:53 <shachaf> merijn: What do you mean?
03:34:07 <shachaf> ((1 + 1) + (1 + 1)) + ((1 + 1) + (1 + 1))
03:34:16 <shachaf> Seems perfectly parallelizable to me, as a tree.
03:34:39 <dmwit> shachaf: You and merijn are having trouble seeing eye-to-eye because the "map" part of the map-reduce in question is too trivial.
03:35:03 <dmwit> "id" is not a very interesting function to parallelize in the map phase.
03:35:12 <shachaf> dmwit: I don't think the map part is really relevant here, though, is it?
03:35:18 <shachaf> I mean, that's trivially parallelizable.
03:35:31 <shachaf> ("trivially")
03:35:42 <shachaf> (Isn't it great how you can just type one word and you're done with a problem?)
03:35:48 <dmwit> shachaf: Imagine a non-trivial map part. You don't know how long it takes for the function to compute for a particular element.
03:35:58 <dmwit> Now, two of the elements complete, and you want to reduce their answers.
03:36:01 <dmwit> What do you do?
03:36:47 <dmwit> Possible answers: 1. merge them right away; this relies on your operation being commutative; 2. wait until all the elements in between them finish computing, then merge with the usual strategy; this doesn't require commutativity but does require sequentialization
03:36:59 <shachaf> OK, fair enough.
03:48:17 * hackagebot lens 3.6.0.3 - Lenses, Folds and Traversals  http://hackage.haskell.org/package/lens-3.6.0.3 (EdwardKmett)
03:51:11 <arcatan> ocharles: btw, 24 days of Hackage is great. I hadn't heard of errors previously, but it seems handy.
03:57:31 <Botje> @pl readsPrec pri input = map convert $ readsPrec pri input
03:57:31 <lambdabot> readsPrec = fix ((map convert .) .)
03:57:43 <Botje> @pl readsPrec pri input = map convert $ readsPrec' pri input
03:57:43 <lambdabot> readsPrec = (map convert .) . readsPrec'
04:08:09 <Botje> @hoogle (.:)
04:08:09 <lambdabot> No results found
04:18:18 * hackagebot uniplate 1.6.8 - Help writing simple, concise and fast generic operations.  http://hackage.haskell.org/package/uniplate-1.6.8 (NeilMitchell)
04:19:18 <shachaf> Uh oh.
04:21:15 <DMcGill> I'm giving a presentation and I need a spoken name for "<|>"
04:21:38 <DMcGill> any suggestions? I was just going to go withi "alternative"
04:22:03 <Ralith> could just abbreviate it to 'pipe'
04:22:36 <DMcGill> hmm, doesn't that bring unix pipe behaviour to mind though?
04:24:04 <vraid> bar?
04:24:16 <vraid> ah, the trigraph..
04:24:52 <DMcGill> :t (<|>)
04:24:53 <lambdabot> Alternative f => f a -> f a -> f a
04:25:07 <Igloo> Wouldn't "or" make sense?
04:25:21 <DMcGill> that's a good idea
04:25:35 <reinoud> what changed between ghc-6.8.3 and ghc-7.4.1 that prevents me from compiling it with ghc-6.8.3 ?
04:26:14 <Igloo> reinoud: Lots of little things, but probably nothing deep
04:26:28 <idnar> what is "it"?
04:27:37 <reinoud> ImplicitCAD
04:27:56 <Igloo> Oh, I thought you meant ghc-7.4.1, sorry
04:28:18 * hackagebot cryptohash 0.7.10 - collection of crypto hashes, fast, pure and practical  http://hackage.haskell.org/package/cryptohash-0.7.10 (VincentHanquez)
04:28:20 <ozgura> is there any way to use ghc generics style deriving with binary or cereal? I see the binary-derive and cereal-derive libraries on hackage but they don't seem to build on ghc-7.6
04:28:30 <watermind> is there some way to explicitelly define a kind, rather than using a data (type) declaration and kind promotion?
04:28:38 <reinoud> i tried to get ghc to compile here but its far from trivial :(
04:28:54 <watermind> s/define/declare
04:29:31 <watermind> so we don't have unecessary types lingering around, ones with the same indentifier as the kind even
04:32:06 <merijn> watermind: No
04:32:15 <merijn> watermind: Unfortunately
04:32:33 * merijn would be in favour of a kind keyword too, but no such luck
04:33:19 * hackagebot cryptocipher 0.3.7 - Symmetrical Block, Stream and PubKey Ciphers  http://hackage.haskell.org/package/cryptocipher-0.3.7 (VincentHanquez)
04:33:20 * hackagebot pem 0.1.2 - Privacy Enhanced Mail (PEM) format reader and writer.  http://hackage.haskell.org/package/pem-0.1.2 (VincentHanquez)
04:36:54 <dreixel_> merijn, watermind: there's a proposal for that
04:37:18 <dreixel_> http://hackage.haskell.org/trac/ghc/wiki/GhcKinds/KindsWithoutData
04:43:18 * hackagebot cipher-aes 0.1.5 - Fast AES cipher implementation with advanced mode of operations  http://hackage.haskell.org/package/cipher-aes-0.1.5 (VincentHanquez)
04:48:53 <hpc> dreixel_: my favorite part of that proposal is changing * to something closer to how haskell parses everything else
04:54:13 <watermind> merijn: :(
04:54:18 <watermind> dreixel_: that looks nice
04:56:54 <watermind> dreixel: for sake of consistency it would be nice to alias "data type" to "data", so we'd have data type and data kind
04:56:55 <Ololo> @pl \x y -> [x, y]
04:56:55 <lambdabot> (. return) . (:)
04:57:02 <Ololo> holy shit
04:57:21 <watermind> dreixel: oh it says there
04:57:26 <dreixel> watermind: yes, http://hackage.haskell.org/trac/ghc/ticket/6024 talks about that too
04:57:34 <watermind> yeah I just noticed
04:57:43 <dreixel> though, in general, we're just not sure if it's a good idea at all
04:58:01 <dreixel> because right now we're seeing a lot of duplication of things at the type and kind level
04:58:10 <yitz> ozgura: interesting. you should report that.
04:58:12 <dreixel> that could potentially be fixed by making * have kind *
04:58:28 <watermind> yeap I was also thinking the next step would be to have some generalization of types and kinds
04:58:32 <watermind> :P
04:58:35 <dreixel> but then you definitely can no longer talk about "data kind" and "data type"
04:58:39 <yitz> ozgura: could be because of the change in Typeable. And it's about to change again, too.
04:58:47 <watermind> hmmm
04:59:16 <dreixel> what's with Typeable?
04:59:38 <ozgura> yitz: I thought I was sufficiently ignored so did not follow up
04:59:57 <ozgura> turns out, cereal provides the ghc generics default implementations already
05:00:01 <yitz> dreixel: http://hackage.haskell.org/packages/archive/base/4.6.0.0/doc/html/Data-Typeable.html
05:00:03 <ozgura> so no need to use cereal-derive
05:00:15 <yitz> ozgura: ah ok that's even better :)
05:00:30 <ozgura> I don't know about binary though
05:00:38 <ozgura> I was intending to use cereal anyway, so hey :)
05:00:39 <dreixel> yitz: yes, I know what Typeable is, but what changes broke what?
05:02:10 <yitz> dreixel: oh i don't remember the details. i do remember that lots of packages broke because of it. and i just saw a mailing list message from JaffaCake that it is about to change again, taking advantage of the new kinds mechanisms.
05:02:28 <dreixel> yitz: yes, it's much better now :)
05:02:50 <dreixel> but shouldn't break much stuff.
05:03:46 <dreixel> but ozgura, you found out how to use GHC.Generics for what you wanted?
05:03:57 <ozgura> dreixel: yes.
05:04:04 <dreixel> ok, cool
05:04:17 <ozgura> dreixel: someone should probably depreciate cereal-derive though
05:04:27 <ozgura> maybe I shouldn't be lazy and email the maintainer to do sth
05:05:14 <dreixel> ozgura: yes, I think that's a good idea
05:05:37 <watermind> what do you call something that has a kind?
05:05:51 <hpc> watermind: a type
05:06:04 <watermind> hpc: so what do you call types of kind * ?
05:06:08 <hpc> (or a constraint; haskell is confusing that way ;))
05:06:12 <hpc> concrete type
05:06:16 <watermind> ah
05:06:51 <dreixel> watermind: lifted types?
05:06:58 <watermind> calling it a type is weird because then Ord is a type
05:07:10 <dreixel> no, Ord has kind * -> Constraint
05:07:24 <ozgura> dreixel: just sent him an email. let's hope he puts a sign in the package description or something like that
05:07:32 <dreixel> ozgura: great
05:07:37 <watermind> dreixel: yes but per hpc first reply that would be a type if I understood correctly
05:07:52 <yitz> Ololo: i usually write it (:[]) . (:) because anyway it's specialized for lists.
05:08:04 <dreixel> watermind: ah, right, that's a trickier question
05:08:09 <hpc> watermind: you missed the parenthetical where i pretend constraint kinds aren't a thing in favor of a simple answer
05:08:19 <dreixel> but yeah, generally you say values have types, and types have kinds
05:08:37 <Ololo> yitz: oh, this one looks much better
05:08:37 <watermind> hpc: right, I see, so if we want to be precise those are constraints
05:08:47 <hpc> types or constraints, yes
05:08:53 <watermind> ok
05:09:11 <mm_freak> watermind: "(Ord a) => a -> a -> X" gets translated to "Ord a -> a -> a -> X", so it's not that weird to call Ord a type constructor…  of course it's actually a constraint constructor, but it's still on the type level
05:09:29 <hpc> or a lifted type (?) if it's something like Z :: Nat (data kinds)
05:09:38 <watermind> mm_freak: yes I undertsand that... still...
05:09:49 <dreixel> hpc: by lifted I just meant that its representation has a closure
05:09:55 <dreixel> as opposed to things of kind #
05:10:26 <hpc> er, i didn't mean (?) as in the actual kind
05:10:36 <hpc> just not sure if that's the right term for when you lift a type to a kind
05:10:40 <dreixel> (?) is gone, fortunately
05:10:47 <hpc> oh thank god
05:11:01 <dreixel> and so is (??)
05:11:33 <dreixel> http://hackage.haskell.org/trac/ghc/wiki/Commentary/Compiler/Kinds
05:13:14 <larsrh> is it possible to derive Data and Typeable for a GADT?
05:13:20 * hackagebot fluent-logger 0.1.1.0 - A structured logger for Fluentd (Haskell)  http://hackage.haskell.org/package/fluent-logger-0.1.1.0 (NoriyukiOhkawa)
05:17:22 <malorie> why don't tuple types have Show instances derived automatically?
05:18:48 <mm_freak> malorie: tuple types?  like (,,) and (,,,,,)?
05:18:58 <malorie> yes
05:19:05 <mm_freak> or like data MyTuple a b c = MyTuple a b c?
05:19:11 <mm_freak> > show (3, 4, 5)
05:19:12 <lambdabot>   "(3,4,5)"
05:20:10 <malorie> yeah. but the instance for (,,) is somewhere in base, no
05:20:38 <Jafet> > show ((),(),(),(),(),(),(),(),(),(),(),(),(),(),(),())
05:20:40 <lambdabot>   No instance for (GHC.Show.Show
05:20:40 <lambdabot>                     ((), (), (), (), (), (),...
05:20:57 <mm_freak> malorie: there is some magic going on for tuples at least in GHC
05:21:28 <mm_freak> but that's really more because GHC provides infinite-sized tuples
05:21:36 <mm_freak> :k (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,)
05:21:37 <lambdabot> * -> * -> * -> * -> * -> * -> * -> * -> * -> * -> * -> * -> * -> * -> * -> * -> * -> * -> * -> * -> * -> * -> * -> * -> * -> * -> * -> * -> * -> * -> * -> * -> * -> * -> * -> * -> * -> * -> * -> * ->
05:21:37 <lambdabot>  * -> * -> * -> * -> * -> * -> * -> * -> * -> * -> * -> * -> * -> * -> * -> * -> * -> * -> * -> * -> * -> * -> * -> * -> * -> * -> * -> * -> * -> * -> * -> * -> * -> * -> * -> * -> * -> * -> * -> * -
05:21:37 <lambdabot> > * -> * -> * -> * -> * -> * -> * -> * -> * -> * -> * -> * -> * -> * -> * -> * -> * -> * -> * -> * -> * -> * -> * -> * -> * -> * -> * -> * -> * -> *
05:21:47 <Jafet> Not that anyone uses large tuples
05:22:00 <luite> I think Show instances are only supplied up to 15 or 16-tuples or so
05:22:00 <mm_freak> i do, i just don't call them tuples =)
05:22:09 <watermind> not only would be nice to have data kind and data type,  but also instead of just type A =...  make it   alias type A = ...  and  alias kind A = ...
05:22:13 <mm_freak> x :+ y :+ z :+ …
05:22:13 <fmap> larsrh: should be possible with standalone deriving
05:22:15 <malorie> more like arbitrarily sized ones, no?
05:22:34 <elliott> mm_freak: FSVO provides
05:22:40 <elliott> you can't actually use ones bigger than a certain size
05:22:41 <mm_freak> FSVO?
05:22:54 <luite> mm_freak: hm does it? I thought the tuple limit was 63 for some reason
05:22:57 <robbe-> mm_freak: for some value of
05:22:58 <mm_freak> finite state vomitting orally?
05:23:09 <mm_freak> ah, thanks
05:23:33 <mm_freak> luite: in h98 yes, in GHC no
05:23:38 <elliott> mm_freak: try it.
05:23:46 <elliott> you can check the type of a 70-length tuple
05:23:48 <elliott> it won't work as a value
05:23:53 <elliott> unless it changed recently
05:24:02 <mm_freak> it should
05:24:04 <ToranLipse> Slightly off topic (Sorry!), but what kind of languages would a PDA recognise if at any transition it could read the whole stack and not just the top element?
05:24:10 <elliott> It didn't, for a very long time
05:24:29 <elliott> <interactive>:2:9:
05:24:29 <elliott>     A 1829-tuple is too large for GHC
05:24:29 <elliott>       (max size is 62)
05:24:29 <elliott>       Workaround: use nested tuples or define a data type
05:24:38 <elliott> looks like it still doesn't.
05:24:43 <luite> oh even less than 63!
05:24:49 <luite> uh, than 63
05:24:57 <elliott> yes, how will we cope with our tiny 62-tuples?!
05:24:58 <mm_freak> > show (1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1)
05:24:58 <malorie> heh
05:24:59 <lambdabot>   A 70-tuple is too large for GHC
05:24:59 <lambdabot>    (max size is 62)
05:24:59 <lambdabot>    Workaround: use nest...
05:25:01 <elliott> that's not enough for lisp
05:25:04 <mm_freak> wow, indeed
05:25:17 <elliott> mm_freak: I did not forge an error message to trick you :P
05:25:30 <mm_freak> let me try it locally, just to convince myself =P
05:25:46 <mm_freak> same =)
05:26:08 <mm_freak> well, nobody uses 70-tuples (obviously)
05:26:44 <mm_freak> anyway with DataKinds it's easy to make an arbitrary-size tuple
05:28:44 <mm_freak> data Tuple :: [*] -> * where Cons :: a -> Tuple xs -> Tuple (a ': xs); Nil  :: Tuple '[]
05:28:45 <larsrh> fmap: the error message tells me that the constructors have to have a Haskell-98 type
05:29:02 <mm_freak> that also allows a more sensible type for 'fst'
05:29:18 <mm_freak> fst :: Tuple (a ': as) -> a
05:29:52 <mm_freak> also my naming is kinda screwed up =)
05:30:53 <elliott> :t _1
05:30:54 <lambdabot> (Functor f, Field1 s t a b) => (a -> f b) -> s -> f t
05:32:38 <hpaste> larsrh pasted “Typeable + GADTs” at http://hpaste.org/78810
05:33:10 <larsrh> fmap: http://hpaste.org/78810
05:34:57 <elliott> try using a standalone deriving
05:35:01 <elliott> deriving instance Typeable Arguments
05:35:04 <elliott> deriving instance Data Arguments
05:35:42 <mm_freak> does anyone else use StandaloneDeriving solely for the sake of more beautiful code?
05:36:27 <fmap> larsrh: "standalone" wasn't a noise in my reply ;)
05:37:45 <larsrh> standalone deriving doesn't like the kind *->* type parameter
05:53:34 <mapf> it's interesting why base doesn't contain some pretty printing lib. I mean that there is no some *standart* pretty printing library or at least some class like Pretty
05:53:39 <mapf> :i Pretty
05:53:45 <mapf> @src Pretty
05:53:45 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
05:53:58 <elliott> well, pretty printing is hard
05:54:02 <elliott> base is big but it shouldn't be that big :)
05:54:19 <b_jonas> what's the Bounded class really for?
05:54:27 <b_jonas> the Typeclassopedia doesn't mention it
05:54:32 <elliott> > minBound :: Int8
05:54:33 <lambdabot>   -128
05:54:35 <elliott> > maxBound :: Int8
05:54:36 <lambdabot>   127
05:54:39 <elliott> > minBound :: Char
05:54:41 <lambdabot>   '\NUL'
05:54:42 <elliott> > maxBound :: Char
05:54:43 <lambdabot>   '\1114111'
05:54:46 <b_jonas> yes, I know that's the methods it contains
05:54:51 <b_jonas> but what's the goal of that class?
05:54:54 <ramses_> b_jonas: for types that have an upper and lower bound, like Int and Char
05:54:55 <elliott> i was hoping to elucidate by example
05:54:57 <elliott> well, bounded enumerations
05:55:02 <elliott> finite enumerated types
05:55:07 <ramses_> b_jonas: for those types you can check what the bounds are
05:55:10 <elliott> > (minBound, maxBound) :: (Bool, Bool)
05:55:12 <lambdabot>   (False,True)
05:55:44 <b_jonas> are there any library functions with a Bounded restriction somewhere in their type?
05:55:48 <mapf> elliott: heh. maybe there are should be some metapackage which reexport recommended standartized packages then
05:56:29 <ramses_> :t minBound
05:56:30 <lambdabot> Bounded a => a
05:56:33 <ramses_> ;)
05:56:37 <mapf> or at least some classes to designed as generalized interfaces
05:56:53 <b_jonas> ramses_: ok, but apart from those two methods?
06:02:38 <nus> @instances Bounded
06:02:39 <lambdabot> (), (a, b), (a, b, c), All, Any, Bool, Char, Dual a, Int, Ordering, Product a, Sum a
06:16:15 <navaati> hi
06:17:23 <navaati> for instances of Read and Show derived by ghc, read . show = id should hold, right ?
06:17:49 <navaati> (yuros, dafuk ? are you a misbehaving bot ?)
06:18:23 <TheShamanoid> guys is there a way to call a  variable/type such that when it is called in another function, it is automatically calculated? without giving it any type of input in that function?
06:18:38 <TheShamanoid> -_-
06:18:45 <Botje> that .. didn't make sense.
06:19:38 <TheShamanoid> hold i will paste an example code on hpaste
06:21:15 <TheShamanoid> wtf, who is this yuros that keeps calling my posts bullshit?
06:21:47 <Botje> hmm, maybe it only annoys newly joined users?
06:22:15 <Botje> doesn't seem to talk to me.
06:22:44 <Botje> TheShamanoid: what did it say to you?
06:23:23 <companion_cube> test
06:23:31 <elliott> will just be some dumb bot.
06:23:32 <companion_cube> didn't annoy me...
06:23:36 <elliott> @where ops
06:23:37 <lambdabot> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
06:23:51 <peteriserins> when creating an Expression data type with GADTs, how to introduce typed variables?
06:23:58 <Saizan> what's happening?
06:24:14 --- mode: ChanServ set +o quicksilver
06:24:21 <quicksilver> who? yuros?
06:24:29 * quicksilver tries to provoke it, if it is a bot
06:24:30 <elliott> so says navaati and TheShamanoid
06:24:57 <elliott> some user/bot apparently insulting people in /msg after they say things (but only newly-joined people? so maybe not a bot)
06:25:23 <beaky> hello
06:25:41 <elliott> (bots that bother people seem to be rather persistent in here and on freenode in general. what a waste of time)
06:26:13 <quicksilver> there was one the other day
06:26:21 <navaati> well, the worse is that it claims to be a freenode op : message is
06:26:24 <navaati> "for your information, you just pasted " for instances of Read and Show derived by ghc, read . show = id should hold, right ? " in #haskell which is pure bullshit. don't do it again, thanks. Freenode Staff Team."
06:26:49 <TheShamanoid> Here is a screenshot   http://i49.tinypic.com/2wnxsae.png
06:26:50 <quicksil1er> testing....
06:27:25 <elliott> at least it is immature enough that nobody will believe it
06:27:36 <beaky> a rogue bot?
06:27:51 <elliott> 14:27:08 -yuros(~yuros@146.185.24.207)- for your information, you just pasted " at least it is immature enough that nobody will believe  it " in #haskell which is pure bullshit. don't do it again, thanks. Freenode Staff Team.
06:27:58 <elliott> looks like it hates me too now
06:27:58 <beaky> lol
06:28:06 <elliott> oh, it's doing it for every line I say.
06:28:18 <elliott> I wonder what you have to say to get it to start
06:28:21 <quicksil1er> very odd
06:28:26 <beaky> I wanna play with it :D
06:28:35 --- kick: yuros was kicked by quicksilver (yuros)
06:28:40 <elliott> maybe if someone else says "at least it is immature enough that nobody will believe it" that will set it off for them too
06:28:43 <elliott> aww, the science is over
06:28:46 <beaky> :(
06:29:02 <TheShamanoid> quicksilver: Thanks :D
06:29:08 <quicksilver> np
06:29:10 <quicksilver> odd, though
06:30:03 <FireFly> Seems like it's causing problems in other channels too, going by #freenode backlog
06:30:13 <FireFly> Well, #gentoo at least
06:30:36 <TheShamanoid> guys is there a way to call a  variable/type such that when it is called in another function, it is automatically calculated? without giving it any type of input in that function?
06:31:27 <nus> make sense?
06:31:48 <ramses_> TheShamanoid: sounds like mutability, or do I get you wrong? Not sure if I get what you mean
06:32:32 <Philippa_> that or a term-that-is-not-yet-a-value
06:32:39 <Philippa_> (as in, hello laziness)
06:33:06 <TheShamanoid> hold on, i will post an example on hpaste
06:33:29 <watermind> Control.Applicative.some and Control.Applicative.many
06:33:39 <ramses_> ah, like lazy initialization of constants?
06:33:58 <watermind> ops I meant, what is the purpose of Control.Applicative.some and Control.Applicative.many?
06:34:36 <watermind> was looking at their definitions, but seems a bit cryptic
06:35:20 <watermind> take 1 $ fmap (take 1) many [1]   -- doesn't return anything
06:36:27 <fmap> watermind: they are quite useful in parsing
06:39:08 <Jafet> ...and nowhere else
06:43:22 * hackagebot doctest 0.9.4.1 - Test interactive Haskell examples  http://hackage.haskell.org/package/doctest-0.9.4.1 (SimonHengel)
06:43:35 <hpaste> Shamanoid pasted “Example” at http://hpaste.org/78811
06:45:38 <TheShamanoid> guys can anyone look at the posted example and tell me if it is in any way possible?
06:46:12 <Clint> TheShamanoid: what is Reds
06:47:08 <fmap> TheShamanoid: what do you suppose to lookup from type?
06:48:31 <TheShamanoid> Clint: it is a of type (Bool, String) -> Representation -> Bool
06:48:38 <ramses_> TheShamanoid: how would you lookup data without having it supplied somehow?? Or did you left htat part out?
06:48:59 <TheShamanoid> all i want to do is for the database defined earlier to be computer and once it is called inside the function
06:49:40 <typoclass> TheShamanoid: fromJust is probably not what you want. i think you're better off by doing "f (_, x) = case lookup x d of Just r -> r". if lookup gives Nothing, this will stop your program, but it'll tell you the line number and stuff. and you're later able to turn on compiler warnings to flag all the places where you did something like that. fromJust will just crash without much explanation
06:49:44 <ramses_> could the reader monad help here somehow? Write your functions inside reader and supply the database when calling it?
06:50:06 <TheShamanoid> the function database takes in a string and then outputs the corrosponding database which i want to lookup
06:50:56 <TheShamanoid> but i dont want to pass the string through the function i posted
06:50:58 <clahey> edwardk: I've been thinking about other parsers that could be MonadParsers.
06:51:15 <clahey> edwardk: I'm pretty sure you could do a non deterministic one.
06:51:21 <ramses_> Ah you want to return a database based on a string? Like with a map of databases?
06:52:00 <TheShamanoid> ramses_: that has already been done using a function called database.
06:52:08 <clahey> edwardk: But because of the monad effect and because you can pass in functions, there's no way to make a MonadParser that, for example, does analysis on the parser itself.
06:52:51 <ramses_> and you'd like the database function to memoize the database?
06:52:59 <TheShamanoid> ramses_: i want to use this function inside another function but the twist is, i dont want to pass to it the string in that function,i want it to be calculated outside and then fed into the function once it is required
06:53:25 <TheShamanoid> typoclass: Thanks. Will try to use this
06:54:29 <ramses_> so the string is like a global variable then? Or where does it come from?
06:54:46 <TheShamanoid> something like variable_x = fromList [(t,y), (s,r)]
06:54:59 <beaky> http://ideone.com/9f5VqM I am writing a tic-tac-toe game in Haskell :D I have finished implementig the Board data structure. anyone willing to criticize it? :D
06:55:03 <TheShamanoid> but instead, this variable is calculated using a function called database
06:57:10 <ramses_> I'm afraid I don't see how your dataflow is supposed to work... The function needs a database which is obtained by calling the database function, but this function takes an argument which you want to be implicit in the current function?
06:57:27 <Sculptor> yo
06:57:32 <beaky> hai
06:57:50 <TheShamanoid> ramses_: Yeh, is this even possible?
06:58:22 * hackagebot lifted-base 0.2.0.1 - lifted IO operations from the base library  http://hackage.haskell.org/package/lifted-base-0.2.0.1 (BasVanDijk)
06:59:30 <ramses_> I think you could achieve something like that using the reader monad
06:59:47 <fmap> beaky: are you going to write corresponding Read instance?
06:59:55 <beaky> yes
07:01:28 <TheShamanoid> ramses_: thanks, will search it on google
07:02:42 <fmap> beaky: nice; and I guess you won't restrict all boards to be 3x3?
07:03:10 <eacameron> are there any tutorials on how to debug stack overflows? I am lost on my 50 line program.
07:03:38 <beaky> fmap: how do I unrestrict it? :D
07:06:35 <fmap> beaky: well, given that array index is Int nobody stops you from calling `board ! 10' already
07:06:43 <beaky> oh
07:06:58 <fmap> beaky: If you want only 3x3 board you may want to use custom type as index
07:07:01 <beaky> I will write a wrapper function :D
07:11:23 <beaky> all problems can be solved with an extra layer of indirection
07:12:55 <quicksilver> beaky: unless the problem statement is "we have too much indirection"
07:19:10 <osfameron> hehe
07:20:12 <edwardk> clahey: check my parsers package, which is designed so it can be used for alternative parsing as well
07:20:42 <Kosta> What does an exclamation point do in haskell, e.g. here: https://github.com/bos/attoparsec/blob/master/examples/RFC2616.hs ?
07:20:55 <hpaste> ramses_ pasted “Implicit argument” at http://hpaste.org/78812
07:21:03 <Botje> Kosta: it makes the field strict.
07:21:04 <ramses_> TheShamanoid: ^
07:21:17 <ramses_> very rough, I don't have a haskell install nearby
07:21:39 <ramses_> also not 100% sure if this is what you're after
07:21:41 <Kosta> Botje: ok... I'll accept that for now :)
07:21:41 <clahey> edwardk: What I'm thinking of doing is taking a generic bnf and attempting to turn it into a LL(1).
07:21:49 <Kosta> Botje: thanks!
07:21:52 <clahey> edwardk: Unfortunately, the spec I'm working with specifies "longest match"
07:22:12 <clahey> So that at every point, you find the production that uses up the most characters.
07:24:47 <neutrino> Kosta: the ghc wiki has a list of all keywords that exist in haskell or ghc. it lists all possible uses of the bang. http://www.haskell.org/haskellwiki/Keywords
07:26:10 <Botje> Kosta: that means that, if you create a new Request object, its fields are immediately evaluated.
07:26:12 <Kosta> neutrino: thanks, that is very helpful
07:26:29 <neutrino> i ran into it last sunday myself
07:26:48 <Kosta> Botje: ok, that makes sense, it also means that haskell is getting more complex for me by the minute :)
07:29:42 <TheShamanoid> ramses_: I just gave it a read. It is doing something similar to what i want, but not exactly. I will play around with it until it works for me. Thank you very much!
07:29:58 <Botje> Kosta: you can ignore it for the most part, it's a cure for "being too lazy"
07:30:37 <ramses_> TheShamanoid: np, the do block in 'function' is redundant by the way, saw it after I posted it :) The one in g is the important one, hiding an argument to the body
07:30:42 <Kosta> Botje: :)
07:31:55 <TheShamanoid> ramses_: yeh, i was wondering where "id" comes from
07:32:28 <ramses_> TheShamanoid: I mashed it up very quickly :)
07:32:29 <ParahSailin> creatures from the id
07:33:27 <TheShamanoid> ramses_: no problem, thank you for being kind and doing it in the first place. :D
07:33:44 <ramses_> you can remove the do block, give the function an explicit argument for s and put the argument to return as the function body
07:35:14 <ramses_> or even better: function x = lookup x . fromJust . database
07:36:11 <neutrino> :t database
07:36:13 <lambdabot> Not in scope: `database'
07:36:16 <neutrino> .
07:39:03 <pmade> I'm writing a lib to interact with a web service.  Based on other API packages on hackage I should put it in Network.X.API, but I feel like Network.API.X would be better.  Thoughts?
07:39:25 <Mortchek> Is there a function :: Int -> [a] -> Maybe a analogous to (!!)?
07:39:48 <Clint> pmade: i've been using Network.Protocol.HTTP.X and such
07:40:19 <pmade> Clint: that's one interesting idea.
07:40:21 <TheShamanoid> ramses_: Thanks, it works.
07:40:46 <Clint> pmade: it fits http://www.haskell.org/haskellwiki/Hierarchical_module_names at least
07:41:08 <ramses_> TheShamanoid: happy to help
07:41:13 <pmade> Clint: thanks for the link.
07:42:00 <pmade> Clint: doesn't this suggest that Network.HTTP is wrong?
07:42:49 <Clint> pmade: it suggests that the majority of hackage is wrong
07:43:10 <pmade> :)
07:43:30 <pmade> Good to know.
07:44:24 <typoclass> well "wrong" suggests there were a single absolute unassailable truth ...
07:45:58 <Clint> typoclass: that's generally what an implied policy suggests
07:46:06 <typoclass> pmade: if you ask me, both Network.X.API and Network.API.X are plausible
07:46:37 <pmade> typoclass: of those I think Network.API.X makes more sense, unless X was huge or something.
07:46:54 <pmade> But now I'm considering Network.HTTP.X or Network.Protocol.HTTP.X
07:47:09 <pmade> While the Protocol one sounds nice, it's a bit deep.
07:47:28 <typoclass> Clint: i think there's a spectrum from very bad choices to very good choices. as long as you're somewhere in the second half ...
07:48:16 <Clint> i think it would be nice if things weren't so free-form
07:50:08 <beaky> I love how haskell lets you overload arbitrary operators (besides equal sign and some others)
07:51:33 <quicksilver> haskell lets you override (and overload) all operators.
07:51:39 <quicksilver> = is not an operator.
07:51:53 <beaky> oh
07:52:19 <beaky> = means definition if I'm not mistaken
07:52:35 <beaky> == is up for grabs though :D
07:53:14 <ramses_> if '=' could somehow be overloaded, haskell programs could get very hard to understand
07:53:59 <beaky> right
07:54:00 <clahey> What other symbols are not operators?
07:54:03 <clahey> |
07:54:10 <Clint> <-
07:54:12 <clahey> []
07:54:18 <clahey> ->
07:54:28 <ramses_> ( and )
07:54:32 <beaky> " and '
07:54:45 <ramses_> ::
07:54:49 <clahey> @
07:54:54 <ramses_> _
07:54:54 <beaky> #
07:55:06 <ramses_> ;
07:55:11 <ramses_> { and }
07:55:20 <clahey> So, there's a ton of them.  :)
07:55:30 <beaky> btw nice how I can stick '#!/usr/bin/env runhaskell' on top of my haskell programs and turn it into a script :D
07:55:34 <Entroacceptor> space :)
07:56:08 <ramses_> Entroacceptor: you could now start mentioning a big part of the ascii table ;)
07:56:30 <clahey> Entroacceptor: Not a symbol.
07:56:41 <clahey> Does lambdabot have a command to look up character classes?
08:00:40 <mapf> Entroacceptor: space is application operator :)
08:00:57 <pmade> Are there any guidelines for the banner that goes at the top of a source file that contains the module name, copyright, stability, etc.?
08:01:26 <mapf> isn't it should be in cabal?
08:01:44 <typoclass> > generalCategory '/' -- clahey: from Data.Char
08:01:45 <lambdabot>   OtherPunctuation
08:02:13 <pmade> I would think this would only need to be in the cabal file, but many popular libraries on hackage have this sort of thing in every source file.
08:02:45 <Clint> that's probably due to legal advice
08:03:25 <Clint> pmade: https://www.softwarefreedom.org/resources/2012/ManagingCopyrightInformation.html
08:03:33 <clahey> > generalCategory ' '
08:04:00 <lambdabot>   Space
08:04:00 <pmade> I get having the copyright and license, but what about Portability and Stability, what's up with that?
08:04:14 <Clint> i was under the impression that those were considered deprecated
08:04:15 <Entroacceptor> mapf: is that really an operator?
08:04:30 <Entroacceptor> mapf: it's a special symbol, and you can't overwrite it, can you?
08:04:32 <Entroacceptor> :t ( )
08:04:33 <lambdabot> ()
08:04:35 <Eidel> Can you pattern match on anonymous functions?
08:04:49 <monochrom> what does that mean?
08:05:21 <Clint> Eidel: \(Right x) -> x+2
08:05:26 <pmade> Clint: thanks.  I'll read that document and use it as a guide.
08:05:50 <Eidel> Clint: Ok, thx
08:06:06 <Clint> but you can only have one pattern
08:06:29 <Eidel> Thats too bad =)
08:07:52 <monochrom> then you mean "in", not "on"
08:08:05 <Eidel> Aha
08:08:07 <Eidel> Good to know
08:08:24 * hackagebot hspec-meta 1.4.3 - A version of Hspec which is used to test Hspec itself  http://hackage.haskell.org/package/hspec-meta-1.4.3 (SimonHengel)
08:09:31 <ramses_> Eidel: if you want multiple patterns you can just use case
08:10:33 <clahey> Entroacceptor: It's not an operator at all.
08:11:47 <ramses_> Entroacceptor: I guess it's more like a syntactic rule. It's certainly not an operator. And ( ) gets interpreted as (), the empty tuple
08:12:55 <Eidel> ramses_: that is true!
08:13:19 <parcs`> > do do Nothing; Nothing
08:13:21 <lambdabot>   Nothing
08:14:14 <ramses_> > do do Nothing; undefined
08:14:14 <lambdabot>   Nothing
08:21:20 <clahey> > do do Nothing
08:21:22 <lambdabot>   Nothing
08:21:39 <clahey> > do Nothing
08:21:40 <lambdabot>   Nothing
08:22:15 <ion> > do do do do do do do do do do do do do do do do batman
08:22:17 <lambdabot>   batman
08:22:23 <Jafet> Just (do it)
08:23:24 * hackagebot HGamer3D 0.1.10 - Windows Game Engine for the Haskell Programmer  http://hackage.haskell.org/package/HGamer3D-0.1.10 (PeterAlthainz)
08:25:20 <t7> > (\(Just _) -> (); \Nothing -> ())
08:25:22 <lambdabot>   <hint>:1:17: parse error on input `;'
08:28:51 <clahey> >do (do Nothing; undefined); undefined
08:29:09 <Mortchek> > let shoo = fmap; bee = id; wop = return () in shoo bee $ do wop
08:29:10 <lambdabot>   No instance for (GHC.Show.Show (f0 ()))
08:29:10 <lambdabot>    arising from a use of `M73523949...
08:29:34 <Mortchek> It worked in ghci :/
08:29:47 <Mortchek> Oh, it's IO, isn't it?
08:29:50 <clahey> > do (do Nothing; undefined); undefined
08:29:51 <lambdabot>   Nothing
08:30:01 <clahey> Ah, the space is required.
08:31:01 <clahey> Mortchek: It's any Monad.
08:31:11 <clahey> I think it's equivalent to return ()
08:31:25 <sioux_> is there (especially for beginners) any reasonable difference between hugs and ghci?
08:31:42 <Mortchek> clahey, I got that - but ghci chooses one by default, I think IO.
08:31:47 <clahey> Mortchek: Right.
08:31:56 <Mortchek> And I guess lambdabot does too, but it (wisely) doesn't want to run IO.
08:32:31 <eikke> > putStrLn $ show (1 :: Int)
08:32:33 <lambdabot>   No instance for (GHC.Show.Show (GHC.Types.IO ()))
08:32:33 <lambdabot>    arising from a use of ...
08:32:45 <andsens> Is there a way to group several constructors in one pattern match?
08:33:24 * hackagebot stylish-haskell 0.5.5.1 - Haskell code prettifier  http://hackage.haskell.org/package/stylish-haskell-0.5.5.1 (JasperVanDerJeugt)
08:33:26 * hackagebot blaze-markup 0.5.1.3 - A blazingly fast markup combinator library for Haskell  http://hackage.haskell.org/package/blaze-markup-0.5.1.3 (JasperVanDerJeugt)
08:34:03 <b_jonas> these type system extensions are confusing
08:34:39 <andsens> Were the two links intended for me?
08:34:55 <Mortchek> No, those were automatically sent when someone updated those packages.
08:35:14 <andsens> oh, ok. Heh, that's cool
08:36:10 <Mortchek> What do you mean when you say group several constructors? Maybe give some example constructors?
08:36:25 <Mortchek> or example patterns
08:36:46 <hpaste> andsens pasted “counting offsets” at http://hpaste.org/78813
08:37:12 <andsens> as you can see, the last three patterns do exactly the same thing
08:37:22 <andsens> and so do the first two
08:38:24 * hackagebot blaze-html 0.5.1.2 - A blazingly fast HTML combinator library for Haskell  http://hackage.haskell.org/package/blaze-html-0.5.1.2 (JasperVanDerJeugt)
08:38:29 <Mortchek> I'm not sure, but I think you can just _ them for the last three at least
08:38:49 <Mortchek> Instead of (P.XMLTag{}) etc., use _
08:39:05 <andsens> hm, true.
08:39:26 <Mortchek> What is r in the first cases?
08:39:31 <Mortchek> Anything?
08:40:01 <andsens> It's so I know whether I can go left.
08:40:14 <andsens> Ups, which means I should check l:ls instead, haha
08:40:45 <andsens> to answer your question, left and right siblings
08:40:48 <b_jonas> what's lambdabot's syntax for asking for the library definition of an instance?
08:43:21 <geekosaur> @src (>>=) Maybe
08:43:22 <lambdabot> Source not found. The more you drive -- the dumber you get.
08:43:31 <geekosaur> unless I got that backwards or something
08:43:37 <geekosaur> @src Maybe (>>=)
08:43:38 <lambdabot> (Just x) >>= k      = k x
08:43:38 <lambdabot> Nothing  >>= _      = Nothing
08:43:53 <geekosaur> note that the @src database is a bit sparse
08:43:54 <b_jonas> thanks
08:44:07 <b_jonas> @src MonadFix []
08:44:07 <lambdabot> Source not found. stty: unknown mode: doofus
08:45:28 <Mortchek> !src [] mfix
08:45:32 <Mortchek> @src [] mfix
08:45:32 <lambdabot> mfix f = case fix (f . head) of
08:45:32 <lambdabot>            []    -> []
08:45:32 <lambdabot>            (x:_) -> x : mfix (tail . f)
08:45:47 <geekosaur> see "a bit sparse".  there is a lot of stuff missing from it
08:55:00 <jstar> hi, I installed ghc-mod for Emacs which made it always enable Flymake mode when opening .hs files. The constant saving of files really annoys me. I completely removed ghc-mod but Flymake still gets enabled everytime I open a Haskell source file. How can I disable it?
08:55:34 <TheShamanoid> guys how can i solve such an error :     Possible fix: add an instance declaration for (Read DataBase) where DataBase is a type i defined
08:56:21 <scp> why do I get
08:56:39 <scp> > (toInteger . sqrt . fromInteger) (75 :: Integer)
08:56:41 <lambdabot>   Ambiguous type variable `a0' in the constraints:
08:56:41 <lambdabot>    (GHC.Float.Floating a0)...
08:57:30 <scp> I don't use any type variables, how do I have an ambiguous one
08:57:30 <scp> ?
08:57:34 <geekosaur> scp:  there are several possible types that sqrt could have there; you need to pick one
08:57:53 <scp> oh, I guess that makes sense. How does it know to call the double or float version x_X
08:57:58 <scp> geekosaur:  thanks
08:58:16 <scp> (toInteger . (sqrt :: Double -> Double) . fromInteger) (75 :: Integer)
08:58:24 <scp> > (toInteger . (sqrt :: Double -> Double) . fromInteger) (75 :: Integer)
08:58:25 <lambdabot>   No instance for (GHC.Real.Integral GHC.Types.Double)
08:58:25 <lambdabot>    arising from a use ...
08:58:44 <scp> eh, I'll debug in my own interpreter =P
08:59:07 <clahey> scp: You can also msg lambdabot directly.
08:59:53 <b_jonas> scp: you can't use toInteger to convert a Double to anything
09:01:04 <scp> ya, meant to use truncate
09:01:10 <scp> thanks all =]
09:01:26 <clahey> > floor . sqrt . fromInteger $ 75 :: Integer
09:01:28 <lambdabot>   8
09:02:10 <TheShamanoid> guys read can change the type of a string to anything right?
09:02:29 <Entroacceptor> :t read
09:02:30 <lambdabot> Read a => String -> a
09:03:11 <Adeon> anything that implements Read typeclass shown above
09:03:35 <TheShamanoid> Entroacceptor: i am trying to change a string to a type i created but it is giving me an error
09:03:53 <TheShamanoid> Adeon: how do i force my type to implement the read typeclass?
09:03:55 <Entroacceptor> TheShamanoid: read doesn't change types, it gives back another value
09:04:28 <TheShamanoid> Entroacceptor: yeh, i know,it gives back another value of a different type
09:05:05 <TheShamanoid> Entroacceptor: so read "12"::Int  takes a string and gives back an Int
09:05:46 <tac> TheShamanoid: read is the thing doing the taking. read "12" is just an Int.
09:06:30 <Entroacceptor> TheShamanoid: you have to make your type belong to the Read typeclass
09:06:58 <Entroacceptor> either by using "deriving Read", or by implementing your own read function
09:25:00 <mreh> QUICK SPAM THE CHANNEL
09:25:25 * hiptobecubic coughs
09:25:33 <mreh> just kidding
09:27:43 <mreh> is there some lightweight persistent storage a bit like acid-state, but without the ACID guarantees?
09:27:54 <mreh> and none of the boilerplate
09:28:04 <Clint> binary/cereal?
09:28:04 <mreh> or all the ACID guarantees and none of the boilerplate?
09:28:40 <Clint> persistent-*?
09:29:14 <mreh> like if my application fails or I kill it I can get it back
09:29:27 <mreh> but it's fast
09:29:59 <mreh> I haven't really investigated just writing it out to a file and resuming from that
09:30:18 <mreh> I was wondering if anyone already had a solution
09:30:29 <mreh> or library
09:32:14 <sclv> mreh: I've done this in the past but not packaged it
09:32:37 <sclv> The idea is I just write an mvar wrapper with a binary constraint
09:32:44 <sclv> and it also takes a filename on spawn
09:33:02 <sclv> it tries to deserialize from the file and failing that starts with the default value
09:33:26 * hackagebot hspec 1.4.3 - Behavior-Driven Development for Haskell  http://hackage.haskell.org/package/hspec-1.4.3 (SimonHengel)
09:33:29 <sclv> then on every write it pushes an async thread to do an atomic write of the file
09:33:43 <sclv> it would be a nice pattern to package up if you end up doing it
09:33:59 <mreh> sclv, yes, it's more or less what redis does
09:34:11 <sclv> oh, cute, i didn't know that
09:34:41 <sclv> the other trick is if you really have a persistent map (e.g. for session state or the like) then you take a directory instead of a file
09:34:52 <sclv> and each key maps to a file in the directory
09:35:00 <sclv> so you can lazily load persisted data
09:35:03 <mreh> that's neat
09:35:40 <mreh> I was thinking how hard it would be to rewrite existing records
09:35:48 <mreh> but that's what a filesystem does
09:38:37 <sclv> mreh: yep, and if things get out of hand you can move to bdb
09:41:14 <booski> Is there a shorthand for `either f id'?
09:44:15 <quchen> booski: I don't think so
09:48:38 <bitonic> booski: fmap does the opposite (either id f)
09:48:41 <bitonic> just so you know
09:52:29 <FireFly> @hoogle Either a b -> Either b a
09:52:29 <lambdabot> Network.Stream bindE :: Result a -> (a -> Result b) -> Result b
09:52:29 <lambdabot> Data.Graph.Inductive.Basic unlab :: DynGraph gr => gr a b -> gr () ()
09:52:29 <lambdabot> Data.Graph.Inductive.Graph gmap :: DynGraph gr => (Context a b -> Context c d) -> gr a b -> gr c d
09:52:36 <FireFly> :(
09:52:47 <parcs`> there's something called a bifunctor
09:53:21 <parcs`> http://hackage.haskell.org/packages/archive/bifunctors/3.0/doc/html/Data-Bifunctor.html#v:first
09:56:43 <bitonic> can I have top-level conditionals in cabal?
10:07:49 <bitonic> edwardk: just to know, what’s new in bound 0.5.0.2?
10:07:58 <edwardk> nothing, just dependency bounds
10:08:02 <bitonic> OK, thanks
10:08:11 <edwardk> it was released so i could put it on stackage
10:08:46 <edwardk> in general in any of my packages x.y.z.w  if i bump 'w' nothing changed in the main package, just documentation, test improvements or dependency bounds
10:09:53 <bitonic> edwardk: OK
10:14:21 <mapf> which another name for fixed point type operator called mu? I forgot the notation completely
10:18:35 <applicative> mapf  you mean within haskell? or in some technical literature. In haskell sometimes Fix f, Rec f, Mu f   ...
10:19:16 <applicative> the important thing is the constructor and deconstructor :)
10:19:46 <applicative> newtype Mu f = In {out :: f (Mu f)}
10:19:49 <mapf> not in Haskell, in type theory. I just read http://en.wikibooks.org/wiki/Haskell/Zippers
10:20:36 <mapf> sorry, here is more convinient link: http://en.wikibooks.org/wiki/Haskell/Zippers#Differentation_of_Fixed_Point
10:23:51 <TheShamanoid> guys, if i have a function that outputs a string that represents another function in my code. How do i convert the string to the function?
10:24:23 <applicative> mapf, that is a confusing symbolism with the mu
10:25:03 <mapf> TheShamanoid: Haskell becomes a Lisp?
10:25:12 <mapf> or you are using TH?
10:25:15 <Zetetic> Yay!
10:25:17 <Zetetic> What?
10:25:20 <chreekat> haha
10:25:29 <TheShamanoid> mapf: is that possible?
10:25:49 <applicative> TheShamanoid: what do you mean, ''the string represents a function"?
10:25:52 <mapf> applicative: why?
10:26:18 <applicative> muX muF muFX
10:26:22 <TheShamanoid> applicative: String is "function1" and i have function1 in my code
10:26:50 <TheShamanoid> i tried using Read but eventually gave up, fixing one error results in two new ones
10:27:20 <applicative> g str = case str of "function1"  -> function1; _ -> error "not function1"
10:27:23 <mapf> applicative: actually i get confused by that article and i decide find out i forgot something...
10:28:35 <TheShamanoid> actually nevermind, i will use guards, such that if i get a string, i run said function. Since there are a few of them, won't be an issue
10:29:16 <quchen> TheShamanoid: You can't do that in Haskell in general. (Of course you can write a case statement a la 'case "foobar" of "function1" -> function1; ...'.) The reason for this is that "converting a string to a function" requires modifying the code during runtime, which is pretty much impossible in a compiled language.
10:29:24 <mapf> TheShamanoid: maybe you would like to use Map also
10:30:16 <mapf> Map Text (a -> a) for exsample
10:30:18 <TheShamanoid> quchen: Can't i say if "function1" then function1 else ....
10:30:22 <applicative> TheShamanoid: right, that's what I was imagining.  Obvious moving directlly from "function1" to function1in another way would involve template haskell or some nonsense
10:30:23 <quchen> TheShamanoid: Why don't you let the string-returning function return the function (and not its name) in the first place?
10:31:00 <quchen> TheShamanoid: Yes, you can do that. What you cannot do is 'toFunction "odd" 1' to calculate 'odd 1'.
10:31:08 <TheShamanoid> quchen: because different inputs to the original function result in outputting a different function
10:32:10 <quchen> Functions are as valid as strings as return types.
10:32:42 <quchen> f p = if p then odd else even
10:32:59 <quchen> ==> f True 1 == odd 1 == False
10:33:08 <quchen>     f False 1 == even 1 == True
10:36:11 <applicative> TheShamanoid: is it somehow the user who is giving you "function1"; if not it's hard to see why it would be needed as quchen is saying
10:39:35 <dgpratt> when I try to "cabal-dev ghci", I get the same error as reported here: https://github.com/creswick/cabal-dev/issues/50#issuecomment-10054111
10:40:51 <quchen> applicative: Even if "function1" comes from the user, the input has to be parsed somewhere. That parsing should do the checking and the conversion.
10:40:58 <dgpratt> has anyone here been able to use that command successfully?
10:42:19 <applicative> quchen: yes, thats what I would have said if it did come from the user
10:42:27 <TheShamanoid> applicative: yup, the user is the one who is picking the function
10:43:09 <TheShamanoid> quchen: the input does get parsed and i end up with a string. That's why i needed the conversion
10:48:16 <typoclass> dgpratt: folks have repeatedly talked about it in here. it seems like a common problem. possibly everyone has it
10:48:21 <augur> is shan on irc ever?
10:48:27 <typoclass> lispy: hiya :-) you around?
10:48:28 <dgpratt> typoclass: ok, thanks
10:48:29 <krautguy> i need a working example for the use of "lines" and "unlines" in order to understand the functionality.. does anyone have one?
10:49:07 <typoclass> krautguy: 'lines' takes a string and splits it at all the newlines (\n)
10:49:10 <typoclass> @type lines
10:49:11 <lambdabot> String -> [String]
10:49:33 <dgpratt> if I build something with cabal-dev, is there another way to "poke" at it with ghci?
10:49:35 <typoclass> krautguy: does that make any sense?
10:49:54 <lispy> typoclass: kinda. What's up?
10:50:16 <parcs`> dgpratt: you have to alter the path of the package database using the -package-db flag
10:50:34 <krautguy> i can read several strings with "lines" and put them into a list of strings?
10:50:35 <dgpratt> parcs`: ah, ok, I'll try that
10:50:38 <dgpratt> thanks
10:51:17 <typoclass> lispy: is there a new cabal-dev release coming? i _think_ i remember you mentioning it a few days ago
10:52:46 <lispy> typoclass: We're having some problems with our internal CI build system that is holding up the release
10:53:01 <typoclass> lispy: ah i see :-) thanks a lot
10:53:31 <applicative> does https://github.com/dagit/cabal-dev solve dgpratt 's problem?
10:54:52 <dgpratt> applicative: it certainly looks like it might
10:55:46 <dgpratt> for some reason, building and installing from source still makes me nervous
10:57:14 <dgpratt> even sticking with cabal install, I've made an unreparable mess of the package database several times
10:57:23 <dgpratt> unreparable by me, that is
10:58:16 <lulf> atypic: espen er guru
10:58:48 <typoclass> krautguy: erm, no, 'lines' is for when you have a single String (e.g. you read an entire file into this String) and want to split it into a list of Strings, one String per line. this is what the type "lines :: String -> [String]" refers to. it takes one String and gives back a [String], which is a list of Strings
10:59:49 <typoclass> krautguy: suppose you have a plaintext file with 5 lines of text, you read it, put it in the String s. then "lines s" will give you a list with 5 Strings in it
11:00:15 <krautguy> ah well okay, now i get it, i think
11:00:22 <krautguy> mercie
11:01:07 <typoclass> krautguy: you're welcome. unlines is pretty much the reverse. it takes a list of Strings and glues them all together, with \n in between
11:01:15 <typoclass> > unlines ["abc", "def"]
11:01:17 <lambdabot>   "abc\ndef\n"
11:01:37 <applicative> dgpratt: I just built it without trouble on both ghc-74 and ghc-7.6 so  I think  git clone https://github.com/dagit/cabal-dev.git   will be harmless
11:02:07 <Blkt> good evening everyone
11:02:26 <krautguy> im just wondering, how it devides the string into different strings. i think about the seperation in new lines .. with \n
11:02:50 <applicative> good aftenoon Blkt
11:03:03 <ParahSail1n> @src unlines
11:03:04 <lambdabot> unlines = concatMap (++ "\n")
11:03:22 <ParahSail1n> @src lines
11:03:22 <lambdabot> Source not found. I am sorry.
11:03:25 <Blkt> :)
11:03:41 <dgpratt> it works! thanks applicative
11:03:43 <applicative> lines is a little more complicated;  you loose double newlines etc
11:03:49 <applicative> dgpratt oh good
11:03:50 <typoclass> dgpratt: i think in this case you're just getting the cabal package directly from github, instead of someone copying it from github to hackage, and you downloading it from there. i think it's okay in this case
11:04:30 <dgpratt> typoclass: why is the latter scenario problematic?
11:05:20 <typoclass> dgpratt: well, if i understood correctly, they just haven't made the release yet :-) the copying from github to hackage hasn't happened yet due to some problem
11:05:56 <typoclass> > break (== '\n') "iii\niii\niii" -- krautguy: 'lines' probably does something similar to this, repeatedly until it has gone through the entire String
11:05:58 <lambdabot>   ("iii","\niii\niii")
11:06:55 <krautguy> ah okay!
11:17:27 <romildo> How do I specify a color by name in gtk2hs?
11:18:04 <romildo> For instance, I want to set the background of widget to purple, for instance.
11:34:04 <sonOfRa> I'm using Data.Tree, and I tried to hide draw and drawTree. Hiding drawTree was no problem, but the ghci said that Data.Tree does not export "draw". However, it is right here in the source code: http://hackage.haskell.org/packages/archive/containers/0.2.0.0/doc/html/src/Data-Tree.html
11:34:16 <sonOfRa> Is that source code outdated, and if so, where can I get recent versions?
11:34:29 <sonOfRa> nvm, stupid question
11:38:30 * hackagebot time-compat 0.1.0.2 - Compatibility with old-time for the time package  http://hackage.haskell.org/package/time-compat-0.1.0.2 (DagOdenhall)
11:43:54 <neutrino> hi
11:44:07 <neutrino> how long does it take to get a login approved on hackage?
11:47:06 <gseitz> is it intentional that haskelltasks.org only shows a white page?
11:47:36 <Cale> gseitz: probably not
11:48:01 <Cale> I think that's Chris Done's new project isn't it?
11:48:07 <gseitz> yep
11:49:14 <c_wraith> gseitz: do you have js disabled?
11:50:06 <gseitz> c_wraith: nope, I tried it in Chrome (win7, osx, ios) and safari. always just a blank page
11:50:18 <Cale> c_wraith: I'm getting a completely blank server response apart from headers, so I don't think it's javascript.
11:50:34 <c_wraith> Ah. It's always just been a blank page for me, since I disable js
11:51:10 <Cale> I never really understood why people would disable javascript altogether
11:51:47 <glguy> haskelltasks is a blank page for you because there is no content on the page /:-)
11:52:17 <sm> g'day all
11:52:50 <gseitz> glguy: but there used to be (for a brief period of time at least) ;)
11:53:06 <sm> has anyone got a good way to assert parsec parse results in unit tests ? Is it possible to derive an Eq instance for ParseError ?
11:53:47 <sm> I would like to do assertEqual (Right a) (parse s), eg
11:55:34 <c_wraith> sm: you could try StandaloneDeriving
11:58:01 <neutrino> Cale: can we get arrows in lambdabot?
11:58:42 <neutrino> gseitz: what is haskell tasks supposed to be?
11:59:16 <gseitz> a collection of small tasks that somebody wants to have done, but eg. doesn't have time to do
11:59:41 <gseitz> the target audience is supposed to be haskell beginners
12:00:03 <gseitz> to get their hands dirty with something other than euler project examples
12:00:15 <joejajam> hello?
12:06:46 <sm> c_wraith: doesn't work since ParseError is abstract, but I think I can unpack it to eq-able parts
12:09:18 <TheShamanoid> guys does the Main module have to have a "module Main where" declaration? I've been compiling it without and faced no problems.
12:09:53 <c_wraith> No
12:10:06 <c_wraith> if there's no module declaration, the module name is assumed to be Main
12:11:42 <TheShamanoid> c_wraith: thanks.
12:14:34 <navaati> for instances of Read and Show derived by ghc, read . show = id should hold, right ?
12:15:32 <c_wraith> If all the instances used in that derivation came from GHC, yes.
12:16:02 <c_wraith> But the derived instance for data Foo a = Foo a depends on the Eq instance for a
12:16:24 <navaati> yeah yeah
12:17:01 <navaati> so if all should be right and it's actually not the case (i get a "no parse" exception), does this mean i'm facing a ghc bug ?
12:17:10 <c_wraith> Not necessarily
12:17:16 <navaati> ah
12:17:21 <navaati> what is the alternative ?
12:17:37 <c_wraith> Show for nested non-record types can do that, I think.
12:17:59 <clahey> Parentheses?
12:17:59 <c_wraith> so, I guess the base assumption isn't true
12:18:11 <navaati> non nested record types ? uh ?
12:18:59 <c_wraith> data Foo = Foo Bar Bar ; data Bar = Bar String
12:19:16 <c_wraith> I'm pretty sure the derived Show instance for Foo there isn't going to parenthesize properly
12:19:24 <burbul> Is there a cleaner way of writing
12:19:28 <burbul> liftM2 (DiscourseInsertionPoint a) (on_reason f r) (return n)
12:19:28 <burbul> ?
12:20:22 <clahey> > show Node (Node 5 []) []
12:20:23 <lambdabot>   The function `GHC.Show.show' is applied to three arguments,
12:20:24 <lambdabot>  but its type `...
12:20:24 <navaati> ah… heck… and is there another serializing solution than read/show ? (i mean, something not too heavyweight)
12:20:28 <clahey> > show (Node (Node 5 []) [])
12:20:29 <lambdabot>   "Node {rootLabel = Node {rootLabel = 5, subForest = []}, subForest = []}"
12:20:39 <clahey> Ah, that one works because it's record based.
12:20:44 <rwbarton> c_wraith: sure it will
12:21:46 <rwbarton> *Main> Foo (Bar "hello") (Bar "there")
12:21:46 <rwbarton> Foo (Bar "hello") (Bar "there")
12:21:51 <c_wraith> navaati: there's binary/cereal for when you actually want to be able to round-trip data
12:22:40 <rwbarton> this is what all the showsPrec stuff is for
12:22:45 <clahey> navaati: What about protocol buffers?
12:22:49 <clahey> navaati: Or xml?
12:23:20 <clahey> navaati: Or do you need it to just take an object and know the right thing to do?
12:24:36 <clahey> protocol buffers has the advantage that it has some upgrade path concepts built in for when you add fields and such.
12:24:40 <rwbarton> I think it is probably a bug if all the Show/Read instances are really derived
12:25:31 <navaati> rwbarton, hum, i'll post the code in a couple of minutes
12:35:05 <hpaste> navaati pasted “Compta.hs” at http://hpaste.org/78817
12:35:57 <hpaste> navaati pasted “compta.hs” at http://hpaste.org/78818
12:36:05 <navaati> here is the code
12:37:22 <navaati> "read $ show compta :: Compta" in ghci 7.6.1 throws "*** Exception: Prelude.read: no parse"
12:38:29 <rwbarton> well Centi is not using a derived Show/Read
12:39:11 <navaati> ah. damn
12:39:19 <rwbarton> > read "Just 455.30" :: Maybe Centi
12:39:21 <lambdabot>   *Exception: Prelude.read: no parse
12:39:26 <rwbarton> > read "455.30" :: Centi
12:39:28 <lambdabot>   455.30
12:39:29 <rwbarton> hm
12:39:53 <navaati> yeah, read . show = id holds for Centi
12:39:56 <rwbarton> OTOH Data.Fixed is in base so you can still consider it a bug
12:40:10 <rwbarton> @type readsPrefc
12:40:12 <rwbarton> @type readsPrec
12:40:12 <lambdabot>     Not in scope: `readsPrefc'
12:40:12 <lambdabot>     Perhaps you meant `readsPrec' (imported from Prelude)
12:40:13 <lambdabot> Read a => Int -> ReadS a
12:40:27 <rwbarton> > readsPrec 9 "455.30" :: Centi
12:40:29 <lambdabot>   Couldn't match expected type `Data.Fixed.Centi'
12:40:29 <lambdabot>              with actual ty...
12:40:33 <rwbarton> @src ReadS
12:40:33 <lambdabot> Source not found. Just what do you think you're doing Dave?
12:40:41 <rwbarton> > readsPrec 9 "455.30" :: [(Centi,String)]
12:40:43 <lambdabot>   [(455.30,"")]
12:40:50 <rwbarton> > readsPrec 10 "455.30" :: [(Centi,String)]
12:40:51 <lambdabot>   [(455.30,"")]
12:41:17 <scp> @pl f g x = f x (g x)
12:41:17 <lambdabot> f = fix ap
12:41:24 <rwbarton> hrm
12:41:40 <rwbarton> @type lex
12:41:42 <lambdabot> ReadS String
12:41:50 <rwbarton> > lex "455.30" :: [(String, String)]
12:41:52 <lambdabot>   [("455.30","")]
12:42:06 <navaati> clahey, protobufs seems waaay too heavy (code generation, omg), xml may be ok if there is instances auto derivation (no boilerplate code)what do you mean by "do you need it to just take an object and know the right thing to do?" ?
12:42:07 <rwbarton> > read " 455.30" :: Centi
12:42:09 <lambdabot>   *Exception: Prelude.read: no parse
12:42:14 <rwbarton> > read " 455" :: Integer
12:42:15 <lambdabot>   455
12:42:18 <rwbarton> there's your problem
12:43:14 <navaati> yup
12:43:20 <rwbarton> as to what to do about it...
12:43:26 <clahey> navaati: I mean do you need to just give it a haskell object and have it serialize it with no work from you?  xml is probably not the way to go in that case.
12:43:35 <clahey> navaati: Nor, I'm guessing, is protobufs.
12:43:38 <navaati> clahey, ah, yeah, that's what i need
12:44:08 <clahey> Does the current protobuf implementation include TH stuff?
12:44:20 <navaati> if i'd need to write serialization code, that'd nearly be not worth it
12:46:34 <navaati> (doesn't seem to be TH in protobufs)
12:47:22 <rwbarton> whatever you use has a good chance of not supporing Data.Fixed out of the box either
12:48:12 <navaati> i guess the easiest way would be to use a good old Double instead…
12:48:16 <navaati> it's sad, though
12:51:05 <navaati> or… the best would be to create my own Centi. Going for it.
12:51:13 <rwbarton> that works
12:52:13 <navaati> (ah, cereal has support for automatic instances derivation, but… binary serialization, not really what i want)
12:52:41 <navaati> thanks for the help anyway, i'll (maybe, if i don't forget) file a bug in GHC about Centi's Read
13:14:19 <lispy> dgpratt: I just saw what applicative said to you about cabal-dev. It's better to use the repo that I forked from. The creswick repo.
13:14:58 <dgpratt> lispy: too late :)
13:15:09 <burbul> And I've got two lists and I want to check whether they intersect in a O(n log n) way.
13:15:20 <burbul> Is there an easier way of doing it than constructing two Sets and
13:15:30 <burbul> Checking whether their intersection is empty?
13:15:36 <dgpratt> lispy: I seem to be getting along fine with it
13:18:03 <lispy> dgpratt: cheers :)
13:21:50 <krautguy> jeah strike! .. got my haskell-homework done for this week :-) thanks again
13:24:20 <fmap> burbul: are lists sorted?
13:25:42 <fmap> hmm, if lists are sorted Set-based solution is actually O(n+m)
13:25:44 <fmap> nevermind
13:34:34 <meyersh> burbul: is the question whether they intersect at all, or what the intersection is?
13:45:17 <dgpratt> I could be experiencing deja vu, but I feel like I've seen this pattern before...
13:45:41 <dgpratt> I'm referring to what is going on in parseTopLevels as implemented here: http://hackage.haskell.org/packages/archive/shakespeare-css/1.0.2/doc/html/src/Text-Lucius.html
13:46:32 <meyersh> dgpratt: I was prepared to be amazed that chrome did syntax hilights for haskell before realizing it was in the html.
13:46:48 <dgpratt> the go function defines a 'front' parameter which is initially passed 'id', but gets...err...composed with other stuff down the line
13:47:13 <dgpratt> is this an established pattern?
13:47:51 <burbul> meyersh: whether they intersect
13:48:01 <burbul> I turned one into a set
13:48:12 <YuleAthas> I'm curious, has anyone ever uploaded an unauthorized broken (intentionally or not) version of a package to Hackage?
13:48:21 <burbul> and then used any + `member`
13:48:47 <YuleAthas> I'd be surprised if some prankster hasn't put up a fake version of a major package.
13:50:57 <lispy> YuleAthas: The only response I can think of right now: Well, there goes the neighborhood.
13:52:24 <YuleAthas> When Haskell becomes succesful, spambots will upload updates to popular package that makes them print advertisements during compilation.
13:53:06 <hpaste> larsrh pasted “Some way to make this shorter?” at http://hpaste.org/78820
13:53:29 <larsrh> I have the feeling that some of the returns are superfluous, but I can't make it to compile
13:53:41 <lispy> YuleAthas: what a great idea for monetizing C++ build times! MS can sell ad space in compiler messages.
13:54:04 <Sculptor> lispy, it's not like devs pay attention:
13:54:10 <Adeon> buy our new pills that will greatly extend your comonads
13:54:19 <Sculptor> http://xkcd.com/303/
13:57:31 <Gurragchaa> @src <$>
13:57:32 <lambdabot> f <$> a = fmap f a
13:59:52 <meyersh> burbul: do the lists have duplicate elements? I'm wondering if you can step through the lists searching for matches and just stop at the first match.
14:16:39 <hpaste> meyersh pasted “Intersection detector” at http://hpaste.org/78821
14:17:03 <eikke> is there some PPA with different GHC packages (7.0.x, 7.6.x)?
14:17:29 <meyersh> Just pasted with the intention of asking for critiques, but hpaste threw up a bunch of warnings - maybe I should work on those first. :)
14:18:26 <flazz> can anyone reccomend "Basic Category Theory for Computer Scientists (Pierce)"? or suggest a better alternative?
14:18:43 <typoclass> meyersh: from glancing over them, the warnings don't seem very severe in this case :-)
14:18:55 <Ralith> pierce is definitely reputable
14:20:54 <lispy> flazz: I've heard his CT text is not amazing although I haven't looked at it myself
14:21:30 <lispy> flazz: I first got Conceptual Mathematics but I fonud it very verbose and long winded. I recently picked up Awodey's CT book and I'm enjoying it more as it is more of a traditional graduate level math text.
14:21:56 <acowley> flazz: It's definitely okay!
14:22:06 <meyersh> typoclass: no, but very informative. Does ghci run code like this effeciently?
14:22:13 <lispy> flazz: Conceptual Mathematics is better for undergrads or someone wanting a gentle intro with examples. Awodey is probably better for people who want to dive in all the way and see the full details.
14:22:36 <acowley> flazz: The thing about learning CT is something that BCP even says in the book, you will probably need to read several treatments of some of the topics before they make any sense.
14:23:09 <typoclass> meyersh: oh, the "redundant bracket" and "you could use infix if you want" stuff it purely about style, code readability, that sort of thing. i don't think it concerns performance at all
14:23:18 <acowley> Also, lots of exercises that you have to do to get anything out of the book, but no solution key. That's how you know it's a math book.
14:23:52 <flazz> acowley: have you found the solutions online somehwere?
14:24:17 <hpaste> meyersh annotated “Intersection detector” with “Intersection detector (annotation)” at http://hpaste.org/78821#a78822
14:24:36 <acowley> flazz: No, you need to dive into the ring and wrestle them to submission yourself. If they get you in a choke hold, you go to ##categorytheory and ask for help.
14:24:54 <eacameron> Can someone explain why "average :: (Real a, Fractional b) => [a] -> b" is not written "average :: [Real] -> Fractional"?
14:25:01 <acowley> meyersh: Is this homework?
14:25:06 <flazz> didn't even know ##categorytheory existed
14:25:32 <acowley> flazz: The intersection with #haskell is not empty, so it will seem familiar.
14:25:46 <meyersh> acowley: No, burbul's question got just me wondering. :)
14:30:21 <flazz> thanks for the advice!
14:32:17 <typoclass> meyersh: looks pretty alright to me. in line 2, you're not using the name 'needle', so you could replace it with _ . same for lines 8-9 obviously
14:33:18 <typoclass> meyersh: in 10-12, it's a bit odd that you take apart y with a pattern match, but take apart x with head and tail. i'd recommend you use (x:xs)
14:36:32 <eacameron> I found out: because Real and Fractional are typeclasses not datatypes
14:37:30 <hpaste> meyersh annotated “Intersection detector” with “Intersection detector (removed unused names. unified pattern matching v head/tail)” at http://hpaste.org/78821#a78823
14:38:49 <meyersh> I started writing this originally thinking I'd need the hasElement function. Is GHCI clever about this sort of recursion with short-circuiting?
14:44:29 <shachaf> @ty elem
14:44:31 <lambdabot> Eq a => a -> [a] -> Bool
14:44:42 <shachaf> meyersh: ☝
14:45:32 <shachaf> There isn't much "cleverness" needed -- "short circuiting" isn't an optimization that may or may not happen.
14:45:32 <typoclass> meyersh: not sure what you mean by 'clever', but haskell has lazy evaluation. roughly, only the stuff that is needed is evaluated. once you hit the first True, it won't go on to the end of the list of something like that
14:45:45 <shachaf> hasElement 1 [1..] is guaranteed to evaluate to True, rather than an infinite loop.
14:46:20 <shachaf> The problem with "only the struff that is needed is evaluated" is that it gives people the idea GHC has magical mindreading powers.
14:46:41 <hpc> "only the stuff you say it needs is evaluated"
14:46:43 <hpc> fixed it
14:46:47 <shachaf> Not really.
14:46:50 <hpc> (not really)
14:46:53 <acowley> I'm battling severe writer's block and just wrote, "Robotics is a crucible for computer science concepts fueled by the
14:46:53 <acowley> tears of engineers."
14:46:54 <hpc> heh
14:47:08 <acowley> I'm going to go back to being blocked
14:47:18 <hpc> acowley: so true though
14:48:03 <mcstar> ive seen things, you people wouldnt believe
14:48:12 <acowley> Haskell is a well-typed balm for the burning itch of software development.
14:48:17 <mcstar> attack ships on fire, on the shoulder of orion
14:48:37 <mcstar> i watched c-beams, glittern through the dark near tannhauser gate
14:49:02 <hpc> i saw snape kill dumbledore
14:49:04 <hpc> CHECKMANTE
14:49:05 <typoclass> shachaf: hm yeah, i didn't want to create that impression. i kinda assumed it was clear that no mindreading goes on
14:49:06 <acowley> mcstar: I can end my document with tears if you think it would cement the gravitas
14:49:07 <hpc> MATE
14:49:21 <mcstar> :)
14:49:32 <acowley> CHECKMANTE sounds like part of a really fun game, actually
14:49:37 <typoclass> acowley: what are you planning to write?
14:49:42 <mcstar> checkmanate
14:49:43 <hpc> haha
14:49:56 <acowley> typoclass: statements for job applications
14:50:09 <mcstar> oh, white lies
14:50:10 <hpc> acowley: it sounds like something that would be picked up by a baccarat detector
14:50:48 <hpc> http://cloud.steampowered.com/ugc/578936844570646473/014773A75AB59E3BE7C7640572A859969822FD60/637x358.resizedimage
14:50:54 <lispy> Just me, or is it impossible to install gtk on osx if you install glib with macports
14:51:29 <mcstar> anyway, ive got to finish
14:51:44 <mm_freak> i think it's misleading to introduce laziness as a kind of optimizations, as most haskell summaries do
14:51:45 <mcstar> all those moments will be lost in time, like tears in rain
14:51:49 <mcstar> time to die...
14:51:50 <mm_freak> -s
14:51:56 <acowley> lispy: I got cairo installed via homebrew the other day which needed glib
14:52:43 <acowley> I don't think I've encountered laziness being introduced as an optimization
14:52:44 <typoclass> mm_freak: right. you wouldn't want infinite lists to only work at -O2 or above, and run infinitely otherwise, or some such :-)
14:53:03 <lispy> If I install glib2-devel with macports then I get the complain that pkg-config glib-2.0 isn't found and if I use glib2 then it complains something about needing the devel stuff. macports won't let me install both glib2 and glib2-devel.
14:53:45 <mm_freak> laziness is not an optimization…  if anything, if you don't know how to use it it makes your code slower
14:54:09 <lispy> Also, for a reason I can't quite fathom mac ports lets "-devel" packages fall way behind the non-devel packages.
14:55:05 <hpc> lispy: that's scary
14:55:27 <hpc> you would think those sorts of things would always update in lockstep
14:56:19 <meyersh> With two recursive calls separated by `||` will this work left-to-right, parallel, etc?
14:56:23 <typoclass> what does -devel contain, the source code? just the headers?
14:57:33 <mm_freak> meyersh: depends on (||)
14:57:40 <burbul> rather belatedly: thanks, meyersh
14:57:41 <mm_freak> > True || undefined
14:57:43 <lambdabot>   True
14:58:06 <hpc> mm_freak: (||) has a standard definition, i think
14:58:36 <hpaste> meyersh annotated “Intersection detector” with “Intersection detector (Ord becomes Eq)” at http://hpaste.org/78821#a78824
14:59:02 <mm_freak> meyersh: (||) is strict, (||) True is nonstrict, (||) False is strict
14:59:16 <mm_freak> in other words, it will always evaluate from left to right, but parallelization is an option
14:59:45 <mm_freak> however, GHC does not parallelize unless told to
15:00:20 <typoclass> meyersh: by the way, you don't need to negate the guard, as in "n == x" and "n /= x". you can just have "| n == x = ..." and then "| otherwise = ..."
15:00:50 <hpc> @src otherwise
15:00:50 <lambdabot> otherwise = True
15:00:56 <meyersh> typoclass: Thank you. I wasn't sure if the 'otherwise' from the source I drew from was literal or no. :)
15:00:57 <hpc> best "keyword" ever
15:01:40 <meyersh> @src (||)
15:01:42 <lambdabot> True  || _ =  True
15:01:44 <lambdabot> False || x =  x
15:02:20 <typoclass> meyersh: no, 'otherwise' is in Prelude, you have it always available. as hpc showed, it's a True, acting as a catch-all
15:03:17 <Singingboyo> Haskell code golf:define otherwise to something else.  Use as actual guard instead of being an 'else' construct.  Hilarity ensues.
15:04:18 <hpc> > let otherwise = if true then otherwise else false; false = otherwise || true; true = False in otherwise
15:04:18 <lambdabot>   mueval-core: Time limit exceeded
15:05:04 <meyersh> hpc: blah!
15:05:19 <meyersh> I've got to jet. Thanks so much for your feedback, everyone.
15:11:44 <watermind> what is the extension to allow for type signatures in function arguments?
15:11:51 <watermind> as in    f (x :: Int) =
15:12:13 <mm_freak> watermind: ScopedTypeVariables
15:12:17 <watermind> thanks mm_freak!
15:12:34 <shachaf> watermind: If you type that into ghci it'll tell you the name of the extension necessary.
15:12:55 <watermind> shachaf: oh I didn't know that
15:13:04 <Peaker> Is there any planned version after Haskell2010?
15:13:11 <shachaf> How did you know it was an extension? :-)
15:13:23 <watermind> shachaf: because I've used it before :S
15:13:23 <shachaf> Peaker: Wasn't the plan to have a new version out pretty regularly, every few years?
15:13:26 <Peaker> would be nice to get ScopedTypeVariables into the standard
15:13:42 <shachaf> ScopedTypeVariables requires forall
15:13:49 <Peaker> also to get a warning for newbies about type-var shadowing in nested exprs
15:13:57 <shachaf> Which would be nice to have in the standard too, even with just rank-1 types.
15:14:00 <Peaker> screw any code that uses that name :)
15:14:20 <Peaker> I really really want them to fix the Applicative=>Monad mess :( I suffer from that all the time
15:14:29 <shachaf> Don't we all.
15:14:37 <hpc> Peaker: YEEES
15:14:39 <shachaf> While they're at it they can add Apply
15:14:50 <hpc> it's been long enough that any breakage would be minimal
15:14:51 <Peaker> Maybe I should just always use a MonadF constraint everywhere  MonadF m = (Applicative m, Monad m)
15:14:59 <neutrino> Peaker: i wish they fixed the whole comonad mess.
15:15:10 * typoclass thought there was another extension that allowed "f (x :: Int)". some kinda subset of ScopedTypeVariables
15:15:15 <neutrino> Peaker: codo as a quasiquoter? oh please.
15:15:18 <Peaker> neutrino, I've never used the Comonad classes so I don't know what I'm missing there
15:15:47 <edwardk> neutrino: what comonad mess?
15:15:47 <neutrino> even arrow got its block syntax.
15:15:47 <Peaker> typoclass, you mean inside a pattern?
15:15:55 <hpc> arrow block syntax is awful
15:16:19 <neutrino> edwardk: the codo syntax being a TH QQ
15:16:19 <neutrino> :)
15:16:22 <neutrino> and.. being ugly.
15:16:45 <typoclass> Peaker: yeah no, i just meant that you can put type annotations in places where you usually can't
15:16:46 <hpc> codo would be a quite nice block syntax i think
15:16:48 <edwardk> i think its an interesting experiment. i rarely use one comonadic value for a long computation though
15:17:18 <hpc> edwardk: for long zipper computations it would be awesome
15:17:18 <watermind> so I was using this to give a function a partial signature and let it infer the rest...  as in    h (f:: Int -> Int)  g  x = ...    but what if  that argument f is supposed to have type  f :: a->a  can I still do anything of the sort?
15:17:22 <edwardk> i often have one monad and lots of little comonads
15:17:26 <watermind> I know I can just use some dummy type A
15:17:29 <___d> 1
15:17:43 <hpc> like complex automata
15:17:47 <watermind> and then subsitute a for A
15:17:48 <neutrino> what is type var shadowing in nested exprs?
15:18:00 <watermind> but was wondering if there was another more elegant way to do it
15:18:07 <neutrino> edwardk: mhm
15:18:37 <neutrino> is there something like coarrow?
15:18:52 <Saizan> watermind: (f :: a -> a) doesn't work?
15:19:44 <watermind> Saizan: oh wait it does
15:20:10 <watermind> Saizan: I had another error and assumed that was it, because I totally didn't expect it to work
15:20:59 <shachaf> watermind: You should try things out before asking in here. Both of your questions would have been answered by ghci just as easily as #haskell. :-)
15:21:48 <neutrino> there's a limit to how far you'll go through confusing errors and unknown language features
15:21:52 <watermind> shachaf: true that was embarrassing...
15:21:57 * Peaker is gonna toy with replacing all Monad with MonadA that implies Applicative
15:22:02 <neutrino> nothing wrong with asking someone to hold your hand every now and then
15:22:11 <neutrino> haskell is big and scary
15:23:35 * hackagebot yesod-pnotify 0.2.0.0 - Yet another getMessage/setMessage using pnotify jquery plugins  http://hackage.haskell.org/package/yesod-pnotify-0.2.0.0 (KatsutoshiItoh)
15:25:17 <acowley> Is Haskell really big and scary?
15:25:32 <typoclass> RelaxedPolyRec. there's always one more extension i've never heard of
15:25:43 <jerojasro> acowley: no.
15:26:02 <hpc> https://en.wikipedia.org/wiki/Haskell%2C_Texas
15:26:06 <hpc> it's quite small, in fact
15:26:53 <ion> Not too big and scary. http://www-history.mcs.st-and.ac.uk/BigPictures/Curry.jpeg
15:27:10 <hpc> he looks like Q from TNG
15:28:26 <ion> Q episodes were so annoying.
15:28:39 <test__> pl \a b c -> a*b+2+c
15:28:54 <test__> ups, sorry
15:31:00 <jerojasro> @pl \a b c -> a*b+2+c
15:31:00 <lambdabot> ((+) .) . flip flip 2 . ((+) .) . (*)
15:31:10 <jerojasro> gross
15:31:51 <acowley> Is that supposed to be a proof that Haskell is big and scary? If so, it's not bad :/
15:33:17 <Hafydd> @pl \x -> 1 + x^2/2 + x^3/6 + x^4/25
15:33:17 <lambdabot> ap ((+) . ap ((+) . (1 +) . (/ 2) . (^ 2)) ((/ 6) . (^ 3))) ((/ 25) . (^ 4))
15:33:23 <jerojasro> acowley: that is intended to show that point-free functions can be far more unreadable than their explicit-arguments equivalents
15:33:39 <Hafydd> :t ap
15:33:40 <lambdabot> Monad m => m (a -> b) -> m a -> m b
15:33:54 <acowley> freedom from points is its own prison
15:34:16 <Hafydd> @src ap
15:34:17 <lambdabot> ap = liftM2 id
15:35:29 <Peaker> Hmm... Just replaced all my Monad constraints with MonadA. That wasn't too bad. No more liftM!
15:39:37 <test__> @pl value x = foldr (\wsp ret -> wsp + x*value) 0
15:39:37 <lambdabot> value = fix (flip flip 0 . ((foldr . (const .) . (+)) .) . (*))
15:40:24 <byorgey> test__: that looks strange.  is 'value' a function or a number?
15:40:47 <byorgey> did you mean  x*ret?
15:41:51 <Peaker> Ranting on #haskell can be good! It just motivated me to get rid of all my liftM/liftM2/sequence calls :)
15:41:58 <Peaker> (and using a MonadA hack for an applicative implication)
15:44:40 <test__> byorgey: function, but i'm just a beginner
15:45:13 <test__> and i replace func name with first other word
15:45:53 <shachaf> Peaker: What do you use instead of sequence?
15:46:07 <Peaker> shachaf, I still use sequence, but I could use Traversable.sequenceA
15:46:14 <Peaker> That one is more trouble than it's worth, though
15:46:15 <shachaf> Ah. Sure.
15:46:25 <Peaker> so I decided against it
15:46:30 <shachaf> Or `traverse id`, I guess, if you have traverse in scope.
15:46:36 <Peaker> but being able to use applicative style on my monads rather than liftM2 or do blocks would be nice
15:46:39 <shachaf> Or sequenceAOf traverse, which is the same thing. :-)
15:47:01 <Peaker> yeah, maybe I should change mapM to traverse indeed
15:47:07 <acowley> Does using Traversable impose any performance overhead on the usual list-specialized versions of things?
15:47:16 <Peaker> No idea...
15:47:24 <acowley> All the overlap makes Traversable kind of awkward
15:47:25 <shachaf> acowley: Not if it can figure out that you're dealing with a list at use site, at least.
15:47:33 <acowley> shachaf: That's what I thought
15:47:53 <acowley> So the argument for keeping the list-specialized definitions is just error messages?
15:48:06 <Peaker> hmm.. there's no traverse_ in there!
15:48:13 <shachaf> Peaker: It's in Foldable
15:48:27 <shachaf> (You don't need traverse to do sequence_, since you're not building the structure back up.)
15:48:45 <shachaf> acowley: That would be a better argument if mapM had Applicative instead of Monad.
15:49:02 <shachaf> Peaker: If you're using lens you can also sequenceOf_ folded
15:49:06 <shachaf> Or sequenceOf_ traverse
15:49:07 <acowley> Maybe we can have {-# LANGUAGE ExperiencedHaskeller #-} that exports Foldable and Traversable from Prelude
15:49:17 <Peaker> shachaf, ah, cool!
15:49:22 <shachaf> acowley: import Control.Lens :-)
15:49:36 <acowley> shachaf: That brings its own brand of pain
15:49:48 <acowley> but it's a good point
15:50:07 <acowley> Except, I don't know what the difference between sequenceOf_ folded and sequenceOf_ traverse is
15:50:08 <shachaf> sequenceOf_ folded is a bit more verbose, but has the usual advantages where you can say sequenceOf_ (folded.folded), (folded.both), etc.
15:50:17 <edwardk> acowley: there is discussion of renaming up/down/left/right upward/downward/leftward/rightward
15:50:25 <edwardk> we renamed almost all the other conflicts already
15:50:31 <shachaf> acowley: They should behave exactly the same way.
15:50:46 <shachaf> The former is possibly more efficient.
15:50:49 * cmccann suggests "dextral" and "sinistral"
15:51:05 <acowley> edwardk: Wherever this discussion is happening, please contribute my two pence to the side for change!
15:51:06 <shachaf> One of them uses the Foldable instance and the other one uses the Traversable instance.
15:51:14 <shachaf> acowley: It's happening in #haskell-lens :-)
15:51:14 <edwardk> cmccann: fore/aft/port/starbord, clearly :)
15:51:18 <typoclass> cmccann: rimwards, widdershins ...
15:51:29 <cmccann> typoclass, hahaha I was about to say that
15:51:34 <acowley> Man, I complain about lens names in all the wrong places
15:52:07 <edwardk> https://github.com/ekmett/lens/issues/167 was where this round of bikeshedding got started
15:52:07 * simpson waits for yaw, pitch, and roll lens
15:54:18 <shachaf> acowley: folded is "more general" than traverse (it works with more types), but traverse is "more general" than folded (you can do more things with it)
15:54:37 * cmccann really should try to remember which is which of port and starboard, in order to have another set of fallback directions that don't clash with left/right
15:54:50 <acowley> shachaf: So each is more general than the other, and there's a possible performance issue. Well that's all cleared up, then! :)
15:55:05 <cmccann> one is more general in contravariant position, of course
15:55:12 <cmccann> that should clear everything up
15:55:16 <shachaf> acowley: I doubt there's ever much of a performance issue in practice.
15:56:17 * cmccann muses on how discussions of programming language "expressiveness" often conflate covariant and contravariant notions of "power"
15:56:26 <shachaf> Oh, I forgot to mention: Don't use sequenceOf_, use traverseOf_
15:57:25 <shachaf> Wait, no.
15:57:34 <shachaf> sequenceAOf_
15:57:38 <shachaf> That's what I was trying to say.
15:58:14 <acowley> shachaf: Are you still clearing up the confusion?
15:58:29 <shachaf> I don't know anymore.
15:58:45 <acowley> hahaha
15:58:46 <cmccann> shachaf has stared into his confusion and found that it stares back.
15:58:58 <shachaf> cmccann: Hey, I was never confused!
15:59:04 <cmccann> are you sure?
15:59:11 <acowley> I'm confused enough for both of us if that helps
15:59:55 <cmccann> I'm not confused, but I'm being intentionally unhelpful.
16:03:07 <hpaste> User9eB1 pasted “ParsecTest” at http://hpaste.org/78828
16:03:55 <typoclass> cmccann: ah, found it :-) my favorite explanation of port and starboard http://www.youtube.com/watch?v=E-5TPE2y8l0#t=8m15s
16:03:56 <User9eB1> Parsec is supposed to work with Data.Text, but it keeps giving me complaints in the above paste. Any ideas?
16:05:13 <cmccann> typoclass, I'll watch that in a bit, doing too many things at once right now
16:08:46 <acowley> User9eB1: I suspect adding more type signatures would help narrow down the problem
16:11:26 <Peaker> yay, replaced sequence/sequence_ with sequenceA/sequenceA_ too :)
16:11:35 <Peaker> no silly Monad constraints where they make no sense anymore!
16:16:40 <fmap> User9eB1: you don't want ParserCombinators modules, they are backwards-compatibility layer
16:16:59 <User9eB1> fmap: Oh, I thought I read that it was the other way around
16:17:27 <fmap> User9eB1: and if you want to parse Text you need to import Text.Parsec.Text.(Lazy) at least :)
16:18:05 <User9eB1> fmap: Thank you, that worked perfectly.
16:18:21 <User9eB1> acowley: Thank you as well
16:23:09 <TheShamanoid> OMG! With haskell, the way higher order functions combined with lambda expressions are able to solve problems is orgasim-like
16:23:33 <TheShamanoid> Amazing how such small compact code is able to do a lot of stuff.
16:23:50 <typoclass> TheShamanoid: ;-) welcome to haskell
16:23:53 <TheShamanoid> I am officially a haskell guy now, bye bye java.
16:24:23 <TheShamanoid> typoclass: pleasure being a user of such a language :D
16:25:20 <copumpkin> @where ttfp
16:25:20 <lambdabot> http://www.cs.kent.ac.uk/people/staff/sjt/TTFP/
16:25:21 <mm_freak> TheShamanoid: the pleasure starts when your colleagues get annoyed by you praising haskell all the time =)
16:26:47 <TheShamanoid> mm_freak: i am yet to experience such a thing
16:27:51 <TheShamanoid> mm_freak: i study at the university of edinburgh and everyone here uses haskell as Philip Wadler is part of the faculty
16:28:12 <TheShamanoid> mm_freak: He actually taught us first year introduction to functional programming
16:28:35 <mm_freak> TheShamanoid: you are a lucky guy!
16:29:23 <TheShamanoid> mm_freak: I know, he still holds the record for most awesome lecturer
16:29:43 <DMcGill> I dunno, Graham Hutton is pretty good
16:30:05 <typoclass> DMcGill: is that the guy from u-nottingham?
16:30:23 <roconnor> tom39291: yes
16:30:28 <roconnor> er
16:30:32 <roconnor> typoclass: yes
16:30:32 <DMcGill> yup, wrote Programming In Haskell
16:30:39 <typoclass> right, thanks
16:30:49 <liyang> DMcGill: is that because you know he reads the logs for this channel?
16:31:18 <mm_freak> TheShamanoid: that's not the point…  i'm surrounded by PHP people
16:31:26 <mm_freak> (at least they acknowledge that PHP sucks)
16:31:41 <DMcGill> I've seen him in here before, but apparently isn't at the moment
16:32:20 <TheShamanoid> mm_freak: nah,i am the exact opposite, all my colleges know haskell.
16:32:53 <TheShamanoid> mm_freak: colleagues*
16:34:31 <Adnauseam> how do i go about to calculate e^ln ?
16:34:43 <liyang> Adnauseam: id
16:34:55 <Adnauseam> liyang: tad more detail ?
16:35:29 <typoclass> Adnauseam: the 2 operations cancel each other out. if ln is the natural logarithm, it's defined to be the base of the e function ...
16:35:31 <liyang> \ x -> e ^ log x is the same as id for positive values.
16:35:57 <Adnauseam> oh i see
16:36:25 <Adnauseam> this is a math question, but what's then the significance of e^constant-ln
16:36:26 <liyang> It's undefined for negative input if you restrict yourself to the reals.
16:36:32 <typoclass> ... wait, i writed it wrong, but you know what i mean :-)
16:36:50 <Adnauseam> mhm, interesting
16:37:50 <Adnauseam> reading up on the geometric coefficient of variation, and infact GCC := e^sln - 1, with s the sample standard deviation
16:37:54 <liyang> > exp . log $ 42
16:37:56 <lambdabot>   42.00000000000001
16:38:08 <Adnauseam> :o
16:38:27 <liyang> Well, up to IEEE-754.
16:39:15 <Mikicacarica> >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> http://fcasroma.blogspot.com/ <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
16:40:11 <Hafydd> > log . exp $ 42
16:40:13 <lambdabot>   42.0
16:41:11 <aheller> TheShamanoid: If you haven't read it already, you might enjoy Hughes' "Why Functional Programming Maters"
16:42:30 <TheShamanoid> aheller: Nope, never heard of it. Will give it a read once i am done with exams. Thanks!
17:10:45 <dagnachew> hi all
17:11:10 <dagnachew> is there a way to export haskell packages and import them ( to install them ) on another pc like rvm gemset export ; rvm gemset import ?
17:12:32 <dagnachew> hello imeredith
17:12:49 <imeredith> dagnachew: hi
17:12:54 <dagnachew> imeredith,
17:12:56 <dagnachew> is there a way to export haskell packages and import them ( to install them ) on another pc like rvm gemset export ; rvm gemset import ?
17:13:12 <imeredith> i have no idea
17:13:15 <dagnachew> ok
17:16:44 <dagnachew> cant install base64-conduit plz help http://pastie.org/5486638
17:17:03 <dagnachew> actualy that one was with yesod
17:17:05 <dagnachew> sorry
17:17:17 <dagnachew> I will bring base64-conduit install error
17:18:10 <acowley> dagnachew: what do you mean by "export haskell packages"?
17:18:34 <pqmodn> copumpkin: what are your thoughts on TTFP? do you recommend any documents to go along with it (assuming you've read it)?
17:18:37 <dagnachew> acowley, I want my pc and laptop to have the same packages
17:18:48 <acowley> dagnachew: use a DVCS like git
17:19:04 <dagnachew> acowley, can you help me cant install base64-conduit http://pastie.org/5486647
17:19:40 <acowley> dagnachew: what version of GHC or the HP do you have?
17:19:51 <dagnachew> hp ?
17:20:18 <SingingBoyo> dagnachew: Haskell Platform
17:20:50 <dagnachew> 7.6.1
17:21:12 <dagnachew> acowley, SingingBoyo 7.6.1
17:21:54 <dagnachew> SingingBoyo, acowley my pc too has 7.6.1 and on it I was able to install base64-conduit
17:23:09 <byorgey> dagnachew: I don't believe you =)
17:23:20 <acowley> dagnachew: I'm not sure what's going on, but it sounds like you have different GHCs on the two systems
17:23:25 <byorgey> Hackage shows base64-conduit failing on 7.6.1 with exactly the same error message
17:23:28 <acowley> well, it *looks* like it
17:23:50 <acowley> well, there you go
17:23:54 <dagnachew> byorgey, acowley ghc --version 7.6.1 on laptop
17:24:12 <dagnachew> same on pc
17:24:38 <SingingBoyo> dagnachew: I'm running GHC 7.4.1 and it installs with the command you used.  guessing that your pc doesn't have 7.6.1.
17:24:41 <byorgey> dagnachew: and you are sure you have base64-conduit installed?  i.e.  'ghc-pkg list base64-conduit'  lists it?
17:25:19 <dagnachew> exec -o ghc-pkg list|grep base
17:25:25 <dagnachew> sorry
17:25:32 <dagnachew>     base-4.6.0.0
17:25:32 <dagnachew>     base-unicode-symbols-0.2.2.4
17:25:32 <dagnachew>     base64-bytestring-1.0.0.0
17:25:32 <dagnachew>     lifted-base-0.2
17:25:32 <dagnachew>     regex-base-0.93.2
17:25:33 <dagnachew>     transformers-base-0.4.1
17:25:38 <byorgey> dagnachew: GHC 7.6.1 changed what it allows with certain extensions, so there are some programs that used to work that now require an extra extension
17:25:44 <dagnachew> I am sorry
17:25:50 <dagnachew> I tought I had it
17:25:51 <byorgey> I don't see base64-conduit there
17:26:20 <dagnachew> The Glorious Glasgow Haskell Compilation System, version 7.6.1
17:26:59 <dagnachew> cabal: There is no package named 'base64-conduit'.
17:26:59 <dagnachew> You may need to run 'cabal update' to get the latest list of available
17:26:59 <dagnachew> packages.
17:27:46 <byorgey> dagnachew: well, do what it suggests
17:28:03 <rwbarton> well it's not going to help, right
17:28:59 <shachaf> http://hackage.haskell.org/package/base64-conduit seems to exist
17:29:04 <shachaf> Why wouldn't it help?
17:29:27 <dagnachew> shachaf, know I have the previous error
17:29:29 <byorgey> it's not going to help actually getting base64-conduit installed under 7.6.1
17:29:37 <dagnachew> acowley, can you help me cant install base64-conduit http://pastie.org/5486647
17:29:44 <rwbarton> because we established that base64-conduit doesn't build on 7.6.1 anyways
17:29:52 <dagnachew> sorry acowley discard last post
17:29:54 <shachaf> Oh.
17:29:59 * shachaf came in in the middle.
17:30:06 <neutrino> so fix it and install it, of course
17:30:10 <dagnachew> shachaf, can you see the error
17:30:11 <byorgey> dagnachew: if you really want it installed you will have to get the source and update it
17:30:25 <dagnachew> byorgey, how
17:30:40 <shachaf> cabal unpack base64-conduit
17:30:53 <neutrino> that is not the vcs though
17:31:09 <Eduard_Munteanu> Is there anything on Hackage that provides a filepath validation / sanitizing function? System.FilePath fails to treat stuff like ".." correctly.
17:31:34 <byorgey> dagnachew: first get the source like shachaf suggests.  Then add {-# LANGUAGE Rank2Types #-} at the top of Data/Conduit/Base64.hs.
17:31:40 <Eduard_Munteanu> I'm interested in a safe (</>) variant.
17:31:58 <byorgey> dagnachew: then, in the base64-conduit directory, do 'cabal install'
17:32:28 <byorgey> Eduard_Munteanu: what? If System.FilePath treats ".." incorrectly I would say that's a bug.
17:32:31 <neutrino> @hoogle canonic
17:32:31 <lambdabot> package canonical-filepath
17:32:31 <lambdabot> System.Directory canonicalizePath :: FilePath -> IO FilePath
17:32:35 <ion> eduard_munteanu: Dunno if this does it better, but it’s worth checking out: http://hackage.haskell.org/package/system-filepath
17:32:42 <neutrino> there you go ed
17:33:00 <dagnachew> wow
17:33:02 <dagnachew> jesus
17:33:11 <dagnachew> byorgey, sorry
17:33:25 <dagnachew> byorgey, cabal install in the directory same error
17:33:31 <Eduard_Munteanu> byorgey: I don't see any way to use combine, </> etc. safely such that a </> b doesn't let 'b' escape the path in 'a'.
17:33:40 <byorgey> dagnachew: did you edit Data/Conduit/Base64.hs ?
17:34:02 <Eduard_Munteanu> > "foo" </> ".."
17:34:03 <lambdabot>   Not in scope: `</>'
17:34:03 <lambdabot>  Perhaps you meant one of these:
17:34:03 <lambdabot>    `<>' (imported from...
17:34:11 <pqmodn> @hoogle Either a b -> Either b a
17:34:12 <lambdabot> Network.Stream bindE :: Result a -> (a -> Result b) -> Result b
17:34:12 <lambdabot> Data.Graph.Inductive.Basic unlab :: DynGraph gr => gr a b -> gr () ()
17:34:12 <lambdabot> Data.Graph.Inductive.Graph gmap :: DynGraph gr => (Context a b -> Context c d) -> gr a b -> gr c d
17:34:16 * Eduard_Munteanu looks
17:34:22 <neutrino> Eduard_Munteanu: oh, so you just want something that allows you to do that?
17:34:26 <byorgey> Eduard_Munteanu: oh, hmm, that seems like a different issue
17:34:33 <dagnachew> byorgey, in the unpacked directory I did runhaskell setup Configur but it said  missing dependency base64-bytestring and conduit; these two are installed :(
17:34:43 <ion> The safe variant shouldn’t be called </>, that functionality is outside the scope of </>.
17:34:51 <byorgey> dagnachew: don't do runhaskell Setup configure
17:34:57 <byorgey> just do 'cabal install'
17:35:01 <dagnachew> byorgey, I did not edit base64.hs
17:35:10 <neutrino> @hoogle relative
17:35:10 <lambdabot> System.IO RelativeSeek :: SeekMode
17:35:10 <lambdabot> GHC.IO.Device RelativeSeek :: SeekMode
17:35:10 <lambdabot> GHC.IO.Handle RelativeSeek :: SeekMode
17:35:17 <byorgey> dagnachew: well, you need to
17:35:22 <neutrino> hmm no
17:35:25 <neutrino> @hoogle+
17:35:26 <lambdabot> package relative-date
17:35:26 <lambdabot> Network.URI relativeFrom :: URI -> URI -> URI
17:35:26 <lambdabot> Network.URI relativeTo :: URI -> URI -> Maybe URI
17:35:27 <hpaste> Carlo pasted “cabal wx install error” at http://hpaste.org/78831
17:35:29 <Eduard_Munteanu> neutrino: I want to do something like a </> b where b is some untrusted user input.
17:35:30 <byorgey> dagnachew: "Then add {-# LANGUAGE Rank2Types #-} at the top of Data/Conduit/Base64.hs."
17:35:32 <neutrino> still not
17:35:39 <dagnachew> ok
17:35:46 <carlo_h> anyone using wxHaskell? I can't install wx on Debian/testing: http://hpaste.org/78831
17:36:22 <neutrino> @hoogle makerelative
17:36:22 <lambdabot> System.FilePath.Windows makeRelative :: FilePath -> FilePath -> FilePath
17:36:22 <lambdabot> System.FilePath.Posix makeRelative :: FilePath -> FilePath -> FilePath
17:36:22 <lambdabot> System.Directory makeRelativeToCurrentDirectory :: FilePath -> IO FilePath
17:36:35 <neutrino> use this Eduard_Munteanu and see if it is a subdir?
17:37:53 <pqmodn> is there already something to flip Either? i want to `fmap` over the left side, but the functor instance for Either maps over the right
17:37:56 <Eduard_Munteanu> Well, actually, my issue was 'takeFileName ".."' also returns "..", so I can't drop path components.
17:38:19 <Eduard_Munteanu> Dunno if that's a bug though.
17:38:28 <pqmodn> i guess `either Right Left` would work, but maybe there's something better
17:38:45 <dagnachew> byorgey, :)
17:39:00 <byorgey> pqmodn: not that I know of.
17:39:10 <pqmodn> byorgey: ok, thanks
17:39:14 <dagnachew> byorgey, what was that line you told me to insert ?
17:40:06 <Eduard_Munteanu> splitFileName ".." also acts oddly, returning ("./","..")
17:40:26 <startling> heh
17:40:26 <rwbarton> what does splitFileName do on a directory in general?
17:40:40 <byorgey> dagnachew: {-# LANGUAGE Rank2Types #-}
17:41:23 <Eduard_Munteanu> rwbarton: I'd expect ("..", "") instead :/
17:41:29 <neutrino> Eduard_Munteanu: you can also make a function which does takeDirectory on two paths, in order to check their common parent, after applying normalize. then you can check if your resultant path and jail path have the jail path as a common prefix.
17:42:09 <rwbarton> Prelude System.FilePath> splitFileName "/tmp"
17:42:09 <rwbarton> ("/","tmp")
17:42:22 <dagnachew> byorgey, it worked I just wanted to know what it did am just starting haskell :)
17:43:31 <neutrino> Eduard_Munteanu: takeFileName "../" returns ""
17:43:41 <Eduard_Munteanu> Hmm.
17:43:59 <neutrino> bear in mind this function is pure, so it is going to have simple rules on how to recognize files or dirs.
17:44:06 <Eduard_Munteanu> Yeah, sure.
17:44:25 <neutrino> however, ".." is 100% certainly a dir
17:44:34 <neutrino> so this is a bug
17:44:37 <SingingBoyo> dagnachew: it enables a language extension in GHC that is apparently used by base64-conduit.  Not exactly sure what the Rank2Types extension does though.
17:44:44 <neutrino> there is no ambiguous situation here
17:45:03 <Eduard_Munteanu> Yeah, the /tmp case above is acceptable behavior though.
17:45:28 <fryguybob> dagnachew: http://www.haskell.org/haskellwiki/Rank-N_types
17:45:44 <neutrino> yes, /tmp might be a file.
17:45:56 <rwbarton> what is the problem anyways
17:46:15 <rwbarton> .. is still the entry named .. in the directory reached by ./
17:46:15 <neutrino> Eduard_Munteanu: i think your issue is that you're trying to implement security
17:46:26 <rwbarton> that seems perfectly consistent to me
17:46:56 <byorgey> dagnachew: if you're just starting Haskell it's not worth worrying about right now.  GHC used to accept certain types without an extension turned on but now requires one.
17:46:56 <typoclass> what is the bug? takeFileName ".." giving ".." seems expected to me. "file name" is the unixy notion, "everything is a file", "directories too are a file", etc.
17:47:13 <byorgey> dagnachew: extensions enable certain features which are not in the Haskell language standard
17:47:33 <neutrino> rwbarton: right. directories are files too.
17:47:38 <byorgey> dagnachew: however, some extensions (such as Rank2Types) are fairly standard even though they are not "official"
17:47:48 <Eduard_Munteanu> neutrino: I'm merely trying to validate a user-supplied name for uploaded files in Yesod.
17:48:00 <Eduard_Munteanu> validate/sanitize
17:48:02 <neutrino> i guess what takeFileName does is give us the last component? i guess if the path ends in a slash the author decided that implies an empt last component.
17:48:30 * Eduard_Munteanu looks at System.Directory.canonicalizePath
17:48:33 <typoclass> Eduard_Munteanu: have you thought about res = a </> b, then checking if the path res is below the directory a? modulo symlinks of course
17:48:51 <neutrino> Eduard_Munteanu: why let the user supply a name at all?
17:49:24 <dagnachew> byorgey, fryguybob thank you very much that was what I expected
17:49:57 <typoclass> Eduard_Munteanu: or you could run that yesod application with a user that has nearly no privileges, i.e. who can only read/write/execute that directory and nothing above
17:50:12 <typoclass> (might be the more reliable approach anyway)
17:50:37 <dagnachew> byorgey, fryguybob if am correct it's loading of extra modules ? or "include file" ?
17:51:00 <byorgey> dagnachew: no, it is enabling an extra feature
17:51:15 <dagnachew> ok
17:51:26 <Eduard_Munteanu> typoclass: AFAICT that will only work if Yesod chroots before saving the file, otherwise it could get access to its own stuff (e.g. a database, which has to be writable)
17:51:45 <pqmodn> Eduard_Munteanu: canonicalizePath appears to use the syscall `realpath`, which resolves symlinks. the doc i read didn't mention this
17:51:50 <Eduard_Munteanu> neutrino: I suppose I could store "filenames" in a db, but I want to avoid that complexity.
17:51:55 <SingingBoyo> dagnachew: Think of it as a compiler flag for that one file, or if you know C/C++, a #pragma.
17:52:02 <typoclass> Eduard_Munteanu: hmm
17:52:21 <dagnachew> I wont bother further I will come back after doing more than adding numbers :0
17:52:59 <Eduard_Munteanu> pqmodn: well, symlinks under the target dir aren't an issue
17:53:16 <Eduard_Munteanu> (I won't have any)
17:54:27 <Eduard_Munteanu> "Note that it is impossible to guarantee that the implication (same file/dir <=> same canonicalizedPath) holds in either direction: this function can make only a best-effort attempt. "   -- hrm...
17:54:57 <pqmodn> yeah, i'm not sure why. maybe a Windows issue?
17:55:16 <Eduard_Munteanu> I think hardlinks or other stuff?
17:55:20 <pqmodn> oh, could be
17:55:37 <Eduard_Munteanu> Anyway, it sounds like combining the path *then* checking it's overall valid might be problematic.
17:56:00 <dagnachew> byorgey, one last question is there a way to know wich packages installs x module ? for exemple wich package install term-info ?
17:56:29 <pqmodn> why's that? i think you could use canonicalizedPath then makeRelative (http://hackage.haskell.org/packages/archive/filepath/1.1.0.3/doc/html/System-FilePath-Posix.html#v%3AmakeRelative) and check for a ".." prefix, no?
17:56:34 <Eduard_Munteanu> Presumably I rather want to check the user-supplied fragment doesn't escape.
17:56:55 <rwbarton> it sounds like you basically just want to check whether a purported "filename" is in fact reasonable
17:57:01 <Eduard_Munteanu> Yep.
17:57:12 <rwbarton> which I think means (1) doesn't contain a / (2) isn't "." or ".."
17:57:47 <rwbarton> (3) isn't ""
17:57:55 <rwbarton> (4) whatever else I haven't thought of
17:57:55 <pqmodn> and (3) isn't path/../../../etc/passwd etc
17:58:17 <Eduard_Munteanu> rwbarton: that (4) there made me uneasy too :)
17:58:35 <rwbarton> probably on Windows there are a different set of invalid names
17:58:44 <byorgey> dagnachew: term-info doesn't sound like the name of a module
17:58:45 <Eduard_Munteanu> Linux-only is fine.
17:58:51 <SingingBoyo> (5) also doesn't contain \ $ # or whatever invalid characters there are for whatever system you're on
17:59:14 <rwbarton> I think the only "invalid character" is '\0'
17:59:14 <byorgey> dagnachew: but in general, sadly, it is somewhat difficult to figure out which packages include certain modules
17:59:20 <rwbarton> that probably falls under (4)
17:59:30 <pqmodn> Eduard_Munteanu: since you're not concerned about symlinks in your target directory, makeRelative alone might be fine
17:59:42 <dagnachew> ok
17:59:48 <pqmodn> > makeRelative "/var/tmp/data" "path/to/../../../files"
17:59:50 <lambdabot>   Not in scope: `makeRelative'
17:59:55 <rwbarton> pqmodn, that falls under (1)
18:00:20 <pqmodn> rwbarton: whoops, misread it as 'isn't "/"'
18:00:55 <typoclass> i think it boils down to "doesn't contain /" followed by a check if the file exists already. (.. and . will already exist)
18:02:20 <Eduard_Munteanu> I could go nazi on it and simply reject any non-alphanumeric characters, plus some other stuff like '-', and let it be.
18:04:25 <Eduard_Munteanu> Actually my application isn't security-sensitive (it's only facing authorized personnel), but it irks me.
18:04:48 <rwbarton> I wonder what happens in my django app that allows file upload if I try to upload a file "..", actually
18:05:10 <SingingBoyo> Eduard_Munteanu: I'd say accepting only [A-Za-z_-]\.[A-Za-z] would be reasonable.
18:05:17 <dagnachew> byorgey, I tried the trick for the zeromq-haskell http://pastie.org/5486785 package
18:05:26 <rwbarton> though it's a bit awkward to actually test
18:05:33 <SingingBoyo> Though my regex syntax is probably way off.  been a while.
18:06:12 <ParahSailin> is there anything i should know about performance of STRefs
18:06:30 <hpc> ParahSailin: it's identical to the performance of IORef
18:06:31 * vreg pops in...
18:06:38 <vreg> could make it case insensitive?
18:06:44 <byorgey> dagnachew: "trick"? there is no trick
18:06:58 <vreg> so you don't have to do A-Za-z
18:07:01 <byorgey> dagnachew: what do you mean?  what exactly did you try?
18:07:03 <dagnachew> the line at the top
18:07:04 * vreg crawls away
18:07:26 <dagnachew> {-# LANGUAGE Rank2Types #-}
18:07:30 <byorgey> dagnachew: that is not a trick.  That was specifically the change needed to get base64-conduit to work.
18:07:47 <byorgey> dagnachew: it has nothing to do with those errors for zeromq-haskell
18:07:55 <dagnachew> byorgey, did you the output error for zeromq-haskell ?
18:08:06 <dagnachew> http://pastie.org/5486785 package
18:08:22 <byorgey> yes, I looked at it.  I have no idea what you would need to do to get it to work.
18:08:28 <dagnachew> ok
18:08:35 <dagnachew> thank you for your time
18:08:38 <SingingBoyo> dagnachew: base64-conduit used the Rank2Types extension.  zeromq-haskell just looks broken from that.  looks like it's missing an include or something to make its foreign interface work.
18:08:57 <dagnachew> SingingBoyo, thank you very much
18:10:32 <rwbarton> or you may have the wrong version of the zeromq C library
18:12:20 <SingingBoyo> anyone know of a good actor library for haskell?  I'd prefer not to try and roll my own, and STM just doesn't appeal to me.
18:13:42 <ion> @hackage distributed-process -- SinginBoyo
18:13:43 <lambdabot> http://hackage.haskell.org/package/distributed-process -- SinginBoyo
18:19:11 <SingingBoyo> oof. thanks. going to take some reading to figure out the api, but it looks like what I want.
18:19:24 <Hass> hi
18:19:36 <ion> singingboyo: You might find this talk interesting. http://skillsmatter.com/podcast/home/cloud-haskell
18:19:39 <Hass> what can I use haskell for? Desktop applications?
18:19:49 <ion> @fac Can Haskell do desktop applications?
18:19:49 <lambdabot> Maybe you meant: fact fact-cons fact-delete fact-set fact-snoc fact-update faq
18:19:54 <ion> @faq Can Haskell do desktop applications?
18:19:54 <lambdabot> The answer is: Yes! Haskell can do that.
18:20:33 <Hass> is it a niche language?
18:20:42 <Hass> cause no one I know knows Haskell
18:21:02 <Hass> I don't know many people though
18:21:10 <rwbarton> SingingBoyo: if you don't need *distributed* actors, there is simple-actor (never really looked at it myself though)
18:21:35 <cmccann> programming in haskell is definitely better than knowing people
18:21:43 <cmccann> it makes more sense
18:21:54 <ion> Even if you don’t need the distribution capability, i think a lot of thought has been put into the semantics of distributed-process.
18:22:37 <typoclass> Hass: i think learning haskell will make you a better programmer, whether you later use haskell or some other language
18:22:55 <gridaphobe> is there a version of `when` that takes a `m Bool` ?
18:23:38 <gridaphobe> i'd like to say "when (doesFileExist f) ..."
18:23:40 <parcs`> nope, not in the stdlib
18:24:37 <joeyh> whenM in ifElse
18:25:03 <Eduard_Munteanu> Hass: http://www.haskell.org/haskellwiki/Applications_and_libraries   , also check out hackage
18:25:15 <SingingBoyo> rwbarton: It's an interesting lib, but I'm likely to end up using supervison, and maybe distributed actors.  simple-actors is, well, too simple
18:25:23 <gridaphobe> joeyh: thanks!
18:26:14 <ion> hass: http://www.haskell.org/haskellwiki/FAQ#The_real_world
18:26:24 <Eduard_Munteanu> He gone.
18:26:44 <ion> verily
18:27:04 <cmccann> he hass gone :D
18:27:19 <parcs`> what's a niche language?
18:27:44 <Eduard_Munteanu> He haß gone.
18:28:14 <Eduard_Munteanu> parcs`: I'd say the opposite of general-purpose, but I think he meant "obscure".
18:28:42 <cmccann> or just one used for a limited variety of purposes, even if it could be general-purpose
18:33:02 <Eduard_Munteanu> Funnily I never thought Haskell was obscure, even before I was acquianted to it; rather, I initially thought "hey, another PHP". :)
18:33:22 <hpc> haha what
18:33:22 <Eduard_Munteanu> Back when I'd only touch C. :)
18:33:28 <parcs`> i wonder if it's worth all the extra complexity to make sure quickcheck's quickCheck function changes the buffering mode of stderr back to what it was after it's done
18:33:50 <SingingBoyo> another... php? lolwut?
18:33:56 <Eduard_Munteanu> hpc: yeah, I had seen the name thrown around, for some reason it made me think it wasn't really different.
18:34:09 <hpc> i learned haskell after java and python and a wee bit of C++
18:34:15 <parcs`> (it turns out that buffering and manually flushing stderr makes quickcheck tests run 7x faster)
18:34:18 <hpc> and thought "if this language sucks i am never programming again"
18:34:46 <Eduard_Munteanu> Well, after another look at the Wikipedia page, I was already sold on it :)
18:35:36 * Eduard_Munteanu should thank Pekka Enberg, it's one of his blog posts that made me have that second look at it.
18:37:00 <parcs`> i decided to learn haskell after somebody on SO remarked that some people claim haskell is the only language one should program in
18:37:54 <parcs`> it was obvious hyperbole, but it still got me interested
18:38:18 <DMcGill> yeah I wouldn't go that far - sometime you do need assembly
18:38:39 * hackagebot force-layout 0.2 - Simple force-directed layout  http://hackage.haskell.org/package/force-layout-0.2 (BrentYorgey)
18:38:46 <SingingBoyo> I don't remember how I first found it, but I came back to it after scala for a while.  FP is just easier to use IMNSHO.
18:39:32 <cmccann> I decided to learn Haskell because I wanted to learn a new language and it was the first one that didn't immediately annoy me for some petty reason
18:39:33 <Eduard_Munteanu> It was about time I learned a higher-level language at that time.
18:40:08 <Eduard_Munteanu> Basically it boiled down to that, plus "holy crap this is crazy". :)
18:40:20 <ion> byorgey: Ooh, force-layout sounds cool.
18:41:44 <startling> what should I require for `base` in my cabal file? base == 4.*? would that work with 7.6?
18:42:39 <parcs`> some people use base < 5
18:43:22 <cmccann> one version of base prior to whatever I have installed seems to be an enduringly popular choice
18:44:00 <Ralith> you should require exclusively the exact version of base that you have installed
18:44:04 <Ralith> your users will thank you
18:44:31 <cmccann> yes, that's also a good plan
18:44:36 <gienah> Ralith: I won't, but then I'd just hack it to remove the stupid == dep
18:44:57 <parcs`> or they will write an angry blog post about how shitty cabal is once you forget to bump the upper constraint on the base version after a ghc release
18:45:19 <rwbarton> well people who are using a different version of GHC will just not become your users
18:45:24 <rwbarton> so, Ralith's statement remains true
18:45:33 <cmccann> everyone immediately upgrades their GHC when a new version comes out anyway, right?
18:45:38 <Ralith> haha
18:45:44 <Eduard_Munteanu> Normally you should do some testing / educated guesses, but that takes time.
18:45:50 <parcs`> everyone worth talking to
18:45:54 <gienah> not on Gentoo, like I'd just hack the stupid dep and see if it builds with ghc head :-)
18:46:49 * gienah builds ghc from git :-)
18:46:50 <Eduard_Munteanu> gienah: what's with the weird 0/7.4.2 ghc slot btw?
18:47:15 <gienah> Eduard_Munteanu: that's to rebuild the deps when ghc is upgraded
18:47:32 <cmccann> Eduard_Munteanu, no see that's what the base version constraint is for, testing. it's like a quickcheck property for "does the user have the right version of GHC"
18:47:57 <gienah> Eduard_Munteanu: and there's more EAPI=5 sublot deps to rebuild the immediate reverse deps when haskell libraries are updated
18:48:22 <Eduard_Munteanu> I see... I recently upgraded to the latest platform and saw that.
18:50:04 <ion> @ask byorgey Out of curiosity, why does force-layout hide “ala” from lens and use newtype instead?
18:50:04 <lambdabot> Consider it noted.
19:08:14 <hpaste> Shamanoid pasted “Error” at http://hpaste.org/78832
19:08:36 <TheShamanoid> guys can someone help me understand the error posted above?
19:09:15 <TheShamanoid> i am trying to implement a recursive function that keeps adding key:value pair to a database
19:09:27 <TheShamanoid> up until now it keeps getting harder and harder
19:09:38 <TheShamanoid> i tried to use higher order functions but failed :(
19:09:49 <rwbarton> what's Arg
19:10:41 <shachaf> @arrgh
19:10:41 <lambdabot> Smartly me lass
19:10:49 <rwbarton> the key type of a Map needs to be an instance of Ord, because Map is implemented as a balanced binary search tree
19:10:50 <shachaf> TheShamanoid: You should probably @paste your code along with the error. :-)
19:11:14 <shachaf> But also what rwbarton said.
19:11:52 <TheShamanoid> rwbarton: alright, i see my mistake now
19:12:15 <TheShamanoid> rwbarton: Arg is simply a data structure that ends up being a bunch of tuples
19:17:00 <TheShamanoid> rwbarton: Thank you very much!
19:17:19 <rwbarton> You should also try to understand how GHC said (part of) what I said. :)
19:17:45 <shachaf> #haskell :: GHCese -> English
19:18:21 <TheShamanoid> rwbarton: Yes sir! I linked what you said to the ghc error and now it makes sense.
19:18:40 * hackagebot partly 1.0.0.0 - Inspect, create, and alter MBRs.  http://hackage.haskell.org/package/partly-1.0.0.0 (TimDixon)
19:18:44 <startling> ^ :D
19:18:56 <shachaf> Oh boy, an MBR library for Haskell.
19:19:15 <startling> shachaf: exciting, right?
19:19:48 <shachaf> I found it startling.
19:20:00 <startling> shachaf, did you lose it?
19:20:23 <shachaf> startling: Are you accusing me of not knowing how to use commas?
19:20:42 <shachaf> tibbe: I wonder whether that's related to my RULES issue with newtype constructors.
19:20:46 <startling> shachaf: You could say that.
19:21:05 <shachaf> I've tracked it down to GHC inlining newtype constructors into a cast at the first, gentlest inlining pass, before any RULES ever have a chance to fire.
19:21:30 <shachaf> It doesn't happen with accessors because accessors apparently behave more like an a real function.
19:21:46 <shachaf> (I guess they are a real function, just automatically defined.)
19:37:56 <byorgey> ion: oh, I don't know, I assumed they were diferent.  Is the 'ala' from lens really just the same as the one from force-layout?
19:37:56 <lambdabot> byorgey: You have 1 new message. '/msg lambdabot @messages' to read it.
19:38:05 <byorgey> er, I mean the same as the one from newtype?
19:38:21 <shachaf> byorgey: It's changed in 3.7
19:38:27 <shachaf> Now it's like the newtype one.
19:38:28 <byorgey> note I was converting from some existing code that used newtype and fclabels
19:38:36 <lewis1711> does anyone know, off the top of their head, what groupBy is in big O?
19:39:08 <shachaf> @src groupBy
19:39:09 <lambdabot> groupBy _  []       =  []
19:39:09 <lambdabot> groupBy eq (x:xs)   =  (x:ys) : groupBy eq zs
19:39:09 <lambdabot>     where (ys,zs) = span (eq x) xs
19:39:12 <copumpkin> lewis1711: O(1), like everything in Haskell ;)
19:39:15 <shachaf> @src span
19:39:15 <lambdabot> span _ xs@[]                     =  (xs, xs)
19:39:15 <lambdabot> span p xs@(x:xs') | p x          =  let (ys,zs) = span p xs' in (x:ys,zs)
19:39:15 <lambdabot>                   | otherwise    =  ([],xs)
19:39:24 <monochrom> copumpkin++
19:39:37 <copumpkin> lewis1711: it's linear in how much you ask for
19:40:04 <JoeyA> Note that groupBy only compares adjacent items.
19:40:12 <lewis1711> really?
19:40:21 <JoeyA> > groupBy (==) [1,2,2,3,5,5,8]
19:40:22 <lambdabot>   [[1],[2,2],[3],[5,5],[8]]
19:40:28 <JoeyA> > groupBy (==) [1,2,2,3,5,5,8,3,5]
19:40:30 <lambdabot>   [[1],[2,2],[3],[5,5],[8],[3],[5]]
19:40:40 <copumpkin> JoeyA: it doesn't actually do adjacent items, but people want it to
19:40:46 <copumpkin> it compares each item with the beginning of each group
19:40:47 <monochrom> w00t new Cartesian Closed Comic!
19:41:11 <monochrom> haha, "I wish Simon Marlow worked for me"
19:41:20 <shachaf> monochrom: That one came out several days ago!
19:41:26 <shachaf> We need to set up a bot to notify monochrom.
19:41:30 <JoeyA> If you want to consolidate the two 3s or 5s, you'll have to sort the list first.
19:41:32 <monochrom> I am lagged several days
19:42:05 <shachaf> copumpkin: You're supposed to give groupBy an equivalence relation.
19:42:07 <ParahSailin> i dont understand "type STRep s a = State# s -> (# State# s, a #)"
19:42:11 <shachaf> Anything else is an abuse.
19:42:15 <shachaf> So I don't care. :-)
19:42:30 <ParahSailin> i didnt know you could have -> in type constructors
19:42:32 <copumpkin> might as well make it do something meaningful if you don't
19:42:51 <monochrom> it should use unsafePerformIO to choose randomly a different but valid implementation each time
19:42:59 <shachaf> ParahSailin: If you don't understand that, you're probably not meant to. :-)
19:43:16 <JoeyA> ParahSailin: -> isn't an argument, it's an arrow
19:43:17 <shachaf> ParahSailin: (What's the issue?)
19:43:29 <JoeyA> (State# s) -> (# State# s, a #)
19:43:47 <shachaf> ParahSailin: That's just a type synonym. #define STRep(s,a) ((State# s) -> (# State# s, a #))
19:45:25 <JoeyA> Is it possible for a FunPtr callback to call back into the RTS from another OS thread when the program is not compiled with -threaded ?
19:45:51 <shachaf> I imagine it's not a good idea.
19:46:14 <JoeyA> But it's okay when compiled with -threaded, right?
19:48:58 <JoeyA> Stepping back: without -threaded, is there any way to wake up a Haskell thread from C-land, when the C code runs in a different OS thread?
19:50:58 <ParahSailin> shachaf, whoa, interesting
19:51:31 <rwbarton> uh, you could talk to yourself with a pipe, I guess?
19:51:54 <shachaf> Signals!
19:53:00 <danny> Perhaps someone can explain this here, how can haskell be purely functional and yet have performUnsafeIO ? They seem to be at odds but perhaps I'm wrong
19:53:25 <shachaf> danny: It can't.
19:53:41 <shachaf> When people say "Haskell is purely functional", they're ignoring unsafePerformIO.
19:53:49 <shachaf> Mostly because you don't use it for writing normal code.
19:53:57 <shachaf> That's why it's called unsafe. :-)
19:54:22 <monochrom> you should ask, how can haskell be purely functional and yet have FFI
19:54:33 <danny> shachaf: Makes sense haha. So what situations is it meant for?
19:54:40 <shachaf> monochrom: I don't think those are at odds.
19:54:56 <shachaf> Unless you count FFI without "-> IO ..." at the end, which is defined in terms of unsafePerformIO, I think.
19:54:57 <monochrom> FFI is more impure than unsafePerformIO
19:55:04 <liyang> danny: nothing. If you need you ask, you shouldn't use it.
19:55:15 <Eduard_Munteanu> C is impure, not the FFI ;)
19:55:17 <shachaf> danny: Lots of different situations, which you'll discover as you learn more Haskell. :-)
19:55:19 <monochrom> Safe Haskell foregoes both
19:55:19 <liyang> *need to ask.
19:55:54 <shachaf> foo :: IO Int; foo = ...; foreign export foo :: IO Int foreign import "foo" bar :: Int
19:56:03 <danny> Alright fair enough. I'm just going to continue being excited with my epiphany about monads
19:56:11 <monochrom> "C is impure, not the FFI" is the same as "what you give to unsafePerformIO is impure, not unsafePerformIO"
19:56:39 <shachaf> monochrom: You could have an FFI from Haskell to the lambda calculus.
19:56:45 <shachaf> It would probably be as "pure" as anything.
19:57:04 <monochrom> "unsafePerformIO (return x)" is as pure as that, too
19:57:43 <shachaf> I think the word "pure" is too ill-defined to argue about.
19:57:45 <copumpkin> return . unsafePerformIO is fine too!
19:57:46 <cmccann> but "return (unsafePerformIO x)" isn't
19:57:47 <copumpkin> >_>
19:57:48 <copumpkin> <_<
19:57:54 * copumpkin slaps cmccann 
19:57:57 <cmccann> >:[
19:58:11 <danny> cmccann: Why's that?
19:58:25 <cmccann> it makes thing work all stupid
19:58:30 <shachaf> return . unsafePerformIO can be used to implement monochromatic concurrency, as monochrom will surely point out.
19:58:35 <copumpkin> it's more or less unsafeInterleaveIO
19:58:44 <Eduard_Munteanu> What? Heh.
19:58:50 <cmccann> modulo some tweaks that unsafeInterleaveIO uses
19:58:58 <cmccann> to make it behave better in some way I can't recall
19:59:00 <monochrom> no, "pure" is sufficiently well-understood enough here. instead, some people prefer to split hair on "who is being impure", at the level of "guns don't kill, shooter does"
19:59:48 <shachaf> I'm not sure what "pure" really means anymore.
19:59:54 <cmccann> :t pure
19:59:55 <lambdabot> Applicative f => a -> f a
20:00:01 <cmccann> problem solved!
20:00:02 <shachaf> thanks cmccann
20:00:05 <shachaf> than
20:00:10 <shachaf> n
20:02:11 <monochrom> I can play that game too. neither guns nor shooters kill. it's the shootee's body's reaction to high-speed impact that kills. yes that's right, if someone shoots you, it's your fault to die. are you happy now?
20:02:45 <shachaf> Makes sense to me.
20:02:51 <monochrom> neither FFI nor the C code it calls is impure. it's the hardware running it that's impure. are you happy now?
20:02:57 <shachaf> Being shot ought to be illegal.
20:04:59 <shachaf> Maybe sequence should be the primitive of Applicative
20:05:03 <danny> On a historical note: If the FFI creates such weird situations, why did it get added in the first place?
20:05:07 <Eduard_Munteanu> Yeah, who are you to get shot like that?
20:05:21 <liyang> Guns don't kill people: http://www.youtube.com/watch?v=VT2YYLkIFZ4
20:05:26 <shachaf> danny: Because it's useful.
20:05:29 <cmccann> danny, because there's a lot of useful libraries written in C
20:06:03 <danny> It wasn't part of the original specification was it?
20:06:34 <danny> meh scratch that, I can google
20:06:37 <shachaf> Nope, it was added to the Report in Haskell 2010
20:06:43 <shachaf> Before that it was an addendum to Haskell 98
20:06:50 <cmccann> it's been around much longer than it's been in the report though.
20:07:21 <shachaf> Sure.
20:07:36 <shachaf> Interfacing with the world is pretty important.
20:08:30 <cmccann> interfacing with the world is necessary for shooting people to demonstrate monochrom's point
20:09:13 <shachaf> Is shooting people pure?
20:09:32 <danny> Depends on if shooting somewhat once is equivalent to shooting them multiple times
20:09:41 <monochrom> if it can be rolled back, it's pure
20:10:06 <cmccann> guess it depends on where you shoot them, and how close the nearest hospital is.
20:10:36 <Eduard_Munteanu> You can shoot them repeatedly, won't make much difference :P
20:11:24 <Eduard_Munteanu> Also, death seems monadic.
20:12:00 <Eduard_Munteanu> i.e. you can kill people, and if you kill a corpse, you get bac a corpse.
20:12:01 <shachaf> Eduard_Munteanu: Nonsense. There are lots of ways of modeling death that don't involve monads.
20:12:08 <Eduard_Munteanu> *back
20:12:17 <monochrom> what is >>= for death?
20:12:24 <danny> Does that mean that death can fail?
20:12:27 <shachaf> I think death is a free monad at best.
20:12:33 <cmccann> see, this is why uniqueness types are handy, because it's safe to shoot someone if nobody knows who they are
20:12:50 <cmccann> it's only when there are multiple references to the same person that you get in trouble
20:13:08 <shachaf> cmccann: This sounds more like GC to me.
20:13:09 <Eduard_Munteanu> join makes more sense.
20:13:17 <shachaf> If you have a group of people who don't know each other, you can shoot all of them.
20:13:22 <shachaf> (As long as no one else knows them.)
20:13:32 <Eduard_Munteanu> Actually it's a closure operator.
20:13:33 <cmccann> sounds sensible enough.
20:13:34 <shachaf> Er.
20:13:37 <shachaf> Who *do* know each other.
20:14:00 <cmccann> yes, I figured that's what you meant.
20:14:24 <Eduard_Munteanu> Sounds like quantum physics.
20:16:08 <danny> So in conclusion, if we raise someone in total isolation, it's pure to shoot them? That sounds twisted somehow...
20:17:29 <liyang> In other words, if a bear shits in the woods, and no trees fall over…
20:17:36 <liyang> Wait, how does that go again?
20:17:44 <monochrom> now this depends on what you mean by pure, i.e., what you want to observe
20:18:00 <shachaf> liyang: If an optimization changes semantics and no one observes it, is it still unsound?
20:18:30 <monochrom> yes, purity is based on "you do/don't observe a difference", so first you should know what you're observing and what you aren't
20:19:10 <monochrom> "let x=2*2 in x+x" and "(2*2)+(2*2)" may not look so similar anymore if you start observing execution costs
20:19:27 <monochrom> @quote monochrom debug
20:19:27 <lambdabot> monochrom says: it was fun debugging Debug :)
20:19:37 <monochrom> @quote monochrom observ
20:19:38 <lambdabot> No quotes match. I am sorry.
20:20:12 <monochrom> I once said something about a debugger showing you what you aren't supposed to observe, and it's the point of debugger
20:20:51 <ParahSailin> {-# UNPACK #-} in a constructor means the data type is stored in memory unboxed a la c struct?
20:21:14 <shachaf> It means the field is stored unpacked inside the data type.
20:21:28 <shachaf> For example, data Foo = Foo !Int !Int will have two machine integers stored directly next to each other.
20:24:57 <danny> Hey can someone point me to a good resource on understanding lazyness and sequencing type things in haskell? I'm unable to find anything satisfingly complete
20:25:05 <shachaf> @where lazy
20:25:06 <lambdabot> http://www.vex.net/~trebla/haskell/lazy.xhtml
20:25:10 <shachaf> That's a good page.
20:27:59 <danny> What that works "@ where <subject>" or was lazy specifically cached...
20:28:34 <shachaf> It works if you're lucky, or if you know your way around.
20:29:52 <nazeer> hello
20:43:47 <Refried__> is there a venn (or other) diagram somewhere that shows the relationships between various type classes?
20:44:08 <Refried__> e.g. Monad, Functor, Applicative
20:45:46 <TheShamanoid> guys is there a function like     a0 -> IO a0     ?
20:45:53 <Ralith> :t return
20:45:54 <copumpkin> @where typeclassopedia
20:45:54 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
20:45:55 <lambdabot> Monad m => a -> m a
20:46:06 <copumpkin> Refried__: ^
20:46:16 <Refried__> copumpkin: thanks, checking it out now
20:46:48 <TheShamanoid> Ralith: Thanks! Can't believe i forgot about return
20:47:21 <Refried__> copumpkin: there's totally a diagram!
20:50:43 <Refried__> and it looks like a good tutorial probably too
20:50:47 <Refried__> thanks
20:58:16 <danny> Refried_: It is, I'm halfway through.
20:58:47 <danny> Have you guys seen: http://www.willamette.edu/~fruehr/haskell/evolution.html
21:01:55 <Cale> danny: Yeah, that's been around for some time now :)
21:02:18 <shachaf> @where evolution
21:02:19 <lambdabot> http://www.willamette.edu/~fruehr/haskell/evolution.html
21:02:22 <Cale> It was around when I was still just learning Haskell :)
21:02:51 <danny> shachaf: Darn it... I should probably have seen that coming
21:03:02 <danny> forgive me, im still a n00b
21:03:22 <sclv> great shame, you posted and old link :-P
21:03:57 <shachaf> We need a version of that code that uses lenses.
21:04:29 <monochrom> heh
21:04:44 <Cale> Is there a sufficiently clever way to use lenses to compute factorial though?
21:05:01 <shachaf> > productOf folded [1..5] -- Not that I can think of off-hand.
21:05:03 <lambdabot>   120
21:06:30 <shachaf> Cale: Clearly this is a deficiency of the lens library.
21:06:54 <rwbarton> how about a traversal for extracting one element from a list and returning the remaining items of the list somehow
21:07:08 <rwbarton> that wasn't very coherent but i guess you know what i mean
21:07:27 <shachaf> Iso [a] (Maybe (a,[a]))?
21:07:48 <rwbarton> I was thinking more like Traversal [a] (a,[a]) but it wouldn't be a traversal
21:07:58 <shachaf> Which you can probably make into a (:) Prism, I guess.
21:08:19 <lewis1711> is there a function that iterates through a list, applies a function to every element, and if the function returns True to any element, exits and returns true? (or false)
21:08:25 <shachaf> ...Which would be what you said, too.
21:08:30 <shachaf> @ty any
21:08:31 <lambdabot> (a -> Bool) -> [a] -> Bool
21:08:45 <lewis1711> that's the one
21:08:46 <lewis1711> ty
21:08:49 <rwbarton> I mean all the ways of taking out one element of the list
21:08:54 <shachaf> @hoogle (a -> Bool) -> [a] -> Bool
21:08:54 <lambdabot> Prelude all :: (a -> Bool) -> [a] -> Bool
21:08:54 <lambdabot> Data.List all :: (a -> Bool) -> [a] -> Bool
21:08:54 <lambdabot> Prelude any :: (a -> Bool) -> [a] -> Bool
21:09:01 <shachaf> rwbarton: Oh, I see.
21:09:11 <rwbarton> then somehow iterating this to get factorial
21:09:19 <shachaf> You mean computing factorial by computing permutations.
21:09:28 <rwbarton> yeah
21:09:53 <TheShamanoid> guys i am getting this error when i compile my final code : <interactive>:1:3:    lexical error in string/character literal at character 'h'
21:10:15 <TheShamanoid> Googling it gives me extremely ambiguous answer, am i doomed?
21:10:22 <rwbarton> Or you can just take a State-ful recursive computation and write it using lenses and prisms
21:10:28 <shachaf> TheShamanoid: Oh, well, just move the eighth character four to the right and it'll compile.
21:10:42 <shachaf> TheShamanoid: (You're not giving nearly enough information for people to help you. The line you're typing in would be a good start.)
21:11:03 <rwbarton> how are you getting an error about <interactive> if you're compiling
21:12:00 <rwbarton> I guess you probably don't mean compiling.
21:12:16 <TheShamanoid> rwbarton: Sorry, i meant testing my compiled code on a file
21:12:34 <TheShamanoid> shachaf: it compiles prefectly
21:12:44 <shachaf> TheShamanoid: Well then! Problem solved.
21:13:10 <TheShamanoid> shachaf: ?
21:13:27 <shachaf> You just said it compiles prefectly. :-)
21:13:34 <shachaf> If it doesn't, then what I said holds.
21:13:42 <TheShamanoid> -_-
21:13:48 <TheShamanoid> alright as you wish
21:14:26 <TheShamanoid> can't disagree with your logic :(
21:15:03 <hpaste> Fūzetsu pasted “pit” at http://hpaste.org/78833
21:16:20 <hpaste> Fūzetsu annotated “pit” with “SHII BAAJON” at http://hpaste.org/78833#a78834
21:16:35 <shachaf> TheShamanoid: My logic is mostly "we can't help you if you don't tell us what the problem is". :-)
21:16:48 <Fuuzetsu> Can anyone explain why the logically equivalent Haskell code is *so* much slower than the C (see paste)?
21:17:09 <Fuuzetsu> On this machine it takes about three to five times as long
21:17:38 <rwbarton> it's using Integer
21:18:01 <rwbarton> try adding a :: Int somewhere
21:18:11 <TheShamanoid> shachaf: Never mind, turns out i was compiling an old version of my main module. Works now :D
21:21:46 <Fuuzetsu> rwbarton: Int doesn't seem to help significantly
21:22:24 <Fuuzetsu> ./pit  166.46s user 8.90s system 99% cpu 2:56.84 total
21:22:31 <Fuuzetsu> ./pit-c  14.61s user 0.10s system 99% cpu 14.790 total
21:23:05 <rwbarton> that doesn't look like "three to five times as long"
21:23:17 <Fuuzetsu> I may have underestimated slightly
21:23:32 <travitch> try mapM_ -- mapM is going to allocate a list
21:23:56 <rwbarton> I assume you are compiling with -O2?
21:24:43 <Fuuzetsu> Ah, that did it!  Thanks
21:25:04 <rwbarton> heh. i assumed at first you must be using -O2 to get within 3-5x of C :P
21:26:10 <shachaf> mapM_ and Int are the two obvious changes to make there.
21:26:25 <shachaf> But to be more fair you might try writing the loop explicitly.
21:26:47 <rwbarton> how fast did the -O2 version end up being btw?
21:26:58 <Fuuzetsu> C 4sec vs Haskell 6 sec
21:27:14 <Fuuzetsu> But it was the mapM_ that did it, not the -O2
21:27:20 <rwbarton> er
21:27:31 <rwbarton> how long is the output?
21:27:59 <lewis1711> is there a function that takes f: (a -> a -> Bool), xs: [a], and uses f to compare each element of xs with every other element?
21:28:02 <rwbarton> it's only around maybe 10000 lines right?
21:28:06 <Fuuzetsu> 1762 lines
21:28:09 <rwbarton> oops
21:28:14 <Fuuzetsu> Could concat it, I guess
21:28:14 <rwbarton> well, pretty close
21:28:21 <rwbarton> so I don't see how the mapM_ should be such a big deal
21:28:43 <rwbarton> compared to the one billion times doing arithmetic
21:29:40 <shachaf> mapM_ doesn't make much of a difference.
21:30:08 <rwbarton> the big win should be from the combination of -O2 and Int
21:30:20 <shachaf> Switching to Int makes a big difference.
21:30:30 <shachaf> I didn't even test it without -O2, because why would you bother?
21:30:36 <Fuuzetsu> Not here... hold on
21:31:15 <shachaf> ~4.5s with Int, ~14-15s without.
21:33:46 <Fuuzetsu> ./pit_  6.74s user 0.05s system 98% cpu 6.862 total
21:34:05 <Fuuzetsu> Let me just wait while the mapM version completes...
21:34:16 <Fuuzetsu> That's both with -O2
21:34:34 <rwbarton> are you 100% sure the "mapM version" is using Int?
21:34:55 <Fuuzetsu> It's exactly the same program with mapM instead of mapM_
21:35:02 <rwbarton> also are you sure you recompiled it with -O2
21:35:05 <Fuuzetsu> The first 1000 is annotated with Int
21:35:09 <Fuuzetsu> I am very sure
21:35:25 <rwbarton> try ghc -O2 -fforce-recomp to be extra sure
21:35:42 <copumpkin> mapM vs. mapM_ can make a reasonable difference, I'd expect
21:35:53 <scp_> is there a function that will run a monad over and over and return a list of the results?
21:35:53 <shachaf> copumpkin: For a list this small?
21:36:01 <rwbarton> yes but not in this particular code
21:36:02 <copumpkin> shachaf: I just tuned in, so maybe not :)
21:36:05 <shachaf> It didn't make a huge difference when I tested it.
21:36:06 <copumpkin> scp_: replicateM
21:36:11 <randomclown> How do I use stuff like popen in haskell, i.e. pipe data to stdin/out of another process
21:36:11 <shachaf> copumpkin: The list is 1762 entries long.
21:36:13 <copumpkin> you mean monadic value
21:36:17 <scp_> copumpkin, thanks
21:36:37 <copumpkin> shachaf: yeah, I could see it making a difference then
21:36:41 * copumpkin shrugs
21:36:45 <Fuuzetsu> Ah, it was apparently not recompiling it completely -- -fforce-recomp speeds it up
21:36:46 <shachaf> scp_: (A vocabulary note: A "monad" is a type constructor like Maybe or IO; what you're thinking of is called an "action".)
21:36:46 <copumpkin> I might just be wrong :)
21:37:01 <copumpkin> Fuuzetsu: how different?
21:37:06 <shachaf> copumpkin: Sure, but it's also filtering a list of length 1000000000.
21:37:14 <copumpkin> oh
21:37:16 <Fuuzetsu> 9 seconds with mapM vs. 6 with mapM_
21:37:16 <copumpkin> okay :)
21:37:29 <shachaf> It does make a difference, just not a huge one.
21:37:34 <Fuuzetsu> *nod*
21:37:38 <shachaf> With a longer list it makes more of a difference.
21:37:51 <Fuuzetsu> fumufumu
21:39:26 <rwbarton> I'm still a bit surprised it is that large a difference
21:39:36 <rwbarton> I guess maybe because of the effect on GC
21:40:07 <travitch> mapM isn't tail recursive, so you don't get a nice tight loop like mapM_ gives you
21:40:10 <shachaf> For what it's worth, writing it as an explicit loop is much fater.
21:40:14 <rwbarton> the list comp will do a lot of allocations
21:40:15 <shachaf> faster
21:40:38 <Fuuzetsu> shachaf: You mean using explicit recursion?
21:40:43 <shachaf> The explicit loop takes ~1.4s here, and the C takes ~0.7s
21:40:49 <shachaf> Fuuzetsu: Yes.
21:41:07 <Fuuzetsu> That's a bigger time difference than we're seeing (scaled for hardware)
21:41:08 <shachaf> As it is it's making the list, which the C code doesn't need to bother with.
21:41:34 <shachaf> Fuuzetsu: Your code, with Ints and mapM_, is ~4.5s here.
21:41:41 <Fuuzetsu> Oh.
21:42:14 <scp_> shachaf, got it, thanks
21:42:31 * shachaf doesn't know how to make these explicit loops particularly nice in Haskell.
21:42:44 <rwbarton> last time I saw there was a huge difference in Haskell/C ratio between different machines it was due to one machine using LLVM
21:42:58 <rwbarton> shachaf: it's what vector is good at I guess
21:43:48 <shachaf> I'm not using LLVM, unless it's mysteriously become the default for GHC (or for Debian GCC).
21:45:27 <scp_> is there a standard library function like (fn g (x:xs) = map (g x) xs ++ fn g xs) ?
21:45:33 <scp_> plus base case =]
21:45:46 <glguy__> Fuuzetsu: concatMap aka =<<
21:46:03 <glguy__> err, scp
21:46:07 <shachaf> Also concat (map f xs)
21:46:14 <shachaf> concat . map f
21:46:18 <copumpkin> wait, that doesn't look right
21:46:24 <copumpkin> it's partially applying g
21:46:29 <glguy__> oh yeah
21:46:30 <copumpkin> to x
21:46:37 <rwbarton> isn't that more like the zip xs (tails xs) stuff
21:46:48 <shachaf> Oh, yes.
21:46:49 <copumpkin> what's sad is that it's easier to figure out what it does with a type sig
21:46:51 <copumpkin> than a definition
21:46:53 <rwbarton> pick whatever variation of that matches your code
21:47:05 <shachaf> copumpkin: That's sad?
21:47:08 <copumpkin> :t let fn g (x:xs) = map (g x) xs ++ fn g xs in fn
21:47:09 <lambdabot> (a -> a -> b) -> [a] -> [b]
21:47:09 <shachaf> Oh, using the LLVM backend for GHC makes it even faster.
21:47:15 <shachaf> ~1s
21:47:25 <shachaf> (And using clang doesn't make it any faster for the C code.)
21:47:38 <shachaf> Unfortunately the recursive Haskell is a good deal uglier than the C.
21:48:30 <latermuse> in a do block, why wont this line get passed the type checker? x <- (randomRIO (1,10) :: (Random a, Num a) => IO a)
21:48:38 <scp_> ya, I want to apply a binary function to every possible pair from a list, but never apply it to an element and itself, and never apply it to the same pair twice
21:48:57 <latro`a> latermuse, I think it is probably too polymorphic
21:49:20 <latermuse> latro`a: are there any quick fixes for that?
21:49:31 <latro`a> does it compile without the signature?
21:49:32 <rwbarton> delete the type signature?
21:49:37 <copumpkin> > liftA2 (=<<) zip (tail . tails) $ [1..4]
21:49:39 <lambdabot>   [(1,2),(2,3),(3,4),(1,3),(2,4),(1,4)]
21:49:47 <copumpkin> >_>
21:49:47 <latermuse> doesnt work without the type signature either
21:49:56 <rwbarton> > liftA2 (=<<) (zipWith g) (tail . tails) $ [1..4]
21:49:57 <lambdabot>   Ambiguous type variable `b0' in the constraints:
21:49:57 <lambdabot>    (GHC.Show.Show b0)
21:49:57 <lambdabot>     ...
21:50:10 <rwbarton> > liftA2 (=<<) (zipWith (g :: Int) (tail . tails) $ [a,b,c,d]
21:50:12 <lambdabot>   <hint>:1:60: parse error (possibly incorrect indentation)
21:50:17 <rwbarton> > liftA2 (=<<) (zipWith g) (tail . tails) $ [a,b,c,d]
21:50:19 <lambdabot>   Ambiguous type variable `b0' in the constraints:
21:50:19 <lambdabot>    (GHC.Show.Show b0)
21:50:19 <lambdabot>     ...
21:50:21 <rwbarton> bah
21:50:33 <shachaf> > let g :: Expr -> Expr -> Expr; g = fun "g" in liftA2 (=<<) (zipWith g) (tail . tails) $ [1..4]
21:50:34 <lambdabot>  Terminated
21:50:37 <shachaf> > let g :: Expr -> Expr -> Expr; g = fun "g" in liftA2 (=<<) (zipWith g) (tail . tails) $ [1..4]
21:50:38 <copumpkin> > liftA2 (=<<) (zipWith (g :: Expr -> Expr -> Expr)) (tail . tails) $ [a,b,c,d]
21:50:39 <lambdabot>   can't find file: L.hs
21:50:39 <lambdabot>   [g 1 2,g 2 3,g 3 4,g 1 3,g 2 4,g 1 4]
21:50:47 * copumpkin sighs
21:50:54 <scp_> ok, so there isn't a standard library function =]
21:51:16 <scp_> seemed like a common thing to do, thought maybe there was
21:51:26 <scp_> thanks folks
21:52:03 <rwbarton> :type randomRIO (1,10)
21:52:08 <copumpkin> > iterate (flip [length, head] <=< group) [1]
21:52:09 <rwbarton> :t randomRIO (1,10)
21:52:10 <lambdabot>   Couldn't match expected type `a0 -> b0 -> c0'
21:52:10 <lambdabot>              with actual type...
21:52:10 <lambdabot> (Num a, Random a) => IO a
21:52:21 <copumpkin> > iterate (sequence [length, head] <=< group) [1]
21:52:23 <lambdabot>   [[1],[1,1],[2,1],[1,2,1,1],[1,1,1,2,2,1],[3,1,2,2,1,1],[1,3,1,1,2,2,2,1],[1...
21:52:23 <copumpkin> :t flip
21:52:24 <lambdabot> (a -> b -> c) -> b -> a -> c
21:52:26 <copumpkin> wtf
21:52:27 <rwbarton> latermuse: since that is the type of the expression anyways I doubt that can ever do any good. you have some problem elsewhere
21:52:29 <copumpkin> :t (.)
21:52:30 <lambdabot> Functor f => (a -> b) -> f a -> f b
21:52:38 <copumpkin> Cale: what is this abomination?
21:52:45 <shachaf> copumpkin: We got him to take flip back.
21:52:46 <copumpkin> flip is ungeneralized!
21:53:20 <shachaf> Might as well generalize it to (MonadReader (a -> b) m, Functor f) => m (f a -> f b), right?
21:53:25 <latermuse> rwbarton: thanks. ill look around more then
21:53:39 <copumpkin> > map (succ . head . tail) . iterate (drop 2) . map length . group . fix $ show
21:53:43 <lambdabot>   mueval-core: Time limit exceeded
21:53:50 <copumpkin> > take 6 . map (succ . head . tail) . iterate (drop 2) . map length . group . fix $ show
21:53:52 <lambdabot>   [2,4,8,16,32,64]
21:54:06 * copumpkin goes to sleep
21:54:33 <shachaf> So what's a good way of writing Fuuzetsu's loop in Haskell?
21:54:54 <shachaf> I wrote some really ugly code for it and I want it to be nicer.
21:55:12 <rwbarton> doesn't vector fuse this kind of code well
21:55:28 <copumpkin> stream fusion isn't particularly good at concatMap iirc
21:55:45 <shachaf> copumpkin: I mean http://hpaste.org/78833
21:55:50 <copumpkin> but you can probably massage it into a good form
21:55:57 <copumpkin> yep
21:56:04 <copumpkin> that's gonna use concatMap translated naively
21:56:19 <shachaf> Oh, you weren't talking about the other thing.
21:58:05 <rwbarton> well presumably you can generate a stream for the (x,y,z) triples one way or another
21:58:08 <copumpkin> clearly the best solution is just to generate the pythagorean triples in an efficient manner :)
21:58:33 <copumpkin> stealing a page from Cale's book
21:58:54 <copumpkin> @let posRationals = 1 : fix ((1 % 1 :) >=> \x -> [1+x, 1 / (1 + x)]); pyth r = (x,y,z) where m = numerator r; n = denominator r; [x,y,z] = sort [2*m*n, m^2 - n^2, m^2 + n^2]
21:58:55 <lambdabot>  <local>:1:28:
21:58:55 <lambdabot>      Not in scope: `%'
21:58:55 <lambdabot>      Perhaps you meant `R.%' (imported ...
21:59:01 <rwbarton> there is concatMap for Stream for instance
21:59:05 * copumpkin sighs
21:59:26 <copumpkin> @let posRationals = 1 : fix (((1 :: Rational) :) >=> \x -> [1+x, 1 / (1 + x)]); pyth r = (x,y,z) where m = numerator r; n = denominator r; [x,y,z] = sort [2*m*n, m^2 - n^2, m^2 + n^2]
21:59:28 <lambdabot>  Defined.
21:59:36 <copumpkin> > map (pyth . (+1)) posRationals
21:59:38 <lambdabot>   [(3,4,5),(6,8,10),(5,12,13),(8,15,17),(7,24,25),(20,21,29),(16,30,34),(10,2...
22:00:24 <copumpkin> rwbarton: it's there, but I don't think it fuses very well (I thought that was one of the main reasons we hadn't moved to stream fusion everywhere)
22:00:29 <copumpkin> or at all
22:00:38 <rwbarton> i forgot how much i hate trying to navigate the vector source
22:01:01 <shachaf> copumpkin: A pithy way of expressing that list.
22:01:10 <copumpkin> shachaf: way more efficient than the original!
22:01:26 <copumpkin> > map (pyth . (+1)) posRationals !! 1001
22:01:28 <lambdabot>   (12100,12141,17141)
22:01:34 <copumpkin> beat that!
22:01:46 <shachaf> copumpkin: I was redirecting the original program to /dev/null, so all I was actually measuring was the runtime.
22:01:53 <shachaf> So main = return () is probably even better.
22:01:55 <copumpkin> :P
22:02:32 <rwbarton> > posRationals
22:02:34 <lambdabot>   [1 % 1,2 % 1,1 % 2,3 % 1,1 % 3,3 % 2,2 % 3,4 % 1,1 % 4,4 % 3,3 % 4,5 % 2,2 ...
22:06:31 <rwbarton> shachaf: what if you just write forM_ [1..1000] $ \x -> ..., is that bad too because it has to build the list?
22:06:58 <rwbarton> obviously it would be possible to fuse forM_ (enumFromTo a b)
22:07:25 <shachaf> rwbarton: Yep.
22:07:37 <shachaf> That still allocates the list.
22:09:22 <rwbarton> forM_eft a b f = go a where go n | n > b = return () | otherwise = f n >> go (n+1) ; {-# RULE forM_ (enumFromTo a b) = forM_eft a b #-}
22:09:25 <rwbarton> does this work
22:11:03 <shachaf> rwbarton: I was just testing similar code.
22:11:09 <shachaf> Still comes out slower than my ugly explicit loop.
22:11:11 <shachaf> (~1.7s)
22:12:28 <shachaf> Oh, it's faster when I switch the cases around.
22:12:43 <rwbarton> odd
22:15:25 <shachaf> Oh, and it's only faster with LLVM.
22:15:36 <shachaf> Otherwise they're the same speed.
22:16:08 <shachaf> I should get LLVM assembly support back into ghc-core
22:16:13 <shachaf> Except not completely broken this time.
22:21:51 <shachaf> Oh, hmm.
22:22:09 <shachaf> It looks like it's doing spurious allocations in the loop.
22:22:37 <shachaf> In particular it either allocates an I# on every iteration or a $wshowSignedInt somethingorother.
22:22:56 <shachaf> I guess GHC is floating them out.
22:23:33 <shachaf> So doing this gets it back to ~1s:
22:23:40 <shachaf> pr :: Int# -> Int# -> Int# -> IO (); pr x y z = print (I# x,I# y,I# z); {-# NOINLINE pr #-}
22:23:46 <shachaf> when (x*x+y*y==z*z) $ pr (case x of I# x# -> x#) (case y of I# y# -> y#) (case z of I# z# -> z#)
22:24:07 <rwbarton> um
22:24:09 <rwbarton> ok
22:24:20 <shachaf> Hopefully there's a better way of doing it than that. :-)
22:24:37 <rwbarton> this with forM_eft-like stuff?
22:25:13 <shachaf> Yes.
22:25:33 <shachaf> loopFromTo :: Monad m => Int -> Int -> (Int -> m ()) -> m (); loopFromTo lo hi f = go lo where go n | n > hi    = return () | otherwise = f n >> go (n+1)
22:26:47 <shachaf> Taking the NOINLINE out makes it slower.
22:29:59 <shachaf> Only z actually needs to do the I# thing.
22:30:23 <rwbarton> does it not know print is strict somehow?
22:30:57 <shachaf> To compete with the C code fairly, this should be constructing a string explicitly instead of using Show, of course.
22:31:02 <rwbarton> and then without the NOINLINE it substitutes for pr and "simplifies" (case x of I# x# -> x#) and forgets that is strict too?
22:31:28 <rwbarton> it should be using printf :P
22:32:11 <shachaf> FSVO "fair"
22:32:48 <rwbarton> what if you write print $! ((((,,) $! x) $! y) $! z)
22:33:41 <rwbarton> I guess maybe it already knows print (x,y,z) is strict in x,y,z
22:33:43 <shachaf> That acts like the regular print
22:34:35 <shachaf> Oh, GHC is floating out the x*x and y*y
22:34:45 <shachaf> Well, maybe GCC is doing that too, with the C code.
22:38:19 <rwbarton> is your ugly explicit loop code a single loop "go x y z" or three nested loops?
22:38:19 <shachaf> Hmm, I can't quite figure out what's going on.
22:38:40 <shachaf> Three nested loops.
22:39:16 <shachaf> main = go where go :: IO (); go = goX 1 where goX :: Int -> IO (); goX x | x <= 1000 = goY 1 where goY :: Int -> IO (); goY y | y <= 1000 = goZ 1 where goZ :: Int -> IO (); goZ z | z <= 1000 = do when (x*x+y*y==z*z) $ print (x,y,z) goZ (z+1); goZ _ = goY (y + 1); goY _ = goX (x + 1); goX _ = return ()
22:39:21 <shachaf> With more {}
22:40:23 <shachaf> (One "go" with three arguments is slower.)
22:42:57 <Kosta> How do I recover from a `read` that fails?
22:43:08 <shachaf> Kosta: If you're using GHC 7.6, Text.Read has readMaybe
22:43:20 <Kosta> shachaf: thanks!
22:43:21 <shachaf> Otherwise, you have to use reads and pattern-match on the result.
22:43:26 <Kosta> I should have hoogled that
22:43:50 <shachaf> I don't think 7.6 is in Hoogle yet.
22:46:38 <Kosta> oh no, I'm using GHC 4.3
22:46:42 <Kosta> err 7.4
22:46:51 <shachaf> OK, then you'll have to use reads
22:47:24 <shachaf> http://www.haskell.org/haskellwiki/FAQ#How_do_I_catch_the_error_thrown_by_read_on_a_parse_failure.3F
22:47:43 <shachaf> Probably that ought to be updated about 7.6 sometime.
22:48:05 <Kosta> Couldn't I just recover from the error?
22:48:11 <Nereid> not outside IO
22:48:21 <Kosta> shachaf: ok you posted before I could ask
22:51:08 <Kosta> shachaf: Thanks, that did the trick :)
22:53:55 <Kosta> Is anyone here familiar with attoparsec and ByteString.Lazy?
22:54:31 <shachaf> It's quite possible. If you have a question you should ask it. :-)
22:54:48 <Kosta> Because I wrote a logfile parser using those but it does seem to behave strictly
22:55:52 <Kosta> If I feed it 100 log lines, it returns immediately. If I feed it a a million log lines, it outputs nothing and eats up a lot of ram
22:56:10 <Kosta> (and 100% of one CPU)
22:56:29 <shachaf> I think Attoparsec doesn't generally parse "lazily", though it has some special mechanism for feeding it chunks, or something?
22:56:39 <shachaf> Doesn't it have something like parse :: Input -> Either Error Output?
22:56:58 <Kosta> kinda
22:57:16 <Kosta> Ah I see
22:57:28 <shachaf> Oh, it has IResult t r = Fail t [String] String | Partial (t -> IResult t r) | Done t r
22:57:32 <Kosta> it can only know whether it's a failure after parsing everything
22:57:35 <shachaf> So maybe it does support it somehow? I don't know.
22:57:45 <shachaf> But if it does you probably have to do it explicitly.
22:57:57 <shachaf> I think tibbe recently added streaming support to cassava; maybe you can look at that.
22:59:09 <Kosta> I think I need to use the strict version of attoparsec, that can produce intermediary results
23:00:59 <Kosta> and here I though I had found a way around that...
23:01:18 <shachaf> Lazy parsing is tricky when you need to handle failure.
23:01:23 <MrWoohoo> Hmmmm, any idea why ghc is telling me it cant find Data.MultiSet??? All I've done is install haskell-platform over my previous mismash install
23:01:59 <shachaf> MrWoohoo: Probably because Data.MultiSet isn't part of haskell-platform!!!
23:02:24 <MrWoohoo> ah… "cabal list |grep'ing I go
23:02:27 <rwbarton> (Hint: You only need a single question mark to make a question.)
23:02:45 <shachaf> MrWoohoo: Google also works.
23:02:53 <shachaf> @google Data.MultiSet haskell
23:02:54 <lambdabot> http://hackage.haskell.org/packages/archive/multiset/0.1/doc/html/Data-MultiSet.html
23:02:55 <lambdabot> Title: Data.MultiSet
23:07:08 <Kosta> well, it seems that you can feed incomplete input to attoparsec but it will only produce output after the parsing is done. That's due to returning error conditions after the whole parse is done
23:07:32 <shachaf> Yep.
23:07:42 <shachaf> Not much you can do about that, if you want that behavior.
23:07:54 <jerng> Has anyone here successfully run the Warp on WAI in Windows?
23:08:12 <shachaf> The alternative would be something like producing a stream of tokens, which might end with an error.
23:08:35 <Kosta> well I would be happy with the alternative, but it seems it's not supported by attoparsec
23:08:55 <Kosta> but what I can do is call `lines` on the input and then parse each line
23:09:01 <Kosta> jerng: What's the problem?
23:09:06 <Nereid> right, attoparsec isn't an incremental parser
23:09:13 <Nereid> er, parser library :p
23:09:48 <Kosta> Had I known that than I wouldn't have converted my parser to it :)
23:10:30 <jerng> Kosta: "user error (accept: can't perform on socket ((AF_INET,Stream,0)) in status Closed)
23:10:32 <jerng> "
23:11:59 <Kosta> does this happen right on startup?
23:12:11 <Kosta> which port do you try to bind to?
23:12:28 <jerng> 3000?
23:13:42 <jerng> kosta: if I runghc a wai_hello_world.hs I get a blinking prompt; running in GHCI for more verbose feedback renders a pause after "Loading package warp-1.3.2" and after that if I Ctrl-C, I see the above error message.
23:18:26 <Kosta> jerng: which output do you expect?
23:18:37 <Kosta> did you try making http requests to port 3000?
23:18:57 <jerng> I expect the webserver to run on localhost:3000, but there is no response.
23:20:27 <Kosta> is that wai_hello_world written by you or from the internet?
23:21:35 <jerng> It's written by me, and it works in Linux.
23:28:59 <Kosta> hm, sorry I don't have a haskell on windows right here
23:29:02 <pqmodn> Kosta: feed (Partial _) Text.Empty -- for example, you can "signal" end of input this way
23:29:34 <pqmodn> Kosta: in attoparsec, this will yield either Failure or Result
23:29:57 <Kosta> pqmodn: what's the advantage over feeding it single lines?
23:29:58 <jerng> kosta; well thanks!
23:30:08 <jerng> kosta: well thanks!
23:30:39 <pqmodn> Kosta: sorry, answering an old question probably: "need to produce intermediary results"
23:32:24 <Kosta> pqmodn: I think splitting at \n and parsing individual lines is easier than injecting Text.empty, right?
23:33:19 <pqmodn> Kosta: sounds like you're trying to parse as much valid input until you reach an error, then return (data, remaining-unparsed-input)?
23:34:01 <Kosta> Actually, I want the parser to return lines as fast as possible so that I can process them while reading the next one
23:34:44 <pqmodn> oh, pre-splitting at the line might be a decent way to go then
23:38:23 <pqmodn> Kosta: alternatively, create parseLine :: (Text -> MyData) -> Parser MyData. this combinator should stop parsing at the end of the line, then you can use parseOnly to get something like Result "remaining-input" MyData
23:39:14 <pqmodn> i forget the combinator but maybe something like takeWhile (notInClass "\n")
23:39:46 <pqmodn> :t parseOnly
23:39:47 <lambdabot> Not in scope: `parseOnly'
23:42:15 <pqmodn> sorry, more like: parse (skipSpace *> takeWhile (notInClass "\r\n")) "hello\n world" -- Done "\n world" "hello"
23:42:44 <pqmodn> Kosta: the first argument to Done is the remaining, unparsed input. the second argument is the parsed input
23:43:13 <statusfailed> Why is unsafeInterleaveIO unsafe?
23:43:33 <shachaf> It gives you a value such that evaluating the value executes some IO
23:43:49 <Kosta> statusfailed: because it "escapes" the IO monad
23:44:10 <statusfailed> Ah I see
23:44:24 <Kosta> pqmodn: Hm, that might be a way
23:44:29 <statusfailed> So if I have an IO [a]
23:44:32 <statusfailed> and it's an infinite list
23:44:36 <statusfailed> What's the best way to deal with it?
23:44:47 <statusfailed> for example, to map print over
23:45:05 <pqmodn> :t sequence
23:45:07 <lambdabot> Monad m => [m a] -> m [a]
23:45:41 <statusfailed> or is unsafeInterleaveIO the only way?
23:45:55 <simpson> :t mapM print
23:45:56 <lambdabot> Show a => [a] -> IO [()]
23:46:16 <simpson> Well, do you want to ever stop printing?
23:46:30 <statusfailed> simpson: that will never execute, I think because of the interleaving problem
23:47:06 <simpson> statusfailed: "mapM_ print [1..]" does print stuff.
23:47:19 <simpson> It just won't get to doing anything afterwards.
23:47:24 <statusfailed> simpson: it's not a list, it's an IO [a]
23:47:39 <statusfailed> err, that was poorly worded
23:47:51 <simpson> statusfailed: Hm. Well, you can get at it with (>>=) or similar, right?
23:47:58 <simpson> statusfailed: Where does it come from? Why is it infinite?
23:48:08 <statusfailed> simpson: It's a list of random numbers generated in the IO monad
23:48:34 <simpson> statusfailed: Hm. Using the standard generator?
23:48:40 <statusfailed> simpson: no, random-fu
23:48:43 <simpson> Hm.
23:49:24 <statusfailed> I can do it purely using a seed instead, but I will eventually have the same problem
23:49:53 <shachaf> statusfailed: foo :: IO [a] can't give you a lazy list that does IO at each iteration unless it uses unsafeInterleaveIO.
23:51:00 <statusfailed> ok
23:51:39 <statusfailed> oh, i'm stupid...
23:52:54 <simpson> Not at all. What's up?
23:53:38 <statusfailed> I was trying to do it with Data.Machines, so instead of making a Machine to print output, I was evaluating the machine to a list and then printing that
23:53:44 <statusfailed> which I think entirely misses the point
23:53:50 <statusfailed> :D
23:58:00 <statusfailed> Yeah, that worked
23:58:00 <statusfailed> haha
23:58:15 <statusfailed> cheers simpson , shachaf
23:58:23 <simpson> statusfailed: Sure?
23:58:29 * simpson didn't really help much, but okay
23:58:57 <statusfailed> I consider myself helped :p
