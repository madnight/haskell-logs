00:00:20 <applicative> what would python answer if you asked it to print(two)?
00:00:43 <applicative> where two is (+1)
00:01:06 <Hafydd> <function <lambda> at 0x7f1907e10290>
00:01:14 <neutrino> well, in python you can only pass functions around uncurried, unless you use a special function for currying
00:01:15 <mrxy> neutrino right. too bad it throws an error every time a function is returned, whether it is an error or not
00:01:23 <sopvop> Ha, python does not even show type.
00:01:29 <applicative> Hafydd: hm, I think the type error is more informative
00:01:30 <neutrino> mrxy: how would it know whether your hand slipped?
00:02:00 <applicative> the function is returned even when you go on to supply another argument
00:02:07 <applicative> > (+) 1 1
00:02:09 <lambdabot>   2
00:02:22 <applicative> look, a function was returned, and then a number
00:03:06 <mrxy> neutrino the error is not that you did not provide enough arguments. the error is that there is no Show instance for a function. not a very helpful error
00:03:39 <neutrino> not until you understand the deeper meaning of it, no
00:03:45 <Hafydd> However in Python, calling that function without any arguments would be an error.
00:03:55 <neutrino> but again, that's only 0.0000001% of your lifetime as a haskell developer
00:03:59 <Hafydd> TypeError: <lambda>() missing 1 required positional argument: 'x'
00:04:04 <applicative> the error is that there is no Show instance for things that need more arguments
00:04:09 <mrxy> there is no deeper meaning. ghci uses show and there's no show instance for functions
00:04:57 <sopvop> ghci is shit. lets code ruby!
00:05:15 <applicative> no, idris
00:05:26 <mrxy> if you expected an int and got a function printed instead I think you would figure out what went wrong without non-related errors being thrown at you
00:05:41 <applicative> the idris repl even has a 'proof assistant'
00:05:51 <edwardk> applicative: heresy
00:05:55 <applicative> good luck finding that in ruby
00:06:47 * hackagebot cab 0.1.15 - A maintenance command of Haskell cabal packages  http://hackage.haskell.org/package/cab-0.1.15 (KazuYamamoto)
00:06:59 <edwardk> i'm sure there will be a ruby lemmachine port ;)
00:07:02 <sopvop> I've never written a line of ruby, but have an opinion of it - 'almost PHP'.
00:07:14 <applicative> ha
00:07:28 <applicative> its much handsomer than php
00:07:36 <sopvop> is it strongly typed?
00:07:49 <neutrino> mrxy: but now you know that this error actually means "you printed out a partially applied function"
00:08:00 <neutrino> mrxy: that's the deeper meaning here
00:08:11 <applicative> they do tend to write 'end' about 40 times/page
00:08:51 * applicative praises D. Turner for saving us from nonsense like 'end' and '}'
00:10:23 <sopvop> I wonder why haskell does not get criticized for whitespace, unlike python. Sure you can write `;' style, but no-one does.
00:10:43 <applicative> .. to say nothing of 'letrec'
00:10:46 <edwardk> sopvop: it gets its share of criticism on that front
00:10:57 <elliott> sopvop: i assure you: people do
00:11:43 <LAMMJohnson> Can anybody explain the Haskell symbol to me?
00:11:55 <LAMMJohnson> it appears to be > lambda =
00:11:56 <sopvop> But not as much. Usually it goes 'interesting useless academic language'
00:12:02 <LAMMJohnson> But does that have any special signifigance?
00:12:26 <applicative> LAMMJohnson:  where do you see it
00:12:32 <edwardk> LAMMJohnson; its a mishmash of >>= which is used for 'binding' monads in haskell and a lambda.
00:12:34 <applicative> >\=
00:12:38 <Nimatek> A combination of a lambda and the monadic bind operator.
00:12:59 <elliott> "mishmash" is right
00:13:03 <LAMMJohnson> applicative: A good example is on hoogle.
00:13:04 <edwardk> LAMMJohnson: there was a logo contest a couple of years back and that one won.
00:13:08 <sopvop> >λ= ?
00:13:15 <LAMMJohnson> sopvop: That's the one.
00:13:30 <applicative> is that valid?? no
00:13:31 <sopvop> h (>λ=)
00:13:35 <sopvop> oh
00:13:35 <LAMMJohnson> I thoguht it might be related to >>=
00:13:42 <c_wraith> LAMMJohnson: it is.
00:14:05 <LAMMJohnson> It's a cool logo.
00:14:14 <sopvop> I can't find it oh noogle
00:14:35 <LAMMJohnson> sopvop: http://www.haskell.org/haskellwiki/Haskell
00:14:40 <LAMMJohnson> Top-left hand corner.
00:14:43 <sopvop> Ah
00:14:53 <LAMMJohnson> I see it all over.
00:15:08 <edwardk> LAMMJohnson: the new branding has been rather successful
00:15:11 <applicative> ah, the logo.  its a pastiche of some kind
00:15:26 <applicative> we took over amtrak's logo
00:15:54 <sopvop> I like this one http://www.haskell.org/wikiupload/1/1e/Lenny2.png
00:16:06 <edwardk> LAMMJohnson: much of the time you use >>= with an explicit lambda. >>= \ x -> ..    this kind of smashed the >>= logo into the lambda which is a more universally recognized symbol for functional programming
00:16:11 <LAMMJohnson> Hah.
00:16:25 <LAMMJohnson> sopvop: Could you imagien the confusion that would cause if put up somethere important?
00:16:27 <sopvop> old logo was horrible
00:16:31 <edwardk> http://www.haskell.org/haskellwiki/Haskell_logos/New_logo_ideas gives you the idea of the field this logo was up against
00:16:48 <shachaf> The old logo was at least circular.
00:17:02 <edwardk> shachaf: i'm not sure thats a plus ;)
00:17:25 <shachaf> edwardk: It is when you want a circular sticker!
00:17:48 <edwardk> LAMMJohnson: http://www.haskell.org/haskellwiki/Image:Haskell-logo2-max.png was the progenitor of the current logo IIRC.
00:17:49 <applicative> the old logo was so unbelievably horrible; it really boggled the mind
00:17:59 <sopvop> that one screams 'pure academic language' http://www.willamette.edu/~fruehr/logos/PNGs/HaskellLogo.png
00:18:04 <LAMMJohnson> sopvop: I like the one below that green one.
00:18:15 <applicative> it was like lambdas and monadic binds stuck on a sphere as if it had a skin condition
00:18:24 <edwardk> it was the new logo application that folks split the >lambda= out of
00:18:27 <LAMMJohnson> The orange rather than the blue.
00:18:31 <applicative> oh my god there it is
00:18:52 <applicative> no here's the real progenitor http://3.bp.blogspot.com/-FbnjTNfXl6U/TeWMRLzFzsI/AAAAAAAAAyk/6wVLltX3t6c/s1600/Amtrak+Logo.jpg
00:18:54 <edwardk> http://www.haskell.org/haskellwiki/Image:Haskelllogosmax.png
00:19:14 <edwardk> yeah after it was picked there were a lot of amtrak jokes =)
00:20:20 <edwardk> http://www.haskell.org/haskellwiki/Image:Haskellvariations1.jpg was pretty much the last iteration before the 'haskell' was ripped off
00:20:23 <Nimatek> http://www.haskell.org/wikiupload/3/36/Haskell-logo-revolution.png
00:20:25 <Nimatek> This one is win.
00:21:02 <edwardk> Nimatek http://www.ozonehouse.com/mark/enemy/
00:21:22 <Nimatek> lol, edwardk
00:21:42 <sopvop> how could this one lose? http://www.haskell.org/wikiupload/8/85/NarleyYeeaaahh.jpg
00:21:51 <edwardk> sopvop: thats my wallpaper at work
00:22:07 <lance-> what does it mean that every function in haskell takes just one argument?
00:22:18 <edwardk> sopvop: it gets some very interesting looks from the rather staid financial education professionals who walk by every once in a while ;)
00:22:29 <Nereid> I really like this one. http://www.haskell.org/haskellwiki/Image:Lenny1.png
00:22:56 <edwardk> lance-: consider 'const: a -> b -> a'   in most other languages that would take two arguments at the same time, const :: (a,b) -> a
00:23:16 <lance-> add x y = x + y  sure looks like it takes two arguments?
00:23:17 <frontendloader> anyone managed to get /all/ of the haddock local docs to install on OSX when installing from brew?
00:23:28 <edwardk> lance-: in haskell it takes one argument, and then returns a new function from the 'second argument' to the result. so you can 'partially apply functions' just by not feeding them enough
00:23:30 <Nereid> add x y = (add x) y
00:23:35 <startling> the syntax would even be the same! const(a, b)
00:23:41 <applicative> Nereid it vaguely suggests a proof of the pythagorean theorem
00:23:44 <edwardk> add 1 is a perfectly reasonable call to make
00:23:46 <Nereid> incidentally, x + y = (+) x y = ((+) x) y
00:23:58 <edwardk> add takes 1 argument and then returns you a new functuion that takes one more
00:24:20 <lance-> hmm
00:24:21 <Eelis> and then there's (x +) y, which looks really fucked up ^_^
00:24:26 <edwardk> lance-: consider this if you have a 12 argument function in c, how do you pass it 1 argument and get a function that expects the rest?
00:24:37 <edwardk> lance-: in haskell you just apply it, to the first argument.
00:24:47 <XexonixXexillion> Eelis: It's less fucked up than (+ x) y
00:24:55 <edwardk> a -> b -> c   is saying a -> (b -> c)
00:24:58 <Nereid> XexonixXexillion: but that's y + x, which is different
00:25:03 <edwardk> its saying that given a, it'll give you a function from b -> c
00:25:34 <Nereid> > error "1" + error "2"
00:25:36 <lambdabot>   *Exception: 1
00:25:37 <Nereid> > error "2" + error "1"
00:25:37 <edwardk> lance-: this means you don't have to deal with 'different arities of functions', there aren't n different function arrows each for a different number of arguments, like there are in say, scala
00:25:39 <lambdabot>   *Exception: 2
00:25:47 <lance-> isnt that inefficient, to create a new function for every parameter?
00:25:55 <LAMMJohnson> http://www.redbubble.com/people/kovacs/works/6390818-haskell?country_code=GB&p=t-shirt
00:25:58 <LAMMJohnson> In black.
00:26:00 <edwardk> lance-: in practice it behaves more like you'd expect
00:26:01 <Nereid> lance-: that's what optimizations are for ;)
00:26:01 <LAMMJohnson> Are you a bad enough dude?
00:26:18 <edwardk> lance-: the actual implementation technology works more like a regular language in that regard
00:26:32 <Eelis> lance-: yes, which is why efficiency-focused functional languages like Clean compromise on this point
00:26:48 <startling> does laziness make it a little more efficient?
00:26:55 <edwardk> lance-: e.g. ghc will make 'partial application' nodes for non-fully applied functions, and over applications will get constructed differently, etc.
00:27:11 <edwardk> Eelis: clean compromises on this point because the suck at closures
00:27:15 <edwardk> er they
00:27:18 <startling> heh
00:27:41 <Eelis> if you say so ;)
00:28:14 <edwardk> > id id id id id id 3
00:28:15 <lambdabot>   3
00:28:23 <edwardk> how many arguments does id take?
00:28:38 <Nereid> > 3 4 5
00:28:39 <lambdabot>   Could not deduce (GHC.Num.Num (a0 -> a1 -> t))
00:28:39 <lambdabot>    arising from the ambiguit...
00:28:50 <edwardk> Nereid: numinstances is gone
00:28:51 <shachaf> edwardk: All of the.
00:28:53 <shachaf> m
00:28:54 <Nereid> I know.
00:28:56 <Nereid> I was there.
00:29:09 <shachaf> @quote Jafet unsafeCoerce
00:29:09 <lambdabot> Jafet says: unsafeCoerce takes any argument. AND IT WINS THAT ARGUMENT.
00:29:13 <Nereid> :D
00:29:21 <lance-> I knew that not providing enough arguments creates new functions, but never made a connection that all functions take one argument until now. thats pretty cool
00:29:32 <edwardk> :t curry
00:29:34 <lambdabot> ((a, b) -> c) -> a -> b -> c
00:29:44 <startling> :t uncurry
00:29:45 <lambdabot> (a -> b -> c) -> (a, b) -> c
00:29:51 <startling> ^ also useful, sometimes
00:29:52 <edwardk> currying takes a 'function of two arguments' -- really a function from a tuple, and gives you a function to a function
00:29:57 <edwardk> uncurrying goes the other way
00:30:01 <edwardk> :t curry . uncurry
00:30:02 <lambdabot> (a -> b -> c) -> a -> b -> c
00:30:07 <edwardk> :t uncurry . curry
00:30:08 <lambdabot> ((a, b) -> c) -> (a, b) -> c
00:30:30 <edwardk> :t uncurry (+)
00:30:31 <lambdabot> Num c => (c, c) -> c
00:30:36 <applicative> :t uncurry id
00:30:36 <edwardk> > uncurry (+) (2,3)
00:30:37 <lambdabot> (b -> c, b) -> c
00:30:38 <lambdabot>   5
00:30:41 <sw2wolf> ,hoogle fmap
00:30:47 <startling> :t \fn a b -> map (uncurry fn) (zip a b)
00:30:48 <lambdabot> (a -> b1 -> b) -> [a] -> [b1] -> [b]
00:30:58 <Nereid> :t zipWith
00:30:59 <startling> ^ (zipWith)
00:31:00 <lambdabot> (a -> b -> c) -> [a] -> [b] -> [c]
00:31:04 <Eelis> i always wondered whether juxtaposition should've been overloadable for non-function types to make it do neat things instead of giving boring errors
00:31:25 <edwardk> Eelis: you can overload juxtaposition with rank-2 types and some elbow grease
00:31:26 <Nereid> I've joked about that.
00:31:32 <Nereid> eh, how so?
00:31:34 <Eelis> hm
00:31:39 <edwardk> i do so in lens all the time
00:31:52 <Nereid> ??
00:31:53 <edwardk> :t enum
00:31:54 <lambdabot> (Enum a, Functor f, Isomorphic k) => k (a -> f a) (Int -> f Int)
00:32:06 <Jafet> @src Isomorphic
00:32:07 <lambdabot> Source not found. Maybe you made a typo?
00:32:09 <startling> Isomorphic is pretty hacky.
00:32:10 <edwardk> k there can be (->) or it can be another instance of Isomorphic
00:32:23 <sopvop> I try to add rank2types everywhere now, and see if it makes things better.
00:32:26 <edwardk> the old version was pretty straighforward
00:32:42 <startling> sopvop: that sounds like a bad idea.
00:33:13 <edwardk> say you wanted oh i don't know, something that worked like an array and could also be used directly as a function to access its elements.
00:33:14 <sopvop> startling: nothing what git reset  can't fix
00:33:31 <edwardk> we can exploit the fact that Array i e   and (i -> e)  have the same arguments in the same positions
00:33:43 <applicative> sopvop this is like a cargo cult type system
00:33:57 <edwardk> so we'll make a class Magic k where magic :: Ix i => Array i e -> k i e
00:34:07 <edwardk> now we can make our MagicArray
00:34:12 <sopvop> everyone cargo cults on lens anyway.
00:34:22 <applicative> yes
00:34:23 <edwardk> type MagicArray i e = forall k. Magic k => k i e
00:34:32 <edwardk> and we can make two instances of Magic
00:34:38 <Eelis> i don't like this hocus pocus
00:34:40 <edwardk> instance Magic Array where magic = id
00:34:49 <edwardk> instance Magic (->) where magic = (!)
00:35:12 <edwardk> now given a MagicArray i e -- you can use it like a function i -> e  or you can access its guts by using it as an array
00:35:17 * sopvop  actually uses the thing edwark describes now.
00:35:32 <Eelis> in C++ it's much more straightforward. you just overload operator() :P
00:35:33 <edwardk> its a trick i figured out ~4-5 years back and have used off and on since
00:35:37 <startling> sopvop, might as well stick in UndecidableInstances and DataKinds and GADTs on everything too
00:35:39 <edwardk> i abuse it a LOT more in lens than elsewhere
00:35:57 <edwardk> startling: sure. you mean, you don't?
00:36:08 <sopvop> startling: Done that yesterday, code become better.
00:36:12 <lance-> curry/uncurry confuse me
00:36:29 <edwardk> t curry
00:36:31 <edwardk> :t curry
00:36:33 <lambdabot> ((a, b) -> c) -> a -> b -> c
00:36:35 <XexonixXexillion> > uncurry (+) (3,5)
00:36:36 <edwardk> lets break that down
00:36:37 <lambdabot>   8
00:36:40 <elliott> guys you're forgetting edwardk's secret code incredient
00:36:42 <elliott> ingredient
00:36:46 <elliott> I won't tell you what it is because he already knows
00:36:51 <sopvop> unsafeCorece?
00:36:54 <startling> edwardk: heh
00:37:06 <edwardk> given a function from a tuple to a value of type c, it'll give you back something, so lets start there
00:37:08 <elliott> sopvop: not just any unsafeCoerce
00:37:11 <elliott> it only counts if you export it
00:37:11 <edwardk> :t curry fst
00:37:12 <lambdabot> c -> b -> c
00:37:19 <sopvop> lens were written by actient aliens?
00:37:37 <sopvop> ancient
00:37:38 <lance-> curry takes a function taking tuple to a function taking that many arguments, right?
00:37:46 <shachaf> Exporting unsafeCoerce is not hard.
00:37:58 <applicative> lance-: right
00:38:02 <edwardk> lance: it only works on a pair, not an arbitrary tuple-size, but, yes.
00:38:14 <edwardk> :t uncurry (+)
00:38:15 <lambdabot> Num c => (c, c) -> c
00:38:24 <edwardk> :t uncurry ($)
00:38:26 <lambdabot> (b -> c, b) -> c
00:38:27 <startling> :t uncurry . uncurry
00:38:27 <applicative> :t array
00:38:28 <lambdabot> (a -> b1 -> b -> c) -> ((a, b1), b) -> c
00:38:29 <lambdabot> Ix i => (i, i) -> [(i, e)] -> Array i e
00:38:30 <shachaf> edwardk: Time for a new class in lens, clearly.
00:38:37 <applicative> :t curry array
00:38:39 <lambdabot> Ix b => b -> b -> [(b, e)] -> Array b e
00:38:39 <startling> shachaf: haha
00:38:40 <sopvop> lens - Safe Haskell: Trustworthy
00:38:42 <edwardk> :t curried
00:38:43 <lambdabot> (Functor f1, Isomorphic k) => k ((a -> b -> c) -> f1 (d -> e -> f)) (((a, b) -> c) -> f1 ((d, e) -> f))
00:38:49 <edwardk> clearly thats what we should be using ;)
00:38:52 <shachaf> {-# Language TrustMe #-}
00:38:55 <edwardk> :t curried.uncurried
00:38:57 <lambdabot> (Functor f1, Functor (k (((a, b) -> c) -> f1 ((d, e) -> f))), Isomorphic k) => k (((a, b) -> c) -> f1 ((d, e) -> f)) (((a, b) -> c) -> f1 ((d, e) -> f))
00:39:02 <shachaf> Guh.
00:39:06 <shachaf> That type is a thing?
00:39:13 <edwardk> hahahaha
00:39:18 <shachaf> OK, it's not so bad in :i form
00:39:24 <shachaf> Iso ((a, b) -> c) ((d, e) -> f) (a -> b -> c) (d -> e -> f)
00:39:29 <edwardk> :t (+)^.uncurried.curried
00:39:30 <lance-> (+ 10)  <<  but isnt this currying instead of what curry function does?
00:39:31 <lambdabot> Num a => a -> a -> a
00:39:39 <shachaf> Maybe it should be abcxyz instead of abcdef, so as not to conflict.
00:39:48 <startling> can youturn an n-ary function that takes all a into an [a] -> Maybe b ?
00:39:53 <edwardk> lance-: that was an aside for the 'lenserati' on the channel, not serious help, sorry
00:40:07 <startling> the kinghts lensplar
00:40:11 <edwardk> lance-: thats 'partial application'
00:40:16 <applicative> lance-: that is partial application
00:40:22 <sopvop> Sir Lensalot
00:40:27 <shachaf> Partial application, also known as application.
00:40:34 <startling> lensicrucians
00:40:42 <edwardk> another name for that is 'sectioning'
00:40:46 <shachaf> startling: What does it do with id?
00:41:24 <edwardk> lance-: http://www.haskell.org/onlinereport/exps.html#sect3.5 for the pedantic
00:42:26 <startling> shachaf: \a -> head a, I guess, where head :: [a] -> Maybe a
00:44:42 <shachaf> startling: ?
00:45:11 <startling> shachaf: ??
00:45:31 <lance-> so add x y = x + y   is a curried function and  add (x, y) = x + y  is not? is that the right teminology?
00:45:57 <startling> :t curry
00:45:58 <lambdabot> ((a, b) -> c) -> a -> b -> c
00:46:11 <startling> sure, why not.
00:46:23 <startling> in practice you don't see the latter very often
00:46:27 <shachaf> startling: I'm not sure what you were after exactly.
00:46:39 <shachaf> startling: id takes 4 arguments, anyway.
00:46:49 <startling> shachaf: me neither, just an idle thought
00:50:01 <XexonixXexillion> Does GHC depend on GCC anymore?
00:50:51 <merijn> XexonixXexillion: Did it ever?
00:51:35 <Crd1> Is there a binary distribution for the Haskell Platform?
00:51:48 * hackagebot language-lua 0.1.3 - Lua parser and pretty-printer  http://hackage.haskell.org/package/language-lua-0.1.3 (OmerAgacan)
00:51:55 <startling> didn't it use C as an intermediary at some point?
00:52:00 <Crd1> I can't install it on my office computer
00:52:01 <startling> or was that always strictly optional?
00:52:25 <merijn> startling: It did, but that is just a dependency on *a* C compiler, not necessarily gcc, I'd say
00:52:33 <startling> merijn: oh.
00:52:40 <merijn> Crd1: Depends on your OS
00:52:41 <XexonixXexillion> merijn: I could never get that to work with any non-gcc c compiler
00:52:43 <applicative> Crd1: it depends on the OS
00:52:50 <Crd1> I'm using Windows
00:52:52 <merijn> startling: I might be wrong, but that'd seem silly anyway
00:53:06 <merijn> Crd1: There should just be a binary download for Windows on the platform site
00:53:10 <Nereid> there is a binary installer.
00:53:23 <merijn> XexonixXexillion: Anyway, GHC's default has been native code generation for a couple of years now, I think
00:53:23 <Crd1> I wanted the Win GHCi
00:53:27 <startling> merijn: I dunno, maybe it'd require gcc-compatible flags
00:53:29 <Nereid> yes, it comes with ghci
00:53:30 <Crd1> For GHC, they have
00:53:34 <Crd1> hmm
00:53:38 <Crd1> alright
00:53:49 <applicative> the windows installer presumably wont let you control  where it's installed
00:53:58 <Nereid> I thought it did?
00:54:20 <applicative> oh
00:54:22 <Nereid> yes it definitely asks me for an installation directory
00:55:04 <applicative> I was going by the fact that the OS X one doesnt
00:55:18 <Nereid> windows is quite different from os x ;)
00:55:52 <applicative> yes
00:56:48 * hackagebot Elm 0.6.0.2 - The Elm language module.  http://hackage.haskell.org/package/Elm-0.6.0.2 (EvanCzaplicki)
00:57:05 <applicative> the Win ghci wasn't that something that made ghci and maybe a little editor come in a little gui thing
00:59:09 <Nereid> it's just ghci with a gui, yeah
01:00:21 <Crd1> Eh Sorry, I only found this
01:00:26 <Crd1> Which is an exe file
01:00:44 <Crd1> I need tar.bz2 =)
01:00:50 <Crd1> of the Haskell Platform
01:00:58 <Crd1> Anyone can help?
01:01:28 <applicative> Crd1 http://www.haskell.org/ghc/download_ghc_7_6_1#binaries  you might be able to install the Platform from source?
01:01:48 * hackagebot poppler 0.12.2.1 - Binding to the Poppler.  http://hackage.haskell.org/package/poppler-0.12.2.1 (IanWooKim)
01:02:13 <Crd1> I think I tried that, but I wasn't able to find the Winghci
01:02:19 <Crd1> Is it really there?
01:02:42 <applicative> win ghci is an application that presupposes a ghc
01:03:09 <Crd1> hmm, so I have to download that separately?
01:03:14 <applicative> ghci will certainly come with the tar.gz thingy linked above
01:03:53 <applicative> but http://code.google.com/p/winghci/ is a completely separate project that seems not awake thesedays
01:06:22 <Crd1> tried this, but doesn't seem to work... http://code.google.com/p/winghci/wiki/WinGhciInstalltion
01:07:45 <lance-> why doesnt this print strings?  i get an error instead: map puStrLn $ words "hello there"
01:08:21 <lance-> map putStrLn $ words "hello there"
01:08:41 <c_wraith> :t map putStrLn
01:08:43 <lambdabot> [String] -> [IO ()]
01:08:50 <c_wraith> that's not an IO action
01:08:54 <c_wraith> It's a list of them
01:10:26 <c_wraith> :t mapM_
01:10:27 <lambdabot> Monad m => (a -> m b) -> [a] -> m ()
01:19:07 <lance-> @hoogle [IO ()] -> IO ()
01:19:08 <lambdabot> System.Mem.Weak addFinalizer :: key -> IO () -> IO ()
01:19:08 <lambdabot> Test.QuickCheck.Test safely :: State -> IO () -> IO ()
01:19:08 <lambdabot> Control.Concurrent.MVar addMVarFinalizer :: MVar a -> IO () -> IO ()
01:19:37 <Enigmagic> :t sequence_
01:19:38 <lambdabot> Monad m => [m a] -> m ()
01:20:32 <lance-> I am not quite getting why IO must be returned instread of IO to get output
01:20:50 <lance-> instead of [IO]
01:20:56 <Crd1> Haskell Platform is 1GB?
01:21:10 <Crd1> Why Soo big? Lol
01:21:23 <shachaf> lance-: What?
01:21:40 <sopvop> lance-: IO is data
01:22:51 <Enigmagic> Crd1: only 1gb? i spent about 20 cents and bought enough storage for all 16GB of my haskell installation :-)
01:23:27 <Crd1> Wow! 16 GB!!
01:23:52 <quchen> Cabal install *
01:24:04 <quchen> `
01:24:04 <quchen> ?
01:24:08 <Enigmagic> Crd1: the last C++ codebase I worked on was about 80GB compiled..
01:24:28 <Crd1> Wow
01:24:30 <shachaf> Enigmagic: Was that at Microsoft?
01:24:35 <Crd1> I'm a cs student
01:24:36 <Enigmagic> shachaf: yeah
01:24:38 <c_wraith> lance-: types have meanings. IO actions are things that do IO.  Lists are things that contain 0 or more elements.  The two are not interchangeable.
01:24:41 <Crd1> never heard that before
01:24:43 <Crd1> lol
01:24:56 <c_wraith> lance-: fortunately, the type system prevents you from using one as the other
01:25:11 <Crd1> Enigmagic: You work in Microsoft? Cool!
01:25:24 <Crd1> worked*
01:26:12 <Enigmagic> worked yeah
01:26:49 * hackagebot partly 1.0.0.1 - Inspect, create, and alter MBRs.  http://hackage.haskell.org/package/partly-1.0.0.1 (TimDixon)
01:38:56 <lance-> can someone explain why [IO ()] must be converted to IO for putStrLn calls to do its thing? I am not quite getting it
01:39:24 <shachaf> Do you know what foo :: IO () means?
01:40:16 <lance-> vaguely. it declares a function with side effects
01:40:32 <c_wraith> entirely wrong
01:40:45 <c_wraith> thinking about it that way will only lead to confusion
01:40:51 <shachaf> It has. :-)
01:41:17 <shachaf> @quote /bin/ls
01:41:17 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
01:41:29 <alang> @pl \(a, _) (_, b) -> (a, b)
01:41:29 <lambdabot> (. snd) . (,) . fst
01:42:31 <shachaf> @ty curry (fst *** snd)
01:42:33 <lambdabot> (c, b) -> (a, c') -> (c, c')
01:48:46 <c_wraith> lance-: IO is a real type. It's not just a marker.
01:49:17 <c_wraith> lance-: IO values represent computations that can have side effects, and have a result value
01:49:49 <c_wraith> lance-: the result value is of the type argument to IO
01:49:52 <startling> what does GHC use for linking and why does it take so long?
01:49:58 <startling> does it just subprocess out to ld?
01:50:41 <startling> lance-: an IO String is a description of a program that, when you run it, gives you a String.
01:50:51 <c_wraith> lance-: so a type like IO String means "a value represents a computation that can interact with the system in arbitrary ways, and will eventually generate a String"
01:50:55 <sopvop> IO is data
01:51:40 <startling> lance-, we have a convention that, if we name an IO program "main" in a module Main (the default), the compiler will compile that program.
01:51:49 * hackagebot partly 1.0.0.2 - Inspect, create, and alter MBRs.  http://hackage.haskell.org/package/partly-1.0.0.2 (TimDixon)
01:52:12 <YuleAthas> startling: yes, it uses ld.
01:52:30 <YuleAthas> startling: and as I recall, GHC triggers some worst-case behaviour in ld.  That was a few years ago, may have changed.
01:52:41 <startling> YuleAthas: hm. linking is consistently the vast majority of my compile time.
01:53:02 <startling> of course, this is OS X, so my ld is probably obsolete by serveral years
01:53:22 <YuleAthas> startling: well, GHC object files also export huge numbers of symbols.
01:53:39 <startling> YuleAthas: yeah, that's a good point
01:57:08 <merijn> startling: Actually, the OSX ld is surprisingly superior to the default linux one (since I think most distro's haven't switched to gold yet)
01:57:45 <shachaf> startling: Same as the convention in C!
01:57:59 <maus> hi! I'm trying to cabalize a program which is built in two phases. On the first phase the helper utility is built which generates some source files used later in compilation of the main binary. Is it possible with cabal or should I stick with makefiles?
01:59:28 <c_wraith> maus: cabal *can* do that, hooks are available in Setup.hs
01:59:38 <startling> merijn: I've got an "llvm" ld, is that gold?
02:00:14 <startling> oh, that might just mean it was built with llvm -- my ld -v is "(#)PROGRAM:ld  PROJECT:ld64-123.2\nllvm version 2.9svn, from Apple Clang 2.0 (build 139)"
02:01:35 <merijn> startling: No, gold isn't used by OSX. I was just saying that OSX ld is significantly better than the usual linux ld (except for the few distro's that are now using gold, as gold as actually decent)
02:01:40 <Jafet> maus: this is typical for C bindings such as gtk2hs
02:01:47 <maus> c_wraith, I know. What puzzles me is how to build my code generator? Should I move it into a separate package. Or maybe I need to create a separate cabal file? Or add the second Executables section?
02:01:53 <merijn> startling: The "old" linux ld is a god awful atrocity that makes me sad
02:02:30 <maus> Jafet, afaik gtk2hs uses a separate package gtk2hs-buildtools and sh script to drive the compilation of its subpackages
02:02:50 <c_wraith> maus: ah, I see. I'd ask dcoutts about that.
02:02:52 <startling> merijn: is this different from binutils ld, then?
02:02:53 <Jafet> Okay, gtk2hs isn't actually very typical
02:03:03 <startling> oh, I guess it has to work for mach-o. duh
02:03:44 <c_wraith> My experience with gold is that there were packages it just flat-out failed to link on linux...  and as such, I went back to ld
02:04:00 <merijn> startling: OSX ld also supports multi pass linking (so recursive dependencies don't force you to dance around listing every library N times in the right order to get the linking right and allows you to lazy link (i.e. linker won't complain about missing symbols as long as the symbols aren't used)
02:04:20 <startling> merijn: oh, neat.
02:05:07 <Crd1> Anyone recommends this tutorial?
02:05:08 <Crd1> http://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours
02:05:24 <Crd1> I'm a newbie to Haskell with prior programming experience
02:05:35 <merijn> Crd1: Only if you're already somewhat familiar with Lisp like things, I think?
02:05:51 <maus> Crd1, it;s quite nice one. Especially if you're interested in interpretation
02:05:52 <Crd1> Read the little schemer before
02:05:59 <Crd1> Am  I ready? =)
02:06:08 <merijn> Crd1: Ah, then it might be a nice one to follow
02:06:15 <Crd1> great
02:06:16 <Crd1> thanks
02:06:27 <merijn> Crd1: You probably want to combine it with a slower tutorial, though and use this as a sort of "practical application" guide
02:06:43 <Crd1> it's even stated there in the wikibook about TLS, lol
02:06:48 <merijn> Crd1: The usual recommendations are Learn You a Haskell and Real World Haskell (I prefer the former)
02:06:51 <Crd1> Sure
02:06:57 <merijn> @where lyah
02:06:57 <lambdabot> http://www.learnyouahaskell.com/
02:07:00 <merijn> @where rwh
02:07:00 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
02:07:06 <Crd1> Thanks
02:08:11 <maus> probably, I can reformulate my question. Is it possible to have separate hooks for different Executable sections in cabal file?
02:13:12 <startling> maus: what do you mean "separate hooks"?
02:13:17 <quchen> Crd1: LYAH (Learn You A Haskell) is certainly better for the basics than RWH (Real World Haskell). Once you're not afraid of functors and monads anymore, you can start reading RWH, where you'll find interesting details about what you already know in the first (introductory) chapters. The rest of RWH is beyond the scope of LYAH and makes a nice transition to the next learning phase, working with libraries.
02:13:20 <startling> maus: you can have multiple executables, iirc
02:13:52 <Crd1> Alright thanks
02:14:51 <hpaste> h pasted “haddock” at http://hpaste.org/79075
02:15:04 <maus> startling, I'll try to explain. I need to build two executables. After building the first one I need to run it in order to generate additional source files. Only after it I can build the second executable.
02:15:34 <startling> maus: oh hm
02:15:47 <startling> maus, you might want two cabal files
02:16:04 <frontendloader> that haddock paste is mine, I'm curious how to resolve those warnings so my haddock docs can be complete
02:19:58 <Yuu-chan> quchen: having RWH read, is it still useful to read LYAH?
02:20:53 <c_wraith> If you feel like you don't really have the basics of the language down, yes
02:22:45 <Yuu-chan> Does it cover some parts which RWH doesn't, for example?
02:23:22 <c_wraith> It covers a lot about basic structures of the language the RWH sort of assumes you already know
02:23:28 <startling> so mmap gives me a IO (ForeignPtr a, Int, Int) or whatever. Can I use this nicely with ST or something to get a 'mutable' bytestring?
02:24:22 <Yuu-chan> c_wraith: okay, thanks.
02:24:24 <c_wraith> startling: not really.  ByteString is very heavily into immutability
02:24:38 <c_wraith> startling: you could fit it into a Vector, though
02:24:47 <startling> c_wraith: how would that work?
02:24:49 <shachaf> Yuu-chan: If you've read and understood all of RWH then you probably don't have much to gain from reading LYAH.
02:26:07 <Yuu-chan> shachaf: I mean there could be an explanation of some useful idioms, like zippers
02:26:07 <quchen> Yuu-chan: 1. LYAH is cool to read even if you don't want to learn Haskell. 2. It's much more basic, I don't think once you've understood RWH you'll get much out of it, except 3. the last chapter explains zippers nicely, which is a technique RWH doesn't mention.
02:26:29 <startling> Yuu-chan: feel free to read just the zipper chapter
02:27:30 <quchen> POLLYWANTSACRACK <-- I love that example
02:31:18 <c_wraith> startling: look at the constructor for http://hackage.haskell.org/packages/archive/vector/0.10.0.1/doc/html/Data-Vector-Storable-Mutable.html
02:31:52 <startling> c_wraith: oh, nice
02:34:11 <c_wraith> startling: or the unsafeFromForeignPtrSource function, if you want to be safer about it :)
02:34:26 <c_wraith> err.  -Source.  bad copy/paste
02:35:10 <startling> c_wraith: yeah, very cool, thanks
02:35:38 <startling> can I stick it all in IO or whatever and use safe functions?
02:36:10 <c_wraith> oh, the unsafe there has to do with it not being able to guarantee freeze will work right, nothing more
02:36:21 <c_wraith> if you never use freeze on the vector, you're fine
02:36:23 <startling> oh okay
02:38:38 <frontendloader> how would you get haddock documentation installed for the base ghc libraries? Data.text for examples.
02:39:13 <shachaf> Data.Text isn't a base GHC library.
02:39:34 <shachaf> If you add Documentation: True to you ~/.cabal/config, you'll get documentation whenever you cabal-install something.
02:39:48 <shachaf> That doesn't apply to things that come with GHC, but those presumably already have documentation.
02:39:56 <frontendloader> I've got that set up, but there are links to things that come with GHC
02:40:07 <frontendloader> that aren't available to be made, because those docs aren't installed
02:40:35 <shachaf> Ah.
02:40:40 <shachaf> Maybe it depends on how you installed GHC.
02:40:54 <frontendloader> I got GHC from here http://www.haskell.org/ghc/download_ghc_7_6_1 , the osx bin dist
02:41:20 <DeadPanda> frontendloader, could you try installing the Haskell Platform instead?
02:43:07 <shachaf> You could try that but I'd certainly hope that it wouldn't be necessary.
02:43:11 <shachaf> And it doesn't come with 7.6
02:43:14 <shachaf> So I wouldn't recommend it.
02:44:02 <lzm> > let f str = Just (str++"a") in liftM f $ f $ "z" -- how can i join f and f together so that the result is Maybe String (and not Maybe (Maybe String))?
02:44:04 <lambdabot>   Just (Just "zaa")
02:44:43 <c_wraith> ...  amusingly, with join
02:44:48 <c_wraith> :t join
02:44:50 <lambdabot> Monad m => m (m a) -> m a
02:45:15 <lzm> oh
02:45:27 <c_wraith> or you can skip the middle man, and use the combined fmap and join
02:45:43 <mreh> How would _you_ deploy your happstack app? Would you compile it on the live server?
02:45:46 <shachaf> > let f str = Just (str++"a") in (f >=> f) $ "z"
02:45:48 <lambdabot>   Just "zaa"
02:45:51 <c_wraith> > let f str = Just (str++"a") in f =<< f z
02:45:51 <shachaf> > let f str = Just (str++"a") in f =<< f "z"
02:45:52 <lambdabot>   can't find file: L.hs
02:45:53 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
02:45:53 <lambdabot>              with actual ty...
02:45:55 <shachaf> > let f str = Just (str++"a") in f =<< f "z"
02:45:58 <lambdabot>   Just "zaa"
02:46:18 <shachaf> @hoogle Maybe (Maybe String) -> Maybe String
02:46:19 <lambdabot> System.Locale iso8601DateFormat :: Maybe String -> String
02:46:19 <lambdabot> Data.Foldable concat :: Foldable t => t [a] -> [a]
02:46:19 <lambdabot> Data.Foldable asum :: (Foldable t, Alternative f) => t (f a) -> f a
02:46:23 <shachaf> Hmph!
02:46:32 <shachaf> @hoogle Maybe (Maybe a) -> Maybe a
02:46:32 <lambdabot> Control.Monad join :: Monad m => m (m a) -> m a
02:46:33 <lambdabot> Data.Generics.Aliases orElse :: Maybe a -> Maybe a -> Maybe a
02:46:33 <lambdabot> Data.Foldable asum :: (Foldable t, Alternative f) => t (f a) -> f a
02:50:04 <startling> so I've got an mmapped file as an MVector IO Word8. Can I use "binary" or "cereal" with it? afaict I'd need to somehow turn a subvector into a bytestring
02:51:23 <startling> meh, maybe I should just seek around a file myself.
02:51:51 * hackagebot classy-prelude 0.4.2 - A typeclass-based Prelude.  http://hackage.haskell.org/package/classy-prelude-0.4.2 (MichaelSnoyman)
02:54:13 <frontendloader> looks like you need to build from source to get proper haddock docs?
02:54:26 <frontendloader> I can't see a way to generate them after the fact
02:55:25 <maus> startling, where to place them? cabal configure fails if detects two cabal files in a project root directory
02:55:39 <startling> maus: different subdirectories, I guess
02:55:49 <startling> frontendloader: you might just need the source
02:56:51 * hackagebot classy-prelude-conduit 0.4.2 - conduit instances for classy-prelude  http://hackage.haskell.org/package/classy-prelude-conduit-0.4.2 (MichaelSnoyman)
02:56:53 * hackagebot testing-feat 0.4 - Functional Enumeration of Abstract Types  http://hackage.haskell.org/package/testing-feat-0.4 (JonasDuregard)
02:59:44 <maus> startling, Ok, I moved it. But how to build the utility? Should I execute system "cabal build" in a prebuild hook of a main binary?
03:01:51 * hackagebot persistent 1.1.0.1 - Type-safe, multi-backend data serialization.  http://hackage.haskell.org/package/persistent-1.1.0.1 (MichaelSnoyman)
03:03:14 <startling> is there a Seekable class somewhere? Ideally I'd be able to seek around a Handle (and get IO x) or seejk around a bytestring (and get Identity x)
03:03:30 <startling> maus: can you require an executable with cabal?
03:04:00 <startling> also, I'd like to write to it -- I guess that'd make it a State ByteString
03:06:53 * hackagebot persistent-template 1.1.1 - Type-safe, non-relational, multi-backend persistence.  http://hackage.haskell.org/package/persistent-template-1.1.1 (MichaelSnoyman)
03:10:50 <lzm> how do i join two String -> IO (Maybe String) together? https://gist.github.com/3984142647e576615e53
03:11:19 <lzm> i'd like to remove the case in that gist
03:16:51 * hackagebot yesod 1.1.6 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-1.1.6 (MichaelSnoyman)
03:16:55 <startling> lzm: could be "maybe (return Nothing) getBlob <$> getCurrentRef"
03:29:19 <fmap> lzm: did you see MaybeT transformer?
03:29:35 <lzm> fmap: no
03:31:09 <fmap> lzm: well, it's in transformers and it allows to chain `m (Maybe a)' things with `>>='
03:32:02 <fmap> it may be overkill for just 2 functions though
03:34:34 <Crd1> Is there any specific site you would recommend to practise my Haskell
03:34:50 <Crd1> Just wanted to find the BEST resources
03:34:52 <Crd1> hehe
03:35:04 <Crd1> Haskell Problem sets
03:35:19 <Crd1> which gradually increase in difficulty
03:35:56 <merijn> Crd1: 99 Haskell problems?
03:36:13 <merijn> Crd1: http://www.haskell.org/haskellwiki/H-99:_Ninety-Nine_Haskell_Problems
03:36:13 <Crd1> Ah ok, came across that
03:37:28 <maus> startling, yeah, there is a build-tools option in cabal. But I can't make it work. Still, it only flags a dependency on a binary, and I need to execute it.
03:46:16 <mreh> has anyone done any work for serving files with happstack?
03:46:41 <mreh> not just mapping requests to some directory on disk
03:47:08 <mreh> but maybe wrapping up data into constructors that represent file types that have their own ToMessage instances
03:47:13 <mreh> doesn't sound so hard now I think of it
03:47:50 <mreh> I don't understand why you have to use the FS to store files directly, it's a really leaky abstraction
03:48:05 <mreh> I'm inclined just to stuff the data straight in the DB
03:51:08 <Peaker> aristid, yeah.. though half-kidding, we must work on PCs too. Not sure what to do about proper graphics on PCs
03:51:34 <Peaker> I guess only Linux users have graphics issues like unavailability of OpenGL
03:51:38 <aristid> Peaker: well generally you can count on opengl being there on PCs, no? it's just that the haskell bindings might not work
03:52:14 <Peaker> aristid, nope, that's what spawned the discussion. shachaf doesn't have working OpenGL at all on Linux
03:52:32 <aristid> Peaker: well actually it's more problematic for me on os x, because i use nix for my haskell stuff, and that supports no access to os x things
03:52:34 <Peaker> rwbarton seems to have (very slow) software rendering
03:52:36 <aristid> Peaker: what?
03:52:54 <Peaker> aristid, bad nVidia support for this hardware, buggy software he'd rather not run for the drivers
03:52:55 <aristid> are these computers older?
03:53:22 <Peaker> <shachaf> Peaker: Yes, it's an Nvidia Optimus thing. ... <shachaf> I'd rather have no OpenGL than run "bumblebee".
03:54:02 <aristid> intel graphics do support opengl.
03:54:20 <Peaker> aristid, yes, though for some reason it was super slow on his machine
03:54:40 <aristid> well if it's a pre-sandy bridge intel, it's ridiculously slow indeed
03:54:49 <aristid> but existent:)
04:00:16 <maus> can anyone suggest a way to run the code before each of executables specified in a cabal file is built?
04:01:52 * hackagebot hoauth2 0.2.5 - hoauth2  http://hackage.haskell.org/package/hoauth2-0.2.5 (HaishengWu)
04:10:46 <ocharles> in ghci is there anyway to do :t on a where clause inside a top level definition?
04:14:23 <quchen> ocharles: Not that I know of. But if you find a way let me know!
04:15:02 <quicksil1er> ocharles: it would be hard to implement
04:15:10 <quicksil1er> you'd need to provide context
04:15:11 <byorgey> ocharles: there is a way but it's kind of dirty.  Use the debugger to step evaluation to some point in the where clause.  Then you can do :t on anything in scope!
04:15:32 <ocharles> byorgey: oh, interesting :)
04:15:36 <ocharles> that might be good enough
04:15:41 <ocharles> would be good to sharpen my debugger skillz
04:16:52 * hackagebot language-lua 0.1.4 - Lua parser and pretty-printer  http://hackage.haskell.org/package/language-lua-0.1.4 (OmerAgacan)
04:17:28 <bartavelle> ocharles, what I do is that I define a type that is wrong (such as :: Int)
04:17:34 <bartavelle> the compiler tells me what it expected
04:17:38 <ocharles> yea, i tend to do that
04:17:44 <ocharles> was hoping there would be something a little less hacky
04:17:56 <bartavelle> also, ScopedTypeVariables or something like that, helps a lot
04:18:12 <bartavelle> not directly related to your question, but that made my day when I discovered this
04:21:12 <frontendloader> how long does a ghc build from source generally take? ballpark on a modern 4 core machine
04:22:51 <silver> bootstrap or not?
04:23:58 <silver> http://dpaste.org/XDvLH/
04:24:26 <silver> this is without bootstrap
04:24:51 <frontendloader> no bootstrap
04:24:59 <frontendloader> just ./configure && make
04:25:47 <silver> 1 hour and 15 minutes than
04:26:09 <silver> Q9400
04:26:14 <silver> on Q9400
04:26:17 <frontendloader> I'm building 7.6.1 though
04:26:35 <silver> oh I see
04:26:44 <silver> 40 minutes then
04:27:08 <frontendloader> we'll see how close I get to that
04:28:01 <frontendloader> just finished, need to find what my start time was
04:36:59 <mSSM> function composition: why does `take 64 $ cycle [1,2]' work, (take 64).cycle [1.2] does not? Isn't (f.g) x == f(g(x)) ?
04:37:24 <mSSM> oh, (take 64).cycle $ [1,2] does work; can somebody explain this to me?
04:37:26 <mSSM> why do I need $?
04:37:31 <b_jonas> > take 64 $ cycle [1,2]
04:37:32 <lambdabot>   [1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,...
04:37:40 <Nereid> (take 64) . cycle [1,2] = (take 64) . (cycle [1,2])
04:37:43 <b_jonas> > (take 64 . cycle) [1,2]
04:37:45 <lambdabot>   [1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,...
04:38:01 <Nereid> mSSM: ^
04:38:03 <benj_> function application binds tighter than composition ?
04:38:12 <mikeplus64> tighter than all opertaors
04:38:12 <Nereid> function application binds tighter than everything else
04:38:14 <mikeplus64> operators*
04:38:25 <benj_> hence, tighter than composition
04:38:26 <Nereid> except for record syntax
04:38:31 <Nereid> for some reason
04:38:37 <byorgey> good old record syntax!
04:39:10 <mSSM> so what the compiler really sees is `(take 64).cycle [1,2]' == `(take 64).(cycle [1,2])', which is meaningless?
04:39:21 <Nereid> it's not meaningless, it's just not well-typed
04:39:35 <b_jonas> so what exactly is the precedence order? infix operators > implicit function call > type specifier, at binding, record syntax
04:39:36 <Nereid> which I guess is as good as meaningless
04:39:39 <b_jonas> how does it work really?
04:39:52 <Nereid> huh?
04:39:59 <mSSM> thank you all
04:40:01 <mSSM> 1
04:40:03 <mSSM> !
04:40:07 <Nereid> @
04:45:21 <quchen> b_jonas: Do you know about fixities?
04:46:19 <b_jonas> quchen: yes. those define the precedence of infix operators among one another (if you count the -> arrow an infix operator too)
04:47:02 <b_jonas> quchen: but the language syntax rules tell how stuff like (a :: b c d) are interpreted
04:47:27 <b_jonas> because :: and @ don't behave like infix operators at all
04:48:13 <quchen> Well, @ is a pattern expression. In patterns, you pretty much always have to use explicit parentheses.
04:48:57 <hpc> (::) is an operator that takes a type on one side, if you feel like going into fancier typing than haskell can handle
04:49:00 <killy9999> I am thinking about learning more about GHC and possibly contributing to its development in the future
04:49:13 <killy9999> should I dive directly into source code + commentary on trac
04:49:23 <quchen> :: binds super loosely
04:49:31 <killy9999> or should I go with SPJs book or tutorial on implementing functional languages?
04:49:39 <b_jonas> quchen: on both sides?
04:50:07 <b_jonas> I think it does, yeah
04:50:28 <quchen> I don't understand that - "both sides"? I meant super loosely in the sense that a :: b === (a) :: (b)
04:50:44 <b__> I have a bunch of functions `a = f "a"`
04:50:57 <quchen> "Do everything else before you look at ::"
04:51:03 <b__> b = f "b", etc. how can I auto generate these?
04:51:10 <b_jonas> quchen: by both sides, I mean that if I write (a b + c d :: e f + g h) that will be parsed as ((a b + c d) :: (e f + g h))
04:51:43 <b__> I mean at runtime
04:52:14 <quchen> On the right side of :: you have to have a type, you can't write "+" on both sides
04:52:29 <b_jonas> quchen: + can be a type these days, at least in ghc
04:52:45 <hpc> plus ghc would still parse it that way
04:52:47 <b_jonas> but if you don't like that, assume I wrote :% instead of +
04:52:49 <hpc> only to choke on it later
04:52:51 <quchen> a b + c d :: e f :+ g h <= that one should work
04:53:40 <quchen> Wait, symbols as type constructors?
04:53:41 <quchen> As data constructors yes, but as types?
04:58:44 <quchen> I've never heard of infix type constructors, and can't find anything about them in the Haskell report
04:58:53 <quchen> (Plus they look weird to me)
04:59:23 <zomg> quchen: isn't cons an infix type constructor actually
04:59:41 <quchen> zomg: It's a *data* constructor.
04:59:58 <zomg> Ah, true that :P
05:00:13 <quchen> Data constructors can be infix of course.
05:00:42 <quchen> But the question above included an expression a la 'a b + c d :: e f :+ g h', and I don't think the right side is legal.
05:01:04 <quchen> ... the consequence being that you don't ever have to worry about fixities in type constructors.
05:01:29 <byorgey> quchen: GHC supports infix type constructors.
05:01:34 <byorgey> though they are not in the Report.
05:02:42 <quchen> Oh, I see
05:03:11 <FireFly> Couldn't you view (->) as an infix type constructor?
05:03:51 <quchen> byorgey: In that case, the GHC manual talks about fixities of these constructors: http://www.haskell.org/ghc/docs/latest/html/users_guide/data-type-extensions.html#infix-tycons
05:04:55 <byorgey> FireFly: yes indeed, but it's rather special
05:05:27 <hpc> :k (->)
05:05:28 <lambdabot> * -> * -> *
05:05:32 <byorgey> but you're right, there is ONE infix type constructor in the report
05:05:36 <quchen> @k (->)
05:05:37 <lambdabot> Maybe you meant: karma karma+ karma- karma-all keal kind . ? @ v
05:06:51 <quchen> FireFly: [], tuples and (->) are explicitly mentioned though.
05:07:32 <quchen> (Page 37)
05:08:03 <quchen> Unlike data constructors, infix type constructors are not allowed (other than (->))
05:08:13 <hpc> tuples have no fixity because the parens are mandatory
05:08:16 <quchen> So GHC violates laws set by the Haskell report! Booo
05:08:39 <byorgey> quchen: only if you turn on -XInfixTypeOperators
05:09:19 <liyang> Watch out if you try to use (->) prefix in GHC 7.6.1 though: http://hackage.haskell.org/trac/ghc/ticket/7312
05:22:58 <startling> is it alright to use UndecidableInstances for (Monad (t m), MonadTrans t, MyClass m) => MyClass (t m) ?
05:23:42 <hpc> possibly...
05:23:52 <startling> hpc, you can't decide?
05:24:11 <hpc> but can the typechecker decide?
05:25:39 <fmap> startling: if typechecking terminates then it's alright to use UndecidableInstances
05:25:50 <startling> fmap: oh, I see
05:25:59 <startling> I'd just heard that it was bad to use at all
05:26:07 <hpc> that's other things
05:26:26 <hpc> undecidable instances is almost the cleanest of the bunch
05:26:30 <hpc> just under flexible instances
05:26:52 <hpc> overlapping is the beginning of evil
05:26:58 <hpc> and incoherent is the very root of evil itself
05:27:13 <startling> ah
05:43:56 <jryan> Anyone have problems with cabal with proxy?
05:46:54 * hackagebot language-c-quote 0.4.4 - C/CUDA/OpenCL quasiquoting library.  http://hackage.haskell.org/package/language-c-quote-0.4.4 (GeoffreyMainland)
05:47:18 <mSSM> for testing, I have a vector with 64 Ints (+1,-1), from which one element is randomly read (10^7 times), multiptlied with 4 neighbours, and put back; profiling says that it spends a huge amout of time multiplying those 4 numbers - why? : http://hpaste.org/79076 any ideas why?
05:47:33 <mSSM> the vector is unmutable
05:48:22 <jeltsch> Hi, I’m experiencing a strange Cabal problem.
05:49:02 <jeltsch> I try to install darcs on GHC 7.6.1. For this to work, I have to stretch the dependencies specified by darcs and by haskeline-0.6.4.7 a bit.
05:49:41 <jeltsch> Now Cabal gives me the following message:
05:49:41 <jeltsch>     rejecting: haskeline-0.6.4.7/installed-7a0... (conflict: directory==1.2.0.0, haskeline => directory==1.2.0.0/installed-8ed...)
05:49:50 <mSSM> Could the profiling be misleading? I would have expected that copying the whole vector with one elem changed or making 10^7 random ints takes longer than what profilin says.
05:50:09 <mSSM> jeltsch: seems there is no dep on haskline?
05:50:26 <jeltsch> Why is there a conflict between directory-1.2.0.0 and the installed directory-1.2.0.0? Why isn’t Cabal just taking the installed version?
05:50:36 <mSSM> oh, sorry
05:50:46 <startling> is there some nice dslish way to deal with bitfields?
05:50:46 <jeltsch> mSSM: If there was no dependency on haskeline, the above conflict shouldn’t occur, I’d say.
05:51:22 <mSSM> jeltsch: is there a reason you are using ghc 7.6?
05:51:40 <jeltsch> Yes, I want to be bleeding egde wrt. language extensions.
05:52:13 <jeltsch> And now after I have installed all the Haskell packages again on top of GHC 7.6.1, I wouldn’t like to start over again with another GHC.
05:52:18 <romildo> How can I set a tooltip for a a treeview column header in gtk2hs?
05:53:04 <fmap> jeltsch: ghc-pkg list directory ?
05:54:12 <Saizan> jeltsch: it's probably constrained to rebuild it against different versions of the depenencies
05:54:54 <davorb_laptop> can someone tell me why this is giving me "Illegal datatype context (use -XDatatypeContexts)"
05:54:58 <hpaste> dado pasted “dictionary” at http://hpaste.org/79077
05:55:03 <davorb_laptop> http://hpaste.org/79077
05:55:07 <jeltsch> Saizan: Can you please elaborate a bit? I don’t fully understand this.
05:55:13 <davorb_laptop> at line 5
05:56:15 <Saizan> davorb_laptop: because you have (Eq a, Ord a) => there
05:56:39 <Saizan> davorb_laptop: you should just remove it, it doesn't help
05:57:21 <davorb_laptop> ah, thanks
05:58:10 <Saizan> jeltsch: if a library foo is compiled against bar-1 and exposes some of bar's types it might cause a build failure if you try to use it together with libs built with bar-2
05:59:20 <Saizan> jeltsch: so cabal tries to only use only one version of each lib in a single install plan
06:00:17 <jeltsch> Saizan: Yes, I know. But I don’t have several versions of any library installed.
06:00:44 <Saizan> jeltsch: darcs might be requiring a different version of some though
06:01:24 <jeltsch> It seems that Cabal complains that the already installed directory-1.2.0.0 is not compatible with a fresh install of directory-1.2.0.0. But why doesn’t it just take the installed copy?
06:03:43 <jeltsch> Saizan: darcs is rather tolerant about versions of directory. It should accept directory-1.2.0.0, but insists on installing directory-1.2.0.1. I have changed darcs.cabal locally such that directory-1.2.0.0 is enforced. Now Cabal tells me that  there is this conflict between directory-1.2.0.0 and itself.
06:04:18 <jeltsch> The problem seems to somehow be that Cabal doesn’t accept the installed directory-1.2.0.0 as a directory-1.2.0.0.
06:04:30 <jeltsch> Which seems weird to me.
06:04:34 <startling> kind sucks that there can't be a MonadState intance for (s -> (s, a))
06:04:38 <startling> *kind of
06:05:02 <neutrino_> hi
06:05:14 <neutrino_> i have a question: how can i find out the current number of threads?
06:05:18 <neutrino_> i want to do this for debugging
06:16:18 <zomg> Is there a difference in terminology in something +.. I mean it's an operator, but isn't it also a function? Or is this just lingo that can be both used for infix functions?
06:17:29 <osa1> I want to make a simple system tray menu for my app, which gui toolkit should I use ? (I'm on linux)
06:18:43 <osa1> zomg: it's a function, and in haskell functions can be used in both infix and prefix position.
06:21:26 <zomg> osa1: yeah I know but it seems the term 'operator' is often used for things like + despite them being functions
06:22:05 <jeltsch> zomg: + is an operator. The function it denotes is called (+).
06:22:14 <osa1> zomg: meybe they use the term 'operator' to say 'arithmetic operator' or something
06:22:28 <osa1> s/meybe/maybe
06:22:31 <jeltsch> No, operator is what can be written infix.
06:22:34 <jeltsch> + is an operator.
06:22:39 <jeltsch> `mod` is kind of an operator too.
06:22:53 <jeltsch> The function that + denotes is written (+).
06:22:56 <jeltsch> The modulo function is written mod.
06:23:12 <jeltsch> You cannot write 3 mod 5, you must write 3 `mod` 5.
06:23:30 <jeltsch> Likewise, you cannot write + 3 5, you have to write 3 + 5 (or (+) 3 5).
06:24:00 <jeltsch> The difference operator/non-operator is purely syntactical.
06:24:13 <Iceland_jack> What about Agda's mixfix functions?
06:24:24 <Iceland_jack> Is if_then_else_ an operator or a function?
06:24:52 <jeltsch> Iceland_jack: Maybe they call it an operator, because it contains these underscores, which denote argument positions.
06:24:54 <Iceland_jack> My point is that normally it depends on the language what an operator is
06:25:00 <zomg> jeltsch: oh I see, so if a function can be used infix without wrapping it in ` (eg. x `fmap` y), it would be an operator then?
06:25:04 <jeltsch> Iceland_jack: Absolutely.
06:25:26 <Iceland_jack> So just saying: infix == operator is misleading
06:25:27 <jeltsch> zomg: So to say.
06:25:35 <Iceland_jack> Do Lisps have no operators then?
06:25:58 <zomg> jeltsch: alright, thanks
06:26:46 <parcs`> Iceland_jack: lisp has at least one operator, .
06:26:48 <jeltsch> zomg: If the thing consists of symbols (like with +), then it is an operator and can be turned into a function identifier by putting it in paranthesis. If it consists of letters, digits, and underscores, it is an ordinary identifier and can be turned into an operator by putting it into backticks.
06:27:08 <jeltsch> parcs`: And this is probably the only one. :-D
06:27:50 <zomg> jeltsch: Okay, yeah I knew how it works but was just curious about the correct terminology :)
06:28:28 <jeltsch> zomg: I’m not *exactly* sure about the precise terminology. You should look into the Haskell Report to find out.
06:35:52 <DarkUnicorn> when using mapM_ in IO does that mean that the io is not really executed because the result is not needed?
06:37:03 <`ramses> DarkUnicorn: no, it is executed
06:37:12 <`ramses> DarkUnicorn: would be quite pointless otherwise
06:37:25 <DarkUnicorn> good
06:37:34 <jesyspa> If you use the return value of mapM_, then the results are kind-of needed.
06:37:42 <jesyspa> (Well, the side-effects of the results are needed.)
06:37:54 <bxc> like when you do putStrLn in a do block, and the result isn't used ... the putStrLn still happens
06:38:00 <DarkUnicorn> so there is no difference between mapM_ and mapM in this case?
06:38:09 <`ramses> :t mapM_
06:38:11 <lambdabot> Monad m => (a -> m b) -> [a] -> m ()
06:38:12 <`ramses> :t mapM
06:38:14 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
06:38:30 <`ramses> the difference is whether you use the results
06:38:59 <neutrino_> hmmmm
06:39:15 <neutrino_> is there really no way at all to get the number of threads currently running?
06:39:27 <DarkUnicorn> right, but in a do-block the two may be used without using the result
06:39:35 <`ramses> e.g. mapM putStrLn ["a","b"] gives you a IO [(),()] which is probably useless
06:39:59 <`ramses> using mapM_ then gives an IO ()
06:40:19 <`ramses> yes, in the do block you wont notice the difference
06:40:33 <DarkUnicorn> okay, thanks for the clarification!
06:40:53 <`ramses> maybe the garbage collector has a bit more work with mapM, but I'm not sure about that
06:41:09 <dzoni> i have one arry [[1,2,3,4,5],[3,3,4,5],[1+3]]=[1+3+1,2+3+3] how to do that
06:41:13 <neutrino_> mapM_ is basically void . mapM
06:41:24 <`ramses> @src mapM_
06:41:24 <lambdabot> mapM_ f as = sequence_ (map f as)
06:41:34 <neutrino_> @src sequence_
06:41:34 <lambdabot> sequence_ ms = foldr (>>) (return ()) ms
06:41:37 <`ramses> @src sequence_
06:41:37 <lambdabot> sequence_ ms = foldr (>>) (return ()) ms
06:41:45 <neutrino_> @src mapM
06:41:46 <lambdabot> mapM f as = sequence (map f as)
06:41:48 <dzoni> help i have one arry [[1,2,3,4,5],[3,3,4,5],[1+3]]=[1+3+1,2+3+3] how to do that
06:41:56 <neutrino_> @src sequence
06:41:56 <lambdabot> sequence []     = return []
06:41:56 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
06:41:56 <lambdabot> -- OR: sequence = foldr (liftM2 (:)) (return [])
06:42:05 <neutrino_> see
06:42:11 <neutrino_> @src void
06:42:11 <lambdabot> Source not found. It can only be attributed to human error.
06:42:41 <dzoni> proizvod []     = 1 proizvod (n:ns) = n * proizvod ns
06:42:43 <`ramses> so, in a do block using mapM without binding the result is completely identical to using mapM_
06:42:44 <dzoni> help i have one arry [[1,2,3,4,5],[3,3,4,5],[1+3]]=[1+3+1,2+3+3] how to do that
06:42:51 <neutrino_> void basically does that return () part that we've found 2 levels deep.
06:42:56 <parcs`> dzoni: stop
06:43:00 <fmap> :t fmap (const ())
06:43:02 <lambdabot> Functor f => f a -> f ()
06:43:23 <neutrino_> `ramses: not if it's the last action in the do block
06:43:23 <typoclass> dzoni: we heard you the first time
06:43:26 <`ramses> dzoni: look at zip functions
06:43:49 <dzoni> i'm on exame sorry and i don't now how to do that i'm c developer i don't understand haskell
06:44:05 <`ramses> neutrino_: true, but I guess it was clear from the previous questions that we were talking it the case where it was followed by other expressions
06:44:09 <parcs`> have fun failing the exam
06:44:17 <epta> ^^
06:44:28 <`ramses> parcs`++
06:44:35 <dzoni> no help then :D
06:44:35 <neutrino_> `ramses: i was just clarifying context
06:44:51 <`ramses> a bit late to come with questions like that when already on the exam :)
06:44:59 <`ramses> neutrino_: sure :)
06:45:17 <neutrino_> dzoni: aren't you the guy who wanted to use haskell in the military
06:45:24 <dzoni> nope
06:45:25 <neutrino_> or something
06:45:32 <neutrino_> heh what exam is it?
06:45:38 <typoclass> parcs`: i think that's uncalled for
06:45:38 <dzoni> haskell
06:45:42 <dzoni> nope
06:45:54 <neutrino_> is the course name "haskell"?
06:45:55 <dzoni> i'not that dzoni
06:45:56 <epta> dzoni: you have just «haskell» discipline?
06:46:05 <neutrino_> what university is it ?
06:46:05 <neutrino_> i'm interested
06:46:24 <dzoni> third country world does't matter if you can help me :D
06:46:27 <`ramses> haha, let's chat a bit while doing an exam ^^
06:46:32 <jeltsch> Where is the --constraint switch of cabal-install documented?
06:46:49 <neutrino_> dzoni: does matter
06:47:14 <neutrino_> dzoni: i have the answer right here.. you just gotta tell us what you're really doing
06:47:22 <fmap> jeltsch: cabal install --help
06:47:49 <dzoni> exame
06:48:07 <astropirate> haskell has ruined me for other languages
06:48:39 <epta> dzoni: is there a way to make a photo of all exam tasks?
06:48:53 <epta> s/make/take/
06:49:15 <fmap> hmm, not very interesting documentation though
06:49:26 <dzoni> thanks anyway exame is over for five minute i go
06:50:15 <dzoni> epta:no
06:50:17 <jeltsch> fmap: This is hardly a documentation. It just says: “Specify constraints on a package (version, installed/source, flags).
06:50:48 <jeltsch> fmap: So how do I specify, for example, that I prefer installed versions over version from HackageDB?
06:50:49 <dzoni> epta:i can write you example of task is simple i see but i dont now haskell at all
06:51:54 <epta> dzoni: go ahead
06:52:39 <fmap> jeltsch: --constraint="$package installed"
06:53:23 <fmap> (you may want to --dry-run first)
06:53:32 <dzoni> epta:arry[[1,2,3,4],[1,2,3],[1,2]]=[1+1+1,2+2] do you see point :D
06:53:56 <dzoni> epta:arry[[1,2,3,4],[1,2,3],[1,2]]=[1+1+1,2+2+2] do you see point :D
06:55:24 <jeltsch> fmap: Thank you. Is this documented somewhere?
06:57:21 <hpaste> neutrino pasted “for dzoni” at http://hpaste.org/79078
06:57:33 <neutrino_> ah, balls
06:57:34 <neutrino_> haha
06:57:44 <neutrino_> i guess he failed then
06:59:04 <`ramses> what if the list would not always contain three elements? I got foldr1 (zipWith (+)), but I couldn't come up with a oneliner that can also handle empty lists
06:59:33 <fmap> jeltsch: I'm not sure. Even if it is, it's not easy to find.
06:59:39 <`ramses> haven't given it too much tought either tjough
06:59:51 <neutrino_> his examples always had 3 elements
06:59:56 <neutrino_> so who cares
06:59:57 <neutrino_> :)
07:00:03 <`ramses> I know, just asking what if :)
07:00:30 <neutrino_> guys guys
07:00:42 <neutrino_> i really need to find out.. how to get the number of currently running threads?
07:00:47 <neutrino_> it's killing me :)
07:04:11 <quchen> neutrino_: you mean currently working OS threads?
07:07:35 <fmap> > let m = map sum . takeWhile (not . null) . getZipList . Data.Traversable.sequenceA . map ZipList in (m [[1,2,3,4],[2,3,4],[3,4]], m [])
07:07:37 <lambdabot>   ([6,9],[])
07:11:13 <`nand`> > map sum . getZipList . traverse ZipList $ [[1,2,3],[4,5,6],[7,8,9]]
07:11:15 <lambdabot>   [12,15,18]
07:11:46 <`nand`> > let [x,y,z] = [[1,2,3],[4,5,6],[7,8,9]] in zipWith3 (\a b c -> a+b+c) x y z
07:11:51 <lambdabot>   [12,15,18]
07:11:56 * hackagebot hoauth2 0.2.5.1 - hoauth2  http://hackage.haskell.org/package/hoauth2-0.2.5.1 (HaishengWu)
07:12:24 <fmap> > map sum . getZipList . traverse ZipList $ []
07:12:26 <lambdabot>   [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
07:13:46 <`nand`> note that Data.Traversable.sequenceA . map ZipList = traverse ZipList
07:19:36 <npl> hello, how can I evoke simple sound signals which come with the OS (linux or windows?) Like the "beep" which occurs when I press too much keys at the same time. I searched for this, but I only found more complex library for playing .mp3 files or generating music
07:20:54 <neutrino_> quchen: no just RTS threads
07:21:11 <Botje> npl: on some terminals you can emit an ASCII alarm character.
07:21:23 <typoclass> npl: hi, have you tried printing a "bell" character to the terminal? it's number 7 http://www.asciitable.com/
07:21:38 <neutrino_> or just \b
07:22:11 <typoclass> npl: you could use putStr "\007", i think
07:22:20 <typoclass> neutrino_: i think it's (confusingly) \a. \b is some other thing i can't recall at the moment
07:22:59 <Botje> backspace
07:23:01 <geekosaur> \a (for "alert").  \b is backspace, and is much older and haskell doesn't really get to change it
07:23:01 <neutrino_> oh right
07:23:01 <neutrino_> \b is backspace
07:23:01 <neutrino_> http://book.realworldhaskell.org/read/characters-strings-and-escaping-rules.html
07:23:01 <neutrino_> see here
07:24:09 <neutrino_> you can do \BEL though
07:24:15 <geekosaur> (\n \t \r \b f were defined by C and work ~everywhere.  \a and a handful of others came later and are best known from perl but actually predate it)
07:24:45 <typoclass> geekosaur: well, haskell *could* change it, but that'd only add to the confusion =)
07:24:46 <typoclass> npl: neutrino_ is right, \BEL is probably the clearest
07:24:55 <marioL> hi. i'm doing an exercise. i've to check if a list is a prefix of another list. i've done it with this: http://hpaste.org/79079 what do you think?
07:25:18 <npl> I don't hear anything when I try putStrLn "\BEL" in ghci
07:25:30 <Entroacceptor> marioL: you don't need Ord for that, Eq should suffice
07:25:47 <marioL> the first list is the list that i've supposed must be the prefix
07:25:52 <Entroacceptor> @src isPrefixOf
07:25:53 <lambdabot> isPrefixOf [] _          = True
07:25:53 <lambdabot> isPrefixOf _  []         = False
07:25:53 <lambdabot> isPrefixOf (x:xs) (y:ys) = x == y && isPrefixOf xs ys
07:26:08 <npl> neutrino_:  thanks, I will look at the link
07:26:15 <Entroacceptor> looks similar ;)
07:26:22 <neutrino_> marioL: what about isPrefixOf "abc" "abc"
07:26:34 <geekosaur> npl, I get beep + screen flash here
07:26:53 <neutrino_> marioL: notice that you have swapped the first two cases..
07:26:56 <geekosaur> check terminal settings, it may be set to visible bell or something
07:27:00 <npl> I just get a new line
07:27:02 <neutrino_> so for identical sequences you'll get false.
07:27:02 <marioL> i got to check that ;)
07:27:05 <npl> ok
07:27:07 <typoclass> npl: your terminal may show it differently (my terminal flashes)
07:27:59 <neutrino_> npl: pipe your program through cat -v and look for ^G
07:28:20 <neutrino_> $ echo $'\a fooo \n' | cat -v
07:28:20 <neutrino_> ^G fooo
07:28:20 <neutrino_>  
07:30:08 <typoclass> npl: you could maybe run a program that plays a short audio file. it might be as simple as doing «import System.Process ; system "mplayer alert.mp3"». or if you're on linux, you could do «system "notify-send abc"» to get a little notification window
07:30:12 <LucaS05> so how can i do?
07:30:17 <neutrino_> ~/tmp$ echo $'module Main where\n\nmain = putStrLn "\\BEL"\n' > bel.hs && ghc bel.hs > /dev/null && ./bel | cat -v
07:30:20 <neutrino_> ^G
07:30:38 <neutrino_> actually that can be shorter
07:32:00 <typoclass> neutrino_: but that will still only show the bell visually, right?
07:32:04 <neutrino_> but i don't know how to specify binary name
07:32:10 <neutrino_> typoclass: no, it will show ^G.
07:32:21 <npl> typoclass: oh, this window is nice
07:32:24 <neutrino_> for an ascii bell.
07:32:53 <LucaS05> ok what about now? http://hpaste.org/79079
07:33:26 <npl> neutrino_: if i type "echo $'module Main where\n\nmain = putStrLn "\\BEL"\n' > bel.hs && ghc bel.hs > /dev/null && ./bel | cat -v" at the terminal I get "^G"
07:33:28 <neutrino_> LucaS05: what about isPrefixOf "abcd" "abc"
07:33:28 <typoclass> npl: glad you like it ;-) there's some more options to notify-send. you may want to switch to rawSystem if it gets longer
07:33:49 <neutrino_> npl: that's exactly what should happen. it tells you cat has seen an ascii bell character.
07:33:59 <LucaS05> i've supposed that the first list is the list that is used for checking that is the prefix
07:34:06 <neutrino_> yeah
07:34:21 <neutrino_> so it should evaluate to false, right?
07:34:21 <neutrino_> well it won't
07:34:49 <LucaS05> if i do isPrefixOf "abc" "abcefghi"
07:34:53 <LucaS05> is true
07:35:00 <neutrino_> now swap them
07:35:02 <neutrino_> you should get false
07:35:05 <neutrino_> what do you get?
07:35:08 <LucaS05> yes false
07:35:27 <LucaS05> but i've put that "condition"
07:35:43 <neutrino_> i think you're not telling the truth :)
07:35:54 <LucaS05> maybe is too easy :D
07:35:56 <jeltsch> Hi, while trying to compile darcs with GHC 7.6.1, I get the following error message: “Unacceptable argument type in foreign declaration: CInt”. Why is this?
07:35:58 <neutrino_> because the code you posted should error out if the second string is a prefix of the first
07:36:06 <neutrino_> and the first is longer
07:37:02 <neutrino_> jeltsch: no idea, but consider checking the darcs bug tracker
07:37:28 <jeltsch> neutrino_: To me this looks more like a GHC bug.
07:37:28 <jeltsch> Or I don’t understand the FFI well enough.
07:37:30 <LucaS05> this is the last code: http://hpaste.org/79081 (i don't get any error in GHCi)
07:37:55 <rwbarton> it is a change in GHC to match the FFI spec
07:38:02 <jeltsch> neutrino_: To me, this message suggests that CInt is not acceptable in FFI declarations at all. But the spec says, it is intended for the FFI, right?
07:38:05 <rwbarton> which requires that the constructor of CInt be in scope
07:38:14 <jeltsch> rwbarton: Aah?
07:38:16 <rwbarton> (or so I hear)
07:38:20 <jeltsch> Aah? → Aah!
07:38:28 <rwbarton> so if you import ... (CInt(..)) it should work
07:38:32 <jeltsch> Okay, I’ll try to get it into scope.
07:38:36 <jeltsch> rwbarton: Thanks.
07:39:32 <neutrino_> jeltsch: so you're right, it was a GHC bug.
07:39:37 <neutrino_> that got fixed, that is.
07:39:41 <rwbarton> probably fixed in a darcs version of darcs but :)
07:40:09 <neutrino_> rwbarton: any idea how to get info about the number of threads my program is currently running?
07:40:15 <neutrino_> rts threads, not os threads
07:40:18 <rwbarton> you can count them yourself
07:40:19 <rwbarton> otherwise, no
07:40:51 <jeltsch> neutrino_, rwbarton: So CInt was already imported.
07:41:07 <jeltsch> neutrino_: So GHC 7.6.1 has a bug wrt. FFI and CInt?
07:41:09 <rwbarton> the type but not the data constructor
07:41:11 <rwbarton> no
07:41:42 <rwbarton> the bug was that GHC 7.4 and earlier was too permissive
07:41:58 <jeltsch> rwbarton: Ah, now I understand. Just importing the type CInt is not enough.
07:42:02 <jeltsch> Let’s try again.
07:42:38 <LucaS05> there's a way to define a type like: data myList = myList [a]? (I want to defin myList like a parametrized list)
07:42:55 <LucaS05> cause like that i got an error (a is out of scope obv)
07:43:43 <rwbarton> data MyList a = MyList [a]
07:45:02 <Nereid> also, consider using a newtype there
07:46:31 <neutrino_> rwbarton: oh, i've found a good way
07:46:49 <neutrino_> you can do ghc -debug and then do ./prog +RTS -Ds and it'll print info about threads
07:46:59 <neutrino_> and it shows how many threads are active etc
07:47:30 <neutrino_> what happens to stopped threads - do they get GC'd?
07:47:50 <neutrino_> oh, apparently they don't
07:47:55 <neutrino_> they stick around
07:48:01 <neutrino_> so this program is leaking threads.. how can i prevent this from happening?
07:49:03 <hpaste> neutrino pasted “how to stop this program from leaking threads?” at http://hpaste.org/79082
07:49:10 <jeltsch> rwbarton: Okay, this seems to work now.
07:51:39 <LucaS05> what's the error here? http://hpaste.org/79083 is not right to pass a type like that?
07:52:04 <rwbarton> don't ask us, ask ghc
07:53:59 <rwbarton> if you want us to explain an error message, then paste the error message
07:56:06 <LucaS05> here you are http://hpaste.org/79085
07:56:51 <`ramses> ListPrefix takes a type
07:57:05 <`ramses> you didn't include one in the signature of your function
07:57:06 <rwbarton> That's not even the same code you pasted before. :-(
07:57:34 <`ramses> the same goes for ActList
07:59:48 <rwbarton> Both your original code and your newer code have another problem, as well
08:00:07 <djcoin> LucaS05: I don't think your pattern matching is exhaustive, what happens if the first list has more than the second ?
08:00:33 <djcoin> It will fail because you are popping one element to both list each time, no ? (im an haskell beginner)
08:00:43 <LucaS05> i've supposed that the first list is used for check if is prefix of the second
08:00:47 <LucaS05> the second is the actual list
08:01:09 <LucaS05> (i'm a beginner too)
08:01:23 <djcoin> Ok, if you are aware of that. I suppose ghc may already have told you so
08:01:23 <`ramses> djcoin: the other patterns will handle that
08:01:56 <djcoin> `ramses: how is that ? if I have isPrefixOf ['a'] [] for example ?
08:02:00 <S11001001> :k ZipList
08:02:02 <lambdabot> * -> *
08:02:52 <`ramses> djcoin: ah sorry, you are correct
08:02:55 <bgamari> tibbe, What is standing in the way of cabal-install learning a --rebuild-broken option which will rebuild the packages that will be broken by an installation?
08:03:31 <LucaS05> i've written the data declaration for that ;)
08:03:35 <tibbe> bgamari: someone implementing it, gentoo has a revdep-build command for that purpose that we could model ourself after.
08:04:34 <bgamari> tibbe, It seems like we can already identify which packages will be broken; perhaps I'm missing something but it doesn't seem to me like this needs to be more complicated that just a --rebuild-broken flag
08:04:38 <LucaS05> the problem is that i've a syntax error
08:04:41 <Crd1> I was reading the real world haskell
08:04:56 <Crd1> It says - is a unary operator
08:05:03 <Crd1> I tried this
08:05:06 <`ramses> LucaS05: your patterns aren't correct, you are mathcing wrong types
08:05:15 <Crd1> > (-) 5 3
08:05:17 <lambdabot>   2
08:05:33 <Crd1> Doesn't this show that - is a binary operator?
08:05:40 <bgamari> tibbe, The flag I'm envisioning will simply take the list of packages that cabal says a build will break and add them to the build list
08:05:53 <typoclass> Crd1: it's both :-/ it's a little bit of a special case
08:05:55 <bgamari> tibbe, It won't scour the system for existing broken packages
08:06:14 <LucaS05> because of the [] ?
08:06:16 <dcoutts> bgamari: that's somewhat like the future ui I'm thinking of
08:06:19 <`ramses> yes
08:06:21 <typoclass> > (- 3)
08:06:22 <Crd1> Hmm alright
08:06:23 <lambdabot>   -3
08:06:26 <typoclass> > (7 - 3)
08:06:28 <lambdabot>   4
08:06:50 <tibbe> bgamari: A good start would be a ticket on the bug tracker describing exactly how such a thing would work from the user's perspective so we can discuss that before implementing
08:07:00 <bgamari> tibbe, sure
08:07:18 <dcoutts> bgamari: the problem at the moment is that there's no guarantee that you can rebuild them, and it's all mutative and not transactional
08:07:34 <beaky> hello
08:08:01 <bgamari> dcoutts, Sure, it isn't perfect but at least it removes a common manually task from the workflow
08:08:08 <beaky> what are some powerful uses of typeclasses?
08:08:22 <dcoutts> bgamari: also, you have to deal with the possibility that adding the extra packages to the build targets makes it impossible
08:08:31 <`ramses> beaky: Functor, Applicative, Monad, Eq, Show, ...
08:09:12 <ion> Ord, Bounded, Traversable
08:09:19 <beaky> so typeclasses are something from Category Theory?
08:09:20 <dcoutts> tibbe: I've been thinking of a simpler ui, for once we have the nix stuff in there underneath
08:09:23 <bgamari> dcoutts, in which case cabal can still throw its hands up in the air and let the user sort it out
08:09:24 <ion> ToJSON, FromJSON
08:09:36 <bgamari> dcoutts, I'm just considering an incremental step
08:09:39 <ion> beaky: no
08:09:50 <quchen> beaky: Typeclasses are very much Haskell only
08:10:02 <beaky> aww
08:10:24 <beaky> typeclasses seem like java interfaces with multiple dispatch
08:10:27 <tibbe> dcoutts: bgamari: once we have completely hermetic builds, will we need this?
08:10:30 <quchen> In Haskell you can unify "things you can do a certain operation on".
08:10:48 <bgamari> tibbe, Probably not but what is the timescale for hermetic builds?
08:10:51 <dcoutts> tibbe: yes, because you still have your "normal" package env to think about
08:11:02 <bgamari> tibbe, I was under the impression that this is a far-off goal
08:11:04 <quchen> For example, you can have something that you can compare. If you can "<" two things, you can also ">" them.
08:11:06 <dcoutts> tibbe: the one you get when you just run ghc --make / ghci
08:11:16 <neutrino_> dcoutts: any ideas why my program would be leaking threads?
08:11:19 <tibbe> bgamari: sandboxes should be out by the end of the year, but the nix stuff is probably on ice as no one is working on it that I know of
08:11:37 <tibbe> dcoutts: right
08:11:40 <bgamari> tibbe, Right, sandboxes are a good step
08:11:46 <dcoutts> neutrino_: what program?
08:11:51 <quchen> Compare that to C++: if you have a function that takes two objects that have operator< defined, but that function tries to use ">" on the objects, the compiler complains.
08:12:07 <neutrino_> http://hpaste.org/79082
08:12:14 <neutrino_> dcoutts: ^
08:12:17 <bgamari> tibbe, but as long as the nix work (which sounds quite non-trivial) isn't being actively developed, I don't think it hurts to think of ways to smooth out the current workflow
08:14:09 <dcoutts> neutrino_: you make a thread each time you call main (or main calls itself)
08:14:25 <neutrino_> yeah, but why does that thread keep on living?
08:14:54 <dcoutts> neutrino_: what makes you think it should be killed?
08:15:19 <tibbe> bgamari: I agree
08:15:23 <neutrino_> i thought that would somehow make sense, i don't understand the behaviour
08:15:29 <neutrino_> how can i delete a thread, dcoutts?
08:15:36 <neutrino_> i tried searching for that but came up empty handed
08:15:48 <dcoutts> neutrino_: it can terminate itself just be finishing running
08:15:58 <neutrino_> do i raise an exception in that thread or something?
08:15:59 <neutrino_> right
08:16:05 <dcoutts> neutrino_: or you can kill a thread from another thread by sending it an async exception
08:16:08 <neutrino_> but if you look at what that thread does it's very simple
08:16:19 <neutrino_> that's what i thought
08:16:32 <dcoutts> neutrino_: take a look at the async package, it will cover this use case
08:16:43 <neutrino_> because also the ghc runtime debugger said that when i terminated the program normally it sent exceptions to all those threads
08:16:51 <dcoutts> ie an acyn action but where you don't want it to run forever
08:16:52 <neutrino_> i don't know exactly how to use async
08:16:53 <LucaS05> i've corrected http://hpaste.org/79086 ;)
08:16:55 <neutrino_> ill have a look
08:17:06 <neutrino_> i want it to run for very, very long
08:17:17 <neutrino_> pretty much forever, until a specific thing happens
08:17:22 <neutrino_> at which point it should be killed
08:19:13 <tibbe> dcoutts: I was a bit confused about the cabal sandbox UI discussion. I thought you and I already discussed it and settled it. You had me write that wiki section as a result of that discussion.
08:19:47 <dcoutts> tibbe: aye, but I'm thinking longer term
08:19:57 <dcoutts> tibbe: when we don't have sandboxing and non-sandboxing
08:20:01 <dcoutts> just one ui
08:21:44 <tibbe> dcoutts: right, what would happen then is that the cabal sandbox init command would go
08:21:52 <tibbe> dcoutts: you'd still use cabal build as per normal
08:22:07 <tibbe> dcoutts: in fact that's one reason that I don't want separate sandbox build commands or flags
08:22:21 <`ramses> LucaS05: wrong paste? I don't see the difference
08:22:26 <tibbe> dcoutts: so we can swap in a nix implementation without the user really noticing
08:22:42 <`ramses> ah, type synonyms! :)
08:22:54 <`ramses> you could also have changed the patterns and kept the ADTs
08:23:15 <dcoutts> tibbe: aye. I don't mind if we make the first release with a separate ui and merge later, it can be dictated by how long it takes, we don't have to rush it
08:23:26 <LucaS05> yes! :D
08:23:39 <tibbe> dcoutts: I feel strongly that we should not have separate commands in a first release
08:23:46 <tibbe> dcoutts: it will make the whole thing quite a pain to use
08:24:07 <LucaS05> i'm on my way to leave the beginner level :D
08:24:52 <dcoutts> tibbe: I'm not opposed to that, depends on if we can get reasonable patches soon enough
08:25:11 <tibbe> dcoutts: ok
08:25:16 <tibbe> dcoutts: i will talk to mikhail
08:25:45 <dcoutts> tibbe: btw, I merged ezyang's C support stuff
08:26:03 <dcoutts> tibbe: we'll have to look out for any interesting build/link bugs
08:26:07 <bgamari> tibbe, dcoutts, https://github.com/haskell/cabal/issues/1144
08:26:08 <tibbe> dcoutts: yup
08:26:15 <tibbe> dcoutts: we need more tests!
08:26:31 <dcoutts> tibbe: building exes now happens in three phases: compile hs files; compile C files; link everything
08:26:48 <npl> is it possible to have multiple arguments in a case statement? like case name age of "marc" 18 -> ...
08:26:56 <dcoutts> tibbe: all very traditional you might thing, but previously for exes we compiled C code, then made one single call to ghc to compile and link the exe
08:27:00 <dcoutts> thing/think
08:27:05 <joeyh> npl: use a tuple
08:27:06 <dmwit> npl: case (name, age) of ("marc", 18) -> ...
08:27:07 <dcoutts> tibbe: I ran all the tests
08:27:17 <npl> oh, thanks =)
08:27:18 <dcoutts> tibbe: but yes, larger scale regression testing
08:27:23 <tibbe> dcoutts: smaller too
08:27:31 <dcoutts> tibbe: also, we have a tricky linking issue
08:27:32 <dmwit> npl: Later, after profiling, if you discover this is too costly, you can unbox your tuple, but that's not too often needed.
08:27:34 <tibbe> dcoutts: new features that are rarely exercised by packages need unit tests
08:27:39 <dcoutts> aye
08:27:51 <tibbe> dcoutts: will this make building normal packages slower?
08:28:02 <dcoutts> tibbe: shouldn't do, not by much anyway
08:28:18 <tibbe> ok
08:28:35 <dcoutts> tibbe: so several users upgrading to 1.17 have reported linker problems, missing symbols
08:29:16 <tibbe> dcoutts: not good
08:29:18 <dcoutts> tibbe: my current hypothesis is that older cabal would build ghci .o libs and now we don't. But if you reinstall a package then the ghci .o file is still there, and ghci will still look at the .o version in preference to the .a version.
08:29:37 <tibbe> dcoutts: hmm
08:29:39 <dcoutts> so the two get out of sync obviously and then bang
08:30:11 <tibbe> dcoutts: who placed the .o files their originally? Cabal?
08:30:22 <neutrino_> jmcarthur: watching the jane st ocaml lecture video from 2009... "price: float;" >_<
08:31:00 <dmwit> neutrino_: That's just for presentation purposes, right? ...right?
08:31:27 <neutrino_> dmwit: ...right?
08:31:37 <dmwit> Then again, I've never actually written any financial code so maybe it's "good enough" for a lot of stuff. What do I know!
08:31:52 <neutrino_> haha.
08:31:58 * hackagebot git-annex 3.20121211 - manage files with git, without checking their contents into git  http://hackage.haskell.org/package/git-annex-3.20121211 (JoeyHess)
08:32:11 <Peaker> dcoutts, hey, I have a bunch of .lib files in Windows that I want to use as "extra-libraries", but I want to distribute them with my package
08:32:26 <Peaker> dcoutts, if I use extra-libraries/extra-lib-dirs - it wants absolute paths, not within-package-paths
08:32:28 <dcoutts> tibbe: originally, yes cabal.
08:32:59 <Peaker> does Cabal support extra-libs from within a package?
08:33:00 <dcoutts> Peaker: yes, they have to be on the system, because dependent packages need to link against them
08:33:16 <Peaker> hmm.. maybe I can install them as "data files" somehow and depend on them there?
08:33:23 <dcoutts> Peaker: the libs would have to be installed for that to work, either with the package or in advance
08:33:34 <dcoutts> Peaker: the other alternative is to link those libs into the lib you're making
08:33:35 <Peaker> dcoutts, these are c libs, btw, not Haskell libs
08:33:40 <dcoutts> aye
08:33:45 <Peaker> dcoutts, how do I link these libs into my package?
08:33:59 <dcoutts> you'd have to use custom code in the Setup.hs
08:34:03 <dcoutts> calling the linker
08:34:31 <Peaker> ah, any example of this somewhere?
08:34:46 <dcoutts> Peaker: not that I'm aware of
08:35:03 <tibbe> dcoutts: so perhaps we should kill the previously installed directory instead of just copying files into it?
08:35:25 <dcoutts> tibbe: that's extremely dubious in general
08:35:41 <dcoutts> tibbe: don't want to rm -rf /usr/local/lib  :-)
08:36:05 <tibbe> dcoutts: but perhaps usr/lib/ghc-7.4.2/time-1.4/ ?
08:36:12 <tibbe> dcoutts: getting of shuttle, brb
08:36:27 <dcoutts> tibbe: it's tricky to work out, the user can pick almost any set of dirs
08:36:28 <tibbe> dcoutts: we could try to just delete specify files if we want to
08:36:38 <dcoutts> tibbe: yes, I think a targeted approach might be better
08:36:52 <tibbe> dcoutts: but it's kinda dubious that we let a previous install remain when reinstalling. that is bound to lead to other issues eventually
08:37:07 <dcoutts> tibbe: that's the fault of the package manager really, ie cabal-install, not Cabal
08:37:22 <tibbe> we own both :)
08:37:44 <Peaker> dcoutts, ok thanks
08:38:06 <dcoutts> Peaker: I think what people usually do is just install the C libs in advance
08:39:51 <Peaker> dcoutts, it's pretty awesome to not have to, though :)
08:39:55 <bgamari> dcoutts, Also, is there a reason why package removal functionality isn't desirable in cabal-install?
08:40:02 <Peaker> (make a C lib cabal-install'able directly)
08:40:14 <dcoutts> bgamari: no, on the contrary, just nobody has implemented it
08:40:22 <Peaker> (freetype2, glfw-b do this, and that makes them so much nicer to use)
08:40:23 <d-snp> I'm installing a new version of cabal-install while at the same time running a cabal install for some package, will it work?
08:40:23 <bgamari> dcoutts, I see
08:40:26 <dcoutts> bgamari: always been other higher priorities
08:40:30 <dcoutts> bgamari: patches welcome :-)
08:40:49 <dcoutts> d-snp: if you're lucky
08:41:00 <dcoutts> Peaker: sure, it would be
08:41:37 <dcoutts> Peaker: one slight issue is if it means the package is now binary only
08:41:57 <dcoutts> Peaker: the other approach would be to have some way to separately have C lib packages for windows
08:42:33 <Peaker> hmm.. in my Setup.hs, what's an easy way to know if I'm in Windows?
08:42:46 <Peaker> I could use LANGUAGE CPP and pass a flag from .cabal if os(windows)
08:42:47 <bgamari> dcoutts, I think I'll take a quick look at what it would take to get a --rebuild-broken flag implemented
08:43:24 <bgamari> dcoutts, I'm not quite as familiar with what would need to happen to fully expunge a package from the database
08:43:49 <dcoutts> bgamari: it'd mean making a file manifest
08:44:31 <bgamari> dcoutts, ahh, right, I guess some things go into .cabal in addition to .ghc
08:44:49 <dcoutts> bgamari: yes, it'd mainly be about tracking files
08:45:06 <bgamari> dcoutts, alright, yeah. this sounds like a slightly harder problem
08:45:07 <tibbe> dcoutts: back
08:45:11 <bgamari> dcoutts, Where would you keep the manifest?
08:45:30 <eikke> hmh, didn't know David Mazieres is a Haskell'er, cool
08:45:38 <dcoutts> bgamari: that'd be something to work out, I'm sure there's reasonable solutions
08:46:58 * hackagebot warp 1.3.6 - A fast, light-weight web server for WAI applications.  http://hackage.haskell.org/package/warp-1.3.6 (MichaelSnoyman)
08:55:52 <mm_freak> is there a way to install via cabal /only/ the documentation of a package?  accessing docs installed by cabal-dev is very inconvenient
08:56:11 <mm_freak> or is there a way to make accessing cabal-dev docs more pleasant?
09:06:44 <rwbarton> where does the source for 'base' live under https://github.com/ghc/ghc? or am I looking in the wrong place entirely?
09:06:58 * hackagebot http-reverse-proxy 0.1.0.7 - Reverse proxy HTTP requests, either over raw sockets or with WAI  http://hackage.haskell.org/package/http-reverse-proxy-0.1.0.7 (MichaelSnoyman)
09:07:00 * hackagebot http-conduit 1.8.5.1 - HTTP client package with conduit interface and HTTPS support.  http://hackage.haskell.org/package/http-conduit-1.8.5.1 (MichaelSnoyman)
09:07:25 <parcs`> https://github.com/ghc/packages-base
09:07:44 <rwbarton> ahh
09:07:50 <rwbarton> thanks
09:22:24 <mm_freak> ok, forget it…  cabal-dev doesn't even build on GHC 7.6
09:22:34 <mm_freak> is there an alternative?
09:23:04 <typoclass> mm_freak: there's 1 or 2. virthualenv (note h) and the other is called henv or hsenv or similar
09:23:48 <typoclass> mm_freak: and possibly there's a fork of cabal-dev on github which is able to build on 7.6. if your issue is the well-known stuff about "version thingy cannot be Nothing"
09:24:09 <typoclass> mm_freak: i think luite was wrestling with the problem just yesterday
09:24:47 <scasino> scasino.com - additional 25 Euro Free on 50+ Euro first deposit
09:24:47 <scasino> BONUS code - bwinps4
09:25:29 <mm_freak> typoclass: the problem is that cabal-dev pulls in Cabal 1.2, which alone is weird, but that one doesn't build
09:25:47 <mm_freak> it doesn't seem to get along with the new exceptions
09:26:04 <typoclass> mm_freak: oh :-/ that's another issue then
09:26:06 <parcs`> mm_freak: i recall people suggesting to the upstream version of cabal-dev on ghc 7.6
09:26:34 <mm_freak> well, i don't like cabal-dev…  let's see if virthualenv does it better
09:27:42 <mm_freak> in fact virthualenv actually seems to do it better and also solves the documentation problem
09:29:40 <mm_freak> of course…  virthualenv wants base < 4.6
09:30:31 <mm_freak> let's see if i can work around that
09:31:48 <quchen> Why does Parsec define its own <|> operator? Every time I import it I have to hide it. Is it because it was easier to define it as `mplus`, i.e. to derive it from the monadic end?
09:31:59 * hackagebot yesod-auth 1.1.2.2 - Authentication for Yesod.  http://hackage.haskell.org/package/yesod-auth-1.1.2.2 (MichaelSnoyman)
09:32:40 <sclv> parsec preceded applicative as i recall
09:33:05 <sclv> don't remember if parsec's follows the laws
09:33:12 <sclv> if so it would probably be a good patch to replace it
09:33:31 <quchen> sclv: But it also *defines* <|> = mplus in the Applicative instantiation
09:34:01 <ocharles> it bugs me too
09:34:02 <quchen> ... and then a few pages later it rolls its own <|> with the same definition
09:34:03 <sclv> haha i guess it should just ditch the other then :-)
09:34:09 <quchen> Totally!
09:34:16 <sclv> send a patch, dude
09:34:20 <ocharles> +1
09:34:32 <quchen> Send a patch?
09:34:39 <quchen> I'll totally do that if you tell me how
09:35:01 <ocharles> cabal unpack parsec. fix it. send patch to maintainer address in the cabal file
09:35:10 <ocharles> hand waving, but that's generally the way of doing things
09:35:20 <quchen> Patch = diff file?
09:35:23 <ocharles> yea
09:36:05 <sclv> right, if you want you can pull the darcs repo (listed on the hackage page http://hackage.haskell.org/package/parsec) and generate a proper darcs patch instead
09:36:14 <Philonous> I want to get the TypeRep of the argument type of a function. Why doesn't (\f -> let x = undefined; _ = f x in typeOf x) type check?
09:36:22 <sclv> darcs record yr change, than darcs send -o to make the patch file
09:37:04 <sclv> Philonous: because x is of type forall a. a
09:37:06 <quchen> sclv: I have never worked with Darcs. (And I'm also a rookie with Git. I know, I should change that.)
09:37:21 <sclv> using it as an argument to f doesn't restrict its type
09:37:29 <sclv> (then using diff to generate a patch is simpler :-))
09:37:36 <Philonous> sclv:  Doesn't it get restricted when I use it at a specific type?
09:37:39 <sclv> no
09:37:55 <sclv> also what if f is polymorphic?
09:38:07 <sclv> what you do is get the typeOf f
09:38:10 <Philonous> sclv:  Right. Now that I think about it, it shouldn't.
09:38:11 <sclv> and then deconstruct that
09:39:55 <`nand`> :t \f -> (\x -> let _ = f x in typeOf x) undefined
09:39:56 <lambdabot> Typeable a => (a -> t) -> TypeRep
09:40:08 <`nand`> but yeah, what sclv said
09:40:37 <startling> @hoogle (a -> Bool) -> (a -> a) -> a -> [a]
09:40:38 <lambdabot> Prelude until :: (a -> Bool) -> (a -> a) -> a -> a
09:40:38 <lambdabot> Data.Generics.Aliases extT :: (Typeable a, Typeable b) => (a -> a) -> (b -> b) -> a -> a
09:40:38 <lambdabot> Prelude (.) :: (b -> c) -> (a -> b) -> a -> c
09:42:01 <sclv> `nand`: actually i think yours is cuter :-)
09:42:02 <Philonous> > (\f -> (\x -> let _ = f x in typeOf x) undefined) id
09:42:03 <lambdabot>   Ambiguous type variable `a0' in the constraint:
09:42:04 <lambdabot>    (Data.Typeable.Internal....
09:42:24 <sclv> > typeOf id
09:42:26 <lambdabot>   Ambiguous type variable `a0' in the constraint:
09:42:26 <lambdabot>    (Data.Typeable.Internal....
09:42:30 <sclv> can't do that anyway :-)
09:42:41 <quchen> ARGH. Parsec's <|> has infixr 1, Applicative has infixl 3.
09:42:51 <quchen> Other than that they're identical.
09:43:01 <sclv> oh, so compatibility reasons must be why they kept it
09:43:02 <sclv> ick
09:43:12 <sclv> can't go breaking all our parsers
09:43:26 <sclv> it would be nice to have that documented clearly in the haddocks if its not
09:43:34 <quchen> I'll at least tell him that
09:46:51 <ick> ick
09:49:07 <mightybyte> Is there any way to trigger a rebuild for a hackage package without uploading a new version?
09:49:45 <typoclass> mightybyte: cabal install --reinstall? not sure what you're looking for
09:51:50 <aavogt> mightybyte: might take an email to whoever runs hackage (Ross Paterson? or the address you send to get your hackage account)
09:57:53 <quchen> sclv: Mail's out! Parsec will be fixed in 3..2..
09:57:55 <quchen> ;-)
10:09:37 <zomg> Damnit, how much RAM does compiling pandoc require...
10:10:30 <mightybyte> aavogt: Cool, thanks.
10:11:46 <startling> mightybyte: yeah, there's definitely not an automated one.
10:12:00 <typoclass> mightybyte: out of curiosity, if your package is unchanged, how could a second build attempt make any difference?
10:13:06 <fmap> dependencies might get fixed
10:13:42 <`nand`> :t let typeOfArg :: Typeable a => (a -> b) -> TypeRep; typeOfArg _ = typeOf (undefined :: a) in typeOfArg
10:13:44 <lambdabot>     Ambiguous type variable `a0' in the constraint:
10:13:44 <lambdabot>       (Typeable a0) arising from a use of `typeOf'
10:13:44 <lambdabot>     Probable fix: add a type signature that fixes these type variable(s)
10:14:00 <`nand`> oh, no ScopedTypeVariables?
10:14:10 <`nand`> but yeah, that + ScopedTypeVariables would be the ‘ideal’ solution I think, sclv
10:14:20 <`nand`> (why doesn't Typeable use a Proxy type?)
10:14:47 <typoclass> fmap: ah right :-) if you don't depend on some exact version, *they* might have uploaded a new one
10:16:51 <mightybyte> typoclass: Because a dependency problem was fixed.
10:17:05 <typoclass> mightybyte: yup, got it, thanks
10:17:58 <zomg> Gah, time to mount more swap space then...
10:18:06 <zomg> Haskell + VPS with not a ton of RAM is such a pain in the ass sometimes
10:18:06 <zomg> :P
10:18:25 <RichyB> Dense vectors are your friend.
10:19:15 <Apocalisp> edwardk: I'm inclined to say that the applicative laws are implied by the functor law and parametricity. Am I off my rocker?
10:21:10 <Apocalisp> "Applicative functor" == "functor with <*> and pure"
10:22:04 <glguy> It'd be pretty easy to make an Applicative instance that didn't satisfy the Applicative laws without violating the Functor laws if that's what you mean
10:22:44 <glguy> or were you talking about some specific type where there is only one implementation
10:22:59 <dmwit> :t \xs ys -> case (xs, ys) of (x:_, y:_) -> [(x,y)]; _ -> []
10:23:00 <lambdabot> [t] -> [t1] -> [(t, t1)]
10:23:24 <edwardk> Apocalisp: you're off your rocker.
10:24:03 <Apocalisp> a counterexample would be most welcome if it's pretty easy
10:24:06 <dmwit> Remember: the "f" in the type signatures isn't parametrically polymorphic, only typeclass polymorphic.
10:24:09 <dmwit> Apocalisp: I just gave one, I think.
10:24:20 <Apocalisp> oh, I missed that
10:24:40 <glguy> take the instance for list and change pure x = [x,x]
10:24:46 <edwardk> Apocalisp: its pretty easy to violate associativity, its also easy to violate each unit law
10:25:02 <Apocalisp> glguy: That would violate the functor law, wouldn't it?
10:25:12 <dmwit> What's the functor law?
10:25:13 <glguy> functor doesn't have pure
10:25:16 <edwardk> Apocalisp: what functor law pertains to pure?
10:25:53 <edwardk> the only functor law is fmap id = id, from that you get fmap f . fmap g = fmap (f . g) by parametricity, but thats it
10:26:22 <Apocalisp> ((<*>) . pure) id = id
10:26:39 <Apocalisp> isn't that the same law?
10:26:45 <edwardk> Apocalisp: pure and (<*>) aren't properties of functors.
10:27:16 <edwardk> :t liftA2 (.)
10:27:17 <lambdabot> (Functor f1, Applicative f) => f (a -> b) -> f (f1 a) -> f (f1 b)
10:27:21 <edwardk> bah
10:27:26 <dmwit> Maybe Apocalisp is asking whether "(pure f <*>) = fmap f" is the only law you need...?
10:27:27 <edwardk> :t liftA2 (Prelude..)
10:27:29 <lambdabot> Applicative f => f (b -> c) -> f (a -> b) -> f (a -> c)
10:27:29 <Apocalisp> Oh I see. So if the only additional law is that (<*>) . pure = fmap
10:27:48 <Apocalisp> dmwit: I think I am in fact asking that.
10:28:17 <edwardk> if you take that as a more convenient (<*>), then you need that that composition is associative, and that pure id acts as a unit for it
10:28:25 <edwardk> those 3 laws do not follow from parametricity
10:28:49 <edwardk> also the fmap f m = pure f <*> m    also needs to be proven separately
10:29:08 <edwardk> if you prove the 3 laws about applicative, then that version of fmap being valid follows
10:29:23 <edwardk> but you should validate that whatever fmap you write is compatible with that
10:29:48 <dmwit> edwardk: What about the other way? If you prove that equality, do you get any of the three necessary other properties for free?
10:30:04 <Apocalisp> what dmwit said
10:30:32 <edwardk> dmwit: i definitely don't think so. its easy to make pure work on the left side of (<*>)  and have a bunch of other crap cases in your Applicative.
10:30:54 <Saizan> you get that pure id is a left-unit of liftA2 (.) pretty easily
10:31:19 <Apocalisp> which is the composition law
10:31:22 <edwardk> Saizan: 1 out of 3
10:31:36 <dmwit> edwardk: Ah, yeah, since we get to control both pure and (<*>) they can conspire to make that law hold in a funny way.
10:31:40 <Saizan> yep, the question was any though :)
10:32:00 * hackagebot concurrent-extra 0.7.0.5 - Extra concurrency primitives  http://hackage.haskell.org/package/concurrent-extra-0.7.0.5 (BasVanDijk)
10:32:06 <edwardk> fair enough, you get the left unit law =P
10:32:21 <dmwit> e.g. pure x = [x]; [f] <*> y = famp f y; _ <*> _ = error "lollerskates"
10:32:26 <edwardk> beyond that you're on your own
10:32:27 <dmwit> s/famp/fmap/
10:32:52 <edwardk> lollerskates ftw
10:33:52 <Apocalisp> pure f <*> pure x = pure (f x)  ==> fmap f (pure x) = pure (f x)
10:35:05 <edwardk> that doesn't get you closer to the associativity law. it gets you associativity for <*> on pure values.
10:35:10 <edwardk> but not in general
10:35:35 <Apocalisp> I see
10:36:02 <dmwit> (In fact, I think the lollerskates example satisfies this proposed law.)
10:38:05 <Apocalisp> resorting to bottoms is cheating a little bit
10:38:26 <dmwit> eh, pick any bad non-bottom thing and substitute it there
10:38:28 <dmwit> like [] for example
10:38:29 <simpson> edwardk: I was trying to explain Applicative to a friend the other day, and she asked, "So are there any Functors which aren't Applicative?" I couldn't think of any. Do you know of one?
10:38:52 <edwardk> Apocalisp: just make another constructor named Lollerskates
10:38:59 <dmwit> exactly
10:39:51 <edwardk> data Const a b = Const a    -- that isn't Applicative unless you know something about a.
10:39:54 <glguy> The Const functor isn't
10:40:18 <simpson> edwardk: Aha.
10:40:19 <edwardk> you need a Monoid on 'a' to manufacture it out of whole cloth for pure, and to ensure associativity on (<*>)
10:40:20 <sclv> pair too
10:40:22 <dmwit> http://stackoverflow.com/q/7220436/791604
10:40:42 <edwardk> (,) e  isn't applicative unless you have a monoid on e as well
10:40:45 <S11001001> simpson: lots of trees
10:41:05 <S11001001> simpson: forall a. Map a
10:41:33 <dmwit> ew, I take that recommendation back
10:41:36 <edwardk> Map k is a functor, and it even could permit (<*>), but it isn't applicative. what key would you use?
10:41:57 <edwardk> IntMap, HashMap k
10:41:58 <dmwit> This guy thinks "mempty = undefined" is an okay implementation of Monoid for Void?
10:42:06 <sclv> hmm… so what are the functors that don't let you have <*> ?
10:42:07 <edwardk> dmwit: =P
10:42:19 <Apocalisp> Map k is one of those semigroupoid things?
10:42:19 <sclv> we've named ones that don't have "pure" only
10:42:26 <sclv> I suppose pair isn't good on <*> either
10:42:39 <sclv> since you have no idea wtf to do with the first element
10:42:56 <dmwit> sclv: It would be a bit odd to have some category that had all finite products but not nullary products.
10:43:12 <sclv> although if you pick a monoid on it (first, last, etc.) then you could...
10:43:13 <neutrino_> hi edwardk :)
10:43:18 <dmwit> Wait, you're saying that's the variant that's already been named?
10:43:21 <dmwit> strange
10:45:09 <beaky> anyone else here like pattern matching?
10:45:21 <beaky> I wish C or C++ had something like it
10:45:50 <beaky> seems I can only emulate it with switch/enum/tagged unions in C, or virtual functions and visitor pattern in C++
10:45:56 <simpson> beaky: C++ can pattern-match enumerations.
10:46:03 <beaky> ah
10:46:10 <Leo__> why is he always terminating my sort list
10:46:11 <simpson> beaky: Also, switch/case is pretty much exactly the same mechanism.
10:46:16 <johnw> beaky: have you discovered view patterns and pattern guards yet?
10:46:23 <beaky> what are view patterns?
10:46:46 <johnw> say i have a function that takes a list as its second argument
10:46:49 <johnw> i could write:
10:47:01 <johnw> f x (length -> 0) = x
10:47:08 <beaky> ah
10:47:11 <johnw> the list gets passed to "length", and then I am pattern matching on the result
10:47:41 <dmwit> Leo__: wat?
10:47:42 <beaky> so it's sugar for f x xs | length xs == 0 = x
10:47:55 <johnw> ye
10:47:55 <johnw> s
10:48:01 <johnw> it becomes more handy when there are multiple parameters
10:48:02 <Leo__> nvm it worked
10:48:04 <beaky> right
10:48:05 <dmwit> beaky: Not quite, because you can actually pattern match, not just use equality tests.
10:48:06 <Leo__> thanks anyway
10:48:11 <johnw> which would otherwise require a bit more convoluted code
10:48:32 <johnw> you have to enable ViewPatterns with an extension; but pattern guards are always there
10:48:51 <beaky> nice that patern matching lets you deconstruct stuff and bind each part to variables
10:48:52 <dmwit> It's a bit like f x xs = case length xs of 0 -> x, except that it doesn't commit unless the match succeeds.
10:48:59 <johnw> a pattern guard is like: f x xs | 0 <- length xs = x
10:49:29 <johnw> beaky: yeah, it's like Lisp's destructuring-bind on steroids ;)
10:49:30 <Chathurga> does xs@(length -> 0) work?
10:49:48 <johnw> Chathurga: try it!
10:49:53 <Chathurga> true
10:50:01 <dmwit> To be honest, I'm not sure how to "desugar" view patterns short of running the bit of the compiler that turns complex patterns into simple ones in your head. Nasty.
10:50:23 <beaky> I hope C++ gets pattern matchin someday
10:50:40 <johnw> beaky: Bjarne wrote a paper on "type-based switch"
10:50:44 <beaky> ah
10:50:46 <johnw> which is a step in that direction
10:51:07 <beaky> and boost has some data structure thingy that's like algebraic data structures
10:51:14 <johnw> variant
10:51:16 <beaky> ah
10:51:38 <beaky> but it's just visitor pattern with some template-magic :D
10:52:25 <Crd1> How do you find the number of characters in a file
10:52:40 <Crd1> I mean, using which function?
10:52:45 <johnw> Crd1: count <- length <$> readFile "foo"?
10:53:21 <dmwit> Ah, "characters". Such a slippery word.
10:53:29 <johnw> true
10:53:45 <Iceland_jack> Do you mean “number of a specific character”?
10:53:59 <Iceland_jack> or a total number
10:54:13 <Crd1> Total number of characters
10:54:21 <dmwit> I'm now curious what readFile does with decoding errors.
10:54:22 <Crd1> Actually I just started on the real world haskell
10:54:29 <Crd1> they asked to edit WS.hs
10:54:30 <johnw> and by characters do you mean bytes, or Unicode code points?
10:54:43 <Crd1> Modify the WC.hs example again, in order to print the number of characters in a file.
10:54:48 <Philonous> Seems like I need to stop thinking of let x = p in e as syntactic sugar for (\x -> e) p
10:54:58 <dmwit> Yes, in Haskell they have subtly different typing rules.
10:55:03 <johnw> Philonous: why?
10:55:06 <Crd1> Think the answer would be pretty simple as it is chp 1
10:55:08 <Crd1> haha
10:55:14 <dmwit> johnw: let is more polymorphic than lambda
10:55:19 <johnw> ah
10:55:31 <Iceland_jack> Search for “let polymorphism”
10:55:34 <Iceland_jack> it's a pretty big thing
10:55:49 <johnw> http://www.haskell.org/tutorial/pitfalls.html
10:58:02 <dmwit> Right, it throws an exception. That really should have been my guess, in hindsight.
11:01:06 <dmwit> I wonder if there's a market for a filesystem where files are either sequences of bytes or sequences of codepoints.
11:01:40 <elliott> limiting it to two data types?
11:01:41 <dmwit> I guess not, since there's still the whole "network" thing to deal with.
11:01:46 <dmwit> elliott: sure, why not
11:02:01 * hackagebot grapefruit-frp 0.1.0.3 - Functional Reactive Programming core  http://hackage.haskell.org/package/grapefruit-frp-0.1.0.3 (WolfgangJeltsch)
11:02:03 * hackagebot grapefruit-records 0.1.0.3 - A record system for Functional Reactive Programming  http://hackage.haskell.org/package/grapefruit-records-0.1.0.3 (WolfgangJeltsch)
11:02:05 * hackagebot grapefruit-ui 0.1.0.3 - Declarative user interface programming  http://hackage.haskell.org/package/grapefruit-ui-0.1.0.3 (WolfgangJeltsch)
11:02:53 <dmwit> elliott: (I know, I know. "0, 1, many". But then I also write most of my programs in a language whose type system has 4 levels. Four! Is that even a number??)
11:03:25 <elliott> dmwit: it's like a really big 1
11:03:36 <dmwit> =D
11:03:41 <elliott> @remember dmwit I know, I know. "0, 1, many". But then I also write most of my programs in a language whose type system has  4 levels. Four! Is that even a number??
11:03:41 <lambdabot> Okay.
11:03:49 <elliott> hmph, irssi
11:03:51 <elliott> @forget dmwit I know, I know. "0, 1, many". But then I also write most of my programs in a language whose type system has  4 levels. Four! Is that even a number??
11:03:51 <lambdabot> Done.
11:03:55 <elliott> @remember dmwit I know, I know. "0, 1, many". But then I also write most of my programs in a language whose type system has 4 levels. Four! Is that even a number??
11:03:56 <lambdabot> Good to know.
11:07:07 * hackagebot grapefruit-ui-gtk 0.1.0.3 - GTK+-based backend for declarative user interface programming  http://hackage.haskell.org/package/grapefruit-ui-gtk-0.1.0.3 (WolfgangJeltsch)
11:07:09 * hackagebot grapefruit-examples 0.1.0.3 - Examples using the Grapefruit library  http://hackage.haskell.org/package/grapefruit-examples-0.1.0.3 (WolfgangJeltsch)
11:10:27 <Apocalisp> Iceland_jack: Allra þjóða kvikindum mætir maður hér
11:11:17 <Iceland_jack> hah já ætli það ekki
11:11:21 <Apocalisp> Eða er þetta sami Baldur og síðast?
11:11:43 <Iceland_jack> Tja ég er alla vega Baldur
11:12:34 <Iceland_jack> :)
11:12:44 <Apocalisp> Is there much Haskell in Iceland?
11:13:02 <jeltsch> Apocalisp, Iceland_jack: Beautiful language, not such a boring mainstream thing. ;-)
11:13:22 <Apocalisp> jeltsch: I assume you mean Haskell :)
11:13:27 <Iceland_jack> heh
11:13:30 <beaky> :D
11:13:33 <Iceland_jack> There is not much Haskell in Iceland :)
11:13:44 <jeltsch> Apocalisp: No, I meant icelandic.
11:13:51 <jeltsch> Aga eesti keel on ka väga ilus. ;-)
11:13:54 <Iceland_jack> I looked at the Reykjavík Haskell User Group and there was a single guy there from my school
11:14:52 <jeltsch> I hope there are no Estionans around who spot mistakes in my use of their language.
11:14:57 <Apocalisp> Háskólinn í Reykjavík?
11:15:12 <Iceland_jack> No, Chalmers
11:15:30 <Apocalisp> jahérna
11:15:30 <jeltsch> And I hope there are no Estonians here who realized that I misspelled “Estionans”. :-D
11:15:37 <Iceland_jack> jeltsch: hehe
11:15:51 <jeltsch> Erm, did it wrong again.misspelled “Estonians”.
11:15:58 <Iceland_jack> Apocalisp: Currently staying right outside of Gothenburg
11:15:59 <Apocalisp> we need to form Haskell Háskólinn in Iceland
11:16:12 <Iceland_jack> Good luck with that :)
11:16:22 <Philonous> jeltsch:  Now you got the Estionans all confused
11:16:28 <jeltsch> :-)
11:16:32 * Iceland_jack is unsure whether that was a snide remark or not
11:17:02 <jeltsch> I hope it wasn’t.
11:19:30 <jeltsch> Is gtkglext still maintained? The latest updates to Gtk2Hs didn’t provide new versions of gtkglext, and gtkglext is also not mentioned http://projects.haskell.org/gtk2hs/documentation/.
11:27:01 * hackagebot hsx-jmacro 7.2.0 - hsx+jmacro support  http://hackage.haskell.org/package/hsx-jmacro-7.2.0 (JeremyShaw)
11:27:03 * hackagebot snap 0.10.0.1 - Top-level package for the Snap Web Framework  http://hackage.haskell.org/package/snap-0.10.0.1 (DougBeardsley)
11:36:14 <beaky> @src zipWith2
11:36:14 <lambdabot> Source not found. Do you think like you type?
11:36:16 <beaky> @src zipWith
11:36:16 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
11:36:16 <lambdabot> zipWith _ _      _      = []
11:36:18 <beaky> @src zipWit3
11:36:18 <lambdabot> Source not found. I've seen penguins that can type better than that.
11:36:24 <beaky> :(
11:38:08 <b__> @src zipWith3
11:38:08 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
11:38:16 <b__> :(
11:42:41 <mercury^> Why is a proper en-dash (–) not supported as comment-start with -XUnicodeSyntax?
11:43:22 <parcs`> :t (–)
11:43:23 <lambdabot> fd:9: commitBuffer: invalid argument (invalid character)
11:43:36 <parcs`> mercury^: because it's a valid operator
11:43:56 <mercury^> Isn't → also?
11:44:02 <beaky> let zipWith3 f xs ys zs = if (null xs || null ys || null zs) then [] else f (head xs) (head ys) (head zs) : zipWith3 f (tail xs) (tail ys) (tail zs) in zipWith3 (\x y z -> x + y + z) [1..10] [10..] [20..]
11:44:07 <beaky> > let zipWith3 f xs ys zs = if (null xs || null ys || null zs) then [] else f (head xs) (head ys) (head zs) : zipWith3 f (tail xs) (tail ys) (tail zs) in zipWith3 (\x y z -> x + y + z) [1..10] [10..] [20..]
11:44:09 <lambdabot>   [31,34,37,40,43,46,49,52,55,58]
11:44:12 <beaky> yay
11:44:28 <parcs`> mercury^: yep
11:44:53 <parcs`> then that's not the reason
11:44:58 <mercury^> parcs`: so your argument is invalid, because with XUnicodeSyntax → is a replacement for ->
11:45:30 <parcs`> mercury^: i don't think the comment delimiter -- is meant to be an ascii representation of an em dash
11:45:42 <mercury^> I am pretty sure that it is.
11:45:48 <beaky> :t zipWith3
11:45:49 <lambdabot> (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]
11:45:53 <beaky> :D
11:45:57 <Clint> then why did you say en dash
11:46:08 <parcs`> mercury^: why is that?
11:46:08 <mercury^> Err, en-dash.
11:46:12 <mercury^> Clint: :)
11:46:44 <mercury^> parcs`: because the en-dash is a comment delimiter in the english language; that motivates the use as a comment delimiter in programming languages.
11:47:12 <mercury^> For Ada that is even stated in the reference manual, I think.
11:47:14 <Clint> http://hackage.haskell.org/trac/ghc/ticket/5239
11:47:24 <b__> double hyphen usually stands for an em-dash though
11:48:03 <mercury^> At least in TeX, double hyphens are an en-dash and triple hyphens are an em-dash.
11:48:40 <parcs`> mercury^: do you have a source for en dash being used to delimit comments in the english language?
11:50:03 <mercury^> Not a particular one, but many novels use it in that way.
11:50:24 <mercury^> It depends on who typeset it; older ones tend to use em-dashes while newer ones use spaced en-dashes.
11:52:17 <parcs`> oh, right, they can be used around parenthetical expressions
11:53:05 <b__> yes, and for ranges
11:53:11 <parcs`> according to the ticket en dash is not supported because nobody cares enough to support it
11:53:21 * glguy learns that ⌥- and ⌥⇧- are en- and em-dash on OS X, respectively
11:53:23 <mercury^> Which ticket?
11:53:56 <parcs`> mercury^: http://hackage.haskell.org/trac/ghc/ticket/5239
11:55:39 <mercury^> There it seems as if the issue is still open. But I think that it should be an en-dash and not an em-dash.
11:55:48 <neutrino_> hi glguy
11:56:40 <glguy> Hi
11:56:50 <neutrino_> parcs`: what about support for →
11:57:10 <parcs`> neutrino_: it's already there -XUnicodeSyntax
11:57:18 <neutrino_> oh right ok
11:57:24 <Guest90658> hello guys
11:57:54 <neutrino_> bear in mind the comments in haskell are actually started with an em dash
11:58:02 <BILLI> Who are programming on Haskell now ?
11:58:26 <neutrino_> and that they are usually meant to comment what's to the left of them on that same line
11:58:30 <neutrino_> for example:
11:58:38 <neutrino_> * apples -- healthy
11:58:44 <neutrino_> * hamburgers -- not healthy
11:58:52 <neutrino_> * fries -- not healthy
12:02:02 * hackagebot tpdb 0.6.1 - Data Type for Rewriting Systems  http://hackage.haskell.org/package/tpdb-0.6.1 (JohannesWaldmann)
12:02:24 <johnw> there's a data type that can rewrite my system?
12:02:24 <johnw> hmm
12:03:38 <neutrino_> johnw: no, it's obviously a package with data systems where that data is types for rewriting
12:05:40 <neutrino_> to safely share a variable between threads i'd use an MVar, right?
12:05:48 <neutrino_> or would it be something else?
12:05:58 <johnw> or use STM
12:06:04 <c_wraith> MVars are for mutually-exlusive access to a mutable cell
12:06:12 <c_wraith> Is that the property you want?
12:07:28 <neutrino_> i don't want mutual exclusivity, since i'll be writing from only one thread, and reading from many, but 1. it's a bool and 2. nothing bad happens if one of the threads, which checks the var in every loop iteration, will get the old value (False) once or twice before it gets True
12:07:37 <neutrino_> so, i don't *need* it
12:07:48 <neutrino_> it'd be nice if it were something that isn't heavy to check
12:08:45 <c_wraith> so you really want an IORef
12:08:47 <neutrino_> because i'll be doing this for every char that gets piped through my program, and there'll be a lot of chars getting piped around.
12:08:55 <neutrino_> right, i think that could be good too
12:09:11 <c_wraith> IORefs give you no synchronization of any sort
12:09:18 <c_wraith> No guarantees of any sort..
12:09:24 <c_wraith> But they're simple
12:10:32 <napping> would you like the loop to block until it becomes true?
12:10:59 <c_wraith> If you want guaranteed delivery to things reading from it, an IORef is very wrong.
12:11:37 <neutrino_> in what way is delivery unguaranteed?
12:12:05 <napping> Isn't sequential consistency promised?
12:12:20 <c_wraith> If you change it again before a particular thread reads from it, the reader will never know it missed a value
12:12:28 <neutrino_> oh, that's fine
12:12:32 <neutrino_> i'll only ever change it once.
12:12:44 <danr> neutrino_: if you want to broadcast you can use Chan or TChan
12:12:46 <neutrino_> it's for telling a bunch of threads "ok guys, time to go home"
12:12:53 <napping> it sounds kind of like you are building some sort of synchronization thing
12:13:03 <neutrino_> yeah, i kinda am.
12:13:09 <napping> so maybe something like killing excess workers with asynchronous exceptions would be better
12:13:18 <neutrino_> i've got a few threads which read from and write to chans and write to some files
12:13:25 <c_wraith> MVar () might be most appropriate
12:13:27 <c_wraith> create it empty
12:13:42 <c_wraith> And attempt to use readMVar in the listeners
12:13:44 <napping> they are working in the background and you want to tell them to stop?
12:13:52 <c_wraith> Oh, that's a good point.
12:13:57 <c_wraith> working vs blocking matters
12:13:57 <neutrino_> yes napping
12:14:25 <c_wraith> in that case, async exceptions might be easiest
12:14:41 <neutrino_> they're not the easiest because i'll need to keep a pool of workers and pass it around
12:14:54 <neutrino_> i can just pass around the ioref instead and that works more easily
12:15:15 <neutrino_> i need to kill from the parent thread, so i'll do something like rQuit <- startLogging
12:15:19 <napping> I don't see how it's harder to pass around the one or the other
12:15:24 <neutrino_> and then pass rQuit to all the threads that get created inside startLogging
12:15:42 <neutrino_> napping, i'll have to create threads inside threads
12:15:50 <neutrino_> that'll be really crappy
12:16:00 <neutrino_> i COULD pass around an mvar with a list of all the workers
12:16:04 <neutrino_> but again
12:16:11 <neutrino_> that's more complex than just an IORef isn't it?
12:16:15 <neutrino_> i guess it depends..
12:16:23 <neutrino_> because i'll have to be checking the IORef on every loop
12:16:32 <neutrino_> and if i keep a list of workers to send exceptions to i won't have to
12:17:05 <neutrino_> ghc will take care of exception checking with some super-optimized nop loop stuff
12:17:15 <napping> what are all the workers doing anyway?
12:17:21 <c_wraith> it's not actually that super-optimized
12:17:24 <neutrino_> by modifying that nop to a local jump probably
12:17:46 <c_wraith> async exceptions are checked for during every allocation
12:18:01 <c_wraith> But you're paying that cost whether or not you're using async exceptions
12:24:19 <neutrino_> napping: 1 sec
12:24:28 <neutrino_> i had to make a drawing to understand the newest version of my concept of this
12:24:39 <neutrino_> ok i have the main thread which forks off to run, say, make
12:25:37 <neutrino_> that returns two handles, with make's stdout and stderr.
12:25:57 <neutrino_> those two have one thread each writing to one chan each, say cOut and cErr
12:26:13 <neutrino_> the main thread can also write to cOut and cErr
12:26:29 <Yuu-chan> I've read the 25th chapter of RWH and decided to try, but -funbox-strict-fields seems to give the same boxed tuple
12:27:34 <neutrino_> then, for each cOut and cErr i have a thread each. those read off the channel and write to a channel called cDB, which is of type Chan (), and to a channel called cLog, which is Chan String, and those two threads also write to stdout and stderr each
12:28:16 <neutrino_> cDB gets emptied by the "db thread" every 1 second, at which point if it was non-empty a timestamp is written to a db (i might actually replace that with an MVar)
12:28:35 <neutrino_> cLog gets polled by a logging threas which writes to a log file
12:29:16 <neutrino_> so i have threads for: 0. make itself 1. make's stdout 2. make's stderr 3. cOut 4. cErr 5. DB 6. Logging
12:29:30 <neutrino_> 0 terminates on its own, and once it's terminated i need to quit 1-6
12:29:40 <neutrino_> i hope that makes sense napping
12:30:23 <napping> why are the db and log writers separate?
12:30:52 <neutrino_> because the db needs to wake up and check if anything's up every 1 second, the log writer needs to write asap
12:31:14 <napping> I mean why are they separate from the threads reading on the channels?
12:32:18 <neutrino_> right, i might actually make the logging thread part of the cOut and cErr threads
12:32:22 <napping> how about just using System.Process to spawn the process (maybe in a thread), and then forking off one log thread and one DB thread that read the Handles at appropriate frequencies, and die when the handles close?
12:32:27 <neutrino_> but then i have e.g. duplicated code and other stuff
12:33:05 <napping> that can be fixed by pulling out (higher-order?) functions
12:33:06 <neutrino_> well, for one thing, i can't read from the same handle in two threads
12:33:16 <neutrino_> because they'll be stealing data from eachother
12:33:19 <neutrino_> right?
12:33:22 <napping> didn't you say one reads stdout, one reads stderr
12:33:29 <neutrino_> yeah
12:33:30 <neutrino_> but
12:33:36 <neutrino_> the log needs to get stdout and stderr
12:33:39 <neutrino_> and so does the db thread
12:34:13 <neutrino_> whereas the stdout and stderr from make need to go to the terminal's stdout and stderr separately
12:35:23 <neutrino_> after having each "\n" replaced with "\nmake stdout> " or "\nmake stderr> "
12:35:29 <neutrino_> while when the main thread writes to stdout and stderr that replacement shouldn't happen
12:36:01 <neutrino_> but when the main thread writes it should go to the log file, and the db, just like when make does
12:36:21 <neutrino_> so i need threads 1 and 2 for this replacement
12:36:45 <neutrino_> and i obviously need threads 3 and 4 for dispatching from cOut and cErr
12:37:01 <neutrino_> and i need a thread for the db (5)
12:37:08 <neutrino_> i may or may not need thread 6
12:37:16 <neutrino_> but that's still 5 threads that need to be stopped
12:37:26 <neutrino_> i could put them all in MVars
12:37:30 <neutrino_> i guess
12:37:52 <neutrino_> or rather, put them all in a single MVar
12:37:57 <neutrino_> in a 5-tuple
12:38:34 <danr> uh, do you really want to hard-code that you're using 5 threads?
12:38:52 <neutrino_> yes
12:39:09 <sclv> any good examples of packages using the new test: feature of cabal along with haskell-test-framework?
12:39:10 <neutrino_> if you can use a tuple instead of a list it's usually better to use a tuple
12:39:27 <neutrino_> sclv: i can give you a skeleton that uses test-framework
12:39:40 <neutrino_> sclv: but i'll have to do that later because i'm about to go out for an hour or so
12:39:57 <sclv> thanks!
12:40:04 <sclv> if i'm around later, ping me :-)
12:40:11 <napping> maybe something like TMChan
12:40:31 <sclv> (if anyone else wants to jump in with a link to hackage or w/e with a good example i'd appreciate it. just want to see basic structure)
12:40:32 <neutrino_> sclv: do you mean test or test-suite btw?
12:40:33 <napping> I think the simplest way is to just let the threads die naturally when the data runs out
12:40:37 <danr> neutrino_: bah, I disagree. If you're using an n-tuple with n larger than 2, you'd better create a record data type (a "named" tuple)
12:40:46 <sclv> maybe test-suite… whatever the cabal thing is
12:40:47 <neutrino_> i am using test-suite, with type: exitcode-stdio-1.0
12:41:31 <hpaste> neutrino pasted “cabal for sclv” at http://hpaste.org/79088
12:41:36 <danr> neutrino_: I'm not saying you should use a list, use an array or a Map
12:41:48 <sclv> w00t
12:41:52 <thoughtpolice> sclv: https://github.com/thoughtpolice/hs-quicklz/blob/master/quicklz.cabal
12:41:59 <thoughtpolice> oh, nvm, neutrino_ beat me :P
12:42:10 <sclv> i <3 #haskell
12:42:42 <sclv> neutrino++
12:42:49 <sclv> thoughtpolice++
12:44:11 <thoughtpolice> sclv: and the 'benchmark' field is almost identical, including the 'type: exitcode-stdio-1.0', FWIW. :)
12:44:25 <sclv> cool
12:45:43 <hpaste> neutrino pasted “test/testsuite.hs for sclv” at http://hpaste.org/79089
12:46:26 <hpaste> neutrino pasted “test/test.sh for sclv” at http://hpaste.org/79090
12:46:30 <neutrino_> here you go
12:46:42 <sclv> awesome
12:47:06 <neutrino_> danr: tuples are simple :p
12:47:18 <neutrino_> danr: it's about correctness, it's not about code reusability.
12:47:48 <neutrino_> or readability
12:48:52 <danr> neutrino_: I am of the opinion that correctness is hard to achieve without readability
12:51:17 <acowley> I kind of wish there was a dumb re-export module for using test-framework with hunit and quickcheck. I find managing the imports myself (particularly the Test type) needlessly finicky.
13:17:03 * hackagebot netclock 0.4 - Netclock protocol  http://hackage.haskell.org/package/netclock-0.4 (AlexMcLean)
13:29:10 <beaky> how do I construct an infinitely-nested list in haskell
13:29:18 <beaky> > let x = [x]
13:29:20 <lambdabot>   not an expression: `let x = [x]'
13:29:23 <beaky> :(
13:29:35 <beaky> > let f x = f [x]
13:29:36 <lambdabot>   not an expression: `let f x = f [x]'
13:29:42 <simpson> > fix (\x -> [x])
13:29:44 <lambdabot>   Occurs check: cannot construct the infinite type: t0 = [t0]
13:29:47 <beaky> oh
13:30:00 <beaky> I love deep recursion like that
13:30:14 <simpson> AFAIK you can't get an arbitrarily-deep list without some typeclass magic.
13:30:17 <S11001001> beaky: Free []
13:30:19 <simpson> beaky: Why?
13:30:55 <beaky> because recursion is nice :D
13:31:31 <Yuu-chan> beaky: data NestedList a = Atom a | List [NestedList a]
13:31:36 <S11001001> Free [] Int is the type of an arbitrarily nested list with Ints at the leaves; you don't have to have any ints in the structure at all though
13:31:40 <beaky> :t Free
13:31:41 <lambdabot> Not in scope: data constructor `Free'
13:31:50 <S11001001> and is isomorphic to what Yuu-chan just wrote
13:31:58 <beaky> oh
13:32:04 <Yuu-chan> @hoogle Free
13:32:05 <lambdabot> Foreign.Marshal.Alloc free :: Ptr a -> IO ()
13:32:05 <lambdabot> Foreign.Ptr freeHaskellFunPtr :: FunPtr a -> IO ()
13:32:05 <lambdabot> Foreign.Marshal.Pool freePool :: Pool -> IO ()
13:32:26 <S11001001> http://hackage.haskell.org/packages/archive/free/3.2/doc/html/Control-Monad-Free.html
13:32:58 <S11001001> note especially the constructors Pure and Free
13:33:42 <uniquenick> do any of the cabal sandboxing tools let me share my global platform packages, while just sandboxing the other stuff my projects need?
13:35:22 <Zer000> hi. Totally new to this language, coming from python. Where do I begin?
13:35:55 <gienah> @where lyah
13:35:55 <lambdabot> http://www.learnyouahaskell.com/
13:37:06 <Zer000> awesome!
13:39:32 <Cale> Zer000: also, feel free to ask lots of questions here
13:39:44 <Zer000> Ok if I get stuck on anything, I will.
13:40:42 <Yuu-chan> Zer000: http://blog.ezyang.com/2011/11/how-to-read-haskell/ ;)
13:44:52 <Chathurga> Hmm, I want to have a list of tuples containing numeric functions like [((- 1), (- 1))] :: [(Int -> Int, Int -> Int)] to describe several directions I want to apply on points but I get an error "No instance for (Num (Int -> Int)) arising from a use of syntactic negation" is there a better way to go about this?
13:45:07 <Cale> (-1) means negative 1
13:45:12 <Cale> not the function which subtracts 1
13:45:23 <Cale> You can use (+(-1))
13:45:26 <acowley> subtract 1 may be what you want
13:45:29 <Cale> or subtract 1
13:45:38 <ion> @type [(subtract 1, subtract 1)] :: [(Integer -> Integer, Integer -> Integer)]
13:45:40 <lambdabot> [(Integer -> Integer, Integer -> Integer)]
13:46:15 <Chathurga> Ah thanks, I think I'll do +(-1) for brevity, damn you ambigious -
13:47:15 <elliott> (+(-1)) is confusing.
13:47:48 <ion> I’d never use (+(-1)).
13:48:06 <ion> It’s even worse than the special rule for (-n). :-P
13:48:42 <CuteAngel24> :t (+ -1)
13:48:43 <lambdabot>     The operator `+' [infixl 6] of a section
13:48:44 <lambdabot>         must have lower precedence than that of the operand,
13:48:44 <lambdabot>           namely prefix `-' [infixl 6]
13:49:01 <CuteAngel24> :t (+negate 1)
13:49:02 <lambdabot> Num a => a -> a
13:49:16 <Cale> ion: ?
13:49:20 <Yuu-chan> :t (-(+1))
13:49:21 <lambdabot> (Num a, Num (a -> a)) => a -> a
13:49:36 <Cale> (+(-1)) makes sense to me...
13:49:39 <Chathurga> It's only for a euler problem, since there's 8 cells describing all directions from a point, subtract would be too long. And I don't find + (-1) confusing personally
13:50:35 <rwbarton> why not just make a list of offsets (Int,Int)
13:50:43 <CuteAngel24> :t (-1+)
13:50:44 <lambdabot> Num a => a -> a
13:52:08 <acowley> We are getting so close to having ¯\(°_o)/¯ as a useful operator
13:52:13 <Chathurga> rwbarton: Oh... yeah. That makes more sense. The things I miss...
13:52:30 <ion> @quote mappend
13:52:31 <lambdabot> elliott says: |\/|/-\|-|-|=|\||} is my preferred mappend operator
13:52:38 <ion> Alas, that’s invalid. :-(
13:52:56 <ion> |\/|/-\|-|-|=|\||>
13:53:42 <elliott> that looks even less like "MAPPEND" :P
13:53:55 <elliott> is that one actually valid?
13:54:04 <elliott> > let (|\/|/-\|-|-|=|\||>) = mappend in [1,2] |\/|/-\|-|-|=|\||> [3,4]
13:54:05 <lambdabot>   [1,2,3,4]
13:54:13 <elliott> nice
14:00:56 <acowley> Take *that*, readability!
14:02:19 <eacameron> Is liftA2 basically just <$> for binary functions?
14:02:25 <eacameron> :t liftA2
14:02:27 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
14:02:31 <eacameron> :t (<$>)
14:02:32 <lambdabot> Functor f => (a -> b) -> f a -> f b
14:02:46 <Cale> eacameron: It's reasonable to look at it that way
14:03:06 <parcs`> > fix (\x -> In [x]) -- beaky
14:03:08 <lambdabot>   In [In [In [In [In [In [In [In [In [In [In [In [In [In [In [In [In [In [In ...
14:03:28 <parcs`> @src mU
14:03:28 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
14:03:30 <parcs`> @src Mu
14:03:31 <lambdabot> newtype Mu f = In { out :: f (Mu f) }
14:03:35 <acowley> :t \f a b -> f <$> a <*> b
14:03:36 <lambdabot> Applicative f => (a1 -> a -> b) -> f a1 -> f a -> f b
14:03:57 <eacameron> Cale: cool
14:04:14 <eacameron> acowley: is that liftA2?
14:04:15 <S11001001> parcs`: where is Mu defined?
14:04:28 <elliott> S11001001: Data.Functor in the Caleskell report
14:04:34 <c_wraith> hah
14:04:52 <acowley> eacameron: Effectively, yes. Using <$> and <*> scales very nicely.
14:05:15 <acowley> eacameron: liftA2 and its ilk are good for when you plan on partially applying
14:07:04 <acowley> That said, it helps when you get used to reading "<$>" and "<*>" as " "
14:07:05 * hackagebot Diff 0.2.0 - O(ND) diff algorithm in haskell.  http://hackage.haskell.org/package/Diff-0.2.0 (SterlingClover)
14:07:10 <eacameron> acowley: I just read O'Sullivan's blog post on getting Applicative by example. He used liftA2 a lot and it seemed that <$>...<*> would be more readable
14:07:16 <eacameron> acowley: I was just curious
14:07:33 <fmap> :t \f a b -> liftA2 ($) (f <$> a) b
14:07:35 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
14:07:56 <parcs`> S11001001: dunno
14:08:16 <Peaker> :t liftA2 id
14:08:17 <lambdabot> Applicative f => f (b -> c) -> f b -> f c
14:08:42 <acowley> I think Applicative is pretty gorgeous, and so really like using <$> and <*> to generalize regular function application.
14:08:56 <Peaker> liftA2 is nice when you're points-free
14:09:00 <acowley> yeah
14:09:02 <Peaker> or when you're penetrating multiple applicatives
14:09:07 <Peaker> (liftA2 . liftA2 . liftA2) ...
14:19:53 <paczesiowa> is it possible to install libraries depending on zlib with profiling enabled?
14:22:47 <acowley> reinstall zlib with profiling enabled first
14:23:12 <paczesiowa> acowley: I've installed everything with --ghc-options="-prof -auto-all"
14:23:47 <acowley> I think that's just for executable profiling
14:24:19 <acowley> I think you'd want -enable-library-profiling. But more useful is to edit ~/.cabal/config to enable library profiling by default.
14:24:26 <paczesiowa> acowley: also, there's library-profiling: True in cabal's config
14:26:25 <paczesiowa> the problem is always in modules using TH
14:26:27 <acowley> then I'd guess you just need to reinstall zlib
14:27:03 <acowley> I'm not sure of an easy way to check if the profiling library is installed other than just looking for it. On my machine, it's in ~/.cabal/lib/zlib-0.5.4.0/ghc-7.6.1
14:28:32 <paczesiowa> I've got there things like: HSzlib-0.5.3.1.o  libHSzlib-0.5.3.1.a  libHSzlib-0.5.3.1_p.a
14:28:54 <paczesiowa> but ghc still picks the wrong, non-profile-enabled version: http://pastebin.com/Qw5TVwdg
14:30:24 <rwbarton> what if you cabal install --enable-excutable-profiling instead
14:31:52 <acowley> uhoh: http://hackage.haskell.org/trac/ghc/ticket/4899
14:32:08 <paczesiowa> rwbarton: I'll check, compilation takes about 10-15min
14:34:03 <rwbarton> I've built an executable that depends (indirectly) on zlib and uses TH with --enable-executable-profiling and I didn't have any problems
14:34:52 <paczesiowa> acowley: I've seen that and it helped with compiling custom code (using ghc), but I have problems with installing packages using cabal-install
14:35:18 <acowley> I don't really understand why I haven't run into this myself
14:35:51 <paczesiowa> rwbarton: was that indirection happstack perhaps?
14:36:01 <rwbarton> no, it was zlib-bindings
14:36:13 <rwbarton> which I used directly
14:36:17 <paczesiowa> :/
14:48:33 <tel> Are there any Haskell meetups in the midatlantic? DC/Baltimore/Phily?
14:50:53 <byorgey> tel: we've hosted a Haskell hackathon at UPenn in Philly every summer for the past few years
14:51:07 <byorgey> I've never heard of anything in DC or Baltimore
14:51:19 <byorgey> but maybe you're talking about something more regular than once a year =)
14:51:35 <ocharles> tibbe: did I spell your name right today? ;)
14:51:56 <byorgey> tel: there's philly lambda: http://phillylambda.org/
14:52:06 <byorgey> not Haskell specific but many Haskell enthusiasts show up there
14:52:20 <alpounet> ocharles, "you're application" => your application
14:52:29 <tel> byorgey: I'm actually in Baltimore and spend much more time in DC than Philly, so I hadn't really looked out for stuff there yet—cool!
14:52:52 <tibbe> ocharles: I will have to check! :D
14:53:18 <tibbe> ocharles: 100 points for accuracy :)
14:53:35 <ocharles> alpounet: thanks :)
14:53:53 <tel> In particular I'm running a startup—for now—in Baltimore and trying hard to see if it's possible to hire for Haskell
14:53:57 <ocharles> tibbe: it turns out my tablet corrects Johan to Johann. so i've conclude it's designed to embarass me
14:54:11 <tibbe> ocharles: ah yes, the incorrect German spelling
14:54:19 <tibbe> everyone know that Johan is the correct way to spell Johan
14:54:48 <Canar> Yochanan
14:54:52 <Canar> the original
14:54:55 <ocharles> alpounet: ok, pushed
14:55:28 <alpounet> ocharles, cool. glad that you talked about ekg btw, loved that package
14:55:30 <tibbe> ocharles: nice blog post
14:56:57 <paczesiowa> rwbarton: --enable-executable-profiling didn't help:(
14:57:49 <ocharles> tibbe: thanks, great package too :) need to talk to you about rebundling it as a snaplet at some point too
14:58:00 <ocharles> tibbe: so you can embed it in any snap website without having it on a separate port
14:58:04 <ocharles> but alas. lack of free time, etc
14:59:10 <acowley> ocharles: s/packages/package in the link to EKG on hackage
14:59:19 <ocharles> oops
14:59:36 <ocharles> correctified. thanks acowley
14:59:46 <ocharles> work and a haskell meetup has weakened my proofing skills :(
15:06:04 <Peaker> I have a Library and Executable both defined in same .cabal file. The executable depends on the same library. However, when building it, it tries to import stuff directly by relative path rather than from the compiled package
15:06:29 <acowley> Peaker: Put the executable source in a different source directory
15:07:04 <acowley> Peaker: I use things like src/Foo/MyLib.hs and src/executable/Main.hs. The library needs -isrc, while the exe needs -isrc/executable
15:07:05 <Peaker> acowley, I did, with Main-is:  demo/example.hs, but it's still finding the library's modules by their paths relative to root, I know because it manages to import the lib even if I remove it from the Build-depends
15:07:15 <tibbe> ocharles: I want to do that
15:07:31 <tibbe> ocharles: I want to break the package apart so lower level things can define counters without depending on snap
15:07:40 <acowley> Peaker: is the .cabal file anywhere public?
15:07:54 <tibbe> ocharles: and then have a top-level convenience package that works like the current API (i.e. one-liner)
15:08:02 <Peaker> acowley, not in its current form.. trying to put the lib in hs-source-dirs too
15:08:10 <Peaker> now it looks good
15:08:23 <Peaker> if the lib is in the package root -- the executable finds it, even if the exec is somewhere else
15:08:35 <fsalingen> Hi all, i'm want to do an offline debug trace; here http://www.haskell.org/haskellwiki/Debugging it says Hat, but Hat seems gone. What is the preferred way to do an offline trace so I can analyze?
15:09:04 <jackss> do you guys use the new ghc if syntax? or do you prefer to stay portable?
15:10:03 <ocharles> tibbe: sounds good!
15:10:17 <tibbe> ocharles: except I'm short on time as usual
15:10:22 <tibbe> ocharles: trying to get some GHC changes in
15:10:46 <AfC> jackss: GHC is portable :)
15:10:58 <jackss> true :)
15:16:32 <startling> so how do I run (runGet (get :: Get s)) for some as-of-yet-undetermined s?
15:16:55 <startling> I want to automate unit-testing of my Serialize types.
15:25:47 <dsantiago> Is cabal-dev soon to be folded into cabal? This post makes it sound like it, but I haven't seen anything about it being released. http://blog.johantibell.com/2012/08/you-can-soon-play-in-cabal-sandbox.html
15:26:30 <byorgey> dsantiago: yes, but it's not released yet
15:27:04 <alpounet> dsantiago, it'll be released soon, although cabal's sandboxes are going to be better than cabal-dev's
15:27:34 <dsantiago> OK, cool.
15:38:46 <epta> What data structure is convinient to keep list of Bit?
15:39:13 <shachaf> How big is the list?
15:40:08 <epta> Not big, about 30 bits long
15:40:20 <shachaf> You would use Word32. :-)
15:40:29 <shachaf> Er, s/w/c/
15:40:43 <shachaf> Curse you, English.
15:41:52 <elliott> and there's even a typeclass for working with them (Bits)
15:42:13 <epta> And Word32 have a Bits instance. Ok
15:43:12 <epta> But how can I get Word32 value from "010101010"::String?
15:43:31 <shachaf> That's a different question. :-)
15:43:32 <Botje> :t readIntAtBase
15:43:33 <lambdabot> Not in scope: `readIntAtBase'
15:43:41 <Botje> or something like that.
15:44:45 <acowley> :t readInt
15:44:46 <lambdabot> Num a => a -> (Char -> Bool) -> (Char -> Int) -> ReadS a
15:44:59 <Botje> or just that, heh.
15:50:46 <epta> acowley: I don't get how to use it to read something from String
15:51:42 <cmccann> epta, ReadS a = String -> [(a, String)]
15:53:34 <epta> > readInt 2 (const True) (\case '0' -> 0; '1' -> 1) "010101"
15:53:35 <acowley> > readInt 2 (`elem` ['0','1']) digitToInt "1011"
15:53:36 <lambdabot>   <hint>:1:26: parse error on input `case'
15:53:37 <lambdabot>   [(11,"")]
15:53:53 <epta> Lambdabot dunno about lambdacase?
15:54:11 <FireFly> > readInt 2 (`elem` "01") digitToInt "101123"
15:54:13 <lambdabot>   [(11,"23")]
15:54:19 <FireFly> I see
15:55:19 <acowley> I notice cabal-dev on hackage doesn't support the current Cabal. Is using Cabal and cabal-install from github the best bet for sandboxed builds right now?
15:55:44 <epta> At least it works
15:56:09 <epta> And `cabal-dev ghci` works well, insted of hackage version
15:56:51 <epta> FireFly: but what is wrong with '0'?
15:57:39 <FireFly> epta: hm?
15:57:49 <FireFly> 1011b parses as 11 dec
15:58:08 <cmccann> Chathurga, you around?
15:58:16 <Chathurga> Hey, yup
15:58:40 <cmccann> I uploaded the first (semi-functional) pile of codegen stuff for fay
15:58:53 <cmccann> if you're still interested
15:59:02 <epta> FireFly: oh, thanks
15:59:09 <mceier> Is it possible to create 'p = q - r' parser using parsec ? Parser p should match the input only if parser q matches the input and parser r doesn't match the same input.
16:00:18 <cmccann> mceier, use "notFollowedBy r" first?
16:00:41 <cmccann> that will try r, then fail if r succeeds
16:00:46 <mceier> oh, thanks ;)
16:00:47 <cmccann> which may or may not be what you want
16:01:07 <mceier> I will check it, but I think that's the solution ;)
16:01:13 <cmccann> e.g. doesn't guarantee that q and r match the same input
16:02:54 <Chathurga> cmccann: Yeah lemme at it :D
16:03:02 <cmccann> mceier, so you couldn't do something like "match zero or more times, except not four" and have p succeed matching five times, stuff like that
16:03:11 <cmccann> Chathurga, https://github.com/isomorphism/fay-bindings
16:03:33 <cmccann> be warned that compiling or loading those in ghci is... slow
16:03:43 <neutrino_> hi
16:04:02 <neutrino_> sclv_: did you manage to get tf working?
16:04:16 <cmccann> Chathurga, a scattering of things are missing or known-broken still
16:04:19 <mceier> cmccann: ok, so it's not what I need ... it should accept five times, but not exactly 4
16:04:22 <shachaf> cmccann: What, it's slow?
16:04:27 <shachaf> You ought to file a GHC bug!
16:04:31 <cmccann> shachaf, YOU'RE slow >:[
16:04:35 <Chathurga> cmccann: Have you ever checked out elm just as a btw
16:04:58 <cmccann> nah, decided I liked the idea of fay better for quick tinkering
16:04:59 <mceier> cmccann: notFollowedBy (r <* eof) -- could this work ?
16:05:08 <Chathurga> I don't want to go that route because it isn't haskell but it looks interesting
16:05:17 <cmccann> mceier, if you only care about matching the rest of the file, sure
16:05:37 <cmccann> there might still be some corner cases depending on the exact parsers used?
16:05:54 <cmccann> mceier, it's not a very robust way to express what you want, but it should work in many cases
16:05:55 <mceier> ok ;)
16:06:03 <mceier> thanks :)
16:06:44 <cmccann> Chathurga, my reasoning is that with fay I can easily jump ship to a proper haskell->js compiler without major code changes
16:07:03 <Chathurga> Yeah hopefully
16:07:05 <cmccann> so it's easy to pick up and tinker with, and doesn't limit my future options as much
16:07:08 <Chathurga> Did you write allt his o.o
16:07:12 <Chathurga> *all this
16:07:18 <cmccann> no, it's generated code
16:07:29 <cmccann> I wrote a ugly hack of a boilerplate-o-matic program
16:07:35 <cmccann> that generated all that from the W3C's IDL files
16:07:35 <Chathurga> ah right, very nice in that case
16:07:42 <Chathurga> Good idea
16:07:54 <cmccann> cf. http://www.w3.org/TR/
16:08:15 <cmccann> I picked a random assortment of things to test with beyond the stuff I specifically wanted
16:08:56 <cmccann> right now all the codegen really handles are interfaces (mostly associated with element types) and their properties/methods
16:09:11 <cmccann> standalone constructors and constant values are notably absent
16:09:16 <cmccann> as well as some other whatnot
16:10:07 <cmccann> so when I tested the audio element I still needed to write an ffi call for "new Audio()" returning an HTMLAudioElement
16:10:20 <cmccann> the element type being defined in the Html5 module
16:10:31 <dagnachew> hi all
16:10:33 <cmccann> along with the methods
16:11:03 <cmccann> currently I'm tinkering with the CSS and canvas stuff before going back to clean up the codegen
16:11:13 <dagnachew> cant install ltk dep for the haskell ide leksah http://pastie.org/5513706
16:11:30 <scientes> :l +Text.Regex isn't working
16:11:35 <scientes> i'm on debian armhf
16:11:42 <scientes> (but don't really know haskell)
16:11:54 <cmccann> Chahurga, got disconnected?
16:12:05 <Chahurga> yeah my net drops randomly, very fun
16:12:26 <Cale> scientes: Try :m + Text.Regex
16:13:07 <cmccann> Chahurga, what's the last you saw me say?
16:13:09 <Chahurga> This looks really good for getting over that initial hump. The idea of overriding the disgusting and inconsistent DOM interface sounds like a dream
16:13:14 <donri> or simply, import Text.Regex
16:13:19 <Chahurga> The thing about "new Audio()"
16:13:28 <dagnachew> plz help I get this error while tying to install ltk package http://pastie.org/5513706
16:13:58 <cmccann> Chahurga, ok. the HTMLAudioElement type is defined in the Html5 module along with its methods, just the constructor is missing
16:14:00 <dagnachew> byorgey, you there
16:14:07 <cmccann> currently I'm tinkering with the CSS and canvas stuff before going back to clean up the codegen
16:14:15 <scientes>     Could not find module `Text.Regex'
16:14:31 <Cale> scientes: Then you probably don't have the regex-base package installed
16:14:33 <cmccann> and trust me, the DOM API is still inconsistent and disgusting
16:14:33 <scientes> would i need a package for the binding?
16:14:40 <Chathurga> cmccann: I see, still good work so far
16:14:46 <cmccann> that's part of why Html5.hs is 8000 lines long
16:14:58 <Chathurga> cmccann: but imagine we can cleanly custom overwrite certain parts :D
16:15:06 <cmccann> because I handle overloaded method names by generating a typeclass each :[
16:15:06 <Cale> scientes: You'll need at least regex-base and one of the associated packages like regex-posix
16:15:44 <Cale> dagnachew: That means that ltk hasn't been updated for the latest Control.Exception, most likely.
16:15:47 <cmccann> yeah, long-term plan would be to tweak some things and make a similar but nicer API
16:16:09 <jackss> what are good libraries for web scraping?
16:16:14 <Chathurga> The DOM is based in some Java fueled orgy of JSs past
16:16:25 <Cale> jackss: tagsoup
16:16:26 <dagnachew> ok
16:17:03 <jackss> tagsoup for parsing. what about a web client?
16:17:07 * hackagebot clckwrks 0.13.2 - A secure, reliable content management system (CMS) and blogging platform  http://hackage.haskell.org/package/clckwrks-0.13.2 (JeremyShaw)
16:17:22 <Chathurga> cmccann: This will go down really well when you release it, very good idea
16:17:24 <scientes> oh damn
16:17:35 <Cale> dagnachew: 0.8.0.6 is a very old version
16:17:36 <cmccann> Chathurga, yeah, but fixing it will require manual intervention. for now, I'm just trying to autogenerate something comprehensive
16:17:39 <scientes> i can't install regex-base from debian because i need experimental ghc for ghc
16:17:43 <scientes> *ghci (on arm)
16:17:47 <Chathurga> oh yeah totally
16:18:02 <Cale> dagnachew: Maybe try installing ltk-0.12.1.0
16:18:12 <scientes> lmao
16:18:19 <scientes> and they are both 7.4
16:18:38 <dagnachew> Cale, cabal install ltk-0.12.1.0 like this ?
16:18:43 <Cale> dagnachew: yeah
16:18:43 <cmccann> Chathurga, feel free to use what's there now if you want to experiment. the naming scheme I use will stay the same so even when I rework the codegen it shouldn't break things much
16:18:56 <Cale> dagnachew: and/or remember to cabal update before cabal install
16:19:10 <dagnachew> oic
16:19:43 <Chathurga> we're doing a web dev module next semester, no one know even HTML, never mind Haskell. I could bring my teammates to tears with this
16:19:52 <cmccann> haha
16:21:27 <alpounet> Chathurga, are you going to study php as part of this module?
16:22:19 <zomg> You should rewrite PHP 1.0 in Haskell with Network.CGI!
16:22:35 <dagnachew> Cale, I did cabal unpack ltk ; cd ltk-.. ; then cabal update ; then cabal install http://old.pastie.org/5513746
16:23:18 <Cale> dagnachew: Ah, I see, your ghc is too new for this package.
16:23:41 <Cale> dagnachew: You could try weakening the upper bound on the base package version in the .cabal file
16:23:42 <dagnachew> cale so no haskell ide beside eclipse
16:23:48 <gienah> dagnachew: a hopefully temporary situation: leksah is very difficult to install with ghc 7.6.1 as the upstream updates that fix this are interleaved with updates that depend on the unreleased gtk2hs gtk3
16:24:06 <dagnachew> ok
16:24:10 <Cale> dagnachew: There's no IDE which a significant number of people actually use, let's put it that way.
16:24:17 <scientes> too new!
16:24:24 <scientes> what happened to backwards compat?
16:24:41 <gienah> dagnachew: there are 2 solutions at the moment: (1) build everything from darcs starting with gtk2hs patched for gtk3
16:24:54 <Cale> scientes: There are hard upper bounds on version numbers in most .cabal files because hackage will whine at you if you don't put some in.
16:25:01 <gienah> dagnachew: (2) apply the patches from the gentoo haskell overlay
16:25:41 <Cale> scientes: So even if the package might build okay with version 4.6 of base, cabal won't install it because that's what the version constraint says.
16:26:20 <Cale> Also, backward compatibility is not generally the highest priority
16:26:32 <Cale> (in general, in the Haskell ecosystem)
16:26:53 * eikke wonders whether Bos' changes to Hashable to be merged into tibbe/master are created during or outside business hours :P
16:26:55 <dagnachew> gienah, do you think soon there will be a proper package we can install as usual ?
16:27:04 <gienah> one the leksah devs needs gtk2hs gtk3 to run on his hardware
16:27:20 <tibbe> eikke: outside of course
16:27:26 <gienah> dagnachew: probably judging by the activity in leksah upstream
16:27:35 <tibbe> eikke: by an incredibly efficient individual ;)
16:27:37 <Cale> gienah: I can't parse what you said just there about gtk3
16:27:58 <eikke> tibbe: maybe hashable will be part of some very secret to-be-announced FB project...
16:28:15 <zomg> I'm sort of doing some drafting for a haskell for web developers type articles/ebook... in the style of jump right in and actually do something useful instead of learn hundred hours of functional programming puzzles first...
16:28:37 <zomg> In fact CGI programming might show up right after the basics =)
16:28:42 <gienah> Cale: there are patches for gtk2hs for gtk3 - this changes the API, and leksah on github is using these, because gtk2 has problems on some hardware with high resolution screens
16:28:56 <zomg> Not sure if anything will come of it though, it might be something that simply won't work due to haskell's complexity
16:28:59 <Cale> ah, okay
16:29:12 <zomg> and that you would need to actually understand things a bit better before you can jump into doing something "bigger"
16:29:48 <Chathurga> zomg: That sounds interesting, would give that a look
16:30:12 <gienah> a leksah dev patched gtk2hs for gtk3: http://www.mail-archive.com/gtk2hs-devel@lists.sourceforge.net/msg01248.html
16:30:44 <tibbe> eikke: maybe ;)
16:30:58 <gienah> alon with peter and maybe some other devs
16:30:59 <jmcarthur> neutrino_, dmwit: "price: float" is what we actually use. it's well defended. we also have some floating point gurus, which helps.
16:31:02 <zomg> Chathurga: yeah that would be nice. I shall buzz you about it once I actually have something worth looking at
16:31:39 <shachaf> jmcarthur: "price: float"? For what?
16:31:51 <jmcarthur> shachaf: almost everything!
16:32:05 <Chathurga> Sweet, that sounds like my path so it would suit me
16:32:09 <shachaf> Hmm, that doesn't sound good...
16:35:32 <startling> @hoogle Applicative f => Int -> f a -> f [a]
16:35:33 <lambdabot> Control.Monad replicateM :: Monad m => Int -> m a -> m [a]
16:35:33 <lambdabot> Test.QuickCheck.Gen vectorOf :: Int -> Gen a -> Gen [a]
16:35:33 <lambdabot> Test.QuickCheck vectorOf :: Int -> Gen a -> Gen [a]
16:35:35 <jmcarthur> i should see if i can share some slides that one of my coworkers put together on what guarantees floating point gives you and why price : float is acceptable
16:36:05 <jmcarthur> he's a lot more comfortable with explaining such things than i am. i wouldn't be good at defending it
16:36:51 * alpounet would be interested in these slides
16:38:07 * cmccann is not smart enough to use floating point correctly
16:38:28 <acowley> jmcarthur: That would be really appreciated!
16:39:03 <parcs`> "False on two accounts. First, even Haskell and Lisp programmers shun recursion in production code." oh, proggit :)
16:39:11 <jmcarthur> lol
16:40:01 <acowley> parcs`: How negative is the comment karma?
16:40:16 <elliott> I predict a positive kind of negative
16:40:18 <simon> jmcarthur I'd like those slides as well.
16:41:00 <napping> is that like price as in stock pricing, or as in charging people money?
16:41:16 <jmcarthur> as in stock pricing
16:41:16 <cmccann> the important thing to realize about proggit is that it's full of the kind of people who would rather post on reddit than be coding
16:41:38 <jmcarthur> i should qualify that the claim only holds for certain kinds of operations you might do
16:42:04 <napping> That's not so surprising then
16:42:09 <jmcarthur> right
16:42:19 <acowley> cmccann: That's why I only listen to blowhards on irc. It's truer to our roots.
16:42:22 <simon> I still can't imagine how or why. :)
16:42:22 <napping> plus, you can probably affort people like this coworker to do it right
16:43:19 <beaky> if haskell can steal any feature from any other programming language, what should it be?
16:43:34 <cmccann> acowley, oddly enough IRC is easier to selectively ignore
16:43:52 <cmccann> probably because you don't have any urge to sit there refreshing the page
16:44:10 <startling> is there a Gen for readable strings somewhere in QuickCheck?
16:44:25 <startling> I guess I want only letters.
16:45:44 <startling> oh, suchThat arbitrary isLetter
16:46:14 <Cale> beaky: Perhaps some features of the module systems of ML languages
16:46:27 <Cale> beaky: Or of course, dependent typing
16:46:40 <Cale> (from languages like Agda and Coq)
16:46:52 <beaky> ah
16:46:57 <hpc> Cale: definitely the latter; classes are getting to be as powerful as modules
16:47:08 <hpc> especially with their gradual first-classiness
16:47:08 * hackagebot Twofish 0.3 - An implementation of the Twofish Symmetric-key cipher.  http://hackage.haskell.org/package/Twofish-0.3 (RonLeisti)
16:47:14 <beaky> dependent typing seems neat
16:47:16 <jmcarthur> a decent module system is way up there on my list. we are "close enough" for dependent type stuff that it takes second place, to me.
16:47:47 <hpc> jmcarthur: do you mean decent in the ML sense or in the organizing code sense?
16:47:54 <napping> Coq and Agda have decent module systems
16:48:59 <jmcarthur> hpc: classes don't encapsulate anything and can't be parameterized on anything but types (and type constructors), and the only way to specify which instance you are using is by using the type it's parameterized on. for that matter, you can't define a class that isn't parameterized on anything
16:49:06 <jmcarthur> in the ML sense
16:49:07 <acowley> We need better type-directed interactive development
16:49:10 <acowley> holes are good
16:49:27 <acowley> and Coq's tactics have their upsides
16:50:19 <hpc> jmcarthur: we're getting a lot closer to that first point with dependent types; the last point i don't get what it gives us
16:51:06 <jmcarthur> hpc: it would be nice to be able to at least define local modules that encapsulate implementation details behind a more limited signature. classes don't offer anything like that
16:51:50 <hpc> like nested modules as an alternative to ".Internal" modules?
16:52:29 <jmcarthur> yes
16:52:41 <hpc> okay that would be awesome
16:52:44 <jmcarthur> (and if it's convenient, it will be used a lot more than .Internal modules are)
16:52:56 <hpc> but i see it as more a module thing than a class thing
16:53:07 <jmcarthur> classes and modules have a lot in common
16:53:37 <hpc> leaving the two separate i think would keep a nicer separation between "this is what code does" and "this is how i organized it"
16:53:39 <jmcarthur> here's another bit of awesomeness to consider
16:54:00 <hpc> because when those two mix my brain just shuts off
16:54:03 <jmcarthur> if we had module signatures, we could define the relationship between similar modules, like Data.ByteString and Data.ByteString.Lazy
16:54:09 <elliott> if you can nest your Internal module, you don't need it in the first place...
16:54:15 <elliott> since only one module uses it
16:54:40 <jmcarthur> with parameterized modules, you could even abstract over which of the two you are using instead of having to choose one to import
16:54:55 <jmcarthur> elliott: not quite true
16:55:13 <jmcarthur> elliott: a nested module can be used by any other module in the same module
16:55:19 <jmcarthur> elliott: not just one other
16:55:24 <elliott> well, ok
16:56:03 <jmcarthur> hpc: i think the only thing that potentially confuses those two things is first class modules
16:56:15 <jmcarthur> hpc: everything else is entirely static
16:56:55 <jmcarthur> module signatures could even be used at the package level
16:57:02 <jmcarthur> so that some packages might be interchangeable
16:57:57 <jmcarthur> that is, one package could provide the signature, and other packages could implement it
16:58:28 <jmcarthur> this is probably a bit less useful than just modules, but the idea has certainly come up a few times in ocaml circles
16:59:15 <hpc> yeah, i just want to be able to put different definitions in different files with a minimum of friction :P
16:59:30 <hpc> anything beyond that is frosting on a frosting cake
17:01:23 <jmcarthur> lolcathost: i read your name as lolocaust at first and was getting ready for the possibility of trolling
17:01:43 <lolcathost> Oh, no.
17:01:59 <lolcathost> jmcarthur: Sometimes I do troll, but I would not troll this channel.
17:02:10 <jmcarthur> :)
17:02:51 <acowley> ocaml doesn't have module signatures?
17:03:03 <alpounet> it does
17:03:08 <acowley> I thought so
17:03:34 <alpounet> module type FOO = sig ... end ;;
17:03:36 <acowley> SML has them, Coq has them… would be surprising for OCaml to lack them!
17:06:57 <jmcarthur> one thing i find odd about ocaml modules is that functors have a runtime cost :\
17:22:15 <alpounet> jmcarthur, whaaaaat?!
17:24:16 <jmcarthur> yeah
17:25:53 <alpounet> jmcarthur, only thing i see is no inlining accross functor boundaries
17:26:49 <jmcarthur> alpounet: modules in ocaml are actually objects in memory at runtime. functors are actually functions.
17:27:01 <jmcarthur> alpounet: this is why it was so easy for them to add first class modules
17:27:33 <jmcarthur> alpounet: of course, for most static code this isn't going to hurt anything
17:27:48 <jmcarthur> but the memory representation is still available for functors and first class modules
17:28:21 <startling> is there a thing somewhere that lets me read and write to a temporary file safely but doesn't let me do any other IO things?
17:28:35 <hpc> startling: use a newtype around IO
17:28:45 <startling> hpc: meh, I'll just use IO then
17:29:09 <simpson> startling: Make a Free subset of IO and then define yourFreeSubsetToIO?
17:29:15 <shachaf> hpc: Or your own IO type!
17:30:12 <alpounet> jmcarthur, meh, i wasn't expecting this (modules being objects in memory)...
17:30:28 <mm_freak> startling: see region I/O
17:31:09 <mm_freak> using it you can constrain yourself to writing to a specific file, including static checks that you won't write to the file after leaving the region
17:32:14 <startling> mm_freak: huh, interesting
17:41:42 <Luke> do you guys have a recommendations for http clients?
17:42:12 <hpc> @hoogle http
17:42:13 <lambdabot> package HTTP
17:42:13 <lambdabot> package http-date
17:42:13 <lambdabot> package http-enumerator
17:42:16 <mm_freak> Luke: client libraries for bots?
17:42:22 <hpc> (inb4 http-conduit)
17:42:33 <Luke> bots?
17:42:39 <Luke> no as an oauth2 client
17:42:51 <Luke> and I'm looking for a recommendation not search results =)
17:43:11 <hpc> well first you're gonna want https
17:43:14 <mm_freak> Luke: check out hackage, there are a number of ready-made OAuth libraries
17:43:19 <AfC> Luke: http-client is really the only reliable choice at this point.
17:43:44 <AfC> Luke: I foresee that changing soon, but talking about future tense libraries that don't exist is a bit pointless.
17:43:48 <AfC> bah
17:43:54 <hpc> the really painful part is going to be figuring out if you need oauth 1 or 2
17:43:54 <Luke> mm_freak: not oauth2
17:43:56 <AfC> Luke: http-conduit
17:44:05 <Luke> AfC: thanks
17:44:13 <Luke> I've looked at http-conduit, it's pretty heavy for what I want
17:44:16 <Mohammed> Hi, I need help with a haskell list
17:44:20 <AfC> Luke: yeah
17:44:28 <AfC> Luke: one of the many things I don't like about it
17:44:34 <Luke> did you mean http-conduit when you said http-client?
17:44:44 <Mohammed> I'm new to haskell and i don't know much about it but i need help with this question: In Haskell, dene the list of all multiples of 3 that are less than 100.
17:44:44 <AfC> Luke: yes
17:44:54 <Luke> AfC: i'm hoping for an io-streams based client but it's not too close =D
17:44:54 <sw2wolf> ,hoogle (<$>)
17:45:00 <Mohammed> In Haskell, define the list of all multiples of 3 that are less than 100.
17:45:11 <AfC> Luke: I'm certainly interested in that, for sure
17:45:27 <sw2wolf> In #lisp, ,clhs foo works great. How about this channel ?
17:45:28 <Hafydd> > [99,96,..]
17:45:29 <lambdabot>   <hint>:1:8: parse error on input `..'
17:45:30 <Luke> hpc: I know I need oauth2 client
17:45:34 <AfC> Luke: my personal pet project at the moment is to lightly refactor the Snap types so we can re-use their Request and Response
17:45:35 <Hafydd> > [99,96,...]
17:45:37 <lambdabot>   <hint>:1:11: parse error on input `]'
17:45:44 <hpc> Mohammed: the obnoxiously smug answer is "generate all multiples of 3 and take until you get above 100"
17:45:55 <Hafydd> > [99,96..]
17:45:56 <lambdabot>   [99,96,93,90,87,84,81,78,75,72,69,66,63,60,57,54,51,48,45,42,39,36,33,30,27...
17:45:57 <Luke> AfC: that'd be awesome
17:45:58 <hpc> Mohammed: ironically it's also the most useful answer
17:45:59 <Hafydd> There.
17:46:16 <hpc> > [0, 3..] -- all multiples of 3
17:46:17 <AfC> Luke: a fair bit of the material needed for a client library already exists in Snap.Test. Needs re-doing, but gave me some good ideas.
17:46:18 <lambdabot>   [0,3,6,9,12,15,18,21,24,27,30,33,36,39,42,45,48,51,54,57,60,63,66,69,72,75,...
17:46:27 <Mohammed> just input the numbers one by one?? Is there a loop i can use? sorry im completely new to this language
17:46:28 <hpc> > takeWhile (< 100) [1, 3..]
17:46:29 <Hafydd> What about -2?
17:46:30 <lambdabot>   [1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,5...
17:46:33 <Hafydd> What about -3, I mean.
17:46:38 <hpc> > takeWhile (< 100) [0, 3..] -- er
17:46:40 <lambdabot>   [0,3,6,9,12,15,18,21,24,27,30,33,36,39,42,45,48,51,54,57,60,63,66,69,72,75,...
17:46:56 <Martty> takeWhile.. shouldnt it be takeIf?
17:47:02 <Martty> or is that a different take
17:47:06 <LordBrain> > [0, 3 .. 99]
17:47:07 <AfC> Anyway, future tense until it isn't, and if someone beats me to it I won't be ashamed.
17:47:07 <lambdabot>   [0,3,6,9,12,15,18,21,24,27,30,33,36,39,42,45,48,51,54,57,60,63,66,69,72,75,...
17:47:09 * hackagebot iteratee-compress 0.3.3.0 - Enumeratees for compressing and decompressing streams  http://hackage.haskell.org/package/iteratee-compress-0.3.3.0 (JohnLato)
17:47:15 <Martty> > filter (<100) [0, 3..]
17:47:16 <Mohammed> Thanks guys!
17:47:19 <lambdabot>   mueval-core: Time limit exceeded
17:47:20 <Luke> AfC: you're aware greg's rewriting the snap http server right?
17:47:22 <Martty> ah right
17:47:25 <hpc> LordBrain: omg
17:47:29 * hpc falls on his sword
17:47:36 <AfC> Luke: yes
17:47:44 <Hafydd> If you mean positive or non-negative multiples of 3, that's a different matter.
17:47:50 <AfC> Luke: I'm working against those branches
17:47:58 <Luke> cool
17:48:45 <Mohammed> Also another question if you guys don't mind..
17:48:49 <Mohammed> .In Haskell, define the list of all numbers that are products of even integers and odd integers.
17:49:01 * AfC → beach
17:49:12 <acowley> Mohammed: Is this homework?
17:49:36 <Luke> anyway AfC you think http-conduit's the only serious one at this point?
17:49:38 <Mohammed> trying to solve part of it
17:49:49 <Luke> damn
17:50:06 <Hafydd> Mohammed: have you even looked up Haskell's syntax?
17:50:44 <Luke> Hafydd: lets be nice to newcomers
17:51:02 <Mohammed> I looked at it but couldn't figure out what I need. Plus I couldn't install the compiler on this machine
17:51:17 <acowley> Mohammed: You should start by getting the compiler installed
17:51:23 <LordBrain> hpc, i just tried it in ghci and [0,3..100] also works.
17:51:44 <hpc> LordBrain: yeah, i completely forgot you could enumFromTo
17:51:45 <acowley> Mohammed: Playing with the type checker is an important part of learning Haskell
17:51:58 <hpc> i am just THAT comfortable with making infinite lists
17:53:29 <Hafydd> Every even integer is the product of an odd integer and an even integer, and no odd integer is the product of an odd integer an an even integer, so you want the list of all even integers -- but that's not entirely trivial, if you also want the negative ones.
17:54:12 <Mohammed> No i'm just wondering about the positive values
17:54:15 <mm_freak> Luke: you didn't look close enough
17:54:20 <Hafydd> > intersperse [-2,-4..] [0,2..]
17:54:22 <lambdabot>   No instances for (GHC.Enum.Enum [t0], GHC.Num.Num [t0])
17:54:22 <lambdabot>    arising from a u...
17:54:29 <Luke> mm_freak: ?
17:54:34 <mm_freak> there is an OAuth2 library…  i don't know if it's good, but there is one
17:54:42 <Hafydd> Oh, whoops..
17:54:49 <Luke> mm_freak: i did look hard enough. it doesn't support bearer auth in the headers
17:55:05 <Luke> mm_freak: i wasn't a fan of it's implementation either
17:55:11 <mm_freak> ok
17:55:44 <Luke> so yeah, I looked unfortunately
17:56:19 <Luke> i'm just going to write my own but I want a solid and simple http client to base it on
17:56:42 <Luke> as hpc's search pointed out, there's a number of http clients on hackage
17:57:13 <Luke> i know the conduit version but it's pretty heavy duty. i'm hoping someone has some positive experience with a lighter client
17:57:29 <Mohammed> takeWhile (< 100) [0, 2..] -- er
17:57:35 <Hafydd> > [(n `div` 2) * (-1)^(n `mod` 2) | n <- [0..]]
17:57:35 <Mohammed> Is this the right syntax for an even number list?
17:57:36 <lambdabot>   [0,0,1,-1,2,-2,3,-3,4,-4,5,-5,6,-6,7,-7,8,-8,9,-9,10,-10,11,-11,12,-12,13,-...
17:57:57 <Hafydd> Well, that demonstrates the principle.
17:58:06 <hpc> > takeWhile (< 100) [0, 2..] -- Mohammed: try it! start a haskell expression with "> " to see it evaluated
17:58:08 <lambdabot>   [0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,5...
17:58:45 <Mohammed> ok i will
17:59:20 <sw2wolf> hoogle fmap
17:59:53 <Hafydd> > concat [ [n, -n-1] | n <- [0..] ]
17:59:55 <lambdabot>   [0,-1,1,-2,2,-3,3,-4,4,-5,5,-6,6,-7,7,-8,8,-9,9,-10,10,-11,11,-12,12,-13,13...
18:00:12 <Hafydd> > map (*2) $ concat [ [n, -n-1] | n <- [0..] ]
18:00:13 <lambdabot>   [0,-2,2,-4,4,-6,6,-8,8,-10,10,-12,12,-14,14,-16,16,-18,18,-20,20,-22,22,-24...
18:00:19 <Hafydd> Huehue.
18:00:37 <hrumph> hi
18:00:58 <hrumph> csomeone showed me were some of the haskell source was can anyone tell me where that is again?
18:01:50 <hrumph> like the git repository or whatever it was
18:02:05 <acowley> Do you mean GHC?
18:02:09 * hackagebot monoid-extras 0.2.2.1 - Various extra monoid-related definitions and utilities  http://hackage.haskell.org/package/monoid-extras-0.2.2.1 (BrentYorgey)
18:02:44 <Hafydd> GHC's source is here: http://hackage.haskell.org/trac/ghc/browser
18:02:44 <acowley> As in, https://github.com/ghc/ghc
18:03:09 <hrumph> he showed me the code for the monad module
18:03:31 <hrumph> so i'm looking for module code specifically right now
18:03:51 <Hafydd> A reference implementation of the Prelude is in the language report: http://www.haskell.org/onlinereport/haskell2010/haskellch9.html#x16-1710009
18:05:24 <Hafydd> And GHC's library documentation includes links to the source: http://www.haskell.org/ghc/docs/latest/html/libraries/index.html
18:27:43 <tomberek> was wondering about composition operators in this pattern:   (.)   AND   (.).(.)   AND   (.).(.).(.)   etc.    can these be abstracted over? I've been trying, but i can only get it with liberal use of curry/uncurry
18:27:59 <hpc> :t (.:)
18:28:01 <lambdabot> (Functor g, Functor f) => (a -> b) -> f (g a) -> f (g b)
18:28:24 <shachaf> tomberek: Abstracted over how?
18:28:39 <hpc> tomberek: the ugly bit is in this abstraction, specifying how deep a particular use of it goes
18:28:42 <acowley> tomberek: Check out https://github.com/ekmett/lens/wiki/Derivation
18:28:51 <tomberek> shachaf: so only a single operator is needed
18:29:10 <shachaf> acowley: Y'all're unstoppable. :-(
18:29:13 <tomberek> acowley: that's what got me thinking about it
18:29:20 <shachaf> tomberek: Needed for what?
18:29:43 <tomberek> shachaf: i don't really have a need in mind, just an abstract thought
18:30:07 <hpc> shachaf: presumably to have something like fmap :: Nat -> (a -> b) -> MAGIC
18:30:22 <shachaf> hpc: Presuming won't make you happy.
18:30:30 <shachaf> tomberek: I mean: I don't understand what context you want to use this thing in.
18:30:34 <shachaf> Can you give an example?
18:31:17 <acowley> shachaf: I fixed a couple typos in that article today, so I'm in PR mode until midnight tonight! :P
18:31:25 <tomberek> shachaf, sure (==0) .@. (+) . (*2) .@. (*) . length .@. map                (i'm using (.) and (.@.)=(.).(.)    )
18:32:02 <shachaf> @ty (==0) .: (+) . (*2) .: (*) . length .: map
18:32:04 <lambdabot> (Eq (([a1] -> Int) -> [a1] -> Int), Num ([a1] -> Int), Num (([a1] -> Int) -> [a1] -> Int)) => (a1 -> a) -> (([a1] -> Int) -> [a1] -> Int) -> Bool
18:32:12 <shachaf> Um.
18:32:13 * elliott thinks you should not write code like this.
18:32:17 <tomberek> shachaf, it's tough to keep in track whether to use (.) or (.).(.) or the triple version, can these all be abstracted over?
18:32:22 <acowley> Needs more .
18:32:31 <tomberek> elliott: yeah, probably right, this is just a golfing expedition
18:32:44 <shachaf> tomberek: I think I can't read that snippet well enough to answer any questions about it.
18:32:47 <acowley> I got a fever, and the prescription is more .
18:32:50 <shachaf> Let's take a smaller example.
18:33:18 <tomberek> ok, (*) . length .: map
18:33:29 <shachaf> @ty (*) . length .: map
18:33:30 <lambdabot> Num ([a1] -> Int) => (a1 -> a) -> ([a1] -> Int) -> [a1] -> Int
18:33:40 <shachaf> Are you sure functions are numbers here?
18:34:07 <tomberek> actually, that's different than what I had in mind..   is (.:) the same as (.).(.)   ?
18:34:13 <hpc> yes
18:34:23 <hpc> (.:) is in fact, fmap fmap fmap
18:34:32 <shachaf> hpc: Yes, but that's just causing confusion and trouble here right now.
18:34:34 <hpc> (slightly more general but equal)
18:34:43 <shachaf> Cale! (.) = fmap is causing nothing but confusion and trouble right now.
18:34:55 <tomberek> what is the affinity of .: ?
18:35:13 <tomberek> @src (.:)
18:35:13 <lambdabot> Source not found. You speak an infinite deal of nothing
18:35:14 <shachaf> @ty ((*) . length) .: map
18:35:15 <lambdabot> (a1 -> a) -> [a1] -> Int -> Int
18:35:18 <copumpkin> tomberek: it prefers running on the first CPU
18:36:03 <tomberek> shachaf,,   i guess I have the infixl 8 set to (.).(.)
18:36:20 <shachaf> OK.
18:36:25 <ivanm> is there an inverse to Data.Vector.slice in that I can copy an array into part of another (assuming the second is large enough)?
18:36:27 <acowley> copumpkin: GPU accelerated high arity composition or bust.
18:36:35 <copumpkin> yup
18:36:42 <acowley> ivanm: copy?
18:36:43 <shachaf> @let infixl 8 .@.; f .@. g = \x y -> f (g x y)
18:36:45 <lambdabot>  Defined.
18:36:53 <shachaf> @ty (*) . length .@. map
18:36:55 <lambdabot> (a1 -> a) -> [a1] -> Int -> Int
18:37:06 <tomberek> shachaf:   yeah, nice lambdabot knowledge
18:37:07 <ivanm> acowley: that assumes both vectors are the same length
18:37:11 <shachaf> By the way, you should know that that code is pretty unreadable even as it is.
18:37:23 <shachaf> Unless I'm not good enough at this .@. thing.
18:37:24 <acowley> ivanm: Yeah, but you just slice the one that's too big to identify the region you want to use
18:37:28 <shachaf> But names aren't evil. :-)
18:37:28 <ivanm> I want to be able to say replace the last 5 values of a vector with the contents of another vector of length 5
18:37:46 <hpc> ivanm: vector slicing?
18:37:50 <tomberek> shachaf,,   yeah, once you get too point-free, it gets unreadable, I was just wondering theoretically
18:37:52 <shachaf> tomberek: Anyway, the issue with what you want in general is that functions don't have arities.
18:38:06 <acowley> copy (slice (n-5) 5 dst) src
18:38:14 <ivanm> acowley: oh, because the slice is a pointer to the original?
18:38:19 <acowley> ivanm: right
18:38:24 <ivanm> hmmmmm....
18:38:25 <copumpkin> ivanm: you could use update and zip with some index math
18:38:31 <acowley> ivanm: I do this all the time
18:38:47 <ivanm> copumpkin: yeah, that was something like what I was thinking of
18:38:56 <tomberek> shachaf:  i've been exploring forth recently,, and something like this could allow    (==) `dot` length `dot` map     but I can't come up with a way to abstract over (.) and (.@.)
18:39:21 <shachaf> COncatenative languages tend to do more point-free than Haskell (and differently).
18:39:43 <shachaf> tomberek: What do you expect id `magicDot` foo to expand to?
18:39:43 <tomberek> i'm not saying that it is readable or anything, i was just curious if it was possible
18:39:43 <hpc> in particular, they are side-effectful
18:39:44 <ivanm> acowley: that also works for pure vectors?
18:40:13 <acowley> ivanm: Not so much. copy is only for mutable vectors.
18:40:18 <tomberek> shachaf: id `magicDot` foo should equal foo
18:40:19 <hpc> ivanm: it'd be funny to write a tree-like structure that supported fast slices
18:40:23 <acowley> ivanm: But that kind of operation is a performance killer on pure vectors
18:40:31 <shachaf> tomberek: Should it equal id . foo or id .@. foo?
18:40:34 <ivanm> oh, right
18:41:05 <ivanm> I'm writing a library to abstract away using Map, Vector and MVector for Int-based lookups
18:41:34 <tomberek> shachaf: ideally, it would DoTheRightThing depending on foo.  if foo is *->*->* it would be .@.
18:41:51 <dasdada> das
18:41:55 <dasdada> hi
18:42:15 <hpc> tomberek: the tricky part is that you could be composing "larger" functions
18:42:25 <shachaf> tomberek: OK, what should id `magicDot` id exapnd to?
18:42:37 <hpc> :t ?f . (*)
18:42:38 <lambdabot> (?f::(a -> a) -> b, Num a) => a -> b
18:42:46 <alpounet> tomberek, hey!
18:42:52 <tomberek> hpc: yeah, around there is where my brain exploded and I was hoping #haskell could offer some genius thoughts
18:42:59 <hpc> :t ($) . (*)
18:43:01 <lambdabot> Num b => b -> b -> b
18:43:01 <tomberek> alpounet: hi there
18:43:17 <tomberek> shachaf: i guess id
18:43:25 <hpc> tomberek: i think you'll find that what you are looking for is impossible
18:43:28 <shachaf> tomberek: Please, with a lambda. :-)
18:43:40 <shachaf> (\x -> id1 (id2 x))?
18:43:43 <shachaf> (\x y -> id1 (id2 x y))?
18:43:49 <tomberek> hpc: that's what I thought, was hoping someone was smarter than me
18:44:16 * shachaf was hoping to explain why it would be impossible.
18:44:54 <hpc> shachaf: oh, continue
18:45:08 <tomberek> shachaf: crap, um....... i guess i want it to depend on x,, if x is *->*, the first one,   if x is *->*->*, the second one
18:45:10 <hpc> i was actually trying to come up with the ambiguity you're about to show :P
18:45:32 <hpc> tomberek: what if x is (printf "%s")?
18:45:35 <shachaf> tomberek: What's x?
18:45:51 <shachaf> tomberek: The thing is that id :: a -> a, and also id :: (a -> b) -> a -> b
18:46:00 <shachaf> Functions don't have "arities".
18:46:29 <hpc> or they do, of the "at least this arity" persuasion
18:46:43 <hpc> which is useless for this
18:47:20 <tomberek> shachaf: yeah, that's why i couldn't come up with a way to do this..... but I'm not super familiar with the new Kind promoting features, didn't know if one of those could apply
18:47:44 <tomberek> alpounet: what are you up to?
18:48:49 <ivanm> why are there so many functions for Vector that aren't available for MVector?
18:49:12 <acowley> ivanm: To encourage you to unsafeFreeze things left and right
18:49:27 <monochrom> hehe
18:50:01 <ivanm> so you're meant to do unsafeThaw . <pure stuff> . unsafeFreeze all the time? :/
18:50:23 <acowley> ivanm: No, I was joking. I actually do a heck of a lot of Vector.create
18:50:51 <ivanm> oh.... maybe I'm thinking of how to do this all wrong
18:51:11 <ivanm> I was planning on using mutable vectors throughout
18:51:15 <tomberek> shachaf, my attempt looked like:     > class Comp a where >     dot :: (b->c) -> (a->b) -> a -> c        and I would have an instance (overlapping probably) for a, a->b, a->b->c... and if a function matches a->b->c, pick that, otherwise step down to a "lower" arity
18:51:24 <acowley> ivanm: The disparity between Vector and MVector does trip me up periodically, so it's not that you're totally off course here
18:51:39 <ivanm> *nod*
18:52:06 <acowley> ivanm: One thing to remember is that you can do things like mapM_ (\i -> unsafeWrite blah blah) [0..6]
18:52:11 * hackagebot diagrams-core 0.6 - Core libraries for diagrams EDSL  http://hackage.haskell.org/package/diagrams-core-0.6 (BrentYorgey)
18:52:13 * hackagebot diagrams-lib 0.6 - Embedded domain-specific language for declarative graphics  http://hackage.haskell.org/package/diagrams-lib-0.6 (BrentYorgey)
18:52:20 <acowley> ivanm: It's not map, but it's not that far from imap, which is probably what you want
18:52:28 <shachaf> tomberek: Before writing the class you should have an idea of what it does to specific cases, like (id `dot` id). :-)
18:53:07 <ivanm> well, I'm currently writing a library to try and abstract away from using Map, Vector, MVector, etc. for Int-based lookup tables (within a monad for MVectors)
18:53:25 <ivanm> as my current code uses Map, but is embarrasingly slow compared to a really simple array-based C version
18:54:02 <tomberek> shachaf: those cases are what confused me and drove me here, i guess there's no way around them
18:54:08 <copumpkin> ivanm: how would you abstract over both mutable and immutable?
18:54:09 <ivanm> so I was going to use e.g. MVector (Maybe a) with the Maybe used to indicate if that value is actually used
18:54:17 <ivanm> copumpkin: it's all monadic
18:54:35 <copumpkin> oh, so it's all inside the MVector's prim monad?
18:54:37 <copumpkin> regardless
18:54:57 <ivanm> well, some Monad
18:55:05 <ivanm> for MVector it will be a PrimMonad
18:55:18 <copumpkin> hmm
18:57:11 * hackagebot diagrams-contrib 0.6 - Collection of user contributions to diagrams EDSL  http://hackage.haskell.org/package/diagrams-contrib-0.6 (BrentYorgey)
18:57:13 * hackagebot diagrams-svg 0.6 - SVG backend for diagrams drawing EDSL.  http://hackage.haskell.org/package/diagrams-svg-0.6 (BrentYorgey)
19:02:15 * hackagebot diagrams-cairo 0.6 - Cairo backend for diagrams drawing EDSL  http://hackage.haskell.org/package/diagrams-cairo-0.6 (BrentYorgey)
19:02:17 * hackagebot diagrams-builder 0.2.1.0 - hint-based build service for the diagrams graphics EDSL.  http://hackage.haskell.org/package/diagrams-builder-0.2.1.0 (BrentYorgey)
19:02:19 * hackagebot diagrams-gtk 0.6 - Backend for rendering diagrams directly to GTK windows  http://hackage.haskell.org/package/diagrams-gtk-0.6 (BrentYorgey)
19:02:21 * hackagebot diagrams 0.6 - Embedded domain-specific language for declarative vector graphics  http://hackage.haskell.org/package/diagrams-0.6 (BrentYorgey)
19:10:47 <ivanm> now that my brother has stopped yabbering to me on the phone...
19:11:07 <ivanm> so if I have an MVector (Maybe a), how would I go about finding the indices of all Just values?
19:11:34 <ivanm> is there any way of doing so without freezing? (as that seems to indicate that I can't use the MVector any more)
19:15:47 <Hafydd> @src MVector
19:15:48 <lambdabot> Source not found. :(
19:18:39 <ivanm> Hafydd: it's in Data.Vector.Mutable
19:19:00 <Nereid> ivanm: huh? freezing makes an immutable copy of the MVector.
19:19:37 <ivanm> Nereid: oh, right, I accidentally was reading the documentation of unsafeFreeze
19:19:43 <hrumph> what does the => operator mean. for instance Monad m => [m a] -> m [a]
19:19:50 <elliott> typeclass context
19:19:52 <hrumph> does that just alias m as Moad?
19:19:55 <elliott> no
19:19:55 <ivanm> hrumph: it specifies constraints
19:20:01 <ivanm> hrumph: it says m _must be_ a Monad
19:20:02 <Nereid> it's not an operator, it's a constraint thing
19:20:14 <Nereid> "if m is an instance of Monad, then you get a function [m a] -> m [a]"
19:20:30 <ivanm> "for any Monad m, this function takes a list of monadic actions and converts it into a monadic action that contains a list"
19:20:53 <cmccann> :k (=>)
19:20:54 <lambdabot> parse error on input `=>'
19:21:01 <cmccann> if it was an operator that would have worked!
19:21:05 <cmccann> what it would have done I'm not sure.
19:21:06 <elliott> (=>) :: Constraint -> k -> k
19:21:44 <Nereid> except not really
19:21:47 <cmccann> somehow that doesn't seem to capture what it actually means
19:21:49 <cmccann> :P
19:22:10 <Nereid> the two sides of => share some variables
19:22:25 <elliott> Nereid: you can say "Foo a a" too
19:22:29 <elliott> the forall is outside
19:22:43 <Nereid> oh I'm dumb.
19:22:44 <Nereid> yeah
19:23:59 <Nereid> and c => t is t if c is satisfied, and uninhabited otherwise. ignoring stuff about dictionaries.
19:24:15 <Nereid> ok
19:24:37 <cmccann> btw I'm pretty sure this isn't helping hrumph understand anything
19:24:41 <Nereid> does it even make sense for k not *?
19:24:44 <Nereid> oh, of course not.
19:24:47 <Nereid> :p
19:24:48 <cmccann> it's not even helping ME understand anything really
19:24:51 <hrumph> i'm reading about type classes now
19:24:58 <hrumph> i mean i googled for it and i'm reading
19:25:00 <Nereid> reading is good.
19:25:03 <shachaf> cmccann: Where do you think that discussion should take place?
19:25:20 <Nereid> hrumph: have you read LYAH? it has a chapter on them
19:25:29 <Nereid> well, two chapters
19:25:33 <hrumph> i'm reading the haskell tutorial classes.html
19:25:41 <cmccann> shachaf, didn't say it shouldn't take place here
19:25:42 <hrumph> what does LYAH stand for?
19:25:47 <Nereid> @where lyah
19:25:48 <lambdabot> http://www.learnyouahaskell.com/
19:26:27 <cmccann> just trying to put a slight damper on the tendency to turn beginner questions into bizarre cascades of esoteric quibbling
19:26:43 <Hafydd> Hahah.
19:26:58 <ivanm> cmccann: that sounds rather heretical to me... :p
19:27:06 <cmccann> and likely futile.
19:27:09 <cmccann> but oh well.
19:27:19 * elliott agrees with cmccann, though.
19:28:23 <zypper> Haskell's built-in `read' function can't read ".3" and "3." as it would "0.3" and "3.0". Is there another way of converting strings to numbers? >_>
19:28:56 <cmccann> it does get a bit ridiculous when a beginner asks something like "hey my program is crashing with 'Prelude.head: empty list' what do I do" and ten minutes later half of #haskell is debating how many distinguishable bottoms can dance on the head of a list
19:28:59 <Nereid> > (\f -> read ("0" ++ f ++ "0")) ".3" :: Double
19:29:01 <lambdabot>   0.3
19:29:04 <Nereid> > (\f -> read ("0" ++ f ++ "0")) "3." :: Double
19:29:06 <lambdabot>   3.0
19:29:07 <Nereid> ;D
19:29:51 <zypper> Nereid: And I guess I'll have to play around a bit to get it to work with a "-" sign in front. But thanks a lot. o.o
19:29:56 <Nereid> oh yeah.
19:30:08 <Nereid> the proper way would probably just to write a parser for it.
19:30:11 <ivanm> zypper: get a real parsing library?
19:30:26 <ivanm> I've adapted the sample parser that comes with polyparse to deal with cases like this
19:30:33 <Nereid> that sentence had no (main-clause) verb.
19:30:37 <elliott> cmccann: I think it's sort of inevitable with the structure of IRC + population of #haskell and I'm not really sure it's anything one person can change
19:30:37 <Nereid> I'm great at english.
19:30:40 <elliott> but then I'm cynical.
19:30:58 <cmccann> elliott, hope springs eternal, I suppose.
19:31:08 <Nereid> zypper: and don't forget about e notation
19:31:11 * cmccann doesn't mind tilting at a few windmills.
19:31:14 <Nereid> > 1.5e6
19:31:15 <lambdabot>   1500000.0
19:31:26 <Nereid> unless you don't need it
19:31:34 <Nereid> > (\f -> read ("0" ++ f ++ "0")) "5e1" :: Double
19:31:36 <lambdabot>  Terminated
19:31:41 <Nereid> > (\f -> read ("0" ++ f ++ "0")) "5.0e1" :: Double
19:31:43 <lambdabot>   5.0e10
19:31:47 <Nereid> :p
19:31:49 <zypper> Meh.
19:31:52 <ivanm> zypper: e.g. http://hackage.haskell.org/packages/archive/graphviz/2999.14.1.0/doc/html/src/Data-GraphViz-Parsing.html#parseStrictFloat
19:31:55 <Nereid> maybe you don't need it.
19:31:56 <Nereid> who knows.
19:32:09 <zypper> ivanm: But but but I don't want any more dependencies! D:
19:32:13 <ivanm> heh
19:32:22 <ivanm> you could possibly adapt that to use ReadP, which ships with GHC...
19:33:54 <ivanm> anyway, that function will parse numbers like ".3", "3.", "3e2", ".3e2"
19:35:10 <ivanm> zypper: or see the toDouble function here (though it's using Text; older versions of the library used String): http://hackage.haskell.org/packages/archive/graphviz/2999.14.1.0/doc/html/src/Data-GraphViz-Util.html
19:35:46 <zypper> So much complicatedness for such a simple goal. D:
19:35:55 <ivanm> well, it adds in necessary 0s, etc.
19:36:05 <zypper> Can't I just use a few splitAt's with Nereid's trick, and stuff?
19:36:51 <ivanm> sure, if you want
19:37:05 <zypper> I guess I'll try that. >_>
19:37:05 <Nereid> I'd rather use a proper parser
19:37:09 <ivanm> depends how complicated you want to get
19:37:15 <Nereid> parsing is fun!
19:37:17 <ivanm> ahhh, here we are: http://hackage.haskell.org/packages/archive/graphviz/2999.11.0.0/doc/html/src/Data-GraphViz-Util.html
19:37:25 <ivanm> see toDouble in there
19:37:45 <ivanm> it does assume it is a valid number though
19:38:44 <zypper> "a valid number" means?...
19:38:58 <ivanm> well, "a5" isn't a number
19:39:01 <ivanm> neither is "5a"
19:39:43 <zypper> Well, that's exactly the kind of things I check in my program. :D
19:39:51 <n81> is there a barnwell in the house here?
19:40:00 <ivanm> zypper: what are you writing?
19:40:10 * zypper is using Parsec to write an expression parser.
19:40:26 <ivanm> so you're already using a parsing library...
19:40:33 <ivanm> why not write a proper parser then? :/
19:40:59 <zypper> Well, it does "parse" it, that is, it fetches the number, as a string.
19:41:09 <zypper> I have yet to convert it to a double correctly. >_>
19:41:24 <ivanm> ahhhh
19:41:38 <Hafydd> In every parser a sub-parser grows.
19:41:50 <ivanm> zypper: it's not the correct syntax as it's for polyparse rather than parsec, but have a look at the first link I gave you
19:42:01 <ivanm> or find the original String-based one from polyparse rather than my Text-based one :p
19:43:26 <zypper> ivanm: I would rather try Nereid's trick first, though.
19:43:38 <ivanm> *shrug* suit yourself :)
19:44:56 <hrumph> ok i may read the learnyouahaskell book
19:57:42 <latermuse> hrumph: you should read it
20:08:10 <johnw> yes, i recommend it too
20:22:21 <shachaf> @djinn m -> ((m -> r) -> a) -> ((m -> r) -> a)
20:22:22 <lambdabot> f a b c = b (\ _ -> c a)
20:22:56 <shachaf> djinn++
20:23:04 <shachaf> Isn't it great when Djinn can write your code for you?
20:24:20 <shachaf> @djinn (a -> m) -> ((m -> r) -> r) -> ((m -> r) -> a -> r)
20:24:20 <lambdabot> f a b c d = b (\ _ -> c (a d))
20:24:31 <shachaf> Hmm, are those _s supposed to be there?
20:24:39 <shachaf> Maybe djinn is writing the wrong code. :-(
20:24:58 <Hafydd> Even when the implementation is shorter than the type.
20:25:10 <ion> @type let f a b c d = b (\ _ -> c (a d)) in f
20:25:11 <lambdabot> (t4 -> t3) -> ((t1 -> t2) -> t) -> (t3 -> t2) -> t4 -> t
20:25:58 <ion> Doesn’t match.
20:28:28 <shachaf> @djinn ((m -> r) -> m) -> ((m -> r) -> a) -> a
20:28:29 <lambdabot> -- f cannot be realized.
20:28:33 <shachaf> Bah, that needs a rank-2 type over r
20:29:03 <shachaf> Someone in this channel should write it instead.
20:29:06 <shachaf> elliott:
20:29:25 <shachaf> I think I'm wrong here, anyway.
20:30:12 <shachaf> (forall r. ((m -> r) -> m) -> ((m -> r) -> a)) -> a
20:30:15 <shachaf> That looks double-CPSed.
20:34:28 <shachaf> OK, yes, djinn's code was wrong.
20:34:49 <shachaf> edwardk: Shouldn't I get used to thinking in CPS eventually?
20:35:01 <edwardk> yes
20:35:36 <edwardk> just write a lot of cps'd code.
20:35:44 <edwardk> e.g. help me work on trifecta. ;)
20:35:47 <edwardk> more free labor
20:35:57 <edwardk> it'll help you grow up big and strong and learn cps
20:37:04 <shachaf> elliott wants to learn about CPS too.
20:37:16 <shachaf> By which I mean elliott wants to work on trifecta.
20:37:28 <shachaf> OK, it's obvious why Djinn got it wrong.
20:37:30 <shachaf> @djinn-env
20:37:30 <lambdabot> data () = ()
20:37:31 <lambdabot> data Either a b = Left a | Right b
20:37:31 <lambdabot> data Maybe a = Nothing | Just a
20:37:31 <lambdabot> data Bool = False | True
20:37:31 <lambdabot> data Void
20:37:32 <lambdabot> type Not x = x -> Void
20:37:34 <lambdabot> class Monad m where return :: a -> m a; (>>=) :: m a -> (a -> m b) -> m b
20:37:36 <lambdabot> class Eq a where (==) :: a -> a -> Bool
20:37:55 <shachaf> @djinn-add class Monoid m where mempty :: m; mappend :: m -> m -> m
20:38:30 <shachaf> @djinn Monoid m => m -> ((m -> r) -> a) -> ((m -> r) -> a)
20:38:31 <lambdabot> f a b c = b (\ _ -> c a)
20:38:35 <shachaf> @djinn Monoid m => m -> ((m -> r) -> r) -> ((m -> r) -> r)
20:38:36 <lambdabot> f a b c = b (\ _ -> c a)
20:38:53 <shachaf> OK, there are multiple different reasons.
20:39:03 <rwbarton> one of them is that it's djinn
20:39:13 <shachaf> One of them is that I gave the wrong type.
20:39:20 <shachaf> Another of them is that it needs to mappend.
20:39:28 <shachaf> Also that it's djinn.
20:39:33 <rwbarton> you could force it
20:39:50 <shachaf> By passing it an (a -> b -> c) mappend?
20:39:52 <rwbarton> @djinn (m' -> m'' -> m) -> m' -> ((m'' -> r) -> a) -> ((m -> r) -> a)
20:39:53 <lambdabot> f a b c d = c (\ e -> d (a b e))
20:40:17 <Nereid> shachaf: what are you doing? :)
20:40:30 <shachaf> @djinn (m' -> m'' -> m) -> m' -> ((m'' -> r) -> r) -> ((m -> r) -> r)
20:40:31 <lambdabot> f a b c d = c (\ e -> d (a b e))
20:40:38 <shachaf> Well, same type.
20:41:01 <rwbarton> @djinn (m' -> m'' -> m) -> x -> (x -> m') -> ((m'' -> r) -> r) -> ((m -> r) -> r)
20:41:01 <lambdabot> f a b c d e = d (\ f -> e (a (c b) f))
20:41:06 <shachaf> Figuring out a thing.
20:41:13 <Nereid> what thing
20:41:13 <rwbarton> oh i guess f shadows the other f
20:41:39 <rwbarton> @type \a b c d e f -> a b c d e f
20:41:40 <lambdabot> (t1 -> t2 -> t3 -> t4 -> t5 -> t) -> t1 -> t2 -> t3 -> t4 -> t5 -> t
20:41:49 <rwbarton> @@ @djinn @type \a b c d e f -> a b c d e f
20:41:50 <lambdabot>  f a = a
20:41:53 <rwbarton> doh
20:41:57 <Nereid> lol
20:42:09 <rwbarton> @@ @djinn @type \a b c d e f -> a (b c d e f)
20:42:10 <lambdabot>  f a b c d e f = a (b c d e f)
20:42:27 <rwbarton> @type let f f = f in f
20:42:28 <Nereid> @type \a b c d e f -> a (b c d e f)
20:42:29 <lambdabot> t -> t
20:42:30 <lambdabot> (t1 -> t) -> (t2 -> t3 -> t4 -> t5 -> t1) -> t2 -> t3 -> t4 -> t5 -> t
20:42:33 <shachaf> @djinn (m' -> m'' -> m) -> ((m' -> r) -> q) -> ((m'' -> r) -> a -> q)
20:42:34 <lambdabot> -- f cannot be realized.
20:42:48 <shachaf> @djinn (m' -> m'' -> m) -> (q -> m) -> ((m' -> r) -> q) -> ((m'' -> r) -> a -> q)
20:42:50 <lambdabot> -- f cannot be realized.
20:43:29 <shachaf> @djinn (m' -> m'' -> m) -> (q -> m') -> ((m' -> r) -> q) -> ((m -> r) -> a -> q)
20:43:29 <lambdabot> -- f cannot be realized.
20:43:44 <shachaf> Er.
20:44:08 <shachaf> Well, I'll just write it myself.
20:45:57 <ninegrid> should i learn parsec first or attoparsec?  i understand the difference between the two, but I don't know why i'd want to use parsec at all considering attoparsec works incrementally
20:46:08 <Nereid> attoparsec doesn't
20:46:13 <Nereid> well
20:46:18 <shachaf> @djinn (m' -> m'' -> m) -> (a -> m') -> ((m'' -> q) -> r) -> ((m -> q) -> a -> r)
20:46:18 <lambdabot> f a b c d e = c (\ f -> d (a (b e) f))
20:46:27 <popl> reddit just had a really cool link to something about parsec
20:46:42 <popl> http://ocharles.org.uk/blog/posts/2012-12-10-24-days-of-hackage-parsec.html
20:47:39 <shachaf> OK, that didn't help.
20:48:04 <Nereid> but what are you doing. D:
20:48:21 <popl> freaking me out
20:48:27 <Nereid> is m supposed to be a monoid?
20:48:29 <shachaf> Oh, my other function was wrong.
20:49:19 <shachaf> *HM> frun (fnow "x = " . flater show . fnow ", y = " . flater show) 2 3
20:49:19 <shachaf> "x = 2, y = 3"
20:49:31 <shachaf> With (Prelude..)
20:49:39 <ninegrid> popl: thanks
20:49:46 <Nereid> interesting
20:49:46 <shachaf> ( http://www.reddit.com/r/haskell/comments/14met7/oleg_typesafe_formatted_io/ )
20:49:56 <popl> ninegrid: I hope it is helpful.
20:50:05 <shachaf> Hmm, "fmap" doesn't quite work here. :-)
20:50:07 <ninegrid> Nereid: what do you mean 'attoparsec doesn't'?
20:50:24 <shachaf> So first I did "type DHM m a b = forall r. HoleyMonoid m r a -> HoleyMonoid m r b", which works, but then I turned the whole thing into a function.
20:50:34 <Nereid> ninegrid: oh never mind.
20:50:56 <popl> If I get a dog I will name it Parsec. That way when it does something good I can say "Good dog! Atta Parsec!'
20:51:11 <Nereid> :(
20:51:32 <ninegrid> *baddumpch*
20:53:58 <popl> ocharles: I pimped your blog. You owe me .25 USD.
20:54:47 <shachaf> You could do one more level of CPSing to this to get DList behavior.
20:54:54 <shachaf> Then you might go completely insane.
20:55:07 <shachaf> Hmm, maybe you can do an extra level of CPSing at no extra cost.
20:57:00 <popl> Nereid: You don't like puns?
20:58:36 <shachaf> Nereid: fnow m k d = k (\m' -> d (m <> m')); flater am k d a = k (\m' -> d (am a <> m')); frun fhm = fhm ($ mempty) id
20:58:45 <shachaf> Is this overly-convoluted?
20:59:19 <Nereid> looks fine. frun is what I got as an implementation for your weird type.
20:59:26 <Nereid> under the assumption that m was a monoid.
20:59:53 <shachaf> I mean for the use at hand.
21:00:10 <Nereid> I guess.
21:00:11 <Nereid> ?
21:00:13 <Nereid> I wouldn't now.
21:00:15 <Nereid> know.
21:00:25 <shachaf> Did you see the link?
21:00:28 <Nereid> yes
21:01:11 <shachaf> Oh, I see why you need the extra CPS.
21:01:29 <Nereid> OverloadedStrings with fromString = fnow.
21:01:31 <Nereid> :p
21:02:37 <Nereid> but you wouldn't have to expose that. you could just ask for a list, maybe.
21:02:53 <Nereid> with fnow and flater replaced by constructors?
21:03:12 <shachaf> With type safety?
21:03:20 <Nereid> I don't know, I haven't thought it through.
21:03:22 <shachaf> You don't always flater show
21:03:35 <Nereid> yeah it wouldn't work, I suppose.
21:03:47 <Nereid> we'd need something other than a list.
21:04:08 <shachaf> You could probably do it with a sufficiently fancy HList thing, maybe.
21:04:10 <Nereid> I want overloaded lists.
21:04:15 <Nereid> yeah like that.
21:13:06 <shachaf> Are tricks like that to avoid (Control.Category..) worth it?
21:13:15 <shachaf> http://www.reddit.com/r/haskell/comments/14met7/oleg_typesafe_formatted_io/c7f8un6
21:13:42 <shachaf> Sometimes it lets you do more than avoid (Control.Category..) -- for example you can do it to make any sort of polymorphic lens composable with (Prelude..)
21:17:32 <sw2wolf> "func1 = io $ do ...", what does io mean ?
21:17:50 <shachaf> It's a function.
21:18:15 <c_wraith> the only function I know of with that name is part of the GHC internals.
21:18:18 <c_wraith> Running into it is odd
21:18:41 <sclv> io is often used as an abbrev for liftIO
21:18:48 <sw2wolf> `hoogle io` gives too many things ...
21:18:49 <applicative> sw2wolf: where do you see it?  I've seen and used it as abbreviating liftIO
21:18:54 <sclv> by people who can't stand extra letters
21:18:55 <shachaf> c_wraith: xmonad has one.
21:19:00 <applicative> oh like sclv said
21:19:01 <sw2wolf> applicative: xmonad
21:19:43 <sw2wolf> io is liftIO ?
21:20:24 <shachaf> Google suggests so.
21:20:24 <sw2wolf> runProcessWithInput cmd args input = io $ do
21:20:25 <sw2wolf>     (pin, pout, perr, _) <- runInteractiveProcess (encodeString cmd)
21:20:25 <sw2wolf>                                  (map encodeString args) Nothing Nothing
21:20:43 <shachaf> sw2wolf: If you want to find out what "io" is, you should look at the place it's defined, not paste code where it's used into the channel.
21:20:59 <byorgey> sw2wolf: yes, in xmonad, io is just a synonym for liftIO
21:21:10 <sw2wolf> shachaf: i cannot find its definition
21:21:13 <sclv> you can load the module into ghci in general, then do :i _somefun_
21:21:20 <sw2wolf> byorgey: thx
21:21:22 <sclv> and that will tell you where it is if you are lost
21:21:36 <shachaf> http://www.google.com/search?q=xmonad+io+liftio -- second result here. :-)
21:22:05 <byorgey> shachaf: searching for liftio is cheating!
21:22:07 <shachaf> (I'm not trying to be mean to you for asking questions. I'm trying to help you with figuring out questions like that yourself, which is a very useful Haskell skill.)
21:22:15 <shachaf> byorgey: But sw2wolf already asked if it's liftio
21:22:31 <byorgey> shachaf: but only after applicative suggested it
21:22:33 <shachaf> byorgey: Besides, it's the same result even without "liftio"
21:22:43 <shachaf> @google xmonad io
21:22:45 <lambdabot> http://xmonad.org/xmonad-docs/xmonad/XMonad-Core.html
21:22:45 <lambdabot> Title: XMonad.Core
21:22:47 <applicative> -- | General utilities -- -- Lift an 'IO' action into the 'X' monad io :: MonadIO m => IO a -> m a io = liftIO
21:22:51 <shachaf> There you go.
21:23:01 <shachaf> First result for "xmonad io". :-)
21:23:05 <sw2wolf> shachaf: here canot use google just bing :(
21:23:16 <byorgey> not for me it isn't
21:23:28 <sw2wolf> applicative: that's waht i want, thx
21:23:29 <shachaf> Bing finds the same file here.
21:24:14 <Clint> ddg doesn't
21:24:15 * applicative figures Google Inc knows what shachaf wants, same as everybody
21:25:17 <applicative> oh I see you solved the problem of HoleyMonoid without a constructor and Data.Category
21:25:28 <applicative> shachaf, I mean
21:25:46 <Zer000> I'm learning haskell and when I tried to do "permutations "abc"" I get "Not in scope: `intersperse'" in ghci
21:25:53 <applicative> I was trying it earlier but kept getting everytihng backward
21:26:01 <Zer000> same with intersperse...
21:26:06 <applicative> Zer000: import Data.List
21:26:24 <shachaf> applicative: Needs an extra level of CPS. :-)
21:26:33 <shachaf> applicative: Actually -- do you have your code where you were getting it backwards?
21:26:34 <Zer000> applicative, oh ok. But how come I have map and reverse without importing that?
21:26:43 <shachaf> Because those are common.
21:26:53 <shachaf> You have to draw the line somewhere.
21:27:11 <applicative> Zer000: they're in the prelude so they're default
21:27:23 <Zer000> applicative, what's prelude?
21:27:37 <applicative> but inside ghci you can just type 'import Data.List'
21:28:12 <applicative> Zer000: it's the functions that are generally in scope in ghci and in any module.  You can modify this in several ways.
21:28:57 <Zer000> applicative, oh ok, well thanks
21:29:03 <applicative> Zer000: if you open ghci and type :browse they will all be exhibited to you, the prelude expressions
21:29:24 <shachaf> Hmm, 470 things in scope in plain ghci
21:29:31 <shachaf> 9912 in scope in my ghci...
21:30:30 <Zer000> uhm if I load a module in ghci, or import data.list it appends it to my prompt. So atm I have "*Main Data.List>" How do I go back up
21:31:05 <sw2wolf> :m - Data.List ?
21:31:26 <Zer000> sw2wolf, yup, ty
21:40:03 <So8res> greetings.
21:40:11 <So8res> I am fiddling with Control.Lens
21:40:19 <So8res> and am trying to write the following lens
21:40:28 <So8res> prepend lens value struct = set lens (value : (view lens struct)) struct
21:40:47 <So8res> This pattern works fine inline, but I'm having difficulty extracting it into a helper function
21:40:49 <edwardk> So8res: two ways to do it
21:40:53 <So8res> specifically, I have no idea how to write the type.
21:40:54 <Nereid> :t over (?value:)
21:40:55 <shachaf> So8res: over lens (value :) struct
21:40:56 <lambdabot>     Couldn't match expected type `a0 -> Mutator b0'
21:40:56 <lambdabot>                 with actual type `[a1]'
21:40:56 <lambdabot>     Expected type: Setting s0 t0 a0 b0
21:40:58 <Nereid> er
21:41:06 <Nereid> :t over ?lens (?value:)
21:41:07 <edwardk> So8res: i'll show you how to do what you wrote and how to do it right =)
21:41:08 <lambdabot> (?lens::Setting s t [a] [a], ?value::a) => s -> t
21:41:18 <So8res> edwark: awesome, thanks.
21:41:20 <shachaf> So8res: But in general this is a rank-2 type, so you'll need to either provide a type signature or use cloneLens.
21:41:38 <shachaf> (But the over version is better here.)
21:41:44 <edwardk> So8res: well, shachaf showed how to to it right. you can use 'cloneLens on the two places you used 'lens' in the body, or use a rank-2 type
21:42:02 <So8res> I figured as much, but I was struggling to find the type signature. I thought it would be 'prepend lens value struct = set lens (value : (view lens struct)) struct' but it is not.
21:42:03 <edwardk> prepend lens value struct = set (cloneLens lens) (value : (view (cloneLens lens) struct)) struct
21:42:25 <So8res> oops, wrong clipboard, meant "prepend :: Simple Lens t [x] -> x -> t -> t"
21:42:38 <edwardk> prepend lens value struct = over lens (value:) struct   avoids using the lens twice at two different signatures.
21:43:01 <So8res> gotcha.
21:43:01 <shachaf> The over version is more general -- it'll work for functions, for example.
21:43:07 <So8res> what does cloneLens actually do?
21:43:15 <Nereid> :t cloneLens
21:43:16 <lambdabot> Functor f => LensLike (Context a b) s t a b -> (a -> f b) -> s -> f t
21:43:25 <edwardk> that should be right. the nice thing about 'over' is that you can use it with a traversal or setter as well as a lens
21:43:27 <shachaf> It lets you use a lens at multiple different types while only consuming it at one type.
21:43:55 <edwardk> the problem is that when you use 'view' its picking the functor for the lens to be 'Accessor' and when you use set its picking it to be 'Mutator'
21:44:15 <edwardk> when you 'cloneLens' in two places it picks it to be (Context [x] [x]) both times, so they are compatible
21:44:24 <edwardk> a rank-2 type will let you use it directly like you did
21:44:32 <So8res> cool.
21:44:33 <So8res> thanks!
21:44:47 <edwardk> but in general its almost always better to find a way to go 'in and out' of the lens in one go using something like over than it is to do the two passes
21:45:09 <edwardk> the reason is you then get sharing of the work of going down and the work coming back up and it lets you do things like traverals
21:45:22 <edwardk> > over both (1:) ([2,3,4],[5,6,7])
21:45:24 <lambdabot>   ([1,2,3,4],[1,5,6,7])
21:45:29 <shachaf> So8res: Oh, by the way, this does work: let prepend :: Simple Lens t [x] -> x -> t -> t; prepend lens value struct = set lens (value : view lens struct) struct
21:45:37 <latermuse> lens is so cool
21:45:52 <So8res> shachaf: yeah, that's as far as I had gotten before I came here
21:46:10 <shachaf> So8res: I mean, your type + your implementaion *do* work.
21:46:19 <shachaf> You might need to turn on the extension Rank2Types, though.
21:46:40 <So8res> edwardk, is there a cleaner way to do something like "setdefault lens value struct | isNothing (view (cloneLens lens) struct) = set (cloneLens lens) (Just value)" without using cloneLens twice?
21:47:00 <So8res> It's hard to unify the use of 'lens' over teh '=' sign.
21:47:47 <shachaf> Maybe you can just "over lens (fromNothing value)"
21:48:16 <edwardk> :t fromMaybe
21:48:17 <lambdabot> a -> Maybe a -> a
21:48:20 <edwardk> :t fromNothing
21:48:21 <lambdabot>     Not in scope: `fromNothing'
21:48:21 <lambdabot>     Perhaps you meant `fromWithin' (imported from Control.Lens)
21:48:31 <shachaf> Er, right.
21:48:32 <shachaf> fromMaybe
21:48:46 <edwardk> :t over ?lens (Just . fromMaybe ?value)
21:48:47 <lambdabot> (?lens::Setting s t (Maybe a) (Maybe a), ?value::a) => s -> t
21:48:49 <So8res> Oh, right. Thanks again for the help!
21:49:08 <edwardk> :t over ?lens (\a -> a <|> Just ?value)
21:49:10 <lambdabot> (?lens::Setting s t (Maybe a) (Maybe a), ?value::a) => s -> t
21:49:14 <shachaf> I,I fromNothing :: Maybe a -> a; fromNothing x@Nothing = unsafeCoerce x; fromNothing _ = error "fromNothing"
21:49:25 <Nereid> I,I
21:52:52 <shachaf> @remember edwardk <aristid> a dubious motivation IMHO <edwardk> i've had worse =P
21:52:53 <lambdabot> It is stored.
21:53:19 <shachaf> Hmm.
21:53:24 <shachaf> @forget edwardk <aristid> a dubious motivation IMHO <edwardk> i've had worse =P
21:53:25 <lambdabot> Done.
21:53:26 <shachaf> @remember edwardk <aristid> a dubious motivation IMHO <edwardk> meh <edwardk> i've had worse =P
21:53:27 <lambdabot> I will remember.
21:54:17 <aristid> shachaf: isn't that a bit meaningless without context?:)
21:54:31 <sw2wolf> Whether or not it is hard to write a haskell REPL ?
21:54:46 <aristid> sw2wolf: start ghci, and there you go
21:54:55 <shachaf> aristid: edwardk is all the context you need.
21:55:07 <aristid> shachaf: if you say so:)
21:55:12 <sw2wolf> aristid: ghci sometimes is too heavy
21:55:25 <aristid> sw2wolf: it is?
21:55:30 <thirsteh> I'm doing some simple substitution of 10 different possible Char -> String; am I better off using an association list, map, or pattern matching?
21:55:44 <Rotaerk> sw2wolf, stop running it on a computer you can't lift
21:55:46 <sw2wolf> e.g. a xmonad box without installing GHC
21:56:15 <simpson> sw2wolf: Embedded?
21:56:25 <sw2wolf> an old freebsd box
21:56:28 <aristid> sw2wolf: well, if you want to write a haskell repl, you probably need to invoke a haskell compiler/interpreter somehow, and that usually means ghc. if your question is how hard it is to write a haskell repl without using a pre-existing haskell compiler...
21:56:28 <shachaf> thirsteh: Whichever one seems nicest to you. :-)
21:56:39 <aristid> sw2wolf: writing haskell compilers is not easy
21:56:48 <aristid> sw2wolf: perhaps you could try using hugs though
21:56:50 <simpson> What about hint? Is that not still a thing?
21:57:00 <aristid> simpson: uses ghc
21:57:04 <aristid> or its api
21:57:05 <shachaf> You can run xmonad without installing GHC.
21:57:08 <shachaf> You just can't configure it.
21:57:26 <aristid> can't you configure it on a beefier machine and just copy the binaries?
21:57:27 <thirsteh> shachaf: I'm interested in which one is fastest
21:57:35 <sw2wolf> it seems in xmonad-extras, there is XMonad.Prompt.Eval, but i cannot make it work :(
21:57:41 <shachaf> thirsteh: Oh. Then benchmark it!
21:57:49 <Hafydd> Hasn't someone written an xmonad.xs that reads from a normal config file?
21:57:53 <Hafydd> *hs
21:58:23 <thirsteh> does someone know off-hand whether data.map or pattern matching is fastest? Is (GHC) pattern matching more than just nested cases or does it do something clever?
21:58:38 <shachaf> thirsteh: It'll do something clever for some cases.
21:59:00 <thirsteh> what cases?
21:59:01 <shachaf> thirsteh: But it really depends on the specific case.
21:59:03 <shachaf> Benchmark it!
21:59:18 <shachaf> I don't know. I look at the generated code for my specific case when I want to know.
21:59:47 <thirsteh> ok
21:59:48 <sw2wolf> anyone used Language.Haskell.Interpreter ?
22:00:17 <aristid> sw2wolf: your freebsd machine does not have enough RAM for GHC, right?
22:00:27 <elliott> thirsteh: pattern matching is clever
22:00:31 <sw2wolf> aristid: yes
22:00:31 <elliott> uses jumps and stuff
22:00:40 <shachaf> Jumps and binary searches and all sorts of things.
22:00:52 <aristid> sw2wolf: to be quite honest, i believe using another tiling window manager would be the most reasonable course on that machine.
22:01:03 <thirsteh> if it does binary search then by definition it should be at least equivalent to data.map for my use case
22:01:29 <sw2wolf> aristid: xmonad compiled from another box runs perfect on this freebsd box
22:02:30 <aristid> sw2wolf: can't you also compile in the configuration?
22:02:39 <sw2wolf> aristid: it just needs a simple REPL. however interpret "1+1" even doesnot work
22:03:11 <sw2wolf> interpret is from Language.Haskell.Interpreter
22:03:41 <sw2wolf> aristid: the configuration is from another box
22:04:41 <aristid> sw2wolf: ok i'm not sufficiently familiar with xmonad to know what it needs a repl for
22:04:44 <sw2wolf>  :t interpret
22:04:45 <sw2wolf> interpret
22:04:45 <sw2wolf>   :: (Data.Typeable.Internal.Typeable a, MonadInterpreter m) =>
22:04:45 <sw2wolf>      String -> a -> m a
22:05:48 <sw2wolf> aristid: just for convenient
22:06:11 <simpson> sw2wolf: Can you grab Hugs or something similar?
22:06:35 <simpson> sw2wolf: Also, *how* doesn't it work? Could you explain a bit more?
22:06:49 <sw2wolf> simpson: xmonad ?
22:07:18 <simpson> sw2wolf: No, hint.
22:07:27 <sw2wolf> simpson: i dont know the second argunment passed to interpret
22:07:43 <simpson> sw2wolf: Also, yeah, as far as I can tell, hint (Language.Haskell.Interpreter and friends) needs GHC.
22:07:59 <byorgey> yes, hint is just a wrapper around the GHC API.
22:08:39 <sw2wolf> then how can i call interpet in a GHC box?
22:08:57 <sw2wolf> > interpret "1+1" ()
22:08:58 <sw2wolf>  
22:08:58 <sw2wolf> <interactive>:4:1:
22:08:58 <sw2wolf>     Ambiguous type variable `m0' in the constraint:
22:08:59 <lambdabot>   Not in scope: `interpret'
22:09:01 <sw2wolf>       (MonadInterpreter m0) arising from a use of `interpret'
22:09:40 <sw2wolf> :m + Lagnuage.Haskell.Interpreter
22:21:24 <mysticc> If there is a list of list and I want to sort on length then is there a more readable way then writing lambda and sortBy
22:22:39 <byorgey> > sortBy (comparing length) ["apples", "and", "adirondack", "a", "apply"]
22:22:40 <lambdabot>   ["a","and","apply","apples","adirondack"]
22:24:53 <mysticc> byorgey: Which module comparing is in?
22:25:51 <simpson> Data.Ord?
22:25:55 <byorgey> @hoogle comparing
22:25:55 <lambdabot> Data.Ord comparing :: Ord a => (b -> a) -> b -> b -> Ordering
22:28:12 <mysticc> byorgey: Is there a way to reverse this. I mean sort in opposite way using lenght
22:28:37 <CuteAngel24> forget it, it's NP-complete
22:29:11 <mysticc> ofcourse without using reverse
22:29:20 <byorgey> mysticc: sure, use 'flip'
22:29:28 <byorgey> > sortBy (flip $ comparing length) ["apples", "and", "adirondack", "a", "apply"]
22:29:30 <lambdabot>   ["adirondack","apples","apply","and","a"]
22:29:54 <Hafydd> :t comparing
22:29:55 <lambdabot> Ord a => (b -> a) -> b -> b -> Ordering
22:29:55 <mysticc> thanks
22:30:38 <Hafydd> @pl comparing
22:30:38 <lambdabot> comparing
22:30:48 <Hafydd> ...what did I expect?
22:31:44 <elliott> comparıng
22:31:46 <elliott> got rid of that dot for you
22:31:51 <elliott> er, that point
22:31:52 <Hafydd> Hah.
22:31:54 <elliott> way to ruin my own joke, me :(
22:33:30 <mysticc> @hoogle on
22:33:30 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
22:33:31 <lambdabot> Control.Exception.Base onException :: IO a -> IO b -> IO a
22:33:31 <lambdabot> Control.Exception onException :: IO a -> IO b -> IO a
22:38:20 <Hafydd> @pl \x -> f x
22:38:20 <lambdabot> f
22:38:39 <Hafydd> @pl \f x y -> g (f x) (f y)
22:38:39 <lambdabot> flip =<< (((.) . g) .)
22:39:33 <Hafydd> @pl \f x y -> g (f x) y
22:39:33 <lambdabot> (g .)
22:50:51 <Heather> Hello
22:51:04 <Heather> I've got C library and I want to make Haskell client
22:51:37 <Heather> Suggest me: c2hs || c2hsc || HSFFIG || libffi
23:00:57 <shachaf> Heather: It depends on the library and what you're doing.
23:01:18 <shachaf> This is a good talk about the Haskell FFI in general:
23:01:37 <shachaf> http://ugcs.net/~keegan/talks/high-level-ffi/talk.pdf
23:01:52 <shachaf> @where+ high-level-ffi http://ugcs.net/~keegan/talks/high-level-ffi/talk.pdf
23:01:53 <lambdabot> Good to know.
23:01:58 <Heather> shachaf: I need to access my C library, there are about 10 functions I need to wrap
23:02:18 <shachaf> If it's simple then maybe none of these tools are worth it.
23:02:25 <shachaf> You can just do straight FFI.
23:02:38 <fengshaun> Heather: RWH has a good section on FFI
23:02:40 <shachaf> foreign import ccall "foo" :: Int -> Int -> IO Double
23:02:54 <shachaf> Yes, look at the rwh chapter.
23:03:13 <shachaf> @where+ rwh-ffi http://book.realworldhaskell.org/read/interfacing-with-c-the-ffi.html
23:03:13 <lambdabot> I will remember.
23:05:49 <maus> Heather, I guess it mainly depends on data types used by C functions. If there is nothing fancy like enums and structs, you can go with plain ffi. Buf if you need to marshall C structs, you better use something like c2hs
23:05:53 <Heather> shachaf: I see
23:06:19 <Heather> maus: there is nothing fancy YET
23:06:55 <Heather> maus: but maybe I shell care about future and c2hs could be good
23:07:02 <Heather> *shall
23:07:22 <shachaf> Heather: It's not difficult to switch a small API from plain FFI to c2hs/hsc2hs/one of those things.
23:10:57 <maus> Heather, I recently wrapped a tiny part of x11 api. There were two structs I need to send into C. I decided to calculate offsets by hand. Guess that? I cursed it all :)
23:11:52 <arbn> maus: "I know! The answer is pointer arithmetic!" Whenever you find yourself at that point, you need to take a step back. :)
23:11:55 <Heather> maus: I see :)
23:13:57 <maus> I choose c2hs over c2hsc for later work mainly because I needed to work enums. I couldn't make it generate the identifiers I want, but still, better than nothing.
23:14:52 <maus> arbn, It's so hard to go backward then you think your goal is just a dozen lines away :)
23:20:17 <maus> by the way, right now I'm having troubles with c2hs. I'm trying to rebuild gth2hs with ghc-7.6.1 on a second almost identical ubuntu system. I'm getting the errors like these: http://hpaste.org/79104. I applied patches from John Lato. They helped to build gtk2hs on the first host but fail on the other one. I'm puzzled.
23:27:18 * hackagebot pipes 3.0.0 - Compositional pipelines  http://hackage.haskell.org/package/pipes-3.0.0 (GabrielGonzalez)
23:29:21 <Ralith> maus: remember, structs may be padded by the implementation
23:42:18 * hackagebot yesod 1.1.7 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-1.1.7 (MichaelSnoyman)
23:42:20 * hackagebot yesod-default 1.1.3 - Default config and main functions for your yesod application  http://hackage.haskell.org/package/yesod-default-1.1.3 (MichaelSnoyman)
