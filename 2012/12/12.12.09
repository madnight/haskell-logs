00:00:19 <popl> hurr
00:00:31 <ion> You should make yet another alternative Prelude in which there’s samBound and sam'n'maxBound.
00:01:22 <popl> Sam holds Max back.
00:02:40 <popl> I feel Max hasn't yet had the chance to tap into his true destructive power.
00:11:19 <cmccann> hm
00:12:03 <cmccann> hahaha ok this is a hilarious hack for fay ffi calls
00:12:48 <cmccann> totally faking the whole subtyping/interface/whatever stuff but it seems to work
00:12:55 <tobias2> Anybody here familiar with pandoc? I try to add css-classes to a HTML-standalone document created with pandoc. For this it should use the "~~~ {.language}" identifier which initiates code snippets. I am a non haskeller and already have a hard time understanding the basics johnmacfarlane.net/pandoc/scripting.html . Help or suggestions pointing into the right direction would be welcome.
00:13:30 <cmccann> by tricking GHC into checking the types (even though it can't do anything with them) and tricking fay into generating the code (even though it doesn't understand the type)
00:14:24 <cmccann> sadly it won't work for overloading functions with different arities
00:27:45 <burrows> Does deriving(Enum) allow me to get the nth constructor?
00:28:45 <Nereid> burrows: sure. you can only derive Enum if all the constructors are nullary though
00:29:23 <Nereid> > map toEnum [0,1,2] :: Ordering
00:29:25 <lambdabot>   Couldn't match expected type `GHC.Types.Ordering'
00:29:25 <lambdabot>              with actual ...
00:29:26 <Nereid> > map toEnum [0,1,2] :: [Ordering]
00:29:28 <lambdabot>   [LT,EQ,GT]
00:30:48 <burrows> Awesome.
00:31:04 <burrows> In my mind the syntax would not stop looking like this Ordering !! 0
00:32:01 <Nereid> I don't think it would be too useful, anyway.
00:32:10 <Nereid> > [minBound..] :: [Ordering]
00:32:12 <lambdabot>   [LT,EQ,GT]
00:33:47 <burrows> That's also pretty cool.
00:44:29 <augur_> edvardkk: hey
00:44:37 <augur_> have you read my curry-howard tutorial?
00:45:47 <shachaf> edvardkk?
00:46:05 <augur_> surely just edwardk with an accent!
00:46:48 <shachaf> ardwark
00:47:12 <cmccann> just like elliott is surely just conal using a different nick
00:47:16 <cmccann> it's only sensible
00:47:41 <augur_> gosh edvardkk isnt edwardk
00:47:45 <augur_> how silly
00:47:48 <augur_> edvardkk: get a better name
00:49:25 <shachaf> edwinb: Don't listen to augur_.
00:49:32 <augur_> hahahahaha
01:03:05 <isomorphic> Is anybody aware of a haskell library for multidimensional scaling?
01:03:20 <neutrino> isomorphic, what is multidimensional scaling/
01:03:22 <neutrino> ?
01:03:52 <isomorphic> neutrino:  Here's a concrete example: https://en.wikipedia.org/wiki/NOMINATE_(scaling_method)
01:04:14 <neutrino> hmm, is that like clustering based on fuzzy numbers?
01:05:15 <isomorphic> I guess so.  The aim isn't so much to cluster as to plot a bunch of objects in the 'right' position in space
01:25:44 <neutrino> isomorphic: i'm afraid i don't know any such library. but maybe someone else will know.
01:25:56 <isomorphic> thanks neutrino :)
01:26:01 <neutrino> yw
01:44:05 <burrows> Anyone have time to look at a piece of code, I am sufficiently perplexed.
01:55:46 <burrows> Nevermind, Type Annotation precedence not what I 'knew' it to be.
02:05:43 * hackagebot cryptohash 0.8.1 - collection of crypto hashes, fast, pure and practical  http://hackage.haskell.org/package/cryptohash-0.8.1 (VincentHanquez)
02:12:50 <Nereid> burrows: next time, just paste the code you have a question about ;)
02:15:05 <drchaos> what function would you use to add up all elements of a list?
02:15:53 <shachaf> drchaos: First ask yourself: What would its type be?
02:15:56 <drchaos> I don't know how to use the sum function
02:16:01 <shachaf> Oh.
02:16:06 <shachaf> Do you know how to use functions in general?
02:16:13 <drchaos> not quite yet
02:16:22 <shachaf> OK, so start with simpler functions. :-)
02:16:29 <shachaf> Might as well use sum, though.
02:16:29 <cmccann> > sum [1, 2, 3]
02:16:31 <lambdabot>   6
02:16:31 <shachaf> > sum [1,2,3]
02:16:32 <lambdabot>   6
02:16:34 <cmccann> ha!
02:16:36 <drchaos> I made this: myLength (x:xs) = sum (map (\_ -> 1) (x:xs))
02:16:37 <elliott> > sum [1,  2,  3]
02:16:38 <lambdabot>   6
02:16:55 <elliott> drchaos: That's almost correct.
02:16:55 <drchaos> this one doesn't work: myLength' (x:xs) = foldr (+1) (x:xs)
02:16:56 <cmccann> good work, elliott, that was helpful.
02:17:04 <elliott> cmccann: I try my best.
02:17:13 <cmccann> yes.
02:17:36 <shachaf> drchaos: That makes about as much sense to me as it does to ghc.
02:17:41 <elliott> > sumOf folded [1,2,3]
02:17:43 <lambdabot>   6
02:17:52 <neutrino> hi Nereid :)
02:17:58 <Nereid> hi :)
02:18:13 <cmccann> elliott, in other news I've produced some Haskell code more horrible than any I'd previously managed
02:18:29 <elliott> cmccann: that sounds suspiciously like all news you have ever given me, ever
02:18:33 <neutrino> cmccann: paste or didn't happen
02:18:46 <cmccann> elliott, different kind of horrible
02:19:02 <cmccann> this is a thrice-nested code generator
02:19:05 <elliott> cmccann: how many kinds of horrible can one person possibly discover
02:19:10 <elliott> you are pushing the limit
02:19:13 <cmccann> yes
02:19:32 <neutrino> cmccann: do you have any monster types to show off?
02:19:38 <drchaos> ok, what function would you use with the sum function to add an element of the list to a number and return that?
02:19:47 <cmccann> no, the types are all boring
02:19:58 <cmccann> though sometimes hideous because the codegen is dumb
02:19:58 <drchaos> I guess just sum (x:xs), but that
02:19:59 <elliott> drchaos: Your myLength with the sum and map was basically correct.
02:19:59 <neutrino> drchaos: i'd use map?
02:20:07 <elliott> drchaos: It works for all lists that are at least one element long.
02:20:07 <neutrino> > map (+2) [1..10]
02:20:09 <lambdabot>   [3,4,5,6,7,8,9,10,11,12]
02:20:17 <elliott> drchaos: Would it help to know that [1,2,3] is (1 : (2 : (3 : [])))?
02:20:26 <drchaos> neutrino: OOh, that gives me an idea
02:20:28 <elliott> And (x:xs) only matches lists of the form (x : xs) for some x and xs, which [] doesn't.
02:21:00 <neutrino> drchaos: if you want to implement this by hand, you can do it recursively with pattern matching by using the (head:tail) pattern.
02:21:02 <drchaos> just map (+0) [...]
02:21:08 <cmccann> elliott, but yeah basically a simple parsec parser eats a slightly wonky grammar specification format and spits out a parsec parser that eats a data description language and spits out code to use the relevant data
02:21:11 <elliott> > map (+0) [a,b,c]
02:21:13 <lambdabot>   [a + 0,b + 0,c + 0]
02:21:18 <elliott> That won't really do anything.
02:21:20 <elliott> You were closer the first time.
02:21:29 <elliott> > Let myLength (x:xs) = sum (map (\_ -> 1) (x:xs)) in myLength [1, 2, 3]
02:21:30 <lambdabot>   <hint>:1:21: parse error on input `='
02:21:32 <elliott> ugh
02:21:34 <elliott> > let myLength (x:xs) = sum (map (\_ -> 1) (x:xs)) in myLength [1, 2, 3]
02:21:35 <lambdabot>   3
02:21:37 <elliott> > let myLength (x:xs) = sum (map (\_ -> 1) (x:xs)) in myLength [1, 2]
02:21:38 <lambdabot>   2
02:21:40 <elliott> > let myLength (x:xs) = sum (map (\_ -> 1) (x:xs)) in myLength [1]
02:21:41 <lambdabot>   1
02:21:42 <elliott> > let myLength (x:xs) = sum (map (\_ -> 1) (x:xs)) in myLength []
02:21:43 <lambdabot>   *Exception: <interactive>:3:5-48: Non-exhaustive patterns in function myLen...
02:21:47 <drchaos> neutrino: I'd love to do that
02:22:05 <elliott> drchaos: The problem is you've only defined myLength for lists of the form (x:xs).
02:22:25 <neutrino> drchaos: so you have a list, and a summand, and you want to add that summand to a specific element of the list, and return the value of that?
02:22:26 <elliott> (Which [] isn't.)
02:22:28 <elliott> drchaos: But you don't have to pattern-match on a list to use it as an argument. You can just do this:
02:22:34 <neutrino> drchaos: or have i misunderstood you?
02:22:35 <elliott> > let myLength xs = sum (map (\_ -> 1) xs) in myLength []
02:22:37 <lambdabot>   0
02:22:38 <elliott> > let myLength xs = sum (map (\_ -> 1) xs) in myLength [1, 2, 3]
02:22:40 <lambdabot>   3
02:24:30 <drchaos> neutrino: I want to add the current element of the list (let's call it x) to the summand (which is comprised of the init of the list) and return that]
02:24:44 <neutrino> what is the "current element of the list"?
02:25:05 <drchaos> in the pattern (x:xs), x is the current element
02:25:09 <neutrino> yes
02:25:22 <drchaos> yes is not helping you
02:25:23 <neutrino> so you are refering to a specific function you were writing before, ok
02:25:32 <neutrino> that makes sense now
02:26:25 <neutrino> this means i have not understood your question correctly, sorry
02:26:33 <drchaos> I don't know how to add the element called x to the summand
02:26:45 <neutrino> really? but that's really simple
02:27:06 <drchaos> I have: getMeanOfList (x:[]) = x  AND getMeanOfList (x:xs) = getMeanOfList (
02:27:33 <neutrino> > let { foo (x:xs) = let summand = 2 in x + 2 } in foo [2]
02:27:34 <lambdabot>   4
02:28:00 <neutrino> err, haha
02:28:12 <neutrino> > let { foo (x:xs) = let summand = 2 in x + summand } in foo [2]
02:28:14 <lambdabot>   4
02:28:19 <drchaos> huh?
02:28:35 <drchaos> my brain must be fried, it's 5AM here and I've been up all night
02:29:02 <neutrino> you just asked how to add a number to a constant, unless i really misunderstood you
02:29:07 <neutrino> :)
02:29:20 <neutrino> that's how you do it..
02:29:37 <drchaos> > let { foo (x:xs) = let summand = 2 in x + summand } in foo [2,4]
02:29:38 <lambdabot>   4
02:29:46 <drchaos> I want a result of 6 there
02:29:48 <neutrino> well yeah, it doesn't recurse
02:30:12 <neutrino> oh, so you want "summand" to be your carry sum?
02:30:23 <drchaos> yes
02:30:27 <neutrino> i.e. you want to sum up all the numbers of a list?
02:30:32 <drchaos> yes, exactly
02:30:50 <neutrino> right, that's not how you do it. i mean you can do it like this, but it's awkward.
02:31:37 <neutrino> instead of carrying your sum as a specific number that you pass to further levels of recursion, you define the sum itself recursively
02:31:46 <neutrino> but this is easier explained in this way:
02:32:09 <neutrino> first of all, i bet right now you're thinking in terms of loops, how you'd do it in C or python
02:32:18 <drchaos> I want to do it in the "define the sum itself recursively" way
02:32:22 <drchaos> yes, loops
02:32:52 <drchaos> there was this webpage I was looking at that says that any while loop can be implemented as a recursive function call
02:32:52 <neutrino> so you must be thinking, ok, let me define a variable called "sum", look at the first element of that list, add it to the sum, and repeat with the next element, carrying the sum with me
02:32:56 <neutrino> right?
02:33:06 <drchaos> hyes
02:33:09 <neutrino> yeah
02:33:17 <Saizan> (tbf, for something strict like (+) it's more efficient to do it "loop with accumulator" style, which can be implemented as a recursive function still)
02:33:48 <neutrino> so here the "next element" is one level of recursion deeper, right drchaos?
02:33:54 <drchaos> yes
02:34:42 <neutrino> but the interesting thing about looping in haskell which you implement with recursion is that it's difficult to carry values "forward in the loop" - that is, carry them to further levels of recursion
02:35:00 <neutrino> whereas it is very easy to carry them backwards, which is not possible at all in for loops
02:35:25 <neutrino> imagine you have a for loop, and in every iteration of it you can get a summary of what will happen in the following iterations
02:35:27 <drchaos> int[] x = [1,2]; int i, sum; i = sum = 0; for(i = 0; i < x.length; i++) sum += x[i];
02:35:33 <neutrino> exactly
02:35:37 <neutrino> you need to stop thinking like this
02:36:39 <neutrino> the thing is, you're thinking in terms of "actions". you make statements like "do this, then do that, then do that". haskell is for the most part a naturally declarative language, which lends itself more to statements like "this is that modified by that"
02:36:59 <drchaos> so err...you get like for [1,2]: first call = [1,2], first level of recursion = [1]
02:36:59 <neutrino> so instead of changes in time, try to describe the nature of things which does not change in time
02:37:10 <Jafet> What's wrong with thinking like that
02:37:11 <drchaos> neutrino: like in math?
02:37:12 <Jafet> > (forM_ [1, 2] $ \x -> do sum <- get; put (sum + x);) `execState` 0
02:37:13 <lambdabot>   3
02:37:16 <neutrino> drchaos: yeah
02:37:26 <neutrino> Jafet: it's unnatural for haskell code
02:37:39 <neutrino> Jafet: as i said, you can do it, but it's an exercise in futility
02:37:48 <neutrino> drchaos: so think about it, when you recurse..
02:37:55 <drchaos> neutrino: I can see algebra 1, and I'm sure I could see algebra 2 with a bit more practice
02:38:02 <zossn> Hello, is there a function that returns if an element is in a list, for now I use "any (==element) list".
02:38:11 <Nereid> zossn: elem
02:38:12 <Jafet> @pl \x -> any (== x)
02:38:13 <lambdabot> any . (==)
02:38:13 <drchaos> Jafet: stop using IO() code
02:38:16 <neutrino> drchaos: at your current recursion level, you can obtain the return value from your next level of recursion
02:38:17 <elliott> > 2 `elem` [1,2,3]
02:38:19 <lambdabot>   True
02:38:24 <Jafet> @src elem
02:38:24 <lambdabot> elem x    =  any (== x)
02:38:24 <zossn> ha
02:38:25 <drchaos> Jafet: your code is nasty
02:38:26 <zossn> darn
02:38:38 <zossn> thanx
02:38:46 <Nereid> forM_ [1, 2] (modify (+x)) `execState` 0
02:38:50 <Nereid> > forM_ [1, 2] (modify (+x)) `execState` 0
02:38:51 <neutrino> drchaos: let me know if you're following so far
02:38:52 <lambdabot>   Couldn't match expected type `Control.Monad.Trans.State.Lazy.StateT
02:38:52 <lambdabot>        ...
02:38:54 <hpaste> romildo pasted “ThreadedDemo.hs” at http://hpaste.org/78983
02:38:54 <drchaos> neutrino: weird
02:38:59 <Nereid> er
02:39:08 <Jafet> > forM_ [1, 2] (modify . (+)) `execState` 0
02:39:10 <drchaos> I'm not used to this mode of thinking
02:39:10 <Nereid> > forM_ [1, 2] (\x -> modify (+x)) `execState` 0
02:39:10 <lambdabot>   3
02:39:11 <lambdabot>   3
02:39:12 <Nereid> yes
02:39:14 <neutrino> drchaos: well, it's not weird. recursion is just a function call, and from a function call you get a return value, right?
02:39:19 <drchaos> yes
02:39:22 <Nereid> > forM_ [1, 2] (id +=) `execState` 0
02:39:24 <lambdabot>   3
02:39:28 <Nereid> =D
02:39:28 <romildo> I am writing a Gtk2hs application which in some point has to scan a directory and all its subdirectories. As it may take some time to complete, I will run it in a separate Haskell thread. There is a button to stop scanning, in case the user thinks it is taking too long. The problem is that sometimes that thread is not killed as expected, and the scanning continues. Am I missing something?  http://hpaste.org/78983
02:39:42 <Jafet> > sum [1, 2]
02:39:44 <lambdabot>   3
02:39:45 <neutrino> drchaos: ok, so the next mental trick to use is to think "backwards"
02:40:33 <neutrino> drchaos: in specific, the way you build your loop, you start out with a big loop, add the first element off it to the sum, and are left with a smaller list. then you go on and on and the list shrinks, until you are left with nothing. right?
02:40:39 <neutrino> drchaos: so you're going from big to small
02:40:49 <drchaos> neutrino: ah
02:40:57 <neutrino> drchaos: that is what you do in C
02:41:03 <neutrino> drchaos: in haskell, go from small to big
02:41:09 <neutrino> start out with the sum of an empty list.
02:41:19 <neutrino> > let foo [] = 0 in foo []
02:41:20 <lambdabot>   0
02:41:23 <drchaos> [] = 0
02:41:28 <neutrino> foo [] = 0 yeah
02:41:32 <drchaos> (x:[]) = x
02:41:43 <drchaos> (x:xs) = foo xs
02:41:49 <neutrino> wait a sec
02:42:00 <Nereid> foo (x:xs) = x + foo xs
02:42:01 <neutrino> (x:[]) -> x does hold, but it's not very useful
02:42:06 <neutrino> right Nereid
02:42:07 <shachaf> drchaos: What are you trying to do here?
02:42:31 <Nereid> shachaf: understand how to define things like sum
02:42:33 <neutrino> drchaos: so you've got your terminating case defined. that is, foo [] = 0.
02:42:45 <shachaf> I'd like to hear drchaos say it. :-)
02:42:48 <Nereid> :)
02:42:51 <neutrino> drchaos: the next step from that is to be able to go from a smaller list to a bigger list.
02:42:56 <drchaos> shachaf: sum all the elements of a list together, then divide by half the size of the list
02:43:09 <shachaf> Since <drchaos> ok, what function would you use with the sum function to add an element of the list to a number and return that?
02:43:17 <Jafet> romildo: how are you killing the thread?
02:43:20 <Nereid> heh
02:43:26 <shachaf> drchaos: OK. Why are you dividing by half the size, by the way?
02:43:33 <neutrino> drchaos: if you have the sum of a smaller list, and have a list which has one more element in front, then you say that the sum of the bigger list is that extra element plus the sum of the smaller list, right?
02:43:44 <drchaos> shachaf: to get the mean value of a list
02:43:56 <Nereid> drchaos: remember, lists are linked lists in haskell
02:43:58 <shachaf> Wouldn't you divide by the full size?
02:44:11 <shachaf> Nereid: So?
02:44:15 <drchaos> shachaf: err...not sure
02:44:18 <dcoutts_> romildo: you mean it doesn't stop at all, or not immediately?
02:44:18 <Nereid> so?
02:44:23 <neutrino> drchaos: following so far, with the summing?
02:44:34 <Nereid> oh I'm totally misreading everything.
02:44:38 <Nereid> I'm gonna go to bed.
02:44:44 <shachaf> Nereid: So what? Are you going to tell this person who doesn't know how to write sum to use an array, or to do it in one pass?
02:44:45 <neutrino> bye Nereid
02:45:15 <shachaf> drchaos: OK.
02:45:36 <Jafet> Hmm, naming that killThread could be misleading.
02:45:39 <Jafet> @quote killThread
02:45:39 <lambdabot> monochrom says: 007 titles for haskellers.  fromForeignPtr withCString.  You Only lift Twice. Bottoms Are Forever.  The Monad with the Pure Function.  For Your Types Only.  A view to A seq.  Licence
02:45:39 <lambdabot> to killThread.  iterate Never Dies.  unsafePerformIO Is Not Enough.
02:46:11 <drchaos> neutrino: yes, you must add x to a smaller list
02:46:18 <neutrino> drchaos: no!
02:46:28 <neutrino> drchaos: you must add that first element to the *sum of* the smaller list
02:46:29 <ijp> and who could forget GoldFingerTree
02:46:42 <drchaos> I see
02:46:51 <romildo> Jafet, using killThread
02:47:05 <neutrino> drchaos: ok, so we have established: sum of bigger list = first element + sum of smaller list
02:47:18 <neutrino> so let's write that in haskellish
02:47:38 <neutrino> sum bigger_list = first_element + (sum smaller_list)
02:47:47 <Jafet> Ok, you should know that killThread actually just throws an exception, it doesn't kill anything.
02:47:58 <romildo> dcoutts, sometimes it does not stop at all. For that to happen I have to try many times.
02:48:02 <Jafet> We have enough violence these days, anyway.
02:48:08 <neutrino> drchaos: but the bigger list and smaller list and the first element can be expressed a little bit differently
02:48:23 <neutrino> because bigger_list = (first_element:smaller_list)
02:48:31 <Jafet> @src killThread
02:48:31 <lambdabot> killThread tid = throwTo tid (AsyncException ThreadKilled)
02:48:51 <neutrino> drchaos: so you can write: sum (first_element:smaller_list) = first_element + sum smaller_list
02:48:58 <neutrino> drchaos: this way, you have gone from smaller to bigger.
02:49:39 <drchaos> neutrino: I see bigger to smaller
02:49:43 <Jafet> This is also why catching SomeException is dumb
02:49:55 <neutrino> drchaos: remember we went from knowing what the sum of smaller_list is
02:50:09 <neutrino> drchaos: and then we figured out what the sum of a list which is bigger than that by one element would be
02:50:38 <Nereid> haskell is magic, you write some equations you want your function to satisfy and that automatically gives you a definition :v
02:50:42 <neutrino> drchaos: that's definitely from smaller to bigger, but the final equation does indeed show going from bigger to smaller
02:50:56 <neutrino> Nereid: it's not magic.. it's very simple
02:50:58 <Jafet> Magnets
02:50:59 <Nereid> I know ;)
02:51:24 <drchaos> Nereid: ah
02:51:32 <drchaos> errr... Nereid
02:51:38 <drchaos> neutrino *
02:51:38 <Nereid> the equations have to be written in a certain way of course.
02:51:43 <Nereid> :p
02:52:04 <Nereid> it might be worth seeing how one might evaluate such a thing:
02:52:14 <neutrino> drchaos: so now, thinking about it, you know how to sum up the empty list ( sum [] = 0 ), you know how to sum up the list with one element (because you can define the sum of a list of one element in terms of the sum of an empty list), and you can go up by one element like that infinitely
02:52:25 <Nereid> sum (1:2:[]) = 1 + sum (2:[]) = 1 + (2 + sum []) = 1 + (2 + 0)
02:53:00 <shachaf> (Only because sum is strict.)
02:53:03 <neutrino> drchaos: so you can, in fact, figure out the sum of a list of any length
02:53:07 <shachaf> Er.
02:53:11 <shachaf> s/sum/(+)/
02:53:23 <neutrino> drchaos: you know what i mean?
02:53:34 <Nereid> shachaf: well yes.
02:53:46 <dcoutts_> romildo: I wonder if you can reproduce that without the gui stuff. It sounds a bit like the thread to be killed is swallowing an exception somewhere.
02:54:01 <neutrino> drchaos: that is, by the way, called mathematical induction, so you have just learnt two very powerful concepts at once: recursion AND induction
02:54:20 <drchaos> getMeanOfList (x:xs) = (x + getMeanOfList xs) / fromIntegral $ myLength (x:xs)
02:54:34 <neutrino> drchaos: i wouldn't do that
02:54:40 <Jafet> Back in the day, you were mathematically inducted in a fraternity house
02:54:56 <neutrino> drchaos: that is incorrect. try summing up separately and getting the length separately
02:55:03 <Jafet> It involved cursing and recursing
02:55:30 <drchaos> Jafet: what is your recursive definition? Drinking all the alcohol?
02:55:37 <neutrino> drchaos: so try this: getMeanOfList xs = (sum xs) / (length xs)
02:55:46 <neutrino> drchaos: insert fromIntegral where it's necessary
02:55:51 <romildo> Jafet, dcoutts , there is a call to try that catches SomeException. Maybe it is related.
02:55:56 <drchaos> and do it recursively until selfIsDead() == True
02:56:18 <neutrino> btw, i have a question
02:56:38 <Nereid> > let sum' acc [] = acc; sum' acc (x:xs) = sum' (x + acc) xs in sum' [1..5] 0
02:56:39 <lambdabot>   No instances for (GHC.Num.Num [t0], GHC.Num.Num [[t0]])
02:56:39 <lambdabot>    arising from a u...
02:56:42 <Nereid> > let sum' acc [] = acc; sum' acc (x:xs) = sum' (x + acc) xs in sum' 0 [1..5]
02:56:44 <lambdabot>   15
02:57:10 <Nereid> @src sum
02:57:11 <lambdabot> sum = foldl (+) 0
02:57:48 <drchaos> neutrino: why can't I do it my way? sum is a function that I don't want to use
02:57:58 <drchaos> oh
02:58:25 <neutrino> drchaos: because for the nth element of the list, you divide it n times.
02:58:31 <neutrino> drchaos: that is clearly incorrect.
02:58:55 <dcoutts_> romildo: oh, where is that?
02:59:02 <drchaos> neutrino: ok, then here's the solution: implement my own sum function called sum'
02:59:09 <neutrino> drchaos: yes
02:59:15 <neutrino> drchaos: and your own length function too
02:59:25 <dcoutts_> romildo: oh yes, I see it.
02:59:27 <neutrino> i need to loop around, the loop needs to carry a couple file handles and an sqlite connection. every two seconds or so i need to write to that connection. what's a good convenience function for looping around like that?
02:59:38 <romildo> dcoutts, http://hpaste.org/78983#line107
02:59:44 <dcoutts_> romildo: so when you find that it doesn't stop, is it logging that it caught an exception?
02:59:53 <neutrino> i think it was something like "forever", but i'm not sure it's the best idea
02:59:55 <neutrino> :t forever
02:59:56 <lambdabot> Monad m => m a -> m b
03:00:04 <neutrino> it probably isn't
03:00:11 <Jafet> TIL you can link to hpaste line numbers
03:00:23 <dcoutts_> romildo: since if the async exception arrives while the thread is inside that 'try' then yes it will swallow your ThreadKilled exception and so not stop
03:00:32 <neutrino> i could write it by hand, but i'm sure there's something that does exactly this kind of loop
03:00:43 <dcoutts_> romildo: this is partly why catching all exceptions is not recommended
03:01:17 <drchaos> neutrino: I try this and I get a lot of warnings: getMeanOfList (x:xs) = (sum (x:xs)) / fromIntegral $ myLength (x:xs)
03:01:38 <neutrino> what warnings do you get?
03:01:39 <Nereid> drchaos: $ has lower precedence than /
03:02:14 <drchaos> does the . operator do the same thing but have a higher precedence than /?
03:02:18 <Nereid> no
03:02:23 <Nereid> $ is function application, . is function composition.
03:02:49 <Nereid> you'll just need to use more parentheses.
03:02:58 <romildo> dcoutts, I suppose I will have to change this code to catch explicitly all exceptions thrown by getDirectoryContents, right?
03:03:07 <drchaos> > getMeanOfList (x:xs) = (sum (x:xs)) / fromIntegral (myLength (x:xs))
03:03:08 <lambdabot>  Terminated
03:03:16 <dcoutts_> romildo: that'll only be IOException
03:03:34 <drchaos> oh, I see
03:04:15 <b__> getMeanOfList getMeanofList xs = sum xs / fromIntegral (myLength xs)
03:04:18 <dcoutts_> romildo: but is that right? in the cases where you noticed it did not stop, did you see that your code logged the exception?
03:04:23 <b__> or something
03:04:33 <b__> without the double getMeanOfList
03:05:21 <romildo> dcoutts, I will have to run the application again to observe that. One moment ...
03:07:06 <hpaste> drchaos pasted “Haskell errors” at http://hpaste.org/78984
03:08:53 <drchaos> neutrino: the errors are there
03:09:51 <neutrino> drchaos: when you run into errors, you need to post your whole source code and the whole error output. can't help you otherwise.
03:11:29 <hpaste> drchaos annotated “Haskell errors” with “Haskell errors (annotation)” at http://hpaste.org/78984#a78985
03:11:53 <Jafet> Err or
03:12:04 <romildo> dcoutts, it seems you are right. Every test I did where the thread was not killed as expected logged the message: EXCEPTION: thread killed
03:12:06 <Jafet> (mess age?)
03:12:23 <dcoutts_> romildo: phew! glad we understand what's going on then.
03:12:49 <Jafet> dcoutts was secretly hoping to discover an obscure GHC IO bug or something
03:13:11 <dcoutts_> really, I wasn't :-)
03:13:17 <romildo> dcoutts, Therefore I will change SomeException to IOException in the code and the issues will be gone.
03:13:22 * dcoutts_ was hoping we did not find any such tricky bug
03:13:25 <neutrino> drchaos: get rid of the type annotations. they're difficult to get right and ghc will do a better job at guessing them than you will.
03:13:32 <dcoutts_> romildo: right
03:14:26 <Nereid> drchaos: the type signatures don't work
03:14:35 <drchaos> wow, that fixed all my problems
03:14:36 <Nereid> you're saying you can sum any list of anything and get a Float out
03:14:42 <Nereid> :p
03:14:52 <drchaos> *Main> getMeanOfList [1,2]
03:14:54 <drchaos> 1.5
03:14:56 <drchaos> *Main>
03:15:07 <romildo> dcoutts, maybe this application can be added as a demo to gtk2hs distribution. What do you think?
03:15:20 <art2art> hi all
03:15:26 <Nereid> some things:
03:15:36 <neutrino> drchaos: basically, when you have type annotations and ghc complains about them, then it probably is saying "you say the type of this function is this, but I came to the conclusion that it's different, and i got confused, so I can't continue, and you get an error"
03:15:38 <dcoutts_> romildo: maybe, send an email to the gtk2hs devel list
03:15:41 <Nereid> myLength [] = 0 is redundant if you replace (x:xs) with xs in the next line.
03:15:57 <Nereid> (\_ -> 1) can be replaced with const 1
03:16:14 <Nereid> also, you'll run into a stack overflow for very long lists
03:16:35 <romildo> dcoutts and Jafet, thank yoou for helping me spot the problem in my application.
03:16:47 <Nereid> (see http://www.haskell.org/haskellwiki/Foldr_Foldl_Foldl%27 for a discussion)
03:16:49 <neutrino> Nereid: doesn't matter, he's just learning right now
03:16:52 <Nereid> :P
03:17:08 <neutrino> Nereid: stop confusing drchaos with technicalities, it really doesn't help him at all
03:17:34 <Nereid> (but that's why I put things in parentheses)
03:17:46 <neutrino> doesn't matter
03:17:47 <monqy> mind if i say it'd help if drchaos understood what he's writing
03:17:48 <dcoutts_> romildo: you're welcome
03:17:49 <monqy> instead of just writing it
03:17:55 <neutrino> still confusing
03:18:42 <Nereid> the exercise is to write out by hand how things like sum' [1,2,3] would get evaluated
03:19:03 <neutrino> weren't you going to go to sleep
03:19:05 <neutrino> :)
03:19:08 <Nereid> oh right
03:19:13 <Nereid> bye then :)
03:19:18 <neutrino> :))
03:20:45 * hackagebot csound-expression 0.3.4 - Csound combinator library  http://hackage.haskell.org/package/csound-expression-0.3.4 (AntonKholomiov)
03:22:27 <shachaf> neutrino: I usually have you on /ignore, but someone is telling me in /msg about how you're being deliberately misleading and unhelpful. Experience and some logs seem to confirm it. Would you please stop?
03:22:51 <neutrino> i think you have slept on the wrong side of the bed
03:23:12 <Jafet> Oh come on, does this channel need to be correct and informative all of the time? Give him a break.
03:23:16 <monqy> shachaf: what if neutrino actually doesn't understand
03:23:38 <neutrino> monqy: i don't even know what he's talking about. where have i been "misleading"?
03:24:31 <shachaf> Oh well.
03:24:35 <shachaf> I'm not sure why I bothered.
03:24:45 <monqy> I don't feel like bothering either...
03:24:57 <neutrino> i'm not sure either, an explanation would be nice, because i don't know what the outrage is about
03:25:06 <Jafet> Well, sometimes I am the one not being informative
03:25:18 <neutrino> Jafet: do *you* know what shachaf is talking about?
03:25:24 <Jafet> Actually probably most of the time, but who's counting
03:26:28 <neutrino> serious question, can anyone tell me what shachaf is objecting to?
03:26:53 <monqy> what specifically? I think only shachaf can...
03:27:31 <neutrino> shachaf: go on then, i'm all ears
03:28:08 <b__> I don't think anyone wants to get involved, because (speaking for myself) it's not quite clear what the issue is.
03:28:15 <shachaf> I take it back.
03:28:27 <shachaf> Everyone knows what they need to know.
03:28:38 <neutrino> i can see with elliott, shachaf, monqy, and Sgeo|web the #esoteric peanut gallery is complete
03:29:19 <Jafet> Perhaps you should acquire the services of a calque
03:32:15 <monqy> neutrino: do I know you?
03:32:58 <Jafet> Heh, of all the wrong words, why "calque"
03:35:26 <Jafet> Probably because the right word is claque
03:35:34 <hpaste> b__ pasted “Why does ghc give this type signature when using liftM2?” at http://hpaste.org/78986
03:35:38 <b__> ^
03:35:50 <osfameron> haha, claque does make more sense than calque
03:36:09 <Saizan> b__: because of the MonomorphismRestriction
03:36:18 <Saizan> b__: and it's not really about liftM2
03:37:13 <b__> wait I kinda didn't paste the right functions >_>
03:38:00 * Saizan suspected so
03:38:28 <hpaste> b__ annotated “Why does ghc give this type signature when using liftM2?” with “Why does ghc give this type signature when using liftM2? (annotation)” at http://hpaste.org/78986#a78987
03:38:37 <b__> ye this makes more sense
03:39:08 <Saizan> b__: are you sure the third function gets that inferred type?
03:39:16 <b__> no
03:39:23 <b__> actually I am not
03:39:40 <mapf> floating types defaulting too?
03:39:42 <shachaf> b__: I bet Saizan's first answer correct.
03:39:50 <shachaf> Do you know what the MonomorphismRestriction is?
03:39:55 <b__> nope
03:40:02 <Saizan> it should infer to [Double] -> Double like the second
03:40:14 <b__> it does indeed
03:41:18 <b__> however the other signature does not give me warnings
03:41:27 <Saizan> yeah
03:41:52 <b__> but why is it suggested for liftM2 and Applicative and not for the first one?
03:42:09 <Saizan> the MR only says that definitions with no signatures and with no apparent arguments don't get to be typeclass polymorphic
03:42:31 <Saizan> so it's not really about the operators, it's the difference between f = .. and f x = ..
03:42:37 <b__> aha, okay
03:43:04 <b__> is the reason(ing) behind this easily explained?
03:43:36 <Saizan> maybe, the reasoning is that we expect the evaluation of things defined like f = .. to be shared
03:43:47 <Saizan> but with a typeclass context they won't be
03:44:05 <Saizan> so the MR is trying to force you to acknowledge the difference
03:45:28 <b__> why would the evaluation be shared without explicit arguments?
03:46:04 <Saizan> e.g. "let x = 5 + 5 in (x,x)" will evaluate the sum once, but "let x :: Num a => a; x = 5 + 5 in (x,x)" will evaluate the sum twice (assuming we force the whole tuple in both cases)
03:46:22 <b__> (if you're not willing to explain or if my questions reveal a total cluelessness you can point me to some reading =D)
03:46:28 <shachaf> Because foo :: Num a => a is really implemented as a function in GHC.
03:46:29 <Nereid> @where dmr
03:46:29 <lambdabot> http://www.haskell.org/haskellwiki/Monomorphism_restriction
03:47:11 <b__> aha yes, I'm getting that
03:47:33 <neutrino> Nereid: what does the "d" stand for?
03:47:37 <b__> you mean x is really implemented, no?
03:47:49 <shachaf> ?
03:47:52 <cmccann> d for "dreaded"
03:48:00 <Saizan> b__: yeah, in my case shachaf's foo is my x
03:48:03 <neutrino> cmccann: ahh.
03:48:04 <shachaf> When you say foo :: Num a => a; foo = ..., foo is compiled into a function.
03:48:08 <cmccann> but you can substitute something less polite if you prefer
03:48:14 <b__> ah yeah, sorry
03:48:26 <neutrino> cmccann: :)
03:48:48 <b__> ok I actually understand it now, on a surface level at least
03:48:53 <b__> thanks
03:49:48 <Saizan> Nereid: that wiki page is kind of a mess, sadly
03:50:16 <neutrino> Saizan: is it true that the MR is slowly going away from ghc?
03:51:13 <Saizan> neutrino: not really, there's been a trend of disabling it though
03:52:06 <neutrino> oh, i heard that the flag for disabling it was being put into the defaults?
03:52:16 <neutrino> i must have heard incorrectly then
03:53:10 <Saizan> tbf i'm not so much in the loop anymore, maybe they are trading it for MonoLocalBinds
03:53:28 <neutrino> oh, what sort of evil is that?
03:53:47 <neutrino> never heard of MonoLocalBinds
03:54:04 <shachaf> I heard F# was getting MonoLocalBinds.
03:54:25 <Saizan> when enabled local bindings default to being monomorphic unless they have a signature, it's implied by GADTs
03:55:37 <neutrino> aha
03:55:45 * hackagebot optparse-applicative 0.4.3 - Utilities and combinators for parsing command line options  http://hackage.haskell.org/package/optparse-applicative-0.4.3 (PaoloCapriotti)
03:56:13 <neutrino> so it's even more evil than the MR?
03:57:56 <neutrino> by the way, regarding my earlier question about loops, i've found this neat solution: http://www.haskellforall.com/2012/07/breaking-from-loop.html
03:58:12 <neutrino> you can use EitherT + forever to create a loop from which you can exit at any time
03:58:30 <neutrino> is that generally a good idea? or am i missing some more obvious way of doing this?
03:59:08 <bitonic> neutrino: it’s OK, you can do the same with MaybeT if you don’t need an error
03:59:16 <neutrino> oh yeah, i don't
03:59:24 <neutrino> i guess MaybeT is even better
04:00:02 <neutrino> is there no shorthand for "void $ runMaybeT $ forever" ?
04:04:08 <mm_freak> neutrino: fix $ \again -> x >> if quit then return () else again
04:04:20 <mm_freak> no need for a monad transformer here
04:04:56 <neutrino> that's really interesting. why does fix terminate there?
04:05:15 <bitonic> neutrino: you’re not using `again' in one branch
04:05:31 <bitonic> but anyway, assuming that you have nested function calls and stuff like that a MaybeT is better
04:05:32 <mm_freak> fix (\again -> someLongExpression)
04:05:36 <bitonic> and assuming that you need the “T” :P
04:05:51 <neutrino> ok, so "again" ends up being the recursive call?
04:05:52 <mm_freak> fix works like that:  'again' is someLongExpression when it appears in someLongExpression
04:06:07 <bitonic> neutrino: yes
04:06:09 <mm_freak> so it's basically recursion for an anonymous function
04:06:23 <bitonic> well it’s not really a “call”
04:06:31 <bitonic> but it’s a recursively defined value
04:06:36 <mm_freak> > fix (\theList -> 1 : theList)
04:06:37 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
04:07:07 <neutrino> well then i could just do recursion and skip fix altogether, couldn't i?
04:07:33 <mm_freak> sure
04:07:46 <mm_freak> fix just saves you from having to define a function
04:07:49 <neutrino> f = do { stuff; if recurse then f; else return () }
04:07:58 <shachaf> A value. :-)
04:08:00 <neutrino> i'll want to define a function anyways
04:08:22 <neutrino> because it'll be complicated enough on its own
04:08:40 <mm_freak> then yeah, a named action could be better
04:08:48 <neutrino> gotcha
04:08:55 <neutrino> that's an interesting way of using fix, though
04:08:59 <mm_freak> fix is great for short loops embedded deep in an IO action
04:09:05 <mm_freak> or, well, any action
04:09:05 <neutrino> i never use fix in my code, so i'm not that well acquainted with it
04:09:22 <neutrino> so thanks for bringing that up
04:09:24 <mm_freak> since i know this use case, i use fix very often =)
04:09:28 <neutrino> ahh
04:10:51 <neutrino> in my loop, i need to carry a variable which will indicate the last time a specific check was performed. i need to perform that check every 2 seconds. how can i store this variable?
04:11:17 <neutrino> i don't think i want to use the State monad, right?
04:11:25 <mm_freak> ($ 1) . fix $ \again x -> … again (x + 1) …
04:11:58 <Digihash> Hello, is their a function that checks if an element is on the first position of a list?
04:12:05 <neutrino> mm_freak: hmm..
04:12:15 <mm_freak> Digihash: pattern matching
04:12:55 <mm_freak> case myList of (15:xs) -> "yes"; _ -> "no"
04:12:58 <neutrino> mm_freak: so explicitly carry the position?
04:13:29 <neutrino> Digihash: if you want to throw an exception if it's not, then you can do: let (15:xs) = myList
04:14:03 <mm_freak> neutrino: "fix (\again -> expr)", expr can be a function and you will have again = expr
04:14:14 <neutrino> mhm
04:14:39 <neutrino> mm_freak: i'm not sure how that relates to the question i asked just now though?
04:14:47 <neutrino> i'm probably missing something
04:14:52 <mm_freak> thanks to currying "fix (\again -> \x -> …)" becomes "fix (\again x -> …)"
04:15:21 <mm_freak> and the result is a function of one argument
04:15:43 <Digihash> ah ok, thanks
04:15:54 <mm_freak> fix (\again x -> print x >> again (x + 1)) 15
04:15:59 <mm_freak> prints 15, 16, 17, …
04:15:59 <neutrino> is there no function that implements the "fix (\again -> ... if repeat then again else return () )" framework?
04:16:45 <mm_freak> well, you could define it as a combinator, but it's not a good idea
04:17:04 <neutrino> why?
04:17:19 <mm_freak> because you would have to use a monad transformer for state
04:17:32 <mm_freak> or IORefs/STRefs
04:17:42 <neutrino> right
04:18:07 <mm_freak> you could of course use ContT for breaking out of forever
04:18:56 <neutrino> i heard ContT is complicated.
04:19:36 <mm_freak> abort = ContT . const . return
04:20:01 <mm_freak> runContT . forever $ … >> abort () >> …
04:20:35 <shachaf> ContT :-(
04:20:41 <mm_freak> but i think it's overkill to use ContT here
04:20:42 <shachaf> mm_freak: EitherT will work just as well.
04:20:55 <mm_freak> sure
04:22:43 <mm_freak> shachaf: EitherT sucks when you want to actually return something from the action =)
04:22:57 <mm_freak> EitherT Result m Result
04:23:09 <mm_freak> or even worse:  EitherT Result m a
04:23:16 <shachaf> As opposed to ContT?
04:23:20 <mm_freak> (when aborting is the only way out)
04:23:34 <mm_freak> yeah
04:23:50 <mm_freak> the difference is in runContT vs. runEitherT
04:24:02 <shachaf> What's the difference?
04:24:11 <mm_freak> runEitherT :: (Monad m) => EitherT e m a -> m (Either e a)
04:24:17 <kqr> not that it matters, but i'm curious on how the unfoldr in Data.List works. does it build the list in reverse and then turn it around prolog-style or does it append to the end of the list at each iteration?
04:24:25 <mm_freak> runContT :: ContT r m a -> m r
04:24:26 <shachaf> kqr: Neither.
04:24:36 <mm_freak> as you see, in runContT the 'a' disappears
04:24:37 <shachaf> kqr: Try building up a list in the most obvious recursive way.
04:24:41 <shachaf> That's what foldr does.
04:25:10 <kqr> shachaf, UNfoldr
04:25:14 <shachaf> kqr: Yes.
04:25:17 <kqr> but i guess that's what you meant
04:25:20 <shachaf> BUILDING UP a list
04:25:29 <kqr> oh
04:25:31 <kqr> never mind
04:25:35 <kqr> now i feel stupid once again
04:25:37 <kqr> you're right
04:25:48 <mm_freak> kqr: try to define unfoldr yourself
04:26:07 <mm_freak> just like foldr doesn't work from right to left, unfoldr doesn't do that either
04:26:20 <kqr> yeah i recalled how i did it before i abstracted the unfold pattern away into unfoldr
04:26:27 <kqr> i don't know why i thought it would build the list in reverse
04:26:41 <shachaf> I know why you thought that.
04:26:43 <shachaf> But it doesn't. :-)
04:26:55 <kqr> why did i?
04:26:59 <kqr> i'm curious
04:27:06 <dmwit> because strict languages lol
04:27:06 <lambdabot> dmwit: You have 1 new message. '/msg lambdabot @messages' to read it.
04:27:10 <dmwit> oooo, shiny
04:27:13 <dmwit> ?messages
04:27:13 <lambdabot> cmccann said 7h 9m 50s ago: thanks a lot for not finding/mentioning a solution to http://hpaste.org/74839 to save me from having to fix my own problems >:[
04:27:16 <kqr> dmwit, hahaha
04:27:32 <neutrino> i wish *i* got messages while i was away :(
04:27:40 <neutrino> @tell neutrino hi there
04:27:41 <lambdabot> You can tell yourself!
04:27:43 <neutrino> :((
04:27:46 <kqr> :(
04:27:53 <Hafydd> @tell neutrino You have a secret admirer.
04:27:54 <lambdabot> Consider it noted.
04:28:07 <neutrino> oh hi guys, what's up?
04:28:07 <lambdabot> neutrino: You have 1 new message. '/msg lambdabot @messages' to read it.
04:28:11 <neutrino> NO WAY.
04:28:14 <dmwit> Whoa, that message was a bit aggressive.
04:28:14 <neutrino> @messages
04:28:14 <lambdabot> Hafydd said 20s ago: You have a secret admirer.
04:28:30 * neutrino dies of a heart attack
04:28:39 <dmwit> ?tell cmccann I'm... sorry? Anyway, upgrade cabal-install and you should be good to go.
04:28:39 <lambdabot> Consider it noted.
04:28:58 <shachaf> dmwit: I don't think cmccann was being completely serious with the aggressiveness.
04:29:06 <dmwit> oh, okay =)
04:29:57 <dmwit> Yeah, reading as a joke seems much more in character for cmccann.
04:30:35 <shachaf> mm_freak: I'm not sure I see the advantage of ContT over EitherT.
04:31:15 <shachaf> Cmm is just a funny language.
04:31:49 <dmwit> ?tell cmccann Oh, actually, you also need to get 0.12.4 instead of 0.12.3.1 if you want 7.6 compatibility!
04:31:49 <lambdabot> Consider it noted.
04:32:10 <mm_freak> shachaf: think of a least of which you know it's not empty…  using 'head' on it somehow feels wrong anyway
04:32:24 <mm_freak> shachaf: same with an always aborting EitherT computation
04:32:24 <shachaf> Right.
04:32:25 <dmwit> ...derp, that paste is from me, not him
04:32:31 <dmwit> Wow, this joke was way too subtle for me.
04:32:58 <shachaf> mm_freak: That's exactly the reason I suggest using EitherT instead of ContT!
04:33:08 <b__> how do I hide Prelude? (I'm rewriting it myself as an exercise)
04:33:19 <dmwit> b__: {-# LANGUAGE NoImplicitPrelude #-}
04:33:20 <shachaf> import Prelude ()
04:33:31 <b__> thanks both
04:33:42 <dmwit> You can import Prelude (), yeah, though you'll still get instances of classes that you're about to override. =P
04:33:57 <mm_freak> shachaf: but the types of the runners tell a different story…  runEitherT returns an Either, from which you would ignore Right and always use Left
04:34:08 <shachaf> dmwit: Hmm, I must have missed a joke too.
04:34:10 <mm_freak> so basically you do this:  either id undefined
04:34:23 <hpaste> dmwit annotated “cabal, Paths_foo, and GHC 7.6” with “the fix, for Googlers” at http://hpaste.org/74839#a78989
04:34:24 <mm_freak> that feels just as wrong as 'head' on a non-empty list
04:34:40 <shachaf> OK, so fmap (either id id) . runEitherT
04:34:49 <dmwit> shachaf: I think the joke is sort of like the old "I found a forum post with my exact problem and the phrase 'fixed it, thanks', RAAAAAAGE".
04:34:52 <shachaf> There are never any "undefined"s to be seen.
04:34:55 <mm_freak> shachaf: also note that i'm not /suggesting/ to use ContT
04:35:12 <mm_freak> i suggest to use 'fix' or a local definition
04:35:32 <mm_freak> it's just that if i had EitherT and ContT, i'd go for ContT
04:35:46 * hackagebot mathgenealogy 1.0.0 - Discover your (academic) ancestors!  http://hackage.haskell.org/package/mathgenealogy-1.0.0 (PeterRobinson)
04:35:49 <shachaf> I would give the exact opposite advice.
04:35:57 <shachaf> If either EitherT or ContT would do, always use EitherT.
04:36:22 <shachaf> Just like I would say to use simpler things than goto instead of goto, when either would do.
04:36:30 <Philonous_> But you can express EitherT in ContT!
04:36:37 <shachaf> Philonous_: That's exactly the point.
04:36:42 <mm_freak> for the sole purpose of abortability ContT is just easier to work with, and it's more economical
04:36:42 <shachaf> You can express anything at all in ContT.
04:36:49 <Philonous_> shachaf:  So why would I want to use the less powerful one
04:36:51 <mm_freak> for EitherT you need to pull in another dependency
04:36:58 <shachaf> Either is *exactly* the "abortability monad"
04:37:06 <Digihash> I'm confused with the keyword "where" that I should put after the guards if I use a new function in it.
04:37:07 <Sgeo|web> I thought that was Maybe?
04:37:14 -Digihash(~digihash@d5152FFE1.static.telenet.be)- Like in this example:
04:37:15 <shachaf> mm_freak: That is true and sad and there's a discussion on libraries@ at this moment for merging it in.
04:38:18 <mm_freak> ContT can express anything, and is usually weird and more difficult than expressing the thing directly
04:38:26 <Digihash> isNextElement :: (Eq a) => [[a]] -> a -> Bool
04:38:26 <Digihash> isNextElement [] _     = True
04:38:26 <Digihash> isNextElement (x:xs) element | isElementOf element x && element /= head x = False
04:38:28 <Digihash>                              | otherwise 				                  = isNextElement xs element
04:38:29 <Digihash> isElementOf :: (Eq a) => a -> [a] -> Bool
04:38:31 <Digihash> isElementOf _ [] = False
04:38:33 <Digihash> isElementOf element (x:xs) | element == x = True
04:38:35 <mm_freak> however, abortion is an exception…  i think abortion is easier to express in ContT than in EitherT
04:38:35 <Digihash> 						   | otherwise    = isElementOf element xs
04:38:36 <shachaf> Digihash: Please don't paste code in here.
04:38:41 <shachaf> @paste
04:38:41 <lambdabot> Haskell pastebin: http://hpaste.org/
04:38:54 <Digihash> Yes I know, sorry. I'll paste it on their straight away
04:39:14 <shachaf> You know?
04:39:18 <shachaf> mm_freak: Either is *exactly* the exception monad!
04:39:24 <shachaf> Oh, you didn't mean "exception" in that sense.
04:39:30 <mm_freak> compare "liftM (either id id) . runEitherT" to "flip runContT return"
04:39:46 <Philonous_> mm_freak:  I'd think the real problem is that the type doesn't give you any guarantees on what kinds of effects a computation can procure any more
04:39:48 <mapf> Digihash: where is 'where'?
04:39:50 <shachaf> So use a a different run function?
04:39:58 <shachaf> Digihash: You shouldn't use tabs for indentation.
04:40:13 <shachaf> Digihash: Your file is full of tabs and they're causing your alignment to be messed up.
04:40:16 <dmwit> Tabs for indentation is fine, but you shouldn't use tabs for alignment.
04:40:21 * shachaf knew it.
04:40:22 <dmwit> (And that's what he's doing.)
04:40:32 <dmwit> So for once I agree that you shouldn't use tabs here.
04:40:36 <Sgeo|web> Why do so many text editors have the tab key default to tabs?
04:40:39 <Sgeo|web> It's gross
04:40:49 * dmwit sighs and stays silent
04:40:52 <shachaf> Let's not turn this into tabs vs. spaces.
04:40:53 * FireFly doesn't use the tab key anyway
04:41:02 <Sgeo|web> dmwit: sorry
04:41:08 <strebe> Sgeo|web: remap it if it bothers you
04:41:21 <shachaf> strebe.
04:41:24 <Digihash> Sorry, I have to eat. Mother is calling :P
04:41:31 <Digihash> See you later
04:41:33 <`ramses> Sgeo|web: backwards compatibility with typewriters? :)
04:41:39 <shachaf> `ramses.
04:41:57 <Sgeo|web> strebe: I do, immediately after I accidentally mess up the code I was working on with tabs because I am using a new editor for whatever reason and didn't think to check the tab key thing
04:42:17 <strebe> shachaf: I don't particularly care about tabs vs spaces, beyond following the convention of any particular codebase i happen to be working on
04:42:25 <dmwit> Using a new editor??? THIS MAN'S A HERETIC
04:42:35 <dmwit> one does not simply Switch Editors
04:42:43 <shachaf> This channel would be much improved by people not talking about tabs or spaces or editors in it.
04:42:59 <strebe> shachaf: well, on another topic, I'm enjoying Awodey's book
04:43:03 <shachaf> I went too far myself.
04:43:05 * dmwit notes that shachaf started it
04:43:13 <shachaf> dmwit: Guilty.
04:43:17 <Sgeo|web> I feel like I started it, sorry
04:43:29 <shachaf> dmwit: I meant to point out the error but got carried away by using the word "indentation" instead of "alignment".
04:43:30 <Sgeo|web> shachaf was simply helping someone
04:43:43 <shachaf> Anyway, no metadiscussion either.
04:44:01 <dmwit> Those tabs won't cause an error. pipes don't need to align
04:44:13 <shachaf> OK.
04:55:37 <Peaker> the freetype2 library comes along with the C code. I want to make a similar binding for freetype-gl
04:55:56 <Peaker> Can my library depend on freetype2 to use the *C code* it brings along?
04:56:16 <Peaker> also, when installing a library that includes C code that is compiled along -- does the result of the C compilation go anywhere?
04:58:58 <Peaker> ~/.cabal/lib/freetype2-0.1.1/ghc-7.6.1/libHSfreetype2-0.1.1.a   does seem to include the C symbols
04:59:48 <dcoutts_> Peaker: right, the .o files from the .c code is just linked into the lib
05:00:16 <Peaker> dcoutts, so if I just add an ordinary dependency on the Haskell lib "freetype2" in my "FreeTypeGL" library - my C code will also find the freetype symbols?
05:01:10 <Peaker> Oh, I guess at least the C header files from freetype2 will not be found :(
05:01:11 <dcoutts_> Peaker: I'm not sure we guarantee that, especially in future when we use shared libs and try to limit symbol visibility
05:01:22 <dcoutts_> Peaker: you can install headers too
05:01:41 <Peaker> so I can modify freetype2 bindings to also install the headers, you mean?
05:01:46 <dcoutts_> yes
05:01:49 <dcoutts_> Peaker: but at the moment it'll work
05:01:51 <Peaker> where do they get installed? How do I get my freetype-gl binding to find them?
05:01:59 <dcoutts_> Peaker: it's automatic
05:02:24 <Peaker> freetype2 bindings package seems to already list the .h files in Extra-sources-files
05:02:31 <Peaker> is that all that's needed to get them available for dependents?
05:02:42 <dcoutts_> it's install-includes you want
05:02:54 <dcoutts_> extra-sources-files  just puts things into the source tarball
05:03:29 <Peaker> then what makes these include dirs be available for the c compile?
05:03:32 <Peaker> the dependency specification?
05:04:16 <dcoutts_> Peaker: yes
05:04:34 <Peaker> cool, thanks :)
05:04:41 <dcoutts_> Peaker: e.g. if your code does #include "HsBase.h" then that Just Works(tm)
05:04:54 <dcoutts_> even though you never said anything about include dirs
05:05:11 <dcoutts_> it's a header installed by base, and your package depends on base, the rest is automatic
05:06:03 <Peaker> great, so no need to duplicate freetype2's C stuff in my code. But I do need to send them a patch
05:07:30 <dcoutts_> Peaker: but note, in future we may change things a bit, to do with .c code in haskell libs
05:08:01 <Peaker> Currently there's no portable OpenGL fonts library that works on Windows, except FTGL which seems to need non-free Visual Studio or so to build (if it builds at all), and GLUT which doesn't support loading arbitrary fonts, and has horrible fonts by default
05:08:12 <dcoutts_> Peaker: we might make it that by default the only symbols visible from a haskell lib are the haskell ones, but in that case we'd also allow "system" flavour libs, which follow the system's default visibility rules
05:08:23 <Peaker> dcoutts, I hope this use case (of depending on C code bundled with another package) is taken in mind
05:08:48 <dcoutts_> Peaker: that's what the system flavour would allow
05:09:06 <Peaker> ok, cool :)
05:11:05 <mSSM> I have profiled my program, and I am trying to read the .prof file properly: http://sprunge.us/fZZG if you look at that, does that mean that my program spends most time in the `uniform' and `uniform2' functions? Those are coming from mwc.random.
05:12:21 <dcoutts_> mSSM: yes
05:12:36 <Peaker> I also tried out MWC and threw it out due to performance issues
05:12:46 <mSSM> 3I am actually really surprised; I thought it would spend most time inserting things in my map-data structure, but it turns out that that almost takes no time at all.
05:12:46 <Peaker> (I didn't really need a good random in the first place)
05:13:01 <Peaker> yes, performance is often very surprising :)
05:13:47 <mSSM> Can you guys suggest how I fix that issue? As my program works now, it iterates over a couple of functions over and over, and it creates random numbers one at a time.
05:14:09 <mSSM> Would it be better to create a big vector of random numbers in one go, and then use them all up?
05:14:36 <mSSM> I chose mwc-random because it claims to be very fast.
05:14:51 <mSSM> But obviously I am doing something completely wrong.
05:15:03 <mSSM> (I am not creating the generator anew; I am passing the one I created at the very start around all the time)
05:15:09 <Peaker> dcoutts, if I use install-includes on a/b/c.h    it will make "c.h" #include'able. But what if my package's C code includes it as: #include <b/c.h> or <a/b/c.h> ?
05:20:15 <dcoutts_> Peaker: no, if you install-includes a/b/c.h then it installs it to a/b/c.h and so you #include "a/b/c.h"
05:20:36 <dcoutts_> Peaker: the file must be found in the source tree as a/b/c.h relative to the include-dirs
05:20:51 <dcoutts_> which might be . or whatever you specify it as
05:21:08 <dcoutts_> e.g. you might stick them all under an includes dir
05:21:19 <mSSM> Different question: I have a Data.Map, in which a new key-value pair gets inserted about 10^6 times for the duration of the program; how can I make sure that Haskell does that non-lazily? I.e. that the old Data.Map gets thrown away?
05:21:23 <Peaker> dcoutts, ah, great
05:21:49 <Peaker> mSSM, force the resulting map, don't keep a reference to the old map?
05:22:29 <mSSM> Peaker: That's what I would like. How can I do that?
05:23:31 <Peaker> mSSM, not sure how deep you must force the resulting Map, so you could force it deeply/completely with the deepseq package's "deepseq" or "nf"
05:25:09 <hpaste> Digihash pasted “Where keyword” at http://hpaste.org/78990
05:25:12 <Peaker> mSSM, for example, you could use: import Control.DeepSeq (force) ; newMap = force $ Map.insert foo bar oldMap   (when newMap is forced to WHNF, it will force it all the way to NF)
05:25:35 <Peaker> Digihash, make some line breaks!
05:26:20 <hpaste> Digihash pasted “Where keyword” at http://hpaste.org/78991
05:26:29 <Digihash> Wow, this is weird. on Input it looked all right, but now...
05:26:35 <Digihash> This last is better
05:26:45 <hpaste> Peaker annotated “Where keyword” with “Where keyword (annotation)” at http://hpaste.org/78990#a78992
05:27:27 <hpaste> Peaker annotated “Where keyword” with “Use infix too” at http://hpaste.org/78990#a78993
05:28:50 <hpaste> Peaker annotated “Where keyword” with “Don't use head...” at http://hpaste.org/78990#a78994
05:29:53 <mSSM> Peaker: I have the Data.Map inside a data structure (e.g. data Foo = Foo (Data.Map Int Int) Double); might it be sufficient to annotate the data type with a ! ? >> !(Data.Map Int Int) ?
05:30:08 <mSSM> I found that on http://users.aber.ac.uk/afc/stricthaskell.html#seq
05:30:23 <Peaker> mSSM, Only if Data.Map itself is deeply strict
05:30:34 <Peaker> (on the spine at least)
05:31:05 <Digihash> Why shouldn't I use the head function?
05:31:11 <Peaker> > head []
05:31:12 <lambdabot>   *Exception: Prelude.head: empty list
05:31:16 <Peaker> Digihash, that's why ^^
05:31:26 <Peaker> it makes Haskell programs crash :(
05:31:27 <Digihash> ah ok, thank you
05:32:33 <mSSM> Peaker: with deeply strict you don't necessarily mean anything in relation to the DeepSeq package, do you? I am talking about http://www.haskell.org/onlinereport/decls.html#strictness-flags
05:32:39 <Digihash> yes it did that and I was trying to deal with this problem. Thanks for the solution
05:32:44 <`nand`> Is it in any way possible, with availability to all unsafe* tricks and full knowledge of GHC internals, to reify a recursive definition like “let x = [1] ++ x in x” into some (non-recursive) description of a graph?
05:35:40 <Digihash> Sorry Peaker, I don't understand why you use the three question marks before the where keyword
05:36:18 <Digihash> ah ok, that's not a solution I see :P
05:38:32 <ypo> mapf: are you there?
05:38:35 <hpaste> “`ramses” annotated “Where keyword” with “Simplify a bit” at http://hpaste.org/78990#a78995
05:39:19 <`ramses> Digihash: ^^ just match on the tail instead of the whole list and then excluding the head
05:40:54 <Peaker> very weirdly, the freetype library exports all of its API under the directory "internal"
05:41:17 <Digihash> But in that solution you don't check if the first element is equal to the element I give with the function
05:42:02 <`ramses> you checked whether the element appears in the list but is different from the head, that's the same as checking whether it appears in the tail, isn't it?
05:43:43 <Industrial> Hi. I'm not great (yet!) with haskell but I thought (coming from NodeJS mostly) maybe webprogramming is a good starting point. Any thoughts on what the 'easiest' way to receive/send HTTP requests with haskell is? Is there a framework close to sinatra (ruby) in simplicity?
05:44:50 <neutrino> i wouldn't say so.
05:44:50 <lambdabot> neutrino: You have 1 new message. '/msg lambdabot @messages' to read it.
05:45:42 <Industrial> oh, I see https://github.com/nfjinjing/miku now.
05:46:01 <`ramses> neutrino: are you commenting on what I said?
05:46:03 <neutrino> Industrial: you're much better served learning some simpler things first. pretty much all web frameworks out there use very complicated concepts and you'll have many setbacks.
05:46:12 <neutrino> i'm commenting on Industrial's question
05:46:15 <`ramses> neutrino: ah ok, you aren't :)
05:46:21 <neutrino> sorry :)
05:46:39 <Peaker> dcoutts, btw, why does cabal not print anything at all about building C code? Just mysteriously taking a long time
05:46:43 <`ramses> neutrino: I already took my piece of paper to proof my statement :)
05:46:56 <neutrino> `ramses: ok :)
05:47:55 <dcoutts_> Peaker: no reason
05:48:39 <dcoutts_> Peaker: it says "Building C Sources...", though I think only at -v level
05:49:10 <Digihash> `ramses, yes I can follow you. But I don't really understand what I should do with the isNextElement ([] : xs) element = ???
05:49:35 <`ramses> Digihash: depends on what you want the function to do :)
05:50:00 <Peaker> dcoutts, could be nice to even get the actual CC commands being executed, similarly to ghc --make's prints
05:50:05 <`ramses> I guess you want to check whether the element appears in any of the tails of the lists
05:50:16 <dcoutts_> Peaker: it will do that if you run with -v
05:50:19 <`ramses> right?
05:50:43 <Peaker> dcoutts, ah, ok. IMO that would interest a casual non-verbose user too, given that it can take a long time
05:51:30 <mSSM> Profiling tells me, that the bulk of my memory is in something I didn't expect at all: in my structure `data Foo = Foo (Data.Map Int Int) Bar' and `data Bar = Bar Double Double', all the memory is in `Bar'. In my program in each run I `insert' a new value in the Data.Map, and the recalculate `Bar (a+a') (b+b')' and then I store everything in a new Foo.
05:51:33 <neutrino> Industrial: if i were you i'd do some systems programming, haskell seems to be fairly good for that
05:51:42 <neutrino> Industrial: it's an easy curve to learn it imo
05:51:52 <Digihash> Not really. I want to check if the element is the next element I should take. So if it stands in the list and it's on the first place, then it should return true
05:52:16 <mSSM> How can I make `Bar' strict and ensure that it is `deeply strict'? These concepts don't tell me much. :(
05:52:55 <`ramses> Digihash: that's not what you've got now, I think
05:53:08 <`ramses> you've got a collection of lists and an element as input, right?
05:53:21 <`ramses> when should the function return true?
05:53:24 <dcoutts_> Peaker: I guess historically the .c code people included into their libs were trivial short bits for ffi shims
05:53:48 <`ramses> (or when should it return false, if that's easier to specify)
05:53:59 <Peaker> dcoutts, and then people figure out they can put whole C libs in there to avoid C deps :)
05:55:07 <etrepum> mSSM: have you seen http://www.haskell.org/haskellwiki/Performance/Data_types ?
05:57:21 <mSSM> etrepum: thank you, I will give it a shot
05:57:53 <mm_freak> apropos systems programming…  is there any functional language that is suitable for low level code?  like writing a kernel or device drivers?
05:58:24 <Industrial> neutrino: currently I'm still having trouble seeing parenthesis that were left out by using $ and some other crazy operators in other people's code.
05:58:54 <dcoutts_> mm_freak: there's some research on haskell-like or haskell-extended languages for OS like code
05:58:58 <mm_freak> Industrial: thanks for making my point =)
05:59:00 <osfameron> mm_freak: isn't the main issue memory fragmentation?  i.e. not the code, but the memory footprint
05:59:44 <dcoutts_> mm_freak: see http://programatica.cs.pdx.edu/House/
05:59:45 <neutrino> Industrial: yeah, you have to run into this yourself to learn it
05:59:47 <osfameron> well, that wouldn't be a problem for kernel drivers, but maybe for devices
05:59:56 <neutrino> mm_freak: there's atom
06:00:02 * osfameron would like a functional language for arduino et al
06:00:13 <neutrino> mm_freak: i always wanted a version of haskell with managed memory..
06:00:21 <neutrino> mm_freak: it would be most amazing
06:00:24 <doomlord> isnt the issue for low level code that you're interfacing with devices that dont use the language
06:00:31 <neutrino> no
06:00:32 <neutrino> it is not
06:00:33 <mm_freak> dcoutts_: but nothing practical?  it doesn't have to be lazy
06:00:51 <doomlord> e.g- if you're writing a graphics card driver, you are writing command lists- - you need to reason about their memory layout and timing
06:00:51 <dcoutts_> mm_freak: practical in what sense? they have an OS running, drivers, etc
06:00:57 <mSSM> How does a Bang pattern work with record syntax? data Foo = Foo { bar :: !Double } ?
06:00:58 <neutrino> haskell has full access to any memory registers, either directly or via ffi
06:01:00 <parcs`> mm_freak: check out the ATS programming language
06:01:14 <neutrino> mSSM: bar is evaluated when set iirc
06:01:28 <mm_freak> dcoutts_: i'm aware of house, but that one is no longer maintained…  there is a successor project, but nothing usable emerged from it yet
06:01:30 <neutrino> parcs`: i have never used ATS. is it an old language?
06:01:31 <parcs`> its syntax is terrible but it's what you're looking for
06:01:50 <Peaker> dcoutts, if my C code depends on the OpenGL headers, will it be enough to depend on the haskell-platform to get the #include's available?
06:01:53 <mm_freak> parcs`: ATS seems to be an imperative language
06:01:53 <dcoutts_> mm_freak: oh ok, in that sense
06:01:59 <parcs`> neutrino: it's a research language in active development
06:02:17 <neutrino> parcs`: oh.
06:02:19 <dcoutts_> Peaker: you can't depend on the haskell-platform, only on the individual packages
06:02:25 <neutrino> parcs`: i have run across mentions of it previously
06:02:30 <neutrino> i should check it out one day
06:03:15 <Peaker> dcoutts, right. silly question :) I guess I meant: If a Windows user had installed the Haskell Platform -- will it have the GL C headers anywhere or does the Windows user need to install the C-side of OpenGL manually?
06:03:30 <parcs`> mm_freak: it's as imperative as ML is
06:03:42 <neutrino> mm_freak: try http://hackage.haskell.org/package/atom/
06:04:00 <Peaker> dcoutts, and if the headers are there -- is it enough to depend on the GL packages to get them?
06:04:08 <mm_freak> neutrino: i know atom, but that seems to be very low level
06:04:29 <mSSM> Adding a bang pattern didn't change anything. :(
06:04:35 <mm_freak> neutrino: and you can have haskell with manually managed memory by linking to your own RTS, but that's going to be a lot of work
06:04:35 <mSSM> Same space comsumption
06:04:40 <tomeo> If I make a function f x y = x + y like this instead: f = (+), have I curried it?
06:04:42 <Nereid> Peaker: I see the gl headers in my platform installation on windows
06:04:45 <doomlord> never mind functional - even imperative with GC isn't suitable for the lowest level parts
06:04:57 <mm_freak> tomeo: it's curried either way
06:05:05 <doomlord> or even c/c++ using a memory manager (e.g, you have to write the memory manager itself)
06:05:11 <tomeo> mm_freak: oh okay
06:05:12 <mm_freak> tomeo: an uncurried version would look like this:  f (x, y) = x + y
06:05:15 <Peaker> Nereid, any chance you'll be willing to test my Haskell bindings for freetype-gl on Windows? I don't have access to a Windows machine
06:05:29 <mm_freak> tomeo: in fact the two definitions you gave are equivalent
06:05:32 <Nereid> uh
06:05:45 <Nereid> right now?
06:06:02 <tomeo> mm_freak: what makes f (x, y) = x + y uncurried?
06:06:17 <mm_freak> tomeo: you can't partially apply it in the currying sense
06:06:22 <mm_freak> you can't write "f 3" to get a function
06:06:27 <neutrino> mm_freak: no such rts exists yet, however..
06:06:48 <mm_freak> neutrino: yes there does exist one such RTS:  house
06:06:53 <neutrino> oh
06:06:54 <neutrino> ok
06:06:56 <tomeo> thanks mm_freak
06:07:13 <mm_freak> tomeo: currying can be summarized by two equations
06:07:22 <mm_freak> 1. type level:  a -> b -> c = a -> (b -> c)
06:07:29 <mm_freak> 2. value level: f x y = (f x) y
06:07:47 <Peaker> Nereid, heh, or some other time if this isn't a good time
06:08:26 <Nereid> Peaker: I imagine it would work, the package.conf.d lists the directory containing HsOpenGL.h
06:08:54 <Nereid> in include-dirs
06:09:13 <tomeo> mm_freak: but anything which can be called with less than max parameters and produce a function will be curried whilst anything that can not do that is uncurried, have I understood that correctly?
06:09:55 <mm_freak> tomeo: shorter and more to the point:  any function that results in a function is curried
06:10:10 <tomeo> mm_freak: thanks
06:10:20 <bitonic> ghc-mod trips over a .cabal file where the executable refers to the library in the same cabal file: <https://github.com/bitonic/mfixed/blob/master/mfixed.cabal#L42>.  is there any way to fix this?
06:10:27 <mm_freak> so you can even have currying in languages like javascript:  function f(x) { return function(y) { return x + y; }; }
06:10:27 <bitonic> cabal itself has no problems building it
06:11:14 <tomeo> mm_freak: but don't you mean any function that _can_ result in a function?
06:11:40 <Nereid> what's the difference?
06:11:46 <neutrino> tomeo: a function that can result in a function is a function that results in a function.
06:11:52 <tomeo> oh :)
06:11:53 <`ramses> tomeo: the return type is fixed..
06:12:17 <Nereid> forall f. Functor f => X -> f Y
06:12:22 <tomeo> hm, don't know what I was thinking
06:12:24 <neutrino> @type (+)
06:12:25 <lambdabot> Num a => a -> a -> a
06:12:26 <Nereid> *can* result in a function
06:12:27 <`ramses> any function which takes multiple parameters is a function which actually returns a function
06:12:29 <Nereid> but doesn't have to
06:12:38 <neutrino> the return type of (+) is Num a => a -> a.
06:12:57 <`ramses> Nereid: that's not true, if you supply all parameters you just directly apply the function returned by (+)
06:12:59 <mm_freak> tomeo: well, in a static sense that can only happen for polymorphic functions
06:13:03 <mm_freak> tomeo: like id :: a -> a
06:13:18 <Nereid> I don't think it's best to ask whether something is curried or uncurried.
06:13:25 <Nereid> you can curry things. and you can uncurry things.
06:13:29 <mm_freak> without polymorphism you either result in a function or you don't statically
06:13:35 <neutrino> anyways
06:13:39 <neutrino> this is really bike shedding
06:13:42 <neutrino> i should leave
06:13:47 <Nereid> no, it's something else
06:13:48 <Nereid> :P
06:13:56 <Peaker> Nereid, if it's not too much trouble, I'd still love to actually see it work on Windows :)  If you can install https://github.com/Peaker/freetype2   and then install: https://github.com/Peaker/FreeTypeGL    -- that would be awesome :)
06:13:59 <neutrino> :)
06:14:13 <mm_freak> tomeo: for example 'id sin' is obviously a function, but that's determined statically
06:14:20 <mSSM> If I have a heap profile like this: http://ompldr.org/vZ21ubg/mising.png can I infer from this that `Observables' is not strictly evaluated?
06:14:35 <tomeo> mm_freak: yes
06:14:44 <Peaker> mSSM, why?
06:15:25 <etrepum> `ramses: it doesn't matter whether it "directly" applies the function (f x y) or whether it calls ((f x) y), they're equivalent. The "direct" part is just a compiler optimization.
06:15:39 <mSSM> Peaker: because technically this Observables thing is only storing 2 Doubles inside of it
06:15:46 <mSSM> Peaker: it shouldn't be so huge
06:15:52 <mm_freak> tomeo: but you can also decide at runtime whether to result in a function or not
06:15:56 <mm_freak> (even in haskell)
06:16:21 <Peaker> mSSM, maybe you have a growing number of Observables?
06:16:53 <mSSM> Peaker: And it is being build like that: updateObservables (Observables e m) de dm = Observables (e+de) (m+dm)
06:16:54 <Peaker> mSSM, can you paste your code somewhere?
06:17:07 <Peaker> mSSM, what is the Observables data constructor like?
06:17:15 <Peaker> mSSM, does it use strict fields?
06:17:40 <`ramses> etrepum: I meant that even if you do (+) 3 4, that (in theory) (+) returns a function (i.c. (3+)) which is subsequently applied to 4
06:17:47 <hpaste> mSSM pasted “simulation” at http://hpaste.org/78996
06:18:17 <`ramses> etrepum: although the compiler might optimize that away, but that's an implementation detail
06:18:29 <mSSM> Peaker: That's the program; the interesting parts are data Observables (they are strict), and then line 85
06:18:37 <mm_freak> (i really wish that GHC starts supporting the 'exists' keyword at some point)
06:18:51 <etrepum> `ramses: yep
06:18:54 <parcs`> apparently i have fundamental misconceptions of how the alternative instance of STM works. can anyone explain why this script outputs [True,False] indefinitely http://fpaste.org/w2Ic/
06:19:26 <Peaker> mSSM, why: (***) (foo) (bar)  and not    foo *** bar ?
06:20:07 <mSSM> Peaker: That was for me at first; I wasn't comfortable with *** and wanted it to jump in my face...
06:20:12 <mm_freak> parcs`: probably because 'many' is not defined for STM
06:20:42 <parcs`> what do you mean?
06:20:49 <parcs`> i should not use many with STM?
06:20:57 <mm_freak> parcs`: most Alternatives don't implement some/many
06:21:23 <mm_freak> it's mostly a parser thing
06:21:26 <mSSM> Peaker: Thanks for looking at it; please ask if I need to explain something.
06:21:29 <bxc> i have some files that ghc likes but haddock doesn't ... eg haddock is getting upset about a lambda expression, and if I put $ in the front to make haddock happy, then hlint tells me to take it away
06:21:33 * bxc crosses eyes
06:21:53 <bxc>    (join $ (for [0..n] \x ->
06:22:01 <bxc> seems to upset haddock
06:22:58 <Peaker> Hmm. I don't know if Data.Map.Strict has a strict or lazy spine
06:23:01 <neutrino> ignore them
06:23:22 <neutrino> linters are tools that should support you, not dictate your work
06:23:31 <bxc> yeah i know that much
06:23:41 <bxc> more interestingto me is tha thaddock is getting upset on sytnax that ghc is ok with
06:23:43 <mSSM> Peaker: but either way, Data.Map does not actually take up so much space.
06:23:52 <mm_freak> parcs`: you could implement your own 'many' though
06:24:01 <neutrino> bxc: dunno about that, sorry :\
06:24:01 <twanvl> I think Data.Map always has a strict spline
06:24:03 <Peaker> mSSM, try making all of your record fields strict as an experiment?
06:24:06 <rwbarton> mSSM: you don't update Observables strictly within an Ising
06:24:32 <bxc> neutrino: me neither - i odn't know the syntax in enough of a language-lawyer way to know if haddocsk wrong or if ghc is accepting more than required
06:24:32 <mSSM> rwbarton: do you mean line 102?
06:24:36 <mm_freak> parcs`: although many1 probably makes more sense and is easier to define:  many1 c = liftA2 (:) c (many1 c <|> pure [])
06:24:45 <mSSM> rwbarton: when I use the Ising constructor?
06:24:58 <mSSM> Peaker: do you mean the Ising record fields as well?
06:25:09 <Peaker> mSSM, yeah
06:25:10 <parcs`> mm_freak: no alternative instance in 'base' explicitly implements some and many from what i see
06:25:22 <mm_freak> many1 c' = let c = liftA2 (:) c' (c <|> pure []) in c
06:25:25 <rwbarton> mSSM: yes
06:25:36 <parcs`> mm_freak: i don't see why stm is special in that regard
06:25:40 <mSSM> Peaker: should I also make the generator strict? I am not sure if that would do weird stuff with it.
06:26:07 <mm_freak> parcs`: is it?
06:26:28 <mSSM> rwbarton: and I can update them strictly by making it strict in the Ising data type?
06:26:58 <rwbarton> that's one way
06:27:05 <Peaker> mSSM, doubt it would cause any trouble
06:27:10 <rwbarton> probably the best way
06:28:00 <mSSM> Peaker, rwbarton YAY
06:28:28 <mSSM> Peaker, rwbarton thank you both; I have made only the Observables field strict, and it pushed the size down to just 6k byes
06:28:29 <rwbarton> parcs`: what do you mean "indefinitely"? True, False, True, False, ...?
06:28:34 <mSSM> i.e. less than 1%
06:28:45 <mSSM> amazing
06:28:51 <parcs`> rwbarton: [True,False]\n[True,False]
06:29:01 <rwbarton> oh, huh
06:29:28 <Peaker> is there a good package for homogenous pairs/triplets/etc?
06:29:50 <Peaker> ideally also strict, like: Vector2 a = Vector2 !a !a   with instances for Num, Applicative, etc.
06:31:03 <mSSM> Now i just need to figure out how to bring down the massive time consumption of the random number generation.
06:31:37 <Nereid> Peaker: I don't know how to build this.
06:31:58 <mm_freak> parcs`: i find it weird though…  i wonder what the default definition of 'many' is
06:32:02 <Peaker> Nereid, "cabal install" in each directory doesn't work?
06:32:15 <Nereid> freetype2 installs
06:32:20 <Nereid> but for FreetypeGL:
06:32:29 <Philonous_> @src many
06:32:29 <lambdabot> Source not found. Where did you learn to type?
06:32:30 <Nereid> looks like first of all we'd need to switch to extra-libraries: opengl32, glu32 for windows
06:32:31 <rwbarton> parcs`, sounds buggy imo
06:32:39 <Nereid> so now it doesn't complain about missing libraries
06:32:57 <Nereid> but then,
06:33:26 <mSSM> My programs spends about 90% of it's time in calling `uniform' from mwc.random; what could I do to reduce that time? Could this be related to lazy evaluation? Is there a fast high-quality PRNG?
06:33:33 <Peaker> Nereid, hmm.. maybe without Extra-libraries at all it would work because of the dependency on GL?
06:33:42 <Nereid> no, the C library.
06:33:54 <Nereid> it's libGL and libGLU on linux, but libopengl32 and libglu32 on windows
06:33:58 <mapf> :t listT
06:33:59 <lambdabot> Not in scope: `listT'
06:34:01 <parcs`> @src some
06:34:01 <lambdabot> some v = some_v
06:34:01 <lambdabot>   where many_v = some_v <|> pure []
06:34:01 <lambdabot>         some_v = (:) <$> v <*> many_v
06:34:03 <Peaker> Nereid, Yeah, but adding a dep to the Build-depends also adds its extra-libs/etc to the C build
06:34:12 <mapf> listT :: TypeQ  -- Defined in `Language.Haskell.TH.Lib'
06:34:12 <mapf>  
06:34:13 <Nereid> hmm
06:34:16 <mapf> why?
06:34:34 <Peaker> Nereid, I had left the "Extra-libraries" field there - but it probably should be removed once I added the "OpenGL" package to Build-depends
06:34:38 <mapf> why not listT :: [Type] -> TypeQ or something
06:34:40 <rwbarton> can you test do { a <- readTQueue; b <- readTQueue; cs <- fmap (:[]) readTQueue <|> return []; return (a:b:cs) }
06:34:52 <Nereid> ok
06:34:53 <Nereid> well
06:35:14 <Nereid> anyway, after that,
06:35:15 <mm_freak> parcs`: i think it shouldn't output indefinitely in either case
06:35:27 <mm_freak> parcs`: perhaps that's a but in TQueue
06:35:33 <mm_freak> but → bug
06:36:05 <parcs`> rwbarton: that prints [True,False] just once
06:36:37 <Nereid> Peaker: well it's looking more like freetype-gl itself doesn't build on windows with mingw
06:36:46 <mm_freak> parcs`: could you try with TMVar?
06:36:51 <Nereid> instead only in VS
06:37:56 <Peaker> Nereid, what build error do you get?
06:38:03 <Nereid> well
06:38:21 <Nereid> it defines round in platform.c even though mingw's math.h provides it already, so error there. and then it can't find ft2build.h and then I gave up
06:38:37 <parcs`> mm_freak: 'atomically $ many $ takeTMVar q' returns [True] once and then [] forever
06:39:16 <Peaker> Nereid, ok... thanks!
06:39:20 <Nereid> oh also I had to install the glew headers.
06:39:30 <Nereid> and I'd probably have to install the glew libraries too
06:39:37 <mm_freak> parcs`: i'd say don't use some/many with STM
06:39:37 <Peaker> Nereid, I guess I need to get myself access to a Windows machine to debug all that
06:39:46 <Nereid> that would probably be easier than doing this over irc yes
06:39:47 <Nereid> :p
06:39:58 <Peaker> Nereid, thanks for the trouble so far :)
06:39:58 <parcs`> mm_freak: when i use TChan instead of TQueue it prints [True,False] just once.. so it probably is some kind of regression caused by TQueue
06:40:54 <absence> i was reading about the euterpea (haskore based) library and saw some code that checks a type at runtime and possibly fails. is this the prefered way to make the check static or are there better ways? http://hpaste.org/78997
06:41:10 <mm_freak> parcs`: i haven't used TQueue, so i can't report similar experiences…  you should probably report that to the STM maintainer
06:41:22 <Peaker> I wonder if WindowsAzure.com would let me have a Windows machine to toy with for free :)
06:42:54 <otters> @pl foldl (\a b -> b a)
06:42:54 <lambdabot> foldl (flip id)
06:43:21 <otters> @pl \x y -> (x,y) == ('q','u')
06:43:21 <lambdabot> flip flip ('q', 'u') . ((==) .) . (,)
06:43:36 <parcs`> rwbarton, mm_freak http://fpaste.org/7VDV/
06:45:00 <otters> @pl \(a,b) -> (b,a)
06:45:00 <lambdabot> uncurry (flip (,))
06:46:55 <mm_freak> parcs`: i think using 'many' is potentially dangerous
06:46:57 <`ramses> :t flip flip
06:46:59 <lambdabot> b -> (a -> b -> c) -> a -> c
06:47:02 <mm_freak> even if it really works
06:47:37 <Philonous_> mm_freak:  What should be dangerous about it?
06:47:56 <mm_freak> lot of livelock potential
06:48:45 <Nereid> :t flip . (flip .)
06:48:46 <lambdabot> (a -> a1 -> b -> c) -> b -> a -> a1 -> c
06:49:11 <Nereid> :t flip . (flip .) . flip
06:49:12 <lambdabot> (a1 -> a -> b -> c) -> b -> a -> a1 -> c
06:49:33 <Nereid> :t flip . (flip .) . (flip .)
06:49:35 <lambdabot> (a -> b -> a1 -> c) -> b -> a -> a1 -> c
06:49:46 <Nereid> oh I guess that's just flip
06:49:58 <Nereid> :t (flip .) . flip . (flip .)
06:49:59 <lambdabot> (a -> b -> b1 -> c) -> b1 -> b -> a -> c
06:50:22 <Nereid> hmm
06:50:45 <Nereid> :t (flip .:)
06:50:46 <lambdabot> (Functor g, Functor f) => f (g (a -> b -> c)) -> f (g (b -> a -> c))
06:50:49 * hackagebot diff3 0.1.0.0 - Perform a 3-way difference of documents  http://hackage.haskell.org/package/diff3-0.1.0.0 (OliverCharles)
06:50:49 <Nereid> agh
06:51:16 <Nereid> :t (flip .) . flip . (flip .)
06:51:18 <lambdabot> (a -> b -> b1 -> c) -> b1 -> b -> a -> c
06:51:21 <Nereid> :t flip . (flip .) . flip
06:51:22 <lambdabot> (a1 -> a -> b -> c) -> b -> a -> a1 -> c
06:51:25 <Nereid> yes.
06:51:59 <Nereid> flip ~ (12), (flip .) ~ (23), (flip .:) ~ (34), etc.
06:52:02 <Nereid> for permutations of arguments.
06:52:17 <Nereid> and everyone knows that (23)(12)(23) = (12)(23)(12)
06:53:06 <Nereid> :t flip . (flip.)
06:53:07 <lambdabot> (a -> a1 -> b -> c) -> b -> a -> a1 -> c
06:53:13 <Nereid> :t (flip.) . flip
06:53:14 <lambdabot> (a -> b1 -> b -> c) -> b1 -> b -> a -> c
06:53:37 <Nereid> :t id `asTypeOf` (flip.).(flip.)
06:53:38 <lambdabot>     Precedence parsing error
06:53:38 <lambdabot>         cannot mix `asTypeOf' [infixl 9] and `.' [infixr 9] in the same infix expression
06:53:43 <Nereid> :t id `asTypeOf` ((flip.).(flip.))
06:53:44 <lambdabot> Functor f => f (b -> a -> c) -> f (b -> a -> c)
06:53:46 <Nereid> bah.
06:54:21 <Nereid> :t flip . (flip.) . (flip.:)
06:54:22 <lambdabot> (a -> a1 -> a2 -> b -> c) -> b -> a -> a1 -> a2 -> c
06:54:32 <Nereid> :t (flip.:) . (flip.) . flip
06:54:33 <lambdabot> (a -> b2 -> b1 -> b -> c) -> b2 -> b1 -> b -> a -> c
06:54:49 <Nereid> :t (flip.:) . flip
06:54:50 <lambdabot> (a1 -> b1 -> a -> b -> c) -> b1 -> a1 -> b -> a -> c
06:54:52 <Nereid> :t flip . (flip.:)
06:54:54 <lambdabot> (a -> b -> a1 -> b1 -> c) -> b -> a -> b1 -> a1 -> c
06:55:01 <Nereid> I don't know why I'm doing this
06:56:10 <Nereid> :t (flip . (flip.:)) `asTypeOf` ((flip.:) . flip)
06:56:11 <lambdabot> (a -> b -> a1 -> b1 -> c) -> b -> a -> b1 -> a1 -> c
06:56:16 <Nereid> :t (flip . (flip.:)) `asTypeOf` ((flip.) . flip)
06:56:17 <lambdabot> (b1 -> b -> b1 -> b1 -> c) -> b -> b1 -> b1 -> b1 -> c
06:56:23 <Nereid> :v
06:57:33 <Nereid> so if you want to swap the second and fourth arguments, say.
06:57:47 <Nereid> :t (flip.) . (flip.:) . (flip.)
06:57:48 <lambdabot> Functor f => f (a1 -> a -> b -> c) -> f (b -> a -> a1 -> c)
06:57:53 <Nereid> oops.
06:57:57 <Nereid> oh yeah. duh
06:58:02 <Nereid> it's right.
06:58:18 <Nereid> @let f12 = Prelude.flip
06:58:20 <lambdabot>  Defined.
06:58:24 <Nereid> @let f23 = (Prelude.flip.)
06:58:25 <lambdabot>  Defined.
06:58:34 <Nereid> @let f34 = (f23.)
06:58:35 <lambdabot>  Defined.
06:58:38 <Nereid> @let f45 = (f34.)
06:58:39 <lambdabot>  Defined.
06:58:46 <Nereid> :t f23 . f34 . f23
06:58:47 <lambdabot> Functor f => f (a1 -> a -> b -> c) -> f (b -> a -> a1 -> c)
06:58:55 <Nereid> :(
06:58:57 <Nereid> urgh
06:59:06 <Nereid> @let f23 = (f12 Prelude..)
06:59:07 <lambdabot>  <local>:10:1:
06:59:07 <lambdabot>      Multiple declarations of `f23'
06:59:07 <lambdabot>      Declared at: <local>:...
06:59:07 <Nereid> :t f23
06:59:08 <lambdabot> Functor f => f (a -> b -> c) -> f (b -> a -> c)
06:59:12 <Nereid> @undefine
06:59:15 <Nereid> :t flip
06:59:16 <lambdabot> (a -> b -> c) -> b -> a -> c
06:59:20 <Nereid> @let f12 = flip
06:59:22 <lambdabot>  Defined.
06:59:31 <Nereid> @let f23 = (Prelude..) f12
06:59:32 <lambdabot>  <local>:2:7:
06:59:32 <lambdabot>      Not in scope: `Prelude..'
06:59:32 <lambdabot>      Perhaps you meant one of th...
06:59:42 <Nereid> :(
07:00:05 <Nereid> @let f23 = \f x -> f12 f x
07:00:07 <lambdabot>  Defined.
07:00:09 <Nereid> @let f34 = \f x -> f23 f x
07:00:10 <lambdabot>  Defined.
07:00:16 <Nereid> @let f45 = \f x -> f34 f x
07:00:18 <lambdabot>  Defined.
07:00:29 <Nereid> :t f12 . f34 . f45 . f34 -- swap 1 and 2, and 3 and 5
07:00:31 <lambdabot> (b -> a -> c) -> b -> a -> c
07:00:37 <Nereid> oops
07:00:38 <Nereid> :t f34
07:00:39 <hpaste> Digihash pasted “on-exhaustive patterns in function getFirsts” at http://hpaste.org/78999
07:00:39 <lambdabot> (a -> b -> c) -> b -> a -> c
07:00:44 <Nereid> I'm an idiot
07:00:47 <Nereid> @undefine
07:00:49 * hackagebot uuid 1.2.9 - For creating, comparing, parsing and printing Universally Unique Identifiers  http://hackage.haskell.org/package/uuid-1.2.9 (AntoineLatter)
07:01:20 <Nereid> @let c f g x = f (g x); f12 = flip; f23 = c f12; f34 = c f23; f45 = c f34
07:01:21 <lambdabot>  <local>:1:38:
07:01:21 <lambdabot>      Ambiguous occurrence `c'
07:01:21 <lambdabot>      It could refer to either `L...
07:01:37 <Nereid> :t (<<<)
07:01:38 <lambdabot> Control.Category.Category cat => cat b c -> cat a b -> cat a c
07:01:45 <Nereid> :t (<<<) flip
07:01:46 <lambdabot> (a -> a1 -> b -> c) -> a -> b -> a1 -> c
07:02:10 <Nereid> @let f12 = flip; f23 = (f12 <<<); f34 = (f23 <<<); f45 = (f34 <<<)
07:02:12 <lambdabot>  Defined.
07:02:15 <Nereid> :t f34
07:02:17 <lambdabot> (a -> a1 -> a2 -> b -> c) -> a -> a1 -> b -> a2 -> c
07:02:23 <Nereid> :t f12 . f34 . f45 . f34 -- swap 1 and 2, and 3 and 5
07:02:24 <lambdabot> (a -> b -> a3 -> a2 -> b1 -> c) -> b -> a -> b1 -> a2 -> a3 -> c
07:02:31 <Digihash> I pasted my solution of some problem in hpaste in the link above. Ghci returns as error "Non-exhaustive patterns in function getFirsts", but I really don't see where I'm wrong.
07:02:42 <Nereid> :t f12 . f23
07:02:43 <Digihash> Do you guys know what I'm doing wrong?
07:02:43 <lambdabot> (a -> a1 -> b -> c) -> b -> a -> a1 -> c
07:03:16 <bk_> hi everyone
07:03:18 <Nereid> Digihash: missing getFirsts ([]:xs)
07:03:31 <Guest5271> hi everyone
07:05:06 <Nereid> hpaste should highlight tab characters in an annoying red colour so that people stop using tabs
07:05:20 <Nereid> ;)
07:05:41 <absence> is this the prefered way to make a dynamic type check static or are there better ways? http://hpaste.org/78997
07:06:22 <Nereid> what's a dynamic type check?
07:06:56 <Digihash> thanks
07:06:57 <absence> one that occurs runtime. the "error" part of the upper code
07:07:11 <Nereid> that's not a type error
07:08:04 <absence> Nereid: exactly, or it would be static :)
07:08:29 <Nereid> note that the two versions of graceNote have different types.
07:08:46 <Nereid> with the bottom probably preferable.
07:09:12 <neutrino> guys
07:09:15 <Nereid> guy
07:09:21 <absence> Nereid: ah cool, the different type was what made me wonder if i was on the wrong track
07:09:37 <neutrino> how can i wrap a file handle so that i can write to it, but e.g. every letter gets uppercased?
07:09:42 <absence> Nereid: i found the upper code in a lib and thought it looked strange
07:09:47 <neutrino> i would like to use the wrapped handle with e.g. hPrintf
07:10:18 <Nereid> I don't think you can do that with a Handle.
07:10:58 <neutrino> you can in python
07:11:02 <neutrino> T_T
07:11:12 <neutrino> @faq can Haskell wrap file handles?
07:11:12 <lambdabot> The answer is: Yes! Haskell can do that.
07:11:20 <Nereid> Handles are pretty low level things in haskell
07:11:38 <neutrino> you just want to put a chasm between me and my dear beloved haskell
07:11:47 <neutrino> you're just saying that!!
07:11:54 * neutrino runs out of the room crying
07:12:25 <Nereid> Handles are essentially file descriptors.
07:12:34 <neutrino> *cough* yeah i know
07:12:42 <neutrino> meh.
07:12:46 <neutrino> i'll have to roll my api.
07:16:13 <`ramses> lambdabot doesn't respond to my /msg's anymore :(
07:16:35 <neutrino> does to mine
07:16:36 <Nereid> are you forgetting your @?
07:16:51 <`ramses> I get a query window, but no response
07:17:27 <`ramses> it worked an hour ago, but not anymore
07:18:52 <neutrino> @hoogle Monad m => (a -> m b) -> [a] -> m b
07:18:53 <lambdabot> Prelude mapM_ :: Monad m => (a -> m b) -> [a] -> m ()
07:18:53 <lambdabot> Control.Monad mapM_ :: Monad m => (a -> m b) -> [a] -> m ()
07:18:53 <lambdabot> Control.Monad forM_ :: Monad m => [a] -> (a -> m b) -> m ()
07:19:41 <`ramses> neutrino: how would you want that list to be collapsed?
07:19:47 <merijn> `ramses: What are you querying? "> " commands and ":t" don't work
07:19:56 <merijn> (in privmsg)
07:19:58 <`ramses> ah! why not?
07:20:02 <`ramses> I was using :t
07:20:11 <merijn> Use @type to do the same in privmsg
07:20:26 <`ramses> ok, @type does work :)
07:20:36 <neutrino> merijn: > does work.
07:20:54 <merijn> neutrino: Oh, maybe, I was just blabbing off the top of my head
07:21:02 <neutrino> just saying :)
07:21:21 <`ramses> yeah > seems to work but :t doesn't. Thanks for pointing that out :)
07:21:33 <`ramses> any particular reason you know of? Seems like an odd restriction
07:21:43 <Nereid> neutrino: nothing of exactly the type you gave could actually exist; what would f _ [] be?
07:21:45 <hpaste> Digihash annotated “empty list error” with “empty list error (annotation)” at http://hpaste.org/78912#a79000
07:21:48 <merijn> I have no clue :p
07:22:07 <neutrino> Nereid: i'm happy with mapM_
07:22:14 <Nereid> I'm sure you are.
07:22:25 <`ramses> Digihash: don't use head on a possibly empty list
07:22:32 <Nereid> `ramses: he isn't
07:22:41 <`ramses> last line
07:22:47 <Nereid> not in the annotation
07:22:47 <`ramses> l ++ [head x] ++ (getFirsts xs l)
07:22:54 <`ramses> woops! :D
07:23:00 <`ramses> sorry
07:23:05 <Digihash> That is my problem
07:23:14 <Nereid> and it is fixed
07:23:18 <Digihash> I'm not using head anymore, because of the problem
07:23:47 <Digihash> But my case of headEveryList is wrong, and I don't really now what it should be. On line 13
07:24:25 <osfameron> concatMap with safeHead?
07:24:26 <Nereid> I'm not sure what it's supposed to do.
07:24:30 <`ramses> you return a list instead of an a
07:25:31 <Digihash> I've seen that now, but how do I return that a? I think my a should be empty because I want to add the found a to output in the oorsprong function
07:25:35 <`nand`> neutrino: that type would make sense if you added Monoid b :)
07:25:46 <Digihash> like in line 4
07:25:54 <neutrino> `nand`: i was just thinking that
07:26:05 <`ramses> Digihash: question is, what should the function return on empty input...
07:26:06 <`nand`> :t fold mconcat . mapM
07:26:07 <lambdabot> (Monad m, Foldable ((->) [([a] -> m [b1]) -> b]), Monoid b) => (a -> m b1) -> b
07:26:10 <`nand`> oops
07:26:13 <`nand`> :t fmap mconcat . mapM
07:26:14 <lambdabot> (a -> [b]) -> [a] -> [b]
07:26:31 <`nand`> :t fmap mconcat .: mapM
07:26:32 <lambdabot> (Monad f, Functor f, Monoid b) => (a -> f b) -> [a] -> f b
07:26:34 <neutrino> `nand`: i knew i was liiking for the final type m (), i just didn't feel like overspecifying because hoogle is sometimes stupid with very specific types.
07:26:39 <Digihash> it should return nothing I think
07:26:45 <neutrino> so i used a broken type by purpose
07:26:51 <`nand`> oh
07:27:01 <neutrino> oh hey
07:27:02 <`ramses> but if a is e.g. an Int, what would Nothing be?
07:27:06 <`ramses> or if it is a Char
07:27:19 <Digihash> if it's a char it should be ''
07:27:23 <Digihash> and empty char
07:27:27 <`ramses> that's not a char
07:27:29 <neutrino> i have a function which should write to a file every time it's called
07:27:36 <`ramses> > '' :: Char
07:27:37 <lambdabot>   <hint>:1:4: parse error on input `::'
07:27:45 <neutrino> however, every new non-empty line should be prepended with "foo"
07:27:49 <neutrino> how can i do this?
07:27:49 <`ramses> maybe you should use a maybe
07:27:50 <Nereid> :t traverse
07:27:51 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
07:28:05 <neutrino> i'll need to keep some state.
07:28:11 <Nereid> :t view traverse
07:28:12 <lambdabot> (Traversable t, Monoid a, MonadReader (t a) m) => m a
07:28:14 <Nereid> er
07:29:00 <Nereid> oh sure, that's t a -> a
07:29:26 <Nereid> :t map M
07:29:27 <lambdabot> Not in scope: data constructor `M'
07:29:27 <Nereid> :t mapM
07:29:28 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
07:29:48 <Nereid> :t mapMOf traverse
07:29:49 <lambdabot> (Monad m, Traversable t) => (a -> m b) -> t a -> m (t b)
07:32:17 <Nereid> @ty fmap fold .: mapM
07:32:18 <lambdabot> (Monad f, Functor f, Monoid b) => (a -> f b) -> [a] -> f b
07:32:59 <Nereid> @ty fmap fold .: traverse
07:33:01 <lambdabot> (Applicative f, Traversable t, Monoid b) => (a -> f b) -> t a -> f b
07:33:24 <Digihash> Hmm, I don't understand how to use maybe in this case.
07:33:43 <Nereid> in what case?
07:34:21 <`ramses> well, you have a partial function since you don't have a sensible output value in case of an empty list
07:34:30 <Digihash> this case: http://hpaste.org/78912#a79000
07:34:43 <`ramses> so you could return Just when you have ouput and Nothing otherwise
07:35:06 <Digihash> And then I should check it in the oorsprong function?
07:35:22 <`ramses> yes, you should somehow handle that
07:35:57 <`ramses> see, there are two possibilities, either the case of an empty list as input cannot occur, or it can
07:36:24 <`ramses> in the first case, you could make that explicit somehow, in the second case you should handle the case properly
07:36:47 <`ramses> (nested cases in natural language are confusing...)
07:38:04 <Digihash> ok, thanks. I'll try
07:38:55 <Nereid> I guess one could say catMaybes makes [] a left Maybe-module :s
07:39:02 <Nereid> er, a right Maybe-module
07:39:29 <Nereid> or -algebra, that's probably what you'd call it
07:39:57 <Nereid> no, let's go with module.
07:41:14 <Nereid> let's try to find other similar things.
07:41:35 <Nereid> any monad is a module over itself on both sides, by join
07:41:43 <Nereid> obviously.
07:42:33 <Nereid> the conditions to check for catMaybes are:
07:42:45 <Nereid> catMaybes . catMaybes = catMaybes . fmap join
07:42:49 <Nereid> catMaybes . fmap return = id
07:48:26 <hpaste> Digihash annotated “empty list error” with “empty list error (annotation) (annotation)” at http://hpaste.org/78912#a79001
07:49:18 <Digihash> How can I implement some sort of case in the oorsprong function to handle Nothing and Just
07:49:42 <`ramses> depends on what you want to do in either case
08:03:58 <hpaste> test pasted “test” at http://hpaste.org/79003
08:04:18 <Eelis> is the dimensional package actually practically usable or is it just a hacky proof of concept that nobody should use in real code?
08:04:59 <Eelis> i know the C++ equivalent is very much practically usable, but it's less of a hack since C++ has real type-level ints
08:07:53 <tomeo> Is there a function in Prelude that takes two lists and returns a list of lists with all the combinations?
08:08:29 <merijn> tomeo: What does "all the combinations" mean?
08:09:37 <mapf> it's so boring when :i saying about ambigious names. i'd like to see all possible info rather than just spend time retyping fully qualified name
08:09:43 <tomeo> merijn: [1,2], [3,4] => [[1,3], [1,4], [2,3], [2,4]]
08:10:06 <tomeo> merijn: like how a list comprehension would have done for [f x y, | x <- xs, y <- ys]
08:10:11 <Eelis> wouldn't a list of pairs make more sense then?
08:10:15 <Eelis> as the result
08:10:39 <Industrial> neutrino: ok I've laid off web programming with haskell for now, and I'll try some systems programming first. A tool that I could use would be one that I could start from the commandline with an argument (directory path) and it would watch for changes and recompile files.
08:11:16 <Industrial> I have no idea where to start :P I'm reading learnyouahaskell though, and discovered hoogle and the haskell wiki ..
08:12:08 <Eelis> > liftM2 (,) [1,2] [3,4]
08:12:09 <lambdabot>   [(1,3),(1,4),(2,3),(2,4)]
08:12:23 <merijn> Industrial: Real World Haskell might have some more info on the practical type of things (profiling, etc)
08:12:28 <merijn> @where rwh
08:12:28 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
08:12:41 <mSSM> Could someone help me analyze why creating 10^6 uniform doubles (or ints) takes 0.02 here http://hpaste.org/79005, but almost 3 seconds here: http://hpaste.org/79004 (profiling says that the program spends more then 80% generating random numbers, not writing them to the map)
08:14:21 <`ramses> tomeo: liftA2 (\x y -> [x,y])
08:14:35 <tomeo> thanks `ramses, Eelis
08:17:36 <`ramses> @pl \x y -> [x,y]
08:17:36 <lambdabot> (. return) . (:)
08:20:18 <ClaudiusMaximus> mSSM: i'm guessing your data needs a strictness annotation on the Map field
08:25:05 <ClaudiusMaximus> mSSM: although, that doesn't make any difference here
08:25:51 * hackagebot diff3 0.1.0.1 - Perform a 3-way difference of documents  http://hackage.haskell.org/package/diff3-0.1.0.1 (OliverCharles)
08:25:58 <TheFuzzball> I'm just looking into Haskell and I'm trying to get function declaration straight in my head. Can you declare a function with two parameters without having them be in a tuple? (if that makes any sense)
08:26:42 <geekosaur> it makes plenty of sense and we usually don't use tuples for that; it makes partial application much harder
08:26:42 <Clint> yes?
08:26:47 <geekosaur> foo a b c = ...
08:27:56 <TheFuzzball> Ah, I thought of that but didn't think to try it. This syntax is quite alien :)
08:40:13 <Hafydd> TheFuzzball: technically a function taking two arguments is a function taking one argument then returning another function that takes one argument.
08:41:05 <TheFuzzball> Hafydd Whoever said Haskell was a hard language to learn? :P
08:41:31 <Hafydd> When I discovered that, a few weeks into learning Haskell I felt "my whole life has been a lie!"
08:42:29 <banacorn> hello :)
08:44:36 <banacorn> I have a question about concurrency and FFI. I tried the examples code in
08:44:55 <banacorn> I have a question about concurrency and FFI. I tried the examples code in http://www.vex.net/~trebla/haskell/ghc-conc-ffi.xhtml
08:45:41 <banacorn> But I got a different result :(
08:45:52 * hackagebot HTF 0.10.0.4 - The Haskell Test Framework  http://hackage.haskell.org/package/HTF-0.10.0.4 (StefanWehr)
08:48:25 <banacorn> The results of the C functions in the example are running in different threads. But they all stuck in the same thread when I tried them.
08:50:54 * hackagebot HTF 0.10.0.5 - The Haskell Test Framework  http://hackage.haskell.org/package/HTF-0.10.0.5 (StefanWehr)
08:52:59 <parcs`> banacorn: did you compile with -threaded
08:54:06 <banacorn> yes, I compiled them with -thread
08:54:47 <banacorn> -threaded *
08:56:22 <parcs`> banacorn: did you mark the foreign import as safe?
08:59:46 <banacorn> yes, the foreign imports are marked as `safe` in the example codes here: http://www.vex.net/~trebla/haskell/ghc-conc-ffi.xhtml
09:13:07 <mSSM> ClaudiusMaximus: thanks, but it doesnt help much
09:14:05 <mSSM> ClaudiusMaximus: I have strictness in my actual program, but that only helps with the heap size; most time is actually spent with those uniform random numbers
09:14:56 <ClaudiusMaximus> i think the profiler output is misleading (ie, profiling slows down random generation much more than it slows down everything else)
09:16:21 <mSSM> ClaudiusMaximus: But I compile both examples with profiling, and in the fast example the profiling overhead seems to be negligible.
09:24:49 <mSSM> ClaudiusMaximus: it could not be related to me calling `mod n` on the random number generated to restrict the random Integer to be within an interval [0, n) ?
09:24:51 <banacorn> thanks for your help,  parcs` :)
09:27:19 <mSSM> Nope, speed of uniformR (0,n-1) is similar to `(mod n) <$> uniform'
09:28:56 <edvardkk> augur: damn, I must find a new nick? :-p
09:29:05 <augur> edvardkk: no no
09:29:07 <augur> a whole new name
09:29:18 <augur> "Edvard Kristoffer Karlsen" is unacceptable
09:29:32 <edvardkk> ok
09:29:41 <edvardkk> give me a few days!
09:29:52 <augur> anything that doesn't look like "edwardk" when turned into a username!
09:31:35 <edvardkk> You are correct. I shall change it tomorrow; the Department of Names is closed in the weekend.
09:31:44 <augur> ridiculous
09:35:53 * hackagebot largeword 1.0.4 - Provides Word128, Word192 and Word256 and a way of producing other large words if required.  http://hackage.haskell.org/package/largeword-1.0.4 (DominicSteinitz)
09:40:27 <cmccann> @tell dmwit haha sorry if that wasn't obviously enough a joke, but your hpaste from months ago was the about the only mention of the issue I found, and I was annoyed because it was cabal-install itself failing to build for me >:I
09:40:27 <lambdabot> Consider it noted.
09:40:35 <cmccann> hm.
09:40:35 <lambdabot> cmccann: You have 2 new messages. '/msg lambdabot @messages' to read them.
09:40:47 <cmccann> it seems lambdabot doesn't tell you about messages if all you say is a bot command!
09:41:27 <cmccann> how curious.
09:41:38 <monochrom> with one exception: @messages :)
09:42:55 <cmccann> @tell lambdabot you confuse me sometimes.
09:42:55 <lambdabot> Nice try ;)
09:45:53 * hackagebot stylish-haskell 0.5.5.2 - Haskell code prettifier  http://hackage.haskell.org/package/stylish-haskell-0.5.5.2 (JasperVanDerJeugt)
09:45:55 * hackagebot blaze-markup 0.5.1.4 - A blazingly fast markup combinator library for Haskell  http://hackage.haskell.org/package/blaze-markup-0.5.1.4 (JasperVanDerJeugt)
09:50:53 * hackagebot blaze-html 0.5.1.3 - A blazingly fast HTML combinator library for Haskell  http://hackage.haskell.org/package/blaze-html-0.5.1.3 (JasperVanDerJeugt)
10:34:46 <scooty-puff> i am having trouble choosing a data structure for an interval tree - though one that does not allow for overlap of intervals
10:35:23 <scooty-puff> i am undecided between a fingertree (Data.IntervalMap.FingerTree) and just an IntMap on the low bound to the high bound (IntMap Int)
10:36:02 <scooty-puff> are there data structures specifically for non-overlapping interval trees?
10:37:13 <Industrial> Trying to create a program that watches a directory for changes and performs some tasks (recompile coffeescript to javascript) when they happen, I found http://hackage.haskell.org/packages/archive/hinotify/0.3.1/doc/html/System-INotify.html to do the watching part. the link mentions I should use initINotify to get an INotify on which to addWatch, but I'm not sure how to get the result of an initINotify. https://gist.github.com/30eecd2cbb9337b4cc96
10:39:06 <Industrial> my imperative gut tells me x=initINotify() x.addWatch(events, path, callback) but thats no haskell :x
10:43:02 <hpaste> keep_learning pasted “forall keyword” at http://hpaste.org/79008
10:43:09 <keep_learning> Hello all
10:43:26 <keep_learning> I am trying to use for all keyword but getting compiler error.
10:43:57 <keep_learning> Could some one please tell me what is wrong with this.
10:44:06 <Eelis> keep_learning: you need to enable one of the extensions that provides it
10:44:13 <Eelis> there are like 3
10:45:00 <keep_learning> Eelis, I enabled two  -XRankNTypes  -XImpredicativeTypes as suggested by compiler.
10:45:13 <Eelis> might not be enough
10:45:34 <Eelis> i generally use ScopedTypeVariables
10:46:22 <keep_learning> Eelis, still error
10:46:37 <neutrino> scooty-puff: what is an interval tree?
10:46:39 <Eelis> keep_learning: then let's se a testcase
10:46:42 <Eelis> *see
10:46:49 <Eelis> oh wait, you did
10:46:53 <neutrino> scooty-puff: are you perhaps talking about something like octree space partitioning?
10:47:14 <Eelis> keep_learning: oh, looks like you may need ExistentialQuantification
10:48:36 <Eelis> otherwise i give up
10:48:49 <neutrino> sewage processing plants are generally only used to make sewage cleaner, you handle the extracted matter as toxic waste, right?
10:49:01 <scooty-puff> neutrino: yes'ish - only one dimensions, and i would prefer to not have to choose where to divide
10:49:01 <neutrino> or are those used to actually harvest materials from it
10:49:06 <scooty-puff> *one dimension
10:49:08 <neutrino> oh sorry wrong window
10:49:16 <neutrino> scooty-puff: yeah
10:49:29 <keep_learning> Eelis, No its still error :(
10:49:42 <neutrino> scooty-puff: i suggest you have a look at how octrees are implemented, and generalize..
10:51:36 <hpaste> keep_learning annotated “forall keyword” with “forall keyword (annotation)” at http://hpaste.org/79008#a79009
11:02:02 <tomeo> I can make foo x = (f x) + 1 like this instead: foo f = (1+).f but can I somehow remove the f too?
11:03:35 <Clint> @pl \f -> (1+).f
11:03:35 <lambdabot> ((1 +) .)
11:09:24 <Saizan> keep_learning: that code won't typecheck because a "Edge a" contains something of type "a" not something polymorphic
11:09:42 <Saizan> keep_learning: but your Graph type is quite weird, what are you trying to do?
11:10:28 <mm_freak> as far as i understand it the GHC people refuse to implement the "exists" keyword, but apparently it's possible since most other compiles do it
11:10:35 <mm_freak> is there any reason why GHC doesn't?
11:10:48 <mm_freak> compilers*
11:11:10 <keep_learning> Saizan, I simply want to keep the graph type as Graph , not something like Graph Double or Graph Int when  the edge value is Double or Int.
11:13:24 <Saizan> keep_learning: and are you fine with forgetting which type it is and just remembering that it's a Num? it doesn't seem like you'd be able to do much that way
11:14:39 <Saizan> keep_learning: anyhow that would be defined as "data Graph = forall a. Num a => Graph (IM.IntMap (Vertex , a))"
11:15:47 <keep_learning> Saizan, so we can not use the forall with type keyword ?
11:15:59 <Saizan> createGraph :: Num a => [Egde a] -> Graph; createGraph xs = Graph . IM.fromList  .  map (\ ( a , b , val ) -> ( a , ( b , val ) )  )  $ xs
11:16:14 <Saizan> keep_learning: you can, but it means something else
11:17:59 <Saizan> if you have "foo :: forall a. Num a => a" then the caller of foo can decide what to use for 'a', so the implementation of foo must work for all of them
11:18:27 <Saizan> same would be needed for the values in your IntMap with your Graph definition
11:19:08 <keep_learning> Saizan, so the difference between "data Graph = forall a. Num a => Graph (IM.IntMap (Vertex , a))"  and type Graph = IM.IntMap  ( forall a. Num a => ( Vertex , a ) )
11:19:37 <hpaste> mapf pasted “lack of pretty printing =<<” at http://hpaste.org/79011
11:19:37 <keep_learning> in first one caller decides a is instance of Num class
11:19:49 <Saizan> when you define "data Graph = forall a. Num a => CGraph (IM.IntMap (Vertex , a))" instead you are saying that "CGraph :: forall a. Num a => IM.IntMap (Vertex , a) -> Graph" so the user of CGraph gets to decide what to use for 'a'
11:19:52 <keep_learning> but for second one it won't be able to decide
11:20:13 <mapf> promoted tuples and promoted lists are hardly ever readable :(
11:20:25 <Saizan> keep_learning: "caller" is too vague, you have to say caller of what
11:20:46 <keep_learning> the function who is using these values ?
11:22:20 <Saizan> then no
11:22:52 <Saizan> keep_learning: maybe this will help http://www.haskell.org/haskellwiki/Existential_types
11:23:18 <Saizan> keep_learning: the problem is also that the forall notation for defining existential types is kind of an abuse
11:24:10 <keep_learning> Saizan, Thank you. It just occurred to me that I don't want to use a in Graph then what should I do and I just remember forall but seems like I need to learn bit more.
11:25:45 <Saizan> keep_learning: sometimes it's better to keep the parameter
11:27:02 <Saizan> *most often
11:27:53 <keep_learning> Saizan, Yes but then I may not have got the  chance to learn forall keyword :)
11:39:18 <burrows> (-1 :: Word16)
11:40:17 <burrows> GHCi evaluates that to 65535 but uses it like a twos complement -1?
11:40:42 <Taneb> > 65535 + 12 :: Word16
11:40:44 <lambdabot>   11
11:40:58 <Taneb> Word16 arithmetic is done modulo 65536
11:42:59 <SplinterOfChaos> The highest number representable with 16 bits.
11:43:16 <SplinterOfChaos> Err, + 1
11:43:55 <burrows> Alright that makes sense.
11:43:58 <burrows> Thanks.
11:46:31 <Peaker> if I malloc a Ptr/ForeignPtr, are they GC'd/auto-freed?
11:47:58 <parcs`> Peaker:  mallocForeignPtr is auto-freed, malloc is not
11:48:06 <parcs`> you may want alloca
11:48:20 <Peaker> I need it to persist beyond the current IO action
11:48:41 <parcs`> you may want mallocForeignPtr :)
11:48:48 <Peaker> thanks :)
11:50:05 <Peaker> is there a standard   withFreeFinalizer :: Ptr a -> ForeignPtr a ?
11:51:06 <parcs`> newForeignPtr finalizerFree ptr
11:51:49 <Peaker> great, thanks :)
11:56:33 <Peaker> bah, the freetype-gl library leaks like crazy
12:09:02 <mgccl> Are there ways to redefine instances? for example if I want to change the default Ord for a imported library.
12:09:27 <sipa> typically, you wrap the type in a newtype, and give a new instance for that newtype, i nthat case
12:12:05 <okdiej> I've been thinking a bit about IO.. How does this idea sound.. basically create a physical type.. normally types are mathematical.. so a function with physical types could for example have a folder on the harddrive as a type so you'd have a pure function copy from folder A to folder B, where folder A and folder B both are types... Does that make sense?
12:12:23 <mgccl> ohh thanks, I finally see the point of newtype
12:12:33 <okdiej> or the type is folder, but folder A and B are variables
12:12:51 <okdiej> but the type folder refers to a folder on a physical disk
12:15:45 <jmcarthur> okdiej: i don't understand
12:16:40 <jmcarthur> okdiej: what do you mean by a "physical type"?
12:18:27 <okdiej> jmcarthur: normally a type refers to an abstract object, like a number, a string, a class or something like that, but what if we let a type refer to a concrete object, like a specific server, or folder on some harddrive etc.. so by physical type I mean the type can refer so a physical object, like a server, instead of just abstract thing like a string or number
12:21:37 <okdiej> like if you look in the standford dictionary of philosophy, they define abstract and concrete objects.. http://plato.stanford.edu/entries/abstract-objects/ Types in programming refer to abstract objects only, at least I haven't seen anything else, but is it an idea to let it refer to concrete objects perhaps.. the thing is that IO is concrete, input is from a physical device, output is to a physical device
12:23:16 <okdiej> or maybe there is types already defined like this?
12:24:08 <jmcarthur> how is a folder in a filesystem any more concrete than a String? neither actually exist
12:24:55 <jmcarthur> and is this any different from   newtype Folder = Folder Filepath   ?
12:25:28 <jmcarthur> and how is IO concrete? it doesn't exist either
12:25:46 <cmccann> does anything truly exist? perhaps we're all hallucinating.
12:25:47 <okdiej> IO has a physical effect, the side effect is what we're after
12:25:49 <jmcarthur> IO isn't even a type
12:26:16 <okdiej> IO transforms from the mathematical domain to the physical domain
12:26:32 <jmcarthur> so what in our physical reality is IO String?
12:27:11 <copumpkin> o____O
12:27:42 <Igloo> It's a machine that makes a String when you press the 'go' button
12:27:46 <okdiej> string is just a mathematical object and while it has of course also a physical effect, you need to store it in memory etc, this physical effect is something we could do without, if it was possible.. but for IO, the physical effect is what we want, we want it to store those bits
12:27:49 <cmccann> physicalReality :: IO RealWorld
12:28:11 <copumpkin> O__________________o
12:28:14 <Adnauseam> haskell has the weirdest code :p
12:28:17 <jmcarthur> okdiej: IO String doesn't always mean "i want you to store bits"
12:28:20 <cmccann> copumpkin, that looks painful
12:28:33 <Adnauseam> well, the people in #haskell write the weirdest named code :p it's wonderful
12:28:42 <copumpkin> cmccann: oh, it is
12:28:56 <jmcarthur> Adnauseam: ?
12:29:40 <cmccann> yay, I have a bunch of fay ffi definitions that might actually work!
12:29:54 <Adnauseam> jmcarthur: just noticing how philosophical haskell code sounds like after going back to python\java for uni work
12:30:14 <jmcarthur> Adnauseam: i think this instance is a bit stranger than the usual, myself
12:30:15 <Adnauseam> jmcarthur: and i mean that in the best way possible. i love that about haskell
12:30:30 <Excedrin> they're both "physical", electrons or magnetism
12:30:32 <Adnauseam> haha
12:30:39 <Adnauseam> =]
12:31:47 <okdiej> jmcarthur: well no, but output to disk or database or whatever means you want to store it, of course you can output to screen etc also, outputing to the screen has another physical effect you're after, you're seeing the string on the screen and this "side effect" is the effect you're after, so  you coudl have Display as a type and an instance of that type would actually refer to your physical screen
12:32:12 <copumpkin> types classify values
12:32:18 <jmcarthur> okdiej: i don't see anything unusual about using Display as a type
12:32:30 <copumpkin> I think this whole notion of abstract vs. concrete vs. physical seems very helpful
12:32:36 <jmcarthur> okdiej: i don't see anything more "physical" about it, either
12:32:51 <jmcarthur> copumpkin: you're killing me here
12:32:53 * cmccann classifies everything as abstract and calls it a day
12:32:59 * copumpkin kills jmcarthur there
12:33:14 <copumpkin> oh shit
12:33:18 <copumpkin> I forgot a negation in that sentence
12:33:23 <copumpkin> that changes everything
12:33:39 * cmccann was wondering about that
12:33:45 <copumpkin> I _don't_ think etc.
12:33:49 <okdiej> well a pixel on my screen is a physical spot right there, but any string or number in my software is not, even though it needs a physical representation in memory or disk to exist
12:33:54 <copumpkin> (it's bad for the mind)
12:34:20 <copumpkin> okdiej: Haskell is an abstract language. It works on abstract machines independently of bits and physical crap at all
12:34:24 <copumpkin> I could run my haskell on paper
12:34:30 <kqr> why is Float an instance of Eq?
12:34:38 <copumpkin> kqr: because Eq has no laws
12:34:54 <hpc> kqr: because floating point equality is well-defined
12:34:54 <hpc> also what copumpkin said
12:35:10 <copumpkin> it gives you a partial equivalence relation
12:35:11 <hpc> the IEEE spec says what equality semantics is
12:35:19 <copumpkin> whereas most people might expect a full equivalence relation
12:35:28 <neutrino> what is a partial relation?
12:35:41 <cmccann> Eq follows the law of the jungle
12:35:42 <copumpkin> partial equivalence relation is symmetric, transitive, but not reflexive
12:35:52 <copumpkin> i.e., there exist values for which x /= x
12:35:54 <hpc> NaN /= NaN
12:35:58 <`nand`> > 0/0 == 0/0
12:35:59 <lambdabot>   False
12:36:00 <hpc> also the infinities
12:36:05 <`nand`> > 1/0 == 1/0
12:36:06 <copumpkin> those are equal to themselves
12:36:07 <lambdabot>   True
12:36:11 <hpc> ah
12:36:24 <hpc> > 1/0 == 2/0
12:36:25 <lambdabot>   True
12:36:35 <merijn> > 1/0 == (-1)/0
12:36:36 <lambdabot>   False
12:36:39 <okdiej> copumpkin: yes, but what if we allowed types to refer to concrete things? you'd have something like a function, where for example the input is number and the output is a pixel on the screen and this function would be pure, since the output domain of the function refers to a physical object, then changing the state of that physical object is no longer a side effect
12:36:55 <neutrino> copumpkin: ok
12:36:55 <merijn> positive infinity == positive infinity, but not so for negative and positive infinity
12:36:59 <SingingBoyo> > 0 == -0
12:37:00 <lambdabot>   True
12:37:16 <merijn> > (-1)/0 == (-1)/0
12:37:16 <kqr> but since when does it make sense to compare floats for equality?
12:37:17 <lambdabot>   True
12:37:26 <rwbarton> > 1/0 == 1/(-0)
12:37:27 <lambdabot>   False
12:37:33 <merijn> kqr: Since IEEE754 defined the semantics
12:37:39 <kqr> okay
12:37:51 <copumpkin> okdiej: why must the output refer to a "physical object"? I can write a function Moo -> (Int, Int) and then have something that reads that pixel and colors it on the screen, separately
12:38:01 <merijn> kqr: Which in practice means you still shouldn't compare them using ==
12:38:07 <kqr> yeah
12:38:10 <cmccann> yes, with floats you can have (x == y) but (recip x /= recip y)
12:38:23 <cmccann> even without NaN being involved
12:38:29 <copumpkin> fucking negative 0
12:38:29 <`nand`> > sort [0.1, 0.5, 0.34, 0.9, 2.1, 0.04]
12:38:31 <lambdabot>   [4.0e-2,0.1,0.34,0.5,0.9,2.1]
12:38:37 <hpc> okdiej: assuming sufficient quantities of magic for that to work out, you would either be modifying a mutable value (impure)
12:38:39 <`nand`> ^ a use case for comparing floats
12:38:52 <okdiej> copumpkin: yes, but I think having the ouput as a physical object is an interesting alternative that hasn't been explored properly
12:38:58 <FireFly> That's not (==) comparison
12:38:58 <kqr> `nand`, i'm not thinking too much about Ord
12:39:01 <copumpkin> okdiej: I don't think you've define it
12:39:02 <hpc> or creating a totally new LCD monitor for every new pixel value you create
12:39:03 <kqr> `nand`, that makes sense
12:39:04 <copumpkin> *defined
12:39:10 <kqr> `nand`, it's Eq that i'm scratching my beard over
12:39:10 <jmcarthur> okdiej: to be honest i don't even think you're making any sense
12:39:13 <`nand`> but given Ord you get Eq either way; since there's an EQ ordering
12:39:25 <copumpkin> okdiej: types don't _care_ what they're talking about
12:39:29 <lee972> hi, does anyone know of a generic zipper library built using GHC.Generics?
12:39:32 <jmcarthur> okdiej: functions are abstract, too. how can they have anything to do with physical objects?
12:39:35 <copumpkin> they simply classify values, and have rules for introducing and eliminating them
12:39:40 <copumpkin> that's all they do
12:39:43 <`nand`> “floats having Eq makes sense because floats having Ord makes sense”; I guess
12:39:52 <copumpkin> they don't make any pretension to being abstract or concrete or anything of the sort
12:40:04 <kqr> `nand`, why make them different classes if Ord implies Eq?
12:40:16 <jmcarthur> kqr: Eq doesn't imply Ord
12:40:16 <`nand`> because Eq doesn't imply Ord
12:40:22 <kqr> oh
12:40:50 <kqr> but functions checking for equality could just as well accept Ord instances instead of Eq?
12:41:04 <jmcarthur> kqr: they would be less general
12:41:07 <merijn> kqr: Ord requires a type to be Eq
12:41:09 <copumpkin> no, it's just that whenever you have an Ord instance, you're guaranteed to have an Eq instance too
12:41:15 <merijn> kqr: It is impossible to define an Ord instance without defining Eq
12:41:19 <kqr> merijn, aha wow
12:41:22 <kqr> i didn't know that
12:41:28 <`nand`> @src Ord
12:41:29 <lambdabot> class  (Eq a) => Ord a  where
12:41:29 <lambdabot>     compare      :: a -> a -> Ordering
12:41:29 <lambdabot>     (<), (<=), (>), (>=) :: a -> a -> Bool
12:41:29 <lambdabot>     max, min         :: a -> a -> a
12:41:30 <jmcarthur> kqr: a function that requires Ord works for fewer types than a function that requires Eq
12:41:34 <rwbarton> of course okdiej is talking about something that does not exist in Haskell, if you try to interpret it from a Haskell-constrained mindset, it will make no sense
12:41:52 <neutrino> just noticed one of my variables ended up being named makeOut.
12:41:59 <copumpkin> rwbarton: then tell me what it means, because I have no clue :)
12:42:00 <okdiej> rwbarton: yes.. what I'm talking about doesn't exist in any programming language...
12:42:05 <neutrino> must be that i'm watching "17 again" while coding.
12:42:09 <copumpkin> it seems to be conflating concepts on completely different levels of abstraction
12:42:11 <jmcarthur> okdiej: can you define it?
12:42:17 <rwbarton> well, take Clean, already it has something more like this
12:42:19 <merijn> kqr: Having a class constraint on the class definition means the compiler complains if you try to define an instance without providing the other instance first
12:42:19 <copumpkin> the very question
12:42:29 <mgccl> is there a way to make functions work for type A works for newtype B = A, without redefine every such function?
12:42:33 <kqr> merijn, yeah, i guess that makes sense
12:42:44 <jmcarthur> mgccl: type classes?
12:42:44 <hpc> @hoogle Newtype
12:42:44 <lambdabot> keyword newtype
12:42:44 <lambdabot> package newtype
12:42:44 <lambdabot> package newtype-th
12:43:07 <hpc> class Newtype ... where ...
12:43:49 <merijn> mgccl: Doesn't that kinda defeat the point of having a newtype?
12:44:15 <okdiej> In what I'm thinking of,the function could theoretically also refer to something physical so if I have a glass of water as input, then empty() as the function which should return an empty glass of water, then I would write this in code but would for example have to program a robot arm to execute this could, which would be kind of like an implementation of an interface for emtpy() and it should perhaps have some way to see if it fail
12:44:40 <mgccl> merjin: so currently all I want is a Data.Set that have a different Ord instance.
12:44:58 <jmcarthur> okdiej: is the type of empty something like    Glass Water -> Glass Water   ?
12:44:58 <copumpkin> okdiej: this seems to presuppose a notion of "object identity"
12:45:25 <rwbarton> what's wrong with object identity
12:45:45 <okdiej> jmcarthur: yeah, or Glass Water -> Empty Glass of Water
12:45:46 <jmcarthur> okdiej: it sounds like you might be looking for linear types or uniqueness types
12:45:47 <copumpkin> nothing, I'm just trying to get this into more concrete terms
12:45:59 <jmcarthur> okdiej: or some other substructural type
12:46:05 <okdiej> where empty glass of water is actually the same glass of water, just empty
12:46:23 <copumpkin> this sounds like typestate like what rust was going to have
12:46:26 <copumpkin> before they killed it
12:46:29 <jmcarthur> okdiej: so the input to the function was "consumed" and can't be used anymore?
12:46:50 <jmcarthur> okdiej: that is, it's illegal to say   empty glass; empty glass   ?
12:47:02 <jmcarthur> okdiej: because the second occurrence is using the same glass?
12:47:17 <jmcarthur> okdiej: on the other hand, i could say    glass <- empty glass; refill glass   ?
12:47:28 <okdiej> jmcarthur: it might or it might not.. there could be a function for lifting the glass of water up, and putting it down again, in this case the same function could be performed multiple times
12:47:46 <jmcarthur> okdiej: but do you use the same glass or a "new" glass each time you modify it?
12:47:51 <okdiej> but if the function was to break the glass, the glass would be consumed
12:47:54 <copumpkin> I don't think the "physical" aspect of this whole thing is crucial to the idea at all
12:47:55 <okdiej> the same glass
12:48:20 <copumpkin> it's just attaching potentially varying type-level tags to particular instances of things
12:48:24 <jmcarthur> well, i was trying to steer you toward linear types, because i think they can express what you want, but you might have to be willing to drop some of your metaphors
12:49:27 <jmcarthur> okdiej: the idea is that if you want to be able to continue using the glass after applying a function to it, the function must supply the glass again
12:49:32 <jmcarthur> okdiej: as an output
12:50:05 <jmcarthur> okdiej: but the glass given as an input can never be used again, regardless
12:50:21 <copumpkin> it sort of depends on how you look at it
12:50:30 <copumpkin> you can think of using the same thing again, assuming it satisfies some conditions
12:50:34 <jmcarthur> okdiej: both glasses can represent the same physical glass, but they are still different identifiers in your code
12:50:36 <copumpkin> and those conditions can vary
12:50:42 <mSSM> What is the difference between a Map and a IntMap ?
12:50:45 <okdiej> jmcarthur: that makes sense, I guess that glass that was given as an input in a way doesn't exist anymore, if it is physical it would have moved forward in time and have changed in any case
12:50:53 <jmcarthur> okdiej: one identifier is the glass before the function, and the other is the glass after
12:51:02 <mm_freak> what's a glass?!
12:51:43 <jmcarthur> okdiej: okay, definitely google linear types (and maybe uniqueness types, but i'm not familiar with the differences from linear types)
12:52:09 <mm_freak> oh, nothing interesting…  "glass" sounded like it could be something edwardk invented =)
12:52:40 <jmcarthur> okdiej: for what it's worth, Clean uses uniqueness types for its i/o, as rwbarton pointed out earlier
12:53:20 <neutrino> how do you read off a handle without blocking? i have a feeilng hGetBuf is the wrong way to go
12:53:21 <`nand`> does lens have support for Dichroic Prisms yet?
12:53:29 <jmcarthur> my understanding of clean's use of uniqueness types for i/o is that it's basically the same thing as our incorrect analogy of IO being a state monad on the real world
12:53:29 <hpc> jmcarthur: linear types are roughly "stale references don't stick around", while uniqueness types are more along the lines of "there's only one RealWorld in existence ever"
12:53:40 <hpc> as far as i can tell at least
12:53:54 <mm_freak> neutrino: you wouldn't
12:54:03 <neutrino> mm_freak: can you explain
12:54:04 <mm_freak> neutrino: use concurrency
12:54:06 <okdiej> jmcarthur: cool, I'll check out linear types
12:54:11 <jmcarthur> neutrino: check out the async library
12:54:22 <neutrino> mm_freak: i am already "using concurrency"
12:54:36 <neutrino> mm_freak: throwing more threads at something isn't always the answer
12:54:55 <mm_freak> neutrino: why not?
12:55:06 <okdiej> maybe I should have a look at clean too
12:55:10 <mm_freak> threads are almost free in haskell…  remember, they are not OS threads
12:55:16 <neutrino> i need to execute a function if a handle hasn't produced any output for 2 seconds, how do you suppose this should happen without nonblocking reads?
12:55:28 <neutrino> i have no idea how to do that otherwise
12:55:39 <mm_freak> i would use STM
12:55:45 <mm_freak> let me write an example
12:55:49 <rwbarton> @hoogle timeout
12:55:49 <lambdabot> System.Timeout module System.Timeout
12:55:49 <lambdabot> System.Timeout timeout :: Int -> IO a -> IO (Maybe a)
12:55:49 <lambdabot> System.Event type TimeoutCallback = IO ()
12:55:52 <neutrino> ok great
12:55:58 * hackagebot caledon 0.0.0.0 - a dependently typed, polymorphic, higher order logic programming language  http://hackage.haskell.org/package/caledon-0.0.0.0 (MatthewMirman)
12:55:59 <rwbarton> (guess what, it is implemented using theads)
12:56:42 <mm_freak> oh yeah, i always forget about 'timeout'
12:56:45 <neutrino> rwbarton: i can't see how timeout would work
12:57:02 <mm_freak> neutrino: timeout uses a separate thread and a timeout
12:57:08 <mm_freak> remember to link with -threaded
12:57:40 <neutrino> right, and if the action doesn't finish during that time, the thread gets killed and the timeout function returns IO Nothing?
12:57:49 <mm_freak> exactly
12:57:55 <neutrino> yeah, that's crap.
12:58:00 <mm_freak> why?
12:58:35 <neutrino> well, i need to be able to read of as much as possible
12:59:05 <jmcarthur> mm_freak: you don't need to link with -threaded for ghc threads to work
12:59:08 <neutrino> so if i read off 10 chars, but the action is waiting for another char, those 10 chars are lost when i get Nothing
12:59:13 <hpaste> rimobi pasted “StringToInt - ["1","3","55"] to [1,3,55]” at http://hpaste.org/79012
12:59:18 <neutrino> which is bad
12:59:26 <mm_freak> neutrino: what would be a sensible type?
12:59:33 <mm_freak> repeatFor :: Int -> IO a -> IO [a]?
12:59:40 <jmcarthur> neutrino: so write it incrementally into a TVar or Chan or something
12:59:43 <mm_freak> (where the Int is a duration in milliseconds)
12:59:57 <neutrino> Int -> IO String
12:59:59 <`nand`> I came across this exact same scenario a while back
13:00:13 <mm_freak> jmcarthur: you really want threaded, when you work with timeouts…  see the documentation of threadDelay and registerDelay
13:00:15 <neutrino> where an empty String means nothing new found during $timeout seconds
13:00:17 <`nand`> I wanted to “read as much of stdin as possible without blocking”
13:00:27 <neutrino> `nand`: what did you do?
13:00:33 <mm_freak> neutrino: that type doesn't make sense without context
13:00:43 <neutrino> mm_freak: i just explained the context?
13:00:58 * hackagebot minimorph 0.1.4.0 - English spelling functions with an emphasis on simplicity.  http://hackage.haskell.org/package/minimorph-0.1.4.0 (EricKow)
13:01:00 <`nand`> neutrino: forked off a thread to read blockingly and write that into a queue that I could read off non-blockingly in another thread
13:01:01 <mm_freak> readFor :: Int -> Handle -> IO String?
13:01:25 <jmcarthur> mm_freak: i don't see anything scary in the documentation for either
13:01:49 <jmcarthur> mm_freak: only "There is no guarantee that the thread will be rescheduled promptly when the delay has expired, but the thread will never continue to run earlier than specified.", which isn't necessarily impacted much from not having -threaded
13:01:49 <neutrino> mm_freak: oh yeah, there's got to be a Handle somewhere as well
13:02:03 <jmcarthur> mm_freak: the only caveat i can think of is if you can into a computation that doesn't allocate for a long time
13:02:43 <jmcarthur> *can get into
13:02:47 <neutrino> this is really really really disappointing that haskell has no simple non-blocking reads
13:04:08 <`nand`> neutrino: http://hpaste.org/78353 <- have a look at ‘forkEvent’; you can replace readTQueue by tryReadTQueue to get STM (Maybe a)
13:04:12 <rwbarton> @hoogle nonblocking
13:04:12 <lambdabot> System.Posix.IO NonBlockingRead :: FdOption
13:04:12 <lambdabot> System.IO hGetBufNonBlocking :: Handle -> Ptr a -> Int -> IO Int
13:04:12 <lambdabot> GHC.IO.Handle hGetBufNonBlocking :: Handle -> Ptr a -> Int -> IO Int
13:04:32 <`nand`> I guess you'd have to write some small wrapper code to change STM (Maybe a) to STM [a]; stopping on the first Nothing
13:04:57 <neutrino> rwbarton: yeah i've seen hGetBufNonBlocking but i have no idea how to get a Ptr a
13:05:07 <jmcarthur> neutrino: look at Foreign.Ptr
13:05:13 <rwbarton> how about hGetNonBlocking from ByteString
13:05:20 <`nand`> perhaps it would also be more efficient to use a TVar [a] and prepend on a new character; then simply reverse when reading
13:05:29 <mm_freak> jmcarthur: the problem with the non-threaded run-time is that context switches occur in certain spots in the code
13:05:47 <mm_freak> i had the issue that a timeout simply wouldn't fire
13:05:48 <Industrial> Learning haskell I want to try to create a program that resorts ls output (.dirs .files dirs files); https://gist.github.com/5f8ae9b59302324b60fc however line 5 is wrong
13:05:57 <neutrino> oh that works well
13:05:58 * hackagebot heist 0.10.0 - An Haskell template system supporting both HTML5 and XML.  http://hackage.haskell.org/package/heist-0.10.0 (DougBeardsley)
13:06:05 <`nand`> rwbarton: as far as I gathered, hGetNonBlocking is asking for all sorts of trouble
13:06:18 <rwbarton> oh really?
13:06:40 <jmcarthur> mm_freak: the opportunities are just whenever it allocates or blocks, no? or are there times when it allocates and still doesn't get a chance to switch?
13:06:54 <neutrino> how so `nand` ?
13:07:14 <`nand`> 2012-11-27 14:40:12 Eduard_Munteanu `nand`: it's timing and buffering-sensitive, just don't do it.
13:07:31 <neutrino> Eduard_Munteanu: why is it timing and buffering sensitive?
13:07:40 <rwbarton> isn't that what one is looking for when doing nonblocking reads
13:07:44 <`nand`> note: that was hGetBufNonBlocking from System.IO; but I guess they're the same thing
13:08:45 <jmcarthur> Industrial: i'm guessing because i don't know what rawSystem is:  https://gist.github.com/f842cac68b02a73499bc
13:08:57 <hpaste> “Ertugrul Söylemez” pasted “repeatFor: Perform for the given amount of time” at http://hpaste.org/79013
13:09:03 <mm_freak> neutrino: http://hpaste.org/79013
13:09:05 <mm_freak> that one should work
13:09:10 <jmcarthur> Industrial: actually, yeah, i misguessed badly
13:09:25 <jmcarthur> baleeted
13:09:36 <mm_freak> neutrino: in your case you would write something like that: repeatFor 2000000 (hGetLine h)
13:09:53 <mm_freak> possibly with an fmap (intercalate "\n")
13:10:10 <jmcarthur> Industrial: how about this?  https://gist.github.com/43db6c1f2afb5ae34265
13:10:20 <mm_freak> jmcarthur: i didn't bother to debug…  using -threaded fixed it
13:10:46 <mm_freak> and i remember many people here who had the same issue
13:10:48 <s_quark> Industrial: line 10, you're passing "/home/tom" twice where the function only expects one argument
13:10:58 <mm_freak> nowadays i just compile everything with -threaded
13:11:09 <Industrial> s_quark: I'm actually trying to test passing multiple arguments, because ls can take multiple
13:11:31 <jmcarthur> Industrial: i just changed my suggestion again
13:11:47 <neutrino> yeah hGetNonBLocking ends up calling System.IO.hGetBufNonBlocking
13:11:53 <jmcarthur> Industrial: you need to pass the arguments as a list, and you need to make sure to use parens or ($) properly in your ls function
13:12:28 <Industrial> jmcarthur: right.
13:12:48 <neutrino> ok so what does it mean that "hGetBufNonBlocking" is sensitive to something?
13:13:01 <neutrino> what's it going to do, return less or more data? because i'm fine with that
13:13:11 <neutrino> because right now this sounds like FUD to me
13:13:18 <Industrial> How do I inspect a value at some point in the execution? I can't simply put a print between somewhere in the ls function to see the value of args?
13:13:26 <neutrino> so i don't believe it
13:13:52 <neutrino> Industrial: build smaller functions, in modular fashion, and use unit testing.
13:13:57 <mm_freak> neutrino: don't use non-blocking
13:14:08 <neutrino> mm_freak: why?
13:14:16 <mm_freak> because how would you express the timeout?
13:14:24 <mm_freak> busy-looping?
13:14:30 <neutrino> what's busy-looping?
13:14:33 <rwbarton> of course you are subject to the whims of the output buffering of whatever you are reading from
13:14:52 <mm_freak> neutrino: try to read, check current time, repeat
13:14:54 <neutrino> rwbarton: how does it change whether you're blocking or not blocking?
13:15:04 <neutrino> mm_freak: i have no idea what you're talking about
13:15:08 <neutrino> mm_freak: :(
13:15:15 <mm_freak> neutrino: you said you want to read as much as possible for a given amount of time
13:15:28 <neutrino> yeah, the given amount of time is 0.
13:15:39 <mm_freak> didn't you mention two seconds or something?
13:15:47 <neutrino> no, that's for something else
13:15:55 <rwbarton> neutrino: that does not change, just trying to imagine what Eduard_Munteanu meant
13:15:58 * hackagebot snap 0.10.0 - Top-level package for the Snap Web Framework  http://hackage.haskell.org/package/snap-0.10.0 (DougBeardsley)
13:16:08 <mm_freak> neutrino: i see…  let's say, non-blocking is a bad design choice
13:16:21 <neutrino> rwbarton: right, but why'd he single out hGetBufNonBlocking over that? i can't understand..
13:16:26 <neutrino> mm_freak: why
13:16:42 <neutrino> non-blocking considered harmful?
13:16:45 <mm_freak> neutrino: normally when you use non-blocking I/O it indicates that your application is wrongly designed…  you should really use concurrency and let the RTS handle the multiplexing
13:17:29 <mm_freak> there are a some rare exceptions though, so do you mind explaining your application?
13:17:55 <neutrino> i need to multiplex between "read stuff" and "signal it's been two seconds" anyways
13:18:27 <neutrino> my application is that i need to pipe data from one handle to another, and if nothing has been piped for two seconds i need to call a function
13:18:48 <mm_freak> does the piping end at that point?
13:18:55 <neutrino> the writing happens through several layers of processing, e.g. replacing newlines with a string
13:19:00 <neutrino> yes
13:19:29 <mm_freak> my way would be to use STM:  one thread reads, another one writes…  the writer waits for at most two seconds
13:19:43 <mm_freak> it's very easy to time out STM actions using registerDelay
13:19:49 <mm_freak> just as i did in my code example
13:20:10 <mSSM> What is the performance of changing one value in an unmutable Vector structure compared to Data.Map? At the moment, my program seems to spend most time looking up stuff in my Data.Map, but I don't want to trade O(1) reading for super slow writing.
13:20:14 <neutrino> that is all, i am running a subprocess, saving its output to disk and writing it to the tty in several mangled forms, and updating a timestamp of last activity which is saved in a db somewhere
13:20:18 <neutrino> i haven't been able to look at your example yet
13:20:50 <mm_freak> mSSM: depends
13:21:06 <mm_freak> mSSM: when fusion applies the performance can be very high, but usually the performance is O(n)
13:21:21 <mm_freak> if you need to change individual elements you should use Data.Map or something similar
13:21:57 <Industrial> jmcarthur: https://gist.github.com/548201904411b30f7435/160f039e054376aa749b82227d6347c36fc3c18b I'm getting there and I can run the program without arguments and with one argument but not with more then one.
13:22:12 <neutrino> in your code, what is "c"?
13:22:38 <mm_freak> neutrino: the action to perform, but the code doesn't apply to your scenario…  let me write another combinator
13:22:54 <neutrino> ok
13:23:04 <Industrial> Also, I'm not sure if rawSystem is the best way to run a commandline program like ls but eventually I'd like each line of the ouput as a string in a list .. so I can sort it before printing
13:23:12 <neutrino> not sure why it's a "combinator"
13:23:14 <neutrino> what does it combine?
13:23:19 <shiny_tears> I was wondering how I can conveniently use a set data structure in Haskell. For instance, in Python I know you can do something to the effect of "set([1,1,2,3,44])" which will drop a list into a set.
13:23:34 <mSSM> mm_freak: the structure is very small; 2^6, maybe 2^10; but the lookup seems to take 40% of the program's time (at least profiling says that).
13:23:47 <rwbarton> > S.fromList [1,1,2,3,44]
13:23:49 <lambdabot>   fromList [1,2,3,44]
13:24:02 <rwbarton> shiny_tears: ^ import qualified Data.Set as S
13:24:11 <shiny_tears> ah....
13:24:14 <shiny_tears> great
13:24:39 <Industrial> jmcarthur: I see that if I add patterns like ls [x, y] = ... then it works for more arguments but I guess I want variable arguments to work ..
13:26:14 <neutrino> @type (<*)
13:26:16 <lambdabot> Applicative f => f a -> f b -> f a
13:26:32 <neutrino> @src (<*)
13:26:32 <lambdabot> (<*) = liftA2 const
13:26:48 <neutrino> @src liftA2
13:26:48 <lambdabot> liftA2 f a b = f <$> a <*> b
13:27:18 <neutrino> @src (<$>)
13:27:18 <lambdabot> f <$> a = fmap f a
13:27:30 <neutrino> @src (<*>)
13:27:30 <lambdabot> Source not found. I've seen penguins that can type better than that.
13:27:38 <neutrino> :\
13:27:44 <hpaste> “Ertugrul Söylemez” pasted “passFor: Pass for the given amount of time” at http://hpaste.org/79015
13:27:48 <mm_freak> neutrino: see pate
13:27:49 <mm_freak> paste
13:27:59 <neutrino> which paste?
13:28:00 <b_____> does anyone know if a proper integer square-root function is faster than a fromIntegered regular sqrt?
13:28:01 <jmcarthur> Industrial: did what i showed you not work?
13:28:09 <mm_freak> neutrino: http://hpaste.org/79015
13:28:09 <jmcarthur> Industrial: it should already do what you want
13:28:12 <neutrino> ok
13:28:17 <jmcarthur> Industrial: in terms of how input works, that is
13:28:34 <neutrino> mm_freak: so what does it do?
13:28:48 <mm_freak> mSSM: another option is to use a mutable vector
13:29:13 <mm_freak> neutrino: passes values from 'get' to 'put', unless 'get' doesn't produce anything for the given amount of time
13:29:33 <mSSM> mm_freak: What
13:29:34 <mSSM> sorry
13:29:44 <neutrino> i am not sure that is the greatest idea
13:29:46 <mSSM> mm_freak: what's the write speed there? O(1) ?
13:29:56 <mm_freak> neutrino: it's what you described
13:30:02 <mm_freak> mSSM: O(1)
13:30:16 <mm_freak> mSSM: but it forces at least your array code to be imperative
13:30:17 <neutrino> you end up spawning threads possibly every few bytes
13:30:26 <neutrino> that sounds like a bad idea
13:30:31 <mm_freak> neutrino: the code uses exactly two threads
13:30:46 <Industrial> jmcarthur: right it does.
13:30:47 <mm_freak> the main thread and the getter thread
13:30:59 <neutrino> which get respawned if nothing happens for two seconds
13:31:13 <mm_freak> neutrino: spawning threads is cheap
13:31:47 <neutrino> i'm still not sure why hGetBufNonBlocking is bad
13:32:12 <neutrino> you create an insane amount of complexity just to prevent yourself from using it
13:32:29 <mm_freak> neutrino: you would create that complexity anyway
13:32:35 <neutrino> why would i?
13:32:43 <mm_freak> how do you handle timeout?
13:32:53 <neutrino> i don't, i'm non-blocking
13:33:05 <mm_freak> yes, but you want to stop after two seconds, when nothing arrives
13:33:18 <neutrino> i don't want to stop
13:33:34 <neutrino> i want to run a function if nothing happened for two seconds
13:33:47 <mm_freak> no matter what you want to do…  you want to respond to silence for two seconds
13:33:49 <neutrino> but i still want to continue working
13:33:52 <jmcarthur> neutrino: what you're describing now sounds even better for threads than what we thought you wanted
13:34:13 <mm_freak> neutrino: to understand what i mean, just try to write it using hGetBufNonBlocking
13:34:24 <neutrino> how would you do that with threads jmcarthur
13:34:29 <jmcarthur> neutrino: you just have a ticker thread sending events through a channel every two second, another thread writing data into it whenever the data is available, and a thread reading from the channel
13:34:43 <Eduard_Munteanu> neutrino: non-blocking I/O isn't the issue there, rather trying to figure message boundaries when you don't have them.
13:34:47 <neutrino> why do i have a thread sending events?
13:34:58 <neutrino> Eduard_Munteanu: what are message boundaries?
13:35:01 <jmcarthur> neutrino: it's that two second thing you're talking about
13:35:03 <mm_freak> jmcarthur: neutrino wants to avoid concurrency altogether
13:35:12 <neutrino> jmcarthur: i don't get it
13:35:17 <jmcarthur> nonblocking io *is* concurrency
13:35:24 <mm_freak> and he will understand that a busy loop is the only alternative
13:35:29 <neutrino> mm_freak: no, i want to avoid having twenty cranks in something that just needs a button
13:35:34 <Eduard_Munteanu> neutrino: checking whether the process writing to you is done writing, and waiting for input
13:35:41 <mm_freak> neutrino: again, just try to write it
13:35:49 <jmcarthur> neutrino: threads are not as heavyweight as you seem to be thinking, either syntactically or at runtime
13:36:13 <Eduard_Munteanu> Brb, making coffee
13:36:17 <mm_freak> neutrino: anyway, the threading code is translated to something you might have written by hand in another language…  you confuse haskell threads with OS threads
13:36:21 <neutrino> mm_freak: if i write it, and it works, i'll probably be happy with it and won't pursue your solution at all. it's not going to "show me".
13:36:23 <mm_freak> there is nothing wrong with creating millions of threads
13:36:37 <Industrial> jmcarthur: I'm not sure what rawSystem does but it doesn't return a list/string pretty sure. This is the way to get ls output? http://hackage.haskell.org/packages/archive/process/1.1.0.2/doc/html/System-Process.html I'm not sure I understand what happens there :S
13:37:04 <neutrino> mm_freak: i don't, i just see threads, MVars, "atomically", and other junk, and i think that's very very superfluous
13:37:05 <mm_freak> neutrino: yes, i'll be very amazed if your solution is shorter than mine =)
13:37:21 <neutrino> so would i, because your solution is very dense
13:37:32 <neutrino> but "shorter" doesn't mean "simpler"
13:37:35 <mm_freak> it's not…  STM is a concept, not just a library…  i use STM very often, even for small programs
13:37:40 <neutrino> i'm looking for simplicity, not density of code
13:37:47 <jmcarthur> neutrino: to summarize my understanding of what you want, you just want to be constantly reading from some handle, and you also want to do something every time you block for at least two seconds?
13:38:03 <mm_freak> my solution /is/ simple…  the apparent complexity comes from your unfamiliarity with STM and haskell concurrency
13:38:18 <neutrino> mm_freak: yes, i believe it does
13:38:39 <neutrino> Eduard_Munteanu: why do i need to check whether the process is done writing?
13:38:43 <mm_freak> neutrino: concurrency is haskell's answer to non-blocking I/O and explicit polling
13:39:49 <djahandarie> Does anyone know how long a forkIO takes to happen, approximately?
13:39:52 <neutrino> i don't understand 90% of the code you just pasted
13:40:19 <copumpkin> djahandarie: exactly 4 minutes
13:40:25 <djahandarie> Thanks copumpkin
13:40:28 <copumpkin> np
13:40:32 <jmcarthur> Industrial: i'm talking about its input. you were saying stuff about pattern matching on lists. you don't need to do that
13:40:34 * djahandarie smashes the pumpkin
13:40:47 <neutrino> nooo no smashing pumpkins
13:41:25 <mm_freak> djahandarie: main = replicateM_ 1000000 . forkIO $ return ()
13:41:30 <mm_freak> that program takes 800 ms on my system
13:42:06 <djahandarie> I'm trying to make something which does a connect flood to a given IP (for load testing), but I can't seem to get the timing down properly. I tried using usleep instead of threadDelay but that didn't help particularly.
13:42:11 <mm_freak> neutrino: learn concurrency first…  an easy way is to write a small telnet chat server
13:42:22 <mm_freak> then have a look at STM and rewrite your chat server using it
13:42:23 <Industrial> jmcarthur: I got it working, but I don't understand how to get the output in a list instead of on the screen
13:42:37 <jmcarthur> :t lines
13:42:38 <lambdabot> String -> [String]
13:43:03 <Industrial> jmcarthur: I'm not sure what rawSystem does so I looked at System.Process.createProcess
13:43:08 <mm_freak> djahandarie: forever . join . readMVar $ actionVar
13:43:17 <mSSM> For inserting something new into an unmutable vector, do I slize it in 2, remove the head of one slice, concat the new value and put them both back together (like for a list)? Or is there a smarter way?
13:43:23 <mm_freak> djahandarie: then use a thread to write to that MVar periodically
13:43:33 <rwbarton> isn't there a function to update a single element of an immutable vector
13:43:36 <djahandarie> Ah, maybe that would be better.
13:43:42 <copumpkin> rwbarton: I don't think so
13:43:44 <hpaste> dj pasted “.” at http://hpaste.org/79016
13:43:48 <rwbarton> no (//)?
13:43:56 <djahandarie> mm_freak, that's what I was doing, but I'll try your solution out.
13:44:11 <copumpkin> oh, there is //
13:44:12 <jmcarthur> neutrino: are you wanting to get any bytes that are available, or do you only care about, say, line boundaries?
13:44:17 <mm_freak> mSSM: perhaps what you want is a hash table instead of an array
13:44:22 <djahandarie> mm_freak, (that paste, I mean.)
13:44:35 <copumpkin> rwbarton: http://hackage.haskell.org/packages/archive/vector/0.10.0.1/doc/html/src/Data-Vector.html#%2F%2F
13:44:38 <mm_freak> djahandarie: that paste may be overkill for your scenario
13:45:01 <copumpkin> rwbarton: there's even one with no bounds checking!
13:45:05 <mm_freak> (because of the timeout stuff)
13:45:08 <rwbarton> unsafeReallySlowUpdate
13:45:11 <copumpkin> lol
13:45:30 <mSSM> mm_freak: but a hashtable is also mutable; in that case I could just use a mutable array
13:45:46 <djahandarie> mm_freak, wouldn't I have the exact same thing just writing to an MVar instead of forking?
13:45:48 <mm_freak> mSSM: a hash table takes care of extending/shrinking for you
13:46:15 <mm_freak> djahandarie: you need a separate writer thread
13:46:15 <mSSM> mm_freak: I don't even need extending/shrinking; the size will stay the same. But one value in it will get replaced.
13:46:35 <mm_freak> mSSM: then an array would be fine, if your indices are Int
13:46:44 <djahandarie> mm_freak, yes. I'm just wondering how this would be overkill.
13:46:45 <Eduard_Munteanu> neutrino: I don't know the context, I got highlighted by that message.
13:47:01 <Eduard_Munteanu> neutrino: what are you trying to do?
13:47:36 <mSSM> mm_freak: yeah, that's the case. Technically the indices are a (x,y) structure, but I am mapping them into a 1d-structure and handle that back-and-forth mapping in a function.
13:47:43 <mSSM> rwbarton: thanks for //
13:47:58 <mSSM> rwbarton: I was looking at vector 0.5  ... not much in there
13:48:35 <mSSM> How do I quickly find the most-up-to-date documentation of a package? I keep searching in google, but that gives me ooold stuff. hoogle has too many results.
13:48:52 <mapf> hm, interesting, such code  `type instance TF (Con a b c) = '(TF1 a, TF2 (TF3 b))'    requires UndecidableInstances because of `Nested Family Application'
13:49:17 <Taneb> mSSM, Hackage
13:49:20 <fari> mSSM: what about hackage?
13:49:22 <Taneb> @hackage transformers
13:49:22 <lambdabot> http://hackage.haskell.org/package/transformers
13:49:24 <mapf> i'm still not convinced why this happens
13:49:35 <Taneb> @hackage vector
13:49:35 <lambdabot> http://hackage.haskell.org/package/vector
13:49:55 <Eduard_Munteanu> @hackage doesn't actually search at all
13:49:55 <lambdabot> http://hackage.haskell.org/package/doesn't actually search at all
13:50:17 <mSSM> hackage doesn't search
13:53:09 <parcs`> mapf: probably because ghc is conservative/can't guarantee that such an instance won't potentially make the compiler loop
13:53:10 <hpaste> jmcarthur pasted “async for neutrino” at http://hpaste.org/79017
13:53:29 <jmcarthur> neutrino: i think that should not be very hard to understand ^^
13:53:34 <jmcarthur> i *hope
13:57:57 <mSSM> How do I qualify imported operators properly? E.g. (//) from vector: Data.Vector.Unmutable.(//) doesn't seem to work
13:58:32 <mapf> parcs`: so, that is UndeciableInstances allows us to do. But I can't imagine case in which that loop happens with nested type family application
13:58:55 <hpaste> “Ertugrul Söylemez” pasted “Do something periodically” at http://hpaste.org/79018
13:59:01 <mm_freak> djahandarie: http://hpaste.org/79018
13:59:19 <jmcarthur> mSSM: a Data.Vector.Unmutable.// b   or   (Data.Vector.Unmutable.//) a b
13:59:22 <mm_freak> djahandarie: gets it right, even if the producer takes some non-negligible time
13:59:26 <djahandarie> mm_freak, I tried a version using takeMVar and putMVar and couldn't get it faster than 20000 per second or so. I'll check your paste
13:59:52 <mm_freak> oh
14:00:13 <mm_freak> well, diffUTCTime is slow unfortunately…  slow enough to become a bottleneck for your application
14:00:27 <mm_freak> i've run into that bottleneck with netwire
14:00:45 <mm_freak> using diffUTCTime i get around 70k FPS
14:00:58 <mSSM> jmcarthur: thanks
14:02:03 <djahandarie> Actually, I can't get this much faster than 5k/s without it getting bogged.
14:02:07 <djahandarie> I guess I should try profiling it.
14:02:17 <fari> btw, which library would you recommend me for parsing html and some data extraction?
14:02:42 <Eduard_Munteanu> fari: HXT is nice
14:03:13 <Eduard_Munteanu> You can extract data using XPath selectors.
14:03:25 <djahandarie> usleep really does much much better than threadDelay at low frequencies though.
14:03:32 <djahandarie> At least the way I'm using it
14:03:48 <Eduard_Munteanu> Albeit a bit slow last time I tried it.
14:03:58 <djahandarie> Or high frequencies, rather.
14:04:00 <Glowball> Hi. How can I match a list of empty lists?
14:04:19 <shachaf> What?
14:04:23 <shachaf> What are you trying to do?
14:04:29 <shachaf> A type and/or example would be good.
14:04:34 <jmcarthur> :t all null
14:04:35 <parcs`> Glowball: all (null list)
14:04:36 <lambdabot> [[a]] -> Bool
14:04:39 <Glowball> I've got a list of lists as my input, and I want to match when they're all empty
14:04:42 <parcs`> er, all null list
14:04:59 <fari> Eduard_Munteanu: thx, do you have expierience particularly with extracting some pieces of (formated) text from existing web page?
14:05:08 <Glowball> [] doesn't work, because the outer list isn't empty (it contains empty lists), and [[]] doesn't work either, because that would mean the outer list contains exactly one empty list
14:05:11 <uiopqwer> how can i concatenate an IO string and a string. i want to concatenate getEnv "HOME" with "/foo/bar/"
14:05:14 <Glowball> parcs`: Thanks, I'll have a look
14:05:29 <Eduard_Munteanu> fari: yeah, that's what I used it for, extracting data from some website.
14:05:32 <shachaf> Glowball: Well, that's not "matching" exactly because there are lots of different patterns.
14:05:44 <Eduard_Munteanu> s/data/text/
14:05:51 <shachaf> If you want constraints like "the outer list isn't empty" then it gets more complicated.
14:06:01 <djahandarie> mm_freak, I think using libev in C you can do almost 100kpps, I'm really curious where the bottleneck is in this fairly simple program.
14:06:03 <Glowball> I want the outer list to contain only empty lists
14:06:04 <shachaf> Another way of doing it would be checking if "concat list" is empty.
14:06:13 <shachaf> OK, but [] contains only empty lists.
14:06:23 <djahandarie> mm_freak, or 100k conns/sec rather.
14:06:28 <mm_freak> djahandarie: in my code it's diffUTCTime
14:06:29 <parcs`> uiopqwer: fmap ("/foo/bar/" ++) (getEnv "HOME")
14:06:49 <mm_freak> djahandarie: if you get rid of it and use threadDelay directly you may get a huge speedup at high frequencies
14:07:21 <hpaste> dj annotated “.” with “. (annotation)” at http://hpaste.org/79016#a79019
14:07:28 <parcs`> uiopqwer: err for your use case it would be (++ "/foo/bar/")
14:07:35 <Eduard_Munteanu> uiopqwer: fmap, <$>
14:07:42 <djahandarie> mm_freak, http://hpaste.org/79016#a79019 is my version using MVars
14:08:01 <Glowball> shachaf: Should [] match [[],[],[]] ?
14:08:11 <Eduard_Munteanu> Glowball: no
14:08:18 <Eduard_Munteanu> Glowball: use guards
14:08:33 <jmcarthur> > all null [[], [], []]
14:08:34 <Eduard_Munteanu> foo xs | all null xs -> ...
14:08:35 <lambdabot>   True
14:08:35 <shachaf> Glowball: You won't be able to use one pattern for lots of different lists. :-)
14:08:38 <jmcarthur> > all null [[], [], [a,b,c]]
14:08:40 <lambdabot>   False
14:09:02 <Eduard_Munteanu> erm... s/->/=/
14:09:06 <Glowball|> I'm sorry, my new laptop has a bad habit of getting disconnected often... I'm on my desktop now
14:09:26 <Glowball|> I have missed everything after shachaf's "Another way of doing it would be checking if "concat list" is empty"
14:09:29 <shachaf> Please see the logs: http://tunes.org/~nef/logs/haskell/12.12.09
14:09:34 <Glowball|> Thanks
14:09:41 <shachaf> (Not that there's much to see.)
14:10:40 <Glowball|> Eduard_Munteanu: I'll try guards, thanks :)
14:11:53 <parcs`> > transpose [[], [], [a,b,c]]
14:11:54 <lambdabot>   [[a],[b],[c]]
14:12:24 <Eduard_Munteanu> > transpose [[], [], [a,b,c]]
14:12:25 <Glowball|> Awesome! Got it working already :)
14:12:25 <lambdabot>   [[a],[b],[c]]
14:12:30 <Eduard_Munteanu> > transpose $ transpose [[], [], [a,b,c]]
14:12:31 <Glowball|> Thanks guys :)
14:12:32 <lambdabot>   [[a,b,c]]
14:12:57 <tryhaskell> i want to implement a tree function in haskell where i give a path and a tree and get a value... but i dont know how
14:13:00 <mvj4> how do I put a C header file in a cabal package? it should be installed in /usr/include or similar.
14:13:07 <copumpkin> > getZipList . foldMap ZipList $ [[], [], [a,b,c]]
14:13:09 <lambdabot>   No instance for (Data.Monoid.Monoid
14:13:09 <lambdabot>                     (Control.Applicativ...
14:13:27 <copumpkin> > getZipList . Data.Traversable.traverse ZipList $ [[], [], [a,b,c]]
14:13:29 <lambdabot>   []
14:13:32 <copumpkin> :(
14:14:09 <Eduard_Munteanu> tryhaskell: ok, what are you having difficulties with / what are you stuck on?
14:14:30 <shachaf> > tranposeOf traverse [[],[],"abc"]
14:14:30 <kniu> is there a monadic equivalent to <$> and <*>
14:14:31 <lambdabot>   Not in scope: `tranposeOf'
14:14:31 <lambdabot>  Perhaps you meant one of these:
14:14:31 <lambdabot>    `transposeOf...
14:14:34 <kniu> I mean, like
14:14:41 <Eduard_Munteanu> :t liftM
14:14:42 <shachaf> > transposeOf traverse [[],[],"abc"]
14:14:42 <lambdabot> Monad m => (a1 -> r) -> m a1 -> m r
14:14:43 <Eduard_Munteanu> :t ap
14:14:44 <lambdabot>   []
14:14:45 <lambdabot> Monad m => m (a -> b) -> m a -> m b
14:14:45 <copumpkin> kniu: liftM and ap
14:14:45 <shachaf> > transpose [[],[],"abc"]
14:14:46 <lambdabot>   ["a","b","c"]
14:14:52 <shachaf> Shouldn't transposeOf traverse = transpose?
14:15:05 <kniu> :t liftM
14:15:06 <lambdabot> Monad m => (a1 -> r) -> m a1 -> m r
14:15:21 <kniu> okay how about
14:15:21 <copumpkin> shachaf: I hope not
14:15:36 <kniu> @hoogle (a -> m b) -> m a -> m b
14:15:36 <lambdabot> Prelude (=<<) :: Monad m => (a -> m b) -> m a -> m b
14:15:36 <lambdabot> Control.Monad (=<<) :: Monad m => (a -> m b) -> m a -> m b
14:15:36 <lambdabot> Prelude (>>=) :: Monad m => m a -> (a -> m b) -> m b
14:15:41 * shachaf looks.
14:15:51 <copumpkin> :t transposeOf
14:15:52 <lambdabot> LensLike ZipList s t [a] a -> s -> [t]
14:16:02 <kniu> but one that doesn't require me to use parentheses
14:16:11 <neutrino> jmcarthur: thanks, i'm reading your and mm_freak's code and trying to understand it
14:16:12 <shachaf> Oh, for non-ragged input.
14:16:14 <edwardk> shachaf: its a little bit worse than transpose iirc
14:16:19 <edwardk> the ragged input support isn't there
14:16:20 <edwardk> yeah
14:16:22 <copumpkin> I think it's better!
14:16:33 <neutrino> jmcarthur: i care about any bytes
14:16:34 <copumpkin> because the ragged support is horrible special-casing for an imprecise type
14:16:36 <edwardk> copumpkin suggested transposeOf
14:16:40 <uiopqwer> parcs`, Eduard_Munteanu: i'm still having trouble concatenating: http://ideone.com/bn1WS1
14:16:42 <mm_freak> djahandarie: did you ever measure the raw performance?
14:16:47 <shachaf> copumpkin: But it helps us golf so much!
14:16:50 <shachaf> @where e_10
14:16:50 <lambdabot> [show(sum$scanl div(100^n)[1..[4..]!!n])!!n|n<-[0..]]
14:16:53 <shachaf> Hmm.
14:16:56 <shachaf> @where pi_10
14:16:56 <lambdabot> (take 100) [show(foldr(\k a->20*100^n+a*k`div`(2*k+1))0[1..[4,8..]!!n])!!n|n<-[0..]]
14:16:57 <mm_freak> djahandarie: i.e. without actually making connections
14:17:01 <shachaf> I guess it doesn't?
14:17:09 <djahandarie> mm_freak, no, I haven't.
14:17:10 <shachaf> @where pi_11
14:17:11 <lambdabot> [show(foldr(\k a->2*10^2^n+a*k`div`(2*k+1))0[1..4*2^n])!!n|n<-[0..]]
14:17:11 <copumpkin> wow, e got really short
14:17:19 <shachaf> @@ @run @where e_10
14:17:21 <djahandarie> mm_freak, I was actually planning on not needing to optimize this at all :P
14:17:22 <lambdabot>   "27182818284590452353602874713526624977572470936999595749669676277240766303...
14:17:46 <mm_freak> djahandarie: making connections is a bottleneck
14:17:59 <mm_freak> at least in linux
14:18:00 <rwbarton> "[1..[4..]!!n]"?
14:18:17 <rwbarton> isn't that [1..4+n]?
14:18:21 <mm_freak> djahandarie: that's basically the reason why nmap doesn't use stream sockets, but builds its packets itself instead
14:18:22 <Eduard_Munteanu> tryhaskell: let's talk in here
14:18:50 <djahandarie> mm_freak, right. But I do need to do more than just generate SYNs, it needs to actually complete the full connection. Would be kind of annoying to do that manually.
14:18:59 <shachaf> > [show(sum$scanl div(100^n)[1..4+n])!!n|n<-[0..]]
14:19:00 <lambdabot>   "2718281828150208757*Exception: Prelude.(!!): index too large
14:19:07 <mm_freak> djahandarie: i understand that
14:19:20 <rwbarton> > [show(sum$scanl div(100^n)[1..[4..]!!n])!!n|n<-[0..]]
14:19:22 <lambdabot>   "27182818284590452353602874713526624977572470936999595749669676277240766303...
14:19:23 <mm_freak> djahandarie: have you tried /not/ using -threaded?
14:19:26 <djahandarie> mm_freak, I just tried it without making connections, it still can't handle doing that many forkIOs it seems.
14:19:26 <rwbarton> hmmm
14:19:33 <rwbarton> oh, int to integer
14:19:38 <djahandarie> mm_freak, no, I haven't tried that, but wouldn't the IO be blocking if there was no -threaded?
14:19:39 <copumpkin> lol
14:19:46 <mm_freak> djahandarie: one million forkIOs take 800 ms here
14:19:49 <rwbarton> i thought about int to double, but there were no doubles
14:20:03 <tryhaskell> Eduard_Munteanu: ok
14:20:08 <Eduard_Munteanu> tryhaskell: how's your tree defined?
14:20:32 <djahandarie> mm_freak, I think the problem is that the time it takes to forkIO is still being included in the time for each cycle.
14:20:36 <Eduard_Munteanu> You probably want something like   path :: [Bool] -> Tree a -> a
14:20:44 <tryhaskell> Eduard_Munteanu: leaves :: Tree a -> [a] leaves Nil	= [] leaves (Leaf a) = [a] leaves (Br l r) = leaves l ++ leaves r
14:20:52 <mm_freak> djahandarie: certainly…  that's why my code performs time correction
14:20:59 <neutrino> jmcarthur: that's pretty damn easy to follow, thanks
14:21:09 <neutrino> jmcarthur: let me grok it a little bit more
14:21:17 <mm_freak> djahandarie: you get exactly the rate you wanted modulo system load
14:21:23 <Eduard_Munteanu> tryhaskell: alright so   data Tree a = Leaf a | Br (Tree a) (Tree a)
14:21:38 <kniu> is there a better way to write: join (f <$> x <*> y)
14:21:43 <djahandarie> mm_freak, but how does one deal with that without using the slow time libraries?
14:21:50 <mm_freak> kniu: not really
14:22:04 <kniu> mm_freak: are you sure?
14:22:09 <mm_freak> djahandarie: you could use SDL
14:22:11 <shachaf> Some people call it bind2 or something.
14:22:12 <tryhaskell> Eduard_Munteanu: yes and Nil for an empty leav
14:22:14 <mm_freak> kniu: pretty sure
14:22:18 <kniu> bummer
14:22:21 <`ramses> :t \f x y -> join (f <$> x <*> y)
14:22:22 <Eduard_Munteanu> Ah, right.
14:22:23 <lambdabot> (Monad m, Applicative m) => (a2 -> a1 -> m a) -> m a2 -> m a1 -> m a
14:23:01 <kniu> alternatively, I could use a do block and be like: do {a <- x; b <- y; f x y}
14:23:11 <Eduard_Munteanu> tryhaskell: so you can see path :: [Bool] -> [a] -> Int doesn't make much sense
14:23:31 <kniu> it's longer, but maybe clearer?
14:23:37 <kniu> uh
14:23:47 <kniu> s/f x y/f a b/
14:24:04 <tryhaskell> Eduard_Munteanu:  i want to give my function a list of Bools and a list of numbers and ist should give me the right value like this : path [True,False,False] [1,2,3] = 2
14:24:09 <neutrino> jmcarthur: why do you need to do "oneLine job" in case Left () ?
14:24:55 <Eduard_Munteanu> tryhaskell: what does [1,2,3] mean? I don't see how that's a tree.
14:25:10 <Peaker> bah! looking at the code of freetype-gl, it is: A) Poorly implemented (bad algorithms),  B) Rather small.  I think maybe instead of a binding, I should just port the good parts to Haskell and write it in Haskell with sane algorithms
14:25:33 <mm_freak> ATS' syntax looks horrible…  i don't think i'll use it
14:25:44 <Peaker> mm_freak, Yeah, I tried learning ATS and got put off by that too
14:25:49 <tryhaskell> Eduard_Munteanu:  its the value of the leavs
14:25:59 * hackagebot snap-loader-static 0.9.0.1 - Snap: A Haskell Web Framework: static loader  http://hackage.haskell.org/package/snap-loader-static-0.9.0.1 (DougBeardsley)
14:26:31 <parcs`> ATS has like 4 closure types
14:26:32 <mm_freak> no practically usable lightweight functional language out there it seems =/
14:26:52 <parcs`> the language is massively complex
14:27:07 <neutrino> mm_freak: doesn't seem so bad? fun cairo_restore {l:agz} (pf: cairo_save_v l | cr: !cairo_ref l): void
14:27:12 <Eduard_Munteanu> tryhaskell: that doesn't define a tree properly, for instance take [1] corresponding to both Br (Leaf 1) Nil and Br Nil (Leaf 1)
14:27:22 <neutrino> parcs`: is it more complex than haskell?
14:27:26 <mSSM> Can I force strict evaluation inside a map? E.g. in `map (f myvec) [1,2,3,4]', I would like to have each application of (f myvec) applied strictly
14:27:35 <mm_freak> neutrino: i have no idea what your code does except that it probably has something to do with the cairo library
14:27:36 <copumpkin> mSSM: no
14:27:57 <neutrino> mm_freak: i have no idea what it does either, i just googled for some code and decided it doesn't look so bad
14:28:06 <neutrino> =)
14:28:10 <parcs`> neutrino: i think so
14:28:11 <mm_freak> lol
14:28:26 <neutrino> parcs`: ok
14:28:27 <tryhaskell> Eduard_Munteanu:  my bad, i mean somethin like this (Br (Br (Leaf 1) (Leav 2)) Leav 3))
14:28:34 <Puffton> Why is newtype limited to just one value constructor?
14:28:38 <mm_freak> mSSM: you don't do that when mapping, but when consuming
14:29:05 <mm_freak> Puffton: because a newtype has exactly the same runtime representation as the constructor's argument
14:29:10 <Eduard_Munteanu> tryhaskell: anyway a list of leaves doesn't tell you anything about the shape of the tree
14:29:11 <copumpkin> Puffton: because it doesn't exist at runtime
14:29:11 <copumpkin> Puffton: it's purely a device for the typechecker, and is represented by exactly what the underlying type is at runtime
14:29:19 <mSSM> mm_freak: you mean when I then for example sum the resulting [Int] (in my case)?
14:29:25 <mm_freak> mSSM: yes
14:29:38 <tryhaskell> Eduard_Munteanu: but this does (Br (Br (Leaf 1) (Leav 2)) Leav 3))
14:29:50 <copumpkin> mSSM: you can use deepseq to force it if you really want, but in most cases you probably don't need it
14:29:56 <neutrino> http://rosettacode.org/wiki/99_Bottles_of_Beer#ATS
14:29:59 <uiopqwer> parcs`: this seems to work: return $ fmap (++ "/foo/bar/") [myHomeDir], but i can't seem to use this because the function i'm passing into expects a String, not an IO String :( is there a way around this?
14:29:59 <mm_freak> deepseq is evil
14:30:04 <Eduard_Munteanu> tryhaskell: yeah, that works... so path :: [Bool] -> Tree a -> a should do
14:30:04 <copumpkin> I wouldn't say it's evil
14:30:10 <copumpkin> you just don't want it for most things
14:30:35 <mm_freak> i can't think of a valid use case for deepseq except to work around badly designed libraries
14:30:46 <copumpkin> it exists to ensure evaluation happens in the right thread
14:31:00 <mm_freak> i use seq for that
14:31:06 <tryhaskell> Eduard_Munteanu:  ok i got this. and now we have to do the recursion start right?
14:31:15 <Puffton> copumpkin, newtype is basically just substitution before runtime?
14:31:15 <copumpkin> mm_freak: you do that on the list that mSSM's map produces, you haven't ensured anything
14:31:51 <Eduard_Munteanu> tryhaskell: actually there's a problem with that as well, you probably want    path :: [Bool] -> Tree a -> Maybe a   since the path could either be invalid, or not reach a leaf.
14:31:56 <mm_freak> Puffton: "newtype MyType = MyType Int" is basically the same as Int, but doesn't unify with Int
14:32:23 <mm_freak> Puffton: in other words, trying to use an Int where a MyType is expected you get a type error…  no difference otherwise
14:32:27 <Eduard_Munteanu> tryhaskell: and yeah, you want to recurse on the path argument.
14:32:32 <mm_freak> also newtypes can refer to themselves
14:32:45 <Puffton> oh the type checker runs on load-time too, but before the "substitution" from newtype to the underlying type?
14:32:56 <mm_freak> what substitution?
14:33:06 <Puffton> I thought internally it would susbtitute
14:33:11 <Puffton> for the underlying type
14:33:21 <Puffton> since copumpkin said it didn't even exist at runtime
14:33:25 <napping> I hope you don't have to worry about that
14:33:25 <mm_freak> at runtime MyType is exactly the same as Int
14:33:48 <mm_freak> at compile time MyType is a different type from Int
14:33:52 <napping> http://hackage.haskell.org/trac/ghc/wiki/Commentary/Compiler/FC
14:33:57 <mm_freak> newtype Name = Name String
14:34:08 <mm_freak> when a Name is expected, you can't accidentally give a String
14:34:39 <napping> but that's how it's handled in core
14:34:49 <tryhaskell> Eduard_Munteanu: i dont know what to do now
14:34:56 <mm_freak> as a more complicated use case newtypes can refer to themselves
14:34:56 <neutrino> jmcarthur: still around?:)
14:35:02 <mm_freak> newtype Stream a = Stream (a, Stream a)
14:35:04 <Puffton> ok, I think I get it
14:35:45 <Eduard_Munteanu> tryhaskell: well, first break up the path argument, you have two cases: it's either [], or (x:xs)
14:35:56 <mm_freak> the point of newtype is that you get an entirely new, independent type with all rights other types have, but it uses reuses an existing type
14:36:18 <Eduard_Munteanu> tryhaskell: if it's [], you've reached the end of the path.
14:36:34 <Puffton> yeah I thought the typecheck/unification failure was just a side effect at first
14:36:42 <Puffton> but realized that it was probably sought-after behavior
14:36:45 <mm_freak> no, it's a main feature =)
14:36:57 <mm_freak> hence "new type" ;)
14:37:31 <tryhaskell> Eduard_Munteanu: path [] should be an error or what?
14:38:12 <Eduard_Munteanu> tryhaskell: nope, it's ok. Now break up the other argument. The first case is say    path [] (Leaf a) = ...
14:38:26 <Eduard_Munteanu> Obviously you want    path [] (Leaf a) = Just a
14:38:49 <`nand`> mm_freak: newtypes can also have different class instances; would that fall under “doesn't unify with Int”?
14:38:51 <Eduard_Munteanu> For anything else in the second argument, you'll return a Nothing.
14:39:04 <Eduard_Munteanu> (since only leaves contain values)
14:39:45 <tryhaskell> Eduard_Munteanu: that seems correct ;)
14:39:54 <mm_freak> `nand`: if falls under "new, independent type"
14:40:23 <Eduard_Munteanu> tryhaskell: alright, now try figuring out the other cases.
14:40:24 <mm_freak> but it's a good example
14:40:44 <`nand`> right, I was just confused by the phrasing “MyInt doesn't unify with Int, no difference otherwise”
14:40:53 <mm_freak> Puffton: for a nice example for a newtype see the ZipList type from Control.Applicative
14:41:00 * hackagebot snap-loader-dynamic 0.10 - Snap: A Haskell Web Framework: dynamic loader  http://hackage.haskell.org/package/snap-loader-dynamic-0.10 (DougBeardsley)
14:41:07 <tryhaskell> Eduard_Munteanu: path [] (br (tree a) (tree a)) must be error
14:41:20 <`nand`> Sum and Product are also fine examples of newtypes
14:41:25 <mm_freak> yeah
14:41:26 <Eduard_Munteanu> tryhaskell: yep
14:41:41 <mm_freak> and of course one of my favorite types:  newtype Auto a b = Auto (a -> (b, Auto a b))
14:41:42 <Eduard_Munteanu> tryhaskell: actually not an error, you can return Nothing
14:41:53 <mm_freak> because it shows recursion in newtypes =)
14:42:10 <`ramses> mm_freak: what would you use that for?
14:42:24 <mm_freak> `ramses: locally stateful programming
14:42:28 <tryhaskell> Eduard_Munteanu: but its an empty tee with values on leavs that not exist?
14:42:48 <Puffton> Is it possible to see an implementation (function, newtype or whatever) in Haskell, within GHCI?
14:42:50 <`nand`> mm_freak: why not just Mu f = Mu (f (Mu f)) and then use Mu ((a ->) ∘ (b,)) ?
14:43:11 <mm_freak> Puffton: not of functions, but you can see the implementations of newtypes by using :i
14:43:21 <Eduard_Munteanu> tryhaskell: it's not an empty tree
14:43:31 <Eduard_Munteanu> tryhaskell: it's just the path ends up somewhere in a branch
14:43:51 <tryhaskell> Eduard_Munteanu: ok i get it :D now i got a problem... how can i do pattern matching on [Bool]
14:43:58 <mm_freak> `nand`: firstly it seems like unnecessary complexity and harder to read, secondly it seems like i will need to use FlexibleContexts and FlexibleInstances for almost everything
14:44:04 <`nand`> :i gives you all type definitions, but no values
14:44:07 <`ramses> mm_freak: I don't see how that would work.. is it in the std libs?
14:44:19 <Eduard_Munteanu> tryhaskell: you have cases like (True:xs) and (False:xs)
14:44:21 <`nand`> it also gives you type class definitions and lists instances, but again no values
14:44:32 <mm_freak> `ramses: you can find a generalized automaton arrow in the 'arrows' library
14:44:44 <tryhaskell> Eduard_Munteanu: oh i didnt know that yet.... ok let me try
14:44:45 <mm_freak> `ramses: for an even more general version and the ability to do FRP see the 'netwire' library
14:45:13 <`nand`> mm_freak: well, I meant if you want to show recursion in newtypes
14:45:13 <Eduard_Munteanu> > False:[True]
14:45:15 <lambdabot>   [False,True]
14:45:37 <mm_freak> `nand`: i think Mu is too difficult to understand for a beginner
14:45:40 <`nand`> that way you just have to wrap your head around the general case
14:45:51 <mm_freak> also i've never used it
14:45:59 <`nand`> fair enough
14:46:03 <tryhaskell> Eduard_Munteanu: (True:xs) [] = Nothing ?
14:46:05 <mm_freak> Mu is nice for a theoretical discussion, but i don't see much use in practice
14:46:49 <Eduard_Munteanu> tryhaskell: nope, the second argument isn't a list, if that's what you mean, it's still a tree.
14:47:33 <Eduard_Munteanu> tryhaskell: oh, if you're asking if (True:xs) matches an empty list, no it doesn't.
14:47:38 <tryhaskell> Eduard_Munteanu: (True:xs) [a] = a
14:47:39 <Eduard_Munteanu> > (True:xs) []
14:47:40 <lambdabot>   Not in scope: `xs'
14:47:40 <lambdabot>  Perhaps you meant one of these:
14:47:40 <lambdabot>    `x' (imported from D...
14:48:04 <Eduard_Munteanu> > let (True:xs) = [] in xs
14:48:06 <lambdabot>   *Exception: <interactive>:3:5-18: Irrefutable pattern failed for pattern (G...
14:48:38 <tryhaskell> Eduard_Munteanu: i mean this! (True:xs) Leaf a = a
14:49:17 <Eduard_Munteanu> tryhaskell: that's better but still incorrect. If you reached a leaf and you want to take a right turn, you can't do it, you should return Nothing.
14:49:40 <Eduard_Munteanu> Also, Leaf a should be enclosed in parens.
14:50:10 <uiopqwer> fmap (++ "/foo/bar") (getEnv "HOME") will add a suffix to the home directory path. how can i also add a prefix?
14:50:38 <Heffalump> fmap ("/prefix" ++)
14:51:22 <tryhaskell> Eduard_Munteanu: this task is a lot of pattern matching.... but path [] Leav a = a or?
14:51:49 <Eduard_Munteanu> tryhaskell: close,  path [] (Leaf a) = Just a
14:51:49 <tryhaskell> Eduard_Munteanu: oh we got this already :D
14:52:50 <Eduard_Munteanu> Then you could say   path [] _ = Nothing  after that, such that for all other cases, it returns Nothing.
14:53:18 <Eduard_Munteanu> (for Br and Tip cases)
14:53:46 <uiopqwer> Heffalump: bingo. this does the trick: myPath <- fmap ("prefix" ++) (fmap (++ "suffix") (getEnv "HOME")). thanks!
14:54:07 <`ramses> mm_freak: am I correct that such a type would expand to something like b -> (c, b -> (c, ...)) and that you would eventually use fst to cut off the recursion? Or how does the recursion ever stop otherwise?
14:55:29 <tryhaskell> Eduard_Munteanu: path (True:xs) (Br (Tree a) (Tree b)) 	= (xs) (Tree b) is that right?
14:56:05 <Eduard_Munteanu> tryhaskell: for that case, you want to call path again recursively
14:56:33 <tryhaskell> Eduard_Munteanu: path (True:xs) (Br (Tree a) (Tree b)) 	= path (xs) (Tree b) so like this
14:56:59 <Eduard_Munteanu> tryhaskell: you're mixing up types with constructors there...
14:57:18 <Eduard_Munteanu> tryhaskell: path (True:xs) (Br l r) = path xs r
14:58:03 <Eduard_Munteanu> (mixing up types with values, rather)
14:59:00 <tryhaskell> Eduard_Munteanu: where does l and r come from?
14:59:28 <Puffton> is currying using closure internally?
15:00:03 <Eduard_Munteanu> tryhaskell: data Tree a = Br (Tree a) (Tree a) | ...     Br l r :: Tree a   for any l, r :: Tree a
15:00:11 <parcs`> currying uses pixie dust internally
15:00:17 <Eduard_Munteanu> tryhaskell: I could've said a and b just as well
15:02:43 <mSSM> Can somebody tell me why my program takes so much time reading from the vector? http://hpaste.org/79021 I tried to cut out most redundant code of my program; in the remaining part, the (|>) function I defined still is a major cost centre. I would have thought that with Vector reading should be quicker than that.
15:03:15 <tryhaskell> Eduard_Munteanu: ok the other case path (False:xs) (Br l r)  = path xs l . Am i done here?
15:03:43 <Eduard_Munteanu> tryhaskell: yeah, but you also need to handle the other cases
15:04:08 <tryhaskell> Eduard_Munteanu: this was my question  :D what other cases? ;)
15:04:44 <Eduard_Munteanu> tryhaskell: for example, path (False:xs) Tip. You can catch all of them with   path (_:xs) _ = Nothing
15:04:59 <Eduard_Munteanu> That is, if you reached the Tip and want to go left, you can't.
15:05:00 <tryhaskell> Eduard_Munteanu: what you mean with tip?
15:05:08 <tryhaskell> Eduard_Munteanu: empty leav?
15:05:33 <Eduard_Munteanu> tryhaskell: oh, sorry, you call it Nil.
15:05:43 <Eduard_Munteanu> Yeah.
15:06:51 <tryhaskell> Eduard_Munteanu: Equations give different arities for "path" :(
15:07:09 <Eduard_Munteanu> @where hpaste
15:07:09 <lambdabot> http://hpaste.org/
15:07:20 <Eduard_Munteanu> tryhaskell: pastebin your stuff there
15:07:49 <jmcarthur> neutrino: hey
15:08:08 <jmcarthur> oneLine job is
15:08:11 <jmcarthur> oops
15:08:22 <tryhaskell> Eduard_Munteanu: i did
15:08:28 <jmcarthur> neutrino: the "oneLine job" bit is because the job still isn't finished at that point
15:08:31 <Eduard_Munteanu> tryhaskell: give me a link to it :)
15:08:35 <jmcarthur> neutrino: so we still need to wait for it to finish
15:09:00 <hpaste> tryhaskell pasted “path” at http://hpaste.org/79022
15:09:21 <tryhaskell> wow
15:09:29 <tryhaskell> this is futuristic^^
15:09:40 <Eduard_Munteanu> tryhaskell: path [] Br (Tree a) (Tree a) = Nothing   is the problem, remove it completely
15:09:45 <jmcarthur> neutrino: of course, that obviously isn't what you want if you want to get all bytes, even just partial bits of a line. the idea could work for individual Chars, but i don't see any convenient function in System.IO for just getting whatever data has been buffered so far :\
15:09:48 <Eduard_Munteanu> tryhaskell: oops, wait
15:09:51 <jmcarthur> neutrino: i see less convenient ones, of course
15:09:58 <Eduard_Munteanu> tryhaskell: just add parens around Br ... .
15:10:08 <Eduard_Munteanu> path [] (Br (Tree a) (Tree a)) = Nothing
15:10:36 <Eduard_Munteanu> path (false:xs) (Leaf a) = Nothing is also wrong, you want 'False', not 'false'.
15:10:49 <tryhaskell> path [] Br (Tree a) (Tree a) is the same as path [] (Br l r) or not?
15:11:06 <Eduard_Munteanu> Uh, I'm not paying attention.
15:11:17 <rwbarton> the latter is the correct version of the former :)
15:11:36 <Eduard_Munteanu> Yeah, what rwbarton says, I'm a bit distracted.
15:12:02 <tryhaskell> so i can use l and r?
15:12:12 <Eduard_Munteanu> or a and b, or x and y :)
15:12:28 <rwbarton> or even _ and _, since you don't use them in this case
15:12:42 <rwbarton> path [] (Br _ _) = ...
15:13:10 <tryhaskell> this is funny :D Syntax error in input (unexpected symbol "r")
15:13:12 <Eduard_Munteanu> or   path [] _ = Nothing   even
15:13:12 <Elench> .
15:13:18 <Eduard_Munteanu> To handle the Nil case as well.
15:13:38 <rwbarton> mSSM: I wonder whether the time spent building the immutable Vector is being charged to the first call to |>
15:13:39 <Eduard_Munteanu> tryhaskell: what did you type?
15:13:49 <rwbarton> try forcing it earlier
15:14:02 <hpaste> tryhaskell pasted “path” at http://hpaste.org/79023
15:14:24 <Eduard_Munteanu> path [] (Br (l r)  = Nothing   is the problem, check the parens
15:14:39 <tryhaskell> ...
15:15:05 <tryhaskell> the small mistakes...
15:15:05 <Eduard_Munteanu> Just use   path [] _ = Nothing, it will handle the Nil case too.
15:15:32 <tryhaskell> doesnt that match to path [] (Leaf a)
15:15:38 <rwbarton> when you get an error, at least read the line the error was reported on, and maybe the previous line too :)
15:15:40 <mSSM> rwbarton: can I force it in a do block the same way as I would in pure code?
15:15:48 <rwbarton> how would you do it in pure code?
15:15:54 <Eduard_Munteanu> tryhaskell: patterns are matched in order, you already matched on the Leaf case.
15:15:59 <mSSM> !bla = makeMeAVector
15:16:04 <rwbarton> on line 93?
15:16:18 <tryhaskell> Eduard_Munteanu: so it has to stand under the other case?
15:16:22 <rwbarton> I think "let !foo = bar" in a do expression means something reasonable, yes...
15:16:33 <Eduard_Munteanu> tryhaskell: yes, under the path [] (Leaf a) case
15:17:24 <mSSM> rwbarton: oh, I thought you were referring to  line 112, when I bind the resulting data structure containing the vector to a value
15:18:01 <rwbarton> well, in that case you will need to make the Vector a strict field of Grid as well as binding the Grid strictly (I think)
15:18:08 <hpaste> tryhaskell pasted “path” at http://hpaste.org/79024
15:18:18 <tryhaskell> Eduard_Munteanu: this is what i got now
15:18:49 <Eduard_Munteanu> tryhaskell: looks ok
15:18:53 <Eduard_Munteanu> Does it work?
15:19:28 <Eduard_Munteanu> The path (True:xs) (Leaf a) = Nothing  cases aren't necessary though.
15:19:29 <tryhaskell> Eduard_Munteanu: by the way, sry for my bad knowledge about haskell... im new with it ( and my nativ language is not english :D )
15:19:39 <Eduard_Munteanu> You already catch them with path (_:xs) _ = Nothing.
15:19:56 <Eduard_Munteanu> Mine isn't English either. :D
15:20:30 <tryhaskell> Eduard_Munteanu: where do you come from? ;)
15:20:45 <Eduard_Munteanu> Romania.
15:21:22 <mm_freak> `ramses: it doesn't stop
15:22:48 <tryhaskell> Eduard_Munteanu: hmm i dont know what i have to insert.... :D path [True,True,False] Leaf a is actually not a correct insert? :D
15:23:16 <mSSM> rwbarton: I have added more strictness, but the main thing that seems changed it the proper space allocation.
15:25:40 <jmcarthur> ah, so nice: http://pastehtml.com/view/cl4uzxwc5.html
15:25:57 <jmcarthur> it's a contrived function for the sake of demonstrating this result
15:26:38 <tryhaskell> :(
15:33:50 <jamy23> everybody common
15:33:59 <mapf> is it possible to compare two Symbols at type level? i want   type family SymEq (p :: Symbol) (q :: Symbol) :: Bool
15:34:27 <tryhaskell> hello?
15:34:32 <tryhaskell> Eduard_Munteanu: hello?
15:35:36 <mm_freak> mapf: do you actually need the resulting boolean?  if no, normally you would just unify
15:35:50 <mm_freak> mapf: v ~ "blah"
15:37:08 <hpaste> tryhaskell pasted “path ” at http://hpaste.org/79026
15:37:17 <tryhaskell> can someone help me with this?
15:37:36 <mapf> well, i actually need something like   type family TF (p :: Symbol) (q :: Symbol) :: a; type instance TF same same = DoSomething same; type instance TF notSame notEq = DoSomthingElse notSame notEq
15:37:38 <mapf> you know
15:38:17 <mapf> well, I can't avoid boolean i guess
15:38:27 <mapf> and can't compare through
15:38:59 <mapf> why overlapping TF's are not allowed? they can be not injective anyway
15:39:43 <rwbarton> because instances can be defined in separate modules etc.
15:39:56 <rwbarton> you actually can have overlapping type families as long as they are coherent
15:40:01 <rwbarton> it's pretty neat
15:41:21 <mapf> rwbarton: what do you mean by coherent?
15:41:48 <rwbarton> two instances are coherent with each other as long as the right hand sides agree whenever the left hand sides agree
15:42:45 <rwbarton> for examples, type instance Or True b = True; type instance Or a True = True -- allowed
15:42:58 <copumpkin> oh interesting
15:43:13 <rwbarton> and that can ease type inference/evaluation
15:44:26 <MQ> hi
15:44:29 <MQ> list
15:44:41 <rwbarton> (type classes can't do this because there is a value-level thing attached to the instances, and the compiler has no way to determine whether those agree)
15:44:44 <`nand`> rwbarton: doesn't work for undecidable TFs though, right?
15:44:58 <neutrino> jmcarthur: hi there
15:45:04 <neutrino> jmcarthur: still around?
15:45:10 <rwbarton> `nand`: I don't know what you mean
15:45:33 <rwbarton> afaik for every pair of instances, it unifies the left hand sides, and tries to see whether those constraints imply that the right hand sides are equal
15:45:49 <`nand`> rwbarton: certain type family instances require UndecidableInstances since the compiler can't prove they terminate; I get the feeling that the compiler also won't recognize these as equal when they overlap; even if they technically are
15:46:32 <rwbarton> I suppose it may diverge during that last step, yes
15:46:42 * rwbarton sort of takes UndecidableInstances for granted
15:46:51 <neutrino> hey guys, can someone help me figure out what's going on in this code? http://hpaste.org/79017
15:47:17 <neutrino> it uses async, and i have no idea what it is doing
15:47:43 <`nand`> mapf: I have a feeling you'd be interested in http://hackage.haskell.org/trac/ghc/wiki/NewAxioms
15:49:06 <hpaste> mapf pasted “type families” at http://hpaste.org/79028
15:49:18 <rwbarton> last edited 6 days ago, promising
15:49:30 <neutrino> hahaha
15:50:37 <rwbarton> I wonder how these (existing) overlapping type family instances interact with contexts
15:51:05 <lispy> hello
15:51:14 <neutrino> hello lispy
15:52:05 <jmcarthur> neutrino: hey
15:52:10 <neutrino> oh hey jmcarthur
15:52:16 <neutrino> :)
15:52:25 <neutrino> got some time to hold my hand? :)
15:52:32 <jmcarthur> a little bit, yes :)
15:52:47 <neutrino> i'm really struggling here
15:52:52 <lispy> I was reading a book (yes, I know, an actual paper book) and the author said that archemedes was killed around the age of 75 because he wanted to work on a math/engineering problem instead of coming quietly when his city was conquered by the romans.
15:52:53 <neutrino> can we start from the top?
15:53:14 <lispy> talk about focus
15:53:25 <neutrino> "coming quietly"?
15:53:43 <jmcarthur> neutrino: sure. are you looking for an explanation of my code or some attempt to apply it to what you're actually trying to do?
15:53:56 <neutrino> i would like to first understand what you've done
15:54:05 <neutrino> then try to adapt it to my needs, which have changed a bit already
15:54:13 <jmcarthur> okay
15:54:36 <neutrino> ok, so forever means "loop forever"
15:54:47 <lispy> ?src forever
15:54:47 <lambdabot> Source not found. stty: unknown mode: doofus
15:54:47 <jmcarthur> neutrino: so, async getLine means "go ahead and start waiting for the next line of input, but i don't necessarily need it yet."
15:54:57 <neutrino> "async" means, i assume, launch an action in a separate thread
15:55:15 <neutrino> jmcarthur: oh
15:55:18 <jmcarthur> neutrino: it does do that, but the fact that it's in another thread is, perhaps, a low level detail
15:55:32 <`nand`> forever = sequence_ . repeat
15:55:45 <neutrino> so it's like a future or something?
15:55:50 <jmcarthur> something like that, yes
15:55:52 <neutrino> ok
15:56:01 <neutrino> and what we get back is a handle of some sort?
15:56:04 <jmcarthur> the "job" you get out of it is the future
15:56:07 <neutrino> "job"
15:56:22 <rwbarton> (have you considered reading the documentation for Control.Concurrent.Async)
15:56:39 <jmcarthur> i called it that because that's what we call it in the Async library at jane street, but that's not any official name for this library
15:56:45 <neutrino> i have, but i'm confused by it
15:57:14 <jmcarthur> "deferred" might be an okay name in place of job, i suppose
15:57:21 <neutrino> jmcarthur: right, i was just asking if "job" is a handle for the future. i guess it is.
15:57:30 <jmcarthur> it's just a value that might be known now or might be determined later
15:57:33 <neutrino> ok, so we've got that covered
15:57:44 <jmcarthur> alright
15:57:52 <jmcarthur> timeout <- async $ threadDelay 2000000  behaves similarly
15:58:25 <jmcarthur> waitEither  takes two deferreds and blocks until one of them is determined
15:58:26 <neutrino> yeah, i know what that does
15:58:34 <neutrino> i understand the rest of the code except for one bit
15:58:45 <neutrino> why do you need to recurse into oneLine when you get Left () ?
15:59:00 <jmcarthur> i did that because i assume we do eventually want to wait for that job to finish
15:59:11 <neutrino> ah
15:59:12 <jmcarthur> i don't know if that's what you actually want. it was a guess at desired behavior
15:59:36 <neutrino> but if we didn't recurse..
15:59:38 <jmcarthur> the alternative is to either kill the job or allow it to complete on its own silently
15:59:54 <neutrino> then wouldn't the next iteration of the "forever" loop try to set up the same job?
16:00:01 <jmcarthur> killing might be unreliable though since there is a bit of a race condition
16:00:11 <jmcarthur> well, it would do *another* getLine
16:00:12 <neutrino> let's say i type in "aaa" but not press enter
16:00:19 <neutrino> then i get to Left ()
16:00:41 <neutrino> now let's assume i'm not recursing. instead it just does putStrLn and terminates oneLine.
16:00:50 <jmcarthur> if you don't recurse, then another getLine will be called, and we don't necessarily know which one will get that line
16:01:00 <neutrino> oh
16:01:09 <jmcarthur> that is, there would be two jobs, each doing a getLine
16:01:11 <neutrino> so then there are two getLine's?
16:01:15 <neutrino> right
16:01:19 <neutrino> why are there two jobs?
16:01:28 <jmcarthur> the first didn't complete
16:01:34 <neutrino> i thought the old one would go out of scope, get garbage collected, and disappear?
16:01:35 <jmcarthur> or get canceled
16:01:48 <jmcarthur> the gc wouldn't be reliable even if that did happen
16:01:50 <neutrino> ok, so if i canceled the job instead of recursing it would do the same?
16:01:56 <neutrino> let me try that
16:02:06 <neutrino> because i tried just removing the recursion and it didn't work
16:02:08 <jmcarthur> canceling would introduce a race condition, unfortunately
16:02:22 <jmcarthur> because you aren't guaranteed to cancel it before it completes
16:02:30 <jmcarthur> that is, it might complete after the timeout but before the cancel
16:02:35 <jmcarthur> so you could lose a line of input
16:02:41 <neutrino> hm yes, canceling works as well
16:02:51 <neutrino> oh
16:02:54 <jmcarthur> i recommend against canceling unless losing input is okay :)
16:03:09 <neutrino> no, it's not ok
16:03:14 <neutrino> it's an interesting observation
16:03:18 <neutrino> i didn't realize that
16:04:28 <jmcarthur> any other questions? i'm about to go watch a movie with the wife
16:04:41 <neutrino> go on
16:04:46 <neutrino> that gave me food for thought
16:04:52 <neutrino> thanks a lot, have fun
16:04:53 <jmcarthur> alright. good luck!
16:04:55 <jmcarthur> thanks
16:04:56 <neutrino> thank you!
16:05:57 <Mortchek> I notice there are some newtypes in Data.Monoid that essentially represent a type together with an operation on that type. Is the reason we need those that we can't parameterize a type on a function (a value)?
16:06:52 <Mortchek> e.g., (Int, (+)) is not valid.
16:07:21 <startling> Mortchek: that's what typeclasses do. :)
16:07:41 <Mortchek> Explain?
16:07:46 <startling> Mortchek: I think you'd need full dependent typing for that to work, too.
16:08:09 <startling> Mortchek, typeclasses are desugared to dictionaries of methods
16:08:13 <Mortchek> Too? Isn't dependent typing what I'm talking about when I talk about parameterizing a type on a value?
16:08:22 <startling> Mortchek: yep!
16:08:36 <lispy> Mortchek: the newtype-just-to-make-instances thing is actually kind of obnoxious and seems like an anti-pattern
16:08:44 <startling> Mortchek: (that's like the definition of dependent typing)
16:09:08 <Mortchek> startling, I don't see how the problem here involves typeclasses. I understand that Int could be anything on which (+) is defined though.
16:09:19 <Mortchek> could rather be*
16:09:22 <kmels> is there a way to know the line on which an exception was thrown? i'm in ghci
16:10:11 <startling> Mortchek, Monoid is a typeclass that lets you specify a type and an operation on it.
16:10:21 <lispy> kmels: not really. ghci does have a debugger. I've never used the debugger so I don't know if it can help you
16:10:33 <startling> kmels, is it coming from your code?
16:10:51 <Mortchek> Sure. But to fully describe a monoid, you need a set (a type) and an operation (a value), which seems problematic.
16:11:06 <kmels> lispy, a debugger in the sense of "show me which function is being evaluated"?
16:11:10 <lispy> kmels: often I resort to "printf" style debugging by importing Debug.Trace
16:11:11 <kmels> startling, yes.
16:11:16 <lispy> kmels: yeah
16:11:35 <lispy> kmels: http://www.haskell.org/ghc/docs/latest/html/users_guide/ghci-debugger.html
16:11:36 <startling> kmels: are you throwing it yourself?
16:11:41 <hpaste> “Carlos López-Camey” pasted “Exception line?” at http://hpaste.org/79029
16:12:08 <rwbarton> what is the exception message?
16:12:27 <kmels> if you load this file and then eval `cyk "abcbcba" palyndromes`, the exception is thrown
16:12:42 <kmels> rwbarton, *** Exception: Prelude.(!!): index too large
16:12:55 <rwbarton> ah
16:13:04 <lispy> > [] !! 1
16:13:06 <lambdabot>   *Exception: Prelude.(!!): index too large
16:13:17 <startling> kmels: this is why you shouldn't use !!. :)
16:13:42 <kmels> hehe
16:13:50 <lispy> kmels: I bet you're missing a +/-1 near this line: cmbs = [((i,k),(i+k,j-k) )| k <- [0..j-1]]
16:14:14 <rwbarton> well you only use !! on two lines, and one of the lines has a trace wrapped around the value
16:15:14 <startling> @hoogle Int -> [a] -> Maybe a
16:15:15 <lambdabot> Prelude (!!) :: [a] -> Int -> a
16:15:15 <lambdabot> Data.List (!!) :: [a] -> Int -> a
16:15:15 <lambdabot> Network.BufferType buf_concat :: BufferOp a -> [a] -> a
16:15:19 <startling> >:(
16:15:47 <rwbarton> so if you put a trace on line 70 also, you should be able to see that that is where the exception is, and print out r and c and matrix and whatever
16:15:58 <Mortchek> Say we made monoids into values instead - i.e., Monoid is basically a synonym for (Set a, (a -> a -> a)). Would there be any particular issues with that?
16:16:23 <lispy> (!!!) xs n str | length xs < n = Right (xs !! n); otherwise = Left str
16:16:37 <rwbarton> Right/Left will not really help you
16:16:43 <lispy> then replace !! with !! and an error messages
16:16:47 <rwbarton> easier to just add trace
16:16:50 <lispy> error works then
16:16:59 <lispy> (!!!) xs n str | length xs < n = xs !! n; otherwise = error str
16:17:10 <lispy> The point is, you annotate the call sites with a unique message
16:17:14 <rwbarton> yeah that's not a bad idea
16:17:25 <kmels> rwbarton, right! i got those indexes, that helps, thank you
16:17:33 <lispy> But, the length xs < n, part has a bug :)
16:17:55 <lispy> the index needs to be strictly less than the length :)
16:18:32 <lispy> (and other typos, like using ; instead |, but you get what I meant)
16:18:58 <startling> ugh, I remember why hakyll annoyed me -- it recommends naming your file "hakyll.hs", which breaks the "import Hakyll" on case-insensitive filesystems. :(
16:20:18 <lispy> I've never figured out how I'm supposed to say it. hack-isle is about how I say it
16:20:32 <lispy> but maybe it's ha-kyle
16:21:01 <shachaf> lispy: There is no "silent e" at the end.
16:21:12 <rwbarton> I assumed like "hackle"
16:21:19 <shachaf> lispy: I think it's named after "jekyll".
16:21:46 <startling> I pronounce it between hackle and heckle
16:21:47 <lispy> jeh-kull? so ha-kull?
16:22:08 * shachaf will never understand attempts to write things down phonetically in English.
16:22:44 <lispy> shachaf: it's easy. Fish is phonetically written ghoti
16:22:55 <startling> is there a way I can specify "import Hakyll, not this file, no really"?
16:23:03 <lispy> https://en.wikipedia.org/wiki/Ghoti
16:23:16 <shachaf> That's nonsense, though.
16:23:30 <shachaf> There are so many good jokes you can make that don't completely ignore the silly rules of English. Why make that one?
16:23:44 <shachaf> (The rules, to the extent they exist. Which is nonzero.)
16:23:57 <lispy> shachaf: I think ghoti is about pushing things to an extreme and showing how little sense it makes
16:25:11 <shachaf> It's a peeve of mine.
16:27:06 <startling> Oh, i remember the other reason hakyll annoyed me -- each of its example blogs defines some very general "helper" functions that it would make sense to have _actually in the module_.
16:27:57 <hpc> omg i see that all the time and i hate it
16:28:08 <hpc> "alright now that you have wordpress installed let's define some functions" wat
16:28:26 <startling> yeah. >:(
16:29:07 <hpc> my holy grail of library design is enabling someone to reasonably write an entire program with just a main action
16:31:04 <Chahurga> haha
16:32:03 <rwbarton> main = doSomethingAwesome
16:32:36 <startling> main = defaults !! 2
16:32:47 <startling> (that way it's configurable)
16:35:59 <wereHamster> so I've made a small library. Should I publish it in hackage? Or just leave it on github?
16:37:43 <lfairy> wereHamster: paste a link
16:38:16 <wereHamster> lfairy: https://github.com/wereHamster/haskell-github-hook
16:38:53 <wereHamster> it's really tiny. I don't know the policy on what packages are allowed into hackage.
16:40:11 <lfairy> some packages are _really_ tiny, so I wouldn't worry about it
16:40:23 <lfairy> such as this: http://hackage.haskell.org/package/void
16:40:42 <lfairy> a type that is literally empty :)
16:41:15 <wereHamster> isn't IO () also kindof empty?
16:41:17 <wereHamster> or ()
16:41:20 <liyang> wereHamster: some packages have no code in them at all.
16:41:43 <lfairy> () isn't empty -- it's a type with one value
16:42:15 <Chahurga> I want to use absurd and vacuous in a program, they're great function names
16:42:30 <wereHamster> so, the way I understand hackage, I have to send some guy an email to get an account?
16:42:46 <lfairy> yup
16:42:57 <shachaf> () has two values.
16:43:10 <shachaf> IO () many more values.
16:43:11 <lfairy> bottom doesn't count :P
16:44:21 <wcarss_> the tryhaskell repl is printing 'terminated!' for every statement I try
16:44:30 <wereHamster> uhm.. I don't rememver *ever* having to send somebody an email to get an account. That seems really ancient.
16:44:54 <wereHamster> signup over a web page isn't that difficult..
16:44:57 <clintm> ah, those were the days.
16:45:31 <lfairy> wereHamster: it's a good anti-spam measure. if you can't send a respectable email, you can't upload a package
16:46:37 <wereHamster> not sure I agree. What kind of spam are you afraid of? I see *lots* of packages in hackage which are so old, abandonned and uusable with recent ghc.
16:46:55 <wereHamster> so this manual signup didn't appear to help there at all
16:47:04 <rwbarton> come on
16:47:12 <Chahurga> I think he means actual spam, of course
16:47:16 <rwbarton> they were not old, abandoned and unusable when they were uploaded
16:47:31 <rwbarton> (one would hope!)
16:47:40 <lfairy> exactly
16:47:44 <simpson> How do you upload something abandoned?
16:48:07 <wereHamster> probably not. but are there any spambots around which upload valid cabal packages?
16:48:28 <liyang> And the Hackage Master might do other background checks on you &c. &c.
16:48:48 <wereHamster> scary. I'll leave my package on github then :)
16:49:47 <Chahurga> wereHamster: there certainly would be if automatic registration existed, anyone who has operated a website unfortunately knows this
16:52:10 <wcarss_> cheers to those who have enough time to log into IRC and complain about having to write an email, but not to write an email
16:53:15 <wereHamster> I was just trying to find out the reason behind this.
16:54:28 <cmccann> it is a kinda silly policy.
16:54:40 <wcarss_> You've been given some reasons, and your response appears to have been to dismiss them and choose not to submit the package :P
16:55:17 <wcarss_> also, if I'm being a jerk don't hold it against them -- I just came here to ask why tryhaskell's repl was farting around terminating simple statements
16:55:28 <wereHamster> it is my choice where I submit my packages, isn't it?
16:55:37 * cmccann still doesn't have a hackage account basically because of the signup process
16:55:52 <simpson> wereHamster: Well, uh, where else will you submit them?
16:56:02 <wereHamster> nowhere. leave it where it is.
16:56:15 <simpson> 'k.
16:56:26 <lispy> I don't think the long term plan is to require email registration, but it is the currently working system
16:56:27 <wcarss_> wereHamster: just like it's your choice to take your ball and go home when people have rules you don't like. Doesn't make you a nice person!
16:56:47 <Chahurga> I don't think we need to make sweeping character judgements haha
16:57:05 <wcarss_> I'm not saying he isn't nice, but he's not demonstrating niceness :P
16:57:23 <wcarss_> though, neither am I
16:57:45 <wereHamster> wcarss_: so your idea of me being nice would be to follow your rules, regardless of whether I like them or not?
16:57:45 <lispy> wereHamster: the current hackage impl is not ideal, this we know. But please do consider getting an account. Having your stuff on hackage makse it so people can actually use it
16:57:52 <cmccann> personally I think the current system for hackage user accounts is stupid
16:58:10 <simpson> Personally, I think that tacos are delicious.
16:58:14 <wcarss_> lispy++
16:58:39 <roconnor> I think the centralized nature of hackage is stupid
16:58:42 <cmccann> I figure if anything of mine is useful enough someone else will put it on hackage for me :P
16:58:47 <roconnor> and delicous
16:58:49 <cmccann> so far that hasn't happened!
16:59:05 <lispy> cmccann: that used to happen, but the people who did that got in trouble for it and stopped
16:59:13 <lispy> I don't really know the details, though
16:59:19 <roconnor> cmccann: you don't need hackage.  You can just but put tar files with cabal files in them.
16:59:31 <cmccann> lispy, haha oh well so much for that
16:59:31 <roconnor> *just put up tar files
16:59:34 <roconnor> on your website
16:59:56 <cmccann> roconnor, not a bad idea
17:00:05 <lispy> roconnor: and then cabal-dev install <some url>?
17:00:12 <rwbarton> until someone wants to use your library as a dependency
17:00:38 <roconnor> lispy: I don't know. but you can at least download the sources and do a cabal install from the untared directory
17:00:39 <rwbarton> then we are back to the era of rpmfind.net
17:00:47 <cmccann> anyway I really don't like the attitude of "it's not our problem if you don't like it". discouraging people from uploading to hackage is not at all beneficial to the community
17:00:50 <roconnor> rwbarton: yep
17:00:50 <dcoutts_> lispy: yes, cabal install [url]
17:01:21 <roconnor> maybe if we identified packages by URL rather than some random name ...
17:01:24 <roconnor> *URI
17:01:44 <wereHamster> oh god, what discussion did I start -.- /me hides
17:01:53 * roconnor .oO( if only there was a global system for resolving names to resource locations )
17:02:17 <cmccann> anyway, my complaints are long-standing and irrelevant and unlikely to change
17:02:21 <cmccann> so I'm going back to coding
17:02:30 <Philippa> roconnor: launchMissile icbm://TheBigOne streetAddress://... ?
17:02:33 <lispy> cmccann: agreed. I don't think discouraging people was ever the intention. The current email registration system works well enough that we have a large hackage, but it's certainly not ideal.
17:03:43 <cmccann> lispy, yes, but the response to people who don't like the system for any of several reasons is all too often "deal with it or go home"
17:03:59 <lispy> cmccann: how about, pull request or go home ;)
17:04:08 <cmccann> when people take the latter option the community as a whole is getting the worse end of that deal
17:04:18 * lispy nods
17:04:33 <yitz> interestingly, the maintainers of cabal-dev have long been passed the email registration hurdle, yet...
17:05:04 <cmccann> anyway, back to these fay ffi bindings
17:05:17 <cmccann> want to get this stupid crap usable tonight >:[
17:07:27 * yitz waves hi to lispy
17:07:46 <Chahurga> cmccann: was meaning to ask about that actually, how is it?
17:08:10 <cmccann> Chahurga, currently best described as "baroque". what do you want to know?
17:08:26 <Chahurga> Have you constructed reasonbly complex web apps before? I'm wonder if I should throw out myown dialect of coffeescript and move to fay
17:08:44 <startling> is there some parsing library smaller than parsec and using mostly the Alternative combinators?
17:08:45 <cmccann> oh, you mean in general, not what I'm working on
17:09:02 <yitz> startling: attoparsec
17:09:03 <Chahurga> Oh sorry yeah
17:09:20 <cmccann> I've done lots of web dev but not in haskell. never used any other JS alternative, but from initial attempts fay is quite pleasant
17:09:32 <cmccann> and if you're going to have haskell on the back end as well it seems like the obvious choice
17:09:36 <cmccann> since you can share code
17:09:57 <startling> yitz: isn't attoparsec only for bytestrings?
17:10:00 <Chahurga> In general my applications tend to be massively front end heavy
17:10:23 <yitz> startling: Data.Text and bytestrings, lazy and strict.
17:10:24 <cmccann> was going to play with it more but I wanted to put some ffi stuff together first
17:10:28 <cmccann> and then got a bit carried away
17:11:08 <lispy> yitz: hi. Sorry we don't have a release yet. I did talk to people about it. Collectively, we're just overbooked with other stuff. The jenkin's server doesn't have machines for never ghcs/HPs and we want to do a quality release.
17:11:39 <lispy> s/never/newer
17:11:41 <Chahurga> Haha the ffi looks quite nice, I just have reservations not about haskell on the front end but rather how well you can actually fit that over the realities of JS and HTML
17:11:43 <cmccann> Chahurga, pretty soon it'd be nice if I had some help shaking out any bugs or other mistakes in this though, so if you feel like doing some heavy front end web stuff in haskell I'd be happy to encourage you
17:11:49 <startling> yitz: oh, neat.
17:11:55 <yitz> lispy: a quality release is nice, but what does that have to do with just uploading to hackage? that takes literally a few seconds
17:12:06 <yitz> lispy: (once you have that email account, of course :))
17:12:41 <Chahurga> I'm thinking about it, I've added partial functions and operator overloading to coffeescript and at this stage I'm thinking I should just actually use haskell instead of making a sad imitation
17:13:16 <cmccann> Chahurga, why not give it a shot?
17:13:29 <yitz> lispy: this is part of the problem that was being discussed above. hackage is about making it easy to use code and build on it, not about defining releases. that's something else.
17:13:51 <lispy> yitz: My point is that the release isn't being held up by hackage, it's being held up by our QA process
17:13:57 <Chahurga> Very true, nothing to lose
17:14:13 <cmccann> the "real" haskell -> js compilers are likely more promising in the end but between the subset-of-haskell and easy ffi aspects fay seems remarkably easy to pick up and run with right now
17:14:30 <yitz> lispy: if you don't want people to use it before QA, why not take the git repo offline too?
17:14:32 <Chahurga> I would prefer that route I think
17:14:40 <Chahurga> the route fay is going I mean
17:14:47 <pdxleif> There's also Roy and stuff... Chahurga
17:15:09 <cmccann> the nicest thing about fay seems to be practically no barrier to entry or initial hurdles
17:15:47 <yitz> lispy: just upload what's there now, and if you wish, add a line to the repo haddock saying that this is alpha, not a release.
17:16:38 <cmccann> Chahurga, anyway what kind of stuff would you be wanting to do? since I'm playing with ffi stuff for myself it'd be interesting to know what other people would find useful
17:17:09 <Chahurga> It wouldn't be like this at all but something of the complexity of let's say Grooveshark
17:18:00 <cmccann> not familiar with it but it looks like that uses lots of fancypants html5 stuff?
17:18:04 <cmccann> or is it flash?
17:18:26 <Chahurga> It would be something as front end heavy as that. Yup it's HTML + JS
17:19:39 <Chahurga> It'd probably be a useful experience for other people if I gave it a try too so I think I will
17:20:47 <cmccann> Chahurga, sounds fun :D
17:21:37 <lispy> yitz: I appreciate your enthusiasm and if you hadn't mentioned it to me to begin with I wouldn't have know it was such a problem. At the moment, I'm just assisting the real cabal-dev maintainers and I think you need to convince them, not me.
17:21:52 <Chahurga> I just have this tendancy to get the application to a certain stage, discover a new technology and then throw everything out and start again haha
17:22:55 <cmccann> Chahurga, some of the html5-y sound/graphics stuff is part of what I'm writing ffi code for
17:23:33 <cmccann> and feedback on that would be very helpful once I've got it in a semi-usable state
17:23:37 <Chahurga> Oooh very interesting, I'll be interested to see how it goes
17:23:49 <Chahurga> Yeah absolutely
17:24:31 <Peaker> how do I make a FunPtr for a ForeignPtr finalizer?
17:24:35 <yitz> lispy: i understand, and i appreciate both your help, and of course, this extremely valuable contribution by the developers.
17:24:41 <Peaker> I've got a simple C function I want to use as a finalizer
17:25:00 <cmccann> Chahurga, right now I'm still sorting out some headaches due to the js side of things having a lot of overloaded identifiers :T
17:25:12 <xenocons> hm, mmirmans caledon looks interesting
17:26:00 <Peaker> I found it in the docs. yuck :(
17:26:12 <Chahurga> I (unfortunately?) know pretty much everything there is to know about JS but I don't know if that knowledge will translate it any meaningful way
17:26:20 <Chahurga> *in
17:26:23 <yitz> lispy: and i fully understand how the realities of day-to-day commercial software work inevitably push off getting out polished releases of community releases.
17:26:44 * xenocons wonders what a 'finalizer' is
17:27:26 <pikhq> xenocons: Function that gets called before deallocation.
17:27:36 <cmccann> Chahurga, and I'm only moderately familiar with js so I have no idea what I might be missing by not knowing more!
17:27:51 <xenocons> pikhq: ah
17:28:45 <drstorm> hey can anybody suggest a good dark colorscheme for vim?
17:28:54 <Chahurga> cmccann: Yeah haha this is what I mean, I guess we should just plough ahead and pool our knowledge
17:29:01 <cmccann> sounds like a plan to me
17:31:03 * hackagebot alpha 1.0.7 - A compiler for the Alpha language  http://hackage.haskell.org/package/alpha-1.0.7 (MarcCoiffier)
17:32:17 <yitz> lispy: how would people feel if i make an amicable fork, with different name and logical but non-clashing version number, that simply makes it easier to install git HEAD versions that are anyway already popular in the wild?
17:32:42 <cmccann> Chahurga, anyway I'm doing some horrific stuff to programmatically cough up a wad of boilerplate for this, which is why I currently have nothing actually usable
17:32:57 <cmccann> but hopefully in an hour or two I'll have something that's not broken
17:33:01 <Peaker> I've got a C library that assumes it's given a malloc'd string because it free's it.  "newCString" is GC'd, right?
17:33:03 <lispy> yitz: you need to talk to Trevor Elliott, he wants to make a variant of cabal that works via github/bitbucket instead of hackage
17:33:14 <Peaker> what can I use to hand over that string?  Call strdup explicitly?
17:33:22 <lispy> yitz: I think leveraging vcs tags is a reasonable thing to do in this day and age
17:33:51 <Chahurga> cmccann: It's already 1:30am here, have a Java :( lecture at 9am but I'll be back tomorrow
17:33:53 <lispy> yitz: github already creates tarballs when you push tags
17:34:13 <cmccann> Chahurga, heh ok. I'll leave a message for you via lambdabot.
17:34:46 <Chahurga> look forward to it :) talk to ya tomorrow, I'm out
17:34:46 <wcarss_> Peaker: totally unfamiliar with your context, but that sounds like a plan
17:34:52 <lispy> yitz: I think that cabal-dev demonstrated that you can make a wrapper around cabal to demonstrate the value of an approach and if it takes the cabal developers will notice
17:35:02 <cmccann> Chahurga, seeya!
17:35:12 <lispy> yitz: seems like you're thinking of the same logic
17:35:27 <yitz> lispy: i've thoought about that too. but again, it's something else. hackage still serves a purpose. it's still better than trying to find git repos with google searches.
17:35:32 <lispy> Maybe as cabal-dev features go into cabal, cabal-dev can stick around as a playground for new features?
17:36:31 <lispy> (actually, we want to retire cabal-dev some day by having cabal natively support sandboxes and it sounds like that day is coming)
17:36:31 <yitz> lispy: maybe. but so far, cabal-dev features haven't gone into cabal yet. and i'm worried that due to "feature creep", it may be quite a while before they do.
17:36:40 <Peaker> wcarss_, sounds a bit awful :) I see that CString is just (Ptr Char), not ForeignPtr
17:36:45 <Peaker> so I wonder when "newCString" gets GC'd
17:36:55 <yitz> lispy: yes that would certainly be best
17:37:12 <clintm> lispy: I swear I saw code in cabal-install
17:37:18 <clintm> or rather in the head branch
17:37:24 <mapf> i
17:37:58 <yitz> lispy: the thing is, the people working on that now have a whole new concepual model for a haskell build system, inspired by cabal-dev but far beyond it.
17:38:29 <yitz> lispy: which is great, except in the meantime, we're not getting just basic cabal-dev sandboxing in cabal.
17:38:31 <mapf> i'm just thinking is it meaningful to define type functions which behaves like ordinary computable functions
17:39:10 <mapf> it's pretty like TH i guess
17:39:11 <yitz> lispy: so unfortunately right now it looks like we'll be needing cabal-dev for quite some time to come. likely years.
17:39:17 <mapf> but on language level
17:39:23 <mapf> and more restricted
17:40:51 <yitz> mapf: oleg showed years ago that you can already do that with just a few of the older type system extensions. except it's quite messy.
17:41:03 * hackagebot gloss 1.7.7.201204.1 - Painless 2D vector graphics, animations and simulations.  http://hackage.haskell.org/package/gloss-1.7.7.201204.1 (BenLippmeier)
17:41:05 * hackagebot gloss-raster 1.7.7.201204.1 - Parallel rendering of raster images.  http://hackage.haskell.org/package/gloss-raster-1.7.7.201204.1 (BenLippmeier)
17:41:07 * hackagebot gloss-examples 1.7.7.201204.1 - Examples using the gloss library  http://hackage.haskell.org/package/gloss-examples-1.7.7.201204.1 (BenLippmeier)
17:41:44 <yitz> mapf: more reminiscent of writing programs in the C++ template language, which has also been shown to be turing complete.
17:43:35 <mapf> yitz: exactly, quite messy. what if we introduce something like 'type functions' which almost just like then we transform type in TH like transf :: Type -> TypeQ
17:44:04 <mapf> so it's just like type families but with powerful matching and partial applications
17:44:50 <Ralith> mapf: just use a dependently typed lang already ^^
17:44:53 <Peaker> is Foreign.Marshall.Alloc.free usable like a C free, on ordinary malloc'd ptrs?
17:45:23 <mapf> Ralith: i'm think i too stupid for that
17:45:35 <mapf> i'm too stupid for haskell actually
17:48:29 <yitz> mapf: http://www.haskell.org/pipermail/haskell-cafe/2011-February/089184.html
17:49:00 <yitz> mapf: no TH needed
17:51:06 <mapf> :k [*]
17:51:07 <lambdabot> parse error on input `*'
17:51:14 <mapf> is it HList?
17:51:33 <mapf> :k [k] -- rather this
17:51:34 <lambdabot> Not in scope: type variable `k'
17:51:45 <rwbarton> HList is morally the product [*] -> *
17:54:19 <byorgey> I don't think lambdabot has -XDataKinds turned on
17:54:42 <rwbarton> [*] itself just classifies lists of types. you could take this list and form a product type or a sum type or whatever with it
17:56:04 * hackagebot GLFW-b-demo 0.1.1 - GLFW-b test\/example\/demo  http://hackage.haskell.org/package/GLFW-b-demo-0.1.1 (BrianLewis)
17:59:36 <yitz> Peaker: the documentation for F.M.Alloc doesn't make any promises about whether its functions happen to be implemented using the libc functions with similar names
18:00:08 <yitz> Peaker: you want to know whether the current version of GHC happens to do that? you would then rely on it?
18:01:52 <Peaker> yitz, I want to know how to handle a (char*) that is malloc'd from the C side and the C side expects me to free it
18:02:07 <Peaker> I'm now also wondering about struct return values
18:02:16 <yitz> Peaker: write a c function you can call via ffi
18:03:17 <Eduard_Munteanu> I guess that function exists... it's called free().
18:03:59 <Peaker> I could use a foreign import of "free", but for now I'll hope Marshall.Alloc.free works
18:04:28 <yitz> Peaker: ok good luck
18:04:41 * yitz puts his fingers in his ears and clenches his teeth
18:05:18 <rwbarton> the current code is really simple and does FFI out to malloc()/free()
18:05:21 <Peaker> heh, ok, ok I just added an import of "free" :)
18:05:39 <Peaker> does the FFI support c-struct-typed return values?
18:05:46 <yitz> Peaker: the problem is that if it's wrong, your program may just cause a gradual memory leak rather than blowing up.
18:06:04 * hackagebot gloss 1.7.8.1 - Painless 2D vector graphics, animations and simulations.  http://hackage.haskell.org/package/gloss-1.7.8.1 (BenLippmeier)
18:06:06 * hackagebot gloss-raster 1.7.8.1 - Parallel rendering of raster images.  http://hackage.haskell.org/package/gloss-raster-1.7.8.1 (BenLippmeier)
18:06:08 * hackagebot gloss-examples 1.7.8.1 - Examples using the gloss library  http://hackage.haskell.org/package/gloss-examples-1.7.8.1 (BenLippmeier)
18:07:08 <Eduard_Munteanu> Well, if M.A.free does its own allocation, then it could easily detect a double free or freeing something it hasn't alloced I suppose.
18:09:40 <jfischoff> what are some ways to represent probability distributions in Haskell? I found this approach interesting http://stackoverflow.com/a/5555071/230050 but it doesn't compile :p
18:09:52 <Eduard_Munteanu> Similarly you could try the Haskell malloc and see if free blows glibc on that pointer.
18:10:11 <AsciiFace> I must say, for a purely functional language, you sure made it seem friendly. ~~to whom it concerns
18:10:24 <yitz> jfischoff: look around on hackage, i think there are some package that do that.
18:11:18 <jfischoff> yitz: I have looked around, but I didn't' find anything that seemed to support continuous distributions
18:11:29 <Eduard_Munteanu> AsciiFace: welcome, we're a friendly lot as well. :)
18:12:38 <AsciiFace> Eduard_Munteanu: Good good, the only other programming crowd I really enjoyed was the devout python coders. Although they can be such sticklers for the pythonic way
18:13:56 <copumpkin> enjoying python is unhaskellic
18:14:01 * copumpkin ejects AsciiFace 
18:14:17 <Ralith> jfischoff: ooo, I've been looking for something like that.
18:14:37 <Ralith> jfischoff: the stuff on hackage isn't nearly so clean/general.
18:14:57 <AsciiFace> copumpkin: :D
18:14:59 <Ralith> I wonder if that admits generating taking samples of RVs...
18:15:20 <Ralith> jfischoff: surely you can correct whatever minor bugs it has.
18:16:04 <jfischoff> Ralith: Perhaps. I'm confused on how to get the "pushforward" part at the end to work
18:16:41 <Ralith> jfischoff: you'd have to rewrite most of the rest if you used that definition of Measure.
18:16:45 <Ralith> everything else assumes a=Double
18:16:58 <jfischoff> Ralith: yeah
18:17:10 <Ralith> but it should all still apply just fine.
18:17:28 <jfischoff> Ralith: I doesn't compile though, its not actually a good fmap
18:18:04 <Ralith> jfischoff: of course it doesn't compile; the given definition of apply is inconsistent with the given definition of Measure
18:18:57 <jfischoff> Ralith: also I don't understand the definition of Measure :p
18:21:32 <yitz> jfischoff, Ralith: look at mwc-random
18:22:33 <yitz> true it assumes Double, but still...
18:22:46 <Ralith> yitz: that seems to have almost nothing to do with this.
18:23:03 <jfischoff> yeah
18:23:10 <yitz> hmm?
18:23:16 <Ralith> we're not discussing a RNG.
18:23:30 <Ralith> these are tools for manipulating distributions
18:23:58 <Ralith> that lib is for computing pseudo-random numbers according to a few fixed distributions.
18:24:03 <yitz> it has normal, standard, exponential, gamma, and chiSquare. that's not the kind of thing you were looking for?
18:24:15 <Ralith> that's like asking for a lib for manipulating numbers
18:24:34 <Ralith> and being told "well, this lib has 5, 7, and 42, isn't that enough?"
18:25:14 <yitz> so you really are looking for some abstraction of general measure spaces?
18:25:28 <Ralith> did you click the link?
18:25:31 <jfischoff> maybe
18:25:48 <Ralith> we're looking for something like what's at the link.
18:26:28 <Ralith> I'm also interested in a lib that has all that *and* the capacity to generate samples, but simply generating samples for a few fixed distributions is a matter of fifteen minutes on wikipedia.
18:26:58 <jfischoff> Ralith: do you understand the "from_pdf" function?
18:27:11 <jfischoff> I'm not sure what he is saying there
18:27:32 <Ralith> jfischoff: numerical integration
18:27:50 <Ralith> I think
18:28:00 <jfischoff> I would expect to see bounds
18:28:01 <rwbarton> yeah
18:28:13 <jfischoff> what I am missing?
18:28:23 <rwbarton> well the integral is over the whole real line
18:28:27 <jfischoff> you know besides the whole concept :)
18:28:29 <rwbarton> if the distribution is unbounded
18:28:30 <jfischoff> ah
18:29:05 <jfischoff> so the Measure is always assumed to integrate across the whole thing?
18:29:23 <jfischoff> you can't specify a region using that representation…or can you?
18:29:35 <rwbarton> what does "specify a region" mean
18:30:17 <rwbarton> if you want a uniform [0,1] random variable, then the corresponding measure is mu f = {- integral of f from 0 to 1 -}
18:31:25 <rwbarton> but if you want, say, a standard Gaussian distribution, you have to integrate over the whole real line
18:32:19 <jfischoff> Right, guess to get the probability of just a part of the Gaussian you could convolve it with a function that is 1 in the region you care about and zero everywhere else… is that right?
18:34:11 <rwbarton> yeah
18:34:41 <rwbarton> but the measure wouldn't have any way to "know" that the function is 0 outside an interval
18:35:52 <pgiarrusso> jfischoff: I'm not convinced
18:36:10 <pgiarrusso> you propose to convolve the Gaussian with the function you describe?
18:36:27 <rwbarton> well not convolve
18:36:31 <rwbarton> just integrate the product
18:36:47 <jfischoff> Oh I don't know. I'm trying to figure out how useful this code is http://stackoverflow.com/a/5555071/230050
18:37:02 <pgiarrusso> rwbarton: agreed
18:37:23 <Ralith> it looks pretty useful, if it can find the mean and variance for arbitrary and arbitrarily manipulated distributions
18:37:50 <pgiarrusso> jfischoff: I see that it defines convolution, but I hope one can also define other operators
18:38:10 <jfischoff> pgiarrusso: me too :)
18:38:31 <pgiarrusso> Take maybe a look at http://en.wikipedia.org/wiki/Convolution#Definition
18:38:36 <jfischoff> I'm just interested in a flexible way to represent probability distributions in haskell
18:39:17 <pgiarrusso> I'm taking a look at that code
18:39:18 <pgiarrusso> and
18:39:26 <rwbarton> well I guess since Measure is a monad you can compute joint distributions (Measure a -> Measure b -> Measure (a, b))
18:39:45 <rwbarton> then you can pushforward with fmap by any function (a, b) -> c
18:39:59 <pgiarrusso> I think that the integration bounds are part of the measure in that code
18:40:08 <rwbarton> I think that's all that's going on here -- (mu ** nu) f = nu $ \y -> (mu $ \x -> f $ x + y)
18:40:14 <rwbarton> could be liftA2 (+) mu nu
18:40:24 <Ralith> oo
18:40:27 <Ralith> does look like that
18:40:39 <roconnor> I'd like to intergrate generalized functions, not just functions.
18:41:03 <rwbarton> well the Measure really is a measure
18:41:04 <jfischoff> pgiarrusso: right, so I was trying to figure out how to change the bounds
18:41:12 <rwbarton> so you can integrate it against an actual function
18:41:27 <rwbarton> delta x f = f x
18:43:09 <jfischoff> I don't understand how I could fix the functor instance code to actually compile :(
18:43:21 <rwbarton> deriving (Functor)
18:43:30 <jfischoff> :)
18:43:48 <rwbarton> well, you need to fix the newtype first :)
18:44:48 <roconnor> rwbarton: can you do the delta' ?
18:45:01 <rwbarton> well it's not a distribution
18:45:14 <roconnor> oh right
18:45:48 <rwbarton> or not a probability distribution rather
18:46:13 <rwbarton> but I guess if you can differentiate functions then you can differentiate distributions
18:51:51 <jozefg> What are the ways that you guys simulate dynamic programming in haskell? I tend to use memoization or folding but i feel like a better way should exist
18:52:29 <shachaf> I think it depends on the individual problem.
18:53:21 <mm_freak> what is this dynamic programming?
18:53:52 <pgiarrusso> rwbarton: I'm confused - how's Measure a monad?
18:53:56 <rwbarton> ST is an option, boxed immutable arrays are an option (more like memoization operationally though), sometimes just using lists is an option
18:54:32 <pgiarrusso>   -- (((a -> b) -> Double) -> Double) ->
18:54:33 <pgiarrusso>   -- ((a -> Double) -> Double) ->
18:54:34 <pgiarrusso>   -- (b -> Double) -> Double
18:54:42 <mm_freak> i mean according to wikipedia haskell is the dynamic programming language
18:54:57 <rwbarton> pgiarrusso: well as a type it is the same as Cont Double
18:55:04 <pgiarrusso> I was trying to implement an Applicative instance for Measure, and that's the (expanded) type signature
18:55:31 <pgiarrusso> newtype Measure a = M ((a -> Double) -> Double) deriving Functor
18:55:32 <rwbarton> @djinn (((a -> b) -> d) -> d) -> ((a -> d) -> d) -> (b -> d) -> d
18:55:32 <lambdabot> f a b c = b (\ d -> a (\ e -> c (e d)))
18:56:06 <Nereid> @djinn (((a -> d) -> d) -> d) -> ((a -> d) -> d)
18:56:06 <lambdabot> -- f cannot be realized.
18:56:18 <Nereid> (would be join for the monad)
18:56:26 <rwbarton> missing a -> d
18:56:28 <rwbarton> er
18:56:30 <rwbarton> missing a " -> d"
18:56:37 <Nereid> where
18:56:41 <pgiarrusso> @djinn (((a -> b) -> Double) -> Double) -> ((a -> Double) -> Double) -> (b -> Double) -> Double
18:56:41 <lambdabot> Error: Undefined type Double
18:56:52 <Nereid> oh yes.
18:56:54 <pgiarrusso> ?
18:56:58 <Nereid> @djinn ((((a -> d) -> d) -> d) -> d) -> ((a -> d) -> d)
18:56:58 <lambdabot> f a b = a (\ c -> c b)
18:57:12 <pgiarrusso> I'm using as definitionnewtype Measure a = M ((a -> Double) -> Double) deriving Functor
18:57:25 <pgiarrusso> *I'm using as definition: newtype Measure a = M ((a -> Double) -> Double) deriving Functor
18:59:16 <pgiarrusso> OK, I retract
18:59:24 <pgiarrusso> Need to understand better the continuation monad
19:00:00 <jozefg> mm_freak: dynamic programming is a technique for problems that are really slow recursively because of overlapping sub problems (eg fibonnacci numbers)
19:03:09 <mm_freak> jozefg: oh…  i usually use lazy vectors for that
19:04:35 <jozefg> mm_freak: Lazy vectors?
19:04:46 <nyc> Fibonacci numbers is not a good example of dynamic programming, but anyway.
19:04:52 <mm_freak> something like this: vec where vec = V.generate 100 f; f 0 = 0; f 1 = 1; f i = vec V.! (i - 2) + vec V.! (i - 1)
19:05:31 <jozefg> nyc: how do you figure?
19:05:34 <mm_freak> jozefg: something like this: vec where vec = V.generate 100 f; f 0 = 0; f 1 = 1; f i = vec V.! (i - 2) + vec V.! (i - 1)
19:06:56 <jmcarthur> dynamic programming is all just memoization in disguise anyway
19:07:07 <nyc> More typical are Bellman-Ford or Floyd-Warshall.
19:07:13 <jozefg> Ok so generate calls f with 0 - 100. Thats neat!
19:07:24 <mm_freak> 0-99 actually
19:07:25 <jmcarthur> it just so happens that sometimes you are lucky enough to have keys that allow you to use a very efficient data structure
19:07:46 <rwbarton> that's the same as the boxed array approach
19:07:56 <rwbarton> but using a trendier library
19:08:21 <mm_freak> you're not constrained to vectors…  you can use any lazy data type you want…  a data type behaves lazily, when it has nonstrict fields, which is the default
19:08:47 <mm_freak> including recursive/nested data types
19:08:54 <jozefg> Gah haskell's container libraries... Eventually i'll understand the differences between them.
19:09:05 <copumpkin> mm_freak: that won't work depending on which V you're using
19:09:16 <mm_freak> import qualified Data.Vector as V
19:09:21 <copumpkin> ok :)
19:09:44 <mm_freak> otherwise my premise "lazy vector" would not be fulfilled ;)
19:09:49 <ShareTextingCEO> http://www.ShareTexting.com Launching March 3rd 2013! OVER 700,000+ Users already signed up! Go sign up now. FREE for life!
19:11:21 <jozefg> I wrote the parser for my language in like 100 lines, parsec is fantastic
19:11:50 <jmcarthur> jozefg: you should check out trifecta if parsec impressed you! ;)
19:12:04 <jmcarthur> (although the documentation is... nonexistent)
19:16:37 <bitonic> tbh, parsec is still much quicker to define languages
19:16:42 <bitonic> through Text.Parsec.Language
19:17:59 <bitonic> also, <http://hackage.haskell.org/packages/archive/trifecta/0.53/doc/html/Text-Trifecta-Parser-Prim.html> :P
19:18:12 <jozefg> To be fair, I designed the languages grammar to be extremely easily parsed. The fun part comes with implementing the lazy semantics and what not
19:18:28 <jozefg> jmcarthur: Pshhh documentation
19:19:10 <bitonic> jozefg: edwardk modules usually need documentation, see the type above
19:19:25 <edwardk> trifecta is rather underdocumented
19:19:30 <bitonic> although trifecta is kinda accessible in the end
19:19:31 <edwardk> i plan to spend some time improving it soon
19:19:44 <edwardk> when in doubt with trifecta assume the combinator does the same thing as in parsec
19:22:17 <jozefg> Oh thats fun
19:29:27 <orzo> hi
19:29:38 <orzo> anybody around?
19:29:40 <jozefg> orzo: hi
19:30:18 <shachaf> Only about a thousand people.
19:30:34 <orzo> i have a big background in OO
19:30:43 <orzo> and now i've been haskelling for a while
19:30:59 <orzo> and i think i have a tendency to make my modules too vertical
19:31:07 <orzo> you know what i mean?
19:31:29 <orzo> a module does a certain job and it has all the low level and high level code to get it done
19:31:29 <jozefg> Um... no to be honest
19:31:45 <orzo> rather layered, low, medium, high, or what have you
19:32:30 <orzo> That's a general tendency of the different paradigms
19:33:01 <orzo> OO want's independent plugable components, but functional prefers layers
19:33:42 <NemesisD> hi all. is there a way to wait indefinitely in main? my program spawns a bunch of threads and will only stop on a sigint. i've tried having it wait on an MVar that never gets written but i get 'thread blocked indefinitely in an MVar operation'
19:34:31 <shachaf> You can always forever (threadDelay maxBound)
19:34:47 <shachaf> Or instead of waiting "indefinitely", you can wait for some specific thing.
19:35:23 <NemesisD> is that going to cause a problem when i install signal handlers?
19:35:43 <NemesisD> there's nothing to really to wait on other than signals
19:35:52 <orzo> i find that in trying to break things into more layers, naming is more difficult.  I seems wrong to just start tacking numbers on
19:36:40 <shachaf> There is also awaitSignal
19:36:55 <orzo> anybody got thoughts on a good convention for naming layers?
19:36:58 <crdueck> i have a simple benchmark comparing two versions of fibonacci generators, one using lists and the other using Data.Vector. The vector version works fine unless I import Data.Vector.Unboxed, which causes an infinite loop. Is this a bug, or is something amiss in my code?  http://sprunge.us/dORL
19:37:56 <shachaf> crdueck: Yes. :-)
19:38:05 <shachaf> Think about how the vector Fibonacci is evaluated.
19:38:49 <crdueck> is the unboxed version preventing it from being lazy?
19:39:15 <shachaf> Yes.
19:39:26 <shachaf> That is the point, sort of.
19:39:44 <crdueck> ah okay, makes sense.
19:40:49 <orzo> hm
19:41:25 <orzo> i would expect an boxed vector is still mandatory-finite
19:41:46 <orzo> is that wrong?
19:41:50 <shachaf> No.
19:42:02 <shachaf> We're talking about value-strictness, not spine-strictness.
19:42:03 <orzo> isn't his fibsV infinite?
19:42:09 <orzo> in spine
19:42:29 <shachaf> Doesn't look infinite.
19:43:08 <shachaf> Hmm, the Wikipedia article says "Unboxing is the unpacking of new products, especially high tech consumer products". I'm not sure what a "new" or "high tech consumer" product type is, but it sounds complicated.
19:43:34 <orzo> oh, i guess (n+1) argument is a vector length?
19:43:57 <shachaf> @google what does data.vector.generate do
19:43:58 <lambdabot> http://hackage.haskell.org/packages/archive/vector/0.5/doc/html/Data-Vector.html
19:43:58 <lambdabot> Title: Data.Vector
19:44:07 <dolio> The problem is that you can't build the unboxed array without evaluating all the elements, and the elements of the unboxed array reference the array.
19:44:31 <dolio> So you get a loop: vector evaluates element which evaluates vector which evaluates element....
19:45:00 <orzo> i see
19:45:49 <dolio> Boxed arrays can finish building the vector before evaluating the elements.
19:46:12 <dolio> Or, without evaluating the elements at all.
19:46:52 <orzo> if he used an intermediate list, would the compiler be smart enough to not regenerate the unboxed array on successive calls?
19:46:59 <orzo> heh
19:47:16 <orzo> no i guess not, because (n+1) changes
19:48:13 <shachaf> ?
19:48:23 <orzo> nevermind my question
19:52:44 <lispy> the push for strict-only data types that I'm seeing is a bit disconcerting
19:53:15 <lispy> People saying that they have 'strict' (pun?) policies at work that code must always use strict fields unless someone can find a compelling reason not to
19:53:27 <lispy> That seems odd
19:53:36 <lispy> Almost domain specific
19:53:56 <dolio> I can see making all your explicit primitives strict.
19:53:57 <lispy> I do enjoy the performance wins of strict fields, but I don't use them by default
19:54:31 <lispy> dolio: what is an explicit primitive?
19:54:43 <dolio> Int, Word, Double, Float, etc.
19:54:53 <dolio> Not a parameter.
19:55:19 <dolio> Those are all probably worth making strict and unpacking.
19:55:37 <lispy> ah, well I've done things like data Vec3 a = V3 !a !a !a, and it made sense at the time but I also assumed a would always be either Float or Double
19:55:52 <dolio> Well, that may make sense, too.
19:56:12 <dolio> But, I don't know about value-strict lists, for instance.
19:56:53 <lispy> import Data.List.Strict
19:57:07 <slack1256> lispy: are you refering to tha comment of tibell on g+ about strict data types?
19:57:12 <slack1256> *that
19:57:24 <lispy> slack1256: that thread of discussion, yes
19:58:18 <lispy> I come from the school of thought that says, "Write your down code and get it working. Worry about the details later."
19:58:27 <slack1256> lispy: that thread catched everybody's attention.
19:58:39 <lispy> So, I tend to think hyperstrictness as a policy is broken
19:58:50 <slack1256> well that correct. first get something working and then optimize
19:58:57 <slack1256> but think from where tibell is comming
19:59:12 <slack1256> he speaks mainly about performance on haskell
19:59:55 <lispy> I don't think tibbe said anything worrying (I'd have to check to be sure)
20:00:17 <lispy> It's the other people chiming in that non-strict fields are not used
20:00:55 <lispy> It reminds me of the quoting level hassle that lisp programmers have to deal with because they don't have laziness
20:01:22 * slack1256 goes to check that discussion.
20:06:48 <jozefg> lispy: been there done that, though macros help to reduce that pain in Lisp.
20:07:03 <roconnor> jozefg: I'm a little late to comment but I use (lazy) Arrays for dynamic programming.
20:07:43 <roconnor> jozefg: you can just initialize arrays using other values in the array, and so long as there is no circular dependency, laziness does all the work for you.
20:08:27 <jozefg> roconnor: yeah that seems to be the general trend, the other suggestion was a vector
20:08:38 <roconnor> ah, i didn't know vector was lazy
20:08:48 <roconnor> if they are, then they are probably better than arrays
20:09:50 <jozefg> whats the difference between the 2?
20:11:06 <rwbarton> array gives you index types other than Int and is part of the Haskell standard
20:11:40 <roconnor> jozefg: and vectors must start at index 0
20:11:50 <roconnor> Are vectors always 1 dimensional?
20:12:02 <roconnor> (other than nesting?)
20:12:03 <rwbarton> yes
20:12:46 <jozefg> so then vectors act a little like a subset of arrays, the sort that behave how we're used to from C languages
20:12:49 <roconnor> jozefg: but vector is supposed to be fast and parallelized I think
20:12:55 <roconnor> jozefg: yes
20:13:20 <roconnor> vectors are part of the data-parellel haskell right?
20:13:55 <rwbarton> dph has its own array type i think
20:14:15 <roconnor> oh
20:14:20 <roconnor> so what is the deal with vector?
20:14:22 <rwbarton> vector isn't parallel
20:14:31 <jfischoff> vectors offer stream fusion
20:14:32 <roconnor> :(
20:14:46 <roconnor> I'm disappointed
20:14:46 <jfischoff> repa gives you parallel
20:14:54 <jfischoff> which is based on vector
20:15:18 <roconnor> is repa part of dph?
20:15:32 <copumpkin> it's sort of an offshoot
20:15:41 * roconnor needs a map
20:15:45 <copumpkin> it takes off the irregular part of dph
20:15:47 <copumpkin> and gives you the rest
20:16:02 <copumpkin> roughly
20:16:11 <copumpkin> with a bit more hand-holding
20:25:10 <shachaf> "an open-source product of more than twenty years of cutting-edge research" -- I wonder what that means.
20:26:36 <Cale> shachaf: Where?
20:26:49 <shachaf> haskell.org
20:26:53 <shachaf> Just seems like a funny phrase.
20:27:13 <Cale> It seems accurate
20:27:23 <shachaf> Isn't all research cutting-edge when it happens?
20:27:41 <thetallguy> shachaf: not historical research
20:27:51 <thetallguy> shachaf: plus, it sounds cooler
20:28:09 <rohit> That phrasing is a geek magnet.
20:28:34 <Cale> I wonder whether that term would apply to research into making COBOL programs more reliable.
20:28:48 <thetallguy> eww
20:28:57 <djahandarie> Cutting-edge COBOL reliability research
20:29:10 <jozefg> all the cool kids are doing it.
20:29:12 <thetallguy> so...
20:29:33 <ihack> yeah
20:29:58 <ihack> i am done with my site
20:30:01 <ihack> :)
20:30:07 <ihack> i can sleep
20:30:38 <thetallguy> is there a type-level trick to ensure that a value is only set in a data structure once?
20:31:02 <shachaf> Set?
20:31:38 <thetallguy> shachaf: no, I've not stated it well
20:32:01 <thetallguy> a tuple  (Maybe a, Maybe b, ...)
20:32:28 <ClaudiusMaximus> @src Either
20:32:28 <lambdabot> Source not found. My pet ferret can type better than you!
20:32:38 <thetallguy> where you can replace a Nothing value, but not a Just value
20:32:50 <shachaf> I don't think I understand.
20:33:00 <thetallguy> shachaf: I'm not sure I do either
20:33:52 <thetallguy> Hmm...  Maybe I could do it with lenses
20:34:20 <ClaudiusMaximus> > mconcat [ (First Nothing, First Nothing), (First (Just 3), First Nothing), (First (Just 4), First (Just "hello")), (First (Just 7), First (Just "world")) ]
20:34:21 <lambdabot>   (First {getFirst = Just 3},First {getFirst = Just "hello"})
20:34:21 <thetallguy> I need a type level Maybe
20:34:58 <shachaf> Setting a value once, replacing a Nothing value, lenses, a type level maybe?
20:35:07 <shachaf> I'm not sure what's going on. :-(
20:35:11 <thetallguy> ClaudiusMaximus: right, but the (Just 4) should fail
20:35:24 <thetallguy> as should the (Just "world")
20:35:38 <ClaudiusMaximus> fail how?
20:35:45 <thetallguy> fail to type check
20:35:57 <shachaf> What are you actually doing?
20:36:02 <thetallguy> clearly what you have there does type check
20:36:34 <thetallguy> I wish to compose values with many components
20:36:54 <thetallguy> but prevent the overwriting of values
20:37:11 <shachaf> How is it composing?
20:37:11 <Noldorin> anyone here that know the untyped lambda calculus, perchance?
20:37:12 <thetallguy> we do it all the time at the value level, but I can't think of a type level trick
20:37:27 <ClaudiusMaximus> hm, i can't see a way to do it without enumerating all the possible combinations
20:37:34 <shachaf> Noldorin: It's quite possible, though not really on-topic. But if you have a question you shouldn't ask whether to ask.
20:37:57 <thetallguy> shachaf: I said compose, I meant apply a binary operator
20:37:59 <rwbarton> some kind of extensible records presumably
20:38:14 <Noldorin> shachaf: that' why i'm asking. i don't want to pollute this channel with anything irrelevant, but i am curious if such people on IRC exist so that i could at least take it elsewhere. :)
20:38:27 <thetallguy> rwbarton: Yes, that's what I was thinking
20:38:43 <ClaudiusMaximus> data FooNNN a b c = FooNNN ; data FooJNN a b c = FooJNN a ; data FooJJN a b c = FooJJN a b ; ...
20:38:44 <shachaf> Noldorin: Just ask your question! The only thing people like less than off-topic questions is questions about questions.
20:38:56 <thetallguy> if I had lenses for setting fields that only worked on type Empty, that would do it
20:38:57 <Noldorin> shachaf: hah ok, sure
20:39:13 <Noldorin> Given a linear term s in Lambda-Beta, and s ->_B t (that is, s one-step beta-reduces to t), show that t is linear.
20:39:17 <Noldorin> any ideas?
20:39:25 <thetallguy> let x :: (Empty, Empty) = (Empty, Empty)
20:39:31 <brandonw> i'm confused by the ghc error given on compiling this function: https://github.com/brandonw/99-haskell-problems/blob/master/Question21-30.hs#L24
20:40:17 <thetallguy> then I could use a Setter to go to (a, Empty), then (a,b)
20:40:24 <shachaf> brandonw: I don't see an error. :-)
20:40:33 <shachaf> brandonw: But, hint: Your life will be easier if you write a type first.
20:40:34 <brandonw> i can't figure it why it's expecting [StdGen] instead of IO StdGen from
20:40:43 <brandonw> hmm
20:40:57 <brandonw> that would make sense, because i'm referring tot he solutions and they all give me the same error
20:41:11 <thetallguy> ClaudiusMaximus: yeah, that would be ugly
20:42:32 <brandonw> shachaf: where should I write a type first? do you mean in the first line of the do block, use something like :: IO StdGen ?
20:42:46 <Clint> he means for the rndSelect function
20:42:50 <shachaf> No, I mean the type of your function.
20:42:57 <brandonw> oh!
20:43:08 <shachaf> Do you know what its type is?
20:43:10 <brandonw> whoops, i wrote it then deleted it accidentally. that would help..
20:43:18 <brandonw> yes, that was my unintentional mistake :)
20:43:40 <shachaf> Once you write its type, you can see why it doesn't match.
20:43:44 <burrows> This line seeems odd  | i <= 0    = error "index must be zero or greater"
20:44:12 <newsham> type checker doesnt parse english
20:44:48 <ClaudiusMaximus> thetallguy: if i wanted a hack quickly, that's probably what i'd do though (perhaps with TemplateHaskell MultiParamTypeClasses and FunctionalDependencies) - if i wanted something elegant i'd follow rwbarton's suggestion and research extensible records stuff
20:44:54 <brandonw> whoops, thanks burrows
20:45:08 <burrows> Yes sir.
20:45:10 <brandonw> also wrong :)
20:45:30 <thetallguy> ClaudiusMaximus: I'm looking at a lens solution.
20:49:09 <brandonw> hmm i still can't get my code to type check. i updated my github with a type for the function. shachaf, it compiled for you?
20:49:46 <brandonw> whoops, i just realized my type is still wrong.
20:49:52 <shachaf> No, I never tried it.
20:50:07 <Clint> your type is definitely still wrong
20:50:20 <shachaf> I see a few issues, which GHC should point out once you figure out the types of everything involved.
20:50:23 <brandonw> oh okay, i understand what my problem i snow
20:50:26 <brandonw> [] is not IO []
20:50:29 <shachaf> I can't comment on your GHC errors because I don't know what they are. :-)
20:51:26 <brandonw> there we go, thanks :)
20:55:59 <tomberek> is there a way to add LLVM support without rebuilding GHC?
20:57:16 <shachaf> Why would you build GHC in the first place? I think the binaries have LLVM support.
20:57:27 <rwbarton> yes, they do
20:58:24 <rwbarton> ghc uses the llvm binaries, so you just need to install those somewhere that ghc will find them
20:58:37 <rwbarton> then build with -fllvm
21:07:20 <tomberek> shachaf, rwbarton - on windows, it seems that it does not
21:07:49 <shachaf> How do you tell?
21:08:00 <tomberek> ghc --info
21:08:05 <shachaf> What does it say?
21:09:27 <tomberek> llc and opt command are empty, and adding -fllvm creates an error that says "Couldn't figure our LLVM version" even though llc and opt are in my path
21:15:26 <tomberek> shachaf - is there something else i would need to do to 'register' llvm?
21:15:49 <shachaf> I don't know much about figuring things like that out on Windows.
21:15:55 <tomberek> ah
21:17:06 <kamatsu> I'm looking to do some GLR parsing in Haskell
21:17:56 <kamatsu> in particular, I'd prefer a GLR parser that I can use dynamically, not a parser generator.
21:18:21 <kamatsu> has anyone done this already? Or shall I have to roll my own?
21:20:04 <shachaf> Cale: Could we get rid of NumInstances in lambdabot?
21:20:08 <shachaf> It makes people confused.
21:20:42 <Nereid> same for (.) = fmap
21:20:53 <shachaf> One step at a time, Nereid.
21:20:56 <Nereid> :p
21:20:59 <Nereid> sure, numinstances first
21:21:09 <Cale> I guess so
21:21:11 <shachaf> NumInstances has very little actual benefit.
21:21:23 <Nereid> neither does (.) = fmap
21:21:33 <shachaf> I think (.) = (Prelude..) or (.) = (Control.Category..) is good too.
21:21:37 <shachaf> But I think Cale cares more about that.
21:21:42 <Nereid> :v
21:22:25 <Cale> @undefine
21:22:35 <Nereid> > 1 2
21:22:36 <lambdabot>   Could not deduce (GHC.Num.Num (a0 -> t))
21:22:36 <lambdabot>    arising from the ambiguity chec...
21:22:51 <shachaf> Hooray! Cale++
21:23:18 <hrumph> yo
21:23:23 <Nereid> sup
21:23:23 <shachaf> @ty (.)
21:23:25 <lambdabot> Functor f => (a -> b) -> f a -> f b
21:23:28 <shachaf> Ah well.
21:23:39 <hrumph> whahow many lines can i post here without vialoating the no paste rule?
21:23:51 <shachaf> 1
21:23:53 <hrumph> i've started my haskell learning by trying to understand monads
21:24:10 <shachaf> hrumph: OK, that's not a good plan. Did you see the FAQ on this?
21:24:11 <shachaf> @where faq
21:24:12 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
21:24:21 <hrumph> no i haven't seen the faq
21:24:38 <shachaf> "trying to understand monads" is overrated. The idea itself is simple but it involves a bunch of other parts of Haskell that you should learn about first.
21:25:00 <hpaste> Hrumph pasted “what does underscore mean” at http://hpaste.org/79034
21:25:17 <Nereid> _ matches anything, just like a variable
21:25:23 <Nereid> it just doesn't bind a name to what it matches
21:25:23 <hrumph> ok i've pasted a code snippet from wikipedia
21:25:42 <hrumph> it has an underscore and i don't know what the underscore is all about
21:25:56 <shachaf> hrumph: You should really not be thinking about "monads" right now -- there's a lot of much more important Haskell things you should learn.
21:25:56 <Nereid> so the code would mean the same thing if you put a fresh variable in place of _
21:26:00 <shachaf> Anyway, what Nereid said.
21:26:06 <hrumph> i see so i could use f or g if i wanted too
21:26:09 <shachaf> What introduction to Haskell are you reading? Most of them cover this.
21:26:20 <hrumph> i don't have an intro to haskell
21:26:23 <hrumph> this is my intro
21:26:26 <Nereid> :(
21:26:29 <Nereid> @where lyah
21:26:29 <lambdabot> http://www.learnyouahaskell.com/
21:26:31 <shachaf> Not recommended.
21:27:01 <hrumph> i'm doing pretty well for someone with limited background in this kind of thing
21:27:15 <Nereid> how do you know?
21:28:11 <hrumph> if only knew about C or Java, and didn't know about currying and stuff i would be very lost
21:28:27 <hrumph> as it is i'm sort of treading water
21:28:37 <Nereid> sounds like you need some focus in your haskell learning
21:30:00 <hrumph> i'm excited about haskell
21:30:31 <Nereid> haskell is pretty exciting. :)
21:34:51 <shachaf> Cale: So how 'bout letting (.)s be (.)s?
21:35:04 <shachaf> I don't think anyone derives any benefit from it being nonstandard in lambdabot.
21:41:09 * hackagebot shelly 0.15.0 - shell-like (systems) programming in Haskell  http://hackage.haskell.org/package/shelly-0.15.0 (GregWeber)
21:55:51 <tomberek> .
21:56:03 <shachaf> Cale: Could we get @check fixed too?
21:57:09 <pnielsen> is there an easy way to tell what's actually being fused using Data.Text, or should I just assume that fusable operations usually are?
21:57:40 <shachaf> There's always "looking at the Core"
21:57:49 <shachaf> You can ask GHC to tell you which rules have fired.
21:58:34 <pnielsen> how?
21:59:01 <pnielsen> I guess I was thinking something like a checker that would tell me when several calls aren't being fused
21:59:11 <pnielsen> or vice versa
21:59:19 <shachaf> Using an option. :-)
21:59:26 <pnielsen> but I suppose I should just build, and profile later
21:59:43 <shachaf> I think that's kind of ill-defined.
22:00:25 <pnielsen> what's the option?
22:01:09 * hackagebot jmacro 0.6.2 - QuasiQuotation library for programmatic generation of Javascript code.  http://hackage.haskell.org/package/jmacro-0.6.2 (GershomBazerman)
22:01:11 * hackagebot jmacro-rpc 0.2 - JSON-RPC clients and servers using JMacro, and evented client-server FRP.  http://hackage.haskell.org/package/jmacro-rpc-0.2 (GershomBazerman)
22:01:13 <shachaf> $ man ghc | grep rul.*fir -ddump-rn    -ddump-rule-firings    -ddump-rule-rewrites   -ddump-rules
22:01:26 <shachaf> One of those.
22:01:29 <shachaf> There are a few others.
22:01:55 <pnielsen> ok thanks
22:06:09 * hackagebot jmacro-rpc-happstack 0.2 - Happstack backend for jmacro-rpc  http://hackage.haskell.org/package/jmacro-rpc-happstack-0.2 (GershomBazerman)
22:11:09 * hackagebot jmacro-rpc-snap 0.2 - Snap backend for jmacro-rpc  http://hackage.haskell.org/package/jmacro-rpc-snap-0.2 (GershomBazerman)
22:26:14 <slack1256> Is it normal to have a hard time graspìng a new project?
22:26:28 <slack1256> I usually don't understand how to connect all the things
22:26:51 <Nereid> all of the things!
22:27:01 <slack1256> I grasp code snippets and individual functions, but when seeing the whole (specially a new project) i get lost
22:27:22 <slack1256> Nereid: sorry, not native speaker ;-)
22:27:30 <Nereid> no, it was fine
22:27:34 <Nereid> I'm just being silly.
22:27:44 <slack1256> it's ok it 4AM after all
22:28:35 <slack1256> Nereid: but how do you approach a new project?
22:28:47 <Nereid> I wouldn't be a good person to ask about that :s
22:28:58 <slack1256> do you scratch an itch (see a bug fix) o do you read the whole project?
22:29:08 <slack1256> Nereid: have some confidence!
22:29:26 <Nereid> I'm in the same boat as you.
22:30:01 <slack1256> mmm
22:37:53 <statusfailed> possibly dumb question: is there an identity lens? it's not justid is it?
22:38:01 <edwardk> id
22:38:15 <edwardk> > over id (+1) 5
22:38:17 <lambdabot>   6
22:40:01 <latro`a> :t over
22:40:02 <lambdabot> Setting s t a b -> (a -> b) -> s -> t
22:41:58 <statusfailed> edwardk: oh, thanks :D
22:42:32 <edwardk> :t over.id
22:42:33 <lambdabot> Setting s t a b -> (a -> b) -> s -> t
22:42:45 <edwardk> :t over id
22:42:47 <lambdabot> (s -> t) -> s -> t
22:42:57 <edwardk> :t over both
22:42:58 <lambdabot> (a -> b) -> (a, a) -> (b, b)
22:43:11 <edwardk> :t over (both.both)
22:43:12 <lambdabot> (a -> b) -> ((a, a), (a, a)) -> ((b, b), (b, b))
22:43:12 <latro`a> :t both
22:43:13 <lambdabot> Applicative f => (a -> f b) -> (a, a) -> f (b, b)
22:43:23 <latro`a> huh, that's a neat trick
22:43:29 <edwardk> :t (1,2) & both .~ 3
22:43:30 <lambdabot> Num b => (b, b)
22:43:35 <edwardk> :t (1,2) & both +~ 3
22:43:36 <lambdabot> Num t => (t, t)
22:43:38 <edwardk> > (1,2) & both +~ 3
22:43:40 <lambdabot>   (4,5)
22:43:46 <edwardk> > (1,2) & both *~ 10
22:43:48 <lambdabot>   (10,20)
22:44:04 <edwardk> > (1,2)^._2
22:44:06 <lambdabot>   2
22:51:10 * hackagebot aeson-lens 0.4.1.1 - Lens of Aeson  http://hackage.haskell.org/package/aeson-lens-0.4.1.1 (HideyukiTanaka)
22:52:42 <Nereid> > 3 ^. id
22:52:44 <lambdabot>   3
22:52:49 <Nereid> :t id .~ ?x
22:52:50 <lambdabot> (?x::t) => s -> t
22:54:05 <statusfailed> yay, new aeson-lens
22:55:17 <edwardk> :t (.~)
22:55:18 <lambdabot> Setting s t a b -> b -> s -> t
22:55:46 <edwardk> under the hood: (.~) :: ((a -> Identity b) -> s -> Identity t) -> (a -> b) -> s -> t
22:56:03 <edwardk> (it uses an Identity-like type for better error messages instead, but thats close enough)
22:56:07 <Nereid> that's over
22:56:11 <edwardk> er sorry
22:56:17 <edwardk> under the hood: (.~) :: ((a -> Identity b) -> s -> Identity t) -> b -> s -> t
22:56:36 <edwardk> l .~ b is over l (const b)
22:57:09 <edwardk> so there all we're doing is picking id :: (a -> Identity b) -> (a -> Identity b)
22:57:19 <edwardk> so a and b can vary independently when you assign to it
22:57:29 <edwardk> :t (id .~)
22:57:30 <lambdabot> t -> s -> t
22:57:35 <edwardk> thats just const
22:58:37 <edwardk> l .~ b = runIdentity . l (Identity . const b); id .~ b = runIdentity . id (Identity . const b) = runIdentity . Identity . const b = const b
23:24:11 <nlogax> Would it make sense for cabal packages to use semantic versioning? So you'd only specify one version per dependency, and it could know (in a perfect world) that newer versions on the same major version are compatible
23:25:29 <slack1256> nlogax: isn't that what minor update (0.4.x) are supposed to mean?
23:25:52 <slack1256> also there is the scoutess project that hopefully will provide dependency testing for cabal packages
23:26:34 <statusfailed> Hmmm.... is it possible to do a where clause for a whole function instead of just a single pattern match? (hope that makes sense...)
23:27:01 <Iceland_jack> I would also be interested in that ↑
23:27:25 <slack1256> statusfailed: could you elaborate?
23:27:33 <slack1256> I didn't get it
23:27:50 <Iceland_jack> slack1256: when you have multiple pattern matches and add a “where” clause, it's only scoped for a single match
23:28:09 <slack1256> ohhh
23:28:17 <slack1256> OK I get what you mean
23:28:52 <slack1256> well you can if you transform you pattern match to a 'case' statement
23:28:54 <nlogax> slack1256: I would assume so, but can't tell what versioning a package uses. If that is already standard more or less, perhaps cabal could adopt it "officially" and be smarter about it :)
23:29:00 <statusfailed> slack1256: bleargh :D
23:29:10 <statusfailed> actually that's not thatbad
23:29:11 <Iceland_jack> I'd personally *way* prefer being able to dump all the where clauses at the end instead of having to interleave them between the pattern matches
23:29:23 <nlogax> Maybe with a flag in the .cabal file?
23:29:30 <shachaf> Iceland_jack: How would that work?
23:29:40 <shachaf> where clauses can use variables bound on the left side of the =
23:29:59 <statusfailed> ah, that would be a problem then...
23:30:01 <statusfailed> forgot about that
23:30:10 <Iceland_jack> well they still could
23:30:31 <Iceland_jack> if they use a variable it would be the one whose pattern match succeeded
23:30:51 <shachaf> f _ x [] = ...; f x _ (a:as) = ... where ...
23:30:59 <slack1256> statusfailed: case statements are not that bad :p
23:33:49 <statusfailed> slack1256: I just feel bad about them for some reason :P
23:34:06 <Iceland_jack> Using too many case expressions brings me back to ML
23:34:20 <tertl3> if you compile haskell to C, does that make the C code typesafe?
23:34:49 <Rotaerk> C code ... typesafe? lol
23:34:59 <Iceland_jack> It depends on what you mean by typesafe..
23:35:26 <pdxleif> Well, it's been typechecked, so, sure?
23:35:29 <tertl3> well i mean the side effects and all that haskell goes to all the trouble to get right
23:35:30 <flux> isn't all C code that doesn't invoke undefined behaavior typesafe?
23:35:36 <Rotaerk> it is the compiler that does type-checking; the code it generates, if modified, provides as much type-safety as the language it's in
23:35:47 <flux> the trick in C is how to write such code..
23:35:52 <Iceland_jack> tertl3: Accessing an array out of bounds is “type safe”
23:36:13 <Rotaerk> if you had haskell->C# compiler, you'd have some type safety... but limited to C# types...
23:36:29 <slack1256> statusfailed: oh forget about what I said case statement, in you problem (to bind variables of matches) doesn't help ;-)
23:36:32 <flux> iceland_jack, but is it really? you might not get a value out of it, but rather an abrupt termination
23:36:40 <tertl3> ok i think get it
23:36:44 <Iceland_jack> It's undefined behaviour
23:36:55 <Iceland_jack> the types don't enter into it
23:36:56 <pdxleif> I don't think the type system of the target language is a concern.
23:37:13 <Nereid> why not talk about haskell -> javascript compilation?
23:37:14 <Iceland_jack> Something being “type safe” in C isn't an issue like it is in say Haskell
23:37:27 <tertl3> but C would introduce more side effects right?
23:37:36 <Nereid> introduce?
23:37:48 <tertl3> when the haskell gets compiled to C
23:37:59 <pdxleif> The default complilation target is untyped.
23:38:11 <merijn> tertl3: Haskell doesn't get compiled to C
23:38:20 <Iceland_jack> tertl3: I'm not sure what you mean by more side-effects
23:38:31 <Nereid> at the end of the day, haskell gets compiled to machine code.
23:38:36 <slack1256> maybe you are confusing compiling to C and use the gcc backend?
23:38:52 <tertl3> popssibly
23:38:55 <slack1256> Nereid: don't tell that outloud or spj could smack you
23:38:55 <Iceland_jack> is printf("hi"); ‘more’ side-effects than putchar('h'); putchar('i');?
23:38:57 <tertl3> possibly*
23:39:53 <tertl3> i was just wondering whats the point of a scheme to C compiler ?
23:40:19 <tertl3> i or haskel to C
23:40:19 <Nereid> tertl3: because people have already done the work of making C code run on various target machines
23:40:24 <Nereid> why duplicate the work?
23:41:05 <startling> attoparsec doesn't have a monad transformer, correct?
23:41:28 <slack1256> startling: afaik no.
23:41:48 <startling> slack1256, so it does?
23:42:12 <slack1256> oh. no it doesn't have a monad transformer
23:42:17 <startling> haha, k
23:42:30 <slack1256> startling: don't try to play with my mind again please,
23:43:19 <startling> slack1256, my fault, I shouldn't have asked like that.
23:43:46 <slack1256> startling: I'm joking man, relax ;-)
23:45:06 <Iceland_jack> How quaint
23:57:15 <SingingBoyo> haskell and c/c++ have very different ideas of how to do openGL.  it's starting to get annoying
23:58:18 <sopvop> use opengl-raw for c-like interface
