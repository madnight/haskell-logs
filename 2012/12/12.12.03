00:02:12 <sopvop> So, If I have function :: (Bazed a ) => a -> ..., I can't reference this 'a' in where clause. like baz = bazOf (undefined :: a)
00:02:32 <sopvop> will get a1 or a2 or whatether
00:02:53 <startling> sopvop, do baz :: Bazed a => a
00:03:35 <Nereid> or use ScopedTypeVariables
00:03:47 <liyang> Just a thought: regarding type ReadS a = String -> [(a, String)] … does anyone actually write or use parsers for ambiguous grammars? I mean, in the Real World here…
00:03:54 <sopvop> Actualy I have function :: Bazed a => ( b -> a) -> ..., and so I don't have value of 'a' really
00:04:15 <Nereid> or asTypeOf or ...
00:05:23 <astropirate> Is anyone using Haskell for real-time financial applications? I know janestreet is the posterboy for Ocaml.. wondering if there is anyone like that using Haskell
00:05:29 <osa1> I'm getting this error when I run c2hs: "c2hs: does not exist" . any ideas _what_ does not exist ?
00:05:41 <sopvop> asTypeOf requires type, I have a function :(
00:05:45 <liyang> astropirate: yes, we do.
00:06:11 <astropirate> liyang, are you at liberty to say company name? and how its worked out for you?
00:06:26 <ion> @type \b -> fix (\a -> ?foo `asTypeOf` a)
00:06:29 <lambdabot> (?foo::a) => t -> a
00:06:47 <sopvop> whoa
00:06:58 <sopvop> what is '?' ?
00:07:51 <ion> Abusing ImplicitParams to emulate holes.
00:12:04 <liyang> astropirate: http://www.tsurucapital.com/en/ — working out pretty well for us. We're a small team and need to be agile enough to push the envelope on our deliverables on a as-need basis. Haskell is a strategit fit for optimising our bottom line.
00:14:08 <astropirate> liyang, very cool! Thank you
00:14:24 <xenocons> hm, have this piece of C code ive been meaning to translate into a FP language, i think its going to be a pain in the butt
00:16:07 <ion> That was a great piece of corporatespeak.
00:18:13 <beaky> hello
00:18:20 <beaky> is it possible to define unary operators?
00:18:47 <liyang> Technically no.
00:18:49 <edwardk> beaky: not really.
00:19:04 <beaky> :(
00:19:10 <edwardk> beaky: ghc has a little hack in it that lets you define postfix operators as long as you surround them in parens, but that hardly counts
00:19:28 <liyang> Nothing like Agda's mixfix operators.
00:19:29 <beaky> I wanna define my ++ operator to increment an IORef :D
00:19:50 <liyang> There's a lens for that.
00:19:58 <beaky> oh
00:20:02 <beaky> what's a lens?
00:20:22 <xenocons> :t (!)
00:20:23 <lambdabot> Ix i => Array i e -> i -> e
00:20:29 <xenocons> :t (!!)
00:20:31 <lambdabot> [a] -> Int -> a
00:20:35 <xenocons> hm i see
00:22:09 <zhulikas> hehe
00:24:04 <sopvop> Yay! schm :: Schemed a => (b -> a ) -> Schema a ; schm _ = schemaOf undefined
00:25:16 <liyang> beaky: um… I'm not sure if will help you or not, but http://hackage.haskell.org/package/lens
00:25:50 <dsantiago> shachaf: Just re-read your thing and it made sense this time. I think one thing I didn't grasp the first time that really hurt me was that all the examples you presented were about creating data structures that were then interpreted in different ways to get the IO.
00:25:52 <Chousuke> I need to learn more about lenses. they seem neat.
00:26:17 <liyang> s
00:26:36 <dsantiago> Now that I get it, so obviously a great comment.
00:26:43 <edwardk> the examples on https://github.com/ekmett/lens#examples are probably a better starting point
00:26:59 <shachaf> dsantiago: It's a pretty important idea in Haskell in general.
00:27:09 <shachaf> The way IO works just happens to be one application of it.
00:27:20 <dsantiago> I think a real problem is people who half understand this stuff writing about it. It adds a lot of noise.
00:27:56 <liyang> Cf. the monad tutorial problem.
00:28:14 <ion> And the emerging lens tutorial problem
00:28:27 <edwardk> i look forward to our new lens tutorial problem ;)
00:28:44 <Chousuke> lenses remind me of common lisp places. except even more powerful :P
00:28:54 <edwardk> i've been trying to keep up by writing more examples (i think we're at 450+ doctests in lens itself) but its hard
00:28:57 <elliott> dsantiago: unfortunately nowhere is immune to that problem :)
00:28:59 <elliott> #haskell included
00:29:48 <xenocons> ill get to lens later ;)
00:29:53 <statusfailed> Does anybody know of anyone hiring Haskelleers?
00:29:56 <edwardk> i'm hoping to get better lens test coverage in for 3.7. at the rate we're going that'll probably be ~600-650 tests
00:30:09 <edwardk> statusfailed: there are lots of places
00:30:16 <shachaf> I think a good up-to-date high-level overview of lens would be good.
00:30:28 <shachaf> The wiki is nice but somewhat limited, and there isn't much else.
00:30:36 <statusfailed> edwardk: I don't suppose you know if skedge is still looking?
00:30:42 <statusfailed> I will email them actually
00:30:51 <Chousuke> dsantiago: it seems to me that people who fully understand things tend to explain them in such a way that it doesn't help people who don't understand the concepts.
00:30:55 <edwardk> ryan is probably still looking, yes
00:31:03 * liyang still isn't familiar with actually using traversals.
00:31:20 <shachaf> liyang: It's just like mapM
00:31:24 <shachaf> You're familiar with mapM, right?
00:31:26 <edwardk> shachaf: yeah. we don't really have anything covering projections or traversals at all
00:31:26 <dsantiago> Yeah, I think that's probably true as well.
00:31:35 <edwardk> or isomorphisms for that matter
00:31:36 <liyang> I'm totally familiar with traverse/for.
00:31:44 <edwardk> and there isn't anything written on the indexed combinators
00:31:46 <statusfailed> Do you know of anyone in singapore? I saw an ad for standard chartered but they seem to want 3+ years haskell in industry...
00:31:54 <shachaf> OK, a traversal is just like that except over some arbitrary structure.
00:32:02 <edwardk> liyang: congratulations. a traversal is just like traversable, but you can compose them
00:32:04 <edwardk> :t traverse
00:32:05 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
00:32:08 <edwardk> :t traverse.traverse
00:32:09 <lambdabot> (Applicative f, Traversable t1, Traversable t) => (a -> f b) -> t (t1 a) -> f (t (t1 b))
00:32:13 <edwardk> :t traverse.traverse.traverse
00:32:15 <lambdabot> (Applicative f, Traversable t2, Traversable t1, Traversable t) => (a -> f b) -> t (t1 (t2 a)) -> f (t (t1 (t2 b)))
00:32:18 <edwardk> notice how each time it goes deeper?
00:32:44 <shachaf> both (\x -> putStrLn ("what's your " ++ s ++ "?") >> getLine) ("name","address")
00:32:44 <Nereid> ~inception~
00:32:44 <edwardk> this is like a generalization of the usual 'fmap' 'fmap.fmap' 'fmap.fmap.fmap' idiom
00:32:52 <liyang> I've written traverse . traverse before…
00:32:54 <Nereid> :t traverse.traverse.traverse.traverse
00:32:56 <lambdabot> (Applicative f, Traversable t3, Traversable t2, Traversable t1, Traversable t) => (a -> f b) -> t (t1 (t2 (t3 a))) -> f (t (t1 (t2 (t3 b))))
00:33:10 <edwardk> liyang: A 'traversal' is just the generalization of this pattern.
00:33:16 <edwardk> :t both
00:33:17 <lambdabot> Applicative f => (a -> f b) -> (a, a) -> f (b, b)
00:33:26 <edwardk> that is a 'traversal' of both sides of a pair
00:33:46 * liyang .oO( *light bulb turns on* )
00:33:48 <Nereid> it is what traverse would be if "Traversable (\a -> (a,a))" made sense
00:33:51 <liyang> Oh.
00:33:58 <edwardk> you'd get it if you wrote both f = (,) <$> f a <*> f b
00:33:59 * shachaf found edwardk's (traverse.traverse.traverse) explanation confusing until figuring it out through other means.
00:33:59 * elliott thinks sample definitions are the easiest way to see it
00:34:15 <shachaf> both f (a,b) = ...
00:34:16 <elliott> _fst f (a,b) = (,b) <$> f a; _snd f (a,b) = (a,) <$> f b
00:34:21 <edwardk> which would be a perfectly cromulent definition for 'traverse' for some type with two parameters
00:34:23 <elliott> both f (a,b) = (,) <$> f a <*> f b
00:34:28 <edwardk> yes, add shachaf's correction =)
00:34:34 <Hafydd> :t foldl (.) (take 10 (repeat traverse))
00:34:36 <lambdabot>     Couldn't match expected type `a0 -> b0' with actual type `[a1]'
00:34:36 <lambdabot>     In the return type of a call of `take'
00:34:36 <lambdabot>     Probable cause: `take' is applied to too many arguments
00:34:57 <edwardk> liyang: the trick is that you can just keep composing them this way and its just (.) from the prelude
00:35:10 <liyang> edwardk: technically I did, didn't I… I just made the types match up. :-/
00:35:22 <edwardk> :t traverse.both
00:35:23 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t (a, a) -> f (t (b, b))
00:35:44 <edwardk> > [(1,2),(3,4)] & traverse.both +~ 2
00:35:48 <lambdabot>   [(3,4),(5,6)]
00:36:03 <edwardk> its just like a lens with multiple targets
00:36:04 <liyang> Proof that you can even write lenses without actually understanding them.
00:36:18 <edwardk> liyang: that has been a HUGE goal of the library all along
00:36:21 <ion> > getConst $ traverse (\a -> Const [a]) ["foobar", "baz"]
00:36:22 <lambdabot>   ["foobar","baz"]
00:36:25 <Hafydd> :t foldl1 (.) (take 10 (repeat traverse))
00:36:26 <lambdabot>     Occurs check: cannot construct the infinite type: b0 = t0 b0
00:36:26 <lambdabot>     Expected type: (a0 -> f0 b0) -> a0 -> f0 b0
00:36:26 <lambdabot>       Actual type: (a0 -> f0 b0) -> t0 a0 -> f0 (t0 b0)
00:36:28 <ion> > getConst $ both (\a -> Const [a]) ("foobar", "baz")
00:36:30 <lambdabot>   ["foobar","baz"]
00:36:33 <shachaf> liyang: The reason (traverse.both) foo works is that it just turns into traverse (both foo)
00:36:38 <shachaf> Well, I guess that's obvious by now. :-)
00:36:49 <Nereid> > toListOf both ("foobar","baz")
00:36:51 <lambdabot>   ["foobar","baz"]
00:36:59 <ion> > runIdentity $ traverse (\a -> Identity (length a)) ["foobar", "baz"]
00:37:00 <lambdabot>   [6,3]
00:37:01 <Nereid> > ("foobar","baz") ^.. both
00:37:02 <lambdabot>   ["foobar","baz"]
00:37:04 <shachaf> This is just a fancy mapM where you can either map over the structure or leak information out via the Applicative.
00:37:08 <ion> > runIdentity $ both (\a -> Identity (length a)) ("foobar", "baz")
00:37:09 <lambdabot>   (6,3)
00:37:27 * liyang prefers not to think about or use mapM these days.
00:37:44 * shachaf likes mapM
00:37:53 <shachaf> I'd like it even more if Applicative was a superclass of Monad.
00:37:56 <ion> > ("foobar", "baz") & both %~ length
00:37:57 <liyang> for or traverse?
00:37:58 <lambdabot>   (6,3)
00:38:10 <ion> > ["foobar", "baz"] & traverse %~ length
00:38:12 <lambdabot>   [6,3]
00:38:13 <shachaf> I like those too. :-)
00:38:19 <elliott> shachaf: you want mapM to have a pointlessly restrictive type for no reason?
00:38:28 <liyang> shachaf: I mean, you don't need mapM if you have those.
00:38:31 <Nereid> :t mapM
00:38:33 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
00:38:44 <liyang> :t traverse
00:38:46 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
00:39:48 <shachaf> elliott: No, I want it to have traverse's type.
00:39:50 <shachaf> I just like the name.
00:39:55 <shachaf> Well, I don't like the name either.
00:40:16 <shachaf> The main thing is that I don't like the name traverse.
00:40:33 * startling % traverse return shachaf
00:40:47 <liyang> Use for instead?
00:40:55 <edwardk> :t forOf
00:40:56 <elliott> for has the wrong argument order
00:40:56 <lambdabot> LensLike f s t a b -> s -> (a -> f b) -> f t
00:41:02 <elliott> which is the right argument order sometimes
00:41:08 <Nereid> :t mapOf
00:41:09 <lambdabot> Setting s t a b -> (a -> b) -> s -> t
00:41:17 <shachaf> Nereid: mapOf is deprecated, man!
00:41:20 <shachaf> Get with the times.
00:41:27 <edwardk> it will be anyways ;)
00:41:27 <Nereid> I was seeing what it was.
00:41:54 <shachaf> edwardk: I live the the future.
00:42:13 <shachaf> Or was it the Thorsten future?
00:42:17 <elliott> shachaf: what if traverse was called "walk" instead
00:42:45 <edwardk> elliott: thought about it, but its too common a name to steal
00:42:45 <liyang> The Thorsten future? …
00:42:47 <Nereid> but there already is a "walk" in Control.Lens.Representable
00:42:53 <shachaf> liyang: Ask edwinb.
00:43:02 <elliott> edwardk: renaming traverse sounds a bit unlikely
00:43:17 <edwardk> liyang: the thorsten future is 'we will do this' when its something easy that everyone knows how to do, but nobody can be bothered to do now
00:43:20 <liyang> edwinb: I'd like to hear about the Thorsten future.
00:43:51 <edwardk> elliott: it was more a matter of whether lens should export something like it, we have 'traversed' which is the indexed version of traverse by ordinal position for instance we could alpha reduce that to walk if we wanted to
00:43:57 <liyang> edwardk: oh of course. I know that Thorsten future.
00:44:16 <sw2wolf> It seems Arrow used less than Functor, Applicative ?
00:44:31 <shachaf> edwardk: It's not alpha-reduction when you export it!
00:44:48 <liyang> Just never heard it being given a name.
00:44:48 <shachaf> Well, I suppose it's alpha-reduction "in the grand scheme of things".
00:44:50 <edwardk> liyang: basically it may or may not ever happen, but its pushed off to the future because its unimportant
00:45:15 <shachaf> edwinb knows. Things like Unicode support.
00:45:24 <startling> hahahaha
00:45:50 <liyang> shachaf: I was there too…
00:46:18 <shachaf> liyang: Where?
00:46:37 <liyang> We *are* talking about the Nottingham Thorsten ja?
00:47:04 <shachaf> liyang: I think we're talking about Thorsten Altenkirch.
00:47:14 <shachaf> Oh, that's the same one.
00:47:47 <liyang> I've been aware of the Thorsten future, just not its name.
00:47:58 <shachaf> Everyone is aware of the Thorsten future.
00:48:15 <liyang> It's just that they don't know it yet.
00:53:40 <beaky> monoids ftw
00:54:30 <lambdabot> i love monoids
00:54:35 <lambdabot> they are so easy
00:58:56 <beaky> you love them too?
00:59:12 <beaky> lambdabot can talk?
00:59:43 <edwardk> @vixen can you talk?
00:59:43 <lambdabot> Any lady who is first lady likes being first lady. I don't care what they say, they like it.
01:00:22 <beaky> so monads are things that you can chain while preserving their structure?
01:00:26 <beaky> monoids*
01:00:30 <edwardk> you didn't know it but lambdabot is really just a really helpful person.
01:00:38 <edwardk> she occasionally gets bored
01:00:48 <beaky> oh
01:00:52 <beaky> lambdabot is a she?
01:01:04 <edwardk> @vixen a/s/l
01:01:05 <lambdabot> A public man must never forget that he loses his usefulness when he as an individual, rather than his policy, becomes the issue.
01:01:18 <lambdabot> i truely am
01:01:28 <beaky> :O
01:04:20 <blz37> Please explain "whole numbers are polymorphic constants" ? thnx.
01:04:31 <Nereid> :t 1
01:04:33 <lambdabot> Num a => a
01:04:36 <shachaf> blz37: Explain what it means or explain why?
01:04:44 <shachaf> Please explain "Please explain"
01:04:48 <Nereid> :t 2.53
01:04:49 <lambdabot> Fractional a => a
01:05:20 <ion> shachaf: fix (please explain)
01:05:37 <shachaf> @ty 1e6
01:05:38 <lambdabot> Fractional a => a
01:05:43 <Nereid> heh
01:05:47 <shachaf> I have a patch to GHC that makes that Num a => a!
01:05:51 <Nereid> heh!
01:06:04 <ion> shachaf: I have wished for that every once in a while.
01:06:17 <beaky> numeric constants have their concrete type inferred for them when used in expressions or when bound to a symbol
01:06:20 <Nereid> I have a patch for ghc that lets me have trailing commas in my lists :(
01:06:31 <ion> nereid: Vade retro
01:06:42 <Nereid> or wait, that was for haskell-src-exts. close enough
01:08:56 <Nereid> and also records
01:09:12 <Nereid> interestingly, a trailing comma is already allowed in a module export list
01:09:33 <shachaf> Trailing commas?
01:09:39 <shachaf> Preceding commas are better.
01:09:45 <Nereid> :(
01:09:50 <Nereid> why
01:09:56 <Nereid> [,1,2] looks awful
01:10:04 <shachaf> [ 1
01:10:05 <Nereid> well,
01:10:06 <shachaf> , 2
01:10:07 <shachaf> ]
01:10:20 <Nereid> [
01:10:25 <Nereid> 1,
01:10:25 <Nereid> ]
01:10:28 <shachaf> [
01:10:29 <shachaf> ,
01:10:30 <shachaf> 1
01:10:31 <shachaf> ,
01:10:31 <shachaf> ]
01:10:34 <Nereid> eh
01:10:38 <blz37> shachaf, I just want to think out loud. whole numbers are constants:As a whole, they are infinite enumeration of the numbers. Each one of them belong to a different type of Num ?
01:10:47 <shachaf> blz37: No.
01:10:56 <shachaf> Or, rather: What?
01:11:02 <xenocons> :t (.&.)
01:11:03 <lambdabot> Bits a => a -> a -> a
01:11:09 <xenocons> very laggy shell
01:11:28 <Nereid> blz37: when you type the literal 35, it gets translated to "fromInteger (35 :: Integer)" internally
01:11:34 <Nereid> or you can think of it as that
01:11:35 <Nereid> :t fromInteger
01:11:37 <lambdabot> Num a => Integer -> a
01:12:15 <Nereid> so all that were really needed were Integer literals
01:12:59 <Nereid> :t fromInteger 5
01:13:00 <lambdabot> Num a => a
01:13:02 <Nereid> :t read "hello"
01:13:03 <lambdabot> Read a => a
01:13:26 * shachaf wants -ddump-everything-you-can-possibly-dump
01:14:22 <blz37> :t fromInteger 5.0
01:14:23 <lambdabot>     No instance for (Fractional Integer)
01:14:23 <lambdabot>       arising from the literal `5.0'
01:14:23 <lambdabot>     Possible fix: add an instance declaration for (Fractional Integer)
01:14:47 <Nereid> 5.0 is not an Integer
01:15:25 <Nereid> incidentally, 5.0 is like "fromRational (5/10 :: Rational)"
01:15:32 <Nereid> er
01:15:37 <Nereid> 50/10
01:15:39 <Nereid> I guess?
01:16:19 <ion> pi is like fromRational (3141592… / 1000000… :: Rational)
01:16:22 <shachaf> 5/1?
01:16:29 <Nereid> that would be 5.
01:16:36 <Nereid> if that made sense.
01:16:37 <shachaf> So would 50/10
01:16:37 <Nereid> I dunno.
01:16:41 <Nereid> I mean "5.".
01:16:53 <shachaf> thion
01:17:20 <Nereid> what does core say about this
01:17:38 <hpaste> sw2wolf pasted “How to transfer this CL code to haskell ?” at http://hpaste.org/78706
01:18:16 <ion> The most obvious way to parse “5.000” as a Rational would be 5000%1000, not 5%1. The constructor will then handle reduction as appropriate.
01:18:35 <Nereid> that's what I'm saying.
01:19:06 <blz37> Taken from "learn you a haskell", "It appears that whole numbers are also polymorphic constants. They can act like any type that's a member of the Num typeclass."
01:19:28 <Nereid> indeed
01:20:05 <ion> sw2wolf: What does it do?
01:20:30 <ion> fibs?
01:20:33 <sw2wolf> ion: it calcuates Fab number
01:20:36 <Nereid> ah, the fractions are reduced in core
01:20:37 <sw2wolf> yes
01:20:54 <Nereid> 5.15 -> fromRational (103 :% 20)
01:21:09 <sw2wolf> I am  surprised it can calcuate fab(1000) using CL without overflow
01:21:15 <ion> What does fab stand for?
01:21:37 <ion> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs !! 1000
01:21:39 <lambdabot>   434665576869374564356885276750406258025646605173717804024817290895365554179...
01:21:40 <sw2wolf> 1 2 3 5 8 13 21 ....
01:21:54 <Nereid> sw2wolf: so it modifies a list as it goes along?
01:22:01 <blz37> I think what I am trying to ask is all members of Num typeclasses are enumerated in the same manner as
01:22:10 <sw2wolf> Nereid: yes!
01:22:21 <blz37> data Bool   = True | False
01:22:30 <ion> > fix((0:).scanl(+)1) !! 1000
01:22:31 <lambdabot>   434665576869374564356885276750406258025646605173717804024817290895365554179...
01:22:52 <blz37> for some like Float, you can't count them ?
01:22:54 <Nereid> seems a waste to store the whole list if you're only ever going to look at the last 2 elements
01:22:57 <Nereid> blz37: what?
01:23:05 <sw2wolf> haskell doesnot permit modifying variable ?
01:23:10 <companion_cube> no.
01:23:11 <Nereid> no
01:23:17 <blz37> countably infinite ?
01:23:36 <xenocons> :t (#)
01:23:37 <lambdabot> parse error on input `)'
01:23:43 <xenocons> :t #
01:23:45 <lambdabot> <no location info>: not an expression: `#'
01:23:48 <xenocons> hmm
01:23:59 <xenocons> :t x#
01:24:01 <lambdabot>     Not in scope: `x#'
01:24:01 <sw2wolf> ion: i will study your code, thx
01:24:01 <lambdabot>     Perhaps you meant `x' (imported from Debug.SimpleReflect)
01:24:11 <startling> Float isn't uncountably infinite.
01:24:18 <ion> sw2wolf: Ignore the latter one, it’s unnecessary golfing.
01:24:20 <Nereid> nothing computable is uncountable.
01:24:37 <sw2wolf> ion: ok
01:24:43 <Nereid> (although it may not be computably countable!)
01:24:46 <blz37> Nereid, How is Float defined ?
01:25:15 <Nereid> blz37: as a wrapper for Float#, but you're probably asking the wrong question
01:25:16 <startling> Nereid: data Rational = Ratio Integer Integer ? ignoring Integer's bounds, I guess
01:25:22 <Nereid> Integer has no bounds
01:25:40 <startling> integer can only go so high, though
01:25:54 <Nereid> yes, it has to fit inside the 8GB of ram my computer has.
01:25:58 <startling> yes.
01:25:59 <xenocons> in http://hackage.haskell.org/packages/archive/base/3.0.3.2/doc/html/src/GHC-Word.html, what is the purpose of '#'?
01:26:14 <Nereid> xenocons: it's the MagicHash
01:26:19 <startling> xenocons: it's a tag for GHC's internal types
01:26:46 <neutrino_> hi
01:27:13 <Nereid> afaik it's just another letter. but it generally denotes something that deals with unboxed types.
01:27:22 <Nereid> Int# is an unboxed int.
01:27:25 <neutrino_> what is a "section"? I just got this error and am wondering what code of this format would do: A section must be enclosed in parentheses    thus: (tp "getFullRevIdByPath returns the latest revision id." $)
01:27:41 <blz37> Nereid, I am still trying to "fully" grasp "It appears that whole numbers are also polymporhic constants. They can act like any type that's a member of the Num typeclass."
01:27:41 <Nereid> int2Word# takes an unboxed int to an unboxed word. etc.
01:27:42 <neutrino_> what does (foo bar $) do?
01:27:56 <Nereid> neutrino_: ($) (foo bar)
01:28:15 <neutrino_> oh
01:28:17 <mauke> foo bar
01:28:34 <neutrino_> a section is just an infix operator which has been applied to one side, yes?
01:28:37 <Nereid> yes
01:28:40 <neutrino_> thanks Nereid
01:28:41 <shachaf> blz37: It's not such an important thing as far as learning Haskell goes, really.
01:28:48 <shachaf> (I mean, it's important, but it'll seem natural later on.)
01:28:51 <shachaf> It means that
01:28:52 <shachaf> > 1 :: Int
01:28:54 <lambdabot>   1
01:28:55 <shachaf> > 1 :: Float
01:28:57 <lambdabot>   1.0
01:29:03 <shachaf> You can use a literal like 1 as different types.
01:29:12 <Nereid> i.e. 1 is a polymorphic value.
01:29:34 <neutrino_> Nereid: err... you mean literal.
01:29:42 <neutrino_> a value has a specific type assigned to it.
01:29:55 <Nereid> 1 has a specific type. its type is forall a. Num a => a
01:30:05 <neutrino_> hmm
01:30:31 <neutrino_> right
01:31:27 <Hazel|artemis> ah, not my imagination... went to /msg someone and it turned out they logged out just before I /msg'd, heh
01:35:06 <blz37> Nereid, yes 1 has a specific type based on the context. I mean compiler can infer its type from the context. What I am trying to compare the types to which 1 belongs is with the definition of type like Bool, where "data Bool = True | False". Imagining "data Integer = "...-1, 0, 1..." and "data Float = "...-1.0...0...1.0..".
01:35:29 <Nereid> that has nothing to do with polymorphism.
01:35:45 <Nereid> you can look up the definition of Integer yourself.
01:36:35 <startling> is there a way to report some error with Aeson's parser?
01:37:02 <startling> :t 1
01:37:03 <lambdabot> Num a => a
01:37:07 <startling> blz37: ^
01:38:18 <startling> also, ugh, I can't use an aeson parser that's not part of a FromJSON instance?
01:38:28 <blz37> thnx. I need to read more. I am looking at the definition of Integral.
01:38:33 <Nereid> no, not Integral
01:38:39 <startling> blz37: that's not what you want at all
01:40:08 <blz37> Integer and Int are instances of Integral ?
01:40:29 <Nereid> they are.
01:40:59 <blz37> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Integer
01:41:58 <startling> this sucks. I can't run an Aeson "Parser" on my own? :/
01:41:58 <shachaf> What does "main:Foo.Foo{v reR}" mean?
01:42:01 <shachaf> The v reR part
01:42:21 <startling> blz37: what about it?
01:42:24 <blz37> http://zvon.org/other/haskell/Outputprelude/Integral_c.html
01:42:31 <blz37> I am looking at those two links.
01:42:39 <Nereid> startling: sure you can.
01:42:51 <Nereid> just because Value is an instance of From/ToJSON doesn't mean you need to use those instances.
01:42:52 <startling> blz37: they're not going to tell you very much
01:43:22 <startling> Nereid: so I've got a Parser A. how do I get an A out of it?
01:43:34 <Nereid> you parse something with it.
01:43:54 <startling> Nereid: yes. how? afaict aeson doesn't expose anything to do that
01:43:54 <blz37> yes but it satisfies something. Apart from the type classes that it belongs to, it is simply defined as "...".
01:44:18 <Nereid> blz37: the implementation is magical, I wouldn't worry about
01:44:20 <shachaf> blz37: Yes, this instance is "magic"
01:44:21 <Nereid> about it
01:44:29 <shachaf> You can write something equivalent to Integer by yourself with no magic.
01:44:34 <shachaf> It'd be much less efficient, though.
01:44:59 <Nereid> startling: aeson doesn't define Parser either. that's all attoparsec stuff
01:45:23 <startling> Nereid: OH, didn't realize that
01:45:31 <Nereid> you would if you clicked on the Parser link in the doc
01:45:40 <blz37> now, I am sated because of "...". thnx a lot. A lot more to read.
01:45:42 <Nereid> or looked at the source
01:46:11 <startling> Nereid: I was thrown off because ghci tells me parseJSON :: FromJSON a => Value -> aeson-0.6.0.2:Data.Aeson.Types.Internal.Parser a
01:46:42 <startling> so I assumed Parser was defined in Data.Aeson.Types.Internal. thanks!
01:46:45 <Nereid> yes, and Data.Aeson.Types.Internal imports Parser from attoparsec.
01:46:45 <Nereid> yeah
01:47:53 <Nereid> there's a reason aeson depends on attoparsec :p
01:47:58 <startling> heh
01:55:37 <fmap> IIRC there are 2 Parsers, one from Aeson and another from Aeson exposed
01:55:48 <shachaf> Aeson secrets revealed
01:56:11 <fmap> s/Aeson/attoparsec/
02:02:55 <Nereid> fmap: so there are. how confusing
02:04:17 <fmap> I actually have an example of Aeson parser without FromJSON instances, but code is so ugly I'm not sure anyone should see it :[
02:08:52 <Mert> Yo
02:09:13 <xenocons> is it convention to put a type annotation above the function? meaning, if inference can already do a good job of working it out, should one sitll put the type signature?
02:09:16 <xenocons> still*
02:09:53 <xenocons> i have this function 'updateKeys' which compiles fine without the need to annotate
02:09:54 <shachaf> xenocons: Yes.
02:10:00 <shachaf> It's mostly to help the human read your code.
02:10:07 <shachaf> (It really helps.)
02:10:15 <xenocons> okay, will do
02:10:41 <xenocons> easy enough to get with :t heh
02:10:48 <Nereid> the type is the most informative part of a function definition
02:11:14 <Nereid> well, it is informative. much more so than in many other languages.
02:11:17 <shachaf> xenocons: Please never leave a type variable with a name like "t1" in your code.
02:11:32 <shachaf> Nereid: I know, man. I don't know why those Agda folks even bother.
02:11:34 <Nereid> but I like my t, t', t1, and t2
02:11:49 <Nereid> shachaf: ?
02:11:53 <xenocons> updateKeys        :: (Num i, Ix i, IArray a Word32) => a i Word32 -> Word32 -> Word32
02:11:59 <xenocons> heh
02:12:11 * xenocons quickly goes and changes k1 to something else
02:12:37 <shachaf> xenocons: Also, you might want to specialize the type if you know what you'll use it as.
02:12:47 <xenocons> like type alias?
02:13:12 <shachaf> For example if the index is always Int, you could say (IArray arr Word32) => arr Int Word32 -> Word32 -> Word32
02:13:30 <xenocons> oh nice ok i see
02:13:30 <shachaf> It might make it clearer to the reader. It might improve performance. Who knows.
02:15:11 <xenocons> ( i dont really even know if this function will work yet)
02:15:15 <Nereid> on the other hand, the user of your library might then wish your type was more polymorphic.
02:15:16 <xenocons> just translating it from some C
02:15:19 <Nereid> (that user might be you!)
02:15:30 <shachaf> Nereid: Sure.
02:15:32 <shachaf> Or they might not.
02:15:36 <Nereid> indeed.
02:15:41 <shachaf> There are many cases when you want the type to be more specific.
02:18:31 <neutrino_> xenocons: i just translated like 500 lines from python and it ran on first try :P
02:19:26 <xenocons> neutrino_: heh
02:19:47 <xenocons> im trying to think of a way to do this actually, meh
02:19:54 <xenocons> stupid code updates a global array\table
02:20:04 <xenocons> and periodically calls this update function
02:20:18 <xenocons> im considering just returning the updated values from my update function
02:20:30 <xenocons> but evvverything seems to rely on this global array
02:21:26 <neutrino_> sounds like State
02:22:02 <xenocons> well, its unncessary, imo
02:22:11 <neutrino_> however, have you considered refactoring the C code so that it doesn't do that, before continuing with your translation?
02:22:27 <xenocons> oh right, that might be a good step
02:22:35 <xenocons> did not even consider refactoring the C
02:24:27 <neutrino_> you might only need to refactor it so that accessing global state is moved to separate functions
02:24:38 <xenocons> some parts of it that i wrote are very easy to translate, but some stuff that i stole from vim is... evil
02:24:42 <neutrino_> this way you would be able to reason about it better in haskell term
02:24:43 <neutrino_> s
02:24:58 <neutrino_> why were you stealing code from vim?
02:25:10 <xenocons> yes i would love to remove the state (keys)
02:25:25 <xenocons> its vim 7.2 :X
02:25:34 <neutrino_> yeah, but why?
02:25:34 <xenocons> which encrypts a file with very bad xor encryption
02:25:38 <neutrino_> oh
02:25:48 <neutrino_> yeah
02:25:48 <xenocons> i just stole the vim part that does the encryption, and use that to crack it
02:25:53 <neutrino_> haha
02:26:02 <neutrino_> why not just call that from FFI?
02:26:28 <xenocons> but my current approach (using frequency tabs) doesn't really work, what i need to do is something a bit different... constants based on file extension
02:26:37 <xenocons> ah, i figured it might be a good first haskell project
02:26:59 <neutrino_> gotcha
02:27:39 <xenocons> http://codepad.org/YmzXzIwR
02:28:29 <xenocons> probably a million bugs, i suck at C
02:28:59 <Nereid> more bugs than bytes?
02:29:11 <xenocons> id say definetly
02:29:36 <xenocons> find C very confusing, and C++ i guess
02:29:36 <Twey> xenocons: The usual rubric I've come across is that you should always annotate functions that are going to be exported
02:29:57 <Botje> OT: I wonder when this [+] or [-] thing in scripts started.
02:30:14 <Botje> it's certainly handy to see where a process goes off the rails.
02:30:34 <Twey> blz37: For the record, zvon.org is very outdated as a reference.
02:30:46 <xenocons> Twey: that makes sense i think
02:30:50 <Botje> xenocons: lines 219--220 are *very* dodgy.
02:31:21 <xenocons> Botje: heh i suspect there is some memory corruption there somewhere
02:31:44 <Botje> you're mallocing memory and then throwing away the only handle to said memory.
02:31:53 <xenocons> ah right
02:32:08 <xenocons> i tried to rewrite it in F# at one stage but got frustrated
02:32:15 <xenocons> and gave up
02:32:43 <merijn> xenocons: Casting malloc ಠ_ಠ
02:33:27 <xenocons> you need to cast malloc in msvc i think
02:33:52 <merijn> That'd mean msvc is not standard compliant, which would be odd
02:33:54 <kranius> why ?
02:34:13 <Twey> Nereid: for (long long i = 0; i < 5; i--) bug(1, alloca(2), 3); // many more bugs than bytes
02:34:15 <merijn> kranius: It's a vile C++-ism that's considered bad style in C
02:34:28 <Twey> merijn: Hahaha, odd?  Have you ever *used* MSVC?
02:34:32 <kranius> yeah, one does not need to cast malloc
02:34:41 <Ghoul_> :3
02:34:45 <Ghoul_> http://sphotos-c.ak.fbcdn.net/hphotos-ak-ash4/390232_10151181008550959_484588830_n.jpg
02:34:58 <Twey> Ghoul_: Cute
02:35:54 <merijn> kranius: For some discussion of why/why not: http://stackoverflow.com/questions/605845/do-i-cast-the-result-of-malloc
02:38:13 <xenocons> afaik, you cant not cast it in msvc
02:38:15 <xenocons> it errors
02:38:28 <xenocons> (i think)
02:38:43 <xenocons> but i know jack all about C
02:39:09 <Ghoul_> so
02:39:27 <Ghoul_> how can I reliably get a pointer to a function written in C
02:39:29 <Ghoul_> from haskell
02:39:33 <Ghoul_> if I include the C w/ the haskell
02:40:54 <Nereid> Ghoul_: FFI
02:44:24 <merijn> xenocons: Are you sure it's not actually trying to compile your code as C++ or something?
02:44:52 <arbn> So... I've just re-read the LYaH chapter on zippers, and I've been told that behind every zipper lies a comonad. Is there any good post or tutorial that explains this clearly?
02:45:21 <xenocons> merijn: shouldnt be, but thre may be some compiler flag
02:46:30 <arbn> Or maybe someone here could explain the connection between a zipper and some comonad?
02:47:28 <Nereid> arbn: google ;)
02:47:29 <Nereid> http://blog.sigfpe.com/2007/01/monads-hidden-behind-every-zipper.html
02:47:56 <Taneb> How do I add .cabal/bin to my path again?
02:48:19 <Nereid> Taneb: consult your shell's manual
02:49:52 <Philippa> mornin'
02:50:00 <Zetetic> Hullo
02:50:10 <shachaf> Yawg.
02:50:13 <Philippa> was wondering if anyone's actually about at this time these days, I'm usually not!
02:50:24 <shachaf> @localtime Philippa
02:50:25 <lambdabot> Local time for Philippa is Mon Dec 03 10:50:07 2012
02:50:26 * Twey is, sort of.
02:50:34 <shachaf> @localtime
02:50:35 <Nereid> Taneb: in my .zshrc I have a line PATH="~/.cabal/bin:$PATH"
02:50:38 <lambdabot> Local time for shachaf is Mon Dec  3 02:50:17 2012
02:50:39 <Philippa> Zetetic: nice nick, if possibly a little excessive ;-)
02:50:49 <Nereid> @localtime Nereid
02:50:49 <lambdabot> Local time for Nereid is Mon Dec 3 02:50:32 2012
02:50:50 <Zetetic> What's excessive about my name?
02:50:56 <Nereid> @localtime Nereid
02:50:57 <lambdabot> Local time for Nereid is Mon Dec 3 02:50:39 2012
02:51:13 <Philippa> Zetetic: heh, you've had it that long you've forgotten the book it's taken from?
02:51:23 <Zetetic> No, I also use the nick Elench
02:51:31 <Nereid> @localtime Nereid
02:51:31 <lambdabot> Local time for Nereid is Mon Dec 3 02:51:13 2012
02:51:33 <Nereid> hmm
02:51:42 <Philippa> right. Just punning, though they were perhaps... excessively contacty?
02:51:54 <shachaf> Nereid is on the best coast?
02:51:59 <Nereid> heh :)
02:52:04 <Zetetic> Oh sorry, I'm not awake enough for puns
02:52:16 <Nereid> sometimes it'll say I'm on UTC though...
02:52:26 * Twey chuckles.
02:52:27 <shachaf> I thought you were in either Russia or the east coast.
02:52:33 <Nereid> haha
02:52:39 <Nereid> why would you think that?
02:52:39 <Twey> I always read ‘Zetetic’ as an adjective in the books.
02:52:52 <shachaf> I guess your nick starts with n, like nus-.
02:53:06 <Zetetic> Twey: I assume it is
02:53:12 <Philippa> okay, now I have anything else to do I think I'm officially too damn tired to work on this constraint code for a bit. I have most of a framework and if prodded I'll have something on GitHub within the next week or two, I just had a hell of a weekend
02:53:28 <Twey> Nereid: Don't you know all Russians have names beginning with n-?
02:53:37 <mauke> nyet
02:53:37 <Nereid> no...
02:53:43 <Nereid> ...
02:53:44 <Nereid> :p
02:53:46 <Twey> :þ
02:54:05 <shachaf> Nereid: If you're in the bay area you should come to bahaskell!
02:54:08 <shachaf> (But you're probably not.)
02:54:12 <Nereid> nope, Vancouver
02:54:18 <Nereid> @localtime Nereid
02:54:19 <lambdabot> Local time for Nereid is time to get a watch!
02:54:29 <Zetetic> @localtime Zetetic
02:54:29 <lambdabot> Local time for Zetetic is Mon Dec 03 10:54:24 2012
02:54:32 <mauke> @localtime
02:54:35 <lambdabot> Local time for mauke is Boomtime, the 45th of The Aftermath in the YOLD 3178.
02:54:43 <Nereid> lol
02:55:08 <latermuse> @localtime latermuse
02:55:10 <latermuse> :)
02:55:14 <lambdabot> Local time for latermuse is Mon Dec  3 18:54:52 2012
02:55:16 <Nereid> @bots
02:55:17 <lambdabot> :)
02:55:20 <latermuse> nice
02:55:29 <latermuse> lambdabot smiled at me
02:55:51 <Zetetic> Must be love
02:55:58 <latermuse> now kiss
02:56:13 <Nereid> @arr
02:56:14 <lambdabot> I'll keel haul ya fer that!
02:57:32 <arbn> Nereid: I'm not really interested in monads right now, but comonads, and the PDF linked to in that post seems a little over my head, thus my request.
02:58:35 <Nereid> arbn: but the post is about comonads
02:59:08 <b____> is it advisable to annotate functions with as general types as possible, or is it better to make things very specific?
02:59:21 <Nereid> depends!
02:59:29 <arbn> Nereid: Ah. Sorry. I feel dumb. I read the first paragraph, and followed the link to the PDF, without looking more closely at the rest of the article. :P Thanks.
03:00:08 <Nereid> b____: or possibly something in between
03:00:21 * Nereid is the most unhelpful person.
03:00:23 <b____> Nereid I thought so
03:00:32 <b____> well my question is quite unhelpful and general
03:00:37 <Nereid> heh
03:00:44 <b____> but I'm still curious
03:01:15 <b____> in cases where you don't yet know whether liberal or tight types are appropriate
03:01:51 <shachaf> "As I've mentioned on #haskell" -- dpiponi isn't around anymore these days, is he?
03:02:07 <FireFly> If I had to choose one of those I'd say as general as possible
03:02:16 <Nereid> I don't recall seeing him around recently.
03:02:26 <shachaf> I don't recall ever seeing him around.
03:02:46 <Nereid> I feel like I've seen a sigfpe in here a long time ago.
03:02:47 <Twey> b____: As general as possible, always.
03:03:02 <shachaf> Hmm, IRC logs indicate me talking to him at least once.
03:03:05 <arbn> Hmm. When I start by writing the types... basically using the type system as my design language, it's been obvious how specific they should be.
03:03:11 <Twey> A lot of worthless synonyms would be saved if the Prelude functions were annotated more generally.  :þ
03:03:37 <Nereid> b____: generally a general type is preferable, especially if you're writing a library, but there are cases where you'd want to specialize.
03:03:56 <shachaf> Twey: Such as?
03:04:03 <Nereid> length?
03:04:23 <Twey> shachaf: map/fmap, (.), id, (++)…
03:04:28 <b____> My example would be I have a type: `type S = forall. a k. (Num a, Ord k) => Map k a`, but I have functions which could operate on a Map where there is no Num restriction on a
03:04:29 <shachaf> What should length's type be?
03:04:36 <Nereid> :t genericLength
03:04:37 <lambdabot> Num i => [b] -> i
03:04:44 <shachaf> Eh.
03:04:45 <Twey> There's a good performance reason for length, though
03:04:52 <shachaf> genericLength is a foldr
03:04:58 <Twey> I wouldn't generalize all the way to Num, anyway.  Maybe Integral.
03:05:04 <shachaf> (It has to be, for the lazy Nat trick to work.)
03:05:17 <Nereid> b____: ah, there's no reason to put on extra typeclass constraints when you don't need them. I think.
03:05:20 <shachaf> Twey just wants Haskell 1.4 back.
03:05:26 <b____> okay
03:05:29 <Twey> Heheh.
03:05:35 <Taneb> :t Data.Foldable.foldmap (const $ Sum 1)
03:05:36 <Twey> We have monad comprehensions now
03:05:37 <lambdabot>     Not in scope: `Data.Foldable.foldmap'
03:05:37 <lambdabot>     Perhaps you meant one of these:
03:05:37 <lambdabot>       `Data.Foldable.foldMap' (imported from Data.Foldable),
03:05:40 <Twey> They're coming around!
03:05:42 <Taneb> :t Data.Foldable.foldMap (const $ Sum 1)
03:05:43 <lambdabot> (Num a1, Foldable t) => t a -> Sum a1
03:05:49 <Taneb> :t getSum . Data.Foldable.foldMap (const $ Sum 1)
03:05:50 <lambdabot> (Num b, Foldable t) => t a -> b
03:05:57 <Taneb> evenGenericerLength
03:06:10 <shachaf> @ty sumOf folded
03:06:12 <lambdabot> (Num b, Foldable f) => f b -> b
03:06:14 <Twey> Hehe
03:06:18 <b____> but Nereid I want to make sure my functions can only operate on the type of Map I described
03:06:18 <Taneb> Or you can be futuristic and lensy
03:06:30 <Taneb> shachaf, that doesn't work
03:06:36 <shachaf> Hm?
03:06:37 <Taneb> > sumOf folded "Hello"
03:06:38 <lambdabot>   No instance for (GHC.Num.Num GHC.Types.Char)
03:06:38 <lambdabot>    arising from a use of `Cont...
03:06:47 <shachaf> Oh, whoops.
03:06:47 <Twey> b____: Why, if they operate perfectly well on other types of Map?
03:06:49 <Taneb> You need to make them all 1s first
03:06:50 <shachaf> @ty lengthOf folded
03:06:51 <lambdabot> Foldable f => f b -> Int
03:06:52 <Nereid> b____: (1) ok, then go ahead and do that. (2) why?
03:06:54 <Taneb> Better
03:07:03 * shachaf didn't read closely.
03:07:04 <Taneb> Mine's still more generic
03:07:15 <shachaf> This one's restricted on purpose.
03:07:20 <Nereid> :t foldMapOf
03:07:21 <elliott> Twey: Which (.) generalisation do you refer to?
03:07:21 <lambdabot> Getting r s t a b -> (a -> r) -> s -> r
03:07:23 <b____> hm, because I am sorta making an edsl
03:07:29 <Twey> elliott: Probably Category
03:07:31 <b____> but you're saying it's not an issue?
03:07:36 <shachaf> Twey: Today you can live.
03:07:41 <Nereid> :t views
03:07:42 <lambdabot> Getting r s t a b -> (a -> r) -> s -> r
03:07:45 <Twey> \o/
03:07:52 * Twey makes another mark on the wall.
03:07:59 <shachaf> views :: MonadReader s m => Getting r s t a b -> (a -> r) -> m r
03:08:11 <Nereid> heh
03:08:16 <b____> Nereid, does it not make sense to restrict my functions in the case of an EDSL?
03:08:20 <Twey> There appears to be a lot of stabbing going on, though.
03:08:26 <Nereid> b____: I don't know.
03:08:41 <Twey> b____: It depends on your EDSL
03:08:59 <Twey> Are you enforcing a useful property within your EDSL, or are you just restricting them because you can?
03:09:29 <b____> good question, probably the former ;p
03:09:35 <Nereid> arbn: ah, I was actually think about the cellular automaton post.
03:09:41 <Nereid> that one's actually about comonads.
03:10:27 <b____> I guess it indeed does not make sense to restrict the types
03:11:48 <arbn> Nereid: Actually, the post you linked is very helpful, now that I stare at it for longer. I've been linked the CA on by Cale before, though. I'll probably look at that one soon, too. :)
03:11:59 <Nereid> heh
03:12:03 <b____> I might have done so in a misguided ideal of coherence
03:12:04 <arbn> the CA one*
03:23:34 <Ferdirand> 7/win 20
03:23:36 <Ferdirand> oops
03:24:01 <Zetetic> Oh look, irssi
03:24:10 <Twey> Without a /w alias?  Scandalous
03:24:24 <Zetetic> Can you switch by name too or do you have to memorise all the window numbers?
03:24:31 <Twey> You can switch by name
03:24:36 <Zetetic> Thanks :)
03:24:53 <Twey> /join #channel will switch to the window if you're already joined
03:25:04 <Twey> I have keybindings up to 40, though, so I don't use it much
03:25:04 <Nereid> I prefer /window goto
03:25:12 <Nereid> which you can still give a name
03:25:16 <zomg> I prefer making an alias for /window goto that's less typing =)
03:25:22 <Nereid> I did that too.
03:25:24 <Twey> Like /w
03:25:25 <Twey> :þ
03:25:31 * Nereid /wc
03:25:33 <Nereid> er, /wg
03:25:42 <zomg> although most of the time I just press meta-a to jump to active
03:25:44 <Zetetic> I prefer C-x b
03:25:46 <Jafet> /wc whisks you to the bathroom
03:25:52 <Nereid> nah, /wc is /window close
03:26:01 <zomg> Best feature in irssi: /disco on
03:26:02 <Nereid> I like yours better though.
03:26:04 <zomg> Disco time!
03:26:10 <Twey> Heh
03:26:20 <Nereid> heh.
03:26:21 <Twey> Zetetic: I would like to if emacs had better buffer-management features
03:26:35 <Zetetic> Twey: what don't you like about them?
03:26:36 <Twey> My emacs gets cluttered enough as it is, without my ~50 IRC buffers barging in there too
03:26:46 <Zetetic> Ah, the lack of the tree?
03:26:48 <Twey> I would like to be able to group them
03:26:49 <Twey> Yes
03:26:55 <Zetetic> Then we agree
03:27:24 <Zetetic> Well, except I think it's worth using anyway
03:27:57 <Zetetic> Twey: when will you write a better emacs in Haskell?
03:28:11 <Entroacceptor> I'm correct that there's no active IRC library on hackage?
03:28:43 <aaaersfons> Zetetic: There's Yi
03:28:54 <Entroacceptor> Zetetic: you just write a Haskell-to-elisp compiler and we're all done :)
03:29:24 <Twey> Zetetic: I won't
03:29:42 <Twey> Zetetic: My desktop environment will do it properly
03:30:00 <Zetetic> Hehe
03:31:02 <Entroacceptor> Twey: oh, you've taken over manatee development>?
03:31:05 <Zetetic> Interesting that Yi uses "normal" keybindings over emacsy ones
03:31:20 <Twey> Entroacceptor: Haha, no :þ
03:31:40 <Twey> Entroacceptor: Did that ever get to the desktop-environment stage?
03:31:59 <Entroacceptor> it's impressive what he managed
03:32:38 <Entroacceptor> it already has webbrowser, irc client, feed reader, pdf viewer and a music player
03:32:48 <Twey> Interesting
03:32:55 <Twey> Though I can't help but consider it a little misguided
03:33:00 <Entroacceptor> yeah
03:33:20 <Entroacceptor> andrew has disappeared, anyway
03:33:22 <Twey> No, I want to solve the problem properly, from the desktop down
03:33:28 <Twey> It's on the backburner somewhere
03:33:46 <Entroacceptor> you're serious/
03:33:47 <Entroacceptor> ?
03:33:48 <Twey> Yeah
03:33:58 <Zetetic> If you do that, you'll have implimented a better emacs
03:34:01 <Zetetic> Probably in Haskell
03:34:04 <Twey> Zetetic: This is true
03:34:09 <Twey> Probably not in Haskell, though
03:34:18 <Zetetic> Fair enough, what in?
03:34:19 <Twey> I'm leery of garbage-collection
03:34:37 <Twey> I'm considering ATS maybe, or my own language
03:34:45 <Entroacceptor> ok, doomed from the start
03:34:48 <Twey> :þ
03:34:59 <Twey> doublec has actually been quite productive in ATS
03:35:18 <Twey> The C integration offsets a lot of the shiny-language syndrome
03:35:41 * arbn had never heard of ATS.
03:35:49 <ramses_> can anyone tell me where I can find the :< operator that's used in http://cs.ioc.ee/~tarmo/tsem05/uustalu0812-slides.pdf ?
03:36:09 <Nereid> ramses_: on slide 4? it's defined there
03:36:11 <Twey> But a programming language is something else I want to do, so it would be nice to use this as a motivating case
03:36:21 <Twey> Or I'll probably use Rust if that goes stable first
03:36:35 <arbn> Twey: I was about to suggest Rust. It would be nice for that kind of project.
03:36:54 <ramses_> Nereid: ah it's just a data constructor he defined! ok thanks :)
03:37:01 <Nereid> yep
03:37:13 <Twey> Agreed — Rust looks like it will pass my decent-language threshold
03:38:20 <ramses_> Nereid: is that an infix definition then? I must never have seen that before
03:38:43 <Twey> ramses_: Colons introduce type operators the same way uppercase letters introduce type functions
03:38:50 <Twey> It's ‘uppercase punctuation’
03:39:11 <Zetetic> Is learn you a haskell a good choice?
03:39:13 <Twey> Yep
03:39:30 <Twey> Or Real World Haskell if you prefer a bit less flippancy & some more real-world examples
03:39:33 <Zetetic> Twey: one of the design languages is related to Haskell
03:39:45 <Twey> Zetetic: Beg your pardon?
03:40:01 <Zetetic> Twey: design languages for objects I can make when the printer turns up
03:40:09 <Twey> Oh, right
03:40:14 <Zetetic> So I can write objects in Haskell and compile them to plastic
03:40:24 <ramses_> Twey: ah ok, that explains why I cannot make value operators starting with a colon
03:40:28 <FireFly> Damn it, people from pretty much every other channel I'm in on Freenode seem to end up in #haskell..
03:40:53 <Twey> Oh no, wait, what?  They removed typestates from Rust?
03:41:01 <Twey> FireFly: Ha
03:41:13 <Twey> FireFly from ##javascript, meet Zetetic from ##English
03:41:31 <Zetetic> A pleasure
03:41:43 <Zetetic> FireFly is from English too though
03:42:04 <nicoo> FireFly: #haskell is an attraction point of the IRC-space.
03:42:06 <Nereid> Twey: what were typestates?
03:42:16 <zomg> He just hangs out with the wrong people
03:42:16 <FireFly> Apparently so
03:42:27 <Twey> Nereid: An OO specialization of unique types
03:42:43 <Nereid> I...don't know what that means.
03:43:11 <Twey> Nereid: An object has an associated typestate; calling methods on the object can change the object's typestate, & different methods are valid or invalid on different typestates
03:43:24 <Twey> Statically
03:43:33 <Nereid> ahh
03:44:07 <FireFly> That.. sounds interesting
03:44:14 <Twey> Socket<Open>.read() is valid; Socket<Open>.close() results in its context mutating into a Socket<Closed>; Socket<Closed>.read() is a type error
03:44:31 <Nereid> FireFly: well haskell already supports such a thing ;)
03:44:45 <Twey> It's just a special case of unique or linear typing, but it's probably the most useful one
03:51:19 <structuralist> Why doesn't Haskell have a formal specification?
03:53:03 <latermuse> structuralist: because it isnt committee run
03:53:15 <neutrino_> @faq Why doesn't Haskell have a formal specification?
03:53:15 <lambdabot> The answer is: Yes! Haskell can do that.
03:53:15 <shachaf> latermuse: It isn't?
03:53:28 <latermuse> shachaf: it was, then they disbanded the committee
03:53:42 <shachaf> http://hackage.haskell.org/trac/haskell-prime/wiki/Committee looks like a committee to me.
03:53:47 <latermuse> I read about it in the history of haskell pdf on haskell.org
03:55:23 <structuralist> oh so it's just a bureaucratic thing, not something to worry about?
03:55:48 <latermuse> Structuralist: I believe its been more than 10 years since the committee disbanded. I dont think there is anything to worry about. ;)
03:56:06 <quicksilver> haskell does have a formal specification.
03:56:16 <quicksilver> what it doesn't have is a precisely written down formal semantics.
03:56:22 <neutrino_> latermuse: the committee gets dissolved every year.
03:56:42 <structuralist> what's the difference?
03:56:44 <latermuse> neutrino_: Isnt that just the committe that presides over the haskell.org financials?
03:56:56 <neutrino_> look at the link that was just posted.
03:57:32 <latermuse> Checking it out now.
04:00:25 <Jafet> What is a formal specification?
04:01:11 <ion> Someone should infiltrate the next Haskell Report committee and make them fix the standard typeclasses.
04:01:23 <quicksilver> you hardly need to infiltrate it
04:01:30 <quicksilver> you just need to propose a solution and get people to agree
04:02:01 <Nereid> infiltrate their minds :)
04:02:13 <neutrino_> ion: haha.
04:02:15 <neutrino_> ion: yes.
04:02:21 <Jafet> That sounds harder than just infiltrating the committee
04:03:43 <quicksilver> just make sure you know *exactly* what colour the bike shed needs to be.
04:03:57 <neutrino_> hey, guys, i have a question about quickcheck. I have a property which accepts [String] as the parameter. However the preconditions are fairly heavy and it never gets to the failing cases. I want to write an Arbitary instance which will generate the right data instead. can i just do type MyStrings = [String]; instance Arbitrary MyStrings where ... ?
04:04:25 <neutrino_> the gist is: will the instance work with type aliases?
04:04:41 <Jafet> No, you can't make type synonym instances.
04:04:46 <Nereid> yes, if you enable -XTypeSynonymInstances
04:04:56 <Nereid> however
04:05:02 <neutrino_> go on Nereid
04:05:08 <Nereid> that'll be the exact same as writing instance Arbitrary [String] where ...
04:05:14 <neutrino_> ah right
04:05:16 <neutrino_> that sucks
04:05:21 <neutrino_> i need a newtype, then, right?
04:05:29 <ion> You don’t necessarily need a separate Arbitrary instance for that, though. http://hackage.haskell.org/packages/archive/QuickCheck/latest/doc/html/Test-QuickCheck-Property.html#v:forAllShrink
04:06:31 <structuralist> http://i.qkme.me/3s0pzh.jpg
04:06:34 <quicksilver> yes, typeclasses suck
04:06:39 <structuralist> that took too long
04:06:41 <quicksilver> just use a 'Gen' object
04:06:45 <neutrino_> ion: hmm, i don't know what forAllShrink really does. could i just use forAll?
04:07:02 <ion> neutrino: Yes.
04:07:28 <neutrino_> i have thought about writing a generator
04:07:35 <neutrino_> but i thought Arbitrary was easier
04:07:46 <neutrino_> but now i've found some code which should work well
04:08:10 <ion> You pass to forAll and forAllShrink exactly what you would use as “arbitrary” and “shrink” in your Arbitrary instance.
04:08:24 <neutrino_> i've never used shrinking
04:09:04 <neutrino_> although for this property i don't think i especially need it
04:09:26 <neutrino_> thanks for the tips guys
04:10:00 <ion> If the default shrink for [String] happens to suit the property, you can just use it: “forAllShrink myGen shrink …”.
04:10:24 <ion> If not, feel free not to use shrinking if that’s more convenient.
04:11:21 * hackagebot ghc-paths 0.1.0.9 - Knowledge of GHC's installation directories  http://hackage.haskell.org/package/ghc-paths-0.1.0.9 (SimonMarlow)
04:11:56 <danny> Hello
04:12:38 <typoclass> danny: hi
04:13:17 <neutrino_> hmm
04:13:51 <neutrino_> how would i create a Gen that yields a list of random length?
04:13:56 <neutrino_> i'm not sure how to start
04:13:59 <Nereid> it already does
04:15:27 <neutrino_> oh, i see what you mean
04:15:38 <neutrino_> no, i don't mean that it yields an arbitrary amount of values as needed
04:15:45 <neutrino_> i mean that each value should be a list of random length
04:15:50 <Nereid> indeed
04:16:11 <neutrino_> i'm afraid you're confusing me
04:16:35 <neutrino_> can you explain what you mean?
04:17:11 <Nereid> look at the doc for listOf, say
04:18:42 <Nereid> >>> sample (arbitrary :: Gen [Int])
04:18:42 <Nereid> []
04:18:42 <Nereid> [2,2]
04:18:42 <Nereid> [1,-4,4,4]
04:18:42 <Nereid> etc.
04:18:50 <neutrino_> right, the source is fairly straightforward
04:19:13 <neutrino_> but but what i need to do is to only generate lists with specific elements
04:19:32 <Nereid> ok, then use the stuff that's provided for you.
04:20:01 <neutrino_> what do you mean? sorry
04:20:13 <neutrino_> it's a bit difficult to follow you Nereid :)
04:20:38 <Nereid> listOf (elements [1..3]) will make a random list of random numbers from 1 to 3.
04:21:01 <Nereid> etc.
04:21:21 * hackagebot snap-auth-cli 0.1.0.1 - Command-line tool to manage Snap AuthManager database  http://hackage.haskell.org/package/snap-auth-cli-0.1.0.1 (DmitryDzhus)
04:21:41 <neutrino_> ahh
04:22:00 <neutrino_> that makes sense!
04:22:37 <Botje> 2pfff
04:26:18 <danny> Does anyone have anyone know of any collaborative filtering libraries for haskell?
04:26:30 <danny> My digging has turned up nothing
04:27:23 <neutrino_> danny: what is collaborative filtering?
04:27:43 <neutrino_> btw, Nereid & ion: do you know of a way to set up the max amount of failures and successes when using quickcheck from test-framework?
04:28:01 <neutrino_> test-framework only accepts a Testable.
04:28:17 <neutrino_> can you make a Testable with such a limitation?
04:28:38 <danny> neutrino_: Machine learning, and matrix factorization that sort of thing
04:30:26 <neutrino_> OK
04:30:35 <neutrino_> sorry, no idea then.
04:30:43 <danny> neutrino: how long have you been doing haskell?
04:31:03 <neutrino_> danny, i've been using it on and off for a couple years now. i've started using it fulltime earlier this year.
04:31:21 * hackagebot not-gloss 0.5.0.3 - Painless 3D graphics, no affiliation with gloss  http://hackage.haskell.org/package/not-gloss-0.5.0.3 (GregHorn)
04:31:26 <neutrino_> it's for my job, but i'm still learning a lot (for example this weekend was spent figuring out quickcheck)
04:32:04 <latermuse> Thats a funny name for a package. "not-gloss"
04:32:28 <chrisbuchholz> Hey guys
04:32:30 <danny> Oh nice, i've been doing functional stuff (lisp/scheme) for about a year and a half... haskell for a month. The style feels natural but the type system is kicking my ass
04:32:34 <neutrino_> as an aside, one package vaguely related to ML i thought was interesting was this one for building regex not for strings but for lists of any type
04:32:46 <Nereid> neutrino_: I dunno, never actually used quickcheck :s
04:32:46 <Jafet> The best package name is still christmastree
04:32:50 <Jafet> @hackage ChristmasTree
04:32:51 <lambdabot> http://hackage.haskell.org/package/ChristmasTree
04:32:51 <neutrino_> the type system takes a while to figure out. i think i'm getting better at it.
04:32:59 <danny> neutrino_: what was the name of the package?
04:33:03 <neutrino_> regexdot
04:33:16 <Jafet> danny: you may end up having to make the package yourself
04:33:28 <neutrino_> i emailed the author, he thought no one would ever use it. it's actually a very cool concept imo.
04:33:38 <Jafet> This may be as simple as leaving all the real work to the C package
04:34:42 <danny> Jafet: yeah ill probably dump it all on my C++ frameworks, is the C interop good with Haskell? I've never tried
04:35:31 <Jafet> C is the only language supported by the FFI, but it is supported well
04:35:52 <kalli> Hi, I'm a beginner with a question that has been troubling me all weekend
04:36:00 <kalli> I can do something like
04:36:12 <kalli> data G = GJust Int | GList [G]
04:36:17 <danny> Ok sounds good... Most things are like that
04:36:17 <neutrino_> i wish haskell had a python ffi
04:36:20 <kalli> To define a recursive list
04:36:30 <hpc> a python ffi would be awful
04:36:38 <chrisbuchholz> i need a way to reduce a list, and my googling leads me to fold(l/r), but i dont think i can use that really. What i need is, i have this function that prints fibonacci, and i need to get the first number that has x digits in it. How should i approach this? fold doesnt seem to cut it to reduce the list, because it logically has to be a left fold because fibonacci is infinite, but you cannot left fold on an infinite list, so...
04:36:39 <kalli> And thus define it like testGList = GList [GJust 2, GList [GJust 4, GJust 1], GJust 7]
04:36:41 <hpc> plus like 90% of the time it would just be a C ffi ;)
04:36:45 <chrisbuchholz> Can somebody point me at another approach?
04:36:46 <neutrino_> hpc: how do you know i'm not in the mood for something awful?
04:36:57 <Botje> chrisbuchholz: why not head . filter ?
04:37:05 <kalli> Is there absolutely no way to be able to define it like iWantThisGList = [2,[4,1],7]
04:37:40 <Botje> kalli: nope. haskell lists are on type only.
04:37:43 <Botje> *one
04:37:56 <neutrino_> wait
04:38:04 <tomeo> kalli: why not just [[2],[4,1],[7]] ?
04:38:09 <neutrino_> wasn't there this thing to have monad comprehensions?
04:38:12 <neutrino_> not just listcomps
04:38:20 <kalli> No way to tell haskell something like iWantThisGList :: G and then give the list
04:38:21 <neutrino_> if you made G a monad you could then do it
04:38:38 <hpc> no
04:38:42 <hpc> or if you did, it'd be awful
04:38:55 <hpc> #1, G is the wrong kind right now ;0
04:38:56 <kalli> neutrino_: where can I read up on that?
04:38:57 <hpc> )
04:39:16 <neutrino_> http://hackage.haskell.org/trac/ghc/wiki/MonadComprehensions
04:39:16 <danny> "What the hell are monads anyway" is a good start
04:39:46 <osfameron> hpc: wouldnt you want to be able to call python libraries?  (even pure python ones)
04:39:58 <neutrino_> "After a long absence, monad comprehensions are back, thanks to George Giorgidze and his colleagues. With {-# LANGUAGE MonadComprehensions #-} the comprehension [ f x | x <- xs, x>4 ] is interpreted in an arbitrary monad, rather than being restricted to lists. Not only that, it also generalises nicely for parallel/zip and SQL-like comprehensions."
04:40:53 <osfameron> obviously that requires setting up a Python interpreter and various other shizzles
04:40:54 <hpc> osfameron: i don't think python libraries would want me to call them
04:41:01 <osfameron> hpc: hmmm?
04:41:03 <kalli> googline "what the hell are monads anyway" doesnt turn anything specific up, any chance to get a link?
04:41:37 <neutrino_> kalli: first make your G type a monad. make sure it works with do blocks. then just translate your do blocks to monadcomps.
04:41:41 <hpc> you shouldn't bother looking for something to learn monads specifically, imo
04:41:47 <neutrino_> yeah, don't
04:41:58 <neutrino_> just make your type a monad, that's all.
04:42:00 <hpc> read through LYAH linearly, until you get to the monad chapter
04:42:35 <kalli> Im almost up to the monad chapter in LYAH, so Ill do that, thanks
04:42:47 <neutrino_> i was reading LYAH and then stopped because it annoyed me to be spoken to as an infant
04:42:56 <hpc> heh
04:43:09 <neutrino_> here's a monad. coochee-coochee-coo!
04:43:26 <hpc> neutrino_: if it felt like you were being talked to like an infant, it was doing exactly what it was supposed to
04:43:33 <neutrino_> yeah
04:43:35 <hpc> (which is make what it teaches completely unintimidating)
04:43:36 <quchen> I'm looking for a quote I've read on some Haskell site (possibly weekly news). It's about how useless it is to memoize an O(n) algorithm, and it's something along the lines "Memoizing O(n) is like [something really useless]". Sound familiar to anyone?
04:43:48 <kalli> but you think I will be able to define G (a type representing Ints or a list of G) and write values of type G without needing a type constructor in front of every single member of the list G?
04:44:03 <neutrino_> hpc: i'm not intimidated by dry text. i'm annoyed by imposed mental retardation
04:44:17 <chrisbuchholz> Botje: yes, that seems to be better. I can work that with a finite list of fibonaccis, but i dont know how i would do that with an infinite list though. as in, my fibonacci functions just runs infinitely, so i cant filter. Any ideas?
04:44:30 <neutrino_> i'm probably the only person in the world with this issue, but it was pretty bad and i just couldn't follow up.
04:44:46 <neutrino_> so for half a year instead i resorted to hanging out here, reading random blog posts, etc
04:45:16 <neutrino_> it was slower but at least i didn't feel absolutely weirded out while doing it.
04:45:37 <chrisbuchholz> Botje: i think this answered my question: http://stackoverflow.com/questions/10936633/filtering-an-infinite-list-in-haskell
04:45:38 * osfameron didn't find LYAH as annoying as _why's annoying guide
04:45:44 <osfameron> it actually had content, for starters
04:45:59 <neutrino_> kalli: try and see. it doesn't seem like writing a Monad instance for your G type would be too difficult.
04:46:10 <neutrino_> osfameron: never read that one.
04:47:07 <neutrino_> quchen: looks like every annoying post that people make on the internet when they try to sound smart. please don't propagate it.
04:47:29 <neutrino_> so, yes, familiar, but not identifiable
04:47:36 <kalli> tiny question: are monoids and monads the same/similar thing?
04:47:39 <neutrino_> no
04:47:41 <Jafet> I think that was my quote
04:47:50 <neutrino_> kalli: very different things.
04:47:55 <Philonous> kalli:  http://hpaste.org/78709
04:47:58 <merijn> kalli: Yes, in the sense that both are just algebraic structures
04:48:06 <quchen> neutrino_: No, it wasn't like that. It was something Haskell-related and non-insulting.
04:48:20 <merijn> kalli: No, in that monads and monoids are entirely different structures and thus do different things
04:48:36 <neutrino_> quchen: do you really want to repost void generalizations?
04:48:43 <kalli> Thanks, sorry for being such a noob
04:48:48 <elliott> kalli: they are related
04:48:48 <Philonous> kalli: It's not quite what you want but the syntax is much lighter.
04:48:53 <elliott> but probably not in a way that will help you learn them
04:49:07 <kalli> Philonous: Thanks alot, this is a great step in the right direction
04:49:07 <elliott> (everyone else might be interested in http://blog.sigfpe.com/2008/11/from-monoids-to-monads.html)
04:49:20 <merijn> kalli: Personally I recommend not caring about what monads are and focussing on understanding haskell types and typeclasses. Once you get those you can just look at the monad typeclass and understand it without needing to know anything about "what" monads are, in as far as there's even such a notion
04:49:22 <neutrino_> kalli: i only learned about monoids and haskell recently.
04:49:28 <quchen> neutrino_: I don't want to repost it. It just came to my mind when someone sent me 300 lines of C++ template metaprogramming for a 3-line code just to memoize it.
04:49:51 <Philonous> kalli:  It's a bit of a hack though. It's not a proper Num instance, so don't try to add to Gs ;)
04:49:52 <Nereid> kalli: monads are monoids in a category of endofunctors. ;)
04:50:07 <merijn> Nereid: Please stop saying that line is completely unhelpful and scares newcomers
04:50:12 <neutrino_> quchen: this might apply from today: 03:35 < edwardk> type level ieee floats are a crime against nature. i had to implement them in c++ for template meta programming once. never ever again
04:50:14 <Nereid> but that's how they're related!
04:50:34 <Nereid> on another note
04:50:45 <merijn> kalli: Most of fuss about monads comes from people not understanding typeclasses and then getting hopelessly confused by the monad typeclass
04:50:47 <Nereid> for any monad m, m () is a monoid
04:50:48 <Jafet> <Jafet> This is like trying to save work in a police investigation by having each detective determine whether another detective has already removed all evidence from his area by walking through it to search for evidence in the area.
04:50:53 <Philonous> kalli:  Btw. the trick is that you can overload numeric literals, so you just need to write the injection in the case of lists.
04:50:56 <kalli> I already got the hang of algebraic data types and typeclasses, I realise why it's a bad idea to go learn advanced features without first learning the basics
04:50:57 <Jafet> That's a terrible analogy, I don't remember why I made it
04:51:03 <quchen> neutrino_: Well, it's no surprise a language that turns out later to be Turing complete has awful syntax.
04:51:04 <Nereid> > [(),()] >> [(),(),()]
04:51:05 <neutrino_> Nereid: is it? interesting
04:51:05 <lambdabot>   [(),(),(),(),(),()]
04:51:10 <latermuse> Nereoid: and bam! I understand monoids now. Thanks ;D
04:51:11 <ion> “It is inspired by gloss and attempts to emulate it.” What’s the justification for its existence then, instead of contributing to gloss?
04:51:14 <Nereid> yes, in fact an applicative will do
04:51:27 <neutrino_> that's pretty cool.
04:51:28 <ion> neutrino: Alas, i have never needed to tweak the QuickCheck parameters when using test-framework.
04:51:39 <merijn> kalli: Oh, if you understand typeclasses I would say just look at the definition of the Monad typeclass and for example the implementation of the Maybe, Either and [] instances for it
04:51:43 <neutrino_> ion: it seems almost impossible.
04:51:50 <neutrino_> ion: i see absolutely no way.
04:51:53 <Nereid> kalli: and State!
04:52:18 <chrisbuchholz> Botje: https://gist.github.com/4194846 this is what i got now. It works though i hate that the filter and takeWhile applications does almost the same thing
04:52:21 <merijn> kalli: That's much more productive for actual haskell coding than worrying about waht monads are (and also State like Nereid says, but those are all covered in LYAH, I think)
04:52:33 <Nereid> I bet someone (multiple people?) has written a "you could have invented monads"
04:52:36 <neutrino_> Nereid: there are tree monads, right?
04:52:46 <Nereid> are there?
04:52:49 <neutrino_> Nereid: i wonder what the monoid based off of that would look like
04:52:54 <neutrino_> Nereid: i don't know. are there?
04:52:56 <Nereid> oh, yes there are
04:52:59 <merijn> neutrino_: Sure, why not?
04:52:59 <neutrino_> i thought there were.
04:53:15 <neutrino_> merijn: i'm just not sure if my memory serves me right.
04:53:23 <Nereid> trees are free magmas
04:53:25 <ion> “You could have written a “you could have invented monads””
04:53:30 <Botje> chrisbuchholz: then just drop the takeWhile?
04:53:41 <merijn> neutrino_: sigfpe has a blogpost called "You Could've Invented Monads (and probably already have!)"
04:53:47 <merijn> eh
04:53:52 <Botje> chrisbuchholz: oh, you're solving *that* problem.
04:53:52 <merijn> s/neutrino_/Nereid
04:53:56 <kalli> Thanks everyone, you just convinced me to learn alot more haskell!
04:54:05 <Botje> chrisbuchholz: then why not just replace head . filter (...) with last?
04:54:08 <ion> mechairoi: alright
04:54:10 <ion> eh
04:54:13 <ion> s/mechairoi/merijn/
04:54:13 <neutrino_> merijn: on a side note, i used that category of endofunctors quote once when cornered in at an interview by a CTO who never used Haskell but was really excited to see it on my cv.
04:54:14 <kalli> But one last question about the code at http://hpaste.org/78709
04:54:18 <neutrino_> kalli: :)
04:54:29 <neutrino_> kalli: make sure to hang out here more :)
04:54:29 <kalli> Why cant I just ad an instnace decleration for List G too?
04:54:41 <Botje> chrisbuchholz: and i've got a case of the mondays. ignore me.
04:54:42 <kalli> Like with Num G
04:54:44 <Nereid> neutrino_: there's a monad for every adjunction. trees are free magmas, so Tree is a monad by the free/forgetful adjunction for magmas.
04:54:53 <Philonous> kalli:  There is no type class for lists
04:54:57 <Nereid> (assuming Tree a = Leaf a | Branch (Tree a) (Tree a)
04:55:01 <merijn> kalli: List is not a typeclass, it's a datatype
04:55:05 <Philonous> kalli:  that is, list literals aren't overloaded
04:55:10 <Botje> chrisbuchholz: how about head . filter (\x -> numLength x == 2) $ fibonacci?
04:55:13 <neutrino_> Nereid: i don't know what that meant what you just said. i read up on magmas once years ago.
04:55:14 <Nereid> Philonous: I wish they were ;)
04:55:40 <neutrino_> Nereid: i'll keep that in mind though.
04:55:58 <Nereid> neutrino_: kind of how like [] is the free monoid
04:56:14 <kalli> Ah, without judging what I dont understand very well, I think they should have defined a typeclass for lists too if only to be able to overload list literals and define your own list-y types
04:56:16 <neutrino_> Nereid: wait, so let's take a concrete example of a tree monad.. what's an example?
04:56:24 <Nereid> no, *the* Tree monad
04:56:38 <neutrino_> right
04:56:42 <neutrino_> so is Tree () a monoid?
04:56:48 <Nereid> yes
04:56:55 <merijn> kalli: There's a sequence typeclass for list-y types, I think
04:56:58 <chrisbuchholz> Botje: yes, that works. But... How? Oh! because of laziness. It only evaluates fibonacci until it has the number it is looking for, right?
04:57:02 <neutrino_> how does mappend look? can you post an example like you did with lists?
04:57:17 <Nereid> it replaces every leaf of the first tree with a copy of the second tree.
04:57:19 <merijn> kalli: Yup, Data.Sequence
04:57:23 <Nereid> I think.
04:57:24 <Botje> chrisbuchholz: yes. think of map and filter as a bucket brigade, handing around buckets one by one
04:57:28 <neutrino_> Nereid: oo.
04:57:32 <Jafet> kalli wants to overload syntax.
04:57:36 <neutrino_> that makes sense.
04:57:36 <merijn> kalli: Oh wait, not a typeclass I'm not paying attention
04:57:41 <chrisbuchholz> Botje: yeah, well, thank you for your help!
04:57:48 <Nereid> exercise: write a Monad instance for Tree, I guess
04:57:51 <Jafet> There are a few ways to do this if you really really want to. Template Haskell is one
04:57:59 <Nereid> return = Leaf, obviously
04:58:00 <Botje> chrisbuchholz: the only thing to watch out for with infinite lists is taking the length or printing them :)
04:58:03 <merijn> kalli: In general it's not really that useful to have "list-like" type, though
04:58:09 <Nereid> and then to me it would be easier to write join than (>>=)
04:58:15 <merijn> kalli: Most of the things you'd want to do are covered by other classes
04:58:15 <Nereid> join :: Tree (Tree a) -> Tree a
04:58:19 <ion> botje: What does the bucket brigade do in fibs = 0 : 1 : zipWith (+) fibs (tail fibs)?
04:58:27 <kalli> Jafet: that might be what Im trying to do, I'm an old lisper and kind of just think that way. Maybe that is my error and I shouldnt be trying to write lisp in haskell
04:58:39 <merijn> kalli: Like Functor, Foldable and Traversable (which provide fmap, fold and traverse respectively)
04:58:42 <Nereid> you have a tree whose leaves are trees, so replace each leaf with the corresponding tree.
04:58:46 <Philonous> kalli:  You can do worse than write lisp is haskell.
04:58:49 <Philonous> in*
04:58:52 <neutrino_> Nereid: hmm ok
04:59:08 <Botje> ion: i'm pretty sure it's time travel ;)
04:59:08 <ion> botje: Does one guy spill the halves of each incoming bucket to two outgoing buckets?
04:59:21 <neutrino_> Nereid: that's pretty cool.
04:59:48 <Jafet> Yes, you can do worse, like json
04:59:59 <neutrino_> Nereid: is m x a monoid for any x other than () ?
05:00:05 <Jafet> There might be some silly startup developer who has made embedded syntax for json or something
05:00:11 <Nereid> neutrino_: how would you write mempty?
05:00:12 <Jafet> You can search for that
05:00:17 <chrisbuchholz> Botje: yeah i see :) can you comment on the way i do this solution? It cant be a very efficient way of doing it. It runs so slow, i doubt it will every compute the first number with a thousand digits
05:00:26 <Nereid> I think m a is a monoid if a is a monoid and m is commutative?
05:00:40 <Nereid> maybe? I don't konw.
05:00:48 <jmcarthur> is this for a specific m?
05:00:51 <Nereid> any m
05:00:55 <Nereid> Monad
05:01:01 <jmcarthur> Alternative and MonadPlus exist for this
05:01:11 <Nereid> sure, for specific m you can say more.
05:01:27 <jmcarthur> for any m, the parameter must be a monoid
05:01:29 <Zetetic> Is there a significant advantage to using Yi over GNU-Emacs for Haskell work?
05:01:35 <jmcarthur> for some m, it doesn't matter what the parameter is
05:01:55 <jmcarthur> Zetetic: i don't know of any
05:01:58 <Nereid> neutrino_: but the resulting monoid structure may differer from what you get with m ()
05:02:01 <Philonous> Zetetic:  Probably not at the moment unless you want to hack on it
05:02:02 <Nereid> differ.
05:02:08 <neutrino_> Nereid: interesting.
05:02:16 <neutrino_> what is an example when it differs?
05:02:18 <Zetetic> I'll stick with what I know for now then, thanks jmcarthur and Philonous
05:02:20 <Nereid> I don't know.
05:02:30 <Nereid> mostly because I don't know what monoid operations you'd get for m a
05:02:31 <Botje> chrisbuchholz: well, you're recomputing every fib as you go. that's indeed quite punishing.
05:02:48 <jmcarthur> neutrino_:   mempty = pure mempty; mappend = liftA2 mappend   is different from   mempty = return (); mappend = (>>)
05:02:51 <Nereid> return mempty and liftM2 mappend, probably.
05:02:53 <neutrino_> let's look at [String] (that's a monoid, right?)
05:02:54 <Nereid> but yeah.
05:02:56 <Botje> chrisbuchholz: there's a much faster means of generating an infinite list of fibonaccis
05:03:09 <Nereid> jmcarthur: is it though?
05:03:27 <Nereid> > liftM2 mappend [(),()] [(),(),()]
05:03:29 <Botje> chrisbuchholz: you just have an f a b = a + b : f b (a + b) and feed it two starting parameters
05:03:32 <lambdabot>   [(),(),(),(),(),()]
05:03:47 <Nereid> > [(),()] >> [(),(),()]
05:03:49 <lambdabot>   [(),(),(),(),(),()]
05:03:57 <jmcarthur> Nereid: yeah, at least in general. for specific cases they are the same, such as for the Trivial monad...
05:04:15 <jmcarthur> hmm
05:04:20 <jmcarthur> i could be wrong, actually :)
05:04:29 <Nereid> I think what goes wrong is you might fail to get associativity.
05:04:31 <chrisbuchholz> Botje: all right, will look into that, thanks
05:04:34 <Nereid> unless something is commutative
05:04:51 <Nereid> > liftM2 mappend [1,2] [3,4,5]
05:04:53 <lambdabot>   Ambiguous type variable `r0' in the constraints:
05:04:53 <lambdabot>    (GHC.Num.Num r0)
05:04:53 <lambdabot>      a...
05:04:56 <jmcarthur> they should both be associative...
05:04:59 <Nereid> uh
05:05:07 <Nereid> doh
05:05:16 <Nereid> > liftM2 mappend ["a","b"] ["c","d"]
05:05:18 <lambdabot>   ["ac","ad","bc","bd"]
05:05:19 <Nereid> > ["a","b"] >> ["c","d"]
05:05:21 <lambdabot>   ["c","d","c","d"]
05:05:24 <Botje> chrisbuchholz: try to estimate the time complexity of tree-recursive fibonacci sometime, the answer is kind of cool
05:05:26 <Nereid> er uh
05:05:34 <Nereid> I don't know what the point of that was.
05:05:45 <Nereid> oh wait
05:05:46 <Nereid> associativity.
05:06:03 <jmcarthur> Nereid: i now think you are right and the two instances are the same when the type parameter is ()
05:06:13 <Nereid> > let f = liftM2 mappend; x = ["a","b"]; y = ["c","d"]; z = ["e","f"] in (f x (f y z), f (f x y) z)
05:06:15 <lambdabot>   (["ace","acf","ade","adf","bce","bcf","bde","bdf"],["ace","acf","ade","adf"...
05:06:22 <Nereid> hmm, looks the same.
05:06:27 <jmcarthur> the laws of monad and monoid guarantee it
05:06:32 <Nereid> well yes.
05:06:40 <jmcarthur> i mean even when composed this way
05:07:03 <Nereid> I'm not convinced that liftM2 mappend is necessarily associative. I'd have to pull out some paper.
05:07:05 <jmcarthur> it's a good exercise to explore why. i enjoyed doing it
05:07:16 <jmcarthur> anyway, g2g
05:08:10 <chrisbuchholz> Botje: i will remember to do that ;)
05:08:48 <Nereid> > liftA2 (,) [1,2] [3,4]
05:08:50 <lambdabot>   [(1,3),(1,4),(2,3),(2,4)]
05:08:51 <Nereid> > liftA2 (,) [3,4] [1,2]
05:08:52 <lambdabot>   [(3,1),(3,2),(4,1),(4,2)]
05:08:55 <Nereid> er oops
05:08:58 <Nereid> > liftA2  (flip (,)) [3,4] [1,2]
05:09:00 <lambdabot>   [(1,3),(2,3),(1,4),(2,4)]
05:09:49 <hpc> that's not associativity
05:09:55 <Nereid> I know.
05:10:02 <latermuse> hpc: why isnt it?
05:10:09 <Nereid> it's (non-)commutativitiy
05:10:16 <hpc> (a + b) + c == a + (b + c)
05:10:48 <neutrino_> 1 sec
05:12:00 <neutrino_> that was thoroughly entertaining. saving this log.
05:12:42 <neutrino_> "monads degenerate to monoids.txt"
05:14:07 <Nereid> ah wait.
05:14:16 <Nereid> yeah, liftM2 mappend is associative.
05:14:20 <Nereid> ok :)
05:14:28 <latermuse> I know that its easy to get multi-threaded stuff working in haskell. Is it equally simple to throw more computers at a single haskell program to get better performance?
05:14:28 <latermuse> like a server array
05:14:42 <Nereid> latermuse: you may be interested in Cloud Haskell?
05:14:47 <neutrino_> cloud haskell
05:14:55 <Philonous> latermuse:  No. It's a lot harder.
05:15:10 <DMcGill> The haddocks of SFML are hosted at [1] but as it's not on hackage I can't use hoogle or hayoo. How can I search them?
05:15:12 <DMcGill> [1]: http://shellblade.net/docs/SFML/index.html
05:15:15 <latermuse> A lot harder, but possible. Thats good enough for me.
05:15:22 <hpc> latermuse: i understand erlang makes that kind of scaling easy?
05:15:30 <latermuse> Haskell is job security.
05:15:41 <neutrino_> erlang isn't?
05:15:46 <hpc> haha
05:16:05 <Jafet> Multithreading usually implies shared memory instead of message passing
05:16:08 <Nereid> DMcGill: I imagine you could run a local hoogle instance for that
05:16:16 <Jafet> A cluster usually implies message passing
05:16:22 * hackagebot cr 1.2 - Code review tool  http://hackage.haskell.org/package/cr-1.2 (AlexandruScvortov)
05:17:29 <neutrino> DMcGill: install the hoogle package and the package you want to search. generate the hoogle cache, i forgot how. then the "hoogle" command can search the package.
05:17:37 <Nereid> neutrino_: so yes, for any Applicative m and Monoid a, m a is a monoid under pure mempty and liftA2 mappend.
05:17:46 <Nereid> in particular, () is a monoid, so m () is a monoid.
05:18:13 <neutrino> Nereid: will they have the same structure for any a?
05:18:20 <Jafet> @instances Monoid
05:18:21 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, First a, Last a, Maybe a, Ordering, Product a, Sum a, [a]
05:18:25 <Nereid> what do you mean?
05:18:49 <neutrino> can you take the same monad, plug in different types, and get monoids which are not isomorphic?
05:19:04 <Nereid> why would you expect them to be isomorphic?
05:19:16 <neutrino> i don't know.
05:19:30 <Nereid> unless the given monoids were isomorphic.
05:20:20 <Nereid> also I bet a monoid morphism a -> b extends to a monoid morphism m a -> m b. that's another thing to check, I guess.
05:20:20 <neutrino> i guess then m String =~ m [Int] ?
05:20:32 <neutrino> i believe [Int] and String are isomorphic, right?
05:20:37 <Nereid> they are?
05:20:45 <neutrino> i'm not sure.
05:20:55 <Nereid> what would the isomorphism be?
05:21:03 <neutrino> what would make them different? the mappend works the same, right?
05:21:23 <Nereid> I don't see how you can compare them.
05:21:35 <hpc> neutrino: sum a String
05:21:36 <Nereid> in any case "isomorphic" isn't the right term
05:21:38 <Jafet> Nereid: probably means fmap (const ())
05:21:51 <DMcGill> [a] =~ [b] if a =~ b
05:21:53 <hpc> neutrino: Int isn't a well-defined type, on its own
05:22:07 <DMcGill> it doesn't apply for all monads though
05:22:10 <DMcGill> see: the zero monad
05:22:10 <hpc> you have to decide what CPU architecture you are on, what compiler you are using, etc
05:22:16 <neutrino> Nereid: a monoid is a set with a single empty element and a single operation called mappend.
05:22:25 <hpc> Int could be 30 bits, which would be smaller than String
05:22:33 <neutrino> i am guessing [a] is isomorphic to [b] for any a and b.
05:22:43 <hpc> or 32 bits, (same size but still not entirely comparable)
05:22:43 <Nereid> neutrino: no...
05:22:45 <hpc> or 64 bits
05:22:51 <neutrino> Nereid: why not?
05:22:59 <Nereid> write me an isomorphism
05:23:25 <neutrino> iso = map ord :: String -> [Int]
05:23:38 <Nereid> ord and chr do not make an isomorphism
05:23:55 <DMcGill> neutrino: [a] and [b] are isomorphic only if a and b are
05:23:56 <ramses_> > chr (-1)
05:23:58 <neutrino> right, because Int has more values than Char?
05:23:58 <lambdabot>   *Exception: Prelude.chr: bad argument: (-1)
05:24:01 <Nereid> yes
05:24:05 <neutrino> ok
05:24:29 <neutrino> following from that, what differences in structure will m String and m [Int] have?
05:24:37 <Nereid> DMcGill: I wouldn't say "only". what if there's some strange isomorphism that isn't map of something?
05:24:47 <Jafet> The question is probably whether fmap (const ()) `on` mappend is isomorphic for all types
05:24:56 <Nereid> neutrino: at least as much as String and [Int] would
05:25:11 <Nereid> (take m = Identity)
05:25:27 <Nereid> Jafet: I don't know what that means.
05:26:20 <ramses_> Nereid: an isomorphism is always bijective, so the sets of values of two isomorphic types need to have the same cardinality
05:26:30 <Jafet> Because it's wrong
05:26:42 <Nereid> ramses_: you don't need to tell me that ;)
05:26:55 <neutrino> yeah, i kind of forgot that little detail.
05:26:57 <Jafet> fmap (const ()) .: mappend
05:27:11 <ramses_> ah ok, but that makes it immediately clear that String and [Int] can't be isomoprhic, doesn't it?
05:27:25 <Nereid> ramses_: no it doesn't
05:27:29 <Nereid> they both have countably infinitely many values
05:27:44 <Jafet> Uncountably
05:28:11 <neutrino> i'm with Jafet
05:28:13 <Nereid> well, not computably countably. but that doesn't change anything.
05:28:18 <hpc> an isomorphism is a bijective homomorphism
05:28:28 <Nereid> an isomorphism is an invertible homomorphism.
05:28:35 <neutrino> an isomorphism is two homomorphisms.
05:28:39 <hpc> https://en.wikipedia.org/wiki/Homomorphism
05:28:50 <Nereid> neutrino: they have to be related somehow.
05:28:51 <hpc> er yes, that
05:28:58 <neutrino> Nereid: yeah.
05:29:12 <Nereid> anyway, there is no reason to believe [a] and [b] should be isomorphic for any a and b.
05:29:14 <hpc> anyhoo, this equation needs to hold: https://upload.wikimedia.org/math/4/3/a/43a443672b30f8a394531e4c78af6b51.png
05:29:15 <neutrino> but everyone knows how.
05:29:19 <neutrino> Nereid: alright
05:29:21 <Nereid> becuase it's false - take a = Void and b = any inhabited type.
05:30:33 <Nereid> oh, yes, if [a] and [b] are isomorphic monoids, then a and b are isomorphic.
05:30:39 <Nereid> because you can look at the indecomposable elements of [a] and [b].
05:30:49 <Nereid> which are precisely the elements of a and b.
05:31:11 <Nereid> irreducible?
05:31:21 <Nereid> let's say irreducible.
05:32:22 <neutrino> right
05:32:32 <Nereid> hpc: I would be careful about saying that an isomorphism is a bijective homomorphism, because there are concrete categories for which that is simply false.
05:32:40 <Nereid> (e.g. the cat of topological spaces)
05:32:46 <hpc> yeah i took that from wikipedia
05:33:19 <hpc> i was just following "this entails this" until i could get to an equation that wasn't satisfied
05:33:20 <neutrino> this is very interesting
05:33:23 <Nereid> my guess is that it's true in Hask, though?
05:33:57 <Nereid> well I don't know what it would mean to be true.
05:34:07 <Nereid> one would want inverses to be computable, for one.
05:34:22 <Jafet> :t iso
05:34:23 <lambdabot> (Functor f, Isomorphic k) => (s -> a) -> (a -> s) -> k (a -> f a) (s -> f s)
05:36:46 <neutrino> quickcheck has really made my test suite very very slow.
05:36:51 <neutrino> 5 minutes for this one property.
05:39:03 <Nereid> I should probably stop talking about haskell and actually write some useful code at some point.
05:39:22 <merijn> Nereid: Story of my life
05:39:33 <arcatan> :)
05:39:35 <neutrino> i just decided to do it, and here i am.
05:39:39 <latermuse> :D
05:39:44 <neutrino> writing a nice little dev tool.
05:39:59 <neutrino> and even getting paid some meager money for it.
05:40:01 <latermuse> I always have #haskell open while Im working in other windows. tiled wm ftw
05:40:30 <Nereid> @localtime
05:40:31 <lambdabot> Local time for Nereid is Mon Dec 3 05:40:13 2012
05:40:37 <Nereid> :(
05:40:39 <latermuse> youre up early
05:40:42 <Nereid> you mean late
05:40:46 <latermuse> semantics
05:40:50 <neutrino> i was up real late yesterday :|
05:40:55 <neutrino> today == sucks.
05:40:55 <Nereid> @localtime neutrino
05:40:58 <lambdabot> Local time for neutrino is Mon Dec  3 14:39:53 2012
05:41:15 <latermuse> just wake up, neutrino?
05:41:24 <Nereid> germany?
05:42:31 <neutrino> no, i had to wake up at 10, walk down to the local pizzeria, and print out their list of daily dishes
05:42:44 <neutrino> went to sleep around 6.
05:43:04 <Nereid> oh great, I have to be up in less than 5 hours. time to go !
05:43:07 <neutrino> Nereid: yeah, i moved here some time ago.
05:43:19 <latermuse> goodnight nereid
05:43:23 <Nereid> :)
05:43:31 <neutrino> it's funny, i started picking up haskell around the same time i started picking up german, and i'd say i'm about just as fluent in both.
05:43:34 <neutrino> nn Nereid
05:44:27 <`nand`> BMeph: what if the computer is running an AI that's controlling a robot that's tossing the caber the computer is nailed to? Self-caber-tossing?
05:44:55 <latermuse> `nand`: <mind blown>
05:45:09 <neutrino> what's a caber?
05:45:12 <`nand`> latermuse: once it lands, probably literally
05:45:21 <latermuse> neutrino: like a stick
05:45:26 <`nand`> neutrino: a large wooden pole
05:45:33 <`nand`> https://upload.wikimedia.org/wikipedia/commons/4/4c/Caber_2.jpg for reference
05:45:48 <neutrino> why would the AI toss its own stick?
05:45:55 <neutrino> other than the pornographic nature of this statement.
05:46:02 <latermuse> XD
05:46:04 <DMcGill> is there a better typeclass to use when converting between Double-like types than "fromRational . toRational"?
05:46:24 * hackagebot alpha 1.0.1 - A compiler for the Alpha language  http://hackage.haskell.org/package/alpha-1.0.1 (MarcCoiffier)
05:46:33 <neutrino> DMcGill: fromDouble, i think?
05:46:57 <neutrino> *think*
05:47:01 <DMcGill> doesn't exist I'm afraid
05:47:25 <`nand`> :t realToFrac
05:47:26 <lambdabot> (Fractional b, Real a) => a -> b
05:47:30 <DMcGill> great, thanks
05:48:16 <DMcGill> I mean it literally is 'fromRational . toRational' but that's what I was looking for ;)
05:48:47 <neutrino> :)
05:53:27 <ippo> i was looking to the page on memoization on the haskell wiki
05:53:48 <ippo> and it seems pretty obvious if your recursive function always calls itself with a lower argument
05:54:11 <ippo> now, let's suppose that at some point your function calls itself with a new argument m such as m > n
05:54:30 <ippo> (very specifically, i'm talking about a function to compute collatz sequences)
05:54:39 <ippo> how can I memoize these results?
05:55:17 <ippo> oh
05:55:18 <ippo> wait
05:55:21 <ippo> I'm an idiot
05:55:38 <ippo> I gave up too early... the haskell wiki gives exactly this example under another name
05:55:45 <ippo> sorry everyone, my bad ^^'
05:58:04 <neutrino> i've had some problems figuring out memoization recently ippo
05:58:08 <neutrino> i was looking at that same page
05:58:14 <neutrino> maybe it's not the best written page in the world
05:58:58 <ippo> well maybe not that
05:59:06 <ippo> but I stopped reading too early
05:59:25 <ippo> also it doesn't call the collatz function by its name, so I didn't see it when first scrolling through :)
06:04:54 <neutrino> never heard of the collatz function
06:06:41 <ToranLipse> What would be the best channel to join to ask questions about Turing Machines?
06:07:45 <Jeanne-Kamikaze> #computing ?
06:07:58 <Jeanne-Kamikaze> hah, it's just you and I there
06:08:05 <ToranLipse> lol
06:08:15 <Jeanne-Kamikaze> maybe just hit stack overflow ?
06:08:27 <ToranLipse> Ok thanks =)
06:08:28 <Jafet> Ask every channel non-deterministically
06:08:35 <Jeanne-Kamikaze> also try #java for the shits and giggles
06:09:28 <Jafet> Machine.TuringComplete.TuringMachineFactory.UniversalTuringMachineFactory.makeTuringMachine(Machine.TuringComplete.TuringMachine....)
06:09:38 <latermuse> Jeanne-Kamikaze: #php might be more fun
06:09:53 <Jeanne-Kamikaze> chmod 777 turing-machine/
06:10:32 <ion> -R
06:10:51 <Jeanne-Kamikaze> true
06:11:14 <Jeanne-Kamikaze> guess I need a php refresher :)
06:11:27 <zhulikas> https://github.com/dmbarbour/Sirea
06:11:30 <zhulikas> looks promissing
06:11:37 <zhulikas> promising*
06:13:29 <DMcGill> I'm sure #math won't mind ;)
06:14:32 <neutrino> Jeanne-Kamikaze: why not ask here?
06:15:17 <Jafet> Because I think turing machines are the ugliest formal model of computation ever
06:18:05 <osfameron> also the first
06:18:24 <companion_cube> lambda calculus existed before
06:18:47 <Jafet> Analytical engine
06:19:19 <osfameron> was the analytical engine a formal model?  wasn't it just a working (ish) model? ;-)
06:19:42 <osfameron> and was lambda calculus considered to be about computation that early?
06:19:58 <Jafet> It was never built
06:20:02 <Jafet> Isn't that all it takes?
06:22:28 <Philippa> Jafet: TMs are specialised for a purpose. Once you understand that, they're elegant - just not the thing you want to use
06:26:23 <DMcGill> is there a modulus for non-integral types?
06:26:54 <simon> is there any way to make happy use LR(2)?
06:27:31 <DMcGill> wait, I mean modulo
06:27:48 <typoclass> Philippa: plz to not confoose me with things like "usefulness" while i'm swooning over some intangible alleged "elegance"
06:27:49 <typoclass> ;-)
06:28:32 <simon> (or rather, LALR(2). I want to increase the look-ahead.)
06:29:35 <artiq> How do you add two lists element wise and return a list? [1, 2, 3] [2, 4, 5] = [3, 6, 8]
06:29:46 <DMcGill> artiq: zipWith (+)
06:29:47 <byorgey> artiq: zipWith (+)
06:29:54 <artiq> Thanks!
06:29:55 <DMcGill> > zipWith (+) [1,2,3] [4,5,6]
06:29:57 <lambdabot>   [5,7,9]
06:31:06 <byorgey> DMcGill: what do you mean by 'modulo for non-integral types'?
06:31:25 * hackagebot yesod-pnotify 0.1.0.0 - Yet another getMessage/setMessage using pnotify jquery plugins  http://hackage.haskell.org/package/yesod-pnotify-0.1.0.0 (KatsutoshiItoh)
06:31:30 <DMcGill> I looked around and found it: I mean Data.Fixed.mod'
06:31:34 <DMcGill> :t Data.Fixed.mod'
06:31:36 <lambdabot> Real a => a -> a -> a
06:34:29 <timemage> DMcGill, seems to do flooring modulo.  you're expected that though, yeah?
06:35:05 <DMcGill> > Data.Fixed.mod' 1.5 1
06:35:06 <lambdabot>   0.5
06:35:16 <DMcGill> that's the behaviour I want
06:35:37 <DMcGill> I don't really care about negative numbers in this case
06:35:51 <timemage> DMcGill, ok.  that's what i was checking.
06:35:55 <DMcGill> thanks
06:37:03 <nart> hi
06:38:18 <Taneb> Hey
06:43:36 <zhulikas> > Data.Fixed.mod' (-3.2) (-3)
06:43:37 <lambdabot>   -0.20000000000000018
06:44:21 <Taneb> A Haskell-y equivalent of a LAMP software bundle could be Linux, Yesod, Acid-State, Haskell
06:44:23 <Taneb> LYAH
06:44:39 <typoclass> Taneb: omb
06:44:45 <typoclass> erm, omg :-)
06:44:59 <Taneb> :)
06:45:33 <Taneb> Of course, I have no idea how hard it is to use acid-state in Yesod
06:51:59 <merijn> Taneb: Pretty easy, but using Yesod is less so :p
06:52:06 <Taneb> Heh
06:56:14 <peteriserins> in a list monad, say, how to return multiple values from a do?
06:56:33 <Taneb> > do {x <- [1,2,3]; return x
06:56:34 <lambdabot>   <hint>:1:27: parse error (possibly incorrect indentation)
06:56:35 <Taneb> > do {x <- [1,2,3]; return x}
06:56:36 <lambdabot>   [1,2,3]
06:56:49 <peteriserins> return x `plus` return y?
06:56:52 <peteriserins> *mplus
06:57:13 <Taneb> > do {x <- [1,2,3], return x ++ return y}
06:57:15 <lambdabot>   <hint>:1:17: parse error on input `,'
06:57:20 <Taneb> > do {x <- [1,2,3]; return x ++ return y}
06:57:22 <lambdabot>   [1,y,2,y,3,y]
06:57:24 <peteriserins> what's the most general way?
06:57:33 <Taneb> > do {x <- [1,2,3]; return x ++ return 1}
06:57:35 <lambdabot>   [1,1,2,1,3,1]
06:57:53 <Taneb> Depends precisely how you want the multiple possibilities to end up
06:57:54 <peteriserins> ok so that's just mplus
06:57:58 <peteriserins> cool
06:58:35 <Taneb> I'd use (<|>) or mplus if you want generality
06:58:41 <Taneb> (++) is fine for just lists
06:59:04 <peteriserins> but then you would say [x] ++ [1] anyways right
06:59:06 <peteriserins> or just end it with [x, 1]
06:59:19 <peteriserins> I'm wondering what is conventional
06:59:26 <Taneb> Depends what you want
06:59:33 <Taneb> The list monad models non-determinism
06:59:46 <Taneb> So you can make more possibilities, like...
06:59:57 <Taneb> > do {x <- [1,2,3]; return x}
06:59:58 <lambdabot>   [1,2,3]
07:00:03 * osfameron doesn't really get how it does non-determinism
07:00:07 <Taneb> Which says "x can be one, two, or three"
07:00:11 <Taneb> And you can filter those
07:00:13 <osfameron> it's more like a cartesian join in SQL
07:00:29 <Taneb> > do {x <- [1,2,3]; guard (x == 2); return x}
07:00:31 <lambdabot>   [2]
07:00:42 <peteriserins> Taneb: oh sorry, actually I wanted something different
07:00:54 <peteriserins> Taneb: I wanted [1, 2, 3, 4] not [1, 2, 1, 3, 1, 4]
07:01:00 <peteriserins> Taneb: if that makes sense
07:01:05 <Taneb> What are you starting with?
07:01:11 <osfameron> Taneb: see,that's just SELECT x FROM [1,2,3] WHERE x = 2 ;-)
07:01:31 <Taneb> osfameron, I don't really know SQL
07:02:03 <peteriserins> Taneb: I'm writing [1, 2] ->   [([], [1,2]), ([1], [2]), ([1, 2], [])]
07:02:22 <Taneb> do {x <- [1,2,3]; y <- [4,5,6]; return $ x + y} -- osfameron
07:02:32 <Taneb> :t splitAt
07:02:33 <lambdabot> Int -> [a] -> ([a], [a])
07:02:38 <Taneb> > do {x <- [1,2,3]; y <- [4,5,6]; return $ x + y} -- osfameron
07:02:39 <lambdabot>   [5,6,7,6,7,8,7,8,9]
07:02:48 <ion> > liftA2 (+) [1,2,3] [4,5,6]
07:02:50 <lambdabot>   [5,6,7,6,7,8,7,8,9]
07:03:14 <osfameron> Taneb: sure, that's the same as: select x + y from [1,2,3] x join [4,5,6] y
07:03:23 <osfameron> (except you don't have literal table syntax in SQL)
07:03:30 <Taneb> So, SQL does non-determinism
07:03:35 <osfameron> I just don't understand why that's non-determinism
07:04:00 <Taneb> Because each element of the final result is a different result-y thing
07:04:21 <Taneb> Selecting from the table, the final result can be based on one of those
07:04:32 <Taneb> It gives you all the possibilities
07:04:45 <osfameron> yes
07:04:49 <Taneb> > liftA2 (+) [1..6] [1..6]
07:04:50 <lambdabot>   [2,3,4,5,6,7,3,4,5,6,7,8,4,5,6,7,8,9,5,6,7,8,9,10,6,7,8,9,10,11,7,8,9,10,11...
07:04:55 <peteriserins> splits (x : xs) = ([], x : xs) : do { (u, v) <- splits xs; return (x : u, v) }
07:05:02 <Taneb> That's all the possibilites for rolling two dice
07:05:16 <Taneb> peteriserins, sorry, I've rather got distracted from your problem
07:05:23 <Taneb> I don't think the list monad is the answer for that
07:05:29 <ion> If you think of the [1,2,3] as the possible results from a three-sided die and the [4,5,6] as the possible results from another three-sided die, the cartesian product of them is the set of possible rolls of both. Applying (+) to each is the set of possible sums when rolling both.
07:05:37 <peteriserins> Taneb: well but that's the solution right there
07:05:46 <peteriserins> Taneb: I was hoping it would all be one do statement
07:05:47 <Taneb> Oh, fair enough
07:06:12 <peteriserins> Taneb: well a solution together with splits [] = [([], [])]
07:06:49 <Taneb> :t let splits (x : xs) = ([], x : xs) : first (x :) (splits xs) in splits
07:06:50 <lambdabot>     Couldn't match expected type `[([a0], [a1])]'
07:06:51 <lambdabot>                 with actual type `(c0, d0)'
07:06:51 <lambdabot>     In the return type of a call of `first'
07:07:06 <Taneb> :t let splits (x : xs) = ([], x : xs) : map (first (x :)) (splits xs) in splits
07:07:08 <lambdabot> [a] -> [([a], [a])]
07:07:16 <Taneb> > let splits (x : xs) = ([], x : xs) : map (first (x :)) (splits xs) in splits [1..4]
07:07:18 <lambdabot>   [([],[1,2,3,4]),([1],[2,3,4]),([1,2],[3,4]),([1,2,3],[4])*Exception: <inter...
07:07:40 <Taneb> > let splits (x : xs) = ([], x : xs) : map (first (x :)) (splits xs); splits [] = [] in splits [1..4]
07:07:41 <lambdabot>   [([],[1,2,3,4]),([1],[2,3,4]),([1,2],[3,4]),([1,2,3],[4])]
07:08:24 <Jafet> :t liftA2 (zipWith (,)) inits tails
07:08:25 <lambdabot> [a] -> [([a], [a])]
07:08:41 <osfameron> there's a way of using <$> ... <*> with 3+ parameters isnt' there?
07:09:02 <Jafet> > (,,,) [] [] []
07:09:04 <lambdabot>   *Exception: show: No overloading for function
07:09:12 <Taneb> You mean f <$> x <*> y <*> z?
07:09:13 <Jafet> > (,,,) <$> [] <*> [] <*> []
07:09:14 <lambdabot>   *Exception: showList: No overloading for function
07:09:19 <osfameron> > let dice = [1..6] in (+) <$> dice <*> dice
07:09:21 <lambdabot>   [2,3,4,5,6,7,3,4,5,6,7,8,4,5,6,7,8,9,5,6,7,8,9,10,6,7,8,9,10,11,7,8,9,10,11...
07:09:22 <Jafet> > (,,) <$> [] <*> [] <*> []
07:09:24 <lambdabot>   []
07:09:26 <osfameron> > let dice = [1..6] in (+) <$> dice <*> dice <*> dice
07:09:28 <lambdabot>   Could not deduce (GHC.Enum.Enum (a0 -> b))
07:09:28 <lambdabot>    arising from the ambiguity ch...
07:09:36 <ion> @src liftA3
07:09:36 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
07:09:38 <osfameron> what shold I use instead in that second case?
07:09:47 <Taneb> > let d = [1..6] in liftM4 (+) d d d d
07:09:49 <lambdabot>   Could not deduce (GHC.Enum.Enum (a30 -> a40 -> r))
07:09:49 <lambdabot>    arising from the ambi...
07:09:55 <Taneb> > let d = [1..6] in liftM4 (+) d d d d :: [Int]
07:09:56 <lambdabot>   No instance for (GHC.Enum.Enum (a30 -> a40 -> GHC.Types.Int))
07:09:56 <lambdabot>    arising fr...
07:10:03 <Taneb> > let d = [1..6] in liftM3 (+) d d d d :: [Int]
07:10:05 <BMeph> > let splits xs = zip (inits xs) (tails xs) in splits [1,2,3]
07:10:05 <lambdabot>   Couldn't match expected type `t0 -> a30 -> [GHC.Types.Int]'
07:10:05 <lambdabot>              wi...
07:10:06 <lambdabot>   [([],[1,2,3]),([1],[2,3]),([1,2],[3]),([1,2,3],[])]
07:10:07 <osfameron> liftM\d is utterly fugly
07:10:09 <Jafet> :t (+)
07:10:10 <lambdabot> Num a => a -> a -> a
07:10:12 <osfameron> it's horribly boilerplate
07:10:23 <ion> osfameron: liftA3 (\a b c -> a + b + c)
07:10:38 <osfameron> liftA\d also (fugly)
07:10:52 <ion> I don’t see how it’s ugly.
07:11:05 <osfameron> you're specialising on the number of parameters
07:11:12 <osfameron> what if you want to handle different numbers of parameters?
07:11:15 <BMeph> peteriserins: Better? (provided you caught that....)
07:11:15 <Taneb> > let splits = zip <$> inits <*> tails in splits [1..4]
07:11:16 <lambdabot>   [([],[1,2,3,4]),([1],[2,3,4]),([1,2],[3,4]),([1,2,3],[4]),([1,2,3,4],[])]
07:11:19 <osfameron> and it just makes my flesh crawl
07:11:42 <peteriserins> BMeph: didn't know about inits & tails
07:11:43 <osfameron> e.g., if you want to roll an arbitrary number of dice, what do you do?
07:12:28 <BMeph> peteriserins: Right, and Taneb gave you a nice golf-y version for it. ;)
07:12:31 <ion> osfameron: (map sum . replicateM 3) [1..6]
07:12:53 <osfameron> ion: ta
07:12:58 <osfameron> so was I dreaming something with <*> ?
07:13:05 <osfameron> bah, I will play with it another time
07:13:11 <ion> osfameron: liftA2 et al. are fine, their use case is simply something other than “arbitrary number of parameters”.
07:13:14 <peteriserins> how about permutations now?
07:13:23 <Taneb> :t permutations
07:13:25 <lambdabot> [a] -> [[a]]
07:13:26 <peteriserins> I was writing splits to use in generating perms
07:13:29 <Taneb> Already exists
07:13:49 <ion> However, liftM* are an abomination. ;-)
07:14:07 <osfameron> ion: fair enough, it might be my background in languages with varargs that makes me think it's so weird...
07:14:10 <peteriserins> Taneb: right, but I'm just looking for a nice implementation
07:15:08 <peteriserins> Taneb: just mapping over splits pretty much
07:16:17 <ion> osfameron: varargs implies either that all the args have the same type or that there’s dynamic typing involved (which is arguably the same thing). That doesn’t fit the likes of liftA* very well.
07:17:35 <osfameron> ion: yeah, I understand why you can't have a single liftA
07:17:55 <osfameron> ion: I guess I find the replicateM workaround nicer though
07:18:06 <ion> > sequence [[1..3],[1..3],[1..3]]  -- “varargs” with everything having the same type
07:18:06 <lambdabot>   mueval: recoverEncode: invalid argument (invalid character)
07:18:24 <ion> osfameron: I suppose you could with type classes, but i don’t think that’s a better solution. Also, the replicateM code isn’t a “workaround”/
07:18:35 <peteriserins> Taneb: perm (x : xs) = map (\(u, v) -> u ++ (x : v)) (join [splits l | l <- (perm xs)]) this sort of thing
07:21:01 <osfameron> ion: "variant" better?
07:31:54 <weissi> I'm having a weird problem with cabal: If I configure/build with --enable-executable-profiling --enable-library-profiling cabal does two strange things: It does not compile with -prof and is does not use the options provided in GHC-Prof-Options. Any ideas? (cabal-install version 1.16.0.2; using version 1.16.0 of the Cabal library)
07:39:29 <adkron> glguy: You here?
07:40:55 <adkron> So I want to start learning Haskell. I would like to start with TDD/BDD. I pulled down HSpec and I have a cabal project that is able to run the specs.
07:41:17 <chandra> hello
07:41:22 <latermuse> chandra: hi
07:41:30 <adkron> I'd now like to start writing tests for starting a server listener on a default port. I'm not sure how to start that.
07:41:31 <latermuse> adkron: what is tdd/bdd?
07:41:40 <ion> Test/Behavior Driven Development
07:41:46 <latermuse> oh
07:41:52 <adkron> latermuse: what ion said
07:42:18 <adkron> I have an example of a simple echo server, but I'm not sure how to test any of this.
07:42:19 <chandra> can you tell me how to append two lists
07:42:27 <latermuse> I saw a good tdd/bdd tutorial with a calculator program
07:42:36 <chandra> i tried this : union (x:xs) (y:ys) = (x:xs):(y:ys)
07:42:42 <chandra> it gives me an error
07:42:54 <weissi> (posting again because new people seem to be here)I'm having a weird problem with cabal: If I configure/build with --enable-executable-profiling --enable-library-profiling cabal does two strange things: It does not compile with -prof and is does not use the options provided in GHC-Prof-Options. Any ideas? (cabal-install version 1.16.0.2; using version 1.16.0 of the Cabal library)
07:42:59 <chandra> what is wrong in that statement
07:43:09 <latermuse> > union [1,2,3] [5,6,7]
07:43:10 <lambdabot>   [1,2,3,5,6,7]
07:43:13 <latermuse> you can append lists like this
07:43:31 <`nand`> > [1,2,3] ++ [5,6,7]
07:43:33 <lambdabot>   [1,2,3,5,6,7]
07:43:38 <latermuse> the way you wanted to do it could have been like this:
07:43:46 <chandra> >union [1] [2]
07:43:49 <chandra> ?
07:43:57 <chandra> oh
07:43:58 <latermuse> union' (x:xs) (y:ys) = union (x:xs) (y:ys)
07:44:09 <`nand`> chandra: (x:xs):y:ys means (x:xs) itself will be the first element
07:44:11 <rwbarton> do you really want to do all that pattern matching? I suspect not
07:44:12 <chandra> oh is union already defined?
07:44:16 <latermuse> yes
07:44:26 <rwbarton> union is defined but it might not be what you means
07:44:27 <chandra> i wanted to define
07:44:28 <rwbarton> *meant
07:44:28 <latermuse> in Data.List
07:44:33 <chandra> oh
07:44:39 <`nand`> ‘union’ has nothing to do with appending lists, does it?
07:44:50 <`nand`> union is about merging lists by taking their union
07:44:52 <rwbarton> well, sort of
07:45:06 <latermuse> >union "cat" "meow"
07:45:13 <rwbarton> surely that has *something* to do with appending lists, but if all you want to do is append lists, don't use union
07:45:18 <merijn> > union "cat" "meow"
07:45:19 <latermuse> > union "cat" "meow"
07:45:21 <lambdabot>   "catmeow"
07:45:21 <lambdabot>   can't find file: L.hs
07:45:28 <merijn> > union "dog" "meow"
07:45:30 <lambdabot>   "dogmew"
07:45:42 <latermuse> > union "dog" cow"
07:45:44 <lambdabot>   <hint>:1:17:
07:45:44 <lambdabot>      lexical error in string/character literal at end of input
07:45:51 <latermuse> > union "dog" "cow"
07:45:53 <lambdabot>   "dogcw"
07:46:06 <latermuse> Its like a mathematical union.
07:46:20 <weissi> union is set union
07:46:23 <Taneb> > union "dog" "woof"
07:46:24 <lambdabot>   "dogwf"
07:46:41 <`nand`> > union "woof" ""
07:46:42 <lambdabot>   "woof"
07:46:48 <`nand`> > union "" "woof"
07:46:50 <lambdabot>   "wof"
07:46:59 <latermuse> cool
07:48:01 <latermuse> but to answer your question
07:48:07 <latermuse> the best way to append two lists is by using ++
07:48:15 <latermuse> > [1,2,3] ++ [4,5,6]
07:48:17 <lambdabot>   [1,2,3,4,5,6]
07:48:41 <latermuse>  [x1, ..., xm] ++ [y1, ..., yn] == [x1, ..., xm, y1, ..., yn]
07:49:12 <chandra>   > [1,2] ++ [4,5]\
07:49:33 <latermuse> that last \ is an error, no?
07:49:55 <chandra> can you tell what is wrong in this : union (x:xs) (y:ys) = (x:xs):(y:ys)
07:49:58 <chandra> its not exactly union its kinda concatenation but anyways
07:50:05 <chandra> it gives me an error
07:50:35 <`nand`> doesn't give me an error
07:51:03 <`nand`> well, it would give you a (runtime) error if you tried to pass [] in either argument
07:52:03 <latermuse> union :: [a] -> [[a]] -> [[a]]
07:52:06 <`nand`> “given a list x:xs and a list of lists y:ys; form a new list of lists (x:xs):y:ys; or [x:xs, y, ...]
07:52:09 <latermuse> this is the type signature of that program
07:52:28 <latermuse> so union [1,2] [[3,4]] would give [[1,2],[3,4]]
07:52:34 <`nand`> > let union (x:xs) (y:ys) = (x:xs):(y:ys) in union [1,2] [[3,4],[5,6]]
07:52:36 <lambdabot>   [[1,2],[3,4],[5,6]]
07:53:40 <neutrino> @hoogle Monad m => ([a] -> b) -> [m a] -> m b
07:53:40 <lambdabot> Foreign.Marshal.Utils withMany :: (a -> (b -> res) -> res) -> [a] -> ([b] -> res) -> res
07:53:42 <latermuse> chandra: is this what you are trying to do?
07:53:49 <neutrino> that's not what i'm looking for.
07:53:55 <neutrino> is there something like what i'm looking for?
07:54:21 <neutrino> @hoogle Monad m => [m a] -> m [a]
07:54:21 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
07:54:21 <lambdabot> Control.Monad sequence :: Monad m => [m a] -> m [a]
07:54:21 <lambdabot> Data.Traversable sequence :: (Traversable t, Monad m) => t (m a) -> m (t a)
07:54:33 <fmap> :t fmap ?f . sequence
07:54:34 <lambdabot> (?f::[a] -> b, Monad f, Functor f) => [f a] -> f b
07:55:29 <neutrino> mmh yeah
07:55:33 <neutrino> thanks fmap
07:55:35 <neutrino> :)
07:56:01 <fmap> :t fmap ?f . sequenceA
07:56:02 <chandra> neutrion thanks for reaching out but i did not start with monads
07:56:02 <lambdabot>     Not in scope: `sequenceA'
07:56:02 <lambdabot>     Perhaps you meant one of these:
07:56:02 <lambdabot>       `Data.Traversable.sequenceA' (imported from Data.Traversable),
07:56:12 <fmap> :t fmap ?f . Data.Traversable.sequenceA
07:56:14 <lambdabot> (?f::t a -> b, Applicative f, Traversable t) => t (f a) -> f b
07:56:37 <fmap> neutrino: so you don't actually need Monad
08:00:19 <latermuse> fmap: what does (?) do?
08:00:39 <Cale> latermuse: That's an implicit parameter
08:01:27 <latermuse> do I need to import something to use it in ghci?
08:02:06 <latermuse> Im getting this error: <interactive>:1:1: parse error on input `?'
08:02:07 <Cale> http://www.haskell.org/ghc/docs/latest/html/users_guide/other-type-extensions.html -- see 7.12.3
08:02:14 <Cale> It's a language extension
08:02:37 <Cale> {-# LANGUAGE ImplicitParams #-}
08:02:49 <adkron> This is a frustrating start, I import IO and it says I need to add haskell98 to my cabal file I add that and it says prelude is ambiguous.
08:03:10 <Cale> adkron: Try System.IO
08:03:15 <latermuse> adkron: IO is deprecated
08:03:27 <adkron> Thanks
08:03:49 <Cale> adkron: Which tutorial are you reading?
08:04:34 <adkron> Cale: http://kyagrd.dyndns.org/wiki/HaskellServerProgramming
08:04:45 <latermuse> adkron: Some of the old tutorials dont work well with the new compilers
08:04:50 <Fikcio> Hello.
08:04:57 <latermuse> fikcio: hi
08:05:02 <adkron> Any that you suggest.
08:05:07 <latermuse> adkron: Try to aim for stuff made after 2008
08:05:29 <latermuse> after 2010 would be best
08:05:44 <Fikcio> Where can I find Prelude.hs and the rest of the libraries source code? I'm very new to Haskell and I'd like to take a look at them.
08:06:05 <Fikcio> I downloaded the Haskell Platform, but I can't find the .hs files anywhere.
08:06:13 <typoclass> latermuse: i think it can usually be fixed by changing a few imports. but yeah, it's inacceptable if beginners are expected to do that
08:06:27 <typoclass> adkron: are you aware of lyah? it's a good book available free of charge
08:06:29 <typoclass> @where lyah
08:06:30 <lambdabot> http://www.learnyouahaskell.com/
08:06:46 <Botje> Fikcio: haskell platform only ships the compiled prelude
08:07:03 <Fikcio> Yeah, that's what I figured. So what should I download instead?
08:07:04 <Botje> Fikcio: you can google for prelude.hs and read the source there, or check out ghc yourself and read the source
08:07:20 <adkron> typoclass: Yeah, I have it open in my browser. I guess the simple echo server is going to take more that I thought.
08:07:37 <dev__> hey guys, where can i find some haskell examples to get started with, I am new to haskell programming
08:07:41 <latermuse> fikcio: You can see the source code easily on hoogle.
08:07:41 <adkron> I thought once I had cabal and HSpec working nicely it was going to be smooth sailing for a bit
08:07:59 <Fikcio> Thank you, but I'd rather have the files.
08:08:14 <Botje> Fikcio: then check out ghc from the darcs/git repo :)
08:08:25 <Fikcio> Oh, ok.
08:08:28 <Fikcio> I'll give that a try.
08:08:30 <Fikcio> Thank you!
08:08:30 <latermuse> fikcio: The source code you see on hoogle is usually really highly optimized, and wont make a whole lot of sense until you have been learning haskell for a while.
08:08:31 <typoclass> Fikcio: in general, on a page like http://www.haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html , you can click "source" on the right hand side
08:08:34 <rwbarton> wow that wiki page mentions 6.2.1
08:08:58 <Fikcio> Great.
08:09:03 <Fikcio> Thank you, guys.
08:09:29 <typoclass> Fikcio: and have you tried "cabal unpack base". what you get then may not exactly match your compiler version (i think), but it's surely good enough for just having a look
08:09:31 <latermuse> rwbarton: I think centos's repositories have GHC 6.2.1 on them.
08:09:57 <latermuse> dont quote me on that though
08:10:06 <typoclass> rwbarton: my brain autocorrected that to "6.12.1", then got second thoughts ...
08:10:16 <Fikcio> No, I haven't. I'll give it a try.
08:10:20 <Fikcio> Thank you very much!
08:10:28 <typoclass> Fikcio: you're welcome
08:10:33 <Fikcio> : )
08:10:46 <Fikcio> Bye. See you guys around.
08:10:59 <latermuse> Bye
08:13:04 <latermuse> cale: Thanks for that link earlier. Thats some good quality reading!
08:27:57 <booski> How can I get list of available `package' versions using cabal?
08:29:00 <typoclass> booski: "cabal info something" will tell you all the versions of package "something"
08:29:01 <latermuse> > [x | y <- [1..5], x <- "meow", then group using inits]
08:29:03 <lambdabot>   Unexpected transform statement in a list comprehension
08:29:03 <lambdabot>  Use -XTransformList...
08:29:31 <booski> typoclass: nice
08:30:40 <singpolyma> How do I get GHC just to unlit an lhs file without building?
08:30:49 <typoclass> booski: oh, and you may need to do "cabal update". if you wanted version something-1.2.3 and you're wondering why it's not listed and cabal thinks the latest is something-1.2.1
08:31:26 <latermuse> > [(x+y) | x <- [1..5] | y <- [10..15]]
08:31:27 <lambdabot>   [11,13,15,17,19]
08:31:39 <latermuse> hmm
08:31:58 <latermuse> how did that work?
08:32:33 <latermuse> is it [[10+1],[11+2],[12+3]..]?
08:32:33 <rwbarton> it uses zip
08:32:36 <latermuse> looks like it
08:32:42 <rwbarton> -XParallelSomethingOrOther
08:32:44 <Jafet> singpolyma: --ddump-parsed
08:32:55 <latermuse> got it, thanks
08:34:07 <singpolyma> Jafet: ok, that's most of the way there.  can I additionally prevent compilation?
08:43:28 <bstrie> Twey: Re: removal of typestate from Rust, see the comments and links here http://news.ycombinator.com/item?id=4658673 for some background
08:45:05 <bstrie> Twey: short story is that the design was quite cumbersome for very little gain, and it was decided to chuck it out and leave it to be potentially reimplemented for Rust 2.0 with a better design
08:45:24 <ParahSail1n> is there something like withForeignPtr2 that would take two ForeignPtr and a (Ptr -> Ptr -> IO b)
08:47:01 <dcoutts> ParahSail1n: you can easily write that using withForeignPtr
08:47:01 <lambdabot> dcoutts: You have 2 new messages. '/msg lambdabot @messages' to read them.
08:48:28 <dcoutts> withForeignPtr fptr1 $ \ptr1 -> withForeignPtr fptr2 $ \ptr2 -> dothing ptr1 ptr2
08:49:00 <rwbarton> or for massive overkill you can wrap withForeignPtr in Codensity and use liftM2
08:49:24 <rwbarton> but, do what dcoutts said
08:50:58 <Saizan> massive_overkill++
08:50:59 <parcs`> :t withForeignPtr
08:51:00 <lambdabot> Not in scope: `withForeignPtr'
08:51:22 <parcs`> rwbarton: wouldn't simply ContT work?
08:51:50 <rwbarton> not for *massive* overkill :)
08:52:16 <rwbarton> but yeah, in some situations
09:01:11 <b____> could someone point me to good articles describing benefits/usage of GADTs other than the ones in the main HaskellWiki article?
09:03:06 <S11001001> b____: what, specifically, difference are you looking for?
09:04:51 <b____> more (not too complicated) examples that show me why they are useful. I'm sort of getting it, but don't yet see why/when I would use GADTs over Haskell98 types.
09:05:23 <edwardk> b____: write data Expr a  where it is strongly typed without GADTs ;)
09:05:56 <hpaste> scooty-puff pasted “Bounded on Arith Overflow, does this already exist?” at http://hpaste.org/78719
09:06:12 <edwardk> b____: data Expr a where If :: Expr Bool -> Expr a -> Expr a -> Expr Bool; (:&&) :: Expr Bool -> Expr Bool -> Expr Bool; Lit :: Int -> Expr Int
09:06:47 <S11001001> edwardk: I think Expr is the example on haskellwiki :P
09:06:53 <edwardk> S11001001: fair enough ;)
09:07:33 <edwardk> GADTs let you safely ignore cases that 'can't happen' for a given type
09:07:43 <b____> hmmm okay
09:08:04 <edwardk> you just don't have to write how to handle Lit 2 :&& Lit 3 -- because that is nonsensical
09:08:40 <edwardk> without them you can often get by but you wind up having to litter your code with unchecked 'undefined's and always worry you missed a real case that can happen
09:08:54 <edwardk> there are other situations where you really do need them though in practice
09:09:17 <b____> okay
09:09:36 <cizra> Hey guys, should I use the Happstack packages from Debian testing or cabal?
09:09:45 <b____> so you can encode restrictions more elegantly?
09:09:55 <S11001001> b____: s,elegantly,at all,
09:10:27 <edwardk> cizra: as a rule do this. if you install anything from debian do so before you use cabal for installing anything. then install with cabal for anything global, then do local stuff.
09:10:48 <edwardk> if you've used cabal for pretty much anything ignore the native package manager for anything haskell related
09:11:24 <glguy> That rule seems complicated /:-)
09:11:27 <edwardk> cizra: this rules out a lot of the 'cabal is terribly broken' situations.
09:11:44 <edwardk> glguy: alternately. just don't use the debian packages for anything past the platform ;)
09:12:14 <edwardk> glguy: but basically its because local packages can depend on global ones, and the package managers usually screw up cabal invariants
09:12:41 <edwardk> so once you've started with cabal, the various hacks the package managers use to smash crap into the package list can mess with you.
09:12:49 <b____> I wish the examples only show cases where GADTs are the only option
09:13:17 <edwardk> data Is a b where Refl :: Is a a
09:13:21 <cizra> Gah. I guess I can just go with the Debian thing, as it seems to have everything I need today.
09:13:21 <edwardk> is that in the example list?
09:14:51 <b____> edwardk I believe not
09:16:37 <Twey> bstrie: Thanks
09:22:20 <astropirate> Anyone here in DC/NOVA want to get a meetup going? :)
09:23:03 <Athas> Is there a tool for reformatting Haskell source, such as gofmt for Go or indent for C?
09:25:38 <c_wraith> Athas: nothing I know of. Haskell's more like python in that sense. Using alignment for layout results in less broken layout.
09:26:24 <tcrayford> I think there is a tool for something like that
09:26:34 <typoclass> Athas: different people have different indetation styles ... i don't think it's quite as fixed as in go
09:26:49 <tcrayford> https://github.com/jaspervdj/stylish-haskell
09:27:09 <tcrayford> you can override stuff in that tool using a yaml file, iirc
09:27:20 <Athas> tcrayford: hm, it does a little less than I'd like, but it's a start.
09:27:42 <Athas> This is also my preferred outcome.  Now I have something to work on!
09:28:40 <tcrayford> Athas: yeah. I wish haskell had an official thing like go fmt included in the haskell platform or something. I think arguing about the way you format code is an amazingly dumb waist of time
09:29:07 <typoclass> tcrayford: yeah, i do wish there was more standardization
09:29:23 <cizra> tcrayford: Get a real editor? Haskell is whitespace-sensitive, which means you CAN'T automatically reformat it in any way and hope it'll remain correct.
09:29:25 <c_wraith> I thought everyone standardized on tibbe's style guide
09:29:42 <tcrayford> c_wraith: right, but that's not completely automated yet ;)
09:29:55 <Athas> cizra: sure you can.
09:30:01 <tcrayford> cizra: true. I use one of the two One True Editors, so no worries there ;)
09:30:03 <Athas> You can enforce consistency, for example.
09:30:21 <Athas> It's much more complicated, though.  You need heuristics for what is "pretty".
09:30:43 <tcrayford> tibbe's style guide is a good start, imo
09:31:13 <Jafet> Haskell is not easy to pretty-print
09:31:32 <Jafet> I have this program that tries to do it
09:31:48 <Jafet> It gets especially hard if you have something like a width limit
09:32:10 <c_wraith> It gets easier if the pretty-printer is allowed to introduce renaming
09:32:25 <Jafet> It has to invent names
09:32:31 <Jafet> That sounds harder
09:32:38 <c_wraith> it could always ask
09:35:33 <edwardk> jafet: you can just devolve to explicit {}"s if you want to fit in a limit
09:35:59 <tcrayford> I think a width limit is better enforced by a linting tool on some levels, given the difficulty
09:36:02 <ParahSail1n> @hoogle newMutableByteArray
09:36:02 <lambdabot> No results found
09:36:10 <tcrayford> (my editor puts a vertical line at 78 chars ;) )
09:36:39 <ParahSail1n> where's http://darcs.haskell.org/packages/array/Data/Array/Base.hs get newMutableByteArray from
09:36:49 <Jafet> Yes, edwardk, the point is to do it with layout
09:39:16 <DMcGill> if I have a float fps, can I reliably check if the user has set it to 0?
09:39:28 <DMcGill> I know that x + 1 - 1 != 0 with floating point
09:39:46 <DMcGill> but does x = 0; x == 0 work?
09:40:16 <DMcGill> s/fps/x
09:43:41 <Ralith> DMcGill: x=c; x==c always works.
09:44:08 <ClaudiusMaximus> unless c is nan
09:45:36 <quchen> > let c = 0/0 in c == 0/0
09:45:38 <lambdabot>   False
09:45:49 <quchen> Oooh IEEE floating point standard
09:46:04 <quchen> Is NaN unequal to anything?
09:46:19 <opqdonut> yes, everything
09:46:30 <opqdonut> AFAIK no comparison with NaN will yield True
09:46:55 <quchen> So is there any way of testing whether something is NaN then?
09:47:07 <Twey> You can check whether it's equal to itself ☺
09:47:09 <rwbarton> @hoogle isnan
09:47:09 <lambdabot> Prelude isNaN :: RealFloat a => a -> Bool
09:47:18 <Twey> More generally there's an isNaN() function
09:47:20 <quchen> > filter isNaN $ map (/0) [-5,-4..5]
09:47:21 <lambdabot>   [NaN]
09:47:32 <Twey> Of course, if you get a SNaN you will have a bottom value
09:47:41 <quchen> SNaN?
09:47:43 <opqdonut> isNan, yes
09:47:48 <Twey> Signalling NaN
09:47:53 <rwbarton> super not a number
09:48:28 <Twey> There are two types of NaN defined by IEEE: signalling NaN, which causes an error as soon as it occurs, and quiet NaN, which just silently infects every calculation it comes into contact with
09:48:47 <quchen> And my guess is that both are evil in their own ways?
09:53:01 <quchen> Speaking of Floats: it seems that the only module that exports RealFloat is Prelude. Why is that? Why is there no module I can import that contains it?
09:53:32 <quchen> Seen in the bigger picture: Why does the Prelude contain source code, and doesn't only import other modules?
09:59:37 <Cale> quchen: That's kind of a philosophical question.
10:00:10 <Cale> quchen: Actually in GHC, the Prelude does get most stuff from other modules.
10:00:23 <Cale> RealFloat is defined in GHC.Float
10:00:32 <Cale> and then re-exported by GHC's implementation of the Prelude
10:01:29 * hackagebot yesod-fb 0.2.2 - Useful glue functions between the fb library and Yesod.  http://hackage.haskell.org/package/yesod-fb-0.2.2 (FelipeLessa)
10:01:33 <Cale> quchen: It really shouldn't matter whether the Prelude is defining things or re-exporting them, because you can't really tell the difference between those two possibilities as a user of the library.
10:03:56 <rwbarton> and you could never need to import RealFloat anyways, since you always have it from Prelude
10:07:16 <artiq> Hi, I was wondering if anyone knows a good way to print a list of pairs?
10:07:50 * Ralith suggests 'print'
10:08:53 <typoclass> artiq: unlines . map show?
10:09:11 <typoclass> (to get some newlines into it, for readability)
10:10:49 <artiq> Like I have a list like this [(string1, string2), (string3, string4)] and I want ot print: string1 string2 \n string3 string4
10:11:47 <glguy> artiq: which part are you having trouble with?
10:12:05 <S11001001> home....
10:16:38 <quchen> Cale: Followup question: Why doesn't GHC complain about ambiguous names when I import Data.List and use 'length'? It's defined both in the Prelude and in Data.List after all.
10:17:20 <c_wraith> quchen: it's the same length. It's defined in Data.List, and re-exported by Prelude
10:17:28 <Cale> quchen: because the Prelude is re-exporting the same one that Data.List is exporting.
10:17:39 <Cale> It's actually defined in GHC.List
10:17:47 <Cale> but then Data.List and Prelude both export it
10:18:08 <quchen> Ah, I see. I picked a bad example ;-)
10:18:08 <Cale> You can find out where things are actually defined using :info <name-of-thing>
10:18:23 <c_wraith> Re-exporting things is actually pretty common in libraries.
10:19:12 <quchen> Cale: Ah, I see where my error came from. I clicked on "source" in the Prelude docs, and thought this would necessarily bring me to the source of Prelude.
10:19:21 <hpaste> DMcGill pasted “Could somebody critique this code please” at http://hpaste.org/78722
10:20:23 <quchen> DMcGill: HPaste automatically runs HLint on pasted code. Scroll down for a first hint :-)
10:21:06 <c_wraith> wow.  I wish GHC would warn about that.
10:21:43 <quchen> ..?
10:21:49 <quchen> Unused LANGUAGE?
10:21:50 <c_wraith> unused LANGUAGE pragmas
10:21:53 <Cale> I wish GHC's warnings were a little better in general. -Wall is just obnoxious and warns about lots of things which don't matter so I never turn it on.
10:21:58 <cizra> Hey guys, I know that's a trolly-sounding question, but Happstack, Snap or Yesod? I've understood they're about equivalent in quality, so it doesn't matter much which one to pick, all other being equal, right?
10:22:17 <c_wraith> cizra: yeah, you're best off picking the one with the api you like most
10:22:31 <Cale> But then it also includes things like pattern match completeness and stuff like that which can be rather important.
10:22:34 <arbn> cizra: If you love Template Haskell, use Yesod.
10:22:49 <arbn> cizra: :P
10:22:57 <cizra> I don't love anything as of right now, I'm just trying to figure out which one to begin loving :-)
10:23:10 <quchen> The good old problem of choosing between equally valid options with feedback. If you choose one, you'll have problems the others maybe don't have. Nash equilibrium is not choosing ;-)
10:23:17 <Cale> cizra: It's one of those matter-of-taste sorts of questions, and a lot of the libraries that these things use can be used together, so you can form almost arbitrary hybrids.
10:23:31 <cizra> Yeah, so the choice really doesn't matter right now. Cool.
10:23:38 <arbn> cizra: Try all of them!
10:23:57 <Cale> cizra: However, if you ask me, I think Happstack looks like the most down-to-earth one and fits best with my mentality.
10:24:00 <cizra> arbn: OK! Now ... er, which one should I start from? :-)
10:24:17 <Cale> There's a lot of TH magic in the others which I'm moderately opposed to.
10:24:21 <cizra> Happstack was the one I'm inclined to try first too. But you never know.
10:24:25 <tcrayford> cizra: I like snap, but there's a reasonable amount of wheel reinventing when you write a snap app (compared to e.g. writing a rails app like I do at the day job)
10:24:26 <Twey> Not in Snap, right?
10:24:29 <Cale> (but I can see why some people would like it)
10:24:55 <Cale> Actually, there's a bit of TH magic in all of them, but it's avoidable to varying extents.
10:25:04 <arbn> cizra: I think Yesod is the easiest to learn and get started with, personally, especially if you've used a web framework in an imperative language like Django or Rails.
10:25:34 <jeff_s1> Yesod has a book available: http://www.yesodweb.com/book
10:26:17 <tcrayford> iirc snap only uses TH for lenses and for dynamic reloading (so when you're in dev, you don't have to restart/recompile the server on every request to see changes)
10:26:21 <stepkut> jeff_s1: is that book better than the happstack crash course?
10:27:19 <jeff_s1> Stepkut: no idea. I've never looked at happstack. FWIW I use snap in production, though I tried warp with similar results.
10:27:51 <jeff_s1> My web portion of my app is simple enough, I don't need a full framework.
10:29:39 <tcrayford> cizra: what kind of web app are you writing?
10:30:14 <xcv_> Hi everyone. I'm having trouble understanding the "(.).(.)" function, can anybody give me some pointers? I know what it does, but not how it is constructed. Thanks
10:30:34 <Cale> xcv_: Do you know about Functor and fmap?
10:30:42 <xcv_> Cale: yes
10:30:45 <Cale> xcv_: I think that function is easier to understand when you generalise it a little bit
10:30:57 <Cale> So there is an instance of Functor for functions:
10:31:09 <Cale> instance Functor ((->) e) where fmap f g x = f (g x)
10:31:14 <Cale> that is, fmap = (.)
10:31:24 <Cale> In general, you have:
10:31:30 * hackagebot representable-profunctors 3.0 - Representable profunctors  http://hackage.haskell.org/package/representable-profunctors-3.0 (EdwardKmett)
10:31:31 <Cale> fmap :: (Functor f) => (a -> b) -> f a -> f b
10:31:39 <Cale> and in this case, f = (->) e, which means
10:31:48 <Cale> fmap :: (a -> b) -> (e -> a) -> (e -> b)
10:32:27 <Cale> fmap takes a function and turns it into a function which acts on the elements of some structure -- in this case, the results of another function
10:32:45 <Cale> If we compose it with itself, we get something which acts two levels deep:
10:33:04 <Cale> fmap . fmap :: (Functor f, Functor g) => (a -> b) -> f (g a) -> f (g b)
10:33:37 <Cale> but then this gives us a way to look at (.) . (.)
10:33:59 <xcv_> Cale: wow, I'll have to think a bit about this. Haskell is making mincemeat brain...
10:34:23 <Cale> You can also just understand it directly of course by applying it to some generic arguments and evaluating a bit...
10:34:49 <xcv_> I think I understand it better now, thanks
10:34:50 <Cale> But this makes it somewhat easy to see what the type should be, and the type completely determines the behaviour in this case
10:35:07 <Cale> (a -> b) -> (e -> e' -> a) -> (e -> e' -> b)
10:35:49 <xcv_> I love the type system, it's concise yet self-explainatory and powerful
10:35:55 <Cale> So it takes a function (a -> b), and a function of two parameters, (e -> e' -> a), and composes them in the only reasonable way to get a function (e -> e' -> b)
10:46:30 * hackagebot midimory 0.0.0.2 - A Memory-like (Concentration, Pairs, ...) game for tones  http://hackage.haskell.org/package/midimory-0.0.0.2 (HenningThielemann)
10:54:27 <jackss> .
10:54:41 <jackss> can someone help me with case syntax?    case map toLower line of     "y" -> return True     "n" -> return False      c  -> tryAgain
10:54:52 <jackss> sorry wanted to paste a link
10:54:56 <jackss> http://hpaste.org/78723
10:55:10 <DMcGill> move the 'c' one character to the left
10:55:20 <DMcGill> it needs to line up with the ", not with the n
10:55:23 <jackss> oh. :)
10:55:26 <jackss> thanks
10:55:48 <DMcGill> that always annoys me with brackets too, just looks slightly off imo
10:55:51 <DMcGill> but there you go
10:56:18 <jackss> yes. I thought I was going insane as I used case of before
10:56:19 <DMcGill> also in this case you can replace the 'c' with '_'
10:56:31 <jackss> good point
10:56:34 <DMcGill> underscore just throws away what it matches
10:59:25 <edwardk> @tell dcoutts i was bored waiting and watched cabal update run. it fetched 00-index.tar.gz apparently uncompressed. and then uncompressed it to 00-index.tar at the same size. i think there may be a funny interaction with curl or whatever you are using to fetch already doing the uncompression
10:59:25 <lambdabot> Consider it noted.
10:59:50 <dcoutts> edwardk: um that'll be a crazy intermediate proxy
10:59:50 <lambdabot> dcoutts: You have 1 new message. '/msg lambdabot @messages' to read it.
10:59:51 <edwardk> @tell dcoutts -rw-r--r--  1 ekmett  staff  82288640 Dec  3 13:59 00-index.tar   -rw-r--r--  1 ekmett  staff  82288640 Dec  3 13:58 00-index.tar.gz -- it took its sweet time downloading it that way too ;)
10:59:51 <lambdabot> Consider it noted.
10:59:55 <edwardk> ah
11:00:06 <dcoutts> edwardk: there's not a lot we can do about them sadly
11:00:06 <lambdabot> dcoutts: You have 2 new messages. '/msg lambdabot @messages' to read them.
11:00:07 <edwardk> i was wondering if it was a proxy or cabal
11:00:30 <dcoutts> proxies really should not decompress
11:00:46 <dcoutts> we have to have special support to notice when proxies are lying to us like this
11:01:07 <edwardk> i wonder if its worth pulling from a slightly different url so you can lie about the mimetype or some such
11:01:09 <edwardk> er the compression mode
11:01:13 <dcoutts> edwardk: the worst ones will transparently decompress, but then not alter the headers to make it clear they've done so! doh!
11:01:37 <ParahSail1n> what are the pros and cons of GHC.Prim newArray# vs Foreign.ForeignPtr mallocForeignPtrBytes
11:01:48 <dcoutts> edwardk: it's the origin server that specifies the mimetype, and apache serves .tar.gz as mime type tar with gz as the transport encoding
11:02:00 <dcoutts> edwardk: so sadly we just have to live with it
11:02:48 <dcoutts> ParahSail1n: you almost certainly want mallocForeignPtrBytes
11:03:50 <edwardk> yes but that is also configurable. i was just suggesting that it might be a usable dodge to have cabal pull from some url that has been configured to send with x-octet-stream or what not. yes its an infelicity, but it avoids the issue. *shrug* its not a big concern and it is a hack
11:03:57 <jackss> are guards function declaration syntax or can you use them in the middle of a function as a replacement for if/else/then chain?
11:04:07 <dcoutts> edwardk: in general we cannot control the origin server
11:04:14 <dcoutts> edwardk: this issue will all go away once we do incremental index updates, since then the amount of data will be very small
11:04:41 <Philippa> Saizan: y'around?
11:04:42 <DMcGill> jackss: they're pattern matching syntax - you can use them inside case statements too
11:04:47 <Saizan> Philippa: yep
11:04:50 <Philippa> cool
11:04:56 <jackss> I see, thanks
11:05:04 <jackss> well no?
11:05:05 <Philippa> edwardk, Saizan: feel free to look at https://github.com/flippac/two-level-constraints and scream at my incompetence!
11:05:09 <DMcGill> I suppose case {_ | bool1 | bool2} does work, doesn't seem super nice though
11:05:18 <edwardk> Philippa: will do once i have some free time
11:05:28 <DMcGill> I mean case undefined of {...
11:05:31 <jackss> maybe I am using wrong terminology, I meant this   func x |  x < 0  -> something; etc
11:05:36 <ParahSail1n> dcoutts: arrays from the array package use the GHC Prim arrays, but i want to pass arrays to ffi c. should i drop Data.Array and use foreignptrs?
11:05:45 <Philippa> sure. I'm a bit knackered to take on proper feedback or write proper code right now anyway. I guess that's why I got round to setting myself up a github account
11:05:52 <Saizan> is github slow in general or just for me?
11:05:56 <dcoutts> ParahSail1n: the array lib provides a storable array type, that can be used with ffi
11:06:10 <Philippa> the Test module may be borken btw, it sure was when I continued work locally
11:06:19 <Philippa> turns out you can do embarrassing shit with two-level types rather easily
11:06:21 <ceii> DMcGill, case () of { () | bool1 -> ... ; () | bool2 -> ... } is a common idiom, though it's superseded by the MultiWayIf extension
11:06:22 <ParahSail1n> dcoutts: ah, derp
11:06:36 <dcoutts> ParahSail1n: and that'd be recommended over rolling your own with ForeignPtr
11:07:28 <ParahSail1n> dcoutts: indeed
11:08:38 <ParahSail1n> "It is similar to IOUArray but slower. Its advantage is that it's compatible with C." so i guess the question is whether that purported overhead is worth it
11:10:55 <ceii> I don't think IOUArray is completely incompatible with C, it's just that its elements aren't pointer-sized and you need to detrmine their size yourself
11:11:33 <ceii> that wouldn't be a problem for arrays of Doubles or Int64s, for example
11:11:41 <ParahSail1n> well IOUArray is implemented as GHC.Prim Array#'s
11:14:36 <ceii> oh, actually STUArray doesn't export its constructor, so you can't reach the underlying byte array
11:14:40 <ceii> too bad
11:20:04 <quchen> I'm having trouble understanding the build function. I understand neither the type (forall strikes again) nor the implementation. However, many functions are implemented in terms of it (e.g. zip and various folds). Is there a simple interpretation?
11:22:22 <Saizan> Philippa: looks nice, swap (put $ i+1) for (put $! i+1) in genSym's implementation though or it's going to get nasty quite fast
11:22:25 <Cale> :t build
11:22:26 <lambdabot>     Not in scope: `build'
11:22:27 <lambdabot>     Perhaps you meant `buildG' (imported from Data.Graph)
11:22:30 <Cale> ah, right
11:22:57 <byorgey> build :: (forall b. (a -> b -> b) -> b -> b) -> [a]
11:23:01 <Cale> build :: (forall b. (a -> b -> b) -> b -> b) -> [a]
11:23:02 <Cale> right
11:23:15 <byorgey> build g = g (:) []
11:23:17 <Philippa> Saizan: heh, good catch!
11:23:24 <Cale> You can think of build as constructing a list out of the result of applying foldr to that list
11:23:38 <Cale> i.e. it's sort of the opposite of what foldr is
11:24:06 <quchen> build g = g (:) []  <==> \x -> foldr f x []
11:24:06 <quchen> ?
11:24:17 <Cale> foldr f z is the function which replaces each occurrence of (:) in a list with the function f and the [] at the end (if any) with z
11:25:02 <Cale> and build, when provided with a polymorphic function of the appropriate parameter types will supply (:) and []
11:25:04 <quchen> ... and build replaces every f with (:)?
11:25:09 <ceii> :t foldr
11:25:10 <lambdabot> (a -> b -> b) -> b -> [a] -> b
11:25:42 <quchen> I'm familiar with folds, but every time I look at the optimization steps I stumble upon build, and it kept nagging me.
11:26:04 <Cale> The important rule in terms of optimisation is that  foldr c n (build g) = g c n
11:26:07 <ceii> if you look at foldr's type, you see that by specializing it to a particular list you get a function (forall b. (a -> b -> b) -> b -> b)
11:26:09 <mightybyte> tibbe: What cabal-install sandbox functionality is in the github master?
11:26:30 <ceii> build goes from such a function back to the list
11:26:32 <Cale> So the construction of a list which is constructed using build can be eliminated when a foldr is applied to it
11:26:59 <tibbe> mightybyte: close to the final one, just hidden behind a different UI e.g. cabal sandbox-configure, cabal sandbox-build
11:27:09 <mightybyte> Ahhh
11:27:12 <quchen> I think I'm starting to understand something.
11:27:24 <tibbe> mightybyte: for the release we will use the normal commands (which will use a sandbox or not depending on if one exists)
11:27:24 <Botje> quick, write it down!
11:27:30 <mightybyte> Is there a way to get a list of those, or am I do I have to soucre-dive for that information right now?
11:27:45 <mightybyte> tibbe: Oh, very cool.
11:27:57 <tibbe> mightybyte: the only functionality that is missing is that add-source dependencies need to be rebuilt properly (we're reviewing a pull request for that now)
11:28:13 <ceii> quchen: I'd point you to church encoding if there was a good, understandable resource on it...
11:28:17 <byorgey> quchen: you might want to try picking a particular type for 'a' (say, Int) and then trying to write functions of type  (Int -> b -> b) -> b -> b
11:28:35 <Cale> Yeah, maybe it will help to understand Church encoding :)
11:28:37 <ceii> (don't try looking at the wikipedia article)
11:28:38 <byorgey> quchen: if you do this you will quickly see how such functions correspond to lists
11:28:53 <byorgey> quchen: then try applying 'build' to your functions and see what happens
11:29:00 <byorgey> either in ghci, or on paper
11:29:20 <quchen> Paper's on its way already :-)
11:29:23 <Cale> In order to explain that, let's take a look at the following somewhat silly datatype (silliness being halfway to abstraction)
11:29:30 <mightybyte> tibbe: How do I create the sandbox?
11:29:41 <tibbe> mightybyte: cabal sandbox --init I think
11:29:49 <tibbe> or was that cabal sandbox init
11:29:57 <tibbe> in the final UI it will be cabal sandbox init
11:30:06 <Cale> data Nature a = Rock a | Stream a (Nature a) | Tree (Nature a) (Nature a)
11:30:12 <mightybyte> cabal sandbox-ini
11:30:16 <byorgey> cabal sandbox --reset --hard ^HACKAGE -b
11:30:56 <Eduard_Munteanu> Is there a file name/path sanitization function around? I need to clean up user-supplied names for uploaded files in Yesod.
11:31:00 <mightybyte> byorgey: unrecognized command
11:31:07 <Cale> We can consider constructing something analogous to foldr for this data type, which will replace each occurrence of Rock, Stream and Tree respectively with some other functions r, s, t
11:31:39 <byorgey> mightybyte: well, obviously you have to do  cabal sandbox checkout --prepare  first
11:31:46 <byorgey> I thought that was too obvious to mention
11:32:01 <donri> Eduard_Munteanu: hold on
11:32:01 <mightybyte> lol
11:32:16 <Cale> foldNature r s t = f where f (Rock x) = r x; f (Stream x n) = s x (f n); f (Tree n n') = t (f n) (f n')
11:32:36 <quchen> Soo would 'build . foldr f [] == id'?
11:32:55 <quchen> Eh, make that 'build $ foldr f []'
11:33:02 <donri> Eduard_Munteanu: http://hub.darcs.net/stepcut/happstack/browse/happstack-server/src/Happstack/Server/FileServe/BuildingBlocks.hs#373
11:33:08 <mightybyte> byorgey: Does "cabal sandbox whatsnew" work too? :)
11:33:18 <donri> Eduard_Munteanu: that's using the system-filepath package
11:34:36 <Cale> quchen: I think you're looking for (\xs f z -> foldr f z xs)
11:35:00 <quchen> Something like that. The above didn't typecheck at all, yes :-)
11:35:39 <Cale> Of course, this too won't quite typecheck, but only for a technical reason
11:35:43 <donri> Eduard_Munteanu: that's how i suggest doing it safely, but if you just want php-style "sanitation" ;) try this http://hackage.haskell.org/packages/archive/system-filepath/0.4.7/doc/html/Filesystem-Path.html#v:collapse
11:35:56 <quchen> Cale: ... the same reason that makes the forall necessary?
11:36:05 <Botje> w 24
11:36:06 <Cale> yeah, well, because of the forall
11:36:10 * Botje eyes his / key.
11:37:42 <Cale> Well, really because of the type of (.) and the fact that type variables aren't allowed to be instantiated with polymorphic types
11:37:49 <Cale> we can write it as:
11:37:54 <Cale> (\ys -> build ((\xs f z -> foldr f z xs) ys)) = id
11:38:21 <Cale> just can't use composition, because of the technical details about higher rank types
11:38:40 <hpaste> tomeo pasted “How do I force this to return double?” at http://hpaste.org/78726
11:39:18 <donri> Eduard_Munteanu: actually just collapse isn't safe at all, which is probably why i wrote combineSafe like that
11:39:19 <Cale> tomeo: Use fromIntegral to convert from Int to Double
11:40:05 <tomeo> thanks Cale
11:40:18 <Cale> quchen: So, let's suppose all we had were functions and we wanted to represent the list type  data List a = Nil | Cons a (List a)
11:40:59 <quchen> Alright.
11:41:02 <Cale> quchen: We don't have honest data constructors like Nil and Cons, but what we can do is to write a function which "presupposes that such functions exist", i.e. it takes them as parameters.
11:41:18 <Cale> So instead of writing Cons 1 (Cons 2 (Cons 3 Nil))
11:41:35 <Cale> we can write (\nil cons -> cons 1 (cons 2 (cons 3 nil)))
11:42:03 <Cale> build is the function which converts back from this representation to the one involving the standard data constructors
11:42:19 <quchen> Oh, that kind of sounds like the concept behind the free monad instance
11:42:40 <Cale> and foldr in some sense goes the other way (or (\xs f z -> foldr f z xs) does anyway)
11:43:14 <Cale> We can do this with any algebraic recursive datatype to represent its terms as functions.
11:43:53 <Cale> and programs in the untyped lambda calculus do this sort of thing all the time
11:44:33 <quchen> So '(\nil cons -> Cons 1 (Cons 2 (Cons 3 Nil))) [] (:) == [1,2,3]'
11:44:48 <Cale> Instead of having a natural number type  data Nat = Zero | Succ Nat, with terms like  Succ (Succ (Succ Zero)) for three, we can use functions like  (\succ zero -> succ (succ (succ zero)))
11:44:54 <Cale> yeah
11:44:57 <quchen> And the parenthesis on the left looks like the 'g' in build
11:45:06 <Cale> yeah
11:45:21 <quchen> Now if we have a producer for g, we have a list encoded as a function
11:45:30 <Cale> up to reordering of parameters, that's the same as build (\cons nil -> Cons 1 (Cons 2 (Cons 3 Nil)))
11:45:34 <Cale> errr
11:45:36 <quchen> And that one can be folded effectively?
11:45:38 <Cale> oops, caps
11:45:48 <Cale> build (\cons nil -> cons 1 (cons 2 (cons 3 nil)))
11:45:53 <Cale> = [1,2,3]
11:46:22 <quchen> I see. That's very lambda-y, representing a list as function concatenation.
11:46:46 <ceii> now the idea of the optimization is that since build and foldr just convert back and forth between the two form, when you see one followed by the other you can just drop them both
11:46:56 <ceii> s/form/forms/
11:48:22 <romildo> Is there an inverse of the intersperse function in the haskell libraries? It would be a function that takes an element and a list and splits the list at all the occurrences of the element in the list?
11:48:46 <glguy> romildo: YOu might look at http://hackage.haskell.org/packages/archive/split/0.2.1.1/doc/html/Data-List-Split.html
11:48:49 <`nand`> there's probably some--
11:48:54 <`nand`> yeah, Data.List.Split
11:49:35 <quchen> Cale: I'd say I'm understanding it 80% now. Close to phase transition! Thanks :-9
11:53:01 <Eduard_Munteanu> donri: thanks. It's kinda weird Yesod doesn't provide one though, given it has all that type-safe routing etc.
11:53:13 <Eduard_Munteanu> (was afk for a bit, sorry)
11:55:33 <nurpax> is there something funny with cabal-dev & enable-profiling: True?  I've been trying to profile my library now for a couple of days but still can't get my library functions to show up on profile (+RTS -p).  Bos's Criterion package otoh does show up on the profile when I run my benchmark
11:56:44 <Heffalump> typically library functions don't show up on profiles, because although the library is built to support profiling, it's not built to be profiled itself
11:57:41 <nurpax> Heffalump: what could cause that to happen?  isn't it enough to re-install all dependent packages that my benchmark depends on?
11:58:15 <Heffalump> nurpax: it's not to do with re-installation, it's just how cabal --enable-library-profiling works
11:58:42 <Heffalump> there are two aspects to compiling for profiling:
11:59:02 <Heffalump> the first is to make objects that support profiling at all, so that other things you are profiling can link against them
11:59:10 <nurpax> so what I've done with cabal-dev is that I have a "cabal.config" file that contains "library-profiling: True" and "executable-profiling: True" - which I pull in with --extra-config-file for cabal-dev commands
11:59:24 <Heffalump> and the second is to mark specific bits of code to actually show up on profiles
12:00:06 <Heffalump> if you rebuild the library you want to profile to say "also mark all the functions to show up on profiles", that should fix it (just going to check the flag you need for that now)
12:01:14 <Heffalump> I think it's --ghc-options=-auto-all : so do cabal install <library> --reinstall --ghc-options=-auto-all
12:01:41 <nurpax> Heffalump: I don't see anything extra in criterion's --ghc-options, I wonder why that behaves differently (http://hackage.haskell.org/packages/archive/criterion/0.6.2.0/criterion.cabal)
12:01:47 <Heffalump> ah, yes, it's all documented here: http://www.haskell.org/haskellwiki/How_to_profile_a_Haskell_program
12:01:48 <nurpax> Heffalump: I'll try that, let's see if that works :)
12:01:59 <Heffalump> nurpax: I guess criterion is the executable you're running
12:02:29 <Heffalump> --enable-executable-profiling does imply -auto-all
12:04:10 <alex_i> Hi, everyone! Is it ok to ask questions here? I've already looked in the docs, but couldn't find a correct way to handle URIs with non-latin alphabet characters in them. I've tried to use urlEncode, but non-latin string that goes in urlEncode isn't the same when I urlDecode later. Could it be some internal problem with non-latin symbols? I use unicode strings, by the way.
12:04:52 <nurpax> Heffalump: a RESULT!  thanks, -auto-all was what was missing!
12:05:27 <Botje> alex_i: what encoding are you feeding to urlEncode ?
12:05:30 <nurpax> Heffalump: I did have both executable and library profiling enabled in my cabal config, but somehow that didn't work
12:05:44 <alex_i> Botje: utf-8
12:05:51 <Botje> alex_i: or rather, where does the URL come from and in what encoding?
12:06:13 <Botje> alex_i: because Haskell Strings contain Unicode characters, not bytes.
12:06:34 <alex_i> I have a haskell source in UTF-8. URL is hardcoded in it. So It should be fine, I think.
12:06:35 <Botje> so you probably need to decode your input bytes first.
12:08:04 <alex_i> For example, when I use "urlDecode $ urlEncode "москва"" I shpuld
12:08:45 <alex_i> sorry, I should see "москва" in response, I think. But i see "\EOT<\EOT>\EOTA\EOT:\EOT2\EOT0"
12:11:01 <Botje> alex_i: well, the 'м' in your string is character 1084 in unicode.
12:11:13 <vraid> > urlDecode $ urlEncode "http://site.com"
12:11:14 <lambdabot>   Not in scope: `urlDecode'Not in scope: `urlEncode'
12:11:18 <vraid> ah..
12:11:32 <alex_i> Botje: is that a problem?
12:11:32 * hackagebot webdriver 0.5.0.1 - a Haskell client for the Selenium WebDriver protocol  http://hackage.haskell.org/package/webdriver-0.5.0.1 (AdamCurtis)
12:12:21 <neutrino> hey guys
12:12:22 <siracusa> > (ord '\EOT', ord '<', 1048 `div` 256, 1048 `mod` 256)
12:12:23 <lambdabot>   (4,60,4,24)
12:12:33 <Botje> alex_i: well, 1084 is 0x044C :)
12:12:37 <neutrino> anyone know if there are any pragmas for ghc-mod so that e.g. it doesn't lint a specific line?
12:13:51 <Botje> alex_i: so urldecode is taking the UTF-16 encoding of your characters.
12:14:01 <Botje> ehm, *urlEncode.
12:14:19 <Botje> alex_i: and very probably it expects UTF-8 or something in urlDecode.
12:14:52 <mat15> exit
12:14:53 <Botje> alex_i: I don't know much about the encodings dictated in the RFC for URLs, unfortunately.
12:15:02 <alex_i> Botje: whoa, so the string I encode isn't utf-8?
12:15:24 <alex_i> or haskell assumes it's utf-16?
12:15:33 <Botje> I think GHC uses utf-16 internally.
12:15:51 <c_wraith> GHC doesn't use anything internally.
12:17:06 <Botje> right, it would just use wide chars.
12:20:08 <alex_i> Well, does that means, that urlencode on non-ascii characters is broken? To be honest I'm still a noob in haskell, so this discussion about internal encodings is a little too much to me.
12:21:32 <Botje> alex_i: if I read wikipedia correctly, RFC 3986 mandates UTF-8 encoding for non-ascii characters in a URI.
12:22:26 <Botje> alex_i: so if urlEncode produces UTF-16 or whatever-encoded characters, it is wrong and should be shot.
12:22:41 <alex_i> Thanks
12:22:57 <Botje> (alternatively, you may file a bug and/or manually encode to UTF-8 first.)
12:23:44 <alex_i> It's funny, if a standard specifies UTF-8 as an encoding for URIs than parseURI is also broken, because it returns false for non-ascii unicode characters
12:24:07 <Cale> alex_i: Which urlEncode function is this that you're talking about?
12:24:22 <c_wraith> well.  UTF-8 that's then converted into hex pairs via url escaping
12:24:33 <Cale> ah, Network.HTTP.Base has one...
12:24:42 <alex_i> urlEncode from Network.HTTP.Base
12:25:34 <ParahSail1n> in withForeignPtr, why is the f (unsafeForeignPtrToPtr fo) preceding touchForeignPtr fo in the do {}
12:27:47 <scooty-puff> is GHC.Integer.GMP.Prim and exported module of integer-gmp?
12:27:55 <scooty-puff> integer-gmp's doc suggests its not
12:27:58 <scooty-puff> but cabal info says otherwise
12:28:14 <scooty-puff> *and exported -> an exported
12:28:36 <hpaste> Jeanne-Kamikaze pasted “Game object fun” at http://hpaste.org/78728
12:29:17 <JoeyA> ParahSail1n: touchForeignPtr doesn't really do anything.  It just tells the garbage collector that the ForeignPtr needs to be available at the time touchForeignPtr is called on it.
12:29:20 <beardedmeatanus> hi
12:29:29 <Jeanne-Kamikaze> welcome, warrior
12:29:38 <beardedmeatanus> thanks!
12:29:42 <ParahSail1n> JoeyA: ah, thanks
12:29:59 <Jeanne-Kamikaze> have you packed your lambdas ? An epic battle against the laval monad awaits you
12:30:05 <Jeanne-Kamikaze> *lava
12:30:17 <Cale> alex_i: So yeah, it looks like urlEncode is screwing up the encoding badly.
12:30:19 <shurikas> stay above monads!
12:30:24 <shurikas> monads are lava!
12:30:31 <beardedmeatanus> monads bad?/
12:30:42 <beardedmeatanus> xmonad too?
12:30:43 <jeff_s1> Wield your Arrows!
12:31:17 <JoeyA> asyncDoProc (only for Windows without -threaded) sends work to another thread, to avoid blocking the RTS.  Right?
12:31:45 <Eduard_Munteanu> We worship Freyd!
12:31:48 <alex_i> Cale: Thanks for looking into it! :)
12:31:49 <tomeo> Is there any way of doing this without getting involved with monads? replicateM 4 [1,0]
12:31:58 <JoeyA> Also, can the callback fill an MVar?
12:32:20 <JoeyA> (which would be a case where an MVar is filled by another thread in the absence of the threaded RTS)
12:32:30 <Botje> tomeo: you can write it out as [ [a,b,c,d] | a <- [1,0] , b <- [1,0], ... ]
12:32:32 <JoeyA> > replicateM 4 [1,0]
12:32:33 <lambdabot>   [[1,1,1,1],[1,1,1,0],[1,1,0,1],[1,1,0,0],[1,0,1,1],[1,0,1,0],[1,0,0,1],[1,0...
12:32:42 <tomeo> thanks Botje
12:33:35 <JoeyA> > map (showIntAtBase 2 ("01" !!)) [0..15]
12:33:37 <lambdabot>   *Exception: showList: No overloading for function
12:33:57 <JoeyA> :t showIntAtBase
12:33:58 <lambdabot> (Integral a, Show a) => a -> (Int -> Char) -> a -> ShowS
12:34:11 <JoeyA> :t map (showIntAtBase 2 ("01" !!)) [0..15]
12:34:12 <lambdabot> [ShowS]
12:34:35 <Botje> tack a "" at the end.
12:34:35 <JoeyA> foldr (.) id (map (showIntAtBase 2 ("01" !!)) [0..15]) ""
12:34:37 <JoeyA> > foldr (.) id (map (showIntAtBase 2 ("01" !!)) [0..15]) ""
12:34:39 <Cale> alex_i: For fun, try  urlDecode (urlEncode "䡥汬漬⁗潲汤")
12:34:39 <lambdabot>   "01101110010111011110001001101010111100110111101111"
12:34:56 <JoeyA> > map (($ []) . showIntAtBase 2 ("01" !!)) [0..15]
12:34:57 <theorbtwo> > urlDecode (urlEncode "䡥汬漬⁗潲汤")
12:34:57 <lambdabot>   mueval: recoverEncode: invalid argument (invalid character)
12:34:58 <lambdabot>   ["0","1","10","11","100","101","110","111","1000","1001","1010","1011","110...
12:35:15 <Botje> Cale: haha, that's cool.
12:35:17 <Cale> (not in lambdabot though, because it already screws up the encoding in another way)
12:35:20 <alex_i> Cale: LOL, very cool
12:35:26 <Botje> That also triggers the famous notepad bug, right?
12:38:39 <alex_i> Well, if we're talking about bugs. Is there any functional language you would recommend for production use? I've looked into scala, but it's too enterprisy and not as beautiful as haskell. Clojure also looks too cumbersome.
12:38:42 <crdueck> I'm trying to install haskell-src-exts from hackage with cabal. It complains that the program happy cannot be found, but I've installed happy with cabal and I can see that happy is in ~/.cabal/bin
12:39:17 <Heffalump> alex_i: what platform(s)?
12:39:23 <alex_i> nix
12:40:39 <Heffalump> I'd say Haskell is fine for production, as long as you don't expect a useful debugger - there are plenty of alternative ways of understanding and fixing problems, but you can't attach a debugger to a running program and see what's going on like you can in most other languages
12:40:43 <Botje> alex_i: I'd go for haskell or O'Caml
12:40:45 <jeff_s1> Probably f# is the closest you can get to a real production friendly functional language, since Microsoft will support it.
12:41:07 <jeff_s1> Maybe you can get Haskell or LISP or OCaml support somewhere.
12:42:02 <alex_i> thanks, f# is a no, unfortunately. MS doesn't support it for unix platforms
12:46:57 <tomeo> What is the proper way of saving a list from replicateM? Im trying list <- replicateM 13 [1,0] in a do-block but I'm getting errors all the time.
12:47:38 <Botje> tomeo: in a do block os what monad?
12:47:46 <Botje> *of what monad.
12:48:08 <Botje> tomeo: if your monad is not the list monad, you should replace that line by "let list = replicateM 13 [1,0]"
12:48:14 <Cale> alex_i: In general, Haskell is rather good for systematically keeping bug counts down. String manipulation is inherently a bit hairy though, sadly. If you wanted to go to a bit of trouble, you could encode things about the state of URL encoding/sanitisation in the types though.
12:48:23 <tomeo> Botje: I solved it by using let, thanks anyway
12:48:41 <shachaf> tomeo: In the future you should be more specific than "I'm getting errors all the time"
12:48:55 <Botje> tomeo: that's what i said!
12:49:16 <Cale> (I don't mean to say that string manipulation is hairy in Haskell specifically, it's just really quite bug prone in any language)
12:49:31 <tomeo> Botje: you did! awesome :)
12:49:38 <alex_i> Cale: "encode things about the state of URL encoding/sanitisation in the types though" - could you elaborate this please? :)
12:50:03 <jeff_s1> I love string manipulation in Haskell, since it has great libraries for array and linked list representations.
12:50:29 <jeff_s1> Most languages only have libraries for arrays of chars, and nothing great for linked lists of anything at all.
12:51:54 <Cale> alex_i: So, you could make some newtypes of String or ByteString or Text depending on the use-case, and not export the data constructor from the module in which they were defined, and have your newtypes represent strings in various particular encodings -- you could then ensure statically that things were encoded or decoded when creating or inspecting values of your new data types.
12:52:44 <Cale> I'm sure there must be a non-broken urlEncode function hanging around somewhere...
12:53:52 <ethercrow> there is urlEncode :: ByteString -> ByteString in Network.HTTP.Types
12:54:13 <ethercrow> and it works if given a bytestring from Data.ByteString.UTF8
12:54:21 <Cale> hmm
12:54:45 <Cale> ah, yeah, that sounds reasonable
12:55:06 <alex_i> import Network.HTTP.Types fails for me
12:55:14 <Cale> It's really unfortunate that the String version is broken. Perhaps someone should suggest to the maintainter to do a conversion to and from UTF-8 bytestring
12:55:20 <alex_i> is that a non-standard package?
12:55:56 <jeff_s1> It's part of the http-types package.
12:56:16 <kuznero> Hello All!
12:56:21 <jeff_s1> hi
12:56:22 <Cale> hello
12:56:40 <ethercrow> Cale: is there a (easy) way to get utf8 sequence for Data.Char?
12:56:49 <kuznero> I have a short question wrt GTK+3 support in Haskell. Does anybody know how is it going?
12:57:10 <ethercrow> it's kind of scary to suggest a new dependency for network package
12:57:39 <Cale> ethercrow: Probably the easiest way to do it right is just to use the text package
12:58:07 <Cale> ethercrow: You can pack or unpack a String to Text, and you can also encode or decode Text to variously encoded ByteStrings
12:59:58 <kuznero> gtk2hs seems to only support GTK+2... :(
13:02:17 <kuznero> No GTK experts today?
13:03:42 <jeff_s1> kuznero - maybe ask the gtk2hs mailing list? http://projects.haskell.org/gtk2hs/development/
13:04:14 <ParahSail1n> on a raid mount, might increasing the block size for lazy bytestring be advantageous?
13:04:48 <kuznero> jeff_s1: thanks! will do!
13:05:03 <jeff_s1> Sarah - ya, if you make the block size to match the raid stripe size, that could potentially help I guess.
13:06:05 <npl> hello, in the definition of findMax at http://hackage.haskell.org/packages/archive/containers/0.5.1.0/doc/html/Data-Set.html#g:12 why is a not constrained to be a member of the Ord typeclass?
13:06:56 <Botje> npl: because findMax doesn't need to do any comparisons. It's just the right-most element of the tree
13:07:08 <jeff_s1> npl - probably because the ordering is already done by the structure of the Set
13:07:29 <npl> ah, thanks
13:08:08 <c_wraith> You should be able to construct a single-element set of a non-Ord type, by the way.
13:08:16 <c_wraith> in which case, findMax would still work
13:21:05 <tomeo> Is there a function that will take two values and a function and return the max by that function?
13:21:48 <DMcGill_> > max `on` negate $ 3 5
13:21:50 <lambdabot>   Precedence parsing error
13:21:50 <lambdabot>      cannot mix `Data.Function.on' [infixl 0] and ...
13:22:01 <DMcGill_> > (max `on` negate) 3 5
13:22:01 <clahey> i.e. maxBy a b f = if f a > f b then a else b
13:22:03 <lambdabot>   -3
13:22:08 <c_wraith> why the heck is on defined as infixl 0?
13:22:15 <c_wraith> That seems terrible
13:22:22 <DMcGill_> hmm, that doesn't work
13:22:42 <c_wraith> yes it did
13:22:44 <otters> aren't all backticked functions defined as infixl 0?
13:22:49 <clahey> @hoogle a -> a -> (a -> b) -> a
13:22:49 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
13:22:49 <lambdabot> Data.Ord comparing :: Ord a => (b -> a) -> b -> b -> Ordering
13:22:49 <lambdabot> Prelude maybe :: b -> (a -> b) -> Maybe a -> b
13:22:54 <c_wraith> oh, but it didn't do what was specified
13:23:04 <c_wraith> otters: no, they're infixl 9 unless otherwise specified
13:23:10 <otters> oh
13:23:15 <otters> haha, I guess that's different
13:23:16 <DMcGill_> comparing negate 3 5
13:23:20 <DMcGill_> > comparing negate 3 5
13:23:21 <lambdabot>   GT
13:23:42 <clahey> It depends on whether you want 3 or -3 as the answer.
13:23:56 <clahey> I think just writing your own would be reasonable.
13:23:58 <DMcGill_> there doesn't seem to be a "maxBy function"
13:24:05 <tomeo> DMcGill_: thanks, but that returns the value after the function, not the actual value
13:24:27 <sclv> ?hoogle max
13:24:27 <lambdabot> Prelude max :: Ord a => a -> a -> a
13:24:27 <lambdabot> Data.Ord max :: Ord a => a -> a -> a
13:24:27 <lambdabot> Prelude maxBound :: Bounded a => a
13:24:44 <DMcGill_> yeah, neither "max `on` f" or "comparing max" really do what you want - time to write your own helper function!
13:24:56 <tomeo> DMcGill_: okay thanks
13:24:58 <rwbarton> @type maximumBy
13:24:58 <jeff_s1> STM is very cool, but I'm kind of sad I can't interact with a database while in an STM transaction.
13:24:59 <lambdabot> (a -> a -> Ordering) -> [a] -> a
13:25:02 <rwbarton> @hoogle maxBy
13:25:02 <lambdabot> No results found
13:25:06 <jeff_s1> Or at least I shouldn't....
13:25:10 <rwbarton> > maximumBy negate [3,5]
13:25:11 <clahey> @type max
13:25:12 <lambdabot>   Occurs check: cannot construct the infinite type:
13:25:12 <lambdabot>    a0 = a0 -> GHC.Types.O...
13:25:13 <lambdabot> Ord a => a -> a -> a
13:25:22 <rwbarton> > maximumBy (comparing negate) [3,5]
13:25:24 <lambdabot>   3
13:25:25 <clahey> @type maximum
13:25:27 <lambdabot> Ord a => [a] -> a
13:25:42 <sclv> ?src maximumBy
13:25:42 <lambdabot> Source not found. You speak an infinite deal of nothing
13:25:51 <clahey> rwbarton: Nice.
13:27:11 <tomeo> thanks rwbarton
13:28:23 <sclv> haha yeah maximumBy defines its own maxBy internally: http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/Data-List.html#maximumBy
13:28:37 <rwbarton> heh
13:29:02 <rwbarton> unfortunately I doubt ghc will inline/unroll that
13:30:22 <ion> They see me unrollin’, they hatin’.
13:31:19 <antiox_> I wish to use OpenGL with vertex arrays. In C I can cast the vertex array to an array of my own vector type and modify the vectors in place, all without doing any allocations. Would I be able to do such non-allocating in-place operations in Haskell?
13:34:40 <tomeo> I'm being told "Stack space overflow: current size 8388608 bytes. Use `+RTS -Ksize -RTS' to increase it.". But I don't understand how to increase it
13:35:32 <Litie> I am bot
13:35:39 <Litie> I come from source of Greedi humanoid
13:35:51 <S11001001> tomeo: it's probably actually telling you that you have a stack consumption bug
13:35:59 <rwbarton> @botsnack
13:35:59 <lambdabot> :)
13:36:35 <Litie> consumption , noun - to consume
13:36:40 <tomeo> S11001001: okay. where would I start looking for that?
13:36:43 <Canar> antiox_: I imagine map operates in-place, no reason for it not to.
13:37:13 <S11001001> tomeo: your folds and recursions
13:37:16 <shachaf> GHC doesn't even turn reverse [] into [] :-(
13:37:37 <Cale> antiox_: The OpenGL library exposes access to vertex arrays via Ptr anyway, so yes.
13:38:03 <Cale> Canar: There's a very good reason for it not to
13:38:06 <rwbarton> antiox_: you can do C-style direct memory management in Haskell using Foreign.* modules
13:38:07 <antiox_> Cale: But can I cast the Ptr to my Vector type?
13:38:25 <Ralith> is there a better objective and precise way to represent color than as an intensity distribution function over the visible spectrum?
13:38:28 <Cale> Depends what your Vector type is...
13:38:56 <antiox_> Of course I want my Vector type layout to be exactly three GLfloats.
13:39:05 <Litie> fRecursion is the process of repeating items in a self-similar way. For instance, when the surfaces of two mirrors are exactly parallel with each other the nested images that occur are a form of infinite recursion. The term has a variety of meanings specific to a variety of disciplines ranging from linguistics to logic. The most common application of recursion is in mathematics and computer
13:39:06 <Litie> science, in which it refers to a method of defining functions in which the function being defined is applied within its own definition. Specifically this defines an infinite number of instances (function values), using a finite expression that for some instances may refer to other instances, but in such a way that no loop or infinite chain of references can occur. The term is also used more
13:39:06 <Litie> generally to describe a process of repeating objects in a self-similar way.
13:39:20 <glguy> >_>
13:39:27 <glguy> Litie: Don’t do that, please
13:39:32 <burbul> I'm getting an error 'Map.find: element not in the map'. Is there any way of getting hold of the file and line number?
13:39:41 <Litie> entry #1337 added to database wordform=recursion
13:39:57 --- mode: ChanServ set +o glguy
13:40:14 <antiox_> rwbarton: my question could be rephrase as: can I operate on raw data with Haskell types?
13:40:26 <burbul> (I have an annoying feeling it's happening in code I'm calling, because i don't even import find in the file I think the error is happening in.)
13:40:33 <shachaf> What's a "raw data"?
13:40:37 <tomeo> S11001001: foldl1' to the rescue. Thanks for helping out.
13:40:47 <antiox_> shachaf: raw data of the OpenGL vertex array
13:40:47 <S11001001> tomeo: np
13:40:57 <rwbarton> it sounds like a storable vector would meet your needs
13:41:01 <rwbarton> (mutable vector)
13:41:12 <ethercrow> burbul: try +RTS -xc
13:41:16 <rwbarton> however I don't really know anything about OpenGL
13:41:20 <burbul> thank you.
13:41:20 <shachaf> @where rts-xc
13:41:20 <lambdabot> ghc -prof -fprof-auto -rtsopts -osuf .p_o foo.hs && ./foo +RTS -xc # print stack traces on unhandled exceptions
13:41:49 <Cale> Yeah, Data.Vector.Storable works for accessing data via a ForeignPtr or Ptr.
13:42:33 <rwbarton> how is Data.Vector.Storable different from Data.Array.Storable, anyways
13:42:34 <aavogt> burbul: if it's in a library you're calling (that doesn't come with ghc) you probably have to re-install them with profiling enabled
13:42:51 <antiox_> Cale: I know I can access data -- my question is, can I operate on that data -- without making copies -- with a Haskell type, say a Vector type.
13:43:25 <rwbarton> I guess the vector version doesn't do index computations
13:43:39 <rwbarton> which can be good or bad
13:44:05 <burbul> do I have to switch on  -prof -fprof-auto -osuf, or is that just an example?
13:44:32 <shachaf> You have to compile with profiling to use -xc
13:44:58 <rwbarton> you don't have to use -osuf .p_o, but it is tidier. the rest is necessary
13:45:07 <burbul> Thanks . what's the point of changing the obj. file extensions?
13:45:13 <burbul> Just so you can tell whether particular files have profiling or not?
13:45:23 <Cale> rwbarton: Well, he's been saying Vector, so I suspected that's what he wanted. Of course Array works too.
13:46:06 <Litie> load:meme=l2code baddy
13:46:10 <burbul> >Warning: 'ghc-options: -prof' is not necessary and will lead to problems when...
13:46:21 <burbul> I guess I replace that with --enable-executable-profiling?
13:46:29 <shachaf> Yep.
13:46:39 <shachaf> You cn specify profiling options to cabal separately.
13:46:40 <burbul> thanks
13:46:53 <Cale> antiox_: Yes, there's "unsafeFromForeignPtr" which you could perhaps use.
13:46:55 --- mode: glguy set +q Litie!*@*
13:46:55 <burbul> Sorry, didn't understand that last remark
13:48:24 <burbul> ack, I thought --enable-executable-profiling was a ghc option.
13:48:31 <burbul> Is there a way of putting it in the .cabal file?
13:48:48 <shachaf> Just run cabal configure --enable-executable-profiling
13:49:04 <shachaf> cabal takes care of doing the profiling build for you.
13:49:41 <Attic> Hello! Does anyone have any good resources about the need for Type Classes? I'm having a hard time figuring out why I would want to use type classes or what they're useful for. Any papers / tutorials about this subject would be appreciated!
13:49:51 <antiox_> Cale: I have control over the array so it would be the other direction -- giving the result of unsafeToForeignPtr to OpenGL. It still seems that when I step through the Storable I'm making copies and putting them back. Are you sure there is no allocation?
13:50:30 <eikke> Attic: polymorphism
13:50:32 <burbul> Hmmm... now it wants me to install profiling versions of all my libraries, and
13:50:35 <rwbarton> what do you mean *no* allocation
13:50:37 <burbul> It looks like I have to walk the entire dependency tree manually.
13:50:48 <monochrom> $HOME/.cabal/config has a line for library-profiling: True/False
13:50:52 <antiox_> Cale: imagine modify an array of vectors via rotating or some such
13:50:54 <burbul> thank you
13:51:35 <antiox_> (I know rotating can be done in OpenGL, that was a bad example -- some morph)
13:52:01 <antiox_> (which of course can't be done in OpenGL)
13:52:10 <Attic> eikke: In that sense it's actually comparable with OOP classes isn't it?
13:52:53 <antiox_> rwbarton: I mean that I don't want to copy the vector element, create a new vector element, and copy it back to the array
13:52:59 <eikke> Attic: hmh, I'm no expert, but when comparing them to something from the OO world, I tend to think of abstract classes and/or interfaces, not classes in general
13:53:01 <rwbarton> that is essentially free
13:53:12 <burbul> monochrom: I've switched that to true, but after that is there any easy way to make it reinstall all the libraries I need with profiling versions?
13:53:13 <monochrom> type class gives you operator overloading. for example see the types of ==, +
13:53:28 <rwbarton> your element is just three Doubles, right
13:53:35 <monochrom> no, you have to manually figure out which packages to rebuild
13:53:37 <burbul> (Sorry to be asking so many questions... I don't normally mess with cabal much)
13:53:48 <burbul> ouch
13:53:52 <antiox_> rwbarton: yes, typically three GLfloat
13:54:02 <antiox_> (whatever GLfloat happens to be)
13:54:14 <monochrom> it is easiest to erase and just ask for what you really need
13:54:24 <burbul> are t profiling versions slower when one doesn't have profiling switched on?
13:54:46 <monochrom> both profiling and non-profiling files are built
13:54:50 <shachaf> burbul: Yep.
13:55:35 <burbul> umm... so the profiling libraries are slower, but when one doesn't have profiling on it links with the non-profiling libraries?
13:56:00 <antiox_> rwbarton: I'll have to run some tests, but it seems pretty likely that walking through a Storable to modify vectors ultimately makes calls to malloc at each step.
13:58:01 <monochrom> yes
13:59:52 <burbul> thank you.
14:04:54 <rwbarton> antiox_: oh no certainly not malloc!
14:05:13 --- mode: glguy set -q Litie!*@*
14:05:14 <rwbarton> it would use the Haskell allocator which is just a few instructions (increase a pointer, compare and jump when GC is needed)
14:05:19 --- mode: glguy set -o glguy
14:05:45 <rwbarton> and when the GC does run, most of your objects will be dead and then collecting them is free
14:07:38 <rwbarton> efficient Haskell programs often allocate several gigabytes per second
14:08:15 <rwbarton> If you're lucky, ghc will manage to use registers for everything anyways
14:08:31 <antiox_> rwbarton: the point was that this is a special case where doing anything other than in-place operations on existing data is catastrophic.
14:08:44 <rwbarton> but you have to do some other computation, right
14:08:52 <rwbarton> for the operation itself
14:09:05 <rwbarton> that's going to be more expensive than the allocation in almost every case
14:09:13 <rwbarton> so it can't be that catastrophic
14:09:27 <antiox_> rwbarton: yes, but it's all +, * on strict data, presumably all stack-allocated
14:09:41 <rwbarton> like, just iterating over the vector has the same cost as allocating
14:10:01 <rwbarton> so already you cannot lose more than a factor of 2
14:10:43 <rwbarton> anyways, try it and see, certainly
14:12:25 <rwbarton> it's quite possible ghc can inline the whole read/compute/write and do no allocation
14:14:15 <antiox_> ok I'll see what happens, thanks
14:28:28 <acowley> Is there an alternative to the gnuplot package for plotting things without cairo?
14:29:57 <acowley> Best haddock page ever? http://hackage.haskell.org/packages/archive/gnuplot/0.5.0.1/doc/html/Graphics-Gnuplot-Terminal.html
14:30:44 <c_wraith> looks like henning wrote it
14:30:55 <c_wraith> ah, look, he did.
14:30:59 <Eduard_Munteanu> Or edwardk :P
14:31:22 <acowley> c_wraith: Yes, and I've complained about it before. I accept that a big part of the problem is that haddock just disagrees with Henning so violently.
14:31:27 <Eduard_Munteanu> But it isn't nearly as fancy as he'd make it.
14:32:06 <robbe-> Can one easily check (in ghci or so) what typeclass(es) certain functions belong to?
14:32:25 <acowley> Yes, kmettage would include a gnuplot binding with far more higher rank types. (C a, C a, C a) => (forall a. a -> b) -> T -> (forall t. C a => a -> T) -> b
14:32:36 <acowley> robbe-: Does :info give you what you want?
14:33:06 <madjestic> hey guys, is there a function, equivalent to ghci :t?
14:33:06 <shachaf> 22:57 <elliott> (ParseCategory c f k i j l, Get f ~ (k -> i), j `i` l) => KFunctor c (State# RealWorld) ByteString (f j l) -> f (Result f)
14:33:36 <robbe-> acowley: It just states in which module the function is defined, afaics.
14:33:47 <Eduard_Munteanu> acowley: anyways, 'chart' is nice
14:33:52 <Eduard_Munteanu> @hackage chart
14:33:52 <lambdabot> http://hackage.haskell.org/package/chart
14:33:55 <Clint> :t typeOf
14:33:56 <lambdabot> Typeable a => a -> TypeRep
14:34:15 <acowley> Eduard_Munteanu: chart depends on cairo
14:34:19 <robbe-> acowley: But, it does give me what I want for other functions apparently; I just tried :i (<)
14:34:21 <Eduard_Munteanu> Hrm.
14:34:23 <robbe-> acowley: Thanks.
14:35:01 <shachaf> The Haddock for Henning-style code are great.
14:35:22 <lispy> shachaf: sacrasm alert!
14:35:31 <acowley> They're hilarious when you're not depending on them, I'll give them that.
14:35:40 <acowley> They have a certain Zen simplicity to them.
14:37:10 <simon> shachaf, what's Henning-style code?
14:37:29 <lispy> module Foo where data T = ...
14:37:37 <lispy> class C a where
14:37:45 <lispy> module Bar where data T = ...
14:37:57 <lispy> simon: rinse repeat always using T and C for types and classes.
14:38:44 <lispy> Because haddock doesn't qualify names it can be such a nightmare to read the types
14:40:05 <Eduard_Munteanu> That looks a bit like Agda, wrt module use.
14:43:08 <hpaste> me pasted “ElegantoCodisimo?” at http://hpaste.org/78732
14:43:27 <madjestic> I am looking for a function, equivalent to python's type(foo())
14:43:41 <madjestic> is there such thing?
14:43:50 <timmy_wooden_hea> Is there an *elegant* way to somehow embed the helper function into the primary function in either instance, or is it just too ugly/not worth it? ---> http://hpaste.org/78732
14:44:06 <shachaf> madjestic: Yes, but it's quite likely that you don't want to use it.
14:45:04 <shachaf> timmy_wooden_hea: You could make a fold for MultEnc
14:45:20 <timmy_wooden_hea> a fold, you say
14:45:32 <shachaf> foo :: (Int -> a -> b) -> (a -> b) -> MultEnc a -> b
14:45:57 <shachaf> Oh, and I guess in the other direction you need an unfold. :-)
14:46:16 <shachaf> What do you mean by "embed"?
14:46:39 <shachaf> You can always put the helper function in a "where" if you just don't like the name being there.
14:47:14 <timmy_wooden_hea> Well, rather than frankenstein more library functions together, I meant keeping the helper functions "intact" inside the original function
14:47:43 <shachaf> Oh, so the only issue is that you don't like the top-level definitions?
14:48:43 <glguy> madjestic: There is Data.Typeable.typeOf, but you wouldn’t use it like you might use Python’s type() built-in function
14:48:52 <timmy_wooden_hea> I guess so. I don't mind them too much, and I don't know what an experienced haskeller would do in this circumstance, but I thought it would be good to know my options.
14:49:37 <madjestic> shachaf: I am studying the code and I am curious about types of certain functions.  I have by guesses, but I would love to verify my guesses.  I though of putting a bunch fo putStrLn's in between and set it to output type
14:49:59 <shachaf> madjestic: Does ghci's :t not help here?
14:50:53 <timmy_wooden_hea> shachaf: to be clear, I can put those functions "in" a where, guards and all?
14:50:59 <madjestic> shachaf: no, it does not show all the functions from the code in question
14:51:29 <madjestic> glguy: I will try that, thanks
14:52:06 <glguy> madjestic: typeOf won’t work on polymorphic functions. It also won’t work on any types that haven’t implemented the Typeable typeclass
14:52:11 <shachaf> timmy_wooden_hea: Yep.
14:52:34 <shachaf> timmy_wooden_hea: foo x = ... where helper y | y == 1 = ... | otherwise = ...
14:53:02 <fmap> madjestic: you can try ghc-mod, it's rather smart about types of things
14:53:39 <tac-tics> @type typeOf
14:53:40 <lambdabot> Typeable a => a -> TypeRep
14:54:01 <tac-tics> You can have a typeclass instance over a polymorphic type at all, can you?
14:54:35 <glguy> are you considering extensions?
14:56:07 <c_wraith> tac-tics: you mean, you can't have a type variable in a TypeRep?
14:56:08 <tac-tics> glguy: sure
14:56:28 <tac-tics> c_wraith: I meant I can't have a polymorphic type in a typeclass instance
14:56:28 <c_wraith> tac-tics: I seem to recall a library for polymorphic TypeReps
14:56:38 <tac-tics> c_wraith: like "Show forall a. a -> a"
14:57:09 <c_wraith> @hackage polytypeable
14:57:09 <lambdabot> http://hackage.haskell.org/package/polytypeable
14:57:14 <c_wraith> Of course it's Oleg's work
14:57:17 <tac-tics> instance Show (forall a. a -> a) where show x = ...;
14:57:41 <c_wraith> You can do it if you trap the type variable in an existential.  But that doesn't really answer your question
14:57:52 <hpaste> glguy pasted “closest thing I could come up with” at http://hpaste.org/78733
14:58:13 <c_wraith> Ok, polytypeable is frightenin
14:58:14 <c_wraith> g
15:25:59 <ParahSail1n> how do you tell ghc to link in an object file for ffi
15:26:21 <c_wraith> I generally let cabal tell ghc to do that.
15:27:31 <dcoutts_> ParahSail1n: just list the .o file when linking
15:29:34 <ParahSail1n> dcoutts_: ah thanks
15:41:37 * hackagebot ghc-vis 0.6 - Live visualization of data structures in GHCi  http://hackage.haskell.org/package/ghc-vis-0.6 (DennisFelsing)
15:51:52 <mapf> that is recommended fixed size list library?
15:53:00 <mapf> something like data List :: Nat -> * -> * where Nil :: List Zero a; Cons :: a -> List l a -> List (Succ l) a
15:56:37 * hackagebot bound 0.5.0.2 - Making de Bruijn Succ Less  http://hackage.haskell.org/package/bound-0.5.0.2 (EdwardKmett)
16:04:04 <Clint> is there an Alternative instance for Either String somewhere?
16:06:37 * hackagebot hyphenation 0.2.1.4 - Configurable Knuth-Liang hyphenation  http://hackage.haskell.org/package/hyphenation-0.2.1.4 (EdwardKmett)
16:11:39 * hackagebot hoodle 0.1.0 - Executable for hoodle  http://hackage.haskell.org/package/hoodle-0.1.0 (IanWooKim)
16:11:41 * hackagebot hoodle-core 0.7.1 - Core library for hoodle  http://hackage.haskell.org/package/hoodle-core-0.7.1 (IanWooKim)
16:11:43 * hackagebot hyphenation 0.2.1.5 - Configurable Knuth-Liang hyphenation  http://hackage.haskell.org/package/hyphenation-0.2.1.5 (EdwardKmett)
16:29:04 <dmwit> > Left "foo" <|> Right 3
16:29:06 <lambdabot>   Right 3
16:29:13 <dmwit> Clint: I guess so.
16:29:59 <shachaf> For some reason :i doesn't show that instance.
16:30:30 <dmwit> experimental computer science
16:30:43 <Clint> hmm, where is that coming from?
16:31:38 <dmwit> C.M.Error
16:32:19 <dmwit> discovered via more experimental computer science: I made a guess and asked ghci if I was right
16:32:33 <Clint> thanks
16:32:34 <mm_freak> Cale: may i /query?
16:33:13 <Cale> mm_freak: sure
16:35:26 <Cale> mm_freak: still here?
16:56:39 * hackagebot machines 0.2.1.1 - Networked stream transducers  http://hackage.haskell.org/package/machines-0.2.1.1 (EdwardKmett)
16:58:14 <ocharles> "Ceci n'est pas une pipe"
16:58:15 <ocharles>  
16:58:21 <ocharles> haha, I missed that on my initial read of machines :)
16:58:44 <monochrom> what is n'est?
16:59:08 <ocharles> "is not"?
16:59:16 <monochrom> thanks
16:59:33 <ocharles> it means "This is not a pipe" -- https://en.wikipedia.org/wiki/The_Treachery_of_Images
17:00:31 <Vyn> monochrom: n'est pas is is not
17:00:54 <monochrom> what is the role of "pas" there?
17:01:28 <Clint> negation
17:02:09 <typoclass> monochrom: iirc the negation is a 2-part thing and is indicated by "ne ... pas", or "n' ... pas"
17:02:23 <monochrom> interesting
17:02:42 <typoclass> i-ne-teresting pas
17:03:05 <hpaste> burbly annotated “ElegantoCodisimo?” with “ElegantoCodisimo? (annotation)” at http://hpaste.org/78732#a78737
17:05:23 <hpaste> burbly annotated “ElegantoCodisimo?” with “ElegantoCodisimo? (annotation)” at http://hpaste.org/78732#a78738
17:06:06 <burbul> hmm... original poster has vanished.
17:08:06 <sipa> monochrom: there are other forms, like ne ... jamais (never), ne ... rien (nothing), ne ... personne (nobody), ...
17:08:26 <sipa> ne already tells you in advance something is going to be negated :)
17:10:55 <typoclass> oh, i guess you can see how the 2-part thingy works with "ne ... plus" ~ "not ... anymore". seems like english is directly parallel on this. "not singing anymore" etc.
17:12:08 <sipa> yes, except "jamais" on itself means "never", not "ever"
17:13:06 <burbul> FWIW, it originally meant ever
17:13:37 <burbul> There tends to be a trend where these things occur with the negative particle, and eventually the negative particle is dropped and the other half picks up the negative meaning.
17:13:54 <burbul> so 'pas' originally meant 'thing', but came to pick up negative force
17:14:04 <sipa> interesting
17:14:14 <burbul> Exactly the same thing happens in Welsh.
17:15:54 <typoclass> who knows, maybe in another million years, english will have dropped the "not" from "the kitty is not bathing anymore", so that you can say "kitty is bathing anymore"
17:16:47 <glguy> kitty is bathing never
17:17:27 <glguy> What was the example in English that has this behavior?
17:19:29 <typoclass> glguy: how do you mean? folks were talking about how negation in french is "ne something pas"
17:20:08 <sipa> so... what did 'pas' originally mean?
17:21:51 <typoclass> sipa: "not not". together with ne, it's "not not not", hence "not"
17:21:53 <typoclass> =)
17:22:46 <hpc> so french is a constructive logic, and to convey anything useful you have to double-negate every sentence?
17:26:14 <aristid> hpc: that explains a lot of things.
17:28:21 <burbul> sipa: i was wrong...
17:28:22 <burbul> From Latin passus. Its use as an auxiliary adverb comes from an accusative use (Latin nec...passum) in negative constructions – literally ‘not...a step’, i.e. ‘not at all’ – originally used with certain verbs of motion.
17:28:55 <burbul> But anyway, it's a mistake to expect languages to behave too logically!
17:29:28 <burbul> (I spend most of my time trying to extract the logical content of natural language.)
17:31:07 <burbul> (and indeed use Haskell to do so.)
17:48:22 <DMcGill_> http://www.csse.monash.edu.au/~damian/papers/HTML/Perligata.html
17:48:47 <hpaste> rosie pasted “atomicity and recursion” at http://hpaste.org/78741
17:49:20 <shachaf> hi rosie
17:49:40 <LAMMJohnson> Hey there, guys.
17:49:52 <LAMMJohnson> I'm lookign to convert a Word64 into a string of 8 characters. Any thoughts?
17:50:05 <glguy> typoclass: Someone said that there were examples in not-French of words taking a negative meaning
17:50:18 <rosie> I am using three threads to update an mvar, and each thread calls itself recursively. How can I execute the recursive function? The only STM to IO function I can find is "atomically", but "atomically" does not work on a recursive function. Any ideas? In the attached code, the line I need to change is marked "THIS LINE NEEDS TO CHANGE"
17:50:19 <glguy> I just wondered what an English example would be (if there was one)
17:50:27 <rosie> Hi shachaf!
17:51:07 <shachaf> rosie: MVars have nothing to do with STM/"atomically".
17:51:13 <shachaf> Are you sure you mean to be using them together?
17:51:38 <typoclass> glguy: don't know if there's examples for that, i just meant "who knows, it might be possible" :-)
17:52:16 <shachaf> rosie: STM involves TVars (and TMVars and TChans and so on), not MVars
17:52:21 <parcs`> LAMMJohnson: using the binary or cereal package, you can serialize the Word64 into a ByteString
17:52:36 <rosie> right, I'm trying to figure out why "inc" used them. I didn't write "inc".
17:52:45 <shachaf> You can't use an MVar in an STM transaction because readMVar :: ... -> IO ..., and you can only do STMy things.
17:52:45 <LAMMJohnson> parcs`: Excellent, thankyou.
17:52:47 <shachaf> Oh.
17:53:02 <shachaf> That looks like broken code as far as I can tell.
17:53:24 <shachaf> rosie: Wait, "MVar" isn't Control.Concurrent's MVar, it's something that comes from some module "MVar" that you didn't paste.
17:53:48 <shachaf> Maybe that module implements MVars in terms of STM.
17:53:52 <rosie> ah! You're right.
17:53:54 <shachaf> (If so, that's a terrible naming schem. :-( )
17:54:20 <rosie> shachaf: It's in another file that implements an MVar as a TVar Maybe
17:54:26 <shachaf> OK.
17:54:31 <shachaf> You should call that a TMVar. :-)
17:54:36 <shachaf> (That's its name in the standard library.)
17:54:45 <rosie> not my choice (;
17:54:59 * shachaf thought you were the teacher these days!
17:55:36 <rosie> haha not yet (:
17:56:17 <rosie> any idea on the atomic recursion?
17:56:28 <shachaf> Oh, I didn't read the actual code.
17:56:59 <shachaf> This looks a lot like homework. :-)
17:57:40 <rosie> shachaf: That's because it is!
17:59:44 <arthurdent> how do i get every y for [(x),(y)] ?
18:00:31 <shachaf> rosie: I'm not quite sure what the question is.
18:00:37 <shachaf> (What class is this, by the way?)
18:00:45 <parcs`> arthurdent: what
18:00:47 <c_wraith> arthurdent: that question isn't quite clear. Do you mean "what's a function with type [(a, b)] -> [b] ?"
18:00:49 <shachaf> arthurdent: I'm also not quite sure what your question is. :-) What's [(x),(y)]?
18:00:51 <ski> > map snd [(3,"like"),(2,"this"),(8,"?")]
18:00:53 <lambdabot>   ["like","this","?"]
18:00:56 <arthurdent> obviously i meant [(x,y)]
18:01:01 <shachaf> Obviously!
18:01:03 <arthurdent> shachaf: thanks
18:01:10 <c_wraith> arthurdent: think in types. Types are good.
18:01:16 <parcs`> [(x),(y)] is a valid expression and pattern
18:01:32 <ski> > [y | (x,y) <- [(3,"like"),(2,"this"),(8,"?")]]
18:01:34 <lambdabot>   ["like","this","?"]
18:01:47 <monochrom> but note that it's syntax sugar for (x);((y):_)
18:01:49 <arthurdent> ski: aha! i was trying to do something like that but it wasn't coming to me
18:01:59 <monochrom> err, (x):((y):[])
18:02:18 <rosie> shachaf: cs242 - Programming Languages. We're learning about concurrency and parallelism. I've posted the output of the program. Does it help you understand that running "inc" recursively in an atomic block won't work, because the first thread will block all others, including the call to itself?
18:02:44 <c_wraith> STM doesn't block
18:02:45 <hpaste> rosie pasted “output of Main.hs” at http://hpaste.org/78742
18:02:54 <c_wraith> or rather, it doesn't lock out other threads.
18:03:09 <c_wraith> Individual transactions can block, but that happening doesn't prevent other threads from proceeding
18:03:11 <shachaf> c_wraith: Well, it will in this case.
18:03:46 <shachaf> rosie: I know what that program is doing; I'm not sure what you're asking about it.
18:04:48 <Nisstyre-laptop> rosie: I haven't looked at your code, but are you trying to implement concurrency here or parallelism?
18:04:59 <c_wraith> Oh.  I see.  use of TMVar makes it so that every other thread using it will choke if the TMVar is empty
18:05:20 <shachaf> Right. It behaves a lot like MVar.
18:05:21 <monochrom> wait, "atomically (takeMVar mvar)"?
18:05:24 <c_wraith> TMVar is a poor choice there, except for instructional purposes
18:05:33 <c_wraith> monochrom: pretend it says TMVar, not MVar
18:05:36 <shachaf> monochrom: "MVar" actually means "TMVar"
18:05:41 <monochrom> I see
18:05:47 <hpc> @hoogle TMVar
18:05:47 <lambdabot> Control.Concurrent.STM.TMVar module Control.Concurrent.STM.TMVar
18:05:48 <lambdabot> Control.Concurrent.STM.TMVar data TMVar a
18:05:48 <lambdabot> Control.Concurrent.MVar putMVar :: MVar a -> a -> IO ()
18:05:52 <Nisstyre-laptop> rosie: looks like I joined after you posted the code, could you give the link?
18:06:02 <shachaf> Nisstyre-laptop: It's at the top of hpaste.org
18:06:10 <Nisstyre-laptop> cool, ok
18:06:37 <Nisstyre-laptop> shachaf: there are two by rosie, should I be looking at the second latest one?
18:06:45 <shachaf> One is the input and one is the output.
18:06:48 <Nisstyre-laptop> ah ok
18:06:55 <shachaf> Hmm, this program isn't quite as straightforward as I thought.
18:07:18 <Nisstyre-laptop> yeah this seems like a weird example of concurrency
18:09:12 <shachaf> OK, now that code makes me a bit sad. Are you sure it's supposed to work this way?
18:09:33 <shachaf> Oh, wait. I misread it again!
18:09:35 * shachaf sighs.
18:11:42 <monochrom> may I see module MVar?
18:13:10 <rosie> yes
18:13:47 <hpaste> rosie pasted “MVar.hs” at http://hpaste.org/78744
18:16:09 <shachaf> It looks to me like MVar.hs has a bug.
18:17:07 <monochrom> I don't see it. what is the bug?
18:17:13 <shachaf> putMVar
18:17:21 <shachaf> ghc -Wall would catch it. :-)
18:17:32 <shachaf> Hmm, no.
18:17:36 <shachaf> Hmm, yes.
18:17:56 <hpc> i am tempted now to write a compiler called "the"
18:18:03 <hpc> just so i call tell people to use "the -Wall"
18:18:04 <shachaf> hpc: THE Haskell Environment?
18:18:19 <monochrom> Oh! haha
18:18:52 <Nisstyre-laptop> hpc: and call libraries "bricks"
18:19:10 <aristid> Nisstyre-laptop: this is not ruby!
18:19:34 <Nisstyre-laptop> the -Wall detected an error in your brick
18:19:35 <aristid> we name things after concepts in abstract algebra, not after silly puns
18:19:57 <shachaf> rosie: Get into the habit of using -Wall!
18:20:04 <shachaf> -Wall catches bugs.
18:20:15 <monochrom> -Wall-E is a shorthand for -Wall -Werror
18:20:30 <Nisstyre-laptop> aristid: I will make it my lifelong goal to introduce a concept called "bricks" into abstract algebra
18:20:32 <shachaf> If only.
18:20:38 <Nisstyre-laptop> I don't have any idea what it will be, but I will
18:20:45 <rosie> shachaf: Thanks! It didn't give me any warnings or errors, though
18:20:52 <shachaf> -Wall didn't?
18:21:01 <shachaf> It probably just saved the old output files.
18:21:09 <shachaf> Try `touch MVar.hs`
18:21:19 <aristid> Nisstyre-laptop: great idea!
18:21:31 <rosie> shachaf: You're right!
18:21:40 <Nisstyre-laptop> aristid: so yeah, I'm going to reverse engineer a concept from a name
18:21:49 <monochrom> a brick is a finitely generated module
18:22:06 <shachaf> There are multiple bugs in MVar.hs, actually.
18:22:12 <shachaf> -Wall won't catch them all.
18:28:26 <hpaste> rosie pasted “integer warning” at http://hpaste.org/78745
18:28:50 <shachaf> rosie: The warning I meant is in MVar.hs, not Main.hs
18:29:05 <shachaf> The defaulting isn't a big deal. You can turn that warning off for all it matters.
18:29:54 <rosie> shachaf: I don't see any warnings in MVar.hs
18:30:59 <shachaf> Hmm, maybe your version of GHC is different from mine.
18:31:03 <shachaf> Did you touch the file?
18:31:34 <shachaf> Or save in your editor, or whatever. GHC won't bother recompiling a file that hasn't been modified.
18:33:07 <rosie> shachaf: you got it. Thanks!
18:35:48 <rosie> shachaf: sweet! It all worked!
18:36:00 <shachaf> rosie: OK.
18:36:06 <shachaf> You still have a bug in MVar.hs. :-)
18:36:27 <rosie> I replaced Just v with Just newval, if that's what you're referring to
18:36:41 <shachaf> Yes, that's the one that -Wall catches.
18:36:42 * hackagebot silently 1.2.4.1 - Prevent or capture writing to stdout and other handles.  http://hackage.haskell.org/package/silently-1.2.4.1 (TrystanSpangler)
18:37:02 <rosie> shachaf: When I say it all worked, I mean all my threads didn't block each other, and the program outputted the correct result. Thank you!
18:37:14 <shachaf> But there's also another one, unless I'm wrong, in one of the functions you don't use. But I might be wrong.
18:37:39 <shachaf> At any rate, good luck.
18:39:00 <pchiusano> edwardk: is there a reason that Machine is not a monad?
18:39:23 <pchiusano> it seems to have a monad instance - it is basically the normal list sequencing monad
18:41:06 <rosie> shachaf: er, could you give me a hint? I think tryTakeMVar works, because the TVar contains either Nothing or Just something, and either way, that's what I want to return. I think tryPutMVar works, because if the value in the TVar is NOthing, I want to write the new value, "val", to the TVar and then return true, and if there's something already in the TVar, I want to return false.
18:41:41 <shachaf> Hmm, maybe the functions are underspecified.
18:42:21 <shachaf> Given that tryTakeMVar has no documentation other than the type.
18:42:37 <shachaf> You might find the documentation of the "normal" tryTakeMVar helpful.
18:44:20 <rosie> shachaf: Thanks! I need to set the TVar's value equal to Nothing if it was Just something.
18:46:21 <shachaf> That's the one I was thinking of.
18:47:01 <rosie> (:
18:56:46 <JoeyA> What do you call a directory like ~/.ghc/x86_64-linux-7.0.3 ?
18:56:51 <JoeyA> Is that a "package database" ?
18:57:19 <JoeyA> Or is that what ~/.cabal is ?
18:57:45 <shachaf> I just call it ~/.ghc/x86_64-linux-7.0.3
18:58:37 <JoeyA> Yes, but what is 2+3 equal to?
18:59:13 <shachaf> 4
19:00:23 <shachaf> pchiusano: The machines channel is #haskell-lens, it seems.
19:00:40 <simon> for small values of 3.
19:02:24 <shachaf> hi chessguy
19:02:41 <chessguy> saluations and other such pleasantries
19:02:59 <Ralith> there's actually a #haskell-lens?
19:03:05 <shachaf> Of course.
19:03:17 <shachaf> Why do you think there's so little lens discussion here and in #-blah?
19:03:22 <Ralith> >_>
19:03:52 <shachaf> "#hasell-lens: the cool channel to be in??"
19:04:22 <chessguy> "#haskell-lens: we promise, no concavity searches!"
19:04:43 <shachaf> chessguy: Lenses are "pretty cool huh"
19:05:01 <chessguy> meh. not my gig
19:17:37 <Ralith> can anyone advise how to set haskell-mode up to handle a nonstandard ghci prompt?
19:18:17 <shachaf> The standard advice I've heard is "don't".
19:19:08 <sclv> the suggestion was as i recall to set yr prompt from a script wrapping ghci
19:19:23 <sclv> and haskell-mode therefore still can pick up normal ghci in the normal path and use the normal prompt
19:22:49 <Ralith> okay, why is haskell-mode blocking on C-c C-l despite me having deleted ~/.ghci
19:23:54 <tertl3> what is the flag to compile to C/C++?
19:24:05 <tertl3> in GHC
19:24:47 <c_wraith> it's gone in modern versions of GHC
19:24:55 <c_wraith> but it used to be -fvia-c
19:25:01 <tertl3> oh
19:25:16 <c_wraith> If you really want to compile to C, take a look at JHC
19:25:28 <tertl3> i dont i was just gonna try it
19:25:36 <tertl3> but I like GHC
19:25:52 <tertl3> i saw a benchmark of them by IBM
19:26:04 <tertl3> oh wait htat was python interpreters
19:26:11 <shachaf> C/C++ isn't a language.
19:26:22 <shachaf> GHC can still compile to slow portable C, I think.
19:26:38 <c_wraith> there is a new option in new versions of GHC to compile with llvm - it gives better low-level optimizations
19:26:51 <shachaf> c_wraith: Sometimes. :-)
19:27:06 <tertl3> llvm as opposed the C runtime?
19:27:14 <shachaf> C runtime?
19:27:19 <Cale> -fvia-c didn't produce working C code though, it produced code whose GCC output had to be mangled to run
19:27:23 <c_wraith> no, it uses the same runtime
19:27:48 <tertl3> llvm is just an optimization pass?
19:27:52 <c_wraith> it just uses llvm to generate assembly from the STG representation, instead of the built-in code generator
19:28:26 <tertl3> oh
19:28:43 <tertl3> i am newb to haskell internals
19:29:04 <c_wraith> well, then, don't worry about the details yet. Suffice to say there are a bunch of steps
19:29:30 <c_wraith> and it just uses llvm for the last one (before linking, anyway)
19:30:55 <shachaf> Why do you want to compile to C?
19:31:31 <tertl3> i was looking to see if anyone had implemented a haskell compiler on arm yet
19:31:50 <c_wraith> there has been work for getting GHC to run on arm, actually
19:31:51 <tertl3> that is keeping me from getting an android
19:31:51 <shachaf> GHC can generate ARM code
19:32:03 <shachaf> Running on Android /= generating ARM
19:32:05 <tertl3> i mean a native arm compiler
19:32:15 <shachaf> It's a lot more trouble, though someone has gotten it working at least once.
19:32:43 <tertl3> i will buy a tablet when haskell runs on it
19:32:54 <tertl3> well, will compile on it
19:34:49 <tertl3> has anyone successfully ran the haskellVM on a VM yet?
19:35:00 <tertl3> anyone here?
19:35:13 <Cale> What Haskell VM?
19:35:18 <shachaf> Is that a Yesod thing?
19:35:23 <shachaf> If so you should ask in #yesod.
20:10:30 <shachaf> Hmm, https://github.com/23Skidoo/ghc-parmake
20:28:48 <Ghoul_> So
20:29:09 <Ghoul_> Could I foreign export stdcall DllMain :: ... from a haskell lib?
20:31:24 <shachaf> I don't know about the details of Windows DLLs, but probably you need something more than that to initialize the RTS and so on.
20:31:42 <Ghoul_> Ah, damn
20:31:50 <Ghoul_> I really didn't want to use a C stub
20:31:55 <startling> how should I create a Gen Word16 for quickcheck such that it's less than or equal to 1023?
20:33:08 <shachaf> "Warning  There are serious limits on what you can do in a DLL entry point. To provide more complex initialization, create an initialization routine for the DLL. You can require applications to call the initialization routine before calling any other routines in the DLL."
20:33:18 <shachaf> I bet you don't want to do that in Haskell anyway.
20:34:09 <Nereid> startling: choose
20:36:24 <startling> Nereid: ah, thank
20:36:25 <startling> s
20:38:02 <Ghoul_> So
20:38:07 <Ghoul_> Is there no way to start the haskell runtime
20:38:10 <Ghoul_> from within haskell
20:38:42 <shachaf> What would be the point of that?
20:40:59 <Ghoul_> shachaf: well, the DllMain is quite a simple thing to write
20:41:02 <Ghoul_> just involves using a guard
20:41:08 <Ghoul_> or a switch
20:41:34 <Ghoul_> but I'm not sure if the haskell runtime would get loaded if the dll were loaded w/ LoadLibrary
20:41:38 <Ghoul_> and DllMain automatically called
20:46:03 * geekosaur is not sure that would be sufficient
20:46:30 <geekosaur> is the idea to attach the DLL and then make calls into it, or is the DllMain itself the sole entry point?
20:53:29 <Ghoul_> geekosaur: the dllmain is the sole entrypoint
20:53:35 <Ghoul_> dont need to call any other exports
20:54:02 <Ghoul_> dllmain spawns a thread, installs some hooks and does some looping haskell'ey logic
20:54:28 <Ghoul_> host process will load it w/ LoadLibrary once
21:43:02 <Pseudonym> [A-blah
21:43:11 <Pseudonym> Whoops.
21:43:13 <Pseudonym> Blah indeed.
21:47:25 <fitz_oh> Got a question
21:47:46 <fitz_oh> Using Data.Text, I'm trying to replace multiple characters (a list of them)
21:48:01 <fitz_oh> replace is Text -> Text -> Text -> Text
21:48:13 <fitz_oh> how do I get to [Text] -> Text -> Text -> Text
21:48:58 <liyang> Replacing all of them with the same thing?
21:49:09 <fitz_oh> yes
21:49:17 <fitz_oh> substituting all punctuation w/ spaces
21:49:39 <fitz_oh> well, almost all punct
21:49:44 <fitz_oh> I'm leaving apostrophes
21:50:00 <latro`a> I think you should be able to foldl
21:50:19 <statusfailed> Can I add compiler flags in a *cabal file ? I want to compile with RTS and -O2
21:51:25 <latro`a> myreplace replaced replaceWith text = foldl' (\acc txt -> replace txt replaceWith acc) text replaced
21:51:33 <latro`a> should work
21:52:08 <latro`a> very bad names, but you get the picture
21:52:11 <shachaf> Or you could use T.map and do them all at once.
21:52:14 <td123> statusfailed: GHC-Options
21:52:18 <shachaf> Which may or may not be more efficient.
21:52:44 <latro`a> erm
21:52:46 <latro`a> oh
21:52:47 <latro`a> I see
21:52:52 <latro`a> encode it in a Char instead
21:52:52 <statusfailed> td123: oh, cheers
21:53:01 <latro`a> yes, that's probably more efficient
21:53:03 <fitz_oh> yeah
21:53:06 <latro`a> erm
21:53:07 <latro`a> not a Char
21:53:09 <latro`a> a Char->Char
21:53:13 <shachaf> latro`a: I don't know about that.
21:53:16 <latro`a> is the mapping actually Char->Char?
21:53:22 <latro`a> or is it a mapping of substrings
21:53:27 <fitz_oh> map is Char-> Char
21:53:33 <latro`a> no, I mean your function
21:53:38 <latro`a> it sounds like it's Char->Char
21:53:39 <latro`a> like
21:53:46 <latro`a> f '!' = '!'
21:53:47 <latro`a> erm
21:53:52 <latro`a> f '!' = ' '
21:53:56 <latro`a> f '_' = ' '
21:53:58 <latro`a> ...
21:53:59 <latro`a> f x = x
21:54:07 <fitz_oh> yeah, I think that works
21:54:08 <latro`a> am I understanding correctly?
21:54:28 <latro`a> if that's the case then Text.map is probably more straightforward
21:54:41 <fitz_oh>  f x = if punct x then ' ' else x
21:54:46 <latro`a> right
21:54:47 <liyang> :t \ things replacement -> foldr (.) id $ flip T.replace replacement <$> things
21:54:48 <lambdabot> Couldn't find qualified module.
21:55:12 <latro`a> not sure why foldr
21:55:30 <hpaste> sw2wolf pasted “The hint package frustrates me !” at http://hpaste.org/78754
21:56:03 <shachaf> That'll do less copying but maybe replace is written more efficiently.
21:56:08 <Ralith> @djinn Monad m => m (a, b) -> (b -> m c) -> m (a, c)
21:56:09 <lambdabot> -- f cannot be realized.
21:56:12 <Ralith> aw
21:56:14 <shachaf> Ah, but it's not (unless some kind of fusion magic is relevant).
21:56:26 <Ralith> shachaf: go!
21:57:02 <shachaf> Ralith: INSERT COIN
21:57:13 <Ralith> ;_;
21:58:17 <shapr> sw2wolf: Funny, I think I have that version of that package installed just fine.
21:58:33 <shapr> sw2wolf: But I will say I used hint *heavily* over the summer and it worked well.
21:59:10 <sw2wolf>  shapr: i tested it many times, it always reports such a error
21:59:18 <shapr> sw2wolf: Just checked, I *do* have hint-0.3.3.5 installed on ghc 7.4.1
21:59:31 <sw2wolf> just a simple `cabal install hint`
21:59:31 <shapr> sw2wolf: What version of ghc are you using?
21:59:47 <shapr> sw2wolf: Well, that's what worked for me, so maybe something else has gone wrong?
21:59:58 <sw2wolf> Glasgow Haskell Compiler, Version 7.0.3, for Haskell 98, stage 2 booted by GHC version
21:59:59 <sw2wolf> 6.10.4
22:00:16 <sw2wolf> on freebsd 9
22:00:38 <Pseudonym> @djinn Maybe (a,b) -> (b -> Maybe c) -> Maybe (a,c)
22:00:38 <lambdabot> f a b =
22:00:38 <lambdabot>     case a of
22:00:38 <lambdabot>     Nothing -> Nothing
22:00:38 <lambdabot>     Just (c, d) -> case b d of
22:00:38 <lambdabot>                    Nothing -> Nothing
22:00:40 <lambdabot>                    Just e -> Just (c, e)
22:00:55 <Pseudonym> Unfortunately, djinn doesn't know abot [].
22:01:12 <shapr> sw2wolf: Hackage shows that  0.3.3.5 does build on ghc 7.6, are you able to install ghc 7.4 or later and try that?
22:01:43 <sw2wolf> shapr: thx, i installed it from freebsd ports
22:01:53 <Pseudonym> @free f :: M (a,b) -> (b -> M c) -> M (a,c)
22:01:53 <lambdabot> $map_M k . p = q . h => $map_M ($map_Pair g k) (f x p) = f ($map_M ($map_Pair g h) x) q
22:01:59 <shapr> sw2wolf: Installed which? hint or ghc 7.4+ ?
22:02:28 <sw2wolf> shapr: there is no ghc7.4 in freebsd port, just ghc 7.0.4 now
22:02:43 <shapr> Hm, I can't help you there.
22:03:07 <sw2wolf> shapr: i will wait for the new ghc port, thx
22:03:11 <shapr> ok
22:04:44 <fitz_oh> got it working, thanks all
22:04:44 <fitz_oh> http://pastebin.com/ZXLBBC5R
22:04:47 <mauke> The paste ZXLBBC5R has been copied to http://hpaste.org/78755
22:08:03 <perdent> Does haskell have any vulnerbilities?
22:08:22 <johnw> it is not immune to bad programmers
22:11:15 <startling> perdent, ice and dragon
22:11:36 <johnw> we have a minus 2 saving throw against mutation
22:11:53 <perdent> startling: ?
22:16:47 <ski> @free bot :: a
22:16:47 <lambdabot> f bot = bot
22:17:44 <c_wraith> what trac ticket was the typechecker bug recently discussed?
22:17:46 <perdent> So are there vulns in haskell code?
22:18:11 <perdent> like in other langs you get format string
22:18:13 <perdent> vulns
22:18:14 <c_wraith> perdent: sure. code that does the wrong thing can be always be vulnerable. Code that doesn't do the wrong thing *may* not be vulnerable
22:18:18 <perdent> is that possible in haskell
22:19:23 <c_wraith> depends on your definition of "wrong"
22:19:47 <perdent> c_wraith: Something that can be exploited, and can cause detrimental affects
22:19:49 <c_wraith> The language is memory safe by default, though.  You have to use native libs or unsafe functions to get around that.
22:20:10 <perdent> c_wraith: What is it not safe by default?
22:21:03 <c_wraith> The language provides IO functions. A badly written program can mess up with them and delete all your files. No language can prevent that.
22:21:47 <perdent> IO monads
22:22:39 <c_wraith> forget the word "monad". It's not important.
22:22:47 <c_wraith> haskell has IO.
22:23:12 <c_wraith> IO is inherently unsafe.
22:23:57 <Pseudonym> Therefore Haskell is inherently unsafe, and Socrates is a penguin.
22:24:21 <c_wraith> the core haskell language does have memory safety, though.
22:24:33 <tertl3> hrm
22:24:42 <c_wraith> Which means you need to go outside the core language to corrupt memory in such a way as to cause buffer overflows
22:25:01 <perdent> e.g?
22:25:05 <c_wraith> Or related problems involving writing to bad places in memory
22:25:46 <c_wraith> using the FFI (foreign function interface, for binding to native code) is the main way to go outside the core language.
22:26:00 <c_wraith> .. at least in a way that allows memory safety to be violated
22:26:15 <tertl3> unsafe C#
22:26:23 <c_wraith> unmanaged, I think it's called in C#
22:26:35 <tertl3> yes
22:26:38 <tertl3> same thing
22:26:43 <Canar> Newsflash: running code can compromise a system.
22:26:45 <tertl3> broadly speaking
22:27:14 <tertl3> i can break my system wiht haskell?
22:27:25 <c_wraith> certainly! IO exists!
22:27:33 <tertl3> i doubt it
22:27:36 <tertl3> prove it
22:27:49 <c_wraith> you can write a program to become root and delete your file system.  Then, when the program prompts you for it, provide your root password.
22:28:04 <tertl3> hmm
22:28:09 <tertl3> ok
22:28:30 <tertl3> but the OS would still be there right
22:28:30 <Pseudonym> main = System.Process.runCommand "killall init"
22:28:38 <tertl3> or would it delte that too?
22:28:49 <c_wraith> if it runs as root, it can delete anything it wants
22:28:55 <Pseudonym> tert13: If you can destroy your system from the command line, you can do it from Haskell.
22:29:04 <c_wraith> modulo SElinux or the like preventing it
22:29:18 <tertl3> ok
22:29:35 <Pseudonym> You need to try very hard, though.
22:29:37 <tertl3> SE linux always in fedora
22:29:55 <tertl3> it helps sometimes
22:30:46 <c_wraith> anyway, haskell is a general-purpose programming language that can interact with the OS. It can do anything to the OS that you tell it to do.
22:31:21 <c_wraith> It doesn't run inside a system security sandbox
22:31:48 * hackagebot aeson-lens 0.4.1.0 - Lens of Aeson  http://hackage.haskell.org/package/aeson-lens-0.4.1.0 (HideyukiTanaka)
22:31:50 <Nisstyre-laptop> tertl3: GRSec is a good solution
22:31:58 <Nisstyre-laptop> tertl3: it does a lot of stuff to harden Linux
22:33:15 <edwardk> The Lens of Aeson sounds like a pretty epic fantasy novel.
22:34:10 <c_wraith> hmm.  That sounds *really* handy, if it provides zippers for getting around Aeson's Value type
22:34:58 <edwardk> c_wraith: you need to be careful as a number of the lens operations there aren't legal traversals/lenses
22:35:08 <edwardk> but it is darn convenient i admit
22:35:21 <tertl3> i will install ubuntu tommorow and start doing my haskell from there
22:37:55 <sw2wolf> Who knows the version of GHC in OpenBSD 5.2 ?
22:46:48 * hackagebot linear 0.4.1 - Linear Algebra  http://hackage.haskell.org/package/linear-0.4.1 (EdwardKmett)
22:51:49 * hackagebot monadic-arrays 0.2.1.2 - Boxed and unboxed arrays for monad transformers  http://hackage.haskell.org/package/monadic-arrays-0.2.1.2 (EdwardKmett)
22:56:49 * hackagebot vector-instances 3.2 - Orphan Instances for 'Data.Vector'  http://hackage.haskell.org/package/vector-instances-3.2 (EdwardKmett)
22:59:00 <ski> @palomer
22:59:00 <lambdabot> You're all nuts
22:59:16 <shachaf> @protontorpedo
22:59:17 <lambdabot> is haskella lisp?
22:59:29 <ski> @keal
22:59:29 <lambdabot> its because the timeline diverges and past events themselves unhappen
23:16:49 * hackagebot parseargs 0.1.3.4 - Command-line argument parsing library for Haskell programs  http://hackage.haskell.org/package/parseargs-0.1.3.4 (BartonMassey)
23:20:50 <rx007> hi
23:20:53 <statusfailed> When I try to install cabal-dev, it seems to want to downgrade everything, is that because of dependencies on 'old' Cabal?
23:21:02 <statusfailed> rx007: hi
23:22:04 <rx007> guys how can i use eclipse ide in haskell development?
23:22:48 <johnw> rx007: search for "Eclipse FP"
23:23:14 <rx007> thanks johnw
23:25:19 <Raynes> Oh my.
23:25:55 <Raynes> I love getting hackage upload tweets. Whenever I need a library it tends to fall into my lap with a tweet.
23:26:07 <edwardk> johnw: around?
23:26:45 <edwardk> johnw: 4 of 4 test suites (4 of 4 test cases) passed. Installing library in /Users/ekmett/.cabal/lib/lens-3.6/ghc-7.4.2 Registering lens-3.6...  I'm not getting the issue you did.
23:27:15 <johnw> hi
23:27:30 <johnw> can you give me your exact steps?
23:28:56 <edwardk> cabal install --enable-tests
23:29:09 <johnw> ok, one sec
23:29:15 <edwardk> if you ghc-pkg describe lens what version of containers shows up in your depends list?
23:30:05 <Raynes> I need to find Bart Massey and give him a big ol' hug.
23:30:09 <edwardk> the line you cited is wrapped in an #ifdef around the version of containers, so i'm wondering if you have something right on the border of the change or i miscalculated it some how
23:30:10 <johnw> i have 0.2.2.1 in my sandbox
23:30:14 <edwardk> RayNbow`TU: oh?
23:30:33 <edwardk> johnw: 0.2.2.1 or 0.4.2.1 ?
23:30:43 <Raynes> Raynes is no rainbow.
23:30:44 <johnw> 0.2.2.1
23:30:52 <johnw> ./sandbox/package-db/unordered-containers-0.2.2.1-d70d5ccb1df11dbbbaac89571b1ee46d.conf
23:30:54 <johnw> hmm
23:30:58 <johnw> there is no regular "containers"
23:31:03 <edwardk> containers, not unordered-containers
23:31:04 <johnw> maybe it's coming from outside the sandbox
23:31:28 <edwardk> its probably taking the one installed with the platform
23:31:39 <johnw> so, how do I run ghc-pkg and yet refer it to the lens I have installed in the sandbox?
23:31:54 <edwardk> there is some incantation i never remember
23:33:08 <edwardk> johnw: if you look in sandbox/package-db/lens-3.6.*.conf what does the dependency for containers say?
23:34:16 <johnw> good idea
23:34:52 <johnw> containers-0.4.2.1-75f143aa39a3e77a1ce2300025bdd8ce
23:35:41 <edwardk> so that should be taking the < 0.5.0 branch of the ifdef
23:36:05 <edwardk>   traverseMin = index $ \f m -> case IntMap.minViewWithKey m of     Just ((k,a), _) -> (\v -> IntMap.updateMin (const v) m) <$> f k a
23:36:27 <edwardk> rather than the 0.5.0 branch:     Just ((k,a), _) -> (\v -> IntMap.updateMin (const (Just v)) m) <$> f k a
23:36:39 <johnw> hmm
23:36:49 * hackagebot punycode 1.0 - Encode unicode strings to ascii forms according to RFC 3492  http://hackage.haskell.org/package/punycode-1.0 (MylesMaxfield)
23:37:33 <edwardk> 0.4.2.1: updateMin :: (a -> a) -> IntMap a -> IntMap a
23:38:05 <edwardk> 0.5.x: updateMin :: (a -> Maybe a) -> IntMap a -> IntMap a
23:38:22 <edwardk> so so long as MIN_VERSION_containers is working, you should be fine.
23:39:14 <edwardk> the only potential infelicity here is that if cabal doesn't set MIN_VERSION_containers, I do: #ifndef MIN_VERSION_containers\n#define MIN_VERSION_containers(x,y,z) 1\n#endif
23:39:35 <edwardk> so i'm wondering if its from how you ran the test
23:40:31 <edwardk> i think i know the culprit
23:40:33 <johnw> so far i'm running the test as part of the stackage build
23:40:34 <edwardk> its fixed in HEAD
23:40:35 <johnw> yeah?
23:40:38 <edwardk> yeah
23:40:46 <edwardk> its that the coctests don't specify a containers version
23:40:53 <edwardk> rather they don't specify that we need containers
23:40:53 <johnw> ah, hmm
23:41:20 <edwardk> so they take whatever the system version is and i'm betting you have 0.5.0 installed or something too
23:42:57 <shachaf> johnw: You shouldn't have containers 0.5 installed.
23:43:09 <shachaf> (Though it's good to have found this bug.)
23:46:51 * hackagebot lens 3.6.0.1 - Lenses, Folds and Traversals  http://hackage.haskell.org/package/lens-3.6.0.1 (EdwardKmett)
23:47:05 <edwardk> johnw: feel like running a stackage build with that?
23:47:30 <johnw> sure
23:47:42 <edwardk> i'll try it in my big integration test with the dozens of other packages but that'll take a while ;)
23:57:13 <cizra> Hi, I've got something of an embarrassingly stupid question )= I'm trying to generate validator-happy XHTML Strict with Blaze, but can't figure out how to add the xmlns attribute to html tag. It's just not in the attributes.
23:57:26 <cizra> But it is present here: http://hackage.haskell.org/packages/archive/blaze-html/0.4.1.7/doc/html/src/Text-Blaze-Html5-Attributes.html
23:57:49 <cizra> so now I'm left to wonder if my version is too old, or Blaze doesn't support standards-conformant XHTML Strict, or something entirely else.
23:58:09 <shachaf> Well, checking whether your version is too old is easy enough. :-)
23:58:22 <shachaf> Is "xmlns" just not in scope?
23:58:39 <mm_freak> cizra: blaze-html certainly supports XHTML 1.0 Strict, since that's what hamlet used to generate by default
23:58:51 <mm_freak> (nowadays everyone just generates HTML 5)
23:58:54 <shachaf> Note that Html5 /= XHtml5
23:59:03 <cizra> Erh. Which standard should I use?
23:59:06 <shachaf> (Is there even such a thing as XHTML 5?)
23:59:11 <b____> no
23:59:17 <shachaf> It exports a module by that name, at least.
23:59:22 <b____> eww
23:59:24 <cizra> shachaf: Yes, GHC says not in scope.
23:59:26 <mm_freak> cizra: if you want a standard, use XHTML 1.0 Strict
23:59:41 <b____> if you want to be post 1995, use HTML5 \o/
23:59:48 <cizra> :-D
23:59:56 <shachaf> cizra: Are you importing .Attributes?
