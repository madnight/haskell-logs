00:00:07 <pedawan> hi guys. i'm trying to define my own data type for natural numbers. I have: data Nat = Zero | Succ Nat    now how can i print it out with print?
00:00:14 <Lethalman> M30W, no let's say I have a string "map", then I'd like to get the map function
00:00:26 <ion> pedawan: Add “deriving Show”
00:00:28 <Lethalman> pedawan, derive from Show
00:00:52 <robs> replacing sequence with parallel from parallel-io made no difference in here. what am I doing wrong? http://hpaste.org/79940
00:01:09 <M30W> Lethalman: let f = map "map" ?
00:01:15 <M30W> f is your function
00:01:58 <Lethalman> M30W, I can use strings instead of function names?
00:02:20 <pedawan> ah ok! thanks! :-)
00:02:23 <Lethalman> M30W, that code raises an error
00:02:29 <M30W> Lethalman: I think we're on different pages
00:02:33 <Lethalman> M30W, indeed
00:02:40 <M30W> eh. let f x = map "map" x
00:02:50 <M30W> hmm
00:02:51 <M30W> idk
00:02:56 <M30W> oh
00:03:24 <M30W> let f x = map x "map"
00:03:25 <Lethalman> M30W, for example: http://docs.oracle.com/javase/7/docs/api/java/lang/Class.html#getMethod%28java.lang.String,%20java.lang.Class...%29
00:03:38 <Lethalman> there I can get a method given its name
00:04:08 * M30W doesn't know what you're asking?
00:04:08 <Lethalman> so for example if I have "somefunc" I'd like to get the function somefunc
00:04:17 <Lethalman> introspection, reflection...
00:04:36 <Lethalman> M30W, do you use python?
00:04:40 <M30W> No
00:04:43 <Lethalman> what other language do you use?
00:04:47 <Lethalman> C?
00:04:50 <lewurm> Lethalman: not exactly what you want, but related: http://mainisusuallyafunction.blogspot.co.at/2010/11/obtaining-name-of-function-in-haskell.html
00:05:20 <Lethalman> lewurm, yes, need the opposite
00:05:31 <M30W> Many, but haven't really focused on any exactly; but shell scripts, I can write better than most; and apparently write "fucking obfusacated shell code"
00:05:34 <M30W> lol
00:05:37 <Lethalman> lewurm, I can obviously create a mapping of some sort, but it is mostly a curiosity
00:08:41 <lewurm> I'm not sure if you even want to do that, since you will loose type safety and all those nice things at compile-time.  though, maybe Data.Typeable / Data.Dynamic is a good start to look at
00:09:12 <Lethalman> lewurm, yes I don't think I'm going to do it, but just a curiosity as whether haskell has something like that...
00:10:12 <lewurm> also, the `plugins' package is a good pointer
00:10:16 <lewurm> heh :-)
00:11:07 <Lethalman> can't find anything on the net, interesting nobody asked for something like this
00:11:41 <M30W> Lethalman: What input/output are you after exactly?
00:12:01 <Lethalman> M30W, given a string I want an existing function
00:13:51 <M30W> So like.. let f = (+5); you want "f" -> (+5) or the "Integer -> Integer"
00:14:22 <M30W> or (+5) -> f ?
00:15:09 <Lethalman> M30W, I need some function getFuncByName name = ... that given a name it returns the function that has that name
00:15:45 <M30W> 19:04       lewurm | Lethalman: not exactly what you want, but related: http://mainisusuallyafunction.blogspot.co.at/2010/11/obtaining-name-of-function-in-haskell.html
00:15:53 <M30W> I read that ^ ?
00:16:10 <M30W> Oh
00:16:17 <M30W> Yea... Good luck.
00:16:37 <robs> I want to scrap a web page and download files in parallel, but I cant seem to figure out how parallel function works. http://hpaste.org/79940
00:16:40 * M30W still quite haskell noob sorry lol.
00:16:55 <Lethalman> maybe http://hackage.haskell.org/packages/archive/reflection/1.1.6/doc/html/Data-Reflection.html not sure, i'm newbie as well
00:17:11 <M30W> robs: Need haskell? Tiny shell script ^_^ haha
00:18:21 <robs> I would prefer to get it working in haskell. :)
00:18:28 <M30W> Lethalman: I'm great with hacking haskell programs, not so much writing them from scratch. ^_^ <- Perfect for XMonad :D
00:18:51 <Lethalman> ahha
00:18:56 <M30W> robs: When you do, tell me; Cause pythonsnake and I are working on a downloader daemon.
00:19:02 <M30W> Atm, it's just a chat-like server :P
00:19:09 <M30W> (protocole speak)
00:19:39 <Guest3770> Lethalman: out of curiosity, why do you need reflection?
00:19:52 <M30W> Guest3770: "curiosity"
00:20:05 <Lethalman> Guest3770, I don't need, but I have to a do a string -> function mapping anyway
00:20:11 <Lethalman> so I either do it manually or automatically
00:20:12 <Guest3770> oh and my nick is messed up...
00:20:25 <M30W> Guest3770: Yes it is ^_^
00:20:35 <M30W> zomg: OMG!
00:20:39 <M30W> Hai buddy
00:20:42 <zomg> lol
00:20:45 <zomg> hi
00:21:08 <M30W> Wait.. Are you not who I think you are? You use archlinux?
00:21:17 <zomg> Lethalman: yeah but what's the purpose for that? I find it pretty rare to require a string lookup for functions
00:21:32 <zomg> M30W: nope
00:21:43 <M30W> Okay, you're not who I thought. :P
00:21:49 <robs> paralell is suppose to run a list of IO actions b, but It made no difference in the program I pasted
00:22:08 <M30W> robs: Async is where I'm looking
00:22:13 <M30W> Try that maybe?
00:22:17 <robs> +simultaneously
00:22:25 <M30W> Async *
00:23:04 <robs> I see? But shouldnt parallel do what I described as well?
00:24:25 <M30W> lambdabot: ping
00:24:30 <M30W> @src png
00:24:30 <lambdabot> Source not found. Maybe you made a typo?
00:24:59 <M30W> Sorry back
00:25:07 <M30W> Stupid laptop + close lid = sleep
00:28:25 <Lethalman> zomg, I'd like to port a java simulation as exercise in haskell
00:28:43 <kennyd> robs your program is correct. either create a local pool of threads or pass +RTS -NX to your program, where X is the number of threads it should run on.
00:28:54 <Lethalman> zomg, the simulation can be done in many ways, there are more algorithms hence the need to map a string (algorithm name) to the actual function
00:29:13 <kennyd> might want to take a look at this too for concurrect web scrapper: http://adit.io/posts/2012-03-10-building_a_concurrent_web_scraper_with_haskell.html
00:29:59 <Hafydd> How does one scrap web?
00:31:01 <robs> thanks!
00:31:23 <zomg> Lethalman: ah I see, perhaps it would make sense then :)
00:31:47 <Lethalman> zomg, yes, so instead of manually doing a case over the strings, I wanted to know if there was something automatic
00:31:50 <zomg> I actually did something sort of like that at one point although it was dynamically compiled code using the GHC API
00:31:56 <Lethalman> zomg, in java I simply use reflection
00:32:18 <Lethalman> zomg, got it
00:32:39 <Lethalman> in which case it would be as simple as compiling the name of the function
00:32:53 <mm_freak_> (looking at this discussion without context it seems like Lethalman is easy to excite)
00:32:56 <mm_freak_> =)
00:32:59 <zomg> lol
00:33:06 <Lethalman> ? :S
00:33:15 <Hafydd> That's what I initially thought...
00:33:17 <mm_freak_> zomg!  zomg!
00:33:37 <mm_freak_> sorry, go on =)
00:33:42 <zomg> Lethalman: well in my case, I had a module system in my application. Each module had the same name function as its entry point, so it simply compiled each module on the fly and then it was able to put the Module.entrypointname function call into a list
00:34:04 <Lethalman> yeah something like that
00:34:08 <M30W> Hafydd: Easiest way, wget in archive mode; --iforgot
00:34:11 <M30W> lol
00:38:32 <robs> this is pretty awesome how the only change between single threaded and concurrent downloader was replacing sequence with parallel
00:38:49 <M30W> robs: Indeed
00:39:59 * M30W looks at all the lets and <- and thinks..... WHERE x <- blah; y="blah"
00:40:00 <M30W> ;p;
00:40:03 <M30W> lol *
00:40:45 * M30W thinks using where can make anything cleaner.
00:57:16 <covi> If I have [a] and [a], how do I get [[a]]? E.g. f [1,2] [3,4] = [[1,2],[3,4]]
00:59:14 <zomg> conal: f a b = [a, b] ? :P
01:05:21 <covi> zomg: sorry, should be 'zipping' f [1,2] [3,4] = [[1,3], [2,4]]
01:07:29 <zomg> :t concat
01:07:31 <lambdabot> [[a]] -> [a]
01:07:47 <zomg> tbh I don't entirely understand your question =)
01:08:38 <kennyd> > zipWith (,) [1,2] [3,4]
01:08:39 <Lethalman> covi, http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html#v:transpose
01:08:40 <lambdabot>   [(1,3),(2,4)]
01:08:48 <MaybeCallMe> is a >>= b >>= c same as ((a >>= b) >>= c) or is it same as (a >>= (b >>= c)) ?
01:08:51 <kennyd> eh probably not what you want
01:11:01 <covi> Lethalman: thanks, exactly what I need
01:14:13 <Gracenotes> MaybeCallMe: for any "correct" monad they should do the same thing
01:14:20 <Gracenotes> http://www.haskell.org/haskellwiki/Monad_Laws
01:15:11 <Gracenotes> in practice it's left-associative, so you get the latter (I think)
01:15:29 <Gracenotes> in practice meaning the definition of the >>= operator
01:16:27 <robs> @src (=<<)
01:16:27 <lambdabot> f =<< x = x >>= f
01:20:22 <robs> should I use async mapConcurrently instead of parallel from parallel io for downloading files concurrently?
01:22:23 <robs> as far as I can tell parallel is for taking advantage of multiple processes when doing expensive computation, not for IO
01:23:06 <ion> @hackage async -- robs
01:23:07 <lambdabot> http://hackage.haskell.org/package/async -- robs
01:24:04 <ion> Ah, that’s what you were referring to in the first place. Yeah, that sounds like a good choice.
01:25:10 <robs> so async for IO, parallel for keeping all processors busy? did I get that right?
01:25:17 <Lethalman> does haskell use fibers or is there any fibers hackage?
01:29:27 <ion> lethalman: Haskell threads are lightweight.
01:29:35 <ion> Well, GHC Haskell threads at least.
01:30:56 <ion> robs: Something like that. The former is often referred to as concurrency (as opposed to parallelism).
01:31:16 <Lethalman> ion, ok
01:31:28 * Lethalman still has to get his mindset to all the different ways to do a thing in haskell
01:32:42 <robs> can haskell keep all the cores busy if its threads are lightweight?
01:36:47 <Gracenotes> Haskell has a hybrid model
01:37:26 <Gracenotes> very hybrid. There are many sparks at the ephemeral end of the scale, and possibly many OS threads at the other end.
01:37:59 <Gracenotes> well. GHC at least.
01:38:58 <Gracenotes> oh. this is a nice diagram. http://stackoverflow.com/a/959001/48077
01:39:45 <zomg> Shiny
01:41:22 <ion> @faq can haskell keep all the cores busy if its threads are lightweight?
01:41:22 <lambdabot> The answer is: Yes! Haskell can do that.
01:42:09 <neutrino> while you probably won't have more than a million Haskell threads
01:42:14 <neutrino> hahaha
01:42:18 <robs> :O
01:43:09 <robs> you can run million haskell threads?
01:44:01 <Gracenotes> yes you can
01:44:40 <startling> @faq can haskell run a million haskell threads?
01:44:40 <lambdabot> The answer is: Yes! Haskell can do that.
01:45:03 <zomg> @faq can haskell turn water to wine?
01:45:04 <lambdabot> The answer is: Yes! Haskell can do that.
01:45:12 <neutrino> @faq will Haskell give me a lift downtown?
01:45:12 <lambdabot> The answer is: Yes! Haskell can do that.
01:45:14 <zomg> Praise the lord!
01:45:15 <zomg> lol
01:45:29 <robs> dont think I have used a language before where you can just spawn threads like that
01:46:21 <Gracenotes> hm. more stack overflow. http://stackoverflow.com/questions/1900165/how-long-does-it-take-to-create-1-million-threads-in-haskell
01:50:32 <hughfdjackson> reading this: http://hackage.haskell.org/packages/archive/hashtables/1.0.1.8/doc/html/Data-HashTable-IO.html
01:50:44 <sgk284> hey all, quick question about Data.Ord and sorting things. I have a directed graph of nodes and want to sort them depending on their parent/child relationship.
01:50:56 <sgk284> I can do this using sortBy and a custom compare function
01:51:02 <hughfdjackson> :p it does seem like haskell got to the same place as many other multiparadigm languages in featuresuite, it just got to it backwards
01:51:16 <sgk284> but was wondering if there was something I was overlooking about making the Node an instance of Ord
01:51:33 <sgk284> and somehow including the graph data along with it, so it can test parent/child properties
01:51:42 <hughfdjackson> am i wrong to think so, RE being capable of being both imperative and declarative?
01:54:34 <Gracenotes> sgk284: assuming there are no cycles, it's still possible for there not to be an ordering between two nodes
01:54:51 <bitonic> hughfdjackson: RE?
01:55:00 <sgk284> right, in that case they'd just be Eq
01:55:01 <hughfdjackson> bitonic: regarding
01:55:15 <sgk284> the problem I'm trying to solve is a slight variation on a topological sort
01:55:28 <bitonic> hughfdjackson: your statements are very vague.  what do you mean by “haskell got it backwards”?
01:56:18 <sgk284> I guess I was just wondering if there was some trick I'm missing about sorting types that need more context than just the two items being compared
01:56:37 <hughfdjackson> most languages approach the problem by having an imperative world, and embedding the ability to do pure programming within it
01:56:39 <sgk284> but I suppose that's what sortBy is for
01:56:54 <hughfdjackson> haskell seems to have build a pure world, and then embedded imperative programming in it
01:56:57 <Gracenotes> huh... it's possible Eq might get you strange results. I can't quite think of an exact scenario.
01:57:09 <aristid> hughfdjackson: most languages don't give you a pure anything.
01:57:14 <bitonic> hughfdjackson: I can’t think of one language that has a sublanguage where purity is enforced
01:57:29 <hughfdjackson> :) well, there's purity, then there's enforced purity
01:57:33 <hughfdjackson> i get the distinction
01:57:43 <Gracenotes> If you wanted to do a sortBy thing with any degree of efficiency, you would take the transitive closure of the graph, I think.
01:57:46 <bitonic> hughfdjackson: no, there isnot
01:57:49 <bitonic> *isn’t
01:57:57 <aristid> hughfdjackson: there is no distinction. either you have a pure subset or you don't.
01:58:09 <bitonic> the whole point of “purely functional” is that you *know* it’s pure
01:58:20 <Gracenotes> There are nicer algorithms to get you a topological ordering, though.
01:58:29 <bitonic> which boys you a ton of guarantees and advantages
01:58:32 <bitonic> *buys
01:58:33 <hughfdjackson> eep; sorry, gotta bail :/ need to leave this holiday home
01:58:34 * bitonic just woke up
01:58:36 <hughfdjackson> :D ciao!
01:58:40 <bitonic> hughfdjackson: ehe, ciao
01:59:03 <robs> i may be wrong but doesnt clojure have something similar? io macro or whtaever it is
01:59:16 <sgk284> Gracenotes: right, I was looking at Data.Graph but can't find any decent examples of it's usage
01:59:34 <sgk284> and just needed to throw together a quick topolgoical sort to test something
01:59:57 <Gracenotes> ah. in the Haskell case, not sure. For better or worse, I've done some wheel re-inventing.
02:00:04 <Gracenotes> er. wrong place for hyphen.
02:00:06 <kennyd> robs marking code as io is optional in clojure. it is not enforced
02:00:21 <Gracenotes> sgk284: stronglyConnComp says it returns results in topological order
02:00:55 <Gracenotes> in the case of a DAG, every node is its own component, so that might add a slight bit of overhead
02:01:01 <Gracenotes> but will get the job done
02:01:24 <Gracenotes> oh. there's also a function called topSort >_>
02:01:29 <Gracenotes> you're looking at http://hackage.haskell.org/packages/archive/containers/0.2.0.1/doc/html/Data-Graph.html ?
02:02:13 <sgk284> Gracenotes: Yea, that seems to have what I want. Being a little new to haskell myself, it's unclear how to actually define the graph in the first place though
02:02:28 <sgk284> once that's done, it seems like every thing I need is in Data.Graph
02:02:36 <sgk284> thanks for the pointers, btw :)
02:03:12 <Gracenotes> sgk284: hm... this seems to be intended for relatively static graphs
02:03:19 <sgk284> that's fine
02:04:06 <Gracenotes> if you look at the function graphFromEdges, it makes a graph from arbitrary node-types and gives you two functions: one converts from index to node type, the other from node type to index.
02:04:55 <Gracenotes> the node index is this Vertex type, which is Int.
02:06:54 <sgk284> Gracenotes: so to define a graph with 2 nodes, A & B, with A ->B, I'd do something like: graphFromEdges [(0, "A", ["B"])] ?
02:08:41 <Gracenotes> okay. there's this key business. You pass in the graph in adjacency list format. For every item, you give (node value, an orderable form of the node called the key, a list of pointed-to nodes by their keys)
02:09:41 <sgk284> right, I guess in my trivial example the node and the key are the same
02:09:48 <sgk284> if I'm understanding this correctly
02:09:57 <Gracenotes> yes
02:10:16 <Gracenotes> hm, taking a simple line graph of strings: [("123", "123", []), ("world", "world", ["123"]), ("hello", "hello", ["world"])]
02:11:29 <sgk284> running topSort against that seems to return [1,2,0]
02:11:56 <sgk284> which 1) I think is wrong? 2) isn't using the keys we specified
02:12:02 <sgk284> 2) isn't much of a concern
02:12:05 <Gracenotes> the vertex indices are internal
02:12:07 <sgk284> I can map back as necessary
02:12:22 <Gracenotes> Basically, something like: let (graph, toNode, fromNode) = graphFromEdges adjList; map (fst3 . toNode) (topSort graph)
02:12:44 <Gracenotes> should give you ["hello", "world", "123"]
02:12:55 <Gracenotes> haven't tested.
02:14:42 <sgk284> Gracenotes: thanks! returns [["world"],["123"],[]]
02:14:48 <sgk284> but that's enough for me to play around
02:14:51 <sgk284> and figure out what's going on
02:15:02 <wuttf> I was reading everything Haskell related in the past few days and I found one guy, Jon Harrop who continously hates on haskell. WTF is wrong with that guy?
02:15:32 <Gracenotes> sgk284: hm. okay. I guess it worked out better in my head! good luck.
02:16:21 <Gracenotes> sgk284: hm, no, I actually did get ["hello","world","123"]
02:16:22 <sgk284> Gracenotes: actually, you were correct.
02:16:26 <sgk284> sorry about that
02:16:29 <sgk284> defined fst3 wrong
02:16:39 <sgk284> let fst3 (_,_,a) = a
02:16:40 <Gracenotes> sounds good
02:16:43 <sgk284> by accident :)
02:16:52 <sgk284> Gracenotes: thanks again, really appreciate the help!
02:17:09 <ion> > ("foo", "bar", "baz") ^. _3
02:17:11 <lambdabot>   "baz"
02:18:39 <Gracenotes> sure. I guess there's also FGL if you need something more dynamic, but I haven't dealt with either that or Data.Graph, and Data.Graph seems to be a nice collection of algorithms.
02:18:43 <robs> > fix error
02:18:44 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
02:18:59 <Hafydd> Heh.
02:19:29 <sgk284> Gracenotes: one last random question. toNode only takes one argument, the node id, which implies that there is a global list of nodes somewhere. does that sound right?
02:19:53 <sgk284> I would think it'd require a second arg, the graph
02:20:19 <Gracenotes> it uses some closure magic, I think.
02:20:34 <Gracenotes> once the function is no longer referenced anywhere, it would be able to gc this global list
02:21:26 <ion> > let magic = (["foo", "bar", "baz"] !!) in magic 1
02:21:28 <lambdabot>   "bar"
02:21:40 <sgk284> okay cool, thanks
02:21:43 <Gracenotes> actually, toNode is literally Data.Array.(!)
02:22:04 <Gracenotes> partially applied to an array containing the mapping
02:23:04 <ivanm> Gracenotes: Data.Graph is a nice collection of algorithms? last I checked it didn't have much in there :s
02:23:28 <sgk284> Gracenotes: that makes sense (with one graph). not sure how that works with multiple graphs (because each graph would have it's own mapping, and hence need it's own toNode function)
02:23:41 <sgk284> but I can worry about that at another time :)
02:24:17 <Gracenotes> yeah. it's all in the Data.Graph source, for whenever.
02:24:43 <robs> can someone explain how this works?
02:24:54 <sgk284> thanks, you really went above and beyond for me
02:24:59 <Gracenotes> ivanm: well. "nice" in a different sense than FGL :p
02:25:16 <ivanm> what's wrong with FGL?
02:25:41 <robs> > all ($ 5) [odd, (>1), (<10)]
02:25:42 <lambdabot>   True
02:26:05 <ivanm> robs: OK, so the list is a list of functions
02:26:07 <Gracenotes> ivanm: Data.Graph seems to be cute and compact. Kind of like Python standard library is. FGL is comprehensive.
02:26:11 <ivanm> @type [odd, (>1), (<10)]
02:26:13 <lambdabot> Integral a => [a -> Bool]
02:26:36 <ivanm> robs: all takes a function and a list and determines whether the predicate is true for all of them
02:26:39 <ivanm> @type all
02:26:40 <lambdabot> (a -> Bool) -> [a] -> Bool
02:26:50 <ivanm> since we have a list of functions, we provide an argument to all of them
02:26:53 <ivanm> @type ($5)
02:26:55 <lambdabot> Num a => (a -> b) -> b
02:27:11 <ivanm> > map ($5) [odd, (>1), (<10)]
02:27:13 <lambdabot>   [True,True,True]
02:27:58 <robs> thanks i got it i think
02:30:34 <robs> so ($5) creates a function that accepts a function and gives it 5 as argument. I am not sure why it does that though?
02:31:04 <Gracenotes> @src ($)
02:31:04 <lambdabot> f $ x = f x
02:31:10 <fmap> @unpl ($ 5)
02:31:11 <lambdabot> (\ a -> a 5)
02:31:24 <ion> > [odd, (>1), (<10)] <*> pure 5
02:31:26 <lambdabot>   [True,True,True]
02:31:32 <Gracenotes> :O
02:31:43 <ion> > sequence [odd, (>1), (<10)] 5
02:31:45 <lambdabot>   [True,True,True]
02:33:16 <srhb> robs: Do you know about sections? Putting an operator in paranthesis and leaving out one side will provide you with a function in which "the missing argument" is expected. Ie. (2/) is a function that divides 2 by something, (/2) is a function that divides something by 2.
02:34:14 <covi> Hi all. This simple code snippet of mine is terribly slow. What's wrong, and how can I improve its efficiency? http://hpaste.org/79945
02:34:16 <Gracenotes> ($), in some sense, is the argument-application operator. (well, function application.) It takes a function and an argument.
02:34:30 <robs> ah I see
02:36:27 <ion> ($) = id with a more restrictive/specialized type.
02:36:27 <sgk284> Gracenotes: heh... after a few minutes of playing around, the whole toNode thing makes total sense now
02:36:35 <sgk284> really trivial actually
02:36:40 <sgk284> not sure why I was confused
02:38:48 <Gracenotes> covi: there are a couple of quadratic things going on
02:39:37 <Gracenotes> how long does it take to run?
02:39:43 <covi> Gracenotes: it's...still running.
02:40:04 <Jafet> ($) is the Society of Lisp Therapists' two-out-of-three-doctors-preferred value-added whitespace operator
02:42:50 <Gracenotes> covi: hm. I've played around with this a bit.
02:43:34 <navaati> hi
02:43:44 <Gracenotes> so abundantNums takes a while to compute, but it's feasible. there are 6965 members in it.
02:44:24 <Jafet> The way to enlightenment is to realize that Seminumerical Algorithms will improve your computer programming much further than Project Euler.
02:44:37 <Gracenotes> then you create another list on the order of 6965*6965 members. that's about 48,511,225 members.
02:45:14 <Gracenotes> then, for each of 28,123 numbers, you check those to make sure they're not in a list of about 48,511,225 numbers
02:45:32 <Gracenotes> you end up with somewhere on the order of 1,364,281,180,675 checks.
02:45:44 <Gracenotes> it's, like, only a trillion.
02:46:56 <covi> Gracenotes: what should I do then
02:47:10 <srhb> Make a better algorithm. :-)
02:47:31 <covi> Gracenotes: I want to filter out the numbers that can not be represented by a sum of any two member in the abundantNums.
02:47:37 <Jafet> That is not even the problem, Gracenotes
02:47:51 <covi> Jafet: seminumerical algorithms?
02:47:55 <Gracenotes> Jafet: hm? what is up?
02:47:55 <Jafet> The problem is running nub on a list of 48511225 numbers.
02:48:12 <Gracenotes> Jafet: yes, and an unsorted list at that
02:48:20 <Jafet> That makes no difference
02:49:06 <Gracenotes> ah. yes, for nub it doesn't. But anyway, I'm ignoring that, as the linear scan is also at the forefront
02:49:44 <Jafet> You don't even need to have a list of the sums
02:50:30 <LMolr> Is "map w2c" ok to convert from [Word8] to String, for sending via socket?
02:50:53 <Gracenotes> Jafet: well, it's an issue of quadratic space/constant check time vs. linear space/linear check time, yes?
02:51:01 <Jafet> It won't burn down your computer, if that's what you mean by "ok".
02:51:17 <covi> Jafet: for checking if a number x is a sum, I can iterate over some subset of the number list, and do a binary search to check. But I don't know how to do this in Haskell.
02:52:05 <Jafet> There is no need to check if a given number is a sum; you only need to produce a list of the sums.
02:52:08 <Gracenotes> Jafet: also, it turns out that nub would cut down from 48,511,225 to 53,871 members.
02:52:41 <Jafet> Yes, that is why the search time is not a problem.
02:52:46 <Gracenotes> fair enough
02:52:55 <Gracenotes> covi: okay, so I got this to run in reasonable time by making abundantSums an IntSet instead of a list
02:53:06 <covi> What is an IntSet?
02:53:11 <Gracenotes> without changing the structure of the program that much
02:53:39 <Gracenotes> It is this data structure which is included with Haskell standard libraries: http://hackage.haskell.org/packages/archive/containers/0.1.0.1/doc/html/Data-IntSet.html
02:54:13 <Gracenotes> In particular -- instead of using nub, use fromList; instead of using notElem, use notMember.
02:54:35 <Gracenotes> There is a set of data structures, Data.Map, Data.Set, Data.IntMap, Data.IntSet -- which are very useful in Haskell.
02:54:40 <Jafet> @google seminumerical algorithms
02:54:42 <lambdabot> http://www.amazon.com/Art-Computer-Programming-Seminumerical-Algorithms/dp/0201896842
02:54:45 <Gracenotes> >_>
02:54:59 <Jafet> "Are ya feelin' lucky, punk?"
02:56:10 <Gracenotes> I'm not sure if I'll ever have the time to give TAOCP the reading treatment it deserves.
02:59:23 <covi> Gracenotes: can you give the modified code? I changed what you said, but it's still very slow (still running)
02:59:54 <Jafet> Perhaps you should find out which part of the program is slow.
03:00:04 <MaybeCallMe> Gracenotes: thanks
03:00:24 <covi> Jafet: "profiling?"
03:00:36 <Jafet> It's normally a good idea to make the slow parts of your program faster, instead of making the fast parts of your program faster.
03:01:54 <mm_freak_> what's Alternative without the Applicative constraint?
03:02:34 <Gracenotes> covi: hm. it takes 22s on i5 laptop. really, I just replace those two functions.
03:02:54 <mm_freak_> i.e. is there a package with that predefined?
03:03:11 <mm_freak_> Monoid1 might be a good name
03:03:35 <covi> Gracenotes: check my annotation here: http://hpaste.org/79945  took 1m16s on my i5
03:04:48 <Gracenotes> covi: yeah, not sure why, that is essentially exactly what I have.
03:05:43 <covi> Gracenotes: how did you run the program? I used runhaskell
03:06:00 <wuttf> Is it some version incompatibility? "Couldn't match expected type `bytestring-0.9.2.1:Data.ByteString.Lazy.Internal.ByteString'             with actual type `Data.ByteString.Lazy.Internal.ByteString'"
03:07:38 <Gracenotes> covi: compiled it. ... doing runhaskell makes my computer freeze up, for some reason.
03:08:50 <covi> Gracenotes: what compiler options did you use?
03:10:21 <Gracenotes> none, and with -O2. The time isn't that different between them.
03:11:24 <mm_freak_> hmm, a Free is the sum of continuation and result, also called a Coroutine
03:11:38 <mm_freak_> a Cofree is the product of continuation and result…
03:11:44 <mm_freak_> also called a Routine?!
03:12:13 <mm_freak_> in any case i like Routine much more than Continue as the name of my monad =)
03:12:34 <aristid> mm_freak_: there is a cofree monad?
03:12:41 <Gracenotes> that makes some vague amount of sense
03:12:45 <mm_freak_> aristid: yeah
03:12:52 <aristid> mm_freak_: what is it?
03:12:54 <sgk284> Quick question: Is there a way to import an operator? import Data.List (\\)
03:12:57 <sgk284> throws an error
03:13:01 <mm_freak_> aristid: newtype Cofree f a = Cofree (a, f (Cofree f a))
03:13:18 <Gracenotes> import Data.List ((\\))
03:13:27 <sgk284> thanks again :)
03:13:33 <Gracenotes> parens are a list of symbols, operators need more parens
03:13:58 <mm_freak_> aristid: it's actually a comonad, but in many cases also a monad
03:14:29 <aristid> mm_freak_: looks like... StreamT? :D
03:14:36 <mm_freak_> anyway, what i have is a more complicated version of that, which is definitely not a comonad, but very well a monad
03:14:55 <aristid> mm_freak_: Cofree Maybe = NonEmptyList, right?
03:15:11 <mm_freak_> aristid: yeah
03:15:15 <aristid> \o/
03:15:27 <covi> @hoogle listArray
03:15:28 <lambdabot> Data.Array.IArray listArray :: (IArray a e, Ix i) => (i, i) -> [e] -> a i e
03:15:28 <lambdabot> Data.Array listArray :: Ix i => (i, i) -> [e] -> Array i e
03:15:28 <lambdabot> Data.Array.MArray newListArray :: (MArray a e m, Ix i) => (i, i) -> [e] -> m (a i e)
03:15:32 <mm_freak_> i'm just wondering whether it's sensible to call that a Routine =)
03:15:49 <mm_freak_> but it does implement a kind of coroutines
03:15:59 <aristid> CocoRoutine :D
03:16:04 <mm_freak_> it implements "try again from this spot"
03:16:10 <covi> @hoogle (!)
03:16:10 <lambdabot> Prelude (!!) :: [a] -> Int -> a
03:16:10 <lambdabot> Data.List (!!) :: [a] -> Int -> a
03:16:11 <lambdabot> Data.IntMap (!) :: IntMap a -> Key -> a
03:16:27 <aristid> mm_freak_: and it satisfies all the comonad laws, and for some f also the monad laws?
03:16:35 <aristid> (Cofree, not your fancy version)
03:16:39 <mm_freak_> aristid: Cofree does, yes
03:17:00 <mm_freak_> aristid: f has to be a functor for that, of course
03:18:17 <aristid> mm_freak_: for which f is Cofree f also a monad?
03:19:19 <mm_freak_> aristid: when f is an Alternative
03:19:45 <aristid> in which edwardk package is Cofree?
03:19:54 <mm_freak_> aristid: lol, it's in 'free'
03:20:09 <mm_freak_> but it doesn't define the Monad instance
03:20:26 <mm_freak_> to get a super-fancy Cofree monad you have to wait until i release my package =)
03:20:32 <aristid> mm_freak_: make a pull request :)
03:21:22 <mm_freak_> currently i have no use for Cofree…  in particular i need something more general than Alternative, which is the reason for my question earlier
03:21:36 <mm_freak_> i need an Alternative that is not a subclass of Applicative
03:21:55 <aristid> but you still have Functor?
03:22:02 <mm_freak_> yeah
03:22:28 <aristid> mm_freak_: i think that class is not entirely unknown, in theory:)
03:23:04 <aristid> i wonder if anybody has put it in a package yet
03:23:28 <aristid> mm_freak_: what does your "fancy Cofree" look like?
03:23:31 <mm_freak_> haven't found one
03:23:55 <mm_freak_> newtype Continue e f m a = Continue (m (Either e a, f (Continue e f m a)))
03:24:56 <aristid> looks suspiciously like "Wire"
03:25:39 <mm_freak_> i noticed that by a change in the semantics i can implement a CPS monad for web applications
03:25:54 <mm_freak_> in fact there is a proof of concept on hpaste already
03:26:16 <MaybeCallMe> Why isn't State constructor exported out of Control.Monad.State ?
03:26:23 <mm_freak_> http://hpaste.org/79601
03:26:39 <mm_freak_> MaybeCallMe: there is no State constructor…  State s = StateT s Identity
03:26:45 <mm_freak_> MaybeCallMe: use 'state' instead
03:27:24 <MaybeCallMe> mm_freak_: thanks. but all the tutorials talk about state constructor. my type is :: Double -> State A B
03:27:47 <MaybeCallMe> there is no problem in the type realm
03:27:48 <mm_freak_> MaybeCallMe: historically there used to be an actual State type, but that one is gone
03:27:50 <MaybeCallMe> to say STate
03:27:57 <MaybeCallMe> mm_freak_: ah ok
03:28:15 <mm_freak_> MaybeCallMe: all pure monads are now implemented in terms of the corresponding transformers
03:28:33 <MaybeCallMe> mm_freak_: i guess they don't care about newbies
03:29:01 <mm_freak_> MaybeCallMe: changing "State" to "state" is really the only change for newbies =)
03:29:09 <MaybeCallMe> :D
03:29:59 <mm_freak_> MaybeCallMe: also mtl is not a teaching library…  it's a practical library used in many real world projects and libraries, so naturally it focusses on simplicity and flexibility
03:30:18 <MaybeCallMe> mm_freak_: what would be the teaching library
03:31:32 <MaybeCallMe> mm_freak_: it is ok.. i just was asking. i can put up with mtl
03:31:57 <chrisdone> hmm, good point
03:32:04 <chrisdone> the documentation should really mention that, i think
03:32:31 * hackagebot hoauth2 0.2.6 - hoauth2  http://hackage.haskell.org/package/hoauth2-0.2.6 (HaishengWu)
03:32:36 <mm_freak_> MaybeCallMe: there is no teaching library, i think, but most tutorials reinvent the monads anyway…  they should be updated to mention that mtl 2.x has a slightly different interface
03:32:39 <MaybeCallMe> @help
03:32:39 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
03:32:39 <aristid> mm_freak_: what's the advantage of this over coroutines?
03:32:43 <MaybeCallMe> @list
03:32:43 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
03:33:02 <mm_freak_> aristid: it returns a result /and/ a /set/ of re-entry points
03:33:13 <mm_freak_> aristid: see the paste
03:33:26 <mm_freak_> particularly see the 'main' action and the annotated example interaction
03:33:49 <aristid> mm_freak_: the actual example seems quite linear?
03:33:56 <mm_freak_> aristid: that's the point
03:34:13 <aristid> ?
03:34:24 <mm_freak_> aristid: see the interaction…  it's crucial for understanding what that monad is about
03:34:34 <mm_freak_> the first annotation contains an example interaction
03:35:04 <mm_freak_> see how the main action is written like a linear command line application, while the interaction is actually completely nonlinear
03:36:23 <mm_freak_> for that kind of interaction monad you need Cofree/Continue instead of Free/Coroutine
03:36:27 <MaybeCallMe> Why isn't (get >>= return A) :: State B A ?
03:36:31 <aristid> mm_freak_: could i enter the y before the x?
03:36:50 <mm_freak_> aristid: no…  you'll get Command rejected (because the command doesn't exist yet)
03:37:10 <mm_freak_> MaybeCallMe: try get >> return A
03:37:35 <aristid> mm_freak_: i don't get the point then, if i can only ever enter one command, why do we need a map of actions?
03:37:47 <MaybeCallMe> mm_freak_: it works! so it is an error to give a parameter to a function which doesnt want it..
03:38:08 <aristid> mm_freak_: sure i can cancel and type hello and go back to square one, but that doesn't use that map
03:38:11 <mm_freak_> aristid: because you can have hello1 and hello2, you can call them and decide to continue either of them at any point…  also you can re-issue the 'x' command
03:38:45 <aristid> mm_freak_: maybe update the example to actually show these things off?:)
03:38:52 <mm_freak_> aristid: you can reenter any past computation at any 'request' spot
03:39:02 <aristid> mm_freak_: if i type multiple x, it will go back and ignore the previous value for x?
03:39:13 <aristid> that is certainly neat
03:39:21 <mm_freak_> aristid: yeah
03:39:23 <aristid> it's just that the example is not entirely clear about that.
03:39:29 <mm_freak_> aristid: it will also give you a new 'y'
03:39:41 <mm_freak_> aristid: better, i'll make a small web framework based on Continue (the better App) and snap =)
03:39:53 <mm_freak_> nonlinear interactions linearized
03:40:01 <mm_freak_> hiding the stateless nature of HTTP =)
03:40:02 <aristid> mm_freak_: oh i missed the fact that the example has multiple "y" inputs
03:40:12 <aristid> mm_freak_: ah!
03:40:24 <ivanm> how do I use Data.Vector.modify ?  I tried passing it a function but I get the error message "The lambda expression `\ mv -> ...' has one argument, but its type `forall s. MV.MVector s (Maybe a) -> ST s ()' has none"
03:40:24 <aristid> mm_freak_: where do you store those continuations for HTTP then?
03:40:38 <ivanm> how do you construct a forall function? :s
03:41:21 <mm_freak_> aristid: imagine writing a web app like this:  (user, pass) <- loginForm; checkLogin user pass; …
03:41:27 <mm_freak_> like a command line application
03:42:00 <Lethalman> mm_freak_, that reminds me smalltalk's seaside
03:42:00 <lambdabot> Lethalman: You have 1 new message. '/msg lambdabot @messages' to read it.
03:42:09 <Lethalman> :O
03:42:17 <aristid> mm_freak_: ... then the login session information is stored in RAM, right?:)
03:42:23 <mm_freak_> Lethalman: and of racket's continuation-based web framework
03:42:28 <mm_freak_> aristid: correct
03:42:31 <Lethalman> thanks fmap
03:42:33 <mm_freak_> aristid: the continuations are in RAM
03:42:35 <aristid> mm_freak_: so once that particular machine dies, the user needs to log in again
03:42:48 <mm_freak_> aristid: exactly…  that's the downside
03:43:08 <Lethalman> where the login can still be taken from the http session somehow
03:43:13 <Lethalman> it's not that you only have to use continuations
03:43:15 <aristid> mm_freak_: but i'm sure for many applications that's an acceptable risk because it does make programming the thing a lot easier
03:43:23 <mm_freak_> however, i'm waiting for the RTS to get distributed computing features…  those will allow me to store function pointers =)
03:43:30 <mm_freak_> then that problem is solved (almost magically)
03:43:32 <aristid> mm_freak_: does the thing hook into netwire?
03:44:18 <ivanm> oh, I can't use modify anyway; need to use create :s
03:44:34 <mm_freak_> aristid: well, only the continuations are lost…  the session can still be there…  when the machine dies between receiving a form and submitting it, you will have to resubmit…  so the implication isn't that horrific
03:44:41 <mm_freak_> aristid: no, it's not based on netwire
03:44:55 <Lethalman> mm_freak_, a good point would be to store continuations somewhere
03:45:07 <aristid> mm_freak_: i meant just because the type looks somehow similar
03:45:09 <mm_freak_> Lethalman: that's much more difficult than it sounds
03:45:16 <Lethalman> in-ram continuations are not very nice either
03:45:59 <mm_freak_> Lethalman: i've tried many approaches to storing continuations, but all of them boil down to:  "you can't have a serializable applicative functor"
03:46:23 <mm_freak_> distributed-static gives you serializable functions, but only basic functions which you have declared to be serializable
03:46:24 <Lethalman> mm_freak_, don't know much about haskell
03:46:47 <aristid> Lethalman: other languages have similar problems
03:47:03 <mm_freak_> actually no, the problem is far less severe in other languages
03:47:08 <Lethalman> aristid, I know I just to don't know what applicative functor is :P
03:47:17 <aristid> mm_freak_: ?
03:47:47 <mm_freak_> aristid: you can easily store continuations in languages that have transparent functions, but it's tricky to get it right
03:48:15 <aristid> mm_freak_: but let's say you limit yourself to a fully static applicative-based decision tree (or maybe Arrow-based), couldn't you use indices into that tree in a static fashion?
03:48:19 <mm_freak_> in haskell it's currently simply impossible…  distributed-static is a hack to name functions and store them together with their closures
03:48:41 <mm_freak_> aristid: depends on the functor
03:49:07 <mm_freak_> aristid: the problem is the first argument to (<*>)
03:49:14 <aristid> mm_freak_: how so?
03:49:25 <aristid> :t (<*>)
03:49:26 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
03:49:44 <mm_freak_> aristid: i think that's best understood by trying it out
03:50:01 <aristid> mm_freak_: heh maybe i'll try it later today:)
03:50:08 <aristid> certainly sounds like a fun exercise
03:50:12 <mm_freak_> try to make Identity serializable
03:50:25 <mm_freak_> then try again with ZipStream
03:50:35 <aristid> but now i gotta do something else. cu:)
03:50:38 <mm_freak_> data ZipStream a = ZipStream a (ZipStream a)
03:50:42 <mm_freak_> have fun =)
03:51:32 <Lethalman> mm_freak_, you don't have to serialize things, but the state in which they are
03:51:56 <mm_freak_> Lethalman: that's also much more difficult than it sounds =)
03:51:56 <Lethalman> or better, also things... don't know how haskell laziness would apply though :S
03:52:36 <mm_freak_> Lethalman: my approach to doing that looked like this:  data ZipStream a = forall s. (Serialize s) => ZipStream s (s -> (a, s))
03:52:43 * Lethalman having hard times finding a doc on the net...
03:54:05 <mm_freak_> actually:  data ZipStream a = forall s. (Serialize s, Typeable s) => ZipStream s (s -> (a, s))
03:54:27 <mm_freak_> where i'm just abusing the Typeable constraint as a fancy HasName =)
03:54:43 <shachaf> Is a type class necessary?
03:54:54 <mm_freak_> shachaf: makes it easier to implement
03:55:16 <mm_freak_> also less error-prone
03:55:39 <mm_freak_> unless you write custom Typeable instances the compiler pretty much ensures that you don't mix up the names
03:56:01 <shachaf> What do you actually do with s?
03:56:14 <Lethalman> mm_freak_, in seaside for example continuations are serializable due to the nature of the language
03:56:21 <shachaf> It seems that you could just store a serialized version of s there.
03:56:45 <shachaf> Like you can store a String instead of an existential Show variable.
03:56:49 <mm_freak_> shachaf: that would make writing the ZipStreams much uglier, but yes, that would work
03:56:58 <mm_freak_> shachaf: however, the deserialization is the main problem
03:57:00 <shachaf> Would it?
03:57:04 <shachaf> OK.
03:57:18 <Lethalman> but my idea would be to have a mix of client side http session and server side continuation that rely on the client information
03:57:21 <Lethalman> probably utopic
03:57:52 <mm_freak_> anyway, it's not that bad not to store the continuations
03:57:58 <Lethalman> that is not only a string representing the continuation id from the client to the server, but some information of where the processing stopped
03:58:10 <mm_freak_> as said the only real problem in practice will be that form submissions would go into nirvana
03:58:15 <mm_freak_> the actual session data isn't lost
03:58:45 <Lethalman> e.g. you have action A and three steps, the client could store the step instead of a continuation ID
03:58:55 <Lethalman> that would let the client store the "continuation" somehow
03:59:01 <mm_freak_> also temporary resources will be lost, but proper REST web apps don't use them much anyway
03:59:28 <mm_freak_> Lethalman: you can't identify continuations for storage
03:59:59 <Lethalman> mh?
04:00:31 <Lethalman> I understand I'm not very clear on my idea so I give up :P
04:02:38 <mm_freak_> Lethalman: the problem is that smalltalk and haskell are very different
04:02:46 <mm_freak_> in smalltalk code is data
04:03:32 <mm_freak_> similar to lisp, except that smalltalk takes this even more seriously
04:03:56 <mm_freak_> in haskell functions are completely opaque
04:04:34 <mm_freak_> there is no way to store the function itself…  you can only store a name and use that one as a key into a data structure later
04:04:54 <mm_freak_> however, you have to write that machinery yourself, because there is no run-time support
04:05:06 <Lethalman> mm_freak_, forget about serializing continuations, my original idea is about storing some continuation information on the client-side
04:05:16 <Lethalman> like: you are at action A at the second step
04:05:49 <mm_freak_> that's possible, but then you don't get a monad
04:05:55 <Lethalman> that is you save the point in which your routine has to be restarted
04:06:05 <Lethalman> mm_freak_, I don't know monads well
04:06:19 <Lethalman> much like a goto
04:06:43 <mm_freak_> that approach works, when the continuations are static information, pretty much meaning that you can't have a monad, and i'd like not to have an arrow
04:07:13 <mm_freak_> in particular it won't work for inherently dynamic things like presenting a form to the user
04:07:20 <Lethalman> why not
04:07:34 <mm_freak_> chicken/egg problem
04:07:50 <mm_freak_> you're reloading the continuation labels and need to map them to actual code
04:08:10 <mm_freak_> to get the actual continuations for a monad, you need to run the underlying monadic action, at which point it's too late
04:08:52 * Lethalman doesn't know about monads, just describing the goto-like approach, in that of saving the state and the point of the routine in the client itself
04:08:54 <mm_freak_> for that approach to work the continuations must be independent of the underlying action, and that essentially means:  you're back to arrows
04:09:12 <mm_freak_> Lethalman: i'd say the easiest way to understand this is to try to implement it yourself =)
04:09:36 <mm_freak_> Lethalman: or read my arrow tutorial, which covers this in detail:  http://ertes.de/new/tutorials/arrows.html
04:09:38 <Lethalman> mm_freak_, I've just used haskell for the second time in my life today :P
04:10:42 <covi> Does anyone have this available for download?: http://dl.acm.org/citation.cfm?id=1291201.1291218&coll=DL&dl=GUIDE&CFID=240357333&CFTOKEN=64568892
04:31:05 <bitonic> covi: I can try, I think it’s OK anyway since dons distributes it here: <https://donsbot.wordpress.com/papers/>
04:35:06 <bitonic> covi: I’ve got it, but it’s a one page thing...
04:35:12 <bitonic> nothing useful
04:37:24 <mm_freak_> can i pass a GHC flag for all executables in my ~/.cabal/config?
04:39:17 <bitonic> covi: in any case, <http://mazzo.li/dons-xmonad.pdf>, I’ll keep it there for 15 mins
04:40:55 <aristid> bitonic: is that thing gated or why do you take it down?
04:41:34 <bitonic> aristid: it’s unclear, it’s gated but I’m pretty sure dons distributed it freely before they took down his uni website
04:41:43 <aristid> bitonic: meh
04:41:49 <Calvin> hi
04:42:07 <bitonic> aristid: more importantly, it’s useless :P
04:42:21 <aristid> bitonic: yeah but still, it's annoying when such things are just deleted
04:42:22 <Calvin> useless?
04:43:04 <bitonic> aristid: well I don’t think that my website is the right place anyway.  we should ask dons to put that stuff back up.  or we should have all those papers on arxiv or whatever
04:43:27 <aristid> bitonic: dons has a movie about xmonad: https://api.viglink.com/api/click?format=go&key=cdee124b11d6baacda6c3e29b12e23dc&loc=https%3A%2F%2Fdonsbot.wordpress.com%2Fpapers%2F&v=1&libid=1356784972188&out=http%3A%2F%2Fwww.ludd.ltu.se%2F~pj%2Fhw2007%2Fxmonad.mov&title=Publications%20%C2%AB%20Control.Monad.Writer&txt=The%20Design%20and%20Implementation%20of%20xmonad&jsonp=vglnk_jsonp_13567849753982
04:43:33 <aristid> wtf that's a long link
04:43:45 <aristid> better link: http://www.ludd.ltu.se/~pj/hw2007/xmonad.mov
04:43:45 <bitonic> aristid: it does seem to work, but I can’t watch it right now
04:44:05 <bitonic> aristid: anyway covi was the interested one :P
04:45:14 <aristid> covi: http://www.ludd.ltu.se/~pj/hw2007/xmonad.mov
04:45:19 <aristid> bitonic: better?:P
04:45:31 <bitonic> better :)
04:46:09 <covi> bitonic: thanks! Why is it only one page though?
04:46:15 <covi> aristid: thx for the link
04:47:17 <aristid> covi: maybe i'll watch it later myself :D
04:47:32 <bitonic> covi: it’s just a bit of Xmonad marketing in some proceedings
04:47:53 <mercury^> Can I replace type instance Thread (ReaderT (f s) m) = s
04:48:07 <mercury^> by something that works on MonadReader (f s) m instead?
04:48:11 <covi> bitonic: I see. I was just hoping to find some "guide" that helps me understand the source code.
04:48:29 <bitonic> covi: the Xmonad source code is very short and clean, you should just read it
04:48:37 <bitonic> it’s ~2000 locs iirc
04:50:50 <aristid> still that short? wow
04:51:05 <aristid> that doesn't include the contrib modules though?
04:51:07 <bitonic> aristid: no
04:51:30 <bitonic> covi: the most annoying part will be the “talking to X” part
04:51:34 <aristid> no to which question?:D
04:51:45 <bitonic> <aristid> that doesn't include the contrib modules though?
04:51:54 <bitonic> maybe it should have been a “yes”.  damn double negatives!
04:52:07 <bitonic> anyway, it *doesn’t* include contrib modules.
04:52:51 <aristid> bitonic: well, double negatives really require a more qualifying answer, sadly
04:53:15 <aristid> i don't think there is really a universal convention what "yes" means as an answer to a double negative question :/
04:53:56 <aristid> but i don't want to stop using double negative questions, as they allow me to put in my guess as to what the answer is right into the question :D
04:54:49 <aristid> maybe the better way to phrase it would have been "am i correct in thinking that this figure does  not include the contrib modules?"
04:55:56 <sepp2k> How is "doesn't include" a double negative?
04:56:23 <bitonic> sepp2k: my answer formed a double negative with the doesn’t
04:56:28 <`ramses> is there a function which can give the type of something at runtime? e.g. for an Integer it would give the string "Integer"
04:57:05 <ClaudiusMaximus> :t show . typeOf
04:57:06 <sepp2k> bitonic: Ah, I see.
04:57:06 <lambdabot> Typeable a => a -> String
04:58:03 <ClaudiusMaximus> but it's not really at runtime...
04:59:22 <`ramses> ah that seems to be what I'm after :) what do you mean by "not really at runtime", is it all decided at compile time?
04:59:58 <ClaudiusMaximus> normally 'a' is fixed at compile time, but i suppose it is a runtime value - i think  i need more coffee :)
05:00:23 <b_> `ramses the compiler sorts out the types, yes
05:00:26 <covi> bitonic: what should I think of the role of a X value?
05:00:54 <`ramses> but does it work if I use that in a library function which gets a polymorphic lambda as input?
05:01:05 <`ramses> or will it spit out something very generic then
05:01:13 <`ramses> I guess I should just try it :)
05:01:37 <epta> Is there any library with darcs bindings?
05:02:29 <covi> @hoogle IAray
05:02:29 <lambdabot> No results found
05:02:32 <covi> @hoogle IArray
05:02:32 <lambdabot> Data.Array.IArray module Data.Array.IArray
05:02:32 <lambdabot> Data.Array.IArray class IArray a e
05:04:27 <aristid> too bad ghc doesn't support holes yet :/
05:04:45 <gienah> aristid: it does in ghc head
05:07:42 <`ramses> I guess there is no easy way to make such a function print a free variable name for "yet undetermined" types? Because now I get "no instance" errors for such type variables
05:08:03 <mikeplus64> > ⊥
05:08:03 <lambdabot>   mueval: recoverEncode: invalid argument (invalid character)
05:08:09 <shachaf> aristid: You can fake them pretty well with ImplicitParams.
05:08:23 <gienah> http://www.haskell.org/haskellwiki/GHC/TypeHoles
05:08:32 <`ramses> like, I have a datatype "Foo Maybe b b" and want to have something like that printed, but the type of b is still unknown
05:08:42 <shachaf> I wish they didn't call them TypeHoles.
05:08:50 <shachaf> What are they going to call actual type-level holes?
05:09:11 <gienah> SetHoles ?
05:09:46 <mikeplus64> shachaf: huh, that's a neat trick (implicit params for type holes)
05:14:05 <covi> @src print
05:14:05 <lambdabot> print x = putStrLn (show x)
05:16:52 <pdxleif> Couldn't they call what's in that link "holes", and call type holes type holes?
05:20:03 <covi> Here are two different functions that both compute the divisors of a number, why is one much slower than the other?: http://hpaste.org/79949
05:27:32 <chrisdone> how do you configure GHC when building it from source to compile with -fPIC?
05:28:15 <chrisdone> i need to recompile the RTS with -fPIC apparently
05:34:36 <mm_freak_> covi: because they implement different algorithms
05:34:50 <mm_freak_> however, the fastest algorithm first finds the factors and then uses subsequences
05:35:14 <mm_freak_> > map product . subsequences $ [2, 3, 5]
05:35:16 <lambdabot>   [1,2,3,6,5,10,15,30]
05:35:20 <mm_freak_> the divisors of 30
05:37:02 <hiptobecubic> it's nice that you get the 1 for free there
05:37:15 <hiptobecubic> from the empty sequence
05:37:37 <b_> I have a bazillion constructors with the same type
05:37:57 <b_> and I wouldn't mind putting the type signature for all of them on one line
05:38:04 <b_> but it will go over 80 chars
05:38:08 <b_> what to dooo
05:39:07 <Hafydd> b_: put them all on the same logical line, perhaps, but split it?
05:39:43 <k00mi> why not just ignore the 80 character limit? it's useless here anyways
05:39:52 <ClaudiusMaximus> a, b, c,\n d, e, f\n :: T -- the extra leading space is ugly though
05:40:38 <Hafydd> Why is it useless>
05:40:41 <Hafydd> *?
05:40:47 <rwbarton> where is here
05:41:23 <Taneb> Is there anything like "data Comparing c a = Comparing (a -> c) a; instance (Eq c) => Eq (Comparing c a) where Comparing c a == Comparing d b = c a == d b; instance (Ord c)=> Ord (Comparing c a) where compare = comparing $ \(Comparing c a) -> c a"?
05:41:54 <k00mi> Hafydd: it's useless because it does not make the code more readable
05:41:58 <dmwit> Taneb: That looks very familiar.
05:42:26 <dmwit> It reminds me of the "I get a functor even if your thing isn't a functor" trick that edwardk likes to pull occasionally.
05:42:35 <Hafydd> k00mi: it does make the code more readable when you're using a terminal or printing it out.
05:42:47 <Taneb> dmwit, it's a bit like the Store comonad
05:43:07 <k00mi> Hafydd: you use a 80 character wide terminal?
05:43:19 <dmwit> Taneb: Yeah, but you wouldn't want that Eq/Ord instance for Store. =)
05:43:26 <Taneb> But for a completely different purpose, yeah
05:43:37 <Hafydd> k00mi: my screen can accommodate two 80-wide terminals side by side, so usually, yes.
05:43:58 <Taneb> (==) = (==) `on` extract; compare = comparing extract
05:44:00 <b_> hm I find it an esthetic flaw to go over 80 chars in this case =[
05:44:05 <Hafydd> Of course my text editor can do shit with wrapping, but I prefer not to.
05:44:36 <dmwit> Automatic wrapping (of code) is never as pretty as manual wrapping.
05:44:48 <b_> but arbitrarily splitting up the signature is not pretty either
05:44:56 <k00mi> Hafydd: i see. i still wouldn't do it because splitting the line would make it less readable for eveyone else
05:45:36 <b_> and I have to provide haddock strings for all of them anyway
05:45:40 <dmwit> b_: How about a, b, c, d\n:: foo
05:45:40 <Hafydd> You have to stop wrapping somewhere, don't you? So why not be systematic about it?
05:45:57 <Hafydd> Er, start wrapping, I mean.
05:46:04 <dmwit> Oh, well, if you need haddocks, that's a non-starter then.
05:46:22 <dmwit> No sense complaining if you're going to write documentation. You just buckle down and do it. =)
05:46:32 <b_> sure
05:46:54 <dmwit> If it's a big type, you could make an alias for it.
05:47:21 <b_> I should be systematic about it
05:47:55 <b_> but I'm still trying to figure out what amount of documentation is a good default/standard
05:48:15 <covi> @hoogle subsequences
05:48:15 <lambdabot> Data.List subsequences :: [a] -> [[a]]
05:49:33 <covi> mm_freak_: awesome. What's a quick way to find the prime factors?
05:54:14 <rwbarton> if you just want the divisors of a number, why not use a library to do it
05:54:16 <rwbarton> http://hackage.haskell.org/packages/archive/arithmoi/0.4.0.3/doc/html/Math-NumberTheory-Primes-Factorisation.html#v:divisors
05:57:53 <covi> rwbarton: Just what I needed. Thanks.
06:04:30 <mm_freak_> covi: seconded, use the arithmoi library
06:04:38 <mm_freak_> it implements the elliptic curve method, which is fine for most purposes
06:05:33 <dmwit> Ellipses and factoring mix?
06:05:36 <dmwit> my mind boggles
06:06:05 <mm_freak_> elliptic curve not-really-groups and finding the non-units
06:06:33 <mm_freak_> http://en.wikipedia.org/wiki/Elliptic_curve_method
06:06:54 <mm_freak_> it's related to (if not based on) pollard's p-1 method
06:08:44 <mm_freak_> lambdabot should include the arithmoi library, then i could pass p-1 as a one-liner to it =)
06:14:03 <mm_freak_> \n -> find (liftA2 (&&) (> 1) (< n)) . map (gcd n . pred) . scanl (\x y -> powerMod x (y^integerLog2 n) n) 2 $ primes
06:14:13 <mm_freak_> pollart p - 1 using arithmoi =)
06:14:24 <mm_freak_> pollard
06:15:05 <mm_freak_> naive implementation, but still much better than trial division
06:43:10 <Jafet> You don't need arithmoi to pass a one-liner to lambdabot
06:43:22 <Jafet> @let gecm n a=id`either`const 0$foldM(flip(^))(1,1)[1..a]where m=pure;k^p|k==0=m(0,0)|odd k=(k-1)^p>>=(p/)|1>0=div k 2^p>>=join(/);(0,0)/x=m x;x/(0,0)=m x;(p,q)/(r,s)=let z l=let t=mod(l*l-p-r)n in m(t,mod(-q+l*(p-t))n)in case(p-r)&n of{(l,_,1)->z$l*(q-s);(_,_,f)|f/=n->Left f|1>0->case(2*q)&n of{(l,_,1)->z$l*(3*p*p+a);(_,_,f)|f/=n->Left f|1>0->m(0,0)}};a&0=(signum a,0,abs a);a&b=let(q,r)=divMod a b;(s,t,d)=b&r in(t,s-q*t,d)
06:43:25 <lambdabot>  Defined.
06:43:37 <Lethalman> \o/
06:43:58 <bitonic> Jafet is the lambdabot numerical one-liner master
06:44:07 <Jafet> > gecm (2^32 + 1)
06:44:09 <lambdabot>   No instance for (GHC.Show.Show (b0 -> b0))
06:44:09 <lambdabot>    arising from a use of `M51186...
06:44:18 <Jafet> > gecm (2^32 + 1) 1000
06:44:21 <lambdabot>   641
06:44:47 <Jafet> > gecm (2^2^6 + 1) 10000
06:44:50 <lambdabot>   274177
06:45:22 <dmwit> argh
06:45:32 <dmwit> There's no instance of Read for DiffTime.
06:45:52 <dmwit> :r
06:45:56 <dmwit> sorry
06:45:56 <Jafet> That said, arithmoi is a good library
06:46:30 <Jafet> Modules loaded: ALL OF THEM
06:46:39 <dmwit> \o/
06:51:24 <DavidT> dmwit: Does fromInteger . read or fromRational . read work for you?
07:05:34 <dmwit> DavidT: Doesn't seem to. I get no parse.
07:06:21 <dmwit> (Even if I strip the 's' off the end.)
07:06:46 <beaky> hello
07:07:37 <beaky> Besides the Glorious Compiler from Glasgow, what excellent Haskell compilers are there?
07:07:56 <byorgey> dmwit: fromInteger . read  should work if stripping off the 's'.
07:08:12 <dmwit> byorgey: Only for integral DiffTimes. =)
07:08:20 <byorgey> heh, right =)
07:08:35 <MaybeCallMe> beaky: none.
07:09:12 <beaky> none? :(
07:09:16 <dmwit> byorgey: (and read :: String -> Rational doesn't do decimal-point-style fractions, unfortunately)
07:09:52 <dmwit> beaky: There's several other implementations; JHC, NHC, UHC, Hugs. Not sure what qualifies as "excellent", though.
07:10:22 <beaky> so those implementations are dog-slow compared to GHC?
07:10:27 <MaybeCallMe> beaky: JHC has a lot of fancy performance enhancing stuff. but nobody uses it
07:10:32 <beaky> ah
07:11:12 <beaky> so Haskell these days really means 'the language that GHC accepts as input'
07:11:28 <dmwit> Well, no.
07:11:43 <Jafet> No. You need to specify which GHC flags are used, too.
07:11:51 <dmwit> There's a specification, and generally people mean that when they say Haskell if they're being careful, and they mean "the language GHC accepts" when they say GHC.
07:12:39 <beaky> ah
07:12:54 <beaky> does ghc have a pedantic mode?
07:13:47 <bitonic> beaky: what’s that?  -Wall?
07:14:06 <byorgey> if you don't enable any extensions you get something pretty close to Haskell2010 (but not quite)
07:14:28 <beaky> ah
07:14:55 <dmwit> byorgey: Oh, not quite?
07:14:59 <dmwit> What's the caveat?
07:15:02 <beaky> is there a haskell implementation for MS-DOS?
07:15:04 <bitonic> oh, pedantic is regarding to the std.
07:15:16 <bitonic> dmwit: non-compliant Prelude?
07:15:29 <dmwit> What, really?
07:15:45 <bitonic> dmwit: ?
07:15:54 <Saizan> the libs are different in a few places
07:15:59 <byorgey> Num doesn't have Eq and Show superclasses
07:16:11 <dmwit> ah, right
07:16:13 <byorgey> is the one in particular I'm aware of, there might be a couple other things
07:16:25 <rwbarton> there is a whole little section of the GHC User's Guide on differences from Haskell 98 (now 2010 I guess)
07:16:30 <dmwit> I was under the impression that was in the spec now, but maybe that's wrong.
07:16:37 <byorgey> no, it isn't
07:16:43 <bitonic> dmwit: it was a recent change in GHC
07:16:47 <byorgey> oh, right, there are a few differences in parsing from the standard too
07:16:56 <byorgey> because the standard is actually pretty much impossible to implement
07:17:08 <bitonic> also, mutually recursive modules
07:17:26 <bitonic> GHC kind of does them, but not as in the standard
07:17:32 <dmwit> cool, http://www.haskell.org/ghc/docs/latest/html/users_guide/bugs-and-infelicities.html#haskell-standards-divergence
07:17:44 <bitonic> yeah
07:19:22 <beaky> ghc produces screaming fast code ^^
07:19:40 <beaky> at least ghc -O2 does
07:19:58 <dmwit> Oh yeah, I knew about the array thing, too, but forgot. Lots of subtleties in here.
07:28:24 <pdxleif> Haskell and GHC Haskell are placed at different locations on this chart: http://james-iry.blogspot.com/2010/05/types-la-chart.html
07:30:12 <pdxleif> Curious why Haskell '98 is to the left of languages like Java on the power / sophistication axis of that, though. :/
07:30:55 <aristid> pdxleif: haskell 98 is quite limited compared to modern GHC haskell
07:36:05 <shachaf> pdxleif: Well, the article does talk about it...
07:40:35 <Rembane> Is there an article about it?
07:44:30 <Jafet> "This chart is obviously too simplistic to be accurate, which renders it fairly meaningless. But Agda is at the top-right corner. Agda is cool."
07:47:28 <Rembane> :D
07:52:39 <saati> will there be a new standard that reflects reality?
07:56:33 <burbul> What's the idiomatic way to raise errors in the Either String monad?  'fail' or 'Left'?
07:56:53 <pdxleif> I know Frege said it gave up on having the generated Java code be typesafe w/ generics, and just casts sstuff, because of limitations w/ java's type system.
07:59:31 <shachaf> burbul: Left sounds better to me.
07:59:55 <shachaf> Or some Left-equivalent.
08:01:13 <burbul> thanks
08:01:24 <burbul> And similarly 'Right' instead of return?
08:01:33 <shachaf> return is fine.
08:01:43 <burbul> Actually, I'm not sure what you mean by 'Left-equivalent'... fail is equivalent to Left, no?
08:01:50 <shachaf> If you use Left, you can switch your errors from String to some other error type.
08:01:54 <shachaf> fail is hard-wired to String.
08:02:28 <pdxleif> There's like an "Exception" or "Error" monad that seems isomorphic to Either, too...
08:02:35 <burbul> ah, I see -- thanks
08:02:58 <burbul> pdxleif: yes, I've never understood why that is in there
08:03:28 <burbul> Although I've only seen it as a transformer ErrorT
08:03:28 <ericbmerritt> hey guys, I am attempting to install chp and getting the following error https://gist.github.com/4407760
08:03:46 <ericbmerritt> I wonder if there might be some issue with my cabal that is causing it
08:04:27 <shachaf> ericbmerritt: It looks vaguely like a compatibility issue.
08:04:40 <shachaf> A newer version of some packages than chp is expecting, or something.
08:06:38 <ericbmerritt> shachaf: that makes sense. I will give that a closer look
08:08:32 <Lethalman> is there any important gui project written in haskell? something like hoodle
08:08:57 <Lethalman> tried reading some code and liked it, but it's splitted in many different repositories thus I can't easily follow the code
08:09:00 <Lethalman> something very simple
08:09:04 <Lethalman> yet useful
08:12:46 <k00mi> there are some reactive-banana examples on the wiki, but those are most likely too simple
08:12:51 <k00mi> http://www.haskell.org/haskellwiki/Reactive-banana/Examples
08:16:11 <k00mi> you could look at reverse dependencies for GUI libraries Lethalman
08:16:19 <Lethalman> k00mi, that's fine
08:21:32 <mm_freak_> Lethalman: leksah, manatee, yi and a few others
08:21:46 <mm_freak_> reactive-banana is a better approach to GUI programming, but i don't know how mature it is
08:21:54 <mm_freak_> seems like you can write at least simple applications using it
08:22:03 <Lethalman> ah it's a whole framework?
08:22:23 <Lethalman> I was impressed by hoodle that uses monads to describe actions and undos ecc.
08:22:35 <Lethalman> though I don't even grasped the concept yet :P
08:22:38 * hackagebot free 3.3 - Monads for free  http://hackage.haskell.org/package/free-3.3 (EdwardKmett)
08:22:40 * hackagebot ad 3.3.0.1 - Automatic Differentiation  http://hackage.haskell.org/package/ad-3.3.0.1 (EdwardKmett)
08:22:42 * hackagebot free 3.3.0.1 - Monads for free  http://hackage.haskell.org/package/free-3.3.0.1 (EdwardKmett)
08:22:44 * hackagebot keys 3.0.1.1 - Keyed functors and containers  http://hackage.haskell.org/package/keys-3.0.1.1 (EdwardKmett)
08:22:46 * hackagebot representable-functors 3.0.0.2 - Representable functors  http://hackage.haskell.org/package/representable-functors-3.0.0.2 (EdwardKmett)
08:23:40 <k00mi> Lethalman: reactive-banana implements functional reactive programming which is a still experimental approach to GUI (and similar reactive systems) programming in functional languages
08:30:07 <DrChaos> err..I've never done pattern matching or recursion for a function taking lists of lists before, can I get a little help? I have sortListOfLists :: [[a]] -> [[a]]; sortListOfLists ([x]:[y]) = ...
08:31:00 <hpc> well first, you'll be wanting sortListOfLists :: Ord a => [[a]] -> [[a]]
08:31:43 <DrChaos> I see that I need xs in my pattern match, but I don't know what to do as all I am concerned with are two elements at a time but I need to be able to process the rest of the list
08:31:55 <shachaf> @ty partsOf (traverse.traverse) %~ sort :: Ord a => [[a]] -> [[a]] -- not recommended
08:31:56 <lambdabot> Ord a => [[a]] -> [[a]]
08:32:32 <DrChaos> what does %~ do?
08:32:38 * hackagebot kan-extensions 3.1.0.1 - Kan extensions, the Yoneda lemma, and (co)density (co)monads  http://hackage.haskell.org/package/kan-extensions-3.1.0.1 (EdwardKmett)
08:32:40 * hackagebot recursion-schemes 3.0.0.1 - Generalized bananas, lenses and barbed wire  http://hackage.haskell.org/package/recursion-schemes-3.0.0.1 (EdwardKmett)
08:32:45 <hpc> it's a lens
08:32:50 <hpc> :t (%~)
08:32:52 <lambdabot> Setting s t a b -> (a -> b) -> s -> t
08:33:03 <DrChaos> I really am quite new to programming
08:33:08 <DrChaos> what is a lens?
08:33:15 <shachaf> DrChaos: Sorry. I shouldn't have sidetracked the conversation.
08:33:25 <hpc> it's complicated and i barely understand how they make code nicer myself :P
08:33:32 <shachaf> lens is a library you might learn about later; it's not part of core Haskell.
08:33:42 <hpc> so back to pattern matching...
08:34:02 <hpc> your function takes a parameter of some kind of [b] (where b = [a])
08:34:08 <hpc> so let's start with the "empty list of lists" case
08:34:15 <hpc> sortListOfLists [] = []
08:34:23 <DrChaos> will people support me in learning Haskell as my first programming language? I have done a little C programming and some Java programming but that's it
08:34:29 <hpc> definitely
08:34:47 <`nand`> shachaf: what, we don't have sortOf?
08:34:56 <arkydo> Can anyone recommend a book to learn Haskell from?
08:35:01 <Clint> @where lyah
08:35:02 <lambdabot> http://www.learnyouahaskell.com/
08:35:12 <DrChaos> @where rwh
08:35:12 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
08:35:40 <hpc> DrChaos: so do you want to sort the inner lists as well as the list-of-lists?
08:36:02 <hpc> ie, sortListOfLists [[3, 2, 1], [0, 5, 4]] = [[0, 4, 5], [1, 2, 3]]
08:36:03 <DrChaos> hpc -> that would be nice but I don't think it's necessary for this exercise
08:36:12 <DrChaos> hpc -> oh, no
08:36:23 <DrChaos> would be nice though
08:36:42 <`nand`> do you want to sort the outer lists at all?
08:36:47 <hpc> and as a programming exercise, you can't use the built-in sort function?
08:37:03 <DrChaos> hpc -> correct
08:37:22 <hpc> well that's kind of a pain
08:38:29 <hpc> it's too early in the morning for me to be thinking at that low level, so in lieu of trying to get you closer to a solution, here's a quick primer on pattern matching
08:38:30 <DrChaos> I just realized that lists inside of a list can be empty so I made a pattern match sortListOfLists [[]] = [[]]
08:38:43 <hpc> yeah
08:39:18 <hpc> so lists are defined "data [] a = [] | (a : [a])" (if the syntax was possible)
08:39:32 <DrChaos> the problem for me is making a function that swaps two sublists based on their length that will call itself recursively and do the same thing over and over again
08:39:34 <hpc> the type constructor is []
08:39:44 <hpc> and the data constructors are [] and (:)
08:40:17 <hpc> the data constructors are what you match on, but you can also use list literal syntax to match an exact list
08:40:32 <hpc> so matching on these patterns, their variables are:
08:40:37 <hpc> [] -- empty list
08:41:17 <hpc> matching ["blargh", "zorg"] against (x : xs) -- x = "blargh", xs = ("zorg" : [])
08:41:34 <hpc> you can also match it against [x, y] and get y = "zorg" instead
08:42:09 <hpc> matching against ((x:xs):xss) would yield x = 'b', xs = "largh", xss = ["zorg"]
08:42:17 <hpc> if that makes sense
08:42:40 <hpc> if we're sorting lists of lists, i think you want two functions
08:42:42 <DrChaos_> I remember data List a = Cons a (List a) | Nil deriving (Show)
08:42:48 <hpc> one to sort the inner lists
08:43:05 <hpc> and then another to call that first function on all elements, then sort the final list
08:43:05 <DrChaos_> that's a polymorphic type that is isomorphic with the original list type
08:43:37 <DrChaos_> data [] a = : a ([] a) | []; is that the list type right there?
08:44:07 <hpc> need parens around (:) to use it prefix like that
08:44:08 <hpc> but yes
08:44:38 <DrChaos_> I'm not sure whether I need two functions
08:44:47 <hpc> so if we suppose you magically were able to use the standard library unrestrictedly, an easy answer would be
08:44:50 <hpc> sortInner = sort
08:44:58 <hpc> sortOuter = sort . map sortInner
08:45:14 <DrChaos_> oh wow
08:45:43 <hpc> if you are allowed to use map and (.), that just leaves you with coming up with a suitable polymorphic sort function
08:45:57 <hpc> selection sort is quite easy
08:46:41 <DrChaos_> hmm...really? I'd think it wouldn't be very easy for somebody new to programming
08:47:05 <DrChaos_> they haven't really discussed the map function
08:47:37 <hpc> map takes a function and applies it to every element of a list
08:47:38 <hpc> :t map
08:47:39 * hackagebot machines 0.2.1.3 - Networked stream transducers  http://hackage.haskell.org/package/machines-0.2.1.3 (EdwardKmett)
08:47:40 <lambdabot> (a -> b) -> [a] -> [b]
08:47:43 <DrChaos_> they have used it, however they also said that they will be revisiting it in the next chapter
08:47:57 <Lethalman> hpc, is it possible to have a single function, like a sort for [a] = realsort and a sort for [[a]] = map sort ?
08:48:02 <hpc> the map function can be generalized in a loooooot of ways
08:48:41 <Lethalman> like [a] (where a is not a list) is the base case
08:48:50 <hpc> Lethalman: you'd need to enable some of the ickier typeclass extensions
08:48:56 <DrChaos_> well huh, let me look up selection sort
08:49:12 <hpc> DrChaos_: it's basically "pick the smallest element and put it at the front, repeat"
08:49:13 <shachaf> Lethalman: That sounds like an awful function.
08:49:57 <DrChaos_> hpc -> owie. I don't think I'd know how to translate that from imperative programming language to functional
08:50:04 <Lethalman> shachaf, why? let's say you have to do that recursively, how do you distinguish between [[a]] and [a]?
08:50:14 <shachaf> What?
08:50:33 <Lethalman> shachaf, like you can have a list of lists of lists
08:50:38 <hpc> DrChaos_: "a selection-sorted list is (minimum of the list) cons'd with (the rest of the list in sorted order)"
08:50:48 <Lethalman> but in general, how do you define a function that recursively does sort?
08:51:00 <shachaf> What?
08:51:02 <Lethalman> what hpc defined above is only for list of lists, how to generalize it for any nested list?
08:51:14 <hpc> infinitely? you'd use Mu and your own function
08:51:16 <shachaf> You don't.
08:51:17 <hpc> @src Mu
08:51:18 <lambdabot> newtype Mu f = In { out :: f (Mu f) }
08:51:26 <shachaf> A list which is arbitrarily nested is called a "tree".
08:51:29 <hpc> or sort a tree
08:51:59 <`nand`> > [[3,2,1],[6,5,4]] & partsOf biplate %~ (sort :: [Integer] -> [Integer])
08:52:01 <lambdabot>   [[1,2,3],[4,5,6]]
08:52:08 <`nand`> > [3,2,1,6,5,4] & partsOf biplate %~ (sort :: [Integer] -> [Integer])
08:52:09 <lambdabot>   [1,2,3,4,5,6]
08:52:10 <`nand`> oh
08:52:14 <`nand`> I guess that's not really the same thing
08:52:17 <`nand`> never mind
08:52:35 <shachaf> The thing you *shouldn't* do is that.
08:52:52 <`nand`> it's not the same as map sort, since it escapes the individual lists either way
08:57:45 <DrChaos> ok, so err...how to translate selection sort algorithm into Haskell?
08:57:48 <DrChaos> I'd have one function that scans the entire list and finds the smallest item and returns it's index
08:58:08 <`nand`> why not return the item itself
08:58:55 <DrChaos> why not return a tuple of (item, index)?
08:59:06 <Martty_> why not both
08:59:09 <shachaf> You shouldn't use indexing with lists.
08:59:11 <`nand`> the API I would think of is (item, [items])
08:59:19 <`nand`> that is, the smallest item and the rest of the list without it
09:01:02 <`nand`> oh hey
09:01:19 <`nand`> add in a Maybe to cover the [] case, and selection sort would be as simple as unfoldr
09:02:28 <DrChaos> err...how would I type signature a function that returns a Maybe value?
09:03:02 <zomg> DrChaos: Maybe WhateverIsInTheMaybe
09:03:56 <DrChaos> I really don't want to mess with Maybes right now
09:04:07 <zomg> Maybes are pretty easy though :)
09:04:18 <`nand`> DrChaos: but what would happen if you select the smallest item from an empty list?
09:04:58 <DrChaos> `nand` -> um...infinite recursion?
09:05:54 <DrChaos> well, I could make it so that [[1],[]] gives [[],[1]] as the result
09:06:32 <shachaf> DrChaos: I suggest you think about how to sort a regular list before you think about lists of lists.
09:07:13 <DrChaos> shachaf -> I'm trying to implement a selection sort algorithm that will sort a list
09:07:58 <clinton> :t fmap . fmap
09:07:59 <lambdabot> (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
09:08:01 * shachaf suspects insertion sort or something is simpler in Haskell.
09:08:18 <shachaf> Anyway the simplest thing is whatever seems obvious to you.
09:08:33 <`nand`> merge sort is pretty simple
09:08:42 <`nand`> so is ‘something like quicksort’
09:09:01 <`nand`> but yeah, insertion sort is probably the simplest
09:09:38 <clinton> why isn't selection sort easy?
09:09:57 <`nand`> because the selection function is needlessly complex
09:10:09 <`nand`> that is, if you want to not only return the smallest item but also the rest of the list
09:10:16 <`nand`> (which you need, to append the smallest item to it)
09:10:19 <Lethalman> why you need the rest of the list?
09:10:24 <`nand`> err, prepend
09:10:40 <Lethalman> you get the smallest, then the smallest that are greater than the previous smallest
09:10:44 <Lethalman> and so on
09:12:55 * `nand` .oO( select . filter (>x) )
09:13:24 <`nand`> but that would probably be less efficient than a slightly smarter ‘select’
09:14:47 <`nand`> let me take back my original claim as well; the selection function isn't very complex even if you return the rest of the list as well
09:15:05 <`nand`> I guess I was just thinking in terms of one-liners
09:15:10 <`nand`> IRC is a curse
09:26:06 <DrChaos> ok, I will try to implement insertion sort, but I don't know how to pass all the needed indexes and things that a recursive application of the insertion sort algorithm will need
09:26:26 <DrChaos> I don't know how to transform the while loop into a recursive function call, that is
09:26:36 <`nand`> tip: forget about indices
09:29:42 <DrChaos> insertionSort :: Ord a => [a] -> [a]
09:31:20 <DrChaos> I don't know how to translate imperative psuedo code into functional code
09:31:37 <elliott> you probably don't want to try
09:31:45 <rwbarton> throw away the imperative pseudo code
09:31:50 <DrChaos> ok...
09:31:55 <rwbarton> it is like how do I translate x86 assembly into javascript
09:32:06 <DrChaos> oh, that's funny!
09:32:16 <DrChaos> you got a laugh out of me
09:32:27 <alpounet> yeah, do not try to translate the imperative pseudo code, think of what the algorithm really is about, and think about the tools you have (lists and recursion), that's going to be a bit hard at the beginning but it'll be fine
09:32:38 <DrChaos> is there an alternative mathematical definition of insertion sort?
09:33:08 <rwbarton> it's a little tricky when you are trying to implement "a specific algorithm"
09:33:21 <`nand`> here's a pseudo-mathematical definition of “remove one element from the original list at a time, insert it into a new list. repeat until done”
09:33:25 <`nand`> of it*
09:33:33 <`nand`> but I don't know if that's going to help you
09:33:42 <arkydo> Whad do I need to ran Haskell on my system? I use Archlinux.
09:33:44 <`nand`> and by pseudo-mathematical I mean “not mathematical at all”
09:33:58 <`nand`> arkydo: a Haskell implementation. ArchLinux should provide a package for GHC, check your repositories
09:34:01 <DrChaos> arkydo -> the ghc package
09:34:19 <elliott> arkydo: you might want to install the haskell platform package instead
09:34:23 <elliott> I think Arch has it as haskell-platform
09:35:02 <arkydo> I've tried to install haskell-platform it does not exist anymore.
09:35:14 <elliott> rwbarton: are you saying we need http://bellard.org/jslinux/ but for Haskell
09:35:15 <rwbarton> archlinux has only ghc 7.6 as far as I can tell (they are insane)
09:35:38 <elliott> yes I think Arch patches the haskell platform to build on the latest GHC always
09:35:44 <elliott> 7.6 is pretty stable though!
09:35:52 <elliott> oh there is no haskell-platform package now?
09:35:56 <elliott> maybe they dropped it so they could have GHC 7.6
09:36:37 <DrChaos> Ooh Gentoo has haskell-platform 2012.4
09:36:48 <arkydo> What's the latest release of Haskell?
09:36:54 <shachaf> Haskell 2010
09:37:42 <byorgey> arkydo: do you mean the latest release of GHC?  Of the Haskell Platform?  of the Haskell language standard? ...?
09:38:21 <alpounet> elliott, last time I checked, haskell-platform was in AUR and wasn't building actually, an error with OpenGL or smth
09:38:43 <arkydo> byorgey: GHC.
09:38:54 <byorgey> arkydo: the latest release of GHC is 7.6.1
09:40:04 <elliott> alpounet: latest HP doesn't build on GHC 7.6, yeah
09:43:18 <monochrom> if you know why the Haskell Platform doesn't build on GHC 7.6, you may be able to fix it, it seems easy
09:43:36 <monochrom> why doesn't build: because GHC 7.6 actually follows a Haskell 2010 rule
09:44:34 <arkydo> I install only the compiler then.
09:44:47 <monochrom> example: suppose you just import CInt, as opposed  to CInt(CInt) or CInt(..). so, you don't import the value constructor. then Haskell 2010 says, CInt cannot be in the type sig of foreign imports
09:44:55 <elliott> monochrom: if you know how to, and are willing to, patch packages like that, probably you don't have any use for the haskell platform anyway :P
09:45:02 <monochrom> haha
09:45:08 <shachaf> patchage
09:45:14 <shachaf> Hmm.
09:45:24 <monochrom> so, that's essentially why some parts of Haskell Platform doesn't build
09:46:02 <monochrom> if you ask me, I am actually glad that GHC finally follows a Haskell 2010 rule, after more than 2 years!
09:46:23 <shachaf> The GHC people are so out of touch with the Report people.
09:48:36 <DrChaos> ok, I lost the psuedo mathematical definition of insertion sort
09:48:55 <DrChaos> my internet connection cuts out  the IRC server connection frequently
09:49:01 <monochrom> the next best thing you could do is edit platform.packages to skip the build-error parts. they are just OpenGL and GLUT IIRC. you probably don't mind skipping them
09:49:13 <shachaf> DrChaos: This is an exercise, right?
09:49:17 <DrChaos> shachaf -> yes
09:49:19 <shachaf> Don't start with a definition.
09:49:29 <shachaf> Think about how you would sort a list, and then implement that.
09:50:12 <monochrom> that part is done. he has chosen insertion sort.
09:50:34 <`nand`> (has he? I thought that was a suggestion by shachaf)
09:50:38 <Estrellas> I wish everything in http://www.haskell.org/ghc/docs/ was blocked by robots.txt except for ./latest/ D:
09:50:46 <Estrellas> I keep finding old documentation via google
09:50:50 <osfameron> insertion sort seems quite tricky
09:50:54 <osfameron> compared to, say, quicksort
09:50:55 <`nand`> Estrellas: yeah, I have that problem as well
09:51:01 <`nand`> “quicksort”
09:51:09 <`nand`> and insertion sort can be very simple
09:51:41 * osfameron has no idea how to tackle insertion sort in haskell tbh
09:52:05 <DrChaos> How I'd do it is e.g. find the smallest item in the list, then copy that item into a temporary variable, remove the item from that location in the list, and then insert that item at the beginning of the list
09:52:34 <monochrom> that's what you get for "think how you would do it" :)
09:53:18 <`nand`> when I sort a deck of playing cards, I don't tend to copy around and delete cards :P
09:54:17 <beaky> what algorithm does sort use
09:54:40 <beaky> @src sort
09:54:41 <lambdabot> sort = sortBy compare
09:54:48 <monochrom> but you do reserve two area on your table or something, one area for unsorted cards, another area for sorted cards. the imperative programmer is just saying, use mutable variables to model those two areas.
09:54:53 <beaky> @src sortBy
09:54:53 <lambdabot> sortBy cmp = foldr (insertBy cmp) []
09:54:56 <Clint> beaky: http://www.haskell.org/ghc/docs/latest/html/libraries/base/src/Data-List.html#sort
09:55:08 <osfameron> "find the smallest item in the list" doesn't sound like insertion sort
09:55:12 <beaky> ah thnaks
09:55:14 <beaky> thanks*
09:55:19 <osfameron> don't you just iterate the whole list?
09:55:20 <beaky> so it uses insertion sort
09:55:30 <rwbarton> it doesn't actually of course
09:55:35 <beaky> oh
09:55:38 <rwbarton> the @src is a lie
09:55:47 <osfameron> @src cake
09:55:47 <lambdabot> Source not found. My mind is going. I can feel it.
09:55:49 <beaky> it uses mergesort!
09:55:54 <beaky> mergesort ftw
09:55:54 <`nand`> osfameron: no, that would be akin to selection sort
09:56:13 <beaky> at least it doesn't use bubblesort or thtat classic quicksort example :D
09:56:26 <osfameron> what's wrong with the classic quicksort?
09:56:30 <lambdabot> i love mergesorts
09:56:33 <lambdabot> they are so easy
09:56:51 <fmap> like monoids?
09:56:52 <monochrom> I use mergesort for student papers
09:57:14 <osfameron> I don't understand mergesort
09:57:23 <clinton> I guess selection sort was a bit trickier than I thought it would be
09:57:26 <clinton> http://ideone.com/GGrhyJ
09:57:38 <elkng> bonus
09:57:40 <beaky> lambdabot: I thought you loved monoids :(
09:57:44 <elkng> where are you
09:57:51 <monochrom> maybe I should try quicksort next time
09:58:02 <beaky> monochrom: try smoothsort! :D
09:58:14 <beaky> it's like heapsort on steroids
09:58:21 <`nand`> I think insertion sort is simplest in Haskell
09:58:22 <osfameron> oic, mergesort is very pretty
09:58:26 <beaky> http://en.wikipedia.org/wiki/Smoothsort
09:58:34 <lambdabot> :D
09:58:43 <Peaker> osfameron, quicksort has a bad worst-case
09:58:46 <beaky> :D
09:58:50 <`nand`> here's an implementation on the type level: http://hub.darcs.net/nand/units/browse/src/Units/Internal/Types.hs#132
09:59:00 <Peaker> but its average case is better, I read
09:59:10 <Peaker> (than the ones that make the worst-case be NlogN)
09:59:22 <`nand`> Peaker: the usual way to implement “quicksort” in Haskell is to always use the head as pivot
09:59:44 <Peaker> `nand`, well, that's not "quicksort" anyway
09:59:45 <`nand`> which isn't necessarily very optimal
10:00:56 <`nand`> thus the quotes
10:01:14 <Peaker> I was talking about the algorithm, though, not Haskell's impl
10:01:23 <Peaker> It sacrifices the worst-case for a better average case
10:03:28 <`nand`> yeah okay, fair enough
10:08:44 <beaky> are >>= and return analogous to mappend and mempty?
10:08:47 <ansy> hello
10:08:51 <beaky> hi :D
10:08:58 <rwbarton> join and return
10:09:00 <ansy> am new
10:09:03 <beaky> ah
10:09:08 <beaky> welcome :D
10:09:12 <ansy> thanks
10:09:25 <beaky> ^^
10:09:30 <ansy> whats all this about
10:09:52 <beaky> ansy: this channel is all about the Haskell programming language.
10:10:07 <ansy> K
10:10:12 <osfameron> did you come here via #ircroulette?
10:10:23 <ansy> how long will it take me to learn
10:10:30 <ansy> is it hard
10:10:31 <DrChaos_> How I'd do it is e.g. find the smallest item in the list, then copy that item into a temporary variable, remove the item from that location in the list, and then insert that item at the beginning of the list.
10:10:32 <werwerwer> 21 days
10:10:35 <DrChaos_> continue with the rest of list while lathering, rinsing, and repeating
10:10:39 <DrChaos_> how to actually code that in haskell I have no idea
10:10:43 <byorgey> ansy: yes, it is hard.
10:10:51 <DrChaos_> that's how I'd do insertion sort
10:10:54 <byorgey> it will take a long time to learn.
10:11:00 <byorgey> (but it is worth it =)
10:11:09 <osfameron> DrChaos_: ok, that sounds like selection sort
10:11:10 <ansy> how long... give pointers
10:11:23 <beaky> ansy: it will take you as long as it takes
10:11:23 <werwerwer> depends on what do you know alrady
10:11:29 <osfameron> DrChaos_: so you want a function that given a list returns (smallest_item, [rest of list])
10:11:52 <osfameron> e.g. selectSmallest :: (Ord a) => [a] -> (a, [a])
10:11:54 <byorgey> ansy: there is no magic point where suddenly you have "learned" a language.  There is only a continuum of understanding.
10:11:54 <ansy> beaky: nothing
10:11:57 <ansy> totally
10:12:05 <ansy> just googled it
10:12:11 <byorgey> ansy: but something on the order of a few months seems average, if you work at it consistently.
10:12:37 <beaky> ansy: to get started with Haskell, check out http://www.learnyouahaskell.com . It covers all of the basics of the language
10:12:45 <byorgey> that's to get to a point of "basic proficiency"
10:12:48 <DrChaos_> osfameron -> how do I remove an element from a list?
10:12:48 <ansy> what is the advantage to other languages.... and what is the poing anyway
10:13:15 <osfameron> DrChaos_: you can't.  you have to return a new list
10:13:19 <Taneb> ansy, referential transparency, that is, if x = y here, x = y ALWAYS
10:13:34 <DrChaos_> osfameron -> or return a new list with that element gone?
10:13:39 <osfameron> DrChaos_: yeah
10:13:41 <beaky> ansy: the biggest advantage of Haskell over other languages is that it reinforces the functional programming paradigm.
10:13:47 <Taneb> ansy, while that may seem bad if you've come from pretty much any other language, it turns out really useful
10:14:21 <ansy> give samples of robust apps in haskell
10:15:18 <paulkoer> dear all, may I ask a quick question regarding profiling with a executable build via cabal?
10:15:23 <Taneb> ansy, http://www.haskell.org/haskellwiki/Haskell_in_industry
10:15:29 <beaky> ansy: there are a number of web frameworks written in haskell; Yesod is one
10:15:33 <osfameron> DrChaos_: possibly using span?
10:16:04 <beaky> ansy: if you are familiar with tiling window managers, there's the excellent XMonad which is built on Haskell
10:16:05 <zomg> paulkoer: You have been granted an audience with the Lords of #haskell. You may proceed.
10:16:27 <osfameron> the Lords of #haskell are indeed merciful
10:16:36 <paulkoer> thank you my highness, this is too kind
10:16:50 <ansy> ok.. I will learn it just for the fun of it
10:16:58 <`nand`> ansy: an excellent choice
10:17:04 <paulkoer> I am for some reason unable to build an executable with profiling enabled
10:17:12 <beaky> Haskell is fun
10:17:17 <DrChaos_> osfameron -> do err... span (== smallestElement) theList?
10:17:27 <DrChaos_> s/do/so/
10:17:28 <paulkoer> basically I do `cabal configure --enable-executable-profiling`
10:17:41 * hackagebot yesod-rst 0.2.2 - Tools for using reStructuredText (RST) in a yesod application  http://hackage.haskell.org/package/yesod-rst-0.2.2 (PascalWittmann)
10:17:47 <ansy> hope it is fun
10:17:54 <beaky> Have fun hacking in Haskell, and always ask here if you have any haskell questions :D
10:18:05 <paulkoer> but when I want to run with +RTS -p it tells me that 'the flag -p requires the program to be built with -prof'
10:18:06 <osfameron> DrChaos_: something along those lines.  Have a play in ghci?
10:18:29 <ansy> K. will most definately do that
10:19:01 <paulkoer> when I try to build with 'ghc -prof ...' it works fine
10:19:17 <`nand`> ansy: you could get an idea of what the language is all about by reading LYAH: http://learnyouahaskell.com/
10:19:18 <ansy> l8r
10:21:05 <shapr> Is anyone doing real Haskell coding for the Raspberry Pi? 256mb of ram seems to limit what programs I can run, and I wonder if the new 512mb models ease that?
10:21:42 <paulkoer> anyone?
10:21:51 <luite> hm, running the programs should be quite doable, running ghc however :)
10:22:13 <shapr> luite: I don't really want to cross-compile
10:23:25 <`nand`> shouldn't 256 be plenty?
10:23:57 <beaky> there's embedded haskell? :D
10:24:13 <shapr> `nand`: Depends on what you want to compile. Attempting to build the Haskell Platform made me cry.
10:24:15 <zomg> I do haskell coding on a vps with 512mb ram and I must say it is sometimes sort of annoying
10:24:28 <zomg> certain things absolutely refuse to compile unless you mount additional swap space
10:24:43 <rwbarton> yep
10:24:50 <shapr> Perhaps there are ghc compile-time settings that can minimize the amount of RAM used?
10:24:58 <shapr> @seen dons
10:24:59 <lambdabot> Unknown command, try @list
10:25:02 <shapr> yah yah, I know.
10:25:54 <DrChaos> ok huh. I really just want a function that returns the list y up to the first match for (== listElement), then the rest of the list with the first match absent
10:26:20 <Rarrikins_r> > takeWhile (/= 5) [1..]
10:26:21 <lambdabot>   [1,2,3,4]
10:26:52 <DrChaos> does span do that?
10:27:20 <Rarrikins_r> > let zomg t (x:xs) = if t == x then [t] else x:zomg t xs in zomg 5 [1..]
10:27:22 <lambdabot>   [1,2,3,4,5]
10:27:35 <Rarrikins_r> No, span will drop the first match.
10:27:37 <rwbarton> span does pretty much that
10:28:10 <rwbarton> or break
10:28:39 <DrChaos> I really want the first match dropped, but available to me in a variable
10:28:43 <DrChaos> and only the first match dropped at that
10:28:49 <Rarrikins_r> Oh
10:28:54 <Rarrikins_r> Yeah, break will do it.
10:29:07 <Rarrikins_r> It'll give you two lists, the first of which you want and the second of which you want the head.
10:29:32 <Rarrikins_r> > let (ys, y:_) = break (==5) [1..] in (y, ys)
10:29:33 <lambdabot>   (5,[1,2,3,4])
10:30:18 <`nand`> zomg: that's interesting, I never knew GHC used so much memory during compilation
10:30:36 <`nand`> that said, I mount copious swap space on systems with low RAM
10:30:51 <`nand`> even my netbook, which has 1 GiB gets a 4 GiB swap space
10:30:56 <DrChaos> err...do I really want the head?
10:31:22 <zomg> `nand`: yeah pandoc was a particular pain in the ass, had to mount 3 gigs of additional swap for it to compile without segfaulting
10:31:26 * shapr reads http://labs.scrive.com/2011/08/running-ghc-on-low-memory-computers/
10:31:31 <DrChaos> if I just had the head of that list, then all I'd get is 1 back
10:31:52 <DrChaos> OH
10:31:52 <rwbarton> read Rarrikins_r's code again
10:31:53 <DrChaos> I see
10:32:11 * `nand` watches memory usage while compiling pandoc
10:32:52 <DrChaos> the second element of the tuple contains elements which match the predicate and the rest of the list after that
10:33:12 <`nand`> whoa, it exceeds firefox
10:33:18 <`nand`> that's quite something
10:33:29 <`nand`> went up to around 1 GB
10:33:53 <rwbarton> did you notice what cabal was doing at the time? was it a specific module, or during linking
10:34:21 <`nand`> it was a general increase throughout the entire compilation, starting somewhere at 100 MB or so and going up
10:34:37 <`nand`> it then repeated this entire process for the profiled version
10:34:37 <rwbarton> oh interesting
10:35:05 <rwbarton> do the individual module builds happen in the same ghc process? I guess that could save a lot of work
10:35:18 <`nand`> yeah, they seem to
10:35:22 <DrChaos> ok err...any idea how to write a function that finds the first occurance of the smallest element in a list?
10:35:29 <`nand`> the process remains constant throughout all of the modules, currently at [23 of 42]
10:35:33 <`nand`> process id*
10:35:43 <rwbarton> I wonder if that is bad for low-memory systems
10:35:47 <Rarrikins_r> DrChaos: Sure, just use minimum and elemIndex
10:36:11 <Nereid> there's probably a way that only has to go through the list once though
10:36:50 <`nand`> it reached [42 of 42] at about 600 MB resident and 800 MB virtual
10:37:03 <elkng> how to run haskel script in linux ?
10:37:27 <shapr> elkng: usually you compile it with ghc and run the resulting binary, but there is a #! hack if you use literate Haskell
10:37:44 <`nand`> you can use ‘runhaskell’ too
10:37:57 <DrChaos> I'd really like to write my own comparison function that only has to go through the list once...that looks like a sort algorithm all by itself!
10:38:06 <Rarrikins_r> > let zomg [] = Nothing; zomg (x:xs) = f 0 0 x xs where f i _ _ [] = i; f i j m (x:xs) = if x < m then f j (j + 1) x xs else f i (j + 1) m xs in zomg [1, 2, 1, 0, 3, 0]
10:38:08 <lambdabot>   No instance for (GHC.Num.Num (Data.Maybe.Maybe a0))
10:38:08 <lambdabot>    arising from a use o...
10:38:18 <Rarrikins_r> > let zomg [] = Nothing; zomg (x:xs) = Just $ f 0 0 x xs where f i _ _ [] = i; f i j m (x:xs) = if x < m then f j (j + 1) x xs else f i (j + 1) m xs in zomg [1, 2, 1, 0, 3, 0]
10:38:20 <lambdabot>   Just 2
10:38:26 <Rarrikins_r> No
10:38:39 <Rarrikins_r> > let zomg [] = Nothing; zomg (x:xs) = Just $ f 0 1 x xs where f i _ _ [] = i; f i j m (x:xs) = if x < m then f j (j + 1) x xs else f i (j + 1) m xs in zomg [1, 2, 1, 0, 3, 0]
10:38:41 <lambdabot>   can't find file: L.hs
10:38:59 <Rarrikins_r> > let zomg [] = Nothing; zomg (x:xs) = Just $ f 0 1 x xs where f i _ _ [] = i; f i j m (x:xs) = if x < m then f j (j + 1) x xs else f i (j + 1) m xs in zomg [1, 2, 1, 0, 3, 0]
10:39:01 <lambdabot>   Just 3
10:39:06 <Rarrikins_r> There we go.
10:39:09 * shapr digs around
10:39:23 <DrChaos> I really don't know how Rarrikins_r comes up with this stuff. I don't understand it
10:39:33 <Rarrikins_r> Lots of practice :)
10:39:52 <DrChaos> what are you doing? exchanging elements?
10:40:17 <elkng> ghc stands for gnu haskec compiller ?
10:40:20 <Rarrikins_r> DrChaos: No, just going through the list, keeping track of the minimum and its index as well as the current index.
10:40:21 <DrChaos> it looks like you exchange elements j with i and x with m
10:40:23 <`nand`> > getMin $ foldMap Min [1,3,1,0,3,4,5,3] :: Int
10:40:25 <lambdabot>   Not in scope: `getMin'
10:40:25 <lambdabot>  Perhaps you meant one of these:
10:40:25 <lambdabot>    `getLine' (impor...
10:40:28 <`nand`> blah
10:40:33 <Rarrikins_r> DrChaos: If you find a smaller element, replace the minimum and its index with that.
10:40:35 <`nand`> useless lambdabot
10:40:54 <`nand`> (note: don't actually do what I did; it would return maxBound :: Int for an empty list..)
10:41:12 <`nand`> elkng: no, Glasgow Haskell Compiler
10:42:01 <`nand`> > foldr1 min [1,3,1,0,3,4,5,3]
10:42:02 <DrChaos> stupid verizon wireless 3g modem
10:42:03 <lambdabot>   0
10:42:07 <`nand`> > foldr1 max [1,3,1,0,3,4,5,3]
10:42:08 <lambdabot>   5
10:42:12 <`nand`> tadaa, much easier than the stupid foldMap Min thing
10:42:22 <hpaste> shapr pasted “SheBang.lhs” at http://hpaste.org/79952
10:42:38 <Rarrikins_r> DrChaos: i is minimum's index, j is current list index, m is minimum element itself, x is current element we're looking at.
10:42:39 <rwbarton> > maximum [1,3,1,0,3,4,5,3]
10:42:41 <lambdabot>   5
10:42:54 <elliott> `nand`: btw, that's "ala Min foldMap"
10:42:54 <`nand`> shapr: yuck, \begin{code} :(
10:43:10 <`nand`> elliott: okay. But still comes with the silly Bounded
10:43:12 <elliott> shapr: you can do that with non-literate haskell nowadays I think
10:43:12 <Nereid> @let findMinimum = fst . foldl' (\(~(m,i),j) a -> if j == 0 || a < m then ((a,j),j+1) else ((m,i),j+1)) (error "empty list",0)
10:43:14 <lambdabot>  Defined.
10:43:15 <elliott> runhaskell will ignore the shebang
10:43:24 <DrChaos> Rarrikins_r -> wow, I'd like to use your solution, but now that you show me such beautiful code I can't use it anymore
10:43:27 <Nereid> > findMinimum "bcadae"
10:43:29 <lambdabot>   ('a',2)
10:43:34 <Nereid> > findMinimum []
10:43:36 <lambdabot>   *Exception: empty list
10:43:37 <hpaste> shapr pasted “SheBang.hs” at http://hpaste.org/79953
10:43:41 <Rarrikins_r> > let zomg2 [] = Nothing; zomg2 xs = elemIndex (minimum xs) xs in zomg2 [1,2,1,0,3,0]
10:43:42 <lambdabot>   Just 3
10:43:43 <shapr> `nand`: happy?
10:44:04 <Rarrikins_r> Hmm...
10:44:08 <Nereid> actually
10:44:09 <`nand`> shapr: I was going for bird tracks; but sure :)
10:44:11 <Nereid> that's stupid.
10:44:29 <shapr> `nand`: ok, hpaste your version with bird tracks :-P
10:44:38 <DrChaos> Rarrikins_r -> I'm happy with elemIndex I think
10:44:49 <Nereid> :t fst . minimumBy (comparing snd) . zip [0..]
10:44:51 <lambdabot> (Enum b, Num b, Ord a) => [a] -> b
10:44:52 <hpaste> “`nand`” annotated “SheBang.hs” with “SheBang.hs (annotation)” at http://hpaste.org/79953#a79954
10:44:55 <Nereid> much better.
10:45:03 <Nereid> > fst . minimumBy (comparing snd) . zip [0..] $ "bcadae"
10:45:05 <lambdabot>   2
10:45:09 <Nereid> > minimumBy (comparing snd) . zip [0..] $ "bcadae"
10:45:11 <lambdabot>   (2,'a')
10:45:18 <Nereid> do this.
10:45:26 <DrChaos> that is beautiful
10:45:44 <DrChaos> you guys are way in over my head
10:46:14 <Rarrikins_r> > let zomg3 = foldl1' (\(mi, me) (i, e) -> if e < me then (i, e) else (mi, me)) . zip [0..] in zomg3 [1,2,1,0,3,0]
10:46:16 <lambdabot>   (3,0)
10:46:17 <DrChaos> I'll use Nereid's solution because it seems like he's using standard library functions for the services they provide
10:46:24 <aristid> mm_freak_: remember the serializable applicative stuff we talked about earlier today?
10:46:27 <Nereid> I like my solution. ;)
10:46:29 <`nand`> > let minimumBy f = foldr (liftM2 f) Nothing in minimumBy min "bcadae"
10:46:31 <lambdabot>   Couldn't match expected type `Data.Maybe.Maybe a20'
10:46:31 <lambdabot>              with actua...
10:46:36 <shapr> `nand`: Will that work without being named .lhs ?
10:46:41 <`nand`> shapr: probably not
10:46:45 <`nand`> shapr: I forgot to change the title
10:47:05 <Rarrikins_r> Hmm.
10:47:09 <`nand`> oh
10:47:27 <Rarrikins_r> > fst . minimum . zip [0..] $ [1,2,1,0,3,0]
10:47:29 <lambdabot>   0
10:47:37 <Rarrikins_r> > fst . minimum . flip zip [0..] $ [1,2,1,0,3,0]
10:47:39 <lambdabot>   0
10:47:44 <Rarrikins_r> > snd . minimum . flip zip [0..] $ [1,2,1,0,3,0]
10:47:45 <lambdabot>   3
10:47:50 <`nand`> my version makes no sense either way, I don't want liftM2
10:47:59 <Nereid> I don't know what you're doing, `nand`.
10:48:21 <Nereid> :t foldr (liftA2 f) Nothing . map Just
10:48:21 <Rarrikins_r> There we go, thanks to Nereid's version :D
10:48:23 <lambdabot> (Show a, Show b, FromExpr b) => [a] -> Maybe b
10:48:29 <Nereid> :t foldr (liftA2 ?f) Nothing . map Just
10:48:31 <lambdabot> (?f::a -> b -> b) => [a] -> Maybe b
10:48:46 <Nereid> :t foldr (liftA2 ?f . Just) Nothing
10:48:47 <lambdabot> (?f::a -> b -> b) => [a] -> Maybe b
10:48:53 <`nand`> > let minimumBy _ [] = Nothing; minimumBy f xs = Just (foldr1 f xs) in minimumBy min "bcadae" -- this, Nereid
10:48:54 <lambdabot>   Just 'a'
10:49:13 <`nand`> but I wanted to get rid of the ugly foldr1
10:49:19 <Rarrikins_r> > minimum . flip zip [0..] $ [1,2,1,0,3,0]
10:49:21 <lambdabot>   (0,3)
10:49:23 <Nereid> > let g f = foldr (liftA2 f . Just) Nothing in (g min [2,1,3], g min [])
10:49:25 <lambdabot>   (Nothing,Nothing)
10:49:26 <Rarrikins_r> Returns element and index :D
10:49:28 <Nereid> oops
10:49:43 <Rarrikins_r> > minimum . flip zip [0..] $ "Hello, how are you today?"
10:49:45 <`nand`> Nereid: liftA2 is wrong, like I said
10:49:45 <lambdabot>   (' ',6)
10:49:49 <Nereid> I noticed.
10:50:07 <Nereid> > let g f = foldr (\a b -> liftA2 f (Just a) b <|> Just a) Nothing in (g min [2,1,3], g min [])
10:50:08 <lambdabot>   (Just 1,Nothing)
10:50:23 <DrChaos> Nereid -> can I make this one based instead of zero-based by simply replacing the [0..] with [1..]? findSmallest a = minimumBy (comparing snd) . zip [0..] $ a
10:50:26 <Nereid> yes
10:50:40 <DrChaos> whoa!
10:50:50 <Nereid> the zip just pairs the elements with indices
10:50:53 <Nereid> > zip [0..] "abcde"
10:50:55 <lambdabot>   [(0,'a'),(1,'b'),(2,'c'),(3,'d'),(4,'e')]
10:51:44 <Nereid> @src minimum
10:51:45 <lambdabot> minimum [] = undefined
10:51:45 <lambdabot> minimum xs = foldl1 min xs
10:52:09 <`nand`> yuck, undefined
10:52:12 <Nereid> :p
10:52:16 <Nereid> > minimum []
10:52:18 <lambdabot>   *Exception: Prelude.minimum: empty list
10:52:19 <flebron> zip = zipWith (,)
10:52:37 <Nereid> zipWith f = map (uncurry f) . zip
10:52:44 <`nand`> heh
10:53:17 <flebron> :p
10:53:25 <Nereid> @pl \f -> map (uncurry f) . zip
10:53:26 <lambdabot> (. zip) . map . uncurry
10:53:31 <Nereid> heh.
10:54:28 <Nereid> @ty \f -> liftA2 f
10:54:30 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
10:54:33 <Nereid> @ty \f -> fmap (uncurry f) . liftA2 (,)
10:54:35 <lambdabot> Monoid a => (a -> (a1, b1) -> b) -> (a, a1) -> (a, b1) -> b
10:54:38 <Nereid> oops
10:54:40 <flebron> pointfree is magic to me, mostly
10:54:52 <Nereid> @ty \f -> fmap (uncurry f) .: liftA2 (,)
10:54:53 <lambdabot> Applicative f => (a -> b1 -> b) -> f a -> f b1 -> f b
10:55:01 <Taneb> zip = getZipList .: liftA2 (,) `on` ZipList
10:55:10 <Nereid> that's what I was getting at.
10:55:12 <Hafydd> A good way to prove oneself as a wizard.
10:56:05 <Taneb> zipWith f = getZipList .: liftA2 f `on` ZipList
10:56:29 <shirt> is there something like colormake for cabal?
10:56:30 <Taneb> > let zipWith f = getZipList .: liftA2 f `on` ZipList in zipWith (+) [1,2,3] [4,5,6]
10:56:32 <lambdabot>   [5,7,9]
10:56:41 <DrChaos> err...where is this minimumBy function defined?
10:56:48 <Taneb> Data.List
10:56:50 <Nereid> use the hoogle
10:57:06 <DrChaos> @hoogle comparing
10:57:06 <lambdabot> Data.Ord comparing :: Ord a => (b -> a) -> b -> b -> Ordering
10:57:10 <Nereid> @hoogle minimumBy
10:57:10 <lambdabot> Data.List minimumBy :: (a -> a -> Ordering) -> [a] -> a
10:57:10 <lambdabot> Data.Foldable minimumBy :: Foldable t => (a -> a -> Ordering) -> t a -> a
10:57:23 <flebron> :t .:
10:57:25 <lambdabot> parse error on input `.:'
10:57:44 <Nereid> :t (.:) -- damn you Cale!
10:57:46 <lambdabot> (Functor g, Functor f) => (a -> b) -> f (g a) -> f (g b)
10:57:52 <`nand`> elliott: surely there must be some way to reduce “getZipList .: foo `on` ZipList” via lens combinators
10:58:03 <Nereid> :t let (.) = (Prelude..) in (.).(.)
10:58:05 <lambdabot> (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
10:58:16 <elliott> what is that in non-(.:) form, I find (.:) completely unreadable
10:58:23 <elliott> @src on
10:58:23 <lambdabot> (*) `on` f = \x y -> f x * f y
10:58:33 <elliott> also how does the `on` associate there
10:58:51 <edwardk> :t transposeOf
10:58:53 <lambdabot> LensLike ZipList s t [a] a -> s -> [t]
10:59:01 <elliott> `nand`: is that blah f x y = getZipList (f (ZipList x)) (f (ZipList y))?
10:59:12 <shachaf> elliott: That can't be right.
10:59:13 <`nand`> no
10:59:21 <shachaf> \x y -> getZipList $ ZipList x `f` ZipList y?
10:59:21 <`nand`> blah f x y = getZipList $ f (ZipList x) (ZipList y)
10:59:22 <Taneb> \f xs ys -> getZipList (liftA2 f (ZipList xs) (ZipList ys))
10:59:22 <elliott> er
10:59:22 <parcs> > ((+) `on` succ `on` succ) 0 0
10:59:24 <lambdabot>   4
10:59:37 <elliott> bah, edwardk gets to do it :P
10:59:51 <parcs> :t \f g -> (f .) . g
10:59:53 <lambdabot> (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
11:00:01 <Nereid> :t fmap fmap fmap
11:00:03 <lambdabot> (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
11:00:46 <Nereid> :t fmap fmap fmap fmap
11:00:48 <lambdabot> (Functor f2, Functor f1, Functor f) => f (f1 (a -> b)) -> f (f1 (f2 a -> f2 b))
11:01:09 <Nereid> :t fmap fmap fmap fmap fmap fmap
11:01:10 <lambdabot> (Functor f1, Functor f) => (a -> a1 -> b) -> f a -> f (f1 a1 -> f1 b)
11:01:12 <Nereid> :t (fmap fmap fmap fmap) fmap fmap fmap fmap fmap fmap
11:01:14 <lambdabot> (Functor f1, Functor f) => (a1 -> a -> b) -> f a1 -> f (f1 a -> f1 b)
11:01:18 <Nereid> proof that fmap fmap fmap fmap = id
11:01:18 <Taneb> :t stop
11:01:19 <lambdabot>     Not in scope: `stop'
11:01:20 <lambdabot>     Perhaps you meant `top' (imported from Data.Constraint)
11:01:54 <DrChaos> ok, now I am on part 2 of implementing selection sort: Remove the first occurence of the smallest item from a list
11:02:38 <DrChaos> I thought that was using the break function
11:02:43 <DrChaos> let me see...
11:04:27 <thoughtpolice> tel: ping
11:04:44 <knrafto> hi all. what's a good definition of "functional programming" that isn't too long and that doesn't contain too much jargon? i'm trying to write an essay about it
11:04:57 <shachaf> knrafto: There's no good definition.
11:05:07 <shachaf> "functional programming" is one of those words that everyone uses to mean whatever they want.
11:05:08 <Nereid> write an essy about how there's no good definition.
11:05:11 <shapr> knrafto: it's easier to describe 'pure' functional programming.
11:05:20 <`nand`> programming with functions
11:05:21 <shachaf> There's not much of a definition of that either.
11:05:24 <shapr> knrafto: Then you can say that every call to a function can be replaced by the result of that function.
11:05:30 <shachaf> It's a good term to use to start IRC arguments.
11:05:47 <knrafto> shapr: i think that counts as jargon
11:05:49 <`nand`> shachaf: you mean, like every word?
11:05:54 <shapr> knrafto: How so?
11:06:10 <DrChaos> huh? How do I use the break function with a list element index like: break (listElementIdxIsEqualTo 10) list
11:06:16 <Nereid> :t break
11:06:17 <lambdabot> (a -> Bool) -> [a] -> ([a], [a])
11:06:22 <Nereid> break won't do it.
11:06:27 <knrafto> if i'm writing it to a layperson, i'm not sure they'll know what a function call is
11:06:31 <shachaf> DrChaos: You don't.
11:06:36 <Nereid> at least, not by itself.
11:06:43 <shachaf> DrChaos: As I mentioned before, I strongly advise you to stop thinking in terms of indices.
11:06:52 <shapr> knrafto: In that case, how about saying it's like programming that follows the properties of math equations?
11:06:54 <shachaf> DrChaos: Indexing is generally a very bad way to work with Haskell lists.
11:07:17 <Nereid> I can't think of a much better way to remove the minimum element of a list though.
11:07:17 <shapr> knrafto: I don't know a good way to describe fp to a layperson. I don't know if they have enough context.
11:07:23 <`nand`> shapr: I don't think that's a definition of functional programming that will get you anwhere
11:07:26 <`nand`> anywhere*
11:07:44 <knrafto> it's not exactly a scholarly paper, so it'll work i think
11:07:57 <zomg> I wonder if you could define it as sort of like telling the computer what is the result you want, wherein in other languages you tell it the steps you want it to perform
11:08:08 <zomg> I mean you often see people talk about fp vs imperative sort of like that
11:08:13 <Nereid> that's not really a characteristic of functional programming though.
11:08:15 <shapr> zomg: Yah, I like that. But that also describes declarative and logic programming just as well.
11:08:17 <Nereid> that's more like declarative.
11:08:34 <`nand`> you could try introducing what a function is first
11:09:06 <zomg> yeah to be honest I'm not sure if a layperson really can understand the difference between functional programming and other types of programming
11:09:08 <`nand`> and then vaguely describe functional programming as “programming based on this concept of function”
11:09:14 <zomg> without understanding more of the related concepts first
11:09:31 <knrafto> how about "Functional programming is a programming paradigm that treats computation as the result of applying purely mathematical functions." ?
11:09:43 <shapr> procedure vs function, then "most programming uses procedures, fp uses functions" ?
11:09:51 <`nand`> knrafto: I think the more precise you want your definition to be, the less understandable it will be; so that's sort of not ideal for your target domain
11:10:04 <shapr> knrafto: still gonna glaze the eyes of a non-programmer, but I dunno how to improve it :-)
11:10:17 <DrChaos> all I want is a way to remove an element from the current location in the list, if I have to recurse until I reach a certain location in the list, so be it
11:10:21 <DrChaos> but, then if I want to stop thinking in terms of indexes, then this code is bad: selectionSort (x:xs) = let findSmallest a = minimumBy (comparing snd) . zip [0..] $ a
11:10:25 <knrafto> hmmm. maybe i'll just be vague and wave my hands a bit
11:10:35 <`nand`> the way you make it sound, a vague definition should be plenty
11:10:40 <`nand`> besides, it's a vague concept
11:10:52 <DrChaos> hello?
11:10:53 <knrafto> true. okay, thanks everybody
11:11:16 <shapr> DrChaos: OH HAI
11:11:18 <DrChaos> blasted internet connection...so blasted unstable
11:11:31 * shapr boings frumiously
11:11:38 <shapr> DrChaos: FP is more about finding things by value than by location.
11:11:52 <shapr> or maybe that's just Haskelley thinking?
11:12:10 * `nand` always feel like IRC isn't very well-suited to poor network conditions; there's no way of knowing whether your or others messages got lost in transit, other than by consulting public logs
11:12:11 <loekie> what is 'the current location in the list'?
11:12:14 <DrChaos> shapr -> then I really need to find the first occurance of the smallest value and go by that
11:12:14 <`nand`> s/feel/feels/
11:17:09 <DrChaos> I want a version of this function that doesn't use zip [i.e. return the indice of the element] at all: findSmallest a = minimumBy (comparing snd) . zip [0..] $ a
11:17:17 <DrChaos> shapr -> still there?
11:17:28 <`nand`> findSmallest = minimum
11:17:53 <Nereid> sure, you could just search for the minimum value in the list and then remove it
11:17:57 <osfameron> DrChaos: you don't care about indices
11:17:58 <Nereid> :t (\\)
11:18:00 <lambdabot> Eq a => [a] -> [a] -> [a]
11:18:02 <Nereid> oops
11:18:05 <Nereid> :t delete
11:18:06 <lambdabot> Eq a => a -> [a] -> [a]
11:18:11 <hpc> DrChaos: perhaps it would be easier to write something like
11:18:22 <Nereid> :t \xs -> delete (minimum xs) xs
11:18:24 <lambdabot> Ord a => [a] -> [a]
11:18:28 <hpc> selectMin :: Ord a => [a] -> (a, [a])
11:18:34 <osfameron> oh nice, delete is perfect
11:18:38 <Nereid> :t \xs -> let m = minimum xs in (m, delete m xs)
11:18:40 <lambdabot> Ord a => [a] -> (a, [a])
11:19:33 <Nereid> but this means you have to compare things in the list twice
11:20:06 <epta> How can I define Ord instance for `data M = A | B | C | D | E'? I need something like A < B < C < D < E
11:20:12 <Nereid> derive it
11:20:35 <`nand`> epta: deriving Ord
11:20:35 <elliott> data M = ... deriving (Eq, Ord)
11:20:37 <DrChaos> does a selection sort necessarily need to search ahead in a list to find the smallest value?
11:20:45 <`nand`> oh, yeah, you'll need eq
11:20:48 <`nand`> Eq*
11:21:08 <DrChaos> I really don't get this stuff at this early a stage in my programming career
11:21:23 <Nereid> I don't know what you mean
11:21:33 <Nereid> you definitely need to look at the entire list to find the minimum value
11:21:34 <epta> elliott: thanks
11:21:41 <DrChaos> ok
11:22:34 <Nereid> I'd still rather delete by index.
11:24:07 <DrChaos> me too
11:24:44 <monochrom> I would rather you just do insertion sort. it fits Haskell better.
11:25:26 <monochrom> But no, under the "you are learning" banner, people speak in terms of "you must not be told anything, you must figure it all out yourself"
11:25:27 <`nand`> Nereid: I'd rather just accumulate the ‘deleted’ list while selecting
11:25:38 <`nand`> Nereid: like select :: Ord a => [a] -> Maybe (a, [a]) -- then sort = unfoldr select
11:25:42 <shachaf> monochrom: I advised insertion sort initially.
11:25:53 <monochrom> methinks those people have mixed up "you have to learn this" and "you have to invent this"
11:26:13 <monochrom> oh yes, that was good advice
11:26:29 <Nereid> `nand`: yes, how to define select?
11:26:48 <monochrom> but your later "think how you sort" is a cause of disaster
11:26:58 <shapr> DrChaos: I got distracted by code, what?
11:27:28 <monochrom> how "you" sort is likely a nightmare to mimic in haskell. I have doubts on what one would learn from this.
11:30:20 <aristid> @tell mm_freak_ i believe what i thought about when talking about "serializable applicatives" were basically just iteratees, so you can replay the input sequence to them whenever you need to load
11:30:20 <lambdabot> Consider it noted.
11:30:25 <monochrom> in fact, why am I having doubts? the empirical experiment has already given the answer. one would learn list-index programming from this!
11:30:46 <shapr> What?
11:30:59 <shachaf> monochrom: I agree.
11:31:13 * shapr scrolls back
11:32:10 <shapr> disaster?
11:32:12 * shapr blinks
11:32:25 <shapr> I think learning involves lots of mistakes, and then understanding those mistakes.
11:32:45 <shapr> Doing things in a less than optimal way is just fine in my opinion.
11:33:04 * `nand` remains by his stance of “when he sorts, he doesn't count indices or copy elements or anything”
11:33:08 <Nereid> why isn't there a version of delete that takes a predicate?
11:33:08 <`nand`> like, in real life
11:33:13 <monochrom> that sounds great if the learner actually reaches the "and then understanding those mistakes" part
11:33:25 <shapr> monochrom: Why would you think they wouldn't?
11:33:33 <Nereid> @src delete
11:33:34 <lambdabot> delete = deleteBy (==)
11:33:37 <Nereid> @src deleteBy
11:33:37 <lambdabot> deleteBy eq x []        = []
11:33:37 <lambdabot> deleteBy eq x (y:ys)    = if x `eq` y then ys else y : deleteBy eq x ys
11:33:59 <monochrom> because I see a lot of learners who don't.
11:34:09 <Nereid> @let deleteP p [] = []; deleteP p (y:ys) = if p y then ys else y:deleteP p ys
11:34:11 <lambdabot>  Defined.
11:34:15 <Rarrikins_r> filter (not (==5)) [1..10]
11:34:21 <Rarrikins_r> > filter (not . (==5)) [1..10]
11:34:23 <lambdabot>   [1,2,3,4,6,7,8,9,10]
11:34:28 <monochrom> hell, I see a lot of learners who don't even know that what they do are mistakes.
11:34:29 <shapr> It sounds like you're saying learners should do the right thing from the very beginning. I don't think that's possible.
11:34:48 <Nereid> Rarrikins_r: that deletes all occurrences, not just the first.
11:34:53 <monochrom> I am not saying that
11:34:53 <Rarrikins_r> Oh, the first
11:35:10 <Rarrikins_r> > break (==5) [1..10]
11:35:11 <lambdabot>   ([1,2,3,4],[5,6,7,8,9,10])
11:35:14 <shapr> monochrom: Ok, I don't understand then. Can you explain?
11:35:35 <monochrom> I am attacking the attitude "you are learning, therefore I tell you nothing"
11:35:51 <shapr> oh
11:35:55 <Rarrikins_r> > (\(xs, (_:ys)) -> xs ++ ys) . break (==5) $ [1..10]
11:35:57 <lambdabot>   [1,2,3,4,6,7,8,9,10]
11:36:22 <Nereid> > (\(xs, (_:ys)) -> xs ++ ys) . break (==5) $ [1..4]
11:36:24 <lambdabot>   *Exception: <interactive>:3:2-26: Non-exhaustive patterns in lambda
11:36:37 <Nereid> > (\(xs, ys) -> xs ++ drop 1 ys) . break (==5) $ [1..4]
11:36:40 <lambdabot>   [1,2,3,4]
11:38:43 <monochrom> "think how you would do ____ yourself, then code it in haskell" results in recalling previously learned imperative algorithms for ____, then coding it in Haskell
11:39:30 <monochrom> if your goal is to nurture how to translate imperative algorithms into Haskell, and undermine learning functional programming, congratulations
11:40:01 <Nereid> unfoldr select is a cool thing I guess.
11:40:20 <Nereid> if only select could be done more nicely.
11:40:27 <Nereid> > let select [] = Nothing; select xs = let pairs = zip [0..] xs; (i,m) = minimumBy (comparing snd) pairs in Just (m, map snd . deleteP ((i==) . fst) $ pairs) in unfoldr select "bcadae"
11:40:30 <lambdabot>   "aabcde"
11:40:30 <shapr> monochrom: So perhaps a more useful approach would be to give a basic description of what flavor of algorithms work well in pure fp as opposed to what basic algorithms work in imperative languages?
11:40:40 <Nereid> time to go
11:40:41 <monochrom> most students are not going to invent functional algorithms by themselves. no amount of thinking will accomplish that. they must be told actual algorithms. they must be told a big part of the answer.
11:40:50 <monochrom> yes
11:41:00 <shapr> If that sort of basic introduction were available, learnings could figure out how to usefully convert imperative algorithms into pure fp-friendly algorithms?
11:41:44 <osfameron> Nereid: do you need the indices? couldn't you just delete minimum ?
11:41:56 <osfameron> Nereid: but looks good anyway!
11:43:14 <monochrom> yes
11:43:29 <shapr> monochrom: and then you could just link newbies to that sort of document.
11:43:48 <monochrom> yes
11:46:30 <niteria> @src unfoldr
11:46:30 <lambdabot> unfoldr f b  = case f b of
11:46:31 <lambdabot>    Just (a,new_b) -> a : unfoldr f new_b
11:46:31 <lambdabot>    Nothing        -> []
11:46:51 <mreh> why won't cabal-dev use my libraries installed in ~/.cabal ?
11:47:06 <mreh> I thought it was normal behavious
11:47:14 <mreh> behaviour*
11:47:43 * hackagebot snaplet-fay 0.3.0.1 - Fay integration for Snap with request- and pre-compilation.  http://hackage.haskell.org/package/snaplet-fay-0.3.0.1 (AdamBergmark)
11:48:14 <hpaste> “`nand`” pasted “Select function” at http://hpaste.org/79955
11:48:23 <`nand`> Nereid: here's my first stab at the selection function
11:48:26 <`nand`> it isn't very pretty though
11:48:52 <shachaf> Your first "stab" doesn't even have any lenses in it.
11:48:58 <monochrom> haha
11:50:03 <niteria> @src (><)
11:50:04 <lambdabot> Source not found. Just what do you think you're doing Dave?
11:50:31 <mreh> I only just discovered <> the other day
11:50:34 <mreh> :t (<>)
11:50:35 <lambdabot> Monoid m => m -> m -> m
11:50:45 <mreh> is it new?
11:50:59 <shachaf> Not all that new.
11:51:34 <niteria> :t mappend
11:51:35 <lambdabot> Monoid a => a -> a -> a
11:51:50 <`nand`> seems it's been there since base 4.5.0.0
11:51:59 <`nand`> in Data.Monoid, at least
11:52:13 <`nand`> there's also (Data.Semigroup.<>) or whatever
11:53:13 <mreh> ahah, that must be it, I just got onto base 4.5.* recently
11:53:55 <niteria> huh, Data.Sequence is pretty cool
11:54:42 <niteria> someone needs to make a list of general purpose useful libraries
11:54:49 <shapr> niteria: write a blog post?
11:54:56 <`nand`> 1. lens
11:55:02 <shapr> I still haven't tried lens.
11:55:13 <niteria> with C++ there is STL and then boost
11:55:35 <hpc> niteria: that list would pretty much be the platform
11:55:44 <niteria> with Haskell i feel it's all over the place
11:55:46 <`nand`> but the haskell-platform doesn't even contain lens
11:55:49 <hpc> plus maybe lens if it isn't already there
11:55:52 <mreh> I wish I knew Free, all the cools kids seem to be talking about it
11:55:57 <mreh> and lenses
11:56:01 <hpc> lenses are new enough that they aren't quite ready yet
11:56:02 <edwardk> `nand`: and i don't want it to. we release more frequently than the platform
11:56:02 <niteria> Free monad?
11:56:08 <Clint> platform has all kinds of things that i've never used
11:56:09 <edwardk> the platform is a ball and chain around any release cycle
11:56:21 <mreh> and Cont, I never learned Cont, not that that has stopped me
11:56:32 <`nand`> edwardk: right, my point is just that the haskell platform isn't a good resource for this
11:56:48 <monochrom> Data.Sequence comes with GHC. there is no need for a list for that. you just need to read GHC documentation more attentively
11:56:51 <`nand`> does the platform have Data.Sequence?
11:56:59 <niteria> there was this advent calendar of Haskell packages, it was cool
11:57:05 <`nand`> oh, it's in containers
11:57:08 <niteria> but not really general purpose
11:57:11 <`nand`> so I'm guessing that's a ‘yes’
11:57:21 <geekosaur> it's part of the compiler, effectively, yes
11:57:31 <`nand`> yeah, it's distributed with GHC
11:57:42 <shapr> :t chunksOf
11:57:43 <lambdabot> Int -> [e] -> [[e]]
11:57:46 <niteria> I feel like a caveman, consing values to my lists
11:58:05 <mreh> at least you aren't using array indeces still
11:58:10 <`nand`> niteria: and lens would be the ‘december 25th’ (or whatever date christmas is)? ;)
11:58:21 <shapr> Hrm, where's the chunksOf that's not specific to Text?
11:58:32 <elliott> @hoogle chunksOf
11:58:32 <lambdabot> Data.Text chunksOf :: Int -> Text -> [Text]
11:58:32 <lambdabot> Data.Text.Lazy chunksOf :: Int64 -> Text -> [Text]
11:58:37 <elliott> isn't it in Prelude
11:58:54 <shapr> jmcarthur introduced me to it recently, and I want to use it more.
11:58:56 <niteria> I occasionally use Data.Map
11:59:04 <shapr> I thought it was in Data.List.Split from byorgey
11:59:31 <ClaudiusMaximus> http://www.haskell.org/hoogle/?hoogle=Int+-%3E+[a]+-%3E+[[a]]+%2Bsplit
11:59:37 <`nand`> edwardk: re: what shapr asked, how about Iso-y thing for coercion between lazy and strict versions of types, including an overloaded chunksOf ?
11:59:51 <elliott> `nand`: said iso-y thing exists
11:59:52 <monochrom> Int -> [e] -> [[e]] is in split
12:00:07 <`nand`> elliott: packed.unpacked I guess?
12:00:22 <elliott> no I mean there's an actual class :P
12:00:29 <hpaste> Ayey pasted “myFunction” at http://hpaste.org/79956
12:00:34 <elliott> http://ekmett.github.com/lens/Control-Lens-Iso.html
12:00:36 <elliott> Strict in there
12:00:39 <shachaf> @ty strict
12:00:40 <lambdabot> (Functor f, Strict s t a b, Isomorphic k) => k (a -> f b) (s -> f t)
12:00:44 <`nand`> oh, indeed
12:00:47 <shachaf> Ew. Old Iso.
12:01:05 <shachaf> strict :: Strict s t a b => Iso s t a b -- good class
12:01:19 <Ayey> Could someone explain to me why my function is not working? I'm really new to Haskell - http://hpaste.org/79956
12:01:40 <monochrom> because n and xs have conflicting types
12:01:53 <`nand`> huh; it's Strict s a => Iso' s a in HEAD
12:01:53 <Ayey> meaning?
12:02:05 <monochrom> "if ... then b else c" requires b,c to be of the same type
12:02:09 <hpc> :t \p x y -> if p then x else y
12:02:11 <lambdabot> Bool -> t -> t -> t
12:02:35 <elliott> `nand`: the s t a b form messed up inference
12:02:42 <monochrom> your program would work in Scheme
12:02:42 <niteria> Ayey: xs is of type [a], n is of type a
12:02:46 <hpc> :t \n xs -> if n == head xs then undefined else undefined
12:02:47 <lambdabot> Eq a => a -> [a] -> a1
12:02:48 <`nand`> Ayey: type error; ‘n’ is a single element, but ‘xs’ is a list of elements
12:02:58 <edwardk> :t strict
12:02:59 <lambdabot> (Functor f, Strict s t a b, Isomorphic k) => k (a -> f b) (s -> f t)
12:03:02 <hpc> (n :: a, xs :: [a])
12:03:03 <edwardk> `nand`: like that?
12:03:10 <Ayey> Ahh
12:03:11 <edwardk> `nand`: it doesn't have chunks
12:03:13 <Ayey> Thank you!
12:03:14 <aristid> man how unprofunctorial
12:03:16 <`nand`> edwardk: yeah, but with chunks :P
12:03:18 <aristid> boo lambdabot
12:03:25 * `nand` .oO( noobfunctor )
12:03:34 <shachaf> Ayey: An easy way to figure out things like this is to write out the type explicitly.
12:03:38 <shachaf> It helps you think about the function.
12:04:24 <monochrom> now I wonder if Agda accepts it too
12:04:55 <`nand`> Eq a => a -> [a] -> exists t. t a
12:04:58 * `nand` ducks
12:05:08 <`nand`> (mangle in an Identity)
12:08:07 <jfischoff> is anyone familiar with a automatic differentiation package that would let me take the gradient of dot(grad f, grad f)?
12:08:23 <elliott> jfischoff: there's edwardk's ad, but I don't know how much it can do
12:08:35 <hpc> @hoogle gradient
12:08:36 <lambdabot> No results found
12:08:39 <hpc> hmm
12:08:46 <hpc> i know i saw it at some point
12:09:02 <edwardk> :t grad
12:09:04 <lambdabot> (Num a, Traversable f) => (forall (s :: * -> *). Numeric.AD.Types.Mode s => f (AD s a) -> AD s a) -> f a -> f a
12:09:16 <edwardk> you can nest gradients with ad
12:09:42 <jfischoff> edwardk: can I dot the grad and then grad again though?
12:09:46 <edwardk> yes
12:09:52 <edwardk> you wind up with two infinitesimals
12:10:07 <jfischoff> okay I'll try
12:10:21 <edwardk> @ty auto
12:10:23 <lambdabot> (Num a, Numeric.AD.Types.Mode t) => a -> t a
12:10:28 <edwardk> you may need to lift with that appropriately
12:10:35 <jfischoff> ah
12:10:43 <jfischoff> okay that makes sense
12:11:01 <edwardk> the infinitesimal keeps you from screwing up the placement of them, by ensuring your program always makes sense if it compiles
12:11:28 <jfischoff> I still don't understand the types in AD
12:11:38 <Ralith> AD?
12:11:47 <edwardk> AD s a   is 'a' augmented with information about its derivatives.
12:11:49 <edwardk> @hackage ad
12:11:50 <lambdabot> http://hackage.haskell.org/package/ad
12:11:54 <edwardk> Ralith: ^-- that
12:12:21 <Ralith> ah, differentiation
12:12:31 <edwardk> AD Forward Int is a simple forward mode where you pair a value with a single derivative
12:12:46 <edwardk> AD Reverse Int uses tricks to get a unique tape
12:12:49 <edwardk> etc.
12:12:55 <jfischoff> ah
12:13:10 <edwardk> quantifying over the mode lets me pick the appropriate mode for each operation
12:13:22 <jfischoff> right
12:13:24 <edwardk> it also lets the mode act as a, "ST s"-like hack
12:13:33 <edwardk> where it doubles as an infinitesimal
12:13:33 <jfischoff> ah
12:13:44 <jfischoff> now you have lost me
12:13:57 <jfischoff> how is an infinitesimal?
12:14:01 <jfischoff> is it
12:14:41 <edwardk> its just saying 'what you are taking a derivative with regards to. its infinitesimal because in forward mode we compute with dual numbers. a + i b   where i^2 = 0, but i /= 0.
12:14:45 <edwardk> i is our infinitesimal
12:15:04 <edwardk> in other modes its a more generalized scheme
12:15:17 <edwardk> but the laws remain the same
12:15:54 <jfischoff> hmm I'll have to look at the docs more I guess
12:17:29 <jfischoff> edwardk: do you know how you CG compares to this one? http://hackage.haskell.org/package/nonlinear-optimization
12:17:36 <edwardk> jfischoff: http://conway.rutgers.edu/~ccshan/wiki/blog/posts/Differentiation/ talks about what happens when you don't have something like that
12:17:54 <jfischoff> thanks
12:17:58 <edwardk> jfischoff: well, they've obviously given it more thought than i have ;)
12:18:17 <jfischoff> :)
12:19:24 <edwardk> it might be worth trying to adapt that to use ad.
12:19:49 <jfischoff> I'll look into it
12:19:51 <edwardk> they have a pretty craptastic api though
12:19:56 <jfischoff> yeah
12:20:00 <jfischoff> it works though
12:20:17 <jfischoff> seems fast enough but I haven't tried to profile it or anything
12:20:22 <edwardk> it looks short at least
12:20:40 <jfischoff> is it now, haven't looked
12:20:46 <edwardk> http://hackage.haskell.org/packages/archive/nonlinear-optimization/0.3.6/doc/html/src/Numeric-Optimization-Algorithms-HagerZhang05.html#optimize
12:21:02 <jfischoff> there is a c file too
12:21:04 <jfischoff> I think
12:21:28 <edwardk> well, i look forward to our new improved 'ad' version ;)
12:21:38 <jfischoff> :)
12:22:08 <edwardk> i had someone who was contacting me about adding CG, BFGS, etc. but not much has come of it yet
12:23:36 <jfischoff> so is auto used like this: grad . auto  . magnitude . grad $ f ?
12:25:06 <jfischoff> well I guess no
12:26:12 <edwardk> grad is going to give you a vector/list out. so you need something to compute the magnitude of a vector then you can just use grad on that directly
12:27:59 <jfischoff> holy shit
12:29:50 <edwardk> > grad (\ys -> sum $ map (\x -> x * x) $ grad product ys) [1..10]
12:29:52 <lambdabot>   [196097332838400,135326876774400,194566905446400,400677236582400,9424685651...
12:30:12 <edwardk> swap product for 'f'
12:32:19 <edwardk> > let sumSq = sumOf (folded.to(^2)) in grad (sumSq . grad product) [1..10]
12:32:21 <lambdabot>   [196097332838400,135326876774400,194566905446400,400677236582400,9424685651...
12:32:23 <shapr> jmcarthur: Where was that chunksOf function that wasn't specific to Text?
12:32:44 * hackagebot openpgp 0.5 - Implementation of the OpenPGP message format  http://hackage.haskell.org/package/openpgp-0.5 (StephenWeber)
12:33:04 <shachaf> Data.List.Split?
12:33:17 <shachaf> Kind of misleading if you ask me. byorgey should've known better than to pick a lensy name.
12:33:29 <edwardk> hah
12:33:45 <edwardk> we came close to naming prisms 'splitters'
12:35:50 <byorgey> are the any names which aren't lensy?
12:36:15 <Ralith> longer english words
12:36:19 <byorgey> I heard that in the next release the Prelude is going to be subsumed into lens
12:36:20 <edwardk> Ralith: heh
12:36:46 <byorgey> =)
12:36:49 <monochrom> you could try animal names. dog, cat, batman!
12:37:07 <monochrom> sorry, batman is not an animal name, but an animaly name
12:37:28 <shachaf> bats and mans are both animals
12:37:32 <shachaf> sounds animaly to me
12:37:53 <monochrom> rename ^. to felicify :)
12:39:11 <shapr> oh it IS Data.List.Split!
12:39:49 <rwbarton> or how about a blender theme
12:39:54 <rwbarton> chop
12:40:00 <rwbarton> mash
12:42:07 <hiptobecubic> What's a good example of a functor that is not an Applicative?
12:42:33 <edwardk> newtype Const m a = Const m
12:43:05 <hpc> fmap _ x = x
12:43:13 <hpc> pure a = {- wtf -}
12:43:49 <monochrom> error "pure is not implemented in version 3.4"
12:44:25 <byorgey> hiptobecubic: there are not very many of them
12:45:08 <byorgey> rwbarton: there are lots of names available in that theme, as evidenced by the fourteen (!) different settings on my blender, all with a different name
12:45:56 <byorgey> as far as I can tell the names play no significant role whatsoever.  They should have just put "fast", "really fast", "super fast", "ok, seriously fast", ...
12:46:22 <Ralith> my blender has three settings: 'off', 'on', and 'pulse'
12:46:23 <Taneb> "now this is legally a jet engine"
12:47:00 <byorgey> Ralith: the new blender we got is the same.  I think blender quality is inversely proportional to the number of settings
12:47:01 <elliott> edwardk: er, Const is an Applicative, surely?
12:47:04 <elliott> just it has a constraint on the m
12:47:11 <monochrom> Q: "on a scale of 1-14, how do you like Haskell?" A: "mash"
12:47:22 <edwardk> elliott: it only becomes Applicative with the monoid.
12:47:22 <byorgey> "puree"
12:47:30 <elliott> right
12:47:30 <Ralith> byorgey: seems quite likely.
12:47:32 <edwardk> but if you know nothing about m you don't get to be Applicative
12:47:38 <hiptobecubic> Const m a = Const a?  What does this do for us?
12:47:52 <elliott> that's Tagged
12:47:56 <elliott> not Const
12:48:11 <monochrom> no, Const m a = Const m
12:48:16 <edwardk> hiptobecubic: it provides about a third of the functionality in lens. ;)
12:48:31 <edwardk> > ("hello","world")^._2
12:48:33 <lambdabot>   "world"
12:48:36 <monochrom> and it is an example of functor but not applicative
12:48:39 <edwardk> that uses Const under the hood
12:48:54 <hiptobecubic> But what the 'a' there
12:48:57 <hiptobecubic> what is*
12:48:58 <elliott> > ["a","b","c"]^._head -- uses Const m as an Applicative for Monoid m
12:49:00 <Taneb> Who cares
12:49:00 <lambdabot>   Not in scope: `_head'
12:49:00 <lambdabot>  Perhaps you meant one of these:
12:49:00 <lambdabot>    `head' (imported ...
12:49:02 <elliott> gah
12:49:07 <Taneb> You don't need an a
12:49:15 <edwardk> Tagged m a = Tagged a    Const m a = Const m
12:49:22 <edwardk> its a 'Functor' trivially.
12:49:40 <byorgey> hiptobecubic: anything you want! =)
12:49:48 <hiptobecubic> Why would you want it?
12:50:07 <edwardk> hiptobecubic: implement foldMap using traverse
12:50:22 <hiptobecubic> and if you create a value, say Const 0, what is its type?
12:50:36 <shachaf> hiptobecubic: It's like Writer -- (w,a) -- but without the (a) part.
12:50:37 <monochrom> forall a. Const Integer a
12:50:41 <shachaf> So just (w)
12:50:41 <`nand`> Num a => Const a m
12:50:48 <byorgey> hiptobecubic: the point is that it fits into the pattern of existing type classes like Functor, Applicative, and Traversable
12:50:58 <elliott> :t Const 0
12:50:59 <lambdabot> Num a => Const a b
12:51:00 <edwardk> @src foldMapDefault
12:51:00 <lambdabot> Source not found. :(
12:51:05 <edwardk> @source foldMapDefault
12:51:06 <lambdabot> foldMapDefault not available
12:51:07 <elliott> Const Integer a, say
12:51:10 <edwardk> i can never remember how that works
12:51:18 <shachaf> edwardk: A good rule of thumb is "doesn't"
12:51:20 <elliott> edwardk: it doesn't
12:51:26 <edwardk> foldMapDefault f = getConst . traverse (Const . f)
12:51:40 <edwardk> :t \f -> getConst . traverse (Const . f)
12:51:41 <lambdabot> (Traversable t, Monoid b) => (a -> b) -> t a -> b
12:51:45 <byorgey> I doubt foldMapDefault is in the text file that lambdabot consults for @src
12:51:55 <`nand`> it isn't
12:52:01 <edwardk> hiptobecubic: that uses 'Const' to implement foldMap in terms of traverse
12:52:10 <edwardk> :t \f -> runIdentity . traverse (Identity . f)
12:52:11 <shachaf> @source Data.List
12:52:12 <lambdabot> http://darcs.haskell.org/packages/base/Data/List.hs
12:52:12 <lambdabot> Traversable t => (a -> b) -> t a -> t b
12:52:23 <edwardk> that uses Identity to implement fmap in terms of traverse
12:52:37 <edwardk> these together motivate why Functor and Foldable are superclasses of Traversable
12:52:48 <edwardk> but you -need- Const for that purpose
12:53:17 <hiptobecubic> hmm
12:53:29 <shachaf> @ty \f -> runWriter . traverse (writer . f)
12:53:31 <lambdabot> (Traversable t, Monoid w) => (a -> (b, w)) -> t a -> (t b, w)
12:53:37 <edwardk> it also showcases why Traversable only uses Applicative not Monad, because Const can be Applicative when m is a Monoid, but it _can't_ be a Monad.
12:54:02 <edwardk> shachaf: showoff =P
12:55:16 <shachaf> @ty \f g -> runWriter . traverse (writer . (f &&& g)) -- maybe this
12:55:18 <lambdabot> (Traversable t, Monoid w) => (a -> b) -> (a -> w) -> t a -> (t b, w)
12:55:37 <shachaf> Of course that won't let you change the type.
12:56:09 <`nand`> it won't?
12:56:20 <edwardk> @ty \f -> runWriter . traverse (writer . (f &&& f))
12:56:22 <lambdabot> (Traversable t, Monoid w) => (a -> w) -> t a -> (t w, w)
12:56:28 <edwardk> @ty \f -> snd . runWriter . traverse (writer . (f &&& f))
12:56:29 <lambdabot> (Traversable t, Monoid b) => (a -> b) -> t a -> b
12:57:07 <`nand`> :t \f -> runWriter . traverse (writer . f) . liftM2 (,)
12:57:09 <lambdabot> (Monad m, Traversable ((->) (m a2)), Monoid w) => (m (a1, a2) -> (b, w)) -> m a1 -> (m a2 -> b, w)
12:57:16 <`nand`> oops :(
12:57:27 <`nand`> :t (\f -> runWriter . traverse (writer . f)) . liftM2 (,)
12:57:28 <lambdabot> (Monad ((,) b), Traversable t, Monoid a1, Monoid a2) => (b, a1) -> t (b, a2) -> (t b, (a1, a2))
12:57:39 <`nand`> that failed hilarious as well
12:57:46 * `nand` gives up golfing. temporarily.
12:58:34 <`nand`> oh wait, I was close
12:58:37 <`nand`> :t (\f -> runWriter . traverse (writer . f)) .: liftM2 (,)
12:58:39 <lambdabot> (Traversable t, Monoid w) => (a -> b) -> (a -> w) -> t a -> (t b, w)
12:59:26 <simpson> What is everybody trying to make?
13:02:42 <byorgey> simpson: apparently, a function that lets you do fmap and foldMap at the same time
13:03:02 <edwardk> simpson: shachaf was making lie of my simplification of what you need to implement foldMap in terms of traverse
13:04:09 <byorgey> it makes sense though.  Writer gives you fmap *and* foldMap.  If you want just the foldMap part then you throw away the 'a' part of the Writer, which gives you Const.
13:04:22 <shachaf> byorgey: Except it's not actually Const.
13:04:26 <shachaf> You don't get coerce
13:04:27 <byorgey> oh?
13:04:30 <shachaf> (:: Const a b -> Const a c)
13:04:46 <shachaf> So you can't change the type.
13:05:23 * byorgey doesn't follow
13:05:24 <simpson> Aha.
13:11:09 <edwardk> class Functor f => Gettable f where coerce :: f a -> f b; such that fmap f = coerce
13:11:43 <edwardk> it applies for any 'Functor' that doesn't use its argument at all
13:12:08 <edwardk> instance Gettable Proxy where coerce Proxy = Proxy  -- etc
13:12:22 * elliott wonders if you can write a Functor which somehow doesn't ignore its argument but is also Gettable.
13:12:36 <edwardk> elliott: see BazaarT ;)
13:12:44 <elliott> edwardk: :(
13:12:54 * elliott doesn't quite understand BazaarT.
13:13:14 <Taneb> edwardk, lens is the most ridiculous library in the history of programming, confirm/deny
13:13:27 <shachaf> elliott: Remember when BazaarT was called EvilBazaar?
13:13:28 <otters> testify
13:13:33 <otters> :i BazaarT
13:13:59 <Taneb> BazaarT {runBazaarT :: forall f. Applicative f => p a (f b) -> f t}
13:14:04 <edwardk> Taneb: i'm biased. ask others
13:14:20 <ion> taneb: I can confirm/deny that.
13:14:44 <cmccann> yes, that's definitely confirmed/denied.
13:14:48 <shachaf> elliott: You understand Bazaar, right?
13:14:58 <shachaf> https://github.com/ekmett/lens/commit/7ec5e55c
13:15:11 <Taneb> I think it's funny how in Haskell, += does roughly what it does in other languages, but it's in a new library not installed by default
13:15:18 <edwardk> lens is my attempt to help other people see the world the same way i do
13:15:26 <otters> Taneb: well, that's why it's called that
13:15:46 <elliott> shachaf: That doesn't really help me understand what it does.
13:16:07 <ion> elliott: https://github.com/ekmett/lens/wiki/Evaluations “Bazaar”
13:16:11 <edwardk> elliott: BazaarT is a Bazaar, it just pretends to limit its functionality based on what 'f' provides
13:16:25 <edwardk> in particular it claims to be Gettable if 'f' is Gettable.
13:16:38 <elliott> ion: That doesn't have BazaarT.
13:16:39 <shachaf> If you actually coerce it, you get an error.
13:16:41 <edwardk> then we only construct them in limited environments where the user doesn't get them
13:16:45 <elliott> yes, I know what happens if you coerce it
13:16:50 <elliott> I'm just not sure why you actually need it
13:16:56 <shachaf> The thing is that you never actually coerce it.
13:17:00 <shachaf> @ty taking
13:17:02 <lambdabot> Applicative f => Int -> SimpleLensLike (Control.Lens.Internal.BazaarT a a f) s a -> SimpleLensLike f s a
13:17:20 <shachaf> > [1..10]^..taking 5 traverse
13:17:23 <lambdabot>   [1,2,3,4,5]
13:17:31 <edwardk> elliott: write 'taking' so you pass it a Getter, Fold, Traversal, or Lens and get a Fold, Fold, Traversal or Travesal.
13:17:35 <shachaf> > [1..10] & taking 5 traverse +~ 1
13:17:37 <lambdabot>   [2,3,4,5,6,6,7,8,9,10]
13:17:45 <shachaf> > [1..10]^..taking 5 folded -- better example
13:17:48 <lambdabot>   [1,2,3,4,5]
13:17:50 <edwardk> elliott: thats what BazaarT is for
13:17:52 <hpc> shachaf: holy pants i did not even realize that was haskell
13:17:56 <elliott> well, sure, I get that it's used to do that
13:18:01 <elliott> but not how it actually helps
13:18:02 <edwardk> and what all my PretextT changes are for
13:18:12 <shachaf> Wait, we have PretextT now? :-(
13:18:27 <edwardk> shachaf: yes
13:18:34 <shachaf> For what?
13:18:45 <Taneb> Couldn't you use Either s (s, Sum Int) and foldlMof, or am I being stupid
13:18:49 <shachaf> Oh, locus?
13:18:57 <edwardk> it is for work in progress changes to Control.Lens.Lens to make it so more combinators preserve the meaning of the index
13:19:02 <shachaf> Hmm, no.
13:19:10 <shachaf> Ah, OK.
13:19:23 <edwardk> e.g. taking can leave the index intact
13:19:30 <edwardk> all for the low low price of a more complicated signature
13:20:11 <hpc> you can have all the theorems you want for the low, low price of FREE!
13:21:17 <shachaf> elliott: I hope you can find a better solution than BazaarT.
13:21:46 <elliott> shachaf: Well, if I understood how it worked...
13:22:37 <shachaf> elliott: *I* didn't have that luxury when I was trying to solve that problem!
13:23:07 <elliott> I hear edwardk thinks there's no better way
13:23:17 <shachaf> He's just a pessimist.
13:23:42 <Taneb> Optimism throw stalwart scepticism.
13:23:53 <Taneb> That's why you're our leader, shachaf.
13:23:59 <elliott> shachaf: So, how come taking needs the "f" it uses to be a Gettable instance?
13:24:10 <elliott> As in the f it passes to SimpleLensLike
13:24:52 <shachaf> elliott: Think about how a "real" Gettable thing would work.
13:24:57 <shachaf> Say, something like Indexing.
13:25:02 <edwardk> elliott: if you just make it Gettable you can try to do things like traverseof (taking 10 folded)
13:25:04 <shachaf> instance Gettable f => Gettable (Indexing f) where coerce (Indexing m) = Indexing $ \i -> case m i of (ff, j) -> (coerce ff, j)
13:25:15 <edwardk> you want the output to be Gettable if the input is gettable
13:25:21 <shachaf> edwardk: I bet you could replace that instance with undefined and it would keep working, by the way.
13:25:41 <shachaf> Uh oh.
13:25:59 <shachaf> Wait, never mind.
13:26:05 * shachaf reinstalls lens.
13:33:17 <osa1> is there a ghc/ghci functionality that desugars do syntax ?
13:33:43 <hpc> you can probably get @undo as a function that takes a string
13:34:06 <byorgey> osa1: there is a lambdabot plugin to do that
13:34:14 <byorgey> if you're just looking for something to help you learn
13:34:21 <shachaf> edwardk: Hmm, maybe BazaarT is pointless?
13:34:34 <shachaf> let oldTaking :: Applicative f => Int -> ATraversal' s a -> LensLike' f s a; oldTaking n l f s = ((set (partsOf' l) ?? s) <$> traverse f (take n $ view (partsOf' l) s))
13:34:40 <byorgey> @undo do { x <- foo; y <- bar x; return baz x y }
13:34:40 <lambdabot> foo >>= \ x -> bar x >>= \ y -> return baz x y
13:34:41 <osa1> byorgey: hmm how can tell lambdabot that ?
13:34:43 <osa1> aha
13:34:45 <osa1> thanks
13:34:56 <shachaf> Oh, wait.
13:35:12 <shachaf> OK, elliott was just mixing me up.
13:35:14 <edwardk> you were the one who proved we needed it ;)
13:35:19 <`nand`> @where rts-xc
13:35:19 <lambdabot> ghc -prof -fprof-auto -rtsopts -osuf .p_o foo.hs && ./foo +RTS -xc # print stack traces on unhandled exceptions
13:35:29 <shachaf> edwardk: Right. I defined "oldTaking" and then used "taking".
13:35:37 <edwardk> ah
13:35:39 * shachaf goes back to convincing elliott that it makes sense.
13:39:05 <`nand`> hrm; +RTS -xc is failing now for some reason. I remember it working fine yesterday
13:39:17 <`nand`> oh; the flag -xc requires the program to be built with -prof
13:42:36 <`nand`> hmm; cabal tells me to use --enable-executable-profiling or --enable-library-profiling instead of setting ghc-options: -prof; however, none of the combinations of enable-executable and/or enable-library profiling to actually get profiling to work. I'm a bit confused, it was working yesterday
13:43:25 <`nand`> If I set --enable-executable-profiling on the executable, it tells me it couldn't find ‘Network.MPD’; if I set --enable-library-profiling on the executable, it builds fine but doesn't contain profiling (as expected)
13:43:40 <`nand`> However, I've tried building libmpd with --enable-library-profiling; --enable-executable-profiling; both and neither
13:43:52 <shachaf> I recommend both.
13:43:53 <`nand`> and all four variations result in the same error as described earlier
13:45:40 <`nand`> libmpd does seem to build with profiling; it goes through every module twice, the second time with suffix .p_o
13:47:26 <elliott> `nand`: In my experience Cabal's profiling support is just broken.
13:47:45 <`nand`> I tried nuking ~/.ghc and ~/.cabal; hasn't improved the situation
13:48:04 <`nand`> elliott: I'm mainly confused as to why it was working yesterday
13:51:51 <`nand`> oh, the flag needs to be passed to ‘cabal install’ *as well*
13:51:55 <`nand`> not just cabal configure
13:51:58 <`nand`> that's terribly confusing
13:53:14 <`nand`> neat, now I get linking errors
13:53:50 <Nereid> `nand`: cabal install is not something to be done after cabal configure/build.
13:54:14 <`nand`> Nereid: can you elaborate?
13:54:42 <monochrom> cabal configure --options; cabal build; [cabal haddock;] cabal copy; cabal register
13:54:42 <Nereid> cabal install is for building a package from start to finish.
13:54:45 <Nereid> ^
13:55:06 <monochrom> "cabal install" re-does "cabal configure"
13:55:18 <Nereid> install does all of those things (plus unpack, as well as installing dependencies)
13:55:29 <monochrom> therefore, "cabal configure --options" ... "cabal install" now you have lost your options. congratulations!
13:55:30 <`nand`> ah; so cabal copy/register is what I want; thanks
13:55:39 <`nand`> linking still fails, mind
13:56:00 <shachaf> cabal configure --only-dependencies
13:56:22 <Nereid> what
13:56:26 <`nand`>     cannot find normal object file `dist/build/vimus/vimus-tmp/Type.o'
13:56:29 <`nand`>     while linking an interpreted expression
13:56:54 <`nand`> as expected, it's related to TH
13:57:25 <`nand`> that's terribly confusing though; the TH has always been there and I did not run into this error yesterday
13:58:04 <monochrom> http://article.gmane.org/gmane.comp.lang.haskell.cafe/101796/
13:58:17 <monochrom> cabal-install has so many things undocumented
14:00:29 <`nand`> oh, I see how the linking stuff can be worked around; I have to build it first without profiling then with profiling
14:00:42 <`nand`> no wonder it worked yesterday and not today; I ran ‘cabal clean’ earlier
14:01:45 <Heffalump> has anyone encountered cabal generating Paths_XXX files that won't compile because they restrict imports from the Prelude?
14:03:11 <stepcut> Heffalump: i think so.. let me ponder for a second
14:03:19 <byorgey> Heffalump: yes, I've heard of that
14:03:26 <byorgey> (but haven't encountered it myself)
14:06:22 <geekosaur> I hear about it somewhat regularly, notably from people building xmonad on certain gentoo configs
14:07:00 <Heffalump> anyone know what the cause is? :-)
14:07:46 <Heffalump> AFAICT it's been busted on this machine for a while but I've got lucky because I don't build much stuff that actually imports Paths
14:11:36 <neutrino_> hi
14:19:12 * Heffalump does some research and finds its a bug in Cabal that's been fixed in 1.6.0.3. But for some reasno my attempt to install that (before I asked here) didn't actually stick
14:20:50 <Heffalump> oh never mind, I know why it didn't stick, wrong window so wrong GHC :-)
14:21:01 <Heffalump> ok, so the basic point is, avoid Cabal 1.6.0.2
14:28:54 <Heffalump> now I'm really confused. Shouldn't the 'cabal' command be in an install of the Haskell Platform? Anyone know where to find it on Windows?
14:31:46 * Heffalump finally finds it in /lib/extralibs/bin (obvious really...)
14:33:06 <k0001> Is anyone aware of backward incompatible changes between bytestring 0.10.* and previous versions (particularly 0.9.2.1, the one on the current Haskell Platform)?
14:33:54 <gienah> k0001: no, loosening the bytestring upper bound works in all cases I have tried
14:34:50 <k0001> gienah: Thanks. That's good news.
14:35:43 <gienah> k0001: a neat website you can check is: http://hdiff.luite.com/cgit/bytestring/ then click on the first version change, in this case 0.10.0.0
14:37:20 <k0001> gienah: thanks for the pointer!
14:52:07 <Ste1891> Hi.  Does anyone know of equivalent functions to "drop" and "take" that have type :: Int -> [[a]] -> [[a]], allowing lists of lists to be chopped into pieces?
14:52:59 <byorgey> Ste1891: can you give an example of what you would want such functions to do?
14:53:21 <parcs> Ste1891: do you mean map (take n), map (drop n)?
14:53:49 <aniero> Ste1891: drop/take work on lists of lists afaik
14:53:52 <byorgey> Ste1891: note that in the type of e.g. drop :: Int -> [a] -> [a],  the type 'a' could itself be a list type
14:54:03 <aniero> what byorgey said
14:54:27 <byorgey> so if you want e.g.  dropList 1 [[1,2,3], [4,5], [6,7]] == [[4,5], [6,7]],  drop already does that
14:54:48 <byorgey> if you want something more complicated you'll have to give some examples
14:56:10 <k0001> Ste1891: many “list be chopped into pieces” functions are available in the split package, you might find something interesting there. http://hackage.haskell.org/packages/archive/split/0.2.1.1/doc/html/Data-List-Split.html
14:56:16 <Ste1891> byorgey: I thought that was the case, but I've got typing errors when I tried to compile.  I'll have another look to check I'm not doing something silly.
14:56:47 <byorgey> Ste1891: if you paste your code (along with the error messages) on hpaste.org we can take a look too
14:59:46 <hpaste> Ste1891 pasted “List of lists chop” at http://hpaste.org/79960
14:59:59 <`nand`> and the error message?
15:00:30 <rwbarton> yikes
15:01:07 <Ste1891> Expected type: [Int], Actual type: [[Int]] in the return type of a call of square0.
15:01:10 <Fuuzetsu> How can I make a specialized data type? Imagine something like `data MaybeStr a = NothingStr | JustStr a'... Would I simply give it a type MaybeStr :: String -> MaybeStr String?
15:01:22 <rwbarton> well one error you probably have is you want parentheses around those scheme0::[Int]
15:01:35 <rwbarton> you wrote (square0 (parse_data hxmap) scheme0) :: [Int]
15:03:17 <`nand`> the error seems to originate from “splitOn [2] (square 1 (take row_length (x:xs)) y0 y1 y2)”
15:03:24 <`nand`> what's the type of splitOn?
15:03:58 <`nand`> actually, never mind; the error could come from anywhere
15:04:22 <malfermu> hi guys
15:04:24 <Ste1891> 'nand': I've already tested that function in isolation and it works.
15:04:26 <applicative> Fuuzetsu: what does MaybeStr have to do with String>
15:04:33 <applicative> hi malfermu
15:04:34 <byorgey> hi malfermu
15:05:19 <malfermu> cool language, learning it. already coding in ruby, perl and php (but i hate it)
15:05:32 <applicative> Fuuzetsu: obviously your can make a synonym type MaybeStr = Maybe String, but that doesn't seem it?
15:05:55 <Fuuzetsu> applicative: that was an example; I don't actually want something as silly as MaybeStr
15:06:04 <byorgey> Ste1891: can you please paste the *entire* error message?
15:06:06 <`nand`> I'm not sure what you want
15:06:17 <applicative> Fuuzetsu: I figured, I was just trying to understand
15:06:28 <byorgey> malfermu: cool, feel free to hang out in here and ask questions
15:06:57 <navaati> @src (<$)
15:06:57 <lambdabot> (<$) = (<$>) . const
15:07:08 <applicative> malfermu: ask questions all the time, especially when people are off topic...
15:07:15 <Fuuzetsu> I'm just trying to find out how to restrict a variable type going into my own type
15:07:16 <byorgey> Ste1891: actually, the issue that rwbarton pointed out would cause the error message you're seeing
15:07:23 <malfermu> ok, thank you, byorgey & applicative!
15:07:28 <zomg> malfermu: web development I take it?
15:07:31 <byorgey> Ste1891: so try fixing that and see if you still get errors.
15:07:37 <`nand`> Fuuzetsu: what do you mean by ‘restrict’?
15:07:44 <`nand`> Fuuzetsu: type equality?
15:07:57 <malfermu> zomg: right you are
15:08:13 <Fuuzetsu> more of what you'd see in a type signature... e.g. foo :: (Num a) => a -> a
15:08:21 * applicative was going to ask what `nand` asked
15:08:42 <Fuuzetsu> as opposed to just accepting all `a'
15:08:50 <`nand`> Fuuzetsu: there's no way to put a context on a type declaration itself; instead you want to put it on the functions that work with said type
15:08:51 <applicative> Fuuzetsu: yeah, you don't want to do that with a data type, just with functions are wahtever you define
15:09:00 <`nand`> (there actually is, but forget about it)
15:09:03 <Nereid> @pl \a b -> a * f b
15:09:04 <lambdabot> (. f) . (*)
15:09:14 <Nereid> @pl \a b -> a . f b
15:09:14 <lambdabot> (. f) . (.)
15:09:31 <applicative> Fuuzetsu: inside a GADT a class constaint makes sense.
15:09:59 <Ste1891> byorgey: That seems to have not copied over properly, somehow.  The parentheses mentioned are there in the real code.  I was getting errors related to bracketing earlier but I cleaned those up, I thought.
15:10:20 <`nand`> oh, right, you could use a GADT
15:10:32 <Fuuzetsu> so say I define MyType a = Const a; I would then make type signatures for functions working on it foo :: (Num a) => MyType a -> whatever ?
15:10:35 <Nereid> @src tails
15:10:35 <lambdabot> tails []         = [[]]
15:10:36 <lambdabot> tails xxs@(_:xs) = xxs : tails xs
15:10:39 <`nand`> Fuuzetsu: yes
15:11:23 <byorgey> Ste1891: ok.  Well, in that case can you paste the real code and the complete error message(s)?
15:11:32 <`nand`> or with a GADT it would be data MyType a where Const :: Num a => a -> MyType a
15:12:03 <Fuuzetsu> Not sure whether a GADT wouldn't be an overkill
15:12:07 <Fuuzetsu> (for my task)
15:12:40 <`nand`> I don't think a GADT would be the right thing to do here
15:12:45 <Fuuzetsu> I asked because my data type will pretty much always only encapsulate a String
15:12:50 <`nand`> well
15:13:08 <`nand`> if the constraint you have is a type equality; you can just get rid of the variable in the first place
15:13:40 <`nand`> data MyType = Const String -- can only hold strings now
15:13:56 <Fuuzetsu> oh, right
15:14:18 <Fuuzetsu> I'm assuming it wouldn't work with a typeclass (like Num)
15:14:25 <`nand`> right
15:14:58 <Fuuzetsu> right then, thanks!
15:18:15 <hpaste> Ste1891 pasted “List of lists chop” at http://hpaste.org/79961
15:18:55 <`nand`> Ste1891: does it compile if you remove the type signatures?
15:19:02 <`nand`> in lines 4-6
15:19:38 <`nand`> oh, I'm guessing parse_data might be polymorphic or something
15:19:47 <`nand`> at any rate, that type signature is incorrect
15:20:05 <`nand`> maybe you meant to put the type signatures after “parse_data hxmap” instead?
15:20:10 <`nand`> like (parse_data hxmap :: [Int])
15:20:48 <`nand`> actually, since square0 is so monomorphic; it should work even if parse_data hxmap were polymorphic
15:21:02 <`nand`> which brings me back to my original question: does it compile if you remove the type signatures?
15:22:22 <Ste1891> No, I get a more polymorphic typing error with an actual type of [[a0]], expected type [Int].
15:25:13 <hpaste> Ste1891 pasted “parse_data” at http://hpaste.org/79962
15:25:46 <Ste1891> Sorry, I forgot to include that before, but not sure it's relevant anyway.
15:26:23 <byorgey> Ste1891: that still has the problem rwbarton pointed out.
15:26:46 <byorgey> (square0 (parse_data hxmap) scheme0::[Int])  means that whole expression should have type [Int]
15:26:56 <byorgey> i.e. the :: scopes over the entire expression to the left
15:27:16 <byorgey> but presumably you want to say  (square0 (parse_data hxmap) (scheme0 :: [Int]))
15:27:36 <Ste1891> Oh, OK I didn't get what he meant before.  I'll check if that fixes it.
15:29:23 <byorgey> Ste1891: also, you should give  (drop count (square0 (parse_data hxmap) (scheme0::[Int])))  a name instead of repeating it three times
15:29:58 <Fuuzetsu> One more thing. Can I do something like data MyType = Foo Integer | Bar String | Baz  ?
15:30:27 <byorgey> Fuuzetsu: that looks like a valid data type declaration to me.
15:30:43 <Fuuzetsu> Awesome.
15:32:23 <DrChaos> Hello
15:32:41 <DrChaos> I am trying to make a selection sort function and I think the recursion is messing me up
15:34:45 <DrChaos> to do selection sort I need to find the minimum value inside the list, append that value to the beginning of the list, and then find the next smallest value and make that the second item of the list and so on and so forth.
15:34:54 <DrChaos> s
15:35:15 <DrChaos> welp, I gotta go
15:35:19 <DrChaos> wireless will disconnect soon
15:35:45 <byorgey> whyyyyyyy
15:36:03 <Rembane> :D
15:39:09 <madjestic> what are members of a type?
15:40:54 <yitz> madjestic: we usually talk about "elements" of a type, and "members" of a type class.
15:41:22 <`nand`> “values” of a type
15:41:43 <cmccann> @hoogle member
15:41:44 <lambdabot> Data.IntSet member :: Int -> IntSet -> Bool
15:41:44 <lambdabot> Data.IntMap member :: Key -> IntMap a -> Bool
15:41:44 <lambdabot> Data.Set member :: Ord a => a -> Set a -> Bool
15:41:56 <sclv> inhabitants of a type
15:42:03 <yitz> cmccann: well ok there's also that kind of member
15:42:09 <sclv> values *have* types
15:42:10 <cmccann> heh
15:42:47 <yitz> sclv: ah yes. true. although "inhabitants" is seen more often in a curry-howard context.
15:42:52 <`nand`> the terminology ‘member’ of a ‘class’ was picked primarily to confuse the OOP guys, right?
15:43:00 <Ste1891> byorgey: OK, it was related to what you and rwbarton pointed out.  It happened because I'd compiled in the value of 'scheme0' as a constant, which is just a quick fix before I write a function to generate it.  Fixing the type of that constant was enough.  So thanks, guys.
15:43:07 <sclv> this is haskell. everything is a curry-howard context ! :-P
15:43:14 <cmccann> sclv, I still say that useful values should be said to "inhabit" a type, and that _|_ should be said to "freeload" off of a type
15:43:58 <cmccann> it lives there, and it's not really contributing anything, but kicking it out is more hassle than it's worth
15:44:01 <byorgey> Ste1891: great!
15:46:15 <yitz> sclv: it's common to talk about the "elements" of an object in a set-like category. Hask is like that.
15:46:50 <sclv> eh, i hate treating hask as set-like
15:47:03 <sclv> i think it makes things more confusing
15:47:55 <elliott> @remember edwardk lens cares little for the legibility of the implementation or the types. ;)
15:47:55 <lambdabot> It is forever etched in my memory.
15:48:01 <cmccann> I'll treat Hask as set-like as soon as I can take proper intersections and unions of types
15:48:14 <edwardk> =P
15:48:48 * `nand` fears the monster edwardk and byorgey would write together
15:49:19 <edwardk> we were meaning to collaborate on a new typeclassopaedia but never got around to it
15:49:37 <`nand`> one with profunctors, bifunctors and comonads?
15:49:44 <edwardk> `nand`: yes
15:49:53 <`nand`> something like an actual wiki-like typeclassopaedia could be interesting
15:50:23 <yitz> `nand`: don't worry. edwardk uses & and byorgey uses #. so it's not possible for them to collaborate anymore. (partly my fault, too)
15:50:27 <`nand`> (of course, one wonders whether it isn't better to include this documentation in the actual haddock pages instead)
15:51:17 <`nand`> yitz: all hope is not lost; byorgey already subconsciously infringes on lens naming territory: chunksOf
15:51:29 <edwardk> `nand`: ack!
15:51:51 * cmccann continues to use (|>) instead of (#) or (&)
15:52:27 <rwbarton> chunksOf splits a traversal into smaller traversals, right
15:52:52 <yitz> @hoogle chunksOf
15:52:53 <lambdabot> Data.Text chunksOf :: Int -> Text -> [Text]
15:52:53 <lambdabot> Data.Text.Lazy chunksOf :: Int64 -> Text -> [Text]
15:53:28 <cmccann> yeah, but compared to lens, who actually uses Text? pf.
15:53:45 <elliott> well Data.Text also clashes with, e.g. Prelude
15:53:46 * `nand` uses the text lens from time to time
15:53:48 <elliott> so not a very big problem :P
15:53:49 <NougatRillettes> Hi guys, I got a question, it's in the paste : http://paste.awesom.eu/CsR
15:53:52 <yitz> and yes, it's in Data.Split, too. which is a candidate for inclusion in the Haskell Platform. (if it isn't already included, i wasn't watching closely this time)
15:53:58 <NougatRillettes> at the end, with "**"
15:54:10 <elliott> oh, Data.List.Split clashes too?
15:54:11 <Nereid> yitz: it's already in
15:54:17 <Nereid> er
15:54:28 <Nereid> yeah.
15:54:34 <Nereid> split is in. but the module is Data.List.Split
15:54:40 <yitz> ah ok
15:54:53 <jmcarthur> NougatRillettes: lately we have type level numerals!
15:55:07 <NougatRillettes> let me check the doc
15:55:11 <jmcarthur> finding docs
15:55:18 <NougatRillettes> i got it don't bother
15:55:34 <jmcarthur> NougatRillettes: http://hackage.haskell.org/trac/ghc/wiki/TypeNats/Basics
15:55:43 <NougatRillettes> well thx :)
15:56:03 <Nereid> the constraint solver doesn't know how to do type level arithmetic yet though
15:56:13 <Nereid> so they're useless in 7.6.1
15:56:16 <rwbarton> does that really compile with just {-# LANGUAGE GADTs #-}?
15:56:22 <Nereid> haha
15:56:22 <NougatRillettes> nope
15:56:27 <jmcarthur> Nereid: not really useless, are they?
15:56:34 <rwbarton> ok good
15:56:41 <NougatRillettes> you need -XdataTYpe
15:56:43 <jmcarthur> Nereid: surely no worse than our existing peano tricks?
15:56:56 <Nereid> jmcarthur: worse. you can't do arithmetic
15:57:02 <Feuerbach> Nereid: worse, they are not inductive
15:57:05 <jmcarthur> huh
15:57:07 <NougatRillettes> wich for a reason I can't figure out doeasn't work if put in LANGUAGE pragma
15:57:11 <jmcarthur> NougatRillettes: ignore my advice
15:57:12 <NougatRillettes> (DataKinds)
15:57:25 <Nereid> jmcarthur: I think they'll be usable in 7.6.2 though
15:57:38 <Nereid> Feuerbach: what's wrong with that?
15:58:01 <NougatRillettes> jmcarthur: yes I was thinking that as there is no arithmettic, i wouldn't be able to find smthg like "S n"
15:58:10 <cmccann> at least the type nats are more useful than the type strings
15:58:15 <cmccann> which you can basically do nothing with
15:58:47 <`nand`> jmcarthur: you can't pattern match on them
15:58:56 <`nand`> jmcarthur: you can pattern match on Peano
15:59:00 <jmcarthur> arithmetic seems to work for me...
15:59:01 <`nand`> well, you can match for equality
15:59:14 <jmcarthur> oh
15:59:16 <jmcarthur> nevermind
15:59:32 <jmcarthur> i thought i had used typelits in one of my projects, but it was just a lifted data type
15:59:46 <`nand`> jmcarthur: does eg.  () :: (1+2) ~ (2+1) => ()  check for you?
15:59:59 <jmcarthur> i doubt it now that i realize what i had actually done :)
16:00:27 <`nand`> both type nats and type strings currently seem to be usable primarily as ‘labels’
16:00:40 <NougatRillettes> guys i got some difficulties to follow you, is there any way to do what I want ?
16:00:47 <jmcarthur> `+' is a type function, and may not be injective
16:00:48 <`nand`> NougatRillettes: I don't think so
16:00:58 <`nand`> NougatRillettes: GHC prints types the way it does; there's no way to tell it to print types differently
16:01:07 <jmcarthur> NougatRillettes: you could make a base 10 type instead of using peano numerals
16:01:17 <NougatRillettes> ok and is it worth asking on trac to implement it ?
16:01:35 * `nand` .oO( Hey, we need kind classes and type-level Show )
16:01:50 <`nand`> NougatRillettes: doubt it, since the new TypeLits stuff will replace this either way
16:02:09 <NougatRillettes> well, I was thinkging of asking for a way to use the Show function declared for values with the types
16:02:16 <cmccann> `nand`, what about GADKs
16:02:24 <`nand`> cmccann: hehe
16:02:33 <NougatRillettes> hm, i'm a bit of a newbie so I need to google everything you say
16:02:40 <NougatRillettes> so please give me some time :D
16:02:47 <`nand`> we *do* need a type-level case..of expression :(
16:02:54 <`nand`> factoring all those matches out to extra functions is getting tedious
16:03:12 <`nand`> and with the new type family instance groups stuff, it's completely doable
16:03:13 <cmccann> how about type-level lambda abstractions
16:03:26 <cmccann> just give up on types being sensible
16:03:29 <jmcarthur> we sure bend over backwards to avoid dependent types
16:04:08 <Nereid> hmm, how come the last ghc nightly is dated 12/13?
16:04:09 <`nand`> I think what I'm leaning towards is ‘singletons’ being able to lift any function definition to the type level automatically
16:04:11 <NougatRillettes> i can't find any doc on TypeLIst, url anyone ?
16:04:13 <`nand`> currently it breaks on stuff like case..of
16:04:30 <NougatRillettes> google won't send anything but list type, with the space
16:04:48 <mauke> NougatRillettes: TypeLits, not TypeList
16:05:06 <NougatRillettes> my bad :>
16:05:19 <Fuuzetsu> Say I have a string as such "| foo | bar | 120x100 | baz | 20x20 | qux |" and I'm trying to extract the 120 and 100; Is there a good way of doing this that's not regular expressions?
16:05:43 <Fuuzetsu> The position of the values I want can shift so they aren't always in `slot' 3 etc.
16:05:52 <Clint> write a parser
16:06:14 <mauke> Fuuzetsu: find out what you're trying to do, then write code to do that
16:06:15 <Feuerbach> Fuuzetsu: may I ask why not regular expressions?
16:06:27 <mauke> this may or may not involve regexes
16:06:32 <hiptobecubic> why doesn't ZipList derive show?
16:06:41 <mauke> hiptobecubic: it's being a dick
16:06:44 <Fuuzetsu> Feuerbach: regex is ugly, that's pretty much the main reason
16:07:22 <Feuerbach> Fuuzetsu: what exactly is ugly?
16:07:50 <Fuuzetsu> I just don't -like- regex although it actually seems like the easiest solution here
16:07:58 <Fuuzetsu> readability wise
16:08:08 <mauke> you haven't described the problem yet
16:08:21 <hiptobecubic> also it seems like getZipList should be called unZipList
16:08:24 <mauke> we're not at the solution stage yet
16:08:52 <hiptobecubic> the whole point is to get a regular list, not a ZipList.
16:08:53 <NougatRillettes> `nand`: what will the "next TypeLit's stuff" be ?
16:08:59 <Fuuzetsu> mauke: take that string and bind values around the first x to variables
16:09:23 <Fuuzetsu> (around the first x that is inside pipes)
16:09:25 <`nand`> NougatRillettes: ways to use the built-in Nat; I don't know the specifics
16:09:33 <`nand`> NougatRillettes: there's a branch available somewhere that works more or less from what I hear
16:09:39 <`nand`> if you want to play with them
16:09:45 <Feuerbach> Fuuzetsu: take a look at the regex-applicative package
16:09:55 <gbacon> did bos manually syntax-color the code in http://www.scs.stanford.edu/11au-cs240h/notes/laziness-slides.html ?
16:09:58 <rwbarton> what if "foo" is "fxo"
16:10:04 <gbacon> or use some tool?
16:10:11 <Fuuzetsu> >feuerbach/regex-applicative · GitHub hehe
16:10:31 * `nand` doesn't like regexes, personally
16:10:33 <rwbarton> gbacon: I assume a tool since on the second slide there is Num in green but Str and Op in red
16:10:59 <Fuuzetsu> `nand`: I'm open to a -better- solution
16:11:02 <mauke> Fuuzetsu: define "inside pipes" and "values around x"
16:11:06 <`nand`> Fuuzetsu: I'll go with what mauke said
16:11:15 <`nand`> figure out the exact behavior you want first
16:11:38 <gbacon> rwbarton: any hunch which?
16:12:51 <JoeyA> It'd be neat if there were a flag that, when name' is defined, any reference to name within the scope of name' produces a warning.
16:13:22 <Nereid> well
16:13:31 <JoeyA> This only applies to local scopes, so using foldl won't warn when foldl' is defined.
16:13:33 <`nand`> JoeyA: you could put a DEPRECATED pragma on name or something
16:13:43 <Nereid> type level nats/strings are still useful
16:13:45 <Fuuzetsu> given the first pattern "| FOOxBAR |" inside of a string, I want FOO to be bound to a name as well as bar; the function I want is basically qux :: String -> (Integer, Integer)
16:13:48 <`nand`> or just pick different names :)
16:13:59 <mauke> Fuuzetsu: that's not a pattern
16:14:04 <mauke> Fuuzetsu: and that type makes no sense
16:14:04 <JoeyA> No, it's for making sure you don't use an old state value.
16:14:05 <rwbarton> gbacon: well there's this   <meta name="generator" content="pandoc" />
16:14:07 <Nereid> you can reflect them with fromSing (sing :: Sing n)
16:14:21 <JoeyA> e.g. buf <- foo; buf' <- bar buf; -- using buf should produce a warning
16:14:21 <gbacon> rwbarton: that's a strong hunch
16:14:26 <Nereid> >>> fromSing (sing :: Sing "hello")
16:14:26 <Nereid> "hello"
16:14:43 <Fuuzetsu> mauke: it's not a valid pattern as for as Haskell goes but what's wrong with ttat signature?
16:14:48 <mauke> Fuuzetsu: do you mean something like "| " DIGIT+ "x" DIGIT+ " |"?
16:14:53 <`nand`> oh, they have sing instances? does GHC magically provide those?
16:14:55 <JoeyA> You could disable warnings for name shadowing, but such warnings are often useful.
16:15:06 <mauke> Fuuzetsu: what if no such pattern is found in the string?
16:15:13 <Fuuzetsu> mauke: yes; I want to be able to pull those DIGITs out
16:15:38 <Nereid> `nand`: I guess so
16:15:41 <Fuuzetsu> there always will be; if not, I have a different defined under
16:15:50 <Fuuzetsu> different case*
16:15:55 <gbacon> http://johnmacfarlane.net/pandoc/demo/example9/producing-slide-shows-with-pandoc.html
16:15:56 <mauke> huh?
16:15:57 <`nand`> Nereid: yeah that's probably the case, they're in GHC. after all
16:16:02 <Fuuzetsu> uhh
16:16:10 <`nand`> still, that's pretty cool
16:16:11 <Fuuzetsu> ignore that
16:16:25 <Fuuzetsu> assume that the pattern will always be there
16:16:30 <`nand`> I can probably refactor some of my code that uses/reflects type-nats that way
16:16:36 <Nereid> yeah, GHC magically provides SingI instances.
16:18:22 <mauke> Fuuzetsu: I'd probably try Text.Regex.TDFA first
16:18:46 <mauke> because this is pretty much \| ([[:digit:]]+)x([[:digit:]]+) \|
16:18:49 <Fuuzetsu> ah, as I thought; I was actually looking at that
16:19:23 <Fuuzetsu> yeah; I was just wondering whether there's a nice way to do that without regex hence my question here
16:20:32 <mauke> let's see ...
16:21:05 <NougatRillettes> Fuuzetsu: it depends and what foo, bar etc are
16:21:17 <mauke> (,) <$> (string "| " *> int) <*> (int <* string " |") using a hypothetical applicative parser combinator library
16:21:22 <NougatRillettes> if they are only char, you can quite easily write a parser on them
16:21:31 <mauke> where int = read <$> many1 digit
16:23:38 <Nereid> don't forget the x
16:23:54 <mauke> oops
16:24:05 <`nand`> Nereid: interesting, there's actually a ‘read’ instance on Sing stuff
16:24:17 <`nand`> read "123" :: Sing 123 -- doesn't seem very useful, at a first glance
16:24:19 <mauke> (,) <$> (string "| " *> int <* string "x") <*> (int <* string " |")
16:24:57 <Nereid> `nand`: read "123" :: Sing 2 is an error
16:25:23 <mauke> my ($x, $y) = $line =~ m{\| (\d+)x(\d+) \|} or return;  # and this is why I use Perl
16:25:24 <Nereid> bye
16:26:34 <aristid> mauke: is the m necessary, or would just /| (\d})x(\d}) |/ work too?
16:26:48 <mauke> no and no
16:26:49 <`nand`> Nereid: yeah; but maybe with the right amount of existential wrapping it could be used.. somewhere? I don't know
16:27:07 <mauke> m is optional with /.../, but the \ are required
16:28:28 <mauke> (and I opted for different delimiters because I think /\| ... \|/ looks ugly)
16:32:11 <`nand`> looks like N and W
16:32:48 <Peaker> the ghc rts c code defines its own ctypes, rather than using "stdint.h", any idea why?
16:34:24 <NougatRillettes> where is the syntaxic sugar [a;b] defined for the list ?
16:34:30 <NougatRillettes> i'd like to define a similar one
16:34:42 <hpc> wait, that syntax exists?
16:34:46 <hpc> > [5;6]
16:34:48 <lambdabot>   <hint>:1:3: parse error on input `;'
16:35:13 <NougatRillettes> > [1,2]
16:35:14 <lambdabot>   [1,2]
16:35:21 <hpc> ah
16:35:25 <rwbarton> in the ghc parser I guess? what do you mean "implement"
16:35:26 <NougatRillettes> :>
16:35:28 <rwbarton> modifying ghc?
16:35:30 <hpc> that's built into the language specification
16:35:36 <Peaker> NougatRillettes, Haskell isn't Lisp
16:35:42 <hpc> you could do something horrid with template haskell
16:35:45 <hpc> but don't
16:35:46 <hpc> ;)
16:35:58 <NougatRillettes> oh yes I am !
16:36:01 <argiopeweb> hpc: Took the words out of my mouth.
16:36:26 <NougatRillettes> I want to have generalized tuples easily availables
16:36:36 <hpc> you reaaaaally don't want that
16:36:37 <NougatRillettes> -s
16:36:50 <hpc> many have thought they wanted it before
16:36:51 <argiopeweb> But yeah, 10 minutes with attoparsec can get you a parser for [<tokena>,<tokenb>] -> tokena:tokenb:[].
16:36:58 <NougatRillettes> well probably not
16:37:02 <hpc> it has never ended well
16:37:10 <`nand`> [l|1,2,3|]
16:37:19 * `nand` ducks
16:37:24 <hpc> perhaps if you could share with us what your end goal is?
16:37:45 <NougatRillettes> get (1,2,3,4,5) working as a 5-tuple
16:37:46 <hpc> (in the "i want to take a picture" sense, not the "photons hit the photoreceptors and are converted to a bit array")
16:37:54 <hpc> > (1,2,3,4,5)
16:37:56 <lambdabot>   (1,2,3,4,5)
16:38:00 <Jafet> nand: Clearly that should be defined as fromList (1 ::: 2 ::: 3 ::: Nil)
16:38:22 <NougatRillettes> hm
16:38:43 <NougatRillettes> why the fuck did I want to do this
16:38:51 <NougatRillettes> I must have get a little confused
16:39:18 <`nand`> Jafet: fromList?
16:39:32 <hpc> NougatRillettes: easy to do :)
16:39:53 <NougatRillettes> well yet
16:40:10 <`nand`> what's GHC practical limit on tuple syntax again? infinite in implementation, or does it cut off at 32 or something?
16:40:22 <Jafet> 100
16:40:23 <NougatRillettes> a function that take a n-tuple a send a (n-1)-tuple isn't possible is it ?
16:40:41 <`nand`> NougatRillettes: you mean, like foo :: (a,b,c,d,e) -> (a,b,c,d) ?
16:41:04 <hiptobecubic> @djinn foo :: (a,b,c,d,e) -> (a,b,c,d)
16:41:05 <NougatRillettes> *-> (b,c,d,e)
16:41:05 <lambdabot> Cannot parse command
16:41:15 <hpc> i thought tuples cut off at 62
16:41:18 <hiptobecubic> @djinn (a,b,c,d,e) -> (a,b,c,d)
16:41:19 <lambdabot> f (a, b, c, d, _) = (a, b, c, d)
16:41:27 <`nand`> @djinn (a,b,c,d,e) -> (b,c,d,e)
16:41:28 <lambdabot> f (_, a, b, c, d) = (a, b, c, d)
16:41:29 <`nand`> you get the idea
16:41:36 <NougatRillettes> yes but generalized to any number of elements :)
16:41:38 <hiptobecubic> i suppose that's the only one really
16:41:44 <`nand`> oh; no, not with tuples
16:41:50 <Jafet> class Init a b | a -> b where init :: a -> b
16:41:56 <`nand`> you could with vectors!
16:42:01 <NougatRillettes> ok but THAT could be done with my implementation
16:42:01 <hiptobecubic> NougatRillettes, why do you want tuples?
16:42:06 <`nand`> NougatRillettes: sure
16:42:07 <Jafet> instance Init (a, b) a where init = fst
16:42:15 <`nand`> tail :: Vec a (Succ n) -> Vec a n
16:42:22 <NougatRillettes> hm
16:42:32 <NougatRillettes> I might just don't now what a vector is
16:42:36 <NougatRillettes> let me chack that :D
16:42:47 <novitiate> I
16:42:55 <novitiate> I'm having a little trouble with pointfree construction
16:43:09 <NougatRillettes> it's a list with the number of elements in it isn't it ?
16:43:44 <`nand`> novitiate: lambdabot can assist you with that
16:43:44 <hpc> NougatRillettes: the length of the list is encoded in the type, if that makes sense
16:43:54 <NougatRillettes> yes
16:44:00 <hpc> the empty vector is of type Vec a Zero
16:44:07 <hpc> etc
16:44:23 <Jafet> Vec are not tuples
16:44:25 <NougatRillettes> hm, i can't find them on hoogle
16:44:25 <`nand`> NougatRillettes: Vec is the ‘Tuple’ of your paste
16:44:35 <NougatRillettes> yes I lately got it
16:44:35 <`nand`> oh
16:44:35 <hiptobecubic> @pl \make me point free -> make * me * point * free
16:44:36 <lambdabot> ((((*) .) . (*)) .) . (*)
16:44:41 <`nand`> Vecs are still monomorphic, right
16:44:43 <`nand`> completely missed that
16:44:49 <Jafet> @where HList
16:44:50 <lambdabot> http://homepages.cwi.nl/~ralf/HList
16:44:51 <`nand`> you want a HList :)
16:44:59 <hpc> nobody ever wants HList
16:45:03 <`nand`> fair enough
16:45:06 <Jafet> Well, I'm not sure if anyone ever wants a HList
16:45:48 <novitiate> @pl f (g (x), y)
16:45:49 <lambdabot> f (g x, y)
16:46:08 <novitiate> @pl disemvowel x = filter (flip notElem "aeiou") x
16:46:09 <lambdabot> disemvowel = filter (flip notElem "aeiou")
16:46:36 <hpaste> “`nand`” pasted “HList” at http://hpaste.org/79963
16:47:05 <Philippa> > filter (`notElem` "aeiou") "Oh happy day!"
16:47:06 <lambdabot>   "Oh hppy dy!"
16:47:22 <hiptobecubic> > filter (`notElem` "aeiou")  "Here we go"
16:47:23 <lambdabot>   "Hr w g"
16:47:52 <`nand`> ‘disemvowel’ oh boy
16:48:08 <`nand`> NougatRillettes: see the hpaste for an example of HList ^
16:48:08 <Jafet> I don't think HList was implemented with GADTs.
16:48:10 <novitiate> mm, is there a more elegant way to add "AEIOU" besides "... notelem "aeiouAEIOU""?
16:48:30 <mauke> . toLower
16:48:56 <covi> Why is GHC's memoization less efficient than something like Data.Array?
16:49:00 <`nand`> I would factor this out, personally: vowel c = toLower c `elem` "aeiou"
16:49:05 <`nand`> or s/vowel/isVowel/
16:49:18 <jmcarthur> covi: what?
16:49:22 <Jafet> > ap (++) toLower "AEIOU"
16:49:22 <jmcarthur> covi: ghc doesn't do memoization
16:49:23 <mauke> covi: what is ghc's memoization?
16:49:24 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
16:49:24 <lambdabot>              with actual type...
16:49:34 <Jafet> > (++) <*> map toLower $ "AEIOU"
16:49:36 <lambdabot>   "AEIOUaeiou"
16:49:45 <covi> what?!
16:49:50 <hpaste> roadfish pasted “failing with Uniplate” at http://hpaste.org/79964
16:49:52 <mauke> covi: what what
16:50:02 <jmcarthur> covi: what language automatically memoizes... anything?
16:50:05 <covi> I thought functional languages compilers do memoizations
16:50:12 <mauke> covi: you thought wrong
16:50:18 <jmcarthur> it's safe to memoize pure functions, but not always a good idea
16:50:24 <Jafet> Do they use Haskell in what?
16:50:25 <cmccann> it's often a very bad idea
16:50:29 <mauke> jmcarthur: or even possible
16:50:33 <covi> Well, I read SICP, and it says memoization in lazy languages really help
16:50:43 <jmcarthur> mauke: usually possible... when wouldn't it be?
16:50:44 <cmccann> and it's very hard for GHC to tell when it'd be a good idea or not
16:50:50 <mauke> jmcarthur: incomparable arguments
16:50:50 <novitiate> Jafet, what's the <*> doing in (++) <*> map ?
16:51:02 <mauke> covi: where does it say that?
16:51:04 <hpc> sicp is an ancient book
16:51:07 <roadfish> what am I doing wrong here: http://hpaste.org/79964 ? the online examples with Uniplate work without any instance delecation.
16:51:12 <hpc> we have since learned better
16:51:17 <mauke> novitiate: \s -> (++) s (map s)
16:51:22 <jmcarthur> mauke: even in that case, structural equality would be an option for a compiler
16:51:25 <hpc> ;)
16:51:33 <Jafet> Ironic that their language isn't lazy
16:51:39 <jmcarthur> mauke: it wouldn't catch all equivalences, of course
16:51:52 <covi> mauke: http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-27.html#%_sec_4.2
16:51:54 <`nand`> roadfish: maybe there's some explicit mechanism for auto-deriving Uniplate instances?
16:52:01 <cmccann> also, people often confuse memoization with the sharing that GHC does do
16:52:04 <covi> hpc: can you say more?
16:52:23 <`nand`> like perhaps some TH mechanism or language extension
16:52:48 <cmccann> if the same value is used in multiple places it won't be recomputed, but that's not the same as memoizing the functions that take that value as an argument
16:52:51 <jmcarthur> covi: if you memoized everything you would just run out of memory quickly or add an overhead to every little function, even ones that would otherwise be faster without the extra baggage
16:52:58 <cmccann> or functions that produced that value as an output
16:53:05 <`nand`> roadfish: Data.Generics.Uniplate claims it's deprecated
16:53:15 <hpc> what cmccann said
16:53:19 <NougatRillettes> `nand`: I don't understand the ': in the code you pasted
16:53:33 <hpc> instead of "a miracle occurs and your code is fast", you understand the underlying machinery and write good code yourself
16:53:38 <jmcarthur> covi: i'm also curious what you meant by the original question? what operations were you comparing to bring up that question?
16:53:39 <`nand`> roadfish: the docs say you want either Data.Generics.Uniplate.Data (which can be auto-derived); or Data.Generics.Uniplate.Direct (which is faster, but needs manual instances to be written)
16:53:41 <covi> jmcarthur: I see. I am very new to Haskell, so what are some common ways to manually memoize some results?
16:53:46 <NougatRillettes> jmcarthur: couldn't haskell though provide a keyword to memoize ?
16:53:47 <`nand`> NougatRillettes: type-level lists
16:53:59 <NougatRillettes> ok that's what I thought
16:53:59 <cmccann> in some cases GHC will, in fact, perform near-miracles to improve your code
16:54:03 <jmcarthur> covi, NougatRillettes: there are libraries that provide memo functions
16:54:10 <cmccann> but it's not wise to count on that unless you understand the optimizer very well :P
16:54:14 <covi> jmcarthur: for instance, when doing dynamic programming, I need to memoize all intermediate results
16:54:25 <NougatRillettes> but I can't get them working at home
16:54:39 <NougatRillettes> jmcarthur: sad one has to use externa libraries
16:54:45 <mauke> covi: this is a different sense of "memoization"
16:54:47 <`nand`> NougatRillettes: can you paste what you're trying?
16:54:48 <novitiate> mauke, so in this case (++) <*> map toLower $ "AEIOU" is taking "toLower" as an argument to curry into both "map" and "++" ?
16:54:54 <covi> NougatRillettes: I am not sure if Data.Array qualifies for memoization, but it does speed things up
16:54:57 <mauke> novitiate: no, you misparsed the expression
16:55:02 <NougatRillettes> mapple for (a bad) example does memoization
16:55:11 <jmcarthur> covi: here's a stackoverflow question i answered a long time ago about dynamic programming http://stackoverflow.com/questions/5223498/efficient-table-for-dynamic-programming-in-haskell
16:55:12 <NougatRillettes> when a keyword is provided
16:55:22 <mauke> novitiate: it groups like this: ((++) <*> (map toLower)) $ "AEIOU"
16:55:39 <mauke> novitiate: (\s -> (++) s (map toLower s)) "AEIOU"
16:55:43 <`nand`> or ((<*>) (++) (map toLower)) AEIOU
16:55:50 <NougatRillettes> `nand`: > :t (':)
16:55:53 <jmcarthur> covi: i happened to solve it with memoization, but memoization isn't always necessary for dynamic programming
16:55:53 <NougatRillettes> `nand`: > :k (':)
16:55:55 <novitiate> mauke, because function application is higher precedence than the <*> operator?
16:55:57 <mauke> novitiate: "AEIOU" ++ map toLower "AEIOU"
16:55:58 <NougatRillettes> :d
16:56:00 <mauke> novitiate: yes
16:56:26 <covi> jmcarthur: thx for the link, will read it
16:56:33 <`nand`> NougatRillettes: hmm. I suddenly have no idea how to quote those correctly
16:56:50 <NougatRillettes> hù ?
16:57:02 <mauke> covi: SICP is talking about "memoizing" thunks, not functions
16:57:12 <`nand`> '(:) works for TH quoting; but it doesn't seem to work for the lifted constructor
16:57:19 <mauke> covi: and this "memoization" is not based on lookup tables because thunks take no arguments
16:58:26 <`nand`> NougatRillettes: any how; this should work for you  :k Int ': '[]
16:58:44 <`nand`> which is also just '[Int]
16:58:45 <covi> mauke: I see. Does GHC memoize thunks?
16:58:52 <mauke> covi: yes
16:59:10 <`nand`> NougatRillettes: but technically; '(:) :: k -> [k] -> [k]
16:59:13 <covi> But it's still not fast enough often times.
16:59:21 <mauke> covi: this "thunks don't get recomputed" stuff is what's usually meant by "lazy"
16:59:31 <mauke> covi: huh? what do you mean?
16:59:40 <roadfish> `nand`: ok, so far the only deriving I've done is with the easy "deriving (Show, Eq)" syntax. I guess I need to read some more on deriving instances where I define the functions.
17:00:05 <NougatRillettes> well well well i(m gonna try to get properly HList
17:00:06 <`nand`> roadfish: you can use deriving (Data)
17:00:08 <novitiate> let disemvowel x = filter (flip notElem "aeiouAEIOU") x, and disconsonant x = filter (flip elem "aeiouAEIOU"), then
17:00:12 <NougatRillettes> but what did you pasted it for ?
17:00:15 <novitiate> can we write them without parantheses?
17:00:16 <NougatRillettes> I'm a bit lost
17:00:42 <novitiate> can we write a single function of two arguments that can be converted into either disemvowel or disconsonant?
17:00:42 <`nand`> roadfish: also, maybe you want Data.Data.Data? I don't know what the difference between that and ‘uniplate’ is; but that one's in base
17:00:59 <`nand`> oh, never mind; uniplate uses the one in base
17:01:01 <jmcarthur> covi: what's not fast enough?
17:01:33 <byorgey> novitiate: the answer to your first question is yes, e.g.  disemvowel = filter $ flip notElem "aeiouAEIOU"
17:01:49 <roadfish> `nand`: ok, thanks for the help
17:02:41 <byorgey> novitiate: the answer to your second question is also yes, but I'm not sure exactly what you want the two arguments to be
17:02:43 <roadfish> I am starting to look at the files in ~/.cabal/packages/hackage.haskell.org/uniplate/ ... I guess that is where all the useful info is
17:02:55 <`nand`> roadfish: I'm looking at http://hackage.haskell.org/packages/archive/uniplate/1.6.10/doc/html/Data-Generics-Uniplate-Data.html
17:02:59 <novitiate> right, but what if I want to make the stripped set also a variable, and so define disemvowel = stripchars "aeiouAEIOU", and, say, noOUs as stripchars "ou"?
17:03:32 <byorgey> novitiate: oh, you mean is it possible to write it without parentheses then?
17:03:51 <novitiate> byorgey, right: "filter $ flip notElem" throws an error.
17:03:59 <`nand`> stripchars = filter . flip notElem
17:04:19 <byorgey> you could do filter . flip notElem, right, though that puts the arguments in the other order.
17:04:37 <byorgey> I guess stripchars = flip $ filter . filp notElem   works
17:04:54 <`nand`> what are you saying?
17:04:57 <`nand`> the argument seems in the correct order
17:05:08 <byorgey> oh, sorry
17:05:10 <novitiate> `nand`, stripchars "aeiou" "help me" throws an error if stripchars = filter . flip notElem
17:05:13 <roconnor> @instances Ix
17:05:14 <lambdabot> Couldn't find class `Ix'. Try @instances-importing
17:05:28 <novitiate> expected type () doesn't match actual type Char
17:05:29 <`nand`> > let stripchars = filter . flip notElem in stripchars "aeiou" "help me"
17:05:32 <lambdabot>   "hlp m"
17:05:35 <`nand`> it does?
17:05:37 <`nand`> oh
17:05:44 <`nand`> novitiate: NoMonomorphismRestriction
17:06:00 <novitiate> oho. Is that why Prelude doesn't like it?
17:06:01 <Modius> I think in promoting haskell you should really promote IDE integration like GHC-mod or equivalent. . . .  The HLint suggestions are very educational, help one feel like you're moving from noob/crap haskell toward quality haskell.
17:06:04 <Jafet> Throw the error, kid! Go long!
17:06:12 <novitiate> Jafet, :)
17:06:15 <`nand`> doesn't have to do with Prelude
17:06:20 <byorgey> novitiate: you're being bitten by the Dreaded Monomorphism Restriction.  it's recommended to turn it off.
17:06:23 <`nand`> just with lack of top-level type signatures
17:06:33 <byorgey> just put {-# LANGUAGE NoMonomorphismRestriction #-} at the top of your file.
17:06:46 <byorgey> that, or give stripchars a type signature (which is a good idea anyway)
17:06:46 <`nand`> or, if this is GHCi, :set -XNoMonomorphismRestriction
17:06:49 <`nand`> in fact you should put that in .ghci
17:06:54 <NougatRillettes> `nand`: (this pseudo is so annoying to type) when I think about my first question : exporting show from values to type, I still think it would be useful
17:07:05 <NougatRillettes> indeed it's not in this case
17:07:06 <hpc> novitiate: be careful when you turn it off though; there's performance considerations to using overly-polymorphic things in the wrong places
17:07:35 <hpc> putting a type signature on it and leaving the monomorphism restriction as-is will generally be a better choice
17:07:38 <novitiate> hpc, so as long as I give things type signatures I don't need to turn off the monomorphism restriction?
17:07:41 <`nand`> in files, you should just always put type signatures on everything
17:07:41 <NougatRillettes> but one may use it on something more complex than just Peano integers
17:07:43 <novitiate> hpc, got it.
17:07:44 <`nand`> yeah
17:07:46 <`nand`> err
17:07:48 <`nand`> not on everything
17:07:50 <`nand`> on top level declarations
17:08:02 <byorgey> NougatRillettes: I can type `nand`'s nick just by typing `<Tab>
17:08:16 <byorgey> if your IRC client can't do that then maybe you need a better one =)
17:08:17 <novitiate> `nand`, top level means outside a "let" or "where"?
17:08:28 <NougatRillettes> on an azerty keyboard ` is AltGr + è
17:08:32 <NougatRillettes> quite annoying
17:08:39 <hpc> novitiate: essentially; it's the stuff that your module exports
17:08:39 <byorgey> oh, I see =)
17:08:42 <hpc> "main = ..."
17:08:48 <hpc> "map f [] = ..."
17:08:50 <`nand`> novitiate: I'll occasionally put type signatures on stuff inside a let/where if they're particularly confusing
17:08:52 <hpc> those are top-level
17:10:12 <`nand`> NougatRillettes: it might make sense to remap that to something more convenient; and I don't say this because of me but because of the ` ` syntax in Haskell
17:10:28 <`nand`> it's just below escape for me, next to 1
17:10:39 <NougatRillettes> it œ
17:10:42 <NougatRillettes> for me
17:10:45 <NougatRillettes> mor useful
17:10:47 <NougatRillettes> +e
17:11:37 <`nand`> you can just omit the ` when talking to me and I don't mind, but you might get some angry snarls from the correctness enforcers
17:11:59 <`nand`> either way moving on; I can see how it might be useful to have some sort of special way of pretty-printing Sing types
17:12:29 <`nand`> but I don't see a way of doing it elegantly other than hacking in a magic special case
17:12:46 <NougatRillettes> well I don't know how GHCI works
17:13:07 <NougatRillettes> so I'm not that useful to you
17:13:21 <`nand`> I always get confused by my type errors when they involve large DataKinds constants :(
17:13:34 <NougatRillettes> who wouldn't
17:13:57 <NougatRillettes> is there anyone familiar with GHCi code over here ?
17:14:07 <hpc> irssi doesn't complete `nand` without typing a backtick
17:14:22 <hpc> NougatRillettes: ghci is essentially a gigantic do-block
17:14:29 <hpc> in the IO monad
17:14:33 <`nand`> there's also a lot of noise like * because it insists on adding the kind index for PolyKinded stuff for everything
17:14:38 <`nand`> including, of course, HLists
17:14:42 <`nand`> err, type level lists
17:14:59 <`nand`> example :: HList ((':) * Int ((':) * Char ((':) * Bool ('[] *))))
17:15:00 <`nand`> yuck
17:15:08 <`nand`> can't have printed HList '[Int, Char, Bool] can it?
17:16:07 <NougatRillettes> Well although I don't know the code I feel that it shall not be so hard to use the same show function for kind and values
17:17:05 <NougatRillettes> Any brave dev anywhere ? :]
17:17:33 <novitiate> Thanks, everybody!
17:17:49 <aavogt> NougatRillettes: how would that work for    '[a, Char, Bool]?
17:17:56 <`nand`> NougatRillettes: no, it doesn't work that way
17:18:04 <NougatRillettes> :(
17:18:06 <`nand`> you can't just lift an arbitrary function to the type level
17:18:11 <aavogt> as in, what does the value-level function see for the 'a'?
17:18:35 <`nand`> and the type printing comes from GHC, not GHCi in particular
17:19:00 <NougatRillettes> well tgere could be restrictions
17:19:01 * aavogt guesses ghc could have a class for prettyprinting types
17:19:02 <`nand`> it would be a deep change in the way GHC pretty-prints types; and to involve anything concerning the value level Show typeclass at all would be black magic most likely
17:19:09 <NougatRillettes> to non-quantified types for example
17:19:16 <`nand`> I see stuff like '[] sugar working, though
17:20:17 <cizra> Hm )= I can't figure out iconv'ing. I give IConv.convert a ByteString and I get a ByteString, but BS.unpack gives me a [Word8], not a [Char].
17:20:48 <`nand`> that being said, I wish the * stuff was optional, at the very least
17:21:13 <hpc> cizra: BSC.unpack
17:21:30 <hpc> (from .Char8)
17:21:31 <`nand`> ByteStrings are not Strings
17:21:37 <hpc> yeah, that too
17:21:38 <`nand`> the .Char8 interface should be nuked from orbit
17:21:40 <rwbarton> what are you doing
17:21:58 <rwbarton> it sounds possibly overly complicated
17:22:00 <hpc> `nand`: there's good reasons to have those things already implemented
17:22:04 <cizra> rwbarton: Trying to decode a %20 URL
17:22:23 <pnielsen> cizra: use Text. URLs can contain non-ASCII characters
17:22:51 <pnielsen> Data.Text, that is
17:23:08 <NougatRillettes> `nand`: how would you get '+ working ?
17:23:20 <cizra> pnielsen: yes, but the only stock function to do that uses ByteStrings
17:23:20 <Peaker> I wonder why Data.ByteString.Char8 provides IsString instance and not the UTF8 module
17:23:24 <byorgey> `nand`: the HList printing sounds like just someone need to actually code up a special case
17:23:35 <byorgey> `nand`: I doubt there's any fundamental reason it couldn't work
17:23:40 <mauke> cizra: is this a web application?
17:24:11 <cizra> mauke: no, well, sort of. I'm trying to make web logs readable.
17:24:44 <pnielsen> cizra: maybe you want http://hackage.haskell.org/packages/archive/http-conduit/1.8.6/doc/html/Network-HTTP-Conduit.html#v:parseUrl ?
17:25:58 <cizra> pnielsen: Sounds vastly overengineered for my purpose. How do I get the data out of a Request?
17:26:04 <`nand`> NougatRillettes: '+ ?
17:26:25 <NougatRillettes> + operation on Int at kind-level
17:26:35 <cizra> pnielsen: Hmmm, it's a record? OK
17:26:41 <pnielsen> cizra: yeah
17:26:46 <`nand`> byorgey: yes absolutely; you'd just need a special case for ': and '[] pretty printing
17:26:53 <`nand`> byorgey: but what he was talking about would go beyond that
17:26:54 <pnielsen> cizra: that's fast, at least. There is also a parseUrl in HTTP-4000 I believe
17:27:24 <NougatRillettes> I was talking about pretty printing and non-quantified inductive
17:27:34 <NougatRillettes> like Foo Bar Na 2
17:27:49 <NougatRillettes> (or Peano :°)
17:27:51 <pnielsen> cizra: the constructor is hidden, but you can see the fields below data Request: http://hackage.haskell.org/packages/archive/http-conduit/1.8.6/doc/html/Network-HTTP-Conduit.html#t:Request
17:28:04 <`nand`> NougatRillettes: well for one, the ' thing is only for promoted constructors; + is not a constructor, it's a function. Functions don't get promoted; but you can write type families to simulate functions in some cases - there's a type family for addition in GHC.TypeLits, called (+)
17:28:16 <`nand`> however, in GHC 7.6.1, it doesn't actually do anything
17:28:25 <NougatRillettes> ouh, obviously
17:28:39 <NougatRillettes> ok i'm getting more and more confused :D
17:28:39 <pnielsen> cizra: could have sworn there was one that gave a [Text] of the parsed path. Sec.
17:29:14 <NougatRillettes> @where type fmillies
17:29:18 <NougatRillettes> @where type famillies
17:29:19 <`nand`> maybe it's best to just leave the DataKinds stuff alone for a while, at least until the dust surrounding it has solidified
17:29:35 <`nand`> type families are undergoing changes as well
17:29:44 <`nand`> but for what it's worth; http://www.haskell.org/haskellwiki/GHC/Type_families
17:29:47 <NougatRillettes> well i feel like getting dusty :)
17:30:10 <hpc> type families are probably going to survive their changes without any substantial re-learning
17:30:30 <`nand`> yeah, probably
17:30:40 <hpc> whooooa, the ghc trac has a blog
17:30:48 * hpc reads
17:30:53 <elliott> how are type families changing
17:30:55 <elliott> just the overlapping stuff?
17:31:04 <`nand`> that's the only change I've heard of
17:31:24 <pnielsen> cizra: ah, that's WAI. If you don't mind Strings, this is probably easier and lighter, import-wise: http://hackage.haskell.org/packages/archive/network/2.4.0.1/doc/html/Network-URI.html
17:36:31 * `nand` wonders how much would break in an upgrade from GHC 7.6.1 to 7.7.20121213
17:41:55 <Nereid> I wish there was a way to specify that a type family was injective on certain arguments.
17:41:55 <hpc> just going off the version number, any parts of the codebase that are unfinished?
17:42:47 <`nand`> probably; I meant in particular in terms of existing haskell libraries
17:42:51 <`nand`> I'll try it on my netbook and find out
17:43:24 <hpc> or chroot or cabal-dev
17:43:33 <JoeyA> In System.Process, you can use UseHandle to set stdin, stdout, or stderr to a given handle.  Does anyone have a program that uses a network Handle with UseHandle?
17:43:55 <hpc> @hoogle UseHandle
17:43:55 <lambdabot> System.Process UseHandle :: Handle -> StdStream
17:44:39 <hpc> JoeyA: people would use the higher-level functions in that module
17:44:49 <hpc> UseHandle seems like just a "building block" as it were
17:45:37 <byorgey> Nereid: many people wish that. (including me.)
17:46:11 <JoeyA> Suppose someone wanted to connect a socket to a program on the system (e.g. to implement something like SSH).
17:46:18 <byorgey> Nereid: I am hopeful that we will get it someday.
17:47:55 <JoeyA> I'm just hunting around for cases where programs hack into a Handle to mess with the underlying file descriptor.
17:48:25 <UsiakVonCashen> hey lookin 4 a quick way 2 make sum moolah, well u can b my rating slave on the yahoo! pool to help me climb up da ladder rankings. all u gotta do is lose 2 me. if you play with me for 1 hr. i give u a voice in my IRC channel #ultrachatzone. 2 hrs. i give you a half op. 3 hrs. i give you an op. 4+ hrs. you become co-owner. i think thats a pretty fair wage. well if u r intrested let me kno b4 its 2 late. 1st come 1st serve
17:49:10 <Botje> hell k-line
17:49:28 <`nand`> @where ops
17:49:28 <lambdabot> arjanb bos Cale conal copumpkin dcoutts dibblego dons edwardk glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom Philippa Pseudonym quicksilver roconner Saizan shapr sjanssen ski wli
17:49:28 <lambdabot> xerox
17:49:48 --- mode: ChanServ set +o edwardk
17:49:59 --- mode: edwardk set +b *!~nend@89.254.149.213
17:49:59 --- kick: UsiakVonCashen was kicked by edwardk (Your behavior is not conducive to the desired environment.)
17:50:00 <flebron> Poor xerox. An afterthought.
17:50:18 <AfC> heh
17:50:33 --- mode: edwardk set -o edwardk
17:50:56 <Nereid> JoeyA: mess with how?
17:50:57 <JoeyA> 1 minute 34 seconds.
17:51:02 <`nand`> I learned a new word! ‘conducive’
17:51:18 <Botje> also, isnt roconnor's name spelled wrong in that factoid?
17:51:24 <adnam> i learned a new word "moolah"
17:51:36 <Nereid> hah, it is.
17:51:41 <JoeyA> Nereid: The base package exposes the representation of Handle in GHC.IO.Handle.Types
17:51:42 <`nand`> monochrom!!
17:51:51 <edwardk> silly `nand`, uses lens all day long, and only _now_ learns a new word
17:51:52 <NougatRillettes> french rappers already know it ;)
17:52:00 <JoeyA> Within, there's one (or two, for a duplex) existentially-quantified records.
17:52:07 <NougatRillettes> http://youtu.be/YiC5SeRfLYw
17:52:11 <Nereid> Botje: I fixed it.
17:52:14 <JoeyA> That abstract over an underlying IO device.
17:52:29 <Nereid> (you could have yourself, with @where+)
17:52:56 <JoeyA> data Handle__ = forall dev enc_state dec_state . (IODevice dev, BufferedIO dev, Typeable dev) => Handle__ { ... }
17:53:18 <Nereid> mhm
17:53:19 <JoeyA> Some libraries use the Typeable constraint to see if the device is an FD, and fail if it's not.
17:54:55 <JoeyA> For example, haskeline does it to issue ioctls to devices.
17:56:21 <chord> How does Haskell support a repl given that its based on type inference
17:56:25 <roconnor> @where ops
17:56:26 <lambdabot> arjanb bos Cale conal copumpkin dcoutts dibblego dons edwardk glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom Philippa Pseudonym quicksilver roconnor Saizan shapr sjanssen ski wli
17:56:26 <lambdabot> xerox
17:56:32 <roconnor> much brighter
17:56:35 <Nereid> :p
17:56:48 <edwardk> roconnor?
17:56:56 <Nereid> it said roconner before
17:57:05 <JoeyA> chord: It infers types as you introduce definitions, rather than all at once.
17:57:06 <edwardk> oh
17:57:18 * edwardk goes back to other things
17:57:47 <JoeyA> A toplevel function without a signature is given the most general type possible.
17:58:04 <mauke> roconnor++  # unintentionally testing my setup
17:58:07 <JoeyA> This includes functions you define in ghci
17:58:09 <c_wraith> most general rank-1 type possible. :)
17:58:14 <JoeyA> ah
17:58:36 <Nereid> not quite, the dmr exists.
17:58:43 <JoeyA> Right.  I was trying to work that in.
17:58:53 <JoeyA> If you say: let f x y z = ...
17:59:02 <JoeyA> The monomorphism restriction won't kick in.
17:59:05 <Nereid> sure.
17:59:27 <JoeyA> @let f x = show x
17:59:29 <lambdabot>  Defined.
17:59:31 <JoeyA> :t f
17:59:33 <lambdabot>     Ambiguous occurrence `f'
17:59:33 <lambdabot>     It could refer to either `L.f', defined at <local>:8:1
17:59:33 <lambdabot>                           or `Debug.SimpleReflect.f',
17:59:35 <JoeyA> :(
17:59:37 <Nereid> :t L.f
17:59:39 <lambdabot> Show a => a -> String
17:59:48 <JoeyA> @let f' = show
17:59:50 <lambdabot>  Defined.
17:59:53 <JoeyA> :t L.f'
17:59:55 <lambdabot> Show a => a -> String
18:00:04 <Nereid> lambdabot has that off.
18:00:04 <JoeyA> Oh, it's lambdabot, not Haskell.
18:00:07 <Nereid> :p
18:00:52 <Nereid> but still, that has nothing to do with ghci.
18:00:53 <JoeyA> I, for one, welcome our monomorphic overlords.
18:01:25 <JoeyA> Defaulting f to () -> String makes it a *lot* faster :-)
18:01:29 <Nereid> :p
18:01:46 <Nereid> aw, show (undefined :: ()) isn't "()"
18:01:57 <Nereid> so it could be optimized further!
18:02:34 <roconnor> mauke: setup?
18:03:14 <JoeyA> instance  Show ()  where showsPrec _ () = showString "()"
18:03:33 <JoeyA> @data Foo = Foo
18:03:34 <lambdabot> Unknown command, try @list
18:03:34 <mauke> roconnor: irc client highlight rules
18:04:02 <JoeyA> It's a pattern match, so it's refutable.
18:08:03 <NihilistDandy> lispy: So I started working through the Idris tutorial. It's pretty great. Like, Agda with tactics great.
18:08:26 <Ralith> isn't it :D
18:08:26 <mauke> @src () show
18:08:27 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
18:08:34 <lispy> NihilistDandy: awesome
18:09:15 <NihilistDandy> I need to push a couple of corrections to the tutorial at some point soon, but other than that it's been awesome.
18:10:27 <lispy> I have a setup where I can convert latex to html with embeded svg for maths. I should test it out on the idris tutorial.
18:10:37 <lispy> that would be a great stress test
18:10:57 <NihilistDandy> Please do. That'd be a great thing to have.
18:18:03 <NihilistDandy> lispy: There's a common pattern I see in the design of all these dependently typed languages that they use ML style cons (::) and type annotation (:). Agda, Idris,  and Ur all do it. Do you think it's because types are more natural to operate on than lists (so they get the easier notation)? Or is it something else
18:18:06 <NihilistDandy> ?
18:18:51 <NougatRillettes> http://paste.awesom.eu/NougatRillettes/c9F
18:18:52 <lispy> NihilistDandy: Math/type theory both use the notation that ML, Agda, Idris, Ur all use. Haskell is actually the odd one out.
18:18:55 <NougatRillettes> I have the following code
18:19:06 <NougatRillettes> and when I instance CHar as Decidable
18:19:19 <lispy> NihilistDandy: Haskell designers thought that we wouldn't use type signatures often but that we would cons a lot. So they made cons easier to type.
18:19:31 <NougatRillettes> I get an overlapping instance with Integral Char
18:19:47 <NougatRillettes> while Char is not instancied as Integral, why ?
18:20:07 <NihilistDandy> I see. Thinking back to the one programming languages class I took, that actually lines up with what I remember. Hadn't even thought of the obvious.
18:22:15 <lispy> NougatRillettes: Char has an Enum instance, could that be the problem?
18:22:52 <mauke> lispy: no
18:23:45 <lispy> mauke: any idea what what the problem is?
18:23:56 <mauke> isn't it obvious?
18:24:02 <mauke> NougatRillettes: what's the actual error message?
18:25:19 <`nand`> NougatRillettes: type class resolution doesn't look at the constraint
18:25:35 <`nand`> NougatRillettes: so ‘instance ... => Decidable a’ matches every possible type
18:25:55 <`nand`> in other words, everything else would collide with it
18:26:36 <NougatRillettes> hm
18:26:48 <NougatRillettes> GHC just see the Decidable a in other terms
18:27:05 <NougatRillettes> ok I'm gonna look for dusty language extensions again
18:27:14 <NougatRillettes> I've seen something like this recently !
18:27:16 <NougatRillettes> :D
18:32:18 <Ralith> lispy: if you do manage to htmlify the tutorial, please do share the script for use on the site
18:33:00 <NougatRillettes> `nand`: could typeclass famill solve that ?
18:33:50 <`nand`> probably not. depends on what you want to ‘solve’
18:34:21 <lispy> Ralith: the script I use (it's a prototype, but it works on my pathological input) is here: https://github.com/dagit/dagit.github.com
18:34:37 <lispy> Ralith: demo here: http://dagit.github.com/hello.html
18:35:13 <Ralith> looks nice
18:35:59 <lispy> It could be improved a lot by moving the shell script into Haskell so that a proper html parser can be used: https://github.com/dagit/dagit.github.com/blob/master/fixup-refs.sh
18:36:22 <lispy> It re-seds the file many times but things could be pre-computed
18:39:10 <lispy> (I've learned to do things with bash that I'm not proud of...not proud of at all)
18:40:31 <lispy> Also, I kind of wish Hevea was written in Haskell so people could just 'cabal install' it.
18:42:38 <hpc> i write most of my bash in perl
18:45:21 <NihilistDandy> I write most of my perl in coq.
18:47:16 * applicative writes his coq in idris of course
18:48:11 <NougatRillettes> I just change bit of my RAM and HDD using telekinetics
18:48:31 <NougatRillettes> how is this usefull : http://www.haskell.org/ghc/docs/latest/html/users_guide/other-type-extensions.html#impredicative-polymorphism
18:48:47 <covi> If I have sth like  x <- [1, 2, 3]  in a do block, what's x then?
18:49:30 <shachaf> x is 1 and 2 and 3
18:50:10 <pnielsen> C-x M-c M-butterfly
18:50:13 <byorgey> it's all of them at once
18:50:13 <hpc> x is a parameter to the continuation of whatever action that line is inside
18:50:26 <hpc> it is instantiated to 1, 2, and 3
18:50:30 <hpc> one or more times
18:50:44 <hpc> or zero times, even
18:52:34 <JoeyA> covi: If I say map (\x -> ...) [1, 2, 3], what's x then?  :-)
18:53:40 <JoeyA> Think of x <- [1, 2, 3] as "pick an x from the list".  x will just be one of the items in the list.
18:53:58 <JoeyA> But it'll evaluate the subsequent code for each item.
18:57:32 <Jafet> M-c hammer
18:58:29 <BMeph> Jafet: No, you can't touch that! ;þ
19:01:28 <NihilistDandy> BMeph: You're a real thorn in my side~
19:10:57 <BMeph> NihilistDandy: Just think of me as a rose, then. Since, you know, "Every rose has its 'þ'." ;)
19:17:15 <DrChaos> Hello. I am on a stable connection now. In other news, I've tried implementing the selection sort algorithm, however, I think the recursion is messing me up
19:18:38 <shachaf> I recommend implementing insertion sort instead.
19:20:09 <NougatRillettes> is there anyway to massively adapt instance of type T to type S, provided T and S are isomorphic ?
19:21:20 <shachaf> If S is a newtype you can use GeneralizedNewtypeDeriving.
19:23:05 <NougatRillettes> and if it's not ? :>
19:23:35 <NougatRillettes> cosidering Int and Peano = S Peano | Z for example
19:23:42 <shachaf> Those aren't isomorphic.
19:24:07 <NougatRillettes> hm
19:25:27 <shachaf> For example think about what you'd like (-) to turn into.
19:25:29 <NougatRillettes> indeed
19:25:39 <NougatRillettes> well
19:25:48 <NougatRillettes> i'm looking for an example of ismorphics types
19:26:00 <NougatRillettes> that couldn't be defined with newtype
19:26:00 <DrChaos> NougatRillettes -> easy
19:26:04 <shachaf> Anyway the answer is not really.
19:26:16 <NougatRillettes> and that is a bit interessant
19:26:21 <DrChaos> oh? that couldn't be defined with newtype?
19:26:31 <mgsloan> > minBound :: Int
19:26:32 <lambdabot>   -9223372036854775808
19:26:43 <shachaf> For that matter, maxBound :: Int
19:26:47 <mgsloan> If this is considered isomorphic to "Z" then it works out
19:26:59 <DrChaos> what is this? anyway, one example of an isomorphic type is: data List = Cons (List a)
19:27:01 <mgsloan> but it wouldn't be very useful :)
19:27:02 <DrChaos> whoops
19:27:04 <NougatRillettes> well let's take smthg quite trivial
19:27:16 <NougatRillettes> F = A | B and Booleans
19:27:40 <DrChaos> yes, that's an isomorphic data type
19:27:49 <shachaf> Yes, those are isomorphic, and no, even if you choose which isomorphism you want, you won't be able to carry instances over.
19:27:58 <NougatRillettes> ok ok
19:28:04 <mgsloan> NougatRillettes: I have a proposed haskell feature (that I really need to get back to working on) that would do this very well
19:28:15 <mgsloan> this use case was one of the motivations
19:28:24 <mgsloan> https://github.com/mgsloan/instance-templates/blob/master/tests/numeric/WithExt.hs#L41
19:28:32 <NougatRillettes> thx mgsloan
19:28:56 <mgsloan> (it's related to default superclass instances, but more kickass)
19:29:21 <Sentreen> Hey everybody, stupid question; I want to start a thread to perform some calculation on each element in a list. What's the best way to do this? I just started doing this with map, but it seems that haskell is too lazy for this to work (using forkIO)
19:30:02 <mgsloan> if the dispatch of these templates was generalized (could get hairy), then you might be able to have "instance ByIso [Eq, Ord, Num, Show, Read] MyType"
19:31:18 <Jafet> Sentreen: you are not using forkIO correctly then
19:31:38 <NougatRillettes> it would be really cool mgsloan
19:31:50 <mgsloan> NougatRillettes: Agreed!
19:32:06 <Sentreen> Jafet: So it should work in map? The exact same call did work when I used it outside the map, on the head of the list :)
19:32:21 <NougatRillettes> (i didn't really get your code though, but it's time for me to go ti bed)
19:32:33 <Sentreen> Or do you mean that forkio in map is not the correct way to do it?
19:32:37 <mgsloan> NougatRillettes: Yeah, it's a bit weird out of context
19:33:57 <Jafet> Sentreen: you are being very confusing. Write code instead
19:35:02 <Sentreen> Allright, give me a sec to dump it somewhere
19:36:19 <hpaste> Sentreen pasted “Threading example” at http://hpaste.org/79968
19:36:53 <Sentreen> Jafet: There you go, forgive my crappy use of do. I'm not really a haskell hero :p
19:36:55 <Jafet> The basic idea is to write forkIO in a place where it gets run, and to tell it to evaluate each thing in the list.
19:38:04 <Jafet> > map putStrLn ["1", "2", "3"]
19:38:06 <lambdabot>   No instance for (GHC.Show.Show (GHC.Types.IO ()))
19:38:07 <lambdabot>    arising from a use of ...
19:38:19 <Jafet> That isn't a place where IO gets run.
19:38:32 <Jafet> :t mapM_
19:38:34 <lambdabot> Monad m => (a -> m b) -> [a] -> m ()
19:40:04 <Sentreen> that does make sense, I'll try that, thanks a lot!
19:40:55 <Jafet> :t map putStr ["1", "2", "3"]
19:40:57 <lambdabot> [IO ()]
19:40:59 <Jafet> :t mapM_ putStr ["1", "2", "3"]
19:41:01 <lambdabot> IO ()
19:41:34 <Jafet> return $! is not a very good way to run IO, because it doesn't.
19:42:12 <Sentreen> Right, I should have removed that
19:42:42 <`nand`> are you just trying to calculate things in parallel?
19:43:57 <Sentreen> not really. it's a pacman like game. Based on graphs instead of an actual playing field. The idea is to have an arbitrary number of ghosts. Every ghost should get a dedicated thread to calculate which paths it can block
19:44:41 <Sentreen> So after the calculation I need to merge them somewhere, which is why the checkUpdateChecker is there. It has to keep on retrying until all the ghosts did their calculations
19:45:08 <DrChaos> shachaf -> can you show me how you'd implement selection sort in Haskell while I go ahead and implement insertion sort?
19:45:34 <DrChaos> I really want to know how implementing selection sort is done
19:45:37 <`nand`> I pasted a rough first draft of how one could implement selection sort in haskell eaqrlier
19:45:39 <shachaf> I probably wouldn't.
19:45:40 <`nand`> earlier*
19:46:03 <`nand`> http://hpaste.org/79955
19:46:59 <DrChaos> `nand` -> that's nice and all but I really don't understand it fully
19:47:31 <DrChaos> most of it looks like black ink to me, colorless and with no scent
19:48:13 <NihilistDandy> DrChaos: http://books.google.com/books/about/Algorithms.html?id=ni1vQgAACAAJ
19:48:21 <shachaf> I recommend learning more Haskell -- through algorithms like insertion sort rather than selection sort -- and then reading it again.
19:49:28 <DrChaos> hmm...I don't know how you'd go about implementing insertion sort
19:49:49 <sclv> Sentreen: you shouldn't need to manually check for completion and retry (unless you want to0)
19:49:52 <NihilistDandy> Then you don't know enough about algorithms for anyone to help you effectively
19:50:05 <DrChaos> first I need a good description of the steps involved in insertion sort, I do not know off hand these steps
19:50:10 <sclv> You can just have the main thread block until everyone is done
19:50:17 <sclv> either using a channel, or a semaphore, or etc.
19:50:39 <NihilistDandy> Pick up a book on algorithms. Read it. Haskell won't teach you how algorithms work.
19:50:54 <lispy> DrChaos: Wikipedia has a pretty decent write up of insertion sort: https://en.wikipedia.org/wiki/Insertion_sort
19:51:15 <lispy> they even have an example in C and pseudo code for some other imperative language
19:51:26 <lispy> along with examples and visualizations
19:51:36 <Sentreen> sclv: the update check is my makeshift semaphore. Perhaps I should make myself a decent semaphore though
19:52:16 <NihilistDandy> DrChaos: Given what you know insertion sort does, what do you imagine its type signature is?
19:54:47 <sclv> Sentreen: atomically $ getTVar myVar >>= \x -> check (x >= waitAmount)
19:55:11 <sclv> that's your entire counting semaphore in stm
19:55:11 <sclv> if the condition isn't met, it will wait until something changes, then try again
19:55:48 <sclv> and etc
19:55:53 <sclv> if you actually want to read values out of distinct tmvars, then that's even easier. you just read out of all of them in a single atomic block. if any is empty, your transaction will automatically retry when something changes
19:56:45 <Sentreen> I didn't know that, I though it only did that when you explicitly called retry. cheers
19:56:47 <DrChaos> NihilistDandy -> insertionSort :: [a] -> [a], and I'd have some helper functions defined within the insertionSort function, namely type item = a; hole = a; insert :: item -> hole -> item
19:57:00 <Sentreen> also thx for the semaphore
19:57:09 <NihilistDandy> DrChaos: What about the comparison?
19:58:09 <sclv> (check does call retry in its implementation. as does tmvar. there's just a nice toolkit already there for you on top of the primitives)
19:58:27 <NihilistDandy> The type signature you describe takes an input list and spits out another list. No need to get clever, yet. Just get a high-level idea of the things you need for a correct insertion sort.
19:59:07 <NihilistDandy> Unless you always want to sort a particular way. In which case that's fine.
20:04:23 <DrChaos> NihilistDandy -> I want a general function that can take a list of any type, even lists containing lists [sort by inner lists length] and do it properly
20:04:37 <elliott> you really don't want to write that
20:04:37 <Sentreen> Right, I'm off, thanks for the advice everybody
20:04:42 <elliott> it isn't really a coherent thing in haskell
20:04:50 <elliott> you can sort of do it with a bunch of type system extensions
20:04:54 <elliott> but it's not something you want to do
20:04:59 <DrChaos> ah
20:07:18 <NihilistDandy> DrChaos: Devise a simple insertion sort that allows you to define the sorting method. I'll start you with the type signature and a skeleton of an implementation.
20:07:20 <hpaste> NihilistDandy pasted “Insertion Sort” at http://hpaste.org/79969
20:07:49 <NihilistDandy> First, what should the base case (sorting the empty list) be?
20:08:23 <`nand`> why not just use Ord
20:08:37 <DrChaos> NihilistDandy -> base case should return []
20:09:21 <NihilistDandy> `nand`: Keeping it extremely basic.
20:10:13 <DrChaos> what does (a -> a) mean?
20:10:26 <`nand`> I think Ord would be simpler, personally
20:10:36 <`nand`> DrChaos: the type of functions from ‘a’ to ‘a’
20:10:36 <DrChaos> I'm not at the point where you have one function depending on the return value of another like that
20:10:53 <NihilistDandy> `nand`: That's fair. Feel free to annotate.
20:10:54 <DrChaos> like (a -> a -> Bool) for example
20:11:20 <DrChaos> what if you replaced Bool with Ord a?
20:11:23 <DrChaos> @src Ord
20:11:23 <lambdabot> class  (Eq a) => Ord a  where
20:11:24 <lambdabot>     compare      :: a -> a -> Ordering
20:11:24 <lambdabot>     (<), (<=), (>), (>=) :: a -> a -> Bool
20:11:24 <lambdabot>     max, min         :: a -> a -> a
20:11:33 <DrChaos> yay
20:11:56 <DrChaos> yes, I like Ord a lot. Please show me how I can use it
20:11:57 <`nand`> (replacing Bool by Ord a would be a kind error)
20:13:01 <`nand`> oh, though GHC doesn't actually call it that
20:20:20 <Philippa> `nand`: it's only a kind error if you're thinking in pretty new GHCish, too. Otherwise, constraints aren't even the same syntactic class
20:20:47 <`nand`> I'm still a bit confused about terminology
20:20:52 <`nand`> the error calls it a ‘Predicate’
20:21:07 <`nand`> I've never heard that word in a Haskell context; what happened to ‘constraint’?
20:21:10 <Philippa> "category error" would be a usable term from elsefield
20:21:30 <Philippa> "predicate" used to be a comparatively common term for it
20:21:38 <mm_freak_> aristid: sure
20:21:38 <lambdabot> mm_freak_: You have 1 new message. '/msg lambdabot @messages' to read it.
20:21:40 <Philippa> oh, a decade back or so? :-)
20:22:41 <mm_freak_> aristid: you're thinking of pure applicatives
20:31:05 <beefcube> is there a way to set a language pragma in GHCI from the pragma noted in buffer, e.g. {-# LANGUAGE.. #-} ?  (other than :set -X... that's painful)
20:31:40 <ivanm> beefcube: not really
20:31:54 <ivanm> as there might be pragmas set in your file that you don't want set in your ghci session
20:32:09 <shachaf> Put every pragma in ~/.ghci
20:32:13 <ivanm> of course, you can have the ":set -X..." commands in a .ghci file (either in your home directory or per-project)
20:32:30 <ivanm> shachaf: even ones that potentially clash? :p
20:32:36 <shachaf> Yes.
20:32:39 <ivanm> :set -XAllTheThings
20:32:43 <shachaf> I put both -XFoo and -XNoFoo
20:32:46 <shachaf> Just in case.
20:35:37 <`nand`> warning: If you set a pragma in .ghci, then :l a file, that file will be interpreted with that pragma on
20:36:11 <`nand`> so before uploading, make sure it actually compiles on its own :P
20:36:36 <beefcube> oh, what I'm trying to do is load pragmas for the file that I'm editing and testing from VIM at the time, and I know other devs are doing this as well, so it is surprising that this isn't a handled use-case
20:37:37 <beefcube> ok, I guess I'll script a .ghci for each file then
20:37:48 <shachaf> If you :set -XAPragma and then :r, it'll reload the file and keep the pragmas.
20:37:57 <`nand`> or just run :l again
20:38:13 <DrChaos> `nand` -> can you annotate NihilistDandy's http://hpaste.org/79969 with how to use Ord a instead of Bool?
20:38:32 <`nand`> you don't ‘use Ord a instead of Bool’
20:38:41 <`nand`> you ‘use Ord instead of passing a comparison function’
20:42:37 <DrChaos> huh, so <= >= == < > would have to be defined for the type I want to compare, right?
20:42:51 <`nand`> pretty much
20:43:16 <DrChaos> and by looking at Ord's source, these <= >= ... functions return a Bool
20:43:23 <`nand`> yes
20:43:34 <jmcarthur> beefcube: that doesn't make sense to me. shouldn'
20:43:35 <jmcarthur> oops
20:43:44 <jmcarthur> beefcube: shouldn't ghci just use the LANGUAGE pragma from the file?
20:43:58 <`nand`> jmcarthur: it doesn't import them into the REPL
20:43:59 <DrChaos> so very nice, and very nice that these <= >= == /= operators are normal functions]
20:44:06 <`nand`> DrChaos: of course
20:44:23 <jmcarthur> `nand`: oh, you mean it uses it to load the module, but doesn't make it available to you after?
20:44:28 <jmcarthur> i never noticed that
20:44:41 <`nand`> jmcarthur: at least, that's what beefcube is describing. But it certainly uses them within the module
20:45:34 <`nand`> whoa, I went to test it and got a ghc panic
20:45:36 <jmcarthur> `nand`: btw, you can use :seti instead of :set to avoid applying the extensions to files that you load
20:45:48 <`nand`> jmcarthur: oh, okay
20:46:08 <lispy> oh the impossible
20:46:13 <lispy> And how it happens to ghc
20:46:53 <`nand`> jmcarthur: yes, a quick test confirms it
20:47:20 <`nand`> {-# LANGUAGE DataKinds #-} type Foo = True -- :k Foo => Foo :: Bool; :k True => Not in scope: type constructor or class `True'
20:47:45 <M30W> Hello world!
20:47:49 <`nand`> the crash was when I defined type Foo = 3
20:48:04 <`nand`>   (GHC version 7.6.1 for x86_64-unknown-linux):
20:48:07 <`nand`>  lookupVers2
20:49:02 <DrChaos> `nand` -> what does a type signature for a function using Ord look like?
20:49:23 <`nand`> :t sort
20:49:24 <lambdabot> Ord a => [a] -> [a]
20:49:25 <`nand`> DrChaos: like that
20:49:59 <`nand`> how odd; adding ‘import GHC.TypeLits’ makes it load fine; but commenting that out makes it panic
20:50:29 <`nand`> can anybody replicate this?
20:50:32 <mariuss> hi there
20:50:48 <mariuss> I have a question regarding pattern matching
20:51:05 <mariuss> is it possible to match on a type?
20:51:17 <`nand`> depends on what you mean
20:51:33 <mariuss> trying to write a function that works for any type implementing Eq
20:51:48 <`nand`> mariuss: you are trying to, eg., determine the type of an argument to a polymorphic function?
20:51:58 <mariuss> yes
20:52:01 <`nand`> then no
20:52:04 <mariuss> aha
20:52:15 <`nand`> (unless you add Typeable, but that's probably not what you want)
20:52:26 <mariuss> what is the alternative?
20:52:31 <mariuss> a type class?
20:52:41 <`nand`> depends on the problem you're trying to solve
20:53:21 <mariuss> trying to implement the card game of set (matching cards based on features)
20:53:45 <mariuss> each card has 4 features: shape, color, number and shading
20:53:58 <`nand`> jmcarthur: can you replicate this? Blank .ghci, file containing just “{-# LANGUAGE DataKinds #-} type Foo = 0”; start ghci and :l Foo.hs -> GHC panic
20:54:01 <mariuss> I defined 4 types for them
20:54:46 <mariuss> and trying to write a function that can take any of these types, but in some cases I need to implement based on actual type
20:54:52 <lispy> mariuss: data Share; data Color; data Number; data Shading?
20:55:09 <`nand`> “trying to write a function” <- you still haven't described the problem
20:55:27 <mariuss> yes, those 4 data type
20:56:13 <lispy> mariuss: you could now do several things. one simple way is you could make a sum type, data Feature = S Shape | C Color | N Number | S2 Shading
20:56:27 <mariuss> the function takes 2 values for any feature and determines the 3rd one such that the 3 of the are a set (eiter all the same or all different)
20:56:56 <lispy> mariuss: another way is class Feature a where {- now insert things that depend on the specific concrete feature -}, and then instance Feature Shape; instance Feature Color; etc
20:57:20 <`nand`> “takes 2 values for any feature and determines the 3rd one” <- like; :: Color -> Color -> Color; or :: Shading -> Shading -> Shading
20:57:32 <mariuss> yes, like that
20:57:33 <`nand`> but you want it to work for all four features?
20:57:39 <`nand`> then yes, you want a typeclass
20:57:47 <`nand`> class Foo a where determine :: a -> a -> a
20:58:58 <mariuss> that makes sense, will look into a typeclass, thanks
20:59:56 <lispy> mariuss: the "downside" to using a type class the way I've described is that you still won't be able to say compare :: Feature a => a -> a -> a, and then call it as compare s1 c1, where s1 is a shape and c1 is a color
21:00:18 <`nand`> I don't think that was in the problem description
21:00:20 <lispy> I don't know the rules of set well enough to know if that is a requirement
21:00:32 <mariuss> yes, no need to compare across features
21:01:05 <mariuss> btw, set is a really nice pattern matching card game
21:01:26 <mariuss> http://www.setgame.com/set/
21:01:27 <lispy> glguy made a haskell implementation of set, but that's about all I know about it
21:01:53 <`nand`> I'll pass for today, too tired
21:01:55 <lispy> he use unicode symbols at the terminal to render the features
21:02:02 <lispy> (and colors)
21:02:31 <jmcarthur> `nand`: confirmed
21:02:32 <mariuss> I see, not trying to do a complete or fancy immplementation, just a good excuse to play with haskell
21:02:39 <`nand`> jmcarthur: want to open a ticket for it?
21:02:52 <jmcarthur> not right now. i want to go to bed!
21:02:56 <`nand`> me too
21:02:59 <`nand`> tomorrow then
21:02:59 <jmcarthur> heh
21:06:33 <mariuss> related question, for an enumerated data type like "data Shape = Oval | Squiggle | Diamond" is it possible to write a function that returns a set with all the values? in this case it would be [Oval, Squiggle, Diamond]
21:07:01 <hpc> deriving (Bounded, Enum)
21:07:09 <mariuss> possibly, yes
21:07:17 <hpc> > [minBound .. maxBound] :: [Bool]
21:07:19 <lambdabot>   [False,True]
21:07:35 <mariuss> great, thanks
21:24:10 <DrChaos> how do I make a function that uses an Ord as a filter [comparator]?
21:24:54 <charliesome> i need to filter duplicate elements out of a list, but nub is O(n^2). is there a faster way?
21:26:38 <DrChaos> like this? insertionSort :: (Ord a => a -> a) -> [a] -> [a]
21:26:54 <shachaf> Put the Ord on the outside.
21:27:05 <shachaf> Also, what's the (a -> a) for?
21:27:08 <DrChaos> how do you mean outside?
21:27:12 <shachaf> @ty compare
21:27:13 <lambdabot> Ord a => a -> a -> Ordering
21:27:18 <DrChaos> oh
21:27:25 <shachaf> Do you understand what that type says?
21:27:31 <Adnauseam> charliesome: shooting in the dark here, but use data.set ?
21:27:34 <DrChaos> probably not
21:27:40 <DrChaos> oh
21:27:43 <DrChaos> I see
21:28:00 <DrChaos> Ord a is shorthand for a -> a -> Ordering ?
21:28:04 <shachaf> charliesome: Converting to and from a Data.Set will indeed work, if you're OK with losing the order.
21:28:04 <Adnauseam> @t fromList
21:28:04 <charliesome> Adnauseam: ah yeah
21:28:05 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
21:28:07 <shachaf> DrChaos: No.
21:28:13 <charliesome> shachaf: yeah i don't particularly care about order
21:28:17 <shachaf> charliesome: You can do something slightly cleverer if you do care.
21:28:19 <shachaf> Ah, OK.
21:28:21 <Adnauseam> :t fromList
21:28:23 <lambdabot>     Not in scope: `fromList'
21:28:23 <lambdabot>     Perhaps you meant one of these:
21:28:23 <lambdabot>       `IM.fromList' (imported from Data.IntMap),
21:28:32 <Adnauseam> well you know what i mean ;[
21:28:32 <charliesome> :t Data.List.fromList
21:28:33 <lambdabot>     Not in scope: `Data.List.fromList'
21:28:33 <lambdabot>     Perhaps you meant `Data.List.product' (imported from Data.List)
21:28:38 <charliesome> wait
21:28:41 <charliesome> :t Data.Set.fromList
21:28:43 <lambdabot> Ord a => [a] -> S.Set a
21:28:48 <charliesome> oh cool
21:28:51 <Adnauseam> there we go
21:29:01 <shachaf> DrChaos: Which book are you reading as an introduction to Haskell?
21:29:07 <shachaf> I think you mentioned you were reading one.
21:29:08 <DrChaos> shachaf -> rwh
21:29:24 <Adnauseam> steep
21:29:26 <shachaf> I think that one is aimed at people who already know Haskell.
21:29:36 <shachaf> Maybe you should try another one, like
21:29:39 <shachaf> @where lyah
21:29:39 <lambdabot> http://www.learnyouahaskell.com/
21:29:48 <Adnauseam> all hail lyah
21:29:53 <shachaf> Not really.
21:30:01 <shachaf> But it's more of an introduction than RWH
21:30:03 <Adnauseam> best haskell intro book imo
21:30:15 <Adnauseam> wellyeah
21:30:23 <M30W> Adnauseam: It's great but I still go through it :P
21:30:24 * shachaf is not a huge fan of it. But still.
21:30:36 <shachaf> DrChaos: At any rate type classes are something that your book should cover before making you write a sort function that uses Ord. :-)
21:30:41 <applicative> charliesome: you might try http://hackage.haskell.org/packages/archive/unordered-containers/0.2.1.0/doc/html/Data-HashSet.html
21:30:47 <M30W> How well is haskell with phones?
21:30:59 <Adnauseam> M30W: it'sa good book to start with
21:31:00 <ethercrow> how can you not like those pictures in lyah?
21:31:12 <Adnauseam> they say the printed version has more pictures too
21:31:28 <Adnauseam> :o
21:32:32 <Adnauseam> M30W: strong static might get in the way of any phonecalls you might be receiving
21:35:01 <M30W> Adnauseam: what calls?
21:35:13 <M30W> oh
21:35:27 <M30W> forgot my own question :3
21:35:28 <M30W> hehe
21:35:54 <M30W> Adnauseam: haskell; won't be good for calls?
21:36:20 <M30W> Also by phones I was referencing ARM **
21:36:27 <shachaf> I don't think Adnauseam was actually trying to answer your question.
21:36:34 <Adnauseam> ;p
21:36:37 * Adnauseam whistles 
21:37:00 <shachaf> GHC can generate ARM code but there's a long way between ARM code and iPhone/Android/whatever executables.
21:37:08 <M30W> Does ghc etc compile good on arm?
21:37:42 <Adnauseam> i think haskell would make a woderful language for phones
21:37:43 <M30W> shachaf: alarm has ghc in the low end arm repos. Doesn't have it in the ARMv7h
21:37:55 <M30W> Adnauseam: indeed
21:37:58 <M30W> Adnauseam: And voip :D
21:38:24 <Adnauseam> it's just a matter of time now. one of the issues is ofcourse ram, but 2 gigs will soon be standard and the speed will just keep climbing
21:38:37 <M30W> Currently my voip is configured with ruby, yuck. I want haskell :P
21:39:01 <M30W> But to get those numbers little cost to it; not hosting the voip server locally.
21:39:10 <Adnauseam> we'll see how it goes with language dev, i think we need a benevolent dictator. simon is too busy doing other things and not being a benevolent dictator
21:39:39 <M30W> Adnauseam: ghc needs 2G ram?
21:39:51 <M30W> I think 128M should be enough to compile on?
21:39:56 <elliott> haha
21:39:58 <elliott> good luck with that
21:40:04 <elliott> ghc likes ram
21:40:08 <M30W> elliott: just slow :P
21:40:29 <M30W> What about my N900 w\ 256M ram? :D
21:40:46 <M30W> I can make a swapfile ;)
21:40:49 <Adnauseam> M30W: sayig 2g is becoming norm doesn;'t mean ghc needs 2g. besides how many mbytes doyou think will be available for your program on the phone
21:41:25 <M30W> Adnauseam: by the running program, almost nothing
21:41:39 <M30W> by ghc which compiles; idk how it does it all.
21:41:40 <M30W> brb
21:42:04 <Adnauseam> besides, who the hell is going to compile on a phone. it's just that haskell isn't fine tuned for phones and their architecture yet. all them sensors needs libs etc
21:42:41 <Adnauseam> will needs lots of hardware c--/haskell and ghc hacking to get things done i think
21:43:22 <Adnauseam> i could give it ago but that'd be like giving a child a crayon and letting them design bridges.
21:45:22 <aavogt> Adnauseam: I think these people released some sort of ghc that'll make binaries for iphone http://ipwnstudios.com
21:46:29 <jdavis> Is there a good way to embed GCHI as an interpreter, e.g. as a scripting language for a program written in C?
21:47:08 <geekosaur> not directly.  I think you can use hint, though?
21:47:17 <jdavis> What do you mean?
21:47:26 <Adnauseam> aavogt: yea they look like they know what they're doing
21:47:27 <geekosaur> @hackage hint
21:47:27 <lambdabot> http://hackage.haskell.org/package/hint
21:48:01 <geekosaur> ghci is a wrapper around the GHC API, which is somewhat painful to work with directly; hint exposes many of the useful parts with a better interface
21:48:50 <roconnor> @hoogle ShowS -> Shows -> Shows
21:48:50 <lambdabot> Did you mean: ShowS -> ShowS -> ShowS
21:48:50 <lambdabot> Data.Generics.Aliases ext1T :: (Data d, Typeable1 t) => (forall e. Data e => e -> e) -> (forall f. Data f => t f -> t f) -> d -> d
21:48:55 <roconnor> @hoogle ShowS -> ShowS -> ShowS
21:48:55 <lambdabot> No results found
21:49:01 <M30W> Adnauseam: Okay; so 1Ghz quodcore 2G ram, ideal enough for a haskell env for a phone?
21:49:04 <M30W> :P
21:49:18 <M30W> ARM *
21:49:26 <Adnauseam> give it a go
21:49:29 <Adnauseam> report back
21:49:38 <M30W> Adnauseam: Heh. TODO get such a device
21:50:03 <geekosaur> can you install something useful on one of the win8 metro things?
21:50:14 <Adnauseam> M30W: easy doesi t
21:50:23 <Adnauseam> geekosaur: yea linux
21:50:32 <Adnauseam> ubuntu installs nice on it i hear
21:50:37 <M30W> Adnauseam: You gotta learn howt to type :)
21:50:38 <geekosaur> (the win8 on them is not so useful; a real desktop win8 is yet to be released, IIRC)
21:50:46 <Adnauseam> M30W: no
21:50:50 * M30W tooo this laptop is huge haha
21:50:55 <Adnauseam> s/no/on
21:51:28 <lispy> someone have some fun with unicode I want to test my urxvt configuration :)
21:51:31 <Adnauseam> geekosaur: dunno man. i kind of am still burned from vista.
21:51:39 <M30W> lolcathost: where does that t come from? But nice nick man ^_^
21:51:43 <M30W> D:
21:51:58 <geekosaur> win7's not bed; if MS had kept vista as a beta and made win7 the release, they'd have done pretty good
21:52:09 <M30W> lolcathost: where does that t come from? But nice nick man ^_^
21:52:11 <Adnauseam> geekosaur: from what i hear though you can setup win8 to look and act like win7
21:52:30 <lolcathost> M30W: ty
21:52:46 <geekosaur> the one on the tablets they're currently pushing is a cut down tablet OS; I'm under the impression it can't be set up to be a full windows environment
21:53:01 <M30W> localhost -> lolcahost Magic t!
21:53:08 <Adnauseam> that's true. i really don't know what they're doing though.. all this UI experimentation really annoys me. :/
21:54:08 <M30W> MS-win is painful enough said; stick with linux/bsd/unix
21:54:08 <M30W> :D
21:54:41 <roconnor> I whish ShowS was a newtype so it could be a Monoid
21:54:42 <geekosaur> they're trying to come up with a common UI to use across phones, tablets, and desktops.  just like ubuntu is with unity and apple is with recent iOS and OS X changes
21:54:42 <Adnauseam> geekosaur: it'll probably be something of a windows\xbox hybrid. tablets aren't usually full blown PCs though
21:54:45 <jdavis> What does GHCI use for interpreting? Is there a reason I can't use a similar strategy to GHCI to embed a haskell scripting language in my application?
21:55:05 <M30W> geekosaur: heard of sailfish?
21:55:15 <geekosaur> jdavis, as I said, it uses the GHC API.  it's a very complex and powerful API, which means it's somewhat difficult to work with
21:55:20 <M30W> Their UI is probally gonna make android, ios and msphone die out quickly.
21:55:22 <lispy> jdavis: look at hint
21:55:27 <jdavis> geekosaur: Oh, ok.
21:55:36 <lispy> ?hackage hint
21:55:37 <lambdabot> http://hackage.haskell.org/package/hint
21:55:41 <shachaf> roconnor: Endo has the right instance, at least.
21:55:45 <jdavis> Yes, looking now, thank you.
21:56:00 * elliott wonders what strange definition of die, out or quickly that is. or probably.
21:56:01 <lispy> jdavis: also, checkout how lambdabot solves the problem
21:56:04 <geekosaur> hint is a wrapper for it that exposes useful parts for the kind of thing you want to do; there is for example an xmonad package which uses it to allow evaluation of strings similarly to ghci
21:56:20 <jdavis> lispy: oh, heh, good idea.
21:56:21 <lispy> jdavis: the difference with lambdabot is that the host application wouldn't be able to interface with the 'scripts'
21:56:34 <lispy> I don't know if that matters for you
21:56:49 <roconnor> @info Endo
21:56:50 <lambdabot> Endo
21:56:51 <geekosaur> lambdabot uses mueval, IIRC, which is like hint with sandboxing
21:57:12 <roconnor> I hate @info
21:57:18 <shachaf> roconnor: @info doesn't exist
21:57:19 <Adnauseam> geekosaur: yeah ubuntu gets/used to get a lot of heat because of that. the one thing they did get right though is unity's search and making system tools sort of jump at you when you open the menues. that made the transition a bit easier. i hope ms gets it right soon. it's terrible atm
21:57:44 <jdavis> geekosaur: OK. So hint is totally unrestricted, but mueval is sandboxed?
21:58:10 <geekosaur> essentially.  you can sandbox hint but you have to delve into the ghc api to do it; that's more or less what mueval does
21:58:38 <jdavis> OK. Both may be useful to me. Thank you.
22:08:36 <shachaf> roconnor: Why foldMap with Endo rather than foldr with (.)?
22:10:16 <roconnor> shachaf: so I can write foldMap instead of a fold of a map
22:10:22 <shachaf> @ty ala Endo foldMap
22:10:24 <lambdabot> Foldable t => t (a -> a) -> a -> a
22:10:35 <roconnor> where is ala?
22:10:40 <shachaf> Control.Lens
22:10:49 <shachaf> (A different version is in Control.Newtype)
22:10:51 <roconnor> well, I should stick to Base for the comment
22:10:58 <shachaf> Sure.
22:11:05 <roconnor> shachaf is talking about  http://www.reddit.com/r/programming/comments/15n8zb/richard_wm_jones_my_rant_about_haskell/c7o4vit?context=3
22:11:07 <shachaf> Though I'm not sure what the point of the comment is.
22:12:20 <roconnor> shachaf: partly that haskell works better (in my opinion) when you actually handle error cases properly (which is why we have tight data types) rather than glossing over errors.
22:12:34 <roconnor> shachaf: partly because I like the applicative style of the IO in main
22:12:49 <shachaf> Fair enough.
22:12:57 <roconnor> shachaf: but mostly because it is past midnight and I'm not longer being reasonable.
22:12:58 <aavogt> should there be cases where ghc can't infer types with (a = ...;  b = ...), but it can if I comment out 'a' or 'b'?
22:13:01 <shachaf> Approximately half that code is read/show boilerplate.
22:13:13 <roconnor> shachaf: oh and partly cause I got to use a pattern guard.
22:13:33 <lispy> oh, someone on reddit has an ignorant opinion? how original
22:13:46 <shachaf> As long as the goal of that isn't to convince the person that Haskell code is easy to understand. :-)
22:14:22 <Nereid> @ty fold
22:14:24 <lambdabot> (Foldable t, Monoid m) => t m -> m
22:14:33 <shachaf> lispy: I know, man. That "roconnor" person just overengineers everything.
22:14:46 <roconnor> shachaf: maybe my goal was to reassure him that his dismissal of Haskell was correct.  My motives are questionable at this hour.
22:15:27 <lispy> shachaf: I meant 'dlachausse'
22:15:35 <lispy> shachaf: (but you probably knew that)
22:16:41 <roconnor> shachaf: one funny thing was that I was upset that ingolemo's code wouldn't give an error message about a bad operator until after it asked to get the 2 numbers.
22:17:08 <roconnor> shachaf: I thought, "the imperative programmers have got us there."
22:17:45 <shachaf> !op <- getOperator
22:17:46 <roconnor> shachaf: but dlachausse's C++ does the same thing!!
22:18:39 <shachaf> Oh, there's a big thread there.
22:18:50 <hpaste> “Jonathan Fischoff” pasted “AD issue” at http://hpaste.org/79973
22:18:59 <jfischoff> edwardk: I'm getting different values from grad . mag . grad f with AD and what I did manually with mathematica. I'm pretty sure the mathematica stuff is right. paste here ^
22:19:30 <jfischoff> I guess it could be a typo
22:19:46 <jfischoff> can you think of any other reason it wouldn't work?
22:21:25 <rwbarton> didn't you want the squared magnitude?
22:21:33 <rwbarton> oh that's what "mag" is, okay
22:22:35 <jfischoff> so the testObj and testObj2 seem to produce the same output
22:23:01 <jfischoff> but when I take the grad of testObj that doesn't work out well
22:23:32 <jfischoff> as opposed to the manually transcribe grad of testObj2
22:23:36 <roconnor> shachaf: I think I also partly wanted to show that using ShowS leads to code that is a little absurd.
22:24:22 <roconnor> @src ala
22:24:23 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
22:25:04 <roconnor> @type ala
22:25:06 <lambdabot> Wrapped s s a a => (s -> a) -> ((s -> a) -> e -> a) -> e -> s
22:25:29 <roconnor> shachaf: why is ala based on Wrapped instead of Iso?
22:25:36 <Nereid> because that's the wrong ala
22:25:41 <shachaf> No.
22:25:44 <shachaf> That's the lens ala.
22:25:47 <Nereid> it is?
22:25:56 <elliott> roconnor: for convenience :(
22:26:01 <shachaf> roconnor: It's because edwardk didn't want to make hundreds of isos.
22:26:03 <elliott> it used to just be "ala _sum" or "ala myIso" and everything was great
22:26:07 <roconnor> is Wrapped a standard Class?
22:26:13 <elliott> but it'd be "ala (wrapped Sum)" which is long so now it's "ala Sum"
22:26:15 <shachaf> Wrapped is a class for newtype isos.
22:26:16 <elliott> but you have to do "au myIso"
22:26:21 <elliott> ala = au . wrapped or whatever
22:26:26 <shachaf> class Wrapped s t a b | a -> s, b -> t, a t -> s, b s -> t where wrapped :: Iso s t a b
22:26:38 <Nereid> oh.
22:26:40 <Nereid> right.
22:26:42 <roconnor> shachaf: ah I see
22:26:44 <shachaf> @ty au (wrapping Sum) foldMap
22:26:46 <lambdabot> (Num t, Foldable t1) => t1 t -> t
22:26:48 <roconnor> shachaf: that's pretty good then.
22:26:52 <shachaf> @ty au (wrapping Endo) foldMap
22:26:53 <Nereid> when did this change.
22:26:54 <lambdabot> Foldable t => t (a -> a) -> a -> a
22:27:04 <shachaf> roconnor: It's not that great.
22:27:07 * shachaf isn't a fan of Wrapped.
22:27:14 <shachaf> Still, you can get an Iso
22:27:17 <shachaf> @ty wrapping Endo
22:27:19 <lambdabot> (Functor f, Isomorphic k) => k (Endo a -> f (Endo a)) ((a -> a) -> f (a -> a))
22:27:34 * shachaf shudders at the nonprofunctor Isomorphic
22:27:35 <tuttlem> Hi all
22:27:35 <Nereid> the (s -> a) argument is ignored and just used for the type, right.
22:27:39 <Nereid> haha
22:27:42 <shachaf> Yep.
22:27:45 <Nereid> hurry up and get 3.8 out.
22:28:01 <Nereid> pro lenses.
22:28:08 <shachaf> Nereid: I bet you feel like fixing the space leak.
22:28:12 <shachaf> Or maybe roconnor does?
22:28:36 <Nereid> what space leak?
22:28:41 <tuttlem> I've got code here that uses HUnit and QuickCheck. Is that "correct" ? or am I just supposed to stick with 1 of them?
22:28:52 <roconnor> tuttlem: that's fine
22:29:01 <roconnor> tuttlem: use QuickCheck where you can and HUnit where you must
22:29:06 <shachaf> Here we are:
22:29:11 <shachaf> foo xs = evalState (traverse (\d -> do { _ <- get; return d }) xs) ()
22:29:14 <shachaf> foo xs = evalState (traverse (\d -> do { !_ <- get; return d }) xs) ()
22:29:18 <shachaf> The second one leaks.
22:29:20 <shachaf> Makes sense, right?
22:29:25 <Nereid> what
22:29:37 <tuttlem> roconnor: awesome, thanks. I'll need to read up on QuickCheck though. I've been smashing all my tests against HUnit -- refactor time!
22:30:22 <Nereid> :t traverse return
22:30:24 <lambdabot> (Monad f, Applicative f, Traversable t) => t b -> f (t b)
22:30:43 <shachaf> Nereid: The idea is: We have a list and a traversal.
22:30:48 <shachaf> We want to put the list into the traversal.
22:31:17 <shachaf> > partsOf (both.traverse) .~ "HELLO THERE" $ ("just","some text")
22:31:20 <lambdabot>   ("HELL","O THERExt")
22:31:24 <shachaf> Hrm.
22:31:35 <Nereid> sure.
22:31:42 <shachaf> Anyway, using State to do it leaks.
22:31:58 <Nereid> why.
22:32:03 <Nereid> and whose responsibility is it.
22:32:05 <shachaf> Even (partsOf foo .~ []) leaks.
22:32:09 <shachaf> Nereid: Yours, I'm afraid.
22:32:13 <Nereid> :(
22:32:30 <Nereid> :t \xs -> evalState (traverse (\d -> do { !_ <- get; return d }) xs) ()
22:32:32 <lambdabot> Traversable t => t b -> t b
22:32:48 <shachaf> Nereid: The actual state here isn't (), it's the list of things you're putting in the traversal.
22:33:07 <Nereid> sure.
22:33:08 <shachaf> But the issue is that when you force the state while traversing, the list is kept around.
22:33:17 <Nereid> hmm
22:34:06 <Nereid> that seems to be expected.
22:34:10 <shachaf> Sure.
22:34:15 <shachaf> But what do you do about it?
22:35:18 <Nereid> this is what we're trying to figure out?
22:37:33 <shachaf> Yep.
22:38:49 <shachaf> We want the "put a list into a traversal" thing without the "using lots of memory" thing.
22:39:19 <c_wraith> that sounds impossible.  you should give up trying forever.
22:40:05 <shachaf> thanks c_wraith
22:41:01 <Rileld> I find that I'm repeating the same imports at the top of all the files in my project. Is there a way to put that info in the .cabal file?
22:42:06 <shachaf> Not really.
22:42:14 <shachaf> You can use #include, though.
22:42:19 <shachaf> Kind of ugly.
22:42:24 <aavogt> if you don't care what the module names are (ie. you don't use any qualified names), you can write one module that re-exports everything
22:42:38 <shachaf> Unfortunately qualified names usually matter.
22:43:03 <aavogt>  module Everything (module A, module B, module C) where import A; import B; import C
22:43:59 <aavogt> just write a template haskell macro that re-defines values so they fake qualified names
22:44:11 <aavogt> err, defines the fake qualified names
22:44:12 <Rileld> aavogt: what do you do once you have the Everything module?
22:44:23 <aavogt> you import Everything in all your files
22:44:59 <Rileld> and what's the #include?
22:45:01 <shachaf> module Everything (module Hi) where import A as Hi; import B as Hi; import C as Hi
22:45:20 <aavogt> worse suggestion is to name your Everything module Prelude and there's probably a ghc extension to get it to use that
22:45:38 <c_wraith> you don't even need an extension
22:45:56 <c_wraith> If your project has a module named Prelude, it'll be used in place of the library one.
22:47:21 <Rileld> Googling seems to say that #include is for C files with FFI. Was that a serious suggestion and I'm missing something?
22:47:39 <shachaf> It works for Haskell files too.
22:47:50 <latro`a> you mean in the cabal file, yes?
22:47:53 <shachaf> But it's kind of ugly and I don't really recommend it.
22:48:01 * hackagebot sym 0.4 - Permutations, patterns, and statistics  http://hackage.haskell.org/package/sym-0.4 (AndersClaesson)
22:48:03 * hackagebot file-embed 0.0.4.7 - Use Template Haskell to embed file contents directly.  http://hackage.haskell.org/package/file-embed-0.0.4.7 (MichaelSnoyman)
22:48:19 <aavogt> needs a {-# LANGUAGE CPP #-}
22:48:26 <latro`a> oh, nvm
22:59:15 <Rileld> Ok, the Everything is kinda working. What's wrong with making a Prelude? The qualified imports would work then, right?
22:59:42 <shachaf> No.
22:59:49 <shachaf> Import qualification is per-module.
23:00:02 <Rileld> :(
23:35:52 <jdavis> I'm trying out Hint (Language.Haskell.Interpreter). However, it says in the docs for runInterpreter that ghc will overwrite signal handlers. Unfortunately, that's unacceptable for my use case. Does someone have a suggestion how I can interact with the GHC libraries to change that so I can control the signal handlers myself (or just leave them alone)?
23:36:25 <jdavis> I would be interested in pursuing a patch to hint to resolve that.
23:40:55 <aavogt> jdavis: it won't work to re-install the same handlers afterwards?
23:41:30 <jdavis> aavogt: that might be a short-term solution to mitigate the problem, but it really is unsafe for my purposes.
23:43:15 <jdavis> I was planning to run haskell from a daemon that needs to stay running.
23:43:43 <shachaf> The daemon could spawn a process to run the Haskell code.
23:44:00 <jdavis> Although it might be OK to overwrite SIGINT and SIGHUP, I don't think it's OK to overwrite SIGTERM or SIGQUIT.
23:44:19 <jdavis> shachaf: yes, that occurred to me. Not ideal though.
23:46:50 <jdavis> Actually, I don't think even SIGHUP is OK. I'm still puzzling through what to do about SIGINT, but I think the other three need to keep their handlers during haskell execution.
23:48:34 <lispy> jdavis: two thoughts: a) It's probably ghc's RTS that actually overwrites the signal handlers and not hint. b) what about a wrapper around this process that handles/translates the signals instead of the haskell process? (eg., if you really need to kill it translate to kill -9, if you need to ignore it have the wrapper do so)
23:49:54 <shachaf> Sounds fragile.
23:50:35 <jdavis> lispy: I was going to start hacking together a PL/haskell for postgres. I don't think translating the signals is something I can do while maintaining safety and without changing the way postgres works.
23:51:15 <lispy> jdavis: hmm...
23:51:47 <jdavis> Does the RTS really need to use signals in that way?
23:52:14 <jdavis> Or is it just intended for interactive use, e.g. GHCI?
23:52:31 <lispy> jdavis: probably. I don't know if GHC does GC this way, but some languages wait until the program tries to use memory it doesn't have, trapping the signal for that, and then handle it
23:52:39 <shachaf> For questions about GHC internals #ghc might know more (though it's usually pretty quiet).
23:53:19 <jdavis> OK. I'll probably ask on haskell-cafe, as a mailing list might be a better format for discussing this kind of thing (e.g. long responses).
23:54:01 <jdavis> This is still very much an exploratory thing. At this point I'm mostly doing it to learn haskell.
23:54:28 <lispy> jdavis: honestly, I'd try to get it working and make note of the infelicitise like this
23:54:41 <wereHamster> when using FRP in a game, how would I model adding/removing objects from the world? Would that be a signal?
23:54:41 <lispy> jdavis: then when you get done, look at those problems, rank them and try to solve them proper
23:54:56 <jdavis> lispy: yeah, that's my plan. No rush at all.
23:55:14 <wereHamster> all examples I've seen so far only deal with signals generated by existing objects (mouse position etc)
23:55:22 <jdavis> lispy: But I thought: hey, if this is a weakness in this library, maybe I can fix it and learn something along the way.
23:55:30 * lispy nods
23:56:09 <lispy> wereHamster: the last time I had an FRP question I asked on stack overflow and made sure that the author of reactive-banana saw my question. I got a high quality answer for my effort.
23:57:26 <wereHamster> lispy: thanks.
