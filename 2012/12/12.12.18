00:00:17 <archeyDevil> JoeyA: 985 :P
00:01:21 <neutrino> `nand`: hey, are you around?
00:01:26 <neutrino> mm_freak_: hi there
00:04:20 <mm_freak_> neutrino: hi
00:04:42 <Ralith> orospakr: I understand that that feature is Coming Soon
00:04:53 <earthy> and has been Coming Soon for a while
00:05:49 <neutrino> mm_freak_: hey, you want to talk about applicative again? just woke up :)
00:06:15 <neutrino> orospakr: i think that's coming in 7.6 at some point. it's fairly big news.
00:06:28 <neutrino> well in 7.6.*
00:06:42 <neutrino> it's sorta there, but still buggy.
00:06:58 <edwardk> stepcut: around?
00:07:18 <mm_freak_> neutrino: well, you wanted to implement Functor and Applicative for Stream =)
00:07:31 <mm_freak_> go ahead =)
00:07:40 <stepcut> edwardk: yup. Practicing contortion and watching ST:TNG.
00:07:50 <neutrino> right
00:07:55 <edwardk> stepcut: http://hpaste.org/79421 its not very far along and the API will definitely clean u
00:07:57 <edwardk> er clean up
00:08:16 <neutrino> we had what.. data Stream a = Empty | a Stream ?
00:08:19 <neutrino> or something like that
00:08:22 * neutrino looks at the logs
00:08:24 <edwardk> stepcut but that gives me strongly typed ixsets
00:08:33 <edwardk> stepcut: no typeable crap
00:08:52 <mm_freak_> neutrino: data Stream a = Stream a (Stream a)
00:08:56 <neutrino> ahh
00:09:00 <neutrino> thanks, i was just about to find it
00:09:14 <mm_freak_> neutrino: or, if you will, data Stream a = Stream { head :: a, tail :: Stream a }
00:09:18 <neutrino> ok, but Stream a never ends?
00:09:21 <edwardk> i can also extend it to support supplemental indices that are hashmaps, etc.
00:09:22 <stepcut> edwardk: ixset totally sucks ass. The fact that there is nothing else that fills the same niche yet still boggles my mind. :)
00:09:25 <mm_freak_> neutrino: yeah
00:09:27 <neutrino> so it's not a valid type in Haskell?
00:09:28 <neutrino> right?
00:09:33 <mm_freak_> huh?
00:09:34 <edwardk> stepcut: hence my 10 minute project ;)
00:09:37 <mm_freak_> why wouldn't it be valid?
00:09:48 <neutrino> i thought you couldn't have such a type
00:09:54 <mm_freak_> you have such a type
00:09:57 <mm_freak_> []
00:10:06 <edwardk> the instance of Relational should be completely derivable
00:10:14 <neutrino> really? hmm interesting
00:10:15 <neutrino> ok
00:10:15 <mm_freak_> it's just that Stream doesn't have a Nil case
00:10:19 <stepcut> edwardk: I am 100% in favor of replacing ixset with something better. There have been several attempts to start something better, but no one has committed to actually releasing something for real :(
00:10:21 <edwardk> you may need to name the primary index column and any candidate keys or supplemental indices
00:10:25 <mm_freak_> data List a = Nil | Cons a (List a)
00:10:26 <neutrino> well yeah
00:10:33 <edwardk> stepcut: k, i'll fiddle with it a bit in the background
00:10:39 <edwardk> this is promising enough to continue with
00:10:43 <neutrino> that is what i mean, i thought you couldn't have a type which can never terminate
00:10:59 <mm_freak_> neutrino: it does terminate
00:11:11 <stepcut> edwardk: that would be awesome! I have absolutely zero attachment to ixset, and will celebrate the day we can recommend something else instead
00:11:37 <edwardk> i did at least get the primary key, and candidate keys working for lookup, and table scans for non-indexed columns
00:11:38 <mm_freak_> neutrino: suppose you have this stream:  ones = Stream 1 ones
00:11:53 <mm_freak_> and you pattern-match against it:  case ones of Stream x xs -> …
00:11:55 <mm_freak_> what's x?
00:12:01 <neutrino> 1
00:12:05 <mm_freak_> there, terminated
00:12:08 <mm_freak_> =)
00:12:11 <neutrino> hmm ok
00:12:14 <neutrino> because it's lazy?
00:12:27 <neutrino> and the tail doesn't actually get evaluated until it's requested?
00:12:29 <edwardk> i'm using lenses mostly to clean up the internals, they haven't popped up yet in the API
00:12:35 <mm_freak_> that's an implementation detail…  the reason is that the Stream constructor is nonstrict
00:12:49 <edwardk>   OtherIndex -> m^..prim.primaryMap.folded.filtered (\ row -> v == val col row) makes a lot of code go away
00:12:57 <mm_freak_> this one actually does not terminate:  data Stream a = Stream a !(Stream a)
00:13:27 <neutrino> ok, implementing pure seems simple: pure x = Stream x (pure x)
00:13:49 <sopvop> is it possible to declare class for rank 2 type with constraint to sub type, like   class (Monad m) => Foo (k m) where...
00:13:55 <mm_freak_> now the second argument to Stream is strict, so pattern-matching against the constructor depends on the constructor of the tail
00:14:05 <neutrino> mhm
00:14:09 <mm_freak_> since that one is strict as well, it depends on its tail and so on
00:14:22 <neutrino> yep
00:14:31 <neutrino> is my definition of pure correct?
00:14:53 <Enigmagic> sopvop: looks like a rank-1 type to me? just using multi-parameter type classes.. should work fine
00:14:55 <mm_freak_> neutrino: before i answer that, implement (<*>)
00:14:59 <neutrino> ok
00:15:41 <sopvop> multi parameter will need fds or type families, or not?
00:15:46 <neutrino> (<*>) func (Stream x tail) = Stream (func x) (func <*> tail)
00:16:10 <Enigmagic> sopvop: that's just using multiparameter type classes. you're not using functional dependencies or type families
00:16:30 <mm_freak_> neutrino: that's a type error…  type it into a source file and compile ;)
00:16:37 <mm_freak_> i.e. don't just guess
00:16:59 <mm_freak_> let me get you started:  Stream f fs <*> Stream x xs = ?
00:17:21 <stepcut> edwardk: there are a number of 'wishlist' improvements to (a replacement for) IxSet that I would love to see -- like support of autoincrement indexes, compound keys, etc, that I would love to see implemented. As far as I can tell, Haskell still does not have a great replacement for SQL tables yet (even if you ignore JOIN and friends). It seems like a very useful general purpose data-type and it is a bit perplexing that we don't have a 
00:17:21 <stepcut>  answer yet.
00:18:01 <neutrino> ok, i will
00:18:16 <neutrino> i wanted to imagine how that would work, rather than rely on the compiler for me
00:18:24 <edwardk> stepcut: yeah, right now i figured i'd get started with just banging out something simple with primary keys, and candidate and supplemental keys, and show how to extend it, then see if others are interested in continuing.
00:18:39 <neutrino> @type (<*>)
00:18:41 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
00:18:43 <mm_freak_> neutrino: the compiler will reject wrong implementations =)
00:18:51 <neutrino> sure
00:19:21 <mm_freak_> (although it will accept some partial versions)
00:19:21 <sopvop> Enigmagic: It works! Thanks
00:19:38 <stepcut> edwardk: awesome! The most recent  IxSet replacement that I am aware of is here, https://github.com/Palmik/data-store
00:20:06 <edwardk> k
00:20:29 <edwardk> i'll probably fiddle with this to see if i can do something with indexable fields that can be used directly as lenses
00:20:34 <stepcut> edwardk: it attempts to address some of the wishlist stuff.. but it also seems more complex than required somehow.. though I have not looked at it too closely
00:20:46 <stepcut> edwardk: that would be swell!
00:20:56 <neutrino> there is no type error mm_freak_
00:21:11 <sopvop> I'm sure module will be called "db"
00:21:11 <edwardk> my first goal was to check that i could sanely implement it using tabulation and that the lenses would help the general lookup by index type
00:21:14 <edwardk> that much seems to work
00:21:14 <sopvop> package
00:21:44 <stepcut> edwardk: nice!
00:21:47 <mm_freak_> neutrino: huh?  the code you showed is clearly a type error
00:21:56 <neutrino> what is the error?
00:22:09 <mm_freak_> is there an IxSet replacement that is completely static?
00:22:21 <mm_freak_> the typeable stuff is really annoying
00:22:35 <edwardk> stepcut: this approach already includes compound key support, btw ;)
00:22:48 <edwardk> mm_freak_: thats part of what im toyin with
00:22:54 <hpaste> neutrino pasted “no error here” at http://hpaste.org/79423
00:22:59 <mm_freak_> edwardk: successfully?
00:23:05 <edwardk> its nowhere near done (barely started) but it does lookups sanely
00:23:11 <edwardk> and i can see how to proceed
00:23:30 <mm_freak_> neutrino: if that's the full code, you're not defining an applicative instance
00:23:31 <edwardk> mm_freak_: http://hpaste.org/79421
00:23:38 <neutrino> nope
00:23:39 <stepcut> mm_freak_: not yet. But mostly due to lack of effort. And, yes, IxSet sucks. I've been wanting something better for a long time.. but IxSet is 'good enough' that it has never been the most important thing for *me* to work on
00:23:53 <neutrino> mm_freak_: oh, do you mean it's just the wrong error for Applicative?
00:24:07 <mm_freak_> neutrino: instance Applicative Stream where …
00:24:14 <neutrino> yeah
00:24:20 <mm_freak_> you're just defining your own top-level function (<*>) there =)
00:24:21 <neutrino> but i don't have all the methods defined
00:24:35 <neutrino> let me first use the type for (<*>) that is known
00:24:45 <edwardk> i'd like to have multiple table support via lenses into a common state with foreign keys
00:24:52 <stepcut> edwardk: me too :)
00:25:04 <edwardk> i can see how to get there with this at least
00:25:21 <stepcut> edwardk: \o/
00:25:49 <edwardk> i also have the rest of the year off to hack on things
00:25:55 <neutrino> ok, i see now
00:25:56 <edwardk> so it may even get done ;)
00:25:58 <neutrino> hmm
00:26:05 <mm_freak_> edwardk: if that ever turns into a real library, i'd love to know =)
00:26:20 <neutrino> Couldn't match type `Stream' with `(->) a'
00:26:27 <neutrino> let me think about it for a sec
00:26:28 <stepcut> edwardk: there are two issues that are really getting in the way of greater adoption of acid-state (1) ixset is kind of lame (2) we don't have a great answer to what to do when you run out of RAM
00:26:36 <mm_freak_> neutrino: yeah…  look at how i started the definition
00:26:51 <mm_freak_> neutrino: instance Applicative Stream where Stream f fs <*> Stream x xs = …
00:26:54 <NoICE> hi guys :)
00:27:28 <mm_freak_> if the first argument to (<*>) is a Stream (a -> b), then what's the type of 'f'?
00:27:32 <stepcut> edwardk: in polyglot systems there is (3) how do you access acid-state from other programming languages..
00:27:39 <edwardk> one nice thing here is that the lookup seems inherently fast. you do the lookup by primary key and you get your answer immediately. no real overhead compared to a map. if you do the lookup by secondary key it involves a secondary lookup in the primary key map
00:27:58 <neutrino> mm_freak_: yeah i figured out that part myself :) in another window right now
00:28:03 <edwardk> i may restructure things to link to the actual value rather than the primary key value in the secondary keys to save lookups
00:28:11 <stepcut> edwardk: whatever you are doing.. it can't be worse than ixset..
00:28:27 <edwardk> since we're entirely in memory the secondary keys storing just the key info doesn't save any storage
00:28:45 <edwardk> basically i take a data type describing all of the keys
00:29:01 <edwardk>   data Column (Foo a) k b where    FooId  :: Column (Foo a) Primary Int;    FooBar :: Column (Foo a) Other   a;    FooBaz :: Column (Foo a) (Secondary NonUnique) Double
00:29:47 <edwardk> that describes the types of each column, and whether its a primary, candidate, supplemental or something that just needs a table scan
00:29:59 <hpaste> neutrino pasted “not visible” at http://hpaste.org/79426
00:30:12 <neutrino> sorry what does this mean? i've never written my own instances yet
00:30:19 <neutrino> probably doing something silly
00:30:33 <fmap> neutrino: Applicative(..)
00:30:34 <dmwit> neutrino: import (<*>)
00:30:48 <edwardk> for each one of the Column's which aren't really columns, more 'searchable composite fields', since they aren't required to be disjoint, i have a few combinators for tabulating with them
00:30:59 <edwardk> e.g. for that:   data Meta (Foo a) f = MetaFoo (f Primary Int) (f Other a) (f (Secondary NonUnique) Double)
00:30:59 <mm_freak_> neutrino: no, that's correct =)
00:31:07 <mm_freak_> neutrino: just a bit ugly =)
00:31:25 <mm_freak_> Stream f fs <*> Stream x xs = Stream (f x) (fs <*> xs)
00:31:34 <edwardk> that lets me make a data type that contains meta information about the primary key, does something different for the other key, and does yet something else different for the non-unique supplemental index on that double
00:31:57 <mm_freak_> neutrino: import Control.Applicative without an import list
00:32:00 <edwardk> then i tabulate: eachMeta f (MetaFoo x y z) = MetaFoo <$> f FooId x <*> f FooBar y <*> f FooBaz z
00:32:18 <sgk284> I suspect the answer is no, but is there any good way to have a function and a list of arguments to use as arguments to that function? Effectively, I'm looking for the lisp equivalent of 'apply'.
00:32:22 <sgk284> ideally, this would work: https://gist.github.com/49b1a5f61d36b78f9453
00:32:25 <stepcut> edwardk: oOo
00:32:33 <stepcut> edwardk: is there anything I can do to help?
00:32:39 <edwardk> so now i have enough information (with a couple other functions such as how to interpret each of those Columns) to generate the primary key, supplemental keys, etc.
00:32:39 <neutrino> ok now it tells me i need to add an instance of Functor
00:32:46 <sgk284> is the sanest way to handle this to simply have fn take a list instead of individual args?
00:33:02 <edwardk> stepcut: i can throw it up in a repository and set up a channel to chat about it/for buildbot spam
00:33:15 <stepcut> edwardk: great!
00:33:18 <neutrino> is it the one from Control.Monad?
00:33:23 <mm_freak_> neutrino: yes…  now be smart…  read the Applicative laws and write fmap in terms of 'pure' and (<*>)
00:33:43 <edwardk> i want to get a little farther along, as soon as i have the basic building blocks in place and it starts to grow beyond a single test module i'll put up the repo
00:33:48 <stepcut> edwardk: by channel.. do you mean irc? Or something else?
00:33:49 <edwardk> probably a couple hours at this rate
00:34:00 <edwardk> irc
00:34:03 <neutrino> mm_freak_: really? ok
00:34:12 <sddfme> by which factor does Data.Sequence take more space than a simple list, roughly?
00:34:13 <stepcut> edwardk: feel free to spam #happs for now
00:34:17 <edwardk> #haskell-tables or something
00:34:41 <edwardk> the issue with that is when i get github spamming it gets pretty noisy fast ;)
00:34:46 <mm_freak_> neutrino: well, Stream is an "applicative /functor/" =)
00:35:41 <hpaste> neutrino pasted “works” at http://hpaste.org/79427
00:35:45 <neutrino> ^
00:35:57 <stepcut> edwardk: that's how people will know something is happening. :p happs/happstack has history had the problem of too little communication, not too much
00:36:02 <Peaker> bah, GNU has dwarf extensions that need to be supported too
00:36:08 <mm_freak_> neutrino: correct
00:36:16 <neutrino> nice
00:36:21 <mm_freak_> neutrino: now, do you remember why i told you to do that?
00:36:26 <neutrino> Peaker: hey, are you writing a haskell decompiler?
00:36:26 <edwardk> heh. ok. ill set up the buildbot like i have it in #haskell-lens and point it to #happs when i get a chance
00:36:32 <neutrino> mm_freak_: not.. really
00:36:38 <stepcut> edwardk: sweet!
00:36:42 <Peaker> neutrino, nope, I'm writing a high-level dwarf parser
00:36:52 <Peaker> neutrino, all the existing libs/etc give you very low-level information
00:36:59 <mm_freak_> neutrino: try to write a Monad instance
00:37:11 <Peaker> I want to extract a nice high-level ADT that has CompilationUnits that have Definitions that are Typedefs | Ptr | ...
00:37:18 <mm_freak_> neutrino: and yes, it's possible
00:37:27 <neutrino> hmm ok
00:37:28 <Peaker> then I will use that to auto-generate FFI bindings from debug info
00:38:23 <mm_freak_> neutrino: my conjecture is that your first two Monad instances will be fast, but incorrect =)
00:40:58 <neutrino> how do i inherit "fail" from default?
00:41:08 <neutrino> it's possible, right?
00:41:11 <mm_freak_> neutrino: ignore 'fail'
00:41:15 <mm_freak_> just don't write it
00:41:15 <neutrino> ok
00:42:06 <mm_freak_> neutrino: 'fail' is a hack to handle pattern match failures in do-notation…  it doesn't really belong into the Monad class
00:47:30 <johnw> luite: ping
00:48:07 <Ralith> Peaker: I'd just use libclang.
00:48:41 <Ralith> DWARF is ridiculously abstract and thus prone to imcompatibly subjective interpretations
00:48:46 <Ralith> incompatibly*
00:49:10 <hpaste> neutrino pasted “monad instance” at http://hpaste.org/79428
00:49:15 <Peaker> Ralith, I've successfully used DWARF for FFI in Python
00:49:21 <Peaker> Ralith, and gdb manages to work with Dwarf
00:49:26 <neutrino> mm_freak_: what do you think of this? :)
00:49:35 <Ralith> gdb manages to work because they cooperate very closely with the authors of gcc :P
00:49:35 <Peaker> Ralith, even if it is limited to gcc, it will still be useful to use gcc->dwarf->ffi source code
00:49:51 <Peaker> Ralith, I'm looking directly at the parsed dwarf now, it's not that hard to figure out
00:50:14 <Ralith> when the clang developers implemented DWARF output, they broke gdb in many places
00:50:17 <mm_freak_> neutrino: that's actually the correct Monad instance =)
00:50:18 <Enigmagic> Peaker: i spent a while looking at this earlier this year... i'd say to use clang's api (not libclang) instead of bothering with dwarf
00:50:22 <neutrino> mm_freak_: :)
00:50:23 <Peaker> Ralith, parsing source for FFI is a bad idea -- it's a different parse context than the one used by the .o you're building
00:50:25 <Ralith> they brought this up with the gdb people
00:50:29 <mm_freak_> neutrino: do you see the problem with it?
00:50:32 <neutrino> mm_freak_: what did you expect me to write?
00:50:38 <Ralith> their response: "Well, let us know if you work out what the right way to interpret that is."
00:50:49 <Ralith> so now they just try to imitate gcc.
00:50:58 <mm_freak_> neutrino: wait, no
00:51:05 <mm_freak_> neutrino: it's not correct
00:51:07 <Peaker> Enigmagic, but then the FFI code won't be binary compatible with whatever context you might be cross-compiling to. Also, you may not have the source you want to FFI with
00:51:09 <neutrino> ok :)
00:51:27 <Peaker> Enigmagic, it's nice to be able to FFI into objects that just have dwarf
00:51:34 <mm_freak_> neutrino: a correct Monad instance doesn't ignore anything
00:51:37 <Peaker> also, I'm 80% done with this project :)
00:51:45 <Ralith> Peaker: one might as well say that parsing the .o is bad--it's a different context than the one used by the .so you might later link.
00:51:47 <Enigmagic> Peaker: i thought clang could cross compile?
00:52:00 <neutrino> mm_freak_: what does this instance ignore?
00:52:15 <mm_freak_> neutrino: the tail of 'action x'
00:52:20 <Ralith> Enigmagic: libclang is the relevant part of clang's API, except in C and substantially more stable.
00:52:23 <neutrino> mm yeah
00:52:27 <Enigmagic> Peaker: the added benefit of using clang is making a quasiquoter that can inline c/c++ into haskell :-)
00:53:08 <mm_freak_> neutrino: you can verify your implementation by checking that liftA2 = liftM2
00:53:43 <neutrino> :O
00:53:43 <Enigmagic> Ralith: it was missing a number of relevant features when i was looking at it, couldn't do it with libclang alone. could have changed, it's been almost a year since i looked
00:53:43 <Ralith> Peaker: from the perspective of the header, you are no different than a native C compiler; "parse context" is irrelevant insofar as that the header is not broken.
00:53:47 <Peaker> Enigmagic, even if clang can cross-compile, how can you guarantee that you're compiling the FFI with the same preprocessor settings/etc as you built the object you're linking against?
00:54:01 <Peaker> Ralith, you can parse the .so directly
00:54:01 <Ralith> Enigmagic: perhaps you simply didn't see them; this sort of thing is what libclang is *for*.
00:54:08 <mm_freak_> neutrino: write an enumFromS function:  enumFromS :: (Enum a) => a -> Stream a
00:54:23 <Ralith> Peaker: irrelevant
00:54:24 <neutrino> what for?
00:54:28 <Peaker> Ralith, parsing sources also requires more configuration
00:54:32 <mm_freak_> neutrino: enumFromS 5 should produce the stream 5, 6, 7, 8, …
00:54:38 <Enigmagic> Ralith: could be, haven't worked with clang much but i did spend a few days dicking around with it for this very purpose
00:54:41 <Peaker> Ralith, it's much easier to say: "make FFI from this executable"
00:54:45 <mm_freak_> neutrino: using it you can verify the correctness of your implementation
00:54:50 <neutrino> ok let me try
00:54:53 <Peaker> Ralith, than "make FFI from this source tree, with this preprocessor context, with ..."
00:55:09 <Ralith> Enigmagic: unfortunately, the documentation is pretty crap; it'd be no surprise if in that time you simply didn't stumble into the right stuff.
00:55:34 <Enigmagic> Ralith: the regular clang api was pretty clear where to find everything i was looking for
00:55:35 <mm_freak_> neutrino: for your convenience also write:  takeS :: Int -> Stream a -> [a]
00:55:45 <Peaker> Enigmagic, I've worked on this for only a couple of days and already I have all the information that I need for FFI.. I think clang is more difficult both for the development and for use later
00:55:48 <mm_freak_> then you can print a prefix of the stream easily
00:55:55 <mm_freak_> print . take 10
00:56:11 <mm_freak_> uhm
00:56:13 <mm_freak_> print . takeS 10
00:56:30 <Ralith> Enigmagic: wouldn't be shocked--the problem is then you have to call out to C++, and deal with the utter lack of stability guarantees.
00:56:31 <neutrino> ok
00:56:33 <neutrino> let me try
00:56:50 <Ralith> so it's probably worth finding the right bits of libclang for production use
00:57:09 <Enigmagic> Peaker: ok, i found that most dwarf was too low level wrt typedefs and things of the sort to do a good job, though it would probably get you something that worked
00:57:26 <Peaker> Enigmagic, that's exactly why I just implemented dwarfadt -- that gives me high-level info
00:58:12 <Enigmagic> Peaker: what does it do?
00:58:52 <Peaker> Enigmagic, you give it any ELF with DWARF in it
00:59:01 <Peaker> Enigmagic, it gives you a high-level ADT of the debug info in there
00:59:22 <Peaker> You get this: https://github.com/Peaker/dwarfadt/blob/master/src/Data/Dwarf/ADT.hs
00:59:25 <Enigmagic> i just found that often times useful information from the source was not ending up in the dwarf
00:59:56 <Peaker> https://github.com/Peaker/dwarfadt/blob/master/src/Data/Dwarf/ADT.hs#L455 --> https://github.com/Peaker/dwarfadt/blob/master/src/Data/Dwarf/ADT.hs#L411
00:59:59 <Peaker> Enigmagic, like what?
01:00:17 <Ralith> another fun phenomenon is how critical bits of the DWARF tend to be absent or, worse, inaccurate when any optimization is applied
01:01:16 <Enigmagic> Peaker: typedefs mostly, but some other information was missing too with both gcc and clang. clang's api worked ok though.
01:02:02 <hpaste> neutrino pasted “enums” at http://hpaste.org/79429
01:02:21 <Ralith> with clang you can also often wrap macros
01:02:28 <neutrino> those should be correct implementations of the enum mm_freak_
01:03:01 <mm_freak_> neutrino: yeah, they are correct
01:03:31 <mm_freak_> neutrino: now try this:  print . takeS 10 $ liftA2 (,) (enumFromS 1) (enumFromS 'a')
01:03:40 <mm_freak_> it should output this:
01:03:53 <mm_freak_> > zip [1..10] ['a'..]
01:03:54 <lambdabot>   [(1,'a'),(2,'b'),(3,'c'),(4,'d'),(5,'e'),(6,'f'),(7,'g'),(8,'h'),(9,'i'),(1...
01:03:59 <johnw> aristid: ping
01:04:05 <sddfme> I read this SO answer http://stackoverflow.com/questions/9611904/haskell-lists-arrays-vectors-sequences which says "Data.Sequence it is less lazy than lists". what does this exactly mean, could you give an example where is it lazy and where is it strict?
01:04:26 <Peaker> Ralith, the idea here is that you can build your C thing - and you want to make a binding. It's easier to build with -g and -O0
01:04:41 <Peaker> Ralith, than it is to configure clang or what not to read the sources with the correct -D options/etc
01:04:52 <mm_freak_> sddfme: the structure of a Seq lives in memory all the time, whereas lists can take O(1) memory
01:05:11 <Peaker> Ralith, also, you might have a closed-source .so file with debug info that you want to call from Haskell
01:05:11 <Ralith> Peaker: I disagree.
01:05:17 <mm_freak_> sddfme: that's also why you can't have infinite Seqs
01:05:19 <Enigmagic> Peaker: think about how a regular C/C++ app would use the library. either they're using pkgconfig or something to get flags or it just needs to be #include'd
01:05:40 <Ralith> Peaker: closed source libraries are necessarily distributed with headers.
01:05:49 <Peaker> Enigmagic, the user now needs to figure out which and somehow pass that knowledge to the parser
01:05:51 <neutrino> ok i see how the instance is incorrect
01:05:58 <neutrino> now how to fix it? hmm.
01:05:59 <sddfme> mm_freak_: ok, and where would it be lazy for example?
01:06:05 <neutrino> let me think about it.
01:06:11 <Peaker> Ralith, Not necessarily, actually
01:06:15 <Enigmagic> Peaker: but they know how to build the app with various flags?
01:06:21 <mm_freak_> neutrino: the liftA2 variant should give the desired result, but the liftM2 variant doesn't
01:06:24 <Peaker> Ralith, you might have a .so with closed-source stuff linked against it
01:06:33 <Peaker> Enigmagic, they have some makefile or arcane build system
01:06:38 <Ralith> yes necessarily, if they expect to accomplish anything to be accomplished by distributing it.
01:06:41 <neutrino> yes mm_freak_
01:06:42 <mm_freak_> sddfme: seqs are only strict in structure, not in the elements
01:06:51 <mm_freak_> sddfme: so you can have a seq of undefined values
01:06:53 <Peaker> Ralith, Why? I distribute foo.so, and a bunch of executables that use it
01:06:59 <Peaker> Ralith, I accomplished distribution of working software
01:07:01 <Ralith> a C programmer does not use the package's "arcane build system" when including headers from that package.
01:07:14 <Ralith> that is not a library distributed for reuse.
01:07:21 <Ralith> are you building a reverse-engineering toolkit?
01:07:27 <Enigmagic> Peaker: so they can modify some arcane build system but not tell the parser what flags to use?
01:07:41 <Peaker> Ralith, I'm building an FFI engine that will handle this case happily
01:07:55 <Ralith> assuming they built with all optimizations explicitly disabled.
01:08:04 <Ralith> and used gcc.
01:08:08 <Ralith> and didn't strip.
01:08:11 <johnw> can I get --haddock-hoogle to insert @depends and @url lines, like the Hoogle files that get downloaded by the hoogle command?
01:08:16 <Peaker> Enigmagic, -g is a common option, you would typically not need to modify it. Also, adding a CFLAGS option is easier than figuring out the CC options required for binary compatibility when cross compiles are involved
01:08:40 <Peaker> Ralith, not to mention DWARF is probably easier to work with in practice (took me a couple days now) than clang on sources
01:08:51 <Ralith> well, you seem very attached to your current approach regardless
01:08:52 <Ralith> have fun
01:08:53 <aristid> johnw: pong?
01:08:57 <Enigmagic> Peaker: well i wish you luck, i wouldn't do it that way
01:09:22 <mm_freak_> neutrino: let me give you a hint:  diagonalization
01:09:38 <johnw> aristid: I had an aws idea I wanted to run past you before coding it
01:09:52 <Peaker> Ralith, it was a lot of fun in Python, easiest FFI I've ever done
01:10:00 <sddfme> mm_freak_: ah! so although a Seq lives in memory all the time, it does not take that much extra memory compared with a list, because what lies in memory might be a lot of (small I guess) not yet evaluated objects?
01:10:09 <Peaker> Now I'm frustrated with doing FFI in the (current) Haskell way
01:11:02 <mm_freak_> sddfme: values, but yes
01:11:12 <beaky> hello haskellites
01:11:17 <sddfme> thanks =)
01:11:23 <aristid> johnw: do tell!:)
01:11:40 <johnw> I am thinking of adding a constructor to GetObject, goResponseContentRange :: Maybe (Int,Int) (where the integers are Offset and Length), where if present causes the HTTP Range parameter to be used to get only part of an object.  Further, if the Length integer is zero, it changes the actual request made into a HEAD request.  This would mean that there would be no gorResponse
01:11:40 <neutrino> mm_freak_: let me think about it
01:12:01 <Enigmagic> Peaker: i think the haskell ffi leaves a lot to be desired but i think to really improve it you want more detail than is available in the dwarf to properly make use of haksell's type system. just my 2c though.
01:12:29 <Peaker> Enigmagic, of course you're going to need to layer Haskell around the auto-ffi
01:12:46 <Enigmagic> Peaker: all the time or some of the time?
01:12:52 <johnw> or would you rather there be a separate HeadObject request type, whose HeadObjectResponse contains only a horMetadata?
01:12:53 <Peaker> Enigmagic, but you won't need to tediously insert "foreign" declarations, "struct" fields, etc, and debug horribly when you make am istake
01:13:07 <aristid> johnw: right, i think HEAD should be separate.
01:13:09 <Peaker> Enigmagic, you could just use it directly but it'd be no fun (e.g: output parameters)
01:13:16 <aristid> johnw: it's a different HTTP method after all
01:13:23 <Enigmagic> Peaker: right, that's an improvement but c2hs and other preprocessors do a lot of this already
01:13:27 <johnw> ok.  I think that in the HeadObject module there should be an existsObjec
01:13:27 <aristid> johnw: but definitely support for ranges is a good idea
01:13:35 <johnw> t helper method, which simply returns a BOol
01:14:10 <aristid> johnw: sounds good
01:14:17 <johnw> ok, colo
01:14:24 <johnw> i'm gonna start coding it now, since I need it :)
01:14:46 <aristid> johnw: ok. i don't, but i'm slowly preparing to be able to test aws with multiple versions of ghc :D
01:15:00 <Peaker> Enigmagic, I used c2hs, it doesn't do almost anything for you
01:15:18 <Peaker> Enigmagic, and it doesn't really support cross-compiles properly iiuc, though that's secondary
01:15:26 * hackagebot sym 0.3 - Permutations, patterns, and statistics  http://hackage.haskell.org/package/sym-0.3 (AndersClaesson)
01:15:42 <Peaker> Enigmagic, with c2hs you still have to make an error-prone listing of every function you call with the parameter lists. Of every struct field.  Every mistake is a cryptic runtime corruption.
01:17:00 <johnw> aristid: look for a pull request shortly :)
01:17:21 <johnw> so, i'll break this up into three features
01:17:29 <johnw> how do I do that on github, with separate feature branches?
01:17:57 <Ralith> johnw: that's the usual approach, I think.
01:18:03 <johnw> ok
01:18:21 <Enigmagic> Peaker: are we talking about the same c2hs? http://tommd.wordpress.com/2009/09/22/haskell-bindings-to-c-c2hs/
01:19:10 <Enigmagic> neither c2hs or hsc2hs is perfect
01:19:50 <Enigmagic> they can at least figure out where fields are located, but not the type. dwarf has similar issues.
01:19:51 <Peaker> Enigmagic, yeah.  Look at how it actually looks like eventually: https://github.com/Peaker/FreeTypeGL/blob/master/Graphics/Rendering/FreeTypeGL/Internal/Markup.hsc#L60
01:20:04 <Peaker> Enigmagic, that's false -- this information is very complete in DWARF
01:20:30 <Enigmagic> it will be the correct size in dwarf
01:20:57 <aristid> johnw: yeah multiple branches is probably the easiest way for me. but you can also do it all in one branch and i can cherry pick what i like :D
01:21:03 <Enigmagic> Peaker: here's something else to look at https://github.com/alphaHeavy/lzma-conduit/blob/master/src/Bindings/Lzma.hsc
01:21:14 <johnw> aristid: ok
01:21:14 <Enigmagic> also hsc2hs but using bindings-dsl
01:21:27 <neutrino> mm_freak_: i have no idea how to do it.
01:21:28 <Peaker> Enigmagic, I wrote cinvoke -- an FFI IPC bridge for Python<->C (a small C/asm FFI server, and a Python client).  The Python client used dwarf parsing to know exactly what's exposed by the C server. It worked wonderfully
01:21:37 <neutrino> mm_freak_: i'm stuck
01:22:19 <Enigmagic> Peaker: i wrote a stack unwinder for ghc using dwarf, so i'm not an idiot about this.
01:22:29 <Enigmagic> and filed loads of bugs against lldb
01:22:36 <Peaker> Enigmagic, that code is just spreading the instance Storable over a lot more lines but it's still repeating every field, every type, etc and in an error-prone way
01:22:47 <hpaste> neutrino pasted “this is as far as I got” at http://hpaste.org/79430
01:22:56 <neutrino> mm_freak_: ^
01:23:02 <Peaker> Enigmagic, it's entirely possible that stack-related stuff (and anything deep inside subprograms) is problematic
01:23:17 <Peaker> Enigmagic, but I've not seen a single bug or incompleteness w.r.t needed information in dwarf
01:23:24 <Peaker> (about exported functions and types)
01:23:51 <Enigmagic> Peaker: the sizes and everything will be correct for sure
01:24:04 <aristid> johnw: please also tell me about how easy/difficult the whole structure makes it for you to extend it:)
01:24:07 <Peaker> Enigmagic, and types are correct, and exposed functions are all there
01:24:10 <Enigmagic> so you'll have something that is unlikely to crash at runtime, and that is a huge improvement over what we have today
01:26:06 <Twisol> Is there an easy introduction to writing monads that I'm missing somewhere?
01:26:26 <johnw> aristid: sure thing!
01:26:55 <neutrino> Twisol: why do you want to learn how to write monads?
01:27:05 <shachaf> Twisol: "Make the types work out."
01:27:35 <Twisol> shachaf: Haha. Easier said than done.
01:27:46 <johnw> Twisol: i like to write Monads by writing fmap and join, and then using equational reasoning to work out what >>= should look like
01:27:53 <mm_freak_> neutrino: let me tell you what the problem here is
01:27:54 <Twisol> neutrino: Because I'm implementing stuff from scratch so I get a feel for how stuff actually works.
01:28:05 <shachaf> Twisol: Does that mean you're getting compilation errors?
01:28:05 <neutrino> ok
01:28:09 <shachaf> That's a good thing here.
01:28:35 <shachaf> In that case you can reduce this to the problem of "how do I write any Haskell function based on knowing its type?".
01:28:38 <Twisol> shachaf: Yes. My brain's also emitting conceptual errors., which is less desirable.
01:28:43 <mm_freak_> neutrino: xs >>= f;  now f will produce a ys, and the first element of the result is the first element of ys for the first element of xs
01:29:00 <mm_freak_> neutrino: the second element of the result is the second element of ys for the second element of xs, etc.
01:29:11 <neutrino> yes
01:29:12 <Twisol> shachaf: it boils down to trying to write a monad transformer thing for my telnet parser.
01:29:13 <neutrino> i know that
01:29:15 <shachaf> Twisol: What's a concrete function you're having trouble with?
01:29:21 <shachaf> Ugh, monad transformers?
01:29:24 <Twisol> ^_^
01:29:24 <shachaf> Those are the devil.
01:29:29 <shachaf> I thought you said monads.
01:29:34 <Peaker> shachaf, what's the alternative?
01:29:37 <johnw> i thought so too
01:29:49 <shachaf> Peaker: For "implementing stuff from scratch so I get a feel for how stuff actually works"?
01:29:52 <shachaf> Just writing the monads.
01:30:05 <mm_freak_> Stream x xs >>= f = let Stream y _ = f x in Stream y (xs >>= tailS . f)
01:30:08 <Peaker> well, if you want to get a feel for how transformers work..
01:30:12 <mm_freak_> that's the correct implementation
01:30:23 <Twisol> Well, I'm trying to write (>>=), and I have to figure out how to square the inner monad (?) with the outer one.
01:30:25 <shachaf> Peaker: Then do that after writing the regular monad. :-)
01:30:32 <shachaf> Twisol: Did you write the non-transformer version?
01:30:41 <neutrino> oh
01:30:46 <Twisol> shachaf: Trying that now, heh.
01:30:46 <neutrino> so i need to shift f by one?
01:30:53 <mm_freak_> neutrino: exactly
01:31:00 <mm_freak_> that's diagonalization
01:31:30 <mm_freak_> neutrino: verify that now liftA2 and liftM2 agree
01:31:44 <neutrino> but if i shifted the xs by one, why doesn't ys get shifted by one?
01:32:11 <mm_freak_> neutrino: because you're still applying the original function and returning its first element
01:32:23 <mm_freak_> but you need to return the element corresponding to the current position in xs
01:33:14 <neutrino> oh
01:33:26 <mm_freak_> neutrino: now that you have a correct Monad implementation, try the following:  print . takeS 100000 $ liftA2 (,) (enumFromS 1) (enumFromS 'a')
01:33:27 <neutrino> here f is indexed by our stream of chars?
01:33:51 <mm_freak_> compile with -rtsopts and run with +RTS -s
01:34:01 <mm_freak_> by our stream of numbers
01:34:06 <mm_freak_> f produces the stream of chars
01:34:16 <mm_freak_> run that and check its memory consumption
01:34:21 <neutrino> yes, i mean f "contains" the stream of chars and so needs to be shifted
01:34:22 <mm_freak_> then do the same with liftM2
01:35:11 <mm_freak_> while liftA2 and liftM2 agree about the result, they LARGELY disagree about how long they should take and how much memory they should eat =)
01:35:32 <neutrino> i don't know how to define tailS
01:35:47 <mm_freak_> data Stream a = Stream { headS :: a, tailS :: Stream a }
01:36:01 <mm_freak_> or equivalently:  tailS (Stream _ xs) = xs
01:36:09 <neutrino> ah of course
01:36:47 <hugli> Is there some internal Haskell equivalent for ``ps aux | grep <name>'' ?
01:37:20 <neutrino> yeah the monadic version is much simpler
01:37:33 <neutrino> hugli: what are you trying to do?
01:37:43 <Twisol> Okay, sanity check. Does this monad make any sense? <https://gist.github.com/a5c95328f93f3ebab0e8> I want to be able to halt a computation when more input is needed, and resume it when that input is provided.
01:37:44 <neutrino> er i meant much slower mm_freak_
01:38:03 <neutrino> Twisol: sounds like STM.
01:38:29 <Twisol> neutrino: What's that?
01:38:31 <neutrino> mm_freak_: why is it so much slower?
01:38:40 <`ramses> mm_freak_: what's the fundamental cause making the monadic code slower? what does it remember that the applicative code doesn't?
01:38:52 <hugli> neutrino: cmus status on xmobar. It should return "" when cmus is not running
01:38:52 <neutrino> Twisol: STM is something which, among others, allows you to halt computation when more input is needed, and resume it when that input is provided.
01:39:07 <Twisol> neutrino: :P
01:39:07 <neutrino> hugli: say what?
01:39:33 <Twisol> neutrino: Google tells me STM is software transactional memory. Name collision or actually what you meant?
01:39:46 <shachaf> Twisol: Interruptible s r ~~ [s] -> r
01:39:50 <shachaf> For what it's worth.
01:39:56 <shachaf> Er, no.
01:40:01 <shachaf> OK, that's backwards. :-(
01:40:06 <Twisol> *blink*
01:40:08 <shachaf> Sorry.
01:40:09 <shachaf> Ignore me.
01:40:14 <neutrino> Twisol: http://hackage.haskell.org/packages/archive/stm/2.1.1.0/doc/html/Control-Concurrent-STM-TMVar.html#v:takeTMVar
01:40:17 <Twisol> Heheh. Okay.
01:40:35 <shachaf> It's actually, uh...
01:40:53 <Twisol> That seems a little heavy for what I want. :/
01:41:06 <neutrino> it's not heavy
01:41:08 <shachaf> What's heavy?
01:41:09 <neutrino> it's very lightweight
01:41:19 <Twisol> shachaf: STM
01:41:25 <shachaf> What? What does this have to do with STM?
01:41:29 <neutrino> stm has explicit support in the runtime
01:41:44 <mm_freak_> neutrino, `ramses: functions in haskell are opaque…  since the function depends on the current element, the resulting stream also does depend on it, so (>>=) has no option but to traverse the resulting stream to the corresponding point from the beginning
01:41:54 <Twisol> shachaf: neutrino suggested it
01:42:03 <shachaf> Oh, neutrino.
01:42:06 <hugli> neutrino: I already made it with Python+zsh. I'm reimplementing it as my first real world project with Haskell (and to reduce cpu load)
01:42:12 <shachaf> It's (exists n. Vect n a -> r). The other half of a funlist.
01:42:20 <mm_freak_> neutrino: to answer your question from yesterday, my experiemental web framework uses a type that is essentially Stream on steroids
01:42:35 <mm_freak_> you asked why i don't just provide a Monad instance
01:42:38 <mm_freak_> that's why =)
01:42:50 <neutrino> gotcha
01:42:56 <neutrino> yes, it doesn't look very correct
01:43:13 <`ramses> mm_freak_: I'll have to think about that later, but thanks for the pointer :)
01:43:33 <neutrino> Twisol: given you've never heard of STM, but are implementing your own monad transformers, i think you're doing things in the wrong order :)
01:43:35 <shachaf> Twisol: Hmm, I wonder what it's called.
01:44:07 <shachaf> OK, it's a free monad.
01:44:16 <shachaf> Interruptible s r ~~ Free (s ->)
01:44:20 <shachaf> Not that that helps you. :-)
01:44:30 <shachaf> Well, it sort of helps you.
01:44:36 <Twisol> Looks a bit like Reader.
01:44:53 <mm_freak_> Twisol: of course your question suggests that you want concurrency, but i understand that there are cases where you actually don't
01:45:10 <shachaf> It's Free (Reader s)
01:45:18 <mm_freak_> in the latter case you probably want coroutines as in a free monad or in monad-coroutine (which is just FreeT in disguise)
01:45:19 <neutrino> Twisol: to me, it sounds like you're kinda-sorta implementing threads with blocking communication and asynchronous exceptions.
01:45:23 <shachaf> mm_freak_: Wait, where did concurrency come up?
01:45:26 <Twisol> ...
01:45:34 <Twisol> I'm just trying to write a network protocol parser. ^_^
01:45:35 <mm_freak_> shachaf: earlier (interruptibility)
01:45:49 <neutrino> Twisol: why not write it with threads, and stm?
01:45:58 <neutrino> you know, things that already exist ;)
01:46:00 <mm_freak_> Twisol: attoparsec + conduit/enumerator/pipes?
01:46:07 <shachaf> Twisol: OK, well, it should be relatively easy to convert Interruptible to a transformer.
01:46:10 <shachaf> And a good exercise.
01:46:25 <Twisol> mm_freak_: tried looking into both, I think I learn better actually exploring the problem space so I have some inkling of what's going on
01:46:25 <mm_freak_> shachaf: the latest version of 'free' has FreeT
01:46:46 <neutrino> mm_freak_: it was fun to write the instances for applicative and functor and monad, thanks for walking me through that
01:46:48 <mm_freak_> Twisol: so you want a resumable parser?
01:46:56 <mm_freak_> neutrino: you're welcome =)
01:47:02 <shachaf> You can take inspiration from here: http://hackage.haskell.org/packages/archive/free/3.2/doc/html/src/Control-Monad-Trans-Free.html#FreeT
01:47:06 <neutrino> mm_freak_: i still don't understand what "tailS f" does
01:47:15 <shachaf> Twisol: Writing this transformer is a good exercise, though.
01:47:21 <Twisol> mm_freak_: Yes. The particular case for being able to interrupt the parser is that if compression on the stream is enabled, I need to stop and decompress before continuing.
01:47:21 <shachaf> Have you figured out what the type should be?
01:47:22 <mm_freak_> neutrino: it's tailS . f
01:47:30 <neutrino> err of course yes
01:47:34 <neutrino> mm_freak_: in our example with the tuple, what is f?
01:47:53 <mm_freak_> Twisol: oh, that doesn't sound like a parser problem at all…  you should probably check out the pipes library
01:48:16 <Twisol> mm_freak_: have, see my answer about doing better exploring the problem space myself first
01:48:29 <neutrino> do you think arrows could be applicable to Twisol's problem?
01:48:30 <Twisol> mm_freak_: I have something that works okay right now. It's horrific IMO.
01:48:34 <mm_freak_> neutrino: liftM2 (,) xs ys = xs >>= \x -> ys >>= \y -> return (x, y)
01:48:53 <neutrino> mm_freak_: ok, let me grok that for a sec
01:49:17 <mm_freak_> neutrino: a category is applicable to Twisol's problem, specifically pipes
01:49:45 <shachaf> Twisol wants to do an exercise to learn! Let Twisol figure things out!
01:49:48 <shachaf> Figuring things out is good.
01:49:49 <Twisol> mm_freak_: for example, experimenting with this stuff has enlightened me somewhat about why pipes always receive and respond with the same type
01:49:51 <neutrino> mm_freak_: i don't know the relation between arrow and pipes.
01:49:58 <Twisol> shachaf: Hah, thanks.
01:50:16 <shachaf> Twisol: Here's a type which is kind of the opposite of yours: newtype Stream m a b = Stream { runStream :: m (Either b (a, Stream m a b)) }
01:50:19 <mm_freak_> Twisol: then i suggest to follow shachaf's suggestion…  learn about free monads, which are coroutines in disguise =)
01:50:45 <shachaf> mm_freak_: I think "learn about free monads" is way overkill for this.
01:50:49 <Twisol> mm_freak_: free monad definitioms based on an associated functor, right?
01:51:16 <mm_freak_> shachaf: well, to understand Free ((->) e) you need to understand Free =)
01:51:19 <mm_freak_> Twisol: yes
01:51:35 <Twisol> shachaf: Huh, that's interesting.
01:51:36 <shachaf> mm_freak_: I'd say that's completely backwards.
01:51:50 <shachaf> mm_freak_: To understand Free you must understand (Free X) and (Free Y) for some X and Y
01:52:04 <shachaf> Twisol: Your version is like a consuming-stream, rather than a producing-stream
01:52:11 <Twisol> Aaah.
01:52:20 <Twisol> Which makes sense.
01:52:24 <shachaf> newtype Foo m a b = Foo { runFoo :: m (Either b (a -> Foo m a b)) }
01:52:25 <mm_freak_> shachaf: depends on where you come from…  i came from monad-coroutine and realized that it's just FreeT
01:53:04 <mm_freak_> others come from the various free monad tutorials and (perhaps) later realize that Free is just \f -> Coroutine f Identity
01:53:06 <shachaf> mm_freak_: newtype Coroutine s m r = Coroutine { resume :: m (Either (s (Coroutine s m r)) r) } ?
01:53:16 <mm_freak_> shachaf: yeah
01:53:20 <shachaf> Yep, that looks like FreeT :-)
01:53:28 <mm_freak_> it is FreeT =)
01:53:43 * shachaf mumbles something about Codensity while we're at it.
01:54:13 <mm_freak_> (except that in the 'free' library edwardk reinvented Either for the same of having Pure and Free constructors) =)
01:54:22 <mm_freak_> sake*
01:54:42 <coleman-> not sure what's the regular ffi way of doing this is, but I'm loving how simple hsc2hs makes fetching C #defines.   #num INT_MAX
01:55:39 <shachaf> mm_freak_: I suspect these things are incomprehensible until you derive them for yourself.
01:56:23 <mm_freak_> shachaf: or you have a set of useful "suspension functors" available in the library
01:57:05 <donri> mm_freak_: i don't see either used in free that way?
01:57:36 <shachaf> What do you get when you combine Foo and Stream?
01:57:42 <mm_freak_> donri: see FreeF
01:57:55 <mm_freak_> shachaf: FooStream?
01:57:58 <coleman-> I just wish it named the resulting value as c_INT_MAX, instead of c'INT_MAX. oh well
01:58:10 <shachaf> I guess you get Iteratee or something similar?
01:58:38 <mm_freak_> shachaf: yeah, except that you don't get Error
01:58:59 <shachaf> What's the definition of Iteratee again?
01:59:43 <donri> mm_freak_: not there either ...
01:59:53 * shachaf reads
02:00:01 <coleman-> is there perhaps a way to change hsc2hs's prefix from c' to c_ ?
02:00:19 <mm_freak_> shachaf: simplified:  data Iteratee s a = Yield a | Error | Continue (s -> Iteratee s a)
02:00:58 <shachaf> mm_freak_: Can't you get rid of Error by putting it into "a"?
02:01:09 <mm_freak_> you can, but that's ugly
02:01:16 <donri> coleman-: i thought c2hs was the better way
02:01:21 <shachaf> Seems less ugly to me.
02:01:24 <shachaf> Anyway, either way.
02:01:33 <shachaf> donri: c2hs rather than hsc2hs? Why?
02:01:47 <mm_freak_> shachaf: with that definition you get an Alternative instance
02:01:55 <shachaf> mm_freak_: Wait, doesn't Iteratee stream things out as well?
02:01:56 <donri> oh, i don't know. but its own description says " Unlike writing foreign imports by hand (or using hsch2s), this ensures that C functions are imported with the correct Haskell types. "
02:02:13 <mm_freak_> shachaf: no
02:02:16 <shachaf> OK.
02:02:21 <mm_freak_> shachaf: iteratees are stream consumers
02:02:22 * shachaf has never used any of these things. :-)
02:02:38 <shachaf> mm_freak_: So what Twisol wrote is just an iteratee minus Error.
02:02:45 <mm_freak_> hence "iteratee" (as opposed to "iterator") =)
02:03:29 <mm_freak_> an enumerator is just an iteratee that behaves like another iteratee, but with additional input
02:03:36 <Twisol> Here's my attempt at T-ifying my Interruptible type. I'm having some trouble though, with the line commented out.
02:03:37 <Twisol> https://gist.github.com/894eee4f5dde920515d9
02:03:42 <mm_freak_> myEnum iter = iterWithInput
02:04:06 <Twisol> (g r) returns an Interruptible rather than the inner monad type, and I don't know how to juggle the types there to make it work.
02:04:13 <mm_freak_> the concept is beautiful, but not very flexible
02:05:05 <mm_freak_> Twisol: for a transformer version you need two types
02:05:47 <mm_freak_> Twisol: newtype Inter s m a = Inter (m (Step s m a))
02:06:13 <shachaf> Twisol: This is your transformer: newtype Foo m a b = Foo { runFoo :: m (Either b (a -> Foo m a b)) }
02:06:15 <mm_freak_> data Step s m a = Yield a | Await (s -> Inter s m a)
02:06:21 <shachaf> Except instead of Either you can define your own type.
02:06:48 <Twisol> This is the Free thing?
02:06:57 <shachaf> It's equivalent.
02:06:59 <mm_freak_> no, but you can define it in terms of Free
02:07:29 <shachaf> Twisol: The issue here is that you need the "m" on the *outside*
02:07:31 <mm_freak_> well, actually in terms of FreeT
02:07:44 <shachaf> Twisol: I.e., you want m (Await ... | Actual ...)
02:07:55 <shachaf> So you only figure out which one it is *after* running the m-action
02:08:00 <Twisol> ah, and that necessitates an extra type
02:08:04 <shachaf> Right.
02:08:08 <shachaf> Or you can use Either
02:08:14 <shachaf> Either works. :-)
02:08:21 <Twisol> well, as long as it's a second type
02:08:22 <mm_freak_> (which is an extra type)
02:09:04 <shachaf> Should we give Twisol CPSing this thing as an exercise, too?
02:09:24 <mm_freak_> uhm, no
02:09:31 <Twisol> my current solution already has this: data Parser m r = Parser (ByteString -> m (Parser m r, r))
02:09:32 <shachaf> Good plan.
02:09:35 <Twisol> so.. yeah.
02:09:58 <mm_freak_> Twisol: that doesn't look like a monad to me
02:10:04 <Twisol> it aint
02:10:09 <Twisol> that's why I'm here
02:10:27 <mm_freak_> Twisol: but if you add an input type, it's a category
02:11:00 <mm_freak_> newtype Parser m a b = Parser (ByteString -> a -> m (b, Parser m a b))
02:11:18 <mm_freak_> and that category is just Auto
02:11:30 <mm_freak_> but a monad-transformed version of it
02:12:00 <shachaf> Twisol: Do you think you can write instance Monad Foo?
02:12:12 <shachaf> (Or do you prefer to make up your own type?)
02:12:30 <Twisol> I prefer to work it out myself, but I'll give it a shot anyhow.
02:12:39 <johnw> aristid: ranges is working
02:13:06 <shachaf> Twisol: OK, do your own type and then do Foo. :-)
02:15:04 <mm_freak_> i see where this is going =)
02:15:34 <shachaf> mm_freak_: ?
02:16:23 <mm_freak_> newtype StreamProc e m a b = StreamProc ([a] -> m (Either e [b], StreamProc e m a b))
02:17:01 <coleman-> what is #integral_t equivalent for pointer typedefs?
02:17:16 <johnw> coleman-: what do you mean?
02:17:17 <Twisol> Oh, on a tangent - it is possible to write PEG-like grammar descriptions using the type system and Show?
02:17:44 <Twisol> and/or Read
02:17:50 <coleman-> johnw  #typedef void *handle;   how would I declare that typedef?
02:18:04 <johnw> i'd use #opaque_t handle
02:18:38 <johnw> see https://bitbucket.org/mauricio/bindings-dsl/wiki/DetailedUsageGuide/Types
02:18:47 <johnw> they do the same for C's FILE* type there
02:18:50 <coleman-> I am reading that. it seems opaque_t is for structs
02:19:05 <johnw> ah
02:19:06 <coleman-> they did it for FILE, which is a struct
02:19:25 <johnw> #synonym_t handle , Ptr ()
02:19:50 <shachaf> mm_freak_: Isn't it great when GHC writes your code for you?
02:19:59 * shachaf has learned to stop worrying and love the ImplicitParams
02:20:26 <shachaf> My new method of writing complicated types is writing everything I can, and then writing "?blah all the variables in scope"
02:20:40 <shachaf> Then I have a little localized puzzle to put together.
02:21:08 <coleman-> johnw yes that's it thanks. I am loving bindings dsl so far
02:21:08 <merijn> ImplicitParameters seems so neat, but I never have a usecase for it, makes me so sad :(
02:22:18 <shachaf> merijn: I just used it now to write Twisol's "Foo" monad instance.
02:22:43 <shachaf> By "used" I mean "looked at the error messages it gives you"
02:22:48 <shachaf> I don't ever leave it in the code at the end.
02:22:52 <shachaf> It's just pseudo-holes.
02:23:01 <aristid> johnw: so i saw your pull request. it doesn't really matter, but there's a few convenience functions you could have used: http://hackage.haskell.org/packages/archive/http-types/0.7.3.0.1/doc/html/Network-HTTP-Types-Header.html#g:3 and perhaps http://hackage.haskell.org/packages/archive/http-types/0.7.3.0.1/doc/html/Network-HTTP-Types-QueryLike.html :)
02:23:34 <djcoin> Is there a good DSL for postgres with type checking ? I'm always hearing DSL are great etc. but curiously I'm having a hard figuring out a good package that would enable me to write type checked SQL, one of the most common DSL I suppose.
02:24:09 <aristid> djcoin: how about haskelldb?
02:24:33 <aristid> djcoin: it doesn't use SQL though, but rather relational algebra. which is better IMHO
02:25:59 <mm_freak_> shachaf: i don't like ImplicitParams
02:26:22 <mm_freak_> they fail at exactly the spots where they would be useful, but there is a better alternative anyway
02:26:34 <shachaf> mm_freak_: What's the better alternative?
02:26:43 <mm_freak_> @hackage reflection
02:26:43 <lambdabot> http://hackage.haskell.org/package/reflection
02:26:46 <mm_freak_> that one
02:26:49 <shachaf> ?
02:26:53 <djcoin> Ok, I heard about metahdbc and haskell framework rolling their own it seems, eg: yesod with persisten. I need to check your link in details
02:26:55 <djcoin> thanks
02:27:04 <shachaf> mm_freak_: I'm not talking about using ImplicitParams in actual code.
02:27:11 <shachaf> I just said I never do that.
02:27:16 <shachaf> I'm talking about using it as pseudo-holes.
02:27:27 <mm_freak_> i don't get that…
02:27:37 <merijn> mm_freak_: Simple
02:28:14 <merijn> :t mapM_ ?foo . concat . permutations
02:28:15 <lambdabot> (?foo::a -> m b, Monad m) => [a] -> m ()
02:28:24 <merijn> mm_freak_: Presto, I know what foo should be
02:28:47 <mm_freak_> ah, clever
02:29:25 <shachaf> More generally, you can use GHC errors while you're working on a big file.
02:29:49 <shachaf> Let's say I'm writing instance Monad (Foo m i) for Twisol's exercise.
02:30:14 <Twisol> which is ending up strangely difficult, btw.
02:30:18 <shachaf> I write: Foo m >>= f = Foo $ m >>= \x -> case x of Left a -> ?leftcase; Right k -> ?rightcase
02:30:32 <shachaf> Now GHC tells me "this can't compile, you haven't filled in ?leftcase and ?rightcase"
02:30:39 <Twisol> oh good, I'm on the right track
02:30:42 <shachaf> But it also tells me their types.
02:30:57 <mm_freak_> that's actually useful
02:30:57 <donri> i wonder if this is actually better than TypeHoles because you can name the holes?
02:31:13 <shachaf> I usually only have one hole at a time.
02:31:44 <shachaf> mm_freak_: I've been writing more and more complicated code this way.
02:32:07 <shachaf> It's great because you can think entirely locally.
02:32:24 <shachaf> mm_freak_: You can also use the hole as a function: Right k -> ?rightcase m f x k
02:32:33 <shachaf> Now it shows me the type of the four "ingredients" I have.
02:32:44 <shachaf> I just need to figure out how to piece those ingredients together.
02:33:22 <johnw> aristid: you still here?
02:33:24 <shachaf> I suppose it's not a huge improvement over a unification error.
02:33:30 <aristid> johnw: sure
02:35:16 <johnw> n/m :)
02:35:28 * hackagebot nemesis 2012.12.18 - a Rake like task management tool  http://hackage.haskell.org/package/nemesis-2012.12.18 (JinjingWang)
02:35:47 <johnw> i'm going to implement HEAD now as an extension to GET if I can (or vice-versa), to avoid copying too much code
02:36:39 <aristid> johnw: huh, i don't think you need to copy a lot of code for that
02:36:53 <aristid> johnw: most of the parameters to GET don't make sense for HEAD.
02:36:59 <johnw> that's true
02:37:23 <johnw> HEAD is a subset of the scope for GET
02:37:39 <johnw> so should I really copy GetObject entirely, or can I have GET "derive" from HEAD?
02:37:48 <johnw> the other possibility is this
02:38:10 <johnw> add goResponseEmpty :: Bool, and if it's True, use a HEAD and return an empty response body
02:38:14 <mm_freak_> shachaf: well, so far for me GHC's type errors have sufficed
02:38:35 <aristid> johnw: i guess having GET derive from HEAD somehow would be cool in some way, but the most practical option right now seems to me to simply copy the code for GET and remove all the things not needed, and you'll end up with a pretty small module
02:38:52 <johnw> yeah, i just have to somehow calm my gag reflex at doing that
02:39:18 <aristid> johnw: i _do_ want a different request/response type pair for GET and HEAD. how you implement it is a different matter but a mere boolean flag would make me unhappy
02:39:34 <johnw> i'll do a separate request object
02:39:40 <johnw> and you can optimize it later if you feel inclined
02:39:49 <aristid> yeah
02:40:14 <shachaf> mm_freak_: The type errors always suffice.
02:40:25 <shachaf> mm_freak_: Along with some thinking, that is.
02:40:36 <shachaf> The point is to reduce the amount of thinking, when the computer can do it for me.
02:40:49 <johnw> now at least I can ask for hoBuckets
02:40:54 <shachaf> mm_freak_: So what does the CPSed version of FreeT look like?
02:40:59 <aristid> johnw: huh?
02:41:04 <johnw> head object Bucket :)
02:41:15 <aristid> johnw: why the s at the end?
02:41:19 <johnw> hoBucket's
02:41:36 <johnw> if I specify my hoBucket, I get back a horMetadata
02:41:41 <johnw> I'm sure there's some good puns in there :)
02:41:50 <aristid> puns which i don't get :D
02:42:09 <johnw> ho and hor are boths puns for "whore"
02:42:35 <aristid> johnw: oh. yeah well talking about whores is not part of my normal discussion topic set:)
02:42:59 <johnw> touché
02:43:39 <aristid> *shrug*
02:43:52 <shachaf> I don't think it's part of #haskell's either.
02:44:01 <johnw> i'm just trying to be funny, I suppose emphasis on trying
02:44:07 * johnw slinks away back to coding
02:44:16 <aristid> johnw: so once you have HeadObject you'll see how much code duplication there is, maybe then it makes sense to think about a way to reduce that
02:44:31 <Twisol> holy crud. <https://gist.github.com/894eee4f5dde920515d9>
02:44:34 <Twisol> that took a while.
02:45:01 <Twisol> (ImplicitParams sure came in handy though)
02:45:12 <aristid> Twisol: somehow that looks tekmo-y :D
02:45:42 <Twisol> I have no idea why, but I'll take that as a compliment!
02:46:00 <Twisol> The F's and T's, maybe? Probably saw that from one of his posts.
02:46:22 <edwardk> stepcut: i managed to get deletion working, and overloading in terms of keys as fake lenses
02:46:55 <johnw> aristid: how do I pass an s3QQuery with no fields?  s3QQuery = HTTP.toQuery [] does not type check
02:47:03 <shachaf> edwardk: So what does the CPSed version of FreeT look like?
02:47:17 <edwardk> it looks mostly useless
02:47:24 <shachaf> Oh.
02:47:28 <edwardk> because the monad causes you pain
02:47:29 <aristid> johnw: just []?
02:47:40 <johnw> worked
02:47:44 <shachaf> So what, you just use the m (Either a ...) form?
02:47:45 <aristid> :)
02:47:51 <edwardk> remember cpsing free works well when you have a linear usage pattern
02:48:00 <aristid> johnw: toQuery is rather polymorphic and often needs type annotations
02:48:08 <shachaf> Oh, you have to build up the whole thing without using it.
02:48:09 <edwardk> when someone else gives you the monad, thats rarely likely to hold
02:48:13 <aristid> but if all you want is an empty Query, it's just a list anyways
02:48:21 <shachaf> Fair enough.
02:49:47 <johnw> aristid: alright, now to try it out...
02:50:05 <donri> edwardk: deletion?
02:50:05 <Twisol> shachaf: I don't think I even have to bother writing an instance for the Foo type, it's pretty much identical. :|
02:50:29 * hackagebot air-extra 2012.12.18 - air-extra  http://hackage.haskell.org/package/air-extra-2012.12.18 (JinjingWang)
02:50:33 <edwardk> donri: in an in-memory haskell relational table that supports multiple indices
02:50:34 <shachaf> Twisol: You did it for your type?
02:50:40 <donri> edwardk: ixset?
02:50:40 <Twisol> shachaf: https://gist.github.com/894eee4f5dde920515d9
02:50:42 <shachaf> Twisol: If it's identical then it won't take long. :-)
02:50:52 <edwardk> something nicer i started on a couple hours ago
02:50:56 <donri> cool
02:50:59 <donri> ixset kinda sucks :)
02:50:59 <shachaf> Twisol: That looks right.
02:51:04 <johnw> aristid: what is the non-exception way of doing readResponseIO?
02:51:19 <edwardk> @hpaste
02:51:20 <lambdabot> Haskell pastebin: http://hpaste.org/
02:51:21 <johnw> i want a Maybe a value, not a fail in IO
02:51:31 <shachaf> Twisol: Now if you replace your thing with Either you get Foo, I guess.
02:51:36 <hpaste> edwardk pasted “relations (progress)” at http://hpaste.org/79433
02:51:39 <shachaf> It's just %s///
02:51:54 <Twisol> shachaf: left/right versus await' and actual'
02:51:56 <edwardk> i was just starting work on insert
02:52:12 <edwardk> which needed the deleteRows helper to deal with collisions
02:53:02 <edwardk> donri: basically you will in the end specify your data type, specify its primary, candidate and supplemental keys, and youll get something you can search through and slice up using those keys
02:53:16 <edwardk> if i feel ambitious maybe we'll get foreign keys
02:53:28 <edwardk> where all the tables occupy a common state type
02:53:33 <johnw> ah, it's just readResponse
02:53:48 <johnw> it knows based on how I case analysis the result what type it should represent the error as
02:54:06 <edwardk> you can test it a bit by loading that in ghci and doing 'toList test'   and 'toList (delete fooId 0 test)' or using the other keys
02:54:21 <edwardk> fooId can be used directly as a lens into the rows
02:55:14 <johnw> aristid: it works!
02:55:26 <johnw> aristid: now we have a cheap way to test for existence of an object
02:55:28 <aristid> johnw: yay
02:56:32 <LMolr> Is there a datatype for an hash string? I am explaining in a presentation a data structure with the power of haskell syntax, but i would like to give really compilable haskell code
02:56:33 <johnw> pull req sent
02:56:57 <shachaf> What is an hash string?
02:56:59 <johnw> i don't think I can add my existsObject helper function, though
02:57:13 <johnw> because HeadObject.hs just makes requests, it's doesn't act on them
02:57:44 <LMolr> shachaf, i mean a datatype for an hash like md5 or sha
02:57:55 <aristid> johnw: looks like it doesn't have a lot in common with GetObject:0
02:58:09 <johnw> it's GetObject--
02:58:18 <aristid> johnw: well you could make a separate ExistsObject/Bool Transaction type, i guess
02:58:21 <LMolr> shachaf, or should I simply do a "type Hash String" ?
02:58:37 <johnw> aristid: it's easy enough to make my own existsObject function at a higher level, so I'm not going to worry about it at this point
02:58:49 <shachaf> LMolr: You should probably use ByteString or [Word8]
02:58:53 <shachaf> [Char] is the wrong type.
02:58:56 <johnw> i have enough now to rewrite my existence test which did a bucket list
02:58:57 <aristid> johnw: hmm, actually Bool would not be valid due to the functional dependency there
02:59:07 <shachaf> LMolr: A better type would be nice but I don't think one exists.
02:59:12 <shachaf> You can always define your own, of course.
02:59:40 <aristid> johnw: did you test what happens when you try the request on a non-existent object? exception?
02:59:46 <LMolr> Ok, thank you shachaf
03:00:03 <johnw> aristid: if you use readResponseIO, it will fail
03:00:11 <donri> edwardk: looks cool. is it very different from http://palmik.net/data-store/Data-Store.html ?
03:00:27 <hpaste> johnw pasted “headFile.hs” at http://hpaste.org/79434
03:00:30 <johnw> that's the test I'm using
03:00:36 <edwardk> quite
03:00:38 <johnw> it returns True if the file exists, False otherwise
03:01:02 <edwardk> no newtype noise for one
03:01:51 <aristid> johnw: ah yeah finally a case where the attempt stuff is useful:P
03:02:12 <johnw> yes, indeed!
03:02:16 <johnw> it's quite handy in this case
03:02:47 <aristid> johnw: you could directly match on responseResult though
03:03:14 <johnw> responseResult?
03:03:25 <aristid> johnw: yeah directly gives you an Attempt
03:03:30 <johnw> i'm not familiar with that
03:03:33 <aristid> with Success and Failure constructors
03:03:35 <johnw> how would thec hanged code look?
03:04:04 <aristid> johnw: instead of matching on JUst and Nothing you'd match on Success and Failure
03:04:19 <johnw> I changed it to: return $ maybe False (const True) (readResponse res)
03:04:20 <aristid> http://hackage.haskell.org/packages/archive/attempt/0.4.0/doc/html/Data-Attempt.html
03:04:38 <efie_> Data.Set is strict in the elements it contains, isn't it?
03:04:40 <shachaf> @ty maybe False (const True)
03:04:42 <lambdabot> Maybe a -> Bool
03:04:55 <shachaf> @ty [isJust, isNothing]
03:04:55 <johnw> oh, um, isJust :)
03:04:56 <lambdabot> [Maybe a -> Bool]
03:05:06 <johnw> haha
03:05:09 <johnw> sometimes I outthink myself
03:05:24 <aristid> ok with isJust it's nicer than matching on the Attempt
03:05:30 <shachaf> efie_: Yep.
03:06:05 <Twisol> shachaf: Now I have no idea how to actually use my new monad. :D
03:06:06 <bourbaki> Greetings
03:06:08 <johnw> yeah, now I can just do this:
03:06:10 <johnw> isJust . readResponse <$>
03:06:14 <bourbaki> edwardk: Still there?
03:06:25 <edwardk> somewhat
03:06:26 <edwardk> whats up?
03:06:36 <shachaf> Twisol: That's not my department!
03:06:47 <shachaf> Twisol: Figure out what primitive operations you want on it.
03:07:14 <Twisol> primarily just a way to yield back to the caller to await more input.
03:07:19 <shachaf> Like done :: a -> FooT i m a and more :: (i -> FooT i m a) -> FooT i m a, or something.
03:07:26 <shachaf> Or who knows.
03:07:33 <shachaf> I guess you want something better than "more"
03:07:33 <bourbaki> edwardk: Just a quick question on the algebra thingy, the Field i defined relies on Magmas one for sums one for products, but both are used with Sum and Prodcut, thus it is not really a field in the end.
03:07:50 <shachaf> Like more :: FooT i m i -- ask for more input
03:07:53 <shachaf> Can you do that?
03:08:14 <bourbaki> Since the operators are defined over different types, so i guess i would have to add some kind of bijection of Sum and Product types. How did you deal with that?
03:08:43 <aristid> johnw: why do you always create a new Configuration with each request?
03:08:47 <Twisol> shachaf: I'm trying to implement it on the non-transformer version first, and named 'yield', but yeah.
03:08:52 <Twisol> er
03:08:53 <Twisol> 'await'
03:09:30 <aristid> johnw: and would you enjoy having something like an AwsT monad transformer?
03:09:41 <johnw> aristid: what would that do?
03:10:16 <aristid> johnw: well it would allow you to do things like headFile without worrying about passing the configuration and manager, i guess
03:10:21 <edwardk> bourbaki: i wind up duplicating the code between the multiplicative and additive structures, making multiplicative monoids or additive monoids and work my way up from there, where they have separate constraints, then only start to tie them together around the ring level
03:10:23 <johnw> ah, I see
03:10:26 <johnw> hmm
03:10:31 <mm_freak_> RWSCELIT
03:10:44 <mm_freak_> ReaderWriterStateContEitherListIdentityT
03:10:58 <edwardk> bourbaki: to turn a 'sum-like' thing into a product-like thing i have Exp, and the other way around i have Log.
03:10:59 <johnw> so, instead of doing my requests in the ResourceT IO a monad, I would do them in Aws a?
03:11:11 <bourbaki> edwardk: Ah ok so there is a point i was pondering about also, if i use templates i can have that features also right?
03:11:14 <edwardk> woot. insertion works in my little tables
03:11:16 <johnw> or I guess AwsT IO a
03:11:17 <edwardk> templates?
03:11:19 <aristid> johnw: something like that yea
03:11:36 <johnw> aristid: well, my Aws code doesn't go deeper than one level, so it wouldn't benefit me
03:11:38 <bourbaki> edwardk: I would have a template for Magmas for example and then be able to inject a prefis.
03:11:40 <mm_freak_> anyway, what's Aws?
03:11:44 <bourbaki> Prefix
03:11:45 <johnw> Amazon Web Services
03:11:59 <bourbaki> Like AdditiveMagma , MultiplicativeMagma etc.
03:12:13 <edwardk> ow would you build these?
03:12:16 <bourbaki> I guess i can not do that with ConstraintKinds right?
03:12:31 <bourbaki> edwardk: With the instance then.
03:12:47 <bourbaki> In order to have a field you need to implement an additive and a multiplicative magma.
03:12:58 <bourbaki> And thus would get rid of the Sum and Product types.
03:13:06 <edwardk> i literally duplicated code code. you might be able to find some fancy way to encode these with constraint kinds and a lot of aliasing for a base set of neutral operators
03:13:10 <edwardk> i didn't have much luck
03:13:30 <bourbaki> Meh :( ok which one is your package anyway?
03:13:43 <edwardk> i did a test and got a few class-like modifiers, like "Ordered Semiring" but its not in algebra
03:13:46 <edwardk> @hackage algebra
03:13:46 <lambdabot> http://hackage.haskell.org/package/algebra
03:13:50 <bourbaki> Thanks
03:14:24 <efie_> shachaf: where excatly does Data.Set say this? WHNF does not mean that the elements have to be fully evaluated, does it?
03:14:28 <bourbaki> I am almost inclined to give up on this one and just start with the actual problem :)
03:14:31 <edwardk> it was a fit of temporary insanity back in 2011 ;)
03:14:38 <edwardk> i highly recommend it ;)
03:14:40 <aristid> mm_freak_: there are still people who don't know what AWS is? oO
03:14:44 <Twisol> shachaf: Huh. I think I actually managed to do it. <https://gist.github.com/894eee4f5dde920515d9>
03:14:47 <edwardk> (giving up and working on the problem that is)
03:14:58 <edwardk> haskell kinda sucks for deep inheritance hierarchies
03:15:04 <bourbaki> Oh cool edwardk :) i was just about to watch some of the videos you have on youtube :)
03:15:05 <edwardk> and it won't get better
03:15:16 <shachaf> efie_: No, Data.Set only evaluates to WHNF, or whatever Ord uses.
03:15:23 <bourbaki> edwardk: Why is that?
03:15:24 <aristid> johnw: anyways, your pull requests look good enough, i'll try to take care of them later today
03:15:25 <johnw> aristid: thanks, I factored out the Configuration
03:15:29 * hackagebot z3 0.2.0 - Bindings for the Z3 Theorem Prover  http://hackage.haskell.org/package/z3-0.2.0 (IagoAbal)
03:15:38 <edwardk> too many people have hung their hopes on how superclass defaults will save us or something
03:16:11 <edwardk> and in my experience the amount of time i could take advantage of them is close to 0
03:16:16 <aristid> edwardk: i remember you saying we would need mixin packages for deep hierarchies to work well, too. or am i mixing up something?
03:16:30 <shachaf> Twisol: Looks good!
03:16:31 <bourbaki> Hm i see :(
03:16:53 <bourbaki> Someone pointed out that what i am really looking for is Agda can you copy that edwardk ?
03:16:58 <shachaf> Twisol: If you think about what that code is saying, it even makes sense.
03:17:04 <edwardk> aristid: mixin packages were kind of an orthogonal concern. mostly as a way to resolve the 'onion' problem with cabal/hackage that later packages have to support everything under them or leave orphans
03:17:04 <Twisol> shachaf: It does!
03:17:09 <bourbaki> Due to the dependent types.
03:17:18 <Twisol> shachaf: Assuming this actually works as I expect, this was the easiest coroutine-ish thing I've ever written.
03:17:33 <edwardk> bourbaki: agda lets you work at a much higher level of sophistication for the sorts of things you want to do
03:17:39 <edwardk> #agda is full of smart people
03:17:51 <aristid> edwardk: but you've given up on that idea, too?
03:18:00 <bourbaki> Cool ill read on the reflection stuff and then might have a sidelook at adga.
03:18:15 <edwardk> aristid: i don't have the energy to make the idea understood and fight for it, more or less
03:18:28 <bourbaki> I read that i can use Haskell as a backend so it is not really that bad i think.
03:18:43 <aristid> edwardk: i think it's a cool idea, but i'm not sure if the added complexity would be bearable
03:18:48 <nyc> Cylindrical algebraic decompositions would be nice to have floating around somewhere.
03:18:52 <edwardk> if you plan to learn agda expect a cliff-like learning curve. its great though.
03:19:07 <bourbaki> Heh
03:19:13 <shachaf> Twisol: You can add output, too, if you like.
03:19:21 <edwardk> bourbaki: there is an intro to agda on my youtube channel
03:19:23 <bourbaki> I just hope that i do not necessarily need Emacs.
03:19:24 <shachaf> So at each stage you yield data and get new data.
03:19:30 <edwardk> copumpkin gave a talk at boston haskell
03:19:38 <bourbaki> edwardk: That was one of the videos i wanted to watch :)
03:19:40 <nyc> Agda would probably help.
03:19:52 <edwardk> bourbaki: in my experience giving up and just embracing emacs to work with agda is really key to getting anything out of it
03:19:55 <bourbaki> Just as that talk about lenses
03:20:01 <edwardk> i _hate_ emacs and i still use it for agda
03:20:07 <bourbaki> :)
03:20:08 <edwardk> its just that much better
03:20:17 <bourbaki> I just came to sublime.
03:20:36 <Twisol> shachaf: I could. The way I have it in my previous solution - and something I'll have to determine about this one - is that the parser chains actions on a monad provided by the calling code, instead.
03:20:38 <edwardk> the key combos for working with holes in agda really make the language come alive
03:20:38 <bourbaki> I used Emacs back when i was working with lisp but i do not really like it for its obstructivity.
03:20:46 <Twisol> shachaf: but that's an intriguing idea
03:20:48 <bourbaki> It is like learning two languages at once then.
03:20:52 <edwardk> once you get proficient with them haskell feels crippled
03:21:14 <edwardk> if you don't load up agda in emacs though, its agda that winds up feeling crippled and hard to reason about
03:21:26 <bourbaki> Hehe
03:21:35 <aristid> agda is hard enough to use even with those fancy features
03:21:41 <bourbaki> Maybe someone would be inclined to port it do Sublime.
03:21:48 <efie_> shachaf: for example if the set contains lists, and I construct lists like this before I put them in the set: [1+1,2+2]. this would be in WHNF, and according to what Data.Set says it would not be evaluated further. but Ord needs to know what 1+1 and 2+2 it, so isn
03:22:08 <efie_> 't this a contradiction?
03:22:10 <bourbaki> Anyway thanks a bunch again ill dig through your videos and your package.
03:22:41 <shachaf> efie_: Set might evaluate your items to more than WHNF, of course.
03:22:47 <shachaf> But that's up to you and your Ord instance.
03:22:54 <shachaf> It won't *necessarily* force them past WHNF.
03:23:11 <efie_> ok, and what is WHNF needed for?
03:23:56 <shachaf> It's not strictly needed, but it's nice to have for reasoning about the performance of your Set and what not.
03:24:08 <shachaf> Twisol: By the way, your arguments are backwards. The "m" should come second.
03:24:57 <Jafet> efie: for avoiding stack overflow exceptions
03:28:59 <Twisol> shachaf: Why's that?
03:29:50 <efie_> Jafet: why is not everything, always be forced to be in WHNF?
03:30:17 <shachaf> Twisol: You'll find out. :-)
03:30:29 <shachaf> Twisol: (When you try to make the MonadTrans instance, specifically.)
03:30:51 <Twisol> shachaf: Ah, that's why. Gotcha.
03:30:53 <Jafet> Everything that is ever evaluated in your program, is forced to be in WHNF!
03:31:14 <Jafet> So that is a strange question.
03:31:28 <Twisol> so pretty much the same reason the monad result is the last parameter.
03:32:22 <shachaf> Twisol: Yep.
03:32:51 <shachaf> Twisol: Did you add "o" yet?
03:35:22 <shachaf> Twisol: That way you get this nice general operator: yield :: Monad m => o -> FooT i o m i
03:35:35 <shachaf> You yield something and get something back at each step
03:36:09 <efie_> Jafet: I mean for example Data.Sequence does not evaluate its members to WHNF, does it?
03:36:46 <Jafet> The WHNF of Seq does not depend on the WHNF of its elements.
03:39:23 <efie_> Jafet: but I thought if the elements of a Seq where in WHNF this would help to avoid a stack overflow?
03:39:43 <coleman-> what's the standard way of writing this?
03:39:48 <coleman-> > type Rect = Num a => ((a, a), (a, a))
03:39:50 <lambdabot>   <hint>:1:1: parse error on input `type'
03:40:01 <shachaf> type Rect a = ((a, a), (a, a))
03:40:07 <shachaf> foo :: Num a => Rect a -> ...
03:40:30 <Jafet> You need a stack to evaluate a Set to WHNF, because it depends on the values of the keys.
03:40:47 <coleman-> but I wanted Rect to contain nums, not to accept a type. not possible?
03:41:02 <shachaf> mm_freak_: Do you know if this version exists anywhere?
03:41:58 <Jafet> Since the WHNF of the Set depends on the keys, Set always evaluates them to WHNF.
03:42:13 <Jafet> (There are plausible key types where WHNF would not be weak enough compared to compare. But these types are never used in a benchmark or the shootout, so it's okay.)
03:42:19 <coleman-> I'll just use RankNTypes..
03:42:47 <Jafet> Turn on extensions until it compiles.
03:43:12 <donri> -XDWIM -XNoDTRT
03:43:45 <Jafet> -fdefer-runtime-errors
03:44:37 <coleman-> is it reasonable that types can't contain typeclasses? I don't see why I would have to type  Num a => Rect a everywhere instead of just Rect
03:44:49 <coleman-> also Rect String makes no sense and yet it would work..
03:45:09 <shachaf> What you wrote does not make sense.
03:45:16 <coleman-> explain
03:45:16 <shachaf> There might be something else that makes sense but it wouldn't be that.
03:45:22 <shachaf> (What you wrote is a rank-2 type.)
03:45:31 <carlocci> I'm on tryhaskell.org, something is wrong: "> 5+7 => []", "> 5 + 7 => [7,6,5,4]", "> 1 + 3 => 12", "> 5 + 7 => 12", "> 1 + 3 => 4", "> 1 + 3 => 12"
03:45:57 <carlocci> isn't haskell supposed to be correct?
03:46:00 <coleman-> yes. and what part of what I wrote makes no sense?  would Rect String not work with your suggestion?
03:46:36 <Jafet> carlocci: yes, but it graciously allows the programmer to be wrong
03:46:56 --- mode: ChanServ set +o johnw
03:46:57 --- mode: johnw set -r
03:47:00 --- mode: johnw set -o johnw
03:47:41 <shachaf> coleman-: No, because you wouldn't be able to use it anywhere.
03:47:46 <Nereid> carlocci: works fine here
03:48:08 <shachaf> coleman-: The part that makes no sense is that foo :: Rect -> Rect -> Rect becomes foo :: (forall a. Num a => ((a, a), (a, a))) -> (forall a. Num a => ((a, a), (a, a))) -> (forall a. Num a => ((a, a), (a, a)))
03:48:16 <efie_> why does Set wants its element to be in Ord anyway?
03:48:24 <shachaf> efie_: What would you prefer?
03:48:35 <mm_freak_> shachaf: what's "this"?
03:48:40 <coleman-> yes you would.  returnStupidRectString :: Rect String = (("this", "makes"), ("a lot", "of sense")))
03:48:46 <shachaf> mm_freak_: newtype FooT i o m a = FooT { runFooT :: m (Either a (i -> (o, FooT i o m a))) }
03:49:01 <shachaf> coleman-: OK, and you wouldn't be able to use it anywhere that required a Num
03:49:06 <Jafet> :t S.singleton
03:49:07 <lambdabot> a -> S.Set a
03:49:08 <efie_> shachaf: when I'm thinking of a Set, I don't think that its elements are ordered
03:49:11 <Jafet> No Ord.
03:49:13 <shachaf> Maybe you'll find out that your function is more general than you thought!
03:49:17 <mm_freak_> shachaf: why an extra 'o'?
03:49:18 <Twisol> shachaf: This is turning into Pipe, isn't it?
03:49:24 <Nereid> efie_: the implementation of Set uses it.
03:49:27 <shachaf> mm_freak_: You have input and output at each stage.
03:49:31 <shachaf> mm_freak_: Like a true coroutine!
03:49:40 <shachaf> mm_freak_: yield :: Monad m => o -> FooT i o m i
03:49:51 <Nereid> efie_: Set is implemented with a balanced binary tree
03:49:53 <coleman-> shachaf making Rect accept just numbers, since that's all it should accept, makes a lot of sense
03:49:57 <Jafet> efie: so what is your fast algorithm to organize a collection of data?
03:49:59 <Nereid> to do that you need to make comparisons between elements
03:50:03 <coleman-> regardless of your forall dribble
03:50:07 <mm_freak_> shachaf: i would simplify that type and simultaneously make it more powerful (i don't know why pipes is so complicated)
03:50:08 <shachaf> coleman-: No, it makes less sense because it makes it easier to make mistakes.
03:50:23 <shachaf> mm_freak_: Simplify it how, by making it into FreeT?
03:50:25 <carlocci> Nereid: yeah, right now it works here too and I didn't even refresh the window. Maybe it was a sudden moment of défaillance
03:50:29 <donri> efie_: there's a HashSet in unordered-containers that is, well, unordered
03:50:30 * hackagebot hack2-contrib 2012.12.18 - Hack2 contrib  http://hackage.haskell.org/package/hack2-contrib-2012.12.18 (JinjingWang)
03:50:32 * hackagebot miku 2012.10.27 - A minimum web dev DSL in Haskell  http://hackage.haskell.org/package/miku-2012.10.27 (JinjingWang)
03:50:46 <mm_freak_> shachaf: newtype Foo e m a b = Foo ([a] -> (Either e [b], Foo e m a b))
03:50:55 <coleman-> shachaf what mistakes?  show me one
03:50:57 <shachaf> I don't know anything about Pipe
03:51:08 <efie_> Nereid: ah ok, thanks
03:51:08 <mm_freak_> me neither
03:51:24 <johnw> aristid: somehow, an import didn't make it into one of those pull requests...
03:51:30 <shachaf> coleman-: For example, swap :: Rect -> Rect; swap ((x,y),(a,b)) = ((1,2),(3,4))
03:51:30 <johnw> aristid: sending you a fix
03:51:36 <Twisol> shachaf, mm_freak_: I'm just going off memory, but I distinctly remember the same i o m r signature w.r.t. pipes
03:51:44 <Twisol> but that was probably before the major overhaul(s)
03:51:52 <donri> coleman-: basically you don't get any guarantees that you get the same Num instances for different Rects
03:51:52 <shachaf> mm_freak_: That's more powerful?
03:51:53 <mm_freak_> Twisol: it's still that way
03:51:53 <aristid> johnw: already fixed myself.
03:51:59 <mm_freak_> shachaf: yeah
03:52:01 <johnw> ok, sorry about tha
03:52:02 <johnw> t
03:52:12 <johnw> i wonder how that made it through, since I ran tests here
03:52:15 <shachaf> This one allows you arbitrary actions.
03:52:20 <efie_> donri: is this set implementation less strict than Data.Set?
03:52:28 <mm_freak_> shachaf: oh, i forgot the m
03:52:35 <mm_freak_> shachaf: newtype Foo e m a b = Foo ([a] -> m (Either e [b], Foo e m a b))
03:52:37 <mm_freak_> my err
03:52:53 <shachaf> Oh, so my thing is just Pipe?
03:52:53 <efie_> donri: nevermind :)
03:52:56 <Jafet> HashSet sounds like it will be most strict, because a useful hash function evaluates all its input.
03:53:00 <Nereid> efie_: HashSet, as the name implies, requires the type to be Hashable (instead of Ord)
03:53:01 <mm_freak_> shachaf: no idea
03:53:13 <shachaf> Hmm, it's similar to Pipe, at least.
03:53:17 <Twisol> Extremely
03:53:17 <merijn> carlocci: I've found tryhaskell a bit flaky at times, if you're interested you might just want to grab GHC so you can play around with ghci on the commandline
03:53:29 <merijn> carlocci: Or just privmsg lambdabot, that also works :)
03:53:31 <donri> also try http://ghc.io/
03:53:32 <coleman-> donri ok I see why they didn't allow that now
03:53:46 <merijn> (Although that means no IO and only 3 seconds of computation, I think)
03:53:53 <shachaf> mm_freak_: I'm not sure what the lists and Either are for.
03:54:17 <mm_freak_> shachaf: another option is to force it to either produce or continue, in which case you can get rid of the output list, but it makes writing a Foo less convenient
03:54:20 <shachaf> What you have is no longer a free monad.
03:54:23 <merijn> shachaf: Either because it can termiante, I think and [] because it can produce multiple elements?
03:54:35 <mm_freak_> shachaf: the Either is for error cases and for switching
03:54:46 <merijn> not wrong \o/
03:54:46 <mm_freak_> shachaf: (foo1 <|> foo2) . foo3
03:55:43 <mcstar> the blinking _ is annoying
03:55:53 <beaky> When should I use Data.Sequence over Data.List or Data.Array/Vector ?
03:56:39 <mm_freak_> beaky: when you have a sequence that lives in memory completely and conses/snocs/unconses/unsnocs
03:56:43 <mcstar> i think Sequence is better with concatenation
03:56:55 <mm_freak_> Sequence is terrible at concatenation
03:56:59 <mm_freak_> (Seq)
03:57:09 <mcstar> how so?
03:57:11 <dibblego> Rope is better for concatenation
03:57:12 <mm_freak_> but you can cons and snoc
03:57:26 <Nereid> it has log-time concatenation, how is that "terrible"?
03:57:45 <beaky> what is snoc
03:57:50 <Nereid> cons backwards
03:57:52 <beaky> is it |> ?
03:57:52 <mm_freak_> Nereid: xs ++ ys doesn't do anything, until you reach the ys
03:57:54 <Nereid> (to the end)
03:57:55 <beaky> oh
03:57:56 <Twisol> shachaf: Added that out parameter. <https://gist.github.com/894eee4f5dde920515d9>
03:58:00 <beaky> so it's like push_back
03:58:03 <beaky> or append
03:58:07 <shachaf> Twisol: Yay!
03:58:11 <shachaf> Not sure that you actually need it.
03:58:14 <beaky> isn't it much slower on Sequence than List?
03:58:17 <mm_freak_> xs `S.append` ys does a lot, even if you never reach ys
03:58:20 <Twisol> shachaf: Oh, I do. Leftovers.
03:58:25 <beaky> ah
03:58:33 <Twisol> shachaf: I was actually halfway through adding it before when I decided to keep it simple.
03:58:39 <shachaf> Looks like edwardk defines this at http://comonad.com/reader/2011/free-monads-for-less-3/
03:58:43 <Twisol> shachaf: Then you suggested it for a different reason and it makes a lot of sense.
03:58:53 <Nereid> I don't think anyone's claiminig Seq is better than [] for every use case
03:58:58 <beaky> I thought Sequences had constant concatenation/append/cons and log-time index
03:59:17 <Nereid> cons/snoc are constant, concatenation is log
03:59:20 <beaky> oh
03:59:27 <Nereid> claims the doc
03:59:36 <Twisol> It amazes me, really, that this takes up less than 15 lines of actual code.
03:59:42 <carlocci> merijn: ok, I'll keep that in mind, but I was just looking for something that showed me some cool features of haskell
04:00:01 <Nereid> @faq can lambdabot show some cool features of Haskell?
04:00:02 <lambdabot> The answer is: Yes! Haskell can do that.
04:00:06 <Nereid> heh.
04:00:28 <merijn> carlocci: Ah, in that case you could also try lambdabot like I said. Although lambdabot has some...interesting and unconventional quirks :)
04:00:30 * hackagebot spy 0.4 - A compact file system watcher for Mac OS X  http://hackage.haskell.org/package/spy-0.4 (StefanSaasen)
04:00:35 <Nereid> caaaaale!
04:00:41 <Jafet> Wait till mm_freak finds out that cons and snoc are only amortized constant time.
04:00:54 <Nereid> lol
04:01:51 <Jafet> .oO( Constant time: the time needed to perform a cons. )
04:02:40 <Nereid> lol
04:03:03 <shachaf> edwardk: Hmm, now that I've actually read that post, I like that representation of IO.
04:03:14 <edwardk> shachaf: we use it here
04:04:00 <edwardk> it basically punts the denotation of IO in such a way that you can reason about things as if you have a pure language
04:04:10 <beaky> what data structure does Data.Sequence use?
04:04:13 <beaky> a vector?
04:04:14 <edwardk> no magic RealWorld tokens
04:04:15 <beaky> array*
04:04:17 <shachaf> Right.
04:04:19 <edwardk> beaky: its called a finger tree
04:04:20 <Nereid> beaky: read the doc
04:04:24 <Nereid> it'll tell you.
04:04:25 <beaky> a finger tree? what's that?
04:04:30 <mcstar> wiki
04:04:32 <Nereid> it'll tell you that too.
04:04:34 <beaky> ah
04:04:39 <shachaf> Sounds like an interesting language you have there.
04:04:46 <edwardk> beaky: http://www.soi.city.ac.uk/~ross/papers/FingerTree.html
04:04:48 * beaky googles 'finger tree'
04:04:59 <beaky> oh interesting
04:05:07 <edwardk> beaky: its a very useful data structure
04:05:14 <byorgey> beaky: also, http://apfelmus.nfshost.com/articles/monoid-fingertree.html  is a gentler introduction to finger trees
04:05:37 <edwardk> there is also http://comonad.com/reader/2010/finger-trees/
04:05:46 <beaky> ah
04:05:58 <beaky> finger trees seem awesome
04:06:03 <beaky> I wanna implement one in C++
04:06:38 <Nereid> byorgey: that article doesn't explain what it is about finger trees that gives them their name
04:06:49 <byorgey> Nereid: that's true.
04:06:59 <beaky> why are they called finger trees? is it because each node points to the right node?
04:07:09 <Nereid> no, that's a linked list.
04:07:19 <Nereid> do have a look at some of those links.
04:07:25 <Nereid> (besides the second)
04:10:12 <edwardk> @hpaste
04:10:12 <lambdabot> Haskell pastebin: http://hpaste.org/
04:10:33 <hpaste> edwardk pasted “more table goodness” at http://hpaste.org/79437
04:10:42 <Twisol> shachaf: Just defined a MonadTrans instance as well! lift a = CoroutineT $ a >>= (return . Left)
04:10:45 <Nereid> beaky: although thr short answer is that they're like ordinary trees except with fingers sticking up out the ends.
04:10:51 <Nereid> the
04:11:02 <shachaf> Twisol: Yep, it's easy.
04:11:17 <beaky> lol
04:11:19 <shachaf> Twisol: Once you figure out the type you want there's pretty much only one implementation.
04:11:21 <edwardk> i can now show tables, they can fromList/toList, you can insert, delete, check for collisions for a new record, etc.
04:11:33 <edwardk> its remarkably close to a usable API
04:11:43 <Twisol> shachaf: Yeah. It takes some mental gymnastics when you're not used to that kind of thinking thogh.
04:11:47 <Twisol> *though
04:11:49 <beaky> so finger trees look like this: http://scienceblogs.com/goodmath/wp-content/blogs.dir/476/files/2012/04/i-4addb7d7fb8c2aae0d4da2190a8f7705-stone%20fingers_478fc739a1585.jpg
04:11:59 <shachaf> Twisol: Fortunately GHC can guide you a lot in writing the code.
04:11:59 <edwardk> just needs some extra structure where you can say 'give me everything less than this key'
04:12:00 <donri> a >>= (return . Left) -- wait isn't this fmap
04:12:26 <Twisol> shachaf: Indeed - you got me addicted to ImplicitParams.
04:12:55 <shachaf> donri: Well, it's liftM
04:13:01 <shachaf> lift a = CoroutineT $ liftM left a
04:13:13 <donri> lift = CoroutineT . liftM Left
04:13:18 <Twisol> sure, make it look easy ^_^;
04:14:13 <shachaf> @pl lift a = CoroutineT $ a >>= (return . Left)
04:14:14 <lambdabot> lift = CoroutineT . (Left `fmap`)
04:14:20 <shachaf> See, lambdabot can do it too.
04:14:27 <shachaf> Except in this case lambdabot's transformation is invalid.
04:14:31 <Twisol> ...
04:14:32 <Nereid> heh
04:14:34 <donri> lol postfix fmap
04:14:41 <Nereid> heh.
04:14:51 <maus> Hi. I'm using conduit-http package to do some web scraping. Some requests fail and I need to recover. Is it possible to handle exceptions inside a ResourceIO computation?
04:15:00 <shachaf> Twisol: The only invalid part is that fmap is the same as liftM, but requires an extra Functor constraint.
04:15:11 <Twisol> Yeah. Shame, that.
04:15:23 <Jafet> @pl \y x -> x + y
04:15:23 <lambdabot> (+)
04:15:27 <Twisol> The best part about this whole exercise is that I actually understand the pipes package a lot better now.
04:15:35 <Twisol> shachaf: Thanks for all your help and guidance!
04:16:43 <shachaf> @pl \x y z -> x + (y + z)
04:16:43 <lambdabot> (. (+)) . (.) . (+)
04:16:48 <shachaf> @pl \x y z -> (x + y) + z
04:16:49 <lambdabot> ((+) .) . (+)
04:16:51 <shachaf> Hm.
04:19:31 <Jafet> Is that a positive association?
04:21:15 <neutrino> the 2006 paper on Concurrent Haskell says it was only implemented for uniprocessor systems at that point. has multiprocessing been added since that time?
04:23:10 <Jafet> Yes, you enable it using the GHC -threaded option.
04:23:31 <neutrino> thank you
04:23:46 <neutrino> is -threaded the result of the "Parallel Haskell" effort?
04:25:20 <donri> with -threaded, the green threads are run on N OS threads where N is the +RTS -N option
04:25:28 <beaky> haskell has the most beautiful syntax of almost every programming language I've ever seen
04:25:46 <mcstar> havent seen J yet?
04:26:10 <beaky> j?
04:26:21 <Jafet> -threaded is definitely the result of the effort to make GHC appear high in the shootout, which may be related to the concurrency effort or the data parallel effort but I'm not so sure.
04:27:14 <Jafet> J is the language to use for golfing when you don't want to count UTF-8 encoded iverson symbols.
04:27:15 <neutrino> beaky: yes, haskell has a very nice syntax. i wish things people do in TH quasiquoters could be done as "first class" syntax in haskell.
04:27:33 <beaky> and monad comprehensions
04:28:46 <Walther> Btw, is there a practical limit in Integer, even if ridiculously big?
04:28:54 <beaky> yes
04:28:56 <Walther> as in, how is it implemented
04:29:10 <Walther> or; what kind of a limit it will hit
04:29:17 <Nereid> it uses gmp
04:29:21 <beaky> like memory limits
04:29:29 <beaky> C has limited memory
04:29:34 <beaky> gmp is in C :D
04:29:45 <mcstar> no, your computer has limited memory
04:30:37 <Twisol> off to bed. Thanks again for the help - #haskell is awesome!
04:30:38 <mcstar> also, i have no idea how long does it take to operate on numbers gigabytes in size
04:30:43 <donri> neutrino: sugarhaskell?
04:31:50 <mcstar> but if there are intermediate results during a coputation, then that places a stricter limit on the numbers than the size of the numbers itself
04:31:52 <Jafet> Not very long, if you have gigabytes of memory.
04:32:21 <neutrino> donri: sugarhaskell? :)
04:32:59 <shachaf> Jafet: I'm storing my numbers on my tape drive, unfortunately.
04:33:01 <donri> neutrino: it's a project to make syntax extensions first-class
04:33:09 <donri> neutrino: although it's implemented with java :(
04:33:25 <shachaf> What scheme shall I use such that I can increment my number in constant time?
04:33:40 <Jafet> You can't use semi-numerical algorithms then, unfortunately. You'll need to use proper full numerical algorithms.
04:34:36 <Jafet> You know, if your tape drive happens to be unlimited at one end...
04:34:50 <beaky> lol
04:35:41 <shachaf> Jafet: My tape drive is unlimited at one end. Unfortunately I can't find that end.
04:35:46 <mcstar> if your number overflows pretty quickly, then you can implement constant time incrementation, cant you?
04:35:57 <mcstar> like a modulo 2 arithmetic?
04:36:28 <mcstar> 'incrementation' sounds pretty made up
04:36:44 <shachaf> If the size of your number is bounded, then you can increment it in constant time.
04:36:52 <shachaf> You can do most anything in constant time if your input is bounded.
04:37:04 <osa1> how can I test whether pandoc is compiled with -fhighlight or not ?
04:37:12 <mcstar> is that averaged constant time?
04:37:33 <shachaf> No, it's constant constant time (within a constant factor).
04:37:35 <mcstar> i mean, obviously, you cant increment numbers of different sizes in the same time
04:39:13 <neutrino> donri: wtf, java?
04:39:57 <mcstar> #yesod is very silent most of the time
04:40:09 <mcstar> even after questions are asked
04:40:24 <mcstar> but irc is such a good medium
04:40:45 <mcstar> i guess they want to make the answers archived, thats why they prefer SO and google groups
04:40:59 <donri> neutrino: inorite. because it came out of a "sugarj" project for the same thing in java
04:41:05 <neutrino> :\
04:41:08 <donri> http://www.informatik.uni-marburg.de/~seba/projects/sugarj/
04:42:53 <hpaste> SwashBuckla pasted “Number guesser” at http://hpaste.org/79438
04:43:05 <neutrino> donri: ugh.
04:43:22 <Jafet> So it's like the evil mangler, except it goes on the other end of the compiler
04:43:24 <neutrino> donri: so it does what.. run the .hs through a java based preprocessor?
04:43:39 <donri> no clue :)
04:43:44 <SwashBuckla> hi there, for the above game, is there a way I can store the value of (midList range) and other repeated calls?
04:44:08 <donri> neutrino: paper http://www.informatik.uni-marburg.de/~seba/publications/sugarhaskell.pdf
04:44:39 <SwashBuckla> usually I use a where clause but in this case I can't seem to use a where clause inside the do block
04:46:17 <beaky> is haskell more powerful than lisp?
04:47:47 <coleman-> is there a zip equivalent that doesn't truncate to the smallest of the two but repeats last element of the smaller list, or a user provided element
04:48:18 <SwashBuckla> oh I figured out where I can put a where clause
04:48:52 <`ramses> SwashBuckla: or use let inside the do
04:49:43 <coleman-> beaky each language has some unique features that the other doesn't
04:49:47 <beaky> ah
04:49:54 <mcstar> :(
04:50:03 <beaky> haskel has lazy evaluation that lisp doesn't
04:50:10 <beaky> and pattern matching
04:50:16 <beaky> and algebraic data types
04:50:28 <coleman-> yep
04:50:31 <mcstar> it can be retrofitted
04:50:33 <SwashBuckla> coleman-: http://stackoverflow.com/questions/3015962/zipping-with-padding-in-haskell
04:51:20 <Jafet> Nothing is more powerful than ZARDOZ
04:51:26 <beaky> zardoz?
04:51:41 <mcstar> sean connery's idea of scifi
04:51:58 <beaky> oh
04:52:19 <beaky> paul graham said that lisp is the most powerful language, and that all other languages are blub
04:52:29 <mcstar> no, he didnt say that
04:52:34 <SwashBuckla> ZARDOZ -- "Beyond 1984, Beyond 2001, Beyond Love, Beyond Death"
04:52:45 <SwashBuckla> this is brilliant
04:52:55 <Zetetic> He said that Lisp is probably blub IIRC
04:53:08 <SwashBuckla> you're blub
04:53:17 * SwashBuckla sticks tongue out
04:53:42 <zebr> hey all. is there a standard name in lambda calculus for converting a beta-redex to a let-expr?
04:54:19 <Jafet> Lambda calculus does not concern itself with trivialities such as let-exprs.
04:54:21 <orospakr> neutrino, Ralith, thanks :)
04:54:48 <deggis> a simple instance definition here: http://hpaste.org/79440 question: using variable names state, state' and state'' can introduce bugs that are somewhat hard to catch. is there an idiomatic way to write that function "safer"?
04:55:04 <Jafet> @hoogle State
04:55:05 <lambdabot> Control.Monad.State module Control.Monad.State
04:55:05 <lambdabot> Control.Monad.Trans.State module Control.Monad.Trans.State
04:55:05 <lambdabot> Graphics.UI.GLUT.State module Graphics.UI.GLUT.State
04:55:17 <coleman-> beaky it goes both ways, lisp also has things that haskell doesn't, such as homoiconicity (and nice macros that come with it), ability to recompile code at runtime, restartable exceptions to just name a few
04:55:23 <zebr> Jafet: i mean lambda calculus theory. as in, we talk about eta-reduction and contexts and metaterms and so on. although lc doesn't *have* let expressions, there may well be a term for that conversion in sugared or extended calculi...
04:55:44 <SwashBuckla> grr
04:55:47 <Jafet> > (`execState` 42) $ do x <- get; put (x + 1);
04:55:49 <lambdabot>   43
04:55:49 <SwashBuckla> hoogle somewhere else! :P
04:56:14 <Jafet> zebr: probably not.
04:56:25 <zebr> i mean, i know System Fc has lets...
04:56:27 <mcstar> it was an answer....
04:56:27 <zebr> hm :/
04:56:28 <orospakr> hey, can I ask ghci to print out the definitions of type classes?
04:56:54 <dibblego> orospakr: as in :info?
04:56:59 <neutrino> orospakr: huh, for what? :)
04:57:08 <neutrino> i guess thanks for free is good too.
04:57:32 <orospakr> neutrino, for the answer to my question about 6 hours ago about dynamic linking of the runtime
04:57:42 <Jafet> @hoogle RandomT
04:57:42 <lambdabot> No results found
04:57:45 <neutrino> are you `nand`?
04:58:30 <orospakr> dibblego, that worked, thanks :)
04:58:46 <neutrino> oh, you mean with your hello world example
04:58:59 <neutrino> (there were two dynamic linking discussions yesterday)
04:59:22 <mcstar> neutrino: did you tab complete on `nand` and still ask the question? :)
04:59:27 <neutrino> yeah, it's a bit funny but the fact that ghc does static linking means it can do very far fetched optimizations which couldn't happen otherwise
04:59:32 <neutrino> mcstar: yes.
04:59:58 <orospakr> ah, I didn't have an example. was just asking about how to dynamically link (after I noticed that even after stripping my hello world haskell ELF was ~750K), and you guys said wait until 7.6
05:00:37 <neutrino> yep
05:00:41 <neutrino> :)
05:00:57 <neutrino> you might want to read up on the tradeoffs of dynamic linking
05:01:05 <neutrino> get familiar with whole-program optimization
05:01:11 <mcstar> irc chat should be made indexable, like you could add some markup, mark things as questions, and mark other things as relevant asnwers
05:01:30 <mcstar> so a FAQ could be generated automatically from irc
05:01:30 <neutrino> sounds like a plan
05:01:45 <zebr> hmm, is there a more appropriate irc channel for questions about lambda calculus (and how i might find a certain phd thesis on it)?
05:01:58 <neutrino> here's a list of all questions: grep '?$' -ir logs/
05:02:05 <mcstar> XD
05:02:15 <mcstar> i guess google has the same logic
05:02:22 <mcstar> only with a grep implemented with mapreduce
05:02:28 <neutrino> zebr: you might try asking here.
05:03:04 <Nereid> zebr: it's also on topic for ##math
05:03:16 <Nereid> although here is probably fine too
05:03:30 <zebr> well, i was wondering if anyone knows where i might be able to find Christopher Wadsworth's thesis, "Semantics and Pragmatics of the Lambda Calculus"
05:03:45 <zebr> it's from 1971 >.>;
05:04:17 <Jafet> @google wadsworth semantics and pragmatics of the lambda calculus
05:04:19 <mcstar> university library where he graduated?
05:04:20 <lambdabot> http://thyer.name/lambda-animator/
05:04:20 <lambdabot> Title: Lambda Animator : animated reduction of the lambda calculus
05:05:06 <zebr> hm, that would be Oxford i think. i guess i could see if i could get my university library to grab it from them...
05:08:13 <neutrino> zebr: you might want to give the bodleian a call and see if they can send you a copy.
05:09:27 <mcstar> http://books.google.hu/books?id=kl1QIQAACAAJ&dq=%22Semantics+and+Pragmatics+of+the+Lambda+Calculus%22&hl=en&sa=X&ei=5WrQUN-kM4iWswb9v4DoAQ&redir_esc=y
05:10:15 <mcstar> hm, you can probably buy it
05:11:38 <Jafet> I'm sure they won't mind setting up the OUP to print one copy for you.
05:12:55 <Nereid> mcstar: google books has a lot of books/things that you can't buy.
05:13:23 <mcstar> well, there is a publicher listed
05:13:27 <mcstar> s
05:13:46 * mcstar just wanted to help
05:14:24 <zebr> appreciate it :)
05:23:46 <osa1> is there a way to specify parallel build count in cabal config file so that I don't have to type -j4 every time I run cabal ?
05:24:20 <SwashBuckla> possibly
05:24:29 <osa1> I tried "jobs: 4" but didn't work
05:24:39 <SwashBuckla> in the meantime I'd just remap cabal to cabal -j4
05:24:54 <SwashBuckla> either in your shell config, or with ln -s
05:25:00 <osa1> nice idea
05:43:26 <Eelis> if i have a .cabal enumerating 3 executables, each requiring the exact same list of build-depends, is there any way i can just put that build-depends at toplevel and not repeat it three times?
05:45:27 <edwardk> ok, i've got nested grouping working. i think thats a good time to call it a night
05:46:49 <edwardk> @hpaste
05:46:49 <lambdabot> Haskell pastebin: http://hpaste.org/
05:47:12 <hpaste> edwardk pasted “tables with nested grouping” at http://hpaste.org/79442
05:50:30 <edwardk> that seems to let me nicely extract groupings using indexed traversals
05:50:37 <edwardk> >>> fromList [Foo 0 "hello" 0.0, Foo 1 "hello" 1.2, Foo 2 "wut" 0.0, Foo 3 "wut" 0.0, Foo 4 "wut" 0.0] ^.. withIndicesOf (grouped fooBar <.> grouped fooBaz)
05:50:42 <edwardk> [(("hello",0.0),fromList [Foo {__fooId = 0, __fooBar = "hello", __fooBaz = 0.0}]),(("hello",1.2),fromList [Foo {__fooId = 1, __fooBar = "hello", __fooBaz = 1.2}]),(("wut",0.0),fromList [Foo {__fooId = 2, __fooBar = "wut", __fooBaz = 0.0},Foo {__fooId = 3, __fooBar = "wut", __fooBaz = 0.0},Foo {__fooId = 4, __fooBar = "wut", __fooBaz = 0.0}])]
05:51:48 <edwardk> Eelis: no
05:59:58 <Eelis> edwardk: ok, thanks
06:01:36 <Amoz> Hello! I'm trying to create an encapsulating data type for a BST, but I Dont want to specify the type of the Tree when I create the encapsulating data type. Any pointers ?
06:02:30 <Amoz> more specifik, it's a Dictionary with a compare function, default value, and the tree itself
06:02:49 <neutrino> show some code
06:03:55 <mcstar> there is no literal string in haskell right? stupid question i know, but i hope there is
06:04:07 <ktosiek> "string"?
06:04:08 <neutrino> myString = "foobar"
06:04:14 <mcstar> no, literal
06:04:19 <mcstar> like python's """ """
06:04:30 <neutrino> that's not what "literal" means
06:04:32 <mcstar> so i can include newlines in the natural way
06:04:42 <ktosiek> you want "multiline"
06:04:43 <mcstar> 'as is'
06:04:44 <neutrino> a literal is an inline definition of a value which evaluates to that value
06:04:46 <ktosiek> or "here-document"
06:05:07 <neutrino> there are multiple ways to do multiline strings in haskell, one of them is to use unlines on a list
06:05:11 <mcstar> not just multiline, automatic escaping too
06:05:26 <ktosiek> automatic escaping?
06:05:29 <ktosiek> oh
06:05:43 <Amoz> data Tree a b = Empty | Node a b (Tree a b) (Tree a b) deriving (Show)
06:05:44 <Amoz> data Dict l d = Dict l d Tree a b
06:05:46 <Amoz> neutrino, ^
06:05:56 <mcstar> anyway, these dont exist rgiht?
06:05:59 <mcstar> iirc they dont
06:06:07 <Amoz> the Tree needs two type variables right?
06:07:06 <mcstar> ktosiek: a literal newline is automatically escapes, so to speak, if you print back the string you will see \n, but you put in a 'real' newline
06:07:10 <mcstar> escaped*
06:07:24 <mcstar> thats why it is a more general idea than 'multiline'
06:07:44 <dgpratt> mcstar: fyi, C# refers to such things as "verbatim literal strings" (I don't know if that is standard terminology)
06:09:53 <mdittmer> Does Haskell support a way to "derive an instance with the default implementation except for one special (pattern matched) case"?
06:12:28 <opqdonut> sounds like a job for template haskell
06:13:05 <mdittmer> @opqdonut I was afraid someone would say that.
06:13:05 <lambdabot> Unknown command, try @list
06:13:15 <neutrino> Amoz: mm, don't know. maybe someone else can help.
06:13:46 <mdittmer> opqdonut: unless you were talking to someone else...
06:13:54 <opqdonut> I was talking to you :)
06:14:09 <Amoz> neutrino, thanks anyway!
06:14:21 <neutrino> well, bringing the code out will help others help you.
06:14:28 <neutrino> might want to hpaste that.
06:15:05 <dngfsdo> here there, is there any way to measure time of a function in ghci?
06:15:31 <opqdonut> yes
06:15:41 <fmap> dngfsdo: :set +s
06:15:56 <opqdonut> for more serious benchmarking, have a look at the package criterion
06:16:01 <opqdonut> (it's very easy to use)
06:16:11 <Amoz> neutrino, it's more a theoretical question than actual code. I dont know if it's the correct way to solve it at all
06:16:28 <dngfsdo> thank u very much my friend :D
06:16:56 <neutrino> Amoz: gotcha
06:17:03 <fmap> dngfsdo: if you want to benchmark you shouldn't use ghci for that though
06:25:44 <mcstar> so, i have a huge step ahead me
06:26:13 <mcstar> i dont think i have ever wanted to update a single package/metapackage through cabal
06:26:24 <mcstar> but now i do, i have to update my yesod-platform
06:26:42 <neutrino> 'we were standing at the precipice of doom, but fortunately enough we have made a big step forward'
06:27:08 <mcstar> o.O
06:28:20 <mcstar> im unsure what i should do, unregister packages, and install the new yesod-platform, or just simply install it again
06:28:32 <neutrino> install it again
06:29:03 <mcstar> wont be a problem, that there will be multiple versions of it?
06:29:12 <mcstar> *installed
06:29:45 <neutrino> not that i know of
06:30:02 <neutrino> if any problems happen, cabal install will let you know
06:30:08 <neutrino> before it continues
06:30:14 <mcstar> it needs --force-reinstalls
06:30:32 <neutrino> nuke your .ghc and install again?
06:30:52 <mcstar> but that 'nukes' all my stuff
06:31:01 <neutrino> yes
06:31:01 <Nereid> you can reinstall it all ;)
06:31:14 <mcstar> thats why i was asking, if i should unregister yesod-platform related packages
06:31:22 <neutrino> could work too
06:31:29 <neutrino> but following the deps by hand is a chore
06:31:47 <neutrino> i'm desperately waiting for the next cabal version, so that we get to use the proposed fixes
06:31:57 <neutrino> but until then it's really dire straits
06:31:59 <mcstar> im on a 200MB/month 3g plan
06:32:08 * mcstar is just kidding
06:32:08 <neutrino> the packages are in .cabal
06:32:10 <neutrino> not in .ghc
06:32:22 <neutrino> i used to be in that position for a year or so
06:32:25 <neutrino> wasn't fun
06:32:54 <mcstar> well, you dont need the packages if ghc doesnt see them..
06:33:36 <neutrino> .ghc only contains built ones
06:34:18 <mcstar> well, it only contains signatures or whatnot
06:34:18 <Nereid> .ghc only contains references to .cabal
06:38:12 <`nand`> neutrino: I am now
06:39:00 <mcstar> no, you are still not 'orospakr'
06:39:44 <`nand`> in reply to <neutrino> `nand`: hey, are you around?  at 9:01:04 my time
06:40:07 <mcstar> oh, i thought re: 'are you `nand`?'
06:41:36 <neutrino> `nand`: hey there
06:41:51 <neutrino> `nand`: i was wondering what happened to your ghc rebuild
06:43:06 <nolank> Hi everyone. In Haskell, the I combinator is id, K is const. What function is the S combinator? I can't work it out
06:43:44 <hpaste> msd pasted “Parsing JSON” at http://hpaste.org/79445
06:44:31 <mdittmer> Can anyone give me a hand with the "Parsing JSON" haste?
06:44:50 <Botje> mdittmer: you only gave one argument to parseEither.
06:45:54 <elemir> @hoogle (a -> b -> c) -> ((a -> b) -> (a -> c))
06:45:55 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
06:45:55 <lambdabot> Data.Data gmapQl :: Data a => (r -> r' -> r) -> r -> (forall d. Data d => d -> r') -> a -> r
06:45:55 <lambdabot> Data.Data gmapQr :: Data a => (r' -> r -> r) -> r -> (forall d. Data d => d -> r') -> a -> r
06:45:55 <mdittmer> Botje: even though its type is "a -> Result a -> a"? Where does it get the Result a from?
06:46:26 <Botje> mdittmer: just looking at the code I see you're only applying it to one argument
06:46:37 <Botje> parseEither (fn defaultQuery (valFromObj field obj))
06:46:53 <mdittmer> I see. Misuse of double $'s?
06:46:58 <neutrino> elemir: maybe you mean (b -> c) -> ((a -> b) -> (a -> c))?
06:47:00 <mcstar> fn cold return with a REsult a
06:47:03 <mcstar> could*
06:47:38 <nolank> elemir: is that directed at me?
06:47:54 <neutrino> no, he was just looking for something to fit his type
06:48:20 <mdittmer> Thnx Botje
06:48:27 <elemir> nolank: Yes, it is
06:48:36 <nolank> Can't tell! Often I ask a question and people respond with a lambdabot, but with no context or explanation that they're even talking to me.
06:48:40 <kranius> nolank: S = \x y z -> x z (y z)
06:48:41 <nolank> elemir: thanks, so S is (.)
06:49:26 <`ramses> nolank: I think S is <*> from applicative, and K is pure then
06:49:34 <kranius> (.) is B no ?
06:49:46 <elemir> S isn't really (.)
06:49:48 <elemir> :t (.)
06:49:50 <lambdabot> Functor f => (a -> b) -> f a -> f b
06:50:02 <`ramses> @src (<*>)
06:50:03 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
06:50:14 <elemir> @type (<*>)
06:50:16 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
06:51:01 <`ramses> if you specialise that to ((->) r) you get (r -> a -> b) -> (r -> a) -> (r -> b)
06:54:30 <nolank> I think ap is S, with monads rather than functions
06:54:55 <`ramses> nolank: exactely, and ap is the same as <*>, which I mentioned above :)
06:55:31 <`ramses> only, <*> only requires an instance of applicative, which is less restricitve then requiring a monad
06:55:51 <nolank> And the <*> name is pronounced apply with applicative isn't it?
06:56:20 <`ramses> I pronounce it like that, don't know whether there is a concensus...
06:58:40 <Clint> i've heard it pronounced /æp/
07:00:01 <neutrino> shit, i finally figured out what guido meant by saying that "reduce" is a primitive in functional languages
07:00:09 <`ramses> Clint: can you provide a "sounds like ..." for those that do not know phonetic writing? :)
07:00:16 <neutrino> he saw a definition of reduce, which calls reduce in recursion.
07:00:36 <neutrino> obvious thought: "they must be using some earlier version of reduce there"
07:01:02 <eacameron> Is there a built-in function to convert Either a b to Maybe b? Hoogle doesn't turn up anything. I'm new to Haskell so maybe I'm missing something
07:01:49 <Clint> `ramses: "app"
07:02:26 <neutrino> eacameron: maybe you could kludge something together with "either".
07:02:30 <`ramses> eacameron: either (const Nothing) Just
07:02:47 <eacameron> :t either (const Nothing) Just
07:02:48 <lambdabot> Either a a1 -> Maybe a1
07:02:55 <eacameron> `ramses: nice. thanks
07:03:09 <FireFly> :t either
07:03:10 <lambdabot> (a -> c) -> (b -> c) -> Either a b -> c
07:03:35 <FireFly> It applies the first function if it's a `Left something`, and the right one if it's a `Right somethingElse`
07:03:44 <FireFly> err, s/the right one/the second one/
07:04:06 <`ramses> FireFly: it always applies the right one ;)
07:14:21 <a|i> is ghc now on llvm?
07:17:00 <SwashBuckla> with Haddock, how do I generate syntax highlighted source code linked to from the documentation?
07:17:36 <SwashBuckla> example: http://hackage.haskell.org/packages/archive/QuickCheck/latest/doc/html/Test-QuickCheck-Gen.html
07:17:37 <b___> what's the most straightforward way to download some xml over https with Haskell?
07:17:47 <SwashBuckla> see Source link on the far right
07:18:07 <SwashBuckla> links to: http://hackage.haskell.org/packages/archive/QuickCheck/latest/doc/html/src/Test-QuickCheck-Gen.html#Gen
07:18:15 <byorgey> a|i: GHC has an LLVM backend.  But it is not the default.
07:18:47 <a|i> byorgey: can the llvm backend be used to port haskell code to arm?
07:19:03 <mcstar> just buy an intel smartphone :)
07:19:18 <byorgey> SwashBuckla: --hyperlink-source
07:19:21 <byorgey> a|i: I don't know.
07:19:28 <mcstar> there are porting topics on the haskell wiki
07:19:45 <eacameron> This is hard to read: getHeader "Authorization" >>= maybeEither . decode.   Is there a way to flip maybeEither . decode to decode ?? maybeEither so the reading goes from left to right?
07:20:04 * mcstar is thinking hard about buying an intel smartphone though
07:20:22 <byorgey> eacameron: you can use >>> from Control.Arrow.
07:20:32 <byorgey> not sure about the precedence of >>> vs >>= though
07:20:37 <`ramses> eacameron: maybeEither . decode =<< "Authorization"
07:20:42 <`ramses> is that better?
07:20:53 <eacameron> byorgey: people seem to tell me that I should ignore that Arrow exists
07:21:04 <byorgey> eacameron: you should ignore those people.
07:21:08 <wunki> could someone help me out with this error: https://gist.github.com/4328879 ?
07:21:18 <Luke> eacameron: did they give a reason?
07:21:23 <eacameron> byorgey: haha...now I don't know who to ignore
07:21:32 <byorgey> eacameron: it is not recommended to ignore that anything exists. It is not a healthy way to live.
07:21:39 <eacameron> Luke: not that I remember
07:22:18 <byorgey> eacameron: anyway, the (->) instance of Arrow often comes in handy.
07:22:21 <`ramses> eacameron: you could also just define (flip (.)) as an operator
07:22:26 <Eduard_Munteanu> eacameron: they may have said "let's ignore this for now", which is entirely different ;)
07:22:35 <byorgey> eacameron: that is, you can learn what the Arrow combinators do for functions without having to know a lot about arrows more generally.
07:22:48 <eacameron> byorgey: that sounds reasonable
07:22:58 <mcstar> wunki: i think there are 2 versions of a package installed
07:23:20 <mcstar> ghc-pkg list will list them for you, and check the relevant package
07:23:29 <mcstar> probably called 'pandoc'
07:25:11 <wunki> mcstar: that could be it, thanks!
07:31:37 <SwashBuckla> byorgey: haddock: unrecognized option `--hyperlink-source'
07:33:53 <byorgey> hmmm
07:34:55 <byorgey> SwashBuckla: oh, I forgot, --hyperlink-source is an option to 'cabal haddock' not to 'haddock'
07:35:07 <byorgey> (which is how you should be building your docs anyway)
07:35:12 <SwashBuckla> oh
07:35:21 <SwashBuckla> how do I build my docs with cabal?
07:35:31 <byorgey> cabal haddock --hyperlink-source
07:35:31 <SwashBuckla> or is this google-able..
07:35:48 <byorgey> assuming you have a .cabal file for your package.
07:35:55 <byorgey> if not, you can create one with 'cabal init'
07:38:18 <eacameron> Is Either a monad that fails on Left ...?
07:38:31 <byorgey> eacameron: yes
07:38:45 <eacameron> byorgey: do I have to import something to get that?
07:39:06 <byorgey> eacameron: perhaps, I forget where it lives now
07:39:10 <mreh> http://hpaste.org/79448 Is that a sensible binding for this function?
07:39:14 <eacameron> I'm getting  No instance for (Monad (Either a0)) arising from a use of `>>='
07:39:15 <byorgey> try Control.Monad.Instances
07:39:31 <eacameron> byorgey: how would I go about finding that (if you hadn't told me)?
07:40:11 <eacameron> byorgey: that worked btw!
07:40:19 <byorgey> eacameron: ask a different person in #haskell, I don't know =P
07:40:26 <byorgey> finding instances can actually be tricky
07:40:32 <mreh> I keep getting seg faults when calling that foreign binding and I have no idea how to debug
07:40:45 <eacameron> byorgey: haha...yeah, I was trying to figure out how I would search for that... ??
07:41:04 <hpaste> bxc pasted “test-framework-smallcheck is not building for me” at http://hpaste.org/79450
07:41:21 <`ramses> eacameron: I'd start by looking in the modules that define the type and the type class
07:41:26 <bxc> is there a way to find out if thats a problem with me or with the test-framework-smallcheck package?
07:42:07 <byorgey> bxc: looks like a problem with test-framework-smallcheck to me.  what version of GHC do you have?
07:42:11 <Eduard_Munteanu> > Left 5 >>= undefined
07:42:13 <lambdabot>   Left 5
07:42:20 <Eduard_Munteanu> > Right 5 >>= undefined
07:42:22 <lambdabot>   *Exception: Prelude.undefined
07:42:23 <byorgey> oh, 7.4.1
07:42:23 <bxc> The Glorious Glasgow Haskell Compilation System, version 7.4.1
07:42:41 <bxc> yep
07:43:13 <byorgey> weird
07:43:33 <byorgey> Hackage says it builds successfully on 7.4
07:44:27 * bxc wonders if he has some broken global packages or anything like that
07:44:34 <bxc> i blew away my ~/.cabal and ~/.ghc
07:44:47 <mreh> bxc: no biggie
07:44:59 <bxc> mreh: whats no biggie?
07:45:45 <bxc> that package (or some version of it) instaled for me yesterday
07:45:56 <bxc> with whatever was in my installed package base then
07:46:12 <byorgey> bxc: by the way, blowing away your .cabal is entirely unnecessary
07:46:22 <Botje> it's to set an example.
07:46:34 <bxc> byorgey: well i was trying to specifically figure out the dependency tree for this project
07:46:45 <byorgey> bxc: and?
07:46:49 <bxc> and i was having some mess with old package versions being all messed up
07:46:57 <bxc> old package versions conflicting with new versions
07:47:01 <byorgey> right. so delete ~/.ghc
07:47:08 <bxc> so i wanted a fresh install of it all
07:47:12 <byorgey> like I said, blowing away ~/.cabal is unnecessary =)
07:47:14 <bxc> ok
07:47:28 <typoclass> bxc: "ghc-pkg check" will tell you about broken packages, but i bet in this case, that's not the problem. i guess it's some version issue; t-f-smallcheck's .cabal file allowing some version of something that t-f-smallcheck's code is subtly incompatible with
07:47:54 <SwashBuckla> byorgey: now I'm using cabal, but cabal configure gives error "Error: No 'Main-Is' field found for executable Main"
07:48:12 <SwashBuckla> I have filled in the Main-Is field with "Main.hs".
07:48:24 <b___> sorry I asked a question but then got disconnected
07:48:26 <b___> what's the most straightforward way to download some xml over https with Haskell?
07:48:39 <byorgey> SwashBuckla: you put the Main-Is field under the 'executable' section?
07:49:01 <bxc> typoclass: ghc-pkg check on its own or what parameter?
07:49:17 <byorgey> SwashBuckla: can you paste your .cabal file on hpaste.org
07:49:27 <bxc> on its own i don't get any output (which is good?)
07:49:35 <typoclass> bxc: on its own
07:50:04 <typoclass> bxc: yup, that's good :-) but as i mentioned, i would guess it isn't the problem in this case
07:50:13 <hpaste> SwashBuckla pasted “Cabal file” at http://hpaste.org/79451
07:50:17 * bxc nods
07:50:37 <SwashBuckla> byorgey: ^
07:51:31 <byorgey> SwashBuckla: the Main-Is field is commented out, you need to remove the --
07:51:37 <SwashBuckla> lol
07:51:38 <SwashBuckla> woops
07:51:41 <byorgey> =)
07:53:16 <bxc> Data.Typeable.Internal.Typeable should be derivable if i put it in the right place, right?
07:55:17 <byorgey> bxc: yes, it is derivable if you turn on the DeriveDataTypeable extension
07:55:37 <coleman-> is there a way to compare lists by identity/address?  I want to see if two lists are the same (not if they have same elements) without Eq constraint
07:56:41 <mpu> coleman-: It would break referential transparence, so I bet there is no "clean" way to do it.
08:00:19 <fmap> coleman-: reallyUnsafePtrEquality#
08:00:30 <fmap> (you get how bad it is)
08:00:51 <mpu> @ty reallyUnsafePtrEquality#
08:00:53 <lambdabot> Not in scope: `reallyUnsafePtrEquality#'
08:01:27 <`ramses> it would be quite insane to allow such functions in lambdabot
08:01:49 <fmap> coleman-: and it's prone to false negative errors
08:02:52 <fmap> well, assuming you use it as a fast equality check
08:03:32 <mpu> It is funny though, because in OCaml it is simple == :)
08:03:52 <mpu> Does not look very frightening!
08:04:41 <`ramses> I guess haskell's laziness and sharing makes it a lot harder to define such a function in semantically correct way
08:05:03 <coleman-> I just wanted to use it for convienience. I'll rewrite my function without it
08:05:28 <mpu> It still breaks referential transparence, but OCaml guys are used to it :)
08:05:30 <coleman-> convenience*
08:06:09 <Eelis> `ramses: there are IRC bots that allow (sandboxed) execution of arbitrary machine code, so "quite insane" is a bit of an exaggeration ;) lambdabot is limited in its demonstration purposes for ideological reasons, not technical reasons
08:07:08 <`ramses> Eelis: the sandbox is then created for every run seperately? Because it wouldn't be too hard to crash the process running the command when such functions are accessible
08:07:59 <Eelis> `ramses: sandbox "creation" doesn't have to be expensive, depending on what mechanisms you use. lightweight mechanisms are available
08:08:21 <mpu> `ramses: Could you give more details, I do not see how I can crash an evaluator with this?
08:08:27 <c_wraith> lambdabot does fork a new process to evaluate expressions, though
08:08:38 <Eelis> excellent, sandboxing a single process is very doable
08:08:45 <Eelis> efficiently
08:08:58 <mpu> C guys have a bot to eval C code, I guess they use this kind of techniques to sandbox.
08:09:11 <Eelis> mpu: yeah, i wrote geordi, the C++ eval bot
08:09:12 <bxc> i added a standalone deriving typeeable into test-providers-smalcheck, which makes it instlal. i haven't tested it yet and i don't know if thats the right thing to do. but it lets me move on a bit.
08:09:12 <`ramses> but still it would require a lot more thought to ensure that the sandbox is actually safe, doesn't it? I seems like a small bug could easily lead to ways for escaping the sandbox when arbitrary code can be run
08:09:29 <mpu> Eelis: oh, so you are well informed :).
08:09:47 <mpu> Eelis: In Haskell ?
08:10:15 <Eelis> yeah. nowadays i'd implement it differently though. nowadays there's new system call filtering mechanisms that are better than ptrace
08:10:44 <mpu> So you ptrace to avoid mess.
08:10:46 <Eelis> and there's the new linux containers
08:10:50 <Eelis> yeah
08:11:31 <neutrino> Eelis: you wrote a C++ eval bot in haskell?
08:11:58 <mpu> This is awesome.
08:15:35 <bxc> ugh now something seems to be depending on quickcheck-1.2.0.1 even though i have a later version instlaled
08:16:30 <bxc> oh its |test-framework-quickcheck
08:16:31 <bxc> grrr
08:16:46 <bxc> maybe i shouldn'tuse test-framework after all
08:17:23 * bxc discovers test-framework-quickcheck2
08:24:59 <yitz> Eelis: no. lambdabot hasn't been actively developed for years. at the time, most of the limiting in lambdabot was "sandboxing", for security reasons. process sandboxing was never considered afaik.
08:35:51 <Eelis> yitz: right, and what i'm saying is that those "security reasons" aren't very strong, since safe and effective sandboxing of a single process is quite doable
08:37:34 <ziarkaen> How may I simplify the expression f m = g m m ?  Is there a standard library function for "double argument application"?
08:38:06 <b_jonas> @pl f m = g m m
08:38:06 <lambdabot> f = join g
08:38:10 <b_jonas> ziarkaen: ^
08:38:33 <ziarkaen> b_jonas, Thanks!
08:38:35 <Eelis> used for that, i'd say it's more obfuscation than improvement
08:40:34 <zebr> that is a funny one
08:49:17 <mdkess> I want to apply a function f to each element in a list, and then add them together. So I have "foldr (+) 0 (map f [1,2,3,4,5])
08:49:18 <mdkess> " - but how can I do this without the map?
08:49:44 <maybefbi> How should I read, pure id <*> v? Is it, pure ((id <*>) v) ?
08:50:00 <elliott> maybefbi: function application binds tighter than any operator
08:50:03 <elliott> so it's (pure id) <*> v
08:50:12 <tac> maybefbi: all operators bind stronger than application
08:50:16 <tac> err weaker?
08:50:19 <tac> they happen last
08:50:41 <tac> f x * y means (f x) * y, and similarly, pure id <*> v means (pure id) <*> v
08:51:17 <maybefbi> hmm can i think in terms of greediness? the functions evaluate as soon as they get a literal to evaluate
08:51:26 <`ramses> mdkess: foldr ((+) . f) 0
08:51:27 <maybefbi> would that be a correct way to phrase it?
08:51:32 <Botje> mdkess: expand that (+) into (\x y -> x + y)
08:51:41 <Botje> mdkess: and then ponder a bit what map f actually does
08:52:22 <`ramses> (maybe I shouldn't have given an answer directly)
08:52:36 <hugli> ""/quit
08:52:39 <maybefbi> elliott, tac can i think in terms of greediness? the functions evaluate as soon as they get a literal to evaluate
08:52:56 <elliott> you can think like that but it would be somewhere from really misleading to outright wrong :P
08:52:58 <tac> I wouldn't use the word "literal" there
08:53:01 <tac> but "argument", sure
08:53:09 <`^_^v> hey. i'm new. how would i get the last line of this working? http://hpaste.org/79457
08:53:23 <elliott> for instance in const "abc" (3+3), (3+3) is likely never evaluated
08:53:24 <mdkess> `ramses, Botje, thanks. Contemplating.
08:53:28 <elliott> but more importantly this has nothing to do with evaluation order
08:53:28 <M30W> Hello.
08:53:30 <elliott> it's just syntax
08:53:56 <maybefbi> elliott: yes it is just syntax
08:53:57 <M30W> Would anyone here mind telling me how the following cuts off the last character?
08:54:00 <M30W> line <- liftM init (hGetLine hdl)
08:54:12 <M30W> This is from a server socket.
08:54:24 <M30W> input 'test' output 'tes'
08:54:39 <maybefbi> elliott: how about if i say something like: "function application in haskell is left associative" would that make any sense?
08:54:42 <Enigmagic> > init "test"
08:54:44 <lambdabot>  Terminated
08:54:44 <M30W> I expect the init, but can't find what it should be
08:54:56 <M30W> > init "test"
08:54:58 <lambdabot>   "tes"
08:55:12 <elliott> maybefbi: sure
08:55:16 <elliott> a b c = (a b) c
08:55:17 <M30W> Yea, so I was right with the init. But.. What should I have instead of init for that context?
08:55:23 <elliott> but this doesn't really have anything to do with the (<*>) operator
08:55:29 <elliott> a b <*> c d is (a b) <*> (c d)
08:55:34 <Enigmagic> M30W: what do you want it to do?
08:56:11 <M30W> Enigmagic: To be exact. Taking the implement a chat server example. And creating a daemon to download files under different protocoles.
08:56:27 <Enigmagic> M30W: well i mean, what did you want it to do instead of dropping the last character?
08:56:36 <M30W> So.. I want to run it through a case, and have it have arguments.
08:56:46 <M30W> Enigmagic: to keep it?
08:57:04 <Enigmagic> M30W: "line <- hGetLine hdl"
08:57:29 <M30W> Heh
08:57:32 <M30W> Thanks
08:57:35 <Enigmagic> np :)
08:57:59 <M30W> That makes so much sense :P
08:59:02 <Enigmagic> liftM/fmap/<$> apply some function to the result of an action. so you were saying 'give me a line, then run init on it'
08:59:21 <hpaste> msd pasted “Exceptions in generic JSON parsing” at http://hpaste.org/79458
09:00:54 <mdittmer> Can anyone explain what's wrong with "Exceptions…" hpaste? It seems to me that since the only instance of Nullable foo that is a JSON requires foo to also be a Data and a Typeable the types should check out.
09:01:35 <mdittmer> No amount of adding "(Data b, Typeable b, JSON b) => " fixes the compilation error.
09:02:15 <Enigmagic> mdittmer: what's the compilation error?
09:02:18 <hpaste> msd annotated “Exceptions in generic JSON parsing” with “Exceptions in generic JSON parsing (annotation)” at http://hpaste.org/79458#a79459
09:03:32 <hpaste> msd annotated “Exceptions in generic JSON parsing” with “Exceptions in generic JSON parsing (annotation) (annotation)” at http://hpaste.org/79458#a79460
09:03:43 <mdittmer> hpaste annotated with error.
09:04:07 <mdittmer> Following the suggestions to further annotate the T (Nullable b) do not seem to help though.
09:05:17 <hpaste> Enigmagic annotated “Exceptions in generic JSON parsing” with “Exceptions in generic JSON parsing (annotation) (annotation) (annotation)” at http://hpaste.org/79458#a79461
09:05:31 <Enigmagic> mdittmer: try something like that, i didn't try compiling it so it might need a little work
09:07:17 <Enigmagic> mdittmer: scoped type variables allows you to reference type variables introduced with a forall
09:09:44 <mdittmer> No luck.
09:09:59 <mdittmer> Could not deduce (JSON a) arising from a use of `showJSON'
09:12:51 <sclv__> syb generics are closed
09:13:00 <sclv__> you can't just post-hoc "extq"
09:13:28 <sclv__> you can use new generics, or give up on the generic approach :-(
09:15:51 <mdittmer> Unfortunate. Why is it that Text.JSON.Generics can use SYB then? because it has no type variables?
09:16:42 <M30W> googlefix f = let x = f x in x
09:17:02 <M30W> fix f = let x = f x in x
09:17:11 <M30W> Anyone mind explaining what teh hell that means?
09:17:25 * M30W is stuck in a loop for understanding.
09:17:26 <johnw> are you asking what the fixed point combinator is?
09:17:34 <M30W> johnw: kinda
09:17:42 <johnw> http://en.wikipedia.org/wiki/Fixed-point_combinator
09:18:36 <M30W> So... It duplicates a variable for use in another function?
09:19:04 <johnw> i would google for fixed point combinator and keep reading
09:19:26 <Enigmagic> mdittmer: no idea, we use aeson not the json package
09:19:36 <johnw> it finds the least fixed point of any function, which for many functions is ⊥ (i.e., non-termination)
09:20:05 <M30W> Okay
09:20:10 <johnw> one of its handier properties is that you can use it to define recursive lambdas
09:20:32 <johnw> > let g = fix $ \f x = if x == 0 then 0 else f x in g 10
09:20:34 <lambdabot>   <hint>:1:20: parse error on input `='
09:20:40 <johnw> > let g = fix $ \f x -> if x == 0 then 0 else f x in g 10
09:20:43 <lambdabot>   mueval-core: Time limit exceeded
09:20:44 <M30W> http://ix.io/3Gg
09:20:51 <johnw> > let g = fix $ \f x -> if x == 0 then 0 else f (x - 1) in g 10
09:20:52 <lambdabot>   0
09:20:58 <johnw> that's a stupid way to make a zero :)
09:21:23 <M30W> johnw: Any suggestions for this loop.. I really need to learn more about haskell loops. I want it to forever loop unless the conection dies or the client says quit
09:21:40 <M30W> link hidden in your bot fun ^_^
09:21:50 <johnw> that's basically the same as calling forever, isn't it?
09:22:02 <M30W> johnw: Yes?
09:22:22 <lispy> M30W: I think the easiest way to understand fix is to expand the RHS out one step at a time
09:22:42 <M30W> lispy: expand RHS for me :)
09:22:55 <lispy> let's use this definition: fix f = f (fix f)
09:23:02 <lispy> :t fix f = f (fix f)
09:23:04 <lambdabot> parse error on input `='
09:23:10 <lispy> :t let fix f = f (fix f) in fix
09:23:11 <lambdabot> (t -> t) -> t
09:23:23 <lispy> M30W: do you agree that's the same function?
09:23:38 <M30W> lispy: As what?
09:23:49 <lispy> M30W: RHS = right hand side, as in the right hand side of the definition
09:24:02 <lispy> M30W: fix f = f (fix f) is the same as fix f = let x = f x in x
09:24:45 <lispy> M30W: I find fix f = f (fix f) to be easier to expand out
09:25:12 <lispy> fix f = f (fix f), now apply definition of fix again: f (fix f) ==> f (f (fix f)
09:25:55 <M30W> Yea
09:26:43 <lispy> if you keep expanding you see that it's always of the form f (f (f ... (fix f)
09:26:45 <M30W> lispy: I think you're a bit behind for what I was talking about after the fix..
09:26:52 * M30W wants to fix his loop
09:26:58 <lispy> oh
09:27:04 <lispy> I thought you were asking how fix works :)
09:27:27 * M30W understands the recusion of fix but yea.. Bit confusing but I'm pretty sure I understood it before you started talking; but you confused me more haha
09:27:41 <lispy> you're welcome ;)
09:27:41 * M30W is archeyDevil for the record.
09:27:59 <M30W> This loop... Suggestions?
09:28:01 <lispy> confusing explanations are free all this week
09:28:03 <M30W> http://ix.io/3Gg
09:29:15 * M30W contemplating about using the MPD protocole as a way to download files over many different protocoles. Lol. No need to write another client haha.
09:29:19 <johnw> what suggestion are you asking for?
09:29:46 <M30W> johnw: to infinitly loop unless the connection dies or the client sends 'quit'
09:29:52 <johnw> you could replace "fix $ \loop -> do" in that code with "forever $ do", and then you can drop the line that calls loop at the bottom
09:29:56 <M30W> So.. Better loop management
09:30:05 <johnw> oh
09:30:07 <johnw> use interact
09:30:20 <johnw> it's pretty much designed for what you're doing :)
09:30:31 <M30W> interact?
09:30:37 <lispy> :t interact
09:30:38 <lambdabot> (String -> String) -> IO ()
09:30:49 * M30W made that loop -> forever change.
09:31:02 <M30W> johnw: How to use?
09:31:16 <johnw> interact (unlines . f . lines)
09:31:33 <M30W> O.o
09:31:40 <johnw> then have your f be the body of your loop
09:31:58 <M30W> You've lost me.
09:32:09 <johnw> ok, what the interact line does it that it calls f for every line of the input
09:32:19 <johnw> when, if it's stdin, will run forever
09:32:21 <M30W> http://ix.io/3Gh
09:32:23 <M30W> current code
09:32:43 <M30W> johnw: socket, kinda stdin. But tcp version ;)
09:33:34 <lispy> M30W: if you use forever the only way out is exceptions, BTW
09:33:47 <johnw> oh, you want quitting behavior?
09:33:53 <M30W> johnw: Yes
09:34:07 <M30W> lispy: exceptions.. Okay
09:34:17 <johnw> MaybeT IO () would work
09:34:36 <mreh> could someone take a quick look at this and suggest why createSpotifySession might be causing a seg fault? http://hpaste.org/79465
09:34:36 <M30W> Wha..?
09:35:05 <M30W> lispy: How to use the exception to close the loop?
09:35:35 <lispy> M30W: I could explain that, but if I were doing this I'd actually rewrite your example
09:35:47 <lispy> @hoogle throwError
09:35:47 <lambdabot> Control.Monad.Trans.Error throwError :: (Monad m, Error e) => e -> ErrorT e m a
09:35:47 <lambdabot> Control.Monad.Error.Class throwError :: MonadError e m => e -> m a
09:35:47 <lambdabot> Control.Monad.Error throwError :: MonadError e m => e -> m a
09:35:48 <M30W> lispy: I'm not stopping you ^_^
09:36:04 <M30W> Hmm... Have to literally throw an error???
09:37:06 <lispy> M30W: I'd define a function processInput = do line <- hGetLine hdl; ...; "quit" -> hPutStrLn hdl "KTHXBAI!"; _ -> processInput
09:37:37 <lispy> M30W: does that make sense?
09:38:31 <lispy> M30W: as far as throwing an error is concerned, exceptions are extensible and you could define a "TerminateForeverLoop" exception
09:38:36 <M30W> http://ix.io/3Gi
09:38:40 <M30W> Whole file..
09:38:49 <M30W> And Yea, makes sense.
09:38:55 <lispy> M30W: But, IMO using exceptions for something you except is a bad idea. Exceptions are better used for exceptional cases.
09:39:35 <lispy> expect*
09:39:37 <M30W> lispy: Yea. That's why I didn't like the idea of throwing an error to do it
09:40:15 <M30W> lispy: Feel free to re-write my program :P
09:40:35 <lispy> M30W: the cool thing about the "processInput" style suggestion is that you're basically doing it already with your mainLoop
09:40:46 <lispy> Just that mainLoop lacks the exit case
09:41:02 <lispy> And you add that by not calling yourself recursively
09:41:35 <lispy> :t Bool -> IO a -> IO b
09:41:37 <lambdabot> parse error on input `->'
09:41:42 <lispy> @hoogle Bool -> IO a -> IO b
09:41:42 <lambdabot> Control.Exception.Base finally :: IO a -> IO b -> IO a
09:41:43 <lambdabot> Control.Exception finally :: IO a -> IO b -> IO a
09:41:43 <lambdabot> Control.OldException finally :: IO a -> IO b -> IO a
09:42:06 <M30W> lispy: Please write the code for what you just explained cause I'm confused and will understand the code if it's there.
09:42:42 * M30W can read almost all haskell; sometimes slowly; but I understand it nether the less. I'm learning on writing it, and for that I need to understand more :D
09:42:56 <M30W> reading examples = formal teaching for me.
09:43:55 <otters> M30W: I understand
09:45:16 <mdittmer> Enigmagic: Do you have a particular rationale for using Aeson over JSON?
09:45:27 <M30W> lispy: Are you writing it up or gone afk?
09:45:35 <M30W> Or doing something else.
09:46:54 <hpaste> lispy pasted “for M30W” at http://hpaste.org/79467
09:47:18 <hpaste> lispy annotated “for M30W” with “for M30W (annotation)” at http://hpaste.org/79467#a79468
09:47:25 <lispy> M30W: something like that
09:47:33 <lispy> M30W: I do need to get back to work though
09:47:41 <ziarkaen> I am using the working: main = firstMonad >> (myMonadicFuntion $ do <lots of stuff>)  How may I remove the parens?
09:47:49 <M30W> lispy: I like that something......
09:47:57 <M30W> lispy: It just looped my "disconnect'
09:48:16 <johnw> ziarkaen: you don't, in that case
09:49:10 <johnw> M30W: still here?
09:49:20 <madjestic> hey guys, I am getting the same error: http://hpaste.org/76710   Any ideas how to fix it?
09:49:33 <ziarkaen> johnw, main = (>>) firstMonad  $ myMonadicFuntion $ do <lots of stuff> seems to work.  Is this unidiomatic?
09:49:37 <hpaste> johnw pasted “M30W.hs” at http://hpaste.org/79469
09:49:40 <ClaudiusMaximus> ziarkaen: you can quux = (foo >>) . bar $ do .....    to avoid the trailing ) at the end of everything
09:49:56 <johnw> M30W: that pastie implements an interpreter that supports "quit"
09:49:56 <M30W> fixed
09:50:01 <M30W> and you did this..
09:50:02 <johnw> without exceptions
09:50:40 <johnw> ziarkaen: ah, that would work, but it's highly unidiomatic :)
09:51:00 <johnw> i would do this:
09:51:02 <ziarkaen> johnw, OK, I'm using then ClaudiusMaximus solution.
09:51:19 <M30W> johnw: It's working already.
09:51:20 <ClaudiusMaximus> probably most idiomatic would be main = do { foo ; bar $ do ... }  and use layout instead of {;}
09:51:21 <johnw> main = do <RET> firstMonad <RET> myMonadicFuntion $ do <lots of stuff>
09:51:23 <M30W> lispy: helped
09:51:31 <johnw> M30W: yeah, but exceptions are just not necessary
09:51:31 <M30W> lispy: Thankyou very much ^_^
09:51:39 <M30W> johnw: Not using exceptions
09:51:52 <M30W> johnw: They were just suggested for that forever loop
09:51:55 <johnw> oh, I see what he did
09:52:38 <M30W> Just needed a little patching cause it wasn't exact but yea
09:52:44 <hpaste> johnw pasted “M30W2.hs” at http://hpaste.org/79470
09:52:53 <johnw> there, that's using his idea
09:53:17 <johnw> and I suppose "go" isn't needed either
09:53:20 <lispy> You could then take this further and externalize the control flow
09:53:34 <johnw> yeah, it's not
09:53:40 <hpaste> johnw pasted “M30W3.hs” at http://hpaste.org/79471
09:53:44 <lispy> data Loop = Terminate | KeepGoing; and then return the appropriate one instead of calling yourself recursively.
09:53:54 <johnw> hm.. wondering why it's not annotating
09:54:00 * lispy goes back to fortran
09:54:07 <johnw> fortran?
09:54:08 <lispy> (not writing it, just transforming it with haskell)
09:54:43 <lispy> johnw: yeah, we have a DoE funded project to build tools for fortran programmers
09:55:26 <johnw> huh
09:55:30 * lispy wishes we had something on the company blog to link to
09:55:38 <johnw> I didn't know Galois did non-Haskell sutff
09:55:57 <M30W> johnw: current -> http://ix.io/3Gj
09:56:25 <M30W> johnw: Any suggestions for that nasty user variable being passed around, could that be made available without passing?
09:56:56 <johnw> State monad would work, or use ST as a quick hack
09:57:05 <johnw> it would need to be StateT
09:57:08 <M30W> processInput user hdl -- append that line to that program
09:57:10 <sclv> mdittmer: you can use SYB to define a class with extQs. but you have to do it "all at once"
09:57:25 <M30W> johnw: You've lost me.
09:57:35 <sclv> the limitation, and one (very complicated) solution to it is described in the "scrap your boilerplate with class" paper
09:57:58 <johnw> M30W: StateT <Type of ugly record> IO ()
09:58:10 <johnw> then ugly record is in the "environment" for all functions in that monad
09:58:23 * M30W still lost.
09:58:23 <johnw> but for code this small, i'd just pass the info around
09:58:26 <johnw> n/m then
09:58:36 <johnw> it's not worth it for code this small
09:58:41 <krautguy> !nextshow
09:58:46 <M30W> johnw: For now it's small.
09:59:12 <M30W> But intended use includes a bit more.. I.e downloading files at the same time, and checking their progress.
09:59:55 <M30W> Program = download daemon.
10:00:03 <Enigmagic> mdittmer: i use GHC.Generics extensively and don't like writing class instances, aeson helps out in this regard
10:00:22 <M30W> Based from chat server :P http://www.haskell.org/haskellwiki/Implement_a_chat_server -- suitable server base.
10:02:01 <mdittmer> One thing that I don't like about (what I've seen so far) from Aeson is that if I have a field foo :: Bar where Bar = Alpha | Beta | Gamma, I get …foo: {Alpha: []}… rather than just …foo: "Alpha"
10:02:46 <mdittmer> Enigmagic: The above gets in the way of composing requests using a fixed set of alternative string values for a request parameter… unless I'm missing something
10:03:36 <Enigmagic> mdittmer: i'd guess that is to support cases like 'Bar = Alpha String | Beta | Gamma Int'
10:04:09 <mdittmer> Enigmagic: I figured as much, but JSON checks for arity-0 constructors, which I guess Aeson doesn't .
10:05:06 <Enigmagic> mdittmer: yeah, i suppose if the parser can handle either case it should pump out the better looking version when serializing.
10:05:10 <M30W> johnw: ping
10:05:26 <johnw> hello
10:05:38 * hackagebot snowball 0.1.0.2 - Bindings to the Snowball library.  http://hackage.haskell.org/package/snowball-0.1.0.2 (DagOdenhall)
10:05:45 <Enigmagic> mdittmer: but you can always write your own instance if you want it formatted in one particular way. i don't use it as part of a public API so i don't really care :-)
10:05:48 <M30W> johnw: Any suggestion for what I should do now with the program?
10:05:55 <johnw> no
10:05:58 <`nand`> what's the simplest HTTP package around, assuming I want to run both a client and a server?
10:05:58 <M30W> :(
10:06:01 <johnw> i've moved on to my work task
10:06:16 <M30W> johnw: Okay, sorry. Resume ^_^
10:06:30 <M30W> s,Resume,Continue,
10:08:06 <johnw> calling loop on myself.. :)
10:08:18 <M30W> johnw: Huh?
10:08:24 <otters> anybody here use optparse-applicative?
10:08:35 <johnw> nothing, an attempt at fix combinator humor
10:08:41 <johnw> otters: not yet, but I want to
10:08:53 <otters> yeah, I'm trying to figure out how to put in optional options
10:09:03 <otters> because the guide makes no mention of that and I fear it doesn't support them
10:09:15 <M30W> johnw: Mind just one last thing?
10:09:30 <johnw> yes?
10:09:32 <luite> otters: i think you can make them optional by giving them a default
10:09:43 <johnw> luite!
10:09:50 <johnw> luite: what process do you use for mirror Hackage?
10:09:53 <M30W> http://ix.io/3Gk - 18/20, one line looping.... How could that be better written?
10:09:56 <M30W> I.e forever?
10:10:03 <otters> luite: how do you do that
10:10:06 <luite> johnw: oh it's just part of the hdiff scripts
10:10:16 <johnw> luite: are those scripts public?
10:10:17 <luite> johnw: download the package index every 5 minutes
10:10:37 <johnw> i'm using a script right now, but the results are not the same as using Hackage directly
10:10:47 <johnw> for instance, cabal install hoogle thinks that Hoogle 3.2 is the newest version
10:10:47 <luite> but it does download them to the wrong directories, so i need some extra nginx rewrite rules
10:10:53 <johnw> ah
10:10:58 <otters> oh
10:11:00 <M30W> johnw: ^^
10:11:13 <luite> johnw: https://github.com/luite/hdiff
10:11:14 <johnw> M30W: sorry M30W, no ideas
10:11:20 <M30W> :(
10:11:49 <johnw> luite: where are your rewrite rules?
10:12:40 <luite> otters: see here for some optional options, Maybe String, https://github.com/yesodweb/yesod/blob/master/yesod/main.hs
10:12:41 <`nand`> Warp advertises it as ‘A fast, light-weight HTTP server handler for WAI.’ <- WAI?
10:12:45 <otters> luite: yeah, I found it
10:12:46 <luite> dunno if it's the best way to do it
10:12:49 <`nand`> are they referring to ‘Web Accessibility Initiative’?
10:12:57 <luite> `nand`: no
10:13:01 <`nand`> then what?
10:13:03 <johnw> cabal info wai
10:13:08 <thoughtpolice> 'web application interface', it's basically our equivalent of ruby's rack
10:13:12 <`nand`> oh
10:13:15 <`nand`> I see
10:13:16 <luite> i think web application interface, it's just a general purpose web middleware for haskell
10:13:49 <luite> johnw: 1 moment
10:13:55 <neutrino> @tell typoclass let me know when you're around, i've just had an idea for your progress display thing
10:13:56 <lambdabot> Consider it noted.
10:15:18 <luite> johnw:  location ~ ^/packages/archive/package/(.*)-(.*)\.tar\.gz$ { alias /home/hdiff/hdiff/archive/$1/$1-$2.tar.gz; }
10:15:44 <johnw> ah, I see what you mean
10:15:47 <luite> i also have an apache rewrite rule somewhere, since the old server (hdiff.luite.com) runs apache, the new one (hdiff-test.luite.com) runs nginx
10:16:02 <johnw> thanks for the info, luite
10:19:36 <neutrino> so since saturday i've learnt about stm, and applicative
10:19:50 <M30W> > [a,b] = words "test tester"
10:19:51 <lambdabot>   <hint>:1:7: parse error on input `='
10:19:55 <neutrino> that's really good, haskell started making sense
10:19:59 <M30W> Any suggestions?
10:20:02 <neutrino> M30W: you're missing a "let"
10:20:06 <M30W> > let [a,b] = words "test tester"
10:20:08 <lambdabot>   not an expression: `let [a,b] = words "test tester"'
10:20:15 <M30W> > let [a,b] = words "test tester" in a
10:20:16 <lambdabot>   "test"
10:20:18 <M30W> > let [a,b] = words "test tester" in b
10:20:21 <lambdabot>   "tester"
10:20:25 <M30W> > let [a,b] = words "test tester testing" in b
10:20:27 <lambdabot>   "*Exception: <interactive>:3:5-39: Irrefutable pattern failed for pattern [...
10:20:42 <neutrino> you can also do that in a /query with lambdabot btw
10:20:51 <neutrino> i use it all the time
10:20:52 <M30W> neutrino: What I'm after is.. a with the first word. b with the rest.
10:20:54 <neutrino> really useful
10:20:56 <M30W> Suggestions?
10:21:00 <neutrino> sure
10:21:03 <`nand`> does Warp only do (Request -> Response)-type servers? I need to build something that asynchronously sends requests and responses as-needed. Does HTTP even allow that?
10:21:32 <neutrino> `nand`: explain "asynchronously sending responses"
10:21:47 <neutrino> you might be looking for websockets, comet, etc
10:21:53 <c_wraith> http doesn't really allow that... exactly.  There are workarounds
10:22:00 <neutrino> M30W: what does words stringhere give you?
10:22:01 <`nand`> neutrino: over a single connection which I want to keep alive; I want to send requests and responses in no particular order
10:22:07 <c_wraith> that's not http
10:22:10 <`nand`> okay
10:22:16 <zomg> Sounds like you want web sockets or something similar
10:22:19 <M30W> neutrino: an array of words
10:22:22 <c_wraith> however, things like comet or websockets will do that
10:22:22 <neutrino> no
10:22:24 <neutrino> a list of words
10:22:27 <neutrino> close enough though
10:22:35 <`nand`> ‘comet’?
10:22:35 <M30W> Yea..
10:22:46 <neutrino> `nand`: what people did before websockets.
10:22:49 <zomg> `nand`: catch-all term for http push
10:22:58 <zomg> ajax long polling, server sent DOM events, iframe push, etc.
10:23:07 <M30W> neutrino: With a string it's as easy as (a:b) = "test"
10:23:08 <M30W> I think
10:23:08 <`nand`> any haskell libraries for it?
10:23:11 <neutrino> M30W: so you want something that is made out of the first one, and something that is made out of the rest
10:23:17 <c_wraith> `nand`: use websockets instead
10:23:18 <M30W> > let (a:b) = "test" in a
10:23:19 <M30W> > let (a:b) = "test" in b
10:23:19 <lambdabot>   't'
10:23:21 <lambdabot>   "est"
10:23:23 <M30W> Yea
10:23:25 <neutrino> M30W: here's a hint, a string is a list of chars
10:23:30 <neutrino> type String = [Char]
10:23:33 <M30W> neutrino: I basicly want that with the words.
10:23:34 <`nand`> any haskell libraries for websockets?
10:23:36 <c_wraith> yes
10:23:41 <neutrino> (x:xs) is a pattern-match on a list
10:23:49 <neutrino> it has nothing to do with String specifically
10:23:52 <`nand`> oh, imaginatively named ‘websockets’
10:24:03 <M30W> neutrino: Wait.. So I was on the right track?
10:24:14 <zomg> I wonder if there's anything like socket.io for haskell
10:24:15 <neutrino> depends with what :)
10:24:17 <M30W> > let (x:xs) = words "this is a test" in xs
10:24:19 <lambdabot>   ["is","a","test"]
10:24:24 <neutrino> yeah
10:24:25 <M30W> > let (x:xs) = words "this is a test" in unwords xs
10:24:27 <lambdabot>   "is a test"
10:24:29 <zomg> 'cause support for websockets is sort of lacking in browsers still
10:24:29 <M30W> :)
10:24:34 <neutrino> there you go
10:24:36 <M30W> Thankyou, so I was close. :D
10:24:46 <neutrino> yep
10:24:47 <zomg> (socket.io is an abstraction on top of websockets with backwards compatibility for other methods when sockets are not available)
10:24:47 <`nand`> zomg: I'm writing the client as well
10:24:53 <neutrino> haskell reuses a lot of stuff everywhere
10:24:55 <`nand`> so I don't care about any browser support in particular
10:24:59 <neutrino> and that shows up in different places
10:25:04 <M30W> In my code.. I was missing the let
10:25:06 <M30W> lol
10:25:09 <zomg> `nand`: that's good then =) was just wondering in general
10:25:16 <neutrino> so you'll learn to use something, in a specific case
10:25:29 <neutrino> and you'll later find out that it has much broader applications
10:25:35 <donri> > unwords . tail . words $ "this is a test"
10:25:37 <lambdabot>   "is a test"
10:25:47 <shergill> yep, haskell is lazy
10:25:54 <neutrino> shergill: heh
10:26:09 <M30W> donri: I want them seperate
10:26:11 <M30W> For use with both
10:26:18 <M30W> So what I have is what I need
10:26:37 <neutrino> use a let block
10:27:10 <donri> > liftA2 (,) head (unwords . tail) $ words "this is a test"
10:27:11 <lambdabot>   ("this","is a test")
10:28:14 <donri> M30W: although i suggest using a case..of so you can cover the empty string case
10:28:45 <donri> > let (x:xs) = "" in (x,xs)
10:28:47 <lambdabot>   (*Exception: <interactive>:3:5-15: Irrefutable pattern failed for pattern (...
10:29:19 <neutrino> he doesn't need case
10:29:30 <neutrino> he just needs to pattern-guard his function
10:29:59 <M30W> donri: I am using a case.
10:30:13 <donri> or a pattern matching function yea
10:30:16 <hpaste> neutrino pasted “let block” at http://hpaste.org/79474
10:30:17 <M30W> donri: I'm splitting a base word/function from arguments for that.
10:30:45 <M30W> case x of ... ++ unwords xs ...
10:31:27 <donri> neutrino: why are you doing an at-pattern there
10:32:07 <M30W> @hackage tolower
10:32:08 <lambdabot> http://hackage.haskell.org/package/tolower
10:32:14 <M30W> @hoogle tolower
10:32:15 <lambdabot> Data.Char toLower :: Char -> Char
10:32:15 <lambdabot> Data.Text toLower :: Text -> Text
10:32:15 <lambdabot> Data.Text.Lazy toLower :: Text -> Text
10:35:52 <M30W> Wed Dec 19 05:35:34 EST 2012
10:35:54 <M30W> Hmmmm....
10:40:06 <ch33sus__> is there support for "medium" multicore systesms like 8 to 16 cores for haskell?
10:40:34 <neutrino> donri: so that the thing can easily be referred to by one word.
10:41:07 <neutrino> i guess if the string is " " it will still match though, so my code sucks.
10:41:31 <donri> neutrino: yea but you're not using the char:chars ones
10:41:33 <donri> only sentence
10:42:05 <neutrino> they're exactly the same thing
10:42:22 <neutrino> i was trying to use that pattern to ensure the string would yield at least one word
10:42:43 <neutrino> thinking it's enough that the string is not empty
10:42:46 <donri> oic what you're going for
10:42:46 <neutrino> which was incorrect
10:42:51 <donri> though you could use _ for those patterns
10:42:59 <neutrino> i guess
10:43:01 <M30W> neutrino: are you neutrak
10:43:03 <M30W> ?
10:43:07 <neutrino> no
10:43:10 <M30W> Okay
10:43:19 <M30W> (On diff net btw)
10:44:34 <`nand`> c_wraith: do you have any experience with websockets? In particular, I'm allocating some resources when a connection is made; and I want to ensure they get deallocated properly when the connection is lost
10:44:54 <`nand`> should I use something like Control.Exception.bracket? That fires when the resource gets GC'd, right?
10:45:42 <c_wraith> `nand`: No experience.  Something like bracket *should* apply, but be very careful of the context.. Control.Exception.bracket works, but MonadCatchIO's bracket basically doesn't work.
10:45:55 <`nand`> okay
10:46:19 <`nand`> the monad I'm working in is MonadIO; so I'd just be using C.E.bracket via liftIO
10:46:29 <c_wraith> that's fine.
10:47:00 <`nand`> oh, wait, this is problematic
10:47:21 <`nand`> bracket's ‘computation’ needs to live in IO as well; so I can't actually use any of the WebSockets stuff in there
10:50:16 <`nand`> hrm; this is actually more problematic than I had anticipated
10:50:45 <c_wraith> well, you could lean on the garbage collector
10:50:45 <`nand`> this also means I can't use ‘forkIO’ to send and receive WebSockets stuff either
10:50:55 <`nand`> concurrently, that is
10:50:58 * M30W is several steps away from turning his program into a honeypot lol
10:51:08 <M30W> Just host on port 23 and let the world access :P
10:51:30 <c_wraith> `nand`: you're using yesod?
10:51:34 <`nand`> c_wraith: no
10:51:40 <`nand`> c_wraith: package ‘websockets’
10:51:45 <c_wraith> no, as the server
10:51:54 <`nand`> yes; as the server
10:52:00 <`nand`> http://hackage.haskell.org/packages/archive/websockets/0.7.1.1/doc/html/Network-WebSockets.html#v:runServer
10:52:43 <c_wraith> Huh.  Is there some reason you're doing this as a web server?
10:52:55 <`nand`> what do you mean?
10:53:07 <c_wraith> I mean, websockets is for when you're integrating into a web application - which generally means you need a full web server to do everything else.
10:53:15 <`nand`> the protocol has to be HTTP
10:53:19 <`nand`> firewall
10:53:44 <M30W> websocks are stfu I WANT IRC
10:53:45 <M30W> lol
10:54:03 * M30W might make a tiny http->irc proxy with auth to fix that lol.
10:54:29 <c_wraith> I feel like you're solving this problem in the wrong way.
10:54:30 <`nand`> oh
10:54:39 * M30W already has zsh irc<->mpd, and other multiple protocole bindings so wouldn't be hard :)
10:54:46 <`nand`> WebSockets has ‘sendSink’ and ‘getSink’ which live in IO
10:54:49 <`nand`> perfect
10:54:57 <`nand`> that makes things easier
10:55:09 <`nand`> never mind my worries then
10:55:12 <M30W> Oh I read websockets as in html5.. Whoops ^_^
10:55:16 <c_wraith> Note that runServer probably (check the source) forks per request anyway
10:55:34 * M30W smels burning plastic....
10:55:40 <M30W> Asus, are you melting?
10:55:41 <c_wraith> Meaning there's exactly zero benefit to forking again for websockets (in addition to probably not working anyway)
10:55:49 <M30W> YES D:
10:56:17 <`nand`> I'm not sure how I'd do this without forking, quite frankly
10:56:32 <c_wraith> Just don't fork for the websockets communication.
10:57:06 <c_wraith> You can fork for *other* stuff. But the whole point of the handler function is that when it returns, the request is over.
10:57:24 <`nand`> then how do I receive and send at the same time? Suppose the following contrived example: every 3 seconds, I want to send “FOO” to the client (via sendTextData); but whenever the client sends me something, I want to print it to the terminal immediately
10:57:39 <`nand`> the idea would be to fork off one thread that sends “FOO” every 3 seconds with a time; then just loop receive >>= print
10:57:58 <lispy> I've just run into a place where I want to use list for the comprehensions and monad instances, but I want Data.Set for the uniqueness property.
10:58:22 <c_wraith> I suppose that works, so long as the handler doesn't terminate too early
10:58:25 <lispy> Eg., I wish for a Monad and MonadPlus instances for Set and monad comprehensions
10:59:45 <ziarkaen> Why does filter (elem ['a'..'z']) "abasad" fail with error [[[Char]]] /= [Char] ?
11:00:16 <donri> ziarkaen: you want (`elem` ...)
11:00:19 <clahey> lispy: I've been thinking of writing a MonadDictionary typeclass which has implementations based on Map, association lists, and an IO implementation that supports hash tables.
11:00:29 <ziarkaen> donri, Ah, of course.  Thanks
11:00:34 <clahey> lispy: It'd be interesting to make a MonadSet typeclass at the same time.
11:00:41 <ziarkaen> donri, There's 5 minutes burned... :/
11:00:46 <donri> :)
11:00:56 <elliott> lispy: what's wrong with using Set.fromList?
11:01:01 <elliott> you can define a set monad but it is very inefficient
11:01:06 <clahey> Oh, it already exists.
11:01:10 <elliott> about as inefficient as just using fromList
11:01:25 <lispy> elliott: I guess I'd just be going toList/fromList pretty much everytime I use it
11:01:48 <elliott> well, you could keep it in list form to avoid the toLists
11:01:48 <clahey> Oh, it exists, but it's not what I want.
11:01:58 <lispy> And that seems silly. I might as well just 'nub' the list and pay the quadradic price
11:02:55 <elliott> it sounds like you're going to pay some price anyway :P
11:02:56 <clahey> Oh, perhaps ST is what I want.
11:04:09 <clahey> lispy: What about using http://hackage.haskell.org/package/hashtables-1.0.1.8 and runST?
11:07:48 <`nand`> excellent, seems to work fine
11:11:55 <neutrino> now, you are ready to take over the world
11:29:59 <ziarkaen> http://hpaste.org/79477
11:30:26 <ziarkaen> I have some sort of syntactic error which I cannot fix.  Error in paste. ^
11:31:55 <lispy> clahey: I think for now I'll just use nub and (++) and some day when performance matters I'll find a proper solution.
11:32:17 <m3ga> i'm looking at Data.Vector.fromList. does that create a mutable or an immutable vector?
11:32:34 <popl> ziarkaen: forM_ ?
11:32:42 <neutrino> @type Data.Vector.fromList
11:32:43 <lambdabot> [a] -> Data.Vector.Vector a
11:32:51 <neutrino> @src Data.Vector.Vector
11:32:51 <lambdabot> Source not found. My brain just exploded
11:32:53 <ziarkaen> It turns out it was indentation. popl
11:33:11 <popl> ziarkaen: It usually is. I see people mixing tabs and spaces a lot, too.
11:33:24 <m3ga> -fwarn-tabs
11:33:30 <popl> m3ga++
11:33:57 <neutrino> look here m3ga
11:34:02 <neutrino> http://hackage.haskell.org/packages/archive/vector/0.10.0.1/doc/html/src/Data-Vector.html#Vector
11:34:07 <neutrino> what makes you think it's mutable?
11:34:50 <johnw> if you want mutable vectors, you need to use Data.Vector.Unboxed.Mutable, for example
11:35:08 <neutrino> or Data.Vector.Mutable
11:35:12 <m3ga> well Data.Vector does both. I should just test it, but it would be nice if was a little more explicitly documented.
11:35:15 <neutrino> which is boxed
11:35:20 <m3ga> ah right. thanks neutrino!
11:35:23 <johnw> oh, yeah, or that ;)
11:35:29 <neutrino> johnw: :))
11:35:33 <neutrino> yw m3ga
11:38:18 <johnw> aristid: will be releasing a new aws today?
11:39:09 <Walther> Ok, so i read about map and filter today. How could those be used to simplify this function? Failure: ubuntuone.platform.tools.linux.IPCError: org.freedesktop.DBus.Error.Spawn.ChildExited:
11:39:13 <Walther> augh
11:39:15 <Walther> mispaste
11:39:21 <johnw> heh
11:39:57 <heatsink> Does someone here know of a Haskell tool for performance regression test suites?  There seems to be lots of correctness testing tools, but not much in the way of performance testing.
11:40:02 <aristid> johnw: today? i... planned adding a bunch more things before the next release.
11:40:20 <johnw> heatsink: look up Criterion; also, Cabal supports benchmarks
11:40:28 <aristid> johnw: but if you need these features and want to use a released version, i can backport them to the stable branch and release 0.7.6 or so
11:40:28 <Walther> http://pastebin.com/sY9N5HtR
11:40:40 * hackagebot hlibgit2 0.17.0.4 - Low-level bindings to libgit2  http://hackage.haskell.org/package/hlibgit2-0.17.0.4 (JohnWiegley)
11:40:45 <johnw> ghc uses a program called "nofib-analyse" to detect regressions
11:41:02 <johnw> aristid: no, that's ok
11:41:13 <johnw> aristid: I'll wait on submitting gitlib-s3 to hackage until you release yours
11:41:15 <johnw> there's no hurry
11:41:31 <aristid> johnw: ok
11:41:36 <popl> AND THEN johnw DIED
11:41:44 <johnw> would it be in the next week or two?
11:41:52 <aristid> johnw: i think i'll _slightly_ reduce the scope of 0.8 tho :D
11:41:59 <johnw> because if it's longer than that, then yeah, a backport would be greatly appreciated
11:42:00 <popl> The world never had a chance to take advantage of gitlib-s3
11:42:05 <popl> It crumbled.
11:42:08 <johnw> haha
11:42:21 <heatsink> Hmm, nofib-analyze is part of nofib, so I can look at that
11:42:25 <popl> Way to kill the planet, johnw
11:42:43 <heatsink> Is Cabal's support for benchmarks part of the cabal test command?
11:42:50 <heatsink> I mean setup test
11:42:51 <dgpratt> well, I quite like a lot about EclipseFP, but getting debugging to work has been...a challenge
11:43:14 <johnw> cabal bench
11:43:27 <heatsink> Hmm, never heard of that
11:43:35 <dgpratt> I strongly suspect the problem is more my lack of understanding of how Eclipse is supposed to work than anything to do with EclipseFP
11:44:05 <dgpratt> anyways, are there any other options for interactively debugging Haskell code than GHCi?
11:44:08 <johnw> Walther: Euler, eh? :)
11:44:21 <johnw> dgpratt: there's Hat
11:44:33 <heatsink> I see some benchmark stuff in the Cabal API docs, but nothing in the user's guide.  It must be new.
11:44:50 <johnw> heatsink: http://blog.johantibell.com/2012/04/cabal-bench.html
11:44:58 <dgpratt> johnw: haven't heard of it, I'll check it out, thanks
11:45:00 <johnw> it's oldish (cabal 0.14)
11:45:11 <heatsink> Oh, thanks
11:46:20 <heatsink> johnw++
11:48:52 <wunki> I keep getting `--force-reinstalls`. Should that worry me, or should I keep using it?
11:49:02 <johnw> well, yes and no
11:49:06 <johnw> can you show me the output?
11:49:18 <wunki> sure, one moment
11:49:22 <parcs> first of all are you using the latest cabal
11:49:46 <wunki> https://gist.github.com/4331283
11:49:55 <wunki> cabal-install version 1.16.0.2
11:49:56 <johnw> ah
11:49:57 <johnw> cabal-dev
11:49:59 <johnw> i hate it when it does that
11:50:07 <johnw> you can force-reinstall
11:50:18 <johnw> but you're going to need to do it again soon
11:50:38 <johnw> cabal-dev is the only thing I use which has such old dependency limits
11:50:45 <johnw> it should really be updated
11:50:59 <johnw> i'll make a pull request for this, in fact
11:51:45 <wunki> johhw: now installing with `--force-reinstalls`. Thanks for your help
11:51:53 <lispy> johnw: it should already have a pull request or two asking for that
11:52:00 <johnw> actually, maybe it's already beenu pdated
11:52:01 <parcs> many people suggest installing cabal-dev via git
11:52:03 <johnw> it just needs to be released
11:52:25 <moben> Why do people say that !! is overused? (or rather, why shouldn't I use it?)
11:52:37 <johnw> i love cabal-dev
11:52:52 <johnw> i'm looking forward to native sandbox support in cabal
11:53:11 <Walther> johnw: No, I wouldn't cheat in Euler (haven't started that yet actually)
11:53:19 <`nand`> How do I distribute binaries compiled with GHC? Like; how do I get it run on systems without GHC installed?
11:53:22 <Walther> this is just for my own fun and to learn essentials in Haskell
11:53:31 <lewisx> for point and rect is there a point of defining separate types over using a tuple?
11:53:42 <johnw> Walther: well, in general any list comprehensions whose target is "x" is just a map :)
11:54:08 <johnw> [ x | x <- ys, p x ] == filter p ys
11:54:50 <parcs> moben: because it _usually_ means that your algorithm is not ideal or that you should be using an array instead
11:55:23 <parcs> `nand`: you don't need GHC installed to run a binary compiled with GHC
11:55:40 * hackagebot data-category 0.5.1 - Category theory  http://hackage.haskell.org/package/data-category-0.5.1 (SjoerdVisscher)
11:55:42 * hackagebot gitlib 0.5.2 - Higher-level types for working with hlibgit2  http://hackage.haskell.org/package/gitlib-0.5.2 (JohnWiegley)
11:55:52 <`nand`> parcs: okay. The target machine is complaining because it doesn't have libgmp.so.10 and libffi.so.6
11:56:01 <`nand`> parcs: do you know if I can get GHC to statically link those two libraries into the binary?
11:56:09 <johnw> ghc -static :)
11:56:20 <wunki> life can be so easy sometimes :)
11:56:22 <heatsink> lewisx, separate types are good for expressing programmer intent
11:56:28 <johnw> well, except on OS X
11:56:49 <`nand`> johnw: doesn't seem to have done anything
11:56:53 <parcs> `nand`: that means that you don't have libffi installed and that the target machine has gmp 4 installed, not gmp 5
11:56:56 <heatsink> lewisx, e.g. distinguishing between a (Double, Double) that's a complex number from a (Double, Double) that's a vector in 2D euclidean space
11:57:12 <`nand`> parcs: so how do I link them in?
11:57:19 <parcs> `nand`: you can statically link everything with -optl-static
11:57:32 <`nand`> that's what I tried, but it results in a bunch of errors
11:57:42 <`nand`> and no output
11:57:53 <parcs> `nand`: also -threaded
11:58:07 <parcs> don't ask me why :P
11:58:18 <`nand`> parcs: http://bpaste.net/show/65236/
11:58:20 <Eduard_Munteanu> What errors? Do you have the corresponding static libs (.a's)
11:58:21 <Eduard_Munteanu> ?
11:58:31 <`nand`> this is the output of `ghc -static -optl-static -threaded Server.hs'
11:58:57 <Walther> How about the licencing then - on the scale from one to impossible, how possible is it to compile Haskell code with builtin libraries, if needed, without having to comply to GPL? Just curious
11:59:29 <Walther> or does it whatever-you-do include something licenced under GPL and hence enforce GPL
11:59:47 <moben> parcs: thanks, that makes sense
12:00:56 <parcs> `nand`: looks like your system doesn't have the .a's for libgmp and libffi
12:01:16 <bootcode__> Walther: I didn't follow the conversation, but GHC seems to have a BSD-like licence, isn't it? Or are you concerned about specific individual libraries?
12:01:57 <Walther> bootcode__: Just wondering in general, about how probable it is in real life to be "forced" to GPL while using Haskell for anything real
12:02:12 <parcs> `nand`: try installing the -devel variants of the libgmp and libffi packages
12:02:26 <bootcode__> Walther: just did a smoke test: base, mtl and lens libs use BSD3 too
12:02:37 <`nand`> oh, there's a USE="static-libs" flag
12:02:41 <`nand`> I guess that's relevant?
12:02:51 <parcs> yeah
12:02:53 <bootcode__> So while the answer may depend on specific libs, I sense that BSD is quite dominant so you can almost do whatever you want
12:03:12 <edwardk> Walther: highly unlikely. very few libs in haskell are GPL. mostly its BSD for libraries and a few GPL applications
12:03:33 <johnw> hey there edwardk
12:03:46 <edwardk> Walther: if you come across something that you can't live without thats GPL in haskell let me know, i probably have written a BSD variant on the theme ;)
12:03:53 <edwardk> johnw: how goes?
12:04:09 <Walther> No, I haven't written basically anything yet :P
12:04:13 <johnw> not bad, just tired; was up forever playing with 'aws'.  how are isos and prisms today? :)
12:04:21 <Walther> Also, how are the BSD terms on commercial things
12:04:33 <johnw> BSD is excellent for commercial use
12:04:42 <Walther> I mean, GPL is a good thing, but if you want to do anything commercial it is a PITA
12:04:49 <bootcode> Walther: ~do whatever you want, just don't use the creator's name to advertise your own product
12:04:51 <johnw> it's basically a "no guarantees, repeat this copyright" type license
12:05:01 <Walther> ah
12:05:01 <edwardk> johnw: not bad. i've been letting elliott and shachaf hash out the symmetric form on #haskell-lens, and went off and started playing with traversals of in-memory database tables with multiple keys
12:05:16 <bootcode> e.g., don't sell it with the tagline "contains edwardk's great libs, so this is a kickass app!" :)
12:05:27 <elliott> ooh remind me to use that tagline
12:05:40 <elliott> cashing in on the edwardk bandwagon
12:05:41 <popl> elliott: Don't forget to use that tagline.
12:05:46 <elliott> thanks
12:05:46 <edwardk> elliott: you are hereby licensed to use that tagline so long as it is a kickass app.
12:05:50 <johnw> so what do I do with my "edwardk Inside!" stickers?
12:06:01 <popl> johnw: You know.
12:06:07 <int-e> ... powered by ...
12:06:14 <edwardk> johnw: you should take them off the cages, right now ;)
12:06:22 <johnw> haha
12:06:48 <`nand`> parcs: worked, great
12:07:49 <edwardk> the database stuff has me rather enthusiastic. lenses really clean up the code inside and out
12:08:01 <edwardk> i wanted a non-trivial application of lenses to show off
12:08:30 <johnw> using them to build composable database queries would be very interesting
12:09:22 <johnw> i.e., one traversals to pull X records from a table join, and then another traversal over X records to fetch a field; then compose them to get a list of fields
12:09:38 <edwardk> johnw: i'm playing a little fast and loose with the traversal laws for write-back
12:10:33 <parcs> `nand`: yay
12:11:04 <johnw> the write-back would be just too cool
12:11:32 <johnw> this will turn into UPDATEs for the resulting records from a SELECT?  How do you correlate?  Do you require an id in the result?
12:14:52 <neutrino> `nand`: so i was right! well, sortof.
12:15:10 <`nand`> eutr
12:15:14 <`nand`> oops
12:15:24 <`nand`> neutrino: about what?
12:18:50 <edwardk> johnw: it works with whatever the primary key was
12:19:57 <edwardk> if you project via a lens for any projections then i also have enough information to go backwards
12:22:20 <johnw> that would be really nice, edwardk
12:22:26 <johnw> let me know when you have something I can test
12:23:51 <edwardk> johnw: the hpaste above is fully functional in that you can play with a toy table and build and tear it down
12:24:42 <johnw> which hpaste would that be?
12:24:47 <johnw> i don't see any from you
12:26:06 <edwardk> http://hpaste.org/79442
12:26:29 <edwardk> you'll need lens and prelude-extras
12:26:37 <johnw> hackage lens, or build from lens-core?
12:26:43 <edwardk> actually the prelude extras depends doesn't matter
12:26:44 <lolcathost> I have recently reinstalled GHC from source on my machine. I have downloaded the source, and done the following: ./configure, make, sudo su -, umask 022, make install. That installed the documentation as well, but only incompletely - the User's Guide is missing. Do any additional steps have to be performed to get the User's Guide?
12:26:48 <edwardk> should work with either
12:27:38 <edwardk> i'll brb, let me know how the set up goes ;)
12:27:49 <johnw> will do
12:29:34 <johnw> oh, I forgot to ask for a quick sample of usage, say on an sqlite table
12:29:46 <johnw> i'll try to glean it from the code
12:31:47 <wunki> someway I keep getting a "~" directory in my projects directory
12:32:07 <wunki> you can understand that it's not cool when I tried to do a "rm -rf ~"
12:32:21 <wunki> https://gist.github.com/4331675
12:32:28 <wunki> anybody know what generates that?
12:35:41 * hackagebot unscramble 0.0 -   http://hackage.haskell.org/package/unscramble-0.0 (JoelTaylor)
12:36:25 <hpaste> johnw pasted “GHCi error” at http://hpaste.org/79483
12:36:34 <johnw> has anyone else ever seen this?
12:36:43 <johnw> i can fix it by restarting my Cabal from scratch, but that takes a while
12:36:55 <johnw> i'm not sure (a) how I got into this situation, and (b) how to extricate myself
12:37:21 <johnw> i wonder if it's a ghc-mod bug...
12:37:56 <johnw> no
12:38:03 <johnw> somehow my libs are bad
12:40:41 * hackagebot unscramble 0.1 - Solve Boggle-like word games  http://hackage.haskell.org/package/unscramble-0.1 (JoelTaylor)
12:48:16 <edwardk> johnw: its not for sqlite, its a small in memory table manager
12:48:45 <edwardk> johnw: fromList [Foo 1 "hello" 0.2, Foo 2 "goodbye" 0.4]   gives you a table, then there are insert, delete, etc.
12:49:16 <edwardk> Foo is the only test table i have right now, it has a primary key on fooId, an unconstraint column fooBar and a secondary key on fooBaz
12:50:41 * hackagebot sde-solver 0.1.0.0 - Distributed SDE solver  http://hackage.haskell.org/package/sde-solver-0.1.0.0 (DavidNilsson)
12:51:56 <mcstar> does Data.Text has a printf?
12:52:08 <mcstar> have
12:52:10 <mcstar> jesus
12:55:28 <sclv> pretty sure it doesn't
12:55:37 <edwardk> mcstar: we don't really use printf even with strings
12:55:39 <mcstar> alternatives?
12:55:56 <sclv> haskell's printf is awesome, but not for real use i think
12:56:03 <sclv> depends what you want to print
12:56:06 <mcstar> idk why
12:56:11 <mcstar> it is runtime safe
12:56:23 <sclv> the types eat you up if you're not careful
12:56:37 <mcstar> anyway, what are the alternatives if i want to interpolate stuff?
12:56:39 <sclv> plus it doesn't check that you have a match between # of arguments and the input string
12:56:43 <edwardk> well, printf as used by c doesn't make sense here, its not type safe. you can make a notion of a format string that is type safe, but it only vaguely resembles printf in the end ;)
12:56:45 <mcstar> ++ ++ is not awesome
12:56:46 <gavri> I'd trying to define a recursive function. it gives me the correct output sometimes, but sometimes, it just doesn't. I'd like to visualize all the calls being made to this recursive function with the arguments being passed in. how do I do this?
12:56:47 <johnw> edwardk: ah, I see
12:56:50 <sclv> you can use a qq for interpolation
12:56:54 <johnw> edwardk: I guess I want persistent-lens then
12:56:59 <johnw> *that* would be dead sexy
12:57:09 <parcs> gavri: using Debug.Trace, perhaps
12:57:14 <sclv> there are a few v. nice quasiquoter for interpolated string packages out there
12:57:19 <sepp2k> Is there a function in the standard library that efficiently compares two lists' lengths in cases where one list might be significantly larger than the other - i.e. without iterating over both lists to the end (as "comparing length" would)?
12:57:28 <mcstar> sclv: can you direct me to some examples?
12:57:59 <parcs> sepp2k: (==) `on` fmap (const ())
12:58:43 <elliott> sepp2k: you can use a lazy natural type + genericLength
12:58:44 <parcs> sepp2k: replace all the elements of each list with (), and then check equality of that
12:59:05 <sclv> mcstar: this looks relatively maintained -- http://hackage.haskell.org/package/Interpolation
12:59:16 <elliott> not sure what the fashionable package to get a lazy natural type from is
12:59:53 <mcstar> well, thanks
12:59:55 <parcs> > let xs = [1..]; ys = [1..10] in map (const ()) xs `compare` map (const ()) ys -- sepp2k
12:59:57 <lambdabot>   GT
13:00:05 <mcstar> but for now, ill just convert Text to String
13:00:11 <sclv> hstringtemplate has a quasiquoter too: http://hackage.haskell.org/packages/archive/HStringTemplate/0.6.12/doc/html/Text-StringTemplate-QQ.html
13:00:23 <sclv> but yes you can printf to string and then use text
13:01:17 <edwardk> johnw: my first goal is to get a multi-index in memory data structure. i figure if i get that working the happs guys can wrap it in acid-state or something and write it to disk
13:02:05 <sepp2k> parcs: elliot: Thanks.
13:02:37 <gavri> parcs: thanks
13:08:26 <johnw> edwardk: but in theory there's no reason it couldn't be extended to SQL, as long as you require the user to identify the id column?
13:08:54 <aristid> johnw: can you tell me the context of what you and edwardk are talking about? sounds intriguin
13:09:04 <edwardk> it'd be a different design. it'd just share a lot of structure
13:09:15 <johnw> traverseSqlQuery "id" "select id, name from mytable where name = 'edwardk'" .~ "johnw"
13:09:17 <edwardk> aristid: i started playing with a little haskell in-memory database
13:09:28 <edwardk> johnw: i'd want something stronger typed than that
13:09:43 <johnw> sure, that was just an untyped sample
13:09:56 <johnw> substitute query with appropriate haskelldb/persistent/acid-state logic
13:09:57 <edwardk> aristid: http://hpaste.org/79442
13:10:17 <edwardk> i'd rather write something from scratch, but whatever floats your boat ;)
13:10:34 <edwardk> i'm finally free of all of my database non-competes as of last week
13:10:40 <edwardk> so i can actually think about this stuff again
13:10:40 <aristid> yay.
13:10:46 <johnw> well, something from scratch == something new to learn
13:10:57 <edwardk> johnw: sometimes thats a good thing =P
13:11:15 <gavri> parcs: this recursive function calls itself twice and adds the results together and I'd like to see the call chain as a tree. that doesn't seem easy with Debug.Trace. is there an alternative?
13:11:21 <johnw> yeah, sometimes
13:11:30 <edwardk> if i have to use the style of the existing APIs I just frankly wouldn't do it
13:11:36 <edwardk> its terrible writing database code in haskell right now
13:11:44 <edwardk> so screw that
13:11:51 <johnw> fair enough
13:11:58 <johnw> come up with the one query spec to rule them all
13:12:19 <tdammers> I resorted to writing old fashioned parametrized queries in strings :P
13:12:30 <edwardk> well, i'm fiddling with what i can do for in memory storage right now. i'm not even all that committed to carrying it through yet. we'll see =P
13:13:17 <johnw> knowing you, edwardk, i'll soon be able to do queries using multiplication and bifunctors
13:13:22 <k00mi> gavri: maybe Debug.HTrace?
13:13:53 <johnw> gavri: you can use diagrams to display the execution
13:13:56 <gavri> k00mi: thanks
13:13:59 <johnw> although, it's just a bit of work
13:15:03 <argiopeweb> Having some issues combining regular clause-level guards and expression-level MultiWayIf. Someone mind taking a look?
13:15:05 <hpaste> argiopeweb pasted “Guards + MultiWayIf” at http://hpaste.org/79485
13:15:24 <johnw> what is the error?
13:15:37 <argiopeweb> Suppose I should have put that in there...
13:15:50 <argiopeweb> "Parse error on '='"
13:16:10 <johnw> line 4?
13:16:15 <argiopeweb> s/on '='/on input '='/
13:16:30 <argiopeweb> 7
13:16:44 <johnw> interesting
13:17:26 <argiopeweb> I thought so. Direction is full of nullary constructors, so it isn't anything to do with that.
13:18:36 <aristid> edwardk: are you restricting yourself to in-memory because out-of-memory is fundamentally hard, or just because it would make writing the code more annoying?
13:18:59 <edwardk> aristid: mostly because it is the sub-problem i care about
13:19:05 <hpaste> argiopeweb annotated “Guards + MultiWayIf” with “Guards + MultiWayIf (annotation)” at http://hpaste.org/79485#a79486
13:19:40 <edwardk> aristid: also out of memory storage is a fundamentally different problem
13:20:18 <aristid> edwardk: yet it isn't entirely orthogonal i think
13:20:35 <edwardk> here i can directly reference say the entire raw row from my supplemental indices, there i have to reference part of the primary key and do a second lookup, i'm dealing with managing pages, a write-ahead logging framework, durability concerns, etc.
13:20:35 <johnw> aristid: that was my contention too
13:20:41 <k00mi> argiopeweb: ghci thinks the guard-pipe is part of the multiwayif right?
13:21:04 <aristid> well if edwardk cares more about in-memory it's his decision not like it's our business to decide what he wants to code :D
13:21:21 <johnw> k00mi: indentation should prevent that
13:21:24 <argiopeweb> k00mi: That's what I'm guessing, I suppose I can break it into a couple of where clauses and avoid the issue.
13:21:26 <edwardk> sure at a sufficient level of abstraction everything is the same. in terms of actually getting something done in the amount of time i'm willing to devote to the topic, i can deal with the in memory version and point someone at the right abstraction for later ;)
13:21:36 <argiopeweb> But, as johnw said, indentation should get it.
13:21:36 <johnw> aristid: true, but if I know him he'll design for both cases
13:21:59 <k00mi> johnw: if you replace the = with -> it complains on the next =
13:22:00 <edwardk> not this time. i've written my production ready database once. i'm not in a hurry to repeat the process ;)
13:22:21 <edwardk> also this is a row-store, if i was designing for offline storage i'd have to make a column-store
13:22:34 <aristid> edwardk: this would be one of your projects where deeper understanding of the problem is more important to you than getting users? (please don't read it in an accusatory tone, it isn't meant that way.)
13:22:36 <edwardk> that brings with it its own set of structuring issues
13:22:43 <johnw> you'll wake up sweating in the middle of the night and make it more abstract, just wait and see
13:23:00 <edwardk> aristid: no, this is the kind of problem where i've had a whole host of datalog code i've wanted to run in memory and no way to write it in haskell for years
13:23:04 <johnw> i love type errors
13:23:26 <edwardk> at least no efficient way to write it in memory
13:23:38 <aristid> edwardk: so you care about the user named edwardk :D
13:23:47 <edwardk> yes
13:24:05 <sclv> edwardk: so my new evil scheme for databases in haskell is that we build a tool to compile state machines to llvm
13:24:22 <edwardk> thats the case with all my libraries. other users just give me more eyeballs, so its occasionally useful to let them use the code too, since they find bugs ;)
13:24:25 <sclv> then turn our propositions into queries and compile and link in memory, lennart style
13:24:33 <aristid> edwardk: i thought lens was different :D
13:24:40 <edwardk> sclv: that sounds like a perfectly viable way to do it
13:24:52 <edwardk> aristid: its an experiment in getting _lots_ of eyeballs ;)
13:25:03 <lispy> haskell, lennart style
13:25:05 <aristid> edwardk: so far happy with the experiment?
13:25:14 <edwardk> aristid: its worked better than i expected
13:25:29 <sclv> yeah i think a state machine -> llvm tool would be super handy regardless
13:25:43 <sclv> just a one stop sort of hammer
13:25:44 <int-e> edwardk - eyeball juggler.
13:26:11 <edwardk> if i wanted to deal with a 'practical' way of dealing with external data, i'd probably go with something like compiling something like sqllite bytecode
13:26:18 <hpaste> argiopeweb annotated “Guards + MultiWayIf” with “Guards + MultiWayIf (fix)” at http://hpaste.org/79485#a79487
13:26:26 <edwardk> here i'm in memory and my indices are mostly maps, and potentially later hashmaps, etc.
13:26:40 <argiopeweb> ^^ Think this one might be worthy of a bug report.
13:26:47 * edwardk rolls his eyes. (ouch, in light of int-e's comment)
13:27:15 <elliott> edwardk: datalog, cool
13:28:00 <aristid> lispy: i didn't get that pun. explain!
13:28:25 <johnw> @pl \f x -> x >>= return . f
13:28:26 <lambdabot> fmap
13:28:38 <johnw> ah, of course
13:29:13 <aristid> johnw: of course lambdabot is lying, that doesn't have the same type. clearly liftM is the right solution!
13:29:25 <johnw> :)
13:30:19 <aristid> johnw: i wonder if your git-s3 thing can be abused for other purposes than just running git on it.
13:30:38 <johnw> how so?
13:30:56 <aristid> johnw: you know i've wondered in the past how well something like an immutable database would work
13:32:01 <sclv> oh no edwardk is going to start building rich hickey's new datastore :-(
13:32:35 <johnw> i have a better datastore: just tell edwardk stuff, he remembers it, then ask him again later
13:33:18 <edwardk> sclv: no. not in the market to write another database =)
13:33:29 <edwardk> i just want an ixset that doesn't suck =P
13:34:21 <sclv> doing the obvious thing (array, indexed into by multiple maps)?
13:34:29 <johnw> aristid: oh, I see what you mean
13:34:38 <johnw> aristid: people have used Git as an immutable data store before
13:34:45 <johnw> aristid: see "git-shelve" for Python
13:34:54 <johnw> i think I wrote it, but honestly I don't remember
13:35:01 <johnw> that's weird...
13:35:08 <x-Suriv> anyone here have experience with the Haskell xml package?
13:36:13 <edwardk> sclv: primary key map, multiple supplemental indices
13:36:14 <edwardk> http://hpaste.org/79442
13:36:23 <edwardk> sclv: using traversals to edit rows
13:36:34 <aristid> johnw: you did.
13:36:35 <edwardk> adding where clauses with write-back now
13:36:40 <aristid> johnw: http://newartisans.com/2008/05/using-git-as-a-versioned-data-store-in-python/
13:37:30 <sclv> ah, traversals for rows, cute :-)
13:37:33 <sclv> lensdb
13:37:41 <edwardk> pretty much
13:37:53 <sclv> no iteratees, no cred :-P
13:37:55 <edwardk> so you can do things like get groupings as indexed traversals of sub-relations
13:38:13 <sclv> can we make an argument that a traversal is an iteratee inside out again
13:38:20 <edwardk> hah
13:38:29 <aristid> sclv: iteratees are like totally out of fashion man
13:38:32 <edwardk> well, it is still cps'd just differently
13:38:38 <sclv> the essence of the cocoiterator pattern
13:38:55 <aristid> i like cocoa.
13:40:16 <dgpratt> when debugging in ghci, what determines the output of the ":show bindings" command?
13:40:22 <sclv> I like CoCoA http://cocoa.dima.unige.it/WhatIsCoCoA/WhatIsCoCoA-English.html
13:40:33 <dgpratt> I would have guessed it would be any symbol in scope, but that appears not to be the case
13:40:47 <elliott> monadic folds are kind of like inverse iteratees right
13:42:00 <aristid> sclv: that's got a lot of translations.
13:42:18 <johnw> hmm.. i actually need an IORef
13:42:24 <johnw> i feel kind of dirty inside, but C is making me do it
13:43:17 <bourbaki_> Greetings
13:43:23 <johnw> hi bourbaki_
13:43:29 <bourbaki_> Is there anythting like this in data types?
13:44:06 <bourbaki_> I want to have a function inside a data that is dependent on its on reference. (or whatever that is called in haskell)
13:45:26 <hpaste> bourbaki pasted “Trial” at http://hpaste.org/79489
13:45:47 <bourbaki_> What i would like to get is something like that stuff commented out.
13:53:57 <edwardk> >>> fromList [Foo 0 "hello" 0.0, Foo 1 "hello" 1.2, Foo 2 "wut" 1.5, Foo 3 "wut" 2.0, Foo 4 "wut" 3.0] ^.. withIndicesOf (having fooId (>) 2 .> grouped fooBar <.> grouped fooBaz)
13:53:57 <edwardk> [(("wut",2.0),fromList [Foo {__fooId = 3, __fooBar = "wut", __fooBaz = 2.0}]),(("wut",3.0),fromList [Foo {__fooId = 4, __fooBar = "wut", __fooBaz = 3.0}])]
13:54:31 <edwardk> having works. you can now to where queries with write-back
13:54:35 <edwardk> er now do
13:55:48 <edwardk> >>> fromList [Foo 0 "hello" 0.0, Foo 1 "hello" 1.2, Foo 2 "wut" 1.5, Foo 3 "wut" 2.0, Foo 4 "wut" 3.0] ^..having fooId (<) 4.having fooBar (==) "wut".folded
13:55:48 <edwardk> [Foo {__fooId = 2, __fooBar = "wut", __fooBaz = 1.5},Foo {__fooId = 3, __fooBar = "wut", __fooBaz = 2.0}]
13:55:51 <jfoutz> is the snap framework supposed to have a control.comonad build depend? snap init wrote a cabal file that's been right so far, but this seems a little weird.
13:56:14 <edwardk> jfoutz: lens uses comonads internally, so does snap. Snaplet is a comonad
13:56:44 <edwardk> they've depended on comonad for a long time, since data-lens used to use comonads too
13:57:01 <jfoutz> so why would import Control.Comonad complain about a hidden package? Isn't that supposed to be available transitively?
13:57:07 <jfoutz> maybe i have a version problem.
13:57:10 <bourbaki_> Hey edwardk im currently trying out the data route for the math stuff.
13:57:38 <edwardk> jfoutz: you probably didn't put comonad in your cabal file or have the package hidden when you go to load it in ghci
13:58:02 <edwardk> bourbaki_: that sounds like a recipe for pain, but sure ;)
13:58:44 <jfoutz> thanks edwardk, is there a good way to check what version range of snap depends on, so i can put the same range, or is it better to just do 3.0.0.2? (what i have installed)
13:58:56 <bourbaki_> edwardk: It already is after typing a few lines ... it just starts to expose the problems i feared to run into from the start, it feels like implementing OOP now...
13:59:03 <edwardk> 3.0.0.2 should be fine
13:59:14 <edwardk> bourbaki_: yep
13:59:26 <edwardk> bourbaki_: agda is much better at that sort of record-heavy development
13:59:35 <bourbaki_> Is there anything like the MOP for Haskell?
13:59:39 <edwardk> anything you build this way in haskell won't 'feel' right
13:59:57 <jfoutz> awesome, thanks again.
14:00:02 <bourbaki_> Meh ok ill have a tour into the Agda world then :(
14:00:12 <edwardk> bourbaki_: mop = model-oriented programming?
14:00:27 <jfoutz> i'm guessing meta object protocol
14:00:29 <bourbaki_> edwardk: Aye
14:00:32 <edwardk> oh derp
14:00:36 <edwardk> no, fraid not
14:01:02 <edwardk> brain went to a different, more recent, stimulus =)
14:01:09 <bourbaki_> :)
14:02:51 <edwardk> now to tackle joins
14:08:21 <stepcut> edwardk: \o/
14:09:20 <edwardk> stepcut: so far you can do arbitrary grouping, and with (where-like clauses), read and write back to the rows, use the various traversal combinators on the results, chain groupings, etc.
14:09:37 <stepcut> nice
14:10:11 <edwardk> it'll use the indices if you give it a key it supports, it'll just sort itself if it has to otherwise
14:11:46 <stepcut> if you have a primary key, can you do inserts with autoincrement?
14:12:02 <edwardk> not yet that turns out to be an interesting conundrum
14:12:17 <stepcut> i bet
14:12:25 <edwardk> you can easly get back the maximum key in the table to add one and write it in
14:12:59 <edwardk> i'll kick around auto-increment. it'll probably wind up something like 'anon' in the lens library
14:13:06 <stepcut> k
14:13:20 <edwardk> you'll get a predicate and a way to generate a new key given the primary index
14:13:38 <edwardk> the predicate will be used to check if you should generate the key
14:13:41 <stepcut> having to manually increment things (with IxSet anyway) makes the code longer and error prone
14:13:50 <edwardk> then we can bake that into the relational class
14:13:55 <edwardk> sure
14:15:54 <edwardk> maybe something like:   autoKey    :: t -> Maybe (Map (PKT t) -> t)    as an extra member of the Relational class
14:16:13 <edwardk> to check if t needs an auto-key, and generate it using the primary index.
14:16:22 <edwardk> i can use that then on insert
14:17:11 <edwardk> er t -> Maybe (Map (PKT t) t -> t)
14:17:12 <aristid> edwardk: is that really necessary?
14:17:23 <aristid> edwardk: do you support composite primary keys?
14:17:28 <edwardk> aristid: yes
14:17:45 <aristid> to which question:D
14:17:53 <edwardk> both
14:18:13 <aristid> edwardk: why is it necessary if you have composite keys? can't you just make the whole row its own key?
14:18:37 <edwardk> you can, but its nice to have inserts that generate ids, non-equatable columns, etc.
14:18:50 <edwardk> you can stuff a function in there
14:19:41 <aristid> c.j. date does not like you anymore.
14:20:10 <edwardk> *shrug*
14:20:43 <edwardk> i'm not implementing a relational algebra, i'm implementing something i want to use =P
14:22:04 <aristid> *shrug*
14:26:53 <hpaste> “Ertugrul Söylemez” pasted “Elegant dependency injection” at http://hpaste.org/79493
14:27:01 <edwardk> i almost have autoincrement working
14:27:19 <mm_freak_> if anyone has read this:  https://plus.google.com/114991347543804898741/posts/Ts5RqheKZod
14:27:28 <mm_freak_> this is the way to do it right:  http://hpaste.org/79493
14:27:29 <mm_freak_> =)
14:28:07 <mm_freak_> dynamic dependency injection with fully static checking…  you can't use a feature you did not request, and if requested, it has to be supplied =)
14:28:28 <elliott> mm_freak_: that's basically an effect system AIUI
14:28:54 <elliott> sort of anyway
14:29:23 <mm_freak_> elliott: no, you can pass arbitrary features around, including configuration
14:29:36 <mm_freak_> it's pluggable ReaderT
14:30:27 <mm_freak_> the nice thing about this approach is that the features travel through type class interfaces
14:30:30 <elliott> you can have a "ReaderT" effect too, it's just that these are hardcoded to IO interpretation
14:30:34 <elliott> but I suppose that is what differentiates them
14:30:39 * elliott does know how reflection works :)
14:30:51 <johnw> aristid: can I change the host:port that aws connects to?
14:31:35 <moben> I want a function that does [1,2,3,4] -> [1,12,123,1234], but somehow fail at using folds the right way :-/
14:32:23 <elliott> that'll be easier with a scan than a fold
14:32:29 <elliott> @hoogle scan
14:32:29 <lambdabot> Prelude scanl :: (a -> b -> a) -> a -> [b] -> [a]
14:32:30 <lambdabot> Data.List scanl :: (a -> b -> a) -> a -> [b] -> [a]
14:32:30 <lambdabot> Prelude scanl1 :: (a -> a -> a) -> [a] -> [a]
14:32:33 <shachaf> > scanl1 (++) ["1","2","3","4"]
14:32:35 <lambdabot>   ["1","12","123","1234"]
14:32:38 <shachaf> The rest is left as an exercise.
14:32:50 <tromp> > let f x = [1,12,123,1234] in f [1,2,3,4]
14:32:50 <hpc> @src scanl1
14:32:51 <lambdabot> scanl1 f (x:xs) =  scanl f x xs
14:32:51 <lambdabot> scanl1 _ []     =  []
14:32:52 <lambdabot>   [1,12,123,1234]
14:32:53 <johnw> as an exercise to the reader (big wink)
14:33:00 <shachaf> Thanks, tromp.
14:33:03 <moben> aaah, scan
14:33:18 <moben> thanks a lot :)
14:35:23 <moben> wow that was easy
14:35:28 <mm_freak_> elliott: the main difference is that you can't mix up two Int features, and you can't use a feature outside its scope
14:35:34 <mm_freak_> that's the big advantage over ReaderT
14:37:13 <aristid> johnw: sure.
14:37:19 <aristid> johnw: look at the endpoint stuff
14:37:57 <aristid> johnw: you'll need to replace the defServiceConfig for that purpose.
14:39:42 <elliott> mm_freak_: well, you get those advantages with just plain reflection
14:39:52 <mm_freak_> elliott: that is plain reflection
14:39:53 <elliott> you don't need any more combinators
14:40:01 <elliott> well, I mean you don't need "with"
14:40:30 <elliott> well... depends on what you are doing
14:40:34 <mm_freak_> the 'with' makes code look nicer and the type variable passing less explicit
14:40:51 <elliott> you can avoid all the lifting though if you skip this boilerplate
14:40:51 <mm_freak_> also there is this With machinery you don't get for free
14:40:57 <mm_freak_> yes, that's true
14:41:08 <mm_freak_> anyway, the point is:  use reflection
14:41:21 <elliott> i agree that reflection is the way to go in general
14:41:55 <mm_freak_> elliott: when you don't use something like App you're passing the features around explicitly
14:42:08 <mm_freak_> you have to pass proxies around
14:42:16 <mm_freak_> that's why i encoded the dependency injection in the monad
14:42:49 <elliott> nope, you don't necessarily have to pass proxies around when using reflection
14:42:59 <elliott> you can put the type parameters on the actual data you work with
14:43:05 <elliott> which also stops you mixing them incorrectly
14:43:07 <clahey> If I were to have a function:
14:43:13 <mm_freak_> there isn't always a sensible way to do it
14:43:34 <mm_freak_> for example often (like in web apps) there simply is no data, or the data gets generated along the way
14:44:03 <mm_freak_> then you either pass proxies or use the monad as the proxy
14:44:07 <clahey> computeWithCache key lazyValue :: a -> b -> IO b
14:44:08 <mm_freak_> the latter is what i'm doing in that code
14:44:18 <clahey> Is there a better name for lazyValue?
14:44:24 <mm_freak_> clahey: x?
14:44:28 <clahey> I was thinking of it as a function because I'm actually writing it in python.
14:44:36 <clahey> Where there aren't lazy values.
14:45:16 <mm_freak_> clahey: btw, computeWithCache key (lazyValue :: b) :: IO b
14:45:28 <mm_freak_> computeWithCache :: a -> b -> IO b
14:46:53 <clahey> mm_freak_: A good point.
14:48:07 <johnw> aristid: aha, thanks
14:48:44 <johnw> i decided to try out mock_s3.py, to speed up testing
14:48:55 <aristid> s3 is too slow?
14:49:00 <johnw> it's slowish, yeah
14:49:17 <johnw> plus, i always prefer to have offline options for anything I'm working on
14:49:26 <aristid> johnw: yeah it also saves money
14:49:35 <johnw> heh, i think I've spent .2 cents now
14:49:52 <aristid> one of the reasons (testing being boring being the other big one) aws doesn't have a... compelling testing story yet ;)
14:50:06 <johnw> yes, I don't want to have my access/secret key committed to my test files :)
14:50:22 <c_wraith> you also get to pay for your test uploads and downloads! :)
14:50:23 <aristid> why not, that way i could use your account to test \o/
14:50:23 <johnw> i actually need an S3 mock in Haskell for another purpose (caching, delay queueing)
14:50:30 <johnw> so i'll keep that use case in mind  too
14:50:34 <otters> cabal sucks
14:51:48 <aristid> johnw: wouldn't you want to do the caching on a higher level?
14:51:57 <johnw> how do you mean?
14:52:36 <johnw> aristid: why is S3Configuration parameterized?
14:52:40 <aristid> johnw: well s3 to me is a very low-level API, and not very well-designed either
14:52:55 <johnw> aristid: oh, because I want something I can just drop-in, or yank out
14:52:58 <aristid> johnw: because you can make s3 requests that are pure URLs and send those signed urls to your clients
14:53:28 <johnw> oh, I see
14:53:37 <johnw> you only use it for the instance definition
14:54:17 <aristid> johnw: yes. it used to be a source of mistakes for me to use the wrong service configuration.
14:54:57 <aristid> sadly datakinds are not stable on 7.4
14:55:01 <edwardk> stepcut, aristid: autoincrement works
14:55:12 <aristid> edwardk: yay. (evil progress)
14:55:13 <stepcut> sweet!
14:55:19 <edwardk> @hpaste
14:55:19 <lambdabot> Haskell pastebin: http://hpaste.org/
14:55:31 <hpaste> edwardk pasted “relations with autoincrement” at http://hpaste.org/79495
14:55:46 * hackagebot unscramble 0.2 - Solve Boggle-like word games  http://hackage.haskell.org/package/unscramble-0.2 (JoelTaylor)
14:55:49 <aristid> edwardk: you should keep a terminal open to your side with just the text http://hpaste.org in it ;)
14:56:43 <edwardk> basically you carry around the auto-increment current index in the 'Table' that backs the relation
14:57:20 <edwardk> by default the autoKey machinery does nothing, but you can enable it with an index into the table
14:57:23 <edwardk>   autoKey = autoIncrement $ \f (FooTable n x y z) -> f n <&> \n' -> FooTable n' x y z
14:57:56 <fmap> apparently we need -XInlineEverything
14:58:06 <edwardk> fmap it'd make my life easier
14:59:07 <aristid> and a NOINLINE pragma for select functions
14:59:36 <edwardk> NOINLINE exists ;)
14:59:51 * glguy resists seeking out that "all the things" image macro
14:59:51 <shachaf> But it has a different effect from no INLINE
15:00:00 <elliott> does lens have any non-inlined top level functions
15:00:01 <shachaf> glguy: Thank you for resisting.
15:00:11 <c_wraith> elliott: that sounds inefficient.
15:00:12 <edwardk> elliott: if it does its probably a bug
15:00:12 <elliott> that are not {-# INLINE #-}d for a reason other than mistake
15:00:35 <edwardk> c_wraith: it makes a huge difference in performance given the common usage patterns for lens
15:00:52 <edwardk> elliott: yes we do
15:01:02 <glguy> elliott: loci is one
15:01:08 <edwardk> a couple of recursive functions that don't use worker/wrapper
15:01:12 <glguy> (for whatever reason I had the source open to that function)
15:01:25 <shachaf> Hmm, several functions in Data.Data.Lens aren't inlined.
15:01:36 <elliott> loci should be inlined
15:01:37 <elliott> from the looks of it
15:01:50 <edwardk> it is now =)
15:01:57 <edwardk> the data.data.lens ones were deliberate iirc
15:02:17 <edwardk> oh not all of them
15:02:18 <edwardk> fixing
15:02:19 <shachaf> Even the fmap instance for Answer?
15:02:32 <shachaf> Ah.
15:02:34 <donri> it's not safe to unsafePerformIO MVar operations, is it? this is for ffi bindings
15:02:42 <shachaf> cache :: IORef Cache
15:02:43 <shachaf> cache = unsafePerformIO $ newIORef $ Cache emptyHitMap M.empty
15:02:43 <shachaf> {-# NOINLINE cache #-}
15:02:53 <shachaf> I bet that one should be inlined.
15:03:04 <aristid> shachaf: no it shouldn't.
15:03:14 <watermind> is there any proposal for anything like monadic guards and monadic pattern matching?
15:03:21 <elliott> ?
15:03:26 <elliott> do { x:xs <- m; ... } -- valid
15:03:29 <edwardk> some of the hitmaps are like that too not inlined because of the unsafePerformIO stuff
15:03:58 <watermind> the idea being that it'd first do a     x <- mx    followed by a case (in the case of pattern matching)
15:04:19 <watermind> and in the case of guards, first do a x <- mx  followed by an if
15:05:46 * hackagebot unscramble 0.3 - Solve Boggle-like word games  http://hackage.haskell.org/package/unscramble-0.3 (JoelTaylor)
15:06:27 <shachaf> edwardk: If they're not inlined on purpose, shouldn't they be NOINLINEd?
15:07:01 <edwardk> shachaf: some were just because of the size of the code block
15:07:14 <edwardk> i did some cheesy performance analysis and wound up with the inlining we have there
15:07:33 <lispy> voodoo programming
15:07:34 <edwardk> i have some basic benchmarks for the plated traversals
15:08:00 <lispy> (I'm not claiming to be any better)
15:08:01 <edwardk> so i tuned it by turning on and off some of them to get a ~10% speed gain and stopped mucking with it
15:11:40 <Peaker> dons had a genetic thing to discover best options for ghc for performance
15:11:50 <Peaker> perhaps we can have the same for inlining
15:13:56 <sclv> shld be easy actually
15:14:40 <watermind> elliott: sorry just realised you were answering me... sure that works, but I'm asking for something more akin of  translating   f mx = x <- mx; case x of ...   to pattern matching  on the function's monadic argument.
15:14:57 <sclv> a quick refactor of this old messy thing would handle it http://hackage.haskell.org/package/strictify
15:15:08 <sclv> would be nice to use haskell-src-exts to generalize it
15:15:09 <sclv> an
15:15:10 <sclv> d
15:15:21 <elliott> watermind: ah. you can do that with the new lambdacase stuff
15:15:22 <aavogt> watermind: might be you can fake it by -XQuasiQuotes
15:15:28 <elliott> f mx = mx >>= \case ...
15:15:41 <elliott> watermind: that said, generally you should not write "f mx = mx >>=", just write "f x = ..."
15:15:44 <elliott> and do >>= f
15:15:49 <sclv> erm, and then to have a generalized way of controlled mutation of haskell programs for performance
15:17:15 <watermind> elliott: yes that is a good point, I know one should stick to kleisli arrows
15:17:54 <watermind> elliott: my initial motivation to ask for this were actually guards not pattern matching, and it actually from looking at a simple recursive definition of filterM
15:18:13 <elliott> well, you can do guards with case technically
15:18:23 <glguy> There's the new "if" syntax for guards
15:18:28 <elliott> mx >>= \case x | a -> ... | b -> ...
15:18:48 <x-Suriv> you can do that in a case statement?
15:18:53 <x-Suriv> is that like short hand?
15:18:54 <watermind> elliott: a yes using the lambda case, true
15:19:01 <glguy> XMultiWayIf
15:19:07 <watermind> elliott: I haven't used them yet
15:19:17 <x-Suriv> elliot: is that the same thing as  case x of a -> .....    b ->
15:19:48 <watermind> aavogt: I don't know that... let me check
15:20:02 <cmccann> in my experience you make a lot of problems go away by not having monadic function arguments in the first place. just using guards and pattern matches and all is nicer.
15:20:14 <elliott> i hate lambdacase because it has the wrong syntax for the bikeshed :p
15:20:21 <glguy> http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#multi-way-if
15:20:29 <cmccann> do the monadic binding when you apply the function, not inside it
15:20:38 <elliott> i hate how multi-way if doesn't respect layout too :(
15:21:50 <aavogt> watermind: your comment reminded me of http://hackage.haskell.org/trac/ghc/attachment/ticket/3919/QQ.hs
15:22:00 <Saizan> sometimes it makes sense to have a monadic argument when you're building new control structures, but not in general
15:22:50 <cmccann> Saizan, actually I've often found that what I was treating as a control structure worked better if I did it some other way that allowed non-monadic arguments
15:22:57 <cmccann> not always possible, sure, but still
15:23:01 <watermind> aavogt: cool stuff, I didn't know this
15:25:46 * hackagebot strptime 1.0.10 - Efficient parsing of LocalTime using a binding to C's strptime,  with some extra features (i.e. fractional seconds)  http://hackage.haskell.org/package/strptime-1.0.10 (EugeneKirpichov)
15:29:08 <watermind> is there no lambda multi way if? :/
15:29:54 <watermind> hmm nevermind
15:29:54 <mornfall> What do you mean with a multi way if?
15:30:05 <c_wraith> mornfall: it's an extension :)
15:30:18 <watermind> lambda if would make sense
15:30:26 <watermind> lambda multi way if not really :/
15:31:14 <aristid> watermind: \case
15:32:17 <watermind> aristid: yes case works for \if
15:32:45 <watermind> in any case I would still like 'monadic' guards where I can put monadic bool expressions
15:33:01 <mornfall> You can write them easily enough. :)
15:33:22 <watermind>  \case only lets you test one boolean at a time and you have to nest them
15:33:31 <watermind> and link them with binds
15:33:34 <watermind> not pretty
15:33:43 <aristid> watermind: not true. \case () of -> _ | test1 ; ...
15:34:04 <mornfall> You could also pattern match on a tuple of booleans.
15:34:48 <watermind> aristid: not sure what you mean...
15:34:54 <watermind> mornfall: true I guess one could do that
15:35:19 <watermind> mornfall: put all the boolean expressions in one big tupple, and then pattern match each of them...
15:36:12 <aristid> i don't have the right ghc version to actually test this now.
15:36:24 <watermind> case (b1,b2,b3) of (True,_,_) -> ... ; (False,_,_) -> ;  (_ , True, _) ->   ....
15:36:55 <watermind> ^ this looks really ugly though, and adding another guard means increasing the tuple
15:37:13 <watermind> and adding another guard in the middle means you have to be really carefull not to mess up everything!
15:38:48 <watermind> aristid: not sure if I explained properly... want I wanted was to do     f x | exp1 = ... ;  | exp2  = ... ; | (...)    but with the exps being monadic
15:38:58 <watermind> aristid: I find this quite a pain
15:39:00 <aristid> > case () of _ | False -> 1 ; _ | True -> 2
15:39:02 <lambdabot>   2
15:39:43 <aristid> :t liftA3 (,,)
15:39:45 <lambdabot> Applicative f => f a -> f b -> f c -> f (a, b, c)
15:40:13 <S11001001> watermind: you can write (Monad m, Foldable t) => t (m Bool, a) -> m (Maybe a) totally
15:40:57 <watermind> aristid: oh wait... I was not parsing your case correctly... is that an extension? I have no idea what that is
15:41:24 <aristid> watermind: no what i just let lambdabot evaluate requires no extensions
15:42:10 <watermind> S11001001: that looks insteresting... a bit more generic than I would need but yes :P
15:43:25 <S11001001> @ty foldr ((b, a) rec -> b >>= \b -> if b then return (Just a) else rec) (return Nothing)
15:43:26 <lambdabot>     Pattern syntax in expression context:
15:43:27 <lambdabot>         (b, a) rec -> b >>= \ b -> if b then return (Just a) else rec
15:43:44 <watermind> aristid: so we can add guards like that in cases? I had no idea
15:43:48 <S11001001> oops writing another syntax
15:43:52 <S11001001> @ty foldr (\(b, a) rec -> b >>= \b -> if b then return (Just a) else rec) (return Nothing)
15:43:53 <lambdabot> Monad m => [(m Bool, a)] -> m (Maybe a)
15:43:58 <aristid> watermind: yup we can
15:44:18 <watermind> aristid: I wonder how I've never seen that
15:44:29 <S11001001> so now you can write [(monadic condition, first result), (monadic condition, another result)]; define a syntax for pairing if you want it to look thenny
15:44:39 <watermind> aristid: so where can we write guards...? in function definitions, cases, anywhere else?
15:45:11 <watermind> S11001001: very well thought
15:45:29 <watermind> S11001001: that is a very elegant way to do it indeed
15:48:20 <aristid> watermind: function definition and case expressions, i think.
15:49:30 <madjestic> hey guys, I intend to do a clean install of haskell platform.  I already deleted .cabal and .ghc.  I also see a /usr/lib/ghc-7.4.2 and /usr/lib/ghc-paths-0.1.0.8.  Is it sane to delet them as well?
15:50:09 <lispy> madjestic: Probably. Never tried that though. What prompted the clean install?
15:50:49 <madjestic> lispy: cabal vs. emerge experiment
15:51:09 <madjestic> I had an intention to see which is the least painful
15:51:22 <aristid> madjestic: what was the result so far?
15:51:45 <S11001001> watermind: and if you have findM it's just liftM (snd <$>) . findM fst :)
15:52:24 <madjestic> in terms of dependeny hell, emerge + overlay is safer
15:53:48 <edwardk> stepcut: >>> test & with fooId (>) 3.rows.fooId +~ 2
15:54:04 <stepcut> edwardk: i think a cat just walked on your keyboard
15:54:18 <edwardk> that explains it
15:54:45 <edwardk> thats taking the rows of test where the fooId column is > 3 and adding 2 to the ids
15:54:58 <edwardk> with works as the where clause you can edit
15:55:12 <edwardk> deleteWith key cmp a tbl = tbl & with key cmp a .~ empty
15:55:31 <edwardk> deleteWith fooId (<) 3 test
15:56:01 <edwardk> with eliminates most of my other combinators
15:56:58 <watermind> S11001001: indeed
15:59:06 <watermind> brb
16:01:47 <hpaste> moben pasted “magic number” at http://hpaste.org/79497
16:02:01 <moben> any pointers on how to make this more readable?
16:05:44 <ag4ve> are there any optimizations for ghc-stage1?
16:06:29 <parcs> ag4ve: are you building from a release tarball?
16:10:20 <glguy> moben: which number is that one?
16:10:47 * hackagebot rabocsv2qif 1.1.2 - A library and program to create QIF files from Rabobank CSV exports.  http://hackage.haskell.org/package/rabocsv2qif-1.1.2 (SanderVenema)
16:11:35 <Aune> If does composed functions reduce on use? As in, say I have a function "isInside :: Pos ->  Bool" and I repeatedly apply functions "moveSlightlyToTheLeft :: (Pos -> Bool) -> (Pos -> Bool)", does evaluating the funtion with a Pos collapse the entire chain of funtions?
16:12:46 <mpu> Can I define a datatype that puts a constraint on one of its type parameter?
16:13:00 <mpu> (like Show x)
16:13:08 <c_wraith> In what sense?
16:13:29 <c_wraith> Do you want that constraint to be available whenever you are using that type?
16:13:37 <mpu> yes
16:13:58 <c_wraith> It's..  not the most common thing to want to do, but you might need to try it to find out why
16:14:05 <c_wraith> You can do it with GADTs
16:14:41 <c_wraith> data Foo x y where Foo :: Show x => x -> y -> Foo x y
16:21:47 <moben> glguy: first k digits (read as a number of length k) are divisible by k (forall k in [1..n])
16:22:03 <moben> for n=10 there is only 3816547290
16:27:20 <andsens> Can somebody tell me how I decode html entities to the actual textual values?
16:27:49 <zomg> andsens: have you tried using show?
16:28:04 <andsens> On the string?
16:28:05 <johnw> what is the type of an html entity?
16:28:08 <S11001001> first, get a DTD parser :>
16:28:09 <hpaste> glguy annotated “magic number” with “magic number (annotation)” at http://hpaste.org/79497#a79498
16:28:13 <zomg> Ohh right I think I misunderstood
16:28:23 <zomg> You mean things like &nbsp; ?
16:28:25 <glguy> moben: I don't know that that's clearer, but it's much faster because it doesn't recompute as much
16:28:28 <andsens> zomg, yes
16:28:45 <zomg> I would imagine there is a library that can do that
16:28:55 <andsens> The problem is, I only want the string conversion, not an entire parser
16:29:07 <andsens> I already have that, my own :-)
16:29:29 <S11001001> andsens: (that's where the entities are defined)
16:30:31 <andsens> S11001001: I was hoping not to have to do another lookup of stuff
16:30:33 <zomg> andsens: looks like Text.HTML.TagSoup might have what you want
16:30:43 <zomg> http://hackage.haskell.org/packages/archive/tagsoup/0.6/doc/html/Text-HTML-TagSoup-Entity.html
16:30:55 <andsens> zomg: I have looked at that and can't find the proper method
16:31:14 <andsens> zomg: That's a lookup table. I want to do it for an entire string
16:31:15 <zomg> lookupNamedEntity as far as I can tell should work, you just need to strip & and ;
16:31:36 <zomg> Oh in that case you'd probably need to write a parser that uses lookupNamedEntity to process a string
16:31:53 <andsens> zomg: Exactly, this is going to be tedious. I just want a encoded string in decoded string out function
16:32:20 <johnw> andsens: you still haven't told us the type of the thing that you have
16:32:35 <S11001001> andsens: look around elsewhere in tagsoup for text parsers
16:32:38 <zomg> andsens: you could probably write it as a pretty straightforward fold over the string
16:32:43 <andsens> johnw: A simple string with zero or more html entities in it
16:33:09 <johnw> how are you expecting to decode that without a parser?
16:33:42 <andsens> johnw, not entirely without one, but simply a string converter of sorts
16:33:57 <johnw> i suggest tagsoup as well
16:34:04 <johnw> parser *are* "string converters"
16:34:42 <andsens> johnw: no, unless you count any program with input -> output as a parser
16:34:57 <johnw> if they interpret the contents of the input, yes
16:35:17 <dibblego> you'd be surprised how many programs are in fact, parsers in disguise
16:35:19 <andsens> but that's kind of missing the point...
16:35:45 <andsens> I wouldn't call that colloquial use
16:35:56 <dibblego> I think recognising that parsers are string converters is a point worth not missing
16:38:02 <andsens> dibblego, but that would mean a parser *always* outputs strings...
16:38:18 <johnw> you said input -> output, not input -> string
16:38:33 <andsens> and dibblego said string converter
16:38:37 <andsens> ah
16:38:38 <andsens> ok
16:38:38 * glguy tags this debate #productive
16:38:53 <andsens> something that converts a string to *something else*
16:38:56 <moben> glguy: thanks, I'll have to look up what 'go' does tomorrow, I haven't gotten that far in lyah yet :)
16:39:04 <johnw> and, possibly, another string :)
16:39:08 <dibblego> andsens: I have some basic parser exercises on github; I think it will give you some insight into why this is true
16:40:04 <glguy> moben: sounds good. Which part haven't you seen before?
16:40:05 <andsens> dibblego: not necessary. I can assure that I am not entirely missing the point, it's mostly technicalities.
16:40:12 <johnw> i'm hit my first "please report this as a bug to GHC" crash :)
16:40:57 <dibblego> yes, it is a technicality, an important one
16:41:19 <moben> glguy: just 'go' I think
16:41:30 <glguy> go is a function defined below in the where clause
16:41:46 <johnw> i love how easy mutable code makes it to create crashing programs
16:41:56 <glguy> moben: just like firstNums and toNum
16:41:59 <johnw> i had an off-by-one error, but it makes 15 to track down because I stomped memory
16:42:06 <johnw> s/makes 15/takes 15 mins
16:42:32 <moben> should have read that better before commenting I guess..
16:42:55 <ag4ve> parcs: pretty much - gentoo package
16:43:03 <beaky> hello
16:43:03 <johnw> it's a common idiom to call a function's internal helper function 'go'
16:43:13 <johnw> hi beaky!
16:43:14 <parcs> ag4ve: by default stage1 is compiled with -O i think
16:45:57 <ag4ve> parcs: so, it can only be optimized at compile time? whatever parser / haskell compilation it does is static from that point forward?
16:47:51 <parcs> ag4ve: i don't understand
16:48:04 <johnw> aristid: pingeth
16:49:20 <moben> glguy: I think I get what's going on there now, thanks :)
16:49:37 <glguy> Oh, great :)
16:50:19 <aristid> johnw: pongeth?
16:50:26 <zomg> andsens: figure it out yet?
16:50:33 <johnw> i'm creating my custom service with (s3 HTTP "localhost" False) { s3Port = 10001 }
16:50:52 <johnw> but tcpdump verifies that no connection attempt is being made to http://localhost:10001
16:51:00 <johnw> i can telnet there just fine
16:51:09 <ag4ve> parcs: there's no way to tell ghc-state1 to use more or less threads?
16:51:10 <hpaste> andsens pasted “entity decode” at http://hpaste.org/79499
16:51:25 <andsens> zomg: Any way this can get shorter?
16:51:27 <aristid> johnw: uh
16:51:40 <johnw> andsens: usingp arsec, absolutely :)
16:51:42 <geekosaur> johnw, beware of ports in haskell, theyt tend to want to be in network byte order which is byteswapped from intel-compatible CPUs
16:51:58 <andsens> johnw. It's used inside parsec
16:52:01 <zomg> andsens: dunno, looks a bit similar to what I wrote :) Was bored so figured I'll give it a shot http://jjh.fi:8080/~jani/temp/ents.hs
16:52:19 <johnw> andsens: but that doesn't look like a Parsec parser.  what's the type of entity_decoder?
16:52:28 <geekosaur> check if it's trying to connect to port (I think) 4391
16:52:30 <andsens> zomg: yep, pretty much the same :-)
16:52:59 <andsens> johnw: No that part isn't, all the other stuff that uses it is
16:52:59 <johnw> ok
16:53:17 <parcs> ag4ve: to use more or less threads for what? for compiling stage2 and the libraries?
16:53:21 <geekosaur> (I think fromIntegral will work if that's the problem)
16:53:22 <aristid> johnw: if what geekosaur said doesn't work i'd need more info, how you call the thing
16:53:28 <johnw> geekosaur: no
16:53:33 <aristid> johnw: does the request succeed and call the public s3?
16:53:36 <johnw> i call it with 'aws'
16:53:38 <johnw> yes
16:53:43 <johnw> if I use defServiceConfig, everything works fine
16:53:55 <johnw> i'm just straight-up swapping that out with this
16:54:25 <aristid> johnw: no i mean when you use localhost, what happens
16:54:30 <aristid> does the connection timeout?
16:54:33 <johnw> ?
16:54:39 <johnw> no connection attempt is made at all
16:54:49 <aristid> johnw: what happens _on the haskell side_
16:54:57 <johnw> i'm not following
16:55:04 <johnw> i have no idea what happens once aws gets a hold of it
16:55:07 <aristid> johnw: does aws return with an error?
16:55:12 <johnw> oh
16:55:14 <johnw> yes
16:55:20 <aristid> which?
16:55:23 <johnw> suppose I should print that out... heh
16:55:24 <johnw> sorry
16:55:29 <aristid> :P
16:57:34 <aristid> johnw: so what's the error?
17:01:10 <johnw> how do I catch an exception?
17:01:15 <johnw> I keep getting IO != ResourceT IO...
17:01:27 <johnw> now I'm trying to use readResponse, but that doesn't mtach up either
17:01:35 <johnw> i'm not veryp familiar with the ResourceT transformer
17:03:14 <Cale> johnw: Try the catch from Control.Exception.Lifted
17:05:15 <mpu> Can I hide an instance when importing a module? Otherwise I get overlapping instances.
17:06:26 <aristid> johnw: doesn't the program print the message somewhere?
17:06:47 <aristid> johnw: you can use runResourceT though to get the IO
17:07:11 <moben> glguy: I got one question though: Why implement pickOne like this? I would have done [ (x,delete x xs) | x <- xs ]
17:07:16 <moben> is that slower?
17:07:52 <johnw> aristid: getAddrInfo: does not exist (nodename nor servname provided, or not known)
17:07:58 <johnw> aristid: no, it didn't
17:08:04 <johnw> i moved my catch handler out outside the runResourceT
17:08:05 <aristid> johnw: there's also this: http://hackage.haskell.org/packages/archive/lifted-base/0.2.0.2/doc/html/Control-Exception-Lifted.html
17:08:08 <glguy> moben: I don't think it matters in this case, I had it with delete at first
17:08:14 <aristid> johnw: ok! try 127.0.0.1
17:08:16 <johnw> interesting, thanks!
17:09:03 <johnw> no change
17:09:53 <aristid> johnw: also try the following: simpleHttp "http://localhost:10001"
17:09:59 <aristid> or whatever the correct url is
17:10:03 <aristid> you can do that right in ghci
17:10:05 <johnw> do I pass True for useUri or whatever it's called?
17:10:20 <aristid> no, it should be False.
17:10:32 <johnw> where is simpleHttp from?
17:10:38 <johnw> http-conduit?
17:10:51 <johnw> aha
17:10:54 <johnw> Exception: connect: does not exist (Connection refused)
17:10:58 <aristid> ok
17:11:00 <johnw> you know, this is good
17:11:13 <johnw> all of the network-http-conduit tests fail with the same error, and that's on my list to track down
17:11:18 <johnw> so it looks like it needs to happen now
17:11:22 <aristid> johnw: so now we know the problem is somewhere in http-conduit or your own networking setup:)
17:11:50 <johnw> yep, cabal test in http-reverse-proxy has a bunch of failures for the same reason
17:11:53 <johnw> thanks aristid
17:12:14 <aristid> johnw: :) always glad to redirect blame... i mean always glad to help!
17:13:30 <johnw> oh, wait
17:13:37 <johnw> it failed because i changed the server's port to 4391 for glguy
17:14:08 <johnw> simpleHttp works fine
17:14:21 <johnw> aws does not
17:14:32 <johnw> getAddrInfo: does not exist (nodename nor servname provided, or not known)
17:15:28 <johnw> should I be using VHostStyle?  s3UseUri?
17:17:29 <aristid> johnw: um i don't believe aws actually wants network-order
17:17:38 <aristid> johnw: it passes the port right down to http-conduit
17:17:49 <aristid> so if simpleHttp accepts 4391, so does aws
17:17:51 <johnw> well, it says "nodename not known"
17:17:57 <johnw> i restarted the server on 10001
17:18:46 <johnw> i don't think this a port number issue
17:19:22 <aristid> sorry i'm not sure anymore what you're doing
17:19:34 <johnw> defServiceConfig works
17:19:37 <johnw> ((s3 HTTP "localhost" False) { s3Port = 10001 }) does not
17:19:45 <johnw> simpleHttp "http://localhost:10001" does
17:19:53 <johnw> aws isn't even opening the port
17:20:06 <johnw> also, using "127.0.0.1" does not help
17:21:19 <aristid> johnw: can you try setting the loglevel to Debug and report the output?
17:21:23 <johnw> oh, interesting
17:21:27 <johnw> haha, i just did that
17:21:33 <johnw> Debug: Host: "fpco-john-development.127.0.0.1"
17:21:45 <aristid> wtf is going on there
17:21:45 <johnw> i'll put that in /etc/hosts and try
17:22:16 <aristid> johnw: i sure as hell am not manipulating hosts in aws
17:22:36 <johnw> hmm
17:23:01 <johnw> you're showing "Host: " ++ show (HTTP.host httpRequest)
17:23:04 <aristid> johnw: oh nevermind.
17:23:10 <aristid> johnw: i know the problem now i think
17:23:31 <aristid> johnw: use PathStyle.
17:23:49 <johnw> heh, editing /etc/hosts worked
17:23:52 <johnw> but i'll try that too
17:24:10 <aristid> johnw: the thing is that s3 normally uses bucket.endpoint as the host
17:24:18 <aristid> i forgot that briefly :D
17:25:00 <johnw> 19:15 <johnw> should I be using VHostStyle?  s3UseUri?
17:25:01 <johnw> :)
17:25:11 <johnw> PathStyle does not help
17:25:13 <johnw> no change
17:25:23 <johnw> ((s3 HTTP "localhost" False) {s3Port = 10001 , s3RequestStyle = PathStyle })
17:25:23 <aristid> johnw: what's the Host: with PathStyle?
17:25:27 <johnw> same
17:25:42 <aristid> no way!
17:25:45 <johnw> yes way!
17:25:58 <aristid> PathStyle   -> ([Just s3Endpoint], [Just "/", fmap (`B8.snoc` '/') s3QBucket, s3QObject])
17:25:59 <aristid> see!
17:26:02 <aristid> it must!
17:26:23 <johnw> i have other windmills to get to, so setting /etc/hosts for now...
17:26:42 <aristid> johnw: how were you telling s3 to use PathStyle?
17:26:52 <johnw> i pasted it above
17:27:38 <aristid> johnw: sorry my head is not entirely clear due to drinking a bit of beer. missed that.
17:29:29 <johnw> uh oh, drunk coding...
17:29:33 <aristid> johnw: i still can't make sense of the Host not changing when you use PathStyle instead of BucketStyle
17:29:53 <aristid> johnw: i'm not coding:) i was watching youtube videos before you asked me about this problem
17:30:06 <johnw> oh, sorry to interrupt
17:30:11 <johnw> lolcats, I hope
17:30:23 <aristid> lol
17:30:39 <johnw> oh, I have more weirdness for you
17:30:48 <johnw> for a PUT, the hostname is "fpco-john-development.127.0.0.1"
17:30:55 <johnw> for a GET, the hostname is "fpco-john-development.localhost"
17:30:57 <aristid> still using PathStyle?
17:31:01 <johnw> no, not using PathStyle
17:31:13 <aristid> and with PathStyle?
17:31:17 <johnw> one sec
17:31:22 <johnw> trying 127.0.0.1 now
17:31:23 <aristid> fpco-john-development _is_ the bucket name?
17:31:24 <mpu> When I am in a StateT transformed (Either x) monad, is there a shortcut to lift $ Left x ?
17:31:28 <johnw> yes, that's the bucket
17:31:38 <johnw> mpu: definey our own helper function
17:31:58 <aristid> mpu: EitherT?
17:32:15 <mpu> aristid: no StateT s (Either ErrorType)
17:32:17 <johnw> ok, with PathStyle
17:32:26 <johnw> PUT: "fpco-john-development.127.0.0.1", GET: "localhost"
17:32:32 <johnw> so, not a lot of uniformity going on here :)
17:32:34 <aristid> johnw: wut
17:32:58 <johnw> using "127.0.0.1" with BucketStyle results in "fpco-john-development.127.0.0.1" for both
17:33:01 <johnw> so at least I can work with that
17:33:13 <aristid> johnw: can you also show the "String to sign" output?
17:33:19 <aristid> that should contain more useful info
17:33:23 <johnw> for which one?
17:33:34 <aristid> PathStyle PUT
17:34:42 <johnw> rebuilding...
17:35:09 <johnw> Debug: String to sign: "PUT\n\n\nWed, 19 Dec 2012 01:34:33 GMT\n/fpco-john-development/98c3f387f63c08e1ea1019121d623366ff04de7a"
17:35:12 <johnw> Debug: String to sign: "GET\n\n\nWed, 19 Dec 2012 01:34:33 GMT\n/fpco-john-development/98c3f387f63c08e1ea1019121d623366ff04de7a"
17:35:24 <johnw> (yes, I PUT and then GET the same object)
17:35:31 <aristid> ok
17:35:55 <aristid> johnw: well i realized string to sign does this normalization so what i looked for isn't there :D
17:36:13 <johnw> ok, using GET on my mock_s3, I'm getting "Missing ETag"
17:36:19 <johnw> so gotta find out why mock_s3 is being weird
17:37:07 <aristid> johnw: can you add a logging line (just like the String to sign line) for sqHost, sqPath and sqPort in Aws/Aws.hs line 214?
17:37:29 <johnw> one sec, i've since moved on from that
17:37:34 <johnw> do you want to setup mock_s3 on your side?
17:37:54 <aristid> no
17:37:58 <aristid> not now
17:38:01 <johnw> ok, onec sec then
17:38:14 <aristid> right, i'll be right back too.
17:38:35 <johnw> sqPath on what value?
17:38:52 <johnw> sqHost q?
17:39:46 <johnw> looks like
17:39:58 <johnw> i'm going to privmsg you from this point
17:48:26 <hpaste> mpu pasted “mpu” at http://hpaste.org/79500
17:48:44 <mpu> What do you guys think of this?
17:50:30 <dmwit> Looks like a brilliant way to leak memory left and right.
17:51:04 <mpu> dmwit: what do you mean?
17:51:34 <dmwit> Your (<|>) traverses the remaining tokens twice, forcing them to stay in memory even if one branch is definitely going to be the one you take.
17:54:32 <mpu> dmwit: I should clear the state in the Left Left case, is that it?
17:54:57 <dmwit> There's not much you can do about it. The standard fix is to commit unless the user explicitly asks you not to.
17:55:06 <dmwit> (This is what, e.g., Parsec does.)
17:55:40 <mpu> So I think I do not clearly see the problem...
17:58:00 <mpu> Oh maybe I have a little clue, you have to specify to parsec when you want to be able to backtrack, but here it can backtrack arbitrarily swallow.
17:58:38 <dmwit> right
17:59:05 <keb> How do i program timers in haskell, I assume I have to make some sort of system call to tell it to execute the following code after the timer expires, is this call unique to each OS? Is there a UNIX standard way to do this? Is this the same underlying mechanism that fixes videogame frame rate and lets audio be played at the proper speed?
17:59:05 <mpu> well it is comfortable! just memory hungry
17:59:14 <dmwit> also right =)
17:59:29 <dmwit> keb: threadDelay
18:00:00 <mpu> dmwit: I feel like, but maybe I'm wrong, this will not cause any performance issue (except if the memory blows up). Is it right?
18:00:13 <dmwit> hard to say
18:00:19 <dmwit> backtracking costs time, too =)
18:00:32 <mpu> dmwit: yeah but this is relative to the user of this module
18:00:39 <keb> if I was building an audio source from scratch is threadDelay the call I would reach for?
18:01:00 <dmwit> My guess is the tool you'd reach for is a binding to an already-written library.
18:01:19 <keb> if I was building it from scratch though
18:01:26 <dmwit> Why would you build it from scratch?
18:01:46 <dmwit> mpu: I don't really know what you mean by "relative to the user of this module"
18:02:15 <keb> at some point you have to be able to reason about how many times a second certain aspects of your program are actually run. How do you design and implement periodicity in a haskell program
18:02:16 <dmwit> keb: Anyway, I don't know whether you'd reach for threadDelay, but probably not.
18:02:45 * dmwit doesn't have to reason about how many times a second aspects of his programs are actually run
18:03:07 <keb> dmwit is most unhelpful, can we ban him?
18:03:53 * elliott thinks trying to get dmwit banned is likely to backfire
18:03:57 * elliott has admittedly not read the context though.
18:04:15 <parcs> keb: yes, the #haskell police will get right on it :P
18:04:30 <mpu> dmwit: I mean that if I make little use of backtracking while using this module, I hope I will not have really low performance.
18:04:49 <dmwit> mpu: I hope so, too. =)
18:05:18 <keb> can someone hlep me on my issues of periodicity and audio?
18:05:22 <mpu> dmwit: To "commit" branching, do they use kind of a continuation?
18:05:41 <djahandarie> keb, I've had a little more luck using usleep than threadDelay for high precision timing
18:06:02 <dmwit> Hm. I'm not sure whether they actually use continuations, but they certainly wouldn't have to.
18:06:09 <djahandarie> From System.Posix.Unistd.
18:06:19 <djahandarie> Don't have much experience with audio though, sorry about that.
18:06:58 <mpu> dmwit: So how could I implement this "commit" in <|> ?
18:07:02 <keb> aren't there bulit in language abstractions for things like this that don't require deep library knowledge?
18:07:46 <dmwit> You are a very strange dude. "I want to build it from scratch, but without having to understand the domain I'm working in."
18:08:02 <keb> dmwit stop talking
18:08:31 * elliott thinks keb should stop talking if he's going to respond to people trying to help him like that.
18:08:47 <dmwit> mpu: I'm not actually sure! I never looked into how Parsec does it.
18:09:03 <djahandarie> keb, I think he's just trying to point out what your question sounds like, rather than saying that is what it actually is. I don't know your domain very well, so I can't answer your question wrt abstractions that are useful for audio.
18:09:13 <dmwit> I would think you'd want a function that could look at a parser and a single token and know right away whether that parser can start off consuming that token.
18:09:27 <dmwit> But I'm not sure after all that that is the simplest way to do it.
18:10:01 <djahandarie> keb, short of waiting of someone who has done that stuff first-hand, you could always poke around in one of the existing audio libraries to see what they do, or maybe generalize your question some so that more people could pitch in.
18:10:06 <hpaste> lispy pasted “Monomorphic pattern bind?” at http://hpaste.org/79501
18:10:37 <lispy> Anyone know what is wrong with my attempted example in that paste?
18:10:54 <lispy> Reading the user guide I expected a type error, but it works here for me on ghc 7.0.1 and 7.4.1
18:11:00 <dmwit> lispy: There's no pattern binding?
18:11:06 <dmwit> oh, [x]
18:11:26 <dmwit> Yeah, [x] = return a is monomorphic, but not in the way you think.
18:11:27 <mpu> dmwit: They seem to have what I called a 'continuation', i.e. a function in the current state that tells what to do in case of failure, this function is called by empty in case of error. In the monad 'sequence' (>>=) they forget this callback.
18:11:47 <dmwit> It's monomorphic once you're inside the scope of 'bar', i.e. once you've supplied the values of the type variables in bar's foralls.
18:11:50 <dmwit> ...I think.
18:11:56 <lispy> dmwit: ah, that could be
18:12:31 <lispy> dmwit: So can you think of a better test case?
18:12:34 <dmwit> mpu: interesting
18:13:42 <dmwit> lispy: err... not off the top of my head
18:15:08 <dmwit> I'm actually sort of surprised that the manual doesn't have such an example.
18:15:58 * lispy tries google
18:16:21 * lispy tries http://hackage.haskell.org/trac/ghc/ticket/4940
18:18:40 <lispy> dmwit: ah, documentation bug
18:19:04 <lispy> dmwit: in 7.0.x that code snippet is an error but by 7.4.x -XMonoPatBinds is removed
18:19:29 <dmwit> doh
18:21:07 <sw2wolf> :t on
18:21:08 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
18:23:47 <sw2wolf> :t compare `on` snd
18:23:48 <lambdabot> Ord b => (a, b) -> (a, b) -> Ordering
18:23:53 <hrumph> yo
18:24:09 <dmwit> w3rd
18:24:20 <djahandarie> Am I the only person who really hates the function name 'on'? I swear that name only works on specific parameters, not in the general case.
18:24:40 <dmwit> :t comparing snd -- sw2wolf
18:24:40 <hrumph> i want to include a type declarion inside an instance declaration (just so i can remember what its supposed to be)
18:24:41 <lambdabot> Ord a => (a1, a) -> (a1, a) -> Ordering
18:24:53 <hrumph> is there any way i can do that let me post what it is i want to do hold on
18:24:57 <dmwit> hrumph: That's too bad.
18:24:57 <djahandarie> > ((+) `on` (*2)) 1 1
18:24:58 <lambdabot>   4
18:25:24 <rwbarton> hrumph: you can do that in the future I think (7.6)
18:25:26 <dmwit> hrumph: You can sort of do it, e.g. instance Functor Foo where fmap = {- ... -} :: (a -> b) -> Foo a -> Foo b
18:25:27 <djahandarie> Add on the double? Must really be stretching it there if that makes any sense.
18:26:07 <lispy> dmwit: http://hackage.haskell.org/trac/ghc/ticket/7508
18:26:29 <sw2wolf> How can i privmsg ":t Foo" to lambdabot ?
18:26:35 <dmwit> lispy: =)
18:26:39 <djahandarie> sw2wolf, with @type instead of :t
18:26:39 <shachaf> sw2wolf: @ty Foo
18:26:41 <dmwit> sw2wolf: Use ?ty or ?type instead.
18:27:24 <sw2wolf> thx
18:28:50 <sw2wolf> one more question how to privmsg "sqrt 100" to lambdabot ?
18:29:08 <dmwit> > sqrt 100
18:29:08 <lispy>  /msq lambdabot > sqrt 100
18:29:09 <lambdabot>   10.0
18:29:18 <lispy> msg*
18:29:31 <sw2wolf> ok, great
18:30:01 <djahandarie> sw2wolf, it may make sense to just get ghci, though. :p
18:30:03 <lispy> if you /query lambdabot then you don't have to explicitly say "/msg lambdabot" before each query
18:30:13 <lispy> or tryhaskell.org
18:30:31 <sw2wolf> djahandarie: yes, but sometimes there is no  ghci by hand
18:30:49 <hrumph> i guess i can resort to using comments for now
18:31:10 <hrumph> i'd like to see the type right there in the instance
18:31:26 <djahandarie> @. djinn type on
18:31:28 <lambdabot> f a b c _ = a (b c) (b c)
18:31:43 <shachaf> @@ @pl @djinn @type on
18:31:45 <lambdabot>  f = ((const .) .) . join . liftM2
18:31:47 <sw2wolf> lispy: tryhaskell.org is wonderful but it seems it doesnot support Copy/Paste ?
18:31:50 <djahandarie> That's not the right function
18:31:52 <shachaf> That doesn't look right at all.
18:32:06 <shachaf> djinn! You're better than that.
18:32:08 <shachaf> @ty on
18:32:10 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
18:32:12 <rwbarton> @@ @type @pl @djinn @type on
18:32:15 <lambdabot>  parse error on input `='
18:32:20 <rwbarton> oh
18:32:31 <rwbarton> :t ((const .) .) . join . liftM2
18:32:32 <lambdabot> (Monad f, Functor f) => (a1 -> a1 -> a) -> f a1 -> f (b -> a)
18:32:43 * rwbarton dies inside
18:32:44 <djahandarie> I thought it would have tried to be more total, I wonder why it wasn't.
18:32:56 <lispy> sw2wolf: oh, we should report that as a bug.
18:33:05 * lispy wonders how to contact chris
18:33:14 <shachaf> @@ @type let (@pl @djinn @type on) in f
18:33:17 <lambdabot>  (Monad f, Functor f) => (a1 -> a1 -> a) -> f a1 -> f (b -> a)
18:33:20 <djahandarie> lispy, perhaps twitter would work.
18:33:39 <rwbarton> @@ @type let (.) = (Prelude..) in let (@pl @djinn @type on) in f
18:33:42 <lambdabot>  (a1 -> a1 -> b) -> (a -> a1) -> a -> b1 -> b
18:33:44 <djahandarie> shachaf, never knew you could do that with @@.
18:34:05 <shachaf> djahandarie: @@ has many secrets
18:36:27 <Ralith> terrible, terrible secrets
18:36:29 <cmccann> yes, it lets you use rot13 to reveal the dark truth about shachaf.
18:37:09 <shachaf> pzpp, naa
18:38:07 <coleman-> > let range x y = if x < y then [x..y] else [x,pred x..y] in (range 0 5, range 5 0)
18:38:09 <lambdabot>   ([0,1,2,3,4,5],[5,4,3,2,1,0])
18:38:14 <coleman-> is there a function like this in standard lib?
18:39:02 <dmwit> nope
18:40:19 <shachaf> coleman-: It's rare that you don't actually know which direction the range goes in.
18:45:21 <mikeplus64> @@ @pl @djinn a -> Maybe a
18:45:21 <lambdabot>  f = Just
18:45:43 <mikeplus64> @@ @pl @djinn Maybe a -> (a -> b) -> Maybe b
18:45:43 <lambdabot>  (line 1, column 37):
18:45:43 <lambdabot> unexpected '>'
18:45:43 <lambdabot> expecting operator
18:55:10 <roconnor> what's the difference between Data and Typeable?
18:56:53 <hrumph> ok i'm really green with haskell i'm reading the book lyahsfgg
18:57:06 <rwbarton> Typeable just identifies the type, Data lets you convert it into a sum-of-products sort of thing (roughly)
18:57:36 <roconnor> rwbarton: what does Typeable allow?  safeCoercion and that's all more or less?
18:58:19 <hrumph> supposing we have an object of type IO [char]. how can i extract the [char] part out when not in a do loop, or am i not supposed to attempt that?
18:58:34 <hrumph> not in a do thingy i mean
18:58:40 <hrumph> loops it the wrong word
18:59:27 <rwbarton> roconnor: that sounds right, I think
19:00:45 <Ralith> hrumph: >>=
19:00:50 <Ralith> :t (>>=)
19:00:52 <lambdabot> Monad m => m a -> (a -> m b) -> m b
19:01:09 <roconnor> does deriving typable require the coponents of the data to be typable?
19:01:34 <ivanm> roconnor: for the actual instance to exist I would assume so
19:01:42 <hrumph> ralith that won't let me get it out. that will only let me manipulate within the context of m
19:01:49 <rwbarton> no
19:02:31 <hrumph> i'm going to assume that there is no general way to do it
19:02:34 <coleman-> > liftM (+10) (Just 10)
19:02:34 <rwbarton> if you define a type Foo in module Bar the TypeRep of the derived instance might as well just be the string "Bar.Foo"
19:02:35 <lambdabot>   Just 20
19:02:57 <rwbarton> i.e. it doesn't depend at all on the definition of Foo
19:03:07 <Ralith> hrumph: why do you want to do that?
19:03:09 <roconnor> so abstract types cannot be typeable?!
19:03:20 <hrumph> ralith i don't think you should be able to do it. it probably doesn';t make sense even
19:03:23 <coleman-> hrumph there is no IO [String] -> [String] function, no, because it can't exist
19:03:28 <hrumph> i'm just trying to get my head around these entirely new concepts
19:03:38 <coleman-> you can use things like liftM as I used in the Maybe example above
19:04:13 <rwbarton> roconnor: why do you say that? I don't understand
19:04:18 <rwbarton> what is an "abstract type"
19:04:52 <ion> aristid: There doesn’t seem to be a data type like Network.URI.URI (but with ByteStrings) in http-types. I take it some package includes one that uses the types from http-types, and has a parser and renderer for it?
19:04:59 <roconnor> rwbarton: a type from a module that doesn't export constructors
19:05:14 <rwbarton> then why? has nothing to do with data constructors
19:05:44 <roconnor> rwbarton: thats what I thought
19:06:15 <roconnor> ah you said it doesn't depend on the definition of Foo
19:06:16 <roconnor> good.
19:06:53 <coleman-> hrumph you can do `liftM reverse getLine'. if it wasn't clear from the Maybe example
19:07:46 <ivanm> I was planning on using multi-way-if for something, but haskell-mode for emacs doesn't support it and it's too much of a pain to fight with my editor...
19:09:46 <edwardk> johnw: its now up in an actual repository: github.com/lens/tables
19:11:13 <hrumph> coleman-: i haven't learned the lift functions yet
19:11:32 <hrumph> i'm still really only at the functors part of the book
19:11:40 <hrumph> but i keep jumping ahead and around
19:12:02 <ivanm> liftM == fmap (for any Monad that has a Functor instance)
19:16:25 <flebron> :t liftM
19:16:27 <lambdabot> Monad m => (a1 -> r) -> m a1 -> m r
19:16:35 <flebron> Why is there a1 and r, and not, say, a and b?
19:16:38 <beaky> liftM is just another word for fmap
19:16:45 <ivanm> flebron: r is short for "result"
19:16:48 <ivanm> it's just a convention
19:16:56 <ivanm> based upon how the typechecker assigns variables
19:16:59 <ivanm> which is often weird
19:22:28 <johnw> edwardk: nice!
19:30:54 <Moggle> Question: is dynamic module loading possible in Haskell?
19:31:02 <johnw> sure
19:31:06 <Moggle> .Net/Java have Reflection, and even in things like python you can import things dynamically
19:31:13 <johnw> now, do you mean of Haskell code, or of FFI libraries?
19:31:17 <M30W> Hello world.
19:31:20 <Moggle> Haskell code preferably.
19:31:26 <johnw> there is hint
19:31:29 <Moggle> I'd like to write a sort of generic plugin system
19:31:40 * M30W didn't sleep still but "morning" "evening" or whatever.
19:31:46 <johnw> also, dynamic loading is essentially what ghci does
19:31:56 <johnw> but i'm not sure if that mechanism is generally accessible
19:32:07 <johnw> and by dynamic loading, all I mean is loading modules at runtime
19:32:11 <johnw> not true dynamic loading
19:32:20 <Moggle> johnw: well, can you compile haskell things into .dlls or .so's?
19:32:28 <johnw> yes, you can do that too
19:32:38 <hpc> haskell does true dynamic loading too, if you don't mind it being quite hideous
19:32:41 <Moggle> that might be good enough for me then
19:32:51 <hpc> and i think calling the actual functions is a bit hard
19:32:52 <Moggle> hpc: define hideous
19:32:55 <johnw> hpc: do you know of a small example?
19:33:02 <hpc> i do not
19:33:12 <hpc> i remember seeing it on the wiki and thinking "i will never learn this"
19:33:26 <hpc> but that was a few years ago when i was young and dumb(er)
19:34:05 <Moggle> hmm
19:34:11 <ivanm> is there a way to get the inverse of a type family?
19:34:49 <ivanm> I'm writing stuff that works for generic mutable vectors, but for some operations I need to drop to pure vectors; however the type class is "instance (MVector (Mutable v) a) => Vector v a"
19:34:50 <Moggle> I suppose it would be possible to loop over everything in a directory with a script and generate some haskell code that links everything in there
19:35:07 <ivanm> if v is an instance of MVector, how do I say that there's also an equivalent Vector instance?
19:35:12 <Moggle> wouldnt be a true plugin but it might be good enough for my plans
19:36:33 <Moggle> are global variables even a thing in haskell
19:36:37 <Moggle> something tells me no
19:36:45 <elliott> foo :: Int; foo = 42
19:36:47 <elliott> It doesn't vary, though.
19:36:55 <Moggle> elliott: preferably something mutabl
19:37:02 <Moggle> you could create an IO String no problem
19:37:03 <hpc> Moggle: global "constants"
19:37:05 <Moggle> but making it mutable is hard
19:37:11 <Moggle> err
19:37:14 <ivanm> Moggle: you can use MVars in IO
19:37:15 <hpc> making it mutable is the unsafePerformIO hack
19:37:24 <hpc> and it's doubleplus ungood
19:37:33 <ivanm> STVars in ST, TVars in STM, etc.
19:37:43 <coleman-> Moogle it's easy to get mutability with MVars or IORef
19:37:44 <hrumph> moggle i haven't studied this topic yet. this is my fifth night of reading about haskell or so...but readers and writers sounds like something you could use for a global variable
19:37:52 <ivanm> hpc: cue ndm's command-line argument library? :p
19:37:56 <Moggle> hrumph: I'll look into those, thanks.
19:38:08 <Moggle> I suspect I don't actually NEED global variables
19:38:14 <Moggle> and I'm just not thinking about this in a haskelly way
19:38:22 <ivanm> there's also some pre-processor that lets you avoid having an explicit global state argument passed around IIRC
19:38:26 <Moggle> bloody imperative languages have corrupted my mind
19:38:29 <M30W> type File = (Int, String, String) -- How would I define an object to that type? I'm in ghci
19:38:33 <hrumph> with readers and writers you can maniuplate impure data
19:38:34 <ivanm> Moggle: the other alternative is to use a State monad
19:38:37 <kennyd> Moggle you want a mutable global variable?
19:38:42 <ivanm> M30W: "object" ?
19:38:51 <Moggle> ivanm: that sounds like precisely what I want
19:38:55 <M30W> ivanm: Well.. variable *
19:38:59 <sipa> :t (5, "fortytwo", "pi")
19:39:00 <lambdabot> Num t => (t, [Char], [Char])
19:39:02 <M30W> turpls *
19:39:08 <sipa> :t (5 :: Int, "fortytwo", "pi")
19:39:10 <lambdabot> (Int, [Char], [Char])
19:39:18 <M30W> sipa: I mean, named to that type?
19:39:21 <ivanm> as sipa did; just define it! ;-)
19:39:35 <sipa> variable :: (Int, String, String)
19:39:35 <ivanm> M30W: (5, "fortyTwo", "pi") :: File
19:39:41 <M30W> Hmmm
19:39:44 <sipa> variable = (5, "fortytwo", "pi")
19:40:00 <M30W> Thankyou
19:40:03 <M30W> Yea, I got it ^_^
19:42:24 <M30W> Hehe.. fail.
19:42:37 <M30W> let files = x:files
19:42:45 <M30W> What would be the non recursive way for that?
19:43:03 <ivanm> what are you trying to do?
19:43:11 <glguy_> ?type repeat
19:43:12 <lambdabot> a -> [a]
19:43:14 <M30W> get a list of Files
19:43:18 <ivanm> > let files = a:files in files
19:43:19 <lambdabot>   [a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,...
19:43:43 <ivanm> M30W: use a library that gets files from the file-system for you
19:43:45 <M30W> ivanm: I know what I did wrong. just don't know how to get it how I want it.
19:43:52 <ivanm> @hoogle FilePath -> IO [FilePath]
19:43:52 <lambdabot> System.Directory getDirectoryContents :: FilePath -> IO [FilePath]
19:43:52 <lambdabot> Graphics.UI.GLUT.Initialization initialize :: String -> [String] -> IO [String]
19:43:52 <lambdabot> System.FilePath.Windows splitDirectories :: FilePath -> [FilePath]
19:43:53 <M30W> ivanm: No, it's not literal files.
19:44:06 <M30W> Download daemon > program.
19:44:19 <M30W> (size, origsrc, destfile)
19:44:20 <ivanm> where are you getting these files from?
19:44:33 <M30W> ivanm: Any socket that runs the "add" command
19:44:41 <M30W> To append to the list and start the download.
19:44:51 <M30W> socket/connection *
19:45:00 <ivanm> M30W: may I suggest you try doing something less IO-intensive to start with if you're just beginning learning Haskell?
19:45:01 <Clint> so you're trying to process a queue
19:45:40 <M30W> Clint: Indeed, except an async queue, so it doesn't wait for one to finish to continue.
19:45:55 <ivanm> check hackage for async queue implementations? *shrug*
19:45:57 <M30W> x files at once.
19:46:08 <ivanm> @google haskell async queue
19:46:10 <lambdabot> http://hackage.haskell.org/package/async
19:46:10 <lambdabot> Title: HackageDB: async-2.0.1.4
19:46:38 <hpaste> jbracker pasted “DB” at http://hpaste.org/79503
19:47:16 <jbracker> Why does that give me the error: Could not deduce (db ~ Connection) from the context (IConnection db)
19:47:29 <M30W> Interesting
19:47:32 <jbracker> I know that Connection is a instance of IConnection
19:47:39 <jbracker> I don't see the problem
19:47:40 <M30W> Oh gonna need another one of those variables. state.
19:48:03 <ivanm> jbracker: my guess is that you're trying to use some generic IConnection instance, but your code actually uses the Connection type rather than being generic
19:48:28 <M30W> @hoogle async
19:48:29 <lambdabot> Control.OldException AsyncException :: AsyncException -> Exception
19:48:29 <lambdabot> Control.Exception.Base data AsyncException
19:48:29 <lambdabot> Control.Exception data AsyncException
19:48:52 <jbracker> ivanm: The error occures when I just try to compile that. I don't even use the function yet
19:49:09 <glguy_> Connectsqlite3 probably isn't of the generic type
19:49:15 <ivanm> I meant within your code for that function
19:49:25 <ivanm> try commenting out your type sig, loading it into ghci and doing :t connect
19:50:15 <ivanm> I would wildly guess that you can't make that function generic, as each DB would have its own connectFoo function
19:50:23 <M30W> Aww crap.. :(
19:50:34 * M30W lost in source code for async
19:51:07 <ivanm> do you mean source code or documentation?
19:51:17 <ivanm> there should be no real reason for you to read the actual code
19:51:47 <jbracker> ivanm: I know that it delivers somethink more specific a Connection. But connection is a instance of IConnection. I don't understand why I can't make the type more general. I mean I am loosing information at that point that should not be a problem
19:52:10 <ivanm> every DB would have its own way of connecting
19:52:26 <ivanm> my guess is that the IConnection class covers all the different DBs
19:52:32 <M30W> ivanm: source. Where is the documetation then?
19:52:44 <ivanm> M30W: on hackage...
19:52:48 <ivanm> where it linked to
19:52:57 <ivanm> you would only view the source if you clicked on "view source"
19:53:11 <M30W> Oh I clicked the wrong link
19:53:19 <M30W> Acturally, I went to the source :3
19:53:25 <M30W> As in on github
19:53:38 <M30W>     do a1 <- async (getURL url1)
19:53:38 <ivanm> jbracker: I think that's what the various withConnection functions are for
19:53:44 <M30W> Yay! URL context too :P
19:55:24 <M30W> :set prompt "> "
19:55:33 <M30W> Yay guess :D
19:56:03 <jbracker> ivanm: I know that every DB has a specific connect function. But I don't see the issue for the type system to make something more general. I am doing something perfectly safe there.
19:56:47 <Moggle> Question: ansi escape codes or whatever don't work by default on Windows. Python has a nice library that fixes that (import colorify and colorify.init() as I recall was all it took), does Haskell?
19:57:10 <M30W> Damn.. How to make the prompt2... "| "
19:57:16 <jbracker> ivanm: Another example: f :: Functor f => f String; f = Just "bla"
19:57:17 <shachaf> Probably not.
19:57:35 <AfC> Moggle: yes
19:57:36 <jbracker> ivanm: that basically gives me the same error
19:57:36 <shachaf> jbracker: That type isn't right.
19:57:47 <Moggle> Afc: :O
19:57:48 <AfC> Moggle: at least, something along those lines is being used by e.g. hspec
19:57:56 <ivanm> jbracker: well, yes, because anyone trying to use that value would expect it to be any generic possible functor
19:57:58 <ivanm> when it isn't
19:58:01 <Moggle> But is it easy to use?
19:58:03 <ivanm> it's a Maybe
19:58:05 <AfC> Moggle: and I've also seen colour used by trifecta
19:58:08 <ivanm> that just happens to be an instance of Functor
19:58:16 <AfC> Moggle: if you check the dependencies for those two you'll probably get an idea
19:58:20 <Moggle> AfC: are you on linux, though?
19:58:39 <ivanm> Moggle: there's a few ansi-related packages on hackage; the names escape me however
19:58:51 <Moggle> @where hackage
19:58:52 <lambdabot> <http://hackage.haskell.org/package/>, also see `revdeps'
19:59:00 <AfC> Moggle: of course. GNOME 3.6, Fedora and Ubuntu doesn't matter
19:59:06 <Moggle> http://hackage.haskell.org/package/ansi-terminal-0.5.5.1
19:59:08 <Moggle> sweetness
19:59:13 <Moggle> I should have done this before asking :P
19:59:15 <Moggle> sorry
19:59:36 <ivanm> wl-pprint-ansi is what I was actually thinking of though; pretty-printing combinators for ANSI output!
20:00:01 <M30W> Is it possible to set the second prompt inside of ghci?
20:00:12 <M30W> I.e :{
20:00:16 <M30W> (multiline code)
20:00:48 <jbracker> ivanm: I see that the implicit forall in there seems to be the problem.
20:01:05 <ivanm> yup
20:01:21 <ivanm> oh, as in what it looks like?
20:01:27 <ivanm> M30W: ^^
20:01:29 <ivanm> don't think so
20:01:40 <M30W> ivanm: Nawww
20:01:50 <ivanm> why would you want to?
20:01:57 <M30W> :set prompt "ghci> "
20:02:00 <ivanm> I don't even know of many people that use multi-line inputs into ghci
20:02:00 <M30W> :{
20:02:01 <jbracker> ivanm: But still I would be interested in seeing an example where doing something like this leads to a problem. I can't imagine it ever would, because what we are returning is a Functor and will always support the fmap operation.
20:02:10 <M30W> with more modules EVERYTHING SHIFTED A LINE
20:02:11 <M30W> :P
20:02:23 <ivanm> jbracker: yes, but if you consider solely the type sig, you wouldn't be able to do any Maybe-based operations
20:02:30 <ivanm> all you know about it is that it's a Functor
20:02:57 <jbracker> yeah and thats fine why not be able to return it like that?
20:03:07 <ivanm> and it doesn't match what the type-checker comes up with: you're allowed to write _stricter_ type sigs, but not more generic
20:03:29 <shachaf> jbracker: If «foo :: Functor f => f Int», that means that «foo :: Maybe Int» and also «foo :: IO Int»
20:03:34 <shachaf> And also every other thing I want.
20:03:39 <shachaf> I can decide what f is.
20:03:45 <shachaf> It's up to me, not you.
20:03:56 <elliott> (so your definition has to work for every Functor)
20:04:36 <Moggle> Cabal updates sure are verbose.
20:04:54 <M30W> ivanm: Would that be suitable for making a bug report? Cause it's really annoying and should be an option.
20:05:00 <M30W> Prompt & prompt2 *
20:05:07 <ivanm> why should it?
20:05:08 <M30W> well. second prompt *
20:05:31 <M30W> ivanm: :set prompt "something" works, why not be allowed to set the second prompt?
20:05:53 <ivanm> people usually set the first prompt because otherwise it gets too long
20:06:00 <ivanm> the second prompt doesn't have that issue
20:06:01 <M30W> Exactly
20:06:09 <M30W> Same issue with the second prompt as it *does* have that issue
20:06:15 <ivanm> if you wrote a patch they'd probably accept it, but I doubt anyone would go out of their way to implement it for you
20:06:18 <ivanm> it does? *shrug*
20:06:26 <M30W> ghci> :{
20:06:27 <M30W> Prelude|
20:06:29 <M30W> Yupp
20:06:35 <jbracker> I can see the problem looking at it from the type systems view as it is designed but not from the users view. What if I as a user don't car what functor I get? I might want to change the actual returned instance later on. Why shouldn't that be supported by the  type system? Maybe my question is a little bit hypothetical...
20:06:38 <ivanm> oh, I didn't realise it spat out the modules again
20:06:53 <Moggle> What's the easiest way to sleep your code in Haskell?
20:06:53 <ivanm> jbracker: as shachaf said, the caller gets to choose the instance
20:07:02 <shachaf> jbracker: If you don't care what kind of Functor it is, just give it the type «Maybe Int»
20:07:06 <shachaf> The use can use that type just fine.
20:07:07 <Moggle> Is there like a basic Thread library or something
20:07:08 <ivanm> Moggle: as in make it wait?  there's a delay function somewhere IIRC
20:07:12 <Moggle> ivanm: yes
20:07:13 <ivanm> @hoogle delay
20:07:13 <lambdabot> Control.Concurrent threadDelay :: Int -> IO ()
20:07:13 <lambdabot> GHC.Conc.IO threadDelay :: Int -> IO ()
20:07:14 <lambdabot> GHC.Conc threadDelay :: Int -> IO ()
20:07:23 <M30W> ivanm: To me that's a bug?
20:07:25 <glguy> jbracker: You can express both
20:07:31 <ivanm> M30W: yes, now I get you and agree
20:07:32 <shachaf> jbracker: If Haskell had existential types, you'd be able to say «exists f. Functor f *> f Int».
20:07:34 <jbracker> oh now I got, as the type system allows you to get mir specific this would allow wierd type casts
20:07:36 <ivanm> I thought the second prompt was just ">"
20:07:39 <ivanm> as I'd never used it
20:07:45 <M30W> Ha.
20:07:47 <shachaf> jbracker: But it doesn't, and even if it did that wouldn't be very useful.
20:07:53 <M30W> Maybe it was, but it's modules | now
20:08:19 <M30W> ivanm: Should I file a bug?
20:08:19 <jbracker> Yeah I think I got it
20:08:24 <ivanm> M30W: yeah
20:08:28 <M30W> ivanm: Okay.
20:08:34 <jbracker> Thanky
20:09:14 * M30W wonders if he should register as archeyDevil or comit himself to M30W :|
20:09:53 <M30W> Anyone have a good RNG for 50% chance? :P
20:10:06 <elliott> @die 1d2
20:10:06 <lambdabot> 1d2 => 1
20:10:19 <M30W> @die 1d2
20:10:20 <lambdabot> 1d2 => 1
20:10:28 <M30W> that 50% chance?
20:10:38 <ivanm> 1 * 2-sided die IIRC
20:10:41 <ivanm> @help die
20:10:41 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
20:10:43 <ivanm> bah
20:10:44 <M30W> Yupp
20:10:51 * M30W spammed lambdabot in query
20:10:55 <ivanm> @die 1d2
20:10:55 <lambdabot> 1d2 => 2
20:11:38 <M30W> @die 1d2
20:11:38 <lambdabot> 1d2 => 1
20:11:47 <M30W> Okay, 1 was m30w
20:12:00 <M30W> WTF CAPTURE???
20:12:17 <M30W> "Please enter the text below to prove you're not a machine." -- Bug report... Easier for machines.....
20:13:32 <M30W>  Warning: You typed the wrong word. Please try again. [3 attempts so far]
20:14:01 <M30W> Blah.. pass doesn't match :|
20:14:07 <M30W> And no capture!!
20:15:11 <M30W> Heh.. Warning, don't use browser addons to generate a password for this bug tracker, auth via httpauth XD
20:24:07 <hpaste> johnw pasted “s3test.hs” at http://hpaste.org/79504
20:24:22 <johnw> any http-conduit experts around that could help me with an issue?
20:24:34 <shachaf> Aren't they all in #yesod?
20:24:37 <johnw> i'm getting "Bad file descriptor" from the "await" call in that code
20:24:39 <johnw> oh, maybe
20:24:43 <ivanm> what does it mean by "Couldn't match kind `*' against `k' …" ? what's the kind of k ?
20:24:46 <shachaf> johnw: I would strace it.
20:24:49 <shachaf> strace is always good.
20:24:54 <johnw> that's a great idea
20:24:55 <shachaf> ivanm: k is a kind.
20:25:20 <johnw> though it's dtruss here
20:25:22 <ivanm> any particular kind of kind?
20:25:24 <ivanm> :p
20:25:35 <ivanm> specifically, I'm trying to write generic Vector operations
20:25:37 <shachaf> How would I know, from that error message?
20:25:50 <ivanm> I wasn't sure whether it stood for something
20:25:56 <shachaf> "k" stands for "kind"
20:26:39 <shachaf> You might turn off PolyKinds if they're on and you don't need them.
20:26:49 <ivanm> yeah, I was afraid of that...
20:27:13 <ivanm> I was using PolyKinds so that my `m' type parameter was identified as having kind * -> * rather than *
20:27:31 <shachaf> ivanm: You can give it a signature.
20:27:34 <shachaf> (m :: * -> *)
20:27:38 <shachaf> You might need -XKindSignatures
20:27:56 <ivanm> yes, but that makes the one-off data definition look fuglier! :p
20:28:08 <shachaf> johnw: return $ case readResponse res of Nothing -> False; Just _  -> True
20:28:15 <shachaf> Didn't we just talk about that the other day? :-)
20:28:35 <ivanm> PolyKinds? yeah
20:28:57 <ivanm> looks like ghci has enough hints now to figure it out though...
20:29:04 <ivanm> I'm getting other errors instead :s
20:30:45 <johnw> shachaf: this is older code that I didn't update
20:30:53 <shachaf> OK. :-)
20:31:58 <johnw> that whole function should just be: isJust . readResponse <$> aws config svcConfig manager (headObject bucket filepath)
20:32:07 <shachaf> Yep.
20:32:50 <johnw> but that still doesn't help me with this ResumableSource dying :)
20:33:41 <ivanm> for some reason Data.Vector.Generic.freeze is making ghci think I'm changing the types of my vectors :s
20:38:23 <fuchsto> Is there anyone using gtk2hs and gtk3?
20:38:33 <johnw> i wonder if this is a Mac issue...
20:39:02 <scooty-puff> > let a `div'` b = (a + b - 1) `div` b
20:39:03 <lambdabot>   not an expression: `let a `div'` b = (a + b - 1) `div` b'
20:39:09 <scooty-puff> (-4) `div'` (-5)
20:39:15 <AfC> fuchsto: gtk2hs uses gtk2, so shouldn't be any issue (other than the fact that GTK2 has been effectively untouched for ~5 years now, and the Haskell bindings hackers really need to get on with porting to GTK3)
20:39:20 <fuchsto> Looks like my glade files (using gtk3) are incompatible with the current release of gtk2hs and / or the haskell glade package :/
20:39:27 <scooty-puff> > a `div'` b = (a + b - 1) `div` b
20:39:29 <lambdabot>   <hint>:1:12: parse error on input `='
20:39:41 <flebron> scooty-puff, you can't assign things to an expression
20:40:08 <flebron> You can define what div a b means, but I don't know if that's actually the definition you want.
20:40:17 <scooty-puff> i want div' a b
20:40:23 <lispy> > let a `div'` b = (a + b - 1) `div` b in div' 2 3
20:40:25 <lambdabot>   1
20:40:42 <scooty-puff> > let a `div'` b = (a + b - 1) `div` b in div' (-4) (-5)
20:40:44 <lambdabot>   2
20:40:47 <scooty-puff> thats interesting..
20:41:03 <lispy> > let a `div'` b = (a + b - 1) `div` b in 2 `div'` 3
20:41:03 <fuchsto> AfC: That's a bummer, gtk3 is actually really nice
20:41:05 <lambdabot>   1
20:41:26 <hamishmack> fuchsto: There are gtk3 gtk2hs patches here https://patch-tag.com/r/hamish/gtk2hs
20:41:32 <lispy> Writing a binding to gtk is a huge pain with little gain. Outside of linux it's very hard for anyone to use it.
20:41:38 <AfC> fuchsto: indeed
20:41:43 <fuchsto> hamishmack: Great! Are they ... stablish?
20:41:57 <johnw> lispy: i use a few Haskell gtk apps
20:41:59 <johnw> on OS X
20:42:04 <hamishmack> fuchsto: Stablish, but a bit incomplete
20:42:22 <fuchsto> lispy: Why is that? I'm running haskell + gtk on windows and OS X boxes, too
20:42:25 <hamishmack> There are some new Gtk3 ways of doing things that are not supported yet
20:42:51 <hrumph> how long should it take me with only moderately superaverage intelligence to learn haskell?
20:43:05 <hrumph> i haven't got really stuck on anything but its a slog
20:43:07 <johnw> for every IQ point, subtract one week
20:43:07 <lispy> fuchsto: impressive. I've never gotten haskell gtk to work on windows and I've had it work once on osx despite trying several times. I just don't bother at this point. gtk is a dep? I'll use a different package.
20:43:33 <fuchsto> lispy: So, what else would you recommend? I'm not married to gtk.
20:43:52 <lispy> fuchsto: Sadly, I can't recommend anything else.
20:44:09 <fuchsto> lispy: Yes, installing the lib deps is a ... let's say it's not comfy.
20:44:26 <AfC> fuchsto: I would actually recommend writing front end in [something with an up-to-date GTK binding] and the back end in Haskell.
20:44:51 <zomg> hrumph: depends on what level you want to achieve I guess, super guru will take forever obviously =)
20:44:54 <hamishmack> fuchsto: Here is leksah building with Gtk3… https://travis-ci.org/leksah/leksah
20:44:58 <lispy> Another thing I don't like about gtk is license. So, 3 things really: 1) too hard to install, 2) license (I want bsd3 or mit), 3) gtk has a gross look and feel
20:45:17 <fuchsto> lispy: true, true and true
20:45:33 <lispy> is wxhaskell bsd3?
20:45:58 <fuchsto> AfC: What exactly do you mean by frontend / backend? Implementing two processes_
20:45:58 <lispy> "OtherLicense"
20:46:01 <fuchsto> ?
20:46:02 <ivanm> lispy: LGPL + linking exception IIRC
20:46:11 <AfC> fuchsto: yes
20:46:41 <fuchsto> AfC: Communicating how? Custom protocol via sockets?
20:46:43 <lispy> fuchsto: I think what I want is for someone to write a wx-like thing in haskell (skipping the C/C++/Objective-C as much as possible)
20:46:49 <johnw> lispy: no arguments from me
20:46:53 <lispy> fuchsto: and slapping a bsd3 license on it
20:46:59 <AfC> {shrug} if you were writing a web app then the front end would be HTML/CSS/Javascript and the backend Haskell; no reason (other than it not being common) to do otherwise on a desktop app
20:47:00 <johnw> is there a sexy Haskell/Cocoa binding?
20:47:29 <ivanm> johnw: there was the start of one IIRC, but I don't know how "sexy" it was
20:47:34 <lispy> johnw: Well, C can use Objective-C right? So couldn't get a lot done with the existing FFI? (I'm ignorant here)
20:47:51 <AfC> fuchsto: so depending on what you're doing, you could write the front end in e.g. pygtk (sic, since it's all gobject-introspection based now) rather stupidly fast and keep the business (sic) logic in Haskell.
20:48:28 <fuchsto> AfC: And use a custom protocol via sockets?
20:48:34 <fuchsto> AfC: I like the idea
20:48:55 <AfC> fuchsto: (I happen to be the lead author and maintainer of the Java bindings to GTK and GNOME, so I have a fairly good familiarity with the space. Oh, and yeah, we ported to GTK 3 no problem, so really not much excuse that gtk2hs hasn't)
20:49:00 <fuchsto> AfC: Especially since the app should be controllable via MIDI
20:49:07 <AfC> fuchsto: yeah
20:49:13 <lispy> fuchsto: some hurdles to what I'm describing: a) only a small part of the win32 api has bindings, b) cocoa? Maybe you have to use the older C binding apple made that I think is not well supported, c) what do you do on linux? just use gtk still?
20:49:32 <johnw> shachaf: nope, same behavior on Linux.  Hmmm......
20:49:33 <fuchsto> I think i really want a backend / frontend architecture
20:49:50 <johnw> guess i'll have to wait and talk to snoyberg
20:49:50 <fuchsto> i only had to port the frontend for every platform there is.
20:49:58 <AfC> fuchsto: a socket would be one way. You could be even more loosly coupled and make your back end a [locally served] RESTful API. Opens up all kinds of possibliities, though that is serious overengineering if you're just shuffling values around.
20:50:00 <lispy> you could send UI events/responses over sockets
20:50:03 <fuchsto> (if i ever wanted to)
20:50:10 <lispy> MVC with message passing over sockets
20:50:14 <johnw> lispy: C can use objective-C, but my would that be incovenient
20:50:37 <fuchsto> AfC: Well, in my project, Haskell would render an OpenGL framebuffer
20:50:46 <AfC> [yes, and yes, the native-front-end-for-each-platform thing is far more important than trying to use one toolkit for all. Doesn't fly\]
20:50:54 <fuchsto> GUI settings -> Haskell backend -> OpenGL view
20:50:55 <AfC> fuchsto: oh, too easy then.
20:51:01 <AfC> yeah
20:51:02 <AfC> nice
20:51:05 <lispy> fuchsto: if you just need minimal support from the GUI like a opengl context, checkout GLFW-b
20:51:20 <AfC> and GUI could wrap the OpenGL context with window management and/or controls as necessary.
20:51:26 <fuchsto> lispy: Currently i'm using HOpenGL and GtkGlExt
20:51:27 <AfC> or completely separate window. Either ay.
20:52:14 <AfC> [I am using "easy" in the hand-wavey this-is-doable-given-6-months-of-serious-work kind of way. Apologies to everyone I'm missing off (myself included) for describing *anything * in IT as "easy"]
20:52:30 <fuchsto> I need a separate window. But its whole drawing pane consists of a single OpenGL viewport, so i could render to a frame buffer and display it from there.
20:52:45 <AfC> fuchsto: indeed.
20:53:11 <lispy> johnw: do you know what is inconvenient about using Obj-C from C?
20:53:20 <lispy> johnw: again, I'm ignorant here
20:53:39 <fuchsto> AfC: Yes, yes, this does sound nice. The GUI settings are just needed to, say, influence the data processing and rendering that happens in Haskell
20:54:35 <fuchsto> So, the GUI (or MIDI, ha!) frontend sends setting updates to the Haskell backend, which in turn provides a frame buffer in memory and reports whenever a frame has been rendered.
20:54:58 <AfC> fuchsto: even in the end if you decided to do the front end in gtk2hs, dividing the architecture across a hard boundary like this will force you to keep things loosely coupled and perhaps encourage you to make smaller more isolated pieces. Good juju
20:55:03 <fuchsto> Plus, i won't have to struggle with GTK in Haskell any longer.
20:55:13 <AfC> [this was, more or less, the thesis of the talk I gave in a conference keynote a few weeks ago]
20:55:23 <fuchsto> Good point.
20:55:37 <AfC> s/force/force you to think about/
20:55:53 * AfC heads back to hacking
20:55:58 <AfC> fuchsto: best of luck on that.
20:56:07 <fuchsto> It's loosely coupled already. Currently i'm using several threads. GUI and data processing communicate via a global application context record.
20:56:18 <fuchsto> AfC: Thank you!
20:56:19 <lispy> fuchsto: and it just occurred to me. the aeson package is supposed to have nice deriving functionality. So you could implement your message protocol in haskell types and use aeson to serialize/deserialize them
20:56:31 <AfC> lispy: yup
20:56:36 <lispy> I don't know what you use on the non-haskell end, but something must exist
20:56:37 <AfC> or protocol buffers, or...
20:57:16 <fuchsto> lispy: Ouh, i'd just use read and show on records ... but j/a/eson should be more compatible
20:57:25 <AfC> lispy: (this is probably the one reason that going whole hog RESTful makes sense; it adds Content-Type to the "protocol" which means you can use the same channel for different types of information)
20:57:37 <AfC> lispy: but yeah, other than that, just throw JSON fragments across it
20:58:28 <AfC> fuchsto: lispy is talking about the other side; one will be foreign and one will be Haskell. This is where JSON has, admittedly, been able to shine. You don't need a whole crazy protocol. You just throw fragments around, and tell both sides to deal with it.
20:58:45 <fuchsto> Yup!
20:59:06 <fuchsto> I'd prefer Qt + C++ for the frontend, to be honest
20:59:57 <fuchsto> (It's not cool, but its performance is nice and it's easily ported to windows)
21:00:34 <fuchsto> Ah the heck, i'll use python and wxwidgets and wait for performance issues to happen, if at all.
21:01:00 <JoeyA> Is let (a, b) = ... identical to let ~(a, b) = ... ?
21:01:10 <fuchsto> Thank you all very much for now
21:01:48 <ivanm> JoeyA: the second is a lazier pattern match
21:01:54 <lispy> JoeyA: IIRC, they are different
21:01:54 <ivanm> @src partition
21:01:54 <lambdabot> partition p xs = foldr (select p) ([],[]) xs
21:01:55 <lambdabot>     where select p x ~(ts,fs) | p x       = (x:ts,fs)
21:01:55 <lambdabot>                               | otherwise = (ts, x:fs)
21:02:03 <JoeyA> In a let binding
21:02:07 <JoeyA> Not in a pattern
21:02:07 <ivanm> JoeyA: ^^ if you didn't have the ~ in there, the performance would be much worse
21:02:08 <lispy> > let (a, b) = undefined in a
21:02:09 <lambdabot>   *Exception: Prelude.undefined
21:02:44 <lispy> JoeyA: I want to say the difference is whether you get as far as (,) or not
21:02:45 <JoeyA> err, not in an equation pattern
21:02:51 <ivanm> JoeyA: well in the definition of partition you could move the ~(ts,fs) pattern match into a let binding...
21:03:22 <JoeyA> I'm already talking about a let binding
21:03:54 <JoeyA> If I have "let (a, b) = ...", is that identical to "let ~(a, b) = ..." ?
21:04:03 <JoeyA> I'd think it should be, since let bindings are irrefutable.
21:04:05 <ivanm> I meant that as partition is currently defined, you could shift the pattern-matching of the tuple into a let binding inside the guards, and so you'd expect the behaviour to still be different depending if you used ~ or not
21:04:18 <JoeyA> > let (a, b) = undefined in 1234
21:04:20 <lambdabot>   1234
21:04:47 <ivanm> namely, select p x rs | p x = let ~(ts,fs) = rs in (x:ts, fs); | otherwise = let ~(ts,fs) = rs in (x:ts, fs)
21:05:22 <rwbarton> JoeyA: they are the same yeah
21:05:25 <JoeyA> So in this case, would removing the ~s have any effect?
21:05:31 <JoeyA> Okay, good.  I just want to use it for emphasis.
21:05:38 <ivanm> rwbarton: oh? I would have thought it would still have had an effect
21:05:48 <rwbarton> > let ~(~(a,b)) = undefined in 1234 -- extra emphasis
21:05:49 <lambdabot>   1234
21:05:56 <JoeyA> To indicate that I don't want the tuple forced during a transaction, to avoid duplicated work.
21:06:28 <JoeyA> > let ~(!a, b) = undefined in "zzz"
21:06:30 <lambdabot>   "zzz"
21:06:37 <JoeyA> > let (!a, b) = undefined in "zzz"
21:06:39 <rwbarton> uff
21:06:39 <lambdabot>   "zzz"
21:06:42 <elliott> rwbarton: huh?
21:06:44 <elliott> they're not the same
21:06:49 <rwbarton> yes, they are
21:06:49 <elliott> oh
21:06:52 <elliott> they are for let
21:06:54 <ivanm> when using explicit do { ... ; ... } notation for monads (at the ghci prompt), why doesn't "do { ... ; let foo = bar ; ... }" work ?
21:06:55 <rwbarton> right
21:06:56 * elliott sighs
21:07:01 <elliott> nothing can be simple
21:07:08 <elliott> JoeyA: note that they are not the same for functions
21:07:19 <ivanm> I get "parse error on input `;' " :s
21:07:27 <rwbarton> let { foo = bar }
21:07:32 <JoeyA> elliott: right
21:07:53 <ivanm> rwbarton: duh, I forgot that let statements can be multiline; ta!
21:08:23 <JoeyA> > case(,){}of~(_,_)->""
21:08:25 <lambdabot>   ""
21:09:38 <lispy> ivanm: use :{ }
21:09:43 <lispy> :{ do ...
21:09:44 <lispy> ..
21:09:45 <lispy> ..
21:09:46 <lispy> }
21:09:49 <lispy> or is it :}
21:11:05 <JoeyA> > (){}
21:11:07 <lambdabot>   ()
21:11:10 <JoeyA> Why does GHC allow that?
21:11:17 <JoeyA> But not this:
21:11:22 <JoeyA> > (()){}
21:11:24 <lambdabot>   <hint>:1:5: Empty record update of: (())
21:11:28 <elliott> record syntax
21:11:29 <elliott> > Just {}
21:11:30 <shachaf> Because that's not a record update.
21:11:31 <lambdabot>   Just *Exception: <interactive>:3:1-7: Missing field in record construction
21:11:32 <elliott> > (Just) {}
21:11:34 <lambdabot>   <hint>:1:8: Empty record update of: (Just)
21:11:35 <shachaf> It's record creation.
21:11:42 <lispy> > ( ){}
21:11:43 <lambdabot>   ()
21:11:50 <shachaf> > has (element 5) [1,2,3,4,5,6,7]
21:11:52 <lambdabot>   True
21:11:52 <rwbarton> and for some reason empty record updates are disallowed
21:11:53 <shachaf> > has (element 20) [1,2,3,4,5,6,7]
21:11:53 <JoeyA> ah
21:11:55 <lambdabot>   False
21:12:16 <shachaf> rwbarton: I suspect it's because you never want them and they might confuse people.
21:12:32 <rwbarton> yeah
21:12:33 <JoeyA> Hugs doesn't accept (){} (not that I care too much)
21:12:35 <lispy> You can pattern match on empty records for non-record types though.
21:12:37 <ivanm> lispy: I'm using ghci within emacs, so I can't do multiline entries like that
21:12:45 <rwbarton> > let f () {} = 3 in f ()
21:12:46 <lambdabot>   3
21:12:54 <elliott> JoeyA: you use hugs??
21:12:56 <lispy> > case Just 1 of Just {} -> "hi"
21:12:58 <lambdabot>   "hi"
21:13:02 <shachaf> rwbarton: On the other hand it would be nice if Haskell added all the empty cases for consistency.
21:13:23 <shachaf> Nullary classes, empty case matches, empty record updates, empty data types...
21:13:24 <JoeyA> elliott: Last time I used it was a few seconds ago, to try (){}.  Before that, not since maybe 2010.
21:13:47 <ivanm> shachaf: empty modules? :p
21:14:30 <rwbarton> I don't think () {} is actually allowed by the Haskell 98 report
21:14:36 <elliott> empty case matches are supported in core!
21:14:40 <elliott> just not in the source language
21:14:58 <shachaf> elliott: What does Core have to do with any of this?
21:15:08 <elliott> well, it was specifically added because of a feature request for case x of {}
21:15:33 <rwbarton> > [] {}
21:15:34 <lambdabot>   []
21:15:47 <JoeyA> What's the shortest bottom value you can make with a fresh GHCi prompt (without importing extra modules or defining extra stuff) ?
21:15:54 * hackagebot range-space 0.1.0.4 - A Range type with vector-space instances  http://hackage.haskell.org/package/range-space-0.1.0.4 (JohnLato)
21:15:54 <JoeyA> The shortest I've found is:
21:16:01 <elliott> let x=x in x?
21:16:01 <JoeyA> > (,){}
21:16:03 <lambdabot>   (*Exception: <interactive>:3:1-5: Missing field in record construction
21:16:07 <elliott> That's not bottom.
21:16:11 <elliott> That's (_|_, _|_)
21:16:16 <shachaf> head"" -- six characters
21:16:16 <JoeyA> oh, good point
21:16:24 <rwbarton> fix id, also six characters
21:16:29 <shachaf> fix isn't in Prelude
21:16:35 <rwbarton> fail
21:16:41 <rwbarton> oh that needs a string
21:16:48 <shachaf> head[]
21:16:56 <elliott> tail[]
21:16:59 <JoeyA> What's wrong with a string?
21:17:06 <rwbarton> nothing but it bumps it back up to 6
21:17:18 <rwbarton> also it might not really be bottom depending on the monad
21:17:35 <JoeyA> Oh, if -XOverloadedStrings is on
21:17:47 <shachaf> JoeyA: rwbarton is talking about the function "fail"
21:17:48 <rwbarton> > 0^(-1)
21:17:49 <lambdabot>   *Exception: Negative exponent
21:18:02 <elliott> > 0^-1
21:18:02 <JoeyA> nice
21:18:03 <lambdabot>   Not in scope: `^-'
21:18:03 <lambdabot>  Perhaps you meant one of these:
21:18:03 <lambdabot>    `-' (imported from P...
21:18:05 <elliott> pah
21:18:07 <elliott> > 0^ -1
21:18:07 <JoeyA> :(
21:18:08 <lambdabot>   Precedence parsing error
21:18:08 <lambdabot>      cannot mix `GHC.Real.^' [infixr 8] and prefix...
21:18:11 <elliott> pppah
21:18:17 <pnielsen> is there an easy way to throw an exception to the main thread without first doing (and saving) myThreadId from it?
21:18:32 <elliott> > 0^0-1
21:18:33 <lambdabot>   0
21:18:36 <elliott> ugh!
21:18:38 <elliott> of course
21:18:52 <shachaf> pnielsen: Exceptions aren't really how you're supposed to communicate between threads.
21:19:11 <pnielsen> in this case it's the appropriate thing to do
21:19:13 <rwbarton> > 0%0
21:19:13 <JoeyA> pnielsen: I don't think so.  It is possible to terminate the whole program with an exception if you're willing to sell your soul.
21:19:15 <lambdabot>   Not in scope: `%'
21:19:15 <lambdabot>  Perhaps you meant `R.%' (imported from Data.Ratio)
21:19:18 <rwbarton> but that's not in Prelude
21:19:32 <pnielsen> JoeyA: that's what I want to do, it's a fatal condition with some shutdown cleanup
21:19:41 <pnielsen> error?
21:19:54 <JoeyA> pnielsen: No, that just produces an exception when evaluated.
21:20:06 <elliott> pnielsen: what do you actually want to do?
21:20:10 <JoeyA> When main exits, the whole program exits (even if threads are currently running)
21:20:11 <elliott> what
21:20:14 <pnielsen> clean up in the main thread before dying
21:20:17 <elliott> edwardk changed (%) to (&)
21:20:20 <elliott> and lambdabot still doesn't have (%)??
21:20:29 <pnielsen> (I am going to catch the exception, then die)
21:20:30 <elliott> edwardk: nobody noticed so put it back
21:20:33 <JoeyA> pnielsen: Just have your main thread wait on an MVar, and do all your work in child threads.
21:20:49 <pnielsen> I would rather not do that since main is a loop
21:20:55 <edwardk> elliott: =)
21:21:00 <JoeyA> Why does it have to be?
21:21:03 <pnielsen> I guess I can forkIO the loop, but meh.
21:21:18 <pnielsen> JoeyA: It's accepting connections, forkIOing handlers
21:22:02 <pnielsen> I can wait on an mvar in the main thread and forkio the accept function, thanks
21:24:50 <rwbarton> > []!!1
21:24:51 <lambdabot>   *Exception: Prelude.(!!): index too large
21:24:58 <shachaf> rwbarton++
21:25:08 * rwbarton read through http://www.haskell.org/onlinereport/standard-prelude.html
21:26:31 <Moggle> Question: http://hackage.haskell.org/packages/archive/base/latest/doc/html/Control-Concurrent.html
21:26:37 <Moggle> myThreadId only works on GHC apparently
21:26:41 <Moggle> What would you do on hugs?
21:27:16 <shachaf> You wouldn't.
21:27:24 <shachaf> It's more like "Why would you do on hugs?"
21:27:32 <elliott> Good luck doing anything on Hugs in the year 2012.
21:27:37 <Moggle> Well, I'll just be happy I'm using GHC today
21:27:39 <Moggle> :D
21:28:12 <shachaf> Is there a pure Haskell implementation of Concurrent Haskell anywhere?
21:28:21 <shachaf> A coöperative one, that is.
21:28:36 <shachaf> You'd have to wrap IO, of course.
21:28:56 <elliott> Moggle: Also Hugs doesn't even support concurrency AFAIK.
21:29:06 <shachaf> Hugs has threads.
21:30:00 <elliott> a cooperative Concurrent Haskell implementation sounds easy with a good enough IO model
21:30:03 <elliott> (is IOSpec good enough?)
21:30:28 <shachaf> elliott: Can't you just pass IO primitives through?
21:32:49 <elliott> shachaf: That counts as a model to me.
21:34:10 <slack1256> shachaf: there is some interesting work on that with free monads
21:34:13 <slack1256> shachaf: http://www.haskellforall.com/2012/06/you-could-have-invented-free-monads.html
21:34:25 <slack1256> in the part of concurrency (obviously)
21:35:13 <slack1256> althought maybe isn't what are you looking for, but is clever and simple
21:35:36 <shachaf> slack1256: Sure, it sounds like free monady thing.
21:35:51 <shachaf> For example CoroutineT that mm_freak_ mentioned yesterday is just FreeT
21:38:10 * lispy can't tell what technology people are supposed to use to make windows applications
21:38:16 <lispy> Is win32 dead?
21:38:34 <shachaf> lispy: I think it involves .NET these days?
21:39:12 <hpaste> dwed annotated “Rabin Karp Algorithm” with “Rabin Karp Algorithm (annotation)” at http://hpaste.org/67606#a79505
21:39:25 <lispy> shachaf: maybe? in 2009 when I needed to do some heavy lifting from .NET the winform didn't have a solution and I had to 'drop down' to the win32 stuff.
21:39:35 <slack1256> shachaf: looking at what coroutineT is, it seems to be related... interesting.
21:39:52 <lispy> shachaf: so I kind of wonder if win32 will just get grandfathered in
21:40:17 <shachaf> lispy: Win32 will probably not die for a very long time. :-(
21:40:48 <lispy> in that case, building on win32 is reasonable for anyone who wants to make a haskell gui library for windows?
21:40:54 * hackagebot hCsound 0.4.2 - interface to CSound API  http://hackage.haskell.org/package/hCsound-0.4.2 (JohnLato)
21:41:15 <shachaf> Well, it's not as if Microsoft is going to break compatibility with Win32.
21:41:23 <slack1256> but what will happen with win32 once we welcome our new ARM overlord?
21:41:24 <shachaf> But I suspect there are better things to build on top of in general.
21:41:28 <slack1256> *overlords?
21:42:25 <lispy> slack1256: I don't know. I haven't been able to make sense of that. I guess MS is doing a crumy job of communicating.
21:45:47 <lispy> anyway, I'm not volunteering for such a project, but I keep wishing someone else would...
21:47:39 <JoeyA> A good start might be to make an *extremely* simple toolkit, and get it to work on OSX, Win32, and GTK.
21:47:49 <JoeyA> E.g. you can only create windows and buttons, that simple
21:48:12 <lispy> Do parsers go in Text or Language?
21:48:42 <lispy> JoeyA: yeah, even that much could be cool
21:48:52 <lispy> JoeyA: and html5 would be another nice backend
21:49:34 <lispy> looks like parsec is in Text
21:49:37 <lispy> So, I'll use that
21:49:53 <JoeyA> That's a parser combinator library, not a parser for a specific language.
21:50:12 <JoeyA> (though there is support for tokenizing various languages)
21:50:35 <lispy> I was thinking of a parser library, I should have clarified
21:54:59 <JoeyA> Just wondering, has anyone implemented a Seq data type, to represent a chain of thunks you can force?
21:55:22 <JoeyA> e.g. data Seq = Seq Seq; instance Monoid Seq where mappend a b = a `seq` b `seq` Seq
21:55:55 * hackagebot loris 0.3.1 - interface to Loris API  http://hackage.haskell.org/package/loris-0.3.1 (JohnLato)
21:55:57 <shachaf> JoeyA: data Seq = Seq Seq?
21:56:01 <JoeyA> For example, if something returns STM Seq, you can evaluate the Seq in IO to force any thunks we were reluctant to do in STM land.
21:56:20 <shachaf> Oh, that's data, not newtype.
21:56:38 <shachaf> Doesn't () do the same thing?
21:56:44 <JoeyA> You could do it with (), but that's extremely subtle.
21:57:00 <rwbarton> I think () even has the right Monoid instance
21:57:06 <shachaf> Yep.
21:57:09 <rwbarton> > undefined <> ()
21:57:11 <lambdabot>   ()
21:57:13 <elliott> strategies has data Eval a = Eval () or something I think
21:57:14 <rwbarton> or not?
21:57:15 <shachaf> Oh, nope.
21:57:20 <shachaf> I was thinking of its Eq instance.
21:57:32 <elliott> type Strategy a = a -> Eval a
21:57:33 <elliott> newtype Eval a = Eval (State# RealWorld -> (# State# RealWorld, a #))
21:57:34 <JoeyA> Except for one-liners like !() <- atomicModifyIORef (\_ -> (x, ()))
21:57:35 <elliott> Okay, I guess not.
21:57:46 * elliott thinks () should have the strict Monoid instance
21:58:04 * shachaf thinks () would be more useful with the nonstrict Eq/Ord instances
21:58:09 <shachaf> Then you can do compare `on` void!
21:58:13 <lispy> () has some terrible instances /me glares at Enum
21:58:24 <shachaf> ()'s Enum instance seems OK to me?
21:58:32 <lispy> > pred ()
21:58:34 <lambdabot>   *Exception: Prelude.Enum.().pred: bad argument
21:58:41 <shachaf> What of it?
21:58:47 <lispy> > succ ()
21:58:48 <lambdabot>   *Exception: Prelude.Enum.().succ: bad argument
21:58:53 <lispy> why even have the instance?
21:58:55 <JoeyA> Yay, another short bottom!
21:59:02 * rwbarton was thinking the same thing
21:59:07 <ion> > pred()
21:59:09 <shachaf> I had pred() previously.
21:59:09 <lambdabot>   *Exception: Prelude.Enum.().pred: bad argument
21:59:15 <shachaf> But I didn't see the point of mentioning it.
21:59:26 <shachaf> There are lots of 6-characters ⊥s.
21:59:52 <rwbarton> yeah
21:59:58 <rwbarton> I think I found some other ones, too
22:00:00 <JoeyA> > []!!0  -- 5
22:00:02 <lambdabot>   *Exception: Prelude.(!!): index too large
22:00:14 <lispy> > let ⊥ = ⊥ in ⊥
22:00:14 <lambdabot>   mueval: recoverEncode: invalid argument (invalid character)
22:00:37 <rwbarton> that's a new kind of bottom I guess
22:00:42 <ClaudiusMaximus> > 0%0
22:00:42 <rwbarton> compile-time _|_
22:00:44 <lambdabot>   Not in scope: `%'
22:00:44 <lambdabot>  Perhaps you meant `R.%' (imported from Data.Ratio)
22:00:50 <shachaf> rwbarton: Those are pretty easy...
22:00:56 <elliott> rwbarton: wouldn't that be a _|_ in a cellular automaton
22:00:57 <shachaf> For example: a
22:01:00 <rwbarton> true
22:01:11 <elliott> shachaf: that's not really a _|_
22:01:24 <rwbarton> this one is somehow even pre-compile time
22:01:26 <rwbarton> -ish
22:01:36 <shachaf> elliott: Right. Neither is the other one.
22:01:59 <elliott> well it's na exception thrown in actual haskell code
22:02:03 <elliott> *an
22:02:26 <shachaf> Maybe "not in scope" is a GHC exception.
22:02:27 <shachaf> Who knows.
22:03:15 * rwbarton read that as "GHC extension"
22:03:29 <elliott> fact: in haskell 98 all variables were always in scope
22:04:06 <rwbarton> -fdefer-not-in-scope
22:04:33 <JoeyA> Is that a deferrable type error?
22:05:03 <JoeyA> Of course, _ (type hole) is the shortest, but requires -XTypeHoles
22:05:05 <ion> -fdefer-all
22:05:40 <JoeyA> -fdefer-bugs: defer runtime bugs until release
22:06:23 <rwbarton> -fdefer-compilation
22:07:01 <Saizan> [lazyness joke]
22:07:20 <lispy> -fdefer-laziness-joke
22:07:43 <JoeyA> We first need a way to serialize thunks without forcing them.
22:07:53 <lispy> coed?
22:07:56 <lispy> er, code
22:18:18 <arbn> I can't seem to use the LLVM backend for GHC on Mac OS X. 'ghc: could not execute: opt
22:18:50 <thoughtpolice> can you execute opt? where does it live
22:21:46 <arbn> thoughtpolice: I can't execute opt or locate it. I thought that would come with Mac OS X, though?
22:22:03 <pqmodn> it's part of LLVM, it seems
22:22:19 <arbn> I have "clang" on my path.
22:22:46 <thoughtpolice> arbn: it doesn't. llvm doesn't come with xcode at all; it just so happens clang uses it
22:22:55 <thoughtpolice> so you'll have to install it from homebrew or something
22:23:13 <arbn> thoughtpolice: Oh. OK. Just install LLVM with Homebrew, then?
22:23:43 <thoughtpolice> yeah, that works fine
22:23:57 <thoughtpolice> i normally track the HEAD version of llvm (i have a script that keeps it up to date)
22:24:26 <arbn> thoughtpolice: Thanks.
22:24:32 <jfoutz> any idea why snap markdown handler happens *before* heistLocal bindings? I'd like to vary the markdown file without having to write a new html template for every .md
22:25:56 <jfoutz> i, sort of, expected "<markdown file="${file}"/>" to let me set the file attribute *before* markdown processing
22:27:10 <jfoutz> if i change the tag to "<marktest file="${file}"/>" this binds file, like i'd expect: heistLocal (I.bindString "file" "./posts/first-post.md")
22:28:48 <aristid> @tell ion http-types supports some parts of URIs, but not the whole thing, at least not yet.
22:28:49 <lambdabot> Consider it noted.
22:35:09 <jfoutz> maybe a better question is, does heist repeatedly evaluate templates until no replacements are left? or does it just do one level of processing? I guess i could do a two pass splice.
22:36:04 <c_wraith> heist processes splices recursively
22:38:02 <jfoutz> hmm. so maybe if i replace <stuff> with <markdown file="myfile.md"/> then markdown will pick up the new tag? i'll give that a shot.
22:42:26 <jubos> hi, anyone have trouble install unix package with cabal (I am getting build-id=none is not a valid option to ld) and it just fails out.  This is with ghc 7.4
22:45:49 <ivanm> jubos: you can't
22:46:06 <ivanm> unix is a boot library of ghc, and thus you can't (well, technically _shouldn't_) upgrade it
22:47:15 <jubos> ivanm: hmm, so I am trying to pull in some cabal packages and they depend on unix 2.6.0, so they fail because unix 2.6.0 doesn't build properly.
22:47:37 <ivanm> if they need unix-2.6.0.0, then they probably need ghc 7.6.1
22:47:37 <mmcdermo> There must be something more idiomatic than: Control.Monad.Logger.MonadLogger m
22:47:53 <mmcdermo> wrong paste.  I mean: (\a -> a^.lens1.lens2)
22:48:11 <elliott> view (lens1.lens2)
22:48:17 <elliott> but you should probably just define (lens1.lens2) instead
22:48:24 <elliott> and use (^.) at the use sites
22:48:43 <mmcdermo> elliot: thanks!
22:49:06 <ion> aristid: Yeah, i noticed. :-\
22:49:10 <mmcdermo> elliot: just trying to work with some non-lens code that needs an (a->b)
22:49:33 <elliott> > [1,2,3] & mapped %~ to succ . to succ
22:49:34 <lambdabot>   No instance for (GHC.Num.Num (a0 -> f0 a0))
22:49:34 <lambdabot>    arising from a use of `e_112...
22:49:42 <elliott> > [1,2,3] & mapped %~ (to succ . to succ)
22:49:44 <lambdabot>   No instance for (GHC.Num.Num (a0 -> f0 a0))
22:49:44 <lambdabot>    arising from a use of `e_112...
22:49:45 <jubos> ivanm: hmm, ok I will play around.  I am on Centos and yum has a package for ghc 7.4.
22:49:46 <elliott> oh right
22:50:06 <elliott> mmcdermo: depending on what the code is you might be able to avoid the view but sure
22:50:10 <aristid> ion: as you may notice it also has much better support for rendering than for parsing
22:50:11 <jubos> ivanm: does that mean that cabal won't try to install things not compatible with 7.4 or does cabal just throw me to the dogs
22:50:29 <ivanm> jubos: whatever you're tryingi to build, try a lower version, especially if the latest version differs only in 7.6.1 support
22:50:41 <mmcdermo> elliot: probably - I will look into alternatives.
22:58:39 <jubos> ivanm: i found a package called haskell-hub-binutils-1-4.0.el5.x86_64 which installed a set of tools like ld in /usr/hs/binutils that look like they are the necessary tools to build things with ghc7.4
22:59:25 <ivanm> jubos: *shrug* I've never really looked into the haskell hub "distribution"
23:00:00 <jubos> ivanm: ok, it looks like it might do well in that normalizes the tools despite the overarching distribution
23:00:04 <jfoutz> thanks c_wraith. a dummy tag that turns into a markdown tag can then be explicitly processed with the markdownSplice > heistLocal (I.bindSplices [("stuff", doMkd),("markdown", markdownSplice)]) $ render "index"
23:10:14 <Moggle> Is there like an entire tutorial on string parsing in Haskell sitting around somewhere?
23:10:20 <Moggle> I feel like I'm doing things really really wrong
23:10:34 <Moggle> (or rather, harder than they have to be)
23:11:21 <ion> I think RWH had something about an older version of Parsec, but the basic idea should transfer to the new versions even if the code has bitrotted.
23:14:56 <Moggle> thanks, ion
23:15:01 <Moggle> that probably gives me a good place to look
23:21:34 <bear3> how to get this working? alloca (\(x :: CInt) -> sizeOf x)
23:23:15 <ByronJohnson> bear3: Type signatures within patterns are syntactically invalid.  One solution is to move it inside the expression.
23:23:43 <shachaf> Alternatively, you could enable the GHC extension that makes them valid.
23:23:48 <shachaf> {-# LANGUAGE ScopedTypeVariables #-}
23:24:59 <Hafydd> Wouldn't (sizeOf :: CInt -> a) work?
23:25:07 <Moggle> How does one normally do a split in Haskell?
23:25:15 <Moggle> I realize I asked this a few days ago but I appear to have forgotten
23:25:39 <Moggle> ie split on " " in "hello hi" returns ["hello", "hi"]
23:26:32 <Moggle> aha, Data.List.Split is what I want
23:29:30 <sopvop> I see proposal of (&) to Data.Function was not successful. I use lens everywhere anyway.
23:30:00 <bear3> : is there a saner way to get size of a C type?  alloca (\ptr -> do x <- (peek ptr); return $ sizeOf (x :: CInt))
23:32:41 <ByronJohnson> bear3: The value of the argument for sizeOf is not used.  The idiom for this function is "sizeOf (undefined :: CInt)"
23:32:52 <bear3> oh nice
23:33:19 <Hafydd> > sizeOf (undefined :: CInt)
23:33:20 <lambdabot>   Not in scope: `sizeOf'
23:33:21 <lambdabot>  Perhaps you meant one of these:
23:33:21 <lambdabot>    `IM.size' (impor...
23:33:27 <bear3> it works
23:43:23 <wuttf> You haskell programmers are not the typical web devvy crowd I can tell :D
23:43:33 <wuttf> Mongodb tutorial 2 years old :D
23:45:08 <arbn> wuttf: Webdevvy crowd? :P
23:46:28 <arbn> wuttf: I'm sort of a web developer, and I'm actually going to use MongoDB soon (from Haskell) for logging.
23:47:10 <wuttf> arbn: Good to hear bro, I am kinda freaking out that I can't find literature (examples, experiences etc) about mongo in haskell
23:48:22 <arbn> wuttf: Maybe that's a sign that the documentation for the MongoDB libraries is self-explanatory!
23:48:28 * arbn has a look of naive optimism.
23:48:36 <wuttf> arbn: :D
23:50:22 <simpson> I recommend MangoDB instead.
23:51:01 <wuttf> simpson: Is that a joke?
23:51:06 <simpson> https://github.com/dcramer/mangodb for the uninitiated.
23:51:18 <simpson> wuttf: Only slightly. If you want to do serious things, you should consider Pg.
23:52:07 <arbn> What's an "auto sharting algorithm"?
23:52:08 <aetcore> awesome ~ If you use this, you must donate $1 to someone more intelligent than you.
23:53:05 <arbn> I am very skeptical of the "operate at Cloud Scale" tagline, personally.
23:53:21 * arbn has an allergy to buzzwords.
23:53:21 <wuttf> arbn :D It is a parody on Mongo I htink
23:53:40 <wuttf> "mongodb is web scale"
23:53:47 <wuttf> (as is node.js, dont you know)
23:54:30 <wuttf> I actually used node.js at one point in my life but i realized the callback soup is not tasty.
23:54:39 <arbn> wuttf: NodeJS makes me angry. For logging, a document-oriented database makes sense, and thus my plan to use Mongo. But Node.js... I don't see the point.
23:54:46 <simpson> Callbacks aren't a biggie; broken type systems are a problem, though.
23:55:32 <wuttf> simpson: Hahahahaha. Tell me that after you code 6 months in it. I screamed for sync io. And I DID use flow libs
23:56:37 <simpson> wuttf: Hi, I contribute to Twisted. >:3
23:56:49 <arbn> I kind of wish, that Haskell had a small, lightweight web framework for JSON-only applications. Sometimes, you just need a small service-oriented app. I'd feel weird using Snap or something.
23:56:53 <wuttf> simpson: Fo' real?
23:56:53 <simpson> wuttf: Node is like Twisted, except bad and in a bad language and you should feel bad.
23:57:00 <simpson> wuttf: Yup.
23:57:11 <wuttf> simpson: Not intended to offend you mate.
23:58:01 <simpson> wuttf: Nah, no worries. I'm not really offended by anything.
23:59:12 <wuttf> Cool.
23:59:41 <wuttf> arbn: Gonna build one I think. Expect web shit from me once I grasp this beautyful lang
23:59:53 <wuttf> *i
