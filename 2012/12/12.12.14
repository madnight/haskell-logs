00:00:01 <johnw> ok
00:00:26 <snoyberg> i certainly want to make sure we resolve it, but stackage is still in flux, and it seems at least that the code is actually working despite the test failures
00:01:10 <johnw> i have this thing about my jenkins build icons being green... :)
00:01:31 <snoyberg> i didn't realize you already had a jenkins build set up for it
00:01:53 <johnw> i didn't yet, since they stand no chance of being green!
00:02:11 <johnw> but I have the VM all setup and my "script" ready, so once I can get tests to pass, i'll have that daily build setup
00:02:25 <snoyberg> you could cheat and ignore those specific test suites
00:02:28 <johnw> but until it passes at least once, it was just be too sad
00:02:35 <snoyberg> (not that i'm recommending that)
00:02:37 <johnw> unsafeSnoyberg
00:03:04 <snoyberg> i wonder what the type signature on that would be
00:03:17 <johnw> a -> ()
00:03:25 * hackagebot lens 3.7.1 - Lenses, Folds and Traversals  http://hackage.haskell.org/package/lens-3.7.1 (EdwardKmett)
00:04:23 <snoyberg> unsafeSnoyberg = const () -- doesn't sound too bad
00:06:36 <johnw> i love installing new lens builds
00:06:46 <Nereid> what's new in this one?
00:06:48 <johnw> i feel like the version numbers are inching me towards infinity
00:06:56 * Nereid reads the changelog.
00:08:17 <snoyberg> i'd love to see some simple cookbook kind of examples for handling the simple cases in lens
00:08:21 <snoyberg> e.g., how to replace this ugly code:
00:08:25 <snoyberg> x <- get
00:08:35 <snoyberg> put x { foo = doSomething $ foo x }
00:08:49 <Nereid> foo %= doSomething
00:09:36 <Nereid> :t ?lens %= ?f
00:09:38 <lambdabot> (?lens::Setting s s a b, ?f::a -> b, MonadState s m) => m ()
00:09:38 <snoyberg> really, that's it? <dumbfounded-shock/>
00:09:41 <Nereid> yep
00:09:41 <johnw> snoyberg: i agree
00:09:51 <johnw> yeah, %= is pretty amazing
00:10:09 <johnw> if you had a tuple, then _1 %= doSomething
00:10:18 <snoyberg> is there a named-function equivalent to %=?
00:10:20 <johnw> or even id %= doSomething
00:10:22 <edwardk> > ("hello","world") & _2 %~ length
00:10:24 <lambdabot>   ("hello",5)
00:10:33 <johnw> edwardk: what is the prefix name for %=?
00:10:42 <shachaf> Probably just modify (over foo doSomething)
00:10:55 <AfC> edwardk: patch sent (via github) as requested.
00:11:12 <Nereid> yeah, %= doesn't have another name.
00:11:21 <Nereid> :t modify . over
00:11:23 <lambdabot> MonadState (a -> b) m => Setting a b a b -> m ()
00:11:25 <edwardk> it doesn't have one. none of the state combinators do. you can use modify (over myLens doSomething)
00:11:26 <johnw> snoyberg: the presence of "=" implies an operation on the State value
00:11:30 <Nereid> :t (%=)
00:11:32 <lambdabot> MonadState s m => Setting s s a b -> (a -> b) -> m ()
00:11:38 <Nereid> hmm
00:11:50 <Nereid> oh duh
00:11:51 <shachaf> The State combinators don't have a prefix name because you have to stop somewhere.
00:11:52 <Nereid> :t modify .: over
00:11:53 <lambdabot> MonadState s m => Setting s s a b -> (a -> b) -> m ()
00:12:00 <shachaf> Otherwise you'd get a "combinatorial" explosion.
00:12:38 <edwardk> snoyberg: the general pattern is that operator= works like an imperative programmer would expect applying the operator to the target(s) of any traversal, setter, lens, isomorphism, prism, etc. you hand it
00:12:50 <Nereid> > execState (_1 %= show) (True,5)
00:12:51 <johnw> overS?
00:12:52 <lambdabot>   Couldn't match type `GHC.Types.Bool' with `[GHC.Types.Char]'Couldn't match ...
00:13:02 <edwardk> snoyberg: '%' is usually read mod to an imperative programmer. so %= is mod-equals, more or less a pun
00:13:04 <Nereid> what?
00:13:14 <shachaf> Nereid: State's type doesn't change.
00:13:16 <edwardk> we renamed the operator % to & because it was causing confusion
00:13:17 <Nereid> oh duh
00:13:23 <Nereid> > execState (_1 %= succ) (3,5)
00:13:25 <lambdabot>   (4,5)
00:13:33 <snoyberg> edwardk: got it, i think
00:13:37 <edwardk> but we kept % in the operators since that would cause more confusion
00:13:52 <edwardk> > (2,3) & _1 *~ 10
00:13:53 <lambdabot>   (20,3)
00:14:04 <johnw> what is *~?
00:14:11 <johnw> :t (*~)
00:14:12 <lambdabot> Num a => Setting s t a a -> a -> s -> t
00:14:12 <edwardk> operator~ is the 'functional' version of operator=
00:14:26 <johnw> oh
00:14:29 <johnw> it's just mult
00:14:33 <edwardk> johnw: *= outside of state
00:14:36 <shachaf> Oh, the new lens is out?
00:14:37 <Nereid> > (2,3) & _1 %~ (*10)
00:14:39 <lambdabot>   (20,3)
00:14:41 <shachaf> Nobody tells me anything.
00:14:43 <johnw> i never know when a char in a lens operator means what I'm used to it meaning ;)
00:14:45 <edwardk> shachaf: had to push something for hashable 1.2
00:14:57 <johnw> edwardk: it's not the ~ or = that confused me, but the *
00:15:10 <edwardk> shachaf: i couldn't see a point in holding back the 3.7.1 improvements and backporting a patch to 3.7.0.2 for it
00:15:32 <snoyberg> edwardk: was the hashable 1.2 upgrade painful?
00:16:05 <edwardk> snoyberg: it hit a dozen or so places in code and had some annoying changes in semantics for things in that now i have to worry about whether i should use hash or hashWithSalt 0
00:16:18 <edwardk> it'll break some closed source code i have for distributed computing
00:16:19 <Nereid> l *~ x = over l (*x). so I guess it would be consistent to have l &~ f = over l (&f) = over l f
00:16:20 <Nereid> oh well
00:16:24 <edwardk> which relied on the fact that the hash was consisteny
00:16:27 <edwardk> er consistent
00:16:42 <edwardk> and it'll break some code i was using the hash for a crap checksum with
00:16:47 <edwardk> but otherwise it wasn't too bad
00:17:23 <edwardk> Nereid: &~ would be more consistent, but i'd field a lot more questions
00:17:27 <Nereid> :p
00:17:37 <Nereid> I'm not saying it would be a good idea to change it.
00:17:41 <edwardk> and i'd lose the mod-equals mnemonic
00:17:44 <Nereid> hehe
00:18:16 <snoyberg> i'm tempting to redo the packdeps changes i wrote yesterday to use lens, i need to actually start using it in real code to feel it out
00:18:21 <snoyberg> *tempted
00:18:50 <Nereid> I need to actually write something in haskell.
00:18:51 <edwardk> also visually its easier to break up the operator soup in foo & bar .~ baz & quux .~ quaffle     or foo & bar %~ baz & quux %~ quaffle          than it is to pick it out of foo & bar &~ baz & quux &~ quaffle   -- the latter would read terribly!
00:19:03 <Nereid> true
00:19:35 <edwardk> snoyberg: if you have any lens questions feel free to pop in and ask here or #haskell-lens. there is a rather alarmingly large population of users who can answer questions even if i'm not around.
00:19:46 <Nereid> :p
00:20:04 <snoyberg> edwardk: thanks, i'll keep it in mind
00:20:27 <snoyberg> Nereid: i can always give real programming task recommendations if you want, as i'm sure a few other people would be happy to do as well :)
00:20:39 <Nereid> heh
00:21:12 <johnw> Nereid: do you like Git?
00:21:15 <Nereid> I'll probably be looking for a job soon, too.
00:21:22 <Nereid> git is cool.
00:21:31 <johnw> i could use help fleshing out gitlib
00:21:44 <johnw> i want to achieve 100% coverage of the libgit2 API, which is a lot of work
00:21:52 <johnw> so right now I'm focusing on the areas where I have actual need
00:21:52 <Nereid> mhm
00:21:57 <johnw> I could use help filling out the holes
00:22:12 <johnw> for example, look in https://github.com/jwiegley/gitlib/blob/master/Data/Git/Reference.hs
00:22:14 <edwardk> and if you want to play with lenses we can always use more doctests/examples
00:22:20 <johnw> see all the comments toward the end?
00:22:36 <johnw> they represent C API functions that I haven't exposed via a proper Haskell interface yet
00:22:41 <edwardk> he indexed traversal documentation is currently alarmingly spare compared to the rest of the package
00:22:53 <Nereid> mmm
00:23:02 <shachaf> lens could use some benchmarks.
00:23:03 <johnw> my friend wrote listRefNames for me, but I haven't really tested it yet
00:23:06 <shachaf> Everyone loves writing benchmarks, right?
00:23:09 <edwardk> shachaf: hahahah
00:23:14 <edwardk> let me guess, for zippers?
00:23:25 * hackagebot ConstraintKinds 0.0.1.2 - Repackages standard type classes with the ConstraintKinds extension  http://hackage.haskell.org/package/ConstraintKinds-0.0.1.2 (MikeIzbicki)
00:23:27 <johnw> edwardk: ?
00:23:48 <shachaf> For lots of things.
00:23:56 <edwardk> johnw: shachaf has, as a half-serious running gag been trying to get almost anyone who joins #haskell-lens to get him zipper benchmarks
00:24:06 <johnw> haha
00:24:30 <edwardk> and the moment someone gets a commit bit he then tries to assign the task to them =P
00:25:00 <johnw> i want a commit bit
00:25:04 <johnw> i've just got nothing to commit yet...
00:25:13 <johnw> i just add them up into commit bytes
00:25:33 <edwardk> done.
00:25:36 <johnw> :):)
00:25:41 <johnw> now i'll have to live up to it
00:25:50 <edwardk> https://github.com/ekmett/lens/issues/121
00:26:10 <johnw> ok, i'll put it on my list, let's see if I can get to it before someone else does
00:26:27 <shachaf> Don't worry, no one else wants to touch it.
00:27:01 <shachaf> It's probably a good idea to understand how Control.Lens.Zipper works first, though (or maybe not! Who knows).
00:27:07 <bartavelle> shachaf, why don't you write them ? (too complicated ? tedious ? hard to have meaningful results ?)
00:27:32 <shachaf> Benchmarks are boring and I don't really have good use cases of Zipper in mind.
00:27:54 <bartavelle> the last 2 items then
00:27:55 <shachaf> I can make things up out of thin air but that kind of benchmark isn't really ideal.
00:28:05 <shachaf> Yep.
00:28:12 <shachaf> edwardk: You're almost as bad as Perl 6.
00:29:14 <johnw> ok, Haskell -> C -> Haskell is now working well
00:29:17 <shachaf> (Last I checked joining #perl6 and breathing too loudly was enough to get a commit bit.)
00:29:26 <johnw> so I can start making new libgit2 backends in Haskell instead of C
00:30:40 <edwardk> shachaf: re the pugs commit bit thing?
00:30:58 <edwardk> heh
00:31:05 <edwardk> it worked well for audreyt
00:31:16 <johnw> what did?
00:31:29 <edwardk> handing out commit bits liberally and harnessing the productive chaos
00:32:33 <shachaf> Pugs is a bit dead these days. :-(
00:33:26 * hackagebot siphash 1.0.3 - siphash: a fast short input PRF  http://hackage.haskell.org/package/siphash-1.0.3 (VincentHanquez)
00:33:28 * hackagebot hlibgit2 0.17.0.2 - Low-level bindings to libgit2.  http://hackage.haskell.org/package/hlibgit2-0.17.0.2 (JohnWiegley)
00:34:35 <snoyberg> edwardk: fyi, i think lens might be boring
00:34:51 <snoyberg> edwardk: i was holding my son during this conversation, and he just fell asleep
00:34:58 <snoyberg> edwardk: (so thank you)
00:35:02 <edwardk> snoyberg: =)
00:35:08 <johnw> cats are known to bang keyboards in the presence of lens
00:35:19 <johnw> i think edwardk got a few operator ideas that way
00:35:28 <edwardk> snoyberg: there should be video of my talk on lenses in NYC in a couple of days you can use for future lullaby purposes
00:35:57 <edwardk> johnw: thats how they started
00:36:02 <snoyberg> edwardk: cool
00:36:15 <johnw> oh, yay!
00:37:07 <shachaf> elliott also wants to improve Zipper, actually.
00:37:09 <edwardk> Whenever I need a new operator I just pick up one of my cats and throw them at the keyboard. It's like a Rorschach test with claws.
00:37:22 <shachaf> And I've already made some of my improvements, so maybe I'll wash my hands of the whole thing.
00:37:45 <pnielsen> still a little ways off from the complete works of Shakespeare
00:37:57 <edwardk> i think your reverse hack at least solved the worst issues with zipper
00:38:09 <edwardk> so moving down into a lens is at least less horrible
00:38:21 <edwardk> (well, i suppose, coming back up)
00:38:26 <johnw> http://i.chzbgr.com/completestore/2008/9/3/128649227994625128.jpg
00:38:30 <shachaf> Yes, if you never move right or left it's good.
00:39:09 <shachaf> Also, if you move right N and then move left N.
00:39:24 <shachaf> Right now GHC doesn't figure out rezip statically, though.
00:39:38 <shachaf> (So tug left & rezip might be better than rezip.)
00:39:47 <shachaf> (Anyway I'm tired of making speculations like that.)
00:40:53 <shachaf> (I hear speculations are popular in .nl this time of year.)
00:42:17 <shachaf> Curse you, edwardk!
00:42:23 <edwardk> hah
00:42:52 <edwardk> i wanted to remember the crux of the things you wanted to explore with the benchmarks
00:43:15 <shachaf> What I want to explore is real use cases. :-)
00:43:20 <johnw> that I wanted to explore?
00:43:29 <johnw> i cared most about "upon", I think
00:44:06 <edwardk> johnw can become our benchmarking guru
00:44:13 <shachaf> I think we can give up preëmptively on upon being fast.
00:44:26 <shachaf> Though it would be nice to know exactly how much you pay.
00:44:29 <johnw> i do like Criterion and profiling, and I want to get some experience with inlining and rewriting rules...
00:44:48 <edwardk> > [1..20] & upon last .~ 1000
00:44:50 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,1000]
00:44:58 <edwardk> that always makes me happy
00:45:18 <johnw> adding that to my little collection o' magic
00:45:20 <edwardk> horrified, but happy
00:45:41 <johnw> yeah, i think i just heard a puppy being run over by a car
00:45:56 <otters> where can upon be found
00:46:00 <fmap> > [1..20] & upon (!! 5) .~ 1000
00:46:01 <edwardk> Data.Data.Lens
00:46:02 <shachaf> Data.Data.Lens
00:46:02 <lambdabot>   [1,2,3,4,5,1000,7,8,9,10,11,12,13,14,15,16,17,18,19,20]
00:46:06 <fmap> nice
00:46:25 <edwardk> > (1,2) & upon fst .~ 200
00:46:27 <lambdabot>   (200,2)
00:46:30 <shachaf> > Left 'a' & upon (fromJust . preview _left) .~ 'b'
00:46:32 <lambdabot>   Left 'b'
00:46:33 <shachaf> > Right 'a' & upon (fromJust . preview _left) .~ 'b'
00:46:36 <lambdabot>   Right 'a'
00:46:50 <shachaf> ^?!, I guess
00:46:55 <edwardk> yeah
00:47:18 <edwardk> well, there it didn't have a target to update
00:47:26 <shachaf> Right, that's what I expected.
00:47:27 <shachaf> > [1..20] & upon (head . filter even) .~ 0
00:47:29 <lambdabot>   [0,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]
00:47:32 <edwardk> and it 'spooned' the function more or less
00:47:45 <shachaf> Oh, bah, it has to check it, of course.
00:48:13 <edwardk> you aren't allowed to look at elements of that type in the function other than the one you want
00:48:21 <shachaf> Right.
00:48:29 <shachaf> > sumOf (elements even) [1..10]
00:48:31 <lambdabot>   25
00:48:50 <shachaf> > [1..20] & upon (sumOf (elements even)) .~ 0
00:48:52 <lambdabot>   [0,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]
00:49:00 <shachaf> > [1..20] & upon (sumOf (elements odd)) .~ 0
00:49:02 <lambdabot>   [1,0,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]
00:49:05 <shachaf> You could make that work!
00:49:12 <shachaf> Er, no.
00:49:16 <edwardk> that one no
00:49:24 <shachaf> I was thinking of a different one.
00:49:27 <edwardk> we could make a traversal that was like upon
00:49:28 <shachaf> Well, no, you *could* make that work.
00:49:33 <shachaf> Right.
00:49:44 <edwardk> where you get everything that the traversal returned in a list somehow
00:49:53 <shachaf> Right. Just put the original value back in.
00:49:58 <shachaf> Keep going until you get non-⊥.
00:50:12 <cordawyn> Hello everybody! Could you help me figure out this basic thing: So Haskell has "data A = A ... | B ..." declaration, which actually creates "A" and "B" constructors. GHC does not allow to reuse already defined constructors in that enumeration. Is it somehow possible to add "C" (which is defined elsewhere) to that enumeration, without wrapping it into another type?
00:50:13 <edwardk> and i can know which values were which by spooning each element in the list in turn
00:50:25 <shachaf> Right, like upon already does.
00:50:32 <otters> no cordawyn
00:50:33 <shachaf> cordawyn: Nope.
00:50:34 <edwardk> this has an issue though since if the user returns two copies of the same element in the list, then i have to nub out the extra copies
00:50:45 <shachaf> edwardk: A list?
00:50:46 <edwardk> shachaf wants to write upons
00:50:51 <shachaf> I did sumOf.
00:50:59 <shachaf> I'm thinking of a function that forces N values in the structure.
00:51:12 <shachaf> Not something that returns a list.
00:51:32 <cordawyn> uh. ok :) Thanks
00:51:40 <edwardk> i mean you give me s -> [a]   and i'll give you a Simple Traversal s a
00:51:47 <edwardk> then you can sumOf that
00:51:53 <edwardk> 'upons'
00:52:01 <shachaf> The only thing sumOf was for was forcing more than one value.
00:52:10 <edwardk> well, i wanted
00:52:28 <shachaf> I was thinking of upons (\(x,y,z) -> x `seq` z) being a traversal of _1 and _3
00:52:34 <edwardk> sumOf (upons …)
00:52:35 <mikeplus64> edwardk: does using lens combinators like above incur any/much overhead?
00:52:50 <edwardk> mikeplus64: depends on the combinator. most of them erase completely
00:52:57 <shachaf> "upon" has a fair amount of overhead.
00:53:07 <edwardk> mikeplus64: some zipper stuff can be fairly heavy. upon is slow
00:53:13 <mikeplus64> why?
00:53:15 <mikeplus64> :t upon
00:53:16 <shachaf> The average lens expression should simplify to something involving no lenses at all.
00:53:16 <edwardk> magic, but slow
00:53:17 <lambdabot> (Data.Data.Data a, Data.Data.Data s, Applicative f, Indexable [Int] k) => (s -> a) -> k (a -> f a) (s -> f s)
00:53:47 <edwardk> > [1..10] & upon (tail.tail) .~ []
00:53:49 <lambdabot>   [1,2]
00:53:57 <Nereid> what
00:53:59 <Nereid> oh
00:54:11 <edwardk> upon does evil things to try to figure out what the function you gave it referenced, so you can run it backwards
00:54:11 <Nereid> upon is what we used to call "field"?
00:54:15 <edwardk> yeah
00:54:22 <edwardk> field was too common a name
00:54:28 <Nereid> still disgusting
00:54:37 <edwardk> its buried in Data.Data.Lens
00:55:02 <shachaf> What would be an "honest" way of deriving an _last lens?
00:55:13 <edwardk> > upon last, clearly
00:55:13 <shachaf> Given the code from last, that is. I assume lenq doesn't do it.
00:55:14 <lambdabot>   <hint>:1:10: parse error on input `,'
00:55:30 <edwardk> lenq was working on it
00:56:57 <mikeplus64> edwardk: shachaf: if you weren't using upon what do the above things look like?
00:57:42 <shachaf> Which things?
00:57:46 <shachaf> There's an _last lens.
00:57:53 <shachaf> > _last .~ 1000 $ [1..20]
00:57:54 <lambdabot>   Not in scope: `_last'
00:57:55 <lambdabot>  Perhaps you meant one of these:
00:57:55 <lambdabot>    `last' (imported ...
00:58:04 <mikeplus64> um, [1..20] & upon (sumOf (elements odd)) .~ 0
00:58:06 <edwardk> its in Data.List.Lens lambdabot doesn't have it
00:58:08 <shachaf> Oh, it's not imported.
00:58:15 <shachaf> mikeplus64: That example was deliberately broken. :-)
00:58:17 <edwardk> mikeplus64: upon doesn't make sense for that
00:58:26 * hackagebot uniplate 1.6.10 - Help writing simple, concise and fast generic operations.  http://hackage.haskell.org/package/uniplate-1.6.10 (NeilMitchell)
00:58:29 <edwardk> there is a very limited kind of things that upon can be used for
00:58:30 <covi_> Why can't I do something like this: myButLast (_:_:xs) = myButLast xs  Am I abusing pattern matching?
00:58:40 <mikeplus64> what about xs & upon head .~ 0 ?
00:58:54 <edwardk> > [1,2,3] & upon head .~ 0
00:58:56 <lambdabot>   [0,2,3]
00:58:56 <otters> covi_: who says you can't?
00:59:06 <quchen> covi_: You can do that, but it won't make any sense.
00:59:19 <mikeplus64> (i'm looking at the implementation of upon now, looking at how upon is implemented, scary scary stuff)
00:59:25 <shachaf> > [1,2,3] & element 0 .~ 0
00:59:27 <lambdabot>   [0,2,3]
00:59:29 <edwardk> mikeplus64: the function you give to upon is required to give back a value subject to a number of constraints. basically it can't look at any other fields of that type in the structure, the structure can't be strict in that field, etc.
00:59:40 <shachaf> mikeplus64: There's an _head lens, but it's also not in scope.
00:59:49 <shachaf> What I wrote won't share the list so it's not optimal.
00:59:51 <mikeplus64> how would you define the _head lens?
00:59:53 <nyc> edwardk: Sorry I couldn't make it. I was ... indisposed.
01:00:05 <edwardk> element, _head, and _tail are the expected way to work with those
01:00:12 <edwardk> _head is technically a traversal
01:00:24 <quchen> > let myButLast (_:_:xs) = myButLast xs in myButLast [1..10]
01:00:26 <lambdabot>   *Exception: <interactive>:3:5-37: Non-exhaustive patterns in function myBut...
01:00:46 <edwardk> @let _head f (a:as) = f a <&> (:as); _head _ [] = pure []
01:00:47 <lambdabot>  <local>:5:1:
01:00:47 <lambdabot>      Multiple declarations of `_head'
01:00:47 <lambdabot>      Declared at: <local>...
01:00:47 <shachaf> _head f (a:as) = (:as) <$> f a; _head f [] = pure []
01:00:48 <edwardk> :t _head
01:00:49 <lambdabot> (Applicative f, Indexable Int k) => k (a -> f a) ([a] -> f [a])
01:01:05 <edwardk> @undefine
01:01:07 <edwardk> :t _head
01:01:08 <lambdabot>     Not in scope: `_head'
01:01:08 <lambdabot>     Perhaps you meant one of these:
01:01:08 <lambdabot>       `head' (imported from Data.List),
01:01:36 <shachaf> I wonder whether we should have Cons and Nil prisms.
01:01:40 <mikeplus64> shachaf: what functor instance is that using?
01:01:51 <mikeplus64> and applicative
01:01:53 <covi_> quchen: so what's wrong here
01:01:53 <edwardk> @let _head f aas = case aas of (a:as) -> f a <&> (:as); [] -> pure []
01:01:54 <shachaf> mikeplus64: Multiple ones, depending on how you use the lens.
01:01:55 <lambdabot>  Defined.
01:01:57 <edwardk> :t _head
01:01:58 <lambdabot> Applicative f => (a -> f a) -> [a] -> f [a]
01:02:06 <edwardk> > [1,2,3] & _head .~ 0
01:02:06 <shachaf> mikeplus64: Usually either Identity or Const.
01:02:08 <lambdabot>   [0,2,3]
01:02:12 <covi_> quchen: in my def of the function i also have myButLast (x:_:[]) = x
01:02:19 <shachaf> edwardk: There's no (!!n) traversal, is there?
01:02:25 <edwardk> shachaf: hrmm
01:02:33 <edwardk> :t element
01:02:34 <lambdabot> (Applicative f, Traversable t, Indexable Int k) => Int -> k (a -> f a) (t a -> f (t a))
01:02:35 <shachaf> You can use element
01:02:40 <shachaf> That won't share the list, though.
01:02:40 <edwardk> :t elementOf
01:02:42 <lambdabot> (Applicative f, Indexable Int k) => LensLike (Control.Lens.Internal.Indexing f) s t a a -> Int -> Overloaded k f s t a a
01:02:43 <shachaf> Maybe that's not a big deal.
01:02:59 <edwardk> :t Data.Sequence.Lens.ordinal
01:03:00 <lambdabot> (Functor f, Indexable Int k) => Int -> k (a -> f a) (Seq.Seq a -> f (Seq.Seq a))
01:03:05 <edwardk> that guy gets you sharing
01:03:13 <edwardk> we could add Data.List.Lens.ordinal to match it
01:03:14 <shachaf> More important for Seqs, of course.
01:03:42 <edwardk> we have Data.Vector.Lens.ordinal, which is kinda silly in one sense because the sharing doesn't matter there
01:04:37 <shachaf> Hmm, ordinal is a lens?
01:04:42 <shachaf> Shouldn't it be a traversal?
01:04:48 <edwardk> it is currently, which it shouldn't be
01:05:19 <edwardk> https://github.com/ekmett/lens/issues/201
01:06:24 <shachaf> I like the clarification.
01:06:26 <edwardk> We could factor ordinal into a class and make it a Traversal
01:06:42 <shachaf> Is there a point to putting it in a class?
01:06:51 <shachaf> These mostly belong in namespaces that you import qualified anyway.
01:07:07 <edwardk> well, we have several instances now, that are all identical
01:07:14 <edwardk> it 'smells' more like At, Contains, etc.
01:07:38 <edwardk> and it yields a more convenient api to have a shared combinator
01:07:43 <shachaf> I suppose it's a lot like At.
01:07:47 <shachaf> What about Array?
01:07:49 <edwardk> so i'm kind of leaning towards smashing it in
01:08:13 <edwardk> the ix lens?
01:08:35 <shachaf> Oh, that already does it, I guess.
01:08:55 <edwardk> its a little different
01:09:00 <edwardk> ix lies and claims to be a lens
01:09:05 <edwardk> because it assumes the index is in range
01:09:21 <shachaf> It's probably a bit easier to forgive it given that all the other Array operations work that way.
01:09:26 <edwardk> yeah
01:09:39 <edwardk> but we could make instances for ordinal for known IArray instances
01:09:48 <edwardk> so you could also get the other behavior if you wanted it
01:10:58 <notdan> Hi! I don't think I understand the haskell's evaluation model fully, would it be right to say that the second mplementation is slower in a situatio nwhere the list contains zero? https://www.refheap.com/paste/d421e2a43a893cd4f8999a809
01:11:21 <notdan> Because it evaluates listMultStrict xs?
01:11:35 <shachaf> Probably not -- (*) isn't lazy.
01:12:02 <shachaf> > 0 * sum [1..]
01:12:10 <lambdabot>   mueval: ExitFailure 1
01:12:10 <lambdabot>  mueval: Prelude.undefined
01:12:20 <notdan> Ah, I see.
01:12:43 <notdan> But if we have used 'and' instead of (*)?
01:13:01 <shachaf> If you used (&&), the second function would be less lazy.
01:13:09 <shachaf> You can try that out yourself, in fact. :-)
01:13:26 * hackagebot mixed-strategies 0.1.0.0 - Find optimal mixed strategies for two-player games  http://hackage.haskell.org/package/mixed-strategies-0.1.0.0 (BartonMassey)
01:16:14 <notdan> Yeah this is pretty cool, thanks shachaf
01:20:39 <nomeata> Hi. Is Ben Lippmeier here?
01:23:33 <edwardk> i don't think so
01:32:54 <ion> Is there a package that implements modification of URI query parameters in terms of Network.URI from the network package?
01:33:49 <ion> I mean, as a String-to-String map or equivalent.
01:43:06 <quchen> shachaf: Is there any reason for the non-laziness of (*) for numbers? I see that it would be a bad idea to demand Num to be lazy, but why can't I assert that 0*x == x for Int/Integer/Double/...?
01:43:20 <quchen> Eh, make that 0*x == 0
01:48:02 <covi_> What's the difference between Int and Integer?
01:48:32 <b__> Integer is arbitrary precision
01:48:39 <shachaf> quchen: Efficiency?
01:48:48 <b__> Int is 32bit or 64bit depending on your system
01:49:15 <shachaf> Or 29 bits.
01:49:49 <b__> shachaf I thought I read somewhere that it was at least 30?
01:50:14 <shachaf> I think 29.
01:50:27 <b__> okay
01:51:22 <b__> http://www.haskell.org/tutorial/numbers.html agrees with you
02:04:32 <fmap> [-2^29; 2^29-1] is at least 30 bits, no?
02:05:09 <m3ga> is there a tool that takes some haskell source and dumps it out as template haskell definitions?
02:13:28 * hackagebot vault 0.2.0.3 - a persistent store for values of arbitrary types  http://hackage.haskell.org/package/vault-0.2.0.3 (HeinrichApfelmus)
02:28:35 <Hare> hi
02:29:41 <snowylike> ho
02:32:19 <nomeata> Recently, someone uploaded a library that would optimize a real (i.e. numerical) function from an arbitrary data type by finding all the values of type Double  in the input and varying them, using generics of some kind. Unfortunately, I cannot find it – can you help me?
02:43:28 * hackagebot operational 0.2.2.0 - Implementation of difficult monads made easy  with operational semantics.  http://hackage.haskell.org/package/operational-0.2.2.0 (HeinrichApfelmus)
03:42:41 <Valk> hello. what would be idiomatic Haskell for a function :: String -> [String] that takes a string of the form "arg1 \"complex arg\" arg2 arg3" and returns ["arg1", "complex arg", "arg2", "arg3"]?
03:44:02 <Valk> the ways I have come up with so far seem unhaskellish (passing extra function arguments to keep track, splitting the list on x:xs where x = "\""and concatMapping only one part, etc)
03:44:57 <aristid> Valk: i think explicit recursion for that would be fine.
03:45:11 <Valk> what do you mean?
03:45:12 <aristid> Valk: you could try using something like parsec though.
03:45:30 <aristid> just pattern match on the first character and recurse based on that
03:46:05 <Valk> won't work, because it would then yield ["arg1", "complex", "arg", "arg2", "arg3"]
03:46:12 <Valk> unless I'm misunderstanding what you have in mind
03:46:15 <aristid> indeed
03:46:48 <typoclass> Valk: could you split the entire String on \" first, giving a list, then split on " " only in the list's even-numbered elements?
03:47:06 <aristid> typoclass: heh
03:47:09 <Valk> even-numbered?
03:47:18 <Valk> the "complex arg" part could be anywhere
03:47:48 <Botje> Valk: you can push the extra arguments into an inner function.
03:48:35 <Iceland_jack> Valk: If you're going to implement some more complex escaping then you should think about Parsec
03:49:08 <typoclass> Valk: right. what i mean is, you split on \", which gives ["arg1", "complex arg", "arg2 arg3"]. in this list, the odd-numbered elements (index 1) are a complex arg. the even-numbered ones (index 0, index 2) are the ones you need to split on " "
03:49:25 <Valk> yeah, I've tried to look into that, but it's just one function in the entire code that has to deal with parsing and I'm still a newbie and the tutorials all seem way over my head
03:49:34 <Valk> (for parsec & attoparsec)
03:50:14 <Valk> typoclass: yeah, the string could as well be "\"complex arg\" arg1 arg2" though
03:50:36 <aristid>  span (`notElem` [' ', '"']) "this is a \"complex test\", yes"
03:50:38 <aristid> > span (`notElem` [' ', '"']) "this is a \"complex test\", yes"
03:50:40 <lambdabot>   ("this"," is a \"complex test\", yes")
03:50:52 <aristid> Valk: you could also use something like this to recurse
03:51:14 <typoclass> Valk: yes yes :-) then splitting on '\"' would result in ["", "complex arg", "arg1 arg2"]
03:51:31 <Valk> hmmm
03:52:10 <typoclass> Valk: when i say «even vs. odd numbered», that means «outside of a \"» vs. «between \"»
03:52:21 <aristid> too bad Data.List doesn't contain a proper splitting function
03:52:43 <Valk> mind = blown
03:52:47 <Valk> thanks!
03:53:25 <typoclass> Valk: erm yeah, i was hoping to explain it, not to confuse you further :-)
03:54:18 <typoclass> aristid: uze teh split package. it's part of an ongoing effort to put every function in its own package
03:54:23 <typoclass> =)
03:58:43 <byorgey> the split package is even in the Platform now!  So complaining that Data.List doesn't have a proper splitting function is really just splitting hairs.
03:59:11 <Valk> typoclass: so ""\complex arg1\" \"complex arg2\" arg2 arg3" would yield ["", "complex arg1", "complex arg2", "arg2 arg3"]?
04:00:44 <typoclass> Valk: almost, there would be another "" in there: ["", "complex arg1", "", "complex arg2", "arg2 arg3"]
04:01:28 <Valk> :O
04:01:37 <typoclass> Valk: think of that planned split function as "go through the String from left to right, until we hit a \", which we remove". it removes only one \", not two
04:02:54 <Valk> got it!
04:02:57 <Valk> typoclass++
04:03:02 <Valk> (if the karma command does work)
04:03:13 <typoclass> ;)
04:05:24 <Entroacceptor> is there no CSV package where you can change the separator?
04:05:24 <typoclass> > span (== 'b') "aabbcc" -- Valk, when you write your split function, you might want to use span (from Prelude)
04:05:26 <lambdabot>   ("","aabbcc")
04:05:37 <typoclass> typoclass: well done =)
04:05:48 <typoclass> > span (/= 'b') "aabbcc" -- Valk, when you write your split function, you might want to use span (from Prelude)
04:05:49 <lambdabot>   ("aa","bbcc")
04:07:29 <Entroacceptor> ah, Text.SSV
04:11:27 <latermuse> whats the best way to start a haskell program and have it keep running even after I log out of my sessions (*nix)?
04:11:46 <latermuse> I dont understand how the System.Daemon library connects with a haskell program/script
04:11:52 <typoclass> latermuse: setsid, disown, nohup ...
04:11:58 <`ramses> latermuse: nohup?
04:12:24 <typoclass> latermuse: some reading of manpages required :-) i don't recall which of the three is what you need
04:14:06 <neutrino> latermuse: you set up a daemon. depending on your distribution, it will be different. most likely an rc or upstart script.
04:15:42 <latermuse> typoclass: ive tried all three, and even in combination :D
04:16:17 <latermuse> (setsid ./meow & disown)
04:17:55 <typoclass> latermuse: what i use setsid for is "in this terminal window i start a vlc/a browser/etc. and i want it to stay around after i close the terminal window, hence this shell"
04:19:45 <latermuse> ha! got it ;)
04:19:46 <latermuse> thanks guys
04:20:05 <`ramses> latermuse: how did you do it?
04:20:16 <latermuse> (nohup ./meow & disown)
04:20:35 <latermuse> the braces make the process run in another process
04:20:50 <latermuse> then nohup makes the command immune to hangups
04:21:08 <latermuse> & runs it in background, then disown disowns it
04:21:12 <`ramses> do braces have significance? what shell is that?
04:21:20 <latermuse> bsh
04:21:43 <`ramses> that's not beanshell I assume? :)
04:21:52 <typoclass> `ramses: yeah, at least bash and zsh do stuff like that, possibly also sh. i think "subshell" is the term
04:22:40 * typoclass still thinks shell languages are complicated and confusing
04:22:53 <`ramses> I didn't know about that, so they spawn a new shell if you wrap an expression in braces?
04:22:55 <latermuse> bsh -> bourne shell -> sh
04:23:04 <`ramses> ah, right :)
04:23:05 <latermuse> `ramses: yes
04:23:42 <typoclass> latermuse: is that a new thing? do have a link? googling doesn't turn up very much
04:24:29 <latermuse> typoclass: http://superuser.com/a/172476
04:25:11 <typoclass> latermuse: er sorry :-) i meant, is bsh a new thing? is it a new replacement for bash ...?
04:25:33 <`ramses> typoclass: bourne shell is just plain old sh
04:25:41 <latermuse> bsh and sh are synonymous
04:25:50 <latermuse> i think "bsh" is the command that is used to open sh
04:25:57 <latermuse> and sh is the shortened name of bourne shell
04:26:16 <rwbarton> is this solaris or something
04:26:19 <eikke> typoclass: bash = bourne again shell, so it's newer :)
04:26:50 <`ramses> on linux there does not seem to a bsh command
04:27:12 <typoclass> oh i see. i know sh only under the name sh. which you can run as /bin/sh
04:27:18 <latermuse> `ramses: http://pic.dhe.ibm.com/infocenter/aix/v7r1/index.jsp?topic=%2Fcom.ibm.aix.cmds%2Fdoc%2Faixcmds1%2Fbsh.htm
04:27:26 <rwbarton> even better
04:27:39 <typoclass> i think on most linuxes these days /bin/sh is either "bash running in a special mode" or "dash shell running in a special mode"
04:27:43 <pqmodn> heart aix
04:28:01 <`ramses> I only have experience with linux and solaris :)
04:28:32 <`ramses> and the solaris experience isn't a particularly good one
04:28:40 <latermuse> i use centos and freebsd for most stuff
04:29:00 <latermuse> was trying to setup an ubuntu server today (scoff) and about tore all my hair out
04:29:38 <latermuse> i mean its easy, but the mirrors are so far away from where I live, so the download speeds were atrocious
04:30:13 <`ramses> you live in the arctic or something? :)
04:30:22 <eikke> daemonization (basically things like fork/session management/...) are tricky, especially when trying to be portable across both Linux and Solaris, even more when threads are part of the mix
04:30:24 <latermuse> `ramses: yeah, close
04:30:29 <typoclass> `ramses: oh, you're so close =D
04:31:32 <`ramses> I figured, where do you have to go these days to not have at least one ubuntu mirror in your country
04:31:41 <eikke> I wish people would stop attempting to implement daemonization in their apps, and let init systems or supervisors handle it instead
04:32:26 <latermuse> eikke: im also the admin for this system that im putting the daemon on
04:33:10 <`ramses> latermuse: then why don't you just use the init system like eikke suggests?
04:33:11 <eikke> latermuse: so can't you use the powers of your init implementation (if it has any powers next to launching shell scripts :P), or something like supervisord, daemontools,...
04:33:42 <`ramses> seems a lot cleaner then launching it in your own session
04:33:44 <typoclass> eikke: in principle i agree, but on my system the init system is some bizarre collection of shell scripts that call each other's functions. doesn't look very reliable to me :-)
04:34:06 <`ramses> typoclass: it does keep your machine running, doesn't it? :)
04:34:13 <eikke> typoclass: then use supervisord/daemontools/... most likely one of those is provided by your distribution
04:35:27 * typoclass has googled that stuff and is trying to decide if it makes things more complicated or less
04:35:31 <eikke> typoclass: those immediately take care of stdout/stderr redirection as well, or restart in case of crashes, and whatever more. all the plumbing you don't want to be bothered with yourself
04:36:01 <merijn> typoclass: Switch to FreeBSD and get a nicely well documented rc system! :p
04:36:02 <typoclass> eikke: sounds good so far!
04:37:35 <typoclass> merijn: that is actually a candidate 8-) next time i reinstall everything, it's gonna be fedora or freebsd, or possibly debian
04:38:57 <eikke> fedora brings systemd, which has built-in daemonization capabilities (and lots of other goodies)
04:39:02 <`ramses> is freebsd usable as a desktop system these days?
04:39:12 <`ramses> haven't looked at it for years
04:39:20 <merijn> `ramses: PC-BSD, maybe? I haven't really used it as a desktop in a while
04:39:43 <`ramses> ah, ok, as a server it makes perfect sense indeed
04:40:57 <typoclass> eikke: that's one of poettering's pet projects, isn't it? i'm very suspicious then
04:42:49 <eikke> typoclass: I know Lennart and don't share that feeling (fwiw, especially not on technical grounds)
04:43:29 <`ramses> I must say I was reluctant at first, but systemd has worked fine on my systems for the last couple of months
04:45:55 <typoclass> eikke: i don't know him, but he was the guy behind pulseaudio as well, right? my distro installed that for me about 3x, each time i've spent some hours trying to fix it, then uninstalled it
04:47:09 <eikke> if that's ubuntu you're talking about, you should blame them (seriously. they shipped PA waaaay too early, against Lennart's advise)
04:48:07 <typoclass> eikke: arch linux for me, but those 3-4 attempts were was several months apart iirc
04:48:47 <`ramses> arch has kept pulse optional for a long time, I only switched to it about two months ago
04:49:22 <typoclass> `ramses: not sure what you mean by optional, but it appeared as a dependency of gnome at some point
04:50:19 <`ramses> I think you had to had it installed, but you could configure all your apps to just use alsa
04:50:24 <`ramses> that's what I did
04:51:03 <`ramses> until two months ago because I wanted my laptop to stream sound to my desktop, which pulse made very easy
04:51:29 <typoclass> `ramses: *shrug* i used the approach of uninstalling it, and half of gnome along with it. sounds works great as long as you don't install pulseaudio
04:51:58 <`ramses> I kept it installed, but just made all my apps ignore it
04:52:06 * eikke never had any issues with PA at all
04:52:41 <typoclass> eikke: anyway, i googled and couldn't work out what problems pulseaudio is meant to fix, but i have my doubts about the approach "find problem at lower level, don't fix lower level but invent some new layer of workarounds, place it on top". it think it makes the system as a whole more complicated, and it's not solid engineering
04:52:41 <eikke> typoclass: http://utcc.utoronto.ca/~cks/space/blog/linux/SystemdRight
04:53:10 <`ramses> the one thing I don't like is the lack of a cli interface like alsamixer
04:53:53 <flebron> Stupid question but... why doesn't "Just . Leaf x" work, when I have some type ctor Leaf :: a -> Foo a? It seems (.) Just Leaf types well, it's :: a -> Maybe (Foo a). Why do I need Just $ Leaf x?
04:54:09 <`ramses> flebron: Just . Leaf $ x
04:54:16 <`ramses> application is left associative
04:54:31 <flebron> So that's being parsed as Just . (Leaf x)?
04:54:35 <`ramses> so you wrote (Just Leaf) x
04:54:42 <typoclass> eikke: i don't want to be unkind to this poettering man, i'm sure he's nice and all, but the whole pulseaudio thing looks to me like a solution in search of a problem. unfortunately it's also a solution that has a number of drawbacks.
04:54:53 <flebron> I wrote Just . Leaf x, wouldn't that be (Just . Leaf) x?
04:54:55 <`ramses> flebron: no, as (Just . Leaf) x
04:55:01 <`ramses> no, see above
04:55:12 <`ramses> and Just . (Leaf x) wouldn't type check
04:55:19 <flebron> I don't understand, is Just . Leaf x the same as (Just . Leaf) x?
04:55:55 <`ramses> no, Just . Leaf x parses as Just . (Leaf x)
04:56:04 <`ramses> but you can't compose that, wrong types
04:56:35 <latermuse> wouldnt it be Just $ Leaf x ?
04:56:47 <`ramses> Leaf x is a value and . expects a function
04:56:55 <flebron> Without infix notation, it would be (.) Just Leaf x, correct?
04:57:12 <`ramses> no, (.) Just Leaf $ x
04:57:24 <flebron> What I wrote I mean.
04:57:39 <`ramses> ah no, indeed, that's correct I think
04:57:50 <typoclass> flebron: as far as i can tell, the problem is that (.) has type (b -> c) -> (a -> b) -> a -> c, in other words, it expects a function on its left and a function on its right. "Left x" is presumably a value, not a function
04:58:05 <flebron> Well, if function application is indeed left associative, wouldn't that be parsed as (((.) Just) Leaf) x?
04:58:06 <aristid> :t (.) Just Left
04:58:07 <lambdabot> a -> Maybe (Either a b)
04:58:33 <aristid> flebron: sure.
04:58:46 <`ramses> flebron: either write Just . Leaf $ x to compose the functions and then apply, or Just $ Leaf x to apply them one after the other
04:58:50 <flebron>  (((.) Just) Leaf) typechecks into :: a -> Maybe (Leaf a). So the expression itself should typecheck.
04:58:57 <`ramses> which of those you prefer is a matter of style
04:58:59 <aristid> or (Just . Leaf) x if you don't like ($)
04:59:02 <flebron> Err, Maybe (Foo a) :p
04:59:04 <eikke> typoclass: was on phone.  you mentioned "solid engineering", the problem is certain parts of the linux kernel, especially in the multimedia department, aren't shining examples of 'solid engineering', yet their maintainers arent very fond of changing things
04:59:13 <eikke> anyway, we're going too OT here
04:59:50 <typoclass> eikke: right :-) i'm not an expert on sound or pulseaudio anyway
05:00:04 <flebron> I'm just not getting how, if Just . Leaf x is the same as (.) Just Leaf x, and the latter typechecks, the first doesn't.
05:00:21 <`ramses> flebron: because application is left associative
05:00:27 <monqy> flebron: your problem is just that function application is tighter than infix operators.  so (Just . Leaf x) is (Just . (Leaf x)), which is not ((.) Just Leaf x)
05:00:42 <monqy> I think you're all mistaking flebron's problem......
05:00:46 <flebron> Ah, OK, so it's the mixing between associativity and infix use of (.)?
05:00:50 <pqmodn> flebron: it isn't the same. Just . Leaf x == Just . (Leaf x). neither type check
05:01:45 <pqmodn> or said another way, Just . Leaf x == (.) Just (Leaf x)
05:02:13 <flebron> OK, so the " " is binding tighter than the infix use of (.), but it wouldn't be an issue if I used the prefix form of (.).
05:03:02 <`ramses> in the prefix form, everything in function application, which associates to the left, in the infix form, you need to be aware of the difference in binding between . and application
05:03:11 <arcatan> a new platform?
05:03:30 <`ramses> everything is *
05:04:56 <flebron> So how is "intercalate ", " . concat . fmap maybeToList parts" working? Shouldn't fmap grab maybeToList and parts, yielding a value, and so it wouldn't make sense to concat . somevalue?
05:05:03 <`ramses> flebron: (.) Just Leaf x --> ((((.) Just) Leaf) x)
05:06:24 <`ramses> :t intercalate ", " . concat . famp maybeToList "abc"
05:06:26 <lambdabot>     Not in scope: `famp'
05:06:26 <lambdabot>     Perhaps you meant `fmap' (imported from Control.Monad.Writer)
05:06:30 <`ramses> :t intercalate ", " . concat . fmap maybeToList "abc"
05:06:32 <lambdabot>     Couldn't match expected type `Maybe [[Char]]'
05:06:32 <lambdabot>                 with actual type `Char'
05:06:32 <lambdabot>     Expected type: [Maybe [[Char]]]
05:06:47 <`ramses> :t intercalate ", " . concat . fmap maybeToList (Just ["abc"])
05:06:48 <lambdabot>     Couldn't match expected type `Maybe [[Char]]'
05:06:49 <lambdabot>                 with actual type `[t0]'
05:06:49 <lambdabot>     In the first argument of `Just', namely `["abc"]'
05:06:56 <`ramses> grmblz
05:06:57 <flebron> Just "abc" :)
05:07:02 <`ramses> :t intercalate ", " . concat . fmap maybeToList (Just "abc")
05:07:04 <lambdabot>     Couldn't match expected type `Maybe [[Char]]'
05:07:04 <lambdabot>                 with actual type `[Char]'
05:07:04 <lambdabot>     In the first argument of `Just', namely `"abc"'
05:07:08 <flebron> ... odd.
05:07:22 <`ramses> could you give a working example yourself? :)
05:07:30 <flebron> ohh
05:07:37 <`ramses> I'm not thinking fast enough it seems
05:07:38 <flebron> [Just "abc"], my font misstook those ( as [
05:07:39 <pqmodn> :t intercalate ", " . concat . fmap maybeToList (Just ["hi", "bi"])
05:07:41 <lambdabot>     Couldn't match expected type `Maybe [[Char]]'
05:07:41 <lambdabot>                 with actual type `[t0]'
05:07:41 <lambdabot>     In the first argument of `Just', namely `["hi", "bi"]'
05:07:43 <bartavelle> can I get the haskell binary full path easily with ghc 7.4.1 ?
05:07:53 <bartavelle> there is something called getExecutablePath in 7.6.1
05:08:00 <`ramses> :t intercalate ", " . concat . fmap maybeToList [Just "abc"]
05:08:01 <flebron> :t intercalate ", " . concat . fmap maybeToList [Just "abc", Nothing, Just "def"]
05:08:01 <lambdabot>     Couldn't match expected type `[Char]' with actual type `Char'
05:08:02 <lambdabot>     Expected type: [[Char]]
05:08:02 <lambdabot>       Actual type: [Char]
05:08:02 <lambdabot>     Couldn't match expected type `[Char]' with actual type `Char'
05:08:02 <lambdabot>     Expected type: [[Char]]
05:08:03 <lambdabot>       Actual type: [Char]
05:08:12 <flebron> ... yeah I hate everything.
05:08:20 <pqmodn> :t maybeToList
05:08:21 <`ramses> :t fmap maybeToList
05:08:22 <lambdabot> Maybe a -> [a]
05:08:22 <lambdabot> Functor f => f (Maybe a) -> f [a]
05:08:23 <monqy> this is just the same problem you were having before.
05:08:26 <monqy> try
05:08:36 <monqy> :t intercalate ", " . concat . fmap maybeToList $ [Just "abc"]
05:08:38 <lambdabot> [Char]
05:08:45 <monqy> > intercalate ", " . concat . fmap maybeToList $ [Just "abc"]
05:08:48 <lambdabot>   "abc"
05:09:02 <`ramses> monqy: that's what I was supposed to be getting at, but I'm really messing up
05:09:38 <flebron> Ah, you're right. Thanks :)
05:10:00 <flebron> So a $ b is always used to mean (a) $ (b), right?
05:10:15 <flebron> (For whatever expressions a, b)
05:10:24 <`ramses> flebron: remember that in a series of compositions, all element must be single argument functions, you cannot have a value
05:10:33 <flebron> Right.
05:10:42 <monqy> flebron: $ is just function application but with really low precedence
05:10:44 <`ramses> depends on whether there are other infox operators in a or b
05:10:57 <`ramses> and what those operators have as fixities
05:10:58 <monqy> flebron: and right-associative
05:11:45 <flebron> Cool. Thanks :)
05:18:32 * hackagebot diagrams-tikz 0.6 - TikZ backend for diagrams drawing EDSL  http://hackage.haskell.org/package/diagrams-tikz-0.6 (AriePeterson)
05:23:32 * hackagebot fb-persistent 0.2.1 - Provides Persistent instances to Facebook types.  http://hackage.haskell.org/package/fb-persistent-0.2.1 (FelipeLessa)
05:41:52 <nomeata> Hi. Can someone recommend a library for numerical minimization? cmaes has a great interface, but seems to be too slow for my problem (which is packing circles of varying size as tight as possible).
05:44:10 <Jafet> > min [1, 2, 3, 0]
05:44:12 <lambdabot>   No instance for (GHC.Show.Show ([t0] -> [t0]))
05:44:12 <lambdabot>    arising from a use of `M6...
05:44:14 <Jafet> > minimum [1, 2, 3, 0]
05:44:15 <lambdabot>   0
05:48:57 <navaati> hi
05:49:29 <navaati> are the lens described in this article http://comonad.com/reader/2012/mirrored-lenses/ implemented in a package ?
05:50:45 <applicative> isn't that the initial draft  of the lens lib
05:51:18 <aristid> navaati: it turns out they are!
05:51:24 <aristid> navaati: it's the lens package
05:51:53 <aristid> it even has its own channel: #haskell-lens :>
05:52:18 <navaati> aristid: thanks
05:52:40 <Jafet> @quote lens
05:52:40 <lambdabot> roconnor says: a lens is a monoidal natural transformation between higher-order coalgebra functors, what's the problem?
05:53:29 <applicative> > _1 .~ 4 $ (1,"hello")
05:53:31 <lambdabot>   (4,"hello")
05:56:26 <navaati> :t _1
05:56:27 <lambdabot> (Functor f, Field1 s t a b) => (a -> f b) -> s -> f t
05:56:46 <Taneb> == Lens a b (a, c) (b, c)
05:57:04 <wuttf> Ahoi peeps."show" is not a visible method of class "X"
05:57:15 <navaati> ah, _1, _2, etc.. work on every tuple that is large enough ? omg this is great
05:57:16 <wuttf> what does that mean?
05:57:38 <Taneb> wuttf, it means you're using show on things that may or may not have a Show instance
05:57:59 <Taneb> Try adding "Show Foo => ..." to the type signature of your function
05:58:13 <quicksilver> no, it doesn't.
05:58:26 <Taneb> Okay, listen to quicksilver
05:58:28 <quicksilver> it means you're trying to write an instance including a method called 'show'
05:58:35 <quicksilver> for a class which doesn't actually have a method called 'show'
05:58:36 <quicksilver> (I think)
05:58:44 <Taneb> ...
05:58:52 <Taneb> I think I'm right
05:58:57 <fmap> navaati: up to 9
05:59:04 <sclv> hpaste the whole error and then it'll be obvious
05:59:05 <typoclass> wuttf: it'd help if you could put the problematic code on hpaste, along with the error that ghc printed
05:59:06 <Taneb> wuttf, do you have something like "foo :: X x =>..."
05:59:09 <typoclass> @where hpaste
05:59:09 <lambdabot> http://hpaste.org/
05:59:21 <quicksilver> Taneb: your case would give an error like "No Show instance for blah"
05:59:28 <quicksilver> Taneb: not "'show' is not a visible method of blah"
05:59:41 <wuttf> typoclass, Taneb getting there =), im so excited
05:59:59 <Taneb> wuttf, make it "foo :: (X x, Show x) => ..."
06:00:54 <Taneb> Hang on
06:00:57 <wuttf> https://gist.github.com/4285644   Taneb , typ
06:01:15 <wuttf> I want an int to be displayed as like "8:00"
06:01:17 <Taneb> Yeah, I'm completely wrong
06:01:50 <Taneb> Use "`div`" instead of "/"
06:02:35 <typoclass> wuttf: have you tried doing "show (a/60)" instead of "(a/60)" ? same for a `mod? 60
06:03:04 <quicksilver> wuttf: please paste also full error message.
06:03:20 <wuttf> minute
06:03:23 <navaati> ouch, lens pulls in all the "edwardk suite", comonads, contravariants, semigoupoids...
06:03:43 <Eduard_Munteanu> edwardk-platform
06:03:45 <quicksilver> because I certainly don't get anythin gabout 'show' not being a visible method
06:03:55 <quicksilver> I get "Couldn't match expected type `[Char]' against inferred type `Int'"
06:04:01 <quicksilver> which is much more what I'd expect.
06:04:06 <typoclass> quicksilver: same here
06:04:12 <wuttf> quicksilver: That was an older error msg, it seem to work now
06:04:24 <quicksilver> the error you give could arise if you transpose Minute and Show
06:04:29 <quicksilver> instance Minute Show where ...
06:04:31 <wuttf> https://gist.github.com/4285670 added two shows to the numbers too
06:04:39 <wuttf> it compiles (yay!)
06:05:19 <wuttf> Hahah, works ! :D
06:05:32 <wuttf> omg my first ever anything I did in haskell
06:06:45 <quchen> wuttf: You'll be surprised how often you'll write "Hahah, it works" in the future :-)
06:07:06 <typoclass> wuttf: congratulations then :-)
06:07:09 <wuttf> quchen: I hope so, the syntax is so alien (C and Go guy here)
06:07:39 <wuttf> typoclass: ^^
06:08:20 <quchen> wuttf: It grows on you. You'll learn to dislike parentheses and semicolons. The downside is that going back to C is a pain.
06:08:39 <Philippa_> wuttf: you get used to it surprisingly fast :-) Though if you're like me, you'll find yourself reading the Haskell Report to get the grammar directly
06:09:38 <wuttf> Time will tell =) How can i write a multiline function
06:09:43 <quchen> And the syntax is not the only thing alien, the whole language is when you're used to imperative programming. But it's a good kind of alien
06:09:45 <wuttf> enter and keep indentation?
06:09:46 <navaati> quchen: this. Haskell syntax is just... there is actually not realy any syntax
06:10:00 <quchen> wuttf: Are you using GHCi?
06:10:01 <applicative> >  _1.both %~ (+1) $ ((3,0),4)
06:10:01 <navaati> you just write words. and it works
06:10:03 <lambdabot>   ((4,1),4)
06:10:10 <wuttf> quchen: no
06:10:16 <quchen> What are you using then?
06:10:21 <Eduard_Munteanu> wuttf: you have to indent appropriately
06:10:25 <Jafet> Haskell has a lot of syntax
06:10:31 <Eduard_Munteanu> foo = 1 +
06:10:32 <navaati> :t both
06:10:33 <lambdabot> Applicative f => (a -> f b) -> (a, a) -> f (b, b)
06:10:34 <Eduard_Munteanu>            2
06:11:10 <navaati> Jafet: well, it's mostly made of layout rules
06:11:45 <navaati> :t (%~)
06:11:46 <lambdabot> Setting s t a b -> (a -> b) -> s -> t
06:11:59 <Philippa_> Jafet: eh, it has a moderate amount for a non-mimimalist language, I reckon. Not all bits are equally tasteful, but I rate the HOPL paper on it as a description of why the 'core' has more than you might expect
06:12:41 <Philippa_> navaati: the layout rule does a lot to save typing and visual clutter, yeah. The constructs that use it each count as 'more syntax' though!
06:12:52 <Jafet> There is also syntactic magic in GHC
06:13:15 <navaati> :t (both %~ (+1))
06:13:16 <lambdabot> Num b => (b, b) -> (b, b)
06:13:27 <navaati> :t (both %~ show)
06:13:28 <lambdabot> Show a => (a, a) -> (String, String)
06:14:04 <Nereid> I wish I was able to set the multiline input prompt in ghci.
06:14:05 <Nereid> :(
06:14:16 <Nereid> then again I've never actually used multiline input.
06:14:51 <wuttf> Can I ask for help again?
06:14:53 <typoclass> i wonder if making haskell's syntax more regular would lead to more clutter. i suspect yes
06:15:23 <b_jonas> wuttf: yes
06:15:25 <wuttf> https://gist.github.com/4285723            Whats wrong with this?
06:15:29 <typoclass> wuttf: only if you pay by posting a dozen lolcats
06:15:30 <typoclass> =)
06:15:31 <quchen> wuttf: We usually allow one question per day only. ;-)
06:15:36 <Nereid> wuttf: don't use tabs
06:15:37 <Jafet> Most of the syntax rules are used
06:16:11 <wuttf> Nereid: yeah it looks crap :S
06:16:18 <quchen> Nereid: Don't use "Don't use tabs" or the discussion goes down the bin here
06:16:18 <Nereid> no, honestly, don't use tabs. tabs breaks things.
06:16:21 <wuttf> quchen, typoclass :D
06:16:32 <wuttf> I am a tab kind of guy
06:16:37 <Philippa_> typoclass: wait, you mean requiring explicit case instead of equations might be costly? Or requiring equations in the middle of expressions?...
06:16:39 <wuttf> In fact I could kill people using spaces
06:16:40 <Nereid> haskell is not a tab kind of language.
06:16:42 <wuttf> :D
06:16:44 <typoclass> wuttf: if you want to use "... = ...", then you'll have to be inside a "where" or "let-in". you'd have to use "let minPart = ... hourPart = ... in ..."
06:17:17 <Nereid> oh, sure.
06:17:23 <Nereid> but you'll also need to fix the whitespace.
06:17:42 <Philippa_> nah. You never /need/ to fix whitespace. You can just use {;} instead
06:17:48 <Nereid> :(
06:18:05 <typoclass> wuttf: most people recomment spaces these days, but whatever. you _do_ have to be consistent with your indentation, however. it's significant in haskell
06:18:34 * hackagebot esqueleto 1.0 - Bare bones, type-safe EDSL for SQL queries on persistent backends.  http://hackage.haskell.org/package/esqueleto-1.0 (FelipeLessa)
06:18:36 * hackagebot bitmap-opengl 0.0.0.1 - OpenGL support for Data.Bitmap.  http://hackage.haskell.org/package/bitmap-opengl-0.0.0.1 (BalazsKomuves)
06:18:44 <quchen> wuttf: The right statement isn't "don't use tab", it's "don't mix different ways of indentation".
06:18:58 <quchen> Using tabs is perfectly fine if you structure your notation accordingly.
06:19:00 <Philippa_> typoclass: hell, last time I wrote my own layout system I just didn't support tab
06:19:03 <Fuuzetsu> ozataman_: Hey, I'm trying to use shpider but I get an empty page back after I send a form to a login page. Is that normal behaviour? Does it store session cookies?
06:19:09 <wuttf> quchen: I used only tabs i think
06:19:17 <typoclass> Philippa_: i like you!
06:19:18 <typoclass> =)
06:20:15 <typoclass> Fuuzetsu: not sure about shpider, but http-conduit handles cookies, if i'm not mistaken
06:20:35 <Fuuzetsu> I'll look into it
06:20:56 <Peaker> quchen, Using tabs "correctly" requires a lot of discipline, and the gain is miniscule. It almost always deteriorates into a big mess
06:21:01 <Peaker> I wish \x09 was just never invented
06:21:53 <quchen> Peaker: I used tabs in Haskell until a month ago, and I wouldn't call "place a newline after every where/do/let/in" discipline, especially because the code fails very quickly if you don't.
06:22:01 <Nereid> it's possible to use tabs "correctly"?
06:22:24 <Philippa_> quchen: the problem's when you're working with other people
06:22:41 <Peaker> quchen, the problem is not newlines, it's using tabs exclusively for indentation (avoiding alignment) and using them consistently. Given that by default the difference between them and spaces is invisible, that is not trivial. And we don't need another non-trivial thing to keep in mind when editing code.
06:22:52 <Peaker> and what Philippa_ said too :)
06:23:00 <Nereid> I set vim to show me tabs so I know to get rid of them.
06:23:27 <typoclass> Peaker: i think there's 1-2 interesting ideas in the whole "tab thing", but the way it's currently handled in editors is likely to cause pain
06:23:34 <quchen> Philippa_: Yes, mixing tabs and spaces is dangerous. However, that's not a tab problem but a tab vs space problem.
06:23:36 <Philippa_> as team size and coding time go up, the probability of someone doing something stupid tends towards 1. You can conclude you should simply shoot them, but you might find out future-you was the idiot for 5 sad minutes
06:23:37 <typoclass> Peaker: how do you mean 'avoiding alignment'?
06:23:40 <Nereid> anyway, read http://urchin.earth.li/~ian/style/haskell.html
06:23:54 <Peaker> typoclass, yeah, if it was fully standardized and it was taken for granted that it just worked in most editors, it could have been worth the miniscule gain
06:24:07 <Nereid> if you use vim, the 'listchars' option is helpful.
06:24:20 <Nereid> every decent text editor does soft tabs anyway.
06:24:28 <Peaker> typoclass, the idea with tabs is being able to configure your own "indent size", but if you also use tabs for aligning the next line with some word in the middle of the previous line - that will be messed up
06:24:39 <typoclass> Philippa_: for me, the conclusion is: doing "something stupid" should be made hard and unlikely
06:24:59 <Philippa_> typoclass: or else less stupid/damaging, yes
06:25:11 <Peaker> typoclass, so you must only use tabs for the indent part, or alignments get messed up
06:25:14 <lpsmith> is there a way to get ghci to ignore group write bits on .ghci files and whatnot?
06:25:25 <Philippa_> (ye gods does the type system save my arse when I'm coding tired and blending embedding levels...)
06:26:15 <wuttf> I simply can't get the intentation right
06:26:19 <wuttf> ind*
06:26:42 <Philippa_> wuttf: read the bit in the Report explaining the layout rule, then read the formal follow-up. It helps a lot.
06:26:49 <typoclass> Philippa_: yeah. the whole "we need to shoot whoever did something stupid" thing in my view is a doomed and not thought-through attempt to make humans be not human
06:26:51 <wuttf> Philippa_: ok
06:27:10 <typoclass> wuttf: if you can't figure it out, feel free to paste the code
06:27:21 <Philippa_> wuttf: when you know what kicks the layout rule in, you'll know what has to align with what :-)
06:27:42 <Nereid> I don't actually know the layout rules, but it's not that hard to get things right when you get used to it a little.
06:28:13 <b_jonas> I just use braces. I don't like layout rules.
06:28:29 <wuttf> Is it possible to do object composition with Haskell?
06:28:49 <Nereid> what is "object composition"?
06:29:22 <typoclass> lpsmith: maybe sudo? not sure what you mean by 'ignore and whatnot' :-)
06:30:07 <b_jonas> @faq Can haskell do object composition?
06:30:07 <lambdabot> The answer is: Yes! Haskell can do that.
06:30:08 <wuttf> With curly braces:                 Car { Engine, Pedals },   Now Car has methods of both Engine and Pedals,
06:30:13 <wuttf> mostly used instead of inheritance
06:30:28 <Nereid> what is an object?
06:30:46 <wuttf> Well you know tha typical OOP imperative jargon dont you
06:30:53 <bindy> what are methods?
06:31:03 <Eduard_Munteanu> wuttf: no, you probably don't want to bring OOP stuff into Haskell
06:31:05 <Nereid> sure, but what does that have to do with haskell?
06:31:12 <Eduard_Munteanu> It can be done, but you'd better not.
06:31:27 <typoclass> wuttf: i guess the haskell equivalent might be that your 'data' (say it's called Foo) has an instance for the Engine typeclass, and an instance for Pedals, and for Show, etc.
06:31:37 <wuttf> Eduard_Munteanu: that was my question, thanks, I am justa  bit tired and English is not my native language as you can tell
06:31:38 <NoICE> wuttf: switch and open your mind. throw away OOP. try to do it differently.
06:31:55 <wuttf> NoICE: I feared that answer :D
06:31:56 <typoclass> wuttf: oh, like the Minute thing you declared
06:32:02 <wuttf> But I am excited to look forward
06:32:19 * Philippa_ would actually like a variant of newtype deriving that could do such things
06:32:21 <navaati> (no answers on #haskell-lens, trying here)
06:32:25 <navaati> i've got a typeclass so that types implementing it can export getters, setters or both, which types should i use ?
06:32:34 <Philippa_> perhaps "you get to derive if you can supply me an appropriate lens"?
06:32:39 <navaati> (for example, instead of "class Blah a where getName :: a -> String; setName :: String -> a -> a", i'd like "class Blah a where name :: <wtf should i write here ?>"
06:33:17 <typoclass> Philippa_: hehe, i hear it's a feature in the upcoming fork ghc-ed
06:33:24 <Philippa_> navaati: how do you distinguish the three cases?
06:33:38 <Nereid> navaati: you'd want to put a lens there.
06:33:39 <Philippa_> that is, how does someone holding Blah a => a know what they can/can't do with it?
06:33:48 <Nereid> or, in practice, a Loupe.
06:33:57 <Nereid> (so that you don't run into rank-2 issues.)
06:34:00 <Nereid> snap does this.
06:35:01 <NoICE> wuttf: haskell can do nicer abstractions than OOP, but it does it by many different ways..
06:35:33 <wuttf> NoICE: Well as you can imagine, I can't even imagine it. :D
06:35:38 <Nereid> wuttf: concepts from many other languages don't tend to map to any one thing in haskell.
06:36:01 <NoICE> wuttf: I can't too :D, but I'm trying :)
06:36:02 <wuttf> Nereid: I hope because I am fairly frustrated with almost all programming languages
06:36:20 <Nereid> time to unlearn them, then.
06:36:27 <navaati> Philippa_: ah, i was giving an example of a class exporting a getter *and* setter, but for one exporting a getter only it would be a different type
06:36:32 <Nereid> what haskell things have you been reading?
06:36:44 <wuttf> The older I get the surer I am all programming languages suck. That's why I turned to Haskell
06:36:48 <navaati> Nereid: well, yeah, but i'm asking what would be the type of such a lens
06:37:12 <Nereid> navaati: hm? do you have something specific in mind?
06:37:18 <wuttf> Nereid: Learn you a Haskell, but I started on the make your own types Chapter so maybe I should start on page 0.
06:37:22 <Philippa_> wuttf: you'll eventually find that Haskell sucks too, but the longer you take, the more refined an opinion you'll have on why
06:37:30 <Nereid> wuttf: do start at the beginning.
06:37:34 <Philippa_> (and thus on what to look at next)
06:37:36 <typoclass> wuttf: if it helps, for a pretty long while i was like "oh let's try out python, oh let's try out perl, oh let's ...". i kinda lost interest in other languages after finding haskell =)
06:37:37 <navaati> Nereid: no, i'm only lost into the lens library many types
06:37:58 <Philippa_> typoclass: hah. I got cynical about the P languages (and Ruby by the time it was a thing) pretty fast
06:38:10 <b_jonas> Philippa_: ruby is a P language
06:38:13 <typoclass> wuttf: i tried some python once, but i just got frustrated how backwards and clumsy everything was
06:38:19 <bartavelle> hum, my language puppet library was much faster than the ruby native code, but I just realized I didn't use -O flags ...
06:38:27 <b_jonas> it's the smalltalk of the P languages
06:38:30 <Philippa_> then again, my first language was Pascal and I spent plenty of time with basics as a kid
06:38:45 <Philippa_> b_jonas: yeah, which is why I have slightly more respect for it. But it's not /obviously/ a P language
06:38:45 <wuttf> typoclass: Yeah most imperative languages are really close to each other
06:38:55 <navaati> typoclass: same for me, the only language i learnt after haskell was C, out of necessity
06:38:57 <typoclass> Philippa_: right. if you ask me, the whole dynamic typing idea will at some point turn out to be a dead end
06:39:01 <Philippa_> (and does PHP really count if that's what we're describing? POS that it is...)
06:39:06 <typoclass> navaati: condolences
06:39:07 <navaati> (and agda, but is it a programming alnguageº)
06:39:21 <typoclass> wuttf: that's true
06:39:33 <Philippa_> typoclass: GHC's done the right thing to make it one, certainly - optionally deferred errors are better
06:39:45 <navaati> oh, C has ugly parts but i find it's philosophy quite nice
06:39:50 <wuttf> typoclass: Dynamic typing is static typing with only one type :P
06:40:07 <b_jonas> right
06:40:07 <wuttf> Dead end. Disaster
06:40:07 * Philippa_ recommends learning logic programming to some extent as well - enough so to grok constraint logic programming
06:40:24 <Philippa_> if you end up then going back and embedding it in Haskell that's just fine :-) But it's a useful viewpoint
06:40:26 <NoICE> I like that first (or close-to-first), there were procedural languages, then everyone switched to OOP, then they discovered that OOP is limiting, so they invented open classes (ruby), instead of saying "damn, OOP really suck, let's get back to roots and reinvent the whole thing" :) OOP is such a bullshit (imo).
06:40:30 <typoclass> Philippa_: i agree completely, if by 'the right thing' you're referring to badass type inference
06:40:33 <Jafet> @quote learn.agda
06:40:33 <lambdabot> ManuelChakravarty says: We used to say, "Learn Haskell, it makes you a better Java programmer." Now we say, "Learn Agda, it makes you a better Haskell programmer."
06:40:52 <b_jonas> hehe
06:40:55 <Philippa_> NoICE: you sound like you're only familiar with the 'mainstream' history of OOP
06:41:12 <mreh> I'd like to hear the underground history of OOP
06:41:14 <typoclass> Jafet: what's the word on learning haskell in order to become a better haskell programmer?
06:41:17 <Philippa_> (the one where Smalltalk gets brushed aside as this weird extremist thing instead of the lang that at least makes sense)
06:41:23 <bindy> wuttf: to your original question - I think this might be enlightening for you a bit: http://stackoverflow.com/questions/6636107/polymorphism-in-haskell
06:41:25 <Jafet> The pundits are divided on that.
06:41:52 <genn> ciao
06:41:56 <typoclass> Jafet: predictably they are
06:42:05 <genn> !list
06:42:05 <monochrom> genn: http://okmij.org/ftp
06:42:22 <Jafet> !list
06:42:29 <Jafet> Poo.
06:42:35 <typoclass> jafet: icanhascheezburger.com
06:42:43 <mreh> how the heck do I include libraries with UHC? what exactly is a library here?! I'm too used to using cabal
06:42:53 <Philippa_> http://c2.com/cgi/wiki?AlanKayOnMessaging is worth a read for anyone who thinks there /can't/ be a sensible OOP
06:43:23 <wuttf> bindy: this typeclass business looks a lot like interfaces in Go
06:43:24 <frx> to read an utf8 text file should i do something other Data.Text.IO.readFile? I am getting errors
06:43:25 <Jafet> Alan Kay? Isn't he that weird extremist thing?
06:43:34 * hackagebot haskdeep 0.1.0.0 - Computes and audits file hashes.  http://hackage.haskell.org/package/haskdeep-0.1.0.0 (MauroTaraborelli)
06:43:43 <b_jonas> So is it fundamentally impossible to infer the types in a polymorphic recursive function? Or is there some algorithm more complicated than the usual Hindley-Milner that can do that?
06:43:43 <typoclass> wuttf: somewhat, yeah
06:43:46 <Philippa_> mreh: the underground one is "there was all this ancestor stuff including Simula and Flavours, then Smalltalk has a biiiig history then stuff like CLOS and ohshit C++ starts happening and it all gets hijacked into commercialised and/or bastardised-for-hardware things"
06:44:07 <Nereid> b_jonas: ???
06:44:07 <nomeata> hmm, Numeric.GSL.Minimization looked good, but does not give good results. Gets stuck too easily in a local minimum.
06:44:08 <Philippa_> b_jonas: it's fundamentally impossible to cover all of them. There are algorithms that work it out for some defined classes
06:44:28 <Philippa_> (assumingly you mean polymorphically recursive: calls itself at different types)
06:44:34 <NoICE> Philippa_: I don't know the whole history, but in fact I was delighted when I first saw OOP in action in pascal.. OOP has it's benefits, but it was escalated to absurd designs in "modern languages".. what bothers me in OOP is (in modern world) the limiting things, like you can't "fix" internal class of some library, because it's nested (and used) deep within.. it shouldn't be done like that, but many (especially ruby) libraries are like that.. a
06:44:34 <NoICE> nd that sucks..
06:44:37 <b_jonas> Philippa_: yes, that kind of polymorpically recursive
06:44:41 <Nereid> oh that kind.
06:44:42 <bindy> wuttf: can't say, I'm not familiar with Go; but yeah, they are basically interfaces
06:44:48 <scp> Is there a way to force Num literals to be Ints in GHCI?
06:44:56 <Jafet> @quote edwardk yo.dawg
06:44:56 <lambdabot> edwardk says: yo dawg, in haskell we can be so oop that even our accessors have UML diagrams describing their accessors.
06:45:04 <typoclass> scp: 3 :: Int ?
06:45:07 <Jafet> scp: default Int Double
06:45:13 <Jafet> Enjoy your numerical errors
06:45:23 <Philippa_> NoICE: yeah, TP5.5 was my first lang
06:45:24 <scp> I am giving a brief presentation on haskell
06:45:29 <scp> I want to show people some things w/ :t
06:45:43 <Philippa_> though what you're describing is 'shitty lib design'? :p
06:45:44 <scp> and (Num a) => a -> a is confusing and difficult to explain quickly
06:45:45 <Jafet> :t 0
06:45:46 <wuttf> :D lambdabot seems so neat
06:45:46 <lambdabot> Num a => a
06:46:14 <Jafet> But that's the type of integer literals.
06:46:16 <Philippa_> scp: what you want there if you can is syntax highlighting so you can concentrate on the RHS of the => and then say "oh, and a is a Number"
06:46:19 <wuttf> what if you give him a command to sum an infinit list or sumtin
06:46:37 <Philippa_> (but anything you can do to get more useful tyvar names is good)
06:46:39 <frx> am i crazy for thinking bigfoot beats overeem?
06:46:57 <scp> Jafet: Where do I put "default Int Double"?
06:47:15 <Peaker> > cycle ["lambdabot", "is", "neat"]
06:47:17 <lambdabot>   ["lambdabot","is","neat","lambdabot","is","neat","lambdabot","is","neat","l...
06:47:33 <Philippa_> scp: IME people tend to intrinsically grok constraints so long as they don't have to build the constraint system themselves and it's moderately well-behaved
06:47:46 <Philippa_> or if not intrinsically, it's only a mild generalisation of stuff we were all doing in maths classes as kids
06:48:03 <wuttf> Peaker: :DD D:
06:48:07 <Nereid> > fix (scanl (+) 0 . (1:))
06:48:09 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
06:48:25 <scp> fix = y?
06:48:26 <typoclass> wuttf: note that beginners sometimes misunderstand and think typeclasses should be used for everything and the dog. this is not the case :-) plain functions go a long way, and doubly so in haskell. typeclasses have their place, but they are actually a somewhat remote feature of haskell, imho
06:48:33 <Jafet> scp: far away from programs
06:48:34 * hackagebot FreeTypeGL 0.0.1 - Haskell fonts with OpenGL  http://hackage.haskell.org/package/FreeTypeGL-0.0.1 (EyalLotem)
06:48:36 * hackagebot Network-NineP 0.1.0 - High-level abstraction over 9P protocol  http://hackage.haskell.org/package/Network-NineP-0.1.0 (SergeyAlirzaev)
06:48:55 <Peaker> scp, yeah, it does what Y does - but it does so with explicit recursion, not without
06:48:56 <Philippa_> typoclass: there are varying opinions on that, of course. Not least because they're the closest thing we have to MLish modules
06:48:57 <NoICE> Philippa_: practically.. yes, but that's the motive for "open classes" thing.. and that's what makes ruby "unusable" to me, I don't want some library hijacking my own things :D I like FP for composability at the lowest level and I believe that data and code should not be tied together.. and haskell takes all those beautiful designs and principles to next level, I love it
06:49:00 <wuttf> typoclass: I will keep in mind thanks.
06:49:27 <wuttf> i find this so awesome:
06:49:33 <wuttf> map (+1) [0 .. 10]
06:49:39 <wuttf> +1 being a function, wow :D
06:49:43 <typoclass> Philippa_: right, good point on the modules
06:49:43 <scp> Philippa_: That is true, maybe I'll just do a quick explanation w/ `:t 5' and then go on
06:49:49 <Peaker> NoICE, of course data and code relating to a concept should be tied together.. that's why we have modules, and abstract types... You want Data.Map's data and code together in one place
06:49:51 <Philippa_> NoICE: right, the AlanKayOnMessaging page has some stuff about limiting such operations to when you intend to allow meta stuff
06:50:18 <typoclass> wuttf: right :-) the parens are significant by the way. (+1) works, +1 doesn't work in the same way
06:50:31 <Nereid> > takeWhile (<300) . map (^2) $ [0..]
06:50:33 <lambdabot>   [0,1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289]
06:50:36 <Peaker> I guess the "wrongness" is how tight they are being tied together
06:50:42 <Nereid> > takeWhile (<300) . map (^2) . filter odd $ [0..]
06:50:44 <lambdabot>   [1,9,25,49,81,121,169,225,289]
06:51:23 <bindy> Peaker: you talk about tieing data definition and code, noice talks about data itself and code
06:51:24 <Nereid> > scanl (+1) 0 [1..]
06:51:27 <lambdabot>   Occurs check: cannot construct the infinite type: a0 = b0 -> a0
06:51:28 <Nereid> er
06:51:30 <Nereid> > scanl (+) 0 [1..]
06:51:32 <lambdabot>   [0,1,3,6,10,15,21,28,36,45,55,66,78,91,105,120,136,153,171,190,210,231,253,...
06:51:33 <wuttf> typoclass: I see
06:52:09 <NoICE> Peaker: and that you shouldn't touch some classes data in proper OOP.. but I want to touch my data! :D
06:52:29 <Peaker> NoICE, that's data-hiding, which is a good thing: Can you touch the data behind a Data.Map?
06:52:39 <Peaker> NoICE, (it's internal implementation details)
06:53:51 <ktosiek> Peaker: only whatever is exported from the module
06:53:58 <aristid> data hiding helps ensure that a data structure cannot get into an inconsistent state
06:54:31 <NoICE> aristid: in OOP, yes, but in functinal language - what state? :)
06:54:35 <Peaker> ktosiek, yeah. and that's a good thing
06:54:39 <Jafet> scp:
06:54:47 <Peaker> NoICE, there is state, it's just not destructively updated
06:54:54 <scp> Jafet: yes?
06:54:58 <Jafet> ghci> :def t (const $ return "putStrLn \"Int\"")
06:55:03 <Jafet> ghci> :t 0
06:55:07 <Jafet> Int
06:55:37 <scp> x_X
06:56:07 <Jafet> Silly solutions to silly problems
06:56:35 <lpsmith> typoclass, the problem is that ghci is ignoring a .ghci file if it has the group write bit set,  because it's "writable by another person".
06:56:42 <Philippa_> aristid: it's almost like it's the poor version of quotienting or something!
06:56:46 <NoICE> Peaker: I believe you know what I'm talking about when I say I want to touch my data.. encapsulation is a good thing, sure.. sometimes..
06:57:04 <aristid> Philippa_: indeed!
06:57:05 <typoclass> lpsmith: urgh! unbelievable
06:57:12 <lpsmith> ghci checks the permissions of certain files before it will process them
06:57:16 <Peaker> NoICE, I don't think that's about OOP/FP either way -- both have facilities for data-hiding (and good on both for that!)
06:57:21 <aristid> Philippa_: or of any dependent types at all.
06:57:42 <Jafet> That's normal for all dot files
06:58:00 <Philippa_> NoICE: The wonderful thing about parametric polymorphism is you don't need to touch the data as such. You just need to know how the data works, and then something else can touch it all it likes
06:58:07 <lpsmith> typoclass, yeah especially because User Private Group is getting nearly ubiquitous on most recent unix systems,  except in a few very large installations
06:58:10 <Philippa_> it encourages a much more 'open' style
06:58:12 <dmwit> I really wish Text.Read.Lex exposed more things.
06:58:16 <scp> Jafet: Sorry, I'll try to just post serious problems from now on, thanks for the help
06:58:27 <typoclass> Jafet: no idea, never seen it before
06:58:45 <Jafet> Many dot files aren't even supposed to be world readable
06:58:53 <Philippa_> dmwit: *nod* Yeah, the downside is that... well, not everything really runs with it. Hell, I'm in a weird state there with the constraint lib I'm writing
06:59:01 <Philippa_> (but I'm at least clearly trying in some directions!)
06:59:03 <NoICE> Philippa_: right! and I like that a lot
06:59:52 <Philippa_> NoICE: the big realisation is "I can have something that promises not to touch the data itself /and still pass it something that can because that's okay, I told it so/"
07:00:20 <Philippa_> map promises that /map itself/ can't mess with your data, only the function you pass it can :-)
07:00:26 <dmwit> Philippa_: Sorry, what does "not everything really runs with it" mean?
07:00:36 <Philippa_> dmwit: not everything uses that style fully
07:00:51 <dmwit> what style?
07:01:10 <Taneb> There hasn't been a 24 Days of Hackage today...
07:01:21 <Peaker> If I'm reexporting a type that I imported from another module -- how can I attach haddock documentation for it in the context of my own module?
07:01:33 <dmwit> The "expose all your internals" style, you mean?
07:01:37 <blackmirroxx1> yeah - I got my leksah IDE to work XD
07:01:38 <Peaker> or will haddock just paste the same documentation in the re-exported context?
07:01:48 <aristid> dmwit: the "use polymorphic types for safety" style i presume?
07:02:11 <dmwit> huh
07:02:12 <hpaste> Nereid pasted “Typeclasses with lenses” at http://hpaste.org/79194
07:02:18 <Nereid> uh oops wrong channel
07:02:25 <dmwit> I guess I just got caught in the crossfire, then? Because I wasn't talking about polymorphism at all.
07:02:27 <Nereid> oh the guy left
07:02:28 <Nereid> ugh
07:02:55 <dmwit> I just want to call Text.Read.Lex.lexDecNumber, which is really really monomorphic.
07:02:57 <Jafet> Ok, a more silly answer to scp
07:03:02 <Jafet> :set -XRebindableSyntax
07:03:22 <Jafet> let fromInteger :: Integer -> Int; fromInteger = Prelude.fromInteger
07:03:33 <arcatan> @tell ocharles we're eagerly waiting for the next episode of 24 days of hackage!
07:03:33 <lambdabot> Consider it noted.
07:04:15 <ocharles> arcatan: :)
07:04:15 <lambdabot> ocharles: You have 1 new message. '/msg lambdabot @messages' to read it.
07:04:40 <ocharles> arcatan: the place I work in is currently moving offices - yesterday was the moving out party, and today is the actual moving
07:04:43 <ocharles> it's really quite hectic :(
07:05:54 <arcatan> oh well
07:07:08 <Philippa_> aristid: I was thinking "use polymorphic types as a way to expose your internals/make them replaceable" actually
07:07:24 <Philippa_> (the difference between parsecs 2 and 3, say)
07:07:47 <aristid> Philippa_: well that works for some types. i don't believe it would for Data.Map.
07:08:06 <Philippa_> aristid: me either
07:08:36 <aristid> so there is merit in data hiding. it's not always the best option though.
07:09:04 <Philippa_> OTOH? I'm building a lot of what're technically functors but 'really' are just plain old data except you get to punch a hole where the recursion happens. Wishing the syntax for it were nicer actually, I don't want the functoriality caught up in my description of what the data itself is
07:09:20 <Philippa_> the knack's in knowing where to punch the holes, I guess
07:12:13 <blackmirroxx1> I <3 lambdabot especially (at)src <function> :):-D:-[
07:12:24 <Peaker> Does haddock support bullet point lists?
07:12:52 <dmwit> blackmirroxx1: See also hoogle, which has "source" links for many more functions than ?src knows about.
07:12:55 <ocharles> arcatan: I have one written for yesterday, and todays will be short
07:12:57 <dmwit> ?where hoogle
07:12:57 <lambdabot> http://haskell.org/hoogle
07:13:00 <ocharles> I will hopefully have time to do them soon.
07:13:12 <thoughtpolice> Peaker: sure, just put them on their own line with '*' at the front, seperated from the other elements by 1 blank line
07:13:22 <Peaker> thoughtpolice, thanks
07:13:24 <thoughtpolice> so, '* Foo\n\n* Bar\n\n*Baz'
07:13:26 <thoughtpolice> np
07:19:53 <blackmirroxx1> is there a difference between hoggle and hoogle+ ?
07:20:09 <dmwit> Yep, ?hoogle+ prints more results from the latest ?hoogle query.
07:20:19 <Clint> and hoggle is a character from labyrinth
07:20:19 <dmwit> ?help hoogle
07:20:19 <lambdabot> hoogle <expr>. Haskell API Search for either names, or types.
07:20:23 <dmwit> ?help hoogle+
07:20:23 <lambdabot> hoogle <expr>. Haskell API Search for either names, or types.
07:20:29 <dmwit> well that's unhelpful
07:20:49 <dmwit> ?hoogle a
07:20:50 <lambdabot> Prelude abs :: Num a => a -> a
07:20:50 <lambdabot> Prelude acos :: Floating a => a -> a
07:20:50 <lambdabot> Prelude acosh :: Floating a => a -> a
07:20:53 <dmwit> ?hoogle+
07:20:53 <lambdabot> Prelude all :: (a -> Bool) -> [a] -> Bool
07:20:53 <lambdabot> Data.List all :: (a -> Bool) -> [a] -> Bool
07:20:53 <lambdabot> Prelude and :: [Bool] -> Bool
07:20:56 <dmwit> etc.
07:21:27 <Jafet> ?hoogl+
07:21:28 <lambdabot> Maybe you meant: hoogle hoogle+
07:22:38 <blackmirroxx1> nice ok I ll use ?hoogle+
07:22:54 <Nereid> any reason you use ? instead of @ ?
07:23:30 <Jafet> Why do you use @ instead of ? @
07:23:47 <blackmirroxx1> matter of taste
07:24:00 <Nereid> I don't know, probably because 95% of the time I see people use @
07:24:22 <Nereid> and it's consistent with other bots I've used
07:24:23 <blackmirroxx1> but you are talking to lambdabot and ? emphasizes that you have a question
07:24:35 <dmwit> I use ? because it is in a more convenient location on my keyboard than @.
07:24:48 <Nereid> yes, that thought crossed my mind.
07:24:53 <Nereid> about keyboard layouts.
07:25:00 <Nereid> what is your layout?
07:25:12 <dmwit> us(dvorak)
07:25:17 <Philippa_> dmwit: huh, I'm not sure there's much in it on a UK QWERTY
07:25:20 <blackmirroxx1> I have standard (se)
07:25:57 <Nereid> I didn't know people actually used dvorak.
07:26:21 <Nereid> :p
07:26:33 <dmwit> =)
07:27:10 <Nereid> I tried learning it once, got up to around 30wpm in a few days before I decided I typed fast enough with qwerty anyway.
07:28:34 <Nereid> I wish there was a faster way to input stuff into all these portable gadgets though. I feel literally retarded when I try to type on my phone.
07:30:42 <`ramses> Nereid: hook it up to a keyboard
07:30:54 <Nereid> if only that were always an option!
07:31:31 <`ramses> I thought they were working on foldable laptops, so a small foldable keyboard ought to be possible
07:31:49 <typoclass> Nereid: it's as if those tablets are more geared towards lounging around in executive meetings looking at colorful graphics, and not really geared towards what anyone might call work
07:31:50 <typoclass> =)
07:31:55 <Nereid> :)
07:32:14 <Nereid> I find them nice for reading papers on.
07:32:14 <Botje> i'm fast enough on my phone/tablet
07:32:24 <Botje> but typing prolonged texts is tiring.
07:33:09 <typoclass> Botje: have you tried looking at primary-color graphics and waving your tablet around under other people's noses?
07:33:36 <typoclass> Botje: bonus points if it's shiny and has some kitshy logo on the back
07:33:53 <Peaker> Can I make a linkable reference to a package in haddock?
07:33:58 * Philippa_ has a reasonable BT keyboard for her tablet
07:34:03 <Peaker> <url of package> is ok, but it'd be nice if the package name was the link text
07:34:18 <Philippa_> oh, also, -> -blah
07:34:29 <`ramses> Nereid: http://design.findfollowtweet.com/qii-the-mobile-rollable-foldable-keyboard/
07:34:32 <Philippa_> (do we need a -blah-overflow yet?)
07:35:06 <Nereid> haha
07:35:45 <`ramses> if you can think of it, someone has done it :)
07:35:59 <Nereid> `ramses: that looks like a nightmare for actual typing. I'm waiting to be able to input text directly from the brain.
07:36:09 <Philippa_> Nereid: yeah, tablets are great for papers. Actually, so long as there's somewhere for me to put the keyboard as well mine's good for most thing that aren't coding and heavy web browsing
07:36:46 <Philippa_> I got a zaggkeys flex: http://www.zagg.com/accessories/zaggkeys-flex-tablet-keyboard-stand
07:37:06 <`ramses> Nereid: they're working at that at my uni: http://www.quicksand.be/qs/?p=283
07:37:34 <`ramses> not sure whether I'd let them put it in my brain, though
07:37:39 <Nereid> haha, cool.
07:37:42 <Philippa_> it'd be nice to have a slightly larger one that's more laptop than netbook keyboard, but realistically? It's coding /Haskell/ the tab's not up to, if I liked Python I'd probably be all over it
07:40:10 <Nereid> Philippa_: I'd just pull out my laptop then.
07:41:01 <Peaker> Philippa_, why is coding Python on a tab easier than Haskell?
07:42:22 <edwardk> @tell navaati note: lens only pulls in the stuff it needs for its own purposes (context comonads are exposed in the API to good effect, and we use unordered-containers to a 50% speed increase in parts of the template haskell bits) or stuff that is part of the platform. https://github.com/ekmett/lens/wiki/faq#wiki-scope
07:42:22 <lambdabot> Consider it noted.
07:43:24 <Philippa_> Peaker: I can get a Python installation reasonably readily. GHC on Android is a PITA, GHC on unrooted Android ain't happening
07:48:35 * hackagebot diagrams-svg 0.6.0.1 - SVG backend for diagrams drawing EDSL.  http://hackage.haskell.org/package/diagrams-svg-0.6.0.1 (BrentYorgey)
07:53:35 * hackagebot scion-browser 0.2.13 - Command-line interface for browsing and searching packages documentation  http://hackage.haskell.org/package/scion-browser-0.2.13 (JeanPhilippeMoresmau)
07:56:53 <typoclass> edwardk: if you're referring to the earlier discussion of "edwardk-platform" and "all of edward" packages, i think that was with tongue firmly in cheek =)
07:58:34 <astropirate> Who wants to buy managed cloud hosting for haskell?
07:58:37 * hackagebot buildwrapper 0.6.3 - A library and an executable that provide an easy API for a Haskell IDE  http://hackage.haskell.org/package/buildwrapper-0.6.3 (JeanPhilippeMoresmau)
07:58:39 * hackagebot FreeTypeGL 0.0.2 - Loadable texture fonts for OpenGL.  http://hackage.haskell.org/package/FreeTypeGL-0.0.2 (EyalLotem)
07:58:55 <jamesmcm> hey
07:59:40 <jamesmcm> what is wrong with the follwing type definition?:
07:59:41 <jamesmcm> data Base = A ('A') | C ('C') | G ('G') | T ('T')
07:59:56 <jamesmcm> I just obtain: parse error on input `''
08:00:11 <Nereid> 'A' is not a type
08:00:15 <Mortchek> jamesmcm, a data constructor can't depend on a value
08:00:28 <jamesmcm> hmm I see, how would I make a type that can only be a subset of characters then?
08:00:30 <Nereid> maybe you just want: data Base = A | C | G | T
08:00:35 <Nereid> you can't make subset types.
08:00:42 <Mortchek> data constructor type*?
08:01:22 <Philippa_> Nereid: or maybe you want that plus toChar and fromChar functions, yeah
08:01:52 <Philippa_> jamesmcm: subsetness is boring. What's interesting is the things that being-a-subset lets you do. Haskell just won't let you do those things /implicitly/
08:03:01 <jamesmcm> cool I see how I can do it now using guards
08:03:08 <jamesmcm> I just wanted some basic type checking on the input
08:03:52 <Philippa_> ah. Yeah, you can't check the type on the input because that's not a type, but you want fromChar :: Maybe Base rather than fromChar :: Base anyway
08:17:38 <`nand`> why exactly does 'A'b results in a parse error when used as a type? It shouldn't be a problem, should it? Since char literals are not permitted in types anyways
08:18:01 <Nereid> why shouldn't it be a parse error?
08:18:36 * hackagebot FreeTypeGL 0.0.3 - Loadable texture fonts for OpenGL.  http://hackage.haskell.org/package/FreeTypeGL-0.0.3 (EyalLotem)
08:18:51 <dmwit> Nereid: I'm with `nand`, it should be the quoted type A'b.
08:18:54 <`nand`> Nereid: data A'b = A'b
08:19:01 <`nand`> 'A'b would be the promoted constructor A'b
08:19:12 <`nand`> there's no ambiguity
08:19:13 <Nereid> oh I see.
08:19:14 <dmwit> But with this new data promotion stuff, maybe character literals are allowed in types after all...
08:19:17 <dmwit> so
08:19:21 <dmwit> maybe there is ambiguity.
08:19:22 <`nand`> dmwit: yeah, that was my other thought; but it seems they aren't
08:19:25 <Nereid> well, Strings are.
08:19:45 <`nand`> in fact, I think type-level strings should be [Char] :)
08:23:30 <astropirate> Is the iteratee paradigm going to replace Monads for IO in haskell?
08:23:44 <Nereid> no
08:23:58 <Nereid> it is hardly a replacement.
08:24:21 <catsbydlo> what's the iteratee paradigm?
08:24:58 <ski> Philippa_ : "subsetness is boring" -- how about refinement types ?
08:25:23 <`ramses> @wiki iteratee
08:25:24 <lambdabot> http://www.haskell.org/haskellwiki/iteratee
08:25:38 <`ramses> @wiki iteratee IO
08:25:38 <lambdabot> http://www.haskell.org/haskellwiki/iteratee_IO
08:26:11 <`ramses> catsbydlo: ^^
08:27:11 <merijn> astropirate: Iteratees are only useful for file/stream like IO, afaik
08:27:12 <catsbydlo> `ramses: that just says an iterate is State
08:27:16 <catsbydlo> nothing about paradigms
08:27:20 <merijn> also, haven't conduits and pipes obsoleted iteratees?
08:27:49 <catsbydlo> "an iteratee is simply a function with state"
08:27:58 <astropirate> Nereid, merijn ohh I see. I'm still learning Haskell, i thought if Monads were being replaced no reason to learn it for the time being :)
08:28:19 <`ramses> astropirate: there is plenty of reason to learn about monads ;)
08:28:35 <benj_> monads aren't just for IO
08:28:41 <merijn> astropirate: 1) Monads will not go anywhere 2) Monads are all blown out of proportions, instead of learning about monads learn about typeclasses and the type system, monads will seem "obvious" afterwards
08:28:46 <catsbydlo> astropirate: almost all monads aren't IO
08:29:18 <astropirate> I see I see. I'm just at about the Monads chapter in learn you a haskell book
08:29:39 <catsbydlo> (similar to how most numbers aren't -5)
08:29:49 <Nereid> don't get to hung up on monads.
08:29:54 <b_jonas> merijn: I disagree. I don't think monads are obvious just because you understand typeclasses.
08:30:02 <Nereid> too*
08:30:13 <merijn> b_jonas: The Monad typeclass is fairly trivial after you understand typeclasses
08:30:14 <watermind> what do call  (>>)
08:30:26 <merijn> b_jonas: What is not obvious about it?
08:30:28 <watermind> do you*
08:30:30 <ion> “and then”
08:30:36 <`ramses> astropirate: I find them very well explained in lyah, so continue reading ;)
08:30:38 <bartavelle> waterlaz, "ind" ? ;)
08:30:41 <bartavelle> err
08:30:42 <bartavelle> watermind
08:30:45 <Philippa_> merijn: what the hell >>= is 'for'
08:30:46 <watermind> ion: I guess that works...
08:30:49 <watermind> bartavelle:  :)
08:30:57 <NoICE> hi guys, I have "simple" problem with Network.Socket .. when I connect to a server, then I close the servers socket, client still sees the socket as connected (isConnected == IO True), readable and writable... lsof sees the connection status: CLOSED_WAIT... and the client crashes when I do recv or send .. but why it does report false socket status? any workaroud?
08:31:19 <merijn> Philippa_: Once you understand typeclasses and then look at say, list/Maybe implementations of >>= it should become evident
08:31:23 <`ramses> watermind: I call it sequence
08:31:25 <b_jonas> merijn: the abstraction of what can be a monad and what all those various monads share. I understand parts of it, but not all.
08:31:47 <catsbydlo> merijn: the list implementation is just concatMap; that doesn't tell me anything
08:31:58 <merijn> NoICE: Did you close both read and write sides of the socket?
08:32:10 <NoICE> merijn: I terminated the server
08:32:11 <watermind> `ramses: I don't like that because  there exists sequence :: Monad m => [m a] -> m[a]   and it has nothing to do with >>
08:32:29 <`ramses> watermind: true, but (>>) sequences actions...
08:32:36 <NoICE> merijn: (close sock, ^D from ghci)
08:32:37 <merijn> watermind: Well, it kinda does
08:32:45 <`ramses> and I need a word to be able to think in my head
08:32:47 <watermind> `ramses: well... so does >>=
08:32:53 <watermind> merijn: sequence_ does
08:32:57 <`ramses> watermind: no, that's different!
08:33:04 <merijn> watermind: Oh, right
08:33:15 <Philippa_> merijn: you might think so. I remember what it was like in '03 or so, it really wasn't
08:33:20 <`ramses> watermind: in my head, I say that (>>=) binds a function into a monadic value
08:33:27 <Philippa_> I mean, you'd get a half-arsed idea that might suffice?
08:33:28 <watermind> `ramses: in deed it is different, but we call sequence to the function sequence which uses >>=
08:33:43 <`ramses> don't know whether that terminology is very good, but it works for me
08:33:52 <Philippa_> I eventually formed one that actually stands up to the CT definition and everything, around when Cale wrote MonadsAsContainers...
08:34:06 <watermind> `ramses: to be honest I agree with you that sequence is a nice word in principle
08:34:20 <Philippa_> `ramses: yeah, the terminology isn't ideal (you've got 'binds' backwards) but it's close enough to what used to be standard
08:34:21 <`ramses> watermind: I think sequence and (>>) both do "sequence", but they sequence differently
08:34:24 <catsbydlo> NoICE: show your code
08:35:03 <watermind> `ramses: yeap... therefore the sequence and sequence_ functions
08:35:06 <`ramses> Philippa_: the monadic value is bound into the function then? that works as well :)
08:35:08 <Philippa_> watermind: >>= does /binding/ sequencing, yeah. It's the gubbins inside a simple let statement, but people don't like the effort involved in spelling that out clearly
08:35:23 <Philippa_> `ramses: right :-)
08:35:34 <`ramses> watermind: hah that's a third!
08:35:42 <`ramses> we have three sequencing functions now
08:36:05 <watermind> `ramses: not really sequence and sequence_ are basically folds with >>= and >>
08:36:15 <watermind> kinda
08:36:18 <`ramses> I just call it sequence, mostly it's clear from the context what is meant
08:36:26 <`ramses> watermind: I know
08:36:38 <catsbydlo> "bound into"?
08:36:41 <`nand`> I call (>>) .. uh, actually I don't have a name for it
08:36:41 <watermind> Philippa_: exactly... which is why I was wondering about what to call (>>)
08:36:47 <`nand`> “then”, I guess?
08:36:52 <`nand`> but that only works for MonadsAsComputation
08:37:22 <watermind> `nand`: I guess that's a fair restriction
08:38:21 <`nand`> flip (bind . const); or flbico for short
08:39:39 <S11001001> I call *> "thenA", then
08:39:56 <S11001001> and <* is butFirstA
08:40:02 <catsbydlo> Athens
08:40:06 <S11001001> no, that's backwards
08:40:22 <S11001001> butLastA
08:41:22 <S11001001> @hoogle .>
08:41:22 <lambdabot> System.FilePath.Windows (<.>) :: FilePath -> String -> FilePath
08:41:22 <lambdabot> System.FilePath.Posix (<.>) :: FilePath -> String -> FilePath
08:41:23 <`ramses> those are too long-winded for my taste... I need to be able to quickly "pronounce" them in my head
08:41:32 <catsbydlo> :t liftA2 return
08:41:33 <lambdabot> Applicative f => f c -> f b -> f c
08:42:00 <catsbydlo> `ramses: the quickest method is not to pronounce them
08:42:03 <`nand`> I pronounce (>>) as “(>>)” in my head. I have no idea how I'd translate that into human speech, but that's how it's pronounced in my head
08:42:34 <`ramses> `nand`: huh, I can't imagine how that would work
08:42:44 <`ramses> catsbydlo: no, I can't relax that constraint :)
08:42:47 <`ramses> (yet)
08:42:53 <catsbydlo> you are not a modem
08:43:49 <S11001001> in your head the operator can be pronounced as the wind of a dark winter's night, howling through the narrow streets of the old city
08:44:19 <benj_> if I pronounce "butFirstA", I just think of "butt-first"
08:46:02 <`ramses> S11001001: do you have a poetic alternative for (>>=) as well then?
08:46:36 <S11001001> `ramses: no that has a perfectly good pronunciation already, "banana"
08:47:00 <catsbydlo> (>>=) is pronounced "swish", obviously
08:47:16 <`ramses> makes bind sounds so boring
08:47:22 <`ramses> s/sounds/sound
08:48:26 <S11001001> thus encouraging everyone to generalize their operations for applicative
08:51:01 <b_jonas> isn't (>>=) pronounced `bind' ?
08:51:56 <beaky> hello
08:52:05 <`ramses> b_jonas: usually yes :)
08:52:06 <beaky> how do I build a finite state machine in haskell?
08:52:09 <zomg> b_jonas: nah it's definitely 'swish' just like -> is 'the pointy thing'
08:52:35 <zomg> and <- is 'the reverse pointy thing'
08:52:36 <zomg> lol
08:52:48 <beaky> <- is monadic bind
08:52:48 <zomg> or was it the other way around...
08:53:01 <S11001001> b_jonas: boring, "banana" is much better
08:53:35 <scooty-puff> short of benchmarks or profiling, is there a good way to decide when {-# UNPACK #-} should be used?
08:53:42 <zomg> My favorite is still the boob operator (.)(.)
08:53:44 <scooty-puff> like a heuristic or something?
08:53:47 <beaky> lol
08:54:49 <scooty-puff> nm, the wiki page is extensive enough i thinkg
08:54:55 <`nand`> the breast operator goes (.).(.)
08:55:25 <zomg> `nand`: isn't that the total recall boob operator?
08:55:57 <merijn> zomg: No, that's (.).(.).(.)
08:56:12 <zomg> haha
08:56:27 <merijn> :t (.).(.).(.)
08:56:28 <lambdabot> (Functor f2, Functor f1, Functor f) => (a -> b) -> f (f1 (f2 a)) -> f (f1 (f2 b))
08:56:43 <Nereid> caleskell
08:56:50 <beaky> lol
08:57:29 <eatman> Hi. I'm looking for someone using the vim2hs plugin under vim. It's not working for me (:HLint works but i've no correct indentation).
08:57:48 <`nand`> :t over (mapped.mapped.mapped)
08:57:50 <lambdabot> (Functor f2, Functor f1, Functor f) => (a -> b) -> f (f1 (f2 a)) -> f (f1 (f2 b))
09:10:19 <flebron> Can I use pattern guards inside case statements?
09:10:25 <Philippa_> yes
09:10:42 <flebron> case foo of 2 => | a = b   | c = d ?
09:12:14 <ion> case foo of 2 | a -> b | c -> d
09:12:44 <parcs`> > case Nothing of Nothing | Nothing <- Nothing -> Nothing
09:12:45 <lambdabot>   Nothing
09:13:41 <`ramses> is there a way to specify default argument to ghc when using make? to not have to type them every time
09:13:58 <ion> Why not use cabal?
09:14:02 <`ramses> something like cflags for gcc
09:14:24 <`ramses> ion: because I have to learn that then... but maybe I should indeed
09:14:33 <ion> Cabal isn’t difficult.
09:14:39 <quicksilver> cflags isn't for gcc
09:14:59 <quicksilver> it's just a makefile convention - they're still explicitly passed to gcc by the makefile
09:15:12 <`ramses> quicksilver: right, forgot about that
09:15:16 <quicksilver> you can do the same thing with ghc in a makefile if you choose to
09:15:29 <quicksilver> however, cabal is proabbly better
09:15:36 <quicksilver> or LANGUAGE decls in the file themselves
09:15:40 <quicksilver> what options were you passing?
09:15:43 <parcs`> > case do Nothing of Nothing | !(~(do Just -> Just{})) <- do Nothing -> do Nothing where Nothing = Nothing
09:15:45 <lambdabot>   Nothing
09:15:58 <`ramses> outputdir and O2
09:19:09 <bgamari> parcs`, case do?
09:19:27 <int-e> bgamari: do Nothing === Nothing
09:19:34 <bgamari> ahh, yes
09:19:36 <elliott> do x === x
09:19:41 <elliott> > do 3
09:19:42 <lambdabot>   3
09:19:49 <bgamari> but why the do?
09:20:02 <bgamari> was this just an exercise in obfuscation?
09:20:15 <bgamari> I guess so
09:20:22 <int-e> > Nothing{}
09:20:24 <lambdabot>   Nothing
09:20:28 <parcs`> what else could it have been? :)
09:20:39 <bgamari> heh, fair enough
09:21:37 <int-e> > Just{}
09:21:39 <lambdabot>   Just *Exception: <interactive>:3:1-6: Missing field in record construction
09:21:40 <parcs`> it wasn't really obfuscation, more like a showcase of the regularity of haskell syntax
09:23:02 <quicksilver> > (const 4).Just{}
09:23:05 <lambdabot>   Just 4
09:23:37 * hackagebot gnuplot 0.5.1 - 2D and 3D plots using gnuplot  http://hackage.haskell.org/package/gnuplot-0.5.1 (HenningThielemann)
09:23:39 * hackagebot fsmActions 0.4.4 - Finite state machines and FSM actions  http://hackage.haskell.org/package/fsmActions-0.4.4 (AndyGimblett)
09:26:29 <wuttf> Guys quick question
09:26:42 <jerojasro> ...
09:26:47 <int-e> too slow.
09:26:52 <wuttf> I have a list, i want to convert to string all element of it and join it with (", ")
09:26:55 <jerojasro> .. o .. * ...
09:26:55 <wuttf> how can I do that?
09:26:56 <wuttf> :D
09:27:20 <otters> intercalate ", " . map show
09:27:21 <ParahSail1n> @ty intercalate
09:27:21 <int-e> @type intercalate ", " . map show
09:27:22 <lambdabot> [a] -> [[a]] -> [a]
09:27:23 <lambdabot> Show a => [a] -> [Char]
09:27:34 <wuttf> wow
09:27:41 <wuttf> checking out the docs for the intercalate thingie
09:27:52 <ski> > (){}:[]{}
09:27:53 <lambdabot>   [()]
09:28:04 <int-e> ski: right. ouch :)
09:28:19 <typoclass> wuttf: it's in Data.List if i remember correctly
09:28:22 <ski> > ([]){}
09:28:23 <lambdabot>   <hint>:1:5: Empty record update of: ([])
09:28:41 <shapr> ski: cute
09:29:25 <wuttf> typoclass: Thanks, found it.
09:30:25 <typoclass> > (){}
09:30:27 <lambdabot>   ()
09:30:46 <typoclass> > (()){}
09:30:47 <lambdabot>   <hint>:1:5: Empty record update of: (())
09:31:02 <typoclass> hm yeah. that makes it clear. or not
09:31:57 <ski> > that{}
09:31:58 <lambdabot>   <hint>:1:5: Empty record update of: that
09:32:10 <quicksilver> typoclass: the first one is a construction
09:32:15 <quicksilver> so it's not an empty record update
09:32:26 <`ramses> > (){}:[]{}>>(){}:[]{}>>=(\_->[()])
09:32:27 <quicksilver> with the extra () you've made it into an expression, not a constructor
09:32:28 <lambdabot>   [()]
09:32:34 <quicksilver> so it's an update-{} not a construct-{}
09:32:56 <quicksilver> as to why you should warn about one and not the other for a type with no fields? well, that's up to hint I guess ;)
09:32:59 <int-e> > let [] {} = [() {}] in [] {} == [() {}]
09:33:00 <lambdabot>   False
09:33:19 <typoclass> quicksilver: oh hm
09:33:37 * hackagebot hashable 1.2.0.1 - A class for types that can be converted to a hash value  http://hackage.haskell.org/package/hashable-1.2.0.1 (JohanTibell)
09:33:54 <typoclass> quicksilver: so corollary, for constructing i couldn't write (MyRecord) {field = initvalue}
09:34:12 <neutrino> int-e: why does that evaluate to false?
09:34:26 <wuttf> in "Learn you a haskell" there is a really short implementation of a binary tree, is that actual usable code which gives good results?
09:34:36 <wuttf> link coming
09:34:54 <int-e> neutrino: the binding [] = [()] is ignored completely
09:35:03 <wuttf> http://learnyouahaskell.com/making-our-own-types-and-typeclasses
09:35:05 <int-e> > let 23 = 42 in 23 == 42 -- same idea
09:35:06 <ski> > case[let{(){}=(){}where{}}in(){}]of[(){}]->(){}where{}
09:35:06 <lambdabot>   False
09:35:07 <lambdabot>   ()
09:35:23 <wuttf> > give-my-a-pony ;)
09:35:23 <neutrino> int-e: when does the binding [] = [()] happen?
09:35:26 <lambdabot>   <hint>:1:16: parse error on input `;'
09:35:32 <wuttf> me*
09:35:42 <int-e> neutrino: never. there's no value being bound, and the binding is lazy ...
09:35:57 <int-e> > let ![] = [()] in [] == [()]
09:35:58 <lambdabot>   *Exception: <interactive>:3:5-14: Non-exhaustive patterns in pattern binding
09:35:59 <neutrino> int-e: then why are you talking about such a binding if it does not happen?
09:36:01 <ski> > case [()] of ~[] -> ()
09:36:02 <lambdabot>   ()
09:36:06 <neutrino> int-e: i don't understand you.
09:36:09 <int-e> neutrino: for confusion
09:36:09 <quicksilver> typoclass: maybe not. Or maybe hint's parser is wrong.
09:36:10 <`ramses> wuttf: you mean the data definition?
09:36:21 <typoclass> quicksilver: k :)
09:36:23 <quicksilver> typoclass: you certainly can use parens in patterns...
09:36:27 <int-e> neutrino: all this {} stuff has been about misdiraction.
09:36:34 <int-e> ouch. misdirection.
09:36:39 <quicksilver> (patterns aren't quite the same as constructions, though)
09:36:42 <neutrino> int-e: can you give me an actual useful answer to my question?
09:36:59 <typoclass> int-e: if that helps, i certainly have misdirected myself with my earlier example ...
09:37:11 <int-e> neutrino: it's a pattern binding. no values are being bound. hence the binding has no effect.
09:37:12 <neutrino> ok this {} is just record constructor syntax right?
09:37:13 <Nereid> wuttf: should be =)
09:37:20 * ski . o O ( "misfermition" )
09:37:22 <int-e> neutrino: yes
09:37:25 <wuttf> `ramses: I dont get ya
09:37:28 <wuttf> wow
09:37:35 <glguy> neutrino: He has been answering your question. "[] {} == [() {}]" is "[] == [()]" is "False"
09:37:37 <wuttf> that's really concise, Nereid
09:37:39 <neutrino> why does [] = [()] get ignored?
09:37:53 <`ramses> wuttf: what exactely do you mean? which code exactely? you mean the data Tree = ... ?
09:37:56 <neutrino> glguy: yeah, it dawned on me :)
09:38:06 <neutrino> > let [] = [()] in []
09:38:06 <Nereid> `ramses: presumably together with the functions below it
09:38:07 <lambdabot>   []
09:38:10 <int-e> neutrino: because "let" binds lazily
09:38:11 <wuttf> `ramses: Yes, and also treeElem :: (Ord a) => a -> Tree a -> Boo
09:38:13 <neutrino> > let [] = [()] in [()]
09:38:14 <wuttf> etc
09:38:14 <lambdabot>   [()]
09:38:20 <neutrino> int-e: oh. what does that mean?
09:38:26 <neutrino> i don't know what lazy binding means
09:38:26 <glguy> neutrino: Your pattern doesn't name any variables, and you didn't use any of the variables that don't exist
09:38:38 <glguy> so the irrefutable pattern wasn't refuted
09:38:41 <int-e> neutrino: the pattern will only be matched when a variable occurring in the pattern is used.
09:38:48 <Nereid> neutrino: it doesn't try to match the pattern until the values of the variables are used.
09:38:50 <int-e> > let Just x = Nothing in [1,2,3,4,x]
09:38:51 <lambdabot>   [1,2,3,4,*Exception: <interactive>:3:5-20: Irrefutable pattern failed for p...
09:38:54 <Nereid> there are no variables, so it'll never try to match.
09:39:01 <wuttf> I am sorry to say that but seems like package system seems like a mess
09:39:01 <int-e> > let Just x = Nothing in [1,2,3,4]
09:39:02 <lambdabot>   [1,2,3,4]
09:39:21 <neutrino> int-e: which pattern exactly, the one between angle brackets here? let <[] = [()]> in [] == [()]
09:39:23 <`ramses> wuttf: I guess that code is fine... depends on what you'd want to do with it
09:39:30 <glguy> > let Just x = Nothing in  x `seq` [1,2,3,4]
09:39:32 <lambdabot>   *Exception: <interactive>:3:5-20: Irrefutable pattern failed for pattern Da...
09:39:44 <Nereid> > let !Just x = Nothing in [1,2,3,4]
09:39:46 <lambdabot>   <hint>:1:11: parse error on input `x'
09:39:49 <Nereid> er
09:39:50 <ski> wuttf : for good binary trees, you want some kind of balancing ..
09:39:54 <Nereid> > let !(Just x) = Nothing in [1,2,3,4]
09:39:56 <lambdabot>   *Exception: <interactive>:3:5-23: Non-exhaustive patterns in pattern binding
09:39:57 <wuttf> `ramses: Using it as my next Mongo killer nosql db index :D
09:40:02 <wuttf> `ramses: (joking)
09:40:23 <wuttf> ski: Yes, apart from that. I am a b+tree guy anyway ;)
09:40:24 <int-e> neutrino: let <binding: <pattern: []> = [()]> in <expression: [] == [()]>
09:40:52 <neutrino> int-e: gotcha
09:41:07 <neutrino> sooo... if we use [] in the expression, why is the pattern never matched?
09:41:17 <glguy> [] is a pattern, not a variable
09:41:21 <neutrino> i guess that's the counterintuitive part
09:41:22 <neutrino> right
09:41:26 <ski> neutrino : it it only matched when you force a variable occuring in the pattern
09:41:28 <Nereid> > let 2 = 3 in 2 + 2
09:41:30 <lambdabot>   4
09:41:31 <neutrino> and the pattern is empty
09:41:36 <neutrino> in that it doesn't mention any variables
09:41:42 <neutrino> that's why it is effectless
09:41:44 <neutrino> right?
09:41:46 <int-e> yes
09:41:47 <ski> > let x:xs = [] in 56
09:41:49 <lambdabot>   56
09:41:50 <ski> > let x:xs = [] in x
09:41:52 <lambdabot>   *Exception: <interactive>:3:5-13: Irrefutable pattern failed for pattern x ...
09:41:52 <Modius> In Emacs I have ghc-mod/haskell-mode working fine; but
09:41:52 <Modius>       I'm pretty sure HLint isn't being activated, even though I see
09:41:52 <Modius>       references to HLint from both.  Is there meant to be some way to
09:41:53 <Modius>       integrate hlint with GHC-Mod or activate it from there?  Or does
09:41:56 <Modius>       it require a distinct plugin?
09:42:02 <neutrino> > let Nothing = 2 in Nothing
09:42:03 <lambdabot>   No instance for (GHC.Num.Num (Data.Maybe.Maybe t0))
09:42:04 <lambdabot>    arising from the lit...
09:42:10 <ski> > let [] = [2,3] in 56
09:42:12 <lambdabot>   56
09:42:25 <neutrino> Nothing is a pattern which doesn't mention any variables. why do i get errors?
09:42:26 <int-e> neutrino: but even if there are variables, the effect will be delayed as much as possible - as ski just demonstrated.
09:42:27 <wuttf> Wha is more idiomatic: throwing an exception or returning a Maybe type?
09:42:28 <ski> > let Nothing = Just "no" in "yes"
09:42:28 <Nereid> neutrino: type checking isn't lazy, though. :p
09:42:32 <lambdabot>   "yes"
09:42:43 <Nereid> > let Nothing = Just 2 in Nothing
09:42:45 <lambdabot>   Nothing
09:43:00 <ski> > let x:xs = [] in [4,x]
09:43:00 <neutrino> wuttf: depends on whether your exception is exceptional and unexpected, or if it's for flow control.
09:43:01 <lambdabot>   [4,*Exception: <interactive>:3:5-13: Irrefutable pattern failed for pattern...
09:43:17 <int-e> neutrino: the code fails to compile - that's a different class of errors. the would-be pattern match failures are runtime errors.
09:43:17 <neutrino> wuttf: flow control is done with monads and functions.
09:43:26 <Nereid> neutrino: no.
09:43:28 <Nereid> :(
09:43:29 <neutrino> int-e: gotcha.
09:43:34 <Nereid> not monads.
09:43:34 <neutrino> Nereid: no what?
09:43:38 <monqy> wuttf: don't listen to neutrino
09:43:47 <monqy> neutrino: i'm sorry it's for the best
09:43:50 <Nereid> monads don't do anything.
09:44:07 <wuttf> neutrino Lets say I have a type which value should be bigger than 2 000 but lesser than 200 000
09:44:09 <neutrino> ok, if you have a different opinion that's good too
09:44:12 <glguy> wuttf:
09:44:22 <glguy> (didn't mean to press enter :) )
09:44:33 <neutrino> wuttf: you would encode that in the type system.
09:44:40 <Nereid> but you can't.
09:44:41 <neutrino> wuttf: instead of doing a runtime check.
09:44:44 <neutrino> sure you can
09:44:44 <wuttf> neutrino: WOW (? !)
09:44:57 <Nereid> how? make a type with 198001 construtors?
09:45:05 <Nereid> or 197999 maybe
09:45:13 <`ramses> wuttf: I'd make a newtype and give it a "smart constructor"
09:45:16 <glguy> or just a newtype with a hidden constructor
09:45:17 <Nereid> ^
09:45:28 <Nereid> http://www.haskell.org/haskellwiki/Smart_constructors
09:45:40 * wuttf is searching for the term "smart constructor"
09:45:50 <neutrino> value promotion, or zermelo
09:46:03 <wuttf> dohh, you are reading my mind
09:46:21 <Nereid> never mind the fact that the wiki example uses "error"
09:46:24 <Nereid> :(
09:46:35 <Nereid> 'error'
09:46:36 <typoclass> wuttf: i guess that's kind of a weakness in haskell's type system. i did sometimes want to do "Hour needs to be >= 0 and <= 23", but there was no good way as far as the type is concerned
09:46:39 <Nereid> @error@
09:46:40 <lambdabot> Unknown command, try @list
09:47:07 <neutrino> typoclass: but that's exactly why we're getting value promotion, isn't it?
09:47:11 <Nereid> no, it isn't
09:47:14 <`ramses> Nereid: how would you do the constructor without using error?
09:47:23 <Nereid> `ramses: change the return type to a Maybe
09:47:28 <typoclass> neutrino: who knows :-) i have little clue about the newfangle extensions
09:47:28 <eatman> Hi again. I'm looking for a "good" vim haskell indentation plugin. Do you have a name or a link for that please?
09:47:32 <`ramses> ah, ok :)
09:47:56 <`ramses> but then you'd had to eventually have a sane default to substitute for the bad input
09:48:03 <Nereid> value promotion is so that we can make types *parametrized* by integers, or strings,...
09:48:04 <wuttf> What happens if an assertion fail? Exception?
09:48:10 <Nereid> wuttf: yep
09:48:16 <`ramses> but agreed, even if you'd eventually call error it's better done outside the constructor
09:48:55 <Nereid> wuttf: but there are safer ways to handle things that would probably be preferable to that
09:48:58 <wuttf> I come from Go where there are multiple return values, one being error usually, thats why I thought about the Maybe
09:48:59 <Nereid> e.g. using Maybe
09:49:02 <neutrino> typoclass: even before type promotion, zermelo arithmetic was entirely possible
09:49:06 <neutrino> http://www.haskell.org/ghc/docs/7.4.2/html/users_guide/kind-polymorphism-and-promotion.html
09:49:09 <neutrino> see here
09:49:19 <silasdavis> Hello... I'd almost settled on using clojure and rather nice looking monger (http://clojuremongodb.info/) to build a mongodb-based message store
09:49:20 <typoclass> neutrino: yes, but inconvenient, wasn't it
09:49:23 <neutrino> look at how they define Nat just before 7.8.1
09:49:35 <Nereid> we still don't have operations on type-level nats
09:49:38 <neutrino> why was it inconvenient
09:49:43 * ski still thinks "kind polymorphism" is a misnomer
09:49:53 <silasdavis> I'm finding it hard to stop myself from using haskell, but it is a commercial setting, and I think clojure is going to be a bit too mental for most involved
09:50:04 <Nereid> "kind polymorphism" makes me think PolyKinds.
09:50:05 <silasdavis> does anyone have any experience with mongodb and haskell?
09:50:47 <neutrino> silasdavis: i have experience with mongodb, and with haskell, but not with both at once
09:51:10 <Nereid> anyway, I guess we'll be seeing proper type-level nat operations in the next ghc release?
09:51:22 <typoclass> neutrino: honestly, many of these things are over my head, but i did ask #haskell 2-3 times how to "tell the type system that this Int is 0-23", and the answer was "there's no simple good way, it's all a bit weird"
09:51:25 <ski> and `PolyKinds' makes me think about polymorphic kinds, i.e. kinds which can have many "kind types", and so are "typed" by a `forall kk. ..kk..' thing
09:51:32 <neutrino> i sure hope so Nereid
09:51:33 <Nereid> I mean the solver.
09:51:44 <Nereid> because we have the operations, we just can't do anything with them.
09:51:46 <ski> (which is not what `PolyKind' actually does)
09:51:57 <neutrino> typoclass: if "it's all a bit weird" put me off i'd have never started with haskell at all.
09:51:58 <wuttf> Ty for help, have a good night guys
09:52:03 <neutrino> nn
09:52:13 <Nereid> ski: but we have that. a PolyKinded class might have kind forall k. k -> Constraint
09:53:02 <ski> Nereid : but a class is a type, and a "PolyKinded class" is a polymorphic *type*
09:53:19 <Nereid> oh I see your point.
09:53:24 <hpaste> killy9999 pasted “TypeFamilies break ST monad” at http://hpaste.org/79199
09:53:47 <killy9999> can anyone tell me why this happens?
09:54:05 <ski> (just as `map' is a polymorphic value (but `forall a b. (a -> b) -> ([a] -> [b])' is not a polymorphic type))
09:54:30 <neutrino> ski: why is it not a polymorphic type?
09:54:31 <Nereid> killy9999: try using a let expression inside runST, instead of a where
09:54:35 <ski> (.. it is the *type* of a polymorphic value, aka a universal type)
09:54:50 <hpaste> killy9999 annotated “TypeFamilies break ST monad” with “TypeFamilies break ST monad (annotation)” at http://hpaste.org/79199#a79200
09:55:01 <ski> neutrino : because its kind is fixed, `*', it can't assume many different kinds
09:55:03 <killy9999> Nereid: OK
09:55:12 <neutrino> ski: oh, ok.
09:55:13 <elliott> Nereid: ghc 7.6 has some type-level nat stuff
09:55:14 <Nereid> killy9999: the where block can't have access to the ST state type, because of the scope of where.
09:55:29 <neutrino> ski: i'm still not fully sure how to recognize types. i guess it'll come with type.
09:55:32 <neutrino> err
09:55:33 <neutrino> with time, lol!
09:55:36 <Nereid> elliott: I know, but we don't have the constraint solver for it yet.
09:55:43 <elliott> Nereid: yeah
09:55:44 <Nereid> so it's basically useless.
09:55:56 <ski> (however `map' is polymorphic, since it can assume types `(Int -> Bool) -> ([Int] -> [Bool])',`(Map String Int -> IO ()) -> ([Map String Int] -> [IO ()])')
09:56:16 <Nereid> I'm not sure what a poly-kinded thing would look like, then.
09:56:18 <ski> neutrino : "recognize types" ?
09:56:38 <eatman> Can someone help me plz? I'm looking for a way to indent haskell code under Vim. Thx in advance.
09:56:55 <ski> Nereid : if we ever wanted to add another typing level above kinds, then we might perhaps want polymorphic kinds ..
09:57:02 <Nereid> heh
09:57:11 <elliott> when is GHC getting type family TypeEq (a :: k) (b :: k) :: Bool, anyway
09:57:17 <Nereid> I've sometimes wondered what it would mean to have an infinite hierarchy like that.
09:57:20 <elliott> that is a thing that was going to happen right
09:57:31 <killy9999> Nereid: you're right, this works. But why doesn't this happen when TypeFamilies are not enabled?
09:57:42 <Nereid> killy9999: hmm!
09:57:42 <ski> (but even if we don't, i think it's confusing to not use the terminology uniformly on the levels that we *do* have)
09:58:04 <eatman> Can someone help me plz? I'm looking for a way to indent haskell code under Vim. Thx in advance.
09:58:24 <Clint> :set expandtab
09:58:33 <eatman> this is done.
09:58:35 <Nereid> does TypeFamilies imply ScopedTypeVariables?
09:58:46 <Nereid> or something like that
09:58:59 <eatman> But it still breaks my "where" indentation
09:59:20 <killy9999> Nereid: frankly speaking I don't know
09:59:26 <glguy> eatman: after you expandtab, you still have to "retab" to replace existing tabs
09:59:27 <Nereid> I was asking everyone.
09:59:56 <ski> Nereid : not sure, but i'd wager "no"
10:00:05 <Nereid> yeah it doesn't look like it.
10:00:08 <eatman> But i'm speaking about something that can indent a full file, like in emacs
10:00:19 <eatman> (with the haskell mode)
10:00:26 <Nereid> and I'm not sure how that would explain killy9999's thing either.
10:00:35 * killy9999 is checking GHC docs
10:01:10 <watermind> so I was looking at these slides on the issue of CBN/CBV translations and static analysis http://www.slideshare.net/ilyasergey/static-analyses-and-code-optimizations-in-glasgow-haskell-compiler
10:01:43 <glguy> eatman: that probably doesn't exist
10:02:01 <eatman> Arg!!
10:02:02 <watermind> they have this example    f x e = if x>0 then x+1 else e   and claim it to be strict in x, for some convenient (non-explicit) definition of strictness for functions with multiple arguments
10:02:12 <killy9999> OK, I have no idea why this happens, but I'm glad there is a workaround
10:02:23 <watermind> now,   f undefined = \_ -> undefined   which is different from undefined
10:02:32 <eatman> I'll continue a bit before giving up...
10:03:05 <killy9999> I also noticed that if cabal file specifies TypeFamilies then it is impossible to override it on per-file basis uding NoTypeFamilies
10:03:06 <watermind> so I'm a bit at loss as to what the usual definition of strictness is
10:03:10 <flebron> Is there a built in f :: Bool -> Integer, f False = 0, f _ = 1?
10:03:25 <watermind> and how do you differentiate between strict in that sense ^   and strict in the sense that f x = undefined
10:03:37 <reactormonk> what's a "dual condition"?
10:03:39 <dcoutts> killy9999: you may want to use other-extensions: TypeFamilies
10:03:47 <watermind> as in  f x = if x > 0 then \e->x+1 else \e-> e
10:03:50 <dcoutts> killy9999: rather than default-extensions:
10:03:59 <ski> flebron : `fromEnum' ?
10:04:04 <watermind> which really is such that f undefined = undefined
10:04:11 <dcoutts> killy9999: default "applies" it to all the modules, rather than just saying "this package uses this extension"
10:04:13 <flebron> ski: Thanks!
10:04:25 <ski> flebron : actually, it gives `Int', not `Integer' ..
10:04:36 <flebron> close enough :p
10:04:36 <ski> so `fromIntegral . fromEnum', i suppose
10:05:12 <dcoutts> killy9999: note it's not specific to type families, ghc -XBlah overrides what is in the file in the LANGUAGE pragma.
10:06:18 <Nereid> reactormonk: where do you see that?
10:06:38 <Nereid> although a precise definition probably isn't needed
10:08:04 <flebron> Hrm. Say I have f :: b -> b -> c, g :: a -> b, h :: a -> b, and finally an x :: a. Is there a comfortable way of writing f(g(x), h(x))?
10:08:36 <flebron> (I was thinking something like uncurrying :s)
10:08:44 <Nereid> something like ap (f . g) h
10:08:46 <Nereid> @pl \f g x -> f (g x) (h x)
10:08:47 <lambdabot> flip flip h . liftM2
10:08:50 <Nereid> er
10:08:54 <Nereid> @pl \x -> f (g x) (h x)
10:08:54 <lambdabot> liftM2 f g h
10:08:58 <Nereid> or that :V
10:09:08 <Nereid> prefer liftA2
10:09:11 <flebron> God damnit how is what lambdabot is doing even computable
10:09:24 <Nereid> liftA2 makes perfect sense.
10:09:28 <flebron> It makes me feel like my brain could be replaced at any moment with a tiny Haskell script
10:09:31 <Nereid> :t liftA2
10:09:33 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
10:09:37 <Nereid> where f = (t ->)
10:09:49 <Nereid> @unpl ap (f . g) h x
10:09:50 <lambdabot> ((\ l -> f (g l)) >>= \ b -> h >>= \ a -> return (b a)) x
10:09:52 <Nereid> urgh
10:10:04 <Nereid> :t \f g x -> ap (f . g) h x
10:10:05 <lambdabot> (Show t, FromExpr a) => (a1 -> a -> b) -> (t -> a1) -> t -> b
10:10:09 <Nereid> :(
10:10:12 <Nereid> :t \f g h x -> ap (f . g) h x
10:10:14 <lambdabot> (a1 -> a -> b) -> (t -> a1) -> (t -> a) -> t -> b
10:10:25 <Nereid> so I was right, but liftA2 is better.
10:11:05 <Nereid> ... = ((f . g) <*> h) x = ((f <$> g) <*> h) x = liftA2 f g h x
10:11:05 <Nereid> duh
10:11:15 <parcs`> i think f (g x) (h x) is better
10:11:24 <Nereid> sure, but what if we don't like the point x?
10:11:37 <flebron> (I don't :p )
10:11:40 <beaky> hello
10:11:48 <beaky> can anyone explain recursion to me?
10:11:50 <Nereid> I should have thought of liftA2 the first time.
10:11:59 <Nereid> beaky: that's a pretty broad request
10:12:05 <Nereid> what about it needes explaining?
10:12:08 <parcs`> Nereid: then make yourself like it ;)
10:12:35 <beaky> so recursion is best vizualised as a stack structure
10:12:43 <S11001001> beaky: before answering, I have to ask: can you explain recursion to me?
10:12:43 <beaky> but then how do you vizualise tail recursion ina  stack
10:13:06 <flebron> specifically my code is this monster: http://hpaste.org/79201
10:13:12 <Nereid> beaky: by overwriting parts of the stack
10:13:15 <beaky> S11001001: recursion is when you have recurring instances of something within that thing
10:13:40 <S11001001> @src Mu
10:13:40 <lambdabot> newtype Mu f = In { out :: f (Mu f) }
10:13:44 <beaky> for example, in procedural languages you can call other subroutines inside a subroutine
10:13:53 <S11001001> don't exclude that from your model, beaky
10:13:56 <flebron> In C I'd have just added two bools :)
10:14:08 <Nereid> beaky: so are you wondering about tail recursion, or what?
10:14:11 <beaky> yes
10:14:55 <beaky> also you can define stuff in terms of a simpler version of itself, that's recursion
10:15:08 <`nand`> has_right :: BinarySearchTree a -> Bool -- smells like a bad design pattern to me
10:15:13 <`nand`> and I don't just mean the name (yuck)
10:16:20 <beaky> I like underscore names
10:16:30 <beaky> but in haskell they looks ugly for some reason
10:16:37 <Nereid> beaky: ok, well here's how I understand it:
10:16:39 <parcs`> flebron: Foreign.Marshal has 'fromBool :: Num a => Bool -> a'
10:16:58 <parcs`> flebron: but i would just do 'degree tree = (if has_left tree then 1 else 0) + (if has_right tree then 1 else 0)' *shrug*
10:17:02 <flebron> `nand: Why?
10:17:07 <flebron> `nand` *
10:17:28 <Nereid> say we have some stack frames A on top of B. if the return address of B is to another return instruction, then
10:17:42 <Nereid> er, B on top of A.
10:17:47 <Nereid> on returning from B, we would immediately return from A.
10:17:54 <elliott> parcs`: you can just use fromEnum
10:17:57 <`nand`> flebron: because you're using a Bool to convey the kind of information that seems more natural for a pattern match
10:17:58 <elliott> > fromEnum True + fromEnum False
10:17:59 <lambdabot>   1
10:18:03 <Nereid> so there's no point in actually hanging onto A, so
10:18:09 <elliott> degree tree = fromEnum (has_left tree) + fromEnum (has_right tree)
10:18:20 <Nereid> we may as well replace B's return address with A's return address, and remove A from the stack.
10:18:24 <flebron> `nand` that bool is indeed a pattern match, but I'm trying to hide the structure and use accessors
10:18:31 <elliott> (... or degree tree = (+) `on` fromEnum <$> fromEnum . has_left <*>
10:18:33 <elliott> er
10:18:34 <flebron> (When it makes sense, of course.)
10:18:37 <elliott> that got mangled :)
10:18:41 <elliott> but itw as not a serious suggestion anyway
10:18:48 <elliott> :t (+) `on` fromEnum <$> ?f <*> ?g
10:18:50 <lambdabot>     Couldn't match expected type `a0 -> c0' with actual type `Int'
10:18:50 <lambdabot>     Expected type: a1 -> a0 -> c0
10:18:50 <lambdabot>       Actual type: a1 -> Int
10:18:56 <`nand`> flebron: compare: “sum xs | length xs == 0 = 0 | otherwise = head xs + sum (tail xs)” vs “sum [] = 0; sum (x:xs) = x + sum xs”
10:18:58 <elliott> :t ((+) `on` fromEnum) <$> ?f <*> ?g
10:18:59 <lambdabot> (?f::f a, ?g::f a, Enum a, Applicative f) => f Int
10:19:03 <Nereid> beaky: so if all you have is some linear tail recursion, then the stack will stay a constant size.
10:19:15 <`nand`> the former does a lot of throwing around contextless booleans and using unsafe functions
10:19:18 <beaky> oh
10:19:58 <Nereid> except in haskell terms,
10:20:16 <`nand`> flebron: if you want to hide internal structure and abstract operations out into queries, view patterns could come in handy
10:20:19 <Nereid> I still prefer to think of haskell evaluation as something more like graph rewriting.
10:20:38 <Nereid> that is,
10:20:44 <`nand`> flebron: for example; Seq has some abstract internal structure; but you can pattern match on it using viewL :: Seq a -> ViewL a (or something like that)
10:21:08 <Nereid> whenever we are trying to evaluate f (...) = g (....)
10:21:13 <beaky> yes
10:21:16 <Nereid> we stop right there and replace f (...) with g (....)
10:21:27 <Nereid> and if f = g, then that's recursion.
10:21:30 <beaky> in haskell, computation is just plugging in numbers like in math
10:22:13 <Nereid> and we like to plug in things from the outside in.
10:22:23 <beaky> ah applicative evaluation order
10:22:24 <Nereid> because that's lazy evaluation
10:22:38 <beaky> does it even work for monads?
10:22:56 <Nereid> that question doesn't make sense, as monads don't actually do anything.
10:24:12 <tromp> monads are the glue that hold all computation together
10:24:18 <Nereid> no
10:24:29 <Nereid> monads are an abstraction of glue, perhaps.
10:25:09 <neutrino> ski: sorry i meant "recognize kinds", i guess i'm a bit tired!
10:25:15 <beaky> monad is like glue :D
10:25:31 <neutrino> yet another bad monad analogy?
10:25:50 <Nereid> glue is not as tasty as burritos.
10:25:57 <neutrino> depends who you ask
10:26:06 <tromp> glue sniffs better
10:26:11 <Nereid> :(
10:26:20 <tromp> high on monads...
10:27:07 <`nand`> neutrino: with DataKinds, things can be ambiguous between types and kinds ;)
10:27:26 <Nereid> not really
10:27:49 <Nereid> with DataKinds, a data declaration simultaneously defines a type and a kind. but their usages are distinguished syntactically
10:28:00 <`nand`> Nereid: without context
10:28:14 <Nereid> get more context!
10:29:23 <`nand`> something like ‘[(Bool, Foo)]’ could be either a type or a kind, conceivably
10:29:36 <killy9999> dcoutts: thanks. Actually I'd expect otherwise - that pragma in a file overrides global settings
10:30:11 <dcoutts> killy9999: from GHC's pov, the command line is where you override things
10:31:45 <glguy> flebron: The simplest change which would implement what `nand` is talking about is if you change the type from has_right :: BinarySearchTree a -> Bool to go_right :: BinarySearchTree a -> Maybe (BinarySearchTree a)
10:33:05 <`nand`> glguy: rather than provide go_right it would make much more sense to provide a traversal ‘right’ and then use Control.Lens.Zipper.down right
10:33:19 <`nand`> less code :)
10:33:25 <glguy> that wouldn't type-check
10:33:39 * hackagebot hashable 1.2.0.2 - A class for types that can be converted to a hash value  http://hackage.haskell.org/package/hashable-1.2.0.2 (JohanTibell)
10:34:06 <killy9999> dcoutts: makes sense
10:34:29 <`nand`> oh, it's no longer called ‘down’
10:34:41 <`nand`> it's ‘within’
10:34:47 <`nand`> or ‘downward’
10:34:57 <glguy> `nand`: no, down(ward) is not for traversals
10:35:20 <ski> neutrino : ok, np :)
10:35:22 <`nand`> yeah, I was mixing them up
10:35:27 <glguy> and within returns a maybe, anyway, since it checks for emptiness
10:35:33 <glguy> so we're back where we started
10:35:41 <`nand`> that was the point
10:38:35 <ski> beaky : "so recursion is best vizualised as a stack structure" -- think of it like this : it's not function calls that push stack frames; it's postponing stuff to do after function calls which pushes stack frames
10:39:21 <neutrino> ski: :)
10:39:50 <neutrino> xkb: hi, you're difficult to learn how to use
10:45:32 * neutrino has been having a hard time trying to hack his own xkb layout together.
10:48:39 * hackagebot heist 0.10.1 - An Haskell template system supporting both HTML5 and XML.  http://hackage.haskell.org/package/heist-0.10.1 (DougBeardsley)
10:48:41 * hackagebot esqueleto 1.0.1 - Bare bones, type-safe EDSL for SQL queries on persistent backends.  http://hackage.haskell.org/package/esqueleto-1.0.1 (FelipeLessa)
10:52:19 <ypo> Is there anyone that has an haskellwiki account and some time to mark several listings as incorrect?
11:05:12 <ion> Lens Gource 2012-12-14 http://youtu.be/ADAprOOgi-A?hd=1
11:08:49 <wereHamster> can I tell quickcheck to only try positive integers?
11:09:04 <wereHamster> or should I simply (abs x) the input in my test function?
11:09:07 <Cale> wereHamster: Yeah, use the Positive newtype, and pattern match against the constructor
11:09:19 <ion> wereHamster: prop_foo (Positive a) = a > 0
11:09:27 <Cale> http://hackage.haskell.org/packages/archive/QuickCheck/2.4.2/doc/html/Test-QuickCheck-Modifiers.html
11:09:27 <wereHamster> cool. neat
11:12:28 <wereHamster> and all my tests still work :)
11:13:38 <saml> hey, so I have a program. I execute it once. ./Foo; it halts few seconds later.  I execute it many times:  seq 100 | xargs -P100 ./Foo
11:13:58 <saml> I want all 100 ./Foo processes to be executed one at a time
11:14:01 <ion> The Show instance for Blind is misleading. :-P
11:14:03 <ion> @type (*)
11:14:05 <lambdabot> Num a => a -> a -> a
11:14:16 <saml> first process of ./Foo  finishes.. then second one continues.. etc
11:15:06 <scooty-puff> is case x of _ -> doStuffNonobviouslyStrictlyWithX x comparable to x `seq` ..., or does the case actually have to look at x?
11:15:42 <scooty-puff> i guess thats why bang patterns exist..
11:15:44 <scooty-puff> so nevermind
11:17:53 <glguy> scooty-puff:
11:17:53 <glguy> > case undefined of _ -> True
11:17:55 <lambdabot>   True
11:18:25 <scooty-puff> case undefined of !_ -> True
11:18:30 <scooty-puff> > case undefined of !_ -> True
11:18:32 <lambdabot>   *Exception: Prelude.undefined
11:18:35 <scooty-puff> yay
11:18:36 <scooty-puff> ok
11:19:49 <ericbmerritt> a quick question concerning test-framework and test-framework-quickcheck2. I have this all wired together and running beautifully from cabal. However, how do you get output (why the test failed) in the cast of failed tests.
11:20:00 <scooty-puff> when making a monad that is a newtype wrapper around StateT or WriterT (or another one with Strict and Lazy options), what criteria guide your decision (or strict or lazy)?
11:20:02 <ericbmerritt> I am pretty new to haskell and just working my way through this stuff
11:20:27 <scooty-puff> ericbmerritt: quick and inaccurate answer: check your dist/ directory
11:20:58 <otters> @pl \(a,b) c -> (a,c,b)
11:20:59 <lambdabot> uncurry (flip . (,,))
11:21:22 <ericbmerritt> scooty-puff: it contains the test log. but the test log contains but that only has the exact same information that was printed to the command line
11:26:15 <beaky> does haskell now have hashtables?
11:31:01 <ion> ಠ_ಠ
11:31:07 <ion> “now”?
11:31:22 <ion> When did you look the last time?
11:32:28 <Saizan> just not use Data.HashTable
11:32:38 <beaky> :(
11:34:08 <pmade> The only way to get an account on hackage is to send an email to Ross?
11:35:57 <Saizan> yep
11:36:08 <clahey> Saizan: What should we use then?
11:36:28 * pmade waits impatiently for Ross to respond...
11:36:38 <Saizan> (unless they fixed it when i wasn't looking)
11:39:18 <Saizan> clahey: hashtables the deprecation warning on Data.HashTable says
11:40:54 <clahey> I wonder if it would make sense to make a HashTable Monad Transformer or something like that.
11:41:09 <clahey> And HashTable Identity would be really slow due to all the copying and such.
11:41:15 <clahey> But HashTableT IO would be faster.
11:41:33 <clahey> I don't know if that actually makes sense though.
11:41:36 <shachaf> What does that mean?
11:41:43 <clahey> shachaf: I don't know.
11:41:47 <shachaf> What would the monad do?
11:41:48 <clahey> shachaf: I'm trying to figure it out.
11:41:54 <scooty-puff> HashTable Identity having a pure Ref impl?
11:42:07 <`nand`> HashTable is a monad?
11:42:12 <clahey> No.
11:42:17 <clahey> It's just an idea that went through my head.
11:42:19 <`nand`> then how would it be a monad transformer?
11:42:37 <scooty-puff> i could see HashTable IO, HashTable (ST s), HashTable (RefSupply s)
11:42:54 <scooty-puff> it would just stack on a MonadRef ref m
11:43:11 <scooty-puff> so i guess it wouldn't be a monad, maybe more like:
11:43:14 <clahey> And there would be put :: HashTable m () and get :: HashTable m a
11:43:38 <scooty-puff> newHashTable :: MonadRef ref m => m (HashTable ref)
11:44:11 <clahey> scooty-puff: Well, I was thinking that you would have the ability to have it be a pure monad where it just builds a new hash table each time.
11:45:27 <NoICE> hi, does anyone know how to check Socket status? (connected, etc.)?
11:45:28 <clahey> Or a version with a runHashTable parameter that gave you an IO m.
11:45:33 <scooty-puff> o right - that might be misleading - since the other nonpure ones would not - though this is (using MonadRef) just as misleading since one on a pure monad would trail/backtrack correctly, while the others wouldn't..
11:45:38 <NoICE> (Network.Socket.isConnected andthelike are broken)
11:46:33 <clahey> scooty-puff: I guess for the pure version I would want it to be very much like State HashTable.
11:47:09 <clahey> scooty-puff: And the IO version would be more like StateT (IORef HashTable) IO
11:47:20 <clahey> Well, not IORef HashTable.
11:47:26 <clahey> Some sort of modifying hash table.
11:47:49 <clahey> Oh, maybe it should be a typeclass.
11:49:21 <clahey> typeclass Monad m => Dictionary m where put :: k -> v -> Dictionary (); get :: k -> Dictionary v
11:49:54 <clahey> And then you could have IOHashTable which had a runHashTable function that returned an IO.
11:50:54 <clahey> And a MapDictionary instance.
11:51:40 <clahey> I'll have to try writing it up if I decide it's interesting enough.
12:02:16 <NoICE> can I query open Socket for it's status? isConnected returns status of MVar, not of the underlying file descriptor :(
12:05:05 <NoICE> when I do this by using System.Posix and ...IO library.. like this: (fdToHandle $ Fd $ fdSocket sock) >>= hIsReadable
12:05:26 <NoICE> it just crashes right away, because fdToHandle sets some properties on that file descriptor
12:05:43 <crdueck> what are ghc's rules for inlining? I reduced the runtime of a fairly simple program from 0.5s to 0.33s just by inlining every function. Some of them are one-liners with integer comparisions that I definitely thought would be inlined automatically
12:05:49 <NoICE> should I just use socketToHandle and deal with the handle the whole time?
12:06:12 <NoICE> crdueck: even with -O2 ?
12:06:17 <crdueck> NoICE: yes
12:06:39 <NoICE> I don't know the answer.. but it's interesting
12:09:43 <NoICE> ... well... I wondered why would anyone need to use socketToHandle, but now I know.
12:12:54 <romildo> Does any library define provides a function "for = flip map", that remembers the forM function?
12:14:21 <byorgey> romildo: Data.Traversable defines  for = flip traverse
12:14:25 <johnw`> in conduit, the type of a source MonadResource m => GSource m ByteString.  What is a common "m" for this type?
12:14:43 <byorgey> romildo: I don't know of anything that defines for = flip map
12:15:20 <shachaf> Traversable defines "for" with a different meaning.
12:15:29 <shachaf> (Same as forM, except for Applicative.)
12:15:50 <shachaf> for = flip traverse, I mean.
12:19:01 <byorgey> of course you can recover the mappish version using Identity
12:19:06 <aristid> :t for
12:19:07 <lambdabot>     Not in scope: `for'
12:19:07 <lambdabot>     Perhaps you meant one of these:
12:19:07 <lambdabot>       `Data.Traversable.for' (imported from Data.Traversable),
12:19:15 <aristid> :t Data.Traversable.for
12:19:16 <lambdabot> (Applicative f, Traversable t) => t a -> (a -> f b) -> f (t b)
12:19:50 <neutrino> if i start an action in async, and it never times out, how do i kill it?
12:20:37 <byorgey> :t \x f -> runIdentity $ Data.Traversable.for (Identity x) (Identity . f)   -- there's probably a better way to do this with lens...
12:20:38 <lambdabot> a -> (a -> b) -> Identity b
12:20:50 <byorgey> oh, wait, that's wrong
12:21:06 <byorgey> :t \x f -> runIdentity $ Data.Traversable.for x (Identity . f)   -- there's probably a better way to do this with lens...
12:21:08 <lambdabot> Traversable t => t a -> (a -> b) -> t b
12:21:43 <neutrino> when i exit the do block, the Async will be destroyed, will the thread it corresponds to be destroyed?
12:22:38 <neutrino> "using withAsync means we can avoid accidentally leaving threads running" ah
12:23:41 * hackagebot timeout-with-results 0.2 - Runs a time-limited computation alowing it to return intermediate results.  http://hackage.haskell.org/package/timeout-with-results-0.2 (PetrPudlak)
12:25:30 <neutrino> speak of the devil heheh
12:32:10 <elliott> byorgey: "over traverse"
12:32:12 <elliott> :t over traverse
12:32:13 <lambdabot> Traversable t => (a -> b) -> t a -> t b
12:32:22 <elliott> but that's just fmap :P
12:32:32 <byorgey> I knew it!
12:32:35 <byorgey> yes, that's the point
12:32:39 <elliott> since Functor is a superclass of Traversable, I believe
12:32:40 <pqmodn> is that Data.Function.over?
12:32:44 <byorgey> well, it's supposed to be flip fmap
12:32:47 <elliott> no it's Control.Lens.over
12:32:50 <pqmodn> er, nm. was thinking of 'on'
12:33:00 <elliott> you can do (over traverse ??) in git lens
12:33:01 <byorgey> elliott: it's fmap with a slightly more restrictive type.
12:33:05 <elliott> but that's just flip (over traverse)
12:33:07 <elliott> byorgey: right
12:34:18 <shachaf> elliott: git? I think you mean released?
12:34:26 <elliott> oh, did (??) get released
12:34:34 <shachaf> did it??
12:34:37 <shachaf> (Yes.)
12:35:09 <neutrino_> ok, back to my threading woes. i think i'll try implementing this stuff with async now.
12:35:49 <shachaf> @ty mapOf traverse
12:35:49 <neutrino_> quick question. is it advisable to write to the same file handle from two threads?
12:35:50 <lambdabot> Traversable t => (a -> b) -> t a -> t b
12:36:00 <shachaf> No deprecation warnings, lambdabot?
12:36:59 <neutrino_> i guess it works for stdout, but could something go wrong?
12:37:14 <c_wraith> well, sort of.
12:37:23 <neutrino_> c_wraith: explain please
12:37:25 <neutrino_> :)
12:37:27 <c_wraith> You'll never break the handle, or anything like that.
12:37:34 <neutrino_> but..?
12:37:39 <c_wraith> But you can end up interleaving data from each thread
12:37:47 <neutrino_> ah
12:37:49 <neutrino_> yeah that's fine
12:37:56 <neutrino_> it's in fact what i want
12:37:58 <c_wraith> each write system call is guaranteed to be atomic, at the os level
12:38:14 <neutrino_> is it?
12:38:18 <c_wraith> But there's no guarantee any particular higher-level function only calls write once
12:38:22 <neutrino_> where do we know that from?
12:38:31 <c_wraith> OS guarantees
12:38:36 <neutrino_> posix?
12:38:42 <neutrino_> i'm on posix
12:38:49 <c_wraith> I believe it is part of posix, yes
12:39:04 <neutrino_> what do you mean by the "but ..." part?
12:39:20 <neutrino_> why should we expect a specific function to execute write only once?
12:39:23 <neutrino_> oh
12:39:39 <neutrino_> so you mean i can't expect writing to happen in contiguous blocks if i e.g. do hPutLine?
12:39:42 <c_wraith> yes
12:39:46 <neutrino_> oh yeah
12:39:56 <neutrino_> i can see how that could be a problem in some situations
12:40:02 <neutrino_> except here i'm writing char by char anyways
12:40:02 <pqmodn> neutrino_: write (2) man page says not all filesystems are POSIX compliant. i'm not sure which though
12:40:04 <neutrino_> so it's ok
12:40:35 <neutrino_> pqmodn: nfs
12:40:49 <pqmodn> ah, yeah
12:40:57 <neutrino_> if someone says "not all filesystems" they always mean nfs.
12:41:01 <c_wraith> In fact, I think I've seen evidence that hPutStrLn issues a write per character in some situations.
12:41:15 <neutrino_> right it was hPutStrLn not hPutLine
12:41:17 <neutrino_> thanks
12:41:29 <neutrino_> why would it do that c_wraith?
12:41:36 <neutrino_> that's fairly unperformant
12:41:44 <c_wraith> because [Char] isn't guaranteed to be finite
12:41:55 <c_wraith> I'd still think it could buffer, and maybe things have changed.
12:42:23 <c_wraith> But I know I've seen the occasional crazy interleaving that you'd expect from character-at-a-time writes.
12:43:03 <neutrino_> it's probably better if it's always broken than if it's sometimes broken.
12:43:47 <c_wraith> I guess trying to buffer could be bad it the string was the result of lazy IO
12:43:51 <c_wraith> and you wanted to stream
12:44:00 <c_wraith> but the input was coming in slowly
12:44:12 <c_wraith> Chunking would introduce extra latency in that case
12:48:17 <johnw``> in a ByteString conduit sink, can I "drain" all the data from the source, and then return a result value from my sink?
12:48:42 * hackagebot youtube 0.1 - Upload video to YouTube via YouTube API  http://hackage.haskell.org/package/youtube-0.1 (HenningThielemann)
12:49:06 <Clint> johnw``: you want to do what?
12:49:16 <johnw``> oh, never mind
12:49:20 <johnw``> i was fusing two ideas
12:49:21 <c_wraith> johnw``: are you asking if you can detect when there's no more data?
12:49:23 <johnw``> I just needed this:
12:49:25 <neutrino_> johnw``: i think you can..
12:49:30 <johnw``> str <- mySource $$ await
12:49:37 <johnw``> myFunction <$> str
12:49:49 <neutrino_> c_wraith: he wants to process all data in the sink and have the sink return some stuff.
12:49:57 <johnw``> i was trying to make the "await" in that code "do more stuff"
12:50:02 <johnw``> but now I realize that it's outside the scope of the sink
12:50:21 <Clint> Data.Conduit.List.map myFunction $$ Data.Conduit.List.consume ?
12:50:36 <johnw``> i'm dealing with a ByteString, not a list, though
12:50:53 <johnw``> essentially I want this: you can hand me a ByteString, or a ByteString source
12:50:57 <neutrino_> hey, when i create an MVar, do i have to later destroy it somehow, to prevent leaking?
12:50:59 <johnw``> either way, I need the whole ByteString
12:51:08 <johnw``> neutrino_: it will be garbage collected
12:51:10 <c_wraith> neutrino_: no, the garbage collector handles that just fine
12:51:20 <neutrino_> ok
12:51:55 <neutrino_> i think i have figured out how to do this stuff well.. learning threading in haskell was a bit scary
12:52:20 <neutrino_> now it's time to try and do it :)
12:53:07 <neutrino_> not sure who told me about the async package first, but they did me a good service :)
12:53:08 <c_wraith> haskell threading is easy, compared to posix or java threading... :P
12:53:35 <tac> It's hard in the sense that there's no canonical way to do it
12:53:47 <tac> You can STM, you can message pass, you can do it the old fashioned way
12:53:52 <tac> You can mix them all together.
12:54:18 <neutrino_> it's just hard to get your head around it :)
12:54:24 <tac> It's not very opinionated on the subject, which is a disadvantage for beginners
12:54:40 <neutrino_> probably exactly because there are so many options
12:54:53 <neutrino_> and all of them seem good but have subtly different applications
12:55:21 <neutrino_> and then there are surprises, like forkIO leaking threads and whatnot
12:55:51 <NemesisD> anyone familiar with the 'errors' package? i'm trying to figure out something similar to the Script monad except with custom defined error handling behavior
12:57:55 <NemesisD> better phrasing: how can I abort an IO monad early?
12:58:17 <c_wraith> exactly the way Script does...  Wrap it in a transformer that supports shortcut evaluation
12:59:41 <neutrino_> NemesisD: fork it, and use async to time it out
12:59:58 <NemesisD> c_wraith: do you have a suggestion for that transformer? Script calls exitFailure
13:00:59 <c_wraith> It's just using some sort of EitherT
13:05:16 <neutrino_> NemesisD: note what they say about the "implementation detail" here: http://hackage.haskell.org/packages/archive/base/4.1.0.0/doc/html/System-Timeout.html
13:05:18 <NemesisD> i'm a bit confused, basically I have a function that does a bunch of IO actions, several of which may throw exceptions. I like that Script catches exceptions and turns them to eithers, but I don't like that it chooses how to display the error and that its ok to call exitFailure
13:09:54 <NemesisD> hmm i think i have it
13:10:53 <NemesisD> the tricky part is that you need to get all failures in your runEitherT to the same type of failure (Either failure a), so if part of  the code throws an exception and part of it returns a Left, you have to coerce them both into whatever failure is
13:11:51 <NoICE> damn.. I rewrote whole project to use Handle instead of Socket in hope hIsReadable will return correct results when the server closes the connection.. but as it seems, the socket is still in CLOSE_WAIT state and client doesn't care until I perform some reading/writing from/to handle :/
13:13:06 <pqmodn> NoICE: perhaps hIsReadable is only reporting the mode of the handle (eg, you opened it for reading)?
13:13:25 <elliott> Cale: @check is broken :(
13:13:33 <pqmodn> nm, the source contradicts that
13:14:23 <NoICE> pqmodn: no.. maybe I need something like hIsClosing, but that doesn't exist
13:15:04 <NoICE> (btw Network.Socket.isReadable returns state of MVar.. and the docs says that Network.Socket is lower-level than Network :) )
13:15:38 <catsbydlo> NoICE: yes, that's how it's supposed to work
13:16:09 <NoICE> catsbydlo: hi again, I had to go before
13:17:06 <NoICE> catsbydlo: what I'm trying to achieve is situation when server disconnects.. and I can't find any way to find that out.. maybe I'll just need to rely on exception thrown on reading/writing.. :(
13:17:26 <NoICE> .. and I'm trying to achieve respawning of the connection after some timeout
13:17:28 <catsbydlo> yes
13:17:32 <neutrino_> when does a thread get garbage collected?
13:17:45 <catsbydlo> reading from a socket whose write end is closed gives you EOF
13:17:47 <neutrino_> when the IO action it was performing is complete?
13:18:14 <catsbydlo> writing to a socket whose read end is closed throws EPIPE
13:18:43 <NoICE> catsbydlo: so.. there really isn't any way to find that out before I call recv/send (hGetChar/hPutStr)?
13:19:08 <catsbydlo> correct, if by recv/send you mean read/write
13:19:43 <NoICE> recv and send are functions in Network.Socked I used before switching to Handle
13:19:49 <NoICE> Socket*
13:19:54 <catsbydlo> oh, I see
13:20:16 <NoICE> (and I still don't know whats considered "better".. to use Socket or Handle)
13:20:52 <hpc> you want Handle until you have specific reason to go Socket
13:21:43 <catsbydlo> I like Network.Socket.ByteString
13:21:48 <NoICE> well.. the first one would be performance.. as I can't find any hGetStr :: IO ByteString
13:22:01 <catsbydlo> actually, I like file descriptors even better
13:22:39 <Cale> elliott: I know, but I don't know what's wrong with it
13:22:47 <NoICE> catsbydlo: I tried to achieve that "realtime socket status"-getting by using fdToHandle $ fdSocket sock .. and using hIsClosed .. but fdToHandle did some magic on that FD so it breaks
13:22:49 <elliott> @check id
13:22:50 <lambdabot>   Not in scope: `myquickcheck'
13:22:51 <hpc> hGetStr is not a performance thing, it is a lazy semantics thing
13:23:01 <elliott> Cale: does grep myquickcheck give any enlightenment?
13:23:13 <NoICE> hpc: I meant mainly the ByteString instead of String thing
13:23:18 <hpc> ah
13:23:37 <hpc> @hoogle Handle -> IO ByteString
13:23:38 <lambdabot> Data.ByteString.Lazy hGetContents :: Handle -> IO ByteString
13:23:38 <lambdabot> Data.ByteString.Lazy.Char8 hGetContents :: Handle -> IO ByteString
13:23:38 <lambdabot> Data.ByteString hGetContents :: Handle -> IO ByteString
13:23:41 <catsbydlo> NoICE: there is no socket status
13:23:56 <hpc> NoICE: er
13:24:03 <NoICE> hpc: huh :) thx
13:24:07 <hpc> read hGetStr as hGetContents
13:24:17 <hpc> ignore my 2nd to last comment
13:24:26 <hpc> :)
13:24:31 <NoICE> hh :)
13:25:11 <NoICE> catsbydlo: there isn't any way to get that "close_wait" status lsof is showing me? :)
13:26:25 <NoICE> well.. I spent few hours today fighting against this whole giant thing.. and all that just because I need to do some respawning :D
13:28:00 <tomeo> Is it possible writing a function like f xs = [g x | x <- xs] but without having the xs as a parameter on the left side of the equals side?
13:28:06 <NoICE> I wanted to get something like "socket status" so I can manage threads.. kill them, reconnect them.. right now the reader thread throws exception (ok..), but writer thread is unaware of this situation, because it just reads from mysql and finds out that nothing is to be done.. (so it sleeps and loops)
13:28:22 <tomeo> Kind of like how f x = 1 + x can be f = (1+)
13:28:31 <elliott> NoICE: you can throw an exception in another thread fwiw
13:28:34 <elliott> if that would help
13:29:17 <NoICE> elliott: something like: readerThread: "Hey dude, that socket you saw last second? Vanished. Go kill yourself." ? :D
13:29:30 <joeyh> tomeo: f = map g
13:30:03 <NoICE> elliott: throwTo ?
13:30:12 <elliott> NoICE: yes. or just use killThread
13:30:32 <NoICE> elliott: killing that thread would be harsh.. it does some DB stuff
13:30:47 <tomeo> joeyh: sorry, I meant using a list comprehension, not that exact function :)
13:30:55 <NoICE> elliott: but thanks, I'll maybe use exceptions for this task
13:31:20 <elliott> right
13:31:35 <elliott> NoICE: you can also use STM channels quite nicely for things like this
13:31:36 <joeyh> I doubt that list comprehensions can be curried, but I'm sure you can rewrite any function using list comprehensions to one that does not, and can then probably be curried
13:31:40 <elliott> but it'll require some more tweaking
13:32:12 <NoICE> catsbydlo: elliott: another approach I'm considering is one reader + writer thread for doing socket stuff and channels to broadcast that read info to reader and writer threads
13:32:24 <NoICE> elliott: yup, something like that
13:32:36 <elliott> yeah if you did TChan then you can do things like
13:32:50 <elliott> foo <- (Just <$> readTChan stuff) <|> (Nothing <$ readTChan quits)
13:32:55 <NoICE> that would be far better for this whole thing, but I didn't use STM or channels yet :(
13:32:55 <elliott> and if foo is Nothing then you quit
13:33:11 <NemesisD> c_wraith: i'm trying to figure out how I can get tryIO to catch all errors, not just IOException
13:33:16 <elliott> STM channels are actually super easy to use (so are regular channels but you can't do the (<|>) stuff)
13:33:38 <`ramses> tomeo: f = \xs ->  [g x | x <- xs]
13:34:03 <NemesisD> c_wraith: tryIO :: (MonadIO m) => IO a -> EitherT IOException m a; tryIO = EitherT . liftIO . try, but if I have parse exceptions from another library within IO, they breeze right past and crash the thread
13:34:05 <`ramses> but you don't really gain anything that way
13:34:44 <aavogt> `ramses: and you might lose against the monomorphism restriction
13:35:04 <NoICE> elliott: so my reader/writer threads would be kept alive no-matter-what (well, they would broke on DB disconnect, but that's different story), and they would just read/write data to TChan?
13:35:21 <elliott> NoICE: yes, that could work. if you don't need what you originally needed throwTo then you can even use plain Chans and skip STM entirely
13:35:24 <elliott> which is often faster
13:35:30 <NoICE> and another thread would read/write data from/to socket and forward them to TChan?
13:35:37 <c_wraith> NemesisD: all you have to do is change the type signature to ... -> EitherT ExceptionTypeYouWantToCatch ...
13:36:01 <NoICE> elliott: mmm interesting
13:36:08 <c_wraith> NemesisD: if you really want to catch *all* errors, which might be dangerous, you can change it to SomeException
13:38:09 <NemesisD> c_wraith: i need to catch them because this thread loops indefinitely, if one iteration errors, i want to log it to the error log, but I can't afford to crash the thread
13:38:51 <c_wraith> That's probably fine. But certain error conditions you aren't expected to be able to recover from. Those will put you in a strange state if you try to catch them.
13:39:07 <NemesisD> c_wraith: like what?
13:40:15 <c_wraith> running out of various resources, primarily. Things like running out of memory, if you've capped the heap size
13:41:25 <NemesisD> c_wraith: i guess i wouldn't want to catch those, my problem is that  with all the safety the compiler gives me, i hate knowing that at runtime, if some library author throws something, my program dies
13:42:08 <NemesisD> it doesn't jive with my warm fuzzy feeling I get from haskell's type safety
13:42:13 <c_wraith> yeah, just catch everything, then let the program crash if the handler throws an exception too
13:42:35 <NemesisD> i'm ok with that
13:43:33 <NemesisD> im making an effort in programs I write now to confront exceptions from their source, and making sure I don't use them directly. they do not fit with what I expect from the language
13:54:50 <NoICE> elliott: I just discovered out of curiosity that calling hIsClosed blocks :D
13:54:57 <elliott> mm
13:55:34 <dmwit> Huh. What ends the blocking?
13:56:00 <NoICE> dunno.. and I can't discover that, since my writing thread is being blocked :D
13:56:10 <NoICE> (and server sends nothing, since it waits for some input)
14:04:19 <tomeo> Could someone please tell me what Im missing? Shouldn't g' f = f ((/3).f) be equivalent to g f x = f ((f x)/3) ?
14:04:53 <flebron> I don't know why it would (I'm also a newbie).
14:05:07 <flebron> The way I'd parse g' f x would be (f ((/3) . f)) x.
14:05:35 <flebron> That is, the inner expression is giving ((/3) . f) as an argument to f, and then applying the result to x.
14:05:38 <johnw``> how do I wrap an arbitrary Storable value a into a Ptr to that stored value Ptr a?  That is, I have a Haskell value, and I want to pass a pointer to that value to a C function (where I know the value will not be referenced beyond the call)
14:06:02 <rwbarton> @type alloca
14:06:04 <lambdabot> Not in scope: `alloca'
14:06:07 <johnw``> aha
14:06:07 <rwbarton> @hoogle alloca
14:06:07 <lambdabot> Foreign.Marshal.Alloc alloca :: Storable a => (Ptr a -> IO b) -> IO b
14:06:07 <lambdabot> Foreign.Marshal.Array allocaArray :: Storable a => Int -> (Ptr a -> IO b) -> IO b
14:06:08 <lambdabot> Foreign.Marshal.Array allocaArray0 :: Storable a => Int -> (Ptr a -> IO b) -> IO b
14:06:20 <johnw``> alloca + poke?+
14:06:23 <rwbarton> hm
14:06:30 <rwbarton> probably there is a handy utility for that
14:06:55 <rwbarton> @hoogle with
14:06:56 <lambdabot> Foreign.Marshal.Utils with :: Storable a => a -> (Ptr a -> IO b) -> IO b
14:06:56 <lambdabot> System.Environment withArgs :: [String] -> IO a -> IO a
14:06:56 <lambdabot> Foreign.Marshal.Array withArray :: Storable a => [a] -> (Ptr a -> IO b) -> IO b
14:07:26 <johnw``> nice, that's exactly what I needed, thanks
14:07:27 <rwbarton> indeed it is just alloca + poke
14:07:32 <johnw``> it even mentions alloca + poke :)
14:10:59 <dmwit> tomeo: No, g' f = f ((/3) . f) is equivalent to g f x = f ((/3) . f) x
14:11:43 <dmwit> ...which hands ((/3) . f) to f as its first argument and x as its second argument.
14:12:13 <dmwit> ?pl \x -> f ((f x)/3)
14:12:14 <lambdabot> f . (/ 3) . f
14:17:23 <NoICE> elliott: well, refactoring to TChan begun :D
14:17:53 <NoICE> elliott: I thought about it and it will solve my other problem - that now I can put back to queue data read from socket, when DB is unavailable for example
14:17:58 <elliott> mm
14:18:46 <NoICE> (and hence I need to use TChan instead of Chan, Chan has deprecated "unGetChan")
14:20:36 <NoICE> elliott: I just discovered this: http://hackage.haskell.org/packages/archive/stm/2.4.2/doc/html/Control-Concurrent-STM-TQueue.html
14:21:18 <elliott> huh, is that new?
14:21:21 <elliott> I don't think I've ever used TQueues
14:21:43 <NoICE> "added in version 2.4"
14:21:46 <NoICE> (http://hackage.haskell.org/package/stm-2.4.2)
14:21:55 <elliott> so 2012 new, ok good :)
14:22:24 <NoICE> now I don't know what to use :D
14:22:28 <NoICE> so many choices! :D
14:23:38 <NoICE> elliott: so.. what I am doing right now (converting the whole thing to TChan/TQueue).. is practically converting the app to use message passing :D
14:24:06 * elliott would consider STM more powerful than just plain message passing :)
14:24:34 <NoICE> :)
14:25:41 <NoICE> elliott: I'm kinda new to the whole STM thing, I've read few articles about it, watched some speaks.. but never used it.. but I'm sure my mind will be blown away when I'll discover it's full potential :)
14:27:42 <tomeo> thanks dmwit
14:33:44 * hackagebot youtube 0.2 - Upload video to YouTube via YouTube API  http://hackage.haskell.org/package/youtube-0.2 (HenningThielemann)
14:39:11 <beaky> @pl \x -> y `rem` x == 0
14:39:12 <lambdabot> (0 ==) . (y `rem`)
14:39:36 <beaky> @pl \x -> rem y x == 0
14:39:36 <lambdabot> (0 ==) . rem y
14:42:17 <beaky> http://ideone.com/jrtgQY anyone know of a shorter fizzbuzz solution?
14:44:07 <simpson> Why do you want it to be shorter?
14:44:22 <tac> golf is fun, simpson
14:45:14 <beaky> yes
14:45:37 <Ralith> @pl f n|g 3&&g 5="FizzBuzz"|g 3="Fizz"|g 5="Buzz"|True=show n where g=(0 ==).rem n
14:45:37 <lambdabot> (line 1, column 14):
14:45:38 <lambdabot> unexpected "\""
14:45:38 <lambdabot> expecting operator
14:45:40 <Ralith> aw
14:46:39 <beaky> @pl [max(show x)(concat[n|(f,n)<-[(3,"Fizz"),(5,"Buzz")],mod x f==0])|x<-[1..100]]
14:46:40 <lambdabot> [max (show x) (join [n | (f, n) <- [(3, "Fizz"), (5, "Buzz")], mod x f == 0]) | x <- [1..100]]
14:46:43 <beaky> lol
14:46:49 <beaky> > [max(show x)(concat[n|(f,n)<-[(3,"Fizz"),(5,"Buzz")],mod x f==0])|x<-[1..100]]
14:46:51 <lambdabot>   ["1","2","Fizz","4","Buzz","Fizz","7","8","Fizz","Buzz","11","Fizz","13","1...
14:47:49 <koala_man> nice
14:47:49 <`nand`> > [fromMaybe (show x) $ ["fizz"|x`rem`3==0]<>["buzz"|x`rem`5==0])|x<-[1..100]]
14:47:51 <lambdabot>   <hint>:1:63: parse error on input `)'
14:47:55 <Hafydd> beaky: 5|n && 3|n  <==> 15|n
14:48:03 <beaky> :D
14:48:05 <koala_man> or horrible, I'm not sure
14:48:12 <`nand`> > [fromMaybe(show x)$["fizz"|x`rem`3==0]<>["buzz"|x`rem`5==0]|x<-[1..100]]
14:48:13 <lambdabot>   Couldn't match expected type `Data.Maybe.Maybe GHC.Base.String'
14:48:13 <lambdabot>            ...
14:48:18 <`nand`> :(
14:48:42 <beaky> https://www.hackerrank.com/fizzbuzz/challenges/fizzbuzz
14:48:50 <`nand`> oh
14:48:52 <beaky> the best solution is perl lets beat it!
14:48:53 <`nand`> needs MonadComprehensions
14:49:17 <Canar> wow
14:49:24 <Canar> what a terribly designed site
14:49:32 <Canar> displays nothing without javascript
14:50:23 <beaky> few sites these days display anything without js :(
14:50:29 <niteria> :t <>
14:50:30 <lambdabot> parse error on input `<>'
14:50:32 <niteria> :t (<>)
14:50:33 <lambdabot> Monoid m => m -> m -> m
14:50:34 <Canar> you go to weird places online beaky x.x
14:50:35 <beaky> so I can't browse the web with links and stuff
14:51:59 <`nand`> Cale: Can we have MonadComprehensions in lambdabot? :)
14:56:31 <lpsmith> Is it possible to include a png image in haddocks?
14:56:48 <startling> lens does something
14:57:09 <startling> <<http://i.imgur.com/FgfVW.png>>
14:57:26 <lpsmith> startling, thanks
14:57:36 <Hermit> without using unsafePerformIO, how can I do something like find IO_Bool .. using existing combinators?
14:57:54 <startling> Hermit: what does "find IO_Bool" do?
14:58:16 <Hermit> IO_Bool is a function that returns IO Bool, looks like the notation was not clear
14:58:35 <startling> what does "find" do?
14:58:35 <DrChaos_> how do you write the sum function in a recursive way?
14:58:46 <startling> DrChaos_, summing a list?
14:58:46 <`nand`> IO_Bool would be a constructor
14:58:48 <mikeplus64> @src sum
14:58:49 <lambdabot> sum = foldl (+) 0
14:58:49 <S11001001> Hermit: you mean Monad m => (a -> m b) -> [a] -> m (Maybe b)?
14:59:05 <Hermit> S11001001: yeah
14:59:08 <mikeplus64> DrChaos_: sum [] = 0; sum (x:xs) = x + sum xs
14:59:27 <Hermit> startling: tries strings on a command and returns True or False deppending on it's output
15:00:00 <startling> Hermit, what's a a command?
15:00:15 <Hermit> startling: shell/system command... r
15:00:25 <startling> ah
15:00:57 <DrChaos_> wow, how did you figure that out? I'm not used to recursive programming
15:01:31 <S11001001> Hermit: huh, I don't see it
15:01:36 <S11001001> (Maybe missing there)
15:02:02 <startling> Hermit: why don't you give us type signatures for "find" and "IO_Bool"?
15:02:08 <Hermit> `nand`: noticed it... I wanted to indicate the return type of that fn.
15:02:28 <catsbydlo> :t find
15:02:29 <lambdabot> (a -> Bool) -> [a] -> Maybe a
15:02:30 <S11001001> Monad m => (a -> m (Maybe b)) -> [a] -> m (Maybe b)
15:02:44 <Hermit> startling: IO_Bool :: String -> IO Bool
15:02:53 <alec> is there an easier language i can use to learn pure FP than haskell?
15:02:57 <alec> and then graduate to haskell?
15:03:00 <catsbydlo> Hermit: that's not a valid name
15:03:09 <`nand`> alec: you could start with the lambda calculus or something
15:03:14 <catsbydlo> haha
15:03:17 <alec> lol
15:03:20 <S11001001> alec: or the little mler
15:03:25 <alec> ah
15:03:26 <`nand`> I was being serious
15:03:33 <`nand`> it's the embodiment of pure functional programming
15:03:37 <`nand`> and fairly simple
15:03:41 <Hermit> catsbydlo: why is something hypothetic taken so seriously, I f*** know it would be a constructor by the name...
15:03:44 <alec> unless there's some kind of lambda calc interpreter i won't know if i'm fucking things up
15:03:58 <alec> i should try the little ml'er though
15:04:01 <alec> that sounds like an idea
15:04:02 <simpson> alec: What do you mean by "pure FP"?
15:04:09 <`nand`> Hermit: we can't help you unless you tell us what it is you want to accomplish
15:04:14 <c_wraith> alec: you could try helium. It's basically haskell, except stripped down to make it easier to teach with.
15:04:14 <alec> no side effect
15:04:20 <beaky> ye
15:04:28 <alec> c_wraith, thanks, that also sounds good
15:04:34 <mikeplus64> Hermit: look at System.Process, it has a bunch of things that take strings and produce an ExitStatus
15:04:40 <startling> Hermit, capital letters denote constructors. How were we supposed to know what your made-up syntax meant?
15:05:12 <mikeplus64> oops, i mean ExitCode
15:05:27 <`nand`> helium looks interesting
15:05:44 <catsbydlo> Hermit: oh sorry, I thought you were serious
15:05:45 <simpson> alec: Haskell doesn't have side effects. What are you using to learn?
15:05:51 <pqmodn> no type classes, iirc
15:06:00 <`nand`> is it a proper subset of Haskell? ie. is any valid helium program also a valid haskell program?
15:06:01 <S11001001> Hermit: if you add ifM :: Monad m => m Bool -> m a -> m a -> m a, findM becomes a nice foldr
15:06:03 <Hermit> ok, I'll reword the whole thing: tryString :: String -> IO Bool,  strings :: [Strings].  What I want:  find tryString strings   (I can do it with find (unsafePerformIO . tryString) strings but I want to do it clean)
15:06:10 <c_wraith> yeah, type classes are the big thing helium leaves out.
15:06:20 <Hermit> `nand`: ^
15:06:32 <c_wraith> `nand`: don't know if it's a proper subset
15:06:43 <alec> simpson, i want to learn haskell but i need to get my head around FP with a more restricted language
15:06:47 <alec> helium sounds like it might work
15:07:02 <`nand`> Hermit: ah; so you want findM :: Monad m => (a -> m Bool) -> [a] -> m (Maybe a) ?
15:07:05 <simpson> alec: I don't understand your motivation. Good luck.
15:07:05 <catsbydlo> alec: why not haskell?
15:07:17 <DrChaos_> Ok, I am new to functional and recursive programming so things that seem obvious to others are not obvious to me
15:07:18 <alec> catsbydlo, because i can't fit it all in
15:07:28 <catsbydlo> alec: do you have to?
15:07:38 <ion> helium sounds have a high pitch
15:07:46 <catsbydlo> DrChaos_: structural recursion is your friend
15:07:49 <alec> catsbydlo, yes i thrive on having a big picture image of the puzzle, even if the puzzle has 10000 pieces
15:07:50 <S11001001> findM f = foldr (\x e -> ifM (f x) (return x) e) (return Nothing)
15:08:00 <S11001001> or return Just x or something
15:08:11 <alec> if i can look at the box and go 'that's what it looks like generally', i can work stuff out and remember it easier
15:08:22 <alec> it's like memorizing a bach prelude with/without music theory
15:08:32 <alec> with music theory, you go, 'here's the next chord'
15:08:40 <catsbydlo> ... no, I don't
15:08:42 <alec> without, you go 'it sounds different now'
15:09:07 <Hermit> `nand`: yeah, that's what I intuitively looked for, but when I tried Control.Monad there was nothing alike. I thought there would be a combinator for that already
15:09:38 <Hermit> S11001001: yeah, the problem is not really implementing it. I just wanted to use the existing combinator, if there is such a thing
15:09:48 <S11001001> Hermit: there's one in scalaz for one day when you have to write scala for some reason :)
15:10:10 <c_wraith> S11001001: the problem with that implementation is that it will execute the effects for the whole list, regardless of whether it finds something or not
15:10:19 <S11001001> c_wraith: no it won't
15:10:24 <Hermit> S11001001: heheh, I would not touch scala, not even with a loooong stick ;-)
15:10:29 <S11001001> c_wraith: ifM is not liftA3 if
15:10:30 <c_wraith> oh, right, it depends on ifM
15:10:32 <mreh> I want to marshall some C structs into haskell datatype, but I have to explicitly tell the API that I want to free up the memory after I've finished with the data I've loaded
15:10:48 <c_wraith> mreh: use a ForeignPtr?
15:10:52 <mreh> is there a way to clone the memory and tell the API to free it up immediately
15:11:22 <Hermit> `nand`: is something like findM already in some module?
15:11:23 <mreh> and let haskell do it's GC
15:11:23 <lispy> mreh: Storable and ForeignPtr are helpful here. Real-World Haskell has a chapter on it, but I don't think they cover much.
15:11:32 <Hermit> `nand`: or should I just implement my own?
15:12:31 <lispy> mreh: http://www.haskell.org/ghc/docs/latest/html/libraries/haskell2010-1.1.1.0/Foreign-ForeignPtr.html
15:12:53 <Hermit> :t ifM
15:12:55 <lambdabot> Not in scope: `ifM'
15:12:56 <catsbydlo> mreh: what do you mean by "clone"? aren't you done with the pointer after you've created your Haskell value?
15:12:58 <`nand`> Hermit: I don't think it exists, no
15:13:00 <mikeplus64> :t foldM
15:13:02 <lambdabot> Monad m => (a -> b -> m a) -> a -> [b] -> m a
15:13:11 <mreh> oh, that's coooool
15:13:16 <`nand`> Hermit: I'm trying to find a lensy way to encode it, but I don't think it can be elegantly done
15:13:28 <S11001001> Hermit: http://hackage.haskell.org/packages/archive/MissingM/0.0.4/doc/html/Control-Monad-MissingM.html
15:13:35 <mreh> catsbydlo: apparently ForeignPtr cleans it up for me when it's GCed
15:13:39 <`nand`> oh
15:13:40 <`nand`> there you go
15:13:46 <`nand`> hoogle didn't pick it up :(
15:14:01 <catsbydlo> mreh: yes, assuming you want to keep the pointer around. do you want to keep the pointer around?
15:14:02 <S11001001> not a pretty implementation but the right one
15:14:16 <mreh> catsbydlo: well I will when I do, and I wont when I don't
15:14:29 <mreh> I want the runtime to take care of the cleanup
15:15:28 <catsbydlo> why?
15:16:14 <Hermit> S11001001: how did you find that module?
15:16:36 <S11001001> Hermit: https://duckduckgo.com/?q=findM+site%3Ahaskell.org
15:17:24 <Hermit> S11001001: even though the findM name is strightforward, I was wondering if there was something else
15:17:34 <Hermit> (involved in finding it)
15:18:19 <S11001001> nah, when !hoogle fails, substitute
15:21:03 <Hermit> in any case, is unsafePerformIO considered a bad thing in this scenario?
15:24:01 <catsbydlo> Hermit: depends on what your action does
15:25:27 <`nand`> actions you unsafePerformIO should: 1. not produce visible side effects (eg. output, real world interaction); 2. always return the same result, even for multiple invocations or invocations at different points in time
15:25:37 <tac> Every time you unsafePerformIO, God kills a kitten and returns ()
15:25:55 <mikeplus64> Hermit: yes, because as you see above findM is pretty trivially implemented
15:26:10 <otters> like unsafePerformIO (return 'c')
15:26:15 <acowley> Hermit: Probably not. If you don't want to write your own, you can use firstM from http://hackage.haskell.org/packages/archive/monad-loops/0.3.3.0/doc/html/Control-Monad-Loops.html
15:29:13 <Cale> Hermit: if you don't know whether unsafePerformIO is okay, then it's probably not okay
15:29:31 <acowley> unsafePerformCale
15:29:47 <thoughtpolice> unsafeDistortReality
15:29:59 <tac> (unsafePerformCale solves your problem and returns ())
15:30:13 <acowley> unsafePerformCale has some surprising Num instances
15:30:52 <Cale> Basically, you should treat the question "Do I need to use unsafePerformIO here?" as being similar to "Do I need to modify the compiler to do what I want to do here?"
15:31:25 <Iceland_jack> That's going a bit too far...
15:32:07 <Iceland_jack> You need unsafePerformIO for any serious FFI work and FFI is not in the same league as modifying the compiler
15:32:11 <jozefg> If I have some instance of Num, is there any way to pattern match it for primitives like Double or Int
15:32:15 <jozefg> ?
15:32:27 <acowley> why do you need unsafePerformIO for any serious FFI work?
15:32:37 <acowley> Lots of FFI work should live in IO
15:32:38 <Cale> Yeah, that's not quite true.
15:32:45 <shachaf> jozefg: What does that mean?
15:32:46 <cmccann> jozefg, numeric literals are not really pattern matches
15:32:48 <`nand`> “Do I need to use unsafeCoerce here?” is similar to “Do I need to modify Haskell to do what I want here?” then?
15:32:53 <acowley> jozefg: No
15:33:18 <cmccann> numeric literals as "patterns" are translated by interpreting the literal as usual and checking with (==)
15:33:19 <shachaf> `nand`: unsafeCoerce is for when you can't figure out how to express your type to the type system.
15:33:20 <Iceland_jack> If you need to work with pointers but still return a pure value
15:33:24 <shachaf> `nand`: Just ask edwardk.
15:33:49 <acowley> unsafeCoerce is the Getting Things Done of functions :P
15:33:54 <Iceland_jack> many “pure” C functions return their values via a pointer argument
15:33:55 * `nand` likes Idris' version of unsafeCoerce
15:33:58 <`nand`> believe_me :: a -> b
15:34:00 <cmccann> @quote unsafecoerce
15:34:01 <lambdabot> shachaf says: isTrue :: Bool -> Bool; isTrue = unsafeCoerce
15:34:01 <acowley> yes
15:34:10 <cmccann> @quote unsafecoerce
15:34:11 <lambdabot> edwardk says: this breaks my previous record of 6 unsafeCoerce's in a line
15:34:20 <cmccann> appropriate!
15:34:23 <monochrom> haha
15:34:41 <shachaf> monochrom: Don't worry, "lens" is down to only 10 instances of the string "unsafeCoerce"
15:34:50 <bholst> :t find
15:34:50 <`nand`> the most ingenious use of unsafeCoerce I've seen is in reflection
15:34:51 <lambdabot> (a -> Bool) -> [a] -> Maybe a
15:34:55 <shachaf> A couple of those are of the form «#define UNSAFELY(x) unsafeCoerce», though.
15:34:56 <acowley> shachaf: One of those lines is defining an alias, isn't it?
15:35:12 <acowley> dontTell = unsafeCoerce
15:35:18 <`nand`> (an edwardk package, of course)
15:35:27 <shachaf> acowley: "don'tTell"
15:43:45 * hackagebot smtp-mail 0.1.0.0 - Simple email sending via SMTP  http://hackage.haskell.org/package/smtp-mail-0.1.0.0 (JasonHickner)
15:49:32 <NoICE> elliott: are you still there?
15:49:43 <shachaf> elliott is always here
15:49:52 <NoICE> :
15:49:53 <NoICE> :)
15:50:58 <NoICE> please, when I write data to TChan via writeTChan .. does it "append" it to the queue, or just overwrites actual value within the TChan?
15:51:15 <shachaf> NoICE: You should try it out!
15:51:36 <NoICE> this thing is hard to try..
15:51:43 <NoICE> .. so I just wanted a shortcut :D
15:51:56 <shachaf> Why is it hard to try?
15:52:11 <shachaf> Also I don't understand your question. What does it mean to "overwrites actual value within the TChan"?
15:52:59 <NoICE> well.. if something is in a channel and has not been read yet by readTChan, will it get overwritten (or will writeTChan block until someone reads the value)?
15:53:08 <catsbydlo> do writeTChan t "foo"; writeTChan t "bar"; readTChan t
15:53:25 <zypper> Is there a way to prevent ghci from printing all the imported modules' names every line?
15:53:31 <shachaf> λ> do { t <- newTChanIO; atomically $ writeTChan t "hi"; atomically $ writeTChan t "hello"; (a,b) <- atomically $ liftM2 (,) (readTChan t) (readTChan t); return (a,b) }
15:53:34 <shachaf> ("hi","hello")
15:53:44 <shachaf> Does that answer your question?
15:53:45 <NoICE> catsbydlo: huh, thanks, will try it then
15:53:57 <shachaf> If you don't know what liftM2 does you can figure out a longer way of saying the same thing.
15:54:17 <NoICE> shachaf: yes it does :) thanks!
15:54:43 <catsbydlo> zypper: :set prompt
15:56:34 <zypper> catsbydlo: But then it still shows it when I use multiline commands with ":set +m"
16:17:07 <lispy> zypper: ghci's default prompt has a %s in it that expands to the modules in scope
16:17:19 <lispy> zypper: so you can set your own prompt that doesn't have a %s
16:17:41 <lispy> zypper: for example: https://github.com/dagit/dotfiles/blob/master/.ghci
16:18:01 <lispy> zypper: I like the module list so I have a %s in mine, but that should give you an example of how to set yours
16:20:06 <zypper> lispy: That doesn't work here, with GHC 7.4.2. >_>
16:20:22 <zypper> I still get "ModuleList | " as the prompt when it's multiline.
16:20:38 <lispy> how do you get a multiline?
16:20:45 <lispy> I'll see if that happens here
16:20:54 <zypper> :{commands:}
16:21:20 <zypper> Or ":set +m" and then using, say, do-notation with indentation layout.
16:21:41 <tomeo> if I want to use arithmetic on Maybes, is there any better way than putting the arithmetics in a do block?
16:22:15 <elliott> > (+) <$> Just 3 <*> Just 4
16:22:17 <lambdabot>   Just 7
16:22:19 <elliott> :t liftA2 (+)
16:22:21 <lambdabot> (Num c, Applicative f) => f c -> f c -> f c
16:22:50 <elliott> :t liftA2 (+) :: Maybe Int -> Maybe Int -> Maybe Int
16:22:52 <lambdabot> Maybe Int -> Maybe Int -> Maybe Int
16:23:55 <tomeo> elliott: is that in prelude?
16:24:04 <elliott> Control.Applicative
16:24:50 <lispy> zypper: ah, I suspect this is a bug. There should probably be a way to set the multiline prompt string.
16:25:06 <tomeo> And if I wanted to do like sum [n+n | n <- [x,y]] where x = Just 3 and y = Just 5, could I do that without a do block?
16:25:11 <lispy> zypper: but I don't see a variable to tweak in the user guide
16:25:46 <elliott> tomeo: sum [n+n | Just n <- [x,y]]
16:26:30 <zypper> lispy: Darn it. :(
16:27:34 <acowley> tomeo: If you're sure that the values are Justs, it would be better if you dind't have Maybes.
16:27:37 <tomeo> elliott: that doesn't return a maybe :/
16:27:54 <tomeo> acowley: I'm trying to learn about maybe's. not trying to accomplish anything special
16:28:00 <acowley> tomeo: I understand
16:28:40 <acowley> tomeo: My point is that you usually don't really want to, at some point, assume which data constructor of a variant type was used. For maybe, you should use things like the Applicative interface.
16:28:47 <elliott> well, I'm not sure what you want your option to do
16:28:53 <acowley> > (+) <$> Just 5 <*> Just 3
16:28:53 <elliott> er
16:28:54 <lambdabot>   Just 8
16:28:55 <elliott> your code to do
16:29:10 <acowley> > (+) <$> Just 5 <*> Nothing
16:29:11 <lambdabot>   Nothing
16:29:23 <tomeo> elliott: If I have x = Just 3, y = Just 5 and z = Nothing
16:29:47 <tomeo> elliott: I found I could do x + y, x + z and even my list comp. in a do block
16:30:05 <tomeo> but I was hoping to find ways of doing the same thing without do blocks
16:30:30 <sipa> > liftA2 (+) (Just 3) (Just 5)
16:30:30 <tomeo> as I have interpreted do blocks to be something I shouldn't use unless I really have to
16:30:32 <lambdabot>   Just 8
16:30:56 <tomeo> sipa: Thats fine, but it uses Control.Applicative and I can't do a list comp with it
16:31:24 <sipa> what would you want to be able to write?
16:32:40 <tomeo> I want x + y to be Just 8, x + z to be Nothing and sum [n+n | n <- [x,y]] to be Just 16
16:32:58 <tomeo> and I can do all this with do, I was hoping to learn how to do it without do
16:33:21 <ick> how do i evaluate an entire list without printing it?
16:33:30 <elliott> What do you want yourSum [Nothing, Just 3, Just 4] to be?
16:33:34 <elliott> Just 7 or Nothing/
16:33:42 <sipa> ick: what would you do with the result?
16:33:58 <ick> nothing, i just want to know how long it takes
16:34:03 <elliott> > let x = Just 3; y = Just 5 in foldr (liftA2 (+)) (Just 0) [(*2) <$> n | n <- [x,y]]
16:34:04 <lambdabot>   Just 16
16:34:59 <elliott> > let x = Just 3; y = Just 5 in fmap getSum $ foldMap (fmap Sum) [(*2) <$> n | n <- [x,y]]
16:35:01 <lambdabot>   Just 16
16:35:03 <elliott> (Don't use that version.)
16:35:25 <tomeo> elliott: But I will either have to import Control.Applicative or use do-blocks right?
16:35:36 <elliott> Yes, these operations are in Control.Applicative.
16:35:39 <elliott> Why don't you want to import it?
16:35:43 <elliott> It's in the standard library.
16:36:15 <elliott> If you want to know how to write these with no helper functions at all, the answer is pattern matching.
16:36:21 <elliott> But it'll be ugly.
16:36:30 <acowley> Go straight to Applicative
16:36:30 <vildor> hi!
16:36:52 <acowley> Haskell without Functor, Applicative, and Monad is... tricky
16:37:04 <tomeo> acowley: Thats my world right now :D
16:37:13 <elliott> > let x = Just 3; y = Just 5 in au (mapping (wrapping Sum)) foldMap [(*2) <$> n | n <- [x,y]]
16:37:15 <lambdabot>   Just 16
16:37:17 <elliott> nice
16:37:26 <acowley> tomeo: The value of your current experience, then, is to motivate those abstractions :)
16:37:26 * elliott might use that version in practice.
16:38:02 <elliott> Though au (mapping _sum) foldMap would be so much nicer.
16:38:04 <acowley> tomeo: Perhaps the most useful thing is to write the pattern match version, not the do-block version.
16:38:57 <tomeo> acowley: like f (Just x) (Just y) = ?
16:38:58 <acowley> tomeo: Use let or where to strip off Just constructors and you'll be left with something very fragile. Use case, and you end up with unpleasantly deep nesting.
16:39:05 <acowley> tomeo: Sure!
16:39:26 <acowley> > let f (Just x) (Just y) = Just (x+y) in f (Just 5) (Just 3)
16:39:28 <lambdabot>   Just 8
16:39:39 <acowley> > let f (Just x) (Just y) = Just (x+y) in f (Just 5) Nothing
16:39:41 <lambdabot>   *Exception: <interactive>:3:5-36: Non-exhaustive patterns in function f
16:39:44 <acowley> "fragile"
16:40:03 <simpson> > let f (Just x) (Just y) = Just (x + y); f _ _ = Nothing in f (Just 5) Nothing
16:40:04 <lambdabot>   Nothing
16:42:11 <vildor> I'm stuck with an assignment for Uni... We spend 3 semesters coding in Java and then have to forget all about that and do some haskell programming...
16:42:28 <avpx> "Get to"
16:42:48 <acowley> vildor: Never forget. Use your painful memories to fuel a newfound enthusiasm for Haskell!
16:42:56 <vildor> I have a list of lists [[Int]] and the inside values are either 0 or 1
16:42:58 <acowley> (also, knowing Java is useful)
16:43:19 <vildor> how can I count the number of 1's in each "line" and "column" ?
16:43:42 <vildor> I've spent a fair part of the day googling\hoogleing and I'm pretty stuck =\
16:43:59 <simpson> vildor: Simpler problem first. How would you count the number of 1s in a single [Int]?
16:44:00 <acowley> vildor: How would you count the 1's in a list?
16:44:02 <vildor> oh! And without using Arrays... [[a]]
16:44:33 <vildor> go through each a in [1..X]
16:44:39 <lispy> vildor: have you looked at list comprehensions?
16:45:06 <lispy> > sum [ 1 | x <- [1..10], even x ]
16:45:08 <acowley> vildor: Have you learned any higher order functions for working with lists? Like map, filter, foldr, foldl?
16:45:08 <lambdabot>   5
16:45:47 <vildor> acowley, we talked about them, but not 100% shure on how it works
16:46:01 <avpx> vildor: Break the problem up, as suggested above. See if you can solve the problem on a single list of elements
16:46:20 <avpx> Then it's just a matter of using higher-order functions to generalize that to a list of lists.
16:46:24 <acowley> vildor: Experiment with map and filter at least
16:46:47 <vildor> ok. I will =)
16:46:56 <acowley> vildor: Any time you spend familiarizing yourself with them will pay off handsomely.
16:48:15 <vildor> just another quick question... On this assignment we also have to read a String from input and convert it into [Int]. I've done that. But converting from [Int]->String jas been a PITA
16:48:23 <vildor> any pointers on that?
16:48:42 <vildor> I'll even say pretty please
16:48:44 <simpson> vildor: How would you convert a single Int into a String?
16:49:01 <vildor> simpson, that I don't know
16:49:01 <glguy> vildor: If you have code where you tried something but it didn't work you can put it up on hpaste.org
16:49:51 <simpson> vildor: Are you allowed to use the "show" function?
16:50:08 <vildor> simpson: yes I am
16:50:21 <simpson> > show [1..10]
16:50:23 <lambdabot>   "[1,2,3,4,5,6,7,8,9,10]"
16:50:58 <vildor> Ok, bad explanation on me
16:51:09 <Elench> > shpw [10..1]
16:51:11 <lambdabot>   Not in scope: `shpw'
16:51:11 <lambdabot>  Perhaps you meant `show' (imported from Prelude)
16:51:18 <Elench> > show [10..1]
16:51:20 <lambdabot>   "[]"
16:51:27 <avpx> vildor: With regards to your first question, it can be done very elegantly in so-called "pointfree style", whereby you just compose other functions without taking arguments
16:51:28 <Elench>  Just wondered
16:51:52 <vildor> String->[Int] would be something like: "AA"->[ASCII VALUES]
16:52:25 <vildor> avpx thans for that. Will search it up =)
16:52:28 <cl_away> vildor: What should stringToInt of "5" be?  Is it okay for that to crash?
16:53:11 <vildor> ok to crash? how so? it has do DO what it's supposed... the script can't stop
16:53:19 <cl_away> If so, you can do a pretty simple pattern match on c:d:cs.
16:53:31 <cl_away> vildor: Right, but you've defined it in terms of pairs of characters.
16:53:41 <cl_away> Actually, you can put in a case for handling a single character as well.
16:53:48 <avpx> > let sum_squares = sum . map (^2) in [1..10]
16:53:50 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
16:53:55 <avpx> Erm
16:53:59 <avpx> > let sum_squares = sum . map (^2) in sum_squares [1..10]
16:54:01 <lambdabot>   385
16:54:04 <cl_away> And use digitToInt
16:54:09 <cl_away> I have to run.
16:54:48 <avpx> vildor: That example is pointfree style. All I had to do to sum the squares of the list elements was compose the sum function with the function that squares all of the elements.
16:55:13 <avpx> And I used a higher-order function to create such a function that squares the elements.
16:55:24 <glguy> If he needs help with his original question, it might be too early to worry about how many points his solution has :)
16:55:41 <avpx> Hah.
16:56:25 <avpx> Maybe I've said too much, but it is very nice to be able to build functions without ever touching your arguments.
16:57:03 <acowley> I think we should be focusing on getting Ints from strings
16:58:04 <acowley> Then we'll get HoFs with points, and soon enough the scales^H^H^H^H^H^Hpoints will fall from vildor's eyes!
16:58:35 <avpx> And in order to understand composition, you basically have to know about categories
16:58:37 <avpx> I mean, come on
17:00:08 <hpaste> vildor pasted “assign” at http://hpaste.org/79210
17:01:05 <vildor> I admit I had some help with that piece of code
17:01:26 <vildor> but that is how I "convert" a string into [[Int]]
17:01:58 <vildor> but I'm having a real challenge making the reverse function
17:09:43 <a|i> does haskell now run on ios?
17:11:26 <lispy> a|i: there is an arm backend, but I doubt it supports ios
17:11:59 <a|i> lispy: so, this doesn't work yet? https://github.com/ghc-ios/ghc/wiki
17:12:48 <lispy> a|i: looks promising, but I've never tried it.
17:31:02 <dmwit> vildor: Why are you trying to do this? (And not, say, using a proper encoding library?)
17:48:50 * hackagebot alpha 1.0.10 - A compiler for the Alpha language  http://hackage.haskell.org/package/alpha-1.0.10 (MarcCoiffier)
18:02:34 <pqmodn> > 1
18:02:51 <pqmodn> lambdabot not feeling well lately?
18:03:57 --- mode: asimov.freenode.net set +o ChanServ
18:04:07 <acowley> coleman-: Are you trying to use ASCII characters?
18:04:13 <coleman-> yes
18:04:27 <ion> @type Data.ByteString.Char8.split
18:04:28 <lambdabot> Char -> BSC.ByteString -> [BSC.ByteString]
18:06:30 <coleman-> thanks. I used Data.ByteString.Split. still out of curiosity, how to write a Word8 in source?
18:06:49 <ion> > 5 :: Word8
18:06:51 <lambdabot>   5
18:07:22 <coleman-> writing ascii codes is not very descripting
18:07:27 <coleman-> descriptive
18:07:56 <ion> Word8 doesn’t stand for an ASCII character, it stands for a 8-bit unsigned integer.
18:08:08 <acowley> > ord '*' :: Word8
18:08:10 <lambdabot>   Couldn't match expected type `GHC.Word.Word8'
18:08:10 <lambdabot>              with actual type...
18:08:20 <acowley> > fromIntegral (ord '*') :: Word8
18:08:22 <lambdabot>   42
18:08:24 <zomg> Hakyll is quite nice... I can write an article in markdown, plop it into my template, and have hakyll pull haskell source examples right into it
18:08:31 <coleman-> ion irrelevant when there are ByteString functions that accept a char as a Word8
18:08:33 <sw2wolf> > t fmap
18:08:35 <lambdabot>   The function `Debug.SimpleReflect.Vars.t'
18:08:35 <lambdabot>  is applied to one argument,
18:08:35 <lambdabot>  but...
18:08:41 <zomg> I could probably integrate GHC into the build so GHC also validates the haskell examples so that they actually compile
18:08:44 <zomg> Nice stuff =)
18:09:00 <sw2wolf> :t fmap
18:09:01 <lambdabot> Functor f => (a -> b) -> f a -> f b
18:09:14 <elliott> coleman-: Are you sure you want to use ByteString and not Text?
18:09:18 <ion> coleman: Sure, if you have some extra knowledge about what some integral type is being used for, conversion functions are just fine to use.
18:09:50 <coleman-> elliott yes I think? I don't need unicode and 2x more memory requirement
18:10:04 <ion> Are you running low on RAM?
18:10:10 <acowley> coleman-: This is just the friction between between Char and ASCII
18:10:27 <coleman-> is there nothing shorter than fromIntegral (ord '*') ?
18:10:50 <ion> Data.ByteString.Char8
18:11:12 <acowley> coleman-: Use http://www.haskell.org/ghc/docs/latest/html/libraries/bytestring-0.10.0.0/Data-ByteString-Char8.html
18:11:14 <acowley> heh
18:11:15 * elliott thinks you're moderately likely to have overheads bigger than ByteString vs. Text, but whatever.
18:11:23 <elliott> acowley: :(
18:11:29 <elliott> coleman-: you can define ord8 = fromIntegral . ord
18:11:39 <elliott> ord8 :: Char -> Word8
18:11:45 <elliott> that's a fairly evil function but less evil than Data.ByteString.Char8
18:12:03 <acowley> I use ByteString for ASCII pretty regularly. If you know your text is ASCII, there's no need to get carried away
18:12:10 <coleman-> heh why is Char8 evil?
18:12:38 <acowley> In particular, I feel great shame when my Haskell ASCII parsing code runs so much slower than naive C.
18:12:42 <byorgey> coleman-: because not all Chars fit.
18:12:44 <elliott> because ByteStrings don't represent Chars at all
18:12:47 <ion> λ> BS8.pack "☺"
18:12:49 <ion> ":"
18:12:54 <elliott> it's a semantic mismatch in several ways
18:13:09 <acowley> ion: At least it came up with half an emoticon
18:13:17 <pqmodn> heh
18:13:50 * hackagebot smtp-mail 0.1.1.0 - Simple email sending via SMTP  http://hackage.haskell.org/package/smtp-mail-0.1.1.0 (JasonHickner)
18:13:52 <ion> λ> BS8.pack "က"
18:13:54 <ion> "\NUL"
18:14:06 <edwardk> > /whois coleman-
18:14:08 <lambdabot>   <hint>:1:1: parse error on input `/'
18:14:12 <tomeo> when doing a foldr, is there any way to access the value that has been accumulated so far?
18:14:30 <ion> > /whois edwardk
18:14:32 <lambdabot>   <hint>:1:1: parse error on input `/'
18:14:35 <edwardk> =P
18:14:44 <sw2wolf> how to use lambdabot ?
18:15:11 <eikke> :t foldr
18:15:11 <edwardk> i apparently had him on /ignore. it was weirding me out that everyone was talking to this imaginary friend ;)
18:15:12 <ion> edwardk: http://youtu.be/ADAprOOgi-A?hd=1
18:15:12 <byorgey> tomeo: yes, the function argument to foldr is given the folded result of the end of the list as an argument.
18:15:12 <lambdabot> (a -> b -> b) -> b -> [a] -> b
18:15:33 <eikke> tomeo: isn't that the 'b' in (a -> b -> b)?
18:16:03 <byorgey> tomeo: if that's not what you mean then you'll have to give an example of what you're trying to do.
18:16:32 <tomeo> byorgey: Im trying to write q (x:xs) = x:q (filter (/=x) xs) with a foldr
18:16:44 <pqmodn> sw2wolf: /msg lambdabot @help
18:17:10 <sw2wolf> pqmodn: thx
18:17:18 <byorgey> tomeo: that sounds quite difficult.
18:17:53 <tomeo> byorgey: yes, thats why Im trying :D
18:18:40 <byorgey> tomeo: because given some list, foldr has to decide what to fold it to, independent of the context of any elements that may be consed onto it on the left
18:18:43 <eikke> tomeo: OTOH, foldr (\acc v -> if v `elem` acc then acc else acc ++ [v]) []
18:18:56 <eikke> which is incredibly inefficient obviously
18:19:06 <byorgey> tomeo: so I suspect you will have to use foldr to produce not a list but a *function* which takes the set of elements to the left as an argument and then produces a list.
18:19:41 <byorgey> > foldr (\acc v -> if v `elem` acc then acc else acc ++ [v]) [] [1,2,1,3,3,2,4]
18:19:42 <lambdabot>   Occurs check: cannot construct the infinite type: t0 = [t0]
18:19:49 <tomeo> byorgey: Im thinking somethine like foldr ((:).expr) where expr does my checking
18:20:08 <kennyd> > foldr (\x acc -> if elem x acc then acc else x : acc) [] "123123"
18:20:10 <lambdabot>   "123"
18:20:38 <tomeo> kennyd: nice, why does the acc reference the acc. list?
18:20:38 <byorgey> that is not the same as what tomeo wrote
18:20:45 <eikke> > foldr (\x acc -> if elem x acc then acc else x : acc) [] "43212345"
18:20:46 <lambdabot>   "12345"
18:20:48 <pqmodn> tomeo: i think foldr ((:) ...) means you must cons a value every iteration
18:20:51 <tomeo> sure it is byorgey
18:20:52 <byorgey> > foldr (\x acc -> if elem x acc then acc else x : acc) [] "123321"
18:20:53 <lambdabot>   "321"
18:21:14 <byorgey> > let q [] = []; q (x:xs) = x:q (filter (/=x) xs)  in q "123321"
18:21:14 <eikke> thats not the same as 'q' I think
18:21:15 <lambdabot>   "123"
18:21:33 <tomeo> byorgey: I could just reverse
18:21:35 <byorgey> see, they delete different elements, hence you can get the output in a different order.
18:21:43 <eikke> > foldr (\x acc -> if x `elem` acc then acc else acc ++ [x]) [] "43212345"
18:21:45 <lambdabot>   "54321"
18:21:50 <byorgey> they are not related by reverse.
18:22:01 <byorgey> > foldr (\x acc -> if elem x acc then acc else x : acc) [] "123132"
18:22:02 <lambdabot>   "132"
18:22:03 <tomeo> byorgey: q is just like nub from Data.List
18:22:11 <byorgey> > let q [] = []; q (x:xs) = x:q (filter (/=x) xs)  in q "123132"
18:22:12 <lambdabot>   "123"
18:22:19 <byorgey> tomeo: indeed.
18:22:46 <byorgey> oh, I guess the foldr (\x acc -> ...)  thing is actually  reverse . q . reverse
18:23:02 <byorgey> so they are related by reverse, as long as you don't care about infinite lists.
18:23:51 <tomeo> I don't get why acc in the lambda holds the acc. value
18:23:57 <tomeo> (or list in this case)
18:24:11 <eikke> isn't that the point of folds?
18:24:14 <pqmodn> :t foldr
18:24:16 <lambdabot> (a -> b -> b) -> b -> [a] -> b
18:24:39 <tomeo> eikke: there's obviously something I'm missing here :)
18:25:04 <byorgey> @check \ys -> let q [] = []; q (x:xs) = x:q (filter (/=x) xs) in (reverse . q . reverse) (ys :: [Int]) == foldr (\x acc -> if elem x acc then acc else x : acc) [] ys
18:25:05 <tomeo> I didn't think intermediate results were available in folds, only in scans
18:25:05 <lambdabot>   Not in scope: `myquickcheck'
18:25:18 <byorgey> wat
18:25:35 <byorgey> tomeo: it depends what you mean by "intermediate"
18:25:41 <eikke> tomeo: a fold is like a scan where only the 'last' value is yielded
18:25:45 <pqmodn> tomeo: foldr doesn't yield the result of each iteration
18:25:57 <eikke> a scan is like a fold where all intermediate results (accumulator) are yielded
18:26:02 <tomeo> pqmodn: it builds a long expression instead right?
18:26:16 <pqmodn> yeah, i think you could say that
18:26:30 <pqmodn> @where fold
18:26:30 <lambdabot> I know nothing about fold.
18:26:35 <byorgey> tomeo: the point is that the intermediate results are certainly *computed*, they are just not *returned* as part of the final output
18:26:42 <tomeo> whereas fold' would evaluate each step
18:26:46 <pqmodn> http://www.haskell.org/haskellwiki/Fold
18:27:06 <byorgey> tomeo: that's unrelated.
18:27:06 <tomeo> byorgey: yes, I understood they were computed. But not that they were available to me :)
18:27:18 <tomeo> but the fact that they are is very good for me
18:27:58 <pqmodn> tomeo: the diagrams in section 5 might be helpful for understanding.
18:28:53 <tomeo> pqmodn: of what litterature?
18:29:03 <pqmodn> pqmodn: http://www.haskell.org/haskellwiki/Fold
18:29:10 <tomeo> oh thanks
18:29:11 <pqmodn> der, tomeo ^
18:29:28 <coleman-> would this be as q function?
18:29:59 <coleman-> > reverse . foldl (\acc x -> if elem x acc then acc else x : acc) [] $ "123321"
18:30:01 <lambdabot>   "123"
18:30:27 <eikke> > reverse . foldl (\acc x -> if elem x acc then acc else x : acc) [] $ "12332145"
18:30:29 <lambdabot>   "12345"
18:31:08 <coleman-> more efficient than acc ++ [x]
18:31:26 <byorgey> coleman-: yes, that looks right to me
18:34:06 <simpson> > nub "12332145" -- coleman- uh, isn't this just Data.List.nub?
18:34:07 <lambdabot>   "12345"
18:34:18 <coleman-> simpson yes
18:34:27 <pqmodn> simpson: yes, he wanted to practice using folds
18:34:32 <simpson> Oh, okay.
18:37:49 <mikeplus64> which is more efficient to update and memory wise, an IORef of an immutable data structure or an immutable data structure of IORefs?
18:39:02 <startling> I assume the latter
18:39:35 <tomeo> byorgey: pqmodn q' = foldr (\x xs -> if elem x xs then xs else xs ++ [x]) []
18:39:46 <tomeo> thanks for your help :)
18:39:48 <coleman-> > reverse . fst . foldl (\ (list, set) x -> if Set.member x set then (list, set) else (x : list, Set.insert x set)) ([], Set.empty) $ "123321"
18:39:50 <cmccann> mikeplus64, I imagine that depends on what kind of updates you're doing
18:39:50 <lambdabot>   Not in scope: `Set.member'
18:39:50 <lambdabot>  Perhaps you meant one of these:
18:39:51 <lambdabot>    `S.member' (...
18:40:03 <argiopeweb> mikeplus64: I'd say it would depend heavily on whether you need concurrent access.
18:40:06 <coleman-> tomeo that would be more efficient. :)
18:40:34 <tomeo> coleman-: is (++) more or less efficient compared to (:)?
18:40:53 <coleman-> tomeo less. it's O(n) compared to O(1) for :
18:41:06 <coleman-> I looked up using a set though, in last code
18:41:39 <tomeo> coleman-: I got rid of the reverse though :)
18:41:54 <tomeo> Which I'm guessing would be O(n) as well
18:42:21 <acowley> indeed
18:42:26 <coleman-> tomeo yes but I did it once, at the end. you are iterating entire list for every new element to append it to a list
18:42:30 <acowley> Which is why it doesn't play so well with infinite lists
18:42:55 <tomeo> coleman-: yes I have a few of them :p
18:43:01 <mikeplus64> cmccann: if you were doing a single field update like modifyIORef ref (\r -> r { a = foo (a r) }) that would be more or less efficient than modifyIORef (a record) foo
18:43:07 <mikeplus64> ?
18:43:31 <coleman-> tomeo then it doesn't matter either way
18:43:34 <mikeplus64> or in the case where you want to update a field by using other fields, it would be more efficient to have the whole thing an IORef?
18:43:39 <pqmodn> mikeplus64: consider updating the 40th element of a list
18:43:50 <cmccann> mikeplus64, I'm honestly not sure what the relative overhead of stuff is
18:44:10 <mikeplus64> cmccann: yeah, there doesn't seem to be much writing about the overhead of IORefs and such
18:44:21 <cmccann> but clearly at some point if you have to rebuild a large structure that keeps a consistent number of slots you'd be better off with the IORefs
18:44:41 <tomeo> [1,2,3], foldr over that list... 3 would be the first value encountered by foldr right?
18:44:48 <coleman-> I think acc ++ [x] is O(n^2) ? as opposed to x : acc and then reverse, which I think is O(2n), or O(n). someone correct me if I'm wrong
18:45:08 <coleman-> tomeo yes
18:45:34 <pqmodn> > foldr (+) z [a,b,c]
18:45:36 <lambdabot>   a + (b + (c + z))
18:45:38 <Cale> coleman-: (O(2n) and O(n) are the same thing), yes, that would be right, assuming you're doing that n times
18:45:45 <coleman-> Cale I know
18:45:51 <acowley> coleman-: It's O(n), but it's O(n) for each item you snoc onto the end. If you do a bunch of conses, then reverse, you win.
18:45:55 <Cale> xs ++ ys takes O(length xs) time
18:47:00 <Cale> So if you do it again and again, you really want xs to be short each time, rather than growing in size.
18:47:05 <coleman-> acowley big O is worse case scenario. if you append all the elements that should be O(n^2) as far as I can see
18:47:39 <Cale> big-O notation is not necessarily used for worst case, but typically is
18:47:40 <acowley> coleman-: Yes, like I said it's O(n) for each snoc, which can end up as n*n
18:48:05 <acowley> coleman-: It's less stark when you're only ever going to snoc one element onto the end of a list.
18:49:11 <Cale> There's a really cute trick for when (++)'s performance is causing problems that I think everyone should be aware of
18:49:14 <pqmodn> coleman-: as ++ (bs ++ (cs ++ ds))) is O(length cs + length bs + length cs)
18:49:28 <pqmodn> er, last one should be as
18:49:36 <Cale> The trick is to replace lists of type [a] with functions [a] -> [a] that add elements to the beginning of a list
18:50:09 <Cale> So, [] becomes id, and [x] becomes (x:), and (++) becomes (.)
18:50:27 <sw2wolf> :t foldl
18:50:29 <lambdabot> (a -> b -> a) -> a -> [b] -> a
18:50:32 <pqmodn> http://book.realworldhaskell.org/read/data-structures.html "Taking advantage of functions as data"
18:50:34 <Cale> but since function composition is constant time instead of linear, you get better performance
18:51:03 <Cale> You can then apply the result of your function to an empty list to get back a normal list
18:51:17 <Cale> For instance, if you had the tree type:
18:51:27 <Cale> data Tree a = Tip | Branch a (Tree a) (Tree a)
18:51:43 <Cale> and had something like:
18:52:05 <Cale> inorder Tip = []; inorder (Branch x l r) = inorder l ++ [x] ++ inorder r
18:52:38 <Cale> you could rewrite that as  inorder' Tip = id; inorder' (Branch x l r) = inorder' l . (x:) . inorder' r
18:52:48 <Cale> and then  inorder t = inorder' t []
18:53:02 <Cale> and it goes from quadratic worst case to linear
18:54:42 <tomeo> How wrong am I if I describe a monad as something with a value that is uncertain? If f where monadic, f 2 would not always return the same value.
18:55:30 <Eduard_Munteanu> tomeo: probably wrong... it's more like value-in-a-context
18:55:54 <tomeo> Eduard_Munteanu: so its not pure vs unpure?
18:56:06 <tomeo> Perhaps I'm mistaking monads for IO
18:56:10 <pqmodn> tomeo: i think the best explanation i've found is "m a" describes a computation that builds an "a" when executed
18:56:12 <simpson> tomeo: At least one monad, Identity, will always give you the same value "inside" when evaluated.
18:56:33 <pqmodn> tomeo: the "recipe" analogy as it were
18:56:46 <tomeo> simpson: isnt Random IO monadic? That wouldn't always contain the same value right?
18:57:14 <simpson> tomeo: Right, but not all monads behave like IO.
18:57:35 <Eduard_Munteanu> "contain" isn't the proper word here
18:57:40 <cmccann> monads are like bad analogies, they describe a value of some sort, but without the right context you can't do anything with it
18:57:58 <tomeo> Perhaps I'd have an easier time understanding if I knew what they were good for. What are the benefits of them?
18:58:22 <pqmodn> tomeo: look at monadic combinators, mapM, sequence, etc. these generic combinators work for all monads
18:58:34 <Eduard_Munteanu> tomeo: you have to investigate particular monads to find that out
18:58:43 <simpson> > let ia = in do { x <- Identity 6; y <- Identity 7; return $ x * y }
18:58:45 <lambdabot>   <hint>:1:10: parse error on input `in'
18:58:49 <simpson> Oh, derp.
18:58:58 <simpson> > do { x <- Identity 6; y <- Identity 7; return $ x * y }
18:58:59 <lambdabot>   No instance for (GHC.Show.Show (Data.Functor.Identity.Identity b0))
18:58:59 <lambdabot>    aris...
18:59:00 <Eduard_Munteanu> For example, take Reader, which takes care of passing a common environment around for you.
18:59:07 <simpson> Oh whatever.
18:59:14 <Eduard_Munteanu> That's almost nothing like IO.
18:59:43 <cmccann> every programmer knows what several specific monads are good for. a monad in general is just an abstraction that unifies a lot of things most people don't even realize are similar.
19:00:07 <pqmodn> tomeo: similar to recognizing instances of Functor, it gives you a common interface to perform all kinds of computation on wildly different instances of the abstraction
19:00:17 <Eduard_Munteanu> In general, monadic functions represent computations with structured output... but that doesn't tell you a lot.
19:00:31 <pqmodn> tomeo: fmap lets you operate on trees, lists, maybes, etc in a uniform manner
19:00:36 <Eduard_Munteanu> However, it turns out that lets you implement certain useful things in terms of them.
19:02:01 <tomeo> Eduard_Munteanu: So If I wanted to output say the steps some matrix multiplications nicely structured, I'd have to use some monad?
19:02:32 <Eduard_Munteanu> Mm, you're misinterpreting my use of "structured".
19:03:00 <sw2wolf> lambdabot: @run toList $ append (fromList [1..5]) (fromList [1..10])
19:03:01 <lambdabot>   Not in scope: `toList'
19:03:01 <lambdabot>  Perhaps you meant one of these:
19:03:01 <lambdabot>    `Data.Foldable.t...
19:03:18 <Eduard_Munteanu> What I mean is a monadic function has a type like a -> m b, so in that sense, it has unstructured (raw) input and structured output.
19:03:41 <Eduard_Munteanu> Since 'm' could take 'b' to a type which gives more context to it.
19:03:53 <Eduard_Munteanu> For instance, Maybe.
19:04:39 <Eduard_Munteanu> Functions a -> Maybe b take "normal" inputs and return Just a value on success, and Nothing in case of failure.
19:05:19 <Eduard_Munteanu> (>>=) lets you combine such computations such that one failure shortcircuits everything.
19:05:45 <tomeo> Eduard_Munteanu: ah okay, yes I really misinterpreted your use of structured :)
19:05:59 <sw2wolf> it seems lambdabot doesnot work sometimes :)
19:06:12 <Eduard_Munteanu> In that sense, 'Maybe a' gives more structure to 'a'.
19:06:41 <geekosaur> sw2wolf, 'toList'/'fromList' are typically rather overloaded
19:07:09 <geekosaur> lambdabot has instances for Map, Set. Foldable, etc.
19:07:16 <sw2wolf> geekosaur: http://ocharles.org.uk/blog/posts/2012-12-14-24-days-of-hackage-dlist.html
19:07:50 <geekosaur> ok, so dlist defines its own
19:08:03 <geekosaur> that article assumes you have dlist loaded
19:08:19 <sw2wolf> why doesnot "/msg lambdabot @hoogle fromList" work ?
19:08:22 <geekosaur> lambdabot probably doesn't; it *does* have, as I said, many other modules that *also* provide those
19:09:03 <geekosaur> last time I tried it, it did.  but Freenode may be blocking the privmsg if you are not registered with nickserv and identified to it in this session (antispam measure)
19:09:12 <sw2wolf> sorry ! it is typing error
19:09:29 <sw2wolf> geekosaur: i see now. thx
19:20:01 <MrZepeda> l
19:38:52 * hackagebot edge 0.9.0.1 - Top view space combat arcade game  http://hackage.haskell.org/package/edge-0.9.0.1 (ChristopherHoward)
19:59:24 <Modius> Has anyone played with a construct that is a list of at least length 1?  (Statically guaranteed to have a head)?
20:00:25 <ion> @hoogle NonEmpty
20:00:26 <lambdabot> Test.QuickCheck.Modifiers NonEmpty :: [a] -> NonEmptyList a
20:00:26 <lambdabot> Test.QuickCheck NonEmpty :: [a] -> NonEmptyList a
20:00:26 <lambdabot> package NonEmpty
20:00:35 <mikeplus64> Modius: yeah
20:01:17 <mikeplus64> i think NonEmpty is implemented as (a, [a]), but i prefer data NonEmpty a = Cons a (NonEmpty a) | Nil a
20:08:53 * hackagebot yesod-markdown 0.5.0 - Tools for using markdown in a yesod application  http://hackage.haskell.org/package/yesod-markdown-0.5.0 (PatrickBrisbin)
20:11:20 <Jafet> Nil a
20:12:22 <a|i> what's the difference between jhc and ghc?
20:14:55 <popl> a|i: j != g
20:15:11 <a|i> popl: thank you, sir.
20:15:16 <popl> :)
20:15:56 <a|i> according to this: http://www.haskell.org/haskellwiki/IPhone jhc can be used on ios, while ghc is not still there. the question is, if jhc does the job, then why bother about ghc?
20:17:49 <dolio> I wonder how the people writing an iphone game using ghc were doing it, then.
20:18:13 <a|i> dolio: which apps?
20:18:24 <dolio> I don't think it ever got released.
20:18:32 <dolio> I just know they were doing it.
20:18:37 <popl> "the job"
20:18:42 <popl> what is the job as you see it, a|i?
20:19:10 <popl> jhc and ghc are designed with different goals in mind.
20:19:25 <a|i> popl: like dolio said, an iphone app.
20:19:53 <a|i> popl: okay, so what's the difference between their goals?
20:19:54 <cmccann> there's more to life than producing yet more iphone apps the world doesn't need
20:20:25 <dolio> I only buy fart sound boards written in Haskell.
20:20:37 <cmccann> haha
20:20:39 <BMeph_> cmcann: I hear, "There's an App fir that!" ;þ
20:20:44 <BMeph_> *fo
20:20:47 <BMeph_> **for
20:20:51 <cmccann> fo' sure.
20:21:15 <BMeph_> cmcann: Fo' shizzle, my nizle! ;þ
20:21:48 <popl> a|i: There are libraries that rely on ghc features.
20:22:33 <a|i> popl: like which features?
20:23:09 <dolio> Does it matter?
20:23:22 <a|i> it may.
20:23:37 <popl> http://www.haskell.org/haskellwiki/MPTC
20:23:39 <popl> for one
20:23:57 <dolio> What probably matters is that GHC will compile the libraries and JHC won't, so you won't be able to use them on the latter.
20:25:38 <Modius> GADTs - seems there's an error if they're not enabled - what's the story on them - avoid, allow, what are the issues?  Is there a good cardinal link on the issue?
20:26:23 <a|i> the hackage info on a library doesn't explicitly mention if it is supported by a compiler or not.
20:26:54 <dolio> Yeah, I don't think hackage tests builds on jhc.
20:26:56 <dolio> Well, I know it doesn't.
20:27:30 <dolio> I'd be surprised if the majority of hackage didn't fail to build on jhc.
20:28:15 <astor> where is Prelude.catch now?
20:28:28 <a|i> so the majority of libs would work with jhc.
20:29:03 <Saizan> a|i: no, most won't
20:29:38 <a|i> okay, missed the double negative.
20:30:21 <astor> is it Control.OldException.catch?
20:33:26 <astor> oh.. moved to Control.Exception.Base
20:33:45 <elliott> astor: Control.Exception
20:33:50 <elliott> no .Base
20:33:53 <elliott> but it has a different type
20:34:32 <astor> eh? how is that possible? how sould stuff be ported?
20:35:00 <elliott> by making it use the new exceptions system, not the old one that's been deprecated for several major versions :P
20:35:13 <astor> I mean when is a function removed from Prelude and not even moved into an "obsolete" package so we can port stuff.
21:02:09 <Refried__> is there an easy way to turn a   Writer [Char] (Maybe a, Maybe b) into a Writer [Char] Maybe (a, b)  ?
21:02:49 <yuruk> I think you guys get this a lot -- coming from a Python/Ruby background, where's the best place to start learning Haskell?
21:02:50 <Refried__> and maybe even into a MaybeT (Writer [Char]) (a, b)
21:03:18 <Refried__> the "lyah" book
21:03:31 <yuruk> Learn you a haskell for great good rite?
21:03:35 <Refried__> rite.
21:03:54 <yuruk> How long do you think it'll take?
21:04:00 <yuruk> I have only a month :(
21:04:06 <Refried__> better get started :)
21:04:36 <yuruk> Thanks! :D
21:05:56 <Hafydd> If you can stand the annoying tone.
21:09:01 <Refried__> or.. any easy way to go from (Maybe a, Maybe b, Maybe c) to Maybe (a,b,c) ?
21:09:52 <zomg> if that was a list it would be a matter of using `sequence` on it
21:10:10 <Refried__> *nod*
21:11:15 <Hafydd> @pl \(a,b,c) -> do{ x<-a; y<-b; z<-c; return (a,b,c) }
21:11:16 <lambdabot> (line 1, column 7):
21:11:16 <lambdabot> unexpected "c"
21:11:16 <lambdabot> ambiguous use of a non associative operator
21:11:54 <donri> > liftA2 (,) . uncurry $ (Just a,Just b)
21:11:56 <lambdabot>   Couldn't match expected type `a1 -> b0 -> a0'
21:11:56 <lambdabot>              with actual type...
21:12:18 <donri> > uncurry . liftA2 (,) $ (Just a,Just b)
21:12:20 <lambdabot>   Couldn't match expected type `b0 -> a0' with actual type `(t0, t1)'
21:12:42 <donri> uuh
21:12:46 <donri> > uncurry liftA2 (,) $ (Just a,Just b)
21:12:48 <lambdabot>   Couldn't match expected type `(a0 -> b0 -> c0, f0 a0)'
21:12:48 <lambdabot>              with ac...
21:12:53 <donri> need moar coffee
21:15:05 <popl> donri: try tea
21:15:15 <popl> coffee will make you jittery
21:15:40 <Hafydd> @pl (\(a,b,c) -> do { x<-a; y<-b; z<-c; return (x,y,z) })
21:15:40 <lambdabot> (line 1, column 8):
21:15:40 <lambdabot> unexpected "c"
21:15:40 <lambdabot> ambiguous use of a non associative operator
21:15:50 <Hafydd> What's wrong with it?
21:15:57 <donri> > (uncurry . liftA2 $ (,)) (Just a,Just b)
21:15:59 <lambdabot>   Just (a,b)
21:16:07 <donri> Refried__: ^
21:16:16 <popl> donri++
21:16:33 <popl> goob job
21:16:38 <donri> Hafydd: don't think @pl knows about do expressions
21:16:55 <Hafydd> I see.
21:17:07 <donri> @undo (\(a,b,c) -> do { x<-a; y<-b; z<-c; return (x,y,z) })
21:17:08 <lambdabot> (\ (a, b, c) -> a >>= \ x -> b >>= \ y -> c >>= \ z -> return (x, y, z))
21:17:17 <donri> @. pl undo (\(a,b,c) -> do { x<-a; y<-b; z<-c; return (x,y,z) })
21:17:18 <lambdabot> (line 1, column 11):
21:17:18 <lambdabot> unexpected "c"
21:17:18 <lambdabot> ambiguous use of a non associative operator
21:17:40 <donri> or pattern matching for that matter ^_^
21:17:55 <popl> what's pl?
21:18:05 <donri> @pl \x -> x
21:18:05 <lambdabot> id
21:18:20 <donri> produces point-less versions of expressions
21:18:35 <popl> thank you
21:21:16 <Refried__> thanks donri & all
21:23:32 <donri> @djinn (Maybe a,Maybe b) -> Maybe (a,b)
21:23:33 <lambdabot> f (a, b) =
21:23:33 <lambdabot>     case a of
21:23:33 <lambdabot>     Nothing -> Nothing
21:23:33 <lambdabot>     Just c -> case b of
21:23:33 <lambdabot>               Nothing -> Nothing
21:23:35 <lambdabot>               Just d -> Just (c, d)
21:23:42 <donri> lol
21:23:45 <Hafydd> Heh.
21:24:29 <Hafydd> @djin (Maybe a, Maybe b, Maybe c, Maybe d, Maybe e, Maybe f) -> Maybe (a,b,c,d,e,f)
21:24:29 <lambdabot> Maybe you meant: djinn djinn-add djinn-clr djinn-del djinn-env djinn-names djinn-ver
21:24:35 <Hafydd> @djinn (Maybe a, Maybe b, Maybe c, Maybe d, Maybe e, Maybe f) -> Maybe (a,b,c,d,e,f)
21:24:36 <lambdabot> f (a, b, c, d, e, f) =
21:24:36 <lambdabot>     case a of
21:24:36 <lambdabot>     Nothing -> Nothing
21:24:36 <lambdabot>     Just g -> case b of
21:24:36 <lambdabot>               Nothing -> Nothing
21:24:38 <lambdabot>               Just h -> case c of
21:24:40 <lambdabot>                         Nothing -> Nothing
21:24:41 <donri> oh dear
21:24:42 <lambdabot>                         Just i -> case d of
21:24:44 <lambdabot>                                   Nothing -> Nothing
21:24:45 <lambdabot>                                   Just j -> case e of
21:24:48 <lambdabot>                                             Nothing -> Nothing
21:24:50 <lambdabot>                                             Just k -> case f of
21:24:50 <Hafydd> I'm sorry.
21:24:52 <lambdabot> Plugin `djinn' failed with: thread killed
21:24:56 <donri> hah
21:24:57 <simpson> Heh.
21:26:23 <simpson> :t f (Just a, Just b, Just c) = Just (a, b, c); f _ = Nothing
21:26:24 <lambdabot> parse error on input `='
21:26:41 <simpson> Derp.
21:31:13 <donri> :t \x -> case x of (Just a,Just b,Just c) -> Just (a,b,c); _ -> Nothing
21:31:14 <lambdabot> (Maybe t, Maybe t1, Maybe t2) -> Maybe (t, t1, t2)
21:31:29 <donri> :t \case (Just a,Just b,Just c) -> Just (a,b,c); _ -> Nothing
21:31:30 <lambdabot> parse error on input `case'
21:31:39 <donri> guess no LambdaCase in the LambdaBot
22:01:40 <neutrino_> jmcarthur: hey, you around? :)
22:10:51 <binroot> Hey guys, can you help me find a nice  graph showing the popularity of haskell over the years?
22:11:50 <binroot> My favorite is this article http://redmonk.com/sogrady/2012/09/12/language-rankings-9-12/
22:12:11 <binroot> but can someone help me find other graphs?
22:13:10 <neutrino_> there aren't really many things like this
22:13:38 <neutrino_> you could, for example, try to find out the size of this irc channel, how much chat happens in here, and similar about the mailing list
22:20:54 <jmcarthur> neutrino_: hey
22:20:54 <lambdabot> jmcarthur: You have 1 new message. '/msg lambdabot @messages' to read it.
22:21:02 <jmcarthur> around for right now, but going to bed soon
22:21:22 <jmcarthur> and you're welcome! :)
22:24:50 <neutrino_> :)
22:25:06 <neutrino_> btw, i was wondering why you have used async, and not withAsync in that example you've given me?
22:25:33 <neutrino_> since withAsync brackets the whole computation
22:43:57 * hackagebot netwire 4.0.7 - Flexible wire arrows for FRP  http://hackage.haskell.org/package/netwire-4.0.7 (ErtugrulSoeylemez)
22:57:39 <mysticc> Is there anyway to splice declarations inside where?
22:57:55 <mysticc> whenever I try something it results in parse error
22:58:47 <donri> @hpaste an example
22:58:48 <lambdabot> Haskell pastebin: http://hpaste.org/
23:02:43 <beaky> hlelo
23:02:45 <beaky> hello*
23:16:31 <neutrino_> is it ok to use withAsync to spin up threads which will not return anything meaningful, and which will be alive for the duration of the computation that withAsync brackets?
23:17:15 <neutrino_> e.g. a separate worker thread that expects input from that computation
23:20:48 <lispy> mysticc: splice as in template haskell?
23:53:58 * hackagebot Network-NineP 0.1.1 - High-level abstraction over 9P protocol  http://hackage.haskell.org/package/Network-NineP-0.1.1 (SergeyAlirzaev)
