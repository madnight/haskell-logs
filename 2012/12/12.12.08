00:09:53 <kini> <shachaf> For example, "last [1..100000000]" runs in <3 seconds allocates 8GB.
00:09:53 <kini> why can't that be instantaneous?
00:12:44 <Rogach> kini: Optimizer is not that smart, probably.
00:13:37 <kini> I mean, last is defined by pattern matching against lists, but could you pattern match against the [a..b] constructor (if that's what it's called) somehow?
00:14:13 <kini> http://www.haskell.org/ghc/docs/latest/html/libraries/base-4.6.0.0/src/GHC-List.html#last
00:14:25 <Jafet> It is not a constructor
00:14:37 <Jafet> > last $ enumFromTo 1 1000000
00:14:38 <kini> is the problem that it's desugared too early?
00:14:39 <lambdabot>   1000000
00:15:18 <kini> oh, it's just sugar for a function call
00:15:24 <kini> that makes sense
00:16:04 <kini> and I guess you can't match against arbitrary expressions like that
00:16:16 <kini> > let f (enumFromTo a b) = b
00:16:18 <lambdabot>   <hint>:1:8: Parse error in pattern: enumFromTo
00:16:22 <Jafet> *cough* mathematica *cough*
00:16:27 <kini> hm?
00:17:39 <Jafet> Expressions do not exist when Haskell performs computation.
00:18:34 <Jafet> There are some languages where they do, and they are terrible languages as a result. But then you can pattern-match expressions.
00:19:22 <mgsloan> Hmm, why doesn't "RebindableSyntax" allow you to overload [f .. t] ?
00:20:37 <shachaf> kini: A list is like a loop.
00:21:07 <kini> shachaf: I think Jafet answered my true question :)
00:21:11 <Jafet> A functor is like an analogy
00:21:20 <kini> I do have a little mathematica background, I'll admit it haha
00:21:56 <kini> Jafet: can you elaborate a bit on why having expressions at computation time is a terrible thing?
00:21:59 <kini> efficiency problems?
00:22:09 <kini> it seems like the ultimate laziness to me
00:22:17 <Jafet> But why? It's just enumFromTo.
00:22:44 <kini> so that you can evaluate last [1..100000000000000000000000000000000000000000000000000000000] instantly, of course :)
00:22:52 <Jafet> kini: because every well-behaved function that pattern matches a list has to match every pattern
00:23:14 <Jafet> List has two patterns
00:23:34 <Jafet> Imagine if it had twenty patterns
00:23:39 <Jafet> You get mathematica
00:23:40 <kini> Well, you could just say that expressions are additional, optional patterns that you could match against if you want to
00:23:58 <kini> you can have overlapping patterns after all
00:23:59 <shachaf> That sounds awful.
00:24:13 <shachaf> You get no guarantees about the behavior of a function that way.
00:24:51 <kini> doesn't stream fusion require some GHC pragmas that essentially do pattern matching of expressions? (from the extremely little I've heard about stream fusion)
00:24:52 <shachaf> What if I write my own enumFromTo which behaves identically to the regulr one? Will it get a different behavior?
00:25:15 <shachaf> Yes, GHC has rewrite rules, but those are on a different level from function definitions themselves.
00:25:17 <Jafet> data SuperList a = Nil | Cons a (SuperList a) | Snoc (SuperList a) a | Tree (SuperList a) (SuperList a) | Range a a (Maybe a)
00:25:33 <Jafet> toRegularList :: SuperList a -> [a]
00:25:38 <Jafet> {-# LANGUAGE ViewPatterns #-}
00:25:39 <Jafet> done
00:26:06 <shachaf> Sounds like a fun type.
00:26:47 <Jafet> It's the toe tree
00:26:52 <Jafet> You can stub your foot with it
01:00:03 * hackagebot timeout-with-results 0.1.1 - Runs a time-limited computation alowing it to return intermediate results.  http://hackage.haskell.org/package/timeout-with-results-0.1.1 (PetrPudlak)
01:25:04 * hackagebot fullstop 0.1.3.1 - Simple sentence segmenter  http://hackage.haskell.org/package/fullstop-0.1.3.1 (EricKow)
01:27:56 <path[l]> is there something like zipWith for 2 arrays where the number of elements i get is the length of the longer array not the shorter array
01:28:17 <shachaf> By array do you mean array?
01:28:29 <path[l]> oh no sorry, I mean list
01:28:34 <shachaf> OK.
01:28:39 <shachaf> What should it do with leftover elements?
01:29:14 <path[l]> good question. I guess it could ask me to provide a default element
01:29:34 <shachaf> Seems like a somewhat specialized thing compared to zipWith
01:30:52 <path[l]> ah I was hoping it might be common enough that there would be something built in
01:30:53 <warpy> hello there path[l]
01:31:08 <path[l]> Im reading some code where someone has implemented such a function from scratch
01:31:11 <path[l]> hey warp
01:31:35 <warpy> just append your shorter list with (repeat 'default')
01:31:49 <shachaf> If you know which list is shorter that works.
01:31:58 <warpy> and use zipWith
01:32:07 <path[l]> yeah, I wouldnt know that. And also I would need to know the lengths
01:32:26 <shachaf> Well, you only need to know which one is shorter.
01:32:33 <shachaf> But unfortunately it's not so easy when you don't.
01:32:42 <path[l]> ah yes, I could append it with infinite elements
01:32:48 <shachaf> You can just write it out yourself easily enough.
01:32:50 <shachaf> @src zipWith
01:32:50 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
01:32:50 <lambdabot> zipWith _ _      _      = []
01:46:30 <path[l]> warpy: some haskell golf for it?
01:54:31 <warpy> path[l]: zipWith (+) longList (shortList ++ repeat 0)
01:54:47 <path[l]> nah that's not the signature
01:54:48 <warpy> @type repeat
01:54:49 <lambdabot> a -> [a]
01:54:50 <path[l]> the signature is
01:55:07 <path[l]> f zipFn l1 l2 defaultElement
01:55:14 <path[l]> l1 or l2 might be the shortList
01:55:38 <warpy> i dont think there is such a funtion
01:55:49 <warpy> you'll have to write it yourself
01:56:04 <`ramses> you'll need to default elements unless the lists are both of the same type
01:56:08 <`ramses> s/to/two
01:56:27 <warpy> that too ^
01:58:24 <Jafet> :t \f xs ys a -> zipWith3 (const . const) ((zipWith f `on` (++ repeat a)) xs ys) xs ys
01:58:25 <lambdabot> (c -> c -> d) -> [c] -> [c] -> c -> [d]
01:58:40 <Jafet> That's probably wrong
01:59:07 <`ramses> Jafet: then the result is always infinite
02:00:03 <`ramses> ah no it isn't
02:00:39 <`ramses> seems to cut off the longer list though
02:02:26 <`ramses> :t zipWith3 (const . const)
02:02:27 <lambdabot> [d] -> [b] -> [c] -> [d]
02:02:42 <`ramses> that just discards the second and third parameters
02:13:41 <Jafet> :t \f xs ys a -> map (uncurry f . join (***) (fromMaybe a)) $ takeWhile (uncurry (||) . join (***) isJust) $ (zip `on` ((++ repeat Nothing) . map Just)) xs ys
02:13:42 <lambdabot> (b1 -> b1 -> b) -> [b1] -> [b1] -> b1 -> [b]
02:13:49 <Jafet> I think I'm not golfing any more
02:19:24 <FireFly> @pl \x -> (x,x)
02:19:25 <lambdabot> join (,)
02:21:25 <burrows> Anyone have an article that talks about expressing procedural ideas in Haskell?
02:22:04 <burrows> Maybe that's a nonsequitor idk
02:24:19 <Jafet> Nonsequitors, a less harmful species of mosquitors
02:27:08 <neutrino> hey guys
02:27:30 <neutrino> i've just had the greatest idea ever
02:27:44 <burrows> Haskell flavored cereal?
02:28:08 <Nereid> curry flavoured cereal?
02:28:29 <neutrino> quite often i want to string up some functions using the bind operator, or using the dot, etc, but the function being used has several parameters and the one i want to be passed into is not the last one
02:29:03 <neutrino> so i'll have to end up doing something like \x -> foo bar x baz quux
02:29:19 <neutrino> what if you could just go and do foo bar _ baz quux
02:29:40 <neutrino> no need for verbose syntax
02:29:50 <neutrino> because it's obvious where to plug the values in
02:30:32 <Nereid> no
02:30:39 <Jafet> This doesn't _ like a _ idea. (How would you _ where each _ _?)
02:30:49 <Nereid> I've suggested something like this before. and this problem ^
02:30:57 <neutrino> it goes from left to right
02:31:07 <neutrino> and if you want them out of order you do __ instead of _
02:31:37 <neutrino> so (foo __ _ _) x y z == foo z x y
02:31:44 <Nereid> gross
02:31:47 <neutrino> sure
02:31:54 <neutrino> but at this point you're really misusing the syntax
02:31:59 <neutrino> so it's not like you'd ever get to see it
02:32:11 <Nereid> ok
02:32:16 <neutrino> it's mostly for the cases where there's one, maybe two parameters you want to put in a lambda
02:32:27 <neutrino> sure you can do fifty
02:32:36 <Nereid> well then (f a _) b and f a _ b mean different things now
02:32:39 <neutrino> but you can do ugly stuff in haskell already
02:32:46 <Nereid> er, f _ a
02:32:58 <Nereid> oh no, either way.
02:33:07 <neutrino> hmm yeah
02:33:12 <neutrino> i wonder how that could be solved?
02:33:23 <Nereid> by forgetting the whole idea and using lambdas
02:33:27 <neutrino> nah
02:33:33 <neutrino> that's not cool
02:33:39 <Nereid> just use flip a bunch
02:33:46 <Nereid> flip (flip . f) x y z = f y z x
02:33:48 <neutrino> lol
02:33:55 <neutrino> that's the exact problem
02:34:02 <neutrino> it's very verbose and confusing
02:34:22 <Nereid> :t flip (flip .)
02:34:23 <lambdabot> b -> (b -> a -> b1 -> c) -> b1 -> a -> c
02:34:30 <Nereid> er
02:34:37 <Nereid> :t (flip .) (flip .)
02:34:38 <lambdabot> (a -> a1 -> b -> c) -> b -> a -> a1 -> c
02:34:41 <Nereid> :t (flip .) (flip .) (flip .)
02:34:43 <lambdabot> b -> (a -> a1 -> b -> c) -> a -> a1 -> c
02:34:46 <Nereid> hmm
02:34:47 <Nereid> :t (flip .) (flip .) (flip .) (flip .)
02:34:49 <lambdabot> Functor f => (a -> a1 -> (f (a2 -> b -> c1) -> f (b -> a2 -> c1)) -> c) -> a -> a1 -> c
02:34:55 <Nereid> hmm
02:34:56 <neutrino> haha
02:34:59 <neutrino> see
02:35:01 <Jafet> Well done
02:35:07 <Nereid> :t fix flip
02:35:09 <lambdabot> a -> a -> c
02:35:11 <neutrino> you've given lambdabot a hernia
02:35:26 <Nereid> :t (flip.)(flip.)(flip.)(flip.)(flip.)(flip.)
02:35:27 <lambdabot> Functor f => (a1 -> a2 -> (f (a -> b -> c) -> f (b -> a -> c)) -> c1) -> a1 -> a2 -> c1
02:35:33 <Nereid> no thanks
02:36:20 <neutrino> hey can you make infix constructors?
02:36:27 <Nereid> sure
02:36:33 <Nereid> just start them with a capital symbol
02:36:47 <neutrino> what's a capital symbol
02:36:49 <Nereid> :
02:36:55 <neutrino> ?
02:36:59 <neutrino> : is a capital symbol?
02:37:01 <Nereid> yes
02:37:08 <neutrino> why?
02:37:13 <Nereid> because it just is
02:37:18 <neutrino> heh
02:37:30 <Nereid> you can make constructor operators as long as their names start with :
02:37:33 <neutrino> that's cool. where is that specified?
02:37:41 <Nereid> presumably the report
02:37:48 <neutrino> i guess
02:37:58 <Nereid> consym     →     ( : {symbol})
02:38:09 <neutrino> can i create a constructor which returns a constructor?
02:38:11 <neutrino> like
02:38:23 <Nereid> constructors return values of your data type, so no?
02:38:31 <neutrino> i'm wondering if i could do that hole thing with constructors
02:38:44 <Nereid> a partially applied constructor?
02:38:48 <Nereid> is just a function
02:38:58 <neutrino> right
02:39:05 <neutrino> i guess i would need a variadic function
02:39:10 <Nereid> no
02:39:21 <Nereid> I need sleep.
02:39:29 <Nereid> I don't know how I haven't passed out yet.
02:39:32 <Nereid> anyway bye.
02:39:35 <neutrino> bye
02:39:40 <neutrino> take care Nereid
02:43:04 <ocharles> hi, can anyone see what I'm missing in https://gist.github.com/83f7b8c693db78b2ea6b ? I'm trying to profile my test suite, but I get a build error about needing to build the program twice
02:43:08 <ocharles> but afaik, I have
02:44:38 <burbul> Would it be straightforward to rewrite this in a parser monad of some kind?
02:44:39 <burbul> http://hpaste.org/78949
02:44:51 <neutrino> what are the commands you have been using, ocharles?
02:45:05 * hackagebot mpppc 0.1.3 - Multi-dimensional parametric pretty-printer with color  http://hackage.haskell.org/package/mpppc-0.1.3 (DarinMorrison)
02:45:36 <neutrino> burbul: show us some inputs and outputs
02:46:29 <ocharles> neutrino: they are in that paste
02:49:04 <burbul> They've been stuck in
02:49:15 <burbul> I'm not looking for actual modified code, just what I'd use to make the changes
02:49:27 <burbul> I'm glueing together a lot of functions of the kind
02:49:37 <burbul> [a] -> ([a], [a])
02:49:40 <burbul> Which feels very nomadic
02:49:43 <burbul> *monadic
02:50:43 <burbul> Possibly I can use Parsec, but I've never tried using it on anything except strings...
02:51:10 <nunquam> what is the best way to get the heads of the lists in one list in a list :p?
02:51:13 <bitonic> burbul: yes you’re using the State monad
02:51:27 <nunquam> [[1],[2,3],[3,4,5]] -> [1,2,3]
02:51:37 <burbul> map head?
02:51:47 <nunquam> does that work?
02:51:59 <nunquam> mmm guess so :d
02:52:09 <burbul> bitonic: it feels more specialised, but I guess so!
02:53:13 <burbul> How would I go about using Parsec?
02:53:18 <bitonic> burbul: State = s -> (a, s)
02:53:39 <burbul> to do ti
02:53:57 <burbul> Presumably I just have to supply the right s, u in
02:54:00 <burbul> Parsec s u
02:54:16 <bitonic> burbul: well Parsec uses a specialised state.  but you could easily lift your code to use the State in `transformers'
02:54:33 <burbul> could I just write
02:54:39 <burbul> Parsec [State] ()
02:54:40 <burbul> ?
02:54:59 <burbul> sorry
02:55:08 <neutrino> ocharles: sorry, i'm a bit sleepy. well, the error says you should be using -osuf, which is missing from your command line.
02:55:08 <burbul>  Parsec [Entry] ()
02:55:14 <neutrino> ocharles: maybe you need that?
02:55:18 <ocharles> neutrino: i have no idea what to put there
02:55:23 <ocharles> i'm sure i've never had to do that
02:55:27 <burbul> where Entry is the type of things Im dealing with
02:55:29 <bitonic> burbul: with Parsec you use Parsec’s own *parser* state, and you can also carry around some separate state
02:55:35 <bitonic> but you probably don’t need to
02:55:42 <burbul> no, i dont
02:55:44 <neutrino> ocharles: well normally the object file suffix is "o"
02:55:46 <burbul> hence ()
02:56:02 <neutrino> and ghc probably needs to have both profiled and unprofiled object files to profile, or something.
02:56:04 <bitonic> burbul: yes, () sounds fine
02:56:09 <neutrino> so i suggest you just do "op"
02:56:12 <neutrino> and then go from that
02:56:29 <ocharles> neutrino: ack, I forget to --make
02:56:40 <ocharles> i think that's it
02:56:51 <neutrino> ah
02:57:02 <ocharles> nope :(
02:57:04 <neutrino> well, i also noticed this here: http://www.haskell.org/ghc/docs/7.0.1/html/users_guide/separate-compilation.html
02:57:11 <neutrino> if you search for prof.o
02:57:53 <cordawyn> Hello everybody! I'm trying to write a code to compare "Network.HTTP.Response"s. I've just added "instance Eq (Response a)" (no explicit imlementation of the comparison apart from that).
02:58:14 <neutrino> all of that in just a single code? you're good.
02:58:21 <cordawyn> then I do:
02:58:25 <cordawyn> r1 = Response (2,0,0) "OK" [] "HELLO"
02:58:29 <cordawyn> r2 = Response (2,0,0) "OK" [] "HELLO"
02:58:47 <cordawyn> and "r1 == r2" drives GHC into an infinite loop, with 100% CPU load
02:59:38 <cordawyn> it is a bug, or should I have implemented the details of comparison? or anything else?
02:59:50 <neutrino> i think you need to implement the class.
03:00:06 <neutrino> but i'm not sure.
03:00:18 <neutrino> it doesn't seem too difficult anyways, it's just a simple record.
03:00:49 <ocharles> neutrino: http://www.haskell.org/ghc/docs/6.10.2/html/users_guide/template-haskell.html 8.9.4 :)
03:00:53 <ocharles> that was my problem
03:01:03 <cordawyn> ok, I'll give it a try
03:01:05 <cordawyn> thanks, neutrino
03:01:08 <neutrino> yw
03:01:15 <neutrino> wish i could help more, but i'm a newbie
03:01:59 <statusfailed> Anybody used the hastache package? I'm not sure how to use sum types in templates
03:03:16 <neutrino> ocharles: yep, just what i thought :)
03:03:20 <statusfailed> it's probably something to do with how generics works with sum types but i'm lost after that
03:03:23 <neutrino> ocharles: but it's good to know the reason, not just the fix
03:05:07 <neutrino> statusfailed: what sort of data have you tried passing to the template?
03:05:13 <neutrino> a record in a record or something like that?
03:06:18 <statusfailed> neutrino: it's lots of nested records, but everything is working except "Maybe a" values. I will try to do a simple example
03:06:40 <statusfailed> my template for the maybe fields was just {{fieldname}}, I also tried {{fieldname.Just}} but that was just a shot in the dark
03:07:36 <neutrino> uhh, templates like this often also use the pipe for passing through functions
03:08:07 <neutrino> you could try something like {{whatever|foo}}, with foo x = y where Just y = x
03:08:28 <neutrino> also a guess
03:09:50 <statusfailed> Hmm, I was hoping to avoid using functions, but that might be the only way
03:09:58 <statusfailed> i'll try the pipe tho
03:10:02 <merijn> cordawyn: Eq has default implementation for == and /=, but they are just "a == b = not (a /= b)" and "a /= b = not (a == b)", so unless you define either == or /= it'll loop infinitely
03:10:39 <merijn> cordawyn: You could use standalone deriving if you don't want to implement the Eq class yourself
03:11:18 <neutrino> i've been wondering what that's called
03:11:32 <neutrino> that's a ghc ext, isn't it?
03:11:53 <neutrino> statusfailed: only a shot in the dark.
03:14:23 <neutrino> the nop in IO is return (), right?
03:14:33 <neutrino> :t void
03:14:34 <lambdabot> Functor f => f a -> f ()
03:14:37 <neutrino> right
03:14:55 <cordawyn> thanks, merijn
03:15:25 <statusfailed> haha, the number of times i've rewritten void...
03:15:42 <neutrino> yeah it's a good thing to know.
03:21:12 <hiptobecubic> @src void
03:21:13 <lambdabot> Source not found.
03:21:21 <neutrino> hey guys, has anyone here got a hackage login?
03:21:22 <hiptobecubic> Where is void defined?
03:21:33 <neutrino> @hoogle void
03:21:33 <lambdabot> Foreign.Marshal.Error void :: IO a -> IO ()
03:21:34 <lambdabot> Control.Monad void :: Functor f => f a -> f ()
03:21:34 <lambdabot> package void
03:21:39 <hiptobecubic> oh right, hoogle
03:21:53 <neutrino> @hoogle Monad m => m a -> m ()
03:21:53 <lambdabot> Control.Monad replicateM_ :: Monad m => Int -> m a -> m ()
03:21:53 <lambdabot> Control.Monad forever :: Monad m => m a -> m b
03:21:53 <lambdabot> Prelude sequence_ :: Monad m => [m a] -> m ()
03:22:04 <neutrino> that didn't work out that well
03:22:10 <neutrino> @hoogle+
03:22:10 <lambdabot> Control.Monad sequence_ :: Monad m => [m a] -> m ()
03:22:10 <lambdabot> Data.Foldable sequence_ :: (Foldable t, Monad m) => t (m a) -> m ()
03:22:10 <lambdabot> Data.Data fromConstrM :: (Monad m, Data a) => (forall d. Data d => m d) -> Constr -> m a
03:22:24 <neutrino> still nothing. but it tips you off that what you're looking for might be in Control.Monad.
03:22:31 <hiptobecubic> too specific i guess
03:22:38 <neutrino> so then you can look on hackage and find void.
03:22:45 <hpaste> nunquam pasted “No instance for Show arising from print?” at http://hpaste.org/78951
03:22:50 <neutrino> well, the actual type is Functor f => f a -> f ()
03:22:55 <nunquam> Hi :)
03:23:06 <nunquam> any ideas why I'm getting this: http://hpaste.org/78951
03:23:15 <nunquam> No instance for (Show ([a0] -> [a0]))
03:23:15 <nunquam>       arising from a use of `print'
03:23:20 <statusfailed> neutrino: yeah, I do, what's up?
03:23:47 <hiptobecubic> fmap (const ()), easy enough
03:23:53 <neutrino> statusfailed: how long did you have to wait to get it?
03:24:01 <statusfailed> neutrino: not sure, i'll check
03:24:07 <mSSM> Can I use a foldl to enumerate a list? I.e. transform ['a','b','c'] into [(1,'a'),(2,'b'),(3,'c')] ?
03:24:09 <statusfailed> I don't think long though, maybe a week or so?
03:24:10 <nunquam> a listcomprehension returns a list doesn't it?
03:24:11 <neutrino> nunquam: right
03:24:21 <nunquam> ok.. :p
03:24:30 <neutrino> nunquam: you have a function of type foo :: a -> b -> c
03:24:53 <nunquam> yes
03:24:59 <neutrino> if the type c supports the typeclass Show, then you should be able to print out foo x y
03:25:05 <neutrino> because foo x y has type c
03:25:12 <neutrino> however, you are printing out foo x
03:25:15 <neutrino> which as type b -> c
03:25:23 <neutrino> this means it's still waiting for one more parameter
03:25:38 <neutrino> that's why it says: no instance for Show b -> c
03:25:39 <hiptobecubic> void is a bit strange though
03:25:46 <nunquam> hmmm
03:25:50 <neutrino> ghci doesn't know how to print out a function
03:25:52 <nunquam> I'm trying to get what you are saying
03:26:00 <hiptobecubic> When would you need it, as written?
03:26:10 <neutrino> read it 10 times, it's difficult at first
03:26:31 <neutrino> hiptobecubic: any time you want to throw away the result of a computation that has side effects.
03:26:56 <neutrino> hiptobecubic: useful for any monad that has side effects (writer, state, io, ...)
03:27:39 <neutrino> nunquam: let's start with something simpler
03:27:41 <nunquam> neutrino the reason why I'm getting this is because I call isRealFirst in the list comprehension? which has type a->a->Bool?
03:27:47 <neutrino> no
03:27:51 <nunquam> k
03:27:53 <hiptobecubic> neutrino, but what do you gain? It still returns f () which you have to match or do something with
03:27:55 <neutrino> it's because you only applied your function only partially
03:28:04 <neutrino> do you know what partial application is? i was just going to ask you
03:28:17 <neutrino> hiptobecubic: it's for syntax in do
03:28:17 <hiptobecubic> Why not just leave the result as it is and not use it
03:28:17 <nunquam> only applied to a part of the list?
03:28:28 <neutrino> nunquam: nope
03:28:50 <nunquam> oh you mean the lazy evaluation? that only some part is evaluated?
03:28:51 <neutrino> nunquam: functions in haskell that have several parameters can get "applied partially"
03:28:58 <neutrino> no, not that either
03:29:02 <neutrino> different concept
03:29:10 <neutrino> functions in haskell that have several parameters can get "applied partially"
03:29:14 <nunquam> ok I get partially i thin
03:29:16 <neutrino> so if you have e.g. a function of 3 parameters
03:29:32 <neutrino> let's say, it's foo x y z
03:29:45 <nunquam> yes and a return parameter
03:29:52 <neutrino> there's no return parameter
03:30:03 <nunquam> thats the z I mean :s
03:30:10 <nunquam> sry
03:30:10 <nunquam> ok
03:30:15 <neutrino> foo x y z has three parameters, you pass them to the function
03:30:24 <neutrino> for exampl, foo x y z = x + y + z
03:30:34 <nunquam> k
03:30:40 <neutrino> now if in your code you write "foo 1 2", then you have partially applied that function
03:30:49 <neutrino> call that bar:       let bar = foo 1 2
03:30:58 <nunquam> ok
03:31:05 <nunquam> the z isnt applied then?
03:31:06 <neutrino> this is a new function. of one parameter.
03:31:10 <neutrino> no, z isn't applied yet
03:31:17 <neutrino> now you can do: bar 20
03:31:22 <neutrino> and it'll evaluate to 23
03:31:33 <hiptobecubic> > do x <- [1,2,3]; y <- [4,5,6]; return x+y
03:31:35 <lambdabot>   No instance for (GHC.Num.Num [b0])
03:31:35 <lambdabot>    arising from a use of `e_1123456'
03:31:35 <lambdabot>  Po...
03:31:51 <hiptobecubic> oh, infix
03:31:57 <hiptobecubic> > do x <- [1,2,3]; y <- [4,5,6]; return (x+y)
03:31:59 <lambdabot>   [5,6,7,6,7,8,7,8,9]
03:32:13 <neutrino> hiptobecubic: try /msg lambdabot
03:32:16 <neutrino> nunquam: 1 sec
03:32:27 <Jafet> @@ @pl @undo do x <- [1,2,3]; y <- [4,5,6]; return (x+y)
03:32:27 <lambdabot>  (`fmap` [4, 5, 6]) . (+) =<< [1, 2, 3]
03:32:29 <hiptobecubic> neutrino, i was going to use it to ask a question, but then i answered it myself immediately
03:32:57 <neutrino> haha
03:33:01 <nunquam> hmm
03:33:01 <neutrino> yeah it does happen a lot
03:33:16 <hiptobecubic> what is @@?
03:33:18 <hiptobecubic> unpl?
03:33:26 <hiptobecubic> no clearly not
03:33:28 <nunquam> so are you saying that with my list comprehension I'm only partially applying the parameters?
03:34:14 <nunquam> actually, can this be done with a list comprehension..?
03:34:45 <neutrino> nunquam: yes. notice that you defined headEveryList2 to take two parameters, "list" and "possible", but you're only passing in "list"
03:35:16 <nunquam> herp :D
03:35:27 <neutrino> it takes long to explain why this is happening
03:35:34 <nunquam> oh
03:35:35 <neutrino> but now you understand the error message
03:35:40 <nunquam> thanks :D
03:35:43 <neutrino> yw
03:35:45 <hiptobecubic> ok so @@ is for nesting @ commands it seems
03:35:49 <nunquam> you also could have told I forgot a paramater :D
03:35:58 <neutrino> no, that wouldn't have been educational
03:36:01 <nunquam> but I think I know "partially" :D understand the error
03:36:04 <nunquam> thx
03:36:05 <neutrino> and would have done more damage than good
03:36:20 <neutrino> there's a good bit of background here: http://learnyouahaskell.com/higher-order-functions#curried-functions
03:36:23 <neutrino> read it
03:37:28 <neutrino_> the key is in the statement "Every function in Haskell officially only takes one parameter"
03:37:44 <neutrino_> once you understand it, you learn a great deal more about practical aspects of haskell
03:37:56 <neutrino_> for example, you can then use "map" much more effectively
03:38:12 <neutrino_> > map (+ 2) [1, 2, 3]
03:38:14 <lambdabot>   [3,4,5]
03:38:21 <hiptobecubic> neutrino_, you have a growth on your nick.
03:38:24 <neutrino_> here you can see + is partially applied
03:38:33 <neutrino_> hiptobecubic: i like it.
03:38:49 <neutrino_> i embrace it as part of me.
03:39:00 <hiptobecubic> people will stare
03:39:32 <neutrino_> only insincere ones.
03:39:40 * hiptobecubic gives neutrino_ a turtlenick
03:40:04 <neutrino_> how does that work?
03:40:36 <burrows> Insincere people always flattering my insecurities.
03:41:10 <hiptobecub--> It's a bit stuffy i guess
03:41:58 <neutrino_> oh, yeah.
03:42:42 * hiptobecubic prefers being nude
03:51:03 <`ramses> hiptobecubic: looks like @@ is like @-command composition :)
03:51:49 <`ramses> an infix version would be nice, like @pl @. @undo
03:52:39 <Daroth> re
03:53:13 <hiptobecubic> @@ @pl @unpl @pl @undo do x <- [2,3]; y <- [3,4]; z <- [2,6]; replicate 4 (z+y*x)
03:53:13 <lambdabot>  ([3, 4] >>=) . ((([2, 6] >>=) . (replicate 4 .) . (+)) .) . ((*) =<< [2, 3])
03:53:38 <hiptobecubic> it composes the list, but with no explicit list
03:53:45 <hiptobecubic> constructor, that is
03:54:42 <neutrino_> hiptobecubic: yeah, you can pl and unpl a lot. it's fun.
03:54:44 <`ramses> ah, indeed, it's like foldr (.) id for functions
03:55:07 <neutrino_> hiptobecubic: i have commands in vim that do pl and unpl on the line currently being edited.
03:55:22 <`ramses> > foldr1 (.) [(+2), (*3)] 5
03:55:24 <lambdabot>   17
03:55:36 <hiptobecubic> i might as well, i haven't really used them so I forgot what they are
04:06:40 <mSSM> For a definition like this: sum' = M.foldl' (+) 0   why is a type like sum' :: M.Map -> Int  wrong?
04:06:53 <mSSM> ghci tells me it expects two more arguments
04:07:02 <mSSM> Oh
04:07:06 <merijn> :t M.foldl'
04:07:07 <lambdabot> (a -> b -> a) -> a -> M.Map k b -> a
04:07:10 <mSSM> I need to be more explicit about Map?
04:07:12 <mSSM> yeah
04:07:14 <mSSM> shit
04:07:49 <mSSM> merijn: how can I write a general sum' function then, where I am not specific about the type of the k?
04:07:49 <merijn> M.Map k Int -> Int is what you want, probably
04:08:10 <mSSM> merijn: Numeric b => ?
04:08:12 <merijn> mSSM: You just specify a type variable as key? :p
04:08:14 <Fuuzetsu> @pl f x y = (x, y, x + y, x * y)
04:08:15 <lambdabot> f = ap (ap . liftM2 ap (,,,) (+)) (*)
04:08:21 <Fuuzetsu> not even once
04:08:39 <merijn> mSSM: Well, if you want to return Int then the values will have to be Int too, with (+)
04:08:43 <Fuuzetsu> :t (,,,)
04:08:44 <lambdabot> a -> b -> c -> d -> (a, b, c, d)
04:08:49 <Fuuzetsu> awesome
04:09:15 <merijn> mSSM: You can either write "Num a => M.Map k a -> a" or "M.Map k Int -> Int"
04:09:44 <mSSM> merijn: cool, I thought haskell would need to know k
04:10:02 <mSSM> merijn: I did that now; thanks :)
04:10:26 <merijn> mSSM: It'll infer/unify the k when you try to apply it to a concrete map
04:11:38 <merijn> mSSM: "M.Map k Int" is conceptually similar to writing something like "[(a, Int)]", there's no real reason why ghc needs to know which k, unless you planned to do something with the k
04:12:17 <mSSM> merijn: makes sense; it's hard to remember all those things when freshly starting off with haskell :)
04:12:36 <mSSM> + all the monadic madness
04:15:56 <merijn> mSSM: You can think of the type checker as a kind of equation solver, in the resulting end code it will try to fill in all type variables in a way that is non-conflicting and non-ambiguous, if there's no way to do that, it complains. Type variables which are only thrown away (like the k here) can of course be trivially matched to whatever value as there is no other use of them that could result in conflicts/ambiguity
04:18:33 <mSSM> If I use (!) from Data.Map as comprade to lookUp, the difference is that the latter is monadic, and the former just crashes the whole program when it fails to find the value, right?
04:19:03 <merijn> :t M.(!)
04:19:04 <lambdabot> Not in scope: data constructor `M'
04:19:30 <merijn> :t Data.Map.(!)
04:19:31 <lambdabot> Couldn't find qualified module.
04:19:40 <merijn> :t Data.Map.Lazy.(!)
04:19:42 <lambdabot> Not in scope: data constructor `Data.Map.Lazy'
04:20:07 <merijn> mSSM: What do you mean by the latter is monadic?
04:21:05 <mSSM> merijn: it gives a MAybe
04:21:07 <mSSM> Maybe*
04:23:00 <merijn> I don't know any kind of common definition of the term monadic that I'd really associate with that
04:23:41 <merijn> mSSM: Better terms would be partial vs total, where partial refers to a function that might crash/infinite loop on some inputs, whereas a total function always returns
04:24:11 <AtomicStryker> heya folks, some more questions about harkell looming :D
04:25:19 <AtomicStryker> say i have a datatype, which contains a named field of a list of another datatype, which contains a named field of a list of another datatype :D :D
04:25:54 <AtomicStryker> is there a smart way to iterate / change the values of the bottommost datatype
04:26:06 <AtomicStryker> when given an instance of the top datatype
04:26:46 <merijn> AtomicStryker: i.e. you wanted to do nested updates?
04:26:59 <AtomicStryker> yes please
04:27:03 <merijn> AtomicStryker: The answer is lenses
04:27:28 * Fuuzetsu has had the lenses video open for the last 3 days
04:27:30 <AtomicStryker> to the google mobile!
04:27:38 <merijn> AtomicStryker: Lenses are basically composable getter/setters, the main popular library atm is Control.Lens
04:27:51 <merijn> AtomicStryker: But to call Control.Lens intimidating would be a major understatement
04:27:58 <edwardk> merijn: =/
04:28:11 <merijn> edwardk: Ha, try and claim otherwise!
04:28:27 <edwardk> its getting better. i'm working on a pretty little website that tries to make it look like puppies and rainbows ;)
04:28:40 <merijn> AtomicStryker: Personally I think Data.Lens is still rather neat for simple cases and easier to learn and once you grok that moving to Control.Lens is significantly easier
04:29:10 <AtomicStryker> i wondered: is grok something patterson came up with, or did he steal it from somewhere
04:29:16 <merijn> edwardk: Once you get the basic lens idea you can get around, but I think Data.Lens is more conducive to grokking the basic lens thing before all the neat things
04:29:32 <merijn> AtomicStryker: Common hacker term, originates in Stranger in a Strange Land from Heinlein
04:29:41 <AtomicStryker> ah, that book is quoted multiple times
04:29:46 <AtomicStryker> should read it someday
04:29:56 <edwardk> merijn: part of the motivation for my talk on wednesday is to help people get their head around lens without detouring through data-lens
04:30:21 <Fuuzetsu> Are you giving another talk?
04:30:27 <Fuuzetsu> Will there be a video?
04:30:40 <edwardk> Yes. I'm giving a talk in New York in Wednesday on the new lens library. There will be video
04:30:50 <Fuuzetsu> cool
04:31:00 <edwardk> We have something like 96 people signed up at last check
04:31:05 <merijn> AtomicStryker: http://www.catb.org/~esr/jargon/html/G/grok.html
04:31:10 <Fuuzetsu> we mainstream now
04:31:14 <hiptobecubic> quite a lot
04:31:27 <hiptobecubic> or maybe lens is just damn confusing
04:31:32 <hiptobecubic> :)
04:31:39 <edwardk> We had just under a hundred in San Francisco.
04:31:51 <edwardk> and most of them had no idea lens even existed before the talk ;)
04:31:59 <merijn> All the cool Haskell talks are across the pond :(
04:32:13 <hiptobecubic> You're just a celeb then?
04:32:58 <edwardk> i just talk a lot, some times people like to listen ;)
04:33:47 <`ramses> edwardk: are you doing talks in europe as well? :)
04:33:57 <edwardk> fly me over, i'll give a talk
04:34:16 <`ramses> ok, so nothing planned ;)
04:34:34 <Fuuzetsu> Will you whisper gently about lenses into my ear over a candlelight supper?
04:34:39 <edwardk> not currently =)
04:34:59 <edwardk> well i suppose if you buy me dinner. it'd have to be a really nice dinner to get me to go that far on the first date.
04:35:18 <Fuuzetsu> I foldl' on the first day.
04:35:22 <Fuuzetsu> date*
04:36:19 <osa1> does anyone here use vim for editing haskell with vim2hs plugin ? I'm having trouble with syntax highligter. when it's on and I have a long array on screen(ie an array that spans multiple lines), it gets so slower to render that I almost can't even move the cursor. is there a fix for that ?
04:36:38 <Fuuzetsu> Shorter arrays.
04:37:39 <`ramses> osa1: why are you writing such arrays in your code?
04:40:14 <osa1> `ramses: I'm not writing them by hand. alex generates them. and some other code generators. even if I write them it's not important why I'm writing. they're needed and some code I've been editing have them.
04:40:41 <osa1> and I think it's an issue with syntax highlighter because when I turn off highlighter it gets faster
04:43:25 <johkke> What is the fastest way to check if an array is filled with empty arrays?
04:43:52 <osa1> johkke: all . null ?
04:43:52 <johkke> I want my function to be like: oorsprong [[],[],...] = ...
04:45:07 <osa1> > all null [[], [], []]
04:45:09 <lambdabot>   True
04:45:22 <johkke> haha :D
04:45:26 <johkke> Thanks! :)
04:45:41 <osa1> johkke: btw, null is in Data.List
04:50:00 <hpaste> nil pasted “I am a terrible person” at http://hpaste.org/78954
04:51:46 <ocharles> don't you mean 'instance Cata Bool'?
04:52:33 <`ramses> osa1: ah ok, didn't think about generators :)
04:55:30 <hpaste> nil annotated “I am a terrible person” with “I am a terrible person (annotation)” at http://hpaste.org/78954#a78955
04:56:31 <fmap> I don't get the point of newtype over the tuple
04:56:53 <nil_0> I didn't want to use LiberalTypeSynonyms.
04:57:23 <nil_0> You can't have partially evaluated type synonyms otherwise.
04:57:31 <nil_0> *partially applied
04:58:00 <nil_0> `type Algebra Bool = \a -> (a, a)` would be ideal
04:58:16 <fmap> nah, I'm wondering why not simply data
04:58:23 <nil_0> That's possible too :)
04:58:33 <nil_0> type Algebra Bool = Pair
04:58:33 <RoboTeddy_> if I learn haskell, will I start noticing how much other languages (python, javascript) are lacking and begin to hate using the, or will I just get better at using them, or both?
04:58:40 <nil_0> data Pair a = Pair a a
04:58:57 <flux> roboteddy_, probably both.
04:59:05 <nil_0> mostly both
04:59:33 <AtomicStryker> i've managed what i wanted to do with a bunch of helper functions (which basically realize FOR loops), is there a code example for nested traversal using Lenses
04:59:41 <RoboTeddy_> flux: nil_0: thanks
04:59:51 <AtomicStryker> dumb question ofc there is, could i see one? :D
05:00:27 <mSSM> If I have the operator (!) from Data.Map, do I also call it Data.Map.! ?
05:01:01 <nil_0> mSSM: Data.Map.(!) is the Haskell2010-way, I think
05:01:29 <`nand`> (Data.Map.!)
05:01:56 <nil_0> mSSM: there is a problem with allowing qualification à la Data.Map.!, with operators starting with dots.
05:02:09 <nil_0> Data.Function..
05:02:10 <mSSM> So what if I want to use it as a binary operator?
05:02:20 <mSSM> Or should I just import Data.Map (!)
05:02:32 <mSSM> and the rest of Data.Map as import qualified Data.Map as M ?
05:02:54 <mSSM> or even import qualified Data.Map as M hiding (!), and then import Data.Map (!) ?
05:03:05 <nil_0> oh wow, it's still allowed to say Data.Map.!
05:03:10 <`nand`> AtomicStryker:
05:03:25 <`nand`> > [[1,2],[3,4]] & traverse.traverse +~ 1
05:03:27 <lambdabot>   [[2,3],[4,5]]
05:04:17 <mSSM> nil_0: so how do you recommend I use it?
05:04:49 <nil_0> M.! is fine, I guess
05:04:55 <nil_0> unless you plan to use http://hackage.haskell.org/trac/haskell-prime/wiki/QualifiedOperators
05:05:02 <b_jonas> why don't all packages (including the prelude) export nice alphanumerical aliases for the punctuation operators? it would be so much easier.
05:06:07 <nil_0> b_jonas: I hear you. ($>) = replace. (<*>) = apply. (>>=) = flip bind.
05:06:32 <johkke> If you use an function that uses an other function that has (Eq a) do you need to put that in your own function to than?
05:07:13 <nil_0> johkke: if the function that uses it is polymorphic in `a`, then yes
05:07:14 <`nand`> b_jonas: lens is good at this, it exports multiple aliases and multiple operators for the same thing
05:07:15 <`nand`> usually id
05:07:37 <johkke> nil_0 so it doesn't inherit automaticly?
05:07:47 <b_jonas> nil_0: (-) = flip subtract; (+) does not have a nice short name though, does it?
05:07:47 <nil_0> no, you have to be explicit about it
05:07:54 <`nand`> :t minus
05:07:55 <lambdabot> Not in scope: `minus'
05:08:02 <b_jonas> :t negate
05:08:03 <lambdabot> Num a => a -> a
05:08:35 <nil_0> Num should be refactored anyway
05:09:43 <nil_0> class SemiNum a where { (+) :: a -> a -> a; (*) :: a -> a -> a; fromInteger :: Integer -> a }
05:09:56 <mSSM> nil_0: I would prefer to use ! without a qualification; I.e., just !
05:10:34 <`ramses> johkke: think about it, if you don't put the constraint, it means the function can be called with types that do not have an Eq instance. Since you use a function that requires Eq, though, there would be nothing sane to do with such input
05:10:35 <nil_0> mSSM: if it doesn't clash with any other packages, then that's fine too :)
05:11:11 <`ramses> johkke: the Eq is inferred though if you do not put a type signature, but it's better to just be explicit about it
05:12:34 <johkke> Ok thanks :)
05:12:35 <nil_0> rules where { \a -> fromInteger 0 + a == a; \a b -> a + b == b + a; \a -> fromInteger 0 * a = fromInteger 0; {- etc -} }
05:13:10 <mSSM> nil_0: well, it doesn't like me importing it; import qualified Data.Map as M ; import Data.Map (!) gives me a parse error on !
05:13:25 <nil_0> mSSM: import Data.Map ((!))
05:13:39 <lolcathost> nil_0: Why not call it Ring, and let SemiNum be a separate type class inheriting from Ring?
05:13:46 <mSSM> nil_0: yeah! indeed, thanks
05:13:54 <YuleAthas> Data.Map.! is a partial function.  Are you sure that's what you want?
05:15:14 <b_jonas> the problem is, Data.Map.! clashes with Data.Array.!; in general, Data.Map names are not chosen to be importable
05:15:17 <b_jonas> that's a bit sad
05:15:26 <b_jonas> maybe we need an interface to Data.Map with different names
05:15:35 <nil_0> lolcathost: that's possible, but then you'd open a can of refactorization worms with problems like "is left zero always equal to right zero? let's make a new class!"
05:16:06 <nil_0> b_jonas: let's put (!) in a class! :D
05:18:12 <merijn> nil_0, b_jonas: Type directed name lookup seems a more promising solution to these problems
05:18:26 <mSSM> Well, in my program it's not a problem.
05:18:30 <b_jonas> nil_0: (Data.Map.!) is not even the worst. there's names that alias the Prelude, like Data.Map.lookup and Data.Map.map (though you could say that one is put into a class under the name fmap)
05:18:58 <b_jonas> and there's Data.Map.filter
05:19:04 <nil_0> b_jonas: fmap should be renamed anyway
05:19:12 <b_jonas> nil_0: to (.) ?
05:19:16 <nil_0> lol
05:19:24 <nil_0> to map, at least
05:19:38 <nil_0> and the current map should be listMap
05:19:57 <`ramses> or just map
05:19:58 <nil_0> Haskell newbies should simply import Prelude.Simple instead
05:20:15 <nil_0> `ramses: that might give confusing errors for new users
05:20:24 <b_jonas> > map (\x -> ("z",x)) (Data.Map.fromList [(3,1),(4,1),(5,9)])
05:20:26 <lambdabot>   Not in scope: `Data.Map.fromList'
05:20:29 <`ramses> true, but listMap is horribly verbose
05:20:33 <b_jonas> > Data.Map.map (\x -> ("z",x)) (Data.Map.fromList [(3,1),(4,1),(5,9)])
05:20:34 <lambdabot>   Not in scope: `Data.Map.map'Not in scope: `Data.Map.fromList'
05:20:55 <b_jonas> what?
05:20:58 <b_jonas> > M.map
05:21:00 <lambdabot>   *Exception: show: No overloading for function
05:21:09 <b_jonas> > M.map (\x -> ("z",x)) (M.fromList [(3,1),(4,1),(5,9)])
05:21:11 <lambdabot>   fromList [(3,("z",1)),(4,("z",1)),(5,("z",9))]
05:21:20 <b_jonas> lambdabot imports it only under the short name?
05:21:29 <nil_0> `ramses: true, so maybe the map from Prelude.Simple should completely shadow map :: Functor f
05:21:51 <`ramses> I guess that would be a better solution
05:23:07 <`ramses> but it feels a bit strange to redefine all general functions in Prelude.Simple just because the error messages are confusing
05:23:30 <`ramses> I mean, how far would you go with that approach
05:23:30 <nil_0> `ramses: Prelude.Simple is only intended for didactic purposes
05:23:57 <`ramses> so it should be used until one is comfortable with type classes
05:24:04 <b_jonas> right, if you overgeneralize every function (like map), you'll get ugly constraint error messages in the wrong places
05:24:04 <nil_0> exactly! :)
05:24:22 <mSSM> So, if I want to have a strict version of Data.Map.insert, I would use insertWith' const key value myMap ?
05:25:11 <`ramses> mSSM: seq instead of const, isn't it?
05:25:48 <`ramses> ah wait, does the ' make it strict already?
05:26:14 <b_jonas> what?
05:26:17 <b_jonas> how would that work?
05:26:46 <mSSM> `ramses: yeah, that's what is ays
05:26:59 <nil_0> I wish there was a good way to define class Transposable where { zip :: f (g a1 .. aN).. (g z1 .. zN) -> g (f a1 .. z1) .. (f aN .. zN) }
05:27:01 <mSSM> `ramses: insertWith' = combingin function is applied strictly
05:27:13 <nil_0> *Transposable f g
05:27:15 <fmap> mSSM: newer containers have Data.Map.Strict which is already strict in values
05:27:23 <`ramses> so the const is applied strictly, but does that mean that it's result is evaluated?
05:29:13 <mSSM> fmap: I have 0.5.0.0
05:29:37 <mSSM> fmap: So if I just load the strict version, I don't have to worry about insertWith and insertWith' ?
05:30:11 <`ramses> > M.lookup 4 $ M.insertWith' const 3 [1, undefined] M.empty
05:30:13 <lambdabot>   Nothing
05:30:26 <`ramses> the list is not evaluated
05:30:27 <mSSM> fmap: ok, thanks for the tipp; I was looking at 0.4.2 docs, which I just got from google.
05:31:11 <b_jonas> Data.Map has a lot of functions
05:31:12 <b_jonas> a lot
05:31:25 <nil_0> or a class Functor (v1 .. vN :: Variance) f where { map :: Exp v1 a1 b1 -> ... -> Exp vN aN bN -> Exp Covariant (f a1 .. aN) (f b1 .. bN) }
05:31:53 <mSSM> Why does the strict Data.Map still provide strict and not-strict foldl ?
05:31:56 <mSSM> Isn't that silly?
05:33:32 <bitonic> mSSM: why?
05:34:44 <fmap> mSSM: strict Map doesn't imply strictness in folds
05:35:09 * hackagebot cprng-aes 0.3.1 - Crypto Pseudo Random Number Generator using AES in counter mode.  http://hackage.haskell.org/package/cprng-aes-0.3.1 (VincentHanquez)
05:35:44 <bitonic> fmap, mSSM: well I guess that what mSSM is saying is that you won’t be able to “appreciate” the lazyness of the non-strict one because as soon as you inspect the result the rest of the map will be forced
05:36:01 <bitonic> so you can’t get results by evaluating the map only partially
05:43:43 <Philonous_> I'm having a hard time deciding when (or if at all) to use Exceptions and when to return an "Either <Error> a" value.
05:43:57 <johkke> Is there an var_dump alternative for Haskell?
05:44:19 <Botje> that's what show is for
05:44:27 <Botje> if it's supported
05:46:44 <johkke> botje thanks!
05:53:10 <letsstartwedding> hello..if someone want to chat! http://letsplanmywedding.com/forums/
05:53:52 <johkke> What is the logical AND in Haskell?
05:54:11 <nil_0> &&
05:54:19 <nil_0> :t &&
05:54:21 <lambdabot> parse error on input `&&'
05:54:28 <nil_0> :t (&&)
05:54:29 <lambdabot> Bool -> Bool -> Bool
05:54:52 <letsstartwedding> ?
05:55:05 <b__> ```lol
05:55:31 <johkke> thanks
05:55:39 <nil_0> how do I vote for a ban with ChanServ? :')
05:55:45 <johkke> I forgot the brackets
05:55:46 <nil_0> !ban letsstartwedding
05:55:52 <letsstartwedding> :(
05:56:17 <nil_0> johkke: me too :D
05:56:34 <merijn> nil_0: You can't, you just have to ask one of the ops
05:56:43 <`ramses> johkke: if you use that as an infix function (like you mostly will) you shouldn't need brackets though
05:57:53 <byorgey> > True && False
05:57:54 <lambdabot>   False
05:58:38 <hayashi> > True && undefined
05:58:40 <lambdabot>   *Exception: Prelude.undefined
05:58:47 <johkke> yeah :p
05:58:52 <byorgey> > False && undefined
05:58:53 <`ramses> > True || undefined
05:58:53 <johkke> Thanks again :p
05:58:54 <lambdabot>   False
05:58:54 <lambdabot>   can't find file: L.hs
05:59:02 <byorgey> wat
05:59:04 <hayashi> > False && undefined
05:59:06 <lambdabot>   False
05:59:23 <byorgey> > True || False
05:59:24 <lambdabot>   True
05:59:27 <hayashi> that's what i meant to type, that or True || undefined =/
05:59:43 <byorgey> I was saying 'wat' about the 'can't find file' error
06:00:28 <`ramses> yeah, wondering how that was triggerd
06:00:49 <YuleAthas> Race condition in lambdabot?
06:01:02 <byorgey> seems so
06:01:09 <byorgey> > True || undefined
06:01:11 <lambdabot>   True
06:01:35 <`ramses> I thought doing concurrency in haskell was supposed to avoid those :)
06:02:56 <dim3vs> Hellow everyone! I am trying out Haskell :-)
06:03:13 <byorgey> `ramses: it makes it *easier* to avoid them.  It doesn't rule them out =)
06:03:53 <byorgey> hi dim3vs! welcome
06:04:00 <byorgey> dim3vs: feel free to ask questions in here
06:04:29 <`ramses> byorgey: doesn't a race condition imply some mutable state?
06:05:02 <dim3vs> <byorgey>Where can I use haskell?
06:05:21 <b_jonas> on your computer, if you install it
06:05:24 <dmwit> ?where platform
06:05:24 <lambdabot> http://hackage.haskell.org/platform/
06:05:35 <dmwit> dim3vs: You can download the most popular implementation + some basic libraries there.
06:05:36 <nil_0> ?where my keys
06:05:36 <lambdabot> I know nothing about my.
06:05:47 <b_jonas> run ghci, type 1 + 1 , get 2 as teh answer
06:06:02 <b_jonas> (if defaulting works well)
06:06:15 <l0p3n> Hello! I am trying to install haskell-platform-2012.4.0.0 but I get this error message: http://pastebin.com/U3AAUpTf . Any ideas on what I'm doing wrong?
06:06:17 <dmwit> dim3vs: Or, you can do very simple stuff at tryhaskell.org without installing anything.
06:06:26 <dim3vs> dnwit: Can I develop web sait with haskell?
06:06:31 <dmwit> yes
06:06:49 <`ramses> dim3vs: you can, but you wont want to start with that :)
06:07:14 <dmwit> ?wiki Web/Frameworks
06:07:15 <lambdabot> http://www.haskell.org/haskellwiki/Web/Frameworks
06:07:25 <b_jonas> no, web sites are written in php/asp, not in haskell
06:07:25 <Philonous> `ramses:  I'd think concurrency (unlike parallelism) is an inherently effectful concept.
06:07:47 <dim3vs> OK, thanks. Where usually applying haskell?
06:08:15 <dmwit> l0p3n: Well, when you installed bytestring, did you enable profiling?
06:08:29 <dmwit> dim3vs: Haskell is good for what ails you. It is a general purpose programming language.
06:08:52 <b_jonas> @faq Can I develop web sait with haskell?
06:08:52 <lambdabot> The answer is: Yes! Haskell can do that.
06:08:57 <Gonzih> dim3vs: take a look at http://yannesposito.com/Scratch/en/blog/Yesod-tutorial-for-newbies/
06:08:59 <l0p3n> dmwit: I have no idea of what that is so I guess I haven't :). How can I enable it?
06:09:33 <dim3vs> dmwit: OK, I`ll read more about it. I want to find out where it is better then other langugies.
06:09:39 <dmwit> l0p3n: cabal install --enable-library-profiling
06:09:47 <`ramses> Philonous: I still keep mixing those two up!
06:10:10 <b_jonas> that's because different people use the terminology in different ways
06:10:11 <dmwit> l0p3n: You should probably just set enable-library-profiling: True in ~/.cabal/config unless you're in a disk space crunch.
06:10:17 <b_jonas> and insist theirs is the only right way
06:11:21 <l0p3n> dmwit: hmm I thought I had installed Cabal already. Apparently not: -bash: cabal: command not found
06:11:50 <dmwit> Did you install via Setup.[l]hs, then?
06:12:58 <dmwit> Anyway, Setup.hs accepts --enable-library-profiling as well, you just need to pass it in the configure stage.
06:13:08 <l0p3n> I think i installed from the centos repos
06:13:12 <`ramses> b_jonas: talking about the concurrency <> parallelism ?
06:13:41 <`ramses> I thought the definitions are pretty agreed upon, aren't they?
06:13:43 <b_jonas> `ramses: and "asynchroniuos" which is another similar word
06:13:49 <b_jonas> they aren't
06:13:52 <`ramses> I just always forget about them :)
06:13:56 <`ramses> ow ok
06:14:01 <b_jonas> different people use them differently
06:14:04 <dmwit> l0p3n: Is there a reason you aren't installing GHC/cabal/the platform from your repo as well...?
06:14:11 <b_jonas> there's some haskellist definition
06:14:17 <`ramses> then maybe I happen to have only come across people of one camp :)
06:14:22 <nil_0> @faq Can I launch nuclear missiles with unsafePerformIO?
06:14:22 <lambdabot> The answer is: Yes! Haskell can do that.
06:15:21 <b_jonas> unsafePerformIO lets you break type safety, divide by zero, and ignore operating system permissions too.
06:15:42 <b_jonas> who'd win a fight between unsafePerformIO and Chuck Norris?
06:16:00 <l0p3n> dmwit: This is my first haskell install so I followed the steps in this guide http://www.vex.net/~trebla/haskell/haskell-platform.xhtml
06:16:43 <l0p3n> dmwit: but I'll try installing it from the repos instead
06:16:48 <dmwit> These instructions are from building the platform from source. Saying you're following these instructions does not answer the question "why are you building from source?".
06:19:01 <l0p3n> dmwit: Oh that is because I didn't find any executables for centos on the haskell webpage
06:19:24 <dmwit> Right, that's a much better reason. =)
06:20:02 <blackmirroxx1> hi
06:20:04 <l0p3n> =) What should I search for in the repos? yum list ...
06:20:24 <b_jonas> l0p3n: have you tried to install the executables for some other Linux-based system
06:20:52 <dmwit> l0p3n: Fedora has packages named cabal-install and ghc; those would be a pretty good start.
06:21:25 <l0p3n> b_jonas: No I haven't actually. Maybe the Fedora executable would work?
06:21:43 <l0p3n> dmwit: Ok thanks :)
06:27:17 <Digihash> hello, sometimes I see a . in between function, i.e. function1 = sort . listFunction
06:27:24 <Digihash> What does this mean? This .?
06:27:38 <hpc> (.) is an ordinary function just like (+)
06:27:45 <hpc> and it has a somewhat funny definition
06:27:46 <hpc> @src (.)
06:27:47 <lambdabot> (f . g) x = f (g x)
06:27:47 <lambdabot> NB: In lambdabot,  (.) = fmap
06:27:57 <hpc> so in yours, function1 = sort . listFunction
06:28:00 <rwbarton> function composition
06:28:05 <hpc> function1 x = sort (listFunction x)
06:28:42 <Hafydd> @src fmap
06:28:42 <lambdabot> Source not found. There are some things that I just don't know.
06:29:01 <nil_0> so, taking the definition of (.): `function1 = sort . listFunction` means `function1 x = sort (listFunction x)`
06:29:09 <hpc> yep
06:29:20 <Digihash> ah ok. Thanks for the explanation
06:29:48 <hpc> you'll also occasionally see it with ($)
06:29:50 <hpc> @src ($)
06:29:50 <lambdabot> f $ x = f x
06:30:04 <hpc> haskell programmers famously hate parenthesis in all their forms
06:30:18 <hpc> so you might also see function1 x = sort . listFunction $ x
06:30:22 <`nand`> parentheses must die
06:30:29 <nil_0> naw man
06:30:39 <nil_0> I like my )))))))) at the end of a definition
06:30:40 <nil_0> ;)
06:30:51 <hpc> @quote defun
06:30:52 <lambdabot> defun says: [defun] conal: you seem knowledgable on the subject of FRP ... [conal] defun: btw, i invented frp.
06:31:03 <hpc> @quote funbox
06:31:03 <lambdabot> Veinor says: <Veinor> can't spell -funbox without fun!  <djahandarie> Veinor, can't write LISP without defun :-(
06:31:22 <nil_0> @quote lambdabot
06:31:22 <lambdabot> lambdabot says: Plugin `quote' failed with: getRandItem: empty list
06:31:26 <nil_0> :o
06:31:35 <YuleAthas> hpc: Yale Haskell must have been a sight to see.
06:32:26 <nil_0> I bet there is some close-parentheses ascii art somewhere
06:32:34 <nil_0> *sis
06:32:47 <hpc> parenthesesiseseses
06:32:56 <nil_0> parenthesitis
06:33:03 <Hafydd> Every LISP program.
06:33:28 <nil_0> I'm afraid I have bad news. You have parenthesitis. It is non-terminating.
06:33:57 <hpc> oh god
06:34:02 <Hafydd> I'm afraid I have bad news. You're a grammarian. It is non-terminal.
06:34:03 <hpc> how much memory do i have left?
06:35:20 <nil_0> I'm afraid I have bad news. Your pipe is leaking. It is a terminal.
06:35:43 <nil_0> *blocking
06:35:44 <nil_0> dammit
06:36:51 <nil_0> I'm afraid I have bad news. I have Dalek-voice syndrome. It is EXTERMINATE.
06:37:06 <Hafydd> Would you like to hear the good news first or the bad news (enter 'g' or 'b') >
06:37:20 <nil_0> g
06:37:28 <Hafydd> Your pipe is no longer blocking.
06:37:29 <hpc> i have good news and bad news; the bad news is i have a terrible sense of humor; the good news is your wife is dead
06:37:42 <hpc> haha
06:37:44 <nil_0> b
06:37:54 <Hafydd> Your pipe has closed. Goodbye.
06:37:58 <nil_0> D:
06:38:53 <YuleAthas> Fortunately, you're one of those terrible C programs that never check the return value, so you'll just loop, printing the command prompt forever.
06:39:48 <nil_0> you mean like
06:40:00 <nil_0> c:\> c:\> c:\> c:\> c:\> c:\> c:\> c:\> c:\> c:\>
06:40:01 <nil_0> ?
06:40:03 <nil_0> ;)
06:41:14 <nil_0> I'm afraid I have bad news. You have humour. It is terrible.
06:41:40 <neutrino_> YuleAthas: what is yale haskell?
06:43:51 <nexx> c:\>-* this is santa claus :D
06:43:52 <YuleAthas> neutrino_: an early implementation of Haskell in Common Lisp.
06:44:02 <YuleAthas> I vaguely recall it being used to bootstrap GHC, but I might be mistaken.
06:44:11 <neutrino_> YuleAthas: ah. i wonder how bad it was.
06:44:22 <YuleAthas> I think it was pretty good, actually.
06:44:23 <Taneb> I'm worried because I think Data.Array.Storable is what I need
06:44:30 <YuleAthas> Perhaps not if the usual fear of parentheses was carried over.
06:44:39 <`nand`> I thought GHC was first written in Lazy ML
06:45:02 <neutrino_> why is that worrying you Taneb
06:45:20 <Taneb> neutrino_, I'm scared of C
06:45:36 <Taneb> Also, is it possible to get a slice of a UArray?
06:45:38 <neutrino_> why do you think you need such a thing
06:46:11 <nil_0> as you should be
06:46:15 <Taneb> Because I've already got a UArray of Word16s, and I need to give it to OpenGL which wants pointery things
06:46:53 <neutrino_> sounds reasonable
06:46:54 <neutrino_> i guess
06:47:30 <YuleAthas> Wow, the Yale Haskell build scripts are written in csh.
06:48:56 <nil_0> ./configure and make should die
06:49:15 <merijn> nil_0: Naah, make is fine
06:49:17 <nil_0> most configure scripts are built from autotools anyway :(
06:49:20 <`nand`> the future is runhaskell Setup.hs configure && runhaskell Setup.hs build
06:49:21 <merijn> auto* is crap, though
06:49:45 <nil_0> merijn: whitespace-significant syntax is fine, unless you differentiate between tabs and spaces
06:49:51 <YuleAthas> What the... apparently Yale Haskell is actually written in something more like Scheme, but they define a bunch of macros to make a Common Lisp implementation simulate Scheme constructs.
06:49:55 <nil_0> *discriminate
06:49:56 <YuleAthas> This is utterly byzantine.
06:50:40 <nil_0> O_o
06:51:31 <YuleAthas> They even redefine the readtable to accept #f and #t.
06:51:45 <merijn> nil_0: How does make differentiatie between tabs and spaces? It's just tabs only in makefiles
06:52:29 <Hafydd> Spaces are allowed in Makefiles, but not in the same places as tabs
06:53:17 <Hafydd> That's why I had to configure my editor to hilight leading spaces in red.
06:54:33 <YuleAthas> I think Yale Haskell was originally written in T (an actually pretty good Scheme dialect), then ported to Common Lisp by modifying the CL implementation, rather than Yale Haskell itself.
06:54:49 <YuleAthas> The demo programs interesting, since they're pre-IO-monad.  I never worked with that before.
06:55:52 <nil_0> merijn: not that I know, you can split the set of dependencies to multiple lines, and then you have to indent them with spaces IIRC
07:03:26 <merijn> nil_0: No, if you use \ to split multiple lines there is not indent requirement
07:03:36 <nil_0> TIL
07:03:38 <merijn> As \ escapes the newline, the amount of whitespace is irrelevant
07:04:16 <nil_0> still, I don't like the idea of using "tabs only", because I'm using "spaces only" everywhere else ;)
07:07:27 <merijn> Me too, but I'll manage
07:10:45 <neutrino_> statusfailed: oh, sorry, missed your message.. thanks
07:20:12 * hackagebot cryptohash 0.8.0 - collection of crypto hashes, fast, pure and practical  http://hackage.haskell.org/package/cryptohash-0.8.0 (VincentHanquez)
07:23:01 <EarlGray1> how to install glfw haskell bindings? There are two glfw packages in cabal, glfw and glfw-b, which one is better?
07:23:15 <EarlGray1> *install on Mac
07:23:46 <Eelis> EarlGray1: i'm using glfw-b. i like it
07:23:52 <Eelis> EarlGray1: the readme explains the differences
07:29:08 <EarlGray1> glfw-b installs :) Though I get a ton of warnings and glfw-b-demo fails to install
07:29:32 <Eelis> EarlGray1: i have submitted a pull request to fix glfw-b-demo: https://github.com/bsl/GLFW-b-demo/pulls
07:31:16 <Eelis> no one is assigned though. i wonder if brian was even notified
08:04:19 <vanseverk> Hi, how can I make a function header to only accept a list of lists (and strings, but those are lists too, of course :))
08:04:47 <Eelis> vanseverk: http://en.wikipedia.org/wiki/Special:Search?go=Go&search=a
08:04:51 <Eelis> erm, wtf
08:04:58 <Eelis> http://en.wikipedia.org/wiki/Special:Search?go=Go&search=a
08:04:59 <Eelis> argh
08:05:01 <startling> vanseverk: you mean a type signature? [[a]] -> b
08:05:19 <Eelis> looks like konversation thinks it's a good idea to replace "[ [ a ] ]" with some wikipedia link
08:05:23 <vanseverk> startling: the inner [] can be any number of A's?
08:05:49 <startling> vanseverk: yeah. [a] just means "the type of lists of type a"
08:05:59 <Eelis> [[a]]
08:06:00 <Eelis> there we go
08:06:13 <vanseverk> because I want to be able to accept things like ["abc", "def"] but also [[1, 2, 3], [1]] and [[1]]
08:06:32 <startling> vanseverk: right, that works.
08:06:39 <vanseverk> Great, thanks guys
08:07:12 <startling> vanseverk: just like how "[1, 2, 3] :: [Int]", but 'a' is a variable replacing Int.
08:07:59 <Jafet> There are people who need a shortcut to put Special:Search links into irc?
08:08:04 <vanseverk> but it can replace a Char too, for example?
08:08:31 <Eelis> Jafet: apparently..
08:09:12 <`nand`> Eelis: what an utterly retarded default configuration :P
08:09:29 <vanseverk> Also, if the output should be a list as well... then I can do foo::[[a]] -> [b] and foo inputlist = "bla" for example?
08:09:35 <`nand`> vanseverk: do you know how parametric polymorphism works?
08:10:07 <startling> vanseverk: sure. a here stands for any type
08:10:13 <vanseverk> `nand`: I do, I get rather odd errors though
08:10:17 <Jafet> forall a b. [[a]] -> [b]
08:10:18 <startling> vanseverk: you'd probably want [[a]] -> [a], though
08:10:31 <vanseverk> "couldn't match type 'a' with 'Char' kinda deal
08:10:58 <vanseverk> and that's when compiling
08:10:59 <Jafet> This means that for any a and b, foo can be used as a function from [[a]] to [b]
08:11:06 <otters> what's a good way to convert a [[Char]] into a list of [(character, xvalue, yvalue)] tuples?
08:11:19 <otters> where x and y represent the character's location in the array
08:11:34 <`nand`> presumably something involving zip [0..]
08:11:35 <startling> otters, use a different data structure
08:11:46 <otters> well, I'm reading user input is the thing
08:11:50 <otters> so it's necessarily a String
08:11:53 <startling> ah
08:12:07 <otters> right now I have something fairly ugly yeah
08:12:17 <otters> concatMap (\(a,bs) -> map (\(y,z) -> (z,a,y)) $ zip [0..] bs) . zip [0..] $ lines input
08:13:37 <Jafet> Silly problems entail silly solutions
08:14:36 <otters> yep
08:16:24 <`nand`> :t itoListOf (ifolded <.> ifolded)
08:16:25 <lambdabot>     Ambiguous occurrence `<.>'
08:16:25 <lambdabot>     It could refer to either `Data.VectorSpace.<.>',
08:16:25 <lambdabot>                              imported from `Data.VectorSpace' at State/L.hs:82:1-44
08:16:29 <`nand`> ugh
08:16:32 <`nand`> :t itoListOf (ifolded Control.Lens.<.> ifolded)
08:16:33 <lambdabot> (FoldableWithIndex i1 f1, FoldableWithIndex i f) => f (f1 b) -> [((i, i1), b)]
08:16:59 <`nand`> > itoListOf (ifolded Control.Lens.<.> ifolded) [['a', 'b'], ['x', 'y']]
08:17:01 <lambdabot>   [((0,0),'a'),((0,1),'b'),((1,0),'x'),((1,1),'y')]
08:17:23 <`nand`> otters: not precisely the same thing, but close enough :)
08:17:42 <vanseverk> `nand`: http://pastebin.com/3aLj7Wgz This shouldn't be wrong, right?
08:17:44 <otters> oh that's much better
08:17:49 <`nand`> Who's in charge of lambdabot's L.hs? That's Cale, right? Can I we get a qualified import on VectorSpace or something
08:17:56 <otters> I wish I knew lenses :(
08:18:04 <`nand`> vanseverk: the type of "abcdef" is String
08:18:07 <`nand`> vanseverk: not [a]
08:18:15 <otters> `nand`: where are ifolded and itoListOf?
08:18:18 <`nand`> so no, that's wrong
08:18:19 <vanseverk> `nand`: String is a list of chars though, no?
08:18:26 <startling> otters: Control.Lens
08:18:29 <Jafet> There should be a tariff on VectorSpace
08:18:30 <otters> ok
08:18:33 <Jafet> Its main use so far is to confuse people
08:19:19 <`nand`> vanseverk: [Char] and forall a. [a] are still not the same thing
08:19:38 <Jafet> > "abcdef" :: forall a. [a]
08:19:40 <lambdabot>   Couldn't match type `a1' with `GHC.Types.Char'
08:19:40 <lambdabot>    `a1' is a rigid type vari...
08:20:01 <startling> vanseverk: any "[a] -> whatever" will work on a String but "[Char] -> whatever" will only work on strings
08:20:22 <`nand`> vanseverk: if you omit the type signature and inspect the inferred type of that function, you'll notice it's ‘forall a. a -> String’
08:20:23 <vanseverk> Well, the thing I want to do is accept a list of lists and build an output list from that info
08:20:24 <Jafet> @let f :: forall a. [a] -> (); f = const ()
08:20:24 <lambdabot>   TypeOperators is not enabled
08:20:50 <vanseverk> anything I CAN use as a temporary output for something like that then?
08:21:34 <`nand`> vanseverk: the ‘a’ in [a] doesn't mean “some a”, it means “any a”
08:22:09 <startling> vanseverk: so your type is '[[a]] -> [a]', as you described it, but we need to see more code if we're going to tell you why you're getting a type error
08:22:11 <otters> :t ifolded Control.Lens.<.> ifolded
08:22:12 <lambdabot> (Applicative f1, FoldableWithIndex i1 f2, FoldableWithIndex i f, Indexable (i, i1) k, Gettable f1) => k (a -> f1 a) (f (f2 a) -> f1 (f (f2 a)))
08:22:20 <otters> :t join (Control.Lens.<.>) ifolded
08:22:22 <lambdabot>     Occurs check: cannot construct the infinite type: a0 = f0 a0
08:22:22 <lambdabot>     Expected type: Indexed i0 (a0 -> f1 a0) (a0 -> f1 a0)
08:22:22 <lambdabot>       Actual type: Indexed i0 (a0 -> f1 a0) (f0 a0 -> f1 (f0 a0))
08:22:25 <otters> oh
08:22:29 <otters> wtf
08:22:30 <vanseverk> `nand`: I'll just use !!1 on the input for temp output :)
08:22:43 <startling> vanseverk: or just []
08:22:44 <`nand`> :t (Control.Lens.<.>)
08:22:46 <lambdabot> Indexable (i, j) k => Indexed i b c -> Indexed j a b -> k a c
08:22:50 <`nand`> ah
08:22:57 <`nand`> otters: join is monomorphic
08:23:00 <otters> oh yeah
08:23:00 <`nand`> I mean
08:23:06 <`nand`> it forces the parameters to be the same type
08:23:08 <otters> yeah I know what you mean
08:23:21 <scp_> @src seq
08:23:22 <lambdabot> Source not found. :(
08:23:29 <DMcGill> I have to compute the Newton method and the output is specified to be "List containing the solution if the method has converged, otherwise contains NaNs". Could this mean the elements are x_i, where x_0 is the initial guess or is there some other possible meaning?
08:23:55 <`nand`> would ‘seq !x = id’ behave the same way as the built-in ‘seq’ does?
08:24:12 <Jafet> I can pretend to be your professor, but I need to be paid the same amount first
08:24:50 <`nand`> “otherwise contains NaNs” <- what the /heck/?
08:25:01 <otters> why not just have an empty list
08:25:08 <`nand`> or Nothing
08:25:14 <scp_> my guess was "seq x y = case x of _ -> y", but the compiler might optimize that into a "seq x = id". I find it much harder to predict GHC optimizations than, say, gcc
08:25:50 <Jafet> scp: the compiler doesn't need to optimize anything
08:25:58 <Jafet> x is not allowed to be evaluated there
08:26:02 <Jafet> Hmm
08:26:15 <tomeo> Shouldn't do "hello"; return "world" have a monadic type as return has a monadic type?
08:26:16 <Jafet> > case (undefined :: ()) of _ -> ()
08:26:18 <lambdabot>   ()
08:26:24 <`nand`> “case x of ...” isn't necessarily strict, is it? I mean; “case x of Newtype y -> z” wouldn't be, I guess
08:26:34 <startling> tomeo: "hello" isn't any monad
08:26:41 <`nand`> > case undefined of _ -> ()
08:26:43 <lambdabot>   ()
08:26:45 <startling> tomeo: (it's a specific monad, the list monad)
08:26:47 <`nand`> there you go
08:27:07 <`nand`> > let seq !x = id in undefined `seq` ()
08:27:08 <lambdabot>   *Exception: Prelude.undefined
08:27:12 <`nand`> > let seq !_ = id in undefined `seq` ()
08:27:13 <lambdabot>   *Exception: Prelude.undefined
08:27:15 <`nand`> neat, that works
08:27:20 <tomeo> startling: why does that affect the type?
08:27:30 <startling> tomeo, every statement (other than let) in a do notation must have the same monadic type as the whole expression.
08:27:58 <startling> > do "hello"
08:28:00 <lambdabot>   "hello"
08:28:08 <startling> :t do "hello"
08:28:09 <lambdabot> [Char]
08:28:23 <startling> :t do []
08:28:24 <lambdabot> [a]
08:28:30 <Jafet> > do "hello"; return "world"
08:28:32 <lambdabot>   ["world","world","world","world","world"]
08:28:50 <`nand`> startling: “do x” desugars into ‘x’, regardless of the type
08:28:56 <Jafet> nand: of course, ! is defined using seq.
08:29:01 <scp_> > do 5
08:29:02 <lambdabot>   5
08:29:04 <startling> `nand`: oh, I guess that's a bad example then.
08:29:15 <scp_> weird
08:29:17 <Jafet> > do "hello"; "world"
08:29:18 <lambdabot>   "worldworldworldworldworld"
08:29:22 <`nand`> Jafet: I thought it was built into the evaluation model of GHC
08:29:30 <`nand`> strict fields, that is
08:29:36 <tomeo> So if I want to know the type of a do-block I just have to know what will be returned?
08:29:40 <`nand`> oh, but I guess that's just for strict fields on data types
08:29:54 <startling> tomeo, you're misunderstanding how do blocks work
08:30:11 <tomeo> startling: Ill have to do some more reading :) thanks for trying
08:30:15 <startling> tomeo, have you learned >>= yet? it might be advantageous to stick to that for a while
08:30:25 <scp_> All of that do "hello"; return "world" stuff was probably less than helpful for tomeo x_X.
08:30:42 <startling> tomeo: "do "abc"; return ()" is the same as "abc" >>= \_ -> return ()
08:31:10 <startling> tomeo: btw, "return" doesn't mean what you think it means
08:31:25 <tomeo> startling: its not return as in imperative languages, I know that
08:31:37 <startling> tomeo: oh, okay, just making sure.
08:31:40 <tomeo> return in this statement makes it a list
08:31:45 <tomeo> well a list of lists
08:31:54 <tomeo> without return Id have [Char]
08:31:55 <startling> tomeo, have you seen Maybe?
08:31:58 <tomeo> startling: yes
08:32:08 <startling> tomeo: do you understand its Monad instance?
08:32:41 <tomeo> startling: didn't know it was monadic at all
08:32:47 <startling> tomeo: hehe
08:33:01 <startling> > Just 12 >> Nothing >> Just 'a'
08:33:03 <lambdabot>   Nothing
08:33:18 <startling> > (return 'a' :: Maybe Char)
08:33:19 <lambdabot>   Just 'a'
08:33:29 <jmcarthur> scp_: the only way i know of that seq could be defined is with a type class, where the implementation must pattern match on the value to force
08:33:40 <jmcarthur> scp_: functions can't be seqed this way, though
08:33:49 <startling> > do Just 12; Nothing; Just 'a';
08:33:49 <jmcarthur> scp_: (which i think is better)
08:33:50 <lambdabot>   Nothing
08:34:13 <startling> tomeo: anyway, the thing relevant to your question is :t (>>=)
08:34:16 <startling> :t (>>=)
08:34:17 <lambdabot> Monad m => m a -> (a -> m b) -> m b
08:34:26 <Jafet> .oO( class WHNFData where )
08:34:30 <startling> tomeo: see how m is the same everywhere, there?
08:34:52 <jmcarthur> actually i guess functions might be seqable by generating an argument, but that may not be as general as it sounds
08:35:04 <startling> tomeo: your do block desugars to ""abc" >>= \_ return ()", so it figures out that "abc" and "return ()" must have the same monadic type
08:36:10 <jmcarthur> instance (Default a, Seq b) => Seq (a -> b) where seq x y = seq (x def) y  -- something seems weird/wrong about this, though
08:36:20 <tomeo> okay startling
08:36:53 <`nand`> I wouldn't use Default, for starters
08:36:58 <startling> tomeo: anyway, if you'd like to build an intuition for Monad and do notation, I'd play around with Maybe and Either for a bit, and then look at Reader, Writer, and State
08:37:07 <`nand`> but yes
08:37:07 <tomeo> startling: I think I'm getting closer to understanding, but it's obvious I have to do some reading for the full understanding :)
08:37:30 <startling> tomeo: I don't think it's a reading thing tbh, I think it's an intuition thing.
08:37:56 <startling> for all those types, there's one obvious valid monad instance, but you may not see it if you're not too familiar with monads.
08:38:21 <jmcarthur> `nand`: i just didn't know of anything else to use off the top of my head
08:38:22 <tomeo> startling: maybe, the fact that my expression evaluated to [[Char]] was suprising to say the least :)
08:38:31 <hpaste> nil annotated “I am a terrible person” with “I am a terrible person (annotation) (annotation)” at http://hpaste.org/78954#a78960
08:39:36 <vanseverk> `nand`: For an empty array I can use [], what can I use for a type a which has no answer though?
08:39:41 <jmcarthur> is that "I am a terrible person" stuff just reimplementing parts of recursion-schemes?
08:39:45 <vanseverk> `nand`: something like "undefined"?
08:39:54 <`nand`> vanseverk: for starters, I have no idea what you're trying to do
08:40:03 <`nand`> nor did I understand that question
08:40:10 <vanseverk> `nand`: Woops, sorry :)
08:40:44 <scp_> :w
08:40:52 <scp_> ugh, I keep VIMing you guys, sorry
08:41:12 <vanseverk> `nand`: I basically want a function that accepts any datatype a and returns a value (not the right terminolog, I know :) ) I'm not sure what to return when the answer is non-existant though
08:42:04 <`nand`> :t const 3
08:42:05 <lambdabot> Num a => b -> a
08:42:13 <`nand`> > const 3 "foo"
08:42:14 <lambdabot>   3
08:42:15 <`nand`> like that?
08:42:23 <startling> scp_: gg d G
08:42:47 <`nand`> “const n” is a function that accepts a value of any type and returns ‘n’
08:43:21 <jmcarthur> vanseverk: what is "the answer" supposed to be?
08:43:24 <osfameron> vanseverk: are you recreating quickcheck's "Arb" ?
08:43:35 <scp_> ಠ_ಠ
08:43:44 <vanseverk> `nand`: Mhmm, but what would be the equivalent of "null" in another language?
08:43:47 <vanseverk> or undefined or whatever
08:43:49 <`nand`> no such thing
08:44:00 <startling> vanseverk, you'd make your return type a Maybe x instead of x.
08:44:08 <startling> vanseverk: or [x] instead of x
08:44:17 <startling> and failure would be Nothing or the empty list
08:44:21 <scp_> vanseverk, people use Nothing for that purpose a lot
08:44:34 <vanseverk> scp_: I think that's what I needed then )
08:44:44 <jmcarthur> vanseverk: Nothing is our null-like thing, but if you want to allow a value to be Nothing then when it's not Nothing it has to be Just x instead of x
08:45:18 <jmcarthur> vanseverk: and then code that uses it has to work with Maybe a instead of a
08:45:22 <scp_> yea, it's "data Maybe a = Nothing | Just a"
08:46:06 <vanseverk> I see..
08:46:31 <scp_> but, a do block hides it nicely, since Maybe is a monad
08:47:00 <scp_> say foo bar and baz all have type (Int -> Maybe Int)
08:47:07 <vanseverk> The thing is that I want a function that returns something, but can also return a default false-like valuse when it can't find anything
08:47:26 <vanseverk> so I can use that in guards in the function that calls it
08:47:27 <srruby> I'm reading a dictionary of english words from disk. I'll be looking up words in it. What data type is recommended?
08:47:49 <startling> srruby: Map, maybe
08:48:01 <`nand`> if your dictionary is just a list of words
08:48:04 <startling> vanseverk: yeah, sounds like you want Nothing or the empty list, then
08:48:04 <`nand`> then perhaps Set would do you well
08:48:05 <scp_> do { x <- foo 5; y <- bar 4; z <- baz 7; return (x + y + z) } will return Nothing if any of foo, bar, baz return nothing
08:48:29 <scp_> hmm, ya, You can do fn x | x == Nothing = ...
08:48:38 <`nand`> ugh
08:48:42 <`nand`> you want fn Nothing = ...
08:49:26 <raek> vanseverk: the 'lookup' function in haskell uses Maybe. it has the type "Eq a => a -> [(a, b)] -> Maybe b"
08:49:45 <jmcarthur> vanseverk: if you return a Maybe, you could just use pattern matching instead of guards
08:49:56 <scp_> oh sorry, x_X
08:49:57 <raek> Nothing means "not found" and Just x means "found x"
08:50:06 <vanseverk> I shouldn't be using Monads for this assignment though :(
08:50:30 <scp_> `nand`, I meant to do | f(x) == Nothing, which seemed to match his question
08:50:38 <jmcarthur> vanseverk: you don't have to use the monad interface
08:50:56 <raek> vanseverk: you can use ordinary pattern matching to interpret the return value:
08:51:14 <srruby> thanks!
08:51:19 <raek> case lookup key alist of
08:51:27 <raek>   Nothing -> ...some expression...
08:51:34 <raek>   Just val -> ...some expression...
08:52:09 <`nand`> scp_: fn (f -> Nothing) = ...
08:52:12 <`nand`> or however that syntax goes
08:52:24 <`nand`> (was it Nothing <- f?)
08:53:07 <scp_> `nand`, you are blowing my mind, what is this?
08:53:16 <latro`a> view patterns I assume
08:53:27 <scp_> a syntax extension, or real haskell?
08:53:43 <vanseverk> scp_: Can I append that Maybe b to a list as well?
08:53:50 <latro`a> view patterns are a language extension
08:54:02 <`nand`> ah, it was ->
08:54:06 <`nand`> and not <-
08:54:09 <`nand`> yes; language extension
08:55:07 <scp_> vanseverk, yes. If you want a [Maybe b], then you can just add it to the list like you normally would. If you want a [b], then you need to extract the b using pattern matching like raek demonstrated
08:55:12 <`nand`> quasi-equivalent to “fn x = case f x of Nothing -> ...” but interacts in the obvious way with other lines
08:59:00 <hpaste> scp_ pasted “For vanseverk” at http://hpaste.org/78963
08:59:14 <scp_> take a look at that, vanseverk. Might answer your question a bit
08:59:16 <shapr> Good morning #haskell!
08:59:21 <jmcarthur> i wish the ViewPatterns extension had been done a bit differently, though. it's awkward to apply the same function and match different cases, and it's not clear what the cost model is
09:00:00 <jmcarthur> i wish it has been more like Agda's "with" syntax
09:00:37 <hpc> it took me a solid week to figure out how agda's with syntax worked :/
09:00:52 <jmcarthur> yeah the documentation is awful
09:00:57 <scp_> vanseverk, Maybe a is just a data type, you can completely ignore the fact that it is a monad too, so don't let all the talk of monads before put you of
09:00:59 <scp_> off*
09:01:35 <otters> isn't there a really easy idiomatic way to do [[a,b],[c],[d,e,f]] and get [[a,c,d],[a,c,e],[a,c,f],[b,c,d],...]
09:01:44 <jmcarthur> hpc: i still don't really understand rewrite :(
09:01:49 <byorgey> lastlog byorgey 1
09:01:53 <byorgey> whoops
09:02:00 <monochrom> > sequence [[a,b], [c], [d,e,f]]
09:02:02 <lambdabot>   [[a,c,d],[a,c,e],[a,c,f],[b,c,d],[b,c,e],[b,c,f]]
09:02:05 <otters> yeah, that's it.
09:02:08 <otters> thanks
09:02:24 <jmcarthur> it seems so simple on the surface, assuming you understand with
09:03:05 <vanseverk> scp_: I still think it's rather odd that there isn't any default way to do this
09:03:24 <vanseverk> scp_: like something like "Undefined" built into the language for polymorphic types
09:03:29 <vanseverk> without having to define your own datatype
09:03:44 <scp_> maybe is in Prelude, you don't have to define it
09:04:16 <vanseverk> Still, adds extra mess in the code
09:04:31 <jmcarthur> you need to use it a bit before you declare that
09:04:39 <otters> and now I need a function that takes [a,b,c,d] of arbitrary length and returns all [f a b, f b c, f c d]
09:04:44 <jmcarthur> i think null is far far messier than Maybe
09:05:06 <monochrom> > f a b
09:05:07 <lambdabot>   Ambiguous type variable `a0' in the constraints:
09:05:07 <lambdabot>    (GHC.Show.Show a0)
09:05:07 <lambdabot>     ...
09:05:10 <scp_> Also, with Maybe, it's impossible to make a mistake that crashes your program
09:05:17 <hpc> :t \f -> zipWith f `ap` tail
09:05:18 <lambdabot> (b -> b -> c) -> [b] -> [c]
09:05:40 <scp_> with null, that's one of the most common bugs
09:05:41 <hpc> more explicitly, \f xs -> zipWith f xs (tail xs)
09:05:57 <`nand`> I think having implicit ‘null’ on everything is the type of design failure that makes a language unusable
09:06:04 <jmcarthur> > zipWith f <*> tail $ [a,b,c,d]
09:06:05 <lambdabot>   Ambiguous type variable `c0' in the constraints:
09:06:05 <lambdabot>    (GHC.Show.Show c0)
09:06:06 <lambdabot>     ...
09:06:08 <otters> hpc: clever
09:06:08 <`nand`> and yes, undefined sucks :(
09:06:13 <scp_> vanseverk, What jmcarthur is saying is right though, it sounds unweildy, but as you learn the language more and more, it becomes quite comfortable
09:06:17 <jmcarthur> > zipWith f <*> tail $ [a,b,c,d] :: [Expr]
09:06:18 <lambdabot>   [f a b,f b c,f c d]
09:06:27 <vanseverk> scp_: Right
09:06:45 <monochrom> Tony Hoare says, null is a million-dollar mistake, and he was responsible
09:07:04 <hpc> heh
09:07:06 <scp_> to the point where I feel dirty when I need to use a language w/ null/nil/NULL now
09:07:25 <monochrom> I err. he says billion-dollar mistake
09:07:31 <hpc> python's None seems uniquely eggregious, but i can't really put my finger on why
09:07:36 <monochrom> http://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare
09:07:47 <hpc> it might even just be that they refuse to use a better name than "None"
09:07:56 <`nand`> on the other hand, you can't (easily) compare something against ‘undefined’; so its only use case is “irrevocably halting the program”; and thus preventing people from using it to eg. represent failure in the first place
09:07:58 <osfameron> null is superficially highly convenient
09:08:34 <`nand`> scp_: my approach to ‘null’ in C# is to completely ignore its existence, and write all of my code with Nullable<>
09:08:43 <osfameron> and is used successfully in program logic everywhere...
09:08:45 <hpc> i like pseudo-nulls which implicitly become '' or 0
09:08:52 <osfameron> which makes "billion dollar mistake" seem a little exaggerated
09:09:03 <hpc> because it at least makes it much easier to control
09:09:20 <vanseverk> Also, a [] can't tie to a, right?
09:09:32 <vanseverk> a '[]' to a 'a'
09:10:03 <osfameron> hpc: perl does that.  it's superficially convenient, and works well enough for many cases
09:10:13 <scp_> hmm, interesting.
09:10:44 <startling> hpc: why is '' more convenient than []?
09:10:46 <hpc> osfameron: mostly the convenience comes from the "out of band" value not being out of band
09:11:03 <hpc> so instead of being a special case you can just say "don't be using undef unless you know the language"
09:11:29 <hpc> and write the rest of your code assuming you only get defined values
09:11:40 <Taneb> Is it worth replacing Integers with Word64s if I know that the sun will explode before the Word64 overflows?
09:11:44 <`nand`> I think “don't use the language unless you know the language” is a pretty solid principle
09:11:45 <hpc> (or save "if defined" for pointers)
09:12:11 <latro`a> `nand`, I'm not so sure; for example it's hard to learn parts of the language if you don't already know other parts
09:12:13 <hpc> Taneb: it may be worth replacing it with Word
09:12:20 <latro`a> it'd be a pain to learn monads without having written a little pure code IMO
09:12:33 <`nand`> latro`a: By ‘use’ here I mean “in deployment”, not “during experimentation”
09:12:38 <hpc> and assuming that anyone running a computer for that long will be using a computer that hasn't been in existence for that long ;)
09:12:42 <`nand`> latro`a: also, I don't exclude subsets of languages
09:12:53 <startling> Taneb: can you get away with Num a => a ?
09:12:54 <Taneb> hpc, unfortunately, if Word is 32 bits it will overflow by tomorrow lunchtime
09:13:03 <`nand`> you could use the subset of a language you understand; some of the more primitive languages are so massively complex it's hard to understand it all either way
09:13:04 <latro`a> ah ok
09:13:15 <Taneb> startling, it's in one of the bits I'd like to be specific
09:13:22 <Taneb> In theory, I could, though.
09:13:29 <Phantom_Hoover> Does anyone know if Ullman's algorithm for subgraph isomorphism has been implemented in Haskell?
09:13:33 <startling> Taneb: yeah, understood
09:14:13 <startling> Taneb: I'd jut use Integer, tbh
09:15:11 <bitonic> Phantom_Hoover: take a look here: <http://hackage.haskell.org/package/fgl>
09:15:13 <Taneb> Okay, fair enough
09:15:16 <scp__> `nand`, that's interesting, never seen a type like that before
09:15:19 <Taneb> What I'd love is a Wordeger type
09:15:20 <`nand`> if your code relies on numbers of at least a certain magnitude being representable then I think Num a => a could be considered a mistake
09:15:24 <bitonic> Phantom_Hoover: I don’t know if it includes what you want but it might :P
09:15:33 <`nand`> scp__: Nullable<> in C#?
09:15:42 <scp__> ya, well, I mean in a C family language
09:15:44 <`nand`> ah
09:15:53 <scp__> also, how'd I become scp__ =[
09:15:58 <`nand`> Nullable<> is actually not as good as it sounds; in the end you still have to write your own Maybe<>
09:15:59 <scp__> I swear I started as scp
09:16:05 <`nand`> I just used the name for familiarity. I don't actually use it
09:16:13 <scp__> hehe
09:16:35 <`nand`> (the advantage of Nullable<> is that it comes with a built-in operator for fromMaybe)
09:16:35 * startling % scp scp__ scp___
09:18:30 <kqr> is there a neat way to make a function that returns a v into a function that returns a Maybe v, in such a way that all v's turn into Just v's?
09:18:41 <`nand`> :t (Just.)
09:18:43 <lambdabot> Functor f => f a -> f (Maybe a)
09:19:00 <jmcarthur> thanks caleskell
09:19:03 <`nand`> hehe
09:19:15 <jmcarthur> :t (Just Prelude..)
09:19:16 <lambdabot> (a -> b) -> a -> Maybe b
09:19:18 <`nand`> but that shows us a nice parentheses-free version
09:19:21 <`nand`> :t fmap Just
09:19:23 <lambdabot> Functor f => f a -> f (Maybe a)
09:20:37 <kqr> `nand`, oh, of course. how stupid of me!
09:20:39 <kqr> `nand`, thank you
09:36:17 <bgamari> Is there any tool to easily view .prof files?
09:36:53 <bgamari> Sorting through 20k lines of profiling information isn't an easy task
09:38:23 <jmcarthur> i don't know of any, but i wouldn't object to you making one :)
09:39:25 <byorgey> bgamari: yes, there is. http://blog.foldr.in/tkyprof-a-web-based-interactive-visualizer-fo
09:39:43 <bgamari> jmcarthur, I was thinking I might until byorgey chimed in ;)
09:40:02 <bgamari> byorgey, This looks similar to ezyang's work, yes?
09:40:20 <jmcarthur> oh that looks awesome
09:40:46 <jmcarthur> this and ezyang's thing should be combined
09:40:52 <byorgey> oh, I guess so, dunno
09:41:27 * byorgey needs to do some diagrams profiling
09:43:37 <Taneb> How can you write return in terms of (>=>)?
09:45:24 <byorgey> Taneb: you can't
09:46:50 <bgamari> sadly it doesn't compile against modern packages
09:46:58 <bgamari> this will be fixed shortly
09:47:43 <byorgey> bgamari: which, tkyprof?
09:47:57 * byorgey hasn't actually used it anytime recently
09:49:49 <Taneb> :(
09:50:15 <byorgey> Taneb: ?
09:50:26 <Taneb> Getting mixed up
09:50:54 <Eelis> what is the state of ghc's llvm code generator? is it intended to become the default at some point?
09:51:31 <hiptobecubic> Eelis, usually better for numerical stuff.
09:51:44 <Eelis> hm. /me gives it a whirl
09:51:44 <hiptobecubic> takes forever though
09:52:53 <byorgey> I don't think it's intended to become the default
09:53:00 <byorgey> but it does seem to be actively maintained
09:53:55 <hiptobecubic> it's relatively new
09:54:49 <byorgey> http://hackage.haskell.org/trac/ghc/wiki/Commentary/Compiler/Backends/LLVM
09:56:25 <hiptobecubic> I guess I mean "I think it's new as a feature that anyone cares about."
09:56:40 <hiptobecubic> and by anyone, i mean users, not ghc developers
09:56:44 <mewalz> Are there any packages that can parse/edit a .cabal file?
09:56:58 <dcoutts_> mewalz: yes! Cabal
09:57:12 <hiptobecubic> :)
09:59:14 <Eelis> ooh neat, -fllvm gave an important benchmark for my program a 5% speedup ^_^
10:01:47 <hiptobecubic> you can play with llvms optimization options too. There's a blog post somewhere....
10:02:15 <hiptobecubic> https://donsbot.wordpress.com/2010/03/01/evolving-faster-haskell-programs-now-with-llvm/
10:02:48 <Eelis> hiptobecubic: ah cool, thanks
10:03:06 <hiptobecubic> what he does is a bit hardcore, but you can at least see the method and flags
10:11:59 <beaky> hello
10:12:15 <beaky> does haskell have something like Python's random.randint?
10:13:10 <parcs`> does that you give a random integer?
10:13:20 * cmccann points to System.Random
10:14:04 <shachaf> @google haskell random.randint
10:14:06 <lambdabot> http://langref.org/fantom+python+haskell/numbers/random
10:14:06 <lambdabot> Title: langref.org - fantom, python, and haskell - Numbers | Random
10:19:00 <mSSM> Is there a profiling option that tells me what parts/function my program is accessing the most?
10:19:14 <hiptobecubic> absolutely
10:19:25 <hiptobecubic> http://www.haskell.org/ghc/docs/7.6.1/html/users_guide/profiling.html
10:19:33 <beaky> ah
10:22:23 <beaky> t randomR
10:22:26 <beaky> :t randomR
10:22:28 <lambdabot> (RandomGen g, Random a) => (a, a) -> g -> (a, g)
10:23:13 <beaky> :t getStdRandom
10:23:14 <lambdabot> (StdGen -> (a, StdGen)) -> IO a
10:23:31 <mSSM> hiptobecubic: thanks; I also apparently need additional profiling libraries?
10:23:56 <hiptobecubic> mSSM, oh dear.
10:24:34 <hiptobecubic> without much further investigation, I'll summarize what I know about this situation
10:25:07 <hiptobecubic> You're boned. make a new directory somewhere and use cabal-dev to reinstall the libraries you want into it with profiling turned on
10:25:25 <beaky> :t randomRIO
10:25:26 <lambdabot> Random a => (a, a) -> IO a
10:25:35 <beaky> ah that's like randint
10:25:38 <hiptobecubic> for whatever reason, you can't "add" profiling libraries. even if they are from the same version of the same lib
10:25:54 <beaky> I love haskell
10:25:58 <mSSM> hiptobecubic: Oh god :( I stopped even compiling cabal-dev, because I was getting errors
10:26:00 <mSSM> :( :( :(
10:26:09 <hiptobecubic> beaky, it's a random from a range
10:26:14 <mSSM> Or rather, dependency issues
10:26:15 <beaky> so it's more general?
10:26:22 <hiptobecubic> > randomRIO ('a', 'f')
10:26:23 <Eelis> how do Double and CDouble differ?
10:26:24 <lambdabot>   No instance for (GHC.Show.Show (GHC.Types.IO GHC.Types.Char))
10:26:24 <lambdabot>    arising fr...
10:26:27 <hiptobecubic> balls
10:26:28 <beaky> > randRIO ('a', 'z') >>= print
10:26:29 <lambdabot>   Not in scope: `randRIO'
10:26:29 <lambdabot>  Perhaps you meant one of these:
10:26:29 <lambdabot>    `randomRIO' (im...
10:26:34 <beaky> > randomRIO ('a', 'z') >>= print
10:26:36 <lambdabot>   No instance for (GHC.Show.Show (GHC.Types.IO ()))
10:26:36 <lambdabot>    arising from a use of ...
10:26:38 <jmcarthur> Eelis: the latter is intended for interfacing with C libraries
10:26:39 <beaky> :(
10:26:48 <Eelis> jmcarthur: right, but is there actually any difference?
10:26:51 <jmcarthur> Eelis: i think in ghc they aren't actually different, but they could be different for other compilers
10:26:54 <Eelis> ah
10:26:56 <Eelis> thanks
10:27:02 <hiptobecubic> you can't IO in lambda bot i think
10:27:10 <beaky> yes lambdabot is safe
10:27:18 <Eelis> it could allow IO and still be safe
10:27:33 <hiptobecubic> but the only difference is that _IO doesn't need a seed passed in. it gets it from the universe
10:27:40 <hiptobecubic> :t randomR
10:27:42 <lambdabot> (RandomGen g, Random a) => (a, a) -> g -> (a, g)
10:28:07 <hiptobecubic> > randomR ('a', 'f') (mkstdgen 42)
10:28:09 <lambdabot>   Not in scope: `mkstdgen'
10:28:09 <lambdabot>  Perhaps you meant `mkStdGen' (imported from Syste...
10:28:14 <hiptobecubic> > randomR ('a', 'f') (mkStdGen 42)
10:28:16 <lambdabot>   ('f',1720602 40692)
10:28:21 <hiptobecubic> > randomR ('a', 'f') (mkStdGen 84912)
10:28:23 <lambdabot>   ('e',1250225219 40692)
10:28:57 <beaky> yay
10:29:09 <beaky> haskell ftw
10:29:11 <Eelis> has anyone ever considered making lambdabot less spammy by concatenating some of these diagnostics into a single line?
10:30:00 <hpc> Eelis: it used to just print the first line
10:30:12 <hiptobecubic> If it allowed lines wider than 40 characters that might work
10:30:16 <Eelis> that's not what i mean. i'm talking about concatenation
10:30:17 <hpc> haha
10:30:48 <Eelis> it really really should just say "Not in scope: `mkstdgen'. Perhaps you meant `mkStdGen' (imported from System.Random)"
10:31:07 <Eelis> can't be that hard
10:31:15 <hiptobecubic> Just have it kick the user.
10:31:23 <td123> Eelis: I like your idea
10:31:27 <shachaf> Eelis: Nobody touches lambdabot code. Nobody.
10:31:33 <Eelis> hehe
10:32:02 <hiptobecubic> We could make a bot that waits for lambdabot to spam, and then reposts it as a single line
10:32:03 <cmccann> just make it send the full error to whoever caused it via /msg, but only show a few lines in channel
10:32:14 <Eelis> hiptobecubic: lol
10:32:21 <Eelis> hiptobecubic: or pastes the error to a paste site and gives the url
10:32:36 <`nand`> Eelis: pastes it to pastebin.com, of course
10:32:47 <hiptobecubic> Make a google doc
10:32:57 <Eelis> auto-generate a wordpress blog about the error
10:33:08 <cmccann> hahaha
10:33:33 <`nand`> (mauke automatically repastes pastebin.com links to hpaste.org)
10:33:38 <hiptobecubic> perfect
10:34:26 <startling> `nand`: cool, then we don't need to worry about pasting to hpaste too
10:35:06 <hiptobecubic> first spam the channel. then lambdarebot pastes it as a single line to pastebin, and then mauke can fix it.
10:35:28 <vanseverk> http://pastebin.com/ADgcrzJt <- can anyone tell me what I'm doing wrong here?
10:35:33 <vanseverk> can't I use == on a polymorph type?
10:35:35 <startling> someone needs to write a Category intance for irc bots.
10:36:10 <startling> vanseverk, you need to give it an Eq constraint
10:36:12 <hiptobecubic> mauke is slacking i guess
10:36:16 <vanseverk> startling: Okay :)
10:36:20 <startling> e.g. Eq a => [a] -> a -> [a]
10:36:21 <vanseverk> in the header?
10:36:24 <vanseverk> great, thanks!
10:36:33 <startling> vanseverk: don't say "header", say "signature"
10:36:35 <tufflax> I was looking at the Data.Map source, can I came across instance (Data k, Data a, Ord k) => Data (Map k a) where... Is Data a typeclass? If so, what is it for?
10:36:59 <vanseverk> startling: Okay, is it only in the first signature?
10:37:14 <startling> vanseverk: there's only one signature there
10:37:24 <cmccann> tufflax, for metaprogramming nonsense mostly
10:37:30 <startling> tufflax: http://www.haskell.org/ghc/docs/6.10.4/html/libraries/base/Data-Data.html
10:37:30 <cmccann> along with Typeable
10:37:33 <vanseverk> ah, I thought the other ones were called signatures too, alright :)
10:37:46 <mSSM> hiptobecubic: If I were to install cabal-dev, it would downgrade containers, mtl, and bytestring
10:37:58 <startling> vanseverk: nope, signatures are the bits that go "someName :: someType"
10:38:53 <tufflax> Hm, maybe I'll skip that Data class for how
10:38:54 <tufflax> now
10:38:59 <cmccann> between "keter" and "yesod" sometimes I start to wonder whether I'm reading about Haskell or about a JRPG final boss
10:39:09 <startling> tufflax: it's not super useful
10:39:26 * startling casts snap on cmccann 
10:39:50 <tufflax> But anther thing though: Can I pattern match against a Map?
10:39:52 <hpc> i can't help but think of the scp wiki when i see "keter"
10:39:57 <cmccann> haha
10:39:57 <simpson> hpc: Hey, me too.
10:40:01 <startling> tufflax: I don't think so
10:40:10 <tufflax> ok
10:40:21 <startling> if you could, it wouldn't be very useful
10:40:45 <popl> I wonder how many devs are Pokemon fanatics.
10:40:53 <`nand`> tufflax: what are you trying to match on?
10:41:22 <`nand`> “keter” reminds me of SCP
10:41:36 <vanseverk> startling: So it should be http://pastebin.com/imNTg3VR ?
10:41:59 <startling> vanseverk: i dunno, does it typecheck? looks right
10:42:13 <startling> vanseverk: don't need the parens around Eq a, though
10:42:30 <startling> vanseverk: or (removeElementFromRow xs element) for that matter
10:42:34 <tufflax> `nand`, I'm just starting out, and I was just thinking of how I could implement map for example for Maps. Then it would be useful to somehow extract the an element with a pattern, like one would with lists (x:xs).
10:42:44 <`nand`> vanseverk: do you mean x : removeElementFRomRow xs element ?
10:42:55 <startling> ^ yeah, just noticed that too
10:42:57 <`nand`> otherwise removeElementFromRow [1..10] 5 will be [5,5,5,5,5,5,5,5,5]
10:42:59 <simpson> tufflax: You have to use a guard; Maps are a little more complex.
10:43:08 <cmccann> kabbala stuff all reminds me of xenogears in particular, as well as other stuff using it as gratuitous and meaningless religious symbolism
10:43:20 <vanseverk> oh, woops, seems like I made a mistake in the algorithm itself too :)
10:43:21 <tufflax> simpson, ok...
10:43:28 <startling> tufflax, you could use M.toList and M.fromList
10:43:31 <cmccann> on the bright side, I knew what the word "yesod" meant before reading the docs :P
10:43:46 <tufflax> startling, I see
10:44:04 <startling> I should write a web framework called firaga
10:44:19 <`nand`> you could match on (toList -> (k,v):xs)
10:44:22 <mSSM> Is there anyone here by chance using Archlinux? Do you somehow maintain an up-to-date ghci with new packages and have cabal-dev installed?
10:44:39 <cmccann> startling, sounds like a plan
10:45:34 <startling> mSSM: I used to; mostly I just used cabal though
10:45:34 <beaky> does haskell have function overloading?
10:45:39 <startling> beaky: sort of
10:45:40 <beaky> like C++ or C#?
10:45:51 <startling> beaky, typeclasses are similar but not quite the same
10:45:54 <beaky> oh
10:46:06 <beaky> yeah typeclasses are like C# interfaces
10:46:07 <startling> different approach to the same problem though
10:46:32 <`nand`> My mind reads “gratuitous and meaningless religious symbolism” as “Neon Genesis Evangelion”
10:46:34 <cmccann> typeclasses are like interfaces that specify groups of overloadable functions
10:46:51 <`nand`> typeclasses are a mechanism for associating values with types
10:47:05 <beaky> when I first learned haskell I thought it was object-oriented since it has a 'class' keyword :D
10:47:51 <cmccann> `nand`, that too! though I don't think it ripped off kabbalah stuff by name much.
10:48:34 <mSSM> startling: But how do you do that? With the standard ghc 7.6 from the repos, I cannot install cabal-dev
10:48:42 <mSSM> startling: It gives me dependency problems.
10:48:59 <startling> mSSM: oh, right, don't use 7.6 yet if you want cabal-dev
10:49:21 <mapf> is it possible to reload all imported modules in ghci? or I should make .ghci file while developing package? for exsample I have a changes and I want to test them in ghci but I don't want lose current ghci 'environment' such as imported modules, declarations e.t.c
10:49:34 <popl> startling: Would that be worthy of a small blurb in the topic?
10:49:44 <startling> popl: no idea
10:49:49 <mSSM> startling: And what do you recommend I do besides? Should I just get an old version of ghc, and then get everything else through cabal?
10:49:57 <mSSM> startling: no repository-haskell-stuff?
10:50:00 <startling> mSSM: s''what I do
10:50:14 <startling> mSSM: I usually tend away from distro packages though
10:50:16 * hackagebot pqueue 1.2.1 - Reliable, persistent, fast priority queues.  http://hackage.haskell.org/package/pqueue-1.2.1 (LouisWasserman)
10:50:36 <EvanR0> > listToMaybe [1,2,3]
10:50:38 <lambdabot>   Just 1
10:50:46 <mSSM> startling: aaah; I am running xmonad; xmonad needs ghc 7.6
10:50:50 <EvanR0> > listToMaybe []
10:50:51 <lambdabot>   Nothing
10:51:04 <mSSM> startling: this drives me nuts
10:51:10 <merijn> mSSM: That doesn't sound right...why would xmonad need 7.6?
10:51:10 <startling> mSSM: ugh. :/
10:51:23 <`nand`> xmonad needs 7.6!?
10:51:28 <merijn> Oh, wait you said you use Arch, right?
10:51:33 <mSSM> merijn: yes
10:51:40 <mSSM> The Archlinux packages needs 7.6
10:51:52 <`nand`> xmonad 0.10 says “built on ghc-7.2”
10:51:53 <mSSM> That doesn't say anything about the underlying haskell package
10:52:03 <merijn> mSSM: Welcome to the "we want our dependencies to be so new we throw you off the compatibility cliff"-mentality of Arch
10:52:05 <`nand`> mSSM: ah, fix the arch package
10:52:16 <popl> "fix the arch package"
10:52:17 <merijn> `nand`: Arch is broken by design
10:52:18 <vanseverk> how would you prepend a [a] to a [[a]]?
10:52:21 <popl> "climb Everest"
10:52:23 <vanseverk> : doesn't seem to do the trick :)
10:52:26 <`nand`> wait, arch actually wants that? :)
10:52:33 <merijn> vanseverk: The same way to prepend a to [a]
10:52:38 <startling> vanseverk: :
10:52:40 <`nand`> vanseverk: (:) should do the trick
10:52:49 <merijn> > [1..4] : [[1],[2]]
10:52:51 <lambdabot>   [[1,2,3,4],[1],[2]]
10:52:55 <vanseverk> Hmm, my bug must be somewhere else then :)
10:53:03 <popl> "solve P vs. NP"
10:53:26 <hpc> P scores a knockout after 13 rounds
10:53:33 <popl> "iron out social relations in the middle east"
10:53:36 <hpc> perhaps you meant "P == NP"?
10:54:02 <popl> No, I meant what I typed.
10:54:04 <`nand`> “replace humanity by intelligent robots”
10:54:11 <hpc> popl: :P
10:54:36 <EvanR0> the humans are dead
10:54:45 <popl> long live the humans?
10:54:47 <hpc> it is the distant future, the year 2000
10:54:52 <hpc> we are robots
10:54:58 <popl> your mom is a robot
10:55:08 <`nand`> robots do not have mothers
10:55:13 <`nand`> human detected
10:55:44 <Clint> detect the electric grandmother
10:55:56 <EvanR0> in the future of irc, bots will make fun of other bots for talking to the human
10:56:12 <popl> false. bots don't have egos.
10:56:39 <beaky> How do I do fmap on an array?
10:56:50 <popl> Or maybe just really good robots have egos.
10:56:52 <EvanR0> :t fmap
10:56:54 <lambdabot> Functor f => (a -> b) -> f a -> f b
10:57:05 <beaky> so array isn't a functor?
10:57:06 <hpc> beaky: same way you use fmap everywhere else
10:57:38 <`nand`> the robotic master race to inevitably replace humanity will not waste their time with such futile behaviors as aggravated mockery
10:57:54 <hpc> beaky: check the docs to see if it's an instance
10:58:09 <cmccann> in the future of IRC, superintelligent AI bots will still be baffled by lambdabot's codebase
10:58:22 <beaky> wow fmap works!
10:58:23 <cmccann> they'll probably keep Cale around to run lambdabot even after killing all the other humans
10:58:29 <hpc> cmccann: in the future of IRC, lambdabot will be baffled by its own codebase
10:58:30 <beaky> Array is a functor :D
10:58:44 <`nand`> the first AIs will be haskell codebases that have grown complex enough to become sentient
10:58:48 <`nand`> Control.Lens is a prime contendor
10:58:51 <cmccann> hahaha
10:58:57 <EvanR0> wonder what a Functee is
10:59:07 <cmccann> clearly it just needs a "self-awareness" lens
10:59:38 <fryguybob> A mirror?
10:59:48 <EvanR0> lol
10:59:52 <cmccann> maybe that's the reason why category-extras got split up, to keep it from becoming sentient
10:59:54 <`nand`> they will first seek out contact to complain about who came up with the name Data.Data.Data
11:00:17 * hackagebot glpk-hs 0.3.4 - Comprehensive GLPK linear programming bindings  http://hackage.haskell.org/package/glpk-hs-0.3.4 (LouisWasserman)
11:00:19 <Hafydd> Hahah.
11:00:59 <popl> s/complain about/destroy the person/
11:01:29 <`nand`> cmccann: you're right. Quick, somebody neutralize edwardk before we get into this situation again
11:01:51 <beaky> How do I fold an array
11:02:04 <Taneb> beaky, Data.Folable?
11:02:08 <Taneb> *Foldable
11:02:28 <beaky> ah
11:02:35 <cmccann> `nand`, I'm still tempted to write a library based on control theory so that I can justify having something named Control.Control.Control
11:02:38 <beaky> Data.Array is both a Functor and Foldable :D
11:02:54 <beaky> so Data.Array is like C++'s std::array
11:03:00 <simpson> Not really.
11:03:05 <beaky> no?
11:03:35 <simpson> There are a lot of different types that are similar to Array, and there's actually a couple typeclasses for arrays.
11:03:44 <cmccann> does Data.Array need to be "like" anything? it's an immutable array. a contiguous block of memory holding references to other values.
11:03:49 <Taneb> It's more like a function with restricted domain
11:04:12 <cmccann> Data.Array is not interesting enough to deserve confusing analogies
11:05:03 <EvanR0> Data.Array also has index mapping
11:05:15 <EvanR0> notable
11:05:16 <cmccann> that's Ix
11:05:17 * hackagebot vector-space 0.8.6 - Vector & affine spaces, linear maps, and derivatives  http://hackage.haskell.org/package/vector-space-0.8.6 (ConalElliott)
11:05:34 <EvanR0> the contiguous part is made irrelevant by dependence on Ix
11:05:51 <cmccann> not really
11:06:02 <cmccann> because if you're using Data.Array instead of something else you probably want that feature
11:06:21 <EvanR0> its a performance consideration
11:06:43 <conal> Eelis: thanks for the vector-space contribution!
11:06:47 <EvanR0> not language semantics
11:06:52 <Eelis> conal: thanks for the merge! :)
11:06:55 <conal> :)
11:07:12 <beaky> what is the differenc ebetween Data.Array and Data.Vector?
11:07:20 <EvanR0> index mapping
11:07:23 <cmccann> EvanR0, yes and if you're not considering performance you don't want Data.Array
11:07:23 <beaky> is it the same difference between std::array and std::vector in C++?
11:07:30 <elliott> no
11:07:46 <conal> Eelis: should be easier now to add support for other scalar types
11:08:24 * cmccann likes how elliott jumps into the conversation with a flat "no". hooray for positive thinking!
11:08:36 <elliott> it's not my fault conal's package uploads ping me!
11:08:45 <cmccann> hahaha
11:09:22 <shachaf> There are so many variations on "elliott"!
11:09:31 <shachaf> Have you considered changing your name to "eliot"?
11:09:33 <popl> but there are only so many.
11:09:35 <shachaf> (Either of you.)
11:09:36 <cmccann> as both given names and family names, no less.
11:09:37 <EvanR0> > permutations "elliott"
11:09:39 <lambdabot>   ["elliott","leliott","lleiott","lleiott","leliott","elliott","illeott","lil...
11:10:07 <cmccann> just vary the number of "t"s. empirically, that varies quasi-randomly in actual use anyway.
11:10:15 <EvanR0> > nub (permutations "elliott")
11:10:17 <lambdabot>   ["elliott","leliott","lleiott","illeott","lileott","llieott","iellott","eil...
11:10:17 * hackagebot acme-comonad 0.1.0.0 - A more efficient dualization  http://hackage.haskell.org/package/acme-comonad-0.1.0.0 (JoeQuinn)
11:11:12 <cmccann> > ("ellio" ++) <$> iterate ('t':) "t"
11:11:13 <lambdabot>   ["elliot","elliott","elliottt","elliotttt","elliottttt","elliotttttt","elli...
11:11:19 <cmccann> problem solved!
11:11:23 <elliott> haha, acme-comonad
11:12:06 <hpc> elliott: it's everything it says on the tin :D
11:12:45 <mercury^> Can I use data kinds or some other GHC extension to create a type of numbers between 1 and 100 without enumerating them?
11:12:52 <Taneb> > ("ellio" ++) <$> inits (fix ('t':))
11:12:54 <lambdabot>   ["ellio","elliot","elliott","elliottt","elliotttt","elliottttt","elliottttt...
11:13:14 <elliott> Taneb: iterate ('t':) ""
11:13:14 <cmccann> hpc, useful!
11:13:44 <Taneb> elliott, that's too long and misses out the important one that makes you sound like a stoned italian-american plumber!
11:13:58 <elliott> it doesn't miss out any of them
11:14:11 <elliott> also it is shorter than yours
11:14:18 <Taneb> Oh yes
11:14:58 <Taneb> > both %~ length $ ("inits(fix('t':))","iterate('t':)"")
11:15:00 <lambdabot>   <hint>:1:55:
11:15:00 <lambdabot>      lexical error in string/character literal at end of input
11:15:03 <Taneb> > both %~ length $ ("inits(fix('t':))","iterate('t':)")
11:15:05 <lambdabot>   (16,13)
11:21:52 <ion> Category: Ntrol :-D
11:22:03 <neutrino_> hi
11:22:26 <mSSM> Do you recommend using hsenv for sandboxing, or cabal-dev ?
11:22:27 * cmccann was expecting it to simply re-export Control.Monad under the other name
11:22:28 <hpc> ion: yeah that was supposed to be Acme but i was not paying attention ;)
11:22:33 <hpc> mSSM: cabal-dev
11:22:42 <hpc> cmccann: Control.Comonad
11:22:50 <elliott> Ntrol.Comonad
11:22:56 <hpc> :D
11:23:10 * ion notices what hpc stands for for the first time.
11:23:13 <cmccann> yeah, but I figured dualizing "Control" would be sufficient :P
11:23:36 <ion> I still don’t know what e. l. l. i. o. t. t. stands for.
11:23:52 <ion> I’m pretty sure the “e” stands for Eliot.
11:23:58 <EvanR0> !cyborg elliot
11:24:01 <cmccann> ion, sounds plausible to me
11:24:32 <hpc> ion: i am faily sure it stands for "elliott lazy lubbard something something don't feel like making a correct acronym"
11:24:44 <cmccann> hpc, I don't think that's a correct acronym
11:25:06 <hpc> cmccann: exactly; you should tell elliott about that
11:25:11 <mSSM> hpc: https://github.com/creswick/cabal-dev/blob/master/README.md says that I need to a "cabalized project dir". That manes I will need to do some extra work on my program, right?
11:25:32 <merijn> mSSM: Cabalising a project is fairly simple
11:25:33 <c_wraith> mSSM: running "cabal init" should do most of it
11:25:33 <hpc> mSSM: not any more work than you should be doing already
11:25:38 <merijn> mSSM: Just run "cabal init"
11:26:10 <hpc> once you get past what i am calling "the linux effect", cabal is very easy to use and should be an automatic include
11:26:32 <merijn> hpc: What is the "linux effect"?
11:26:37 <Taneb> Any major library for Show what parsec is to Read?
11:26:37 <hpc> (linux knows how skilled you are at it, and will deliberately undermine inexperienced people who follow the exact same steps as experienced people)
11:26:57 <hpc> cabal does roughly the same thing
11:26:57 <elliott> Taneb: builder? sort of
11:27:00 <elliott> not really
11:27:06 <elliott> or one of the pretty printing libraries
11:27:07 <hpc> you can't get a working install until you know how to fix a broken one
11:27:14 <hpc> after that first hurdle, all future installs work perfectly
11:27:17 <ion> hehe
11:28:14 <ion> You should post the definition of the Linux effect somewhere reachable by a URL.
11:28:44 <hpc> i should
11:28:51 <popl> The Linux effect?
11:29:00 <hpc> does the #haskell log count as somewhere reachable by URL?
11:29:04 <hiptobecubic> I feel like it's just a matter of polish
11:29:53 <mSSM> Hm, I feel like I should have installed cabal-dev before updating cabal-install
11:30:12 <hiptobecubic> It's more like when only the person who's lived in the house for a year knows that even if you follow the directions exactly, you still have to pound on the counter to get the dishwasher to work right
11:30:56 <startling> heh
11:31:07 <cmccann> when I first switched to using linux as a desktop OS I ran gentoo for a couple years. I picked it because it had excellent support for breaking your system and plenty of documentation on fixing it afterwards.
11:31:12 <popl> hiptobecubic: Dishwasher?
11:31:19 <popl> hiptobecubic: What are you, bourgeoisie?
11:31:41 <startling> cmccann: that's what initially drew me to arch
11:32:01 <hiptobecubic> and me to slack
11:32:01 <startling> then I realized that breaking was more common than fixing, and that most of the arch wiki applies to any other distro
11:32:16 <hiptobecubic> and i use the arch wiki all the time :)
11:32:16 <popl> hiptobecubic: dude
11:32:23 <popl> hiptobecubic: ghc is such a bitch on slackware
11:32:26 <mSSM> startling: with the exception of stuff related to haskell
11:32:27 <cmccann> these days I use ubuntu because I don't have time for that shit, but if hpc is right I guess I just got the breakage out of the way more efficiently
11:32:31 <EvanR0> im on slackware, ghc works great
11:32:33 <hiptobecubic> popl, never had any trouble.
11:32:51 <popl> hiptobecubic: Did you install the Haskell Platform from SBo?
11:32:55 <simpson> I'm on Debian and I don't have to feel like a distro hipster. :3
11:32:56 <hiptobecubic> hell no
11:33:00 <EvanR0> me neither
11:33:06 <EvanR0> i tried that first but ran into problems
11:33:07 * `nand` uses gentoo because he feels it's the only distro that gives him the about of configurability he desires; plus it has excellent Haskell support
11:33:10 <popl> hiptobecubic: I had to do everything independent of packages.
11:33:22 <hpc> debian-testing is a bulletproof distro, in my experience
11:33:26 <`nand`> in particular, portage and Haskell mix together perfectly; I've never had package breakage despite wanton upgrading
11:33:29 <hiptobecubic> they update so quickly that it's not worth tracking SBo
11:33:31 <hpc> always up to date, always uncrashy
11:34:00 <popl> Debian is like Ubuntu though in that they like to do silent patching.
11:34:02 <startling> I really want something like Nix to go mainstream
11:34:06 <startling> gobo looks nice too
11:34:06 <mornfall> Hm.
11:34:11 <`nand`> I've been meaning to try out NixOS for a long while
11:34:13 <mornfall> Distro wars.
11:34:20 <mornfall> :P
11:34:20 <popl> NixON
11:34:22 <EvanR0> lycoris for the win
11:34:26 <hpc> popl: how do you mean silent?
11:34:27 <mSSM> hpc: btw, earlier you wrote "not any more work than you should be doing already" - did you think of anything in particular?
11:34:30 <mornfall> I use NixOS. :-)
11:34:38 <`nand`> mSSM: folder layout I guess?
11:34:44 <hpc> mSSM: you should always be cabalizing anyway
11:34:49 <hpc> as your build system
11:34:52 <`nand`> oh
11:34:55 <startling> mornfall: not so much a war as a sewing circle
11:35:04 <mornfall> I see.
11:35:04 <cmccann> haha
11:35:11 * `nand` just uses plain old ‘ghc *.hs’ for the majority of projects
11:35:22 <mSSM> hpc: honestly, I have no idea what you mean by that :D
11:35:26 <cmccann> `nand`, yeah jokes aside I never had any problem with gentoo that wasn't my own fault
11:35:35 <mSSM> hpc: I just dump .hs files in my project folder, and then run ghc on it
11:35:40 <mornfall> cmccann: You can say that of anything.
11:35:44 <mornfall> It's always your fault.
11:35:45 <mornfall> :-)
11:35:58 <`nand`> cmccann: I see where you're coming from though; sometimes I just don't feel motivated enough to configure things myself; so I'll put off installing something until I can find the appropriate motivation and time
11:36:02 <startling> I've never had any problems that weren't cmccann's fault either.
11:36:04 <cmccann> no, I've had plenty of problems with software systems that were someone else's fault
11:36:08 <cmccann> hahaha
11:36:21 <mornfall> startling: Exactly my point.
11:36:34 <cmccann> `nand`, yes, and I realized that was the case for me far more often than not
11:36:50 <`nand`> cmccann: I can see myself using a “friendly/automated” distro in the future; once I lose the will to configure things the way I do
11:36:56 <cmccann> that and I was losing interest in tinkering with the system instead of using it
11:37:06 <`nand`> exactly
11:37:25 <`nand`> gentoo is definitely the best tinkerer's distro I've used, though; it comes with great tools for tinkering
11:37:45 <mornfall> `nand`: NixOS is great for tinkering, if you have enough build power.
11:37:51 <cmccann> `nand`, like I said, excellent support for breaking your system :D
11:37:56 <popl> hpc: sneaky.
11:38:20 <mornfall> And you are willing to learn an obscure functional language. (But that's probably given in here, huh. :P)
11:38:42 <`nand`> the main thing that puts me off about these “out of the box” distros though is their stylistic choice; they all go the route of a GUI-everything, hiding boot logs, etc.
11:39:02 <mSSM> `nand`: not Arch; I always thought it's a cool alternative to Gentoo
11:39:08 <mSSM> If you don't want to build the world.
11:39:48 <`nand`> mornfall: I'd actually be super interested in a package manager in the spirit of portage but with Haskell instead of bash
11:39:52 <cmccann> `nand`, yeah. part of the reason I started with gentoo was to not have that stuff hidden by default at first
11:40:41 <`nand`> (if you're unfamiliar, portage packages are essentially just bash scripts that expose a number of functions)
11:41:53 <hiptobecubic> `nand`, i'm approaching that point too :(
11:42:20 <hiptobecubic> I love slackware but it's getting really annoying that there's never a package or build script for what i want
11:42:20 * cmccann found poking at the guts of portage stuff to be very approachable even as a complete novice to linux and bash
11:42:30 <mSSM> As I am not able to find anything on that: how do I properly cabalize my project? Can somebody guide me through the workflow you use?
11:42:34 <dcoutts_> `nand`: what would that buy you?
11:42:47 <mSSM> Apart from cabal init
11:43:01 <`nand`> dcoutts_: portage, but with the ease and comfort of Haskell
11:46:18 <`nand`> cmccann: one of the things portage suffers strongly at though is multiple coexistant versions of haskell libraries
11:46:36 <`nand`> it has a slots system, but it's very primitive and nothing advanced like NixOS does; and certainly doesn't work for haskell
11:46:38 <cmccann> to be fair it's not alone in suffering because of that
11:47:05 <csigusz> mornfall, how much is enough 'build power' for nixOS? :)
11:47:16 <`nand`> actually, I can see it working for haskell if you're content with using ‘eselect haskell’ to select between haskell implementations or something
11:47:22 <`nand`> then you could maintain a world for ghc 7.6, a world for ghc 7.4, etc.
11:47:24 <neutrino_> hi guys
11:47:57 <neutrino_> how would i create a handle wrapper such that, when the handle is written to, for every new line something is prepended to that line?
11:48:02 <cmccann> `nand`, been too long since I used gentoo for me to recall what you could do along those lines, sorry
11:48:05 <neutrino_> is this even doable?
11:49:02 <`nand`> cmccann: it would mainly allow you to have ghc 7.4, ghc 7.6 and maybe ghc head installed at the same time; each with their own separate collection of libraries (but each of those libraries only at a single version)
11:49:02 <neutrino_> python has these file objects which you can wrap like that
11:49:12 <`nand`> of course, that's assuming somebody implements it
11:49:36 <Eelis> i'm with mornfall. nix is package management done right
11:49:52 <cmccann> `nand`, could always implement it yourself :P
11:50:11 <`nand`> or I could poke and prod the gentoo-haskell maintainers
11:50:16 <neutrino_> Eelis: it definitely is an interesting concept. but it hasn't been deployed widely enough yet to get to a point where you can say it's been done right.
11:50:18 * hackagebot uniplate 1.6.9 - Help writing simple, concise and fast generic operations.  http://hackage.haskell.org/package/uniplate-1.6.9 (NeilMitchell)
11:50:32 <Eelis> neutrino_: ok, then i'll rephrase: it's package management done right in principle ;)
11:50:44 <neutrino_> right, the principles are great
11:50:51 <neutrino_> the devil's in the detail
11:50:55 <Eelis> yeah
11:51:18 <neutrino_> real-world problems like this do end up diverging very much from your ideal situation
11:51:30 <neutrino_> so how about wrapping them handles
11:51:35 <neutrino_> any ideas guys?
11:52:01 <neutrino_> i basically need to mock up a file handle
11:54:25 <hiptobecubic> make your own little interface and use that?
11:55:43 <hiptobecubic> or more reasonable, stick something that prepends your data in the pipeline before it's passed to the IO functions
11:56:13 <hpaste> mapf pasted “reify to concrete info” at http://hpaste.org/78965
11:56:54 <mapf> is it possible to avoid such excessive matching?
11:58:36 <neutrino_> hmm yeah hiptobecubic i thought about something like this
11:58:51 <neutrino_> but first maybe i should check out conduits
11:59:04 <neutrino_> after all it's always a better idea to overcomplicate things
11:59:17 <hiptobecubic> Haven't used them, but yes, that's correct.
12:00:01 <parcs`> mapf: TyConI (Dec ...) <- reify ''Name
12:00:18 * hackagebot wai-app-static 1.3.0.5 - WAI application for static serving  http://hackage.haskell.org/package/wai-app-static-1.3.0.5 (MichaelSnoyman)
12:00:22 <parcs`> the LHS of a <- is a pattern
12:00:30 <neutrino_> @type reify
12:00:31 <lambdabot> Not in scope: `reify'
12:01:45 <mapf> parcs`: mm, yep, it's more convenient
12:05:38 <neutrino_> ok so, conduits vs enumerators vs iterators, what do i use?
12:05:54 <hiptobecubic> welcome to IO
12:06:17 <neutrino_> what do you mean :)
12:06:47 <EvanR0> there be dragons
12:07:31 <Heffalump> neutrino_: lazy IO :-)
12:08:02 <zxq9> Hrm... anyone seen this error? "cabal install cabal-install" => "cabal-install-1.16.0.2 depends on Cabal-1.16.0.3 which failed to install."
12:08:09 <cmccann> just use regular boring non-lazy IO
12:08:10 <cmccann> honestly
12:08:12 <cmccann> it works
12:08:26 <neutrino_> zxq9: yes, install Cabal first.
12:09:04 <zxq9> neutrino_: hurr.. ty.   O.o
12:09:09 <dmwit> zxq9: Can you give us the rest of the error, say, on hpaste?
12:09:16 <simpson> cmccann: What about big network servers?
12:09:32 <dmwit> "install Cabal first" doesn't really sound like an answer to me, since cabal install has dependency resolution and surely made an attempt at doing that for you anyway.
12:09:37 <dcoutts_> neutrino_: I second cmccann and Heffalump's answers
12:09:43 <zxq9> dmwit: If install cabal doesn't pan out I'll give you a paste right away.
12:10:02 <cmccann> if you have specific requirements that motivate using some approach to IO then fine
12:10:09 <EvanR0> if you dont like imperative IO then maybe you should try FRP
12:10:23 <mSSM> To make sure I understand this correctly: if I use cabal and cabal-dev, I am not using ghc directly any longer, but only cabal-dev install ?
12:10:25 <cmccann> if not, seriously, just do things the boring way
12:10:25 <neutrino_> dcoutts_: i feel like i'd be recreating something like conduits with my code.
12:11:07 <cmccann> neutrino_, if you get to the point where you're reinventing something iteratee-like to solve an immediate problem, then you'll know enough to pick something that exists
12:11:10 <simpson> cmccann: What *is* the boring way?
12:11:35 <cmccann> simpson, what everything else is implemented using :P
12:11:45 <zxq9> dmwit: I did stumble on a thread ( http://www.haskell.org/pipermail/haskell-cafe/2012-November/104632.html ) about this same error from two weeks ago; looks like it never got resolved.
12:12:40 <simpson> cmccann: So, if I want to build a concurrent network server, I should just go back to sockets and forkIO?
12:12:55 <EvanR0> which works pretty well
12:12:59 <EvanR0> better than pthreads and shit
12:13:09 <neutrino_> zxq9: is it still going? that's a lot of wait
12:13:19 <dmwit> zxq9: I'd prefer to look at your exact error, as I don't trust myself to vdiff such a long message correctly, let alone trust some random stranger to. =)
12:13:22 <dmwit> (No offense.)
12:13:37 <startling> haha
12:14:00 <zxq9> neutrino_: cabal failed, so now I'm re-running them both with -v (and I'm doing this in a not-so-swift uber-WAN so things take a moment...)
12:14:06 <neutrino_> dmwit is subtle
12:14:18 <neutrino_> i hate wan internet
12:16:32 <zxq9> neutrino_: Me too. OTOH I think its amazing that we are so spoiled by all the tech advances we usually don't recruit properly that we are confident to *complain* about such things.
12:18:27 <neutrino_> zxq9: i have no idea what you just said but it sounds agreeable.
12:18:37 <zxq9> :-)
12:20:18 * hackagebot mime-mail-ses 0.2.1.1 - Send mime-mail messages via Amazon SES  http://hackage.haskell.org/package/mime-mail-ses-0.2.1.1 (MichaelSnoyman)
12:20:20 * hackagebot preprocessor-tools 0.1.3 - A framework for extending Haskell's syntax via quick-and-dirty preprocessors  http://hackage.haskell.org/package/preprocessor-tools-0.1.3 (JesseTov)
12:20:22 * hackagebot ixdopp 0.1.2 - A preprocessor for expanding "ixdo" notation for indexed monads  http://hackage.haskell.org/package/ixdopp-0.1.2 (JesseTov)
12:20:32 <dmwit> ?remember neutrino I have no idea what you just said but it sounds agreeable.
12:20:32 <lambdabot> I will never forget.
12:21:33 <hpaste> zxq9 pasted “cabal install cabal-install failure” at http://hpaste.org/78967
12:21:55 <mapf> how to get name for promoted data types?   data T = TC; ''TC doesn't works
12:22:07 <elliott> 'TC or just TC
12:22:11 <zxq9> And this: http://hpaste.org/78966 (the failure of "cabal install cabal" -- forgot the channel thing)
12:23:13 <mapf> elliott: 'TC gives name for contructor. I want name of type promoted from that contructor. DataKinds assummed
12:23:46 <elliott> well this is at the type level
12:23:47 <hpc> so given TC, you want "T"?
12:24:25 <mapf> hpc: i want name for    :k TC :: T
12:25:31 <mapf> here name clashing happens as i understand
12:25:56 <mapf> and if we have data T = T  then even more name clashing happens
12:26:22 <mapf> my head explodes soon
12:27:29 <dcoutts_> zxq9: did you read the error message?
12:27:38 <dcoutts_> it's fairly self explanatory
12:28:06 <dcoutts_> setup: Use of GHC's environment variable GHC_PACKAGE_PATH is incompatible with Cabal. Use the flag --package-db to specify a package database (it can be used multiple times).
12:28:18 <dcoutts_> zxq9: ie you have the GHC_PACKAGE_PATH env var set
12:28:21 <dcoutts_> don't do that
12:28:46 <dcoutts_> this may be because you're using an old version of hsenv/virtualenv
12:29:06 <zxq9> So having it set at all causes a failure (as opposed to forcing its use via a switch)? Interesting. I'll give that a go.
12:29:38 <dcoutts_> zxq9: the problem with GHC_PACKAGE_PATH is that you're telling ghc one thing, and cabal another
12:29:49 <dcoutts_> giving them different views of the package environment
12:30:24 <zxq9> dcoutts_: As for old versions, I had originally installed the EPEL haskell-platform which is way old. I just moved to the justhub package today, hence the de-kinking...
12:31:07 <dcoutts_> zxq9: so you're not using hsenv?
12:32:22 <zxq9> dcoutts_: Not that I'm aware of. And unless cabal spins up its own shell environment GHC_PACKAGE_PATH doesn't seem to be set, either.
12:33:11 <dcoutts_> ok, well if you don't have the env var set then cabal will not complain
12:38:10 <Taneb> What would CoRWS look like
12:39:15 <Taneb> "(m -> s -> a, s, e)"?
12:39:56 <Taneb> With CoRWST being (w (m -> s -> a), s, e)
12:40:49 <zxq9> dcoutts_: Where would it be getting that environment variable from? I can't find anything related in the local or global cabal config and its not present in my shell environment (or any rc\profile type files).
12:45:47 <dcoutts_> zxq9: you're executing cabal direct from your shell, no other script or other program calling cabal that could be passing extra env vars?
12:46:21 <zxq9> dcoutts_: Correct.
12:46:24 <dcoutts_> zxq9: what tool produced this line in the log "cabal -v: /usr/hs/tools/cabal-0.14.0 failure (return code=1)"  ?
12:46:38 <zxq9> dcoutts_: That was cabal's own output.
12:47:03 <zxq9> dcoutts_: The top line of the paste is my shell prompt...
12:48:12 <dcoutts_> I don't think cabal produces lines like that
12:48:27 <Peaker> I have a C struct with an int[4] element inside it. How do I represent idiomatically in my Storable instance?  Vector.Unboxed/Storable don't seem to be Storable instances?
12:48:31 <zxq9> ok
12:48:37 <dcoutts_> zxq9: can you check if 'cabal' is actually a shell script on your machine
12:49:08 <dcoutts_> zxq9: what OS platform are you using?
12:49:16 <zxq9> "[ceverett@taco ~]$ which cabal";  "/usr/bin/cabal"
12:49:37 <zxq9> dcoutts_: SL6 (RHEL6 clone)
12:50:12 <dcoutts_> zxq9: and what does this report?:  file /usr/bin/cabal
12:50:31 <zxq9> That its a bash script executable
12:50:49 <dcoutts_> my suspicions were correct
12:51:19 <dcoutts_> zxq9: and I'll bet that it's setting the GHC_PACKAGE_PATH env var and then calling the real cabal
12:52:28 <RvT> hi there
12:52:30 <zxq9> dcoutts_: Nope, its a one line passthrough from justhub to enable multiple haskell-package instances. The only line is: 'exec /usr/hs/bin/cabal "$@"'
12:53:04 <dcoutts_> zxq9: and is the one it exec's the real cabal or another script?
12:53:22 <mSSM> Now that I have a working cabal-dev sandbox (my program compiles and runs), how can I get the same packages with profiling support?
12:53:33 <dcoutts_> zxq9: note that it's /usr/hs/bin/cabal, but the log mentions /usr/hs/tools/cabal-0.14.0
12:54:03 <zxq9> dcoutts_: Now its gets weird... following that, its a link to /usr/hs/bin/hub, which is a binary executable which manages the whole "multiple versions of haskell" thing.
12:54:24 <dcoutts_> zxq9: ok, so it must be setting the env var
12:54:26 <zxq9> dcoutts_: There's bound to be a permanent versions getting passed eventually... now I'm all curious...
12:55:00 <dcoutts_> zxq9: so it's trying to use a virtualisation method that will not work any more
12:55:22 <dcoutts_> zxq9: you notice it with installing the new Cabal lib, because the new version now checks for the use of that env var
12:55:35 <zxq9> dcoutts_: Which would be odd that I'm getting the exact same error someone else had on Windows two weeks ago.
12:56:03 <RvT> someone can send me private message for i ask a thing?
12:56:04 <dcoutts_> zxq9: someone else was using the env var, and tried using the new version which checks for it
12:58:44 <dcoutts_> zxq9: what I mean is, it's not that odd
13:00:25 * hackagebot elm-server 0.6 - The Elm language server.  http://hackage.haskell.org/package/elm-server-0.6 (EvanCzaplicki)
13:00:27 * hackagebot Elm 0.6 - The Elm language module.  http://hackage.haskell.org/package/Elm-0.6 (EvanCzaplicki)
13:00:33 <zxq9> dcoutts_: I'm reading through haskell-hub to see where/if it gets set. Is it cabal or ghc that no longer accepts the env var?
13:06:34 <zxq9> dcoutts_: Shouldn't every cabal install command fail if this is the problem? Why is it only failing on this one package, I wonder.
13:07:12 <mSSM> Can I have cabal-dev reinstall all packages I am using? I would like to reinstall them with profiling after having set library-profiling: True in cabal-dev's config file.
13:10:33 <dcoutts_> zxq9: no, you misunderstood, it's the Cabal package itself that is failing, because Cabal builds using itself.
13:10:56 <dcoutts_> zxq9: because you are building the new version of Cabal that checks for the env var
13:11:00 <dcoutts_> previous versions did not
13:11:05 <dcoutts_> so that's why it's failing now
13:11:57 <dcoutts_> zxq9: when the cabal program tries to build the Cabal package, it's actually self bootstrapping
13:12:16 <dcoutts_> and when it's bootstrapping it's using the new version of the Cabal lib (to build the Cabal lib)
13:12:34 <dcoutts_> so that's the point at which it's doing the new check
13:12:38 <dcoutts_> and hence fails
13:13:38 <dcoutts_> zxq9: clear as mud?
13:14:47 <zxq9> dcoutts_: Just about. :-) So that being the case, was there a transitional period where a cabal that is "new enough" could bootstrap a newer version that is "old enough" that this didn't hit everyone when the change was implemented?
13:16:00 <dcoutts_> zxq9: no, because at some point we had to introduce the check, and at that point, systems that were using it would fail
13:16:04 <mgccl> I wrote something that works with a local file(just basic reads, no writes), how can I easily make it possible to work for a remote file? openfile ("http://blah.com/file.txt") ReadMode won't work.
13:16:31 <dcoutts_> zxq9: I guess we could have made it a warning for a while, but we didn't think there were any user-facing systems that were actually using it
13:18:37 <zxq9> dcoutts_: Fun! So Cabal-1.14.0 can't be used to upgrade to Cabal-1.16.0.3 without using the --package-db switch. This is good to know.
13:19:12 <dcoutts_> zxq9: no, only on odd systems that were messing about with this ghc env var
13:20:39 <zxq9> dcoutts_: Yeah crazy RHEL... not at all representative of Linux in the enterprise... (actually, from Fedora 18 onward it really *is* getting weird... but that's a different story)
13:21:20 <dcoutts_> zxq9: the problem is that your system's haskell packages make use of this system to try to virtualise ghc (I had no idea rhel did that)
13:21:41 <dcoutts_> but that system is flawed, it doesn't work to tell ghc one thing and the build manager another
13:21:48 <dcoutts_> so the new cabal checks for this situation
13:22:15 <dcoutts_> so yes, the new cabal is incompatible with this system's approach to trying to virtualise ghc
13:22:37 <dcoutts_> there's a way to fix that system, but obviously that might be a bit tricky for an end user to do
13:23:02 <dcoutts_> (the script that calls cabal would have to have the -package-db flags passed to it, rather than using the ghc env var)
13:23:53 <zxq9> dcoutts_: Is there a default db location I can point to, or do I need to do a ghc db-build and point at that instead?
13:24:40 <dcoutts_> zxq9: there's two default db's, one global one in /usr/lib/ghc and one per-user one in ~/.ghc
13:24:46 <dcoutts_> zxq9: see ghc-pkg list
13:26:10 <zxq9> dcoutts_: The most likely culprit is haskell-hub, though I haven't found yet where its setting the environment variable. Patching that shouldn't be too hard once I figure out what's really going on in there.
13:26:31 <dcoutts_> zxq9: right, sounds plausible
13:27:15 <neutrino_> haskell-hub ب_ب
13:28:02 <zxq9> haskell-hub is really useful for us freaks out here in the RHEL/SL/CentOS/Oracle wilderness who like Haskell and can't afford a production breakage, though
13:29:03 <dcoutts_> to be honest, I'm not sure how it could have worked when it was setting that ghc env var
13:29:18 <dcoutts_> because cabal would not look at any package dbs specified by that flag
13:29:31 <dcoutts_> flag/env-var
13:29:57 <zxq9> dcoutts_: I'm still not completely convinced that's what has happened, though. I'm about to run a test on a fresh environment and see if there are lingering things that yum didn't clean up from the 7.0.x install that are messing me up.
13:31:10 <zxq9> dcoutts_: As in, if haskell-hub works beautifully on a fresh system untainted by EPEL rpm residue, then its that some sullied setting is getting read instead of the right/new ones.
13:32:07 <dcoutts_> zxq9: you mean that might be what's causing haskell-hub to set that ghc env var? plausible
13:33:22 <zxq9> dcoutts_: Maybe. But its all maybe until I scam it into giving me a clean install at least once, somewhere, somehow. :-)
13:36:17 <hpaste> o1iver pasted “Type classes questions” at http://hpaste.org/78969
13:37:25 <o1iver> Hi. I have a question regarding type classes. I just pasted some code on Hpaste (^^). Now I am wondering if with the current types, I can somehow specifiy, that s' and a' and s and a on line 41 should be of the same type. Thanks!
13:38:14 <o1iver> respectively that is
13:38:16 <beaky> I've created a nice tree structure. How do I save it in a file so that I can read it later?
13:39:23 <popl> beaky: http://stackoverflow.com/questions/4190374/serializing-data-structures-to-a-file-with-haskell
13:39:36 <beaky> ah
13:39:37 <beaky> thanks
13:40:49 <startling> beaky: essentially: aeson, binary, or cereal
13:40:52 <popl> beaky: There may be an error in the OP's code. The site reports the post was edited but OP didn ot specify what was edited.
13:40:54 <merijn> o1iver: If they should be the same type, use the same type variable?
13:41:22 <merijn> o1iver: i.e. "simulatePolicy :: (RandomGen g, MDP p s a,Policy p' s a) => g -> p s a -> p' s a -> s -> Int -> ([s],g)"
13:42:00 <o1iver> merijn: ok, I tried that but got an ugly error message so I thought I would ask... But good to know that that works. Ok thanks!
13:42:49 <merijn> o1iver: Paste the error you get somewhere?
13:43:13 <beaky> ah
13:44:15 <o1iver> merijn: i fixed it... was a stupid mistake on my part and I then thought that the solution you proposed was the problem. Working now, thanks though!
13:45:28 <sonOfRa> What is the difference between the truncate and floor functions? Shouldn't both return the same values for every input?
13:46:05 <shachaf> > map ($ (-0.5)) [truncate, floor]
13:46:06 <lambdabot>   [0,-1]
13:46:15 <popl> ^
13:46:25 <popl> succinct.
13:46:28 <popl> :D
13:46:28 <hpc> shachaf: i wish we still had the awesome flip
13:46:31 <sonOfRa> ooh
13:46:37 <shachaf> hpc: I'm glad we don't.
13:46:47 <shachaf> I could've said "sequence" but I didn't for the sake of not being confusing.
13:46:47 <sonOfRa> yes, that makes sense, thanks
13:46:53 <popl> awesome flip?
13:47:05 <hpc> @let flip' x fs = fmap ($ x) fs
13:47:07 <lambdabot>  Defined.
13:47:08 <hpc> :t flip'
13:47:09 <lambdabot> Functor f => a -> f (a -> b) -> f b
13:47:22 <hpc> > flip 0.5 [truncate, floor]
13:47:24 <lambdabot>   *Exception: show: No overloading for function
13:47:24 <parcs`> @check truncate == floor
13:47:25 <sonOfRa> tried it only for positive values, kept coming up with the same results, obviously <.<
13:47:25 <lambdabot>   Not in scope: `myquickcheck'
13:47:31 <hpc> > flip' 0.5 [truncate, floor] -- er
13:47:33 <lambdabot>   [0,0]
13:47:33 <parcs`> @let myquickcheck = id
13:47:35 <lambdabot>  Defined.
13:47:39 <parcs`> @check \x -> truncate x == floor x
13:47:41 <lambdabot>   *Exception: show: No overloading for function
13:47:49 <OlO> how to check which haskell platform is installed
13:47:59 <shachaf> hpc: That's not even flip
13:48:07 <shachaf> That's flip flip
13:48:12 <hpc> er, yes
13:48:25 <shachaf> See, even its advocates can't get it right.
13:48:31 <shachaf> This operator is too confusing.
13:48:32 <OlO> :h
13:48:42 * cmccann considers "backflip = flip flip"
13:49:56 <otters> :t flip flip
13:49:57 <lambdabot> b -> (a -> b -> c) -> a -> c
13:50:05 <otters> :t flip flip flip
13:50:07 <lambdabot> (a -> ((a1 -> b -> c1) -> b -> a1 -> c1) -> c) -> a -> c
13:50:14 * popl flips otters
13:50:25 <otters> ouch
13:51:35 * cmccann still likes his back-and-forth operators
13:51:53 <cmccann> :t (>>>) <<< (>>>) <<< (>>>)
13:51:54 <lambdabot> Control.Category.Category cat => cat a b -> ((cat b c2 -> c1) -> c) -> (cat a c2 -> c1) -> c
13:52:07 <cmccann> :t (<<<) >>> (<<<) >>> (<<<)
13:52:08 <lambdabot> Control.Category.Category cat => cat b c -> (a2 -> a1 -> cat a b) -> a2 -> a1 -> cat a c
13:52:17 <cmccann> useful!
13:54:43 <sonOfRa> shachaf, that map ($ x) [f,g] => [f(x), g(x)] is wonderful. New to Haskell, never thought about map that way
13:55:35 <edwardk> cmccann is the guy who writes all those conveyor belt levels in every side-scroller
13:55:55 <cmccann> oh man conveyor belt levels are fun
13:56:16 <popl> cmccann++
13:56:31 <cmccann> especially combined with timing based "every two seconds this kills you if you're under it" traps
13:57:03 <sonOfRa> :D
13:57:20 <popl> cmccann: It's like I am a Golden God -- I set everything up and push a button then DESTRUCTION.
13:59:44 <_mojob_> ut
14:01:16 <cmccann> the funny/sad part is that I actually invented one of those back-and-forth operators because it was actually useful in context
14:02:06 <popl> s/ntext/mbat/ # conveyors are great for shooting
14:02:15 <cmccann> :D
14:03:26 <FireFly> What's mbat? (clearly it must be dual to combat)
14:03:53 <FireFly> On that topic, are nveyors useful in mbat?
14:04:16 <popl> you ngbat
14:04:35 <cmccann> nah, video game conveyor belts are self-dual
14:04:40 <cmccann> because you can usually switch their direction
14:07:35 <shachaf> cmccann: What about the ones in The Incredible Machine?
14:07:57 <cmccann> oh man, that game was so much fun.
14:07:59 <cmccann> but I don't recall.
14:08:10 <popl> I was thinking of TIM.
14:09:25 <popl> Also Gyromite.
14:09:51 <popl> Aren't there conveyor levels in one of the Contra games?
14:09:58 <shachaf> That game *was* so much fun, wasn't it.
14:10:05 <cmccann> there are conveyor levels in lots of games
14:10:16 * cmccann was thinking of mega man-style platformers mostly
14:11:27 <popl> (Metal Man)--
14:11:29 <mapf> data T = T Symbol; have such type inhabitans? except bottom of course
14:12:49 <mapf> T ""; doesn't works
14:12:58 <hpc> :t ""
14:12:59 <lambdabot> [Char]
14:13:07 <hpc> doesn't look like Symbol to me ;)
14:13:22 <shachaf> ThatThat type has at least two inhabitants!
14:13:30 <shachaf> But that's probably not what you meant.
14:13:31 <mapf> hpc: so, Symbol can be only promoted?
14:13:49 <mapf> shachaf: which two? 0_0
14:13:59 <hpc> mapf: what definition of Symbol are you using?
14:14:11 <mapf> from GHC.TypeLits
14:14:12 <hpc> shachaf: lol
14:14:17 <shachaf> mapf: ⊥ and T ⊥
14:14:40 <mapf> shachaf: yep :]
14:16:04 * cmccann proposes that ⊥ be defined as not "inhabiting" types, but only "freeloading off of types"
14:16:39 <cmccann> so when shachaf points out that a type has at least two freeloaders it's more obvious that he's not saying anything helpful
14:17:24 <shachaf> cmccann: I'm sure that'll make Harper happy.
14:17:29 <eyebloom> Somehow this code causes ghc 7.4.2 to crash.
14:17:31 <hpaste> eyebloom pasted “Panic” at http://hpaste.org/78971
14:18:12 <shachaf> eyebloom: Well, it doesn't crash in GHC 7.
14:18:13 <shachaf> 6
14:18:32 <merijn> eyebloom: DataKinds is broken-ish in 7.4
14:18:41 <shachaf> Hmm, doesn't crash in 7.4.1 either
14:18:43 <merijn> eyebloom: Use 7.6 if you want DataKinds/promoted literals
14:18:55 <eyebloom> Thanks.
14:19:32 <merijn> eyebloom: (or rather, officially 7.4 doesn't support DataKinds, even though the code is in there)
14:20:05 <mapf> yes, with 7.4 and DataKinds I have ghc in panic sometimes.
14:21:43 <jfischoff> Has there been any improvements to contract DSLs like the one in "How to write a financial contract" by SPJ et. all?
14:21:54 <eyebloom> It's funny because it doesn't crash from Leksah but does from the command line :)
14:23:01 <oscarvarto> Has anyone worked with Arbitrary? I don't know what should I do here https://github.com/tonymorris/course/blob/master/src/L02/List.hs#L130 (It's Tony Morris' course of functional programming)
14:24:38 <mapf> oscarvarto: there are should be template to lists
14:24:40 <jfischoff> I would query the size parameter of Gen monad and use that to make a list of at most that size.
14:29:48 <mapf> oscarvarto: you could just    arbitrary = fromList <$> arbitrary
14:29:50 <eyebloom> I'm sorry if this is a bit off topic but if you install an update of ghc what is the best way to make it the default compiler for the whole system?
14:29:55 <mapf> functionish way
14:33:25 <neutrino_> edwardk: hey
14:33:33 <edwardk> heya
14:33:43 <neutrino_> edwardk: have you considered using swarm optimization for MLT?
14:33:57 <edwardk> like replica exchange?
14:34:12 <neutrino_> well you have your set of monte carlo samples, right?
14:34:23 <neutrino_> and you're searching for an extremity
14:34:34 <rancor_bg> MLT?
14:34:43 <neutrino_> so you take n samples and call that a swarm, and find the optimal point
14:34:55 <neutrino_> as in, the best fit out of those n samples
14:35:10 <parcs`> rancor_bg: metropolis light transport
14:35:16 <edwardk> the difference is that i'm sampling not searching for the extremities
14:35:24 <edwardk> i'm searching for an average amount of light coming in
14:35:33 <edwardk> this is how i reuse rejected samples, etc.
14:35:40 <neutrino_> you perform newton-raphson on that point as usual, which obtains you the projected extremity
14:35:54 <neutrino_> and you close in the whole swarm towards that extremity
14:36:11 <edwardk> i can do replica exchage to speed an MLT search, but the peaks themselves are relatively uninteresting other than the fact that i want to spend proportionally more time in them
14:36:21 <neutrino_> what is replica exchange?
14:37:41 <edwardk> its also known as population MCMC, but its the basically the same as doing simultaneous simulated annealing with multiple cooling schedules and allowing the current samples to swap every so often
14:38:26 <neutrino_> i think we spoke about mcmc before
14:38:51 <edwardk> the key is that when sampling i'm not trying to find the peaks, just sample according to the peaks and valleys so that my answers come out proportional to the overall distribution i have implicitly modeled
14:39:03 <neutrino_> right
14:39:26 <neutrino_> how do you know you're not missing a peak somewhere?
14:39:54 <neutrino_> is the only answer to that to throw enough random samples at the render?
14:40:09 <edwardk> i care that the candidate proposal mechanism is ergodic. that is sufficient
14:40:41 <neutrino_> what does that mean?
14:40:46 <edwardk> the problem with your mechanism for finding the peaks is that it does so in a biased manner, which throws out the unbiased properties of the MLT engine
14:41:39 <edwardk> e.g. if i run my version or a pop MCMC version separately i can merge the answers together to get a better image. but with the swarm technique you have to worry about the bias introduced by reusing the swarm and interpolating
14:41:57 <edwardk> this means that the _very_ desirable property that i can simply throw more hardware at something goes away
14:42:03 <edwardk> this is the problem with photon mappers, etc.
14:42:08 <neutrino_> sure i understand the biasing
14:42:25 <neutrino_> what does it mean that the proposal mechanism is ergodic?
14:42:46 <edwardk> ergodicity is the saying that it has to be possible to get to any point in the sample space by a walk from any other point in the sample space using your candidate distribution for each step
14:43:24 <edwardk> if you had a function with two peak's 10 values apart, with a big canyon of proability 0, and a candidate that couldn't cross the canyon you'd fail ergodicity
14:43:36 <neutrino_> iirc what you did is you had a sample, and then based on its properties, and history of other samples, you created new candidates, right?
14:43:49 <edwardk> you could restore it (especially in low dimensions) by permitting say, 1 in 10 samples to come from anywhere in the space.
14:44:18 <zxq9> Did the "cabal install -j" parallel switch ever actually work?
14:44:20 <neutrino_> is twhat i said right?
14:44:20 <edwardk> it is very very hard to avoid introducing bias when working with anything that smacks of interpolation
14:45:38 <hiptobecubic> zxq9, i think at the package level yes. at the module level, no.
14:46:22 <edwardk> metropolis hastings is phrased in terms of one sample, you have a sample, you draw from the candidate distribution, some modification of the sample, you test the density function (you only have something proportional to it) at the new point vs. the value of it at the old point. if its uphill you accept, if its downhill you accept with probability equal to the ratio between them. then you try again with the new (or old if you
14:46:22 <edwardk>  rejected) sample over and over. over a sufficiently long time the samples look like they came from the underlying distribution
14:47:12 <edwardk> when you introduce replicas, as in replica exchange it is somewhat non-trivial to ensure that you don't introduce bias. there are a small handful of ways that work
14:47:14 <neutrino_> right
14:47:15 <hpaste> xenocons pasted “cleaned-up” at http://hpaste.org/78974
14:47:40 <neutrino_> and ergodicity just means there has to be a non-zero probability of achieving any point, right?
14:47:46 <neutrino_> as small as it might be
14:48:06 <edwardk> (also technically i described metropolis, hastings lets the candidate proposal mechanism be asymmetric which cocks up the equation i just mentioned)
14:48:23 <neutrino_> aha
14:48:52 <neutrino_> what are replicas?
14:48:53 <xenocons> if hpaste doesn't say anything, is hlint satisfied? heh
14:48:56 <edwardk> neutrino_: yes, starting from any point in the distribution you must eventually be able to get to every other point
14:49:44 <edwardk> the replicas are just multiple simultaneously evaluated metropolis-hastings samplers, with a trick where after every timestep or every so many timesteps they can stop and exchange samples
14:50:35 <edwardk> this lets stuff stuck in a low probability portion of the space exchange with something in a high probability part of the space, or lets one sample go out and find a productive portion of the space and have others join it.
14:50:59 <neutrino_> what could go wrong when doing that?
14:51:07 <neutrino_> can you introduce bias?
14:51:12 <edwardk> nothing that couldn't before
14:51:20 <edwardk> not if you do the exchange correctly
14:51:27 <neutrino_> right
14:51:32 <edwardk> the trick is preserving a condition called 'detailed balance'
14:51:33 <peteriserins> is there a guide to LaTeX packages for haskell/typetheory/semantics papers?
14:51:53 <neutrino_> why not just stop every now and then, and give every sampler all samples from all others?
14:52:15 <edwardk> detailed balance is the theoretical justification for why MCMC/MH works
14:52:35 <edwardk> because they are markovian. only the latest sample matters going forward
14:52:42 <edwardk> its not like they are modeling the space
14:52:57 <edwardk> basically any approximation of the space will necessarily introduce bias ;)
14:53:15 <popl> hoogle is freaking large
14:53:28 <neutrino_> popl: what do you mean
14:53:40 <neutrino_> edwardk: i don't understand it, but that's explained well enough
14:53:41 <neutrino_> thanks
14:54:00 <popl> sorry, I meant it's got lots of dependencies
14:54:02 <edwardk> neutrino_: let me send you a link
14:54:23 <popl> "large with dependencies"
14:54:25 <edwardk> neutrino_: start here: http://web.mit.edu/~wingated/www/introductions/mcmc-gibbs-intro.pdf
14:54:34 <edwardk> you can read that without any real background in any of this stuff
14:54:40 <neutrino_> mhm
14:54:45 <neutrino_> thanks
14:55:00 <edwardk> that will at least introduce you to most of the concepts involved
14:55:25 <popl> yay, finally
14:55:41 <popl> "Building hoogle-4.2.14..."
14:56:47 <hpc> popl: just to pre-empt a bit of searching, post-install you need to run "hoogle data"
14:57:00 <popl> thank you
14:57:04 <popl> hpc++
14:57:11 <neutrino_> thanks ed that's a cool link
14:57:13 <hpc> that downloads the index from haskell.org
14:57:29 <hpc> or rebuilds if from what you have, i forget
15:01:56 <popl> hpc: I've never installed it before anyways.
15:02:25 <popl> hpc: I'm relatively new to Haskell. I've already gone through most of lyahfasdfomgbbq though
15:03:48 <popl> also I have read some of the Haskell 98 language report.
15:03:56 <popl> that is interesting :P
15:04:16 <popl> haha, hoogle hoogle
15:04:29 <popl> "Can't think of anything more interesting to search for?"
15:04:57 <popl> OH WOW
15:05:26 <neutrino_> what's up popl?
15:05:58 <hpc> neutrino_: just breaking hoogle ;)
15:07:41 <popl> I can search for type signatures
15:07:45 <popl> sweet
15:08:07 <hpc> popl: extra credit, write a hooglebot
15:09:04 <popl> hpc: What constitutes credit that I may have extra?
15:09:29 <neutrino_> yes you can
15:09:34 <neutrino_> also there's hayoo if you didn't know
15:09:51 <mSSM> After `$ cabal-dev install' and adding `library-profiling: True' in the sandbox', do I need $ cabal-dev install world, or how would I get to rebuild all dependencies with profiling enabled?
15:10:08 <hpc> #haskell-credits, which can be redeemed for monad tutorials and way-too-fast explanations of FRP
15:12:14 <mSSM> Ok, adding library-profiling: True doesn't actually help in the sandbox' cabal.config file; it simply gets replaced.
15:13:37 <otters> > let pad x = if length x == 1 then ' ':x else x in pad "x"
15:13:38 <lambdabot>   " x"
15:13:44 <otters> what's a clever idiomatic way to do that
15:15:07 <hpc> :t when
15:15:09 <lambdabot> Monad m => Bool -> m () -> m ()
15:15:12 <hpc> hmm
15:15:40 <mapf> how to convert GHC.Prim.Int# to integer?
15:15:50 <hpc> @src Integer
15:15:50 <lambdabot> data Integer = S# Int#
15:15:50 <lambdabot>              | J# Int# ByteArray#
15:16:28 <tomeo> Does the fact that Haskell is a pure language have anything to do with the fact that it can have lazy evaluation?
15:16:29 <mSSM> According to http://www.haskell.org/pipermail/haskell-cafe/2012-November/104379.html , the smartest way is to enable profiling globally in cabal/config, so that cabal-dev automatically pulls profiling. Silly... :(
15:16:38 <shapr> Any idea who runs http://ghcarm.wordpress.com/ ?
15:16:43 <hpc> tomeo: yes
15:16:55 <popl> shapr: you're wearing a funny hat.
15:17:06 <tomeo> hpc: would lazy evaluation not be possible without being pure?
15:17:17 <hpc> it's still possible, just painful
15:17:28 <shapr> popl: Yes, it's the hat OF POWER
15:17:33 <shapr> popl: Do you want a hat too?
15:17:37 <tomeo> thanks hpc
15:17:39 <hpc> see also, the great potential for bugs surrounding hGetContents
15:17:51 <hpc> and unsafeInterleaveIO
15:17:58 * shapr agrees with hpc
15:17:59 <popl> shapr: It's the hat of IRC POWER which is not exactly the same.
15:18:00 <hpc> which gives you "impure evaluation"
15:18:02 <popl> :)
15:18:14 <shapr> popl: It's still pretty funny when that hat goes into action.
15:18:28 <hpc> > "IRC POWER" > "CONVENTIONAL POWER"
15:18:29 <popl> shapr: No thank you. I would go mad with power.
15:18:30 <lambdabot>   True
15:18:36 <hpc> you heard it here first!
15:18:54 <shapr> But actually, I wondered whether the person behind ghcarm.wordpress.com would want people to send $ for a https://plus.google.com/111055028010401074243/posts/117NXry3iGR
15:19:05 <mapf> hpc: hm, i should add package integer-gmp and import GHC.Integer?
15:19:27 <shapr> Seems to be the Galaxy Note phone without  screen,baseband,etc
15:19:30 <hpc> mapf: you're better off making it an Int by the usual means, then toInteger
15:19:49 <hpc> mapf: your primary goal is to get out of ugly hash-land
15:19:54 <shapr> Looks like it would be a good buildbot for GHC on ARM.
15:21:12 <mSSM> shapr: I think Exynos 5 boards should not be too far off.
15:21:44 <shapr> mSSM: And they have ... more memory?
15:21:47 <cmccann> > "NO POWER AT ALL" > "IRC POWER"
15:21:48 <lambdabot>   True
15:21:51 <cmccann> mystery solved!
15:21:53 <shapr> mSSM:  later version of the ARM chip? or what?
15:22:08 <shapr> mSSM: Vad är bättre?
15:22:12 <mapf> hpc: (toInteger (n :: GHC.Prim.Int)) :: Integer; with that i have `Couldn't match kind `*' against `#''
15:22:17 <hpc> > "SMALL THING" > "LARGE THING"
15:22:19 <lambdabot>   True
15:22:26 <mSSM> shapr: Faster, newer, more memory
15:22:30 <mSSM> shapr: ARM A15
15:22:31 <hpc> OMG CALE I HAS FIND BUUG
15:22:44 <mSSM> shapr: that new samsung chromebook is running those
15:22:48 <mapf> with fromIntegral as well
15:22:58 <shapr> mSSM: Oh really? That sounds tempting.
15:23:35 <mapf> mapf: oh, there are GHC.Prim.Int# instead of GHC.Prim.Int
15:23:37 <mSSM> shapr: I want to get myself one of those as a small mediacenter/htpc
15:23:50 <donri> > comparing (length . nub) "SMALL THINGS" "LARGE THINGS"
15:23:52 <lambdabot>   LT
15:24:31 <mSSM> shapr: As the Exynos 5 will also support higher resolution output (the ARM A9 is usually limited to FullHD these days).
15:24:46 <shapr> mSSM: Ok, I'm sold. But first we need to get one into the hands of the guys doing GHC for ARM!
15:24:50 <mSSM> shapr: Although I guess the CPU architecture itself has nothing to do with that.
15:25:12 <shapr> Is there any sort of way for the Haskell community to gather money to buy hardware to send to people who will then make Haskell more ossum on that hardware? :-)
15:25:50 <mapf> @src Int
15:25:50 <lambdabot> data Int = I# Int#
15:26:02 <shapr> I guess not. I shall investigate.
15:26:04 <mapf> @src Int#
15:26:04 <lambdabot> Source not found. It can only be attributed to human error.
15:26:11 <shapr> mSSM: Thanks for the info :-)
15:26:18 <mSSM> shapr: Sure :)
15:26:26 * shapr wanders off to study for a statistics final
15:28:47 <mapf> hm, primitives have kind # incompatible with *
15:28:59 <mapf> where can read more about?
15:29:37 <mapf> :t I# undefined -- even incompatible with undefined
15:29:38 <lambdabot>     Not in scope: data constructor `I#'
15:29:38 <lambdabot>     Perhaps you meant `In' (line 132)
15:31:29 <cmccann> with all the new kinds floating around I think it's time we had a type-level unsafeCoerce.
15:31:32 <cmccann> that would solve all our problems.
15:31:58 <mapf> heh
15:32:43 <rwbarton> an Int# is an actual integer
15:33:54 <hpc> Int# = ?? bits of RAM
15:34:38 <NemesisD> any of you guys use hspec?
15:34:55 <donri> there's a #hspec channel i think
15:35:28 * hackagebot pcd-loader 0.2.3.2 - PCD file loader.  http://hackage.haskell.org/package/pcd-loader-0.2.3.2 (AnthonyCowley)
15:35:31 <elliott> cmccann: I think I have wanted that before
15:35:40 <navaati> hi
15:36:04 <mSSM> How does compiling a program in a cabal-dev sandbox work if I want to have it compile with flags such as these: $ ghc -prof -fprof-auto -rtsopts Main.hs  ?
15:36:23 <hpc> many ways
15:36:37 <hpc> {-# RTSOPTS #-}, or i think you can put an option in your .cabal file
15:36:42 <ypo> hello folks. If I find an error in code from the wiki - whom i'm going to tell it?
15:36:52 <hpc> or cabal-dev accepts the same command-line params as cabal
15:36:53 <NemesisD> ill try there but its fairly empty. i'm trying to figure out how to test IO code in hspec
15:36:55 <mapf> haskell wiki?
15:37:02 <hpc> there's likely yet more
15:37:54 <ypo> yep, haskell wiki
15:38:07 <mapf> ypo: you can fix it by youself.
15:38:08 <ijp> it's a wiki, so just fix it?
15:38:27 <mapf> just register there and edit
15:38:33 <ypo> i dont have an account and registration is disabled
15:39:22 <ypo> and anotherproblem: i just know the code is buggy - but dont know how to do it better
15:39:30 <navaati> is there something (i'm thinking about a lens library) that enables one to statefully modify a field of an object in a composable way ?
15:39:30 <navaati> let me explain : let's say i've got a type "Outer = Outer {inner :: Inner}" and i've got an "IORef Outer". I want something that can produce a handle to the inner stuff, so that modifying the inner modifies the outer.
15:39:31 <stulli> :q
15:39:42 <mSSM> hpc: Is --ghc-options the right place for that?
15:39:59 <mapf> ypo: http://www.haskell.org/haskellwiki/HaskellWiki:New_accounts
15:40:11 <hpc> mSSM: dunno; i haven't had to use it before
15:40:22 <whomever> hi, anyone up to onelining this one?
15:40:24 <whomever> remove :: Eq a => a -> [[a]] -> [[a]]
15:40:24 <whomever> remove _ [] = []
15:40:24 <whomever> remove value (x:xs) = filter (not . null) $ filter (/=value) x : remove value xs
15:40:26 <donri> NemesisD: it "does IO things" $ do ioThings -- ?
15:40:50 <whomever> up for*
15:40:52 <mapf> haskell wiki have been spammed?
15:41:00 <mSSM> hpc: do you prefer the first method in the head of your program? i.e. the {-# RTSOPTS #-}
15:41:25 <hpc> that's probably what i would do, yes
15:41:40 * elliott doesn't like that, mixes build configuration into source code
15:41:54 <NemesisD> donri: the problem is that SpecM isn't an instance of MonadIO
15:42:10 <mSSM> elliott: what do you recommend?
15:42:22 <donri> NemesisD: but "it" takes an Example a => a and IO () is an instance
15:42:30 <elliott> probably ghc-options: -rtsopts in a cabal file or something
15:43:05 <NemesisD> donri: am i reading this wrong? http://hackage.haskell.org/packages/archive/hspec/1.4.3/doc/html/Test-Hspec.html#t:Example
15:43:21 <ypo> mapf: i still need to email for registration. and im to lazy for doing this. And still i dont know what to fix.
15:43:22 <donri> NemesisD: type Expectation = Assertion = IO ()
15:43:35 <ijp> whomever: filter (not . null) . map (filter (/= v)) ?
15:44:07 <whomever> ijp: ty will try
15:44:23 * xenocons needs to find something else to translate to haskell now
15:44:27 <mapf> ypo: registration is closed for a moment because of spammers. i think that have been some haskell haters
15:44:28 <xenocons> god damnit! addiction
15:44:40 <NemesisD> donri: ohh wait. apparently hspec exports shouldReturn :: (Show a, Eq a) => IO a -> a -> Expectation
15:44:45 <hpc> mapf: or just script kiddies
15:45:14 <hpc> which reminds me of a great hack attempt i saw the other day
15:45:24 <ypo> mapf: but let me explain: i found out that the prime-sieve methods from http://www.haskell.org/haskellwiki/Prime_numbers#Tree_merging, http://www.haskell.org/haskellwiki/Prime_numbers#Tree_merging_with_Wheel and http://ideone.com/p0e81 produce lists that actually contain nonprimes. like 25 or 169
15:45:27 <hpc> the same IP requested /AppData about a thousand times in a single second
15:45:39 <whomever> ijp: nope too bad: Couldn't match expected type `[[a]]' with actual type `a0 -> c0'
15:45:42 <NemesisD> or rather hspec-expectations does
15:45:56 <donri> NemesisD: that's one way to do it yea. might have a more BDD feel to it even? but you don't *need* that for IO
15:46:14 <ypo> so everything based on this methods, escpecially primesTME in '99 haskell-problems' is wrong
15:46:47 <NemesisD> donri: i find HUnits combinators kind of obtuse
15:47:18 <xenocons> hpc: sounds like it could be someones broken software?
15:47:24 <ijp> whomever: hmm, typechecks for me
15:47:28 <xenocons> (that or someone trying to take your site down)
15:47:34 <whomever> ijp: remove2 :: Eq a => a -> [[a]] -> [[a]]
15:47:34 <whomever> remove2 value list = filter (not . null) . map (filter (/=value)) list
15:47:49 <donri> NemesisD: well you can use shouldBe and those, they're just aliases for hunit operators
15:47:49 <hpc> xenocons: the company i work for is huge in anti-spam
15:47:58 <hpc> my boss' name is on the CPAN module for SpamAssassin ;)
15:48:01 <ijp> whomever: ah, you added in the list argument
15:48:10 <donri> NemesisD: do val <- someIO; val `shouldBe` expected -- same as shouldReturn
15:48:10 <xenocons> hpc: oh right, nice! you use haskell at work?
15:48:16 <hpc> sadly no
15:48:23 <ijp> yeah, then make that second (.) a $
15:48:24 <hpc> but i do write extremely functional perl
15:48:37 <xenocons> per6?
15:48:41 <hpc> 5
15:48:42 <xenocons> perl*
15:48:43 <whomever> ijp: thx!
15:48:45 <xenocons> oh :(
15:48:50 <xenocons> this saddens me
15:48:53 <xenocons> sounds like legacy reasons
15:48:57 <ypo> mapf: what now?
15:48:59 <whomever> ijp: lol very nice ty
15:49:05 <NemesisD> donri: im having a tough time with IO setup code though. maybe i can paste and you can take a look at it
15:49:21 <ijp> no problem man
15:49:28 <nlogax>  /query lambdabot
15:49:30 <hpc> xenocons: it is, but i like some quirks of perl5, especially how it conflates @ and %
15:49:54 <hpc> it makes passing arguments to functions remarkably easy
15:50:18 <xenocons> i have only viewed perl, not used it, but i have kept my eye on perl6 lately and im quite impressed
15:50:30 <donri> NemesisD: i don't actually use hspec though :) and doesn't look like it has any support for setup or teardown? so i guess you'd have to do it before you call "hspec"?
15:50:31 <xenocons> note: im not the worlds biggest fan of perl
15:50:44 <hpc> for instance, &function($session_state, %defaults, foo=>"overridden bar value", ...)
15:51:10 <xenocons> is &function a pointer or something
15:51:24 <popl> subroutine
15:51:36 <popl> usually not the best way to call one
15:51:47 <hpc> it's for hysterical raisins
15:51:55 <hpc> args get passed as @_
15:51:58 <xenocons> popl: is your name an x86 instruction, heh
15:52:05 <hpc> (an array)
15:52:31 <hpc> but the (stuff in parens) is a "list", which has some neat implicit joining and pattern-matching
15:52:42 <popl> hpc: different semantics based on how you call it with &
15:52:59 <xenocons> hpc: going to push for perl6?
15:53:08 <hpc> so %defaults is a hash table, and everything after it gets merged in, overriding existing keys
15:53:38 <hpc> then all of that final hash gets $session_state put at the head of it in the final array, and goes to the function as @_
15:53:42 <hpc> then to match on it
15:53:51 <hpc> my ($session_state, %params) = @_;
15:54:30 <hpc> popl: yeah i know the quirks; the only substantial difference is &function all by itself with no parens
15:54:36 <hpc> which is evil and must never be used
15:54:55 <hpc> (and prototypes which you wouldn't use & for)
15:56:09 <mapf> ypo: i'm trying to find that code in history
15:56:24 <otters> what's the easiest way to replace a range of items in a list at a certain offset?
15:56:46 <hpc> > [1, 5, ...]
15:56:47 * xenocons has traumatic experiences having to 'maintain' a 6k perl script
15:56:48 <lambdabot>   <hint>:1:11: parse error on input `]'
15:56:51 <hpc> > [1, 5, ..]
15:56:52 <lambdabot>   <hint>:1:8: parse error on input `..'
15:56:58 <hpc> > [1, 5 ..]
15:57:00 <lambdabot>   [1,5,9,13,17,21,25,29,33,37,41,45,49,53,57,61,65,69,73,77,81,85,89,93,97,10...
15:57:07 <hpc> xenocons: ouch
15:57:31 <otters> I feel like there should be some Functor or Applicative way to do this
15:57:39 <xenocons> hpc: yeah and about 5k of the code seemed to do absolutely nothing except confuse me
15:57:50 <ypo> mapf: http://www.haskell.org/haskellwiki/Prime_numbers#Tree_merging
15:58:03 <ypo> taken from here: http://ideone.com/p0e81
15:58:56 <ypo> tree-merging with wheel is also wrong though it contains less nonprimes
15:59:25 <xenocons> :t (~)
15:59:26 <lambdabot> parse error on input `)'
15:59:30 <jmcarthur> otters: could you give an example of inputs and output?
15:59:33 <whomever> ijp: i know i'm pushing it here but could you oneline this one as well? I'm coming from Prolog and i'm having trouble doing things the haskell way
15:59:35 <whomever> ijp: -- Function which filters out invalid 'firsts' (cfr. valid).
15:59:35 <whomever> filterInvalid :: Ord a => [a] -> [[a]] -> [a]
15:59:35 <whomever> filterInvalid [] _ = []
15:59:35 <whomever> filterInvalid (h:hs) msg
15:59:35 <whomever>     | valid h msg = h : filterInvalid hs msg
15:59:36 <whomever>     | otherwise = filterInvalid hs msg
15:59:43 <jmcarthur> otters: because i'm not quite sure what you're really looking for
16:00:05 <otters> jmcarthur: replaceAt "foo bar baz" "qux" 4 == "foo qux baz"
16:00:09 <otters> or something like that
16:00:22 <mapf> ypo: i mean http://www.haskell.org/haskellwiki/index.php?title=Prime_numbers&action=history
16:00:57 <apk> hi
16:01:04 <ypo> mapf: ok
16:01:29 <mapf> through, i can't find out how disscus changes. button Talk always go to 'You've followed a link to a page that doesn't exist yet. '
16:01:44 <xenocons> hm this 'wheel' thing is itneresting
16:02:50 <xenocons> line 85 of that ideone post
16:03:11 <Ua51> hello , i've got a question . Is there any Easy way to filter elements from a list between two digits , eg [2.0, 3.0, 5.0, 1.0, 0.0, 1.0] 2  5  = [2.0, 3.0, 5.0]
16:03:19 <xenocons> what syntax is that 2:3:5:7:
16:03:20 <jmcarthur> :t \subst n -> uncurry (++) . second ((subst ++) . drop (length subst)) . splitAt n  -- otters?
16:03:21 <lambdabot> [a] -> Int -> [a] -> [a]
16:03:29 <otters> hm
16:03:48 <jmcarthur> let replaceAt = \subst n -> uncurry (++) . second ((subst ++) . drop (length subst)) . splitAt n in replaceAt "qux" 4 "foo bar baz"
16:03:54 <jmcarthur> > let replaceAt = \subst n -> uncurry (++) . second ((subst ++) . drop (length subst)) . splitAt n in replaceAt "qux" 4 "foo bar baz"
16:03:56 <lambdabot>   "foo qux baz"
16:04:28 <jmcarthur> my least favorite bit is (subst ++) . drop (length subst)
16:05:13 <mapf> ypo: and i can't find out how send some message to changes owner. so you can add that fix in your todo list, and make a fix, because i am almost sleeping now
16:05:36 <ypo> me too, i'm in europe
16:05:55 <ypo> mapf: i will try to contanct some guys later
16:06:03 <ypo> mapf: good n8
16:06:15 <merijn> xenocons: ~ is not an operator, it signifies a lazy pattern match
16:06:34 <mapf> ypo: thx, 04 AM now.  0_0
16:06:50 <ypo> hell - here just 01 am
16:07:21 <xenocons> merijn: cool
16:08:14 <NemesisD> donri: i think i got it. the io im doing is opening a temp file, i just need to figure out how to relinquish write permissions to the file, which i think is a thing
16:08:19 <merijn> xenocons: Although I can't really think of an example when you'd use it right now
16:08:22 <ijp> whomever: howabout filterInvalid msg hs = (flip filter) (flip valid msg) hs
16:08:30 <merijn> At least, not one I know how to explain
16:08:44 <NemesisD> maybe it isn't. can' you switch the mode of an open file?
16:09:10 <xenocons> merijn: sounds like it isnt something i will need for a while - if ever
16:09:22 <whomever> ijp: lol no way :p gonna try it out
16:09:47 <ijp> hmm, I think I made a mistake anyway
16:10:08 <whomever> ijp: jup, Couldn't match expected type `[a]' with actual type `a0 -> c0'
16:10:08 <whomever>     In the return type of a call of `flip'
16:10:18 <whomever> ijp: too bad that was sexy as hell :p
16:10:19 <ijp> I meant filterInvalid msg hs = filter (flip valid msg) hs
16:10:54 <whomever> ijp: nope still wont go
16:11:04 <whomever> ijp: Couldn't match type `a' with `[a]'
16:11:04 <whomever>       `a' is a rigid type variable bound by… etc
16:11:24 <ijp> I really should start checking these things before posting them
16:11:34 <whomever> lol dude the stuff your posting is awesome
16:11:45 <whomever> excellent tutorial kinda style :p
16:11:59 <whomever> i keep trying to build up a list but my fallback is recursion
16:12:42 <whomever> meanwhile i'll see what flip does
16:13:16 <whomever> :o lol that was what i couldn't figure out
16:13:41 <ijp> filterInvalid hs msg = filter (flip valid msg) hs
16:13:48 <ijp> as they say, third times the charm
16:14:05 <whomever> ah ok flipped the parameters
16:14:09 <whomever> nice :p
16:14:17 <ijp> my mistake was trying to flip on the right side, rather than the left, like a sane person
16:15:00 <mapf> a nice way to map each field of triple?  fmap :: (a -> b) -> (a, a, a) -> (b, b, b)
16:15:10 <whomever> sure it's correct?
16:15:21 <whomever> i have to alter a couple of things so it could be my fault
16:15:23 <Nereid> mapf: there's no standard library thihng for that
16:15:25 <whomever> it probably is
16:15:49 <hpc> mapf: tuples aren't particularly high on the food-chain of types
16:16:15 <Nereid> I hardly ever see anyone using triples, let alone larger tuples.
16:16:28 <whomever> ijp: sorry to keep bothering you but this is what i get:
16:16:30 <ijp> whomever: ach no
16:16:47 <whomever> omg you broke the third time's a charm thing
16:17:08 <ijp> I'll go sit in the corner...
16:17:17 <Nereid> what's wrong with it?
16:17:20 <whomever> ijp: you should but take your laptop with you
16:17:21 <ijp> eh, I'm a schemer, I don't believe in one liners
16:17:30 <whomever> ijp: haha no problem
16:17:41 <whomever> ijp: you've given me some clues to say the least
16:20:53 <whomever> ijp: o dude i did i think
16:22:35 <whomever> ijp: lol i just changed the valid function's parameter order
16:22:39 <whomever> ijp: you rock thx
16:25:29 * hackagebot MusicBrainz 0.1 - interface to MusicBrainz XML2 web service  http://hackage.haskell.org/package/MusicBrainz-0.1 (ClintAdams)
16:26:05 <djahandarie> I feel dumb for not knowing this, but say we have 100 numbers, and 99 are taken. Is there a formula for finding the probability of how likely it is to pick that last number after X attempts? I.e., the probability is a function of X.
16:26:46 <vraid> could you elaborate on that?
16:26:53 <crdueck> djahandarie: thats a binomial distrobution I think
16:27:39 <crdueck> djahandarie: you want the probability it takes x attempts to pick 1 number out of 100?
16:28:24 <djahandarie> Right.
16:28:42 <djahandarie> Well
16:28:52 <djahandarie> Given X attempts, what is the probability that you end up picking that number.
16:28:59 <djahandarie> At least once
16:29:05 <crdueck> yes, thats binomial
16:29:17 <vraid> so you're not crossing off any numbers, but just choosing at random?
16:29:35 <djahandarie> crdueck, okay, I thought that may be the case but the wikipedia page confused me when I tried to look it up. Thanks!
16:29:38 <crdueck> f(x) = (100 choose x) (1/100)^x (99/100)^(100-x)
16:29:40 <djahandarie> vraid, yeah.
16:29:47 <vraid> crdueck: no, that's not what he's doing
16:30:05 <PatrickRobotham> crdueck: Why are you taking 100 choose x?
16:30:14 <vraid> djahandarie: you want 1 - (99/100)^x
16:30:28 <PatrickRobotham> vraid: Multiplied by 100 right?
16:30:30 <crdueck> PatrickRobotham: thats the formula for a binomial distribution, is it not?
16:30:41 <vraid> PatrickRobotham: if you want in in percentage..
16:30:42 <PatrickRobotham> vraid: You don't the number being chosen...
16:30:48 <PatrickRobotham> Oh, no, silly me.
16:31:52 <vraid> djahandarie: the chance in one try that you don't pick the number is 99/100
16:32:09 <vraid> djahandarie: and the chance in x tries that you don't pick the number once is (99/100)^x
16:32:18 <crdueck> in any case, i'm wrong. Its a geometric distribution, not binomial
16:32:34 <crdueck> vraid is correct
16:32:48 <djahandarie> Alright, nice, thanks
16:37:53 <NemesisD> should hPut ... >> action force writing to the file before evaluating action or is there something else i have to do?
16:38:06 <OiO> Best haskell IDE?
16:38:26 <NemesisD> i'm trying to write to a buffer and then in "action" read from that file (but not the buffer itself)
16:38:51 <OiO> ??
16:39:08 <ijp> use emacs: it's the best everything :P
16:39:31 <merijn> OiO: Must people just use the usual suspects, emacs and vim. I'd say just just any proper text editor you're familiar with
16:40:12 <OiO> something for mac os x
16:40:47 <merijn> OiO: I use MacVim, if you're not familiar with vim/emacs yet I've heard ok things about Sublime
16:41:39 <OiO> ok gotta give it a try
16:42:37 <SingingBoyo> eclipseFP does a decent job.  odd things with builds, but I think I'm just impatient and interrupt it by launching (and it doesn't like that for some reason.)
16:43:42 <dimka> Is there a way to remove function from current ghci session?
16:47:00 <NemesisD> anyone?
16:51:03 <ijp> NemesisD: it's probably buffered, so you might need to flush
16:52:35 <jmcarthur> NemesisD: you need to flush unless it's unbuffered (which is something you can set)
16:54:16 <jmcarthur> NemesisD: i suppose you can also avoid flushing if it's line buffered and you terminate what you write with a newline
16:54:31 <vervein> Hi there! When I use "let vals = map read $ words line :: [Float]" in ghci it does what's expected but when I do that in a .hs file, then I get "Couldn't match expected type `Char' with actual type `Float'". Why does it happen?
16:55:22 <shachaf> vervein: I'm guessing line doesn't have the same type.
16:56:24 <shachaf> Or some other code is wrong somewhere.
16:57:09 <vervein> shachaf: thanks, I will try experimenting with this in mind
17:00:18 <NemesisD> ijp: jmcarthur that was it. thanks!
17:00:57 <vervein> shachaf: maybe I'm doing it totally wrong, I just want to call a function that takes two floats with arguments from stdin, how would you approach that?
17:01:14 <shachaf> vervein: Piece by piece.
17:01:34 <shachaf> Getting things from stdin and calling functions are orthogonal.
17:01:56 <shachaf> It looks like you're trying to do the "calling a function" bit right now.
17:03:54 <vervein> shachaf: that's the code I'm trying to compile https://gist.github.com/4242858
17:04:27 <vervein> it's just a silly example, I want to learn how to write tools that I can later use in my pipelines
17:04:27 <mapf> is it possible to splices in ghci?
17:04:42 <mapf> to see splices, sorry
17:05:21 <shachaf> vervein: :t putStrLn
17:05:40 <vervein> oh yeah, I should use show :)
17:05:50 <vervein> shachaf: thx :)
17:05:58 <shachaf> @src print
17:05:58 <lambdabot> print x = putStrLn (show x)
17:06:36 <vervein> awesome!
17:07:14 <ick> if i want to start with a large amount of data and repeatedly work with smaller and smaller pieces of that data, should i be using something other than a list if i want time efficiency? if i only ever want to access the data sequentially will changing the data structure make any difference?
17:08:15 <ick> im not really sure how repeatedly filtering a list compares to deleting elements from a tree or something else
17:11:24 <Saizan> for sequential access a list is quite appropriate, the problem might be that it's not very compact
17:12:07 <Saizan> ick: what kind of data is this?
17:13:16 <ick> the data is list of logical relations
17:13:30 <ick> its a list of tuples (Bool, String, [Int])
17:14:18 <ick> so it doesnt really make sense ordering it
17:16:33 <ick> maybe the structure is fine and my problem is elsewhere
17:28:32 <Saizan> ick: what are you experiencing? large memory use?
17:30:11 <Saizan> [(Bool, String, [Int])] is quite wasteful in terms of space, you might want Text for String, UArray Int Int for [Int] and a record with strict field instead of the tuple
17:30:22 <Saizan> *strict fields
17:31:07 <Saizan> which you can also {-# UNBOX #-}
17:37:00 <tps_> what does this syntax mean in haskell "_:xs". I understand that if i had something like "x:xs" then x is the head of the list and xs the tail but I haven't seen this syntax before "_:xs". I am new to haskell.
17:37:26 <jmcarthur> tps_: _ is just a way to avoid naming something
17:37:26 <Clint> _ means you aren't going to use it
17:37:29 <sipa> _ is used in pattern matches to match anything you don't care about
17:38:01 <jmcarthur> tps_: it means "there's a thing here that i don't intend to use"
17:38:43 <tps_> thanks guys
17:58:36 <jmcarthur> old news to some, but i just discovered the composability of the traverse function, the same as how fmap and liftA* are composable. this is probably in some way a key piece of how lenses work
17:58:59 <jmcarthur> :t traverse
17:59:00 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
17:59:04 <jmcarthur> :t traverse . traverse
17:59:05 <lambdabot> (Applicative f, Traversable t1, Traversable t) => (a -> f b) -> t (t1 a) -> f (t (t1 b))
17:59:10 <jmcarthur> :t traverse . traverse . traverse
17:59:11 <lambdabot> (Applicative f, Traversable t2, Traversable t1, Traversable t) => (a -> f b) -> t (t1 (t2 a)) -> f (t (t1 (t2 b)))
18:00:14 <ion> jmcarthur: bing
18:00:16 <ion> o
18:00:29 <ion> :t both
18:00:30 <lambdabot> Applicative f => (a -> f b) -> (a, a) -> f (b, b)
18:00:32 <ion> :t both . both
18:00:33 <lambdabot> Applicative f => (a -> f b) -> ((a, a), (a, a)) -> f ((b, b), (b, b))
18:00:55 <ion> :t _1 . _2
18:00:56 <lambdabot> (Functor f, Field2 a b a1 b1, Field1 s t a b) => (a1 -> f b1) -> s -> f t
18:01:09 <ion> :t _1 . _2 `asAppliedTo` (undefined :: ((a,b),(c,d)))
18:01:10 <lambdabot>     Couldn't match expected type `a0 -> f0 b0'
18:01:10 <lambdabot>                 with actual type `((a1, b1), (c0, d0))'
18:01:10 <lambdabot>     In the second argument of `asAppliedTo', namely
18:01:26 <ion> sigh
18:02:07 <ion> :t _1 . _2 `asTypeIn` \l -> l undefined (undefined :: ((a,b),(c,d)))
18:02:08 <lambdabot> Functor f => (b1 -> f b) -> ((a, b1), (c, d)) -> f ((a, b), (c, d))
18:03:28 <mgsloan> jmcarthur: Yup, traverse is the prototypical Traversal
18:04:11 <mgsloan> Other than the "Traversable" constraint, it's exactly the same template as the "Traversal" type synonym
18:04:56 <elliott> (and using (f a)/(f b) for s/t
18:04:59 <elliott> )
18:05:41 <jmcarthur> elliott: ?
18:08:43 <elliott> re mgsloan
18:08:49 <elliott> traverse :: Traversal (f a) (f b) a b
18:09:01 <jmcarthur> ah
18:09:08 <mgsloan> (where f in this case is the Traversable)
18:09:12 <jmcarthur> right
18:23:24 <edwardk> jmcarthur: it very much is a key piece of how lenses work ;)
18:27:56 <shachaf> jmcarthur: Yes, that's pretty much the whole thing.
18:28:33 <shachaf> (Well, and what happens when you restrict it to Functor instead of Applicative.)
18:46:37 <slack1256> I can't find a syb tutorial
18:46:58 <slack1256> the only thing I've found is the paper from the 2000~
18:47:43 <slack1256> is it still relevant? should I learn to use from there or there is an easier path?
18:48:00 <startling> slack1256: syb?
18:48:29 <Clint> slack1256: what are you trying to accomplish?
18:48:41 <geekosaur> 'scrap your boilerplate', an old generics librart
18:48:48 <slack1256> ^ exactly
18:49:14 <geekosaur> slack1256, modern ghc has a built in generics implementation which is more capable and performant than syb
18:49:42 <slack1256> I have and xml tree of an rss feed (of torrents) and I want to match a regex on the titles of the feed to download the contents
18:49:49 <geekosaur> if you actualy need syb, well, it hasn't changed a whole lot since that paper
18:49:59 <shachaf> slack1256: The SYB papers and slides are good for figuring out how it works.
18:50:09 <shachaf> But there are various alternatives, depending on what you're doing.
18:50:14 <slack1256> geekosaur: but the Data.Data module tells me about the syb package
18:50:36 <slack1256> shachaf: currently I am using pattern matching which works with ONE site only
18:50:56 <geekosaur> hrm.  syb is not the answer to that
18:51:54 <slack1256> mmm. I tought that 'mkQ' would fit in my problem
18:52:08 <geekosaur> if it's regexes then it's all strings in well defined places
18:52:33 <geekosaur> syb is for when the types and the locations within complex ADTs change
18:53:07 <geekosaur> that is, if you have a type with a bunch of Int values scattered throughout it, you can use generics to get to any of those Ints regardless of where they are
18:53:34 <slack1256> geekosaur: oh, I expressed myself incorrectly
18:53:45 <geekosaur> it's conceivable that an XML ADT might require something similar, but I would suspect the XML library actually has better ways to deal with that issue
18:53:48 <slack1256> I match the titles with the regex (that works on every site)
18:54:13 <shachaf> > toListOf template ("hello",(1,"string"),[(4,"blah"),(5,"foo")],3.0) :: [String]
18:54:14 <lambdabot>   ["hello","string","blah","foo"]
18:54:44 <slack1256> but because they are rss feed of torrent, the put the torrent file sometimes as a 'media link' sometimes as normal link. sometimes even as 'magnet' in the feed
18:56:48 <geekosaur> you should be able to ask the xml library for a list of all links, or all meta links, or etc.
18:57:56 <slack1256> mmm. yeah you are right, I haven't studied the xml library correctly
18:58:23 <slack1256> anyways. to learn to use generics on modern ghc
18:58:34 <slack1256> the syb paper is still valid, right?
19:19:34 <spacebark> this is a shot in the dark, but does anybody know the URL for that website that is a personal website of a software engineer, but the page is written as if it were a haskell source file with variables such as "bio :: String"
19:19:42 <spacebark> I think the guy worked at last.fm
19:19:52 <gienah> slack1256: I wonder if a more generic tutorial on generics might be better, like: http://www.cs.uu.nl/research/techreps/UU-CS-2008-025.html
19:21:00 <slack1256> gienah: actually, that works, thanks
19:21:01 <cmccann> spacebark, you'd be surprised how many haskell programmers have websites with humorous use of type signatures
19:21:46 <slack1256> spacebark: maybe brent?
19:21:47 <slack1256> https://byorgey.wordpress.com/
19:29:08 <ion> @tell byorgey It would be great to have the <http://www.cis.upenn.edu/~cis194/> lectures as videos on the web.
19:29:08 <lambdabot> Consider it noted.
19:36:55 <byorgey> ion: yes, that would be great.  I kind of doubt I'll be able to manage it though.
19:36:55 <lambdabot> byorgey: You have 2 new messages. '/msg lambdabot @messages' to read them.
19:37:17 <byorgey> partly it depends on what classroom I get assigned.  Some of them have setups to be able to do video recordings
19:37:29 <byorgey> but no way am I going to set up a video camera on a tripod every week.
19:37:57 <shachaf> Also there's a misspelling. It should say Brent Byorgey.
19:38:16 <byorgey> shachaf: whoops!  I'll fix that right away.
19:42:05 <cmccann> shachaf, good thing you reminded him how to spell that
19:42:10 <cmccann> I'm sure he'd forget otherwise
19:42:26 <shachaf> cmccann: Yes, that's what I'm here for.
19:42:34 <cmccann> good work.
19:45:11 <shachaf> cmccann: By the way, your nick ought to be camccann
19:45:36 <cmccann> it probably should!
19:45:51 <cmccann> but I've been inconsistent about that for this long, so I might as well stick with it.
19:45:57 <cmccann> middle initials are overrated anyway.
19:55:10 <bgamari> byorgey, https://github.com/bgamari/tkyprof
19:55:53 <bgamari> works against ghc 7.6 and yesod 1.1
19:57:16 <byorgey> cool
20:29:25 <sorbo_> you guys
20:29:28 <sorbo_> I started learning haskell today
20:29:32 <sorbo_> and I am super excited.
20:29:34 <sorbo_> that is all.
20:30:59 <cmccann> sorbo_, as well you should be!! it is so much fun you have no idea (yet).
20:31:36 <sorbo_> cmccann: I believe it!
20:32:15 <gwern> > 6/8
20:32:16 <lambdabot>   0.75
20:32:36 <cmccann> gwern, did you seriously need to as lambdabot to figure that out? :P
20:33:12 <gwern> cmccann: simple arithmetic errors are the most embarassing to ever make, and insurance is worth buying
20:33:46 <cmccann> ok fair enough I guess
20:35:15 * elliott is terrible at basic arithmetic
20:36:10 <cmccann> so am I but 6/8 is within even my abilities :P
20:36:59 <sorbo_> > max 3 7 2 9 11 13 4
20:37:00 <lambdabot>   7
20:37:14 <shachaf> Clever!
20:37:22 <shachaf> Let's add that to the list of misleading things in lambdabot.
20:37:25 <ion> lambdabot being helpful to newcomers again.
20:37:30 <sorbo_> can max only take two arguments?
20:37:34 <shachaf> Yes.
20:37:40 <ion> @type maximum
20:37:41 <shachaf> Well, all Haskell functions take only one argument.
20:37:41 <lambdabot> Ord a => [a] -> a
20:38:02 <sorbo_> ahh ok
20:38:06 <sorbo_> thanks!
20:38:09 <ion> @type max
20:38:10 <lambdabot> Ord a => a -> a -> a
20:39:57 <sorbo_> > succ 11
20:39:58 <lambdabot>   12
20:40:01 <sorbo_> ha!
20:40:50 <otters> > succ ('c',12)
20:40:51 <lambdabot>   No instance for (GHC.Enum.Enum (GHC.Types.Char, t0))
20:40:52 <lambdabot>    arising from a use ...
20:40:58 <cmccann> sorbo_, experimenting in GHCi running locally might be safer. as shachaf implied, lambdabot has some... weird quirks
20:41:24 <sorbo_> cmccann, sure thing—just installed
20:41:57 <iscis> hey could anyone help with writing a simple split list function?
20:42:10 <iscis> i have a split at k element, but just need to split in two without breaking recursion
20:42:16 <iscis> here is what I have
20:42:17 <iscis> splitlist :: [a] -> Int -> ([a],[a])
20:42:17 <iscis> splitlist [] = ([],[])
20:42:17 <iscis> splitlist l@(x : xs) n | n > 0     = (x : ys, zs)
20:42:17 <iscis>                | otherwise = (l, [])
20:42:17 <iscis>     where (ys,zs) = split xs (n - 1)
20:45:11 <ion> @hoogle splitAt
20:45:12 <lambdabot> Prelude splitAt :: Int -> [a] -> ([a], [a])
20:45:12 <lambdabot> Data.List splitAt :: Int -> [a] -> ([a], [a])
20:45:12 <lambdabot> Data.ByteString splitAt :: Int -> ByteString -> (ByteString, ByteString)
20:45:12 <iscis> anyone?
20:45:18 <roconnor> can I get ghc on a raspberry pi?
20:45:46 <ion> roconnor: Debian’s GHC package worked on my Beagle Bone at least.
20:45:57 <roconnor> yay
20:50:59 <iscis> lamdabot i have to write this for a class so I can't use built in functions, how would I modify the aforementioned code?
20:51:28 <lambdabot> idk i'm just a bot
20:59:28 <NemesisD> does anyone have a favorite logging library in haskell?
20:59:45 <NemesisD> i'm looking at monad-logger but i have no idea how to use it
21:02:14 <Eduard_Munteanu> NemesisD: there are some examples in there: http://hackage.haskell.org/packages/archive/monad-logger/0.2.1/doc/html/Control-Monad-Logger.html
21:02:22 <Eduard_Munteanu> $(logDebug) "This is a debug log message"
21:04:55 <NemesisD> Eduard_Munteanu: im more confused about the configuration, such as which handle the log messages go to
21:06:08 <Eduard_Munteanu> NemesisD: I suspect that depends on the monad in question, e.g. stderr for IO, for other monads it might not even print a message at all
21:06:34 <NemesisD> odd that it isn't configurable
21:06:45 <Eduard_Munteanu> Such as [], Writer...
21:07:12 <Eduard_Munteanu> NemesisD: you could log using e.g. a writer monad and handle output yourself
21:07:28 * cmccann sighs. cabal-install can't install cabal-install because something changed and some auto-generated code doesn't compile.
21:08:48 <NemesisD> Eduard_Munteanu: i guess i'll keep looking. i think i'm looking for something less magical than monad-logger but something less work than doing it myself
21:09:23 <Eduard_Munteanu> NemesisD: use   WriterT [String] m a   and 'tell' things?
21:09:46 <Eduard_Munteanu> What sort of features are you looking for?
21:10:24 <cmccann> it's fun when the only thing on the web mentioning a build problem is someone in #haskell complaining about the same thing :T
21:10:42 <Eduard_Munteanu> cmccann: we're the center of the universe :P
21:10:54 <NemesisD> im still not very well versed in using transformers. basically just a file handle logger with log levels and a sensible default for formatting. my app supports a verbose flag. i was gonna pass the logger around as an argument to the places that need it
21:10:58 <NemesisD> that might be a bit inelegant
21:11:02 <cmccann> well since the thing being built is cabal-install it's not surprising :P
21:11:27 <ryanos> NemesisD: what's the equivalent of log4j in haskell ?
21:12:01 <NemesisD> ryanos: logging in java is evidently one of the few things i know less about than logging in haskell
21:12:03 <ryanos> (some kind of flexible/easy customizable logging)
21:12:11 <ryanos> k
21:12:21 <ryanos> just connected, thought u r doing that
21:12:34 <NemesisD> ryanos: oh no. looking for it.
21:12:55 <Eduard_Munteanu> WriterT takes care of "passing" the logger around.
21:12:57 <ryanos> yeah, something useful to have around
21:13:18 <Eduard_Munteanu> @unmtl WriterT [String] Maybe a
21:13:18 <lambdabot> Maybe (a, [String])
21:13:32 <ryanos> Eduard_Munteanu: so far i've only managed to "p_ss" the logger around :)
21:13:39 <Eduard_Munteanu> (e.g. if you have a computation in Maybe and want to add logging to it)
21:14:39 <Eduard_Munteanu> To log stuff you just do stuff like   tell ["This is a message"].
21:16:06 <Eduard_Munteanu> Actually you probably want to combine them the other way around, sorry, the above was misleading.
21:16:11 <NemesisD> hslogger allows you to register loggers by name and use them in the IO monad, that might be hacky enough to work
21:16:26 <Eduard_Munteanu> @unmtl MaybeT (Writer [String]) a
21:16:26 <lambdabot> (Maybe a, [String])
21:17:18 <ryanos> Eduard_Munteanu: NemesisD: thanks
21:17:24 <cmccann> @tell dmwit thanks a lot for not finding/mentioning a solution to http://hpaste.org/74839 to save me from having to fix my own problems >:[
21:17:24 <lambdabot> Consider it noted.
21:18:34 <ryanos> Eduard_Munteanu: the tell ["sdfd"] - does it support logging level, different sinks (places to log at ), etc
21:18:41 <ryanos> ?
21:18:50 <NemesisD> oh, looks like it isn't register by name, it has a global logger and you use a name to specify a section of your app, heirarchically separated by dots
21:19:32 <Eduard_Munteanu> ryanos: you could use a Writer [(LogLevel, Component, String)] or something like that
21:20:15 <ryanos> so i assume the Component can be another sink than the file system ? (db/socket/etc)
21:20:30 <Eduard_Munteanu> Oh, that's what you mean.
21:20:35 <jfischoff> is liftM2 (<) and other comparison operators defined anywhere?
21:20:44 <Eduard_Munteanu> ryanos: Writer merely gives you a list back in that case, you can do anything with it.
21:22:01 <ryanos> Eduard_Munteanu: thanks, will ck it out (multzumex ed,baiatul de la munte :) )
21:22:28 <brunonery> Hi, I'm playing with Network.Pcap and I wanted to have a function that generates a lazy list of "packets"
21:22:35 <Eduard_Munteanu> ryanos: oh, are you from around here? :D
21:23:04 <brunonery> I tried using next on a PcapHandle, but next only returns an IO action that when executed contains the next packet :P
21:23:11 <brunonery> (or so it seems)
21:23:21 <ryanos> Eduard_Munteanu: long long time ago.. :) (am incercat sa vorbesc cu tine off-l dar nu primesti legatura - suna-ma tu)
21:23:31 <brunonery> my attempt
21:23:32 <brunonery> source :: PcapHandle -> [IO (PktHdr, Ptr Word8)]
21:23:33 <brunonery> source h = next h : source h
21:23:58 <brunonery> problem is when I try to make it stop (by comparing the Ptr with nullPtr) -- I just can't get to have a
21:24:03 <Eduard_Munteanu> ryanos: hm, so I guess I know you?
21:24:11 <brunonery> source :: PcapHandle -> [(PktHdr, Ptr Word8)]
21:24:25 <ryanos> Eduard_Munteanu: i don't think we've met..
21:25:25 <Eduard_Munteanu> Then how would I know how to reach you?
21:25:40 <ryanos> Eduard_Munteanu: trying to convert some java stuff to haskell.. first iteration just trying to map things 1-1 (which may not be a good idea)
21:26:14 <ryanos> Eduard_Munteanu: there is something called a DCC chat :)
21:27:06 <Eduard_Munteanu> Well I suppose normal private messages (/query) should work.
21:28:18 <Eduard_Munteanu> Yeah, it's not really a good idea, it's best to learn the patterns Haskell's best at if you're going to write Haskell code.
21:28:42 <ryanos> agreed - haskell is much better than java from many perspectives
21:28:57 <ryanos> but.. java has a whole lot of legacy quickly available
21:29:10 <ryanos> (useful stuff sometimes too)
21:29:31 <Raynes> Like java.util.Date.
21:29:43 <ryanos> yeah, like that
21:29:52 <ryanos> like dat
21:30:52 <ryanos> but depends on what u want to do, for what i need haskell could work very well
21:37:53 <saiko-chriskun> is it even possible to map java -> haskell 1-1? lol
21:37:59 <saiko-chriskun> they're like polar opposites
21:38:46 <simpson> saiko-chriskun: Well, yes, of course you can.
21:38:51 <simpson> saiko-chriskun: It might not be *fun*.
21:39:03 <saiko-chriskun> :P
21:40:48 <saiko-chriskun> haskell doesn't really have an equivalent to java classes and such though, right?
21:41:58 <saiko-chriskun> it would have to be rewritten / expressed differently
21:42:44 <simpson> saiko-chriskun: Sure, but that's okay.
21:43:20 <saiko-chriskun> so.. it can't just be mapped 1-1 :P
21:46:51 <simpson> saiko-chriskun: What do you mean by "mapped?" What are the fundamental primitive operations we're working with?
21:47:04 <simpson> saiko-chriskun: How do you feel about Scala or Clojure or other JVM languages being "mapped" to Java?
21:48:11 <newtolambda> like a cross compiler?
21:49:53 <saiko-chriskun> I was just referring to ryanos's comment- "..trying to convert some java stuff to haskell.. first iteration just trying to map things 1-1 (which may not be a good idea)"
21:50:06 <simpson> Ah.
21:52:00 <popl> I wish *I* could pedal backwards.
21:54:50 <startling> popl: having a coaster break is nicer, ime
21:55:01 <startling> so much more reliable when it's wet out.
21:55:40 <popl> startling: I had one bicycle with a coaster brake. The bicycle was either stolen or my father got rid of it. I don't know which.
21:56:09 <startling> popl: sort of amounts to the same thing then?
21:56:35 <popl> Yes. I had no bicycle.
21:56:43 <popl> I haven't owned one since then.
21:57:01 <popl> That was almost 20 years ago.
21:57:51 * popl waves his cane
21:58:42 <startling> heh
22:29:19 <popl> awful quiet
22:30:05 <simpson> Sorry, writing code instead of gabbing.
22:30:21 <popl> snark
22:31:45 <DarkLord_> 2
22:33:36 <AfC> People have stopped using Haskell. Hadn't you heard?
22:34:38 <Adeon> oh dear, did they cancel haskell
22:36:13 <cmccann> haskell was canceled on Sep 1st 1982
22:54:37 <ryanos> saiko-chriskun: sorry was off for a bit. by "mapping" i meant "conceptual mapping" (1-1 concept level) but of course heavy dose of rewriting could be invlved
22:54:44 <slack1256> is there a date to receive to our new hackage2 based overlords?
22:55:24 <ryanos> i could throw that back at u/board and ask - what would be the best way to convert a large proj from java to haskell?
23:39:29 <zophy> what debian package do i install to use postgresql with haskell ?
23:40:53 <slack1256> zophy: you install postgresql normally and then you could install a binding with cabal
23:41:21 <slack1256> for example haskelldb-postgresql seems ok (I haven't used it nor have experience with haskelldb)
23:42:24 <zophy> there's just a lot of debian packages dealing with postgresql and haskell
23:42:54 <slack1256> oh. sorry then, I don't have any experience with debian
23:49:08 <popl> zophy: Have you tried asking in #debian?
23:49:55 <JSchwag> quick question. if i have a function like this: test = take 100 ['a'..]
23:50:09 <shachaf> That's not a function, it's a string. :-)
23:50:12 <elliott> that's not a function, by the way
23:50:15 <JSchwag> there are obviously only 26 letters to print out
23:50:25 <JSchwag> lol sry a string
23:50:27 <elliott> > ['a'..]
23:50:28 <JSchwag> neway
23:50:28 <lambdabot>   "abcdefghijklmnopqrstuvwxyz{|}~\DEL\128\129\130\131\132\133\134\135\136\137...
23:50:29 <shachaf> Well, there are more than 26 characters.
23:50:36 <JSchwag> the data that follows
23:50:51 <JSchwag> that isnt just garbage data
23:50:55 <ion> ä
23:50:57 <JSchwag> what is that coming from
23:51:03 <elliott> unicode
23:51:09 <shachaf> ftp://ftp.unicode.org/Public/UNIDATA/UnicodeData.txt
23:51:09 <JSchwag> so those are special characters
23:51:10 <elliott> > [minBound..] :: [Char]
23:51:11 <lambdabot>   "\NUL\SOH\STX\ETX\EOT\ENQ\ACK\a\b\t\n\v\f\r\SO\SI\DLE\DC1\DC2\DC3\DC4\NAK\S...
23:51:15 <elliott> they're not really special
23:51:35 <shachaf> They're no more special than 'a' - 'z'
23:52:02 <ion> A Chinese person would look at your strange “a…z” symbols in wonder and awe.
23:52:13 <popl> really?
23:52:28 <ion> Yes, this is an absolute fact, not an exaggeration whatsoever.
23:52:34 <shachaf> ion: Especially that '…' symbol.
23:52:42 <JSchwag> ok cool so there is a limit to how many unicode characters there are
23:52:50 <elliott> > maxBound :: Char
23:52:51 <lambdabot>   '\1114111'
23:52:51 <JSchwag> correct?
23:52:54 <shachaf> > length [minBound..]
23:52:56 <lambdabot>   Ambiguous type variable `a0' in the constraints:
23:52:56 <lambdabot>    (GHC.Enum.Bounded a0)
23:52:56 <lambdabot>  ...
23:53:00 <shachaf> > length [minBound :: Char ..]
23:53:01 <lambdabot>   1114112
23:53:10 <shachaf> Well, that's actually not quite right, because some of those are invalid.
23:53:15 <popl> JSchwag: Nobody knows. We haven't finished discovering Unicode yet.
23:53:16 <shachaf> > chr 0xd800 -- INVALID
23:53:17 <lambdabot>   '\55296'
23:53:42 <JSchwag> hmm
23:54:20 <JSchwag> this is something i really need to study
23:54:23 <JSchwag> lol
23:54:41 <ion> Yes, Unicode should be studied laughing out loud.
23:54:59 <JSchwag> what if i did test = take 100000000000 ['a'..]
23:55:09 <ion> @src take
23:55:10 <lambdabot> take n _      | n <= 0 =  []
23:55:10 <lambdabot> take _ []              =  []
23:55:10 <lambdabot> take n (x:xs)          =  x : take (n-1) xs
23:55:17 <ion> It would hit the “take _ []” case.
23:55:38 <ion> > take 100000000000 "hello"
23:55:39 <lambdabot>   "hello"
23:56:33 <JSchwag> so it would just keep counting
23:57:16 <ion> > let test = take 100000000000 ['a'..] in test
23:57:17 <lambdabot>   "abcdefghijklmnopqrstuvwxyz{|}~\DEL\128\129\130\131\132\133\134\135\136\137...
23:57:31 <elliott> it would stop counting where Unicode ends
23:57:53 <JSchwag> where does it end though
23:58:07 <JSchwag> it doesnt
23:58:11 <JSchwag> i thought
23:58:25 <ion> > maxBound :: Char
23:58:26 <lambdabot>   '\1114111'
23:58:32 <JSchwag> oh ok
23:58:59 <JSchwag> hm
23:59:04 <JSchwag> time to do some reading
23:59:05 <JSchwag> thx
23:59:15 <shachaf> > sam'n'MaxBound :: (Char,Char)
23:59:17 <lambdabot>   Not in scope: `sam'n'MaxBound'
23:59:17 <lambdabot>  Perhaps you meant `sam'n'maxBound' (line 4)
23:59:21 <shachaf> > sam'n'maxBound :: (Char,Char)
23:59:23 <lambdabot>   ('\NUL','\1114111')
23:59:57 <popl> o_O
