00:01:04 <omonomon> Hello, I'm a complete haskell noob and I've just been experimenting. I'm having some trouble designing something like a Field (the algebraic structure) type class from which I'm trying to create a Galois Field instance.
00:02:16 <snowylike> what exactly are you having a problem with?
00:03:03 <omonomon> Creating the Galois field data structure / instance
00:03:17 <omonomon> I don't think a type can take an integer parameter
00:03:57 <omonomon> Right now I've just been instantiating something like data GF = GF Int Int
00:04:09 <omonomon> and instantiating a field with type (Int -> GF)
00:04:36 <omonomon> but it doesn't feel right and so I'm looking for a more elegant way of doing it
00:05:29 <snowylike> now, just that i understand you correctly
00:05:35 <snowylike> a galois field means a finite field?
00:05:40 <omonomon> right
00:06:09 <omonomon> For simplicity, I'm just thinking of those with a prime number of elements now
00:06:22 <omonomon> as of now, I'm clueless how to structure the types, basically
00:06:34 <snowylike> well
00:07:09 <snowylike> all you really need for a field like Z/Zp should be one Integer and the operations on Z/Zp
00:07:31 <omonomon> Yeah
00:07:36 <omonomon> I made a typeclass for Field
00:07:45 <omonomon> (this is all just an exercise by the way)
00:08:06 <omonomon> which maps out the id, inverse, addition, subtraction, etc
00:08:32 <omonomon> but I want to create a Finite Field instance
00:08:43 <omonomon> and I want the number of elements in the field to be known
00:09:03 <omonomon> so I'm not sure what type I should put in the header
00:09:14 <omonomon> instance Field ([some type])
00:10:19 <snowylike> mh
00:11:04 <omonomon> basically my problem is being able to instantiate a finite field of arbitrary number of elements
00:11:39 <omonomon> but as far as I can figure out that would involve some sort of type constructor which takes an integer
00:11:39 <snowylike> which is, of course, impossible
00:11:44 <omonomon> yes
00:12:01 <omonomon> oh is the former thing impossible?
00:12:17 <snowylike> well not totally - i think
00:12:23 <omonomon> I can only instantiate fields of fixed size?
00:12:26 <omonomon> ah ok
00:12:30 <snowylike> but Z/Zp for p not prime ist not a field
00:12:34 <snowylike> that's what i wanted to say
00:13:09 <omonomon> Right
00:13:24 <omonomon> when I say arbitrary number of elements
00:13:30 <omonomon> I meant p^2 or p or whatever
00:13:33 <omonomon> for some prime p
00:13:34 <omonomon> p^k*
00:15:10 <snowylike> i don't know any better way than what you're already doing
00:15:30 <omonomon> Hmm okay
00:15:31 <omonomon> but the thing is
00:15:36 <omonomon> I do this really hacky thing
00:15:38 <omonomon> so
00:15:48 <omonomon> it's getting an input of type (Int -> GF)
00:15:50 <snowylike> could you paste the code somewhere, so i could take a look at it?
00:15:58 <omonomon> and I want to extract that Int
00:16:13 <omonomon> so I apply it to 0 and pattern match to get the size of the field...
00:16:25 <omonomon> sure
00:19:09 <omonomon> http://pastebin.com/K96S18X3
00:19:13 <mauke> The paste K96S18X3 has been copied to http://hpaste.org/78587
00:19:40 <omonomon> The instance part is incomplete and doesn't make any sense now
00:19:49 <omonomon> But it's just what I have
00:27:56 <omonomon> so technically I could just make the type of the instance GF but then every time I want to deal with an element of the field, I'd have to deal with the size of the field, which is super annoying
00:32:05 <snowylike> mh
00:34:48 <snowylike> see no way around that
00:34:53 <Cale> omonomon: The latest version of GHC (i.e. 7.6) has some support for type level numeric literals now
00:35:48 <Cale> omonomon: You can go to a bunch of trouble to implement type level numbers in previous versions using type families or functional dependencies with multiparameter type classes, but it's kinda tricky
00:36:08 <Cale> (at least, once you start wanting to do computations on them)
00:36:48 <omonomon> interesting
00:38:26 <startling> does anyone have a nice example for optparse-applicative up somewhere?
00:38:39 <omonomon> i do seem to have an outdated version of ghc
00:39:01 <startling> also, more specifically, I want to provide a default for when there are no flags and another default for when there are some flags.
00:39:12 <neutrino_> omonomon: 7.4.1 is the current.
00:39:20 <omonomon> oh, that's what i have
00:39:27 <omonomon> is 7.6 an experimental version or something?
00:39:27 <neutrino_> it's not outdated.
00:39:29 <neutrino_> yes.
00:39:42 <neutrino_> you can use peano arithmetic to define numbers in the type level.
00:39:45 <startling> omonomon: it's not really experimental, just not very compatible right now.
00:41:09 <neutrino_> you can use peano arithmetic to define numbers in the type level *in 7.4.1 as well* i should say
00:41:34 <startling> like, I want the default to be "all the switches are on", but if there are any switches I want them all shut off.
00:41:57 <startling> (except for those switches themselves, naturally)
00:42:19 <startling> e.g. mything view should dump *all* the data, but mything view -signature should only dump the signature.
00:53:37 <sacundim> am i right to suspect that it's impossible to implement a function of type Monad m => (a -> m b) -> m (a -> b)
00:54:14 <neutrino_> interesting question
00:54:34 <Jafet> @djinn (a -> m b) -> m (a -> b)
00:54:34 <lambdabot> -- f cannot be realized.
00:54:47 <neutrino_> @hoogle Monad m => (a -> m b) -> (m a -> m b)
00:54:47 <lambdabot> Prelude (=<<) :: Monad m => (a -> m b) -> m a -> m b
00:54:47 <lambdabot> Control.Monad (=<<) :: Monad m => (a -> m b) -> m a -> m b
00:54:47 <lambdabot> Prelude (>>=) :: Monad m => m a -> (a -> m b) -> m b
00:54:49 <sacundim> i really should learn to use the bots, huh
00:54:50 <neutrino_> oh
00:54:52 <Cale> djinn doesn't know about monads
00:54:57 <sacundim> i already hoogled...
00:55:23 <sacundim> but maybe i can use =<<, huh
00:55:29 <neutrino_> Cale: hi, got a minute?
00:55:41 <Cale> neutrino_: yeah, I responded to your PM, but you didn't see
00:57:37 <sacundim> uh, are we getting a bot flood
00:58:15 --- mode: ChanServ set +o Cale
00:58:19 --- mode: Cale set +b *!*@178.22.51.87
00:58:19 --- kick: Ensut123 was kicked by Cale (Ensut123)
00:58:41 --- kick: Ensut120 was kicked by Cale (Ensut120)
00:58:41 --- kick: Ensut276 was kicked by Cale (Ensut276)
00:58:41 --- kick: Ensut31 was kicked by Cale (Ensut31)
00:58:41 --- kick: Ensut317 was kicked by Cale (Ensut317)
00:58:41 --- kick: Ensut461 was kicked by Cale (Ensut461)
00:58:42 --- kick: Ensut528 was kicked by Cale (Ensut528)
00:58:44 --- kick: Ensut529 was kicked by Cale (Ensut529)
00:58:46 --- kick: Ensut544 was kicked by Cale (Ensut544)
00:58:48 --- kick: Ensut647 was kicked by Cale (Ensut647)
00:58:50 --- kick: Ensut894 was kicked by Cale (Ensut894)
00:58:52 --- kick: Ensut93 was kicked by Cale (Ensut93)
00:59:20 <c_wraith> I would suspect you can't write a function with type Monad m => (a -> m b) -> m (a -> b).  If you could, Monad and Applicative would be the same thing.
00:59:22 * arfy notes that ghc produces rather bulky executables. why?
00:59:42 <Cale> arfy: Statically links everything
01:00:04 <Cale> c_wraith: Monad subsumes Applicative
01:00:07 <arfy> cale: ah that would do it.
01:00:46 <neutrino_> arfy: ghc does a lot of optimization at a level lower than dynamically linked executables allow
01:00:59 <c_wraith> Cale: yes, but in the other direction..  If m (a -> b) was as expressive as a -> m b, there wouldn't be a difference between Monad and Applicative
01:01:27 <sacundim> huh, i see
01:02:10 <sacundim> or i think i see
01:02:22 <johnw> for any functor, is there an operation (f a -> f b) -> f (a -> b)?
01:02:50 <johnw> (Haskell functor, I mean)
01:03:28 <sacundim> i think [] is a counterexample
01:03:46 <simpson> :t \f -> Identity (\a -> case f (Identity a) of { Identity b -> b })
01:03:47 <lambdabot> (Identity a -> Identity t) -> Identity (a -> t)
01:04:08 <c_wraith> Identity isn't m.  The polymorphism is important :)
01:04:31 <sacundim> um, no, i'm a dumbass, [] isn't a counterexample
01:04:32 <simpson> Sorry, I took the question to mean "Does any Functor exist such that..." ?
01:04:56 <c_wraith> Ah, sure.  There are such functors!
01:05:33 <c_wraith> I bet you can do it with Reader, too.
01:05:59 <sacundim> i was just checking the function functor
01:06:07 <sacundim> i don't see how to do it there
01:06:07 <simpson> :t \f -> return (\a -> case f a of { b -> b }) -- You would need to be able to unwrap right here, and AFAIK you can't wriggle it in there.
01:06:09 <lambdabot> Monad m => (t1 -> t) -> m (t1 -> t)
01:06:58 <sacundim> @djinn ((t -> a) -> (t -> b)) -> a -> b
01:06:58 <lambdabot> -- f cannot be realized.
01:07:07 <c_wraith> you forgot a t
01:07:25 <c_wraith> @djinn ((t -> a) -> (t -> b)) -> t -> a -> b
01:07:25 <lambdabot> f a b c = a (\ _ -> c) b
01:07:26 <sacundim> right.
01:07:31 <sacundim> duh.
01:07:37 <c_wraith> so yeah, it works with Reader
01:08:53 <c_wraith> But that's because Reader isn't actually capable of anything as Monad that it's not capable of as an Applicative.
01:34:07 <chandra> hello
01:34:21 <neutrino_> hi chandra
01:34:22 <chandra> i have started with haskell
01:34:27 <neutrino_> welcome :)
01:34:32 <neutrino_> do you need any help?
01:34:37 <chandra> i defined a sample sum function
01:35:04 <chandra> what should i add to my code if i want to sum more than two integers
01:35:39 <chandra> like sum1 5 3 => 8 but sum1 5 4 3 =>error of instance
01:36:24 <chandra> @neutrino_ can u help
01:36:24 <lambdabot> Unknown command, try @list
01:36:35 <neutrino_> chandra: sure, i can help
01:36:38 <neutrino_> well, here's the deal
01:37:09 <chandra> ya thanks carry on..
01:37:11 <neutrino_> functions in haskell can only have a fixed number of parameters. this is described by saying that there are "no variadic functions"
01:37:46 <neutrino_> but if you want a function which takes in an arbitrary amount of values, all of the same type, you can just pass it a list
01:37:55 <neutrino_> which is a single parameter, but of variable size
01:38:04 <chandra> yeah the problem is i can write a recursive function with 1 argument..but how to write for more than one argument?
01:38:12 <chandra> ok
01:38:29 <neutrino_> how would you write the recursive function?
01:39:49 <chandra> i mean like for factorial its easy coz it takes only one argument
01:39:57 <neutrino_> sure
01:40:06 <neutrino_> but a list is only one argument as well
01:40:18 <chandra> for a function with more than one argument how to implement using list as u said
01:40:19 <neutrino_> look here:
01:40:28 <neutrino_> > let a = [1, 2, 3] in length a
01:40:30 <lambdabot>   3
01:40:47 <neutrino_> length only gets one parameter passed, but that parameter contains three values
01:40:58 <chandra> okayy
01:41:02 <neutrino_> do you know about pattern matching?
01:41:22 <neutrino_> you need to use it to implement a recursive function that sums a list
01:41:30 <chandra> ya
01:41:54 <neutrino_> do you know about the pattern (x:xs) which matches the first element of a non-empty list, and the rest of the list?
01:42:23 <neutrino_> for example:
01:42:37 <chandra> ya i know about it..but does it divide integers list also?
01:42:44 <neutrino_> > let foo (x:xs) = x in foo [4, 3, 2, 1]
01:42:46 <lambdabot>   4
01:42:52 <neutrino_> > let foo (x:xs) = x in foo "qwerty"
01:42:53 <lambdabot>   'q'
01:43:20 <chandra> ya i got that
01:43:21 <neutrino_> so you would basically recurse on xs
01:43:32 <neutrino_> think about it for a while and see if you can come up with it yourself
01:43:42 <chandra> for summing up wat should be the base case?
01:43:52 <neutrino_> you mean the terminating case?
01:43:54 <chandra> i tried sum[]=[]
01:43:58 <chandra> ya
01:44:02 <neutrino_> well, first of all
01:44:11 <edwardk> is the sum of an empty list an actual empty list or is it something else, like a number?
01:44:12 <neutrino_> you want your function to return an integer, right?
01:44:27 <chandra> yeah
01:44:34 <neutrino_> edwardk: he wants it to return numbers..
01:44:41 <edwardk> neutrino_: i know =)
01:44:46 <neutrino_> so even in the case that sum is passed an empty list, it should return a number
01:44:56 <neutrino_> it's a good idea to make that number 0
01:45:00 <neutrino_> so try sum [] = 0
01:45:05 <chandra> okay
01:45:46 <neutrino_> remember: multiple definitions of your functions always have the same number of arguments, types of arguments and types of return values
01:46:07 <neutrino_> now you have everything you need, try it yourself chandra
01:46:29 <chandra> thanks neutrino :)
01:46:36 <neutrino_> yw :)
01:46:46 <chandra> > sum1 [] = 0 > sum1 [x,xs] 	= x + xs i tried this
01:46:47 <lambdabot>   <hint>:1:9: parse error on input `='
01:48:07 <chandra> > sum1 [] = 0 > sum1 [x:xs] 	= x + xs
01:48:10 <lambdabot>   <hint>:1:9: parse error on input `='
01:48:11 <chandra> ?
01:48:16 <chandra> error
01:48:48 <neutrino_> chandra: you entered a tab
01:48:56 <neutrino_> lambdabot can't interpret it
01:49:13 <neutrino_> ok, well
01:49:26 <neutrino_> you say sum1 [x:xs] = x + xs
01:49:26 <neutrino_> however
01:49:31 <neutrino_> there are two problems
01:49:38 <neutrino_> first of all, your pattern match syntax is off
01:49:41 <neutrino_> it's (x:xs)
01:50:05 <neutrino_> second of all, you must remember x is a number, xs is a list of numbers. you cannot add a number to a list, they're of different type.
01:50:06 <chandra> oops
01:50:13 <neutrino_> what you need to do is you should recurse.
01:50:29 <neutrino_> you need something that gives you the sum of xs, so that you can add it to x.
01:50:48 <chandra> ya i ll add the head of xs to x
01:50:48 <chandra> ?
01:51:30 <neutrino_> well
01:51:34 <neutrino_> you can do that
01:51:38 <neutrino_> but it's not going to give you a sum..
01:51:44 <neutrino_> but it would be correct
01:52:02 <neutrino_> > let sumBroken (x:xs) = x + (head xs) in sumBroken [1, 2, 3, 4]
01:52:03 <lambdabot>   3
01:52:19 <neutrino_> it typechecks, which means the code is "correct", in the sense that it can compile
01:52:24 <chandra> okay
01:52:26 <neutrino_> but it's not what you want
01:52:34 <neutrino_> what you want is to add x to the *sum* of xs
01:52:44 <neutrino_> at this point you need to recurse
01:52:53 <neutrino_> that is, call the function you are currently defining.
01:53:15 <chandra> recursion with two variables is where i m getting struck
01:53:32 <neutrino_> there are no two variables
01:53:36 <neutrino_> you only pass one variable
01:53:42 <neutrino_> like this: sum1 xs
01:53:59 <chandra> i already tried it
01:54:06 <neutrino_> what did your code look like?
01:54:12 <chandra>  Possible fix: add an instance declaration for (Num [t -> t1 -> t2]
01:54:17 <chandra> it always says this
01:54:21 <neutrino_> that's the error, show me the code
01:54:34 <chandra> > sum1 [] = 0 > sum1 (x:xs)  	= x + sum1 xs	
01:54:35 <lambdabot>   <hint>:1:9: parse error on input `='
01:54:39 <neutrino_> yeah
01:54:42 <neutrino_> you forgot a paren
01:54:43 <neutrino_> :)
01:55:31 <neutrino_> > let sum1 [] = 0; sum1 (x:xs) = x + (sum1 xs) in sum1 [1, 2, 3, 4]
01:55:33 <lambdabot>   10
01:55:38 <neutrino_> it works :)
01:55:55 <chandra> oops
01:56:12 <chandra> i thought it would catch the polymorphic sentence there
01:56:27 <startling> so my program fails to typecheck under runhaskell, but succeeds with ghci. o.o
01:56:29 <neutrino_> if you get errors about types, look whether you forgot to add parentheses
01:56:36 <neutrino_> startling: paste it
01:56:46 <startling> neutrino_, it's a lot of code, sec.
01:56:56 <neutrino_> you might have two different haskell instances
01:56:57 <chandra> my code is working
01:57:01 <startling> neutrino_: oh, hm
01:57:16 <neutrino_> consider building a cabal project and using that to check out your code
01:57:34 <neutrino_> set up a test harness with test-framework and HUnit and you're golden
01:57:40 <neutrino_> it's really easy to do once you've lifted off
01:57:51 <chandra> the thing is why cant i write my input list as 1 2 34 instead of [1, 2, 3, 4]
01:57:53 <startling> neutrino_, how would a test framework help with compile errors
01:58:06 <neutrino_> chandra: because it needs to be a list, and not separate parameters.
01:58:16 <chandra> ohh i havent been to cabal packages till now..thanks for the advice
01:58:21 <neutrino_> startling: it wouldn't. it's just a different workflow.
01:58:33 <startling> neutrino_, oh, you're not talking to me.
01:58:43 <neutrino_> startling: i was talking to you.
01:58:58 <neutrino_> runhaskell and ghci are signs of bad dev practices.
01:59:03 <startling> lol
01:59:08 <chandra> i m using ghci
01:59:18 <neutrino_> chandra: for learning and hacking around that's fine
01:59:26 <neutrino_> it's not good to write long programs "in" ghci..
01:59:33 <startling> neutrino_: no kidding.
01:59:36 <chandra> ya ya coz its just interactive
01:59:43 <chandra> i get it :)
01:59:48 <neutrino_> :)
02:00:06 <neutrino_> i have ghci open all the time when i'm writing code, for example to figure out how to use a specific library function
02:00:09 <neutrino_> but that's it
02:00:22 <neutrino_> i don't actually try to run my code under ghci, it's futile
02:00:31 <startling> neutrino_, you haven't made friends with haskell-mode, I take it.
02:00:40 <neutrino_> i don't use emacs
02:01:16 <neutrino_> as far as operating systems go i prefer GNU/Linux over emacs
02:01:23 <startling> har har har
02:02:05 <neutrino_> :)
02:02:30 <neutrino_> running the test suite is just ;!!<Ctrl-M> for me
02:02:40 <neutrino_> (because Enter is too far)
02:02:44 <chandra> foe beginners i think ghci serves the purpose right..but i ll start building my project on cabal
02:02:57 <chandra> lol
02:03:02 <neutrino_> chandra: cabal is fairly involved but it's good to get to know it.
02:03:05 <startling> chandra, ghci is really nice, don't listen to him.
02:03:08 <neutrino_> chandra: it might be more than you need right now.
02:03:17 <startling> chandra: I virtually always have a ghci window open when I'm working on some code.
02:03:23 <neutrino_> startling: i did say ghci was good for him
02:03:32 <startling> okay.
02:03:35 <Ralith> there's no need to pay too much attention to neutrino_ here; cabal isn't at all necessary for simple projects you don't intend to redistribute, unless your local library situation is a mess.
02:03:35 <chandra> guys cool.. :)
02:03:55 <chandra> okay ralith
02:04:08 <neutrino_> Ralith: why would you say that? i'm talking about startling's situation, who has a problem with his code not compiling
02:04:51 <neutrino_> Ralith: he's comparing whether it runs under ghci with whether it runs under runhaskell. i'd say the issue is definitely on the side of the tools in use.
02:05:06 <startling> probably my ghci is importing something surprising.
02:05:12 <neutrino_> Ralith: in chandra's situation, he's just learning haskell, interactive sessions in ghci are definitely a good idea
02:06:42 <startling> neutrino_, anyway, I was just trying to use runhaskell to test out my command-line arguments, and it *is* really weird to get a type error under runhaskell and not ghci.
02:06:58 <startling> turns out I'm getting this while cabal build-ing, too.
02:07:10 <neutrino_> runhaskell has problems compiling some things that require linking afaik
02:08:04 <mysticc> Is there any TH library to provide helper functions to perform code transformation. ?
02:08:32 <startling> neutrino_: That wouldn't cause a type error afaict.
02:08:35 <neutrino_> mysticc: do you want to refactor haskell code?
02:08:43 <neutrino_> startling: just throwing that out there..
02:08:55 <neutrino_> startling: what is your error, and what is your code?
02:09:03 <mysticc> neutrino_: Perform some optimizations like recursion unrolling etc///
02:09:29 <neutrino_> mysticc: maybe have a look at HaRe and the lambdabot plugins for djinn, pl, unpl, do, and undo
02:09:45 <mysticc> neutrino_: I found that I will have to write lots of helper functions like substituting a variable with a literal etc
02:09:54 <neutrino_> mhm
02:10:12 <neutrino_> that's as much as i can help though, sorry :)
02:10:55 <neutrino_> i gotta go to the gym. hope someone can help you startling
02:11:14 <neutrino_> cya
02:13:24 <mysticc> startling: ghci infers some of types of its own so that might be the problem
02:15:18 <startling> oh ugh it was MonomorphismRestriction thing?
02:15:28 <startling> that's so weird.
02:16:04 <startling> (I was getting an error where I was getting a Word8 instead of a Word16 from fromIntegral)
02:16:27 <johnw> @tell aristid Check these free textbooks out: http://www.math.vcu.edu/2011publishing.html
02:16:27 <lambdabot> Consider it noted.
02:44:49 <DavidT> Does anyone know what syntax to write (and/or what extensions to enable) to make a kinded TyVarBind (i.e. KindedVar) in haskell-src-exts?
02:45:35 <DavidT> I can make unkinded ones e.g. 'forall a. T a'
02:46:00 <DavidT> but things like forall a :: *. T a don't seem to work
02:53:43 <DavidT> ah, gotit, it works in a DeclHead
02:53:57 <DavidT> class A (b :: * -> *) where
03:07:40 <sw2wolf> Does anybody here run `cabal install xmonad-extra1 successfully ?
03:12:53 <bitonic> sw2wolf: `xmonad-extra1' doesn’t seem to be in hackage.  can you post your error?
03:44:12 <zxq9> I'm working on a format/highlight extension for a print utility. Are there any other common extensions for Haskell source files than .hs?
03:44:47 <ramses_> zxq9: .lhs for literate haskell
03:44:59 <zxq9> In particular what extensions indicate files that might have the -- denoted comments?
03:45:40 <zxq9> ramses_: Is that a sysnonym for .lit sometimes?
03:46:57 <ramses_> don't think so, I haven't encountered .lit in the past
03:48:32 <zxq9> OK. But generally I should be safe checking for .lhs and .hs extensions?
03:48:45 <ramses_> that are the ones I'm aware of
03:50:11 <zxq9> ramses_: Thanks. I had forgotten about .lhs. I still feel like I'm in the larval Haskell learner phase and haven't messed with LP features... :/
03:53:59 <ramses_> I don't actually know how much they're used though, I only experimented with lhs a bit in the past to know what it's like
03:55:28 <Maxdamantus> Literate programming seems odd to me.
03:55:49 <Maxdamantus> Its use suggests the language you're writing in isn't expressive enough.
03:56:23 <Maxdamantus> Maybe it should be used for assembly programming or something.
03:56:40 <zxq9> I don't know if that's the point -- I think its a compelling idea considering the density problem inherent in reading terse code.
03:57:24 <zxq9> But not all code is terse, and most people are probably better at reading/grokking in a single pass than I am, so maybe its my relative n00b status that makes it seem like a good idea.
03:58:43 * hackagebot hlint 1.8.37 - Source code suggestions  http://hackage.haskell.org/package/hlint-1.8.37 (NeilMitchell)
03:59:45 <ramses_> I feel like the code can get lost in the documentation, making it hard to see what the program does
04:00:28 <ramses_> but it's pretty nice for making a latex report which contains code snippets to check if all the code combined compiles properly
04:01:00 <fmap> zxq9: there are also .hsc and .chs files for hsc2hs and c2hs preprocessors respectively.
04:01:19 <zxq9> There's an intersting thought. Perhaps its all about moderating the ratio between the two. otoh I'm not a fan of lots of comments to begin with.
04:01:54 <zxq9> fmap: Thanks! Do they take -- style comments as well?
04:03:16 <fmap> zxq9: yep
04:08:42 <merijn> Maxdamantus: Heh, what does programming language expressiveness have to do with literte programming?
04:10:17 <Maxdamantus> merijn: you should be able to read something written in the programming language and understand how it does what it does.
04:10:40 <merijn> Maxdamantus: You're overlooking a huge use case for literate programming
04:11:03 <ramses_> I think readability and expressability of a language are not necessarily the same thing
04:11:06 <merijn> Maxdamantus: Which is when the text is not explaining what the code is doing but the algorithm
04:11:24 <Maxdamantus> merijn: yes, the code should express that.
04:11:32 <Peaker> I've got a little monad stack involving ReaderT and StateT. When I try to add WriterT, it becomes 50% slower :(  When I use RWST instead, it becomes 30% slower :(
04:11:34 <merijn> Maxdamantus: i.e. I write a new garbage collection algorithm, even if you understand the code how do you know it's correct?
04:11:52 <Peaker> I guess I'm going to stick my stuff in my state
04:12:03 <merijn> Maxdamantus: It can't
04:12:40 <merijn> Maxdamantus: Code cannot explain or proof massive concurrent interaction on its own, not any human readable PL anyway
04:13:05 <merijn> What if my system is more than one language or a collection of programs/processes working together
04:13:48 <Maxdamantus> merijn: maybe literate programming isn't what I think it is .. I'd've imagined it'd be particularly irrelevant there.
04:14:37 <merijn> Maxdamantus: literate programming is only what you make of it. The most common case I see is to have paper + code implementing the papers ideas interspersed so you end up with a runnable paper
04:14:56 <zxq9> Maxdamantus: Interesting contraction.
04:15:01 <Maxdamantus> How does that work with a massive concurrent interaction across multiple languages?
04:15:19 <Maxdamantus> or rather, how is it particularly applicable there?
04:15:56 <zxq9> merijn: The large system case is where I'm thinking of LP making sense. We got a rather large system that spans 5 languages, several end-user apps and a fairly complex datastore. Documenting interfaces is a big deal.
04:16:33 <merijn> Maxdamantus: In that scenario it becomes important which external invariants your code is assuming, as external invariants may influence your design
04:17:05 <merijn> Are remote operations idempotent? What sort of consistency are you relying on? etc
04:18:17 <Maxdamantus> I'd've thought literate programming would've emphasised particularly explaining how things work, rather than stating assumptions.
04:18:47 <Maxdamantus> That's basically just documentation.
04:19:07 <mysticc> Does anybody know a current working version of fraskell?
04:20:33 <merijn> Maxdamantus: Well, yes. No one needs to explain what the code is doing, that's what the code is for. What you need to explain is the why things are the way they are
04:20:36 <mysticc> I need some functions defined here http://www.cs.ox.ac.uk/ian.lynagh/Fraskell/Template-Haskell-Utils.ps but I think this one is very old.
04:21:04 <mysticc> Some knows these functions like simplify etc for template haskell defined in some other library?
04:37:29 <daknok> hi
04:37:57 <mekeor> hi
04:39:38 <ion> hi
04:40:56 <luite> hi
04:42:07 <hiptobecubic> hi
04:45:32 <quchen> Hello
04:47:11 <ion> COMBO BREAKER
05:00:08 <tomboy64> ok
05:01:17 <tomboy64> is my interpretation right that an Int is guaranteed to be >=30bits, e.g. +/- 536'000'000?
05:03:01 <ramses_> "A fixed-precision integer type with at least the range [-2^29 .. 2^29-1]."
05:03:48 <ramses_> > [-2**29, 2**29 - 1]
05:03:49 <lambdabot>   [-5.36870912e8,5.36870911e8]
05:03:49 <tomboy64> ^^ ok
05:04:35 <tomboy64> ok. just wanted to make sure i hacked the right digits into my calculator
05:04:41 <ramses_> you can use minBound and maxBound to find the exact limits for your platform
05:04:46 <ramses_> > minBound :: Int
05:04:48 <lambdabot>   -9223372036854775808
05:05:28 <ramses_> lambdabot appears to be running on a 64bit machine :)
05:05:44 <bitonic> ramses_: not necessarely
05:06:32 <ramses_> bitonic: elaborate please?
05:13:20 <bitonic> ramses_: I’m just saying that you shouldn’t infer anything about the machine given the size of Int
05:13:36 <bitonic> since the std does not dictate “Int is a word” or similar
05:16:22 <bitonic> it’s not even outlandish to imagine non-word Ints - if for example you unbox them
05:16:23 <ramses_> ok, sure, but I guess most implementations will actually just take Int to be a word. But agreed, it's no scientific proof
05:16:45 <bitonic> which is most likely why the minimum width is 29 bits
05:16:49 <bitonic> to allow for tagging
05:17:09 <bitonic> but yeah
05:23:44 * hackagebot fluent-logger 0.1.0.0 - A structured logger for Fluentd (Haskell)  http://hackage.haskell.org/package/fluent-logger-0.1.0.0 (NoriyukiOhkawa)
05:23:46 * hackagebot fluent-logger-conduit 0.1.0.0 - Conduit interface for fluent-logger  http://hackage.haskell.org/package/fluent-logger-conduit-0.1.0.0 (NoriyukiOhkawa)
05:23:55 <DMcGill> I'm trying to install HSSFML following these instructions: https://github.com/jeannekamikaze/SFML/wiki/Installation-on-Windows and have installed the libraries fine but when calling cabal install I get this error: http://hpaste.org/78559
06:19:25 <mm_freak> edwardk: do you have a tutorial for 'bound'?
06:19:40 <mm_freak> i'll need it soon
06:44:26 <latermuse> The more I write haskell programs, the better I seem to get at writing haskell programs. Funny how that works.
06:47:21 <osfameron> that's not a conclusive proof.  You should now try writing fewer haskell programs and see if youget worse at it
06:50:33 <cocon> Hi! What does lazy I/O mean for output? In what sense is putStrLn lazy?
06:51:12 <latermuse> cocon: Lazy IO is stored as a sequence of commands that dont get excecuted unless absolutely necessary
06:52:14 <cocon> So what does this mean for putStrLn? Is there any chance that its argument is not forced after the action is sequenced?
06:52:19 <latermuse> osfameron: We should also find a second person to be a control group and not learn any kind of programming at all. Then compare their haskell skill level before and after the experiment.
06:52:33 <osfameron> latermuse: good plan
06:52:39 <osfameron> science ftw
06:53:12 <cocon> Shouldn't it really be called (lazy I)/O?
06:54:45 <latermuse> cocon: the output can be lazy. You can also force the input
06:55:07 <latermuse> so it cant necessarily be called (lazy I)/O
06:55:25 <cocon> Hmmm, so what would be an example of lazy output?
06:56:21 <sipa> :t unsafeInterleave
06:56:22 <lambdabot> Not in scope: `unsafeInterleave'
06:56:34 <sipa> :t unsafeInterleaveIO
06:56:35 <lambdabot> Not in scope: `unsafeInterleaveIO'
06:56:41 <DMcGill> for example, you can "print [1..]"
06:56:57 <DMcGill> and it'll just start writing numbers
06:57:41 <cocon> I see -- so the output part doesn't seem to require any magic (i.e. unsafePerformIO).
06:57:41 <shachaf> That's not lazy I/O
06:57:45 <cocon> ah!
06:57:59 <shachaf> That's just regular strict I/O consuming a lazy list.
06:58:25 <latermuse> shachaf: you mean the print [1..]?
06:58:26 <shachaf> Lazy output would be some x such that evaluating x prints something.
06:58:32 <shachaf> Yes.
06:58:48 <cocon> shachaf: is that possible?
06:58:52 <latermuse> cool way to put it into perspective. string I/O consuming a lazy list
06:59:01 <shachaf> cocon: Yes.
06:59:13 <cocon> Do you have an exmaple? :)
06:59:16 <shachaf> No.
06:59:29 <shachaf> When you are old and wise, you'll be able to come up with an example for yourself.
06:59:41 <shachaf> Until then, don't do lazy I/O. :-)
06:59:52 <shachaf> OK, Debug.Trace is one example.
07:00:35 <cocon> So the functions in Prelude just do (lazy I)/O then?
07:00:40 <shachaf> Hmm, darcsden.com is down.
07:01:24 <shachaf> I don't know what (lazy I)/O is.
07:01:29 <cocon> It seems that you can't write a program with Prelude functions only that prints something when something is evaluated.
07:01:30 <shachaf> But anyway it doesn't matter.
07:01:40 <sipa> you could do lazy output using something like unsafeInterleaveIO (putStrLn "blah" >> return 1)
07:02:03 <sipa> where the blah would only be executed when you try to match on the output
07:02:09 <shachaf> Yay.
07:02:16 <sipa> which kinda seems points
07:02:20 <sipa> *pointless
07:02:35 <latermuse> I have a program that does this. It is lazy output: mapM_ (return) x
07:02:39 <latermuse> er wait
07:02:48 <latermuse> mapM_ (buildPage . return) x
07:02:56 <shachaf> That's not lazy I/O
07:03:00 <latermuse> no?
07:03:04 <shachaf> No.
07:03:18 <latermuse> this returns x, and gets the data out of it, then uses buildPage to output it
07:03:26 <shachaf> What?
07:04:02 <mm_freak> edwardk: nevermind, found
07:04:28 <DMcGill> latermuse: I'd stop worrying about "lazy IO" until you've had a little more practice with the language and with monads :)
07:04:57 <sipa> the only real example of lazy I/O (and indeed, only input) is getContents
07:05:01 <sipa> afaik
07:05:02 <cocon> So lazy input is when evaluation can trigger execution? Seems like that is the case for getLine, but not for putStrLn.
07:05:29 <latermuse> DMcGill: Im not worried about it. I embrace the language, and found that mapM_ ... code that I wrote earlier to be insanely beautiful after it compiled correctly.
07:05:33 <cocon> s/lazy input/lazy IO/
07:05:38 <shachaf> cocon: It's not the case for either getLine or putStrLn
07:05:47 <sipa> cocon: evaluation causing execution happens all the time
07:05:54 <shachaf> "evaluation can trigger execution" is more or less the point of unsafeInterleaveIO
07:05:57 <shachaf> sipa: It does?
07:06:34 <sipa> that's just lazyness, no?
07:07:00 <shachaf> No.
07:07:10 <shachaf> Execution here means IO.
07:07:11 <sipa> well, i guess it depends on what you call execution
07:07:18 <sipa> right, in that case: true
07:07:23 <shachaf> Execution can mean other things in other contexts.
07:07:24 <cocon> shachaf: indeed. I should have said getContents instead of getLine.
07:07:36 <shachaf> But I don't think any of them can be caused by evaluation.
07:07:55 <shachaf> cocon: Yes, getContents works that way.
07:09:17 <Jafet> @quote executes
07:09:17 <lambdabot> Jafet says: In Soviet Russia, State executes you
07:09:40 <cocon> I guess the symmetric equivalent would be if Haskell started to execute *output* actions only if the output buffer of the process becomes empty.
07:11:03 <shachaf> I'm not sure how that's equivalent...
07:11:06 <cocon> So 'mapM print ([1..1000] ++ [undefined]' would only die once the process's output is consumed by whatever is downstream.
07:11:32 <cocon> shachaf: I'm thinking about it in the context of UNIX pipes.
07:11:39 <shachaf> I don't think you need lazy I/O for that.
07:11:45 <shachaf> print can just block
07:11:48 <Jafet> It's equivalent in the same way that COME FROM is the symmetric equivalent of GO TO
07:12:03 <geekosaur> that can happen if you output enough data and the pipe blocks, yeh
07:12:11 <cocon> shachaf: yes, that's the point. print blocks the entire process!
07:12:25 <shachaf> No, it blocks the current thread.
07:12:30 <shachaf> But this has nothing to do with laziness.
07:13:06 <cocon> well, instead we could just stop the output and go on with something else.
07:13:22 <shachaf> Something else like what?
07:13:37 <mysticc> Language.Haskell.TH has all the things to build AST but I am finding it difficult to find helpers which operates on it. For example find free variables in a lambda expression etc ?
07:13:42 <cocon> whatever the next I/O action is
07:13:47 <shachaf> No we can't.
07:13:53 <shachaf> What you wrote is equivalent to do { print 1; print 2; ...; print 1000; print undefined }
07:14:11 <cocon> yep.
07:14:20 <shachaf> This is just regular IO.
07:15:29 <rwbarton> but you *could* if print didn't block. imagine print -> forkIO . print
07:15:31 <cocon> Of course -- my point is that the semantics could be changed to make it lazy, so thet it would be truly symetric between input and output.
07:15:44 <cocon> rwbarton: exactly
07:16:01 <rwbarton> but with better ordering guarantees, ideally
07:16:13 <cocon> rwbarton: yes!
07:16:42 <Jafet> Then you wind up with http://www.dangermouse.net/esoteric/whenever.html
07:18:34 <cocon> The crucial bit is that the argument to 'print' isn't evaluated until the output stream is ready to be written to.
07:18:49 <cocon> (which is not the case if the output buffer is full)
07:18:52 <rwbarton> basically a way to work around pipe buffer limitations
07:19:15 <cocon> well, at least to import that problem into Haskell ;)
07:20:18 <rwbarton> a better way in Haskell to do it would be to spawn a thread for the purpose of printing to stdout
07:20:43 <rwbarton> and send it stuff asynchronously through a Chan
07:23:52 <cocon> A function is called strict if f _|_ == _|_. Under this definition is print is non-strict. Is there a formal way of saying that 'print _|_' blows up upon execution?
07:25:54 <hpc> :t print
07:25:55 <lambdabot> Show a => a -> IO ()
07:26:39 <cocon> > print undefined `seq` ()
07:26:40 <hpc> cocon: so print has a class constraint, which makes it not the same function for all types
07:26:41 <lambdabot>   ()
07:27:12 <cocon> hpc: how does that relate to strictness?
07:27:30 <hpc> so we could theoretically say, on execution (distinct from evaluation)
07:27:46 <hpc> the "IO strictness" of print is equal to the strictness of show for that type
07:28:03 <shachaf> This isn't really related to cocon's question at all.
07:28:15 <shachaf> The same question works with s/print/putStr/
07:28:21 <cocon> exactly
07:28:23 <hpc> "blows up upon execution" -- execution
07:28:34 <shachaf> I don't think there's a "formal way of saying" that.
07:28:42 <cocon> I guess I'm looking for something like 'runIO (putStr _|_) == _|_'
07:28:44 <shachaf> There's rarely a formal way of saying much of anything about IO. :-)
07:28:45 <hpc> for evaluation, just take the typical approach of "return undefined" being not equal to "undefined"
07:28:54 <hpc> also that
07:29:07 <cocon> for other monads that makes sense, though
07:29:20 <shachaf> hpc: Sometimes return undefined is the same as undefined
07:29:20 <hpc> cocon: you can construct an IO action that when /executed/, crashes
07:29:27 <shachaf> cocon: Not for most of them.
07:29:29 <hpc> but when evaluated, is a defined action
07:29:35 <hpc> (namely, the action that crashes your program)
07:29:43 <shachaf> hpc: Yes, I think this is cocon's point.
07:30:03 <hpc> which goes back to my "IO strictness" coining above
07:31:22 <cocon> > (put undefined :: State Int ()) `seq` ()
07:31:23 <lambdabot>   ()
07:31:33 <cocon> runState (put undefined :: State Int ()) 0
07:31:37 <shachaf> OK, but no one calls it "IO strictness", and that's a somewhat vague word.
07:31:58 <cocon> > runState (put undefined :: State Int ()) 0
07:32:00 <lambdabot>   ((),*Exception: Prelude.undefined
07:32:15 <cocon> seems to work for the State monad
07:32:31 <cocon> (although we'll have to universally quantify over the initial state, i.e. the 0 here)
07:32:31 <shachaf> OK, now how about State Void ()?
07:33:05 <cocon> Void being the uninhabited type? What about it?
07:33:12 <Underbyte> hello everyone
07:33:35 <shachaf> cocon: Well, what "initial state" do you pass?
07:33:47 <Underbyte> i know its the wrong channel, but if anyone here knows Prolog, I could _really_ use some somewhat urgant help, would greatly appreciate it
07:33:57 <shachaf> Underbyte: Have you tried #prolog?
07:34:12 <Underbyte> yes, all idle.
07:34:41 <cocon> shachaf: That's what I mean we'll have to universally quantify, i.e. the statement of "State-strictness" becomes forall s, runState (f _|_) s == _|_
07:34:56 <cocon> ...which means that we can't just type it into ghci and test it
07:35:58 <shachaf> I think you mean execState, anyway.
07:36:24 <cocon> yes, that makes more sense.
07:37:00 <shachaf> So how about []?
07:40:15 <cocon> somehow "[]-strictness" should discern (\_ -> [1]) from (\x -> [x])
07:40:18 <hpc> Underbyte: join #haskell-blah and ask there, to keep a modicum of on-topicality in here ;)
07:41:09 <cocon> so maybe []-strictness is just the same as normal strictness -- there is nothing like 'runList'
07:42:23 <cocon> oops, (\x -> [x]) is not strict (sorry for too much thinking aloud)
07:42:32 <mysticc> what does this pattern mean "data Pat = ViewP Exp Pat" in the definition of Pat in Template haskell ?
07:42:55 <shachaf> mysticc: It means the same thing as any other data definition.
07:42:58 <shachaf> What's the trouble?
07:43:27 <Underbyte> hpc: done. If anyone comes across this, http://pastebin.com/hrk1KBjA if you want to have a looksee
07:43:30 <mauke> The paste hrk1KBjA has been copied to http://hpaste.org/78590
07:44:16 <mysticc> shachaf: I meant what is the semantics of ViewP patterns in real haskell?
07:44:37 <shachaf> mysticc: Oh. It's just an expresion and a pattern on the result of that expression.
07:44:46 <shachaf> @google view pattern
07:44:48 <lambdabot> http://hackage.haskell.org/trac/ghc/wiki/ViewPatterns
07:44:48 <lambdabot> Title: ViewPatterns – GHC
07:46:17 <mysticc> shachaf: Oh.. I saw this first time today. Thanks.
07:49:56 <mysticc> shachaf: http://www.cs.ox.ac.uk/people/ian.lynagh/Fraskell/Template-Haskell-Utils.ps Do you know any library which provides functionality similar to this.
07:50:09 <mysticc> This one is very old so does not work
07:53:12 <shachaf> I don't know.
07:53:14 <shachaf> Maybe Igloo knows.
07:53:43 <Igloo> I'm afraid I do not
07:53:56 <Poapfel> It's not really haskell realted, but does anybody know the name of this keyboard? http://www.haskell.org/wikiupload/a/aa/Screen-triplehead-galois.jpg
07:54:08 <shachaf> Kinesis
07:54:49 <Poapfel> thank you sir
08:12:45 <aetcore> ?
08:12:50 <aetcore> where did everyone go?
08:13:38 <jmcarthur> what do you mean?
08:13:47 <jmcarthur> there are 964 people here
08:16:46 <drchaos> for problem 8 (see here) I was planning on using a simple state machine with two states EMIT_ELEMENT and DUPLICATE: http://www.haskell.org/haskellwiki/99_questions/1_to_10
08:16:57 <drchaos> is this overcomplicating things?
08:18:11 <Botje> and how are you going to feed the state machine?
08:19:16 <ramses_> drchaos: it can be solved very easily with a few library functions, are do you just want the challenge of doing it on your own?
08:20:03 <drchaos> ramses_: well, I'd like a challenge because I want to learn something
08:20:31 <jmcarthur> drchaos: it can be solved in 14-16 characters
08:20:50 <monochrom> two states are not enough. you are oversimplifying things
08:21:02 <drchaos> besides, in the list ["a", "a", "a"] the state machine would have to change from DUPLICATE to EMIT_ELEMENT at ["a", "a"] in the recursive call
08:21:20 <jmcarthur> i think state machines are often a rather unnatural way to work
08:21:31 <ramses_> drchaos: sure, but I mean, do you want to learn to program efficiently in haskell, 'cause if so I'd suggest you look at Data.List and use some library functions. If you want to learn to write down a bigger algorithm, sure then implementing a state machine might be a nice challenge
08:21:35 <drchaos> I think state machines are not the proper way to go about it
08:21:38 <jmcarthur> haskell works fine for implementing state machines. it's just that you're basically emulating imperative programming this way
08:22:46 <jmcarthur> drchaos: the haskelly way would be to combine 3 or 4 existing functions in a nice, high-level expression
08:23:31 <drchaos> jmcarthur: ooh, I want to do it that way
08:23:31 <monochrom> one of which is considered unsafe by many people in this channel
08:23:48 <drchaos> unsafe? huh?
08:23:55 <drchaos> what is that supposed to mean?
08:23:55 <jmcarthur> partial
08:24:02 <jmcarthur> unsafe means different things to different people
08:24:27 <ParahSailin> is pipes/conduits intended to supersede bytestring lazy?
08:24:31 <drchaos> well, we are basically discarding data to produce a result with this function, are we not?
08:24:34 <jmcarthur> but the one monochrom is thinking of is partial, which many people consider bad practice in that improper use can cause a runtime error
08:24:40 <drchaos> oh
08:24:43 <monochrom> I have taken that into account. there are enough people here who say that partial functions are unsafe.
08:24:43 <jmcarthur> ParahSailin: they serve different purposes
08:25:12 <drchaos> I have no idea of the functions available to me or how to combine them
08:25:20 <drchaos> it's class time
08:25:21 <jmcarthur> drchaos: read the documentation for Data.List
08:25:25 <ramses_> drchaos: have a look at the Data.List module
08:25:28 <drchaos> ok
08:25:29 <monochrom> then write your own recursion
08:25:52 <ramses_> then eliminate the recursion :)
08:26:18 <jmcarthur> i think a good thing for practice is to try to use existing functions to solve your problem, then try to implement those functions in terms of other functions, etc. see how far you can go without resorting to explicit recursion
08:26:23 <monochrom> toss a coin
08:26:36 <jmcarthur> eventually you have to, but it might surprised you how deeply you can go without explicit recursion
08:26:40 <jmcarthur> *surprise
08:27:19 <jmcarthur> it's also a fun game to see how far you can go while avoiding pattern matching
08:27:27 <jmcarthur> not that pattern matching is bad
08:27:44 <ParahSailin> the hardest part of haskell in my experience is making it compile to something optimized
08:28:16 <ramses_> that makes me think of something I was wondering about, is there any way to access a field of a data type (that is not written using record syntax) without pattern matching?
08:28:16 <ParahSailin> i remember for one task i had to turn off -O2 and turn on -fno-state-hack or it would just be broken-slow
08:28:18 <jmcarthur> ParahSailin: it gets easier once you've largely internalized how the runtime works
08:28:25 <jmcarthur> interesting
08:28:31 <jmcarthur> i've never had to do -fno-state-hack
08:28:37 <drchaos> ok, I am looking here and I see no partial function: http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html
08:28:47 <jmcarthur> it's there
08:29:02 <jmcarthur> there are a few, even
08:29:20 <jmcarthur> drchaos: one example, which is not the one we have in mind, is tail
08:29:25 <ParahSailin> jmcarthur, the program im working on at the moment seems to need some crazy fiddling with magic options in ghc
08:29:35 <ramses_> think of which functions have no sensible output for some corner cases
08:29:48 <jmcarthur> ParahSailin: sounds to me like you need to drive the evaluation order a bit more explicitly in the code or something
08:29:50 <ramses_> and a typical corner case would be an infinite list, or an empty one
08:29:56 <drchaos> jmcarthur: oh, so partial is a class of functions?
08:30:00 <jmcarthur> drchaos: yes
08:30:08 <jmcarthur> drchaos: a partial function is one which is not defined for all inputs
08:30:17 <drchaos> ah
08:30:22 <jmcarthur> > tail []
08:30:32 <jmcarthur> no lambdabot :(
08:30:39 <latermuse> where did it go?
08:30:49 <jmcarthur> that should give "*** Exception: Prelude.tail: empty list"
08:30:50 <ParahSailin> jmcarthur, for that no-state-hack, i generated IO [Int] from a mersenne twister package-- now i'm thinking i would have needed unsafeinterleaveIO
08:30:53 <latermuse> 00:10 -!- lambdabot [~lambdabot@li85-105.members.linode.com] has quit [Ping timeout: 255 seconds]
08:30:56 <drchaos> jmcarthur: it's OK, I always have terminals open
08:32:23 <monochrom> scheme is how far you can go without pattern matching, ha ha
08:33:55 <jmcarthur> there are other ways to define this function in terms of other functions without the use of partial functions
08:34:18 <shachaf> package++
08:34:30 <drchaos> jmcarthur: http://static.inky.ws/image/3490/2012-12-01-103200_1680x1050_scrot.png
08:35:18 <jmcarthur> i have a keyboard shortcut just for opening a new terminal with a ghci session
08:35:34 <beaky> hello
08:35:39 <shachaf> ghci takes 0.8s to start up these days.
08:36:01 <shachaf> Must be all my imports.
08:36:02 <drchaos> jmcarthur: OK, let me create one of those keyboard shortcuts
08:36:10 <beaky> how do i implement tictactoe in a purely functional manner?
08:36:21 <beaky> data.sequence?
08:37:11 <jmcarthur> tictactoe is small enough that you could just make a single record to store all of the squares, unless you want a generalized version of them game
08:37:22 <jmcarthur> *the game
08:37:24 <beaky> yeah
08:37:47 <monochrom> I would use an array
08:37:52 <beaky> those AI algoriths might be fun to implement in haskel
08:38:08 <monochrom> but it is immutable array. you can call it a record
08:38:26 <monochrom> immutable data buys you backtracking for free
08:39:01 <drchaos> Mwahahahahah! The new keyboard shortcut works
08:39:21 <monochrom> I tried to implement some basic AI algorithms in C. the need to remember "copy this array so I could backtrack later" was annoying. I grew impatient and gave up
08:39:43 <jmcarthur> you can even still implement this function in 14-16 characters without the partial function (just checked)
08:40:14 <monochrom> then I met haskell and I simply walked into Mordor and wrote this: http://www.vex.net/~trebla/haskell/forwardconstraint/ForwardConstraint.html
08:43:15 <shachaf> I'm up to 107 imports in .ghci
08:43:29 <dim> hi
08:43:30 <shachaf> Maybe the next version of GHC will make startup fast again.
08:43:33 <shachaf> They're done it before!
08:44:37 <jmcarthur> shachaf: that's a lot of imports
08:44:57 <jmcarthur> shachaf: maybe you could make a little package that exports them all via just one precompiled module
08:45:03 <latermuse> monochrom: do any of you run osxmonad?
08:45:19 <latermuse> oops, that came out strangely
08:45:55 <dim> I'm doing cabal install pandoc, to be able to write a 12 to 20 lines script to add a minor piece of feature, and it looks like I'm installing yet another version of the whole computing world. is that normal?
08:45:57 <Entroacceptor> we are all monochrom!
08:46:12 <shachaf> jmcarthur: Some of them are qualified.
08:46:20 <jmcarthur> dim: must be a version clash in some dependency
08:46:34 <jmcarthur> shachaf: ah. well, the unqualified ones at least :)
08:46:36 <monochrom> I don't even have osx
08:47:34 <ramses_> jmcarthur: I'm thinking about your solution without an partial function, not immediately obvious though
08:47:55 <monochrom> perhaps osxmonad is unrelated to osx. I don't use osxmonad either, and never heard of it
08:48:59 <monochrom> dim: it is or is not normal depending on what you had installed previously
08:49:49 <jmcarthur> ramses_: there are at least two standard alternatives to that function
08:50:03 <shachaf> Which function?
08:50:20 <rwbarton> its name is unspeakable
08:50:28 <jmcarthur> shachaf:  the most popular partial function on lists (being secretive because somebody else here is trying to solve a problem)
08:50:35 <dim> monochrom: it's my first ever try at using haskell
08:50:36 <jmcarthur> *an exercise
08:50:42 <shachaf> Ah.
08:51:13 <ramses_> jmcarthur: I'm at 27 chars with no partial function, you've probably got something better
08:51:21 <beaky> i love monads
08:51:24 <shachaf> I bet it's minimumBy.
08:52:37 <Jafet> :t minimumBy $ const $ const LT
08:53:02 <monochrom> then we are at an impasse
08:53:23 <jmcarthur> how did i not know about ghci's "it" variable for so long?
08:53:54 <monochrom> by not reading the manual
08:54:06 <shachaf> It's because you only read the first line of error messages.
08:54:17 <shachaf> It's right there in the last line of every error in ghci. :-)
08:54:24 <jmcarthur> ha
08:54:51 <jmcarthur> i just never paid that bit much attention
08:55:49 <ramses_> jmcarthur: I'm down to 20, but had to use >>= to get there
08:55:49 <jmcarthur> is there a way to hide functions or prevent them from being imported when using :m?
08:56:07 <jmcarthur> ramses_: i don't think >>= is cheating
08:56:38 <shachaf> What is the goal here?
08:56:48 <shachaf> jmcarthur: import Foo hiding (...)
08:56:52 <shachaf> Well, that's not :m
08:56:54 <shachaf> But it works in ghci
08:56:59 <jmcarthur> oh
08:57:01 <jmcarthur> nice :)
08:57:11 <jmcarthur> i forgot about that. it used to not work
08:57:22 <blablub> cabal: when i run "cabal build ; cabal test" everything seems to be compiled twice
08:57:35 <ramses_> shachaf: someone asked about solving problem 8 of http://www.haskell.org/haskellwiki/99_questions/1_to_10 and the extra constraint added here was to not use partial functions
08:57:37 <blablub> can i prevent this?
08:58:04 <dim> ok I just got 385M	/Users/dim/Library/Haskell/ of dependencies for pandoc, I guess it's kind of expected, I didn't realize I was bootstraping a new world of computing...
08:58:07 <ramses_> shachaf: it was pointed out that that should be possible in < 16 or so characters
08:58:35 <jmcarthur> mine is 16 characters if i use pretty whitespace, 14 if i remove unnecessary whitespace
08:59:00 <shachaf> The most common way of writing that would probably use a partial function.
08:59:04 <jmcarthur> yes
08:59:20 <monochrom> no, the extra constraint was not added. I only pointed out that a partial function could be used. I said it in a way to mock people who frown upon partial functions.
08:59:27 <shachaf> That's easy to get around, though.
09:01:19 <shachaf> I think jmcarthur is using more modules than just Data.List
09:01:26 <jmcarthur> shachaf: indeed
09:01:35 <jmcarthur> i'm using one other
09:01:41 <shachaf> So I know his solution.
09:02:01 <monochrom> why are you counting characters? why not tokens?
09:02:33 <jmcarthur> just because that's what most people do
09:02:35 <shachaf> "no partial functions" is a somewhat odd restriction in Haskell.
09:02:44 <monochrom> they do it wrong
09:02:48 <blablub> if any, "tokens" also sounds like the only sensible source code metric to me
09:02:51 <jmcarthur> four tokens
09:03:00 <shachaf> @where e_10
09:03:06 <shachaf> Hmph.
09:03:39 <monochrom> counting characters is clearly an unfair comparison between "longname ( x : xs ) =" and "f(x:xs)="
09:03:42 <jmcarthur> i did say "3 or 4 functions" earlier
09:03:48 <shachaf> jmcarthur: If you remove all restrictions I can do it in lambdabot in 11 characters.
09:04:05 <shachaf> monochrom: So what?
09:04:13 <jmcarthur> by "all restrictions" you mean the one restriction on partial functions?
09:04:13 <monochrom> counting lines is also unfair, but not as extreme as counting characters, so I let that slide, but in principle it's pretty wrong too
09:04:29 <shachaf> And the restriction on imports that I guess you didn't actually mention. :-)
09:04:34 <jmcarthur> oh right
09:04:39 <jmcarthur> i never had that restriction
09:04:45 <jmcarthur> or never intended it, at least
09:04:46 <shachaf> lambdabot has an unusual stdlib
09:04:59 * jmcarthur thinks how it could be done in 11 characters
09:05:02 <shachaf> Cale: ☝
09:05:07 <shachaf> (lambdabot is dead)
09:05:18 <shachaf> That should've been ☟
09:05:33 <monochrom> shachaf, it's wrong, it's misleading, it's unproductive, it should be changed. but if you don't share that view, fine.
09:06:16 <monochrom> just look at how jmcarthur is sweating over "down to 16 characters by removing some spaces". that's silly.
09:06:28 <jmcarthur> 14 :P
09:06:35 <jmcarthur> this is just a game guys, sheesh
09:06:36 <shachaf> monochrom: It's a fun optimization problem of a well-defined property.
09:08:34 <jmcarthur> oh i see how it works
09:08:51 <blablub> the sense of these exercises is to produce barely readable code that barely does what it should to impress programmers of other languages, except perl monks of course, because they can still do it better :D
09:09:49 <blablub> ... and in the process you improve your skills in your favorite language
09:10:51 <jmcarthur> that lambdabot solution uses a function i don't like :(
09:11:09 <jmcarthur> on the other hand, i guess it also decreases the token count
09:11:19 <shachaf> jmcarthur: I don't like it much either.
09:11:31 <shachaf> Actually it uses two different things I don't like.
09:11:48 <shachaf> If you only use one of them you can do 13
09:13:55 <C-Keen> hi! I am installing a package with cabal but it insists on calling "make", whereas I would need to call GNU make which is called "gmake" on my system. How can I set this?
09:14:43 <Saizan> you could try --with-make=gmake
09:14:43 <jmcarthur> yeah
09:14:47 <elliott> trry --with-make=gmake
09:14:55 <C-Keen> ah thank you
09:15:53 <C-Keen> cabal does not know about --with-make, this is cabal 1.16.0.2
09:15:59 <shachaf> --with-hmake?
09:16:07 <shachaf> I don't know if hmake is some other program or what.
09:16:11 <C-Keen> looks better
09:16:23 <shachaf> Oh, it is.
09:16:25 <shachaf> Never mind.
09:16:59 <elliott> a better question might be why cabal is calling make in the first place
09:17:20 <shachaf> That would be a good question.
09:18:16 <C-Keen> just a second, I will show you the output
09:19:28 <C-Keen> http://paste.call-cc.org/paste?id=87c17c6b82a135a748365c3e508b295681f5e0bd
09:20:13 <C-Keen> this is on OpenBSD 5.2 x86 with ghc 7.0.4
09:23:07 <brandonw> i just wanted to confirm: http://www.haskell.org/haskellwiki/99_questions/Solutions/8
09:23:15 <brandonw> is the very first solution given at the top of that page actually incorrect?
09:23:29 <brandonw> compress = map head . group
09:23:57 <Saizan> brandonw: no, why?
09:23:57 <brandonw> seems  like it wouldn't even type check, since map first maps group over each element
09:24:06 <brandonw> whereas, group takes in a list, not a single element
09:24:11 <shachaf> No it doesn't.
09:24:16 <shachaf> (map head) . group
09:24:38 <brandonw> right, that looks more accurate
09:24:40 <shachaf> ?
09:24:49 <brandonw> you want to map head on to the output of group
09:24:56 <brandonw> not compose head and group, and send that function to map
09:25:02 <ion> …
09:25:05 <shachaf> map head . group means (map head) . group
09:25:13 <rogerthealien> i have an anonymous function (\e -> putStrLn "Nan")  --- how would i be able to declare the type of e? (\(e :: SomeType) -> putStrLn "Nan") doesn't seem to be the right way
09:25:29 <shachaf> rogerthealien: {-# LANGUAGE ScopedTypeVariables #-}
09:25:48 <jmcarthur> brandonw: the (.) divides the map head from the group
09:25:52 <Saizan> C-Keen: maybe it's easiest to just trick it with a symlink and a custom PATH
09:25:53 <brandonw> ohhh
09:25:59 <ion> Also: (\e -> putStrLn "Nan") :: SomeType -> IO ()
09:26:03 <shachaf> brandonw: Do you have ghci?
09:26:04 <brandonw> i was thinking map head . group means map (head . group)
09:26:10 <jmcarthur> brandonw: function application binds tighter than any operator
09:26:13 <ion> brandonw: Function application binds tighter than any operator.
09:26:13 <brandonw> but yeah function application comes first
09:26:17 <jmcarthur> ion: :o
09:26:33 <shachaf> jmcarthur: It's a cult.
09:26:35 <ion> Great butts fart alike.
09:27:05 <blablub> jmcarthur: firsto to post, and capital "F": the winner! ;)
09:27:59 <jmcarthur> no, ion did the correct capitalization and punctuation. i was merely the first.
09:28:19 <shachaf> jmcarthur's capitalization was as correct as ion's.
09:28:23 <e1decembrie> why haskell?
09:28:29 <cizra> Hey guys and gals. I'm starting a project that contains a network server + a custom desktop client, meant to run on Windwoes (but I'd prefer to develop in Linux and only test on Windwoes). I'm thinking of making the whole mess in Haskell, for the community, type system, and the added benefit that the customer will be highly likely locked in to yours truly. I believe Haskell + gtkhs is mature enough to pull this off, right?
09:28:29 <elliott> e1decembrie: why not?
09:28:50 <ion> cizra: M1CR0$0F7 WINDW0ES?
09:29:00 <cizra> ion: Is there any other kind?
09:29:10 <jmcarthur> e1decembrie: easy to reason about. terse. pretty fast. etc. same reasons others might support a different language.
09:29:31 <cizra> My main concern right now is deployment -- can I pack my program + whatever Haskell libs needed into a self-contained bunch that won't pollute the customer's computer too much with runtimes and whatnot?
09:29:39 <cizra> Link things statically as much as I can
09:29:45 <shachaf> cizra: Yep.
09:30:14 <blablub> cizra: in the Good Old Times (TM) static linking was the only option
09:30:27 <e1decembrie> @jmcarthur: i saw a lot of researchers who started to use haskell instead of other language.
09:30:40 <e1decembrie> jmcarthur: i saw a lot of researchers who started to use haskell instead of other language.
09:30:50 <shachaf> e1decembrie: Did you read the FAQ? A lot of your questions are probably answered there. :-)
09:31:02 <shachaf> http://www.haskell.org/haskellwiki/FAQ
09:31:04 <e1decembrie> shacaf: i will read it.
09:31:10 <e1decembrie> shacaf: thanks. :)
09:31:13 <jmcarthur> is there a way to have ghci use defaulting when evaluating and attempting to show the result of an expression, but not use defaulting when using let?
09:31:27 <blablub> eldecembrie: were they all into programming languages or also other topics?
09:31:28 <shachaf> jmcarthur: What kind of defaulting?
09:31:56 <brandonw> man, currying
09:32:03 <jmcarthur> shachaf: i want to be able to have the monomorphism restriction turned off and still type  5  and have ghci print that back to me
09:32:04 <rogerthealien> shachaf: thanks
09:32:05 <brandonw> is going to make me unlearn so many habits
09:32:06 <e1decembrie> blablub: other topic too :)
09:32:07 <brandonw> lol
09:32:13 <shachaf> jmcarthur: That's how it works, isn't it?
09:32:27 <shachaf> Those aren't even really related to each other.
09:32:31 <brandonw> it's so engrained in my habits that a function call must be complete and done all at once
09:32:38 <jmcarthur> oh right. i did something else
09:32:38 <shachaf> I always turn the MR off in ghci.
09:32:40 <brandonw> *ingrained
09:32:43 <C-Keen> Saizan: I am sure that works, but there must be a cleaner way...
09:33:37 <jmcarthur> shachaf: okay, say i have NumInstances in ghci and i say "5 5"
09:33:54 <jmcarthur> shachaf: i would like ghci to give me "5", but instead it's an error
09:34:05 <shachaf> Oh, I don't know about NumInstances.
09:34:15 <shachaf> Where do I get that?
09:34:17 <jmcarthur> it's just a specific case of a more general issue
09:34:26 <shachaf> Aha.
09:34:28 <jmcarthur> let me try to think of another example
09:35:01 <cizra> But in genral, it seems that Haskell is good enough to build commercial apps on Windwoes, right?
09:35:18 <kallisti> is there a CPP macro that specifies which version of base is being used?
09:35:32 <shachaf> cizra: Is that "Windwoes" strictly necessary?
09:35:44 <shachaf> kallisti: Yes, MIN_VERSION_base(x,y,z) or something like that.
09:36:11 <cizra> shachaf: Yes. That's what my beloved customers are VERY likely going to run.
09:36:34 <Clint> shame on them
09:36:39 <shachaf> I was referring to your spelling, actually.
09:37:01 <cizra> shachaf: Ohh, sorry. No, my days of being political are mostly past.
09:37:01 <blablub> btw, i'd also like to know whether GHC+GTK is stable enough on windows
09:37:52 <kallisti> shachaf: I don't think it matters in this case. I'm just changing a Bits constraint to (Bits x, Num x)
09:37:56 <cizra> I know GTK itself is -- Wireshark and Pidgin (at least) use it.
09:38:03 <kallisti> which shouldn't break with prior versions of base
09:38:13 <Saizan> C-Keen: are you sure it's calling make? i can't find out that would happen starting from Setup.hs
09:38:17 <shachaf> kallisti: ?
09:38:27 <blablub> but is gtkhs stable and complete enough?
09:38:35 <Saizan> C-Keen: cabal by itself won't use make
09:38:52 <kallisti> shachaf: Bits is no longer a superclass of Num. If I just explicitly add the Num constraint, my code will still compile on versions of base where that is still true.
09:38:58 <Saizan> C-Keen: so it has to come from the custom build code that git-annex adds
09:39:03 <C-Keen> Saizan: hm, I assumed it by looking at the lines "Makefile", line 5: Need an operator. These are typical when you call a gnu makefile with bsd make
09:39:13 <byorgey> kallisti: indeed, no CPP is needed for that change
09:39:20 <kallisti> shachaf: er, other way around, Num is a superclass of Bits.
09:39:29 <kallisti> *was
09:39:30 <kallisti> :P
09:39:48 <kallisti> technically is, since that version of base is probably still used.
09:39:56 <blablub> is there a good article that explains how to cross-compile haskell apps from linux to windows?
09:40:15 <jmcarthur> shachaf: ah, well, i can't figure out a way to trigger it right now. i'm sure i'll bump into it again sometime
09:40:32 <Saizan> C-Keen: makes sense
09:40:44 <jmcarthur> shachaf: the NumInstances thing is all i can think of. here's that example with its type:   5 5 :: (Num (a -> t), Num a) => t
09:40:58 <jmcarthur> i guess this makes sense
09:40:58 <cizra> blablub: That's not strictly necessary (for me) -- I need to test it anyway...
09:40:59 <shachaf> jmcarthur: Yes, I see that behavior with NumInstances.
09:41:19 <shachaf> Seems like a bit of an edge case.
09:41:42 <blablub> cizra: but compiling on windows is like linux from scratch: manual compilation, hunting dependencies manually ...
09:42:14 <cizra> blablub: Eeek. That sounds bad, but at least it's a one-time job.
09:42:31 <Nereid> compiling haskell stuff on windows works fine
09:42:37 <Nereid> cabal still works
09:42:43 <blablub> cizra: well, until you want to upgrade packages
09:43:02 <shachaf> What's with all the Windows FUD?
09:43:29 <blablub> shachaf: we're just trying to improve a broken system with some haskell blessing ;)
09:43:35 <shachaf> Plenty of Haskell people use Windows just fine.
09:44:01 * shachaf sighs.
09:44:20 <blablub> shachaf: do you compile natively or via cygwin?
09:44:34 <Nereid> ghc runs natively on windows
09:44:42 <Nereid> and so do the things built by it
09:45:01 <shachaf> blablub: I don't use Windows at all.
09:45:11 <blablub> Nereid: i know, i compile on windows myself. however, getting linuxy packages to run is a lot of work with mingw and msys
09:45:23 <Saizan> some C deps can be a pain on windows, or libs coming with configure scripts
09:45:28 <blablub> shachaf: ;)
09:45:34 <Nereid> ok sure, if you have some foreign dependencies then it's a bit more work
09:45:35 <parcs`> ghci 7.2 used to randomly crash with a "blocked indefinitely on mvar" exception
09:45:41 <Saizan> luckily the platform has binaries for the most used ones
09:45:50 <parcs`> on windows, that is.
09:45:57 <Nereid> but whenever I did that, just running cabal from a mingw shell worked fine
09:46:32 <Nereid> I wouldn't call it a lot of work
09:46:42 <blablub> well, i guess the main problem is that there is no package manager for compiling free libs on windows
09:47:04 <blablub> something like emerge or similar would be great
09:47:05 <Nereid> there is no package manager period.
09:47:47 <blablub> Nereid: well, ever compiled GTK yourself on windows? is has a ton of deps and sometimes you have to try several versions of a lib, because some versions simply won't work
09:48:01 <cizra> blablub: http://www.haskell.org/haskellwiki/GHC_under_Wine
09:48:10 <Nereid> then don't do that? there are gtk binaries for windows
09:48:27 <Nereid> also, gtk2hs was easy to build as well. (just follow the simple instructions)
09:49:00 <Saizan> yeah, try to use binaries for C stuff, Haskell stuff is quite smooth otherwise
09:49:01 <monochrom> FOSS /= compile everything yourself
09:49:03 <Nisstyre-laptop> So, what is the best library for doing web requests? I'm looking for something very "Haskell-ish", not just a wrapper around a C library. Network.HTTP is the one I checked out, dunno if there's something better out there.
09:49:13 <blablub> cizra: thanks, but i have a native windows to compile and run on. i just hope that it is a lot less time-consuming to cross-compile from linux
09:49:19 <Nereid> Nisstyre-laptop: maybe check out http-conduit ;)
09:49:32 <monochrom> also, no package manager /= compile everything yourself
09:49:38 <Nisstyre-laptop> Nereid: thanks I'll get that from hackage right now
09:49:53 <Nereid> blablub: in any case, building haskell stuff on windows is pretty easy
09:50:04 * hackagebot HDBC 2.3.1.2 - Haskell Database Connectivity  http://hackage.haskell.org/package/HDBC-2.3.1.2 (NicolasWu)
09:50:06 * hackagebot cond 0.4.0.2 - Basic conditional and boolean operators with monadic variants.  http://hackage.haskell.org/package/cond-0.4.0.2 (AdamCurtis)
09:50:13 <Eelis> ghc-under-wine works very well for my crosscompilation needs
09:50:14 <monochrom> I still don't understand why people still think "if not apt-get install ghc, then compile ghc myself"
09:50:44 <blablub> Nereid: i agree. ghc is not the problem. the foss libs are
09:51:01 <Nisstyre-laptop> monochrom: depends what you mean by "compile myself"
09:51:02 <Saizan> monochrom: tbf that's how it goes for lots of software on linux
09:51:09 <Nisstyre-laptop> monochrom: to me that means run a build script
09:51:34 <Nisstyre-laptop> I know it's not quite the same, but that's what I would do
09:51:51 <blablub> btw, using prebuilt libs on windows won't solve all problems automatically, you can still get odd problems like weird name mangling of export symbols, and so on
09:52:05 <Nereid> deal with that when you come to it then.
09:52:06 <Saizan> i don't think there are lots of projects who bother making a generic linux binaries
09:53:25 <Nisstyre-laptop> Saizan: because it's so easy to build it yourself
09:53:50 <monochrom> to compile ghc, first you need to compile ghc
09:53:54 <Nisstyre-laptop> if you use Arch like me then everything you don't get from the official repos is build yourself through ABS
09:54:31 <Saizan> right, ghc is one of the exceptions where you can't do without a generic binary
09:54:57 <Saizan> but still it's quite natural that the first reaction will be to do what works most of the time
09:55:03 <monochrom> this is why the false dichotomy "apt-get or build" breaks down
09:55:38 <Nisstyre-laptop> monochrom: well people are not used to downloading precompiled binaries from a source that is not their distro's repo
09:55:50 <Nisstyre-laptop> monochrom: which is probably a sign that they are no longer used to windows
09:55:55 <Saizan> of course it breaks down, still i'd be surprised if everyone would immediately realize that ghc has to be treated specially
09:56:31 <Saizan> or even can be treated specially
09:56:42 <Nisstyre-laptop> Saizan: well I wonder how they think GCC gets built
09:57:10 <monochrom> ok sure, but hop over to ghc's download page, it puts generic binaries up front
09:57:14 <Nisstyre-laptop> "the magical compilation faeries do it"
09:57:29 <Saizan> Nisstyre-laptop: the experience of not finding gcc in the repos would be quite weird itself :)
09:57:42 <Nisstyre-laptop> Saizan: it's the same concept though
09:57:45 <latermuse> http://www.reddit.com/r/programming/comments/142jix/10_print_chr_2055_rnd_1_goto_10_how_a_single_line/c79cz2q  Is there a way to get better performance of the code use in this haskell example?
09:57:59 <monochrom> the correct natural first reaction is to look at the download page, not to presume
09:58:29 <Saizan> Nisstyre-laptop: yeah, but it's one of the exceptions, and it's also one you're likely to not have faced
09:58:36 <monochrom> but if you say, humans want incorrect natural first reactions rather than correct natural first reactions, sure
09:59:11 <Nisstyre-laptop> Saizan: yeah, so it can be explained simply that people assume gcc will always be there, and that if they want to compile it then they just use gcc, because it's always there
09:59:13 <Saizan> we just build habits and stick with them until we get burned :)
09:59:56 <Nisstyre-laptop> Saizan: welcome to psychology I guess
10:00:14 <Nisstyre-laptop> actually it's sort of evolutionary psychology
10:00:58 <Nisstyre-laptop> Saizan: I think this is the same reason some people have trouble with programming at a fundamental level
10:01:12 <Nisstyre-laptop> Saizan: they aren't used to thinking about something using a structured framework
10:01:43 <Nisstyre-laptop> same thing applies to mathematics
10:03:00 <Eelis> isn't ghc supposed to be great at cross-module optimization? i just moved 30 LOC worth of functions from one module to another, and my program's performance went down the drain
10:03:42 <Eelis> guess i'll keep the code in the original module for performance reasons, even though i'd really logically like it in its own module
10:03:45 <shachaf> Eelis: Try adding INLINE pragmas?
10:03:49 <shachaf> Or INLINABLE or something.
10:03:53 <Eelis> ...
10:03:59 <Eelis> i like my solution better
10:04:05 <shachaf> What?
10:04:13 <shachaf> {-# INLINE ... #-} isn't a big hassle.
10:04:19 <Eelis> i don't want to be in the business of telling the compiler what to inline
10:04:21 <Eelis> when i don't have to
10:04:28 <Eelis> it's a step back
10:04:41 <shachaf> So instead of doing it with a pragma, you'll do it by putting your code in a module it doesn't belong in?
10:04:47 <Eelis> yes
10:04:57 <monochrom> ghc has good heuristics for when to inline, cross modules, etc. but good heuristics may still fail in your case
10:05:00 <shachaf> Seems much more unnatural to me.
10:05:04 * hackagebot ghc-gc-tune 0.3 - Graph performance of Haskell programs with different GC flags  http://hackage.haskell.org/package/ghc-gc-tune-0.3 (DonaldStewart)
10:05:26 <Eelis> shachaf: i don't even know what is supposed to be inlined. i'd have to do research on it first
10:05:31 <Eelis> i'd be doing the compiler's job
10:05:38 <shachaf> If a function is only ever used once, GHC will always inline it if it can, because there's no duplication of code.
10:05:44 <monochrom> otoh, fwiw, famous high-performance libs such as bytestring etc are full of these instructions to the compiler
10:05:47 <Eelis> i'd rather let it do /its/ job. and when it is so incompetent that it can only do its job properly in a single module, so be it
10:06:07 <elliott> calling GHC incompetent is a good laugh
10:06:09 <shachaf> When you don't export it from a module, GHC knows it's only ever used once, so that can help its inlining heuristics.
10:06:24 <Nisstyre-laptop> it probably uses heuristics for a reason
10:06:32 <Nisstyre-laptop> I'm guessing because it would be intractable otherwise
10:06:33 <elliott> poor naive GHC. not like there's actually difficult problems involved here or anything
10:06:51 <Nisstyre-laptop> does anyone want to confirm that or expand?
10:07:35 <monochrom> in principle, writing "code" is doing the compiler's job already. there is a reason why you say "code", rather than "algorithm", "specification", "description", etc
10:07:41 <jmcarthur> dons is uploading packages?!
10:08:12 <Eelis> monochrom: lol, yes, excellent argument. coding is doing the compiler's job already, so whenever the compiler isn't doing something it really could be doing, one should rejoice, for there is opportunity for more coding!
10:08:28 <shachaf> jmcarthur: Hmm, I was just looking into ghc-gc-tune the other day.
10:08:30 <Nisstyre-laptop> monochrom: I'm not sure I see where the line is between a piece of code and an algorithm
10:08:45 <argiopeweb> Don is alive? I thought he had been given a new name and face and moved to a non-disclosed location...
10:08:53 <jmcarthur> he's here in nyc
10:09:14 <shachaf> 0.3 still links to GHC 6.12 documentation.
10:09:24 <jmcarthur> even saw him in person once. last i heard from him apart from pictures of clouds on twitter
10:09:48 <shachaf> Last I saw him was at BayHac 2011, I think.
10:09:50 <Nisstyre-laptop> monochrom: in my mind that leads to things like the silly views some people have on patenting software
10:10:00 <jmcarthur> shachaf: you inspired me to finally finish prettying my ghci
10:10:25 <Eelis> rather than INLINE pragmas, ghc should offer a  --take-all-the-fucking-time-you-need-to-do-cross-module-optimization-as-if-everything-was-in-a-single-module  siwtch
10:10:32 <geekosaur> do you normally confuse the map with the territory?
10:10:50 <jmcarthur> Eelis: that would be call -fexpose-all-unfoldings
10:10:52 <jmcarthur> *called
10:11:01 <Eelis> great, i'll try that, thanks :)
10:11:10 <jmcarthur> Eelis: it's not *quite* what you said you wanted, but close
10:11:18 <Eelis> understood, i'll read the docs
10:11:25 <jmcarthur> Eelis: it's the same as putting INLINABLE over everything
10:11:36 <yepyep> I'm having an awful time understanding (>>=) in Control.Monad.State.  I've done some reading but still don't understand it.  Any suggested tutorials?
10:11:40 <monochrom> Eelis, I'm saying that you're drawing a very artificial, arbitrary line between your job and compiler's job
10:11:52 <shachaf> yepyep: Step 1: Figure out what it's supposed to do.
10:11:57 <shachaf> Step 2: Write it yourself from scratch.
10:12:05 <Eelis> monochrom: i think "i don't want to have to tell the compiler what to inline" is a pretty obvious clear line
10:12:29 <shachaf> Step 1 is the important one. Sometimes people skip to step 3 and try to read the code in the module. :-)
10:12:58 <eikke> yepyep: first, learn the Reader monad, then the Writer monad, then realize State is somewhat alike to Reader and Writer combined
10:13:15 <shachaf> eikke: Huh? Writer and State don't have much in common.
10:13:34 <shachaf> I sometimes wish they had less suggestive names.
10:13:41 <shachaf> Or, rather, suggestive of the right things.
10:13:55 <shachaf> Well, I guess they have *some* things in common.
10:14:06 <Eelis> shachaf: got any particular new names in mind? :)
10:14:15 <argiopeweb> shachaf: They're all in the same package, for one...
10:14:27 <shachaf> But anyway, yepyep wasn't trying to "learn the State monad", they were trying to understand (>>=) :: State s a -> (a -> State s b) -> State s b
10:14:30 <monochrom> I can only agree to this pragmatic stance: given one compiler, I do the minimal work to get the program I want. but nothing says that this minimal work must not involve certain things. it is up to the given compiler.
10:14:37 <argiopeweb> And I want to say they all employ tuples, but that's as far as I'd give it.
10:14:37 <shachaf> Which is a perfectly reasonable concrete function to understand.
10:14:40 <zenzike_> shachaf: and State is precisely equal to the composition of Reader and Writer ...
10:14:49 <shachaf> argiopeweb: Unfortunately that's not correct.
10:15:08 <shachaf> zenzike_: Where is the Monoid instance in Writer?
10:15:16 <shachaf> Er, in State.
10:15:25 <DMcGill> yepyep: do you mean the definition of (>>=) for State, or what it does?
10:15:50 <elliott> zenzike: Reader + Writer is a very different thing
10:15:54 <argiopeweb> shachaf: As zenzike_ just pointed out. Apparently this is one of those days where I let my (metaphorical) mouth run ahead of my brain. I'll sit here and be quiet.
10:16:06 <elliott> consider that RWS = Reader, Writer and State composed together.
10:16:14 <monochrom> if one particular version of one particular compiler requires me to use "let" to gain some memoization it can't figure out, "seq" to gain some eagerness it can't figure out, "INLINE" to gain some inlining it can't figure out, I accept it. there is always a future version that improves upon this.
10:16:15 <elliott> (and it isn't the same as State and State composed together)
10:16:24 <eikke> shachaf, elliott, zenzike: I didnt imply State equals Reader + Writer, but when you understand how Reader and Writer work, State is pretty obvious
10:16:29 <yepyep> DMcGill: the definition.  I feel like i can understand code that uses state, but i'm puzzled by the inner workings
10:16:51 <yepyep> of >>= anyways
10:16:53 <monochrom> figuring out when to inline is not obvious
10:17:12 <elliott> I was replying to zenzike_.
10:17:40 <elliott> who said exactly that was true
10:18:07 <shachaf> yepyep: OK, do you know what "State s a" means?
10:18:13 <eikke> just clarifying ;)
10:18:53 <zenzike> elliott: I was just thinking in terms of Reader and Writer being adjoint, and that giving rise to State
10:19:10 <yepyep> shachaf, well, if i understand correctly, the s is the state, and the a is the result from a previous computation
10:19:35 <yepyep> and the State itself is a newtype wrapping around those two
10:19:50 <shachaf> yepyep: OK, but do you understand what it actually is/means?
10:19:50 <eikke> yepyep: 'a' is the type of the value yielded by the complete computation when being 'executed'
10:20:00 <newsham> > runState (return 3) 9
10:20:04 * hackagebot HDBC-odbc 2.3.1.1 - ODBC driver for HDBC  http://hackage.haskell.org/package/HDBC-odbc-2.3.1.1 (NicolasWu)
10:20:09 <shachaf> I guess I'm just talking about the definition of State. :-)
10:20:37 <shachaf> "State s a" is a function that takes some state of type "s" and returns some state of type "s" along with a value of type "a"
10:20:52 <shachaf> So we say that State s a = s -> (a,s)
10:21:20 <shachaf> Now expand that in (>>=)'s type
10:21:25 <shachaf> State s a -> (a -> State s b) -> State s b
10:21:47 <yepyep> so it's sort of like function composition in a sense?
10:22:04 <shachaf> What's like function composition?
10:22:07 <yepyep> errr... maybe not
10:22:14 <shachaf> "State s a" is like a function, because it is a function.
10:22:23 <monochrom> "sort of", "like", "in a sense" are always correct
10:22:38 <newsham> (s -> (a,s)) -> (a -> (s -> (b,s)) -> (s -> (b,s))
10:22:41 <shachaf> monochrom is sort of like correct, in a sense.
10:23:03 <monochrom> the important point is just answer yes and move on
10:25:05 * hackagebot webdriver 0.5 - a Haskell client for the Selenium WebDriver protocol  http://hackage.haskell.org/package/webdriver-0.5 (AdamCurtis)
10:27:52 <yepyep> The part at (a -> State s b) -> State s b  or if we replace with functions as newsham did (a -> (s -> (b,s)) -> (s -> (b,s)) is where i'm getting lost
10:28:16 <yepyep> why do we pass the result of the first state computation back in?
10:29:13 <newsham> yepyep: thats what monad's "bind" does.  it passes the unwrapped result from the first computation as input into the second computation.
10:29:49 <yepyep> Ok, yeah. that makes sense.  I'm overthinking it i guess.
10:29:52 <parcs`> yepyep: because you can :)
10:29:52 <newsham> take the first half of the program, execute it, take its result and pass it as input to the second half of your program
10:30:20 <newsham> sort of what "var =" and ";" do in C.
10:33:57 <newsham> except you cant reprogram "var =" and ";" in C
10:36:39 <monochrom> the second computation has type a->s->(b,s). it wants both a and s from the first computation. because it has that data dependency
10:38:38 <shapr> Good Morning #haskell!
10:38:44 <shapr> How's code treating everyone?
10:40:13 <monochrom> causing confusions because of lengthy type expressions :)
10:40:47 <monochrom> (types clarify, yes, for those who can read lengthy types)
10:41:46 <monochrom> as an example, (((p -> r) -> s) -> t) is something a lot of people aren't used to, as type or as proposition
10:41:50 <eikke> if liftIO :: MonadIO m => IO a -> m a, is there any way to do MonadIO m => m a -> IO a ?
10:42:16 <monochrom> but once you cease trying to translate it into natural language, it's all clear
10:43:55 <elliott> eikke: no
10:44:31 <byorgey> eikke: not in general.  It depends on the particular monad m.
10:44:42 <byorgey> eikke: for example, suppose m is  StateT Int IO
10:44:52 <byorgey> then you have to use something like  runStateT
10:44:53 <ocharles> (because you have to evaluate the outer monad down to the IO monad, which depends on the monad)
10:45:03 <ocharles> that 'running' is not part of the Monad type class
10:45:14 <monochrom> also, not part of MonadIO
10:45:18 * ocharles nods
10:45:22 <eikke> yes, I figured that
10:45:23 <eikke> thanks
10:46:06 <eikke> then why do so many libraries have functions like "f :: a -> IO b" instead of "f :: MonadIO m => a -> m b" ?
10:46:23 <monochrom> class Runnable m where run :: m a -> IO a
10:46:38 <monochrom> instance Runnable IO where run = forkIO  XD
10:47:09 <byorgey> eikke: if f :: a -> IO b  then  liftIO . f :: MonadIO m => a -> m b
10:47:41 <byorgey> so you don't lose anything by using the more concrete type
10:47:53 <monochrom> because 99% of the time I don't want MonadIO, I want concretely IO
10:48:03 <eikke> byorgey: what is f is actually something like "withFoo :: a -> (b -> IO c) -> IO c", and you'd want "withFoo :: MonadIO m => a -> (b -> m c) -> m c" ?
10:48:10 <HairyDude> cabal says: Warning: Unknown extensions: DeriveGeneric
10:48:29 <byorgey> eikke: right, then it makes a difference
10:48:34 <ocharles> monochrom: hmm, not sure it's 99% for me - i tend to often be in ReaderT whatever IO
10:48:37 <eikke> that's the thing I'm fighting ;)
10:48:56 <elliott> eikke: you can't have the latter, MonadIO is not powerful enough
10:48:57 <eikke> in ReaderT here as well, trying not to be forced to duplicate some with* logic
10:49:08 <elliott> in general there is no really good abstraction for monads that can do this though, the "correct" behaviour depends on what withFoo does
10:49:16 <elliott> consider withFoo = forkIO, m = StateT SomeState IO
10:49:19 <elliott> what should be done with the state?
10:49:41 <byorgey> forkIO seems like a special case
10:50:09 <eikke> yeah. here with* is just bracket+alloc+close, basically
10:50:17 <monochrom> I am playing puns on the word "Runnable"
10:50:55 <elliott> byorgey: well, the same questions apply to exception handling
10:58:59 <humandisaster> Question (very n00b Haskell): It seems like you have two ways of comprehending your lists.  "Plain" list comprehensions, and functions like map, filter, etc. I notice that most haskell code I see doesn't use "plain" comprehensions much. As a beginner, should I invest much time in them?
11:00:41 <roconnor> humandisaster: either way is fine.
11:00:43 <argiopeweb> humandisaster: Speaking for myself, I use them both in daily coding. Sometimes list comprehensions express things much more cleanly, particularly when you have more than one list which you're trying to combine e.g. [(x, y) | x <- [1..10], y <- [1..10]]
11:00:51 <simpson> humandisaster: I'd recommend being familiar with how map and filter work first.
11:01:32 <HairyDude> istr seeing a post saying monad comprehensions were coming back, was that an April fool?
11:02:00 <humandisaster> cool. thanks for the input
11:02:18 <simpson> HairyDude: It's back! You can get full monad comprehensions with -XMonadComprehensions.
11:02:24 <HairyDude> oh, cool
11:02:47 <HairyDude> (not that I ever knew them... I didn't know Haskell existed till long after H'98)
11:03:39 <simpson> HairyDude: No worries.
11:05:05 <Nisstyre-laptop> simpson: badass, I didn't know that extension existed
11:05:14 <Nisstyre-laptop> I've always wanted the list comprehension syntax for any monad
11:05:57 <Nisstyre-laptop> that is going in my normal pragma list along with GADTs and FlexibleInstances
11:06:13 <simpson> :t \mx my -> [(x, y) | x <- mx, y <- my] -- does lambdabot do MCs?
11:06:24 <simpson> Oh, lambdabot's DC'd. :c
11:07:19 <HairyDude> who hosts lambdabot?
11:07:33 <simpson> Cale or lispy, maybe?
11:09:16 <HairyDude> huh, never seen the "group by" comprehension syntax before
11:12:11 <DMcGill> HairyDude: what syntax do you mean?
11:13:59 <Nisstyre-laptop> DMcGill: I think he means the one inspired by LINQ
11:14:53 <hpaste> jtlien pasted “fast integer pop count” at http://hpaste.org/78592
11:18:07 <chandra_> what is wrong in writing a function giving a space at the beginning
11:18:28 <simpson> chandra_: What do you mean?
11:18:51 <zomg> Are there any good resources to learn about typical testing practices in Haskell libraries? Eg. QuickCheck and HUnit, organizing code or such
11:19:05 <ocharles> zomg: Real World Haskell has a chapter on it
11:19:13 <ocharles> zomg: Snap framework is a good example of test layout
11:19:15 <zomg> This seems pretty comprehensive but I wouldn't know if it's accurate http://ics.p.lodz.pl/~stolarek/blog/2012/10/code-testing-in-haskell/
11:19:23 <chandra_> like if i write a function suppose >peculiar y =y it is error free but not > peculiar
11:19:44 <zomg> ocharles: I'll have a look, thanks
11:20:09 <ocharles> zomg: generally, QuickCheck, SmallCheck and HUnit all glued together with test-framework makes a fairly powerful test toolchain
11:20:20 <ocharles> and then use cabal to do the final driving of it all
11:22:38 <ParahSailin> if i do unsafeInterleaveIO on an IO [a], will that let me lazily generate that list?
11:22:39 <BMeph_> chandra_: Spacing of code is significant in Haskell. By inserting spaces in front of something, it tells the compiler to make that code a subordinate clause to something else. Since that's not how you've written the ret of your code, it complains. :)
11:23:17 <BMeph_> ...the *rest...
11:24:19 <ocharles> you should be able to start with a space though as long as you have a module Whatever where
11:24:23 <ocharles> at the top of the file
11:24:36 <ocharles> but they will all have to be indented equally
11:32:43 <chandra_> ocharles: i dint get u
11:37:38 <argiopeweb> ocharles: Any recommendations on best practice for combining SmallCheck and QuickCheck? Seems like there could be a lot of test overlap (and therefore reduced benefit) by using both naively.
11:40:02 <HairyDude> DMcGill: more generally, any of the things starting "then"
11:49:44 <rhodesd> @botsnack
11:52:12 <ocharles> argiopeweb: no advice i'm afraid - i haven't even used smallcheck myself
11:54:22 <argiopeweb> ocharles: Ah well. It may deserve an SO post. I'll see about it in a bit.
11:56:38 <ocharles> argiopeweb: i don't think it needs a SO post - there's plenty of info already with a bit of googling/reading haddock/experimenting
11:57:22 <arthurmaciel> hello!
11:57:45 <TheShaman> Yo!
11:58:43 <arthurmaciel> I'm new to Haskell and have a doubt: why the worry with side-effects if we can use locks for IO for example?
11:59:36 <TheShaman> Sorry can't help you, i am new as well. There are a lot of experts here who will be able to help.....
12:02:23 <shapr> arthurmaciel: You don't get to use locks exactly.
12:02:30 <Mortchek> As far as concurrency goes, having no side effects means you don't even need locks, which are slow, because there is no shared state.
12:03:31 <elliott> (Haskell supports shared state concurrency)
12:03:32 <Mortchek> (This applies to more than just Haskell, by the way - You could write a concurrent C program with no shared state and thus obviate the need for locks.)
12:04:21 <shapr> arthurmaciel: Have you read Learn You A Haskell?
12:12:25 <shapr> arthurmaciel: The nifty thing about IO in Haskell will become clear, but you may want to read through "Real World Haskell" first.
12:17:31 <shapr> SURE IS QUIET HERE!
12:17:33 * shapr boings cheerfully
12:18:09 <jonny_steel_fort> Can someone tell my why I can't define a type like this : funct :: [a] -> Maybe a
12:18:18 <elliott> you can define a function like that
12:18:18 <jonny_steel_fort> or how to achieve my general aim
12:18:24 <elliott> @hpaste
12:18:27 <elliott> paste your code
12:18:29 <elliott> oh, where is lambdabot?
12:18:32 <elliott> http://hpaste.org/
12:18:35 <jonny_steel_fort> wtf. ok, hold on
12:20:13 <arthurmaciel> shapr: sorry and thank you!
12:20:23 <arthurmaciel> shapr: I'm still reading Real World Haskell.
12:20:57 <arthurmaciel> shapr: but from the background I have, if there is no shared state, everytime you call a function you have to copy its parameters, right?
12:21:20 <elliott> no
12:22:53 <arthurmaciel> hm... ok. I'll read more and come back latter :)
12:22:57 <arthurmaciel> thank you, guys!
12:23:14 <hpaste> me pasted “funct” at http://hpaste.org/78596
12:23:42 <argiopeweb> shapr: Must be nice to have all that energy...
12:23:46 * cl1 is learning some category theory
12:24:00 <DMcGill> in line 3, "xs" has type [a] but "Just" has type "a -> Maybe a"
12:24:19 <jonny_steel_fort> oh
12:24:38 <DMcGill> what I think you meant was to make line 3: "funct (x:xs) = Just x"
12:24:44 <DMcGill> if you want to take the first element
12:25:20 <DMcGill> and note that since we throw away "xs", you can do "funct (x:_) = Just x"
12:25:25 <arthurmaciel> see you!
12:27:36 <jonny_steel_fort> Okay. That was a stub to figure out the basics of my problem, but now I've got it going with your advice
12:28:28 <cl1> i know this isn't the appropriate place for this but #math isn't answering. is there a formula to compute the number of possible maps from set A to set B where f . f = f?
12:28:28 <argiopeweb> DMcGill: Isn't there already a maybeHead implementation in the standard libraries somewhere?
12:28:43 <cl1> i already figured out that the total number of maps from A to B is B^A
12:28:58 <DMcGill> listToMaybe does it, but jonny_steel_fort was asking for help on that code in particular
12:29:25 <argiopeweb> Ah, right.
12:29:40 <roconnor> cl1: yo mean maps from set A to set A?
12:29:49 <roconnor> cl1: otherwise f . f doesn't typecheck
12:29:56 <cl1> roconnor: yes
12:29:59 <cl1> sorry
12:30:08 * hackagebot language-lua 0.1.2 - Lua parser and pretty-printer  http://hackage.haskell.org/package/language-lua-0.1.2 (OmerAgacan)
12:30:21 <cl1> roconnor: this is in the context of category theory not haskell
12:30:31 <roconnor> cl1: I'm guessing \sum(i < n, choose(n-i, i))
12:30:37 <roconnor> where #A = n
12:31:24 <ocharles> Hi, anyone got a moment to help me understand why the Rank2Types of ST (et al) works? If I try 'runST (newSTRef "Hello")' it fails, as its meant to but I can't understand why. runST is :: (forall s. ST s a) -> a -- is the problem that a ~ s?
12:31:45 <roconnor> cl1: hmm not quite right
12:31:48 <elliott> ocharles: if you add more quantifiers it makes more sense
12:31:57 <elliott> ocharles: runST :: forall a. (forall s. ST s a) -> a
12:31:59 <ocharles> and we said forall a. outside the st action?
12:32:02 <roconnor> cl1: I'm guessing \sum(i < n, i^(n-i))
12:32:27 <elliott> ocharles: you have (forall s. ST s s) -- the s "escapes" because you are supplying it as the outer forall a
12:32:30 <elliott> st
12:32:31 <elliott> *er
12:32:35 <elliott> ST s (STRef s b)
12:32:37 <elliott> but you get the idea
12:32:57 <ocharles> i guess that makes sense yea, it just seems weird as to why 's' can't be part of 'forall a' - after all, it's all 'a's
12:33:14 <roconnor> cl1: I'm guessing \sum(i <= n, i^(n-i))
12:34:05 <cl1> roconnor: what is sum and i?
12:34:15 <monochrom> no, nothing says a~s or not a~s. (forall s. ST s a) -> a works by saying, runST chooses s, you (provider of the do-block) does not
12:34:36 <roconnor> cl1: sum [i ^ (n-i) | i <- [0..n]]
12:34:42 <donri> marking exposed internals -XUnsafe: good or bad idea?
12:34:48 <cl1> roconnor: ah
12:35:19 <roconnor> cl1: don't trust this is the answer
12:35:28 <cl1> roconnor: lol
12:35:39 <DMcGill> cl1: try asking in #math?
12:35:47 <roconnor> DMcGill: cl1 did try
12:35:51 <cl1> DMcGill: i did
12:35:52 <DMcGill> ah, sorry
12:35:54 <roconnor> np
12:36:46 <ocharles> monochrom: ok, that also makes sense. So the real 'offender' is my action to runST, which is trying to return 's' to the outside world, which somehow violates the fact that runST has chosen 's'?
12:38:06 <jonny_steel_fort> how do I clear this chat?
12:38:37 <jonny_steel_fort> using freenode.net
12:38:48 <monochrom> I guess "who chooses s" does not fully explain that. but I can complete it by also saying who chooses a, and also when.
12:38:54 <sipa> what does 'to clear a chat' mean?
12:39:08 <osa1> does anyone know this error: http://hpaste.org/78597  ? how can I fix that ?
12:39:26 <osa1> I think it's because of a cached file
12:39:37 <jonny_steel_fort> I mean, like clearing your console in linux. There is  too much stuff on my screen. Painful for the old eyes
12:39:39 <DMcGill> so does cabal chance the source before it installs sometimes? I have here "import Paths_sfml_demos" and "fontPath  <- getDataFileName \"Vera.ttf\"", what do I change that into to get it working myself?
12:39:46 <roconnor> where is lambdabot and preflex?
12:40:03 <parcs`> osa1: rm -r .cabal/packages
12:40:14 <monochrom> forall a. (forall s a. blah) -> a.  this says, you choose a, and runST chooses s. but this also say, you choose a first, then runST chooses s. when you choose a, there is no s yet.
12:40:35 <ocharles> ah!
12:40:49 <ocharles> the lightbulb has finally turned on
12:41:09 <elliott> monochrom: you have an extra " a" there
12:41:25 <monochrom> oh, yikes
12:41:34 <ocharles> i got what you meant though :)
12:41:40 <osa1> parcs`: thanks
12:41:41 <jonny_steel_fort> More of conceptual question...but is there anyway to return "any damn thing I please" in Haskell? Like, if I want a function to possibly return one of three things: a list, a tuple of 8, or a Banana data type?
12:41:49 <DMcGill> s/chance/change
12:42:23 <hiptobecubic> jonny_steel_fort, make an algebraic type which is one of those three and then return that
12:42:24 <johnw> jonny_steel_fort: you can always use Data.Dynamic
12:42:49 <elliott> data AnyDamnThing = AList [Int] | ATuple (Int, Int, Int, Int, Int, Int, Int, Int) | ABanana Bananana
12:42:55 <elliott> generally you should use more descriptive names though...
12:43:03 <johnw> also, a function whos type is Int -> a can return "any damn thing"
12:43:06 <hiptobecubic> Banananananana
12:43:17 <monochrom> "any damn thing I please" --- who is "I"? I mean, is "I" the caller of the function? the callee of the function? (cannot be both, there are logical conflicts)
12:43:32 <elliott> johnw: well, it can't return any damn thing at all, to be precise :P
12:43:40 <DMcGill> you should probably not use Data.Dynamic imo, elliott and hiptobecubic have the right idea
12:43:53 <elliott> I agree with monochrom :p
12:43:57 <johnw> i'm getting the sense Dynamic isn't what he wants either
12:44:25 <ClaudiusMaximus> jonny_steel_fort: 1. define a data type, 2. use (equivalent?) continuation passing style like   foo :: ... -> ([Double] -> r) -> ((Int, Char) -> r) -> (Banana -> r) -> r
12:44:43 <jonny_steel_fort> Very cool. Nice examples. So I should probably "roll my own" in this instance. Dynamic is for "unbounded" freedom, then? For instance, if I want to return any of a million things I might think of.
12:45:08 <elliott> Dynamic doesn't really give you freedom.
12:45:14 <jonny_steel_fort> oh
12:45:17 <elliott> you basically never want to use it
12:45:20 <hiptobecubic> :D
12:45:30 <sipa> Dynamic just means you don't need to prove to the typesystem you're always right
12:45:33 <jonny_steel_fort> Well, I didn't need that kind of freedom anyway, so it's all good.
12:45:56 <elliott> in general the problem with code like this is -- what can callers of your function do with the "any old thing" you give back?
12:45:57 <hiptobecubic> jonny_steel_fort, the problem with a function that can return anything is that you don't know what the return value can do
12:46:02 <elliott> there's not really anything they can do at all
12:46:09 <hiptobecubic> right
12:46:11 <monochrom> remember, freedom given to caller is freedom taken away from callee. and vice versa. this is a zero-sum game
12:46:15 <elliott> because some code that uses a function generally wants some kind of result back
12:46:27 <johnw> i think of Dynamic kind of like void* in C.  You can shove anything into it, but the correctness of what you get out is up to you
12:46:42 <elliott> well, you can't shove anything in, not everything is Typeable
12:46:51 <johnw> oh, they need to be Typeable?  didn't know that
12:46:55 <elliott> and you do get runtime errors rather than crashes if you do the wrong thing
12:46:59 <johnw> that makes it a lot less useful
12:47:14 <elliott> it'd break parametricity otherwise
12:47:30 <roconnor> cl1: http://oeis.org/A000248
12:47:31 <monochrom> whenever someone thinks "___ gives freedom", it is really "___ gives freedom to X", and it is always "___ reduces Y's freedom". so don't be happy prematurely, you may be Y rather than X
12:47:42 <roconnor> cl1: seems my formula is wrong
12:48:50 <singpolyma> Is it possible to list executable-only cabal packages as build-depends in a cabal file?
12:48:59 <Jafet> @quote isJust
12:49:03 <jmcarthur> lovely! http://i.imgur.com/t6hOx.png
12:50:58 <jmcarthur> that's my ghci, if it isn't clear
12:51:12 <monochrom> Dynamic is just there for Exception
12:51:15 <osa1> jmcarthur: how did you colorize it ?
12:51:33 <HairyDude> hm, I commented out yesod-core from my .cabal file, but it still compiles... how does that work?
12:51:38 <jmcarthur> h/o and i'll paste the relevant bit of my .ghci
12:52:12 <HairyDude> (I have yesod listed, which depends on yesod-core, but it also depends on yesod-default, which gives a "module not found" error if I comment it out)
12:52:19 <alistra> where is lambdabot?
12:52:20 <hpaste> jmcarthur pasted “prettied and colorized ghci” at http://hpaste.org/78598
12:52:27 <alistra> i need something pointfreed FAST
12:52:28 <jmcarthur> osa1: there^^
12:52:44 <osa1> jmcarthur: thanks
12:52:46 <zxq9> Is there anything like a PL/Haskell already implemented for Postgres?
12:52:49 <elliott> jmcarthur: whoa
12:52:53 <johnw> neat, thanks
12:52:54 <elliott> is there a way to make that work for input too?
12:52:58 <HairyDude> alistra: install lambdabot locally?
12:53:01 <jmcarthur> osa1: i had to tweak the IPPrint package to get it to install
12:53:12 <johnw> alistra: cabal install pointfree
12:53:18 <alistra> johnw: thx
12:53:31 <jmcarthur> osa1: oh, and the colorized prompt required some ansi magic
12:53:33 <roconnor> cl1: I have a correct formula now
12:53:54 <roconnor> cl1: sum [i ^ (n-i) * n `choose` i | i <- [0..n]]
12:53:55 <osa1> jmcarthur: ansi magic ?
12:54:06 <jmcarthur> elliott: i think there's a trick you can use for input, but i don't want to try that yet
12:54:18 <jmcarthur> elliott: it isn't some supported way
12:54:23 <monochrom> HairyDude: if you do not import modules belonging to p, then you don't need depends-on p
12:54:37 <singpolyma> So, I can't find documentation on this, but it looks like since all dependencies are resolved through ghc-pkg, I can't depend on something unless it registers a library
12:54:47 <elliott> jmcarthur: does this colourise IO output I do in GHCi, or just what GHC actually prints? (what about types etc.?)
12:54:56 <elliott> er, just what GHCi actually prints
12:55:08 * hackagebot DAV 0.3 - RFC 4918 WebDAV support  http://hackage.haskell.org/package/DAV-0.3 (ClintAdams)
12:55:09 <jmcarthur> elliott: it's a customization only for the things that ghci prints
12:55:17 <elliott> mm
12:55:25 <jmcarthur> your IO is left alone
12:55:28 <jmcarthur> which is how i want it
12:55:37 <jmcarthur> there is, however, a function you can use in place of print if you wish
12:55:40 <jmcarthur> explicitly, that is
12:55:58 <jmcarthur> the myPrint function defined in that ghci file is available for you to use directly
12:56:03 <jmcarthur> works on anything with Show
12:56:12 <elliott> right
12:56:22 <elliott> I just worry it'll colour other things GHCi outputs too? types, error messages and so on
12:56:28 <jmcarthur> nope
12:56:41 <jmcarthur> it only replaces what ghci uses for "printing" things
12:57:07 <monochrom> oh, is -interactive-print a new thing in 7.6?
12:57:07 <jmcarthur> it normally uses print. this just says to use myPrint instead
12:57:10 <jmcarthur> yeah
12:57:16 <jmcarthur> yay for reading the manual!
12:57:25 <monochrom> now it is less magical
12:57:27 <osa1> jmcarthur: hmm, I'm using 7.4
12:57:34 <rtharper> is there a simple lib for parsing HTML?
12:57:37 <osa1> jmcarthur: also can't install ipprint
12:57:48 <jmcarthur> "osa1: i had to tweak the IPPrint package to get it to install"
12:58:01 <jmcarthur> osa1: you need to bump one of the constraints on its dependencies
12:58:08 <monochrom> tagsoup is a simple lib for parsing HTML
12:58:09 <argiopeweb> jmcarthur: Forgive the ignorance, but how is this (very cool) snippet supposed to be used?
12:58:17 <jmcarthur> argiopeweb: stick it in ~/.ghci
12:58:24 <jmcarthur> argiopeweb: you need a couple packages installed too
12:58:49 <argiopeweb> Ah, okay. I can handle the packages.
12:59:16 <ocharles> jmcarthur: very cool!
12:59:17 <rtharper> monochrom: do you recommend it? I saw a few and wasn't sure which ones were worth looking at
12:59:28 <cizra> Hey guys, do I understand it right that compiling a gtk2hs demo program "$ ghc --make Main.hs" produces a file that is statically linked against GHC runtime and dynamically against GTK? Can I tune this? I'd like to link statically against GTK too, for easier deploying.
12:59:48 <monochrom> I recommend it
12:59:54 <elliott> -optl-static -optl-pthread
12:59:55 <elliott> or something
13:00:35 <monochrom> static GHC runtime, static gtk2hs, dynamic gtk+. if you see what I mean
13:01:02 <monochrom> also dynamic clib
13:01:25 <cizra> elliott: Hmm, I seem to be missing atk and gdk_pixbuf, otherwise seems like it'd work.
13:01:25 <HairyDude> monochrom: ahh, right
13:01:25 <jmcarthur> it even seems to not screw up haskell-mode, although the colors don't show
13:01:42 <cizra> monochrom: Why would dynamic gtk+ be better than static?
13:02:00 <monochrom> not saying better or worse. just saying the default.
13:02:36 <jmcarthur> ah, there's an issue with this
13:02:37 <cizra> Yea, I see :-)
13:02:45 <jmcarthur> it demands the entire input to parse it
13:03:00 <jmcarthur> so you can't print infinite data structures incrementally with this
13:03:12 <HairyDude> dynamic $LIBRARY means you can upgrade the version of $LIBRARY that your program uses without recompiling it.
13:03:32 <monochrom> that is actually not true
13:03:33 <cizra> HairyDude: At the risk of version incompatibility.
13:03:39 <jmcarthur> you have to say "print" explicitly to do that
13:03:46 <ocharles> jmcarthur: you can't print infinite structures anyway, can you?
13:04:02 <monochrom> ghc has dynamic *.so files too. good luck switching versions
13:04:03 <jmcarthur> ocharles: you can print the beginnings of them until you hit control-C
13:04:03 <HairyDude> also reduces memory footprint, and reduces the scope for cross-module inlining (not a problem for foreign libs though)
13:04:05 <HairyDude> cizra: true
13:04:15 <jmcarthur> ocharles: try evaluating [1..] in ghci
13:04:24 <cizra> HairyDude: Reduces memory footprint IF there are any other apps to share the dynamic lib
13:04:29 <HairyDude> also true
13:04:46 <monochrom> dynamic lib reduces exe size by increasing *.so size
13:04:50 <cizra> Which is not the case in Windwoes/GTK+, most of the time.
13:05:12 <ocharles> jmcarthur: ah
13:05:14 <HairyDude> ah, I see your point.
13:05:20 <ocharles> jmcarthur: i see what you mean
13:05:26 <monochrom> I am serious. no a priori reason why your client already has the *.so files your exe needs
13:05:49 <jmcarthur> i think i'm okay with this issue, but we'll see if i become annoyed by it later
13:05:58 <ocharles> jmcarthur: meh, Extra doesn't build here so i can't install ipprint
13:06:13 <jmcarthur> ocharles: you need to bump the version constraint on Extra in the ipprint package
13:06:22 <jmcarthur> ocharles: the newest version of Extra works fine for me
13:06:24 <ocharles> ah
13:06:45 <HairyDude> monochrom: it makes sense where your program is being distributed, say, as part of a Linux distribution where all the Haskell programs are built against the same GHC runtime
13:06:48 <monochrom> in particular, "I am using dynamic lib in my haskell program built with GHC so I can send a small exe to my client" fails to understand how large the *.so files you have to send to your client
13:07:08 <monochrom> "the same GHC runtime" is almost a joke
13:07:32 <HairyDude> well, I don't actually know much about this issue :)
13:07:49 <jmcarthur> i'm confused about how ghc is supposed to do all of its fancy cross-module inlining with dynamic libraries, too
13:08:04 <monochrom> you are spoiled by c libs being so versatily version-compatible back front and center
13:08:34 <HairyDude> I think if it's inlinable you get Core definitions in .hi files. which further increases library size...
13:08:41 <jmcarthur> i suppose it could still do it. it just means the savings are even smaller from using dynlibs
13:08:44 <monochrom> but GHC, if you so much as change a tiny optimization flag, you lose binary compatibility
13:09:17 <HairyDude> doesn't LLVM do some link-time inlining?
13:11:05 <monochrom> go find out the ABI hashes of base in various linux distros. even with nominally "same GHC version" and "just focus on x86_64", you may be able to find different hashes
13:11:33 <monochrom> therefore, a dynamic exe built on one distro will not work on another distro
13:11:51 <HairyDude> monochrom: yes. But what about two programs built for the same distro?
13:13:06 <cizra> Dynamic linking is good for linking speed, I think :-)
13:13:13 <HairyDude> what effect do shared libraries have on cache performance?
13:13:20 <monochrom> screw same distro. the exact condition is: the builder and the client have identical *.so files
13:16:17 <hpaste> edwardk pasted “TF based Iso” at http://hpaste.org/78600
13:18:38 <jrajav> Has anyone compared Mathematica's expression rewriting and rule-based programming to Haskell?
13:20:01 <robbe-> Hello, I'm confused :) For an exercises I have to implement the Read typeclass for my type, but I don't understand how I should implement readsPrec
13:20:39 <typoclass> robbe-: i think the second argument is usually ignored ... "readsPrec s _ = ..."
13:21:32 <rwbarton> it only matters when your Read instance uses infix syntax
13:22:08 <robbe-> typoclass: As far as I understand, the first argument is the precedence, and the second one is the input.
13:23:27 <typoclass> robbe-: right :-) that may well be possible. i only recall it has one weird parameter that everyone ignores
13:23:33 <robbe-> But indeed, I am ignoring precedence. :-) We are asked to parse a string into our own data format so to speak. I read that's not really the intention of read/show but the exercise is what it is I suppose. :-)
13:24:37 <elliott> that is a bad exercise, yes
13:28:21 <shirt> how can my haskell program print the version of GHC that compiled it?
13:29:26 <atriq> shirt, System.Info.compilerVersion?
13:29:47 <Igloo> shirt: Run "yourprog +RTS --info"
13:33:14 <jmcarthur> ocharles: did you ever get it to work?
13:33:39 <shirt> atriq, Igloo: thanks! both great answers! but compilerVersion is giving me [7,4] or [7,6]. How do I get the exact full version, such as "7.6.1"?
13:33:51 <jmcarthur> osa1: same to you ^^
13:34:09 <rwbarton> the +RTS --info one shows the full version
13:34:39 <rwbarton> if it's enough to get the information from "outside" the program
13:36:16 <ParahSailin> how do i reinstall packages with profiling
13:36:37 <Heffalump> ParahSailin: cabal install --reinstall --enable-library-profiling foo
13:37:04 <Heffalump> annoyingly, it won't recurse over dependencies that are alreay installed without profiling
13:39:50 <shirt> rwbarton: ideally i would like to get the full version from "inside" the program
13:42:30 <k0ral> anyone experiencing unexpected segfaults since last update of gtk2hs ?
13:44:24 <meiji11> hi. I've got a graph I'm generating at random, which is done in the IO monad. I would like to submit a bunch of queries to a function that manipulates this structure in ghci.
13:44:42 <meiji11> the problem is, since the graph is encapsulated in the io monad, it's re-generated every time it's referenced..
13:45:28 <meiji11> I would like to generate a graph at random *and* preven it from being re-generated. I'm not sure if this is possible in lazy IO, since random number generation must be done there.
13:45:40 <meiji11> lazy IO is all I know. is there an alternative that might help?
13:46:16 <monochrom> "x <- make_graph". then x is fixed
13:46:34 <meiji11> you can do that in ghci?
13:46:38 <monochrom> yes
13:46:42 <meiji11> I thought you had to be in a do clause.
13:46:54 <monochrom> ghci is special
13:47:05 <meiji11> so you can. thanks very much.
13:48:29 <monochrom> there are a ton of other anomalies of ghci
13:49:05 <meiji11> are they all documented somewhere?
13:49:16 <monochrom> yes. the GHC user's guide
13:49:56 <typoclass> meiji11: in ghci, you're more or less in a big do clause
13:50:20 <meiji11> i'm thinking I should get around to reading the guide.
13:50:43 <`Jake`> typoclass: You can define Types, though
13:51:08 <roconnor> Is there an applicative Kleisli?
13:51:15 <roconnor> hmm probably not
13:51:17 <roconnor> nevermind
13:51:17 <monochrom> I avoid saying "ghci is a big do clause". 1+1 and getLine cannot possibly work in the same big do clause
13:51:33 <typoclass> `Jake`: yes, but i don't think that will get in the way of him doing "x <- make_graph"
13:51:52 <`Jake`> typoclass: True, I was just pointing that out
13:51:53 <cizra> Is Haskell going to get Agda-style Unicode support anytime soon?
13:52:02 <atriq> cizra, it sort of does
13:52:06 <ion> It already has.
13:52:07 <monochrom> at the end, you must admit that ghci is special. that's the only tenable position
13:52:30 <cizra> Ahhh, the Unicode language extension?
13:52:33 <cizra> http://www.haskell.org/haskellwiki/Unicode-symbols
13:53:20 <typoclass> monochrom: yes yes, but "big do block" is a reasonable first approximation. "big do block and additionally you can do 1+1 and stuff" would be the second approximation
13:54:24 <Amoeba1> Hi all I a trying to learn haskell with Try Haskell.
13:54:37 <Amoeba1> I keep getting Terminated on Lesson2
13:54:39 <monochrom> no, in practice, most people know "you can do 1+1" first
13:55:11 <yitz> 1+1 doesn't really violate the "big do clause" analogy; it just means there is an implied print (sort of) when the type is not IO. things like :set are what really make it only an approximation.
13:56:04 <yitz> and of :load, and import after you've already done stuff, and...
13:56:06 <monochrom> that's stretching too far
13:56:39 <yitz> monochrom: ?
13:56:42 <Amoeba1> Is there any channel for tryhaskell?
13:57:35 <lispy> simpson: what's up?
13:57:43 <monochrom> IMO, the part "implied print" already violates the "big do clause" analogy. there is no big do clause that has implied print or implied whatever, much less implied whatever based on type differentiation
13:57:59 <yitz> hi lispy
13:58:08 <atriq> Amoeba1, have you tried refreshing the page?
13:58:08 <lispy> simpson: oh, n/m. Yes, I run the server and Cale is the lambdabot admin
13:58:14 <lispy> yitz: howdy
13:58:27 <lispy> yitz: how are things?
13:58:38 <monochrom> the analogy is violated left right and centre. newer GHCi versions violate more. the analogy is stretching thin. it's time to give up
13:58:42 <yitz> lispy: many people are very very frustrated with the version of cabal-dev currently on haskell
13:58:49 <yitz> lispy: great thanks!
13:59:06 <lispy> yitz: oh no. Please elaborate
13:59:18 * lispy assumes s/haskell/hackage
13:59:22 <yitz> lispy: can't you guys just upload whatever happens to be there right now? it would be far better than the current situation
13:59:35 <yitz> *hackage yes :)
13:59:43 <lispy> yitz: because of the ghci support or something else?
13:59:49 <monochrom> it's much easier to just say: expressions are supported, fragments of do-notation are supported, declarations are supported, etc
14:00:15 <yitz> lispy: it doesn't compile on 7.6. it doesn't work with either the current or last previous version of the haskell platform.
14:00:45 <monochrom> approximations and analogies do not simplify this. I have nothing against approximations and analogies that genuinely simplify.
14:01:08 <yitz> lispy: until the current sandboxing work on cabal itself goes live - which it now looks like won't be for a while - cabal-dev has become a critical part of the haskell infrastructure.
14:01:10 <lispy> yitz: thanks for letting me know. I'll see what I can do
14:01:30 <yitz> lispy: it really needs to be able to be installed with cabal and at least partially work.
14:01:33 <yitz> lispy: thanks!
14:01:36 <Amoeba1> atriq If I do the irc chat will disconnect. I guess I can try it.
14:01:44 <atriq> Not this page!
14:01:51 <atriq> The other page!
14:01:58 <atriq> Aaargh, I knew that would happen
14:02:35 <hiptobecubic> heh
14:02:54 <Amoeba1> Well refreshing the page didn't help on tryhaskell.org
14:03:08 <Amoeba1> I am just trying a simple expression and I love the interface of tryhaskell.org
14:03:18 <hiptobecubic> what expression?
14:03:20 <atriq> I meant the tryhaskell.org page, btw, not this page
14:03:50 <Philonous> Does cabal-dev ghci still not work?
14:03:50 <lispy> yitz: looks like the release stalled on supporting HP current and HP (current -1 )
14:03:59 <Amoeba1> atriq It's the smae page.
14:04:11 <jrajav> I guess not :(
14:04:11 <Amoeba1> hiptobecubic: let x = 4 in x * x
14:04:13 <lispy> Philonous: I sent a pull request and I think it does work if you get the one from github
14:04:25 <hiptobecubic> Amoeba1, yeah no. there's a problem here
14:04:31 <yitz> lispy: there's a ticket for -1 including a simple patch. some simple cabal dependency bump i think
14:04:42 <atriq> That's happening for me, too, Amoeba1
14:04:48 <yitz> lispy: probably something similar for current hp too
14:05:03 <atriq> Try just typing it again
14:05:11 <Amoeba1> Ok thanks let me try.
14:05:15 <neutrino> hi guys
14:05:25 <neutrino> how can i throw an exception in my code? I am in the IO monad
14:05:28 <yitz> lispy: fwiu the problem with ghc 7.6 is only the containers version dep.
14:05:36 <Amoeba1> Ah thanks hiptobecubic and atriq it worked!
14:05:38 <neutrino> i know i need to use throwIO but not sure what to give it as a parameter
14:05:42 <yitz> lispy: maybe a few other small things like that.
14:06:07 <neutrino> i want to raise the exception when a subprocess returns non-zero.
14:06:10 <lispy> yitz: can you show me the current -1 patch? https://github.com/creswick/cabal-dev/pulls
14:06:14 <Philonous> lispy:  Ah, nice. I hacked the FakeGhc to pass --numeric-version through to the actual ghc and that worked. But I guess I can get rid of that now
14:06:16 <Heffalump> neutrino: if you just want to produce a simple exception you can use 'fail' with a String argument
14:06:25 <lispy> Philonous: that was the patch I sent
14:06:36 <Amoeba1> http://stackoverflow.com/questions/1012573/getting-started-with-haskell I like what's on this page. Is it a good way to go about Haskell Programming?
14:06:55 <atriq> Amoeba1, I'd use Learn You a Haskell
14:06:58 <atriq> @where lyah
14:07:37 <Philonous> lispy:  Heh, and I thought it was too ugly to be sent upstream.
14:07:51 <neutrino> Heffalump: i think fail is not guaranteed to respect ordering
14:07:54 <Amoeba1> atriq thanks. Yes the page suggests Learn you a Haskell, then moves to eulers problems and then real world haskell and monads etc ...
14:07:59 <neutrino> Heffalump: throwIO is, so i'd like to use it.
14:07:59 <yitz> lispy: issues #62 and #74
14:08:03 <neutrino> :t throwIO
14:08:09 <neutrino> @type throwIO
14:08:29 <neutrino> throwIO :: Exception e => e -> IO a
14:08:36 <yitz> lispy: seems that current git-hub is fine, just needs to be uploaded to hackage.
14:08:44 <atriq> Amoeba1, definitely start with LYAH. The rest can come later.
14:08:45 <elliott> Amoeba1: project euler is quite bad for haskell
14:08:47 <lispy> yitz: thanks
14:08:51 <elliott> newbies, that is
14:08:54 <neutrino> i need to pass a value of typeclass Exception to throwIO. how do i instantiate such a thing?
14:09:01 <neutrino> i don't see any constructors
14:09:08 <Amoeba1> elliott 99 haskell problems then?
14:09:16 <elliott> I guess it's better
14:09:28 <elliott> I don't like its problems much but they're better than project euler's for haskell
14:09:36 <Heffalump> neutrino: given that fail is in the IO monad, I'd hope it could use throwIO
14:09:54 <Heffalump> but if you really want to use throwIO yourself, you can pass it ErrorCall
14:09:56 <neutrino> i'm not satisfied with hoping
14:10:04 <neutrino> what's ErrorCall?
14:10:07 <Heffalump> I was just trying to find the source
14:10:37 <Heffalump> the exception type that you get when you call 'error'
14:11:42 <Amoeba1>  Thanks atriq and elliott. Let me go get learn you a haskell.
14:12:28 <Amoeba1> How long does it take to become a good Haskell programmer from being an absolute novice?
14:12:54 <johnw> that completely depends on you, your background, your devotion, and time available
14:13:29 <cizra> .. but I'dn't count on less than a year.
14:13:48 <Amoeba1> Johnw. I programmed c for 4 years. Then I lost touch with programming for 7 years now ...
14:13:58 <Amoeba1> cizra sounds good.
14:14:16 * cizra sounds good!
14:14:30 <neutrino> Heffalump: hmm
14:15:09 <ParahSailin> i think cabal should build the library profiling binaries by default for packages, so that newbies who dont need to think about profiling right away dont run into annoyances rebuilding everything when they need prof
14:15:12 <johnw> Amoeba1: it also depends on what you mean by "good".  If you just mean being effect enough to solve your problems, such that Haskell helps more than it gets in the way, that doesn't need to take very long
14:15:12 <Amoeba1> As far as time available, I have the entire month of December at my disposal after that a few hours a day.
14:15:20 <eikke> it also depends on the application you want to build, some domains fit haskell very well and writing code is 'obvious', for some others you need more experience/mind-bending
14:15:56 <Amoeba1> eikke, I just want to learn Haskell for fun.
14:15:59 <issimus> hello all, what does GHC.Exts.lazy do? docs say it has magic strictness property. why do i want to fool the strictness analysis?
14:16:06 <Philonous> Amoeba1:  I think you question isn't well-posed. A "good Haskell programmer" is a completely subjective term.
14:16:10 <Amoeba1> I don't have a  project in mind just yet.
14:16:16 <cizra> You can also write C-style code in Haskell! You can also bind native C code to be callable from Haskell!
14:16:49 <Amoeba1> Cizra that's my definition of  what is *NOT* a good Haskell programmer. :)
14:16:53 <Heffalump> neutrino: I think fail does DTRT: it calls failIO which is defined here: http://www.haskell.org/ghc/docs/latest/html/libraries/base/src/GHC-IO.html
14:17:00 <Amoeba1> Philonous: I guess you are right.
14:17:39 <cizra> Amoeba1: I personally feel that Haskelly Haskell code is easier to write, read, reason about and generally nice. But you do need C-style code for things like GUI programming (unless you're into FRP or something equally bearded)
14:18:02 <neutrino> Heffalump: what is DTRT?
14:18:15 <johnw> Do The Right Thing
14:18:24 <neutrino> ok
14:18:26 <neutrino> thanks johnw
14:18:30 <typoclass> Amoeba1: at any rate, learn it! it's gonna be fun and it'll make you a better programmer no matter which language :-) and lyah is available free of charge, so there's really no reason not to have a look :-)
14:18:51 <neutrino> Heffalump: how do you see that fail calls failIO?
14:19:12 <Amoeba1> typoclass I will. I don't program for a living:) So it's just a hobby.
14:19:42 <cizra> Amoeba1: Maybe you should! It's a clean, quiet, safe, reasonably well-paid job.
14:20:10 <Amoeba1> Thanks all for your help. I will get back to tryhaskell. It's very well designed. I should send a thank you note to the author:)
14:20:16 <cizra> Hard on the organism, though -- your butt is your main, er, working organ.
14:20:23 <Amoeba1> Lol.
14:20:41 <Amoeba1> Well I do have a tire around my belly.
14:21:34 <Heffalump> neutrino: https://github.com/ghc/packages-base/blob/master/GHC/Base.lhs
14:21:34 <Amoeba1> Cirza do you program haskell for you daily bread?
14:21:42 <neutrino> Heffalump: thanks.
14:21:50 <neutrino> i'm trying to understand the definition of failIO.
14:22:44 <neutrino> i might be paranoid
14:22:54 <neutrino> but it isn't entirely apparent to me that it does the right thing
14:23:00 <cizra> Amoeba1: Actually not, but I just got a contract to build a program, and the customer doesn't know anything about this, so I'm going to pick Haskell for this job.
14:23:23 <Amoeba1> Cool.
14:23:47 <cizra> Yeah! I've never built large Haskell application before! Loads of risk :-D
14:23:50 <neutrino> Heffalump: i guess the whole thing hinges on the definition of raiseIO#, which I understand comes from the runtime
14:23:58 <neutrino> i am unable to reason at that level.
14:24:10 <cizra> I have to say, though, that Haskell is the language with the very best community I've seen. You're bound to get quality answers in a really short time in #haskell.
14:24:11 <Amoeba1> As long as it's fun I guess the risk is acceptable. :)
14:24:14 <neutrino> why do you think it will do what i say?
14:24:32 <neutrino> oh, wait
14:24:48 <neutrino> i just looked at throwIO! it's actually using raiseIO# in the same way
14:24:58 <neutrino> so i think you're right, fail will work :)
14:27:50 <Heffalump> :-)
14:28:06 <Heffalump> I got bored once I saw there was a implementation that explicitly mentioned IO
14:28:56 <lispy> yitz: this may have to wait till Monday or Tuesday. I need help from one of my co-workers
14:28:59 <neutrino> thanks a lot Heffalump
14:29:17 <lispy> yitz: Do you think that's okay?
14:29:17 <neutrino> that was very friendly of you to go code diving
14:29:20 <neutrino> :)
14:29:47 <Heffalump> had to justify my casual assertion that it would all be fine ;-)
14:29:52 <lispy> yitz: we have a strict policy of building cabal-dev on our continuous integration server at work before releasing, and it doesn't seem to have targets yet for the latest HP or ghc 7.6
14:37:16 <Amoeba1> What's the equivalent of fst for last in a tuple?
14:37:42 <shachaf> snd?
14:37:42 <Amoeba1> I want the last variable in a tuple.
14:37:47 <issimus> amoeba1: snd
14:38:01 <Amoeba1> Thanks shachaf and issimus.
14:38:08 <Amoeba1> So what exactly does lst do?
14:38:17 <Amoeba1> Is there an lst?
14:38:35 <shachaf> No.
14:38:41 <shachaf> @ty fst -- 2-tuples only
14:38:42 <Amoeba1> Thanks.
14:38:49 <shachaf> fst :: (a,b) ->
14:38:50 <shachaf> a
14:39:50 <issimus> > 3
14:40:34 <typoclass> Amoeba1: in a function that takes a list, you might get handed a list of 10 elements, when called next you might get a list of 0 elements, then one with infinite elements, and so on. it's different for a function that takes a (say) a 3-tuple. it will always contain 3 elements, the compiler ensures it
14:41:27 <axkrts> how would I go about using a Word8 as a bit field?
14:41:53 <shachaf> axkrts: The same way you would in C?
14:41:56 <monochrom> Data.Bits may have operations you like
14:42:03 <shachaf> Ah, yes.
14:42:15 <shachaf> typoclass: That in itself isn't reason enough not to have "fst" work on different tuple sizes.
14:42:18 <axkrts> thanks
14:42:27 <typoclass> shachaf: true
14:42:29 <TheShamanoid> guys i have an important question that is specific to haskell developers
14:42:30 <shachaf> > (view _1 (1,2), view _1 ('a','b','c'))
14:42:39 * shachaf sighs.
14:42:39 <TheShamanoid> and haskell coders too
14:42:42 <shachaf> One day I will learn.
14:42:43 <monochrom> there is a lens for that
14:43:01 <monochrom> @bots
14:43:02 <TheShamanoid> what is the meaning of life?
14:43:08 <xenocons> arbritrary tuple access with an operator is nice =p
14:43:10 <edwardk> lambdabot is dead?
14:43:14 <zobzob> @pl \x -> (x, x)
14:43:18 <typoclass> edwardk: out drinking again
14:43:19 <Amoeba1> typoclass Thanks. I think I get it.
14:43:20 <xenocons> #2 (1,2,3)
14:43:23 <edwardk> makes sense
14:43:24 <roconnor> zobzob: join (,)
14:43:24 <lispy> edwardk: long live lambdabot!
14:43:36 <hiptobecubic> lambdabot is not even here
14:43:45 <typoclass> shachaf: i just meant to explain how lists are fundamentally different from tuples. but yeah.
14:43:55 <shachaf> typoclass: Sure.
14:44:10 <TheShamanoid> guys, what is the meaning of life (in haskell code)?
14:44:28 <Amoeba1> TheShamanoid God wrote in Haskell?
14:44:30 <Ralith> undefined
14:44:33 <johnw> TheShamanoid: it's polymorphic
14:44:43 <hiptobecubic> i thought it was just 42
14:44:50 <johnw> but what's the type of 42?
14:44:50 <lispy> I thought life was implemented with a comonad
14:44:57 <TheShamanoid> Amoeba1: Haskell wrote god.
14:44:58 <hiptobecubic> johnw, defaults to integer
14:45:05 <neutrino> do comonads have co-do syntax?
14:45:08 <johnw> Int, Int#, Int32, Integer? :)
14:45:13 <neutrino> how does it look?
14:45:13 <Amoeba1> TheShamanoid:  https://www.youtube.com/watch?v=pUjJU8Bbn3g
14:45:39 <ParahSailin> all kinds of "dangerous reinstalls" adding profiling to packages
14:46:09 <TheShamanoid> Amoeba1: if this is a video that tries to prove the existence of of tell me in advance.
14:46:19 <Amoeba1> Na!
14:46:21 <typoclass> TheShamanoid: anyway, this channel is for discussing the haskell programming language
14:46:25 <Amoeba1> It's a fun take on lisp.
14:46:30 <ParahSailin> should i just wipe .cabal and start fresh?
14:46:48 <johnw> ParahSailin: you only need to wipe .ghc and .cabal/lib/*
14:47:37 <Amoeba1> It's the song, "God wrote in Lisp". It invokes a lot o programming languages with the notable exception of Haskell.
14:47:39 <typoclass> i was wondering about that "reinstalls are always dangerous" warning -- what does it mean anyway?
14:47:48 <edwardk> neutrino: dominic orchard wrote a paper and a package for codo sugar
14:48:01 <edwardk> https://github.com/dorchard/codo-notation
14:48:08 <edwardk> http://www.cl.cam.ac.uk/~dao29/drafts/codo-notation-orchard-ifl12.pdf
14:48:12 <startling> typoclass, it's a lie.
14:48:18 <startling> typoclass, but sometimes reinstalls can break existing packages.
14:48:35 <monochrom> reinstalls are safe iff you are a cabal pro
14:49:15 <monochrom> therefore, while "reinstalls are always dangerous" is a lie, it is only a lie for non-pros
14:49:23 <monochrom> err, only a lie for pros
14:49:35 <TheShamanoid> Amoeba1: Just listened to it, pretty awesome :D
14:49:45 <typoclass> hm ok, thanks guys
14:49:57 <monochrom> but I am sure we can all agree with s/dangerous/confusing/
14:50:59 <neutrino> edwardk: interesting
14:51:51 <startling> I think learning haskell kind of entails becoming a cabal pro. :/
14:52:13 <shapr> startling: Have you seen snoyman's code that fixes that problem?
14:52:16 <shapr> stackage?
14:52:24 <startling> shapr: nope
14:52:32 <monochrom> it is better to erase those packages you don't want or you want replaced. with them gone, when you install new or replacement stuff, you don't get false alarms
14:52:33 <shapr> @google snoyman stackage hackage
14:52:43 <shapr> oh, no lambdabot
14:53:03 <shapr> startling: http://www.yesodweb.com/blog/2012/11/stable-vetted-hackage
14:53:06 <monochrom> that is, if you still get alarms, now you know they are about things you really need
14:54:10 <startling> shapr: interesting
14:56:04 <Amoeba1> I love the map function! Dunno why but I love Haskell and I don't know anything about it!
14:56:50 <typoclass> Amoeba1: ;-) good start
14:57:14 <Eelis> many a blog post has been written about what's to love about map ;)
14:57:31 <typoclass> shapr: thanks, interesting link
14:57:33 <pckt> I am partial to folds personally
14:57:46 <argiopeweb> jmcarthur: I'm playing with your GHCI prettiness. Any clues on how to get it to persist after loading a file?
14:57:49 <Amoeba1> let me look up folds!
14:57:50 <Eelis> pckt: i like folds implemented with map ;)
14:57:55 <startling> is there a library for pretty-printing tables?
14:58:28 <yitz> elliott: why do you not like euler for haskell?
14:58:53 <johnw>  yeah, why not?
14:58:55 <startling> oh, this is interesting: http://hackage.haskell.org/packages/archive/boxes/0.1.2/doc/html/Text-PrettyPrint-Boxes.html
14:58:59 <shapr> startling: so, if dependency problems are bothering you, contribute to snoyman's stackage project!
14:59:03 <johnw> i found solving them in Haskell quite interesting
14:59:12 <neutrino> edwardk: what is on the left of => in the codo notation?
14:59:21 <startling> euler is interesting but it doesn't teach you haskell.
14:59:24 <neutrino> it looks like this: codo x => some code here
14:59:37 <johnw> startling: on the contrary, it taught me quite a few things about Haskell
14:59:37 <Amoeba1> startling: so what does?
14:59:38 <elliott> yitz: you run into strictness issues with a lot of the numeric stuff
14:59:44 <johnw> especially the numerical side of Haskell
14:59:50 <elliott> people come in here confused about it when doing euler project problems early in haskell
14:59:57 <yitz> elliott: i did a few hunderd of them. never had any problems.
15:00:04 <elliott> maybe you already knew too much then :)
15:00:06 <neutrino> Amoeba1: i wish there was something like 4clojure but for haskell. that one's really good.
15:00:06 <startling> johnw, you'd never learn Applicative or State or Reader or Writer just by doing euler, though
15:00:07 <typoclass> Amoeba1: basically, map takes a list and produces another list of the same length, while a fold takes a list and produces some other value. foldr (+) 7 [3..5] gives 19, for instance
15:00:13 <edwardk> neutrino: in general comonads don't give you a way to smash two values together. you need a ComonadApply instance for that. the marker is which comonadic values are being merged through that
15:00:22 <johnw> startling: sure, but you do learn other things
15:00:37 <xenocons> hm, looking at the pattern matching in learnyouahaskell, i notice theyre building the type signature for the function, sayMe :: (Integral a) => a -> string, how do we define this inside of ghci (as opposed to a script)
15:00:41 <startling> johnw: like what?
15:00:45 <neutrino> edwardk: how do you smash two values together in a monad?
15:00:47 <jmcarthur> argiopeweb: how are you loading the file? i've not had any problem with it going away
15:00:48 <johnw> anyway, fpcomplete is working on a Learning Site that will cover the various areas of Haskell, with interactive examples
15:00:55 <shapr> johnw: exciting!
15:00:55 <johnw> startling: like what I said above, the numerical side
15:01:12 <elliott> xenocons: let sayMe :: blah; sayMe ... = ...
15:01:13 <edwardk> :t ap
15:01:24 <jmcarthur> argiopeweb: i take it back, i see
15:01:28 <argiopeweb> jmcarthur: Either via :l or from the command line (ghci file.hs). Running 7.6.1
15:01:33 <yitz> euler is definitely not a way to learn all of haskell. it's a nice source of examples of writing pure haskell code.
15:01:35 <edwardk> with ap
15:01:44 <xenocons> elliott: right so you need to have the binding on the same line as the type signature?
15:01:46 <neutrino> edwardk: let me look up that function. never seen it.
15:01:48 <jmcarthur> argiopeweb: i guess i had somehow just not loaded files with this before...
15:01:55 <edwardk> its monadic (<*>)
15:02:03 <jmcarthur> argiopeweb: i might need to make a package for it so that the definition doesn't go away
15:02:10 <xenocons> yitz: especially if you solve a question then look at the forum ;)
15:02:14 <jmcarthur> argiopeweb: the downside of that being that the settings would have to be hardcoded :\
15:02:21 <elliott> xenocons: pretty much
15:02:28 <elliott> i think you can do let { or something
15:02:30 <argiopeweb> jmcarthur: Hmm, that is a bit of a pain...
15:02:33 <neutrino> ap :: Monad m => m (a -> b) -> m a -> m b
15:02:36 <neutrino> this ap?
15:02:40 <bartamues> let { sayMe :: (Integeral a) => a -> string; s ayMe = ... }
15:02:45 <xenocons> ah...
15:02:47 <xenocons> hmm
15:02:49 <xenocons> awkward
15:02:51 <yitz> xenocons: well yes. but really euler problems are math problems, not programming problems, so a lot of what's on the forum is about that.
15:02:54 <elliott> or rather let { \n ... \n }
15:03:07 <startling> johnw: is haskell's numerical side interesting?
15:03:19 <xenocons> it feels a lot of people dont use ghci for prototyping stuff?
15:03:27 <johnw> startling: i thought so
15:03:32 <argiopeweb> jmcarthur: I also added a (set prompt "Prelude> ") to the end of mine to get rid of the extra module listings.
15:03:41 <johnw> xenocons: i write my code in a file, but i test it in ghci
15:03:43 <neutrino> startling: if you want an easy high-level language for number crunching i suggest python.
15:04:04 <johnw> or go one further and check out sage
15:04:04 <xenocons> johnw: how do you handle stuff like having to use let { and other syntactic differences
15:04:06 <jmcarthur> argiopeweb: yeah i had a custom prompt already, obviously from the screenshot
15:04:09 <startling> neutrino, I already know python and furthermore this has nothing to do with the conversation we're having.
15:04:16 <johnw> xenocons: i just handle it
15:04:20 <xenocons> alright
15:04:28 <Amoeba1> typoclass: nice so folds folds everything in maps just changes and maps the change and propagates it!
15:04:29 <xenocons> pain that it is different i guess, that is a hurdle for noobies like me
15:04:33 <johnw> i don't define a lot of stuff in ghci
15:04:34 <neutrino> startling: i'm sorry you got offended. i heard edwardk gives out free hugs.
15:04:34 <startling> xenocons: yeah, I write my code in a file and then :r in ghci whenever I feel like it.
15:04:40 <xenocons> alright
15:04:41 <typoclass> Amoeba1: yup
15:04:46 <johnw> i define it in my file buffer, hit C-c C-l, and then I call it in ghci
15:04:55 <jmcarthur> does anybody know of a way in ghci to not lose things you defined via let when you :l a file?
15:05:02 <xenocons> ok that settles it i need emacs happening
15:05:10 <startling> xenocons: yeah, haskell-mode is great
15:05:10 <xenocons> let the battle commence
15:05:22 <edwardk> ok, down boys, down =P
15:05:22 <startling> neutrino: I'm not offended? I'm mostly confused why you're suggesting that I learn python
15:05:23 <johnw> C-M-x is supposed to re-eval single definitions, but I've had difficulty getting that to work
15:05:33 <argiopeweb> jmcarthur: I never saw the screenshot. O.o
15:05:45 <neutrino> startling: i saw you asking about applications of haskell in numeric programming.
15:05:52 <neutrino> at least that's what i thought.
15:05:57 <startling> neutrino: nope
15:06:05 <Amoeba1> Is emacs the editor of choice for haskell as well?
15:06:21 <jmcarthur> argiopeweb: http://i.imgur.com/t6hOx.png
15:06:26 <johnw> i wouldn't say that
15:06:30 <johnw> it's _my_ editor of choice
15:06:31 <Rotaerk> Amoeba1, depends on who is doing the programming
15:06:32 <Ralith> Amoeba1: don't you know? emacs is the editor of choice for everything.
15:06:34 <yitz> johnw: since the promises about hackage 2 made years ago still haven't come to fruition, sets of recommended packages, like tibbe's and this stackage thing, are very important.
15:06:39 <argiopeweb> There's a pretty strong VI presence.
15:06:55 <johnw> yitz: yes, I agree
15:07:10 <johnw> stackage doesn't pass all tests on Mac, so we need help tracking that down atm
15:07:11 * nyc is a fan of antique vi's, not vim/etc.
15:07:24 <Amoeba1> Thanks johnw. I used to live in emacs 7 years ago. So I guess it should be my editor of choice as well.
15:07:26 <xenocons> can Vi send a selected buffer to ghci?
15:07:28 <jmcarthur> argiopeweb: yeah i think i will just try the package idea
15:07:28 * Rotaerk doesn't like vi* or emacs.
15:07:31 <jmcarthur> it won't be too hard
15:07:41 <xenocons> Rotaerk: what are you using
15:07:44 <startling> emacs is pretty bad, but so is every other editor. :/
15:07:44 <johnw> Emacs is wondrous, but that's a tale for another channel
15:07:58 <Rotaerk> xenocons, I don't really code in haskell yet
15:08:01 <startling> I like how there are people named "so" and "learning" here.
15:08:04 <Rotaerk> so I don't know what I'll use for it
15:08:07 <neutrino> my editor of choice is ``while read line; do lambdabot -e "@pl $line"; done''
15:08:12 <Rotaerk> I just know I dislike those editors
15:08:18 <xenocons> Rotaerk: ah heh
15:08:22 <johnw> startling: ah, that's why my IRC editor keeps making the word "so" appear in pink...
15:08:23 <argiopeweb> jmcarthur: Sounds good. I suppose I'll do the same.
15:08:24 <yitz> johnw: however, stackage in particular doesn't sound like it will be very general on the face of it. requiring a particular cabal version *outside sandboxing* sounds like a pretty unreasonable requirement, as does String everywhere instead of Text.
15:08:51 <johnw> yitz: it's just at the beginning stages; we're open to comments
15:09:03 <Rotaerk> is that haskell IDE any good yet?
15:09:07 <Rotaerk> leksah?
15:09:07 <elliott> isn't the String thing just in the actual stackage code
15:09:11 <elliott> not in the packages it includes
15:09:11 * `nand` disabled name highlighting for names below 3 characters for precisely that sort of silliness
15:09:20 <xenocons> Rotaerk: its GTK+
15:09:23 <typoclass> yitz: how do you mean, "String everywhere"?
15:09:27 <xenocons> so probably good on linux
15:09:32 <johnw> `nand`: which variable does that?
15:09:33 <startling> johnw: haha
15:09:36 <Rotaerk> xenocons, gtk+ is fine in windows too
15:09:47 <xenocons> hmm, i duno, ive always had problems with gtk+
15:09:48 <`nand`> johnw: depends on the client, surely
15:09:53 <yitz> johnw: i have a pretty iron clad policy: cabal install cabal-dev after a fresh ghc/hp install, then never ever use cabal again, only cabal-dev. so it sounds like stackage is out for me.
15:09:56 <xenocons> bloat, strange font issues
15:09:58 <neutrino> edwardk: so you "smash together" values in codo using extend, yes?
15:10:06 <Rotaerk> ah never had that issue
15:10:13 <geekosaur> hm.  is there known to be a problem with the latest haskell platform, 64 bit, on snow leopard?
15:10:13 <johnw> looks like I have to hack some lisp to make that change here
15:10:13 <startling> "smash", too.
15:10:21 <edwardk> extend just keeps the comonad around. you smash them together with <@> from ComonadApply
15:10:28 <johnw> yitz: i'm an avid sandboxer as welr
15:10:35 <geekosaur> I know there's an issue with Double but I'm getting ghci dumping core before it prints a prompt
15:10:38 <johnw> but that's not the target audience for stackage
15:11:17 <johnw> so, that's changed
15:11:22 <johnw> hmm.. still highlighting...
15:11:23 <startling> geekosaur, ugh, yes
15:11:29 <geekosaur> I do not have a .ghci file
15:11:30 <startling> geekosaur: the solution is to use 32-bit on snow leopard
15:11:31 <geekosaur> *sigh*
15:11:47 <johnw> so
15:11:48 <startling> geekosaur, 64-bit isn't officially supported on snow leopard or earlier for Reasons
15:11:49 <yitz> typoclass: on the github readme for stackage. it says no dependencies on the text package, use String everywhere.
15:11:53 <edwardk> once the new version of lens goes out i'll look into putting it on stackage
15:11:55 <geekosaur> that would be problematic.  I guess no haskell on this machine then.
15:12:15 <neutrino> edwardk: so i need those "markers" to be able to do <@>?
15:12:19 <neutrino> i don't buy that
15:12:19 <startling> geekosaur: you can't use 32-bit?
15:12:20 <edwardk> yitz: he means that the stackage implementation itself doesn't have any
15:12:30 <neutrino> the code i saw in the paper doesn't use <@> once
15:12:37 <romildo> The webkit package offers the function webViewLoadHtmlString to load html content into a WebView widget. How can one get the a WebView content as a string?
15:12:41 <neutrino> i think you're lying to me
15:13:00 <edwardk> neutrino: he called it something else in the paper. i convinced him to switch to ComonadApply. and as i don't care to be called a liar i'm going to go do something else =P
15:13:08 <jmcarthur> argiopeweb: it didn't fix it :(
15:13:15 <yitz> geekosaur: the 32-bit HP works fine on 64-bit SL.
15:13:16 <neutrino> yeah, he did switch
15:13:31 <neutrino> edwardk: going to the gym? :p
15:13:47 <edwardk> no cheater, no i'm not =P
15:13:47 <argiopeweb> jmcarthur: I was just about to come back and tell you the same thing... :\
15:13:57 <xenocons> alright, ive got emacs+haskell-mode now
15:14:04 <geekosaur> I got tired of 32-bit infecting everything and causing failures with stuff that decided it needed to build universal but refused to build 32-bit, so I purged 32-bit libs and am trying to avoid reintroducing them
15:14:36 <startling> geekosaur: sorry. :/
15:14:41 <neutrino> edwardk: had me tricked ;)
15:14:44 <geekosaur> I am not expecting to be able to upgrade this machine to lion or later any time soon, either
15:16:10 <elliott> neutrino: calling people who are trying to help you liars isn't very productive...
15:16:23 <yitz> geekosaur: by "purged 32-bit libs", do you mean you bascially broke Snow Leopard?
15:16:27 <neutrino> edwardk: can you say the markers on the left of => are like lambda parameters?
15:16:27 <kallisti> heh, so today I learned that Debian has a libghc-cond-dev
15:16:40 <geekosaur> yitz, I did not purge system libs, no
15:17:07 <geekosaur> btw the HP Mac web page claims 64 bit is for 10.6 and up, if this is not true then perhaps someone should fix that to say 10.7 and up
15:17:30 <startling> geekosaur: probably. it's a GHC bug, fwiw
15:18:05 <yitz> geekosaur: so since the HP only links statically, why should it bother you if it builds 32-bit?
15:18:22 <jmcarthur> i am now trying to find a way to execute more than one command in ghci at a time
15:18:26 <yitz> (by default)
15:18:38 <startling> jmcarthur: type them really fast
15:18:51 <geekosaur> yitz:  I am not willing to repeat arguments I have had over the roots of this issue in the past here and elsewhere, so just drop the subject
15:19:22 <xenocons> emacs seems like a steep learning curve
15:19:27 <geekosaur> (in particular I do not need hordes of eww-you-aren't-using-my-preferred-drug-you-caveman like last time...)
15:19:51 <jmcarthur> nevermind i found what i need
15:20:10 <Amoeba1> xenocons: try the emacs tutorial. Then try haskell mode.
15:20:18 <argiopeweb> jmcarthur: Tying it to a :def?
15:20:20 <yitz> geekosaur: not trying to argue. just saying that i've been using the 32-bit HP on SL happily, works fine. you'll obviously make your own choices for your own machine.
15:20:25 <xenocons> Amoeba1: doing the tutorial now, its very long
15:20:33 <neutrino> i wonder if codo notation can at all use values from surrounding scope without having them in markers
15:20:37 <Amoeba1> C-h t iirc.
15:20:51 <neutrino> and what is the difference between having them and not having them in markers
15:21:02 <`nand`> Is there a name for the property of ‘f’ that f . f = id ?
15:21:13 <Heffalump> self-inverse?
15:21:36 <johnw> xenocons: most good things have a steep learning curve **cough** Haskell **cough**
15:21:38 <`nand`> ah, an involution
15:21:39 <yitz> `nand`: idempotent
15:21:43 <`nand`> yitz: no, that's f. f = f
15:21:47 <yitz> ah right
15:22:14 <johnw> `nand`: so do you say that "f is involute"?
15:22:19 <jmcarthur> argiopeweb: yeah
15:22:19 <xenocons> johnw: fair call
15:22:25 <jmcarthur> argiopeweb: it works for using :l
15:22:27 <`nand`> johnw: f is involutary
15:22:32 <startling> Amoeba1: fwiw, I just wrote down the commands I thought I'd use a lot (C-x C-f opens a file, C-x b lets you switch buffers, C-x 3 splits vertically, C-x C-s saves, C-c C-l loads in haskell-mode, C-u C-c C-t adds a type annotation in haskell-mode) and then learned from there.
15:22:38 <jmcarthur> argiopeweb: still doesn't work if i pass the file as   ghci <file>
15:22:43 <startling> luckily emacs isn't unusable with just these few commands.
15:22:52 <argiopeweb> I can probably get over that. Mind throwing your fix on hpaste?
15:22:57 <xenocons> startling: thanks! copying that into a file
15:22:59 <johnw> so id is both idempotent and involutary
15:23:13 <Amoeba1> startling: I have probably remapped a lot of those keys.
15:23:20 <neutrino> and is also the convolution by the dirac delta.
15:23:33 <startling> Amoeba1: then you're on your own. :)
15:23:42 <hpaste> jmcarthur pasted “keep colors when loading files” at http://hpaste.org/78605
15:23:48 <jmcarthur> argiopeweb: ^^
15:23:55 <yitz> startling: C-x 3? why not C-x 2?
15:23:56 <jmcarthur> a bit redundant
15:24:00 <Amoeba1> startling: Na I am good with emacs.
15:24:21 <startling> yitz: C-x 3 is more useful to me. I hardly ever split horizontally.
15:24:29 <Amoeba1> xenocons: Is learning emacs though.
15:24:40 <xenocons> (i think startling confused amoeba1 with me)
15:24:50 <startling> Amoeba1, xenocons: oh, heh, yes
15:24:51 <argiopeweb> jmcarthur: Much obliged.
15:24:59 <jmcarthur> argiopeweb: the redundancy seems to be necessary :(
15:25:16 <yitz> startling: anyway, now that i'm using a good window manager (xmonad), which is much better than emacs at windows, i only use C-x 5 2.
15:25:18 <xenocons> whats the difference between def! and def?
15:25:30 <xenocons> (i realise this isnt haskell)
15:25:32 <jmcarthur> :def! allows you to redefine existing definitions
15:25:38 <johnw> one is louder?
15:25:41 <yitz> startling: or more commonly C-x 5 f
15:25:42 <xenocons> heh
15:25:42 <johnw> what are you talking about?
15:25:51 <xenocons> johnw: http://hpaste.org/78605
15:25:51 <jmcarthur> johnw: ghci commands
15:26:25 <startling> yitz: fair enough. I'm on OS X usually, I'd love to be able to use a tiling WM. :(
15:26:32 <johnw> ah, C-M-x in haskell-mode is working now, that's cool
15:26:45 <argiopeweb> jmcarthur: Hmm, odd. You're working at a level above me already. I'm not sure what's up with :def!
15:27:31 <jmcarthur> i'm just referring to the manual
15:27:34 <jmcarthur> first time i've ever used it
15:27:37 <Amoeba1> xenocons: https://www.youtube.com/watch?v=k5JSJuN3UWI
15:28:08 <johnw> i'm guessing :def! overwrites a builtin?
15:28:15 <argiopeweb> Yes
15:28:19 <jmcarthur> just any existing command
15:28:21 <yitz> startling: i see what you mean if you're using a macbook.
15:28:24 <jmcarthur> including builtins
15:28:25 <argiopeweb> Not documented in the :h help, which is odd.
15:29:25 <yitz> startling: though even there i find myself using C-x 5 ... instead of C-x 3. maybe habit from xmonad, but it works for me there too as long as i don't do it too often.
15:29:30 <pqmodn> startling: https://github.com/pufuwozu/osxmonad
15:30:08 <startling> pqmodn: oh huh
15:30:46 <startling> does anyone have a project that uses quickcheck and cabal's test infrastructure together? I'd like to see an example, I'm not sure how I'd organize things.
15:30:48 <johnw> pqmodn: how well does that work?
15:31:01 <johnw> startling: hspec can do that, just fyi
15:31:34 <pqmodn> johnw: i haven't used it myself, but i've followed his twitter feed and it seemed the biggest obstacle was moving windows between spaces, and it's fixed. wish i could say more
15:31:41 <hiptobecubic> startling, didn't you ask that earlier? Someone posted a good link
15:31:52 <startling> hiptobecubic: wasn't me.
15:31:57 <hiptobecubic> oh
15:31:57 * startling scrolls up
15:31:59 <hiptobecubic> let me look for it then
15:32:18 <argiopeweb> jmcarthur: Working on rebinding :r. That should get me close enough that I'll be happy. Just need to :r after I load from the command line.
15:32:25 <hiptobecubic> startling, http://ics.p.lodz.pl/~stolarek/blog/2012/10/code-testing-in-haskell/
15:32:45 <neutrino> hey, guys
15:33:07 <startling> hiptobecubic: nice, thanks
15:33:12 <neutrino> if i have a list [(a, b)] and i want to set an existing key or add it if it doesn't exist, how do i do this?
15:33:26 <hiptobecubic> startling, it's a nice writeup
15:33:41 <kallisti> neutrino: use Data.Map or a similar data structure instead. :P
15:33:55 <xenocons> Amoeba1: watching now
15:33:58 <neutrino> no
15:34:13 <neutrino> this is the structure given to me by library functions and expected by them
15:34:25 <neutrino> i need to know how to do it using this data structure. do you know how?
15:34:51 <neutrino> i could use a lens but i think there's got to be another simpler function for that
15:35:55 <startling> :t M.toList . M.insert "k" 12 . M.fromList
15:36:03 <startling> neutrino: ^
15:36:38 <neutrino> ohh that looks great
15:36:41 <neutrino> thanks startling
15:37:07 <neutrino> kallisti: yeah, i think you had a pretty good idea after all :P
15:37:45 <latro`a> neutrino--any particular reason an assoc list is better in the first place?
15:37:51 <latro`a> (not that there never is one, just curious)
15:38:31 <neutrino> latro`a: one library gives me that, another expects it.
15:38:42 <neutrino> in specific, i get it from getEnvironment and pass it to runProcess.
15:38:46 <latro`a> wonder why that is
15:39:07 <latro`a> I guess I'd have to look at the source for the libs to know
15:39:09 <neutrino> because it's not a bad idea.
15:39:49 <latro`a> depends on what you're doing with it really
15:39:50 <startling> neutrino, alternatively, you can just mylist ++ [("k", 12)] (assuming later definitions take precedence)
15:39:53 <latro`a> just lookup/insertion is better with Map
15:40:02 <neutrino> startling: i considered that, but i'm not sure
15:40:13 <latro`a> wouldn't prepending make more sense?
15:40:37 <startling> latro`a: depends how things are looked up, I guess.
15:40:50 <latro`a> indeed, but the lookup would be faster if the bias is towards the first
15:41:08 <edwardk> startling: i'm looking into adding a sortedList iso to Data.Map.Lens, etc.
15:41:11 <latro`a> also prepending is faster, of course
15:41:43 <edwardk> xs & from sortedList. at k ?~ value
15:41:50 <startling> latro`a: that's true. I was assuming they were e.g. creating a map internally
15:42:02 <latro`a> ahh
15:42:11 <xenocons> Amoeba1: i did laugh
15:42:22 <startling> latro`a: I don't actually know, though, so :T
15:42:25 <argiopeweb> jmcarthur: :r instance is the same as the :l instance (just with auxreload) and works fine. :load and :reload don't work at all though. Odd.
15:42:27 <latro`a> right
15:42:30 <latro`a> nor do I
15:43:33 <jmcarthur> huh. they work for me
15:44:04 <argiopeweb> They should be infinitely recursive... I'm not sure what's going on with that.
15:44:20 <jmcarthur> oh, again, you are right and i am wrong
15:44:26 <jmcarthur> :load indeed fails for me
15:45:06 <startling> is there still no way to use test-suite type detailed-1.0 in cabal?
15:45:07 <argiopeweb> Not to worry. I never use the full words anyway. :l is great, and I can :r if I feel like having pretty output.
15:45:52 <argiopeweb> And it works in the Emacs haskell-mode terminal, which is all kinds of neat.
15:46:06 <jmcarthur> yeah that one surprised me
15:46:59 <deech> Hi all, does GHC erase types like the Java compiler?
15:47:34 <jmcarthur> deech: like most compilers, yes
15:48:27 <deech> jmcarthur: Those are the only two I've worked with, so my follow-up question is why? It seems like it would be useful to have types around during run-time.
15:48:41 <jmcarthur> how would they be useful?
15:49:27 <jmcarthur> you can build with all kinds of profiling info and debugging information, btw
15:49:29 * `nand` .oO( Word1 )
15:49:59 <jmcarthur> `nand`: Bool?
15:50:27 <deech> jmcarthur: The biggest use-case would be able to embed an interpreter that allows me to interact with my program at run-time.
15:50:41 <startling> more specifically, has anyone used detailed-1.0 with quickcheck and succeeded?
15:50:42 <cmccann> `nand`, but what about Word0?
15:51:05 <deech> jmcarthur: Also to useful for when other dynamic languages want to interact with my program at runtime.
15:51:05 <jmcarthur> deech: http://hackage.haskell.org/package/hint
15:51:30 <`nand`> type Word0 = (); type Word1 = Bit
15:51:36 <shirt> how do i make an unboxed array where the elements are a newtype? i'm getting: No instance for (Data.Array.Base.IArray UArray Foo) arising from a use of `bounds'
15:51:41 <`nand`> wait wait
15:51:48 <`nand`> type Word n = Vector n Bit
15:51:54 <deech> jmcarthur: Neat, didn't know this existed.
15:52:03 <elliott> type Word n = Fin (2^n)
15:52:16 <jmcarthur> shirt: you need to write the Unbox instance for the newtype. there's a package to help with that using template haskell. unbox-th i think it's called?
15:52:19 <Amoeba1> What's the difference between (10,3,2) and [10,3,2] ?
15:52:29 <Iceland_jack> Amoeba1: one is a tuple, the other is a list
15:52:36 <jmcarthur> Amoeba1: the former is a tuple, which has a fixed length and possibly different types for each element
15:52:37 * cmccann notes that having a Data or Typeable or whatever constraint available amounts to preserving a lot of type information
15:52:41 <Heffalump> jmcarthur: can't you just use GeneralizedNewtypeDeriving?
15:52:48 <jmcarthur> Amoeba1: the second is a list, which variable length and only one type of elements
15:53:03 <Amoeba1> Thanks Iceland_jack  and jmcarthur.
15:53:07 <Amoeba1> so
15:53:11 <jmcarthur> Heffalump: it's hard because you also need some associated data types and such
15:53:17 <Amoeba1> "Ameba" is a list?
15:53:18 <Heffalump> ah, ok
15:53:27 <shirt> jmcarthur: thanks. will using a newtype have an impact on performance?
15:53:32 <jmcarthur> shirt: no
15:53:32 <cvii> Amoeba1: yes
15:53:39 <Amoeba1> Thanks cvii.
15:53:43 <argiopeweb> And it works in the Emacs haskell-mode terminal, which is all kinds of neat.
15:53:54 <jmcarthur> argiopeweb: you already said that ;)
15:54:13 <argiopeweb> Whoops... Hit <up-arrow> enter in my terminal, and it wasn't my terminal. :\
15:54:27 <argiopeweb> Silly xmonad.
15:54:31 <cvii> ["A","m","e","b","a"]
15:54:45 <argiopeweb> cvii: That's a [[Char]]...
15:55:08 <plhk> cvii: ['A','m','e','b','a']
15:55:11 <cvii> oh right
15:55:14 <Amoeba1> ['a','m','e','b','a']
15:56:09 <booski> Could someone remind functional version of `if'?
15:56:55 <startling> booski: if x then y else z
15:57:13 <startling> if you want a function, if' x y z = if x then y else z
15:57:27 <booski> startling: if', thanks!
15:59:40 <startling> so there's no way to use quickcheck with detailed-1.0 in cabal? :( It seems like it'd be as simple as Testable prop => prop -> Test
16:06:10 <shirt> jmcarthur: hm... i'm using Dara.Array.Unboxed, not Data.Vector.Unboxed
16:06:30 <dsantiago> What's the difference between Vector and Array?
16:06:39 <jmcarthur> shirt: ah!
16:07:13 <hiptobecubic> That question should really be in a FAQ somewhere
16:07:37 <argiopeweb> I saw the answer on SO yesterday... Let me see if I can find it (seems easier than summarizing).
16:08:22 <shirt> I need to represent a 2D grid, so i'm using Array. Vector seems to only support a single Int index
16:08:30 <Cale> dsantiago: Vector is newer, and does a bunch of stream fusion stuff, but it also lacks the nice indexing interface that Array has. For the most part it's better though.
16:08:53 <argiopeweb> shirt: Array and Repa are your best choices for out of the box multi-dimensional arrays.
16:09:04 <xenocons> :t `elem`
16:09:08 <cvii> is there anything similar to haskel-on-a-horse, active if possible?
16:09:12 <xenocons> oh right
16:09:13 <xenocons> no lambdabot
16:09:16 <Cale> oh
16:09:19 <Cale> I can fix that :)
16:09:23 <argiopeweb> Repa == multi-dimensional Vector.
16:09:37 <jmcarthur> repa doesn't have all the functionality one might need for multidimensional arrays, unfortunately
16:09:37 <shirt> argiopeweb: Array is regular Data.Array?
16:09:43 <dsantiago> Cale: Thanks.
16:09:47 <jmcarthur> for example, mutable multidimensional arrays
16:09:59 <argiopeweb> shirt: Correct.
16:10:00 <dsantiago> And are these persistent or they copy an entire new array?
16:10:15 <Cale> dsantiago: both?
16:10:17 <jmcarthur> dsantiago: those are the same thing ;)
16:10:18 <cmccann> it would not be terribly difficult to use the same Ix stuff Array does to calculate an index to use with Vector
16:10:28 <jmcarthur> dsantiago: there are mutable and immutable versions, though
16:10:45 <cmccann> but I don't think that's really the primary purpose of Vector
16:10:47 <dsantiago> That is true… what I meant was, are they hash-mapped array trees or whatever they're called?
16:11:05 <jmcarthur> dsantiago: to make sure i'm not muddying the waters too much, a persistent data structure is an immutable one, not a mutable one
16:11:06 <argiopeweb> jmcarthur: True, for mutable arrays you still need Data.Array. Are mutable Arrays appreciably faster than Repa arrays?
16:11:19 <c_wraith> Ix seems overcomplicated for just "I want multiple dimensions."
16:11:25 <jmcarthur> argiopeweb: it depends on your algorithm
16:11:57 <jrajav> Has anyone compared Mathematica's expression rewriting and rule-based programming to Haskell?
16:12:13 <shirt> hm... is Data.Vector.Unboxed significantly faster than Data.Array.Unboxed?
16:12:47 <cmccann> why is using Ix overcomplicated? the instances you'd need are already there.
16:13:03 <argiopeweb> shirt: My understanding is that, once you factor in stream fusion it's faster. Can't pull any statistics on that though...
16:13:04 <cmccann> not like you have to use a weird indexing scheme if you don't want to.
16:14:58 <c_wraith> mostly that Ix supports arbitrary offset indexing. It may have everything you'd want already, but it has more than I'd want, and enough to add some real overhead to index calculations.
16:15:24 <Cale> Yeah, if I was using Vector to try to get multidimensional arrays, I would definitely use Ix
16:15:46 <Cale> Because all the operations you'd need are already implemented there, it's just you'd have to use them explicitly to calculate indexes
16:15:55 <Cale> but that's better than writing out the formula by hand
16:16:09 <cmccann> eh, I figure that if performance of calculating index offsets is a serious concern you're doing something where there is no single generic answer
16:17:20 <xenocons> is using a predicate inside list comprehension more efficient than filter?
16:17:31 <cmccann> calculating offsets is not going to be a performance bottleneck in most situations
16:18:36 <c_wraith> xenocons: should be identical
16:18:46 <xenocons> hmm
16:18:57 <c_wraith> xenocons: unless the comprehension has multiple generators, and you apply the predicate before one of the generators
16:19:04 <xenocons> ah right
16:19:30 <xenocons> so with a predicate, the list gets created, then the predicate is applied?
16:19:41 <xenocons> (same as filter)
16:20:11 <c_wraith> well, yes and no.  It's applied to each element individually, the same as filter.
16:20:27 <c_wraith> But because of laziness, it doesn't mean that the whole input is generated first
16:20:28 <cmccann> xenocons, it's not necessarily that simple, because the list will be computed only on demand
16:20:39 <xenocons> right, just to lazyness
16:20:50 <xenocons> due*
16:21:00 <xenocons> sorry, laziness, i always mis=spell that
16:21:42 <xenocons> hm i really like `elem` heh
16:22:48 <xenocons> wondering about its complexity though
16:22:51 <cmccann> it's better to think about how many elements will be tested or inspected somehow, rather than what gets "created" and when
16:23:29 <xenocons> if you filter into `elem`, i figure this is equivilant to for list do for elem
16:23:52 <xenocons> like filter (`elem` "aeiou") "this is my sentence"
16:24:21 <pqmodn> @src elem
16:24:21 <lambdabot> elem x    =  any (== x)
16:24:26 <xenocons> interesting this feels so much cleaner than how i would normally think about this problem
16:24:40 <xenocons> oh cool, can i use @src from ghci?
16:24:46 <cmccann> no
16:24:50 <cmccann> that's a lambdabot thing
16:24:50 <xenocons> :<
16:24:56 <cmccann> you can /msg lambdabot though
16:25:03 <xenocons> okay cool
16:25:35 <cmccann> (you can also run your own lambdabot locally but last I heard that was... awkward)
16:26:49 <lambdabot> totally awkward
16:26:54 <pqmodn> heh
16:28:23 * FireFly wonders who's possessing lambdabot
16:28:53 <hiptobecubic> I have a lambdabot locally. It's not as useful as i'd hoped
16:30:05 <xenocons> @src any
16:30:06 <lambdabot> any p =  or . map p
16:30:45 <cmccann> I love how much of the prelude is "one-liner using a couple other Prelude functions"
16:31:39 <Taslem> Is ++ concat constant-time or linear-time?
16:31:57 <sclv> linear time in the length of the first argument
16:31:57 <Cale> I love how much stuff isn't in the Prelude or Data.List because it is already a one liner of that sort. :)
16:31:59 <shachaf> Linear in the length of the first argument.
16:32:23 <sclv> love the haskell stereophonic effect
16:32:23 <cmccann> alternately, it's constant time after you force the first argument in linear time for some other reason :P
16:32:31 <Cale> Yeah, reducing xs ++ ys fully takes O(length xs) steps
16:32:34 <Cale> @src (++)
16:32:35 <lambdabot> []     ++ ys = ys
16:32:35 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
16:32:35 <lambdabot> -- OR
16:32:35 <lambdabot> xs ++ ys = foldr (:) ys xs
16:32:46 <Cale> you can see that from the recursive definition of (++)
16:33:37 <Cale> Of course, taking the first element of (xs ++ ys) can be done in constant time.
16:33:40 <hpaste> sw2wolf pasted “cannot install xmonad-eval” at http://hpaste.org/78606
16:33:50 <xenocons> @src or
16:33:50 <lambdabot> or    =  foldr (||) False
16:33:59 <xenocons> oh thats interesting
16:34:21 <hiptobecubic> Yeah I thought ++ actually wasn't so bad if you were doing the usual "eat the list one elements at a time" approach
16:34:33 <Cale> A single (++) is not bad
16:34:40 <sclv> @src Bool
16:34:41 <lambdabot> data Bool = False | True deriving (Eq, Ord)
16:34:55 <Cale> What's bad is where you have a bunch of (++)'s which add a small number of elements at a time to the end of a list which is being built up
16:35:03 <Jesin> doesn't it also do Read, Show
16:35:04 <Taslem> Yeah, that's what I figured.
16:35:12 <DMcGill> @info (++)
16:35:12 <lambdabot> (++)
16:35:18 <cmccann> thanks lambdabot
16:35:20 <Taslem> So, is it ever a problem so long as you only concat smaller lists to the beginning of an accumulatingly larger one?
16:35:21 <xenocons> lol
16:35:21 <Jesin> @src (++)
16:35:21 <lambdabot> []     ++ ys = ys
16:35:22 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
16:35:22 <lambdabot> -- OR
16:35:22 <lambdabot> xs ++ ys = foldr (:) ys xs
16:35:29 <Cale> That results in linear time for the first element (have to dig through n (++)'s), and quadratic time overall.
16:35:33 <hiptobecubic> Cale, but a ++ b ++ c? If you are consuming it one element at a time, starting from head, why is it an issue?
16:35:34 <DMcGill> (++) is infixr 5
16:35:50 <cmccann> if your (++) uses are right-nested it shouldn't be too bad, I'd think?
16:35:52 <Cale> hiptobecubic: a ++ (b ++ c) is more efficient than (a ++ b) ++ c
16:36:16 <pqmodn> @src concat
16:36:16 <lambdabot> concat = foldr (++) []
16:36:20 <hiptobecubic> Cale, but it's infixr right? so it should be ok?
16:36:29 <cmccann> it's infixr
16:36:36 <Cale> hiptobecubic: But the fixity doesn't matter if you're using it recursively
16:36:45 <monochrom> haha
16:36:47 <Cale> and there's only one actual ++ in your expression
16:36:54 <cmccann> the problem is if you're appending manually to the result of some previous appends
16:36:55 <Jesin> what expression is this?
16:37:00 <Jesin> ...yeah that's a problem
16:37:05 <cmccann> which is not an uncommon scenario
16:37:15 <Taslem> So, a ++ (b ++ c) is good, (a ++ b) ++ c is bad.
16:37:29 <DMcGill> using StringS is better
16:37:35 <Cale> Let's say something like   foo 0 = []; foo n = foo (n-1) ++ [n] -- this will be horrid
16:37:42 <Jesin> hiptobecubic: "infixr" only tells you how something is *parsed* when you leave out the parentheses
16:38:19 <Cale> When you run into this situation, you can often do a trick where you replace lists of type [a] with functions [a] -> [a] that add elements to the beginning of their list parameter
16:38:24 <Cale> [] becomes id
16:38:25 <cmccann> it does mean that an expression like "x ++ y ++ z" &c. will be computed in the less horrible way
16:38:29 <Cale> [x] becomes (x:)
16:38:33 <Cale> (++) becomes (.)
16:38:35 <hiptobecubic> crazy
16:38:39 <xenocons> i dont reallly understand foldr (||) False
16:38:40 <DMcGill> see: StringS
16:38:43 <cmccann> but I personally prefer using concat instead of lots of (++)
16:38:51 <DMcGill> :t StringS
16:38:52 <lambdabot> Not in scope: data constructor `StringS'
16:38:53 <Cale> since (.) is O(1) time, this will replace a linear time operation with a constant time one
16:38:54 <DMcGill> :t shows
16:38:56 <lambdabot> Show a => a -> ShowS
16:38:57 <monochrom> > foldr (||) False (repeat True)
16:38:58 <lambdabot>   True
16:39:04 <hiptobecubic> > foldr f 0 [x,y,z]
16:39:04 <Cale> and you'll get better performance :)
16:39:05 <lambdabot>   Ambiguous type variable `a0' in the constraints:
16:39:05 <lambdabot>    (GHC.Num.Num a0)
16:39:05 <lambdabot>      a...
16:39:06 <Taslem> xenocons: For [a,b,c,d] that's like doing False || a || b || c || d
16:39:10 <hiptobecubic> > foldr f 0 [x,y,z] :: Expr
16:39:12 <lambdabot>   f x (f y (f z 0))
16:39:18 <xenocons> ah
16:39:20 <Cale> you can then apply the function to the empty list at the end
16:39:29 <Taslem> How about representing lists as functions as Int -> a?
16:39:35 <monochrom> no, it's foldr not foldl, a || (b || (c || (d || False)))
16:39:51 * cmccann notes that (||) is infixr as well
16:39:53 <Cale> Taslem: hmm
16:39:58 <Taslem> So that [a] is (const a) and (x : z) is (\i -> if i == 0 then x else z (i-1))?
16:40:14 <Taslem> And if you annotate them with length could you also make ++ constant in this manner?
16:40:39 <Cale> Taslem: That can work, but indexes are usually something which is avoided as much as possible
16:40:41 <BMeph> Taslem: You mean 'repeat a' would be 'const a', right? ;)
16:40:47 <monochrom> so many falsehoods in a few minutes
16:40:51 <eikke> > or $ repeat True
16:40:52 <lambdabot>   True
16:40:57 <eikke> > or $ repeat False
16:41:03 <lambdabot>   mueval: ExitFailure 1
16:41:03 <lambdabot>  mueval: Prelude.undefined
16:41:09 <eikke> oh silly me, confusing or and and
16:41:33 <Taslem> So that (++) (x, xl) (y, yl) i = if i < xl then x i else y (i-xl)
16:41:52 <Jesin> Taslem: that also gives space leaks unless you're careful for stuff like "tail xs"
16:41:59 <Taslem> Yeah, that's what I figured.
16:41:59 <DMcGill> yeah, wouldn't the recursive version of 'or' be better as it can short circuit?
16:42:10 <monochrom> @src or
16:42:10 <lambdabot> or    =  foldr (||) False
16:42:14 <Taslem> It could also give you up to linear time get operations if you kept nesting.
16:42:20 <Jesin> DMcGill: umm, the foldr version does short-circuit
16:42:22 <cmccann> what makes you think or doesn't short circuit as is?
16:42:22 <Jesin> @src foldr
16:42:23 <lambdabot> foldr f z []     = z
16:42:23 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
16:42:26 <Taslem> [a] ++ [b] ++ [c] ++ [d] ++ [e] would be O(N) to get the last element.
16:42:35 <xenocons> what was that foldl vs foldr rule of thumb regarding laziness again (im going to get a notepad of stuff now)
16:42:45 <cmccann> Taslem, it's O(N) to get the last element of any list though :P
16:42:56 <DMcGill> oh yeah, sorry
16:43:06 <Cale> Taslem: Using lists in the first place is like saying "I plan to iterate over these things in order"
16:43:07 <typoclass> xenocons: either foldr or foldl', don't use foldl ?
16:43:17 <DMcGill> would then a version using foldl not short circuit?
16:43:21 <monochrom> foldr and foldl don't even do the same thing
16:43:26 <Taslem> Isn't !! constant time if the list is forced already?
16:43:30 <Cale> So operations which act on indices are somewhat unnatural
16:43:32 <mgsloan> > let alphas = map concat $ sequence ["":alphas, map (:[]) ['a'..'z']] in alphas
16:43:33 <lambdabot>   ["a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s...
16:43:34 <typoclass> xenocons: see also http://www.haskell.org/haskellwiki/Foldr_Foldl_Foldl'
16:43:36 <Cale> especially (!!)
16:43:41 <mgsloan> can anyone golf this down further?
16:43:41 <Cale> Taslem: no
16:43:41 <Nereid> Taslem: no
16:43:41 <Jesin> foldr and foldl only do the same thing when their operator is associative
16:43:44 <monochrom> ask what's the rule of thumb for id vs succ regarding laziness
16:43:46 <Cale> xs !! n is O(n) time
16:43:49 <Cale> always
16:43:50 <Nereid> Jesin: and the list is finite
16:43:53 <xenocons> right
16:43:55 <mgsloan> > let alphas = map concat $ sequence ["":alphas, map (:[]) ['a'..'c']] in alphas
16:43:56 <lambdabot>   ["a","b","c","aa","ab","ac","ba","bb","bc","ca","cb","cc","aaa","aab","aac"...
16:43:58 <xenocons> typoclass: ty thats a good reference
16:44:15 <Jesin> ah, Nereid is right about that too.
16:44:38 <DMcGill> > filterM (const [True, False]) ['a'..'c']
16:44:40 <lambdabot>   ["abc","ab","ac","a","bc","b","c",""]
16:44:51 <DMcGill> hmm, not quite what you asked
16:44:58 <Nereid> > filterM (const [False,True]) ['1'..]
16:45:00 <lambdabot>   *Exception: stack overflow
16:45:02 <Nereid> aww
16:45:06 <Nereid> well duh
16:45:21 <mgsloan> DMcGill: That's cool!! Yeah, not quite :)  I'd prefer it to be infinite
16:45:59 <Jesin> mgsloan: you want an infinite list of what again?
16:46:10 <mgsloan> like excel column labels
16:46:22 <mgsloan> "a" to "z", then "aa", "ab", etc
16:46:35 <Jesin> oh
16:46:58 <xenocons> typoclass: question: how did the author display the expansion of the expressions like that?
16:47:06 <mgsloan> I've got a fine function, but it seems like there ought to be a more compact one (not that it really matters)
16:47:09 <xenocons> manually or is there some ghci command
16:47:12 <typoclass> xenocons: beats me
16:47:33 <DMcGill> > let list = ['a'..'z'] in iterate (list:) [list]
16:47:34 <lambdabot>   [["abcdefghijklmnopqrstuvwxyz"],["abcdefghijklmnopqrstuvwxyz","abcdefghijkl...
16:48:09 <`nand`> > forM [0..] replicateM ['a'..'z']
16:48:11 <lambdabot>   [[""],["a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q",...
16:48:35 <mgsloan> > forM [0..] replicateM ['a'..'c']
16:48:36 <lambdabot>   [[""],["a","b","c"],["aa","ab","ac","ba","bb","bc","ca","cb","cc"],["aaa","...
16:48:43 <mgsloan> `nand`++
16:48:56 <mgsloan> thanks!! :D
16:48:56 <pqmodn> > subsequences ['a'..'z']
16:48:58 <lambdabot>   ["","a","b","ab","c","ac","bc","abc","d","ad","bd","abd","cd","acd","bcd","...
16:49:03 <mgsloan> whaaat
16:49:21 <`nand`> > [0..] >>= flip replicateM "abc"
16:49:23 <lambdabot>   ["","a","b","c","aa","ab","ac","ba","bb","bc","ca","cb","cc","aaa","aab","a...
16:49:26 <mgsloan> well that's new to me
16:49:37 <mgsloan> pqmodn++ too
16:49:54 <`nand`> subsequences excludes "aa"
16:50:03 <pqmodn> hmm, yes it does
16:50:23 <mgsloan> not a big deal
16:50:24 <xenocons> cool
16:50:37 <Nereid> hm, showIntAtBase doesn't quite do it
16:50:45 <`nand`> hehe
16:50:46 <pqmodn> i was just thinking that...
16:50:55 <mgsloan> I just want a bunch of unique names
16:51:20 <Nereid> > map (\x -> showIntAtBase 26 (chr . (+65)) x []) [1..]
16:51:22 <lambdabot>   ["B","C","D","E","F","G","H","I","J","K","L","M","N","O","P","Q","R","S","T...
16:51:33 <Nereid> > concat $ map (\x -> showIntAtBase 26 (chr . (+65)) x []) [1..]
16:51:35 <lambdabot>   "BCDEFGHIJKLMNOPQRSTUVWXYZBABBBCBDBEBFBGBHBIBJBKBLBMBNBOBPBQBRBSBTBUBVBWBXB...
16:51:48 <`nand`> > let showAtBase b n = ([0..] >>= flip replicateM b) !! n in [showAtBase "0123456789ABCDEF" 12345, showAtBase "abc" 12345]
16:51:48 <Nereid> yeah that's missing things.
16:51:50 <lambdabot>   ["1F28","ababaccac"]
16:51:55 <`nand`> > 0x1F28
16:51:56 <lambdabot>   7976
16:51:59 <`nand`> :(
16:52:16 <`nand`> oh
16:52:24 <Nereid> that looks wrong.
16:52:29 <`nand`> no, that's not quite the same thing; since it counts ‘00’ as coming after ‘9’
16:52:36 <BMeph> > concat $ map (\x -> showIntAtBase 26 (chr . (+89)) x []) [1..]
16:52:38 <Nereid> how does it even.
16:52:38 <lambdabot>   "Z[\\]^_`abcdefghijklmnopqrZYZZZ[Z\\Z]Z^Z_Z`ZaZbZcZdZeZfZgZhZiZjZkZlZmZnZoZ...
16:52:39 <Nereid> ohh.
16:52:59 <BMeph> > concat $ map (\x -> showIntAtBase 26 (chr . (+96)) x []) [1..]
16:53:01 <lambdabot>   "abcdefghijklmnopqrstuvwxya`aaabacadaeafagahaiajakalamanaoapaqarasatauavawa...
16:53:06 <Nereid> `nand`: but we want that.
16:53:09 <sw2wolf> What are you doing ? show your haskell skill? it will make software hard to maintain ,right ?
16:53:32 <Nereid> > let showAtBase b n = ([0..] >>= flip replicateM b) !! n in map (showAtBase ['a'..'z']) [0..]
16:53:34 <lambdabot>   ["","a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r"...
16:53:42 <Nereid> > let showAtBase b n = ([0..] >>= flip replicateM b) !! n in concat $ map (showAtBase ['a'..'z']) [1..]
16:53:44 <lambdabot>   "abcdefghijklmnopqrstuvwxyzaaabacadaeafagahaiajakalamanaoapaqarasatauavawax...
16:54:08 <Nereid> > let showAtBase b n = ([0..] >>= flip replicateM b) !! n in map (showAtBase ['a'..'z']) [700..]
16:54:10 <lambdabot>   ["zx","zy","zz","aaa","aab","aac","aad","aae","aaf","aag","aah","aai","aaj"...
16:54:11 <Taslem> > let f 0 list = map (:[]) list; f n list = concat $ map (\u -> map (u :) $ f (n-1) list) list; every list = concat $ map (\k -> f k list) [0..] in every "abc"
16:54:12 <lambdabot>   ["a","b","c","aa","ab","ac","ba","bb","bc","ca","cb","cc","aaa","aab","aac"...
16:54:22 <`nand`> :t startsWith
16:54:24 <lambdabot> Eq a => [a] -> Splitter a
16:54:26 <Taslem> I think my method works.
16:54:30 <Taslem> Though I don't think it's fast.
16:54:43 <Jesin> I still kinda like
16:54:43 <Jesin> let alphas = map concat $ sequence ["":alphas, map (:[]) ['a'..'z']] in alphas
16:55:00 <Taslem>  >let alphas = map concat $ sequence ["":alphas, map (:[]) ['a'..'z']] in alphas
16:55:20 <`nand`> showAtBase should be implementable in terms of the replicateM thing if you filter all of the elements that start with “zero”, I guess. But at that point it already lost its elegance
16:55:26 <Nereid> > let showAtBase b n = ([0..] >>= flip replicateM b) !! n in map (showAtBase ['a'..'b']) [1..]
16:55:28 <lambdabot>   ["a","b","aa","ab","ba","bb","aaa","aab","aba","abb","baa","bab","bba","bbb...
16:55:55 <mgsloan> Jesin: Yeah, that one's nice.  But since I don't need actual column names, I'm gonna use subsequence
16:55:57 <Nereid> `nand`: yeah but this one works nicely for mgsloan
16:56:06 <Nereid> oh why are we doing this dumb thing
16:56:20 <Nereid> > [0..] >>= flip replicateM "ab"
16:56:22 <lambdabot>   ["","a","b","aa","ab","ba","bb","aaa","aab","aba","abb","baa","bab","bba","...
16:56:28 <mgsloan> Nereid: everyone loves a golf battle, right? :)
16:56:31 <Nereid> :)
16:56:42 <`nand`> oh, this is a golf battle? give me a moment to cook something up
16:56:48 <romildo> I need to generate an (static) html page in Haskell. Which package is recommended for that?
16:56:58 <Nereid> romildo: a text editor
16:57:08 <Nereid> :p
16:57:19 <byorgey> romildo: hakyll
16:57:28 <`nand`> on second though, I can't think of a way to do this with lenses
16:57:34 <`nand`> thought*
16:57:41 <mgsloan> Nereid: that one's pretty darn nice, if surprising
16:57:42 <Nereid> yeah I don't see how you'd fit lenses here
16:58:04 <romildo> Nereid, By static I meant it does not interact with the user to generate contents. But of course the generated page depends on data supplied by  my program.
16:58:14 <byorgey> romildo: wait, sorry, I need more information.  Do you mean you want to build a website?  Or you mean you want to actually have control over the precise HTML that is generated/
16:58:27 <byorgey> romildo: if the latter, maybe try blaze-html
16:59:08 <romildo> byorgey, I want to present some data in HTML format.
16:59:25 <`nand`> there's something like ‘blaze-html’ whi-- oh, byorgey already mentioned it
16:59:26 <romildo> byorgey, it will not be a website.
16:59:27 <Nereid> mgsloan: ah yeah, replicateM n "ab" generates all sequences of a and b of length n
16:59:30 <byorgey> romildo: ok, right. Then use blaze-html.
16:59:50 <`nand`> blaze-html is just a library for generating HTML text; no matter what you want to do with it
17:00:17 <`nand`> Nereid: here's a nice one
17:00:23 <`nand`> or ugly, depending on your viewpoint
17:00:34 <Nereid> things can be simultaneous nice and ugly
17:00:36 <Nereid> simultaneously.
17:00:44 <edwardk> > [0..]^!act (>>= flip replicateM "ab")
17:00:47 <lambdabot>   ["","a","b","aa","ab","ba","bb","aaa","aab","aba","abb","baa","bab","bba","...
17:00:48 <edwardk> =)
17:00:52 <`nand`> > replicateM 8 "0123456789ABCDEF" !! 3735928559
17:00:58 <lambdabot>   mueval: ExitFailure 1
17:00:58 <lambdabot>  mueval: Prelude.undefined
17:01:05 <`nand`> oh, that one was a bit large, wasn't it?
17:01:12 <Nereid> haha yes.
17:01:16 <`nand`> > replicateM 8 "0123456789ABCDEF" !! 57005
17:01:20 <lambdabot>   mueval-core: Time limit exceeded
17:01:27 <`nand`> > replicateM 8 "0123456789ABCDEF" !! 255
17:01:30 <lambdabot>   "000000FF"
17:01:36 <edwardk> the fact that you use context to determine what to do next kind of rules out most lens combinators
17:01:45 <Nereid> it wouldn't be efficient at all for getting the representation of a *specific* number
17:02:09 <`nand`> > showIntAtBase 16 3735928559
17:02:11 <lambdabot>   No instance for (GHC.Num.Num GHC.Types.Char)
17:02:11 <lambdabot>    arising from the literal `3...
17:02:24 <`nand`> :t showIntAtBase
17:02:27 <lambdabot> (Integral a, Show a) => a -> (Int -> Char) -> a -> ShowS
17:02:30 <`nand`> ah
17:02:49 <`nand`> where's the Int -> Char for hex digits?
17:03:05 <pqmodn> @where showIntAtBase
17:03:05 <lambdabot> I know nothing about showintatbase.
17:03:28 <Nereid> it's in Numeric
17:03:32 <`nand`> > showIntAtBase 16 intToDigit 3735928559
17:03:34 <lambdabot>   *Exception: show: No overloading for function
17:03:47 <pqmodn> :t showHex
17:03:49 <lambdabot> (Integral a, Show a) => a -> ShowS
17:03:52 <Nereid> :t intToDigit
17:03:53 <lambdabot> Int -> Char
17:03:56 <`nand`> > showIntAtBase 16 intToDigit 3735928559 ""
17:03:57 <lambdabot>   "deadbeef"
17:03:59 <Nereid> yeah
17:04:32 <Nereid> > intToDigit 16
17:04:34 <lambdabot>   *Exception: Char.intToDigit: not a digit 16
17:04:35 <Nereid> aw.
17:04:59 <Nereid> should allow up to 36.
17:05:02 <Nereid> er 35
17:05:06 <ion> yeah :-\
17:05:21 <Mortchek> Also require a base
17:05:50 <mm21> edwardk: was is [0..]^!act
17:05:57 <mm21> *what
17:06:00 <Nereid> :t (^!)
17:06:02 <lambdabot> Monad m => s -> Acting m a s t a b -> m a
17:06:11 <Nereid> guess that doesn't mean anything to most people.
17:06:13 <Mortchek> Don't stab ma :(
17:06:33 <xenocons> i saw masterbate
17:06:43 <edwardk> mm21: its an abuse of a lens combinator. not a serious suggestion
17:06:51 <mm21> Nereid: i checked the type already but does not get it
17:07:01 <`nand`> x ^! act y = y x --, no?
17:07:03 <edwardk> (^!) can be used to run an action inside a monad.
17:07:13 <xenocons> i just successfully stole `elem`
17:07:26 <`nand`> similar to x ^. to y
17:07:26 <elliott> x ^! act = join, I think?
17:07:29 <edwardk> its for getters with side-effects
17:07:31 <Nereid> :t ?x ^! act ?y
17:07:32 <edwardk> :t acts
17:07:32 <lambdabot> (?x::t, ?y::t -> m b, Monad m) => m b
17:07:33 <lambdabot> Control.Lens.Classes.Effective m r f => (a -> f a) -> m a -> f (m a)
17:08:02 <edwardk> elliott: you're thinking acts, which is the join for actions.
17:08:33 <edwardk> :t ?x^!acts
17:08:35 <lambdabot> (?x::m b, Monad m) => m b
17:08:45 <Nereid> :t ?x ^! folded . act ?y
17:08:46 <lambdabot> (?x::f a, ?y::a -> m b, Monad m, Foldable f, Monoid b) => m b
17:08:52 <`nand`> :t ?x^.acts
17:08:53 <lambdabot> (?x::Identity b) => b
17:09:14 <mm21> ok these ? makes it even more mysterious :)
17:09:16 <xenocons> ('a -> 'a seq -> bool) when 'a : equality, i think thats the same as Eq a => a -> [a] -> Bool
17:09:27 <edwardk> mm21: i don't recommend starting to learn 'lens' by way of 'Action' ;)
17:09:30 <cmccann> "s t a b" are always great type parameter names
17:09:40 <Nereid> yes, excellent choice
17:09:47 <xenocons> i like s and a but not t and b
17:09:55 * `nand` is still waiting for Getting s t a b b e d
17:09:56 <cmccann> though "f a b" is also nice
17:10:03 <elliott> edwardk: right
17:10:10 <latro`a> lol `nand`
17:10:15 <xenocons> f a b i use too much
17:10:22 <edwardk> (^!) takes a value and a rap artist (Acting Masta B).
17:10:29 <edwardk> :t (^!)
17:10:29 <elliott> xenocons: depends what you mean by "'a : equality"
17:10:31 <lambdabot> Monad m => s -> Acting m a s t a b -> m a
17:10:33 <mm21> edwardk: i glimpsed at lens already, but i guess that were just 10% of it :)
17:10:41 <cmccann> heh
17:11:07 <xenocons> elliott: i stole it like: let ``elem`` e = Seq.exists ((=) e)
17:11:14 <gertc> https://github.com/MichaelXavier/GooglePlus/blob/master/Web/GooglePlus/Monad.hs why do they put a data type in a data type in yet a other data type here?
17:11:15 <`nand`> depends on which version of lens; that figure is expected to drop rapidly as the version numbers goes towards infinity
17:11:17 <xenocons> seems to be close enough to `elem`
17:11:18 <edwardk> mm21: the original intention of adding Actions was so that you could define something that worked like a Getter that had a monadic side-effect
17:11:41 <mm21> ahh i see
17:11:50 <`nand`> :t mapMOf
17:11:51 <lambdabot> LensLike (WrappedMonad m) s t a b -> (a -> m b) -> s -> m t
17:12:16 <`nand`> useful for that too
17:12:28 <edwardk> mm21: the nice thing about actions is they compose with arbitrary getters and traversals and folds, etc. and just become a bigger action or a monadic fold you can run
17:12:48 <edwardk> mm21: so you aren't constantly dropping out to use >>= or trying to remember if something has a side -effect
17:12:53 <edwardk> kleisli composition of actions is just (.)
17:12:59 <gertc> cant they skip data GooglePlusEnv en just put GooglePlusAuth in newtype GooglePlusM ?
17:13:04 <edwardk> :t acts.acts
17:13:05 <lambdabot> Control.Lens.Classes.Effective m r f => (a -> f a) -> m (m a) -> f (m (m a))
17:13:34 * cmccann wonders what edwardk's high score is for "number of parameters to a type constructor"
17:14:41 <edwardk> :t act readFile.act putStrLn
17:14:43 <lambdabot> Control.Lens.Classes.Effective IO r f => (() -> f ()) -> FilePath -> f FilePath
17:15:02 <edwardk> "foo"^.act readFile.act putStrLn  -- could be used for instance
17:15:06 <edwardk> er ^!act
17:15:21 <`nand`> > (["foo","bar"], ("bat", ["baz","barbat"])) ^! biplate . act putStrLn
17:15:23 <lambdabot>   No instance for (GHC.Show.Show (GHC.Types.IO ()))
17:15:23 <lambdabot>    arising from a use of ...
17:15:32 <`nand`> oh, that instance disappeared?
17:15:50 <edwardk> :t (["foo","bar"], ("bat", ["baz","barbat"])) ^! biplate . act putStrLn
17:15:51 <lambdabot> IO ()
17:16:10 <xenocons> is () unit
17:16:31 <beaky> hello
17:16:34 <mm21> readFile.act? is that with CPP?
17:16:51 <beaky> besides haskell and ML and agda, what other programming languages have pattern matching?
17:16:57 <Nereid> (act readFile) . (act putStrLn)
17:17:08 <xenocons> beaky: Rust
17:17:10 <mm21> hehe oh
17:17:14 <`nand`> edwardk: I still like this example
17:17:16 <`nand`> main = "file" ^! act readFile.byLines.to capital.act putStrLn
17:17:18 <`nand`>   where capital = byWords._head %~ toUpper
17:17:40 <edwardk> eh
17:17:45 <elliott> you don't need the to there, do you
17:17:48 <elliott> oh
17:17:49 <elliott> I guess you do
17:17:52 <xenocons> beaky: http://dl.rust-lang.org/doc/tutorial.html#control-structures
17:17:55 <elliott> or do you
17:17:58 <Nereid> you do
17:18:11 <edwardk> he does because the capital is using a lens, not a getter in its own right
17:18:13 <beaky> ah
17:18:24 <beaky> is rust more powerful than haskell?
17:18:35 <edwardk> beaky: yes, we've all been wasting our time
17:18:36 <mm21> Nereid: thx i'm not used to . without spaces around it
17:18:41 <Nereid> heh
17:19:40 <beaky> rust is a pretty new language
17:20:29 <edwardk> `nand`: re your earlier comment about how his understanding is going to drop off as the version numbers head to infinity, look at that sharp drop off in activity: (["foo","bar"], ("bat", ["baz","barbat"])) ^! biplate . act putStrLn clearly it will last
17:20:30 <beaky> if Haskell didn't have typeclasses, how would we solve the expression problem in haskell?
17:20:31 <edwardk> er
17:20:35 <edwardk> https://github.com/ekmett/lens/graphs/code-frequency
17:21:04 <beaky> I guess with higher-order functions
17:21:05 <ion> Aww, lens is dead. Again.
17:21:08 <beaky> and algebraic datatypes
17:21:24 <edwardk> haskell without typeclasses leads to many new ways to tackle the expression problem. it leads me to express sadness, depression, ...
17:21:37 <beaky> haha
17:21:40 <Maxdamantus> Wonder if it'd be reasonabel to've allowed class instances inside expressions.
17:21:41 <Nereid> you could still do explicit dictionary piassing!
17:21:45 <Maxdamantus> reasonable*
17:21:58 <xenocons> there are 'traits' too
17:22:04 <xenocons> im not entirely sure how they related to typclassing
17:22:14 <cmccann> if Haskell didn't have typeclasses ot wpi;dm
17:22:15 <cmccann> ergh
17:22:20 <cmccann> wouldn't really be haskell
17:22:30 <ion> ot wpi;dm indeed.
17:22:32 <cmccann> stupid keyboard
17:22:33 <Nereid> cmccann: I've never done that starting from the middle of a line.
17:22:46 <elliott> cmccann: it looks like you just gave up explaining half-way through in anger at the very idea of a haskell without typeclasses
17:22:53 <cmccann> my keyboard is not very stable and I wasn't looking at what I was typing :[
17:23:09 <cmccann> elliott, that works too I guess
17:23:16 <ion> Does it suffer from macro-scale quantum effects?
17:23:16 <hiptobecubic> i like the first explanation
17:23:19 <Nereid> https://github.com/ekmett/lens/graphs/punch-card heh, there's been something almost every hour
17:23:39 <xenocons> typeclassing is one of the major attractors for me to learn haskell
17:23:42 <hiptobecubic> edwardk, not a morning person?
17:23:59 <ion> Is the punch card graph generated based on the local time of each commit?
17:24:00 <edwardk> hiptobecubic: oh re commit times?
17:24:07 <hiptobecubic> yes :)
17:24:10 <typoclass> @remember cmccann if Haskell didn't have typeclasses ot wpi;dm
17:24:10 <lambdabot> Nice!
17:24:18 <cmccann> :[
17:24:49 <ion> :[]
17:24:52 <xenocons> but rust is definetly on my to learn list after ive got a bit more comfortable with haskell
17:24:57 <Cale> cmccann: Get a Das Ultimate, then you can't usefully look at the keys :)
17:25:01 <edwardk> hiptobecubic: i have to sleep sometime. and after that i go to work ;)
17:25:01 <wereHamster> The function '..' is applied to two arguments, but its type '...' has two. WTF?
17:25:25 <cmccann> Cale, the problem is that I was looking at neither the keys nor the letters on the screen
17:25:29 <Cale> hah
17:25:32 <wereHamster> thanks captain obvious..
17:25:36 <shachaf> wereHamster: Yep. It's a minor bug.
17:25:39 <edwardk> the spread during a week has been polluted by the fact that i took a week off to work on lens and on my DAE library
17:25:43 <cmccann> wereHamster, that's a beautiful error
17:25:47 <elliott> Cale: das keyboards :(
17:26:09 * elliott cowers at Cale's @, also
17:26:17 <xenocons> i have razr blackwidow kb, one of the best kbs ive ever used
17:26:35 <beaky> nice to see haskell features like typeclasses, monads, and STM trickle down into mainstream languages like C#
17:26:47 <beaky> xenocons: I own that keboard too :D
17:26:56 <xenocons> beaky: hehe
17:27:12 --- mode: Cale set -o Cale
17:27:18 <edwardk> Cale is a tyrant. He rules the channel with an iron fist. If you come in and don't know haskell he'll drag you off to #haskell-overflow and lecture you for hours before letting you back in.
17:27:24 <xenocons> i think you can probably thank erik mejier for the useful components of C#
17:27:33 <Cale> lol
17:27:37 <xenocons> and don syme of course (generics)
17:28:02 <Cale> It was really that I was killing a bunch of bots that someone join-spammed the channel from (all with the same IP address)
17:28:12 <Cale> and then didn't deop
17:28:14 <xenocons> the reason C# got generics is so that F# could be made possible ;) ohhh C# people hate me
17:28:37 <mm21> i'd take lessons from Cale anytime ;)
17:28:43 <ion> I was thinking of using Rust for a project i might want to port to an ARM microcontroller with little memory etc, but it doesn’t support ARM or running on any bare hardware at the moment. Something like C or C++ is too painful, so i decided to forget about the low-spec microcontroller and use Haskell on a Beagle Bone.
17:28:58 <beaky> embedded haskell?
17:29:14 <Cale> I actually really love my Das Ultimate, though the blank keycaps aren't really the important part. I really just love the cherry blue switches.
17:29:16 <kristof> No such thing
17:29:30 <kristof> haskell shouldn't be used for embedded devices
17:29:32 <elliott> maybe they fixed them
17:29:36 <elliott> but the construction was really bad a while ago
17:29:44 <elliott> compared to other mechanical-switch keyboards
17:29:45 <c_wraith> mm21: have you considered using the atom package for haskell? It generates C code appropriate for embedded devices
17:29:59 <Cale> huh, well, this seems quite solidly put together to me
17:30:11 <kristof> Oh, well, there's the atom package.
17:30:23 <xenocons> can atom generate code other than C?
17:31:21 <neutrino> Cale: i wish i could get an affordable clicky keyboard with half-width keys
17:31:39 <xenocons> oh its specifically designed for creating RT embedded software, nice
17:31:39 <Sintendo> is there a simple guide to instancing Read?
17:31:40 <neutrino> half..height, that is.
17:32:37 <xenocons> neutrino: this kb i have, the keys are full sized, but you only need to half press it down to type.. if that makes sense
17:32:54 <johnw> is Niklas Broberg here?
17:33:16 <`nand`> Maxdamantus: allowing that would allow inconsistent instances, no?
17:33:25 <xenocons> cost around 100$
17:33:25 <`nand`> which would be pretty bad for a lot of things
17:34:32 <neutrino> xenocons: let me dig up a link
17:35:42 <xenocons> oh, just googling, this kb uses cherry mx mechanical structure
17:35:47 <xenocons> probably cheaper to just get a cherry heh
17:37:18 <xenocons> http://www.youtube.com/watch?feature=player_detailpage&v=SNkPvDdaS1c#t=105s suffice to say my wife hates it
17:37:56 <neutrino> xenocons: i prefer "lp family": http://i.imgur.com/aw1CG.jpg
17:38:17 <xenocons> oh interesting
17:39:28 <xenocons> you might like MS arc then
17:39:51 <xenocons> i found it good but the lack of proper F keys and directional arrows pissed me off too much
17:40:16 <neutrino> ms arc is 3x lower than lp family
17:40:52 <xenocons> ah
17:41:41 <neutrino> lp family is a "normal" keyboard, arc has a "laptop" keyboard mechanism
17:41:53 <neutrino> it makes it impossible to use modifier keys with your knuckles
17:43:21 <xenocons> heh
17:43:58 <neutrino> currently using a logitech k200 which can be had for about $20 and has no issues, except for having a numpad (need to get a bandsaw)
17:45:35 <Maxdamantus> `nand`: not necessarily.
17:45:47 <Maxdamantus> `nand`: might be a bit messy, but I think that problem exists already.
17:46:43 <`nand`> Maxdamantus: maybe you could show an example of what you're trying to accomplish
17:46:46 <Maxdamantus> Maybe if it allowed you to create a new type and instance dependent on that type.
17:46:59 <Maxdamantus> `nand`: a use of sortBy without sortBy.
17:47:29 <Maxdamantus> I'm not trying to accomplish it .. just wondering if it'd be particularly unreasonable.
17:49:20 <`nand`> maybe you'd be interested in edwardk's ‘reflection’ package
17:49:22 <`nand`> https://github.com/ekmett/reflection/blob/master/examples/Monoid.hs
17:50:02 <Maxdamantus> let newtype T = T Integer; instance Ord T where compare = f in sort . map T
17:50:18 <Maxdamantus> rather than `sortBy f`
17:50:43 <Maxdamantus> (as a more general way to do it)
17:51:30 <Maxdamantus> er, compare (T a) (T b) = f a b
17:53:19 <`nand`> here's a more elaborate example
17:53:21 <`nand`> https://github.com/ekmett/reflection/blob/master/examples/Constraints.hs
17:57:04 <romildo> How can one parse a string into a Text.Blaze.Html.Html ?
17:57:33 <shachaf> I thought Blaze was for generating HTML?
17:57:42 <Nereid> a string containing what? html?
17:58:09 <Nereid> but yes, blaze-html isn't for parsing html
17:58:54 <Nereid> although you can insert your own html fragments with preEscapedToHtml
17:59:09 <`nand`> that makes me wonder; is there a library for parsing potentially broken HTML? (eg. auto-inserting missing closing tags at the necessary places)
17:59:14 <Nereid> tagsoup?
17:59:21 <romildo> I want to generate an html page, containing a small snippet of html which is available as a string. So I need to convert that snippet to Html first.
17:59:35 <Nereid> yes, use preEscapedToHtml
17:59:49 <`nand`> (modern browsers accept all sorts of malformed documents)
17:59:56 <Nereid> `nand`: tagsoup?
18:00:29 <`nand`> Nereid: sounds relevant
18:01:13 <romildo> Nereid, thanks.
18:14:27 <slack1256> when using monad transformer I usually see them using the Monad interface instead of the Applicative
18:14:50 <slack1256> and doing some test on the Applicative interface seems I can only access the outer monad or the value
18:15:24 <slack1256> is it possible to access the inner monad through transformer?
18:17:02 <ion> libsolv might be useful for cabal. https://github.com/openSUSE/libsolv#readme
18:18:26 <hpaste> slack1256 pasted “Applicative Transformers” at http://hpaste.org/78611
18:22:14 <SingingBoyo> I'm having problems getting the sdl-image bindings to build on windows.  it looks like when hsc2hs gets run for Version.hsc, it outputs an empty file.  Anyone run into this before/have any ideas?
18:22:53 <ion> The text in “Copyright” actually adds restrictions to “License: GPL”, doesn’t it? http://hackage.haskell.org/package/sat
18:25:16 * hackagebot base-compat 0.2.0 - Provides readMaybe, lookupEnv, etc. for older versions of base  http://hackage.haskell.org/package/base-compat-0.2.0 (SimonHengel)
18:48:21 <startling> anyone happen to have an example up somewhere using optparse-applicative with many subcommands?
19:00:16 * hackagebot base-compat 0.2.0.1 - A compatibility layer for base  http://hackage.haskell.org/package/base-compat-0.2.0.1 (SimonHengel)
19:00:18 * hackagebot base-compat 0.2.0.2 - A compatibility layer for base  http://hackage.haskell.org/package/base-compat-0.2.0.2 (SimonHengel)
19:14:52 <Shamanoid> I am using ghc to compile my main code file which imports other modules. It however keeps saying module X not found even though it is in the same directory and i've checked for any spelling mistakes 100 times
19:15:41 * mauke eyerolls
19:15:45 <sw2wolf> Shamanoid: How about `ghc --make Main.hs` ?
19:16:01 <mauke> 1) what command are you using?  2) what's the actual output?  3) what output did you expect?
19:17:03 <Shamanoid> sw2wolf: still same error
19:17:14 <sw2wolf> message ?
19:17:30 <geekosaur> inparticular if a module name has a . in it then it will be a / (unix) or \ (windows) in the filesystem
19:17:44 <Shamanoid> mauke: i am using ghc <main.hs>.
19:17:50 <mauke> Shamanoid: 1) what command are you using?  2) what's the actual output?  3) what output did you expect?
19:18:21 <startling> byorgey: is there a way I can specify the separators of boxes right before I render using your "boxes" package? Should I just have all my things give [Box] and then punctuateH at the end?
19:18:23 <ion> 4) what’s your code?
19:18:45 <mauke> Shamanoid: 'ghc <main.hs>.' should result in either '-bash: main.hs: No such file or directory' or '-bash: .: Is a directory'
19:18:46 <pqmodn> 5) use hpaste.org
19:19:34 <Shamanoid> mauke: http://pastebin.com/DX9FbF7i
19:19:37 <mauke> The paste DX9FbF7i has been copied to http://hpaste.org/78612
19:19:48 <Shamanoid> mauke: i mean that i add the main module there
19:19:54 <mauke> Shamanoid: 1) what command are you using?  2) what's the actual output?  3) what output did you expect?
19:20:02 <ion> ls Filters.*
19:20:12 <geekosaur> you have  a "path is here" you arent telling is
19:20:33 <Shamanoid> geekosaur: no the proper path is there
19:20:41 <Shamanoid> geekosaur: that was added by me
19:20:48 <geekosaur> thart was not the point
19:20:49 <ion> Could you please help me? The error is: <error is here>
19:21:09 <mauke> ion: yes, just do <solution here>
19:21:10 <geekosaur> is Filters sourc ein the same dir as Main.hs or is it in the current directory or ???
19:21:11 <Shamanoid> ion:  :(
19:21:19 <ion> mauke: Ah, thanks
19:21:34 <Shamanoid> mauke: thanks. problem solved
19:21:57 <geekosaur> also could you *please* stop trying to remove information from these things?  If it's so sensitive you dare not tell us but it is relevant, then we might not be able to help you at all
19:21:58 <Shamanoid> if it helps, i am able to compile all the modules on their own
19:22:08 <Shamanoid> they are all in the same directory with the same path
19:22:22 <mauke> Shamanoid: 1) what command are you using?  2) what's the actual output?  3) what output did you expect?
19:23:49 <zachk> hey mauke
19:24:06 <Shamanoid> mauke: 1)i am using "ghc" followed by input file. 2) Actual output is error message posted earlier. 3) Output expected is a successful compilation
19:24:14 <ion> If i wanted to troll a programming channel, this methodology would work great. Ignoring important questions and censoring relevant bits of information would be hilarious.
19:24:22 <Clint> you could keep it up for hours
19:24:25 <mauke> Shamanoid: 1) that's not the actual command. 2) no, it isn't. 3) ok
19:24:30 <mauke> Shamanoid: now you just need to answer 1) and 2)
19:27:09 <rodlogic> What is the recommended package to deal with dates and times and haskell?
19:27:22 <nus> Shamanoid, so, where's Filters.hs?
19:27:38 <Shamanoid> http://pastebin.com/4w6kT17e
19:27:42 <mauke> The paste 4w6kT17e has been copied to http://hpaste.org/78613
19:27:52 <Shamanoid> mauke: guess this answers both 1 and 2
19:28:02 <nus> @hackage time
19:28:02 <lambdabot> http://hackage.haskell.org/package/time
19:28:04 <Clint> well there's your problem
19:28:22 <pqmodn> Shamanoid: first cd ~/Desktop/Code. ghc is looking for modules in your *current directory*
19:28:24 <mauke> Shamanoid: I don't believe you
19:28:50 <mauke> there are three parts of that paste that don't match
19:29:06 <Shamanoid> mauke: alright, i admit i changed the paths
19:29:18 <pqmodn> Shamanoid: why?
19:29:20 <Clint> that only took 15 minutes
19:29:26 <mauke> ok, I give up
19:29:38 <Shamanoid> i will move all the files to the desktop then
19:29:39 <geekosaur> is there some reason you keep (a) replacing paths (b) lying about it?
19:29:47 <Clint> ...
19:30:05 <geekosaur> (c) expecting either we, the cimpiler, or both can read your mind?
19:30:05 <nus> someone is shy of their paths, it seems (-;
19:30:17 <beaky> I love C++
19:30:19 <Shamanoid> geekosaur: it is a university assignment and i am facing such a primitive issues. The path contains university name as well as course name
19:30:21 <geekosaur> Clint, they were asked multiple times by multiple people
19:30:32 <Clint> geekosaur: i realize this
19:30:42 <Clint> i am suggesting that only 15 minutes were completely wasted
19:30:46 <Shamanoid> alright WTF
19:30:52 <geekosaur> an explanation up front would have been fine.
19:31:00 <Shamanoid> i moved the code to a folder on the desktop and it compiled
19:31:16 <nus> anyway, http://www.haskell.org/ghc/docs/7.6.1/html/users_guide/separate-compilation.html 4.7.3
19:31:51 <Shamanoid> geekosaur: thank you for your understanding
19:34:14 <Shamanoid> nus: thanks. Even though problem solved.  Reading it right now.
19:44:25 <slack1256> anybody has managed to use the applicative interface of Transformers?
19:44:50 <slack1256> if so. Could you show me a package with code as an example?
19:44:58 <edwardk> slack1256:  you mean the transformers package?
19:45:05 <slack1256> yeah.
19:45:15 <slack1256> everybody uses the Monad interface of monad transformers
19:45:20 <edwardk> the applicative interface is so you can use the applicative combinators with your otherwise monadic code
19:45:24 <edwardk> in that case
19:45:29 <slack1256> but the applicative one seems complicated
19:45:49 <sclv> it's simpler than monadic
19:45:57 <edwardk> Applicative is 'weaker' than Monad.
19:46:25 <slack1256> I would think is simpler, but let me upload an example of something odd
19:47:27 <hpaste> slack1256 pasted “example Applicative monad transformers” at http://hpaste.org/78614
19:49:41 <slack1256> Anyways that interface doesn't seem to be that popular. I wonder why. Applicative for "regular" monad is used plenty
20:24:19 <ParahSailin> @undo do {c <- MAr.readArray ar idx; MAr.writeArray ar idx (c+1)}
20:24:20 <lambdabot> MAr.readArray ar idx >>= \ c -> MAr.writeArray ar idx (c + 1)
20:25:13 <ParahSailin> that's a bottleneck in my program, because i execute that billions of times, would it be worthwhile to make that a foreign ccall?
20:25:49 <shachaf> You're incrementing a particular cell in an array billions of times?
20:26:01 <ParahSailin> different cells
20:26:20 <shachaf> I'd say there's not enough information to answer your question.
20:26:26 <shachaf> Keep in mind that there is some overhead to FFI calls.
20:26:28 <startling> ParahSailin: that doesn't sound like a bottleneck, even
20:26:58 <ParahSailin> i profiled, it's the major cpu occupier
20:27:02 <startling> that sounds like the part of your code that gets executed billions of times is taking the most time. How is that unexpected?
20:27:13 <shachaf> Profiling results can be misleading.
20:27:38 <ParahSailin> startling, right; i just want to know if i can get this any faster
20:27:50 <shachaf> That depends on what "this" is.
20:31:11 <ParahSailin> shachaf, what is the overhead like on ffi
20:31:47 <shachaf> How should I know?
20:32:29 <shachaf> I certainly don't know enough about your problem to know whether it's appropriate for it or not.
20:33:22 <ParahSailin> well, the increment an index in an array is what the bottleneck can be reduced to
20:34:49 <shachaf> That doesn't really sound right to me, but who knows.
20:35:40 <Taslem> I have a typeclass, DatumMaker a where datumMaker :: a -> Datum. I have an instance for Double, but datumMaker 5 will give me an "ambiguous type variable" error since 5 could be any number.
20:36:20 <Taslem> Is there some better way of going about that? I don't want to have to annotate every occurence of a literal to be a double for use.
20:36:37 <shachaf> ParahSailin: OK, maybe the overhead of unsafe foreign import isn't that big. Depends. I don't know.
20:36:52 <shachaf> Taslem: It's possible that the right solution is not to use a type class. :-)
20:37:06 <shachaf> I don't know what you're doing, though.
20:38:09 <Taslem> More or less, I have a sort of tiny "database" which contains either Strings, Doubles, or a third "Object" typed value which does something else.
20:38:28 <Taslem> And I'm trying to make a convenient way to convert to these so I need not specify when it's not important
20:40:04 <Cale> Taslem: Instead of using datumMaker, why not just have different functions for each type?
20:40:28 <Taslem> I actually thought of a simpler fix.
20:43:39 <axkrts> hello
20:43:42 <axkrts> http://hpaste.org/78615
20:44:01 <axkrts> how can I generalize this function so that it can take a list of anything that is an instance of Enum
20:44:05 <axkrts> and do what it does
20:44:25 <mauke> wtf
20:44:41 <mauke> why is that code going through Int just to convert to Word32 at the end?
20:45:16 <axkrts> because I am extremely new to haskell
20:45:43 <axkrts> ghc complained about ambiguous type of '0' being either Int Bits or Word32
20:45:50 <axkrts> so I just made it an Int
20:46:07 <mauke> axkrts: remove 'fromIntegral'
20:46:33 <axkrts> thanks for pointing that out
20:46:47 <mauke> then remove :: Int, then remove the type signature
20:46:51 <mauke> and you should be done
20:47:26 <axkrts> can I do something like "putCaps :: Enum a => [a] -> Word32"  ... to generalize it?
20:47:39 <mauke> that comes afterwards
20:47:47 <mauke> first you remove the type signature and ask ghci for the type
20:48:44 <axkrts> i removed the type hint and the fromIntegral
20:48:52 <axkrts> [type] -> Word32 still stands
20:52:50 <axkrts> OK. I think this is what I wanted: http://hpaste.org/78620
20:53:17 <axkrts> wait... foldl...
20:53:22 <wereHamster> what is the general advise on version ranges for libraries or executables? Should I keep them as strict or as lose as possible?
20:58:13 <mjo> wereHamster: consult with your priest
20:58:23 <mjo> there are people willing to kill for both viewpoints
20:59:54 <execat> The Archlinux link on http://www.haskell.org/platform/linux.html is a 404. Is there a way to change it?
21:02:25 <xenocons> getting used to emacs with haskell mode now, very good
21:02:31 <xenocons> makes a world of difference
21:05:48 <wereHamster> mjo: lol
21:06:24 <wereHamster> mjo: I'm trying to use the campfire package in my app, but it refuses to install because of conflicts (I use bytestring this, campfire uses bytestring that...)
21:07:16 <mjo> I personally say leave them as loose as possible. If you don't try to use cabal as your package manager, this presents no problems and only benefits.
21:07:24 <mjo> However, in reality, people use cabal as a package manager.
21:08:39 <wereHamster> mjo: what are the alternatives to cabal?
21:09:29 <mjo> Your distros package manager on Linux. On Windows, there isn't one. On OSX, who knows.
21:10:30 <mjo> The distribution's developers pick out a set of packages that work and only allow you to install those together. Having loose bounds makes their job easier. Since the packages are tested for you, strict bounds don't benefit the user in any way.
21:11:10 <wereHamster> what is the argument *for* strict bounds then?
21:11:25 <mjo> At the moment, we treat Hackage as both 1) A place to dump any Haskell code, and, 2) A collection of packages that people can install with cabal-install
21:11:40 <mjo> Strict bounds help people stuck on Windows and OSX avoid build failures
21:11:55 <rwbarton> er
21:12:05 <rwbarton> what if my executable actually depends on a specific version of a package
21:12:09 <Clint> strict lower bounds make sense
21:12:29 <mjo> rwbarton: then you specify the bound, obviously.
21:13:01 <mjo> We're only (I think!) talking about whether or not to specify an upper bound when you don't know if future versions will work.
21:13:45 <mjo> (1) and (2) above are incompatible, because no one is responsible for making sure any of the packages work together.
21:14:33 <Clint> isn't that what stackage is all about
21:15:18 <mjo> yup
21:15:33 <rwbarton> the argument for upper bounds is that future versions of the package may remove functions, or change them in other incompatible ways
21:15:55 <wereHamster> I could use a plain http library to access the campfire API. But then again there are no decent *actually usable* https libraries for haskell
21:16:04 <Clint> there aren't?
21:16:37 <mjo> There's http-conduit, if you're willing to spend a few days learning the abstractions involved just to make an http request
21:17:08 <mjo> network-curl also works, except when it doesn't
21:17:14 <wereHamster> everytime I try to use one it's missing something. Either doesn't support SSL, or no basic authentication (or custom headers), or no easy way to POST something..
21:17:16 <mjo> but only on linux
21:17:23 * joeyh wonders if http-conduit buffers the entire outgoing request in memory, or if clint's DAV library is at fault
21:17:32 <joeyh> must try to find out, one of these days..
21:17:51 <Clint> well, we haven't tried chunking
21:18:03 <joeyh> well, I have chunking, so I don't care a whole lot
21:18:23 * Clint nods.
21:18:39 <joeyh> iirc the problem was there's a http content-length header, and once that's calculated, you're buffering obviously
21:18:46 <OceanSpray> is "forall a. exists b. f a b" equivalent to "exists b. forall a. f a b"?
21:18:54 <OceanSpray> like, assuming exists means what it usually does in logic
21:19:17 <monochrom> no. both in logic and types
21:19:22 <OceanSpray> okay
21:19:23 <wereHamster> what did I say last? I disconnected there
21:19:43 <joeyh> btw, does http-conduit allow pipelining http requests over a single connection?
21:19:44 <mjo> "everytime I try to use one it's missing something..."
21:20:38 <wereHamster> oh, so yeah, fuck it, I just want the equivalent of "curl -X POST -d '...' https://url". I might just as well use spawnProcess, probably the easiest way of them all.
21:21:12 <mjo> If you're on linux and don't need cookies, try network-curl. It's pretty simple.
21:21:12 <Clint> possibly if you use the same Manager, it does that, but I haven't checked
21:21:21 <Clint> wereHamster: that's really prety easy in http-conduit
21:21:41 <startling> @hoogle [[a]] -> [[a]]
21:21:42 <lambdabot> Data.List transpose :: [[a]] -> [[a]]
21:21:42 <lambdabot> Prelude concat :: [[a]] -> [a]
21:21:42 <lambdabot> Data.List concat :: [[a]] -> [a]
21:21:49 <startling> aha, transpose.
21:22:01 <wereHamster> mjo: rofl, literally. How do you POST data with network-curl?!? The library interface is teh fail.
21:23:01 <joeyh> Clint: yeah, I was thinking that might be the case, and it might be a reason to expose the internals of DAV to allow doing that
21:23:56 <Clint> maybe i'll poke at it after i get some sleep
21:24:07 <mjo> wereHamster: check out the "before" routines: http://michael.orlitzky.com/git/?p=lwn-epub.git;a=commit;h=cf0659082f2d0e6afa6b43a6ad55432a00b155e9
21:24:27 <mjo> i.e. go back one commit previous, and look at e.g. log_in in HTTP.hs
21:25:04 <mjo> The cookie handling is busted (that's why I replaced it with http-conduit), but POSTing works OK
21:26:33 <wereHamster> mjo: the way I understand, CurlPostFields uses application/x-www-form-urlencoded. But I need to send JSON in the body. So I need to be able to set the raw body.
21:28:05 <mjo> How would you do it on the command line then? There's probably /some/ combination of options
21:28:41 <wereHamster> curl -X POST -d '{"my":"json"}' -H 'Content-Type: application/json' http://...
21:29:21 <Clint> you could've done it in http-conduit by now
21:29:43 <wereHamster> no, you forget that I have to install hundreds of dependencies
21:31:06 <joeyh> Clint: looks like the manager does maintain a pool of open connections
21:32:10 <Clint> joeyh: so factor the Manager out of DAVState, you think?
21:33:10 <mjo> There's http://hackage.haskell.org/packages/archive/curl/1.3.8/doc/html/Network-Curl-Post.html, helpfully undocumented
21:33:50 <mjo> The problem with http-conduit is that you need to spend a week figuring it out when this should be a 30-second adventure
21:34:28 <joeyh> Clint: something like that.
21:35:02 <joeyh> oh, it'd also allow using http, rather than httpLbs, which buffers everything it downloads (urgh!)
21:36:31 <Clint> how would it?
21:37:38 <joeyh> well, things could return a Source
21:37:53 <wereHamster> Clint: if http-conduit is so easy. How do I set the Content-Type header?
21:38:52 <Clint> wereHamster: alter the requestHeaders of your Request
21:39:15 <elliott> wereHamster: hostility isn't a good way to get help
21:39:21 <Clint> hContentType in newer http-types
21:39:32 <shachaf> wereHamster: You shouldn't be rude about libraries to get help with them thing.
21:39:52 <shachaf> People here are happy to help you, but being rude about it just makes everyone feel bad.
21:41:14 <Clint> joeyh: well, if i could figure out how to get the Source out of the response body
21:41:27 <wereHamster> Clint: req { requestHeaders = ("Content-Type","applicaiton/json") : requestHeaders req } ?
21:42:07 <Clint> wereHamster: you spelled application wrong, and the "Content-Type" bit isn't a String
21:42:50 <wereHamster> Clint: http://hackage.haskell.org/packages/archive/http-conduit/1.8.3/doc/html/src/Network-HTTP-Conduit-Request.html#urlEncodedBody uses a string
21:43:42 <Clint> well, it's OverloadedStrings
21:44:11 <mjo> After some experimentation, I'm proud to say I have no idea what to do with Network.Curl.Post
21:45:03 <wereHamster> ok. but even if we ignore the type problems with that line of code, it's still not correct.
21:45:20 <wereHamster> anyway, I'll just ignore the RFCs and hope it'll work.
21:55:20 * hackagebot authenticate-oauth 1.4.0.4 - Library to authenticate with OAuth for Haskell web applications.  http://hackage.haskell.org/package/authenticate-oauth-1.4.0.4 (HiromiIshii)
22:09:03 <gertc> can sombody test this with 7.6 so i am sure it is not working https://github.com/freizl/hoauth2/blob/master/hoauth2.cabal
22:09:40 <gertc> by test i mean cabal install
22:10:44 <slack1256> gertc: you want just to install it?
22:11:13 <gertc> i get this when i want to install it just asec
22:12:15 <slack1256> sorry cannot do, I have too many package that depend on bytestring 0.10 but this one force me to 0.9.2.1
22:12:29 <gertc> exactly
22:12:59 <slack1256> mmm why don't just change the dependency.
22:13:01 <slack1256> let me see
22:14:29 <slack1256> gertc: it's compiling, lets cross fingers
22:15:04 <gertc> i am already writing a issue :)
22:17:50 <slack1256> well it continues to compile, some time ago in haskell-cafe was a thread about the utility of upper-bound on cabal
22:17:57 <slack1256> but idk what was concluded
22:18:53 <gertc> what does upper-bound do?
22:19:33 <slack1256> for example for bytestring was (>= 0.9.*) && (<= 0.10)
22:19:54 <slack1256> the idea is that it "restrings" the library api exposed to the package
22:20:34 <slack1256> on the other hand some packages don't change too much the interface. So it doesn't compile because of nothing
22:21:04 <slack1256> And the ones who do usually maintain a legacy api (see parsec3)
22:22:04 <startling> is it significantly harder to call haskell from C than vice-versa?
22:22:19 <gertc> ok thx slack1256
22:23:14 <arbn> startling: No.
22:23:22 <startling> arbn: good to know, thanks
22:23:55 <slack1256> startling: http://www.haskell.org/haskellwiki/Calling_Haskell_from_C
22:24:07 <slack1256> it seems you need just an extra header
22:24:44 <startling> neat, thanks
22:26:16 <arbn> startling: https://gist.github.com/4129855 <-- Here's a silly example of populating an allocated array with a Haskell function.
22:26:26 <arbn> startling: The C code is there, too.
22:27:07 <startling> arbn: wow, cool
22:27:25 <arbn> So, yeah, it's super easy.
22:27:37 <startling> haskell's FFI is really nice.
22:27:37 <slack1256> gertc: it compiled. but I can't assure you it's correctness
22:27:48 <gertc> ok thx
22:27:57 <slack1256> s/it's/its
22:28:50 <gertc> ps is there something wrong with `Control.Lens'? Does not export `query'
22:29:07 <startling> :t query
22:29:09 <lambdabot> Not in scope: `query'
22:29:26 <startling> gertc, apparently not. where did you hear about this function? what does it do?
22:29:56 <arbn> startling: Yeah. This means that it's pretty easy to write desktop applications, where the "view" and "controller" part are written in whatever language they have to be written in (usually Objective-C or .NET), but all the interesting, backend parts of the logic can be calls to Haskell functions.
22:30:22 <startling> arbn: neat.
22:30:36 <slack1256> arbn: oh. I didn't though about that
22:30:43 <slack1256> *think
22:31:19 <slack1256> but I really want a strong GUI component binding for haskell
22:31:44 <arbn> slack1256: Yeah. I'm working with Cocoa right now, and I wish I had the time to get HOC into shape, or something.
22:31:47 <gertc> https://github.com/gertcuykens/haskell-design/blob/master/src/Json.hs it used to work
22:31:59 <gertc> import qualified Control.Lens as LENS (query)
22:32:25 <slack1256> gertc: see hoogle for the definition of query and see what it throws you
22:32:45 <gertc> ok
22:33:48 <slack1256> arbn: Cool! wish i got mac to play with cocoa too.
22:37:11 <startling> is there a way not to dynamically link to GMP yet?
22:37:50 <startling> I probably don't even need to use Integer.
22:38:50 <slack1256> startling: even so, if you use Num (example the (+) function) you have the method fromInteger
22:38:56 <slack1256> @type fromInteger
22:38:57 <lambdabot> Num a => Integer -> a
22:39:33 <slack1256> so you would probably want the Integer of GMP, because the native implementation aparently hasn't recived much love
22:40:26 <startling> slack1256: yeah, I know.
22:40:28 <gertc> i think i need this query but it does not export it anymore? http://hackage.haskell.org/packages/archive/lens/3.2/doc/html/Control-Lens-Getter.html
22:41:05 <startling> is the native implementation usable? A performance hit would be fine.
22:41:36 <centrinia> Why do you need the native implementation?
22:41:48 <slack1256> aparently yes, but is even less portable than GMP
22:44:44 <startling> centrinia: I'm just idly wondering. I'd like to be able to drop a binary virtually anywhere, though.
22:45:03 <beaky> does haskell have a mutable IOInt?
22:45:06 <startling> gertc: it looks like it's differently-named, now.
22:45:12 <gertc> peruse
22:45:16 <gertc> i think
22:45:40 <slack1256> beaky: yes, not only in the IO monad, also in the ST monad
22:45:41 <startling> yeah.
22:46:06 <beaky> ah how do I use it
22:46:23 <shachaf> gertc: It's just "view" now.
22:46:30 <shachaf> gertc: Oh, maybe that didn't make into 3.6
22:46:38 <slack1256> beaky: before that. Are you sure that your solution requieres mutable Int?
22:46:40 <shachaf> In HEAD it's just called view.
22:46:52 <slack1256> beaky: usually in haskell mutable doesn't imply faster
22:47:28 <beaky> oh
22:47:58 <beaky> I can get by with forM_ :D
22:47:59 <startling> shachaf: how does that work?
22:48:15 <beaky> but I want to make my haskell code look like pascal with mutable integers
22:48:27 <shachaf> @ty asks
22:48:28 <lambdabot> MonadReader r m => (r -> a) -> m a
22:48:41 <slack1256> beaky: oh well, more knowledge can't hurt right?
22:48:43 <shachaf> > asks (+1) 5
22:48:45 <lambdabot>   6
22:49:00 <startling> beaky, why not just use State or whatever, then?
22:49:01 <slack1256> beaky: you use the module Data.IORef
22:49:11 <aristid> or State.
22:49:11 <lambdabot> aristid: You have 1 new message. '/msg lambdabot @messages' to read it.
22:49:19 <aristid> lambdabot: i know:)
22:50:17 <slack1256> the documentation is clear, from the example you get the gist
22:50:26 <gertc> ok it was changed to peruse
22:50:38 <aristid> :t peruse
22:50:39 <lambdabot> MonadReader s m => Getting a s t a b -> m a
22:50:53 <aristid> shachaf: getting a stab? :)
22:51:15 <slack1256> gertc: and that is exactly why upper bounds exists
22:51:51 <shachaf> Getting a stab, ma
22:51:54 <dmwit> S&M getting a stab, ma
22:51:56 <dmwit> dang
22:51:59 <dmwit> a few seconds too late
22:52:45 * slack1256 wonders if that signature was on purpose
22:52:49 <dmwit> definitely
22:53:16 <aristid> slack1256: as far as i'm informed, shachaf influenced the naming convention of type variables in the lens library in that direction.
22:53:41 <dmwit> You would have no doubts if you had seen his newtype Nu f = Nu { old :: f (Nu f) }
22:54:04 <dmwit> or was the joke even better? I can't remember it now...
22:54:05 <slack1256> OMG!
22:54:21 <elliott> edwardk failed to realise the clear superiority of (u,v) over (s,t).
22:54:43 <startling> dmwit: haha
22:55:10 <aristid> dmwit: i don't get that one
22:55:35 <elliott> new, old
22:55:58 <aristid> oh
22:56:23 <shachaf> I spent a while going through the whole library and renaming it from (a,b,c,d) to (s,t,a,b)
22:56:52 <aristid> shachaf: and it's a clear improvement, even when not counting the puniness.
22:56:53 <startling> shachaf: haha
22:57:04 <slack1256> hehe
22:57:05 <shachaf> startling: A big improvement, don't you think?
22:57:33 * startling stabs shachaf 
22:57:56 <dmwit> MonadReader source monad => Getting input source target input output -> monad input
22:58:18 <dmwit> clear as mud
22:58:25 <aristid> dmwit: are there some invisible unicode characters there that my terminal can't display?
22:58:59 <dmwit> I guess all the characters are Unicode characters, and about 20% of them are invisible.
22:59:12 <dmwit> But that's not answering your question in a helpful way. The helpful answer is "no".
22:59:52 <aristid> oh
22:59:55 <startling> aristid: hυh? of coωrs∃ nøt.
23:00:11 <aristid> dmwit: well i guess i must not be thinking clearly if i think source and input are the same word.
23:00:46 <dmwit> mud's starting to look pretty good, huh?
23:01:04 <dmwit> Is there a pithy phrase I can use for that effect? "semantic satiation" is already taken
23:01:42 <shachaf> http://slbkbs.org/lazy-syntax.png
23:01:45 <aristid> dmwit: is there a... description of that effect? because right now i think it's just me being tired
23:02:00 <aristid> shachaf: mm colors.
23:02:21 <shachaf> Is there an existing streaming pseudo-syntax-highlighter?
23:02:28 <shachaf> It doesn't have to do real code.
23:02:44 <aristid> shachaf: just Show instances?
23:03:14 <shachaf> aristid: I think something that operates over a string would be simplest.
23:03:36 <aristid> shachaf: no i mean typical Show instances is what it should support?
23:03:53 <aristid> > Data.Map.singleton "44"
23:03:54 <lambdabot>   Not in scope: `Data.Map.singleton'
23:03:59 <mikeplus64> shachaf: you can use vim and one of it's terminal plugin things, then set syntax=haskell
23:04:20 <slack1256> shachaf: you want to highlight code on the terminal (possibly on a pipe)?
23:04:28 <shachaf> mikeplus64: Seems a little heavyweight for ghci.
23:04:33 <shachaf> aristid: Sure.
23:04:36 <mikeplus64> shachaf: probably
23:04:51 <mikeplus64> but not really if you're already editing text with vim
23:05:02 <dmwit> aristid: Compare "circle plus squared minus two = 2 * minus + minus * plus^2 + squared^2 - two" and "f x y z w = 2 * z + z * x^2 + y^2 - w".
23:05:05 <mgsloan> shachaf: https://www.youtube.com/watch?v=pMEyz4leeLk
23:05:05 <shachaf> ?
23:05:47 <mgsloan> better: https://www.youtube.com/watch?v=pMEyz4leeLk&t=1m30s
23:05:50 <shachaf> Is that a thing written in elisp?
23:05:56 <aristid> dmwit: um that's extra evil, using operator names for variables
23:06:18 <Ralith> shachaf: is that a colored ghci? o.O
23:06:31 <mgsloan> shachaf: I haven't looked at how it works, but it's pretty cool as far as colored + folding results of Show
23:06:33 <dmwit> aristid: Pff, that's not evil, that's job security.
23:06:52 <mikeplus64> that haskell emacs repl looks great, too bad i can't stand emacs
23:06:54 <mikeplus64> lol
23:07:03 <pd_snipe> I am new to Haskell and stuck on a homework assignment. Can anyone help me? The problem I am trying to solve is supposed to be really easy but i am stumped. I am suppose to write a function that chains 3 functions together to form a new function.  I am thinking the solution involves composition but I am not sure.
23:07:11 <aristid> dmwit: circle cheese hamster cookie icecream = 2 * cookie + cookie * cheese ^ 2 + hamster ^ 2 - icecream
23:07:32 <aristid> dmwit: i think that works slightly better
23:07:32 <dmwit> circle sounds delicious :3
23:07:32 <shachaf> mgsloan: Yep.
23:07:33 <slack1256> pd_snipe: yeah you have to use composition
23:07:33 <Ralith> pd_snipe: what do you have so far?
23:07:36 <shachaf> I just want a simple ghci thing, though.
23:07:38 <mikeplus64> aristid: now i know what i'm having for dinner -- hamster
23:07:39 <shachaf> Ralith: Yep.
23:07:46 <Ralith> shachaf: link
23:07:59 <aristid> mikeplus64: yea thats why i used a list of foods ;)
23:08:08 <shachaf> Ralith: http://www.reddit.com/r/haskell/comments/144biy/pretty_output_in_ghci_howto_in_comments/
23:08:18 <Ralith> ty
23:08:22 <Rotaerk> pd_snipe, do you at least know what its signature should be
23:08:25 <mauke> MonadReader mаrklar marklаr => Getting marklar mаrklar mаrklаr marklar mark1ar -> marklаr marklar
23:08:28 <shachaf> Ralith: Except that one doesn't handle infinite values, so I started writing my own thing to do that.
23:08:30 <aristid> mikeplus64: for some reason those were the first wordy words that came into my mind.
23:08:39 <startling> shouldn't someone just use hint or whatever write a different repl?
23:08:46 <dmwit> mauke: =(
23:08:50 <popl> mauke++
23:08:54 <pd_snipe> no i dont think so
23:08:55 <shachaf> Ralith: But I don't want to write a syntax highlighter.
23:09:01 <slack1256> pd_snipe: http://learnyouahaskell.com/higher-order-functions#composition
23:09:06 <dmwit> Also, bonus negative points for using marklar instead of malkovich
23:09:13 <slack1256> the very first thing is what you want
23:09:17 <pd_snipe> http://www.utdallas.edu/~Brian.devries/cs4337/hw3_haskell.hs
23:09:25 <pd_snipe> its problem #1
23:09:49 <mauke> dmwit: ooh, malkovich would have allowed me to avoid cheating with 1
23:09:51 <aristid> dmwit: i think the problem in all of those cases is "too many similar things for brain to keep apart"
23:10:06 <shachaf> mauke: That doesn't even kind-check, does it?
23:10:08 <slack1256> pd_snipe: Your teacher is in the channel
23:10:15 <mauke> shachaf: why not?
23:10:19 <shachaf> @kind MonadReader
23:10:21 <lambdabot> * -> (* -> *) -> Constraint
23:10:38 <pd_snipe> right now i have fnChain = c . b . a for the definition
23:10:40 <startling> slack1256: that's pretty funny
23:10:53 <pd_snipe> no clue on the signature
23:11:02 <popl> There are classes teaching Haskell?
23:11:05 <popl> Fucking brilliant.
23:11:08 <slack1256> pd_snipe: does it load on ghci?
23:11:17 <pd_snipe> lol
23:11:30 <dmwit> > "mаrklar" == "marklаr"
23:11:30 <lambdabot>   mueval: recoverEncode: invalid argument (invalid character)
23:11:42 <beaky> hello
23:12:01 <dmwit> shachaf: Anyway, that evaluates to False. =)
23:12:02 <shachaf> dmwit: Oh.
23:12:37 * shachaf misunderstood the point completely, then.
23:12:42 <startling> data Slot = Slot { kind :: Type } :S
23:12:49 <dmwit> startling: agh
23:13:20 <startling> dmwit: not my fault that the type theorists took all the good vague words
23:14:05 <slack1256> pd_snipe: why don't define some examples?
23:14:09 <slack1256> @type (+5)
23:14:10 <lambdabot> Num a => a -> a
23:14:18 <slack1256> that a function so
23:14:20 <popl> dude, my programming languages class sucked compared to this
23:14:23 <dmwit> data Sort = Sort { kind :: Category flavor => flavor Type Set }
23:14:40 <startling> popl: did you learn Java
23:14:56 <pd_snipe> example? like what?
23:15:02 <popl> startling: Lisp, Prolog, and Erlang.
23:15:03 <slack1256> @type ((+9) . (/2) . (3.14*))
23:15:05 <lambdabot> Fractional b => b -> b
23:15:14 <slack1256> @type ((signum) . (/2) . (3.14*))
23:15:15 <lambdabot> Fractional b => b -> b
23:15:27 * hackagebot sym 0.2.1 - Permutations, patterns, and statistics  http://hackage.haskell.org/package/sym-0.2.1 (AndersClaesson)
23:15:30 <slack1256> @type ((>=0) . (/2) . (3.14*))
23:15:32 <lambdabot> (Fractional a, Ord a) => a -> Bool
23:15:35 <mauke> :t round . sqrt . abs
23:15:36 <lambdabot> (Floating a, Integral b, RealFrac a) => a -> b
23:15:38 <startling> popl: that's not so bad.
23:15:47 <popl> startling: No, I liked those languages.
23:16:06 <popl> startling: But the outline on this syllabus looks like it covers things we didn't cover.
23:16:30 <startling> popl: ah
23:16:37 <startling> how is DataKinds broken on 7.4?
23:16:51 <popl> startling: It was a 10 week quarter, though.
23:17:46 <byrdmansniper> how does functional programming work in haskell?
23:17:57 <mauke> terrible!
23:18:11 <mauke> byrdmansniper: how does imperative programming work in C?
23:18:13 <slack1256> byrdmansniper: how so?
23:18:31 <slack1256> could you expand on that?
23:18:36 <mysticc> In templatehaskell how do you convert an operator to a name like <. I could check type of '< to be name but when I patternmatch on this in a function it gives parse error?
23:18:36 <popl> mauke: It's very basic.
23:18:46 <byrdmansniper> good one
23:18:54 <byrdmansniper> i deserved that
23:19:55 <pd_snipe> brydmansniper is in the same class as me btw
23:20:09 <startling> where do I read how to use DataKinds?
23:20:26 <slack1256> wow time to REALLY call you proffesor
23:20:38 <slack1256> who is really here (partial true lie)
23:20:41 <shachaf> startling: The paper?
23:20:54 <shachaf> startling: Or the GHC manual?
23:21:16 <popl> THe only problem with that class is that it is in Dallas.
23:22:36 <popl> Also that the instructor chooses to use .doc for the syllabus.
23:22:42 <mgsloan> mysticc: you can't use those for pattern matching, you'll have to use guards with (x == '<)
23:22:58 <mgsloan> I think it might also be '(<)
23:24:35 <mgsloan> yup, you can only use those to construct names, and it has to be in parens
23:24:54 <startling> shachaf: good calls
23:25:48 <sw2wolf> A *.cabal file has a flag with_hint, how can i define the flag using cabal ?
23:26:36 <slack1256> sw2wolf: I don't know from cabal, but i usually modify the flag from 0 to 1 directly on the file and then cabal install
23:27:04 <randomclown> Is there a better way to do fromJust $ lookup x $ zip [2,4,6,9,0,3,7] [1,2,4,6,3,67,0]
23:27:16 <sw2wolf> slack1256: doesnot `cabal configure` add some parameters ?
23:27:41 <slack1256> not sure, but i've got my way with cabal install
23:27:53 <sw2wolf> thx
23:29:14 <mgsloan> mysticc: if you're seriously pattern matching a ton of template haskell, you might take a look at my unfinished quasi-extras package: https://github.com/mgsloan/quasi-extras/blob/master/examples/Example2.hs
23:29:38 <sw2wolf> slack1256: you mean modify *.cabal, i.e. xxx_flag=1 ?
23:29:53 <slack1256> exactly
23:30:03 <sw2wolf> ok, i will try
23:30:38 <johnw> `nand`: ping
23:31:05 <johnw> @tell `nand` Isn't it involutive, rather than involutary?
23:31:05 <lambdabot> Consider it noted.
23:31:43 <shachaf> Is this a grammatical question or a technical question?
23:31:58 <johnw> technical
23:32:10 * startling involutes johnw
23:32:24 <shachaf> What's involutary?
23:32:34 <johnw> i'm not sure if that's the correct term
23:32:37 <johnw> but it's f . f = id
23:32:46 <mauke> self-inverse?
23:32:52 <johnw> i'm doing the Software Foundations proof for it now, and it's calling it involutive
23:33:01 <slack1256> oh
23:33:08 <popl> @learn
23:33:08 <lambdabot> http://www.haskell.org/learning.html
23:33:13 <popl> ^broken URL
23:34:14 <shachaf> johnw: Are those two words that mean two different things?
23:34:23 <mysticc> mgsloan: I want to simplify expression like (If (3>2) then 1 else 2) when passed through my TH simplifier will be converted to 1.
23:34:48 <johnw> i was asking if he could clarify that for me
23:35:10 <mgsloan> mysticc:  ahh, interesting!  My library might work well for you, actually
23:35:51 <mgsloan> here are most of Haskell's desugarings for TH: https://github.com/mgsloan/quasi-extras/blob/master/src/Language/Quasi/Internal/Desugar.hs
23:35:51 <slack1256> Am i getting arrows right?, usually one side of the tuple will be a function and the other will be information about that function known a priori?
23:36:05 <shachaf> mysticc: Note that GHC will already do that particular optimization.
23:37:13 <mgsloan> mysticc: The main failing point of the approach is that it doesn't work for places that the AST has lists of things
23:37:22 <mgsloan> (case statements, where clauses, etc)
23:37:28 <startling> okay, so I've got types of items (data Genus = Sword | Dagger | Etc). I want each player to have a job, and each job should have a required type of item that needs to be equipped in order to have that job. Should I encode this in the types using DataKinds or something? how would it look?
23:37:48 <mysticc> shachaf: Yeah I know, this is just a part of what I need
23:38:58 <startling> Instead of "should I", I should ask "is it possible to".
23:39:30 <slack1256> startling: that seems a case of gadt
23:39:32 <mzero> startling: not the way you've defined Genus - those items are constructors (values), not types
23:39:45 <startling> mzero: hence DataKinds. ;)
23:39:52 <startling> slack1256: oh, really? interesting
23:39:52 <mzero> and really, it is almost certainly overkill to try to put such a thing in the type system
23:40:11 <slack1256> mzero is right
23:40:27 <startling> okay, but is it possible?
23:40:29 <slack1256> I would probably get something working first
23:40:49 <slack1256> yeah totally haskell is like zombo.com "your imagination is your limit"
23:40:52 <mzero> perhaps - but we'd have to know much more about the structure AND what you want the type system to enforce
23:41:32 <mzero> encoding in the type system is making sure that the programmers conform to certain strictures
23:41:54 <mzero> ensuring that run-time data conform to certain strictures is not always the same thing
23:42:23 <startling> mzero: right. my stricture would be "nothing can create a character having some job that doesn't have the associated item equipped"
23:42:59 <mzero> you might be able to do that - but probably at the expensive of clarity elsewhere
23:43:50 <mzero> for example, one might have     data Player :: Player {  ....    playerItemsHeld: [ Genus ] .... }
23:44:13 <startling> mzero: yes, I know how it'd work ordinarily.
23:44:33 <mzero> if you want what you said, you'd end up with      data Player :: Player { ....  playerSwords :: [Sword], playerDaggers :: [Dagger], .... }
23:44:43 <mzero> see - that is probably more cumbersome for many many other things
23:45:24 <startling> mzero: I don't think that's necessarily true.
23:45:25 <shachaf> That type hardly seems right either.
23:45:50 <startling> shachaf: what should it look like?
23:46:03 <mzero> well - off hand, it seems unlikely to me to be right to encode the job / equipment relationships in the type system
23:46:22 <shachaf> startling: I have no idea. :-)
23:46:29 <startling> shachaf: alright, fair enough.
23:46:41 * startling grumble grumble dependent typing
23:46:47 <shachaf> Mostly because I'm not sure what you're trying to do.
23:47:11 * shachaf is pretty good at having no idea what people are trying to do.
23:48:31 <startling> I really want "shoot :: Player Bow -> Direction -> World -> World", though. :/
23:57:16 <Ralith> startling: clearly you should be doing this in idris.
23:57:23 <startling> Ralith: ikr
23:57:35 * startling considers
23:57:55 <xenocons> heh, 'where' and pattern guards are really quite pretty
23:58:08 <xenocons> that is quite nice
23:58:36 * xenocons wonders why F# doesn't have this ;)
23:59:01 <mzero> yes, Haskell code is quite elegant once you get over the syntax shock
23:59:12 <Heffalump> xenocons: F
23:59:24 <Heffalump> F# does have active patterns
23:59:28 <xenocons> im always writing x when x > .. | x when x < .. | etc
23:59:30 <xenocons> yeah
23:59:38 <xenocons> imo though where is neat
23:59:56 <Heffalump> you can always use a let before the match
