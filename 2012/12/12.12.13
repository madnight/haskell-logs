00:00:08 <liyang> One of: change, alter, adjust, mutate, assign, vary?
00:00:18 <liyang> (As I said on #haskell-lens)
00:01:01 <statusfailed> liyang: okay, I'll stop trying :p
00:01:18 <liyang> Guess who just looked up the thesaurus.
00:01:22 <statusfailed> haha
00:01:31 <liyang> statusfailed: please carry on, if you have more alternatives!
00:01:42 * liyang kind of likes 'vary'.
00:01:52 <snowylike> now this might be a stupid or annoying question, but
00:01:58 <shachaf> NemesisD: I ran your program and got a different behavior with -threaded
00:02:02 <snowylike> where's the difference between #haskell and #haskell-lens?
00:02:14 <Nereid> haha
00:02:17 <shachaf> NemesisD: I recommend testing that fooSignal behavior in a little program that doesn't do any of the conduit nonsense.
00:02:27 <statusfailed> now I feel guilty...
00:03:00 <shachaf> snowylike: One of them is smaller (but has more traffic)
00:03:13 <snowylike> ah okay
00:03:18 <liyang> snowylike: there's even more lens-talk in #haskell-lens
00:04:06 <thirsteh> can I pattern match against a variable? e.g. foo = "bar", and I want to match against "bar" in function baz bar = x, baz _ = y (rather than shadow foo)
00:04:17 <shachaf> No.
00:04:24 <shachaf> You can use a guard: | foo == "bar" = ...
00:04:29 <NemesisD> shachaf: cool ill try that tomorrow. also, is there a different place you can think of thaaat i can take these nontrivial debugging problems to? seems like this channel is mostly for learning
00:04:34 <liyang> Those names are already in use in containers. Can we draw any sort of parallel between them?
00:04:40 <liyang> Oops. Wrong channel.
00:05:06 <snowylike> another question
00:05:21 <shachaf> NemesisD: This channel is for most anything.
00:05:31 <ion> nemesisd: This channel is just fine for nontrivial problems.
00:05:32 <shachaf> There are other channels but people usually don't pay attention to them.
00:05:52 <snowylike> i'm a mathematician by trade (actually a student, but i guess there's not that big of a difference anymore) and i know a bit about category theory
00:06:00 <snowylike> but not much about haskell
00:06:12 <snowylike> someone told me that functors in haskell are not like functors in category theory
00:06:15 <snowylike> or not quite like them
00:06:28 <snowylike> is that a correct assessment, and if so, how do the differ?
00:06:45 <shachaf> snowylike: They are related.
00:07:03 <shachaf> snowylike: Functors in Haskell are endofunctors on the category of Haskell types.
00:07:07 <Nereid> Functors in haskell are (categorical) functors Hask -> Hask, but not all such functors come from Functors.
00:07:20 <Nereid> e.g. the identity functor
00:07:24 <shachaf> I don't know what I'm talking about so I'll let Nereid talk.
00:07:24 <snowylike> mh
00:07:36 <NemesisD> shachaf: cool. ill probably be back tomorrow. ill try isolating the signal handling issue. thanks!
00:08:10 <latro`a> eh, Identity is isomorphic to the actual identity functor
00:08:18 <JamesJRH> Ah, got it working. I was supposed to use http://dac4.designacourse.com:8000/anim for http://hpaste.org/raw/79152, rather than /draw.
00:08:21 <latro`a> even though it's not actually the same thing
00:08:23 <JamesJRH> Awesome!
00:08:35 <snowylike> isomorphism is enough for me
00:08:58 <latro`a> the main place where haskell's X and category theory's X aren't really the same is monads imo
00:09:10 <Nereid> really?
00:09:26 <latro`a> they are actually the same, but the things that category theory and haskell care about are drastically different
00:09:47 <Nereid> so the difference isn't really in the definition, just how we think about them.
00:09:49 <latro`a> in particular, in category theory every monad has a comonad, but in haskell the associated comonad is often a meaningless structure because it lives in the wrong category
00:09:50 <Nereid> (not countaing fail)
00:09:51 <Nereid> counting
00:09:53 <johnw> latro`a: do you mean because of Haskell's emphasis on >>=?
00:09:59 <latro`a> that's also a part of it
00:10:19 <latro`a> but even if you built haskell monads from join fmap return, the result has a different feel
00:10:20 <Nereid> but there are different comonads associated to one monad.
00:10:35 <latro`a> uhh...fairly sure that's not true categorically
00:10:37 <Nereid> just like how different adjunctions can give you the same monad.
00:10:39 <latro`a> been a while though
00:10:46 <latro`a> oh wait nvm, right
00:10:55 <latro`a> that's the more basic result
00:11:06 <latro`a> and in category theory you start with the adjunction and get the monad/comonad
00:11:14 <latro`a> in haskell we tend not to even have the adjunction as a pair of Functors
00:11:25 <latro`a> there's a pair of functors, but usually only one is a Functor
00:11:43 <snowylike> is this difference something fundamental to functional programming, or is it a quirk of haskell itself?
00:12:04 <latro`a> not really either; it's all about Hask as a category, which isn't intrinsically linked to programming at all
00:12:36 <latro`a> Hask is somewhat of a weird category
00:12:52 <latro`a> because it has a TON of structure
00:12:52 <johnw> http://www.haskell.org/haskellwiki/Hask
00:13:03 <johnw> that lays out many of the oddnesses
00:13:06 <latro`a> right
00:14:57 <latro`a> I should say *in part because
00:15:06 <latro`a> bottom-anything is another major reason
00:15:48 <liyang> lol @ bottom row of “Why Hask isn't as nice as you'd thought.”
00:15:58 <Nereid> there's also a lot of categorical structure that Hask doesn't have.
00:16:01 <Nereid> e.g. pullbacks
00:16:10 <zurich> thought i would stop by and say haaaaaaaaaay
00:16:13 <latro`a> this is true, though that's not that unusual
00:16:25 <snowylike> mh
00:16:58 <latro`a> I think the more important thing is that haskell really doesn't care about the adjunction, whereas category theory primarily does
00:18:06 <Nereid> and yeah, bottom ruins a few things.
00:18:11 <latro`a> (by the way, the dual of most of what I've said here is true; most comonads on Hask do not have the corresponding monad also being on Hask)
00:19:27 <snowylike> and i guess those that do have comonads/monads that are on hask aren't that interesting from a haskell point of view?
00:19:44 <latro`a> I can't think of any that aren't basically trivial
00:20:15 <latro`a> for example Identity's comonad is isomorphic to it I believe
00:20:23 <Nereid> but Identity is a pretty boring comonad
00:20:25 <Nereid> or monad
00:20:29 <latro`a> (maybe contravariantly isomorphic, something like that)
00:20:33 <latro`a> right
00:20:35 <Nereid> anyway, edwardk had a blog post on how every Comonad gives a Monad (but not vice versa)
00:20:36 <Nereid> wherever it is
00:20:45 <latro`a> hmm
00:20:54 <latro`a> maybe I was mistaken (I blame 3 am if so)
00:21:07 <Nereid> http://comonad.com/reader/2011/monads-from-comonads/ and a couple more
00:22:10 <bartavelle> is there a way to prevent people from turning haskell-cafe into debian-endless-bickering-about-licenses ?
00:22:43 <Nereid> haha
00:22:46 <popl> bartavelle: Probably not.
00:23:25 <popl> bartavelle: People are contentious.
00:23:37 <johnw> i disagree :)
00:23:51 <bartavelle> :)
00:23:59 <Nereid> @botsnack
00:24:00 <lambdabot> :)
00:24:19 <popl> hurr
00:24:38 <latro`a> huh, cute
00:24:42 <poilades> exit
00:25:06 <latro`a> any construction that gives you a comonad from an arbitrary monad would allow a definition of unsafePerformIO
00:25:17 <latro`a> I'm surprised how intuitive that is
00:25:28 <zurich> why bother with programming when u can just use facebook apps latro`a
00:27:11 <Nereid> latro`a: it would?
00:27:35 <latro`a> (it's in that link)
00:27:48 <Nereid> oh right
00:27:55 <latro`a> but...although it's not *exactly* what happens, more or less having an "extract" gives you unsafePerformIO, kinda
00:28:17 <latro`a> again there's monad-comonad laws in the way of that actually being unsafePerformIO, since the comonad doesn't have the same type constructor
00:28:23 <latro`a> but...that's the gist of it
00:47:05 <mikeplus64> @undo y <- x; ys <- f xs; return (y : ys)
00:47:06 <lambdabot>  Parse error at "<-" (column 3)
00:47:10 <mikeplus64> @undo do y <- x; ys <- f xs; return (y : ys)
00:47:11 <lambdabot> x >>= \ y -> f xs >>= \ ys -> return (y : ys)
00:47:19 <mikeplus64> @pl x >>= \ y -> f xs >>= \ ys -> return (y : ys)
00:47:20 <lambdabot> (`fmap` f xs) . (:) =<< x
00:52:52 <thirsteh> is there a zlib package that lets you do e.g. Z_SYNC_FLUSH that's not Data.Conduit.Zlib?
00:53:25 <thirsteh> Codec.Compression.Zlib with a compressFlush, basically
00:54:02 <shachaf> thirsteh: https://encrypted.google.com/search?q=site%3Ahackage.haskell.org+z_sync_flush suggests two libraries.
00:54:20 <shachaf> Well, one of them is "for internal use only"
00:55:30 <thirsteh> oh, nice, had missed Codec.Zlib, thanks. flushDeflate looks like exactly what I need
00:55:40 <thirsteh> looks like the non-conduity lib behind Data.Conduit.Zlib
00:56:11 <blackdog> anyone know of a clever algorithm for finding which of a set of strings is closest (levenshtein-wise) to a target string?
00:57:32 <thirsteh> blackdog: Python's difflib.get_close_matches() is pretty neat
00:57:49 <thirsteh> "SequenceMatcher is a flexible class for comparing pairs of sequences of any type, so long as the sequence elements are hashable. The basic algorithm predates, and is a little fancier than, an algorithm published in the late 1980's by Ratcliff and Obershelp under the hyperbolic name "gestalt pattern matching". The basic idea is to find the longest contiguous matching subsequence that contains no "junk" elements (R-O doesn't address junk). The
00:57:49 <thirsteh> same idea is then applied recursively to the pieces of the sequences to the left and to the right of the matching subsequence. This does not yield minimal edit sequences, but does tend to yield matches that "look right" to people."
00:58:10 <blackdog> thirsteh: thanks, that looks useful.
00:58:59 <blackdog> thirsteh: i imagine yo ucould use that as a winnowing pass and compute exact edit-distance for the remaining candidates
01:00:08 <thirsteh> yup
01:01:31 <blackdog> thirsteh: hm. it looks like it still just iterates over each pair
01:02:07 <blackdog> was hoping you could build a trie-ish structure perhaps.. or at least, use an iterative deepening approach so you don't keep searching on candidates that will be hugely off
01:02:29 <neutrino> thirsteh: i think there's a library that does something like that
01:03:41 <neutrino> isn't patience diff the same or similar thirsteh?
01:04:13 <neutrino> http://hackage.haskell.org/package/patience
01:04:45 <mikeplus64> how do you add a context to a rewrite rule?
01:04:45 <thirsteh> pretty similar, at least
01:04:47 <thirsteh> ah, nice
01:04:53 <neutrino> kmc's single non-troll contribution to the community
01:04:57 <mikeplus64> a class constraint I mean
01:05:11 <shachaf> mikeplus64: I think rules don't really have types at all.
01:05:29 <blackdog> thirsteh: blergh, it's a bit too strict.
01:05:40 <mikeplus64> ghc complains if i just use forall a b., so there is some typing
01:05:46 <neutrino> here's another http://hackage.haskell.org/package/acme-colosson
01:05:57 <shachaf> mikeplus64: a and b aren't types, they're values.
01:06:11 <Nereid> neutrino: haha what is that package
01:06:13 <shachaf> Rewrite rules are about expressions as far as I know.
01:06:26 <neutrino> an attempt at trolling the community, Nereid?
01:06:42 <blackdog> neutrino: at least it's in acme :)
01:07:01 <neutrino> much trolling in this category: http://hackage.haskell.org/packages/archive/pkg-list.html#cat:acme
01:07:23 <mikeplus64> shachaf: oh right, then maybe i can use forall (a :: C x => x)
01:07:26 <mikeplus64> yeah, i can
01:07:54 <Nereid> haha don't.
01:10:16 <shachaf> I'm not sure this does what you want.
01:11:53 <blackdog> neutrino: patience diff is interesting too, thank you
01:12:24 <blackdog> i think my problem is that i'm looking for an asymmetric match, where a string is an almost-prefix of something else
01:12:47 <blackdog> maybe if i just match the first chunk of each string...
01:12:52 * hackagebot hlibgit2 0.17.0.1 - Low-level bindings to libgit2.  http://hackage.haskell.org/package/hlibgit2-0.17.0.1 (JohnWiegley)
01:17:06 <Nereid> AcmeT is my favourite monad transformer now.
01:18:50 <johnw> any particular reason?
01:19:05 <Nereid> read the source to find out.
01:19:15 <johnw> e,h too much work
01:19:25 <Nereid> fail = return . unsafeCoerce
01:19:38 <ion> The acme category isn’t trolling, it’s humor. They might be trolling if they weren’t marked as “acme”.
01:20:01 <neutrino> blackdog: yw
01:20:51 <shachaf> Nereid: Looks like a reasonable implementation to me.
01:24:38 <Jafet> blackdog: Levenshtein distance is a metric, so you can use any metric space data structure
01:24:50 <Jafet> Whether any of them are fast is another matter
01:25:33 <leroux> Anyone have experience with haskell and web dev?
01:26:18 <leroux> I'm thinking about prototyping one of my projects in haskell so I can learn more about the language.
01:26:36 <shachaf> #haskell-web might know something.
01:26:43 <shachaf> I think web development isn't a good way to learn Haskell.
01:26:46 <Jafet> I have only bad experiences
01:27:00 <johnw> shachaf: it's not even a good way to learn web programming
01:27:14 <opqdonut> I've written a couple of cgi programs in haskell, 'twas nice
01:27:24 <shachaf> I've written some CGI programs in bash.
01:27:29 <opqdonut> hehe
01:27:30 <shachaf> A traumatic experience, overall.
01:27:35 <simpson> The Web sucks, learn languages without writing for the Web.
01:27:42 <johnw> let's make mod_yesod
01:27:46 <eikke> any chance hackage2 will have some (automatic) "Tell me in which version this symbol was introduced" feature?
01:28:01 <shachaf> eikke: Maybe hdiff already does something along those lines?
01:28:01 <leroux> simpson: I'm usking haskell for non-web stuff. But I'm starting out in web dev...
01:28:11 <leroux> I haven't done web dev for a few years now.
01:28:12 <johnw> eikke: i'm not even sure that's on anyone's radar, other than maybe the hdiff site
01:28:25 <eikke> hmh, don't know hdiff yet... will check
01:28:41 <leroux> Well, I guess I'll just get back to using python/django...
01:28:42 <mikeplus64> leroux: snap and happstack might be approachable for a beginner, yesod has a book, but i'm still unsure how accessible it is for a newb
01:28:45 <leroux> For web dev...
01:28:54 <leroux> I've seen happstack and yessod.
01:28:56 <shachaf> @where hdiff
01:28:57 <lambdabot> http://hdiff.luite.com/
01:29:01 <simpson> leroux: Don't use Django; use Flask.
01:29:03 <johnw> leroux: one thing Haskell does bring to web dev is some level of consistency, and static type checking
01:29:07 <simpson> leroux: No reason to beat yourself up.
01:29:19 <leroux> Kay, will look into it.
01:29:21 <johnw> the unified approach in Yesod is kind of nice for preventing stupid mistakes
01:29:48 <mikeplus64> leroux: i find snap very nice to use, but i haven't yet created anything very large in it
01:29:55 <johnw> and it uses Fay these days as an approach to the Javascript problem, so you don't have to leave the comfort of Haskell very much
01:30:02 <leroux> My project isn't really large.
01:30:06 <leroux> Just a small application.
01:30:11 <johnw> they all start that way :)
01:30:19 <leroux> Collection of data and plotting. And possibly a login system.
01:30:19 <leroux> xD
01:30:27 <johnw> soon you'll be buying 10,000 nodes on AWS
01:30:33 <Jafet> The ones that start small become large
01:30:34 <leroux> Haha.
01:30:39 <Jafet> The ones that start large disappear in two weeks
01:30:46 <leroux> Mhm.
01:31:02 <leroux> Have you read any of pg's essays?
01:31:10 <mikeplus64> leroux: check out #snapframework, or #yesod or #happstack or all, i'm sure if they're awake they'll help you if you need it
01:31:17 <leroux> Paul Graham (pg)
01:31:17 <johnw> leroux: yes
01:31:28 <shachaf> I think that's off-topic in here.
01:31:31 <leroux> Will definitely join those chans if I need help.
01:31:44 <Jafet> leroux: http://farm1.staticflickr.com/170/439422722_047705186c.jpg
01:32:10 <johnw> lol
01:32:13 <simpson> Heh.
01:32:14 <johnw> "Ages 28 and under"
01:32:23 <leroux> He also says "umm" a bit too much.
01:32:26 <leroux> Anyways.
01:32:35 <leroux> Thanks for the help guys.
01:52:27 <sopvop> what happened in 7.6.1 with infix fixity? cannot mix `BS.cons' [infixr 5] and `BS.snoc' [infixl 5]
01:53:17 <sopvop> Hm, it seems ByteString changed it
01:58:20 <killy9999> hm... am I doing something wrong or the ST monad doesn't work with TypeFamilies extension?
02:02:53 * hackagebot simple-vec3 0.1.0.1 - Three-dimensional vectors of doubles with basic operations  http://hackage.haskell.org/package/simple-vec3-0.1.0.1 (DmitryDzhus)
02:07:53 * hackagebot egison 2.4.5 - An Interpreter and Compiler for the Programming Language Egison  http://hackage.haskell.org/package/egison-2.4.5 (SatoshiEgi)
02:40:13 <Peaker_> Hey, I'm trying to make the FTGL package self-contained (i.e: come with the FTGL c++-side sources, and build them as well)
02:40:30 <Peaker_> all seems to be going well, even a dependent package (graphics-drawingcombinators) can be built, with a working example
02:41:08 <Peaker_> however, when I try to build a dependent of a dependent (lamdu), some of the Haskell .o files fail to build: they claim to be missing the "vtable"/"typeinfo" symbol from FTGL
02:41:19 <Peaker_> (even though there's no dependency on FTGL, just on drawingcombinators which already works)
02:41:33 <Peaker_> also, the typeinfo does seem to be in the library archive about which ghc complains
02:43:35 <rribeiro> Hello folks! I want to know if there's a tool  for searching the hackage for libraries that use some particular GHC extension. There is some kind of tool like that?
02:44:14 <rribeiro> In particular, I'm interested in some example libraries that use the UndecidableInstances compiler Pragma
02:44:24 <gienah> Peaker_: if the C++ is in a shared library you could check the shared libary with: ldd -r libwhatever_the_cxx_shared_lib_is_called.so
02:45:54 <Peaker_> gienah, it's a static archive, and I did check, and they symbol is in there, so it's very weird
02:46:36 <gienah> Peaker_: maybe it might work better if it was a shared lib. wxcore builds C++ stuff.
02:47:16 <Peaker_> hmm it's in there as a defined and as an undefined symbol
02:47:18 * Peaker_ looks into it
02:49:11 <gienah> Peaker_: other things you can do is call the C++ constructors of concrete objects, and the derived objects to get the abstract ones, in order to try to force the vtbls to be included
02:51:44 <Peaker_> c++ complicates everything so much for so little gain :(
02:51:46 <gienah> Peaker_: oops its wxc that builds the C++ stuff (a C++ package in hackage)
02:52:58 <Peaker_> gienah, does wxc build on Windows?
02:53:16 <Jafet> Peaker: they're crazy people using the C ABI to implement totally irrelevant things.
02:53:25 <gienah> Peaker_: I guess it would, but I've never tried it on Windows
02:53:41 <Peaker_> Jafet, who do you mean?
02:54:00 <Jafet> The C++
02:54:28 <Peaker_> I spent the better part of a week getting FreeTypeGL lib to be sane (it sucked!) and build everywhere, and write Haskell bindings. And it works, it's just very slow on one of my 2 machines :(
02:54:37 <Peaker_> FTGL is fast, but C++ which makes it a PITA to build :(
02:57:21 <Peaker_> wxc fails in a peculiar way here: it claims its dependency (wxdirect >= 0.90) which *was* installed successfully, is missing
02:57:36 <Peaker_> ghc-pkg list shows   wxdirect-0.90.0.1
02:57:43 <bartavelle> anybody devised a way to get quickly a binary .deb from my cabal package ? (I don't want to depend on package libraries)
02:57:54 <gienah> Peaker_: it wants wxdirect in your path
02:57:56 <bartavelle> (it is an executable)
02:58:01 <ivanm> bartavelle: there was work on apt-cabal or something IIRC
02:58:10 <ivanm> is there a #debian-haskell ?
02:58:19 <rribeiro> Does anyone know a library on hackage that uses the undecidable instance compiler pragma rather than cgi-undecidable?
02:58:22 <bartavelle> nope
02:58:29 <gienah> ivanm: yeah but not on freenode
02:58:34 <Peaker_> gienah, it is in my path
02:58:35 <ivanm> gienah: ahhh
02:58:58 <Peaker_> ah, when it's in my path it's failing in a different way
02:58:58 <Peaker_> Configuring wxc-0.90.0.4... setup: failed
02:59:22 <Peaker_> ./Setup configure still claims its missing though
02:59:57 <gienah> Peaker_: well, guessing, it also wants wx-config in your path
03:00:49 <Peaker_> what package is that from?
03:02:12 <gienah> Peaker_: well my answer is on Gentoo so may be irrelevant: app-admin/eselect-wxwidgets-1.4
03:02:52 <Peaker_> wxc has its own Setup.hs that builds everything
03:02:59 <gienah> Peaker_: anyway its more likely its from a pkg called wxwidgets or something like that on other opoerating systems
03:03:03 <Peaker_> it doesn't even list the sources in the cabal way
03:03:42 <gienah> Peaker_: yeah, exactly :-) its just a C++ shared lib masquerading as a haskell pkg
03:04:11 <Peaker_> I'll try to keep with the c-sources for a bit, it seems really close
03:04:41 <fmap> rribeiro: what's "cgi-undecidable"?
03:05:06 <fmap> rribeiro: anyway, mtl uses UndecidableInstances
03:05:10 <gienah> Peaker_: well anyway, wxc shows that its possible: it builds a C++ shared lib with lots of dependent shared libs, and ldd -r /usr/lib64/libwxc.so.0.90.0.4 shows it resolves the symbols to everything
03:05:44 <Peaker_> gienah, it's pretty terrible to write a Makefile in .cabal :) If at least they put it in some lib I could import from Setup.hs?
03:05:51 <Peaker_> oops, I mean in my Setup.hs :)
03:06:38 <gienah> Peaker_: I think cabal might have an option to use autotools, I'm not sure, I haven't tried that
03:06:53 <Peaker_> FTGL with autotools doesn't build on Windows at all
03:07:02 <Peaker_> if I just list all the .cpp files and provide a simple config.h it does
03:08:01 <Peaker_> I like FreeTypeGL better, a small C lib. It was written very badly, but it was small enough that in a few days, I fixed it.. there's something slow about it though, on 1 of my machines, and I'm not sure what. It uses vertex shaders, and various buffer/texture uploads. Maybe it's emulated on that machine
03:08:06 <gienah> Peaker_: I guess you probably have seen this blog post about mingw: http://blog.johantibell.com/2011/01/setting-up-haskell-development.html
03:08:58 <Peaker_> gienah, the Haskell Platform actually was enough for me to build most of everything.. didn't need to install mingw. I guess you'd need that for unix and its dependents, but I don't need it yet
03:09:06 <Peaker_> just trying to get OpenGL fonts to work with Windows :(
03:09:38 <rribeiro> fmap: hummm... but mtl needs undecidable instances due to the coverage condition needed by functional dependencies. I'm looking for some library that needs undecidable instances because the defined instances doesn't satisfy the Paterson conditions
03:09:46 <gienah> Peaker_: I was thinking that autotools is more of a unix thing, so it might want more unix type stuff to work on windows
03:10:26 <sopvop> autotools should be burned
03:10:28 <Peaker_> gienah, it's not just missing autotools, I had spent many hours trying to get it to build with its own build system (just the c++ lib)
03:10:35 <Peaker_> it's got tons of troubles..
03:10:47 <merijn> sopvop++
03:10:50 <Peaker_> just listing all the c++ files, however, does seem to build ok
03:11:13 <Peaker_> Except this later: Loading package FTGL-1.400 ... linking ... ghc: /home/peaker/.cabal/lib/FTGL-1.400/ghc-7.6.1/libHSFTGL-1.400.a: unknown symbol `_ZTI18FTSimpleLayoutImpl'
03:11:22 <Peaker_> And now I understand! It's the TH/ghci that's failling to load it
03:11:27 <sopvop> classic http://www.cul.de/images/autotoolscg.jpg
03:11:57 <fmap> bartavelle: did you see cabal-debian?
03:13:02 <Peaker_> gienah, all this time, the problem was in ghci only
03:13:23 <Peaker_> now I need to figure out how ghci differs from ghc at loading libraries
03:15:48 <gienah> Peaker_: I think the way to fix it with ghci is to place the C++ code in a shared library. The reason I think this is there are some bugs for "undefined symbol" that say they will be fixed with the move to "dynamic by default" in ghc >=7.7 like this (not actually directly relevant though, just similar):
03:15:58 <gienah> Peaker_: http://hackage.haskell.org/trac/ghc/ticket/7072
03:16:57 <bxc> to get a haskell wiki account, is emailing nominolo still the right hting to do?
03:17:40 <Peaker_> why does ghci fail with static libs? because it's hard to load a static lib on the fly?
03:17:48 <fmap> rribeiro: any particular reason or you just want to see them?
03:19:07 <rribeiro> fmap: I'm interested in type inference and strategies for lifting these restrictions, on the context of multi-parameter type classes, without using any compiler pragma or extensions like functional dependencies.
03:20:11 <rribeiro> fmap: Since mtl needs undecidable instances because of the coverage condition,  I'm looking for some real code (because, artificial examples, I have a lot of them) that does not follow paterson conditions
03:20:56 <gienah> Peaker_: it seems that for static libs ghci uses its own linker, while as for shared libs (as are built by default with the dynamic by default in ghc >=7.7) it uses the system dynmic linker
03:21:36 <Peaker_> "its own linker"? GHCHQ wrote a linker?
03:22:03 <Peaker_> Damn, I wish TH didn't load ghci and imported *everything*
03:23:11 <gienah> Peaker_: I think they are are over it since moving to dynamic by default :-)
03:23:29 <Peaker_> even then, you don't want TH to hog compile times by loading everything
03:23:50 <Peaker_> how do I tell .cabal to build my lib as a shared one? Only with the manual Setup?
03:24:51 <Maxdamantus> @do [ a | a <- b, f a ]
03:24:51 <lambdabot> [a | a <- b, f a]
03:24:56 <gienah> Peaker_: well I only know of the 2 solutions I mentioned earlier 1) cabal with autotools 2) how wxc does it
03:25:27 <Peaker_> I guess I might have to go the wxc way :-(
03:25:27 <Maxdamantus> Hmm .. there's some `Bool -> a -> [a]' somewhere, isn't there, that works like the filter bit of the list comprehension?
03:25:47 <Maxdamantus> blah True a = [a]; blah False a = []
03:26:06 <Maxdamantus> Meh, I'll just define it myself.
03:27:57 <Laish> i have to following haskell code, and i want to replace "Aa123456" with hex values like "BD9ECFCFCFCFCFCF", how can i do that ?
03:27:58 <Laish> zipWith (\x y -> -(fromIntegral (ord x)) + y - 2) "Aa123456" [0..] :: [Word8]
03:28:22 <fmap> Maxdamantus: list comprehensions use `guard'
03:28:25 <fmap> :t guard
03:28:27 <lambdabot> MonadPlus m => Bool -> m ()
03:28:27 <Maxdamantus> Ah, guard.
03:28:36 <Maxdamantus> Thanks.
03:49:58 <simon> is there curly brace-notation for non-monadic expressions? I'd like to split something across multiple lines in my Happy parser, but the parser it generates has arbitrary whitespace in the code surrounding my generated code.
03:52:18 <simon> is it bad style to define a type in one module and one of its typeclasses in another module?
03:52:57 <byorgey> simon: I don't think I understand the question.  you can split expressions across lines however you like, as long as you don't unindent too far.
03:54:13 <simon> byorgey, the thing is, I have an expression across lines, but Happy inserts spaces on the first of these, so the following lines aren't indented far enough. I don't want to assume exactly how many spaces it indents with and compensate manually for this (I think it's something like two or three tabs), so right now it's just on one line.
03:54:42 <byorgey> oh, I see.
03:55:02 <byorgey> I mean, you can use braces with  let { ... } in ...
03:55:15 <simon> it *is* a let-expression.
03:55:17 <simon> cool.
03:55:24 <byorgey> ah, nice =)
03:55:30 <simon> so let { a = 42; b = 43 } in ...?
03:55:34 <byorgey> yup
03:55:37 <simon> yay.
03:56:00 <byorgey> simon: re: your other question, what do you mean "one of its typeclasses"?  do you mean "one of its type class instances"?
04:10:14 <Peaker> gienah, you still there?
04:10:24 <gienah> Peaker: yeah
04:10:38 <Peaker> trying to do the wx trickery to get a shared lib -- but given that it's doing its own building logic, it skips the include paths addition
04:10:53 <Peaker> gienah, i.e: I depend on freetype2, which has "install-include-dirs"
04:11:04 <Peaker> gienah, and now it doesn't know to add the -I to my FTGL compilation
04:12:09 <gienah> Peaker: I'm not sure if adding the --verbose=3 option to the configure gives any more hints when using the custom Setup.hs, you could try it
04:13:47 <Sculptor> hi!
04:14:10 <sp3ctum> is it possible to not lose my local state when :loading some code in a ghci session?
04:14:19 <sp3ctum> it's an annoyance to type all of it back again
04:14:29 <gienah> Peaker: on unix this gives the freetype include flags: freetype-config --cflags
04:14:42 <Peaker> gienah, no no, I need the includes to come from the standalone haskell package installed
04:14:50 <Peaker> I don't want to depend on freetype being installed separately
04:15:01 <Peaker> gienah, i.e: I added "install-includes" to freetype2.cabal
04:15:22 <Peaker> gienah, so now if I depend on it, cabal automatically adds "-I ~/.cabal/.../freetype2/include"
04:15:31 <Peaker> gienah, but that's somehow broken by the custom Setup.hs
04:17:56 * hackagebot hoodle-render 0.2 - Hoodle file renderer  http://hackage.haskell.org/package/hoodle-render-0.2 (IanWooKim)
04:18:02 <gienah> Peaker: wxcore does evil stuff in Setup.hs to find the include directory for wxc
04:18:50 <Peaker> hmm.. I just need to figure out what cabal normally does to get the include dirs from the installed package info
04:18:57 <Peaker> and then see why it gets subverted by the custom setup
04:22:58 * hackagebot hoodle-core 0.8 - Core library for hoodle  http://hackage.haskell.org/package/hoodle-core-0.8 (IanWooKim)
04:23:00 * hackagebot hoodle 0.1.0.0 - Executable for hoodle  http://hackage.haskell.org/package/hoodle-0.1.0.0 (IanWooKim)
04:31:24 <bartavelle> fmap (about cabal-debian) yes, but it doesn't build on my computer
04:39:39 <bhurt42> Got a stupid newbie question if anyone is around this early in the morning.
04:40:17 <sipa> bhurt42: just ask your question - maybe someone wants to answer, maybe not, but it's not morning everywhere :)
04:41:29 <hpaste> frontendloader pasted “pattern guards?” at http://hpaste.org/79154
04:41:49 <frontendloader> import Data.Char
04:41:49 <frontendloader> f :: Char -> Bool
04:41:49 <frontendloader> f x = toUpper x < 'M'
04:41:49 <frontendloader> g :: String -> Bool
04:41:50 <frontendloader> g x = length firstHalf > length secondHalf where
04:41:52 <frontendloader> 	firstHalf = [y | y <- x, f y]
04:41:54 <frontendloader> 	secondHalf = [y | y <- x, not (f y)]
04:42:36 <frontendloader> http://hpaste.org/79154 hope all that didn't paste in here
04:43:04 <Botje> frontendloader: and what is your specific question?
04:43:48 <frontendloader> The question is why wouldn't pattern matching work in guards like that? on line 15 and 22 a [Char] is being recieved when I thought it would be a Char
04:44:10 <Botje> frontendloader: because functions only have one type.
04:44:11 <frontendloader> so the functions on line 16 and 23 are throwing errors because they expect Char
04:44:20 <bhurt42> So, I'm trying to do this: http://pastebin.com/uN9niEzT  and failing.  I want to create a Rangeable class, which is Ord and Enum, and if the type is also Bounded, supply the obvious implementations.  And then also supply the obvious implementation for unbounded Integers.  What am I doing wrong?
04:44:31 <Botje> you cannot accept (x:xs) :: [Char] on line 12 and x :: Char on line 15
04:45:02 <bhurt42> When I try to call has_next (3 :: Integer), I get a class conflict error.
04:45:57 <bhurt42> I'm pretty sure my problem is that I'm not declaring the default Bounded implementation correctly.
04:46:37 <frontendloader> isn't that the premise of pattern matching though?
04:46:54 <Botje> frontendloader: you can only pattern match on values of the same type
04:47:02 <frontendloader> I guess thats matching a list with a single element
04:47:48 <Botje> no, matching a list with the pattern 'x' will bind the entire list to the variable x
04:48:06 <frontendloader> oh
04:48:15 <frontendloader> so I only need to match (x:xs) and the empty list
04:48:30 <fmap> bhurt42: by "class conflict error" you mean overlapping instances?
04:48:32 <Botje> yes.
04:48:44 <bhurt42> fmap: yes
04:48:57 <fmap> bhurt42: `Rangeable a' instance will overlap with any other anyway
04:49:51 <fmap> bhurt42: problem is nobody cares what's on the left side of => when instance is selected
04:50:41 <bhurt42> So, is there a way to do what I'm trying to do?
04:51:04 <fmap> bhurt42: solution is "never use `instance C1 a => C2 a where' things"
04:52:46 <bhurt42> I want to declare that all Bounded a are also Rangeable a.  Sounds like this may not be possible.  :-(
04:53:10 <merijn> bhurt42: The problem is that there's no way to prevent a custom Rangeable instance being declared for a type that is Bounded and then which is the compiler supposed to pick?
04:53:59 <merijn> bhurt42: For example, Int is Bounded so it'd be an instance of Rangeable, yes? Now I write "instance Rangeable Int where ..." now what is the compiler supposed to do?
04:54:35 <bhurt42> merijn: Wouldn't that also be a problem if I provided Rangeable Int, Rangable Char, etc. instances?
04:54:54 <bhurt42> merijn: I thought the solution to that was newtype.
04:55:10 <bhurt42> Er, newtype deriving.
04:55:20 <fmap> bhurt42: you can make `newtype Wrapped a = Wrapped a' and then `instance (Bounded a, ...) => Rangeable (Wrapped a) where'
04:55:25 <fmap> it's rather common trick
04:57:07 <merijn> bhurt42: Well, no. Or yes, someone could define a custom implementation that breaks, which is why orphan instances are considered Bad (TM)
04:57:44 <merijn> bhurt42: Where an orphan instance is a typeclass instance declared in a file which does *not* A) define the datatype we're defining the instance for or B) define the typeclass whose instance we're defining
04:58:53 <merijn> bhurt42: Which is fine for built in types (i.e. all their Rangeable instances will be in your typeclass file anyway). But suppose I import your rangeable code and implement an instance for my datatype, but my datatype was also Bounded, now I get weird behaviour I don't understand
04:59:19 <merijn> (Since clearly your file isn't expected to export an implementation for MyCustomType)
05:00:28 <merijn> bhurt42: It's a bit inconvenient, yes. But the other alternative would be a pain too...
05:00:34 <dropdrive> The pipes tutorial suggests that perhaps "lazy IO was a bad idea" -- can anyone elaborate on this?  Does it mean, say, lazy ByteStrings?
05:00:47 <merijn> dropdrive: It means things like hGetContents
05:01:32 <bhurt42> merijn: as a general case, I see what you're saying.  In this case, I just need to know if I can call succ and pred on the values without throwing a runtime error.  I'm mildly surprised this behavior isn't in Enum.
05:01:32 <merijn> dropdrive: Which lazily reads the contents of an entire file. As a result you have no control over when the file handle is closed, resulting in weird behaviour like reading lots of files randomly resulting in "to many open file descriptor" errors
05:01:45 <merijn> :t succ
05:01:46 <lambdabot> Enum a => a -> a
05:01:47 <b__> can I see fixity of an operator in ghci?
05:01:57 <merijn> b__: :info I think
05:02:18 <dropdrive> merijn: I see, thanks.
05:02:21 <merijn> bhurt42: Ah, you might want to use spoon (although some people have philosophical objections to it)
05:02:26 <b__> ah yeah but that doesn't show me anything for certain self-defined operators. This means it is default?
05:02:46 <merijn> bhurt42: spoon has functions of type "a -> Maybe a" in case the a can throw exceptions
05:03:13 <merijn> bhurt42: It doesn't show anything for operators with the default fixity (which I think is infixl 9?)
05:03:16 <merijn> eh
05:03:23 <merijn> b__: Last line was for you
05:03:32 <b__> ah thanks =]
05:03:39 <merijn> b__: Check the report to be sure what the default is
05:04:53 <bhurt42> merijn: Thanks.  But I'm strongly considering just only supplying type classes for Int and Integer (which are the only types I really care about for what I'm doing), and moving forward.
05:06:57 <hpaste> frontendloader pasted “pattern guards?” at http://hpaste.org/79156
05:07:44 <frontendloader> http://hpaste.org/79156 not quite sure why it expects [a0] and [a1]
05:09:17 <Botje> frontendloader: firstHalf is a function.
05:09:24 <Botje> frontendloader: what is it applied to on line 11 ?
05:10:12 <frontendloader> nothing at all :(
05:10:16 <Botje> frontendloader: because that is what your compiler is complaining about.
05:10:23 <frontendloader> I don't know how I missed that
05:10:30 <Botje> it expects a list ([a0] or [a1]) but instead you give it a function [Char] -> [Char]
05:12:26 <frontendloader> I don't know why I thought that'd work
05:12:59 * hackagebot language-puppet 0.3.2 - Tools to parse and evaluate the Puppet DSL.  http://hackage.haskell.org/package/language-puppet-0.3.2 (SimonMarechal)
05:14:03 <merijn> frontendloader: It happens :)
05:16:16 <mysticc> @pl \a b -> 2*a + b
05:16:18 <lambdabot> (+) . (2 *)
05:17:33 <mikeplus64> is there a way to "assert" (with a Constraint) that two types are *not* equal?
05:17:52 <mikeplus64> or is just calling the two types different names enough?
05:19:00 <LucaS05> hi. i'm defining the lenght function with the foldr http://hpaste.org/79157 but i got that error. what's the problem?
05:19:19 <johnlong> I know I should use Cabal over a simple Makefile in most cases, but my program is a literate Haskell program. Is there a way for Cabal to build the PDF as well?
05:19:48 <dcoutts> johnlong: you'd have to add that as a bit of custom code in the Setup.hs, using the postbuild hook
05:20:01 <mikeplus64> LucaS05: you have the arguments the wrong way around
05:20:06 <mikeplus64> you probably want (\_ x -> x + 1)
05:20:07 <johnlong> dcoutts: ok thanks, do you know of any examples i could find anywhere?
05:20:10 <dcoutts> johnlong: e.g. directly or by calling out to the makefile
05:20:44 <int-e> or turn it upside-down and invoke cabal from a makefile?
05:21:28 <dgpratt> getting a compile error in acid-state 0.8.1 on Windows...
05:21:35 <dgpratt> in this file: http://hub.darcs.net/Lemmih/acid-state/browse/src-win32/FileIO.hs
05:21:43 <LucaS05> thanks mikeplus64 !
05:22:14 <merijn> mikeplus64: If you find out, let me know. I've needed type inequality in the past too.
05:22:26 <merijn> mikeplus64: I think type inequality may not be decidable, though :\
05:22:35 <dgpratt> that file references a function tryE that I cannot find anywhere (nor can GHC); any ideas what it refers to?
05:23:48 <mikeplus64> merijn: i guess the type system is only any good at stating what's possible -- not what isn't
05:24:19 <Peaker> dcoutts, hey, you there? I'm trying to figure out where in Cabal's sources, Cabal is adding the includeDirs from the InstalledPackageInfo to the lib's build info
05:24:39 <Peaker> dcoutts, I have a hooked Setup.hs that's somehow not finding the dependencies' include dirs in the library's build info
05:24:41 <dcoutts> Peaker: almost certainly in the D.S.GHC module
05:25:49 <Peaker> D.S.GHC just assumes that is already in the library's build info
05:26:49 <dcoutts> Peaker: oh actually, it's not done by cabal at all, it's part of the package, so ghc does it
05:27:10 <dcoutts> Peaker: see the "include-dirs:" for any registered package
05:27:27 <alpounet> dgpratt, http://stackoverflow.com/questions/13260622/unable-to-cabal-install-acid-state-on-haskell-platform-2012-2-0-0-windows-xp
05:27:38 <Peaker> dcoutts, hmm.. what could cause a Custom Setup.hs that builds a shared dll from C++ sources on its own (as wxc does) not to get these include paths?
05:28:20 <Peaker> oh, I think I know. it just calls gcc instead of ghc -c
05:28:23 <dgpratt> alpounet: thanks
05:28:31 <dcoutts> Peaker: actually my mistake, you're not talking about dependent packages here, you just mean the include dirs of the package itself
05:28:42 <Peaker> dcoutts, no no, I did mean the dependent packages' includes
05:28:49 <dcoutts> oh
05:28:54 <dcoutts> then that's automagic, by ghc
05:28:55 <Peaker> dcoutts, thanks, I understand what's going on now :)
05:29:05 <dcoutts> Peaker: check the registration info for the package in question
05:29:50 <Peaker> dcoutts, I am trying to use some hacky Setup.hs someone made that makes a DLL/so from c++ sources, and it used gcc directly on the C++ files in the package, which doesn't get the -I properly
05:30:04 <dcoutts> ah
05:33:08 <Peaker> now I need to figure out how to add the -package-id that cabal adds to ghc, in the ugly Setup.hs
05:35:28 <bbbbsasadsad> hello
05:35:39 <bbbbsasadsad> clicking? ;-)
05:35:45 <bbbbsasadsad> or typing ;-)
05:35:46 <pranavrc> helloh
05:36:00 <bbbbsasadsad> how to get first character of word "hello"
05:36:06 <bbbbsasadsad> fst "hello" doesn't work
05:36:50 <pranavrc> head "hello"
05:36:52 <Entroacceptor> bbbbsasadsad: what is the type of "hello"?
05:36:59 <pranavrc> fst is for tuples
05:37:00 <Entroacceptor> :t fst
05:37:01 <lambdabot> (a, b) -> a
05:37:03 <bbbbsasadsad> this is a table of characters
05:37:13 <Entroacceptor> :t "hello"
05:37:14 <bbbbsasadsad> ok
05:37:15 <lambdabot> [Char]
05:37:17 <bbbbsasadsad> first "hello" ?
05:37:25 <bbbbsasadsad> :t first
05:37:27 <lambdabot> Arrow a => a b c -> a (b, d) (c, d)
05:37:27 <Philonous> :t first
05:37:28 <lambdabot> Arrow a => a b c -> a (b, d) (c, d)
05:37:31 <pranavrc> :t head
05:37:33 <lambdabot> [a] -> a
05:37:35 <bbbbsasadsad> :t head
05:37:36 <lambdabot> [a] -> a
05:37:38 <bbbbsasadsad> :t tail
05:37:40 <lambdabot> [a] -> [a]
05:37:43 <Philonous> bbbbsasadsad:  Don't use head.
05:37:45 <bbbbsasadsad> ok :-)
05:37:50 <Philonous> bbbbsasadsad:  Pattern match instead
05:38:33 <bbbbsasadsad> ok, Is there any search command in tryhaskell.org?
05:38:44 <mikeplus64> case s of (h:_) -> h; _ -> ... do something smarter than error "empty list" ...
05:38:47 <bbbbsasadsad> I have connected here from that interpreter in web
05:39:02 <mikeplus64> bbbbsasadsad: use hoogle
05:39:05 <Philonous> > (\s -> case s of [] -> Nothing; (s:ss) -> Just s) "hellow" -- bbbbsasadsad
05:39:06 <lambdabot>   Just 'h'
05:39:27 <mikeplus64> bbbbsasadsad: http://www.haskell.org/hoogle
05:39:31 <bbbbsasadsad> ok
05:39:38 <Philonous> > listToMaybe "hello"
05:39:40 <lambdabot>   Just 'h'
05:39:45 <bbbbsasadsad> thanks for help ;-)
05:39:59 <bbbbsasadsad> you are very helpful
05:40:02 <Peaker> listToMaybe would better be named safeHead
05:40:30 <Peaker> and while I'm ranting:  fromMaybe should have been in the Prelude to discourage fromJust
05:42:05 <Philonous> Peaker:  "listToMaybe" would better be named "head"
05:42:12 <Peaker> heh yeah :)
05:42:42 <sclv> and "head" would be better named "wtfDon'tUseMeUseTheSafeOneHead"
05:43:14 <sclv> not exactly unsafe
05:43:31 <sclv> but more of a "seriouslyIMeanSeriouslyReally" namespace mabye
05:43:33 <sclv> maybe
05:44:12 <Philonous> There should be a naming convention for partial functions.
05:44:28 <typoclass> Philonous: hm, good idea actually
05:45:21 <byorgey> too bad we can't use ! in identifiers
05:45:29 <aristid> Philonous: could put a partial in front of the name :D
05:45:31 <byorgey> head!  tail!  etc.
05:45:33 <aristid> partialHead
05:45:33 <Philonous> Or - and / for that matter
05:45:43 <sclv> ! reads to me like scheme for mutatey things
05:45:43 <Nereid> what's partial about - ?
05:45:45 <byorgey> ooh, or maybe an interrobang
05:45:55 <Philonous> byorgey:  That looks like it's an in-place version
05:45:57 <sclv> !? is nice tho
05:46:01 <Peaker> dcoutts, does Cabal know how to build c-sources as a shared lib?
05:46:02 <byorgey> conveying a subtle incredulity that you would even contemplate using such a function
05:46:05 <aristid> "you can't type interrobang? well, don't use partial functions then"
05:46:13 <sclv> it conveys exactly the "really? really?"
05:46:15 <Peaker> or is the shared-lib support only for building Haskell libs?
05:46:15 <byorgey> hahaha exactly
05:46:23 <dcoutts> Peaker: it knows how to build C sources to include into a Haskell shared lib
05:46:51 <dcoutts> Peaker: which explains why we can build haskell shared libs :-)
05:46:57 <dcoutts> (since so many packages have bits of C code)
05:46:57 <Peaker> dcoutts, my problem is that I'm building C++ sources, it's generating a static archive from it - and then when ghci tries to load it, it fails due to inter-dependencies in the .o's in the .a
05:47:05 <Philonous> Nereid:  Nothing, I just want to write identifiers with hyphens instead of camel case.
05:47:12 <Philonous> Nereid:  and "call/cc"
05:47:15 <dcoutts> Peaker: ghci cannot in general load C++ .a files
05:47:17 <byorgey> head‽  tail‽
05:47:25 <Peaker> dcoutts, why?
05:47:26 <typoclass> yes, the interrobang convention will help us greatly with correcting the impression that haskell is a weirdo off-the-wall language
05:47:37 <dcoutts> Peaker: C++ does mad things with the linker :-)
05:47:47 <byorgey> typoclass: who said anyone was interested in correcting such an impression‽
05:47:48 <sclv> no standard abi
05:47:54 <Peaker> dcoutts, and ghci has its own linker?
05:47:57 <dcoutts> Peaker: I tried adding support once, so we could load the LLVM packages, too much madness
05:48:16 <dcoutts> Peaker: only sensible solution is to make C/C++ shared lib
05:48:17 <Philonous> head⸮
05:48:25 <byorgey> (and who said it was incorrect? =)
05:48:39 <int-e> so where's the proposal to make ‽ the leftward application operator that so many people like? ;)
05:48:54 <sclv> haha i like it!
05:49:34 <Peaker> dcoutts, that's what I'm trying to, via cabal
05:49:36 <fmap> > [] ^? _head
05:49:39 <lambdabot>   Nothing
05:49:44 <Peaker> dcoutts, (I want cabal to make my shared lib from my C++ sources)
05:50:00 <Peaker> so I'm using wxc's custom Setup.hs
05:50:07 <int-e> @type _head
05:50:08 <lambdabot> (Applicative f, Indexable Int k) => k (a -> f a) ([a] -> f [a])
05:50:08 <Peaker> now need to add the -package-id args though so it finds the include's of deps
05:50:10 <dcoutts> Peaker: Cabal has no support for building separate C shared libs, just compiling C code into the haskell lib
05:50:32 <typoclass> fmap: so you suggest ^? as an alternative for !? ... interesting idea
05:50:35 <Peaker> dcoutts, I don't mind if the C code and Haskell code of the same package all goes into the same shared lib
05:50:36 <typoclass> =)
05:50:36 <dgpratt> does lambdabot (or any other bot in this channel) have a 'seen' function?
05:50:41 <Peaker> dcoutts, afaiu, it should work?
05:50:53 <typoclass> dgpratt: i don't think so, no
05:51:05 <dcoutts> Peaker: it should, yes
05:51:12 <sclv> :-( miss preflex
05:51:14 <dgpratt> by the way, whatever happened to preflex? get tired of living in lb's shadow?
05:51:25 <sclv> lb used to have a seen to back in the day
05:51:27 <dgpratt> typoclass: k, thanks
05:52:04 <Entroacceptor> nickserv has something like it
05:52:30 <Peaker> dcoutts, what's the Library option to enable shared linking?
05:52:32 <dgpratt> Entroacceptor: oh?
05:53:30 <bbbbsasadsad> is it possible to have multiline code in tryhaskell.org interpreter?
05:53:32 <Peaker> dcoutts, ghc-options: -dynamic ?
05:53:45 <byorgey> @remember ziarkaen I'm thinking I can kill two birds with one stone by learning Haskell while producing a website, but all the birds are still alive at the moment.
05:53:45 <lambdabot> Okay.
05:54:01 <bbbbsasadsad> I want to write Factorial function
05:54:12 <aristid> Peaker: cabal seems to complain that ghc-options is not a valid configuration file entry. maybe my version of cabal is too old for that?
05:54:31 <Laish> newbe Q: what is [0..] ?
05:54:31 <fmap> typoclass: nah, ^? is safe, but there is always ^?! ;)
05:54:33 <aristid> oh wait nevermind
05:54:40 <aristid> was thinking you meant something else.
05:54:40 <typoclass> fmap: =D
05:54:42 <Peaker> ghc-flags I guess?
05:54:47 <byorgey> bbbbsasadsad: you can write multiple declarations on one line using semicolons.  fact 0 = 1; fact n = ...
05:54:57 <aristid> Peaker: no, i believe ghc-options is right in that context
05:55:03 <bbbbsasadsad> ok
05:55:09 <aristid> Peaker: for some reason i thought you meant ~/.cabal/config
05:55:34 <typoclass> aristid: wasn't it "with-ghc-options" or something ... i can never remember
05:55:42 <jasonk> Hi. cabal check tells me off for not having a Setup.hs. What is the point of this file? I can configure, build and install my app without it, just using the cabal command. Why do I need a Setup.hs?
05:55:51 <aristid> typoclass: it's also undocumented, so i have no idea:P
05:56:20 <Peaker> dcoutts, It seems to recursively need the deps to be compiled with -shared too :(
05:57:36 <robert__> hello
05:58:14 <bbbbsasadsad> fact 0 = 1; fact n = fact (n - 1) * n;  fact 4; doesn't work in tryhaskell.org
05:58:49 <bbbbsasadsad> i get parse error on input '='
05:58:49 <aristid> that's because it's not valid
05:59:05 <bbbbsasadsad> ;-) but why?
05:59:16 <aristid> > let fact 0 = 1; fact n = fact (n - 1) * n in  fact 4
05:59:18 <lambdabot>   24
05:59:31 <bbbbsasadsad> hmm
05:59:43 <aristid> bbbbsasadsad: you can't mix declarations and expressions, and tryhaskell only allows expressions.
05:59:44 <bbbbsasadsad> I gues that there is some sort of problem in my chrome browser
05:59:52 <artiq> How do you write the fucntion "f = filter . flip elem" using list comprehension?
05:59:55 <bbbbsasadsad> ah
05:59:59 <bbbbsasadsad> ok
06:00:02 <Cale> bbbbsasadsad: Try the version with let/in
06:00:36 <bbbbsasadsad> works ;-)
06:00:39 <aristid> like tryhaskell, lambdabot also only allows expressions.
06:00:47 <bbbbsasadsad> so in is execution part and let is declaration part
06:00:55 <copton> artiq: homework?
06:01:09 <artiq> no
06:01:22 <Martty> who the heck has haskell homework?!
06:01:32 <copton> Martty: :) true
06:01:35 <aristid> bbbbsasadsad: let ... in allows you to embed declarations in an expression, yes
06:01:35 <fmap> jasonk: the point of this file (on of them anyway) is to have an ability to install your app even without cabal-install
06:01:47 <fmap> s/on /one /
06:01:59 <Cale> Martty: Quite a few people -- there are a number of universities which use it to teach computer science.
06:02:00 <Saizan> Martty: some unis do use haskell in their courses
06:02:21 <Martty> that i know of .. but homework?!
06:02:36 <jasonk> fmap: but I thought it depends on the cabal libraries anyway? and who doesn't have cabal installed?!
06:02:43 <Martty> what a bizarro world
06:02:51 <Cale> artiq: Let's expand that a bit:  f xs = filter (flip elem xs), so f xs ys = filter (flip elem xs) ys = [y | y <- ys, flip elem xs y] = [y | y <- ys, elem y xs]
06:02:56 <strebe> Martty: most university classes have homework
06:03:00 <jasonk> fmap: also, do I therefore need to specify all my dependencies etc again in Setup.hs?
06:03:23 <Martty> cute
06:03:26 <Saizan> yeah, that university classes have homework is bizarre for me too, but apparently it's common in e.g. the US
06:03:35 <Martty> i guess you hand it in later.. and then some guy grades it
06:03:43 <jasonk> Martty: are you in the uk? in the uk we generally use homework for school children, and say coursework for university. in the us they same homework for all stages of education
06:03:50 <Martty> ah
06:03:52 <Cale> Yeah, usually a TA if not the prof.
06:03:57 <fmap> jasonk: Cabal library is separate thing from cabal-install; Cabal library is ditributed with ghc, while cabal-install is not
06:04:06 <Martty> but like.. coursework is more like fully fledged assignments that take some weeks
06:04:17 <Cale> Martty: Yeah, so is homework in this case.
06:04:24 <strebe> Martty: depends on the class and university :/
06:04:25 <jasonk> fmap: ok, got it. what do i do about specifying all my warning options, dependencies etc in Setup.hs?
06:04:32 <Cale> (typically)
06:04:38 <Martty> okay. homework it is :D
06:04:57 * Martty mutters something about babysitting universities
06:05:29 <strebe> Martty: yes, some very much do
06:05:43 <fmap> jasonk: I wouldn't care about his much, just do something along the lines of "import Distribution.Simple; main = defaultMain"
06:06:27 <jasonk> fmap: but then if i ignore all dependencies and so on, surely it's going to be unlikely to use the Setup.hs. which again makes me think, what's the point?
06:07:27 <Cale> http://thatsmathematics.com/blog/wp-content/uploads/2012/09/mathgen-1389529747.pdf -- lol, apparently this was actually published in "Advances in Pure Mathematics"
06:08:04 <jasonk> Matty: in a UK context, homework is work that we would prepare for a tutorial or a supervision in your college with your tutor
06:09:01 <strebe> Cale: is that computer-generated?
06:09:43 <strebe> ah, given the url, I guess it is
06:10:34 <alpounet> Cale, no way!
06:10:37 <alpounet> really?
06:10:39 <Martty> wtf
06:10:39 <yitz> too bad '⚠' is a symbol character
06:11:19 <Cale> http://thatsmathematics.com/blog/mathgen
06:12:19 <Cale> http://thatsmathematics.com/blog/archives/102
06:12:41 <Cale> (I had to find that, my friend only linked me to the actual paper in his email)
06:13:00 <fmap> jasonk: well, `runhaskell Setup.hs configure --user' will tell you what dependencies are missing, you can install them separately (again with only Setup.hs)
06:13:54 <fmap> jasonk: It's not a big deal, anybody may write ad-hoc Setup.hs for your package anyway
06:14:04 <alpounet> this is sick
06:15:21 <eikke> Cale: that's... just sad
06:16:22 <Peaker> dcoutts, got my shared lib of C++ code to build with the custom Setup.  Now it's trying to install the ordinary .a filename which doesn't exist :(
06:17:53 <Crd1> > :type flip
06:17:54 <lambdabot>   <hint>:1:1: parse error on input `:'
06:18:16 <Crd1> flip :: (a -> b -> c) -> b -> a -> c
06:20:28 <Crd1> I don't understand the type signature of flip
06:20:32 <Crd1> can anyone help pls?
06:20:57 <Iceland_jack> flip :: (a -> b -> c) -> (b -> a -> c)
06:20:59 <Iceland_jack> does that help?
06:21:24 <Crd1> hmm
06:21:39 <Crd1> I can see what the function does, it reverses the arguments
06:21:41 <Crd1> but
06:21:43 <Iceland_jack> yeah
06:22:09 <Crd1> flip ((-) 5 4)
06:22:12 <Cale> Crd1: So let's take a look at the code and infer the type by hand
06:22:12 <Iceland_jack> Crd1: are you familiar with `take'?
06:22:15 <Crd1> Why wouldn' tthe above work
06:22:19 <Crd1> yup
06:22:30 <mm_freak> Crd1: flip (-) 5 4
06:22:39 <mm_freak> Crd1: (flip (-)) is the function
06:22:39 <Cale> Crd1: Because you're passing one argument to flip which is the number 1
06:22:44 <Iceland_jack> take :: Int -> [a] -> [a]
06:22:51 <Cale> flip f x y = f y x
06:22:52 <Iceland_jack> flip take :: [a] -> Int -> [a]
06:22:57 <mm_freak> Crd1: (flip (-)) 5 4 is the applied function
06:23:17 <Iceland_jack> > flip take "testing" 3
06:23:19 <lambdabot>   "tes"
06:23:22 <mm_freak> and because application is left-associative that's the same as flip (-) 5 4
06:23:25 <Iceland_jack> > take 3 "testing"
06:23:27 <lambdabot>   "tes"
06:23:32 <Crd1> Ah I see
06:23:34 <Crd1> thanks
06:23:38 <Iceland_jack> No problem
06:23:49 <mm_freak> no problem =)
06:23:53 <Cale> flip (-) 5 4 = (-) 4 5
06:24:22 <Cale> Crd1: Ah, so does the type signature make sense now?
06:24:25 <Cale> :t flip
06:24:27 <lambdabot> (a -> b -> c) -> b -> a -> c
06:24:57 <Crd1> Cale: Yup, that was really clear =) thanks
06:25:35 <yitz> @src flip
06:25:36 <lambdabot> flip f x y = f y x
06:26:24 <Iceland_jack> flip is generally useful for higher-order functions
06:26:31 <Iceland_jack> > map (flip take "testing") [1,2,3,4]
06:26:32 <lambdabot>   ["t","te","tes","test"]
06:27:16 <Crd1> wow, cool!
06:28:01 <yitz> Iceland_jack: it's also useful for evalState, which everyone agrees should have been written the other way, but we won't get into that here
06:28:35 <Iceland_jack> haha, yes it's also useful for badly thought out functions
06:32:20 <mm_freak> the problem is that most people write:  newtype State s a = State { runState :: s -> (a, s) }
06:32:56 <`ramses_> mm_freak: how is that the problem?
06:33:27 <Cale> I'm not sure that it should be the other way. Obviously the flipped version has a bit of a syntactic advantage in many cases, but I think the existing one does follow the rule that its parameters are in order of increasing expected variation.
06:36:59 <mm_freak> `ramses_: it's not a "problem"
06:37:16 <mm_freak> it's just unfortunate that you have to flip runState all the time
06:37:56 <mm_freak> in my own transformer library i called that one "getState" and wrote a separate flipped runState function
06:40:08 <`ramses_> mm_freak: ah ok, I haven't used State enough to have experienced that. But I guess I will then
06:42:26 <mm_freak> nowadays i hardly use State/StateT at all
06:42:53 <mm_freak> only sometimes for random number generation, because the System.Random interface matches the State transition function
06:43:08 <mm_freak> getRandom = state random
06:43:16 <mm_freak> getRandomR = state . randomR
06:44:00 <aristid> :t state random
06:44:01 <lambdabot> (MonadState s m, RandomGen s, Random a) => m a
06:44:06 <`ramses_> what's the alternative then? Or do you just not encounter problems which require state
06:44:09 <aristid> mm_freak: that's a neat trick
06:44:43 <mm_freak> `ramses_: i either use recursion or locally stateful abstractions like Auto or Wire
06:44:50 <killy9999> what does CSE stand for? It's related to optimisations done by GHC
06:45:06 <mm_freak> killy9999: rather optimizations /not/ done by GHC mostly =)
06:45:09 <aristid> it would be kind of surprising if the author of netwire didn't use Wire :D
06:45:11 <mm_freak> Common Subexpression Elimination
06:45:14 <killy9999> aaa
06:45:15 <killy9999> right
06:45:22 <killy9999> this makes sense
06:45:39 <mm_freak> killy9999: in x^2 + x^2 you can mostly expect x^2 to be evaluated twice
06:46:07 <mm_freak> aristid: yeah, that would be sad =)
06:46:17 <mm_freak> i didn't write it for fun =)
06:46:22 <mm_freak> well, actually i did
06:46:29 <aristid> not _just_ for fun:)
06:46:38 <killy9999> I'm looing through the list of bugs in GHC and stumbled upon this
06:46:58 <killy9999> man, it seems impossible to start developing GHC....
06:48:02 <killy9999> build system itself is enormous
06:48:32 <mm_freak> killy9999: start with simple bugs like typos and the like just to introduce yourself to the source tree
06:49:32 <killy9999> mm_freak: I checked out the sources recently and am reading commentary on the wiki
06:49:46 <killy9999> but it just seems impossible...
06:50:10 <killy9999> barrier of entry IS high
06:50:27 <killy9999> so, I'm looking through the tickets to find something easy
06:51:56 <killy9999> but it's impossible to fix anything without knowing how to compile GHC, run validation and so on
06:52:33 <Crd1> Just to confirm, for the flip type signature, (a -> b -> c) -> b -> a -> c
06:52:47 <Crd1> (a -> b -> c)  refers to (-) right?
06:52:58 <Crd1> flip (-) 5 4
06:53:28 <Saizan> yep
06:54:02 <Iceland_jack> Crd1: It's probably better to use a function that doesn't have the same type signature before and after flipping
06:54:06 <dgpratt> I think it may be time for me to finally accept defeat
06:54:39 <dgpratt> I've been trying to get a fay-based project to build (on Windows) using cabal-dev
06:54:47 <Peaker_> after struggling with a C++ build for *really* long I'm really tempted to translate the C++ to C
06:54:47 <mm_freak> killy9999: get GHC to compile first
06:54:56 <dgpratt> so close, it seems, but no
06:54:57 <Crd1> hmm
06:55:41 <adnam> dgpratt: what's the issue on windows?
06:55:51 <killy9999> mm_freak: I did that once :)
06:56:06 <killy9999> I'm yet to figure out how to customize the build so it doesn't take 1,5h
06:57:15 <dgpratt> adnam: I've had some problems due to the platform, but mostly fay is not cabal-dev compatible, it appears
06:57:52 <dgpratt> not surprising since fay is still very experimental
06:58:02 <JamesJRH> Hi, how do I do /* this sort of comment */ in Haskell?
06:58:19 <`nand`> JamesJRH: {- like this -}
06:58:25 <JamesJRH> Thanks.
06:58:36 <adnam> dgpratt: i use cabal-dev when i work on fay, but you need to cabal install it once as well
06:59:08 <killy9999> anyway, is there IRC channel for GHC devs?
06:59:33 <kranius> #ghc afaik
07:01:45 <dgpratt> adnam: ok thanks (was hoping to avoid that -- oh well)
07:01:50 <adnam> dgpratt: perhaps this issue will be magically solved once we get cabal sandboxing
07:02:21 <startling> If I write an nth-fibonacci-number by first writing a list of fibonacci numbers, isn't it automagically memoized?
07:02:29 <dgpratt> adnam: the more time passes, the greater my expectations of sandboxing :)
07:04:03 <dgpratt> adnam: when you say 'when i work on fay' do you mean *using* fay, or do you literally mean that you work *on* fay?
07:04:43 <adnam> both!
07:05:19 <Crd1> Iceland_jack: Can you give me some examples of functions which don't have the same type signature before and after flipping pls
07:05:49 <Iceland_jack> Crd1: I already did
07:05:55 <Crd1> oh
07:06:23 <Crd1> Just saw
07:06:25 <Crd1> thanks
07:06:30 <Iceland_jack> no problem
07:06:51 <dgpratt> adnam: it's quite a sexy project, I think
07:08:40 <adnam> :) yeah, the ffi is probably the sexiest
07:08:55 <dgpratt> adnam: agreed
07:10:27 <meyersh> Reading http://www.haskell.org/onlinereport/derived.html#sect10.1 , what is _|_ ?
07:11:22 <int-e> meyersh: "bottom", an undefined value, representing non-termination and various errors.
07:12:22 <artiq> What is the difference between writing f x = map map x and f x = map (map x)?
07:12:41 <int-e> artiq: the former is (map map) x.
07:12:41 <meyersh> int-e: Thanks!
07:13:08 <typoclass> artiq: it groups the other way. "map map x" is "(map map) x", the other thing obviously is "map (map x)"
07:14:26 <int-e> meyersh: note that the value of 'undefined' is, in fact, _|_. So you can think of it as (1,_|_) == (2,_|_)  ==> False
07:15:48 <artiq> Could you perhaps give me a call example? map (map x) can be used to write map (map (+3)) [[1,2], [3,2]]
07:16:52 <b_jonas> > map (map (+3)) [[1,2], [3,2]]
07:16:53 <lambdabot>   [[4,5],[6,5]]
07:16:57 <quicksilver> map map would apply map to every element so you'd have to apply it to a list of functions
07:17:17 <quicksilver> map map [(+1),(+2),(+3)] would typecheck for example
07:17:26 <quicksilver> (and the result is a list of functions which work on lists)
07:17:33 <b_jonas> > map map [(+3), (+4)] [10, 20]
07:17:34 <lambdabot>   The function `GHC.Base.map' is applied to three arguments,
07:17:35 <lambdabot>  but its type `(...
07:17:52 <quicksilver> > zipWith ($) (map map [(+3),(+4)]) ([10,20])
07:17:54 <lambdabot>   No instance for (GHC.Num.Num [b0])
07:17:55 <lambdabot>    arising from a use of `e_1341020'
07:17:55 <lambdabot>  Po...
07:18:10 <quicksilver> > zipWith ($) (map map [(+3),(+4)]) ([[10,20],[30,40]])
07:18:12 <lambdabot>   [[13,23],[34,44]]
07:18:23 <quicksilver> may not be the easiest example to follow :)
07:18:32 <quicksilver> but once you've got a list of functions which work on lists, what are you going to do with them?
07:19:54 <artiq> hmm, need to think=)
07:22:48 <int-e> > map map [pred, succ] <*> [[1],[3,4]] -- Applicative seems to be the easiest way to use 'map map' to me
07:22:50 <lambdabot>   [[0],[2,3],[2],[4,5]]
07:22:53 <artiq> I get itnw
07:22:57 <artiq> it now*
07:22:57 <artiq> thanks
07:23:10 <int-e> not sure how helpful that is :)
07:25:01 <adnam> dgpratt: if you have any other questions you might want to try #fay or https://github.com/faylang/fay/issues , this channel is a bit noisy for us to notice :)
07:25:20 <dgpratt> adnam: will do, thanks
07:28:23 <sopvop> I give up on generating schema along with encoder for json. I'll write that shit by hand.
07:28:25 * sopvop cries
07:29:07 <quicksilver> int-e: rather relies on knowing what the applicative instance for lists is, but yes, certainly an example.
07:51:02 <cote> http://www.carolinaherrera.com/212/es/areyouonthelist?share=HBwr80bR-2foKDsmH9finK07NzCqnVrcUjgmo98XySnkz4rz3EUUdzs6j6FXsjB4447F-isvxjqkXd4Qey2GHw#episodio-5
07:54:13 <mysticc> Is there a well documented place to read about quickcheck test case coverage. More examples preferred.
08:12:29 <Peaker_> In Windows, I manually install a lib to C:\Windows and C:\Windows\System32, but "cabal configure" fails to find it (unless I use --extra-lib-dirs=C:\Windows). What directories *are* in the search path of libs by default?
08:13:07 <dcoutts> Peaker_: the ones that are on gcc's search path
08:13:15 <dcoutts> ie it's gcc that decides that
08:14:10 <Peaker_> how do I know gcc's paths?
08:14:54 <Clint> gcc -print-search-dirs
08:17:52 <Peaker_> thanks
08:21:08 <Peaker_> Doh! cabal build/ghc fail with: "This application has requested the Runtime to terminate it in an unusual way. Please contact the application's support team for more information."
08:21:24 <Peaker_> damn, getting anything to work on Windows is a world of pain
08:21:49 <Mihailo123> hi
08:21:52 <shanse> please contact your administrator!
08:22:47 <Mihailo123> im learning haskell and have a question :)
08:23:07 <tcrayford> ask away
08:23:31 <Mihailo123> http://stackoverflow.com/questions/2807629/handling-incremental-data-modeling-changes-in-functional-programming?rq=1
08:23:48 <Mihailo123> here's the code that i have trouble understanding
08:23:57 <Mihailo123> data Actions a = Action ...
08:24:22 <Mihailo123> its a data structure
08:24:58 <Mihailo123> the 2nd parameter is a function that takes a, returns a
08:25:12 <Mihailo123> and ???? it somehow maps to Actions structure???
08:25:40 <Mihailo123> im somewhat new to FP programming, though i do have knowledge of LISP
08:26:01 <b_jonas> Mihailo123: but what's the question? could you be more specific?
08:26:15 <`nand`> Mihailo123: the second parameter is a function that takes a function from a to a and returns a new Actions a
08:26:15 <Mihailo123> can u explain what the 2nd argument/parameter to Actions is???
08:26:30 <`nand`> ‘(a -> b) -> c’ means the first parameter is a function
08:26:57 <Mihailo123> so then, the mkLit definition...
08:27:08 <Mihailo123> how is it referring to itself???
08:27:20 <Mihailo123> lambda expression \f referring to mkLit again
08:27:51 <Mihailo123> seems like a recursive defn
08:27:52 <`nand`> it's a recursive function
08:28:04 <`nand`> that's completely normal, haskell is lazy
08:28:10 <startling> Mihailo123: recursive definitions are fine
08:28:25 <Mihailo123> :)
08:28:37 <`ramses_> wow, I just reimplemented a prolog assignment I got at uni a while ago in haskell and my naive haskell solution outperforms my optimized prolog solution by an order of magnitude!
08:28:41 <Hafydd> http://google.com/search?q=recursion
08:28:46 <`ramses_> why do they learns us prolog??
08:28:58 <startling> `nand`: has nothing to do with laziness really
08:29:07 <tdammers> `ramses_: because execution speed isn't everything
08:29:15 <Mihailo123> so how would mkLit 1 get evaluated???
08:29:25 <`ramses_> tdammers: but the haskell solution is _less_ code
08:29:25 <`nand`> startling: yeah fair point, because of the lambda
08:29:33 <startling> `nand`: yeah
08:29:34 <`nand`> startling: that would be fine even in strict higher order languages
08:29:37 <Mihailo123> where is the function specified?
08:29:43 <startling> Mihailo123: right there
08:29:43 <tdammers> `ramses_: then maybe haskell is more suited to this particular assignment than prolog
08:29:57 <`ramses_> nah, it is a typical backtracking problem
08:29:58 <`nand`> mkLit x = Actions x (\f -> mkLit (f x))
08:30:02 <`ramses_> very well suited for prolog
08:30:16 <`ramses_> I did the backtracking in haskell with the list monad
08:30:16 <`nand`> ‘actEval (mkLit x)’ evaluates to ‘x’
08:30:31 <`nand`> because the ‘actEval’ field of the Actions record is given as ‘x’ by mkLit
08:30:32 <`ramses_> prolog is just slow, I'm afraid
08:30:32 <Mihailo123> nand: what is actEval ??? is that a built-in operator?
08:30:36 <tdammers> `ramses_: in that case, idk - maybe haskell is just awesomer, generally :P
08:30:41 <`nand`> Mihailo123: no, look at the definition of ACtions
08:30:55 <`nand`> data Actiona a = Actions { actEval :: a, ... }
08:30:59 <`nand`> Actions*
08:31:11 <Mihailo123> nand: i've been looking at it since yesterday :)
08:31:39 <`ramses_> my prolog solution (for which I got the maximum score) is 338 lines of code, the haskell solution 220. For the most complex puzzle the prolog solution needs 40min, the haskell one 8min
08:32:00 <Saizan> Mihailo123: maybe it's record syntax that's confusing you?
08:32:05 <Mihailo123> nand: actEval is that afunction ??
08:32:11 <`nand`> Mihailo123: yes
08:32:16 <`nand`> actEval :: Actions a -> a
08:32:25 <`nand`> maybe you should look at how record syntax works like Saizan suggested
08:32:28 * `nand` is afk for a while
08:33:07 <startling> Mihailo123, how are you learning haskell?
08:33:18 <Mihailo123> reading online tutorials
08:34:11 <Saizan> Mihailo123: try this paragraph http://learnyouahaskell.com/making-our-own-types-and-typeclasses#record-syntax
08:34:15 <`ramses_> tdammers: I do certainly think haskell is way more awesome, my professor however, thinks the opposite. Maybe I should tell her about my experiment :)
08:35:02 <Saizan> `ramses_: well, there are many prolog implementations, some more optimized than others
08:35:12 <`ramses_> we used swi-prolog
08:35:30 <`ramses_> don't think its the fastest, but definitely not a slow pne either
08:35:30 <Saizan> `ramses_: there are also more modern logic programming languages than prolog
08:35:45 <`ramses_> I know, I'm just blown away by the difference
08:36:07 <`ramses_> since my professor is always telling us how good prolog is for this kind of problems
08:36:34 <startling> Mihailo123: seems like you're stumbling on some fairly basic things -- maybe bookmark this page and come back after you've learned a little more?
08:36:37 <startling> @lyah
08:36:37 <lambdabot> Unknown command, try @list
08:36:42 <startling> @where lyah
08:36:43 <lambdabot> http://www.learnyouahaskell.com/
08:36:50 <startling> ^ is probably the best online tutorial
08:37:14 <Mihailo123> startling: yes, that's the one i've been reading
08:38:00 <startling> Mihailo123: cool. :)
08:38:10 <Mihailo123> one last q, b4 i go off reading more...
08:38:12 <Mihailo123> mkLit x = Actions x (\f -> mkLit (f x))
08:38:19 <Mihailo123> how would u say that in common lisp?
08:38:51 <Peaker> (defun mkLit (x) (Actions x (lambda (f) (mkLit (f x)))))
08:39:42 <Mihailo123> thanks Peaker!
08:40:12 <Mihailo123> bye everyone, thanks for help!
08:40:22 <Peaker> Mihailo123, except Common Lisp would probably not have "Actions" as a data constructor
08:40:56 * Iceland_jack . o O ( Lisp programmers have all defun )
08:41:03 <Mihailo123> Peaker: what do u mean?
08:41:17 <Botje> Iceland_jack: *groan*
08:41:18 <Mihailo123> isnt Actions a function
08:41:21 <Iceland_jack> :)
08:42:57 <tcrayford> it's a data constructor, which is a function, at least in some respects. Normal functions can't start with capital letters though
08:43:05 * hackagebot snaplet-acid-state 0.2.3 - acid-state snaplet for Snap Framework  http://hackage.haskell.org/package/snaplet-acid-state-0.2.3 (DougBeardsley)
08:44:41 <aleator> Hmm.. Is there any online stuff about ekmetts latest lens talk floating around yet?
08:49:20 <b__> Iceland_jack it's funnier in Dutch where "de" == "the"
08:49:33 <b__> aleator: #haskell-lens
08:49:42 <aleator> b__: ah. Of course.
08:50:01 <Iceland_jack> b__: Thanks :) I have a joke for some Dutch people I know
08:50:40 <Iceland_jack> Is it btw possible to specify that arguments to an ADT are of different types?
08:50:58 <b__> in case it's delivered orally: the 'e' in "de" is pronounced as in "the"
08:51:08 <Iceland_jack> d'the?
08:51:20 <Iceland_jack> oh sorry, misread
08:51:43 <Iceland_jack> “data List a b = Nil | Cons a (List b a)”, would it be possible to specify that a /= b
08:52:00 <tac> Iceland_jack: not in a generic way, no
08:52:03 <Iceland_jack> hm
08:52:23 <tac> in the theory, you can't really tell when two types are different.
08:52:51 <Iceland_jack> You can't?
08:52:58 <tac> well... sorta... kinda
08:53:15 <quicksilver> the point is more that when they're polymorphic you can't *promise* they will be different
08:53:26 <Iceland_jack> Fair enough :)
08:53:27 <tac> stick with what quicksilver said there :)
08:53:35 <quicksilver> so they're potentially different but there is no way you can stop an enclosing context from unifying them to be the same
08:53:52 <tac> to require they be different delves into waters that are scary even with dependent types
08:54:19 <Iceland_jack> Hm, I don't think it would be too hard with dependent types
08:54:31 <Iceland_jack> but I suppose it depends on which type system you're using
08:55:50 <quicksilver> you may wish to read http://okmij.org/ftp/Haskell/typeEQ.html
08:56:08 <quicksilver> look for uses of the word 'disequality'
08:57:08 * Iceland_jack kind of hoped it wouldn't appear in the link to induce enlightenment
08:57:54 <Iceland_jack> comparing the string "disequality" for equality..
08:58:05 <Iceland_jack> Anyhow, I'll look into it quicksilver: thanks
08:59:09 <Mihailo123> data Actions a = Actions {
08:59:09 <Mihailo123>     actEval :: a,
08:59:09 <Mihailo123>     actMap  :: (a -> a) -> Actions a }
08:59:32 <Mihailo123> so this function returns either a OR Actions func?
08:59:50 <Mihailo123> 'a' or Actions 'a' ?
09:02:30 <wavewave> hi.
09:03:45 <wavewave> i just uploaded advertisement video for my program on reddit
09:05:44 <wavewave> see http://redd.it/14seiv   :-)
09:08:05 * hackagebot containers 0.5.2.1 - Assorted concrete container types  http://hackage.haskell.org/package/containers-0.5.2.1 (JohanTibell)
09:08:12 <Nafai> wavewave: Yeah, I just saw it!  Looks awesome.  If I had a tablet running Linux, I'd try it out.
09:08:31 <Nafai> wavewave: I did check out the source code to see how you wrote it though, I'm always looking to improve my gtk2hs code
09:09:12 <wavewave> Nafai: thanks. BTW, hoodle is installable on windows machine, too  ;-)
09:09:22 <joehillen> wavewave: I bet Canonical would be interested in that since they are pushing into the tablet market
09:09:41 <wavewave> Nafai: although poppler support is not successful in windows.
09:09:44 <Nafai> wavewave: yeah, I only have an Android-powered tablet :)
09:10:14 <wavewave> joehillen: hopefully. I need someone to help me for making a package. I haven't done it yet.
09:12:55 <wavewave> Nafai: I hope that there is a simple way to develop android, iOS app using haskell.
09:17:16 <ziarkaen> I'm trying to embed a case...of statement within an if...then...else.   Here is my broken attempt: http://hpaste.org/79159
09:17:22 <ziarkaen> How can I make that work?
09:18:01 <`nand`> what's the problem, exactly?
09:20:39 <ziarkaen> `nand`, Oh, silly me.  The "then" part was of type [Char] and the else was of type [[Char]].  I should have analyzed the error message more carefully.
09:25:16 <Cale> ziarkaen: It helps to actually post the error message when asking about code :)
09:26:02 <ziarkaen> Cale, Yeah, was trying to find a function on hpaste for that, and by the time I had put it in anopther pastebin I realized te mistake.
09:26:27 <tac> in ziarkaen's defense, GHC's error messages are usually incomprehensible.
09:26:52 <`nand`> to somebody who can't speak english and knows nothing of Haskell, sure
09:27:12 <`nand`> the main problem with GHC's error messages is that you have to actually read them
09:27:23 <`nand`> I'm not sure that's a problem that can be avoided, in general
09:27:27 <romildo> With gtk2hs, would it work to remove a widget from a container and later on add it again to the container? gtk+ docs recommend calling g_object_ref on the widget, before removing it from a container, in order to be able to use it again. Would it be necessary with gtk2hs too?
09:27:27 * tac only reads the actual error messages as a last line of defense :P
09:28:21 <appamatto> Is there a way to automatically generate cabal constraints?
09:28:44 <`nand`> cabal-install has an algorithm for figuring out the dependencies of your projects
09:29:14 <dcoutts> appamatto: in principle yes, but we don't have a tool that does it
09:29:44 <dcoutts> romildo: with gtk2hs you don't have to deal with refcounts, gtk2hs does that automagically
09:29:45 <`nand`> did I misunderstand the question?
09:29:47 <appamatto> I'm wondering more about how to make the project.cabal file without doing a lot of trial and error
09:29:56 <`nand`> appamatto: ‘cabal init’?
09:29:56 <navaati> hi
09:30:01 <dcoutts> appamatto: cabal init does a half-decent job
09:30:12 <appamatto> Oh, does cabal init inspect your source?
09:30:16 <dcoutts> appamatto: yes
09:30:21 <appamatto> Whoa, I didn't know that.
09:30:34 <dcoutts> well, latest version does, it's been improved
09:30:50 * dcoutts isn't sure exactly what is in the latest dev version vs released version
09:31:01 <appamatto> That sounds awesome
09:31:04 <romildo> dcoutts, it did not work in my  application, though.
09:31:45 <dcoutts> romildo: you mean you removed it from one container, and added it to another, and what happened?
09:31:55 <navaati> typeclass dictionary resolution is done at compile time, except for existentials where the dictionnary is carried with the data at runtime, right ?
09:33:01 <romildo> dcoutts, I removed widget1 from a container, added widget2 to the container, then removed widget2 from the container and added widget1 to the container. At the end the container looks empty.
09:33:03 <b_jonas> navaati: no
09:33:29 <b_jonas> navaati: even without existentials, typeclass dictionaries are passed along in runtime
09:33:37 <`nand`> not necessarily
09:33:58 <`nand`> in cases where the dictionary is known and fixed; GHC can optimize those dictionary calls into direct calls
09:35:45 <navaati> ok. so that mean i can have some code that chooses the concrete type at runtime (as a result of parsing for example), put it into an existential so i can have many of them different types satisfying one class in a list, and the right method will still be chosen
09:35:50 <b_jonas> okay, so sometimes it's optimized away,
09:35:52 <navaati> does that sound possible ?
09:36:02 <b_jonas> but in general the dictionary has to be passed on at runtime
09:36:28 <romildo> dcoutts, In my application there is a list of items in a tableview and I want to show some details of the selected item in a separate container. Each time the cursor changes in the tableview the container has to be updated accordingly.
09:36:41 <b_jonas> navaati: yes, the right method will be used
09:37:23 <navaati> (actually, the question is not about a wrong method being used but about ghc shouting on me ^^)
09:37:30 <navaati> ok, thanks, i'll try then
09:39:39 <romildo> dcoutts, Each item in the tableview has a widget that is added or removed from the container for the details.
09:41:28 <romildo> dcoutts, When the cursor changes on the treeview, the widget of the previous selected item is removed from the container, and the widget for the new selected item is added to the container.
09:42:17 <dcoutts> romildo: hmm, I don't see any problems noted, e.g. see http://developer.gnome.org/gtk-faq/stable/x635.html
09:42:30 <romildo> dcoutts, But when the treview cursor revisits an item, the container keeps empty.
09:42:47 <dcoutts> romildo: a reference to a widget in haskell is equiv to having a reference count on that widget
09:45:12 <romildo> dcoutts, I will write a minimal test program that demonstrates the issue and then I will come back.
09:45:41 <dcoutts> romildo: and send it to the gtk2hs-users (or gtk2hs-devel) mailing list
09:52:14 <ericbmerritt> is there any way to constrain numbers to a range as part of a data declaration?
09:52:41 <Iceland_jack> Not without defining your own number type
09:55:02 <byorgey> not even with defining your own number type.
09:55:34 <ericbmerritt> byorgey: thats the conclusion I had come too.
09:56:02 <byorgey> ericbmerritt: what people usually do in this sort of situation is to make a newtype wrapper around some numeric type, then make a "smart constructor" which does a dynamic check ensuring the number is in the valid range, and then don't export the actual constructor
09:56:31 <byorgey> you can add dynamic checks in the arithmetic operations as well, if you like
09:56:43 <`nand`> or modulo arithmetic
09:57:03 <byorgey> it's not as good as having a *static* guarantee that your numbers are within the valid range, but then again, checking that statically is rather difficult if you want to do arithmetic
10:01:36 <ericbmerritt> that makes sense actually.
10:02:09 <ericbmerritt> hmm, would that make the return value of the constructor an Either then, since it can either return the result or some error message
10:02:38 <ericbmerritt> I guess the alternative is some exception, but I am generally not a fan of those
10:02:39 <b__> I have a bunch of functions (which are just specialised versions of a more generic combinator), but I want to generate them somehow. For example f foo = "foo" for a boatloads foos.
10:03:10 <Peaker_> b__, that sounds like a code smell (not necessarily bad, but suggestive)
10:03:40 <tobias_> hi, can anybody help me find a 4 state busybeaver with more than 107 steps?
10:03:43 <b__> hm they are shorthands for different HTML element constructors
10:03:56 <b__> div/p/etc
10:08:06 * hackagebot a50 0.4 - Compare genome assemblies  http://hackage.haskell.org/package/a50-0.4 (KetilMalde)
10:17:23 <Peaker_> according to the .prof, 72.8% of runtime spent in    withMultGLMatrix act = GL.preservingMatrix $ do { m <- GL.newMatrix GL.ColumnMajor ; GL.multMatrix (m :: GL.GLmatrix R) ; act }
10:17:25 <vinnova> Functor is recruiting - http://alpmestan.com/posts/2012-10-23-haskell-job-opening-at-functor.html
10:20:11 <rwbarton> my laptop's hostname is functor, does that mean I am qualified?
10:20:28 <catsbydlo> fully qualified hostname
10:20:44 <vinnova> rwbarton, yeah
10:22:15 <catsbydlo> a functor is just a fun ctor
10:23:07 <elliott> data Foo = Fun Int -- a fun ctor
10:23:46 <b__> that's really fun ny
10:25:13 <vinnova> Indeed any type is a functor, in the sense of initial (or final) (co)algebras or least (greatest) fix points of such, true enough.
10:34:15 <clahey> Has anyone written a compiler from haskell to java?
10:34:38 <`nand`> clahey: Frege is something similar
10:35:39 <tac> Is confluence the same as the Church-Rosser property? Or are they distinct?
10:36:18 <clahey> `nand`: Why not just compile haskell to java?
10:36:40 <clahey> `nand`: Oh, I'm reading their page now.
10:37:36 <ParahSail1n> @hoogle readNWith
10:37:36 <lambdabot> No results found
10:47:58 <startling> will rm -rf ~/.ghc ~/.cabal do anything bad? I want to start anew. :(
10:48:26 <elliott> you'll lose ~/.cabal/config
10:49:25 <startling> I don't think I've customized that, but thanks.
10:52:00 <glguy> a recent version of cabal-install will install a version of .cabal/config that it doesn't understand
10:52:26 <glguy> so if you start having trouble with the cabal command you might check that out (that's the only problem I know of)
10:54:00 <byorgey> startling: there really should never be any need to delete ~/.cabal
10:54:14 <startling> byorgey: ah well, too late.
10:54:22 <byorgey> rm -rf ~/.ghc is fine, it will get rid of all your locally installed packages
10:54:26 <startling> yeah
10:54:49 <byorgey> ~/.cabal just contains your config and a Hackage download cache
10:54:57 <glguy> and executables
10:55:05 <byorgey> oh, that too, by default
10:55:19 <startling> heh, oops, lost cabal install
10:55:29 * byorgey has had cabal configured to install executables elsewhere for so long that I always forget about that
10:55:30 <glguy> time to bootstrap.sh
10:56:01 * glguy has Cabal installing things into $HOME/Library/Haskell/bin because some Haskell Platform decided to do that at some point
10:56:20 <startling> glguy: what's that?
10:56:56 <glguy> startling: If you download the source tarball for cabal there is a bootstrap.sh that is basically enough of the cabal-install functionality to reinstall cabal-install
10:56:57 <dgpratt> this expression is not well-typed: either (const Nothing) Just `fmap` try (getEnv "PATH")
10:57:04 <dgpratt> how can I make it so?
10:57:07 <startling> glguy: aha
10:57:18 <elliott> :t either (const Nothing) Just `fmap` try (getEnv "PATH")
10:57:19 <lambdabot> Not in scope: `try'
10:57:19 <lambdabot>     Not in scope: `getEnv'
10:57:19 <lambdabot>     Perhaps you meant `getAny' (imported from Data.Monoid)
10:57:25 <elliott> @hoogle getEnv
10:57:25 <lambdabot> System.Environment getEnv :: String -> IO String
10:57:25 <lambdabot> System.Environment getEnvironment :: IO [(String, String)]
10:57:25 <lambdabot> System.Posix.Env getEnv :: String -> IO (Maybe String)
10:57:26 <dgpratt> also suspect that there is a simpler construct that will do what I want
10:57:31 <elliott> :t either (const Nothing) Just `fmap` try (return "")
10:57:33 <lambdabot> Not in scope: `try'
10:57:37 * elliott sighs.
10:57:40 <elliott> :t either (const Nothing) Just `fmap` Control.Exception.try (return "")
10:57:41 <lambdabot>     Ambiguous type variable `a0' in the constraint:
10:57:42 <lambdabot>       (GHC.Exception.Exception a0)
10:57:42 <lambdabot>         arising from a use of `Control.Exception.Base.try'
10:57:53 <elliott> dgpratt: It doesn't know what kind of exception you're trying to catch.
10:57:54 <typoclass> dgpratt: what is the 'try' thing? it converts a Maybe ...?
10:58:12 <catsbydlo> dgpratt: System.Posix.Env getEnv :: String -> IO (Maybe String) ?
10:58:18 <dgpratt> typoclass: exception to Either in a nutshell
10:58:23 <elliott> dgpratt: How about: Just <$> getEnv "PATH" `catch` \(_::TheExceptionTypeYouWantToCatch) -> return Nothing?
10:58:28 <glguy>  fmap (either (\(SomeException _) -> Nothing) Just) (try (getEnv "PATH"))
10:58:36 <typoclass> dgpratt: oh. yeah then what elliott said
10:58:37 <dgpratt> yowza! :)
10:58:39 <elliott> (don't use SomeException, though)
10:58:45 <dgpratt> right
10:58:48 <dgpratt> IOException
10:58:53 <dgpratt> (I think)
10:59:00 <elliott> isn't it IOError?
10:59:07 <dgpratt> elliott: probably
10:59:21 <elliott> Mine and glguy's snippets are equivalent, btw, so you can just pick whatever you prefer.
10:59:26 <typoclass> (what do you expect to catch, btw?)
10:59:34 <elliott> Personally I don't like the intermediate Either step.
10:59:34 <glguy> getEnvironment :: IO [(String, String)] -- if you want to avoid exceptions
10:59:36 <dgpratt> typoclass: missing env var
10:59:53 * typoclass thought those were covered by getEnv giving Nothing
11:00:12 <glguy> getEnv :: String -> IO String
11:00:45 <typoclass> glguy: ugh, you're right. i mixed up System.Environment and System.Posix.Env
11:01:03 <dgpratt> glguy: problem with that (so it seems to me) is its tricky to do a case-insensitive search for the value
11:01:33 <dgpratt> glguy: problem with getEnvironment, I mean
11:02:12 <dgpratt> there's also lookupEnv :: String -> IO (Maybe String), but that appears to be a new thing
11:02:20 <glguy> dgpratt: in 7.6.1 we have lookupEnv :: String -> IO (Maybe String)
11:02:34 <catsbydlo> @src IOError
11:02:34 <lambdabot> Source not found. Maybe you made a typo?
11:02:35 <dgpratt> glguy: oh? I didn't know that ;-)
11:03:13 <glguy> dgpratt: but what are you talking about case-insensitive search?
11:03:24 <glguy> getEnv "path" doesn't find PATH
11:03:56 <dgpratt> glguy: no? I was assuming it would
11:04:10 <glguy> dgpratt: Well, assumption avoided :)
11:04:31 <dgpratt> glguy: it does on my machine (Windows)
11:04:49 <glguy> dgpratt: That's Windows-specific, then
11:04:51 <aristid> dgpratt: it does not in general.
11:04:53 <glguy> don't rely on it
11:05:15 <dgpratt> plus on linux/unix I bet its always "PATH"
11:05:40 <typoclass> dgpratt: i think it's reasonable to expect the linux people to specify the exact variable case-sensitively ("PATH")
11:05:53 <merijn> :t map (first (map toUpper)) <$> getEnv
11:05:54 <lambdabot>     Not in scope: `getEnv'
11:05:54 <lambdabot>     Perhaps you meant `getAny' (imported from Data.Monoid)
11:06:09 <merijn> typoclass: Just toUpper everything, magic case insensitivity :p
11:06:20 <mdmkolbe> Slightly off topic (but I don't know where else to ask (suggestions welcome)): If "g(n) = n log n" and "f(g(n)) = (n^2) log n", then what is "f(n)"?  (The context for this question is that I'm analyzing the computational complexity of an algorithm, and it boils down to this, but I don't know how to derive "f".)
11:06:39 <typoclass> merijn: i dunno ... seems as likely to cause confusion as it is to cause convenience
11:07:08 <merijn> typoclass: Maybe...
11:07:26 <glguy> mdmkolbe: wouldn't f(x) = n * x ?
11:07:46 * glguy gathers it isn't that simple
11:08:06 <mdmkolbe> glguy: f has to be a function of just it's argument (so you would have to derive "n" from "x")
11:12:29 <glguy> solve x = n log n for n comes back as "n = e^W(x)", so then f(x) = x * e^W(x)     , ? (WolframAlpha)
11:13:22 * glguy is only trying because the experts aren't speaking up ;)
11:13:24 <Hafydd> mdmkolbe: To extract n from n log n, you need the Lambert W function/
11:14:19 <Hafydd> mdmkolbe: http://www.wolframalpha.com/input/?i=solve+x+*+log+x+%3D+c
11:17:32 <Hafydd> Oh, someone already said that. I apologise.
11:17:52 <glguy> Hafydd: Good to have someone explicitly agree ;)
11:18:08 * hackagebot HTF 0.10.0.7 - The Haskell Test Framework  http://hackage.haskell.org/package/HTF-0.10.0.7 (StefanWehr)
11:18:25 <mdmkolbe> Hafydd: Egads!  Is there a simplification for (W(n)^2)*log W(n)?
11:20:23 <Hafydd> mdmkolbe: I think you'd rather want: f(x) = x * e^W(x)
11:20:46 <Hafydd> That givesn f(n log(n)) = n log(n) * e^(W(n log n)) = n^2 log(n)
11:21:51 <mdmkolbe> Oh, hehe, after I looked up the W function I forgot glguy's original responce.  Silly me.
11:24:24 <mdmkolbe> Hmm, is there a way to get wolfram alpha to plot e^W(n)?  When I tried it, it just thought I wanted to plot e^W.
11:24:49 <mdmkolbe> (I've never really used WA before.)
11:24:59 <Hafydd> mdmkolbe: http://www.wolframalpha.com/input/?i=plot+Exp[ProductLog[x]]
11:25:15 <mdmkolbe> cool thx
11:25:30 <Hafydd> "e^ProductLog(x)" also works.
11:25:46 <Hafydd> As does "e^LambertW(x)"
11:37:28 <mdmkolbe> Hafydd: Plotting this for various it looks like x e^W(x) > O(x^(2-epsilon)) for any given epsilon.  Is there a way to prove this?  (If there is, then it is very good because I can say that f is effectively n^2.)
11:41:50 <byorgey> did you really mean > ?
11:42:09 <byorgey> oh, never mind
11:49:59 <dmwit> mdmkolbe: Taking f(n)=n^2 is a conservative estimate, as f(n log n)=n^2 (log n)^2 > n^2 log n for all n > e
11:50:18 <dmwit> or I could be misunderstanding
11:50:33 <romildo> dcoutts, the issue with adding and removing widgets to containers was related to incorrectly using scrolled windows and viewports on my proggram. Adding and removing widgets to containers works as expected.
11:50:41 <romildo> dcoutts, thank you for your attention.
11:50:46 <dcoutts> romildo: ah, great
11:53:54 <mdmkolbe> dmwit: We have f(x) < O(x^2), not f(x) > O(x^2).  I don't understand your statement
11:55:21 <dmwit> You should probably ignore me, then, since I don't really understand what you want/are asking.
11:57:15 <Iceland_jack> Hey, is there a way of getting a sublists of a list of a specific length?
11:57:52 <`nand`> filter ((n==) . length) . subsequences
11:57:57 <`nand`> okay, probably not the most efficient solution :P
11:57:58 <blackdog> Iceland_jack: if you take the tails of the list, map (take n) over it, then filter out the too-small lists you should be fine
11:58:23 <Iceland_jack> it doesn't need to be very efficient yet so I'll use `nand`'s version
11:58:30 <`nand`> oh, subsequences "abc" includes "ac"
11:58:38 <`nand`> not sure what a subsequence or a sublist is, properly
11:58:38 <Iceland_jack> `nand`: that's good!
11:58:48 <Iceland_jack> I was a bit unclear in my question
11:58:52 <blackdog> Iceland_jack: it doesn't work if by "sublist" you mean it should be contiguous
11:59:06 <Iceland_jack> all permutations of a certain length
11:59:18 <blackdog> permutations is something else again...
11:59:46 <`nand`> all subsequences of a certain length? or all n-length strings constructed from elements of the source?
11:59:56 <Iceland_jack> the latter
12:00:08 <`nand`> > replicateM 2 "abcdef"
12:00:09 <lambdabot>   ["aa","ab","ac","ad","ae","af","ba","bb","bc","bd","be","bf","ca","cb","cc"...
12:00:24 <Iceland_jack> Thanks :)
12:00:40 <Iceland_jack> I wonder why it didn't turn up on Hoogle
12:01:00 <Iceland_jack> Never mind, it did
12:02:39 <mdmkolbe> note that these are technically not permutations since they include duplicates
12:05:08 <ParahSail1n> ever since rebuilding everything in cabal with profiling, it's been messed up. how do i rebuild from scratch, making sure that profiling is enabled by default
12:05:44 <clahey> I had that problem.  I think I deleted .cabal and .ghc.
12:06:54 <ParahSail1n> how do i make profiling enabled by default on everything when i rebuild
12:06:56 <blackdog> ParahSail1n: make sure that ~/.cabal/config has profiling turned on, too
12:07:17 <mdmkolbe> library-profiling: True
12:08:00 <mdmkolbe> You can leave "executable-profiling: False"
12:10:16 <mdmkolbe> In my experience, you may have to also rebuilt stuff that isn't in cabal but is in the standard distribution (e.g. old-time).  (Unfortunately, I don't know of a good way to find what you need to rebuild other than waiting for when cabal complains that it can't find the profiling version of something.)
12:15:56 <scp> Is learning about arrows worth it?
12:16:13 <scp> err, rather
12:16:19 <scp> why is learning about arrows worth it?
12:16:31 <scp> that's badly phrased too, but I think you get the idea =]
12:17:08 <ParahSail1n> why didnt cabal install cabal put anything in ~/.cabal/bin
12:18:32 <merijn> scp: They can be useful abstractions for things you can't manage to squeeze into the monad interface
12:19:04 <merijn> scp: Whether that's worth it depends on how likely you are to encounter those. OTOH they're not particularly complicated either
12:20:08 <scp> merijn: cool, thanks.
12:20:13 <Cale> scp: You should spend about 10 minutes looking into what Arrows are, and then set them aside until you either want to use a library which uses the abstraction, or end up writing a library which might fit the description.
12:20:36 <merijn> scp: The Arrow paper is actually very readable and thus a good place to start
12:20:48 <Cale> There are not so many libraries which use Arrow, and there are some serious issues with the abstraction as it presently exists.
12:21:00 <Cale> (It's very close to something which *would* be very useful.
12:21:07 <merijn> scp: It gets more difficult/tricky about halfway in, but I'd say it's worth reading for the first half alone
12:21:10 <Cale> )
12:23:00 <merijn> scp: "Generalising Monads to Arrows" and "Programming With Arrows" (both by Hughes) are the ones you want if you're interested
12:23:18 <`nand`> scp: http://ertes.de/new/tutorials/arrows.html
12:23:27 <`nand`> this is a good first read
12:23:32 <Pranz> > 2 / 2 * 2
12:23:34 <lambdabot>   2.0
12:24:18 <Pranz> >2 * 2 / 2
12:24:26 <Pranz> > 2 * 2 / 2
12:24:28 <lambdabot>   2.0
12:27:51 <aavogt> scp: at least one rather useful library uses them: http://hackage.haskell.org/package/hxt
12:28:27 <invariant> aavogt, are there any benchmarks which show that hxt is useful?
12:33:12 <aavogt> invariant: I'm not really sure what you mean by a benchmark for being useful.
12:33:42 <`nand`> mm_freak: the Quickstart tutorial for netwire claims that the stepWire type as shown is simplified. It seems to be the same as the actual stepWire type
12:33:59 <aavogt> but I've used it for getting basic stuff out of SVG (positions and sizes of things)
12:35:09 <aavogt> chances are there are more useful examples in here http://www.haskell.org/haskellwiki/HXT
12:35:55 <taesoo> hi, is there any way to invoke hayoo in console, like hoogle?
12:39:55 <moevenpick> hi, i'm trying to install wxhaskell. However it fails: "g++: error: unrecognized command line option -Wl"
12:40:00 <dgpratt> if someone(s) felt like doing a small code review on this small function http://hpaste.org/79162 I'd appreciate it
12:40:01 <moevenpick> Does anyone know how to deal with this?
12:40:45 <moevenpick> (error occurs with wxcore/building phase)
12:41:02 <`ramses_> dgpratt: the explicit pattern match could be done with the either function
12:43:28 <dgpratt> `ramses: the thought had occurred to me; besides making it shorter, I wasn't sure it would make it better; I take it you think it would?
12:44:01 <`ramses> dgpratt: it does exactely the same thing, just looks nicer imho
12:44:28 <hpaste> Hafydd pasted “mdmkolbe” at http://hpaste.org/79163
12:45:00 <`ramses> dgpratt: just like I prefer implicit recursion over explicit recursion, I prefer implicit pattern matches over explicit one. I think they're more readable and less error prone
12:45:14 <Hafydd> mdmkolbe: if I correctly interprete your meaning of "> O(...)", that should prove it I think.
12:45:31 <dgpratt> `ramses: I see your point
12:45:40 <neutrino> `ramses: how do you perform implicit recursion?
12:45:50 <Hafydd> mdmkolbe: and I have taken epsilon to be positive, of course.
12:45:52 <neutrino> `ramses: you have to recurse at some point right?
12:46:06 <`ramses> neutrino: I mean stuff like until and folds
12:46:24 <neutrino> that's.. not really implicit.
12:46:34 <neutrino> it's fairly obvious that it's an iteration of some sort.
12:46:35 <`ramses> you don't recurse yourself
12:46:41 <neutrino> yes
12:46:48 <neutrino> and the implementation doesn't have to recurse either
12:46:49 <`ramses> sure, but you don't write the recursion yourself
12:47:12 <neutrino> so saying "implicit recursion" is like saying that cars implicitly run on hop oil
12:47:21 <`ramses> maybe I should use the term internal vs external iteration
12:47:33 <neutrino> it's just an implementation detail
12:47:56 <neutrino> it could work via graph reduction at the level of bare metal
12:48:07 <neutrino> or valves and steam whistles
12:48:09 <invariant> aavogt, it means that its performance is better than that of competing systems.
12:48:12 <`ramses> but whether you use a higher order function or write the recursion yourself is not a detail imho
12:48:20 <hpaste> Hafydd annotated “mdmkolbe” with “mdmkolbe (correction: 0 to x_0)” at http://hpaste.org/79163#a79164
12:48:27 <neutrino> but there isn't "the recursion"
12:48:41 <neutrino> the error is that you say "whether you use a higher order function or write the recursion yourself"
12:48:45 <dgpratt> so something like: either (const $ return Nothing) (return . Just) e
12:48:49 <invariant> aavogt, such benchmarks don't exist and as such recommending it is based on absolutely nothing.
12:48:54 <neutrino> whereas you should be saying "whether you use a higher order function or write a recursion"
12:49:06 <neutrino> which is a fairly different thing imo
12:49:10 <`ramses> argh, yeah, you know what I mean
12:49:28 <`ramses> maybe I could've picked the wording better
12:49:36 <`ramses> but I guess you get what I mean
12:49:42 <neutrino> well, i know what you're getting at, but the nice thing about this topic is that we can bikeshed over it until we actually figure out how to talk about it properly :)
12:49:50 <beaky> hello
12:50:01 <beaky> how do I have a heterogeneous list in haskel
12:50:04 <beaky> haskell*
12:50:10 <`ramses> I'm glad you call it bikeshedding ;)
12:50:37 <`ramses> but you are right that is important to use proper wording
12:50:58 <elliott> beaky: you don't
12:50:59 <elliott> @where faq
12:51:00 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
12:51:06 <beaky> can't? :(
12:51:10 <neutrino> btw, about *implicit* recursion, i wonder if you could somehow use the type system to figure out if recursion should happen
12:51:12 <elliott> http://www.haskell.org/haskellwiki/FAQ#How_do_I_make_a_list_with_elements_of_different_types.3F
12:51:15 <elliott> you don't want to
12:51:19 <neutrino> and if yes, just recurse at the bottom of the function
12:51:22 <elliott> you should just make a list that contains the operations you need to do on each element
12:51:23 <neutrino> that would be really fun
12:51:29 <beaky> ah
12:51:39 <elliott> you can do it with an existential, but you usually don't want to
12:52:10 <beaky> ah
12:52:14 <neutrino> beaky: you'll find that you probably don't need it anyway
12:52:16 <beaky> whats an existentiaal?
12:52:25 <`ramses> neutrino: how would that work? I don't think it's possible if for instance the recusive function is endomorphic
12:52:44 <neutrino> beaky: it's an advanced technical topic that's in the area of haskell's type system
12:52:45 <`ramses> then the type system has no means of testing for a termination condition
12:52:57 <dgpratt> there really ought to be an English term for when something requested is possible but not desirable
12:53:01 <neutrino> beaky: no reason for you to learn about it right now, it's mostly useless for you
12:53:46 <neutrino> `ramses: why not? all you really need is to be able to call the function again.
12:54:00 <`ramses> neutrino: and to decide whether it's to stop or not
12:54:06 <beaky> ah
12:54:10 <`ramses> time to stop *
12:54:12 <neutrino> well, sure
12:54:24 <`ramses> neutrino: that's the part I was talking about
12:54:37 <neutrino> but given this kind of convention, i'm sure some way of signaling it to stop can be found
12:54:53 <`ramses> ah, you mean like some syntactic sugar
12:54:58 <neutrino> for example, let's say you have guards, and recursion only happens on the otherwise guard
12:55:03 <beaky> haskell ftw
12:55:16 <`ramses> the until function is very useful if the recursive function is endomorphic
12:55:35 <neutrino> why
12:55:53 <`ramses> I wonder how such syntax would look like, to decide what input to give for the recursive call
12:55:58 <neutrino> isn't that nearly like the fixed point combinator
12:56:04 <neutrino> well it's a simple call really
12:56:32 <`ramses> it's more general then a fixed point, as you can give it any decision logic
12:56:47 <neutrino> you'd probably want to have it happen in an imperative language (e.g. a do block) and you'd just pass the recursive call variables of the same name as the arguments
12:56:48 <`ramses> (I think, don't know the fixed point thing too well)
12:57:46 <`ramses> neutrino: but do you gain much except not having to type the name of the function? you still have to write all logic to do the recursion
12:58:02 <neutrino> yeah you don't gain much
12:58:10 <neutrino> that i can see right now
12:58:31 <`ramses> when I stated that I avoided explicit recursion, I mostly meant using map and folds and filter and such, instead of the manual approach of e.g. prolog
12:58:31 <neutrino> however
12:58:42 <`ramses> where you have to write recursive functions over and over again
12:58:46 <neutrino> if you can generalize any function to a simple tail recursion
12:58:52 <neutrino> probably building a list or something like that
12:58:58 <`ramses> and each time run the risk of doing something wrong
12:59:00 <neutrino> then maybe you can automatically generalize it to any data structure
12:59:05 <aavogt> invariant: which xml library do you prefer?
12:59:25 <neutrino> so you basically build a recursion skeleton, declare the type you want to get, and the compiler figures out how to recurse
12:59:29 <neutrino> wouldn't that be cool?
13:00:07 <`ramses> sure! :) But I don't immediately see how it would work..
13:00:08 <neutrino> i mean there's already an api like that for iterating over monadic values
13:00:26 <neutrino> you can iterate over lists, trees, maybe, etc with the exact same code
13:00:48 <`ramses> you mean stuff like functor and foldable?
13:00:51 <neutrino> but is there an api for defining lists, trees, maybe, etc?
13:01:00 <neutrino> no, you can just use do blocks and <- to get values
13:01:27 <`ramses> can you write a monad instance for trees then?
13:01:51 <`ramses> cause it seems like you imply that trees can be monads
13:02:18 <`ramses> but I have given it thought before but I couldn't come up with a sensible applicative functor for them
13:02:51 <neutrino> http://www.cse.chalmers.se/~rjmh/OPLSS/Exercises.pdf
13:03:37 <`ramses> ok, very interesting!
13:03:49 <`ramses> is that from a course you're following?
13:05:11 <neutrino> also see here: http://stackoverflow.com/questions/6798699/monad-instance-for-binary-tree
13:05:18 <neutrino> yes `ramses the university of google
13:05:18 <neutrino> :p
13:06:18 <neutrino> :))
13:07:57 <`ramses> ha! ok :)
13:08:44 <`ramses> actually I kinda concluded for myself a while ago that trees probably shouldn't be monads, so I'm glad that mistake can be justified now
13:09:25 <`ramses> I'll do the exercise one of these days
13:15:43 <dgpratt> is there any standard function that is equivalent to (flip liftM) ?
13:17:26 <fmap> @ty (<&>)
13:17:28 <lambdabot> Functor f => f a -> (a -> b) -> f b
13:17:36 <shachaf> FSVO "standard"
13:18:34 <dgpratt> fmap: where does that live?
13:18:44 <fmap> lens
13:18:44 <Clint> lens
13:18:51 <dgpratt> ah
13:19:23 <dgpratt> fmap: probably means I shouldn't use it (for this), but thanks!
13:19:26 <shachaf> You can section <$>, though.
13:19:33 <shachaf> (<$> x) f
13:19:55 <dgpratt> shachaf: oh, good point
13:20:53 <dgpratt> well, what do folks think of my revised function? http://hpaste.org/79162
13:21:49 <hpaste> elliott annotated “maybeGetEnv” with “maybeGetEnv (annotation)” at http://hpaste.org/79162#a79166
13:21:50 <dgpratt> I am reluctant to take hlint's advice because I prefer the read order I have (not sure that's a good justification)
13:22:10 <elliott> That might have to be fmap Just (getEnv name), actually.
13:22:53 <elliott> dgpratt: (http://hpaste.org/79162#a79166, if you didn't see)
13:23:07 <elliott> That maintains your read order without the nasty try step
13:23:11 * hackagebot sizes 2.0.2 - Recursively show space (size and i-nodes) used in subdirectories  http://hackage.haskell.org/package/sizes-2.0.2 (JohnWiegley)
13:23:13 * hackagebot sizes 2.0.3 - Recursively show space (size and i-nodes) used in subdirectories  http://hackage.haskell.org/package/sizes-2.0.3 (JohnWiegley)
13:23:25 <dgpratt> elliott: quite nice, but I'd prefer to avoid enabling a language extension
13:24:23 <neutrino> `ramses: :)
13:24:33 <saml> x + y =   0 if x and y are 0.    x  if y is 0.  y if x is zero.    x + y   when both are non zero        how do I express this?
13:24:42 <saml> + and 0 are arbitrary
13:24:50 <dgpratt> elliott: is 'try' considered nasty, or just my use of it?
13:25:04 <shachaf> dgpratt: You can easily avoid a language extension while making the code almost as nice as what elliott wrote.
13:25:13 <dgpratt> shachaf: oh? :)
13:25:19 <shachaf> But ScopedTypeVariables is unfortunately pretty necessary when working with Control.Exception.
13:25:27 <shachaf> Control.Exception is a mess. :-(
13:25:31 <saml> if zero x and zero y then zero else if zero x then y else if zero y then x else x `plus` y
13:25:35 <saml> is there something like this?
13:25:41 <saml> some monad or something?
13:25:44 <learningHaskell> Hello could I ask a quick question?
13:25:45 <dgpratt> shachaf: is there something else I could use here?
13:25:59 <hpaste> elliott annotated “maybeGetEnv” with “maybeGetEnv (annotation) (annotation)” at http://hpaste.org/79162#a79167
13:26:03 <elliott> dgpratt: two possible solutions ^
13:26:04 <sipa> learningHaskell: yes, but don't ask to ask
13:26:11 <elliott> You should really just use ScopedTypeVariables though.
13:26:13 <dgpratt> (not very well versed at all with Haskell exception handling)
13:26:16 <glguy> saml: That's basically what Monoid is
13:26:20 <elliott> It's a huge pain not to and the extension is really tiny.
13:26:31 <saml> oh i see
13:26:34 <learningHaskell> Doing :t [1] gives me :: Num t => [t]
13:26:39 <learningHaskell> why not just [t]?
13:26:43 <neutrino> saml: why not just say x + y = x + y?
13:26:43 <shachaf> Maybe ScopedTypeVariables should be split into two pieces and one of them should go into Haskell'
13:26:52 <Cale> learningHaskell: Because 1 has to be some sort of number
13:26:53 <Philippa_> we should really, really spec up ScopedTypeVariables and put it into Haskell'
13:26:54 <Philippa_> ...yeah
13:27:00 <dgpratt> elliott: ok, I have hopes to make a pull request some day and I wanted it to be as unobtrusive as possible
13:27:04 <saml> plus and zero are arbitrary neutrino
13:27:06 <Philippa_> which reminds me - someone convince me I shouldn't apply to be on that c'tee already?
13:27:10 <saml> maybe (+) is Monid
13:27:20 * elliott would really like it if ScopedTypeVariables made the explicit "forall" behaviour the default.
13:27:23 <shachaf> Philippa_: I'm not sure that the scoping part should go into H'
13:27:25 <neutrino> yes, you're looking for a monoid
13:27:30 <elliott> So you don't have to repeat all your variables in a forall just to get proper scoping.
13:27:32 <neutrino> read up on monoids on wikipedia
13:27:38 <neutrino> or wolfram
13:27:42 <Cale> learningHaskell: For example, there would be no way to treat that as [String]
13:27:45 <shachaf> Philippa_: Well, it has some baggage, like "forall". Maybe forall should go into it too, though.
13:27:59 <shachaf> It's not as if every implementation doesn't implement it.
13:28:05 <shachaf> Even if it's only rank-1
13:28:30 <Philippa_> quite
13:28:39 <saml> why high school doesn't teach monoid and stuff?
13:28:41 <Cale> oh, he quit...
13:28:47 <saml> so hard to learn things when i'm old
13:29:15 <Hafydd> Any high schools teaching FP?
13:29:18 <otters> Semigroup is Monoid without mempty, right?
13:29:41 <saml> i have no idea what these are
13:29:41 <elliott> yes
13:29:43 <elliott> re otters
13:29:46 <saml> wiki is hard to udnerstand
13:29:54 <otters> thanks elliott
13:29:55 <saml> bring me back to younger years and teach me
13:30:44 <neutrino> otters: it's an associative magma
13:31:01 <otters> and can somebody show me a use case of All
13:33:03 <`ramses> otters: I guess you'd use it to use booleans as input to a function that takes a monoid
13:33:38 <johnw> saml: how old is "old" for you?
13:34:16 <saml> over 30 is old
13:34:19 <fmap> > let all' = getAll . foldMap All in (all' [True, True, True], all' [True, True, False])
13:34:21 <lambdabot>   (True,False)
13:34:30 <johnw> ah
13:34:34 <johnw> so, by old you mean really young
13:34:38 <johnw> got it
13:34:45 <shachaf> This sounds off-topic.
13:35:31 <otters> oh I see
13:35:52 <otters> getAll . mconcat $ [All True, All False, All True]
13:36:45 <glguy> otters: You could use it as the Monoid argument to a WriterT and track that none of the computations sequenced together returned a "False"
13:38:20 <pmade> Is there a way to avoid duplicating build-depends in a .cabal file when you have a lib, exec, and tests?  Right now cabal wants me to list the same build-depends for each section.
13:38:21 <dgpratt> In my situation (of trapping exceptions coming from getEnv), what is to be preferred? Control.Exception.catch or System.IO.Error.catch? the latter appears to be simpler to use
13:42:20 <catsbydlo> System.Posix.Env.getEnv
13:42:36 <johnw> does anyone know how HTF compares to, say, hspec?
13:48:58 <neutrino> johnw: htf is pretty good.
13:49:11 <johnw> yeah, it looks nice; I'm setting it up now
13:49:31 <neutrino> look at the log from yesterday for my skeleton
13:49:39 <johnw> whereat?
13:49:46 <neutrino> here, for sclv
13:49:50 <neutrino> 1 sec
13:52:27 <neutrino> http://tunes.org/~nef/logs/haskell/12.12.11
13:52:33 <neutrino> 12:41, 45, 46
13:52:36 <neutrino> three pastes
13:53:17 <hpaste> dgpratt annotated “maybeGetEnv” with “maybeGetEnv (annotation)” at http://hpaste.org/79162#a79168
13:53:26 <neutrino> johnw^
13:53:41 <dgpratt> any issues with that version?
13:55:04 <neutrino> johnw: hspec turns me off from ever using it. buzzwords like "behavior-driven development" make me retreat.
13:55:30 <neutrino> johnw: and the whole idea of making it look like natural language is just failed at birth.
13:55:36 <johnw> neutrino: i disliked how wordy it is, but I figured that might just be unfamiliarity speaking
13:55:47 <johnw> HTF looks rather nice
13:55:59 <neutrino> look at my pastes
13:56:03 <johnw> kk
13:56:06 <neutrino> they're all you need
14:00:43 <johnw> i thought you were going to show me sexy output
14:01:01 <johnw> also, your testsuite.hs seems a lot more complex than what they show in the htfpp-based tutorial
14:01:03 <`ramses> why isn't there a more flexible insertWith function like   (b -> a -> a) -> k -> b -> Map k a -> Map k a   to fuse a new element into the old one
14:01:23 <`ramses> like you have a map of lists and want to add a new element to the list at the key
14:01:34 <neutrino> yeah it actually does Real World Shit, johnw
14:01:46 <neutrino> :p
14:02:01 <johnw> why aren't you using htfpp at all?
14:02:11 <neutrino> what is htfpp?
14:02:23 <johnw> see http://hackage.haskell.org/packages/archive/HTF/0.10.0.7/doc/html/Test-Framework-Tutorial.html
14:02:38 <neutrino> oh
14:02:38 <johnw> it assembles the tests into suites automatically
14:02:44 <neutrino> htf is an actual package name
14:02:45 <johnw> you just need functions named test_* and prop_*
14:02:55 <neutrino> i thought you meant haskell test-framework
14:02:58 <johnw> ahhh
14:03:10 <neutrino> yeah, i don't necessarily like that
14:03:26 <johnw> i'm all about scrapping boilerplate
14:03:36 <neutrino> i prefer it this way. you can execute single tests with wildcard parameters to the test executable
14:03:43 <neutrino> which is nicer than having to remember property names
14:04:03 <neutrino> plus, i don't like to have a list of top-level functions for my tests AND then also possibly put them in some big list
14:04:17 <neutrino> i guess if anything called prop_ or test_ will be added automagically that's nicer
14:04:27 <johnw> yeah
14:04:37 <johnw> at least for hundreds of little tests, it's much more convenient
14:04:48 <johnw> i don't know about complex tests that require setup/teardown
14:04:53 <neutrino> i dunno, what i'm doing currently couldn't be much more convenient
14:05:02 <neutrino> ah yeah
14:05:47 <neutrino> if i have a complex setup or teardown i either do multiple assertions in the same test (both hunit and qc support that), or i factor out the setup/teardown to a separate function and call that
14:06:42 <BlairA> I guys I'm looking for some good vim plugins to make working with Haskell a bit easier, any suggestions?
14:07:08 <neutrino> i have lambdabot refactoring commands defined in my vimrc
14:07:10 <johnw> BlairA: is there a plugin that installs Emacs? ;-)
14:07:20 <neutrino> you could have a look at my whole vimrc actually
14:07:29 <neutrino> johnw: for some time my vimrc pulled in emacs as a dependency
14:07:33 <neutrino> so.. yes.
14:07:34 <glguy> There's a haskellmode that has been pretty slick so far
14:07:43 <johnw> neutrino: wild!
14:08:09 <neutrino> BlairA: check msg
14:08:14 <neutrino> johnw: it doesn't anymore :)
14:08:32 <BlairA> Forgot my manners to not start a religious chat ;)
14:08:51 <neutrino> that's ok, don't worry
14:08:56 <neutrino> johnw is on his way out *cough*
14:09:00 <neutrino> ;)
14:09:00 <glguy> Don't worry; it's OK to write the words "vim" and "emacs" in channel
14:10:24 <johnw> one thing I do miss re: lisp vs. haskell is how easy it is to refactor sexps; Haskell code requires a lot more manual surgery (at the moment)
14:11:06 <johnw> although, ghc-mod *can* identify the "current" expression, with ever-widening scope
14:13:12 * hackagebot chuchu 0.4.2 - Behaviour Driven Development like Cucumber for Haskell  http://hackage.haskell.org/package/chuchu-0.4.2 (FelipeLessa)
14:13:22 <johnw> huh, speak of the devil...
14:14:07 <johnw> ugh, that seems so verbose: https://github.com/marcotmarcot/chuchu/blob/master/tests/calculator.hs
14:16:40 <neutrino> johnw: haha
14:17:00 <johnw> he use of applicative is kind of  cool
14:17:42 <neutrino> how do they use applicative?
14:17:48 <neutrino> i don't know anything at all about applicative
14:17:55 <johnw> "desc" *> number <* "desc"
14:18:06 <johnw> so that the expression just yields "number"
14:18:30 <neutrino> why would you do that
14:18:48 <johnw> well, in parsers it's a good way to parse context that you don't care about after the parse
14:18:57 <johnw> whitespace *> digits <* whitespace
14:19:06 <neutrino> right
14:19:19 <neutrino> but why is it good in a testing framework?
14:19:28 <johnw> i didn't quite say that, it was just clever
14:19:37 <neutrino> why.. is it clever?
14:19:43 <johnw> it looked nifty
14:19:54 <neutrino> you're a tease
14:20:01 <neutrino> :p
14:26:24 <beaky> how do I implement OOP-style polymorphism in haskell
14:26:32 <beaky> is it with existential types?
14:26:52 <tac> beaky: Existential types are what you want. I don't know if haskell does it as nicely as it could
14:27:35 <beaky> would be cool if I could
14:27:46 <tac> You say "I have SOME type X with the following properties"
14:27:49 <beaky> then I can translate smalltalk code into haskell :D
14:27:59 <hpc> it... isnt cool
14:28:17 <hpc> scala spent a ton of effort getting oo to play nice with fp
14:28:31 <ciaranm> and failed miserably
14:28:39 <tac> Subtyping is a PITA (and IMO not really worth it)
14:28:59 <tac> but polymorphism based on what a type can do isn't bad
14:29:06 <Clint> what's the most efficient way to replicate a conduit pipeline for multiple sinks?
14:29:14 <tac> and is exactly existential types tupled with what fields it supports
14:29:44 <tac> A monoid would be Exists X. (X, X -> X -> X)
14:29:49 <tac> for example
14:30:09 <tac> (together with a guarantee the X -> X -> X thing is associative and the X is unital
14:30:44 <pqmodn> tac, can you do anything with that besides add unit/zero values?
14:31:23 <tac> pqmodn: You need to have other objects of X to do interesting things, of course
14:31:44 <hpc> you also need to tell it what X is?
14:32:11 * hpc hasnt delved into this particular brand of ugly :P
14:32:11 <pqmodn> can you instantiate X?
14:33:17 <hpc> in any event, this all reimplements classes poorly
14:33:18 <tac> not concretely
14:33:35 <hpc> (type classes)
14:33:59 <tac> hpc: It all depends on how you feel about embedded prologs in your language.
14:34:49 <hpc> i feel very (X) about it
14:34:50 <tac> beaky: In ML, you'd use a module rather than an existential type
14:36:02 <beaky> haskell could use those module things :D
14:36:47 <killerville> Are there some alternatives for XML?
14:38:53 <Dashkal> To answer that would require knowledge of your use case
14:44:36 <SLi> killerville, generally, yes. Without knowing more about your case, look at YAML and JSON.
14:47:50 <combataircraft> Hi all.  I want to create a multiplayer go program but can't find anything on google.
14:47:57 <combataircraft> I need a library to validate the moves of players.
14:48:06 <combataircraft> How can I start this?
14:48:24 <tac> Are you looking for a pre-written Go library in Haskell?
14:48:32 <tac> Or help with how to implement one yourself?
14:49:02 <combataircraft> both
14:49:10 <simpson> combataircraft: Hi, saw you in #python.
14:49:22 <simpson> Which language do you *actually* want to use?
14:49:51 <combataircraft> not decided yet, there are many parameters of choosing a language for this task
14:50:41 <combataircraft> haskell, erlang and may be python or ruby. depending on the real time performance and library quality, community support etc
14:51:10 <tac> writing a Go validator seems like a good haskell task
14:51:14 <simpson> combataircraft: Well, what do you *know*? :3
14:51:46 <combataircraft> I also consider NodeJS and JavaScript
14:52:32 <tromp> i have a Go validator at http://homepages.cwi.nl/~tromp/go.html
14:52:38 <simpson> combataircraft: You might need to learn how to program first.
14:53:24 <tromp> it's not written with performance in mind though:(
14:53:34 <combataircraft> simpson: obviously, I've been learning it for many years
14:53:52 <combataircraft> tromp: thanks a lot, it would be very helpful
14:54:08 <simpson> combataircraft: Well, which languages do you *know*?
14:54:39 <djcoin> quit
14:54:42 <djcoin> wouups
14:55:58 <combataircraft> simpson: I think you mean "which languages do you feel comfortable with?" then my answer would be python. but I'm ok with leaving my comfort zone.
14:56:34 <combataircraft> I use haskell just for maintaining xmonad nothing else
14:57:20 <combataircraft> but I would like to take advantage of a fast Go library written in Haskell, if exists
14:58:19 <combataircraft> @tromp thanks a lot for writing that. the code looks very cool.
14:58:20 <lambdabot> Unknown command, try @list
14:58:30 <combataircraft> tromp thanks a lot for writing that. the code looks very cool
14:58:49 <tromp> cool but slow
14:58:58 <tromp> the 2nd version is much less slow though
14:59:01 <combataircraft> how do we make it fast?
14:59:40 <zomg> I think the standard programming language advice still stands
14:59:46 <zomg> if you have a deadline, use something you are familiar with
14:59:47 <zomg> =)
15:00:22 <janua> Hi,  I am trying to get experience with function lifting. I am trying to lift the show function, but also trying to lift a hGetLine aswell. What am i doing wrong?
15:00:25 <janua> liftM show (liftM hGetLine (openFile "text.txt" ReadMode))
15:00:53 <tcrayford> janua: hGetLine is already in the io monad
15:01:12 <tcrayford> (well, its return value is)
15:01:55 <tcrayford> have a look at the types and think about it somewhat ;)
15:02:49 <janua> tcrayford: I am looking closely… i can't figure it out! openFile returns something in the IO monad, but hGetLine doesn't take something in the IO monad, so I'm lifting it to it.
15:03:15 <janua> It then returns an IO monad, and i am lifing show to it *scratches head*
15:04:13 <tcrayford> janua: you *need* bind to get that result (>>=) liftM can't do anything extra with the result of an action
15:04:33 <tac> @hoogle Monad m => m (a -> b) -> m a -> m b
15:04:34 <lambdabot> Control.Monad ap :: Monad m => m (a -> b) -> m a -> m b
15:04:35 <lambdabot> Control.Monad liftM :: Monad m => (a1 -> r) -> m a1 -> m r
15:04:35 <lambdabot> Control.Applicative (<*>) :: Applicative f => f (a -> b) -> f a -> f b
15:04:55 <janua> tcrayford: I see!! So you can't chain them like in point free style?
15:05:21 <tcrayford> janua, you can, you just have to use >>= instead of liftM
15:05:54 <janua> tcrayford: But can i not just explicitly not use the liftM? (Which is what I'm trying to do)
15:06:02 <janua> Too many nots there
15:06:25 <tcrayford> janua: mind removing them? That sentence makes my head hurt
15:07:05 <janua> tcrayford: But can i just explicitly use the liftM?
15:07:15 <tcrayford> janua: no, the types don't line up
15:07:23 <tcrayford> I think
15:07:23 <tcrayford> :S
15:07:28 <tcrayford> one sec
15:07:35 <janua> I am really confused now about it
15:07:42 <pqmodn> janua: look closely at the types of openFile, hGetLine, show, and then liftM
15:08:11 <janua> pqmodn: Ok, I will have a look at them now beside each other
15:08:19 <tcrayford> also look at the specific types of, e.g. applying liftM to hGetLine
15:09:32 <pqmodn> janua: keep in mind there is no instance for Show (IO a)
15:09:37 <tcrayford> I'm pretty sure I'm right now, liftM won't let you do something with the value inside a monad
15:09:41 <killerville> is there a very simple protocol built on tcp/ip that is suitable to implement in haskell?
15:10:19 <tcrayford> killerville: you could just make up your own protocol if you want the practice ;)
15:10:39 <tcrayford> if not, iirc syslog is pretty simple (and real world haskell has an example implementation)
15:11:23 <pqmodn> tcrayford: liftM does, if you have "m a" and a pure function "a -> b", you can use liftM to get "m b"
15:11:27 <janua> pqmodn: But since i am lifting it, does it not use the instance for Show String?
15:11:27 <combataircraft_> tromp: do you know any other good go libraries?
15:12:03 <pqmodn> janua: i probably added confusion, the wrong part is liftM (hGetLine ..)
15:12:07 <tcrayford> pqmodn: right, but you can't use liftM to run another action, correct?
15:12:15 <pqmodn> right
15:12:57 <pqmodn> @type openFile
15:12:59 <lambdabot> Not in scope: `openFile'
15:13:45 <tromp> http://senseis.xmp.net/?ComputerGoProgramming#toc8
15:14:51 <tromp> libEGO is fastest library but not the clearest code
15:15:33 <pqmodn> janua: so openFile gives you an "IO Handle" and hGetLine requires just a "Handle", but gives you an "IO String". combining these with liftM does strip off the "IO" and give hGetLine just "Handle", but it re-wraps the return value of hGetLine to "IO (IO Handle)"
15:15:44 <pqmodn> sorry, "IO (IO String)"
15:15:56 <combataircraft_> thanks a lot
15:16:22 <tromp> there's also http://sourceforge.net/projects/nngs/, for which i contributed some move checking code
15:16:35 <combataircraft_> java would be good fit for this task if the library is fast. would be fun to use clojure
15:17:54 <janua> pqmodn: Ahh! I see, so the lifting of the shows ok, its the double wrapping of the IO thats causing the problem? I can see how it is getting double wrapped
15:17:56 <combataircraft_> tromp: source code links don't work
15:18:01 <pqmodn> janua: yes
15:18:21 <janua> pqmodn: Ok, can you give me a hint as to how i could get out of this?
15:18:25 <pqmodn> janua: compare liftM with >>=
15:18:33 <tromp> then find and contact the authors
15:18:35 <janua> Doing that.
15:18:55 <pqmodn> janua: notice the argument order is flipped, but also notice the return type
15:19:10 <pqmodn> :t liftM
15:19:11 <lambdabot> Monad m => (a1 -> r) -> m a1 -> m r
15:19:13 <pqmodn> :t flip (>>=)
15:19:15 <lambdabot> Monad m => (a -> m b) -> m a -> m b
15:21:42 <janua> pqmodn: Ahhhh, it doesn't re wrap the result, instead it keeps the type that the function returns
15:21:47 <pqmodn> yeah
15:22:00 <janua> How the hell did you know that off the top of your head
15:22:13 <tcrayford> monads are a very common haskell thing ;)
15:22:26 <pqmodn> janua: i went through it several times, like you've just done
15:22:39 <janua> I am beginning to kind of understand them, but i was trying to get experience with lifting tonight :)
15:23:08 <janua> Well thanks for your help guys :) Now how to factor in the bind function! Oh fun times
15:23:28 <pqmodn> janua: just keep in mind liftM (or other kinds of lifting, like liftA2) work on *pure functions* and lift them into some kind of context
15:24:57 <pqmodn> janua: fmap is another lifting function, surely you've used it without realizing.
15:25:01 <pqmodn> :t liftM
15:25:03 <lambdabot> Monad m => (a1 -> r) -> m a1 -> m r
15:25:03 <pqmodn> :t fmap
15:25:05 <lambdabot> Functor f => (a -> b) -> f a -> f b
15:25:19 <janua> pqmodn: But, isn't bind working in a context too?
15:25:39 <pqmodn> yep
15:25:44 <pqmodn> but show is not
15:25:57 <pqmodn> neither is hGetLine
15:26:10 <pqmodn> that is, they don't take "effectful" arguments
15:26:14 <janua> It's just merely a slight different in the function signature, which obviously is a big different but you know what i mean :)
15:26:53 <pqmodn> janua: this paper helped me understand better http://www.soi.city.ac.uk/~ross/papers/Applicative.html
15:27:46 <janua> pqmodn: Thanks, i will check that out
15:27:48 <tyfighter> I come from a Ruby / JS background, best place to start learning Haskell? I see the community or tutorials are thin
15:27:55 <pqmodn> @where LYAH
15:27:56 <lambdabot> http://www.learnyouahaskell.com/
15:28:07 <dmwit> ?where RWH
15:28:08 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
15:28:10 <dmwit> ?where gentle
15:28:10 <lambdabot> http://www.haskell.org/tutorial/
15:28:13 * hackagebot Nomyx-Rules 0.0.1 - Language to express rules for Nomic  http://hackage.haskell.org/package/Nomyx-Rules-0.0.1 (CorentinDupont)
15:28:14 <dmwit> (My personal favorite.)
15:28:34 <tcrayford> tyfighter: those are good. There's nothing quite a substitute for trying to write something *real* in haskell though
15:28:44 <tcrayford> at least once you're up to some sorta speed
15:28:51 <tyfighter> right, ok
15:28:55 <dmwit> Also, "the community is thin" is a sophomoric tactic and you should be ashamed of yourself.
15:29:11 <tcrayford> dmwit: he's a ruby/js guy, he's already ashamed of himself
15:29:12 <janua> I had real world first, but found learn you a haskell much easier to understand
15:29:12 <tcrayford> ;)
15:29:17 <Chathurga> Jeez dmwit no need for that
15:29:59 <Chathurga> tyfighter: I come from a similar background, found learn you a haskell to be really good
15:30:02 <tyfighter> I didn't choose the right words, I meant when I search for "haskell tutorial", the resources don't seem too thick, compared to let's say ruby
15:30:24 <pqmodn> tyfighter: LYAH is somewhat similar to _why's guide
15:30:46 <tyfighter> Thanks
15:30:55 <pqmodn> tyfighter: there's also tryhaskell.com
15:30:59 <tcrayford> yeah, LYAH is really nice. RWH is useful, but not as your first thing
15:31:00 <cmccann> LYAH has a slightly higher ratio of informational content vs. whimsy compared to _why's guide
15:31:05 <tyfighter> Yes I did tryhaskell.com
15:31:06 <Ralith> thin? if anything, haskell has too many tutorials...
15:31:11 <cmccann> whether that's good or bad is a matter of opinion I guess
15:32:13 <tyfighter> I feel I've entered the lions den here lol
15:32:23 <elliott> _why's guide was the first Ruby thing I read. I didn't learn a single thing about Ruby, but it did convince me I wanted to know Ruby.
15:32:28 <elliott> (then I got better)
15:32:37 <tyfighter> yes, same here
15:32:40 <elliott> LYAH is distinguished by being actually useful for learning :P
15:32:50 <cmccann> elliott yeah that's kind of how _why's guide worked
15:33:04 <killerville> :t liftM
15:33:05 <lambdabot> Monad m => (a1 -> r) -> m a1 -> m r
15:33:13 * hackagebot Nomyx 0.0.1 - A Nomic game in haskell, featuring automatic, machine-executed rules written by the players  http://hackage.haskell.org/package/Nomyx-0.0.1 (CorentinDupont)
15:33:17 <dmwit> I personally couldn't stand it. It made me actively want to avoid Ruby. =P
15:33:19 <cmccann> whereas LYAH actually stands on its own as learning material
15:33:33 <killerville> :t liftM
15:33:35 <lambdabot> Monad m => (a1 -> r) -> m a1 -> m r
15:34:11 <tyfighter> Thanks for the info
15:34:23 <dmwit> ?where tutorials
15:34:24 <lambdabot> http://haskell.org/haskellwiki/Tutorials
15:35:18 <Chathurga> tyfighter: Don't get scared off haha, sometimes somebody gives a needlessly agressive or condescending response but this channel is actually a really good learning tool too
15:36:17 <cmccann> what about aggression and condescension that aren't needless, though
15:36:20 <cmccann> are those ok
15:36:33 <tyfighter> ^^
15:36:45 <Chathurga> cmccann: yup, of course!
15:36:53 <cmccann> ok cool
15:37:43 * cmccann makes fun of elliott for liking ruby at one point, then
15:37:48 <cmccann> ;]
15:38:13 * hackagebot simple-tabular 0.1.0.0 - Simple tabular-text formatter  http://hackage.haskell.org/package/simple-tabular-0.1.0.0 (BartonMassey)
15:38:37 <killerville> > liftM (+1) $ Just 5
15:38:39 <lambdabot>   Just 6
15:39:45 <janua> Now I have:  openFile "text.txt" ReadMode >>= hGetLine >>= show
15:39:52 <janua> lifting show doesn't seem to work
15:39:56 <janua> :t liftM show
15:39:57 <lambdabot> (Monad m, Show a1) => m a1 -> m String
15:40:02 <janua> Which i thought it would
15:40:07 <dmwit> show doesn't do any IO; perhaps you want putStr, putStrLn, or print.
15:40:17 <simpson> :t openFile "derp" ReadMode >>= hGetLine
15:40:18 <lambdabot> Not in scope: `openFile'
15:40:19 <lambdabot> Not in scope: data constructor `ReadMode'
15:40:19 <lambdabot>     Not in scope: `hGetLine'
15:40:25 <simpson> Oh, right, no IO here.
15:40:43 <dmwit> :t print "IO is okay here, but scoping is a different story"
15:40:44 <lambdabot> IO ()
15:41:02 <dmwit> > print "In fact..."
15:41:03 <Hafydd> :t System.IO.openFile
15:41:04 <lambdabot>   No instance for (GHC.Show.Show (GHC.Types.IO ()))
15:41:04 <lambdabot>    arising from a use of ...
15:41:04 <lambdabot> FilePath -> GHC.IO.IOMode.IOMode -> IO GHC.IO.Handle.Types.Handle
15:41:13 <pqmodn> janua: liftM show will give you an IO String, but like dmwit said, show doesn't do any IO actions.
15:41:30 <dmwit> Oh, has that changed? Okay, then.
15:41:38 <Hafydd> :t S.I.openFile
15:41:40 <navaati> is there another way than modules to do encapsulation (by this i mean "having only an external interface to an object, without being able to tinker with its internals")
15:41:40 <lambdabot> Couldn't find qualified module.
15:41:40 <janua> Ah!
15:41:41 <killerville> > liftM (+1) $ Just 5
15:41:42 <lambdabot>   Just 6
15:41:47 <Hafydd> :t S.IO.openFile
15:41:48 <lambdabot> Couldn't find qualified module.
15:42:03 <janua> pqmodn: Is it safe to say that i need something that performs an IO action, where the signature is IO ()
15:42:10 <dmwit> navaati: not really
15:42:10 <janua> Or ends in rather
15:42:13 <killerville> liftM(+1) . (Just 5)
15:42:20 <pqmodn> janua: yes, print, putStr, putStrLn etc is what you want
15:42:31 <killerville> (liftM . (+1)) (Just 5)
15:42:35 <dmwit> janua: *need*, no; *want*, yes
15:42:42 <navaati> dmwit: erf... having to create a whole module for a small datatype is a bit cumbersome…
15:42:44 <janua> pqmodn: Got it! Thanks :)
15:42:55 * dmwit nods sadly in navaati's direction
15:43:01 <rwbarton> you could use existentials for encapsulation I guess, but that seems even more cumbersome
15:43:13 * hackagebot hashable 1.2.0.0 - A class for types that can be converted to a hash value  http://hackage.haskell.org/package/hashable-1.2.0.0 (JohanTibell)
15:43:15 * hackagebot Nomyx-Rules 0.0.2 - Language to express rules for Nomic  http://hackage.haskell.org/package/Nomyx-Rules-0.0.2 (CorentinDupont)
15:43:42 <dmwit> It wouldn't be so bad if there were some mechanism for including multiple modules in a single file.
15:43:51 <pqmodn> that'd be nice
15:43:55 <dmwit> s/including/implementing/ maybe? dunno exactly what word I want
15:43:55 <navaati> rwbarton: not sure about it being more cumbersome, but an existential type is a bit hard to serialize...
15:43:57 <Eelis> navaati: type classes can be used kinda like that. if you write your code for a type class interface, then you can generally be sure that when you later instantiate it with implementations of the type class, it won't bypass the type class interface to mess with the internals of the implementation you instantiated it with
15:43:58 <pqmodn> defining?
15:44:14 <navaati> dmwit: multiples modules per files, à la agda ?
15:44:29 <dmwit> yes
15:44:39 <dmwit> I think JHC has something like that.
15:45:06 <dmwit> (The spec doesn't actually say anything about the mapping of modules to on-disk representation.)
15:46:05 <navaati> dmwit: really ? interesting. tho, having something like agda requires a bit more syntax
15:46:27 <navaati> (iirc, agda's module system is actually wonderful)
15:47:08 <rwbarton> navaati, you could make serialization part of the interface
15:47:22 <rwbarton> fwiw, probably nothing :)
15:47:35 <killerville> Im trying to define monads in my own words. A monad is a container in which you can put a value and that container then decides how to put together operations on that value. Hmm?
15:47:35 <Hafydd> What would happen if all binaries of GHC were deleted?
15:48:03 <cmccann> killerville, not really, sorry
15:48:05 <navaati> killerville: well… sorry, but not really :]
15:48:07 <killerville> Do you know which country has the best programmers?
15:48:19 <tcrayford> killerville: russia has oleg, and he's from the future
15:48:20 <killerville> Can ada...
15:48:23 <tcrayford> so I vote russia
15:48:24 <Hafydd> Would it be possible to massage it to run under another compiler like Hugs without too much effort?
15:48:28 <killerville> kill me
15:48:42 <navaati> killerville: ppffrrrt, i laughed
15:49:19 <navaati> rwbarton: you mean, something like including a method "parse :: Parser a" in the class, or something ?
15:49:35 <pqmodn> killerville: the container analogy doesn't apply to monads like IO. https://twitter.com/copumpkin/status/264952295295442944
15:50:01 <rwbarton> you don't even need a class, necessarily
15:50:54 <cmccann> is "data Const a b = Const a" a container for values of type b?
15:51:25 <navaati> rwbarton: hummm… ah, are you talking about the stuff in the existential datatype sectio of ghc's user manual ?
15:51:34 <Saizan> cmccann: sure!
15:52:21 <cmccann> (ok yes it's just one example of the "sequence of fixed length" monads but cmon)
15:52:40 <elliott> cmccann: the joke is that's not really a monad :)
15:52:48 <elliott> though data ConstUnit a = ConstUnit is
15:52:57 <cmccann> oh yeah dur
15:52:59 <cmccann> that's what I meant
15:53:12 <cmccann> dunno what I was thinking there
15:53:19 <cmccann> mine isn't even an applicative
15:53:19 <patrickod> is *** a special operator in haskell ? found it while looking at sample code online but not sure what it does exactly.
15:53:25 <cmccann> :t (***)
15:53:27 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
15:53:28 <shachaf> cmccann: It is when a is a monoid!
15:53:39 <cmccann> obviously that type signature should clear everything up
15:53:41 <patrickod> cmccann: whoops. Forgot the almighty :t
15:53:50 <shachaf> @quote monad.*container
15:53:51 <lambdabot> heatsink says: If monads are containers, the Cont monad is a klein bottle.
15:53:54 <shachaf> @quote kmc monad.*container
15:53:54 <lambdabot> kmc says: monads are like containers, as long as you forget everything you know about the meaning of the word "container" and take it to be a totally abstract word synonymous with "monad"
15:54:00 <gnuvince> If I want to implement a simple dynamic programming algorithm, am I better off with Array or vector?
15:54:06 <mm_freak> nanothief: indeed…  it used to be simplified when i had the Reactive class, which is now gone in favor of a much simpler interface
15:54:10 <mm_freak> uh
15:54:19 <cmccann> :t not *** show
15:54:20 <lambdabot> Show b' => (Bool, b') -> (Bool, String)
15:54:22 <mm_freak> nand`: indeed…  it used to be simplified when i had the Reactive class, which is now gone in favor of a much simpler interface
15:54:28 <rwbarton> data Stack a = forall s. Stack { stack :: s, pop :: s -> (Maybe a, s), push :: a -> s -> s } -- navaati
15:54:31 <rwbarton> I think I did that right
15:54:32 <cmccann> patrickod, that might get the point across better
15:54:42 <elliott> note that rwbarton's type is equivalent to:
15:55:04 <rwbarton> if you like you can add "serialize :: s -> ByteString", "deserialize :: ByteString -> Maybe s"
15:55:05 <navaati> rwbarton: and how do you serialize that ? you can't serialize functions
15:55:08 <elliott> data Stack a = Stack { pop :: (Maybe a, Stack a); push :: a -> Stack a }
15:55:10 <elliott> well, more or less
15:55:18 <elliott> you might be able to do some funny business with push taking another argument there
15:55:22 <Saizan> shachaf: nah, not all monads http://www.cs.nott.ac.uk/~txa/publ/cont-tcs.pdf
15:55:23 <ski> rwbarton : i'd use `Maybe (a,s)' instead of `(Maybe a, s)'
15:55:27 <rwbarton> sure
15:55:45 <shachaf> Saizan: ?
15:55:52 * elliott often wrote existentials like rwbarton's type but realised he could always reduce them to something simpler and non-existential
15:55:55 <elliott> it's simplified a lot of my code
15:56:20 <rwbarton> navaati: somehow you need to get an "implementation" to (de)serialize with though so I guess what I wrote isn't quite right
15:56:33 <cmccann> elliott, so not using existentials made a lot of code not exist?
15:56:35 <ski> elliott : try with a `union'/`merge'-type of operation :)
15:56:41 <elliott> cmccann: groan
15:56:44 <mm_freak> also it's usually much better to use two separate types there
15:56:47 <mm_freak> Stack and StackOps
15:56:54 <pqmodn> cmccann: haha
15:56:54 <shachaf> Saizan: Not all monads what, I mean?
15:56:59 <elliott> ski: right, but in that case you're already mixing the actual operations with a value so it's kind of hard to do already
15:57:00 <mm_freak> in which case, of course, you can't use an existential anymore
15:57:01 <rwbarton> anyways this is all silly IMO
15:57:05 <elliott> hence why deserialisation doesn't really fit into that model
15:57:21 <ski> elliott : yes. what mm_freak said
15:57:24 <rwbarton> if your goal is to avoid writing an extra file
15:57:24 <mm_freak> mixing data and operations is OOP and belongs to the imperative world
15:57:28 <Saizan> shachaf: are containers, but the reference was this one http://www.cs.nott.ac.uk/~txa/publ/fossacs03.pdf
15:57:46 <Refried__> terminology question: is Maybe a type (higher-order) *and* also a type constructor, or only considered a type constructor and not a type
15:57:49 <rwbarton> mm_freak: how would you write those
15:58:05 <ski> Refried__ : the former (both a type and a type constructor)
15:58:07 <cmccann> Refried__, I don't think the terminology is used consistently there
15:58:14 <elliott> "mixing data and operations" =/= representing data as its operations
15:58:15 <mm_freak> rwbarton: since your type is isomorphic to lists with safeHead and (:), i'd just use a list
15:58:17 <rwbarton> I rather prefer the latter
15:58:20 <rwbarton> mm_freak: well okay
15:58:24 <rwbarton> use your imagination
15:58:24 <elliott> the latter is the essence of OOP and a very useful technique in Haskell imo
15:58:32 <ski> Refried__ : otoh `Either String' is a type (a type function), but not a type constructor
15:58:33 <shachaf> Saizan: I'm not sure which thing I said you're correcting, I mean.
15:58:55 <cmccann> elliott, OOP = syntactic sugar for church-encoding all the things?
15:59:15 <Refried__> ski: *mindblown*
15:59:18 <ski> Refried__ : also, `Maybe :: * -> *' isn't a higher-order type -- but e.g. `StateT :: * -> (* -> *) -> * -> *' is
15:59:24 <Refried__> Oh
15:59:32 <Refried__> (ski) good point, i see that now
15:59:49 <rwbarton> basically type theory is no better in terms of standard terminology than any other area
15:59:53 <elliott> cmccann: from one perspective :)
15:59:54 <ski> Refried__ : `Either String' is a type function because its kind, `* -> *', has a `->' as main "kind constructor"
15:59:54 <Saizan> shachaf: nothing that you said
16:00:04 <elliott> cmccann: except you sort of take church encoding as pathological
16:00:06 <gseitz> so the hashable package defines a Hashable instance for Data.Text, yet GHC doesn't seem to find it. any ideas?
16:00:09 <elliott> and represent smaller sets of operations instead
16:00:11 <mm_freak> elliott: f s = push s x (stack s)  -- that's not really representing data by its operations, because the data is still there, which is unfortunate
16:00:11 <elliott> hence abstraction
16:00:12 <Refried__> rwbarton:  :-\
16:00:16 <shachaf> Saizan: Ah, OK.
16:00:21 <elliott> mm_freak: I wasn't advocating rwbarton's approach.
16:00:33 <elliott> I was advocating data Stack a = Stack { pop :: Maybe (a, Stack a); push :: a -> Stack a }
16:00:49 <mm_freak> elliott: well, you're just representing operations there, not data by operations
16:00:51 <cmccann> elliott, yeah, that was sacrificing accuracy for being glib, heh.
16:00:54 <Refried__> ski: Doesn't Maybe also have kind `* -> *`, but how is it different?
16:00:59 <elliott> Actually you probably don't want push in there in this case. It's not the ideal structure to talk about this stuff with.
16:01:05 <mm_freak> elliott: however, i find myself doing this a lot:  someFunc :: (forall a. (Random a) => m a) -> m X
16:01:07 <ski> Refried__ : i call types with kind `*' "concrete types" -- so `Int',`String -> Double',`Either String Int' are all concrete types
16:01:08 <elliott> cmccann: unforgivable!
16:01:18 <cmccann> :[
16:01:32 <elliott> mm_freak: that's a bit different to existential data imo
16:01:43 <Refried__> ski: yeah that makes sense to me
16:01:50 <mm_freak> elliott: there is a very strong relation between existentials and higher rank types
16:01:58 <mm_freak> in fact i often regard them as equivalent
16:02:03 <rwbarton> everything is the same as everything
16:02:08 <rwbarton> that doesn't help when you want to talk about things
16:02:10 <cmccann> forall in contravariant position = exists
16:02:12 <cmccann> give or take
16:02:20 <pqmodn> mm_freak: why is someFunc higher rank (or is it)?
16:02:20 <elliott> mm_freak: yes I know that someFunc is existential
16:02:31 <ski> Refried__ : however, some people call every type function a "type constructor", reserving the plain term "type" for what i call concrete type -- i don't like this though, since that doesn't accord well with the "data constructor" terminology
16:02:36 <mm_freak> pqmodn: forall in parentheses, which you can't leave off
16:02:57 <Refried__> ski: hm
16:03:03 <mm_freak> elliott: well, it's not obvious
16:03:05 <cmccann> there probably is utility in having a special name for things with kind * but I don't like reserving "type" for those alone
16:03:10 <ski> Refried__ : "Doesn't Maybe also have kind `* -> *`, but how is it different?" -- different from what ?
16:03:37 <Refried__> ski: different from `Either String' which you said was a type function
16:04:33 <Refried__> ski: next I want to combine this with explaining why `Maybe' is a Monad, but why `Maybe Int' isn't a Monad
16:04:38 <pqmodn> mm_freak: oh, it isn't equal to :: Random a => m a -> m X... but i'm not sure i see why. can't you lift "forall"s on the RHS of a function ->?
16:04:50 <mm_freak> cmccann: btw, i have no clue about the relation to CT…  it just jumped at me when i implemented some statically checked stuff
16:04:51 <Refried__> that's what i'm trying to get up to, but can't nail down the terminology
16:04:55 <Refried__> (ski ^)
16:04:57 <shachaf> pqmodn: Yes, but that one's on the left side. :-)
16:05:00 <mm_freak> cmccann: i.e. in practical code, not in a theoretical discussion
16:05:07 <pqmodn> shachaf: doh, thanks
16:05:13 <shachaf> pqmodn: It's obvious when you think of "forall" as just another argument.
16:05:21 <ski> mm_freak : .. did you mean something like `somefunc :: (forall a. Random a => ..a.. -> m X) -> m Y' ?
16:05:44 <mm_freak> pqmodn: you can read the "forall" almost literally…  someFunc takes a function that works /for all/ 'a', so someFunc can actually choose the type to pass to that function
16:05:55 <ski> Refried__ : `Maybe' is also a type function. but it is a type constructor as well
16:05:55 <dagnachew> hi all
16:06:04 <mm_freak> ski: nope
16:06:07 <navaati> hum… i'm getting mindblown about all of this… thanks for your answers, i'll have some sleep and come back tomorrow :)
16:06:13 <mm_freak> ski: i just forgot the monad constraint =)
16:06:14 <rwbarton> you should probably ignore all of it
16:06:14 <dagnachew> how one updates installed packages ?
16:06:25 <pqmodn> mm_freak: thanks. my mistake was not having coffee... mixing up my left and rights. makes sense :)
16:06:26 <mm_freak> someFunc :: (Monad m) => (forall a. (Random a) => m a) -> m X
16:06:53 <mm_freak> dagnachew: i reinstall everything
16:07:03 <ski> mm_freak : how could the caller provide an interesting argument of type `forall a. Random a => m a' (presupposing `Monad m') ?
16:07:15 <cmccann> mm_freak, contravariant position (i.e. an argument to a function) works like logical negation here, so it's just a variation on de morgan's laws
16:07:22 <rwbarton> @type randomIO
16:07:23 <lambdabot> Random a => IO a
16:07:23 <mm_freak> dagnachew: the procedure is:  cabal update && cabal fetch world && rm -rf ~/.cabal/{bin,lib,share} .ghc && cabal install world
16:07:26 <Refried__> ski:  So Either is a type function and a type constructor, and Either String is a type function but not a type constructor.  ?
16:07:39 <shachaf> It's pretty ridiculous how much output GHC can generate when you give it all the flags.
16:07:47 <navaati> rwbarton: oh, no, it's all interesting. I mean, if my problem was do simply do the job, i wouldn't be trying to enforce separation between what data can i put in an object at it's construction and what operation can i do to modify it
16:07:53 <elliott> mm_freak: btw the someFunc may be forall m. (Monad m) => (exists a. (Random r) => m r -> m x)
16:07:59 <elliott> but that's actually slightly misleading
16:08:01 <dagnachew> mm_freak, is it safe ? regarding dependencies ?
16:08:01 <elliott> er
16:08:04 <mm_freak> ski: let m be State StdGen, then the argument can be 'state random'
16:08:06 <ski> Refried__ : an instance of `Monad' (iow a type `t' where `Monad t' holds) must have kind `* -> *'. `Maybe' has that kind, but `Maybe Int' doesn't (it has kind `*', so is a concrete type)
16:08:10 <elliott> forall m. (Monad m) => (exists a. (Random a) => m a -> m X)
16:08:17 <elliott> because you can pick *multiple* a
16:08:18 <mm_freak> dagnachew: yes…  if the deps fail, fetch will complain before you delete
16:08:27 <mm_freak> dagnachew: of course compile errors are still possible
16:08:28 <rwbarton> elliott: did you omit a "not"
16:08:29 <rwbarton> ?
16:08:30 <elliott> it's sort of like picking a single a that is a gadt representing trees of typeclass operations
16:08:39 <elliott> rwbarton: I don't think so
16:09:07 <mm_freak> elliott: that doesn't seem right…
16:09:11 <rwbarton> mm_freak's type is not really an existential in the normal sense
16:09:40 <mm_freak> elliott: example:  someFunc :: (Monad m) => (forall a. (Random a) => m a) -> m (Int, Integer)
16:09:48 <mm_freak> someFunc getRandom = liftM2 (,) getRandom getRandom
16:09:48 <navaati> oh, my english is becoming terirble too... good night folks
16:10:10 <rwbarton> right
16:10:14 <ski> Refried__ : "So Either is a .." -- yes
16:10:16 <rwbarton> so I have no idea what it has to do with anything
16:10:32 <Refried__> ski: and that's inferred because of the way `m' is used in the definition `class Monad m where' ?
16:10:57 <elliott> mm_freak: well ((forall a. b) -> c) is basically (exists a. b -> c)
16:11:18 <Refried__> ski: (the kind of `t' where `Monad t' holds)
16:11:32 <ski> Refried__ : just like `Node' is a (value/data) function and a (data) constructor, while `Node "nay"' is a (value/data) function, but not a (data) constructor
16:11:36 <ski> @type Node
16:11:37 <lambdabot> a -> Forest a -> Tree a
16:11:47 <elliott> mm_freak: in this case, you pick a specially by writing a law-violating instance :P
16:11:55 <elliott> you just need to see the ((Random a) => m a) part as (RandomDict a -> m a)
16:11:59 <mm_freak> elliott: depending on where the 'forall' for 'b' is, this seems like an absurd type
16:12:06 <Refried__> ski: *nod* I see, Node.
16:12:15 <ski>   data Tree a = Node a (Forest a)
16:12:16 <ski>   type Forest a = [Tree a]
16:12:23 <elliott> mm_freak: I am saying you can turn your last someFunc type into:
16:12:33 <ski> Refried__ : yes
16:12:36 <elliott> someFunc :: (Monad m) => (exists a. ((Random a) => m a) -> m (Int, Integer))
16:12:41 * cmccann assumed that elliott's "b" and "c" were not bound variables but syntactic metavariables
16:12:46 <elliott> yes, they were
16:12:49 <elliott> should have specified, sorry
16:13:20 <cmccann> so that a could be, and probably is, mentioned by b
16:13:31 <mm_freak> elliott: that doesn't seem right either…
16:13:43 <ski> elliott : "well ((forall a. b) -> c) is basically (exists a. b -> c)" -- not sure i agree
16:13:51 <mm_freak> elliott: let's introduce an actual working "exists" by using the 'exists' package
16:14:08 <mm_freak> elliott: but before we do that let's make this type actually valid
16:14:20 <mm_freak> what's ((Random a) => m a)?
16:14:22 <elliott> We don't need another package.
16:14:38 <mm_freak> elliott: yes, we do, because i'm interested in how to implement it
16:14:48 <elliott> data SomeFunc = forall a. SomeFunc { getSomeFunc :: forall m. (Monad m) => ((Random a) => m a) -> m (Int, Integer) }
16:14:56 <ski> elliott : note that in `foo :: (forall a. ..a..) -> ...', the function `foo' can actually instantiate the type variable `a' in the argument to several distinct types (or perhaps none at all)
16:15:01 <elliott> We don't need another package; that's existential.
16:15:09 <elliott> ski: Right. But you can do that in Haskell in this case.
16:15:16 <ski> "that" being ?
16:15:22 <cmccann> ski, I read both of those as saying that whatever receives the argument of type "b" can pick the type "a" to use
16:15:22 <elliott> you can make a data type that represents all the Random operations in a tree, and instantiate "a" to it
16:15:32 <elliott> and then "interpret" that using any number of instances you want
16:15:33 <cmccann> however the forall seems to imply that it can use more than one "a" if it wants
16:16:02 <cmccann> but I dunno, this is exceeding my handwaving capacity at this point
16:16:05 <shachaf> It's pretty similar from the perspective of the consumer.
16:16:20 <mm_freak> elliott: ok, i see it now
16:16:22 <mm_freak> i think
16:16:35 <shachaf> f1 :: (forall a. Foo a) -> Bar; f2 :: exists a. Foo a -> Bar
16:16:55 <shachaf> In either case, do use f1/f2 you have to provide a "Foo a" that works for every possible "a".
16:16:55 <elliott> mm_freak: I'll write an example program.
16:17:01 <shachaf> s/d/t/
16:17:30 <elliott> mm_freak: Using a simplified version of Random with just randomR, though.
16:17:35 <elliott> Too lazy for anything more :P
16:17:43 <ski> shachaf : sometimes the main reason for using such a rank-2 type is to hide implementation details
16:17:51 <cmccann> I like to use a simplified version of haskell where () is the only type to illustrate my points.
16:17:56 <cmccann> it simplifies things immensely.
16:18:06 <cmccann> for example: (), qed.
16:18:10 <cmccann> simple!
16:18:15 <shachaf> cmccann: I prefere the version where Void is the only type.
16:18:22 <shachaf> s/e / /
16:18:24 * shachaf sighs.
16:18:25 <elliott> cmccann: I take it you do all your work in http://www.inutile.ens.fr/estatis/falso/
16:18:38 <cmccann> elliott, no that's shachaf apparently
16:18:44 <mm_freak> elliott: no worries, i got it
16:19:05 <mm_freak> 'a' has to remain polymorphic when pattern-matching against SomeFunc
16:19:21 <mm_freak> so it's the same thing
16:19:27 <shachaf> ski: I'm not sure what you mean in this context.
16:19:35 <elliott> mm_freak: right, but actually writing a value of SomeFunc that instantiates "a" to multiple types is harder
16:19:36 <BrianHV> @seen apfelmus
16:19:36 <lambdabot> Unknown command, try @list
16:19:38 <elliott> you need a trick
16:20:16 <elliott> hmm
16:20:22 <elliott> actually the easiest way to implement this is with reflection :P
16:20:30 <shachaf> elliott...
16:20:58 <cmccann> too much existentialism for me
16:21:03 * cmccann goes back to programming
16:21:12 <mm_freak> elliott: the problem is that inside the SomeFunc 'a' still has to be a single type
16:21:22 <elliott> mm_freak: yes, that is the trick I was talking about
16:21:30 <elliott> it's not a show-stopper
16:21:37 <mm_freak> data SomeFunc = forall a. SomeFunc …
16:21:50 <mm_freak> that's basically:  data SomeFunc = SomeFunc (a :: *, …)
16:21:56 <shachaf> What's a non-reflection trick?
16:22:17 <elliott> shachaf: Writing it now, but it'll be ugly.
16:23:15 <shachaf> I meant a non-ugly way.
16:24:43 <mm_freak> higher rank is beautiful…  i'll stick with it =)
16:24:43 <elliott> Hmm, this is really tricky for Random.
16:25:08 <shachaf> Can you do the old foo :: (forall a. a -> a) -> (Int,Char); foo id = (id 5, id 'a') that way?
16:25:35 <dagnachew> I am starting haskell and I would like to know the difference between prompt prelude> and ghci>
16:25:43 <elliott> shachaf: I think no.
16:25:49 <elliott> (exists a. (a -> a) -> (Int,Char)).
16:25:49 <ski> BrianHV : "Last seen  : Jul 07 19:12:40 2012 (22 weeks, 5 days, 05:12:03 ago)", according to `/msg NickServ info' ..
16:25:50 <shachaf> elliott: Oh, that's what I meant.
16:25:51 <elliott> Well, you can.
16:25:54 <elliott> Pick a = Either Int Char.
16:25:57 <elliott> Done.
16:25:59 <shachaf> Not reflection nonsense with different instances.
16:26:04 <shachaf> elliott: I don't think that quite counts.
16:26:08 <elliott> Sure it does.
16:26:12 <killerville> does (***) have a name?
16:26:18 <elliott> You can build a data type if you use the id at an infinite number of types.
16:26:26 <killerville> :t (***)
16:26:27 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
16:26:28 <elliott> It's a non-trivial transformation to the function in all cases.
16:26:29 <cmccann> killerville, its name is (***)
16:26:30 <ski> shachaf : hm, i suppose just a rumination about uses of higher-rank types
16:26:36 <shachaf> dagnachew: No difference.
16:26:51 <killerville> :t (&&&)
16:26:53 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
16:26:59 <shachaf> elliott: But you have to write ugly things to use it.
16:27:00 <cmccann> killerville, if you're wondering how to pronounce it then I dunno
16:27:09 <shachaf> elliott: I mean, how would you actually write foo?
16:27:13 <killerville> > (***) (+1) (5,4)
16:27:15 <lambdabot>   Couldn't match expected type `(->)' with actual type `(,)'
16:27:21 <killerville> > (&&&) (+1) (5,4)
16:27:23 <lambdabot>   Couldn't match expected type `(->)' with actual type `(,)'
16:27:31 <killerville> > (&&&) (+1) 5 4
16:27:33 <lambdabot>   No instance for (GHC.Num.Num (c0 -> c'0))
16:27:33 <lambdabot>    arising from a use of `e_1154'...
16:27:37 <cmccann> > (+1) *** (*2) $ (5, 4)
16:27:38 <lambdabot>   (6,8)
16:27:39 <killerville> :t (&&&)
16:27:40 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
16:27:48 <killerville> :t (***)
16:27:49 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
16:27:52 <cmccann> > (+1) &&& (*2) $ 5
16:27:54 <lambdabot>   (6,10)
16:28:14 * hackagebot unordered-containers 0.2.3.0 - Efficient hashing-based container types  http://hackage.haskell.org/package/unordered-containers-0.2.3.0 (JohanTibell)
16:28:37 <cmccann> :t (***) `asAppliedTo` id
16:28:38 <lambdabot> (c -> c) -> (b' -> c') -> (c, b') -> (c, c')
16:28:45 <cmccann> :t (&&&) `asAppliedTo` id
16:28:46 <lambdabot> (c -> c) -> (c -> c') -> c -> (c, c')
16:28:55 <elliott> shachaf: You'd write foo in an ugly manner.
16:28:56 <cmccann> maybe id isn't the best choice there...
16:28:57 <rwbarton> :t (&&&) . id
16:28:58 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
16:29:01 <elliott> When did I say this was an elegant transformation?
16:29:01 <rwbarton> hm
16:29:04 <elliott> It's hideous.
16:29:09 <dagnachew> guys am following the book "learn you haskell for your good and on it they dont prefix with "let"
16:29:15 <shachaf> elliott: With partial pattern matches and all?
16:30:00 <dagnachew> in my prompt ghci > a = 2 + 4 ==> parse error on input `=` but let a = 2 + 4 works
16:30:26 <shachaf> dagnachew: Where in the book does it say "a = 2 + 4"?
16:30:37 <killerville> :t (+5)
16:30:39 <lambdabot> Num a => a -> a
16:30:42 <elliott> shachaf: Yeah.
16:30:52 <shachaf> elliott: Sorry, that's not good enough.
16:31:02 <shachaf> elliott: Please give me a better solution.
16:31:10 <elliott> tough
16:31:27 <dagnachew> shachaf, I correct my self sorry
16:31:39 <dagnachew> how can we clear the ghci terminal
16:32:33 <dagnachew> nm
16:32:40 <dagnachew> ansi-terminal
16:32:44 <killerville> :t (+5)
16:32:45 <lambdabot> Num a => a -> a
16:32:53 <killerville> :t (&&&)
16:32:54 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
16:33:01 <killerville> :t (+)
16:33:03 <lambdabot> Num a => a -> a -> a
16:33:23 <killerville> what type is a b c?
16:33:27 <killerville> or not type
16:33:39 <shachaf> killerville: "a" really means "(->)"
16:33:43 <shachaf> So "a b c" is "b -> c"
16:33:59 <ski> dagnachew : i suspect when the book says `a = 2 + 4', it means for you to type that into a file, save it, and load it into your interactor (GHCi)
16:34:02 <shachaf> At least, for most uses of (&&&) you'll see in this channel.
16:34:12 <S11001001> :t let x = 5 in (x+)
16:34:14 <lambdabot> Num a => a -> a
16:35:11 <dagnachew> ski, i installed clearscreen and know in ghci it says not in scope clerScreen
16:36:41 <shachaf> dagnachew: Press Ctrl-L
16:36:46 * ski has no idea what "clearscreen" is
16:36:59 <dagnachew> shachaf, :)
16:37:13 <BrianHV> ski: thanks for checking with nickserv. didn't think about that.
16:37:16 <dagnachew> i wont bother further back exploring haskell :)
16:37:36 <ski> BrianHV : alas, `preflex' is no longer among the living
16:38:15 <popl> ski: preflex died?
16:38:47 <killerville> what is the minimum needed to run a haskellprogram on a linuxbox?
16:39:08 <popl> killerville: what do you mean?
16:39:36 <S11001001> killerville: libc, maybe
16:42:06 <coeus_> > putStrLn "\ESC[H\ESC[2J"
16:42:08 <lambdabot>   No instance for (GHC.Show.Show (GHC.Types.IO ()))
16:42:08 <lambdabot>    arising from a use of ...
16:42:28 <killerville> to run a binary on a linuxbox
16:43:12 <killerville> > flip (+1) 5
16:43:14 <lambdabot>   No instance for (GHC.Num.Num (b0 -> c0))
16:43:14 <lambdabot>    arising from a use of `e_115'
16:43:14 <lambdabot>  ...
16:43:21 <killerville> :t flip
16:43:23 <lambdabot> (a -> b -> c) -> b -> a -> c
16:44:03 <killerville> > flip (-) 6 4
16:44:04 <lambdabot>   -2
16:44:15 <c_wraith> > subtract 6 4
16:44:17 <lambdabot>   -2
16:44:39 <coeus_> killerville, the minimum could be...
16:45:07 <popl> ghc?
16:45:13 <popl> I don't understand the question. :(
16:45:24 <coeus_> linux-vdso.so.1 libgmp.so.10 	libm.so.6 	librt.so.1	libdl.so.2	libc.so.6	libpthread.so.0 	/lib/ld-linux-x86-64.so.2
16:45:35 <shachaf> You gotta have linux-vdso
16:47:03 <dagnachew> is it normal that I dont have a .ghci.conf by default ? I have to create it ? to start I just want to have colored ghci
16:47:31 <shachaf> It's normal.
16:47:47 <dagnachew> shachaf, when I did ghci --colour it complained
16:48:14 <shachaf> I don't know what --colour is.
16:48:15 <dagnachew> I want to put color info in .ghci.conf
16:48:24 <shachaf> Don't bother.
16:48:27 <dagnachew> http://www.haskell.org/haskellwiki/GHCi_in_colour
16:48:56 <shachaf> dagnachew: That doesn't exist.
16:49:08 <popl> dagnachew: read the ghci man page. --colour doesn't exist.
16:49:21 <shachaf> dagnachew: Also, colour won't help you learn Haskell. So you shouldn't bother.
16:49:29 <dagnachew> ok
16:49:57 <popl> dagnachew: You can change the prompt, though. You can also load some stuff that will make printing stuff in ghci look nicer.
16:53:15 * hackagebot snap-extras 0.3 - A collection of useful helpers and utilities for Snap web applications.  http://hackage.haskell.org/package/snap-extras-0.3 (DougBeardsley)
16:53:27 <Mark__> hi
17:06:16 <ski> @tell popl re `preflex', "Last seen  : Oct 23 18:33:55 2012 (7 weeks, 2 days, 06:29:45 ago)". it appears mauke stopped running it for some reason
17:06:16 <lambdabot> Consider it noted.
17:09:25 <dagnachew> I loaded a simple module and the prompt changed to *Main> as I am following the book LearnYouHaskell is there a newer haskell book to follow ? my module has one function doubleMe x = x + x
17:11:24 <dagnachew> shachaf, how can I get back to the ghci prompt after loading a module
17:11:48 <pqmodn> dagnachew: not to worry, it's just telling you which modules have been loaded. it's still ghci
17:12:20 <pqmodn> dagnachew: if you really hate it, type :set prompt "ghci> " or whatever
17:12:36 <dagnachew> pqmodn, in .ghci.conf file ?
17:12:51 <pqmodn> dagnachew: is what in .ghci.conf?
17:13:03 <pqmodn> dagnachew: oh, no, at the prompt you can type that
17:13:14 <dagnachew> pqmodn, to not type that everytime ?
17:14:08 <dagnachew> ok pqmodn
17:14:08 <pqmodn> you can do everything at the "*Main> " prompt that you can at the "Prelude> " prompt. but yes, if you want to permanantly change the prompt you can set it in your GHCI config file
17:14:20 <dagnachew> ok
17:14:31 <pqmodn> or you can set it temporarily from inside GHCi
17:19:12 <ToranLipse> Is anyone a lambda calculus expert?
17:19:40 <Dashkal> Facinated with, but no expert.
17:19:48 <startling> I know a bit
17:19:57 <startling> (not an expert either though)
17:20:14 <Dashkal> When I can finally write the y combinator out by understanding the construct, then I'll claim some mastery.
17:20:42 <ToranLipse> I need an expert!
17:20:44 <ToranLipse> Alas!
17:21:52 <startling> ToranLipse: what's your question?
17:21:56 <Dashkal> You could just ask the question and see if anybody pipes up...
17:22:28 <skchrko> ToranLipse, write a letter to mr. Barendregt then
17:22:29 <startling> is a MonadPlus instance ever semantically different from an Alternative instance?
17:23:04 <ToranLipse> lol
17:23:51 <ToranLipse> I need someone that can actually give me a hand with something. someone I can converse with without writing a letter. =P
17:24:05 <Dashkal> startling: The back of my mind is whispering that MonadPlus and Alternative have differing laws, but I cannot commit to that.
17:24:29 <pqmodn> ToranLipse: IRC is good for that, have you tried it?
17:24:47 <ToranLipse> Nah. The people in IRC are a bunch of ****'s
17:24:48 <ToranLipse> =P
17:25:10 <pqmodn> ToranLipse: good luck, then!
17:25:46 <ToranLipse> No lambda calculus experts want to earn some money??
17:25:47 <ToranLipse> =P
17:26:15 <startling> does Alternative have any laws?
17:26:26 <Chathurga> ToranLipse: lambda calculus experts already have more women and money than they can get to in a lifetime
17:26:30 <startling> ToranLipse, you didn't mention that you were willing to pay
17:26:42 <ToranLipse> I would happily pay.
17:28:33 <Nereid> startling: I'm pretty sure Alternative and MonadPlus instances are supposed to agree when they both exist
17:28:46 <startling> Nereid, hmmm, okay
17:28:47 <Nereid> observe: instance (Applicative (WrappedMonad m), MonadPlus m) => Alternative (WrappedMonad m)
17:29:11 <startling> oh, interesting
17:29:35 <startling> but it seems like MonadPlus guarantees that mzero >>= x is mzero, where Alternative doesn't guarantee that empty *> x is empty.
17:29:47 <Nereid> and note that both of them list the same laws
17:30:09 <Nereid> hmm, MonadPlus has more laws.
17:30:10 <startling> Nereid: where? I'm not seeing any Alternative laws other than the Monoid laws
17:30:12 <rwbarton> @type empty *> ?x
17:30:13 <lambdabot> (?x::f b, Alternative f) => f b
17:30:26 <startling> > Nothing *> Just 12
17:30:27 <lambdabot>   Nothing
17:30:30 <Nereid> yes, the monoid laws are what I'm talking about.
17:30:31 <rwbarton> I think it is a free theorem
17:30:53 <Nereid> what's a free theorem?
17:31:06 <rwbarton> empty *> x = empty
17:31:19 <Nereid> hm
17:31:20 <startling> So would I be justified in replacing MonadPlus in Idris with just Alternative? :D
17:31:23 <rwbarton> maybe not
17:31:28 <rwbarton> maybe only mzero >>= x = mzero is
17:31:50 <rwbarton> that sounds plausible actually, since the 'x' in mzero >>= x can't do much
17:31:56 <rwbarton> while the empty *> x can, potentially
17:32:06 <rwbarton> well
17:32:11 <rwbarton> I remember this being tricky
17:32:25 <mm21> what is up with ?x
17:32:33 <pqmodn> mm21: implicit params
17:33:03 <mm21> thx
17:47:36 <dmj> @help
17:47:36 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
17:47:49 <dmj> @help list
17:47:50 <lambdabot> list [module|command]
17:47:50 <lambdabot> show all commands or command for [module]. http://code.haskell.org/lambdabot/COMMANDS
17:48:44 <dmj> karma dmj
17:49:20 <Modius> oddSquareSum = sum . takeWhile (< 10000) . filter odd $ map (^ 2) [1 .. ]
17:49:20 <Modius>     -  what is it that allows this to terminate?  I know it's lazy; but how does it stop trying to draw from the infinite list?
17:50:09 <hpc> Modius: so let's go from the outside in
17:50:15 <hpc> oddSquareSum = sum ?
17:50:31 <hpc> so right away we know it's going to be munching the entirety of some kind of list
17:50:46 <hpc> ? = takeWhile (< 10000) ??
17:50:48 <Modius> I know how it works logically; but I don't get how it knows to stop munching the infinite list
17:50:55 <Nereid> > takeWhile (<10) [1..]
17:50:57 <lambdabot>   [1,2,3,4,5,6,7,8,9]
17:51:02 <Modius> I statically can see that the list keeps growing; but how can it see?
17:51:11 <rwbarton> because of what takeWhile does
17:51:13 <Modius> That's the point - takeWhile - can it statically see that the list is forever-growing?
17:51:17 <hpc> so we consume from some list until we hit our first element >= 10000
17:51:19 <hpc> then we stop
17:51:25 <Modius> Oh - takewhile
17:51:31 <Modius> I was thinking of filter operation.  Sorry.
17:51:33 <hpc> so all that last list needs to do is hit 10000 or more, at some point ever
17:51:34 <hpc> ;)
17:52:54 <dcoutts> for the adventurous users: the test instance of new hackage server impl is now doing live mirroring
17:52:56 <dcoutts> http://new-hackage.haskell.org/recent.html
17:56:06 <jmcarthur> sweet!
17:57:24 <jmcarthur> Modius: filter only stops because takeWhile stops
17:58:13 <rwbarton> if there somehow weren't any odd squares above 10000, then the takeWhile would never finish
17:59:31 <pqmodn> @pl (\x -> [x])
17:59:31 <lambdabot> return
18:01:32 <Nereid> or (:[])
18:01:52 <c_wraith> @quote eat.a.comment
18:01:52 <lambdabot> SamB_XP says: I once saw it eat a comment (:[{- Help! -}])
18:01:58 <pqmodn> ah, of course. thanks
18:03:16 * hackagebot edge 0.8.20 - Top view space combat arcade game  http://hackage.haskell.org/package/edge-0.8.20 (ChristopherHoward)
18:13:42 <Modius> In a typical project, what's the way around the warning  Warning: Defaulting the following constraint(s) to type `Integer'
18:13:53 <shachaf> Disable the warning.
18:13:56 <shachaf> Or make it not default.
18:14:12 <Modius> What's the idiomatic policy on this sort of thing on large projects?
18:14:19 <hpc> type signatures everywhere
18:14:31 <shachaf> I think that warning is fine to disable.
18:14:55 <Modius> As an example on the line oddSquareSum = sum . takeWhile (< 10000) . filter odd $ map (^ 2) [1 .. ] what would get rid of that warning?
18:15:10 <Modius> By type sig I assume you mean on the line itself (as putting a sig above the line doesn't help)
18:15:17 <hpc> oddSquareSum :: Int
18:15:25 <hpc> or something else
18:15:25 <rwbarton> you are talking about the (^ 2)?
18:15:33 <hpc> :t sum . takeWhile (< 10000) . filter odd $ map (^ 2) [1 .. ]
18:15:35 <lambdabot> Integral b => b
18:15:44 <hpc> :t (^)
18:15:46 <lambdabot> (Integral b, Num a) => a -> b -> a
18:15:48 <shachaf> Oh, that 2 is defaulting.
18:15:50 <Modius> Yeah, technically the ^ 2 is the trigger - is there something I should put next to it?
18:15:52 <hpc> oh, hmm
18:15:53 <shachaf> You can annotate it.
18:15:58 <cmccann> Modius, (2 :: Int)
18:15:58 <shachaf> ^ (2::Int)
18:15:58 <Modius> How do I annotate it?
18:16:00 <cmccann> or such.
18:16:01 <shachaf> If you want.
18:16:03 <Modius> Aah - thanks
18:16:04 <hpc> :t (**)
18:16:05 <cmccann> but that's ugly.
18:16:06 <lambdabot> Floating a => a -> a -> a
18:16:10 <hpc> :t (^^)
18:16:10 <shachaf> It is.
18:16:11 <lambdabot> (Fractional a, Integral b) => a -> b -> a
18:16:17 <hpc> blech
18:16:23 <cmccann> I'd just disable the warning about defaulting. it's a bit silly.
18:16:47 <Modius> Is it pretty common to disable that warning in large haskell projects I may see?
18:17:24 <shachaf> I assume so.
18:18:17 * hackagebot cassava 0.2.1.1 - A CSV parsing and encoding library  http://hackage.haskell.org/package/cassava-0.2.1.1 (JohanTibell)
18:18:22 * cmccann would consider a "run a spellchecker on comments and warn on any unrecognized words" more useful than the defaulting warning.
18:18:41 <rwbarton> really?
18:18:49 <rwbarton> I think it can catch bugs
18:19:11 <Modius> Leads to another question then - how do I disable that specific warning?  Does it go in the .cabal file?
18:19:26 <cmccann> I have a hard time imagining how, other than easily-fixed performance issues
18:19:28 <shachaf> Sounds right.
18:19:38 <cmccann> well, the dumb defaulting to floats instead of rational might cause problems
18:19:45 <cmccann> but that's a misfeature more than defaulting is
18:20:02 <rwbarton> well you can change that if you like
18:20:16 <cmccann> I'd do that before I'd turn on the warning, yes
18:20:17 <Modius> Does anyone here use ghc-mod / emacs. . . . is there a trick to make it consider other files in the wider project for its compile-onn-the-fly?
18:21:05 <jmcarthur> i never turn off the defaulting warning
18:21:27 <cmccann> really, though, what kind of bugs would the defaulting warning catch? I honestly cannot think of a scenario where it would help.
18:21:34 <jmcarthur> in performance critical code, i don't want it to default my numbers to Integer, for example
18:21:46 <rwbarton> i can't recall off-hand
18:21:55 <cmccann> in performance-critical code you probably want monomorphic types anyway, don't you?
18:22:07 <jmcarthur> yeah. and the warning makes sure i do so
18:22:31 <cmccann> a profiler will do that and more :P
18:22:47 <jmcarthur> the compiler gives much faster feedback
18:22:48 <cmccann> and if I care that much about performance I'm gonna profile the code anyway I'm sure
18:22:57 <rwbarton> profiler won't do that
18:23:14 <cmccann> still doesn't seem like it would outweigh the annoyance of the warning the rest of the time
18:23:39 <rwbarton> profiler just tells you what is slow, not why
18:24:25 * cmccann shrugs
18:24:41 <cmccann> not convinced, sorry :P
18:24:46 <cmccann> it's a dumb warning
18:25:16 <rwbarton> well I hardly expect "I think I saw a bug that would have been caught by the warning but I can't recall what it was" to be very convincing
18:25:56 <cmccann> yes, and once the "perhaps you should write an instance for this" suggestion GHC makes was actually what I needed to do to fix a "no instance" error.
18:26:07 <cmccann> unusual things happen now and then!
18:26:29 <rwbarton> I usually don't bother with warnings at all
18:26:32 * rwbarton lives dangerously
18:26:41 <shachaf> I prefer to not make mistakes.
18:26:47 <cmccann> good plan.
18:26:58 <shachaf> That's why I disable the type system, too.
18:27:04 <cmccann> I prefer to blame shachaf for my mistakes.
18:27:19 <rwbarton> shachaf isn't kidding, have you seen the lens source
18:27:19 <shachaf> edwardk does the same thing but is more explicit about it, with unsafeCoerce.
18:27:37 <cmccann> hahaha
18:27:47 <shachaf> rwbarton: Hey, I worked hard at getting rid of most of these!
18:28:10 <shachaf> We only had one release that claimed to be Trustworthy while allowing you to segfault.
18:28:23 <cmccann> oh only one ok then
18:28:32 <cmccann> carry on
18:28:43 <hpaste> crd1 pasted “split function” at http://hpaste.org/79174
18:28:43 <shachaf> I blame edwardk for that.
18:28:50 <shachaf> A couple of days after the release I figured out how to do it safely.
18:29:11 <shachaf> cmccann: The way to do it safely was s/unsafeCoerce/undefined/, by the way. The unsafeCoerce was never actually getting called.
18:29:44 <cmccann> that's the best kind of unsafeCoerce.
18:30:05 <Crd1> For the function I have pasted
18:30:18 <Crd1> I can't really see what's happening there
18:30:26 <shachaf> Crd1: Neither can we.
18:30:30 <rwbarton> don't worry, ... ^
18:30:33 <Crd1> lol
18:30:38 <shachaf> Why do you have multiple different things named "split"?
18:30:58 <rwbarton> this is hardly an advertisement for foldl
18:31:01 <Crd1> It's a code I copied out of my notes actually
18:31:08 <Crd1> not mine
18:31:21 <Crd1> But it attempts
18:31:28 <elliott> well the good news is that you didn't write that code
18:31:31 <elliott> the bad news is that someone else did...
18:31:34 <Crd1> to split a list of numbers according to its signs
18:31:55 <Crd1> so for example, split [-1,1,2,-2] gives [[-1],[1,2],[-2]]
18:32:56 <Crd1> split [1,2,3,-1,-2,7,4,-3,-5,-6,2,3] gives [[1,2,3],[-1,-2],[7,4],[-3,-5,-6],[2,3]]
18:33:07 <shachaf> > groupBy ((==) `on` signum) [1,2,3,-1,-2,7,4,-3,-5,-6,2,3]
18:33:08 <Nereid> > groupBy ((> 0) `on` (*)) [1,2,3,-1,-2,7,4,-3,-5,-6,2,3]
18:33:09 <lambdabot>   [[1,2,3],[-1,-2],[7,4],[-3,-5,-6],[2,3]]
18:33:10 <lambdabot>   Couldn't match expected type `b0 -> GHC.Types.Bool'
18:33:10 <lambdabot>              with actua...
18:33:12 <Nereid> oops
18:33:19 <Nereid> backwards.
18:33:35 <Nereid> > groupBy ((> 0) .: (*)) [1,2,3,-1,-2,7,4,-3,-5,-6,2,3]
18:33:37 <lambdabot>   [[1,2,3],[-1,-2],[7,4],[-3,-5,-6],[2,3]]
18:33:46 <Nereid> signum is better
18:33:48 <Crd1> haha, does the same thing huh
18:34:10 <stepkut> lambdabot: [8, 6, 7, 5, 3, 0, 9] -- callme!
18:34:10 <Crd1> I can see what the foldl does
18:34:20 <Crd1> if we have the input [-1,1]
18:34:29 <Nereid> > groupBy const [True,False,True,False,False,True,True,True,False]
18:34:31 <lambdabot>   [[True,False,True,False,False,True,True,True,False]]
18:34:33 <Nereid> oops
18:34:38 <hpc> heh
18:34:39 <Nereid> > groupBy (const id) [True,False,True,False,False,True,True,True,False]
18:34:41 <lambdabot>   [[True],[False,True],[False],[False,True,True,True],[False]]
18:34:54 <shachaf> @src groupBy
18:34:55 <lambdabot> groupBy _  []       =  []
18:34:55 <lambdabot> groupBy eq (x:xs)   =  (x:ys) : groupBy eq zs
18:34:55 <lambdabot>     where (ys,zs) = span (eq x) xs
18:34:57 <Nereid> > groupBy const [False,True,False,True,False,False,True,True,True,False]
18:34:58 <Nereid> heh
18:34:59 <lambdabot>   [[False],[True,False,True,False,False,True,True,True,False]]
18:35:03 <hpc> :t groupBy
18:35:05 <lambdabot> (a -> a -> Bool) -> [a] -> [[a]]
18:35:10 <hpc> :t groupBy id
18:35:12 <lambdabot>     Occurs check: cannot construct the infinite type: a0 = a0 -> Bool
18:35:12 <lambdabot>     Expected type: a0 -> a0 -> Bool
18:35:12 <lambdabot>       Actual type: a0 -> a0
18:35:15 <hpc> :(
18:35:24 <Crd1> It would be so much easier if I was able to use a tracer like in Scheme =(
18:35:54 <hpc> @quote oasis
18:35:54 <lambdabot> chromatic says: My productivity increased when Autrijus told me about Haskell's trace function. He called it a refreshing desert in the oasis of referential transparency.
18:36:12 <popl> Perl's chromatic?
18:36:12 <lambdabot> popl: You have 1 new message. '/msg lambdabot @messages' to read it.
18:36:16 <shachaf> I doubt that's what Crd1 means.
18:36:18 <popl> wat
18:36:49 <popl> Nobody ever talks to me. :O
18:36:53 <Crd1> The tracer in DrRacket I mean
18:37:10 <popl> ski: mauke has been missing from Perl for awhile.
18:37:15 <popl> #perl
18:37:45 <Crd1> Can you help me as I trace it please? =)
18:37:55 <popl> 18:37 <perlbot> I last saw mauke saying "vivalavinnie: yes" at Wed Dec  5 07:26:59 2012 Z.
18:37:58 <Crd1> Let's say we have the input [-1,1]
18:37:58 <shachaf> Crd1: Trace what?
18:38:10 <Crd1> As in step through
18:38:16 <Crd1> the function I pasted
18:38:22 <shachaf> No, that function gives me a headache.
18:38:29 <Crd1> lol
18:38:30 <shachaf> It's bad code in all sorts of ways.
18:38:35 <rwbarton> just Calevaluate your code
18:38:37 <Crd1> Ah I see
18:38:45 <popl> calevaluate?
18:38:45 <Crd1> My prof writes bad code
18:38:47 <Crd1> Lol
18:38:53 <Modius> Having trouble searching for details as most posts are requests for the feature;but some claim it exists.  Windows 64-bit build from GHC - how can I ask a cabal build for a 64-bit windows build?
18:38:59 <shachaf> rwbarton: I think that only works for a fixed set of inputs.
18:39:03 <shachaf> Like double (double 5)
18:39:15 <hpc> Modius: it should do it automatically
18:39:21 <hpc> do you have a 64-bit ghc?
18:39:49 <shachaf> shachaf@carbon:~/haskell-log$ grep '<Cale>.*double (double 5)' ALL | wc -l
18:39:49 <shachaf> 205
18:39:52 <Modius> hpc:  Just noticed I have 7.4.1 so probably not :(
18:40:45 <shachaf> 7.4.1 is orthogonal to 64-bit
18:40:55 <shachaf> Try ghc --info
18:41:25 <shachaf> If GHC generates a 64-bit thing at all, then it probably generates only 64-bit things.
18:41:28 <Modius> shachaf:  I see a lot of "Mingw32" so no.
18:41:49 <ski> popl : NickServ reports about the same last seen time. still the one for preflex is much longer, possibly mauke just has some minor connection or similar trouble
18:42:17 <ski> @where stepeval
18:42:17 <lambdabot> http://www.srcf.ucam.org/~bm380/cgi-bin/stepeval.cgi
18:42:19 <popl> I hope that's it.
18:42:25 <popl> I hope he's OK.
18:42:27 <ski> Crd1 : did you try that ^ one ?
18:43:30 <Crd1> Hmm, not yet
18:43:35 <Crd1> Lemme try
18:43:56 <keb> solike,.,.,. ,I wana know.,,., with this HASKOR junk,..,., do like functions AUTOMATICALLY get called 4.41 times per second? is that called in MAIN? and where do exicutibles get paused on the chip? PM PLZ
18:44:31 <simpson> keb: Hi! Welcome to #haskell!
18:44:45 <rwbarton> that's one of the most broken keyboards I have seen here in a while
18:44:50 <rwbarton> you should get a new one
18:45:02 <Crd1> ski: do I paste my split function into the source file in github? haha
18:46:07 <Crd1> Ohh
18:49:38 <elliott> @remember keb solike,.,.,. ,I wana know.,,., with this HASKOR junk,..,., do like functions AUTOMATICALLY get called 4.41 times per second? is that called in MAIN? and where do exicutibles get paused on the chip? PM PLZ
18:49:38 <lambdabot> Okay.
18:50:15 * cmccann resists the temptation to warn keb about stairs
18:50:29 <simpson> Heh. "IT KEEPS HAPPENING"
18:50:32 <shachaf> @forget keb solike,.,.,. ,I wana know.,,., with this HASKOR junk,..,., do like functions AUTOMATICALLY get called 4.41 times per second? is that called in MAIN? and where do exicutibles get paused on the chip? PM PLZ
18:50:32 <lambdabot> Done.
18:50:36 <shachaf> Come on, elliott.
18:50:39 <shachaf> This isn't #esoteric.
18:52:01 <copumpkin> shachaf: ಠ_ಠ
18:53:12 <shachaf> copumpkin: Do you think that quote belongs in @remember?
18:53:32 <copumpkin> I wasn't ಠ_ಠing at that
19:08:31 <JoeyA> If I want to make a simple stream that will only be traversed once, is this a good idea?  data Stream a = Item a (() -> Stream a) | Done
19:09:46 <JoeyA> (() -> Stream a) is basically equivalent to (Stream a) in Haskell due to purely functional semantics, but I'm doing that to keep it from retaining the list of Stream elements.
19:09:46 <Nereid> why () -> Stream a ?
19:10:01 <Nereid> retaining?
19:10:40 <JoeyA> If I say Item a (Stream a) | Done, then it's just like [a]
19:11:08 <Nereid> yes
19:11:16 <JoeyA> If you traverse a list, and the code isn't sufficiently optimized, it may keep the whole list around due to a dangling reference to the first cons.
19:11:44 <Nereid> and how is this supposed to change that?
19:11:48 <JoeyA> That shouldn't happen, but sometimes does.
19:12:22 <JoeyA> That's the question.
19:13:20 <Nereid> or rather
19:13:20 <Nereid> why should one expect that it would change that?
19:13:42 <elliott> you avoid sharing with (() -> Stream a)
19:14:35 <JoeyA> elliott: Right.  Is this a good idea, given that I don't want it to build a linked list in memory and forget to garbage collect it?
19:15:27 <elliott> depends, I would say :P
19:19:51 <shachaf> Crd1: If you can't work out that split function on your own, you should practice working out simpler things on your own until you can do it.
19:20:29 <shachaf> Rather than asking other people to evaluate bad code step by step for you. :-)
19:21:55 <Crd1> shachaf: Haha alright, you saw my posting? =)
19:23:02 <shachaf> Yes.
19:30:38 <elliott> eurgh, new hashable library has a global name that changes over program invocations
19:30:46 <zomg> Heh, I just noticed dons has 66.6k rep on stack overflow...
19:30:54 <zomg> haskell the language of the beast
19:32:59 <shachaf> elliott: defaultSalt?
19:33:36 <elliott> yes
19:35:19 <sclv> new hashable bothers me
19:37:38 <copumpkin> @hackage hashable
19:37:38 <lambdabot> http://hackage.haskell.org/package/hashable
19:38:10 <copumpkin> wtf
19:39:27 <sclv> defaultSalt = unsafePerformIO . alloca $ \p -> do
19:39:27 <sclv>                 getRandomBytes_ "defaultSalt" p (sizeOf (undefined :: Int))
19:39:28 <sclv>                 peek p
19:39:41 <copumpkin> yeah, that was where the wtf came from
19:40:18 <copumpkin> does the constant one really need an inline pragma?
19:41:06 <sorbo_> haskell
19:41:08 <sorbo_> hurts my frontal lobe
19:41:31 <copumpkin> is that you, hercules?
19:44:10 <elliott> copumpkin: to be fair, base propagates the same sin as hashable to some degree
19:44:22 <copumpkin> oh?
19:44:24 <elliott> http://hackage.haskell.org/packages/archive/base/4.6.0.0/doc/html/System-Info.html
19:44:33 <copumpkin> oh, sure
19:44:38 <copumpkin> but it's not doing it intentionally
19:44:44 <copumpkin> that's more of a design decision
19:44:50 <copumpkin> they didn't have to go out of their way to make it so
19:44:57 <copumpkin> (a bad one, in my opinion)
19:45:02 <elliott> (though those are actually compile-time constants, they don't have to be)
19:45:09 <elliott> (you can easily imagine an implementation for which they are not)
19:45:10 <copumpkin> but you can take that as far as you want, and kill Int
19:45:11 <copumpkin> or Word
19:45:27 <elliott> I don't like Int/Word either :)
19:45:29 <elliott> Int :: IO *
19:46:00 <copumpkin> lol
19:46:08 <sclv> yes the inline pragma for the constant is v. funny
19:46:13 <sclv> how dumb can the compiler be
19:46:44 <copumpkin> sclv: what's weirder is when I see someone taking something like topLevelConstant :: Int; topLevelConstant = someexpensivecalc; {-# INLINE topLevelConstant #-}
19:46:57 <copumpkin> where without the inline, the expensive calc would happen once
19:46:59 <SwineFlu> How long will it take me to complete the "99 Haskell Problems"
19:47:08 <SwineFlu> I've programmed in alot of other langs
19:47:17 <copumpkin> SwineFlu: then it'll take longer than if you hadn't
19:47:19 <SwineFlu> but never a functional language
19:47:20 <parcs`> approximately 99 * average time it takes to complete 1 problem
19:47:36 <SwineFlu> parcs`, They get harder though :p
19:47:54 <parcs`> do it backwards
19:48:16 <sclv> we spend too much time with benchmarks and too little time with profiling
19:48:18 <sclv> causes blindess
19:49:25 <flebron> Hi. Newbie question, is there something like (Ord a) => data AVLTree a = ... ?
19:49:34 <flebron> That is, restrict parametric types via typeclasses.
19:49:46 <copumpkin> not on the types themselves like that
19:49:50 <copumpkin> there is, but you shouldn't use it
19:49:54 <shachaf> flebron: Yes, but you probably don't want to do that.
19:50:00 <copumpkin> because it doesn't behave the way you'd expect and it's deprecated
19:50:07 <shachaf> In general you put the constraints on functions that use the type.
19:50:12 <flebron> Well, doesn't it make sense to say "AVL trees require that their type is ordered"?
19:50:30 <shachaf> It does, but you write that as insert :: Ord a => a -> AVLTree a -> AVLTree a
19:50:45 <elliott> copumpkin: technically there isn't as of2012 :)
19:50:47 <flebron> Alright, I'll add the restrictions in the functions then.
19:50:48 <elliott> er, 2010
19:51:12 <flebron> I suppose it makes sense too, since if I make this a module, people won't even be able to make instances of the type which don't conform to the typeclasses I request.
19:51:18 <flebron> (Because I won't export the ctors.)
19:51:18 <shachaf> copumpkin: Well, there's the other way of doing it, which does "sort of" do what flebron wants.
19:51:30 <copumpkin> yeah, but don't
19:51:35 <shachaf> flebron: Well, they might be able to make a singleton AVLTree. :-)
19:51:48 <shachaf> Since that probably doesn't need the Ord constraint as such.
19:51:50 <shachaf> It's just not very useful.
19:51:52 * flebron stays away from dark places in Haskell. I know enough not to poke in dark wizardry.
19:51:54 <parcs`> or an empty AVL tree
19:52:09 <Nereid> oh JoeyA left.
19:52:42 <Nereid> I wonder if it would have been of any help at all to make a cps'd list.
19:52:54 <Nereid> forall b. b -> (a -> b -> b) -> b
19:53:22 <copumpkin> :t build
19:53:23 <lambdabot>     Not in scope: `build'
19:53:23 <lambdabot>     Perhaps you meant `buildG' (imported from Data.Graph)
19:53:27 <copumpkin> @hoogle build
19:53:27 <lambdabot> GHC.Exts build :: (forall b. (a -> b -> b) -> b -> b) -> [a]
19:53:27 <lambdabot> Data.Graph.Inductive.Internal.Heap build :: Ord a => [(a, b)] -> Heap a b
19:53:27 <lambdabot> Graphics.Rendering.OpenGL.GLU.Mipmapping build1DMipmaps :: TextureTarget -> PixelInternalFormat -> GLsizei -> PixelData a -> IO ()
19:57:48 <sclv> @remember ion monad.bind = function (func, args) { return func.apply(undefined, [value].concat(Array.prototype.slice.apply(args || []))); }; is idiomatic JavaScript?
19:57:48 <lambdabot> It is forever etched in my memory.
20:01:06 <zomg> Anyone happen to know if there's some easy way to have Hakyll parse custom syntax in a markdown file?
20:01:37 <zomg> Basically, I would like it to read a file and apply a syntax highlighter to it, and then embed it into the document
20:03:35 <zomg> Ah of course I find an answer right away =) https://groups.google.com/forum/?fromgroups=#!topic/hakyll/vYtcOAceIks
20:04:13 <johnw> what does the 'z' mean in zomg?
20:05:25 <Nereid> absolutely nothing
20:05:26 <SwineFlu> Is there any fundamental difference between a list and an array in say java
20:05:37 <SwineFlu> other than haskells typing of the elements?
20:05:47 <Nereid> haskell lists are linked lists
20:05:50 <SwineFlu> ah
20:05:55 <SwineFlu> I was about to ask that
20:06:08 <SwineFlu> Is there an array format?
20:06:10 <parcs`> what's an ArrayList?
20:06:12 <Nereid> there are arrays
20:06:17 <Nereid> for random access
20:06:25 <Nereid> and there are lots of other container types
20:06:40 <Nereid> e.g. Seq
20:07:20 <SwineFlu> I read that functional data types can't be changed after complie time?
20:07:27 <Nereid> ???????
20:07:34 <SwineFlu> no?
20:08:01 <Nereid> haskell doesn't have "variables" that can be changed.
20:08:09 <sorbo_> haskell doesn't have mutable state
20:08:10 <Nereid> (unless you start talking about IORef/STRef/...)
20:08:33 <latermuse> Container types are just functors, correct?
20:08:41 <Nereid> "just"?
20:08:56 <SwineFlu> So everytime I add something to my list i'm creating a new instance of list?
20:09:13 <SwineFlu> or has my brain been melted by writing java too long
20:09:37 <Nereid> not that any insight could be gained from that statement
20:10:06 <johnw> SwineFlu: one thing that helps in thinking about Haskell is to think about "values" rather than "in-memory representations of values"
20:10:14 <Nereid> SwineFlu: it's probably all the java :p
20:10:17 <johnw> there is a way of making a new list from an old list by copying
20:10:18 <parcs`> SwineFlu: have you read LYAH?
20:10:36 <johnw> but that is not the only way; and the compiler is free to choose whichever way it wants, so long as the semantics of the program are not changed
20:10:43 <Nereid> SwineFlu: you have much to unlearn, young haskeller.
20:10:48 <SwineFlu> parcs`, i'm working though it now
20:11:16 <parcs`> SwineFlu: good :)
20:12:45 <SwineFlu> Want to do all of the 99 haskell problems by jan 16th
20:12:55 <johnw> good luck!
20:13:13 <sorbo_> I've started doing the euler problems in haskell
20:13:19 * hackagebot coroutine-object 0.1.0 - Object-oriented programming realization using coroutine  http://hackage.haskell.org/package/coroutine-object-0.1.0 (IanWooKim)
20:13:49 <ski> latermuse : <http://sneezy.cs.nott.ac.uk/containers/blog/> ?
20:14:04 <sorbo_> the syntax isn't the tricky part, it's converting my thinking from procedural/OO -> functional
20:17:07 <haskellnewb> sup dudes
20:18:21 * hackagebot hoodle 0.1.0.1 - Executable for hoodle  http://hackage.haskell.org/package/hoodle-0.1.0.1 (IanWooKim)
20:18:23 * hackagebot hoodle-builder 0.1.0 - text builder for hoodle file format  http://hackage.haskell.org/package/hoodle-builder-0.1.0 (IanWooKim)
20:18:25 * hackagebot hoodle-core 0.8.0 - Core library for hoodle  http://hackage.haskell.org/package/hoodle-core-0.8.0 (IanWooKim)
20:18:27 * hackagebot hoodle-parser 0.1.0 - Hoodle file parser  http://hackage.haskell.org/package/hoodle-parser-0.1.0 (IanWooKim)
20:18:29 * hackagebot hoodle-render 0.2.0 - Hoodle file renderer  http://hackage.haskell.org/package/hoodle-render-0.2.0 (IanWooKim)
20:22:28 <LordBrain> Is there an irc client program, not a bot, but an interface for a human, that is written in haskell?
20:23:30 <flebron> So I'm playing with Applicative functors. I have a BinarySeachTree a, which has a Maybe (BinarySearchTree a) as a left node. I'm writing find :: (Ord a) => BinarySearchTree a -> a -> Bool. For the recursive case, when I need to search my left child, with left :: Maybe (BinarySearchTree a), does this make sense? Just True == fmap find left <*> (Just x)?
20:23:32 * hackagebot hoodle-types 0.1.0 - Data types for programs for hoodle file format  http://hackage.haskell.org/package/hoodle-types-0.1.0 (IanWooKim)
20:23:34 * hackagebot xournal-parser 0.5.0 - Xournal file parser  http://hackage.haskell.org/package/xournal-parser-0.5.0 (IanWooKim)
20:23:36 * hackagebot xournal-types 0.5.0 - Data types for programs for xournal file format  http://hackage.haskell.org/package/xournal-types-0.5.0 (IanWooKim)
20:24:09 <flebron> (fmap find left :: Maybe (a -> Bool), so I <*> it, and give it Just x, with x :: a, and then compare that with Just True.)
20:27:43 <johnw> flebron: why not just try it and see?
20:28:06 <flebron> Haven't finished writing the basics yet, so I haven't created any instances of my type :)
20:28:21 <johnw> well, ask your question then :)
20:28:52 <ski> flebron : `maybe False (\t -> find t x) left' ?
20:29:11 <ski> (or with explicit pattern-matching)
20:29:15 * flebron hasn't used maybe
20:29:56 <SwineFlu> haskell errors are almost as sacry as C errors
20:30:07 <ski>   case left of
20:30:14 <ski>     Nothing -> False
20:30:27 <ski>     Just t  -> find t x
20:32:05 <flebron> Ah, cool haha
20:33:20 * hackagebot aeson 0.6.1.0 - Fast JSON parsing and encoding  http://hackage.haskell.org/package/aeson-0.6.1.0 (BryanOSullivan)
20:33:39 <wavewave> hi
20:38:56 <flebron> Is it incorrect to say height (C x) x = 0, when data Foo a = C a, and height :: Foo a -> a -> Integer?
20:39:28 <elliott> Incorrect howso?
20:39:34 <elliott> It's invalid :P
20:39:42 <flebron> I get "    Conflicting definitions for `x'"
20:39:48 <elliott> I assume you want the second argument of height to be checked for equality with the x inside the C?
20:39:50 <shachaf> height (C x) y | x == y = 0
20:39:55 <elliott> Maybe you want height (C x) y | x == y = 0.
20:40:01 <shachaf> Maybe.
20:40:07 <elliott> You'll need to say height :: (Eq a) => Foo a -> a -> Integer for that, since you are comparing two "a" values for equality.
20:40:11 <flebron> Right, I'd want that check. Can't it be written more succinctly?
20:40:14 <elliott> (So they have to be comparable for equality.)
20:40:19 <flebron> Even with Eq a I still get the same :s
20:40:29 <zomg> johnw: I dunno, I started using this nick before the exclamation 'ZOMG!' was popular =)
20:40:30 <elliott> You need to write it like how shachaf/I said with the (Eq a) =>.
20:40:33 <shachaf> Not really. Equality isn't on the same level as pattern matching.
20:40:39 <flebron> "find :: (Eq a, Ord a) => AVLTree a -> a -> Bool"
20:40:39 <elliott> It doesn't get shorter than that, but it's not something you want to do terribly often anyway.
20:40:51 <shachaf> I wouldn't want "height (C x) x = 0" to implicitly use (==)
20:40:52 <flebron> find (Leaf x) x = True is the actual line.
20:41:00 <flebron> Ah, OK. I would :p
20:41:47 <wavewave> hoodle is now compatible with ghc 7.6. anyone interested in it, please try it.
20:41:47 <shachaf> That gives (==) magic powers that other functions don't have.
20:41:49 <shachaf> I don't like that.
20:42:00 <shachaf> hi wavewave
20:42:13 <shachaf> Is that the thing you were working on in January?
20:42:13 <wavewave> shachaf: hi!
20:42:19 <applicative> this hoodle thingy looks awesome comrade wavewave
20:42:25 <wavewave> shachaf: yes.
20:42:29 <wavewave> applicative: thanks!
20:43:13 <ski>   find (Leaf x) x0 = x == x0
20:43:14 <elliott> shachaf: Other functions except fromInteger, negate, ...
20:43:40 <shachaf> elliott: No other function has *this particular* magic power.
20:43:59 <shachaf> ski: I assume there were more equations later that changed the meaning of that.
20:44:08 <SwineFlu> How do I write a pattern for a list of any size :S
20:44:13 <shachaf> (If it was just find _ _ = False then what you wrote would be an improvement.)
20:44:13 <elliott> shachaf: Except (==), because foo (C 0) = ... translates to foo (C x) | x == 0 = ...
20:44:40 <shachaf> elliott: Yes, but (==) doesn't have the magic power where you can write "f x x = ..." and it turns into "f x y | x == y = ..."
20:44:49 <elliott> That is true.
20:44:55 <shachaf> I'm not sure what your point is.
20:45:01 <slack1256> The monad laws should be obeyed because the compiler relies on them to optimize or to maintain semantic meaning on the monad class?
20:45:29 <shachaf> slack1256: I don't know that GHC relies on them. As far as I know it doesn't.
20:45:52 <shachaf> But someone could add rewrite rules that rely on them if they wanted to. There might be some somewhere.
20:46:12 <shachaf> Certainly humans like me rely on them all the time.
20:46:28 <shachaf> (I'm definitely completely human. Don't listen to cmccann.)
20:46:59 <cmccann> shachaf is definitely completely human. don't listen to me.
20:47:06 <johnw> slack1256: yes
20:47:17 <shachaf> cmccannsnack
20:47:22 <cmccann> :]
20:47:23 <slack1256> johnw: yes to the first part or to the second?
20:47:30 <johnw> yes to both parts
20:47:39 <johnw> saying something is a Monad creates the assumption that it is, in fact, a Monad
20:47:42 <wavewave> I hope that there are some computing facilities for checking compilability of a haskell package. Installing each version of ghc, haskell platform on my system is a little burdensome.
20:47:49 <shachaf> johnw: I'm not sure what that means.
20:47:50 <johnw> if it's not, all bets are off
20:48:05 <shachaf> johnw: Saying "instance Monad Foo" says that Foo is, in fact, an instance of the class Monad.
20:48:12 <shachaf> It's not saying (to the compiler) anything about the monad laws.
20:48:15 <NemesisD> shachaf: hey man. i did what you said and wrote an isolated case for blocking/handling sigHUPs, was wondering if you could help troubleshoot it
20:48:28 <shachaf> NemesisD: It's possible.
20:48:41 <slack1256> mmm, I thought it used only to desugar the do-notation
20:48:47 <hpaste> NemesisD pasted “blocking for SIGHUP” at http://hpaste.org/79179
20:48:48 <cmccann> an instance of Monad is not the same thing as a monad. distinguishing the two by capitalization helps a bit.
20:49:19 <NemesisD> awaitSignal doesn't block
20:49:35 <cmccann> but yes, if something is declared to be the former I full well expect that it better be the latter, or at least a passable imitation of one.
20:50:11 <SwineFlu> myLast (_:a) = [a] !! length [a]            I'm trying to return the last element of a list using that code... But i get the error "index to large"
20:50:11 <shachaf> NemesisD: Sure it does.
20:50:19 <shachaf> It just doesn't block on sigINT
20:50:21 <SwineFlu> can anyone point me in the right direction
20:50:34 <shachaf> NemesisD: Try awaitSignal Nothing
20:50:38 <ski> > "last" !! length "last"
20:50:39 <lambdabot>   *Exception: Prelude.(!!): index too large
20:50:53 <ski> > "last" !! (length "last" - 1)
20:50:55 <lambdabot>   't'
20:50:57 <shachaf> Your blockSignals reservedSignals and unblockSignals probably don't have any effects because awaitSignals swaps in a new mask.
20:51:19 <shachaf> NemesisD: Did you try deleteSignal sigINT fullSignalSet like I suggested yesterday?
20:51:24 <ski> > ["last"] !! length ["last"]
20:51:26 <lambdabot>   "*Exception: Prelude.(!!): index too large
20:51:36 <ski> > ["last"] !! (length ["last"] - 1)
20:51:38 <lambdabot>   "last"
20:52:24 <SwineFlu> Perhaps because length returns a int
20:52:37 <NemesisD> shachaf: i haven't tried that yet. why would I omit sigINT
20:52:40 <ski> > length ["last"]
20:52:41 <lambdabot>   1
20:53:03 <ski> > let _:a = "last" in length [a]
20:53:05 <lambdabot>   1
20:53:08 <ski> > let _:a = "last" in (a,length [a])
20:53:09 <lambdabot>   ("ast",1)
20:53:24 <shachaf> @google what is a signal mask
20:53:25 <lambdabot> http://www.gnu.org/s/libc/manual/html_node/Process-Signal-Mask.html
20:53:26 <lambdabot> Title: Process Signal Mask - The GNU C Library
20:53:43 <ski> SwineFlu : do you understand those examples ?
20:53:50 <NemesisD> shachaf: with Nothing, HUP actually hangs up on it
20:54:03 <shachaf> NemesisD: OK, then you probably want to block HUP.
20:54:09 <SwineFlu> ski, Just looks like moonspeak to me :(
20:54:33 <shachaf> SwineFlu: Maybe you should try writing simpler Haskell code for now to figure out the syntax.
20:54:39 <ski> SwineFlu : your `[a]' is a list which always has exactly one element (that element is `a', which is a list)
20:54:48 <NemesisD> shachaf: so I want to block the signal first that I want to await?
20:54:59 <SwineFlu> I thought a was like  a generic
20:55:09 <ski> SwineFlu : `a', yes. `[a]', no
20:55:17 <SwineFlu> ohh
20:55:23 <SwineFlu> ohhh
20:55:25 <SwineFlu> ohhhh
20:55:54 <shachaf> NemesisD: I didn't actually read the documentation (that's your job :-) ), so I'm just making guesses here.
20:56:32 <shachaf> NemesisD: I'm guessing that the SignalSet is a set of signals that are blocked, i.e., that your process won't respond to.
20:56:43 <shachaf> Whereas you're waiting for all the ones that *aren't* blocked.
20:57:11 <shachaf> Which is why I inverted your signal set.
20:57:59 <ski> > ["last","next","first","previous"] !! 0
20:58:01 <lambdabot>   "last"
20:58:03 <NemesisD> shachaf: so if i want to await HUP, I should block everything but HUP then awaitSignal with Just HUP?
20:58:05 <ski> > ["last","next","first","previous"] !! 2
20:58:06 <lambdabot>   "first"
20:58:08 <ski> > ["last","next","first","previous"] !! 3
20:58:10 <lambdabot>   "previous"
20:58:10 <ski> > ["last","next","first","previous"] !! 4
20:58:11 <lambdabot>   "*Exception: Prelude.(!!): index too large
20:58:14 <ski> > length ["last","next","first","previous"]
20:58:16 <lambdabot>   4
20:58:20 * hackagebot attoparsec 0.10.3.0 - Fast combinator parsing for bytestrings  http://hackage.haskell.org/package/attoparsec-0.10.3.0 (BryanOSullivan)
20:58:21 <shachaf> NemesisD: Of course, HUP will still kill the process unless you set up a SIGHUP handler.
20:58:21 <ski> SwineFlu : do you understand that ?
20:58:25 <NemesisD> shachaf: and i have read the documentation several times, its pretty sparse and i don't quite follow it
20:58:37 <ion> > map (\n -> (n, "hello" !! n)) [0..]
20:58:39 <lambdabot>   [(0,'h'),(1,'e'),(2,'l'),(3,'l'),(4,'o'),(5,*Exception: Prelude.(!!): index...
20:58:59 <NemesisD> shachaf: ah, ok i didn't think of that step, i thought it would just awaken the program and continue with execution
20:59:11 <SwineFlu> so when I was calling length it was returning 3, but because i typed [a] it could only ever by size 1
20:59:14 <SwineFlu> and was out of bounds
20:59:20 <shachaf> NemesisD: As far as I know it won't do that.
20:59:40 <SwineFlu> also
20:59:44 <ski> SwineFlu : yes, but even fixing that, it would be (just) out of bounds, because of [see above]
20:59:48 <SwineFlu> its 0 index
20:59:55 <ski> indeed
20:59:57 <SwineFlu> Like arrays in other languages
21:00:07 <ski> s/other/some other/
21:01:36 <SwineFlu> :)
21:01:39 <SwineFlu> thanks
21:01:52 <ski> (: yw
21:02:28 <SwineFlu> How do i make my function take a list of any size :s
21:03:03 <NemesisD> shachaf: that seemed to work!
21:03:13 <NemesisD> thanks!
21:03:22 <johnw> SwineFlu: i think you may want to read the chapter on Lists again in LYAH
21:04:01 <johnw> in general there are only two kinds of lists you concern yourself with: empty and non-empty
21:05:27 <NemesisD> shachaf: although the fact that you have to put it in a handler sort of messes things up. the config is tied to the program state, i was going to have it await a config reload and then just recurse the program with the new state basically
21:06:10 <NemesisD> shachaf: since the handler has to be elsewhere, i guess i can put to an MVar on reload and then have the main thread block on it
21:13:20 * hackagebot gitlib 0.5.0 - Higher-level types for working with hlibgit2  http://hackage.haskell.org/package/gitlib-0.5.0 (JohnWiegley)
21:20:34 <NemesisD> i can't remember, is tail recusion safe to do in haskell
21:20:57 <shachaf> Every kind of recursion is safe to do.
21:21:39 <Clint> unsafeRecurse
21:23:12 <Hafydd> > let unsafeRecurse = unsafeRecurse
21:23:14 <NemesisD> i mean in terms of memory usage, does haskell use TCO
21:23:14 <lambdabot>   not an expression: `let unsafeRecurse = unsafeRecurse'
21:23:45 <Hafydd> I thought I saw someone using "let" before.
21:24:13 <shachaf> NemesisD: "TCO" isn't really a phrase that makes sense in the context of lazy evaluation.
21:24:22 <shachaf> But the short answer is "yes".
21:24:42 <shachaf> I challenge you to find a reasonable way of evaluating Haskell that *doesn't* "use TCO".
21:25:31 <SwineFlu> Ohh yeah
21:25:34 <cmccann> TCO makes sense when talking about e.g. foldl'.
21:25:42 <SwineFlu> it took me like a hour but i wrote my first haskell program
21:26:08 <johnw> only an hour?  good job
21:26:12 <johnw> i think it took me forever
21:26:28 <Clint> i'm still writing it
21:26:29 <shachaf> johnw: Don't be so pessimistic. You'll finish it sometime.
21:26:35 <shachaf> @src foldl'
21:26:36 <lambdabot> foldl' f a []     = a
21:26:36 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
21:26:46 <SwineFlu> Its only 4 lines
21:26:53 <SwineFlu> 4 lines of moonspeak that i can now read
21:27:02 <shachaf> cmccann: I'm not sure how it makes sense for foldl'
21:27:09 <shachaf> Would you also say it makes sense for foldl?
21:28:04 <cmccann> the phrase makes sense. it's still not exactly the same thing.
21:28:07 <keb> Question: is there a UNIX standard for scheduling that gets compiled into the binary for real time audio applications and how are these compile options accessed and activated in, lets say, GHC? What are best practices for programming experimental audio in Haskell?
21:28:43 <johnw> don't real time applications require a real time OS kernel?
21:28:53 * cmccann prefers imaginary time applications
21:29:06 <johnw> cmccann: we call them "games"
21:29:07 <SwineFlu> 3 lines
21:29:26 <johnw> SwineFlu: when you've gotten to -1 lines, you're a true Haskell master
21:29:33 <keb> so a buffer server in the kernel? is this a unix thing?
21:29:41 <cmccann> coincidentally, I've been working on a simple browser game in haskell!
21:29:43 <keb> what if I'm on a mac
21:29:52 <johnw> keb: i don't really know what you're talking about
21:30:18 <keb> i want for make code for sinewaves in speaker out for haskell
21:30:37 <ClaudiusMaximus> keb: http://hackage.haskell.org/packages/archive/synthesizer/0.2.0.1/doc/html/Synthesizer-Overview.html is where i'd start
21:31:08 <ClaudiusMaximus> keb: alternatively i'd write a DSL that compiles to machine code and then uses JACK
21:31:32 <tertl3> u are writing for JACK?
21:31:59 <tertl3> i used to use that for recording my guitar
21:32:00 <keb> i no gnotingg
21:32:08 <johnw> i don't know jack
21:32:16 <tertl3> lol
21:32:17 <cmccann> *rimshot*
21:32:20 <tertl3> hes a nice guy
21:32:25 <keb> I want for write haskel code in speaker out real easyfast
21:32:45 <tertl3> inspeaker?
21:32:51 <keb> yes
21:33:02 <tertl3> please elaborate
21:33:03 <keb> mac 10.7
21:33:20 <tertl3> ok
21:33:21 <ClaudiusMaximus> cat /dev/mem > /dev/dsp  -- no longer works on linux without obscurantist hacks, no clue about OS X
21:33:22 <ski> shachaf : "Would you also say it makes sense for foldl?" -- yes
21:33:29 <tertl3> mac
21:33:40 <tertl3> thats interesting inits own
21:34:00 <tertl3> i didnt know haskell ran on mac
21:34:40 <shachaf> ski: How would a Haskell implementation work that way?
21:35:00 <ski> work what way ?
21:35:35 <clintm> didn't know haskell ran on a mac?  Did I inadvertently step into some sort of irc time warp?
21:36:26 <clintm> Clearly I'm lagging by about ten years or so.
21:36:37 <Clint> macs will be invented next year
21:36:40 <johnw> he did say OS X
21:45:21 <SwineFlu> mmm
21:45:27 <SwineFlu> that enough haskelling for today
21:47:18 * applicative has no mem or dsp in his mac /dev
21:49:52 <covi_> Where can I download this doc + sources: http://www.haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html
21:51:34 <johnw> covi_: that's in the ghc tarball
21:51:52 <popl> covi_: http://www.haskell.org/onlinereport/standard-prelude.html
21:51:54 <johnw> and you see the "source" buttons for each definition, yeah?
21:52:23 <popl> I defer to johnw.
21:53:34 <covi_> What's the difference between 98 and 2010 report? Which one should I use
21:54:09 <applicative> covi_ if  you have ghc  just use the ghc Prelude
21:54:32 <applicative> covi_: or what are you doing with Prelude source?
21:55:37 <covi_> applicative: just wanna take a look
21:56:52 <lispy> covi_: You can think of 2010 report as some ammendments to 98 report.
21:57:00 <applicative> well http://www.haskell.org/onlinereport/standard-prelude.html is at least reasonable. the GHC prelude is imported from all kinds of things
21:57:21 <lispy> covi_: if you get familiar with the 98 report most of it will carry over. We no longer have n+k patterns, but I think that was the only thing removed
21:57:38 <SwineFlu> http://pastebin.ca/2293391 This is my first attempt at haskelling... Am i doing anything extreamly wrong sofar?
21:57:58 <shachaf> covi_: You should probably use the 2010 report if you don't care, because it's newer.
21:58:23 <covi_> OK!
21:58:26 <covi_> Thanks
21:58:28 <lispy> covi_: http://www.haskell.org/onlinereport/haskell2010/haskellli2.html#x3-5000
21:58:49 <applicative> SwineFlu: those are the problems they set, with partial functions?
21:59:16 <SwineFlu>  they just gave a sample output
21:59:36 <SwineFlu> took me so long to write 3 lines of code >.>
21:59:49 <shachaf> SwineFlu: Your last functions traverse the list twice and are therefore inefficient (in some cases extremely inefficient due to GC behavior).
22:00:02 <shachaf> As an exercise you should write them to traverse the list only once.
22:00:43 <shachaf> For example: let x = [1..10000000000] in myLast x will use a lot more memory than the same thing with the normal "last".
22:01:01 <SwineFlu> would reversing the list work?
22:01:12 <applicative> > foldl1 (flip const) "hello"
22:01:14 <lambdabot>   'o'
22:01:36 <SwineFlu> oh, I've not saw that function before :P
22:01:46 <SwineFlu> Need to read more lysh
22:02:02 <lispy> which function is new?
22:02:23 <SwineFlu> foldl1
22:02:31 <lispy> :t foldl1
22:02:32 <lambdabot> (a -> a -> a) -> [a] -> a
22:02:45 <lispy> > foldl1 (+) [1..10]
22:02:47 <lambdabot>   55
22:03:09 <lispy> > scanl1 (+) [1..10]
22:03:11 <lambdabot>   [1,3,6,10,15,21,28,36,45,55]
22:04:02 <SwineFlu> I need to sleep but I will rewrite those in a few hours
22:04:08 <SwineFlu> thx for your help
22:05:59 <lispy> is there a "scan" variant for unfoldr?
22:06:06 <lispy> unscanr?
22:06:26 <lispy> :t iterate
22:06:27 <lambdabot> (a -> a) -> a -> [a]
22:06:38 <alec> hello
22:06:43 <lispy> hi
22:06:47 <applicative> hello alec
22:06:55 <alec> hey lispy, applicative
22:07:43 <alec> lots of users here
22:08:02 <Ralith> yep
22:08:09 <alec> is there anything like codeacademy for haskell?
22:08:16 <alec> besides tryhaskell
22:09:08 <lispy> alec: stack overflow says just tryhaskell: http://stackoverflow.com/questions/10392247/functional-language-equivalent-to-codeacademy
22:09:20 * lispy hasn't heard of anything
22:09:38 <applicative> tryhaskell could use a few more chapters, so to say.  I think we were invited to compose them.
22:10:10 <alec> damn
22:10:14 <alec> because i like that method of learning
22:10:17 <alec> i don't do well with books
22:10:27 <alec> i have asperger's
22:10:36 <alec> i like computers but i have to learn with them interactively
22:11:01 <alec> and i'm not good enough to learn to code on my own without some sort of interactive structure like codeacademy
22:11:26 <ski> > dualize "codeacademy"
22:11:28 <lambdabot>   "deacademy"
22:11:44 <maybefbi> alec: try The Little Schemer. and solve the exercises in haskell
22:11:46 <lispy> I'd like to thank deacademy...
22:12:18 <applicative> alec do you have the ghc installed?
22:12:25 <alec> yeap
22:12:31 <alec> or i did
22:12:41 <alec> it's an apt-get away
22:13:32 <maybefbi> @undo do x <- [3..4] ; [1..2] ; return (x, 42)
22:13:32 <lambdabot> [3 .. 4] >>= \ x -> [1 .. 2] >> return (x, 42)
22:13:37 <applicative> it seems to me 'learn you a haskell" has a ton of stuff that you write in the ghci prompt, like tryhaskell
22:14:23 <applicative> you could read the text when necessary, and just noodle around typing the examples and varying them
22:14:44 <ski> .. and ask question in #haskell, of course !
22:14:51 <applicative> >  take 12 (cycle "LOL ")
22:14:53 <lambdabot>   "LOL LOL LOL "
22:15:02 <applicative> see, excellent examples
22:15:22 <alec> hmm
22:15:24 <alec> yeah
22:15:32 <applicative> > let boomBangs xs = [ if x < 10 then "BOOM!" else "BANG!" | x <- xs, odd x]   in boomBangs [7..13]
22:15:34 <lambdabot>   ["BOOM!","BOOM!","BANG!","BANG!"]
22:15:37 <alec> too bad lyah-gg isn't part of tryhaskell already!
22:15:54 <alec> i wonder if the author would give permission for someone to work it in
22:16:23 <alec> i have read lyah-gg but i just have a hard time focusing
22:16:26 <alec> it's part of my asperger's
22:16:36 <alec> i can focus on reading and i can focus on coding but doing both is hard
22:16:47 <alec> that's why i like stuff like tryhaskell and codeacademy
22:16:49 <applicative> hm.
22:16:56 <alec> it feels natural to learn
22:17:22 <maybefbi> alec: The little schemer has very little English text. just code
22:17:36 <alec> hmm, that might be good, maybefbi
22:17:58 <ski> i think there's also an "The Little MLer"
22:18:16 <maybefbi> alec: http://books.google.com.sg/books?id=xyO-KLexVnMC&printsec=frontcover#v=onepage&q&f=false
22:18:41 <maybefbi> try the The Little books. it worked well for me.. and I too hated reading English text
22:19:10 <applicative> i still think cutting and pasting the examples from lyah and fiddling with them will go a long way in these circumstances
22:20:01 <applicative> once you get the hang of the syntax the code tends to make more sense than the explanations anyway....
22:20:43 <alec> lol, yeah, that's the funny thing about haskell, applicative
22:20:52 <applicative> and things that seem like nonsense you can ask about here.
22:20:55 <alec> it seems like it takes more time to explain how it works than it does to just get on with it
22:25:43 <applicative> > findIndices (`elem` ['A'..'Z']) "Where Are The Caps?"
22:25:45 <lambdabot>   [0,6,10,14]
22:28:11 <applicative> > (++) <$> Just "johntra" <*> Just "volta"  -- ?!
22:28:14 <lambdabot>   Just "johntravolta"
22:28:37 <applicative> > (++) <$> ["ha","heh","hmm"] <*> ["?","!","."]
22:28:39 <lambdabot>   ["ha?","ha!","ha.","heh?","heh!","heh.","hmm?","hmm!","hmm."]
22:28:53 <applicative> see, BONUS is obviously a master....
22:29:09 <alec> BONUS = author of lyah-gg, no?
22:30:23 <applicative> yes
22:30:43 <Nereid> > findIndices isUpper "Where Are The Caps?"
22:30:45 <lambdabot>   [0,6,10,14]
22:32:01 <Nereid> @src findIndices
22:32:02 <lambdabot> findIndices p xs = [ i | (x,i) <- zip xs [0..], p x]
22:32:14 <Nereid> that's a good implementation.
22:32:30 <Nereid> @. pl src findIndices
22:32:30 <lambdabot> (line 1, column 1):
22:32:30 <lambdabot> unexpected end of input
22:32:30 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
22:32:33 <Nereid> oops
22:33:11 <Nereid> :t \p -> map fst . filter (p . snd) . zip [0..]
22:33:12 <lambdabot> (Enum b, Num b) => (a -> Bool) -> [a] -> [b]
22:33:33 <Nereid> :t findIndices
22:33:34 <lambdabot> (a -> Bool) -> [a] -> [Int]
22:33:45 <applicative> I don't know if its sensible, but it is a beautiful implementation,  findIndices
22:34:04 <Nereid> it's how I would have done it.
22:34:22 <Nereid> what would be more sensible?
22:35:29 <applicative> I don't know, I was just marvelling at its compactness and intelligibility.  I probably would have tried several ugly things before it dawned on me :)
22:35:39 <Nereid> heh
22:36:52 <Nereid> :t let f acc ( p [] = []; f p acc (x:xs) = (if p then (acc:) else id) (f (succ acc) p xs); g = f 0 in g
22:36:54 <lambdabot> parse error on input `='
22:37:01 <Nereid> :t let f acc p [] = []; f p acc (x:xs) = (if p then (acc:) else id) (f (succ acc) p xs); g = f 0 in g
22:37:03 <lambdabot>     No instance for (Num Bool)
22:37:03 <lambdabot>       arising from the literal `0'
22:37:03 <lambdabot>     Possible fix: add an instance declaration for (Num Bool)
22:37:07 <Nereid> hmm.
22:37:37 <Nereid> oh I'm an idiot
22:37:38 <Nereid> :t let f acc p [] = []; f acc p (x:xs) = (if p x then (acc:) else id) (f (succ acc) p xs); g = f 0 in g
22:37:40 <lambdabot> (Enum a, Num a) => (t -> Bool) -> [t] -> [a]
22:37:53 <Nereid> let f acc p [] = []; f acc p (x:xs) = (if p x then (acc:) else id) (f (succ acc) p xs); g = f 0 in g isUpper "Where Are The Caps?"
22:37:59 <Nereid> > let f acc p [] = []; f acc p (x:xs) = (if p x then (acc:) else id) (f (succ acc) p xs); g = f 0 in g isUpper "Where Are The Caps?"
22:38:01 <lambdabot>   [0,6,10,14]
22:38:08 <lispy> some variant of zip xs [0..] or zipWith f xs [0..] are among my favorite uses of laziness
22:38:09 <Nereid> ugly.
22:38:15 <lispy> (at least, uses in real programs)
22:38:21 <Nereid> heh
22:38:26 <shachaf> @@ @pl @undo findIndices
22:38:26 <lambdabot>  findIndices
22:38:30 <shachaf> @@ @pl @undo @src findIndices
22:38:31 <lambdabot>  ()
22:38:37 <shachaf> good @pl
22:38:41 <shachaf> @src findIndices
22:38:42 <lambdabot> findIndices p xs = [ i | (x,i) <- zip xs [0..], p x]
22:38:46 <shachaf> @@ @undo @src findIndices
22:38:46 <lambdabot>  ()
22:38:50 <lispy> can you create a loop with @@?
22:38:53 <Nereid> @undo findIndices p xs = [ i | (x,i) <- zip xs [0..], p x]
22:38:53 <lambdabot> findIndices p xs = concatMap (\ (x, i) -> if p x then [i] else []) zip xs [0 ..]
22:39:06 <shachaf> Oh, right.
22:39:08 <shachaf>  @src is weird.
22:39:12 <shachaf> A loop?
22:39:37 <Nereid> @pl findIndices p xs = concatMap (\ (x, i) -> if p x then [i] else []) zip xs [0 ..]
22:39:38 <lambdabot> findIndices = flip flip [0..] . (zip >>=) . (`ap` snd) . (. fst) . flip flip [] . (flip .) . flip flip return . (((.) . if') .)
22:39:42 <Nereid> nice.
22:39:53 <lispy> shachaf: I don't think you can, but I was imagining two commands that just keep feeding into each other
22:40:09 <lispy> @@ @more @eval [1..]
22:40:19 <shachaf> You can also make something that times out lots of other ways.
22:40:31 <lispy> @eval [1..]
22:40:35 <lispy> @eval 1
22:40:38 <lispy> does that do anything?
22:40:40 <Nereid> @run 1
22:40:42 <lambdabot>   1
22:40:43 <Nereid> what exactly does @@ do?
22:40:49 <lispy> @@ @more @run [1..]
22:40:52 <glguy__> it's command composition
22:40:59 <Nereid> how's it different from @. ?
22:41:23 <glguy__> Maybe I'm confusing it then
22:41:26 <shachaf> Hmm, @undo is broken.
22:41:32 <shachaf> Nereid: @@ lets you have multiple chains, nested commands, etc.
22:42:08 <glguy__> @@ @djinn @type id
22:42:10 <lambdabot>  f a = a
22:42:34 <lispy> @@ @djinn @type @hoogle fromJust
22:42:35 <lambdabot>  Error: Undefined type Couldn't
22:42:47 <lispy> I hate it when the undefined type couldn't
22:43:00 <glguy__> djinn can't write fromJust
22:43:14 <glguy__> but I'm not sure that that's the reason you got that error
22:43:30 <lispy> @djinn a -> Maybe a
22:43:30 <lambdabot> f = Just
22:43:43 <lispy> it does know maybe...
22:43:46 <shachaf> You can do things like @@ @cmd ... (@cmd ...) ...
22:43:48 <lispy> @hoogle fromJust
22:43:49 <lambdabot> Data.Maybe fromJust :: Maybe a -> a
22:43:53 <elliott> @djinn-env
22:43:53 <lambdabot> data () = ()
22:43:54 <lambdabot> data Either a b = Left a | Right b
22:43:54 <lambdabot> data Maybe a = Nothing | Just a
22:43:54 <lambdabot> data Bool = False | True
22:43:54 <lambdabot> data Void
22:43:56 <lambdabot> type Not x = x -> Void
22:43:57 <lambdabot> class Monad m where return :: a -> m a; (>>=) :: m a -> (a -> m b) -> m b
22:43:58 <lispy> glguy__: I bet it was confused about Data.Maybe
22:44:00 <lambdabot> class Eq a where (==) :: a -> a -> Bool
22:44:05 <mzero> let findIndicies p = map fst . filter (p . snd) . zip [0..]  in findIndicies (`elem` "yowza") ['a'..'z']
22:44:13 <mzero> > let findIndicies p = map fst . filter (p . snd) . zip [0..]  in findIndicies (`elem` "yowza") ['a'..'z']
22:44:15 <lambdabot>   [0,14,22,24,25]
22:44:19 <glguy__> lispy: fromJust has a type that djinn can't implement
22:44:24 <mzero> the other defintion seems, awkward
22:44:56 <lispy> glguy__: sure, it's partial, but I bet the error was because hoogle returned that Data.Maybe that confused the rest of the chain
22:45:10 <lispy> @type Data.Maybe
22:45:12 <lambdabot> Couldn't find qualified module.
22:45:25 <lispy> @djinn Couldn't find qualified module.
22:45:25 <lambdabot> Error: Undefined type Couldn't
22:46:14 <glguy__> Data.Maybe is a module
22:46:25 <glguy__> doesn't have a type :-p
22:48:29 <neutrino> hi glguy
22:51:01 <mysticc> How do you get list in reverse. Like [100 .. 1] ?
22:51:08 <mysticc> > [1..10]
22:51:10 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
22:51:16 <mysticc> > [10..1]
22:51:18 <lambdabot>   []
22:51:27 <mysticc> > [10,9..1]
22:51:29 <lambdabot>   [10,9,8,7,6,5,4,3,2,1]
22:51:38 <neutrino> > reverse [1..100]
22:51:39 <lambdabot>   [100,99,98,97,96,95,94,93,92,91,90,89,88,87,86,85,84,83,82,81,80,79,78,77,7...
22:53:23 * hackagebot iproute 1.2.10 - IP Routing Table  http://hackage.haskell.org/package/iproute-1.2.10 (KazuYamamoto)
23:08:23 * hackagebot case-insensitive 0.4.0.4 - Case insensitive string comparison  http://hackage.haskell.org/package/case-insensitive-0.4.0.4 (BasVanDijk)
23:09:06 <hpaste> “Travis Athougies” pasted “Type instances” at http://hpaste.org/79180
23:09:13 <iammisc> I'm trying to use type families for a project, and I think I might be going about it incorreclty
23:09:40 <iammisc> specifically, I would like to be able to define show on all instances whose embedded type synonym instance is a member of class show
23:15:57 <johnw> maybe you want generics?  just guessing
23:18:55 <johnw> has anyone here used #callback with Bindings-DSL?
23:23:01 <maybefbi> @undo do { put 5; return 'X' }
23:23:02 <lambdabot> put 5 >> return 'X'
23:25:16 <maybefbi> Just $ figured out you can private message lambdabot
23:25:23 <ion> johnw: Nope, but ask anyway.
23:26:06 <johnw> ion: thanks, I did find what I needed
23:27:28 <johnw> Bindings-DSL really does work quite nicely
23:33:24 * hackagebot concurrent-supply 0.1.4.1 - A fast concurrent unique identifier supply with a pure API  http://hackage.haskell.org/package/concurrent-supply-0.1.4.1 (EdwardKmett)
23:34:04 <ion> Yeah, it is very nice.
23:36:41 <johnw> edwardk: Haddock docs aren't being generated for that package...
23:36:47 <edwardk> which one?
23:36:54 <johnw> http://hackage.haskell.org/package/concurrent-supply-0.1.4.1
23:37:01 <edwardk> haddock docs get generated up to 12 hours after something gets posted
23:37:06 <johnw> ah
23:38:25 * hackagebot multipass 0.1.0.1 - Folding data with multiple named passes  http://hackage.haskell.org/package/multipass-0.1.0.1 (EdwardKmett)
23:39:23 <AfC> edwardk: that's pretty slow. I know I'd prefer not to see a package announcement until the documentation is ready.
23:39:27 <ion> -- Portability :  portable
23:39:29 <ion> import GHC.IO (unsafeDupablePerformIO)
23:39:35 <edwardk> AfC: talk to the cabal guys
23:39:46 <AfC> well, it's more about hackagebot, no?
23:40:00 <ion> {-# LANGUAGE MagicHash, UnboxedTuples #-}
23:40:09 <simpson> ek dallas multipass?
23:40:12 <edwardk> hackagebot announces the moment something pushed to hackage. as a package maintainer i kind of want to know immediately about new dependencies
23:40:16 <edwardk> simpson: yes =)
23:40:35 <simpson> edwardk: Moulteepaas. What's it do? It looks like it's something for numerical analysis?
23:40:51 <edwardk> AfC: when the update happens you can cabal update, cabal install, and get the haddocks right away
23:42:02 <AfC> edwardk: I suppose. Mostly I see packages I don't know a thing about, so go to click on the link out of interest and to learn something new, only to ... not learn anything.
23:42:16 <AfC> Bad juju
23:42:22 <edwardk> *nods*. my recommendation is to click on the previous version
23:42:26 <AfC> I do
23:42:28 <edwardk> then browse the docs there ;)
23:42:50 <AfC> Of course, then I'm left wondering if the new release of concurent-supply was to fix the documentation such that it would be more understandable.
23:43:20 <edwardk> this new hashable stuff is proving fairly tedious to update for, but i suppose its better to get it out of the way
23:43:27 * hackagebot reducers 3.0.0.2 - Semigroups, specialized containers and a general map/reduce framework  http://hackage.haskell.org/package/reducers-3.0.0.2 (EdwardKmett)
23:43:29 * hackagebot compressed 3.0.0.1 - Compressed containers and reducers  http://hackage.haskell.org/package/compressed-3.0.0.1 (EdwardKmett)
23:43:42 <AfC> I was a bit surprised that they didn't choose a 2.0 version number for that.
23:45:46 <AfC> edwardk: anyway, the question I have about concurent-supply (that I'd never heard of before, sorry) is how it relates to UUIDs (which are well specified and usually sourced from a libuuid for what I was under the impression were fairly good reasons.
23:46:07 <AfC> edwardk: might be nice to address that in the documentation there {shrug}.
23:46:11 <edwardk> UUIDs are designed so they come out globally unique across computers, but are expensive to generate
23:46:35 <edwardk> the idea with a concurrent supply is that i often have a desire to generate a bunch of integer ids within a single process that are unique within the process
23:47:04 <edwardk> but i don't want to have a single counter that i have to contend for to tick upwards with every thread vying for that same counter
23:47:06 <AfC> edwardk: fair enough. That's not really how I would have interpreted "globally" in "A globally unique fresh identifier supply", then
23:47:31 <edwardk> i accept patches ;)
23:47:45 <AfC> edwardk: ok
23:48:23 <edwardk> anyways the idea of concurrent-supply is i build a tree-like structure you can split so you can make smaller unique supplies and then you allocate from your supplies locally.
23:48:47 <edwardk> behind your back it'll pull from a unique supply a block at a time as they are needed as you walk into parts of the tree that haven't been explored
23:49:20 <edwardk> this is structured in such a way that the values themselves are pure once they 'fossilize' in this fashion and the computation is replayable within a session
23:49:33 <edwardk> this is important when you use them for certain roles in compilers
23:53:25 * hackagebot intern 0.9.1.1 - Efficient hash-consing for arbitrary data types  http://hackage.haskell.org/package/intern-0.9.1.1 (EdwardKmett)
23:53:34 <johnw> haha
23:53:40 <1JTAAT864> are there any good tutorials on what functional reactive programming *is*?
23:53:46 <1JTAAT864> wow how did my name get changed
23:53:53 <johnw> i read that as "intern", as in somebody who does something for little reward :)
23:54:35 <edwardk> johnw: its a bit of both =)
23:55:42 <lightquake> also, more packages should have a .Tutorial module
23:56:35 <edwardk> johnw: that should be everything i need to do to fix my parts of stackage except for lens.
23:56:51 <johnw> nice, thanks for all that work
23:56:54 <edwardk> like neil i'm 'technically' blocked on vault getting updated
23:57:04 <johnw> if I can help with anything, let me know
23:57:08 <edwardk> i'll push lens shortly. I want to make sure we have 3.7.1 in a good state first
23:57:22 <johnw> lens =~ Good
23:57:31 <snoyberg> wow, that's a funny conversation to see first thing i join the channel
23:57:49 <edwardk> snoyberg: =)
23:58:09 <snoyberg> i included heinrich in the stackage issue btw
23:58:36 <johnw> snoyberg: did you get my latest set of test failures on "virgin" Mac?
23:59:05 <snoyberg> yes, i was surprised by two things: the fact that simple-sendfile passed, and the fact that unix-time didn't
23:59:15 <johnw> I'm focused on the Git stuff now, but I'll try to make time to track those down and get them resolved
23:59:48 <snoyberg> don't put too high a priority on tracking it down yet
