00:10:44 <beaky> ello
00:10:51 <beaky> is recursion more natural than iteration
00:11:44 <c_wraith> I don't bother thinking of them as something different
00:11:52 <c_wraith> it helps with ignoring questions like that
00:12:51 * glguy feels like c_wraith immediately contradicted himself :-)
00:12:57 <beaky> lol
00:13:46 <c_wraith> but seriously, just notice they're the same thing.
00:13:57 <beaky> they are?
00:14:29 <c_wraith> different syntactic expressions of the same thing
00:14:45 <elliott> Well, tail recursion is iteration.
00:14:50 <beaky> ah
00:14:52 <elliott> General recursion is much more powerful.
00:15:20 <beaky> yes recursion is the most powerful force in the universe
00:15:33 <c_wraith> eh.  general recursion is iteration + stack.
00:16:01 <glguy> captain recursion is?
00:16:04 <elliott> Stacks are pretty powerful :)
00:17:40 <beaky> if stacks are recursion
00:17:44 <beaky> what are queues?
00:18:54 <Hafydd> Procrastination.
00:18:59 * hackagebot forml 0.1.2 - A statically typed, functional programming language  http://hackage.haskell.org/package/forml-0.1.2 (AndrewStein)
00:21:45 <wuttf> I think the Haskell creators took the pill named "Generics on Steroids" on a daily basis
00:22:00 <wuttf> I am amazed
00:24:21 <Jafet> @remember Hafydd <beaky> if stacks are recursion, what are queues?  <Hafydd> Procrastination.
00:24:21 <lambdabot> I will never forget.
00:26:44 <mapf> hi guys. when I reify some function I constantly get Info which not contain clauses. So I have Nothing in VarI from here: http://hackage.haskell.org/packages/archive/template-haskell/2.7.0.0/doc/html/Language-Haskell-TH.html#t:Info
00:27:00 <mapf> can someone idea how to get clauses?
00:31:31 <hpaste> mapf pasted “how to get clauses in TH” at http://hpaste.org/79217
00:32:05 <shachaf> I have foo :: IO () which might throw an IOException which I want to ignore. Do I have a shorter way of saying that than (_::Either IOException ()) <- try foo?
00:33:01 <c_wraith> shachaf: Not without using something like the errors package
00:33:28 <c_wraith> Is adding an import shorter?
00:33:56 <shachaf> That package looks ugly.
00:33:59 <shachaf> Maybe I'm wrong.
00:34:02 <shachaf> How would I do it with errors?
00:36:03 <mapf> splicing in top level doesn't helps. I have no idea.
00:36:34 <c_wraith> shachaf: it'd be something like runEitherT . tryIO
00:36:51 <c_wraith> Which isn't really short, but at least it's simpler to read
00:37:05 <shachaf> Ugh, EitherT.
00:37:56 <sw2wolf> :t runEitherT
00:37:58 <lambdabot>     Not in scope: `runEitherT'
00:37:58 <lambdabot>     Perhaps you meant `runWriterT' (imported from Control.Monad.Writer)
00:38:23 <c_wraith> EitherT m e a -> m (Either e a)
00:38:33 <c_wraith> It's not very interesting.
00:38:36 <elliott> Nothing wrong with EitherT.
00:38:39 <c_wraith> It's just the destructor for EitherT
00:38:54 <elliott> But you should use "either" instead because edwardk wrote it
00:38:59 <shachaf> «catch (\(_::IOException) -> return ()) $ do» is even longer.
00:39:27 <shachaf> elliott: I heard it was getting into base.
00:39:37 <elliott> by base do you mean transformers
00:39:45 <edwardk> and the author of the EitherT deprecated his in favor of the one in 'either' which is being ported into transformers now.
00:40:01 <elliott> Oh, "errors" depends on "either"
00:40:01 <shachaf> elliott: I mean whatever.
00:40:05 <c_wraith> isn't errors implemented in terms of your package too?
00:40:11 <c_wraith> oh, I asked too slowly
00:40:22 <edwardk> that too
00:40:25 <c_wraith> Darn you for answering before I could ask!
00:40:59 <nus> mapf, http://www.haskell.org/haskellwiki/Template_Haskell#What_can_reify_see.3F
00:41:30 <shachaf> c_wraith: We'll let it slide today. Next time be more prompt with your questions.
00:41:44 <c_wraith> I'll try harder
00:43:12 <mapf> nus: thanks. but i need function definition!
00:44:20 <mapf> btw, ghc 7.6 does the same
00:45:25 <mapf> i'm frustrated. Are there no way really?
00:47:57 <mapf> ok, then I put this all in quote
00:58:37 <wuttf> How can I define < and <= operators on types?
00:59:13 <c_wraith> make the type an instance of Ord and Eq
00:59:26 <wuttf> c_wraith: Ty
00:59:39 <`nand`> Is it bad if I thought that was question about type families and Nat?
00:59:54 <c_wraith> yes
01:00:06 <wuttf> `nand`: Hold on dude, I am programming in Haskell for 1 day :D
01:01:43 <wuttf> Maybe it is too soon to form an opinion, but a lot of people said that "in Haskell you have to keep on hammering the code until all types agree" ... now, I think the type system (the subset of it I know)
01:01:51 <wuttf> is perfectly reasonable and I have no problem with it
01:02:05 <`nand`> hammering the code until the types agree is something you have to do if you don't know what you're doing
01:02:18 <wuttf> But I was always a static guy
01:02:26 <`nand`> maybe that's a common newcomer's opinion of haskell for that reason, or an opinion of those who started using haskell then stopped before they really understood it
01:03:10 <wuttf> `nand`: thats good to hear, I feared that the hardest parts are ahead me and thats why I find it understandable
01:04:40 <wuttf> The type system alone and the ubergenericness of Haskell makes me learn this language
01:05:23 <wuttf> type inference in Haskell is like having sex on ecstasy
01:05:41 <wuttf> legen - wait for it - dary
01:15:39 <wuttf> Hey guys I have defined < operator for my type, it works, I did not define > but when I issue > GHCi goes into an infinite loop
01:15:41 <wuttf> wtf?
01:15:52 <shachaf> wuttf: Did you read the documentation for Ord?
01:16:06 <shachaf> It tells you what the minimal complete definition of an Ord instance is.
01:16:42 <wuttf> shachaf: I feel you question strongly implies that I should...
01:17:05 <wuttf> I am more interested in why doesnt it throw a type error?
01:17:10 <wuttf> It just hangs up (I mean GHCi)
01:17:14 <shachaf> Because it's not a type error.
01:17:37 <shachaf> (It would be great if it gave a warning. Currently GHC doesn't do that.)
01:18:01 <wuttf> Dohh. I feel so stupid. Okay, back to implementing the rest of the stuff, thank you
01:34:45 <Ralith> wuttf: of course you should read the documentation. Reading the documentation is nearly always the first thing you should do.
01:39:45 <johnny934759> how can i make function return different type values depending on the context it was used in?
01:40:12 <shachaf> You can do it with type classes, sort of, but you probably don't want to.
01:40:28 <statusfailed> johnny934759: what problem are you trying to solve?
01:41:17 <johnny934759> statusfailed: writing a sparse vector/matrix library i want vector/matrix mul to return specific type depending on the context
01:41:45 <johnny934759> sort of the regexpression library...
01:42:14 <wuttf> Ralith: got it, RTFM ;)
01:42:32 <statusfailed> johnny934759: Are you looking just for polymorphic return types? e.g. 'fromIntegral'?
01:43:02 <johnny934759> statusfailed: yeah something like that
01:44:09 <statusfailed> johnny934759: Perhaps just make your Vector/Matrix types instances of Num?
01:44:20 <shachaf> You should give more context.
01:44:35 <shachaf> It sounds to me like a bad idea as you put it, though -- see Text.Regex for an example of how bad it can get. :-)
01:45:21 <statusfailed> shachaf: isn't it just making Vector/Matrix instances of Num?
01:45:23 <shachaf> You can just use two functions, one for dot product and one for cross product or whatever it is you want.
01:45:43 <shachaf> They're different things so there's no real reason they should have the same name.
01:45:48 <Nereid> statusfailed: that won't do it, because you want to be able to multiply a matrix with a vector.
01:46:09 <Nereid> or well, things of different types together.
01:46:25 <johnny934759> making these instance of Num causes type problems
01:46:28 <Ralith> Num multiply and linear algebra multiply are really different operations
01:46:37 <shachaf> Yep.
01:46:42 <shachaf> So is Monoid multiply.
01:46:43 <Ralith> linear algebra multiply on its own is a few different operations, even.
02:06:18 <mikeplus64> johnny934759: make a typeclass for it, like others have said, and you may be able to use fundeps to say one type "depends on" another so you don't need to give a type signature
02:07:06 <mikeplus64> e.g. class VectorMatrixThing in out | in -> out where vectormatrixthingfunction :: in -> out
02:07:28 <mikeplus64> (but you probably want more specific types than that, e.g. Vector in -> Vector out or something)
02:07:37 <shachaf> Better yet, you probably don't want a type class at all.
02:08:19 <johnny934759> sure so futional depency is the normal route for this effect with the type system?
02:09:04 <mikeplus64> if your function does fundamentally different things depending on the type, then you probably don't want a typeclass like shachaf says, but otherwise typeclass away
02:11:03 <mikeplus64> johnny934759: i think fundeps have fallen out of favour due to type families, but they're still there, but the most "normal" route is to just not use fundeps at all, and annotate the type
02:11:30 <shachaf> The most "normal" route depends on what you're doing.
02:11:31 <b_jonas> I don't think they have fallen out of favour.
02:11:42 <b_jonas> But I don't really understand type families.
02:15:16 <mikeplus64> b_jonas: http://www.haskell.org/haskellwiki/Functional_dependencies_vs._type_families gives me that impression
02:15:30 <mikeplus64> and some ghc manual page that i can't find right now...
02:15:56 <shachaf> mikeplus64: mtl still uses fundeps, for example.
02:16:35 <b_jonas> I know they say type families can substitute for fundeps, and I know they can in simple cases,
02:17:02 <b_jonas> but I never understood either how you can rewrite fundeps to type families in general, nor how you could rewrite type families to fundeps in general.
02:17:05 <mikeplus64> shachaf: i still use fundeps, for example :), but prefer type families solely because they are nicer to use
02:17:30 <shachaf> mikeplus64: In the case of mtl the argument is good that fundeps are nicer to use.
02:18:55 <mikeplus64> i find in my code in https://github.com/mikeplus64/record using fundeps the instance contexts got very hairy, but i'm abusing a lot of features that generally contribute to a codebase's hairiness
02:19:54 <mikeplus64> (so much so that haddock crashes trying to generate docs for it, haha)
02:25:02 <neutrino_> hi
02:25:58 <neutrino_> is it ok to use the async module's withAsync to just spin up a background thread, which should be deleted if withAsync gets an exception or exits?
02:26:01 <johnny934759> found a tutorial that solved my exact problem using fundeps: http://www.haskell.org/haskellwiki/Functional_dependencies
02:33:50 <hpaste> elm pasted “pong” at http://hpaste.org/79220
02:37:28 <EarlGray> hello
02:37:55 <EarlGray> is there a natural way to emulate int8_t overflow in Haskell?
02:38:18 <EarlGray> I can do this manually, but maybe some GHC types fit this better
02:38:56 <bitonic> EarlGray: use Int8?
02:39:05 <bitonic> that will overflow nicely.
02:39:17 <bitonic> > (maxBound :: Int8) + 1
02:39:19 <lambdabot>   -128
02:39:20 <shachaf> EarlGray: int8_t overflow is undefined behavior in C.
02:39:32 <bitonic> or in Haskell for that matter, iirc
02:39:40 <shachaf> I don't think Int8 overflow is undefined in Haskell, mostly because Int8 isn't part of Haskell.
02:39:48 <shachaf> Int overflow is undefined in Haskell, though.
02:40:04 <bitonic> shachaf: I was assuming that considerations about Int carried over.  and I was wrong about Int, so meh
02:40:19 <bitonic> so wait is there some standard exception to be thrown?
02:40:23 * bitonic goes toward the report
02:40:32 <shachaf> bitonic: ?
02:41:28 <bitonic> shachaf: “The results of exceptional conditions (such as overflow or underflow) on the fixed-precision numeric types are undefined”, so I was right
02:41:47 <shachaf> bitonic: That doesn't contradict what I said.
02:41:55 <shachaf> (In fact it agrees with what I said.)
02:42:24 <bitonic> then I misunderstood what you said.  I thought you meant “it mandates against undefined behaviour”, but now I understand it’s “it does talk about overflow” :P
02:42:40 <shachaf> I'm not sure which thing I said you mean.
02:42:43 <shachaf> 02:39 <shachaf> I don't think Int8 overflow is undefined in Haskell, mostly because Int8 isn't part of Haskell.
02:42:46 <shachaf> 02:39 <shachaf> Int overflow is undefined in Haskell, though.
02:43:02 <shachaf> Ah, by "undefined" I ment "is specified as undefined behavior".
02:43:07 <bitonic> shachaf: oh, sorry, I read “Int overflow is *defined* in Haskell”
02:43:08 <shachaf> By "though" I meant "in contrast"
02:43:21 <bitonic> no I just misread.
02:43:46 <bitonic> EarlGray: moral of the story, the short answer is “no”, but GHC Int8 will probably do what you want
02:44:15 <EarlGray> bitonic:  thanks, that's what I was looking for
02:50:43 <EarlGray> Another question: how to unpack ByteString.Char8 to sequence of Int8 ?
02:51:07 <shachaf> EarlGray: ByteString.Char8 isn't a type.
02:51:11 <shachaf> It's just a ByteString.
02:51:22 <shachaf> You can unpack it to [Word8] using ByteString.unpack
02:51:29 <EarlGray> as I see, even for Data.ByteString.Char8 ByteString type is data {# UNPACK #} !Int
02:52:07 <shachaf> EarlGray: That Int is a length or offset or something.
02:52:13 <shachaf> You shouldn't use Data.ByteString.Char8
02:52:15 <ypo> Hello. Is there anyone that could tell me the email-adress of this nominolo guy for registring to the wiki -- or do i have to crawl through the mailinglist till i find his/her?
02:52:17 <shachaf> It's a bad module.
02:52:35 <shachaf> nominolo is in here -- maybe they'll be able to tell you themselves. :-)
02:52:36 <EarlGray> Ah, the first field is of type Word8, maybe that's what I need
02:52:54 <ypo> nominolo: are you there?
02:52:57 <EarlGray> shachaf : I am not using it for any text data
02:53:06 <shachaf> ypo: You can look up the name "Thomas Schilling", maybe.
02:53:06 <ypo> shachaf: thanks
02:53:07 <EarlGray> it's graphics processing
02:53:13 <shachaf> EarlGray: OK, so don't use Data.ByteString.Char8
02:53:16 <shachaf> Use Data.ByteString
02:53:21 <shachaf> It's exactly the same type.
02:53:52 <EarlGray> just a note: I feel like it's time to standardize capability to mark some modules as `bad` :)
02:54:02 <EarlGray> ok
02:54:28 <EarlGray> Cause there's no way to know about bad modules except IRC :)
02:55:18 <shachaf> EarlGray: I think the documentation might mention it.
02:55:28 <shachaf> Anyway, Data.ByteString.Internal defines a type
02:55:46 <shachaf> This same type is exported from both Data.ByteString and Data.ByteString.Char8
02:55:53 <shachaf> But different operations are exported.
02:56:06 <shachaf> (The latter exports more culturally insensitive operations.)
02:57:01 <fmap> EarlGray: it's bad as in "probably not what you want", not if it does not work or something
02:59:18 <ypo> shachaf: Ok, I found his adress through google. Lets see if it was the right one :D
03:05:03 <EarlGray> another not-so-smart question: how to convert Word8 to Int8? I don't see conversion/truncation functions in Data.Int
03:05:13 <shachaf> @hoogle Word8 -> Int8
03:05:13 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
03:05:14 <lambdabot> Control.OldException throwDyn :: Typeable exception => exception -> b
03:05:14 <lambdabot> Network.BufferType buf_snoc :: BufferOp a -> a -> Word8 -> a
03:05:16 <shachaf> Hmm.
03:05:18 <shachaf> Don't do that.
03:05:21 <shachaf> @ty fromIntegral
03:05:23 <lambdabot> (Integral a, Num b) => a -> b
03:05:25 <shachaf> That.
03:22:00 <donri> hoogle should filter out unsafe functions :p
03:24:28 <c_wraith> or at least filter out unsafeCoerce
03:24:37 <c_wraith> since it matches every function type
03:25:19 <shachaf> @hoogle Int -> (Double,Double,Bool,Char)
03:25:21 <lambdabot> No results found
03:25:24 <shachaf> Where's my unsafeCoerce?!
03:25:58 <Hafydd> > unsafeCoerce 1 :: (Double,Double,Bool,Char)
03:26:00 <lambdabot>   Not in scope: `unsafeCoerce'
03:26:07 <Hafydd> > Unsafe.Coerce.unsafeCoerce 1 :: (Double,Double,Bool,Char)
03:26:08 <lambdabot>   Not in scope: `Unsafe.Coerce.unsafeCoerce'
03:26:57 <Hafydd> unsafeCoerce has disappeared!
03:28:54 <c_wraith> well, lambdabot doesn't have it because it can be used to execute IO
03:30:44 <Hafydd> Prelude Unsafe.Coerce> unsafeCoerce (1 :: Int) :: (Double, Double, Bool, Char)
03:30:44 <Hafydd> (Segmentation fault (core dumped)
03:30:52 <Hafydd> I see why they call it unsafe.
03:31:39 <c_wraith> Remember, haskell uses the type system to shape the way it executes code.  If you lie about the type of something...  it can execute very wrong.
03:32:23 <c_wraith> In that particular case, it evaluated a boxed value, and assumed the result was 4 pointers.
03:32:39 <c_wraith> Except it was only actually one pointer.  It just read the next four words anyway
03:32:54 <c_wraith> Which was arbitrary memory
03:33:02 <c_wraith> and it tried to dereference all of those pointers
03:33:08 <Rogach> btw, how can one make something to dump core when segfault happens? It only displays "Segmentation fault" for me.
03:33:12 <Hafydd> Prelude Unsafe.Coerce> (unsafeCoerce (1 :: Int) :: Int -> Int) 1
03:33:13 <Hafydd> -8502796096475496448
03:33:15 <Hafydd> Woah.
03:33:41 <Hafydd> A new way to generate random integers?
03:33:46 <c_wraith> Rogach: that's a user-level setting in linux. I think it's part of ulimit? Most systems default your max core file size to 0
03:34:31 <Rogach> c_wraith: Ok, thanks, I'll look into that. I had a lot of trouble debugging one segfault some time ago, core could have helped with that.
03:34:49 <c_wraith> Rogach: you can also just run your compiled program inside gdb.  that's sometimes easier.
03:35:03 <Jafet> @quote head.\[\]
03:35:03 <lambdabot> <kmc> says: head [] = peek . intPtrToPtr . fromIntegral . unsafePerformIO . randomRIO $ (0, 2^32)
03:35:14 <Hafydd> I didn't set it intentionally, anyway.
03:36:03 <Hafydd> Heh.
03:36:41 <c_wraith> well, that'd make it non-partial!
03:36:46 <c_wraith> (for some definition of non-partial)
03:36:55 <c_wraith> (that is, a wrong definition)
03:40:03 <Hafydd> Prelude System.IO.Unsafe Unsafe.Coerce> unsafePerformIO $ unsafeCoerce (1 :: Int) :: IO ()
03:40:07 <Hafydd> <interactive>: internal error: stg_ap_v_ret (GHC version 7.6.1 for x86_64_unknown_linux) Please report this as a GHC bug:  http://www.haskell.org/ghc/reportabug
03:40:10 <Hafydd> Aborted (core dumped)
03:40:31 <Hafydd> I presume that isn't actually a bug?
03:40:35 <c_wraith> no
04:36:23 <EarlGray> Is there a simple way to mirror a picture in Gloss?
04:41:21 <geckr> in  (\l -> l !! 4) . map (*2) $ [1..5], is *2 applied to the numbers 1 to 4 too, isn't it?
04:42:05 <fmap> > (\l -> l !! 4) . map (*2) $ [undefined, undefined, undefined, undefined, 5]
04:42:07 <lambdabot>   10
04:42:17 <fmap> so no
04:42:22 <geckr> oh cool
04:45:21 <`nand`> EarlGray: scale -1?
04:47:01 <EarlGray> tricky, but simple, thank you :)
04:49:28 <geckr> fmap: but if I have "(\l -> l !! 4) $ Data.List.permutations [1,2,3]" permutations has to calculate the permutations 0 to 3 of [1,2,3] and cannot "jump" directoly to the 4th calculation, right?
04:51:55 <shachaf> That depends on what you mean by "calculate".
05:02:17 <tdammers> is hackage down by any chance?
05:03:30 <McManiaC> how can I explicitely export the associated type of a type family class declaration?
05:04:02 <McManiaC> i.e. "class Foo where data Bar" then "module (Foo (Bar)) where... "
05:04:29 <McManiaC> this gives me the error/warning "The export item attempts to export constructors or clas methods that are not visible here"
05:05:09 <McManiaC> it's actually an error ^^
05:09:05 * hackagebot hpaco-lib 0.16.2.0 - Modular template compiler library  http://hackage.haskell.org/package/hpaco-lib-0.16.2.0 (TobiasDammers)
05:09:07 * hackagebot hpaco 0.16.2.0 - Modular template compiler  http://hackage.haskell.org/package/hpaco-0.16.2.0 (TobiasDammers)
05:09:09 * hackagebot elerea-sdl 0.1.1 - Elerea FRP wrapper for SDL  http://hackage.haskell.org/package/elerea-sdl-0.1.1 (StephenWeber)
05:09:14 <tdammers> oh hey
05:09:18 <tdammers> there's my upload
05:09:19 <tdammers> \o/
05:09:45 <tdammers> odd
05:10:00 <tdammers> hackagebot sees it before my locally-running cabal upload job returns
05:11:54 <tdammers> I aborted the upload jobs
05:11:57 <tdammers> wonder what happens now
05:12:06 <fmap> geckr: I'm not sure what does `permutations' do, but given its type it cannot evaluate list elements themselves, only rearrange them
05:13:15 <fmap> (I don't know what do you mean by "calculate" though)
05:13:59 <tdammers> fmap: `permutations` spits out a list of all the possible reorderings (permutations) of the given list
05:14:06 <tdammers> > permutations [1,2,3]
05:14:07 <lambdabot>   [[1,2,3],[2,1,3],[3,2,1],[2,3,1],[3,1,2],[1,3,2]]
05:14:38 <fmap> tdammers: yes, but its source code is unreadable :[
05:15:09 <hpc> > permutations [undefined, 2, 3] !! 4
05:15:11 <lambdabot>   [3,*Exception: Prelude.undefined
05:15:36 <tdammers> > permutations [undefined, 2, 3] !! 1 !! 0
05:15:37 <lambdabot>   2
05:15:47 <mvj4> @pl \x y -> y x
05:15:48 <lambdabot> flip id
05:15:49 <tdammers> completely lazy
05:15:57 <hpc> doesn't seem to inspect any elements for permutations other than the one you want
05:16:05 <tdammers> why would it?
05:16:12 <hpc> no idea
05:16:16 <tdammers> this is one of the situations where laziness shines
05:16:17 <Taneb> If I'm using Text.Printf, how do I get a '%' literal?
05:16:22 <hpc> %%
05:16:27 <tdammers> > permutations [1..100] !! 0
05:16:29 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
05:16:34 <hpc> > printf "%%" :: String
05:16:36 <lambdabot>   "%"
05:16:42 <Taneb> Thanks, hpc
05:18:39 <tdammers> try that with a non-lazy implementation...
05:18:58 <tdammers> > permutations [1..100] !! 1000000
05:19:00 <lambdabot>   [6,10,3,7,5,8,2,4,1,9,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
05:19:07 <tdammers> huh.
05:19:23 <tdammers> > last $ permutations [1..100]
05:19:27 <lambdabot>   mueval-core: Time limit exceeded
05:19:30 <tdammers> ah.
05:20:03 <merijn> Doesn't that have like 100! permutations? not very odd that lambdabot gives up reaching the last one :p
05:20:09 <nicoo> tdammers: Not very surprising ;)
05:20:23 <tdammers> nicoo: of course not
05:20:31 <nicoo> > last $ permutations [1..5]
05:20:32 <lambdabot>   [2,4,1,5,3]
05:20:35 <tdammers> that's pretty much what I expecteed
05:20:45 <nicoo> tdammers: 'kay
05:20:56 <tdammers> my point is that this would happen for *every* similar call to permutations if it were eager
05:21:26 <tdammers> if you do the same in python, getting the first permutation takes just as long as getting the last one
05:21:51 <tdammers> unless permutations in python is implemented as a generator of course
05:22:04 <nicoo> Oh, yeah; but I don't expect people to generate the whole permutation list at once in Python :$
05:22:43 <geckr> last $ permutations [1..100] exceeds the time limit not because all permutations till the last one, because it takes to long to go through the whole list?
05:22:56 <geckr> "till the last one are calcualted"
05:23:40 <tdammers> not really calculated
05:23:48 <tdammers> it doesn't fully evaluate all the elements still
05:23:55 <tdammers> just the spines of the individual lists
05:24:08 <tdammers> the elements are still thunks until you request one of them
05:24:22 <tdammers> e.g. if you'd do length $ last $ permutations [1.100]
05:24:26 <nicoo> @src permutations
05:24:26 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
05:24:37 <nicoo> lambdabot: So cruel :(
05:24:39 <tdammers> it would not evaluate the list elements
05:24:43 <tdammers> or even
05:24:52 <tdammers> > length $ last $ permutations [undefined, undefined]
05:24:53 <lambdabot>   2
05:25:27 <geckr> ah thanks, I think I get it
05:25:30 <nicoo> tdammers: Unless the implementation of permutation uses the previous one in the list to build the next one ;)
05:25:47 <tdammers> nicoo: it would still operate on thunks, not values
05:26:07 <tdammers> except if at some point evaluation of an element were enforced
05:27:56 <lzm> im having lots of problems trying to install the couchdb library on debian squeeze
05:28:39 <lzm> cabal: dependencies conflict: base-3.0.3.2 requires syb ==0.1.0.2 howeversyb-0.1.0.2 was excluded because json-0.7 requires syb >=0.3.3
05:28:42 <nicoo> tdammers: No, it doesn't evaluates the elements themselves, but accessing (all the spine of) the last permutation may force construction of all the previous lists :(
05:28:42 <lzm> not sure how to solve that
05:29:01 <tdammers> nicoo: yes, probably
05:29:18 <frx> is it possible to extract value from IO action and pass it to a pute function in one step  instead of doing var <- ioAction; pureFunc var ?
05:30:10 <hpc> you mean (return (pureFunc var))?
05:30:13 <hpc> :t fmap
05:30:14 <lambdabot> Functor f => (a -> b) -> f a -> f b
05:30:16 <frx> no
05:30:22 <tdammers> I wonder if it would be possible to implement permutations in a way that makes `permutations xs !! n` more efficient than `permutations xs` by itself
05:30:35 <hpc> ah, then you want (>>=)
05:30:39 <frx> pureFunction 'something' ioAction
05:30:44 <hpc> :t getLine >>= putStrLn
05:30:46 <lambdabot> IO ()
05:30:55 <tdammers> frx: liftM?
05:30:58 <tdammers> :t liftM
05:30:59 <lambdabot> Monad m => (a1 -> r) -> m a1 -> m r
05:31:00 <geckr> tdammers: I have a father node in a state space, and I can calculate children nodes of it. I can assign each node a value. I want to a) get the best child (highest value), first child which is better than the father child c) randomly pick a child and check if its better. so for all these three cases I can do e.g. permutations (father node), and only for the a) case, all permutations would be generated, right? :)
05:31:02 <frx> but getLine is not pure function
05:31:09 <hpc> frx: yes
05:31:16 <hpc> frx: if it's a pure function, you need that return
05:31:22 <frx> nor is putStrLn
05:31:31 <hpc> :t length <$> getLine
05:31:32 <lambdabot> IO Int
05:31:49 <hpc> (<$>) = fmap = liftM = lots of other things
05:31:57 <hpc> and that's as good as you are going to get
05:32:13 <tdammers> funny
05:32:25 <tdammers> I had not realized that (<$>) = liftM
05:32:37 <tdammers> always used <$> for applicative and liftM for monads
05:32:41 <frx> that is exactly what I was looking for, thanks
05:32:54 <hpc> @src liftM
05:32:55 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
05:33:57 <tdammers> geckr: in the a) case, you have to walk all the permutations, so yes, it would evaluate them all
05:34:05 * hackagebot HLearn-classification 0.0.1 -   http://hackage.haskell.org/package/HLearn-classification-0.0.1 (MikeIzbicki)
05:34:22 <tdammers> in the c) case, you'd generate a random index, and it would evaluate all the permutation spines up to the index, and then the list at the index itself
05:36:16 <quchen> tdammers: fmap == (<$>) == liftA == liftM
05:36:39 <tdammers> quchen: yes, I know
05:36:43 <tdammers> I already did
05:36:46 <quchen> (Why is there a liftA function anyway? Applicative requires Functor after all.)
05:37:00 <tdammers> I just never realized it in any practical situation
05:37:06 <hpc> because there's also liftA2
05:37:10 <hpc> liftA3
05:37:11 <hpc> etc
05:37:36 <quchen> ... and?
05:37:38 <frx> how come all 3 functions exist? are they complely equal?
05:37:46 <hpc> @src liftA
05:37:47 <lambdabot> liftA f a = pure f <*> a
05:37:56 <hpc> (also known as fmap)
05:37:57 <hpc> but...
05:38:00 <hpc> @src liftA2
05:38:00 <lambdabot> liftA2 f a b = f <$> a <*> b
05:38:04 <hpc> @src liftA3
05:38:05 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
05:38:13 <hpc> well you get the point
05:38:56 <tdammers> frx: historical reasons, I guess
05:38:57 <quchen> hpc: But isn't it an Applicative law that pure f <*> = fmap f?
05:39:06 <hpc> yeah, liftA is fmap
05:39:19 <hpc> but liftA2 and onward are impossible to define with a Functor constraint
05:39:25 <tdammers> I think people discovered functors, applicatives and monads independently
05:39:33 <quchen> Yes, I'm just saying that that makes me not understand what you just wrote.
05:39:37 <hpc> the only reason liftA exists is for completeness with respect to the lift functions
05:39:43 <quchen> Oh.
05:40:01 <quchen> Then my next question would be why is it defined in terms of pure and <*>?
05:40:08 <hpc> no idea
05:40:31 <tdammers> quchen: "because we can"
05:42:58 <hpaste> NoICE pasted “broadcast_tchan_read” at http://hpaste.org/79224
05:43:11 <frx> i like how <$> reads as $ but for monads
05:43:19 <NoICE> elliott: hi there! :) can you please take a look at that hpaste? ^
05:43:31 <`ramses> frx: s/monads/applicatives
05:44:06 * hackagebot tup-functor 0.2.0.3 - Homogeneous tuples  http://hackage.haskell.org/package/tup-functor-0.2.0.3 (BalazsKomuves)
05:44:22 <frx> ramses arent they the same thing?
05:44:47 <`ramses> no, applicatives don't have bind
05:44:51 <tdammers> frx: Applicative is a superset of Monad
05:44:55 <`ramses> an applicative with bind is a monad
05:45:02 <tdammers> as in, all Monads are Applicatives, but not all Applicatives are Monads
05:45:48 <frx> so liftM will not work in some cases where <$> does
05:45:54 <`ramses> indeed
05:46:10 <`ramses> liftM has a monad constraint, liftA an applicative constraint
05:46:40 <`ramses> you could replace every liftM with a liftA (assuming there is an applicative instance for the monad in scope) but not vice versa
05:47:16 <NoICE> anyone interested in STM - broadcast TChan problem? :)
05:47:22 <tdammers> IIRC, the reason for both liftA and liftM existing is that Monads were discovered before Applicatives
05:47:38 <tdammers> so liftM already existed before liftA came around
05:48:01 <frx> that would explain it
05:48:15 <NoICE> tdammers: I've read that Applicatives were introduced as a solution for Monad memory usage problems?
05:48:38 <`ramses> the monad type class should have a class constraint that the type should be an applicative, just like the applicative has a constraint that the type must be a functor.
05:49:07 <`ramses> but it's not there because of the history tdammers mentioned
05:49:49 <merijn> `ramses: s/applicatives/functors
05:50:09 <merijn> :t (<$>)
05:50:11 <lambdabot> Functor f => (a -> b) -> f a -> f b
05:50:16 <`ramses> merijn: where?
05:50:17 <fryguybob> NoICE: Perhaps it is related to this: http://hackage.haskell.org/trac/ghc/ticket/7493
05:50:30 <merijn> `ramses: When you said <$> was for applicatives instead of monads :)
05:50:39 <merijn> > (+1) <$> [1..10]
05:50:40 <lambdabot>   [2,3,4,5,6,7,8,9,10,11]
05:51:03 <tdammers> merijn: that's a good one for golfing
05:51:25 <wuttf> Is there a generic map implementation in Haskell? Like in go you have map[string]interface{}
05:51:36 <tdammers> wuttf: fmap?
05:51:37 <merijn> wuttf: Data.Map?
05:51:38 <frx> fmap
05:51:38 <`ramses> merijn: ah, right :) I always say that wrong because it's in the applicative module
05:51:48 <tdammers> oh wait
05:51:51 <merijn> tdammers, frx: That's Go for a data structure :p
05:51:53 <NoICE> fryguybob: interesting.. trying to find a solution (or bug ticket) on google, but no luck.. source code for broadcastTChan seems to use just TMvar, so it should't be broken :/
05:52:00 <wuttf> frx: , tdammers , merijn ty I will look into it
05:52:11 <tdammers> merijn: I just realized he was talking about the data structure, not the function
05:52:19 <tdammers> wuttf: I think we misunderstood
05:52:25 <tdammers> you need a data structure, right?
05:52:34 <tdammers> Data.Map is probably what you're looking for
05:52:51 <tdammers> but for small lists, an association list works: [(String, a)]
05:52:54 <frx> wuttf: you want Data.Map
05:53:07 <fryguybob> NoICE: If you can build 7.6.2 and try running with that it has the fix for the bug I linked.
05:53:58 <wuttf> tdammers: Yes, I want to be able to convert data coming from mongodb to my own types. I don't know how that work out in Haskell, do I have to write db driver specific code, or can I expect a generic data structure?
05:54:00 <bourbaki> Hidiho
05:54:06 * hackagebot ConstraintKinds 0.0.1.3 - Repackages standard type classes with the ConstraintKinds extension  http://hackage.haskell.org/package/ConstraintKinds-0.0.1.3 (MikeIzbicki)
05:54:31 <`ramses> wuttf: how do you interface with the db?
05:54:54 <tomeo> I thought (.) :: (a -> b) -> (b -> c) -> (a -> c) but ghci says (.) :: (b -> c) -> (a -> b) -> a -> c. Doesn't ghci's type say that (.) takes two functions and an a?
05:55:01 <bourbaki> I want to make a class AbelianGroup and then have a class Field that exposes two operators that are AbelianGroups, thus the class constraint does not hold over the type but the operator, how do i do that in Haskell?
05:55:18 <wuttf> `ramses: I didn't even looked into the mongodb driver, my question is hypothetical. In Go, the query result from the db is a generic, untyped, plain old data-like map
05:55:22 <`ramses> tomeo: that's the same (except you swapped the first two arguments)
05:55:28 <bourbaki> Or would i have to make the operators a type of that class?
05:55:46 <`ramses> wuttf: ah, but I think all depends on the interface...
05:56:02 <fryguybob> NoICE: I'll try myself in a few minutes.
05:56:04 <tomeo> `ramses: Why does (b -> c) have to come first?
05:56:16 <`ramses> because the dot reads as "after"
05:56:24 <`ramses> perform the first function after the second
05:56:33 <NoICE> fryguybob: I'm currently using ghc 7.4.1 x64 with STM 2.3 (i would like to use STM 2.4.2, but monad-loops restricts that (even when it doesn't even mention stm in its dependencies))
05:56:33 <tomeo> `ramses: ahh
05:56:35 <tomeo> thanks
05:56:49 <`ramses> (f . g) x = f (g x)
05:57:02 <`ramses> so f takes as input the return type of g
05:57:32 <merijn> tomeo: Also, the bracketing doesn't matter, -> is right associative, so "(b -> c) -> (a -> b) -> (a -> c)" is identical to "(b -> c) -> (a -> b) -> a -> c"
05:58:10 <`ramses> which is very intuitive in when you view the one with brackets as returning a curried function
05:58:25 <merijn> tomeo: "a -> b -> c -> d" reads as "a -> (b -> (c -> d)))"
05:58:28 <`ramses> (I'm not phrasing that very clearly...)
05:59:26 <frx> what would be an example of a type that is applicative but isnt a monad?
05:59:50 <`ramses> frx: ZipList
06:00:06 <`ramses> many parsing stuff as well
06:00:16 <NoICE> fryguybob: solved stm 2.4.2 dependency and its still buggy, I would like to try ghc 7.6.x but I'm on mac and I'm using haskell platform.. don't know how to proceed
06:01:19 <hpaste> NoICE annotated “broadcast_tchan_read” with “broadcast_tchan_read (annotation)” at http://hpaste.org/79224#a79225
06:01:32 <NoICE> ignore that ^, just fixed variable name
06:01:54 <neutrino_> hi
06:02:28 <merijn> NoICE: You can download the OSX binary of GHC and just install it somewhere
06:02:51 <merijn> NoICE: The readme tells you which command to run and you can use --prefix=/your/install/path to tell it where to install
06:03:11 <wuttf> Anyone has experience with Haskell projects in the 10 000 - 100 000 SKLOC range?
06:03:15 <`ramses> frx: although I think it might be possible to write a monad instance for ZipList if you wanted to
06:03:20 <merijn> NoICE: Then you just makes sure the install directory for 7.6 is on your path before the other installed version and everything should Just Work (TM)
06:03:40 <NoICE> merijn: ok, will try then
06:04:04 <merijn> NoICE: I've not really run into any trouble on OSX, but ymmv
06:06:17 <wuttf> I must be one of the few corporate code monkeys here then
06:07:04 <tdammers> wuttf: negative
06:07:11 <merijn> wuttf: I don't think there's many haskell projects that grow that big...
06:07:34 <merijn> wuttf: because most things just don't require that many lines of code
06:07:40 <tdammers> also, 10k SLOC in Haskell equals 100k SLOC in Java
06:07:51 <merijn> Anyone know how much SLOC ghc is?
06:08:00 <tdammers> no clue, really
06:08:08 <wuttf> I am almost finished porting my 300 lines Go package to haskell and its 46 lines now,
06:08:20 <wuttf> I am kinda freaking out
06:08:34 <tdammers> that's expressiveness for you
06:09:24 <`ramses> wuttf: any figures on the performance? does it make a difference?
06:09:25 <wuttf> I am particularly amazed that I dont have to write yet another for loop
06:09:55 <tdammers> Haskell is pretty much the opposite of verbosity
06:10:07 <t7> wuttf: also you get type safe re-use. (not having to cast to/from interface{})
06:10:32 <wuttf> `ramses: I spared lines at two functions which are O(log n) in the go version but O(n) in the haskell, so I don't benchmark yet
06:11:35 <wuttf> Also I could not learn the Maybe monad so error handling is nonexistent, but I think it will be approx 100 lines when ready.
06:11:45 <NoICE> fryguybob: installing ghc 7.6.1
06:11:51 <frx> wuttf:  by using assoc list instead of Map
06:11:53 <frx> ?
06:12:08 <wuttf> I always thought you Haskell guys are lying :D
06:12:34 <wuttf> frx No. I did a linear search instead of a binary one
06:12:38 <wuttf> (any)
06:12:59 <tdammers> wuttf: same difference ;)
06:13:31 <wuttf> tdammers: :D Yes, in terms of complexity
06:14:51 <NoICE> fryguybob: huh.. how do I install/load STM package in this custom installation?
06:14:55 <wuttf> I am afraid that type inference will reduce readabilty of larger projects, but hey, I am enjoying this language so much it worths a try
06:15:09 <NoICE> do I have to download & untar the tar somewhere and use ghc-pkg register ?
06:15:29 <Botje> wuttf: nobody is forcing you to remove all type information.
06:15:46 <wuttf> Botje: Thats true :D
06:15:48 <Botje> wuttf: putting types on top-level declarations is common sense AND good documentation.
06:17:38 <merijn> Yeah, writing top level type signatures is common practice, and it annoys the crap out of me when people don't do it
06:17:57 <Eelis> agreed
06:17:58 <fryguybob> NoICE: cabal install stm --with-ghc=/path/to/ghc
06:18:06 <Eelis> and i'm bummed that you need a bunch of extensions to be able to place type annotations in more places
06:18:09 <merijn> Especially people that come here asking "hey! why doesn't thise code work?" *paste 10 lines of code with no types*
06:18:20 <NoICE> fryguybob: won't this install it to my main ghc libraries?
06:18:34 <NoICE> (since cabal command is taken from there?)
06:18:40 <NoICE> will try though
06:18:53 <mysticc> Is using f = 1 faster than f _ = 1 ? I suppose first would avoid a function call?
06:19:04 <frx> do you add type information for top level variables too?
06:19:04 <fryguybob> NoICE: Libraries end up separated by ghc version
06:19:11 <NoICE> ok
06:19:17 <Botje> mysticc: those are two different things.
06:19:21 <merijn> frx: I do, yes
06:19:27 <wuttf> One thing I particularly like, and I do not hear in the rhetoric of Haskell advocates, is that prewriting common patterns is possible due to the awesomely generic nature of Haskell's type system.
06:19:56 <NoICE> fryguybob: same results
06:20:12 <mysticc> Botje: Thats what I am asking. Suppose I have a function which is defined only for small number of integers say 10. having f i = ... will be slower than having 10 variables like f_1,f_2 .. ?
06:20:13 <merijn> wuttf: Yes, but it's hard to convince people of that when most people are still stuck in the python/ruby mindset of "types suck and get in the way" :)
06:20:26 <fryguybob> NoICE: Oh, you got 7.6.1, for the fix I had in mind you need a newer one then that.  I don't know if there is a built of it or not.
06:20:27 <hpaste> NoICE annotated “broadcast_tchan_read” with “broadcast_tchan_read (annotation)” at http://hpaste.org/79224#a79227
06:21:08 <wuttf> merijn: Good luck for them on debugging, I rather spend my time with my girlfriend :D
06:21:40 <merijn> wuttf: You will go far, young grasshopper
06:21:43 <mysticc> wuttf: you can still spend time and debug :P
06:21:53 <NoICE> merijn: I came to haskell from ruby, I'll never forget my first ghc-orgasm
06:22:06 <mysticc> merijn: Any thought on my question
06:22:17 <NoICE> merijn:  s/ghc-orgasm/haskell-orgasm :)
06:22:17 <wuttf> NoIce :DDD
06:22:24 <fryguybob> NoICE: I'm building here, but it always takes a bit to get working if I haven't done it in a while.
06:22:24 <NoICE> :)
06:22:37 <NoICE> fryguybob: thanks :)
06:22:41 <wuttf> mysticc: Debugging is the root of all evil
06:23:20 <mysticc> wuttf: Yeah you should avoid that, but still it exists.
06:23:34 <merijn> mysticc: I have no clue, unfortunately. Try it and benchmark? :)
06:23:55 <wuttf> mysticc: Yes, and that's when I wish I would choose a career in McDonalds
06:24:19 <mysticc> merijn: lol.. Thats what I am trying to avoid looking for a saviour here :P
06:24:52 <NoICE> wuttf: merijn: when I did ruby, I've been always thinking about switching my work to cashier in Lidl :D
06:24:57 <hpc> mysticc: for all you know, those will all get reduced to their common normal form of 1
06:25:03 <hpc> at compile time
06:25:09 <hpc> focus on bigger fish
06:26:08 <tdammers> NoICE: try some PHP. You'll wish your job were to clean toilets.
06:26:23 <NoICE> tdammers: I came to ruby from PHP :)
06:26:30 <tdammers> oh.
06:26:43 <wuttf> Will I get rejected from the Haskell community if I only use a retard-compatible subset of Haskell that I can actually understand? Because at this very moment, I think I will never be able to grasp 60% of it.
06:26:49 <mysticc> hpc: That I gave a simple example. suppose f i | 0 <= i < 5 = i and | i <= 10 = something like f (i-3) + f (i-5) ..
06:26:57 <NoICE> tdammers: and I wanted to switch back to php when I discovered how nasty can ruby library developers be :)
06:27:14 <NoICE> (open classes? you mean "I'll screw everything you'll ever do"? :D )
06:27:15 <tdammers> PHP itself isn't half as bad as its community
06:27:26 <mysticc> hpc: I can not as I am trying to optimize to the last bit I can.
06:28:18 <wuttf> Problem with PHP is that everyone and their mum can knock up something in it. Its the lowest common denominator of programming languages.
06:28:34 <NoICE> wuttf: I'm newbie too, but I'm reading any paper on everything haskell-related and I'm making my progress, you'll be fine
06:28:40 <wuttf> many shit programmers = a lot of shit code ^ 2
06:28:58 <rwbarton> mysticc: how about memoizing with an array
06:29:23 <mysticc> rwbarton: I want to totally avoid function calls there.
06:29:25 <NoICE> wuttf: php.. yes, now imagine ruby, where everyone can do what the hell they wanted and you'll discover that they broke everything on production :)
06:29:46 <rwbarton> trust in the inliner
06:29:57 <rwbarton> or, write assembly, your choice
06:30:04 <mysticc> rwbarton: As the number of those is known at compile time and are pretty small. In my case they are 80.
06:30:15 <mysticc> rwbarton: I can not as the definition is recursive
06:30:20 <frx> am I getting too wild in here, having just discovered <$>?  doSomething =<< fromList <$> words <$> readFile filename
06:30:21 <NoICE> everyone in ruby community answers that problem simply: do TDD/BDD/shitDD :) but that's poor solution to bad language design
06:30:33 <rwbarton> looking up in an array is not recursive
06:30:36 <wuttf> NoICE For me dynamic typing is a no go. I am too stupid (and lazy) to code without the help of a compiler.
06:31:06 <mysticc> rwbarton: Thats what I am asking will haveing 80 variables like f_1 .. f_80 will be faster that the the function f?
06:31:09 <rwbarton> you can even precompute the array at compile time for extra speeeeeeeed
06:31:27 <NoICE> wuttf: same for me.. the older I am.. the more I'm tired of this shit :D
06:31:29 <wuttf> rwbarton: randomnumer() int { return 4 }
06:31:32 <rwbarton> well uh
06:31:35 <merijn> frx: Why not "fromList . words <$> readFile filename"?
06:31:40 <mysticc> rwbarton: I cannot as there are the content of the function depends on runtime parameters.
06:31:48 <wuttf> NoICE: How old?
06:32:01 <rwbarton> this question is making less and less sense
06:32:07 <NoICE> wuttf: 1 quarter of a century :D
06:32:18 <mysticc> rwbarton: I wrote a TH to do what I am doing, but I can not splice it inside where. And I am stuck :(
06:32:23 <wuttf> NoICE: I am 23.67 approx
06:32:39 <NoICE> hh
06:32:50 <tdammers> wuttf: even that wouldn't be so bad if people wouldn't buy the crap those wannabe programmers poop out
06:32:53 <merijn> "getting to old" "how old are you?" "25" <- haha :)
06:33:09 <tdammers> "too old"? no such thing
06:33:09 <merijn> Not that I'm much older, mind you...
06:33:11 <frx> merijn: that works too. but was thinking in comparison to text <- readFile filename; doStuff . fromList . words $ text
06:33:12 <NoICE> merijn: I said "the older I am" :)
06:33:14 <wuttf> merijn: you? :D
06:33:50 <merijn> frx: I think I like the latter better, actually. Sometimes having some variable names is good :p
06:34:07 * hackagebot cryptohash 0.8.2 - collection of crypto hashes, fast, pure and practical  http://hackage.haskell.org/package/cryptohash-0.8.2 (VincentHanquez)
06:34:09 * hackagebot lens 3.7.1.1 - Lenses, Folds and Traversals  http://hackage.haskell.org/package/lens-3.7.1.1 (EdwardKmett)
06:34:14 <mysticc> rwbarton: Any ways thanks. I will wait and see If I can get good answers on cafe list.
06:34:22 <tdammers> anyway, yeah... dynamic typing is evil, at least in nontrivial doses
06:34:29 <merijn> wuttf: 26, so I shouldn't complain to much
06:35:20 <NoICE> ruby/python/etc has it's benefits.. for "simple" tasks.. but building complex systems, where you write tests for tests for tests for app... it's damn non-appropriate
06:35:44 <NoICE> I like how haskell teaches me a lesson every time I do some mistake :)
06:35:54 <NoICE> "no dude, you can't put square to a round hole. NO."
06:35:58 <tdammers> the problem is simply that for any function you write, you have to be prepared for *anything* being passed
06:36:01 <Botje> mysticc: note that arrays are lazy, so you can easily express recursive stuff in them.
06:36:07 <wuttf> I promoted Go for half a year for my mates, If I tell them I changed my mind and we should start new shit in Haskell they will shoot me
06:36:38 <NoICE> wuttf: we are rewriting everything to haskell and some members of our team are still sceptical about it.. but they are starting to see :)
06:36:39 <tdammers> e.g., write a factorial() function in a dynamically-typed language, and you have to be prepared to receive a network socket as its first argument
06:36:51 <tdammers> NoICE: lucky you
06:37:31 <NoICE> tdammers: wuttf: I did one meme-thing about ruby :D
06:37:32 <NoICE> http://9gag.com/gag/5640344
06:37:43 <wuttf> NoICE: whos Idea was that yours? :D Prepare to say good bye to you ballsacks if it turns out bad :D
06:38:17 <Botje> mysticc: store = array (1,80) $ map (\x -> (x, f x)) [1..80] where f 1 = 1; f 2 = 1; f x = store ! (x - 1) + store ! (x - 2)
06:38:28 <wuttf> NoICE: commenter -> "I don't get it!"           :D Forever alone, we nerds
06:39:39 <NoICE> wuttf: a colleague of mine ("bindy", sometimes he is on this channel) introduced me to haskell and he does every new task in haskell.. as do I :) it's good how we can learn new things from each other, since we are both beginners
06:40:23 <NoICE> wuttf: yup :D, no one understood that on 9gag
06:40:56 <hpaste> “ScopedTypeVariables + Proxy” pasted “`nand`” at http://hpaste.org/79228
06:41:04 <`nand`> ^ can somebody explain to me why this doesn't work as expected?
06:41:15 <NoICE> fryguybob: how goes compiling?
06:41:32 <hpaste> “`nand`” annotated “`nand`” with “`nand` (annotation)” at http://hpaste.org/79228#a79229
06:41:41 <demogog> Hello everyone
06:41:49 <`nand`> oops, flipped author and title fields
06:42:16 <neutrino_> hey guys, is it ok to use withAsync in the async package to spin up a thread if i don't expect any meaningful return value from it?
06:42:22 <merijn> NoICE, wuttf: There's always lambdacats.org :p
06:42:51 <merijn> `nand`: STV requires explicit forall
06:43:11 <`nand`> oh
06:43:12 <merijn> `nand`: At least, for type variables you intend to use scoped
06:43:22 <NoICE> merijn: :D
06:43:28 <`nand`> yeah, thanks
06:43:33 <`nand`> that's what I was missing :)
06:43:36 <merijn> `nand`: So, "forall a p . Foo a => p a -> String"
06:44:00 <wuttf> merijn: "O HAI, I MADED YOU A TEST CASE" :DDD
06:44:17 <merijn> `nand`: l2read the ghc manual ;)
06:45:38 <fryguybob> NoICE: still chugging along.
06:47:55 <hpaste> bourbaki pasted “Group” at http://hpaste.org/79230
06:48:24 <bourbaki> Could anyone have a look at this and tell me if this is at all the right direction?
06:48:31 <coleman-> is there something like a Map with one key and multiple values?
06:48:34 <`nand`> excellent, my abomination works
06:49:01 <NoICE> fryguybob: ok.. :) .. it's interesting problem/bug.. maybe I'll have to use some different approach.. what I'm trying to do is to signall all worker threads that they should exit gracefully, so I used this broadcasted tchan for it.. thinking about different path.. nothing comes to my mind (except exceptions, but ...)
06:49:10 <`nand`> convert (100 * kilometer/hour) :: Double :@ Meter/Second => 27.77777777777778
06:49:10 <wuttf> how can I get the closest number(s) from a list a given number
06:49:31 <wuttf> *to
06:49:44 <tdammers> coleman-: you can build a Map a [b], or Map a (Set b)
06:49:54 <merijn> NoICE: Oh, you know what I did to do that?
06:50:01 <NoICE> no? :)
06:50:29 <merijn> NoICE: Maintain a Map in a TVar that contains ThreadId, then at the end throw an asynchronous exception to every thread id to do shutdown
06:50:33 <fryguybob> NoICE: Others in this channel are more familiar with working with STM, I'm only familiar with the rts side.
06:50:51 <merijn> NoICE: Then you just have to wrap your workers in an exception handler that lets you do graceful shutdown
06:51:49 <NoICE> merijn: well.. that's what I meant by using exceptions.. I considered that, but the shameful truth is that I don't even know how to make custom exceptions! :D
06:52:10 <wuttf> I created a type from Int: MyInt, how can I cast back to Int
06:52:23 <coleman-> tdammers ok good idea
06:52:29 <merijn> NoICE: Never the wrong time to learn! Control.Exception is pretty well documented. Alternatively, why not just use "TVar Bool" instead of a channel, and then exit if it's true
06:52:29 <NoICE> wuttf: by using type MyInt = Int ?
06:52:55 <wuttf> NoIce I check
06:53:03 <merijn> wuttf: How? type, newtype or data? The first doesn't actually create a new type, the latter two you have to pattern match
06:53:12 <neutrino_> NoICE: i have been considering this same problem right now
06:53:27 <neutrino_> NoICE: one thing you can do is to have a bool MVar
06:53:36 <wuttf> merijn: declaration looks like data MyInt = MyInt Int
06:53:40 <neutrino_> NoICE: but another thing is to use withAsync and the async map
06:53:48 <neutrino_> NoICE: but i'm not sure if that's a perfect use of async
06:53:55 <neutrino_> what do you think merijn
06:54:08 <merijn> wuttf: Ah, then you can just pattern match. "f (MyInt i) = i" or "case x of MyInt i -> i"
06:54:20 <wuttf> merijn: ty
06:54:37 <merijn> neutrino_: I think a TVar makes more sense, tbh
06:54:43 <NoICE> merijn: well.. I wanted to use TChan so I could broadcast it.. by using TVar, I have to use something like peekTVar (which doesn't exist) so all threads can "read" it?
06:54:44 <neutrino_> by async map i mean mapConcurrently
06:55:02 <neutrino_> merijn: what about for my case. i asked a little bit earlier above. do you think withAsync is a good idea?
06:55:13 <NoICE> merijn: and also I wanted to use TChan so I could but arbitrary control messages to all threads, like "new mysql connection, deal with it"
06:55:19 <NoICE> (when mysql disconnects and reconnects)
06:55:24 <merijn> NoICE: What's wrong with readTVar/readTVarIO?
06:55:32 <neutrino_> i only have to start two threads (with different computations)
06:55:35 <NoICE> merijn: that it flushes the tvar out?
06:55:54 <merijn> NoICE: That's a nonsensical statement, you can't take something out of a TVar
06:56:04 <merijn> NoICE: Unlike MVars TVars can't be empty
06:56:39 <NoICE> merijn: ah I see, sorry, just checked the documentation - confused those two (TVar and TMVar)
06:56:47 <merijn> You can look at the value in a TVar or you can change the value in a TVar, you can't remove the value inside it
06:57:47 <wuttf> What is the random access time of a list?
06:57:53 <wuttf> complexity*
06:57:57 <coleman-> O(n), it's a linked list
06:58:40 <`ramses> wuttf: you might want to use newtype instead of data then, http://www.haskell.org/haskellwiki/Newtype
06:58:59 <`ramses> wuttf: random access is linear
06:59:04 <wuttf> coleman-: Ouch. Any vectors?
06:59:32 <Nereid> wuttf: there are a few options for better random access time, like Array/Vector or Seq
06:59:37 <Taneb> wuttf, loads of choices
06:59:40 <merijn> wuttf: Yes, Data.Vector and also Data.Array exist
06:59:51 <Nereid> and Data.Sequence
07:00:43 <merijn> wuttf: Which one is best depends on your access pattern. Mostly read, mostly write, or both equally?
07:01:18 <coleman-> if you are looking things up see Data.Set and Data.Map too
07:01:37 <wuttf> I see, I will look into them
07:01:39 <Nereid> (and IntSet and IntMap)
07:01:48 <artiq> Why is it not possible to write: (-2) 3
07:01:52 <coleman-> they are implemented as a binary tree
07:01:54 <Nereid> > (subtract 2) 3
07:01:56 <lambdabot>   1
07:01:57 <hpc> > (-2)
07:01:59 <lambdabot>   -2
07:02:01 <Nereid> artiq: (-2) means negative 2.
07:02:14 <Nereid> which is why 'subtract' exists.
07:02:15 <artiq> but why does +2 work
07:02:24 <hpc> because "-" is horrid and magical
07:02:32 <Nereid> the only unary operator is -
07:02:34 <hpc> > (+2)
07:02:35 <Nereid> + is not one
07:02:36 <lambdabot>   No instance for (GHC.Show.Show (a0 -> a0))
07:02:37 <lambdabot>    arising from a use of `M83928...
07:02:39 <Nereid> > +5
07:02:40 <merijn> artiq: Normally you can slice operators, i.e. (+2), (/2), etc.
07:02:40 <coleman-> artiq syntax glitch. everything works but -
07:02:41 <lambdabot>   <hint>:1:1: parse error on input `+'
07:02:53 <typoclass> wuttf: are you sure that your lists are routinely so large that the O() times play any role? ("are you sure" in the sense of "have you measured it")
07:02:53 <artiq> aha ok
07:02:54 <coleman-> as (-1) is negative one
07:02:54 <artiq> thanks
07:02:55 <Botje> if only we could differentiate between - and –!
07:03:05 <typoclass> wuttf: here is some information on profiling in haskell http://www.haskell.org/ghc/docs/7.4.2/html/users_guide/profiling.html :-)
07:03:09 <neutrino_> merijn: no comment?
07:03:16 <merijn> neutrino_: eh, wait what?
07:03:21 <otters> isn't the only way to perform an STM action to wrap the whole thing in atomically?
07:03:30 <merijn> otters: Yes
07:03:43 <merijn> otters: That's kinda the point ;)
07:03:44 <neutrino_> merijn: i was wondering if you could say something to what i asked above, but if you're busy that's ok
07:03:54 <`nand`> Any function String -> String to strip leading and trailing whitespace?
07:03:54 <merijn> neutrino_: I think I missed the question
07:03:56 <otters> is it? okay
07:03:57 <wuttf> typoclass: approx 200 elements max, that may result in 40k access
07:03:57 <Nereid> wuttf: don't be afraid of plain lists though, they're plenty good for a lot o fthings.
07:04:02 <merijn> :t isSpace
07:04:03 <lambdabot> Char -> Bool
07:04:23 <Nereid> `nand`: dropWhile isSpace for leading, and then the exercise is to write dropWhileFromEnd.
07:04:23 <merijn> `nand`: takeWhile (not . isSpace) . dropWhile isSpace?
07:04:29 <coleman-> lists are more efficient than arrays when prepending. O(1) vs O(n)
07:04:29 <neutrino_> merijn here it is again: is it ok to use withAsync in the async package to spin up a thread if i don't expect any meaningful return value from it?
07:04:33 <otters> so is it better to atomically $ do { STM actions... } or do { atomic STM action 1; atomic STM action 2; ... }
07:04:38 <Nereid> merijn: no that won't work.
07:04:47 <merijn> neutrino_: I guess it is
07:04:48 <neutrino_> for example, i have a thread which takes care of logging, and i'll be sending it data via a chan
07:04:52 <Botje> otters: that depends entirely on the semantis you want.
07:04:53 <Nereid> > takeWhile (not.isSpace) "hello oops  "
07:04:53 <merijn> Nereid: Oh, yeah, you're right :\
07:04:55 <lambdabot>   "hello"
07:05:03 <neutrino_> but i don't exactly see it as a job that comes up with a result
07:05:21 <`nand`> ah, actually; I can use a different function instead
07:05:28 <`nand`> never mind
07:05:33 <Nereid> :E
07:05:34 <merijn> neutrino_: But why not spawn your own thread instead of using async?
07:05:44 <neutrino_> because withAsync brackets it
07:05:52 <neutrino_> so i don't have to bother with thread management
07:05:54 <merijn> otters: Those two are different things
07:06:04 <merijn> neutrino_: The thread will die when it finishes anyway
07:06:12 <otters> I guess my question was "what's the difference between"
07:06:14 <neutrino_> it never finishes
07:06:20 <neutrino_> it would leak if i don't kill it
07:06:44 <merijn> otters: The first atomically does *all* actions, the second performs each action atomically, but with possible other things happening in between every action
07:06:56 <neutrino_> know what i mean merijn
07:06:56 <otters> Oh, right, "atomically"
07:06:58 <otters> of course
07:07:03 <neutrino_> i'm not sure if i'm explaining this right
07:07:25 <merijn> neutrino_: Why would you want to kill it if it's never done?
07:07:39 <neutrino_> because i know that it's done, the thread doesn't
07:07:46 <typoclass> wuttf: 200 sounds very small. i bet the O() complexity will have no influence whatsoever :-) honestly, performance is so counterintuitive, you really should implement the simplest possible thing and then find the bottlenecks through profiling. i think you're wasting your time otherwise
07:07:47 <neutrino_> the thread listens forever on a chan and writes to a file
07:08:04 <typoclass> wuttf: anyway, that's what i would recommend :-)
07:08:07 <neutrino_> if the thread writing to the chan knows it's done writing, then it knows that "never ending" thread is done
07:08:09 <neutrino_> so it can kill it
07:08:23 <hpc> neutrino_: give the thread an additional "we're done now" MVar
07:08:24 <neutrino_> either by doing it manually, or by just exiting and invoking the bracket
07:08:35 <neutrino_> hpc: why is that better than withAsync?
07:09:16 <hpc> then you aren't killing threads at unspecified points in their own execution
07:09:25 <neutrino_> hmm
07:09:26 <hpc> you are letting each thread pick the time and place of its demise :P
07:09:34 <neutrino_> gotcha
07:09:40 <hpc> (that sounds like the start of a horrible movie)
07:09:46 <neutrino_> yes
07:09:47 <neutrino_> it does
07:10:13 <neutrino_> so maybe i should use withAsync for absolute worst-case bracketing, and the MVar or TVar for graceful bracketing
07:10:17 <neutrino_> ?
07:10:18 <neutrino_> sounds like a plan
07:10:26 <neutrino_> i guess
07:10:26 <hpc> usually you reserve killing threads for "oh god something happened and we need to panic"
07:10:39 <hpc> except "panic in a fixable way"
07:10:58 <neutrino_> i don't know what that last line means
07:11:10 <hpc> eh, i am just rambling :P
07:11:16 <neutrino_> ok
07:11:23 <neutrino_> well, i'm going to go to the gym now i guess
07:11:25 <neutrino_> see you later
07:13:18 <neutrino_> thanks for the help guys
07:14:40 <frx> is there a function that takes any function with random type signature and returns infinite list of random values?
07:15:32 <`ramses> frx: what would the type of such a function be?
07:15:52 <`ramses> frx: where would the random values come from?
07:15:57 <bourbaki> How can i model constraints on functions in a class, like associativty or distributivity?
07:16:35 <Clint> frx: do you know about QuickCheck
07:17:48 <fryguybob> NoICE: 7.6.2 does not change the behavior of your code.
07:17:54 <frx> ramses it would take a function that takes random gen and a random value and the build infinite list of values with it
07:18:12 <frx> "takes random gen and returns a randon value"
07:20:46 <frx> type would be something like (RandomGen g) => (g -> (a, g)) -> [a]
07:20:54 <geckr> I am not sure if understand laziness/strictness right; for exmaple "fromList" ( http://hackage.haskell.org/packages/archive/containers/0.4.1.0/doc/html/src/Data-Set.html#fromList  ) from "Data.Set": because this function is strict, whenever I have "function (fromList  x)" in my code, all the elements in x are transformed to a set, before "function" can do something with an element from the set?
07:23:23 <hpc> geckr: fromList is strict in the spine of the list, if that makes sense
07:23:36 <Saizan> hpc: it's strict in the elements too
07:23:43 <Saizan> it has to sort them
07:23:45 <hpc> oh yes, durr
07:23:51 <geckr> hpc: what does spine exactly mean?
07:23:58 <hpc> geckr: ignore that :P
07:24:11 <hpc> but it basically means, in (a : (b : (c : [])))
07:24:18 <hpc> it matches on (:) and []
07:24:21 <hpc> but not a, b, or c
07:24:53 <geckr> ah ok
07:24:56 <hpc> but yeah, it has to look through every element of the list to know what order they should be in, when added to the tree
07:24:57 <typoclass> > take 3 [42..] -- geckr: in general, only the part of the list is produced which is needed (in this case: needed by "take 3"). otherwise, this would of course "run forever" because the list is infinite
07:24:59 <lambdabot>   [42,43,44]
07:25:28 <geckr> ok
07:25:53 <geckr> how would a lazy version of fromList look like? has foldlStrict to be replaced by foldr for example?
07:27:01 <Saizan> you can't really make a lazy version of fromList considering the structure of the Set type
07:28:15 <geckr> because for example when I apply "findMax" to a set, all elements in the list have to be converted to the set anyway?
07:28:58 <Saizan> yeah
07:29:14 <coleman-> random gen in ghci gives me "Ambiguous type variable `a0' in the constraint:"
07:29:23 <Saizan> also, you can't know which one is the maximum without looking at all the lements
07:29:24 <artiq> How should you think when you try to determine the type of a function like: map.zipWith
07:29:27 <coleman-> random gen :: (<what here>, Int) ?
07:29:38 <Saizan> coleman-: StdGen
07:30:05 <geckr> Saizan: but I just want an arbitrary element from the set, therefore I did "fromList . take 1 . Set.toList", I don't see how I need strictness in this case
07:30:18 <coleman-> thanks that worked
07:30:40 <geckr> Saizan: oh, forget the first "fromList"
07:31:15 <Saizan> geckr: why do you convert to Set at all?
07:31:31 <coleman-> geckr set is auto sorted. it has to consume all the elements to know which one comes first
07:31:50 <typoclass> Saizan: it's all a bit unclear to me. do you have some more information? (link to a blog post or whatever)
07:31:54 <Saizan> geckr: anyhow, it's the structure of Set, since it's sorted, that makes fromList strict
07:32:21 <geckr> but where is the problem of sorting the set again, if I insert an element?
07:32:57 <geckr> Saizan: I used Set because I want to avoid  to have multiple elements
07:33:00 <typoclass> Saizan: i see that a function "find me the maximum" has to force a list, or set, or any data structure because it needs to check each element. but i thought the creation of the list can still be lazy. haskell still allows lazy lists, and has a "maximum" function. it's just that this function doesn't work on infinite lists
07:33:35 <typoclass> Saizan: i also wonder why fromList in Data.Set is described as O(n*log n) when it's supposed to force each of the n elements
07:33:57 <Saizan> geckr: if you want a lazy uniq you can write one
07:34:01 <Botje> typoclass: you have to insert each element into a tree
07:34:18 <Saizan> geckr: Set.toList . Set.fromList can't be that
07:34:29 <Botje> insertion into a tree is O(log n) given a balanced tree, you have O(n) elements.
07:34:48 <geckr> Saizan: sorry, what do I have to write on my own for this?
07:35:02 <artiq> Why does the function map.zipWith need a [[a]] as one of its arguments and not [a]?
07:35:12 <Saizan> geckr: if you don't mind O(n^2) behaviour there's nub
07:35:14 <Nereid> :t map . zipWith
07:35:16 <lambdabot> (a -> b -> c) -> [[a]] -> [[b] -> [c]]
07:35:17 <Saizan> ?type nub
07:35:18 <lambdabot> Eq a => [a] -> [a]
07:35:18 <Nereid> :t map .: zipWith
07:35:21 <lambdabot> (a -> b -> c) -> [a] -> [[b]] -> [[c]]
07:35:43 <coleman-> that is odd. my zipWith is zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
07:35:48 <typoclass> Botje: hmm ok
07:35:59 <Nereid> coleman-: what's odd about it? no one mentioned zipWith
07:36:04 <Nereid> without map
07:36:13 <coleman-> Nereid heh I see that now
07:36:18 <hpc> :t zipWith
07:36:19 <lambdabot> (a -> b -> c) -> [a] -> [b] -> [c]
07:36:30 <geckr> Saizan: hm there is also a nub which has O(n * log n), but Set has O(n + m) for union, that's why I choose it
07:36:33 <artiq> but why does it need a list of lists+
07:36:33 <Saizan> geckr: otherwise you can write something like uniq xs = go Set.empty xs where go seen [] = []; go seen (x:xs) = if Set.member x seen then go seen xs else x : go (Set.insert x seen) xs
07:36:49 <Botje> artiq: very probably map . zipWith is not what you want.
07:37:01 <Botje> artiq: can you give a more concrete example of what you're trying to do?
07:37:25 <artiq> Nope, it's an exercise question
07:37:30 <artiq> that im trying to understand
07:37:45 <Botje> artiq: well, work out map . zipWith using the definition of (.) first
07:37:52 <Botje> @src (.)
07:37:53 <lambdabot> (f . g) x = f (g x)
07:37:53 <lambdabot> NB: In lambdabot,  (.) = fmap
07:37:59 <Nereid> just look at the types.
07:38:02 <Nereid> :t map
07:38:04 <lambdabot> (a -> b) -> [a] -> [b]
07:38:05 <Nereid> :t zipWith
07:38:07 <lambdabot> (a -> b -> c) -> [a] -> [b] -> [c]
07:38:22 <geckr> Saizan: this is lazy version of fromList?
07:38:28 <coleman-> can I do something like this (it doesn't work).  liftM (+1) random gen
07:38:59 <Saizan> geckr: no, this is a lazy efficient uniq
07:39:02 <Nereid> coleman-: try more parentheses.
07:39:10 <Botje> coleman-: that would apply (+1) to the returned generator, unfortunately.
07:39:14 <Nereid> so in map.zipWith, the (a -> b) of map is unified with the ([a] -> ([b] -> [c])) of zipWith.
07:39:14 <`nand`> Can't I pattern match on Language.Haskell.TH.Name; using 'Foo in a pattern?
07:39:17 <Nereid> :t map.zipWith
07:39:18 <lambdabot> (a -> b -> c) -> [[a]] -> [[b] -> [c]]
07:39:23 <Saizan> geckr: there can't be a lazy version of fromList
07:39:40 <Botje> coleman-: you can do first (+1) (random gen), though.
07:40:14 <Botje> coleman-: or (+1) . fst $ random gen
07:40:21 <Nereid> :t random ?gen
07:40:23 <lambdabot> (?gen::g, RandomGen g, Random a) => (a, g)
07:40:28 <coleman-> nice thanks
07:40:40 <Nereid> :t first (+1) $ random ?gen
07:40:40 <hpc> :t let horribleFromList _ = Set.empty in horribleFromList
07:40:41 <lambdabot> (?gen::d, Num c, RandomGen d, Random c) => (c, d)
07:40:42 <lambdabot> Couldn't find qualified module.
07:40:51 <hpc> :t let horribleFromList _ = S.empty in horribleFromList
07:40:52 <lambdabot> t -> S.Set a
07:40:52 <Saizan> geckr: because the shape of the resulting tree is determined by sorting the elements of the list, the only way to avoid that is to break the fundamental invariant of Set, which would also make the other operations less efficient
07:41:23 <Botje> coleman-: you could also look at randomR, which allows you to specify a range.
07:41:25 <Saizan> geckr: well, it'd just break them as written, but if they had to handle malformed Set's they'd be less efficient
07:41:39 <typoclass> does anyone have documentation on Data.Set? (i gather from the discussion in here that it's sorted or something, but the haddock doesn't really mention that)
07:41:51 <Botje> coleman-: randomR (1,2) gen -- seems to be what you intended.
07:42:13 <hpc> typoclass: Data.Set is internally identical to a Map with () values
07:42:33 <hpc> and a Map is a sorted binary tree, iirc?
07:42:48 <hpc> use the source, luke
07:43:35 <geckr> Saizan: but this strict fromList has O(n * log n). If you laszy insert all the n elements as needed, you would also have O(n * log n), when O(log n) is insertion?
07:43:53 <MasseR> Is there any way to profile memory without compiling with -prof? Memory explodes if I compile with -O2, but is constant with runhaskell
07:44:02 <Saizan> geckr: insert is also strict wrt the set
07:44:06 <hpc> MasseR: gdb ;)
07:44:38 <MasseR> :< not too fond of recompiling _everything_ with profiling
07:44:51 <typoclass> hpc: right. i kinda guessed it's like a Map with the values being ignored, based on the name "Set" ...
07:44:53 <hpc> you could probably do something with the ghci debugger
07:45:22 <hpc> hmm
07:45:55 <geckr> Saizan: ok, thanks :) maybe a hint at that Set uses strictness at the top of the module would be be helpful?
07:45:55 <Saizan> geckr: and the element
07:46:53 <Saizan> geckr: we'd have to put it everywhere
07:48:06 <hpc> it's actually already there
07:48:12 <hpc> This module satisfies the following strictness property:
07:48:12 <hpc>     Key arguments are evaluated to WHNF
07:48:12 <hpc> Here are some examples that illustrate the property:
07:48:12 <hpc>  delete undefined s  ==  undefined
07:48:40 <nomeata> What would be a good module space for an algorithm that packs circles. Optimisation.CirclePacking?
07:49:06 <hpc> nomeata: that's... a good question
07:49:17 <hpc> Algorithm?
07:49:28 <nomeata> the API is: (a -> Double) -> [a] -> [(a, (Double, Double))]
07:49:42 <geckr> hpc: could you provide a link? I don't see it
07:49:52 <hpc> http://hackage.haskell.org/packages/archive/containers/latest/doc/html/Data-Set.html
07:50:01 <typoclass> geckr: it's under "strictness properties" at the top
07:50:16 <typoclass> nomeata: sure, why not
07:50:32 <geckr> oh; I looked at containers-0.4.1.0: :)
07:51:43 <hpc> if you are using firefox, add hoogle as a search engine
07:51:48 <hpc> and give it a keyword of hoogle
07:51:56 <hpc> then in the address bar, you can type "hoogle set"
07:51:58 <hpc> and poof!
07:52:18 <hpc> latest version of docs for just about everything worth using
07:53:21 <coleman-> > liftM (+1) (1, 2)
07:53:23 <lambdabot>   No instance for (GHC.Base.Monad ((,) t0))
07:53:23 <lambdabot>    arising from a use of `e_1112'...
07:53:24 <geckr> thanks, this is nice
07:53:28 <coleman-> shouldn't this work?
07:53:44 <coleman-> could swear I did something similar before
07:54:17 <fmap> > fmap (+1) (1,2)
07:54:20 <lambdabot>   (1,3)
07:54:25 <fmap> interesting
07:55:23 <sorbo_> learning Haskell, I've found that I have about four "shouldn't this work?"s
07:55:30 <sorbo_> followed by a "there's no way in hell this will work"
07:55:30 <sorbo_> a
07:55:33 <typoclass> hpc: right, but still, i wish they'd fix it on the server once and for all, instead of 1000 people fixing it in their firefoxes one by one :-)
07:55:37 <sorbo_> nd that ends up being the right solution
07:56:04 <hpc> typoclass: it's not a "fix" of any kind that can be done server-side :P
07:56:18 <hpc> unless we are talking about different things...
07:56:40 <typoclass> hpc: i thought, changing robots.txt so that google goes to "latest" by default, instead of old packages
07:56:43 <fmap> coleman-: I guess that Monad instance just isn't defined anywhere
07:56:58 <hpc> no
07:57:11 <hpc> changing firefox's location bar behavior to give you direct hoogle access
07:57:21 <hpc> i do a similar thing for agda's docs
07:57:59 <hpc> and pretty much all the rest of what i do is handled by duckduckgo
07:58:32 <geckr> a "key argument" is the first agument passed to a function?
07:58:45 <`ramses> > liftA (<> Sum 1) (Sum 1, Sum 2) -- coleman-
07:58:47 <lambdabot>   (Sum {getSum = 1},Sum {getSum = 3})
07:59:02 <`ramses> not very convenient though
07:59:19 <Botje> geckr: key as in key-value?
07:59:41 <geckr> Botje: as it appears here: http://hackage.haskell.org/packages/archive/containers/latest/doc/html/Data-Set.html at strictness properties
08:00:29 <typoclass> hpc: yes, i'm familiar. i've been using stuff like that for many years. (i believe opera is where firefox got that from ;-) ). still it'd be more friendly if google didn't show random ghc 6.12 documentation, old packages, etc.
08:00:46 <fmap> geckr: key means set's element
08:01:28 <typoclass> geckr: i think that's a copy-paste error, they probably copied the documentation from Data.Map. "key element" means "stuff that the Set contains", as far as i can tell
08:03:17 <geckr> ok; how can you deduce from this strictness property that "fromList" puts all the elements at one go into a set?
08:03:48 <coleman-> would liftTup1 be a bad name for a function that does this:  liftTup1 (+10) (1,2)  => (11,2)
08:04:18 <cmccann> well, "Data.Set.Set a" is isomorphic to "Data.Map.Map a ()"
08:04:36 <Botje> coleman-: that function is already defined in Control.Arrow as "first"
08:04:52 <cmccann> > first (+10) (1, 2)
08:04:53 <lambdabot>   (11,2)
08:05:01 <cmccann> > second (+10) (1, 2)
08:05:03 <lambdabot>   (1,12)
08:05:18 <cmccann> > (+20) *** (+10) $ (1, 2)
08:05:20 <lambdabot>   (21,12)
08:05:24 <coleman-> Botje oh? I remember you typed it earlier but I didn't grook it. thanks
08:05:38 <fmap> > over _1 (+10) (1,2)
08:05:39 <coleman-> actually I thought it was a typo for fst
08:05:40 <lambdabot>   (11,2)
08:06:03 <typoclass> geckr: hm, good question ...
08:12:11 <hpaste> String pasted “complete induction” at http://hpaste.org/79231
08:12:54 <Botje> geckr: if you implement fromList as foldl Set.insert Set.empty, for example.
08:13:47 <geckr> Botje: this would be a lazy fromList?
08:13:57 <Botje> this would be strict.
08:14:19 <Botje> foldl must walk the entire list to produce a value.
08:15:47 <String> http://hpaste.org/79231   I want to ask if somebody could explain me how to make an complete induction to n on this to show if the first and the snd function are equal
08:16:54 <geckr> Botje: I though foldl' would be a strict variant of foldl
08:16:58 <geckr> thought*
08:17:46 <Botje> geckr: foldl' is the same as foldl, except it reduces the accumulated value to WHNF for every step.
08:17:56 <`ramses> > let fmap' f = swap . fmap f . swap in fmap' (+3) (1,3) -- coleman-
08:17:58 <lambdabot>   (4,3)
08:18:13 <Botje> String: that sounds like homework
08:19:26 <`ramses> coleman-: ^^
08:20:03 <String> @botje   sounds like I need help ^^
08:20:03 <lambdabot> usage: @vote <poll> <choice>
08:24:30 <wuttf> Can I load code dynamically?
08:24:33 <nus> String, http://math.stackexchange.com/questions/19485/dominoes-and-induction-or-how-does-induction-work
08:24:50 <jlamothe> Silly newbie question: is there a way to explicitly state that if an object is of class A that it is also of class B?
08:24:58 <cmccann> wuttf, yes, but the details may vary depending on exactly what you have in mind
08:25:05 <`ramses> jlamothe: there are no objects..
08:25:13 <cmccann> jlamothe, what is an "object" :P
08:25:18 <jlamothe> `ramses: A data-type, rather.
08:25:19 <`ramses> jlamothe: but you might be looking for class constraints
08:25:27 <wuttf> cmccann: I just want to implementa  plugin system, that needs dynamic coad loading
08:25:34 <byorgey> jlamothe: class B a => A a where ...
08:25:37 <nomeata> With diagram’s envelopes, is there a good way to find the maximum radius of an object?
08:25:49 <jlamothe> byorgey: That was the syntax I was looking for.  Thanks!
08:25:58 <cmccann> wuttf, look at the hint package
08:26:01 <cmccann> @hoogle hint
08:26:01 <lambdabot> Graphics.Rendering.OpenGL.GL.Hints module Graphics.Rendering.OpenGL.GL.Hints
08:26:01 <lambdabot> Graphics.Rendering.OpenGL.GL.Hints hint :: HintTarget -> StateVar HintMode
08:26:01 <lambdabot> package hint
08:26:17 <byorgey> nomeata: not really
08:26:24 <cmccann> @hackage hint
08:26:24 <lambdabot> http://hackage.haskell.org/package/hint
08:26:25 <byorgey> nomeata: you can sample at a lot of points and take the maximum
08:26:31 <cmccann> there, that's what I meant to do. :T
08:26:36 <nomeata> byorgey: ok, thats what I guessed.
08:26:50 <artiq> how can I use the foldl or foldr to define map?
08:26:58 <byorgey> nomeata: however, we're working on generalizing things to allow some automatic differentiation (and other stuff) which might make it possible to actually find the max radius directly.
08:27:04 <byorgey> but don't hold your breath.
08:27:38 <cmccann> wuttf, I think there are other examples of loading code at runtime that might be better for your purposes
08:27:43 <cmccann> but I can't recall them right now, sorry
08:28:05 <wuttf> cmccann: no problem i dont need it right away but i will in the future
08:29:04 <cmccann> wuttf, well ask around in here when you do, you'll probably want advice on how to go about it
08:29:18 <byorgey> wuttf: 'hint' can be used to dynamically interpret some code at runtime.  If you want to have dynamically loaded plugins you might want to look at the 'plugins' package: http://hackage.haskell.org/package/plugins
08:29:21 <cmccann> I seem to recall there being a few pitfalls last time I tried stuff like that
08:29:43 <cmccann> ah yes, plugins. a very obscure name, no wonder I couldn't remember that.
08:29:48 <cmccann> never would have guessed.
08:29:53 <cmccann> :T
08:30:32 <byorgey> hehe
08:30:36 <wuttf> :D
08:31:09 <wuttf> Is the haskell runtime written in C?
08:31:28 <fryguybob> wuttf: C, Haskell, and cmm
08:32:20 <cmccann> we don't have a perl script that performs cryptic optimizations on assembly code anymore, right? I seem to recall that went away.
08:32:33 <cmccann> C for the runtime is fine but that was just horrifying
08:32:38 <t7> mangler? ,unger?
08:32:44 <t7> munger*
08:34:05 <coleman-> > map' f = foldr (\x acc -> f x : acc) []
08:34:07 <lambdabot>   <hint>:1:8: parse error on input `='
08:34:18 <startling> cmccann: haha what
08:34:22 <ryant5000> i'm having trouble compiling 'containers' with UHC; is that possible?
08:34:30 <typoclass> wuttf: another recommendation -- have a look at the "xmonad" window manager. it behaves a little like it has plugins, but it does it in a more simple, direct way. personally, i think plugins are often unnecessary ... recompiling/restarting a program is really quite manageable, compared with the complexity and hidden problems of a plugin system
08:34:54 <Clint> only if you have a compiler on the system
08:35:06 <cmccann> startling, cf. http://darcs.haskell.org/ghc/docs/comm/the-beast/mangler.html
08:35:19 <jdnavarro> is there an easy way to apply '[b,c,d..z]' to 'a <$> b <*> c <*> d <*> .. z'?
08:35:23 <wuttf> typoclass: recompilation was my plan z, but I will think about it
08:35:36 <cmccann> startling, the url should give you the idea
08:35:51 <startling> cmccann: o.o
08:36:32 <wuttf> Last question for today guys. I have  data MySuperType = MySuperType [MyType]            how can i convert a [MyType] to MySuperType ?
08:36:44 <startling> cmccann: I know hindsight is 20/20, but....
08:37:02 <cmccann> startling, apparently it finally got exorcised a couple years ago
08:37:04 <Clint> wuttf: MySuperType
08:37:17 <wuttf> Clint: and the other way around?
08:37:34 <wuttf> just simply call it like a function?
08:38:17 <wuttf> Clint: you mean let x = MySuperType y -- where y is [MyType] ?
08:40:21 <typoclass> wuttf: yes, you can call the constructur like a function. "main = print $ foo (MySuperType [ some-stuff-of-type-MyType ])". for the reverse, if your function "foo" needs the list extracted, use "foo (MySuperType xs) = do-something-with-xs"
08:41:43 <bourbaki> Is there any way to get something like scoping of functions in classes so you can have the same name several times in the same file?
08:43:39 <wuttf> typoclass: WORKS! thank you very much.
08:43:41 <tdammers> bourbaki: you can scope functions inside functions using let or where
08:43:51 <typoclass> wuttf: ;-)
08:44:13 <typoclass> wuttf: please have your female goat ready, sacrifice day is coming up next month
08:44:55 <wuttf> typoclass: ;)
08:45:51 <bourbaki> tdammers: I have that problem when deriving classes though.
08:48:31 <cmccann> typoclass, fortunately the god of haskell is not strict, and in fact never actually demands the sacrificed goats. just offer _|_ and be done with it.
08:48:48 * typoclass giggles
08:50:42 <cmccann> typoclass, at least until judgement day, when the universe will be evaluated to see if it diverges
08:56:40 <NoICE> fryguybob: (I was afk) thanks for the test on 7.6.2
09:00:12 <fryguybob> NoICE: No problem.  When I have time I'll try to dig into it further.  Like I said, I don't know much of the higher level STM api's at this point.
09:01:27 <hpaste> nomeata pasted “diagrams code” at http://hpaste.org/79234
09:02:03 <nomeata> byorgey: I am adding this code as example code to a library of mine: http://hpaste.org/79234
09:02:32 <nomeata> byorgey: Is this idiomatic diagrams code or would you rather not want to see that somewhere public? Any improvement is welcome.
09:03:23 <byorgey> nomeata: cool!
09:03:34 <byorgey> nomeata: looks pretty idiomatic to me
09:03:41 <nomeata> great, thanks
09:03:53 <byorgey> nomeata: and even if it wasn't, I wouldn't care if you posted it =)
09:04:15 <byorgey> nomeata: what's Optimisation.CirclePacking? is that your library?
09:04:25 <nomeata> byorgey: yupp
09:04:30 <byorgey> nice
09:04:35 <`nand`> (\c o -> o # fc c) is the same as fc
09:04:49 <byorgey> ah, good point `nand`  =)
09:05:13 <nomeata> byorgey: if diagram objects had a better defined radius this might make a good addition to diagram-libs or some other library
09:06:19 <byorgey> nomeata: can I see an image of the output? =)
09:06:58 * typoclass thought byorgey would look at the source code and see through it, like the dude in matrix who looks at the green squiggles and sees "the blonde with the red dress"
09:07:07 <byorgey> hahaha
09:07:08 <nomeata> byorgey: once I upload the package, in the docu. It is included as a SVG file in a data url :-)
09:07:20 <`nand`> typoclass: would need the source code of packCircles for that ;)
09:07:34 <nomeata> `nand`: who knows what byorgey is capeable of :-)
09:07:35 <typoclass> `nand`: oh right, of course
09:07:41 <byorgey> typoclass: I can do that for pure diagrams code of course, but I don't know how nomeata's library works
09:07:49 <byorgey> =)
09:08:09 <`nand`> byorgey can look at the definitions of fractals and spend an afternoon exploring them in his mind
09:08:30 <`nand`> fix ((c+) . (^2))
09:08:31 <byorgey> speaking of fractals: http://www.cis.upenn.edu/~byorgey/hosted/RandomIters2.pdf  =)
09:09:00 <frx> is there a function like this in standard library?  http://hpaste.org/79235
09:10:01 <typoclass> frx: yes i'm pretty sure, hang on
09:10:06 <jmcarthur> neutrino_: "btw, i was wondering why you have used async, and not withAsync in that example you've given me?" ... i'm actually not very familiar with that library, so it could have just been an oversight
09:10:10 <byorgey> frx: yes, randoms
09:10:16 <byorgey> @type randoms
09:10:18 <lambdabot> (RandomGen g, Random a) => g -> [a]
09:10:34 <byorgey> oh, I guess that's not exactly the same thing
09:10:51 <byorgey> well, the randFun is encapsulated in the Random instance for a
09:10:51 <`nand`> isn't ‘randFun’ part of ‘Random’?
09:11:15 <`nand`> you could construct your own Random instance at runtime and pass that to randoms ;)
09:11:33 <typoclass> frx: yeah, "randoms" in the Random typeclass http://hackage.haskell.org/packages/archive/random/1.0.0.3/doc/html/System-Random.html you might get the global generator and call it with that
09:13:22 <nomeata> (package uploaded, waiting for documentation to show up)
09:13:40 <byorgey> oh, that can take a while =(
09:13:45 * byorgey is patient
09:14:10 * hackagebot circle-packing 0.1.0.0 - Simple heuristic for packing discs of varying radii in a circle  http://hackage.haskell.org/package/circle-packing-0.1.0.0 (JoachimBreitner)
09:16:02 * `nand` is impatient, and looks at the source
09:16:10 <`nand`> bottom of view-source:http://darcs.nomeata.de/circle-packing/Optimisation/CirclePacking.hs :)
09:16:26 <`nand`> oh, ignore the view-source: stuff; that's from firefox
09:17:02 <frx> I am not sure how or if randoms and Random can be used to accomplish the same thing? say I have randDice function that returns a number from 1 to 6. I could get infinite list like this: makeRandList randDice gen
09:17:19 <byorgey> oooh, nice =)
09:17:24 <nomeata> byorgey: if you are really curious, then run: darcs get http://darcs.nomeata.de/circle-packing ; cd circle-packing; ghc --make -O2 diagrams-demo.hs; ./diagrams-demo -w 400 -o test.svg; firefox test.svg
09:17:40 * byorgey just copy-pastad the data: URL into firefox =)
09:17:55 <`nand`> same :)
09:17:58 <nomeata> (and notice how slow it is at the moment. but I did do zero optimisation besides adding a TODO list of easy ideas to speed up the code to the code)
09:18:49 <`nand`> frx: randomsR (1,6)
09:18:51 <`nand`> or whatever
09:18:57 <byorgey> randomRs
09:19:04 <`nand`> yeah, that
09:19:27 <frx> nand sure but that works just in this specific case, not for every random function
09:19:52 <`nand`> if you need some special purpose random function, you could create a newtype for the type you're producing; then add a Random instance for that
09:20:21 <`nand`> alternatively, you could use randomRs and map a function :: Integer -> a -- or whatever
09:20:22 <byorgey> yeah, but that's annoying if you have a bunch of functions operating on the same type
09:20:43 <typoclass> frx: could you give use more information on the "random function" that you're using?
09:20:57 <typoclass> (if you want, use hpaste)
09:21:00 <typoclass> @where hpaste
09:21:01 <lambdabot> http://hpaste.org/
09:21:31 <nomeata> byorgey: now that I think about it, the envelop gives a conservative estimate. So if I calculate the max in, say, 4 directions and then multiply by sqrt 2, the object is guaranteed to be contained in a circle of that diameter
09:21:59 <`nand`> frx: also in the function you wrote, why have RandomGen g and Random a constraints?
09:22:12 <byorgey> nomeata: true, though that might not be a very good estimate
09:22:20 <nomeata> byorgey: Or, a bit more accurate, I can get a safe approximating octagon and then take the (larger) radius of that.
09:22:28 <byorgey> right
09:22:43 <nomeata> Which would, for most somewhat regular shapes, give a sensible result.
09:22:52 <`nand`> :t unfoldr -- very similar type, without the constraints
09:22:53 <lambdabot> (b -> Maybe (a, b)) -> b -> [a]
09:23:00 <`nand`> :t unfoldr . (Just.)
09:23:01 <nomeata> And then my algorithm could be used to layout arbitrary diagrams.
09:23:02 <lambdabot> (b -> (a, b)) -> b -> [a]
09:23:08 <`nand`> ^- frx
09:23:14 <byorgey> nomeata: indeed! =)
09:23:38 <coleman-> can someone recommend me a sql database library? there seem to be several
09:23:52 <`nand`> No, but I can recommend acid-state :P
09:23:53 <beekor> i liked the hdbc stuff
09:23:59 <beekor> if thats what you're looking for
09:24:05 <beekor> -d.  currently like
09:24:12 <nomeata> byorgey: I only wonder if that should be yet another package of its own or if it would fit some existing package.
09:24:15 <Clint> coleman-: persistent
09:24:26 <byorgey> nomeata: which part?
09:24:36 <viran> hey... anyone knows a little about b+ trees? i have a theoretical question
09:25:10 <nomeata> byorgey: the glue, basically calculating the radius,  "position . map (\(o,(x,y)) -> (p2 (x,y),o))" and the call to packCircles.
09:26:29 <nomeata> Of course I’d like to see it being part of diagrams-lib, but I’m not sure if you’d like the additional dependency (although circle-packing is quite pure, depending only on base).
09:26:47 <byorgey> nomeata: calculating the radius can go in diagrams-lib
09:27:08 <byorgey> nomeata: a good place for the other stuff is diagrams-contrib
09:27:34 <nomeata> byorgey: agreed
09:27:51 <byorgey> which still means you pull in 'circle-packing' when doing 'cabal install diagrams', but as you say, it's pure, so I don't really mind
09:28:09 <nomeata> Ah, there is also force-layout being used. I was looking at that first, but it did not give pretty results for my problem.
09:28:54 <byorgey> yes, I wouldn't imagine so
09:29:18 <nomeata> It could even be integrated into Diagrams.TwoD.Layout.Tree to layout hierachical information by nesting circles.
09:30:04 <byorgey> oh, fun =)
09:30:50 <hpaste> bourbaki pasted “Fields” at http://hpaste.org/79237
09:30:56 <byorgey> nomeata: also, it's not required, but feel free to join #diagrams
09:31:20 <bourbaki> What happens if i do a derivation like in the instance of the Field in this example?
09:31:26 <nomeata> indeed. What I don’t discover there. symmLayout reminds me of what I did to generate http://www.joachim-breitner.de/blog/archives/276-Descendant-tree-drawing-problem.html (which is haskell, but not diagrams :-))
09:31:54 <bourbaki> Does this expose the same problem as multiple inheritance in C++?
09:32:52 <byorgey> nomeata: oh, nice =)
09:33:06 <nomeata> byorgey: I started looking into this because I wanted a nice demo project for a Haskell talk, but based on gloss. I did also consider diagrams, but I find it not accessible enough for a 1h-talk, with all the lenses and custom operations around.
09:33:26 <byorgey> nomeata: agreed
09:33:41 <typoclass> nomeata: where/when is the talk?
09:34:02 <byorgey> diagrams explicitly sacrifices ease of learning for power, gloss has made the other choice
09:34:06 <byorgey> both are important =)
09:34:07 <bourbaki> And how would i make use of my Field instance now ?
09:34:11 * hackagebot doctest 0.9.5 - Test interactive Haskell examples  http://hackage.haskell.org/package/doctest-0.9.5 (SimonHengel)
09:34:34 <nomeata> byorgey: I thought I’d mention it, due to “although a Haskell-tutorial-via-diagrams is a fun idea and may happen in the future” on http://projects.haskell.org/diagrams/tutorial/DiagramsTutorial.html
09:34:52 <nomeata> typoclass: Tuesday evening, Karlsruhe, http://www.meetup.com/The-Karlsruhe-Functional-Programmers-Meetup-Group/events/93934702/
09:35:34 <byorgey> nomeata: yeah, I still think it could be a fun idea, but would require a lot of careful planning, and it would not be short.
09:35:54 <`nand`> bourbaki: that doesn't look like it would work very well; ‘neutral’ is ambiguous between a bunch of instances, with no way to specify which one you want
09:36:46 <typoclass> nomeata: hm nice. the only times i've ever been to karlsruhe is for the last 3 or 4 gulaschs =)
09:37:13 <nomeata> typoclass: then chances are high that you were attending my Agda talk this year?
09:37:23 <bourbaki_> nand: What would be the correct way then?
09:37:45 <typoclass> nomeata: NO! i missed it. i missed that day of the gulasch :-( i was very unhappy
09:37:52 <`nand`> bourbaki_: depends on what you want to do; and what ‘correct’ means
09:38:11 <typoclass> hm ... 8 hours of trains for 1 hour of talk ... maybe not  :-)
09:38:25 <nomeata> typoclass: where are you from?
09:38:26 <bourbaki_> nand what i want to do is to define a Field structure, which is why i have to add some type over operators.
09:38:30 <typoclass> nomeata: hannover
09:38:43 <bourbaki_> And also there are two different operators over the same type in a field.
09:39:07 <bourbaki_> But both operators in a Field are BinaryOperators.
09:39:14 <nomeata> typoclass: well, if there is a chaos event between 22.12. and 25.12., I can hold the talk again, I’ll be in Hannover at that time
09:40:12 <nomeata> Or alternatively some other time next year, also if you are in academics I never mind holding a guest lecture – ask your prof (if you have one and are not one yourself)
09:41:28 <bourbaki_> Is what i had in mind there at all possible in Haskell? Maybe the scoping is a problem here?
09:42:20 <typoclass> nomeata: heh, i'm not a prof :-) i'll be out of town on christmas (visiting the family). but i'll keep it in mind for next year
09:42:48 <bourbaki_> Even if this was possible the next problem i would get into would be commutative groups or is there so way around that also?
09:43:14 <typoclass> ok see you, guys
09:43:30 <`nand`> bourbaki_: have a look at http://hackage.haskell.org/packages/archive/numeric-prelude/0.3.0.2/doc/html/Algebra-Field.html
09:44:20 <`nand`> http://hackage.haskell.org/packages/archive/numeric-prelude/0.3.0.2/doc/html/Algebra-Additive.html#t:C <- for commutative groups
09:47:30 <fmap> C a => C a...
09:47:41 <bourbaki_> Ah, ...
09:47:47 <bourbaki_> http://hackage.haskell.org/packages/archive/algebra/3.0.1/doc/html/Numeric-Ring-Class.html
09:48:07 <bourbaki_> It works because this implementation does not derive from the same class twice right?
09:48:14 <bourbaki_> Rng and Rig in this case.
09:48:43 <`nand`> I don't know what you mean by ‘derive’
09:49:12 <bourbaki_> The => arrow
09:49:27 <`nand`> that's a context
09:50:01 <bourbaki_> Ok then it works because it does not have the same context twice like i do right?
09:52:41 <`nand`> no
10:04:11 * hackagebot hOpenPGP 0.5.2 - native Haskell implementation of OpenPGP (RFC4880)  http://hackage.haskell.org/package/hOpenPGP-0.5.2 (ClintAdams)
10:07:20 <Clint> solirc: thanks, that did the trick
10:09:30 <fluffynukeit> hi
10:10:35 <byorgey> hi fluffynukeit
10:11:21 <fluffynukeit> is there really as little activity as I am seeing?
10:11:49 <byorgey> fluffynukeit: there is often lots of activity in this channel, but occasionally there are lulls
10:11:57 <byorgey> you happened to enter at a lull
10:12:17 <fluffynukeit> yeah apparently.  I was worried something was wrong on my end
10:12:23 <byorgey> nope =)
10:12:41 <byorgey> fluffynukeit: are you visiting from tryhaskell.org?
10:13:09 <fluffynukeit> no I don't think so.  I came from a link in the wiki
10:13:21 <fluffynukeit> well, I came with a question, so here's hoping you can answer!
10:13:43 <byorgey> oh, ok
10:13:51 <byorgey> yes, feel free to ask questions here
10:14:41 <fluffynukeit> I'm using the Get monad and building up a big Get action
10:15:07 <fluffynukeit> I go from Get Mod to something like Either String [[Mod]]
10:15:14 <fluffynukeit> using runGet and replicateM, etc
10:16:10 <fluffynukeit> my problem is that when there is a failure, I am only getting the error "too few bytes."   What I want to do is somehow annotate this further so that the error is more descriptive
10:16:21 <fluffynukeit> but the monadic short-circuiting is making it a little tricky for me to figure out
10:17:18 <byorgey> this is the Get monad from the binary package?
10:17:34 <fluffynukeit> so my question is, instead of aborting the rest of the action when there is a failure (ie Left), how do I perform operations on the Left result?  yes, this is Get but from Binary Strict
10:18:42 <byorgey> fluffynukeit: if there is a failure do you want to continue parsing?
10:18:59 <byorgey> or you just mean you want to have each subcomputation return a different error message, with more information?
10:19:12 * hackagebot smtp-mail 0.1.2.0 - Simple email sending via SMTP  http://hackage.haskell.org/package/smtp-mail-0.1.2.0 (JasonHickner)
10:20:12 <fluffynukeit> byorgey: I want to in some sense add more information to the error, kind of like a stack trace.  So instead of "too few bytes" I'd be able to annotate it to something like "too few bytes: while generating list 2"
10:20:23 <byorgey> ok, right, makes sense
10:21:03 <byorgey> so do you at some point have, e.g., something of type  [[Either String Mod]]  ?
10:21:51 <byorgey> given an   Either String Mod   you can use   either (++": while generating list 2") id   to add some information to the error message (if it is generated)
10:23:12 <byorgey> then all you have to do is use things like  zipWith [0..]  and so on to pair up the right information with the right parsing actions, and add it to the error messages
10:23:13 <fluffynukeit> byorget: No, my types are Get Mod, Get [Mod], and Get [[Mod]].  I understand your suggested use of either, I have used that previously.  But it requires me to leave the monad
10:23:38 <byorgey> fluffynukeit: but how do you go from  Get Mod  to  Get [Mod], using replicateM ?
10:23:54 <fluffynukeit> yes
10:24:11 <hpaste> “`nand`” pasted “Field” at http://hpaste.org/79238
10:24:13 <byorgey> oh, I see, hmm
10:24:14 <fluffynukeit> and from Get [Mod] to Get [[Mod]] using whileM
10:24:20 <`nand`> bourbaki_: maybe you want something like this? http://hpaste.org/79238
10:24:37 <saati> hi, can i convert something that has record syntax in it to point-free?
10:24:52 <`nand`> saati: lenses
10:24:58 <fluffynukeit> byorgey: maybe it's not possible to do what I'm thinking of...
10:25:00 <`nand`> lenses are the answer :)
10:25:00 <saati> what are lenses?
10:25:24 <`nand`> saati: lenses are, among other things, a way to express record access and update in a functional (point-free) way
10:25:42 <saati> where can i read about them?
10:25:46 <bourbaki_> nand i think that the package you pointed me to earlier is exactly what i need, i am just trying to get myself into it :)
10:25:50 <byorgey> fluffynukeit: you can probably do it by making your own custom monad which consists of a Get action paired with an error message
10:25:58 <`nand`> saati: http://stackoverflow.com/questions/5767129/lenses-fclabels-data-accessor-which-library-for-structure-access-and-mutatio/5769285#5769285
10:26:08 <bourbaki_> I just am not sure if this is the right place to start with Haskell :)
10:26:09 <saati> thank you `nand`
10:26:14 <byorgey> fluffynukeit: it is a bit awkward.
10:27:05 <`nand`> saati: also, https://github.com/ekmett/lens/wiki/Overview
10:27:09 <`nand`> in general, the entire lens/wiki
10:27:49 <byorgey> fluffynukeit: you can still do something like what I suggested.  Note that replicateM is actually a combination of 'sequence' and 'replicate', so you can go from Get Mod  to [Get Mod], then pair them up with custom error messages, inject into your custom monad, and *then* call sequence
10:27:55 <fluffynukeit> byorgey: good suggestion, but I agree awkward.  Would doing runGet and recursion to build up [Either String [Either String Mod]] be the wayt to go?
10:27:56 <bourbaki_> `nand`: What i just still wonder about is if i can inject structure the way i had in mind.
10:28:47 <fluffynukeit> byorgey: or at least your recommendation?  I'm open to refactoring if my current path leads to headaches
10:28:48 <byorgey> fluffynukeit: no, because in order to do that you have to call 'runGet' separately on each of the Get actions, which means they are not sequenced together in any way
10:28:53 <`nand`> oh, my paste can be improved; hang on
10:29:12 * hackagebot themoviedb 0.1.0.0 - Haskell API bindings for http://themoviedb.org  http://hackage.haskell.org/package/themoviedb-0.1.0.0 (PeterJones)
10:29:41 <byorgey> fluffynukeit: that's why I suggested making a custom monad, because you have to make sure that all the Get actions are sequenced together so they work over the entire input.
10:29:52 <byorgey> sorry if I'm being too vague
10:31:28 <fluffynukeit> byorgey: it's not so vague, thanks for your help!  Is there some other approach I could take to avoid these pitfalls altogether?  Some kind of error stack trace seems like a problem that's been solved before.  What about a Writer transformer on top of Get?
10:31:29 <hpaste> “`nand`” annotated “Field” with “Field (annotation)” at http://hpaste.org/79238#a79239
10:33:44 <byorgey> fluffynukeit: a WriterT on top of Get does not work because if the Get fails you lose the Writer log.
10:33:55 <byorgey> you would have to use GetT on top of Writer but I don't think there is a GetT.
10:34:59 <fluffynukeit> byorgey: hmmmm well rats
10:35:19 <byorgey> I think a custom monad adding custom error messages to Get actions is probably the nicest way to go.  But there might be a better way I'm not thinking of.
10:36:44 <fluffynukeit> byorgey: Sounds good to me.  I'm working toward a functioning program but it's all just a big learning exercise essentially.  No time like the present to try it out
10:37:02 <byorgey> fair enough =)
10:37:08 <startling> a GetT would be useful
10:39:03 <fluffynukeit> byorgey: thanks for your help
10:39:26 <byorgey> you're welcome
10:41:09 <bobry> is there a printf for bytestrings anywhere? googling doesn't help much
10:47:36 <bourbaki_> nand thanks alot! :) The sample is gold, and a lot easier to understand than the package.
10:51:11 <startling> byorgey: pdxleif wants to know if you still have the source for the diagram in the typeclassopedia
10:52:28 <pdxleif> Want to extend it with extra stuff.
10:52:28 <byorgey> startling: yes, I think so
10:52:54 <startling> byorgey: cool. :)
10:54:02 <byorgey> pdxleif: http://www.cis.upenn.edu/~byorgey/hosted/dependencies.dot  -- there you go
10:56:10 <bgamari> Hackage is down?
10:57:27 <byorgey> o noes!
10:58:01 <byorgey> seems so
10:58:03 <byorgey> http://www.downforeveryoneorjustme.com/hackage.haskell.org
10:59:24 <`nand`> bourbaki_: it's not exactly as simple as it could be though; you could think away all of the ConstraintKinds/LiberalTypeSynonyms stuff if you want and use “Monoid (Sum Double)” instead of “Additive Monoid Double”
10:59:31 <`nand`> I just thought the latter would sound cooler
10:59:39 <viran> hey... a theoratical question for you, lets say i want to change the k/2k limit of a b tree to a k/2k-x ; what's the range of x? so the tree would function like a regular BTree. any idea?
11:00:33 <bourbaki_> nand :) no its totally cool
11:01:32 <`nand`> bourbaki_: note also the distinction between ‘class’ and ‘type’; I used ‘class’ where a class actually introduced new laws; and ‘type’ where no new laws were introduced that were not covered in the others
11:01:46 <`nand`> that way, you get the ‘type’s for free; if the laws are fulfilled either way
11:01:58 <pdxleif> byorgey: Thanks!
11:02:05 <mewalz> a piece of my code ended up in the following form, has anyone seen something similiar? newtype Foo i o = Foo { runFoo :: i -> (o, Foo i o) }
11:02:16 <elliott> mewalz: yes
11:02:36 <bourbaki_> nand what i still need to have a look at is how they got the distributivity etc in that package, they have this Laws module in there.
11:02:39 <`nand`> mewalz: Automaton
11:02:43 <`nand`> mewalz: see package netwire
11:03:27 <elliott> mewalz: it's a Mealy machine
11:05:56 <bootcode> Hello
11:06:06 <bootcode> do you perceive hackage down too?
11:06:28 <jix> is there a way to teach ghci about what to do to display values that are neither Show a => a nor Show a => IO a?
11:07:28 <elliott> only by giving them a Show instance
11:07:46 <byorgey> bootcode: yes
11:10:56 <fryguybob> jix: You can with 7.6 and -interactive-print
11:12:35 <fryguybob> jix: Details are here: http://www.haskell.org/ghc/docs/7.6.1/html/users_guide/interactive-evaluation.html
11:12:40 <byorgey> ooh, I didn't know about -interactive-print, neato =)
11:13:35 <byorgey> jix: note, however, that there is no way to say "first try using a Show instance, and if there isn't one then use this other thing"
11:16:01 <chexxor_home> I do 'cabal update' and it says 'cabal: timeout' after a long time
11:16:20 <startling> -interactive-print looks really cool
11:16:40 <chexxor_home> now it says 'cabal: <socket: 3>: resource vanished' - Any ideas?
11:16:56 <startling> a "This output is long. Sure you want to print it?" function would be really helpful
11:18:38 <elliott> chexxor_home: hackage is down
11:18:57 <chexxor_home> elliott that's how it appears - thanks for confirming
11:19:11 <chexxor_home> elliott is it often down? will it be down for long?
11:19:31 <elliott> yes and nobody knows :P
11:19:36 <elliott> it usually comes up within a few hours
11:20:31 <chexxor_home> ah, I see - thanks for the insight :)
11:20:42 <bourbaki_> Is there an elegant way to define a fixed lentgh data type? Something like , data Vector dimension scalar = Scalar scalar | Scalar scalar (Vector dimension - 1 scalar) ... or somesuch
11:21:09 <chexxor_home> I'm trying to install Gitit on my Raspberry Pi -- anyone think I'm headed down the path to failure?
11:21:51 <Clint> chexxor_home: yes, you'll need to implement TH on arm
11:23:16 * chexxor_home starts reading about template haskell
11:26:31 <bootcode> is there an automatic way to export makeLenses'd lens for exported datatypes?
11:27:16 <bootcode> for example I have data Foo = Foo { _a :: Int, _b :: String }, use makeLenses ''Foo. Now I must export 'a' and 'b' manually, while for Foo I just use Foo(..)
11:29:15 <jozefg> Wasn't someone planning on writing a book on parallel haskell? I seem to remember readint that
11:29:52 <chexxor_home> Clint: yeah, sounds like you're right :-
11:29:55 <chexxor_home> :(
11:30:25 <Clint> or you could pay someone to do it
11:31:25 <chexxor_home> serious? how does that work? there are bounty-hunters in haskell land?
11:34:11 <`nand`> bootcode: you could put the type and its lenses into a dedicated module that contains only them; then re-export the entire module or something
11:34:44 <merijn> chexxor_home: Well, I think that if people offer on the mailing list to pay for something to be implemented that bounty hunters might suddenly appear, yes :p
11:34:52 <fmap> @where hdiff
11:34:53 <lambdabot> http://hdiff.luite.com/
11:35:22 <merijn> bootcode: I don't think that exists yet, no :\
11:35:40 <lispy> http://www.isup.me/hackage.haskell.org
11:35:40 <merijn> jozefg: That's probably Simon Marlow?
11:35:43 <lispy> hackage is down?
11:35:58 <merijn> jozefg: As he's the parallel/concurrent haskell guru and he said he was finishing a book before march
11:36:09 <jozefg> lispy: It is for me
11:36:14 <bootcode> the separate module approach seems doable for now
11:36:25 <jozefg> merijn: Do you know who's publishing it?
11:37:05 <`Jake`> Is the base ten property of numbers defined in ghc or on a lower level?
11:37:05 <merijn> jozefg: From his departure email: "My plan is to take a break to finish the book on Parallel and"
11:37:08 <merijn> Concurrent Haskell for O'Reilly, before taking up a position at
11:37:08 <merijn> Facebook in the UK in March 2013.
11:37:57 <jozefg> Ok cool thanks, just trying to figure out what books I want to read of winter break this year
11:39:15 <`nand`> when's hackage 2 coming, anyway?
11:40:03 <`nand`> `Jake`: what do you mean, base ten property of numbers?
11:40:22 <`Jake`> `nand`: Int is in base 10, as opposed to hexadezimal or binary
11:40:30 <`nand`> it is?
11:40:35 <`Jake`> s/dezimal/decimal
11:40:41 <`nand`> how so?
11:41:00 <`Jake`> Well, showing a value returns a decimal number
11:41:06 <`nand`> oh, you mean Show
11:41:12 <`Jake`> e.g.
11:42:51 <`Jake`> Read as well
11:44:24 <`nand`> it doesn't seem to be mentioned in Haskell
11:45:26 <`Jake`> So that means it's probably defined on a lower level?
11:45:32 <merijn> `Jake`: That "property" is just the implementation of Read/Show...
11:46:09 <cmccann> > read "0x10" :: Int
11:46:10 <`nand`> `Jake`: it means it's a design choice made by GHC
11:46:11 <lambdabot>   16
11:46:32 <cmccann> base ten, pf.
11:46:34 <`nand`> `Jake`: that said; numerical literals are defined to be decimal (by default) by Haskell
11:46:57 <`nand`> so that much is unambiguous; it's just the behavior of Read/Show that's not accurately defined
11:47:36 <`Jake`> Ok, I think I got it, thank you
11:47:42 <cmccann> clearly read and show ought to use unary by default.
11:47:48 <hiptobecubic> yes
11:47:58 <`nand`> "Succ (Succ (Succ (Succ (Succ (Succ (Succ (Succ (..."
11:48:04 <lispy> http://new-hackage.haskell.org <-- I believe that's the new url, but it seems to be down
11:48:37 <`Jake`> Floats in unary would be a little weird
11:49:13 <`Jake`> But certainly possible
11:49:34 <cmccann> fractional numbers could use a repeating fraction form, I suppose.
11:49:52 <cmccann> that would be sensible.
11:50:04 <hiptobecubic> could they? how would you express 1/2 in unary?
11:50:29 <hiptobecubic> i guess you could have a Ratio-style representation
11:50:47 <`Jake`> And you can't define irrationals anyway
11:50:57 <hiptobecubic> Succ (Nil) % Succ (Succ (Nil))
11:51:03 <cmccann> er, I mean continued fraction. why did I say repeating?
11:51:06 <`nand`> `Jake`: how so? I mean; the obvious extension of unary literals (eg. 1111 ⇔ 1·1³ + 1·1² + 1·1¹ + 1·1^0) doesn't make much sense for fractions; 1·1^-1 + 1·1^-2 + ...
11:51:11 <orospakr> hi, I have a silly question: what is ">>?" called, and where would I normally go to look such things up? (such syntax not being very googlable, of course)
11:51:35 <hiptobecubic> `nand`, that's what i mean
11:51:39 <cmccann> @hoogle (>>)
11:51:39 <lambdabot> Prelude (>>) :: Monad m => m a -> m b -> m b
11:51:40 <lambdabot> Control.Monad (>>) :: Monad m => m a -> m b -> m b
11:51:40 <lambdabot> Control.Monad.Instances (>>) :: Monad m => m a -> m b -> m b
11:52:05 <hiptobecubic> orospakr, it's called "Bind but throwaway the input"
11:52:10 <hiptobecubic> throw away*
11:52:12 <`nand`> we had this discussion yesterday
11:52:16 <`nand`> it's called “swoosh”, or something
11:52:29 <`nand`> actually I think that was >>=
11:53:12 <orospakr> cmccann, ahh, I see. clever! still, why am I seeing a question mark adjacent to it in http://book.realworldhaskell.org/read/monads.html, however?
11:53:36 <cmccann> orospakr, that's defining its own operator
11:53:40 <`nand`> orospakr: because that's not >>
11:53:41 <hiptobecubic> swoosh?
11:53:54 <`nand`> hiptobecubic: (it was a joke)
11:54:02 <`Jake`> sounds like something philip wadler said
11:54:25 <orospakr> aha, I see now.
11:54:26 * cmccann proposes calling (<<) "a jump to the left" and (>>) "a step to the right"
11:54:29 <orospakr> thank you. :)
11:54:35 <`nand`> a small step for a monad
11:54:53 <elliott> ouch!
11:54:57 <fmap> there is no (<<)
11:55:03 <elliott> the new hashable apparently makes HashMap's toList impure
11:55:05 <elliott> this is terrible
11:55:09 <`nand`> elliott: what
11:55:13 <`nand`> that is awful
11:55:21 <elliott> `nand`: because it uses a different salt on each program run
11:55:30 <cmccann> fmap, there isn't? hunh. was probably thinking of (<*) or something, nevermind.
11:55:30 <elliott> so the results are different
11:55:31 <`nand`> ah
11:55:49 <elliott> main = print foo  -- can print different things over multiple runs!
11:55:57 <`nand`> yuck
11:56:18 <cmccann> elliott, I bet you love maxBound :: Int then
11:56:25 <`nand`> can't they have used a context or something to pipe along the hash value; and have the programmer generate it in main instead of unsafePerformIO'ing?
11:56:31 <`nand`> seems like a use case for the configuration problem
11:56:59 <elliott> `nand`: well, a context which then affects every single library that uses hashing
11:57:08 <elliott> reflection would work for this purpose, agreed
11:57:14 <elliott> does unordered-containers even depend on fundeps though?
11:57:15 <`nand`> elliott: it's not that simple
11:57:31 <`nand`> elliott: eg. consider the case when something like acid-state serializes it to disk
11:57:47 <`nand`> elliott: something like reflection which uses rank-2 types to prevent the unique hashing parameter from escaping or something could be invaluable
11:57:54 <elliott> cmccann: maxBound doesn't change unless you recompile your program etc.
11:58:00 <elliott> cmccann: I'm not too fond of Int but this is something completely different
11:58:03 <`nand`> (of course, I'm not sure if that would cover the acid-state case)
11:58:24 <elliott> well, you can build such a safe interface with the reflection package
11:58:35 <cmccann> elliott, this at least seems not much worse than lazy IO
11:58:37 <elliott> you just reflect a rank-2 function instead
11:58:38 <`nand`> yeah that was the idea
11:58:42 <cmccann> which I'm not a fan of mind you
11:58:42 <`nand`> ah
11:59:14 <elliott> cmccann: I think it is much worse. Lazy IO at least you get the "same results" even if the effects are driven by evaluation.
11:59:16 * `nand` agrees, he wouldn't want his hashtables being incompatible in unexpected ways across borders
11:59:26 <elliott> This essentially ruins repeatability/composition/whatever of Haskell programs that use hashing
11:59:28 <`nand`> agrees with elliott, that is
11:59:50 <elliott> like, if you had a mini stateless haskell interpreter program it shouldn't matter whether you fork a new ghc interpreter for each line or not
11:59:53 <elliott> but now it does
12:00:07 <cmccann> elliott, I think you can contrive similar stuff using unsafeInterleaveIO but not in normal use scenarios that is true
12:00:10 <elliott> also what if there is a bug in unordered-containers? programs will become nondeterministically broken!
12:00:17 <elliott> you will have bugs that you can't repeat because it picks a different seed when you try
12:00:24 <cmccann> anyway yeah, just playing devil's advocate here
12:00:39 <elliott> yeah, I realise
12:00:56 <elliott> we have things that are similarly bad but I think this has worse effects, especially since hashing is ubiquitous
12:01:12 <cmccann> this sounds more likely to cause problems when used in sensible ways
12:01:23 <elliott> I hope something is done about this beyond just the cabal flag it has to not use this broken behaviour (useless since it won't be enabled when hashable gets pulled in as a dependency and you can't depend on flags)
12:01:42 <elliott> otherwise I suspect we'll end up with some horrific split hackage with two hashing packages and forks of unordered-containers and the like
12:03:09 * cmccann waits for when elliott staples his 95 theses to hackage's front door
12:03:49 <elliott> haha
12:04:33 <elliott> cmccann: don't be ridiculous, 95 isn't a nice round number. it'll be 64
12:04:57 <cmccann> 95 is the traditional number though.
12:05:03 <cmccann> historically speaking, it tends to work.
12:05:15 * elliott is an innovator
12:05:33 <cmccann> (for anyone who doesn't know what I'm referring to: http://en.wikipedia.org/wiki/The_Ninety-Five_Theses )
12:05:58 * elliott knew
12:06:04 <cmccann> I realize you did :P
12:06:12 <cmccann> and yes you have a point, 64 is a much nicer number
12:06:14 * elliott realises you realise he did!
12:06:41 * cmccann realizes the fixed point of the obvious pattern
12:07:10 <cmccann> and also realises I guess
12:07:15 <cmccann> both ought to apply to the fixed point
12:07:24 <singpolyma> Does anyone know what's up with hackage?
12:07:44 * cmccann knows what's not up with hackage
12:07:55 <cmccann> namely, itself
12:08:50 <neutrino_> why is hackage dropping dead so often?
12:08:59 <neutrino_> this crucial resource needs at least five nines
12:09:13 <fmap> it helps to avoid success
12:10:00 * neutrino_ table flip
12:10:34 <cmccann> > flip table
12:10:35 <lambdabot>   Not in scope: `table'
12:10:37 <cmccann> :[
12:11:56 <catsbydlo> hackage has at least 9 fives
12:12:33 <cmccann> that's almost the same thing I suppose
12:12:57 <neutrino_> catsbydlo: >_<
12:13:31 <byorgey> it's exactly the same thing, by commutativity of multiplication
12:13:44 <cmccann> hooray!
12:14:16 <cmccann> it seems byorgey has solved the hackage uptime issue algebraically, excellent
12:14:33 <byorgey> math ftw!
12:17:43 <neutrino_> byorgey: that is amazing
12:17:55 <neutrino_> tell me more /me dewy eyes
12:18:14 <cmccann> elliott, the more I think about it the more that hashing thing sounds horrible. even aside from the purity issue on which there is apparently disagreement, that sort of thing is murder for repeatability in testing :[
12:18:20 <cmccann> sigh.
12:19:01 <hiptobecubic> doesn't it defeat the several of the main reasons for hashing something?
12:19:11 <hiptobecubic> like equality testing?
12:19:18 <elliott> cmccann: yup
12:19:32 <nejucomo> Is hackage down?
12:19:36 <elliott> cmccann: I guess I can install it with -fnot-brokenly-impure or whatever and just sadly tell people they have to do this if they run into problems
12:19:40 <elliott> but it will suck
12:19:42 * cmccann is finally reading the reddit thread
12:19:49 <chrstphrhrt> hey this is kind of a funny topic, but would anyone say there are common elements of the haskell developer "culture"? for example our local python user group is very into nice beer, and also a spirit of teaching each other rather than showing off too much
12:20:11 <cmccann> apparently augustss is determined to write his own hashtable package now, heh
12:20:20 <startling> chrstphrhrt: definitely
12:20:29 <hiptobecubic> your local python group is much better than #python then
12:20:32 <chrstphrhrt> we're going to be starting a haskell user group in the new year but don't know much about the existing community yet
12:20:41 <startling> hiptobecubic: huh?
12:20:46 <chrstphrhrt> hiptobecubic: haha, yeah
12:21:09 <startling> hiptobecubic: I mean, I'm fine with complaining about #python but "showing off" is like the last thing they do
12:21:28 <nejucomo> Is it really possible to generalize the community before just meeting with locals for a while?
12:21:49 <hiptobecubic> sure
12:21:52 <chrstphrhrt> startling: well i've seen some silly ego battles in #python.. but in general there are helpful folks
12:21:57 <hiptobecubic> "relatively Small"
12:22:00 <nejucomo> I can say that all of the haskelleers I've met in real life are also into good beer.  ;-)
12:22:09 <nejucomo> -but that's about 3 people.
12:22:13 * lispy isn't sure what 'showing off' looks like with programming
12:22:18 * byorgey is into good beer
12:22:18 <lispy> Of course people like to make cute examples
12:22:22 <startling> lispy: it looks like @pl
12:22:29 <cmccann> chrstphrhrt, the haskell community tends to be full of people who enjoy explaining things to anyone who'll listen, and are prone to abstraction golfing the most generic-yet-rigorous ways to do mundane things
12:22:34 <hiptobecubic> lispy, it's like what people do in here when they start humping lambdabot, but somehow bad
12:22:43 <chrstphrhrt> nejucomo: obviously local is the best and only real start.. just wanted to probe a bit if haskellers (is that what they're called?) share some hobbies or whatever outside of their shared interest in the language
12:23:03 <chrstphrhrt> cmccann: haha cool
12:23:03 <startling> cmccann: "abstraction golfing" is a good phrase
12:23:08 <elliott> full of people who enjoy explaining things in ten different ways simultaneously :P
12:23:15 <startling> chrstphrhrt: we like math.
12:23:15 <hiptobecubic>  arguing about operator syntax?
12:23:18 <`nand`> chrstphrhrt: where are you situating your HUG?
12:23:29 <cmccann> splitting hairs over semantics in defining terms is also popular
12:23:34 <`nand`> ^
12:23:43 <nejucomo> I think other english speakers might say "haskellers", but I like "haskelleers".  ;-)
12:23:44 <cmccann> chrstphrhrt, many (though not all) haskell programmers develop an interest in math after spending some time with haskell
12:23:51 <`nand`> a regional pastime is trying to define things in ways that shachaf would approve
12:23:58 <hiptobecubic> cmccann, i can attest to that
12:24:01 <cmccann> far more than actually know obscure math before learning haskell
12:24:12 <nejucomo> hehe...
12:24:19 <chrstphrhrt> `nand`: montreal
12:24:42 <dblhelix> nejucomo: because it's like "musketeers"?
12:24:57 <hiptobecubic> looks like a dutch word to me
12:25:10 <nejucomo> I can make connections to hackage.haskell.org's http port, and "send" a GET request, but it hangs on the respose.
12:25:16 <nejucomo> s/respose/response/
12:25:20 <hiptobecubic> i guess the double 'l' ruins it
12:25:22 <`nand`> chrstphrhrt: we like lenses, and so should you :)
12:25:50 <startling> cmccann: definitely
12:25:55 <nejucomo> Or buccaneers.
12:26:05 <`nand`> @yarr
12:26:05 <lambdabot> Well me 'earties, let's see what crawled out of the bung hole...
12:26:11 <chrstphrhrt> have definitely been reviving interest in math since starting haskell tutorials
12:26:16 <dblhelix> hiptobecubic: doesn't strike me as dutch
12:26:27 <startling> haaskell
12:26:41 <cmccann> chrstphrhrt, but otherwise I don't think haskellers are that different from programmers with similar backgrounds elsewhere. the "good beer" thing, f'rinstance, is pretty common
12:26:43 <hiptobecubic> haskeleers is better
12:26:50 <`nand`> Haaskell is the name of my local haskell group; because the only two people in it have the last name Haas :)
12:26:58 <chrstphrhrt> cmccann: right, figured as much
12:27:06 <t7> heh
12:27:23 <t7> mine is pretty lonely too
12:27:30 <nejucomo> hiptobecubic: Agreed.
12:27:50 <dblhelix> cmccann: although, of course, they like their beers strongly typed
12:27:51 <cmccann> startling, oh and yeah "abstraction golfing" is a phrase I coined a while back but nobody else seems to have taken it up :[
12:27:56 <hiptobecubic> `nand`, who's the other guy?
12:28:05 <startling> cmccann: I will!
12:28:06 <hiptobecubic> cmccann, it's good.
12:28:07 <chrstphrhrt> cmccann: also half-suspected some more fancy wine-lovers or something considering the academic roots
12:28:26 <startling> haskellers probably like microbrew and foreign beers
12:28:27 <`nand`> hiptobecubic: a friend from school; he isn't active in the Haskell community, nor on freenode
12:28:29 * nejucomo commits "abstraction golfing" to memory.
12:28:33 <chrstphrhrt> yay "abstraction golfing"
12:28:44 * cmccann drinks microbrews, imports (mostly belgian), and single malt scotch
12:29:15 * dblhelix will perhaps play some abstraction golf this weekend
12:29:22 * hiptobecubic drinks "wine" from a cardboard box on the bottom shelf at the store
12:29:23 <shachaf> hi `nand`
12:29:24 <`nand`> cmccann: I like “premature abstraction is the greatest source of procrastination”
12:29:36 <chrstphrhrt> haha
12:29:39 <cmccann> haha
12:29:43 <startling> hiptobecubic: haha
12:29:54 <dblhelix> `nand`: ha
12:30:25 <shachaf> cmccann: I'd rather have my messages lost than use the @ idiom!
12:30:44 <startling> :t (@)
12:30:45 <lambdabot> parse error on input `@'
12:30:50 <chrstphrhrt> somehow my impression of haskell so far is that it wants to be less abstract than anything OO.. types feel more.. "real"
12:30:53 <cmccann> shachaf, sorry, that's how it works on SO :P
12:31:25 <hiptobecubic> chrstphrhrt, if by real you mean "meaningful" then maybe
12:31:28 <shachaf> cmccann: What's how it works? You don't have an option between your messages getting lost and using @?
12:31:35 <shachaf> It appears to me that I have an option.
12:31:48 <c_wraith> chrstphrhrt: it's less abstract in some ways, more abstract in others.  Types are more concrete - but much greater polymorphic abstractions are possible
12:31:49 <cmccann> shachaf, it's specifically "@name" that triggers the inbox notification in the general case
12:32:05 <cmccann> shachaf, some specific cases also do (only one other person commenting, the author of the post always gets notified, &c.)
12:32:06 <chrstphrhrt> hiptobecubic: yeah I guess "meaningfulness" is closer to the feeling
12:32:07 <`nand`> chrstphrhrt: I personally get the impression that functional programming is particularly keen on ‘representing things the way they are’; eg. by being able to store something like a function as you would any old value
12:32:29 <`nand`> instead of needing wrappers or workarounds to associate functions with values
12:32:32 <neutrino_> chrstphrhrt: you're basically talking about dynamic dispatch. it's a feature of class-oriented languages which makes code confusing and makes working with it very indirect.
12:32:42 <aristid> hackage down, or just shitty internet on my end?
12:32:46 <`nand`> aristid: down
12:32:47 <startling> it's down
12:32:48 <neutrino_> hackage down
12:32:57 <pharaun_> D:
12:32:59 <startling> aristid: hackage is down
12:33:05 <hiptobecubic> Does anyone remember that great quote about design patterns in OOP being abused? Something like abstraction but keeping all the boilerplate?
12:33:08 <cmccann> hackage is down like a thing that is not up in any way
12:33:13 <startling> indeed
12:33:23 * aristid cries (yeah i know about luite's mirror :P)
12:33:49 <`nand`> hiptobecubic: I just remember “design patterns are unabstracted abstractions”
12:33:59 <nus> new-hackage.haskell.org
12:34:14 <hiptobecubic> `nand`, that sounds like it, only not as well delivered
12:34:22 <hiptobecubic> maybe i'm just romanticizing
12:34:23 <aristid> nus: does not load either?
12:34:24 <`nand`> @quote design.patterns
12:34:25 <lambdabot> PeterOtten says: [re: design patterns] When most of your code does nothing in a pompous way that is a sure sign that you are heading in the wrong direction.
12:34:33 <navaati> grmbl, hackage down, what does happen ?
12:34:33 <lambdabot> navaati: You have 2 new messages. '/msg lambdabot @messages' to read them.
12:35:20 <nus> aristid, hm, seems so, the front page was cached locally
12:35:52 <`nand`> how much space and dedication would it take to conceivably run my own hackage mirror; for future redundancy? (cc luite)
12:36:35 <nus> eh, n-h.h.o and h.h.o have the same ip
12:37:03 <aristid> hackage is hosted at galois?
12:37:09 <`nand`> I think so
12:37:11 <aristid> so down for the weekend i guess *sigh*
12:37:34 <chrstphrhrt> haha so design patterns are "pompous"… they do seem to fill a space between the descriptive (the code) and normative (how the code ought to be).. which seems a bit silly and likely to cause more indirection
12:37:47 <Saizan> i think they moved it to some virtual server service
12:38:29 <chrstphrhrt> …which leads to the curiosity: is there "idiomatic" haskell? or is that a non-thing considering that expressing mathematical stuff doesn't really rely on best practices (e.g. patterns)
12:38:40 <`nand`> idioms are a subjective thing
12:38:43 <hiptobecubic> a lot of design patters seem specifically made to deal with shitty warts in java
12:38:45 <`nand`> that said; there certainly is more or less idiomatic haskell
12:38:56 <`nand`> (depending on who you ask, this may differ)
12:39:03 * cmccann remains amused that the entire purpose of the visitor pattern is to reinvent functionality that GHC writes for you and takes a line or two to use in Haskell
12:39:04 <hiptobecubic> Design Patterns, not design patterns.
12:39:40 <aristid> design patterns without capital latters do exist in haskell. they do not deal with shitty warts in java though.
12:39:50 <hiptobecubic> I never really understood the issue with it. How is it different from just a function that takes, for example, a struct?
12:39:52 <`nand`> What's the haskell equivalent to the visitor pattern? (I have no idea what the visitor pattern is)
12:40:06 <Saizan> folds, afaiu
12:40:09 <cmccann> `nand`, Traversable, give or take.
12:40:12 <tomeo> If I have a function p fs = map map fs, is this equivalent to p fs = map (map fs) ?
12:40:14 <hiptobecubic> the visitor pattern "allows you to add functionality to a class without modifying the class" or something
12:40:25 <`nand`> tomeo: no
12:40:28 <`nand`> tomeo: (map map) fs
12:40:51 <cmccann> it's 1) doing what algebraic data types do easily and 2) traversing structures built that way
12:41:01 <`nand`> forget I asked
12:41:04 <`nand`> this is sounding too complicated already
12:41:08 <tomeo> `nand`: so the first map gets the second map as a function? and the second map gets fs?
12:41:09 <alex-shpilkin> hiptobecubic: the visitor pattern lets you have double dispatch without really having double dispatch, no?
12:41:15 <navaati> :i Traversable
12:41:24 <`nand`> tomeo: the first map maps ‘map’ over ‘fs’
12:41:27 <navaati> @info Traversable
12:41:27 <lambdabot> Traversable
12:41:30 <`nand`> tomeo: where ‘fs’ would be a list; if this type checks
12:41:38 <tomeo> ah okay thanks
12:41:44 <`nand`> a list of functions
12:41:49 <navaati> lambdabot, how do you do ":i" please ?
12:41:50 <`nand`> :t map map
12:41:51 <lambdabot> [a -> b] -> [[a] -> [b]]
12:41:56 <hiptobecubic> alex-shpilkin, apparently
12:42:12 <Saizan> navaati: it doesn't
12:42:23 <navaati> really ? how sad
12:42:30 <cmccann> lambdabot's @info command remains hilariously useless
12:42:42 <`nand`> @info do { a <- b; c a }
12:42:42 <lambdabot> b >>= \ a -> c a
12:42:43 <tomeo> `nand`: how is it you know that fs is a list and not a function?
12:42:47 <cmccann> @src Traversable
12:42:48 <lambdabot> class (Functor t, Foldable t) => Traversable t where
12:42:48 <lambdabot>     traverse    :: Applicative f => (a -> f b) -> t a -> f (t b)
12:42:48 <lambdabot>     sequenceA   :: Applicative f => t (f a) -> f (t a)
12:42:48 <lambdabot>     mapM        :: Monad m => (a -> m b) -> t a -> m (t b)
12:42:48 <lambdabot>     sequence    :: Monad m => t (m a) -> m (t a)
12:42:59 <`nand`> tomeo: because I know the type of ‘map’; and thus ‘map map’
12:43:29 <lispy> :t map map
12:43:31 <lambdabot> [a -> b] -> [[a] -> [b]]
12:44:35 <simpson> :t map . map
12:44:37 <lambdabot> (a -> b) -> [[a]] -> [[b]]
12:45:38 <navaati> traverse is a generalization of fold, is it ?
12:45:47 <ericbmerritt> is there any way to test failure modes that will throw an exception? that is you generate invalid data to test that it does indeed throw an exception as expected
12:45:54 <`nand`> navaati: they're similar
12:46:30 <`nand`> navaati: folds are more general than traversals though; every traversal is a fold but not vice versa
12:46:40 <cmccann> traverse is a generalization of mapM
12:47:21 <cmccann> which is sequence + map. so it's a fold as much as sequence is.
12:52:15 <`nand`> :t getConst . traverse Const
12:52:17 <lambdabot> (Traversable t, Monoid b) => t b -> b
12:55:04 <elliott> :t (^.traverse)
12:55:05 <lambdabot> (Traversable t, Monoid a) => t a -> a
12:55:08 <elliott> :t view traverse
12:55:10 <lambdabot> (Traversable t, Monoid a, MonadReader (t a) m) => m a
12:55:17 <elliott> right
12:55:18 <shachaf> @ty ($ []) . appEndo . getConst . traverse (Const . Endo . (:))
12:55:20 <lambdabot> Traversable t => t a -> [a]
12:55:23 <elliott> > view traverse [Sum 1, Sum 2, Sum 3
12:55:24 <elliott> > view traverse [Sum 1, Sum 2, Sum 3]
12:55:24 <lambdabot>   <hint>:1:35: parse error (possibly incorrect indentation)
12:55:26 <lambdabot>   Sum {getSum = 6}
12:55:37 <shachaf> > ($ []) . appEndo . getConst . traverse (Const . Endo . (:)) $ [1,2,3,4]
12:55:39 <lambdabot>   [1,2,3,4]
12:55:41 <elliott> > [Endo (+1), Endo (*2)] ^. traverse $ 123
12:55:43 <lambdabot>   The first argument of ($) takes one argument,
12:55:43 <lambdabot>  but its type `Data.Monoid.En...
12:55:52 <`nand`> :t (runIdentity.) . traverse . (Identity .) -- without lenses, for illustratory purposes
12:55:53 <lambdabot> Traversable t => (a -> b) -> t a -> t b
12:56:02 <elliott> > [Endo (+1), Endo (*2)] ^. traverse . unwrapping Endo $ 123
12:56:04 <lambdabot>   Ambiguous type variable `a0' in the constraints:
12:56:04 <lambdabot>    (GHC.Num.Num a0)
12:56:05 <lambdabot>      a...
12:56:05 <`nand`> :t over traverse
12:56:06 <lambdabot> Traversable t => (a -> b) -> t a -> t b
12:56:08 <elliott> > [Endo (+1), Endo (*2)] ^. traverse . unwrapping Endo $ 123 :: Int
12:56:10 <lambdabot>   No instance for (Data.Monoid.Monoid GHC.Types.Int)
12:56:10 <lambdabot>    arising from a use of...
12:56:13 <elliott> what
12:56:23 <elliott> > [Endo (+1), Endo (*2)] ^. traverse . wrapping Endo $ 123 :: Int
12:56:25 <lambdabot>   Couldn't match expected type `Data.Monoid.Endo a0'
12:56:25 <lambdabot>              with actual...
12:56:30 <shachaf> let l = traverse in (runIdentity .) . l . (Identity .) -- with lenses, for illustratory purposes.
12:56:43 <`nand`> shachaf: haha
12:57:12 <elliott> :t traverse . wrapping Endo
12:57:13 <lambdabot> (Functor (k (Endo a -> f (Endo a))), Applicative f, Traversable t, Isomorphic k) => k (Endo a -> f (Endo a)) (t (a -> a) -> f (t (a -> a)))
12:57:15 <elliott> :t traverse . unwrapping Endo
12:57:17 <lambdabot> (Functor (k ((a -> a) -> f (a -> a))), Applicative f, Traversable t, Isomorphic k) => k ((a -> a) -> f (a -> a)) (t (Endo a) -> f (t (Endo a)))
12:57:26 <cmccann> now that's what I call a type signature!
12:58:03 <elliott> :t view (traverse . unwrapping Endo)
12:58:05 <lambdabot> (Traversable t, Monoid a, MonadReader (t (Endo a)) m) => m (a -> a)
12:58:09 <mreh> what's the word on hackage?
12:58:22 <`nand`> what's the name for (^.) again
12:58:42 <shachaf> The name is (^.).
12:58:44 <elliott> view
12:58:44 <alex-shpilkin> :t (^.)
12:58:46 <lambdabot> s -> Getting a s t a b -> a
12:58:52 <alex-shpilkin> ouch
12:58:59 <cmccann> getting a stab
12:59:01 <mreh> hackage is down for everyone else, yes?
12:59:05 <cmccann> yes
12:59:11 <mreh> oh good
12:59:16 <cmccann> no not good
12:59:17 <cmccann> :[
12:59:37 <alex-shpilkin> http://www.downforeveryoneorjustme.com/hackage.haskell.org
12:59:50 <elliott> :t (^. traverse . unwrapping Endo)
12:59:50 <mreh> wasn't it hosted by dons at some point?
12:59:51 <lambdabot> (Traversable t, Monoid a) => t (Endo a) -> a -> a
12:59:53 <shachaf> Let's put it in the topic.
12:59:57 <elliott> so why is there a Monoid a constraint
12:59:57 <shachaf> Wait, it won't help.
12:59:58 <mreh> yes please
13:00:02 --- mode: ChanServ set +o monochrom
13:00:04 <tomeo> I'm trying to understand what a constructor is in Haskell. More specifically the difference between a type constructor and a data constructor, but both the examples here are identical. http://www.haskell.org/haskellwiki/Constructor
13:00:05 <mreh> why not?
13:00:08 <elliott> is it trying to use the monoid instances on function because unwrapping Endo comes last
13:00:14 <shachaf> mreh: Because nobody reads the topic.
13:00:15 --- topic: set to '["hackage down","Haskell Platform 2012.4: http://bit.ly/Clv5r ","GHC 7.6.1 http://v.gd/CEBRVo ","Paste code/errors: http://hpaste.org/new/haskell ","Haskell News: http://reddit.com/r/haskell ","The Haskell programming language http://haskell.org ","Logs: http://bit.ly/5mwtRQ "]' by monochrom
13:00:15 <mreh> everyone reads the topic
13:00:20 <mreh> lol
13:00:26 --- mode: monochrom set -o monochrom
13:00:30 <mreh> I read it before I asked
13:00:38 <monochrom> just got wind from haskell-cafe
13:01:01 <cmccann> tomeo, type constructors construct types and data constructors construct data
13:01:11 <cmccann> not sure what else to say about it
13:01:23 <catsbydlo> data Maybe a = Nothing | Just a
13:01:29 <catsbydlo> type constructor: Maybe
13:01:34 <catsbydlo> data constructor: Nothing, Just
13:01:35 <bobry> Can somebody help me with attoparsec? I'm trying to write a parser for simple arithmetic expression. Current version seems to suffer from infinite recursion on 'a + b'-like inputs :(  https://gist.github.com/862436ae1a7d98b90bbf
13:01:43 <nejucomo> I also read the topic before I asked about hackage being down about an hour ago.
13:01:43 <tomeo> cmccann: isnt the type constructor type Something = something and a data constructor data Something = something?
13:01:52 <cmccann> tomeo, no
13:01:56 <nejucomo> (But I usually don't and remembered to check it.  ;-)
13:01:56 <shachaf> I didn't bother reading the topic, I just assumed it was down.
13:02:05 <cmccann> tomeo, see catsbydlo's example
13:02:12 <mreh> who hosts it?
13:02:19 <shachaf> Galois?
13:02:25 <mreh> tht's what I thought
13:02:38 <mreh> dons aint here
13:02:44 <tomeo> catsbydlo: so the left side of the equals sign is the type constructor and the right side is the data constructor?
13:03:00 <monochrom> Galois is not married to dons
13:03:06 <mreh> but dons is
13:03:10 <shachaf> dons doesn't work at Galois
13:03:15 <mreh> oh
13:03:16 <catsbydlo> tomeo: no, "data Maybe a" is not a constructor
13:03:18 <cmccann> he used to
13:03:18 <shachaf> And when he did, he still was a distinct entity from Galois
13:03:19 <elliott> :t view (unwrapping Endo) . view traverse
13:03:21 <lambdabot> (Functor f, Traversable t, MonadReader (t (Endo a)) f) => f (a -> a)
13:03:26 <catsbydlo> tomeo: "Maybe" is
13:03:27 <elliott> is there a nicer way to write this
13:03:53 <mreh> he is able to do more about fixing hackage than me I would assume, if he worked for galois still
13:04:25 <size_2_shoes> Hey, can you put guards in a where clause?
13:04:27 <shachaf> review (Wrapping Endo)
13:04:31 <`nand`> elliott: re: your earlier question; instance Monoid b => Monoid (a -> b) -- Defined in `Data.Monoid'
13:04:35 <shachaf> Clearly!
13:04:39 <elliott> `nand`: yeah
13:04:54 <elliott> shachaf: I mean avoiding the view l . view m
13:04:55 <shachaf> @ty view (traverse . unwrapping Endo)
13:04:56 <lambdabot> (Traversable t, Monoid a, MonadReader (t (Endo a)) m) => m (a -> a)
13:05:06 <shachaf> s/W/w/, by the way.
13:05:21 <cmccann> size_2_shoes, you can put them on definitions in a where clause the same way you can at top-level
13:05:54 <jmcarthur> :t view traverse
13:05:56 <lambdabot> (Traversable t, Monoid a, MonadReader (t a) m) => m a
13:06:01 <jmcarthur> :t view (unwrapping Endo)
13:06:02 <lambdabot> MonadReader (Endo a) m => m (a -> a)
13:06:06 <hpaste> me pasted “guards in where” at http://hpaste.org/79241
13:06:17 <jmcarthur> :t pure id
13:06:18 <lambdabot> Applicative f => f (a -> a)
13:06:27 <jmcarthur> is it different from that? ^^
13:06:30 <shachaf> Yes.
13:06:36 <`nand`> :t view (traverse . to Endo)
13:06:38 <lambdabot> (Traversable t, MonadReader (t (a -> a)) m) => m (Endo a)
13:06:45 <shachaf> jmcarthur: Please examine the constraint more carefully. :-)
13:06:54 <size_2_shoes> So, can you do guards in a way similar to how I pasted?  http://hpaste.org/79241   (I'd like to know if it's my syntax that's screwed up, or the whole idea)
13:06:55 <jmcarthur> i realize there were more constraints
13:06:57 <`nand`> oh, other way around
13:07:00 <`nand`> :t view (traverse . from Endo)
13:07:01 <lambdabot>     Couldn't match expected type `AnIso b0 a0 b1 a1'
13:07:01 <lambdabot>                 with actual type `(a2 -> a2) -> Endo a2'
13:07:01 <lambdabot>     In the first argument of `from', namely `Endo'
13:07:04 <`nand`> :(
13:07:04 <coleman-> can someone recommend me a database library that is a bit higher level than hdbc?  in which you don't interact with the database by manually constructing and sending SQL strings
13:07:05 <shachaf> view (unwrapping Endo) :: Endo a -> a -> a
13:07:35 <shachaf> elliott: Did you hear about the great contains change of yesterday?
13:07:46 <mreh> coleman-: acid-state?
13:07:58 <SwashBuckla> hi there, I'd like to be able to use HPC to view my test coverage of a multi-module program, but it seems like quickCheckAll requires all of my properties to be in the same file I'm running do $(quickCheckAll) from. Is there a way to produce a HPC report for a multi-module program using quickCheckAll?
13:08:03 <mreh> an ACID database written purely in haskell
13:08:05 <`nand`> coleman-: persistent?
13:08:20 <coleman-> thanks I'll check them out
13:08:21 <mreh> `nand`: I would find out about that but hackage is down
13:08:23 <mreh> what is it?
13:08:29 <mreh> sounds interesting
13:08:38 <jmcarthur> shachaf: Endo a -> a -> a  still just looks like  id  plus newtype wrapping
13:08:48 <cmccann> size_2_shoes, I don't see anything wrong with it as such, though I'm not sure why you'd use guards like that instead of just "func 0 = ..." and such
13:08:50 <`nand`> mreh: SQL library that constructs your queries in a type safe way; that's all I know (from the description)
13:08:56 <`nand`> only heard about it earlier today myself
13:08:59 <shachaf> jmcarthur: That's exactly what it is.
13:09:01 <elliott> shachaf: nope, I didn't
13:09:11 <e98> hackage down?
13:09:13 <mreh> yes
13:09:16 <mreh> read the topic
13:09:23 <mreh> :)
13:09:24 <shachaf> mreh: See?
13:09:26 <shachaf> elliott: It's great!
13:09:29 <neutrino> i have a question
13:09:30 <size_2_shoes> well, I need more complicated checks, but that's the idea
13:09:32 <elliott> shachaf: view (traverse . unwrapping Endo) is wrong
13:09:38 <elliott> it has a Monoid a constraint because it uses the Monoid (->) instance
13:09:40 <neutrino> is higher-rank polymorphism the same as rank-n polymorphism?
13:09:49 <e98> mreh: I did actually think this should be put in the topic
13:09:49 <byorgey> neutrino: yes
13:09:59 <neutrino> thank you byorgey
13:10:00 <e98> mreh: wanted to suggest if you had said 'yes'
13:10:06 <shachaf> How is it wrong?
13:10:23 <cmccann> size_2_shoes, note that you can even do stuff like "where x | a > 2 = ...", assuming "a" is bound elsewhere
13:10:28 <shachaf> @ty view (unwrapping Endo) . view traverse
13:10:29 <SwashBuckla> has anyone here gotten HPC working on a multi-module program?
13:10:30 <lambdabot> (Functor f, Traversable t, MonadReader (t (Endo a)) f) => f (a -> a)
13:10:33 <cmccann> e.g. an argument to the function the where clause is attached to
13:10:35 <shachaf> @ty view (traverse . unwrapping Endo)
13:10:38 <lambdabot> (Traversable t, Monoid a, MonadReader (t (Endo a)) m) => m (a -> a)
13:10:46 <shachaf> Hmm.
13:10:58 <jmcarthur> :t view (unwrapping Endo . traverse)
13:10:59 <lambdabot> (Traversable ((->) a), Monoid a, MonadReader (Endo a) m) => m a
13:11:10 <SwashBuckla> if not HPC, how do you view your test coverage?
13:11:24 <neutrino> you know what would super-suck
13:11:30 <shachaf> I see.
13:11:30 <jmcarthur> (i'm not trying to answer any questions. just exploring)
13:11:31 <neutrino> both hackage and lambdabot down at the same time
13:11:33 <SwashBuckla> neutrino: vacuums
13:11:38 <neutrino> that would be unbearable
13:11:47 <neutrino> i would go out of my mind
13:11:49 <`nand`> is this the part where we crash lambdabot?
13:11:57 <neutrino> ouch
13:12:30 <jmcarthur> neutrino: you ruined the fun i had planned. i didn't realize hackage was down
13:12:51 <jmcarthur> SwashBuckla: vacuums don't suck
13:13:05 <shachaf> @ty view (traverse . to (view (unwrapping Endo)))
13:13:07 <`nand`> non-vacuums just blow
13:13:07 <lambdabot> (Traversable t, Monoid a, MonadReader (t (Endo a)) m) => m (a -> a)
13:13:10 <neutrino> jmcarthur: :(
13:13:29 <shachaf> elliott: Oh, well, sure.
13:13:34 <shachaf> Why would you ever write that?
13:13:52 <elliott> shachaf: Well, say you have a list of Endo a.
13:14:13 * lispy has notified folks about the hackage outage
13:14:16 <elliott> I don't like how sometimes you need multiple "view"s.
13:14:21 <lispy> It may take several hours. Sorry!
13:14:24 <shachaf> elliott: Well, one of them isn't a real view
13:14:30 <elliott> It'd be nice if the Monoid thing was doable some other way.
13:14:30 <mreh> lispy: thanks
13:14:44 <elliott> view (traverse . monoidify . unwrapping Endo)
13:16:49 <jmcarthur> lispy: also express our continued gratitude for the service and all the time and effort required to keep it running!
13:16:52 <jmcarthur> :)
13:17:58 <mreh> lets buy him a present
13:19:05 <1JTAAT864> are there any good tutorials on FRP? i feel like i've been reading about it and still don't know what it is
13:19:21 <mreh> 1JTAAT864: not really, lots of blog posts
13:19:26 <alex-shpilkin> mreh: I’m afraid that means they’ll have to assemble it from several air mail packages. which may or may not be bad :-)
13:19:27 <mreh> people making tonnes of games
13:19:32 <SwashBuckla> how do I view my test coverage?
13:19:50 <1JTAAT864> mreh: that's what i've heard is a good use case
13:20:01 <1JTAAT864> any blog posts in particular you think are good?
13:20:13 <1JTAAT864> SwashBuckla: hpc, I think, though I dunno how to use it
13:20:18 <mreh> 1JTAAT864: yeah, some guy actually wrote his thesis on making a quake III like clone in Yampa
13:21:07 <solirc> Clint: you are welcome ;)
13:21:54 <SwashBuckla> 1JTAAT864: I'm already using HPC. Here is a good introduction: http:// http://book.realworldhaskell.org/read/testing-and-quality-assurance.html. The problem is that multi-module testing seems untenable with the described setup there.
13:21:55 <mreh> i got really excited when someone compiled a game built in netwire to javascript using haste
13:22:16 <1JTAAT864> ah, i dunno then.
13:22:18 <mreh> I can't compile the base libs for haste on my laptop though :(
13:22:42 <byorgey> SwashBuckla: you could also try sending your question to the haskell-cafe mailing list
13:22:50 <mreh> it's 64 bit, can anyone think of a way round it?
13:23:54 <mreh> I need to build GHC on a 32 bit machine, but I want to use them on a 64 bit machine, would that be possible
13:23:58 <SwashBuckla> byorgey: ok :)
13:24:14 <mreh> [the base libs]
13:24:52 <alex-shpilkin> mreh: most probably you’ll even be able to cross-compile on the 64-bit multilib machine itself (though I haven’t tried), but all that will probably be very boring
13:25:05 <neutrino> how do you unify the types of two values?
13:25:16 <1JTAAT864> neutrino: what do you mean?
13:25:23 <lispy> Sending the galois sysadmin a thank you card for hackage would be pretty awesome
13:25:26 <bootcode> any guess why gloss has a high CPU usage (only using the pure display function) ?
13:25:28 <mreh> alex-shpilkin: I'll use a VM
13:25:36 <neutrino> i am reading a paper which recommends unifying the type of two values.
13:25:52 <neutrino> r even propagate configuration data from one argu-
13:25:53 <neutrino> ment of a function to another, by unifying their types
13:25:55 <mreh> lispy: where do we donate?
13:26:01 <neutrino> *or
13:26:05 <1JTAAT864> what paper are you reading?
13:26:08 <lispy> mreh: http://corp.galois.com/paul-heinlein/
13:26:12 <vildor> hi!
13:26:24 <neutrino> http://www.cs.rutgers.edu/~ccshan/prepose/prepose.pdf
13:26:26 <vildor> I have a problem reading some code, can some one help me?
13:26:30 <neutrino> page 2, left column, lower half
13:26:36 <alex-shpilkin> mreh: I suspect the compilation result won’t run on your 64-bit machine then (e.g. /usr/lib/ld-linux.so would have the wrong arch)
13:26:43 <madjestic> hey guys.  After you edit a foo.cabal and then do 'cabal install' - does foo get installed, or some file mangling needs to be done aftrerwards?
13:27:09 <mreh> madjestic: normally cabal will object saying its been changed and needs to be reconfigured
13:27:16 <alex-shpilkin> mreh: but you try installing a multilib GCC for your distribution and setting CROSS before building
13:27:22 <alex-shpilkin> *could try
13:27:40 <1JTAAT864> neutrino: i guess the question is, what are you actually trying to *do*? in haskell 'type unification' is basically part of type inference
13:27:58 <neutrino> 1JTAAT864: read the context in the paper
13:28:04 <hpaste> vildor pasted “unknown” at http://hpaste.org/79243
13:28:09 <madjestic> mreh: what kind of configuration do you mean?
13:28:15 <alex-shpilkin> mreh: that should be quite easy on a decent Linux distribution, but not so on a Mac or a Windows PC
13:28:34 <mreh> madjestic: cabal configure, the step before building, it checks for dependencies mostly I believe
13:28:38 <lightquake> neutrino: right, i get that. what *specific problem* are you trying to solve in actual code?
13:28:41 <SwashBuckla> this is purely a stylistic question -- do you think QuickCheck properties should reside next to the code they're testing, or be in a separate file?
13:28:54 <mreh> alex-shpilkin: I think I might just do it all on a VM :)
13:29:12 <neutrino> lightquake: none, i'm reading the paper.
13:29:32 <mreh> i'm targeting javascript, it's not GCC
13:29:38 <lightquake> oh
13:29:43 <alex-shpilkin> mreh: of course. it’s a matter of taste, and I just like having all the things on my (physical) machine =)
13:29:53 <neutrino> if you don't know how to explicitly make the types of two values unify that's ok
13:30:01 <madjestic> mreh, so normally I want to do 'cabal configure' before 'cabal isnstall', after editing a foo.cabal?
13:30:05 <neutrino> i don't either
13:30:11 <lightquake> well in this case you can force unification using `asTypeOf`
13:30:20 <lightquake> @type undefined `asTypeOf` 2
13:30:22 <mreh> madjestic: I wouldn't worry about it unless cabal asks you to
13:30:23 <lambdabot> Num a => a
13:30:26 <byorgey> vildor: what is it you're having trouble with?
13:30:31 <neutrino> oh right i remember asTypeOf
13:30:31 <mreh> but you will probably have to
13:30:43 <neutrino> in fact i remembered there was some specific function that did exactly that.. i forgot the name
13:30:45 <alex-shpilkin> mreh: you mentioned recompiling the base libs, and I suspected you have a C package that won’t compile on a 64-bit machine. which does mean that you’ll be recompiling GHC and base and all that stuff.
13:30:48 <geekosaur> madjestic, cabal installl does the configure step itself under pretty much any circumstances you'll run into
13:30:49 <mreh> because it wont proceed unless you do
13:30:53 <neutrino> thanks, that's qhat i was looking for lightquake
13:31:00 <alex-shpilkin> s/suspected/assumed/
13:31:07 <vildor> byorgey: can't understand what the behaviour of  "\x bit -> alterarBit x noise bit" is
13:31:14 <geekosaur> and if you do it yourself, the install will do it again
13:31:20 <vildor> especially the \ and the ->
13:31:25 <byorgey> vildor: that is a lambda expression, i.e. an anonymous function
13:31:38 <byorgey> vildor: it is a function which takes two arguments, called x and bit, and outputs  alterarBit x noise bit
13:31:58 <vildor> oh!!!
13:32:10 <byorgey> vildor: in general  \x y z ... -> blah   is a function which takes arguments  x y z ...  and outputs blah
13:32:18 <vildor> kudos to you sir byorgey!
13:32:24 <vildor> thank you very, very much!!!
13:32:27 <byorgey> glad to help =)
13:32:30 <mreh> alex-shpilkin: haste wont compile the program properly if the base libs are 64 bit
13:32:44 <mreh> but all my other libs will be
13:33:44 <madjestic> mreh: the problem is I get foo installed this way, as I can see foo, after doing 'ghc-pkg list', however when I try to install bar, which has foo as a dependency, bar still tried to install foo, even though it seems to be installed already
13:34:34 <mreh> madjestic: what versions of foo do you have, and what version of foo does bar need?
13:34:49 <mreh> cabal will install two versions of the same package quite happily
13:35:19 <madjestic> mreh: allegedly, version require and version manually installed, match
13:35:57 <mreh> that doesn't sound right
13:36:08 <madjestic> no it does not
13:37:17 <mreh> sounds beyond my experience of cabal
13:37:26 <madjestic> I am currrently trying to wipe my installation
13:37:40 <madjestic> cabal, ghc, haskell platform
13:37:53 <mreh> you can move your .ghc directory in your home folder and start again
13:38:51 <mreh> your databse might have become corrupted
13:39:06 <mreh> that's just a guess...
13:39:43 <neutrino> @type withFile
13:39:44 <lambdabot>     Not in scope: `withFile'
13:39:45 <lambdabot>     Perhaps you meant one of these:
13:39:45 <lambdabot>       `writeFile' (imported from Prelude),
13:39:55 <neutrino> is there some bracket on file handles?
13:40:46 <monochrom> depends on what you mean. but I interpret it as withFile
13:40:57 <monochrom> System.IO.withFile
13:40:59 <neutrino> i wonder why withFile wasn't found
13:41:09 <neutrino> by lambdabot that is
13:41:11 <pqmodn> lambdabot doesn't do IO
13:41:33 <monochrom> there should be no surprise that lambdabot is not ghc
13:41:54 <neutrino> outrage
13:44:22 <neutrino> i have a thread which spins forever reading off a Chan Char and writing to a file. is there a way to use the Chan to tell the thread "ok, no more input going to happen, kill yourself now"?
13:44:32 <neutrino> other than using something like Chan Maybe Char
13:44:40 <neutrino> Chan (Maybe Char) that is
13:44:53 <Enigmagic> STM
13:45:01 <Enigmagic> use a TChan Char and a TVar Bool
13:45:20 <neutrino> @hoogle tchan
13:45:21 <lambdabot> Control.Concurrent.STM.TChan module Control.Concurrent.STM.TChan
13:45:21 <lambdabot> Control.Concurrent.STM.TChan data TChan a
13:45:21 <lambdabot> Control.Concurrent.Chan getChanContents :: Chan a -> IO [a]
13:45:21 <zenzike> this is strange: cabal install configurator thinks that "hash" is not a method of Hashable
13:45:21 <monochrom> ah, that's clever
13:45:30 <zenzike> any dieas why that might not be the case/
13:45:31 <neutrino> why would i use tchan and not chan, Enigmagic ?
13:45:34 <c_wraith> zenzike: it's not, in the newest version of Hashable
13:45:37 <neutrino> i know i can use TVar Bool
13:45:48 <zenzike> zenzike: ah. that sounds crazy :-)
13:45:50 <neutrino> but i was looking for something that *just* uses a Chan of some sort
13:45:52 <c_wraith> zenzike: you have to take the salt into consideration now
13:46:02 <zenzike> c_wraith: thanks very much
13:46:17 <c_wraith> zenzike: (and failure to consider the salt has negative security implications, so please do use it)
13:46:20 <zenzike> c_wraith: I imagine a lot of libraries are going to break
13:46:27 <zenzike> c_wraith: of course, DOS attacks
13:46:59 <neutrino> Enigmagic: (i have never used TChan and.. no way to check the docs right now)
13:47:01 <Enigmagic> neutrino: you acn use STM's Alternative instance to check the TVar Bool if the TChan Char is empty
13:47:37 <neutrino> Enigmagic: hmm.
13:47:58 <neutrino> Enigmagic: i guess you can't do that if you use Chan and TVar?
13:48:15 <Enigmagic> neutrino: not efficiently
13:49:26 <neutrino> oh, is there some special efficiency tuning for STM alternatives?
13:50:30 <Enigmagic> neutrino: compared to a polling a Chan, yes
13:50:42 <Enigmagic> or using threads/exceptions
13:50:52 <neutrino> huh, don't you poll a TChan as well?
13:51:08 <c_wraith> no
13:51:10 <c_wraith> STM doesn't poll
13:51:16 <Enigmagic> neutrino: not if it's empty. the STM will block until someone writes to the tchan or tvar
13:51:34 <neutrino> ohh
13:51:37 <neutrino> i get it now
13:52:10 <neutrino> that's clever
13:53:45 <neutrino> if i have two TVars, can i somehow unify them?
13:53:52 <neutrino> so that setting either sets the other?
13:54:16 <hpaste> Enigmagic pasted “stm flow control” at http://hpaste.org/79244
13:54:22 <Enigmagic> neutrino: ^^^
13:54:44 <neutrino> wow nice
13:54:47 <neutrino> thanks looking
13:55:28 <neutrino> i have no idea how those operators work
13:55:37 <neutrino> still haven't learnt applicative and alternative
13:55:51 <neutrino> i'll just happily copypaste :D
13:56:18 <pqmodn> neutrino: connor mcbride's paper was very helpful for me, regarding applicatives
13:56:30 <pqmodn> conor rather
13:56:40 <Enigmagic> <|> = an 'or' clause... says try the left action first, if it retries try the right action. if they both retry block until the TVar/TChan is modified.
13:56:43 <neutrino> pqmodn: any idea which paper?
13:56:47 <neutrino> Enigmagic: i figure that much
13:56:47 <pqmodn> http://www.soi.city.ac.uk/~ross/papers/Applicative.pdf
13:57:03 <neutrino> nice, thank you
13:57:04 <c_wraith> in STM, <|> is orElse, and empty is retry
13:57:33 <Enigmagic> neutrino: the Just/Nothing bits convert the two result types into a single type
13:57:42 <neutrino> right. what's the different between <* and <*>?
13:57:48 <neutrino> difference
13:57:59 <pqmodn> :t (<*)
13:58:00 <lambdabot> Applicative f => f a -> f b -> f a
13:58:01 <pqmodn> :t (<*>)
13:58:03 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
13:58:32 <neutrino> mhm
13:58:53 <xplat> neutrino: <* ignores the return value of the right-hand argument and just performs the effect/substitutes into the container/whatever
13:58:55 <neutrino> so <* is basically void?
13:58:58 <neutrino> of sorts
13:59:00 <neutrino> or const
13:59:11 <pqmodn> its similar to (>>)
13:59:13 <Enigmagic> *> is >> but for applicatives
13:59:22 <pqmodn> it still executes the effects, but discards the result
13:59:28 <neutrino> so <* is << but for applicatives?
13:59:29 <xplat> a <*> b = const <$> a <*> b
13:59:37 <c_wraith> :t fmap const
13:59:38 <xplat> er
13:59:38 <lambdabot> Functor f => f a -> f (b -> a)
13:59:42 <`nand`> there's no (<<)
13:59:43 <xplat> a <* b = const <$> a <*> b
13:59:47 <`nand`> but (<*) is flip (*>), right?
13:59:53 <Enigmagic> neutrino: if there was a standard (<<) then yes
13:59:56 <neutrino> `nand`: yeah, just saying
14:00:00 <c_wraith> `nand`: no
14:00:02 <neutrino> that's pretty cool. thanks
14:00:05 <xplat> *> = flip const <$> a <*> b
14:00:12 <`nand`> oh
14:00:12 <c_wraith> `nand`: they have opposite effect order
14:00:15 <`nand`> c_wraith: right
14:00:22 <neutrino> :t <$>
14:00:24 <lambdabot> parse error on input `<$>'
14:00:27 <neutrino> :t (<$>)
14:00:29 <lambdabot> Functor f => (a -> b) -> f a -> f b
14:00:36 <neutrino> :t (<*>)
14:00:37 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
14:00:48 <`nand`> thinking about how you use it, that makes perfect sense
14:00:52 <xplat> f <*> x = pure f <*> x
14:01:06 <pqmodn> no, f <$> x = pure f <*> x
14:01:06 <xplat> * f <$> x = pure f <*> x
14:01:24 <xplat> my accuracy is sad today
14:01:25 <`nand`> modulo types
14:01:44 <neutrino> so is <$> like function application, but applying the function to a value wrapped in a functor? and is then <*> just feeding that function further arguments?
14:02:08 <simpson> neutrino: Yes.
14:02:10 <xplat> also, (<$>) = fmap
14:02:16 <startling> is there a neat way to write a monad where each individual action can have initializers and finalizers that get run *before* we execute any action?
14:02:17 <neutrino> that finally made sense
14:02:25 <neutrino> xplat: every time people say this it confuses me
14:02:26 <pqmodn> neutrino: <$> applies a pure function to an effectful argument. <*> applies an effectful function to an effectful argument
14:02:30 <neutrino> i'll ignore it this time
14:02:33 <neutrino> :)
14:02:39 <neutrino> pqmodn: yeah
14:02:42 <c_wraith> startling: that would violate the monad laws
14:02:54 <neutrino> pqmodn: i see it's a common idiom to have func <$> arg <*> arg2 <*> arg3
14:03:00 <pqmodn> yep
14:03:03 <pqmodn> or liftA2
14:03:05 <pqmodn> :t liftA2
14:03:07 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
14:03:11 <pqmodn> well, i guess that would've been liftA3
14:03:14 <xplat> startling: you can do that for an applicative, but not for a monad
14:03:16 <c_wraith> startling: one of the rules is that foo and foo >>= return must be the same
14:03:38 <xplat> startling: for a monad you may have to run earlier actions to find out which actions get run later on
14:03:53 <neutrino> ok Enigmagic why are you using pure there?
14:04:03 <startling> c_wraith: maybe I should just data Wrapped m v = Wrapped { initalize :: m (); action :: m v; finalize :: m () } at the top level, then
14:04:12 <xplat> (and you can't do that for every applicative, just for some of them)
14:04:14 <neutrino> :t pure
14:04:16 <lambdabot> Applicative f => a -> f a
14:04:18 <pqmodn> neutrino: pure lifts a pure function into the context, making it "effectful".
14:04:19 <Enigmagic> neutrino: you could use 'return'... STM is also a Monad instance
14:04:25 <neutrino> :t (<|>)
14:04:27 <lambdabot> Alternative f => f a -> f a -> f a
14:04:28 <startling> xplat: aha, that makes sense
14:05:07 <xplat> c_wraith: i think you might have misunderstood what startling was asking for, in your example return could just be defined to have no (or trivial) initializer and finalizer
14:05:12 <neutrino> let me add some parens to this line
14:05:14 <neutrino> x <- atomically $ Just <$> readTChan tc <|> pure Nothing <* blockUntilTrue tv
14:05:26 <neutrino> x <- atomically $ ((Just <$> readTChan tc) <|> (pure Nothing <* blockUntilTrue tv))
14:05:30 <neutrino> this is how it parses, right?
14:05:33 <pqmodn> yeah
14:05:43 <c_wraith> xplat: oh, yes.  I thought he meant every action had the same initializer and finalizer
14:05:45 <hpaste> Enigmagic annotated “stm flow control” with “stm flow control (annotation)” at http://hpaste.org/79244#a79246
14:05:46 <neutrino> ok i see how that works
14:05:57 <Enigmagic> neutrino: check the update, i rewrote it without using as much Applicative stuff
14:05:58 <neutrino> pure is a generalization of return, right?
14:06:06 <c_wraith> yes
14:06:11 <neutrino> no that's fine, i'm digging it
14:06:19 <startling> xplat, cmccann: but I don't want, say, x >> x >> x to intialize three times
14:07:13 <startling> so I guess I can just stick the value the intializer creates (?) in a StateT etc
14:07:31 <neutrino> i gotta run
14:07:31 <c_wraith> startling: maybe you'd be interested in something like ResourceT
14:07:41 <startling> c_wraith: I'll take a look, thanks
14:07:42 <neutrino> but i'll be back soon. thanks for the info guys. this was great help
14:08:39 <xplat> ResourceT gives you finalizers at the end but it only gives you just-in-time initializers for the reason i mentioned
14:09:21 <startling> man, ghci doesn't run without gcc? >:(
14:09:29 <startling> xplat: huh, interesting
14:09:46 <startling> xplat: if I run a thing twice, does it get initialized twice?
14:10:18 <xplat> i think that depends how you defined it
14:11:26 <xplat> i've never used it in a case where i cared about that
14:12:01 <startling> yeah. anyway, I think defining initializers as m c and actions as StateT c m whatever makes more sense for me.
14:12:01 <Luke2> hackage is down right?
14:12:05 <startling> Luke2: yep
14:12:08 <Luke2> damn
14:12:09 <mikeplus64> yep. hold me
14:12:17 <Luke2> anyone working on it?
14:12:17 <purefn2> ya, not a good day to be starting a new project :(
14:13:02 <xplat> i guess it's a good day to be installing a copy of the haskell platform, though
14:17:23 <tomeo> According to Hoogle return has the type Monad m => a -> m a, but if I write do "merry"; return "christmas" the type of my expression will be [[Char]], why doesn't it get placed in a monad?
14:17:28 <jmcarthur> for everybody bummed about losing hackage for today, just comment out the remote-repo line in your .cabal/config and add     remote-repo: hdiff.luite.com:http://hdiff.luite.com/packages/archive
14:18:21 <xplat> tomeo: [] is a monad
14:18:26 <jmcarthur> so all you've lost is online documentation, which you can generate locally anyway
14:18:50 <xplat> > do "merry"; return "christmas"
14:18:52 <lambdabot>   ["christmas","christmas","christmas","christmas","christmas"]
14:19:29 <xplat> > do c <- "merry"; return (c:"christmas")
14:19:31 <lambdabot>   ["mchristmas","echristmas","rchristmas","rchristmas","ychristmas"]
14:19:33 <tomeo> Yes :) I find the value of the expression to be curious as well
14:20:10 <elliott> tomeo: say m = []
14:20:20 <elliott> return :: a -> [] a, same as return :: a -> [a]
14:20:34 <avpx> > [ "christmas" | c <- "merry" ]
14:20:35 <startling> so I want to define an interface to alternate among several different State actions with different state types. What kind of thing should I hold the state of each thing in?
14:20:36 <lambdabot>   ["christmas","christmas","christmas","christmas","christmas"]
14:20:51 <avpx> > [ c:"christmas" | c <- "merry" ]
14:20:53 <lambdabot>   ["mchristmas","echristmas","rchristmas","rchristmas","ychristmas"]
14:21:25 <tomeo> elliott: so as [] is a monad and [] a is the same as [a] then [a] is a monad?
14:21:44 <xplat> tomeo: [a] is a type of monadic value
14:21:55 <purefn2> jmcarthur: awesome, thanks!
14:21:57 <xplat> in the typical parlance here
14:22:36 <startling> also a "monadic action"
14:22:52 <xplat> startling: no, it's still a 'type of monadic action'
14:23:11 <xplat> ["christmas","christmas","christmas","christmas","christmas"] is a monadic value/action
14:23:21 <xplat> (so is "merry")
14:23:37 <avpx> Sure, or Nothing.
14:23:43 <tomeo> are they always monadic or are they just monadic because they are used with a return?
14:23:44 <startling> xplat: sure, should have specified that
14:24:10 <nomeata> Hi. What is the latest and greatest tool when it comes to organizing benchmarks for a library of mine?
14:24:17 <avpx> tomeo: Monad means something more specific than that.
14:24:19 <startling> nomeata, criterion, I think
14:24:36 <nomeata> I’d imagine there could be something that is able to automatically compare different states of my repository, and draw nice graphs, and so on.
14:24:41 <avpx> tomeo: But all monads in Haskell implement >>= (bind) and return.
14:24:48 <startling> nomeata: yeah, criterion
14:24:55 <xplat> tomeo: monadic is monadic, no matter what you build/use them with.  but if there's nothing in the area typical of monad use, the fact that you have a monadic value becomes a lot less relevant.
14:25:07 <nomeata> startling: I was thinking one level higher. criterion can be used to get the numbers, but it is not so much aimed at managing these numbers
14:25:33 <nomeata> The quiz would be: quickcheck/hunit ist to test-framework as criterion is to ...?
14:25:39 <tomeo> Is there an easy way to explain why my expression results in as many christmas as length "merry"?
14:25:57 <avpx> tomeo: Did you see the list comprehensions I posted earlier?
14:25:59 <startling> nomeata: oh, I see
14:26:21 <avpx> tomeo: I essentially just rewrote that do-notation as a list comprehension.
14:26:25 <aristid> luite: is it possible that you use a subtly different directory format than hackage?
14:26:32 <startling> tomeo, it's like "for all the elements in "merry", say "christmas"
14:26:36 <tomeo> avpx: Don't think so. Did you highlight me?
14:26:44 <startling> > "merry" >> "christmas"
14:26:45 <lambdabot>   "christmaschristmaschristmaschristmaschristmas"
14:26:54 <avpx> tomeo: No, here:
14:26:56 <avpx> > [ "christmas" | c <- "merry" ]
14:26:58 <lambdabot>   ["christmas","christmas","christmas","christmas","christmas"]
14:27:28 <shachaf> > [(),(),(),(),()] >> "hi"
14:27:29 <`nand`> > "christmas" <$ "merry"
14:27:30 <lambdabot>   "hihihihihi"
14:27:30 <aristid> luite: i can't test now because hackage is down (grml) but the code i have here indicates that the hackage directory format would be /packages/archive/NAME/VERSION/NAME-VERSION.tar.gz. you seem to skip the /VERSION/.
14:27:30 <lambdabot>   can't find file: L.hs
14:27:32 <`nand`> > "christmas" <$ "merry"
14:27:33 <lambdabot>   ["christmas","christmas","christmas","christmas","christmas"]
14:28:32 <tomeo> avpx: That was a great example. Thanks
14:30:39 <Moggle> Hey there, I'm trying to memoize a function basically
14:30:45 <Moggle> this is my code: http://codepaste.net/9tfa3p
14:30:58 <Moggle> This code won't run obviously
14:31:08 <Moggle> In any other language, I'd have a mutable array or hashtable or something
14:31:39 <Moggle> in Haskell... I don't really know how exactly to memoize something, and the Haskell wiki was frustratingly opaque on the matter of functions that aren't fib
14:32:23 <shachaf> There are a bunch of libraries for it.
14:32:50 <shachaf> What you seem to be tring for isn't optimal because you'll have a lot of random access on the list.
14:33:11 <shachaf> ((!!n) will have to step through the list to the nth point each time, even if the values themselves aren't being recomputed.)
14:33:13 <avpx> True. If you're using (!!) on big lists, you're probably doing it wrong.
14:33:22 <Moggle> this is a good point
14:33:26 <Moggle> what should I be using as an alternative here?
14:33:30 <shachaf> avpx: More than once, anyway.
14:33:37 <avpx> schlaftier: Yeah.
14:33:41 <shachaf> Moggle: There are a bunch of memoization libraries and things.
14:33:58 <Moggle> That's great shachaf, but I'd love to learn to do it myself here :P
14:34:15 <Moggle> i'd like to know what kind of data type i _should_ be using in this situation
14:34:22 <shachaf> Looking at those libraries might still be more useful than having people type things into here!
14:34:40 <nomeata> also, it seems that criterion does not support benchmarks with parameters (e.g. input size) that would generate me graphs that would allow me to check the asymptotic complexity.
14:34:41 <shachaf> The data structure depends on what you're doing.
14:35:04 <Moggle> For here? Just calculating the number of steps it takes for a number to get to 1 in the Collatz conjecture
14:35:13 <avpx> It looks like you're trying to use the list to memoize your result
14:35:14 <Moggle> single parameter, see if I've already called the function with that
14:35:36 <avpx> The issue with this is that a list is not the right data structure, since it's made up of cons cells. You should look into actual memoization libraries, as suggested.
14:35:40 <shachaf> I'd link to a relevant page, but Hackage is down.
14:35:46 <Moggle> Yes, I ran into that problem shachaf
14:35:48 <Moggle> :P
14:35:50 <Moggle> Which is why I came here
14:36:05 <startling> any ideas for my alternating-state thing?
14:36:13 <Moggle> As for data structures, I was assuming I could get by with something with Data.Map
14:36:17 <Moggle> but... that isn't mutable
14:36:23 <Moggle> nothing is mutable except IO stuff and it is terrible
14:36:25 <avpx> It doesn't really need to be, does it?
14:36:30 <shachaf> Moggle: Well, a trie is popular for this sort of thing.
14:36:48 <Moggle> well it seems horrifically inefficient but blargh lazy evaluation
14:36:59 <avpx> Correct me if I'm wrong, but can't you update Data.Map efficiently without copying the whole structure?
14:37:02 <shachaf> Also, you can use mutation.
14:37:02 <startling> e.g., I have State String and a State Int actions. I want to run them in some arbitrary order, but share the String among the State Strings and the Int among the State Ints.
14:37:11 <Moggle> just not quite sure how I'd calculate the first 999999 numbers and the length of their sequence
14:37:14 <shachaf> Memoization is probably one of the more valid uses of unsafePerformIO.
14:37:17 <Moggle> with a map and update it
14:37:19 <rwbarton> in this case you can also use an immutable array
14:37:30 <shachaf> That's also true.
14:37:41 <shachaf> Though it wouldn't work for a sparse sequence.
14:37:54 <avpx> Here though, it seems to be a good solution
14:37:55 <Moggle> perhaps I could do like foldl and have the accumulator be the updated map?
14:38:00 <rwbarton> this is
14:38:04 <rwbarton> oops
14:38:20 <Moggle> but then the accumulator function has to potentially update the map multiple times and that's terrible
14:38:23 <Moggle> perhaps doable though!
14:38:43 <rwbarton> "semisparse", you can memo all the values below a bound and recompute the rest
14:38:51 <shachaf> Oh, I just realized that's a "project euler" thing. I think I'm boycotting those or something. :-(
14:39:05 <rwbarton> or you can do it this way yeah
14:39:08 <startling> hmmm, maybe this is where existential quantification is useful
14:39:19 <shachaf> startling: What, memoization? Why?
14:39:37 <Moggle> it's an easy way to learn the language, shachaf
14:39:38 <startling> shachaf: This is my own dialogue
14:39:45 <startling> well, monologue so far
14:39:54 <Moggle> but hardly matters, I'd still need to learn memoization if I were using haskell anywhere else
14:40:47 <avpx> AFAIK, Haskell does some memoization of its own
14:40:49 <avpx> Erm, GHC does
14:40:52 <jmcarthur> no
14:40:59 <startling> avpx: I don't think so
14:41:00 <jmcarthur> sharing is not the same as memoization
14:41:07 <avpx> Hmm, okay.
14:41:19 <rwbarton> a widely-perpetuated myth
14:41:27 <Moggle> well avpx, I thought Haskell _did_ do memoization myself
14:41:35 <Moggle> but then when I was brute forcing this collatz thing I found out it didnt
14:41:39 <jmcarthur> ghc will (rarely) do something that might make you think it does, though. when it does CSE it might appear to be memoization.
14:41:40 <Moggle> and now I'm sad I have to do it myself
14:41:45 <startling> If i do someFn 12 + someFn 12, will it run someFn twice?
14:41:58 <Moggle> my tests say yes
14:41:59 <Moggle> :(
14:42:01 <Moggle> could be wrong
14:42:03 <avpx> jmcarthur: Hmm, that's probably the source of my confusion.
14:42:04 <cmccann> generally yes
14:42:11 <rwbarton> different issue
14:42:12 <startling> cmccann: and that's "sharing"?
14:42:19 <sclv> @oeis 15,65,175,369,671,1105,1695,2465,3439,4641
14:42:21 <lambdabot>  Rhombic dodecahedral numbers: n^4 - (n-1)^4.
14:42:21 <lambdabot>  [1,15,65,175,369,671,1105,1695,2465,3439,4641,6095,7825,9855,12209,14911,179...
14:42:21 <nicoo> Moggle: It's quite easy; esp if you use Data.MemoCombinators
14:42:24 <startling> errr wait
14:42:24 <cmccann> but if you write "let x = someFn 12 in x + x" it will only compute it once
14:42:27 <SegFaultAX> Moggle: Well you wouldn't really /want/ it to memoize, would you?
14:42:31 <startling> cmccann: ah, okay
14:42:31 <rwbarton> as jmcarthur mentions
14:42:44 <Moggle> The memory concerns would be horrific, SegFault
14:42:47 <Moggle> this is true
14:43:15 <startling> couldn't you just have a memoizing wrapper for a function?
14:43:27 <Moggle> there are libraries for that apparently startling
14:43:28 <cmccann> it would of course be easy for GHC to automatically memoize all kinds of things. and since GHC is very clever most of the time, that it essentially doesn't do any memoization should tell you something
14:43:30 <Moggle> i was hoping to make my own
14:43:34 <startling> Moggle: aha
14:43:43 <startling> cmccann: heh
14:44:21 <cmccann> it's apparently very difficult for the compiler to figure out what could be memoized without making things worse, possibly drastically so
14:44:46 <cmccann> if you want to see the worst case scenario, profile your code and look at the total memory allocated
14:44:51 <cmccann> then imagine that none of that ever gets GC'd
14:44:55 <SegFaultAX> cmccann: Even if that weren't the case and it could freely memoize everything, it's probably not useful for your compiler to assume you have infinite memory.
14:45:05 <avpx> cmccann: That does sound pretty nasty.
14:45:54 <hiptobecubic> why do you need unsafePerformIO for memoization?
14:45:59 <shachaf> You don't.
14:46:04 <shachaf> But it's one way of doing it.
14:46:05 <cmccann> SegFaultAX, yes and the total memory allocation performed by code compiled by GHC approaches infinity faster than you'd think
14:46:08 <fryguybob> Also computation can be much faster then memory lookup.
14:46:27 <cmccann> fryguybob, also very true! but that's a subtler question of optimization.
14:46:46 <shachaf> cmccann: It might reach infinity in as little as *half* the time that another language would take!
14:46:53 <hiptobecubic> shachaf, but if you use it, then where? You can't use it when checking if the hash is already in the map and you can't use it to retrieve the results from the map
14:47:26 <hiptobecubic> you can use it to mutate the map to store new results, but if the compiler thinks the lookup function is pure then what good is that?
14:49:39 <neutrino> hi again
14:49:58 <neutrino> Enigmagic: hey, one more question about TVars
14:50:08 <Enigmagic> neutrino: sure
14:50:18 <neutrino> i want something like a TVar, but which gets unset when i read it
14:50:25 <neutrino> am i right to think that's an MVar?
14:50:28 <Enigmagic> neutrino: TMVar
14:50:29 <shachaf> hiptobecubic: I'm not sure what you mean.
14:50:33 <neutrino> oh there's a TMVar?
14:50:35 <neutrino> nice
14:50:38 <Enigmagic> yep
14:50:54 <neutrino> thanks
14:51:47 <Ralith> Does anyone remember that paper about implementing datatypes with specific in-memory encodings (e.g. weirdly-shaped bitfields like you find in protocol headers or hardware control registers) in haskell?
14:51:47 <hiptobecubic> shachaf, you said memoization was one of the valid uses of unsafePerformIO, but I don't see how you could use it
14:52:18 <shachaf> hiptobecubic: Store a map in a variable, look up in the map each use of the function, if the variable isn't found then compute a new value and store in the map?
14:52:35 <hiptobecubic> shachaf, but the lookup will be assumed to be pure no?
14:52:39 * cmccann has a half-finished parser for packed bitfield formats somewhere...
14:52:55 <shachaf> hiptobecubic: And it behaves as such.
14:52:59 <hiptobecubic> shachaf, so if we checked once and it wasn't there, we might not check again?
14:53:04 <shachaf> ?
14:53:10 <Ralith> specifically I'm interested in the syntax they settled on
14:53:18 <Ralith> and a discussion of the design concerns
14:53:20 <Jafet> GHC always checks again.
14:53:20 <shachaf> I'm talking about unsafePerformIO of a lookup in a mutable variable.
14:53:34 <cmccann> Ralith, if you find the paper I'd be interested to see it
14:53:58 <Ralith> cmccann: will ping you if I have any luck
14:54:01 <cmccann> in case I ever go back to working on whatever I needed to mess with that stuff for
14:54:13 <Jafet> (In other words, GHC does not memoize.)
14:54:39 <hiptobecubic> shachaf, i must have the wrong mental model for what you're describing. If the map is changing, how can the lookup function be treated as pure?
14:54:43 <neutrino> am i right to think that TMVar is basically MVar with Applicative and Alternative?
14:54:44 <cmccann> all I remember is I had a parser that would output lots of diagnostic information showing the exact bit sequences and byte boundaries and how they matched up to where it thought the fields were.
14:54:58 <neutrino> or are there other differences as well?
14:55:01 <Ralith> hiptobecubic: because the same result is returned for the same input regardless.
14:55:07 <hiptobecubic> we do a lookup now, it's not in the map so we calculuate the result and unsafely store it
14:55:18 <hiptobecubic> ohhhh
14:55:24 <jmcarthur> @hackage stable-memo
14:55:24 <lambdabot> http://hackage.haskell.org/package/stable-memo
14:55:28 <jmcarthur> hiptobecubic: an example
14:55:44 <hiptobecubic> i was thinking the unsafe part was inside the lookup, not the outer "give me the result" function
14:55:52 <hiptobecubic> no it makes sense now, i get it
14:55:55 <jmcarthur> (that is a different kind of memoization than value memoization, but it still works as an example of unsafePerformIO for memoization)
14:56:16 <hiptobecubic> is hackage up now or are you just trolling?
14:56:21 <jmcarthur> ah shoot
14:56:21 <shachaf> hiptobecubic: Just think of how you'd do simple memoization in an average impure language, then do that in Haskell with unsafePerformIOs to match. :-)
14:56:26 <jmcarthur> unintentional trolling
14:56:30 <hiptobecubic> jmcarthur, :)
14:56:53 <hiptobecubic> shachaf, yes i see how it works.
14:57:05 <neutrino> side-trolling
14:58:04 <Enigmagic> neutrino: IO has Applicative but not Alternative
14:58:40 <neutrino> Enigmagic: gotcha
14:59:40 <lispy> we could probably implement Alternative IO with some exception handling, but I doubt it would do what people want
14:59:47 <Enigmagic> neutrino: they also support the notion of transactions, which is how the Alternative instance works.. but transactions can be much larger than a single read or write
14:59:51 <lispy> (eg., probably wouldn't obey the laws)
15:00:01 <neutrino> yep
15:01:45 <neutrino> if i have two TVars, can i unify them to be one?
15:01:56 <neutrino> in some way
15:02:10 <jmcarthur> you could read them and make a new one with whatever result you intend
15:02:14 <romildo> Why some gtk2hs demos (distributed with the sources) have imports Graphics.UI.Gtk.ModelView as New? If the import is ommited, it still works.
15:02:40 <neutrino> what i want is a single TVar which can be written to which writes to the two original ones
15:03:07 <dagnachew> hi all
15:03:09 <dagnachew> cabal update
15:03:11 <dagnachew> Downloading the latest package list from hackage.haskell.org
15:03:13 <dagnachew> cabal: <socket: 7>: resource vanished
15:03:17 <neutrino> topic
15:03:27 <cmccann> resource vanished is a good way to put it
15:04:02 <aristid> how can i tell cabal update to fetch the package list for a specific remote? (specifically hdiff.luite.com, of course.)
15:04:14 <dagnachew> cmccann, what does it mean
15:04:18 <alpounet> aristid, ~/.cabal/config
15:04:27 <alpounet> <jmcarthur> for everybody bummed about losing hackage for today, just comment out the remote-repo line in your .cabal/config and add     remote-repo: hdiff.luite.com:http://hdiff.luite.com/packages/archive
15:04:29 <aristid> alpounet: ? i already have the remote-repo in there.
15:04:30 <Enigmagic> neutrino: it's possible, sure. not something i'd probably do though
15:04:40 <neutrino> Enigmagic: how would you do it?
15:04:43 <aristid> but cabal update still tries hackage.haskell.org and fails.
15:04:43 <alpounet> aristid, oh, then just cabal update will do it
15:04:48 <cmccann> dagnachew, well hackage is a useful resource and it's currently vanished
15:04:49 <aristid> no it doesn't!
15:05:18 <dagnachew> cmccann, you mean out of order for know ?
15:05:23 <alpounet> aristid, and you've commented out hackage.haskell.org?
15:05:24 <jmcarthur> @let floatSum = fst . foldl' (\(acc,err) x -> let x' = x - err; acc' = acc + x'; err' = (acc' - acc) - x' in (acc', err')) (0, 0)
15:05:27 <lambdabot>  Defined.
15:05:33 <cmccann> dagnachew, yes, see the topic
15:05:38 <jmcarthur> > sum $ replicate 1000 0.3
15:05:40 <lambdabot>   300.0000000000056
15:05:41 <Enigmagic> neutrino: i'd tote the pair of TVars around (maybe in a newtype wrapper) and have a new function like 'writeTVarPair :: (TVar a, TVar a) -> a -> STM ()'
15:05:42 <jmcarthur> > floatSum $ replicate 1000 0.3
15:05:45 <lambdabot>   300.0
15:06:05 <neutrino> Enigmagic: yeah, i thought of that as well.
15:06:10 <aristid> alpounet: ah, that might help!
15:06:11 <neutrino> maybe i should just do something like this.
15:06:27 <alpounet> aristid, i think cabal just tries them in order, so if one fails it may just yell at you
15:06:36 <neutrino> why would you want a newtype wrapper?
15:06:45 <neutrino> i'm not good with newtypes, so i'm not sure what their applications are
15:06:55 <aristid> alpounet: so it seems
15:07:48 <cmccann> newtype defines a new type, unlike type which does not define a type, and subtly different from data which also defines a type. what's not to understand?
15:07:57 <aristid> alpounet: anyways, it works now.
15:08:05 * cmccann is not fond of that choice of keywords.
15:08:20 <neutrino> cmccann: mm, yeah.
15:08:28 <jmcarthur> neutrino: you could just write an STM function that does what you want instead of using a TVar
15:09:03 <neutrino> jmcarthur: you mean an stm function which writes to the original two TVars, insteas of using a third TVar?
15:09:11 <aristid> how much data is hackage? in case people want to add more mirrors :P
15:09:22 <jmcarthur> neutrino: newtype TVarWriter a = TVW (a -> STM ()); writeTVars :: TVarWriter a -> a -> STM ()
15:09:46 <jmcarthur> neutrino: along with    addTVar :: TVar a -> TVarWriter a -> TVarWriter a
15:10:03 <jmcarthur> neutrino: or some variation on the whole idea. newtype is not strictly necessary of course, for example
15:10:04 <neutrino> i'm not sure how to understand the type of writeTVars
15:10:37 <jmcarthur> neutrino: it just feeds a value into the TVarWriter, which writes it to all the TVars you have "added" to it
15:10:42 <neutrino> the constructor TVW takes a function from a to STM (), yes?
15:10:47 <neutrino> but what is that function?
15:10:52 <jmcarthur> neutrino: TVarWriter could just as well have been [TVar a], really
15:11:10 <jmcarthur> neutrino: that function write to zero or more tvars
15:11:27 <jmcarthur> neutrino: conveniently, the whole thing is also a monoid, in a couple different ways
15:11:30 <neutrino> aha
15:11:32 <neutrino> got it
15:11:54 <jmcarthur> neutrino: so depending on how you define the monoid, it could either mean taking the union of the sets of tvars or it could mean nondeterminism
15:12:14 <neutrino> how do you end up with nondeterminism?
15:12:27 <jmcarthur> neutrino: by using orElse
15:12:39 <neutrino> why is that nondeterministic?
15:13:06 <jmcarthur> because it either does one thing or the other but not both, and it's not deterministic which one it does
15:13:34 <jmcarthur> at least not in general
15:13:48 <jmcarthur> there may be contexts in which you know which of the choices it would make
15:14:01 <neutrino> oh?
15:14:22 <neutrino> hmm ok.
15:14:22 <jmcarthur> just depending on the STM actions, what shared variables they access, what causes them to get stuck, etc.
15:16:30 <epta> How could I parse 0 or 1 with attoparsec?
15:16:45 <johnw> use a predicate
15:18:22 <johnw> satisfy $ \w -> w == 0 || w == 1
15:18:57 <johnw> there is an example of this in the "Parsing individual bytes" section of the Haddock docs
15:20:10 <epta> johnw: could you please remind a name of the attoparsec module where it could be find
15:20:33 <johnw> search for satisfy
15:20:48 <epta> Data.Attoparsec.ByteString.Internal
15:21:10 <johnw> just Data.Attoparsec.ByteString
15:21:34 <epta> johnw: got it, thanks
15:31:42 <Moggle> Dumb question: any way to reverse parameter order when calling a function?
15:31:51 <Moggle> I know there's a way to do it but I can't remember
15:31:53 <tbreisacher> Moggle: I think you're looking for 'flip'
15:31:56 <Moggle> aha
15:31:58 <Moggle> that sounds perfect
15:32:04 <avpx> That only works on two arguments
15:32:20 <tbreisacher> it seems like it should be easy enough to write a 'flip3'
15:32:33 <avpx> Yes, of course
15:32:37 <johnw> let's write 'scramble'
15:32:43 <johnw> different arg order every time
15:32:44 <tbreisacher> flip3 :: (a -> b -> c -> d) -> (c -> b -> a -> d)
15:32:44 <tbreisacher> i think
15:32:58 <v0|d> there r 6 elements of order 3 in S3.
15:33:38 <v0|d> oh 2 not 6, so there will be flip3_1 and flip3_2
15:35:12 <avpx> v0|d: Why are we just using the order 3 elements?
15:36:14 <v0|d> nice question, avpx.
15:36:42 <avpx> flip3' f a b c = f c b a has feelings too
15:36:48 <v0|d> suppose we want a order 2 perm, then we can first curry then use flip.
15:36:58 <v0|d> so no need to have flip3.
15:36:59 <avpx> Ah.
15:37:08 <v0|d> does it make sense?
15:37:11 <avpx> Yes.
15:37:12 <johnw> yes!
15:37:35 <v0|d> order 2 permutations will stabilize the third.
15:37:41 <aristid> flip4 !sey
15:38:17 <v0|d> can anybody point me a paper on X combinator?
15:38:22 <aristid> @pl \f a b c -> f c b a
15:38:23 <lambdabot> flip . (flip .) . flip
15:38:28 <aristid> heh, @pl.
15:39:17 <johnw> wonder how long hackage will be out this time  :(
15:39:18 <jmcarthur> it's just flip . fmap flip . flip
15:39:22 <jmcarthur> pretty nice, actually
15:39:32 <jmcarthur> plays out like forth stack manipulation
15:39:36 * tbreisacher is wondering that too
15:39:44 <johnw> at least I have a local mirror
15:39:48 <johnw> it's just not 100% faithful
15:40:04 <johnw> for whatever reason, my mirror thinks hoogle-3 is the latest version
15:40:11 <johnw> so I don't really trust it anymore
15:40:16 <tbreisacher> are there other mirrors out there that are available for people to use?
15:40:24 <epta> Yep, building all packages with haddock is surprisingly helpful
15:40:42 <johnw> tbreisacher: yes, there is
15:41:01 <johnw> http://comonad.com/reader/2012/hackage-mirror/
15:41:10 <tbreisacher> wooooo thanks :D
15:41:49 <johnw> luite: ping
15:42:02 <Moggle> oh god stack overflows
15:42:03 <jmcarthur> a general formula for flipN:   to flip the nth and (n+1)th argument of a function, indexed from zero, apply n fmaps to flip
15:42:15 <johnw> are you referring to the Q&A website?
15:42:36 <jmcarthur> :t let c = (.) in (flip, c flip, (c.c) flip, (c.c.c) flip, (c.c.c.c) flip)
15:42:38 <lambdabot> (Functor f9, Functor f8, Functor f7, Functor f6, Functor f5, Functor f4, Functor f3, Functor f2, Functor f1, Functor f) => ((a -> b -> c) -> b -> a -> c, f (a1 -> b1 -> c1) -> f (b1 -> a1 -> c1), f1
15:42:38 <lambdabot> (f2 (a2 -> b2 -> c2)) -> f1 (f2 (b2 -> a2 -> c2)), f3 (f4 (f5 (a3 -> b3 -> c3))) -> f3 (f4 (f5 (b3 -> a3 -> c3))), f6 (f7 (f8 (f9 (a4 -> b4 -> c4)))) -> f6 (f7 (f8 (f9 (b4 -> a4 -> c4)))))
15:42:41 <jmcarthur> ugh
15:42:43 <Moggle> http://codepaste.net/6ynk2n
15:42:45 <jmcarthur> :t let c = (Prelude..) in (flip, c flip, (c.c) flip, (c.c.c) flip, (c.c.c.c) flip)
15:42:47 <Moggle> this is what i am referring to
15:42:47 <lambdabot> ((a -> b -> c) -> b -> a -> c, (a1 -> a2 -> b1 -> c1) -> a1 -> b1 -> a2 -> c1, (a3 -> a4 -> a5 -> b2 -> c2) -> a3 -> a4 -> b2 -> a5 -> c2, (a6 -> a7 -> a8 -> a9 -> b3 -> c3) -> a6 -> a7 -> a8 -> b3 -
15:42:47 <lambdabot> > a9 -> c3, (a10 -> a11 -> a12 -> a13 -> a14 -> b4 -> c4) -> a10 -> a11 -> a12 -> a13 -> b4 -> a14 -> c4)
15:43:01 <Moggle> it is horrifying and makes me a sad panda
15:43:11 <Moggle> i suspect thunks are the issue
15:43:17 <Moggle> perhaps there is a stricter version of insert?
15:43:19 <johnw> ah, you just need some strictness, that's all
15:43:28 <Moggle> but where D:
15:43:35 <Moggle> i tried to put it in the foldl'
15:43:37 <Moggle> but that didnt help
15:43:49 <Moggle> learning haskell is hard :P
15:43:51 <johnw> that made the foldl' itself strict
15:44:01 <johnw> but it's not *deep*
15:44:14 <epta> How could I read file to Data.ByteString.Internal.ByteString?
15:44:25 <Moggle> So where exactly is the bottleneck in the code, johnw?
15:44:31 <Moggle> I don't understand what's being lazy here
15:44:36 <Moggle> it could be the add operation
15:44:40 <johnw> you see that expression being passed into insert?
15:44:41 <Moggle> but I don't know how to make add strict
15:44:45 <Moggle> yessir
15:44:49 <johnw> i'd do this:
15:45:04 <johnw> let x = <that expr> in seq x $ M.insert n x m
15:45:19 <johnw> that way it forces the lookups to be done
15:45:36 <johnw> you may need even more strictness to force the inserts to be done too, i'm not sure without further analysis
15:45:41 <Moggle> will that also work if I do where x = <that expr>?
15:45:48 <johnw> sure
15:45:52 <Moggle> whew
15:46:08 <Moggle> I'm confuse at the seq x bit
15:46:12 <Moggle> what exactly is seq?
15:46:27 <jmcarthur> seq just means that both arguments should be evaluated, but only return the second
15:46:28 <johnw> seq x foo says: force evaluation of x when you need to evaluate foo
15:46:38 <johnw> but if foo is not needed, x won't be evaluated either
15:46:53 <johnw> but even further: x is only evaluated to weak head normal form
15:47:04 <johnw> so you have to know exactly *what* needs to be made strict
15:47:40 <johnw> in this case, it will make the 1 + ... strict, which should be enough to reduce it down to an actual number
15:47:41 <jmcarthur> Moggle: (seq x y) takes on the value of y assuming that the computation of x terminates
15:47:42 <Moggle> huh, the Haskell tutorial I read never went into that
15:47:44 <Moggle> thanks!
15:47:56 <jmcarthur> s/assuming/if and only if/
15:48:31 <Moggle> http://codepaste.net/vub1ms
15:48:37 <Moggle> still getting stack overflows
15:48:39 <Moggle> how sad
15:48:47 <johnw> don't despair, we're just beginning
15:48:57 <Moggle> the despair is clawing at my heart though
15:48:59 <Moggle> D:
15:48:59 <johnw> ok, next try this:
15:49:07 <johnw> change "collatzMap n m" to "collatzMap !n !m"
15:49:13 <Moggle> !n meaning?
15:49:13 <johnw> and add the language feature that GHC will suggest to you
15:49:27 <johnw> it makes n a strict argument of collatzMap
15:49:50 <Moggle> it says it's an illegal bang-pattern
15:50:08 <jmcarthur> you must have put it in the wrong place
15:50:09 <Moggle> do I have to do ghci -XBangPatterns
15:50:11 <Moggle> ?
15:50:12 <johnw> do you have {-# LANGUAGE BangPatterns #-}?
15:50:13 <jmcarthur> use it on the left side of the function
15:50:26 <jmcarthur> and ghc should suggest that you enable BangPatterns
15:50:27 <Moggle> http://codepaste.net/pkpp2z
15:50:28 <johnw> add that to your file and reload
15:50:47 <jmcarthur> yeah that looks right. just add the pragma at the top
15:50:57 <johnw> i think that making 'm' strict is all you need, actually
15:51:02 <johnw> but can't hurt to do both for now
15:51:08 <Moggle> ohey that line added made it work
15:51:15 <johnw> now try removing the seq we added
15:51:20 <johnw> and change !n to n
15:51:24 <johnw> and see if !m is all you needed
15:51:32 <jmcarthur> that would surprise me
15:51:41 <Moggle> I'm still kind of confused here on the ! notation
15:51:41 <jmcarthur> hmm, or would it
15:51:46 <Moggle> you said it makes Haskell tell me what I need?
15:51:47 <jmcarthur> no, i think that wouldn't surprised me after all
15:51:51 <johnw> normally in Haskell arguments are not strict
15:51:51 <Moggle> it's not giving me any debug info
15:51:53 <jmcarthur> no
15:51:56 <johnw> they are only evaluated if/when needed
15:52:05 <jmcarthur> we just meant what extension will be required for ! to work
15:52:08 <johnw> !m says "evaluate m before evaluating the body of this function, when this function call itself is evaluated"
15:52:13 <Moggle> ah, okay
15:52:18 <jmcarthur> Moggle: ! just means to always evaluate it whether or not it's needed
15:52:20 <Moggle> and why did I need {-# LANGUAGE BangPatterns #-} exactly?
15:52:25 <jmcarthur> that's to enable that feature
15:52:29 <johnw> !m is a special syntax supported only by GHC
15:52:35 <jmcarthur> it's not actually haskell proper
15:52:36 <Moggle> I see!
15:52:39 <johnw> the alternative is to wrap the entire function body with: seq m ...
15:52:44 <Moggle> That's going to be hard to remember
15:52:52 <Moggle> but doable!
15:53:02 <johnw> it's just a shorthand for doing seq on function arguments over the entire function body
15:53:14 <Moggle> still getting a stack overflow
15:53:19 <Moggle> with both arguments !n !m
15:53:25 <johnw> but without the seq?
15:53:31 <Moggle> I still have the seq
15:53:35 <Moggle> Should I remove it?
15:53:36 <johnw> what did you change?
15:53:40 <johnw> you said it worked before
15:53:45 <Moggle> It never worked
15:53:57 <Moggle> http://codepaste.net/bmmktt
15:53:59 <Moggle> this is what I have right now
15:54:00 <pqmodn> i think he meant GHC didn't complain about bang patterns after he enabled the extension
15:54:00 <johnw> "ohey that line added made it work"
15:54:05 <johnw> ah
15:54:06 <Moggle> compile*
15:54:07 <Moggle> sorry
15:54:27 <johnw> ok, so we the strictness elsewhere then
15:54:47 <johnw> need
15:55:41 <johnw> i think "seq x" isn't deep enough
15:55:44 <Moggle> could be my code is just plain wrong
15:55:47 <Moggle> :P
15:55:58 <Moggle> I'm not exactly 100% confident in it
15:56:11 <johnw> well, try running it with a smaller number
15:56:13 <johnw> 1..999
15:56:15 <johnw> see if that runs
15:56:27 <johnw> you know
15:56:33 <johnw> this could be a case of infinite recursion
15:56:36 <Enigmagic> johnw: how could you get much deeper than seq on an Int?
15:56:44 <johnw> Enigmagic: you're right, I couldn't
15:56:51 <johnw> i think collatzMap is not terminating
15:57:04 <Moggle> it appears to work for smaller numbers
15:57:07 <Moggle> fascinating
15:57:17 <johnw> ok, so it is terminating
15:57:21 <Moggle> well
15:57:26 <Moggle> for larger numbers it could be its not terminating
15:57:28 <johnw> then why in the world would !m + seq x not be enough?
15:57:31 <Moggle> and the stack goes REALLY deep
15:57:38 <johnw> it goes really deep for small numbers?
15:57:39 <Moggle> I know for a fact it can go 512 levels deep or so
15:57:46 <Moggle> for 888888
15:57:47 <Moggle> or so
15:57:58 <Moggle> but that... doesn't seem that bad
15:58:09 <Moggle> fib 500 probably works?
15:58:16 <johnw> but it goes deeper and deeper for each n, doesn't it?
15:58:30 <johnw> err, for each m
15:58:39 <Moggle> for n around 900000 it can call collatzMap and recurse > 500 times
15:58:43 <Moggle> is what I'm trying to say
15:58:44 <johnw> i haven't used foldl in so long I misread the meaning of n and m
15:59:01 <glguy> seq on an IntMap doesn't seq the values stored in the IntMap
15:59:15 <johnw> glguy: but we're doing seq on the value that gets inserted
15:59:22 <glguy> (I haven't read the whole chat log yet, still catching up)
15:59:35 <Moggle> I appreciate the help by the way, johnw
15:59:38 <Moggle> learning a lot here :P
15:59:50 <johnw> Moggle: sure; so, I think you can drop the !n and !m
15:59:52 <johnw> you only need the seq x
16:00:03 <Moggle> k
16:00:07 <johnw> but I think you need to fix the recursion, it's just getting too deep for large values of m
16:00:14 <johnw> or, increase your stack size :)
16:00:29 <johnw> try putting in a Debug.Trace.trace statement
16:00:34 <Moggle> how does one increase the stack size?
16:00:37 <johnw> to watch how the recursion changes
16:00:41 <glguy> Is this a project euler problem?
16:00:46 <Moggle> and where would I put that Debug.Trace.trace statement exactly?
16:00:48 <Moggle> why yes it is
16:00:48 <johnw> +RTS -K10m -RTS
16:00:54 <Moggle> Do I do that on the command line
16:00:56 <glguy> Which number is it?
16:00:57 <Moggle> or like at the top of my file
16:01:03 <johnw> put the trace at the top of collatzMap
16:01:06 <Targen> Anybody know whether it’s possible to specify a schema for HaskellDB table specifications?  (as in the namespaces for table names and other objects inside a database, at least available in postgres)
16:01:20 <Moggle> problem 14
16:01:22 <johnw> like: trace ("collatzMap n = " ++ show n ++ " m = " ++ show m) $
16:01:24 <Moggle> I've already solved it
16:01:29 <Moggle> with a super inefficient method
16:01:31 <Moggle> which took > 20 seconds
16:01:38 <Moggle> I'm trying to do some memoization here
16:01:40 <pqmodn> the implementation of collatzMap doesn't look tail recursive
16:01:42 <Moggle> It's surprisingly tricky in Haskell
16:01:55 <pqmodn> so maybe you're just eating lots of stack space
16:02:00 <johnw> Moggle: you know you don't need to use a Map to do memoization of integers in Haskell?
16:02:12 <Moggle> I tried doing it with a list earlier
16:02:17 <johnw> Haskell's scheme for lazy evaluation can be used to do memoization for you
16:02:19 <Moggle> and the list memoization idea didn't work out
16:02:27 <Moggle> How exactly would I do it with integers?
16:02:39 <glguy> The list case has a problem because the sequence grows over the starting value in many cases
16:02:55 <Moggle> indeed it does!
16:03:03 <johnw> so, you populate a list with n thunks, and then change your function definition to simple return the n'th element
16:03:04 <neutrino> how to check what functions and types are defined in a module?
16:03:18 <pqmodn> neutrino: in ghci use :browse
16:03:22 <neutrino> thank
16:03:24 <neutrino> s
16:03:52 <Moggle> I don't quite understand that johnw
16:03:53 <neutrino> @hoogle tmvar
16:03:53 <lambdabot> Control.Concurrent.STM.TMVar module Control.Concurrent.STM.TMVar
16:03:53 <lambdabot> Control.Concurrent.STM.TMVar data TMVar a
16:03:53 <lambdabot> Control.Concurrent.MVar putMVar :: MVar a -> a -> IO ()
16:03:57 <johnw> in http://www.haskell.org/haskellwiki/Memoization, see the section "Memoization with recursion"
16:04:04 <johnw> the way memoized_fib is implemented is what I mean
16:04:14 <Moggle> the nyeah
16:04:16 <johnw> the "function" is really just a lookup into a map of thunks
16:04:19 <fmap> pqmodn: tail recursion is mostly irrelevant in haskell (in fact, it often introduces stack problems not solves them)
16:04:25 <Moggle> I implemented my thing the exact same way
16:04:38 <johnw> which causes the evaluation of the n'th element to happen only once, at the time when Haskell actually needs the value, and then never again after
16:04:42 <Moggle> but the problem is if I try for memoized_collatz(n * 3 + 1)
16:04:47 <Moggle> well I haven't solved for that already
16:04:56 <glguy> Moggle: I seem to remember that if you do a good job at the naive version it actually runs very fast, much less than the 20-second range
16:05:19 <neutrino> readTMVar will block until the tmvar is not empty, right?
16:05:32 <glguy> (I get that you've already solved it, but that's another opportunity for optimization)
16:05:40 <pqmodn> fmap: hmm, do you have any documentation about that?
16:05:51 <copumpkin> there are certainly many places where tail recursion is useful
16:05:54 <johnw> Moggle: did you add the trace statement?
16:06:00 <copumpkin> they just aren't all the same places that people expect from other languages
16:06:23 <neutrino> what places do people expect that don't work?
16:07:14 <copumpkin> well, a lot of people think that writing something that resembles foldl is tail recursion
16:07:22 <copumpkin> and that will have problems with accumulated thunks
16:07:54 <Moggle> http://codepaste.net/jjf8tb
16:07:58 <Moggle> this is my code for the naive version
16:07:58 <neutrino> why would they think that.. and why is that a common example?
16:08:03 <Moggle> and it took forever
16:08:11 <neutrino> naḯve
16:08:12 <copumpkin> so you need to be careful of laziness, and be aware of when it might pay to have different flavors of recursion that can produce results incrementally
16:08:25 <neutrino> copumpkin: ok
16:08:28 <copumpkin> neutrino: take a tail-recursive sum function over a list
16:08:31 <Moggle> maximum*
16:08:32 <copumpkin> how might a newcomer write that?
16:08:35 <Moggle> damnit i messed up on that code
16:08:59 <neutrino> well the most obvious way is to do sum (x:xs) = x + sum xs
16:09:07 <copumpkin> that isn't tail recursive :P
16:09:17 <copumpkin> I'm talking about how intuitions of tail recursion don't carry over from other languages
16:09:20 <johnw> Moggle: can you try using memoFix on "col"
16:09:20 <neutrino> why is it not tail recursive
16:09:28 <Moggle> http://codepaste.net/boajyh
16:09:33 <copumpkin> neutrino: because the recursive call is not in the tail position...
16:09:33 <Moggle> THERE that was my naive code
16:09:33 <johnw> i.e., map (memoFix col) [1..]
16:09:41 <Moggle> memoFix?
16:09:44 <Moggle> Never touched that before.
16:09:47 <Moggle> but alright
16:09:57 <johnw> one sec, i'll try it here
16:09:59 <neutrino> how would you write it tail recursively copumpkin
16:10:11 <pqmodn> neutrino: the last thing your sum function does is add. if it were tail-recursive the last thing it would do is call itself
16:10:25 <Moggle> What module is memoFix even in?
16:10:27 <alpounet> neutrino, using an extra arg to accumulate "the sum so far"
16:10:35 <neutrino> ok
16:10:44 <copumpkin> neutrino: the "naive way" that people would assume from other languages might be somethin like: sum = go 0 where go n (x:xs) = go (x + n) xs; go n [] = n
16:10:49 <pqmodn> neutrino: sum [] acc = acc; sum (x:xs) acc = sum xs (x + acc)
16:10:53 <alpounet> but then, you have to take care of not letting a bunch of additions stack up in the accumulator
16:11:00 <alpounet> so you have to make that accumulator strict
16:11:25 <neutrino> copumpkin: why would they assume that "from other languages"?
16:11:27 <alpounet> so that it's actually computed everytime the function calls itself
16:11:39 <neutrino> i don't know any other languages where you'd think of defining summation like this
16:11:41 <pqmodn> neutrino: because that's the way strict evaluation works
16:11:43 <copumpkin> neutrino: because that actually works in other languages that support tail calls
16:11:59 <neutrino> what other languages are you talking about copumpkin?
16:12:14 <copumpkin> scheme, C (with tail talls :P), etc.
16:12:20 <copumpkin> any other "functional" language
16:12:25 <neutrino> such as?
16:12:25 <pqmodn> scala, ML
16:12:30 * copumpkin sighs
16:12:35 <copumpkin> neutrino: what is your experience?
16:12:44 <copumpkin> do you know what a tail call is?
16:12:59 <copumpkin> if you don't, that might explain "I've never come across that definition"
16:14:01 <neutrino> well i'm just trying to understand the case here. so we're talking about people who are very experienced in either scheme, an esoteric subset of C, scala, or ML, but who also have no idea about lazy evaluation or who don't have enough general knowledge about functional programming to appreciate how lazy evaluation could end up building lots of thunks
16:14:14 <copumpkin> a large chunk of CS students have been through SICP for example
16:14:16 <copumpkin> in scheme
16:14:24 <neutrino> i'd wager a bet that this is not a big amount of people
16:14:28 <copumpkin> okay
16:14:31 <copumpkin> now you're just being nitpicky
16:14:50 <popl> copumpkin: Where are you?
16:14:52 <Saizan> neutrino: it's large enough that we've learnt to spot the pattern around here
16:15:00 <hpaste> glguy pasted “p14” at http://hpaste.org/79247
16:15:03 <neutrino> well, you supported your argument with a fairly synthetic example of a sum function
16:15:12 <neutrino> which is very unintuitive imo
16:15:20 <copumpkin> neutrino: yes, and I asked for tail recursion. If you don't know what that is, just say so, and don't start contradicting m
16:15:25 <neutrino> and as i understand you supported that by what i just described
16:15:33 <glguy> Moggle: that version runs in 3 seconds on my computer, at least
16:16:13 <copumpkin> neutrino: any CS student will have come across tail recursion. We get a lot of CS students in here, who expect that knowledge (and yes it is unintuitive) to carry over to haskell, because they've already struggled through that learning process
16:16:43 <pqmodn> as an example, it hadn't occurred to me until just now
16:16:51 <neutrino> ok so are we talking about programmers or students
16:16:57 <Moggle> glguy: that's... odd. Way slower on mine.
16:17:00 <neutrino> because there's a big chasm between the two imo
16:17:02 <Moggle> How exactly do I use +RTS -K100000 -RTS?
16:17:04 * copumpkin sighs
16:17:08 <hpaste> johnw pasted “collatz.hs” at http://hpaste.org/79248
16:17:15 <neutrino> i'd expect any kind of esoteric craziness from freshly baked students
16:17:22 <copumpkin> it's not esoteric
16:17:25 <johnw> Moggle: what's weird about that code is that collatz N just returns a list of N zeroes
16:17:36 <johnw> Moggle: and "length $ take 999999 collatz" returns instantly
16:17:49 <johnw> but "solution" is ultra-slow
16:17:52 <copumpkin> neutrino: anyway, my point is that intuition about tail recursion doesn't carry over. If you don't have intuition (or even a definition) of tail recursion, you are not in the target audience
16:18:14 <Moggle> that is VERY weird johnw
16:18:24 <glguy> johnw: your version of 'col' doesn't do anything put return 0 after computing the whole sequence
16:18:26 <johnw> heh, zip (take 10 collatz) [1..] doesn't terminate either
16:18:36 <glguy> but*
16:18:37 <Moggle> oh
16:18:40 <Moggle> that's because I forgot to do 1 +
16:18:42 <Moggle> derp
16:19:00 <copumpkin> neutrino: if you're going to go off on a tangent about how real programmers don't care and students learn esoterica, that's unrelated and I beg you not to go there
16:19:00 <neutrino> i think you're sort of not very good at this copumpkin ;)
16:19:09 <Moggle> in the place with col' ~n | mod n 2 == 0
16:19:12 --- mode: ChanServ set +o copumpkin
16:19:16 --- mode: copumpkin set +b *!~neutrino@p57AEA974.dip.t-dialin.net
16:19:16 --- kick: neutrino was kicked by copumpkin (talk to #haskell-ops)
16:19:19 --- mode: copumpkin set -o copumpkin
16:19:23 <Moggle> you want do 1 + col (n `div` 2)
16:19:25 <Moggle> but yeah
16:19:32 <Ptival> :)
16:19:40 <johnw> ah, that works
16:19:48 <Moggle> and 1 + col (n * 3 + 1)
16:19:53 <Moggle> but yeah how do I use +RTS -K100000 -RTS exactly?
16:19:57 <Moggle> or Ksize
16:20:00 <Moggle> not really sure what to put there
16:20:06 <Moggle> I assume it's a command line argument to ghc when compiling?
16:20:39 <johnw> ok, now I see the stack blow too
16:20:49 <johnw> -K10m
16:20:53 <johnw> for 10 megabytes
16:21:02 <popl> copumpkin: What was he implying you were not good at?
16:21:11 <elliott> getting trolled :P
16:21:17 <Moggle> And where does it go, johnw?
16:21:20 <popl> Ok. That's what I thought.
16:21:21 <Moggle> ghc?
16:21:33 <copumpkin> popl: I don't even know, but it's just the latest in a series of useless arguing for its own sake in here
16:21:45 <popl> No it isn't!
16:21:47 <johnw> you have to link like this:
16:21:47 <popl> :)
16:21:51 <johnw> ghc --make -rtsopts solution.hs
16:21:57 <johnw> ./solution +RTS -K1000m
16:22:03 <cmccann> arguing about *uninteresting things* you mean. interesting arguments for their own sake occur in here often.
16:22:06 <Moggle> ah, I se.
16:22:08 <Moggle> thanks
16:22:25 <johnw> what does maximum mean on tuples?
16:22:33 <johnw> the tuple with the largest member?
16:22:34 <popl> Arguments are carried out differently in my house.
16:22:45 <popl> The winner is determined by who yells loudest.
16:23:09 <shachaf> maximumOf each :: (a,a,...,a) -> Maybe a
16:23:20 <cmccann> popl, that's not a very good approach.
16:23:27 <cmccann> "who can keep yelling the longest" is much better.
16:23:43 <popl> hm
16:23:51 <popl> I'll bring it up to my father.
16:24:00 <Moggle> o.O still running out of memory
16:24:05 <Moggle> I probably messed up somewhere, but where
16:24:08 <popl> Moggle: More memory?
16:24:18 <merijn> cmccann: I usually am loudest + longest lasting, so yay!
16:24:19 <popl> RAM is cheap.
16:24:21 <Moggle> I did 1gb of memory :P
16:24:22 <pqmodn> copumpkin: not entirely useless, i learned a thing or two. though probably not from the arguing
16:24:32 <Moggle> If my code needs that muhc I'm doing something wrong
16:24:39 <popl> Nonsense.
16:25:07 <copumpkin> pqmodn: well, the things we were saying with content in them were getting said anyway. Most of his contribution was defining a non-tail-recursive version and me explaining how that didn't really change anything I was saying
16:26:02 <pqmodn> so in that example, leaving sum in non-tail call form is no less efficient than making it tail-call form but not strict, right?
16:26:28 <Moggle> collatz = foldl' (flip collatzMap) (M.singleton 1 0) [1..999999] doesnt work but collatz = foldl' (flip collatzMap) (M.singleton 1 0) [1..99999] does
16:26:32 <Moggle> in like a tenth of a second
16:26:39 <Moggle> why are you so fickle, haskell stack
16:26:50 <pqmodn> that is, both are building thunks at each iteration?
16:30:38 <coleman-> is there a reliable way to auto generate C bindings?
16:30:54 <johnw> Moggle: the recursion depth of 'col' can simply get very, very deep
16:31:20 <Moggle> yes but increasing the memory available to 1gb
16:31:23 <Moggle> still wasn't enough
16:31:26 <Moggle> it doesn't get _that_ deep
16:31:46 <johnw> see this version:
16:31:58 <hpaste> johnw pasted “Moggle.hs” at http://hpaste.org/79249
16:32:09 <johnw> that's about as simple as I can make it
16:32:16 <johnw> the blowing of stack is now solely the responsibility of 'col'
16:32:41 <Moggle> that darn col
16:32:54 <johnw> i'm going to have col report its recursion depth for each n
16:33:08 <Moggle> i swear it doesnt go much above 512 D:
16:33:13 <Moggle> i will triple check that with naive code one second
16:33:43 <glguy> Moggle: Shouldn't col have a recursion depth up to the answer to the problem?
16:34:03 <glguy> oh, never mind, the answer was "which number" and not "how deep"
16:34:27 <epta> Is there a name for an operation inverse to `map'? I.e. if `y = map x', 'x = _ y'?
16:34:53 --- mode: ChanServ set +o copumpkin
16:35:01 --- mode: copumpkin set -b *!~neutrino@p57AEA974.dip.t-dialin.net
16:35:04 <coleman-> "Warning: -#include and INCLUDE pragmas are deprecated: They no longer have any effect"
16:35:05 --- mode: copumpkin set -o copumpkin
16:35:10 <coleman-> why were they deprecated?
16:35:24 <Moggle> 	oh, never mind, the answer was "which number" and not "how deep"
16:35:30 <Moggle> you have to know how deep
16:35:33 <coleman-> what replaced them?
16:35:34 <Moggle> it is to figure out what number
16:36:19 <johnw> where is the functor instance for (,) e defined?
16:36:31 <shachaf> johnw: :i will tell you!
16:36:35 <nus> @src map
16:36:35 <lambdabot> map _ []     = []
16:36:36 <lambdabot> map f (x:xs) = f x : map f xs
16:36:44 <nus> epta, inverse that
16:36:57 <johnw> ah, Control.Monad.Instances
16:37:16 <epta> nus: I can't start even with signature
16:37:22 <Moggle> C:\Users\Drew\Desktop\hs>collatz
16:37:23 <Moggle> (524,837799)
16:37:25 <Moggle> so yeah
16:37:36 <Moggle> it SHOULD at maximum go 524 recursive calls deep
16:37:41 <Moggle> I don't think that should overload the stack
16:37:44 <Moggle> that doesn't seem like much :/
16:38:53 <nus> epta, it's destructs, applies a function, then constructs... how would  you describe an inverse operation?
16:38:57 <neutrino> copumpkin: *hug*
16:39:00 <nus> s/it's/it/
16:39:01 * copumpkin hugs neutrino 
16:39:06 <neutrino> :)
16:39:27 <johnw> interesting!
16:39:32 <johnw> it's not collatz or col that's blowing stack
16:39:37 <Moggle> :D
16:39:38 <epta> nus: f^-1
16:39:39 <johnw> it's the call to zip
16:39:42 <Moggle> ... oh
16:39:47 <johnw> collatz 999999 completes just fine
16:39:50 <Moggle> well that just makes me feel kind of stupid
16:40:05 <nus> epta, I mean, in plain english, inverse to what was described
16:40:07 <johnw> i don't think we even need that zipped structure
16:40:13 <Moggle> the reason I have it, john
16:40:17 <Moggle> is to get the number
16:40:18 <johnw> you just want the largest element which is larger than N, right?
16:40:30 <Moggle> maximum (collatz) returns the largest number of iterations it takes to get to 1
16:40:37 <Moggle> i want the index of that element in the collatz array
16:40:42 <Moggle> which is why I did the zip
16:41:10 <johnw> ok, one sec
16:43:03 <Moggle> its unfortunate Haskell doesn't just have a maximumIndex function
16:43:18 <Moggle> the elementIndex function is O(n) because lists are literally the devil
16:43:33 <newsham> if only there was a way to make a maxIndex function
16:43:44 <Moggle> newsham, what do I look like? Someone who isn't lazy?
16:43:52 <copumpkin> Moggle: maximumBy (comparing snd) . zipWith [0..]
16:44:28 <popl> Moggle: I don't know what you look like.
16:44:36 <Moggle> :(
16:44:40 <copumpkin> popl: are you going to popl?
16:44:42 <Moggle> I hope it's handsome.
16:46:21 <Moggle> I'm going to try making the zip code strict
16:46:24 <Moggle> and see how that turns out
16:46:26 <hpaste> johnw pasted “Moggle-fast.hs” at http://hpaste.org/79250
16:46:29 <johnw> there you go
16:46:43 <dolio> copumpkin: It's spelled popple: http://www.youtube.com/watch?v=IDFG2dI6y0I
16:46:45 <johnw> finds the answer in 6.5 secs
16:46:54 <johnw> so i'm sure you can optimizing that
16:46:55 <Moggle> not bad johnw :O
16:46:57 <Moggle> thanks!
16:47:03 <johnw> now I'll try adding memoization
16:47:10 <copumpkin> dolio: I learn so much in here!
16:47:36 * cmccann remembers those :T
16:48:25 <dolio> I bet those didn't make it over to Italy.
16:51:47 <Moggle> johnw, I improved on my code previously
16:52:15 <Moggle> http://codepaste.net/8dpjnk
16:52:23 <Moggle> uses Data.Map as opposed to Data.IntMap
16:52:30 <Moggle> and suddenly no more stack overflow
16:52:45 <Moggle> you can't see this right now but I'm staring at my command prompt with a look of disapproval
16:53:44 <johnw> memoization is hurting too, not helping
16:53:55 <hpaste> johnw pasted “Moggle-memoized.hs” at http://hpaste.org/79251
16:54:03 <Moggle> how are you even pasing like that?
16:54:08 <popl> copumpkin: What's popl?
16:54:15 <johnw> i use hpaste-current-buffer in Emacs
16:54:18 <johnw> just visit hpaste.org
16:54:30 <copumpkin> popl: the programming languages conference that's in rome this year
16:54:33 <Moggle> also, johnw, the reason the memoization is hurting
16:54:39 <popl> copumpkin: No.
16:54:45 <Moggle> is because !! means you're using a list
16:54:51 <Moggle> and lists are killing the efficiency horrifically
16:54:57 <johnw> but it's only a 1 million element list
16:55:07 <popl> copumpkin: I'm poor.
16:55:08 <Moggle> yeah but that's still some pretty bad O(n) checks
16:55:13 <Moggle> they can't be helping very much at all
16:55:15 <johnw> ah, thats' very true!
16:55:17 <popl> copumpkin: I've never been outside of the USA.
16:55:29 <johnw> let me try a vector instead
16:55:31 <Moggle> if there was a mutable array sort of data thing
16:55:36 <Moggle> I would love haskell forever
16:55:42 <johnw> of course there is
16:55:44 <Moggle> perhaps one could make an array of IO objects?
16:55:45 <johnw> Data.Array
16:55:49 <Moggle> o.O
16:55:51 <Moggle> that's mutable?
16:55:55 <Moggle> to the google!
16:55:57 <johnw> yes, it has an unsafe variant
16:56:00 <johnw> which is mutable
16:56:03 <johnw> same with Data.Vector
16:56:10 <johnw> caveat emptor
16:56:15 <Moggle> ... why do tutorials never mention any of this?
16:56:26 <johnw> because in general you don't need mutability
16:56:36 <elliott> They're not unsafe, are they?
16:56:37 <johnw> you only think you do because of the way you're used to thinking about problems :)
16:56:42 <elliott> I don't think mutable Vector is unsafe at least.
16:56:54 <Moggle> well, johnw
16:57:03 <Moggle> i'm not sure how you do memoization _without_ something mutable
16:57:06 <shachaf> johnw: There's a mutable variant of Array but that's not unsafe.
16:57:08 <Ralith> Moggle: if you actually need mutable stuff, which is rare, you probably want a STArray
16:57:08 <johnw> elliott: it precludes parallelization, which means you have to build in the safety manually
16:57:11 <Moggle> because it seems like using immutable maps is killing my efficiency
16:57:16 <shachaf> Moggle: Mutation happens all the time in evaluating Haskell.
16:57:20 <shachaf> Moggle: That's how laziness works.
16:57:20 <elliott> johnw: I think that's an unconventional definition of safety...
16:57:28 <elliott> johnw: Is MVar unsafe because it's mutable?
16:57:32 <johnw> Moggle: memoization can rely on the thunk evaluation mechanism of Haskell itself
16:57:40 <Moggle> with lists, johnw
16:57:44 <johnw> I just need to switch to a map-based memoziation scheme, rather than list-based
16:57:45 <Moggle> which as we have found out slow things down
16:57:58 <johnw> elliott: you have a point there
16:58:05 <Moggle> my map-based memoization is also very slow johnw
16:58:08 <elliott> I propose saying "mutable" instead :P
16:58:19 <johnw> Moggle: hold one
16:58:22 <cmccann> elliott, executing programs is unsafe fyi
16:58:25 <cmccann> the more you know
16:58:27 <johnw> http://www.haskell.org/haskellwiki/Memoization#Efficient_tree_data_structure_for_maps_from_Int_to_somewhere
16:58:29 <Moggle> i might be using Data.Map incorrectly though
16:59:58 <johnw> Moggle: http://stackoverflow.com/questions/3208258/memoization-in-haskell
17:00:14 <popl> stackoverflow is awesome
17:00:29 <popl> Except for the whole "your questions belong to us once you submit them" thing.
17:01:03 <Moggle> this is a very good link!
17:01:18 <popl> Moggle: That site is pretty great.
17:01:31 <popl> Except for what I mentioned above.
17:01:41 <Moggle> I've used it before for other languages
17:01:42 <Moggle> :P
17:01:45 <Moggle> It's even better for them
17:02:08 <Moggle> In any case, I have a serious issue with this tree business johnw
17:02:14 <Moggle> Why not hashtable it?
17:02:29 <Moggle> O(1) time to access any element
17:02:33 <Moggle> seems way better than O(log n)
17:03:07 <c_wraith> O(1) for hash tables is a lie.  They're O(log n) with really good constants
17:04:12 <Enigmagic> that also assumes hash functions are faster than equality or ordering tests
17:04:22 <Moggle> ... which still seems faster than O(log n) for trees
17:04:39 <Moggle> also hash functions for integers are pretty much just bitwise & if I recall Enigmagic
17:04:43 <tomeo> c_wraith: why is it O(log n)?
17:04:44 <Moggle> they are probably just as fast
17:04:50 <Enigmagic> Moggle: i can compare two integers faster than i can hash them
17:05:20 <Moggle> that seems wrong for some reason but I don't have enough knowledge of good hash functions to argue the point :P
17:05:24 <johnw> hmm..
17:05:27 <xplat> it's all the pointer lookups following tree branches (and the repetition of comparisons) that cost for integers
17:05:31 <Moggle> my experience with them has been quick hacks at programming contests
17:05:35 <johnw> using edwardk's memoization trick takes 10.7s
17:05:39 <Enigmagic> Moggle: processors are pretty fast at comparing numbers :-)
17:05:40 <johnw> so still slower than the naive approach
17:05:51 <Moggle> they're pretty fast at doing bitwise operations too!
17:05:57 <hpaste> johnw pasted “Moggle-edwardk_method.hs” at http://hpaste.org/79254
17:05:58 <edwardk> johnw: which one?
17:06:13 <c_wraith> tomeo: You have to consider the amount of time the hash function takes. If there are n elements in the table, the hash function must examine at least O(log n) bits of the value being hashed to put the new value into an unused bin in the table
17:06:30 <edwardk> yeah that was peculiar to the high amount of self-reference in the question the guy had on stackoverflow
17:06:38 <edwardk> it probably fails to be a win in general for things like collatz
17:06:46 <johnw> yeah
17:06:57 <johnw> the maintenance overhead is higher than just doing the recursive math
17:07:15 <johnw> well, i've got to go now
17:07:17 <Enigmagic> Moggle: yes, but there are fewer operations needed to compare vs hash. don't always assume hash tables are fast. it depends on the size of the collection, size of the data, time to compare, time to hash, etc
17:07:22 <johnw> hope that helped at least a little bit, Moggle!
17:07:32 <Moggle> you've been a TON of help johnw
17:07:36 <Moggle> also you do have a point there Enigmagic
17:08:02 <Moggle> when your hashtable is full and you have to rehash everything it's a huge timesink
17:08:05 <c_wraith> hash tables are O(1) if your keys are fixed-size.  But so are trees.  (with way worse constant factors)
17:08:12 <Moggle> trees do have the advantage of not being horrifically slow every once in a while
17:08:24 <Enigmagic> Moggle: in many cases a regular old C array and linear scan will beat out "faster" collections.
17:08:30 <c_wraith> eh, rebalancing a tree isn't fast either
17:08:38 <Enigmagic> Moggle: and no you do not, go look at linear hash tables
17:08:50 <Moggle> what, where collisions are basically handled with a linked list enigmagic?
17:08:56 <Twisol> Could I get some feedback on this Telnet parser implementation? <http://hpaste.org/79253> It works fine, but it's kind of ugly right now. I tried to make patterns I saw as obvious as possible, but I'm stuck at that actual refactoring part.
17:08:57 <Moggle> that degrades performance hugely over time
17:09:19 <Moggle> then again i may not know what i am talking about :P
17:09:21 <Enigmagic> Moggle: no
17:09:39 <Moggle> specialize implementations of hashtables are probably something I should learn before long
17:09:45 <Moggle> specialized*
17:09:56 <Enigmagic> Moggle: http://en.wikipedia.org/wiki/Linear_hashing
17:10:04 <xplat> if you have to do hashtables in real-time you could keep two tables and do an extra key in the new one on each operation
17:10:38 <Moggle> Enigmagic: oh that's clever
17:10:42 * cmccann notes that tries are technically O(1) if you ignore everything but the size of the collection
17:10:44 <Moggle> very very clever
17:10:58 <cmccann> which is exactly what people do when they say hash table operations are O(1) of course
17:11:02 <lucca> hmmm telnet
17:13:05 <xplat> cmccann: they also ignore the memory hierarchy when analyzing hashtables, which is silly because that's often the thing that really makes a hashtable faster in practice
17:13:11 <cmccann> yes
17:13:49 <xplat> it's kind of silly, like insisting a porsche is fast because it's red
17:14:02 <xplat> i mean, it really is fast, but not because it's red
17:14:19 <lucca> Twisol: your option identification is kinda weird
17:14:20 <neutrino> xplat: the mercedes le mans bolide was fast because it wasn't painted.
17:14:48 <Twisol> lucca: Oh?
17:14:48 <lucca> really 240..254 are the various commands from 854/855, and the things AFTER the do/dont/will/wont/sb are the options
17:14:58 <lucca> and options are... more numerous
17:15:12 <Enigmagic> xplat: you may find this interesting if you're concerned about memory bandwidth http://www.mpi-inf.mpg.de/~rgemulla/publications/schlegel09search.pdf
17:15:21 <roadfish> is haskell.org kind of dead for you too? I'm not getting http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Char.html
17:15:36 <neutrino> i was wondering, given the hackage downtime, is there a way to easily go from module name to file path using the command line?
17:15:52 <Enigmagic> xplat: AVX implementations are rather fast.
17:15:56 <roadfish> ah, I just saw the subject ... Hackagedown
17:16:04 <Twisol> lucca: Hmm. Are you concerned about the code itself or just my terminology? I just categorize commands as either simple commands or option-related commands.
17:16:11 <cmccann> xplat, judy arrays are interesting, in a horrifying complicated way
17:16:31 <cmccann> being some sort of elaborate wide-branching trie monstrosity full of special cases
17:16:36 <lucca> Twisol: fair enough. It's a terminology nit, so ignore it.
17:16:45 <lucca> Twisol: when you're ready, though... https://gist.github.com/2cd0f2f88686bc21218f
17:16:49 <xplat> Enigmagic: intriguing!
17:17:00 <Twisol> lucca: Hah. Yeah.
17:17:01 <Moggle> There isn't a Haskell third-party-library package manager by chance, is there?
17:17:12 <Moggle> Like, Ruby has rubygems
17:17:17 <Moggle> Python has pip or something I hate python
17:17:28 <Twisol> lucca: I've seen the IETF list of registered options before, actually. :)
17:17:28 <shachaf> Those aren't really package managers, are they?
17:17:35 <Twisol> or rather, IANA
17:17:36 <lucca> Twisol: I've got more in there than they do
17:17:42 <roadfish> Muggles would hate Python. Is that snake magic thing.
17:17:50 <Twisol> lucca: Indeed, you have MUD options. :D
17:17:56 <Moggle> rubygems downloads third party libraries, can download updates for them and can remove them
17:18:00 <Moggle> it seems like a package manager to me :P
17:18:07 <Moggle> in any case is there anything equivalent for Haskell?
17:18:18 <cmccann> Moggle, do you mean aside from cabal and hackage?
17:18:24 <X-suriV> LOL topic saved me the trouble of asking  :P
17:18:27 <Moggle> "aside" implies I knew of either
17:18:28 <X-suriV> Hackage down...
17:18:32 <lucca> Twisol: working on a telnet client that works like tf+screen by using js (via Fay) and a websocket server.
17:18:37 <cmccann> holy crap someone read the topic before asking?!?!
17:18:50 <roadfish> Are you asking for some replacement while Hackage is down?
17:18:57 <cmccann> Moggle, I figured you would have heard about it because of the current situation with hackage being down :P
17:19:05 <Moggle> ohey, I have cabal on my command line
17:19:07 <Moggle> fascinating
17:19:29 <X-suriV> I will ask this then: Leksah complains when I try to import System.Directory , says it cant find it, its a member of a hidden package...is that something that change recently?
17:19:29 <shachaf> @google how to install a haskell package
17:19:31 <Twisol> lucca: Interesting. I'm working on a browser-based telnet client that uses Telnet over a WebSocket.
17:19:31 <lambdabot> http://www.haskell.org/haskellwiki/Cabal/How_to_install_a_Cabal_package
17:19:31 <lambdabot> Title: Cabal/How to install a Cabal package - HaskellWiki
17:19:35 <shachaf> thanks google
17:19:38 <Moggle> cabal install hashtables would install
17:19:40 <Moggle> oh there's a wiki page?
17:19:44 <Moggle> screw the wiki I dont need no wiki
17:19:50 <lucca> Twisol: Well then.  That might be relevant to my interests.
17:19:52 <popl> "don't need no"
17:19:56 <popl> correct
17:19:56 <Moggle> :D
17:19:57 <cmccann> Moggle, cabal is a build system and packaging thingie whatsit, hackage is the package repository that the cabal command line program downloads from
17:20:11 <Moggle> Cabal is exactly what I was asking about
17:20:13 <Moggle> :P
17:20:16 <Moggle> It seems to be exactly what I wanted
17:20:21 <Moggle> course with hackage down
17:20:24 <Moggle> it's apparently not working
17:20:25 <cmccann> heh
17:20:38 <popl> Cabal is a good book.
17:20:38 <X-suriV> is System.Directory not included in GHC anymore?
17:20:38 <cmccann> it will work just fine as long as you have everything you need installed!
17:20:49 <Twisol> lucca: Well, it's not implemented in Haskell - it uses JS client-side, not Fay. This Haskell impl is more for my own self-learning.
17:21:07 <fmap> X-suriV: it's in directory
17:21:07 <Twisol> lucca: but I'd be interested in collaborating on some level regardless!
17:21:16 <roadfish> I did download the 200MB http://hackage.haskell.org/cgi-bin/hackage-scripts/archive.tar ... but I don't see Data.Char there. Is that tarball only for extensions?
17:21:33 <fmap> X-suriV: (directory is distributed with ghc)
17:21:46 <roadfish> popl: Cabal is a book?
17:22:08 <popl> roadfish: It's a novella by Clive Barker.
17:22:12 <popl> *the title of a
17:22:29 <roadfish> ok, a little joke
17:22:29 <popl> roadfish: The film _Nightbreed_ was based on the story.
17:22:29 <lucca> Twisol: other than research on options and the q negotiation thing, I haven't implemented much telnet level stuff yet, so I don't have much to offer you
17:23:16 <Twisol> heh, q. That's… "fun" to implement
17:23:19 <roadfish> one time I was reading something on functional programming and they said that Ken Osmond was an important Haskell researcher.
17:23:22 <lucca> just a local talk thing from the websocket demo plus better unicode normalization: http://www.accela.net/lucca/img/wstest.png
17:23:31 <lucca> but yes, haskell client and server side.
17:23:48 <Twisol> lucca: Iron Realms has WebSocket proxies you can connect directly to, by the way.
17:24:20 <lucca> That's worth playing with, but I'm hoping to make a more generalized client for the MUSH community
17:24:25 <roadfish> lucca: haskell client. is this in the web browser or some app to get data, like from a web api?
17:24:46 <Twisol> lucca: Me too, but it's easier to work with infrastructure that's already there. ;)
17:24:58 <lucca> roadfish: js+html5 websockets in a browser; Fay lets you compile (a subset of) Haskell into javascript
17:25:20 <roadfish> nice
17:25:41 <Twisol> lucca: implementing my own proxy means figuring out how to pass the client's IP along to the MUD, since so many of them like that information
17:26:03 <roadfish> I was thinking about getting a Nexus 7 and I was wondering if is easy to use Haskell on it.
17:26:05 <lucca> Twisol: there's a telopt for that
17:26:20 <roadfish> Maybe could get through web browser on Nexus 7
17:27:02 <Twisol> lucca: Yeah. My problem is that people don't want to modify their already-likely-broken telnet stacks. :/
17:27:23 <X-suriV> fmap: well I try and call doesFileExist it says it isnt in scope, so I try adding an import for System.Directory in leksah, and it complains that it's a member of a hidden package
17:27:44 <lucca> Twisol: MUDs are usually better about that than other servertypes, but it depends.
17:27:56 <lucca> also, they might not want to trust your information
17:28:37 <Twisol> lucca: yeah, that was the other problem. Having some kind of authentication for the proxy forwarding the IP/
17:29:06 <byorgey> X-suriV: you need to add 'directory' to the build-depends: field in your .cabal file
17:29:09 <Twisol> I figured it would be easier to develop a proxy that they could install and control themselves
17:29:15 <fmap> X-suriV: yeah, you probably need to .. yes
17:29:21 <lucca> Twisol: I intend to address that by having them register local accounts that persistently store their connection/terminal state.
17:29:23 <neutrino> hmm, the packages you have installed don't usually live anywhere in unpacked state, do they?
17:29:34 <lucca> closing and reopening the browser will be like re-attaching with screen
17:29:47 <byorgey> neutrino: the sources? no
17:30:05 <byorgey> neutrino: the tarballs are usually cached in ~/.cabal/
17:30:26 <byorgey> neutrino: so you can 'cabal unpack' and get the source
17:30:33 <byorgey> even if Hackage is down
17:30:34 <neutrino> yeah, i know about those.. just trying to figure out a way to quickly go from having the module name to having the source open in vim
17:30:43 <byorgey> oh, I see
17:31:01 <neutrino> i guess doing unpack every time is a bit wasteful
17:31:08 <lucca> still using the basic server included in the Websocket package though.  Need to graduate to yesod or something, but I was focused on client issues so far.
17:31:14 <neutrino> you can open .tar.gz in vim without an issue
17:31:23 <Twisol> lucca: It's funny, what you're doing is identical to my original design.
17:31:42 <neutrino> but then every module might be in a different file in the package.. and that's a mess
17:31:43 <Twisol> lucca: Not funny in a bad way. Just funny. :D
17:33:01 <lucca> There have been a number of web-based terminal clients with various technologies; java, flash, ajax...  most still try to contact only the running server directly from the browser, which doesn't help people circumvent firewalls.
17:33:19 <neutrino> so there's probably not a good way, i'll just retort to cabal unpack
17:33:22 <neutrino> thanks byorgey
17:33:22 <lucca> We have a holy obligation to let people play muds from behind work firewalls :D
17:33:33 <shachaf> I think #haskell-web probably would know more about this topic than #haskell.
17:33:46 <Twisol> lucca: Absolutely. :D
17:34:07 <lucca> shachaf: good idea.  Didn't know there was such a thing.  Thanks!
17:35:20 <roadfish> is there a list of other Haskell channels?
17:35:41 <popl> roadfish: /list
17:35:58 <glguy> On Freenode you use the "alis" bot to search channels
17:36:13 <glguy> roadfish: I don't know if there is a webpage that lists them all
17:36:16 <popl> glguy++ #helpful
17:36:21 <popl> popl-- # not
17:39:51 <roadfish> alis haskell
17:49:54 <andyjgill> Any news regarding the ETA of hackage?
17:55:38 <sw2wolf> Suppose there is a Money.hs module which manipulates a data file "money.dat" in the same directory "DIR-1". Because it is using relative path, i have to `cd` to DIR-1 to make money.dat visible to this module.  Now if i `ghc-pkg register` this module, can i make money.dat visible to Money.hs no matter where the current directory is ?
17:59:01 <pk-nb> ping adimit
17:59:58 <geekosaur> sw2wolf, no.  cabal-install can autogenerate a Paths module for a program, but not for a library
18:00:12 <Peaker> geekosaur, are you sure? I think I'm using it for a library
18:00:32 <Peaker> I am indeed using it successfully in a library
18:00:46 <geekosaur> "A library cannot (currently) be prefix-independent, because it will be linked into an executable whose file system location bears no relation to the library package." quoth the cabal documentation
18:00:52 <geekosaur> maybe it's out of date...
18:00:56 <byorgey> sw2wolf: see http://www.haskell.org/cabal/users-guide/developing-packages.html#accessing-data-files-from-package-code
18:00:59 <Peaker> I just have to mention the Paths_LibName in my Other-modules section
18:01:44 <Peaker> maybe it working is an accident, but it works on both Windows and Linux :)
18:01:51 <Peaker> or more likely the docs are out of date
18:01:58 <geekosaur> ok, maybe that;s not referirng to quite the same thing (also I was having trouble finding the thing byorgey just linked from the section on installation paths; there is at least one dead link in that section that probably should point to that...)
18:03:15 <coleman-> how come puts from C library works when I declare it as CString -> IO Int but not if I declare it as CString -> Int ?  How does haskell limit if C function does pure or impure stuff?
18:03:44 <hpc> coleman-: foreign import doesn't have any damn clue whether a C function is pure or impure
18:03:57 <shachaf> coleman-: "not works" is not a description of something something does.
18:04:00 <coleman-> hpc yeah. so why does one work and other doesn't?
18:04:00 <Peaker> coleman-, More likely, laziness is avoiding the call entirely
18:04:07 <Peaker> coleman-, in your "not works" example
18:04:09 <coleman-> nothing is printed
18:04:13 <sw2wolf> thanks for all your suggestion ! I just want to find thing similar to  CL: (namestring (asdf:system-relative-pathname 'money "money.dat"))
18:04:16 <coleman-> I see
18:04:17 <shachaf> Well, did you run any code?
18:04:17 <hpc> your second, pure foreign import
18:04:25 <hpc> is equal to unsafePerformIO . (first import)
18:04:38 <coleman-> I called c_puts in main yes
18:04:45 <X-suriV> you can use C libraries in Haskell? O_O
18:04:49 * X-suriV is newer to haskell
18:04:50 <coleman-> whether lazy thing got to me I don't know
18:04:56 <sipa> X-suriV: sure, look up FFI
18:05:01 <hpc> X-suriV: https://duckduckgo.com/?q=haskell+ffi
18:05:08 <hpc> it's quite handy
18:05:30 <X-suriV> oh wow this is awesome
18:05:32 <shachaf> coleman-: Unfortunately this channel has not yet learned to read minds, so you might have to mention what code you're actually using.
18:05:39 <Peaker> Unfortunately, you have to define all structs and fields tediously
18:05:49 <coleman-> doesn't matter
18:06:04 <coleman-> forget about puts. say I have a hello function in C that accepts no arguments and modifies a global variable. I could call that function in a pure haskell code?
18:06:25 <Peaker> and I find that it's missing basic combinators like:  asPtr x f = alloca $ \ptr -> poke ptr x >> f ptr
18:06:48 <Peaker> coleman-, that is very likely a very bad idea
18:07:02 <Peaker> coleman-, Modifying or even reading a global variable means your function is not pure
18:07:08 <coleman-> Peaker sure, but it can be done?
18:07:18 <coleman-> meaning a pure function is not really guaranteed to be pure?
18:08:05 <Peaker> coleman-, well, in a sense, yes, but GHC will be free to get rid of the call.. GHC may not evaluate the thing you need for the side-effect
18:08:16 <coleman-> that's a bit of a downer
18:08:17 <SLi> Well, in FFI, you give the guarantee to the compiler by marking a C function pure, not the other way. (And it still might be pure even if modifies a global variable, if that variable can have no observable effect on the Haskell code.)
18:08:20 <Peaker> coleman-, laziness keeps you honest
18:08:28 <Peaker> coleman-, why would you want to modify a global variable in a pure function??
18:08:41 <shachaf> coleman-: If you lie to the FFI and tell it a function is pure which isn't pure, it'll believe you.
18:08:43 <Peaker> coleman-, preventing this kind of thing is a *benefit* :)
18:08:50 <coleman-> I don't, the point is that you can. hence there's no real guarantee that a haskell function is pure
18:09:03 <SLi> Peaker, a common reason would be to cache things.
18:09:05 <shachaf> That's right, the FFI lets you lie.
18:09:23 <Peaker> SLi, yeah, there are some rare, legitimate purposes (e.g: ugly-memo package)
18:09:30 <shachaf> In general the point of purity is to protect you from yourself, not from malicious attackers.
18:09:49 <Peaker> coleman-, ah, well, since you sometimes need to resort to impure primitives to build fast pure ones, the compiler needs to trust some code..
18:09:50 <elliott> (See Safe Haskell.)
18:09:58 <SLi> coleman-, a haskell function is pure, subject to the validity of your purity annotations of C functions.
18:10:00 <shachaf> coleman-: The existence of unsafePerformIO is not new. :-)
18:10:01 <elliott> You can violate purity more easily anyway:
18:10:05 <elliott> @hoogle unsafeperformIO
18:10:06 <lambdabot> System.IO.Unsafe unsafePerformIO :: IO a -> a
18:10:06 <lambdabot> Foreign unsafePerformIO :: IO a -> a
18:10:26 <coleman-> I guess they couldn't have done it in a different way, since some C functions are pure and they need to be accessed from haskell
18:10:31 <cmccann> wasn't unsafePerformIO technically part of the FFI anyway?
18:10:39 <elliott> cmccann: shhh
18:10:43 <cmccann> as in, using it for pure FFI calls was the original purpose :P
18:10:47 <coleman-> just a bit of a downer that there's no total guarantee as I thought until now
18:12:15 <cmccann> coleman-, there's always agda! :D
18:12:22 <shachaf> Do you think the language would be better if there was a total guarantee?
18:13:04 <rwbarton> one can't guarantee that I didn't go around scribbling over code with a Ptr prior to calling your function either
18:13:32 <cmccann> one also can't guarantee that GHC doesn't have some bug which will introduce side effects to code that should be pure
18:13:41 <rwbarton> Haskell is too systems-y for this kind of guarantee
18:13:46 <parcs> one also can't guarantee that a cosmic ray will flip a bit
18:14:01 <shachaf> CosmicRa`...
18:14:21 <Peaker> coleman-, some Haskell functions are pure and built from IO actions
18:14:33 <Peaker> coleman-, (similarly to some C functions being pure)
18:15:33 <coleman-> I guess with C and all potential nasty errors that come with it guaranteed purity isn't your biggest concern
18:16:21 <shachaf> (Are you flipping bits again?)
18:16:26 <coleman-> but I'm curious how does agda do it? all the C calls are in IO (or whatever it's equivalent is)
18:16:57 <Peaker> Agda depends on the programmer not lying too, I suppose
18:17:16 <SLi> Agda is practical enough to have FFI?
18:17:18 <shachaf> @quote runtime.*gda
18:17:19 <lambdabot> cmccann says: the most common solution to prevent runtime errors in Agda is by not running the program
18:17:53 <cmccann> :D
18:18:02 <elliott> Agda lets you unsafely FFI to Haskell, I think.
18:18:11 <dolio> Yes.
18:19:33 <SLi> If you want to be sure, you can always put all your C calls in the IO monad. And actually that's one of the more important reasons for unsafePerformIO: You have a bunch of low-level, side-effecty bindings to C functions in the IO monad, and after you have built a Haskell function around them that you believe is free of any possible side effects, you typically would like to get rid of the IO monad.
18:19:42 <SLi> At least that's how I understand it.
18:20:06 <Peaker> Hmm.. I'm not getting a compilation error when I put:  Typeable (m ())   in my function's type's context, despite not enabling FlexibleContexts, how come?
18:20:17 <SLi> Another way would be to write the glue code in C and make side-effect free C functions, but actually Haskell tends to be quite a nice language for that glue code.
18:20:43 <dolio> No, the point of unsafePerformIO with regard to FFI is that you may have to do some stuff with pointers to interface with a pure-ish C function, and the pointer stuff will force you into IO.
18:20:51 <dolio> On the Haskell side.
18:21:23 <dolio> Then you unsafePerformIO because you know that it's actually pure externally, and the pointer stuff was only for interfacing.
18:21:32 <SLi> Which I believe is another way of saying exactly what I said? :)
18:21:33 <Peaker> or you are implementing memoization
18:21:41 <Peaker> which is pure, but uses effects inside
18:22:00 <dolio> No, you said the C code has side effects.
18:22:06 <simpson> Is there any downside to a custom monad for FFI work, besides that MonadIO isn't in base?
18:22:35 <SLi> Ah, yes. Right. We're talking about different scenarios.
18:22:42 * cmccann suspects that the biggest benefit of purity in haskell is not that it forces programmers to use pure functions, but that it teaches programmers to WANT to use pure functions
18:23:10 <parcs> agda has postulates doesn't it? which in agda land is as bad as unsafePerformIO in haskell land, i think
18:23:40 <copumpkin> no
18:24:06 <dolio> It has postulates, but they're nothing like unsafePerformIO.
18:24:09 <copumpkin> postulates don't evaluate
18:24:20 <copumpkin> they're like implicit parameters
18:24:30 <hpc> postulates are basically specific instantiations of undefined
18:24:46 <hpc> (i think)
18:24:58 <Saizan> what are postulates compiled into, actually?
18:25:11 <parcs> i was comparing them relative to the merits of the respective programming language
18:25:25 <copumpkin> I think it just refuses to compile stuff with postulates
18:25:33 <SLi> dolio, but I'm not sure I'm incorrect ;) What if the C code you want to interface is _not_ pureish? I've seen Haskell code that does something like initClibrary :: Something -> IO LibHandle, uninitClibrary :: Something -> IO LibHandle etc., and functions to manipulate some objects inside that library. I think using unsafePerformIO to wrap a function that is externally pure that uses those is a very good use of unsafePerformIO.
18:25:45 <hpc> it'll compile postulates
18:25:49 <copumpkin> unless they're bound with a pragma
18:25:50 <hpc> it has to, for foreign imports
18:25:56 <hpc> ah, hmm
18:26:08 <rwbarton> -fdefer-proofs
18:26:13 <cmccann> haha
18:26:58 <hpc> -XLiveForDanger
18:27:01 <shachaf> -fexercise-for-the-reader
18:27:08 <SLi> dolio, like, a disassembler library written in C. You need to initialize the library, do all kinds of impure manipulation etc., but still it makes sense to have a pure Haskell function disassembleBytes :: ByteString -> String.
18:27:18 <dolio> SLi: It depends whether you're talking about uses of unsafePerformIO that are arguably okay, or uses for unsafePerformIO that actually got it justifiably included into the FFI spec.
18:27:34 <SLi> Ah :)
18:27:48 <dolio> There are a lot more of the former.
18:28:30 <cmccann> and then there are uses that don't even try to be okay, like Debug.Trace :D
18:28:44 <cmccann> unsafePerformPrintfDebugging
18:28:55 <binroot> I was reading a tutorial that said haskell's if statement is lazy: if a then b else c
18:29:02 <binroot> but isn't java and C++ also lazy in that sence
18:29:04 <binroot> sense*
18:29:06 <binroot> ?
18:29:21 <shachaf> Yes.
18:29:23 <Peaker> binroot, yeah, they are
18:29:27 <binroot> k
18:29:32 <copumpkin> yup, although as an expression it's more like the ternary operator
18:29:40 <shachaf> In Haskell, if could be implemented as a regular function (though it's not).
18:29:48 <Peaker> binroot, difference is that in Haskell you can write:  myIf p x y = ... and that would behave the same (apart from syntax)
18:30:01 <binroot> ooo ok
18:30:08 <byorgey> binroot: yes.  The interesting point is that... what shachaf said.  In C++ and Java it has to be a special built-in thing.
18:30:10 <Peaker> I wonder, how does Agda mixfix syntax do currying?
18:30:28 <byorgey> binroot: more generally, laziness makes it convenient to define your own new control constructs in Haskell, just as regular functions
18:30:28 <Peaker> Do you call it with its explicit name to get currying?  i.e:   (if_then_else_ foo) ?
18:30:32 <binroot> I see, so it's just a special case in Java and C++, but haskell has it innate
18:30:32 <coleman-> just out of curiosity, what prevented incorrectly declared puts as pure from working in here? http://hpaste.org/79256
18:30:36 <dolio> SLi: The latter is more restricted to cases like, "it's impossible to interface with any pure operations written on strings in C and give them pure types without unsafePerformIO."
18:30:36 <cmccann> the important difference is that in haskell, five people will explain the same thing to you in as many seconds on IRC
18:30:43 <copumpkin> Peaker: yeah, although there is some talk of "sections"
18:30:46 <copumpkin> but it sounds complicated
18:30:47 <byorgey> binroot: right
18:30:56 <byorgey> cmccann: hehe
18:31:07 <shachaf> copumpkin: You should always specify what happens, instead of "it didn't work".
18:31:13 <shachaf> s/copumpkin/coleman-/
18:31:22 <rwbarton> what's a leman-?
18:31:24 <shachaf> coleman-: In this case you never actually evaluate «puts ...».
18:31:44 <shachaf> Try it out: main = do { ...; return $ error "HELP!"; ... } will never print an error.
18:31:45 <cmccann> rwbarton, not a pumpkin, I suppose
18:31:54 <coleman-> shachaf I see
18:32:15 <elliott> I guess with mixfix you could have "if then x eles y"
18:32:15 <shachaf> You can do something like do { ...; c_puts str `pseq` return (); ... }
18:32:18 <elliott> *else
18:32:48 <shachaf> But this is kind of unreliable and you certainly shouldn't use it without having a good idea of how Haskell gets evaluated.
18:33:05 <shachaf> (You can use `seq` instead of `pseq`, I guess.)
18:34:59 <coleman-> that worked. so did printing returned value
18:35:45 <parcs> > undefined :: ()
18:35:47 <lambdabot>   *Exception: Prelude.undefined
18:37:39 <rwbarton> if I have "newtype X = X X", what is GHC's runtime representation of X like?
18:39:07 <parcs> it probably doesn't have one
18:39:58 <byorgey> what, of course it does
18:40:34 <byorgey> though I don't know precisely what it is
18:42:32 <cmccann> rwbarton, probably about the same as its runtime representation of "data X".
18:42:40 <rwbarton> hmm
18:42:55 <rwbarton> that is a good question too
18:42:59 <Peaker> Would be nice to be able to auto-derive Binary instances even when you need a constraint
18:43:11 <parcs> yeah, i meant what cmccann said :P
18:43:21 <Peaker> data MyMap k = MyMap { .. m :: Map k Int }
18:43:31 <Peaker> derive makeBinary ''MyMap <-- will fail :-(
18:44:36 <rwbarton> I guess any value of these types must be an uncomputed thunk and there must be a uniform representation for values-that-are-thunks
18:44:38 <coleman-> is there something like withCString for several strings?
18:45:08 <Peaker> coleman-, multiple withCStrings? :)
18:45:11 <parcs> nest the calls
18:45:11 <rwbarton> @hoogle withMany
18:45:11 <lambdabot> Foreign.Marshal.Utils withMany :: (a -> (b -> res) -> res) -> [a] -> ([b] -> res) -> res
18:45:28 <Peaker> @type withCString
18:45:30 <lambdabot> Not in scope: `withCString'
18:45:30 <rwbarton> if you have a whole list's worth
18:45:41 <coleman-> thanks
18:46:25 <Peaker> You could have: withCString :: String -> ContT a IO CString
18:46:33 <Peaker> and then "withMany" is sequence :)
18:48:30 <Peaker> if "withMany" did not take [a] and (a->) but instead took the pre-applying the (a->) to yield:  withMany :: [(b -> res) -> res] -> ([b] -> res) -> res
18:48:36 <Peaker> then the Cont-ness becomes more evident
18:49:05 <Peaker> withMany :: [Cont res b] -> Cont res [b]
18:49:19 <Peaker>  = sequence
18:50:48 <coleman-> nested withCString don't look half bad with omitted parenthesis
18:54:04 <coleman-> withCString "foo" $ \ s1 ->\nwithCString "bar" $ \ s2 ->\nc_func s1 s2
18:55:17 <Moggle> is there any way to do multiple lets on one line?
18:55:17 <Moggle> like say
18:55:17 <Moggle> let x = 2, y = 3 in x + y
18:55:17 <Moggle> ?
18:55:17 <shachaf> Yes, with semicolons.
18:55:17 <Moggle> so that would be
18:55:17 <simpson> > let x = 2; y = 3 in x + y
18:55:17 <Moggle> let x = 2; y = 3 in x + y
18:55:17 <lambdabot>   5
18:55:19 <Moggle> ah, thank you very much
18:55:28 <shachaf> You should read about how Haskell layout works. :-)
18:56:04 <Moggle> maybe after i solve these silly triangular numbers
18:56:16 <Moggle> they're throwing dynamic programming problems at me and they're too easy
18:56:46 <shachaf> Oh, you're the "project euler" person. :-(
18:57:04 <shachaf> Well, that question wasn't related to that.
19:02:12 <coleman-> my ffi functions work in GHCI but I get "undefined reference" errors when trying to compile the code with GHC. am I suppose to manually link C code somehow?
19:02:56 <Nereid> oh, hackage is down.
19:03:27 <X-suriV> is there any place where one can get Haskell swag like tshirts etc etc
19:03:41 <shachaf> coleman-: The same thing I said before holds. :-)
19:04:06 <shachaf> coleman-: When you ask a question, you should specify (a) what you did (b) what you expected (c) what happened
19:04:19 <shachaf> Otherwise people have to guess at what you mean, and there are so many different possibilities.
19:05:01 <byorgey> X-suriV: yes, see http://www.haskell.org/haskellwiki/Merchandise
19:05:07 <slack1256> X-suriV: sometimes at talks you could get stickers.
19:05:19 <cmccann> hey shachaf my code didn't work can you please fix it for me?
19:05:46 <shachaf> cmccann: Done.
19:05:48 <coleman-> I thought my question was clear? my ffi function works fine in GHCI but not in GHC, I get undefined reference (to that C function) error.
19:05:52 <cmccann> awesome!
19:05:56 <coleman-> when compiling with GHC
19:05:58 <shachaf> coleman-: No, it wasn't clear.
19:06:30 <shachaf> Please specify: What code you're using; what command you ran; what error you got (the full error, not two words from it)
19:06:32 <Twisol> Would anyone care to provide some feedback on my Telnet parser? <http://hpaste.org/79260> There are obviously a lot of patterns, but I'm not sure how to exploit them to make the code cleaner.
19:07:01 <coleman-> that should not be relevant. I am getting linking errors because C library isn't linked
19:07:29 <parcs> coleman-: what's the C function
19:08:04 <shachaf> How would you know whether it's relevant? The thing about things we can't figure out is that they often don't work the way we expect, and the solution is often not where we thought to look.
19:08:11 <shachaf> If it was, we wouldn't have trouble figuring them out.
19:08:24 <shachaf> (Also, this is general question-asking etiquette.)
19:09:57 <Moggle> Do let statements not work inside lambas?
19:09:58 <Moggle> if so, this is terrible
19:10:15 <shachaf> Moggle: They do. More importantly, let expressions do.
19:10:24 <Moggle> http://codepaste.net/8yoo4e
19:10:27 <slack1256> Moggle: they do.
19:10:30 <Moggle> then why is it so whiny about line 5's equal?
19:10:42 <Moggle> "parse error" likely means I messed up somewhere
19:10:57 <shachaf> That code is too complicated for for me to understand.
19:11:00 <parcs> perhaps you're missing a parens
19:11:04 <shachaf> I don't blame GHC for not liking it.
19:11:07 <parcs> but wow that is one ugly line
19:11:11 <slack1256> Moogle: a tab
19:11:13 <Moggle> I take offense to that parcs
19:11:19 <Moggle> It's a beautiful line
19:11:35 <Moggle> Where should I put the tab, slack?
19:12:11 <slack1256> Moggle: I tidying up that file, give me a sec
19:12:13 <shachaf> Moggle: Instead of that, take your lambda and separate it out into its own multi-line function.
19:12:17 <slack1256> it should be clear when i am done
19:12:25 * geekosaur 's eyes are bleeding...
19:12:28 <parcs> oh, right. you need to line up mx with tri
19:12:37 <Moggle> oh
19:12:37 <shachaf> That's also true.
19:12:39 <Moggle> durrrr
19:12:40 <latro`a> uh
19:12:44 <latro`a> yeah
19:12:44 <shachaf> But you shouldn't use a tab for that. You should use spaces.
19:12:53 <latro`a> that was what I noticed first >.>
19:12:54 <Nereid> never use tabs.
19:13:07 <Moggle> blame notepad++!
19:13:22 <shachaf> No, I blame you for writing that long line.
19:13:25 <shachaf> Please split it out.
19:13:25 <parcs> it's much more amusing to blame the user instead
19:13:44 <Moggle> :D
19:13:45 <shachaf> Moggle: Also, you're using lists wrong. You should basically never use length and (!!).
19:13:49 <cmccann> holy rolling shitballs that is a horrifying line of code.
19:13:52 <shachaf> Or, at least, no more than one per list.
19:13:55 <cmccann> please don't use (!!) like that.
19:13:56 <cmccann> or ever.
19:14:04 <Moggle> FINE i'll split it into first and last
19:14:15 <Moggle> uh, I hope it's first and last
19:14:32 <shachaf> Oh, this is "project euler" again.
19:14:35 <shachaf> I'm still boycotting that.
19:14:42 <Moggle> aha!
19:14:44 <Moggle> head
19:14:53 <Nereid> > zip`ap`tail $ [1..10]
19:14:55 <lambdabot>   [(1,2),(2,3),(3,4),(4,5),(5,6),(6,7),(7,8),(8,9),(9,10)]
19:15:51 <copumpkin> @quote aztec
19:15:52 <lambdabot> quicksilver says: zip`ap`tail - the Aztec god of consecutive numbers
19:15:52 <latro`a> :t (<*>)
19:15:53 <Nereid> oh I suppose that doesn't help much.
19:15:53 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
19:16:08 <slack1256> Moggle: wow, i don't any idea of what mx does!
19:16:08 <cmccann> Moggle, you should probably avoid using head and tail as well.
19:16:17 <cmccann> it's a bad habit, especially for a beginner.
19:16:23 <Moggle> ...
19:16:26 <Moggle> gosh darnit cmcann
19:16:29 <shachaf> Solving "project euler" problems is also a bad habit for a beginner.
19:16:30 <lispy> folks, instead of telling people what not to do, it's much better to show examples of what to do
19:16:30 <Twisol> ^_^
19:16:33 <Moggle> http://projecteuler.net/problem=18
19:16:37 <Moggle> slack
19:16:50 <cmccann> shachaf why you gotta hate
19:16:51 <latro`a> it's best to use matching for problems like this
19:17:10 <Moggle> mx is the basically the array showing the biggest-possible path
19:17:15 <Nereid> should we mention the hackage mirror in the topic? http://hdiff.luite.com/
19:17:17 <Moggle> its a 2d array of the triangle
19:17:26 <Moggle> it's built from the ground-up
19:17:28 <Moggle> basic dynamic programming
19:17:29 <Twisol> change of tack - anyone know where I can go for a brief code review of my Telnet parser?
19:17:37 <slack1256> Moggle. I made that example with a foldr
19:17:42 <slack1256> i guess i still got the file
19:17:48 <slack1256> I could post it
19:17:53 <latro`a> dynamic programming in haskell is clearer when not done in a style that imitates iterative style
19:18:04 <Moggle> well latro, that would be the problem
19:18:08 <Moggle> since it's where I'm coming from
19:18:14 <Moggle> if you want to post it, slack, I'd appreciate it
19:19:49 <flebron> i've often referred to the styles as bottom up and top bottom
19:19:58 <shachaf> lispy: OK, here's a good solution:
19:19:58 <shachaf> λ> tri <- map (map read . words) . lines <$> readFile "18.txt" :: IO [[Integer]]
19:20:02 <shachaf> λ> foldr1 (\x xs -> zipWith (+) x (zipWith max xs (tail xs))) tri
19:20:29 <Moggle> oh that's clever
19:20:32 <Moggle> zipWith and the tail
19:20:34 <elliott> shachaf: "drop 1 xs" please :(
19:20:36 <Moggle> very clever
19:20:46 <shachaf> But Moggle won't understand that. Unfortunately working incrementally toward any kind of good solution from Moggle's current code will not help Moggle either.
19:21:23 <slack1256> Moggle: wow, i won't post it because i wrote some shitty code back then
19:21:26 <slack1256> also is in spanish
19:21:30 <shachaf> So what can I do? Heuristics for "things you probably shouldn't do" are very useful things, and you can give them on their own.
19:21:34 <Moggle> that's alright
19:21:38 <Moggle> I think I know how to fix my code
19:21:43 <shachaf> elliott: Sorry, zipWith and tail is kind of a tradition.
19:21:48 <Moggle> i am still pretty confident that my code should compile
19:22:02 <cmccann> Twisol, codereview.stackexchange.com ?
19:22:18 <latro`a> incidentally, just to be horrible
19:22:28 <Twisol> cmccann: will give that a shot, thanks
19:22:33 <slack1256> Moggle: in a battle between the man and the machine. always be to the machine. or didn't you see 80's movies?
19:22:41 <slack1256> s/machine/compiler
19:22:53 <latro`a> foldr1 (\x xs -> zipWith (+) x (zipWith max xs (tail xs))) =<< (map (map read . words) . lines <$> readFile "18.txt" :: IO [[Integer]])
19:22:56 <latro`a> works
19:22:58 <latro`a> :p
19:23:15 <elliott> shachaf: You said it was "good".
19:23:17 <shachaf> latro`a: What's your point?
19:23:21 <latro`a> nothing
19:23:27 <latro`a> I was just making a horribly long line
19:23:29 <latro`a> for kicks
19:23:39 <hpaste> slack1256 pasted “oh god why” at http://hpaste.org/79261
19:23:52 <shachaf> What I wrote was better because the lines were shorter. :-)
19:24:00 <jmcarthur> for a library that programming, certain patterns of using Data.Dynamic sure require a lot of type signatures
19:24:09 <jmcarthur> *that provides dynamically typed programming
19:24:13 <latro`a> I know, I don't actually approve of extremely long lines in practice
19:25:07 <slack1256> jmcarthur: I thought that anything involving Typeable had lots of type signatures
19:25:19 <cmccann> elliott, for what it's worth the zip`ap`tail thing is safe
19:25:24 <elliott> cmccann: yeah I know
19:25:33 <elliott> it upsets me though still
19:25:40 <elliott> especially since drop 1 is just a hack there really
19:25:40 <cmccann> since (zip [] x) is always []
19:25:45 <elliott> I have no idea how to make it elegant
19:25:53 <jmcarthur> slack1256: not everything. it depends on how often the context implies the type
19:26:33 <Crockeo> Hey fellas here in #haskell.
19:26:35 <Crockeo> I've a question
19:26:49 <Crockeo> I'm using hOpenGL for the first time, and a lot of tutorials use $= quite a bit.
19:27:13 <Crockeo> Is that a hOpenGL-specific thing or..?
19:27:15 <Crockeo> Wait, hoogle.
19:27:24 <shachaf> Yep.
19:27:28 <jmcarthur> StateVar is the name of the package, i think
19:27:28 <cmccann> sort of.
19:27:31 <cmccann> it's in another package, yes.
19:27:46 <shachaf> Hayoo would find it.
19:27:46 <cmccann> but is mostly for hopengl
19:27:48 <shachaf> Hoogle wouldn't.
19:28:01 <jmcarthur> hopengl and the glut bindings both use it, at least
19:28:24 <Crockeo> Alright, thank you, I found it on Hayoo!
19:33:44 <Moggle> oh joy i try to use where instead of let
19:33:55 <Moggle> and now it's like "wheres inside lambdas are literally satan im going to error on you"
19:34:10 <latro`a> you can't where inside a lambda-
19:34:16 <newsham> thats an unusual error message
19:34:23 <Moggle> well i can't let inside the lambda either
19:34:28 <Moggle> so there's no winning
19:34:30 <latro`a> you can let inside a lambda
19:34:38 <Moggle> the code was hating pretty hard on me
19:34:40 <newsham> it sounds like your compiler has something against you
19:34:44 <Moggle> i dont blame it
19:34:46 <latro`a> > (\x -> let z = x+1 in z+1) 2
19:34:47 <Moggle> this code is disgusting
19:34:47 <lambdabot>   4
19:34:56 <shachaf> Based on the code Moggle pasted, it sounds to me more like Moggle has something against the compiler.
19:35:10 <Moggle> can you show me how you'd do multiple let variables inside a lambda
19:35:14 <latro`a> > (\x -> let z = x+1; p = z+2 in z+1) 2
19:35:15 <lambdabot>   4
19:35:22 <Moggle> nice
19:35:27 <Moggle> now the question is why it hates me
19:35:27 <latro`a> ....forgot to actually use p, but you get the point
19:35:39 <newsham> because you wouldnt read the manual i imagine
19:35:55 <frx> is there a way to do somethint like this without line <- getLine first?  case getLine of ...
19:36:07 <shachaf> frx: Nope.
19:36:18 <shachaf> In GHC 7.6 you can say getLine >>= \case of ...
19:36:28 <shachaf> With an extension.
19:36:31 <Moggle> Oh cool, now it's complaining about hGetContents
19:36:34 <latro`a> or fmap, if you don't do more IO after
19:36:36 <Moggle> which means I forgot to import Data.IO
19:36:39 <newsham> frx: kind of.. but you're going to need to know something about monad
19:36:42 <latro`a> *System.IO
19:36:54 <Moggle> same difference!
19:36:56 <Moggle> :D
19:36:58 <Moggle> (thanks)
19:37:14 <latro`a> erm, not that you don't do more IO after, but that you just make a new value with the string, rather than it influencing what IO you do after
19:37:29 <latro`a> (still poorly phrased but *shrug*)
19:44:24 <Moggle> ((cur !! i) + (head pre))
19:44:27 <Moggle> if you were a haskell
19:44:29 <Moggle> why would you hate this
19:44:42 <latro`a> quite a few reasons actually >.>
19:44:46 <Moggle>  No instance for (Num [b0])
19:44:48 <Moggle>    arising from a use of `+'
19:44:49 <Moggle> that specifically then
19:44:51 <Moggle> ;P
19:45:05 <latro`a> looks like cur !! i is a list, which makes sense if cur is a [[a]]
19:45:16 <Moggle> huh, that would explain the error
19:45:19 <latro`a> either that or head pre is a list, again makes sense if pre is an [[a]]
19:45:26 <latro`a> yeah, type errors tend to be pretty informative
19:45:34 <Moggle> i find them rather opaque
19:45:38 <Moggle> still learning haskell
19:45:53 <latro`a> no instance for Num [b0] means there's no definition of the basic number functions for lists
19:46:41 <Moggle> Num is a type function?
19:46:49 <latro`a> Num is a type class
19:46:53 <Moggle> now I think on it, I do recall seeing (Num a) => a - a at some point
19:46:57 <latro`a> it has instances which are types
19:46:58 <Moggle> type class, type function, same difference
19:47:00 <latro`a> no
19:47:01 <Moggle> its a type that acts like a function
19:47:03 <latro`a> not at all
19:47:04 <latro`a> no
19:47:12 <latro`a> Num is not a type, and it does not act like a function
19:47:21 <Moggle> Num is a function
19:47:24 <Twisol> it's comparable to an interface, since you're from the imperative world.
19:47:25 <Moggle> that takes a type and returns a type
19:47:26 <Moggle> no?
19:47:26 <latro`a> it is not a function either
19:47:27 <latro`a> no
19:47:41 <latro`a> there are such things; type classes are another thing entirely
19:47:57 <latro`a> they are roughly analogous to interfaces as Twisol said
19:48:08 <Nereid> (what really happens is that Num takes a type and returns a constraint)
19:48:10 <Twisol> the (Num a) => thing you saw is the use of a typeclass as a constraint
19:48:24 <Nereid> :k Num
19:48:26 <lambdabot> * -> Constraint
19:48:51 <Moggle> yeah, see I think this is a definition failure
19:49:00 <Moggle> to me, that's pretty much a function right there for Num
19:49:00 <latro`a> ...what?
19:49:04 <Moggle> it takes a type and returns a constraint
19:49:18 <Moggle> i guess its _different_ though but I cant help but think of it as a function
19:49:19 <latro`a> a constraint is not a type
19:49:46 <latro`a> you can think of it that way, but I don't think doing so is very useful except if you're using DataKinds
19:49:46 <Moggle> i'll go reread the Learn You A Haskell page on this stuff then :P
19:50:02 <Moggle> soon as this code compiles!
19:50:06 <Moggle> AND IT WILL COMPILE.
19:50:08 <Moggle> >:O
19:50:08 <latro`a> (and even then you can just think of DataKinds as sugar)
19:50:19 <latro`a> actually
19:50:24 <latro`a> *is* DataKinds sugar?
19:50:35 <latro`a> I think it is, since I remember using it, then checking the type of something, and having the data kinds vanish
19:50:59 <Nereid> it just makes it possible to define new kinds, I thought.
19:51:06 <latro`a> erm
19:51:08 <Twisol> doesn't DataKinds let you use things like numeric constants at the type level?
19:51:15 <latro`a> I seem to have misremembered the name of the extension
19:51:16 <Nereid> no, that's different.
19:51:30 <latro`a> I'm thinking of like
19:51:36 <latro`a> type Foo a = (Bar a,Baz a)
19:51:56 <latro`a> which istr is DataKinds but I may have misremembered
19:52:07 <Nereid> ?
19:52:15 <latro`a> for example
19:52:25 <latro`a> type NumAndFloating a = (Num a,Floating a)
19:52:37 <Nereid> sure, you only need ConstraintKinds for that.
19:52:43 <latro`a> ah ConstraintKinds
19:52:43 <dolio> Data kinds are the kind equivalent of data types.
19:52:44 <latro`a> thank you
19:52:45 <latro`a> sorry
19:52:47 <Nereid> ok
19:52:55 <Nereid> but it lets you do legitimately cool things.
19:52:55 <latro`a> OK, is *that* sugar?
19:53:04 <Nereid> that you couldn't without.
19:53:21 <latro`a> I remember making an example where I used a constraint kind, then compiled, and then checked the type in ghci
19:53:22 <Nereid> e.g. you can make a constraint an associated type of a class
19:53:27 <Nereid> and then use that constraint for its members
19:53:33 <latro`a> and there was no constraint kind in the type after compilation
19:53:51 <latro`a> is this in combination with TypeFamilies?
19:53:53 <Nereid> oh, yes
19:54:08 <latro`a> ic
19:56:03 <mapf> hackage is down?
19:56:06 <Nereid> yep
19:56:12 <Nereid> hackage mirror http://hdiff.luite.com/
19:58:11 <mapf> Nereid: thanks
19:59:44 <Moggle> HAH
19:59:46 <Moggle> the code COMPILED
19:59:55 <Moggle> i bent it to my will slowly
19:59:57 <Moggle> and with great effort
20:00:05 <Moggle> (and also realized I was using : completely wrong0
20:00:09 <Moggle> (I blame Prolog)
20:41:29 <hpaste> flebron pasted “How idiomatic is this?” at http://hpaste.org/79263
20:42:42 <flebron> Is there any way of giving more semantics than "(Double -> Double) -> Double -> Double -> Double -> Double"? Should I create a few type aliases?
20:44:15 <jmcarthur> flebron: type alias are documentation. newtypes give you compile time checks. whether one is better than the other is up to you, but either is probably nicer than a wall of Doubles
20:44:41 <otters> or you could comment each argument
20:44:52 <Mortchek> flebron, your main might be expressed better with let...in instead of do
20:45:40 <flebron> Ah, yes, that's better.
20:46:42 <jmcarthur> you have some redundant parens. that's not always bad, but haskellers learn pretty quickly that function application binds more tightly than any infix operator
20:47:10 * djahandarie uses redundant parens sometimes
20:47:19 <jmcarthur> as i said, it's not always bad
20:47:21 <djahandarie> My head isn't always as good as the parser... (-:
20:47:37 * djahandarie fills jmcarthur full of straw and hits him
20:47:41 <jmcarthur> i don't think i ever use redundant parens to separate an applied function from an operator, though
20:48:03 <jmcarthur> *prefix function
20:48:17 <flebron> Oh you're right, a
20:48:18 <flebron> a * f b
20:49:02 <jmcarthur> i also think instead of  epsilon > (abs $ f c)  i would have just said  epsilon > abs (f c)
20:49:09 <cmccann> djahandarie, so tell me, can you head parse... THIS?
20:49:10 <cmccann> @quote cmccann Int -> Int
20:49:10 <lambdabot> cmccann says: :t \f -> \x -> f x :: Int :: (Int -> Int) :: (Int -> Int) -> Int -> Int
20:49:31 <jmcarthur> wtf
20:49:35 <cmccann> hahahaha
20:49:54 <djahandarie> Surprisingly, yes
20:49:56 <jmcarthur> i had no idea type annotations terminated lambda expressions
20:50:04 <shachaf> :t \x -> \y -> x + y :: Int :: Int -> Int :: Int -> Int -> Int
20:50:06 <lambdabot> Int -> Int -> Int
20:50:07 <jmcarthur> i guess it makes sense, but...
20:50:08 <simpson> I had to read that right to left.
20:50:20 <Nereid> cmccann: haha that's wonderful.
20:50:27 <cmccann> djahandarie, I think you're the first person I've shown that to who hasn't merely boggled at it for a while
20:51:10 <Ralith> made sense to me
20:51:18 <cmccann> I mean, once you realize what's going on it's not hard to read, but I don't think anyone would complain about using redundant parens there
20:51:39 <jmcarthur> flebron: i agree with all the messages that hlint gave you on the hpaste
20:51:48 <shachaf> Coming soon to a Hackage near you:
20:51:53 <jmcarthur> in terms of being idiomatic
20:51:55 <shachaf> instance (Applicative f, a ~ a2, a ~ a3, a ~ a4, a ~ a5, a ~ a6, a ~ a7, a ~ a8, a ~ a9, b ~ b2, b ~ b3, b ~ b4, b ~ b5, b ~ b6, b ~ b7, b ~ b8, b ~ b9) => Each Int f (a,a2,a3,a4,a5,a6,a7,a8,a9) (b,b2,b3,b4,b5,b6,b7,b8,b9) a b where each = Lens.indexed $ \ f ~(a,b,c,d,e,g,h,i,j) -> (,,,,,,,,) <$> f (0 :: Int) a <*> f 1 b <*> f 2 c <*> f 3 d <*> f 4 e <*> f 5 g <*> f 6 h <*> f 7 i <*> f 8 j
20:52:04 <djahandarie> I pretty much just randomly put spaces and parentheses wherever it feels good to me.
20:52:40 <Mortchek> shachaf, what would that even be *for*?
20:52:49 <djahandarie> One lens to rule them all
20:52:50 <jmcarthur> shachaf: why use (~)? why not just reuse a and b several times?
20:52:59 <shachaf> jmcarthur: Better inference.
20:53:05 <cmccann> to force unification for inference, I assume
20:53:13 <jmcarthur> oh, i see
20:53:16 <cmccann> it's a handy trick
20:53:28 <cmccann> overgeneralized the instance so the head matches, then unify with ~ after
20:53:28 <flebron> Hrm, why am I parsing epsilon > abs $ f c incorrectly? I think of $ as adding ( and ) around the right hand side, yielding epsilon > abs (f c)... but I may be being confused by infixness and precedence at the same time.
20:53:40 <shachaf> flebron: (epsilon > abs) (f c)
20:53:47 <flebron> Ohhh.
20:53:47 <otters> flebron: a $ b is (a) $ (b)
20:53:55 <jmcarthur> flebron: ($) binds *very* loosely
20:54:00 <flebron> Right, it also adds parens to the left.
20:54:01 <cmccann> $ is just an operator with low precedence
20:54:04 <cmccann> :t ($)
20:54:05 <lambdabot> (a -> b) -> a -> b
20:54:12 <Nereid> ($) = id
20:54:15 <flebron> Yeah, f $ a = f a
20:54:38 <shachaf> > Just $ do 5 :: Int
20:54:41 <lambdabot>   Just 5
20:54:48 * shachaf likes this trick.
20:55:09 <simpson> @pl \x y z w -> x > y (z w)
20:55:09 <lambdabot> (. (.)) . (.) . (.) . (>)
20:55:11 <jmcarthur> > 5 :: Maybe Int
20:55:13 <lambdabot>   No instance for (GHC.Num.Num (Data.Maybe.Maybe GHC.Types.Int))
20:55:13 <lambdabot>    arising f...
20:55:15 <jmcarthur> i wish
20:55:15 <popl> shachaf: That's almost the Nike slogan.
20:55:16 <simpson> Yeah, just use the parentheses. :3
20:56:15 <jmcarthur> popl: in ghci, the identifier "it" is bound to the last thing you evaluated :)
20:56:22 <shachaf> Hey, Hackage is back.
20:56:25 <shachaf> monochrom: ☝
20:56:54 --- mode: ChanServ set +o jmcarthur
20:57:11 <popl> jmcarthur: Thank you.
20:57:16 --- topic: set to '["Haskell Platform 2012.4: http://bit.ly/Clv5r ","GHC 7.6.1 http://v.gd/CEBRVo ","Paste code/errors: http://hpaste.org/new/haskell ","Haskell News: http://reddit.com/r/haskell ","The Haskell programming language http://haskell.org ","Logs: http://bit.ly/5mwtRQ "]' by jmcarthur
20:57:31 <edwardk> shachaf: that is its simplified form, yes
20:57:34 --- topic: set to '[ "Haskell Platform 2012.4: http://bit.ly/Clv5r ","GHC 7.6.1 http://v.gd/CEBRVo ","Paste code/errors: http://hpaste.org/new/haskell ","Haskell News: http://reddit.com/r/haskell ","The Haskell programming language http://haskell.org ","Logs: http://bit.ly/5mwtRQ "]' by jmcarthur
20:57:36 --- mode: jmcarthur set -o jmcarthur
20:58:06 <jmcarthur> ah shoot, i misinterpreted a space as though it was intended
20:58:13 <jmcarthur> sorry for noise
20:58:15 --- mode: ChanServ set +o jmcarthur
20:58:20 --- topic: set to '["Haskell Platform 2012.4: http://bit.ly/Clv5r ","GHC 7.6.1 http://v.gd/CEBRVo ","Paste code/errors: http://hpaste.org/new/haskell ","Haskell News: http://reddit.com/r/haskell ","The Haskell programming language http://haskell.org ","Logs: http://bit.ly/5mwtRQ "]' by jmcarthur
20:58:22 --- mode: jmcarthur set -o jmcarthur
21:19:15 * hackagebot smtp-mail 0.1.3.0 - Simple email sending via SMTP  http://hackage.haskell.org/package/smtp-mail-0.1.3.0 (JasonHickner)
21:19:17 * hackagebot lens 3.7.1.2 - Lenses, Folds and Traversals  http://hackage.haskell.org/package/lens-3.7.1.2 (EdwardKmett)
21:24:19 * hackagebot bifunctors 3.0.1 - Haskell 98 bifunctors  http://hackage.haskell.org/package/bifunctors-3.0.1 (EdwardKmett)
21:24:37 <edwardk> davean: hackage lives again
21:28:17 <startling> what's the syntax to "forall" two type variables?
21:29:36 <startling> oh, "forall a b. whatever"
21:39:26 <ski> @type map :: forall a. forall b. (a -> b) -> ([a] -> [b])
21:39:27 <lambdabot> (a -> b) -> [a] -> [b]
21:42:00 <epta> What is the difference between `(a → b) → [a] → [b]' and `forall a. forall b. (a → b) → [a] → [b]' ?
21:42:20 <johnw> in this case, nothing at all
21:42:21 <Nereid> by themselves, none
21:42:43 <johnw> forall is just introducing the type names, which is already implied
21:42:54 <Nereid> it matters when you put things together, though, like
21:43:10 <Nereid> there's a big difference between 'forall a. a -> b' and '(forall a. a) -> b'
21:43:28 <johnw> Nereid: can you elaborate?
21:43:42 <Nereid> one is inhabited, and the other isn't.
21:43:50 <johnw> can you elaborate on that?
21:43:59 <johnw> i don't know what "inhabited" means in this contxet
21:44:02 <Nereid> has a value
21:44:11 <johnw> still not getting it
21:44:22 <Nereid> there's nothing of the type forall a b. a -> b, while \x -> x can have type forall b. (forall a. a) -> b
21:44:38 <Nereid> (forall a. a) -> b = exists a. (a -> b), as it were.
21:44:58 <Twisol> This is just predicate logic?
21:45:09 <Nereid> in a way, yes ;)
21:45:18 <johnw> doesn't a function of type a -> b have the type forall a b. a -> b?
21:45:22 <Nereid> yes
21:45:25 <Nereid> and no such thing exists
21:45:30 <Nereid> except undefined and unsafeCoerce and ...
21:45:34 <Twisol> not all a's go to b's, right?
21:45:37 <Twisol> or rather
21:45:39 <Twisol> not all a's go to all b's
21:45:44 <Twisol> or something of that nature
21:46:10 <arbn> Hm. On exactly one of my two Mac OS X machines, I'm told that cabal-install needs to be upgraded, every time I do "cabal update".
21:46:11 <Twisol> …there is no cartesian product of a's and b's such that every combination produces a valid mapping?
21:46:43 <Nereid> there is no single polymorphic function that can turn something of any type 'a' into something of any other type 'b'
21:46:47 <Nereid> @free f :: a -> b
21:46:47 <lambdabot> h . f = f . g
21:46:51 <epta> arbn: maybe it's a time for `cabal install cabal-install' ?
21:46:58 <Twisol> That's what I was trying for. ^_^
21:46:58 <johnw> except unsafeCoerce, which does exist..
21:47:22 <Nereid> that doesn't count!@
21:47:23 <Twisol> there's a reason it's prefixed "unsafe" :D
21:47:25 <arbn> epta: Everytime I do that, I still get the message afterward.
21:47:32 <dolio> (forall a. a) -> b and exists a. (a -> b) are not identical.
21:47:34 <Nereid> however, (forall a. a) -> b is different:
21:47:38 <dolio> In intuitionistic logic.
21:47:47 <arbn> epta: I just tried re-installing the Platform freshly, but it doesn't change anything.
21:47:53 <Twisol> dolio: is this the law of the excluded middle thing?
21:47:54 <Nereid> something of that is a function that takes a polymorphic argument (which can take any type, including b), and returns a value of type 'b'
21:47:58 <Nereid> it's a rank-2 type.
21:48:27 <Nereid> dolio: well we don't really have an "exists" in haskell anyway.
21:49:02 <dolio> We don't have a forall, either. Unless you mean in ghc, which also has an exists.
21:49:16 * hackagebot hslogger-template 2.0.2 - Automatic generation of hslogger functions  http://hackage.haskell.org/package/hslogger-template-2.0.2 (BrianLewis)
21:49:20 <Nereid> I'm confused.
21:50:05 <dolio> It's just not written using "exists."
21:50:45 <Nereid> what is it, then?
21:51:19 <ski> (it doesn't exactly have `exists' (however spelled), it only has something which is equivalent to it, combined with a data type)
21:51:30 <dolio> To get the above type, you'd use 'data F b = forall a. F (a -> b)'. Then F b is the same as exists a. a -> b.
21:51:31 <Nereid> sure.
21:51:37 <Nereid> ok.
21:52:00 <Nereid> but that's not the point I was trying to get across.
21:54:41 <hpaste> startling pasted “fun with existential quantification” at http://hpaste.org/79265
21:54:53 <startling> ^ I can't figure this out, any ideas?
21:56:12 <startling> essentially I want to pair a StateT with its current state, so I can play it repeatedly but let it update its state.
21:57:12 <startling> so I'm using ExistentialQuantification to hide the type of the state, but I'm getting an odd error in the process.
22:06:37 <startling> I guess this might be beyond the scope of existential quantification.
22:07:02 <epta> How can I get `a' value from `IO a' inside list comprehension?
22:07:32 <johnw> epta: need more info
22:07:35 <startling> epta, you can't, but maybe you want sequence or mapM
22:08:01 <sw2wolf> :t mapM
22:08:03 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
22:08:47 <shachaf> epta: "IO a" does not contain "a", so you can't extract an "a" from it.
22:09:41 <startling> :t extract
22:09:43 <lambdabot> Not in scope: `extract'
22:09:48 <startling> aw. :/
22:10:12 <sw2wolf> :t liftIO
22:10:13 <epta> > let f :: IO [Int]; f = return [1,2,3]; [ a + b | list <- f, a <- list, b <- list ]
22:10:13 <lambdabot> MonadIO m => IO a -> m a
22:10:15 <lambdabot>   <hint>:1:83: parse error (possibly incorrect indentation)
22:11:10 <johnw> liftM2 (+) a b?
22:11:35 <johnw> but list isn't a list there
22:11:45 <startling> oh, I see where my problem is -- execStateT returns a monadic value, duh
22:12:09 <sw2wolf> :t execStateT
22:12:10 <johnw> the liftM2 will operate on the list inside the IO, but not the values inside the list inside IO
22:12:10 <lambdabot> Monad m => StateT s m a -> s -> m s
22:12:28 <johnw> lift
22:12:34 <johnw> liftM2 (liftM2 (+))? :)
22:13:14 <epta> Actually, why it is a parse error?
22:13:43 <johnw> do you have monad comprehensions turned on?
22:13:47 <Nisstyre> epta: why is what a parse error?
22:13:57 <Nisstyre> monad comprehensions are fun
22:14:18 <johnw> actually, with monad comprehensions it ought to work with just liftA2
22:14:18 <epta> > let f :: IO [Int]; f = return [1,2,3]; [ a + b | list <- f, a <- list, b <- list ]
22:14:20 <lambdabot>   <hint>:1:83: parse error (possibly incorrect indentation)
22:14:22 <epta> Nisstyre: that
22:15:11 <Nisstyre> epta: because you're returning the list into IO a ?
22:15:23 <Nisstyre> monad comprehensions would indeed fix that
22:15:35 <Nisstyre> but yeah, I don't think that's the parse error
22:16:13 <epta> And what monad comprehension is?
22:16:16 <epta> Sounds scary
22:16:25 <Nisstyre> epta: generalizes the list comprehensions syntax to any monad
22:16:26 <Nereid> epta: that won't work though
22:16:36 <Nereid> you can't mix different monads
22:16:41 <Nisstyre> ^
22:16:56 <epta> Maybe it could be done without comprehensions at all?
22:16:57 <Nisstyre> Nereid: if he replaced + with ++ would it?
22:17:03 <Nereid> no
22:17:09 <Nisstyre> oh wait yeah it wouldn't
22:18:52 <Nereid> on the other hand, this works: [ [ a + b | a <- list, b <- list ] | list <- f ]
22:19:19 <hpaste> johnw pasted “epta.hs” at http://hpaste.org/79267
22:19:23 <epta> > Couldn't match expected type `[[t0]]' with actual type `IO [Int]'
22:19:23 <johnw> epta, that works
22:19:24 <epta> Nereid:
22:19:25 <lambdabot>   <hint>:1:25: parse error on input `type'
22:19:31 <johnw> epta: but f :: IO [Int] does not
22:21:24 <epta> johnw: there are some tricks to do [μ α] → μ [α] and backwards but it's hard to remember it :[
22:21:39 <Nereid> [m a] -> m [a] is sequence.
22:21:42 <Nereid> the other direction doesn't exist.
22:21:50 <Nereid> :t sequence
22:21:52 <lambdabot> Monad m => [m a] -> m [a]
22:23:10 <epta> Nereid: are there some m, for which of them exists m [a] -> [m a]?
22:23:19 <Nereid> sure, like Identity.
22:23:33 <epta> Maybe
22:23:34 <shachaf> You can write a function of that type but it won't do what you want.
22:23:40 <Nereid> and []
22:23:47 <Nereid> but it won't in general be an inverse of sequence
22:23:51 <shachaf> You don't have enough information to figure out the length of the list.
22:24:02 <Nisstyre> epta: so is this what you wanted? [[a+b | a <- l, b <- l] | l <- f]
22:24:03 <shachaf> @ty liftM (=<<) (liftM return) return return [] :: Monad m => [m a] -> m [a]
22:24:05 <lambdabot> Monad m => [m a] -> m [a]
22:24:09 <shachaf> OK, that wasn't helpful. Sorry. Ignore it.
22:24:14 <Nereid> and you just can't for IO.
22:24:30 <Nereid> at least, not in a reasonable way.
22:24:42 <johnw> Nisstyre: i tried that, and couldn't get it to work
22:24:52 <Nisstyre> johnw: it works with XMonadComprehensions
22:25:01 <johnw> did you try it?
22:25:02 <Nisstyre> yes
22:25:03 <Nereid> I tried it.
22:25:03 <johnw> i have that enabled too
22:25:05 <Nisstyre> it works
22:25:08 <Nereid> f :: IO [Int]
22:25:12 <johnw> let me try again
22:25:19 <epta>  Couldn't match expected type `[[t0]]' with actual type `IO [Int]'
22:25:22 <Nereid> then [[a+b | a <- l, b <- l] | l <- f] :: IO [Int]
22:25:31 <Nisstyre> johnw: http://ideone.com/Dl3IsP
22:25:34 <johnw> i tried this: [ [ x + y | x <- a, y <- b ] | a <- g, b <- g ]
22:25:53 <johnw> ah
22:26:01 <johnw> i needed to drop the sequence
22:26:22 <hpaste> johnw pasted “epta2.hs” at http://hpaste.org/79269
22:26:32 <johnw> thanks, Nisstyre, I was so close but didn't know it
22:27:01 <epta> Nisstyre: yeah, it works with XMonadComprehension pragma
22:27:07 <shachaf> _1
22:27:07 <shachaf>   :: forall s t a b (f :: * -> *) (k :: * -> * -> *).
22:27:08 <shachaf>      (Functor f, Indexable Int k, Field1 s t a b) =>
22:27:08 <shachaf>      k (a -> f b) (s -> f t)
22:27:12 <shachaf> Guess who's to blame for that type?
22:27:15 <shachaf> Hint: It's elliott.
22:27:21 <Nereid> I'd rather just write it as fmap (\l -> [a+b | a <- l, b <- l]) f
22:27:25 <Nisstyre> johnw: I got an error about the monomorphism restriction for main so I gave a type hint
22:27:29 <Nereid> shachaf: :)
22:27:36 <elliott> I blame edwardk
22:27:45 <edwardk> =P
22:27:58 <epta> johnw: what is a point of doing `xs <- ..; print xs'?
22:28:07 <popl> Is pasting allowed in the channel?
22:28:13 <edwardk> it follows the principle of allowing everything that _could_ work with a lens to work with it.
22:28:14 <Nereid> popl: only if it's real short.
22:28:19 <popl> Ok.
22:28:20 <Nereid> else http://hpaste.org/
22:28:25 <johnw> epta: nothing really
22:28:30 <popl> Right. My twitchy was twitching.
22:28:34 <johnw> i was just simplifying
22:28:42 <popl> I am used to channels with a strict no pasting policy.
22:28:52 * popl eyes shachaf 
22:29:06 <popl> shachaf: I know you're shifty. You hang out in that esoteric channel.
22:29:07 <shachaf> I think four lines is usually OK?
22:29:08 <Nereid> no point in using hpaste for a 1-line thing.
22:29:20 <Nereid> depends on the lines :p
22:29:23 <Nereid> I'd probably hpaste 4 lines.
22:29:34 <shachaf> One of them was two characters. Could've joined it.
22:29:46 <Nereid> heh
22:29:59 <Nereid> oh, in your case I would have just pasted it here :p
22:30:05 <popl> Sure.
22:30:08 <Nereid> it's one "line"
22:32:00 <epta> Is it possible to convert nested list comprehensions in nested []-monad with do-notation?
22:32:19 <epta> I'm about this readable one: `[ [ x + y | x <- a, y <- b ] | a <- g, b <- g ]'
22:32:31 <edwardk> shachaf was mostly just trying to make a point, since he lost the 'keep the type simple' argument in #haskell-lens ;)
22:32:43 <shachaf> There was an argument?
22:32:47 <shachaf> I'd call it a massacre.
22:32:58 <edwardk> hah
22:33:14 <Nereid> epta: hmm?
22:33:32 <Nereid> that's do {a <- g; b <- g; return $ do {x <- a; y <- b; return (x + y)}}
22:33:58 <epta> Nereid: ok, got it
22:34:00 <epta> Thanks
22:34:16 <shachaf> @undo [ [ x + y | x <- a, y <- b ] | a <- g, b <- g ]
22:34:17 <lambdabot> concatMap (\ a -> concatMap (\ b -> [concatMap (\ x -> concatMap (\ y -> [x + y]) b) a]) g) g
22:34:21 <Nereid> :(
22:34:22 <shachaf> @@ @redo @undo [ [ x + y | x <- a, y <- b ] | a <- g, b <- g ]
22:34:23 <lambdabot> Plugin `compose' failed with: Unknown command: "redo"
22:34:25 <shachaf> @@ @do @undo [ [ x + y | x <- a, y <- b ] | a <- g, b <- g ]
22:34:26 <lambdabot>  concatMap (\ a -> concatMap (\ b -> [concatMap (\ x -> concatMap (\ y -> [x + y]) b) a]) g) g
22:34:31 <shachaf> Pfooey.
22:34:34 <Nereid> @undo do {a <- g; b <- g; return $ do {x <- a; y <- b; return (x + y)}}
22:34:35 <lambdabot> g >>= \ a -> g >>= \ b -> return $ a >>= \ x -> b >>= \ y -> return (x + y)
22:34:48 <Nereid> I guess undo doesn't know about monad comprehensions.
22:40:21 <edwardk> @remember elliott I think lens is the first library I've seen that promises letting you write abstract totally-inefficient-looking compositional code and getting reliably good compilation which has actually delivered on that promise.
22:40:22 <lambdabot> Done.
22:40:43 <donri> edwardk: marketing? :)
22:41:31 <edwardk> donri: more that if i @remember in #haskell-lens daniel can't see it ;)
22:41:41 <Cale> What? What about ByteString?
22:41:58 <edwardk> the surrounding discussion was about the fragility of RULES based optimization
22:42:17 <edwardk> we tend towards INLINE and unsafeCoerce
22:42:25 <edwardk> so we're less sensitive to phase ordering
22:42:50 <donri> daniel who?
22:43:17 <edwardk> daniel santa cruz, the HWN guy
22:43:27 <edwardk> just found out he works in our New York office. small world
22:43:32 <donri> oh
22:43:44 <donri> i thought he just looked at what quotes was added to lambdabot using some command for that
22:43:59 <edwardk> so did i
22:44:07 <shachaf> Pft.
22:44:11 <shachaf> "some command for that"
22:44:15 <edwardk> which always made me wonder when he didn't see something from blah, etc
22:44:17 * donri hand-waves
22:44:18 <shachaf> As in, code that someone writes in lambdabot?
22:45:04 <elliott> edwardk is secretly fabricating testimonials from me.
22:45:34 <shachaf>  @remember elliott I didn't say half the things I said.
22:48:46 <popl> 22:45 < elliott> Haskell is cool, but my favoritest language ever is probably COBOL.
22:48:57 <johnw> anyone here familiar with runResourceT?  I have a function returning a ResourceT IO (ResumableSource (ResourceT IO) ByteString), and I don't quite know what to do with it.  I want to get at the ByteString
22:49:14 <johnw> I tried runResourceT $ ... $$ await, but that didn't type-check
22:49:17 * hackagebot mime-types 0.1.0.1 - Basic mime-type handling types and functions  http://hackage.haskell.org/package/mime-types-0.1.0.1 (MichaelSnoyman)
22:49:38 <shachaf> johnw: That sounds like Yesod.
22:49:51 <edwardk> [01:49] <elliott> I really wish everyone would spell my name properly with one t.
22:50:46 <donri> shachaf: it's conduit
22:52:42 <donri> johnw: i don't really speak conduit but from the types, don't you rather want something like do source <- runResourceT thatThing; bytes <- doSomethingConduityTo source
22:52:54 <johnw> let me try that
22:53:19 <johnw> closer
22:53:24 <johnw>     Couldn't match expected type `Source IO a0'
22:53:24 <johnw>                 with actual type `ResumableSource (ResourceT IO) ByteString'
22:53:28 <donri> presumably runResourceT gets you to the IO, and conduit doesn't act on IO actions
22:54:05 <johnw> maybe I need $$+-
22:54:23 <johnw> ooh, now it's just IO != ResourceT IO
22:54:37 <johnw> just need to put runReosurceT in front of that
22:54:58 <Ralith> $$+-? really?
22:55:01 <donri> great success
22:55:10 <johnw> yeah, it completes processing of a resumable source
22:55:14 <Ralith> "because readability is for chumps"
22:56:48 <donri> @quote mappend
22:56:49 <lambdabot> elliott says: |\/|/-\|-|-|=|\||} is my preferred mappend operator
22:57:55 <Nereid> what do you mean, <%@= looks like a swear word?
22:58:36 <donri> :t (<%@=)
22:58:38 <lambdabot> MonadState s m => Overloaded (Indexed i) ((,) b) s s a b -> (i -> a -> b) -> m b
22:58:48 <johnw> and it actually works too
22:59:05 <donri> johnw: duh, if it type checks...
22:59:07 <hpaste> johnw pasted “runResourceT usage” at http://hpaste.org/79274
22:59:12 <Nereid> :D
23:01:28 <osa1> I'm trying to understand relation between logic programming and type systems, and as an exercise I'm rewriting some simple prolog programs in haskell's type level. what am I doing in this program ? http://hpaste.org/79275 last instance declaration (the one commented out) is giving error: "duplicate instance declarations"
23:02:35 <Nereid> osa1: what if someone wrote an instance Child a a?
23:02:44 <edwardk> @remember shachaf The two-letter and three-letter identifiers are for edwardk's libraries. The one-letter identifiers are for his actual code. <elliott> edwardk has non-library code?
23:02:44 <lambdabot> Okay.
23:02:47 <Nereid> for fixed a
23:03:29 <osa1> Nereid: fundep conflict ?
23:03:38 <Nereid> nope
23:03:41 <Nereid> instance Child Emily Emily
23:03:44 <Nereid> no fundep conflict there.
23:03:51 <Nereid> er oops
23:03:52 <Nereid> Anne Anne.
23:04:04 <Nereid> no, I had it right the first time.
23:05:48 <osa1> Nereid: ok, how's that related with my problem ?
23:06:35 <Nereid> uh
23:06:46 <Nereid> hmm
23:07:16 <Nereid> actually, I think it was something like
23:07:23 <Nereid> fundeps are ignored when checking for overlapping instances?
23:08:32 <Nereid> can someone tell me if that's right?
23:08:51 <osa1> Nereid: if that's the case, then is there a way to do what I'm trying to do ?
23:09:27 <Nereid> I don't know.
23:10:20 <Nereid> maybe allowing OverlappingInstances is fine.
23:17:29 <osa1> Nereid: overlappinginstances doesn't work in that case I think because being overlapping and duplicate are two different things. in my case they're not overlapping but duplicates
23:19:49 <Nereid> oh, yes.
23:19:52 <Nereid> never mind then.
23:29:18 * hackagebot yesod-auth 1.1.3 - Authentication for Yesod.  http://hackage.haskell.org/package/yesod-auth-1.1.3 (MichaelSnoyman)
23:30:20 <Jafet> osa1: http://okmij.org/ftp/Haskell/types.html
23:59:45 <mmcdermo> Why are monad transformer stacks primarily defined as newtypes, instead of just type synonyms?
