00:00:00 <SingingBoyo> haskell way is nice, just takes getting used to.  impatience will be the death of me.
00:00:26 <Jafet> opengl.h is more or less a coherent argument against state machine programming style
00:01:38 <sopvop> Unfortunately real time graphics programming is horrible is any language right now.
00:02:56 <Jafet> Well, if boyo says that the opengl package is nice, that probably implies that it is slow
00:02:57 <SingingBoyo> 2D graphics aren't so bad, once you get used to it.  it's 3d that's terrible.
00:03:13 <sopvop> leaky abstractions can't be more leaky than that
00:03:45 <Jafet> It can, actually. Consider OpenCL
00:03:59 <sopvop> high level opengl is slow. most people build their own abstractions on top of Raw module.
00:09:31 <statusfailed> Is Data.Aeson.TH able to derive instances for GADTs?
00:10:22 <shachaf> I assume it depends on the GADT.
00:10:26 <shachaf> Did you try?
00:10:54 <statusfailed> yep, but I didn't understand the error, hah
00:11:04 <sopvop> post the error
00:13:32 <hpaste> statusfailed pasted “Deriving To/From JSON for GADT” at http://hpaste.org/79036
00:13:35 <statusfailed> sopvop: posted
00:13:52 <statusfailed> derivedwith $(deriveJSON id ''Generator)
00:17:08 <sopvop> I guess it can't. It make instance of `Generator a', but should do instead several instances of Generator Double, Generator WhatEver. Or, I think, add constraint to `a'.
00:17:26 <statusfailed> oh, derp
00:18:47 <statusfailed> sopvop: how do I add the constraint? like this? data (FromJSON a, ToJSON a) => Generator a where
00:19:30 <sopvop> I don't think that will work.
00:19:43 <shachaf> No.
00:19:56 <shachaf> You don't add constraints to data types.
00:20:02 <statusfailed> Yeah, I got yelled at by the compiler
00:20:03 <statusfailed> :D
00:20:25 <statusfailed> "-XDatatypeContexts is deprecated: It was widely considered a misfeature, and has been removed from the Haskell language."
00:20:31 <sopvop> Constraints go to class instances, but you might need undecidable or even overlapping ones
00:22:08 <sopvop> I would rather make instances manually. Like instance FromJSON (Generator Double) where ... and code should only cover Double case
00:22:18 <statusfailed> yeah, that makes sense
00:22:31 <statusfailed> i'm not 100% sure I even need GADTs, but it seems to be the way to go
00:22:41 <shachaf> What is the goal of that GADT?
00:23:22 <alpounet> statusfailed, what's the actual data type?
00:24:10 <sopvop> I avoid GADTs, they kill inference.
00:24:38 <Kosta> How do I pretty-print JSON in haskell? I found that Text.JSON provides conversions to Doc, but then how do I pretty-print a Doc?
00:25:13 <statusfailed> shachaf: just a limited set of ways of generating data
00:26:00 <statusfailed> e.g., gaussians, discrete, uniform, etc.
00:26:11 <statusfailed> but I need to represent it in json
00:26:39 <sopvop> Kosta: http://hackage.haskell.org/packages/archive/pretty/latest/doc/html/Text-PrettyPrint.html#g:9
00:27:11 <statusfailed> I think I don't need a GADT actually...
00:28:59 <Kosta> hm, ok I'll try using `render
00:29:54 <sopvop> Which would be faster, mappending a -> [b], or manually concatenating [a -> b]?
00:30:44 <Kosta> Ok, now I have to install a package from cabal. I'll pray that it doesn't break everything
00:31:18 <statusfailed> Is using DeriveFunctor a bad idea?
00:31:26 <statusfailed> it seems reasonably magical to me
00:33:15 <drdo> Does someone know about the existence of a constant-q transform implementation?
00:35:06 <sopvop> Kosta: Make sure its the same 'Doc' as in that package
00:36:07 <sopvop> So, god dam, lens are clever and edwardk is god. Also the part with functors is awesome and I realized how to use same trick for something else.
00:36:17 <edwardk> heh
00:36:19 * sopvop feels smart
00:36:28 <edwardk> playing with the database stuff?
00:36:35 <shachaf> Which part with functors?
00:36:54 <sopvop> No, now I switched to schema+json encoding.
00:36:59 <edwardk> ah
00:37:30 <sopvop> that named trick, I can supply it different functors, and get either encoding function or schema function.
00:37:47 <sopvop> or both!
00:39:39 <sopvop> It's like prism
00:42:42 <statusfailed> sopvop: What's the named trick?
00:43:16 <sopvop> that one. http://hpaste.org/78889
00:44:35 <Kosta> Ok, pretty-printing kind of works, but multiple keys are on one line. how do I fix that?
00:45:17 <sopvop> Kosta: by changing doc generating code I would assume
00:45:36 <SingingBoyo> how do I convert a haskell array to a Ptr to pass to a C function binding?
00:46:09 <shachaf> By copying, presumably.
00:46:13 * hackagebot miniutter 0.4.0 - Simple English clause creation from arbitrary words.  http://hackage.haskell.org/package/miniutter-0.4.0 (MikolajKonarski)
00:47:10 <drdo> SingingBoyo: You probably want to use some kind of Storable Array if you want to do that a lot
00:47:36 <sopvop> SingingBoyou http://hackage.haskell.org/packages/archive/array/0.4.0.1/doc/html/Data-Array-Storable.html#g:3
00:50:57 <hpaste> chrisdone annotated “Deriving To/From JSON for GADT” with “-_-” at http://hpaste.org/79036#a79037
01:06:25 <sopvop> is there a reversed functor type class? So I have   data Encoding = Encoding (a -> Value). and want fmapReversed (b -> a) :: f a -> f b ? :)
01:06:48 <shachaf> Contravariant
01:06:56 <shachaf> It's not in base, though.
01:08:23 <sopvop> contravariant - Author: Edward A. Kmett
01:08:32 <sopvop> Somehow I'm not surprised
01:08:37 <edwardk> =)
01:10:51 <terminate1> Hi guys
01:11:02 <terminate1> I'm super new to Haskell
01:11:42 <terminate1> Just wanted to know which IDE you recommend in order for step by step evaluation of expressions like in DrRracket for Schemej
01:11:45 <terminate1> Scheme*
01:13:07 <terminate1> Anyone?
01:13:14 <terminate1> =)
01:14:08 <Jafet> What is this step by step evaluation thing?
01:14:11 <Jafet> (Is it webscale?)
01:14:18 <terminate1> Hmm
01:14:21 <terminate1> which mean
01:14:41 <terminate1> (if (x==5) then 7 else 6)
01:15:12 <terminate1> this gets replaced by  the value of the expression
01:15:20 <terminate1> as I step through the code
01:15:26 <terminate1> Is it possible
01:16:01 <merijn> terminate1: I don't think that exists, and if it did I'm not sure the output would make sense in a lazy language
01:16:03 <Jafet> Definitely. But you probably need to implement the code that does this step by step evaluation thing first.
01:16:22 <merijn> Jafet: I think he's asking for an IDE that does that for haskell code
01:16:35 <terminate1> Exactly, IDE
01:16:35 <Jafet> Ok, someone actually implemented this thing already, but nobody uses it
01:16:36 <terminate1> Haha
01:16:45 <terminate1> I see
01:17:13 <terminate1> Leksah allows you to step through the code right?
01:17:17 <terminate1> Just confirming
01:17:22 <terminate1> I read online..
01:17:28 <terminate1> But it wasn't so clear
01:17:55 <liyang> Given how many such expressions there are, people just tend to learn how to step through their code in their heads, and use the occasional trace or traceShow.
01:18:05 <liyang> (IME.)
01:18:12 <shachaf> It does?
01:18:13 <shachaf> I doubt it.
01:18:28 <Jafet> What is this leksah thing?
01:18:42 <hiptobecubic> 'step through' is a strange idea in a lazy language. Things don't happen like you're used in, say, gdb
01:18:44 <terminate1> hmm, yeah, I like stepping through in my head too
01:18:45 <merijn> Jafet: haskell IDE that no one uses
01:18:50 <terminate1> but I was trying the Y combinator
01:18:55 <terminate1> and it made my head hurt
01:19:00 <terminate1> trying to trace the code
01:19:02 <terminate1> Lol
01:19:03 <gienah> leksah builds on gentoo with ghc 7.6.1
01:19:22 <Jafet> .oO( Are there more people who don't use leksah than yi? )
01:19:39 <gienah> yi also builds on gentoo with ghc 7.6.1
01:19:44 <hiptobecubic> Does anyone know how to actually use this? http://hackage.haskell.org/packages/archive/void/0.5.10/doc/html/Data-Void.html
01:19:48 <merijn> gienah: What's your point?
01:20:00 <hiptobecubic> You apparently can't just Void
01:20:10 <hiptobecubic> even thought it looks like it's being exported
01:20:22 <shachaf> terminate1: Fortunately for you the Y combinator doesn't type-check in Haskell.
01:20:46 <gienah> merijn: leksah upstream has moved to gtk2hs using gtk3 that is unreleased, maybe a reason that it might not be used much is its very difficult to build with ghc 7.6.1 currently
01:21:03 <merijn> gienah: Yeah, but how is the fact that it builds relevant to the discussion?
01:21:18 <hiptobecubic> or maybe no one uses it because there's no good reason to
01:21:22 <gienah> merijn: because you can grab the patches if you want to build it
01:23:00 <hiptobecubic> I can't figure out how to construct anything of type void. Which I suppose makes sense in a way, but then what does this package do?
01:23:31 <shachaf> hiptobecubic: It lets you talk about a type such that you can't construct anything of type it.
01:23:48 <hiptobecubic> and what might you do with that ability?
01:24:15 <shachaf> You might use it in theorem proving!
01:24:47 <shachaf> "theorem" "proving"
01:24:51 <shachaf> You could have things like callCC :: ((a -> Cont r Void) -> Cont r a) -> Cont r a
01:25:01 <hiptobecubic> hm
01:25:28 <quchen> Does anyone know why there's no "flip ($)" in the basic packages? ekmett said they tried to standardize it but eventually gave up, but I can't find anything about that.
01:26:06 <shachaf> There was a mailing list discussion about it on libraries@
01:26:06 <edwardk> http://markmail.org/message/vsplpb7aajp7goqo?q=python
01:26:41 <edwardk> http://markmail.org/message/vsplpb7aajp7goqo?q=python#query:python+page:1+mid:re4afhiyzappj55j+state:results was its death basically
01:27:35 <edwardk> anyways the reason there isn't one is because there is a large contingent who thinks its a bad idea and object to the style of having it around even in a fringe library like Data.Function
01:28:13 <edwardk> i happen to disagree with them, and even happen to be in the majority on the issue, but the libraries process is about building concensus, not sheer vote counting.
01:28:24 <edwardk> if we 'd wanted to ram it through on votes we probably could have
01:28:46 * shachaf thinks it's OK as it is.
01:28:49 <edwardk> it was pretty clear a week into that proposal that it was going nowhere
01:28:58 <shachaf> If someone wants (&) = flip ($) they can always get it from Control.Lens.
01:29:05 <edwardk> i personally wouldn't have put the proposal in
01:29:17 <edwardk> shachaf: yes, it is quite the minimal import. ;)
01:29:38 <shachaf> Exactly!
01:29:56 <edwardk> well, at this rate they'll probably already have it installed from something else using it
01:30:07 <edwardk> now that snap is coming on board
01:30:27 <quchen> It's clearly a function many people use. Looks like they thought "iteratees have this funny syntax, why not have every library define their own flip$ operator as well"
01:30:37 <quchen> Standards kill diversity!
01:30:41 * shachaf is not a huge fan of (&)
01:30:54 <shachaf> I don't like chained $s either.
01:31:09 <terminate1> > myLast [1,2,3,4]
01:31:10 <lambdabot>   Not in scope: `myLast'
01:31:53 <edwardk> i originally thought & was a cute hack, but its grown on me since
01:32:06 <edwardk> i tend to only use chains of & where the types are somehow related though
01:32:07 <shachaf> If it was composition I'd probably be happier with it.
01:32:08 <quchen> shachaf: Well, you can avoid chained ($) with (.)
01:32:19 <quchen> Now try avoiding (&) with other things
01:32:34 <edwardk> foo & bar .~ baz & quux .~ quaffle  -- the output is still spiritually a 'foo'
01:33:13 <shachaf> quchen: If (&) was flip (.) and (|>)-or-whatever was flip ($), that would let you do the same thing.
01:33:44 <edwardk> quchen: the issue there is the precedences. you can avoid chained $'s with (.) but (.) has very high precedence. so you can't avoid chained $'s with it when you are using chains of operators
01:34:59 <edwardk> e.g. bar .~ baz $ quux .~ quaffle $ foo    and bar .~ baz . quux .~ quaffle $ foo  doesn't work you need (bar .~ baz) . (quux .~ quaffle) $ foo
01:35:25 <edwardk> since (.) binds tigher than (.~)
01:41:10 <b__> I have a small module with stuff like (&), if', (wrap x y z = x ++ z ++ y), etc
01:41:14 * hackagebot hpaco-lib 0.16.1.0 - Modular template compiler library  http://hackage.haskell.org/package/hpaco-lib-0.16.1.0 (TobiasDammers)
01:41:18 <b__> I bet others have similar modules
01:44:36 <McManiaC> hi, is there a CPP macro (#ifdef ... #endif) thing for GHCi?
01:44:47 <McManiaC> i.e. "#ifdef GHCi runthiscode #endif"
01:44:57 <McManiaC> (+ newlines obviously)
01:46:14 * hackagebot hpaco 0.16.1.0 - Modular template compiler  http://hackage.haskell.org/package/hpaco-0.16.1.0 (TobiasDammers)
01:46:27 <b__> {-# LANGUAGE CPP #-}
01:48:00 <Industrial> Wanting to write a simple program that executes a ls, gets the output as a string, re-sorts part of the ouput and the prints it. https://gist.github.com/b984845b8e6bd7d23864 I'm getting ls.hs:13:3:Couldn't match expected type `IO b0' with actual type `CreateProcess'
01:48:19 <McManiaC> b__: and the macro thing?
01:49:44 <b__> trying to find it
01:50:01 <rrolles> I would like to embed a Haskell interpreter into a third-party program written in C.  I did this once before with OCaml:  basically the OCaml interpreter has a module called TopLoop which exports a function called loop, and consumes input that the user provides, which I obtain through the third-party application. Also I take care of redirecting stdout etc. to the application's specific output
01:50:01 <rrolles> window
01:50:05 <rrolles> am I likely to have a similar process with Haskell, or is there something in particular that I should read / know?
01:52:40 <McManiaC> b__: thanks
01:53:27 <quchen> edwardk: Funny how people bring up beginner confusion as a counter argument with (&). I think Haskell's use of "return" shadows everything, and in general it's very good advice for beginners to assume Haskell has nothing to do with any other language.
01:53:39 <edwardk> heh
01:54:53 <quchen> Problem with Control.Lens is, as stated above, it's a bit much just for flip$. Maybe we should create a Data.Function.Misc package.
01:55:16 <Industrial> learning haskell right now, erik mijer's video talks are doing me good :P
01:55:20 <edwardk> quchen: i was only joking about saying it was the best solution to just import it from there ;)
01:55:40 <quchen> Yes I know that, but nevertheless it's the most standard thing to do this import right now
01:55:50 <b__> McManiaC I can't find it anymore, sorry
01:56:11 <quchen> The real joke is more that your joke wasn't necessarily one
01:56:38 <McManiaC> b__: I've read about #ifdef GHCI a couple of times, but it doesnt seem to get triggered in ghci =(
01:56:45 <b__> oh?
01:56:55 <merijn> rrolles: Check out mueval
01:56:58 <b__> #ifdef GHCI
01:57:07 <b__> big <i>
01:57:09 <merijn> rrolles: I think that's the package used by lambdabot for haskell evaluation
01:57:57 <McManiaC> b__: http://npaste.de/mav/ always outputs no ghci
01:58:03 <McManiaC> at least for me?
01:58:36 <Industrial> Does haskell have a debugger? I'm kind of hesitant to go back to prints everywhere in my code (coming from javascript/nodejs) and with haskell I'm not even sure where to put the prints ... e.g. f = a . b . c  How do I explicitly check the result of b(c(x)) ?
01:59:02 <shachaf> You can use Debug.Trace to print things.
01:59:14 <shachaf> Or you can do other things depending on what you're actually doing.
01:59:26 <merijn> Industrial: Debug.Trace is one of the better places to start
01:59:42 <merijn> Industrial: I think there's some debugger stuff, but in general I don't think it's used very much?
02:00:35 <Industrial> nah Debug.Trace is fine, it seems :-)
02:01:43 <merijn> Industrial: Of course Debug.Trace comes with the (obvious) warning that this stuff is not safe to actually use for doing output in production code
02:02:01 <b__> McManiaC for me too
02:02:34 <Industrial> merijn: right. I just want to check types here and there.
02:04:20 <shachaf> Debug.Trace won't tell you types.
02:07:30 <merijn> Industrial: If you want to check types it's usually simpler to load your code into ghci and use ":t" (alternatively, if you have a complicated subexpression that's hard to query in ghci you can add a type annotation ":: ()" and then the compiler will say "error: expected type () but found whatever-type-I-inferred")
02:09:47 <merijn> Industrial: Also, not directly related to debugging, but more to finding bugs: you should take a look at things like QuickCheck, very neat for finding bugs
02:10:58 <fmap> ghc-mod has a nice interface for quering types of things
02:11:30 <Ralith> which I have never gotten to work
02:11:44 <Ralith> in fact that thing has gotten progressively *less* functional the longer I have had it installed
02:12:02 <b__> ghc-mod is great!
02:12:18 <fmap> well, one major problem is module is required to compile, but yeah, even then it doesn't work 100% of time
02:12:42 <Ralith> right now it can't even launch ghci
02:12:45 <Ralith> just locks up emacs until I ^G
02:14:29 <quchen> Is there a reason the links to GHC.* all seem to be dead? For example, I can't view the source of the Ord typeclass: http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Ord.html#t:Ord
02:14:33 <Industrial> What is the easiest way to invoke a commandline program e.g. ls ?
02:14:44 <quchen> (It's happened to me many times and it left me wondering)
02:15:04 <b__> System.Cmd.system
02:15:08 <b__> @Industrial
02:15:08 <lambdabot> Unknown command, try @list
02:15:17 <`ramses> quchen: works for me...
02:15:51 <`ramses> quchen: ah no, they were still cached in my browser, dead indeed
02:16:05 <quchen> `ramses: Huh? What's the URL it directs you to? For me, it includes %01 and %02
02:16:16 <quchen> ... which seem to be some very low-ASCII values
02:16:47 <edwardk> twanvl: you should join #haskell-lens, all we do is sit around and talk about van Laarhoven lenses all day.
02:18:03 <`ramses> quchen: you were talking about not being able to view the sources on hackage, right?
02:18:37 <quchen> `ramses: Yes. When I click on "source" on the right of "Eq a => Ord a where ...", I get a 404.
02:19:31 <`ramses> quchen: ok, well I thought it worked for me, but turns out my browser had the page still in cache, so it appears to be a dead link indeed
02:19:47 <`ramses> sorry for the confusion :)
02:20:12 <quchen> Sorry for destroying your cache :-)
02:20:52 <quchen> In 4.2.X it still works. At last! http://hackage.haskell.org/packages/archive/base/4.2.0.2/doc/html/src/GHC-Classes.html#Ord
02:21:00 <quchen> (I just clicked some old version.)
02:21:25 <merijn> edwardk: Do you have any lens talk videos online yet somewhere?
02:22:30 <edwardk> i have a talk on lenses in scala available online
02:22:40 <edwardk> i'm doing a talk on wednesday though about the new lens library
02:23:15 <edwardk> https://www.youtube.com/watch?v=efv0SQNde5Q&list=PLEDE5BE0C69AF6CCE
02:23:18 <edwardk> is the scala talk
02:23:47 <edwardk> https://www.youtube.com/watch?v=BiHH3LzKV04 is a more gentle introduction to them in scala by seth tisue
02:24:38 <merijn> The wednesday talk will be recorded, I hope?
02:24:45 <edwardk> yep
02:24:49 <merijn> \o/
02:25:05 <edwardk> i did a version in san francisco a few weeks back, but we weren't allowed by google to record in their facilities
02:25:57 <merijn> mmm, I should just steal your talk for the FP community here :>
02:26:04 <edwardk> http://www.meetup.com/NY-Haskell/events/91576512/ is the new york talk. there appear to still be a few spots open if you know anyone in the area there
02:26:51 <edwardk> merijn: you're welcome to the slides and will have video of how i talk over them to go by ;) that said you may not want to do the entire 2 hours or so i'm going to do in NYC ;)
02:27:25 <merijn> I have a feeling I'd have to drastically simplify anyway :)
02:27:58 <merijn> Especially since the haskell contigent has been fairly small so far (mostly Scala/Erlang/Clojure people)
02:29:16 * gienah would love to watch 2 hour video on lens
02:29:23 <fmap> edwardk: scala talk isn't about lens-style lenses though iirc?
02:29:43 * fmap didn't get much from it anyway since unfamiliar with scala
02:33:00 <edwardk> fmap: fraid not, they aren't even data-lens style, just basic 'getter/setter' pair lenses.
02:33:25 <edwardk> fmap: the audience i was talking to there was mostly unaware of things like even the state monad, etc. so i had to build up a lot of crazy machinery from scratch
02:33:57 <shachaf> Prisms don't have have an equivalent to data-lens style lenses, do they?
02:34:51 <edwardk> shachaf: nobody has written them there
02:35:03 <edwardk> shachaf: prisms so far are a lens-only thing
02:35:46 <shachaf> I just mean an equivalent to moving the s -> parameter out.
02:36:26 <shachaf> (s -> Either t a, b -> t) -- I guess the equivalent would be "moving the t result out", but that doesn't really seem to make sense.
02:36:55 <edwardk> oh yeah the fact that they form store comonad coalgebras is a complete coincidence
02:37:15 <edwardk> there isn't a factoring that makes sense in Hask^op, we don't have coexponentials
02:39:04 <bartavelle> has anybody managed to have ByteStrings be an instance of Unboxed ? Prerequisites for such an instance seem to know GHC internals extremely well ...
02:39:29 <shachaf> How would that work? An array of pointers, or what?
02:39:33 <shachaf> ByteStrings are variable-size.
02:39:41 <bartavelle> array of pointers
02:39:47 <edwardk> bartavelle: they still hole the pointer to the bytestring's backing store alive, so it won't work
02:39:48 <bartavelle> hum that would be pointless
02:39:59 <bartavelle> understood
02:40:09 <bartavelle> wondered how to have a memory efficient bytestring set
02:40:11 <edwardk> er hold even
02:40:27 <edwardk> bartavelle: bytestrings are generally pretty memory hungry
02:40:48 <edwardk> you have something like 72 bytes of overhead before you even start the second character
02:40:48 <bartavelle> ah I figured strict bytestrings would cost some overhead + the CString
02:41:04 <bartavelle> ah yes it is expensive
02:41:35 <bartavelle> I want to remove all words from a file (one word / line) from another (a set difference), where both are large
02:41:36 <edwardk> this is one reason why jaspervdj's efforts to refactor text from utf-16 to utf-8 didn't pay out in practice for instance, the same kind of overhead was present
02:42:08 <shachaf> Why does UTF-8 affect the overhead?
02:42:09 <bartavelle> I intented to form a set for the list of words to remove, and go through the second file only reprinting words not in the set
02:42:18 <edwardk> well, if you hold onto the original file as a bytestring the individual words will all be slices of that file
02:42:43 <bartavelle> yes but they should weight much less than 72 bytes
02:42:46 <edwardk> shachaf: it doesn't but the point was that that baseline overhead was so high the overhead of an extra byte per ascii char wasn't really 'felt'
02:43:18 <edwardk> bartavelle: ou can always hold onto the 'ur' bytestring directly and pass around start and end locations =P
02:43:44 <bartavelle> yes :(
02:43:48 <edwardk> on 64 bits thats probably 32 bytes per
02:43:51 <bartavelle> I'll just write it in C
02:44:12 <edwardk> my usual answer is to just buy a bigger computer ;)
02:44:21 <bartavelle> heh
02:44:25 <bartavelle> this words for some stuff
02:44:44 <bartavelle> I wrote most of my stuff for some research in haskell, and managed to fit everything in 32Gb
02:45:00 <bartavelle> but had I written it in C, I certainly would have been able to use ~2Gb
02:45:17 <bartavelle> except I would not have been confident that the output would be correct
02:45:35 <bartavelle> not that I am with the haskell version, but I am much more confident, so this pays off
02:45:40 <bartavelle> the problem is the 32Gb limit ...
02:49:04 <edwardk> there is always the ability to to the subtraction in multiple passes.
02:49:20 <bartavelle> yes but the point of writing it in haskell is for the program to be simple
02:49:28 <bartavelle> I'm sure I can do it simpler in C by doing it in 1 pass
02:49:53 <bartavelle> (actually I already wrote something similar, so the cost is low)
02:53:04 <edwardk> can you get effective compression by using a trie rather than a flat bytestring?
02:53:21 <edwardk> and are the words long enough that the bytestring overhead is worth it?
02:53:41 <edwardk> if you converted to a list of byte or a list of chars your per character overhead would be lower than the bytestring rep
02:53:48 <edwardk> and you could share tails
02:53:49 <Nereid> ;
02:54:14 <edwardk> bytestrings are great right up until they are the wrong tool for the job =P
02:54:19 <bartavelle> I am unfamiliar with this
02:54:36 <bartavelle> I suppose there are effective data structures for chains sharing common "beginnings"
02:54:40 <edwardk> and its easy to be binded by the 'bytestrings are the fast way' rule of thumbs
02:55:02 <Ralith> bartavelle: common alphabets*
02:55:12 <Ralith> of smallish size
02:55:21 <bartavelle> what do you mean ?
02:55:21 <edwardk> you could store it as a trie for the common beginnings or even as common tails since its not like its too much work to work backwards through a line, etc.
02:55:46 <edwardk> how big is the first file?
02:56:21 <bartavelle> around 500b, 50M words
02:56:33 <bartavelle> that's the order of magnitude I have
02:56:44 <bartavelle> could be 10x this
02:56:46 <edwardk> ok, a suffix array for that fits in about 2 gigs of memory
02:56:50 <edwardk> for that 20
02:57:19 <bartavelle> so I should google for "suffix array" to check what this data structure is like ?
02:57:19 <edwardk> er you don't want a suffix array of the whole thing though
02:57:23 <edwardk> so it'll be way smaller
02:57:34 <edwardk> just thinking
02:57:46 <edwardk> you probably just want to look at one of the trie packages on hackage
02:58:00 <edwardk> http://hackage.haskell.org/package/bytestring-trie
02:58:09 <edwardk> try that and see how well it fits in memory to start
02:58:17 <edwardk> then see if you need to do anything smarter
02:58:37 <bartavelle> alright thanks for the algorithmic advice
02:59:40 <bartavelle> there will be some waste as this is a map and not a set
02:59:43 <bartavelle> but I'll check
03:00:09 <shachaf> Oops, apparently I still don't know how to reply to mailing lists.
03:00:09 <bartavelle> what will be the thing that takes the less amount of memory as value ?
03:00:10 <bartavelle> () ?
03:00:17 <bartavelle> least
03:00:22 <shachaf> That explains why people acted as if they didn't see my message.
03:03:23 <bartavelle> what's the name of the package that does "IO a -> IO (Maybe a)" (catching exceptions in an easy manner)
03:03:51 <bartavelle> errors
03:04:52 <Industrial> I'm not sure what's wrong here: https://gist.github.com/387746b5027eefe8570d
03:05:45 <ocharles> Industrial: I think "ls" ["-AlFGH "] ++ args
03:06:02 <ocharles> I think you want proc "ls" (["-AlFGH "] ++ args)
03:06:07 <shachaf> Industrial: (proc "ls" ["-AlFGH "] ++ args) === ((proc "ls" ["-AlFGH "]) ++ args)
03:06:08 <ocharles> :t proc
03:06:09 <lambdabot> Not in scope: `proc'
03:06:13 <ocharles> meh
03:06:18 <ocharles> :t System.Process.proc
03:06:20 <lambdabot> FilePath -> [String] -> System.Process.Internals.CreateProcess
03:06:26 <ocharles> yea, there we go
03:06:47 <ocharles> Industrial: your code is trying to append to a CreateProcess, but that doesn't make any sense
03:08:28 <Industrial> I want to resort the string output; https://gist.github.com/387746b5027eefe8570d/0961da31c1f6ae0457be91ef5fbca16d13b4a3a5
03:10:20 <`ramses> Industrial: ls args >>= putStrLn
03:10:37 <`ramses> instead of printing the IO String
03:15:16 <Industrial> >== is like (in javascript for example) f=function(x, cb){cb(x*2)};g=function(x, cb){cb(x^2)};f(10, function(x){g(x, function(x){console.log(x == 400);});}); ?
03:15:47 <Industrial> i mean, >>=
03:15:53 <shachaf> Industrial: You can think of the second argument to (>>=) as a callback, sort of.
03:16:15 <tdammers> >>= glues two actions together, feeding the result of the first into the second
03:16:20 <shachaf> It's not quite the same thing but it has some similarities.
03:16:27 <Kosta2> Dear Haskell, your string classes drive me insane
03:16:31 <shachaf> tdammers: I think "the result of the first" is a bit misleading.
03:16:40 <tdammers> yeah well, in lack of a better word
03:16:44 <shachaf> Kosta2: Haskell has string classes?
03:16:51 <tdammers> it's not really a return value, technically
03:16:54 <Jafet> @google javascript monads
03:16:55 <lambdabot> http://igstan.ro/posts/2011-05-02-understanding-monads-with-javascript.html
03:16:55 <lambdabot> Title: Understanding Monads With JavaScript
03:17:27 <Industrial> thanks
03:17:31 <Kosta2> sorry, I meant string "types"
03:17:34 <shachaf> tdammers: It's not really "a value", technically.
03:17:42 <tdammers> touche
03:17:50 <shachaf> It might be more than one value, for example.
03:18:01 <Kosta2> I just searched the docs for 20 minutes trying to match/convert a ByteString.Lazy.UTF8 with a ByteString.Lazy to no avail
03:18:32 <Kosta2> sorry, no I mean make a ByteString.Lazy.UTF8 out of a ByteString.Lazy
03:18:50 <shachaf> Kosta2: You probably should use Data.Text for Unicode text.
03:19:38 <Kosta2> I need to read some gigabyte of logs files and I want to use lazy bytestrings for that
03:19:57 <Kosta2> ATM, I read them using ByteString.Lazy.readFile
03:20:01 <eikke> Kosta2: there's Data.Text.Lazy
03:20:15 <Kosta2> Let me check
03:20:31 <eikke> Kosta2: and Data.Text.Lazy.IO for file handling
03:21:11 <hiptobecubic> typeclasses feel like static duck-typing.
03:21:24 <hiptobecubic> It's a good feeling.
03:21:37 <`ramses> hiptobecubic: polymorphism done right :)
03:22:10 <shachaf> They probably shouldn't.
03:22:55 <tdammers> "static duck typing"?
03:23:20 <tdammers> to me, typeclasses feel like the exact opposite of duck typing
03:23:38 <Kosta2> If I use Data.Text.Lazy.breakOn, will the returned substrings point to the original text or be copies?
03:23:39 <tdammers> as in
03:23:54 <tdammers> "this thing promises to be a duck, so it's safe to assume I can make it quack"
03:24:09 <t7> duck typing is usually not type checked :|
03:24:20 <tdammers> exactly
03:25:24 <`ramses> except when you view structural typing like some kind of duck typing
03:30:08 <yitz> Kosta2: are you asking about memory usage? don't worry about that.
03:30:40 <yitz> Kosta2: i mean, worry about memory usage, but don't worry about whether that is implemented by copies or not.
03:31:18 <yitz> Kosta2: what you want to worry about is whether you keep references laying around that pile up
03:31:23 <Kosta2> Hm, but in this case, I want to worry about that
03:32:15 <yitz> Kosta2: why? the whole point of a garbage collected language is that you don't have to.
03:33:01 <Kosta2> well I want to see if ugly-parsing-by-myself-with-lazy-bytestrings is faster than attoparsec-with-strict-bytestring
03:33:48 <Industrial> I'm so going to hack at these monads with coffeescript now Jafet :p
03:34:17 <yitz> Kosta2: ok. in either case, you'll want to try to process each line on its own, and not keep around any per-line information, unless you don't mind having it all in memory.
03:34:20 <tdammers> Kosta2: what about attoparsec-with-lazy-bytestring?
03:34:27 <eikke> Kosta2: you're aware lazy strings are streams of strict chunks?
03:34:44 <yitz> Kosta2: btw why bytestrings at all? this is binary data?
03:34:57 <Kosta2> Nope
03:35:00 <yitz> Kosta2: you almost always want to use text for text.
03:35:18 <Kosta2> This is actually ascii
03:35:20 <tdammers> what if it's encoding-agnostic text?
03:35:28 <yitz> tdammers: use Data.Text.
03:35:51 <Kosta2> I need to feed parts of it into Network.HTTP.Types.URI.decodePath
03:36:10 <Kosta2> and that wants a ByteString.Lazy.UTF8
03:36:39 <tdammers> well, HTTP is essentially a binary protocol, really
03:36:50 <yitz> Kosta2: hmm? what is that?
03:37:10 <Kosta2> It seems I'd need to go Text to String to ByteString.Lazy.UTF8
03:37:18 <yitz> Kosta2: there is ByteString.Lazy and ByteString. Once you talk about encodings, you are in Text, not bytestrings.
03:37:47 <eikke> Kosta2: http-types 0.7.3.0.1's Network.HTTP.Types.URI.decodePath wants ByteString as input
03:37:51 <eikke> not ByteString.UTF8
03:38:10 <Kosta2> yitz: It takes  an HTTP path&query, like /path/to/foo?a=1&b=2 and splits that into path :: [Text] and query : Query (which is [(Text, Text)])
03:38:21 <Kosta2> eikke: ok, in that case I read my ghc error wrongly
03:38:49 <Kosta2> ah, stupid me
03:38:51 <yitz> Kosta2: the module ByteString.Lazy.Char8 provides some hacks to treat a string of bytes as ASCII-encoded text, but you usually want to avoid using it except in certain special circumstances.
03:38:58 <eikke> and it returns ([Text], Query), which makes perfect sense
03:39:11 <Kosta2> yeah that part makes sense
03:39:30 <Kosta2> sorry I had a wrapper function in-between with a screwed up type signature
03:39:51 <neutrino> hi
03:40:15 <Kosta2> Hi
03:40:15 <yitz> Kosta2: if your application deals with text and then needs to send it over http, you use Data.Text, and then just as you send it you encode it using Data.Text.Encodings.
03:40:30 <eikke> Basically: "binary" strings (byte sequences) -> Bytestring. "human readable" string, i.e. text (in some encoding) -> Text. Conversion between both -> Data.Text.Encoding. And both have lazy variants if required/useful
03:40:34 <Kosta2> yitz: No I'm just parsing the path&query from a log file
03:45:26 <yitz> Kosta2: i think you want parseURI from the network package.
03:46:27 <yitz> Kosta2: it takes the URI as a String, but you just use T.unpack. URIs (even big ones) are small enough that it won't cost you anything significant.
03:49:30 <yitz> Kosta2: by using the uri parser from an http library, you are forcing yourself to encode your text as if it were coming over the wire, and only then parse it.
03:50:28 <Kosta2> yitz: ok, I'll look into it
03:52:49 <Kosta2> great, another stack overflow :(
03:53:00 <Kosta2> (unrelated to String types)
03:53:56 <eikke> Kosta2: depending on what you're trying to do with the decoded URIs and the size of your log file, you might want to consider other approaches than lazy IO
03:54:18 <fmap> parseURI seems to be much simpler than decodePath, you just get (String, String) instead of ([Text], [(ByteString, Maybe ByteString)])
03:55:25 <Kosta2> yes, but it also does not parse the actual query string
03:55:33 <Kosta2> I need that for some of that data
03:56:41 <Kosta2> eikke: Basically, I'm splitting the ByteString.Lazy into a list of lines, parse those into a list of LogLine types and foldr over that to produce a LogStatistics that I output as JSON
04:01:53 <eikke> I guess I'd use Conduit with something like "CB.sourceFile fileName $= CB.lines =$= CL.map parseURI $$ CL.fold updateState state0" with CL = Data.Conduit.List and CB = Data.Conduit.Binary
04:03:02 <eikke> Kosta2: with parseURI :: ByteString -> SomethingURILike and updateState :: ResultType -> SomethingURILike -> ResultType
04:04:55 <eikke> Kosta2: CL.fold is a strict left fold
04:07:27 <Kosta2> eikke: that looks good, but I'm a bit afraid to really look into conduits :)
04:08:56 <Kosta2> ok I think cabal screwed everything up for me again...
04:09:29 <Kosta2> shouldn't the ByteString type from import qualified Data.ByteString.UTF8 and Data.ByteString be the same?
04:09:58 <Kosta2> and the ByteString type from Data.ByteString.Lazy.UTF8 and Data.ByteString.Lazy be the same?
04:10:26 <Kosta2> because I'm getting the error Couldn't match expected type `BL.ByteString' with actual type `BLU.ByteString'
04:10:39 <Kosta2> where BL = Data.ByteString.Lazy and BLU = ...UTF8
04:11:30 <Kosta2> reason could be: `cabal info bytestring` saying: Versions installed: 0.9.2.1, 0.10.0.1
04:12:25 <byorgey> Kosta2: which package is Data.ByteString.UTF8 from?  there is no module with that name in the 'bytestring' package
04:12:39 <byorgey> Kosta2: there is nothing wrong with having multiple versions of a package installed.
04:12:44 <shachaf> @google Data.ByteString.UTF8
04:12:46 <lambdabot> http://hackage.haskell.org/packages/archive/utf8-string/0.3/doc/html/Data-ByteString-UTF8.html
04:12:46 <lambdabot> Title: Data.ByteString.UTF8
04:12:51 <shachaf> That one. :-)
04:13:02 <byorgey> Kosta2: if that were the problem, the error message would have package and version numbers prefixed to the types
04:13:23 <byorgey> like "couldn't match  bytestring-0.9.2.1:Data.ByteString with actual type ... "
04:14:44 <byorgey> Kosta2: but hmm, you're right, Data.ByteString.UTF8 appears to just re-export the ByteString type from Data.ByteString
04:15:50 <Kosta2> I installed a new version of the bytestring package to get toStrict and fromStrict in Data.ByteString.Lazy
04:16:28 <Kosta2> now I cannot use Data.ByteString.Lazy.putStrLn anymore with an Data.ByteString.Lazy.UTF8 ByteString
04:17:24 <byorgey> well, if utf8-string was built against bytestring-0.9.2.1, then you would get this problem
04:17:42 <Kosta2> So do I need to reinstall utf8-string?
04:18:17 <byorgey> Kosta2: try 'ghc-pkg describe utf8-string'
04:18:25 <byorgey> it will tell you which version of bytestring it depends on
04:18:42 <byorgey> if it's 0.9.2.1, then yes, you need to reinstall it
04:18:44 <Kosta2> depends  bytestring-0.9.2.1-0044644a71adfe5e950e6c6f6ca13065
04:18:49 <byorgey> assuming that doesn't break other stuff
04:19:05 <byorgey> Kosta2: what does 'cabal --version' say?
04:19:05 <Kosta2> I assume this will break my wai/warp/yesod installation, we'll see
04:19:33 <Kosta2> cabal-install version 1.16.0.2
04:19:33 <Kosta2> using version 1.16.0.3 of the Cabal library
04:19:40 <byorgey> ok, good
04:19:52 <byorgey> so that means it will warn you before breakinf stuff
04:19:55 <byorgey> *breaking
04:20:09 <Kosta2> cabal: The following packages are likely to be broken by the reinstalls:
04:20:09 <Kosta2> yesod-platform-1.1.4.1
04:20:09 <Kosta2> xss-sanitize-0.3.2
04:20:09 <Kosta2> yesod-form-1.1.3
04:20:09 <Kosta2> yesod-auth-1.1.1.2
04:20:10 <Kosta2> yesod-1.1.2
04:20:10 <Kosta2> language-javascript-0.5.6
04:20:11 <Kosta2> hjsmin-0.1.3
04:20:11 <Kosta2> http-conduit-1.6.1.2
04:20:12 <Kosta2> authenticate-1.3.1.1
04:20:29 <eikke> Kosta2: why are you still bothering with utf8-string?
04:20:53 <Kosta2> eikke: cause I want to write my program that way first
04:21:17 <Kosta2> eikke: converting it to conduit will set me back to square 1 for now and I don't want that right now
04:21:35 <eikke> Kosta2: I'm rather referring to why you wouldn't use Text instead
04:22:05 <Kosta2> eikke: because it seems to me that using http-types decodePath better fits what I want to do
04:22:52 <Kosta2> cabal was that great tool that couldn't delete packages, right?
04:23:17 <Kosta2> solution is to delete the package manually from  ~/.cabal/packages/hackage.haskell.org ?
04:23:50 <merijn> Kosta2: Cabal only uses the the library tools of GHC which only track registered libraries, not which files they install. So you can unregister libraries, but that won't delete the files
04:23:54 <sopvop> actually from .ghc
04:24:14 <eikke> Kosta2: decodePath takes a ByteString. I still don't get what you'd need utf8-string for
04:25:16 <Kosta2> eikke: utf8-string is just GHC's way of telling me that I cannot use bytestring-10 because everything else is linked against bytestring-9
04:25:19 <bxc> does STM ensure that if I read two TVars in an atomically block, then no modifications to the 2nd tvar have happened in between me reading the first and the second? (I'm thinking baout code that only reads from tvars, not writes)
04:25:38 <shachaf> bxc: Yes.
04:25:51 <eikke> bxc: if a write did occur, your transaction will be restarted, so yes, sorta :P
04:26:06 <shachaf> "sorta"? That's the whole point of STM.
04:26:13 <shachaf> Everything in atomically will be executed atomically.
04:26:18 <bxc> yeah restartis what I want
04:26:19 <bxc> ok
04:26:29 <bxc> just one explanation i read suggests aborts only happen on writes
04:26:35 <bxc> (of which i'm doing none)
04:26:39 * sopvop wonders why almost all 'cabal problems' happen with yesod
04:26:48 <eikke> shachaf: I was reffering to the fact a write *might* have occurred in-between (but you won't percieve it as-is)
04:27:11 <eikke> Kosta2: if you don't import utf8-string in your app and only use bytestring, things should work fine, isn't it?
04:27:38 <Kosta2> bxc: If there's only reads, there's no reason to restart
04:27:43 <merijn> bxc: Well, writes are the only things that would change the contents of a TVar, no?
04:27:53 * shachaf sighs.
04:28:20 <Kosta2> eikke: well, decodePath is linked against bytestring-9 and won't accept a bytestring-10
04:28:32 <eikke> right, that makes sense
04:29:04 <bxc> Kosta2: thread 1 reads A, reads B. thread two writes A, writes B. I'm trying to make sure i get a consistent (A,B) snapshop
04:29:32 <bxc> so I don't really mind who does the retrying... what I care about is that I won't see A before the thread 2 commit and B after the thread 2 commit
04:29:36 <Kosta2> bxc: In that case, depeding on your orderings, there might be restarts but it will be atomic
04:29:42 <bxc> yeah
04:29:44 <bxc> coolio
04:30:21 * bxc finally has some use for STM so its shaking out bugs in my understanding
04:30:33 <Kosta2> bxc: But consider thread1: reads A, reads B. thread 2: reads B reads A, thread 3 reads A, reads B. No conflicts -> no restarts
04:30:49 <Kosta2> So I have bytestring: Versions installed: 0.9.2.1, 0.10.0.1
04:30:56 <Kosta2> How do I get rid of 0.10.01?
04:30:59 <bxc> Kosta2: right
04:31:45 <bxc> one thing i read didn't describe isolation like that, when I'd assumed it did but then worried because i wasn't reading that
04:32:28 * bxc finds that isolation definition in spj/beautiful concurrency.
04:33:02 <eikke> bxc: what does it say?
04:33:13 <bxc> "it" ?
04:33:22 <eikke> the definition you refer to
04:33:44 <bxc> the beautiful concurrency one?
04:34:00 <eikke> i guess :)
04:34:06 <bxc> that an atomically block behaves as if a snapshop was taken of all the variables at the start of the block.
04:35:00 <bxc> and thats what you see
04:35:17 <eikke> so what was confusing you?
04:35:18 <bxc> which is what i want and thought was the case, and turns out to be the case
04:35:28 <bxc> eikke: oh there was another bit i read at the start of realworld haskell
04:35:39 <bxc> that only talked about the atomicity part, not that snapshot style isolation
04:35:49 <bxc> let me go find tha tagain
04:36:13 <bxc> oh i missed a bit "nor can our thread see any changes made by other threads. "
04:36:14 <bxc> ok
04:36:17 <bxc> all is good in the world
04:36:25 <eikke> :)
04:36:47 <bxc> now its back to how i thought it worked.
04:36:55 <merijn> \o/
04:37:23 <edwardk> admittedly the instance (a ~ a2, a ~ a3, a ~ a4, a ~ a5, a ~ a6, a ~ a7, a ~ a8, a ~ a9, b ~ b2, b ~ b3, b ~ b4, b ~ b5, b ~ b6, b ~ b7, b ~ b8, b ~ b9) => Each Int (a,a2,a3,a4,a5,a6,a7,a8,a9) (b,b2,b3,b4,b5,b6,b7,b8,b9) a b where
04:37:23 <edwardk>  looks pretty funny
04:37:29 <edwardk> er wrong channel
04:37:59 <bxc> was it aimed at #typechecking-porn ?
04:38:04 <edwardk> hahahahah
04:38:33 <edwardk> oooh unify with me baby, unify with me!
04:39:06 <edwardk> oh, who's a naughty skolem variable? you are!
04:39:26 * ocharles shakes his head
04:39:27 <merijn> ...
04:39:41 <merijn> I worry edwardk might be getting into this a little too much >.>
04:39:46 <edwardk> heh
04:39:54 <ocharles> if this is what it takes to produce lens i'm ok with that.
04:40:02 <edwardk> =)
04:40:32 <merijn> lenstube, redlens, what more do we have? :>
04:40:37 <edwardk> https://github.com/ekmett/lens/blob/master/src/Control/Lens/Each.hs is the class in question
04:41:17 <edwardk> its a bit evil and DWIMmy but it lets us to do a lot with one little combinator
04:41:37 <merijn> The little combinator that could?
04:41:45 <edwardk> yeah
04:43:59 <ocharles> i like how this file throws a  finger at the 78-characters-per-line idea
04:45:13 <edwardk> =)
04:45:33 <edwardk> that was the rest of you guys. ;) i'm fine with much longer line lengths
04:45:45 <edwardk> heck my laptop has a 2560x1600 display, whats the problem =P
04:46:03 <sopvop> does it fit on HD screen with 14pt font?
04:46:12 <sopvop> oh
04:46:34 <edwardk> it fits on my screen
04:46:44 <edwardk> quite handily even
04:46:49 <typoclass> edwardk: you should get a proper window manager
04:47:01 * typoclass whistles innocently and strolls away
04:47:09 <edwardk> i have one, when i run out of room for windows, i buy another monitor =P
04:49:43 <bartavelle> edwardk, your trie advice was sensible, it did indeed only take ~2G, but the runtime performance is horrendous. Also the profiler reportes it ran in 40s, whereas time says it ran in 15 minutes.
04:50:45 <edwardk> you can build a packed trie/suffix array implementation that could do better than bytestring-trie, it was just the simplest thing you could reach for that would work
04:57:12 <bartavelle> will look at it, thx
05:00:39 <invariant> Is changing the last x to y a valid alpha renaming? (forall s. ST s (Foo x)) -> Foo x
05:00:54 <invariant> Is changing the last x to y a valid alpha renaming? (forall x. ST x (Foo x)) -> Foo x
05:00:56 <Heffalump> you have to change both of the occurrences of x
05:01:14 <byorgey> invariant: now it is valid, yes
05:01:31 <byorgey> in your second type
05:01:45 <invariant> byorgey, yeah, it was a typo.
05:04:18 <yitz> edwardk: we need to appy to icann for a new .lens tld. that will help prevent people not intellectually mature from inadvertently seeing such things.
05:04:57 <typoclass> yitz: i hear most of edwardk's packages are on parental block lists
05:05:11 <edwardk> yitz: =P
05:06:30 <edwardk> instance (a ~ a2, a ~ a3, a ~ a4, a ~ a5, a ~ a6, a ~ a7, a ~ a8, a ~ a9, b ~ b2, b ~ b3, b ~ b4, b ~ b5, b ~ b6, b ~ b7, b ~ b8, b ~ b9) => Each Int (a,a2,a3,a4,a5,a6,a7,a8,a9) (b,b2,b3,b4,b5,b6,b7,b8,b9) a b where each = Lens.indexed $ \ f ~(a,b,c,d,e,g,h,i,j) -> (,,,,,,,,) <$> f (0 :: Int) a <*> f 1 b <*> f 2 c <*> f 3 d <*> f 4 e <*> f 5 g <*> f 6 h <*> f 7 i <*> f 8 j -- is a perfectly cromulent line of code with a reasonable
05:06:30 <edwardk>  line length.
05:06:32 <edwardk>  
05:06:48 <typoclass> edwardk: your irc client didn't seem to agree there
05:06:51 <edwardk> hahahaha
05:09:03 <fmap> I hope that's generated somehow
05:11:19 * hackagebot tkyprof 0.1.0.1 - A web-based visualizer for GHC Profiling Reports  http://hackage.haskell.org/package/tkyprof-0.1.0.1 (MitsutoshiAoe)
05:11:21 * hackagebot chuchu 0.4.1 - Behaviour Driven Development like Cucumber for Haskell  http://hackage.haskell.org/package/chuchu-0.4.1 (FelipeLessa)
05:17:33 <noteventime> I can't seem to figure out how to serialize Vector, Data.Vector.Binary from vector-binary-instances loads, but it still complains about missing instances.
05:36:45 <yitz> edwardk: i have a question about lenses. what would be a neat way to implement this using lenses:
05:36:49 <yitz> > let ed n=let s=intersperse", ".flip map(map show[2..n]).(++)in(concat.concat)[["instance ("],s"a ~ a",[") => Each Int (a, "],s"a",[") (b, "],s"b",[") a b where each = Lens.indexed $ \\ f ~(c, "],s"c",[") -> (",replicate(n-1)',',") <$> f (0 :: Int) c"],concat[[" <*> f ",show$k-1," c",show k]|k<-[2..n]]]in ed 9
05:36:51 <lambdabot>   "instance (a ~ a2, a ~ a3, a ~ a4, a ~ a5, a ~ a6, a ~ a7, a ~ a8, a ~ a9) ...
05:37:05 <yitz> > let ed n=let s=intersperse", ".flip map(map show[2..n]).(++)in(concat.concat)[["instance ("],s"a ~ a",[") => Each Int (a, "],s"a",[") (b, "],s"b",[") a b where each = Lens.indexed $ \\ f ~(c, "],s"c",[") -> (",replicate(n-1)',',") <$> f (0 :: Int) c"],concat[[" <*> f ",show$k-1," c",show k]|k<-[2..n]]]in ed 3
05:37:07 <lambdabot>   "instance (a ~ a2, a ~ a3) => Each Int (a, a2, a3) (b, b2, b3) a b where ea...
05:37:15 <typoclass> yitz: seems already extremely neat, what's the problem
05:37:28 <yitz> my my lambdabot has gotten stingy lately
05:38:14 <sopvop> Is there a way to demote data type promoted to kinds? :)
05:39:47 <hpaste> quchen pasted “Why is this bottom?” at http://hpaste.org/79039
05:40:45 <danr> quchen: because a = a*2 is an infinite loop
05:40:54 <danr> it's a letrec, really
05:41:07 <quchen> Is it? I thought the RHS is evaluated, the LHS defines the replacement pattern
05:41:29 <danr> ah, no, in let a = a*2, on the RHS, a in bound to the a on the LHS
05:41:39 <danr> thus you can write circular structures such as let xs = 1 : xs
05:41:54 <quchen> Oh, I see. I thought lets were evaluated differently.
05:41:54 <typoclass> > let xs = 1 : xs in xs
05:41:55 <invariant> quchen, you are writing down "to compute a, compute a *2'.
05:41:56 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
05:42:09 <typoclass> (infinite list of ones)
05:42:28 <quchen> I just played around with scoping in do notation, and had to think of "let a=b, b=a in ..."
05:42:34 <quchen> And thought I could get rid of the b
05:42:44 <danr> quchen: nope... mainly for better, but you'll have to make up a new variable name here (a')?
05:42:57 <j3ssi> can someone help me to contruct a datatype. the datatype should  be like: DAut [a]  where [a] is a infinite list
05:43:10 <invariant> quchen, you can use let x =1;....; return 23
05:43:12 <danr> j3ssi: data DAut a = DAut [a] ?
05:43:12 <quchen> danr: I know it's not good code, I was just wondering why it's not working bad code
05:43:23 <danr> quchen: ok :)
05:43:25 <invariant> quchen, (in a do block)
05:44:03 <hpaste> quchen pasted “Fixed it for laughs” at http://hpaste.org/79040
05:44:13 <quchen> Thank you #haskell ;-)
05:44:26 <danr> quchen: clever ;)
05:44:40 <invariant> quchen, a new kind of terrible.
05:45:19 <quchen> invariant: Don't challenge me to write a preprocessor macro for doing this so I can update my variables without the helper prime
05:46:07 <invariant> quchen, why don't you just program in the programming language you want and build a smallish compiler to deploy on GHC if that's what you want?
05:46:08 <danr> quchen: use STRefs? :D
05:46:18 <typoclass> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs -- quchen: you saw the infinite list above. here's something slightly more elaborate. the zipWith and tail stuff is not so important; the point is that you can see that the definition of fibs gives the first elements and then refers to the definition of fibs.
05:46:19 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
05:46:46 <danr> I think imperative programming in Haskell is underappreciated
05:46:48 <quchen> typoclass: I'm familiar with pattern matching, I just thought let bindings were evaluated in a special way
05:47:07 <quchen> danr: I don't need STRefs. New let scopes and unsafePerformIO work just as good
05:47:40 <invariant> They do something completely different save for your usecase.
05:48:14 <quchen> Of course they do
05:49:05 <j3ssi> how do I construct datatypes on haskells intern list type ?
05:49:54 <danr> j3ssi: I gave you a suggestion above
05:51:26 <j3ssi> danr: and how can i implement that [a] should always be a infinite list ?
05:52:09 <danr> j3ssi: maybe you're looking for a stream: data Stream a = a :< Stream a
05:52:12 <eikke> j3ssi: data InfList a = Cons a (InfList a) ?
05:53:02 <yitz> j3ssi: data DAut a = DAut a (DAut a)
05:53:31 <j3ssi> thanks
06:11:31 <`ramses> r
06:12:59 <SplinterOfChaos> Are there any good Haskell music composition libraries?
06:13:07 <SplinterOfChaos> midis and stuff.
06:16:28 <`nand`> I remember something about declarative music generation
06:16:31 <`nand`> but no specifics, sorry
06:18:47 <Cale> SplinterOfChaos: There's Haskore, but the version of that on Hackage is maintained by Henning Thielemann and is thus unusable, because he insists on naming every type T and every typeclass C.
06:19:21 <Cale> You might be able to get Paul Hudak's original version.
06:19:48 <SplinterOfChaos> Yeah, I started playing around with Haskore last night. I seems usable /enough/.
06:20:17 <quchen> Cale: Why does he insist in doing this? Conciseness?
06:20:25 <Cale> quchen: I don't know, he's just weird
06:20:32 <S11001001> I think the idea is qualified imports everywhere.
06:21:01 <Cale> But in many cases it makes me quite upset when he takes over maintainership of a perfectly sane Haskell library and makes it ridiculous.
06:21:55 <quchen> Haven't thought of coding like this yet. It'll make a good entry in my list for obfuscating code
06:22:55 <paolino> He is very helpful, fwiw.
06:24:46 * typoclass doesn't know him, but based on cale's description, i imagine him as a cat saying "o hai i upgraded ur pkg"
06:24:57 <S11001001> e.g. Say you import qualified Data.List.NonEmpty as NonEmpty; then you have to say NonEmpty.NonEmpty to refer to the type.  NonEmpty.T seems clear enough.
06:25:17 <quchen> typoclass: What's the bad thing about "updating ur pkg"?
06:25:54 <eikke> S11001001: import Data.List.NonEmpty (NonEmpty)\nimport qualified Data.List.NonEmpty as NonEmpty
06:26:21 * hackagebot http-conduit-browser 1.7.2 - Browser interface to the http-conduit package  http://hackage.haskell.org/package/http-conduit-browser-1.7.2 (MikhailKuddah)
06:26:21 <S11001001> eikke: I'm not saying it's the only way to do it, just that one style seems to imply the other
06:26:23 <typoclass> quchen: i don't know if it's bad, i have no opinion on that :-) but cale was mentioning taking perfectly sane packages and making them ridiculous
06:26:31 <Cale> paolino: He certainly does a lot of work, but this side effect of what he does makes a lot of packages annoying to use.
06:26:37 <eikke> (calling some type T in some module, then using modulename.t everywhere is something I regularly see in OCaml)
06:26:59 <S11001001> eikke: as the functions on it are also in the module?
06:27:09 <eikke> s/T/t/
06:27:11 <eikke> S11001001: yes
06:27:16 <Cale> Haskell tools aren't equipped to deal with it -- in particular, Haddock likes to display all names unqualified.
06:27:29 <Cale> So it makes the documentation horrible to try to read
06:27:36 <eikke> S11001001: and the 'type t' is made abstract most of the time
06:27:38 <S11001001> I imagine deriving Show is the same
06:28:46 <typoclass> S11001001: i see your point, it could occasionally be clear to say "NonEmpty.T". but i guess you'd need a big bold warning in the haddock page, "this is meant only for being imported qualified". and cale has a point also
06:29:20 <quchen> I think the first time I felt like that was when reading "data RWS r w s a = RWST r w s Identity a"
06:29:27 <quchen> That one turned out to make sense however
06:29:28 <S11001001> typoclass: aye
06:29:59 <tdammers> quchen: in that example, the T stands for "Transformer" though, not "Type"
06:30:00 <b__> :t a . b (.)
06:30:02 <lambdabot>     Couldn't match expected type `a0 -> b0' with actual type `Expr'
06:30:02 <lambdabot>     In the first argument of `(.)', namely `a'
06:30:02 <lambdabot>     In the expression: a . b (.)
06:30:27 <b__> > let a … b = a . b (.)
06:30:27 <lambdabot>   mueval: recoverEncode: invalid argument (invalid character)
06:30:38 <S11001001> eikke: maybe that's where Thielemann gets the style?
06:31:46 <eikke> i guess
06:32:21 <eikke> I'd consider it not very Haskell'ish though
06:33:15 <paolino> Cale, I think one should not rename inside someone else package. There should be a limit for when one can break this rule, though.
06:33:17 <eikke> and, as you noted, not very useful in combination with deriving Show etc (which doesn't exist in OCaml as-is, you implement your own string_of functions etc)
06:33:32 <S11001001> yeah
06:35:10 <quchen> Cale: From unmaintain: a naming convention from the world of C++ is the use of "m_" in front of members. This is supposed to help you tell them apart from methods, so long as you forget that "method" also starts with the letter "m".
06:35:15 <Cale> I've considered writing an automatic "dehenning" tool, but it's not terribly easy, mainly because Haskell imports are subtle.
06:35:26 <osfameron> cluck!
06:36:08 <typoclass> quchen: very good :-)
06:37:13 <Cale> In some cases it might be worth it to just do the translation by hand at some point and post versions of the packages with some affix on their name to indicate the change. Keeping them up to date might be a hassle though.
06:38:41 <neutrino> hello
06:39:09 <Cale> Hi neutrino
06:39:34 <neutrino> hi Cale, i am trying to figure out a good way to log a subprocess
06:40:08 <Cale> Have you seen the stuff in System.Process?
06:40:21 <Cale> (or do you mean something else by subprocess?)
06:40:36 <neutrino> yeah. it's more of a design issue or technicality.
06:42:16 <Cale> Well, I'm a little bit unclear on exactly what "log a subprocess" means in your case.
06:42:35 <Cale> Do you have some code which accomplishes the goal in a bad way?
06:42:35 <neutrino> you see, i have a subprocess. i need to do several things to its output: 1. when it's outputting, a timestamp has to be written with the last output that happened. due to performance reasons, this should only happen every second or so. 2. when it's outputting, its stdout and stderr should go to stdout and stderr of the main program respectively. 3. its stdout and stderr should also go to a log file. this log file should contain both at once,
06:42:44 <Cale> oh, okay
06:42:48 <neutrino> oh, the timestamp is written to a database.
06:43:05 <Cale> So you really do mean an honest OS subprocess and not the more flexible meaning of that term :)
06:43:37 <Cale> Right, so probably you're going to want a couple of threads.
06:43:42 <neutrino> so, yesterday jmcarthur showed me a way of doing that line-by-line
06:44:02 <neutrino> yeah. he explained to me how to do it with the async module.
06:44:17 <Cale> ah, how modern :)
06:44:28 <Cale> I was going to say use a Chan, but async is great
06:44:58 <neutrino> however, if i do it linewise, the output will be falsified
06:45:20 <Cale> what do you mean?
06:45:32 <neutrino> consider this situation: let's say the subprocess is a build system, and it has 1000 components to build, each takes a second.
06:45:56 <neutrino> every time one is built, a dot (with no newline) is sent to stdout. when an error happens, a string is written to stderr.
06:46:21 <Cale> ah, so you just want to turn buffering off?
06:46:21 * hackagebot snaplet-sqlite-simple 0.3.0 - sqlite-simple snaplet for the Snap Framework  http://hackage.haskell.org/package/snaplet-sqlite-simple-0.3.0 (JanneHellsten)
06:46:29 <neutrino> if you ran it in a terminal, and an error happened on the fifth dot, you'd see something like: "....error: something bad happened\n...." and so on
06:46:37 <Cale> right
06:47:08 <neutrino> however, if i did it linewise, i'd get: "stderr> error: somthing bad happened\nstderr> error: something else happened\nstdout> ........................" and so on
06:47:20 <neutrino> so i think i need to do it char by char.
06:47:39 <Cale> hSetBuffering :: Handle -> BufferMode -> IO () -- might be useful
06:47:56 <neutrino> that's a good tip. i'll keep that in mind.
06:48:49 <neutrino> however, i am troubled that doing it char-by-char comes with another issue. a lot of output will be generated, and if i keep spawning new threads for every new char, i think that just might end up being very, very bad
06:49:10 <neutrino> so i'll have to think of something else. possibly still using the async module.
06:49:30 <Cale> Threads are only a handful of bytes
06:50:00 <Cale> But I'm not certain why you'd be creating new threads for every char...
06:50:45 <Cale> You conceptually have two threads: the one which is running and talking to the subprocess, and the one which is handling the log.
06:50:49 <neutrino> well, the way that jmcarthur showed me was basically "set up a new deferred (separate thread) which waits for a line to come through, or time out"
06:50:56 <neutrino> yeah
06:51:19 <neutrino> i'll probably need two more: one which waits for a char on the subprocesses stdout, and one on stderr.
06:51:24 <Cale> Right, okay, well, that's only one thread at a time, isn't it?
06:51:32 <Cale> Shouldn't be a problem.
06:51:37 <neutrino> yeah.
06:51:48 <neutrino> but i'm not 100% sure how to do it, so i'll have to do some reading up.
06:51:53 <Cale> GHC threads are extremely lightweight.
06:51:56 <neutrino> i'll probably need a separate thread as well for the database
06:52:10 <neutrino> oh yeah, i'm happy with spawning 100s of threads
06:52:23 <neutrino> i'm just unhappy with spawning 10000s of threads per second.
06:52:51 <Cale> There's probably some cost associated to that, but until you see what it is, I wouldn't worry about it.
06:53:06 <neutrino> it just doesn't feel right.
06:53:14 <neutrino> but maybe i should try it and see it fail.
06:53:21 <osfameron> that sounds like a scientific approach
06:53:26 <neutrino> just so that i can tell the tale.
06:53:29 <Cale> There's a simple solution to this involving two threads and a Chan at the very least, but if you already have something close which uses the async abstraction, don't worry.
06:53:42 <neutrino> osfameron: i guess that reinforces the whole haskell-academia meme
06:53:45 <Cale> The abstraction is there to be used
06:53:51 <neutrino> what is a Chan?
06:54:07 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/base-4.6.0.0/Control-Concurrent-Chan.html
06:54:09 * neutrino hoogles
06:54:09 <neutrino> ah
06:54:13 <neutrino> you were faster :)
06:54:16 <osfameron> neutrino: is "it doesn't feel right" the more enterprisey real-world approach then?
06:54:28 <neutrino> osfameron: yes.
06:54:38 * osfameron takes notes
06:55:16 <neutrino> Cale: ok, so a Chan is a fifo, and it can be written to from one thread and read from another, yes?
06:55:34 <burrows> With the type Maybe, would we correctly call "Just a" the monadic type constructor?
06:56:01 <johnw> burrows: Just is a value constructor
06:56:01 <lambdabot> johnw: You have 1 new message. '/msg lambdabot @messages' to read it.
06:56:11 <neutrino> oh, hi johnw..
06:56:27 <johnw> burrows: Maybe a is a type constructor, and Maybe is a Monad
06:56:28 <Cale> neutrino: yeah
06:56:42 <johnw> hi neutrino!
06:56:44 <neutrino> Cale: that looks great.
06:56:54 <neutrino> thanks for the tip.
06:56:59 <Cale> burrows: Just is a data constructor, not a type constructor
06:57:15 <neutrino> is there such a thing as a type constructor?
06:57:33 <neutrino> oh, Foo a
06:57:35 <neutrino> hmm.
06:57:41 <burrows> Alright I'm kind of confused.
06:57:48 <Cale> burrows: also, the fact that Maybe is a monad is incidental, not something which is central to what the type constructor Maybe is, or what the data constructors Nothing and Just are.
06:57:49 <neutrino> can you say a type, which has no parameters, is a type constructor?
06:58:07 <Cale> I wouldn't say that "Maybe a" is a type constructor, but it is a type.
06:58:12 <burrows> Just asking because of this book. http://book.realworldhaskell.org/read/monads.html
06:58:46 <burrows> Says the first property of a Monad is "A type constructor m."
06:58:54 <Cale> Yeah
06:59:06 <Cale> So m = Maybe, for example.
06:59:15 <burrows> Gotcha.
06:59:27 <burrows> So a type constructor is defined in terms of data constructors?
06:59:53 <Cale> yeah, I think this really ought to have been introduced earlier in the book...
07:00:00 <Cale> But Maybe is defined as:
07:00:06 <Cale> data Maybe a = Nothing | Just a
07:00:13 <Cale> which means that for each type a
07:00:38 <Cale> Every value of type Maybe a is either the value Nothing
07:00:53 <Cale> or is a value of the form Just x, where x has type a
07:01:01 <burrows> Okay.
07:01:04 <Cale> For example, Just 5 :: Maybe Integer
07:01:45 <Cale> :t [Just "hello", Nothing, Just "world", Nothing, Nothing]
07:01:46 <lambdabot> [Maybe [Char]]
07:02:51 <Cale> burrows: It's sometimes useful to think of Maybe values as "lists of length at most one"
07:03:18 <Cale> In that you could also use [] and [x] in place of Nothing and Just x
07:03:19 <burrows> Okay.
07:03:30 <Cale> (but you can't represent longer lists)
07:03:32 <burrows> I was mainly confused about the distinction between a type and data constructor.
07:03:36 <Cale> ah, okay
07:03:44 <Cale> type constructors are on the right hand side of the ::
07:03:44 <burrows> Thanks for the explanation.
07:03:49 <Cale> data constructors are on the left
07:03:53 <burrows> Okay.
07:03:55 <Cale> (data constructors are values)
07:04:49 <startling> @hoogle (a -> a) -> Int -> a -> a
07:04:50 <lambdabot> Data.Sequence iterateN :: Int -> (a -> a) -> a -> Seq a
07:04:50 <lambdabot> Data.Sequence adjust :: (a -> a) -> Int -> Seq a -> Seq a
07:04:50 <lambdabot> Data.IntMap adjust :: (a -> a) -> Key -> IntMap a -> IntMap a
07:05:23 <startling> is there something like that somewhere? I want to repeat an (a -> a) n times on some input.
07:05:44 <`ramses> startling: you could use until
07:05:59 <rwbarton> iterate f x !! n
07:06:00 <`ramses> if you somehow keep state
07:07:45 <Nereid> why don't we have a function Monoid a => Int -> a -> a?
07:08:28 <startling> Nereid: what would it do?
07:08:44 <Nereid> times n x = x <> ... <> x (n times)
07:08:47 <Nereid> (n >= 0)
07:08:48 <startling> :t until
07:08:49 <lambdabot> (a -> Bool) -> (a -> a) -> a -> a
07:09:34 <fmap> Nereid: there is one in semigroups iirc
07:09:54 <Nereid> that only works for semigroups, and doesn't work with 0
07:09:58 <typoclass> what's wrong with rwbarton's suggestion?
07:10:16 <startling> nothing, I'm using it.
07:10:23 <Nereid> nothing
07:10:25 <typoclass> ah =)
07:10:27 <bartavelle> typoclass, doesn't it run in O(n) space ?
07:10:33 <Nereid> no
07:10:40 <neutrino> Nereid: here's your chance to contribute some code
07:10:53 <dimka> How could I delete Maybe α from a Maybe [α]? Like deleteM ∷ Maybe α → Maybe [α] → Maybe [α]
07:11:03 <bartavelle> aren't the (n-1) values allocated before the nth could be couputed ?
07:11:09 <bartavelle> computed
07:11:14 <fmap> Nereid: what's the point of using times with 0?
07:11:23 <Nereid> bartavelle: and then immediately deallocated, because they're no longer needed
07:11:40 <bartavelle> Nereid, yes, but with large n, this becomes a problem
07:11:44 <Nereid> no
07:11:48 <Nereid> it's O(n) time for sure, but O(1) space
07:11:54 <Nereid> go and try it ;)
07:11:59 <rwbarton> I think a whole thunk f (f (f ...)) is allocated
07:12:02 <bartavelle> the list isn't kept until the nth value is computed ?
07:12:08 <Nereid> rwbarton: oh that may be the case.
07:12:09 <bartavelle> ok I trust you on that, the runtime is clever :)
07:12:10 <rwbarton> you need a smarter consumer than !! n
07:12:13 <neutrino> dimka: turn m [a] to [m a] first
07:12:24 <Nereid> bartavelle: nah, it's just the GC doing its job.
07:12:31 <rwbarton> @src iterate
07:12:31 <lambdabot> iterate f x =  x : iterate f (f x)
07:12:47 <neutrino> dimka: then delete normally, then turn back to m [a] again.
07:12:49 <Nereid> ah, yeah.
07:12:57 <Nereid> but the problem is not the list allocation.
07:13:10 <bartavelle> Nereid, doesn't seem obvious to me, the list keeps a reference on each cell until it is released, and the list could only be released until the nth value is computed, right ?
07:13:30 <Nereid> bartavelle: there's no reason for it to hold onto the head if it doesn't need it anymore.
07:13:42 <bartavelle> ah I didn't realize this was possible
07:13:54 <bartavelle> I still don't think of lists as chained lists
07:14:15 <hkBst> if anyone has the time, please consider editing http://en.wikipedia.org/wiki/Real_World_Haskell so it doesn't get deleted before it can grow.
07:14:45 <Nereid> bartavelle: go run ghci, and try: repeat 1 !! 100000000000
07:14:53 <Nereid> it'll take a long time but the memory usage will be constant.
07:14:57 <dimka> hkBst: what is a point of having rwh page on wikipedia?
07:15:03 <bartavelle> Nereid, cool stuff!
07:15:50 <ozgura> hkBst: that page says one of the authors of the book is an Irish sportsperson. http://en.wikipedia.org/wiki/Bryan_O%27Sullivan
07:16:05 <Nereid> huh, that took less than a minute. computers are so fast.
07:16:07 <dimka> hkBst: why there is no lens page? Or it have been deleted already?
07:16:30 <neutrino> ozgura: does that mean it has been adopted in the (sports) industry?
07:16:39 <Nereid> or rather, it took 3 seconds.
07:16:47 <typoclass> > let f x = maybe id delete x <$> Just [40..45] in (f Nothing, f $ Just 42) -- dimka
07:16:49 <lambdabot>   (Just [40,41,42,43,44,45],Just [40,41,43,44,45])
07:16:50 <ozgura> neutrino: haskell is a multi-purpose programming language after all :)
07:17:00 <rwbarton> 3 seconds for a hundred billion?
07:17:02 <hkBst> dimka: what's the point of having wikipedia have pages?
07:17:09 <Nereid> rwbarton: beats me.
07:17:14 <rwbarton> oh
07:17:22 <rwbarton> 100000000000 :: Int, are you on a 32-bit system? :)
07:17:30 <dimka> hkBst: dunno, sorry :[
07:17:30 <hkBst> ozgura: apparently the other BOS is not a notable person yet...
07:17:33 <typoclass> dimka: just checking -- did you mean a list of Maybes, or a Maybe that contains a list? i think the first is very common, the latter is more rare
07:17:33 <Nereid> aha. yep
07:17:43 <Nereid> let me try it on my 64-bit thing
07:17:59 <hkBst> dimka: seriously?
07:18:00 <invariant> RHW is not notable according to wikipedia standards.
07:18:00 <rwbarton> > 100000000000 :: Int32
07:18:02 <ozgura> hkBst: maybe it shouldn't be a link then.
07:18:02 <lambdabot>   1215752192
07:18:10 <hkBst> ozgura: could be
07:18:36 <Guest38969> but is RWH?
07:18:40 <Nereid> rwbarton: alarms went off when I tried a trillion and it complained about a negative index.
07:18:53 <Nereid> > 10^12 :: Int32
07:18:54 <lambdabot>   -727379968
07:19:00 <rwbarton> it'd be nice if ghc could warn about literals that are too big to fit in their inferred type
07:19:00 <`ramses> dimka: liftM2 delete
07:19:15 <Nereid> that would be nice.
07:19:41 <Nereid> I forgot that !! takes an Int.
07:19:45 <dimka> typoclass: it works, but `ramses `liftM2 delete` is better
07:19:49 <dimka> Thanks
07:20:11 <Nereid> are you sure that does the right thing?
07:20:17 <Nereid> if the first argument is Nothing, you'll get Nothing out.
07:20:21 <Guest38969> Nereid: heh, are you using !! with a trillion?
07:20:25 <Nereid> haha yeah.
07:20:35 <rwbarton> of course *we* cannot be sure, because the original question was underspecified
07:20:38 <Nereid> true
07:20:43 <Nereid> so I'm asking dimka
07:20:52 <dimka> Nereid: yeah, it's ok
07:21:11 <Nereid> as opposed to
07:21:12 <`ramses> wasn't sure about that either...
07:21:17 <Nereid> :t maybe id (fmap . delete)
07:21:18 <lambdabot> (Eq a, Functor f) => Maybe a -> f [a] -> f [a]
07:27:36 <saml> do { Just x <- cmd; return (f x) }    is there shortcut?
07:27:51 <saml> cmd >>= maybe someDefaultVal f    ?
07:28:54 <ozgura> saml: liftM f cmd
07:29:02 <ozgura> or is it not the same?
07:29:27 <saml> i mean.. what do I do if cmd returns None ?
07:29:36 <ozgura> also "fmap f cmd" or "f <$> cmd"
07:29:41 <`ramses> saml: liftM (fmap f)
07:29:42 <ozgura> saml: you mean Nothing
07:29:56 <saml> oh yah
07:29:56 <saml> i got confused
07:30:35 <`ramses> > liftM (fmap (+1)) [Just 3, Nothing, Just 4]
07:30:36 <lambdabot>   [Just 4,Nothing,Just 5]
07:30:40 <`ramses> something like that?
07:31:17 <`ramses> (using a list for whatever monad this should act in)
07:32:12 <Nereid> @undo do {Just x <- cmd; return (f x)}
07:32:13 <lambdabot> cmd >>= \ a -> case a of { Just x -> return (f x); _ -> fail ""}
07:32:42 <Nereid> :t maybe (fail "") (return . ?f)
07:32:43 <lambdabot> (?f::a -> a1, Monad m) => Maybe a -> m a1
07:34:48 <rwbarton> if you're actually expecting the Just x pattern to fail then maybe mzero is more appropriate than using fail
07:34:55 <rwbarton> however, the original seems best in any case
07:35:05 <bscarlet> I'm using cabal to build a package with a library and an executable. When I build, cabal first builds the library with no problems, including an "exposed" module A which imports an "other" module B. Then cabal proceeds to the executable (it says "Preprocessing executable ..."). The main (and only) module of the executable imports A (but not B). Before I see any actual compilation messages (the ones of the form "[n of m] Compiling ...", I get an error at
07:35:08 <bscarlet> the line in A where it imports B, complaining "Could not find module `B' it is a hidden module in the package...". That seems weird to me. I'd think transitive use of hidden modules was the point of their existence.
07:36:35 <dcoutts> bscarlet: is your exe in a different src dir? does your .cabal file say that your exe depends on the lib?
07:36:40 <rwbarton> sounds like the executable is including A-as-source-file, not A-as-provided-by-the-library
07:36:52 <rwbarton> *importing
07:36:59 <dcoutts> bscarlet: there's two ways to find the module, one is as a local source file, the other is by depending on the library
07:39:31 <bscarlet> My .cabal file does say the exe depends on the lib. I didn't list A in any way in the executable section of the .cabal file, so I hoped it wouldn't be found as A-as-source-file, but instead as A-as-provided by the library. Should I somehow be using separate source directories in my package?
07:40:45 <dcoutts> bscarlet: yes, you'll have to use separate src dirs, because local files are always preferred over packages
07:43:55 <eikke> lol. "... but object-oriented code is more manager-friendly, favoring factories over monads."
07:44:54 <bscarlet> Ah, so I was wrong in assuming that something like the cabal file's "exposed-modules" and "other-modules" lists was restricting the visible source files for each target?
07:45:20 <dcoutts> bscarlet: it restricts what is visible from the lib's interface
07:45:37 <dcoutts> bscarlet: but doesn't stop another component from using the source files directly
07:45:51 <dcoutts> bscarlet: which is a good thing, because we sometimes want to test internal modules
07:46:23 * hackagebot diff3 0.1.2 - Perform a 3-way difference of documents  http://hackage.haskell.org/package/diff3-0.1.2 (OliverCharles)
07:46:39 <dcoutts> bscarlet: what would be nice though is if depending on the lib, meant that it masked the source files. But that's something ghc does and we would have to patch ghc to change it.
07:46:46 <b__> if I write `a >< b = a >< b >< a` why doesn't ghc say: "no, bad"? Lazy eval?
07:47:06 <bscarlet> dcoutts: wouldn't testing internal modules run into exactly the problem I'm seeing?
07:47:11 <eikke> :t (><)
07:47:12 <lambdabot>     Not in scope: `><'
07:47:13 <lambdabot>     Perhaps you meant one of these:
07:47:13 <lambdabot>       `Seq.><' (imported from Data.Sequence),
07:47:15 <neutrino> dcoutts: i wouldn't say that would be nice.
07:47:32 <dcoutts> bscarlet: you'd test them by not depending on the package, but by importing the source files directly.
07:47:46 <dcoutts> neutrino: mm?
07:47:55 <dmwit> b__: Have you declared a type signature or fixity for (><)?
07:48:04 <dmwit> oh, I misread the question
07:48:06 <neutrino> dcoutts: it sounds like something you could stumble into using without knowing about it.
07:48:21 <dmwit> GHC doesn't say "no, bad" because it doesn't try to solve the halting problem.
07:48:26 <neutrino> dcoutts: and because it changes the way things work very drastically, it could end up being an issue.
07:48:37 <b__> dmwit yeah, silly question actully
07:48:39 <Nereid> b__: that's just a recursive definition of (><)
07:48:39 <b__> actually*
07:48:45 <dcoutts> neutrino: I'm not so sure, the current situation is what people stumble into without knowing about it
07:48:48 <bscarlet> dcoutts: so my binary might build if I left the source where it is but didn't depend on the library (and so used it directly)?
07:48:58 <dcoutts> bscarlet: yes
07:48:58 <ocharles> b__: not an entirely silly question, some languages will reject that
07:49:07 <ocharles> but ghc/haskell doesn't do termination checking
07:49:15 <dmwit> (thank goodness)
07:49:16 <dcoutts> bscarlet: it'd then build those modules twice, once for each component
07:49:17 <neutrino> dcoutts: i guess people stumble into both then?
07:49:25 <ocharles> dmwit: you say that, I could have done with it earlier!
07:49:37 <dcoutts> neutrino: can you see any situation where that'd happen?
07:49:39 <ocharles> but I guess it was my fault for having too general pattern matches
07:49:44 <bscarlet> dcoutts: thanks. I moved the binary to a separate directory and can now build.
07:49:55 <dmwit> There are pros and cons. But we already have languages with good termination checkers, so use those if that's what you want. =)
07:50:00 <neutrino> dcoutts: any other situation when you'd list the package as a dep.
07:50:28 <dcoutts> neutrino: we're talking about a library within the same package here
07:50:45 <dmwit> The reason you're about to give for not using that other language is exactly what I meant when I said "(thank goodness)". ;-)
07:50:48 <neutrino> er i meant when you'd list the lib as a dep
07:50:49 <b__> dmwit it's not what I want
07:50:53 <neutrino> (sorry, a bit tired right now)
07:51:08 <dmwit> b__: oh, okay
07:51:13 <dmwit> What did you mean?
07:51:16 <dcoutts> neutrino: if I have an exe that depends on a lib that exposes module A, and the exe imports A, surely we want it to get that A from the package, not from a local source file?
07:51:31 <b__> no I meant exactly what you think I did, but I was only curious =]
07:51:45 <dcoutts> neutrino: I can't currently imagine a situation where we want the reverse. If you want the source file, don't depend on the library.
07:51:47 <b__> and your answer satisfied it
07:51:49 <dmwit> argh, I again misread, this time "want" as "meant"
07:52:16 <neutrino> dcoutts: no, if i want to be able to override the package easily
07:52:20 <dmwit> b__: You must be typing in a different font from everybody else or something. =P
07:52:27 <neutrino> dcoutts: *not
07:52:40 <b__> am I? hmmm
07:52:50 <b__> I'm using Textual for Mac, default settings
07:52:55 <dmwit> no, no, it's a joke
07:52:58 <dmwit> IRC doesn't do fonts
07:53:22 <b__> well actually today three "."s were changed by my client to ...
07:53:22 <dmwit> I'm just trying to find a scapegoat for my shortcomings.
07:53:34 <neutrino> dcoutts: or consider what if two packages have common module names, let's say "Test", and you want to use the one local to your module for unit testing, but you also need some code from the other package
07:53:40 <b__> so who knows what's going on =D
07:54:11 <neutrino> dcoutts: it's basically the same situation as unqualified imports in haskell.
07:54:11 <dcoutts> neutrino: ok, overriding a module from an external dependency is one thing, but from a library in the same package?
07:54:52 <neutrino> dcoutts: it's still basically unqualified imports
07:55:24 <neutrino> dcoutts: personally i hate unqualified imports
07:55:27 <neutrino> some people love them
07:55:30 <neutrino> ymmv
07:56:13 <neutrino> this reminds me of a thing which i can't figure out in cabal, and which really annoys me
07:56:22 <johnw> what is that?
07:56:38 <neutrino> i have a module in my pkg which depends on a lot of packages
07:56:55 <neutrino> it is used in two executables, i don't want to expose the module itself, just build the executables
07:57:14 <neutrino> i don't know how to write just one list of packages and have both executables pull them in
07:57:40 <johnw> can you have a second internal "library" which both executables depend on?
07:58:07 <johnw> i'm not sure if that makes sense
07:58:11 <neutrino> i guess? what is an "internal" library?
07:58:21 <johnw> that's where my logic fails :)
07:58:42 <neutrino> the thing is, i don't want the module to become available for e.g. import
08:06:32 <neutrino> dcoutts: hey, any ideas how this could be realized? or if it's possible at all?
08:13:01 <startling> neutrino: other-modules under the executable definition
08:13:45 <startling> neutrino: https://github.com/startling/partly/blob/master/partly.cabal#L45
08:17:09 <Qett> hey can someone take a look at this:
08:17:13 <Qett> http://hpaste.org/79050
08:17:16 <Qett> line 11
08:17:51 <Qett> isPrime should return false if any number in a list divides its parameter
08:18:08 <Qett> prevPrime is a list of int
08:21:24 * hackagebot highlight-versions 0.1.2.2 - Highlight package versions which differ from the latest  version on Hackage  http://hackage.haskell.org/package/highlight-versions-0.1.2.2 (BrentYorgey)
08:22:08 <S11001001> Qett: think you're missing a . there
08:25:59 <Qett> S11001001: in between the ==0 and mod x ?
08:26:19 <Qett> S11001001: yes you are right
08:26:22 <Qett> thanks
08:27:04 <ihack> merry christmas everyone - http://iosdevs.org/christmas/
08:32:43 <typoclass> S11001001: just a friendly heads-up :-) with this sort of homework question, we usually try to point them in the right direction but also leave something for them to figure out. most people are against just handing them the end result
08:35:36 <Qett> typoclass: its not a homework question
08:35:57 <typoclass> Qett: i apologize, it looked like one. no worries.
08:36:00 <Qett> im learning haskell for myself
08:36:15 * elliott thinks that's a good strategy for most beginner questions, whether they're homework or not
08:36:38 <typoclass> elliott: exactly, that's what i meant
08:37:12 <Qett> I get what you're saying but I wouldn't have asked if i could have figured it out easily
08:37:17 <Qett> i spent a while trying different things
08:42:12 <Sculptor> hi
08:43:10 <b__> could a function `f = f . f` possibly be useful?
08:43:25 <b__> how could it terminate?
08:43:40 <elliott> :t let f = f .f in f
08:43:42 <lambdabot> a -> a
08:43:58 <elliott> it couldn't
08:44:04 <joehillen> b__: you can't reassign f
08:44:17 <b__> hm okay
08:44:30 <madhadron> b__, wouldn't it just be the identity function?
08:44:41 <b__> no
08:44:42 <madhadron> No, sorry, could be any idempotent function
08:45:29 <rwbarton> "the function f defined by f = f . f" and "a function f satisfying f = f . f" are different concepts
08:46:00 * madhadron attempts to jump start his brain.
08:51:37 <Qett> quetion: if i bind some name to a function call in a where, will the function be called every time the name is used?
08:51:50 <Qett> where asdf = foo x
08:52:26 <Qett> then i have until foo f s
08:52:40 <Qett> i mean until asdf f s
08:52:55 <Qett> will foo be called multiple times in the until?
08:53:16 <Qett> or will asdf be given a value one time
08:53:53 <rwbarton> even if you use asdf in multiple places in its scope, it will only be evaluated once (per time that scope is entered)
08:53:56 <rwbarton> probably
08:54:22 <rwbarton> ghc might try to do something "smart", and it may or may not be right about that
08:54:52 <Qett> rwbarton: but if i use it in one place but inside a where?
08:54:56 <Qett> i mean inside an until
08:54:57 <Cale> As long as the binding isn't type class polymorphic, you should be okay
08:55:30 <rwbarton> "in one place" is a special case of "in several places"
08:55:37 <rwbarton> yes, it will be evaluated only once
08:55:45 <rwbarton> even if you did not introduce a name, that would still be true
08:55:45 <Cale> Any single non-type class polymorphic variable is evaluated at most once so long as it remains in scope
08:56:00 <rwbarton> until (foo x) f s -- will evaluate foo x at most once
08:56:12 <meyersh> b__: ran that function. Gmail crashed.
08:57:07 <Qett> rwbarton what about if i do until g f asdf
08:57:13 <b__> running functions I paste is not advisable in general
08:57:39 <meyersh> b__:   :)
08:58:00 <rwbarton> you can put the variables in whatever order you like. not sure why you are still asking :P
08:58:13 <rwbarton> @type until
08:58:14 <lambdabot> (a -> Bool) -> (a -> a) -> a -> a
08:58:45 <Qett> ok thanks
08:58:57 <rwbarton> note that if you write until (foo x) f s, or ... until asdf f s ... where asdf = foo x, then (foo x) will be evaluated only once, but (foo x y) will be evaluated for several different y
08:59:22 <rwbarton> if the definition of foo looks like an ordinary "foo x y = ..." then there is no gain from evaluating "foo x" only once
08:59:35 <rwbarton> only if foo looks something like "foo x = let z = ... in \y -> ..."
08:59:43 <typoclass> Qett: in plain haskell, there's really no way that "foo 42" evaluated now could give a different result than "foo 42" evaluated in a minute, because of purity. therefore, ghc can "optimize away" the second/third/... evaluation
08:59:44 <rwbarton> then z can be evaluated only once, too
09:00:03 <typoclass> (anyway, that's my understanding, i hope it's good nuff)
09:03:53 <neutrino> Qett: however, x <- foo 42 could give you a different result now and later.
09:04:01 <djahandarie> Anyone have thoughts on how to reduce the memory usage of threads? I want a million or so forkIO threads alive at once but that takes like 2.5GB of RAM.
09:04:26 <djahandarie> Even with just threadDelay forever as the contents of the thread.
09:04:28 <neutrino> why do you
09:04:44 * neutrino is curious
09:04:52 <djahandarie> Because in the actual program, each thread is holding an open TCP connection
09:05:04 <djahandarie> And it definitely does not take that much memory to just have a bunch of TCP connections
09:05:07 <neutrino> and you have 1 million tcp connections open?
09:05:11 <djahandarie> Yeah.
09:05:18 <neutrino> interesting, what are you making?
09:05:19 <djahandarie> That's not the memory bottleneck though.
09:05:39 <djahandarie> A program that benchmarks another program by opening a bunch of TCP connections :P
09:05:52 <neutrino> kind of like ab?
09:05:57 <djahandarie> Yeah, just not HTTP
09:06:04 <djahandarie> I could probably go over 1M if I figure how to get around this open file limit and memory problem
09:06:25 <neutrino> right
09:06:34 <neutrino> i'm sort of wondering if threading is the right idea here..
09:06:40 <djahandarie> But I'm not aware of any way to do non-blocking IO in Haskell without spawning new threads
09:06:42 <neutrino> but.. i know very little about ghc runtime
09:07:25 <neutrino> i was looking at non-blocking IO recently
09:07:31 <neutrino> i believe posix defines its own non-blocking api
09:07:41 <neutrino> via what.. select? i don't know
09:07:54 <m_fulder> Hello, I am trying to make an easy language-parser...I now have one module named Program (which should be a list of another module called Statement) and Im trying to create a function "exec" in Program module which uses "exec" from the statement .. now the problem is that when I try to call Program.exec and it jumps into Statement.exec the compiler seems not to see the T in Program as the same thing as a list of Statements ... wh
09:08:49 <rwbarton> if 2500 bytes per connection sounds like a lot to you, i would suggest you consider not using Haskell
09:08:58 <typoclass> m_fulder: hello, you were cut off at "statements ... wh"
09:09:07 <S11001001> m_fulder: http://hpaste.org/
09:09:10 <neutrino> djahandarie: http://hackage.haskell.org/package/select-0.4
09:09:29 <neutrino> rwbarton: there's no reason to get unreasonable here.
09:09:56 <djahandarie> rwbarton, the problem is definitely the thread overhead. The actual connections don't seem to be taking up much memory at all.
09:10:10 <neutrino> djahandarie: see man 2 select
09:10:11 <Cale> neutrino: GHC does non-blocking I/O even when it appears to be blocking, for example in getLine, so that other GHC threads can be doing things. The runtime will use epoll/kqueue when those are available and otherwise select (which is less efficient).
09:10:27 <neutrino> Cale: mm, yeah, i believe hearing about that.
09:10:30 <rwbarton> yes, I am saying, you have a million of something, that something needs to fit in less than 2500 bytes, apparently
09:10:46 <m_fulder> typoclass: ..."why is that :O here's the called code: http://pastebin.com/qgpp1Q58 "
09:10:54 <neutrino> right, i was just going to search for those two djahandarie... epoll and kqueue are your two other bets
09:11:06 <Cale> m_fulder: There is a limit on IRC message length
09:11:09 <neutrino> try using select, epoll, or kqueue directly
09:11:36 <m_fulder> Cale yeah I know that .. thought that this webbased IRC client would stop me auto :P
09:11:38 <Cale> m_fulder: Some IRC clients will try to break long messages into shorter ones automatically, but yours doesn't seem to do that.
09:11:50 <djahandarie> rwbarton, why do you think that's impossible?
09:12:08 <rwbarton> i don't think it's *impossible* just that it is way too much effort to do in Haskell
09:12:20 <Cale> m_fulder: You might want to, for your own and others' sanity, not name all your types T.
09:12:21 <rwbarton> it would be like trying to run a Haskell program on a machine with 2.5K of ram
09:12:30 <neutrino> rwbarton: i don't think that's going to create unidiomatic haskell, i do think it's a path less traveled alright
09:12:50 <neutrino> i don't believe it would be like this rwbarton
09:13:15 <neutrino> djahandarie doesn't have a problem with whatever memory the ghc runtime is taking up, he has a problem with the scalability of his current approach
09:13:20 <mercury^> I have a function that repeatedly deletes entries from a map.  How do I avoid the construction of lots of intermediate maps?
09:13:39 <m_fulder> Cale, hm yeah I should maybe rename them .. but it still should work with the same name?
09:13:42 <neutrino> and needs something that has less than O(n) space requirements
09:14:18 <mercury^> (the maps are of type IntMap, to be precise)
09:14:20 <typoclass> m_fulder: could you add the error message that ghc is giving you?
09:14:23 <Cale> m_fulder: Yes, but you seem to have left out the module declarations, and I'm not sure what files these things are in, so it's unclear what's going on.
09:14:28 <typoclass> (add to the paste, i mean :-)  )
09:14:29 <beaky> hello
09:14:34 <beaky> how do I slice a Data.Array?
09:15:11 <m_fulder> typoclass: here is the error: http://pastebin.com/QLNiFVLZ
09:15:20 <Cale> beaky: By making a new array, I would guess.
09:15:33 <beaky> ah
09:15:43 <rwbarton> @type ixmap
09:15:44 <lambdabot> (Ix j, Ix i) => (i, i) -> (i -> j) -> Array j e -> Array i e
09:16:04 <Cale> yeah, ixmap is probably useful :)
09:16:05 <fmap> where if this "everything is a T" thing from?
09:16:11 <fmap> s/if/is/
09:16:48 <Cale> I *hate* that convention. I was mentioning earlier about how Henning Thielemann sabotages all the packages he maintains like that.
09:16:53 <ocharles> is it badform to do something like 'fmap read (count 4 digit)' in parsec?
09:17:02 <neutrino> Cale: what convention?
09:17:08 <Cale> Naming all your types T
09:17:26 <neutrino> how can you have multiple types called T?
09:17:32 <neutrino> i thought you can only have one type per name?
09:17:33 <Cale> By putting them in separate modules
09:17:41 <neutrino> oh eww
09:17:52 <neutrino> that's absolutely disgusting
09:18:13 <typoclass> m_fulder: right. that error message indicates that Program.T (the newtype from line 15) is a different type from Statement.T (the one defined in line 22)
09:18:17 <fmap> Cale: I thought it was Henning's personal weirdness, but apparently it isn't
09:18:39 <Cale> fmap: Apparently some ML people do this.
09:18:54 <alpounet> it's very OCaml-ish yes
09:19:06 * typoclass would be happy if we could just standardize on calling all types Meow
09:19:19 <bitonic> fmap, Cale: whats “everything is a T”?
09:19:27 <companion_cube> it's not ugly, as long as you don't open the type, and keep it namespaced
09:19:38 <Cale> bitonic: I think I already explained it as well as I could.
09:19:51 <Cale> bitonic: Name every type you define T, put them in separate modules
09:19:53 <alpounet> bitonic, the (normal) Text type would be Data.Text.T
09:20:30 <bitonic> Cale: oh.  can you give an example package that is like that?
09:20:55 <beaky> ah
09:20:56 <typoclass> bitonic: the guy henning thielemann apparently defines a new unrelated type "T" in almost every module he writes. a few hours ago we were talking about how that makes code difficult to read
09:21:04 <m_fulder> typoclass: hm but Program.T should be a [Statement.T] and isn`t that what the exec in Statement uses?
09:21:06 <mercury^> Maybe it helps if I am even more precise. S is IntSet, M is IntMap in:
09:21:15 <mercury^> S.foldl' (flip M.delete) (fibres c) cs
09:21:18 <Cale> http://hackage.haskell.org/package/midi-0.2.0.1
09:21:30 <mercury^> How do I avoid the creation of intermediate maps there?
09:21:54 <Cale> http://hackage.haskell.org/package/numeric-prelude-0.2.2.1
09:21:55 <bitonic> Cale: thanks.  that is truly horrible.
09:22:07 <rwbarton> "instance C T" x20
09:22:16 <bitonic> and every class is C!  aha
09:22:40 <Cale> http://hackage.haskell.org/packages/archive/numeric-prelude/0.2.2.1/doc/html/MathObj-Polynomial.html -- try reading the instances here
09:22:42 <Cale> lol
09:22:47 <Cale> good luck
09:22:49 <bitonic> that is an MLism in some way, but in Haskell it just doesn’t work
09:23:01 <Cale> (C a, C a) => C (T a)
09:23:09 <Cale> FUN!
09:23:23 <elliott> to be fair that is partly haddock's fault
09:23:26 <Cale> of course, you can mouse over each C and look at where it links to
09:23:35 <elliott> "The C instance is intensionally built from the C structure of the polynomial coefficients."
09:23:38 <Cale> Yes, but it's not easily solvable
09:23:45 <ocharles> Cale: I came across that package at a Music Hackday weekend
09:23:50 <typoclass> m_fulder: yes, but the problem is, you have "p :: Program.T", you give it to Program.exec, which gives it to Statement.exec (with no converting). but Statement.exec is defined to take a [Statement.T], not a Program.T or [Program.T]
09:23:51 <ocharles> I promptly closed that tab :(
09:24:01 <ocharles> i would have loved to write my solution in Haskell, but not with a monster of an api like that
09:24:09 <Cale> At least, not without the Haddock documentation explicitly listing the imports at the top
09:24:18 <Cale> because modules can be imported with new names
09:25:10 <Cale> Or I guess haddock could opt to rewrite module qualifiers with the full name
09:25:16 <Cale> but that would be hideous too
09:26:07 <rwbarton> it could use the qualified-ness of the name used in the source
09:26:37 <dmwit> I wonder how horrible it would be to do "abbreviated" style like initials for the hierarchy and the full name for the final module.
09:26:37 <Cale> rwbarton: To do that generally it would need to tell you the imports though.
09:26:44 <rwbarton> not really
09:26:45 <dmwit> e.g. instead of Foo.Bar.Baz.C, use F.B.Baz.C
09:26:46 <rwbarton> I mean
09:26:57 <rwbarton> it would be no worse than the current system
09:26:57 <m_fulder> typoclass: yeah I see but then how can I convert the Program.T into the correct [Statement.T]? I've tried to specify the type of the exec function in prog to use [Statement.T] but that doesn't helt (still same error)] .. how can I then convert it ?
09:27:04 <Cale> I guess it would be better than what it currently does to to that.
09:27:04 <rwbarton> you can still mouse over it to find out that "Map" is "Data.Map"
09:27:05 <Cale> do*
09:27:09 <rwbarton> or you can just guess
09:27:13 <m_fulder> help *
09:27:22 <rwbarton> or that "BL" is Data.ByteString.Lazy
09:27:56 <hpaste> typoclass pasted “how to get stuff out of a newtype” at http://hpaste.org/79056
09:28:06 <Cale> Even so, I still think it's horribly ugly
09:28:20 <scp> Is there a way to force something to be completely evaluated?
09:28:22 <typoclass> m_fulder: here's how you use pattern matching to get something "out" of a newtype ^^
09:28:42 <scp> I am loading some data from the disk into a Data.Map, and I want the map to be completely built at startup, rather than waiting for it to be accessed
09:29:12 <beaky> > let sliceArray i j = ixmap (i, j) id in sliceArray 0 3 (listArray (0, 12) "Hello, World!)
09:29:14 <lambdabot>   <hint>:1:90:
09:29:14 <lambdabot>      lexical error in string/character literal at end of input
09:29:16 <beaky> :(
09:29:21 <beaky> > let sliceArray i j = ixmap (i, j) id in sliceArray 0 3 (listArray (0, 12) "Hello, World!")
09:29:22 <lambdabot>   array (0,3) [(0,'H'),(1,'e'),(2,'l'),(3,'l')]
09:29:29 <beaky> yay
09:29:52 <beaky> > let sliceArray i j = ixmap (i, j) id in elems (sliceArray 0 3 (listArray (0, 12) "Hello, World!"))
09:29:53 <lambdabot>   "Hell"
09:30:02 <rwbarton> note that this copies the array
09:30:06 <beaky> oh
09:30:12 <rwbarton> well, the part you sliced anyways
09:30:19 <beaky> ah that's alright
09:30:30 <typoclass> m_fulder: so that's maybe the quick fix. in the long run, i think if you reorganize your program so that there aren't 3 different things called T, you'll really do yourself a favor :-) it's really easy to get confused
09:30:32 <beaky> that's how it happens in python and MATLAB right?
09:31:04 <typoclass> m_fulder: if you get stuck on that, folks in this channel will happily suggest new names
09:31:11 <m_fulder> typoclass you mean convert "exec prog list=.." in Program module to something like "exec (Statement.T prog) list =.."?
09:31:37 <rwbarton> no idea about matlab, in python I guess so because python lists are mutable and slices semantically create a copy
09:31:40 <m_fulder> typo hehe yeah I'll do the renaming :)
09:31:50 <m_fulder> typoclass*
09:32:29 <beaky> typos ftw :D
09:33:01 <typoclass> m_fulder: erm, almost. pattern matching takes place on the left side of an "=". check the hpaste that i put up; the pattern matching part is the (S xs) which is between "f" and "="
09:33:38 <typoclass> m_fulder: so it'd be "exec (Program statements) list = Statement.exec statements ..."
09:38:49 <m_fulder> typoclass ah ok I think I understand .. but should the statements really be "cast" to Program? Statement.exec will be needing an [T] where the T is a Statement (in the statement module now :P )
09:41:40 <typoclass> m_fulder: no it's not 'casting' :-) the "exec (Program s) ... = ..." extracts the s, it takes apart the first argument of exec
09:44:52 <m_fulder> typoclass, hm extracts? then what will it do with the s when its taken apart? :P
09:45:53 <typoclass> m_fulder: you can use it on the right-hand side. you can see that the "xs" in my hpaste is used on the right side, i'm giving it to the "show" function
09:47:04 <m_fulder> typoclass ah I see! so you kind of take away the type sending it to show without any?
09:47:24 <beaky> > let x = "let x = " in print x
09:47:26 <lambdabot>   No instance for (GHC.Show.Show (GHC.Types.IO ()))
09:47:26 <lambdabot>    arising from a use of ...
09:47:45 <beaky> > let x = ("let x = " ++ x) in x
09:47:47 <lambdabot>   "let x = let x = let x = let x = let x = let x = let x = let x = let x = le...
09:47:52 <beaky> oh :(
09:48:13 <monochrom> it works
09:48:15 <beaky> > let x = ("let x = x in x") in x
09:48:17 <lambdabot>   "let x = x in x"
09:48:40 <beaky> I want to do a one-liner quine
09:48:50 <tac-tics> @type eval
09:48:51 <lambdabot>     Not in scope: `eval'
09:48:51 <lambdabot>     Perhaps you meant `ival' (imported from Data.Number.Interval)
09:49:01 <tac-tics> I want to eval!
09:49:24 <monochrom> I am very weak in quines. but I believe that quines are seldom recursive programs
09:49:26 <typoclass> m_fulder: yes. we take away the "Program.Program" constructor (in my hpaste the name was "S"). inside of it we find a [Statement.T] (or in my hpaste [Integer])
09:49:29 <beaky> right
09:49:40 <beaky> to write a quine, you first find recursion and then eliminate it
09:49:48 <monochrom> yes, something like that
09:50:00 <monochrom> ok, have fun!
09:50:10 <beaky> :D
09:51:04 <Nereid> > ap (++) show "ap (++) show "
09:51:06 <lambdabot>   "ap (++) show \"ap (++) show \""
09:51:59 <m_fulder> typoclass yeah great then I think I get it .. though I still get almost the same error while Pattern matching ... on the exec call:   http://pastebin.com/KV7vJ8p7
09:52:09 <scp> hey, I asked this question a couple minutes ago, but then got disconnected
09:52:17 <scp> does anyone know how to force complete evaluation of an object?
09:52:19 <saml> scask again
09:52:30 <Nereid> scp: the closest you can get is probably DeepSeq
09:52:32 <saml> print it
09:52:39 <saml> print object
09:52:41 <Nereid> or show it, yeah, if that can be done
09:52:46 <scp> DeepSeq, ok, will look that up
09:52:48 <beaky> the simplest quine is like the y-combinator
09:52:54 <scp> show isn't an option, unfortunately
09:52:57 <beaky> :t ap
09:52:58 <lambdabot> Monad m => m (a -> b) -> m a -> m b
09:53:05 <Nereid> ap f g x = f x (g x)
09:53:16 <beaky> oh
09:53:20 <beaky> so it is like $
09:53:24 <Nereid> no
09:53:26 <Nereid> it is like the S combinator
09:53:32 <typoclass> m_fulder: hm!
09:53:35 <saml> haskell is lazy.
09:54:17 <beaky> craziest quine: http://asiajin.com/blog/2009/09/22/uroboros-programming-with-11-programming-languages/
09:54:45 <Nereid> what about http://blog.sigfpe.com/2011/01/quine-central.html
09:55:17 <kirindave> Hey folks. I was curious I recently used Yesod for a JSON-friendly RPC endpoint for some haskell software
09:55:22 <kirindave> But honestly it seemed to offer very little to that use case
09:55:24 <beaky> wow
09:55:28 <kirindave> Are there better frameworks?
09:56:04 <m_fulder> typoclass sorry I had wrong type on the exec function .. now it compiled! :D
09:56:15 <kirindave> Like, Clojure as Compojure, the horrifically named software that makes it very very easy to write json or protocol buffer endpoints.
09:56:22 <kirindave> Is there a good analogue for haskell?
09:56:56 <typoclass> m_fulder: ah okay :-) i was getting a little puzzled
09:57:19 <m_fulder> typoclass hehe sry :P
10:16:59 <srruby> I'm on Debian. I'm running cabal install cabal-dev and I got network-2.3.2.0 failed
10:19:34 <m_fulder> typoclass thanks for your help before btw :)
10:20:47 <typoclass> m_fulder: you're welcome :-)
10:23:16 <luite> does anyone know how to fix this, running cabal-dev ghci: setup: ghcInvocation: the programVersion must not be Nothing
10:26:39 <simon> I'm comparing potentially large sub-trees of a syntax tree, and I wonder if there's a way I can compare hashes instead. is there a typeclass for this?
10:27:28 <simon> maybe something with memoized hashes for various trees... I'm not sure what makes sense here. maybe I should invent a simple way to hash them so I avoid comparisons.
10:27:34 <ocharles> kirindave: there is msgpack-rpc
10:27:39 <ocharles> kirindave: perhaps that might help
10:28:31 <typoclass> luite: i think it's a known bug, or knownish bug. several people have had trouble. does google turn up anything? istr people were reporting they had more luck with newer cabal-dev versions from github instead of hackage
10:28:40 <scp> simon, are you trying to do subexpression elimination?
10:28:51 <scp> s/subexp/common subexp/
10:28:54 <luite> typoclass: hm, i think i hae the latest version from github
10:29:19 <acowley> Has there been any movement on per-target data-files in Cabal to support data files for testing purposes?
10:29:21 <typoclass> luite: it's possible i'm misremembering. they might have been talking about a fork on github
10:29:48 <dcoutts> acowley: no, patches welcome though
10:30:44 <acowley> dcoutts: alright, fair enough
10:31:19 <simon> scp, no, I am generating some annotations for the syntax tree that I'm keeping separate of the actual tree. for later traversals of the tree, I have to find the annotations again.
10:31:37 <simon> scp, so yeah... I could just put the annotations *in* the tree.
10:32:07 <scp> simon, well, I think a solution I used for CSE a while back might work. Gimme a sec to recall the details
10:32:21 <scp> do you have any guaranties about the arity of the tree's nodes?
10:34:46 <scp> simon: Are you comparing for equality, or some kind of ordering?
10:36:56 <hpaste> “AZDFAS DFDSFD” pasted “1” at http://hpaste.org/79057
10:39:33 <scooty-puff> is there a version of "div" that rounds up?
10:40:41 <niteria> > let div' a b = (a + b) `div` b in 10 div' 4
10:40:42 <lambdabot>   Could not deduce (GHC.Num.Num ((a0 -> a0 -> a0) -> a1 -> t))
10:40:43 <lambdabot>    arising fro...
10:41:21 <niteria> > let div' a b = (a + b) `div` b in 10 `div'` 4
10:41:22 <lambdabot>   3
10:41:32 <rwbarton> a + b - 1
10:41:51 <niteria> right
10:42:55 <scooty-puff> niteria: i'm not sure i follow
10:43:22 <scooty-puff> o wait, nm, missed the '
10:46:10 <simon> scp, both. once for comparison, once for a topological sort of a list of statements.
10:46:49 <simon> scp, that is, some of my annotations are strictly for comparison (finding the annotation based on the expression -- I currently use the sub-tree as the key in a Data.Map ;-P
11:03:38 <srruby> how do I install hsenv?  Thanks.
11:03:53 <m_fulder> typoclass I have another question if you're still here and have time/want to help :P .. Both my Program and Statement modules are instances of a class parser : http://pastebin.com/iuREzbkg .. though when I try to call the toString function for a Program my program lags (only printing ") (if I move the printTmp line up to Program module instead it works just fine
11:06:57 <triyo> Anyone know how to set the RSS feed `lastBuildDate' in Hakyll?
11:07:32 <triyo> for some reason on my side its set to earliest blog post in my list...
11:07:57 <Philonous> m_fulder:  Statement.toString does not mean "toString from the Statement class"
11:08:27 <Philonous> m_fulder:  Rather, it means the composition of the Statement and toString functions (and therefore, you have an infinite loop)
11:08:50 <m_fulder> aah right!
11:09:00 <triyo> I want the last build date to be today.
11:10:20 <Philonous> m_fulder:  I'm surprised the type checker doesn't complain, though
11:10:59 <m_fulder> Philonous yeah that's what I thought too .. seems weird
11:12:28 <m_fulder> Philonous but say I have a function in Statement module that statements toString calls .. then I should be able to call it from Program as well ? Like this: http://pastebin.com/Qyxz1zTw
11:13:23 <citizen93> Dear all, I have a small question. I am trying to understand Monads and therefore I'm trying to create a Monad, which does the following: it maintains two states, first a state just like the state monad, the second state is a comment state which is a string actually in which I can put in comments with putComment. Now I'm aware of the State monad, but I'm not sure whether I should "reinvent"
11:13:24 <citizen93> the wheel for this addition. I was considering the datatype data State' s a = State' {runState' :: s -> (a, s, String)}, however in this way I will have to create a new "state monad" which is very similar to the old one... so I figured that I probably need to reuse the State type of Control.Monad.State. Do you guys recommend me to create a new datatype with similar characteristics like State
11:13:24 <citizen93> or should I reuse state? And if I reuse state, what would be a good datatype?
11:13:47 <m_fulder> Philonous sry wrong pastie, heres the correct one: http://pastebin.com/sC16TK15  :P
11:14:30 <shachaf> No, you shouldn't reinvent the wheel.
11:14:48 <shachaf> Just use State (MyState, Comment) or something like that.
11:14:49 <rwbarton> unless as a learning exercise
11:15:20 <citizen93> yes, but I should maintain two states
11:15:32 <Philonous> m_fulder:  Actually, I was mistaken, Statement.toString does indeed mean "toString from the Statement module"
11:15:38 <acowley> rwbarton: But even then, the better exercise is to write your own State, then use it as shachaf suggests
11:16:00 <Philonous> m_fulder:  But it's the same toString, so there's your infinite loop (and that's why it type checks)
11:16:19 <citizen93> is there a possibility that I can extend the State monad?
11:16:21 <rwbarton> well this sounds like a State/Writer combination
11:17:34 <m_fulder> Philonous what do you mean with same toString? if it goes into the Statement module then it should use that toString instead of the one in Porgram?
11:17:48 <Philonous> m_fulder:  Yes, you can call functions from other modules that you imported. But overloaded functions are selected by type
11:18:01 <acowley> :t (_2 %=) . flip mappend
11:18:03 <lambdabot> (Monoid b, MonadState s m, Field2 s s b b) => b -> m ()
11:18:19 <m_fulder> Philonous ah I see!
11:18:20 <Philonous> m_fulder:  Both toString come from the same class, don't they?
11:18:29 <m_fulder> Philonous yeah
11:18:49 <m_fulder> so it automaticly choose the right type ok cool
11:18:54 <acowley> I think that expression could define putComment for a (MyState, Comment) data type
11:19:47 <Philonous> m_fulder:  What are you trying to do? One Statement's toString has type Statement -> String, how is this supposed to work with the T type?
11:20:19 <Philonous> -One
11:20:27 <`ramses> > (read "1") :: Char
11:20:28 <lambdabot>   *Exception: Prelude.read: no parse
11:20:33 <`ramses> how come this fails?
11:20:39 <`ramses> why doesn't it return '1' ?
11:20:46 <m_fulder> Philonous the T type in Program is a list of statements that tostring should loop through this list of statements printing each and one of them
11:20:54 <Philonous> read "'1'" :: Char
11:20:57 <Philonous> > read "'1'" :: Char
11:20:59 <lambdabot>   '1'
11:21:09 <`ramses> oh, ok..
11:21:32 <`ramses> didn't know that, what a shame that read isn't more flexible than that
11:21:35 <citizen93> Alright, I will go with the type State' (State s a, String)
11:21:37 <m_fulder> Philonous: so I guess I can do something like:  toString (st:sts) = toString st ++ toString sts in the Program module
11:21:54 <citizen93> thank you for the advice
11:22:31 <Philonous> m_fulder:  That would make sense/
11:22:31 <acowley> Is there a cross-platform way to create a temporary file in any library?
11:22:32 <shachaf> State' (State s a, String)?
11:22:55 <elliott> acowley: base has one
11:23:02 <acowley> ah, "temporary"
11:23:03 <citizen93> data State' s a = State' (State s a, String), this way I can keep comments in a string
11:23:04 <elliott> http://hackage.haskell.org/packages/archive/base/4.6.0.0/doc/html/System-IO.html#g:22
11:23:06 <elliott> acowley: ^
11:23:07 <acowley> elliott: base's is POSIX-only
11:23:08 <thoughtpolice> acowley: temporary
11:23:14 <elliott> oh, is it
11:23:17 <elliott> that sucks
11:23:26 <m_fulder> Philonous hm yeah though gave me an error : "couldn't match type 'T' against '[a]' :/
11:23:38 <acowley> Oh, perhaps not
11:23:49 <Philonous> m_fulder:  What does your T look like?
11:24:04 <m_fulder> Philonous: newtype T = Program [Statement.T]
11:24:14 <acowley> elliot: base has System.Posix.Temp
11:24:23 <acowley> elliott: The one you found requires me to provide a directory
11:24:53 <Philonous> m_fulder:  You need to unwrap it first. toString (Program xs) = toString =<< xs
11:25:05 <rwbarton> well there's also http://hackage.haskell.org/packages/archive/directory/latest/doc/html/System-Directory.html#v:getTemporaryDirectory
11:25:18 <elliott> acowley: there's - yeah, what rwbarton said
11:25:45 <Philonous> m_fulder:  Btw. "T" is a horrible name for a type ;)
11:25:53 <acowley> Well, I'll be
11:25:59 <acowley> there sure is a lot of overlap
11:27:29 <m_fulder> Philnous haha ops same fault as before when typoclass helped me :P ... Yeah I know .. this is one assignment Im trying to do/learn from though and thats the "program-case" I've gotten with the name T
11:29:44 <m_fulder> Philnous, hm after I've done like you suggested I get the error No instance for (Parse [Statement.T) but thats exactly the instance of the Program module :O
11:31:06 <rwbarton> "instance of the Program module"? doesn't make sense, do you mean instance for Program.T? and Program.T is not [Statement.T], it's a newtype
11:31:14 <m_fulder> Philnous or oh nvm it worked exactly how you wrote it .. I tried "toString (Program (st: sts)) = toString st ++ toString sts first ... shouldn't that work aswell?
11:31:39 <rwbarton> no, what are you doing with "toString sts"
11:32:13 <rwbarton> btw "concatMap toString xs" reads a lot better than randomly using =<<
11:32:18 <m_fulder> I thought that the first toString will call the toString inside Statement and then the second one ("toString sts") will recursively call toString in Program?
11:32:52 <rwbarton> no, because sts is not of type Program.T
11:32:54 <rwbarton> it's just a list
11:33:01 <m_fulder> ah right!
11:34:34 <m_fulder> hum but then shouldn't the first toString I wrote work? :  toString (st:sts) = toString st ++ toString sts ... then st should be Statement.T and sts [Statement.T] ?
11:35:18 <rwbarton> that definition would work in isolation
11:35:32 <m_fulder> isolation? :P
11:35:33 <Philonous> rwbarton:  It looks less intimidating. And I guess that's a good thing
11:37:39 <Philonous> m_fulder:  It would work if you had an instance for lists
11:37:48 <Philonous> m_fulder:  But It would probably not be what you want
11:37:59 <m_fulder> ah right!
11:38:27 <Philonous> m_fulder:  Actually, the way you wrote it, it would define an instance for lists
11:38:35 <m_fulder> Philonous "toString (Program sts) = toString =<< sts"  compiles without errors though it still freezes (inf. loop)
11:39:05 <m_fulder> Philonous, hm really? but then it should compile correctyl aswell? it didn't
11:39:35 <Philonous> m_fulder:  You wheren't defining an instance for lists, but for T, so it didn't type check
11:39:51 <m_fulder> aha I see
11:40:58 <Philonous> m_fulder:  Let me rephrase: The line you wrote would work in an instance for lists, but since you said to define one for T instead , it didn't
11:41:50 <m_fulder> Philonous I see .. I have to run outside for a bit .. will be back in a moment :P
11:43:01 <Philonous> m_fulder:  The reason it hangs has to be in Statement.T's instance of toString
11:44:07 * bgamari feels like the traffic in #haskell has dropped substantially since the advent of #haskell-lens
11:44:37 <parcs`> > 16 * 16 * 1000 / 8 / 1024
11:44:38 <lambdabot>   31.25
11:45:08 <Iceland_jack> I know I get a bit tired of people showing off Haskell's “flavour of the week”
11:45:35 <johnw> what is this week's flavor?
11:45:44 <rwbarton> you mean cabal-dev?
11:45:50 <rwbarton> pipes?
11:45:50 <eikke> lol @ /topic of #haskell-lens
11:45:51 <parcs`> i could've easily guesstimated that.. also, my spell checker thinks guesstimate is a word
11:46:10 <edwardk> heh
11:46:16 <johnw> maybe it guesstimates proper spelling
11:46:29 * hackagebot yesod-recaptcha 1.1.0.2 - Dead simple support for reCAPTCHA on Yesod applications.  http://hackage.haskell.org/package/yesod-recaptcha-1.1.0.2 (FelipeLessa)
11:46:35 <`nand`> base >=4 && <4.4, <- that was GHC 7.4, right?
11:46:56 <rwbarton> no, 7.4 is 4.5
11:47:03 <`nand`> that's odd
11:47:53 <Philonous> parcs`:  It is a word. A horrible word.
11:53:09 <acowley> bgamari: I think you're right
11:53:40 <gertc> liftIO (userinfo accessToken >>= liftIO . print) why is this not the same as userinfo accessToken >>= liftIO . print >>= liftIO ?
11:55:33 <gertc> if i just do userinfo accessToken >>= liftIO . print ghc complains about IO not expected
11:55:40 <rwbarton> well they both look like nonsense
11:55:45 <gertc> lol
11:55:45 <parcs`> gertc: why would they be the same? the burden of proof is on you!
11:56:29 <rwbarton> in the first, you are trying to liftIO an action in whatever monad userinfo is in, if that actually is IO, then why are you using the inner liftIO to lift print from IO to IO?
11:56:29 * hackagebot hissmetrics 0.4.0.2 - Unofficial API bindings to KISSmetrics.  http://hackage.haskell.org/package/hissmetrics-0.4.0.2 (FelipeLessa)
11:56:31 * hackagebot crypto-conduit 0.4.2 - Conduit interface for cryptographic operations (from crypto-api).  http://hackage.haskell.org/package/crypto-conduit-0.4.2 (FelipeLessa)
11:56:34 * hackagebot yesod-recaptcha 1.1.0.3 - Dead simple support for reCAPTCHA on Yesod applications.  http://hackage.haskell.org/package/yesod-recaptcha-1.1.0.3 (FelipeLessa)
11:56:36 * hackagebot monoid-extras 0.2.2.0 - Various extra monoid-related definitions and utilities  http://hackage.haskell.org/package/monoid-extras-0.2.2.0 (BrentYorgey)
11:56:43 <rwbarton> in the latter, why are you trying to liftIO the result of print?
11:56:45 <rwbarton> @type print
11:56:46 <lambdabot> Show a => a -> IO ()
11:56:58 <rwbarton> you can't liftIO the value ()
11:57:52 <lolcathost> Are there any tools specifically designed for testing concurrent Haskell programs?
11:58:30 <hpaste> gertc pasted “liftIO” at http://hpaste.org/79060
11:59:17 <rwbarton> can't you just get rid of the outer liftIO
11:59:32 <rwbarton> and write things normally, in do notation
12:00:12 <gertc> no it complains just a sec
12:00:14 <elliott> @where xc
12:00:14 <lambdabot> I know nothing about xc.
12:00:17 <elliott> @where backtrace
12:00:17 <lambdabot> I know nothing about backtrace.
12:00:19 <elliott> where is it
12:00:24 <hiptobecubic> @where bt
12:00:24 <lambdabot> I know nothing about bt.
12:00:33 <rwbarton> @where ghc-xc
12:00:34 <lambdabot> I know nothing about ghc-xc.
12:00:51 <rwbarton> @where rts-xc
12:00:51 <lambdabot> ghc -prof -fprof-auto -rtsopts -osuf .p_o foo.hs && ./foo +RTS -xc # print stack traces on unhandled exceptions
12:01:53 <hpaste> gertc annotated “liftIO” with “liftIO (annotation)” at http://hpaste.org/79060#a79062
12:02:38 <rwbarton> well what is the type of userinfo
12:03:32 <gertc> yes but why does liftIO (userinfo accessToken >>= liftIO . print) work?
12:03:41 <rwbarton> by accident
12:03:44 <gertc> i expected teh same error
12:04:04 <rwbarton> the argument of the outer liftIO is an IO action, of course
12:04:08 <rwbarton> the inner liftIO is extraneous
12:04:24 <rwbarton> liftIO :: IO a -> IO a
12:04:28 <rwbarton> is your inner liftIO type
12:05:23 <Daroth> hi
12:05:24 <rwbarton> I assumed before userinfo was in some monad other than IO, since you wrote "userinfo accessToken >>= liftIO . print"
12:05:45 <rwbarton> but now I see userinfo is actually in IO, and that liftIO is just redundant
12:06:00 <Daroth> I'm wondering, is there an easier way to right the following :
12:06:02 <Daroth> let f =  (\q l -> (take q l) ++ (reverse . take (length l - q - 1) . reverse $ l))
12:06:03 <gertc> how would you right liftIO (userinfo accessToken >>= liftIO . print) ?
12:06:04 <Daroth> ?
12:06:14 <rwbarton> delete "liftIO . "
12:06:30 * hackagebot fb 0.13.4.2 - Bindings to Facebook's API.  http://hackage.haskell.org/package/fb-0.13.4.2 (FelipeLessa)
12:06:36 <m_fulder> hello again :P
12:06:36 <gertc> ok just a sec
12:06:41 <Refried__> terminology question...   if Maybe is a Monad, is Nothing an empty Monad?
12:07:09 <johnw> Nothing is a value
12:07:12 <Philonous> Refried__:  Maybe is a Type, Nothing is a Value.
12:07:17 <c_wraith> Refried__: no.  Monad describes types, not values
12:07:30 <rwbarton> Daroth: what does that do? spare us :)
12:08:01 <gertc> liftIO (userinfo accessToken >>= print) works
12:08:03 <rwbarton> is it just skipping the qth element?
12:08:03 <Refried__> thanks — what can I call a value of a monad type that is the mzero?, without using the term mzero?
12:08:06 <m_fulder> Philonous dont know if you still remember my toString problem but I don't think your line works either :P  "toString (Program sts) = toString =<< sts"  (does the same as concatMap?) but it still will inf. loop because sts is no statement
12:08:12 <osa1> I have some repetitive code in my alex file because of same rules applied to different patterns, is there a way to specify one rule for multiple patterns ?
12:08:15 <Daroth> it drop element at q index in l list so f 2 [1..4] return [1,2,4]
12:08:35 <rwbarton> Refried__: if M is a monad and x is a value of type M A you can call x an "action"
12:08:35 <gertc> rwbarton: liftIO (userinfo accessToken >>= print) but still looks ugly i guess :)
12:08:45 <Botje> Daroth: take a look at the splitAt function.
12:08:46 <Philonous> m_fulder:  (=<<) is (flip concatMap)
12:08:55 <Daroth> Botje: thx :)
12:09:03 <m_fulder> Philonous ah !
12:09:08 <Refried__> rwbarton: I can call Nothing an action?
12:09:11 <rwbarton> Refried__: and mzero is often the action that represents "failure"
12:09:19 <Philonous> m_fulder:  And no, there is no infinite loop, at least not in this function
12:09:21 <Refried__> rwbarton: *nod*
12:09:26 <rwbarton> yes, I do. or "action in the Maybe monad" or "Maybe-action" if you want to be more specific
12:09:32 <Philonous> m_fulder:  The reason it hangs has to be in Statement.T's instance of toString
12:09:44 <Refried__> hmmm ok
12:10:14 <rwbarton> probably if you want to refer to mzero it is clearest to just say "mzero" though!
12:10:14 <m_fulder> Philonous are you sure? doesn't "sts" need to be a Statement before it goes into that instance->toString ?
12:10:47 <Philonous> m_fulder:  We don't call toString on sts, but on it's elements (that's what concatMap does)
12:10:49 <Refried__> rwbarton: I'm trying to defined mzero for folks with context more limited than mine
12:11:06 <rwbarton> ah, I see
12:11:26 <m_fulder> Philonous ah right! you are correct :)
12:11:49 <rwbarton> "an action that represents failure"
12:11:57 <johnw> mzero is action that causes a sequence of monadic bind operations to result in mzero
12:12:21 <johnw> ah, no
12:12:29 <johnw> the definition on this web page is misleading
12:12:29 <lispy> I'm using the latest alex 3.0.2 on the machine where it doesn't compile
12:12:44 <johnw> mzero is just like mempty for Monoids, that's what I originally thought
12:12:54 <johnw> so why would you relate it to failure, rwbarton?
12:13:05 <johnw> > mzero `mplus` [1]
12:13:07 <lispy> > 1
12:13:07 <rwbarton> in practice that is how it is used
12:13:29 <lispy> Cale: linode seems to be acting up. I think you'll have to restart lambdabot
12:13:33 <rwbarton> there mzero is a nondeterministic computation with no successful branches
12:13:34 <johnw> huh, the "tour of Haskell monads" page is just wrong about mzero
12:13:56 <thoughtpolice> lispy: yeah, several people just fell off in other channels, mostly fremont DC i think.
12:15:17 <bgamari> joeyh, Do you have any plans to break up the git-annex source a bit?
12:15:25 <johnw> joeyh: hello!
12:16:03 <bgamari> joeyh, The current approach seems more monolithic than necessary (although I could be wrong)
12:16:31 <citizen93> dear all I have another question, a very simple one. In my module I have data State' s a = State' {runState' ...}, and if I do my module like this module Test (State
12:16:47 <citizen93> module Test (State'(State', runState') where
12:16:51 <citizen93> both of them would be exported right?
12:16:59 <citizen93> oh I'm missing a )
12:18:02 <lispy> thoughtpolice: good to know it's not just me
12:18:21 * lispy is mystified by this alex error
12:18:33 <thoughtpolice> linode fremont is apparently the flakiest of all their DCs :P
12:18:54 <joeyh> bgamari: well, I sometimes think about trying to do something with the 10% or so that is general-purpose utility libraries, and the other 5% or so that is a git library. Perhaps like ledger splits itself at least. Dunno
12:22:40 <lispy> Hmm...I think the way alex handles right_ctx changed between 2 and 3.
12:23:35 <joeyh> bgamari: any thoughts you might have appreciated of course... I'd love to even have separate executables on day, ifwhen dynamic linking becomes the default
12:23:46 <dimka> Are there any ideas how to improve this ? https://gist.github.com/70a12ec6c01be0cf2832
12:23:46 <bgamari> joeyh, It seems like the webapp at least should be split out
12:24:15 <bgamari> joeyh, but I don't know. I was just wondering
12:25:37 <neutrino> hi there
12:26:03 <ypo> mapf: hi
12:27:30 <ypo> anyone here who knows the prime-number page in haskellwiki?
12:28:55 <Botje> dimka: where does msgType come from?
12:29:13 <rwbarton> oh god
12:29:27 <`nand`> dimka: kill it with fire
12:29:38 <Botje> dimka: you should switch to case ... of or at least multiple clauses for your function.
12:29:57 <`nand`> return $ case msgType of
12:30:08 <`nand`> oh; not quite
12:30:23 <rwbarton> how about a lookup table [({- whatever the type of msgType is -}, Get M.SCMessage)]
12:30:33 <`nand`> (,) msgTransactionID <$> case msgType of ...
12:30:35 <`nand`> at the very least
12:31:09 <`nand`> then the bodies can be cleaned up as well
12:31:23 <`nand`> M.PacketIn <$> getPacketInREcord len; etc.
12:34:24 <rwbarton> sometimes people also write
12:34:27 <rwbarton> case () of
12:34:33 <rwbarton>   _ | cond1 -> exp1
12:34:37 <rwbarton>     | cond2 -> exp2
12:34:38 <rwbarton> ...
12:35:03 <rwbarton> which is kind of a hack, but still better than this
12:36:14 <Hafydd> What is wrong with case boolExp of { True  -> ...; False -> ... }?
12:36:33 * hackagebot LambdaHack 0.2.6.5 - A roguelike game engine in early and active development  http://hackage.haskell.org/package/LambdaHack-0.2.6.5 (MikolajKonarski)
12:37:08 <Hafydd> Oh, I suppose that doesn't work if you want more than 2 branches.
12:38:02 <`nand`> rwbarton: if | cond 1 = exp1 | cond2 = exp2
12:38:03 <rwbarton> talking about replacing a (very) nested set of ifs
12:40:52 <tac> Hafydd: You can nest them or tuple them. case (b1, b2, b3) of (True, True, x) -> .... etc
12:41:20 <tac> Agda has an interesting way of dealing with it, using with clauses and preferring decidable propositions over booleans
12:41:51 <Hafydd> That occured to me, but it's a bit ugly in that it separates the guards from their bodies.
12:42:27 <tac> You can also create a data type that expresses the disjoint union of possible outcomes
12:42:39 <tac> like data Sign = Pos | Zero | Neg
12:42:54 <tac> instead of x < 0; x == 0; and x > 0
12:43:05 <Hafydd> > compare x 0
12:43:19 <tac> that works, too :)
12:43:21 <rros> I think i've messed up my pacages (ghc-pkg check shows many errors) can anyone give me directions resetting my install?
12:43:23 <Hafydd> Well, ykwim
12:43:31 <tac> Except lambdabot is on strike?
12:46:14 <m_fulder> Philonous I have one more function in my Parse class:  "parse :: String -> a" (where a is "class Parse a...") now the weird thing is .. in my Statement module I have made an instance of this parse that I know work..and now I am in the Program class just calling parse = Statement.parse
12:46:19 <neutrino> @type newChan
12:46:44 <byorgey> rros: on linuxish-systems, you remove the directory ~/.ghc/<arch>-<version>
12:46:49 <neutrino> the type of newChan is IO (Chan a). how does newChan know what "a" will be?
12:47:08 <byorgey> rros: for example ~/.ghc/x86_64-linux-7.4.2
12:47:16 <byorgey> rros: that contains all your installed packages
12:47:37 <scooty-puff> is :set -package-conf ... respected in a .ghci file?
12:47:45 <neutrino> jmelesky: oh hey
12:47:55 <neutrino> jmcarthur: sorry meant for you :) hey
12:48:05 <neutrino> wow typing is difficult today..
12:48:26 <m_fulder> Philonous: this should work fine because the input is String which is same for both these classes ... though while testing if the parse func. works in my Program class I get the freeze lagg again :/
12:48:52 <reinoud> lseen colah?
12:48:58 <reinoud> seen colah?
12:49:09 <reinoud> hmm no bot :-)
12:49:11 <rros> byorgey: thanks! that worked nicely :)
12:51:43 <neutrino> hey guys, i can do this: forever (getLine >>= putStrLn). what would i need to do to be able to use getChar?
12:52:06 <neutrino> getChar has type IO Char, getLine has type IO String
12:52:41 <slack1256> neutrino: remember that [Char] == String
12:52:48 <neutrino> i know that
12:52:53 <neutrino> i still don't know how
12:53:04 <litherum> forever (getChar >>= return >>= putStrLn)?
12:53:04 <Taslem> neutrino: in the context of IO, >>= works like this: (>>=) :: IO a -> (a -> IO b) -> IO b
12:53:15 <neutrino> i know
12:53:23 <slack1256> so you could for example 'getChar >>= \s -> putStrLn [s]
12:53:29 <alpounet> neutrino, putChar?
12:53:30 <S11001001> litherum: return.return :)
12:53:31 <Taslem> neutrino: So You need a function of type (Char -> IO ())
12:53:42 <litherum> list monad is cooool
12:53:48 <neutrino> right slack1256 i figured that out in parallel but i was hoping for something that allowed me to use putStrLn pointfree
12:54:17 <slack1256> then 'getChar >>= putStrLn  . return
12:54:31 <slack1256> the list is the indeterminacy monad
12:54:41 <neutrino> ah
12:54:42 <neutrino> yes
12:54:57 <Taslem> @pl f x = getChar >>= putStrLn [x]
12:54:57 <slack1256> *or how is called, in spanish indeterminacy is how I would say it
12:54:58 <litherum> ah yeah, that makes more sense than my stupid answer :D
12:55:03 <alpounet> getChar >>= putStrLn . (:[]) or getChar >>= putChar >> putChar '\n'
12:55:11 <Philonous> m_fulder:  Same problem. Statement.parse is the same parse as the one you are defining
12:55:13 <neutrino> i was trying getChar >>= return >>= putStrLn
12:55:14 <Taslem> @pf f x = getChar >>= putStrLn [x]
12:55:26 <slack1256> litherum: give yourself some credit. at least you were in the right path ! :-)
12:55:28 <neutrino> thanks guys
12:56:05 <Taslem> @pl (\x -> putStrLn [x])
12:56:41 <m_fulder> Philonous hm, but its not the same now 'cause toString was toString :: a -> String .. now parse is String -> a  so shouldn't Statement.parse jump in to the Statement class anyway?
12:56:51 <slack1256> neutrino: but remember, pointfree sometimes doesn't make things clearer, use a discretion
13:00:35 <neutrino> yeah
13:00:51 <neutrino> i'm sort of trying to get to terms with it and flex my muscle a bit
13:01:01 <neutrino> i think i'm getting proficient at it
13:01:59 * shapr watches neutrino FLEX his Haskell muscles!
13:02:15 <slack1256> lol
13:03:57 <Philonous> m_fulder:  No, the a still determines the instance that is selected. You have to do something to the result of parse to make it the right type anyway
13:04:16 <johnw> go neutrino!
13:06:01 <deech> Am I right in assuming that lenses can pretty much take care of most uses of arrows?
13:06:08 <m_fulder> Philonous ah yeah thats right
13:08:16 <neutrino> shapr: hahaha
13:08:25 <neutrino> johnw: yay :)
13:08:25 <shachaf> deech: I'm not sure how they're particularly related.
13:09:00 * neutrino makes a lambda-shake
13:09:02 <deech> shachaf: Well lenses seem to better ways of composing operations on tuples.
13:09:15 <deech> shachaf: This seems to be the largest use case of arrows.
13:09:50 <neutrino> deech, you're not right
13:09:53 <Mortchek> Does GHC do any concurrency automatically? Or do you have to tell it specifically to do concurrency?
13:10:02 <Mortchek> s/specifically/explicitly/
13:10:08 <neutrino> it's just that edwardk, who is probably the only person who knows arrows well, is also only working on lenses recently.
13:10:21 <`nand`> mm_freak seems to know arrows well
13:10:33 <neutrino> he says a typical use case for arrows is streams.
13:10:46 <`nand`> netwire is a wonderful use case for arrows
13:10:53 <neutrino> but generally, if you have a function on a monoid, you can use arrows to shift that monoid around and stuff.
13:11:06 <shachaf> That's not really "a use case of arrows".
13:11:07 <neutrino> no, wait, that was comonads.
13:11:13 <Philonous> deech:  The tuple stuff in arrows is mostly to route data around operations. Otherwise composition would have to linear.
13:11:27 * neutrino is confusing arrows with comonads
13:11:31 <Philonous> deech:  So arrows are not to help with tuples, it's the other way wround
13:11:33 <Philonous> around*
13:11:34 <deech> neutrino, Philonous: Ah, thanks.
13:11:40 <shachaf> It's just one generalization that people happen to export from Control.Arrow. People usually only use the (->) version, but it's hardly "about" tuples.
13:11:57 <`nand`> I don't use (->); I use Kleisli Identity
13:12:53 <Philonous> `nand`:  You mean CoKleisli
13:13:09 <deech> shachaf: That makes sense. The times I've looked at Arrow tutorials they always seem to be about manipulating tuples.
13:13:38 <shachaf> deech: A good rule of thumb is to ignore "Arrow tutorials". They're worse than "monad tutorials".
13:13:43 <`nand`> Philonous: clearly
13:13:45 <Philonous> deech:  Out of necessity. You have to shuffle tuples around a lot because how arrows are designed
13:13:58 <uebas> http://www.carolinaherrera.com/212/es/areyouonthelist?share=_Jyay526v2-KjV2VIpPyzUJNBxpkRLQs8YjNLYFCr6fkz4rz3EUUdzs6j6FXsjB4447F-isvxjqkXd4Qey2GHw#episodio-2
13:13:59 <uebas> http://www.carolinaherrera.com/212/es/areyouonthelist?share=q6IaCcQMqoRxdi5nWij9iL8CbSN2ar5IY_v4JetXP-7kz4rz3EUUdzs6j6FXsjB4447F-isvxjqkXd4Qey2GHw#episodio-3
13:14:01 <`nand`> oh, arrow tutorials? http://ertes.de/new/tutorials/arrows.html
13:14:26 <m_fulder> Philonous, though I already have so that the parse from my Statement module returns always a Statement .. but the problem is that I somehow need to call it from the Program instance and then I can only return a list of thoes
13:14:49 <uebas> http://www.carolinaherrera.com/212/es/areyouonthelist?share=5nq-34PGZ4OwXBxmvy079KXJre7r7ZWZcCCIUz8hj97kz4rz3EUUdzs6j6FXsjB4447F-isvxjqkXd4Qey2GHw#episodio-5
13:15:07 <deech> `nand`: That tutorial seems way better than the ones I've looked at: http://en.wikibooks.org/wiki/Haskell/Understanding_arrows
13:15:22 <shachaf> That looks like spam.
13:15:35 --- mode: ChanServ set +o johnw
13:15:45 --- mode: johnw set -o johnw
13:16:29 <shachaf> The wikibook was on the level of astronauts and space suits last I looked.
13:16:43 <shachaf> In fact, the wikibook had astronauts and space suits, or was it nuclear waste?
13:16:46 <johnw> and "containers" and boxing and burritos!
13:16:56 * `nand` thinks the ‘tutorial’ he sent is quite sane
13:16:58 <shachaf> "using the factory metaphor from the monads module as a support"
13:17:31 <Philonous> m_fulder:  You don't need to worry about where parse comes from. The compiler will choose the one with the right type (if one exists). So you could do something like (parse s = Program [(parse s :: Statement.T)]
13:17:35 <johnw> let's write a tutorial where two burrito have a boxing match inside a container
13:17:39 <S11001001> misty banana unicorn forever
13:17:46 <deech> johnw: In space.
13:17:54 <`nand`> it's less a tutorial-by-analogy-or-example and more just a fairly straightforward introduction to arrows themselves; including motivating examples, their laws, their syntax, etc.
13:17:55 <companion_cube> cowrapping burritos
13:17:59 <neutrino> `nand`: that's a really nice arrow tutorial.
13:18:01 <Philonous> m_fulder:  The type annotation isn't even necessary, but it makes it perfectly clear which parse you mean
13:18:10 <johnw> deech: almost definitely in space, because they would both be boxing in space suits
13:18:12 <neutrino> companion_cube: cowtipping bullitos
13:18:20 <johnw> a floating nuclear waste station
13:18:29 <neutrino> on a platform
13:18:46 <deech> neutrino: Cowtipping Burritos would be an awesome name for a band.
13:18:53 <slack1256> companion_cube: what are those? you put the meat outside and wrap the tortilla with meat and wacamole?
13:19:03 <m_fulder> Philonous ah I see
13:19:06 <`nand`> @quote edwardk band
13:19:12 <`nand`> ..
13:19:14 <`nand`> :(
13:19:18 <neutrino> :(
13:19:23 <neutrino> we need a failover-lambdabot
13:19:23 <johnw> "Monads: Ask Us What They Mean"
13:19:26 <kirindave> aristid: Hey, are you at all working on a dynamodb extension for your aws library? SimpleDB seems deprecated.
13:19:30 <`nand`> I don't think it was stored under edwardk either way
13:19:54 <`nand`> 2012-09-01 14:34:07 shachaf Polykinded Indexed Monads is the name of edwardk's new band.
13:19:57 <`nand`> close enough
13:20:04 <Botje> needs more co.
13:20:13 <companion_cube> slack1256: you take a burrito, wrap another burrito inside and "tie the knot"
13:20:15 <neutrino> definitely needs more co-wbell
13:20:24 <companion_cube> so that the first burrito ends in the second one
13:20:25 <aristid> kirindave: no
13:20:32 <FireFly> Polykinded Index Monads is the name of edwardk's new company
13:20:33 <FireFly> ftfy, Botje
13:20:35 * popl stares blankly at neutrino 
13:20:36 <aristid> kirindave: i haven't started, at least
13:20:41 <johnw> or that great horror movie, the Burrito Centipede
13:20:43 <Botje> FireFly: :D
13:20:57 <popl> seven layer centiped
13:21:00 <popl> *centipede
13:21:06 <neutrino> co-needs more wbell.
13:21:09 <companion_cube> coburritos can be found in ta-cobell ?
13:21:41 <Philonous> We need #haskell-copuns
13:21:42 <popl> companion_cube: Only the Doritos Lo-cos.
13:22:02 <neutrino> #cohaskell
13:22:08 <FireFly> What's the dual of a pun?
13:22:30 <popl> FireFly: a couch
13:22:39 <johnw> FireFly: a groan
13:23:08 <crdueck> @hoogle (Monad m, Functor f) => (a -> b) -> f a -> m (f b)
13:23:25 <`nand`> crdueck: return .: fmap
13:23:35 <crdueck> `nand`: thanks :)
13:23:48 <johnw> :t return .: fmap
13:24:08 <neutrino> we really need a failover lambdabot
13:24:17 <johnw> monadbot
13:24:25 <`nand`> (Monad m, Functor f) => (a -> b) -> f a -> m (f b)
13:24:28 <`nand`> johnw ^
13:25:36 <popl> neutrino: only if it's a markov bot
13:25:46 <popl> hilarity would ensue
13:26:02 <neutrino> lambdabot is already a markov bot
13:26:32 <kirindave> aristid: Any reason why? Just no need now?
13:26:41 <neutrino> just so you know popl
13:26:41 <kirindave> aristid: Or is there some technical challenge you ran into?
13:27:01 <popl> neutrino: I know. I wasn't being pedantic, though.
13:27:08 <popl> My fault.
13:28:09 <neutrino> not sure what you mean :)
13:28:35 <popl> like gumbyBRAIN (see #gumbybrain)
13:29:10 <neutrino> hmm ok :)
13:30:57 <popl> neutrino: It's basically useless. :)
13:31:43 <neutrino> no, it's gumby :)
13:32:30 <popl> There's no pokeyBRAIN
13:32:36 <popl> I feel cheated.
13:36:34 * hackagebot tsp-viz 0.1.0.0 - Real time TSP tour visualization.  http://hackage.haskell.org/package/tsp-viz-0.1.0.0 (DavidNilsson)
13:41:09 <m_fulder> Philonous, ops Im sorry the parse function should not return only "a" but a Maybe(a,String) like it says here: http://pastebin.com/cjCdv8BY so I guess I could do something like Just(Program[(parse s::Statement.T)], [])  ?
13:41:18 <pqmodn> > "allo?"
13:42:39 <m_fulder> Philonous or no crap .. parse from Statement will return Maybe(Statement.T, String) too
13:44:00 <Philonous> m_fulder:  Yes, so you need to pattern match on that first
13:44:11 <m_fulder> ah righ!
13:44:12 <Philonous> m_fulder:  (Or use some combinators)
13:47:25 <popl> Why is lambdabot on strike?
13:47:56 <popl> We need to speak with a union representative.
13:48:38 <`nand`> we haven't fed her enough @botsnacks
13:48:59 <popl> I hope you don't buy botsnack from Trader Joes.
13:49:02 <popl> *botsnacks
13:49:25 <popl> There was a botsnack recall.
13:49:47 <m_fulder> Philonous, got it working at least! Thanks a lot for all your help! :D
13:57:30 <slack1256> `nand`: you are right, that's a good arrow tutorial
13:57:45 <Ralith> haven't arrows fallen out of favor?
13:57:53 <`nand`> some valiantly defend them
13:58:27 <hiptobecubic> @tell lambdabot You're fired.
13:58:32 <sipa> many layers of monads have been pierced already
13:58:47 <clahey> `nand`: Are there any good rants out there defending them?
13:58:59 <hiptobecubic> what's wrong with Arrows?
13:59:01 <`nand`> clahey: I haven't seen any
13:59:05 <`nand`> at least none I can actively recall
13:59:11 <Ralith> apparently they're just not actually very useful.
13:59:12 <`nand`> hiptobecubic: Monads are more popular
13:59:16 * Ralith hasn't followed it closely
13:59:44 <byorgey> Ralith: they were never particularly "in favor", for that matter, but they have some niche uses.
14:00:01 <Ralith> byorgey: in particular?
14:00:21 <`nand`> automaton a rrows
14:00:34 <`nand`> newtype Auto a b = Auto (a -> (b, Auto a b))
14:00:35 <byorgey> FRP libraries is a big one
14:00:56 <slack1256> scoutess uses arrows for the chain of compiler computations
14:03:01 <epta> ocharles: are you gonna write something about FPR in 24 days of hackage?
14:03:20 <epta> frp*
14:03:37 <Philonous> Ralith:  You can pin static information to arrows (but not to monads), that's useful for some parsers
14:04:13 <neutrino> epta: what is 24 days of hackage?
14:04:35 <Philonous> neutrino:  http://ocharles.org.uk/blog/posts/2012-12-10-24-days-of-hackage-parsec.html
14:04:58 <slack1256> neutrino: check out planet haskell for update on that ^
14:05:24 <epta> Or just reddit
14:05:33 <epta> Or just ocharles twitter
14:05:48 <neutrino> ok
14:05:51 <neutrino> i will
14:09:11 <Philonous> I've finally understood how syb works. And it doesn't seem quite as mind-boggling any more
14:11:45 <slack1256> Philonous: share your wisdom with me, I can't catch on it
14:11:56 <slack1256> what did you read? give me a meta-tutorial
14:12:36 <ocharles> epta: I'm afraid not
14:12:42 <ocharles> epta: I have 0 experience with FRP
14:12:48 <Philonous> slack1256:  I read http://hackage.haskell.org/packages/archive/binary-generic/0.2.1/doc/html/src/Data-Binary-Generic.html#getAlgebraic and wrote a generic XML pickler
14:12:49 <ocharles> maybe next year ;)
14:13:36 <epta> This is a 24 days vacation and you have nothing to do or where did that strange name comes from?
14:13:51 <simpson> epta: Advent, probably.
14:14:15 <slack1256> Philonous: Ok will read
14:20:36 <Noldorin> Question on the untyped lambda calculus here, if anyone can help... Given a linear term s in Lambda-Beta, and s ->_B t (that is, s one-step beta-reduces to t), show that t is linear.
14:21:36 <lispy> any alex experts here?
14:21:41 <mdmkolbe> Is there a varient of "read" for integers that will provide me a Nothing instead of failing?  e.g., read' "123abc" == Nothing && read' "-5" = Just -5
14:21:50 <hpc> :t reads
14:21:59 <hpc> D:
14:22:21 <elliott> mdmkolbe: readMaybe
14:22:21 <hpc> reads "123abc" = [(123, "abc")] -- extra text after the parse
14:22:32 <elliott> hpc: you don't have to use reads for that any more thankfully
14:22:42 <hpc> awesome
14:23:35 <mdmkolbe> elliott: what module is readMaybe in?  I'm not seeing it.
14:23:49 <elliott> good question
14:23:54 <elliott> Text.Read
14:24:05 <elliott> see also readEither
14:25:26 <mdmkolbe> elliott: I don't see either one in Text.Read (http://www.haskell.org/ghc/docs/7.0.4/html/libraries/base/Text-Read.html)
14:25:53 <Clint> 7.0.4 doesn't sound like "now"
14:26:12 <ocharles> epta: it's an advent calendar
14:26:19 <ocharles> epta: there are 24 days before christmas day
14:26:26 <elliott> mdmkolbe: looks like you have an excuse to upgrade
14:26:30 <ocharles> epta: no vacation here :(
14:26:30 <hpc> Clint: it's "now" enough for those of us who aren't that great at following haskell news ;)
14:26:39 <elliott> failing that use reads
14:26:47 <epta> ocharles: ok
14:37:40 <Dexter509> i'm trying to convert a list of elments in to a list of pairs, but the type-checking always fails.. http://ideone.com/2f2dyl
14:37:46 <Dexter509> any ideas what i'm doing wrong?
14:38:55 <shachaf> Dexter509: You're mixing up your use of brackets.
14:39:03 <shachaf> (a:b) isn't the same as [a:b]
14:39:14 <shachaf> And [a] : b isn't the same as a : b
14:39:33 <Dexter509> yes, but i nested them properly, didn't i?
14:39:46 <shachaf> I'm not sure what you mean.
14:39:59 <shachaf> Your function has three cases:
14:40:26 <shachaf> An empty list, a list of one element of any form, and a list of one element of the form x1:x2:xs
14:40:34 <Hafydd> Dexter509: http://ideone.com/KZ7xcN
14:40:34 <shachaf> You don't handle lists longer than one element.
14:40:35 <Dexter509> if i leave out the brackets the compiler still complains, becaus the result is not a list anymore
14:40:50 <Dexter509> oh, how would i do that?
14:41:02 <`nand`> perhaps you meant pair (x1:x2:xs)
14:41:28 <shachaf> Look at some other function that does something to a list.
14:41:30 <shachaf> @src map
14:41:43 <shachaf> Bah.
14:41:51 <`nand`> (x1:x2:xs) matches something of the form “x1 cons'd to x2 cons'd to something”
14:42:11 <`nand`> to perhaps make it more clear, your second case [x] is equivalent to x:[]
14:42:26 <`nand`> and [x1:x2:xs] is equivalent to (x1:x2:xs):[]
14:42:56 <simpson> Dexter509: http://ideone.com/A1yGIg
14:44:12 <ocharles> sclv: ping?
14:44:21 <ocharles> sclv_: ping too :)
14:45:07 <sclv> ocharles: yo
14:45:41 <ocharles> sclv: yo, didn't know you were on irc, I just sent you an email about Diff
14:45:53 <Dexter509> [23:42:06] <`nand`> and [x1:x2:xs] is equivalent to (x1:x2:xs):[] <- why is that? i thought tuples are not lists
14:45:56 <ocharles> (i didn't make the association between your irc handle and email address until I hit send :))
14:46:16 <sclv> ocharles: patches welcome :-)
14:46:26 <`nand`> Dexter509: there's no tuple there
14:46:27 <sclv> i'll look at the request more closely too
14:46:32 <ocharles> sclv: happy to supply patches, just wanted to know if you agreed with what I wanted
14:46:47 <donri> Dexter509: comma makes a tuple, not parenthesis
14:46:55 <Dexter509> oh, ok
14:47:14 <sclv> as long as it can still do the simpler interface its all good
14:47:29 <ocharles> ok
14:47:48 <ocharles> sclv: bah, now I have to learn darcs :P
14:47:51 <sclv> actually, hmm…
14:47:59 <sclv> ocharles: i'll take a .patch file too :-)
14:47:59 <Dexter509> so what are the parenthesis for then?
14:48:02 <ocharles> ok :)
14:48:18 <sclv> so maybe we really want (DI a) and to return [(DI a)]
14:48:30 <sclv> where we have data DI = F a | S a | B a a
14:48:39 <sclv> ?
14:48:47 <ocharles> sclv: bingo
14:48:53 <danr> sclv: data DI a = ... ?
14:48:55 <Dexter509> so square brackets are for those complex types?
14:49:04 <sclv> don't rememebr what I thought DI should stand for
14:49:05 <`nand`> square brackets are for lists
14:49:10 <sclv> difference indicator i think
14:49:16 <`nand`> the parentheses are just for grouping; think (1 + 3) * 4
14:49:19 <pnielsen> will a thread that's waiting on STM (retry) be garbage collected if nothing no longer uses/refers to it?
14:49:19 <danr> Dexter509: square brackets is sugar for lists (and is desugared to (:) and [])
14:49:21 <sclv> diff was the first thing i ever put on hackage
14:49:27 <pnielsen> (GHC)
14:49:27 <ocharles> sclv: and my diff3 is going to change to be data Hunk a = Hunk HunkType [a] [a] [a], probably
14:49:45 <ocharles> sclv: yea, I figured it meant difference indicator
14:49:50 <`nand`> without parentheses; a:b:c would parse to a:(b:c); which is distinct from (a:b):c
14:49:59 <Dexter509> ok, letzt me put the question another way then, why do i need [x] in line 3 in http://ideone.com/A1yGIg, but (x1:x2:x3) in line 4?
14:50:03 <Dexter509> *Tet
14:50:06 <Dexter509> *let
14:50:14 <pnielsen> refers to anything inside the transaction, that is
14:50:18 <ocharles> sclv: wait, F a is still not enough
14:50:19 <danr> Dexter509: the first [x] means (x:[])
14:50:20 <donri> Dexter509: [1,2,3] is sugar for 1:(2:(3:[]))
14:50:20 <`nand`> Dexter509: because you're matching a list with exactly one element
14:50:25 <ocharles> no wait yes it is, ignore me :)
14:50:31 <`nand`> [1] is a list containing just ‘1’
14:50:56 <sclv> ocharles: if you want to generalize further to take a diff of a and b both
14:51:01 <`nand`> the first line matches an empty list; the second line matches a list with one element; the third line matches a list with at least two elements
14:51:01 <sclv> DI a b
14:51:05 <sclv> with an equality relation
14:51:12 <sclv> that's cool too :-)
14:51:44 <Dexter509> but why does the third line not need square brackets? (or more importantly, why does it fail with square brackets?)
14:51:57 <ocharles> sclv: I think I'll just do enough to scratch my own itch, if you don't min d:)
14:51:59 <pnielsen> if anyone's curious, just found this which answers the question with "yes" :) http://blog.ezyang.com/2011/07/blockedindefinitelyonmvar/
14:52:31 <sclv> sure. as you can see diff just sort of does its thing and only gets updates when someone has an itch, so no need for overgeneralization prematurely
14:52:41 * ocharles nods
14:53:01 <byorgey> Dexter509: [ ... ]  always means a list with a single element, where ... is that element
14:53:21 <byorgey> Dexter509: so [x] means 'match on a single element list, and call that element x'
14:53:26 <hpaste> “`nand`” pasted “pair” at http://hpaste.org/79064
14:53:31 <Dexter509> oh, i see
14:53:45 <byorgey> Dexter509: and [x1:x2:xs] means 'match a single element list, whose single element is a list with at least two elements'
14:53:47 <`nand`> Dexter509: I changed it slightly and added some formatting that I hope will make it a bit clearer
14:53:49 <`nand`> http://hpaste.org/79064
14:54:01 <`nand`> oh, typo
14:54:13 <hpaste> “`nand`” annotated “pair” with “pair (annotation)” at http://hpaste.org/79064#a79065
14:54:16 <`nand`> have a look now ^
14:56:04 <donri> Dexter509: technically you don't need parenthesis to pattern match on lists with (:), but you do need the parenthesis to tell the parser that you don't mean "(pair x) : xs"
14:56:54 <donri> Dexter509: same as if you're pattern matching on a Just, for example, you need "f (Just x)" even though the parenthesis have nothing to do with Just or Maybe
14:57:41 * `nand` .oO( [..] should totally be something like enumFrom minBound )
14:58:38 <Hafydd> `nand`: would that not introduce more platform-independent behaviour?
14:58:45 <Hafydd> Er, "-dependent"
14:59:16 <`nand`> that would depend on what it is you're minBound'ing
14:59:28 <`nand`> arguably you'd never use [..] on [Int] in the first place
14:59:40 <Hafydd> Fair point.
15:00:00 <danr> admittedly, it would be a terse way of enumerating the booleans
15:00:03 <`nand`> which is probably one of the only thing that really has a platform dependent minimum bound
15:00:11 <`nand`> yeah, or any other (Ord a, Bounded a)
15:00:16 <ziman> filterM [..] :)
15:00:24 <danr> ziman: ^^
15:00:37 * alpounet just remembered byorgey's neat (...) operator
15:00:51 <danr> alpounet: what did it do?
15:01:08 <`nand`> enumFromTo ?
15:01:12 <`nand`> wait no
15:01:13 <`nand`> that would be redundant
15:01:21 <shapr> @quote
15:05:30 <alpounet> danr, you gave it a list, i somehow computed a progression determined by the few elements you gaveit and handed you back an infinite list following the rule determined by the few first elements
15:06:27 <danr> aha, sounds like extrapolating a polynomial... but I don't see how this would be a binary operator
15:06:28 <Dexter509> is there a way to check if i'm dealing with lists of lists? or do i need a separate function that takes care of that?
15:06:45 <Philonous> alpounet:  With newton polynomials?
15:06:47 <shachaf> _Mathematics Made Difficult_ had a good section about how to do those.
15:07:28 <alpounet> Philonous, nah, just subtracting stuffs
15:07:40 <Hafydd> I do have to wonder in how many situations there would be an actual use of quadratic, cubic, etc progressions.
15:07:46 <alpounet> but it was cool to write, say, [1,3,6]...
15:10:51 <Philonous> > let (...) = cycle in ([1,2,3]...)
15:10:55 <Philonous> Ah, darn
15:11:33 <`nand`> Philonous: does lambdabot have PostfixOperators set?
15:11:54 <hpc> > [[] ..]
15:11:58 <quchen> alpounet: Maybe it sent a query to OEIS
15:12:10 <alpounet> quchen, nope
15:12:14 <Hafydd> Hahah.
15:12:38 <alpounet> it was using a very simple thing, just using the difference between an element and its predecessor, stuffs like that
15:12:41 <quchen> Mathematica has a function like that and it finds the weirdest things
15:12:54 <`nand`> quchen: hey that's a brilliant idea
15:12:58 <alpounet> quchen, lambdabot does have a @oeis command :)
15:13:05 <quchen> @oeis 1 2 3 4 5 7
15:13:14 <alpounet> (but the bot is down right now)
15:13:26 <quchen> Hm
15:13:30 <`nand`> unsafePerformIO . extendSequence_IO :: [Integer] -> [Integer]
15:13:33 <`nand`> any questions?
15:13:37 <elliott> too bad OEIS is mutable
15:13:41 <alpounet> quchen, it uses  http://hackage.haskell.org/package/oeis-0.3.1
15:14:05 <ocharles> sclv_: dunno if you've headed off now, but https://gist.github.com/3d25d4fb7f424dbfcd22 is one approach
15:14:11 <`nand`> oh hey
15:14:12 <quchen> alpounet: I learned again not to joke about math and Haskell in the same sentence
15:14:13 <`nand`> that actually exists
15:14:24 <`nand`> Math.OEIS.extendSequence = unsafePerformIO . extendSequence_IO
15:14:25 <hpc> elliott: use archive.org for a specific date upper bound to make it immutable
15:14:34 <hpc> updates to oeis would consist of just a bump on that date
15:14:37 <Philonous> `nand`:  The plugin should invent a random sequence about 1 in 20 times.
15:14:57 <quchen> `nand`: Wait, you guessed that function, and now it's there with the same names?!
15:14:58 <Dexter509> do i have to specify matching types in some special way? i.e. i have type Week = [Run] and type Run = (Int, Int) and pair :: [String] -> [Week] - but the compiler tells me [String] -> [(Int,Int)] does not match [String] -> [Week]
15:15:01 <elliott> `nand`: not even an unsafe in the name?
15:15:05 <hpc> oeis 1 2 4 9
15:15:07 <alpounet> quchen, :P
15:15:18 <`nand`> elliott: nope
15:15:26 <`nand`> quchen: I looked up extendSequence_IO
15:15:31 <quchen> I see
15:15:34 <quchen> That makes sense.
15:15:34 <hpc> [1, 2, 4, 9, 1, 1, 1, 1, 1, 1...] -- the sequence beginning with [1, 2, 4, 9] followed by an endless stream of ones
15:15:41 <`nand`> quchen: but I found extendSequence after it
15:15:42 <hpc> the most useful sequence!
15:15:49 <quchen> That's some dangerous use of unsafePerformIO
15:15:58 <quchen> (And by dangerous I mean wrong)
15:15:59 <Philonous> Dexter509:  It's [String] => [[(Int, Int)]]
15:16:14 <Dexter509> oh :x
15:16:22 <`nand`> elliott: nope; but words of warning in the haddock: “There are no side effects, and practically speaking this function is referentially transparent (technically, results may change from time to time when the OEIS database is updated; this is slightly more likely than the results of getSequenceByID changing, but still unlikely enough to be essentially a non-issue. Again, purists may use extendSequence_IO).
15:16:24 <`nand`> ”
15:17:04 <quchen> I'll use unsafePerformIO on readFile now
15:17:07 <Philonous> `nand`:  Uh, doesn't it connect to the server?
15:17:11 <quchen> -- purists don't use that part of the code please
15:17:16 <Dexter509> hm.. i'm using hugs currently, is there maybe some other interactive system that explains these error better?
15:17:17 <quchen> -- also don't change the file
15:17:24 <`nand`> Philonous: it does
15:17:41 <elliott> `nand`: purists may disown this library...
15:17:46 <`nand`> I wonder how extendSequence behaves in the presence or nonpresence of an ethernet cable in my RJ45 port :)
15:18:10 <quchen> Let's write IO' for somewhat pure code but not really
15:18:21 <`nand`> newtype IO' a = IO' a
15:18:23 <quchen> It's when ST is too restrictive but IO is too permissive
15:18:26 <`nand`> -- not quite pure
15:18:46 <simpson> quchen: Do you have an example?
15:19:02 <quchen> printIO' x = unsafePerformIO $ do { print x; return x }
15:19:16 <quchen> simpson: I was just joking
15:19:20 <simpson> quchen: Okay.
15:19:21 <tac> @type unsafePerformIO
15:19:21 <Dexter509> what does the $ do?
15:19:29 <tac> oh yeah, lambdabot's dead.
15:19:32 <Philonous> Dexter509:  f $ x = f x
15:19:38 <`nand`> tac: IO a -> a
15:19:44 <hpc> the scariest function
15:19:49 <tac> Dexter509: It's a handy operator to reduce the number of parens required
15:19:53 <quchen> Dexter509: ($) is low-precedence function application.
15:19:53 <Dexter509> so call f with parameter x?
15:19:53 <alpounet> cloud lamndabot, hell yeah
15:19:53 <c_wraith> a -> b is scarier
15:19:57 <Philonous> Dexter509:  But with really low precedence, so you need fewer parenthesis
15:20:04 <tac> Dexter509: f $ a b == f (a b)
15:20:12 <Dexter509> ah, ok
15:20:13 <`nand`> c_wraith: a -> b can be implemented in terms of IO a -> a
15:20:23 <quchen> f x binds very tightly. for example, f x y = (f x) y. $ binds very loosely, f $ x y = f (x y)
15:20:49 <quchen> Why is Lambdabot down?
15:20:52 <quchen> Is he hosted on Facebook?
15:21:01 <`nand`> () = unsafePerformIO launchMissiles
15:21:01 <Philonous> `nand`:  Real languages have the value restriction!
15:21:27 <hpc> () = unsafePerformIO killAPuppy
15:21:34 <`nand`> should be fine as long as nobody pattern matches on ()
15:21:36 <hpc> never seq on ()!
15:21:37 <`nand`> nobody does that, right?
15:21:51 <quchen> hpc: Why not?
15:21:54 <quchen> `nand`: Why not?
15:21:55 <Hafydd> I have patten matched on Right ()
15:22:07 <quchen> case x of () -> x
15:22:10 <quchen> Looks legit to me
15:22:12 <hpc> quchen: either it evaluates to () or...
15:22:18 <quchen> Bottom! :D
15:22:27 <`nand`> Hafydd: why not Right _ ?
15:22:29 <quchen> It's a concise way of checking whether your program crashes.
15:22:30 <c_wraith> hpc: it's actually a key part of rnf :)
15:22:30 <`nand`> laziness :D
15:22:34 <Hafydd> I just didn't want to write Right _, because it seemed opaque.
15:22:46 <hpc> c_wraith: oh god the puppies
15:23:18 <c_wraith> I kinda dislike rnf because it's like a slow sledgehammer.  But it's a helpful debugging tool, at least
15:23:19 <slack1256> quchen: facebook is down?, so that's why my little sister is crying
15:23:19 <slack1256> > 2 + 2
15:23:20 <Hafydd> And indeed if there was a "Right (error "oh no")", I didn't want to hide it.
15:23:28 <`nand`> slack1256: 4
15:23:38 <quchen> slack1256: It was. It's up again though.
15:23:47 <c_wraith> Hafydd: isn't what you wanted ismorphic to Maybe, rather than Either () ?
15:23:48 <quchen> > 2 + 4
15:23:58 <`nand`> Hafydd: I don't think I've seen any context in which you'd pass ⊥ in place of ()
15:24:02 <hpc> quchen: 7
15:24:09 <`nand`> maybe in place of the entire expression; sure, but not Right undefined
15:24:11 <c_wraith> Hafydd: oh, you said *right*.
15:24:12 * `nand` sleeps
15:24:13 <quchen> Cloud Haskell version of Lambdabot? :D
15:24:24 <slack1256> > (exp pi) - pi
15:24:33 <quchen> I like Maybe ()
15:24:35 <Hafydd> c_wraith: it was Either String (), acting as an exception Monad, with the right type possibly varying in computations.
15:24:41 <hpc> slack1256: * Exception: divide by cucumber
15:24:51 <slack1256> heh
15:24:55 <cmccann> hpc, please reinstall universe
15:25:19 <Noldorin> Question on the untyped lambda calculus here, if anyone can help... Given a linear term s in Lambda-Beta, and s ->_B t (that is, s one-step beta-reduces to t), show that t is linear.
15:25:20 <quchen> Just wrap it in unsafePerformIO and give the file a .py ending
15:25:27 <hpc> i like to think groundhog day was someone running the universe from live cd
15:25:33 <cmccann> haha
15:25:47 <cmccann> or maybe it's what an STM transaction feels like from the inside
15:25:52 <Hafydd> `nand`: but I like to know that my program components are completely safe, independently of how their neighbours are written.
15:26:36 * hackagebot pcd-loader 0.3.0.0 - PCD file loader.  http://hackage.haskell.org/package/pcd-loader-0.3.0.0 (AnthonyCowley)
15:27:17 <jtkman> Hello guys, I am currently doing my homework, which is to write a Monad, however my monad has a termination problem. I know the problem is something with displaying the state, however I can't see what I'm doing wrong.
15:28:20 <slack1256> jtkman: can paste what you got on hpaste?
15:28:27 <jtkman> http://pastebin.com/cbR7jV55
15:28:34 <slack1256> *can you, pardon
15:28:40 <jtkman> I have it here, because I cannot risk somebody else copying it :(.
15:28:47 <jtkman> So I've set the time to 1 hour :(
15:29:13 <jtkman> as you can see eval example1 fails terminating :(
15:29:25 <jtkman> I meant eval example1 ()
15:30:10 <jtkman> uhm... wait it's called runStateMonadPlus now..
15:30:15 <Hafydd> D: what is wrong with pastebin's Haskell hilighting?
15:30:33 <simpson> pastebin.com is pretty lame.
15:30:50 <jtkman> :(, I'm sorry, but hpaste doesn't have any time limitations :(
15:30:52 <shapr> Does anyone know Colin Runciman? I'm wondering if there's some likelihood Gadgets could be released under a GPL or BSD license?
15:30:55 <jtkman> as far as I know
15:30:57 <Hafydd> And whose idea was it to give strings a contrasting background colour?
15:31:01 <simpson> jtkman: Considered asking your TA?
15:31:05 <quchen> jtkman: Some general advice: 1. Try to keep your lines short (< 80 characters). This has multiple reasons. For example, you can easily fit two windows on the screen alongside each other, it's easy to edit in a single standard console window, and if your line is super long it's hard to read in any case because you're packing so many things into one  expression
15:31:29 <jtkman> Yes, I will do it tomorrow, but I actually wanted to fixed today (deadline is btw on Friday)
15:31:31 <quchen> Furthermore, don't indent after the module declaration, as horizontal space is precious
15:32:09 <jtkman> quchen, I actually like the consistency of indentations after module declaration
15:32:29 <jtkman> I'm sorry if this is not the status quo programming style, I will try to change that
15:32:35 <slack1256> jtkman: welp you have minor error already
15:32:39 <Hafydd> You will try to change the status quo?
15:32:44 <jtkman> no
15:32:51 <jtkman> I will adapt my style to the status quo ;)
15:32:57 <slack1256> in the return method of the monad instance of stateMonadPlus
15:32:58 <Hafydd> Oh good.
15:33:07 * Hafydd moves his finger away from the "independent thought" alarm.
15:33:17 <slack1256> no wait
15:33:19 <slack1256> my bad
15:33:37 <beekor> haa
15:33:39 <jtkman> I thought it was correct :(
15:33:57 <jtkman> I have looked for 4 hours now, but I can't seem to find it... :(
15:34:00 <slack1256> it's apparently correct, wait a little
15:34:14 <Hafydd> (But seriously, indenting after a module declaration is a bit demented, even if, as you say, it is consistent with the abstract syntax tree).
15:34:17 <slack1256> without blinking? :-)?
15:34:26 <jtkman> no, I blinked a lot :P
15:35:01 <rwbarton> I suggest you compile with -Wall
15:35:17 <jtkman> I will stop indenting after module decl., I feel pressure from my seniors :P
15:35:34 <quchen> jtkman: Haha :-) No pressure
15:35:45 <hpc> rwbarton: i expect a crappy nerd band somewhere has released an album called "The -Wall"
15:36:08 <hpaste> Hafydd pasted “Horrible” at http://hpaste.org/79066
15:36:19 <quchen> jtkman: It's just a matter of preserving space. Indentation should separate/group code blocks, but any module has only one module declaration, and that one's at the top
15:36:26 <quchen> So you don't have to group/whatever it.
15:36:31 <dinox> ;;help
15:36:34 <quchen> Add a few newlines after it if you want. :-)
15:36:36 <jtkman> btw the return function can't be wrong, I think because example0 actually terminates
15:36:37 * hackagebot clckwrks 0.13.0 - A secure, reliable content management system (CMS) and blogging platform  http://hackage.haskell.org/package/clckwrks-0.13.0 (JeremyShaw)
15:36:50 <rwbarton> pretty sure -Wall will point out your errors to you
15:37:01 <jtkman> What is -Wall?
15:37:10 <acowley> Show all warnings
15:37:33 <quchen> It's like -spam, but more verbose
15:37:39 <rwbarton> add -Wall to ghc command line while compiling (and make sure you actually recompile)
15:37:42 <jtkman> Oh this is cool!
15:37:44 <jtkman> Thanks!
15:38:04 <dinox> What is the name of the awesome bot who can make funktions point-free?
15:38:13 <jtkman> OH MY GOD, I SEE THE MISTAKE I THINK! :|
15:38:20 <mux> dinox: lambdabot
15:38:21 <jtkman> some functions are just too general!
15:38:31 <quchen> dinox: Lambdabot. @pl FUNCTION
15:38:36 <quchen> However it's down right now
15:38:42 <quchen> > 1 + undefined
15:38:44 <dinox> thanks mux and quchen! Awww
15:38:49 <jtkman> hmm... no wait...
15:39:14 <jtkman> runStateMonadPlus example1 () still gives me nothing of a warning :(
15:39:22 <slack1256> dinox: also there pointfree on cabal which is a cli for the same thing
15:39:24 <jtkman> and it doesn't terminate
15:43:10 <jtkman> Well I know it has to do something with the State, though, but I have no idea what I did wrong :(
15:45:11 <acowley> jtkman: Is there an hpaste somewhere that shows what you're wrestling with?
15:45:28 <jtkman> oh yes http://pastebin.com/cbR7jV55
15:45:56 <jtkman> I'm having difficulty to determine why my Monad doesn't terminate, I will show you: runStateMonad example1 ()
15:46:40 <jtkman> results in non-termination :(, I've no idea what I did wrong and the problem probably lies in the state, but I don't know how to fix this
15:47:07 <rwbarton> read the warnings...
15:47:09 <acowley> What the heck is happening with the color highlighting on that page?
15:47:53 <rwbarton> even better, fix the warnings
15:48:24 <jtkman> I don't know what happened to the color highlighting
15:48:50 <acowley> It's the single quotes
15:48:52 <rwbarton> pastebin is not too smart about identifiers with single quotes in their names, it seems
15:48:52 <Hafydd> It was probably written by some philistine who didn't know that ' can occur in identifiers in Haskell.
15:50:10 <cmccann> my code editor doesn't understand prefix ' for TH  :[
15:50:37 <jtkman> ic, I'm trying to fix all the warnings
15:56:16 <jtkman> well I fixed all fixable warnings, but I still get non-termination
15:56:33 <jtkman> the example0 to example2 code should not be edited, because this is defined in the assignment
15:56:37 * hackagebot clckwrks-cli 0.2.0 - a command-line interface for adminstrating some aspects of clckwrks  http://hackage.haskell.org/package/clckwrks-cli-0.2.0 (JeremyShaw)
15:56:52 <jtkman> I give up, Haskell beat me today
15:57:05 <rwbarton> what does "all fixable warnings" mean, can you paste the new code?
15:58:27 <jtkman> http://pastebin.com/Uy8Zu7sA <- new code with warnings arising from example0 to example2 (I can't fix them because these lines are from the assignment itself)
15:58:34 <Hafydd> Hahah, according to archlinux.org, "The community around Haskell on Arch is dying but in the process of revival"
15:58:53 <c_wraith> So..  it's a phoenix, where death and revival are the same thing?
15:58:55 <slack1256> Hafydd: but that's true
15:59:14 <Hafydd> It sounds like a contradiction to me, slack1256, to be both dying and reviving.
15:59:24 <slack1256> there where 3 guys, one left and the 2 left are trying to get new members
15:59:40 <Dexter509> can i do someting like let (a,b,c) = somefunction array-of-tuples?
15:59:43 <jtkman> it's called reincarnation Hafydd
15:59:47 <Dexter509> what is the proper syntax for it?
15:59:55 <jtkman> ;)
15:59:57 <slack1256> Hafydd: thing like cancer, technically you are dying but you have more cells everyday
16:00:01 <slack1256> *think
16:00:04 <Hafydd> Haha.
16:01:49 <jtkman> hopefully after a nice shower I will get more inspiration
16:02:07 <simpson> jtkman: Got it. You shadowed a bit too aggresively.
16:02:11 <acowley> Dexter509: Can you clarify what somefunction array-of-tuples" is?
16:02:11 <simpson> Er, *aggressively.
16:02:13 <jtkman> :|
16:02:17 <acowley> jtkman: I addressed warnings and it works now
16:02:29 <rwbarton> the cat is out of the bag
16:02:37 <acowley> jtkman: You should do the same!
16:02:47 <rwbarton> anyways if you look again at your new code you will see parts that are obviously wrong now
16:02:56 <jtkman> alright
16:02:59 <Dexter509> acowoley a function that returns a tuple - basically what i want to do is generate multiple aggregates from one array of tuples
16:03:02 <jtkman> I see, I should use more names
16:03:04 <ocharles> how do I read the quickcheck error message https://gist.github.com/5e75de2a0fe43c23ab3d ? Does that mean the property failed when the arguments were '[0]' and '[]'? My property is [Int] -> [Int]
16:03:11 <ocharles> [Int] -> [Int] -> Property *
16:03:19 <simpson> jtkman: Hint: let (s, m') = (s, frob m) in ...
16:03:20 <jtkman> I'm not creative enough with names =.=" sigh
16:03:31 <simpson> jtkman: Consider: let m' = frob m in ...
16:03:51 <jtkman> ah I see I get it =)
16:03:53 <jtkman> Thank you!
16:03:58 <simpson> Sure.
16:04:09 <jtkman> 4 hours and I missed something this elementary -.-"
16:04:19 <acowley> Dexter509: Your example, let (a,b,c) = f stuff, is valid syntax, though. So I'm not sure what the question is.
16:04:20 <simpson> Also, you're gonna be happier with the readability of your code if you move showTuple and showMap up to the top level of the module.
16:04:31 <acowley> jtkman: The compiler wanted to tell you!
16:04:45 <Dexter509> oh, ok then - didn't really expect it to work
16:04:55 <simpson> jtkman: Also also, you don't have to indent the first level of indentation in modules; it's customary to have all top-level statements in a module be unindented.
16:05:07 <jtkman> yes I noticed that, but I removed the unused binds... but that was ofcourse wrong! XD
16:05:55 <jtkman> thanks =), I will adopt my style to the status quo
16:06:37 * hackagebot clckwrks-plugin-bugs 0.3.0 - bug tracking plugin for clckwrks  http://hackage.haskell.org/package/clckwrks-plugin-bugs-0.3.0 (JeremyShaw)
16:07:47 <jtkman> I'm now going to fix my mistakes =). Thanks guys!
16:08:15 <jtkman> Everytime I come here, I learn more =). I really appreciate you all =).
16:08:23 <jtkman> thanks!
16:08:29 <simpson> jtkman: Also, just for fun, go read up on what intercalate (from Data.List) does.
16:09:26 <jtkman> intercalate? alright thanks!
16:10:03 <jtkman> hahaha :P, thanks! Brilliant!
16:10:09 <jtkman> intercalate ;) :P
16:11:43 <hpaste> quchen pasted “Good night #haskell” at http://hpaste.org/79068
16:13:38 <Hafydd> :)
16:13:40 <lolcathost> quchen: Is there any reason why you have not used ST instead?
16:14:28 <quchen> lolcathost: Because that's redundant. You would have to cast it to IO first in order to apply unsafePerformIO.
16:14:38 <quchen> I'm aiming for minimalism
16:14:47 <acowley> unsafePerformIOAllTheThings
16:14:56 <quchen> Also naming conventions can help making code more readable. For example in (xs:x), xs stands for "x singular", and x contains the rest of the x.
16:14:59 <quchen> Bye ;-)
16:15:27 * lolcathost is befuddled.
16:18:06 <Dexter509> is something like map \(a,b) -> a+1 valid? (i.e. pattern matching in the maped variable)
16:18:54 <rwbarton> sure, aside from missing parens around the function
16:18:55 <Cale> Dexter509: yes
16:18:57 <acowley> Dexter509: Do you have GHCi available?
16:18:58 <shachaf> Dexter509: Try it out!
16:19:00 <lolcathost> Dexter509: I think it needs $, but other than that, it's okay.
16:19:07 <Cale> rwbarton: Those aren't always required :)
16:19:16 <Cale> oh
16:19:17 <Cale> map
16:19:20 <Cale> I missed that :)
16:19:25 <rwbarton> ah
16:19:34 <Dexter509> oh, so map needs parenthesis for the part after -> ?
16:19:43 <lolcathost> Dexter509: No.
16:19:44 <Cale> map (\(a,b) -> a+1)
16:19:47 <shachaf> No, the lambda needs parentheses.
16:19:55 <Dexter509> ah, ok
16:19:55 <shachaf> The map is a separate part.
16:19:56 <applicative>  map (\(a,b) -> a+1)
16:20:08 <shachaf> Cale: What's with lambdabot, by the way?
16:20:21 <Cale> Is something wrong?
16:20:25 <Cale> > 1
16:20:30 <Cale> hm
16:20:32 <rwbarton> I heard the internet is broken
16:20:34 <acowley> something is very wrong
16:20:47 <acowley> I heard gmail relies on lambdabot, hence the former's problems today
16:21:24 <rwbarton> @botsnack
16:21:29 <lambdabot> :)
16:21:50 <shachaf> Cale: Thanks!
16:21:55 <shachaf> Cale: Could you add #haskell-lens to the autojoin list, too?
16:25:19 <Dexter509> wow, the program is actually running xD
16:25:38 <Cale> shachaf: okay
16:25:50 <cmccann> arrrrrrrrgh fay does not understand type synonyms >:[
16:25:58 <shachaf> #define
16:26:15 <Dexter509> http://ideone.com/BnX3KB .. i think i've never spent so much time on this few lines ^^
16:26:23 <Dexter509> thanks for the help :)
16:27:02 <lolcathost> Are there any examples of how to use STM in code that reads from/writes to a database?
16:27:51 * cmccann doesn't think stm and db transactions are going to mix the way you'd wish for...
16:29:37 <lolcathost> Would it be feasible (at least in principle) to make a DBMS that uses STM instead of locks for transactions?
16:30:34 <cmccann> dbms do fancier things than that, I expect
16:33:29 <elliott> cmccann: there are STM-based object databases
16:33:53 <elliott> though you aren't going to use Haskell's "stm" library to do them of course
16:34:39 <cmccann> mostly I meant that the typical full rdbms that are used are more elaborate than just "locks"
16:34:48 <elliott> yeah
16:36:17 <applicative> Dexter, looks good http://ideone.com/4OMZnK
16:36:32 <Hafydd> > 'Y' : 'a' : 'y' : '!' : []
16:36:33 <lambdabot>   "Yay!"
16:36:40 <Dexter509> what is stm?
16:36:52 <Clint> @hackage STM
16:36:52 <lambdabot> http://hackage.haskell.org/package/STM
16:37:05 <Dexter509> 404 Not Found :\
16:37:11 <Clint> er
16:37:12 <Clint> @hackage stm
16:37:13 <lambdabot> http://hackage.haskell.org/package/stm
16:37:31 <applicative> http://hackage.haskell.org/package/stm
16:37:38 <applicative> hmm
16:37:39 <Dexter509> ah, ok
16:38:15 <bgamari> Dexter509, For the record, I think (>.>) is (>>>) from Control.Arrow
16:39:06 <cmccann> to be fair >.> is also an emoticon
16:39:10 <cmccann> an important trait in operators
16:39:17 <Dexter509> oh, ok - that part was already given ^^
16:40:01 <applicative> what is the lens version now?
16:40:28 <fryguybob> lolcathost: STM has its roots in taking what had already been done for databases into memory.
16:41:33 <Jello_Raptor> hmm,
16:41:35 <Jello_Raptor> damnit
16:41:38 * hackagebot clckwrks-plugin-media 0.3.0 - media plugin for clckwrks  http://hackage.haskell.org/package/clckwrks-plugin-media-0.3.0 (JeremyShaw)
16:41:52 <Jello_Raptor> now i want to write a haskell program that reads entirely like LOLspeak
16:42:02 <Dexter509> stm has a semaphore, so you could pretty much build everything out of it (even the fancier stuff really only need that at its core)
16:42:37 <cmccann> Jello_Raptor, cats are famously lazy creatures so it is appropriate in a way.
16:42:51 <applicative> Dexter509, For the record, I think (>.>) is (&) from Control.Lens
16:43:10 <Jello_Raptor> cmccann: come to think of it, so are programmers
16:43:18 <Dexter509> not >>>?
16:43:37 <edwardk> applicative: 3.7.0.2
16:43:59 <applicative> am  I wrong now?
16:44:05 * applicative preferred %
16:44:21 <edwardk> i kinda did too
16:44:48 <applicative> Dexter509: >>> is in Control.Arrow it's a bit more general
16:45:41 <Dexter509> but >.> has pretty clear semantics, how can that be further generalised?
16:46:13 <applicative> the Arrow type generalizes a -> b
16:46:14 <kqr> this is a longshot but i figured i'll ask here before i go to sleep. if you have two elements a and b, and a binary operation O defined between them that has the property of (a O b) O b = a, what is that property called?
16:46:22 <applicative> actually is it associated with Category?
16:46:38 * hackagebot clckwrks-plugin-ircbot 0.3.0 - ircbot plugin for clckwrks  http://hackage.haskell.org/package/clckwrks-plugin-ircbot-0.3.0 (JeremyShaw)
16:48:03 <applicative> kqr: http://en.wikipedia.org/wiki/Involution_(mathematics)
16:48:12 <acowley> kqr: You might call b involutive
16:48:18 <acowley> gah, beaten
16:48:22 <kqr> wow, you're amazing
16:48:33 <acowley> It's kind of different though, because your situation depends on the operation O
16:48:45 <kqr> oh right
16:48:55 <acowley> So, it's more like the partial application (O b) is an involution
16:49:05 <acowley> where I'm treating O as an infix operator
16:49:16 <kqr> yes
16:49:40 <kqr> i really didn't expect that good an answer on a random maths question from a programming language channel :D
16:49:40 <niteria> that's a 'xor' property :)
16:50:05 <kqr> niteria, that's pretty much how i saw it explained when i tried googling for it
16:50:09 <rwbarton> is that equation supposed to hold for all a and b?
16:50:17 <kqr> rwbarton, yes
16:51:38 * hackagebot clckwrks-theme-bootstrap 0.2.2 - simple bootstrap based template for clckwrks  http://hackage.haskell.org/package/clckwrks-theme-bootstrap-0.2.2 (JeremyShaw)
16:52:53 <niteria> (a -> b) -> b, if you put it this way
16:53:05 <niteria> I bet it has a name
16:53:34 <niteria> Pierce law?
16:54:00 <rwbarton> is O associative?
16:54:00 <beaky> what are some elegant haskell libraries?
16:54:04 <beaky> anything like the STL?
16:54:40 <aristid> niteria: no, that function does not correspond to any non-constructive logic, i think. consider a = Void
16:55:10 <hpc> @djinn (a -> b) -> b
16:55:10 <lambdabot> -- f cannot be realized.
16:55:17 <byorgey> Peirce's law is  ((a -> b) -> a) -> a
16:55:49 <hpc> aristid: (a -> b) -> b depends on where the foralls are, i think
16:56:04 * FireFly wonders what other O's there could be (and over which domains)
16:56:21 <FireFly> xor is the one that immediately springs to mind
16:56:21 <aristid> byorgey: i think it's hilarious how random it is when people use "ei" and when they use "ie" :P
16:56:40 <aristid> hpc: when not explicit, the foralls are on the outmost scope, i'd think:)
16:56:43 <byorgey> aristid: huh?
16:56:53 <byorgey> that is how you spell Peirce's law
16:57:00 <aristid> byorgey: no idea whether pierce or peirce is correct, but both are used apparently
16:57:11 <byorgey> or are you saying it's random that particular person's name was spelled ei ?
16:57:11 * cmccann thought the question was about forall a b. an isomorphism between "(a -> b) -> b)" and "a", not "(a -> b) -> b" alone
16:57:11 <niteria> they are 2 different people
16:57:12 <hpc> actually no, you are right
16:57:17 <niteria> my mistake
16:57:20 <hpc> forall a on the outside, obviously false
16:57:27 <hpc> forall a on the inside, you can't construct an a
16:57:37 * rwbarton has no idea where (->) came from at all
16:58:05 * monochrom knows
16:58:16 <aristid> it looks like an ancient animal
16:59:01 <mm_freak> shachaf: i feel a bit offended…  i've got lots of positive feedback for my arrow tutorial, particularly because my tutorial doesn't cover monads in disguise, but actual non-monadic arrows
17:00:04 <aristid> byorgey: well, i mean mostly that the way people use the letter combinations "ie" or "ei" when they write anything is somewhat random in english. not referring to which spelling is correct
17:00:15 <mm_freak> shachaf: in particular, no spacesuits or conveyor belts, but straight to the point
17:00:30 <byorgey> aristid: ok, fair enough =)
17:00:30 <niteria> ie is more common, I think
17:00:48 <beaky> how do I generate the fibonacci sequence in haskell
17:00:56 <beaky> in an infinite list
17:00:58 <FireFly> Are you a human bieng?
17:01:05 <mm_freak> beaky: start with a recursive definition
17:01:07 <aristid> byorgey: well it probably just seems normal to a native speaker :) i'm coming from a mostly-phonetic language
17:01:19 <mm_freak> beaky: fibs x y = …
17:01:42 <mm_freak> (yes, there are more elegant ways to express the sequence, but start with that one)
17:01:45 <byorgey> aristid: sure, I have no illusions that English makes any sense =)
17:02:11 <beaky> > map fst (iterate (\(a, b) -> (b, a + b)) (1, 1))
17:02:13 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
17:02:18 <beaky> I love the fibonacci sequence
17:02:27 <monochrom> wait, in fibs x y, what are x and y for?
17:03:02 <mm_freak> monochrom: the current two successive numbers
17:03:08 <mm_freak> fibs x y = x : …
17:03:08 <ion> The two previous numbers. fibs = (+) :-P
17:03:24 <monochrom> haha
17:03:42 <mm_freak> > fix (\r x y -> x : r y (x + y)) 0 1
17:03:42 <beaky> the fibonacci sequence is awesome
17:03:43 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
17:04:00 <FireFly> Oh hey, lambdabot's back
17:04:03 <beaky> is fib(0) 0?
17:04:03 <mm_freak> that's my favorite definition, because i think it's the cleanest one
17:04:10 <beaky> what does fix do
17:04:12 <mm_freak> > fix (\r x y -> x : r y (x + y)) 1 1
17:04:13 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
17:04:19 <mm_freak> if you insist =)
17:04:21 <niteria> :t fix
17:04:22 <lambdabot> (a -> a) -> a
17:04:32 <mm_freak> beaky: fix is anonymous recursion
17:04:35 <beaky> oh
17:04:36 <mm_freak> fix (\r -> x)
17:04:39 <beaky> it's like the y combinator?
17:04:44 <FireFly> > let fibs = 0:1:zipWith (+) fibs $ tail fibs in fibs
17:04:46 <lambdabot>   Couldn't match expected type `[a0]' with actual type `[b0] -> [c0]'
17:04:49 <mm_freak> in the expression 'x' the value 'r' represents the expression 'x'
17:04:59 <FireFly> > let fibs = 0:1:zipWith (+) fibs (tail fibs) in fibs
17:05:01 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
17:05:06 <mm_freak> beaky: it's a fixpoint combinator, an alternative to the Y combinator
17:05:09 <beaky> oh
17:05:17 <beaky> I don't understand combinators :(
17:05:30 <mm_freak> the Y combinator isn't well typed in haskell
17:05:37 <FireFly> a combinator is just a function
17:05:47 <glguy> > fix((1:).scanl(+)1)
17:05:48 <FireFly> the I combinator is id, the K combinator is const
17:05:48 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
17:05:52 <niteria> combinator is a bird
17:05:57 <mm_freak> beaky: there is a formal and an informal definition of "combinator", and they conflict
17:06:01 <mm_freak> but most people use the informal one
17:06:09 <mm_freak> which basically means "higher order function"
17:06:13 <beaky> ah
17:06:17 <beaky> what is the formal definition?
17:06:19 <beaky> some math-speak? :D
17:06:25 <mm_freak> the formal one is "function without free variables"
17:06:29 <beaky> ah
17:06:38 <beaky> easier than "monoid in the category of endofunctors" :D
17:06:44 <mm_freak> =)
17:06:48 <FireFly> Oh, that makes sense
17:07:07 <beaky> so it's a function that takes functions
17:07:16 <mm_freak> no, it's a function that is self-contained
17:07:18 <beaky> or is it a standalone function
17:07:19 <beaky> ah
17:07:24 <mm_freak> like const and id
17:07:36 <FireFly> It doesn't depend on anything outside of itself
17:07:38 <c_wraith> const 5 has a free variable, in contrast
17:07:43 <beaky> my mind is blown; how can a function exist without variables
17:07:49 <beaky> without accepting variables*
17:07:54 <mm_freak> without /free/ variables
17:07:56 <beaky> oh
17:07:57 <c_wraith> accepting variables is fine
17:08:00 <Mikicacarica> http://fcasroma.blogspot.com/
17:08:06 <c_wraith> It's that it can't close over anything
17:08:11 <beaky> so it can be defined without variables even though it can accept them
17:08:12 <mm_freak> a free variable is a value that comes from the environment
17:08:16 <beaky> like point-free style
17:08:19 <mm_freak> main = putStrLn "blah"
17:08:24 <mm_freak> putStrLn is a free variable
17:08:31 <mm_freak> const x y = x
17:08:33 <beaky> ah
17:08:36 <acowley> I think the intuition is that it combines its arguments, and nothing else
17:08:43 <mm_freak> both x and y are the opposite of free variables, 'bound' variables
17:09:03 <mm_freak> it's probably easier to understand in terms of lambdas
17:09:06 <c_wraith> however.. partially-applied const has an implicit free variable
17:09:14 <mm_freak> \a b -> c a b
17:09:19 <mm_freak> a and b are bound, c is free
17:09:28 <beaky> :t \a b -> c a b
17:09:30 <lambdabot>     The function `c' is applied to two arguments,
17:09:30 <lambdabot>     but its type `Expr' has none
17:09:30 <lambdabot>     In the expression: c a b
17:09:48 <mm_freak> beaky: the correct non-lambdabot error message is "not in scope: c" =)
17:09:55 <beaky> ah
17:10:10 <beaky> yeah that's what ghci says
17:10:13 <niteria> > sum [a, b, c]
17:10:15 <lambdabot>   0 + a + b + c
17:10:15 <c_wraith> yeah, the problem is that all single-letter names are in-scope in lambdabot :)
17:10:18 <mm_freak> const = \x -> \y -> x
17:10:27 <acowley> lambdabot is a namespace camper
17:10:33 <mm_freak> the variable x is bound in the outer (left) lambda, but free in the inner (right) one
17:10:36 <beaky> lambdabot is quirky :d
17:10:45 <mm_freak> that's why partially applied const has a free variable
17:10:52 <beaky> oh
17:11:14 <beaky> so a free variable is something that isn't contained in a function
17:11:32 <beaky> in \_ -> y, is y a free variable?
17:11:34 <mm_freak> that isn't bound by a function
17:11:36 <mm_freak> yes
17:11:39 <beaky> ah
17:11:59 <mm_freak> the terms come from lambda calculus, where you could regard "function" as equivalent to "lambda abstraction"
17:12:15 <beaky> so all functions that look like \_ is a combinator :D
17:12:24 <mm_freak> the opposite
17:12:34 <beaky> ah oops
17:12:37 <mm_freak> a combinator has /only/ bound variables
17:13:08 <mm_freak> as an exercise i invite you to find out whether 'forever' is a combinator =)
17:13:14 <beaky> :t forever
17:13:16 <lambdabot> Monad m => m a -> m b
17:13:29 <mm_freak> forever c = let cs = c >> cs in cs
17:13:31 <niteria> @src forever
17:13:31 <lambdabot> Source not found. My brain just exploded
17:13:46 <beaky> it is a combinator :D
17:13:47 <mm_freak> or a simpler, less efficient definition:  forever c = c >> forever c
17:13:47 <cmccann> of course, in combinatory logic, the point is moot because it has no way to describe variables at all
17:13:58 <mm_freak> beaky: are you sure?
17:14:06 <cmccann> which does ensure that there are no free variables anywhere
17:14:10 <beaky> I'm not sure :(
17:14:17 <mm_freak> beaky: name all the variables
17:14:34 <mm_freak> in the latter definition, the simpler one
17:14:36 <beaky> c (bound variable) and cs which I'm not sure is bound
17:14:38 <beaky> ah
17:14:42 <mm_freak> forever c = c >>= forever c
17:14:43 <mm_freak> uhm
17:14:45 <mm_freak> forever c = c >> forever c
17:14:59 <beaky> seems to be a combinator
17:15:00 <niteria> fun part is that you can do "lambda abstraction" with combinators
17:15:15 <mm_freak> beaky: don't be too fast
17:15:21 <mm_freak> name all variables
17:15:25 <mm_freak> hint: there are three of them
17:15:30 <beaky> c and forever
17:15:31 <hpc> four
17:15:34 <beaky> and the bitshift
17:15:39 <cmccann> mm_freak, "forever c = let cs = do { c; cs; } in cs"
17:15:40 <cmccann> problem solved!
17:15:41 <hpc> (>>) and the monad dictionary it comes from
17:15:59 <mm_freak> beaky: c, forever and (>>)
17:16:04 <mm_freak> (and that's not a bit shift)
17:16:07 <beaky> oh
17:16:09 <hpc> :t (>>)
17:16:11 <lambdabot> Monad m => m a -> m b -> m b
17:16:19 <mm_freak> beaky: is 'c' bound?
17:16:19 <hpc> mm_freak: you're forgetting (Monad m)
17:16:24 <mm_freak> hpc: no, i'm getting to it
17:16:39 * hackagebot alpha 1.0.8 - A compiler for the Alpha language  http://hackage.haskell.org/package/alpha-1.0.8 (MarcCoiffier)
17:16:40 <beaky> it is bound by forever
17:16:53 <mm_freak> beaky: what about (>>)?  that's a bit trickier
17:16:56 <hpc> ...oh dur
17:16:56 <simpson> [ 71%] ?name("eiskalt"): Filtering packages
17:17:00 <simpson> Derp, sorry.
17:17:08 <cmccann> m is bound, but of course Monad is not
17:17:12 <beaky> ah, well >> is free
17:17:12 <cmccann> if you're going there
17:17:30 <mm_freak> beaky: no, (>>) is bound as well, but implicitly through the Monad constraint
17:17:33 <hpc> cmccann: i don't think types count
17:17:37 <mm_freak> beaky: it comes as a hidden argument =)
17:17:42 <mm_freak> beaky: however, what about 'forever'?
17:17:51 <beaky> forever is bound
17:17:53 <beaky> to forever
17:18:04 <mm_freak> beaky: it's not
17:18:09 <mm_freak> 'forever' is free
17:18:09 <beaky> ah
17:18:25 <cmccann> hpc, why not? the implicit forall is there, binding the type variables.
17:19:01 <hpc> cmccann: \p t f -> if p then t else f is a combinator
17:19:12 <hpc> (once you desugar to case of)
17:19:20 <hpc> ...wait shit, True/False
17:19:23 <cmccann> haha
17:19:35 <cmccann> better use church bools there.
17:19:36 * hpc dies of embarassment
17:19:39 <hpc> yes
17:19:42 <mm_freak> beaky: this is an alternative definition:  forever c = fix (c >>)
17:19:43 <hpc> that's totally what i meant
17:19:47 <mm_freak> beaky: but now 'fix' is free
17:19:53 <beaky> right
17:20:01 <mm_freak> beaky: in fact you can't define it as a combinator in the formal sense
17:20:02 <hpc> :t forever fix c = fix (c >>)
17:20:03 <lambdabot> parse error on input `='
17:20:12 <hpc> :t let forever fix c = fix (c >>) in forever
17:20:13 <lambdabot> Monad m => ((m b -> m b) -> t) -> m a -> t
17:20:22 <mm_freak> hpc: that's not 'forever'…  it's a different function
17:20:24 <beaky> what is the meaning of >> ?
17:20:27 <hpc> i know
17:20:32 <mm_freak> beaky: read it as "and then"
17:20:42 <mm_freak> beaky: do a; b = a >> b
17:21:05 <beaky> ah so it evaluates functions from left to right
17:21:12 <mm_freak> main = do putStrLn "Press enter to continue."; getLine
17:21:17 <mm_freak> main = putStrLn "Press enter to continue." >> getLine
17:21:20 <mm_freak> not functions
17:21:25 <byorgey> beaky: no, it sequences monadic actions
17:21:42 <byorgey> beaky: "what is the meaning of >>" is a rather meaningless question, actually
17:21:49 <byorgey> beaky: a better question is "what is the type of >>"
17:21:53 <byorgey> and the answer is:
17:21:55 <byorgey> @type (>>)
17:21:57 <lambdabot> Monad m => m a -> m b -> m b
17:22:00 <rwbarton> "what is the meaning of +"
17:22:07 <beaky> + is just a symbol
17:22:13 <byorgey> so is >>
17:22:30 <beaky> I thought it meant bitshift-right :(
17:22:37 <byorgey> if fact, >> has a different meaning for each Monad instance
17:22:40 <byorgey> hehe, nope =)
17:22:46 <hpc> beaky: so what did you think forever did then? :P
17:22:56 <mm_freak> beaky: if it were, 'forever' as it is predefined would be hard to justify ;)
17:23:00 <beaky> I thought forever did an action forever
17:23:03 <acowley> A spontaneous monad tutorial breaks out in #haskell. No one is surprised.
17:23:04 <mm_freak> and would be illtyped =)
17:23:17 <hpc> beaky: and that semantics comes from bitshift how?
17:23:40 <acowley> hpc: Modern computers have a lot of bits
17:23:44 <mm_freak> beaky: that's what it denotes…  an action that is repeated forever
17:23:50 <hpc> bits bits sliiiidy bits!
17:23:53 <mm_freak> beaky: of course for some value of "forever"
17:23:58 <beaky> right, >> means many things in different languages. in C++ >> means to extract from a stream :D
17:24:00 <mm_freak> > forever Nothing
17:24:02 <lambdabot>   Nothing
17:24:10 <hpc> beaky: >> in C++ is still bitshift
17:24:21 <mm_freak> beaky: in C++ >> doesn't have a fixed meaning
17:24:23 <hpc> the stream classes override it
17:24:25 <beaky> oh
17:24:28 <niteria> > forever [1]
17:24:30 <lambdabot>   *Exception: stack overflow
17:26:33 <beaky> > forever $ x <- [0..] >> return x + 1
17:26:34 <lambdabot>   <hint>:1:1: Parse error in pattern: forever $ x
17:27:00 <beaky> > forever $ [0..] >>= \x -> return x + 1
17:27:02 <lambdabot>   No instance for (GHC.Num.Num [a0])
17:27:02 <lambdabot>    arising from a use of `GHC.Num.+'
17:27:02 <lambdabot>  Po...
17:28:09 <f> ?
17:28:18 <niteria> list monad is the weirdes of all
17:28:19 <Guest41490> ?
17:28:23 <niteria> weirdest
17:28:30 <beaky> > forever $ [0..] >>= \x -> return (x + 1)
17:28:32 <lambdabot>   *Exception: stack overflow
17:28:44 <beaky> > forever $ [0..10] >>= \x -> return (x + 1)
17:28:46 <lambdabot>   *Exception: stack overflow
17:28:50 <beaky> oops :(
17:29:04 <beaky> so the list is a monad
17:29:30 <mm_freak> [] is a monad
17:29:33 <beaky> looking at lists as monads is interesting
17:29:44 <beaky> that means strings are monads too :D
17:29:48 <mm_freak> niteria: what's weird about it?  it's basically just list comprehension
17:29:51 <Guest41490> [0..10] >>= \x -> return (x + 1)
17:30:02 <mm_freak> beaky: strings are monadic values…  a monad is a type constructor
17:30:31 <mm_freak> > do x <- [1,2,3]; y <- [-1, 1]; return (x + y)
17:30:33 <lambdabot>   [0,2,1,3,2,4]
17:30:40 <mm_freak> of course that's just
17:30:49 <mm_freak> > liftA2 (+) [1,2,3] [-1, 1]
17:30:50 <lambdabot>   [0,2,1,3,2,4]
17:31:01 <beaky> :t liftA2
17:31:02 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
17:31:15 <beaky> > liftM2 (+) [1,2,3] [-1, 1]
17:31:17 <lambdabot>   [0,2,1,3,2,4]
17:31:26 <beaky> what is the difference between liftM2 and liftA2?
17:31:29 <mm_freak> beaky: liftA* for lists is comparable to cartesian product
17:31:32 <beaky> ah
17:31:37 <niteria> mm_freak: I doesn't fit my monad metaphor of
17:31:43 <niteria> 'values with context'
17:31:50 <mm_freak> there is no difference…  it's just that liftA* has a more general type
17:31:54 <nexx> :t liftM2
17:31:55 <lambdabot> Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
17:32:06 <mm_freak> beaky: every Monad is an Applicative
17:32:18 <beaky> Applicatives are more general
17:32:21 <mm_freak> (however, as a historical artefact that's not enforced by the base library)
17:32:37 <mm_freak> niteria: that's because metaphors are wrong
17:33:48 <niteria> just looking at the monad laws, you can't get an idea how they're supposed to be used
17:34:09 <beaky> monads are just monoids
17:34:29 <beaky> and monoids are things you can associatively add together
17:34:33 <beaky> s/add/join/
17:35:47 <niteria> yeah, monoids in a category of endofunctors, I know what every word means, but that doesn't really tell me what a monad is
17:36:45 <niteria> and values with context metaphor holds even for cps monad
17:36:47 <acowley> The functors we mostly care about are endofunctors, monoids combine things, so monads combine the functors we care about. aka join.
17:37:25 <beaky> so if you strech the definition of joining things you can do lots of cool things with monads?
17:37:28 <beaky> stretch*
17:37:43 <dagnachew> guys what was the flags to put at the beginging of a file ?
17:38:07 <dagnachew> nm got it
17:38:13 <hpc> dagnachew: a german flag, then racing stripes through the rest of the code
17:38:17 <hpc> it'll run twice as fast
17:39:00 <niteria> that would be french flag
17:39:42 <beaky> lol
17:40:19 <beaky> besides the Monad abstraction, what other abstractions should a functional programmer know?
17:40:31 <niteria> Lens
17:40:47 <beaky> what's a lens? is it like a bitmask?
17:40:55 <simpson> Mu. I don't think you *should* know anything, in terms of abstractions, beyond the general idea of abstracting.
17:41:14 <beaky> ah
17:41:15 <rwbarton> @where typeclassopedia
17:41:15 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
17:41:17 <rwbarton> just read that
17:41:18 <edwardk> beaky http://stackoverflow.com/questions/5767129/lenses-fclabels-data-accessor-which-library-for-structure-access-and-mutatio/5769285#5769285
17:41:55 <beaky> Functors, Monads, Monoids, Arrows, Applicatives, Typeclasses... lots of abstractions :D
17:41:58 <edwardk> but typeclassopaedia is probably a good start. monads are a bit of a blunt instrument there are more refined types that often do the job and fit in places monads can't
17:42:44 <niteria> what about Traversables, Foldables
17:42:55 <niteria> biplates
17:43:04 <edwardk> Traversable is one of the best abstractions in haskell.
17:43:19 <edwardk> biplate is just a traversal
17:43:33 <edwardk> which fits into the whole lenses and traversals thing
17:43:57 <beaky> all those abstractions are just typeclasses too
17:44:19 <edwardk> beaky: not all of them. lenses and traversals are not typeclasses. Traversable is a typeclass
17:44:24 <beaky> ah
17:46:00 <niteria> are there laws for Traversables?
17:46:09 <roconnor> yes
17:46:17 <beaky> so whenever I'm using getters and setters, I am using a Lens?
17:46:36 <roconnor> beaky: probably
17:46:55 <edwardk> beaky: a lens is just a pair of a getter and corresponding setter packaged into a type you can compose.
17:47:05 <beaky> ah
17:47:09 <Eelis> is there a convenient way to generate lenses for all fields of a record?
17:47:17 <edwardk> beaky: imperative programmers don't think twice about saying foo.bar.baz += 10
17:47:28 <edwardk> beaky: lenses give you that in a functional _immutable_ setting
17:47:35 <edwardk> Eelis: makeLenses ''Foo
17:47:42 <Eelis> thanks, i'll have a look
17:47:49 <hpc> edwardk: at the price of having to think twice about it ;)
17:47:54 <beaky> lol
17:48:15 <edwardk> Eelis: that is a template haskell splice that will automatically generate lenses and traversals for all of the fields in a data type.
17:48:43 <Eelis> edwardk: yeah, reading about it now. looks good, thanks :)
17:49:19 <edwardk> Eelis: makeClassy goes one step farther, which is handy if you plan on stuffing that object in a larger object and want to get access to its fields in the parent too
17:49:46 <edwardk> Eelis: https://github.com/ekmett/lens/blob/master/examples/Turtle.hs uses that for example purposes
17:50:05 <Eelis> sneaky
17:50:12 <edwardk> i don't recommend naming your lenses 'x', 'y', 'r', g' and 'b' like in that code though ;)
17:50:17 <Eelis> :)
17:50:36 <edwardk> Eelis: i use this approach a lot when i have code i want to be able to run in a composite complex state.
17:51:05 <niteria> say you have a Tree a b = Leaf b | Node (Tree a b) a (Tree a b), you can only do one Functor instance, but you'd really like to have 2, is there a solution?
17:51:29 <edwardk> Eelis: e.g. if i have a compiler, i might have a state type or reader environment describing my warning configuration, and one for my localization settings, and another for the meta info of the package i'm compiling, etc.
17:52:16 <edwardk> i can mash all of those into a composite state, make a few HasWarningConfig HasLocalizationSettings, HasPackageInfo instances for it, that are just one liners, and spontaneously i can call any combinator that expects those HasFoo properties on the state and i can just use the lenses directly
17:53:34 <edwardk> in practice i find it drastically reduces the complexity of the compositions involved in my lens code
17:54:32 <Eelis> i have to admit i share hpc's concern though
17:54:46 <kniu> is "forall a. ... -> forall b. ..." always equivalent to "forall a b. ...", ignoring shadowing and whatnot?
17:55:09 <kniu> can a forall on the right of a function arrow always be "moved" to the left?
17:55:36 <hpc> kniu: since we are ignoring shadowing, yes
17:55:55 <hpc> and if we don't ignore shadowing, alpha renaming lets you ignore shadowing anyway ;)
17:56:42 <kniu> what about the converse? If the quantified variable does not appear to the left of an arrow, can that quantification be moved to the right?
17:56:50 <hpc> yes
17:56:51 <edwardk> niteria: make it a Bifunctor or make traversals for each parameters and use the lens combinators
17:57:12 <edwardk> say you have: Tree a b = Leaf b | Node (Tree a b) a (Tree a b)
17:57:28 <kniu> so, technically, a typechecker that returns "forall a. a -> forall b. b" instead of "forall a b. a -> b" isn't really wrong
17:57:46 <roconnor> niteria: the typical solution is to newtype wrap Tree
17:57:57 <roconnor> niteria: It's unfortunate
17:58:12 <hpc> kniu: it might make unification harder
17:58:19 <edwardk> leaves :: Traversal (Tree a b) (Tree a c) b c; leaves f (Leaf b) = Leaf <$> f b; leaves f (Node l a r) = Node <$> leaves f l <*> pure a <*> leaves f r
17:58:24 <hpc> but otherwise it's correct
17:58:32 <edwardk> niteria: then you can 'over leaves (+1) ...
17:58:33 <shachaf> mm_freak: Wait, which are you talking about?
17:58:48 <edwardk> niteria and you can similarly construct a traversal for the nodes
17:59:21 <kniu> ah yes, unification
17:59:52 <edwardk> nodes :: Traversal (Tree a c) (Tree b c) a b; nodes _ (Leaf c) = pure (Leaf c); nodes f (Node l a r) = Node <$> nodes f l <*> f a <*> nodes f r
18:00:37 <edwardk> over nodes (+1) (Node (Leaf "hello") 2 (Leaf "world"))
18:01:04 <shachaf> mm_freak: The only "arrow tutorial" I was taking an issue with specifically was the conveyor belt one, I think.
18:01:35 <brunonery> howdy! I'm trying to measure a monadic chain using timeItT - this returns 2.5 seconds, but Linux' time returns 4. Does ghc compiled programs have a big "warm up"?
18:02:32 <IzaakBloomberg> hello
18:02:35 <hpc> brunonery: or you aren't profiling the whole program
18:02:44 <edwardk> brunonery: not usually 1.5 seconds big. you might have a fair bit of code running outside of the timeItT block
18:02:44 <IzaakBloomberg> can i ask
18:02:53 <IzaakBloomberg> can i ask if i can ask question
18:02:58 <slack1256> you already did
18:03:03 <brunonery> I have two putStrLn and getArgs
18:03:03 <edwardk> IzaakBloomberg: don't ask to ask, ask.
18:03:05 <brunonery> nothing else
18:03:08 <slack1256> hello IzaakBloomberg
18:03:16 <IzaakBloomberg> edwardk ok, im asking then
18:03:19 <byorgey> edwardk: but IzaakBloomberg asked to ask to ask.
18:03:31 <edwardk> @hpaste
18:03:31 <lambdabot> Haskell pastebin: http://hpaste.org/
18:03:45 <IzaakBloomberg> question is:
18:03:46 <slack1256> but he already ask to ask to ask
18:03:55 <edwardk> if you need to paste code for what you want to ask about hpaste above is a good place to dump it =)
18:03:55 <byorgey> ask is such a funny word
18:04:00 <byorgey> especially when repeated a lot
18:04:03 <IzaakBloomberg> how to repeat world war two and holocaust?
18:04:22 <kniu> what makes (->) so special?
18:04:22 <byorgey> IzaakBloomberg: what does that have to do with the Haskell programming language?
18:04:31 <shachaf> > ask ask ask ask ask ask ask 5
18:04:33 <lambdabot>   5
18:04:34 <kniu> you can't do that quantifier move thing for other arbitrary type constructors
18:04:35 <IzaakBloomberg> !ops
18:04:37 --- mode: ChanServ set +o edwardk
18:04:43 <IzaakBloomberg> bye!
18:04:48 <slack1256> @type ask
18:04:49 <lambdabot> MonadReader r m => m r
18:04:53 --- kick: IzaakBloomberg was kicked by edwardk (Your behavior is not conducive to the desired environment.)
18:05:13 <slack1256> wow, trolling is getting lame by the day
18:05:53 <slack1256> oh lambdabot is up again! was it updated?
18:05:55 <kniu> and apparently my implementation of type unification can't handle these "mismatched" quantifiers
18:06:19 <cmccann> oh boy a 9000+ line file full of generated code
18:06:21 <cmccann> this bodes well
18:06:23 --- mode: edwardk set +b *!~IzaakBloo@*
18:06:41 --- mode: edwardk set -o edwardk
18:07:02 <kniu> :t \_ -> undefined
18:07:03 <lambdabot> t -> a
18:07:15 <c_wraith> kniu: with respect to quantification? (->) is special because it actually implies an operation.
18:07:22 <kniu> :t (\_ -> undefined) :: forall a. a -> forall b. b
18:07:23 <lambdabot> a -> b
18:07:36 <rwbarton> (->) e commutes with limits (including "forall a.") because it has a left adjoint (,) e
18:08:09 <kniu> :t ((\_ -> undefined) :: (forall a b. a -> b) -> forall c. c) ((\_ -> undefined) :: forall a. a -> forall b. b)
18:08:10 <lambdabot> c
18:08:34 <kniu> my brain is being fuddled
18:08:36 <rwbarton> though that is only the category-theory-level explanation, not the type-theory-level explanation
18:09:41 <Saizan> the type-theory-level explanation would be "flip is an isomorphism"
18:10:06 <rwbarton> well the mysterious bit is that x -> forall a. y is actually *the same* as forall a. x -> y (not just isomorphic)
18:10:10 <kniu> does this mean that if I want to implement Haskell (or some other System F like language) I'll have to implement a unification algorithm that handles quantifiers to the right of a function arrow?
18:10:30 <Saizan> rwbarton: that requires a ghc-level explanation :)
18:10:44 <rwbarton> well Haskell 2010 doesn't allow forall to the right of a function arrow, or anywhere except at the top level of a type
18:10:50 <byorgey> kniu: no
18:11:15 <kniu> then how the hell did what I just gave lambdabot typecheck
18:11:36 <kniu> there's some implementation-level weirdness going on here
18:11:57 <rwbarton> well, for starters, what ghc with whatever options lambdabot turns on implements is not the same as Haskell 2010
18:12:09 <Peaker> niteria, did you get an answer for your dual-functor?
18:12:24 <Saizan> and Haskell itself is quite more funky wrt foralls than System F is
18:12:39 <cmccann> clearly lambdabot uses Caleskell 2010
18:13:37 <Peaker> in Lamdu we have "explicit" foralls -- but we hide them at the UI level (application of a value whose type is a dependent Pi is collapsed/hidden by default, and definition whose parameters are dependent are hidden by default).  We do explicitly show the Pis in the type though, as sort of "explicit foralls"
18:14:03 <Peaker> not sure how easy that is at the learning curve level, but it's pretty nice to use on our toy examples :)
18:14:04 <Saizan> but if you want to implement something close to what ghc implements than yeah, you've to do some normalization on these foralls, i believe it's called hoisting in ghc's jargon
18:14:27 <shachaf> Peaker: If only I could run Lamdu so I could understand what you mean!
18:14:32 <roconnor> typeclasses give haskell a tiny peak into rank2 polymorphisms
18:14:32 <rwbarton> forall is not even a keyword in Haskell 2010 AFAIK
18:14:40 <Peaker> shachaf, are you on Windows?
18:14:45 <shachaf> Nope.
18:14:56 <shachaf> Still running Debian on that computer with the messed up OpenGL.
18:14:56 <Peaker> shachaf, do you not have OpenGL? I forget what issue you had
18:15:03 <Peaker> oh man, who hasn't OpenGL? :)
18:15:57 <shachaf> Yes, I was the one with no OpenGL.
18:16:04 <cmccann> every time I opengl I immediately want to closegl it and not mess with it again
18:16:08 <kniu> why does no one tell me these things in their hindley milner typechecker tutorials
18:16:43 <Saizan> kniu: a standard hindley-milner system doesn't have to deal with forall's at all
18:17:21 <acowley> What's wrong with OpenGL? It's so intuitive!
18:17:30 <Saizan> kniu: ghc is way beyond H-M when you turn on extensions
18:17:54 <cmccann> acowley, it seems a little overengineered as a way to display a black rectangle
18:18:08 <cmccann> supposedly it does other stuff but I'm skeptical
18:18:14 <rwbarton> cmccann, that is basically my experience as a user of opengl too :/
18:18:27 <acowley> But it is a *seriously* black rectangle. Think of the billions of transistors used to create that black rectangle!
18:18:39 <Peaker> cmccann, yeah, OpengL is insanely terrible
18:18:43 <acowley> It's am embarrassingly parallel black rectangle.
18:18:47 <cmccann> I'm sure if I spent more time working with opengl I'd start to understand it better and not be horrified
18:18:54 <cmccann> but it's not very approachable :T
18:19:02 <Peaker> cmccann, but I know of no other way to have real-time, high-speed, smooth portable graphics
18:19:12 <Peaker> cmccann, I use abstractions that give a non-terrible interface on top of OpenGL
18:19:13 <rwbarton> not portable enough, apparently
18:19:13 <c_wraith> There are also so many basically-incompatible versions of OpenGL these days
18:19:50 <Peaker> though now I'm making bindings for a GL fonts library that supposedly works on Windows, and it's making me do direct OpenGL (the horror!)
18:20:10 <applicative> Dexter509: what I said above about (&) was nonsense of course; it's flip ($)
18:20:44 <Peaker> rwbarton, :( not sure if cairo or other fallback backends can do nice smooth animations
18:20:51 <cmccann> one of these days I need to figure out the least painful way to make 3d pictures appear on a monitor
18:21:10 <cmccann> but for now I'm playing with HTML5 browser graphics/audio stuff which is pretty horrifying in its own right
18:21:13 <rwbarton> for me opengl apps "sort of" work
18:21:16 <Peaker> cmccann, I just need 2d images, I just need them to be drawn ~60 times per second, smoothly
18:21:34 <rwbarton> I wonder whether xmonad is partially at fault
18:22:11 <Peaker> rwbarton, try lamdu and tell me if it doesn't work?
18:22:16 <tromp> > 128*153
18:22:17 <c_wraith> Peaker: have you tried sdl?
18:22:18 <lambdabot>   19584
18:22:39 <Peaker> c_wraith, yeah, it's a PITA on OSX and does not do accelerated drawing, no smooth animations :(
18:26:40 * hackagebot iproute 1.2.9 - IP Routing Table  http://hackage.haskell.org/package/iproute-1.2.9 (KazuYamamoto)
18:28:04 <Peaker> shachaf, even basic programs like "glxgears"/etc don't work?
18:28:18 <shachaf> Peaker: Yes, it's an Nvidia Optimus thing.
18:28:38 <acowley> Linux, I take it
18:28:48 <shachaf> Sure.
18:29:15 <acowley> I don't understand why Nvidia hasn't done a better job supporting Optimus in Linux
18:29:20 <Peaker> Linux doesn't generally work at all with Optimus?
18:29:35 <shachaf> They have a thing called "bumblebee".
18:29:50 <shachaf> It's truly awful software. So bad that I uninstalled it even though it occasionally managed to work.
18:30:01 <shachaf> I'd rather have no OpenGL than run "bumblebee".
18:30:04 <sipa> works perfectly here
18:30:10 <simpson> nVidia could always sponsor PRIME if they wanted to, which is an open-source in-kernel Optimus effort.
18:30:18 <shachaf> Apparently nvidia is working on official support these days, or something.
18:30:50 <shachaf> sipa: I don't want programs like that on my computer. :-(
18:31:00 <sipa> how do you mean?
18:31:10 <shachaf> Anyway that's off-topic in here.
18:31:14 <sipa> oh
18:31:36 <acowley> shachaf: Phrase your displeasure using the language of type theory
18:31:57 <shachaf> Type theory is barely relevant to Haskell.
18:31:58 <monochrom> Nvidia -> Void
18:43:55 <rwbarton> Peaker: it's very slow, but seems to basically work
18:44:49 <Peaker> rwbarton, ah, so maybe software rendering?
18:44:57 <rwbarton> I suppose so
18:45:19 <rwbarton> I just have some kind of intel integrated graphics
18:45:26 <Peaker> bummer. I guess we'll eventually need to make fallbacks or focus on tablets or something :)
18:45:42 <Peaker> programming on tablets will be nice once there's little text input involved
18:46:18 <Peaker> (very type driven completions would mean you choose between very few options in most cases)
18:47:30 <Peaker> tablets reliably have OpenGL, I hope :)
18:58:41 <aristid> Peaker: OpenGL ES, sure
18:59:01 <Peaker> I'm not sure what the differences/restrictions are
18:59:11 <aristid> it got rid of all the legacy support
18:59:26 <sclv> ocharles: taking a look at yr. patch. looks good. i'm going to play with getGroupedDiff a bit more. Also I'm sure you meant toDI of Both to be B, not S ?
18:59:36 <aristid> but still you don't have the graphics power of a 150 watt desktop card, of course :)
18:59:57 <aristid> which should not matter for a structural code editor
19:01:44 <aristid> Peaker: i assume you'd be more interested in supporting android than iOS?
19:06:41 * hackagebot ghc-mod 1.11.3 - Happy Haskell programming on Emacs/Vim  http://hackage.haskell.org/package/ghc-mod-1.11.3 (KazuYamamoto)
19:07:21 <cmears> If you have a type class with a type family, and an instance of that class, can you tell from ghci how the type family is defined for that instance?
19:08:48 <byorgey> cmears: if you have ghc 7.6 you can use :kind! to "evaluate" type expressions
19:09:42 <cmears> byorgey: interesting, thanks
19:10:56 <bear2> how do you call typeclass function, method? or something else
19:11:14 <byorgey> method
19:11:59 <bear2> is there a way to create something method without creating a typeclass?  a function of sort that can accept more than one type
19:12:12 <bear2> something like a method*
19:12:21 <shachaf> > id 'a'
19:12:23 <lambdabot>   'a'
19:12:24 <shachaf> > id True
19:12:26 <lambdabot>   True
19:12:26 <shachaf> No type class!
19:13:03 <bear2> id is just a function that accepts a?
19:13:21 <shachaf> id will take a value of any type.
19:13:24 <shachaf> id :: a -> a
19:13:57 <bear2> that's not what I had in mind. I want something like a method that can be expanded by users but without creating a typeclass for it
19:15:07 <cmccann> why? that's sorta what typeclasses are for
19:16:19 <byorgey> bear2: no, that's not possible.
19:17:01 <byorgey> (like cmccann I am not sure why you would want that)
19:17:38 <shachaf> I'm not even sure what bear2 wants, let alone why. :-)
19:17:40 <bear2> for the similar reason you would use lambda instead of defining a function. it's more concise. if I have just one method it seems like unneecsary boilerplate to have to define a typeclass for it
19:18:40 <shachaf> bear2: What are you actually doing?
19:18:51 <shachaf> This sort of use of type classes will often make you unhappy later anyway.
19:19:04 <rwbarton> the boilerplate is like three words
19:19:06 <cmccann> if the boilerplate of typeclasses is burdensome you're probably using them wrong
19:19:13 <cmccann> as shachaf will happily tell you
19:19:40 <cmccann> shachaf once kicked a typeclass in the shins and then laughed at it. he doesn't like them much.
19:19:59 <shachaf> cmccann: I have no problem with *certain* type classes!
19:20:03 <bear2> rwbarton and the boilerplate of defining a function is how many words? so why have lambdas?
19:20:15 <rwbarton> how do you imagine this working exactly
19:20:22 <rwbarton> I don't think you've thought this through
19:20:31 <cmccann> shachaf, that reminds me, you would be horrified at the code I'm working on right now
19:20:34 <shachaf> bear2: It's the other way around -- lambdas are the fundamental building blocks, and "foo x = ..." is just syntax sugar for a lambda.
19:20:43 <shachaf> cmccann: I think that's an invariant.
19:20:45 <bear2> why would I have to think of a typeclass name, and have to repeat it every time I declare a method for some type, when all I want is one generic function/method ?
19:20:47 <cmccann> true.
19:21:12 <cmccann> shachaf, but this is unusually horrible.
19:21:12 <shachaf> bear2: What would the type of your function be?
19:22:07 <byorgey> you could do what bear2 wants if Haskell actually had support for branching on the type of an argument.
19:22:18 <byorgey> but there are very good reasons Haskell doesn't support that.
19:22:25 <monochrom> anonymous type class eh?
19:22:26 <cmccann> shachaf, right now I'm deliberately committing all kinds of "trying to be OOP" atrocities
19:22:30 <byorgey> namely, parametricity, and also parametricity.
19:22:33 <rwbarton> but how then would it be able to "be expanded by users"
19:22:34 <shachaf> Well, that's rather different from what a type class does.
19:22:42 <rwbarton> you need to know what you are expanding
19:22:52 <cmccann> in order to fake something like subtyping in some fay ffi bindings to the DOM
19:22:54 <byorgey> rwbarton: oh, true
19:23:00 <monochrom> if you pass around your own dictionary, you will never need to coin a name
19:23:02 <shachaf> For one, type classes aren't about arguments. You could just as easily want to "branch on the type of your result".
19:23:26 <byorgey> indeed. ignore me.
19:23:52 <dolio> You could branch on the type of the result, too.
19:24:12 <dolio> Or rather, byorgey should have said, 'branching on the type arguments.'
19:24:29 <cmccann> byorgey, yeah, what do you know about typeclasses, huh. did you ever even read the typeclassopedia? :O
19:24:49 <byorgey> oh, but the typeclassopedia isn't about type classes!
19:25:05 <cmccann> yes but that undermines my joke :T
19:25:07 <ivanm> is there a monad transformer class for PrimMonad?
19:25:08 <byorgey> hehe =)
19:25:09 <cmccann> sigh.
19:25:22 <ivanm> I've found 2 or 3 classes for ST, but not PrimMonad
19:25:48 <applicative_> what are the classes for ST, ivanm ?
19:26:04 <ivanm> applicative_: e.g. http://hackage.haskell.org/packages/archive/monad-st/0.2.1.1/doc/html/Control-Monad-ST-Class.html
19:26:29 <ivanm> that's the edwardk solution; there's also the stateful-mtl package
19:27:04 <zomg> cmccann: yeah trying to make clever use of types in ffi in fay can be a bit tricky sometimes
19:27:27 <cmccann> zomg, I've got a hilariously terrible hack I'm using currently
19:27:33 <cmccann> along with a boilerplate-o-matic program
19:27:39 <hrumph> hi
19:27:42 <cmccann> it's horrific on multiple levels
19:27:45 <zomg> Show me
19:27:46 <zomg> :D
19:27:54 <cmccann> the horror mitigated only by the caveat that it sorta works
19:28:16 <cmccann> heh not showing the code generator, it's too embarrassing
19:28:18 <hrumph> i'm trying import Prelude hiding (>>=) but it doesn't work
19:28:26 <byorgey> hrumph: hiding ((>>=))
19:28:32 <cmccann> but gonna upload the bindings on github or whatev when they're in slightly better shape
19:28:33 <elliott> cmccann: what are you generating code for
19:28:41 <cmccann> all the things
19:28:44 <cmccann> all of them
19:28:44 <elliott> help
19:28:44 <ivanm> hrumph: do I dare ask why you're not wanting to use >>= ?
19:28:50 <zomg> hehe
19:28:56 <byorgey> the first paretheses go around the list of stuff being hidden, the second is around the name of an operator
19:28:57 <hrumph> ivanm just a learning excercise
19:29:00 <applicative_> ivanm: I see monad-st is the same class, but the methods totally different.
19:29:11 <hrumph> i'm learning about monads so i'm just messing with the definitions
19:29:13 <monochrom> ((>>=)). two levels of parenthesizing
19:29:35 <zomg> This is probably my "worst" ffi function :P addEventListener :: (Event e, Foreign f) => f -> String -> (e -> Fay ()) -> Bool -> Fay ()
19:29:49 <shachaf> I thought Fay didn't have classes?
19:29:57 <monochrom> in general, hiding ((>>=), (+), (==))
19:30:02 <cmccann> so far I'm generating stuff for (almost) all of html5, plus some extra junk like the canvas api, websockets, svg dom, &c
19:30:12 <zomg> shachaf: I'm not sure if they do anything besides help ghc type checking, but at least it doesn't complain about them
19:30:20 <ivanm> applicative_: well, I was thinking of having something wrap over Vector, and the mutable stuff is all based upon PrimMonad, not just ST
19:30:38 <beaky> anyone know of a function that can scramble a list or array?
19:30:52 <beaky> @hoogle [a] -> [a]
19:30:53 <lambdabot> Prelude cycle :: [a] -> [a]
19:30:53 <lambdabot> Data.List cycle :: [a] -> [a]
19:30:53 <lambdabot> Prelude init :: [a] -> [a]
19:30:57 <cmccann> yes, I'm using typeclasses that do nothing for checking stuff, then relying on fay's inherent untypedness to make it all work on the ffi side
19:30:58 <monochrom> "reverse" scrambles a list
19:31:08 <cmccann> it's terrible but it works
19:31:10 <zomg> You can sort of use them to force certain things work in a slightly more type safe manner but I don't think it does anything on the JavaScript level
19:32:00 <zomg> For example since I use Event e I won't be able to give a function that takes the wrong kind of parameter as a handler
19:32:05 <cmccann> sadly a lot of the DOM duplicates member names outside the "real" hierarchy
19:32:06 <zomg> but it only complains when running it through ghc
19:32:14 <cmccann> so I have a stupid amount of one-function overload classes
19:32:27 <cmccann> which is why Html5.hs is 8000 lines long
19:32:41 <hrumph> it occurs to me if you use monads a lot it'll be the same as imperative programming
19:32:44 <hrumph> nothing gained
19:33:01 <ivanm> beaky: there's a list shuffle package on hackage IIRC
19:33:21 <simpson> hrumph: Depends on which monads you use.
19:33:25 <cmccann> zomg, oh and if it's not obvious I'm running a codegen I hacked together on IDL files from the w3c
19:33:34 <zomg> Oh
19:33:43 <cmccann> hence the huge volumes of code :D
19:33:54 <monochrom> if you lose imperative programming, you also gain nothing
19:33:55 <zomg> Yeah I think I saw a ticket for doing something like that so figured you might be doing something along those lines
19:34:02 <cmccann> yeah
19:34:09 <cmccann> someone asked about it then apparently nobody bothered?
19:34:16 <beaky> ah
19:34:21 <cmccann> but I didn't feel like writing lots of bindings by hand as I went
19:34:28 <cmccann> so figured I'd get as much as possible out of the way up front
19:34:35 <zomg> Dunno, I'm not pro enough to do all that :p
19:34:43 <cmccann> the current result is hideous but it's a start
19:34:45 <zomg> I just contributed XMLHttpRequest stuff to fay-dom
19:35:05 <cmccann> once it works at the proof of concept level I'll tidy up the codegen and figure out ways to make the resulting API nicer
19:35:29 <cmccann> some way to test that everything actually works would also be nice
19:35:42 <applicative_> ivanm: yes I see. Is it that you want something like instance (MonadTrans t, PrimMonad m, Monad (t m)) => PrimMonad (t m) where
19:35:42 <zomg> Despite not being pro enough at haskell stuff I'm sort of feeling like writing a bunch of articles on "haskell for web developers" =)
19:36:01 <cmccann> zomg, well if you want to try using the bindings I'm working on that'd be awesome
19:36:02 <latermuse> zomg: please do it
19:36:05 <zomg> As someone with a mostly web dev background I've talked with a lot of other web devs who seem quite interested in haskell but can't quite get around to learning it
19:36:07 <ivanm> applicative_: yeah, I'm not sure whether it's worth doing that or having it as an explicit typeclass
19:36:08 <cmccann> can't promise things will work immediately
19:36:13 <cmccann> since I'm still ironing bugs out of the codegen
19:36:45 <latermuse> zomg: I use haskell for web dev, and I feel like im mostly blumbering around in the dark with most things im doing
19:37:00 <zomg> yeah I have some ideas
19:37:07 <zomg> we'll see what comes of it
19:37:11 <latermuse> cool :)
19:37:20 <zomg> most likely it'll get bashed by haskell purists for all the mistakes in it
19:37:22 <zomg> lol
19:38:02 <cmccann> just don't write a monad tutorial and most haskell folks will be supportive I think
19:38:15 <hrumph> zomg: as an experiement i'm thinking of creating a small site with haskell
19:38:16 <latermuse> zomg: thats peer review ;)
19:38:31 <hrumph> its for profs registering exams at an educational institution
19:38:52 <latermuse> hrumph: im making a big site in haskell right now with no frameworks. Its not too difficult.
19:38:56 <hrumph> what should i use for the db back end?
19:39:18 <hrumph> i'll probably use one of the avaialble frameworks i think
19:39:33 <hrumph> if i do it
19:40:09 <hrumph> i like mysql at least i'm used to it
19:40:23 <hrumph> but i here that haskell has its own baked in solutions
19:40:41 <hrumph> that i can use as alternatives
19:41:04 <hamishmack> cmccann: Hi, are you working on this… https://github.com/faylang/fay/issues/162 or something similar?
19:41:20 <hpaste> applicative pasted “PrimMonad” at http://hpaste.org/79071
19:41:26 <cmccann> hamishmack, ...sort of?
19:41:36 <cmccann> I didn't see that until after I started hacking on this
19:41:40 <cmccann> but it's the same idea
19:41:52 <applicative_> ivanm: I can get this far ^^ but I take it 'internal' is impossible or am I blind
19:43:06 <hamishmack> cmccann: Cool.  Let me know if you need help with anything.
19:43:41 <ivanm> applicative_: heh, I was hoping there was an existing package with it ;-)
19:44:05 <cmccann> hamishmack, anything in particular you're hoping for?
19:44:27 <cmccann> I'm mostly generating some html5 stuff to play with at first
19:44:48 <cmccann> to see how well the api hackery I'm using holds up and whether the codegen has major bugs
19:44:52 <applicative_> ivanm, well I was figuring you could convince Roman L to add it if it makes sense?
19:45:47 <hamishmack> I'ld like it if the Fay API was portable to webkitgtk & ghcjs
19:46:28 <hamishmack> But not necesarily using the functions as they are now in the webkitgtk package
19:47:28 <hamishmack> The use of String for instance is a pain for GHCJS (the Text type is much faster in GHCJS)
19:47:31 <cmccann> right now I'm just boilerplating up ffi stuff based on w3c IDL files, not sure if it would carry over to those (not familiar with them)
19:48:07 <ivanm> applicative_: that's why I figured some kind of extra liftIO-like class would work better
19:48:15 <cmccann> maybe you'd be more interested in the codegen part once I clean it up a bit?
19:48:49 <hamishmack> I had trouble with the w3c IDL files so I used the webkit ones for the webkitgtk bindings
19:49:42 <cmccann> the w3c appears to have its own wonky idl variant that some things use
19:49:49 <cmccann> all the newer stuff mostly
19:50:14 <cmccann> whereas the older files are using more standard-ish idl?
19:50:25 <cmccann> dunno, I'm making this up as I go.
19:51:21 <cmccann> but right now my codegen can handle most stuff in the wonky html5-ish idl files
19:54:17 <hamishmack> The webkitgtk bindings I made are here... https://patch-tag.com/r/hamish/webkit/snapshot/current/content/pretty/Graphics/UI/Gtk/WebKit/DOM
19:54:22 <ivanm> applicative: my thinking is also that having a definition of internal is also necessary...
19:55:15 <ivanm> the primToPrim function also makes it look like having arbitrary monad stacks be an instance of PrimMonad might not be that great an idea
19:57:23 <hamishmack> cmccann: If you have time to check them out and suggest any changes let me know
19:57:56 <cmccann> hamishmack, prolly not... kinda busy these days and I mostly just wanted fay bindings for a bunch of html5 things
19:58:12 <cmccann> since my goal is to use fay, not generate ffi bindings for it :]
20:00:40 <ivanm> edwardk: out of curiousity, where you unaware of stateful-mtl when you wrote monad-st?
20:00:48 <ivanm> *were
20:01:49 <hamishmack> cmccann: No worries. If you do come up with a nicer DOM interface though, do share it :-)
20:01:59 <cmccann> I can't promise nicer yet
20:02:24 <cmccann> but more complete than https://github.com/faylang/fay-dom I can do
20:02:39 <edwardk> ivanm: yes
20:02:57 <ivanm> fair enough
20:03:25 <applicative> ivanm yes, this seems complicated. I'm not exactly seeing your use case though.
20:03:38 * applicative favors every use case for the vector package....
20:03:56 <ivanm> applicative: I want to be able to eventually stack transformers on top of mutable vectors
20:04:35 <ivanm> edwardk: as the mtl maintainer, would you happen to know if there is a PrimMonad equivalent to MonadIO?
20:06:18 <applicative> what is the difference between stateful-mtl and monad-st
20:07:24 <ivanm> applicative: the names
20:08:02 <applicative> class MonadST looks a lot like class MonadST
20:08:42 <applicative> I guess World is better than StateThread ; I'm going with monad-st
20:09:19 <edwardk> ivanm: no
20:09:42 <edwardk> i prefer monad-st =)
20:09:53 <ivanm> guess I need to write my own then
20:10:00 <ivanm> edwardk: I prefer stateful-mtl's documentation :p
20:10:12 <edwardk> feel free to patch =P
20:10:20 <ivanm> why not merge it into mtl?
20:10:25 <edwardk> github, fork, pukll req
20:11:02 <applicative> does mtl use those extensions.  I suppose it does.
20:11:09 <ivanm> well, I'm not going to be using either stateful-mtl or monad-st
20:11:14 <edwardk> put up a libraries proposal, but it'd be fundepped not tf'd
20:11:25 <cmccann> hamishmack, behold the output of my codegen in all its terrible glory: https://github.com/isomorphism/fay-bindings/tree/master/Fay/W3C
20:11:31 <edwardk> i'd be +1 most likely
20:11:42 <cmccann> note that there are some things missing or wrong because my codegen doesn't handle a few kinds of definition right now
20:12:14 <edwardk> i think it comes down to the fact that ST requires rank-2 types
20:12:23 <edwardk> and currently the mtl has nothing that uses rank-2
20:12:29 <ivanm> edwardk: oh, right, I forgot about TF/FD, though I think TF makes more sense for this
20:12:33 <edwardk> so its a portability change
20:12:41 <edwardk> TF may make more sense but it won't go in MTL
20:12:42 * ivanm also needs to get his Data.Tree proposals sorted and submitted
20:12:44 <cmccann> zomg, if you're still around, check out the link :D
20:12:52 <applicative> monad-st  uses  {-# LANGUAGE TypeFamilies, FlexibleInstances, UndecidableInstances #-}
20:13:12 <edwardk> applicative: yes, but it can change to MPTCs and FDs pretty easily
20:13:15 <ivanm> applicative: yeah, but the latter two are only for the automatic instances
20:13:43 <ivanm> if it was in transformers or mtl, presumably explicit instances would be used
20:13:50 <edwardk> also if it was mtl it'd probably be a harder sell to keep the (t m) instance
20:13:57 <applicative> edwardk: yeah i see, and mtl uses UndecidableInstances of course
20:14:09 <edwardk> ivanm: even so you don't shrink 's' so you still need undecidable
20:14:15 <ivanm> ahhh, right
20:14:22 <ivanm> now for the fun part: what do I call my primmonad-based class? :p
20:14:25 <edwardk> which is fine, mtl does that everywhere
20:14:36 <applicative> MonadPrim
20:14:36 <edwardk> Ivan m =>
20:14:44 <ivanm> edwardk: *groan*
20:15:12 <ivanm> applicative: the naming convention would actually make it MonadPrimMonad :p
20:15:14 <applicative> PrimMonad m, MonadPrim m =>
20:15:24 <applicative> ah there you are
20:15:53 <ivanm> applicative: actually, that constraint doesn't make any sense
20:16:18 <ivanm> since if a monad is an instance of both, then it'd just be either ST or IO
20:16:21 <applicative> ivanm: yeah I know.  But i havent figured out Ivan m => yet
20:16:28 <ivanm> applicative: consider my nick...
20:16:38 <applicative> ha, that I got
20:17:09 <johnw> does anyone have example code handy that uses vector-space?
20:18:08 <fryguybob> johnw: diagrams?
20:18:18 <johnw> any code would help
20:18:44 <johnw> i think i have a perfect use case for vector-space, based on watching Dan Piponi's presentation, but the Haddock documentation alone gives me no idea of how to even start
20:18:46 <applicative> oh I was goingto say its all over diagrams
20:18:53 <johnw> ok, i'll check diagrams
20:21:14 <applicative> johnw this even uses Control.Lens hiding (ala)
20:21:15 <applicative> http://hackage.haskell.org/packages/archive/force-layout/0.2/doc/html/src/Physics-ForceLayout.html
20:23:37 <applicative> johnw: what presentation of D.  Piponi do you mean?
20:23:56 <elliott> whenever you write "import Control.Lens hiding" edwardk cries
20:24:14 <edwardk> hah
20:24:21 <edwardk> i presume the ala hiding was pre 3.7
20:24:50 <shachaf> import Control.Lens hiding (ala)? :-(
20:24:55 <edwardk> yeah
20:25:07 <hamishmack> cmccann: Nice.  Hopefully we can spit out something compatible to wrap WebKitGTK's DOM functions (or if someone does https://github.com/faylang/fay/issues/161 then we could use that instead)
20:25:14 <elliott> imports Control.Newtype hiding (ala) too
20:25:24 <edwardk> now that our ala matches newtype he could save the import
20:25:46 <cmccann> hamishmack, this is mostly "proof of concept" level junk right now, as I use the bindings I'll be cleaning up the codegen a bit and polishing it
20:25:54 <shachaf> Before that he could've done ala _endo, i guess.
20:26:02 <cmccann> once it's in better shape I'll toss that on github as well
20:26:08 <edwardk> i think byorgey has something against ala, must be a christian thing ;)
20:26:23 <elliott> edwardk: well they hide newtype's ala too
20:26:32 <elliott> oh
20:26:35 <elliott> no, they just import newtype's ala
20:26:51 <johnw> applicative: i don't remember where I downloaded it from
20:27:00 <edwardk> clearly there is only one way to check: export it calling it god, or yahweh and see if he hides it.
20:27:37 <cmccann> clearly edwardk's next library will name all its functions after various deities
20:27:41 <applicative> import Control.Lens hiding (yahweh)
20:28:03 <applicative> somehow I think the tetragrammaton is uppercase
20:28:06 <edwardk> do not take my packages in vain. you shall have no other lens libraries before me.
20:28:36 <shachaf> What about data-lens?
20:28:50 <johnw> elliott: do you have a simple sample program that uses vector spaces?
20:29:09 <edwardk> i guess 'murder bad' belongs among the lens laws somewhere, too.
20:29:11 <johnw> your blog post (if you are Conal Elliott) doesn't actually make use of vector space, it seems to just talk about defining them...
20:29:14 <edwardk> shachaf: think old testament
20:29:20 <elliott> conal's nick is conal :)
20:29:24 <johnw> ah
20:29:39 <johnw> i didn't think there were that many elliotts with 2 ls and 2ts!
20:29:39 <Nereid> @ty over (wrapping Endo)
20:29:41 <lambdabot> (Endo a -> Endo a) -> (a -> a) -> a -> a
20:29:43 <elliott> /nick elliott_NOTCONAL
20:29:44 <Nereid> ah excellent
20:30:22 <Nereid> @ty wrapping Endo
20:30:24 <lambdabot> (Functor f, Isomorphic k) => k (Endo a -> f (Endo a)) ((a -> a) -> f (a -> a))
20:30:45 <shachaf> edwardk: Do lens, lens-family and $X form a holy trifecta?
20:31:05 <cmccann> we need to put elliott in a newtype wrapper
20:31:12 <cmccann> to distinguish things more clearly
20:35:36 <liyang> We had an intern called Elliott a few years ago; he's at GS now.
20:36:40 <liyang> He was here when Conal visited. They didn't annihilate each other.
20:38:30 <ivanm> applicative: http://hub.darcs.net/ivanm/monad-prim
20:38:43 <ivanm> it compiles; haven't actually tried using it yet though :p
20:38:55 <liyang> ivanm: good enough.
20:39:08 <copumpkin> liyang: I'm sure they would have annihilated each other had they been spelled differently
20:39:16 <applicative> liftPM :: (PrimMonad pm, StatePrim m ~ PrimState pm) => pm a -> m a
20:39:21 <copumpkin> since elliotts are quite particular about the number of Ls and Ts involved
20:39:40 <shachaf> copumpkin: Fortunately, eliots are not.
20:40:43 <ivanm> applicative: is there a better way of doing that?
20:41:14 <applicative> no, I was marvelling at the symmetry
20:44:22 <applicative> so now you will do something like liftPM . unsafeFreeze or ...  I need some documentation
20:47:57 <ivanm> applicative: this is intended to be able to do something like: liftPM $ new 5 :: (MonadPrim m, StatePrim m ~ s) => m (MVector s a)
20:48:26 <ivanm> so that you can create a new mutable vector with say a WriterT (ST s) stack
20:49:28 <applicative> where m might be WriterT String IO
20:49:42 <ivanm> yeah
20:49:43 <applicative> funny
20:49:57 <ivanm> why funny?
20:50:14 <applicative> nothing, I was just writing the same example WriterT
21:00:25 <beaky> hello
21:00:57 * Clint nods.
21:03:50 <lispy> happy+alex is a really nice combo
21:04:04 <lispy> just say'n
21:04:18 <johnw> can I see what you created with them?
21:05:32 <lispy> johnw: If you're talking to me, I'm doing something for work so I would need to get permission first
21:06:00 <lispy> johnw: I have a bunch of logs from program I'm running and I'm extracting timing information
21:07:38 <johnw> ah, i'm curious to see what your parser looks like
21:07:52 <johnw> compared to what I would have written with parsec
21:09:06 <shachaf> Well, you can find other alex+happy parsers, presumably.
21:09:23 <johnw> yeah, but i have a feeling lispy and I are on a similar wavelength
21:09:24 <simpson> GHC uses Alex and Happy, doesn't it?
21:09:31 <shachaf> simpson: Yep.
21:10:05 <shachaf> Someone should propose --# for one-line pragmas.
21:10:20 <johnw> i think you just did
21:10:59 <Nereid> except --# is an operator name
21:11:20 <Nereid> maybe -- #
21:11:21 <Nereid> ?
21:11:59 <johnw> how about an editor that just inserts the right thing if you type --#<tab>
21:12:13 <Nereid> why <tab>?
21:12:14 <shachaf> I don't really like -- # because it's not consistent with {-#
21:12:17 <shachaf> But maybe that breaks less.
21:12:20 <Nereid> shachaf: I know.
21:12:34 <Nereid> no one uses --# as an operator either
21:12:38 <johnw> Nereid: <tab> is my "snippet expander" key, use whatever works for you
21:12:46 <shachaf> Yes, but breaking compatibility is a bigger deal.
21:12:50 <lispy> johnw: I'm not a huge fan of parsec to be honest. I find it's hard to get your parser correct because 'try' must be used explicitly, it's on the slower side (but that's not really an issue), it's hard to reason about the grammar implemented by a parsec parser (unlike BNF based parser generators)
21:12:55 <shachaf> Now your file isn't H98 unless you enable an extension.
21:13:00 <shachaf> Which you have to do with a pragma!
21:13:04 <terminate1> I am not allowed to install the Haskell platform on the computer I'm working with
21:13:07 <shachaf> {-# LANGUAGE SanePragmas #-}
21:13:13 <terminate1> Is there any alternative
21:13:20 <terminate1> which do you recommend
21:13:28 <terminate1> Portable interpreter maybe?
21:13:33 <lispy> terminate1: all you really need to install is ghc (can be installed in your homedir), and then install cabal-install.
21:13:38 <johnw> terminate1: not even in your home directory?
21:13:47 <shachaf> What's "Portable interpreter"?
21:13:50 <terminate1> I'm not at home currently =)
21:13:50 <shachaf> If that's Hugs, then no.
21:14:03 <terminate1> Hmm, something which can be run in a usb stick
21:14:12 <terminate1> I mean just like eclipse
21:14:16 <shachaf> GHC is fine.
21:14:21 <terminate1> Where you don't have to install
21:14:23 <terminate1> Ah I see
21:21:43 <ajdiaz> hola
21:22:03 <dan_> hello haskell people
21:22:13 <johnw> hi haskell person
21:22:54 <cmccann> oh btw, hey shachaf
21:23:03 <cmccann> look on my works and despair: https://github.com/isomorphism/fay-bindings/blob/master/Fay/W3C/Html5.hs
21:23:33 <ajdiaz> manana voy a examen de haskell :'(
21:23:38 <dan_> I'm looking at haskell for the first time. on... the internet. pretty neat.
21:24:01 <shachaf> I don't like that file, cmccann. :-(
21:24:06 <lispy> dan_: tryhaskell.org?
21:24:12 <dan_> yes
21:24:16 <cmccann> ahahahaha
21:24:24 <cmccann> shachaf, horrifying, innit
21:24:34 <cmccann> and it just keeps on going
21:24:37 <cmccann> and going
21:25:09 <Nereid> please tell me you didn't write it all by hand
21:25:16 <shachaf> I hope you wrote it all by hand.
21:25:23 <shachaf> That's what you deserve.
21:25:23 <cmccann> hell no
21:25:28 <hn> hello
21:25:33 <Nereid> haha
21:25:40 <cmccann> that's the output of the thrice-nested code generator abomination I was talking about the other day!
21:25:42 <hn> hola alejandro
21:25:49 <ajdiaz> q peod perra
21:26:50 <cmccann> but hey, it lets me simulate subtyping well enough for GHC to check that things are correct
21:27:11 <cmccann> which should be helpful when dealing with the DOM in JS bindings
21:27:18 <cmccann> but still
21:27:22 <cmccann> just
21:27:24 <cmccann> look at it D:
21:27:33 * cmccann dies a little inside
21:28:33 <lispy> cmccann: how long does it take to compile that and how big is the resulting .js?
21:28:49 <cmccann> forever and huge
21:28:52 <cmccann> respectively
21:29:02 * lispy thought he was evil for making a Map Doc Doc (required instances for Eq/Ord for Doc)
21:29:18 <cmccann> it doesn't help that there are other files besides that one
21:29:23 <cmccann> it's just the largest
21:29:53 <cmccann> the CSS and SVG stuff is pretty massive as well I think
21:30:27 <cmccann> after I polish the codegen a bit I need to look into splitting it into smaller files
21:30:35 <cmccann> no need to import everything every time
21:31:28 <cmccann> there are also some significant things missing right now :T
21:31:31 <cmccann> but it's a start
21:36:44 * hackagebot Allure 0.4.6.5 - Near-future roguelike game in very early and active development  http://hackage.haskell.org/package/Allure-0.4.6.5 (MikolajKonarski)
21:37:18 <b__> I find it interesting that for `wrap a b c = a ++ c ++ b` it's not possible to write a short point free version
21:37:55 <Nereid> @pl wrap a b c = a ++ c ++ b
21:37:56 <lambdabot> wrap = (. flip (++)) . (.) . (++)
21:38:00 <Nereid> @pl wrap a b c = (a ++ c) ++ b
21:38:00 <lambdabot> wrap = flip . ((++) .) . (++)
21:38:10 <b__> best that I can come up with is wrap a b = (a ++) . (++ b)
21:38:22 <b__> which isn't really much better than the original
21:38:32 <shachaf> Names aren't the devil, b__.
21:38:36 <b__> I know
21:38:39 <shachaf> You can use them.
21:38:45 <Nereid> readability > point-free-ness
21:38:50 <shachaf> If you really hate them, Haskell isn't the language for you. Try #concatenative. :-)
21:38:51 <Nereid> pointlessness
21:38:51 <b__> I agree
21:39:31 <cmccann> "pleased to meet you, won't you guess my name?"
21:39:37 <cmccann> ergo guessing names = the devil
21:39:40 <cmccann> mystery solved.
21:39:56 <terminate1> I was downloading the Haskell interpreter, came across 2 different file extensions
21:39:59 <terminate1> tar.bz2 and .exe
21:40:06 <terminate1> what's the difference between them
21:40:28 <shachaf> I bet there's some explanation next to those file names.
21:40:29 <cmccann> one's a bzipped tarball and the other isn't?
21:40:46 <Nereid> ghc is not an interpreter. one is a source archive; the other is an installer
21:40:51 <joevar> I'm thinking of teaching my 12 y/o cousin haskell as a 1st lang. Is this a bad decision?
21:40:56 <terminate1> Hmm
21:41:07 <cmccann> if you don't know what the extension .tar.bz2 is you don't want that one
21:41:17 <terminate1> haha
21:41:19 <terminate1> ok
21:41:41 <stepkut> joevar: not at all. One moment.
21:43:12 <stepkut> joevar: cdsmith did an Haskell as a first language for kids class and blogged about it.. but the blog seems to be offline for me at the moment. the link is, http://cdsmith.wordpress.com/2011/08/03/haskell-for-kids-introduction/
21:43:29 <Nereid> google has it cached
21:43:40 <stepkut> joevar: many people have hypothesized that Haskell is, in fact, easier to learn if you have not been exposed to other languages
21:43:48 <joevar> stepkut, thanks. I'm just worried I might demotivate her away.
21:43:58 <Nereid> just don't start with monads ;)
21:44:22 <cmccann> joevar, definitely check out those blog posts
21:44:24 <joevar> She has the interest, so that's a big plus.
21:44:36 <cmccann> and maybe steal some ideas from them
21:44:53 <joevar> Okay, I'll read it.
21:44:54 <stepkut> oh.. it did eventually load for me
21:45:26 <stepkut> his class was for 12 to 13 year olds.. and I am sure he would be happy to answer any questions you have if you email him
21:45:32 <lispy> joevar: I think it's a great idea. I learned Visual Basic 3.0 as a first language, and it di-di-din't hurt me none.
21:45:55 <lispy> joevar: (my point is actually, that it doesn't really matter what you teach someone, they can learn more later)
21:46:35 <cmccann> one nice thing about haskell is that purity and laziness make a lot of simple stuff actually simple instead of deceptively non-simple
21:46:44 * hackagebot Elm 0.6.0.1 - The Elm language module.  http://hackage.haskell.org/package/Elm-0.6.0.1 (EvanCzaplicki)
21:47:35 <stepkut> joevar: one thing I like about cdsmith's approach is that it focused on making visible changes happen.. things appear on the screen.. that is cool! implementing some math function.. not so cool.
21:47:46 <cmccann> for a kid not going into it with expectations about how programming works and not being impatient about getting to some notion of practical use, that's potentially a huge bonus
21:48:14 <cmccann> coupled with direct feedback--like with cdsmith's approach--I can see it being a great learning language
21:48:40 <stepkut> joevar: i'm putting together an arduino class for people who have no programming or electronics experience at all.. and that is a big part of my goal for the first class.. give them the ability to make something move, make something light up, make something make noise
21:48:46 <joevar> I actually started teaching her C, but the syntax seemed bothered her. Then, I showed her the equ. in haskell and python. She liked the haskell ones.
21:48:47 <cmccann> just don't be afraid to simplify things by skipping parts of the language. for a beginner you want to teach programming before teaching a specific language
21:48:51 <stepkut> IMO, that makes it really feel like you have actually done something
21:48:59 <hpaste> gnuvince pasted “Solution to Euler 31” at http://hpaste.org/79072
21:49:21 <joevar> stepkut, she wants to do robotics. I suggested that we could do a arduino project.
21:49:50 <gnuvince> Can anyone help me understand why this program (http://hpaste.org/79072) is about 10x slower than the equivalent OCaml program and allocates ~3.8 GB of memory?
21:49:51 <joevar> I'm trying to put together a Arduino to haskell via serial commanding program.
21:50:02 <stepkut> joevar: ooo. I am actually working on that at the moment. I am currently (as in right this minute) looking up parts
21:50:43 <stepkut> joevar: my plan is to make a little rover that at the low-level is controlled by an arduino, but is coupled to a raspberry pi that can run Haskell code
21:51:24 <stepkut> joevar: also.. a year ago, I wrote this message, http://www.haskell.org/pipermail/haskell-cafe/2011-September/095650.html
21:51:29 <stepkut> just.. been a busy year ;)
21:52:03 <stepkut> but.. I have also learned a lot in the meantime that is relevant to that project
21:52:06 <joevar> stepkut, awesome. Also, here's my arduino code if you're interested. https://github.com/joevar/asc .
21:52:41 <stepkut> neat
21:53:12 <stepkut> my current plan is to try to combine this, http://www.seeedstudio.com/depot/romeoall-in-one-controller-p-1060.html and this, http://www.jameco.com/webapp/wcs/stores/servlet/Product_10001_10001_2114520_-1
21:55:12 <joevar> stepkut, that's pretty much what I'm going for.
21:56:11 <latermuse> Could you guys make a tutorial about how to hook up a raspberry pi that runs haskell to an arduino to make it do stuff?
21:56:33 <cmccann> stepkut, oh btw, you're a web framework guy of some sort, right?
21:56:43 <cmccann> (sorry, I can't keep irc nicks straight sometimes)
21:56:44 <ivanm> is there any way to have as a constraint "the value (KeyType c) must be either Int or a newtype of Int" ?
21:56:59 <ivanm> (to let me avoid having two classes :p)
21:58:17 <Nereid> sounds like you'd need a typeclass!
21:58:29 <stepkut> cmccann: yes, the maintainer of happstack.com and clckwrks.com
21:58:30 <Nereid> or maybe more generally say "KeyType c must be isomorphic to Int"
21:58:51 <Nereid> hmm
21:58:56 <cmccann> stepkut, dunno if you were around earlier but I've started working autogenerating a huge pile of ffi bindings for fay
21:58:59 <Nereid> that may or may not help.
21:59:02 <stepkut> happstack even runs on the raspberry pi :p
21:59:17 <stepkut> cmccann: nice, that would be swell
21:59:21 <cmccann> I mostly want to play with shiny html5 toys but it'd be nice to make something useful for other people too :P
21:59:34 <cmccann> cf. https://github.com/isomorphism/fay-bindings/tree/master/Fay/W3C
21:59:48 <cmccann> for the current (not completely working) state of the generated code
22:00:02 <stepkut> neat
22:00:22 <stepkut> cmccann: did you talk about this in #fay at all?
22:00:30 <cmccann> haha, no
22:00:35 <cmccann> didn't even realize there was a channel for it
22:00:39 <cmccann> guess I should have figured :P
22:00:43 <stepkut> cmccann: :)
22:00:47 <cmccann> this was just a weekend hack
22:00:55 <cmccann> because I wanted to play with html5 stuff
22:00:57 <stepkut> cmccann: it's a good place to be.. a bunch of core fay developers hang out there
22:01:09 <stepkut> cmccann: I think they would love to hear about it
22:01:29 <cmccann> I'll try to remember to lurk in there for the near future
22:01:35 <cmccann> while I'm hacking on this stuff
22:01:46 <stepkut> cmccann: yeah.. I am pretty excited about fay/ghcjs/etc
22:02:29 <cmccann> anyway, I'm generating stuff using the w3c's IDL files
22:02:39 <cmccann> of which there are quite a lot
22:03:09 <cmccann> if there's anything in particular you'd find useful I can add it to the files I'm using to test with
22:03:16 <terminate1> Any rule of thumb for Haskell indentation rules?
22:03:23 <terminate1> I keep getting indentation errors
22:03:25 <stepkut> cmccann: not sure if you saw it, but I blogged about fay recently, http://happstack.com/clck/view-page-slug/15/happstack-fay-acid-state-shared-datatypes-are-awesome
22:03:26 <cmccann> terminate1, use spaces. line things up.
22:03:32 <terminate1> hmm
22:03:34 <terminate1> Line things as in
22:03:48 <Nereid> terminate1: never use tabs
22:03:57 <cmccann> terminate1, read the source for the Prelude and emulate that.
22:04:00 <cmccann> can't go too wrong that way
22:04:01 <terminate1> hmm ok
22:04:06 <stepkut> cmccann: I have an upcoming project where I want to use fay + canvas, so I'll get back to you then
22:04:16 <cmccann> canvas is in there already
22:04:18 <stepkut> cmccann: I'm trying to make a 'room escape game'
22:04:20 <terminate1> Source for the prelude?
22:04:30 <cmccann> as is svg and whatnot
22:04:41 <stepkut> cmccann: right. I'm saying, I'll be more likely to have feedback on that when I actually try to use it
22:04:54 <cmccann> I plan to experiment with in-browser games so anything useful there I'll probably add anyway :P
22:05:02 <cmccann> ok.
22:05:17 <ivanm> is there any way to have as a constraint "the value (KeyType c) must be either Int or a newtype of Int" ?
22:05:19 <ivanm> (to let me avoid having two classes :p)
22:05:29 <cmccann> it's kinda messy right now but the naming conventions I'm using should stay consistent unless someone has a much better idea
22:05:51 <cmccann> and I'm faking subtypes like crazy so a lot of JS stuff should translate easily-ish
22:09:51 <lispy> ivanm: Were you able to get the benchmarks to your advisor?
22:09:58 <lispy> ivanm: using criterion, even?
22:10:14 <ivanm> I sent them to him
22:10:19 <ivanm> he hasn't gotten back to me yet :s
22:10:22 <lispy> heh
22:10:31 <lispy> ivanm: any lessons learned?
22:10:52 <lispy> Or even, would you use haskell for this if you had to do it over?
22:11:20 <ivanm> well, I'm starting to write a library to let me abstract between Map, IntMap, Vector and MVector as a backend
22:12:06 <lispy> hmm
22:12:09 <ivanm> and thus using MVector would hopefully get me closer to performance
22:12:14 <lispy> Oh I see. You mean, as ways to store a graph?
22:12:33 <ivanm> yup
22:13:02 <lispy> Most haskell code can reach pretty deep when it comes time to optimize
22:13:15 <lispy> So even if your current code is slow you could probably tune it a lot
22:13:35 <cmccann> stepkut, anyway I'm heading out for now, but feel free to bother me (here or on github) if there's anything you'd like to see in the bindings as I work on them
22:13:54 <stepkut> cmccann: sure!
22:13:56 <lispy> I've yet to have good luck using mutable structures for speed in Haskell.
22:14:04 <cmccann> I'd like to get this polished enough that it's something anybody could pick up and use
22:14:28 <lispy> ivanm: So, I'm skeptical that MVector will be good because it's mutable, but Vectors are fast so there is certainl yhope.
22:14:31 <cmccann> so that the whole DOM is easily available in typed form for haskell web hackery
22:14:44 <cmccann> it's much nicer than using JS directly, as you well know :D
22:14:55 <lispy> ivanm: anyway, glad to hear you got the bugs worked out.
22:14:58 * lispy heads home
22:15:04 <ivanm> lispy: well, the problem with using Vector is that it's O(n) for updates
22:15:16 <XexonixXexillion> lispy: I've had very good results with mutable unboxed vectors
22:15:19 <ivanm> and the C version was so fast IIUC because it used vectors
22:15:45 <lispy> ivanm: yeah, your problem is unlike things I've optimized. So maybe you'll have better luck than me.
22:16:26 <lispy> XexonixXexillion: cool. I think the two mutable things I've used with subpar results, IORefs and MArray
22:16:46 <lispy> in the MArray case it was faster to use a function that behaved like a lookup table
22:16:55 <lispy> But it was pure and computed the result on the fly
22:17:13 * lispy really leaves for home
22:17:18 <ivanm> heh, cya
22:23:11 <hrumph> in the Monad class is the function
22:23:24 <hrumph> m >> k = m >>= \_ -> k automatically defined by the class?
22:24:30 <hrumph> i mean if i create a monad instance is that going to be the default definition for >> ?
22:25:11 <hrumph> supposing i don't want to go off the map and produce side effects and stuff
22:25:29 <mikeplus64> hrumph: yeah
22:26:16 <mikeplus64> http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/GHC-Base.html#%3E%3E hrumph: scroll down to "Monad"
22:27:38 <hrumph> ok i see it
22:28:22 <hrumph> how come the main documentation page doesn;t mention that its the default
22:28:59 <hrumph> this is my second night of learning haskell
22:29:12 <hrumph> so i woulddn't have known where to see the code
22:29:31 <hrumph> someone said it was the default definition on web page i read
22:30:40 <mikeplus64> @hoogle Monad
22:30:41 <lambdabot> Prelude class Monad m
22:30:41 <lambdabot> Control.Monad class Monad m
22:30:41 <lambdabot> Control.Monad.Instances class Monad m
22:30:57 <mikeplus64> lambdabot ought to have links to the hackage docs
22:32:52 <mikeplus64> hrumph: on haskell.org/hoogle i searched "Monad", clicked the first result, then clicked "source" next to the thing for >>
22:36:49 <Nereid> hrumph: it also says "Minimal complete definition: >>= and return."
22:37:05 <Nereid> which means defining >>= and return is enough to get a complete Monad instance
22:41:31 <jeltsch> Does the current cabal-install (0.14.0) work with GHC 7.6.1?
22:42:20 <jeltsch> I already edited cabal-install.cabal to increase the version ranges for Cabal and unix dependencies.
22:42:35 <shachaf> You shouldn't need to editor cabal-install.cabal
22:42:47 <shachaf> The binary should work fine, but if the source isn't compiling, just get a more recent cabal-install.
22:42:53 <elliott> that's not the current cabal-install
22:42:58 <shachaf> Don't mess with the .cabal unless "you know what you're doing".
22:43:02 <elliott> it's up to 1.16.0.2
22:43:03 <jeltsch> elliott: Which one is the current one?
22:43:07 <shachaf> Oh, er, yes. That's not the current version.
22:43:15 <shachaf> @hackage cabal-install -- right here. ;-)
22:43:15 <lambdabot> http://hackage.haskell.org/package/cabal-install -- right here. ;-)
22:43:17 <elliott> your version is from April
22:43:20 <shachaf> s/;/:/
22:43:21 <shachaf> Ugh.
22:44:23 <jeltsch> shachaf, elliott: See http://www.haskell.org/cabal/download.html.
22:44:39 <shachaf> Cabal is not cabal-install
22:44:44 <shachaf> Oh, hmm.
22:44:51 <shachaf> I guess that ought to be updated?
22:45:04 <shachaf> dcoutts: ☝?
22:45:06 <jeltsch> I relied on this, of course, since this is the *official* page for cabal and cabal install, I thought
22:45:20 <elliott> well, you relied wrong :P
22:46:16 <jeltsch> Okay, I will get a current cabal-install.
22:46:18 <applicative> jeltsch: If you want to install the new one with your old one you can just do cabal install cabal-install-1.16.0.2  or however it goes
22:46:20 <jeltsch> Thank you guys.
22:46:46 <jeltsch> applicative: I now, but I have no old one. I’m bootstrapping, since I installed a fresh GHC.
22:47:12 <applicative> ah
22:47:25 <mrxy> I am writing a binary tree for fun and practice.  can I do something like this?  fromList = foldl' (somethingClever insert) Empty. fromList accepts association list, and insert accepts k v instead of (k, v)
22:47:26 <jeltsch> Once I have the cabal-install binary, I will install it again with, well, cabal-install, and then remove the bootstrapping one.
22:47:36 <elliott> You don't need to do that.
22:47:37 <mrxy> I tried to play with uncurry but that didn't do it
22:47:40 <elliott> The two binaries will be identical.
22:47:58 <elliott> (In fact it doesn't even matter what you use to compile cabal-install; it doesn't have to be the GHC you're actually using.)
22:48:47 <mrxy> or if that wasn't clear, can I rewrite this without a lambda?  fromList = foldl' (\acc (k, v) -> insert k v acc) Empty
22:48:48 <jeltsch> elliott: I know. But it seems cleaner to me. And, well, it could make a difference, because installing cabal-install again with cabal-install could result in different options (e.g., for optimization).
22:49:08 <elliott> You can set the options used with bootstrap.sh.
22:49:11 <jeltsch> At least, I *know* that I get a conistent state.
22:49:28 <Nereid> @pl \acc (k, v) -> insert k v ac
22:49:28 <lambdabot> const (uncurry (flip flip ac . insert))
22:49:29 <shachaf> @type curry
22:49:31 <lambdabot> ((a, b) -> c) -> a -> b -> c
22:49:33 <Nereid> @pl \acc (k, v) -> insert k v acc
22:49:33 <lambdabot> (`ap` snd) . (. fst) . flip (flip . insert)
22:49:34 <jeltsch> elliott: Too complicated. If i just reinstall it (easy), I get the right options (default ones) automatically.
22:49:38 <Nereid> bleh
22:49:48 <elliott> I think you vastly overrate the consistency and reliability cabal-install provides.
22:49:52 * elliott would trust bootstrap.sh more.
22:50:34 <Nereid> :t flip (uncurry ?insert)
22:50:35 <lambdabot> (?insert::a -> b1 -> b -> c) => b -> (a, b1) -> c
22:50:43 * jeltsch thinks that cabal-install should be at least as good as bootstrap.sh.
22:51:13 <Nereid> @unpl flip (uncurry insert)
22:51:14 <lambdabot> (\ b c -> uncurry insert c b)
22:51:33 <Nereid> oh, unpl doesn't know about uncurry but pl does?
22:51:52 * elliott thinks that jeltsch must never have used cabal-install
22:52:04 <mrxy> insert is my function.  insert :: Ord k => k -> v -> Tree k v -> Tree k v
22:52:04 <jeltsch> :-D
22:52:11 <jeltsch> Believe me, I have used it.
22:52:29 <jeltsch> But maybe not in such advanced ways that would reveal its deficiencies. :-)
22:52:36 <Nereid> :t flip (uncurry (?insert :: k -> v -> t k v -> t k v))
22:52:38 <lambdabot>     Unbound implicit parameter (?insert::k -> v -> t1 k v -> t1 k v)
22:52:38 <lambdabot>       arising from a use of implicit parameter `?insert'
22:52:38 <lambdabot>     In the first argument of `uncurry', namely
22:52:45 <Nereid> eh
22:53:04 <mrxy> oh that worked
22:53:06 <mrxy> nice
22:53:29 <mrxy> of course, I used foldl
22:53:50 <mrxy> so I have to flip the arguments
22:54:00 <mrxy> awesome!
22:55:39 <mrxy> lambdabot wasn't very clever there by the way.  <lambdabot> (`ap` snd) . (. fst) . flip (flip . insert)     :)
22:56:12 <lispy> sections are a nice way to avoid flip
22:56:39 <Nereid> but you can't section an expression
22:57:48 <lispy> true
23:00:40 <mrxy> why can't you fetch a returned function with `it' ?
23:00:46 <mrxy> in ghci
23:01:27 <Nereid> what is a "returned function"?
23:01:29 <mrxy> because of "Not an instance of Show I guess"
23:01:45 <Nereid> yes, it didn't even bother to compute it because it couldn't show it.
23:02:08 <Nereid> @ty foldl (.) id . map (uncurry ?insert)
23:02:10 <lambdabot> (?insert::a -> b1 -> b -> b) => [(a, b1)] -> b -> b
23:02:54 <mrxy> that always bothered me a bit, functions not being part of Show typeclass
23:03:15 <lispy> mrxy: what would the instance look like?
23:03:16 <Nereid> oh that can be fused,
23:03:17 <Nereid> @ty foldr ((.) . uncurry ?insert) id
23:03:18 <lambdabot> (?insert::a1 -> b -> a -> a) => [(a1, b)] -> a -> a
23:03:27 <lispy> mrxy: would it have to be compiler generated?
23:03:27 <mrxy> lispy function declaration
23:03:36 <mrxy> lispy probably
23:03:58 <elliott> function declaration would violate parametricity
23:04:03 <lispy> mrxy: Seems like you could only do that for some functons
23:04:09 <mrxy> lispy why?
23:04:19 <Nereid> you can't write a nontrivial Show instance for functions without losing referential transparency.
23:04:26 <Nereid> or something.
23:04:37 <mrxy> it could be part of ghci
23:04:38 <lispy> mrxy: what should, show (+ 1), print?
23:04:43 <mrxy> I don't care hot it's implemented
23:04:53 <mrxy> lispy :t (+ 1)
23:05:17 <lispy> mrxy: Oh, you want to print the type?
23:05:22 <lispy> > (+ 1)
23:05:24 <lambdabot>   No instance for (GHC.Show.Show (a0 -> a0))
23:05:24 <lambdabot>    arising from a use of `M50384...
23:05:27 <mrxy> yes. instead of error
23:05:33 <Nereid> > typeOf (+ 1)
23:05:35 <lambdabot>   Integer -> Integer
23:05:36 <lispy> IIRC, lambdabot had an instance like that for a while
23:05:48 <Nereid> doesn't work with polymorphic functions though
23:05:55 <Nereid> (for good reasons)
23:06:04 <edwardk> mrxy: what should it show for id?
23:06:11 <lispy> > typeOf when
23:06:13 <lambdabot>   Ambiguous type variable `m0' in the constraints:
23:06:13 <lambdabot>    (GHC.Base.Monad m0)
23:06:13 <lambdabot>    ...
23:06:16 <Nereid> > typeOf id
23:06:18 <lambdabot>   Ambiguous type variable `a0' in the constraint:
23:06:18 <lambdabot>    (Data.Typeable.Internal....
23:06:20 <mrxy> edwardk :t id
23:06:46 * hackagebot word8 0.0.3 - Word8 library  http://hackage.haskell.org/package/word8-0.0.3 (KazuYamamoto)
23:07:00 <edwardk> mrxy: the trick is that to do so you need overlapping instances, and generally unsound support from the compiler that break other features we value more
23:07:08 <mrxy> that would be nicer than being grabbed by an error message, especially for newcomers
23:07:48 <edwardk> mrxy: an instance of Show is supposed to give you text you can put back in and get what you shows. I can't do that for functions, and a type isn't the body of the function.
23:08:22 <mrxy> never said it had to be implementable by user. ghci could make it work doing whatever it needs to do
23:08:44 <frontendloader> my haskell installation seems to be missing the local documentation, is there a way to fix it? http://www.haskell.org/pipermail/glasgow-haskell-users/2012-February/021780.html Trying this right now
23:08:49 <applicative> instance Show ((->) a b) where show f = "<Function>"
23:09:10 <edwardk> applicative: i'd rather have the error =P
23:09:19 <Nereid> me too
23:09:29 <applicative> yes
23:09:31 <mrxy> edwardk oh I get what you mean
23:09:44 <applicative> frontendloader: you mean the documentation for ghc and the base libraries?
23:09:54 <mrxy> edwardk I think that's just a convention? ie a type can implement Show but not Read
23:10:01 <frontendloader> the haddock documentation
23:10:05 <edwardk> mrxy: my issue is that nothing you do for Show can meet the 'rules' for Show.
23:10:24 <edwardk> mrxy: a handful of crap instances of Show are out there. That doesn't mean you should continue this trend
23:10:28 <applicative> frontendloader: you should also adjust the ~/.cabal/config file so that it haddocks anything else you install
23:10:42 <Nereid> may I ask, what are the "rules" for Show?
23:10:48 <applicative> frontendloader: the ghc documentation is probably buried somewhere
23:10:55 <frontendloader> thanks for that, I was wondering how to prevent it in the future
23:11:33 <edwardk> some people tend to glom onto show in inappropriate ways because it makes their live easier for five minutes, e.g. parsec errors come to mind. then they have to deal with the fact that they can no longer pretty print data structures that contain those types at all.
23:11:40 <applicative> frontendloader: unfortunately, it should be done before you install stuff with cabal install, since the new haddocks will want to link to the old ones, which wont be there
23:11:50 <edwardk> so if you go to do any debugging on those libraries, its just a mess
23:12:06 <frontendloader> well
23:12:23 <frontendloader> I'm probably going to wipe this install anyway to bring it from 7.4 to 7.6
23:13:03 <ivanm> Nereid: read . show == id would probably be the main expectation
23:13:47 <Nereid> > let x = (repeat (), 1) :: ([()],Int) in (snd x, snd (read . show $ x))
23:13:49 <lambdabot>   Ambiguous type variable `a0' in the constraint:
23:13:49 <lambdabot>    (GHC.Read.Read a0) arisi...
23:13:53 <Nereid> doh
23:14:07 <Nereid> > let x = (repeat (), 1) :: ([()],Int) in (snd x, snd (read . show $ x)) :: (Int,Int)
23:14:09 <lambdabot>   Ambiguous type variable `a0' in the constraint:
23:14:09 <lambdabot>    (GHC.Read.Read a0) arisi...
23:14:13 <Nereid> forget it
23:14:18 <mrxy> but Show doesn't requrie Read or vice versa. so tht's just a convention
23:14:19 <edwardk> Nereid: infinite structures are not included ;)
23:14:22 <Nereid> ;)
23:14:39 <edwardk> mrxy: neither are required. but i don't need to be able to Read to want to paste code into an editor
23:14:56 <Nereid> > fst (read . show $ ((),repeat ()) :: ((),[()]))
23:15:00 <lambdabot>   mueval-core: Time limit exceeded
23:15:03 <Nereid> aw.
23:15:08 <Nereid> > fst (read . show $ ((),[]) :: ((),[()]))
23:15:11 <lambdabot>   ()
23:15:14 <Nereid> read is to strict!
23:15:15 <Nereid> too
23:17:13 <edwardk> mrxy: anyways the issue remains that you can't make a proper instance of Show. and there are several approximations, none of which is better than all others for all situations you might apply to functions. you might try to enumerate its values for all inputs if the domain is enumerable. you might show <function> you might try to do some horrible un-hoas conversion of a sufficiently tricky syntax tree representation
23:17:42 <edwardk> there isn't one choice that is universally better than all others. therefore it is best to leave the instance off and allow the developer to choose to implement such if they want it
23:17:53 <applicative> frontendloader: you might be able to find the ghc -related haddocks by doing something like 'locate Control-Monad.html'
23:18:42 <edwardk> instances should really almost always only be written when there is only one right way to do something.
23:18:57 <edwardk> in the case of a Show (a -> b) this isn't the case
23:18:58 <mrxy> edwardk it was my understanding that it can't be implemented by the user? since functions taking different arguments have different types
23:19:36 <edwardk> mrxy: the instance you want where you magically show the type? it has a number of theoretical issues but i suppose in the end oleg kiselyov's polytypeable hack would work
23:20:04 <edwardk> otoh, when someone else wants to show all the inputs into a function and their outputs for something like quickcheck, that instance would conflict with your desired behavior
23:20:16 <edwardk> and their needs and desires would be just as valid as yours
23:20:27 <elliott> well you can do the Typeable thing
23:20:28 <edwardk> there isn't one choice here that fits all needs
23:20:30 <elliott> wrt showing the type
23:20:45 <edwardk> elliott: Typeable works if the type is fully monomorphic. Polytypeable works even when its not
23:20:50 <elliott> oh, right
23:20:51 <edwardk> but its a horrible unportable hack
23:21:05 <elliott> I think Hugs could Show function types
23:21:13 <elliott> things you learn when porting edwardk packages to hugs
23:21:19 <edwardk> heh
23:21:35 <edwardk> coming soon: lens-hugs
23:21:48 <elliott> just replace the type families with unsafeCoerce
23:21:50 <elliott> worked the first time
23:22:24 <sopvop> the horror
23:23:06 <mrxy> edwardk is there only one right way to print int?
23:23:26 <sopvop> There is only one obvious way
23:23:45 <sopvop> guido style
23:23:48 <mrxy> no reason not to provide a reasonable default just because someone else may want to print it in a different way.
23:24:43 <elliott> the main problem is that Show has something like 3-4 meanings.
23:24:48 <elliott> hence any set of instances will be a compromise.
23:26:26 <edwardk> mrxy: i do not find your default to be reasonable. It isn't portable, so no other haskell compiler would standardize on it. It isn't easy. Heck the <function> show instance is easy, but its also not informative. the error message gives you the type involved if you want it, in fact it does better than the instance would, because it can figure out all sorts of helpful hints for you
23:27:00 <edwardk> the error messages is scary, but the alternative is a loss of functionality _that is already in use_
23:28:00 <edwardk> build a time machine and go back to 1990 or so and you could sell the world on this solution, but the time when that could be done is gone
23:28:57 <applicative> instance Show ((->) a b) where show f = "You just asked me to show a function; that doesn't make sense"
23:29:19 <edwardk> applicative: i'd still rather have the type error. that way i can see the signature involved and some suggestions about how i screwed up =P
23:29:25 <elliott> instance Show (a -> b) where show = unsafeCoerce  -- edwardk-style
23:29:30 <edwardk> elliott: =P
23:30:13 <elliott> Prelude Unsafe.Coerce> unsafeCoerce id :: String
23:30:14 <elliott> ""
23:30:14 <elliott> Prelude Unsafe.Coerce> unsafeCoerce fst :: String
23:30:14 <elliott> ""
23:30:17 <elliott> not a very good show
23:30:22 <edwardk> sheesh you let 2-3 little unsafe coerces out into the world in "SafeHaskell" code and nobody lets you live it down ;)
23:31:28 <Hafydd> > unsafeCoerce "" :: Int -> Int
23:31:30 <lambdabot>   Not in scope: `unsafeCoerce'
23:32:19 <mrxy> edwardk what helpful hints can you figure out from typing a function name in ghci that you can't by typing :t function ?
23:33:07 <edwardk> >>> const
23:33:07 <edwardk> <interactive>:3:1: No instance for (Show (a0 -> b0 -> a0))
23:33:35 <mrxy> besides the type declaration I see nothing useful
23:33:37 <edwardk> that tells you the information you want to know. so why do i want to break my ability to get useful diagnostics out of QuickCheck?
23:34:08 <mrxy> I see noise and I have to track down the type declaration to get something useful
23:34:23 <edwardk> not only that it isn't obvious to a compiler writer _how_ to make such an "instance"
23:34:25 * elliott doesn't think any argument will convince mrxy that a Show instance for functions is a bad idea.
23:34:27 <neutrino> that'll come with practice mrxy
23:34:33 <edwardk> i think i have better things to do
23:34:55 <neutrino> you're just being stubborn ;)
23:34:56 <applicative> (unsafeCoerce "" :: Int -> Int) 5 turns out to be Bus error, who'd have thought?
23:35:08 * sopvop is going to start complaining about people complaining about cabal
23:35:14 <mrxy> elliott well, haskell is the only language with a repl I used that isn't capable of printing functions instead of throwing an error
23:35:14 <neutrino> applicative: long or short bus?
23:35:34 <elliott> I'm sure Haskell has lots of other unique properties among the languages you know too, since it's almost certainly very different to them
23:35:42 <neutrino> how do you print afunction in the python repl
23:35:46 <mrxy> this property isn't very desirable
23:35:53 <mrxy> neutrino you just type the function
23:35:58 <neutrino> and what happens
23:36:00 <osfameron> mrxy: that does annoy me.  but given closures and currying, it's probably harder to do than it seems at first sight
23:36:09 <applicative> just like + ? mrxy
23:36:11 <elliott> edwardk has offered many reasons your proposed solution is worse than the problem.
23:36:19 <neutrino> because i've been using python for years and haven't seen python "print a function"
23:36:25 <sopvop> print(foo)
23:36:26 <sopvop> <function foo at 0xfebcf8>
23:36:26 <mrxy> neutrino function name is printed. clojure does the same. as does sbcl. and ruby. and ..
23:36:35 <sopvop> very helpful
23:36:39 <osfameron> some javascript implementations will print the code
23:36:40 <neutrino> yes sopvop, that's exactly what i mean
23:36:50 <edwardk> mrxy: what is the 'name' of 'const 2' ?
23:36:59 <osfameron> edwardk: anon?
23:37:06 <edwardk> mrxy: or (\x y -> x) 2
23:37:16 <edwardk> and why should these be distinguishable to the end user?
23:37:30 <neutrino> mrxy: there are absolutely never any situations when you lose track of the "function name" when developing haskell code
23:37:39 <edwardk> by making them distinguishable to the end user you weaken parametricity. parametricity is a very very powerful guarantee, and that is a crap reason to give it up
23:37:48 <neutrino> mrxy: python can afford to keep track of "function names" because functions don't change and don't get created
23:37:51 <mrxy> edwardk it doesn't have a name. but I sid it should print :t <function>, not the function's name
23:38:24 <neutrino> in haskell, everything is a function, and functions get created all the time, and it's not obvious at all how to assign one function to one of the previous functions that came together to create it
23:38:35 <edwardk> mrxy: i happen to disagree. why should 'const' behave differently than its definition? I just lost equational reasoning to satisfy your whim
23:39:10 <sopvop> can you show lens? :)
23:39:15 <edwardk> map f . map g = map (f . g); map id = id. i use reasoning tools like this all the time
23:39:21 <fmap> not everything is a function
23:39:26 * applicative has seen lens
23:39:27 <mrxy> what does that even mean, const would behave differently than it's definition?
23:39:52 <edwardk> mrxy: i mean that in one setting you want me to print the name of the function 'const' in the other you want me to print <function>
23:40:05 <neutrino> mrxy: what edwardk means is that if you type const 2 into ghci right now you get 2. you don't get a function name.
23:40:28 <mrxy> neutrino no if I type const 2 into ghci I get error
23:40:37 <edwardk> neutrino: you get a function, not 2
23:40:37 <sopvop> neutrino: you get No instance for (Show (b0 -> a0))
23:40:50 <neutrino> right, i meant const 2 x
23:40:51 <ivanm> neutrino: you do?
23:40:52 <neutrino> for some x
23:40:54 <edwardk> and more information that mrxy's magic show would provide
23:40:59 <mrxy> edwardk I want to print whatever :t <function>. prints.
23:41:03 <ivanm> I get a `No instance for (Show (b0 -> a0))' error
23:41:09 * neutrino ERROR
23:41:22 <mrxy> the only reason :t exists is because haskell is not capable of printing it's functions
23:41:22 <edwardk> didn't i have better things to do? oh yeah i did
23:41:25 <startling> neutrino: you've seriously never seen repr(someFunction), someFunction.__name__ and someFunction.__code__?
23:41:41 <neutrino> startling: of course ih ave
23:41:49 <mrxy> (well ignoring :t <object>)
23:42:02 <neutrino> startling: but __code__ doesn't get printed out when you "type a function into the repl"
23:42:09 <edwardk> mrxy: i think that is an incredibly shallow view of why :t exists.
23:42:28 <applicative> in the repl python says >>> print(str) is <type 'str'>  ; I guess meaning that's what it returns?
23:42:43 <startling> neutrino: sorry, just reading the scrollback. repr(function) does, though
23:42:55 <startling> anyway, this is just a Show instance.
23:42:59 <mrxy> applicative yes. I have never used a language with a repl that throws an error because a function is return. not very welcoming for a newbie
23:43:03 <neutrino> no, in python a type is a constructor, like a higher-level class maybe
23:43:16 <mrxy> returned*
23:43:21 <applicative> ah
23:43:24 <neutrino> mrxy: you've never used a language that does a lot of things haskell does
23:43:30 <neutrino> mrxy: if you want python, just use python
23:43:32 <elliott> edwardk: I think mrxy just doesn't realise :t foo prints "foo" as well as the type.
23:43:38 * applicative is with neutrino
23:43:44 <edwardk> elliott: there is that
23:43:47 <neutrino> mrxy: if you want haskell, use haskell, and get over its quirks
23:43:53 <mrxy> neutrino haskell does a lot of great things. throwing an error when a function is returned is not one of them
23:44:00 <neutrino> there are some, but not as many as in python once you get to know it
23:44:05 <neutrino> sure
23:44:09 <neutrino> python does a lot of great things
23:44:14 <neutrino> having no threading is not one of them
23:44:15 <neutrino> etc
23:44:16 <Iceland_jack> “It's Haskell's way or the highway”?
23:44:25 <startling> mrxy, the thing is that pretty-printing a function name *breaks* those other great things
23:44:26 <neutrino> we can trade deficiencies like that all day long
23:44:28 <elliott> I think this argument has stopped being productive, if it ever was.
23:44:33 <lispy> mrxy: you could define an instance of show that your ~/.ghci loads and use that
23:44:35 <mrxy> I don't even like python so I'm not sure why you expect me to defend it
23:44:35 <applicative> it's not throwing an error when a function is returned.
23:44:41 <sopvop> what statically typed languages out there have repl?
23:44:52 <mrxy> sopvop C
23:44:54 <applicative> you'll get the same error for > show id
23:44:56 <neutrino> mrxy: but you like $lang which also has its own deficiencies
23:45:00 <sopvop> what?
23:45:06 <mrxy> to be honest I don't know if cint can print it's functions
23:45:20 <startling> can it print structs etc?
23:45:21 <neutrino> the C repl is rarely used :)
23:45:26 <lispy> mrxy: so if you want your own personal ghci to have this ability, you can make it so
23:45:29 <edwardk> Iceland_jack: no, but its one thing to say hey i think it should be another way, and its another to ignore the reasonable objections of other people who have been using the tool for a lot longer.
23:45:37 <lispy> mrxy: share it with others, if it catches on great
23:46:06 <edwardk> i think many things about haskell should be another way. i do what i can to slowly make those changes
23:46:12 <Iceland_jack> That's what I heard when reading · for example:
23:46:13 <Iceland_jack> 07:43 < neutrino> mrxy: if you want haskell, use haskell, and get over its quirks
23:46:20 <elliott> The main problem, as I see it, is that people want to use Show to do in-depth debug printing, which involves violating invariants of Haskell itself, because you care about implementation details.
23:46:21 <sopvop> Thanks god SPJ is not Guido (and is not a dictator at all)
23:46:28 <elliott> But that's totally not going to be reasonably achievable with a typeclass.
23:46:47 <elliott> And the current Show is a reasonable approximation that doesn't blow up guarantees like parametricity and works for some other usecases too (like simple serialisation).
23:47:47 <edwardk> Iceland_jack; the main thing is ghci's repl is remarkably non-magic. it does a little bit of 'unfair' type analysis to figure out if it got back an IO action to run it, but otherwise its pretty much playing fair using Show, and asking the instance to print out stuff.
23:48:09 <edwardk> Iceland_jack: the request isn't reasonable given the confines of the language to implement in that manner and it breaks reasonable things that people use
23:48:20 <elliott> (Actually I think Hugs gets this right; it has its own internal debug printer you can use that'll print anything.)
23:48:30 <neutrino> mrxy: the thing is, there's many things you can complain about when using a new thing, be it a new language or a new chair, but it's just the power of habit, really
23:48:32 <Iceland_jack> what elliott said
23:49:07 <applicative> actually, if you ask ghci to show id, 'id' is a part of the error; a perfectly good string representation
23:49:08 <neutrino> mrxy: and sure, haskell's errors when printing out a function are not immediately obvious, but in the long run they make much more sense than the logic you propose
23:49:12 <mrxy> it's not even a deficiency in language but implementation. nothing is stopping ghci from pretty-printing function names
23:49:17 <sopvop> and don't forget to blame cabal (for anything)
23:49:44 <elliott> mrxy: it's clear you don't understand the issues -- like parametricity -- at play here. So why are you insisting your change is obviously correct? It's not going to go anywhere but cycles.
23:49:53 <applicative> mrxy should it also be able to show things like getChar?
23:49:56 <neutrino> mrxy: well, what ghci does is basically it's a loop in IO that runs the standard show function on things that come to the top
23:50:08 <neutrino> elliott: be nice.
23:50:52 <neutrino> mrxy: this is a simple description, but it's enough to understand in full what ghci is doing at that level. adding support for what you'd like to be happening would add more complexity.
23:51:16 <neutrino> mrxy: "show" itself cannot be changed because it has other uses as well, and is already defined to do specific things in the haskell standard
23:51:32 <edwardk> If you want this functionality, you are free to implement this functionality.
23:51:49 <neutrino> i'm much happier using a table knife that simply cuts, rather than one that suddenly becomes a spoon if you dip it in soup
23:51:53 <applicative> funny if you ask ghci to evaluate 'show readLn' it complains about the Show instance, but then hammers you for not saying how you wanted to specify the type read
23:52:17 <sopvop> class ShowDebug a and template-haskell for $(deriveShowDebug ''Foo) - and viola. Then patch ghci to use it instead of show.
23:52:27 <mrxy> just because ghci is basically a loop in IO that uses standard show function doesn't mean it has to be implemented that way.
23:52:45 <neutrino> no, but that's the simplest way to implement it
23:52:51 <mrxy> to the end user it doesn't matter how it's implemented
23:52:54 <neutrino> why make things more complex than absolutely necessary?
23:53:27 <neutrino> when you're using haskell, the time to figure out why typing a function name results in an error in ghci is about 0.000001% of your lifetime as a haskell programmer
23:53:43 <applicative> mrxy can you actually believe that anything is to (+1) as "2" is to 2 and "True" is to True?
23:53:55 <neutrino> why make the other 99.999999% of that time less productive and more deficient, just so you can accomodate that tiny blup?
23:54:09 <neutrino> blip
23:54:28 <mrxy> neutrino how would ghci custom printing returned functions make you less productive?
23:54:39 <mrxy> show doesn't even have to be touched
23:54:55 <applicative> 'printing returned functions'
23:54:58 <neutrino> when i type a function i expect it to behave like in a compiler pretty much
23:55:09 * applicative stares in amazement
23:55:16 <neutrino> so if i'm learning how to use a function, i'll always type it in, with some arguments i'd use in my code, and then see what it returns
23:55:30 <neutrino> if i type in wrong parameters, i expect a type error
23:55:37 <neutrino> that holds if i type in too few parameters
23:55:51 <mrxy> not typing enough parameters is not an error
23:55:52 <neutrino> the type error you complain about lets me know i forgot some parameters
23:56:01 <neutrino> is too in haskell
23:56:08 <mrxy> eh no.
23:56:31 <neutrino> i.. don't think you're making a reasonable argument here
23:56:39 <applicative> mrxy it is an error if you are asking the repl to show the thing.
23:56:52 <sopvop> why would you need to print function at all?
23:56:53 * edwardk helpfully offers -fdefer-type-errors. It'll make your haskell experience just like writing python.
23:57:05 <mrxy> plusOne = (+) 1 <- no error
23:57:09 <fmap> still better
23:57:19 <edwardk> sadly, true
23:57:39 <applicative> unsafeCoerce ,  -fdefer-type-errors, edwardk is a bad influence on impressionable youth
23:57:45 <neutrino> mrxy: sure, so let's see something like this
23:57:51 <mrxy> it's nost python. every single repl I have ever used in any language is capable of printing returned functions. it's a reasonable expectation
23:57:54 <neutrino> two = (+) 1
23:57:59 <neutrino> myList !! two
23:58:01 <neutrino> boom, type error
23:58:08 <Hafydd> How would you print let f g = g f in f?
23:58:09 <neutrino> why? because i forgot an argument
23:58:25 <sopvop> why, why do you need to print functions?
23:58:31 <mrxy> neutrino you are not making a reasonable argument. partial application is not an error
23:58:48 <neutrino> mrxy, in your case, you didn't type in too few parameters, you typed in just as many as you wanted
23:59:25 <Hafydd> Well, okay, that doesn't exist, but something similarly defined.
23:59:35 <neutrino> partial application that happens in error is something that error output helps me detect
23:59:43 <applicative> Hafydd: I print it 'Occurs check'
