00:00:19 <Enigmagic> the idea of IOT is that IO wouldn't be the base monad. MonadIO says 'lift until you hit the base monad, which is IO'
00:02:04 <startling> yeah. it's sort of silly, but it's clean up this particular code
00:02:52 <startling> *it'd
00:04:38 <startling> I'd be able to derive Monad with GeneralizedNewtypeDeriving! >:( >:( >:(
00:06:21 <Enigmagic> it can sometimes
00:09:38 <Enigmagic> i find it works pretty reliably if you use the form 'newtype FooT m a = FooT ... deriving (Monad, Applicative, Functor)' then define 'type Foo a = FooT IO a' if you want it to be restricted to IO
00:10:05 <startling> Enigmagic: well, I want FileT m a = FileT (ReaderT Handle IO (m a))
00:10:23 <startling> speaking of which, I'm having a hard time defining >>= for that. anyone care to give it a shot?
00:10:54 <Enigmagic> startling: why not just FileT (ReaderT Handle m a) ?
00:11:44 <startling> Enigmagic, because I want to be able to to use FileT for any m.
00:12:06 <startling> (and hide the IO at the same time)
00:12:18 <bartavelle> I was under the impression there was a Chan conduit sink somewhere, but I can't find it anymore. Is anybody aware of that ?
00:12:51 <bartavelle> (I found the STM conduit)
00:25:24 <Saizan> startling: you should rather require MonadIO m =>
00:26:43 <startling> Saizan: that won't let me hide the IO, though, will it.
00:26:57 <simpson> startling: You shouldn't hide IO unless it's in a monad isomorphic to IO.
00:27:16 <startling> simpson: why not?
00:27:20 <simpson> startling: Also, I get the feeling that you're reinventing ResourceT.
00:27:46 <startling> simpson: I want to seek around and read pieces of a file, is that what ResourceT is for?
00:28:06 <simpson> It's for doing things with an allocated resource which you plan on freeing later.
00:28:14 <startling> that's not what I'm doing at all.
00:28:38 <startling> well, I am, but withFile is sufficient for my purposes.
00:30:32 <simpson> Alrighty.
00:30:50 <startling> I just want "seek :: Monad m => Int -> FileT m a" and "bytes :: Monad m => Int -> FileT m ByteString"
00:32:40 <simpson> I'm not sure why you want a monad just for this, but okay.
00:33:17 <startling> it's sort of a long story.
00:34:24 <Enigmagic> seems like "seek :: MonadIO m => Int -> FileT m ()" would be more obvious to the user what's going on.
00:36:00 <Twisol> I'm coming in late, but your 'seek' and 'bytes' make it sound like you want a newtype around StateT over IO.
00:36:48 <mm_freak_> ResourceT is basically just a hack to handle loosly scoped resources‚Ä¶  a proper streaming abstraction should allow scoping
00:36:56 <mm_freak_> that's basically the reason why i don't like conduits that much
00:37:09 <startling> Twisol: a Reader around a Handle, actually
00:37:40 <Twisol> startling: Probably. Didn't think of the handle as immutable I guess.
00:37:43 <startling> The entire purpose of this is to move around a file without keeping too much of it in memory.
00:38:09 <mm_freak_> startling: should be a one-liner in any reasonable stream processing library like conduit/enumerator/pipes
00:38:51 <Enigmagic> mm_freak_: does conduit/pipes/enumerator support seekable sources like iteratee?
00:39:08 <startling> mm_freak_: yeah? do they let you seek to a previous position without having the first half in memory?
00:39:16 <Enigmagic> last time i looked it seemed like iteratee was the only one that did
00:39:29 <mm_freak_> Enigmagic: your producer can seek as much as it wants, but ideally communication goes from producer to consumer only
00:39:41 <Twisol> pipes allows bidirectional communication
00:39:48 <Twisol> so your consumer -could- ask the producer to seek
00:39:59 <mm_freak_> yes, that's possible at least in conduit and pipes
00:40:20 <mm_freak_> (conduit is pipes in disguise nowadays)
00:40:49 <startling> interesting. which one of those should I learn?
00:40:51 <Enigmagic> how would you do it in conduit?
00:41:03 <Saizan> startling: yeah, you can't really hide the IO if you want to be a transformer, IO has to go at the bottom of the stack, you could do FileT t a = FileT (ReaderT Handle (t IO) a) but that'd be weird, and what if t wants to embed IO too?
00:41:06 <johnw> startling: i think conduit has more "real world" users at the present time
00:41:27 <mm_freak_> Enigmagic: see how to do it in pipes and transfer it to conduit‚Ä¶  if in doubt, ask on the yesod mailing list
00:41:32 <startling> Saizan, so it's not possible? I was sort of getting that feeling but I couldn't convince myself.
00:41:34 <mm_freak_> they are based on almost the same type
00:41:39 <johnw> pipes is advancing nicely along theoretical lines
00:41:58 <Enigmagic> mm_freak_: not anymore i don't think, the bidirectional stuff isn't supported in conduit afaik
00:42:05 <startling> johnw, thanks
00:42:17 <mm_freak_> well, learn pipes =)
00:42:20 <startling> haha
00:42:27 <Twisol> startling: I'm a newbie to pipes, but I like its theoretical cleanliness.
00:43:04 <mm_freak_> i hope at some point pipes obsoletes conduit‚Ä¶  but currently conduit is better, if you want to get stuff done
00:43:16 <startling> I'm not really aiming to get stuff done. :)
00:44:11 <startling> anyway, it looks like a ReaderT Handle IO a is good enough; I don't *really* need it to be a transformer. thanks, everyone?
00:44:20 <startling> haha, s/?/!
00:44:25 <johnw> conduit is also more than just conduit; it has quite a few dependent libraries around it (attoparsec-conduit, http-conduit, csv-conduit, etc), so you don't have to roll your own producers and consumers as much
00:44:54 <johnw> startling: conduit really is quite trivial to use, if you're already comfortable with the complexity of using ReaderT
00:45:02 <mm_freak_> there was a lot of communication between michael snoyman and gabriel gonzales to exchange concepts between conduits and pipes‚Ä¶  conduit has improved a lot, but doesn't quite reach the beauty of pipes
00:45:33 <startling> johnw: that's compelling
00:45:41 <johnw> I read that pipes had cured some of its performance problems, I wonder how it compares to conduit now
00:45:57 <johnw> startling: and finally, there's pipes-conduit :)
00:45:59 <mm_freak_> johnw: that's what i meant when i said that conduit is better for getting stuff done right now
00:46:03 <startling> johnw: hahaha
00:46:05 <johnw> so even if you go with pipes, you can use it with conduit anyway
00:46:33 <mm_freak_> startling: i strongly recommend against ReaderT Handle IO
00:46:53 <mm_freak_> do it properly from the beginning, otherwise it will bite you later
00:47:15 <johnw> i'd say if you don't need real world, learn pipes; at the very least you'll appreciate the problem domain well if you should switch to another library in future
00:47:29 <Twisol> What's wrong in particular with ReaderT Handle IO?
00:47:49 <startling> mm_freak_: what's improper about that? I will be running literally two IO actions in it.
00:49:28 <Twisol> my first instinct would've been a newtype over ReaderT Handle m with primitives 'seek' and 'read' with (MonadIO m) constraints
00:50:17 <Ralith> startling: conduit is awesome
00:51:00 <Ralith> me and irene-knapp built our ICFP entry around it to generate streaming output as the problem was solved, instead of buffering it up
00:51:31 <startling> neat
00:52:07 <mm_freak_> startling: incomposability
00:52:26 <mm_freak_> startling: as soon as you want to get more flexible about how the data is processed you will be reinventing coroutines
00:52:32 <mm_freak_> as such you will be reinventing enumerators
00:52:58 <Ralith> startling: we also used it to, with minimal effort, build an ANSI-terminal-based interactive game mode for testing.
00:53:10 <mm_freak_> and finally, when you hit the flexibility wall of that approach, you will find yourself using pipes/conduits anyway =)
00:53:13 <Twisol> mm_freak_: however, reinventing coroutine is rather fun! :D
00:53:18 <Twisol> *coroutines
00:53:51 <bartavelle> can someone explain to me how to get an AppData for http://hackage.haskell.org/packages/archive/network-conduit/0.6.2.1/doc/html/Data-Conduit-Network.html ?
00:55:52 <startling> what should I read to learn pipes, then?
00:56:18 <startling> oh, Control.Proxy.Tutorial
00:57:08 <snoyberg> bartavelle: when you use runTCPServer, the Application you provide is given an AppData for every request
00:57:24 <snoyberg> bartavelle: similar concept for runTCPClient
00:57:28 <bartavelle> AHHHHH
00:57:46 * bartavelle facepalms
00:57:46 <bartavelle> thanks
00:58:28 <snoyberg> bartavelle: np
00:58:53 <johnw> hi snoyberg, did you hear us talking about conduit? :)
00:59:32 <snoyberg> i just looked over to this window for a moment and saw something about pipes and network-conduit
00:59:39 * snoyberg scrolls up...
01:00:59 <snoyberg> i think something that people miss a lot in the pipes vs conduit "debate" is that conduit has a lot of added complexity to handle more complex situations, connect-and-resume being the prime example
01:01:21 <snoyberg> connect-and-resume makes it much easier to actually *use* conduit in many cases, but there is a cognitive overhead to it
01:01:48 <snoyberg> i put "debate" in quotes because, in reality, pipes and conduit are far more similar than they are different
01:02:53 <simpson> Isn't the main trick about how to get things like bidirectional proxies to work?
01:03:05 <snoyberg> if someone is just hoping to learn the concepts, i see no problem with using pipes for that, but i still believe that if you try to use it in the real world you will (eventually) run up against a lot of the problems that motivated the extra functionality in conduit in the first place
01:03:29 <snoyberg> simpson: sorry, i don't follow, what do you mean by the main trick?
01:04:05 <simpson> snoyberg: Behind connect-and-resume. You've gotta move chunks from connection A to connection B, and then back from connection B to connection A, without ignoring either for a long stretch of time.
01:05:02 <snoyberg> simpson: i suppose in that sense you *might* be able to technically solve the same problem as connect-and-resume with bidi proxies, though you didn't need bidi for that either, nested transformers solves that problem
01:05:03 <mm_freak_> Twisol: reinventing coroutines boils down to reinventing FreeT
01:05:16 <snoyberg> the trick is that C&R makes it really easy to use that code
01:05:24 <mm_freak_> Twisol: i noticed that Coroutine from monad-coroutine is essentially just FreeT and proposed to add it to the 'free' library‚Ä¶  now monad-coroutine is obsolete
01:05:24 <Twisol> mm_freak_: So I'm told. Doesn't make it less fun and/or interesting. :)
01:05:30 <snoyberg> my prime example for that is to compare the API for http-enumerator and http-conduit regarding request bodies
01:05:56 <beaky> what are continuations
01:06:01 <simpson> snoyberg: Hm. Never thought of doing it that way. This is pretty much *the* problem in networking libraries in other languages, so I figured that it must have been the motivator for C&R.
01:06:19 <johnw> beaky: they're like closures that include the entire program
01:06:25 <snoyberg> C&R is almost exclusively a means of simplifying code
01:06:43 <applicative_> hey snoyberg is here. hi.
01:07:10 <johnw> beaky: if a lambda is an anonymous function, and a closure is a lambda that captures its lexical scope, a continuation captures its execution context and is therefore resumable from where it left off at any later time
01:07:15 <beaky> so the IO monad is like a continuation?
01:07:17 <snoyberg> it was really kicked off by m3ga, when he mentioned using Warp + http-conduit as a proxy, and it became obvious to everyone involved in the conversation that "yes, you *could* do that with enumerators and nested transformers... but why would you want to?"
01:07:17 <mm_freak_> beaky: regular style:  f :: X -> Int
01:07:23 <snoyberg> applicative_: hi
01:07:28 <mm_freak_> beaky: continuation style:  f :: X -> (Int -> r) -> r
01:08:09 <mm_freak_> chaining regular functions:  f . g
01:08:43 <m3ga> snoyberg: have i missed something or was i just mentioned in passing? :-)
01:08:46 <mm_freak_> chaining CPS functions:  \x k -> g x (\y -> f y k)
01:09:15 <snoyberg> m3ga: you were mentioned in passing. you motivated the whole concept of connect-and-resume with the proxy use case, which wasn't properly addressed by enumerators
01:09:24 <snoyberg> m3ga: remember getting those headaches? ;)
01:09:39 <johnw> beaky: the Cont monad is ony way to use continuations, and ContT can be used with IO
01:09:42 <mm_freak_> beaky: in other words:  don't /return/ a result, but instead pass it to a "go on with this value" function
01:09:44 <johnw> s/ony/one
01:09:45 <m3ga> ah yes, making that work with enumerator almost broke my brain
01:09:56 <beaky> ah
01:10:19 <beaky> CPS seems very neat for some things
01:10:38 <snoyberg> simpson: i'm still not completely clear on what the use cases are for bidi proxies TBH
01:10:48 <mm_freak_> beaky: continuations are a special case of coroutines
01:10:55 <mm_freak_> beaky: see how free monads work
01:11:22 <snoyberg> simpson: i usually approach things from a more pragmatic standpoint, and i never actually felt motivated to create something like that, so it didn't strike me as a solution to a problem that i've faced
01:11:23 <johnw> snoyberg: someone was asking if you can seek inside of a source, and then someone else suggested using bidi to ask the source to seek
01:11:35 <snoyberg> johnw: ahh, i missed that
01:11:35 <simpson> snoyberg: Any time that you want to hook two things to each other. Last one I built was for WebSockets (ugh!) as a wrapping protocol. Any other kind of wrapping proxy would probably want something similar.
01:11:42 <johnw> (that is, for the sink to ask the source to seek)
01:11:47 <snoyberg> johnw: i saw a question like that on SO i think, but forgot to respond
01:12:06 <snoyberg> johnw: my question is: what would the semantics of that be? the next time you get a chunk it would just jump somewhere else?
01:12:37 <johnw> i suppose so
01:12:49 <snoyberg> simpson: IME it usually doesn't make sense to deal with both ends of a connection in the same thread, except in the most basic of use cases
01:13:34 <snoyberg> simpson: that's what motivated the design of network-conduit: instead of having a Conduit that sat between a server and client connection, we get a Source for the one side and a Sink for the other, and you can deal with them however you want
01:14:03 <simpson> snoyberg: Right, but they're in their own green thread, so it's kind of hard to just wire Source-Sink on both connections and then let it magically run.
01:14:04 <snoyberg> johnw: hmm... i think it could be done, you'd probably have to do something like create a control object first
01:14:35 <snoyberg> johnw: maybe i'll play with the idea a bit, definitely sounds doable, if not as slick as how iteratee works
01:15:10 <snoyberg> simpson: can you give me an example of something that doesn't fit the model very well?
01:16:58 <simpson> snoyberg: I'm just thinking of proxies that I've built in other languages. Most of them have a little setup on each side, and maybe an adapter glued to one end, and then you pull apart the backs of the connections and smush 'em back together. The networking library runs the rest.
01:17:20 <simpson> Obviously you can just C&R chunks from one connection to the other, and vice versa, which isn't that much of a pain.
01:18:06 <snoyberg> simpson: my point is that, if you have that kind of a simple use case, you can do it the easy way with conduit too: send some initial data to the sink, C&R some initial data from the Source, and *then* smush 'em back together, possibly even with a Conduit in between
01:19:23 <simpson> snoyberg: Well, these are bidirectional, but you can only run one conduit at a time, right?
01:19:56 <snoyberg> simpson: true, i don't think the pipes bidi pipes allow concurrency either though
01:20:18 <snoyberg> simpson: so if you actually need concurrent behavior, i think your only choice is to use the separate Source/Sink approach we have in network-conduit and fork some green threads
01:20:42 <simpson> snoyberg: Well, if I hypothetically spent most of my time in Python writing things in Twisted, then this is a no-brainer. >:3
01:20:58 <simpson> I don't know how pipes does it.
01:21:46 <applicative_> snoyberg: How far Control.Proxy advances on pipes is obscure. The types of the filter functions in Contol.Proxy mean that even the presence of a filter  makes the composition a one way 'pipe'
01:22:31 <snoyberg> simpson: i don't really know enough about twisted to make a comparison there, but if there are things it's doing better, i'd love to know so we can improve network-conduit
01:22:36 <applicative_> maybe it makes sense; but you'd think filtering was a pretty elementary operation
01:23:04 <simpson> snoyberg: It's mostly just highly impure in its event loop. It's a different struture, no green threads or anything like that.
01:23:20 <monadicity> what is Set^(->) ?
01:23:20 <Moggle> A while ago I asked for a list of basic problems for beginners to Haskell to solve, does anyone still have that list?
01:23:33 <monadicity> it has truth values false true and in between
01:23:52 <snoyberg> applicative_: maybe i'll have to have another look, when i first read about it it didn't really sink in very much
01:24:28 <hpaste> snoyberg pasted ‚ÄúBasic seeking in conduit‚Äù at http://hpaste.org/79874
01:24:51 <snoyberg> johnw: that's the most basic example of seeking in conduit i could come up with
01:25:13 <winnerrre> http://www.carolinaherrera.com/212/es/areyouonthelist?share=4Y9fhwXQQ7Mswio6hAClqdz2gzAqEjJq72G1oQgnhyd_9D3FDiouJG-c8M6ydir-FdOWaD_yCK1meXDLNBOfTw#episodio-7
01:25:26 <monadicity> help
01:26:01 <johnw> snoyberg: interesting
01:26:06 <johnw> monadicity: it's an arrow category
01:26:13 <monadicity> thanks
01:26:15 <johnw> monadicity: the category whose objects are the morphisms from Set
01:28:17 <johnw> C‚Éó :)
01:28:23 <snoyberg> johnw: another possibility for seeking would be that each yield would provide a "seek" action along with it
01:28:29 <monadicity> lets define it in haskell
01:28:35 <Moggle> A while ago I asked for a list of basic problems for beginners to Haskell to solve, does anyone still have that list?
01:28:47 <snoyberg> johnw: and then we could have a sourceSeekableFile kind of function
01:29:06 <johnw> Moggle: http://www.haskell.org/haskellwiki/H-99:_Ninety-Nine_Haskell_Problems
01:29:18 <Moggle> johnw: <3
01:30:03 <monadicity> category C^(->) where objects = a -> b ; morphisms (f : a -> b) (g : c -> d) = (a -> c, b -> d) -- with commuting
01:32:03 <johnw> Moggle: I think that if you had type-level composition, you could just define Category (.)
01:33:14 <johnw> or maybe that's too linear
01:34:20 <nyc> Was there a particular Haskell/Prolog problem being examined?
01:34:37 <hpaste> snoyberg pasted ‚ÄúsourceSeekableFile‚Äù at http://hpaste.org/79875
01:34:59 <johnw> ah, the morphisms of ùê∂ ‚Éó are the commuting square diagrams of ùê∂, so my suggestion is not valid
01:35:26 <startling> is there not an mtl requiring transformers >= 0.3 ? ugh.
01:35:26 <johnw> snoyberg: interesting!
01:35:43 <johnw> so your source hands back callbacks to establish bidirectionality
01:35:47 <notdan> Why does the MonadReader class has a local method? I thought the idea of a Reader is that we are not allowed to modify the "state", we a are only allowed to read it
01:35:52 <johnw> that's very clever, and easy to implement with the existing conduit
01:36:02 <snoyberg> johnw: that one's a bit "unsafe" because you have to ignore Nothing values, but i can work around that in a different way (going to try that one next)
01:36:08 <startling> notdan, you could do it anyway
01:36:33 <startling> notdan: it would be "runReader something . someFn <$> ask"
01:37:05 <startling> notdan: the important thing is that if you sequence many Reader operations, they can't change what operations sequenced after them see.
01:37:28 <notdan> Ah, I see
01:37:28 <johnw> notdan: it only modifies the environment for the scope of one action
01:37:29 <notdan> thanks
01:37:30 <snoyberg> never mind, the Nothing ignoring is going to be a requirement unfortunately
01:37:44 <notdan> the chaining readers is, well, commutative?
01:37:47 <notdan> in some one?
01:37:53 <notdan> s/one/way/
01:38:01 <johnw> that's why it's called "local"
01:38:08 <notdan> I see, thanks
01:38:40 <startling> notdan: "commutative" is a good way to put it
01:39:14 <startling> do a <- x; b <- y; return $ a + b; is the same as do b <- y; a <- x; return $ a + b;
01:39:21 <startling> whereas in State it's not necessarily.
01:40:15 <johnw> monadicity: http://unapologetic.wordpress.com/2007/05/23/arrow-categories/
01:46:36 <Phlogistique> hello there
01:47:54 <monadicity> hi
01:51:28 <startling> ugh. something is depending on mtl-2.0.1.0 (which requires transformers-0.2.2.0), but I have other things that depend on transformers-0.3.0.0. How do I figure out what wants the old mtl?
01:52:11 <shachaf> -v?
01:53:20 <startling> that doesn't give me any more information.
01:53:30 <atriq> edwardk: is tables "edwardk does ixset"?
01:53:38 <startling> All I've got is "package mtl-2.0.1.0 requires transformers-0.2.2.0"
01:54:11 <atriq> What are you trying to install?
01:54:42 <startling> This is for a package I wrote; I was rewriting the tests using hspec. hspec is pulling in the new transformers
01:54:47 <snoyberg> startling: you can look at all the red rows in http://packdeps.haskellers.com/reverse/mtl
01:56:02 <startling> snoyberg: haha, neat
01:56:10 <Moggle> why must function currying be so awesome
01:56:16 <Moggle> never see it in other languages
01:56:21 <snoyberg> startling: hmm... maybe i should add the ability to "see only red"
01:56:26 <Moggle> or well I imagine it's in plenty of them I just haven't found them yet
01:56:28 <monadicity> probaly because its left adjoint to exponential functor
01:56:34 <snoyberg> startling: might be confused for a way to make you angry
01:56:35 <monadicity> ?????????
01:56:39 <startling> snoyberg: that would help
01:56:44 <atriq> snoyberg, are you the guy who makes the reverse dependency site?
01:56:51 <snoyberg> atriq: yes
01:57:08 <snoyberg> atriq: at least the one i just linked to, there are one or two others out there i think
01:57:14 <atriq> snoyberg, may I tell you the one thing I'd like for it?
01:57:26 <snoyberg> atriq: sure
01:57:40 <atriq> On the search box, a way to match exactly
01:58:09 <mm_freak_m> Currying isn't really a language feature per se. You just need closures.
01:58:20 <startling> automatic currying is, though.
01:58:33 <atriq> Python has currying. Nobody uses it, though
01:58:35 <mm_freak_m> What's that?
01:58:45 <snoyberg> atriq: you mean whole word matching?
01:58:48 <atriq> Yeah
01:58:55 <atriq> Try searching "snap"
01:59:00 <Moggle> jeez some of these wiki problem solutions are overly complex
01:59:10 <Moggle> (also wrong)
01:59:39 <snoyberg> atriq: i see what you mean
01:59:52 <snoyberg> atriq: i'll look into it, can you file an issue on github?
02:00:22 <atriq> snoyberg, okay
02:03:47 <snoyberg> atriq: thanks, i just saw it
02:04:48 * startling % rm -rf .ghc && cabal update && cabal-dev install aeson aeson-pretty binary vector base64-bytestring optparse-applicative # >.>
02:04:57 <Catnaroek> snoyberg: Do you think it would be feasible to extend Data.Conduit.Binary with the possibility to arbitrarily fseek a file being read (opened using sourceFile)?
02:05:22 <snoyberg> Catnaroek: johnw and i were discussing that a little bit ago
02:05:30 <snoyberg> Catnaroek: check out: http://hpaste.org/79875
02:05:39 <startling> oh hey, it works
02:05:51 <Catnaroek> snoyberg: Oh, let me see.
02:05:54 <snoyberg> Catnaroek: i've personally never had this use case, so there might definitely be some improvements possible
02:06:02 <monadicity> what is a presheaf
02:06:04 <monadicity> ?
02:06:18 * hackagebot keter 0.3.4.1 - Web application deployment manager, focusing on Haskell web frameworks  http://hackage.haskell.org/package/keter-0.3.4.1 (MichaelSnoyman)
02:10:49 <Catnaroek> snoyberg: I want to implement a toy RDBMS (right now, performance is not a concern, I just want to explore some ideas regarding what is possible using foreign keys), and the last thing I want to do is go back to low-level IO using Handles, just because I need to fseek inside index files. conduit and cereal-conduit would provide an ideal solution if you could add the possibility to arbitrarily fseek files.
02:11:35 <snoyberg> Catnaroek: what do you think about the sourceSeekableFile approach?
02:12:34 <Catnaroek> snoyberg: Unfortunately I could view your paste, because I am reinstalling my whole system from scratch... I'm going to download links right now.
02:13:09 <snoyberg> Catnaroek: got it... i think combined with a Conduit to turn the stream into a simple stream of ByteString values, it should work
02:14:16 <lzm> about the folder structure of a haskell project.. should my Main.hs go in src/ or src/MyProjectName ?
02:14:26 <bartavelle> what is the point, with IODone, to have (Maybe input) as the first argument ?
02:14:57 <bartavelle> (for the SinkIOResult type)
02:15:13 <Catnaroek> snoyberg: I just read your paste... What exactly would be the type signature of await?
02:16:07 <snoyberg> await :: Pipe .. m (Maybe (S.ByteString, SeekMode -> Integer -> IO ()))
02:16:25 <snoyberg> that's what i meant by having another Conduit, which would give you just the stream of ByteStrings and not the seek functions
02:16:47 <snoyberg> it would essentially be "map fst", but would stop when it hits a null Bytestring
02:22:29 <covi> What is this syntax called: class Monad m => MonadError e m | m -> e where  (the `|' thing)
02:22:43 <startling> covi: functional dependencies
02:23:05 <covi> startling: what does | mean
02:23:38 <startling> covi: "MonadError has two arguments, e and m, where e depends on and will be inferred from m"
02:23:57 <Catnaroek> snoyberg: I guess that works, although I wonder if there is a way that does not involve using those liftIOs.
02:24:26 <snoyberg> Catnaroek: i could have the returned function live in an arbitrary MonadIO
02:24:37 <snoyberg> Catnaroek: i think that requires rank2
02:26:25 <covi> startling: I see. What does 'infer' mean here?
02:27:02 <hpaste> keep_learning pasted ‚Äúmain is terminating before threads‚Äù at http://hpaste.org/79876
02:27:06 <Catnaroek> covi: m uniquely determines e, me thinks.
02:27:12 <startling> ^ yep
02:27:20 <keep_learning> Hello all
02:28:01 <mikeplus64> is there a way to enable/disable features depending on what packages someone has installed? (or rather, to enable/disable CPP flags in cabal based on what packages someone has installed)
02:28:09 <keep_learning> Could some one please tell me how to force main to evaluate all the thread before terminating.
02:28:15 <keep_learning> http://hpaste.org/79876
02:28:25 <startling> mikeplus64, no, but you can have them give cabal a flag
02:28:38 <startling> mikeplus64: N.B. this is probably a terrible idea for libraries
02:29:00 <mikeplus64> shame
02:29:07 <snoyberg> startling: ok, that checkbox is now live
02:29:11 <mikeplus64> although maybe with Setup.hs you could somehow do it ...
02:29:26 <startling> snoyberg: already figured it out. >.>
02:29:46 <snoyberg> startling: how'd you figure it out so quickly? i just uploaded the changes 10 seconds ago
02:30:11 <snoyberg> atriq: you can do an exact search now by prepending "exact:", give the database another few minutes to reload and then it should work
02:30:14 <startling> snoyberg, oh, heh, I meant the dependency error
02:30:24 <snoyberg> startling: got it
02:30:24 <startling> snoyberg: I appreciate the helpfulness though.
02:30:38 <snoyberg> startling: sure, it's a feature i keep meaning to add and keep pushing off
02:32:00 <startling> anyway, wow, optparse-applicative sure changed a lot of the api for a minor release!
02:34:40 <atriq> snoyberg, :)
02:35:01 <atriq> Ah, naming functions, the hardest part of programming
02:35:40 <atriq> If you were looking for a function that you gave a year and it gave you an interval of days, what name would you look for?
02:36:03 <notdan> http://hpaste.org/79877 is it possible to use ReaderT instead of StateT in here?
02:37:27 <Eelis> notdan: i'd say no, because then you have no way to track how much input you've read
02:37:39 <atriq> notdan, no, I've tried this before
02:37:49 <notdan> Ok, fair enough :)
02:37:50 <notdan> thanks
02:38:15 <atriq> Also, State s is shorthand for StateT s Identity
02:38:52 <notdan> yeah i know i was just playing with transformers
02:38:57 <atriq> Okay
02:39:00 <notdan> i had other monad instead of the identity there
02:39:02 <atriq> Also..
02:39:07 <atriq> :t evalStateT
02:39:09 <lambdabot> Monad m => StateT s m a -> s -> m a
02:39:14 <Eelis> you can also use RWS to reduce the number of layers
02:39:21 <atriq> Means you don't need to say "fst"
02:39:34 <notdan> o
02:39:37 <notdan> that's cool
02:39:41 <notdan> Eelis: RWS?
02:39:48 <atriq> Reader-Writer-State
02:39:53 <atriq> It's a big altogether monad
02:39:56 <Eelis> http://hackage.haskell.org/packages/archive/mtl/latest/doc/html/Control-Monad-RWS-Lazy.html
02:40:07 <Eelis> hardly big
02:40:12 <notdan> ah, I see
02:40:14 <atriq> Bigger than Reader
02:40:31 <Eelis> yes, but it would not just replace his reader, it would replace his reader+state
02:40:34 <Eelis> or his writer+state, whatever
02:40:48 <atriq> It's bigger than writer+state
02:40:54 <atriq> It's also really fun to say
02:40:56 <Eelis> and RWST is still just  r -> s -> m (a, s, w)
02:41:04 <atriq> Reader Writer State Transformer
02:41:08 <Eelis> just pick () for r if you don't need it, no big deal
02:43:13 <Eelis> i wouldn't say it's bigger than writer+state if you consider the extra ugly boilerplate you have to have if you do it in two steps
02:43:27 <Eelis> the code will be cleaner :)
02:44:10 <Catnaroek> snoyberg: Sorry for bugging you more! I think the interface for allowing seeks could be somewhat simplified if you allowed relative seeks only. After all, drop basically performs a forward relative seek. Perhaps dropping -3 bytes could mean going 3 bytes backwards in the file.
02:45:27 <snoyberg> Catnaroek: i would think it would definitely be likely that users at some point would want to seek to the beginning of the file, or a certain offset from the beginning
02:55:05 <startling> uh-oh. getting "process haskell bus error" from encode from aeson.
02:56:07 * startling goes to sleep instead
03:07:14 <zomg> Oh!
03:07:19 <zomg> ctrl+r works in ghci
03:07:39 <zomg> Why didn't anyone tell me about this?
03:07:41 <zomg> :D
03:08:48 <ethercrow> zomg: you'll like rlwrap then
03:09:00 <zomg> What's that?
03:09:20 <ethercrow> rlwrap telnet - and you have ctrl+r and other stuff with telnet
03:09:30 <ethercrow> or with any other commandline program
03:09:40 <zomg> ah, pretty neat
03:24:26 <atriq> Flexible Instances has just blown up in my face
03:49:00 <Waffrol> Haskell seem to be a very nice language
03:49:37 <atriq> There is a very good reason for that
03:49:42 <atriq> It is a very nice language
03:50:04 <Waffrol> I am coming from C and I like what I'm seeing
03:51:21 * hackagebot her-lexer-parsec 0.0.0 - Parsec frontend to "her-lexer" for Haskell source code.  http://hackage.haskell.org/package/her-lexer-parsec-0.0.0 (TimothyHobbs)
03:52:04 <Waffrol> So is there any graphical package to make GUI applications with Haskell?
03:52:12 <atriq> Yes, there's a few
03:52:17 <atriq> What are you used to from C?
03:52:35 <nicoo> Waffrol: http://www.haskell.org/haskellwiki/Applications_and_libraries/GUI_libraries
03:52:38 <atriq> Did you use OpenGL? WX?
03:52:54 <Waffrol> OpenGL mostly
03:53:13 <atriq> Haskell has very good OpenGL bindings!
03:53:17 <Waffrol> for window applications I quite like Qt
03:53:36 <Waffrol> That's nice to hear, I will certainly check that out
03:53:58 <atriq> Actually
03:53:59 <Waffrol> Do you know a place to learn Haskell and openGL bindings?
03:54:02 <atriq> I'm thinking of GTK
03:54:16 <atriq> For Haskell, Learn You A Haskell
03:54:19 <atriq> @where lyah
03:54:19 <lambdabot> http://www.learnyouahaskell.com/
03:54:31 <zomg> @where waldo
03:54:32 <lambdabot> http://planet.haskell.org
03:54:37 <zomg> lol
03:54:44 <Waffrol> thank you
03:55:03 <atriq> Start with that
03:55:09 <Waffrol> That's actually exactly what I was looking for
03:55:26 <Waffrol> An easy start.
03:55:44 <Waffrol> Haskell is just so much different from C-style languages
04:01:30 <Twisol> I find myself taking multiple objects in JavaScript and just gluing them together through the events they emit. I wonder if this pattern could be formalized, like as an instance of Category or something.
04:10:53 <joar> I'm following the tutorial "Hitchhikers guide to Haskell", I believe I must have missed something in my program. This is the task at hand: http://www.haskell.org/haskellwiki/Hitchhikers_guide_to_Haskell#Chapter_4:_REALLY_packing_the_knapsack_this_time, this is my basically identical copy (comments copypasted, code written by hand): https://github.com/joar/hs-hitchhiker/blob/master/cd-fit.hs#L43, this is the output: https://gist.github.com/558dc2a029906b65
04:11:28 <Twisol> joar: output link is dead
04:11:51 <joar> Twisol: might have been truncated, here it is again: https://gist.github.com/558dc2a029906b6536df
04:12:08 <Twisol> yep, think you sheared the last bit off
04:12:45 <joar> Twisol: I blame Freenode's line length limit :) It looks complete on my side.
04:12:50 <osa1> I'm reading "stanford encyclopedia of philosophy"s lambda calculus post, but I don't understand difference between Y and Œò combinators, can anyone give me some pointers for further investigation ? "curry's paradox" wikipedia page also didn't help.
04:12:54 <Twisol> That would make sense!
04:13:51 <catsbydlo> s/Freenode/IRC/
04:14:07 <Twisol> joar: Sorry, not familiar with the problem at hand. :( Was hoping there might be an obvious error to track down.
04:14:24 <joar> Twisol: Me too :)
04:14:47 <frontendloader> wikipedia pages are the worst resource for learning
04:15:07 <frontendloader> I made the mistake of trying to learn toom-cook from it
04:15:54 <frontendloader> It's reference material, not learning material
04:16:11 <mcstar> it has been 1 year since i picked up haskell seriously
04:16:39 <joar> catsbydlo: You are right according to RFC 1459, page 8, paragraph 3 :)
04:16:56 <mcstar> time flies pretty fast
04:17:12 <catsbydlo> Œò = (Œªx. Œªy. (y (x x y))) (Œªx. Œªy. (y (x x y)))
04:17:14 <catsbydlo> Y = Œªf.(Œªx.f (x x)) (Œªx.f (x x))
04:17:17 <catsbydlo> that's the difference
04:20:32 <catsbydlo> operationally it looks like theta doesn't use a closure
04:20:47 <catsbydlo> yeah, f is not shared
04:21:28 <catsbydlo> otherwise it looks identical
04:21:53 <osa1> catsbydlo: yeah I know their definition but why one of these is called "curry's paradox", while other one is "turing's fixed-point combinator" ?
04:22:36 <catsbydlo> I don't know about curry but presumably theta is called turing's fixed-point combinator because it's a fixed-point cominbator and it was discovered by turing
04:23:49 <osa1> ok I found this http://plato.stanford.edu/entries/curry-paradox/ it has a page for curry's paradox too :) it will be a long read (I also have combinatory logic and proof theory in the queue)
04:26:22 * hackagebot family-tree 0.3.0.0 - A family tree library for the Haskell programming language.  http://hackage.haskell.org/package/family-tree-0.3.0.0 (NathanVanDoorn)
04:26:33 <catsbydlo> ok, I've read about curry's paradox but I don't see how it's related to Y
04:27:08 <catsbydlo> I know types correspond to theorems via curry-howard but I have no idea how to even start with the paradox
04:27:22 <catsbydlo> on the other hand, fix :: (a -> a) -> a can be used to "prove" anything
04:27:37 <atriq> Well, I made a mess of that
04:28:00 <atriq> And now it's on Hackage
04:28:17 <atriq> Can someone look at family-tree and tell me why Hackage isn't showing the dependencies?
04:28:59 <catsbydlo> atriq: maybe that information generated is generated in batches, like documentation?
04:29:13 <shachaf> @src Rec
04:29:14 <lambdabot> newtype Rec a = InR { outR :: Rec a -> a }
04:29:20 <shachaf> catsbydlo: Do you see how that's related to Curry's paradox?
04:29:52 <catsbydlo> I'm not sure what the a is doing
04:30:12 <catsbydlo> rec_a = rec_a -> a
04:30:34 <shachaf> The a can be anything.
04:30:37 <catsbydlo> "theorem a: if theorem a is true, then a"
04:30:49 <catsbydlo> ok, so it's parameterized by the thing we want to "prove"
04:30:55 <shachaf> Calling it "theorem a" is a bit confusing, but yes.
04:31:12 <shachaf> So that's Curry's paradox.
04:31:16 <shachaf> @where y
04:31:16 <lambdabot> \f -> (\x -> f (outR x x)) (InR (\x -> f (outR x x)))
04:31:23 <shachaf> That's Y, written using Curry's paradox.
04:31:30 <atriq> :t InR (const 10)
04:31:32 <lambdabot> Num a => Rec a
04:31:46 <atriq> :t let x = InR (const 10) in outR x x
04:31:47 <lambdabot> Num a => a
04:31:52 <atriq> > let x = InR (const 10) in outR x x
04:31:54 <lambdabot>   10
04:32:55 <catsbydlo> wait, we're cheating by using type-level recursion, right? (Rec refers to itself)
04:33:02 <shachaf> Yes.
04:33:04 <catsbydlo> that's why the whole thing types
04:33:09 <shachaf> Yes.
04:33:17 <shachaf> You can't actually write Y in Haskell without cheating, of course.
04:33:19 <shachaf> That's the point.
04:33:23 <sopvop> how bad is -XImpredicativeTypes?
04:33:26 <catsbydlo> the fixed point
04:33:40 <shachaf> sopvop: Bad in what sense?
04:33:50 <catsbydlo> michael jackson bad
04:33:55 <sopvop> Like bad as overlappinginstances
04:34:08 <shachaf> No, it's not really bad in the sense that it's evil.
04:34:16 <shachaf> It tends to not work that well, though?
04:35:12 <zenzike> pl sqrt . distSq x
04:35:30 <zenzike> @pl sqrt . distSq x
04:35:30 <lambdabot> sqrt . distSq x
04:35:32 <catsbydlo> zenzike: already pointless
04:35:37 <zenzike> well, yes
04:35:46 <zenzike> but not totally point free
04:35:50 <catsbydlo> yes, it is
04:36:09 <mcstar> @pl \x -> sqrt . distSq x
04:36:09 <lambdabot> (sqrt .) . distSq
04:36:20 <catsbydlo> @pl \distSq -> sqrt . distSq x
04:36:21 <lambdabot> (sqrt .) . ($ x)
04:36:27 <sopvop> @pl \(a,b,c) d -> foo a b c d
04:36:27 <lambdabot> (line 1, column 7):
04:36:27 <lambdabot> unexpected "c"
04:36:27 <lambdabot> ambiguous use of a non associative operator
04:36:33 <catsbydlo> @pl \(.) -> sqrt . distSq x
04:36:33 <lambdabot> (line 1, column 3):
04:36:33 <lambdabot> unexpected "."
04:36:33 <lambdabot> expecting pattern
04:36:41 <sopvop> @pl (\(a,b,c) d -> foo a b c d)
04:36:42 <lambdabot> (line 1, column 8):
04:36:42 <lambdabot> unexpected "c"
04:36:42 <lambdabot> ambiguous use of a non associative operator
04:36:48 <catsbydlo> @pl \f -> sqrt `f` distSq x
04:36:49 <lambdabot> flip ($ sqrt) (distSq x)
04:36:50 <zenzike> ah I see. thanks.
04:36:58 <catsbydlo> sopvop: 2-tuples only
04:37:25 <sopvop> lame
04:37:36 <catsbydlo> it compiles to fst/snd
04:38:01 <sopvop> why not (view _1)? :)
04:38:57 <catsbydlo> @hackage banana
04:38:58 <lambdabot> http://hackage.haskell.org/package/banana
04:39:05 <catsbydlo> someone should write that
04:39:17 <sopvop> @hoogle reactive-banana
04:39:18 <lambdabot> package reactive-banana
04:39:18 <lambdabot> package reactive-banana-wx
04:40:05 <catsbydlo> @hackage barbed-wire
04:40:05 <lambdabot> http://hackage.haskell.org/package/barbed-wire
04:59:35 <Taneb> Ack
04:59:42 <Taneb> I'd said "0.42" instead of "0.4.2"
05:00:05 <mrout> Why is Haskell so big?
05:00:10 <mrout> the download, that is
05:00:43 <byorgey> mostly it's the magical gnomes
05:00:47 <byorgey> they don't compress very well
05:00:52 <catsbydlo> which download?
05:01:05 <mrout> catsbydlo: the Haskell Platform download, obviously
05:01:23 * hackagebot family-tree 0.3.0.1 - A family tree library for the Haskell programming language.  http://hackage.haskell.org/package/family-tree-0.3.0.1 (NathanVanDoorn)
05:01:25 <catsbydlo> "obviously"
05:01:44 <mrout> what‚Äôs not obvious about that?
05:02:07 <Taneb> Could refer to just GHC, or the entire of Hackage
05:02:16 <byorgey> anyway.  how big is it?  and how big would you expect it to be?
05:02:17 <catsbydlo> or the report
05:02:24 <Taneb> Or the report, yeah
05:02:26 <mrout> 112MB. Kinda large.
05:02:27 <catsbydlo> or even hugs
05:02:30 <mcstar> or the 'haskell 2010' specification...
05:02:38 <Taneb> Or JHC or nhc or UHC...
05:02:43 <catsbydlo> mcstar: that's the report
05:02:58 <mcstar> you can call that 'haskell' too
05:03:12 <mrout> mcstar: I think they meant that they had referred to it already
05:03:13 <mcstar> catsbydlo: i see, reada the backlog
05:03:19 <catsbydlo> possibly some distribution packages
05:03:31 <mrout> Why is the Haskell Platform download so big?
05:03:32 <bootcode> mrout: the platform contains lots of packages bundled too, not only the compiler
05:03:56 <mrout> bootcode: ahh, I see. what sort of packages?
05:04:15 <bootcode> mrout: however as I sense (correct me if not) is that a better route is to have just ghc + cabal installed, and let cabal pull the packages
05:04:17 <byorgey> mrout: because it has stuff in it the total size of which is 112MB?  It's a binary distribution.  It has profiling versions of libraries as well as normal versions.  It has GHC which is quite large.
05:04:26 <byorgey> 112MB doesn't seem that big to me anyway.
05:04:43 <bootcode> mrout: libs developed by others. Like lens, transformers, graphics, etc.
05:04:56 <mrout> byorgey: well i have cable, and it took 8 minutes to download.
05:05:05 <byorgey> the Haskell platform doesn't have lens.
05:05:08 <Taneb> There's a compression library, a software transactional memory library, a serialization library, a graph theory library, a GUI library, and a whole bunch of others
05:05:21 <mrout> Ahh, excellent. Thanks guys.
05:05:23 <bootcode> byorgey: my bad, sorry
05:05:29 <byorgey> mrout: here are all the libraries that come with the Haskell platform: http://lambda.haskell.org/platform/doc/current/frames.html
05:06:06 <bootcode> mrout: also, with cabal you get better using cabal-dev (which I don't know) or hsenv to isolate the packages to a local (per-project) scope
05:06:09 <mcstar> btw, whats the benefit of Haskell Platform over ghc + cabal? i never used it...
05:06:23 <mrout> mcstar: from the sounds of it, the packages
05:06:30 <bootcode> mcstar: it has a nice webpage
05:06:34 <bootcode> :)
05:07:00 <mcstar> the question is, does it help with version mismatches?
05:07:04 <Taneb> mcstar, it's regarded as the "stable version"
05:07:07 <mcstar> is it like debian?
05:07:30 <Taneb> It's got a whole bunch of libraries that are good enough to be considered standard
05:07:33 <bootcode> mcstar: not really as I experienced
05:07:49 <bootcode> mcstar: (regarding version mismatches)
05:08:08 <mrout> eww debian stable.
05:08:15 <mcstar> thats what i meant
05:08:26 <byorgey> bootcode, mcstar: yes, it does help with version mismatches, at least for the packages which are included.
05:08:54 <mcstar> the only headache with haskell so far, is the occasional rebuild of the installed packages
05:08:57 <bootcode> byorgey: interesting, could you elaborate?
05:09:18 <mrout> bootcode: well presumably it contains a whole lot of compatible packages?
05:09:27 <byorgey> bootcode: it includes particular versions of a particular set of packages which have been tested to work together.
05:09:39 <byorgey> so you are guaranteed to get those packages working out of the box.
05:09:43 <mrout> s/compatible packages/compatible versions of packages/
05:09:54 <byorgey> if you installed them manually you might or might not, depending on the current state of the latest versions.
05:10:49 <mrout> How does Haskell do IO if functions can‚Äôt have side effects?
05:11:10 <mcstar> they can have, actually
05:11:18 <companion_cube> mrout: by creating values that describe how to perform side effects
05:11:28 <companion_cube> the side effects are then performed by the runtime
05:11:37 <bootcode> mrout: Haskell main gives you an IO _plan_, which is then executed
05:11:54 <mrout> mcstar: o.O what. i thought it was purely functional.
05:12:00 <bootcode> mrout: creating the plan is side-effect free
05:12:16 <mrout> companion_cube: that SORT OF makes sense? I suppose? haha
05:12:18 <Eelis> of the three answers, i'll nominate bootcode's as the best one :)
05:12:20 <companion_cube> mcstar: are you talking about unsafePerformIO and such?
05:12:25 <mcstar> yes
05:12:33 <companion_cube> oh, but that's cheating :)
05:12:47 <catsbydlo> is unsafePerformIO even Haskell?
05:12:50 <bootcode> Eelis: I nominate someone who put it this way who I can't remember
05:12:59 <catsbydlo> how does it semant?
05:13:13 <companion_cube> IO a -> a
05:13:16 <companion_cube> :D
05:13:19 <Taneb> catsbydlo, it's GHC, and it's nasty
05:13:46 <Eelis> and yet it's encouraged for certain common tasks
05:13:49 <Taneb> It's the function in Haskell I'm most scared to use
05:14:05 <mcstar> can somebody tell me/refer me to the history of the State monad?
05:14:06 <shachaf> Taneb: More than reallyUnsafePtrEquality# ?
05:14:33 <Taneb> shachaf, that goes past scary and into hilarious
05:14:36 <Taneb> My brain works weird
05:15:03 <Taneb> It's like a man waving outside a cave screaming "don't go in here! It's not safe!" to anyone who walks past
05:15:59 <mcstar> did the State monad exist, before there were monads in haskell?
05:16:05 <bootcode> mcstar: maybe it was introduced in a monad paper?
05:16:08 <mcstar> (in some form or another)
05:16:25 <catsbydlo> mcstar: the technique itself is pretty obvious
05:16:27 <mrout> what‚Äôs a monad? wikipedia‚Äôs explanation is pitiful
05:16:31 <catsbydlo> (I invented it myself)
05:16:40 <Taneb> mrout, don't worry about them
05:16:53 <catsbydlo> formalizing it and recognizing the abstract pattern less so
05:16:55 <Taneb> They're the big scary thing in haskell that when you get close to them turns out to be tiny
05:17:05 <mcstar> catsbydlo: i think it is ingenious
05:17:05 <catsbydlo> ooh, I know that book!
05:17:06 <Taneb> Learn You a Haskell gets to them later on
05:17:14 <mrout> Taneb: yeah, but what‚Äôs a monad? :P
05:17:25 <Taneb> It's a monoid in the category of endofunctors
05:17:25 <catsbydlo> mrout: in Haskell or in math?
05:17:43 <mrout> in #Haskell and therefore in Haskell.
05:17:54 <catsbydlo> mrout: non sequitur
05:17:59 <catsbydlo> #haskell often talks about math
05:18:05 <mcstar> the generality of monads and the do notation is impressive
05:18:19 <shachaf> Have you read the FAQ, mrout?
05:18:22 <shachaf> @where faq
05:18:22 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
05:18:29 <mcstar> it is like discovering a new piece of physics
05:18:36 <catsbydlo> a monad in Haskell is an instance of the Monad class
05:18:42 <mcstar> hard to believe that someone did that on purpose
05:18:53 <mrout> catsbydlo: still, it‚Äôs not an unreasonable to expect that in #haskell, questions are about Haskell
05:19:34 <mrout> are they related concepts, though?
05:20:15 <catsbydlo> yes
05:20:30 <Taneb> A lot of Haskell is named for bits of category theory
05:21:09 <mcstar> catsbydlo: when you said, you invented it yourself, do you mean, you abstracted the monad, that is a coputation(function) that takes a state and returns a result and a new state, and formalized the composition of such things?
05:21:19 <mcstar> did you invent it outside of haskell?
05:21:25 <bootcode> mrout: for me understand monads was easier with monadiv funtions, which are of the form a -> m b
05:21:26 <mcstar> or just what did you mean?
05:21:34 <catsbydlo> mcstar: no, I wrote stateful purely functional code by returning tuples
05:21:40 <catsbydlo> outside of haskell
05:22:02 <catsbydlo> e.g. I actually wrote a parser that was basically String -> (a, String)
05:22:06 <bootcode> mrout: if you have f ::  a -> m b, and g :: b -> m c, you can't do (g . f) to compose them
05:22:25 <shachaf> Here we go again...
05:22:31 <catsbydlo> and I did it this way because the language didn't have pointers and I wanted to know what the inner parsers consumed
05:22:32 <bootcode> mrout: but if m is a monad (conforms to some contract), then you can compose
05:22:46 <bootcode> which is fun :)
05:22:55 <mrout> bootcode: that‚Äôs what a monad DOES. Not what it IS, or HOW it does it.
05:23:10 <catsbydlo> heh
05:23:26 <Taneb> mrout, a monad is an interface
05:23:27 <bootcode> from programmer view, it is just an API, isn't it?
05:23:30 <catsbydlo> mrout: a monad is a type constructor that supports two operations
05:23:38 <catsbydlo> how? well, you define two functions
05:23:39 <bootcode> with some nice guarantees
05:23:39 <Taneb> There a lot of different monads that work completely differently
05:24:01 <mrout> I think I‚Äôll just play with them and work out what they do.
05:24:08 <catsbydlo> the "magic" is in the code you write, not the fact that it conforms to the Monad interface
05:24:09 <shachaf> Did you read the FAQ yet?
05:24:12 <mcstar> what are the guarantees?
05:24:25 <mcstar> you have to make sure of them in each case
05:24:29 <mcstar> it is not a given
05:24:30 <bootcode> mrout: read the typeclassopedia, it is fun
05:25:20 <mcstar> catsbydlo: what was your vehicle of choice for that code?
05:25:24 <mcstar> (language)
05:25:28 <catsbydlo> heh
05:25:44 <catsbydlo> an esoteric toy language I invented myself
05:26:10 <catsbydlo> I was like "I know some C and interpreters are pretty cool, let's write a scripting language!"
05:27:40 <bootcode> mrout: the most accessible monad instance is probably Either (well, after Maybe, which is less spectacular)
05:27:45 <catsbydlo> I wanted to write a command line calculator. I knew how to do it in C with a set of mutually recursive functions incrementing a char * to step through the input
05:27:57 <bootcode> mrout: with it you can compose functions which handle errors
05:28:30 <catsbydlo> my scripting language didn't have anything like pointers (in fact, no deep mutability)
05:28:54 <catsbydlo> it could only mutate plain variables
05:29:01 <catsbydlo> so I had to pass tuples around
05:29:22 <shachaf> bootcode: The next step after "understanding monads" is "understanding what not to say to people who are asking questions about monads".
05:29:25 <shachaf> Did you read
05:29:26 <qnikst> is it possible to make automatic `toEnum' call when making a ffi wrapper?
05:29:29 <shachaf> @where burrito
05:29:29 <lambdabot> http://byorgey.wordpress.com/2009/01/12/abstraction-intuition-and-the-monad-tutorial-fallacy/
05:29:36 <bootcode> shachaf: Is there a tutorial about that? :)
05:29:57 <bootcode> shachaf: Did. But then we just all sit in silence then?
05:30:14 <bootcode> What is a monad? I know but won't tell about it, find out yourself :P
05:30:19 <mcstar> i think there is no easy answer to what is a monad, but if you read LYAH from cover to cover, i think you will have an idea
05:30:38 <catsbydlo> there is an easy answer but it requires some other bits of knowledge
05:30:51 <mcstar> well, lets assume none
05:30:51 <catsbydlo> such as a basic understanding of haskell's type system and classes in general
05:30:54 <mrout> bootcode: Maybe seems pretty unwhelming
05:31:08 <catsbydlo> mrout: congratulations, you understand monads
05:31:10 <qnikst> if I'm making type F = Int -> IO () and foreign import ccall "wrapper" mkF :: F -> (FunPtr F), then i can use toEnum in function, but if i change type to type F = AEnum -> IO (), I have a type error
05:31:17 <mcstar> and lets assume, they want to know the stuff thats useful for haskell coding
05:31:24 <mrout> it‚Äôs basically a way of saying ‚Äúthis might not actually be an Integer‚Äù
05:31:38 <mcstar> what is unwhelming?
05:31:44 <zomg> mrout: Maybe is pretty cool when you chain multiple things though =)
05:31:52 <catsbydlo> somewhere between underwhelming and overwhelming?
05:32:01 <mrout> mcstar: they‚Äôre a rather... hyped up concept, that doesn‚Äôt actually seem that complicated.
05:32:06 <mrout> *underwhelming
05:32:08 <mcstar> it is cool when you want deep first search
05:32:25 <Eelis> i think the key to teaching people monads is to never ever ever utter the word "monad" until they've written a bunch themselves already. then you go "oh, nice monad you wrote there", and it's done
05:32:39 <mrout> mcstar: what‚Äôs deep first search? somewhere between depth first search and breadth first search?
05:32:49 <mcstar> yes
05:32:57 <zomg> Eelis: or stop trying to categorize them as boxes or whatever
05:33:10 <Eelis> zomg: yeah, concrete examples are the way to go
05:33:13 <mcstar> it would not have been funy if i had written DFS
05:33:28 <catsbydlo> nice monad you've got there. would be a shame if anything happened to it, wouldn't it?
05:33:50 <bootcode> a monad is like a giant hedgehog
05:33:55 <zomg> I mean it shouldn't be hard to understand if you say that monads are just data types that share certain behaviors (eg. they can be chained or whatever)
05:34:02 <Eelis> or really it would be "oh, nice monad you wrote there. you should make it an instance of the Monad class, then you get neat/weird stuff like liftM3 for free ^_^"
05:34:05 <zomg> I'm sure someone could articulate that better, that's just off the top of my head
05:34:22 <mcstar> 'monad is the only thing, that "do notations" is good for', thats it
05:34:25 <mcstar> -s
05:34:37 <Eelis> "programmable semicolon" is a nice description i think
05:34:41 <shachaf> I wonder whether mrout has read the FAQ yet.
05:34:52 <mrout> shachaf: I have. why are you so insistent about it?
05:34:55 <shachaf> The FAQ has much better answers to these questions than what the channel typically gives.
05:34:57 <zomg> Eelis: Nice if you actually understand monads, if you don't then it isn't ;>
05:35:11 <Eelis> zomg: yes, hence my earlier advice
05:35:17 <shachaf> mrout: Did you read section 8?
05:35:45 <mcstar> the m-word
05:35:58 <mcstar> probably stand for meta
05:36:26 <mrout> yes, I did
05:37:42 <chrisdone> anyone done any work in having your hoogle database update every time you install a new cabal package?
05:37:59 <mrout> you see ‚Äú(>>=) :: m a -> (a -> m b) -> m b‚Äù means nothing to me.
05:38:20 <mcstar> you call it 'bind' if that helps
05:38:21 <shachaf> mrout: Did you read section 8.3 *past* that line?
05:38:27 <mrout> shachaf: yes
05:38:36 <Eelis> i don't get why the public hoogle doesn't just index all hackage packages
05:38:45 <mcstar> btw, how do you say <*> ?
05:39:02 <chrisdone> no idea
05:39:03 <bootcode> app?
05:39:06 <`ramses> mrout: am I correct that you are reading lyah? If so, I'd just keep on reading, the book introduces monads at the right time, after you've learned about the necessary abstractions to be able to understand them without too much effort
05:39:29 <`ramses> mcstar: app or apply (it is the same as ap in monad)
05:40:02 <mrout> `ramses: yeah, fair enough. that‚Äôs probably the best idea
05:40:11 <mcstar> ty
05:40:28 <`ramses> mrout: trying to skip the other stuff and jump straight to monad is a bad idea, monads are not that complicated once you've grasped functors and applicatives
05:41:37 <`ramses> while they probably are pretty confusing without the needed prior knowledge :)
05:41:41 <bootcode> after LYAH applicatives, monads feel like sunshine :)
05:41:50 <mrout> `ramses: hence ‚Äòneeded‚Äô :P
05:41:50 <chrisdone> agreed, the problem of understanding monads is the problem of being competent with hakell's type system
05:42:37 <`ramses> chrisdone: and having done the mental effort to grasp functors and applicatives
05:43:04 <chrisdone> i don't think that, but it can't hurt either
05:43:17 <`ramses> I think going functor -> applicative -> monad introduces manageable extra levels of abstraction at every step
05:43:24 <`ramses> without being overwhelming
05:43:51 <mcstar> does LYAH deal with monad transformers?
05:43:59 <`ramses> and functor -> applicative is imho harder then applicative -> monad (if you really understand aplicative)
05:44:10 <`ramses> mcstar: no
05:44:30 <hpaste> qnikst pasted ‚Äúhow to use enum in foreign wrapper‚Äù at http://hpaste.org/79880
05:44:56 <qnikst> can smb help me with making foreign wrapper for function with enum? ^^
05:46:23 <mcstar> the function instances were always enlightening to me
05:46:28 <mcstar> a bit at least
05:47:12 <mcstar> (i mean, instances of functor, applicative, monad)
05:48:26 <chrisdone> i'd like to experiment with giving a haskell newbie the original monad and applicative papers
05:49:13 <mcstar> "In GHC, STRef and IORef will behave the same way at runtime. The difference is the extra compile-time safety checking associated with runST."
05:49:21 <zomg> chrisdone: he'd probably need to be some sort of math nerd to understand those
05:49:22 <zomg> :D
05:49:24 <chrisdone> because those papers aren't written by people who've already learned monads with all the bias and assumed information, they're written by people who /invented/ the idea, so they have to justify what's so great, what it was like before, etc.
05:49:26 <mcstar> what does this mean? whats that extra safety?
05:49:32 <zomg> If they are anything like the other haskell related papers I've seen..
05:49:53 <chrisdone> zomg: nah, they are in plain english, very very readable
05:50:22 <`ramses> mcstar: (<*>) is pretty subtle for ((->) r), if you go beyond the usual f <$> g <*> h
05:50:59 <mcstar> i didnt go beyond, but it is nice, how it gives you a different kind of function compisition
05:51:31 <mcstar> whats the extra safety that runST provides?
05:51:51 <mcstar> maybe shachaf knows...
05:52:10 <shachaf> mrout: ?
05:52:16 <chrisdone> zomg: here's the original monads paper http://homepages.inf.ed.ac.uk/wadler/papers/marktoberdorf/baastad.pdf and the original applicative paper http://www.soi.city.ac.uk/~ross/papers/Applicative.pdf
05:52:45 <`ramses> mcstar: indeed, but you can also view it in the light of SKI calculus, that gives some very nice extra depth to the instance
05:53:34 <catsbydlo> mcstar: well, there's the fact that runST exists at all
05:53:48 <catsbydlo> the safety is the guarantee that you can't use it wrong
05:54:01 <mcstar> how so?
05:54:03 <mrout> shachaf: what?
05:54:11 <mcstar> i know it is a self-contained mutable computation
05:54:16 <shachaf> mrout: That was meant to be mcstar.
05:54:17 <mcstar> that doesnt really mess with the outside world
05:54:45 <catsbydlo> mcstar: imagine you could runST (newSTRef 42)
05:54:50 <mcstar> shachaf: oh, dear sir, i just wondered if you could tell me the answer to my question
05:54:58 <mcstar> but didnt have the courage to ask you personally
05:55:25 <shachaf> What question?
05:55:43 <mcstar> "In GHC, STRef and IORef will behave the same way at runtime. The difference is the extra compile-time safety checking associated with runST."
05:55:59 <mcstar> what safety does that sentence refer to?
05:56:18 <shachaf> Well, runST will let you make pure functions that use mutation internally.
05:56:40 <catsbydlo> runST is safe, unsafePerformIO is not
05:56:40 <mcstar> yes, thats clear
05:56:55 <mcstar> why is it safer than doing the whole thing in IO?
05:57:01 <tdammers> because you don't have to carry the IO monad around with you just to do mutations
05:57:03 <mcstar> (since it compares it to IORef)
05:57:08 <tdammers> IO basically means "anything can happen"
05:57:29 <mcstar> ah, right, i get it
05:57:43 <mcstar> ok
05:58:56 <mrout> Haskell doesn‚Äôt seem to be very purely functional, from the conversation you‚Äôre having
05:59:19 <mcstar> if you have read the FAQ you wouldnt say that
05:59:22 <catsbydlo> mrout: but it is
05:59:25 <chrisdone> unsafePerformIO is safe given a safe expression to execute, tho
05:59:51 <chrisdone> runST could probably be unsafePerformIO and STRef implemented with an IORef and you'd be fine
05:59:59 <mrout> @where faq
06:00:00 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
06:00:29 <catsbydlo> yes, I think you can simply replace STRef by IORef and runST by unsafePerformIO in all working code
06:00:46 <catsbydlo> the difference is that it is impossible to get runST wrong
06:00:51 <chrisdone> iirc it's a speed optimization that it's not implemented like that
06:00:59 <catsbydlo> whereas it's very easy to shoot yourself in the foot with unsafePerformIO
06:01:07 <mrout> whether or not you can call certain subsets of its functionality purely functional is irrelevant.
06:01:08 <chrisdone> nod
06:01:28 <catsbydlo> mrout: what about supersets?
06:01:30 <mrout> the fact is that if the ENTIRE language is not purely functional, then it‚Äôs not purely functional
06:01:42 <chrisdone> well it's not irrelevant to the unsafePerformIO "is unsafe" claim, that makes it sound like it's always going to break stuff
06:01:43 <mcstar> "Haskell programs are pure-functional programs which compute imperative programs."
06:01:58 <catsbydlo> mrout: I disagree, actually
06:02:21 <mrout> you can‚Äôt just exclude arbitrary sets of functionality and say ‚Äúit‚Äôs functional if you ignore these bits‚Äù
06:02:27 <catsbydlo> yes, I can
06:02:41 <catsbydlo> also, I'm not excluding arbitrary subsets; I'm excluding unsafePerformIO
06:02:42 <mrout> You could argue C or something was pure functional because you can write functions that have no side effects.
06:02:51 <catsbydlo> yes, but that argument would suck
06:02:51 <mrout> catsbydlo: seems arbitrary to me
06:03:00 <mcstar> you can use unsafePerformIO in a referentially transparent way
06:03:01 <mrout> and yours doesn‚Äôt?
06:03:08 <catsbydlo> mrout: dude, the "unsafe" is right there in the name
06:03:11 <mrout> why, because it‚Äôs Haskell and you prefer Haskell to C?
06:03:28 <catsbydlo> no, because it's a single library function that isn't even part of the language proper
06:03:29 <mrout> oh, so if you label all the non-functional bits, it‚Äôs still a purely functional language?
06:03:53 <catsbydlo> again, we're not talking about "all the bits", we're talking about a single backdoor into the runtime system
06:04:09 <mrout> purely functional implies it‚Äôs PURELY functional
06:04:15 <mrout> you can call it functional, but not PURELY functional
06:04:41 <catsbydlo> "Haskell" as defined by the language standard does not contain unsafePerformIO, thus it's purely functional
06:04:47 <Eelis> 99% purely!
06:04:48 <chrisdone> oh, you're talking about something else. n/m
06:04:48 <chrisdone> mrout: you can view haskell as a pure, expression-producing language
06:05:17 <mrout> :/
06:05:27 <chrisdone> mrout: technically all haskell expressions are pure
06:05:44 <chrisdone> mrout: what's the difference between the ST monad and the IO monad that makes one pure and one not pure?
06:06:02 <catsbydlo> all monads are pure. that question makes no sense.
06:06:13 <mrout> chrisdone: you lot JUST SAID that unsafePerformIO, or whatever is not purely functional. it has side effects.
06:06:39 <Eelis> yeah, bending over backwards to see unsafePerformIO as "pure" is pretty cynical i think
06:06:46 <catsbydlo> who is doing that?
06:07:06 <chrisdone> mrout: unsafePerformIO is just another pure expression. what's the value of ‚ÄúunsafePerformIO launchMissiles‚Äù?
06:07:12 <Eelis> catsbydlo: ^
06:07:18 <catsbydlo> ok, chrisdone is wrong
06:07:48 <chrisdone> catsbydlo: if i implement unsafePerformST, is what pure or impure?
06:08:00 <mcstar> runST
06:08:08 <chrisdone> no, not runST
06:08:12 <catsbydlo> chrisdone: depends. what is its type and what does it do?
06:08:13 <chrisdone> unsafePerformST :: ST a -> a
06:08:20 <mcstar> :t runSt
06:08:22 <lambdabot>     Not in scope: `runSt'
06:08:22 <lambdabot>     Perhaps you meant `runST' (imported from Control.Monad.ST)
06:08:24 <mcstar> :t runST
06:08:25 <lambdabot> (forall s. ST s a) -> a
06:09:05 <chrisdone> perfect
06:09:07 <catsbydlo> chrisdone: unsafePerformST :: ST s a -> a?
06:09:08 <mrout> chrisdone: unsafePerformIO :: IO a -> a <== is this a correct definition
06:09:15 <chrisdone> i'm trying to show how they're the same and you point it out
06:09:18 <shachaf> That's not a definition.
06:09:22 <mrout> you know what I mean
06:09:26 <mrout> is that what it does?
06:09:26 <shachaf> I don't.
06:09:31 <mrout> it does IO a -> a
06:09:33 <shachaf> That's not a specification either.
06:09:35 <catsbydlo> mrout: you know what  the answer is
06:09:36 <shachaf> That's its type.
06:09:42 <shachaf> What it "does" is a harder question.
06:10:07 <mrout> the point is, if it is IO a -> a then it‚Äôs stupid. see the FAW
06:10:08 <mrout> FAQ
06:10:21 <catsbydlo> it is stupid
06:10:27 <catsbydlo> but fortunately it doesn't exist
06:10:30 <mrout> http://www.haskell.org/haskellwiki/FAQ#How_do_I_convert_IO_Int_to_Int.3F
06:10:50 <parcs> how do i convert IO Int to IO?
06:11:03 <mrout> parcs: What
06:11:12 <mcstar> i <- getInt
06:11:37 <catsbydlo> > let (_ : b :  _ : a : _) = "IO Int" in [a,b]
06:11:39 <lambdabot>   "IO"
06:11:53 <mcstar> lol, wrong
06:12:17 <chrisdone> <catsbydlo> all monads are pure. that question makes no sense. ‚Äî that was the point =)
06:12:26 <d-snp> hi, if I have function :: a -> b -> c, I couldn't pass it a :: a -> b to get a c right?
06:12:44 <catsbydlo> chrisdone: what point? and what does it have to do with unsafePerformIO?
06:12:48 <parcs> d-snp: nope
06:13:05 <chrisdone> catsbydlo: by "all monads are pure" you mean "all monadic expressions are pure", right?
06:13:09 <catsbydlo> d-snp: a -> b -> c means (a -> (b -> c))
06:13:18 <d-snp> right, thanks :)
06:13:23 <parcs> a -> b -> c = a -> (b -> c) not (a -> b) -> c
06:13:40 <catsbydlo> chrisdone: I think I meant all monadic operations but that's probably the same thing
06:13:54 <chrisdone> catsbydlo: er, what's a monadic operation?
06:14:06 <catsbydlo> >>= and return
06:14:07 <d-snp> I was thinking of a library design, and it needs configuration, and I realized that currying configuration is a trap
06:14:10 <parcs> @djinn (a -> b -> c) -> (a -> b) -> a -> c
06:14:11 <lambdabot> f a b c = a c (b c)
06:14:21 <mcstar> i wonder why mrout tried to argue before he understood more of the language
06:14:44 <d-snp> or is it..
06:14:45 <d-snp> hmm
06:15:42 <mcstar> it is like saying, haskell cant be pure, since it has a runtime that runs on a real computer
06:15:58 <Philippa> catsbydlo: ain't nothing pure about /executing/ >>= :: IO a -> (a -> IO b) -> IO b
06:16:07 <d-snp> running software on real computers is so 2012
06:16:33 <shachaf> Philippa: I wouldn't say that (>>=) is executed.
06:16:42 <shachaf> Philippa: The "IO b" that it gives you is executed.
06:17:01 <chrisdone> splitting hairs a bit, but ja
06:17:26 <Eelis> as long as functions produce outputs in IO, purity is kinda moot since IO is inscrutible anyway
06:17:27 <Philippa> shachaf: fine, have a saturated application of it
06:17:31 <mcstar> you cant really execute it, afaik, it is a transformation
06:17:43 <mcstar> you build up a program with it
06:17:47 <d-snp> the >>= is evaluated to construct the monad, with expressions that are executed when the monad is evaluated
06:17:59 <Philippa> mcstar: there is most certainly a sense in which it can be executed. Go write an interpreter with an IO monad
06:18:03 <catsbydlo> Philippa: yes, hence it is crucial that you can't execute in Haskell
06:18:23 <Philippa> catsbydlo: OTOH, a Haskell program is defined by that execution
06:18:34 <Philippa> (specifically, of Main.main)
06:18:38 <d-snp> oh wait, the expressions are not executed, they are also evaluated, but the results of the evaluations are hints to haskell to execute side effects..
06:18:45 <chrisdone> yeah i think we're all on the same agreement if not on the same terms
06:18:47 <d-snp> ok nvm I'm complicating you guys :P
06:18:59 <mm_freak_m> It's not really splitting hairs, because (>>=) is evaluated. No execution is done there.
06:19:05 <chrisdone> needs more denotational semantics
06:19:31 <Philippa> mm_freak_: it's evaluated during its execution! Nothing else can demand it
06:19:43 <mm_freak_m> In fact the IO monad relies heavily on laziness.
06:19:54 <mm_freak_m> Sure.
06:20:58 <Philippa> (we are mostly, of course, using "evaluating f" to mean "evaluating a [saturated] application of f" here)
06:21:14 <chrisdone> Philippa: sorry, what's ‚Äúsatured‚Äù?
06:21:24 <chrisdone> er, saturated. haha
06:21:37 <Philippa> chrisdone: one parameter for each lambda at f's head
06:22:01 <chrisdone> nice word, i'll keep that
06:22:30 <Eelis> does it also work for constructors?
06:23:35 <mcstar> i dont really understand what saturated means
06:23:51 <catsbydlo> filling all available holes
06:23:57 <nus> @src id
06:23:57 <lambdabot> id x = x
06:24:09 <nus> @type seq
06:24:10 <lambdabot> a -> b -> b
06:24:13 <mcstar> every parameter of f is evaluated?
06:24:20 <mcstar> (already)
06:25:03 <catsbydlo> not necessarily
06:25:24 <mcstar> a saturated f is not a lambda, is that it?
06:25:39 <Philippa> Eelis: yeah. Better defined in terms of -> than lambda
06:25:52 <Philippa> (assume the lambda definition is for the untyped lambda calculus!)
06:25:55 <chrisdone> (\x -> \(y -> ‚Ä¶)) a b ‚Üê satured?
06:26:04 <catsbydlo> id x y
06:26:05 <chrisdone> why can't i spell saturated ·Éö(‡≤†Áõä‡≤†·Éö)
06:26:11 <Eelis> Philippa: ah ok, thanks
06:26:13 <Philippa> chrisdone: where ... is not another \, yeah
06:26:40 <Philippa> mcstar: f is just applied to every parm it wants/needs
06:27:05 <mcstar> ok, but what if the arguments are functions themselfes?
06:27:10 <Philippa> (so for example, if f is a constructor then you can skip straight to constructing rather than doing unary eval/apply or whatever on it)
06:27:41 <Philippa> mcstar: that's fine. We already defined what f is in saying it's saturated, and there's a spine of applications putting things in place
06:27:50 <Guest21672> !list
06:27:50 <monochrom> Guest21672: http://okmij.org/ftp
06:28:05 <mcstar> trap
06:29:32 <chrisdone> why did i write documentation on my hackage package. i'm quite sure not one person read it :p
06:30:01 <Taneb> Which package?
06:30:04 <Philippa> heh. So my github repo is not going on hackage until I have docs for it? But it involves enough type classes that the term 'framework' isn't totally inapplicable
06:30:37 <chrisdone> Philippa: i discovered that hoogle can show documentation of names =o which is both awesome (yay!) and ‚Äúoh‚Ä¶‚Äù after the evening's worth of work i did D: i just need to figure out a way to make Cabal automatically regenerate the hoogle database whenever i install a package
06:30:39 <mcstar> @neg "isn't totally inapplicable"
06:30:39 <lambdabot> Maybe you meant: bug let msg
06:30:49 <chrisdone> Taneb: http://hackage.haskell.org/package/haskell-docs
06:31:11 <mcstar> oh, i meant @un-neg probably
06:31:42 <mcstar> 'is slightly applicable'
06:32:23 <Philippa> mcstar: that only works if you ignore double-negation as a cue for understatement, anyway
06:32:32 <mcstar> :)
06:32:36 <mcstar> is totally applicable
06:33:22 <catsbydlo> one litotes, please
06:33:30 <Philippa> yeah. A lot of it's near-standard functorial stuff with domain-specific names at the moment, for example
06:33:56 <catsbydlo> unsafePerformFunctor
06:34:28 <mcstar> catsbydlo: thx for the word
06:34:33 <mcstar> weird pronunciation
06:36:25 <mcstar> i like this one:
06:36:27 <mcstar> "He's no oil painting."
06:36:36 <mcstar> meaning "He's ugly."
06:37:49 <Taneb> Where do I complain about diagrams?
06:37:53 <YunxBOT1830> Guest9041
06:38:56 <shachaf> Taneb: #diagrams?
06:39:07 <shachaf> I guess you found it.
06:39:17 <Taneb> Yeah
06:39:43 <neutrino_> hello
06:40:00 <YunxBOT1830> xinming_
06:40:51 <catsbydlo> YunxBOT1830: it is time to pass the turing test
06:40:55 <mcstar> heh
06:41:19 <mcstar> Where do I complain about YunxBOT1830?
06:41:33 <neutrino_> @where ops
06:41:33 <lambdabot> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
06:41:37 <YunxBOT1830> catsbydlo Hello! ^&^
06:41:39 <Taneb> I really need to find a nicer way to ask that
06:41:42 <neutrino_> there you do
06:42:20 <YunxBOT1830> catsbydlo How do you do!
06:42:38 <catsbydlo> hmm, pretty convincing
06:42:43 <mcstar> catsbydlo: would you pipe YunxBOT1830 to emacs' psychotherapist?
06:42:43 <neutrino_> YunxBOT1830: what is the topic of discussion in this channel?
06:43:02 <catsbydlo> mcstar: can't, don't have emacs
06:43:31 <YunxBOT1830> catsbydlo Nice to meet you!
06:43:49 <neutrino_> so this chat bot is not even a markov bot
06:43:54 <neutrino_> how quaint
06:44:06 <mcstar> it is so slow
06:44:22 <neutrino_> it's probably running from siberia or something
06:44:26 <mcstar> maybe it is a real human
06:44:30 <neutrino_> s/from/out of/
06:44:44 <YunxBOT1830> catsbydlo Where are you from?
06:44:46 <catsbydlo> YunxBOT1830: What difference does it make if I ?
06:45:06 <catsbydlo> YunxBOT1830: How about staying with you?
06:45:33 <mcstar> cant do that, i dont have free rooms
06:46:05 <YunxBOT1830> catsbydlo Could you speak it in chinese?
06:46:06 <neutrino_> mcstar: maybe it is on a computer run on steam and uses trinary deontic logic with lots of don't cares
06:46:10 <YunxBOT1830> catsbydlo My English is poor...
06:46:36 <catsbydlo> test passed.
06:46:37 <mcstar> oh, chinese, i feel hungry already
06:46:43 <chrisdone> mcstar: try this one "i could care less"
06:46:52 <catsbydlo> mcstar: do not eat the chinese; they are our friends
06:46:52 <neutrino_> i've just @told a message to quchen, mcstar
06:47:03 <neutrino_> his nickname means "cake" :(
06:47:15 <catsbydlo> "qake"
06:49:02 <YunxBOT1830> catsbydlo Good luck!
06:50:30 <YunxBOT1830> catsbydlo Nice to see you!
06:50:40 <YunxBOT1830> catsbydlo Sorry, I'm leaving
06:50:46 <mcstar> wtf? is he at your window?
06:51:14 * mcstar imagines Bourne looking into the scope, seeing Pamela
06:51:52 <catsbydlo> typing into his shell
06:58:02 <chrisdone> Eelis: in answer to your question earlier
06:58:03 <chrisdone> Bug 79: The other work is to index all the packages on Hackage. The problem here is generating the textbases, once they have been created the rest is fairly simple. However, to run Haddock 2 over a package requires that the package builds, and that all the dependencies are present. Unfortunatley my machine is not powerful enough to cope with the number of packages on Hackage. Hopefully at some point the machinery that builds Haddock
06:58:03 <chrisdone> documentation for Hackage will also generate textbases, however in the mean time if someone wants to take on the task of generating textbases for Hackage, please get in contact.
06:58:05 <chrisdone> http://neilmitchell.blogspot.it/2008/08/hoogle-database-generation.html
07:07:52 <chrisdone> anyone controlled a quadcopter from haskell?
07:11:30 <mcstar> a virtual one?
07:12:20 <neutrino_> chrisdone: define "from haskell"
07:12:50 <mcstar> i guess it is a building on the campus
07:14:27 <mcstar> what happened to Miranda? was it doomed, because it was closed source?
07:14:37 <mcstar> (is it?)
07:15:07 <mcstar> everywhere it is mentioned, there is a trademark notice
07:16:19 <mreh> I started learning FP in miranda
07:16:35 <mreh> there are a few textbooks written for miranda, one by my lecturer
07:17:00 <mreh> Haskell pretty much uses the same syntax, so it lives on
07:20:09 <applicative> mreh: one of the miranda books, or maybe two, were turned to haskell books. Bird and Wadler for example?
07:20:50 <mreh> applicative, I used this one: http://www.amazon.com/Programming-With-Miranda-Chris-Clack/dp/013192592X
07:20:51 <applicative> that the academic papers mention the trademark is truly insane.
07:21:13 <chrisdone> so how do you guys lookup documentation of stuff when you're coding in haskell?
07:21:13 <mcstar> so what, they copied miranda, when they were making up haskell for the first time?
07:21:26 * hackagebot family-tree 0.3.0.2 - A family tree library for the Haskell programming language.  http://hackage.haskell.org/package/family-tree-0.3.0.2 (NathanVanDoorn)
07:21:26 <mcstar> is it like cloning unix to make gnu?
07:21:27 <chrisdone> i tend to google the module name and search down the page for the function
07:21:31 <mreh> chrisdone, hoogle?
07:21:42 <t7> gnu is not unix
07:21:48 <mcstar> yes
07:21:52 <chrisdone> mreh: you use hoogle for all library functions, including hackage?
07:21:54 <mcstar> but similar
07:22:20 <mreh> chrisdone, it seems to work okay for hackage libraries
07:22:30 <t7> mcstar: yeah haskell was an evolution of miranda if i remember my history
07:22:55 <mreh> wasn't there some dispute about the copyright of the syntax?
07:23:00 <mcstar> i just open my documentation bookmarks for the docs on my machine
07:23:02 <t7> it pains me to think how people did equality without type classes
07:23:02 <mreh> if it's possible to do such a thing
07:25:44 <mreh> .cabal/share/doc/ contains all your locally installed libs
07:25:45 <applicative> t7 if you look a little close in base you see we have eqInt eqFloat eqInt# etc, if I remember how the names are formed
07:25:56 <mreh> where are all the haskell platform ones then?
07:26:05 <t7> yeah but its not polymorphic
07:26:05 <mreh> installed via the package manager
07:26:17 <applicative> where your package manage put them
07:26:41 <mreh> :)
07:27:03 <applicative> if they've been around long enough mreh, you can do like 'locate Control-Monad.html' to find them...
07:28:54 <chrisdone> mreh: how?
07:29:20 <catsbydlo> ‡≤†_‡≤†
07:29:43 <chrisdone> wait, i think i have someone on ignore in here as mreh seems to be talking to himself
07:29:45 <mreh> chrisdone, well I tend to recall the function names, but If i'm looking for a specific package which I don't know yet I'll browse hackage
07:30:40 <chrisdone> mreh: no i mean how does it work with hackage packages?
07:30:49 <applicative> mcstar I think it wasa bit like cloning unix to make gnu; I'm not sure what great new ideas that already had ... not typeclasses much less class Monad
07:31:26 * hackagebot JsonGrammar 0.3.3 - Combinators for bidirectional JSON parsing  http://hackage.haskell.org/package/JsonGrammar-0.3.3 (MartijnVanSteenbergen)
07:31:42 <mreh> chrisdone, I don't know for sure, but it has a large number of packages indexed
07:32:12 <applicative> mreh, also some package managers make the docs a separate install; but that would mess with your locally haddocked things
07:32:35 <mreh> applicative, that's why I tend to use hoogle + hackage
07:32:53 <chrisdone> mreh: so does hoogle Data.List.Split.splitWhen work?
07:33:15 <applicative> did you try locate Control.Monad.html ?
07:33:31 <applicative> did you try locate Control_Monad.html , rather
07:33:34 <applicative> damn
07:33:39 <applicative> did you try locate Control-Monad.html , rather
07:33:50 <mreh> applicative, yeah, that worked :)
07:33:50 <applicative> pardon cussin'
07:34:09 <chrisdone> mreh: does it‚ÄΩ
07:34:21 <mreh> chrisdone, I was talking to applicative
07:34:45 <mreh> chrisdone, that package doesn't work
07:35:04 <mreh> maybe I don't use any packages that don't appear on hoogle
07:35:21 <mreh> I'm not sure why it isn't in the index, it seems like a fairly old package
07:35:31 <mreh> you can supposedly run hoogle locally
07:35:35 <mreh> but I never got very far with it
07:36:22 <chrisdone> mreh: ahhhh, you use hoogle *online*, ok. i thought you meant locally, earlier
07:36:26 * hackagebot JsonGrammar 0.3.4 - Combinators for bidirectional JSON parsing  http://hackage.haskell.org/package/JsonGrammar-0.3.4 (MartijnVanSteenbergen)
07:36:54 <chrisdone> so we all basically use hoogle online for stuff that hoogle does, and otherwise we google the package and trawl the docs page manually?
07:37:06 <mreh> chrisdone, unfortunately yes
07:37:16 <catsbydlo> I use hayoo
07:37:37 <mreh> that has Data.List.Split :)
07:37:46 <mreh> but I dislike the interface quite a bit
07:37:58 <applicative> if its  in blahblahblah/ghc/html/libraries/base-4.5.0.0/src/Control-Monad.html then open blahblahblah/ghc/html/index.html
07:38:22 <mreh> cabal also maintains a nice index for you
07:38:39 <mcstar> applicative: i said exactly that a couple of lines above, maybe you didnt see that :)
07:38:46 <mreh> ~/.cabal/share/doc
07:39:03 <applicative> mncstar a sorry
07:39:08 <mcstar> np
07:39:49 <chrisdone> and if you're working offline you do what?
07:40:07 <mcstar> grep
07:40:30 <chrisdone> grep where?
07:40:35 <derdon> ack is much better!
07:40:51 <mcstar> well, you turn on the documentation building flag of cabal
07:41:02 <mreh> mcstar, was just about to say that
07:41:04 <mreh> :)
07:41:04 <derdon> http://betterthangrep.com/
07:41:39 <mcstar> also, if you have a desktop search indexer something application, i guess you can use that too
07:41:52 <mcstar> aka spotlight/strigi/nepomuk whatever they are
07:43:19 * applicative just manage to get his ack to recognize Idris files, finally
07:43:38 <mcstar> i wonder what that is
07:43:40 <mcstar> ack
07:43:52 <mcstar> cant open that page <angryface>
07:44:41 <mcstar> after the system upgrade, ill look it up
07:45:04 <catsbydlo> https://metacpan.org/module/ack
07:45:32 <mcstar> yay, another useless world wide web link
07:45:38 <mcstar> :)
07:49:23 <pnielsen> the Go tool has an option "go doc" that launches a web server with a copy of http://golang.org/pkg/
07:49:42 <pnielsen> the most annoying thing about Haskell docs to me is that everything on Hackage is indexed, so you invariably get doc pages for really old versions of a package when you google e.g. "Data.Map haskell"
07:51:26 * hackagebot ReplicateEffects 0.3 - Composable replication schemes of applicative functors  http://hackage.haskell.org/package/ReplicateEffects-0.3 (MartijnVanSteenbergen)
07:51:33 <applicative> pnielson open ~/.cabal/doc/index.html
07:52:13 <mreh> pnielsen, i'm sure you can run hoogle locally too
07:52:31 <mreh> it wasn't quite working out of the box last time I tried
07:52:41 <mreh> unfortunately
07:53:13 <pnielsen> it would be nice to have a version of the docs part of hackage where it was a bit easier to reach the latest docs, and to mirror it (including locally)
07:53:20 <mcstar> out of context pretty funny: "this paper describes the use of monads in a program tens of lines long"
07:53:45 <pnielsen> sorry, lagging a bit
07:54:00 <applicative> make an alias for firefox ~/.cabal/doc/index.html or whatever pnielson;its the same as the go docs page
07:54:17 <pnielsen> applicative: file not found. I guess you'd have to enable building docs
07:54:29 <applicative> pnielsen, ah yes
07:54:38 <pnielsen> which means rebuilding packages
07:54:43 <applicative> pnielsen I advise it though
07:54:48 <pnielsen> I understand
07:54:49 <applicative> yes,as you say
07:54:59 <pnielsen> just trying to look at the difference in ease-of-use
07:55:02 <pnielsen> requires quite a bit of work to get it
07:55:11 <mcstar> applicative: are you opposed to bookmarks?
07:55:50 <applicative> mcstar: no I was emulating the go goodness pnielsen was mentioning;in fact I use a bookmark, but am just now writing an alias
07:56:13 <mcstar> also, in chromium it is easy to add search engines, not sure about firefoxz
07:56:45 <mcstar> hk searches hackage for me <3
08:03:21 * applicative has verified that it is easy to add hoogle to firefox's searches
08:05:54 <zhulikas> same for chrome too
08:08:25 <chrisdone> so, i was genuinely interested in how you guys looked up docs, but also making a point
08:08:48 <chrisdone> we're actually jumping ridiculous hoops and relying on online, incomplete services to give us documentation
08:09:18 <chrisdone> about time we fix it?
08:10:24 <applicative> well of course chrisdone but there are other things.
08:10:34 <chrisdone> applicative: go on‚Ä¶
08:10:53 <applicative> in fact my preferred study of documentation is just to look at the source in my preferred editor
08:11:34 <Philippa> I'm lazy and mostly stay within the Platform on the assumption it's going to be bad anyway. Which I shouldn't be doing, really
08:12:33 <applicative> I have to say haddock is much better than when I was first learning haskell, you should add it to you cabal/config Philippa
08:12:48 <elliott> i find local haddock useless because it does not generate source links
08:12:52 <applicative> or maybe there was a Dark Period for haddoc
08:12:53 <elliott> when used with cabal-install
08:13:05 <elliott> unfortunately I hear cabal-install is not going to get the ability to pass flags to haddock any time soon
08:13:14 <elliott> (maybe i should write a wrapper haddock script)
08:13:26 <chrisdone> so it's clear that hoogle /can/ give us both search + documentation (and faster than my recent tool, due to parsing the HTML source directly, not dealing with the ghc API + haddock api), so we just need to make sure that for any given cabal package set (-package-conf in ghc/cabal terms), we can query that with hoogle, right?
08:14:04 <applicative> elliott: yes, I use cabal unpack bytestring && editor for that
08:14:04 <chrisdone> (the package conf specifity would mean that cabal-dev could also be supported)
08:14:28 <applicative> elliott: is there maybe a global haddock preference somewhere to do the source?
08:14:36 <Philippa> chrisdone: sounds about right, yeah. That'd be pretty nifty to start just firing up from within ghci
08:14:38 <elliott> applicative: I don't think haddock has a configuration file
08:14:57 <elliott> but I do think you can point cabal-install at another binary to use as haddock and perhaps this could be a wrapper shell script which asks haddock to generate source
08:15:23 * applicative studies
08:16:12 <chrisdone> elliott: hmm, true. access to source is actually another good point
08:16:47 <chrisdone> in SLIME (common lisp IDE) you can access the source of any library you're using by hitting M-. on the function name
08:17:18 <chrisdone> we could achieve that if we had the .hs files lying around
08:17:33 <chrisdone> arguably you'd prefer to open the .hs file directly in your editor than view some pretty printed html for it
08:17:47 <mcstar> slime is like an OS running in an OS running in an OS
08:17:52 <applicative> chrisdone emphatically yes
08:18:03 <chrisdone> slime is very good, i steal a lot of ideas from it =)
08:18:07 <applicative> the colorized source makes sense on the web
08:18:27 <applicative> but .cabal stores the source in a compressed format
08:18:38 <chrisdone> hmm
08:19:01 <applicative> i  tend to keep much used ones uncompressed in a hackage directory
08:19:01 <chrisdone> technically hasktags could be used to do jumping (in emacs and vim), and if another ide, well, they have w/e they have
08:19:23 <chrisdone> right -- perhaps the .tar.gz files stored in ~/.cabal could just be unpacked and then indexed with hasktags?
08:19:30 <chrisdone> and then from your editor you can jump to them
08:20:02 * applicative doesnt know  hastags
08:20:02 <chrisdone> so we add an option to .cabal/config like unpackArchives: True to make sure this happens
08:20:04 <shergill> haskdogs does that
08:20:21 <chrisdone> eh, it's a program to generate a kind of index from one or more .hs files that your editor can use
08:20:45 <shergill> http://hackage.haskell.org/package/haskdogs-0.3
08:21:27 <elliott> chrisdone: honestly I don't mind the HTML source view
08:21:34 <fmap> elliott: you mean cabal-install doesn't have --haddock-hyperlink-source?
08:21:49 <elliott> fmap: !
08:21:51 <elliott> that is new
08:21:54 <elliott> but can you set it on by default?
08:22:02 <fmap> I don't think so
08:22:33 <chrisdone> elliott: but opening the file in your own editor would be better, right?
08:22:51 <chrisdone> (i mean, if you're gonna focus efforts in one of the two)
08:23:20 <applicative> fmap, I'll be darned
08:24:19 <elliott> chrisdone: well, personally I'm not sure :) reading certain bits of code is a bit different to actively working on files for me
08:24:23 <elliott> but certainly both are acceptable
08:24:44 <applicative> chrisdone: I think its obviously better, but for the  risk I might feel like editing it....  In the first instance it will have whatever highlighting is  customary, for what that'sworth
08:25:47 <monochrom> exposing source code worsens documentation
08:25:47 <chrisdone> i suppose the files could be made read-only. possibly
08:26:16 <chrisdone> monochrom: what's that based on?
08:26:20 <applicative> monochrom: seeing the actual definition is essential
08:26:55 <applicative> besides it is pleasing to read haskell....
08:27:07 <mcstar> then whats the purpose of the documentation at all, if you need to see the source nevertheless?
08:27:11 <chrisdone> mm, i tend to jump to the definition if (1) the docs are useless, (2) there's a bug in the library, (3) i'm going to modify the code
08:27:12 <monochrom> because people have more incentives to say "everyone reads the source code anyway, I am not writing documentation anymore"
08:27:52 <applicative> in any case the html -vs- source-in-editor question seems not too important; it would best turn on what makes for a coherent larger system, I'd think.
08:27:54 <monochrom> and empirical evidence? many open-source people have the "use the source, luke" attitude
08:27:54 <mcstar> chrisdone: (4) you are simply curious?
08:28:09 <chrisdone> mcstar: CHRISDONE IS NEVER CURIOUS
08:28:36 <chrisdone> monochrom: good points
08:29:19 <chrisdone> applicative: it would best turn on what makes for a coherent larger system, I'd think. ‚Äî huh, wha? „ÅèÔºàÔºæ_„ÉªÔºâ„Çù
08:29:22 <applicative> monochrom: but it is clear the scheme chrisdone is meditating on will make documentation much more central
08:29:55 <applicative> chrisdone: I just mean, both are nice, but maybe one is easier to implement, in particular given whatever else
08:30:09 <applicative> it makes sense to implement
08:30:24 <chrisdone> sure
08:31:07 <chrisdone> two points remain, anyhoo: (1) getting to the docs sucks, (2) getting to the source sucks as bad, but possibly less important presently than (1)
08:31:25 <applicative> chrisdone: yeah is see the sentence was a mess.   (when a laptop's keyboard goes, there's not much to be done)
08:31:48 <chrisdone> so if i made a ~/.cabal/config option like: generateHoogle: true -- would that be sufficient?
08:31:50 <applicative> yes.
08:32:16 <chrisdone> it would probably write to the standard hoogle database file using that combining option in hoogle
08:32:18 <applicative> yes to the first question
08:32:21 <chrisdone> what about cabal-dev scenarios?
08:33:05 <applicative> is hoogle robust enough for this? as someone complained above, I had trouble getting the local db going last time I tried; though that means nothing
08:33:27 <chrisdone> well, let me make a small test
08:34:31 <adek05> Can I use Mutable IO Arrays or Arrays from ST monad to do parallel read and write access?
08:34:57 <adek05> I mean, without wraping each access by mutex lock
08:35:07 <chrisdone> cabal install split --reinstall --force-reinstalls --haddock-hoogle
08:35:14 <chrisdone> does yours generate a .hoogle file?
08:36:55 <chrisdone> oh by the way, it might nuke your libraries depending on split. >_>
08:37:20 <chrisdone> choose a less used module, like HoleyMonoids
08:37:45 <chrisdone> cabal install HoleyMonoid --haddock-hoogle
08:37:57 <chrisdone> it doesn't seem to generate anything hoogle for me
08:38:13 <shachaf> chrisdone: Did you see my variation on HoleyMonoid that's composable with (Prelude..)?
08:38:25 <chrisdone> what, really? hmm. nice
08:38:27 <shachaf> http://www.reddit.com/r/haskell/comments/14met7/oleg_typesafe_formatted_io/c7f8un6
08:38:28 <chrisdone> can you link me?
08:38:32 <chrisdone> thanks
08:38:58 <applicative> shachaf: yes that was awesome.
08:39:14 <applicative> oh I guess I said I'd attempted it earlier in the day
08:39:15 <shachaf> Hmm...
08:39:37 <shachaf> It might be possible to improve on that with our newfound lens knowledge!
08:39:43 <chrisdone> shachaf: i think i'll update to that. i made a small `format' module based on holeymonoid
08:39:53 <chrisdone> lol
08:40:07 <chrisdone> Now You're Looking Through Lenses!
08:40:30 <chrisdone> applicative: did it work/generate anything?
08:40:37 <applicative> chrisdone: i
08:40:48 <chrisdone> o_o
08:40:48 <shachaf> edwardk: That's a profunctor, right?
08:40:49 <applicative> am not seeing that haddock or hoogle was called.
08:41:01 <edwardk> shachaf: the FHM type?
08:41:02 <shachaf> Foo m r x = (m -> r) -> x
08:41:09 <shachaf> No, the two halves of it.
08:41:19 <shachaf> The goal there was to make something (.)-composable.
08:41:22 <edwardk> yes
08:41:49 <shachaf> Oh, I guess what I'm saying is that HoleyMonoid itself is a profunctor.
08:41:58 <edwardk> yeah
08:42:00 <chrisdone> what's a profunctor?
08:42:25 * chrisdone . o O ( and is there an antifunctor? )
08:42:26 <edwardk> profunctors are what we build everything in lens out of these days.
08:42:31 <applicative> this use  of Rank2Types  is so smooth and wholesome
08:42:46 <edwardk> a profunctor p takes two arguments and is contravariant in the first, covariant in the second
08:42:50 <edwardk> @hoogle profunctors
08:42:50 <chrisdone> applicative: like a baggette fresh from the oven?
08:42:51 <lambdabot> package profunctors
08:42:51 <lambdabot> package representable-profunctors
08:42:55 <edwardk> @hackage profunctors
08:42:56 <lambdabot> http://hackage.haskell.org/package/profunctors
08:43:00 <`nand`> would an antifunctor be a contravariant functor? :P
08:43:07 <edwardk> `nand`: no =P
08:43:10 <Taneb> dimap :: (a -> b) -> (c -> d) -> p b c -> p a d
08:43:13 <`nand`> shame
08:43:27 <`nand`> maybe an antifunctor can be a functor that is contravariant in its right and covariant in its left argument
08:43:36 <`nand`> a bifunctor, that is
08:43:43 <chrisdone> ah, nice
08:43:50 <shachaf> chrisdone: I changed my mind -- I like the version with the newtype now.
08:43:52 <Taneb> Like the imaginary (<-), `nand`?
08:43:54 <shachaf> I mean DHM
08:43:55 <chrisdone> it reminds me of arrows
08:43:56 <`nand`> Taneb: yeah
08:44:10 <`nand`> Taneb: not necessarily imaginary
08:44:14 <edwardk> chrisdone: note you can't compose then, just bolt functions on either end
08:44:25 <edwardk> chrisdone: if you add Category you get _almost_ an arrow
08:44:36 <`nand`> newtype Flip f a b = Flip { unflip :: f b a }; type (<-) = Flip (->)
08:44:40 <`nand`> unless (<-) is not a valid operator name
08:44:42 <`nand`> but it should be
08:44:57 <edwardk> `nand`: in 7.6. you can use it
08:45:18 <shachaf> Oh, I bet you could improve on DHM too.
08:45:21 * chrisdone stays on track: how to generate hoogle stuff from this package
08:46:10 <`nand`> edwardk: almost? some missing laws? or the ‚Äôfirst/second‚Äô stuff?
08:46:26 <applicative> chrisdone: somehow the options in cabal install HoleyMonoid --reinstall --force-reinstalls --haddock-hoogle seem to be turning off haddock?
08:46:29 <shachaf> Is there a name for Foo r a b = (r -> a) -> b?
08:46:30 <edwardk> `nand`: first/second
08:46:42 <edwardk> shachaf: that was our old Indexed. ;)
08:46:55 <shachaf> True.
08:47:04 <shachaf> But we put it in the wrong position!
08:47:11 <chrisdone> applicative: i see haddock working, but it doesn't generate anything. on the other hand. cabal unpack HoleyMonoid; cd HoleyMonoid; cabal haddock --hoogle generated a .txt file, which, as i understand it, can be converted to a .hoo file. i will try and report back
08:47:16 <edwardk> now you know the use for it in argument position
08:47:45 <shachaf> I guess it's representable (trivially).
08:47:58 <edwardk> newtype Holey r a b = Holey { runHoley :: (r -> a) -> b }
08:48:17 <chrisdone> applicative: oh wait: Hoogle has both binary databases (extension .hoo) and textual databases (extension .txt). Textual database files are a list of functions and their types, along with information about type synonyms, instances etc. The textual database files can be generated by Haddock with the --hoogle flag. Support for this is now in Cabal with runhaskell Setup haddock --hoogle.
08:48:30 <`nand`> newtype Holey r a b = Moley { holeyMoley :: (r -> a) -> b }
08:48:56 <edwardk> and yeah its representable, prismatic, etc.
08:49:31 <applicative> chrisdone: wait, I see my hoogle is broken, so I haven't really done anything yet
08:49:32 <`nand`> what does ‚Äòrepresentable‚Äô mean in these contexts either way? eg. representable profunctors
08:49:39 <chrisdone> applicative: LOL
08:49:42 <`nand`> I keep seeing stuff like ‚Äòtabulate‚Äô but I don't have some sort of inner picture about what it ‚Äúmeans‚Äù
08:49:56 <chrisdone> applicative: ÔºàÔæâ¬¥–¥ÔΩÄÔºâ
08:50:15 <edwardk> `nand`: k is a RepresentableProfunctor if its a Profunctor and admits: tabulatePro :: (Rep k d -> c) -> k d c     indexPro :: k d c -> Rep k d -> c
08:50:21 <shachaf> `nand`: A profunctor p is representable if p a b ~ f a -> b for some f
08:50:22 <edwardk> for some type Rep
08:50:31 <edwardk> p a b ~ f a -> b
08:50:46 <edwardk> corepresentable: p a b ~ a -> f b
08:50:54 <`nand`> motivating examples?
08:51:10 <edwardk> `nand`: UpStar f a b =    a -> f b   is corepresentable by f
08:51:17 <`nand`> I guess (->) is trivially representable by Identity
08:51:20 <edwardk> DownStart f a b = f a -> b  is representable by f ;)
08:51:28 <edwardk> (->) is both representable and corepresentable
08:51:31 <`nand`> yeah
08:51:39 <chrisdone> i can't figure out the argument to pass to hoogle to tell it what .hoo/.txt file to use for its database, anyone remember it?
08:51:39 <`nand`> it's UpStar/DownStar Identity either way
08:51:43 <`nand`> so that makes sense
08:51:51 <edwardk> (i -> a -> b   is also both corepresentable by (i ->)  and representable by (i,)
08:51:55 <`nand`> what about ‚Äòrepresentable‚Äô in other contexts?
08:52:04 <chrisdone> (hoogle --help does NOT help in this)
08:52:05 <`nand`> eg. representable functors
08:52:26 <edwardk> a corpresentable functor f a ~ x -> a   for some x
08:52:42 <edwardk> a representable functor is contravariant and f a ~ a -> x
08:53:09 <edwardk> the representable-functors package uses Functor so its 'representable' is technically corepresentable
08:53:12 <`nand`> a^n ~ n -> a -- ?
08:53:30 <edwardk> data Pair a = Pair a a  is representable by Bool
08:53:37 <`nand`> that's a special case of a^n
08:53:38 <edwardk> (er corepresentable)     Bool -> a
08:53:58 <edwardk> this is how i encode vector spaces in linear
08:54:12 <`nand`> does this mean all corepresentable functors are like functors with a fixed number of ‚Äôfields‚Äô?
08:54:32 <edwardk> i define them to be functors that are represented by their polymorphic lenses forall x. Lens' (f x) x   is a 'key'
08:54:49 <edwardk> `nand`: and where all of the information is contained in those fields
08:55:02 <`nand`> okay
08:55:04 <mcstar> oh, True to give the first arg. False to give the second arg, for example?
08:55:08 <`nand`> yeah, makes sense
08:55:10 <`nand`> mcstar: exactly
08:55:18 <edwardk> my work-in-progress tables is built on a similar notion actually!
08:55:48 <parcs> > 0x100
08:55:50 <lambdabot>   256
08:55:56 <edwardk> i use
08:55:56 <edwardk>   mkTab :: Applicative h => (forall k a. (IsKeyType k, Ord a) => Key k t a -> h (i k a)) -> h (Tab t i)
08:56:04 <edwardk> and   ixTab :: Tab t i -> Key k t a -> i k a
08:56:20 <edwardk> as inverses (modulo the Applicative noise on mkTab)
08:56:57 <edwardk> https://github.com/ekmett/tables/blob/master/src/Data/Table.hs#L82
08:57:09 <edwardk> see the few built in instances at the bottom
08:57:15 <chrisdone> applicative: any luck?
08:57:20 <chrisdone> *poke*
08:57:24 <chrisdone> („Çú„ÄÇ„Çú)
08:57:40 <applicative> no, studying
08:58:01 <chrisdone> (    „Çú„ÄÇ„Çú) ok
08:58:09 <applicative> hoogle blah --help doesn't seem to have a suitable option.  hoogle convert?
08:58:27 <chrisdone> oh
08:58:52 <chrisdone> i just did 'hoogle search --help'. seems promising. did not expect that to work. mildly annoyed that it does. but ok
08:58:55 <shachaf> edwardk: How is Holey Prismatic?
08:59:03 <shachaf> Is it only when r is a monoid or something?
08:59:05 <aforemny> Can I use reactive-banana for sound processing, e.g. firing an event 44100 times a second? I seem to have hit a bottleneck and wonder if it is by poor design of my application.
08:59:56 <b_jonas> hello. I was trying to build ghc 7.6.1 from source and I got an error message saying it's trying to use an unsafe package.  http://hpaste.org/79882
08:59:57 <chrisdone> doesn't work :(
09:00:03 <b_jonas> I wonder what I've done wrong.
09:00:11 <edwardk> Corepresentable should give you whichever one of Lenticular or Prismatic is implied there. i forget which
09:00:31 <b_jonas> I might have messed up something while installing packages to ghc 7.2.1 which I'm using for this compilation.
09:00:34 <edwardk> aforemny: that might be a bit fast for reactive banana
09:00:51 <aforemny> edwardk: I see. Thank you.
09:00:51 <rwbarton> aforemny: I did a little reactive-banana benchmark and was only getting about 40000 events firing per second in a trivial setup
09:01:10 <bartavelle> it seems to me that what gitlib calls a "text" is actually directly derived from some latin1 string :(
09:01:38 <gwern> @quote string
09:01:38 <lambdabot> monochrom says: 007 titles for haskellers.  fromForeignPtr withCString.  You Only lift Twice. Bottoms Are Forever.  The Monad with the Pure Function.  For Your Types Only.  A view to A seq.  Licence
09:01:39 <lambdabot> to killThread.  iterate Never Dies.  unsafePerformIO Is Not Enough.
09:01:53 <gwern> hah
09:01:59 <elliott> in my experience unsafePerformIO is always enough
09:02:51 <monochrom> @quote string.*data
09:02:51 <b_jonas> hrhr
09:02:51 <lambdabot> roconnor says: String is kinda a poor data type for strings.
09:02:58 <BMeph> mcstar: I find that a "good" way to remember it is by thinking of a function that represents a bit-encoded number: 2^n ~ n -> 2
09:03:12 <monochrom> @quote string.*stark.*data
09:03:13 <lambdabot> AlanPerlis says: The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
09:03:28 <chrisdone> @quote unsafePerfom
09:03:28 <lambdabot> No quotes match. stty: unknown mode: doofus
09:03:32 <chrisdone> @quote unsafePerform*
09:03:33 <lambdabot> mmorrow says: {-# RULES "HAI; CAN HAS STDIO?"  id = unsafePerformIO (system "killall -9 breathingMachine && xeyes &" >> return id)  #-}
09:03:38 <chrisdone> lol
09:03:47 <chrisdone> killall -9 breathingMachine made me giggle
09:04:11 <chrisdone> doesn't even get the dignity of a proper shutdown
09:04:31 <monochrom> I don't get that breathingMachine reference
09:05:04 <chrisdone> breathing machines as in hospital ventilators that keep you alive
09:05:26 <chrisdone> i just noticed xeyes LOL
09:05:37 <BMeph> monochrom: It suggests that you're not just "killing" an inanimate process.
09:05:44 <chrisdone> i miss mmorrow
09:05:48 <monochrom> then I am more baffled. what is xeyes doing there then?
09:05:53 <chrisdone> hahahah
09:06:03 <chrisdone> stop it, you're making me laugh more
09:06:11 <monochrom> fine
09:06:16 <chrisdone> xD
09:06:38 * chrisdone still giggling
09:06:52 <mcstar> the joke is &&
09:07:07 <chrisdone> ahh, i haven't laughed that hard in a while
09:07:32 <chrisdone> mmorrow: come back, i miss you! (;________ ; )
09:07:40 <chrisdone> @seen mmorrow
09:07:40 <lambdabot> Unknown command, try @list
09:07:56 <monochrom> there is no more seen. even preflex has left
09:07:59 <mcstar> did he accidentally kill dash nined?
09:08:00 <chrisdone> lambdabot: why don't you know do @seen. call yourself a bot?
09:08:13 <chrisdone> why did lambdabot stop doing @seen?
09:08:16 <chrisdone> i swear it used to
09:08:29 <monochrom> yes it used to
09:08:55 <chrisdone> <monochrom> there is no more seen. even preflex has left ‚Äî all that remains is me, and this old sandwich
09:09:01 <chrisdone> oh well!
09:09:42 * chrisdone pounces on ivanm
09:09:43 <mysticc> :t 1
09:09:45 <lambdabot> Num a => a
09:09:47 <chrisdone> (‚óè¬¥‚àÄÔΩÄ‚óè)
09:09:51 <mysticc> :t [[1],2]
09:09:53 <lambdabot> (Num [t], Num t) => [[t]]
09:10:18 <Taneb> mysticc, that means that for some number type t, [t] is also a number
09:10:21 <saati> :t ‚óè
09:10:22 <lambdabot> fd:9: commitBuffer: invalid argument (invalid character)
09:10:26 <Taneb> Only then can you construct [[1],2]
09:10:31 <applicative> chrisdone: so I am at this point --haddock-hoogle makes presburger.txt ; hoogle convert presburger.txt makes presburger.hoo
09:10:33 * chrisdone still giggling at the breathingMachine && xeyes command
09:11:00 <chrisdone> applicative: presburger??? haha
09:11:09 <mysticc> Taneb: Then shouldn't the type be [t] and not [[t]]
09:11:13 <chrisdone> hmmm
09:11:27 <chrisdone> applicative: then how do you use, and ONLY use, the .hoo file with hoogle's search?
09:11:48 <Taneb> mysticc, no, because it's a list of [t]'s, which you are saying a kind of number
09:12:15 <donri> doesn't that require existentials
09:12:44 <chrisdone> (‚óèÔΩÄÔΩ•(ÔΩ¥)ÔΩ•¬¥‚óè) donri
09:13:01 <donri> lol
09:13:03 * chrisdone traps him in a net and then sprays cinnamon on his shoes
09:13:57 <chrisdone> whatever happened to the er... what was that feature? like existentials but didn't require a data type to do it, parametric, sorta
09:14:21 <chrisdone> you could write [forall a. Show a => a] but it almost never ever worked, and was an "experimental" feature
09:14:37 <joar> cd-fit.hs:1:1: Could not find module `Prelude' Perhaps you haven't installed the profiling libraries for package `base'?
09:14:39 <c_wraith> impredicative types
09:14:43 <chrisdone> that's the one
09:14:47 <chrisdone> what happened to that idea?
09:14:50 <joar> i'm on ubuntu, how do I get the profiling libs?
09:14:52 <donri> i thought that was what existentials allowed you to write
09:15:11 <chrisdone> they do but only in a data type, whereas impredicative you could do it kind of on the fly somehow
09:15:28 <chrisdone> joar: that's a seriously messed up setup. how are you compiling cd-fit.hs?
09:15:32 <joar> ghc6-prof seems to be something
09:15:41 <joar> cd-fit.hs:1:1: Could not find module `Prelude' Perhaps you haven't installed the profiling libraries for package `base'?
09:15:44 <chrisdone> ah, profiling
09:15:44 <joar> oops
09:16:03 <joar> yes; ghc -O --make -prof -auto-all -o cd-fit cd-fit.hs
09:16:04 <joar> :)
09:16:23 <chrisdone> that's weird, i thought profiling versions of base came with ghc
09:16:38 <rwbarton> (ghc6?)
09:16:38 <joar> now I get [...]     Perhaps you haven't installed the profiling libraries for package `QuickCheck-2.4.2'?
09:16:40 <chrisdone> that's why ghc is so hueg
09:16:53 <chrisdone> ah, much better. so install QuickCheck-2 with profiling enabled
09:17:11 <chrisdone> rwbarton: did you see that hoogle can also show documentations?
09:17:14 <joar> chrisdone: I haven't read that tutorial :)
09:17:30 <chrisdone> me neither, i was hoping you had  ò‚Äø ò
09:17:30 <joar> and I guess it's not available via Ubuntu's repositories
09:17:33 <rwbarton> chrisdone: yeah
09:17:44 <monochrom> chrisdone: thanks for haskell-doc
09:17:46 <rwbarton> what's your plan for haskell-docs now?
09:17:56 <chrisdone> monochrom: welcome!
09:18:28 <chrisdone> rwbarton: well if i can get cabal to reliably (re-)generate a hoogle database then i would recommend using hoogle and forgetting haskell-docs
09:18:33 <chrisdone> *if*
09:18:33 <applicative> hoogle dump presburger.hoo does re-render it; or maybe it just unzips it...
09:18:53 <joar> cabal seems to be the place to get profiling libs
09:19:00 <chrisdone> cabal install X; hoogle X.foo should work, is the idea
09:19:43 <rwbarton> joar: how did you install the non-profiling QuickCheck?
09:19:58 <joar> rwbarton: sudo apt-get install ghc
09:20:14 <joar> at least I think so
09:20:29 <applicative> what version of ghc does taht give you joar
09:20:29 <joar> but it might be that it's been in my /home/joar for quite a while
09:20:31 <watermind> > catch (return $ error "ops") (\_-> return "ok")
09:20:33 <rwbarton> what version of ubuntu are you using
09:20:34 <lambdabot>   No instance for (GHC.Show.Show (GHC.Types.IO [GHC.Types.Char]))
09:20:34 <lambdabot>    arising ...
09:20:47 <rwbarton> actually, just ask: ghc-pkg list quickcheck
09:20:52 <joar> rwbarton: 12.10, I think
09:21:07 <rwbarton> or QuickCheck, rather
09:21:19 <watermind> so why exactly does this not catch the error:   catch (return $ error "ops") (\_-> return "ok")
09:21:21 <joar> ‚ûú  hitchhiker git:(master) ‚úó ghc-pkg list QuickCheck                                                                            belz
09:21:24 <joar> /var/lib/ghc/package.conf.d QuickCheck-2.4.2
09:21:28 * hackagebot xosd 0.2.1 - A binding to the X on-screen display  http://hackage.haskell.org/package/xosd-0.2.1 (DonaldStewart)
09:21:36 <rwbarton> ok so probably you installed it through apt
09:21:44 <rwbarton> whether as part of ghc or separately
09:21:46 <watermind> I know it has to do with lazy evaluation but I don't see how that makes it not work
09:22:41 <joar> Test/QuickCheck/Arbitrary.hs:70:8: Could not find module `System.Random' Perhaps you haven't installed the profiling libraries for package `random-1.0.1.1'?
09:22:51 <applicative> http://packages.ubuntu.com/search?keywords=haskell-platform mentions a Package haskell-platform-prof
09:22:56 <joar> when running `cabal install -p QuickCheck`
09:23:21 <joar> applicative: that one I didn't have.
09:23:41 <rwbarton> how about just install libghc-quickcheck2-dev
09:23:44 <rwbarton> and don't use cabal
09:23:48 <rwbarton> um
09:23:52 <joar> much better, now all the compiler errors I see are ones created by me.
09:23:52 <rwbarton> libghc-quickcheck2-prof
09:23:59 <rwbarton> well, ok
09:24:15 <chrisdone> applicative: GET BACK TO STUDYING YOU NAUGHTY BOY
09:41:29 * hackagebot conductive-hsc3 0.3 - a library with examples of using Conductive with hsc3  http://hackage.haskell.org/package/conductive-hsc3-0.3 (RenickBell)
09:50:23 <r00723r0> Who wrote Yesod?
09:51:31 <pnielsen> r00723r0: snoyberg
09:55:16 <donri> r00723r0: lots of people, primarily michael snoyman
10:06:29 * hackagebot monad-logger 0.2.3.2 - A class of monads which can log messages.  http://hackage.haskell.org/package/monad-logger-0.2.3.2 (MichaelSnoyman)
10:10:15 <monochrom> ‚òÉ
10:23:26 <osfameron> heh
10:31:30 * hackagebot vector-binary-instances 0.2 - Instances of Data.Binary and Data.Serialize for vector  http://hackage.haskell.org/package/vector-binary-instances-0.2 (DonaldStewart)
10:34:00 <`nand`> Is there a variant of ‚Äòuntil‚Äô that will return a list of all intermediate values?
10:34:14 <`nand`> something like \f g -> takeWhile (not . f) . iterate g
10:36:00 <k00mi> why not use that?
10:37:24 <`nand`> just asking if there's a name for it somewhere
10:37:38 <tromp> :t until
10:37:40 <lambdabot> (a -> Bool) -> (a -> a) -> a -> a
10:38:50 <tromp> :t while
10:38:51 <lambdabot> Not in scope: `while'
10:40:06 <beaky> how do I serialize my haskell data structures
10:40:20 <beaky> like my game monsters and word
10:40:22 <beaky> world*
10:40:34 <S11001001> beaky: you could start with show and read
10:40:52 <S11001001> beaky: any haskell intro probably covers those.
10:41:10 <beaky> ah
10:41:17 <beaky> that makes it easy :D
10:44:06 <lispy> beaky: <unsolicited advice>Read/Show are great serialization at first, but as things grow more complicated, I recommend moving away from them. Then you'll likely want binary or cereal</unsolicited advice>
10:44:30 <beaky> ah
10:44:34 <beaky> like bytestring?
10:44:47 <lispy> IMO, read/show are more like a programmer's tool.
10:44:57 <lispy> binary and cereal both use bytestring, IIRC
10:45:10 <`nand`> readMaybe can be great for stuff like reading integers
10:45:21 <`nand`> when you don't really care about a specific format
10:46:29 <lispy> beaky: My style is to do the simplest thing that works. Read/Show are great for that. My ray-tracer takes scene descriptions via the compiler generated Read instance. Some day I will make a proper scene language (or borrow one).
10:48:06 <S11001001> lispy: or not :)
10:48:55 <tromp> do you want efficiency or human-readability?
10:49:02 <lispy> S11001001: :) The default Read parser is terrible about parsing and errors so I do kind of want to replace it some day
10:50:54 <shachaf> Igloo: Any idea what's happening with the {Traverseable,Foldable} {(e,),Either e} instances?
10:50:58 <beaky> I want maximum human readability atm :D
10:51:02 <DigitalKiwi> if you're transmitting over the wire, and maybe even if you aren't, maybe protobufs are an option?
10:51:16 <shachaf> Igloo: It looks like people on libraries@ are for it. Are you just waiting for a patch?
10:51:43 <lispy> shachaf: that would be my guess
10:52:12 <lispy> beaky: what type of game are you making?
10:52:23 <beaky> a roguelike
10:52:24 <DigitalKiwi> there's also the possibility of json or xml or whatnot
10:52:44 <lispy> beaky: fun. Graphical or classic ascii style?
10:53:07 <beaky> classic :D
10:53:17 <beaky> I haven't even picked a terminal library yet
10:53:42 <beaky> still struggling to figure out the best way to do things :D
10:53:47 <lispy> I'd check out vty or vty-ui. I hear they are more haskell friendly, but I have no experience there personally
10:54:32 <pmk> hey, what you do want a terminal library for?
10:54:47 <lispy> pmk: drawing the screen of a rogue-like?
10:55:02 <pmk> ok
10:55:12 <beaky> I like how in haskell you are always thinking of other ways to do things
10:55:41 <flebron> that's because you were brought up in imperative
10:55:42 <pmk> consider simply emitting raw xterm control sequences, they're easy
10:55:52 <sm> vty is great, but not super fast. I wonder if ncurses is any different. (And vty-ui looks really great)
10:55:52 <flebron> if your had been brought up in functional programming, you'd say the same about c++ :p
10:56:21 <beaky> well even in C++ I'm thinking of all the different ways things can be done :(
10:56:31 <beaky> maybe it's because I'm just a beginner programmer
10:56:38 <`nand`> I've always wanted to get into vty, but I think it's a bit too low level for my taste
10:56:43 <flebron> you can shoot yourself in the foot with pointers
10:56:48 <flebron> you can shoot yourself in the foot with iterators
10:56:51 <flebron> you can shoot yourself in the foot with templates
10:56:59 <flebron> oh the choices!
10:59:25 <sm> `nand`: that's where vty-ui comes in
10:59:27 <pmk> i was asked the other day what language i would suggest for a very first programming language, and i found myself utterly stumped.
11:00:20 <franv> Logo and BASIC of course! :P
11:00:53 <`nand`> I remember some proper subset of Haskell intended for beginners
11:00:55 <flebron> pmk, we teach haskell in uni in the cs degree
11:01:16 <flebron> (essentially because it's easy, coming from a mathematics background, to understand function declaration and recursive definitions)
11:01:26 <`nand`> I don't remember what it's called though
11:01:27 <beaky> if I import Foo hiding (bar, baz), does that mean I can't use bar or baz?
11:01:28 <flebron> we do elimiate all higher order however, and essentially no typeclasses.
11:01:35 <beaky> or can I use them if I qualify them with Foo.bar?
11:01:40 <pmk> teaching haskell to cs students sounds like a fine idea
11:02:04 <`nand`> oh, this is about cs students? I thought it was about what you'd teach a child
11:02:10 <`^_^v> except that the vast majority of them will never ever do anything like haskell post-college
11:02:10 <flebron> math oriented folks actually get confused about things like "x = x+1"
11:02:11 <pmk> it is
11:02:24 <beaky> flebron: that was a wtf for many students at my uni
11:02:35 <flebron> as for a kid... perhaps python? or js (if one guides them into the sane parts of it)
11:02:38 <beaky> 'professor, isn't that a false statement?'
11:03:12 <`nand`> sm: I don't think I like vty-ui, just looking at some examples
11:03:16 <`nand`> it seems very complicated to use
11:03:18 <hpc> flebron: i actually think writing OO javascript is one of the best introductions to functional programming you can give a person
11:03:20 <flebron> although yeah, every language is going to have some underlying knowledge that acts as a barrier for entry, in python you have types, control structures, etc
11:03:39 <`nand`> oh
11:03:44 <`nand`> Helium is what I was thinking of
11:03:47 <hpc> it's "oh, perfectly ordinary classes and objects", but with first-class functions and hash tables
11:03:48 <pmk> i would love to hire people conversant in both haskell and assembly language, myself
11:03:55 <flebron> yeah
11:03:58 <`nand`> so yeah, I guess I'd teach people Helium first
11:04:05 <`nand`> and then the natural step would be towards Haskell
11:04:10 <`^_^v> control structures are fundamental to programming itself, not a language
11:04:18 <flebron> the first thing cs students learn in algoriths 1 isn't actually programming, it's a specification language
11:04:21 <`^_^v> and i dont see how a beginner would need to worry about types in python at all
11:04:25 <`nand`> hpc: like C#?
11:04:36 <flebron> often the key issue is specifying _what_ you want to do, and what you can assume
11:04:41 <hpc> i have never used C#
11:04:58 <flebron> many would like to jump in keyboard-first into the problem, and find themselves deleting a bunch of code because they weren't really thinking
11:04:59 <`nand`> it's like java, but with first class functions and quasimonads and stuff (yes, I just invented that term)
11:05:00 <hpc> but i think yes, just going from my intuition about how C# would interact with F#
11:05:13 <hpc> quasimonad is a term i think
11:05:28 <flebron> were they invented in the university of notre dame?
11:05:30 <hpc> http://citeseer.ist.psu.edu/viewdoc/download;jsessionid=7E0C97EFB9D9D3580B76CACE74E7A958?doi=10.1.1.47.8923&rep=rep1&type=pdf
11:05:48 <`nand`> `^_^v: I think the most principal problem at the heart of programming is about denotational semantics; the fundamental challenge is figuring out how to represent things you want to represent in a language
11:05:57 <`nand`> that's one thing that's shared among every programming language I know
11:06:10 <flebron> that's easy, it's a functor from Idea to Language
11:07:17 <`^_^v> you're right
11:07:34 <`nand`> hpc: do you know if there's a term for a semigroup in the category of endofunctors?
11:07:37 <`nand`> aka monad without return
11:08:16 <hpc> `nand`: uh
11:08:30 <hpc> i don't know of a name for it
11:08:45 <`nand`> because I think that's sort of what LinQ is
11:08:50 <`nand`> but I haven't worked enough with LinQ to be certain about it
11:08:57 <hpc> linq has a return though
11:09:06 <aristid> `nand`: so join and fmap but no return/
11:09:07 <`nand`> it does?
11:09:24 <dalinto> hi :) can you recommend a couple of book to start learning haskell?
11:09:29 <`nand`> dalinto: LYAH
11:09:44 <hatds> is there a way to make ghc ignore LINE pragmas?  There doesn't seem to be a flag...
11:10:00 <hpc> uh
11:10:18 <Taneb> @where lyah
11:10:18 <lambdabot> http://www.learnyouahaskell.com/
11:10:22 <Taneb> dalinto ^^^
11:10:23 <pmk> dalinto: your best bet nowadays is called "learn you a haskell for great good"
11:10:38 <dalinto> aha ok.. is there other good books for new students?
11:10:50 <hpc> `nand`: according to wikipedia you're right
11:11:16 <`nand`> aristid: yeah, which still gives you a lot of things, including ap
11:11:25 <pmk> dalinto: where are you starting from?  have you messed with functional programming languages at all?
11:11:53 <dalinto> pmk: not really i just know python and awk
11:11:55 <aristid> `nand`: you could call it a Pointless Monad :D
11:12:01 <`nand`> aristid: haha
11:12:08 <`nand`> okay, that's a term I'll use from now on
11:12:14 <aristid> lol
11:12:29 <monochrom> unreturnable monad
11:12:52 <Taneb> Blunt monad?
11:12:59 <`nand`> hpc: while LinQ appears to have return (with its from ... select sugar; ‚Äòselect‚Äô works like return); it's just sugar for constructing a lambda and fmap'ing that
11:13:03 <monochrom> no-reply@monad.com
11:13:10 <pmk> dalinto: yeah, you want to start with LYAH, and if you're the kind of person who likes reading user manuals, the Haskell 2010 Report is pretty readable and useful
11:13:13 <`nand`> hpc: notably, you can't ‚Äòselect‚Äô without a ‚Äòfrom‚Äô
11:13:52 <Taneb> The semigroupoids package calls it a "Bind"
11:13:56 <dalinto> pmk: aha ok :)
11:14:09 <`nand`> (in fact, the principal combinator of LinQ, SelectMany, is like fmap f . bind g)
11:14:38 <monochrom> some SQL variant has "select 1". I think postgresql does it
11:15:03 <`nand`> monochrom: (this is about C# and LinQ, not some SQL)
11:15:44 <edwardk> `nand`: its not return, more 'map', no?
11:16:01 <edwardk> like how in scala, their for { } syntax lacks return too
11:16:01 <beaky> what are some uses of Data.Either?
11:16:02 <`nand`> edwardk: what is that in response to?
11:16:10 <`nand`> the SelectMany stuff?
11:16:19 <edwardk> `nand`: select as return
11:16:29 <`nand`> right; that's sort of my point; it looks like return but isn't really
11:16:31 * hackagebot http-conduit 1.8.6 - HTTP client package with conduit interface and HTTPS support.  http://hackage.haskell.org/package/http-conduit-1.8.6 (MichaelSnoyman)
11:17:19 <`nand`> (that's the problem with replacing type classes by interfaces)
11:18:37 <edwardk> that and the whole inability to write code parametrically in terms of what monad it works with. with linq you always have to pick _some_ linq provider to program to
11:18:56 <edwardk> you can't write a predicate that works with both, say, linq-to-entities and the reactive framework
11:19:24 <`nand`> you can write parametric code in C#, no? Foo<T> (T a) : T is ISomething -- or something like that
11:20:09 <edwardk> `nand`: that works for values, but not for things you want to vary the args to
11:20:30 <edwardk> i can't give you Foo<_> where you can plug in the <_> later
11:20:44 <edwardk> scala has it, the .net ecosystem is missing this concept
11:20:45 <`nand`> oh, yeah; that's a problem with lack of higher order types
11:21:29 <`nand`> (actually, I think this is orthogonal to higher order types)
11:21:31 <edwardk> i find the strength of this effect from a sapir-whorf hypothesis perspective amusing
11:21:58 <`nand`> I've never thought of applying sapir-whorf to programming languages
11:23:01 <mcstar> how can i provide flags to cabal?
11:23:17 <mcstar> like this vty-ui stuff needs a
11:23:22 <mcstar> 'demos' flag to build demos
11:23:34 <`nand`> I wonder if there's a simpler way to write manual, cyclic Enum instances
11:24:10 <`nand`> say I have data X = A | B | C; and I want succ A = B; succ B = C (as with the auto-derived instance), but succ C = A
11:24:31 <`nand`> is there any alternative than enumerating every possibility?
11:24:46 <`nand`> s/than/to/
11:24:51 <Saizan> TH?
11:24:58 <`nand`> oh, fair point
11:25:02 <`nand`> yeah that would work
11:25:08 <Saizan> maybe derive has something for it too
11:25:13 <`nand`> (is there a function somewhere for this?)
11:25:29 <sm> mcstar: cabal install vty-ui  -fdemos
11:25:43 <mcstar> im just trying to build it
11:25:51 <mcstar> cabal build [options]
11:26:11 <sm> cabal configure -fdemos; cabal build
11:26:14 <Saizan> `nand`: http://hackage.haskell.org/packages/archive/derive/2.5.11/doc/html/Data-Derive-EnumCyclic.html
11:26:21 <mcstar> aham, configure needs it
11:26:25 <mcstar> sm, thx
11:26:33 <sm> np
11:28:42 <mcstar> oh, sweet
11:29:11 <mcstar> maybe im gonna change my mind, and use haskell + vty instead of python + urwid
11:29:59 <`nand`> Saizan: great
11:30:07 <`nand`> what the hell is Derivation?
11:30:26 <`nand`> is this related to the deriving (...) syntax?
11:30:32 <`nand`> or is that just some TH abstraction somebody made
11:30:48 <Saizan> the latter
11:30:56 <Saizan> check Data.DeriveTH
11:31:09 <`nand`> oh okay
11:31:20 <`nand`> yeah that's simple enough
11:31:26 <`nand`> and good to know, in case I want to write stuff like this in the future
11:31:38 <`nand`> Derivation is probably a much simpler interface than manually munging the Dec tree and stuff
11:59:20 <watermind> which is the paper showing that you can make math operations, valid for real and complex numbers, in the algebra of types, and get something sensible out of it in the end?
11:59:41 <watermind> I was watching a talk on that and they mention the author but the sound is off
11:59:55 <`nand`> maybe something by mcbride could point you in the right direction
12:00:19 <r00723r0> watermind: just taking a stab... http://en.wikipedia.org/wiki/Curry%E2%80%93Howard_correspondence
12:00:34 <`nand`> the curry howard correspondence doesn't seem relevant here
12:00:56 <r00723r0> Figured. Ignore me. :)
12:01:04 <watermind> `nand`: thought so to, but that deffinitelly isn't the name
12:03:58 <`nand`> (curry howard is about types and constructive logic, not about the algebra of types as such (with addition, multiplication and so forth))
12:04:48 <watermind> `nand`:https://www.youtube.com/watch?v=YScIPA8RbVE#t=2061s
12:06:11 <`nand`> 2061s?; is that 34:21, then?
12:06:43 <watermind> yeap
12:08:37 <neutrino_> hi `nand`
12:10:01 <`nand`> neutrino_: hi
12:13:53 <neutrino_> how's it hanging? :)
12:14:10 <chrisdone> like three tree trunks battling for an apartment
12:14:56 <`nand`> ‚Äúthere a paper by a guy called [SOUND CUTS OUT], who's a mathematician [...]‚Äù
12:15:08 <`nand`> that sounds so conspicuously intentional
12:17:04 <neutrino_> only an existential proof was provided, not a constructive one, `nand`
12:17:17 <neutrino_> there exists a guy, who's a mathematician, such that he wrote a paper
12:17:26 <`nand`> and he's called something
12:17:45 <neutrino_> well, he's called John up to isomorphism
12:17:57 <`nand`> watermind: you might find an answer here: http://stackoverflow.com/questions/9190352/abusing-the-algebra-of-algebraic-data-types-why-does-this-work
12:18:03 <chrisdone> jona della isomorfismo
12:18:52 <neutrino_> `nand`: do you use tabs, or spaces, in your code?
12:19:04 <`nand`> neutrino_: I use 2 spaces for indentation
12:19:10 <neutrino_> ahh
12:19:34 <neutrino_> i've spent several hours today reading up on tabstops (which resulted in even more hours reading up on typewriters...)
12:19:50 <`nand`> did you get to elastic tabstops?
12:19:57 <`nand`> http://nickgravgaard.com/elastictabstops/columnblocks_coloured.gif
12:20:00 <neutrino_> sure
12:20:03 <neutrino_> i knew of those already though
12:20:10 <neutrino_> as it turns out, the SVID (System V Interface Description) defines 8-space tabstops as standard
12:20:28 <neutrino_> or rather, says they are standard, but it doesn't tell what standard
12:20:50 <`nand`> I wonder if something like that can be done easily and seamlessly in vim; it would speed up my haskell productivity by quite a bit since I no longer have to painstakingly align every single thing
12:20:51 <neutrino_> so, that shows why most languages nowadays work with 8 space tabstops
12:21:15 <neutrino_> yes, something like that can be done in vim
12:21:20 <neutrino_> but it's a lot of work to make it happen
12:21:35 <watermind> `nand`: ah! yes, thank you! "Andreas Blass's"
12:22:18 <`nand`> (the immediate issue I see though is that, assuming I want to save the file using regular spaces, how would vim know where I want my elastic tabstops through a save/load?)
12:22:28 <watermind> wait no
12:22:52 <watermind> it is McBride they reference there...
12:22:58 <neutrino_> `nand`: anyways, now i can tell everyone who uses tabstop not =8 that they're actually wrong.
12:23:02 <watermind> weird, it sounds nothing like McBride in the video
12:23:29 <neutrino_> `nand`: elastic tabstops are generative, they work by analyzing blocks of code that line up
12:23:49 <neutrino_> so in the end it doesn't matter
12:24:49 <`nand`> I think it would have to be pretty smart to figure out where I want my tabstops based on the code
12:25:05 <`nand`> I'm not sure if that would get in my way or not. I don't like editors that like to get in my way with ‚Äòhelpful things‚Äô
12:29:38 <neutrino_> `nand`: you want your tabstops anywhere that there are two or more spaces next to one another.
12:30:26 <Eelis> ivanm: hey, any chance you could make the graphviz bindings work with bytestring 0.10? :)
12:30:30 <neutrino_> using the python interface it should be fun to make this.
12:30:35 <neutrino_> go for it, `nand
12:30:44 <Eelis> ivanm: should just be a .cabal change, no code changes
12:31:21 <neutrino_> i'd definitely see it through if i ever made use of elastic tabstops or variable indentation.. and/or had the time.
12:31:59 <Eelis> ivanm: i'd send you a patch but i've forgotten how darcs works
12:40:24 <scooty-puff> i am benchmarking a monad transformer using criterion by solving a set of problems (this is a finite domain solver - so the problems are fixed)
12:40:52 <scooty-puff> is it good enough to use nfIO to avoid single evaluation?
12:41:19 <scooty-puff> (for those familiar with standard finite domain probems, main = defaultMain [bench "sendmory" $ nfIO sendmory])
12:41:40 <scooty-puff> i guess the answer is dependent on the style of the transformer..
12:41:50 <scooty-puff> (its a State Logic transformer)
13:14:40 <chrisdone> ivanm: maybe this version will compile for you http://hackage.haskell.org/package/haskell-docs
13:16:07 <chrisdone> https://github.com/chrisdone/haskell-docs/issues/1
13:16:33 * hackagebot haskell-docs 0.2.0.0 - A program to find and display the docs of a name from a  given module.  http://hackage.haskell.org/package/haskell-docs-0.2.0.0 (ChrisDone)
13:20:11 <ivanm> chrisdone: ta
13:21:38 <ivanm> chrisdone: especially since last night I was trying to work out how to display html docs in an emacs buffer so I didn't have to keep switching back and forth to check docs :p
13:21:55 <chrisdone> =)
13:22:59 <ivanm> so, what's different in this version that it's haddock-version-agnostic?
13:23:11 <ivanm> -Wall complains a few times though
13:23:27 <chrisdone> it's not agnostic, i just added some ifdefs to deal with the newer haddock
13:23:30 <chrisdone> and newer ghc
13:23:52 <chrisdone> #if MIN_VERSION_haddock(2,13,1) etc
13:24:19 <ivanm> in that case, you can remove the --constraint stuff from the .cabal file
13:25:20 <ivanm> and I just realised that of all the .dot files I copied over to this laptop before I left to go home for Christmas, I forgot to copy over my .ghci file :s
13:26:23 <chrisdone> the most important one!!
13:26:32 <sandeep> Hello everyone :)
13:26:42 <ivanm> nah, I think copying over my .emacs.d is a tad more important :)
13:26:50 * ivanm waves in sandeep's general direction
13:27:12 <sandeep> Hey sorry for being a n00b, but can somebody tell me exactly what haskell is used for?
13:27:25 <chrisdone> o_o
13:27:40 <chrisdone> writing programs
13:27:42 <ivanm> sandeep: writing software
13:27:53 <ivanm> chrisdone: or is that a premature generalisation? :p
13:28:17 <chrisdone> ivanm: only wave in sandeep's specific direction :p
13:28:25 <sandeep> it's a general purpose programming language?...how is it different from python or ruby..and doesn't haskell have an inclination towards mathematics?
13:28:39 <chrisdone> yeah
13:28:43 <ivanm> sandeep: why not try reading the wikipedia page, looking at some examples, etc.?
13:28:44 <chrisdone> all that
13:28:49 <sandeep> right
13:28:52 <sandeep> sounds goo
13:28:54 <sandeep> good*
13:28:56 <sandeep> thanks all :)
13:29:00 <ivanm> it'd probably be easier for you to comprehend that way rather than having lots of people offering points of view here :)
13:29:10 <sandeep> true :)
13:29:14 <fmap> @quote abstract.research
13:29:15 <lambdabot> Jafet says: Haskell is an abstract research language used only in academia, education, banking, stock trading, circuit design, embedded systems, cryptography, operating systems research, bioinformatic
13:29:15 <lambdabot> s, phone apps, and web services.
13:29:23 <chrisdone> the only reason you're not drowning in points of view is because it's a quiet period
13:29:50 <sandeep> ^^ Good one :P
13:30:07 <chrisdone> it's also used to make my laptop play music when i wave my arms
13:30:19 <ivanm> chrisdone: :o
13:30:31 <ivanm> you have packages for webcam support?
13:30:35 <chrisdone> i'd record a video to show you, but despite being a clever programmer i am too stupid to record sound from alsa with recordmydesktop
13:30:38 <pckt> I've used it to warm my room slowly
13:30:41 <sandeep> how @chrisdone?
13:30:49 <chrisdone> using my kinect and sdl =)
13:30:59 <sandeep> wow
13:31:05 <sandeep> you guys are pros here :O
13:31:10 <chrisdone> lol
13:31:13 * chrisdone beams
13:31:26 <ivanm> chrisdone: googling for "recordmydesktop sound" seems to give lots of solutions... :p
13:31:39 <sandeep> lol ^^
13:31:53 <chrisdone> ivanm: most of them are "from your microphone" from what i searched
13:32:06 <ivanm> ahhhh, right
13:32:08 <ivanm> you want arbitrary input?
13:32:25 <ivanm> IIUC, pulseaudio can do audio re-direction; but I've never used pulseaudio
13:32:30 <ivanm> there's also JACK...
13:32:32 <chrisdone> i did find good advice to use pulseaudio to set a "monitor" on my soundcard for recordmydesktop's input
13:32:41 <chrisdone> but it doesn't actually do anything
13:33:08 <chrisdone> i could setup jack, i suppose. renoise would prefer that i use jack over alsa. anyone use jack?
13:33:15 <ivanm> this page says you need to adjust the "wave" setting: http://recordmydesktop.sourceforge.net/rug/p1_2c.php
13:33:30 <ivanm> "Notice that wave is turned off. If it gets enabled (which in kmix happens by clicking on the leds), all sounds will be recorded(music, desktop environment notifications, etc.)."
13:33:42 <chrisdone> oooo
13:33:55 <chrisdone> ·Éö(‚ïπ‚ó°‚ïπ·Éö)
13:34:18 * chrisdone tries kmix
13:34:31 <ivanm> kmix is KDE 3.x though IIUC
13:34:58 <chrisdone> The following extra packages will be installed:
13:34:58 <chrisdone> [all of kde]
13:34:59 <chrisdone> After this operation, 135 MB of additional disk space will be used.
13:34:59 <chrisdone> Do you want to continue [Y/n]?
13:35:01 <chrisdone> hmmm =)
13:35:25 <ivanm> heh
13:35:28 <chrisdone> i don't care about the disk space actually, but i'm on a 32kbps mobile internet connection
13:35:40 <ivanm> ugh
13:35:48 <chrisdone> \o/ italy
13:36:07 <ivanm> can't get ADSL or cable?
13:36:23 <ivanm> I wonder whether it also depends upon your sound card...
13:36:24 <chrisdone> i'm waiting for adsl at the moment
13:36:29 <beaky> hello
13:36:31 <chrisdone> hm, could do
13:36:33 * hackagebot tdd-util 0.1.0.1 - Utilities for TDD with test-framework, HUnit, and QuickCheck  http://hackage.haskell.org/package/tdd-util-0.1.0.1 (ByronJohnson)
13:36:35 <chrisdone> ciao beaky
13:36:56 <neutrino_> mental note: learn go, right after you've learnt haskell.
13:37:12 <ivanm> oooohhh, another package with buzzword bingo in its synopsis! :p
13:37:25 <ivanm> neutrino_: so that'd be in what, 10 years? :p
13:37:37 <joar> I'm not getting this kind of notation: maybe :: b -> (a -> b) -> Maybe a -> b
13:37:38 <chrisdone> i'd complain about learning go, but one never stops learning haskell, so yeah "learn go after haskell!" hear, hear!
13:37:43 <neutrino_> someone got the joke :p
13:37:52 <neutrino_> joar: what do you not understand?
13:37:55 <ivanm> joar: in what sense?
13:37:57 <joar> I just started learning haskell, is there any explanation to what that would mean?
13:38:02 <neutrino_> joar: ok, wait a sec
13:38:04 <chrisdone> joar: do you have a book?
13:38:04 <ivanm> maybe is a function that takes three arguments:
13:38:14 <neutrino_> joar: do you know what this notation means? foo :: a -> b
13:38:14 <joar> chrisdone: haskell book? no
13:38:16 <ivanm> joar: do you know what the Maybe type is?
13:38:21 <ivanm> @src Maybe
13:38:21 <lambdabot> data Maybe a = Nothing | Just a
13:38:22 <ivanm> @src maybe
13:38:23 <lambdabot> maybe n _ Nothing  = n
13:38:23 <lambdabot> maybe _ f (Just x) = f x
13:38:25 <chrisdone> interesting. if you get a book, it would make learning a lot easier
13:38:26 <joar> I'm uncertain about the "->"
13:38:31 <chrisdone> @google learn you a haskell
13:38:33 <lambdabot> http://learnyouahaskell.com/
13:38:33 <lambdabot> Title: Learn You a Haskell for Great Good!
13:38:34 <chrisdone> @google real world haskell
13:38:36 <lambdabot> http://book.realworldhaskell.org/
13:38:36 <lambdabot> Title: Real World Haskell
13:38:39 <neutrino_> joar: "goes to"
13:38:43 <ivanm> joar: "a -> b" means "this is a function that takes in a value of type `a' and returns a value of type `b' "
13:39:01 <neutrino_> joar: foo :: a -> b means that foo defines a function such that the type a goes to the type b.
13:39:39 <neutrino_> joar: you'll be well-served reading lyah
13:39:41 <neutrino_> @where lyah
13:39:41 <lambdabot> http://www.learnyouahaskell.com/
13:40:04 <joar> so the "maybe" method takes in a 'b', turns it into an 'a' (to) 'b' then turns that into an 'Maybe a' and returns a 'b'?
13:40:25 <ivanm> joar: no
13:40:27 <ivanm> @src maybe
13:40:28 <lambdabot> maybe n _ Nothing  = n
13:40:28 <lambdabot> maybe _ f (Just x) = f x
13:40:47 <ivanm> joar: ^^ it takes in a default "b" to be used when the Maybe value is Nothing
13:40:50 <joar> and what does _ mean?
13:41:04 <ivanm> "any value"; it doesn't give the variable/input a name
13:41:13 <joar> ack
13:41:15 <ivanm> a function (a -> b) that applies to the value inside a Just
13:41:20 <ivanm> and then an actual maybe value
13:41:30 <ivanm> > maybe "hi" show Nothing
13:41:32 <lambdabot>   "hi"
13:41:35 <ivanm> > maybe "hi" show (Just 3)
13:41:37 <lambdabot>   "3"
13:41:38 <chrisdone> > 'b' : replicate 50 'o' ++ "k"
13:41:40 <lambdabot>   "booooooooooooooooooooooooooooooooooooooooooooooooook"
13:41:47 <ivanm> chrisdone: or online tutorial
13:41:56 <ivanm> wasn't there one at a site called tryhaskell.org? :p
13:42:01 <chrisdone> joar: http://tryhaskell.org
13:42:10 <joar> I'm following http://www.haskell.org/haskellwiki/Hitchhikers_guide_to_Haskell, but I feel I have missed out on some core things and I'm mostly writing whatever I'm told to write and try if it works.
13:42:11 <chrisdone> ivanm: it's like we're twins OMG TWINNY
13:42:22 * ivanm shudders and runs
13:42:25 <elliott> joar: you should read learn you a haskell instead
13:42:26 <chrisdone> ;_;
13:42:31 <ivanm> joar: yeah, that's old and probably not that good
13:42:33 <elliott> that guide is very old
13:42:34 <chrisdone> learn you a haskell++
13:42:46 <elliott> @where lyah
13:42:47 <lambdabot> http://www.learnyouahaskell.com/
13:43:02 <ivanm> @where tutorials
13:43:02 <lambdabot> http://haskell.org/haskellwiki/Tutorials
13:43:05 <ivanm> @where books
13:43:05 <lambdabot> See `LYAH',`RWH',`YAHT',`HR',`wikibook',`non-haskell-books'
13:43:14 <ivanm> @where HR
13:43:14 <lambdabot> "The Haskell Road to Logic, Maths and Programming", by Kees Doets,Jan van Eijck, at <http://homepages.cwi.nl/~jve/HR/>
13:43:17 <Jeanne-Kamikaze> hitchhikers guide to haskell :/
13:43:17 <ivanm> ahhh, that one
13:43:30 <ivanm> I thought there'd be a link to the wiki for textbooks
13:43:31 <chrisdone> i have that book in dead tree form
13:43:44 <ivanm> I have a PDF and have read it in dead tree form
13:44:00 <chrisdone> didn't read it all though, turns out i find logic for the sake of logic really boring
13:44:07 <bcl> joar: I just re-started with learnyouhaskell and so far it is pretty good.
13:44:25 <bcl> my previous attempts with other books kept getting stuck.
13:45:39 * ivanm wanders off to get breakfast
13:46:01 <chrisdone> ivanm: get toast with honey!
13:46:29 <ivanm> nah, I prefer cereal
13:47:12 <chrisdone> corn flakes with honey!
13:47:23 <chrisdone> lol
13:47:38 <joar> I'll read learnyouahaskell then
13:47:47 <luite> muesli with yoghurt and honey!
13:47:48 <joar> it seems to be what most votes are for
13:47:57 <chrisdone> ‚Äúivan typed into the computer, ‚Äò/me wanders off to get breakfast‚Äô, then he paused, and looked at the computer for a little while longer‚Äù
13:48:19 <chrisdone> luite: ooo. that's gotta be filling! i can only eat a few spoonfuls of muesli and i'm full for three days
13:48:49 * ivan wanders off to eat chrisdone for breakfast
13:48:50 <luite> oh i really like it for lunch when i'm really hungry :)
13:49:03 <aristid> ivan: that's not nice
13:50:00 <chrisdone> not only does he propose to eat me, but he considers my carcass only worth of mere breakfast
13:50:13 <DigitalKiwi> most important meal of the day
13:50:28 <chrisdone> chrisfast
13:50:47 <aristid> chrisdone: how dare you suggest that breakfast is not a worthy meal
13:51:08 <chrisdone> what are ya gonna do about it? eat me?
13:51:16 <aristid> maybe.
13:51:22 <chrisdone> ·ï¶(√≤_√≥Àá)·ï§
13:51:35 <aristid> oh no that smiley has muscle-arms
13:52:05 <message144> joar, i hate to complicate things, but I am also in the learning process.. I did not personally have much luck with Learn You Haskell, but have done well with "Programming In Haskell".. just my two cents
13:52:08 <luite> hm, i really should fix my terminal to be able to see chrisdones magnificent smileys
13:52:19 <aristid> luite: yes.
13:52:20 <chrisdone> lol
13:52:33 <chrisdone> what is your current font, btw?
13:52:41 <luite> i think it's consolas
13:52:49 <joar> message144: gah
13:53:02 <chrisdone> hmm. what terminal? i thought pango used fallbacks
13:53:09 <joar> Inconsolata works great
13:53:12 <luite> oh this is mac
13:53:13 <joar> in gnome-terminal
13:53:16 <chrisdone> ah, ok
13:53:24 <luite> but it's probably because i've forgotten something in my screen
13:53:28 <chrisdone> so what does the mac show for chars it doesn't know? that diamond or question marks?
13:53:36 <luite> question marks
13:53:37 <chrisdone> or boxes
13:53:39 <chrisdone> ah, ok
13:53:50 <aristid> luite: i use Monaco
13:53:53 <luite> ?(?_??)?
13:53:53 <lambdabot> Unknown command, try @list
13:53:54 <aristid> on my mac
13:54:09 <chrisdone> yeah it's nice how pango falls back, i can tell that ubuntu font doesn't have ‚Üí because it makes the line bigger, indicating it's probably dejavu or something
13:54:35 <ippo> hi everyone. is there any package for signal processing? i have a matlab application i'd like to port over, but I can't find a dsp package
13:54:44 <luite> aristid: hm, lemme check, i have consolas in emacs, not sure about terminal
13:54:56 <luite> ah it's andale mono
13:55:00 * aristid also finds it funny when hpaste does not line up line numbers with lines anymore due to big unicode characters
13:55:13 <chrisdone> lol
13:55:14 <aristid> luite: Monaco seems to be relatively good about the unicodes.
13:55:27 <luite> aristid: i think it's probably not a font issue
13:55:29 <aristid> chrisdone: that happens a lot when you hpaste agda code!
13:55:29 <chrisdone> all the codes!
13:55:43 <luite> not sure though
13:56:01 <chrisdone> yeah looking at agda code makes me cringe
13:56:31 <aristid> chrisdone: Swap : Iso (Set √ó Set) (Œª p ‚Üí proj‚ÇÅ p √ó proj‚ÇÇ p) (Œª p ‚Üí proj‚ÇÇ p √ó proj‚ÇÅ p)
13:56:32 <aristid> :P
13:58:28 <ippo> hi everyone. is there any package for signal processing? i have a matlab application i'd like to port over, but I can't find a dsp package
13:58:43 <beaky> @hoogle dsp
13:58:43 <lambdabot> package dsp
13:58:44 <lambdabot> Prelude readsPrec :: Read a => Int -> ReadS a
13:58:44 <lambdabot> Text.Read readsPrec :: Read a => Int -> ReadS a
13:58:57 <chrisdone> it's like the programmer is thinking ‚Äúi think i'll use a for this variable name.‚Äù and a voice in their head says ‚Äúno, use Œû so that no one can type or pronounce your code, your code is untouchable!‚Äù ‚Äúyeah, my code is untouchable‚Äù
13:59:18 <beaky> chrisdone: haha
13:59:35 <beaky> ippo: might check out http://hackage.haskell.org/package/dsp
14:00:26 <chrisdone> ah, crap, that reminds me, brian mckenna's esolang competition is in progress
14:00:56 <chrisdone> i was thinking of maybe doing a prolog with anonymous rules
14:01:01 <chrisdone> has that been done before?
14:01:13 <aristid> does it matter?
14:01:22 <chrisdone> yeah, it's gotta be esoteric :p
14:01:26 <chrisdone> eso-lang
14:01:33 <aristid> it's still esoteric enough if you ask me
14:01:47 <chrisdone> well, this month's theme is turing tarpit
14:01:56 <aristid> you could use unicode for everything to make it more esoteric
14:02:03 <chrisdone> so i wanted to do JUST first-class anonymous rules, like lambda calculus but instead of abstractions, rules
14:02:11 <beaky> on one hand, the symbols lead to concise code. on the other hand, it leads to dense code :D
14:02:40 <elliott> chrisdone: there is lambda prolog
14:02:50 <elliott> http://en.wikipedia.org/wiki/%CE%9BProlog
14:02:52 <chrisdone> elliott: what's it got?
14:02:57 <elliott> lambda
14:02:58 <chrisdone> my connection's too slow to open wikipedia
14:03:00 <elliott> also, prolog
14:03:08 <elliott> I don't know much about it
14:03:12 <aristid> chrisdone: btw. typing unicode symbols is not hard at all :P just need to enable agda-mode
14:03:45 <chrisdone> (1) open emacs (2) M-x agda-mode (3) go back to browser/irc client/email client/console (4) paste
14:04:41 <aristid> nothing could be easier.
14:06:52 <chrisdone> i thought a first-class pattern matching language would also be good, but someone already submitted such a language
14:07:59 <chrisdone> i had an idea of a language with unrestricted macros based on indentation
14:08:34 <astropirate> call it zoidburg
14:08:35 <astropirate> (\/) (∞,,,∞) (\/) woop woop woop woop
14:08:35 <chrisdone> like:
14:08:35 <chrisdone> somemacro everything past this point is
14:08:36 <chrisdone>           interpreted by the macro as a string
14:08:43 <Canar> first-class pattern matching? what would that look like to you?
14:08:44 <elliott> a string :(
14:08:53 <Canar> i hear pattern matching and i think prolog
14:09:08 <Canar> but that's just because i'm a rabid prolog fanboi
14:09:17 <chrisdone> sql SELECT * FROM blah ‚Ä¶;
14:09:17 <chrisdone> = x *2/4-3
14:09:18 <chrisdone> ‚Äú=‚Äù could be a macro to say "here comes maths"
14:09:30 <companion_cube> prolog has full unification, it's even better
14:09:41 <Canar> companion_cube: yea
14:09:45 <Canar> exactly
14:09:49 <chrisdone> elliott: yeah, but you could provide reification tools like String ‚Üí Maybe ExistingVar
14:11:48 <chrisdone> canar: well, like plet (x,y) = Pattern x y in case (1,2) of Pattern 1 2 -> ‚Ä¶
14:11:52 <`nand`> hmm
14:12:33 <chrisdone> actually lennart augustsson was doing some work on something similar to this when i spoke to him at camhac, iirc
14:12:46 <chrisdone> but it was more like "pattern aliases"
14:13:14 <elliott> chrisdone: check out lens
14:13:16 <chrisdone> whereas you could have an arbitrary function serve as a pattern, like view patterns but not sucky
14:13:20 <elliott> prisms are a first-class pattern abstraction
14:13:30 <elliott> (no language support but there could be and they work with view patterns)
14:13:55 <edwardk> prisms are categorically dual to lenses, and turned out to be effectively first-class patterns
14:14:24 <edwardk> well, first-class constructors
14:14:31 <chrisdone> edwardk: do they take functions as arguments?
14:14:34 <edwardk> because you can use them to inject as well
14:14:35 <Canar> elliott / edwardk: could I get some articles on either?
14:14:41 <neutrino_> first-class templates :)
14:14:44 <edwardk> :t prism
14:14:46 <lambdabot> (Applicative f, Prismatic k) => (b -> t) -> (s -> Either t a) -> k (a -> f b) (s -> f t)
14:14:51 <Canar> oh
14:15:02 <elliott> Canar: the documentation describes them pretty well
14:15:17 <elliott> yuck, the old prism signature
14:15:18 <`nand`> I think the type interpretation of ‚ÄòŒ£(T(x))‚Äô (meaning sum of T(x) for every possible x) is ‚Äòexists x. T x‚Äô -- it seems to hold for lists; being Œ£(a^x) or a^0 + a^1 + a^2... where a^x corresponds to Vec a x; and I can go on to define data List a = forall x. List (Vec a x) and write the isomorphisms :: List a -> [a] and :: [a] -> List a
14:15:23 <chrisdone> edwardk: i mean the magic of patterns is that they introduce bindings, how do you do that?
14:15:24 <`nand`> does this hold for every type, though?
14:15:48 <Canar> just when I think I'm getting Haskell, I read something here and the computer scientist in me cries at how little I really know
14:16:03 <Canar> FFS a BSc just isn't enough :(
14:16:19 <elliott> `nand`: sum is dependent tuple yes
14:16:22 <neutrino_> @where lyah
14:16:23 <lambdabot> http://www.learnyouahaskell.com/
14:16:23 <elliott> `nand`: product is dependent function arrow!
14:16:25 <chrisdone> i only have to look at the cover of my knuth books to feel like that
14:16:33 <`nand`> elliott: awesome, that would have been my next question
14:16:38 <`nand`> elliott: dependent function arrow?
14:16:42 <elliott> yes
14:16:45 <elliott> as in (x:A) -> B
14:16:51 <elliott> or equivalently forall (x:A). B
14:17:07 <elliott> note that if you ignore the variable you're summing/producting over, the sum just becomes multiplication (= product = tuple)
14:17:17 <elliott> and the product just becomes exponentiation (= function)
14:17:18 <edwardk> chrisdone: prisms capture the 'one of several alternatives' side of a pattern. if you think of lenses as splitting something into 'the target of the lens (b) and everthing else ( c ) '  eg.   a <-> exists c. (b,c)
14:17:18 <`^_^v> canar, that's pretty much how people feel in every field
14:17:29 <`^_^v> don't worry, it's normal
14:17:40 <edwardk> then a prism takes you from a  <-> exists c. Either b c
14:17:45 <elliott> `nand`: see also e.g. http://en.wikipedia.org/wiki/Intuitionistic_type_theory#Connectives_of_type_theory
14:18:09 <edwardk> er forall
14:18:12 <chrisdone> edwardk: so an example code? my connection's 32kbps until midnight, then i can browse the web again =)
14:18:14 <neutrino_> `nand`: what x does [1, 1, ...] use?
14:18:43 <edwardk> chrisdone: sure. https://github.com/ekmett/lens/blob/master/src/Control/Exception/Lens.hs is probably the biggest hierarchy done with prisms and isos
14:18:43 <`nand`> neutrino_: any infinite type
14:18:54 <chrisdone> can't browse web ‚Üí provides link
14:18:54 <`nand`> neutrino_: Integer, for example
14:18:56 <chrisdone> lol
14:19:02 <edwardk> catching nonTermination
14:19:36 <chrisdone> edwardk: github is too heavy to open i'm afraid. it's surprising how heavy pages are these days
14:19:41 <chrisdone> is the code short enough to paste here?
14:19:55 <chrisdone> or maybe the raw link i can load
14:19:57 <edwardk> nonTermination :: Prism' SomeException NonTermination
14:20:02 <elliott> chrisdone: https://raw.github.com/ekmett/lens/master/src/Control/Exception/Lens.hs
14:20:10 <chrisdone> cheers
14:20:10 <edwardk> elliott: he can't load it
14:20:23 <chrisdone> let's see‚Ä¶
14:20:34 <elliott> edwardk: <chrisdone> or maybe the raw link i can load
14:20:40 <edwardk> ah
14:20:46 <chrisdone> ok this loaded up =D
14:20:47 <edwardk> that raw link might be good, yeah
14:21:07 <edwardk> chrisdone: this module is very much a work in progress
14:21:19 <edwardk> handling_ nonTermination (return "caught") $ throwIO NonTermination
14:21:31 <chrisdone> hmm, ok, i get this
14:21:46 <edwardk> nonTermination is a prism, there i'm saying match on that case
14:21:55 <chrisdone> right
14:21:56 <edwardk> this gives prisms for the open exception hierarchy
14:22:05 <edwardk> easy to catch with a prism easy to throw with one
14:22:11 <edwardk> throwing _nonTermination ()
14:22:13 <neutrino_> `nand`: sorry, i thought Vec a b meant "b-tuple of a", where b is a zermelo-encoded nat.
14:22:14 <conal> edwardk: have you played with a category-generalized version of Traversable?
14:22:47 <edwardk> conal: i have an indexed form of it in github.com/ekmett/indexed but i punted on that project until 7.8 or so
14:23:00 <conal> edwardk: i'm wondering whether the applicative stays or goes. and if it goes, is it just functor?
14:23:26 <conal> edwardk: what's coming in 7.8?
14:23:42 <edwardk> conal: well, right now product kinds are basically useless. hopefully they'll be fixed by then
14:23:45 <`nand`> neutrino_: I don't know what zermelo-encoding is; but using peano encoding an infinite list would be the ‚Äòfix Succ‚Äô-tuple of a
14:23:56 <Twisol> In Javascript, I often find myself taking a bunch of objects and wiring them up through their events. It feels a lot like composition, but with multiple places data can go in or out. Can an analogous construct be defined in Haskell?
14:23:58 <neutrino_> peano, yes. sorry, food coma hitting in.
14:23:59 <`nand`> neutrino_: I was being a bit informal earlier
14:24:17 <neutrino_> i know you were
14:24:18 <`nand`> neutrino_: I said ‚Äúfor every x‚Äù but what I really meant is for all x ‚àà Nat
14:24:30 <conal> edwardk: ah, okay.
14:24:34 <`nand`> so you're right, I'd use exists (n :: Nat). Vec a n
14:24:43 <edwardk> conal: also i dunno if you've tuned into the lens chatter in the last couple of weeks or not, but amusingly we found a nice form of profunctor-based lenses where it isn't traverse that is the most useful default‚Ä¶ but rather then SEC
14:24:44 <`nand`> and consequently an infinite list would be the only infinite Nat
14:24:51 <chrisdone> Twisol: possibly arrowy
14:24:51 <edwardk> er but rather SECs
14:25:07 <neutrino_> right, but that only defines all finite lists since there is no infinite natural number
14:25:09 <conal> edwardk: no, i hadn't noticed.
14:25:33 <edwardk> lens is picking up some benefits inspired by that. in particular this lead to prisms and isomorphisms that can be composed with (.) and id from the prelude
14:25:41 <neutrino_> of course, you could sum over Natu{+oo} and then you're fine
14:25:52 <edwardk> so now the entire lens hierarcy doesn't need Control.Category
14:25:53 <Taneb> Is Void a Semigroup?
14:25:55 <edwardk> er hierarchy
14:26:02 <edwardk> Taneb: sure. give me two of them i'll give you one back
14:26:03 <elliott> Taneb: yes
14:26:14 <Taneb> Yay
14:26:16 <edwardk> Taneb: if you gave me one in the first place i'll look at you funny though ;)
14:26:27 <elliott> Taneb: (Void -> Void -> Void) matches (Void -> a) so absurd satisfies its type
14:26:32 <`nand`> edwardk: product kinds? as in '(,) :: a -> b -> (a,b) ? What's wrong with them?
14:26:47 <elliott> Taneb: and laws are easy to prove about Void because "for all Voids x y z, x <> ..." is trivially true!
14:26:50 <Taneb> Not sure how useful that will ever be...
14:26:51 <edwardk> `nand`: they are inhabited by an extra identifiable 'Any' type
14:26:54 <`nand`> oh, that
14:26:56 <edwardk> so its not x * y, its x * y + 1
14:27:05 <`nand`> I remember asking you this before
14:27:37 <edwardk> `nand`: also there is an issue with the fact that you can't infer from x :: (a,b)    that x ~ '(y,z)  with y :: a, z :: b
14:27:59 <edwardk> which is related to the former, but resolving the former is not strictly enough to fix the latter.
14:28:01 <`nand`> edwardk: will you be able to do that in the absence of Any?
14:28:02 <`nand`> oh
14:28:16 <Modius> The warning on, and consequently type sig on, toplevel functions in a haskell codebase <-- retain?
14:30:00 <neutrino_> `nand`: i think the p
14:30:11 <neutrino_> `nand`: i think the operation you're looking for is set closure
14:31:06 <`nand`> elliott: back to your dependent arrow example for products, that makes perfect sense
14:32:35 <elliott> `nand`: if you think about it, the cardinality of (x:A) -> B is sum (x in A) |B|, too
14:32:38 <elliott> er
14:32:39 <elliott> s/sum/product/
14:33:29 <otters> who wrote the yesod guide
14:33:29 <lambdabot> otters: You have 1 new message. '/msg lambdabot @messages' to read it.
14:33:44 <otters> the grammar is clumsy
14:34:05 <`nand`> elliott: yeah
14:34:29 <neutrino_> otters: don't read lyah then
14:34:40 <otters> lyah is much better than the yesod guide
14:34:45 <neutrino_> `nand`: what is the product defined as?
14:35:10 <`nand`> elliott: I was mainly thinking in terms of ‚Äòproduct of T(x) for every x:A -> no matter what a‚ààA you choose, there's a T(a); which lines up with forall (a :: A). T a‚Äô
14:36:03 <neutrino_> is the product like a generalized "either" with arbitrarily many type constructors?
14:36:09 <`nand`> neutrino_: Œ£(T(x)) = exists x. T x; Œ†(T(x)) = forall x. T x
14:36:19 <`nand`> generalized tuple with many fields
14:36:27 <`nand`> the sum would be a generalized either with many constructors
14:36:31 <neutrino_> ok, so it's cartesian product?
14:36:32 <`nand`> think product types, sum types
14:36:35 * hackagebot sandi 0.1.1 - Data encoding library  http://hackage.haskell.org/package/sandi-0.1.1 (MagnusTherning)
14:37:07 <Feuerbach> otters: I'm sure that whoever wrote it would appreciate your corrections
14:37:15 <otters> I doubt that
14:37:23 <Feuerbach> why?
14:37:36 <otters> oh, were you being serious
14:37:42 <Feuerbach> yes
14:37:47 <Modius> Is there a core lib or anything commonly used, or common pattern, for naming a list of minimum length 1 or 2?
14:38:29 <neutrino_> yes.. (x, y, z) :: (a, a, [a])
14:38:34 <bootcode> Modius: NonEmpty or something like it?
14:39:16 <Modius> Thanks - I knew of doing the tuple thing, I'll also look into NonEmpty
14:39:35 <neutrino_> yw :)
14:40:16 <`nand`> you could use a List' a (a, a) where List' a is the free monad version of lists
14:40:35 <`nand`> or just make your own ‚Äúlists-with-terminators‚Äù
14:41:08 <`nand`> data List' b a = Nil b | Cons a (List' b a) -- list with length ‚â•2 = List' (a,a) a
14:41:14 <`nand`> of course, none of these are very nice
14:42:30 <`nand`> What would this be in dependently typed languages? ‚Äòexists n. n‚â•2 *> Vec a n‚Äô ?
14:43:40 <shachaf> (n:Nat, Vec a (S (S n)))?
14:43:47 <shachaf> Or presumably you could just do what you said.
14:43:53 <`nand`> that would be even simpler
14:44:05 <`nand`> wouldn't work for something like n ‚â§ 5 though
14:44:13 <`nand`> actually, something else would
14:44:20 <shachaf> n:Fin 5?
14:44:23 <`nand`> yeah
14:49:58 <McManiaC> hey, if I try to install something with cabal I always get:
14:50:00 <McManiaC> cabal: Couldn't read cabal file "hashable/1.2.0.0/hashable.cabal"
14:50:51 <hpaste> ‚Äú`nand`‚Äù pasted ‚ÄúList with minimum length‚Äù at http://hpaste.org/79891
14:50:54 <`nand`> oh wow, this actually works
14:50:54 <McManiaC> (freebsd/ghc 7.4.1/cabal-install 0.10 /cabal 1.10)
14:51:09 <ivanm> McManiaC: try cleaning your downloaded package cache?
14:51:40 <ivanm> rm -rf ~/.cabal/packages/hackage.haskell.org/*
14:51:49 <ivanm> then cabal update
14:51:50 <McManiaC> ivanm: already did that
14:51:53 <ivanm> huh
14:51:54 <McManiaC> i think
14:52:07 <ivanm> get a newer version of cabal-install?
14:52:13 <chrisdone> `nand`: i think with ghc 7.6 you could use number literals instead of the Nat
14:52:28 <`nand`> chrisdone: not 7.6
14:52:45 <`nand`> chrisdone: no way to pattern match or increment the 7.6 literals
14:53:27 <chrisdone> hm, what about the singletons that bring type values into runtime values?
14:53:28 <Enigmagic> `nand`: pattern match no (seems to be working on the type-nats branch now btw), but i thought + and * was in GHC.TypeLits in 7.6
14:53:44 <`nand`> Enigmagic: they have no instances
14:54:00 <Enigmagic> `nand`: type X = 8 + 5 should work
14:54:11 <`nand`> yes, but 8 + 5 ~ 13 doesn't hold
14:54:12 <chrisdone> oh i thought arithmetic was working by now
14:54:30 <`nand`> hmm, maybe it does by now
14:54:44 <chrisdone> hmm
14:54:47 <monadicity> hello
14:55:05 <Enigmagic> `nand`: the solver that proves 8+5 ~ 13 is in the type-nats branch, i don't know if it's been merged into master in whole or part though
14:55:29 <`nand`> isn't in 7.6 at the very leasy
14:55:34 <`nand`>     Couldn't match type `1 + 2' with `2 + 1'
14:55:41 <`nand`> s/leasy/least/
14:55:42 <Enigmagic> `nand`: no it's not in 7.6
14:55:42 <chrisdone> Enigmagic: is it just implemented as Nat = S Nat | Z underneath?
14:55:47 <monadicity> haskell category
14:55:52 <Enigmagic> chrisdone: no
14:55:52 <`nand`> chrisdone: I think it would be more efficient internally
14:56:13 <chrisdone> yeah i guess. at this rate i think people would be happy even with that =)
14:57:16 <monadicity> hey
14:57:22 <Enigmagic> chrisdone: he had some function to convert a Nat1 (that used S Nat | Z) to a Nat (that uses something more like an Integer)... but it looks like pattern matching on Nats seems to work so I haven't had to use the Nat1 rep
14:57:33 <Enigmagic> err Nat1 = S Nat1 | Z
14:57:45 <chrisdone> nod
14:58:47 <chrisdone> then again i suppose people would want integers, not nats?
14:59:10 <Enigmagic> chrisdone: well you can get an Integer back out..
14:59:11 <`nand`> you mean Nat1 = S Nat1 | One ?
14:59:22 <chrisdone> i mean 5-7
14:59:59 <Enigmagic> chrisdone: there is - but it's undefined for results that aren't naturals
15:00:06 <chrisdone> unless i'm having a brainfart and 'natural' doesn't mean 'positive integers' anymore
15:00:13 <chrisdone> undefined? o_o
15:00:29 <`nand`> oh whoa, ‚Äòsingletons‚Äô lets me reflect  singletons a gain
15:00:31 <`nand`> again*
15:00:32 <monadicity> help
15:00:45 <`nand`> forgot about / didn't know that, that should scrap some boilerplate in my libraries
15:00:58 <chrisdone> the singleton stuff is cool
15:01:05 <Enigmagic> chrisdone: https://github.com/ghc/packages-base/blob/master/GHC/TypeLits.hs#L114
15:01:07 <Enigmagic> that's what it says
15:05:18 <`nand`> type family Foo a :: *; -- with no further instances
15:05:25 <`nand`> Foo Int is a valid type; and is simply Foo Int
15:05:33 <Enigmagic> `nand`: it's implemented in GHC not in a library
15:05:55 <`nand`> I'm just showing that type families being undefined makes sense
15:06:38 <Enigmagic> `nand`: right but the (-) family has instances, they're just not defined in base
15:06:55 <`nand`> yeah but I mean 0 - 1 can stand as-is
15:06:59 <`nand`> it would simply not reduce further
15:07:46 <chrisdone> so if you get to a negative ghc would just throw a compile error?
15:08:00 <Enigmagic> i dunno, let me try it out
15:10:13 <`nand`> no
15:10:19 <`nand`> not necessarily
15:10:43 <`nand`> well, or you could define it as Any
15:10:47 <Enigmagic> simple test case does... type Foo = 0 - 1
15:10:51 <`nand`> but as I understood it Any is being taken out
15:10:55 <Enigmagic>     Couldn't match type `t0 + 1' with `0'
15:11:03 <chrisdone> neat
15:11:06 <`nand`> ah, okay
15:11:08 <Enigmagic> dunno why the error shows (+) instead of (-)
15:11:16 <chrisdone> maybe -1 is just + n-1
15:11:29 <`nand`> I think that might be because 0 - 1 is matching 0 against (n + 1)
15:11:48 <`nand`> I didn't expect that though. Is it a special case for numbers? I thought type families are inherently open
15:12:03 <Enigmagic> `nand`: type families on data kinds are closed
15:12:10 <`nand`> what exports Constraint again?
15:12:23 <elliott> ghc.exts
15:12:25 <`nand`> Enigmagic: is that a part of the new changes?
15:12:30 <`nand`> elliott: thanks
15:12:49 <Enigmagic> `nand`: well think about how many instances are possible for 'type family Foo (x :: Bool) :: *'
15:13:50 <`nand`> what I mean is
15:13:52 <`nand`> Œª type family Foo (x :: Bool) :: *
15:13:54 <`nand`> Œª type instance Foo False = Int
15:13:56 <`nand`> Œª type Bar = Foo True
15:13:58 <`nand`> Œª
15:14:00 <`nand`> this doesn't error
15:14:23 <`nand`> so why should (0 - 1) ?
15:14:39 <Enigmagic> `nand`: it doesn't error until i tried using it
15:15:01 <`nand`> using it in which way?
15:15:13 <Enigmagic> main = print (undefined :: Blah Foo)
15:15:57 <chrisdone> cmccann: *wave*
15:16:12 <cmccann> 'sup.
15:16:44 <`nand`> with my example that would give a No instance for Show (Foo 'True) or whatever error
15:16:45 <chrisdone> wanted to talk you earlier, but can't remember what for
15:16:53 <`nand`> but not, say, Could not match 'True with 'False
15:18:01 <`nand`> for an unrelated issue; I'm getting some odd errors from singletons
15:18:15 <`nand`> Not in scope: `sEQ'; Not in scope: `sLT' etc.
15:19:11 <cmccann> chrisdone, praise for my HTML5 method of playing sound files, no doubt.
15:19:53 <chrisdone> never!!
15:20:38 <chrisdone> hehe, i was considering using it at one point‚Ä¶ with a server to control it
15:20:46 <cmccann> haha
15:21:08 * elliott wonders about this method
15:21:35 <cmccann> html5 power! slowly but surely turning what was once a markup language for documents into some unholy semi-cross-platform UI toolkit.
15:22:42 <cmccann> elliott, the reference is to this: http://stackoverflow.com/a/14005813/157360
15:24:46 <Hafydd> Or: HTML5! Slowly but surely changing the definition of "document".
15:25:33 <cmccann> Hafydd, that works too. it's certainly changing something.
15:27:24 <SLi> To me it seems it's doing to HTML what C++ did to C. (NB. I still use C++ and happen to think that it often is superior to C, and HTML5 probably to lesser HTMLs, but C++ certainly still is an unholy mess :-)
15:28:31 <hpaste> ‚Äú`nand`‚Äù pasted ‚ÄúSingletons fail‚Äù at http://hpaste.org/79892
15:28:41 <`nand`> ^- here's a minimal failure for the singletons issue I'm experiencing
15:28:55 <`nand`> oh, of course
15:29:00 <cmccann> SLi, to be fair in many ways HTML5 is actually less of a mess than what it's trying to replace
15:29:00 <`nand`> it's lacking singletons for Ordering
15:29:25 <cmccann> if nothing else, it's organizing and documenting the existing mess, which is still an improvement
15:30:08 <chrisdone> yeah it's an interesting route
15:30:21 <chrisdone> instead of "think real hard and make something good and then make it popular", they've gone the reverse
15:30:22 <cmccann> and the new features being added are largely about direct support for things that people used hacky workarounds or third-party stuff for.
15:30:37 <chrisdone> "take some thing shitty and popular and make it gradually better through thinking hard"
15:31:02 <chrisdone> right
15:31:08 <cmccann> html5 is horrifying out of necessity; personally I can't think of anywhere that it's even moderately more horrible than it has to be, though.
15:31:30 <SLi> cmccann, true enough.
15:31:36 * hackagebot family-tree 0.3.0.3 - A family tree library for the Haskell programming language.  http://hackage.haskell.org/package/family-tree-0.3.0.3 (NathanVanDoorn)
15:31:49 <Taneb> Hopefully this time I've got that right
15:32:41 <chrisdone> cmccann: by the way the sound stuff was for this app https://dl.dropbox.com/u/62227452/Screenshots/kn.ogv
15:33:14 <chrisdone> cmccann: the circles are just debugging overlays. you can't hear it because i can't figure out to make recordmydesktop's recordmysound, but it plays a different note under each hot spot
15:33:27 <cmccann> neat!
15:33:32 <chrisdone> i'm going to make a whole grid and then it's like a party piece, people walk around and wave to make music =]
15:33:46 <cmccann> SLi, anyway, the biggest gripe I have with html5 is having to use javascript
15:33:51 <SLi> But for many parts C++ is also horrifying out of necessity (when the problem set consists of making a powerful language backwards compatible with C and supporting the inventive ways to (ab)use the horrors of the language that people have found).
15:34:03 <Hafydd> HTML5 reduces the need for Javascript.
15:34:06 <SLi> I also hear that javascript is quite tolerable. Sort of. ;)
15:34:12 <johnw> this is better talk for -blah, btw
15:34:18 <johnw> or overflow
15:34:32 <chrisdone> ehh only if it's interrupting on-topic chat
15:34:42 <cmccann> well, hating js brings us back around to why this came up in the first place
15:34:46 <zenlike> Hey guys, total haskell newbie here and I am wondering if anyone could tell me what <+> might mean in the context of a Haskell statement
15:34:55 <chrisdone> technically we can use the webkit DOM from haskell with the bindings
15:34:55 <elliott> @hoogle (<+>)
15:34:55 <cmccann> which was me using fay to play audio with html5
15:34:55 <lambdabot> Control.Arrow (<+>) :: ArrowPlus a => a b c -> a b c -> a b c
15:34:56 <lambdabot> Language.Haskell.TH.PprLib (<+>) :: Doc -> Doc -> Doc
15:34:56 <lambdabot> Text.PrettyPrint.HughesPJ (<+>) :: Doc -> Doc -> Doc
15:35:06 <chrisdone> not sure if that also includes making audio objects and such, tho
15:35:07 <zenlike> Specifically, that idiom is used in some of my XMonad config files and I'm trying to figure out what it means
15:35:14 <chrisdone> i'd expect so, seeing as it's just another dom object
15:35:24 <elliott> zenlike: ahh
15:35:27 <elliott> I think xmonad defines its own (<+>)
15:35:33 <zenlike> Oh
15:35:47 <zenlike> O_o
15:36:04 <chrisdone> ‡≤†_‡≤∞‡≥É
15:36:12 <fmap> it's mappend
15:36:23 <zenlike> Haha I am so new to the language and it's a lot to take in.  Very cool language though.  mappend?
15:36:43 <chrisdone> @src Monoid
15:36:43 <lambdabot> class Monoid a where
15:36:43 <lambdabot>     mempty  :: a
15:36:43 <lambdabot>     mappend :: a -> a -> a
15:36:43 <lambdabot>     mconcat :: [a] -> a
15:36:56 <chrisdone> all monoids have the mappend operation
15:37:01 <chrisdone> @google wikipedia monoid
15:37:03 <lambdabot> http://en.wikipedia.org/wiki/Monoid
15:37:03 <lambdabot> Title: Monoid - Wikipedia, the free encyclopedia
15:37:09 <monadicity> instance Monad Zen where return = return
15:37:10 <zenlike> chrisdone: graci
15:37:28 <chrisdone> i think <+> was one of the proposed operators for mappend, though i think <> might have won instead
15:37:45 <cmccann> I still think (++) should be mappend
15:37:45 <cmccann> >:[
15:37:46 <johnw> chrisdone: it did win
15:37:47 <chrisdone> i prefered ++
15:37:56 <chrisdone> cmccann: me too, i use it in some projects
15:38:02 <cmccann> then again I also think map should be fmap
15:38:10 <chrisdone> also that
15:38:13 <cmccann> and that (.) should be the one from Category
15:38:25 <cmccann> screw this monomorphism crap, pf.
15:38:28 <chrisdone> but, c'est la askelle
15:38:45 <elliott> I like the existing Prelude (.) now that we have everything in lens composing with it ;)
15:39:04 <cmccann> elliott, there are other category instances worth composing :P
15:39:12 <edwardk> chrisdone: (<>) won
15:39:14 <chrisdone> like HoleyMonoid!
15:39:18 <elliott> cmccann: as if
15:39:25 <elliott> chrisdone: shachaf showed you can write HoleyMonoid with Prelude id/(.)
15:40:06 <Ralith> elliott: can, but should?
15:40:26 <elliott> sure, why not?
15:40:32 <elliott> it's more convenient to use
15:40:38 <cmccann> I suppose when lens manages to subsume all the variations on automaton arrows that should about wrap it up for needing Category elsewhere
15:40:53 <chrisdone> can we rename lens to borg?
15:41:03 <elliott> well, the other things that you'd want for Category is I guess pipey conduity type stuff
15:41:22 <elliott> dunno if edwardk's "machines" package needs Category :p
15:41:41 <chrisdone> does anyone use the the pipe/conduit/iteratee libraries apart from their authors?
15:41:51 <elliott> sure, tons of people use conduit
15:41:53 <elliott> very popular
15:41:58 <chrisdone> are they all yesod users?
15:42:04 <Ralith> I'm not
15:42:14 <elliott> 138 packages depending on conduit in hackage
15:42:15 <chrisdone> interesting
15:42:19 <cmccann> elliott, all the various stream processor thingies. I guess not at all of them are automaton arrows with stuff bolted on, but iteratees mostly were.
15:42:24 <stepkut> i use pipes
15:42:24 <elliott> 22 depending on attoparsec-conduit alone
15:42:34 <chrisdone> elliott: direct dependencies or indirect?
15:42:39 <elliott> chrisdone: not sure
15:42:42 <stepkut> I also indirectly use conduits :-/
15:42:46 <chrisdone> that sounds like a lot of libraries
15:42:54 <elliott> even just from reddit you can tell plenty of people use conduit though
15:43:18 * cmccann notes that AFRP implementations are pretty much the same sort of thing
15:43:18 * ivanm doesn't use any of them
15:43:18 <stepkut> even more people use lazy IO :)
15:43:19 <chrisdone> pretty much everything snoyman writes uses conduit
15:43:30 <ivanm> chrisdone: strange that :p
15:43:42 <chrisdone> and he writes a lot of libs, that people use
15:43:53 <chrisdone> so i wouldn't be surprised by indirect deps
15:44:24 <chrisdone> much like blaze-builder, that's another lib that tends to just appear and it's like "oh, i have to use this now because the library uses it"
15:45:15 <chrisdone> cmccann: AFRP? what's AF-?
15:45:26 <elliott> arrowised functional reactive programming
15:45:28 <chrisdone> well, what's the A
15:45:29 <Enigmagic> arrows?
15:45:30 <chrisdone> ah, ok
15:45:59 <Enigmagic> chrisdone: we use conduit for loads of stuff at work
15:46:08 <chrisdone> yeah there are a lot of frp libs, but didn't notice many people using *other people's* libs
15:46:13 <chrisdone> Enigmagic: for what?
15:46:31 <Enigmagic> chrisdone: web crawling, market data processing, text processing
15:46:45 <chrisdone> i don't suppose that code is open
15:46:47 <cmccann> chrisdone, netwire seems to get some use
15:46:54 <Ralith> cmccann: I thought FRP stuff was mostly applicative these days?
15:47:02 <cmccann> just based on having seen people asking about using it
15:47:07 <Enigmagic> chrisdone: nope..
15:47:17 <Enigmagic> chrisdone: some of our helper libraries like lzma-conduit are though
15:47:28 <navaati> hi
15:47:38 <cmccann> Ralith, don't ask me, don't really follow it currently
15:48:17 <shachaf> When stepping through Haskell code in gdb, what do you do about the timer tick thing?
15:48:18 <k00mi> Ralith: reactive-banana is applicative and i think netwire is too, not sure though
15:48:25 <Enigmagic> netwire uses arrows
15:48:26 <shachaf> I disable SIGVTALRM but that seems suboptimal in general.
15:48:31 <k00mi> okay
15:48:44 <navaati> netwire can be used applicative-style
15:49:05 <Enigmagic> looks like it's both
15:49:48 <navaati> and it's actually intended so (as an applicative)
15:50:59 <Enigmagic> navaati: all the old samples i saw used arrows (like http://www.haskell.org/haskellwiki/Netwire)
15:51:02 <navaati> is it possible, from a "pairRef :: IORef (a,b)", to get an "aRef :: IORef a" such that when aRef is modified, pairRef is too ? (if not possible with IORef, does exist another kind of container that permit it ?)
15:52:06 <navaati> Enigmagic: yeah, but the author (rhaa, can't remember his name) showed me code in applicative style and it's really more straightforward
15:52:23 <`nand`>     Couldn't match kind `Assoc' with `Assoc'  <- well that's the first time I've seen such an error
15:52:53 <hoknamahn> hello. i'm wondering how to resolve this "instance Vector a => Num a where (+) = vzip (+)"? can i specify somehow that (+) on the left side isa vector one and (+) on the right side is a prelude one?
15:52:57 <chrisdone> navaati: don't know of a library that does that
15:53:30 <raek> does someone know if there is a library for parsing haskell code?
15:53:39 <chrisdone> @hackage haskell-src-exts
15:53:40 <lambdabot> http://hackage.haskell.org/package/haskell-src-exts
15:53:55 <raek> thanks!
15:53:58 <lispy> I wonder if ghc will ever use that library
15:54:18 <chrisdone> seriously doubt it, not without heavy modifications
15:54:26 <Enigmagic> lispy: there has been talk of having parts of it shared with template-haskell
15:54:28 <navaati> hoknamahn: normally, you don't need to specify anything
15:54:35 <mikeplus64> is there a way to give warnings for specific functions in specific instances of classes?
15:55:05 <cmccann> TH and GHC's internal representation are not at all the same, I don't think.
15:55:15 <lispy> mikeplus64: not sure what you mean, but you could look at hlint, IIRC you can customize the errors it gives
15:55:15 <chrisdone> right
15:55:17 <cmccann> though some of the structural decisions are the same.
15:55:19 <elliott> navaati: a composable IORef like that would be nice (could be done with an Invariant instance) but I don't think such a library exists
15:55:20 <navaati> chrisdone: argh, i needed it for some GUI code (you know, having a datatype that maps to the widget tree...)
15:55:22 <elliott> i twould be fairly easy to write though
15:55:27 <mikeplus64> lispy: i mean like a WARNING pragma
15:55:29 <cmccann> haskell-src-exts makes some different decisions about how to structure things.
15:56:04 <chrisdone> and haskell-src-exts is slow and uses String
15:57:21 <elliott> navaati: oh, it could even be an instance of an invarianty Applicative, whatever that means...
15:57:25 <navaati> elliott: easy to write... is it possible in pure haskell, or would i need to play with pointers...
15:57:30 <elliott> (hm, monadic lenses would help here)
15:57:35 <elliott> navaati: you can write it in pure haskell on top of IORef
15:57:53 <k00mi> navaati: you could put two IORefs in the pair
15:57:54 <chrisdone> yeah it sounds like a lens, i was thinking
15:57:55 <elliott> well, haskell + existential quantification
15:58:05 <chrisdone> waiting for one of the lensizens to pipe up
15:58:15 <edwardk> chrisdone: =P
15:58:19 <navaati> yeah, i looked at lenses when i thought about this, but... doesn't work right now, lenses are pure
15:58:22 <elliott> in fact you end up with
15:58:27 <elliott> data Ref a = forall b. Ref !(IORef b) !(a -> b -> b) !(b -> a)
15:58:28 <elliott> which is just
15:58:29 <mikeplus64> chrisdone: doesn't ghc also use String everywhere? (and is notoriously slow)
15:58:36 <elliott> data Ref a = forall b. Ref !(IORef b) !(Lens' b a)
15:58:42 <chrisdone> mikeplus64: nah it has FastString and things like this
15:58:50 <Enigmagic> FastString now is ByteString
15:59:00 <edwardk> navaati: we have actions and monadic folds, but they kinda suck for actions right now. we haven't come up with a story for how to deal with monadic lenses 'properly' in the new framework yet
15:59:01 <Enigmagic> (in HEAD)
15:59:02 <elliott> navaati: well, lens has MonadicFold. you'll have to wait for edwardk to figure out how to do monadic lenses properly for this to be a lens directly though :P
15:59:03 <mikeplus64> chrisdone: the more i know
15:59:13 <elliott> that said, if I were to write this library I would build it on top of lenses like that
15:59:17 <elliott> since it would be much more convenient
15:59:25 <edwardk> not that i consider the other frameworks' approaches for monadic lenses proper, since i still can't reason about their las
15:59:34 <elliott> and you could say e.g. "mapRef _1 :: Ref (a,b) -> Ref a"
15:59:42 <elliott> rather than having to say mapRef fst (\a (_,b) -> (a,b)) or whatever
15:59:57 <elliott> edwardk: (hm, would this be good to have in lens itself?)
16:00:01 <elliott> wouldn't be much code
16:00:20 <edwardk> elliott: haven't paid much attention to the discussion so far other than the bit about actions
16:00:23 <navaati> mmh, i still haven't wrapped my head around the MonadicFold part of lenses, so...
16:00:25 <cmccann> edwardk, pf, what's hard to reason about with "Do what thou wilt shall be the whole of the Law"?
16:00:47 <elliott> edwardk: just an IORef (or MVar or STRef or...) that you can "map over"
16:00:50 <edwardk> elliott: adding a bunch of stuff about IORefs doesn't generalize very well and strikes me as out of scope
16:00:55 <elliott> edwardk: i.e. go from Ref (a,b) to Ref a
16:01:03 <elliott> and I guess maybe Ref a and Ref b to Ref (a,b)
16:01:11 <edwardk> elliott: like Coyoneda IORef ?
16:01:11 <elliott> edwardk: yeah I was thinking a typeclass
16:01:18 <elliott> hm, I guess Coyoneda works here
16:01:26 <hpaste> h pasted ‚ÄúVector (+) vs Prelude (+)‚Äù at http://hpaste.org/79893
16:01:32 <edwardk> this is one of ski's classic examples of coyoneda
16:01:38 <elliott> edwardk: well, not quite coyoneda I don't think
16:01:46 <elliott> you need to be able to both read and write to a part of a structure
16:01:47 <chrisdone> :t writeIORef
16:01:48 <elliott> so you really want a lens
16:01:48 <lambdabot>     Not in scope: `writeIORef'
16:01:49 <lambdabot>     Perhaps you meant `writeSTRef' (imported from Data.STRef)
16:01:58 <edwardk> hrmm
16:02:13 <edwardk> work up a sketch. i have to run for a bit
16:02:20 <dylukes> Coyoneda sounds like a southern mexican dish.
16:02:20 <elliott> alright
16:03:02 <Fuuzetsu> Does anyone happen to know how to get Network.Browser to keep the cookies between calls to browse? There's the getBrowserState but I'm not sure how to use it.
16:03:24 <dylukes> "I'll have the coyoneda con arroz, and a margarita."
16:03:43 <navaati> is there a class describing "this is a reference you can write to and/or read from", and being instanced by IORef, MVar, STRef and maybe this STM stuff in the standard lib at the moment ?
16:03:54 <hammersbang> is haskell worth learning?
16:03:55 <elliott> navaati: not in the standard library :(
16:04:02 <cmccann> navaati, don't think so, but I'm pretty sure there's at least three on hackage
16:04:04 <catsbydlo> hammersbang: no
16:04:07 <elliott> hammersbang: really, what answer are you expecting from #haskell?
16:04:08 <navaati> hammersbang: yes, like, YES !
16:04:33 <hoknamahn> hey guys any ideas how to solve this? http://hpaste.org/79893
16:04:34 <chrisdone> hammersbang: is origami worth learning?
16:04:40 <edwardk> elliott, navaati: there are dozens of 'MonadRef' like classes out there
16:04:59 <Enigmagic> hammersbang: avoid it while you can, haskell is like herpes.
16:05:01 <edwardk> the fact that this might need one kind of makes me lean even more toward out of scope for lens proper
16:05:14 <catsbydlo> hoknamahn: you posted the wrong code
16:05:16 <elliott> yeah I'll just sketch something up and see how lightweight it is
16:05:20 <elliott> it might well want to be in another package
16:05:40 <edwardk> now, a nice lens-refs package that uses lens and all the little bits might make sense
16:05:41 <cmccann> I prefer the dictionary passing equivalent for "MonadRef"-ish stuff anyway
16:06:06 <cmccann> so that I don't have to screw around with fancy extensions to have instances for shoving things into a TVar or a TChan
16:06:09 <edwardk> cmccann: because of the fact that you have lots of ref'ish things that work in IO, etc?
16:06:32 <cmccann> and can use lenses with a State monad the same way and so on
16:06:33 <edwardk> i have a fork of unificatin-fd lying around somewhere that does that
16:06:37 <edwardk> er unification-fd
16:06:44 <hpaste> h pasted ‚Äú[Edit] Vector (+) vs Prelude (+)‚Äù at http://hpaste.org/79894
16:06:58 <hoknamahn> sorry this is the one
16:07:03 <cmccann> thing is just having "references" isn't really enough
16:07:19 <catsbydlo> hoknamahn: you can't do that
16:07:27 <cmccann> and once you jump down the rabbit hole of read vs. write and whether you can make new ones and if it behaves like an IORef or an MVar or...
16:07:28 <hoknamahn> really?
16:07:31 <catsbydlo> 'instance Num a' overlaps everything
16:07:40 <catsbydlo> you're saying every type is an instance of Num
16:07:41 <navaati> so, well, lens-refs does not exist at the moment, so i need to find an equivalent pure solution... maybe FRP GUI...
16:08:07 <hoknamahn> catsbydlo, but I gave it constraint. should be enough, no?
16:08:16 <catsbydlo> hoknamahn: the constraints don't matter
16:08:26 <cmccann> I don't see much benefit to a type class over just passing around things with types like "a -> m ()" or "m a".
16:08:34 <cmccann> the latter is more general and not really that much more work
16:08:36 <catsbydlo> that just means to actually use the methods, the type in question must be an instance of Vector as well
16:08:56 <catsbydlo> the instance still applies to all Num a
16:09:01 <elliott> navaati: well you can build a module to do what you want in like five minutes
16:09:10 <elliott> with or withou tlens
16:09:39 <chrisdone> navaati: you could make some reactive values, i suppose
16:09:42 <hoknamahn> catsbydlo, but how to avoid boilerplate? i don't really want to do instance for every VectorN type because all the instances will define the same (+) = vzip (+)
16:09:56 <catsbydlo> hoknamahn: don't use +
16:10:00 <chrisdone> navaati: in fact, i would, if i were doing gtk programming
16:10:18 <hoknamahn> catsbydlo well yeah... but it's so sad :(
16:10:23 <catsbydlo> no u
16:11:42 <navaati> yeah, seems like FRP is actually the cleanest thing
16:11:45 <chrisdone> navaati: data Value a = Value { valueRef :: IORef a, valueSubscribers :: [(Int,IO ())] }
16:11:45 <chrisdone> navaati: subscribe :: Value a -> IO () -> IO Int -- makes a subscription to "react" when the value changes
16:11:46 <chrisdone> navaati: putValue :: Value a -> a -> IO () -- writes to the value, and notifies all subscribers
16:12:04 <chrisdone> navaati: with this trivial API you can ease a lot of pain working with gtk or whatever
16:12:43 <navaati> what is the trendy FRP lib at the moment ? does any work with gtk (i hate wxwidgets) ?
16:12:58 <navaati> chrisdone: uh, i'm looking at this...
16:13:04 <elliott> you can bind reactive-banana to gtk in like 30 lines of code
16:13:15 <elliott> chrisdone: looks like frp lite :P
16:13:37 <chrisdone> elliott: yup =)
16:13:49 <navaati> really ? oh, i really need to dig deeper into this banana stuff
16:13:50 <chrisdone> "frp that doesn't require a tutorial, a package, or memory leaks"
16:14:06 <chrisdone> is reactive-banana free of the memory leak issues?
16:14:10 <elliott> chrisdone: well, I only know of one memory leak in reactive-banana and it's an edge-casey bug rather than a fundamental flaw
16:14:19 <elliott> (I don't know how easy that edge-casey bug is to fix, though)
16:14:27 <`nand`> elliott: excellent, only 30 lines of boilerplate
16:14:37 <navaati> what is the role of the Int in your example API ?
16:14:38 <elliott> (ok, I don't *know* it's not a fundamental flaw either, but it's nothing like the memory leak issues you get with older FRP libraries)
16:14:57 <chrisdone> navaati: ah, that was for if you want to unsubscribe later on
16:15:02 <elliott> reactive-banana has e.g. leak-free dynamic event switching
16:15:15 <chrisdone> navaati: e.g. when your UI element has been deleted and doesn't need to be notified anymore
16:15:28 <hamishmack> navaati: You might want to check out http://hackage.haskell.org/package/sodium too
16:15:32 <`nand`> has netwire been tied into Gtk and the likes anyhow?
16:16:37 <navaati> `nand`: don't think so, netwire's typical usage is quite different, seems
16:16:40 <hamishmack> navaati: Sodium example http://ghcjs.github.com/bin/freecell.trampoline.jsexe/
16:18:37 <`nand`> navaati: I wonder what would be a good design; having the monad be a Reader GtkEvent or something?
16:18:48 <`nand`> and then just running the wire for every event that flows in
16:19:40 <message144> is it normal to dream in haskell when first learning it? heh
16:19:43 <chrisdone> doubtless GTK is defined for IO and not MonadIO so using your own monad doesn't work runMyMonad everywhere
16:19:53 <`nand`> message144: I've done that on occasion
16:19:57 <navaati> message144: yes
16:20:08 <`nand`> message144: especially if you spend an entire day (or more, before sleeping) doing nothing but thinking about Haskell
16:20:12 <message144> glad to see im not going crazy
16:20:38 <message144> `nand`, unfortunately ive spent most of an entire 1 week vacation digging into it
16:20:39 <navaati> message144: oh, you are
16:21:01 <chrisdone> it's crazy clown time!
16:21:30 <chrisdone> excuse me, that was david lynch, he took over my keyboard
16:21:30 <message144> navaati, `nand` : the scary thing is im grasping it much more quickly than I am comfortable with. obsession gone wrong.
16:21:39 <`nand`> chrisdone: ReaderT GtkEvent IO -- liftIO everywhere
16:21:57 <`nand`> message144: that's just your brain telling you ‚Äúhey, this actually makes sense‚Äù
16:22:32 <message144> `nand`, yeah there was a small part of me that was hoping it wouldnt make any sense and i would give up, so i could at least get it out of my system and move on with life.. that didnt happen
16:22:34 <chrisdone> `nand`: yeah, sucks
16:23:00 <chrisdone> if it were MonadIO it could all be MyMonad
16:23:19 <`nand`> message144: don't worry, you can just get everything else out of your system and move on with life
16:23:28 <message144> ha great
16:24:09 <`nand`> chrisdone: you could provide a lightweight wrapper around Gtk that lifts everything into MonadIO ;)
16:24:55 <chrisdone> `nand`: well the point is the library should be designed to have thought of this simple idea, but yeah, you can always make wrappers to fix broken things
16:25:17 <elliott> you can use reflection to avoid the ReaderT!!!!
16:25:19 <beaky> when should I use let over where
16:25:24 * elliott is getting paid for this
16:25:28 <`nand`> elliott is right
16:25:32 <`nand`> or an implicit parameter!
16:25:35 <cmccann> of course, when dealing with callbacks liftIO isn't always viable anyhow
16:25:53 <chrisdone> cmccann: in gtk it is because it's single threaded, i think
16:26:15 <chrisdone> if the doEvents is also MonadIO m => m then it's not a problem
16:26:15 <cmccann> it's something you have to think about, at least
16:26:34 <chrisdone> sure
16:27:07 <elliott> I don't like the idea of everything using MonadIO
16:27:10 <chrisdone> (i'm being unfair really -- IO is the safest bet to let people write their wrappers. it's just inconvenient)
16:27:13 <elliott> since it just falls down completely whenever contravariance comes up
16:27:27 <chrisdone> elliott: does it come up in gtk+
16:27:34 <beaky> what are Kinds?
16:27:45 <elliott> chrisdone: dunno. but it's a general objection
16:28:12 <navaati> beaky: Kinds are types of types
16:28:42 <chrisdone> elliott: yeah, usually "contravariance coming up" means, "oh shit how do i catch exceptions"
16:29:30 <elliott> well, it's callbacks more generally
16:29:33 <chrisdone> but seems true of any non-IO monad, i suppose
16:29:45 <hamishmack> Leksah is forever doing‚Ä¶  ideRef <- ask; liftIO $ someGtkFunction (liftIO $ runReaderT callbackCode ideRef)
16:29:58 <hamishmack> It is painfull
16:30:15 <elliott> hamishmack: could avoid that with... *drumroll* reflection!
16:30:19 <cmccann> just make another type class with an "unliftIO :: m a -> IO a" and require that with a law stating that composing it with liftIO in either order is id
16:30:22 <cmccann> problem solved!
16:30:37 <beaky> what does liftIO do?
16:30:38 <elliott> cmccann: finally, a typeclass pair for the constraint (m ~ IO)
16:30:39 <beaky> :t liftIO
16:30:41 <lambdabot> MonadIO m => IO a -> m a
16:30:43 <chrisdone> elliott: for gtk+ i would have the doevents running in the MonadIO m => m and then when the C code triggers events i'd push that onto a stack for the MonadIO m => m action to trigger. as one idea
16:30:47 <cmccann> elliott, that works too
16:30:50 <beaky> ah, so it translates between monads?
16:30:56 <elliott> chrisdone: sure. but that's situation-specific :)
16:31:12 <beaky> liftIO (0 :: IO Int) :: List
16:31:17 <beaky> > liftIO (0 :: IO Int) :: List
16:31:19 <lambdabot>   Not in scope: type constructor or class `List'
16:31:19 <lambdabot>  Perhaps you meant `Last' (i...
16:31:20 <chrisdone> elliott: sure
16:31:21 <beaky> :(
16:31:48 <simpson> beaky: The target monad must be an instance of MonadIO.
16:32:02 <simpson> beaky: This nearly always means that the target is a transformer which has IO in its base.
16:32:05 <beaky> ah
16:32:22 <simpson> :i StateT () IO
16:32:34 <simpson> Oh, right, we don't have this. Nevermind.
16:33:41 * cmccann would like some way to lift atomically for the same transformer stack on top of STM vs. IO
16:33:53 <cmccann> I'm sure there's something on hackage
16:33:56 * chrisdone tries to figure out a way unlift can be a comonad
16:34:03 * chrisdone gives up
16:34:31 <elliott> basically any attempt to define this contravariant MonadIO ends up stating "this is ReaderT r IO for some r"
16:34:40 <elliott> see monad-control etc.
16:34:47 <elliott> and that has really weird behaviour when you use State or whatever
16:34:47 <cmccann> which is actually pretty useful
16:35:10 <elliott> unfortunately we just cannot pretend our effects compose properly. it just ain't so
16:35:32 <elliott> cmccann: but if you just have Reader then you should be using *choir booms out* reflection!!
16:35:42 <chrisdone> hmm i was talking about this to someone. maybe myself. how transformer laws demand reliable composition, right?
16:35:43 <cmccann> I like ReaderT :[
16:36:07 <hpaste> beaky pasted ‚ÄúWhich style should I use?‚Äù at http://hpaste.org/79895
16:36:27 <elliott> cmccann: accept reflection into your heart!
16:36:27 <cmccann> the reader monad is nice and friendly and simple and not full of confusing hacks
16:36:39 <chrisdone> like, transformer of monad1 (monad2 ‚Ä¶) does not have to have the same effects as monad2 (monad1 ‚Ä¶)
16:36:42 <`nand`> elliott: or, yknow, (->) r
16:36:53 <elliott> `nand`: reflection is nicer than that for configuration
16:37:08 <elliott> cmccann: we should just get the source link to point to the oleg paper somehow so people stop judging reflection for being efficient
16:37:10 <`nand`> depends on how many reallyUnsafeTypeSystemTrickery you add to it
16:37:14 <`nand`> unless you go with the Tagged approach
16:37:20 <elliott> beaky: the former generally
16:37:21 <chrisdone> whereas a stack of LogicT ConT, you're asking for a world of pain, smokey
16:37:22 <`nand`> which has the same problems as a Reader
16:37:36 <elliott> `nand`: huh? you don't need any unsafe things to use reflection
16:37:49 <`nand`> elliott: the thing is, how do you pass the phantom parameter around?
16:38:00 <chrisdone> what is this 'reflection' you guys keep talking about?
16:38:01 <elliott> ?
16:38:07 <elliott> `nand`: I can only recommend reading the paper
16:38:13 <elliott> chrisdone: http://hackage.haskell.org/package/reflection
16:38:27 <elliott> read the paper it links if you want an introduction
16:38:27 <`nand`> elliott: the paper uses Tagged
16:38:32 <beaky> ah
16:38:48 <cmccann> I dunno, I just never really understood why implicit configurations (or implicit parameters for that matter) were better than just using the reader monad
16:38:58 <elliott> `nand`: not really, it has a lot of examples of putting the type parameter on the actual values that use your configuration
16:39:13 <`nand`> elliott: that's what Tagged is
16:39:22 <elliott> ...no, Tagged is a single type
16:39:24 <cmccann> I'm all for fancy trickery and type shenanigans but this really doesn't seem to cross the border of "needs fancier abstraction"
16:39:27 <elliott> not the general technique of adding phantom type parameters to things
16:39:41 <elliott> cmccann: well, you can't do things like a "integers modulo n with Num, etc. instances" type with Reader (not without extreme ugliness, anyway)
16:39:47 <elliott> with reflection it's easy
16:40:01 <cmccann> elliott, ok true
16:40:10 <`nand`> elliott: can you point me to a specific example in that paper?
16:40:24 <navaati> yeah, but when you have to use Tagged, doesn't it mean that reflection is useless since you could use Reader ?
16:40:25 <elliott> `nand`: it's been ages since I read it but IIRC it does the integers-modulo-n thing
16:40:33 <elliott> navaati: you don't have to use Tagged
16:40:33 <`nand`> elliott: yeah, but it uses Tagged for them
16:40:38 <cmccann> elliott, but that doesn't give me any reason to use it when I want something simpler :P
16:41:05 <navaati> elliott: you don't have to iff you already carry a phantom parameter in your code, right ?
16:41:23 <elliott> navaati: no
16:41:56 <chrisdone> this is the fun of haskell
16:42:02 <elliott> `nand`: just checked. ok, technically the type they use is isomorphic to Tagged. but they don't use "Tagged" in general, it's a *specific* type for the purpose. and nothing is requiring it to be isomorphic to tagged
16:42:10 <elliott> newtype M s a = M (a,a) would be just fine too
16:42:16 <elliott> or data M s a = M { foo :: a, blah :: Int, ... }
16:42:28 <elliott> so calling it Tagged is a red herring; it's actually just a phantom type parameter
16:42:35 <navaati> ah... then, if you don't have to have a phantom carried, what do you reflect on ?
16:42:49 <chrisdone> you clock out and do some work for a year, come back and look at what new stuff the community is doing, and there's a bunch of new abstractions and exotic tricks that are quickly becoming normal
16:43:04 <elliott> cmccann: anyway, I think the ability to reuse your configuration setup in both monadic and pure code is valuable -- rather than having to sprinkle (<$>) (<*>) all over your pure code that just wants to have access to the configuration
16:43:07 <chrisdone> i remember when applicative was a newfangled idea, now people are recommending it to newbies before monads
16:43:08 <`nand`> fair enough. Those all fall under my concept of ‚ÄòTagged‚Äô, if you ask me (because why would you make a new type when you can use Tagged which has a nice interface available for it already eg. with representable-profunctors?)
16:43:28 <elliott> cmccann: sure you can just use a regular function there. but then you have to explicitly fish it out of your Reader whenever you want to go into pure code
16:43:40 <cmccann> elliott, I suppose so
16:43:41 <elliott> cmccann: and if you annotate your data types with the type parameter well, you can just call your pure code directly with them
16:44:08 <elliott> `nand`: huh?
16:44:23 <elliott> you don't want the different types that all use the configuration to unify with one another
16:44:32 <BMeph> What happened to that 'ACIO' stuff? :)
16:44:45 <elliott> anyway you're identifying all uses of phantom type parameters as Tagged which is just weird to me, they're not the same thing at all
16:45:14 <`nand`> not all
16:45:24 * chrisdone ‚Üí bed
16:45:30 <`nand`> GADTs etc. are an immediate example of phantom types that can't be implemented via Tagged
16:46:05 <elliott> all I can say is if you think you should always pass around the configuration type with Tagged then you probably don't realise how you can use reflection effectively *shrug*
16:46:08 <elliott> just my opinion
16:46:21 <cmccann> BMeph, my guess is that the people who think it's a worthwhile idea and the people who'd be likely to implement it are mostly disjoint sets
16:46:45 <`nand`> I don't see an alternative (barring unsafeCoerceDictionary). Maybe you could show me code samples that use reflection the way you envision it?
16:47:34 <elliott> um, see the paper again... like I said, the fact that the type it defines for modular numbers is isomorphic to Tagged is irrelevant
16:48:07 <elliott> for one if you just use Tagged you could only have one instance for Num! so the only way you can use reflection to do arithmetic is now modular arithmetic because defining duplicates of Tagged is bad... pretty bad tradeoff if you ask me :P
16:49:06 <elliott> `nand`: there is http://hpaste.org/66715 which I wrote once to demonstrate more ReaderT-like use of reflection
16:49:06 <`nand`> (hey, you could put stuff inside newtypes! like instance Num (Modular (Tagged s a))) but you missed my point
16:49:45 <`nand`> (sure, it doesn't all have to be Tagged in the implementation, but the fact that they're all isomorphic to Tagged means that any reasoning we apply to Tagged we can apply to all of those use cases)
16:50:17 <elliott> you could say Tagged p Report everywhere but (a) this only handles one configuration per type -- there's no reason you'd necessarily only want one (b) you get lots of wrapping/unwrapping noise (c) the instances problem (unless you do instance Foo (ReportWrapper (Tagged p Report)) which... would be something)
16:50:40 <elliott> not really sure you can apply all that much reasoning to Tagged, it's a pretty uninteresting type by design :P
16:51:46 <`nand`> elliott: the plumbing happens here when you try to pass the result of ‚Äòcalculate‚Äô to a function that expects an Integer, not a Datum p
16:52:23 <elliott> sigh
16:52:29 <elliott> I could have made Datum a complex record if you'd like :)
16:52:44 <elliott> look at Report -- that's not a single wrapped type
16:52:46 <`nand`> I don't see how that changes things
16:53:23 <elliott> well, your statement seems to be equivalent to "defining types -- newtypes, records, whatever -- is bad because you can't implicitly use them as whatever's inside them"
16:53:49 <elliott> you can use lens or such to make wrapping and unwrapping values from stuff as easy as it gets but if you want strong typing there's always going to be accessing fields of stuff
16:53:50 <`nand`> I guess you could say it's that
16:54:21 <elliott> mostly I just don't think this is really related to reflection :P
16:54:24 <`nand`> my point is; the noise from unwrapping all of those newtypes and scoped type variables and stuff isn't necessarily less than the overhead of using something other than reflection
16:54:33 <`nand`> it may be worse
16:54:37 <elliott> if I have data in my program then I'm going to define newtype Datum whether I add a type parameter for configuration or not!
16:54:55 <elliott> I don't want to just sprinkle Integer (or remember, it could be a large record -- you'd define a new type *anyway*) without knowing what it means
16:55:00 <elliott> after all, that's what newtype is for...
16:56:22 <ariqq> if I have a function that looks something like this: f::Integer -> Integer -> Integer, can I use something to make it accept float numbers and return float?
16:57:01 <elliott> `nand`: and fwiw, the excessive use of ScopedTypeVariables there was just because the technique of using reflect directly often confuses people learning the library who think that it's going to look at the actual data, etc.
16:57:01 <monadicity> ariqq, no
16:57:28 <elliott> `nand`: if you have annotated data then you shouldn't need that often
16:57:31 <elliott> monadicity: ? yes you can
16:57:38 <`nand`> elliott: I think the issue here was about interaction with other libraries that /don't/ have any knowledge of reflection, or anything else, for that matter
16:57:52 <elliott> ariqq: you can define e.g. g a b = fromInteger (f (round a) (round b))
16:57:58 <elliott> it depends how you want to convert the floats to integers and back
16:58:03 <`nand`> so the ‚Äúyou'd define your own record either way‚Äù doesn't apply
16:58:26 <elliott> `nand`: well, I don't quite understand what you mean then; it would depend on the specific example
16:59:37 <mikeplus64> @pl \p _ -> f p
16:59:37 <lambdabot> const . f
17:00:35 <`nand`> elliott: the example brought up here was that suppose you have some interface like (Foo -> IO a) -> IO (); but all your functions live in ReaderT Conf IO instead of IO because they want to pass around configuration data
17:01:47 <ariqq> @elliott I want a function that can add two floats or two integers and returns the appropiate type
17:01:47 <lambdabot> Unknown command, try @list
17:01:49 <elliott> `nand`: well, if your callback really doesn't close over anything with the configuration parameter (but then why does it need to be in your ReaderT?), then you probably want myCallBack :: Proxy p -> Foo -> IO a
17:01:57 <elliott> much more convenient to use than Tagged
17:02:13 <elliott> ariqq: ah... then this function already exists:
17:02:14 <elliott> :t (+)
17:02:16 <lambdabot> Num a => a -> a -> a
17:02:43 <`nand`> yeah, and instead of Reifies p Conf => Proxy p; you can just use Conf ->
17:03:17 <elliott> `nand`: except, see the first part of what I said
17:03:25 <`nand`> elliott: the point I made about using unsafeCoerceDictionary and stuff is that you can get rid of both Tagged *and* Proxy using it
17:03:34 <ariqq> @elliott thanks!
17:03:34 <lambdabot> Unknown command, try @list
17:03:39 <elliott> I honestly have no idea how unsafeCoerce is meant to help here
17:03:49 <elliott> but like I said, you don't have to pass anything at all if you have stuff that uses your configuration in scope
17:03:57 <elliott> which you will in all the cases I can think of where you'd want this
17:04:18 * cmccann thinks @elliott should be a command that sends the following text to elliott as a lambdabot message
17:04:25 <ariqq> :t (/)
17:04:26 <lambdabot> Fractional a => a -> a -> a
17:04:38 <ariqq> :t (*)
17:04:40 <lambdabot> Num a => a -> a -> a
17:04:47 <elliott> cmccann: I think it should be like @get-shapr instaed.
17:05:08 <ariqq> so if I want to add two values, I write (+) a b ?
17:05:21 <lambdabot>  @elliott thanks!
17:05:27 <cmccann> haha
17:05:52 <elliott> ariqq: a + b
17:11:54 <Fuuzetsu> @pl f x = g x ++ h x
17:11:54 <lambdabot> f = liftM2 (++) g h
17:12:33 <parcs> > logBase 2 0x2000
17:12:34 <lambdabot>   13.0
17:12:41 <Fuuzetsu> @pl f x = g x ++ h x ++ ";"
17:12:41 <lambdabot> f = liftM2 (++) g ((++ ";") . h)
17:12:58 <Fuuzetsu> @pl f x = g x ++ "=" ++  h x ++ ";"
17:12:58 <lambdabot> f = liftM2 (++) g (('=' :) . (++ ";") . h)
17:13:06 <parcs> > 2^13
17:13:07 <lambdabot>   8192
17:18:52 <`nand`> hmm, do we have parameterless type classes?
17:19:01 <elliott> no
17:19:21 <elliott> we do have class a ~ () => C a | -> a
17:19:23 <elliott> or whatever
17:19:53 <mikeplus64> what is the point of a paramaterless typeclass?
17:30:04 <Modius> In haskellage, assume I wanted some type/union variant that's (a, a), where the first a is *always* to be smaller than the second (this is a stereotyping of a design element I'm thinking of) - anyone calling the type constructor could put in anything they want.  What's the idiomatic haskelly way to express the constraint?
17:30:52 <parcs> > 2^16
17:30:53 <lambdabot>   65536
17:31:11 <ivanm> Modius: use a smart constructor
17:31:16 <ivanm> :: a -> a -> Maybe (a,a)
17:31:26 <ClaudiusMaximus> module OrderedPair(OrderedPair(), orderedPair, toPair) where ...
17:31:43 <ivanm> or it might be possible to do something dependently-type-ish, but it probably isn't worth it
17:31:51 <Modius> ivanm:  From the other perspective, can I also isolate a constructor that forces me through the code that runtime-sorts 2 values?
17:32:09 <ariqq> is there anyway to convert a digit to a type a? I at first had used digitToInt but now also want it to work for floats
17:32:48 <roconnor> Modius: you make a type and hide the representation using the module system.  Only export functions that establish and maintain your invariant.
17:33:13 <Modius> roconnor:  Thanks.  Was just wondering if there was anything else - as with many things, saw it as a learning opportunity.
17:34:05 <roconnor> Modius: you may also want to take a look at ViewPatterns for "pattern matching" on abstract types.  It is non-standard though.
17:34:54 <Modius> I've got emacs/ghc-mode indentation, not sure it's indenting types the way it should - anyone got some code I should look at for a cardinal example of something like data Foo = Bar | Moo (int, int)  <-- this type of thing across multiple lines, indented properly?
17:35:03 <roconnor> ClaudiusMaximus: I'd probably call it unordered pair
17:35:41 <ClaudiusMaximus> roconnor: oh, good point
17:35:45 <roconnor> Modius: I personally line up the | with =
17:35:47 <elliott> you don't need the Maybe there really
17:35:52 <elliott> you can construct it from any two as
17:36:01 <elliott> though to get a pair back out requires an Ord constraint
17:37:02 <simpson> :t \x y -> if x < y then (x, y) else (y, x)
17:37:04 <lambdabot> Ord t => t -> t -> (t, t)
17:37:42 <roconnor> data UnorderedPair a = UnorderedPair a a; mkUnorderedPair x y | x <= y = UnorderedPair x y   | otherwise = UnorderedPair y x
17:38:35 <roconnor> instance Foldable UnorderedPair where foldmap f (UnorderedPair x y) = f x <> f y
17:39:04 <Modius> Aah yeah - emacs/haskell wants me to put the first case on the line with the =, then it lines up the rest right.
17:40:35 <roconnor> too bad we cannot make a functor instance
17:40:44 <elliott> roconnor: I think it's nicer to not require an Ord constraint on construction
17:40:54 <roconnor> elliott: how is that possible?
17:41:01 <roconnor> oh
17:41:02 <elliott> roconnor: if you don't export the constructor, then it doesn't matter that the two representations differ
17:41:05 <elliott> mkUnorderedPair = UnorderedPair
17:41:09 <elliott> sure, Eq requires Ord
17:41:17 <elliott> and so does foo :: Ord a => UnorderedPair a -> (a,a)
17:41:22 <elliott> but construction/fmap/etc. don't
17:41:42 <roconnor> elliott: I doubt it gains you much and makes coding riskier
17:42:20 <elliott> well, you gain useful instances you can't otherwise provide, but also I think this is the correct type anyway
17:42:26 <elliott> why can't you make an unordered pair of two incomparable values?
17:42:53 <elliott> it might also make sense to provide e.g. (a -> a -> Ordering) -> UnorderedPair a -> (a,a)
17:42:58 <roconnor> elliott: you want fmap
17:43:07 <roconnor> interesting
17:43:09 <elliott> with the requirement that the function is commutative
17:43:26 <elliott> err, not commutative
17:43:33 <elliott> well, you know what I mean. what you expect of a typical "compare"
17:43:44 <roconnor> elliott: I'm not sure I'd go that far
17:44:17 <elliott> basically I just think it's fundamentally getting an *ordering* out of your unordered pair that requires the ability to *order* the type
17:44:26 <elliott> an *unordered* pair shouldn't care about ordering :)
17:44:36 <roconnor> elliott: well, I like that you can define fmap
17:44:48 <roconnor> that is quite some motivation
17:44:53 <beaky> df -h
17:44:58 <beaky> oops wrong window sorry
17:45:02 <elliott> roconnor: you can even give an Applicative instance, I think!
17:45:04 <roconnor> beaky: du -h
17:45:23 <roconnor> elliott: no I don't think so
17:45:28 <elliott> oh, you can't define a nice (<*>)
17:45:51 <roconnor> no traversable either.
17:45:59 <roconnor> still, functor is nice
17:46:04 <elliott> you can define apply :: Semigroup b => UnorderedPair (a -> b) -> UnorderedPair a -> UnorderedPair b
17:46:24 <elliott> I guess? apply (P f g) (P x y) = P (f x <> g x) (f y <> g y)
17:46:42 <elliott> maybe that's not quite right... you use f and g in both elements but x and y don't cross over in the same way
17:46:52 <roconnor> elliott: is that associative?
17:47:03 <roconnor> or whatever counts as associative
17:47:07 <elliott> yeah, I dunno. just thinking out loud
17:47:11 <roconnor> :)
17:47:11 <elliott> obviously:
17:47:25 <dolio> Semigroup isn't right.
17:47:42 <elliott> apply :: CommutativeSemigroup b => (a -> b) -> UnorderedPair a -> b; apply f (P x y) = f x <> f y
17:47:46 <elliott> should be ok (and doesn't require Ord again)
17:50:19 <Smith_> How come I have never heard of haskell before?
17:51:07 <roconnor> Smith_: we avoid success at all costs
17:51:14 <elliott> Smith_: it's a secret.
17:51:47 <Smith_> what is it used for?
17:51:59 <r00723r0> Smith_: automation, like any programming language.
17:52:03 <`nand`> anything you want
17:52:09 <elliott> keeping secrets
17:52:13 <`nand`> r00723r0: programming languages are used for automation?
17:52:17 <elliott> like its own existence
17:52:18 <`nand`> well, sure they are
17:52:19 <`nand`> but exclusively?
17:52:25 <r00723r0> `nand`: commercially.
17:52:26 <`nand`> I guess you never implied exclusiveness
17:52:27 <`nand`> never mind
17:52:42 <Smith_> so it's just another programming language... why do we need ANOTHER one?
17:52:53 <`nand`> because there aren't enough bad programming languages
17:53:27 <r00723r0> Smith_: as a Haskell beginner who has used many other languages, I can tell you that Haskell is worth learning.
17:53:36 <`nand`> Smith_: on a more serious note, every programming language is different
17:54:07 <BMeph> Some are more different than others, though. ;)
17:54:11 <Modius> I keep flinging myself at the haskell wall.  I used to categorize it as being like an ML; but even being well versed in F# I've been learning that haskell remains in a different category.
17:54:21 <elliott> Smith_: Haskell originated in the late 80s to early 90s.
17:54:28 <elliott> Smith_: it is older than Java, Python, Ruby...
17:54:30 <`nand`> Smith_: the reason Haskell was created was actually to unify the plethora of pure lazy functional languages that were floating around at the time of its creation
17:54:42 <`nand`> to give a common denominator to the masses, somebody everybody can rely on, yknow?
17:54:53 <r00723r0> Haskell is more than that.
17:54:57 <`nand`> (of course, since the, it's evolved considerably)
17:54:58 <ben_> @pl bitLength x = ceiling $ logBase 2 (fromInteger $ x + 1)
17:54:58 <lambdabot> bitLength = ceiling . logBase 2 . fromInteger . (1 +)
17:55:00 <`nand`> since then*
17:55:04 <roconnor> Modius: everything is upside down due to laziness
17:55:16 <Modius> I know it's been evolving; but can it grow to include the wacky proofs stuff in more experimental languages (coq type things), or would it have to be abandoned by people who want to enter that arena?
17:55:35 <`nand`> Modius: you could say.. it's in a dual category? *ba dum tsh*
17:55:43 <roconnor> Modius: only if you want to lose general recursion
17:55:54 <BMeph> Modius: Read up on Agda, then come back. ;)
17:55:56 <roconnor> Modius: there there is a project to make a dependently typed language with general recursion
17:56:10 <`nand`> Modius: I think Haskell is pretty solidly biased against that
17:57:43 <`nand`> roconnor: wait, isn't that easy? Just turn off the termination checker?
17:58:02 <roconnor> `nand`: then you can immediately prove False
17:58:16 <`nand`> sure, but it's still dependently typed, no?
17:58:31 <DigitalKiwi> "why do we need another one" <-- implying haskell is new?
17:58:38 <roconnor> *l* I guess, but you don't have wacky proofs stuff in any sensable sense
17:58:40 <`nand`> DigitalKiwi: it's fairly new compared to some languages
17:58:42 <elliott> "wacky proofs stuff" probably implies proofs
17:58:59 <DigitalKiwi> well most languages are new compared to FORTRAN lisp and COBOL ;p
17:59:10 <`nand`> or English
17:59:13 <`nand`> English is fairly old, I've heard
18:03:20 <ben_> @pl f x = 2 ^ (bitLength x - 1)
18:03:21 <lambdabot> f = (2 ^) . subtract 1 . bitLength
18:03:26 <Moggle> I've heard of Fortran so much
18:03:33 <Moggle> I should probably go check out what the code _looks_ like
18:03:35 <Moggle> I suspect it is not pretty
18:04:22 <Moggle> sweet jesus people actually programmed in this? *still* program in this?
18:04:32 <jmcarthur> it's not actually that bad
18:04:35 <jmcarthur> the old stuff is
18:04:35 <`nand`> people still program in C++
18:04:37 <dolio> You have to be careful about what you're looking at.
18:04:42 <eyebloom> Hi, I've been trying to compile this example involving Kind-indexed type families from "Giving Haskell a Promotion" on ghc 7.6.1 and I'm getting a parse error. Can anyone tell me what's wrong with it:
18:04:48 <hpaste> eyebloom pasted ‚Äúfrom Giving Haskell a Promotion‚Äù at http://hpaste.org/79896
18:04:54 <jmcarthur> modern fortran is not all that bad, at least
18:04:55 <Moggle> `nand`: well that's sort of a given for cutting-edge games and such when you need every ounce of speed
18:04:57 <dolio> People don't program in the stuff with significant columns anymore, for instance.
18:05:33 <`nand`> eyebloom: paste the error
18:05:42 <eyebloom> one moment
18:05:51 <`nand`> eyebloom: do you have UnicodeSyntax turned on or something?
18:06:12 <hpaste> eyebloom pasted ‚Äúerror from Giving Haskell a Promotion‚Äù at http://hpaste.org/79897
18:06:26 <eyebloom> Not that I know of.
18:06:52 <`nand`> that's odd, the error references a line 21, but the code you pasted is only 7 lines long
18:08:12 <eyebloom> Ah sorry it's referring to the first instance declaration, there's some comments at the top.
18:08:50 <`nand`> eyebloom: line 6 seems to be missing an actual definition
18:11:07 <eyebloom> Sorry let me start over.
18:11:12 <hpaste> eyebloom pasted ‚Äúanother try‚Äù at http://hpaste.org/79898
18:12:20 <`nand`> eyebloom: do you have TypeFamilies enabled?
18:13:14 <Smith_> Interesting. I'm trying to learn JavaScript and now Haksell...
18:13:22 <Smith_> Haskell*
18:14:42 <eyebloom> Ok that get's rid of the parse error. I now get this:
18:14:45 <hpaste> eyebloom pasted ‚Äúanother error‚Äù at http://hpaste.org/79899
18:16:14 <`nand`> the error message suggests a fix
18:16:39 <eyebloom> Right, it works, sorry to fill up the channel with my lameness.
18:16:42 <`nand`> (I needed to enable TypeFamilies, UnicodeSyntax, PolyKinds and UndecidableInstances to get your sample to compile)
18:17:00 <`nand`> on that note
18:17:13 * `nand` really thinks type families should result in a nicer GHC error when TypeFamilies isn't enabled
18:17:24 <ivanm> I'm wanting to use a Vector (Maybe a) analogously to say IntMap a; would it be better to just append a new value onto the end each time, or to allocate a chunk more space and just update values (since updates are all O(n)) ?
18:17:43 <`nand`> instead of a ‚Äúparser error on input ::‚Äù
18:17:49 <eyebloom> I agree with you.
18:32:53 <Modius> Do you get in situations where the name of an (ADT?)/union choice tends to want to be the same as the name of the type (and its constructor) that you're storing?  What *should* I do instead?
18:33:45 <shachaf> strings /dev/urandom | head
18:33:46 <`nand`> you mean like data FooBar = Foo Foo | Bar Bar ?
18:34:00 <Modius> `nand` yeah
18:34:39 <mrout> @where faw
18:34:40 <lambdabot> I know nothing about faw.
18:34:41 <mrout> faw
18:34:45 <mrout> @where faq
18:34:45 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
18:34:50 <`nand`> I've run into it once or twice, but managed to workaround
18:34:58 <Modius> Seems it'd be pretty common
18:35:17 <Modius> ny time a data choice happens to be something that would have named fields.
18:35:20 <`nand`> Modius: shachaf's idea suggest TqfY
18:36:39 <mrout> where's that list of real world applications of haskell you post when people go "ewww, Haskell looks like a toy language for mathematicicans"
18:37:15 <`nand`> http://www.haskell.org/haskellwiki/Haskell_in_industry maybe?
18:37:30 <mrout> tyvm
18:37:32 <cmccann> pf, all programming languages look like toy languages for people who do something I don't personally care about
18:37:39 <`nand`> but I don't post that when people go ‚Äúewww, Haskell looks like a toy language for mathematicians‚Äù; I post that when people go ‚Äúare there any examples of Haskell being used in the industry?‚Äù
18:38:12 <Modius> FWIW Jon Harrop started a big potshot at that list.
18:38:30 <cmccann> harrop does not have meaningful opinions
18:38:38 <`nand`> who's Jon Harrop?
18:39:22 <BMeph> `nand`: Exactly. ;)
18:39:32 <DigitalKiwi> F# guy?
18:39:56 <`nand`> he runs the ‚ÄúHaskell News‚Äù blog?
18:40:19 <DigitalKiwi> http://www.amazon.com/F-Scientists-Jon-Harrop/dp/0470242116
18:40:41 <elliott> `nand`: a troll
18:40:49 <Modius> A: Harrop is ludicrously smart and a top contributor to F# knowledge.  B:  He is disingenuous between languages so as to draw functional-interested folk toward his own products.
18:40:56 <Modius> Or in short, he's a troll yeha.
18:41:01 <elliott> `nand`: feel free to ignore anything he says about haskell
18:41:05 <Modius> I tihnk it's worth reading everything he writes.
18:41:07 <elliott> he freely admits it is all trolling to advertise his F# company
18:41:29 <`nand`> I'll go ahead and trust elliott and cmccann's judgements
18:41:32 <DigitalKiwi> and a troller of the lisp google group
18:41:32 <Modius> Some of the F# vs Haskell led me astray a bit, cherrypicked stuff that amade haskell more verbose.
18:41:41 <Modius> Oh yeah, hardcore lisp troller.
18:42:01 <elliott> I like how the sidebar of the "Haskell News" blog is all links to F#/OCaml/Mathematica stuff he wrote.
18:42:05 <elliott> Haskell news!
18:42:06 <monadicity> isn't lisp community just so incestual that everyone outside it is a troll
18:42:10 <cmccann> far as I can tell at least 90% of everything harrop says is designed to advertise his consulting services
18:42:23 <Modius> But part of it is advertising by sharing uncommonly good info.
18:42:31 <ion> http://www.topix.com/city/haskell-tx
18:42:59 <cmccann> honestly I found harrop's presence so irritating that it's discouraged me from looking at F# much
18:43:18 <DigitalKiwi> https://groups.google.com/forum/?fromgroups=#!topic/comp.lang.lisp/aOKqiR278bQ is kind of lulzy in a sad way
18:43:18 <cmccann> and I'm a C# programmer at my day job
18:43:21 <Modius> Meh - if you're in .Net it's the shite.
18:43:29 <ion> ‚ÄúHASKELL DATING‚Äù
18:43:36 <Modius> F#'s support is sufficient to make C# obsolete
18:44:25 <cmccann> well if I'm gonna ditch the mainstream stuff that pays my bills I see no reason to be tied to .NET
18:44:35 <`nand`> (from what I heard F# isn't very well supported yet)
18:44:36 <cmccann> I'd probably take up clojure or something first
18:44:49 <Modius> I have to qualify that F# is da bomb, if you're in .net
18:44:56 <elliott> cmccann: there's a nice deleted SO answer about Harrop accusing the data parallel haskell people of academic fraud
18:45:00 <Modius> It can be compared side by side with C#
18:45:09 <Modius> They're trying to get it onto mono; but it takes a god just to get it running.
18:45:11 <cmccann> elliott, yeah I think I remember seeing that
18:45:17 <elliott> cmccann: er s/about Harrop/by Harrop/
18:45:23 * `nand` still uses C#, if only to avoid having to learn a new language :(
18:45:48 <Modius> I'd think a haskell and C# user could go straight into F#
18:45:50 <`nand`> Modius: it ‚Äòruns‚Äô fine; but apparently some of the more complex libraries can fail to build
18:46:08 <`nand`> Modius: of course, I've heard conflicting opinions about this
18:46:18 <`nand`> others say every library compiles fine under mono now
18:46:18 <Modius> I wanted the IDE working
18:46:22 <cmccann> C# is surprisingly tolerable for a language mainstream enough not to scare people
18:47:07 <shachaf> monadicity: Are you fax?
18:47:40 <`nand`> is ‚Äòfax‚Äô a name here, or an adjective?
18:48:00 <shachaf> I'm not really sure.
18:49:10 <`nand`> Modius: I think the greatest effort would be figuring out what you can't do in F#
18:50:14 <`nand`> (not like I use .NET either way; the C# usage just pops up when some devious part of my mind goes down the path of ‚ÄúI wonder if I could do this in C#... maybe by doing this...‚Äù)
18:51:56 <Modius> F# guys did a wonderful job.  Interop is seamless, IDE support is 90% what you get in C#.
18:52:19 <Modius> I haven't done Asynch stuff in C# just F#; but I don't see how they could make it nearly as nice.
18:52:36 <`nand`> I stopped using C# before they introduced the async stuff :(
18:52:45 <Modius> Sneaked in some of the immutable containers to the C# codebase.  "Are you linking in F# to the core project?"  "No, they're just .Net libraries, I don't know what they're written in" haha.
18:54:07 <Modius> In one aspect of practicality, the Haskell/Cabal system seems to work across Windows/Linux without much grief, I'd feel comfortable writing software in it that had to run in both worlds.
18:56:45 <`nand`> you can sneak in Posix dependencies from time to time
18:57:54 <Modius> I'm going on faith that the IO works (been using Darcs)
19:01:28 <augur> are there any good videos recently?
19:04:07 <Modius> Woah - 2 different record types' "members" can't share a name?
19:04:28 <Modius> (I value the extract syntax, don't get me wrong. . .  but. . .)
19:04:33 <otters> well, no
19:04:45 <otters> because the member becomes a function of type Record -> a
19:05:06 <`nand`> lenses to the rescue?
19:05:13 <Modius> What do you find yourself doing when you see this come up in practice when coding?
19:05:20 <edwardk> ?
19:05:20 <otters> rename the member
19:05:23 <otters> or import qualified
19:05:26 <otters> if it's not mine
19:05:28 <edwardk> ah
19:05:33 <`nand`> makeClassy :P
19:05:43 <`nand`> (disclaimer: I've never used makeClassy)
19:06:31 <Modius> I see a page on hackage where they go over it.
19:06:58 <edwardk> Modius: it makes sense when you learn more about haskell. type directed name resolution has a lot of implications for the type system. its part of the reason why type inference sucks so much in other language compared to haskell
19:07:11 <edwardk> er other languages
19:07:23 <Modius> Oh I know, in F# it bugs the crap out of me I have to do a (fun x -> x.FieldName) everywhere when everything eles is so functonal.
19:07:44 <cmccann> in other words a lot of code relies on having name-directed type resolution
19:07:48 <Modius> One nice thing - does haskell have this?  In F#, you can have { existingRecordInstance with someMemberFoo = newValue }
19:07:59 <elliott> rec { foo = newV }
19:08:00 <edwardk> Modius: foo { bar = 12 }
19:08:09 <`nand`> foo & bar .~ 12
19:08:09 <cmccann> and you kind of want your resolution to resolve somewhere
19:08:11 * `nand` hides
19:08:13 <edwardk> with lenses you can doo foo & bar .~ 12
19:08:16 <elliott> you might well end up preferring rec & foo .~ newV :P
19:08:49 <Modius> Got a link to something for that?  .~ probably won't show up on a search, I want a definitive guide to this stuff.
19:09:06 <`nand`> best ask edwardk
19:09:30 <elliott> hackage.haskell.org/package/lens
19:09:33 <elliott> it's not part of the language
19:09:34 <edwardk> Modius: lens.github.com links to a bunch of stuff. github.com/ekmett/lens has a short tutorial on it
19:09:37 <elliott> it's a separate package
19:09:49 <cmccann> https://github.com/ekmett/lens/wiki/Operators is pretty handy
19:09:50 <elliott> probably you don't want to bother learning it until you're comfortable with haskell
19:09:52 <edwardk> Modius: also i have a 2 hour youtube video describing how it works
19:10:04 <edwardk> https://www.youtube.com/watch?v=cefnmjtAolY&hd=1
19:10:06 <elliott> cmccann: hmm, that looks out of date :(
19:10:09 <elliott> talks about "query"
19:10:20 <cmccann> edwardk, 90 minutes of which are just listing all the operators you use, right
19:10:31 <edwardk> cmccann: no, i blow past all of those
19:10:41 <edwardk> its mostly just walking through laws and some basic usecases
19:10:49 <edwardk> i didn't even get to the template haskell generation or prisms, etc.
19:11:10 <`nand`> cmccann: haha
19:11:24 <`nand`> I think I still like <<>~ best
19:11:52 <DigitalKiwi> now do that in unicode
19:12:05 <edwardk> `nand`: the rat?
19:12:06 <`nand`> edwardk: when will you update your talk with respect to profunctor lenses?
19:12:08 <`nand`> edwardk: exactly
19:12:23 <edwardk> `nand`: nothing in the talk other than 5 minutes on isomorphisms would change
19:12:28 <`nand`> U+0C32 LEFTWARDS RAT
19:12:51 <shachaf> Hmm, maybe I should do a short talk about the latest advances in lens technology at bahaskell.
19:12:56 <edwardk> and even then i already put a caveat on how the isomorphism stuff was covered to indicate that it was based on an old version of the library's approach and was more indicative of how you could do such a thing
19:12:58 <`nand`> edwardk: well, and include prisms obviously
19:13:34 <shachaf> elliott: Did you manage to write ignored?
19:14:05 <`nand`> isn't ignored just const pure?
19:14:13 <`nand`> or is this about some new representation
19:14:20 <elliott> shachaf: I think it's impossible without id.
19:14:23 <elliott> With id it's easy.
19:14:30 <shachaf> elliott: Well, yes.
19:14:38 <elliott> I don't know of any way to reduce the weird duplication with Prismy.
19:15:27 <Modius> I'm seeing the logic of the record access syntax.  F# is divine; but the foo.bar thing (and needing a lambda to make a func that gets bar) makes me feel OO-dirty.
19:16:01 <Modius> This stuff though probably pulls you into smarter use of modules, in pseudo-OO-functional you still end up using namespaces/modules more as an afterthought.
19:16:05 <`nand`> don't worry, lenses will make you feel dirter
19:16:08 <`nand`> dirtier*
19:16:09 <shachaf> > view (_1._2) (("hello","there"),"Modius")
19:16:11 <lambdabot>   "there"
19:16:20 <`nand`> it gets better when you throw in the pascal-y ^.
19:16:24 <Modius> Doesn't look dirty to me - it's a problem I've had in the back of my mind before.
19:16:28 <`nand`> rec^.fieldA.fieldB
19:16:35 <shachaf> What was the type for ignored again?
19:16:41 <elliott> :t ignored
19:16:43 <lambdabot> (Applicative f, Indexable i k) => Overloaded k f s s a b
19:16:45 <elliott> Modius: honestly our record system sucks
19:16:47 <elliott> no real way around it
19:16:49 <elliott> lenses make it nice though
19:17:11 <shachaf> elliott: Not that one.
19:17:16 <shachaf> Oh, I guess it is that one.
19:17:19 <shachaf> p a b -> p s s?
19:17:47 <shachaf> But Prismy is enough to fail, and Lensy is enough to not have to provide (b -> t) without s!
19:17:51 <cmccann> unfortunately, the only thing people can agree on about haskell's records is that they suck
19:17:57 <`nand`> Modius: stuff like ‚Äòfield += 3‚Äô is valid lens code ;)
19:18:04 <cmccann> every attempt to fix them has stalled out because of endless arguments
19:19:28 <`nand`> I think the major benefit record syntax has over lenses right now is that rec { foo = bar; bat = baz } can type-check when rec & foo .~ bar & bat .~ baz doesn't, if the types of foo and bar are related and you want to change both at the same time
19:19:31 <edwardk> cmccann: i'm hoping with 'over exposed' to be able to finally put to bed the last argument against lenses for records
19:19:48 <parcs> > 0x108
19:19:50 <lambdabot>   264
19:19:51 <`nand`> edwardk: exposed?
19:20:11 <edwardk> `nand`: 'exposed' gives you that
19:20:14 <elliott> `nand`: it fixes the problem you just said
19:20:17 <`nand`> okay
19:20:21 <`nand`> not in HEAD yet?
19:20:32 <shachaf> Fixed in edwardk's HEAD
19:20:40 <shachaf> @yow
19:20:40 <lambdabot> Couldn't find fortune file
19:20:42 <cmccann> edwardk, that would be lovely but I'm not ready to be optimistic about anything where records are involved
19:21:03 <edwardk> foo & over exposed %~ \r -> r & x .~ 10 & y .~ 20
19:21:25 <`nand`> dohoho ‚Äòoverexposed‚Äô
19:21:34 <DigitalKiwi> what are records? is this some database thing or?
19:21:49 <`nand`> DigitalKiwi: just regular types with named fields
19:22:15 <edwardk> that lets you edit the tyes of the fields independently and then when it gets sucked back through the 'exposed' isomorphism the typechecking happens
19:22:48 <DigitalKiwi> oh
19:23:07 * cmccann still wishes there was a to partially-apply record constructors using field names
19:23:19 <`nand`> edwardk: still a bit more verbose than foo { x = 10; y = 20 }
19:23:19 <cmccann> with that being reflected in the type, not just leaving the other fields as errors
19:23:29 <edwardk> `nand`: sadly so
19:23:45 <`nand`> maybe some new operators could help with that
19:23:51 <edwardk> er i also was more verbose there than i needed to be
19:23:54 <cmccann> yes, more operators should help
19:24:03 <cmccann> there are at least a few not already in use
19:24:05 <cmccann> I think
19:24:08 <`nand`> let's hope
19:24:13 <`nand`> maybe &&
19:24:29 <`nand`> not sure the Data.Bool folks would appreciate that
19:24:31 <lispy> :t maybe (&&)
19:24:33 <lambdabot> (a -> Bool -> Bool -> Bool) -> Maybe a -> Bool -> Bool -> Bool
19:24:34 <DigitalKiwi> which bot do i trigger and how for the seen? looking for glguy :<
19:24:35 <cmccann> how about ($<~<**<=)?
19:24:39 <cmccann> I don't think that's used yet
19:24:42 <Modius> I still wonder if a person of average programmer intelligence can get useful in haskell.
19:24:54 <`nand`> cmccann: I think that's used for indexed prisms inside state monads
19:24:57 <Nereid> @seen glguy
19:24:57 <lambdabot> Unknown command, try @list
19:25:01 <Modius> I used to think functional stuff was just a familiarity issue for those of us who cut our teeth in C, now not so sure.
19:25:04 <Nereid> but.
19:25:09 <cmccann> `nand`, Bool is obsolete, everything is lenses now
19:25:25 <cmccann> Modius, sure, it's just a bigger transition
19:25:26 <edwardk> `nand`: you don't index prisms =P
19:25:28 <`nand`> Lens ‚âÖ Lens Lens LEns
19:25:30 <lispy> > maybe (&&) (const (&&)) (Just 1) True False
19:25:32 <lambdabot>   False
19:25:42 <`nand`> the next generation of lambda calculi
19:25:44 <elliott> well you could define something for foo & over exposed %~ bar
19:25:46 <cmccann> Modius, I think Haskell would be easier to learn than C++ for someone completely new to programming
19:25:55 <cmccann> admittedly that's not saying much
19:26:00 <elliott> so it'd just be
19:26:11 <elliott> foo <OPERATOR> (x .~ 10) . (y .~ 20)
19:26:23 <lispy> Modius: FWIW, when I program in python I'm constantly reminded of how bad I really am at programming. I'm simply not smart enough to deal with that language.
19:26:27 <elliott> edwardk: (a (.) with the same precedence as (&) could be useful...)
19:26:28 <`nand`> needs a nice operator for (.) too
19:26:29 <Modius> That's what I mean, I know expertise in C++ (to where you don't write crashers) is hard and takes time; but I think a drone could plod through it in time.
19:26:31 <`nand`> yeah
19:26:33 <lispy> Modius: but I do fine with Haskell
19:26:36 <edwardk> Modius: i used to want to transition the entire world to functional programming. now i'm content to work with smart people and no longer feel the need.
19:26:40 <elliott> or you could do foo <OPERATOR> do { x .= 10; y .= 20 } I guess
19:26:47 <Nereid> ha
19:27:25 <Nereid> > (1,2) `execState` do { _1 .= 3; .2 .= 4 }
19:27:27 <lambdabot>   <hint>:1:33: parse error on input `.'
19:27:31 <Nereid> > (1,2) `execState` do { _1 .= 3; _2 .= 4 }
19:27:33 <lambdabot>   Couldn't match expected type `Control.Monad.Trans.State.Lazy.StateT
19:27:33 <lambdabot>        ...
19:27:39 <Nereid> oh what am I looking for.
19:27:45 <shachaf> flip execState?
19:27:47 <edwardk> there are enough good haskellers out there that i could keep any good sized company i wanted to work for stocked with talent, and the community is growing more than fast enough to keep up with demand.
19:27:50 <`nand`> flip.. yeah
19:27:54 <Nereid> yeah.
19:28:05 <Nereid> > do { _1 .= 3; _2 .= 4 } `execState` (1,2)
19:28:07 <lambdabot>   (3,4)
19:28:08 <lispy> ?users
19:28:08 <lambdabot> Unknown command, try @list
19:28:28 <ion> > do { _1 .= "foo"; _2 .= "bar" } `execState` (1,2)
19:28:30 <lambdabot>   No instance for (GHC.Num.Num [GHC.Types.Char])
19:28:30 <lambdabot>    arising from the literal ...
19:28:33 <Nereid> indeed.
19:28:35 <cmccann> edwardk, the only problem is that they're not geographically dense enough to find local talent in arbitrary locations
19:28:36 <lispy> I miss being able to ask lambdabot for the high-water mark
19:28:37 <Modius> edwardk:  Do you see a time when better language-empowered programmers will take the place of many drones, or just that people like haskellers (and I can't claim to be one) will stay in the most difficult niches?
19:28:43 <Nereid> oh yeah.
19:28:46 <Nereid> I guess State can't change types.
19:28:51 <Nereid> :(
19:28:51 <`nand`> foo |> a .~ b && c .~ d
19:28:54 <cmccann> which is why the most recent /r/haskell post about hiring was full of "where are you and can people work remotely?"
19:29:16 <`nand`> Nereid: just munge an overexposure in there
19:29:23 <monadicity> https://pledgie.com/campaigns/18959
19:30:19 <`nand`> cmccann: lazy relocation?
19:30:34 <`nand`> you end up moving over when somebody tries to hand you a paper or something
19:30:48 <cmccann> haha
19:31:23 <`nand`> (of course, nobody will want to feel the guilt of causing you to spend so much effort moving for something that can easily be done online, so it'll work out in the end)
19:31:33 <DigitalKiwi> huh I could use 3000 dollars
19:33:49 <mikeplus64> :t (|>)
19:33:50 <lambdabot>     Not in scope: `|>'
19:33:50 <lambdabot>     Perhaps you meant one of these:
19:33:50 <lambdabot>       `Seq.|>' (imported from Data.Sequence),
19:35:08 <superfluous> is learn yourself a haskell for great good still considered the 'best' get-your-self-up-to-speed-in-haskel guides?
19:35:11 <mikeplus64> (edwardk |> instead of/additionally to & would be nice (F# and others use |> for backwards function application))
19:35:22 <`nand`> I don't know about the best, since I've read a fairly small number of them, but it's certainly nice
19:35:26 <elliott> don't talk to edwardk about (|>) :P
19:35:39 <edwardk> mikeplus64: i consciously rejected (|>)
19:35:40 <`nand`> heh
19:35:50 <edwardk> i'm well aware of the precedent
19:35:56 <mikeplus64> edwardk: why?
19:35:58 * cmccann likes (|>) and (<|) for low-precedence application, to visually match (<<<) and (>>>) for low-precedence composition
19:35:59 <`nand`> mikeplus64: the idea just now was to use |> not for & but for the over exposed stuff
19:36:38 <shachaf> https://github.com/ekmett/lens/issues/17
19:36:43 <Modius> You using |> the same as the F# |> ?
19:36:49 <shachaf> No.
19:36:51 <shachaf> No one's using (|>)
19:37:04 <lispy> superfluous: it's still relevant. I can't say if it's the best, but it is good
19:37:29 <edwardk> for one, the problem with (|>) is it doesn't fit the surrounding semiotics of haskell. (<|>) is about alternatives. we use (<*>) <* *>     |>  looks more like something for m |> a = m <|> return a.   the second problem is related
19:37:32 <elliott> cmccann: nothing's nice about (<<<) and (>>>)
19:37:38 <Modius> I can't claim to know much haskell; but of several books I had before, it took LYAH to talk down to me enough to get me past the first hurdles.
19:37:43 <superfluous> lispy: cool. I've been trying to 'get into it' but its been a bit of a hurdle...
19:37:50 <lispy> > let (|>) = flip ($) in 1 |> succ
19:37:51 <lambdabot>   2
19:38:07 <cmccann> :t (<<<) >>> (<<<) >>> (<<<) -- elliott, how can you not appreciate the beauty of this
19:38:08 <lambdabot> Control.Category.Category cat => cat b c -> (a2 -> a1 -> cat a b) -> a2 -> a1 -> cat a c
19:38:17 <edwardk> if we go through and logically continue the reasoning that leads to most of the operators in lens, the operator=   should be the application of the operator to the target of the lens in  the state monad, so you get  |>=  which is a particularly egregiously bad looking operator
19:38:38 <edwardk> worse, when you realize that <operator= is used for chaining assignment it yields a <|>=  operator that has nothing to do with <|>!
19:38:43 <shachaf> edwardk: You should annotate comment on https://github.com/ekmett/lens/issues/48
19:39:10 <edwardk> finally, it contributes to the operator soup complaints. & at least reads off the screen as 'and' or 'and then' |> has no such reading.
19:39:13 <`nand`> cmccann: too many parentheses. I think we need to define <<<>>><<<>>><<< as an alias for this commonly used function to fix that
19:39:14 <shachaf> Drop one of those verbs.
19:39:20 <cmccann> `nand`, works for me
19:39:56 <lispy> :t (<><)
19:39:57 <lambdabot>     Not in scope: `<><'
19:39:58 <lambdabot>     Perhaps you meant one of these:
19:39:58 <lambdabot>       `<>' (imported from Data.Monoid),
19:40:03 <carlocci> I'm trying to learn this language through osmosis: are there content aggregators which present news and articles about the language you would suggest?
19:40:05 <lispy> no fish operator?
19:40:22 <`nand`> hmm
19:40:27 <lispy> carlocci: planet haskell and reddit's /r/haskell
19:40:42 <carlocci> I'll google for those, thanks
19:40:46 <DigitalKiwi> carlocci: that probably won't work too well
19:40:53 <DigitalKiwi> I tried that a while back
19:40:54 <`nand`> does #haskell count as a content aggregator?
19:41:00 <carlocci> very much so
19:41:03 <DigitalKiwi> for months I idled here, didn't learn a thing ;p
19:41:08 <edwardk> mikeplus64: & won over (|>) for all of those reasons and the fact that it was shorter and easier to type. two symbols for the same thing just means that end users start wondering if there is a subtle distinction they are missing between them, etc.
19:41:18 <`nand`> I think I started learning when I stopped idling and started writing haskell + asking questions
19:41:25 <DigitalKiwi> ^
19:41:28 * cmccann will continue to use (|>) anyway. lens already conflicts with an operator or two in his idiosyncratic alternate Prelude so what's one more incompatibility?
19:41:38 <lispy> DigitalKiwi: the immersion approach works well for learning the lingo, the issues that people care about, and definition things, but yeah doing is the only way to learn to program in Haskell
19:41:41 * edwardk shrugs.
19:41:51 <cmccann> that said, & is probably better for lens
19:41:52 <`nand`> I must say I like & much more than |>
19:41:58 <edwardk> feel free. i'm just enumerating the reasons why lens will not be exporting another name for &
19:42:00 <cmccann> it would be nice to standardize on a single flipped ($) operator though
19:42:01 <`nand`> I also liked %, but Data.Ratio w/e
19:42:09 <edwardk> we're ripping ^& out in 3.8 too
19:42:09 <`nand`> I think I like & more than % though
19:42:11 <`nand`> it reads nicer
19:42:18 <`nand`> ^&?
19:42:22 <cmccann> there is one benefit to &
19:42:35 <edwardk> `nand`: high fixity & for compatibility with ^. chaining
19:42:39 <cmccann> the only sensible thing it would mean out of context is something involving logical and
19:42:45 <carlocci> DigitalKiwi: I find extremely funny when people ask a question, someone evaluates something and lambdabot outputs a couple of lines of garbled text and everyone goes "hmm, I see"
19:42:46 <cmccann> and that's not workable because | is a syntax error
19:42:54 <`nand`> ah, that one
19:42:59 <edwardk> cmccann: we lost the fight on the mailing list and it was contentious enough that i decided to not try to standardize anything for a while
19:43:04 <cmccann> so a lone & is kind of stranded semantically, might as well repurpose it
19:43:06 <`nand`> cmccann: I think that's firmly rooted as &&
19:43:20 <`nand`> and .&.
19:43:35 <`nand`> hey, is Bool an instance of Bits?
19:43:48 <`nand`> gosh, it isn't
19:43:52 <cmccann> `nand`, right, using (&) for and is awkward because (|) isn't legal
19:43:53 <lispy> > True .|. False
19:43:55 <edwardk> `nand`: there were a bunch of changes made so 7.6 coud have it be
19:43:55 <lambdabot>   No instance for (Data.Bits.Bits GHC.Types.Bool)
19:43:55 <lambdabot>    arising from a use of `D...
19:44:12 <edwardk> `nand`: previously it required Num as a superclass
19:44:16 <`nand`> yeah
19:44:17 <edwardk> and Bool isn't Num
19:44:36 <lispy> Bool could be Num if Num were just a ring
19:44:38 <`nand`> if it could be made an instance now we could have (&&) = (.&.) and free up the former for lens ;)
19:44:44 <cmccann> Bool could be a Num anyway
19:44:46 <lispy> but alas, num  is no ring
19:44:50 <`nand`> Word8 is a Num
19:44:51 <cmccann> treat it as Word1 :P
19:44:54 <`nand`> Bool ‚âÖ W..
19:44:55 <`nand`> yteah
19:45:10 <Modius> You should qualify every now and then that you're joking, you're scaring the little people.
19:45:29 <elliott> joking?
19:45:34 <elliott> I think it is you who needs to be scared
19:45:45 <cmccann> Modius, a lot of what gets said in here transcends any distinction between jokes and serious intent
19:45:52 <Modius> By "little people" I meant me.
19:45:53 <`nand`> I think distinguishing between jokes and serious proposals is part of the learning process
19:45:53 <cmccann> it is both, and it is neither
19:45:59 <lispy> I cannot make jokes. I lack a humor coprocessor.
19:46:12 <`nand`> the best jokes are those with a hint of truth in them
19:46:12 <cmccann> I only make jokes that aren't funny.
19:46:17 <`nand`> same here
19:46:20 <cmccann> the only humorous things I say are not jokes.
19:46:28 <cmccann> it works better that way.
19:46:46 <lispy> There are two people in this room, one who always tells funny jokes and one who always tell non-funny jokes...
19:46:56 * `nand` envisions some parallel world in which the academic process is to introduce new concepts entirely via jokes
19:46:56 * lispy sees a logic puzzle forming
19:46:58 <edwardk> clearly Bool should be a boolean ring rather than the boolean semiring
19:47:07 <elliott> lispy: ahh, I know this one! The latter one is cmccann
19:47:14 <lispy> edwardk: agreed
19:47:35 <`nand`> boolean ring?
19:47:36 <mikeplus64> in a Num instance for Bool, i'm not sure what negate would be, if you treat false as 0 and true as 1
19:47:42 <mikeplus64> negate = id?
19:47:46 <elliott> > negate 1 :: Word8
19:47:47 <lambdabot>   255
19:47:49 <elliott> > negate 255 :: Word8
19:47:50 <lambdabot>   1
19:48:02 <lispy> > signum 1
19:48:03 <lambdabot>   1
19:48:08 <lispy> > signum 1 :: Word8
19:48:10 <lambdabot>   1
19:48:14 <lispy> > signum 255 :: Word8
19:48:15 <lambdabot>   1
19:48:20 <Nereid> > signum (-1) :: Word32
19:48:20 <`nand`> two's complement negation of Word 1 would be 1
19:48:22 <lambdabot>   1
19:48:24 <`nand`> Word1's 1*
19:48:38 <cmccann> > (negate 1 :: Word8) .&. 1
19:48:38 <edwardk> x + y = (x ‚àß ¬¨ y) ‚à® (¬¨ x ‚àß y) is totally what people expect when they write True + False
19:48:39 <lambdabot>   1
19:49:14 <lispy> Being able to accidentally add True/False would be a sweet feature.
19:49:14 <`nand`> xor?
19:49:26 <`nand`> doesn't xor canonically use a symbol like +
19:49:30 <`nand`> with a circle around it , I guess
19:49:38 <cmccann> `nand`, ‚äï
19:49:44 <mikeplus64> `nand`: /= ;)
19:49:48 <edwardk> `nand`: xor would be * in the boolean ring
19:49:53 <edwardk> er
19:49:56 <edwardk> nm
19:50:03 <edwardk> thats &
19:50:03 * cmccann ponders the situation of telling someone called "nand" the symbol for a boolean operator
19:50:07 * lispy curses his windows-unicode-characters-not-present-in-the-font situtation
19:50:15 <Modius> Is there/what is a library element to represent a sorted container (I assume tree-based)?
19:50:25 <cmccann> Modius, Data.Set?
19:50:35 <`nand`> cmccann: I forgot what the nand operator looks like :(
19:50:40 <Modius> Thanks
19:50:42 <mikeplus64> @hoogle containers
19:50:42 <lambdabot> package containers
19:50:42 <lambdabot> package containers-benchmark
19:50:43 <lambdabot> package containers-unicode-symbols
19:50:43 <`nand`> that's why I just use `nand`
19:50:46 <mikeplus64> Modius:
19:50:54 <cmccann> `nand`, a sheffer stroke?
19:51:03 <`nand`> yeah, I knew the name.. but not what it looks like
19:51:29 <`nand`> oh, an up arrow
19:51:44 <cmccann> I think the sheffer stroke is written |
19:51:51 <cmccann> which certainly won't confuse matters at all
19:51:58 <`nand`> wikipedia's TeX stuff writes it https://upload.wikimedia.org/math/2/d/6/2d6557c145701f007f60a15534c9269c.png
19:51:59 <jozefg> Someone have the time to proof-read a blog post? I'd really appreciate it
19:53:15 <Fuuzetsu> uh, I get  openBinaryFile: does not exist (No such file or directory) if I pass a file name with a forward slash in it to ByteString.writeFile ... Any ideas? Escaping it with \ didn't seem to work
19:54:06 <cmccann> `nand`, ‚äº might be a less confusing option
19:54:10 <Fuuzetsu> (it works in case of existingDir/fileName but doesn't if I do existingDir/fileNa/me nor existingDir/fileNa\/me
19:54:14 <Fuuzetsu> )
19:54:26 <`nand`> cmccann: I could live with that
19:54:33 * `nand` goes with ¬¨(a‚àßb) in practice
19:54:44 <mikeplus64> it's very peculiar to have a filename with a / in it Fuuzetsu
19:54:51 <cmccann> `nand`, tch, how mundane
19:55:09 <Fuuzetsu> mikeplus64: I have plenty of those...
19:55:16 <`nand`> cmccann: how does one get ‚äº (darn it, now I have to add a new keybind somewhere) into ASCII?
19:55:35 <mikeplus64> Fuuzetsu: are you on windows?
19:55:35 <`nand`> then again, it's not like we're using ASCII for ‚àß either way
19:55:39 <Fuuzetsu> mikeplus64: no
19:55:41 <cmccann> `nand`, by not using ASCII, I expect
19:56:08 <mikeplus64> Fuuzetsu: how do you make files with /s in them in linux (or mac os x)?
19:56:42 <`nand`> edwardk: have you thought about how one might expect %~ to be lens_value Data.Ratio.% a ?
19:57:11 <edwardk> `nand`: yes, and shrugged.
19:57:18 <mikeplus64> Fuuzetsu: with dolphin, if i try make a file with a / in it, it inserts a character awfully like a /, but not a /
19:57:24 <Fuuzetsu> mikeplus64: I just checked and apparently I can't... I could have sworn that I could just escape it with something but it doesn't work
19:57:24 <elliott> edwardk hates Data.Ratio.(%)
19:57:28 <Fuuzetsu> it's an illegal character
19:57:30 <cmccann> `nand`, is that a rational thing to expect though
19:57:31 * Fuuzetsu sighs
19:57:37 <`nand`> (especially while (%) was still flip ($), that would have really killed the point about $~ and %~)
19:57:45 <Fuuzetsu> I guess I'll just filter all the '/' in file names
19:58:13 <edwardk> i'm happier with the %= mod-equals mnemonic. that i am with compatibility with a module that takes up a perfectly good operator in order that most of the time they'll just wind up with the awesome Ratio Int
19:58:27 <edwardk> er than I am
19:58:29 <mikeplus64> Fuuzetsu: try see if you can tab complete the filenmae in ghci, and what comes up
19:58:35 <`nand`> cmccann: <insert bad pun about something being completely natural>
19:58:49 <mikeplus64> (just type "<chars><tab>
19:58:51 <mikeplus64> )
19:59:36 <mikeplus64> Fuuzetsu: because if you have files with '‚ÅÑ' in them (*not* '/'), everything is fine and dandy
19:59:39 <edwardk> the more consistent choice is &~ and &=, but that won't happen. it looks terrible in practice, has no mnemonic, and foo & bar &~ baz & quux &~ quaffle   gives no good visual break
20:00:12 <`nand`> I do feel that % looks a bit bulky
20:00:18 * cmccann doesn't trust & anyway. looks like a demon.
20:00:19 <`nand`> %~ isn't the prettiest operator I've seen
20:00:28 <cmccann> at least % is possibly edible.
20:01:00 <mikeplus64> most operators composed of other operator symbols are pretty damn ugly
20:01:02 <`nand`> fun mental image: a group full of seasoned haskellers furiously mashing their keyboards in attempt to figure out new operator combinations that could work
20:01:10 <edwardk> %~ is bulky, but there is a shortage of symbols and i don't intend to randomly bikeshed that and break all of the users of lens, given that ther eis frankly no other comparable operator to move to
20:01:31 <`nand`> it could be worse
20:01:34 <`nand`> we could be using #
20:01:42 * hackagebot conductive-hsc3 0.3.1 - a library with examples of using Conductive with hsc3  http://hackage.haskell.org/package/conductive-hsc3-0.3.1 (RenickBell)
20:01:47 <edwardk> i've already had people complain that .~ wasn't application of (.) to the target
20:01:50 <mikeplus64> `nand`: in the world's largest bikeshed
20:02:34 * cmccann suggests just using fancy unicode stuff. plenty of operators to be had there.
20:02:36 <edwardk> my take away from all of this is that no matter what i do, someone will complain, so i will continue to just do what i want to do =P
20:02:39 <`nand`> edwardk: clearly the solution is to just have ~, and overload it using a typeclass to make it take the correct type based on context
20:02:46 <cmccann> good plan
20:02:56 <mikeplus64> ~ has always implied to me "modify", so as far as i care it's a shame those State lens things steal all the nice =y operators
20:03:01 <edwardk> and, along the way, listen to the more reasonable requests ;)
20:03:37 * cmccann requests not clashing with his use of (??) >:[
20:04:33 <`nand`> (??)?
20:04:48 * cmccann defines (??) = flip fromMaybe
20:04:56 <NihilistDandy> @hoogle (??)
20:04:56 <lambdabot> keyword ??
20:04:58 <elliott> clearly by reasonable requests edwardk means *my* requests
20:04:58 <mikeplus64> i don't know where i got ~ for modify, but you can see it in some projects e.g. StateVar
20:05:12 <cmccann> which is handy because I also replace a lot of partial functions with ones returning Maybes :P
20:05:20 <`nand`> cmccann: that's.. actually fairly handy
20:05:32 <edwardk> (??) = flip in lens right now
20:05:38 <`nand`> cmccann: reminds me of C#'s Nullable stuff, except not built-in to the language
20:06:02 <edwardk> > over _1 ?? ("hello","world") $ length
20:06:03 <lambdabot>   Not in scope: `??'
20:06:03 <lambdabot>  Perhaps you meant one of these:
20:06:04 <lambdabot>    `^?' (imported from ...
20:06:06 <cmccann> `nand`, and with appropriate fixity to chain it in the obvious manner
20:06:07 <Fuuzetsu> A somewhat related question: Is there a way to have curl (Network.Curl) infer the file name on its own even on a redirect? wget --content-disposition or curl -J -O from the command line
20:06:13 <cmccann> and yes, it's a C#-ism
20:06:18 <edwardk> @let (??) = flip
20:06:19 <edwardk> > over _1 ?? ("hello","world") $ length
20:06:20 <lambdabot>  Defined.
20:06:21 <cmccann> I use C# in my day job
20:06:22 <lambdabot>   (5,"world")
20:06:27 <mikeplus64> edwardk: you'll never win the operator battle (operators are evil bikeshedding devices), lol
20:06:33 <edwardk> the ??'s tend to replace the operator in question
20:07:03 <edwardk> mikeplus64: i've won the battle. the library is written. people use it, and /ignore is a powerful weapon in my arsenal against complaints ;)
20:07:10 <`nand`> edwardk: interesting
20:07:11 <startling> :t flip fromMaybe
20:07:12 <lambdabot> Maybe c -> c -> c
20:07:21 <startling> oh, interesting
20:07:25 <cmccann> anyway, my (??) is exported by my modified Prelude so I have to import lens hiding edwardk's now :P
20:07:42 <`nand`> what does your modified Prelude do?
20:07:46 <edwardk> cmccann: i already moved it from ? =P
20:07:55 <startling> > let (??) = flip fromMaybe in lookup 'a' [('b', 12)] ?? 13
20:07:56 <lambdabot>   13
20:08:02 <cmccann> `nand`, changes around a bunch of stuff I don't like
20:08:08 <`nand`> that much was clear
20:08:23 <`nand`> (isn't that the point of every modified prelude?)
20:08:24 <cmccann> re-exports stuff like Control.Applicative by default, makes functions like head and tail return Maybes
20:08:35 <elliott> edwardk's ignore list must be like 100 people long
20:08:39 <elliott> and also have me on it at least three times
20:09:00 <cmccann> adds some of my favorite utility functions and whatnot, like (??) and (=<*) and (enumerate :: (Enum a, Bounded a) => [a])
20:09:01 <`nand`> cmccann: that actually gives me an idea; configure my editor to start out all blank .hs files with ‚Äòimport Control.Applicative‚Äô
20:09:15 <startling> `nand`: heh
20:09:17 <caseyjames> Hi, A question:  If a cabal package has dependencies that wont work on the target, what is the best way to go about working with pieces of it?  Do I 'cabal unpack' and then just copy the files to my project dir?
20:09:25 <startling> Control.Monad too
20:09:30 <edwardk> elliott: its usually only around 3-4 people.
20:09:34 <`nand`> import (..)
20:09:41 <edwardk> its not like dolio. i think he has half of irc on ignore.
20:09:59 <edwardk> not sure why he logs in. its not like he can understand what is going on
20:10:06 <startling> edwardk, how do you ignore a negative amount of people?
20:10:14 * cmccann uploaded an early version of his tweaked prelude to github a while back at https://github.com/isomorphism/Overture
20:10:23 <startling> > 3-4
20:10:25 <lambdabot>   -1
20:10:39 <edwardk> cmccann: so now we have overture, fugue, basic prelude, classy prelude, and lens
20:10:41 <`nand`> startling: it's not like he used the unambiguous subtraction sign
20:10:45 <cmccann> and then forgot to keep updating it as I fixed stupid oversights and mistakes
20:10:51 <`nand`> startling: there's actually like 5 different unicode characters for that symbol, depending on the context
20:10:54 <startling> edwardk: oh, I see. you ignore everyone *except* one person
20:10:56 <`nand`> including one for numerical ranges
20:11:08 <elliott> edwardk's ignore list: elliott, elliott, shachaf, shachaf
20:11:14 <cmccann> haha
20:11:14 <`nand`> but the ASCII - doesn't have any connotations afaik
20:11:26 <edwardk> elliott: only some days ;)
20:11:40 <edwardk> elliott: you guys still get through on commit messages though
20:11:48 <edwardk> so the filter is only a brief reprieve
20:12:12 <`nand`> I bet you there's some userscript that lets you filter their pull requests as well
20:12:13 <cmccann> but yeah, skimming the type signatures in https://github.com/isomorphism/Overture/blob/master/src/Overture/Data.hs will give you a pretty good idea of what I'm after :P
20:12:17 <elliott> git commit -am "Optimise indexed Zipper internals p.s. edwardk sucks"
20:12:34 <`nand`> cmccann: generalized everything?
20:12:47 <`nand`> well, it's not that bad
20:12:54 <cmccann> and less-partial functions and whatnot
20:13:10 <Fuuzetsu> Can someone with the ability to edit haskellwiki remedy the fact that this page http://www.haskell.org/haskellwiki/Network.Curl hosts examples written in Python?
20:13:11 <cmccann> pretty minor really, but enough that I get myself really confused if I try to do anything using the standard Prelude :D
20:13:19 <startling> man, I really wish () could be a synonym for mempty.
20:13:21 <startling> [] even.
20:13:22 <`nand`> (one can go much much worse in terms of overgeneralization)
20:13:35 <lispy> startling: you need idris
20:13:41 <johnw> startling: or ‚àÖ even :)
20:13:43 <lispy> startling: it supports this form of overloading
20:14:00 <`nand`> ‚Äòe‚Äô
20:14:02 <startling> lispy: I know! [] and :: in idris are great
20:14:17 <startling> and thence overloaded lists etc
20:14:41 <cmccann> ugh, I never even pushed the fix for the mistake in my type signature for length
20:14:48 <lispy> I asked edwinb if he thought the same trick would work in haskell, but it seemed to hinge on the way idris figures out the context of things.
20:15:06 <`nand`> cmccann: Integral instead of Num ?
20:15:10 <cmccann> yeah
20:15:23 <cmccann> wrong kind of variance
20:15:41 <lispy> (he seemed unsure and I decided that it must be harder in haskell)
20:15:58 * lispy thinks he should tell Oleg it's impossible
20:16:00 <cmccann> Integral is for contravariant position
20:16:36 <`nand`> isn't (++) mappend in Prelude now
20:16:39 <cmccann> no
20:16:45 <cmccann> and I refuse to accept that it won't be
20:16:50 <`nand`> oh
20:16:52 * cmccann shakes his fist
20:16:55 <`nand`> I've had that in .ghci so long I think it's standard
20:17:02 <cmccann> hahahaha
20:17:48 <cmccann> on the bright side, I don't need to reimplement readMaybe anymore
20:18:01 <lispy> Does anyone have an alternative prelude that is applicative and monoid happy?
20:18:01 <cmccann> I can just rename it to "read"
20:18:45 <`nand`> one thing no prelude will be able to fix is making applicative a superclass of monad
20:18:55 <cmccann> you can fix that if you want
20:19:02 <cmccann> just have to break compatibility with everything else
20:19:05 <cmccann> no big deal, right?
20:19:08 <`nand`> we've had superclass changes in GHC 7.6 and the world moved on, when are we going to get this?
20:20:02 <`nand`> probably more effort to single out all of the usages of ‚ÄòliftM‚Äô and ‚Äòap‚Äô that could be replaced by ‚Äòfmap‚Äô and <*>
20:20:18 * lispy isn't sure what all could be improved with a Prelude 2.0, the list seems long
20:20:39 <cmccann> step 1: remove Num and Enum entirely
20:20:40 <`nand`> cmccann: remove fail while we're at it?
20:20:41 <cmccann> also, remove fail
20:21:06 <elliott> Applicative => Monad
20:21:21 <lispy> improve Enum, Change Num into a Ring (fix the whole numeric type class heirarchy), add applicative and monoid, use IsString and import Data.Text and make it the default...
20:21:25 <`nand`> cmccann: what's your proposed alternative to Num and Enum?
20:22:09 <NihilistDandy> While you're at it, make it a Field
20:22:11 <elliott> strict string type by default :(
20:22:18 <cmccann> `nand`, split Num into more sensible fragments
20:22:36 <cmccann> Enum is a lost cause, it needs something completely different
20:22:52 <lispy> replace length with genericLength
20:23:31 <cmccann> but for Num, at least separate it into fromInteger, abs and signum, (+) and (*), (-) and negate
20:23:38 <cmccann> also, make fromInteger fromNatural instead
20:23:42 <cmccann> and have a Natural type
20:23:48 * `nand` .oO( http://hpaste.org/79239 )
20:23:49 <cmccann> because come ON seriously
20:24:08 <`nand`> cmccann: we would need some way of not alienating the [1,3 ..] syntax
20:24:36 <cmccann> `nand`, range syntax has something like three distinct semantic interpretations that Enum conflates
20:24:48 <NihilistDandy> `nand`: YES
20:24:52 <cmccann> which is part of why the instance for floats is such an abomination
20:24:53 <NihilistDandy> Magma makes it even better
20:25:11 <startling> I like the idea of getting rid of return, making Applicative a superclass of Monad, and using 'pure' everywhere.
20:25:12 <cmccann> and the Enum instance for () is just ridiculous beyond belief
20:25:25 <startling> > [()..()]
20:25:25 <`nand`> > [()..]
20:25:26 <lambdabot>   [()]
20:25:27 <lambdabot>   can't find file: L.hs
20:25:35 <cmccann> > succ ()
20:25:37 <lambdabot>   *Exception: Prelude.Enum.().succ: bad argument
20:25:39 <cmccann> > pred ()
20:25:40 <lambdabot>   *Exception: Prelude.Enum.().pred: bad argument
20:25:49 <`nand`> > minBound :: ()
20:25:50 <lambdabot>   ()
20:25:51 <startling> > enumFrumTo () ()
20:25:52 <lambdabot>   Not in scope: `enumFrumTo'
20:25:53 <lambdabot>  Perhaps you meant one of these:
20:25:53 <lambdabot>    `enumFromTo'...
20:25:53 <elliott> ugh, Magma
20:26:00 <startling> > enumFromTo () ()
20:26:02 <`nand`> doesn't that fall in line with the comment specifications of Enum/Bounded?
20:26:02 <lambdabot>   [()]
20:26:06 <NihilistDandy> > maxBound :: ()
20:26:08 <lambdabot>   ()
20:26:11 <`nand`> namely that succ maxBound and pred minBound should error
20:26:20 <`nand`> > succ (maxBound :: Int)
20:26:21 <lambdabot>   *Exception: Prelude.Enum.succ{Int}: tried to take `succ' of maxBound
20:26:25 <cmccann> `nand`, you mean the specification that adds no semantic content and just tells you when it should cause errors?
20:26:33 <cmccann> yes, that specification clearly improves the situation
20:26:34 <`nand`> cmccann: yes, exactly those
20:26:44 <startling> succ really needs to return a Maybe.
20:26:46 <`nand`> well, I'm just saying it's not the instances fault
20:26:51 <NihilistDandy> It's dumb, but in the technically correct way :D
20:27:01 <`nand`> but I guess that's not what you were implying
20:27:01 <cmccann> seriously, "how to cause errors" is about the only rule for Enum's behavior
20:27:06 <cmccann> and then only in terms of Bounded
20:27:19 <cmccann> `nand`, I am saying it is Enum's fault for being stupid
20:27:27 <cmccann> there is nothing an instance can do to fix that
20:27:27 <`nand`> right
20:27:47 <`nand`> I've never liked the interaction between two entirely unrelated typeclasses
20:28:09 <cmccann> it's particularly funny that Bounded and Ord have no relation
20:28:09 <lispy> ?check maxBound == minBound -- won't work now, but things used to default to (), so I bet it would have passed
20:28:11 <lambdabot>   Not in scope: `myquickcheck'
20:28:20 <`nand`> yeah
20:28:23 <`nand`> not even a superclass
20:28:41 <cmccann> also, floats have no bounded instance, despite having clearly defined minimum and maximum values, by specification
20:28:51 <startling> cmccann: ugh what
20:29:00 <cmccann> > maxBound :: Double
20:29:02 <lambdabot>   No instance for (GHC.Enum.Bounded GHC.Types.Double)
20:29:02 <lambdabot>    arising from a use o...
20:29:12 <`nand`> > succ (1/0)
20:29:14 <lambdabot>   Infinity
20:29:21 <`nand`> cmccann: that would go against specifications!1
20:29:51 <startling> > (1 / 0) :: Double
20:29:53 <lambdabot>   Infinity
20:30:02 <startling> > pred (1/0)
20:30:05 <lambdabot>   Infinity
20:30:07 <cmccann> you know I think I should probably go to bed. staying up all night complaining about floats and Enum is most likely unwise
20:30:09 <startling> I guess it just does - 1
20:30:10 <`nand`> > pred (-1/0)
20:30:11 <lambdabot>   -Infinity
20:30:27 <startling> > succ 1.0001
20:30:29 <lambdabot>   2.0000999999999998
20:30:32 <startling> haha
20:30:54 <`nand`> I still can't get my head over the fact that the successor of a double is (+1)
20:31:05 <cmccann> > [1.0, 1.2 .. 1.5]
20:31:06 <lambdabot>   [1.0,1.2,1.4,1.5999999999999999]
20:31:07 <startling> yeah. that's pretty ugly.
20:31:15 <cmccann> how about that one?
20:31:15 <`nand`> if we're enumerating all possible doubles, shouldn't the successor be something like the smallest representable number that is strictly higher?
20:31:16 <r00723r0> What does that mean?
20:31:26 <r00723r0> I see.
20:31:28 <startling> `nand`: that's what I've already thought too
20:31:31 <startling> *always
20:31:32 <Okasu> > 0.999999999999999999999999999 == 1
20:31:34 <lambdabot>   True
20:31:47 <startling> cmccann: hahaha
20:31:48 <cmccann> note that the range produced contains a value larger than what I specified as the end of the range
20:31:53 <`nand`> cmccann: that's a Double wart if you ask me, and not something inherent to Enum - the (+1) thing is
20:31:59 <cmccann> because the Enum instance for float is awesome
20:32:03 <`nand`> oh
20:32:06 <`nand`> I missed that
20:32:15 <`nand`> never mind what I just said
20:32:27 <startling> > [0.1..0.2]
20:32:28 <lambdabot>   [0.1]
20:32:31 <startling> ugh
20:32:40 <cmccann> > [1.1, 1.3 .. 1.6]
20:32:41 <lambdabot>   [1.1,1.3,1.5,1.7]
20:32:45 <cmccann> there, is that easier to read?
20:32:53 <startling> :S
20:32:55 <`nand`> > succ 1 :: CReal
20:32:56 <lambdabot>   *Exception: Cannot fromEnum CReal
20:33:03 <`nand`> interesting
20:33:13 <`nand`> what was that a superclass of again?
20:33:51 <`nand`> Num?
20:34:21 <startling> @src Num
20:34:21 <lambdabot> class  (Eq a, Show a) => Num a  where
20:34:22 <lambdabot>     (+), (-), (*)           :: a -> a -> a
20:34:22 <lambdabot>     negate, abs, signum     :: a -> a
20:34:22 <lambdabot>     fromInteger             :: Integer -> a
20:34:25 <startling> @src Enum
20:34:26 <lambdabot> class  Enum a   where
20:34:26 <lambdabot>     succ                     :: a -> a
20:34:26 <lambdabot>     pred                     :: a -> a
20:34:28 <lambdabot>     toEnum                   :: Int -> a
20:34:29 <lambdabot>     fromEnum                 :: a -> Int
20:34:31 <lambdabot> [3 @more lines]
20:34:37 <lispy> that's old
20:34:42 <lispy> Eq is no longer there
20:34:49 <`nand`> @src Real
20:34:49 <lambdabot> class  (Num a, Ord a) => Real a  where
20:34:49 <lambdabot>     toRational      ::  a -> Rational
20:35:04 <`nand`> oh
20:35:07 <`nand`> > [1..] :: CReal
20:35:09 <lambdabot>   Couldn't match expected type `Data.Number.CReal.CReal'
20:35:10 <lambdabot>              with ac...
20:35:11 <`nand`> err
20:35:14 <`nand`> > [1..] :: [CReal]
20:35:17 <startling> anyway, yeah, seems like different Enum instances have next to no semantic relation.
20:35:18 <lambdabot>   [1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0,10.0,11.0,12.0,13.0,14.0,15.0,16.0,17....
20:35:22 <startling> other than +/- 1 I guess.
20:35:26 <`nand`> that's why it provides Enum
20:35:35 <`nand`> odd that it has enumFrom and but not succ
20:36:01 <lispy> > [1,1.01 ..] :: [CReal]
20:36:02 <lambdabot>   [1.0,1.01,1.02,1.03,1.04,1.05,1.06,1.07,1.08,1.09,1.1,1.11,1.12,1.13,1.14,1...
20:36:35 <startling> anyway, I feel like there should just be a IsNumber typeclass (a la IsString) and maybe IsEnum
20:36:44 <`nand`> overloaded literals would be interesting
20:36:47 <`nand`> in general
20:36:51 <lispy> > enumFromToBy 1 maxBound 0.01
20:36:52 <lambdabot>   Not in scope: `enumFromToBy'
20:36:52 <lambdabot>  Perhaps you meant one of these:
20:36:52 <lambdabot>    `enumFromT...
20:37:01 <startling> seems like haskell as is likes to confuse syntactic meaning with semantic
20:37:01 <cmccann> > [1..] :: [Fixed E3]
20:37:03 <lambdabot>   [1.000,1.001,1.002,1.003,1.004,1.005,1.006,1.007,1.008,1.009,1.010,1.011,1....
20:37:09 * cmccann throws fuel on the fire
20:37:28 <`nand`> cmccann: now that I find to be more sane than Double et al
20:37:31 <lispy> `nand`: and IsBool (overload all the literals and data constructors!). I guess it makes things cumbersome.
20:37:48 <startling> lispy: ha.
20:37:50 <cmccann> `nand`, it would be more sane if it didn't conflict so badly with the instances for floats and Rational
20:37:57 <startling> overloading 'if' could be useful, I guess.
20:38:03 <`nand`> lispy: no, I really just mean integer literals, rational literals, string literals and character literals
20:38:19 <cmccann> rebindable syntax already lets you overload if, doesn't it?
20:38:24 <`nand`> yes
20:38:30 <startling> what would character literals be useful for?
20:38:35 <startling> cmccann: what's that?
20:38:44 <lispy> overloaded if would be great for DSLs, but maybe we be better of by being able to drop into mixfix regions?
20:38:45 <cmccann> startling, GHC language extension
20:38:47 <`nand`> startling: I'm not sure
20:38:57 <cmccann> {-# LANGUAGE RebindableSyntax #-}
20:38:57 <`nand`> startling: but the others can certainly make sense on their own
20:38:58 <lispy> oh you can rebind if?
20:39:02 <cmccann> yes
20:39:14 <lispy> I thought it was just for do-notation for some reason
20:39:14 <cmccann> as well as (>>=) and all that other fun stuff
20:39:27 <startling> cmccann: oh, neat
20:39:30 <cmccann> it also lets you replace fromInteger and whatnot
20:39:41 <startling> so it uses whatever >>= is local, rather than Prelude.>>=
20:39:51 <cmccann> you need OverloadedStrings to change string literals I think
20:39:53 <startling> yayyy unsanitary macros
20:40:17 <cmccann> startling, yep, you can even shadow (>>=) in a where clause and have local reinterpretation of do notation :D
20:41:34 <cmccann> sadly I don't think there's any way to overload list literals
20:41:47 <startling> cmccann: can you change halfway through with a let binding? :S
20:41:59 <cmccann> startling, that... you know I'm not sure
20:42:04 <cmccann> that's a horrible, terrifying idea
20:42:09 <startling> yeah srsly
20:42:18 <AfC> cmccann: there was a discussion on haskell-cafe about that a few months ago. Not sure if it led to a GHC hacker deciding to implement it. Purists were objecting on religious grounds.
20:42:28 <cmccann> pf.
20:42:42 <startling> this is basically what idris does
20:42:56 <startling> [1, 2, 3] desugars to "1 :: 2 :: 3 :: []"
20:43:18 <startling> which are interpreted as local and possibly-overloaded
20:43:34 <startling> [] desugars to Nil, too
20:44:07 <`nand`> startling: try it
20:45:59 <cmccann> yes
20:46:06 <cmccann> you can replace (>>=) halfway through a do block
20:46:09 <cmccann> this is terrible
20:46:13 <lispy> someone got me "The Haskell Road to Logic, Maths and Programming" and I'm hoping to try out the exercises with Idris/Agda instead of Haskell considering I feel like I already know Haskell.
20:46:14 <cmccann> what the actual fuck
20:46:25 <lispy> no idea if it makes sense to do that yet :)
20:46:32 * cmccann boggles
20:46:50 <`nand`> doesn't seem like you can rebind list or tuple syntax
20:47:03 <lispy> cmccann: rebindable syntax isn't a feature people normally use
20:47:19 <`nand`> cmccann: how long until somebody ends up using this in some obfuscated haskell contest?
20:47:24 <lispy> without that extension I wouldn't expect a local definition to override
20:47:36 <cmccann> well, of course it needs rebindable syntax
20:48:13 <`nand`> lispy: is that the one that starts with ‚ÄúHaskell is a member of the lisp family‚Äù?
20:48:29 <lispy> `nand`: yeah, that gave me a rise too
20:48:37 <lispy> o rly?
20:48:37 <NihilistDandy> lispy: You're starting to get me into the idea of Idris. I already like Haskell and Agda is fun to play with. Idris is looking like a neat language.
20:49:05 <lispy> NihilistDandy: it's really quite nice but also quite new. Expect lots of things to be immature.
20:49:19 <lispy> manage your expectaton and you should be fine :)
20:49:36 <cmccann> ok, after the startling revelation that startling's idea actually works I think I need to call it a night
20:49:40 <NihilistDandy> lispy: That's exactly how I treat rust. Pull down new sources every couple of weeks, rebuild and see what's broken
20:50:27 <`nand`> NihilistDandy: that's how I treat lens, except I do it every couple of days
20:50:41 <lispy> the other book I got for christmas (and the one I want to finish before starting the haskell road) is nate silver's book, "the signal and the noise"
20:50:43 <NihilistDandy> haha
20:51:14 <`nand`> lispy: is that a book about signal processing circuitry or something?
20:51:26 <cmccann> `nand`, I take it you're not the sort to stay on the cutting edge of lens technology then
20:51:40 <`nand`> cmccann: what do you mean?
20:51:41 <lispy> `nand`: no, nate silver is the guy that built fivethirtyeight.com the election predicition website
20:52:03 <lispy> `nand`: before that he improved the state of the art in baseball prediction
20:52:07 <cmccann> `nand`, only every couple days? completely out of date!
20:52:14 <`nand`> cmccann: ah; yes, that is unfortunate
20:52:51 <`nand`> cmccann: well, I *do* pay attention to the channel (admittedly, it's the only thing I do), so I'll catch any breaking news in time to git pull
20:53:03 * cmccann notes that nate silver was sorta following in the footsteps of another election prediction site which is run by a computer science professor
20:53:30 <startling> heh, crashed ghci (and thus emacs and erc) with the RebindableSyntax stuff
20:53:43 <cmccann> startling, your horrible idea works though
20:54:04 <`nand`> what, emacs doesn't separate buffers into independent processes?
20:54:07 <cmccann> you can replace (>>=) and (>>) halfway through a do block
20:54:29 <startling> cmccann: I think something else is going on, then: https://gist.github.com/ffb1d6aa5dadcc369f05
20:55:03 <lispy> cmccann: that wouldn't suprise me. He mentions in the book that he felt the idea was 'obvious' and cites other people using similar techniques that were more successful than anything in the public eye. I'm starting to relaized that nate silver is pretty good at getting attention.
20:55:38 <lispy> cmccann: But, his ideas have merit none the less.
20:55:49 <cmccann> lispy, the other site (which I think predates most similar stuff) is electoral-vote.com
20:56:32 <startling> oh, maybe my emacs setup is just broken
20:56:52 <startling> (seems like it's hanging on getline? weird)
20:59:31 <startling> cmccann: anyway, I wonder what you could do that's *really* crazy
20:59:43 <cmccann> not all that much to be honest
20:59:49 <cmccann> it's all syntactic sugar
21:00:30 <`nand`> applicative do notation!
21:01:03 <cmccann> rebinding the syntax is fun though
21:01:20 <cmccann> changing if expressions can be handy, and there's all that indexed monad stuff
21:01:27 <NihilistDandy> startling: Once I wrapped my head around that, it was pretty neat.
21:01:29 * `nand` can't see a use for changing if expressions
21:01:38 <`nand`> hey, how do multi-line ifs desugar under RebindableSyntax?
21:01:43 <cmccann> `nand`, for EDSLs?
21:01:48 <`nand`> cmccann: oh, that makes sense
21:01:49 <startling> cmccann: I wonder whether it's lexically-scoped
21:02:05 <`nand`> startling: you mean the do.. let (>>=) stuff?
21:02:10 <cmccann> startling, I would imagine it's scoped however what it desugars to is scoped
21:02:15 <startling> Can I write a thing that switches the definition of >>= every other iteration?
21:02:19 <startling> cmccann: yeah.
21:02:23 <startling> `nand`: yeah.
21:02:35 <startling> hehe, I could use state.
21:02:38 <`nand`> it desugars to a >> let x = y in b
21:02:44 <cmccann> yeah
21:02:49 <`nand`> @undo do { a; let x = y; b }
21:02:50 <lambdabot>  Parse error at "}" (column 22)
21:02:54 <`nand`> useless thing
21:03:33 <lispy> you probably already thought of this, but you could actually do something like do { (>>=) <- get; ... }
21:03:39 <cmccann> bwahahahaha
21:03:43 <startling> lispy: oh god
21:03:43 <`nand`> lispy: haha
21:04:04 <lispy> > do { (>>=) <- return const; }
21:04:06 <lambdabot>   The last statement in a 'do' block must be an expression
21:04:06 <lambdabot>    >>= <- return c...
21:04:15 <lispy> > do { (>>=) <- return const; 1 >>= 2 }
21:04:16 <lambdabot>   No instance for (GHC.Num.Num (m0 b0))
21:04:17 <lambdabot>    arising from a use of `e_112'
21:04:17 <lambdabot>  Pos...
21:04:26 <lispy> > do { (>>=) <- return const; return (1 >>= 2) }
21:04:28 <lambdabot>   No instance for (GHC.Show.Show (m0 b0))
21:04:28 <lambdabot>    arising from a use of `M96008662...
21:04:45 <roconnor> lispy: oh god
21:04:53 <roconnor> what does the haskell report say about that?
21:04:53 <flebron> "lisp"y indeed
21:05:06 <cmccann> the haskell report says anything about -XRebindableSyntax?
21:05:13 <`nand`> no, just the GHC docs
21:05:21 <`nand`> it's not haskell2010 or anything, iirc
21:05:33 <roconnor> `nand`: how litterally do you take desugaring of do expressions?
21:05:42 <lispy> oh, and rebindable syntax + rec do + binding (>>=) inside the do-notation should be pure hilarity
21:05:43 <roconnor> see, this is why Harper says we need formal semantics
21:05:56 <`nand`> RebindableSyntax makes it quite clear that it's a literal desugaring
21:06:02 <startling> lispy: "hilarity"
21:06:05 <roconnor> forget RebindableSyntax
21:06:09 <roconnor> just plain Haskell 2010
21:06:10 <NihilistDandy> roconnor: I would think just shutting down those smug ML weenies would be enough reason~
21:06:28 <elliott> roconnor: IIRC desugaring rules say that they use the definitions from Prelude no matter what
21:06:31 <lispy> roconnor: we have a start of that in OTT for core
21:06:45 <`nand`> haskell2010 defines them as being Prelude.Monad's (>>=) etc.
21:06:48 <cmccann> elliott, I believe so
21:06:50 <roconnor> wher
21:06:50 <lispy> roconnor: so if you had a formal semantics for desugaring to core, you're a good chunk of the way to what you want
21:06:52 <roconnor> whew
21:07:16 <cmccann> if nothing else I think the docs for RebindableSyntax imply that the report expects Prelude.foo to be used no matter what's in scope
21:07:19 <elliott> roconnor: whew??? think of all the possibilities wasted
21:07:36 <lispy> > do { (>>=) <- return const; return (1 >>= 2) } :: Maybe INt
21:07:37 <lambdabot>   Not in scope: type constructor or class `INt'
21:07:38 <lambdabot>  Perhaps you meant `Int' (imp...
21:07:38 <lispy> > do { (>>=) <- return const; return (1 >>= 2) } :: Maybe Int
21:07:40 <lambdabot>   Just 1
21:07:52 <`nand`> ‚Äúthe functions >>, >>=, and fail are operations in the class Monad, as defined in the Prelude‚Äù -Haskell2010
21:08:12 <lispy> that example I just gave is confusing, but it's precisely what I Would expect
21:09:11 <`nand`> @undo do { (>>=) <- return const; return (1 >>= 2) } -- oh no, this breaks
21:09:11 <lambdabot> return const >>= \ (>>=) -> return (1 >>= 2)
21:09:20 <`nand`> actually that particular example doesn't even
21:09:26 <cmccann> lispy, right, you can shadow the name under normal circumstances it just doesn't change do notation
21:09:45 <`nand`> clearly @undo needs to be revised to tack on Prelude. everywhere
21:10:12 <cmccann> > let 1 + 1 = 3 in 1 + 1 -- just like you can do this
21:10:13 <lambdabot>   3
21:10:21 * lispy nods
21:11:01 <`nand`> @undo do { Just y <- x; z }
21:11:01 <lambdabot> x >>= \ a -> case a of { Just y -> z; _ -> fail ""}
21:11:12 <`nand`> oh, it does that correctly; great
21:11:42 <flebron> undo was confused by your let x = y line
21:11:53 <otters> > let 1 + 1 = 3 in 2 + 1
21:11:55 <lambdabot>   *Exception: <interactive>:3:5-13: Non-exhaustive patterns in function +
21:12:43 <`nand`> I remember seeing the 1+1 = 3 thing for the first time. The guy who demonstrated it at the time neglected to show any of the other cases :)
21:13:09 <`nand`> they make it significantly less magical, unfortunately
21:14:55 <mikeplus64> is there an error :: ByteString -> a or similar? (that isn't just like error = Prelude.error . pack)
21:14:59 <cmccann> "fix error" will always be magical though
21:16:01 <`nand`> > fix breakage
21:16:03 <lambdabot>   "No. No. No. No. No. No. No. No. No. No. No. No. No. No. No. No. No. No. No...
21:37:15 <NihilistDandy> lispy: You wouldn't have a copy of idris-tutorial.pdf, would you? The St. Andrews page seems to be down
21:40:19 <NihilistDandy> Oh, nevermind. It's on github, as well
21:42:40 <lispy> NihilistDandy: the only copy I have is out of date and on my kindle. But it sounds like you found a copy.
21:43:04 <NihilistDandy> lispy: https://github.com/edwinb/Idris-dev/blob/master/tutorial/idris-tutorial.pdf
21:43:08 <NihilistDandy> Yup.
21:43:45 <Heather> Hello
21:43:51 <NihilistDandy> Hello
21:43:57 <Heather> how mass mask in haskell )
21:44:02 <Heather> e.g. /* */ in C
21:44:11 <mikeplus64> {- -}
21:44:15 <Heather> thank you
21:45:40 <lispy> Heather: we call that a multi-line comment
21:46:03 <Heather> lispy: ok :)
21:47:00 <Heather> I need more clay examples :(
21:47:10 <lispy> clay examples?
21:50:43 <Heather> lispy: haskell to css
21:50:47 <Heather> lispy: alike sass
21:50:55 <Heather> lispy: but on haskell
21:51:09 <mikeplus64> Heather: there are a number of libraries for it
21:51:11 <Heather> lispy: trying to switch sass files to clay
21:51:11 <mikeplus64> @hoogle css
21:51:12 <lambdabot> System.Posix.Types data CSsize
21:51:12 <lambdabot> package css
21:51:12 <lambdabot> package css-text
21:51:35 <mikeplus64> Heather: oh, didn't realise you meant withclay
21:54:17 <lispy> Heather: you already found these pages? http://sebastiaanvisser.github.com/clay/ http://hackage.haskell.org/packages/archive/clay/0.0.1/doc/html/Clay.html
21:55:50 <Heather> lispy: yes
21:56:02 <Heather> lispy: currently stuck with font-family
21:56:44 * hackagebot Win32-notify 0.3 - A binding to part of the Win32 library for file notification  http://hackage.haskell.org/package/Win32-notify-0.3 (MarkDittmer)
21:56:46 * hackagebot fsnotify 0.0.5 - Cross platform library for file creation, modification,  and deletion notification.  http://hackage.haskell.org/package/fsnotify-0.0.5 (MarkDittmer)
21:57:22 <Heather> lispy: fontFamily :: [Literal] -> Css
21:57:31 <Heather> lispy: what is Literal?
21:57:50 <mikeplus64> Heather: you can click 'Literal' on the page that says that
21:57:51 <Heather> lispy: just string?
21:58:20 <mikeplus64> Heather: newtype Literal = Literal Text, so it's just a wrapper around Text (so yes, a string)
21:59:00 <Heather> mikeplus64: and [] means array of it, right? :)
21:59:14 <lispy> Heather: yeah, it's a string and you set it like you set the other properties (which I think means you say, value "MyFavoriteFont")
21:59:18 <mikeplus64> Heather: list of it, yeah
21:59:51 <Heather> what is the easy way to declare list :)
21:59:55 <lispy> if value "MyFavoriteFont" doesn't work, you may need something like value (pack "MyFavoriteFont")
22:00:13 <lispy> > [1,2,3] -- Heather, a three element list example
22:00:15 <lambdabot>   [1,2,3]
22:00:28 <mikeplus64> @where lyah
22:00:29 <lambdabot> http://www.learnyouahaskell.com/
22:00:40 <mikeplus64> ^ heather perhaps you should read the first chapter of this to get the syntax a bit
22:01:22 <Heather> https://gist.github.com/4394936
22:01:29 <mikeplus64> i mean the first few chapters apparently
22:02:02 <Heather> mikeplus64: I was trying to use this but there error message appears
22:02:04 <mikeplus64> Heather: add {-# LANGUAGE OverloadedStrings #-} to the top of the file
22:02:37 <Heather> mikeplus64: it helps \o/
22:02:39 <sw2wolf> @where hackage
22:02:39 <lambdabot> <http://hackage.haskell.org/package/>, also see `revdeps'
22:07:49 <b__> purely out of curiosity, not because I want to do so in production code, but is there a sensible way of writing this pointfree? `f x y = g a x y || h a x y`
22:08:13 <b__> @pl f x y = g a x y || h a x y
22:08:14 <lambdabot> f = ap (ap . ((||) .) . g a) (h a)
22:08:49 <`nand`> a first step would be f x = liftM2 (||) (g a x) (h a x)
22:09:03 <b__> I'd expect something this f = magic (||) (g a) (h a) to be possible
22:09:29 <`nand`> so liftM2 (liftM2 (||)) (g a) (h a) should work
22:09:40 <lispy> the Reader instance for ((->) r) might be useful here
22:09:49 <lispy> esp., join
22:09:54 <b__> or for a similar function f x y = g a x y || g b x y
22:09:59 <`nand`> > let magic = liftM2 . liftM2 in magic (||) (g a) (h a) x y
22:10:01 <lambdabot>   No instance for (Debug.SimpleReflect.Expr.FromExpr GHC.Types.Bool)
22:10:01 <lambdabot>    arisi...
22:10:03 <`nand`> bleh
22:10:05 <`nand`> of course
22:10:12 <`nand`> > let magic = liftM2 . liftM2 in magic (+) (g a) (h a) x y
22:10:13 <lambdabot>   Ambiguous type variable `a0' in the constraints:
22:10:13 <lambdabot>    (GHC.Num.Num a0)
22:10:14 <lambdabot>      a...
22:10:27 <ion> liftA2
22:10:44 <lispy> > join (*) 3
22:10:46 <lambdabot>   9
22:11:03 <ion> All liftM2 does is remind us about the bad type class structure. :-P
22:11:23 <mikeplus64> ion: how's that?
22:11:42 <`nand`> because liftM2 and liftA2 should be the same
22:11:52 <`nand`> but in practice, the latter pulls in another constraint
22:11:53 <b__> @pl f x y = g a x y || g b x y
22:11:54 <lambdabot> f = ap (ap . ((||) .) . g a) (g b)
22:12:08 <ion> Well, either one can pull in another constraint depending on what you‚Äôre doing.
22:12:19 <lispy> @redo  ap (ap . ((||) .) . g a) (g b)
22:12:19 <lambdabot> Maybe you meant: do read todo undo
22:12:25 <lispy> @undo  ap (ap . ((||) .) . g a) (g b)
22:12:26 <lambdabot> ap (ap . ((||) .) . g a) (g b)
22:12:30 <ion> unpl
22:12:33 <b__> @unpl f x y = g a x y || g b x y
22:12:33 <lambdabot> f x y = (g a x y) || (g b x y)
22:12:40 <b__> erm
22:12:47 <lispy> I was actually hoping for a command that would translate those aps into do-notation
22:13:08 <b__> @unpl f = ap (ap . ((||) .) . g a) (g b)
22:13:09 <lambdabot> f = (\ m r -> (\ y -> (||) (g a m y)) >>= \ o -> r >>= \ n -> return (o n)) >>= \ e -> (g b) >>= \ d -> return (e d)
22:13:16 <b__> haha well there you go =[
22:13:23 <lispy> hah, nice
22:13:28 <`nand`> great
22:13:33 <`nand`> now just pipe that into red
22:13:35 <`nand`> oh
22:13:35 <lispy> so easy to read now :)
22:13:37 <`nand`> we don't have redo, right
22:13:44 <dolio> @do x >>= f
22:13:45 <lambdabot> do { a <- x; f a}
22:13:47 <b__> @pl f = (\ m r -> (\ y -> (||) (g a m y)) >>= \ o -> r >>= \ n -> return (o n)) >>= \ e -> (g b) >>= \ d -> return (e d)
22:13:48 <lambdabot> f = (g b >>=) . (return .) =<< (. ((. (return .)) . (>>=))) . (>>=) . ((||) .) . g a
22:13:52 <b__> ok nvm hahahah
22:13:58 <`nand`> aha!
22:14:10 <`nand`> @do (\ m r -> (\ y -> (||) (g a m y)) >>= \ o -> r >>= \ n -> return (o n)) >>= \ e -> (g b) >>= \ d -> return (e d)
22:14:10 <lambdabot> do { e <- (\ m r -> do { o <- (\ y -> (||) (g a m y)); n <- r; return (o n)}); d <- (g b); return (e d)}
22:14:12 <lispy> pl is notorious for not understanding infix
22:14:34 <`nand`> there you do, lispy
22:14:42 <rwbarton> all is clear now
22:14:42 <`nand`> s/do/go/
22:14:43 <b__> ok once more then I'll stop
22:14:49 <b__> @unpl f = (g b >>=) . (return .) =<< (. ((. (return .)) . (>>=))) . (>>=) . ((||) .) . g a
22:14:50 <lambdabot> f l = (g b) >>= (((\ h ag -> h (\ aj -> ag >>= \ am -> return (aj am))) >>= \ d ad -> return (d ad)) ((>>=) (\ aq -> (||) (g a l aq))))
22:15:13 <lispy> well, I'm so glad we could elucidate the solution ;)
22:15:32 <b__> I'll just stick to `f x y = g a x y || g b x y` ;]
22:16:56 <sw2wolf> b__: then by which it choose g a x y or g b x y ?
22:17:21 <sw2wolf> :t liftA2
22:17:22 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
22:17:38 <mikeplus64> is it reasonable to use lazy Text/ByteStrings not for lazy IO but for potentially cheaper updates/insertions/deletions to portions of text?
22:19:00 <b__> the actual function is `(@==) :: String -> HTML -> Bool`, `x @== xs = matchAttr "src" x xs || matchAttr "href" x xs` (for the gaxy gbxy example)
22:19:39 <mikeplus64> i mean, an insertion/deletion/update to strict Text will copy the whole thing, but with lazy Text might only copy the chunk it needs to and use the other chunks from before updating it
22:19:46 <mikeplus64> (does that happen in reality?)
22:19:54 <b__> so that it works for a's, img's, links etc
22:20:19 <b__> I have no real need to write it pointfree but was just curious
22:21:13 <sw2wolf> pattern match is enough ?
22:22:01 <b__> I could, but don't want to restrict it to known tags
22:22:47 <b__> in practice this works better because sometimes js API's require weird use of attributes
22:23:14 <b__> in which case I need that function to be pretty liberal
22:23:21 <Nereid> hooray for RebindableSyntax.
22:24:03 <b__> Nereid: aimed at me?
22:24:10 <Nereid> aimed at no one
22:24:32 <b__> okay, but it did made me google it and that's interesting =]
22:24:44 <b__> make*
22:24:55 <mikeplus64> Nereid: does RebindableSyntax also rebind fromString (or some kind of magical Addr# -> thing function?)?
22:25:14 <Nereid> I don't know.
22:27:09 <Jafet> mikeplus64: -Xzibit
22:28:54 <mikeplus64> wat
22:29:03 <Heather> any ideas if I can somehow use multiple arguments alike [htm, body ... etc https://gist.github.com/4395066
22:30:57 <Nereid> Heather: ?
22:31:13 <mikeplus64> Heather: i think you can use html (body <> html <> ...)
22:31:21 <mikeplus64> if that's what you mean
22:31:23 <Heather> Nereid: in pattern matching I need some or ...
22:31:38 <Heather> body or html etc ...
22:31:43 <Heather> I need a rule for them all
22:31:57 <Nereid> I don't understand what you're trying to do.
22:32:22 <mikeplus64> Heather: yeah, use <>
22:32:36 <Heather> mikeplus64: why? is it logical 'or' ? :S
22:33:00 <Heather> mikeplus64: Not in scope: `<>' :)
22:33:10 <Nereid> it's mappend
22:33:14 <sclv> ?hoogle (<>)
22:33:14 <lambdabot> Language.Haskell.TH.PprLib (<>) :: Doc -> Doc -> Doc
22:33:14 <lambdabot> Text.PrettyPrint.HughesPJ (<>) :: Doc -> Doc -> Doc
22:33:15 <lambdabot> Text.PrettyPrint (<>) :: Doc -> Doc -> Doc
22:33:17 <Nereid> or
22:33:19 <sclv> grr
22:33:23 <mikeplus64> Heather: import Data.Monoid
22:33:25 <sclv> its from Data.Monoid
22:33:49 <Heather> what is Control Monoid for then?
22:33:57 <sclv> ?ty (<>)
22:33:58 <mikeplus64> there is no Control.Monoid
22:33:59 <lambdabot> Monoid m => m -> m -> m
22:34:10 <sclv> a monoid is just something with mempty and mappend
22:34:15 <sclv> such that mappend associates
22:34:25 <Heather> this works... mikeplus64 thank you
22:34:27 <sclv> its anything that has a way of "sticking it together" with another thing
22:44:09 <Heather> mikeplus64: what if I have an list [body, html]
22:44:23 <Heather> mikeplus64: and want to make them all sticking together
22:45:01 <Heather> mikeplus64: and use them in matching alike everything ? do
22:46:12 <mikeplus64> i don't follow
22:47:54 <Heather> mikeplus64: so, like if I had "do body <> html? do" and now I have and everyhing = [body, html] and I want something alike "do everything.xxx ? do"
22:48:28 <sclv> mconcat
22:48:31 <sclv> ?ty mconcatt
22:48:32 <lambdabot>     Not in scope: `mconcatt'
22:48:32 <lambdabot>     Perhaps you meant one of these:
22:48:33 <lambdabot>       `mconcat' (imported from Data.Monoid),
22:48:34 <sclv> ?ty mconcatt
22:48:36 <lambdabot>     Not in scope: `mconcatt'
22:48:36 <lambdabot>     Perhaps you meant one of these:
22:48:36 <lambdabot>       `mconcat' (imported from Data.Monoid),
22:48:38 <sclv> ?ty mconcat
22:48:39 <lambdabot> Monoid a => [a] -> a
22:48:42 <sclv> there we go
22:48:53 <sclv> it just applies <> to everything in the list in sequence
22:49:07 <Heather> that's what I need though
22:49:11 <sclv> so "do mconcat everything"
22:49:25 <sclv> or even everything = mconcat [body, html]
22:50:12 <Heather> drops site.hs: Selector is a semigroup
22:50:33 <sclv> hmm, one sec
22:50:56 <Heather> there is ** also
22:51:04 <Heather> is there way to ** everything ? )
22:51:35 <Heather> [a] -> a1 ** a2 ** a3
22:52:14 <sw2wolf> :t ap
22:52:15 <lambdabot> Monad m => m (a -> b) -> m a -> m b
22:52:43 <sclv> you can just write the folds yourself
22:52:46 <sclv> ?ty fold1
22:52:48 <lambdabot>     Not in scope: `fold1'
22:52:48 <lambdabot>     Perhaps you meant one of these:
22:52:48 <lambdabot>       `foldl1' (imported from Data.List),
22:52:53 <sclv> ?ty foldl1
22:52:54 <lambdabot> (a -> a -> a) -> [a] -> a
22:53:03 <sclv> so if you import Data.List
22:53:09 <lightquake> can someone summarize yampa vs reactive-banana vs netwire vs the other FRP libraries?
22:53:28 <sclv> you can get foldl1, which will then lift any binary operator into a function that collapses a list
22:53:29 <mikeplus64> lightquake: different spelling (ok i'll show myself out)
22:53:37 <lightquake> dohohoho
22:53:37 <sw2wolf> @wn reactive
22:53:38 <lambdabot> *** "reactive" wn "WordNet (r) 3.0 (2006)"
22:53:38 <lambdabot> reactive
22:53:38 <lambdabot>     adj 1: participating readily in reactions; "sodium is a reactive
22:53:38 <lambdabot>            metal"; "free radicals are very reactive" [ant:
22:53:38 <lambdabot>            {unreactive}]
22:53:39 <sclv> so you can write foldl1 (<>) to collapse a list with <>
22:53:40 <lambdabot> [3 @more lines]
22:53:51 <NemesisD> is there a way i can suppress the "user interrupt" and "ExitFailure 1" messages for SIGINT?
22:53:52 <sclv> and foldl1 (**) to collapse a list with **
22:53:53 <sclv> etc
22:54:06 <NemesisD> i want a sigINT to quietly exit the program
22:54:07 <sclv> NemesisD: you can override with your own signal handlers
22:54:28 <sclv> lightquake: there are a bunch of responses to that question on stackoverflow
22:54:31 <NihilistDandy> lightquake: http://stackoverflow.com/questions/13341937/whats-the-status-of-current-functional-reactive-programming-implementations
22:54:42 <sclv> there, for example :-P
22:54:48 <NihilistDandy> lightquake: http://stackoverflow.com/questions/10000074/which-frp-package-to-choose
22:54:57 <NemesisD> sclv: i installed a handler like: blockSignals reservedSignals; installHandler sigINT (Catch exitSuccess) Nothing. it never actualy exits
22:54:57 <NihilistDandy> Some inquiry along those lines
22:54:58 * lightquake follows the pointers
22:57:24 <Moggle> Question: are foldrs less efficient than foldls?
22:57:44 <Moggle> The answer seems to be YES because the foldr has to do a whole traversal of the list before it can start
22:57:54 <Moggle> But perhaps there are clever optimizations?
22:58:37 <NihilistDandy> Moggle: foldl'
22:58:51 <Moggle> Is strict!
22:59:04 <edwardk> Moggle: that 'whole traversal' story is backwards. foldl needs to reasociate the list, before you get a s ingle answer out of it.
22:59:04 <Moggle> So perhaps it is better to say foldr' is less efficient than foldl'?
22:59:33 <NihilistDandy> @type foldr'
22:59:35 <lambdabot>     Not in scope: foldr'
22:59:35 <lambdabot>     Perhaps you meant one of these:
22:59:35 <lambdabot>       BS.foldr' (imported from Data.ByteString),
22:59:40 <simpson> @src foldr
22:59:40 <lambdabot> foldr f z []     = z
22:59:40 <sclv> there is no foldr'
22:59:40 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
22:59:42 <edwardk> foldl' is sometimes nicer when you are producing a strict result.
22:59:42 <NihilistDandy> I didn't even know that existed
22:59:51 <Moggle> edwardk: I am confused, isn't the head 5 in  5:4:3:2:1:[]
23:00:00 <Moggle> and therefore foldl can start going through the list _at_ 5
23:00:06 <Moggle> therefore making foldl the more efficient choice?
23:00:11 <edwardk> but in almost all other cases you want foldr in a lazy lanuguage
23:00:26 <mikeplus64> @src foldl
23:00:26 <lambdabot> foldl f z []     = z
23:00:27 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
23:00:56 <edwardk> Moggle: _it_ starts. you don't get the answert until its done. you're thinking strictly
23:01:15 <Moggle> edwardk: oh dear
23:01:16 <edwardk> what matters is the productivity of the result, not the well-foundedness of your recursion
23:01:37 <mikeplus64> Moggle: so the problem with foldl is that because of laziness nothing is given a chance to evaluate before the fold ends -- where foldl' comes in
23:01:46 <mikeplus64> @src foldl'
23:01:47 <lambdabot> foldl' f a []     = a
23:01:47 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
23:02:12 <Moggle> mikeplus64: so it _is_ correct to say that foldl' is more efficient than foldr'?
23:02:48 <simpson> Moggle: Look at how foldr's iteration works. The accumulating function could exit early and has control of the recursion.
23:03:14 <mikeplus64> Moggle: if you mean foldr (there is no foldr') for a lot of cases yeah, but not always, e.g. when the fold "ends early", which can't happen with foldl'
23:03:25 <mikeplus64> ie what simpson said
23:03:42 <sclv> NemesisD: ctrl c should throw a user interrupt exception in ghc these days
23:03:48 <sclv> so you can just catch that exception?
23:03:50 <edwardk> Moggle: lets try this again
23:03:52 <edwardk> > foldl' (flip (:)) [] [1..]
23:04:00 <lambdabot>   mueval: ExitFailure 1
23:04:00 <lambdabot>  mueval: Prelude.undefined
23:04:15 <edwardk> give foldl' an inifnite list and you cannot get an answer out of it
23:04:31 <edwardk> nothing, it spins forever forcing more and more of the list
23:04:35 <sclv> NemesisD: also, you can only call exit from the main thread
23:04:37 <edwardk> and you get nothing in return
23:04:47 <Nereid> (likewise for foldl)
23:04:51 <edwardk> > foldr (:) [] [1..]
23:04:53 <Moggle> edwardk: well yeah but that's why you don't fold an infinite list unless I'm missing something about fold
23:04:56 <lambdabot>   mueval-core: Time limit exceeded
23:04:58 <edwardk> > foldr (:) [] [1..]
23:05:00 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
23:05:11 <edwardk> look an infinite fold.
23:05:23 <sclv> more info: http://hackage.haskell.org/trac/ghc/ticket/2301
23:05:24 <edwardk> it works _fine_ to fold an infinite list in a lazy language
23:05:30 <Moggle> edwardk: huh, what, it seems I misunderstand foldr
23:05:41 <Moggle> edwardk: if you can exit early, which I don't understand
23:05:43 <edwardk> > foldr (\x y -> x : x : y) [] [1..]
23:05:45 <lambdabot>   [1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,14,14,15,15,16...
23:06:13 <edwardk> Moggle: the problem is your intuition for this is coming from a strict setting, everything is backwards here
23:06:13 <Nereid> @src foldr
23:06:14 <lambdabot> foldr f z []     = z
23:06:14 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
23:06:39 <Nereid> in the recursive case, foldr f z xs may not ever have to be evaluated
23:06:46 <edwardk> foldr (:) [] [1..]   does no work on its own, until forced
23:07:00 <edwardk> > const 1 (foldr (:) [] [1..])
23:07:02 <lambdabot>   1
23:07:18 <edwardk> we didn't look at the output, it never got computed, right?
23:07:25 <simpson> foldr might *associate* to the right, but it does its work by deconstructing the list, which is left-to-right.
23:07:28 <edwardk> thats the point of laziness by default
23:07:34 <Moggle> edwardk: huh, never even though about const being like that
23:07:34 <edwardk> but it has a lot of insidious consequences
23:08:02 <edwardk> everything in haskell has been turned around and woks in this sort of 'demand-driven' mode
23:08:16 <edwardk> you can grab at infinite lists as long as you only eat a finite part of them
23:08:18 <Jafet> @wn insidious
23:08:19 <lambdabot> *** "insidious" wn "WordNet (r) 3.0 (2006)"
23:08:20 <lambdabot> insidious
23:08:20 <lambdabot>     adj 1: beguiling but harmful; "insidious pleasures"
23:08:20 <lambdabot>     2: intended to entrap
23:08:20 <lambdabot>     3: working or spreading in a hidden and usually injurious way;
23:08:21 <lambdabot>        "glaucoma is an insidious disease"; "a subtle poison" [syn:
23:08:23 <lambdabot>        {insidious}, {pernicious}, {subtle}]
23:08:37 <Jafet> Oh ok, you did use the word correctly
23:08:38 <lpsmith> Ok,  if I have an FFI interface that can cause a process to dump core if used incorrectly,   but it respects type safety and referential transparency etc,   can I call it {-# Trustworthy #-}?
23:08:45 <edwardk> foldr can give results so long as the amount of work it takes to get 'to the next constructor in the output' takes only finite amount of time.
23:08:56 <edwardk> its _corecursion_ not recursion
23:09:10 <edwardk> so you don't even need a base case
23:09:13 <Nisstyre> edwardk: agreed, people commonly mistake corecursion as recursion
23:09:22 <Moggle> @src foldr
23:09:22 <Nisstyre> e.g. recursive acronyms are really corecursive acronyms
23:09:23 <lambdabot> foldr f z []     = z
23:09:23 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
23:09:36 <edwardk> so lets look at that src for a sec
23:09:46 <Moggle> hmm, I *was* very mistaken about foldr
23:09:52 <Moggle> seeing the definition like that clears up a lot
23:10:04 <Nereid> > foldr const 8 [1..]
23:10:06 <lambdabot>   1
23:10:08 <Moggle> i thought foldr f = foldl f . reverse
23:10:16 <mikeplus64> lpsmith: a good idea is to make a wrapper that won't explode with incorrect input
23:10:19 <Nisstyre> Moggle: I think if foldr was defined iteratively "foldr const a as" would not just return a
23:10:35 <Jafet> lpsmith: you can shit in a soup can and call it Trustworthy
23:10:42 <Jafet> The user decides whether to trust your soup can
23:10:50 <Nereid> > foldr const 8 (undefined:undefined)
23:10:52 <lambdabot>   *Exception: Prelude.undefined
23:10:53 <Nereid> oops
23:10:56 <sclv> i don't think its wise to call that trustworthy
23:10:57 <Nisstyre> (unless you gave it an empty list)
23:10:58 <Nereid> > foldr const undefined (1:undefined)
23:11:00 <lambdabot>   1
23:11:05 <lpsmith> mikeplus64, I would prefer that,  but this is not normally intended for direct use,  and that would just add more indirection for limited functionality
23:11:10 <edwardk> so when i go to demand the head of the output of foldr (:) [] [1..]    i force the outermost part of the answer, which is matching up with my current parenthesization, etc. and quickly get 1 : ‚Ä¶      because f = (:)
23:11:20 <sclv> because there's no guarantee that it won't stomp memory in an untrustworthy way
23:11:39 <elliott> lpsmith: I would say that's not Trustworthy
23:11:45 <lpsmith> I'd love it if the library I'm binding to would fix their stuff so I wouldn't have to do this.
23:11:51 <edwardk> Moggle: thats a common optimization in a strict setting, we do it that way in scalaz because we have to, it moves the calculation out onto the heap rather than the stack there, and generally lets it perform better
23:11:56 <elliott> at least I would write an angry email to someone who claimed that was trustworthy and caused my code to dump core
23:11:59 <edwardk> but in a lazy setting its suicide ;)
23:12:36 <lpsmith> elliott, I agree, but I'm reading up on Safe Haskell and it seems to fit the definition.   I mean,  you dump core through the IO monad,  so if you interpret that as an arbitrary side-effect...
23:12:42 <edwardk> Moggle: an interesting exercise is to define foldl in terms of foldr.   a more frustrating exercise is trying to realize _why_ you can't write foldr in terms of foldl
23:12:53 <Moggle> edwardk: oh god now I'm going to have to try that :P
23:13:17 <Moggle> my initial thought was foldl f = foldr f . reverse
23:13:22 <edwardk> Moggle: its useful to do at lease once.
23:13:24 <Moggle> but now I know that foldr isn't defined that way
23:13:25 <Nereid> that's cheating
23:13:25 <Nereid> :p
23:13:26 <Moggle> so rage
23:13:40 <elliott> lpsmith: it's only in IO? that's less bad then
23:14:00 <lpsmith> elliott, right
23:14:16 <zomg> Is there some way to get instance definitions on ghci? Eg. if I wanted to see how [] is defined as an Applicative
23:14:32 <Nereid> nope
23:14:32 <sclv> haha yeah, IO is a get out of jail card.
23:14:36 <Nisstyre> :i Applicative
23:14:42 <Nisstyre> hmm
23:14:44 <zomg> Nisstyre: that just gives the default declaration
23:14:47 <Nisstyre> should that have worked?
23:14:52 <Nisstyre> zomg: I guess
23:14:55 <sclv> not in lambdabot it doesn't
23:15:02 <zomg> I guess I can just go into hackage to look at the source :)
23:15:08 <Nisstyre> sclv: for some reason I thought it would work with lambdabot
23:15:10 <zomg> Though the source display doesn't seem to work for certain things in the Prelude at least
23:15:28 <Nereid> ghci doesn't show any source of anything.
23:15:39 <zomg> Yeah
23:15:50 <Nisstyre> someone showed me this the other day with lambdabot
23:15:52 <Nisstyre> but I forget now
23:16:09 <zomg> Nereid: :i Applicative does show the default (?) definition of Applicative though
23:16:10 <edwardk> Moggle: another interesting exercise is to show that you use foldr to define foldl' and foldl to define foldr' when you go to do this for arbitrary Foldable types
23:16:24 <Moggle> edwardk: I like how mathy Haskell is :D
23:16:25 <Nereid> zomg: no, I only see the methods
23:16:34 <zomg> Yeah that's what I meant :P
23:17:03 <Nisstyre> @src reverse
23:17:03 <lambdabot> reverse = foldl (flip (:)) []
23:17:05 <zomg> I've been writing some haskell article stuff for fun and I'm finding I actually understand certain things better because I had to explain them in words myself =)
23:17:07 <edwardk> Moggle: i like the fact that there is a culture of math here, but i particularly like the fact that that leads to insights that keep paying off later
23:17:24 <zomg> I'm now poking at Applicatives
23:18:06 <Moggle> edwardk: I don't suppose there's an actual textbook on everything like Monads? Or is that like, theoretical computer science and I should just go start looking there?
23:18:18 <johnw`> Moggle: oh yes indeed there is
23:18:31 <Moggle> I've got a lot of basic computer science stuff, taken lots of basic compsci courses on algorithms/data structures (all of them useless since I self-learned most of the things)
23:18:33 <Nereid> @where typeclassopedia
23:18:33 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
23:18:36 <Moggle> but very little on theoretical approaches
23:18:42 <Moggle> to typing systems and the like
23:18:45 <Moggle> which are fascinating
23:18:49 <johnw`> Moggle: if you want the mathy side, check out Awodey's book on Category Theory
23:18:56 <Moggle> :D
23:18:58 <Nereid> monads aren't that big a deal really
23:19:03 <Moggle> Is this like Group theory (another thing I need to study in depth)
23:19:13 <johnw`> one thing that's cool about Monads is that you can understand them anew from several different angles
23:19:16 <elliott> they're both theories
23:19:33 <Nisstyre> Moggle: if you are interested in type theory there is a book by Robert Harper that just came out on the subject
23:19:42 <edwardk> there is a lot about monads that has been written. there is a lot of stuff out there in category theory that turns out to be directly relevant to programming. we borrow a lot of tools from category theory and apply them to the limited domain that is haskell's type system
23:19:45 <Nisstyre> there are also a bunch of renowned books on it by other computer scientists
23:19:46 <Moggle> I'm interested in just... everything.
23:19:50 <Moggle> There's so little time and so much I need to learn.
23:19:54 <edwardk> e.g. Functor here has a real mathematical meaning
23:20:05 <edwardk> the laws for it come from category theory
23:20:15 <edwardk> Monad is also a concept we borrowed from category theory
23:20:19 <Nisstyre> Moggle: I just bought 3 books on graph theory, mathematical logic, and the axiom of choice
23:20:28 <Nisstyre> there IS a lot of math stuff to learn
23:20:56 <johnw`> i'm reading abstract algebra, and sometimes it feels like I'm just reading a printed version of #haskell transcripts
23:21:10 <Nisstyre> johnw`: I got a Dover book on that
23:21:12 <edwardk> the use of monads for effects goes way back to a paper by eugenio moggi. then folks incorprorated them into the language, added support for doing classes for that sort of thing, etc.
23:21:14 <Nisstyre> they have a lot of great math books
23:21:46 * hackagebot Buster 0.1.0 - Hits a set of urls periodically to bust caches  http://hackage.haskell.org/package/Buster-0.1.0 (MichaelXavier)
23:21:47 <Moggle> So: look up lots of category theory.
23:22:05 <Moggle> perhaps I should finish learnyouahaskell.com's tutorial
23:22:05 <edwardk> i write some pretty painfully abstract code in haskell from time to time, and when in doubt i like to borrow abstractions from other people that have been battle tested.
23:22:05 <Nisstyre> the logic one I mentioned is actually written by Stephen Kleene, so I'm looking forward to that one
23:22:31 <Nisstyre> Moggle: I wouldn't look up category theory stuff tbh
23:22:38 <Nisstyre> Moggle: I'd start with logic
23:22:41 <edwardk> category theory is 50 years old. that means mathematicians have been using it for a long time and have worked out the kinks in lots of areas.
23:23:10 <Nisstyre> which is what I'm doing currently, learning about mathematical logic, and combinatory logic
23:23:15 <Moggle> Nisstyre: third year computer engineering student here, I think I have a fairly firm basis on logic
23:23:19 <johnw`> people have even proven most of it using computer-assisted proof methods
23:23:22 <Nisstyre> Moggle: combinatory logic?
23:23:24 <Moggle> But perhaps there's tons of advanced stuff I haven't looked into
23:23:27 <Moggle> like combinatory logic
23:23:29 <Moggle> :P
23:23:29 <edwardk> think of what we still use actively today that is 50 years old. you can maybe point to the core of lisp. ;)
23:23:43 <Nisstyre> Moggle: proof theory is also important
23:23:55 <Nereid> oh, I wrote foldl in terms of foldr again. I've probably done this exercise a dozen times by now.
23:24:04 <Nisstyre> I think it was David Hilbert who pioneered that
23:24:31 <Moggle> Nereid: was that a joke? I'm kind of swimming in all of edwardk's things here and just trying to find stuff out now :
23:24:33 <Moggle> :D
23:24:40 <Nereid> not a joke
23:25:14 <edwardk> Moggle: my main point is that all of these things are useful, so dabble. learn enough of each to get by and see how they all fit
23:25:23 <Nisstyre> Moggle: there is a vast array of logic related stuff that is not "well known"
23:25:24 <Jafet> edwardk: financial mainframes
23:25:24 <Moggle> I am trying :D
23:25:26 <Nisstyre> e.g. ordinal logics
23:25:35 <edwardk> intuitions from one apply to the others through something called the 'curry-howard-lambek' correspondence.
23:25:37 <Jafet> Well, those aren't quite 50 years old yet
23:25:43 <Moggle> Nisstyre: care to recommend a textbook I can go check out of the eng. library?
23:25:51 <Moggle> or heck something I can download would be better
23:25:59 <Nisstyre> Moggle: well there is one by Hindley that looked really good, I haven't read it myself
23:26:02 <Nisstyre> it's kind of expensive
23:26:03 <edwardk> curry-howard says types are propositions, programs that inhabit those types are proofs.
23:26:06 <elliott> edwardk: you would make a good motivational speaker
23:26:39 <Nisstyre> Moggle: http://books.google.com/books/about/Introduction_to_Combinatory_Logic.html?id=sRc7AAAAIAAJ
23:27:03 <Moggle> <3 nisstyre
23:27:06 <Nisstyre> Moggle: Hindley is one of the people responsible for Haskell's type system
23:27:31 <edwardk> curry-howard-lambek says that that you can view types as a category, and you can bring things like monads and comonads over into your type system, and they form modalities in logic, letting you write more interesting propositions that you can prove by writing functions with their signatures
23:27:50 <Nisstyre> I'm currently working on my own implementation of the H-M type system
23:28:01 <johnw`> H-M-N?
23:28:09 <Nisstyre> johnw: what's the N?
23:28:14 <johnw> Nisstyre!
23:28:21 <Nisstyre> lol
23:28:25 <Nisstyre> sure :P
23:28:27 <elliott> there's a version of curry-howard for linguistics or something right
23:28:33 <elliott> I know absolutely nothing about it other than hearing about it once
23:28:33 <Nisstyre> elliott: uh
23:28:37 <Nisstyre> elliott: what would that be?
23:28:44 <elliott> Nisstyre: I have no idea! but it was a thing
23:28:52 <edwardk> elliott: heh, i actually did a brief stint as a 'creativity consultant' in the early 90s, where we'd go into Ford and try to get people to think outside the box and see if at the end of the day we could save them a few cents on a part somewhere.
23:29:14 <Nisstyre> elliott: maybe that you can view phonological rules as proofs of accents or something?
23:29:15 <Nisstyre> idk
23:29:27 <elliott> it was considerably more abstract
23:29:29 <elliott> :P
23:29:31 <Nisstyre> I'm not far enough into linguistics to know what that would mean
23:29:48 <Nisstyre> elliott: phonology is quite abstract, for linguistics.
23:30:32 <Moggle> Why does the world have to be so fascinating?
23:30:33 <Nisstyre> it generalizes phonetics to be much broader, and applies to the sounds as we conceive of them
23:31:08 <Nisstyre> essentially, you have a set of allophones (sounds we actually make), and you can classify them as being a single phoneme
23:31:20 <Nisstyre> then you can write out grammar productions that apply to that phoneme
23:31:46 * hackagebot palindromes 0.4 - Finding palindromes in strings  http://hackage.haskell.org/package/palindromes-0.4 (JohanJeuring)
23:33:21 <edwardk> Nisstyre: phonology doesn't have a lot of structure. it sits down there feeding information into syntax through morphology, then you extract semantics from syntax.
23:33:33 <Nisstyre> edwardk: I guess
23:33:45 <edwardk> most of the interesting proof/logic bits in linguistics come in the syntax domain as you try to translate into semantics
23:33:51 <Nisstyre> edwardk: the analogy with curry-howard probably had to do with semantics or something then
23:34:56 <sclv> there's categorical grammar
23:35:25 <edwardk> yes. there is a nice adjunction between syntax and semantics, so you have lots of nice category theoretic tools to bring to bear. and where you can bring that to bear, there is a type system to be had ;)
23:35:27 <Nisstyre> edwardk: there seem to be some similarities between morphology and phonology though
23:35:33 <sclv> i'm dubious about categorical grammar though
23:35:43 <sclv> because it is flamboyantly nonconstructive
23:36:00 <edwardk> morphology is where whatever the phonology and syntax guys don't want to think about gets put.
23:36:01 <vexy> hello. is there a fromLeft or similar function for either, equivalent of fromMaybe? how about isLeft :: Either a b -> Bool ?
23:36:16 <Nereid> :t either (const True) (const False)
23:36:19 <lambdabot> Either a b -> Bool
23:36:47 <edwardk> sclv: wren is a big fan of it for certain language families, e.g. japanese
23:36:47 <Nisstyre> edwardk: well, for example, metathesis, is that a morphological or a phonological process, both right?
23:37:47 <sclv> there's probably an intuitionist encoding that'll satisfy my prejudices
23:38:33 <edwardk> Nisstyre: morphology mostly exists as a fuzzy grey area between syntax and phonology, it finds itself borrowing little bits from each, and whether something falls into morphology is alarmingly more subjective than almost anything else in linguistics =P
23:39:01 <Nisstyre> edwardk: yeah, I think I agree
23:39:36 <edwardk> words have internal structure, and in some languages a lot more than others, so there is a syntactic component to it, but lots of languages have dead boring morphology.
23:40:23 <Nisstyre> edwardk: English is interesting because there are a lot of corner cases -- words where you think there is an affix but there really isn't for example
23:40:31 <edwardk> vexy: they are defined in many libraries. there isn't a standard one.
23:41:15 <Nereid> :t either id . const
23:41:17 <lambdabot> c -> Either c b -> c
23:41:44 <Nereid> :t flip either id . const
23:41:45 <lambdabot> c -> Either a c -> c
23:43:10 <Jafet> isRight = unsafeCoerce
23:43:26 <edwardk> @let is l = fromMaybe . preview l
23:43:29 <lambdabot>  Defined.
23:43:34 <edwardk> > is _left (Left 4)
23:43:36 <lambdabot>   No instance for (GHC.Show.Show
23:43:36 <lambdabot>                     (Data.Maybe.Maybe (Data....
23:43:40 <notdan> Sorry guys, I keep forgetting whether I should use System.IO.Error or Control.Exception?
23:43:49 <edwardk> @undefine
23:45:05 <edwardk> @let is l = isJust . preview l
23:45:07 <lambdabot>  Defined.
23:45:12 <edwardk> > is _left (Left 4)
23:45:14 <lambdabot>   True
23:45:19 <edwardk> > is _left (Right 4)
23:45:21 <lambdabot>   False
23:46:07 <edwardk> :t preview _left
23:46:08 <lambdabot> MonadReader (Either a c) m => m (Maybe a)
23:46:25 <edwardk> :t (^?_left)
23:46:27 <lambdabot> Either a c -> Maybe a
23:46:37 <johnw> edwardk: how new is "is"?
23:46:50 <edwardk> johnw: we call it 'has' in the library in 3.8
23:47:02 <edwardk> mostly because it works on any fold
23:47:11 <johnw> has is  the official term for it?
23:47:12 <edwardk> @let has l = isJust . preview l
23:47:14 <lambdabot>  Defined.
23:47:22 <edwardk> > has (element 3) [1..10]
23:47:24 <lambdabot>   True
23:47:25 <edwardk> > has (element 30) [1..10]
23:47:28 <lambdabot>   False
23:47:37 <edwardk> it works better for that linguistic situation
23:47:46 <edwardk> johnw: yeah
23:48:46 <johnw> it's hard to write about lens because I keep wanting to wait until the dust truly settles
23:48:59 <johnw> but I suppose it's getting more active lately than less, which is a great thing
23:49:05 <johnw> and the basics aren't changing all that much, I hope
23:49:25 <edwardk> the main set of changes in 3.8 is that we're moving more stuff to profunctors, and giving you more functionality for existing combinators
23:49:50 <edwardk> the core trick that drives iso and prism changes, making them able to be composed with (.)
23:50:07 <edwardk> but a shockingly large chunk of the code base remains intact
23:50:20 <edwardk> oh, and we're making zippers deal with infinities better
23:51:43 <notdan> Why can't I write code like this: 'tempdir <- CE.catch (getTemporaryDirectory) (\_ -> return ".")'? It give me a type error
23:51:51 <notdan>  Ambiguous type variable `e0' in the constraint:
23:51:52 <notdan>       (Exception e0) arising from a use of `CE.catch'
23:52:05 <johnw> you need to give _ a type
23:52:15 <johnw> ((_ :: IOException) -> return ".")
23:52:20 <johnw> insert \
23:52:35 <johnw> i find this detail to be very annoying about catch
23:52:46 <notdan> Right, thanks
23:52:53 <notdan> But why does it need a type signature tho?
23:53:04 <johnw> btw, you may just want to use finally
23:53:16 <notdan> the type of my lambda is a -> IO b
23:53:31 <notdan> johnw: eh, not really, i still have some actions after that
23:53:32 <Nereid> it doesn't know what to pick for a.
23:53:41 <johnw> ah
23:53:44 <Nereid> there are lots of Exception instances and it has to pick one. and there's no default.
23:53:48 <johnw> maybe bracket then?
23:54:10 <Nereid> also I thought it was IOError ,not IOException.
23:54:17 <johnw> it's IOException
23:54:20 <johnw> i've typed enough lately
23:54:24 <Nereid> oh I guess they're the same
