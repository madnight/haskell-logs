00:04:21 <M30W> Hmm.. How do you extract information from something like this? `Right (Somedatatype { information = 60 })`
00:05:16 <zomg> M30W: http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Either.html
00:05:16 <sclv> well its an either
00:05:27 <sclv> so it might not have information
00:05:44 <sclv> i typically use the either function to reduce it
00:05:47 <sclv> ?ty either
00:05:49 <lambdabot> (a -> c) -> (b -> c) -> Either a b -> c
00:06:49 <Nereid> :t _right . ?information
00:06:51 <lambdabot> (?information::f (a -> f1 b), Functor f, Applicative f1) => f (Either c a -> f1 (Either c b))
00:06:56 <sclv> > either (const "defaultVal" :: Int -> String) id $ Right "hi"
00:06:58 <lambdabot>   "hi"
00:06:58 <Nereid> caaaaaaaaaale!
00:07:02 <M30W> sclv: I know it's going to give me this output, But I'm still confused on how to extract this?
00:07:05 <Nereid> :t _right Prelude.. ?information
00:07:07 <lambdabot> (?information::a -> a1 -> f b, Applicative f) => a -> Either c a1 -> f (Either c b)
00:07:09 <M30W> Hmmm
00:07:26 <sclv> M30W: do you know how to use "maybe"?
00:07:36 <M30W> sclv: Sort of
00:07:47 <sclv> (you can get out the "information" but from Somedatatype by just calling information as a function, btw)
00:08:04 <M30W> sclv: O.o?
00:08:05 <sclv> so we can reduce your data to Right 60 by just saying (fmap information yourData)
00:08:10 <Nereid> you might just want to pattern match though
00:08:25 <sclv> record syntax means that you can just apply the names of records as functions to extract their values
00:08:33 <sclv> but then you still have an Either
00:09:03 <M30W> Right (Status {stState = Playing, stVolume = 65, stRepeat = True, stRandom = False, stPlaylistVersion = 2, stPlaylistLength = 282, stSongPos = Just 264, stSongID = Just (Id 264), stNextSongPos = Just 265, stNextSongID = Just (Id 265), stTime = (213.391,256), stBitrate = 128, stXFadeWidth = 0, stMixRampdB = 0.0, stMixRampDelay = NaN, stAudio = (44100,24,2), stUpdatingDb = 0, stSingle = False, stConsume = False, stError = Nothing})
00:09:18 <sclv> so you can pattern match it out, or work with it monadically, or use a catamorphism (collapsing function) like "either" to eliminate that
00:09:30 <M30W> Exactly what I have from withMPD $ status, and I'm after stVolume
00:10:01 <sclv> so let's give you a maybe volume
00:10:19 <sclv> either (const Nothing) stVolume $ yourData
00:10:31 <Nereid> that fails to typecheck
00:10:42 <sclv> oh, right
00:10:51 <sclv> either (const Nothing) (Just . stVolume)
00:10:56 <Nereid> you should probably actually handle the error case
00:11:00 <sclv> yeah
00:11:08 <Nereid> that's why it returns an Either
00:11:13 <sclv> i'm just trying to help M30W think through how to do that by reducing it to a maybe
00:11:31 * M30W still lost.
00:11:40 <sclv> since we just established some way to deal with maybes
00:11:46 <sclv> ok, let's go back one step
00:11:52 <sclv> fmap stVolume yourData
00:11:58 <M30W> let x = withMPD $ status
00:12:02 <sclv> will now give you back Right 65
00:12:10 <Nereid> x <- withMPD status
00:12:16 <M30W> Oh
00:12:20 <sclv> but you still might have a Left
00:12:29 <M30W> Thankyou
00:12:31 <Nereid> so x is either Left of a MPDError, or Right of a Status
00:12:33 <sclv> so you need to handle the error
00:13:03 <sclv> if you're really just getting started, my advice is actually to do the crashy, cheaty thing and not handle the error
00:13:10 <sclv> and just do Right x <- withMPD status
00:13:11 <Nereid> sure
00:13:14 <Nereid> ^
00:13:17 <sclv> now if you get an error that will go boom
00:13:24 <M30W> Hehe
00:13:25 <sclv> but you can get started with it
00:13:42 <Nereid> and then x is just a Status, so then you can stVolume x
00:13:45 <M30W> I wanna put this in my xmonad config to use mpd instead of amixer for volume control.
00:14:45 <M30W> Cause I don't always use the same speakers... USB-Archlinux install, portable; So hardcoding amixer set PCM +5 isn't idea
00:14:48 <M30W> l
00:15:42 <M30W> In the end of the day; I want to add or take 5 from the number, and run it though withMPD $ setVolume ###
00:16:55 <Nereid> perhaps: withMPD $ do { x <- status; setVolume (stVolume x + 5) }
00:17:24 <M30W> Right ()
00:17:25 <b__> if every function I define in a module is supposed to be exported, should I still export them  explicitely?
00:17:29 <Nereid> indeed
00:17:41 <M30W> Oh, read it wrong; yea that makes sence.
00:17:43 <M30W> :D
00:17:54 <Nereid> M30W: but it did something. if you got a Left, you know something went wrong.
00:18:13 <M30W> Nereid: Yea..
00:18:27 <M30W> But, it's only going to error out if MPD isn't running yea?
00:18:33 <M30W> Or responding
00:18:58 <Nereid> it looks like there are a few different kinds of MPDError.
00:20:01 <sopvop> Is it safe to call hs_init() and hs_exit() twice? Just in case I have 2 python C modules using haskell.
00:21:20 <Nereid> looks like "yes"
00:21:43 <Nereid> "There can be multiple calls to hs_init(), but each one should be matched by one (and only one) call to hs_exit()[14]."
00:21:43 <M30W> Nereid: Now Im thinking about mute...
00:21:52 <M30W> MPD can't mute :|
00:22:20 <Nereid> you could set the volume to 0?
00:22:30 <M30W> I could save a variable for unmute but yea...
00:22:36 <M30W> Nereid: ^^
00:22:50 <M30W> Setting to zero isn't mute anyway
00:22:54 <M30W> Linux here haha. zero != mute
00:22:59 <M30W> Alsa ♥
00:23:07 <Nereid> who knows, then.
00:23:26 <M30W> Zero, pretty close tho :P
00:23:33 <Nereid> what does disableOutput do?
00:23:37 <M30W> I think I'll just not use mute :P
00:23:42 <M30W> Nereid: disables the output
00:23:48 <Nereid> obviously.
00:23:51 <M30W> I.e alsa, pulse, httpserver
00:24:15 <Nereid> a bit more rude than mute, perhaps.
00:24:16 <M30W> Only disables MPD from using it
00:24:24 <M30W> Not quite
00:24:39 <M30W> MPD isn't the only thing that would use the interface
00:24:53 <M30W> But MPD level; it's more or less mute on that output
00:25:00 <Nereid> ok.
00:28:00 <M30W> volup work but not down....
00:28:28 <notdan> Hm, ByteString.readFile gives me an exception saying that file does not exist.. but it does, at least ls says so
00:28:36 <notdan> what might be the problem?
00:28:39 <M30W> , ("<XF86AudioLowerVolume>",   withMPD $ do { x <- MPD.status; MPD.setVolume (MPD.stVolume x - 5)})
00:28:42 <M30W> , ("<XF86AudioRaiseVolume>",   withMPD $ do { x <- MPD.status; MPD.setVolume (MPD.stVolume x + 5)})
00:28:48 <M30W> First doesn't work, second does... O.o
00:29:43 <aristid> M30W: there's a MPD module for xmonad? cool
00:29:59 <M30W> aristid: libmpd, not exactly xmonad; but xmonad being haskell; easy to add in
00:30:07 <aristid> ah
00:30:07 <M30W> aristid: libmpd
00:30:15 <M30W> Err, I said that haha
00:30:25 <aristid> lol
00:31:16 <M30W> aristid: vodik has a slightly wrapped version on github. (Supporting switching between different mpd servers cleanly.
00:32:29 <M30W> aristid: He removed that hostchanging from his xmonad config, not sure if he still has it in his repos; but.. https://github.com/archeydevil/dotfiles <- I haven't removed it, It's in xmonad/lib/Utils/MPD.hs
00:32:46 * M30W as usual, really needs to update that repo...
00:33:23 <M30W> aristid: The changehost, brings up a prompt (xmonad-contrib) it's really nice. :)
00:34:18 <M30W> Nereid: Any idea for the issuee that I can only add 5, and can't take?
00:34:24 <Nereid> nope
00:35:10 <M30W> Hehehe.. Casually changing the volume of my other laptop by playing with these bindings. :P
00:35:27 <M30W> Proof that it only goes up tho :P
00:36:34 <aristid> M30W: neat, complete with history
00:36:55 <M30W> Hmm, fixed; for the M-<F11/12> but it looks like my media keys don't want to work with the volkeys
00:36:57 <M30W> Strange
00:36:59 <aristid> M30W: does xmonad store that history persistently somewhere?
00:37:19 <M30W> aristid: Yea, it's awesome. I wrote up that Tmux module with some help in here a while back; Also completion and session management
00:37:29 <aristid> M30W: so you can with that key change from playing music locally on the laptop to using your sound server at home?
00:37:34 <M30W> aristid: Yes. ~/.xmonad/history
00:38:16 <M30W> aristid: I generally only have music playing on my desktop but rsync'd accross my computers and to my phone.
00:38:25 <M30W> Phone + ssh = rsync! :)
00:38:34 * M30W loves his Nokia N900
00:38:39 <johnw> edwardk: is there a lens for Reader?
00:39:03 <aristid> M30W: so what do you need mpd host switching for if you have only one mpd server?
00:39:12 <Nereid> johnw: everything is a lens for reader
00:39:13 <Nereid> :t view
00:39:15 <lambdabot> MonadReader s m => Getting a s t a b -> m a
00:39:21 <johnw> ah, hehe ;)
00:39:25 <M30W> aristid: Cause.... I might be on my laptop and not at home?
00:39:30 <M30W> So I use localhost ^_^
00:39:35 <johnw> so how does it access the environment?
00:39:44 <johnw> i.e., if I have a tuple as my r, how do I get _1 for it?
00:39:50 <aristid> M30W: ok, so you were lying when you said you only play on your desktop:)
00:39:52 <Nereid> view _1
00:40:00 <johnw> oh, I ese
00:40:04 <zomg> M30W: heh, N900 still going huh.. seems that is still liked by a lot of people :D
00:40:47 <M30W> 19:37         M30W | aristid: I generally only have music playing on my desktop but rsync'd accross my computers and to my phone.
00:40:52 <zomg> I was a subcontractor at Nokia when that wasn't released yet and got to play with a proto.. it was rather amazing back in the day
00:40:54 <M30W> aristid: Lie? "generally"
00:41:10 <zomg> I remember that the prototype had broken keyboard leds, they just kept blinking randomly :D
00:41:16 <aristid> M30W: generally doesn't mean always? maybe my non-native english is at fault there:P
00:41:28 <zomg> M30W: does the N900 still display a small \o/ smiley when it boots up?
00:41:29 <M30W> generally means almost always
00:41:43 <M30W> zomg: Nope.
00:41:46 <zomg> aww
00:41:58 <zomg> it used to do that, I guess it might be hidden by one of the Nokia logos now
00:42:03 <aristid> M30W: interesting, most words that i feel i know i know correctly.
00:42:11 <M30W> My N900 should be dualbooting alarm and sailfish in the near future
00:42:20 <aristid> M30W: perhaps it's because there is a german cognate which means _really always_.
00:42:27 <aristid> "generell"
00:42:46 <M30W> l *
00:42:49 <M30W> ly *
00:43:01 <aristid> ?
00:43:07 <M30W> oh nvm
00:43:16 <M30W> And damn you aux cable.. BE LONGER
00:43:44 <M30W> Win :)
00:44:32 * M30W got this laptop a few days ago; haven't really touched it much. Just booted from USB; going to install to this 32G SSD soon. :)
00:44:48 * M30W already told win.8 to fuck off and leave my SSD alone. :)
00:45:07 <M30W> Mine; not your hibernation area >_<
00:45:55 <aristid> M30W: it's got an embedded 32 GB SSD?
00:46:08 <aristid> in addition to a hard disk i guess
00:46:21 <Nereid> SSDs are great.
00:46:33 <zomg> 32 gig ssd is sorta small though
00:46:42 <zomg> well, at least in the Windows world
00:46:42 <zomg> :P
00:46:42 <M30W> aristid: also, M-p using the prompt from xmonad-contrib really comes in handy instead of dmenu cause it's easier to theme with the environment you configure in the xmonad.hs file. And the history gets useful
00:46:58 <M30W> Completion is much nicer too ^_^ Table above the prompt; damn awesome. :D
00:47:05 <M30W> aristid: And yea. 500G HDD
00:47:07 <nicoo> zomg: It's enought to put the base system and some cache, which is enough
00:47:07 <Nereid> I imagine 32GB would be fine if you used it together with a regular HDD and bcache or something.
00:47:09 <nicoo> :P
00:47:20 <zomg> nicoo: yeah not if you want to use Windows :P
00:47:28 <zomg> maybe if you're like really, really careful..
00:47:46 <nicoo> zomg: I don't use Windows :)
00:47:50 <M30W> But... I'm gonna have to learn more windows.foo. Cause... I have to repartition it so windows has 300G and I can have 200G for my storage. Music/steam-beta-games/etc.
00:48:01 <aristid> zomg: microsoft sells windows devices with 32 GB... the surface rt ;)
00:48:09 <M30W> nicoo: ...
00:48:12 <MasseR> M30W: I actually just replaced the prompt module for dmenu when changing topics (topicspace)
00:48:32 * M30W is running from a 32G USB. This thing has all my music, all my programs/apps.. EVERYTHING :D
00:48:46 <M30W> Even a few games, and a n64 emulator for Zelda :P
00:48:47 <M30W> lol
00:49:01 <aristid> M30W: easiest would be to nuke windows altogether :D
00:49:11 <M30W> MasseR: switched from the prompt to dmenu?
00:49:12 <M30W> O.o
00:49:18 <M30W> You're the first ^_^ haha
00:49:27 <M30W> aristid: Oh indeed. :D
00:49:29 <MasseR> Because dmenu doesn't require all of the entry to be written, only a minimum identifying string is enough. If I want firefox, I write 'f<enter>' and if I want to go to web topic I write 'w<enter>'
00:49:29 <M30W> Sadly...
00:49:51 * M30W needs to get to know more about windows due to school REQUIRING windows skills.
00:49:57 <M30W> Stupid school.
00:50:21 <M30W> I know enough to bring down your entire network and fry the server. And you still MAKE ME USE WINDOWS! >_<
00:50:21 <nicoo> M30W: I feel for you :(
00:50:43 <M30W> nicoo: Sucks aye. :(
00:51:07 * M30W needs to relearn bloody qwerty before moving on to colemak....
00:51:10 <MasseR> M30W: :/. Haven't used windows at work or at school for years now.
00:51:17 <M30W> (HUGE KEYBOARD!!!!)
00:51:28 <MasseR> But when I did, brr it was horrible
00:51:37 <M30W> MasseR: Ofc it was horrible. :P
00:51:37 <johnw> um, you guys may want to take this to #haskell-blah
00:51:52 <M30W> This thing has win.8 which drove me nuts.
00:52:02 <nicoo> M30W: Reminds me of high school; be default, every single user had the right to shutdown/reboot ... even remote machines ... even the Domain Controler :)
00:52:06 <M30W> (day one; all I did was tell it to leave my SSD alone)
00:52:07 <M30W> :)
00:52:20 <nicoo> johnw: There is #haskel-blah ?
00:52:37 <johnw> yes, it's for non-Haskell discussion by #haskell people
00:52:42 <M30W> nicoo: My school; everyone has the right to install on the harddrives and boot into any system.
00:53:09 <M30W> (computer with no active screen; auto boot-strap install USB = remote box; still online XD)
00:53:17 <johnw> M30W: please move this discussion to another channel
00:53:21 * M30W loves his revshell to his school over the holidays.
00:53:28 <M30W> johnw: Oh sorry; okay
00:53:35 <johnw> thanks
00:53:47 <M30W> nicoo: MasseR >> #haskell-blah
00:54:00 <Nereid> whoa topic police.
00:54:01 <Nereid> :p
00:54:17 <Hafydd> MasseR: >>= #haskell-blah
00:54:24 <MasseR> :D
00:54:29 <johnw> Nereid: shachaf does it enough to me, thought I'd return the favor to the channel :)
00:54:32 <Heather> how to write empty do block?
00:54:39 <Nereid> Heather: there is no such thing
00:54:43 <Heather> ...
00:54:46 <johnw> Heather: "return ()"
00:54:51 <Nereid> that is almost such a thing
00:55:03 <Heather> ok return works
00:55:14 <Nereid> Heather: have you read learn you a haskell?
00:55:15 <Heather> thank you )
00:55:15 <Nereid> @where lyah
00:55:16 <lambdabot> http://www.learnyouahaskell.com/
00:55:25 <Nereid> or something like it
00:56:11 <Heather> Nereid: so I'm reading read it still but I'm trying to write / to use something in the same time
00:58:16 <johnw> Heather: I can relate to that
00:58:44 <Heather> johnw: relate?
01:00:22 <johnw> meaning, I know where you're coming from
01:00:41 <johnw> "your description sounds like it's related to me"
01:03:14 <Heather> johnw: ok.
01:03:56 <Nereid> another one that may be worth reading is
01:03:58 <Nereid> @where rwh
01:03:58 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
01:27:37 <notdan> What is the best way to invoke an external program in Haskell? Right now I am trying to work with System.Process and createProcess/waitForProcess but I am getting in a lot of trouble. Should I try System.Cmd instead?
01:28:48 <notdan> http://hpaste.org/79904 for some reason this code does not work as expected
01:32:49 <johnw> notdan: i'd use shelly
01:33:36 <johnw> unless you only need to do it a single time, then just the 'system' function from System.Cmd
01:58:21 <notdan> johnw: thank's ill look into it
02:49:16 <lzm> is there a better way to do "modify $ \x -> x { field = value }" ?
02:49:35 <bitonic> lzm: lenses!
02:51:30 <elliott> field .= value
02:51:30 <lambdabot> elliott: You have 1 new message. '/msg lambdabot @messages' to read it.
02:51:32 <elliott> or, what bitonic said
02:52:48 <aristid> > (1,2) & _1 .~ "hello"
02:52:50 <lambdabot>   ("hello",2)
02:55:47 <elliott> lzm: http://lens.github.com/, if you're unfamiliar
02:56:31 <lzm> thanks!
02:56:48 <lzm> i am unable to google ".=" though
02:57:06 <aristid> that's because .~ is the right operator :)
02:57:18 <elliott> also https://www.youtube.com/watch?v=cefnmjtAolY
02:57:24 <elliott> aristid: huh?
02:57:26 <elliott> :t (.=)
02:57:27 <lambdabot> MonadState s m => Setting s s a b -> b -> m ()
02:57:37 <elliott> lzm: it's in the lens package
02:57:42 <aristid> elliott: that requires a MonadState
02:57:47 <elliott> see that youtube video for an introduction
02:57:53 <elliott> aristid: lzm said "modify $ \x -> x { field = value }"
02:57:56 <elliott> that's "field .= value"
02:58:21 <aristid> elliott: oh!
02:58:36 <aristid> nevermind then
03:01:52 * hackagebot omnicodec 0.6 - data encoding and decoding command line utilities  http://hackage.haskell.org/package/omnicodec-0.6 (MagnusTherning)
03:08:52 <covi> I have a function (a -> a -> b) and the two arguments in a [a], what's a good way to apply the function to the arguments? I can pattern match, but I suspect there exists better solution.
03:09:49 <shachaf> As in, a list of length exactly 2?
03:10:17 <covi> shachaf: yes
03:10:25 <Skillsob> If the list is of length exactly 2, use a tuple (a,a) instead!
03:11:03 <Skillsob> Then for your tuple t you can just call (curry yourFunction) t
03:11:16 <Skillsob> Actually it might be uncurry in this case.
03:11:21 <Skillsob> :t curry
03:11:22 <lambdabot> ((a, b) -> c) -> a -> b -> c
03:11:28 <Skillsob> Yeah, uncurry.
03:11:53 <covi> Looks good. Thanks
03:13:53 <elkng> someone in #python-offtopic said: "Haskell -- language of the pretentious university students", that true ?
03:14:04 <elkng> is
03:15:19 <elliott> Why are you asking us?
03:15:46 <elliott> repeating obvious trolls is equivalent to trolling in the first place
03:15:59 <elkng> elliott: that what you think
03:16:09 <elliott> yes, that is what I think
03:16:30 <elkng> there is no "no trolling" in topic, why ?
03:16:46 <elliott> well I don't see how you could possibly expect a productive discussion to come from discussion of an inflammatory flamebait quip like that
03:16:53 <zomg> elkng: whoever said that is obviously a dumb retard and should go die in a fire!!11==++=oneoneelever
03:16:54 <elliott> so it doesn't seem worthwhile to even bother
03:17:05 <zomg> *n
03:17:41 <shachaf> zomg: Please don't feed the trolls (as they say).
03:19:00 <elkng> being "pretentious university student" isnt offensive
03:19:08 <lzm> not sure how to make a Setter out of a struct field
03:19:15 <srhb> elkng: Right... :P
03:19:17 <Skillsob> I don't know how to access the lambdabot quote system, but there's one that mentions "abstract research language" that's particularly applicable right now
03:19:21 <elliott> lzm: you want to make a Lens instead
03:19:29 <srhb> @quote abstract research language
03:19:30 <lambdabot> No quotes for this person. I am sorry.
03:19:33 <srhb> Oh, person...
03:19:36 <elliott> lzm: you can automatically generate them with template haskell: http://hackage.haskell.org/packages/archive/lens/3.7.1.2/doc/html/Control-Lens-TH.html
03:19:49 <byorgey> @quote abstract.research.language
03:19:50 <lambdabot> Jafet says: Haskell is an abstract research language used only in academia, education, banking, stock trading, circuit design, embedded systems, cryptography, operating systems research, bioinformatic
03:19:50 <Skillsob> @quote research language
03:19:50 <lambdabot> s, phone apps, and web services.
03:19:50 <lambdabot> No quotes for this person. Just try something else.
03:20:12 <srhb> byorgey: Weird.
03:20:47 <aristid> @quote research.language
03:20:48 <lambdabot> Jafet says: Haskell is an abstract research language used only in academia, education, banking, stock trading, circuit design, embedded systems, cryptography, operating systems research, bioinformatic
03:20:48 <lambdabot> s, phone apps, and web services.
03:20:48 <elkng> what is BBS ?
03:21:45 <aristid> Skillsob: you need to replace all spaces by .
03:23:47 <Lethalman> hi all
03:24:04 <Lethalman> I'm trying to approach haskell but I'm a little concerned about performances
03:24:13 <srhb> Lethalman: Don't be, it's silly.
03:24:22 <zomg> ^ this
03:24:24 <Lethalman> srhb, I'm doing some tries
03:24:27 <Lethalman> let me show
03:24:32 <srhb> Lethalman: No. :(
03:24:38 <Lethalman> :S
03:24:55 <elliott> you can write very fast haskell code if you know what you're doing
03:25:03 <zomg> Unless you're writing something really really performance intensive I don't think you'll have to worry about perf much
03:25:06 <elliott> but it's not something you want to worry about early on
03:25:33 <Lethalman> I'm doing a very simple test for a task
03:25:44 <Lethalman> I wanted to use haskell instead of python which I usually use
03:26:01 <zomg> Lethalman: you're comparing haskell to python and you're worried about performance? :)
03:26:02 <Lethalman> I have to count some frequencies of number from files
03:26:13 <Lethalman> zomg, yes because from this first test it's slower
03:26:16 <Lethalman> this is the code: http://paste.debian.net/219787/
03:26:24 <Lethalman> it should be simply counting occurrences from a file
03:26:44 <Lethalman> tried many types of hashmaps
03:26:47 <zomg> I find it hard to believe it would be slower than python... it's probably something with your specific implementation that's slowing it down
03:26:55 <Lethalman> zomg, yes, that's why I'm here :)
03:27:06 <Lethalman> zomg, that code takes 1.3s in haskell and 300ms in python
03:27:07 <zomg> Yeah, I'm sure someone can shed some light on it.. not a huge pro myself :)
03:28:27 <Lethalman> any hints?
03:28:58 <ethercrow> try using Text or ByteString instead of String
03:29:19 <elliott> Lethalman: you might want to turn on profiling
03:29:23 <ethercrow> standard String is a linked list of chars and much less efficient that python strings
03:29:30 <elliott> makes it pretty easy to find out where you're wasting time
03:29:37 <HugoDaniel> Lethalman: are they producing the same output ? you are just doing a show of a hashmap :/
03:29:45 <Lethalman> HugoDaniel, same output
03:29:46 <fmap> and System.Random is /slow/
03:29:55 <elliott> I can see several things that could be problematic there but nothing looks totally wrong
03:29:59 <Lethalman> fmap, not using Random in that code, it's commented
03:30:02 <elliott> so profiling is a good first step, it's easy with GHC
03:30:24 <Gracenotes> Lethalman: was is faster or slower using Data.Map instead of HashMap?
03:30:29 <Gracenotes> it
03:30:33 <HugoDaniel> Lethalman: im not sure i get the point of this :/ reading a bunch of numbers from a file, putting them into a hashmap and calling show on it
03:30:37 <Lethalman> Gracenotes, it's the same
03:30:38 <elliott> Lethalman: oh, most of your code is commented out
03:30:50 <Lethalman> elliott, yes only readNums is executed
03:30:54 <elliott> Lethalman: This code doesn't really *do* anything so you're not really benchmarking actual computation, just micro-details
03:31:03 <elliott> but (IntMap Int) might help
03:31:07 <Lethalman> elliott, well, it runs in 1.3 seconds while python 300ms sorry...
03:31:09 <elliott> though I hear (HashMap Int) beats IntMap often nowadays
03:31:15 <elliott> Lethalman: how are you compiling?
03:31:19 <Lethalman> elliott, ghc -O2
03:31:23 <HugoDaniel> Lethalman: is there a point ? can i see the python code ? wouldn't it be better to just do text manipulation of the file if thats what you seem to be targeting as an output...
03:31:33 <elliott> oh, you are using "read" too
03:31:44 <Lethalman> elliott, I'm using things that I read on tutorials
03:31:50 <elliott> I think String is probably to blame here, but there's still lots of things it could be... again I recommend profiling
03:32:04 <Lethalman> HugoDaniel, the python code is http://paste.debian.net/219788/
03:32:10 <HugoDaniel> overall, in my experience, haskell is like several orders of magnitude faster than equivalent python code...
03:32:23 <HugoDaniel> lol
03:32:24 <elliott> http://www.haskell.org/ghc/docs/latest/html/users_guide/profiling.html
03:32:29 <HugoDaniel> Lethalman: you are not comparing the same code
03:32:33 <Lethalman> elliott, if I already need profiling for such a code, I don't really mind writing haskell
03:32:35 <HugoDaniel> in python you are just doing string manipulation
03:32:51 <HugoDaniel> in haskell you are building a whole hashmap with a very complex hashing function
03:33:02 <Lethalman> HugoDaniel, that defeats the point of haskell... I'm writing something very natural, if that's not going to be as fast I'm not going to use haskell I believe
03:33:05 <elliott> Lethalman: you can make that snap judgement if you want. I'm not saying you need to profile this code to make it fast
03:33:10 <elliott> I'm saying it would be easy and convenient
03:33:17 <Gracenotes> HugoDaniel: you don't see hashing in python code?
03:33:41 <HugoDaniel> i see this: d[int(n)] += 1
03:33:50 <Lethalman> what I mean is: ok there's a way to optimize that code in haskell, but that will lead to unreadable code and using niche libraries while in python it's very natural?
03:33:59 <HugoDaniel> its not the same as Hashmap, which uses the hashing package
03:34:10 <elliott> When did anyone say unreadable code and niche libraries? it sounds like you have inaccurate preconceptions
03:34:25 <Lethalman> elliott, probably, what should I do then?
03:34:31 <Lethalman> use something else than String?
03:34:32 <HugoDaniel> comparing different approaches in different languages makes no sense
03:34:37 <elliott> anyway it would help if your two programs actually gave the same output to start with
03:34:41 <elliott> since you are really comparing apples to oranges here
03:34:49 <Lethalman> HugoDaniel, I'm trying to do the same task with haskell, that's it
03:35:12 <Lethalman> elliott, I don't care, I want to achieve that task but 1.3 seconds is too much compared to 300ms
03:35:30 <elliott> like I said
03:35:34 <elliott> they are two different programs in many ways
03:35:39 <elliott> if you don't care about that then don't compare how long they take to run :P
03:36:01 <Lethalman> elliott, the problem here is that I'm doing something as natural as I would do in python, but it's slower
03:36:01 <HugoDaniel> exactly :|
03:36:13 <Lethalman> I got it it's not the same
03:36:24 <Lethalman> so I'm going to profile
03:36:30 <HugoDaniel> Lethalman: your haskell code doesn't seem to be that natural, from a quick judge i would say that you have a bit more experience in python than haskell
03:36:42 <Lethalman> HugoDaniel, of course, that's why I'm here :)
03:36:58 <HugoDaniel> ok
03:37:05 <HugoDaniel> so, Lethalman for a quickstart
03:37:07 <elliott> yes, if I was writing this program to be as natural as possible it'd look pretty different
03:37:21 <elliott> the python is kind of cheating though
03:37:31 <elliott> it outsources all the collection work to something specifically designed for this very task
03:37:45 <Lethalman> elliott, it's not cheating
03:37:47 <elliott> and Python has highly-optimised basic string manipulation that isn't comparable to the String type (but more comparable to Text or ByteString)
03:38:02 <Lethalman> ok
03:38:19 <HugoDaniel> Lethalman: lets do a simple approach in haskell and compare it to your python code ?
03:41:49 <Gracenotes> even after using ByteString etc. Python might still beat the Haskell
03:42:18 <elliott> Lethalman: ultimately I suggest using a less synthetic benchmark that actually *does* something, though certainly you can do a lot better than 1.3 seconds
03:42:58 <Gracenotes> still, String is probably being slow. it being a linked list of characters.
03:43:54 <Gracenotes> elliott: why isn't it a fair benchmark?
03:44:11 <Gracenotes> seems fair to me. The Haskell version also seems like a fairly direct translation.
03:45:00 <HugoDaniel> Gracenotes: you have 7 lines of python versus 40 lines of haskell and it seems a direct translation ?
03:45:00 <elliott> I don't really agree on either account, since this is really more about just picking the exact right library
03:45:06 <ethercrow> Lethalman: http://paste.debian.net/219790/
03:45:11 <elliott> and since I wouldn't write the Haskell like that if trying to write something natural and simple
03:45:15 <ethercrow> Text instead of String
03:45:21 <elliott> HugoDaniel: it's actually 22 lines
03:45:28 <elliott> half of the code is completely unused
03:45:51 <HugoDaniel> oh ok
03:45:59 <Gracenotes> it's not unused. it's a test case.
03:46:23 <HugoDaniel> still :/
03:46:37 <Lethalman> ethercrow, thanks
03:46:42 <elliott> Gracenotes: a test case?
03:46:55 <elliott> the python it's being compared to doesn't replicate that half either, it is irrelevant for the purposes of benchmarking :P
03:47:44 <Lethalman> ethercrow, awesome now it's faster
03:48:12 <Lethalman> so the whole problem was in the string splitting with words?
03:48:18 <Gracenotes> Lethalman: cool. how much faster, at the moment?
03:48:31 * Lethalman was doing profiling while testing ethercrow pastebin :S
03:49:06 <Lethalman> Gracenotes, 200ms compared to 366... I know it's not a fair benchmark, but well I'm going to do that for many files ecc.
03:49:57 <HugoDaniel> Lethalman: your files are just "1 2 3 4 5" ?
03:49:59 <HugoDaniel> no lines ?
03:50:35 <Lethalman> HugoDaniel, the test I've done has no lines, but the real files for the task are lines of 10 numbers
03:52:06 <HugoDaniel> ok, let me try out a haskell implementation
03:53:31 <Gracenotes> Lethalman: Using String involves a lot of allocation and deallocation of small cons cells. Laziness is not always useful, and can be bad for locality, if you plan on processing *all* of something at once.
03:55:32 <Lethalman> Gracenotes, I thought lazyness was good for incremental processing, I wanted to read the file chunk by chunk to construct an hashmap on which I can do some reasoning
03:57:09 <Lethalman> ah readFile is strict
03:58:30 <Gracenotes> how does Data.Text.Lazy perform?
03:58:42 <Lethalman> interestingly using TIO.hGetContents is fine as well
04:00:12 <Lethalman> Gracenotes, don't know how to use it... I'm actually doing TIO.hGetContents which returns IO Text
04:00:43 <Gracenotes> That also takes the whole file in memory
04:00:59 * Lethalman doesn't even have his head to understand a lazy string :)
04:01:07 <Gracenotes> it just gets it from disk efficiently
04:01:33 <Lethalman> Gracenotes, ah
04:01:40 <Lethalman> so Data.Text.Lazy.IO
04:01:59 <ethercrow> just substitute every Data.Text with Data.Text.Lazy
04:02:04 <ethercrow> api is the same
04:02:45 <Lethalman> ethercrow, I see, but readLine seems to be still "strict" as per docs
04:02:51 <Lethalman> while for hGetContents there is no docs
04:04:11 <ethercrow> "Read a file and return its contents as a string. The file is read lazily, as with getContents."
04:04:33 <Gracenotes> just by changing the import statements, you should change the behavior of the program to read from the file lazily.
04:04:44 <ethercrow> I'm looking at http://hackage.haskell.org/packages/archive/text/0.11.2.3/doc/html/Data-Text-Lazy-IO.html
04:04:51 <Gracenotes> *should be able to
04:05:08 <Lethalman> ah
04:05:08 <Lethalman> me at http://hackage.haskell.org/packages/archive/text/0.7/doc/html/Data-Text-Lazy-IO.html
04:05:12 <Lethalman> different version :)
04:05:14 <Lethalman> ethercrow, thanks
04:06:09 <Lethalman> ethercrow, that was exactly what I wanted, I've tried for large files and it's perfect :)
04:06:12 <Lethalman> thanks everybody
04:06:53 * hackagebot digestive-functors-heist 0.5.1.1 - Heist frontend for the digestive-functors library  http://hackage.haskell.org/package/digestive-functors-heist-0.5.1.1 (JasperVanDerJeugt)
04:08:41 <Lethalman> I'm still a little worried about this choosing the right library because default types are not very optimized, but maybe it's only about habits
04:09:04 <srhb> Lethalman: String really is the exception.
04:09:39 <elliott> String isn't even always the wrong choice.
04:09:43 <elliott> it's often a good one
04:11:48 <srhb> Yes, and in all honesty I really don't understand why it isn't a good choice in this case
04:12:03 <srhb> I mean, if we keep with the HashMap, I would think it would be fused away entirely.
04:12:30 <srhb> But I suppose it's the equality check that's more costly?
04:13:32 <Lethalman> srhb, as I understand, the slow part of my code was in splitting the string together with converting to a number
04:14:00 <srhb> My own test version did not include converting to a number.
04:14:30 <elliott> well there's the read part
04:14:34 <elliott> read is not so nice under the hood
04:14:39 <srhb> I am not using read.
04:14:50 <elliott> I meant the original code
04:19:44 <srhb> Mine is basicaly words <$> readFile "testfile.txt" >>= print . fromListWith (+) . map (\w -> (w,1))
04:19:54 <srhb> Should I not expect fusion to make String a Pretty Good Choice (tm)?
04:21:43 <HugoDaniel> back, sorry
04:21:55 <HugoDaniel> Lethalman: let me try to do your code in haskell
04:22:01 <HugoDaniel> i would use an IntMap instead of hash
04:22:15 <HugoDaniel> and keep the occurs in there
04:22:40 <Lethalman> HugoDaniel, I've tried Data.HashMap which is an IntMap as far as I understand, but HashMap.Strict is better in this case
04:23:22 <HugoDaniel> im not familiar with the inner workings of it, but from the name im judging hashmap has hashing on top of IntMap
04:23:36 <HugoDaniel> which can be slower for integers
04:23:42 <elliott> it's not based on IntMap
04:23:50 <HugoDaniel> and probably faster for harder to compare datatypes
04:23:52 <HugoDaniel> like strings
04:23:54 <elliott> HashMap Int actually often (usually?) beats IntMap AFAIK
04:23:59 <elliott> oh, maybe not with the new hashable since now hashing for ints isn't a nop
04:24:07 <elliott> but they have a more advanced underlying structure
04:24:11 <HugoDaniel> oh ok
04:24:22 <HugoDaniel> still, it should be straightforward to replace one for another
04:24:50 <HugoDaniel> then, a foldr feels more appropriate than a map
04:25:11 <HugoDaniel> since you are actually folding a list of words into a hashmap (or intmap, or whatever)
04:25:40 <Lethalman> isn't fromListWith doing that for me?
04:25:46 <srhb> I would think so.
04:26:21 <Gracenotes> and more efficiently, probably.
04:26:48 <HugoDaniel> i dont know fromListWith
04:28:22 <HugoDaniel> my approach would be foldr with insertWith
04:29:01 <elliott> that's fromListWith, more or less
04:30:09 <HugoDaniel> foldr (insertWith (+1))
04:30:14 <HugoDaniel> hmm, without the zipping operation
04:30:42 <HugoDaniel> alias, foldr (insertWith (+1) . toInt)
04:30:48 <HugoDaniel> single pass
04:32:03 <shachaf> What are you inserting into?
04:32:20 <shachaf> Oh, an IntMap?
04:32:23 <shachaf> You should use foldl'
04:32:39 <HugoDaniel> yes
04:32:57 <HugoDaniel> still the idea is to do it all in a single pass
04:33:25 <Lethalman> HugoDaniel, why isn't map+fromListWith a single pass?
04:33:26 <HugoDaniel> because once you use Text "words", you are really dealing with lists, and i believe they dont fusion
04:34:12 <HugoDaniel> compose a big function, and do a single pass on the list
04:34:12 <srhb> Why not?
04:34:28 <Lethalman> HugoDaniel, but that's the same
04:34:39 <Gracenotes> lack of fusion doesn't increase the number of passes, just increases the overhead for every item.
04:34:42 <elliott> foldr operates on a list too...
04:35:09 <Lethalman> words, then map to (c,1) and fromListWith... given it's all lazy, doesn't it reads word by word and add to the map?
04:35:20 <Lethalman> *read
04:36:03 <HugoDaniel> i think it does two passes
04:36:08 <HugoDaniel> alias, 3
04:36:14 <Lethalman> HugoDaniel, sorry, why?
04:36:20 <HugoDaniel> 1 for fromListWith, 2 for map, 3 for words
04:36:27 <Lethalman> but that's a stream of words
04:36:31 <srhb> Why would you assume that?
04:36:39 <HugoDaniel> why shouldn't i ?
04:36:50 <HugoDaniel> i assume the worse
04:36:53 <srhb> *boggle*
04:38:39 <Gracenotes> to augment what I said earlier, doing multiple strict passes can be more efficient than doing one big lazy pass for size-bounded input
04:39:16 <Gracenotes> if you can get e.g. better spatial locality with the strict passes
04:39:19 <elliott> HugoDaniel: an assumption of passes is inaccurate for lazy codata like this
04:39:24 <elliott> depends on the specific types of course...
04:39:58 <Lethalman> to point it out, I'm working with a 1 million words, and it appears to work better with laziness
04:40:57 <srhb> I am getting equivalent performance to the Python version with my ultra naive Lazy Text version, but I'm sure it can easily be beaten. I just like shorter programs better. <_<
04:41:07 <werwerwer> you guys discussing speed of haskell program against python program?
04:42:32 <Lethalman> srhb, yes but I don't care if it's slightly slower or slightly faster, the important thing is that it doesn't take 10 seconds whereas python takes 1 second... with lazy text it goes very fine
04:43:03 <hpaste> srhb pasted “Super naive occurs” at http://hpaste.org/79906
04:43:11 <srhb> Lethalman: ^^^
04:43:27 <Lethalman> have to go, thanks for all the help, very appreciated... will try to continue using haskell :)
04:44:00 <Lethalman> srhb, yes that's it, though missing the string to int conversion :P
04:44:06 <elliott> srhb: you can make that program even nicer with tuple sections
04:44:07 <srhb> Lethalman: Text to Int, but yes
04:44:12 <srhb> elliott: I know. :)
04:44:16 <srhb> elliott: fsvo nicer, with pragmas.
04:44:22 <Lethalman> srhb, don't have the head to get >>=  yet :P
04:44:34 <elliott> main = readFile "foo" >>= print . fromListWith (+) . map (,1) . words
04:45:41 <HugoDaniel> well
04:45:56 <Lethalman> bye :)
04:45:59 <srhb> I don't understand why it's so costly to use String instead though.
04:46:16 <HugoDaniel> why not use overloaded strings
04:47:15 <elliott> srhb: I bet it's decently fast with Map, also
04:47:20 <elliott> since the real problem seems to be String
04:47:27 <elliott> though maybe the repeated Ords mess Map up
04:47:29 <srhb> elliott: It is.
04:47:41 <elliott> oh, yours was even with Map, I didn't notice
04:48:04 <srhb> The only thing I left out is the conversion to Int
04:48:34 <srhb> (Which does seem to be very costly)
04:49:22 <elliott> I bet if you hand-write it rather than using read it's a lot faster
04:49:37 <elliott> since read is kind of terrible :(
04:49:38 <hpc> > read "-15"
04:49:40 <lambdabot>   *Exception: Prelude.read: no parse
04:49:50 <hpc> > read "-15" :: Int -- it has to handle negatives
04:49:52 <lambdabot>   -15
04:49:57 <srhb> elliott: Yeah.
04:50:04 <elliott> hpc: well the haskell and python prorgam being compared did not even give the same output
04:50:06 <Gracenotes> > read "()"
04:50:07 <hpc> > read "0xdeadbeef" :: Int -- and it has to handle alternate bases
04:50:08 <lambdabot>   ()
04:50:08 <elliott> so I assume some laxness
04:50:09 <lambdabot>   3735928559
04:50:15 <elliott> *program
04:50:46 <hpc> here's an idea:
04:50:51 <hpc> read a single char from the file
04:50:59 <hpc> > ord '\n' -- then pass it through ord
04:51:01 <lambdabot>   10
04:51:06 <hpc> no parsing whatsoever
04:51:07 <timthelion> > let f = (char 'a' >> char '.' >> f) <|> (char 'b') in parse f "Unknown" "a.a.b"
04:51:08 <lambdabot>   Not in scope: `parse'
04:51:21 <timthelion> > let f = (char 'a' >> char '.' >> f) <|> (char 'a') in parse f "Unknown" "a.a"
04:51:23 <lambdabot>   Not in scope: `parse'
04:51:24 <timthelion> Hello,
04:51:51 <hpc> incidentally, at that point it becomes map length . group . sort
04:52:04 <hpc> if i am understanding the problem right
04:52:37 <timthelion> I have a problem, that I'd like to recursively parse a string of the form "someSymbol" dot "another symbol" dot ect.  And when I use the naive approach as described in the seccond line I just pasted, I get unexpected end of input as parsec tries to parse the symbol and then the dot and fails :(
04:53:06 <timthelion> I thought that <|> was supposed to TRY and then go on to the next option if it doesn't succeed...
04:53:33 <hpc> (<|>) doesn't roll back a parse tree on its own
04:53:37 <hpc> you need "try"
04:53:48 <hpc> specifically
04:54:00 <hpc> (try x) <|> (try y) <|> ... <|> z
04:54:12 <HugoDaniel> here is my approach for the other python problem http://hpaste.org/79908
04:54:17 <HugoDaniel> im not sure if this would be faster
04:54:22 <HugoDaniel> still it makes more sense in my head
04:54:27 <timthelion> hpc: Thanks! :)
04:55:53 <HugoDaniel> cat nums.txt | ./Main
04:55:57 <HugoDaniel> should work :P
04:56:01 <HugoDaniel> and should be faster than python lol
04:57:28 <HugoDaniel> afk, lunch time
04:58:18 <srhb> HugoDaniel: stack size overflow. Fun.
04:58:21 <HugoDaniel> lol
04:58:22 <HugoDaniel> :D
04:58:28 <srhb> But it is WAY faster than Python ;)
04:59:01 <HugoDaniel> lol
04:59:07 <HugoDaniel> it crashes so much sooner :D
05:19:47 <bartavelle> I have a conduits question, if somebody can help me. I wrote an "interactive" conduit, meaning that I'd like the input to end up in the sink ASAP
05:20:25 <bartavelle> I have noticed that it outputs the (n-1)th result only when I push the nth input
05:20:41 <bartavelle> is this expected or something specific with my particular conduit ?
05:33:15 <hpaste> fmap pasted “Overloading on function type” at http://hpaste.org/79909
05:33:32 <fmap> any idea on better approach?
05:34:20 <elliott> f :: A -> B -> D; g :: C -> D
05:34:30 <fmap> =(
05:34:53 * elliott thinks you'll find nothing but pain doing overloading like this
06:31:43 <ozgura> quick question: `cabal list --simple-output --installed` lists all installed packages, can I get cabal to list only those in the user database and not in the global database
06:34:21 <solarus> ozgura: `ghc-pkg list' separates these at least
06:35:09 <ozgura> solarus: true. let me see if I can easily separate the two with some bash hackery
06:35:24 <ozgura> it feels like this should be easier :)
06:35:52 <solarus> ghc-pkg list --user
06:36:22 <solarus> ghc-pkg list --user --simple-output lists everything on one line
06:36:41 <ozgura> solarus: fantastic!
06:36:43 <ozgura> thanks!
06:37:19 <solarus> ozgura: there was a --names-only flag also if you dont need the versions for the packages
06:37:58 <ozgura> solarus: hmm, doesn't seem to work
06:38:21 <ozgura> ah, it works together with --simple-output only
06:39:11 <solarus> wierd
06:39:29 <ozgura> --names-only should probably imply --simple-output
06:40:00 <solarus> send a patch! :)
06:44:52 <ozgura> solarus: might do :)
06:49:01 <notdan> Hi! Can somebody please help me with my small piece of code: http://paste.lisp.org/display/134310
06:49:18 <notdan> for some reason, it appears that the `dot' command is not being envoked
06:49:22 <notdan> *invoked
06:49:41 <notdan> however, if I just do the 'system' part in GHCi - it works fine
06:56:00 <srhb> notdan: What's the exit code?
06:56:24 <srhb> notdan: What's your main function?
06:57:29 <srhb> notdan: You didn't include it in your paste.
07:46:04 <CodeCoder> tryhaskell is broke!
07:46:09 <CodeCoder> i keep getting Terminates
07:46:15 <CodeCoder> Terminated
07:46:51 <donri> CodeCoder: http://ghc.io/
07:47:20 <CodeCoder> hmm.
07:47:24 <CodeCoder> is there a tutorial
07:47:32 <donri> not in that one no
07:47:59 <donri> @where lyah
07:48:00 <lambdabot> http://www.learnyouahaskell.com/
07:48:12 <srhb> CodeCoder: But the tryhaskell lessons still work. You can type stepN where N is the next step number
07:49:04 <CodeCoder> ah
07:49:17 <CodeCoder> well try haskell was cool, fix it!
07:49:19 <CodeCoder> lol
07:49:37 <notdan> srhb: I am just running my test function in the ghci
07:49:50 <notdan> srhb: the exit code is ExitSuccess
07:51:15 <adnam> CodeCoder: our gnomes are on it
07:52:16 <adnam> it's problematic though because their fingers are really small and really thick so they can't use a regular or small keyboard efficiently
07:53:56 <srhb> notdan: Make your function print the exit code of the system call.
07:54:35 <srhb> notdan: Or are you saying that not even your test function works in ghci?
07:55:51 <notdan> I made it print the exit code and it was ExitSuccess, just as I've mentioned
07:56:02 <magneticduck> aa, wait just a second, two equations for the same function have to have the same number of parameters?
07:56:02 <notdan> and yeah, even the test function doesn't work in GHCi
07:56:07 <magneticduck> is there any way around that?
07:56:19 <magneticduck> seems a bit odd
07:56:32 <magneticduck> I'd imagine it has something to do with the technicalities..
07:56:44 <magneticduck> huh
07:56:49 <magneticduck> I never knew
07:56:56 <magneticduck> anybody else think that's a bit strange?
07:57:11 <rwbarton> I think it's just one of those things that is a programmer error 99.9% of the time so you might as well make it a compile error too
07:57:30 <magneticduck> hm
07:57:32 <CodeCoder> magneticduck: huh, how would you have different number of parameters for the same function
07:57:55 <shachaf> p True x = blah; p False = id
07:58:10 <shachaf> I've wanted it occasionally.
07:58:32 <magneticduck> CodeCoder: one sec
07:58:40 <hpaste> MagneticDuck pasted “different number of parameters” at http://hpaste.org/79913
07:58:44 <magneticduck> CodeCoder
07:58:57 <magneticduck> in my code
07:59:06 <magneticduck> I'd like to take out the "world" in the first two equations
07:59:20 <magneticduck> yeah
07:59:23 <magneticduck> ah well
07:59:56 <rwbarton> You can, you just have to "take it out of" the third equation too.
08:00:07 <rwbarton> execAction _ (AddAction point info props) = \world ->
08:00:12 <magneticduck> yeah
08:00:17 <srhb> notdan: I don't know, I suppose it's a ghci quirk. Make a main function and check if it still fails once compiled?
08:00:29 <srhb> but I actually don't know, maybe someone smarter does.
08:02:51 <notdan> srhb: nope, still doesn't work :( maybe it's a problem with dot
08:09:49 <srhb> notdan: Easy to test, try another command.
08:12:59 <donri> is it still the case that free has a performance problem that operational does not?
08:13:37 <elkng> how do I write a 'while' loop with Haskell ?
08:14:01 <srhb> elkng: Maybe you shouldn't. What are you trying to do?
08:15:07 <elkng> does Haskell supports object oriented programming ?
08:15:15 <srhb> elkng: Not in the sense you mean.
08:15:25 <roconnor> Oleg has a OO library
08:15:37 <srhb> still. :P
08:16:13 <elkng> srhb: I'm curious if its possible to write a 'while' loop
08:17:10 <srhb> elkng: Well, yes. that doesn't mean you should. It depends what you're doing.
08:17:12 <Hermit> elkng: it's possible doing some cumbersome IORef management, but still, you better avoid it and start doing things recursively
08:17:26 <srhb> You don't need IORefs though.
08:17:28 <elliott> possible using totally non-cumbersome recursion
08:17:41 <osfameron> takeWhile might work
08:17:42 <Hermit> srhb: really? could you elaborate briefly?
08:18:02 <srhb> Hermit: State, for instance.
08:18:50 <osfameron> elkng didn't specify that they needed a stateful While (though I guess it may be implied)
08:19:21 <Hermit> elliott: I thought he was asking in the sense of doing stuff like for too, doing a while loop and assigning stuff to a variable. He obviously comes from a non FP background
08:20:05 <srhb> How do you even do a while loop outside of a stateful context.
08:20:19 <srhb> Nevermind WHAT the state is, but still.
08:20:21 <osfameron> elkng: perhaps a good approach would be to quote some simple while loop, and we could look at how to approach it in haskell
08:20:28 <elkng> is haskell turing complete ?
08:20:35 <osfameron> srhb: while (x < 10) { list.push(x); x++ }
08:20:48 <Hermit> elkng: yeah, so is brainfuck, so what?
08:21:06 <osfameron> srhb: translates as list = takeWhile (<10) [1..], e.g. doesn't need to be stateful
08:21:08 <srhb> osfameron: How is that not stateful?
08:21:17 <srhb> osfameron: x has state
08:22:07 <osfameron> srhb: yes.  but it's better to translate it to something other than stateful while
08:22:22 <osfameron> the question was just: 16:13 <elkng> how do I write a 'while' loop with Haskell ?
08:22:24 <srhb> osfameron: Absolutely. :) I lead with that.
08:22:30 <osfameron> and the answer might be "don't"
08:22:41 <srhb>  <srhb> elkng: Maybe you shouldn't. What are you trying to do?
08:22:55 <shachaf> 03:13 <elkng> someone in #python-offtopic said: "Haskell -- language of the pretentious university students", that true ?
08:22:58 <shachaf> 03:16 <elkng> there is no "no trolling" in topic, why ?
08:23:04 <osfameron> srhb: ah yes.
08:23:06 <shachaf> elkng: Please stop trolling. Really, it just makes things unpleasant.
08:23:20 <srhb> Meh, I didn't realize it was a troll, sorry.
08:23:27 <elkng> someone spying on me ?
08:23:34 <pnielsen> "is Haskell turing complete" kinda gave it away for me
08:23:54 <Boreeas> Pfft, who needs turing complete languages anyway
08:23:55 <srhb> pnielsen: Yeah.
08:24:02 <Fuuzetsu> The irony of a Python user calling something pretentious
08:24:05 <ion> Is elkng turing complete?
08:24:19 <derdon> was turing language complete?
08:24:28 <Fuuzetsu> was turing turing turing
08:24:34 <elkng> is ion free particle ?
08:24:35 <osfameron> was turng elking complete?
08:24:55 * shachaf suspects this is not constructive.
08:25:02 <shachaf> Oh well.
08:25:13 <elkng> is ion a some free particle ?
08:25:36 <elkng> calling someone a troll is definitely not constructive
08:25:43 <srhb> Anyway, I don't understand what the purpose of this kind of trolling is, not the psychology behind it. I mean, none of us are riled up.
08:26:19 <pnielsen> elkng: check out http://learnyouahaskell.com/ if you're genuinely interested in Haskell
08:26:20 <elkng> srhb: you see ? its because its not trolling
08:26:41 <elliott> asking why the channel doesn't explicitly tell people they're not allowed to troll is a pretty good sign you are not intending on contributing constructively
08:27:16 <srhb> elliott: Or that "trolling" as a concept is not understood.
08:28:57 <elkng> pnielsen: the sites first sentence is: "Hey yo! This is Learn You a Haskell" how can it be serious source of haskell guide ?
08:29:10 <pnielsen> elkng: just read it
08:29:16 <donri> telling people not to troll is just begging for trolls :p
08:29:38 <donri> @where rwh
08:29:38 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
08:29:49 <pnielsen> or that
08:30:00 <donri> elkng: ^ if you want serious biznaz
08:30:01 <osfameron> RWH isn't necessarily a good first book though
08:30:12 <pnielsen> serious /= easy
08:30:42 <derdon> donri: hey, aren't you the bloke from #pocoo? I have the feeling I know you from somewhere
08:30:51 <donri> i am/was
08:31:17 <donri> haven't done python in over a year
08:31:59 <derdon> ha! I have a good memory!
08:32:06 <donri> :)
08:33:03 <donri> edwardk: is there still a performance problem with free that operational solves?
08:38:00 <donri> also, what about that problem with the monad transformer laws, was that fixed in free? does operational suffer the same?
08:41:27 <notdan> srhb: I've solved my problem :) if you are interesting, the whacky part was that I was running a dot command on a file I haven't closed with hClose
08:41:35 <elliott> donri: I think you're meant to use Free with Codensity in practice?
08:41:36 <notdan> srhb: it is strange that the return code was success tho
08:41:39 <elliott> and I think there's a separate FreeT
08:43:07 <edwardk> donri: the naive free monad is slow. operational and the church encoded free monad inside of kan-extensions solves that
08:43:46 <edwardk> http://hackage.haskell.org/packages/archive/free/3.2/doc/html/Control-Monad-Free-Church.html is fast like 'operational'
08:44:35 <donri> aha, thanks
08:44:56 <donri> what about transformer laws?
08:48:52 <edwardk> what about them?
08:49:04 <edwardk> free isn't a real 'monad transformer'
08:49:22 <edwardk> it is useful to pretend it is
08:49:28 <edwardk> and freet is a real transformer
08:51:09 <donri> ah
08:51:57 <donri> i remember tekmo noting some issue with it but maybe that was with Free having a MonadTrans instance and FreeT is correct
08:55:46 <DigitalKiwi> i see a few smtp client libraries? what's a recommended one?
09:01:40 <chrisdone> chris@midnight:~$ ghc -O2 --make -no-hs-main -optl '-shared' -o Test.so Test.hs
09:01:41 <chrisdone> [1 of 1] Compiling Test             ( Test.hs, Test.o )
09:01:42 <chrisdone> Linking Test.so ...
09:01:42 <chrisdone> /usr/bin/ld: Test.o: relocation R_X86_64_32S against `stg_CAF_BLACKHOLE_info' can not be used when making a shared object; recompile with -fPIC
09:01:44 <chrisdone> is it worth bothering trying to recompile GHC with -fPIC or am i likely to be greeted with more nonsense after that?
09:01:58 <pnielsen> DigitalKiwi: https://github.com/jhickner/smtp-mail
09:03:04 <srhb> CodeCoder: Did you notice tryhaskell is up again?
09:03:38 <DigitalKiwi> pnielsen: k, thanks
09:04:37 <hiptobecubic> defining <*> as liftM2 id is strange
09:04:44 <DigitalKiwi> http://hackage.haskell.org/package/SMTPClient how is it compared to that?
09:05:14 <pnielsen> DigitalKiwi: simpler. compare the examples
09:06:00 <augur_> hmm
09:06:09 <DigitalKiwi> any idea on performance comparison?
09:06:17 <augur_> permutation testing by deletion is interesting in a lazy language
09:06:47 <augur_> DigitalKiwi: any relation to a certain egg?
09:06:51 <pnielsen> DigitalKiwi: performance for SMTP? Just use the one you prefer, you won't have a problem :)
09:07:26 <DigitalKiwi> augur_: ?
09:07:33 <augur_> DigitalKiwi: guess not!
09:07:42 <augur_> DigitalKiwi: i know someone on another server who goes by the name kiwi
09:07:44 <pnielsen> DigitalKiwi: if you want performance, you should probably run a postfix or qmail locally to manage the spool anyway
09:08:02 <pnielsen> and use localhost:25 as the relay
09:08:18 <DigitalKiwi> oh hmm
09:08:24 <DigitalKiwi> that's an interesting idea
09:08:36 <hiptobecubic> @src Maybe (<*>)
09:08:37 <lambdabot> (<*>) = ap
09:08:43 <hiptobecubic> @src Maybe ap
09:08:43 <lambdabot> Source not found. stty: unknown mode: doofus
09:08:46 <DigitalKiwi> postfix doesn't really handle the volume i need though :<
09:08:47 <hiptobecubic> @src ap
09:08:48 <lambdabot> ap = liftM2 id
09:09:05 <hiptobecubic> @src liftM2
09:09:05 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
09:09:07 <chrisdone> you should probably also use postfix anyway for reliability
09:09:09 <hiptobecubic> So in that case
09:09:13 <hiptobecubic> f is id
09:09:19 <pnielsen> DigitalKiwi: maybe you want to use Amazon's Simple Email Service or something instead then
09:09:43 <hiptobecubic> and x1 will actually be f (a -> b)
09:09:54 <hiptobecubic> err.. m1
09:10:04 <DigitalKiwi> we have smtp services, that's not the problem, i just have to get stuff to them
09:10:16 <pnielsen> chrisdone, DigitalKiwi: with a local Postfix, you avoid any headache wrt resending on connection failures, bounces to senders (if you're sending behalf of someone), etc.
09:11:13 <pnielsen> DigitalKiwi: I would use postfix and send through localhost:25. You really need to send a LOT of emails to kill that
09:11:32 <chrisdone> pnielsen: exactly
09:11:37 <pnielsen> assuming that you use your main smtp infrastructure as a relayhost
09:11:42 <pnielsen> in the postfix config
09:11:45 <chrisdone> also something as simple as logging
09:12:37 <chrisdone> and you can just queue a thousand mails up in postfix and end your program, you don't need to manage time for sending to take place
09:12:59 <pnielsen> yup
09:13:20 <DigitalKiwi> postfix lacks a lot of things a comercial smtp service provides
09:13:36 <pnielsen> you could mount /var/spool/postfix on a RAM disk if it's not fast enough.. :)
09:14:05 <chrisdone> sure -- but then if you need that kind of scale, just use a commercial mail sending service, not some haskell library from hacakge
09:14:19 <pnielsen> DigitalKiwi: set your main infrastructure as the relayhost--you send through the local Postfix which relays the messages to your main gear
09:14:47 <pnielsen> encryption/anything like that would have to be managed by the library anyway
09:16:23 <DigitalKiwi> I'm not arguing it's a good idea, it might be appropriate...it might even work for us, but I've hit postfix limits a long time ago :(
09:16:41 <pnielsen> DigitalKiwi: I don't understand how you can hit its limits if you are just relaying to your main SMTP server
09:17:01 <DigitalKiwi> you have to REALLY be good tog et 100k an hour out of postfix, i've never gotten there :/
09:17:06 <pnielsen> DigitalKiwi: and seriously, if you want to speed it up exponentially, you can mount the spool dir on a ramdisk
09:17:19 <pnielsen> DigitalKiwi: that's a lie
09:17:33 <DigitalKiwi> maybe the spool dir would help
09:17:45 <pnielsen> I've had relays that sent ~30k every 5 minutes
09:18:01 <DigitalKiwi> using the spool trick?
09:18:05 <pnielsen> not even
09:18:10 <S11001001> pnielsen: are you really *really* good? :]
09:18:24 <hiptobecubic> > read <$> Just "1" :: Maybe Double
09:18:25 <pnielsen> I don't think so. I barely changed the config at all :)
09:18:26 <lambdabot>   Just 1.0
09:18:33 <hiptobecubic> oh... it does work
09:19:44 <pnielsen> DigitalKiwi: but if you are at this level on a single server, then the haskell library is probably going to be your bottleneck regardless
09:21:16 <DigitalKiwi> 11:13 < chrisdone> sure -- but then if you need that kind of scale, just use a commercial mail sending service, not some haskell library from hacakge
09:21:36 <pnielsen> DigitalKiwi: out of curiosity, what are you doing?
09:22:00 * hackagebot happstack-clientsession 7.2.3 - client-side session data  http://hackage.haskell.org/package/happstack-clientsession-7.2.3 (JeremyShaw)
09:22:19 <DigitalKiwi> like mailchimp? those don't work for what we do, they're designed for news letters, we don't do news letters
09:22:32 <pnielsen> DigitalKiwi: like Amazon SES
09:22:38 <hpaste> chrisdone pasted “Test.hs” at http://hpaste.org/79915
09:22:55 <hpaste> chrisdone annotated “Test.hs” with “C code” at http://hpaste.org/79915#a79916
09:23:12 <chrisdone> any idea why this fails?
09:23:47 <DigitalKiwi> I think we looked at them, stuff like smtp.com and mailgun is what we use right now
09:25:04 <pnielsen> DigitalKiwi: what do you do?
09:25:24 <zomg> Anyone happen to know if there's any way to make Hakyll allow special characters in the template identifiers? Eg. $whatever.foo$ (which does not work out of the box)
09:25:34 <DigitalKiwi> email marketing
09:25:58 <chrisdone> so use campaign monitor?
09:26:07 <pnielsen> DigitalKiwi: so you are sending identical mails to a lot of people? Then you definitely want Amazon SES or similar, and use a Haskell library to interface with AWS or smiilar instead
09:26:10 <chrisdone> like facebook, google, etc. do
09:26:35 <pnielsen> or campaign monitor, idd
09:26:39 <DigitalKiwi> no, different emails to a lot of people
09:27:02 * hackagebot happstack-clientsession 7.2.4 - client-side session data  http://hackage.haskell.org/package/happstack-clientsession-7.2.4 (JeremyShaw)
09:27:52 <pnielsen> DigitalKiwi: then if your main service offers an SMTP interface, a local postfix configured to use that as a relayhost + some haskell smtp lib is the easiest way to start, and will scale very well
09:28:05 <zomg> Different emails in email marketing = placeholders replaced with strategically placed receiver's first / last names to make the mail look more personal
09:28:08 <zomg> =)
09:28:32 <pnielsen> zomg: wonder if e.g. Campaign Monitor doesn't offer some kind of service to infer that from the recipient field or something
09:28:43 <pnielsen> seems like an extremely common problem
09:28:58 <zomg> At least MailChimp seems to separately collect it when people subscribe to your mailing list
09:29:12 <zomg> it offers a name field for filling, which you can then insert into your mail templates
09:29:53 * pnielsen is going to launch a company that does marketing where {{firstName}} {{lastName}} are substituted from "Firstname Lastname <firstname.lastname@company.com>"
09:29:59 * pnielsen is going to be very rich
09:30:14 <DigitalKiwi> :)
09:37:00 * hackagebot happstack-foundation 0.3.1 - Glue code for using Happstack with acid-state, web-routes, reform, and HSP  http://hackage.haskell.org/package/happstack-foundation-0.3.1 (JeremyShaw)
09:48:25 <mzero> @msg lambdabot
09:48:25 <lambdabot> Not enough privileges
10:01:59 <Peaker> @tell chrisdone if you use dlerror() to see the errorcode from dlopen, you see that it's missing some ghc libs
10:01:59 <lambdabot> Consider it noted.
10:08:43 <raulcaj> #
10:10:58 <Peaker> @tell chrisdone this works for me: ghc --make -dynamic -shared -fPIC -lm -lrt /usr/local/lib/ghc-7.4.1/libHSrts.a Test.hs -olibtest.so && gcc test.c -ldl -o test -Wall && ./test
10:10:58 <lambdabot> Consider it noted.
10:11:32 <orospakr> hey, why did Data.String define its own type? The builtin Char (and [Char]) type already supports Unicode.  Is it something  like [Char] ends up being a linked list of chars, where Data.String is an array?
10:12:14 <byorgey> orospakr: String is just a synonym for [Char]
10:12:23 <bitonic> orospakr: Data.String.String = [Char]
10:12:23 <orospakr> byorgey, yeah, I know
10:12:29 <orospakr> oh wait, one sec
10:12:38 <shachaf> Synonym = exact same type
10:12:51 <orospakr> erp, sorry s/Data.String/Data.Text/ typo. :)
10:12:58 <bitonic> orospakr: performance
10:13:01 <shachaf> Data.Text does it for efficiency, yes.
10:13:02 <pnielsen> orospakr: yes, text is an array
10:13:10 <orospakr> yeah, okay, I figured it was something like that.
10:13:33 <pnielsen> orospakr: some operations are more expensive, most common ones are not (and are much faster than a linked list with bad locality)
10:13:43 <Peaker> hmm.. linking the GHC rts into every Haskell-export .so file is probably a bad idea
10:14:07 <Peaker> If I try to throw the GHC rts into the C program that loads the Haskell .so's, I think the linker is being a smart-ass and throwing away the unused dependencies
10:14:15 <bitonic> osfameron: the easiest thing to see is that a linked list will have an high overhead since it needs to link the nodes.  Each Char is 5 bytes in GHC.  also, you can’t address Chars quickly
10:14:18 <byorgey> also, "supporting Unicode" is much more than just having a Char type which can store Unicode code points.
10:14:35 <orospakr> yeah, I know the differences in usage/performance of LLs vs arrays, just wanted to confirm that the dichotomy of Text vs String was that. :)
10:14:41 <byorgey> Data.Text actually has full, correct support for Unicode.
10:14:42 <orospakr> byorgey, things like casing and matching?
10:14:47 <byorgey> exactly
10:15:31 <shachaf> Casing and matching in Data.Text?
10:15:43 <orospakr> okay. so, is it fair to say that, as a general rule, if I'm dealing with text of any decent size/complexity, I should be using Data.Text?
10:15:57 <byorgey> yes
10:16:01 <bitonic> orospakr: FSVO size/complexity, yes
10:16:29 <shachaf> orospakr: Not necessarily.
10:16:36 <shachaf> It depends on what you're doing.
10:16:40 <bitonic> orospakr: but most of the times String suffices
10:16:46 <shachaf> Data.Text is great at some operations and not great at others.
10:17:28 <bitonic> orospakr: Text would probably be better as a default “string” for a language anyway.  but using String is still simpler if you want to write small and compatible programs.
10:18:24 <shachaf> I'm not sure about that.
10:18:49 <pnielsen> orospakr: I have an application where I need to make a lot of substitutions of character codes inside strings (substitutions to non-char/longer strings.) Data.Text is much less efficient for this than String, since it must allocate a new array every time. A linked list just requires the equivalent of changing a few pointers
10:19:00 <byorgey> orospakr: well, as you can see, there is not a lot of agreement on this point =)
10:19:20 <bitonic> shachaf: it’s a delicate point, but I think most of the times you want Text properties
10:19:22 <shachaf> pnielsen: You could probably do something more efficient with Builder or something?
10:19:26 <orospakr> yeah, I see what you're getting at.  String for things small things UI strings, and Data.Text for larger things like large amounts of human-readable user input.
10:19:29 <pnielsen> shachaf: probably
10:19:56 <pnielsen> orospakr: figure out what kind of operations you are gonna do, then look at their respective complexities. They are listed in the docs
10:20:04 <shachaf> bitonic: They don't really fit in with how lots of other things in Haskell work.
10:20:08 <NemesisD> where did class Ix get its name from
10:20:14 <shachaf> Anyway it's not going to change so it doesn't matter.
10:20:24 <pnielsen> orospakr: Data.Text is good for large amounts of text because the strings take up much less space in memory
10:20:25 <Nereid> Ix is short for index, I imagine.
10:20:35 <bitonic> shachaf: that’s true as well, but I was thinking more from a “let’s redesign a language” perspective
10:20:46 <Nereid> but 5 letters is too much typing.
10:21:00 <shachaf> @let ix = _at
10:21:01 <lambdabot>  Defined.
10:21:39 <orospakr> actually, that's a good segue into another question: are arrays in haskell implemented with just naiive copies or something more clever like CoW (with some sort of associated mask blocks or something), with the goal of having the passed-by-value arrays seeming entirely immutable as required by lazy FP, but cutting down on redundant memory use?
10:21:57 <NemesisD> i just always assume something in haskell that has a name i don't understand must be some sort of mathematical term
10:22:11 <shachaf> orospakr: There are lots of varieties of arrays.
10:22:21 <shachaf> There are simple immutable arrays, which just do copying.
10:22:22 <bitonic> orospakr: the two big arrays libraries (`array' and `vector') don’t do anything like CoW.
10:22:35 <shachaf> There are mutable arrays, which do mutability.
10:22:38 <orospakr> ouch. so, passing a big array into a function is inherently very expensive?
10:22:42 <bitonic> orospakr: which is really something that would require help from the compiler
10:22:51 <bitonic> orospakr: wait: arrays will still be immutable
10:22:52 <shachaf> There's something called "DiffArray" which tries to be clever and use mutation, but it doesn't end up being that great.
10:22:58 <orospakr> nah, I don't care about mutability.
10:23:04 <pnielsen> orospakr: haskell isn't call-by-value, if that's what you mean
10:23:09 <shachaf> orospakr: Passing a big array into a function will just pass a pointer, of course.
10:23:12 <bitonic> orospakr: so I copy when passing to a function won’t be required - that’s ture in general in Haskell
10:23:16 <shachaf> You only copy the array when you change it.
10:23:26 <bitonic> *true in general
10:23:30 <pnielsen> orospakr: since everything's immutable there's no chance whatever a pointer points to will be modified
10:23:33 <shachaf> There's no such thing as "passing by value", really.
10:24:00 <orospakr> I'm just talking about a function that outputs an array derived from an input array.  If a large amount of the data sent in is the same as what was sent out, it would be nice if the platform avoided copies (hence why CoW came to mind)
10:24:08 <pnielsen> orospakr: http://en.wikipedia.org/wiki/Evaluation_strategy#Call_by_need
10:24:09 <orospakr> shachaf, I know, insofar as *everything* is pass by value. ;)
10:24:36 <bitonic> orospakr: when you actually modify the array you copy it.  but that’s not necessarily the case when passing an array to a function.
10:25:07 <shachaf> orospakr: Yes, for a simple array that'll generally involve copying.
10:25:18 <shachaf> You can always do mutability if that's what you're after, of course.
10:25:27 <shachaf> Also there are all sorts of clever fusion things.
10:25:35 <utaal> hi everyone, first time here - does somebody have a couple of minutes for a newbie question?
10:25:39 <mzero> orospakr: there are many different kinds of containers - many of which have the property you seek: For example… if you have a large Map, and modify just a few keys, then you get a new map that shares all the unchanged data and most of the internal structure
10:25:40 <shachaf> It's not really what you asked for but sometimes it helps with similar things. :-)
10:26:00 <shachaf> utaal: You should just ask questions if you have them.
10:26:04 <bitonic> orospakr: in general immutable arrays in Haskell are convenient if you create them once and read from them a lot, rather than constantly update them
10:26:24 <mzero> as for arrays, there aren't "sharing on modify" kinds of them, because generally that kind of use calls for other kinds of containers (like Map, Set, trees, etc...)
10:27:19 <utaal> (@shachaf) cool! I have a couple of functions
10:28:41 <utaal> readExpr :: String -> Either ErrorType ValType; eval :: ValType -> Either ErrorType ValType
10:30:15 <utaal> I'd like to write   readAndEval expr = readExpr expr >>= eval >>= (return . show)   point-free but I can't figure out how
10:30:29 <shachaf> @pl readAndEval expr = readExpr expr >>= eval >>= (return . show)
10:30:29 <lambdabot> readAndEval = (show `fmap`) . (eval =<<) . readExpr
10:30:33 <shachaf> That's one way.
10:30:51 <S11001001> @ty (>=>) -- utaal
10:30:52 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
10:31:03 <shachaf> Yes, (>=>) is probably better here.
10:33:02 <Eelis> i wish  1e6::Int  worked :(
10:33:04 <utaal> cool, that's perfect, thanks! ( readExpr >=> eval >=> (return . show)   correct? )
10:33:51 <shachaf> utaal: Do you know that foo >>= return . bar === liftM bar foo?
10:33:53 <ion> The parens aren’t necessary. (.) binds tighter than most operators.
10:34:00 <shachaf> Eelis: I wrote a GHC patch to make it work!
10:34:13 <Eelis> schlumpi: cool! can i vote on it as an extension or something? :)
10:34:19 <Eelis> sorry, that was for shachaf
10:34:23 <shachaf> Eelis: http://hackage.haskell.org/trac/ghc/ticket/7266
10:34:42 <tromp> should 1.23e2::Int also work?
10:34:49 <utaal> shachaf: I do, does it help here?
10:35:30 <Eelis> shachaf: very nice :)
10:35:32 <ion> tromp: I don’t see why not.
10:36:01 <shachaf> utaal: Well, it helps in your original definition.
10:36:09 <ion> > denominator 1.23e2 == 1
10:36:11 <lambdabot>   True
10:36:21 <shachaf> utaal: Maybe you can do something like readExpr >=> fmap show . eval?
10:36:56 <tromp> it's weird that 1.23e2 and 1.23e1 type differently
10:37:16 <Eelis> not to me
10:37:45 <tromp> you expect valid int literals to have simple syntax
10:37:59 <Eelis> indeed, simple like 1e6 :)
10:38:04 <shachaf> I expect what I want!
10:38:18 <utaal> shachaf: got it, it was actually written like that before, thanks
10:38:18 <tromp> so maybe one shld exclude dots in the notation for int literals
10:38:40 <utaal> ion: nice, thanks
10:38:44 <tromp> i mean decimal point
10:38:46 <shachaf> tromp: I don't see why.
10:38:53 <shachaf> > 1.2e6
10:38:55 <lambdabot>   1200000.0
10:38:57 <Eelis> i like 1.2e6::Int, too
10:40:59 <tromp> :t 1.23
10:41:01 <lambdabot> Fractional a => a
10:43:21 <utaal> shachaf: cool, what form would you advise? (readExpr parses a scheme expr and eval evaluates)
10:44:01 <shachaf> Depending on what happens later, you might also say readExpr >=> eval >=> print
10:47:35 <utaal> (this is from "write yourself a scheme" btw) then there is a catchError and extraction of Right - I have to have a second look now that I know of fmap and >=>
10:47:59 <utaal> thanks!
10:57:23 <S11001001> is newtype Flip f a b = Flip (f b a) defined anywhere?
10:58:49 <Rileld> Hi all, I'm having problems getting 'cabal init' to work. Let me know if you know what the error I'm getting means.
10:58:51 <hpaste> Rileld pasted “Cabal init fails” at http://hpaste.org/79924
10:59:34 <parcs> > let f x ((==x) -> True) = 1; f _ _ = 0 in f 3 3
10:59:36 <lambdabot>   1
11:00:56 <parcs> > let f ((==x) -> True) x = 1; f _ _ = 0 in f 3 3
11:00:58 <lambdabot>   0
11:01:47 <ocharles> hm, is there an already existing type class to turn some 'a' into some 'Monoid b => b'? I currently have 'class Monoid b => Convert a b'
11:02:33 <bitonic> ocharles: well, there is a `Convertible' somewhere
11:02:39 <bitonic> ocharles: <http://hackage.haskell.org/packages/archive/convertible/1.0.11.1/doc/html/Data-Convertible-Base.html>
11:02:46 <dmwit> parcs: Oh, subtle.
11:02:46 <ion> ocharles: Foldable close enough?
11:02:52 <ocharles> yea, i know about the general converting classes, I just wondered if there was something to 'inject' things into a monoid
11:02:54 <ocharles> a bit like pointed
11:02:55 <dmwit> parcs++ for a delightful puzzle
11:03:16 <bitonic> ocharles: but you probably want about something specific for Monoid, in which case what ion said, or maybe ListLike
11:03:26 <bitonic> ocharles: “inject”?
11:03:38 <ocharles> bitonic: inject is probably the wrong word, judging by that confusion :)
11:03:59 <dmwit> ocharles: Is the thing you're starting with a monoid (or semigroup)?
11:04:02 <ocharles> but that 'Monoid m => a -> m' function is what I meant by injection
11:04:29 <dmwit> If not, I don't see what you could hope for a polymorphic function (in either a or m) to do.
11:04:34 <ocharles> no. I have an applicative functor with a 'Const monoid' in there somewhere, and i want that monoid to be variable by the user - but I need a way to get things into monoid
11:04:59 <ocharles> https://gist.github.com/d799b3a07006a4968d6b is everything I have so far, in fact
11:05:06 <bitonic> ocharles: so you’re looking at the as for which a `Monoid m => a -> m' exist, but they aren’t Monoid themselves?
11:05:17 <ocharles> i just wondered if my 'ToConflict' class was an instance of anything more general
11:05:27 <parcs> > let f x@((+x) -> y) = y in f 1
11:05:29 <lambdabot>   2
11:06:31 <parcs> that doesn't feel right
11:07:27 <dmwit> ocharles: Nothing jumps out at me.
11:07:37 <ocharles> mmm, ok. maybe it's best to keep it specific in this case :)
11:09:33 <tsuraan> I'm having problems creating/implementing what I think is a trivial class.  I have some encryption routines, and I want them to run in a (MonadKeyInfo) class, which has a single "getEncryptionKey :: EncKeyName -> m ByteString" function.  My class looks like this:
11:09:50 <tsuraan> class (Monad m, MonadVfsError m, MonadIO m) ⇒ MonadKeyInfo m where getEncryptionKey ∷ EncKeyName → m ByteString
11:09:51 <bitonic> ocharles: I really don’t see why you need a typeclass to do that.  just use two functions.
11:10:06 <pnielsen> > take 10 $ fix$(<$>)<$>(:)<*>((<$>((:[])<$>))(=<<)<$>(*)<$>(*2))$1
11:10:08 <lambdabot>   [1,2,4,8,16,32,64,128,256,512]
11:10:36 <tsuraan> and I'm trying to make a trivial implementation using a ReaderT, so I'm trying to define that instance like this: instance (Monad m, MonadVfsError m) ⇒ MonadKeyInfo (MonadReader ByteString m) where getEncryptionKey _ = lift ask
11:10:52 <ocharles> bitonic: i can use a function, it just means I have to thread the function through everything
11:11:16 <dmwit> tsuraan: Don't forget the MonadIO m constraint.
11:11:46 <bitonic> ocharles: you can have two other functions that work on lists of things.
11:11:48 <dmwit> tsuraan: Also, MonadReader is a typeclass; perhaps you meant to either put that in the context or to use ReaderT in the head.
11:11:48 <tsuraan> the problem I'm having with the instance is that compiling gives me this:  Predicate `MonadReader ByteString m' used as a type
11:11:51 <ocharles> bitonic: in fact, a function was my initial thought, but I just couldn't see a nice way to pass that around other than changing my applicative
11:12:08 <tsuraan> dmwit: ok, that second thing is probably my problem
11:12:32 <dmwit> tsuraan: You probably will not need to use "lift", either.
11:12:42 <bitonic> ocharles: tbh that whole code seems obscured by abstraction the way it is now :P
11:13:11 <bitonic> I mean maybe it is an exercise in abstraction, but I would keep things more plain, unless the abstraction buys you something
11:13:20 <tsuraan> yeah, using the type instead of the class, and ditching lift did the trick.  Thanks!
11:13:45 <tsuraan> I still never can guess whether I'm having a conceptual issue, or a stupid one.  I'm hoping to get that feel soon :)
11:14:27 <ocharles> bitonic: perhaps. It's somewhat an exercise in abstraction, but i'm actually happy with how I can reason about things now. i might later collapse that applicative if i need to for optimisation
11:19:32 <bitonic> ocharles: anyway, because of the abstraction, I can’t really see what you are doing quickly - one that might be better is a phantom type as a tag to decide which monoid to take, so that you have `instance Monoid (MergeScope a ConflictCount)' etc. and a `castMergeScope :: MergeScope a tag1 -> MergeScope tag2'
11:20:30 <bitonic> (the types might be wrong, you get the idea)
11:20:36 <ocharles> bitonic: that applicative is isomorphic to 'Monoid conflicts => (MergeScope a -> Either conflicts a)' - if that helps
11:22:42 <bitonic> ocharles: gotta go have dinner, what I feel is that you’re doing stuff with GHC type classes to reduce a bit of syntax, but that it’s a bit forcing it
11:23:37 <bitonic> but it might be me :)
11:26:31 <sclv> ocharles: you want a reducer: http://hackage.haskell.org/packages/archive/reducers/3.0.0.2/doc/html/Data-Semigroup-Reducer.html
11:28:08 <ocharles> sclv: damnit, reducers strikes again!
11:28:09 <ocharles> :)
11:28:22 <ocharles> (i've been recommended this library twice now for different things)
11:28:28 <ocharles> time to bump it up on the 'LEARN THIS' list
11:28:35 <sclv> its just what you want
11:28:38 <sclv> nothing else really
11:28:45 <sclv> stems exactly from your use case :-P
11:31:01 <ocharles> sclv: oh cool, unit is the minimal definition. easy :)
11:31:35 <goosecheese> Anybody home?
11:32:16 <Elench> No
11:32:24 <goosecheese> damn
11:37:15 <rwmjones> hello .. I'm looking for an example to help me understand the haskell FFI ...  preferably a C library that has Haskell bindings, available for Linux, complex C API, one that passes C "objects" (as pointers) back (which is one of the things I'm having difficulty understanding)
11:37:19 <rwmjones> any suggestions?
11:37:48 <rwmjones> so far I've looked at pcre, glib, readline
11:38:30 <c_wraith> rwmjones: check out the lua bindings, maybe? (I hear they're not great, though)
11:39:01 <rwmjones> lua to haskell bindings?  OK I'll see those
11:39:14 <rwmjones> also one that is well written :-)  otherwise I'll end up copying a bad example
11:42:25 <rwmjones> it's pretty strange .. the HsLua package contains the whole source of lua
11:43:07 <thoughtpolice> that's generally for easy distribution, a lot of people just encourage making lua part of your distribution because it's so small :)
11:43:14 <thoughtpolice> i do this for some other libraries, too
11:43:20 <c_wraith> yeah, lots of packages do that when the C source is small
11:43:34 <c_wraith> just because it's way simpler than getting library paths and include paths right
11:43:40 <rwmjones> I found lua to be a strange language ..  arrays are indexed from 1, and on the C side it's all stack manipulation like FORTH
11:43:57 <rwmjones> (not necessarily bad, just strange)
11:44:13 <thoughtpolice> rwmjones: also, hdis86 is a good example
11:44:28 <thoughtpolice> it wraps udis86 (a low level C library) into a very nice high level API
11:44:37 <rwmjones> thanks
11:46:53 <pnielsen> or sqlite
11:48:52 <Rileld> Hi all. I asked this an hour or so ago, but didn't get a response. Does anyone know why cabal init doesn't work for me? http://hpaste.org/79924
11:50:26 <hpaste> petelefoo pasted “mini  me” at http://hpaste.org/79925
11:54:10 <monochrom> I don't understand why "rpmbuild/noarch/RPMS" is involved at all. cabal-install is not supposed to even know that
11:55:29 <lispy> Rileld: perhaps --verbose works with the init command?
11:55:39 <lispy> failing that, strace may shed light
11:56:10 <Rileld> lispy: --verbose is unrecognized
11:56:35 <lispy> and cabal --version?
11:56:50 <Rileld> cabal-install version 0.10.2
11:56:50 <Rileld> using version 1.10.2.0 of the Cabal library
11:56:54 <lispy> do you have an alias for cabal?
11:57:18 <Rileld> Not that I know of. I don't know how to check that though
11:57:26 <monochrom> type in "alias"
11:57:38 <monochrom> or "type cabal"
11:57:58 <Rileld> I don't have an alias
11:59:50 <Rileld> I'm using Fedora 17 x64 if that makes a difference.
12:00:50 <lispy> Rileld: move your cabal config out of the way and try it again? Something like mv ~/.cabal/config ~/.cabal/config.bk
12:01:15 <lispy> (or the shorter mv ~/.cabal/config{,.bk})
12:02:04 <Rileld> I tried moving the config, but I get the same error
12:02:43 <lispy> did you try strace? strace cabal init
12:03:44 <lispy> if you know how to use strace, we should be able to figure out if cabal is shelling out to some program that is inturn looking for the RPMS dir
12:03:51 <lispy> (that's my current theory)
12:04:26 <Rileld> I do not know how to use strace. But I ran it, and I can put the output on hpaste
12:04:37 <lispy> cool
12:04:56 <lispy> Rileld: also, do you have any funny env variables? For example, is $HOME set to something unusual?
12:05:18 <hpaste> Rileld pasted “strace cabal init” at http://hpaste.org/79926
12:06:53 <Rileld> lispy: $HOME is definitely in the usual place.
12:07:19 <lispy> Rileld: what are the permissions on rpmbuild/noarch/RPMS?
12:07:52 <Rileld> drwxr-xr-x
12:08:05 <lispy> it looks like cabal is doing a sort of recursive stroll through $HOME and then when it gets to that directory it bafrs
12:08:08 <lispy> barfs*
12:08:21 <Rileld> lispy: sorry that was for rpmbuild
12:08:34 <lispy> openat(AT_FDCWD, "/home/kevin/rpmbuild/noarch/RPMS", O_RDONLY|O_NONBLOCK|O_DIRECTORY|O_CLOEXEC) = -1 ENOENT (No such file or directory
12:08:34 <Rileld> lispy: rpmbuild/noarch does not exist
12:09:35 <lispy> Rileld: if you make a directory and run the command in there, does it work? mkdir lispy-test && cd lispy-test && cabal init
12:10:56 <Rileld> Ah, thank you. That works.
12:11:32 <lispy> We still don't know why cabal chokes on the RPMS dir
12:12:50 <monochrom> interesting. I think I know how to reproduce it. it is also present in 0.14
12:13:01 <lispy> Rileld: you might try running a file system scan if rpmbuild/noarch does not exist
12:13:26 <lispy> monochrom: hmm...how would you reprocude it?
12:13:43 <Rileld> lispy: why? what's that folder for?
12:14:17 <monochrom> ensure that rpmbuild/RPMS/noarch exists (as a directory, and note the order). then cabal-install will look for rpmbuild/noarch/RPMS (note the order!)
12:14:36 <lispy> Rileld: I'm a little confused here. I don't know if cabal is screwing up or if your filesystem is reporting that directory path but then not allowing programs to access it (that would hint at file system corruption?)
12:14:51 <lispy> monochrom: oh weird. How does that even happen?
12:15:19 <monochrom> I blindly bet that someone made an ordering mistake in cabal-install or Cabal :)
12:15:25 <Rileld> lispy: I have rpmbuild/RPMS/noarch
12:16:08 <lispy> cabal-install version 1.16.0.1
12:16:09 <lispy> using version 1.16.0.2 of the Cabal library
12:16:15 <lispy> monochrom: I think the bug is still there
12:16:23 <lispy> monochrom: your steps worked here
12:16:29 <monochrom> hehe!
12:18:15 <chrisdone> where are dcoutts? (●´∀｀●)
12:18:16 <lambdabot> chrisdone: You have 2 new messages. '/msg lambdabot @messages' to read them.
12:18:28 <chrisdone> @messages
12:18:29 <lambdabot> Peaker said 2h 16m 30s ago: if you use dlerror() to see the errorcode from dlopen, you see that it's missing some ghc libs
12:18:29 <lambdabot> Peaker said 2h 7m 31s ago: this works for me: ghc --make -dynamic -shared -fPIC -lm -lrt /usr/local/lib/ghc-7.4.1/libHSrts.a Test.hs -olibtest.so && gcc test.c -ldl -o test -Wall && ./test
12:19:58 <popl> Do people ever retrieve embarrassing messages from lambdabot in the channel?
12:20:06 <popl> s/Do/Have/
12:20:10 <popl> *retrieved
12:20:21 <popl> That would be funny.
12:21:02 <lispy> I bet the problem is in this module: https://github.com/haskell/cabal/blob/master/cabal-install/Distribution/Client/Init/Heuristics.hs
12:22:32 <chrisdone> Peaker: if i run that command, i get: /usr/bin/ld: /home/chris/Programs/ghc/7.4.1/lib/ghc-7.4.1/libHSrts.a(RtsAPI.o): relocation R_X86_64_32 against `ghczmprim_GHCziTypes_True_closure' can not be used when making a shared object; recompile with -fPIC
12:23:15 <chrisdone> don't think i have ghc's source on this machine
12:23:31 <chrisdone> nope
12:24:16 <lispy> In fact, I think the bug happens near this line: https://github.com/haskell/cabal/blob/master/cabal-install/Distribution/Client/Init/Heuristics.hs#L80
12:24:42 <lispy> you can make a simpler test case with mkdir cabal-init-test && cabal-init-test && mkdir -p FOO/bar && cabal init
12:25:12 <chrisdone> Peaker: (actually i had this error earlier with other incanations advised in some tutorials. i guess i have to recompile ghc with the elusive -fPIC enabled)
12:27:06 <chrisdone> connection's too shitty to download the source… hmm i could download it on my virtual machine, recompile it and download the .a
12:27:30 <chrisdone> Now You're Thinking in SSH Portals™
12:28:24 * chrisdone . o O ( why the hell didn't ghc --make link these things for me? )
12:29:56 * chrisdone . o O ( like -threaded. “hey, can i use forkIO?” “sure…” “forkIO seems not to work properly” “≖‿≖ -threaded” )
12:30:58 <monochrom> oh w00t, now I have a github account!
12:31:39 <lispy> Rileld, monochrom: https://github.com/haskell/cabal/issues/1160
12:31:52 <Nimatek> Hm, is there a faster way to write single bytes to memory than using withForeignPtr and pokeByteoff?
12:32:20 <monochrom> nice lispy, thanks
12:33:24 <chrisdone> Nimatek: memset?
12:33:27 <Rileld> cool, I found a bug :) Thanks lispy
12:34:04 <Nimatek> chrisdone: Mm, I doubt that, but I'll test it.
12:34:28 <shachaf> monochrom: OK, GitHub 101: First, "fork" the repository at ekmett/lens.
12:34:28 <ktosiek> is there any kind of implicit conversion in Haskell? At least for literals?
12:34:36 <monochrom> haha
12:34:41 <Nimatek> Also wait, no. Single bytes.
12:34:51 <monochrom> Second, add more unsafeCoerce
12:34:58 <mm_freak_> ktosiek: no
12:35:03 <ktosiek> I'm writing a lot of Justs lately
12:35:12 <ktosiek> mm_freak_: thanks
12:35:14 <chrisdone> forkREPO
12:35:16 <monochrom> (Third, push your patches. but everyone knows this :) )
12:35:23 <Rarrikins> ktosiek: Sure, integer literals are automatically run through fromInteger or something like that.
12:35:28 <mm_freak_> ktosiek: literals are actually converted using whatever type class is appropriate
12:35:41 <mm_freak_> ktosiek: when you write "3" you actually get "fromInteger theValueThree"
12:35:41 <monochrom> (Optional: change some combinator names!)
12:35:52 <ktosiek> mm_freak_: that's cool :-D
12:36:14 <chrisdone> it's also lame if you want to use ghc to compile anything without base >_>
12:47:07 <byorgey> chrisdone: what's the status of haskelltasks.org ?
12:48:24 <byorgey> just curious
12:48:35 <byorgey> since I could probably come up with quite a few diagrams-related tasks
12:50:54 <chrisdone> i turned it off after no one submitted anything to it =)
12:51:05 <byorgey> heh, fair enough =)
12:51:27 <byorgey> was just looking through some stuff I previously marked "to look at later"
12:51:40 <chrisdone> hehe
12:55:02 <chrisdone> byorgey: this is what it was http://haskelltasks.org/ — written in fay of course. in the end it served as a good experiment
12:55:38 <byorgey> yep, neat
12:56:14 <lispy> we really need a universal account system for the haskell community
12:56:18 <lispy> your site reminds me of that
12:56:18 <niteria> there needs to be an interactive tutorial to learn idiomatic haskell, with simple everyday tasks
12:56:44 <lispy> (I'm thinking something OAuth or OpenID related, probably a combination of them)
12:56:49 <donri> do you think the need for signup is why no one added any tasks?
12:57:30 <chrisdone> dunno. it's about as impeding as reddit's sign-up
12:57:37 <lispy> donri: I think it's a factor, but I doubt it's the only reason. Some people may not have any suggestions when they are actually looking at the site
12:57:43 <chrisdone> lispy: well we have haskellers.com as a start
12:58:15 <chrisdone> but yeah it would be good to have just one haskell account
12:58:23 <lispy> we have hackage accounts, haskellwiki accounts, multiple trac accounts, mailing list sign up, what else?
12:58:26 <chrisdone> i have one for the wiki, one for hackage
12:59:14 <niteria> none of these tasks look like something that can be done in one day
13:00:04 <lispy> someone should make a parser for mixfix that you can use via quasiquotation (and desugars into normal haskell).
13:00:16 <chrisdone> nod
13:00:26 <lispy> I was going to do that over the break, but then took down time for myself instead :)
13:00:26 <chrisdone> if all those services used google i'm sure there'd be no one left without an account
13:00:47 <lispy> chrisdone: s/google/openid/
13:01:05 <lispy> Everyone has an openid friendly accounts somewhere these days, often through google
13:01:12 <chrisdone> i imagine only the most extreme tinfoil hat bridge trolls don't have a google account
13:01:36 <lispy> I bet there are chinese citizens that don't for good reason
13:01:49 <chrisdone> niteria: they were (bad) examples
13:01:53 <lispy> (not that I understand what the reasons would be, I can jst imagine it)
13:03:01 <chrisdone> it was supposed to be "tasks I need doing for my OS project", but every haskeller who viewed it doesn't need any help, or doesn't care about trying it
13:03:14 <lispy> heh
13:03:39 <lispy> chrisdone: so a sort of bounty system (without an explicit bounty) ?
13:04:28 <chrisdone> well it could have karma or something. whatever motivates people. i don't suppose That Warm Feeling Of Doing Good is enough :p
13:05:02 <chrisdone> there are a bunch of people all the time in this community
13:05:16 <chrisdone> "give me a project to work on. maintenance, documentation, ANYTHING"
13:05:21 <chrisdone> those people would go here
13:05:28 * lispy nods
13:05:33 <niteria> there need to be simple tasks to lure them in
13:05:39 <lispy> Sounds like we need to do some marketing and also show that it works.
13:05:43 <chrisdone> even i would, if i had a few hours to spare. i like hacking on small problems and submitting pull requests
13:06:29 <chrisdone> yeah, but we need some legit <1day problems to be solved
13:06:31 <lispy> I've often that that turning issues in an issue tracker into a detective game would help increase crowd participation
13:06:45 <monochrom> use addiction tricks of online games such as "every time you play, you get marks"
13:06:48 <chrisdone> like cluedo? :p
13:07:23 <monochrom> also it was edwardk on hackage using lens :)
13:07:30 <niteria> problem is for many people it's easier to do 1day task instead of explaining what needs to be done
13:07:36 <lispy> chrisdone: what goes in the difficulty field if the problem is easy?
13:07:52 <chrisdone> 'easy'
13:08:05 <chrisdone> i wasn't sure how to handle that
13:08:30 <chrisdone> i just wanted somehow to express "this task is easy for relative haskell newbs", "this is easy for experienced hackers"
13:09:34 <lispy> chrisdone: http://haskelltasks.org/17/fix-this-simple-cabal-init-bug
13:09:35 <chrisdone> (actually that field should be a dropdown, and it can probably be a structured/mandatory way of adding a tag 'easy')
13:10:05 <chrisdone> hmm
13:11:05 <lispy> this discussion of what motivates people reminds me of the twitter clone idea I had. Make a website where all you can post are progress updates about something you're trying to complete
13:11:14 <chrisdone> that's a good example of an issue
13:11:39 <chrisdone> hmm yeah
13:12:20 <niteria> that's a nice issue, makes me want to try
13:12:24 <chrisdone> at work we had the irc hooked up to tickets, so when you completed a ticket, it said "Complete" in the IRC. it was a fun inducement to have loads of <yourname> Completed turn up in an hour
13:12:42 <byorgey> lispy: ooh, good one
13:12:59 <byorgey> I remember that IRC conversation but didn't realize it was a cabal init bug
13:13:03 <byorgey> the minimal test case is nice
13:13:09 <byorgey> lispy++
13:13:31 <lispy> byorgey: monochrom and Rileld deserve the credit
13:13:32 <chrisdone> lispy: ah, i didn't mention -- another idea was to automatically hook up the issue to the actual github ticket, so when the github ticket is closed, the haskelltask is closed, so there's not a maintenance cost
13:13:33 <lispy> monochrom++
13:13:38 <lispy> Rileld++
13:13:40 <byorgey> if anyone fixes that cabal init bug I promise to promptly review the code and merge it!
13:14:11 <lispy> chrisdone: that would be a nice enhancement
13:14:16 <byorgey> chrisdone: ah, yeah, a way to hook haskelltasks to github (or hub.darcs?) tickets would be nice
13:14:39 <chrisdone> or indeed hub.darcs, or bitbucket, ghc's trac, etc. i would implement them if people'd use 'em
13:15:16 <donri> chrisdone: and have haskelltask watch bug trackers for a tag like 'haskelltasks' and automatically import
13:15:27 <chrisdone> clever!
13:15:30 <byorgey> ooh, nice!
13:15:42 * byorgey would certainly use github + hub.darcs integration
13:17:03 <edwardk> haskelltasks watching github issues would be nice
13:17:07 <lispy> foldl (</>) == foldr (</>) ?
13:17:43 <chrisdone> it would be fun to show “niteria complete task #132: http://… ” in here, as an additional inducement. but i'm sure people would consider it spammy (tho ironically to have that kind of spam would be indicative of a lot of work being done =)
13:18:30 <chrisdone> > foldl (++) "noarch" ["rpmbuild","RPMS"]
13:18:33 <lambdabot>   "noarchrpmbuildRPMS"
13:18:34 <chrisdone> > foldr (++) "noarch" ["rpmbuild","RPMS"]
13:18:37 <lambdabot>   "rpmbuildRPMSnoarch"
13:18:46 <lispy> chrisdone: we already have hackagebot and people accept that, so it's probably not bad
13:18:57 <chrisdone> and hpaste!
13:19:42 <lispy> oh, so the bug might actually be the foldl on this line? https://github.com/haskell/cabal/blob/master/cabal-install/Distribution/Client/Init/Heuristics.hs#L101
13:20:36 <chrisdone> hmm, nice catch
13:21:13 <lispy> > foldl (++) "root" ("bar" : "FOO")
13:21:15 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
13:21:15 <lambdabot>              with actual ty...
13:21:19 * byorgey is not convinced
13:21:26 <lispy> > foldl (++) "root" ["bar" : "FOO"]
13:21:28 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
13:21:28 <lambdabot>              with actual type...
13:21:34 <chrisdone> lol
13:21:35 <lispy> > foldl (++) "root" ["bar", "FOO"]
13:21:37 <lambdabot>   "rootbarFOO"
13:21:42 <lispy> hehe, I swear I've used haskell before
13:21:48 <chrisdone> really? ;p
13:21:58 <lispy> > foldr (++) "root" ["bar", "FOO"]
13:22:00 <lambdabot>   "barFOOroot"
13:22:04 <byorgey> foldl (</>) vs. foldr (</>) just changes whether the "base case" gets placed at the beginning or end
13:22:07 <byorgey> it does not reverse
13:22:27 <chrisdone> but it's not reversing in the example is it?
13:22:35 <chrisdone> $HOME/rpmbuild/RPMS/noarch
13:22:35 <chrisdone> → /home/Rileld/rpmbuild/noarch/RPMS
13:23:06 <lispy> yeah, it's flipping them
13:23:17 <byorgey> oh, hmm, maybe
13:23:26 <lispy> I think that isUpper is firing
13:23:52 <lispy> we had to capitalize FOO to make it happen (this was monochrom's idea)
13:24:04 <chrisdone> ahh
13:24:13 <monochrom> no, I did not discover capitalizing, you did
13:24:27 <monochrom> I only discovered re-ordering
13:25:08 <rwbarton> oh hmm
13:25:16 <chrisdone> hm, i suppose i already have cabal running in a ghci session, might as well look at this
13:25:31 <rwbarton> I remember seeing a path pasted here where a bunch of components were in the reversed order, a while back
13:25:44 <byorgey> I remember that, too
13:25:52 <rwbarton> I don't remember the context though
13:25:58 <byorgey> maybe if a bunch of path components are all uppercase the cumulative flipping results in reversal
13:26:25 <`nand`> this is one of the weirdest #haskell conversations to not know anything about the context of
13:27:01 <lispy> `nand`: http://haskelltasks.org/17/fix-this-simple-cabal-init-bug
13:27:15 <lispy> `nand`: checkout the link in that haskell task
13:27:16 <`nand`> “Javascript required.”
13:27:29 <chrisdone> ah, you're one of *those* people :p
13:27:37 <monochrom> haha
13:27:49 <`nand`> it's okay, I can temporarily enable it on a per-site basis
13:27:51 <chrisdone> warning: it also uses cookies, too!!!
13:27:54 <pnielsen> noscript I gjuess
13:27:56 <`nand`> it does? works fine here
13:28:12 * popl eyes chrisdone 
13:28:28 * chrisdone runs xeyes on popl's computer
13:28:55 <Jafet> Not wanting javascript is understandable. But who doesn't want cookies?
13:29:34 * lispy points out that we could be looking in the totally wrong fuction it may not even be in the Heuristics module
13:29:46 <popl> Jafet: third-party cookies suck
13:30:08 <ivanm> Jafet: I prefer biscuits to cookies ;-)
13:30:11 <popl> those are usually the cookies from google analytics and such
13:30:23 <`nand`> I like chocolate chip cookies
13:30:33 <pnielsen> popl: those are technically first-party though
13:30:37 <popl> chrisdone: Full-screen xeyes is pretty cool.
13:30:42 <pnielsen> at least in the sense that they're set on foo.com domain
13:30:54 <chrisdone> popl: it always makes me laugh
13:31:08 <chrisdone> @quote mmorrow xeyes
13:31:09 <lambdabot> mmorrow says: {-# RULES "HAI; CAN HAS STDIO?"  id = unsafePerformIO (system "killall -9 breathingMachine && xeyes &" >> return id)  #-}
13:31:19 <ivanm> chrisdone: but it's not a case of simple things amusing simple minds, right? :p
13:31:32 <ivanm> "breathingMachine"?
13:31:35 <popl> pnielsen: ಠ_ಠ
13:31:48 <chrisdone> ivanm: respirator
13:31:51 <pnielsen> ^_^
13:32:08 <ivanm> I'm assuming the biological one?
13:32:13 <shachaf> popl: It seems that you've seen yourself back in.
13:32:24 <chrisdone> ivanm: no, like in hospitals
13:32:36 <ivanm> ahhhhh
13:32:36 <chrisdone> the one that you unplug and you hear
13:32:40 <chrisdone> > 'b':repeat 'e'
13:32:42 <lambdabot>   "beeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee...
13:32:46 <chrisdone> and someone cries
13:32:48 <pnielsen> nerd alert
13:32:53 <ivanm> the correct way of doing that is having a cleaner unplug it so that they can vacuum, right?
13:33:04 <popl> shachaf: The coffee sucks.
13:33:12 <popl> shachaf: I'm here to talk about more not-haskell.
13:33:13 <otters> > 'f':repeat 'u'
13:33:15 <lambdabot>   "fuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuu...
13:33:19 <byorgey> lispy: but that function in Heuristics is so complicated that it must contain *some* bug (even if not the one currently under consideration)
13:33:38 <chrisdone> ivanm: as opposed to the incorrect way of killall -9 and running xeyes on the on screen display? :p
13:33:44 <Taneb> > "oh god not the " ++ 'b' : repeat 'e' ++ "s"
13:33:46 <lambdabot>   "oh god not the beeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee...
13:33:46 <shachaf> popl: This isn't really the channel for that.
13:33:50 <lispy> byorgey: and it does look for directory entries that have initial caps...it has all the smells
13:33:58 <byorgey> lispy: I completely agree
13:34:17 <pnielsen> > replicate 7 'f' ++ replicate 12 'u'
13:34:19 <lambdabot>   "fffffffuuuuuuuuuuuu"
13:34:36 <popl> shachaf: OK.
13:37:04 <ivanm> chrisdone: methinks that in haskell-process it somewhere assumes that the frame is split only once; if I have it split horizontally, code on left, then on right-side split vertically with the haskell buffer on the bottom and hit Enter on an error, it removes the window above it and goes to the line specified _in the haskell buffer_
13:37:09 <ivanm> (rather than the code buffer)
13:37:19 <ivanm> (and by "haskell buffer" I mean the interaction one)
13:37:29 <davesque> how can i install the latest haskell platform on debian squeeze?
13:38:15 <monochrom> I don't know what's special about debian squeeze, but try my http://www.vex.net/~trebla/haskell/haskell-platform.xhtml
13:38:21 <chrisdone> ivanm: yeah… the whole code is screwed. i had it working perfectly and someone came to do it the Right Way with standard emacs functions and i was all "yeah ok" and now it basically never works, but i've been too lazy to fix :p
13:38:33 <ivanm> heh, fair enough
13:39:14 <chrisdone> <update> thought of a nice way to express editor combinators last night in bed, tho </update>
13:40:30 <ivanm> oh? how so?
13:42:20 <davesque> has anyone ever tried installing the wheezy haskell-platform package on squeeze?
13:42:43 <chrisdone> ah, like parser combinators but i was kind of stuck for a while on implementation details
13:43:10 <chrisdone> actually, like formlets
13:45:02 <Modius> Building GHC on linux I get "inplace/bin/hsc2hs not found " - is there something goofy I'm doing?  Seems daft I'd have to copy it in manually
13:45:27 <ivanm> Modius: sounds like a config error or something
13:46:04 <lispy> byorgey: I'm 90% certain that we're missing a reverse. Line 101 should read: scanForModulesIn projectRoot $ foldl (</>) srcRoot (reverse (entry : hierarchy))
13:46:25 <lispy> byorgey: the problem is that hierarchy is accumulated in reverse order (from current directory to root)
13:46:40 <lispy> byorgey: and so the left fold builds up the path in reverse but it gets the right root
13:46:48 <byorgey> ah, of course, that makes sense
13:47:16 <byorgey> the 'hierarchy' gets built by consing things on the left as we recurse deeper into directories
13:47:30 <lispy> yeah, we should probably be using a zipper...
13:47:35 <lispy> So that part is hidden
13:47:36 <byorgey> meh, whatever
13:47:40 <lispy> :)
13:47:49 <byorgey> patches welcome! =)
13:47:58 <lispy> I could have suggested type indexed lists a la darcs patch sequences :)
13:48:01 <sm> if haskelltasks is reborn as a sort of issue tracker aggregator, https://bugs.launchpad.net/ could be worth looking at
13:48:03 <byorgey> hehe
13:48:34 <chrisdone> something like:
13:48:34 <chrisdone> e_if (If cond_e then_e else_e) = do keyword "if"; cond <- optional e_exp cond_e; keyword "then"; then' <- optional e_exp then_e; keyword "else"; else' <- optional e_exp else_e
13:48:34 <chrisdone>                                     validating $ case (cond>>then'>>else') of Just{} -> return (Right (If cond then' else')); _ -> return (Left "not all slots provided to if")
13:48:34 <chrisdone> ivanm: because i wanted that when you *make* an "if" expression, it outputs: “if _ then _ else _” and the slots are optional. yeah… i'll show you when i've implemented it this way
13:48:56 <ivanm> hmmm, interesting
13:49:18 <ivanm> I did have a look at using some kind of snippet templating thingy in emacs for haskell code, but it didn't seem to be worth it
13:49:26 <chrisdone> yasnippet?
13:49:29 <ivanm> yeah
13:49:40 <ivanm> (I was really looking for something to fill out a module template with all the haddock fields up the top, etc.)
13:49:55 <chrisdone> right
13:50:31 <lispy> byorgey: untested patch! https://github.com/haskell/cabal/pull/1161
13:50:48 <chrisdone> dont-normally-test-my-code-but-when-i-do-i-do-it-in-production.jpg
13:51:54 <byorgey> lispy: thanks!  I'll take a look at it soon
13:53:40 <lispy> chrisdone: what's production ;)
13:53:52 <byorgey> lispy: it's a good thing you made a task on haskelltasks to encourage people to take a look at that bug
13:53:59 <lispy> hahaha
13:54:00 <chrisdone> lol
13:54:09 <chrisdone> byorgey++
13:54:12 <lispy> its-a-trap.jpg
13:54:25 <chrisdone> looks legit
13:54:39 <niteria> lispy: it doesn't seem to work
13:54:47 <lispy> niteria: do'h!
13:54:55 <lispy> niteria: you mean the pull request I just made?
13:55:11 <lispy> niteria: do you have a test case?
13:55:21 <niteria> I've made the same change, installed cabal locally and it still fails on the same test case
13:55:34 <ivanm> chrisdone: for your "greph" task, isn't there that programming-oriented grep utility that might work (albeit not as intelligently as what you're asking for)
13:55:50 * lispy decides he'll have to try it
13:55:56 <chrisdone> you don't mean ack i presume?
13:56:12 <ivanm> yeah, that's the one
13:56:45 <niteria> lispy: well it's my first time compiling cabal so I might've messed sth up in the process
13:58:38 * ivanm should go and check whether the sdist produced by cabal for cabal-install actually includes all modules needed for testing yet
13:59:41 * lispy tries to compile Cabal on a linode...bbiab
14:00:00 <niteria> that thing is thrown away anyway
14:00:18 <niteria> scanForModulesIn projectRoot srcRoot = scan srcRoot []
14:00:24 <niteria> nvm
14:04:13 * chrisdone → bed
14:05:17 <byorgey> night
14:05:33 <ivanm> cya chrisdone
14:05:44 * ivanm supposes he should go cut the grass before it heats up any more
14:06:05 * byorgey doesn't see what the temperature of the grass has to do with anything
14:06:35 <Taneb> byorgey, too hot and the lawnmower just melts
14:06:38 <ivanm> byorgey: if the grass is too hot it burns before you can cut it, making it rather untidy
14:07:06 * hackagebot shelltestrunner 1.3 - A tool for testing command-line programs.  http://hackage.haskell.org/package/shelltestrunner-1.3 (SimonMichael)
14:11:08 <hiptobecubic> How hard would it be to just a have a --fucking-shut-up-and-do-whatever-you-gotta-do flag for cabal? So that if you want to install something and it would break something else it just attempts to update as much of world as is necessary to get things into a working state?
14:11:47 <parcs> pretty damn hard, i bet
14:11:50 <popl> hiptobecubic: how would it know what defines a working state?
14:11:51 <monochrom> it would be hard. it would need a USB 3.0 port in your head. because it would need reading your mind, it's subjective
14:12:03 <hiptobecubic> popl, how does it know packages will be broken?
14:12:42 <monochrom> also, "update" breaks more things, not fewer. perhaps change it to "downdate"
14:13:32 <rwbarton> or "unregister"
14:14:56 <hiptobecubic> monochrom, sure. The point is i want to change a library and rebuild everything that needs it and if i have to change some version to something else that it knows is available then fine, do it
14:15:19 <hiptobecubic> A way to say "I don't give two damns about version numbers. Figure it out."
14:15:54 <lispy> hiptobecubic: if you use cabal-dev it creates a sandbox in the current directory and install the dependencies there. In my experience, it largely solves the problem you're having.
14:15:59 <popl> hiptobecubic: The utility just goes off the dependencies listed in the .cabal files
14:16:08 <popl> I don't think it "knows" anything.
14:16:39 <sm> hiptobecubic: it's pretty easy right now: cabal install THING --force; ghc-pkg-clean (https://gist.github.com/1185421)
14:16:50 <byorgey> hiptobecubic: that would be pretty easy actually.  it would just do  rm -rf ~/.ghc  and then install.
14:17:04 <rwbarton> hiptobecubic: it sounds like you want to add the packages it tells you would break to the cabal install command line
14:17:06 * hackagebot tremulous-query 1.0.6 - Library for polling Tremulous servers  http://hackage.haskell.org/package/tremulous-query-1.0.6 (ChristofferOjeling)
14:17:44 <byorgey> a flag to add breaking packages to the install command line (OR to unregister them first) would be nice
14:17:45 <monochrom> is it --force? or is it --force-reinstall?
14:17:51 <niteria> lispy: hm, I wasn't running the local version for some reason, it works after your fix
14:18:05 <byorgey> niteria: ah, good to hear
14:18:07 <sm> monochrom: it'll accept the shorter spelling I believe
14:18:13 <monochrom> that's neat
14:18:30 <monochrom> "use the --force, luke"? :)
14:18:35 <sm> yup, I use that all the time. But --only doesn't work --only-deps, alas
14:18:48 <sm> doesn't work for
14:19:00 <monochrom> there are so many undocumented things
14:19:01 <niteria> but it's wierd, which cabal gave /home/niteria/.cabal/bin/cabal yet ~/.cabal/bin/cabal init gives different result than cabal init
14:19:08 <popl> hiptobecubic: I suppose in that sense you can have something like a Build-might-work-with section in the .cabal file
14:19:48 <niteria> byorgey: I only tested the testcase from the issue
14:20:00 <monochrom> "which" may be wrong. use "type" if you are in bash
14:20:15 <sm> I think unique flag abbreviations are supported by any haskell program using cmdargs, and perhaps other opt libs too
14:20:23 <monochrom> also, in bash: if you want to rehash to make sure, "hash -r"
14:20:29 <hiptobecubic> I'm saying that cabal has no problem if you wipe everything out and specify all of world at once to be installed
14:21:06 <niteria> monochrom: huh, TIL, never run into this before
14:22:52 <lispy> niteria: cool, I'm still compiling Cabal :)
14:30:33 * applicative didn't know about 'type'
14:30:36 <applicative>  which which; type type; which type; type which
14:32:57 <applicative> type command which type command
14:34:33 <Nereid> > cycle "type command which "
14:34:40 <lambdabot>   mueval: Prelude.undefined
14:34:46 <Nereid> ???????????????????????????????????????????
14:34:50 <`nand`> > ()
14:34:54 <rwbarton> lambdabot just woke up
14:34:56 <lambdabot>   mueval-core: Time limit exceeded
14:34:58 <`nand`> oh no
14:34:59 <Nereid> caaaaaaaaaaaaaaale
14:35:03 <rwbarton> @undefine
14:35:04 <Nereid> :t (.)
14:35:19 <lambdabot> thread killed
14:35:21 <`nand`> I just tried to use @oeis in a privmsg but it failed. Is this a coincidence?
14:35:26 <`nand`> oeis seems to be down
14:35:37 <rwbarton> you monster
14:35:38 <rwbarton> > ()
14:35:43 <lambdabot>   mueval-core: Time limit exceeded
14:35:47 <mm_freak_> lambdabot seems broken
14:36:48 <Ralith> it happens
14:36:55 <Nereid> Cale
14:37:47 <`nand`> it's always struck me as odd that we can't seem to engineer a reliable lambdabot; something's always broken
14:40:27 <Ralith> it's not that we can't so much as that nobody wants to
14:40:42 <`nand`> motivation is part of ability
14:42:06 * hackagebot apelsin 1.2.1 - Server and community browser for the game Tremulous  http://hackage.haskell.org/package/apelsin-1.2.1 (ChristofferOjeling)
14:42:10 <Ralith> I think the usual refrain here is 'patches welcome'
14:45:06 <rwbarton> here's a patch
14:45:25 <rwbarton> replace (.) by (Prelude..)
14:46:15 <Taneb> Or (Control.Category..)
14:46:49 <hemmie> hi all, quick cabal question: so I had installed pandoc from hackage, but then determined I need the latest version from github, so I need to uninstall the existing version first.. A bit of googling indicated that 'ghc-pkg unregister pandoc' should do it, but the executable and lib files are still in my ~/.cabal. So the question is, is there a more elegant solution to remove a package than manually
14:46:50 <hemmie> removing it from ~/.cabal/{bin,lib, etc.}?
14:47:22 <rwbarton> > let x = (Control.Arrow..) in ()
14:47:24 <lambdabot>   Not in scope: `Control.Arrow..'
14:47:24 <lambdabot>  Perhaps you meant one of these:
14:47:24 <lambdabot>    `Contro...
14:47:35 <Taneb> hemmie, no
14:47:52 <rwbarton> is there even any way at all to get Control.Category.. in lambdabot currently
14:48:03 <Taneb> :t Control.Category.(.)
14:48:04 <simpson> :t (>>>)
14:48:05 <lambdabot> Couldn't find qualified module.
14:48:05 <lambdabot> Control.Category.Category cat => cat a b -> cat b c -> cat a c
14:48:06 <applicative> >  let (!!!) f g x  = f (g x); (><) = (unwords !!!) !!! (!!! words) in (concat!!!permutations) >< "type command which"
14:48:08 <lambdabot>   "type command which command type which which command type command which typ...
14:48:11 <Taneb> :t (Control.Category..)
14:48:13 <lambdabot> Control.Category.Category cat => cat b c -> cat a b -> cat a c
14:48:23 <rwbarton> > let x = (Control.Category..) in ()
14:48:24 <lambdabot>   Not in scope: `Control.Category..'
14:48:24 <simpson> :t (<<<) -- derp
14:48:26 <lambdabot> Control.Category.Category cat => cat b c -> cat a b -> cat a c
14:48:30 <rwbarton> (<<<) is good though, yeah
14:48:37 <rwbarton> or at least better than nothing
14:48:40 <Taneb> > (+ 1) Control.Category.. (*2) $ 3
14:48:42 <lambdabot>   Not in scope: `Control.Category..'
14:48:49 <rwbarton> > (id <<< id) 3
14:48:50 <lambdabot>   3
14:49:18 <hemmie> Taneb: really? ok, wow... but should I go ahead and remove them manually, or maybe hope that the new install will overwrite in all the right places?
14:49:18 <simpson> > (+1) <<< (*2) $ 3
14:49:20 <lambdabot>   7
14:50:34 <hemmie> Also, is there any reason cabal can't uninstall packages? It's the first package manager I've used that doesn't seem to have that option
14:51:00 <rwbarton> the new version won't overwrite anything at all
14:51:18 <rwbarton> it's never been a priority
14:51:22 <applicative> uh, calling it a package manager will cause some to begin extremely tedious meditations
14:51:53 <hemmie> rwbarton: well surely it would overwrite ~/.cabal/bin/pandoc, no?
14:51:56 <c_wraith> cabal is a package installer.
14:52:10 <rwbarton> oh for an executable, yeah
14:52:13 <c_wraith> Sometimes it does passable dependency resolution, too
14:52:30 <Taneb> hemmie, because it's not actually a package manager. It's a build system.
14:52:41 <applicative> no it is really annoying it doesn't overwrite executables
14:52:43 <hemmie> Taneb: right... ok
14:52:56 <Taneb> It's stupid, I know
14:53:05 <applicative> no, it's a *build manager*
14:53:15 <Taneb> Okay, it's a build manager
14:53:23 <Taneb> Whatever Cabal does, it does very well
14:53:57 * applicative loves Cabal it's cabal he hates
14:53:58 <c_wraith> By that definition, it's traditionally a package installation breaker.
14:53:59 <c_wraith> :)
14:56:15 <hemmie> ok, thanks all
14:57:16 <applicative> were you wishing it would do something more specific, hemmie?
14:57:52 <[IOD]Ole|Rip-Tra> #TRAVISROOM is the greatest chat room on irc. its owned by me, travis, and i have worked hard day and night to make it the ultimate chat room in the universe. its full of fun, games, interesting talk, and more. so if u want a new chat experience and r sick of ur old ones, come to #TRAVISROOM today.
14:58:08 <Taneb> @where ops
14:58:09 <lambdabot> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
14:58:48 <[IOD]Ole|Rip-Tra> hello my name is travis and i am the owner of the chat room #TRAVISROOM which is the best chat room on the net. its a fun chat and a great place to hang out, talk, and meet other ppl. so if u r bored, stop by #TRAVISCHAT today, its the best chat room on da net.
14:58:49 * applicative  has never seen half these ops
14:58:53 <hemmie> applicative: well even allowing for the fact that it's just a "build manager", it wouldn't seem out of place for it to have an option to uninstall, after all some projects that use make have a "make uninstall" option, no?
14:59:03 <parcs> [IOD]Ole|Rip-Tra: will do, thanks for the heads up
14:59:55 * `nand` would like a ‘cabal uninstall’, because ‘ghc-pkg unregister <name> && rm -rf ~/.cabal/{lib,share/doc}/<name>’ is tedious
15:00:05 <[IOD]Ole|Rip-Tra> #TRAVISROOM is the greatest chat room on irc. its owned by me, travis, and i have worked hard day and night to make it the ultimate chat room in the universe. its full of fun, games, interesting talk, and more. so if u want a new chat experience and r sick of ur old ones, come to #TRAVISROOM today.
15:00:21 <applicative> @where ops
15:00:21 <lambdabot> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
15:00:39 <[IOD]Ole|Rip-Tra> hello my name is travis and i am the owner of the chat room #TRAVISROOM which is the best chat room on the net. its a fun chat and a great place to hang out, talk, and meet other ppl. so if u r bored, stop by #TRAVISCHAT today, its the best chat room on da net.
15:00:56 <hemmie> `nand`: can't tell if sarcastic or...
15:01:13 <`nand`> hemmie: if you ask that then it must mean I'm missing something incredibly obvious
15:01:13 <[IOD]Ole|Rip-Tra> r u bored? looking for a fun place 2 chat? well come to #TRAVISROOM today. its the funnest and greatest place on the net to chat. who knows what could happen there. you can have fun, chat, play, and maybe even meet a new best friend. so stop by #TRAVISCHAT today.
15:01:26 <applicative> hemmie, it is a little tedious
15:01:28 <loekie> `nand`: no need to remove the old stuff. I'm far too lazy for that :)
15:01:56 <`nand`> loekie: no, this is for when I want to uninstall something I installed locally so it'll automatically fall back to the ‘proper’ global versions
15:02:08 <`nand`> tl;dr I only install things locally during the development cycle
15:02:18 <hemmie> well the tedious part is figuring out exactly which dirs to look for when deleting, which, granted you only have to do once
15:02:22 <[IOD]Ole|Rip-Tra> r u bored? looking for a fun place 2 chat? well come to #TRAVISROOM today. its the funnest and greatest place on the net to chat. who knows what could happen there. you can have fun, chat, play, and maybe even meet a new best friend. so stop by #TRAVISCHAT today.
15:02:29 <`nand`> so when the development is done, I'd like to remove them locally and install them through my package manager as usual
15:02:31 <loekie> `nand`: unregistering should be enough
15:02:51 <[IOD]Ole|Rip-Tra> r u bored? looking for a fun place 2 chat? well come to #TRAVISROOM today. its the funnest and greatest place on the net to chat. who knows what could happen there. you can have fun, chat, play, and maybe even meet a new best friend. so stop by #TRAVISCHAT today.
15:02:59 <parcs> [IOD]Ole|Rip-Tra: hi
15:03:01 <applicative> hemmie: unregistering does most everything; are you worried about the space used in ~/.cabal?
15:03:33 <hemmie> applicative: no, just that the github version of pandoc would clash with the hackage one
15:03:39 * `nand` .oO( the spam message lists two different channels, which one am I supposed to join now?! )
15:03:48 <[IOD]Ole|Rip-Tra> hello my name is travis and i am the owner of the chat room #TRAVISROOM which is the best chat room on the net. its a fun chat and a great place to hang out, talk, and meet other ppl. so if u r bored, stop by #TRAVISCHAT today, its the best chat room on da net.
15:03:57 <`nand`> applicative: I'm worried about ~/.cabal not being as tidy as possible :(
15:03:58 <applicative> hemmie: I see, this is a definite problem
15:04:04 <[IOD]Ole|Rip-Tra> hello my name is travis and i am the owner of the chat room #TRAVISROOM which is the best chat room on the net. its a fun chat and a great place to hang out, talk, and meet other ppl. so if u r bored, stop by #TRAVISCHAT today, its the best chat room on da net.
15:04:05 <[IOD]Ole|Rip-Tra> #TRAVISROOM
15:04:06 <[IOD]Ole|Rip-Tra> r u bored? looking for a fun place 2 chat? well come to #TRAVISROOM today. its the funnest and greatest place on the net to chat. who knows what could happen there. you can have fun, chat, play, and maybe even meet a new best friend. so stop by #TRAVISCHAT today.
15:04:07 <[IOD]Ole|Rip-Tra> #TRAVISROOM is the greatest chat room on irc. its owned by me, travis, and i have worked hard day and night to make it the ultimate chat room in the universe. its full of fun, games, interesting talk, and more. so if u want a new chat experience and r sick of ur old ones, come to #TRAVISROOM today.
15:04:10 <parcs> wait is it #travisroom or #travischat?
15:04:15 <Clint> we'll never know
15:04:22 <sclv> ?where ops
15:04:22 <lambdabot> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
15:04:32 <applicative> the trouble is you have the hackage pandoc  and now want something sexy from the github version
15:04:37 <[IOD]Ole|Rip-Tra> #TRAVISROOM is the greatest chat room on irc. its owned by me, travis, and i have worked hard day and night to make it the ultimate chat room in the universe. its full of fun, games, interesting talk, and more. so if u want a new chat experience and r sick of ur old ones, come to #TRAVISROOM today.
15:04:37 <[IOD]Ole|Rip-Tra> #TRAVISROOM is the greatest chat room on irc. its owned by me, travis, and i have worked hard day and night to make it the ultimate chat room in the universe. its full of fun, games, interesting talk, and more. so if u want a new chat experience and r sick of ur old ones, come to #TRAVISROOM today.
15:04:38 <[IOD]Ole|Rip-Tra> hello my name is travis and i am the owner of the chat room #TRAVISROOM which is the best chat room on the net. its a fun chat and a great place to hang out, talk, and meet other ppl. so if u r bored, stop by #TRAVISCHAT today, its the best chat room on da net.
15:04:39 <[IOD]Ole|Rip-Tra> #TRAVISROOM is the greatest chat room on irc. its owned by me, travis, and i have worked hard day and night to make it the ultimate chat room in the universe. its full of fun, games, interesting talk, and more. so if u want a new chat experience and r sick of ur old ones, come to #TRAVISROOM today.
15:05:26 <sclv> yeah we should update those ops
15:05:31 <Taneb> So there's nowhere to talk about processes meat products?
15:05:55 <sclv> a bunch don't hang on irc anymore
15:06:03 <applicative> hemmie: let me try, I haven't reinstalled pandoc lately
15:06:55 <monochrom> sorry was away :)
15:07:55 <hemmie> applicative: for me at least, just cabal install'ing the github version doesn't work
15:08:38 <hemmie> but it might not be related:
15:08:41 <hemmie> cabal: pandoc.cabal:385: The 'type' field is required for test suites. The
15:08:42 <hemmie> available test types are: exitcode-stdio-1.0
15:08:46 <applicative> hemmie: what sort of things goes wrong
15:08:47 <applicative> oh
15:09:10 <applicative> hm, which version cabal install are you using
15:09:12 <rwbarton> that is a lot of .cabal
15:09:57 <applicative> it's insane, but now anything-yesod totally outdoes it :)
15:10:35 <applicative> what does cabal -V say?
15:11:38 <applicative> and does 'cabal install cabal-install --dry-run' predict alarming breakage
15:12:28 <applicative> hemmie: is pandoc the reason youre using cabal-install to begin with?  there might be some simpler advice in that case
15:12:41 <hemmie> marks-laptop> cabal -V
15:12:42 <hemmie> cabal-install version 0.10.2
15:14:07 <applicative> can that be right? I have cabal-install version 1.16.0.2 using version 1.16.0 of the Cabal librar
15:14:11 <hemmie> applicative: like apt-get it?
15:14:39 <applicative> hm, studying
15:14:43 <conal> How can I tell ghci where to look for #include'd files? I'm trying ":set -i<dir>" and ":set -I<dir>" to no avail.
15:15:06 <applicative> hemmie: what version of ghc?
15:15:21 <hemmie> --dry-run gives the same error
15:15:40 <applicative> hemmie: you can cabal install cabal-install but there are some impediments
15:15:48 <hemmie> applicative: ghc 7.0.3
15:16:48 <applicative> hm, what does ' khc-pkg list Cabal ' give for the version of big-C Cabal?
15:17:50 <applicative> sorry ghc-pkg i was using an alias....
15:17:54 <hemmie> applicative: aha
15:18:00 <hemmie> marks-laptop> ghc-pkg list Cabal
15:18:00 <hemmie> WARNING: there are broken packages.  Run 'ghc-pkg check' for more details.
15:18:01 <hemmie> /var/lib/ghc-7.0.3/package.conf.d
15:18:03 <hemmie>    Cabal-1.10.1.0
15:18:45 <hemmie> a shitload of dependencies don't exist
15:19:03 <applicative> I'm worried that the ghc version is getting old enough that avant garde github-pandoc and its .cabal file are out of step with it?
15:19:29 <monochrom> I have updated @where ops. let me know if I'm missing someone or adding extraneous ones
15:19:31 <monochrom> @where ops
15:19:32 <lambdabot> Cale Heffalump Igloo Lemmih Philippa Pseudonym Saizan arjanb bos conal copumpkin dcoutts dibblego dons edwardk glguy jmcarthur johnw kosmikus monochrom quicksilver shapr sjanssen ski wli xerox
15:19:40 <applicative> xerox??
15:19:55 <monochrom> yikes, should have sorted without case :)
15:20:25 <applicative> hemmie: does your distribution have a newer ghc or haskell platform?
15:20:51 <applicative> I'm not sure what version of cabal-install he's taking for granted
15:21:18 <edwardk> heh
15:21:23 <hemmie> applicative: probably, I installed the platform about a year ago I'd say
15:21:59 <hemmie> so yeah, I'll just update everything and call back if there's still problems
15:22:45 <applicative> anyway, it might be easy to hack the cabal file to get around this, but if you want to keep up with pandoc, I think it tends to be pretty unforgiving about recent ghcs
15:23:07 <applicative> 7.4 is the going 'haskellplatform ' version I think
15:23:45 <applicative> hemmie: but it seems like several things are going on, which I'm sure is a bit demoralizing when the point is the pandoc version ...
15:25:20 <hemmie> applicative: if I found this stuff demoralizing I wouldn't be a linux user.... or a phd student :D
15:25:32 <applicative> hemmie: good good.
15:25:33 <hemmie> thanks for the help anyway :)
15:26:13 <FreeFull> How would I go about memoising http://dpaste.org/BC75t/ ?
15:26:59 <mauke> :t even
15:27:01 <lambdabot> Integral a => a -> Bool
15:27:05 <applicative> there is also bypassing your package manage and having a local ghc and cabal which is surprisingly easy with http://www.haskell.org/ghc/download_ghc_7_6_1#binaries and maybe monochroms advice page
15:28:18 <simpson> FreeFull: You could snap Data.MemoCombinators or something similar over it.
15:28:23 <Taneb> How do I tell GHCi that Data.FamilyTree is in the same directory as the other module you just loaded?
15:28:25 <monochrom> and monochrom's advice page is http://www.vex.net/~trebla/haskell/haskell-platform.xhtml
15:28:31 <simpson> FreeFull: But it mostly depends on how you want to look up things in the memoized version.
15:28:32 <applicative> oh here http://www.vex.net/~trebla/haskell/haskell-platform.xhtml you don't actually need the platfrom
15:28:48 <monochrom> but wait, if you go Haskell Platform, you cannot use 7.6.1
15:29:19 <monochrom> (well, you can if you don't mind figuring out how to get a few libs to build)
15:29:20 <mauke> :t let cols = 0 : 1 : map (\x -> x : (cols !! step x)) [2 ..] where step n = if even n then n `div` 2 else n * 3 + 1 in cols
15:29:22 <lambdabot>     No instance for (Num [Int])
15:29:22 <lambdabot>       arising from the literal `0'
15:29:22 <lambdabot>     Possible fix: add an instance declaration for (Num [Int])
15:29:27 <applicative> monochrom: I think he doesn't need the platform, the boot libs are enough for pandoc. he would need a new cabal-install
15:29:32 <mauke> :t let cols = [] : [1] : map (\x -> x : (cols !! step x)) [2 ..] where step n = if even n then n `div` 2 else n * 3 + 1 in cols
15:29:33 <lambdabot> [[Int]]
15:29:40 <mauke> > let cols = [] : [1] : map (\x -> x : (cols !! step x)) [2 ..] where step n = if even n then n `div` 2 else n * 3 + 1 in cols
15:29:41 <lambdabot>   [[],[1],[2,1],[3,10,5,16,8,4,2,1],[4,2,1],[5,16,8,4,2,1],[6,3,10,5,16,8,4,2...
15:29:50 <hemmie> applicative: yeah I think I need to go this route since apt-get is telling me haskell-platform is at the latest version :/
15:29:56 <monochrom> alright good, my page has enough for GHC itself :)
15:30:01 <simpson> > let col x | even x = div x 2; col x = 3 * x + 1 in iterate col 15 -- FreeFull
15:30:03 <lambdabot>   [15,46,23,70,35,106,53,160,80,40,20,10,5,16,8,4,2,1,4,2,1,4,2,1,4,2,1,4,2,1...
15:30:26 <simpson> mauke: Nice.
15:30:34 <FreeFull> simpson: Of course you'll note my version stops when it hits 1
15:30:39 <simpson> FreeFull: Sure.
15:31:05 <hemmie> monochrom: ok thanks I'll give that a try
15:31:41 <mauke> > let cols = [] : [1] : map (\x -> x : (cols !! step x)) [2 ..] where step n | (n', 0) <- n `divMod` 2 = n' | otherwise = n * 3 + 1 in cols
15:31:43 <lambdabot>   [[],[1],[2,1],[3,10,5,16,8,4,2,1],[4,2,1],[5,16,8,4,2,1],[6,3,10,5,16,8,4,2...
15:31:53 <FreeFull> mauke: Making it into an infinite list is clever
15:32:17 <applicative> hemmie: monochrom 's structure is the one I use; I think the principal trouble will be building a new cabal-install since the old one might not be able to build the newone
15:32:19 <simpson> FreeFull: Also unfoldr, from Data.List, could be useful.
15:32:37 <mauke> > let cols = [] : [1] : map ((:) <*> (cols !!) . step) [2 ..] where step n | (n', 0) <- n `divMod` 2 = n' | otherwise = n * 3 + 1 in cols
15:32:40 <lambdabot>   [[],[1],[2,1],[3,10,5,16,8,4,2,1],[4,2,1],[5,16,8,4,2,1],[6,3,10,5,16,8,4,2...
15:33:28 <FreeFull> What does  (n', 0) <- n `divMod` 2   do here?
15:34:14 <Rarrikins> FreeFull: Gets the quotient into n' if the remainder is zero.
15:34:19 <applicative> hemmie, you would use the makefile in the source for http://hackage.haskell.org/package/cabal-install-1.16.0.2
15:34:32 <monochrom> eh? use bootstrap.sh
15:34:37 <mauke> :t divMod
15:34:38 <lambdabot> Integral a => a -> a -> (a, a)
15:34:49 <simpson> > let pair x = (x, x); col 1 = Nothing; col x | even x = Just . pair $ div x 2; col x = Just . pair $ 3 * x + 1 in unfoldr col 15 -- I am so inelegant today :c
15:34:51 <lambdabot>   [46,23,70,35,106,53,160,80,40,20,10,5,16,8,4,2,1]
15:35:01 <applicative> hemmie: or, follow monochrom s advice which will always be better, when you can get it :)
15:35:08 <FreeFull> :t divMod
15:35:09 <lambdabot> Integral a => a -> a -> (a, a)
15:35:45 <FreeFull> Oh, mauke already did it
15:35:51 <monochrom> well, I never read that makefile, I just don't know whether it works or not. I have only used bootstrap.sh and it works
15:36:14 <monochrom> and I have read it and know what it does
15:36:33 <FreeFull> Rarrikins: So  (n', 0) <- n `divMod` 2   evaluates of true and assigns n' to the quotient?
15:36:51 <FreeFull> But only if the pattern matches?
15:36:57 <applicative> monochrom: yeah,  I should have have stopped at saying his old cabal-install is unlikely to be able to build a new one
15:37:09 <rwbarton> it's a pattern guard
15:37:26 <hemmie> ok getting a small bit confused now -- you're saying install the platform from source and then, when installation of cabal-install fails, execute bootstrap.sh?
15:38:05 <rwbarton> FreeFull: do you know how regular guards work?
15:38:09 <mzero> my goodness… I haven't been following …. but what's that?
15:38:29 <mzero> what system are you trying to install on, hemmie ?
15:38:30 <monochrom> n `divMod` 2 may give you (3,1) or (3,0). (I'm making up "3"). in case of (3,1), it's a pattern-match failure, try next pattern. in case of (3,0), it's a match, let n' be 3 and continue
15:38:31 <FreeFull> rwbarton: Yeah
15:38:46 <rwbarton> FreeFull: a pattern guard is similar but instead of an expression that evaluates to True or False, you have a "pattern <- expression"
15:38:48 <monochrom> there is no True or False involved
15:39:04 <hemmie> mzero: just the most recent ubuntu
15:39:16 <FreeFull> Can you mix pattern guards and regular guards?
15:39:23 <applicative> hemmie: no, I was thinking that you weren't going to install the whole platform. for one thing, then you;d have ghc-7.4, which isn't a bad idea probably
15:39:34 <hemmie> ah, ok
15:39:37 <Rarrikins> > let colls = [0]:[1]:map coll [2..]; coll n = f n where f 1 = [1]; f n' = if n' < n then colls !! n' else n':f (if even n' then div n' 2 else 3*n' + 1) in colls
15:39:38 <rwbarton> if the expression matches the pattern then the right-hand side of that guard is used as the value of whatever you're defining, with possibly some variables bound by the pattern
15:39:39 <lambdabot>   [[0],[1],[2,1],[3,10,5,16,8,4,2,1],[4,2,1],[5,16,8,4,2,1],[6,3,10,5,16,8,4,...
15:39:53 <Rarrikins> Now with reuse of previously-made lists!
15:40:07 <rwbarton> if the expression doesn't match the pattern then you go on to the next guard, like if a regular guard expression evaluated to False
15:40:11 <mauke> Rarrikins: huh?
15:40:27 <applicative> hemmie: there are versions of ghc-7.4 http://www.haskell.org/ghc/download_ghc_7_4_2
15:41:32 <Rarrikins> mauke: When the value gets below the start value, it reuses the chain for that lower value as the tail of the result.
15:41:49 <hemmie> so I install ghc 7.4, and then use monochrom's instructions to compile and install the rest of the platform?
15:42:09 <mauke> Rarrikins: why not always reuse the chain?
15:42:14 <monochrom> you can do that. though I don't know what you prefer
15:42:31 <applicative> hemmie: actually, you may be able to use the existing cabal-install with that one, doing cabal --with-compiler=/Users/applicative/h/bin/ghc --with-ghc-pkg=/Users/applicative/h/bin/ghc-pkg install in  the pandoc source
15:42:52 <mzero> hemmie - this is because you want HP 2012.4.0.0? Otherwise just use the HP 2012.2.0.0 that is in the package repos
15:43:12 <mzero> no need to hand install anything, then
15:44:09 <Rarrikins> mauke: How would you do that?
15:44:11 <applicative> hemmie: I take back what Isaid about your old cabal-install, I was going by a bit of the ghc page that is getting updated...
15:44:56 <FreeFull> > xor <$> [0..15] <*> [0..15]
15:44:57 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,1,0,3,2,5,4,7,6,9,8,11,10,13,12,15,1...
15:45:05 <mauke> Rarrikins: uh. like the code I wrote above?
15:45:15 <applicative> mzero: hemmie seemed to be saying ghc-7.0.x was the haskell platfrom in his repo
15:45:54 <mzero> http://packages.ubuntu.com/search?keywords=haskell-platform
15:46:06 <mzero> that seems to say for quantal or raring, you've got 2012.2.0.0
15:46:09 <mzero> which is 7.4.1
15:46:10 <hemmie> yes, HP 2011.2.0.1.2  -- which makes it clear that I'm not on the most recent ubuntu after all I think
15:46:25 <mzero> oh - Oneriric?
15:46:34 <applicative> mzero: but it seems he needs a more recent one to build the development version of pandoc
15:46:42 <Rarrikins> mauke: That's pretty neat :)
15:46:52 <hemmie> I've no idea about the names -- what's the command to get the full name?
15:46:56 <applicative> mzero: Oneiric is what I was wondering.
15:46:58 <mzero> ah - pandoc , ever-growing-monster of goodness
15:47:14 <FreeFull> Thanks for the help guys, I will meditate on your code
15:47:23 <mauke> I will meditate and then destroy you
15:47:32 <applicative> hemmie: well, it could be worse you could studying haskell after installing it; that was my ruin...
15:47:38 <FreeFull> mauke: And then?
15:48:13 <mauke> hover, I guess
15:48:28 <mzero> hemmie: cat /etc/lsb-release
15:48:53 <Fuuzetsu> Is there a tool that will look at your file(s) and produce a dependency list for cabal?
15:49:03 <applicative> hemmie: mzero is haskell-platform tsar
15:49:11 <FreeFull> I wonder how good Haskell is for code golf compared to other languages
15:49:12 * mzero bows
15:49:13 <monochrom> note this strangeness: ubuntu quantal has ghc 7.4.2 and haskell-platform 2012.2
15:49:47 <hemmie> ok, yeah, oneiric
15:49:51 <mzero> FreeFull: it is good w.r.t. the other production languages - it is bad w.r.t. to special purpose golf languages
15:50:18 <applicative> special purpose golf languages?
15:50:36 <mzero> yeah - they exist
15:50:36 * applicative proposes to write one
15:50:52 <Fuuzetsu> you mean perl?
15:51:09 <mauke> FreeFull: you can check http://golf.shinh.org/
15:51:11 * applicative thought perl-6 maybe since the others are used in production
15:51:24 <hemmie> how about I install the most recent ghc from source using my current one, and then update the packages I need?
15:51:26 <mauke> perl-6 wasn't designed for golf
15:51:40 <mauke> golfscript was
15:52:06 <monochrom> there is no need to build ghc from source
15:52:37 <hemmie> monochrom: ok install a recent binary
15:52:41 <monochrom> although, if you still feel like it, my page suggests watching a long movie while you wait
15:53:10 <monochrom> perhaps The Hobbits
15:53:19 <applicative> hemmie: oh yeah wasnt i pointing to the binary thing>
15:53:22 <hemmie> wow, that long?
15:53:47 <monochrom> I don't actually know. I have lost track of recent computer fastness
15:53:56 <tsuraan_> I have a simple typeclass that just defines access to some data, and a trivial implementation of it, using a Reader monad.  If I make my implementation using entirely type constraints, it works, but I think that's the wrong way to go about it.  If I try to make a specific instance for a ReaderT monad, then my code doesn't work.  The working but ugly code is at http://hpaste.org/79931, and the one that doesn't work is at http://hpaste.org/79932
15:54:01 <applicative> hemmie: it's crazy, though if you are an enthuiast and recovering from something, there is a certain pleasure....
15:54:03 <hemmie> applicative: yeah ok get a recent ghc in binary, but then: install platform, or just update packages individually?
15:54:28 <tsuraan_> can somebody explain why the second way of doing the type instance seems to promote the IO monad all the way through the transformer stack?  At least, I think that's what's happening
15:55:02 <rwbarton> what does "doesn't work" mean
15:55:03 <tsuraan_> and also, the "right way" snippet might not need all those language extensions, but the "wrong way" one does
15:55:04 <applicative> hemmie: my minimalist thought was, then install cabal install -- the version will have to agree with the ghc version in a way that can be explained
15:55:11 <tsuraan_> rwbarton: won't compile
15:55:21 <rwbarton> paste the error message
15:55:22 <hemmie> applicative: gotcha
15:55:51 <tsuraan_> http://hpaste.org/79933
15:56:11 <applicative> hemmie: my thought is, the libraries that are in the binary package -- which include the Cabal library but not cabal-install the executable -- will be enough to install pandoc
15:57:01 <tsuraan_> rbarton: so it seems to be using the ErrorT specialization for IOException IO, but I don't see why it would do that when I specify ErrorT/ReaderT but not when I'm using MonadError/MonadReader
15:57:13 <hemmie> applicative: but I'm interested in the broader haskell ecosystem as well, so that would be a good setup to start from, or should I just wipe everything and get the platform?
15:58:37 <applicative> hemmie: then,  I think you can follow monochrom 's page, but this will require ghc-7.4.x as substratum?
15:58:39 <rwbarton> tsuraan_: well look at the instance on line 19 of the non-working version
15:58:41 <shirt> how can i specify in a .cabal file the minimum version of GHC that is required?
15:59:06 <rwbarton> you're defining an instance for ErrorT MyError m but you require that *m* have a MonadMyError instance
15:59:10 <rwbarton> surely that's not what you meant?
15:59:28 <monochrom> usually, people use "base"s version to indirectly say GHC's version
15:59:44 <rwbarton> ErrorT MyError m already has a MonadMyError instance, regardless of what m is
15:59:52 <monochrom> "base >= 6" is a way to say "a future GHC"
15:59:57 <applicative> shirt: if impl(ghc < 7.8) then explode else ...
16:00:39 <shirt> applicative: thanks, i'll look into this
16:00:43 <monochrom> but impl(ghc < 7.8) is better
16:01:18 <tsuraan_> rwbarton: I think that entire instance is junk
16:01:26 <tsuraan_> give me a sec :)
16:01:44 <hemmie> applicative: I'll install 7.4.2 from binary, then monochrom's instructions for the platform
16:02:12 <hemmie> and wipe my current ~/.cabal for good measuer
16:02:28 <monochrom> don't forget ~/.ghc
16:03:05 <rwbarton> yeah, upon further inspection, shouldn't that instance not compile at all
16:03:10 <rwbarton> because where is MonadReader coming from
16:03:25 <tsuraan_> rwbarton: http://hpaste.org/79934 has a less stupid implementation, but the same compile error
16:03:46 <rwbarton> you still have the error because of MonadGetNumber m
16:04:02 <rwbarton> you sort of painted yourself into a corner here
16:04:23 <rwbarton> because you made getNumber a method of a class that has MonadMyError as a superclass
16:05:07 <rwbarton> in the line 19 instance you want to use the getNumber from m but you don't want to use the MonadMyError from m
16:05:56 <rwbarton> I would remove "MonadMyError m, MonadIO m" from the superclasses on line 13, and then rearrange stuff as necessary
16:06:09 <hemmie> monochrom: ok thanks a lot
16:06:30 <tsuraan_> the actual implementation of "getNumber" does some network activity that can fail though
16:06:41 <tsuraan_> this is a bit condensed
16:06:44 <rwbarton> oh, well
16:06:47 <rwbarton> wait
16:06:58 <rwbarton> there is no "actual implementation" in the *class*, so that's no problem surely
16:07:39 <tsuraan_> but if the method does IO that can fail, doesn't the class need to have MonadIO and MonadError constraints?
16:07:58 <tsuraan_> or do I want the constraints on the method?  somehow that hadn't occurred to me
16:08:12 <tsuraan_> is that even possible?
16:08:13 <rwbarton> why? the class just specifies that the method exists
16:08:18 <rwbarton> it is possible
16:08:28 <rwbarton> I think?
16:08:45 <tsuraan_> (MonadGetNumber m) defines the monad that getNumber runs in
16:08:53 <rwbarton> well
16:08:58 <rwbarton> I think this is too simplified, then
16:09:01 <tsuraan_> so the constraints on getNumber's m have to be the same as those on MonadGetNumber, don't they?
16:09:05 <rwbarton> and wouldn't reflect a real problem
16:09:15 <tsuraan_> it gives the same compile error :)
16:09:23 <tsuraan_> but true, it is simplified
16:09:42 <monochrom> if you have (MonadIO m, MonadError e m), and m becomes IO, then e must be IOException. this is fundep's doing
16:10:05 <tsuraan_> why doesn't m become IO in http://hpaste.org/79931 ?
16:10:27 <monochrom> it goes more general. if m is "blahblahT (mumblemubleT IO)", e must still be IOException
16:10:43 <rwbarton> generic :: ErrorT MyError (ReaderT Int IO) by lines 19 & 30
16:10:57 <monochrom> because of "MonadError e m => MonadError e (ReaderT r m)" etc
16:11:12 <rwbarton> except when blahblahT = ErrorT
16:11:18 <rwbarton> or ErrorT e rather
16:11:24 <rwbarton> or better ErrorT e'
16:11:25 <rwbarton> then e = e'
16:11:26 <covi> If xs :: [a] and x :: a, what's the difference between  x:xs  and  [x]++xs
16:11:28 <monochrom> ah, ok, good exception
16:11:35 <monochrom> yikes, no pun intended!
16:12:28 <mauke> @src (++)
16:12:28 <lambdabot> []     ++ ys = ys
16:12:28 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
16:12:28 <lambdabot> -- OR
16:12:28 <lambdabot> xs ++ ys = foldr (:) ys xs
16:12:43 <monochrom> my real question is why MonadIO is involved in the first place. it reduces your freedom
16:12:59 <tsuraan_> how so?
16:13:08 <mauke> covi: [x]++xs ==> x : ([] ++ xs) ==> x : xs
16:13:24 <rwbarton> maybe we should start with why are you defining type classes at all
16:13:47 <covi> mauke: So there's no difference in efficiency?
16:14:12 <tsuraan_> I have a code base that does data processing.  The two major parts are an encryption area, and a data storage area
16:14:26 <mauke> covi: why do you care?
16:14:27 <rwbarton> if you're putting superclasses on class MonadGetNumber because "the implementation needs MonadIO" then I don't think you want a class
16:14:48 <tsuraan_> so, at the top level, I can push all the information about keys, getting keys, storage, etc through all the functions that live above the encryption and data storage
16:15:03 * `nand` wonders if the compiler would optimize out [x]++xs
16:15:05 <applicative> covi, well, there's at least the two steps  mauke exhibited...
16:15:27 <tsuraan_> but that keeps getting uglier and uglier, so I put type constraints on the lowest-level functions (the ones that need keys, and the ones that need stoorage info), and then I'm letting the type classes propogate upwards
16:16:14 <tsuraan_> but if you have some function that wants to use a MonadError, and it does IO, then it needs to use MonadIO as well, doesn't it?
16:16:21 <tsuraan_> is there a way around that?
16:16:25 <rwbarton> but it doesn't need to go in the *class*
16:16:29 <rwbarton> that is the whole point
16:16:40 <rwbarton> the class does not care about your implementation(s)
16:16:48 <rwbarton> the instance(s) care
16:16:55 <tsuraan_> so if the class defines a function that can fail, or that does IO, then the class cares, doesn't it?
16:17:07 <rwbarton> all you wrote is getNumber :: m Int
16:17:36 <tsuraan_> but if some other implementation gets the number off a network, and fails sometimes...
16:17:58 <rwbarton> then for *that instance* m will be a monad that represents effects like networks and failure
16:18:02 <rwbarton> the class still does not care
16:18:43 <tsuraan_> so if the class looks like "class Monad m => MonadGetNumber m where getNumber :: Int"
16:18:59 <mauke> m Int?
16:18:59 <tsuraan_> then how can an implementation define a getNumber that fails?
16:19:07 <tsuraan_> oh
16:19:13 <tsuraan_> ok
16:19:18 <tsuraan_> that makes a lot of sense, mauke
16:19:24 <rwbarton> instance MonadGetNumber (EitherT Foo IO) where ...
16:19:37 <tsuraan_> rwbarton: ok, that is just simple
16:19:50 <tsuraan_> yeah, I totally overthought things
16:19:54 <tsuraan_> or maybe underthought?
16:20:19 <tsuraan_> anyhow, I'll see what I can do.  at any rate, I think that makes a lot of sense.  Thanks all!
16:25:12 <tsuraan_> wow, stripping all the constraints out of the class totally works.  sweet :)
16:25:38 <tsuraan_> and not surprising, now that I am starting to have some understanding of what it does
17:06:26 <Diabellical> all: has anyone looked at the lectures for 61A at Berkeley?
17:07:45 <harrison> http://www.youtube.com/watch?v=w2Q2Q9ou2io&feature=youtu.be
17:08:03 <harrison> I considered coding the tracer in a functional language
17:08:15 <harrison> but that was back in 2004 or so
17:08:48 <harrison> and there wasn't a multicore ML, I recall, or Haskell either
17:08:54 <harrison> so i used Oberon
17:11:57 <aristid> harrison: haskell did exist in 2004
17:14:03 <coleman-> why does `pure 10' return 10, and not Ambiguous type exception?
17:14:31 <`nand`> coleman-: in what context?
17:14:31 <c_wraith> ambiguous types result in compile errors, not exceptions
17:14:47 <coleman-> `nand` I typed it in ghci
17:15:13 <`nand`> GHCi has some.. rather interesting typing rules as I recall it. It's probably being interpreted as IO
17:15:24 <c_wraith> ghci has extended defaulting rules.  One of them is "an expression of type Monad m => m a gets defaulted to IO a"
17:15:33 <`nand`> yeah that
17:16:01 <c_wraith> especially top-level expressions, which if they are IO actions, ghci will execute
17:16:14 <`nand`> and then show the result, unless it isn't an instance of Show!
17:16:18 <harrison> aristid: Haskell, yes, of course! Not a multicore one that was ready for coding my project -- at least not that I found
17:16:20 <coleman-> ok got it
17:16:31 <aristid> harrison: oh
17:16:37 <c_wraith> `nand`: it also won't show a () from an IO () :)
17:16:44 <harrison> I was hoping for john reppy's "manticore" but it never arrived
17:16:45 <c_wraith> That one's a special case
17:16:50 <`nand`> makes sense
17:17:08 <harrison> (manticore is ml not haskell)
17:17:09 * hackagebot hdevtools 0.1.0.5 - Persistent GHC powered background server for FAST haskell development tools  http://hackage.haskell.org/package/hdevtools-0.1.0.5 (BitConnor)
17:22:44 <rwbarton> it's not actually defaulting in this case, is it
17:23:17 <rwbarton> just the fact that it tries to type check the expression first as IO foo
17:23:31 <rwbarton> pure 10 `seq` () is an ambiguous type error
17:23:36 <parcs> that's not totally true. ghci tries to interpret an expression three ways, as follows (assume e is the expression inputted): 1) 'do { it <- e; print it }' 2) 'do { it <- e }' 3) 'do { let it = e; print it }'
17:23:40 <covi> @src seq
17:23:41 <lambdabot> Source not found. :(
17:23:53 <covi> What does `seq` do?
17:24:36 <mauke> 0) do { it <- e :: IO () }
17:24:41 <parcs> so with e = pure (), the first way succeeds since IO is an Applicative and () gets printed
17:25:07 <ivanm> covi: evaluates the outer constructor
17:25:10 <ivanm> it's a built in
17:25:15 <ivanm> @hoogle seq
17:25:17 <lambdabot> Prelude seq :: a -> b -> b
17:25:17 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
17:25:17 <lambdabot> Control.Monad sequence :: Monad m => [m a] -> m [a]
17:26:01 <ivanm> "Evaluates its first argument to head normal form, and then returns its second argument as the result."
17:26:05 <parcs> er, sorry, () doesn't get printed if 'it' has type ()
17:26:20 <c_wraith> *weak* head normal form
17:26:36 <c_wraith> The difference being that it doesn't evaluate the body of a function under a lambda
17:26:40 <ivanm> c_wraith: blame the haddocks!
17:26:53 <ivanm> I just grabbed that thanks to chrisdone's haskell-docs
17:26:59 <c_wraith> It just says "hey, this is a function, I'm done!"
17:27:14 <parcs> here's the code if you're curious https://github.com/ghc/ghc/blob/master/compiler/typecheck/TcRnDriver.lhs#L1371
17:27:45 <c_wraith> (lambda calculus is more strict, defining head-normal form that actually does something to functions)
17:39:11 <coleman-> in LYAH chapter 8 author made a Set-like data structure an instance of a functor class. isn't this wrong? afaics it doesn't obey fuctor law.
17:39:23 <coleman-> functor law*
17:39:53 <shachaf> A link would be helpful.
17:40:17 <coleman-> http://learnyouahaskell.com/functors-applicative-functors-and-monoids
17:40:27 <coleman-> he called it a tree but it's really a Set, it only has keys
17:40:41 <shachaf> That's not even chapter 8. :-(
17:41:01 <coleman-> wrong link then
17:41:12 <coleman-> http://learnyouahaskell.com/making-our-own-types-and-typeclasses#the-functor-typeclass
17:41:18 <shachaf> Anyway, that "data Tree" looks like a functor to me.
17:41:34 <JoeyA> Poll: if hGetSome returns a smaller string than requested, what you expect a subsequent hGetSome call to do?
17:42:02 <c_wraith> coleman-: which type?
17:42:10 * hackagebot shelltestrunner 1.3.1 - A tool for testing command-line programs.  http://hackage.haskell.org/package/shelltestrunner-1.3.1 (SimonMichael)
17:42:32 <coleman-> shachaf how? fmap works on keys. if you do fmap show key on a Tree of ints it is no longer a valid Set, and it= is different than if you show each int before inserting it
17:42:46 <c_wraith> coleman-: Tree is not a set.
17:42:56 <c_wraith> coleman-: Tree is any tree structure, not a binary search tree
17:43:02 <coleman-> it is a set not a tree
17:43:16 <c_wraith> coleman-: then what type are you talking about?
17:43:26 <coleman-> about a Set-like type which he named a Tree
17:43:27 <mauke> how is it not a functor?
17:43:34 <shachaf> Are we talking about "data Tree a = EmptyTree | Node a (Tree a) (Tree a) deriving (Show, Read, Eq)"?
17:43:40 <c_wraith> What makes you think it's setlike?
17:43:42 <coleman-> yes
17:43:49 <c_wraith> You can store 5000000 of the same element in it
17:43:53 <coleman-> c_wrait it only contains keys, not values
17:43:53 <c_wraith> that's nothing like a set
17:44:04 <mauke> coleman-: it only contains values, not keys
17:44:15 <coleman-> exactly
17:44:23 <mauke> so you're not making any sense
17:44:26 <coleman-> c_wraith you can't, see the insert function. it is just like a set
17:44:27 <c_wraith> It's a tree, not a set
17:44:36 <mauke> functions don't matter
17:45:02 <coleman-> c_wraith is it a tree and not a set if his implementation of fromList [1,1,1,2] makes Set store just 1 and 2?
17:45:09 <shachaf> > insert 5 [1,2,6,8,10] -- all lists are sorted!
17:45:11 <lambdabot>   [1,2,5,6,8,10]
17:45:23 <mauke> what is Set?
17:46:03 <Saizan> coleman-: the fact that it can be used to implement a set-like inteface doesn't mean it's only meant to be that
17:46:06 <coleman-> he made a Set like data structure and called it a Tree. and then he made it a Functor instance
17:46:19 <mauke> "Set like data structure" is meaningless
17:46:21 <Saizan> coleman-: especially when the data constructors are exported
17:46:42 <coleman-> Saizan that is the only way he used it though. poor example of a functor
17:47:12 <mauke> coleman-: why is it a poor example of a functor?
17:47:17 <coleman-> and it took me reading a couple of more chapters to figure it out. at the very least it's misleading
17:47:20 <shachaf> welcome bauke
17:47:25 <sclv> its a much better functor than a set
17:47:33 <coleman-> mauke can Data.Set be a functor?
17:47:40 <mauke> coleman-: I don't know
17:47:43 <sclv> no
17:47:48 <sclv> because of the ord constraint
17:47:54 <Saizan> not a Functor at least
17:47:55 <coleman-> sclv exactly.
17:48:03 <shachaf> @orrd
17:48:04 <lambdabot> Ahoy mateys
17:48:06 <mauke> coleman-: do you have a point?
17:48:32 <shachaf> This Tree here is pretty different from Data.Set
17:48:37 <coleman-> mauke you can't tell whether Data.Set can be a functor, so my poinprobably went over your head
17:48:46 <mauke> coleman-: I'll take that as a no
17:48:52 <coleman-> as you wish
17:48:54 <shachaf> > insert 5 [1,2,4,8] -- Is [] a functor?
17:48:56 <lambdabot>   [1,2,4,5,8]
17:49:15 <sclv> he never said tree was a set
17:49:19 <sclv> he said you could use it as a set
17:49:22 <sclv> i just checked the book
17:49:23 <sclv> i
17:49:28 <mauke> shachaf: no, because when you call (show [1,2,3]) it's no longer an int
17:49:29 <coleman-> he implemented it as a set, and used it as a set
17:49:46 <shachaf> mauke: Good point.
17:49:55 <shachaf> He implemented it as a tree.
17:49:56 <sclv> i read the book, the distinction beween tree being used as a set and tree being a set was made clearly
17:50:02 <shachaf> Here's the implementation:
17:50:02 <shachaf> data Tree a = EmptyTree | Node a (Tree a) (Tree a) deriving (Show, Read, Eq)
17:50:19 <sclv> i'll grant that since you were confused, he cold have been clearer still
17:50:20 <cmccann> Data.Set is a perfectly reasonable functor if you consider the subcategory of Hask where the objects are all types with Ord instances
17:50:25 <sclv> since, emperically, somebody missed the point
17:50:39 <cmccann> but that's not what Functor is
17:52:59 <shachaf> Data.Set may not be a Functor, but you can write a Setter for it.
17:53:06 <shachaf> Not too surprising, given the name.
17:53:27 <coleman-> shachaf if Data.Set exposed it's constructors you wouldn't mind if it was a Functor instance?
17:53:30 <mauke> hah
17:53:31 <`nand`> shachaf: groan
17:54:01 * cmccann gives shachaf a s t a b
17:54:31 <cmccann> if Data.Set exported its constructors it wouldn't be Data.Set in any useful way
17:54:41 <cmccann> this is a very silly line of conversation.
17:55:15 <coleman-> you are defending the author on technicality even though he screwed up twice, called a set a tree, and then made it a functor
17:55:25 <sclv> I wrote an intmap like this: type IntMap a = [(Int,a)]
17:55:30 <sclv> but the functor instance is terrible!
17:55:33 <sclv> haskell is a crummy language
17:55:40 <sclv> clearly the authors of the prelude screwed up big time
17:55:43 <coleman-> sclv silly analogy
17:56:01 <sclv> nobody needs to defend LYAH. it is a well regarded and popular book.
17:56:05 <mauke> coleman-: stop being a dick
17:56:08 <HugoDaniel> hi
17:56:12 <coleman-> mauke go fuck yourself
17:56:17 <cmccann> oh boy
17:56:21 <Jafet> You are feeding a troll even though he's screwing up almost every argument
17:56:22 <sclv> obscenity is not welcome on this chanel
17:56:24 --- mode: ChanServ set +o mauke
17:56:24 <sclv> @where ops
17:56:25 --- mode: mauke set +b *!*@lap.ee
17:56:25 <lambdabot> arjanb bos Cale conal copumpkin dcoutts dibblego dons edwardk glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih mauke monochrom Philippa Pseudonym quicksilver roconner Saizan shapr sjanssen ski
17:56:25 <lambdabot> wli xerox
17:56:27 <ivanm> people! we're meant to be all polite and stuff here!
17:56:35 <HugoDaniel> ouch
17:56:38 <`nand`> what is this, #lisp night or something?
17:56:39 <HugoDaniel> things are hot around here
17:56:43 <c_wraith> sclv: mauke *is* an op. :P
17:56:52 <sclv> yeah, i just like making the point :-)
17:56:58 <HugoDaniel> what is happening ?
17:57:06 <HugoDaniel> still arguing about python vs haskell ?
17:57:08 <sclv> just a polite disagreement escalated
17:57:08 <mauke> wtf
17:57:11 <sclv> no big deal
17:57:11 <`nand`> something about sets and functors
17:57:16 <mauke> who added me to @where ops?
17:57:23 <`nand`> monochrom perhaps
17:57:33 <`nand`> he updated the list earlier
17:57:35 <mauke> sigh
17:57:39 <Jafet> mauke's secret identity is revealed
17:57:42 <Jafet> News at nine
17:57:45 <HugoDaniel> :D
17:57:48 <shachaf> If you are an op you probably belong on @where ops
17:57:54 <`nand`> ^
17:58:08 <cmccann> Jafet, and here I thought mauke was secretly batman
17:58:14 <mauke> @where+ ops arjanb bos Cale conal copumpkin dcoutts dibblego dons edwardk glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom Philippa Pseudonym quicksilver roconner Saizan shapr sjanssen ski wli xerox
17:58:14 <lambdabot> Done.
17:58:24 --- mode: mauke set -o mauke
17:58:30 <ivanm> mauke: why don't you want to be known as an op?
17:58:37 <shachaf> I don't think being an op is meant to be *only* "ban people who are rude to you" power.
17:58:44 <Jafet> Because entrapment is legal on irc
17:58:51 <`nand`> I don't think it's about being known or not, perhaps about being highlighted?
17:59:04 <mauke> ivanm: mu
17:59:08 <sclv> yeah i can imagine that when people ask for the ops its irritating to be on call
17:59:15 <HugoDaniel> irc is all about the kick :)
17:59:20 <shachaf> sclv: Then why be an op?
17:59:22 <ivanm> with great power comes great responsibility, etc. ?
17:59:24 <`nand`> sclv: but isn't that the point?
17:59:26 <ivanm> shachaf: exactly
18:00:23 <mauke> shachaf: why is @where ops a list of names?
18:00:41 <pnielsen> mauke: to ping them
18:00:44 <pnielsen> I guess
18:00:47 <ivanm> mauke: so that when someone is spamming the channel, people can go "@where ops" to get the attention of someone that is an op
18:00:58 <mauke> ivanm: non sequitur
18:01:20 <Jafet> Perhaps a bat-floodlight is less intrusive.
18:01:24 <Saizan> ivanm: mauke is already highlighted by @where ops
18:01:36 <Saizan> ivanm: i.e. the command itself
18:01:45 <ivanm> oh?
18:02:12 <Saizan> it's easy to set up your irc client to do that
18:02:16 <ivanm> mauke: how is it a non sequitur
18:02:38 <ivanm> Saizan: yeah, I've done it for similar things, but I didn't know mauke had done so
18:02:41 <mauke> ivanm: because people can go "@where ops" to get the attention of an op without there being a list of names
18:03:10 <ivanm> mauke: assuming every op sets up each and every IRC client they use to highlight "@where ops"
18:03:25 <mauke> yes
18:03:43 <mauke> with great power comes great responsibility, etc.
18:04:17 <ivanm> fails for cases where you're using a different computer than usual and thus a different client than usual
18:04:41 <Saizan> this argument is off-topic
18:04:50 <Saizan> there's #haskell-ops if you want to continue
18:05:13 <`nand`> presumably, each op can make his or her individual choice on whether or not to set up their IRC clients or add it to a list of names; so it's pointless trying to make a point for standardizing it
18:05:17 <pnielsen> why are people here so pissy about OT when there is no actual on-topic discussion going on?
18:05:49 <Saizan> pnielsen: prolonged OT actually hinders on-topic stuff from starting
18:05:51 <Jafet> pnielsen: the purpose of asking to move an unwanted topic to another channel is to kill it.
18:05:54 <pnielsen> I'd understand if somebody was asking a question
18:06:00 <johnw> I was just going to say what Saizan said
18:06:00 <pnielsen> heh, fair enough
18:06:06 <pnielsen> makes sense
18:06:55 <pnielsen> what Jafet said, not about preventing something from starting
18:07:08 <pnielsen> if that were the case, you wouldn't stand a chance of getting an answer in #ubuntu :p
18:07:48 <ivanm> OK, here's an on-topic question: where can I find details about what fusion does in Vector (without actually pouring through all the code)?
18:08:17 <ivanm> I'm trying to determine whether my use-case will get fused or result in lots of O(n) re-allocations
18:08:27 <pnielsen> ivanm: shachaf gave me a list of GHC flags recently, let me try to find it
18:08:46 <ivanm> pnielsen: what does GHC flags have to do with how Vector implements fusion? :/
18:08:58 <pnielsen> seeing what rewrite rules are triggered
18:09:02 <c_wraith> ivanm: compile it and see whether it allocates too much? :)
18:09:02 <Jafet> Presumably you want to look at whether RULES are used.
18:09:16 <ivanm> pnielsen: oh, right
18:09:37 <ivanm> I'm writing a library to be used for another library to be used for an application; I won't actually be able to test anything for a while :p
18:09:49 <Jafet> Though, there are libraries that don't rely on RULES for fusion. I believe repa is one.
18:10:22 <c_wraith> vector definitely uses rules, though.
18:10:29 <ivanm> *nod*
18:10:53 <pnielsen> ivanm: -ddump-rule-firings  -ddump-rule-rewrites  -ddump-rules
18:11:09 <ivanm> pnielsen: as I said, I'm a long way from actually being able to test this :)
18:11:17 <ivanm> so I'm just wondering what's the best way to write it
18:11:19 <pnielsen> fair enough
18:11:31 <shachaf> Cale: Can we have profunctors in lambdabot?
18:12:17 <pnielsen> ivanm: I'm no expert, but in general it seems you can reasonably expect anything in the same pipeline that is subject to fusion to be fused the "right way"
18:13:01 <pnielsen> I know, that was incredibly vague :)
18:13:32 <ivanm> specifically, I'll be at times wanting to grow the Vector; am I better just appending as many values as I need to the end, or doubling the length each time (which IIRC gives you asymptotic guarantees) even if that results in even more values to copy/re-allocate every time you change the Vector
18:13:34 <edwardk> shachaf: wait until we push 3.8 out ;)
18:13:54 <edwardk> it'd make a much easier sales pitch when there is code using it in the wild ;)
18:14:16 <shachaf> True.
18:14:28 <edwardk> ivanm: if its mutable? i'd go with the doubling strategy
18:14:39 <ivanm> edwardk: no, this is for pure Vectors
18:14:45 <edwardk> or multiply by some constant > 1 relative to its size
18:14:57 <shachaf> Even for (.), dimap f g k = g . k . f is a sort of useful pattern.
18:14:59 <ivanm> I've already got the doubling working for mutable vectors
18:15:18 <ivanm> if nothing else, abstracting all the functions I need into a class will make benchmarking different data structures easier :p
18:15:18 <shachaf> Well, maybe I just think that because of all the profunctor instances in k.hs
18:15:20 <edwardk> for immutable vectors appending is almost always a bad idea
18:15:53 <ivanm> edwardk: so is having a "large enough" Vector from the beginning even if you don't end up using all the values better?
18:16:05 <ivanm> (and thus doubling as necessary to prevent unneccessary appends)
18:16:20 <edwardk> shachaf: http://hpaste.org/79936 i'm wondering if something like that can solve our parallel sum needs
18:16:20 <edwardk> possibly with an unrolling for the 'list-like' case
18:17:14 <pnielsen> ivanm: that's what other languages do for arrays/slices at least, doubling the size of the array every time so that individual appends don't cause reallocs
18:17:55 <ivanm> pnielsen: yes, I know; I'm just not sure what the best approach for pure Vector values is
18:18:43 <edwardk> ivanm: if i'm writing into something that will fill up i grow it with 2x or 1.5x multipliers usually
18:18:52 <ivanm> even for pure ones?
18:19:34 <ivanm> that O(n) factor for updating values makes me consider trying to keep the Vector as small as possible (and thus only append a single value as necessary)
18:19:35 <edwardk> well, say you were deserializing from a Stream. it'd still be a 'pure' vector
18:19:51 <Jafet> Someone should make arrays that grow one page at a time.
18:20:11 <edwardk> when trying to figure out how to dump that to flat memory, i'd allocate slabs in ever growing sizes until i got one that fit
18:20:45 <edwardk> if i have to cons on one entry at a time, i'd hardly be using vector.
18:21:46 <ivanm> well, I wasn't planning on using Stream
18:25:11 <Saizan> doubling only makes sense if you can insert a bunch of elements without reallocating again, which takes a bit of ingenuity for a pure structure i think? since the extra memory is the same for any parallel use
18:26:26 <Saizan> but if you are e.g. implementing fromList and using mutability under the hood you should double there, assuming you don't want to take the length up front
18:26:59 <c_wraith> I thought people decided phi was the best multiplicative constant, for some reason.
18:27:02 <c_wraith> rather than 2
18:27:10 <ivanm> I'm wanting to use (Vector (Maybe a)) as a replacement of (IntMap a)
18:27:25 <ivanm> c_wraith: it definitely _sounds_ cooler :p
18:27:53 <c_wraith> ivanm: have you considered Seq (Vector (Maybe a)) ?
18:28:22 <ivanm> c_wraith: *shudders* I don't see that working well for lookups
18:28:48 <ivanm> even for insertions you'd still be dealing with either O(n) re-allocation to append it to the end of the last Vector
18:28:59 <c_wraith> well, it'd work really well with the original monoidally-annotated trees concept
18:29:24 <c_wraith> though I guess Seq doesn't expose that
18:29:35 <ivanm> thsi specifically is what I'm wanting to do: http://hub.darcs.net/ivanm/keyless-entry/browse/Data/Keyless.hs
18:35:09 <ivanm> unless I'm looking in the wrong place, I can't see any RULEs that apply to Data.Vector.//
18:35:19 <ivanm> unless it's due to all the inlining
18:56:24 --- mode: ChanServ set +o mauke
18:56:25 --- mode: mauke set -b *!*@lap.ee
18:58:25 --- mode: mauke set -o mauke
19:07:12 * hackagebot forml 0.1.3 - A statically typed, functional programming language  http://hackage.haskell.org/package/forml-0.1.3 (AndrewStein)
19:09:05 <PatrickRobotham> Don't we already have one of those?
19:09:57 <`nand`> one or two
19:10:17 <Jafet> Statically typed, functional programming languages for EVERYONE
19:10:53 <monochrom> until one of them becomes popular, we don't have enough of them
19:11:04 <Jafet> "Dear god I hope that isn't another ML"
19:11:17 <Jafet> (thankfully, it's actually derived from ruby?)
19:12:13 <`nand`> “Targets Javascript” oh great, we needed another one of those
19:12:48 <pnielsen> I heard you can compile Haskell to JavaScript
19:13:04 <`nand`> you can more or less
19:13:18 <`nand`> modulo what FFI you want to provide I guess. (C FFI is part of the Haskell standard, right?)
19:13:26 <monochrom> yes
19:13:41 <`nand`> of course, it's perfectly doable to provide a C FFI in a Javascript implementation
19:16:14 <pnielsen> >:)
19:19:03 <pnielsen> I wish browsers would just run sandboxed LLVM bytecode or something
19:19:12 <pnielsen> JavaScript as ASM for the web is pretty depressing
19:19:29 <Jafet> LLVM 0-days
19:20:04 <`nand`> clearly all browser scripting should be done in the pure untyped lambda calculus
19:20:06 <pnielsen> hence sandboxed
19:20:18 <pnielsen> chrome sandboxes nacl pretty well, actually
19:21:48 <M30W> withMPD $ do { x <- MPD.status; MPD.setVolume (MPD.stVolume x + 5)}
19:22:05 <M30W> Anyone see any way that could be cleaned up? x is used only once.
19:22:21 <`nand`> status >>= setVolume . (+5)
19:22:32 <M30W> `nand`: man I was close when trying
19:22:47 <Rarrikins> @undo do { x <- MPD.status; MPD.setVolume (MPD.stVolume x + 5)}
19:22:48 <lambdabot> MPD.status >>= \ x -> MPD.setVolume (MPD.stVolume x + 5)
19:22:48 <`nand`> oh
19:22:54 <`nand`>  . stVolume as well
19:22:57 <M30W> wiat no.
19:23:00 <M30W> lol yea
19:23:02 <`nand`> man, this thing needs like; lenses
19:23:21 <Rarrikins> @. pl undo do { x <- MPD.status; MPD.setVolume (MPD.stVolume x + 5)}
19:23:21 <lambdabot> MPD.setVolume . (5 +) . MPD.stVolume =<< MPD.status
19:23:53 <pnielsen> what is pl?
19:23:58 <pnielsen> is there a standalone version?
19:24:00 <Rarrikins> It's pointless.
19:24:05 <`nand`> it's contained in lambdabot
19:24:12 <pnielsen> Rarrikins: lol
19:24:17 <pnielsen> "pointless style"
19:24:26 <Rarrikins> ;)
19:24:30 <mikeplus64> is there some difference between using "ghc --make" and just "ghc" when building an executable?
19:24:30 <`nand`> I like to read it @perl
19:24:39 <Rarrikins> Haha
19:25:10 <Jafet> ghc --make is a flag that tells you to upgrade ghc
19:27:17 <lispy> pnielsen: there used to be a standalone version called GoA or ghci on acid. It was really a thing that made it so that you could invoke lambdabot from inside ghci.
19:27:32 <lispy> pnielsen: it's kind of fallen out of fashion. It's easier to just /query lambdabot
19:27:34 <`nand`> you can run lambdabot locally
19:27:39 <pnielsen> *nod*
19:27:52 <`nand`> or extract the source code!
19:28:13 <`nand`> http://code.haskell.org/lambdabot/Plugin/Pl/
19:28:45 <lispy> `nand`: honestly, I'd like to see lambdabot have a proper maintainer again. I run the server and Cale makes sure lambdabot is working and in the channel, but there is no current lambdabot champion making sure lambdabot gets new features and proper refactorings.
19:29:07 <Cale> I'd like to see a new IRC bot get written :)
19:29:07 <lambdabot> Cale: You have 1 new message. '/msg lambdabot @messages' to read it.
19:29:29 <pnielsen> wasn't lambdabot rewritten, or is in the process of being rewritten?
19:29:56 <hpc> i have a rather horrendous bot written in perl
19:30:00 <ninegrid_> i remember coming across a syllibus somewhere that mentioned in its project suggestions that writing a new lambdabot to take advantage of new features would be easy
19:30:03 <hpc> that is not quite an adequate substitute
19:30:04 <pnielsen> I thought I read somewhere a nice version of "the old code sucked so we're writing it from scratch":
19:30:08 <hpc> but is close
19:30:35 <lispy> Cale: what do you want to get out of a rewrite?
19:30:54 <`nand`> for one, the race conditions need to go away
19:30:56 <geekosaur> it was originally thought to be easy but I can recall at least one attempt that went awry fairly quickly
19:31:00 <`nand`> (the L.hs stuff)
19:31:23 <`nand`> for two, it needs to become less prone to going completely haywire when one thread crashes
19:31:30 <lispy> L.hs was a hack that took dons about 5 mintues :)
19:31:32 <hpc> the L.hs stuff goes away completely if we just stop allowing @let
19:31:49 <hpc> then we can even pre-compile it
19:32:02 <aavogt> there used to be a lunabot
19:32:03 <`nand`> can't you recompile on @let
19:32:08 <hpc> not easily
19:32:20 <hpc> mueval only seems to use existing binaries if it's in ghc-pkg
19:32:24 <`nand`> ah
19:32:32 <hpc> which means you need to cabal-install an L module
19:32:39 <Cale> lispy: Well, lambdabot's code is of highly variable quality...
19:32:54 <hpc> Cale: have any of my fixes been integrated yet?
19:33:01 <hpc> http://hpc.dyndns-web.com:8000/blog/view.cgi?id=13
19:33:02 <Cale> hpc: I don't know.
19:33:08 <`nand`> stuff like @check is currently broken as well
19:33:21 <Cale> (You're asking me, you'd want to ask lambdabot's nonexistant maintainer)
19:33:25 <hpc> ah
19:33:39 <hpc> @ask nobody_in_particular have my fixes been implemented yet?
19:33:39 <lispy> is lambdabot in a darcs repo? Would it help to move it to github? (really, i'm just trying to be diplomatic, I think that github would help.)
19:33:40 <lambdabot> Consider it noted.
19:33:46 <hpc> if that ever fires, i will eat my hat
19:33:55 <M30W> Rarrikins: Any suggestion for -5 instead ?
19:34:18 <`nand`> ah
19:34:23 <`nand`> nick length limit
19:35:39 <hpc> hmm
19:35:42 <M30W> Rarrikins: adding 5 works as expected; but I can't get it to -5?
19:35:43 <`nand`> lispy: for the publicity, you mean?
19:35:52 <hpc> `nand`: on another server i am on, the limit is 30 characters
19:35:59 <hpc> which is just enough for thisnickisthirtycharacterslong
19:36:04 <Rarrikins> M30W: You need (subtract 5)
19:36:15 <Rarrikins> M30W: Haskell has this thing with negation using -.
19:36:38 <Cale> (+(-5)) works
19:36:39 <M30W> O.o
19:36:42 <lispy> `nand`: essentially. Also, only die-hard darcs fans have darcs installed these days.
19:36:43 <M30W> Cale: ew
19:36:45 <M30W> lol
19:36:48 <Rarrikins> Cale: Cool :)
19:36:50 <Cale> At least, as long as the definition of negation is sane.
19:37:00 <Jafet> So does ((-5)+)
19:37:10 <M30W> wtf?
19:37:20 <M30W> I tried (-(5))
19:37:21 <Jafet> It's neat because (+) has a monoidal structure, therefore you should use it
19:37:26 <M30W> Expected that to work but needs the + :(
19:37:31 <`nand`> lispy: personally, I can't seem to understand git :(
19:37:35 <Cale> M30W: that's unary negation
19:37:38 <Rarrikins> So does negate.(+5).negate
19:38:06 <Cale> > (-(5))
19:38:08 <lambdabot>   -5
19:38:10 <mikeplus64> > (-5+) 3
19:38:12 <lambdabot>   -2
19:38:18 <Cale> > ((-(((5)))))
19:38:19 <lambdabot>   -5
19:38:20 <lispy> `nand`: I know that feel. Took me using git for a year, reading the source, looking at lots of guides on the internet, and getting help from co-workers to feel comfortable doing the usual with git. On the other hand, it's been worth it.
19:38:44 <`nand`> lispy: I use darcs for my day to day stuff and have never regretted leaving git behind
19:38:52 <lispy> `nand`: the pro git book and the visual git guide (both available on google) help a ton
19:39:06 <Cale> I use git for my day to day stuff and wish that I was using darcs all the time.
19:39:21 <mikeplus64> Cale: why?
19:39:28 <hpc> i only use github as a publicly accessible "backup"
19:39:32 <Cale> Because git is fucking confusing.
19:39:36 <hpc> and occasionally for linking
19:39:41 <hpc> git is really damn confusing
19:39:56 <ninegrid_> thats funny, haskell experts thinking git is confusing
19:39:59 <`nand`> hpc: I use darcs2git (or whatever) to back up all of my darcs repos on github + publicity
19:40:00 <Cale> I don't want to have to understand what reflogs are
19:40:07 <`nand`> hpc: I also use github to back up all of my config files etc.
19:40:09 * lispy has the last process's status code in his prompt precisely to help with git usage :)
19:40:11 <hpc> they give weird-ass verbs to things that are already hard to do
19:40:20 <hpc> just to make sure you balls it up as much as possible
19:40:22 <M30W> > 90 (+50-)
19:40:24 <lambdabot>   <hint>:1:9: parse error on input `)'
19:40:31 <M30W> > 90 (-50+)
19:40:33 <lambdabot>   Could not deduce (GHC.Num.Num ((a0 -> a0) -> t))
19:40:33 <lambdabot>    arising from the ambigu...
19:40:39 <M30W> > 90 -(+50)
19:40:41 <lambdabot>   No instance for (GHC.Num.Num (a0 -> a0))
19:40:41 <lambdabot>    arising from a use of `e_19050'...
19:40:45 <`nand`> git is simple, just view it as a clopen language of closed bijections
19:40:46 <Rarrikins> M30W: You have to put the function before the argument.
19:40:50 <Cale> And half the time it won't allow some operation to go through for some inexplicable reason, and I just end up cloning a new repo and making changes to it again by hand.
19:41:03 <M30W> > (-5+) 90
19:41:05 <lambdabot>   85
19:41:10 <M30W> That's better
19:41:13 <Rarrikins> Neat :)
19:41:23 <Rarrikins> > (-203+) 5
19:41:24 <lambdabot>   -198
19:41:39 <`nand`> Cale: oh, I know that all too well. One of my common operations during day to day git usage is “rm -rf thisrepo && git clone git://repourl” so I can get back to the latest state and continue working from there
19:41:58 <hpc> that's sad
19:42:14 <Clint> funny, i do that with darcs
19:42:23 <M30W> > (-5) 10
19:42:25 <lambdabot>   Could not deduce (GHC.Num.Num (a0 -> t))
19:42:25 <lambdabot>    arising from the ambiguity chec...
19:42:25 <lispy> I'll just leave this here: http://sifter.org/~simon/journal/20121123.h.html
19:42:28 <M30W> I really don't see why that can't work?
19:42:36 <M30W> Well
19:42:36 <ninegrid_> `nand`: do you: git checkout -b imgonnafthisup
19:42:38 <Cale> M30W: Because (-5) isn't a function.
19:42:39 <mikeplus64> M30W: because (-x) is x negated
19:42:48 <Cale> It's negative 5
19:42:49 <hpc> > 1 2
19:42:51 <lambdabot>   Could not deduce (GHC.Num.Num (a0 -> t))
19:42:52 <lambdabot>    arising from the ambiguity chec...
19:42:57 <hpc> oh, that no longer works!
19:43:00 <hpc> :D
19:43:00 <Cale> The function instance for Num isn't turned on at the moment
19:43:01 <ninegrid_> `nand`: and then stage and commit that, then checkout master, and git branch -D imgonnafthisup
19:43:24 <M30W> hpc: Wha did it do? 1*2?
19:43:32 <Cale> ninegrid_: What the heck does all that do?
19:43:45 <ninegrid_> git is all about branching and merging
19:43:46 <Rarrikins> They have something for resetting git or something like that: http://stackoverflow.com/a/6335744/463897
19:43:47 <hpc> M30W: it's functions-as-vectors
19:43:54 <hpc> fromIntegral x _ = x
19:44:00 <hpc> so (1 2) = 1
19:44:04 <`nand`> ninegrid_: well for example, suppose I have a fork (on github) of some upstream repo; and all of my fork's changes have been committed upstream; fast forward 5 months and I want to make another contribution to that project; so I decide to ‘git pull upstream master’ and get tons of errors; so what I do is just delete the entire thing and re-clone from the latest upstream HEAD so I can work on it from
19:44:07 <`nand`> there
19:44:13 <ninegrid_> Cale: git is all about branching and merging
19:44:20 <hpc> M30W: the idea was that (sin**2 + cos**2) == 1
19:44:28 <Cale> I guess that's another reason I dislike git. I don't want to think about branches as an explicit thing. What's the real difference between a branch and repository anyway?
19:44:47 <hpc> and other similar ways of expressing such formulas
19:44:50 <M30W> Okay.
19:44:58 <`nand`> that you don't have to push them all to the server manually? :P
19:45:07 <ninegrid_> Cale: that is a good question, for me it is all about containment within a canonical repo
19:45:17 <shachaf> Cale: A branch is just a name for a commit.
19:45:25 <Cale> shachaf: wat
19:45:43 * M30W is happy now; media keys as of last night control the volume of the mpd server instead of just localhost. And I can switch between different mpd servers for different computers. :)
19:45:47 <shachaf> ?
19:45:55 <M30W> xmoand ♥
19:46:01 <lispy> Cale: have you ever read this? http://marklodato.github.com/visual-git-guide/index-en.html
19:46:02 <Cale> shachaf: Isn't a commit like one single patch?
19:46:07 <Clint> with ancestry
19:46:09 <Clint> a repository can have many branches
19:46:18 <`nand`> ninegrid_: also, how do I undo git rebase -i HEAD^^^^^^^^ + deleting a bunch of stuff?
19:46:38 <shachaf> Cale: A git repository is like a big purely-functional data structure.
19:47:16 <shachaf> A commit is like the root of a tree, more or less.
19:47:17 <`nand`> shachaf: it's the same for darcs, that doesn't say much
19:47:18 <ninegrid_> `nand`: i've never had to rebase except maybe once, so it is something i don't remember well
19:47:35 <Rarrikins> No, a repository is like a Mexican restaurant and a branch is like a burrito.
19:47:38 <ninegrid_> `nand`: but i would like to experiment with darcs
19:47:49 <shachaf> When you commit, something, your new commit has a reference to some older commits as well as sharing a bunch of references to files.
19:47:52 <shachaf> f/,//
19:48:04 <applicative> `nand` I've done this hundreds of times "what I do is just delete the entire thing and re-clone from the latest upstream HEAD so I can work on it from"
19:48:10 <shachaf> So any "commit" has the entire history of the tree.
19:48:12 <`nand`> ninegrid_: how do you track down regressions? I'm trying to figure out what introduced a crash in vimus I'm getting, so I rebase -i HEAD^^^^^^ to delete commits in order to go back and time until it's no longer present
19:48:24 <M30W> shachaf: f?
19:48:30 <shachaf> f?
19:48:32 <M30W> I know s// but what's f?
19:48:46 <shachaf> I don't know?
19:48:49 <shachaf> Oh.
19:48:52 <shachaf> s/f/s/
19:48:54 <Cale> applicative: In anger, or as a basic way of getting things done?
19:48:57 <Rarrikins> haha
19:48:59 <M30W> xD
19:49:02 <ninegrid_> `nand`: i use continuous integration and i've never hit a regression thats been so deeply seated in the past
19:49:26 <M30W> shachaf: At first I thought maybe "first" but s only does the first unless you give the g flag
19:49:28 <ninegrid_> `nand`: but i know that it is a common practice to do such a think within a git repo, but the docs can be a bit obtuse
19:49:29 <M30W> :P
19:49:33 <Clint> `nand`: you know about git bisect?
19:49:42 <`nand`> Clint: I'm hearing that for the first time
19:49:50 <applicative> Cale its how I get things done. It's much easier than finessing all of gits moronic commands, but what do I  know....
19:49:51 <ninegrid_> `nand`: and if you check SO you'll find like 20 methods to do a certain thing and a lot if disagreement over the best way
19:49:59 <Cale> applicative: okay :)
19:50:05 <shachaf> git's model seems simple and sensible to me.
19:50:17 <shachaf> Whereas darcs's doesn't so much, I think?
19:50:25 <Cale> Odd, it's the reverse for me.
19:50:36 <hpc> you really are only able to measure complexity when something breaks
19:50:40 <`nand`> darcs repositories are collections of patches; where each patch may or may not have dependencies, but they can also be independent
19:51:52 <`nand`> in particular, there's no timeline of sorts. two repositories are equal if they contain the same set of patches, regardless of how they got there
19:52:10 <applicative> oh man, what a paradise, dont remind me
19:52:13 <shachaf> Cale: A branch is literally just a file with a commit hash in it, as in echo c87e6f4c92e3516af47d591443a0caee39fa1e41 > .git/refs/heads/symmetric
19:52:36 <Cale> shachaf: That doesn't mean a whole lot to me
19:52:37 <shachaf> It's a convenient way to refer to commits (and to make sure they don't get GCed).
19:53:15 <Cale> I have a feeling that all the people who actually like git actually bother to understand all the stuff inside the .git directory.
19:53:25 <`nand`> also, darcs patches commute, so I can in theory pull and push patches in any order (assuming I conform to the dependencies)
19:53:28 <shachaf> I don't!
19:53:43 <shachaf> (Understand.)
19:53:52 <ninegrid_> `nand`: doesn't that make darcs a bit slow compared to git?
19:53:57 <`nand`> ninegrid_: depends
19:54:01 <shachaf> There's some semi-complicated object store thing that I like to pretend is simple.
19:54:09 <`nand`> ninegrid_: for some operations, it can be very slow; it's known as the “exponential merge problem”
19:54:14 <`nand`> ninegrid_: but it's supposedly very rare
19:54:18 <`nand`> ninegrid_: at least, since darcs 2 or whatever
19:54:28 <dmwit> Saying darcs patches commute is a bit deceptive.
19:54:35 <`nand`> oh
19:54:37 <`nand`> I meant *can* commute
19:54:40 <shachaf> Cale: I think of a git repository as a very direct analogy to a Haskell data structure.
19:55:08 <Cale> I don't want to ever think about how my version control system works internally in order to use it.
19:55:15 <dmwit> That's deceptive, too. What I mean is, darcs patches *change* when you perform the "commute" operation.
19:55:23 <dmwit> So it's not really the "commute" that mathematicians usually think of.
19:55:24 <startling> shachaf: what's the data structure?
19:55:30 <shachaf> startling: A tree-ish thing?
19:55:44 <dmwit> shachaf, startling: It's a DAG.
19:55:57 <startling> directed acyclic graph?
19:56:00 <dmwit> yes
19:56:00 <shachaf> A tree-ish thing with sharing. :-)
19:56:02 <`nand`> dmwit: they're technically still the same patch though, no? just the operation applied to the actual file tree changes as you commute them?
19:56:12 <`nand`> dmwit: of course, it's been a while since I read up on darcs' patch theory
19:56:20 <startling> I should probably learn how git works sometime.
19:56:26 <`nand`> in practice, I don't care so much about whether or not patches ‘commute’, for me it just means “I can pull and push as needed”
19:56:36 <dmwit> `nand`: I think if you say that, you're really missing out on a lot of the stuff darcs is doing. The actual patch you send down the wire doesn't commute, and any complete theory of how darcs works has to account for that.
19:57:48 <ninegrid_> `nand`, Cale: have you seen "a successful git branching model"?
19:57:58 <Cale> I haven't really bothered to understand darcs either, but as `nand` mentions, I just pull and push things and make changes, and they end up in the repository in some reasonably sane fashion, and then when I want to undo something, I can rollback, or pull into a new repo and skip some stuff.
19:58:03 <Cale> ninegrid_: yes
19:58:08 <`nand`> Cale: I think the representation of repositories is part of the external API, personally
19:58:41 <Jafet> git is its user interface.
19:58:45 <`nand`> maybe not the implementation details; but the fundamental relationships on which they're based
19:58:52 <`nand`> eg. “a repo is a set of patches”
19:58:55 <shachaf> Cale: That sounds like how I use git.
19:59:26 <`nand`> shachaf: when I feel git it feels like all I'm doing is using the wrong commands for things that git seems to support
19:59:49 <flebron> What do we get if we have Applicative without pure?
19:59:51 <Cale> `nand`: As far as I'm concerned, I just want the thing to take care of all the changes I make without my having to think about how it's doing that, and then let me merge those changes reliably with other people's and undo stuff occasionally. I don't want to have to think about any of the representation of that.
20:00:06 <Cale> It *shouldn't* matter
20:00:34 <dmwit> Cale: Are you claiming that git does not do these things?
20:00:38 <Cale> Git exposes all kinds of obnoxious details
20:00:49 <Cale> and seems to require me to understand them
20:00:56 <Cale> in order to have a reasonable time using it
20:01:18 <Cale> whereas I can use darcs without understanding how darcs works at all
20:01:20 <shachaf> Funny, I had that experience with darcs.
20:01:29 <pnielsen> Cale: disagree
20:01:45 <shachaf> Anyway this seems like a useless discussion at this point, and also off-topic
20:01:55 <pnielsen> maybe for involved stuff, but everyday use--branching, merging, commiting, etc.--requires almost no knowledge of internals IMO
20:01:57 <shachaf> #haskell-blah would be a better place for it.
20:01:58 <Enigmagic> my tools are better than yours
20:02:17 <`nand`> well, vim > emacs
20:02:20 <`nand`> so take that
20:02:23 <pnielsen> that said, I haven't used darcs much
20:02:25 * `nand` hides
20:02:26 <pnielsen> also, emacs > vim
20:02:31 <applicative> flebron: http://hackage.haskell.org/package/semigroupoids-3.0.0.1
20:02:32 <hpc> > "vim" > "emacs"
20:02:33 <shachaf> thanks for helping, `nand`, pnielsen
20:02:34 <lambdabot>   True
20:02:35 <shachaf> , hpc
20:02:35 <pnielsen> `nand`: you got the > backwards
20:02:40 <pnielsen> heh, sorry
20:02:46 <`nand`> hpc: haha
20:02:51 <hpc> > "python" > "haskell" -- /me ducks
20:02:53 <lambdabot>   True
20:03:16 <shachaf> thanks, hpc
20:03:17 <pnielsen> how crazy would it be if it answered false to such comparisons
20:03:32 * flebron is still trying to get the conceptual part of Applicative, though I guess I'll finish reading the canonical paper about it :)
20:03:34 <Cale> pnielsen: Well, it's mostly like that, but then things mysteriously fail for me -- git decides that I can't perform some operation without adequately explaining what I need to do, and then I end up cloning a new copy of the repo and making my change again by hand.
20:03:34 <`nand`> > "C" > "haskell"
20:03:36 <lambdabot>   False
20:03:41 <hpc> it would be violating paretricity for that instance
20:03:46 <hpc> so it would be pretty damn fantastic
20:03:57 <applicative> flebron: http://hackage.haskell.org/packages/archive/semigroupoids/3.0.0.1/doc/html/Data-Functor-Apply.html#t:Apply
20:04:00 <Rarrikins> > python > haskell
20:04:00 <Cale> which basically defeats the purpose of having a VCS in the first place
20:04:02 <lambdabot>   False
20:04:04 <`nand`> hpc: surely all it needs is a bit of OverloadedInstances
20:04:04 <flebron> > let "python" < "haskell" in "python" < "haskell"
20:04:06 <lambdabot>   <hint>:1:26: parse error on input `in'
20:04:09 <`nand`> err
20:04:10 <pnielsen> Cale: interesting, I don't know if I've experienced that
20:04:11 <startling> flebron: it's just that you can't join
20:04:11 <`nand`> Overlapping
20:04:21 <pnielsen> Cale: I get that feeling all the time with hg though
20:04:30 <flebron> > let "python" < "haskell" = True in "python" < "haskell"
20:04:32 <lambdabot>   True
20:04:32 <startling> flebron: so you can't use some applicative action depending on the results of some other applicative action
20:04:51 <pnielsen> > "python" > "haskell"
20:04:53 <lambdabot>   True
20:05:00 <Rarrikins> > python < haskell
20:05:02 <pnielsen> > "python" < "haskell"
20:05:02 <lambdabot>   True
20:05:03 <lambdabot>  Terminated
20:05:04 <flebron> startling, but a monad without join is just return :p
20:05:06 <pnielsen> lol
20:05:39 <`nand`> <*> is equivalent to f a -> f b -> f (a, b) -- if that helps
20:05:51 <Jafet> > "ML" > "Нaskell"
20:05:51 <lambdabot>   mueval: recoverEncode: invalid argument (invalid character)
20:05:58 <hpc> a monad without join is pointed
20:05:58 <startling> flebron: right, so you've got this other thing that's less powerful
20:06:04 <`nand`> Jafet: nice try
20:06:23 <hpc> which is incidentally a class that's so pointless its only law was later discovered to be a free theorem coming from Functor
20:06:29 * `nand` .oO( there's no such thing as a monad without join )
20:07:19 <`nand`> hpc: what was the law Pointed had?
20:07:57 <hpc> uh
20:08:06 <`nand`> fmap f . point = point . f -- or something?
20:08:27 <hpc> probably
20:08:49 <flebron> I've been drawing a few diagrams to get a hang for what Applicative is doing. The cool part that I sort of knew already but hadn't internalized, is that if a is a type, and b is a type, a -> b is a type. So what Applicative does is, if you have a type a, a type b, you have a type c = a -> b. You could take F c, and you'd get F (a -> b) = c'. You could also take F a and F b, let's call them a' and b' resp. We also have y = a' -> b'.
20:08:49 <flebron>  And so what Applicative gives you, is a <*> :: c' -> y, whereas Functor gave you fmap :: c -> y.
20:09:51 <`nand`> that was an oddly nameful way of putting things
20:09:56 <flebron> And there has got to be some commutative diagram somewhere that relates both these two arrows (both inside Hask of course), and pure, taking a to a', b to b', and c to c'.
20:10:43 <flebron> The one that was totally obvious was pure f <*> pure x = pure (f x) :p
20:10:54 <`nand`> pure f <*> x  = fmap f x
20:11:01 <flebron> Right :)
20:11:50 <flebron> I still need to tidy my drawings up to see a few other "obvious" identities, but I think the above arrows should account for the nature of Applicative.
20:12:13 <shachaf> `nand`: Not for Magma, it doesn't!
20:12:27 <shachaf> I guess I mean Const (Magma a)
20:12:34 * startling dips shachaf in magma
20:12:37 <flebron> There's a Magma typeclass in Haskell, which represents a magma?
20:12:41 <`nand`> shachaf: what was that in response to?
20:12:44 <shachaf> No class.
20:12:48 <flebron> I recall seeing it and thinking "... just... why."
20:13:08 <cmccann> a magma typeclass sounds thoroughly useless
20:13:12 <shachaf> https://github.com/ekmett/lens/blob/master/src/Control/Lens/Magma.hs
20:13:14 <flebron> "There's this set, and it has this operation. The end."
20:13:42 <`nand`> I uh.. that seems to be a different concept of Magma?
20:14:07 <flebron> Indeed, magmas are certainly not monoids.
20:14:16 <flebron> (Though preeeeeetty much everything's a magma :p)
20:14:30 <cmccann> haha, "instance Monoid (Magma i a)"
20:14:40 <cmccann> I'm sure that makes sense in context but still
20:14:44 <`nand`> every set is trivially a magma, give it ‘const’ as binary operation
20:15:08 <shachaf> cmccann: The idea is that we take a fold and reify it into a tree while preserving its shape.
20:15:21 <shachaf> That way you can e.g. access either end of the tree efficiently, if the original fold was balanced.
20:15:24 <cmccann> I figured it was something like that
20:15:33 <flebron> `nand`, what about the empty set? :p
20:15:38 <shachaf> Then we do things to the tree and eventually put it back into the traversal.
20:15:39 <`nand`> flebron: totally works
20:15:48 <`nand`> flebron: it's still total
20:15:53 <`nand`> and closed, w/e
20:15:57 <jmcarthur> omg that was a lot of troll/spam
20:16:02 <shachaf> cmccann: This is a more advanced (/less valid) version of the partsOf thing we talked about the other day.
20:16:12 <flebron> Well, I guess I don't know how to define const for {}. I suppose it's equivalent to, you know, "the one function from {}".
20:16:20 <lispy> jmcarthur: what was?
20:16:20 <shachaf> Now edwardk wants to support indexed travesals.
20:16:27 <edwardk> adding them as we speak
20:16:27 <jmcarthur> i feel bad every time i find that i am not around when somebody calls for ops
20:16:42 <jmcarthur> lispy: it was around 500 lines back i think
20:16:59 <startling> haven't there been indexed traversals forever?
20:16:59 <`nand`> jmcarthur: that guy advertising the ambiguously named channel?
20:17:07 <`nand`> startling: for Magma, I take it
20:17:22 <lispy> jmcarthur: ah, I see it now. I totally missed it, but then I'm not an op
20:17:23 * startling scrolls up
20:17:36 <jmcarthur> wow, i did not mean to call attention to that which does not deserve attention
20:17:38 <cmccann> free magmas are basically binary trees, just consider tree rotations to be isomorphisms and that's totally a useful application for magmas, right
20:17:38 * lispy was once an op and was terrible at it
20:18:09 * flebron started his holidays today, and so he will spend this next week mentally masturbating about Hask and applicative and that good stuff.
20:18:20 <mercury^> Hi. I can do foo ∷ (MonadReader m, EnvType m ~ Bar s) ⇒ etc., but not class (MonadReader m, EnvType m ~ Bar s) ⇒ etc.; why, and is there a fix?
20:18:44 <parcs> > fromIntegral (-1 :: Int8) :: Int
20:18:45 <lambdabot>   -1
20:18:51 <`nand`> MonadReader m? Isn't that missing a parameter?
20:18:53 <mercury^> (GHC complains about s not being in scope in the class declaration.)
20:19:10 <mercury^> `nand`: I am using monads-tf.
20:19:24 <`nand`> oh, okay
20:19:50 <shachaf> You shouldn't use monads-tf
20:20:01 <mercury^> Oh? What should I use instead?
20:20:04 <shachaf> mtl
20:20:08 <hpc> mtl has been the standard for years now
20:20:35 <mercury^> I see. I googled for what to use, and some stackoverflow thread said transformers + monads-tf
20:21:11 <mercury^> http://stackoverflow.com/questions/2769487/mtl-transformers-monads-fd-monadlib-and-the-paradox-of-choice
20:21:19 <cmccann> that's pretty old
20:21:21 <`nand`> mercury^: anyhow, shouldn't that work?
20:21:30 <`nand`> λ class Foo x where type Bar x
20:21:33 <`nand`> λ class (Foo x, Bar x ~ Int) => Blaz x
20:21:35 <`nand`> ^- doesn't give me an error
20:21:38 <cmccann> and out of date since it predates some significant changes in how mtl and transformers relate
20:22:07 <mercury^> cmccann: Ok. It's still the first answer I could find using google. Maybe someone should post updated information there.
20:22:18 <cmccann> yes, someone probably should
20:22:31 <parcs> "For coercing between any two integer types, use fromIntegral. Coercing word types (see Data.Word) to and from integer types preserves representation, not sign."
20:22:46 <cmccann> probably the person who wrote the top-scoring answer
20:22:46 <shachaf> cmccann: If only we had the author at hand.
20:22:48 <parcs> > fromIntegral (-1 :: Int8) :: Int -- is this behaving as specified by the report?
20:22:49 <lambdabot>   -1
20:22:54 <cmccann> shachaf, yeah oh well
20:23:04 <cmccann> guess it's hopeless!
20:23:09 <startling> "Still unsatisfied? Throw them all out, download category-extras, and solve all the world's problems with a page and a half of incomprehensible abstract nonsense breathtakingly generic code." :S
20:23:31 <cmccann> that's also outdated! category-extras got dismantled.
20:23:34 <flebron> Well, I have a question about "Applicative programming with effects". In the introduction, the author states (about a transpose function) "Except for the noise of the repeats and zapps, this definition is in a fairly standard applicative style". If I don't know what "applicative style" is, should I just skip that? I went to that paper to understand what applicatives are :p
20:23:34 <edwardk> category-extras is obsolete. you need to install about 30 packages to replace it ;)
20:23:41 <shachaf> I like how cmccann's highest-voted answer by a large margin is "How is <*> pronounced?"
20:23:56 <parcs> oh wait, it says "coercing word types"
20:23:58 <startling> shachaf, the people have spoken
20:23:59 <cmccann> yes. people like that answer.
20:24:19 <cmccann> mostly it involves me using a lot of words to explain why you shouldn't pronounce it as anything
20:24:49 <edwardk> flebron: i think the author was trying to indicate that it was more or less an example of the style of things to come, than indicate you should know applicatives a priori
20:25:02 <flebron> Ah, OK.
20:25:57 <roconnor> shachaf: is the answer "ap"?
20:26:08 <M30W> haskell ♥
20:26:34 <`nand`> > fromIntegral (255 :: Word8) :: Int8
20:26:35 <lambdabot>   -1
20:26:38 <parcs> > fromIntegral (-1 :: Int8) :: Word
20:26:39 <lambdabot>   18446744073709551615
20:26:49 <M30W> > -5+ 10
20:26:51 <lambdabot>   5
20:26:56 <mikeplus64> > -1 :: Word
20:26:58 <lambdabot>   18446744073709551615
20:26:58 <parcs> > fromIntegral (-1 :: Int8) :: Word8
20:27:00 <lambdabot>   255
20:27:28 <parcs> i would figure 'fromIntegral (-1 :: Int8) :: Word' == 255
20:27:48 <`nand`> “*Still* not satisfied? Download profunctor-extras”
20:27:49 <mikeplus64> parcs: Word is like Int, except for unsigned integers
20:28:03 <shachaf> Applicative is such a verbose name.
20:28:37 <M30W> dzen2, why can't you have a point for gravity and let me have you work with left and right? :'(
20:28:38 <`nand`> Monoidal is so much better?
20:28:57 <flebron> Well monoidal gave me an idea of what it did. But "applicative" doesn't :p
20:29:15 <parcs> mikeplus64: that's an Int8
20:29:20 <roconnor> flebron: that and ML already uses the name applicative functor
20:29:29 <flebron> For something different?
20:30:21 <parcs> oh, i see
20:30:34 <cmccann> shachaf, just call (<*>) fzip. especially around edwardk.
20:30:41 <cmccann> er, fzipWith.
20:30:53 <`nand`> parcs: probably something to do with the leftmost bit being preserved when expanding word sizes or somesuch
20:30:54 <cmccann> or something like that.
20:31:03 <startling> has anyone made the "fap" joke yet?
20:31:09 <shachaf> cmccann: What should I call <&>?
20:31:43 <mikeplus64> :t fmap fmap fmap fmap fmap fmap -- now they have
20:31:44 <lambdabot> (Functor f1, Functor f) => (a -> a1 -> b) -> f a -> f (f1 a1 -> f1 b)
20:32:17 <flebron> Heh, I guess fmap^n makes sense for every n >= 0.
20:32:20 <applicative> I think 'applicative' is due to Backus
20:32:32 <`nand`> flebron: it gets cyclic
20:32:38 <applicative> it's the opposite of 'von Neumann' somehow
20:32:43 <flebron> Really? No matter the functor?
20:32:43 <cmccann> shachaf, dunno
20:33:10 <`nand`> yeah; well, type checking gets exponentially more difficult or something
20:33:20 <`nand`> but the signature is modulo something iirc
20:33:32 <applicative> shachaf: do y'all have a <&>
20:33:41 <shachaf> @ty (<&>)
20:33:43 <lambdabot> Functor f => f a -> (a -> b) -> f b
20:34:00 <parcs> `nand`: i have a feeling it's because Int8 is secretly an Int
20:35:18 <parcs> i don't think it's correct behavior
20:35:23 <parcs> must investigate
20:35:36 <`nand`> can we introduce ’flip const’ as ‘idOf’ in 3.8?
20:35:36 <mikeplus64> > fmap ($ Just 5) (fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap (+) (Just 4) :: Maybe (Maybe Int -> Maybe Int) )
20:35:38 <lambdabot>   Just (Just 9)
20:35:43 <applicative> > "hello" <&>  ord
20:35:45 <lambdabot>   [104,101,108,108,111]
20:36:10 <`nand`> parcs: Num etc. are so messed up it's dubious if there even is a ‘correct behavior’
20:36:18 <applicative> @type flip const
20:36:19 <lambdabot> b -> c -> c
20:36:25 <parcs> `nand`: well according to the docs "Coercing word types (see "Data.Word") to and from integer types preserves representation, not sign."
20:36:27 <applicative> awesome
20:37:03 <parcs> i think the implementation of fromInteger is missing a bitmask somewhere, or something
20:38:03 <`nand`> parcs: hey, I guess you really *are* preserving representation if they're Int#s internally :P
20:38:30 <parcs> true
20:39:08 <monochrom> > toInteger (-1 :: Int8)
20:39:10 <lambdabot>   -1
20:39:21 <monochrom> > fromInteger (-1) :: Word
20:39:22 <lambdabot>   18446744073709551615
20:39:41 <parcs> > fromInteger (-1) :: Int8
20:39:42 <lambdabot>   -1
20:39:56 <parcs> > fromIntegral (fromInteger (-1) :: Int8) :: Word
20:39:57 <lambdabot>   18446744073709551615
20:40:02 <monochrom> toInteger (-1 :: Int8) = -1 is obviously correct
20:40:18 <monochrom> and I don't know what you expect for fromInteger (-1) :: Word
20:40:30 <`nand`> yeah, it goes through Integer either way; so there's not much bitmasking etc. you can do
20:40:33 <mercury^> Which package should I use for Control.Monad.ST.Class?
20:40:33 <parcs> 255
20:40:41 <`nand`> why 255?
20:40:58 <parcs> er, sorry
20:41:09 <parcs> fromIntegral (-1 :: Int8) :: Word should equal 255
20:41:19 <`nand`> but fromIntegral = fromInteger . toInteger
20:41:50 <`nand`> there's not much we can do to change that, unless you want to revise the whole Prelude
20:41:56 <monochrom> parcs, it's fromInteger (toInteger (-1 :: Int8) :: Integer)) :: Word  to be fully typed
20:41:58 <cmccann> who doesn't want to do that?
20:42:14 <`nand`> well, that would be fairly involved
20:42:30 <`nand`> just saying it isn't a ‘simple fix’ of some instance or anything
20:42:58 <cmccann> obviously the real problem is that fromInteger doesn't have a sensible definition for Word types
20:43:04 <cmccann> so just remove their Num instances
20:43:04 <`nand`> right
20:43:06 <cmccann> problem solved!
20:43:09 <`nand`> heh
20:43:10 <parcs> monochrom: oh, right..
20:43:33 <`nand`> ‘error "(Word8) fromInteger: Negative value"’
20:43:34 <shachaf> > fromInteger $ do -1 :: Int8 :: Word8
20:43:36 <lambdabot>   Couldn't match expected type `GHC.Integer.Type.Integer'
20:43:36 <lambdabot>              with a...
20:43:37 <cmccann> it's amazing how many problems can be solved by removing instances.
20:43:46 <shachaf> Er.
20:43:54 <ion> REMOVE ALL THE THINGS
20:44:00 <shachaf> > fromIntegral $ do -1 :: Int8 :: Word
20:44:02 <lambdabot>   18446744073709551615
20:44:15 <ion> nice
20:44:27 <monochrom> there is some chance fromIntegral :: Int8 -> Word is optimized and does not go through fromInteger.toInteger. however, if that is the case, I'm pretty sure someone loud complained enough to make sure that the optimized code gives exactly the same answer as fromInteger.toInteger, and I would support that guy
20:44:35 <mercury^> edwardk: which package do you recommend for Control.Monad.ST.Class, if any?
20:44:40 <applicative> mercury^: I'm not sure it matters, but http://hackage.haskell.org/package/monad-st is still being maintained...
20:44:50 <`nand`> I never would have guessed that parses correctly
20:45:02 <edwardk> monad-st is the one i use
20:45:03 <mercury^> applicative: well, that is to be used with transformers, and I was just told to use mtl.
20:45:09 <mercury^> Now I am confused.
20:45:15 <cmccann> `nand`, oh really
20:45:16 <cmccann> @quote cmccann Int -> Int
20:45:17 <lambdabot> cmccann says: :t \f -> \x -> f x :: Int :: (Int -> Int) :: (Int -> Int) -> Int -> Int
20:45:25 <cmccann> parse that one
20:45:26 <edwardk> mercury^: transformers is the core of the mtl
20:45:40 <covi> If I have [a] and [a], how do I get [[a]]? E.g. f [1,2] [3,4] = [[1,2],[3,4]]
20:45:44 <applicative> mercury^: edwardk will sort this out for you ...
20:45:47 <edwardk> mercury^: transformers provides all of the parts of the mtl that can be supplied without breaking haskell 98
20:45:51 <edwardk> mtl provides the rest
20:46:17 <mercury^> edwardk: I see. But mtl uses functional dependencies and monad-st uses type families?
20:46:18 <`nand`> cmccann: I wasn't even aware :: behaves like that
20:46:29 <cmccann> `nand`, but now you know
20:46:35 <`nand`> more importantly
20:46:42 <`nand`> what's with the completely unnecessary set of parentheses?
20:46:46 <edwardk> mercury^: i maintain both of those packages. ;)   i use type families here because its more convenient for this particular API.
20:47:17 <monochrom> f x y = [x,y] ?
20:47:19 <cmccann> `nand`, not sure. trying to make it more confusing to read somehow?
20:47:39 <cmccann> or maybe less.
20:47:40 <`nand`> might be more confusing without them
20:47:47 <edwardk> i could have just as easily used a class Monad m => MonadST s m | m -> s where         signature like in the mtl
20:48:02 <mercury^> edwardk: I see. I thought to have read somewhere that combining functional dependencies and type families is not a good idea, but I guess that is wrong then, or at least does not apply here.
20:48:10 <monochrom> mtl is a MPTC-fundep wrapper over transformers
20:48:27 <edwardk> mercury^: they mix fine nowadays
20:48:54 <edwardk> there are a couple of places where its preferable to use a type family because you can't move information from a fundep to a type family, but thats it
20:49:06 <edwardk> the nature of this API is such that this doesn't become an issue
20:49:47 <`nand`> the main problem with MPTCs seems to be the horrendeously long flag -XMultiParamTypeClasses
20:49:57 <`nand`> why can't it have been -XMPTCs?
20:50:00 <`nand`> We have -XGADTs after all
20:50:01 <edwardk> `nand`: =)
20:50:08 <shachaf> {-# LANGUAGE AbbreviatedLanguagePragmas #-}
20:50:19 <`nand`> at least they had the decency to shorten Parameter to Param
20:50:36 <cmccann> maybe people are afraid to complain about the inconsistency because the result might be unabbreviating GADT instead
20:50:36 <`nand`> shachaf: oh, that's so much better :)
20:50:38 <monochrom> haha `nand`++
20:50:39 <byorgey> and Multiple to Multi
20:50:52 * monochrom has a cunning plan!
20:51:06 <monochrom> {-# LANGUAGE CPP #-}
20:51:16 <monochrom> #define MPTC MultiWhatever
20:51:26 <monochrom> {-# LANGUAGE MPTC #-}
20:51:51 <shachaf> {-
20:51:52 <`nand`> -XMultiWhatever
20:51:56 <shachaf> #define CPP BangPatterns
20:51:56 <shachaf> -}
20:52:01 <shachaf> {-# LANGUAGE CPP #-}
20:52:37 <`nand`> maybe I could invest in getting tab completion on LANGUAGE pragmas into vim
20:52:38 <monochrom> in CCCP, CPP defines you
20:52:59 <AfC> heh
20:53:01 <shachaf> {-# LANGUAGE ☭ #-}
20:53:13 <AfC> shachaf: oh, well done
20:53:19 <monochrom> @quote monochrom CCCP
20:53:20 <lambdabot> monochrom says: in Soviet Russia, current continuation calls procedure (CCCP)
20:53:35 * cmccann is now jaded about syntactic abuse after the stuff with rebindable syntax the other day
20:54:03 <`nand`> cmccann: part of me is trying to find a legit use for it in actual code
20:54:12 <cmccann> if you can find one, I'd love to see it
20:54:30 <`nand`> unfortunately, it's probably going to be just as fruitless as my efforts to integrate TardisT
20:54:33 <ion> CCCP :-D
20:55:23 <cmccann> `nand`, could always use hint or whatever, something to load code at runtime, and then redefine (>>=) based on stuff that way
20:55:33 <Jafet> Хаскэлл
20:55:46 <shachaf> hi dolio
20:55:46 <`nand`> cmccann: in particular, the (>>=) <- thing
20:55:52 <cmccann> right
20:56:04 <`nand`> oh, you mean load hint in the do block; yeah
20:56:25 <monochrom> rebindable syntax is a lot of fun
20:56:31 <`nand`> cmccann: bonus points if hint is running on that file's source code?
20:56:50 <cmccann> `nand`, turtles all the way down!
20:57:02 <shachaf> cmccann was doing do { (>>=) <- x; ... } with RebindableSyntax?
20:57:09 <cmccann> no, that was lispy's idea
20:57:11 <shachaf> I guess that's why it's called rebindable.
20:57:29 <cmccann> after startling asked about redefining (>>=) in the middle of a do block
20:57:42 <monochrom> yikes!
20:57:59 <monochrom> actually I don't think rebindable syntax supports that
20:57:59 <cmccann> which does exactly what you'd expect in terms of the desugaring
20:58:02 <cmccann> it does
20:58:04 <cmccann> I tried it
20:58:14 <monochrom> oh God, I suppose it does
20:58:20 <cmccann> the rest of the do block used the new definition
20:58:21 <Jafet> (>>=) is a name in scope
20:58:29 <`nand`> it just blindly desugars to foo >>= \(>>=) -> bar >>= ...
20:58:31 <monochrom> hahaha this is great fun!
20:58:34 <ion> nice
20:58:37 <cmccann> monochrom, which is why lispy then suggested (>>=) <- ...
20:58:45 <Jafet> @undo do (>>=) <- x; y; z
20:58:46 <lambdabot> x >>= \ (>>=) -> y >> z
20:59:04 <cmccann> and yeah, you need to replace (>>) as well for maximum benefit
20:59:06 <shachaf> If only (>>=) was dynamically scoped.
20:59:13 <Jafet> ?>>=
20:59:13 <lambdabot> Unknown command, try @list
20:59:22 <monochrom> yeah I was not interpreting "it uses whatever >>= in scope" literally
20:59:26 <`nand`> hmm
20:59:28 <shachaf> Hmm, let (>>) = ?bind
20:59:44 <shachaf> Er, with the _
20:59:54 <`nand`> write a botched forwards-backwards-state monad and have (>>=) <- get reverse forwards and backwards composition in each iteration
21:00:03 <cmccann> monochrom, I'd previously abused it by redefining do syntax locally, shadowing (>>=) with a where clause or such
21:00:34 <cmccann> but doing it in the middle of a do block is just hilariously terrible
21:00:48 <monochrom> yeah I'm still giggling
21:01:04 <`nand`> unfortunately, all my idea would probably result in is a big pile of ⊥
21:01:41 <mercury^> edwardk: now I am more or less back at my original problem though:  class MonadReader (Foo s) m complains about s not being in scope; on the other hand foo ∷ MonadReader (Foo s) m works.
21:02:19 <shachaf> mercury^: Neither of those are valid.
21:02:30 <shachaf> I guess you're missing => and some more text.
21:02:33 <edwardk> mercury^: i wasn't present for your initial problem, and i'm not quite sure how to parse what you have written there.
21:02:39 * cmccann wonders if anything similarly horrible could be done with rebound proc syntax
21:02:51 <cmccann> it's a lot less flexible in how you rebind the arrow desugaring stuff though
21:03:00 <shachaf> proc syntax is the devil. :-(
21:03:17 <mercury^> class MonadReader (Foo s) m ⇒ Bar m gives an error, foo ∷ MonadReader (Foo s) m ⇒ a → b works.
21:03:39 <shachaf> You need an s on the right side.
21:04:04 <shachaf> (Also, "gives an error" isn't helpful, unless all it says is "error".)
21:04:26 <`nand`> has anybody tried constructing lenses using proc syntax yet? Presumably in a way that doesn't desugar to a >>> b >>> c >>> ...
21:04:28 <edwardk> mercury^: you need an 's' somewhere in the instance head for Bar.
21:04:34 * cmccann gives shachaf an error.
21:04:46 <shachaf> thmccann
21:04:53 <mercury^> shachaf: I've previously said that the error is "s not in scope" several times. But yes, that fixes it. Thank you all.
21:04:55 <shachaf> thasey?
21:05:10 <edwardk> it can be as simple as class MonadReader (Foo s) m => Bar s m | m -> s
21:05:54 <edwardk> `nand`: if its a 'lens' it will desugar to a >>> b >>> c. if its something else you can get some interesting ways to do recursion
21:06:10 <`nand`> s/lenses/lenslikes/
21:07:53 <parcs> > fromIntegral (-1 :: Int16) :: Word
21:07:54 <lambdabot>   18446744073709551615
21:09:32 <Catnaroek> Is there any type similar to ByteString, but which does not keep an internal character count?
21:09:49 <mikeplus64> Catnaroek: CString, i guess
21:09:57 <mikeplus64> (ie Ptr CChar)
21:10:09 <Catnaroek> mikeplus64: Ah, okay! ty
21:10:22 <shachaf> FSVO "similar"
21:10:34 <Jafet> [Word8]
21:11:24 <mikeplus64> Catnaroek: why do you want that though?
21:11:45 <hejux> hi
21:11:50 <hejux> what is this channel about?
21:12:05 <hejux> is there a golang channel?
21:12:21 <startling> cmccann: haha
21:12:24 <Catnaroek> mikeplus64: I want to read a database index file. I want to compare keys. Keys to be compared will always be equal in size.
21:12:57 <hejux> go build github.com/shadowsocks/shadowsocks-go/shadowsocks: signal 9
21:13:03 <Jafet> hejux: welcome to #haskell. You can troll Haskell users here.
21:13:05 <`nand`> edwardk: what's that magic function that constructs a traversal from an function like (!!4) called again?
21:13:06 <startling> hejux: #go-nuts
21:13:13 <cmccann> startling, I hope you realize you've created a syntactic monster here
21:13:23 <startling> cmccann: semantic as well!
21:13:24 <mikeplus64> `nand`: to?
21:13:30 <mikeplus64> that's at least one of the magical ones...
21:13:35 <`nand`> to isn't magical
21:13:47 <`nand`> and it doesn't construct a traversal
21:13:58 <edwardk> `nand`: 'upon'
21:14:01 <`nand`> ah, thanks
21:14:10 <`nand`> I need a mnemonic for that or something
21:14:41 <roconnor> @type upon
21:14:43 <lambdabot> (Data.Data.Data a, Data.Data.Data s, Applicative f, Indexable [Int] k) => (s -> a) -> k (a -> f a) (s -> f s)
21:14:54 <mikeplus64> `nand`: oh, looking at the source now, i guess not
21:15:13 <edwardk> > "hello" & upon head .~ 'j'
21:15:15 <lambdabot>   "jello"
21:15:42 <startling> o.o
21:15:52 <cmccann> "Data.Data.Data" never stops being hilarious
21:15:53 <shachaf> > "hello" & upon ((`seq` "") . length) .~ " world"
21:15:55 <lambdabot>   "hello world"
21:16:01 <edwardk> > "world" & upon last .~ 'y'
21:16:03 <lambdabot>   "worly"
21:16:16 <edwardk> shachaf: =P
21:16:29 <edwardk> it has lots of documentated limitations, but its fun for showing off
21:16:56 <mikeplus64> edwardk: i have no idea how you do it but that's awesome
21:16:58 <M30W> wtf is .~ ?
21:16:59 <shachaf> We needs upons, which modifies each of the affected locations rather than just the last one.
21:17:10 <edwardk> M30W: .~ is 'set' for lenses.
21:17:24 <M30W> edwardk: lenses?
21:17:31 <cmccann> oh boy
21:17:33 <edwardk> > ("hello","world") & _2 .~ "foo"
21:17:35 <lambdabot>   ("hello","foo")
21:17:50 <edwardk> _2 is a 'lens' which lets you read and write from the second field in a tuple
21:18:22 <`nand`> but don't look at its type signature
21:18:43 <edwardk> M30W: lens.github.com has a tutorial. https://www.youtube.com/watch?v=cefnmjtAolY&hd=1 is a couple hour long crash course I did on how they are implemented.
21:19:01 <cmccann> M30W, a huge pile of baroque machinery edwardk created mostly so that he could golf one-liners with lambdabot
21:19:04 <cmccann> give or take
21:19:20 <mikeplus64> oh, did upon get axed from the most recent 'lens' release?
21:19:30 <shachaf> No.
21:19:30 <`nand`> import Data.Data.Lens ?
21:19:31 <Jafet> I have not seen a lens golf to date
21:19:34 <edwardk> we need all these lenses to avoid looking directly at the medusae that are their type signatures.
21:19:41 <edwardk> mikeplus64: its in Data.Data.Lens
21:19:42 <cmccann> hahaha
21:19:46 <mikeplus64> edwardk: ah
21:20:05 <`nand`> _2 :: (Functor f, Field2 s t a b, Indexable Int p) => p a (f b) -> s -> f t
21:20:09 <applicative> @remember <M30W> edwardk: lenses?
21:20:10 <lambdabot> Done.
21:20:20 <shachaf> What?
21:20:21 <`nand`> add in a few more vector spaces and it'll be almost as awful as diagrams
21:20:24 <cmccann> edwardk, what about the occasional cryptic and hard-to-fix type checking errors caused by types that are secretly higher-rank polymorphic :P
21:20:44 <edwardk> cmccann: thats when you turn to stone
21:20:48 <cmccann> ok
21:21:45 <edwardk> lens is the type-theoretic version of http://xkcd.com/356/
21:21:47 <Jafet> Or your type variables do
21:22:10 <roconnor> M30W: your question is fair;  It's only funny because edwardk likes to talk about lenses :D
21:22:11 <edwardk> rigid type variables have been caught by the medusa. run
21:23:00 <cmccann> edwardk, so THAT'S what rigid means
21:23:03 <cmccann> it all makes sense now
21:23:03 <Jafet> The skolem hits!  The skolem bits!
21:23:08 <`nand`> cmccann: haha
21:23:19 <cmccann> Jafet, You die... Would you like your types identified?
21:23:50 * `nand` is totally going to miss going back into a normal sleep schedule and missing these great hours on #haskell :(
21:24:00 <`nand`> that sentence was poorly worded
21:24:11 <shachaf> cmccann: You have never polymorphed a type?
21:24:47 <mikeplus64> hi, i'm mike, and i've unsafeCoerced rigid types to be polymorphic
21:24:49 <cmccann> shachaf, cf. my profile here http://gamedev.stackexchange.com/users/983/c-a-mccann
21:24:54 <mikeplus64> (hi mike)
21:24:57 <shachaf> You've linked that before.
21:25:03 <cmccann> yes.
21:25:15 <shachaf> blessed greased fixed point
21:25:16 <hejux> startling: thanks
21:25:44 <cmccann> shachaf, I'm still inordinately pleased with that, for being a joke that a very limited number of people will understand
21:26:17 <shachaf> Surely lots of people in here will understand it.
21:26:21 <shachaf> Like Jafet.
21:26:22 <cmccann> yes
21:26:30 <`nand`> you didn't even get to the +5 hylomorphisms?
21:26:35 <Jafet> I am very limited
21:26:46 <shachaf> Hylomorphisms are the devil.
21:26:59 <shachaf> Might as well employ direct recursion at that point!
21:27:10 <shachaf> This user has not answered any questions
21:27:10 <cmccann> shachaf, no, & is a devil
21:27:40 <shachaf> I remember the good old days when I was in #nethack
21:27:43 <shachaf> What an awful game.
21:27:59 <cmccann> it's fun until you get the hang of it
21:28:09 <cmccann> and realize that it's easy to win by playing in painfully tedious way
21:28:15 <shachaf> Yes.
21:31:42 <shachaf> I bet indexed zippers are going to be so great.
21:33:16 <startling> :t &
21:33:17 <lambdabot> parse error on input `&'
21:33:23 <startling> :t (&)
21:33:25 <lambdabot> a -> (a -> b) -> b
21:33:25 <startling> :t (*)
21:33:27 <lambdabot> Num a => a -> a -> a
21:33:29 <startling> :t (!)
21:33:31 <lambdabot> Ix i => Array i e -> i -> e
21:33:46 <startling> :t (/)
21:33:48 <lambdabot> Fractional a => a -> a -> a
21:33:58 <`nand`> are indexed zippers going to be a real thing, then?
21:34:03 <startling> :t (@)
21:34:04 <lambdabot> parse error on input `@'
21:34:06 <startling> aw.
21:34:33 <`nand`> in particular, storing and rewinding tapes of indices rather than positions
21:34:38 <shachaf> `nand`: They're already real, if you're fine with most of the API being ⊥
21:35:23 <Catnaroek> @src (&)
21:35:23 <lambdabot> Source not found. There are some things that I just don't know.
21:35:49 <Catnaroek> Oh, I expected "(&) = flip ($)".
21:36:10 <`nand`> I see :> grew an extra >
21:36:11 <shachaf> Expecting @src to work?
21:36:13 <shachaf> Dangerous.
21:36:47 <Catnaroek> lol
21:37:05 <`nand`> how long until lens runs out of names?
21:37:15 <`nand`> wait, never mind, you can just fall back to /dev/urandom
21:37:24 * hackagebot snaplet-i18n 0.0.3.1 - snaplet-i18n  http://hackage.haskell.org/package/snaplet-i18n-0.0.3.1 (HaishengWu)
21:37:31 <startling> `nand`: there *is* an infinite set of operators
21:37:55 <mercury^> Can one avoid typing the parameter that is made implicit by a functional dependency?
21:38:15 <mercury^> (typing as in writing out)
21:38:32 <edwardk> `nand`: the api for indexed zippers is still somewhat in flux
21:38:55 <edwardk> mercury^: no
21:39:11 <edwardk> mercury^: this is the downside to using functional dependencies
21:39:21 <`nand`> Top :> (a :@ i) :> (b :@ j) .. hmm
21:39:29 <mercury^> edwardk: Is that the reason why you used type families for monad-st, or is there another advantage?
21:39:42 <edwardk> `nand`: thats the current idea. its messy but it lets me do indexed searches
21:40:06 <edwardk> mercury^: its part of it. but in general you rarely talk about the 'world' type in ST operations, so it just made sense
21:40:49 <edwardk> at the time it was more of a coin toss that came down 'type families'.
21:41:04 <edwardk> and now it has users, so i won't change it without good reason
21:41:31 <Jafet> Where do you buy the fundep/family coin
21:41:52 <`nand`> at a bank, up to isomorphism
21:42:25 <edwardk> Jafet: you just get them custom printed
21:42:34 <edwardk> its pretty easy to 3d print anything you want these days
21:42:46 <hammersbang> hello guys!
21:43:21 <hammersbang> i'm trying out bitch x on my macbook via macports -.-
21:44:02 <`nand`> edwardk: wait, what's Track all about? Just internal usage?
21:44:19 <edwardk> `nand`: its used internally by tape because its 'off by 1'
21:44:28 <edwardk> if i figure out a nicer tape i can get rid of it
21:44:50 <`nand`> seems odd to list it in the haddock f-- oh, I'm looking at the .Internal page
21:44:53 <`nand`> never mind
21:45:23 <edwardk> C.L.Z.I was exported because shachaf didn't like the fact that i'd hidden the invariant-breaking parts of the API
21:46:49 <edwardk> 40 minutes of debugging because i hadn't turned on ScopedTypeVariables =/
21:47:04 <`nand`> what happens to restoreNearTape if the index isn't found, eg. in a Map?
21:47:48 <edwardk> `nand`: well, i'm still working the index stuff into all of that
21:47:59 <`nand`> okay
21:48:00 <edwardk> in the old version it'd move as far as it could and fail
21:48:01 <shachaf> {-# LANGUAGE Everything #-}
21:48:15 <edwardk> in the new version its still open what the right semantics are
21:48:37 <edwardk> it'll probably try to move there and fail
21:48:44 <shachaf> There should be a variant of -fglasgow-exts that still works.
21:48:46 <edwardk> or rather take the last key before it
21:49:07 <shachaf> Maybe it can print "THIS IS A TRIAL COPY" before running main or something.
21:49:27 <`nand`> if you consider it like moving into an ‘ix n’ traversal then failing entirely wouldn't be too insane
21:49:55 <edwardk> `nand`: thats what 'restore' is for
21:50:06 <edwardk> restoreNear tries to do the nearest thing it can within any level
21:50:10 <edwardk> but fails on moving down
21:50:19 <startling> shachaf: YOU HAVE 23 USES REMAINING
21:50:21 <`nand`> I'm just not sure ‘nearness’ for non-integer keys makes any sense
21:50:34 <edwardk> and i'm not sure that its possible for me to distinguish the type of key i'm given
21:50:47 <edwardk> hence 'don't use restore near' if you want to do something meaningful on maps
21:50:58 <`nand`> edwardk: yeah, but my point was that ‘restoreNearTape’ could pretend like “it found the key, but failed to move down into it”
21:51:06 <`nand`> when in reality it didn't find the key
21:51:17 <edwardk> `nand`: yes. restoreNear is very rarely what you want
21:51:24 <edwardk> stick to restore and unsafelyRestore
21:52:01 <edwardk> i'm including it because i liked the old behavior of restoreNear. its sometimes very much the right behavior. i don't want to remove it, but it doesn't cleanly make much sense for the new indexed operations
21:52:22 <`nand`> but you're right, it's not very feasible to distinguish between something like a Map Int either way; so the behavior would probably have to be ‘find the nearest key in all scenarios’
21:52:45 <edwardk> technically it finds the nearest preceding key
21:52:56 <shachaf> What happens for a traversal whose keys aren't Ord?
21:53:26 <`nand`> hmm; the type system prevents “restore as far as possible then return the zipper when you can't go any further”; right?
21:53:41 <`nand`> unless you wrap it inside an existential or something
21:53:48 <edwardk> shachaf: there are a whole host of open issues with these
21:53:59 <edwardk> `nand`: correct
21:55:33 <edwardk> my first step is to see if i can get it to work sanely for ordered traversals, and then to see if we can add other modes for scans, etc.
21:55:57 <edwardk> if you use 'downward' or 'within' you get an automatic Int index added for you
21:56:17 <edwardk> its 'idownward' and 'iwithin' that add the index from the source type and will be assuming it is ordered
21:56:27 <shachaf> I bet cmccann wants to try doing the crazy continuationy zipper.
21:56:29 <`nand`> within traverse = iwithin itraverse?
21:56:48 <shachaf> iwithin traversed?
21:56:52 <edwardk> shachaf: i don't understand how the 'crazy continuationy zipper makes any sense when you can back up after edits and want to have them remain
21:56:55 <`nand`> modulo class constraint
21:57:01 <edwardk> `nand`: yeah
21:57:16 <`nand`> oh, did not know of traversed
21:57:25 <edwardk> iwithin within = iwithin . indexing
21:57:41 <edwardk> er within = iwithin . indexing
21:57:46 <`nand`> traversed = indexing traverse ?
21:57:50 <edwardk> yeah
21:57:53 <shachaf> lens has traverse, traversed, itraverse, itraversed
21:57:56 <`nand`> well there we go
21:57:57 <shachaf> It's great.
21:58:07 <edwardk> shachaf: and we're forced into having at least 3 of the 4
21:58:18 <edwardk> *shrug*
21:58:39 * `nand` sleeps it off
22:02:03 <mysticc>  Is there a pointfree way to test equality on first element of a tuple?
22:02:13 <shachaf> @ty (==) `on` fst
22:02:14 <lambdabot> Eq b => (b, b1) -> (b, b1) -> Bool
22:02:42 <mysticc> @hoogle on
22:02:43 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
22:02:43 <lambdabot> Control.Exception.Base onException :: IO a -> IO b -> IO a
22:02:43 <lambdabot> Control.Exception onException :: IO a -> IO b -> IO a
22:03:16 <Jafet> :t liftA2 (==) `join` swap
22:03:17 <lambdabot> (Eq b, Eq a) => (a, b) -> Bool
22:03:35 <M30W> appamatto: remember okay.. how to recal?
22:03:41 <M30W> @recall
22:03:41 <lambdabot> Unknown command, try @list
22:03:45 <M30W> @list
22:03:45 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
22:03:55 <M30W> Useless see cmd
22:03:56 <M30W> haha
22:04:03 <mysticc> :t on
22:04:04 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
22:04:31 <M30W> @quote m30W
22:04:31 <lambdabot> No quotes match. There are some things that I just don't know.
22:04:31 <shachaf> Can we make a two-way version of on for lenses?
22:04:56 <mysticc> @pl \(a,b) (c,d) -> (c,b+d)
22:04:56 <M30W> @fortune
22:04:56 <lambdabot> Couldn't find fortune file
22:04:56 <lambdabot> (`ap` snd) . (. fst) . flip ((.) . (,)) . (+) . snd
22:05:02 <M30W> :(
22:05:09 <edwardk> shachaf: signature and use?
22:05:10 <mysticc> wtf
22:05:18 <M30W> mysticc: pointless :D
22:05:22 <shachaf> edwardk: I was hoping you'd do that part.
22:05:29 <edwardk> fixing zippers =P
22:05:39 <edwardk> or breaking them depending on your point of view
22:05:48 <mysticc> Is there a simple pointfree version of that
22:06:36 <shachaf> "We do on stage the things that are supposed to happen off. Which is a kind of integrity, if you look on every exit being an entrance somewhere else."
22:06:40 <byorgey> mysticc: probably not
22:06:44 <M30W> @. pl \(a,b) (c,d) -> (c,b+d)
22:06:44 <lambdabot> Plugin `compose' failed with: Unknown command: "\\(a,b)"
22:07:05 <byorgey> mysticc: but if you instead use  (Last a, Sum b)  it's just the 'mappend' (or (<>)) operation
22:09:04 <M30W> What is the most obsucated haskell code that exists?
22:10:54 <startling> M30W: http://comonad.com/haskell/remorse-1.0/remorse.hs
22:10:58 <byorgey> M30W: http://www.haskell.org/haskellwiki/Obfuscation
22:12:52 <M30W> startling: so... brainfuck for haskell; thanks.
22:16:41 <startling> M30W: not quite. :)
22:17:00 <M30W> startling: Close tho. :P
22:20:43 <mysticc> How to hide a module from a package in cabal. I have two dependencies in a package base and haskell98 and bot export prelude?
22:21:43 <mm_freak_> mysticc: if you depend on both packages and they provide the same module, you can use the PackageImports extension
22:21:51 <mm_freak_> import "mtl" Control.Monad.Reader
22:22:58 <mysticc> mm_freak_: Thats for some other module, what about Prelude. I don't want to write this on all the files of the package. Can I do this in Cabal?
22:23:23 <byorgey> mysticc: you should not depend on both base and haskell98.
22:23:37 <byorgey> you must choose one.
22:24:27 <byorgey> haskell98 is if you want to write a program which conforms to the Haskell 98 standard.  base is for the Haskell 2010 standard.
22:25:17 <geekosaur> actually base has moved beyond h'2010 as well (see:  Eq and Show superclasses for Num)
22:25:21 <mysticc> byorgey: If I remove either I start getting errors. If I remove haskell98 I get module System not found and for other I get Data.Word not found?
22:25:34 <byorgey> mysticc: right, System is an old name
22:25:39 <geekosaur> System has been split into a number of other modules
22:25:47 <byorgey> you need to replace it with something like System.IO or System.Environment
22:25:53 <byorgey> it depends what you were using from System
22:26:18 <mysticc> Its pretty old package I am trying to install, something around 2007
22:26:59 <byorgey> which package?
22:27:15 <mysticc> byorgey: Its not on hackage
22:27:49 <mysticc> byorgey: I have received the code from some guy (its not opensourced yet)
22:28:12 <byorgey> well, your best chance is to remove haskell98 and try to fix the errors which come up
22:28:16 <mysticc> @hoogle catch
22:28:17 <lambdabot> Prelude catch :: IO a -> (IOError -> IO a) -> IO a
22:28:17 <lambdabot> System.IO.Error catch :: IO a -> (IOError -> IO a) -> IO a
22:28:17 <lambdabot> Control.OldException catch :: IO a -> (Exception -> IO a) -> IO a
22:28:18 <mysticc> thanks
22:37:39 <mysticc> byorgey: What does this error mean http://hpaste.org/79938
22:38:14 <mysticc> oops sorry
22:41:07 <startling> hehe
22:42:02 <mysticc> @hoogle Ratio
22:42:03 <lambdabot> Prelude type Rational = Ratio Integer
22:42:03 <lambdabot> Data.Ratio type Rational = Ratio Integer
22:42:03 <lambdabot> Data.Ratio module Data.Ratio
22:42:38 <mysticc> startling: I know. Sometimes you don't see the most obvious thing.
22:42:51 <sw2wolf> :t (%)
22:42:52 <lambdabot>     Not in scope: `%'
22:42:53 <lambdabot>     Perhaps you meant `R.%' (imported from Data.Ratio)
22:42:58 <sw2wolf> :t %
22:42:59 <lambdabot> parse error on input `%'
22:43:10 <sw2wolf> :t (<%>)
22:43:12 <lambdabot>     Not in scope: `<%>'
22:43:12 <lambdabot>     Perhaps you meant one of these:
22:43:12 <lambdabot>       `<>' (imported from Data.Monoid),
22:44:44 <mysticc> @hoogle getCurrentDirectory
22:44:45 <lambdabot> System.Directory getCurrentDirectory :: IO FilePath
22:46:34 <mm_freak_> any lambdabot operators here?
22:47:24 <shachaf> Legitimate ones?
22:48:38 <mm_freak_> just someone who can @join
22:54:27 <Enigmagic> > join (Just (Just "no"))
22:54:28 <lambdabot>   Just "no"
22:54:51 <mysticc> @hoogle ClockTime
22:54:51 <lambdabot> System.Time data ClockTime
22:54:51 <lambdabot> System.Time addToClockTime :: TimeDiff -> ClockTime -> ClockTime
22:54:51 <lambdabot> System.Time diffClockTimes :: ClockTime -> ClockTime -> TimeDiff
22:55:45 <startling> > join ["#some-other-channel?"]
22:55:47 <lambdabot>   "#some-other-channel?"
22:55:54 <mysticc> @hoogle UTCTime -> ClockTime
22:55:55 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
22:55:55 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
22:55:55 <lambdabot> Data.Function ($) :: (a -> b) -> a -> b
22:56:09 <mysticc> Is there such function?
22:56:17 <startling> it's usually a bad sign when hoogle's first result is unsafeCoerce. >.>
22:56:33 <sclv> mysticc: you can interact with lambdabot in privmsgs too, you know, if you don't want it all to be on channel
22:56:46 <sclv> working with time is a pain
22:58:11 <sclv> you can send a CalendarTime to a ClockTime
22:58:17 <sclv> so the question is how you get a CalendarTime
22:58:29 <lispy> I don't even understand why our time apis are so bad
22:58:43 <lispy> it seems like something we'd be able to get right.
22:58:57 <roconnor> why are they bad?
22:59:32 <startling> it might be a documentation problem.
22:59:41 <sclv> clocktime is ancient
22:59:47 <sclv> nobody really uses it these days
22:59:47 <lispy> roconnor: in my experience, they've been poorly documented, important functionality is spread out oddly across modules/packages. Lots of little things like that.
23:00:06 <sclv> yeah, its powerful and does all the right things
23:00:11 <sclv> but its impossible to navigate
23:00:48 <lispy> sometimes I wanted to simply add or subtract time and I ended up writing code for that.
23:00:56 <sclv> system.time is from old-time
23:01:03 <sclv> which basically nobody uses anymore.
23:01:06 <lispy> I never did figure out if it was there and I just didn't find it
23:01:35 <robs> System.Time crashed ghc the only time I tried to use it
23:01:37 <roconnor> lispy: did you want to add or subtract time counting or ignoring leap seconds and/or day light savings time?
23:01:44 <sclv> mysticc: so go and cabal install this package: http://hackage.haskell.org/package/datetime
23:01:51 <roconnor> lispy: african or european
23:01:55 <sclv> and it has a conversion function that takes utctime to clocktime
23:02:03 <sclv> which is the easiest thing for you right now
23:02:09 <lispy> roconnor: I wanted to time the critical section of my code, so I didn't really care about global things like that.
23:02:18 <sclv> in the long term, i'd migrate the program off of using old-time
23:02:53 <sclv> there's still got to be an api that presents those options less horribly than what we have
23:03:25 <lispy> I ended up converting all the smaller order time units (nanoseconds?) into an Integer along with the higher order units (seconds?) and then took the difference of the Integers
23:03:26 <Enigmagic> sclv: i'm working on one
23:06:34 <mysticc> sclv: Thanks
23:07:35 <roconnor> Ideally we wouldn't be using the time library for timing code.  There is about a million things that could go wrong.
23:08:57 <roconnor> there are leap-seconds, adjtime and ntp are constantly reseting the system clock ...
23:09:18 <roconnor> getting the linux system running time would be better.
23:09:35 <roconnor> maybe wrapped up in a nice code-timing library with a bracket like operation
23:10:11 <lispy> roconnor: I was fetching from the high-precison real-time clock, but IIRC it returned something that the time libraries know about. Maybe I'm conflating bad apis?
23:10:40 <startling> leap seconds are really annoying. :/
23:10:49 <startling> we should just save up and buy a year.
23:10:54 <roconnor> lispy: System.Posix.Clock?
23:11:16 <roconnor> that certainly seems appropraite
23:11:23 <roconnor> it returns a TimeSpec
23:11:39 <roconnor> nothing to do with the Time library though
23:12:51 <lispy> roconnor: that looks right.
23:12:58 <lispy> it's very minimal
23:13:27 <lispy> although, I thought I used something linux specific
23:14:30 <beefcube> is naive use of libaries based on Arrow's as it is with Monads, or should I do the homework on learning Arrow's as well?
23:15:30 <Jafet> http://ro-che.info/ccc/12.html
23:15:40 <lispy> roconnor: I think this is actually what I used: http://hackage.haskell.org/packages/archive/system-time-monotonic/0.2/doc/html/System-Time-Monotonic.html
23:15:55 <lispy> roconnor: looking at it now, I see that it does have a Num instance. No idea why I didn't use it.
23:17:21 <Estrellas>     Couldn't match expected type `system-filepath-0.4.7:Filesystem.Path.Internal.FilePath' with actual type `[Char]'
23:17:26 <lispy> Well, I used something...and now I'm getting confused by the time/clock apis trying to just figure out what I used :)
23:17:27 <Estrellas> I thought they were the same thing?
23:17:59 <lispy> Estrellas: I thought system-filepath was its own type. Prelude's FilePath is [Char]
23:18:11 <Estrellas> ohh
23:18:39 <lispy> http://hackage.haskell.org/packages/archive/system-filepath/0.4.7/doc/html/src/Filesystem-Path-Internal.html
23:38:53 <M30W> mm_freak_: Back, sorry laptop went to sleep when I closed the lid. -_-
23:39:04 <mm_freak_> sure
23:39:10 <M30W> mm_freak_: wrong channel anyhow
23:39:11 <M30W> haha
23:39:32 <mm_freak_> no worries…  it's not off-topic here anyway =)
23:45:56 <M30W> mm_freak_: haha, true.
23:47:00 <M30W> mm_freak_: I shall go back to my noob-haskell-learning hehe.
23:55:07 <M30W> cancelWith a x = throwTo (asyncThreadId a) x
23:55:18 <M30W> ^ As of last night I can acturally read that. :D
23:55:19 <Lethalman> hi somebody yesterday said that System.Random mkStdGen was slow, what should I use?
23:55:57 <M30W> Lethalman: Normally I would suggest /dev/urandom, but in haskell land. No clue.
23:56:11 <Lethalman> also another question, is it possible to get a function given its name? e.g. from a configuration file
23:56:34 <M30W> @src cancelWith
23:56:35 <lambdabot> Source not found. My mind is going. I can feel it.
23:56:43 <M30W> @src >>=
23:56:44 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
23:56:49 <M30W> Meh.
23:57:00 <M30W> Lethalman: lambdabot has a method for getting src for things
23:57:56 <M30W> Lethalman: Why do you need the function's src anyway?
23:58:08 <Lethalman> M30W, I don't need the source
23:58:26 <Lethalman> M30W, I need something like String -> (a -> b)
23:58:27 <M30W> possible to get a function given it's name?
23:58:34 <M30W> Eh.
23:58:36 <Lethalman> M30W, yes something like java reflection
23:58:39 <M30W> types
23:59:08 <M30W> :t on ghci
23:59:10 <lambdabot> Not in scope: `ghci'
23:59:32 <M30W> lol..
23:59:38 <M30W> :t putStrLn
23:59:40 <M30W> There
23:59:40 <lambdabot> String -> IO ()
23:59:48 <M30W> Lethalman: Like that?
