00:00:48 <johnw> no?
00:01:22 <shachaf> Well, it's a somewhat bizarre function.
00:01:27 <shachaf> Who knows.
00:01:45 <randomclown> waiting for homofunctors
00:02:47 <johnw> Saizan: how would Foo a t refer to s or b?
00:03:22 <shachaf> newtype Blah q w e r x y = Blah ...
00:03:35 <shachaf> Foo s t a b a t -> Foo s t a b s b
00:03:41 <shachaf> That's fine.
00:03:45 <shachaf> Er, Blah
00:03:45 <johnw> but the kind of Foo in your query is * -> * -> *
00:03:46 <shachaf> Whatever.
00:03:49 <shachaf> Yes.
00:03:53 <shachaf> let Foo = Blah s t a b
00:05:58 <johnw> if that is how Foo is defined, then what does your query look like?
00:06:24 <johnw> see, I don't get how Foo a t is ever going to know about b, in order to be isomorphic to a -> b
00:07:00 <shachaf> (Blah s t a b) is a perfectly valid Foo
00:07:11 <johnw> making Foo a t b -> Foo s b t ~~ (a -> b) -> s -> t is easy
00:07:15 <shachaf> (Blah s t a b) a t -> (Blah s t a b) s b
00:07:22 <johnw> ah, i see what you mean
00:10:40 <mikeplus64> shachaf: why s t a b? any reason other than you can have stuff like Getting a s t a b?
00:11:21 <shachaf> mikeplus64: Pick any order you want.
00:11:24 <shachaf> It doesn't matter here.
00:11:25 <kallisti> mikeplus64: because knives are fun
00:11:27 <randomclown> same type attack bonus duh
00:11:34 <kallisti> yes
00:11:36 <shachaf> What matters is Foo a t -> Foo s b
00:11:48 <shachaf> Also, you can try Foo s b -> Foo a t if you prefer.
00:11:51 <shachaf> That one might be easier to think about.
00:11:59 <shachaf> (I'm not sure either is possible.)
00:12:22 <mikeplus64> shachaf: i'm just wondering wrt lens if there is a mnemonic other than the fact it's s t a b (which clearly i have remembered -- so it must be good)
00:13:16 <shachaf> mikeplus64: Well, the shape is Lens (a,x,y) (b,x,y) a b
00:13:26 <shachaf> a and b are just simple type variables
00:13:28 <shachaf> @ty map
00:13:30 <lambdabot> (a -> b) -> [a] -> [b]
00:13:32 <shachaf> They're that a and b
00:13:46 <shachaf> s stands for "structure" or "source" or "state"
00:14:01 <shachaf> t sometimes stands for "target" but usually stands for "the letter that comes after s"
00:14:20 <hpaste> johnw pasted “second-attempt.hs” at http://hpaste.org/79668
00:14:22 <johnw> what about that?
00:14:40 <shachaf> Blah s t a b i j = Blah { runBlah :: i -> (t,b) }
00:14:59 <shachaf> Blah s t a b a t -> Blah s t a b s b
00:15:18 <shachaf> (a -> (t,b)) -> (s -> (t,b))
00:15:33 <johnw> hm.. just one swap away
00:15:50 <johnw> if only I had a type-level "case"
00:18:43 <notdan> Hi!
00:18:59 <notdan> What is the default go-to CSV library out there?
00:19:02 <lewisx> is there a functikn that uncurries more than just two arguments?
00:19:07 <johnw> i've heard cassava spoken highly of
00:19:08 <notdan> It need not to be super fast or anything
00:19:22 <shachaf> lewisx: Not in the Prelude.
00:19:24 <johnw> wait, that's not it
00:19:35 <notdan> Hm, does it work fine with unicode?
00:19:42 <lewisx> shachaf: what is the name of the function?
00:19:44 <johnw> yeah, that's it
00:20:02 <shachaf> lewisx: What function?
00:20:03 <johnw> http://hackage.haskell.org/package/cassava
00:20:20 <johnw> it's by tibbe, so it's probably quite decent
00:20:43 <notdan> true
00:20:52 <johnw> notdan: it uses ByteString, so the Unicode decoding is up to you
00:20:56 <lewisx> uncurryN. you said not in prelude so I thought it is in some other module
00:21:35 <johnw> the way cassava defines parsers is very similar to aeson (wonder which one came first)
00:21:46 <m3ga> johnw: i needed to process quite large data files and i found csv-conduit worked well for me.
00:21:54 <shachaf> lewisx: Some people call a function for 3 arguments uncurry3
00:22:02 <shachaf> But you probably have to define it yourself.
00:22:06 <shachaf> Better yet, don't use 3-tuples.
00:22:11 <m3ga> johnw: i think cassava uses attoparsec. attoaprsec and aseon are both by bos
00:22:58 <johnw> ah, makes sense
00:23:27 <notdan> csv-conduit has a Text parser, cool
00:24:07 <notdan> albeit I don't know anything about conduit
00:25:40 <johnw> conduit is pretty nice, i've been using it lately
00:27:14 <m3ga> johnw: if thats the case, then i heartily recommend csv-conduit. i just blogged about it http://www.mega-nerd.com/erikd/Blog/CodeHacking/Haskell/my_space_is_leaking.html
00:28:39 <johnw> cool, i'll queue it
00:42:52 <van> I need to choose between haskell and clojure.... Can somebody help me?
00:42:58 <johnw> clojure
00:43:34 <van> I like clojure, but I don't like the jvm...\
00:44:54 <startling> van: haskell
00:45:11 <van> I truely like haskell, but people say don't use it for real stuff.... Just a subcon...
00:45:25 <johnw> van: clojure
00:45:28 <startling> van: they're wrong
00:46:20 <van> startling: I am a freelance...
00:47:11 <Jafet> > ["Clojure", "Haskell"] !! fst (randomR (0, 1) $ mkStdGen 0)
00:47:12 <lambdabot>   "Haskell"
00:47:28 <van> startling: Do you have any insight of freelancers using haskell? That would be helpful
00:47:47 <lewisx> Jafet now repeat that 20 times :)
00:48:06 <startling> van: nope
00:48:18 <Jafet> > [["Clojure", "Haskell"] !! fst (randomR (0, 1) $ mkStdGen n) | n <- [0..]]
00:48:19 <lambdabot>   ["Haskell","Haskell","Haskell","Haskell","Haskell","Haskell","Haskell","Has...
00:48:34 <startling> the choice is clear!
00:48:38 <simpson> Wat.
00:49:38 <van> Yeah. Haskell it is for me... but I haven't fully mastered it yet.
00:50:48 <van> To socialize, I am yet to find an indipendent developer using haskell.....
01:02:44 <AfC> m3ga: hey, hadn't noticed your post about space leaks. Always eager to read people talking about how they tame the beast.
01:03:39 <m3ga> AfC: hey! yeah, in this case (small program already using conduit) it was pretty obvious what was going wrong and how to fix it.
01:05:56 <AfC> m3ga: I've been studying the parser gcollins is writing for the next version of his snap-server library. Bloody voodoo, but even though I don't really know what's going on, I'm getting ideas even from i.e. SCC annotations
01:07:24 <alang> @pl \xs -> map (\x -> map (x *) xs)
01:07:25 <lambdabot> map . flip (map . (*))
01:07:26 <m3ga> yeah, benl23 uses SCC because it makes tracking down memory usage sources easier from the profiling data
01:07:50 <beaky> hello
01:09:30 <beaky> All programming languages were born to solve a problem. C was invented to port the UNIX operating system. Perl was designed as an awk killer to efficiently process text. Javascript was designed to implement interactive webpages. What was Haskell born to do?
01:10:11 <simpson> Teach, IIUC.
01:10:19 <beaky> teach? :(
01:10:40 <beaky> I read some document about the origin of haskell and I thought Haskell was made to standardize lazy purely-functional languages
01:10:54 <simpson> I dunno. I don't know things.
01:11:01 <beaky> ah
01:15:50 <lewisx> .
01:16:15 <beaky> @src (.)
01:16:16 <lambdabot> (f . g) x = f (g x)
01:16:16 <lambdabot> NB: In lambdabot,  (.) = fmap
01:17:13 <lewisx> just checking if I am still connected
01:17:42 <lewisx> ca someone explain why one works but not the other?  http://hpaste.org/79669
01:17:50 <dbushenko> $src ($)
01:18:09 <dbushenko> @src ($)
01:18:10 <lambdabot> f $ x = f x
01:18:15 <Jafet> beaky: Haskell was born to supply problems
01:19:12 <beaky> ah
01:19:17 <beaky> what kind of problems does haskell suply?
01:19:29 <dbushenko> whats the difference between $ and .  ?
01:20:03 <Maxdamantus> What's the similarity?
01:20:48 <dbushenko> looks like both just make it possible to set the priorities
01:21:06 <lewisx> foo $ x y  is   the same as foo (x y).  neither is comparable to (.)
01:21:28 <Maxdamantus> > let a = (5+) . (/4) in a 20
01:21:30 <lambdabot>   10.0
01:21:58 <beaky> $ is function application
01:21:59 <Jafet> > let a = (5+) $ (/4) in a 20
01:22:00 <lambdabot>   No instance for (GHC.Num.Num (a0 -> a0))
01:22:01 <lambdabot>    arising from a use of `e_15420'...
01:22:03 <beaky> while . is composition
01:22:15 <dbushenko> thanks
01:23:15 <beaky> > map ($ 3) [(+1), (-1)]
01:23:17 <lambdabot>   No instance for (GHC.Num.Num (b0 -> b0))
01:23:18 <lambdabot>    arising from a use of `e_1311'
01:23:18 <lambdabot> ...
01:23:19 <kennyd> > (show . (^2)) 10
01:23:20 <beaky> :(
01:23:20 <lambdabot>  Terminated
01:23:29 <kennyd> > (show . (^2)) 10
01:23:31 <lambdabot>   "100"
01:23:41 <Maxdamantus> > map ($ 3) [(+1), (subtract 1)]
01:23:43 <lambdabot>   [4,2]
01:24:40 <johnw> @pl \f -> get >>= return . f
01:24:41 <lambdabot> (get >>=) . (return .)
01:24:57 <lewisx> anyone knows why one works but not the other? doesnt make sense. http://hpaste.org/79669
01:26:10 <mikeplus64> lewisx: the monad the first one is using isn't IO, it's ((->) a), the function monad
01:26:15 <Maxdamantus> Because you can't make it *ANY* type.
01:26:27 <Maxdamantus> It's already restricted.
01:26:33 <mikeplus64> wait oops
01:26:47 <mikeplus64> i misread =<< as <=< sorry disregard what i just said lewisx
01:27:42 <beaky> :t (***)
01:27:44 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
01:27:52 <Maxdamantus> lewisx: imagine: let id v = let silly :: a; silly = v in silly
01:27:56 <beaky> what does (***) do
01:28:02 <beaky> what's an arrow
01:28:15 <johnw> shachaf: how do I make an ad hoc lens for any record field?
01:28:17 <Maxdamantus> lewisx: you can't say that `silly` is of any type; it's of whatever type v is.
01:28:18 <johnw> is that "lens"?
01:28:19 <mikeplus64> > succ *** pred $ (0, 0)
01:28:21 <lambdabot>   (1,-1)
01:28:23 <mikeplus64> beaky:
01:28:26 <Twisol> beaky: apparently, combines two arrows in parallel
01:29:01 <edwardk> johnw: in general my advice is not to use the 'lens' combinator directly.. ever
01:29:16 <johnw> well, i have this record containing a record in state
01:29:17 <mikeplus64> an arrow generalises (->). to be honest i don't think i've ever seen an arrow other than the function arrow actually used
01:29:23 <Twisol> imagine a is (->), which is a specific instance of Arrow, and figure out what the type is for that instance
01:29:30 <johnw> and i need a convenient way to modify one of the fields in the innermost record
01:29:45 <johnw> and I can't lensify both records
01:29:51 <mikeplus64> beaky: so in that case, with the function arrow, (***) :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)
01:29:53 <johnw> (i.e., with makeClassy)
01:29:57 <johnw> so what's the recommend approach?
01:30:18 <edwardk> myLens f myrec = f (getFoo myrec) <&> \r -> myrec { getFoo = r }
01:30:25 <edwardk> gets you the lens without using 'lens'
01:30:28 <johnw> ok
01:30:30 <johnw> works for em!
01:30:37 <beaky> :t (+1) *** (-1)
01:30:39 <lambdabot> (Num (b' -> c'), Num c) => (c, b') -> (c, c')
01:30:53 <beaky> (+1) *** (-1) $ (0, 0)
01:31:00 <beaky> > (+1) *** (-1) $ (0, 0)
01:31:00 <edwardk> subtract 1
01:31:02 <lambdabot>   Could not deduce (GHC.Num.Num (b'0 -> c'))
01:31:02 <lambdabot>    arising from the ambiguity ch...
01:31:03 <Maxdamantus> > let id v = { let silly :: a; silly = v in silly } in id 4
01:31:03 <edwardk> (-1) is a number
01:31:05 <lambdabot>   <hint>:1:12: parse error on input `{'
01:31:06 <mikeplus64> beaky: sadly (-1) is treated as (negate 1)
01:31:06 <beaky> oh
01:31:12 <beaky> > (+1) *** (subtract 1) $ (0, 0)
01:31:14 <lambdabot>   (1,-1)
01:31:34 <Maxdamantus> > let id v = let silly :: a; silly = v in silly in id 4
01:31:36 <lambdabot>   Couldn't match type `t' with `a2'
01:31:36 <lambdabot>    `t' is a rigid type variable bound by
01:31:36 <lambdabot> ...
01:32:01 * Maxdamantus should figure out Haskell's indentation some time.
01:33:55 <notdan> Does anybody have any experience working with CSV files with dates? I am trying to use Cassava and it turns out I have to write a FromField instance for UTCTime myself. I tried the following ,but it does not work: http://hpaste.org/79670
01:34:26 <`nand`> > let id v = let { silly = v in silly } in id 4 -- Maxdamantus
01:34:28 <lambdabot>   <hint>:1:28: parse error on input `in'
01:34:36 <`nand`> :(
01:34:43 <notdan> It doesn't work because readTime has type :: ... -> t, where ParseTime t, but parseField outputs Parser t
01:34:45 <`nand`> oh, of course
01:34:50 <`nand`> > let id v = let { silly = v } in silly in id 4 -- Maxdamantus
01:34:52 <lambdabot>   4
01:35:15 * Maxdamantus thought it'd be confused by the chain of ins.
01:35:24 <`nand`> > let id v = let silly = v in silly in id 4
01:35:26 <lambdabot>   4
01:35:27 <`nand`> not at all
01:35:34 <Twisol> > ((+1) *** (subtract 1)) . (id &&& id) $ 0
01:35:36 <lambdabot>   (1,-1)
01:35:41 <Maxdamantus> Yeah. I can see now that that bit is actually unambiguous.
01:36:04 <mikeplus64> > (succ *** pred >>> succ *** pred) (0, 0)
01:36:06 <lambdabot>   (2,-2)
01:36:12 <Maxdamantus> It's always left-recursive.
01:36:22 <johnw> edwardk: that works perfectly, thank you
01:36:35 <`nand`> > (0,0) & _1 +~ 1 & _2 -~ 1
01:36:37 <lambdabot>   (1,-1)
01:36:58 <Twisol> one of these days, I need to learn lens.
01:37:16 <`nand`> you could make that day today
01:37:23 <edwardk> we have video =)
01:37:25 <Twisol> not at 1:30am!
01:37:37 <`nand`> http://lens.github.com/
01:37:38 <`nand`> ah
01:37:40 <Twisol> edwardk: The one posted on Reddit a couple days ago?
01:37:43 <shachaf> johnw: Is your question still unanswered?
01:37:47 <shachaf> Oh, edwardk got to it first.
01:37:51 <edwardk> Twisol: its been replaced with one with fixed audio
01:38:04 <Twisol> edwardk: I'm about an hour and twenty into it (yes, with the fixed audio), but had to pause
01:38:22 <Twisol> Very cool stuff.
01:38:37 <Twisol> (most of which goes just slightly over my head, but I get the drift)
01:38:54 <edwardk> going to set up a page on lens.github.com with the links to the slides, the video, etc.
01:39:00 <`nand`> <&> = flip (<$>) ?
01:39:01 <shachaf> Sometime I should try introducing profunctorial lenses to someone who doesn't know about any other kind.
01:39:08 <shachaf> Just as a little generalization of SECs.
01:39:21 <shachaf> They'd probably think twan lenses are horribly complicated in comparison.
01:39:26 <edwardk> heh
01:39:56 <edwardk> they lose because traversals are common and too verbose that way
01:40:15 <`nand`> twan lenses?
01:40:26 <edwardk> but yes the twan+profunctor form are more complicated than idea
01:40:28 <edwardk> er ideal
01:40:29 <shachaf> Sure, as a final side-note you can mention that in practice p a (f b) is more useful.
01:40:46 <edwardk> `nand`: "lens" lenses are you know them
01:40:59 <`nand`> I thought those were van laarhoven lenses
01:41:07 <edwardk> twan is his first name
01:41:07 <shachaf> "twan van laarhoven" is his full name.
01:41:11 <`nand`> I see
01:42:03 <edwardk> i think to flip the vocabulary around and call the twan+profunctor lenses profunctor lenses and the ones you like profunctor SECs
01:42:19 <statusfailed> I thought twan lenses were the non polymorphic ones?
01:42:25 <shachaf> I don't like the name "SEC".
01:42:33 <edwardk> muahaha
01:42:36 <shachaf> It's a scary name for a simple idea.
01:42:41 <edwardk> and this is how i win the terminological battle ;)
01:42:45 <shachaf> statusfailed: They can be made polymorphic trivially.
01:42:49 <statusfailed> oh I see
01:42:57 <Maxdamantus> lewisx: there's a GHC extension that might make the error more explicit.
01:43:04 <shachaf> kmc would get annoyed at the use of the word "trivial".
01:43:08 <statusfailed> I got to understanding twan lenses and then went "and via magic, we get polymorphism" :P
01:43:17 <shachaf> My defense is that you make them polymorphic by commenting out the type signature.
01:43:17 <Maxdamantus> Hmm .. that was the last thing I asked about here, I think.
01:43:32 <edwardk> statusfailed: (a -> f a) -> s -> f s  becomes (a -> f b) -> s -> f t
01:43:33 <shachaf> statusfailed: You can get polymorphism with pretty much any lens representation.
01:43:37 <Maxdamantus> Can't remember what it's called .. it lets you declare parametric types.
01:43:43 <shachaf> statusfailed: Pick your favorite representation, I'll make it polymorphic.
01:43:47 <statusfailed> edwardk: I just haven't looked up which functors you set f to in order to get the magic
01:44:14 <edwardk> f doesn't change for polymorphism its still just Identity or Const
01:44:14 <Maxdamantus> (usually type parameters are completely implicit except in data/etc declarations and classes/instances)
01:44:26 <statusfailed> oh!
01:44:32 <Maxdamantus> Maybe -XExplicitTypeParameters or something.
01:45:07 <edwardk> it just becomes a lot harder to screw up and pass an a accidentally where a b belongs
01:45:33 <statusfailed> edwardk: you mean by using more than just Identity and Const?
01:45:51 <`nand`> by separating ‘a’ and ‘b’ or ‘s’ and ‘t’
01:45:52 <edwardk> no i mean, you can screw up the simple lens for (a,b) a
01:45:55 <Maxdamantus> It seems like a silly extension though :\
01:46:02 <statusfailed> oh I see
01:46:05 <Maxdamantus> It should let you declare type variables around any expressions.
01:46:08 <edwardk> its hard to screw up the polymorphic one for Lens (a,c) (b,c) a b
01:46:11 <edwardk> the types won't let you
01:46:19 <`nand`> Maxdamantus: are you thinking of ScopedTypeVariables or something?
01:46:25 <Maxdamantus> Hmm .. actually, no, that wouldn't make sense.
01:46:27 <shachaf> edwardk: With enough unsafeCoerce, anything is possible.
01:46:30 <Maxdamantus> `nand`: ah, maybe.
01:46:37 <edwardk> shachaf: hah
01:46:44 <edwardk> we're back down to ~11
01:46:54 <`nand`> Maxdamantus: which lets you do let x :: [a]; x = y ++ [] where y :: [a]; y = []
01:47:02 <Maxdamantus> `nand`: yep.
01:47:10 <`nand`> and the ‘a’ of y would refer to the ‘a’ of x
01:47:13 <shachaf> We're still using that bizarre CPSed Exchange?
01:47:14 <`nand`> (then again, that would work without the extension)
01:47:23 <edwardk> yeah
01:47:24 <Maxdamantus> `nand`: but not something like: for all types a, let x = ..
01:47:27 <`nand`> oh, for a better example
01:47:37 <Maxdamantus> `nand`: so you don't need to give a full type for x
01:47:38 <shachaf> I have no idea whether it's justified.
01:47:42 <`nand`> let x :: forall a. Num a => [a]; x = y : [2,3,4,5] where y :: a; y = 1
01:47:45 <edwardk> benchmark and kill it then ;)
01:47:59 <shachaf> I'll just let it accumulate.
01:50:44 <Twisol> Well, that was awfully pleasant. Somehow my mac got stuck halfway between two workspaces and I had to hard reboot. :|
01:50:52 <lewisx> forM is cute. :)
01:51:17 <bxc> forM almost turns things back into a normal language ;)
01:51:38 <zuserm> good morning
01:51:47 <beaky> with the right monads, haskell can look like an imperative language
01:52:11 <beaky> http://stackoverflow.com/a/5269180
01:52:25 <shachaf> I wonder whether there are other things that can use the (p ... -> p ...) trick so as not to require as Category instance.
01:52:38 <mikeplus64> lewisx: i often define "for" as for m f = go 0 where go i = if i < m then f i else return ()
01:52:49 <mikeplus64> so then i can do like for 100 $ \i -> ...
01:53:06 <mikeplus64> f i >> go (i + 1) i mean
01:53:38 <shachaf> mikeplus64: Why not forM_ [0..99] $ \i -> ?
01:53:50 * Maxdamantus saw some some things designed to let you write Haskell that looks like C :\
01:53:58 <mikeplus64> because that requires a list i don't need or want
01:54:08 <shachaf> mikeplus64: (Assuming you meant to make go recursive.)
01:54:15 <shachaf> mikeplus64: Are you talking about performance or what?
01:54:20 <mikeplus64> yeah
01:54:21 <Maxdamantus> http://kormacode.blogspot.co.nz/2011/11/c-style-haskell_10.html
01:54:35 <shachaf> That seems like premature optimization.
01:54:36 <statusfailed> mikeplus64: you're in luck :D
01:54:48 <mikeplus64> last time i tried it, my "for" above was much much faster for it
01:54:49 <beaky> what is the differnece between state and data?
01:54:53 <shachaf> You can make a RULE so forM_ [n..m::Int] $ \i -> becomes your "for".
01:55:18 <mikeplus64> shachaf: it wasn't when i was doing like for 640 $ \x -> for 480 $ \y -> render pixels dumbly
01:55:29 <zuserm> anyone have much experience with optparse-applicative? I'm wondering if there's a way to get it to allow combined short options (e.g. -abc vs. -a -b -c).
01:55:30 <shachaf> No, I mean you can make one.
01:55:52 <Twisol> beaky: what context are you asking in?
01:55:52 <shachaf> mikeplus64: At one point rwbarton and I and a few other people tried out different loops.
01:56:01 <mikeplus64> i wonder why there isn't a RULE like that already
01:56:02 <shachaf> I think you can make it pretty good with the list.
01:56:06 <beaky> like in general
01:56:19 <mikeplus64> shachaf: it wasn't good enough for more than like 10 fps iirc
01:56:26 <mikeplus64> it was very slow
01:57:11 <shachaf> mikeplus64: I just tried -- it turns into a loop with no allocations.
01:57:18 <shachaf> At least in a simple case.
01:57:19 <mikeplus64> it's a really silly way to render stuff, but still
01:57:22 <Twisol> beaky: um, just speaking in terms of English, "state" connotes a value along a temporal (or other?) axis
01:57:27 <mikeplus64> shachaf: what simple case?
01:57:39 <Twisol> beaky: i.e. a state suggests other possible states, perhaps before or after
01:57:48 <shachaf> mikeplus64: foo = forM_ [0..10000::Int] $ \i -> print i
01:58:01 <beaky> ah
01:58:16 <beaky> so state is like a dimension
01:58:20 <mikeplus64> if it works for something like width <- readLn; height <- readLn; forM_ [0..width] $ \x -> forM_ [0..height] $ \y -> ..., neat
01:58:22 <beaky> while data is just data
01:58:37 <shachaf> Oh, I didn't try that.
01:58:39 <Twisol> beaky: no, state is a value in the context of a dimension of values
01:58:44 <beaky> oh
01:59:09 <Twisol> beaky: again, just in terms of English, and even more specifically my own understanding of it. ;)
01:59:10 <shachaf> mikeplus64: foo n = forM_ [0..n] $ \i -> print i still turns into a loop
01:59:24 * beaky has poor command over english :(
01:59:40 <mikeplus64> that's interesting, maybe something has changed since i last tried (it's a silly way to "put pixels" anyway)
01:59:57 <beaky> also, why is it so easy to define function composition in haskell, while it's so difficult to do in C++?
02:00:00 <shachaf> mikeplus64: OK, it looks like with nested loops it's not so great. :-(
02:00:01 <Twisol> beaky: the distinction between state and value is sort of subtle, so no worries
02:00:03 <beaky> or even in c?
02:00:18 <mikeplus64> shachaf: damn, i wonder why that is
02:00:27 <Twisol> beaky: Because there's no provision for creating a new function in C without creating more instructions and adding a pointer to the start of those new instructions
02:00:56 <statusfailed> shachaf: would it help to generate a list of tuples?
02:00:57 <Twisol> beaky: also Haskell is declarative, so you can let -it- define the new function - or as the case usually is, let it inline and optimize and not even define one at all
02:00:59 <shachaf> mikeplus64: It does one loop but the other one still does enumFromTo
02:01:07 <shachaf> statusfailed: I doubt it?
02:01:49 <neutrino> beaky: my answer would be, because haskell has an algebraic structure on the set of all functions with specific properties, whereas C doesn't have the properties that make it so easy.
02:02:03 <mikeplus64> shachaf: what if you do let for n f = forM_ [0..n] f in for 100 $ \x -> for 100 $ \y -> print (x, y) ?
02:02:13 <mikeplus64> maybe it'll optimize 'for'?
02:02:33 <beaky> might even optimize out the list :D
02:02:39 <statusfailed> shachaf: how are you viewing the optimised code?
02:02:52 <statusfailed> --ddump-something?
02:02:52 <shachaf> statusfailed: ghc-core
02:03:00 <shachaf> Yes, it does -ddump-simp
02:03:04 <shachaf> simpl
02:03:36 <shachaf> mikeplus64: By the way, you can still getter better performance than "for" if you're willing to write an ugly loop.
02:03:51 <shachaf> I got some really bizarre results last time I experimented with these sorts of loops.
02:04:12 <mikeplus64> shachaf: i write it with bangpatterns in reality, but don't go so far as to explicitly use unboxed ints or anything
02:04:25 <shachaf> Where the best option with a noticeable margin was to unbox two Ints but leave the third one boxed, or something like that.
02:04:41 <statusfailed> oh, -O2 loses the output?
02:04:44 <shachaf> GHC was floating out some allocations that it shouldn't.
02:04:53 <mikeplus64> bizarre
02:04:53 <shachaf> statusfailed: ?
02:05:04 <shachaf> statusfailed: I don't know what your question is but I bet the answer is -fforce-recomp
02:05:36 <statusfailed> ... thanks
02:05:54 <shachaf> It's always -fforce-recomp
02:08:23 <mikeplus64> ghc-core doesn't do -fforce-recomp by default (it ought to imo)
02:08:25 <mikeplus64> ?
02:08:40 <shachaf> It does.
02:08:50 <hpaste> beaky pasted “haskell roguelike” at http://hpaste.org/79671
02:08:55 <shachaf> 184:    let defaultArgs = words "-O2 -ddump-simpl -fforce-recomp --make"
02:09:02 <shachaf> I need to do some work on ghc-core. :-(
02:09:07 <beaky> anyone willing to critize my code? http://hpaste.org/79671
02:09:10 <beaky> ^^
02:10:04 <edwardk> beaky: needs more lenses
02:10:19 <beaky> more lenses? :D
02:10:20 <mikeplus64> shachaf: feature requests: make ghc core look less like it was indented by a well trained monkey, and hide/fold on command some of the noise you usually don't care about
02:10:50 <mikeplus64> i think the latter would require like making your own pager
02:10:58 <shachaf> mikeplus64: Do you know about -dsuppress-all?
02:11:04 <mikeplus64> nope
02:11:10 <shachaf> I'm going to add an option for some of the more common/useful supression options.
02:11:15 <edwardk> beaky: just saying you can clean up a lot of the move code
02:11:21 <beaky> ah right
02:11:21 <shachaf> mikeplus64: Add -dsuppress-all to the command line (after the file name, so it gets passed to GHC).
02:11:28 <beaky> I want to clean up that move code :D
02:11:28 <shachaf> It makes the output *way* more readable.
02:11:39 <mikeplus64> thanks
02:12:15 <shachaf> mikeplus64: Making a custom pager would be nice but a lot of work. :-)
02:12:25 <edwardk> beaky let me take a whack with lenses for my own edification
02:12:46 <beaky> :D sure
02:12:48 <shachaf> There are more pressing things that can be done to improve it.
02:12:56 <beaky> I want my roguelike to be well designed :D
02:13:01 <beaky> and not a hack :(
02:13:20 <shachaf> I think there are a lot of UI improvements that could be made to GHC.
02:13:30 <beaky> and good abstractions like monads and lenses = good design ^_^
02:13:33 <shachaf> There's so much information that it knows that it doesn't expose usefully, at every step of the compilation.
02:13:58 <mikeplus64> shachaf: woah it's like an entirely different language
02:14:04 <mikeplus64> that's quite readable
02:14:27 <shachaf> mikeplus64: Now you know the secret. :-)
02:14:58 <shachaf> mikeplus64: Another secret: If you want to see what's happening past the STG level but don't want to read the horrible generated assembly, use -ddump-cmm
02:14:59 <mikeplus64> although looking at this core suddenly i regret inlining lots of stuff
02:15:02 <mikeplus64> lol
02:15:26 <shachaf> Cmm has a lot more information that gets lost after that stage.
02:15:35 <shachaf> So it's much easier to read.
02:15:59 <zuserm> shachaf: secrets are bad, surely this should be documented somewhere easy to find?
02:16:07 <shachaf> zuserm: It should.
02:16:14 <mikeplus64> seeing the cmm pretty printed is really nice
02:16:17 <shachaf> I'm going to do it sometime. I have a bunch of changes I want to make.
02:16:35 <shachaf> (All I wanted to do was make it compile with GHC 7.6!)
02:17:57 <zuserm> shachaf: Yay. That definitely would have helped me at some point, and I doubt I'll remember the next time I need it.
02:18:09 <beaky> what is the most powerful feature of haskell
02:18:12 <beaky> that no other languages have?
02:18:29 <beaky> lisps' power is macros. perl's power is regexes. C's power is pointers...
02:19:00 <zuserm> haskell's power is that it doesn't lie to you
02:19:20 <Jafet> @protontorpedo
02:19:20 <lambdabot> paul graham said static typing and ML types fo lisp hurt exploratory progrmaming
02:20:06 <bxc> i love static types for exploratory programming!
02:22:47 <randomclown> is there a quick mathmaticall proof that a function of type (X -> Y) -> Z is convertable to X -> (Y -> Z)?
02:23:00 <shachaf> randomclown: It is not.
02:23:26 <randomclown> I though the brackets in haskell were movable
02:23:35 <shachaf> They are not.
02:23:37 <randomclown> thought*
02:23:47 <kennyd> not always
02:24:19 <kennyd> a -> b -> c  is  (a -> (b -> c))
02:24:21 <statusfailed> randomclown: X -> Y -> Z == X -> (Y -> Z) though
02:24:35 <statusfailed> aw :)
02:24:49 <shachaf> hi monqy
02:25:04 <monqy> hi shachaf
02:25:22 <shachaf> monqy: have you heard of profunctor lenses
02:25:34 <monqy> no
02:25:46 <shachaf> monqy: how about: bifunctor lenses
02:26:06 <monqy> no....
02:27:36 <startling> shachaf: isn't that just a bitraversal?
02:28:15 <shachaf> startling: I don't think so?
02:28:20 <johnw> haha
02:28:35 <shachaf> I haven't figured out how to make traversals work.
02:29:08 <startling> errrrr yeah, lenses aren't traversals, I'm dumb and sleepy.
02:29:21 <mikeplus64> shachaf: btw ghc-core still fails if PAGER="less -R" :(
02:30:24 <shachaf> mikeplus64: Oh, I "fixed" it but haven't released a new version yet.
02:30:45 <shachaf> mikeplus64: Can you tell me if the version in git works for you, possibly?
02:30:52 <mikeplus64> OK
02:31:13 <shachaf> I'm seeing some strange behavior with ^C that I should probably figure out.
02:33:06 <zuserm> I'm thinking of writing an option parsing lib. This thought horrifies me because there are already over half a dozen of them.
02:33:42 <mikeplus64> shachaf: yep it works
02:34:18 <edwardk> @hpaste
02:34:18 <lambdabot> Haskell pastebin: http://hpaste.org/
02:34:37 <hpaste> edwardk annotated “haskell roguelike” with “haskell roguelike (lensified)” at http://hpaste.org/79671#a79672
02:35:03 <edwardk> i should probably update that Show instance too
02:36:23 <zuserm> I couldn't possible actually want to write another one could I?
02:36:42 <hpaste> edwardk annotated “haskell roguelike” with “haskell roguelike (more lensified) (annotation)” at http://hpaste.org/79671#a79673
02:36:48 <mikeplus64> edwardk: what is makeClassy?
02:37:08 <mikeplus64> oh there it is
02:37:10 <mikeplus64> carry on
02:37:32 <shachaf> edwardk: Why don't we define ALens etc. if we define APrism?
02:37:33 <edwardk> mikeplus64: makeClassy ''Foo generates lenses for Foo along with a HasFoo class. so you can use its members more directly on containers
02:37:34 <shachaf> @ty cloneLens
02:37:36 <lambdabot> Functor f => LensLike (Context a b) s t a b -> (a -> f b) -> s -> f t
02:37:46 <edwardk> shachaf: makes sense
02:37:49 <shachaf> I guess ALens = Loupe
02:37:50 <edwardk> would make those sigs less scary
02:38:15 <edwardk> we can change the sigs for LensLike (Context a b) to use Loupe
02:38:22 <edwardk> that might make people happier about using loupes
02:38:29 <shachaf> Seems like calling it ALens would be more consistent.
02:38:34 <edwardk> i would
02:38:40 <edwardk> but it'd also basically piss off the snapframework guys
02:38:49 <shachaf> Did they push for the name Loupe?
02:38:53 <edwardk> no
02:38:56 <shachaf> Or is it just the compatibility thing?
02:38:59 <edwardk> but they like compatibility
02:39:06 <shachaf> Crazy people.
02:39:07 <edwardk> why not add ALens to C.L.Type
02:39:13 <edwardk> and then switch code over internally
02:39:18 <shachaf> Makes sense to me.
02:39:18 <m_fulder> I have a function with a type like [a] -> String -> [Integer] -> [Integer] which is called recursyvly...now for one of the cases (say when one of the list are empty) I would like to print something in the terminal ... is that even possible in haskell? :S
02:39:21 <edwardk> and then in 3.8 or 3.9 we can deprecate Loupe for ALens
02:39:22 <shachaf> ALens, ATraversal
02:39:34 <mikeplus64> edwardk: could there be a TH function to generate classes for each field of a record, something like if i had data Thing = Thing { _thingX, _thingY :: Int } it would generate class HasX a where x :: a -> Int; class HasY a where x :: a -> Int ?
02:39:36 <edwardk> that will clean up a lot of code
02:39:36 <johnw> some days i never know if I'm on #haskell-lens, or I forgot to switch my buffer
02:39:39 <catsbydlo> ALiens.
02:39:48 <edwardk> mikeplus64: not yet
02:39:54 <johnw> m_fulder: yes, using Debug.Trace.trace
02:39:57 <shachaf> data Coil t a = (t ~ Top) => Coil | forall h s. (t ~ (h :> s)) => Snoc (Coil h s) (LensLike' (Bazaar a a) s a) !Int [s] ([a] -> s) [s]
02:39:57 <mikeplus64> is it planned? or considered?
02:40:04 <johnw> trace is your friend
02:40:08 <shachaf> data Coil t a = (t ~ Top) => Coil | forall h s. (t ~ (h :> s)) => Snoc (Coil h s) (ATraversal' s a) !Int [s] ([a] -> s) [s]
02:40:12 <edwardk> mikeplus64: it has some problematic issues
02:40:12 <shachaf> Much nicer.
02:40:21 <edwardk> shachaf: yeah
02:40:23 <shachaf> edwardk: Why are we no longer using the GADT?
02:40:32 <mikeplus64> edwardk: what issues are there?
02:40:35 <edwardk> shachaf: because it causes the hlint parser to crap out ;)
02:40:42 <randomclown> what would be the (*) operator for Hom(N+, M), where N+ is the monoid of natural numbers under addition and M is any monoid
02:40:46 <m_fulder> johnw, oo cool will try that on
02:40:46 <koik> http://www.carolinaherrera.com/212/es/areyouonthelist?share=NVq56AQ2vxgECOtvW_3-cC_MeqWSEVkU2vlXs7SL5zHkz4rz3EUUdzs6j6FXsjB4447F-isvxjqkXd4Qey2GHw#teaser
02:40:51 <randomclown> what would (*) operator be
02:41:01 <shachaf> :-(
02:41:05 <edwardk> mikeplus64: actually now that i think about it it would probably work
02:41:30 <mikeplus64> the only thing i can think of is coming up with a suitable naming convention to say "i want this field to be overloaded"
02:41:50 <mikeplus64> i guess _<name of the constructor><name of the field> is fine though
02:42:10 <edwardk> mikeplus64: there is an open issue for overhauling the TH machinery. if you want this i'd recommend making a comment in there
02:42:18 <mikeplus64> alright
02:43:30 <shachaf> I suppose we should also have APrism' etc.
02:45:43 <shachaf> "Simple ALens" sounds bad. :-(
02:46:14 <edwardk> shachaf: ALens'
02:46:39 <shachaf> Sure, but the documentation.
02:46:42 <shachaf> -- | @type 'ALens'' = 'Simple' 'ALens'@
02:46:44 <shachaf> Oh well.
02:47:59 <shachaf> alongside :: LensLike (Context a b) s t a b -> LensLike (Context a' b')  s' t' a' b' -> Lens (s,s') (t,t') (a,a') (b,b')
02:48:02 <shachaf> alongside :: ALens s t a b -> ALens s' t' a' b' -> Lens (s,s') (t,t') (a,a') (b,b')
02:48:29 <beaky> ah
02:48:56 <beaky> :t makeClassy
02:48:57 <lambdabot> Language.Haskell.TH.Syntax.Name -> Language.Haskell.TH.Syntax.Q [Language.Haskell.TH.Syntax.Dec]
02:49:11 <shachaf> edwardk: Any objection to cloneLens :: ALens s t a b -> Lens s t a b?
02:50:06 <beaky> how do I instal lenses?
02:50:16 <edwardk> shachaf: sold
02:50:31 <johnw> cabal install lens
02:50:33 <edwardk> beaky: cabal install lens
02:50:34 <beaky> wow
02:50:46 <beaky> looks complex :(
02:50:49 <johnw> haha
02:50:54 <johnw> you aren't kidding
02:50:56 <beaky> what's a semigroupoid
02:50:58 <edwardk> beaky; its big, its scary. there are multiple tutorials ;)
02:51:08 <edwardk> beaky: omething with an operation like (.)
02:51:12 <beaky> ah
02:51:32 <edwardk> class Semigroupoid k where (o) :: k b c -> k a b -> k a c
02:51:39 <edwardk> its about as boring as you can get
02:51:56 * shachaf contemplates ATraversalT
02:51:58 <lewisx> with hsc2hs is it possible to omit c' and C' prefix?
02:51:58 <shachaf> Probably not.
02:52:07 <johnw> beaky: it basically remove "id" from a Category
02:52:11 <catsbydlo> lewisx: what c' prefix?
02:52:12 <shachaf> lewisx: That sounds like just a convention.
02:52:20 <beaky> :t remove
02:52:20 <shachaf> Did you try? :-)
02:52:21 <lambdabot> Not in scope: `remove'
02:52:23 <m_fulder> johnw, great Debug.Trace.trace works just as I wanted ... now I would just need a similiar function that can prompt the user for a value aswell .. can I do that without IO aswell?
02:52:40 <catsbydlo> m_fulder: that doesn't sound like debugging
02:52:55 <edwardk> shachaf: cute
02:53:01 <m_fulder> catsbydlo, can't I use debug functions as IO as a walkaround?
02:53:13 <catsbydlo> ... "walkaround"?
02:53:14 <beaky> what lens tutorials should I read
02:53:18 <lewisx> catsbydlo: it adds c' prefix to every function it defines and C' for every type. ie c'printf
02:53:27 <statusfailed> beaky: I found this talk really helpful: http://twanvl.nl/blog/news/2011-05-19-lenses-talk
02:53:27 <beaky> I wanna lensify my roguelike :D
02:53:31 <catsbydlo> lewisx: hsc2hs defines no functions or types
02:53:34 <johnw> beaky: http://newartisans.com/2012/11/getting-started-with-lenses/
02:53:59 <mikeplus64> anyone know why this isn't working? magic x = [d|class $c $x where|] where c = mkName "Magic"
02:54:00 <m_fulder> catsbydlo, yeah I mean .. how can I otherwise print something to the terminal at one recursive call in a function like [a]->String->[Integer]->[Integer] ?
02:54:02 <statusfailed> beaky: also this: http://comonad.com/reader/2012/mirrored-lenses/
02:54:10 <catsbydlo> m_fulder: you can't, obviously
02:54:13 <mikeplus64> i thought i could just splice in the name like that ...
02:54:18 <beaky> btw, are lenses monads/
02:54:21 <catsbydlo> the type says the function returns a list, not an IO action
02:54:25 <m_fulder> catsbydlo..I can using Debug ?
02:54:26 <edwardk> beaky: no
02:54:30 <beaky> ah
02:54:38 <johnw> m_fulder: you can use unsafePerformIO to do what you're asking
02:54:45 <lewisx> catsbydlo: then maybe it is binding-dsl that does it?
02:54:49 <edwardk> beaky: i have a 2 hour video there i crash through how lens works
02:54:53 <m_fulder> johnw, yeah but isn't that like the most hated function :P
02:55:02 <shachaf> Well, it would be nice to clean up partsOf's signature...
02:55:04 <mreh> I think i'm going to need something akin to top level mutable state for my FFI binding, I'd like to make something akin to the singleton pattern
02:55:05 <catsbydlo> lewisx: possible, I've never used it
02:55:05 <johnw> m_fulder: if you're using it for debugging and intend to remove it, it's fine
02:55:06 <statusfailed> edwardk: is this the same talk where prisms were introduced?
02:55:17 <edwardk> beaky: https://www.youtube.com/watch?v=cefnmjtAolY&hd=1
02:55:17 <edwardk> statusfailed: i haven't covered prisms in a talk yet
02:55:24 <mreh> any ideas how to acheive this?
02:55:57 <statusfailed> edwardk: oh.. is it the NY haskell group talk? I htought someone said you did there
02:56:01 <fmap> @google top level mutable state
02:56:03 <lambdabot> http://www.haskell.org/haskellwiki/Top_level_mutable_state
02:56:03 <lambdabot> Title: Top level mutable state - HaskellWiki
02:56:06 <statusfailed> yep, just loaded :)
02:56:55 <m_fulder> johnw, Im not using it for debugging...I want to use it :P ...the thing is, I have created a simple parser with functions like if/while which takes in a list of commands to execute and returns a list..
02:56:56 <m_fulder> .now I have made a new function in my "language" that should print something to terminal (a writeln)
02:56:58 <shachaf> Every single instance of BazaarT makes me sad.
02:57:00 <shachaf> For the record.
02:57:21 <johnw> m_fulder: then you don't want to use unsafePerformIO, and you will have to move your recursive function into IO
02:57:24 <edwardk> statusfailed: yeah
02:57:40 <edwardk> shachaf: do you get a nicer form in pure profunctor lenses?
02:57:46 <edwardk> er profunctor SECs ;)
02:58:15 <m_fulder> johnw, hm how do you mean move it into IO ? so all the recursive calls are made in a do statement?
02:58:27 <shachaf> edwardk: I haven't even figured out what traversals are "really" like for profunctors.
02:58:27 <mm_freak_> i wonder if there is a useful XML DSL/EDSL that i can use to generate XML…  the use case is:  android's XML schema is extremely verbose, ugly and hard to read
02:58:34 <edwardk> Profunctor secs sounds like porn for John Baez.
02:58:38 <shachaf> I mean, the corepresentable solution works, but I think there ought to be something better.
02:58:39 <johnw> m_fulder: [a]->String->[Integer]-> IO [Integer]
02:58:44 <catsbydlo> m_fulder: no, just fixing your type to let you use IO actions
02:59:05 <mreh> myGlobalVar = unsafePerformIO (newIORef 17) -- wont GHC replace the LHS with the RHS? or is that what the no-inlining is for?
02:59:29 <mreh> it's not completely clear
02:59:32 <mikeplus64> oops, i mean [d|class $n a where|]
02:59:42 <edwardk> what was the difference between Lensy and CorepresentableProfunctor again?
02:59:59 <m_fulder> johnw, catsbydlo,  I see but won't that function always return an IO [Integer] now? .. I would like to still be able to use a normal "write" that writes stuff into a list and not screen in my language ..
03:00:04 <edwardk> maybe the similarity there gives a guide for how to think about it
03:00:14 <catsbydlo> m_fulder: ... and?
03:00:46 <shachaf> edwardk: Not any, really.
03:00:49 <shachaf> edwardk: Wait, which Lensy?
03:01:02 <m_fulder> catsybdlo .. so say I will do a program like ... write 10; write 100; writeln 200 .. then I want the program to both return a list of [10, 100] and print 200 into the terminal
03:01:04 <shachaf> I had a class called Lensy that *only* let you do lenses, not traversals or anything else.
03:01:10 <shachaf> That was Saizan's rmap_withcontext
03:01:20 <shachaf> Then I had Twanny which was basically the same as CorepresentableProfunctor
03:01:20 <catsbydlo> m_fulder: ... and?
03:01:26 <shachaf> I'm not happy with either one of those.
03:01:50 <m_fulder> catsybdlo...and if my function now always "returns" IO [Integer] it won't work for the "normal" write?
03:01:56 <catsbydlo> m_fulder: why not?
03:02:17 <shachaf> edwardk: (You know the name of your class is too long when I copy and paste it from IRC rather than type it in.)
03:02:44 * hackagebot cassava 0.2.1.2 - A CSV parsing and encoding library  http://hackage.haskell.org/package/cassava-0.2.1.2 (JohanTibell)
03:02:53 <m_fulder> catsybdlo..because I can't "unwrap" [Integer] from IO?
03:02:55 <edwardk> CorepresentableProfunctor is a perfectly cromulent pre-alpha-reduction phase edwardk name
03:03:26 <catsbydlo> m_fulder: why do you need to?
03:03:37 <beaky> :t (^.)
03:03:39 <lambdabot> s -> Getting a s t a b -> a
03:03:46 <beaky> O.o
03:03:58 <edwardk> > ("hello","world")^._2
03:04:00 <lambdabot>   "world"
03:04:29 <edwardk> beaky: its used to 'read' from a lens, fold, traversal, isomorphism, etc.
03:04:30 <shachaf> m_fulder: foo :: IO [Integer] doesn't *contain* an [Integer]
03:04:40 <beaky> ah
03:04:45 <shachaf> m_fulder: You can't "unwrap" it because it's not "wrapping" anything.
03:04:45 <beaky> so ^. is like a getter
03:04:46 <shachaf> @quote /bin/ls
03:04:47 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
03:04:57 <edwardk> (^.) is like 'read from'  and it takes a getter
03:05:06 <beaky> [1, 2] ^. _1
03:05:08 <beaky> > [1, 2] ^. _1
03:05:10 <lambdabot>   Could not deduce (Control.Lens.Tuple.Field1 [t1] t0 a b0)
03:05:10 <lambdabot>    arising from t...
03:05:14 <beaky> :(
03:05:19 <edwardk> _1 doesn't work on lists. we have _head and element 0, etc.
03:05:25 <beaky> ah
03:05:28 <edwardk> > ["hello","world"]^.element 0
03:05:31 <lambdabot>   "hello"
03:05:34 <edwardk> now i cheated there
03:05:40 <edwardk> because element gives you a traversal
03:05:43 <edwardk> > ["hello","world"]^.element  20
03:05:46 <lambdabot>   ""
03:05:50 <beaky> ooh
03:05:52 <edwardk> so it needs to be able to make up an element from nothing
03:06:01 <edwardk> therefore it needs a monoid on the result type
03:06:10 <mikeplus64> edwardk: [0,1,2,3] ^. element 6
03:06:10 <edwardk> and strings form a monoid with "" and (++)
03:06:13 <mikeplus64> herp
03:06:19 <mikeplus64> > [0,1,2,3] ^. element 6
03:06:20 <mikeplus64> sorry edwardk
03:06:21 <lambdabot>   Ambiguous type variable `a0' in the constraints:
03:06:21 <lambdabot>    (GHC.Num.Num a0)
03:06:21 <lambdabot>      a...
03:06:25 <beaky> are tuples monoids?
03:06:28 <mikeplus64> > map Sum [0,1,2,3] ^. element 6
03:06:30 <edwardk> > [0,1,2,3,4] ^.. element 6
03:06:31 <lambdabot>   Sum {getSum = 0}
03:06:32 <lambdabot>   []
03:06:33 <edwardk> > [0,1,2,3,4] ^? element 6
03:06:35 <lambdabot>   Nothing
03:06:49 <catsbydlo> > [("a", "b"), ("c", "d")] ^. element 1
03:06:51 <lambdabot>   ("c","d")
03:06:55 <edwardk> beaky: tuples form a monoid if each of its args are a monoid
03:06:55 <statusfailed> @ty (^?)
03:06:57 <lambdabot> s -> Getting (First a) s t a b -> Maybe a
03:06:59 <edwardk> its the monoid product
03:07:07 <beaky> ah
03:07:11 <mikeplus64> > ("a", "b") <> ("c", "d")
03:07:12 <lambdabot>   ("ac","bd")
03:07:18 <beaky> :t (<>)
03:07:20 <lambdabot> Monoid m => m -> m -> m
03:07:27 <edwardk> > "hello" <> "world"
03:07:29 <lambdabot>   "helloworld"
03:07:35 <mikeplus64> beaky: easy to think of it as a generalised ++
03:08:01 <catsbydlo> :t comparing length <> compare
03:08:02 <lambdabot> Ord a => [a] -> [a] -> Ordering
03:08:08 <lewisx> yes it is binding dsl that auto adds prefixes. if I use hsc directly will it autonatically generate functions gor structure fields? and will it figure out correct struct alignment?
03:08:11 <fmap> > ("hello","world") ^. both
03:08:12 <mikeplus64> > 1 :: Sum Int
03:08:13 <lambdabot>   "helloworld"
03:08:14 <lambdabot>   No instance for (GHC.Num.Num (Data.Monoid.Sum GHC.Types.Int))
03:08:14 <lambdabot>    arising fr...
03:08:18 <catsbydlo> lewisx: no
03:08:23 <beaky> @src (<>)
03:08:24 <beaky> :(
03:08:24 <lambdabot> Source not found. My mind is going. I can feel it.
03:08:42 <lewisx> catsbydlo: no for both?
03:08:55 <catsbydlo> lewisx: did you read the manual for hsc2hs?
03:09:14 <mikeplus64> beaky: (<>) = mappend
03:09:16 <mikeplus64> @src mappend
03:09:17 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
03:09:19 <mikeplus64> :(
03:09:28 <mikeplus64> mappend is a class function from Monoid
03:09:34 <m_fulder> shachaf, catsbydlo .. hm I see, but then I don't quite understand how this function could return both [10,100] and print 200 in the terminal (in the case of write 10; write 100; writeln 200)..
03:09:35 <m_fulder> here's my code with some recurcive calls and patter matching using debug to print: http://pastebin.com/1uPCn3pG   how would I now rewrite it to return IO [Integer] instead with same result?
03:09:38 <shachaf> @src Monoid
03:09:39 <lambdabot> class Monoid a where
03:09:39 <lambdabot>     mempty  :: a
03:09:40 <lambdabot>     mappend :: a -> a -> a
03:09:42 <lambdabot>     mconcat :: [a] -> a
03:09:59 <catsbydlo> m_fulder: putStrLn "200" >> return [10, 100]
03:10:12 <statusfailed> huh, I didn't know mconcat was in Monoid
03:10:16 <lewisx> briefly. I used binding dsl right away and am considering switching. but if the answer is no to both questions i will just stick with binding dsl
03:10:26 <mikeplus64> statusfailed: in case you're not happy with foldr mappend mempty
03:10:37 <statusfailed> makes sense!
03:10:39 <beaky> mappend is like adding stuff?
03:10:45 <m_fulder> catsbydlo, oh I see! will try that on
03:10:49 <mikeplus64> like appending stuff, yeah
03:10:49 <statusfailed> beaky: like generalised adding
03:11:06 <beaky> lots of things can be added
03:11:12 <mikeplus64> yep
03:11:17 <mikeplus64> so Monoid is very useful a lot
03:11:27 <beaky> and monads are just monoids
03:11:28 <catsbydlo> m_fulder: fmap ([value expr dict] ++) (exec stmts dict input)
03:11:44 <beaky> in the category of endofunctors :D
03:11:49 <edwardk> beaky: a monoid is just something with a "unit": mempty and an operation mappend, such that 1.) mappend mempty a = a     2.) mappend a mempty = a;     3.) mappend (mappend a b) c = mappend a (mappend b c)
03:11:52 <catsbydlo> m_fulder: do { xs <- exec stmts dict input; return (value expr dict : xs) }
03:12:10 <catsbydlo> m_fulder: exec stmts dict input >>= (\xs -> return (value expr dict : xs))
03:12:13 <hagb4rd> hi, i'd like to compare two ascii strings bitwise (&&)  and print out the result as string again? i'm pretty sure you guys could do this in a cute short term.. could'nt you`? thanks
03:12:14 <edwardk> beaky: lots and lots of things satisfy those laws
03:12:41 <beaky> seems that Integers, Lists (and Strings), IO, etc. are monoids
03:12:53 <catsbydlo> hagb4rd: what result? a Bool?
03:13:01 <edwardk> integers could be, but should mappend = (+); mempty = 0   or should mappend = (*) and mempty = 1?
03:13:15 <hagb4rd> the result of a bool operation (AND) bitwise -> string
03:13:15 <edwardk> with booleans should it be (&&) or (||) with False or True?
03:13:26 <beaky> > mappend 1 2
03:13:28 <lambdabot>   Ambiguous type variable `a0' in the constraints:
03:13:28 <lambdabot>    (GHC.Num.Num a0)
03:13:28 <lambdabot>      a...
03:13:28 <edwardk> since it isn't clear which operation to choose for those cases, we simply don't
03:13:32 <edwardk> > mappend (Sum 1) (Sum 2)
03:13:34 <lambdabot>   Sum {getSum = 3}
03:13:35 <beaky> ah :(
03:13:38 <catsbydlo> hagb4rd: "bitwise" makes no sense there
03:13:43 <edwardk> beaky: we make newtypes to pick for you
03:13:49 <hagb4rd> edwardk: true, i guess
03:13:50 <edwardk> > ala Sum foldMap [1,2,3,4]
03:13:52 <lambdabot>   10
03:14:15 <simon> where does Sum come from?
03:14:19 <edwardk> Data.Monoid
03:14:20 <m_fulder> catsbydlo, hm hold on why do you have fmap ([value expr dict] ++)...  and not just ([value expr dict)] ++
03:14:21 <catsbydlo> @index Sum
03:14:21 <lambdabot> bzzt
03:14:26 <edwardk> newtype Sum a = Sum { getSum :: a }
03:14:38 <beaky> ah
03:14:44 <edwardk> instance Num a => Monoid (Sum a) where mempty = Sum 0; mappend (Sum a) (Sum b) = Sum (a + b)
03:14:45 <shachaf> edwardk: Tests are still broken, by the way.
03:14:45 <catsbydlo> m_fulder: because (++) takes two lists but exec stmts dict input is an IO something, not a list
03:14:51 <shachaf> Some of them use (^$)
03:14:54 <edwardk> shachaf: ahh
03:15:03 <m_fulder> catsbydlo ooh right
03:15:22 <beaky> watching that lenses lecture, it seems that lenses are like an improvement over data structures that use record syntax or that are frequently updated through pattern matching
03:15:24 <mikeplus64> beaky: there is no Monoid instance for IO a, but i guess you can make one with instance Monoid a => Monoid (IO a) where mempty = return mempty; mappend = liftM2 mappend
03:15:47 <beaky> or are they something else?
03:15:48 <edwardk> beaky: thats the starting point of them
03:15:54 <catsbydlo> mempty = mzero; mappend = mplus
03:16:18 <catsbydlo> @unmtl WriterT [t] IO a
03:16:19 <lambdabot> IO (a, [t])
03:16:34 <Maxdamantus> Is that really monoidic?
03:17:09 <m_fulder> catsbydlo and the other calls are equivalent I guess?
03:17:20 <catsbydlo> m_fulder: yes
03:17:49 <catsbydlo> first to demonstrate how to do it without fmap using do notation, then to show what the do notation actually boils down to
03:18:00 <catsbydlo> it's all in the >>=
03:18:37 <Maxdamantus> Ah. Monoids aren't necessarily commutative.
03:18:53 <edwardk> beaky: lenses, folds, traversals, getters, setters give you a generalized notion of an 'accessor' for getting at parts of a structure
03:19:21 <edwardk> beaky: using this you might make a traversal that visits all of the monsters you have on your grid, so you can tell them all to wake up
03:19:41 <edwardk> g & monsters.sleeping .~ False
03:20:02 <edwardk> thats a big generalization from just being able to access one monster at a time
03:20:45 <catsbydlo> the leroy jenkins combinator
03:20:52 <edwardk> catsbydlo: hah
03:21:47 <edwardk> g & monsters.filtered (near leroy).sleeping .~ False
03:22:08 <shachaf> edwardk: I like the part where you used filtered. :-(
03:22:22 <edwardk> shachaf: heh here it was safe since ideally sleeping isn't part of their location =P
03:22:31 <shachaf> edwardk: I think we ought to be able to make a legal version of filtered.
03:22:39 <shachaf> If it takes a predicate + a traversal as an argument.
03:22:44 * hackagebot ddc-base 0.3.1.1 - Disciplined Disciple Compiler common utilities.  http://hackage.haskell.org/package/ddc-base-0.3.1.1 (BenLippmeier)
03:22:46 <shachaf> And only uses the traversal if the predicate is true.
03:22:46 * hackagebot ddc-core 0.3.1.1 - Disciplined Disciple Compiler core language and type checker.  http://hackage.haskell.org/package/ddc-core-0.3.1.1 (BenLippmeier)
03:22:48 <shachaf> Oh, that's not enough.
03:22:48 * hackagebot ddc-build 0.3.1.1 - Disciplined Disciple Compiler build framework.  http://hackage.haskell.org/package/ddc-build-0.3.1.1 (BenLippmeier)
03:22:50 * hackagebot ddc-code 0.3.1.1 - Disciplined Disciple Compiler base libraries.  http://hackage.haskell.org/package/ddc-code-0.3.1.1 (BenLippmeier)
03:22:56 <edwardk> shachaf: yeah its more insidious than that
03:22:57 <shachaf> Bah.
03:23:05 <shachaf> Right, you can still modify the object.
03:23:14 <shachaf> Since the predicate has access to the whole thing.
03:25:56 <shachaf> We should rename SimpleReflect to Reflect'
03:26:00 <m_fulder> catsbydlo: hm the first line you wrote works fine (the one using fmap).. but the second with the do statement returns a wrong type .. a Parser [Integer] (Parser is my type that this exec function uses (first argument)) instead of an IO [Integer]
03:26:07 <edwardk> shachaf: heh
03:26:19 <edwardk> i noticed that too, it shows up when you go hunt for Simple's
03:26:46 <beaky> ah
03:27:00 <shachaf> edwardk: Should we s/Setting/ASetter/?
03:27:17 <edwardk> shachaf: i'm somewhat torn. we could do that for ASetter and AGetter too for consistency
03:27:29 <beaky> so lens lets me make my Grid have all these entities and only work with part of them at times?
03:27:34 <edwardk> then deprecate Setting and Getting in 3.9?
03:27:37 <edwardk> er
03:27:41 <edwardk> wait its not AGetter
03:27:46 <edwardk> we can't do that one easily
03:27:52 * hackagebot ddc-core-eval 0.3.1.1 - Disciplined Disciple Compiler semantic evaluator for the core language.  http://hackage.haskell.org/package/ddc-core-eval-0.3.1.1 (BenLippmeier)
03:27:54 <shachaf> Oh, because the arguments are different.
03:27:54 * hackagebot ddc-core-llvm 0.3.1.1 - Disciplined Disciple Compiler LLVM code generator.  http://hackage.haskell.org/package/ddc-core-llvm-0.3.1.1 (BenLippmeier)
03:27:55 <edwardk> Setting -> ASetter works
03:27:56 * hackagebot ddc-core-salt 0.3.1.1 - Disciplined Disciple Compiler C code generator.  http://hackage.haskell.org/package/ddc-core-salt-0.3.1.1 (BenLippmeier)
03:27:58 * hackagebot ddc-core-simpl 0.3.1.1 - Disciplined Disciple Compiler code transformations.  http://hackage.haskell.org/package/ddc-core-simpl-0.3.1.1 (BenLippmeier)
03:28:00 * hackagebot ddc-driver 0.3.1.1 - Disciplined Disciple Compiler top-level driver.  http://hackage.haskell.org/package/ddc-driver-0.3.1.1 (BenLippmeier)
03:28:06 <edwardk> beaky: yes
03:28:32 <shachaf> What was the reason one of them is simple and the other one isn't, again?
03:28:37 <edwardk> beaky: basically the nice part is that lenses themselves are easy to use, but the rabbit hole goes much deeper giving you more and more toys
03:28:48 <beaky> like I can have the player show all monsters on the map after he casts a spell or drinks a potion (rather than just those in his line of sight)? :D
03:29:09 <edwardk> a "Getter" would just have two naked unused type parameters dangling there if it wasn't simple
03:29:11 <edwardk> same with Fold
03:29:26 <edwardk> Getting isn't simple because you can pass it a lens that is changing type
03:29:27 <shachaf> Well, everything else does... :-)
03:29:34 <shachaf> I suppose that's more relevant when consuming, though.
03:29:38 <beaky> ah
03:29:38 <edwardk> i had it with just 2 parameters
03:29:58 <edwardk> but then it caused problems where users would pass in "ALens" and read and go to write back and fail
03:30:08 <edwardk> so they'd pass in two lenses, etc.
03:30:11 <edwardk> its just a mess
03:30:14 <beaky> besides lenses, what are some useful abstractions for building roguelikes?
03:30:27 <edwardk> so the generalized Getting signature is better in practice for users passing around lenses.
03:30:47 <shachaf> We could call Getter Getter'
03:30:50 <shachaf> That's kind of ugly, though.
03:30:53 <edwardk> blech
03:31:03 <edwardk> i'm okay with Getter, Fold, Action having two params
03:32:00 <shachaf> Getting is actually extra-different because of the r
03:32:07 <edwardk> beaky: prisms would be useful later on, i put some prism code in there, but didn't find a practical use for it
03:32:12 <shachaf> So maybe it's OK to have ASetter.
03:32:16 <edwardk> beaky: but thats a lens-related concept
03:32:37 <edwardk> I'd be okay with swapping Setting over to ASetter over the course of a couple of releases
03:32:51 <edwardk> especially now than we have ALens, ATraversal, etc.
03:33:02 * hackagebot ddc-tools 0.3.1.1 - Disciplined Disciple Compiler command line tools.  http://hackage.haskell.org/package/ddc-tools-0.3.1.1 (BenLippmeier)
03:33:03 <beaky> ah
03:37:59 <edwardk> beaky: learn everything you can about Applicative and Traversable and Foldable
03:38:05 <edwardk> beaky: those concepts pop up _everywhere_
03:39:11 <edwardk> beaky: monads are a bit of a blunt instrument, it is good to understand simpler tools for many tasks, because they have simpler structures they are easier to understand and more importantly there are more instances of them ;)
03:40:56 <beaky> ah
03:41:17 <beaky> right I always see people typing foldr and <$> here :D
03:43:29 <beaky> 'How do I do X in haskell?' '> foldr (f . g . h) >>= <$> a <*> ([x..xs] *** [y..ys])'
03:44:01 <beaky> and it magically works :D
03:47:10 <Maxdamantus> > let [f, g, h, a, x, xs, y, ys] = repeat undefined in foldr (f . g . h) >>= <$> a <*> ([x..xs] *** [y..ys])
03:47:12 <lambdabot>   <hint>:1:76: parse error on input `<$>'
03:47:43 <Maxdamantus> Would've needed (f:g:..:_) anyway.
03:48:23 <beaky> hehe
03:48:59 <Peaker> beaky, that would really be magical :)
03:49:07 <Peaker> beaky, foldr is not hard :)
03:49:37 <Peaker> beaky, whenever you do something like:  myFunc [] = foo ; myFunc (x:xs) = bar x (myFunc xs)       <-- a very common pattern!
03:49:50 <Peaker> beaky, you can do: myFunc = foldr foo bar    instead
03:50:02 <beaky> you can fold other recursive data structures as well :D
03:50:12 <Peaker> beaky, and non-recursive ones too!
03:50:25 <Rembane> Like papers
03:50:26 <Peaker> @type maybe
03:50:28 <lambdabot> b -> (a -> b) -> Maybe a -> b
03:50:34 <Peaker> maybe folds a "Maybe"
03:50:44 <Peaker> maybe : Maybe,  foldr : [a]
03:50:52 <Peaker> rather: maybe : Maybe,  foldr : []
03:51:24 <beaky> so TemplateHaskell is just like Lisp Macros (at least it serves the same ultimate purpose: extending language syntax)?
03:52:36 <Peaker> beaky, similar, but not quite like it.. Lisp macros take arbitrary lists as input, which look like ordinary code lists
03:52:54 <Peaker> beaky, TH takes arbitrary Haskell data params that don't quite look like Haskell code syntax
03:53:25 <beaky> oh
03:53:26 <Peaker> beaky, there's "quasiquoting" which is perhaps more similar, it takes ordinary strings so you can make it look like code or what not
03:53:34 <Peaker> beaky, usually TH is used like this:
03:53:43 <Peaker> $(makeLenses ''MyType)
03:53:48 <Peaker> or with modern GHC, just:
03:53:56 <Peaker> makeLenses ''MyType   <-- at the to-level of the file
03:54:00 <Peaker> top-level*
03:54:36 <edwardk> template haskell is an .. acquired taste ;)
03:54:56 <edwardk> but yes we use it where a schemer/lisper would write a macro for code generation
03:54:59 <Peaker> hardly anybody likes that taste though :) Perhaps snoyman
03:55:04 <edwardk> since our language isn't homoiconic its harder to use
03:55:15 <beaky> ah
03:55:17 <edwardk> because we have more kinds of structure, etc.
03:55:27 <edwardk> lots of syntax gets in the way of pretty macros
03:55:39 <beaky> isn't haskell more expressive enough to not need as much macro hackery as lisp? :D
03:55:47 <edwardk> well, thats part of it.
03:56:02 <edwardk> with laziness you don't need macros for writing control structures
03:56:09 <edwardk> we can use lambdas for binders, etc.
03:56:34 <edwardk> you can write more DSLs in haskell without resorting to macros, and they look pretty good
03:56:57 <edwardk> so TH is really left with the worst code generating usecases for macros
03:57:06 <aristid> there are legitimate things that can't really be done without TH though
03:57:36 <edwardk> and it has to deal with our fairly complex syntax, so when you have to write TH you're usually dealing with a doubly painful situation already ;)
03:57:57 <Peaker> not only fairly complex, but changed with every new GHC release :)
03:58:08 <beaky> arhg
03:58:26 <beaky> argh*
03:58:48 <Peaker> aristid, a lot of them are being swallowed whole by the Data.Data/Generic derivations, some by ever-more generalized TH'd constructs (e.g: lens/prisms covering ground we used to use TH for)
03:59:46 <beaky> ah
03:59:55 <aristid> Peaker: well, i'm especially thinking about when you use lens as your record system replacement and want to generate lenses and prisms automatically without declaring each of them by hand :)
03:59:56 <beaky> lens and prisms seem to be implemented with TH :D
04:00:26 <edwardk> beaky: TH is used to generate lenses automatically, you can work without the TH
04:00:36 <edwardk> its just convenient not to have to write a lot of boilerplate
04:00:44 <beaky> ah
04:01:20 <edwardk> 'lens' provides hundreds of lenses and doesn't use TH internally ;)
04:01:22 <Peaker> aristid, ideally GHC would have record fields associated with lens rather than weak getters
04:01:45 <Peaker> aristid, and have no record update syntax at all
04:01:46 <edwardk> Peaker: it'll become an easier sell once makeExposed goes into lens
04:01:59 <Peaker> edwardk, what's makeExposed?
04:02:23 <edwardk> it lets you do field updates to multiple polymorphic fields without needing crazy machinery
04:02:34 <aristid> Peaker: ideally... i wouldn't count on that getting into GHC 7.10 ;)
04:03:11 <Peaker> edwardk, cool
04:03:22 <edwardk> over exposed ?? V2 "hello" "world" $ \v -> v & _x .~ 1 & _y .~ 2   ; despite data V2 a = V2 a a
04:04:00 <edwardk> Peaker: that should silence the last of the 'but lenses can't do _Everything_ i can do with normal fields critics
04:04:14 <edwardk> it gives you a slightly more polymorphic polymorphic update
04:07:23 <notdan> The cassava library I am using has anAPI based on Vector datatype. I was wondering if it's possible to sort such a vector. The functions from Data.Vector.Algorithms seems to operate on different tytpes
04:08:33 <beaky> what makes programming in Haskell seem so different from programming in an imperative language?
04:08:50 <notdan> beaky: well, haskell is not an imperative language?
04:09:19 <Peaker> beaky, Composing pure functions to build the functionality you want is a very different activity from a sequence of destructive updates typically found in imperative languages
04:12:46 * hackagebot ddc-driver 0.3.1.2 - Disciplined Disciple Compiler top-level driver.  http://hackage.haskell.org/package/ddc-driver-0.3.1.2 (BenLippmeier)
04:12:48 * hackagebot ddc-tools 0.3.1.2 - Disciplined Disciple Compiler command line tools.  http://hackage.haskell.org/package/ddc-tools-0.3.1.2 (BenLippmeier)
04:14:36 <beaky> in ordinary imperative languages, you can't get by without destructive updates
04:14:47 <beaky> while in haskell there are no updates
04:14:53 <beaky> only name binding and substitution
04:15:24 <Peaker> beaky, Haskell has destructive updates and such, they're just heavier than pure function compositions, whereas in imperative languages it is the opposite
04:15:33 <Peaker> "heavier" as in syntactically, and the types are uglier
04:16:44 <tgehr> How well does GHC optimize code that uses ST?
04:17:39 <applicative> notdan: yeah I dont know if anyone has written things like sort for boxed vectors in Data.Vector
04:17:45 <beaky> btw, is it normal for unoptimized code built by GHC to keep overflowing the stack until you turn on -O2 optimization?
04:18:55 <notdan> applicative: I ended up converting Vector to List and sorting it that way :/
04:19:01 <notdan> It's not that I have that much data anyway
04:20:00 <applicative> I don't think I've seen a  library before cassava make this kind of central use of boxed Vectors.
04:23:45 <statusfailed> beaky: I don't really know, but i'd be interested to see the code that's doing it :)
04:23:47 <applicative> notdan: I see that in his examples he uses fromList so maybe thats what he intends.
04:23:47 <mreh> why can't I make a generic function that wraps haskell functions in a FunPtr?
04:23:49 <statusfailed> is there a simple example?
04:24:51 <notdan> applicative: well he uses that for generating CSV
04:25:04 <mreh> foreign import ccall "wrapper" wrap :: Storable a => a -> IO (FunPtr a)
04:25:13 <mreh> oh, I see why
04:25:14 <applicative> notdan: yeah
04:25:19 <mreh> -> has not Storable instance
04:25:24 <mreh> no*
04:26:22 <beaky> http://ideone.com/cVsTpj
04:26:41 <beaky> translated from C to haskell :D
04:27:46 * hackagebot optparse-applicative 0.5.0 - Utilities and combinators for parsing command line options  http://hackage.haskell.org/package/optparse-applicative-0.5.0 (PaoloCapriotti)
04:27:48 * hackagebot ddc-build 0.3.1.3 - Disciplined Disciple Compiler build framework.  http://hackage.haskell.org/package/ddc-build-0.3.1.3 (BenLippmeier)
04:28:37 <statusfailed> beaky: i'm not sure if this is correct, but
04:28:54 <statusfailed> maybe the tail-recursion doesn't kick in because of that IO-gotcha
04:29:04 <statusfailed> the one where it has to evaluate the whole IO expression in one go
04:29:14 <statusfailed> (not sure if that's the right way of expressing it :\)
04:30:11 <beaky> ah
04:30:16 <beaky> so it keeps thunking
04:31:56 <Agas> hello
04:32:03 <Agas> new to Haskell
04:36:40 <statusfailed> beaky: not sure if that's right though :)
04:37:47 * hackagebot ddc-driver 0.3.1.3 - Disciplined Disciple Compiler top-level driver.  http://hackage.haskell.org/package/ddc-driver-0.3.1.3 (BenLippmeier)
04:37:49 * hackagebot ddc-tools 0.3.1.3 - Disciplined Disciple Compiler command line tools.  http://hackage.haskell.org/package/ddc-tools-0.3.1.3 (BenLippmeier)
04:38:44 <applicative> hm Agas vanished too quickly
04:39:21 <statusfailed> applicative: yep :(
04:40:26 <wuttf> Can anyone explain me this: https://gist.github.com/4358747
04:42:56 <Peaker> wuttf, requestInfo and pathInfo are qualified names too in the latter
04:43:11 <wuttf> Peaker: aaaaa :) Thank you. Makes sense.
04:43:12 <Peaker> wuttf, you need Wai.requestInfo, etc
04:43:21 <Peaker> there's some GHC extension to get more sensible namespacing inside records
04:43:27 <Peaker> I don't remember what it is :)
04:44:05 <wuttf> Peaker: :) No problem it is okay now.
04:45:25 <applicative> wuttf in that particular case you can just write  app (Wai.Request m p) = do ...
04:45:51 <Peaker> applicative, it's nice not to make unnecessary assumptions about data constructors though
04:46:11 <Peaker> though OTOH if anything is added to it, it may be a bug to ignore it
04:47:52 <wuttf> applicative: I will stick to the more readable one since I am quite a noob
05:11:53 <beaky> why are
05:12:21 <beaky> what makes monads such a powerful means of abstraction for difficult things like IO, State, Reader, etc.
05:12:48 <catsbydlo> join
05:13:02 <beaky> :t join
05:13:04 <lambdabot> Monad m => m (m a) -> m a
05:13:09 <beaky> oh
05:13:29 <beaky> > join (Just (Just 3))
05:13:30 <lambdabot>   Just 3
05:13:46 <beaky> > join (Nothing (Just 3))
05:13:48 <lambdabot>   The function `Data.Maybe.Nothing' is applied to one argument,
05:13:48 <lambdabot>  but its type...
05:13:51 <beaky> oops
05:14:05 <beaky> > join (Just (Nothing))
05:14:07 <lambdabot>   Nothing
05:15:00 <beaky> lambdabot: What is best in life?
05:15:23 <beaky> does lambdabot chat/
05:18:29 <zuserm> beaky: feeling a little lonely?
05:25:25 <beaky> after learning about monads, I start to see them outside of haskell and in other programming languages
05:25:37 <beaky> for example, pointers are monads
05:26:36 <latermuse> beaky: its kind of fun, isnt it?
05:26:52 <beaky> how do you join two pointers?
05:27:32 <catsbydlo> Ptr ~ Maybe
05:27:44 <shachaf> Not really.
05:28:10 <beaky> :t (~)
05:28:11 <lambdabot> parse error on input `)'
05:28:15 <beaky> :(
05:28:21 <beaky> guess pointers aren't monads
05:28:23 <edwardk> beaky: he was just saying is approximately
05:28:29 <edwardk> beaky: but its not really
05:28:50 <beaky> ah
05:29:21 <beaky> what are examples of Haskell concepts (like Monads) in other programming languages?
05:30:35 <edwardk> monads don't have many good examples in other languages. LINQ in c# is the closest you'll probably get to monads elsewhere, even then the type system forces you to write fully monomorphic code any one monad not code parametric in the choice of monad
05:30:52 <edwardk> er monomorphic code for any one
05:37:05 <zuserm> I want to combine two parsers such that the second one is run only if the first one succeeds without consuming input, put parsec doesn't seem to provide a way to do this :(
05:38:08 <beaky> if I wanna invent my own monads, all I have to do is define >>= and return?
05:38:34 <beaky> instance Monad BeakyM where...
05:38:37 <latermuse> zuserm: use a conditional statement of some sort?
05:44:36 * applicative wonders what someone could mean by calling Haskell the “the Taliban version of ML”
05:45:11 <statusfailed> applicative: context?
05:45:25 <statusfailed> Taliban is to Haskell as ML is to what I wonder
05:45:38 <statusfailed> er, swap Haskell & Taliban
05:45:59 <applicative> islam, I guess; with the presupposition that it's no good
05:46:05 <randomclown> we preserve purity by killing the infidels
05:46:55 <applicative> statusfailed: nonsense linked on reddit-haskell:  http://www.theregister.co.uk/2012/12/21/financial_software_disasters/page2.html
05:47:29 <applicative> Haskell, its kind of like this: fix$(<$>)<$>(:)<*>((<$>((:[{- thor's mother -}])<$>))(=<<)<$>(*)<$>(*2))$1
05:48:21 <applicative> > take 10 $ fix$(<$>)<$>(:)<*>((<$>((:[{- thor's mother -}])<$>))(=<<)<$>(*)<$>(*2))$1
05:48:23 <lambdabot>   [1,2,4,8,16,32,64,128,256,512]
05:49:34 <statusfailed> that's pretty cool :D
05:49:46 <catsbydlo> > iterate (* 2) 1
05:49:48 <lambdabot>   [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,...
05:49:50 <catsbydlo> much cooler
05:49:54 <niteria> that was a weird article
05:50:00 <applicative> the author professes a weakness for APL, but Haskell is supposed take it too far...
05:50:19 <zuserm> Why does the Reply type in Parsec have a ParseError field in the OK constructor?
05:50:19 <tgehr> lol
05:50:26 <tgehr> code like that can be written in most languages
05:50:38 <statusfailed> i'm thinking of starting a blog where I just post flamebait, it must make so much money
05:50:48 <catsbydlo> adequacy.org?
05:50:58 <Peaker> @unpl  fix$(<$>)<$>(:)<*>((<$>((:[{- thor's mother -}])<$>))(=<<)<$>(*)<$>(*2))$1
05:50:58 <lambdabot> (((fix ((<$>) <$> ((:)))) <*> ((((\ j k -> k >>= j) <$> \ b -> (\ a -> a : []) <$> b) <$> (*)) <$> \ d -> d * 2)) 1)
05:51:04 <Peaker> that's not unpl'd
05:51:38 <b_jonas> > (2^) . [0..9]
05:51:40 <lambdabot>   [1,2,4,8,16,32,64,128,256,512]
05:52:04 <b_jonas> that's basically the apl solution, except no need for an explicit (.) there
05:52:27 <catsbydlo> :t join (zipWith (+))
05:52:29 <lambdabot> Num c => [c] -> [c]
05:52:36 <catsbydlo> :t (1 :) . join (zipWith (+))
05:52:37 <lambdabot> Num a => [a] -> [a]
05:57:50 * hackagebot minesweeper 0.9.2 - Minesweeper game which is always solvable without guessing  http://hackage.haskell.org/package/minesweeper-0.9.2 (PeterDivianszky)
05:58:13 <Fuuzetsu> wow, sweet minesweeper
05:59:39 <`nand`> edwardk: can you make lens compatible with profunctors-3.1?
06:00:15 <edwardk> `nand`: yes
06:00:56 <shachaf> Is it not compatible?
06:01:13 <`nand`> shachaf: the .cabal requires ==3.0.*
06:01:14 <edwardk> i just didn't update the dep list
06:01:26 <shachaf> Oh.
06:01:27 <edwardk> i'll push it in about 30 seconds
06:02:30 <`nand`> great, thanks
06:10:38 <edwardk> you're all set
06:37:51 * hackagebot vault 0.2.0.4 - a persistent store for values of arbitrary types  http://hackage.haskell.org/package/vault-0.2.0.4 (HeinrichApfelmus)
06:37:52 <`nand`> edwardk: what's the difference between UpStar/DownStar and Kleisli/Cokleisli?
06:38:07 <edwardk> `nand`: purpose
06:38:23 <edwardk> kleisli indicates you want kleisli composition. UpStar is going to mostly be used for profunctor composition
06:38:48 <edwardk> Procompose (Upstar f) (Upstar g) ~ Upstar (Compose f g)
06:39:09 <edwardk> Procompose (DownStar f) (DownStar g) ~ DownStar (Compose g f)
06:54:33 <noteventime> If one were to try to use Haskell instead of R for statistics, what PRNG library would one use (i.e. does anyone have an opinion on the state of the different random number packages around)?
07:06:52 <edwardk> noteventime: chase down what criterion uses and use that
07:06:59 <edwardk> its a good rule of thumb
07:07:13 <edwardk> @hackage criterion
07:07:13 <lambdabot> http://hackage.haskell.org/package/criterion
07:07:26 <edwardk> http://hackage.haskell.org/package/mwc-random-0.12.0.1
07:10:34 <byorgey> the REAL rule of thumb is "ask bos"
07:10:44 <byorgey> but chasing down what criterion uses is easier.
07:14:48 <noteventime> edwardk: mwc-random is what statistics uses too, but the API looks somewhat specialised
07:16:32 <noteventime> Though I guess that might not really be a problem
07:17:52 * hackagebot machines 0.2.1.2 - Networked stream transducers  http://hackage.haskell.org/package/machines-0.2.1.2 (EdwardKmett)
07:24:04 <LMolr> what module do I need to import to call close on a Socket?
07:28:55 <pnielsen> LMolr: Network.Socket (sClose)
07:29:34 <hiptobecubic> mwc is good
07:29:51 * hiptobecubic realizes that he is adding nothing to the conversation...
07:30:25 <pnielsen> hey, at least the world didn't end
07:30:41 <hiptobecubic> maybe it's gradual
07:31:04 <LMolr> pnielsen, thank you.
07:37:37 <Skel> My bad if this is obvious/simple but, I'm learning Haskell and trying to understand the type system, I'm confused what happens if I apply map to something that's not a function. ghci seems to give me a type back and I don't see how it works/makes sense: :t (map 1) gives me (map 1) :: Num (a -> b) => [a] -> [b]
07:38:43 <rwbarton> 1 isn't necessarily not a function.
07:38:56 <rwbarton> Do you know how numeric literals are overloaded?
07:39:00 <rwbarton> Try map (1 :: Integer)
07:39:56 <Skel> rwbarton: I was aware there was some magic to numbers but I didn't know how, just got an error doing what you said, I'm still a bit confused though
07:40:39 <rwbarton> well, that new error is what you expected to get originally, right
07:40:43 <Skel> Yeah
07:42:01 <rwbarton> :t 1
07:42:02 <lambdabot> Num a => a
07:42:11 <rwbarton> 1 can have any type that's an instance of the Num type class
07:42:28 <rwbarton> In principle you could decide to make functions an instance of Num
07:42:40 <rwbarton> Then map 1 would make sense, and it would have the type ghci told you
07:43:23 <rwbarton> In practice, if you see a type involving a constraint like "Num (a -> b)", 99% of the time it means you messed up and tried to use a function as a number or vice versa
07:44:15 <Skel> Hmm, bare with me, I'm struggling to grasp this. I understand what you're saying I think, but I'm struggling to see how it actually works, I thought Num a => a is still just a but with a constraint, I'm confused how that is accepted as matching a function
07:44:33 <rwbarton> well, 'a' matches any type at all
07:44:44 <Skel> Yeah, but a -> b shouldn't match 'a' surely?
07:44:47 <rwbarton> so tha tincludes functions
07:44:56 <shachaf> Skel: Those aren't the same 'a'
07:45:14 <shachaf> "b -> c" can match "a"
07:45:49 <Skel> shachaf: right, that's what I'm trying to understand, why can it match that? I'm kind of confused by it, I didn't mean to imply the a's are the same sorry
07:46:04 <shachaf> Skel: Let's drop type classes for a bit because they just make things confusing.
07:46:11 <shachaf> id :: a -> a
07:46:11 <Skel> Ok
07:46:16 <shachaf> not :: Bool -> Bool
07:46:28 <shachaf> What do you expect (id not) to be?
07:46:51 <Skel> (Bool -> Bool) -> (Bool -> Bool)
07:46:57 <shachaf> Right.
07:47:01 <shachaf> Well, no.
07:47:06 <shachaf> (id nat) :: Bool -> Bool
07:47:09 <Skel> Well, the result would be (Bool -> Bool)
07:47:16 <shachaf> But the type of id in that expression becomes what you said.
07:47:20 <shachaf> So a = Bool -> Bool
07:47:31 <shachaf> How about (id id)?
07:47:42 <shachaf> What's the type of both of those ids?
07:47:46 <Skel> a -> a
07:47:55 <shachaf> Let's give them each a name.
07:48:01 <shachaf> id_1 :: a -> a; id_2 :: a -> a
07:48:05 <shachaf> (id_1 id_2)
07:48:11 <shachaf> What's the type of id_1 *in that expression*?
07:48:29 <Skel> (a -> a) -> (a -> a) I think
07:48:39 <Skel> Wait
07:49:04 <shachaf> It helps to rename the types so there's no conflict. :-)
07:49:09 <shachaf> id_1 :: a -> a; id_2 :: b -> b
07:49:17 <shachaf> id_1 :: (b -> b) -> (b -> b)
07:49:20 <shachaf> So a = b -> b
07:49:38 <Skel> Ok yeah, makes sense
07:49:53 <Skel> I was typing up something similar but with a1 a2 ;p
07:49:55 <shachaf> So the same thing, more or less, happens with Num
07:50:49 <shachaf> Except you only have one "a", which can become *any* type (as long as that type is an instance of Num)
07:51:03 <shachaf> So if you write instance Num (b -> c), then a = b -> c works just fine.
07:52:37 <Skel> Ok, I still follow, but I don't see how you get to (b -> c) from a type that is just a, I can't imagine what you're describing with Num and map for example
07:52:47 <Skel> Sorry if I'm being really slow here
07:53:47 <shachaf> Forget the Num for a moment.
07:53:52 <shachaf> That's what GHC does, after all.
07:54:01 <shachaf> First it just looks at it as a plain "a"
07:54:11 <shachaf> That means "this can become any type you like"
07:54:31 <shachaf> If foo :: a, then you can use foo as an Int or a Char or whatever.
07:54:34 <zomg> Skel: (a -> b) is a single type. It's not a list of types :)
07:54:43 <zomg> That's why `a` can become (a -> b)
07:55:10 <shachaf> zomg: Saying "a" can become "a -> b" is confusing because those two won't unify, if that's the same "a"
07:55:13 <shachaf> (It's not.)
07:55:17 <zomg> Yeah
07:55:26 <Skel> zomg: shachaf, I think I may be confusing here what I mean, I understand that (a -> b) can replace 'a', I.E, if I pass (b -> c) to a function that takes an a, that a will become (b -> c)
07:55:47 <shachaf> Skel: Well, it's more than passing it.
07:55:56 <Skel> But if I do :t (map 1), I am passing a type 'a', to something that expects (b -> c), not the reverse, for any type but a number seems to reject it like I would expect so
07:56:30 <shachaf> > 1 :: Int
07:56:32 <lambdabot>   1
07:56:34 <shachaf> > 1 :: Double
07:56:35 <lambdabot>   1.0
07:56:41 <Skel> FOr some reason numbers are considered functions, which is what I think I dson't understand
07:56:50 <shachaf> Numbers are considered "lots of things"
07:56:57 <shachaf> See how 1 became both an Int and a Double there/
07:56:59 <shachaf> ?
07:57:19 <Skel> Yeah
07:57:27 <rwbarton> > 1 :: Char
07:57:28 <lambdabot>   No instance for (GHC.Num.Num GHC.Types.Char)
07:57:29 <lambdabot>    arising from the literal `1...
07:57:44 <rwbarton> if you wrote an instance Num Char, it could be a Char too
07:57:58 <shachaf> Right.
07:58:01 <Skel> Sure, but how does that make it a function?
07:58:03 <rwbarton> :t 1 :: Char
07:58:04 <lambdabot>     No instance for (Num Char)
07:58:04 <lambdabot>       arising from the literal `1'
07:58:05 <lambdabot>     Possible fix: add an instance declaration for (Num Char)
07:58:06 <shachaf> > 1 :: a -> b
07:58:08 <lambdabot>   No instance for (GHC.Num.Num (a1 -> b1))
07:58:08 <lambdabot>    arising from the literal `1'
07:58:08 <lambdabot>  P...
07:58:12 <shachaf> It's the same thing.
07:58:22 <shachaf> Functions are just another type.
07:58:41 <Skel> But It's type isn't a function, maybe I just haven't gotten far enough in this book yet
07:58:43 <Skel> its*
07:58:45 <shachaf> If you made Char an instance of Num, then (1 :: Char) would be valid.
07:58:52 <shachaf> If you made (a -> b) an instance of Num, then (1 :: a -> b) would be valid.
07:59:15 <Skel> Oh, ok it just hit me, I understand
07:59:36 <Skel> Hang on, let me just write something in ghci to make sure I really do understand ;p
07:59:41 <FireFly> It took me a while to get that..
08:00:04 <jmcarthur> this has occurred to me many times, but i've never said it out loud. since our strings are linked lists, it of course takes linear time to compute the length of a string. this is unfortunate, but at least makes some sense. what makes no sense is that C strings are structured in such a way that you don't have the benefits of linked lists, yet it's still a linear time computation to get the string's length :(
08:00:09 <merijn> On the upside, if you got it, you're well underway to true enlightenment :p
08:00:30 <FireFly> It's not so much that numbers are function, as it is that functions are numbers (or that's my understanding of it at least)
08:00:49 <FireFly> (if you make  Num b => a -> b  an instance of Num, that is)
08:01:21 <jmcarthur> it's just that "number" is an overloaded word
08:01:35 <shachaf> jmcarthur: C strings still have the benefit that a pointer into a string is a valid string.
08:01:40 <Skel> If I understand it, It's that it expects an instance of Num, the a in Num can be a -> b (or c -> d to clear up confusion), so when I pass 1 to map, seeing as 1 doesn't have a concrete type yet, a -> b could be valid
08:01:59 <jmcarthur> shachaf:  pascal strings only require one extra number to be attached to the pointer
08:02:07 <shachaf> Right.
08:02:25 <jmcarthur> but i see your point
08:02:49 <shachaf> Skel: Yep.
08:02:56 <shachaf> @ty undefined
08:02:57 <lambdabot> a
08:03:09 <shachaf> undefined is a magic value that can pretend to have *any* type
08:03:18 <shachaf> (But when we actually use it for anything, it crashes our program.)
08:03:25 <shachaf> @ty undefined :: Char
08:03:27 <lambdabot> Char
08:03:28 <jmcarthur> shachaf: also, haskell strings have that benefit, too, if you translate "pointer" into "reference"
08:03:29 <shachaf> @ty undefined :: a -> b
08:03:31 <lambdabot> a -> b
08:03:34 <shachaf> jmcarthur: Right.
08:03:41 <shachaf> jmcarthur: This is one of the benefits of a linked list.
08:03:47 <shachaf> C strings "sort of" have it.
08:03:47 <jmcarthur> i guess all you meant is that not all the benefits are lost
08:03:50 <jmcarthur> yeah
08:03:51 <shachaf> (You can't cons, though.)
08:04:43 <shachaf> jmcarthur: I don't think C strings really make that much sense nowadays.
08:05:35 <shachaf> Perhaps they made sense in 1970
08:06:18 <Skel> Just to be sure, numbers are magical in Haskell though right? I couldn't define my own values the same way could I?
08:06:49 <merijn> Skel: Sure you can
08:06:51 <rwbarton> a numeric literal is really an application of fromInteger
08:06:54 <rwbarton> :t fromInteger
08:06:55 <lambdabot> Num a => Integer -> a
08:07:27 <merijn> Skel: For example, the Default and Bounded typeclasses do similar things
08:07:31 <Skel> Oh, interesting, so fromInteger is slightly magic ;p
08:07:32 <merijn> :t minBound
08:07:33 <lambdabot> Bounded a => a
08:07:43 <Skel> I mean
08:07:44 <merijn> > minBound :: Char
08:07:45 <rwbarton> fromInteger itself isn't magic, numeric literals are magic
08:07:46 <lambdabot>   '\NUL'
08:07:48 <merijn> > minBound :: Int
08:07:51 <lambdabot>   -9223372036854775808
08:07:54 <Skel> Number literals are to be 'rewritten' as fromInteger
08:07:56 <Skel> yeah
08:08:32 <rwbarton> (and obviously I mean integer numeric literals; there's a similar story for fractional ones)
08:08:37 <merijn> Skel: Yeah, the only magic is that numeric literals are polymorphic (and so are strings if you enable OverloadedStrings)
08:08:57 <merijn> Skel: But you can (and people do) define similar overloaded constants without any dark magic
08:09:30 <Skel> merijn: would it be too much to ask to see a small example?
08:10:52 <merijn> Skel: The Bounded and Default typeclasses I just mentioned are common examples, if you search hoogle for Bounded you'll see a bunch of implementations of that typeclass
08:11:14 <shachaf> Skel: By the way, this isn't a thing you should do a lot.
08:11:17 <jmcarthur> Skel: it's merely syntax sugar for something you could write by hand. nothing really magical
08:11:44 <merijn> > minBound :: (Int, Bool)
08:11:45 <lambdabot>   (-9223372036854775808,False)
08:11:50 <Skel> shachaf: aye
08:12:21 <Skel> jmcarthur: yeah, I just like to understand things, and it did seem magical at first ;p
08:12:36 <Skel> Thanks for all the help, really appreciate you guys baring with me on that
08:12:56 <merijn> Skel: I think it's one of the trickier details to wrap your head around at first
08:13:15 <shachaf> I think unification is much more important to understand early on than type classes.
08:13:28 <merijn> shachaf: True
08:13:45 <shachaf> That (what happens when you combine weird types without any class constraints) should probably be your main focus until you're comfortable with it.
08:13:50 <shachaf> Type classes make things annoying.
08:15:20 <shachaf> Anyway, /me is off
08:19:50 <monochrom> soon, list literals will be polymorphic too by OverloadedList
08:20:00 <monochrom> no literal is safe!
08:20:52 <elliott> class Overloaded a b where overload :: a -> b
08:21:09 <elliott> map (+1) [1,2,3] --> overload map (overload (+) (overload (1::Integer))) (overload (:) ...
08:22:10 <Taneb> OverloadedChar
08:22:25 <Taneb> OverloadedParentheses
08:28:48 <saati> i have read that if i want nonblocking socket i/o i should do it in a separate thread
08:29:17 <saati> what is a good solution for passing the data to the main thread?
08:30:27 <elliott> Possibly a Chan.
08:30:32 <elliott> Note that GHC uses non-blocking IO internally.
08:30:44 <elliott> (So you don't need to do anything special to get the advantages of it.)
08:38:02 <saati> hmm i have to figure this out more thoroughly
08:38:27 <saati> i want to create a data type(or something like that) that's synchronized between processes
08:40:05 <saati> like a queue where the inserted data only appears for reading after all the others acked it
08:48:35 <LMolr> is there a main library to deal with ICMP messages?
09:06:12 <lolcathost> Is there any syntax sugar for "f >>= \x -> case x of..." ?
09:06:58 <sp3ctum> lolcathost, you need guards
09:07:06 <sp3ctum> ?
09:07:21 <osfameron> or define x -> ...  as a function
09:07:21 <lolcathost> sp3ctum: No.
09:07:49 <osfameron> also do ... ;
09:09:27 <lolcathost> @pl f x = maybe x y z
09:09:28 <lambdabot> f = flip (flip maybe y) z
09:12:21 <liyang> lolcathost: If you're willing to put up with {-# LANGUAGE LambdaCase #-} ... http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#lambda-case
09:20:14 <lolcathost> liyang: ty let me see!
09:20:48 <lolcathost> liyang: At least that is less verbose!
09:23:28 <lolcathost> Is there any syntactic sugar for "if cond then return x else $ do" ?
09:24:19 <plat0> Is there a version of Language.Haskell.Syntax for common GHC extensions?
09:24:47 <jmcarthur> lolcathost: not sugar, but...   (guard cond >> do ...) <|> return x   -- for instance of MonadPlus (and if it's not also an instance of Alternative you have to replace (<|>) with mplus)
09:25:29 <jmcarthur> lolcathost: also, if x is just (), you could say:    unless cond $ do ...
09:25:42 <lolcathost> jmcarthur: Unfortunately, x is not ().
09:25:51 <lolcathost> jmcarthur: I am aware of when and unless.
09:25:59 <lolcathost> jmcarthur: ty btw!
09:26:11 <lolcathost> @hoogle MonadPlus
09:26:12 <lambdabot> Control.Monad class Monad m => MonadPlus m
09:26:26 <jmcarthur> lolcathost: that might have different semantics than what you are really after for some monads
09:26:34 <jmcarthur> so... just beware
09:27:00 <jmcarthur> for example, for the list monad, that will just add x to the end of the list, even if the guard passes
09:27:15 <lolcathost> jmcarthur: It is just ST.
09:27:26 <jmcarthur> hmm... ST might not even be an instance of MonadPlus
09:27:33 <jmcarthur> i can't think of how it would be
09:27:36 <jmcarthur> @instances MonadPlus
09:27:36 <lambdabot> Either e, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, StateT s m, WriterT w m, []
09:28:51 <hpaste> lolcathost pasted “SICP's count-change” at http://hpaste.org/79677
09:29:33 <lolcathost> I just wanted to put the countChangeST's first three cases inside the do block.
09:30:26 <lolcathost> (Because that would allow me to flip countChangeST's arguments to "n xs h", which would in turn allow me to define countChange as "new >>= countChangeST n xs".)
09:30:29 <jmcarthur> lolcathost: i would replace that whole \case expression with fromMaybe, and i probably wouldn't use a mutable container at all
09:30:48 <jmcarthur> the fromMaybe thing only works if not using the monad, to be clear
09:31:18 <lolcathost> Mmm...
09:31:22 <jmcarthur> maybe action return   is a common pattern. there should probably be a function for that
09:32:18 <lolcathost> An alternative to the mutable container would be an array whose elements are lazily initialized, but I have no idea how big the array needs to be.
09:32:21 <dmwit> ?hoogle whenJust
09:32:21 <lambdabot> No results found
09:32:34 <dmwit> ?hoogle whenJust +xmonad +xmonad-contrib
09:32:34 <lambdabot> Could not find some databases: xmonad xmonad-contrib
09:32:35 <lambdabot> Searching in:
09:32:35 <lambdabot>   .
09:32:49 <jmcarthur> lolcathost: why not just a Map or something?
09:34:04 <lolcathost> Would that not change the amortized complexity of lookup from O(1) to O(log n)?
09:34:24 <jmcarthur> what's wrong with log n?
09:35:51 <lolcathost> jmcarthur: Nothing, I guess. After all, this is just a toy program. :)
09:35:52 <jmcarthur> lolcathost: hash tables can be fast, but it has nothing to do with amortized O(1)
09:36:45 <dmwit> for all n, log n < 30
09:36:55 <monochrom> heh
09:37:15 <lolcathost> dmwit: Experimentally determined? :-O
09:37:27 <jmcarthur> lolcathost: how much memory does your machine have?
09:37:29 <dmwit> this is computer _science_, after all
09:37:56 * hackagebot fad 1.1.0.1 - Forward Automatic Differentiation.  http://hackage.haskell.org/package/fad-1.1.0.1 (BjornBuckwalter)
09:38:07 <lolcathost> jmcarthur: 8GB RAM, not using disk for virtual memory at all.
09:38:30 <jmcarthur> lolcathost: that means you only need 33 bits for each addressable location in your physical memory
09:38:48 <jmcarthur> lolcathost: how many hash tables do you have that need all available memory? :)
09:39:02 <lolcathost> jmcarthur: Oh, true. Haha.
09:39:54 <jmcarthur> *need 33 bits to designate any one address in your physical memory
09:41:28 <lolcathost> jmcarthur: I just used a hashtable, because it was the first key-value container I happened to stumble upon in Hackage. XD
09:42:29 <jmcarthur> lolcathost: the containers package probably came with your ghc
09:42:46 <jmcarthur> lolcathost: it should provide at least Data.Map, Data.IntMap, Data.Set, and Data.IntSet
09:43:22 <lolcathost> jmcarthur: Ah!
09:44:08 <jmcarthur> lolcathost: and these days there are Strict and Lazy variants for all of those, although i think the Strict apis aren't quite the way i would have designed them
09:44:38 <Iceland_jack> jmcarthur: Do you know if anything like GMap (generalized map) is going to find its way into the libraries?
09:45:52 <jmcarthur> Iceland_jack: i'd never even heard of that one until now, although it looks like other things i have used before, and it looks like i know the person who wrote it by coincidence
09:46:13 <Iceland_jack> oh :)
09:46:16 <jmcarthur> Iceland_jack: the only way that will happen is if somebody proposes it, gets support, and is willing to do the work himself :)
09:46:25 <Iceland_jack> Hehe, fair enough
09:46:30 <jmcarthur> well, maybe not the only way, but the most reliable way
09:46:57 <jmcarthur> and you don't have to be "a somebody" to do so
09:47:19 <Iceland_jack> ;) Don't worry, I'm not
09:47:24 <Iceland_jack> on that point (since it would use the same extension), do you think there is a place in Haskell for generalizing containers?
09:47:34 <jmcarthur> all said, i think i would vote against this particular interface being standardized
09:47:48 <Iceland_jack> jmcarthur: Any reason why?
09:47:55 <jmcarthur> it looks more like a swiss army knife than any sort of principled approach. there are surely better ways
09:48:30 <jmcarthur> i'm not sure i understand your question. you mean a place in the *language* haskell for generalizing containers?
09:48:39 <Iceland_jack> yes
09:48:45 <dmwit> What does "generalizing containers" mean?
09:49:11 <jmcarthur> Iceland_jack: Functor, in some sense, already generalizes many containers
09:49:24 <jmcarthur> or at least it is said to. i think it's a fuzzy way to explain Functor
09:49:33 <Iceland_jack> where it doesn't matter what data collection you have, you could generalize functions on them by having some collection of operations for them
09:49:49 <Iceland_jack> so you could use “length” that works for both Set and Lists
09:49:49 <jmcarthur> sounds like type classes are a fine way to do that already
09:49:56 <mvj4_> @pl \a b -> b + 1
09:49:56 <lambdabot> const (1 +)
09:50:03 <jmcarthur> Iceland_jack: there is already such a generalization for length :)
09:50:11 <Iceland_jack> jmcarthur: Right but I believe you'd have to use type families
09:50:17 <Iceland_jack> I meant in the way it's implemented ;)
09:50:19 <jmcarthur> :t Data.Foldable.foldl (+) 0
09:50:21 <lambdabot> (Num b, Foldable t) => t b -> b
09:50:26 <jmcarthur> that's not length
09:50:29 <jmcarthur> that's just:
09:50:34 <jmcarthur> :t Data.Foldable.sum
09:50:35 <lambdabot> (Num a, Foldable t) => t a -> a
09:50:38 <jmcarthur> but you can do length as well
09:51:17 <jmcarthur> ugh, ocaml has ruined me
09:51:20 <jmcarthur> :t foldl
09:51:21 <lambdabot> (a -> b -> a) -> a -> [b] -> a
09:51:27 <Iceland_jack> So for a list, cons xs might return (head, tail) while cons of a set would return (arbitrary element, rest): possibly implemented as minView
09:51:37 <jmcarthur> :t Data.Foldable.foldl (\_ acc -> acc+1) 0
09:51:38 <lambdabot> (Num a, Foldable t) => t a -> a
09:52:00 <jmcarthur> Iceland_jack: no type families needed for that length function ^^
09:52:33 <jmcarthur> Iceland_jack: there are some containers that have restrictions on the types of elements. those might require something like type families or MPTCs, but we already have those features...
09:52:59 <Iceland_jack> The length function was just an example, perhaps a bad one
09:53:12 <jmcarthur> my point is just that we don't need to really change the language (or at least the language commonly called "Haskell" as implemented by ghc) to get this
09:53:18 <Iceland_jack> I know that
09:53:46 <Iceland_jack> Since Haskell finally has Type Families implementing this is very easy
09:53:56 <jix> hmm the GHC manual says " You can't have an implicit parameter in the context of a class or instance declaration" but instance (?foo :: String) => Show X where show _ = ?foo works fine in my 7.6.1 GHCi
09:53:58 <Iceland_jack> blah :: Collects ce => ce -> [Elem ce]
09:53:58 <Iceland_jack> blah (cons' -> Nothing) = []
09:53:58 <Iceland_jack> blah (cons' -> Just (x, xs)) = x:blah xs
09:54:08 <Iceland_jack>   ↑ this works to turn any collection into a List
09:54:15 <Iceland_jack> it works for lists (duh), sets, etc.
09:54:39 <jmcarthur> jix: weird!
09:54:41 <masak> so I have a function returning a list of pairs of Int: [(Int, Int)]. what would a main function look like that went through each of the pairs and output it on its own line?
09:54:56 <jmcarthur> jix: does the resulting instance work?
09:55:00 <jix> I wonder if it really works in all cases...
09:55:02 <jix> jmcarthur: it does
09:55:12 <jix> at least for toy examples
09:55:15 <jmcarthur> jix: meaning it requires the implicit parameter and everything?
09:55:18 <jix> yeah
09:55:20 <jmcarthur> neat
09:55:26 <jmcarthur> perhaps accidental, but neat :)
09:55:40 <jix> and that would be usefull for show instances that need extra information to give nice output
09:55:46 <jmcarthur> masak: mapM_ print
09:56:02 <elliott> jix: better to use the reflection package imo
09:56:05 <jix> but I'm not sure if it is a good idea to use it
09:56:12 <elliott> implicit parameters have some nasty interactions and nobody likes using them :P
09:56:22 <elliott> I think the extension might technically be removed at some point too?
09:56:32 <jix> elliott: yeah that's another reason I don't want to use it
09:56:40 <parcs> what are the nasty interactions?
09:57:02 <elliott> parcs: the stuff where adding an innocuous type signature can change your values etc.
09:57:28 <jix> elliott: but I'm storing expressions with newtype wrapped Ints as variables... and I want to restore the names when I print them but I don't want to store the names in the expression
09:57:32 <masak> jmcarthur: that typechecks, but when I run it, it outputs nothing.
09:57:46 <jmcarthur> masak: you must apply it to the list
09:57:47 <masak> I have it as `main = mapM_ print solutions`
09:57:59 <masak> and right now, `solutions = [(4, 13)]`
09:57:59 <jmcarthur> it should work. are you sure solutions has any elements?
09:58:02 <jmcarthur> ah
09:58:02 <elliott> jix: yeah you can do that with reflection, might have to change your type slightly though
09:58:05 <masak> prints nothing.
09:58:12 <jmcarthur> masak: i need to see all of your code. hpaste?
09:58:17 <masak> sure. hold on.
09:58:33 <jix> elliott: it's not written yet so I can just chose the type to make it work :) will look at that package
09:58:36 <Iceland_jack> jmcarthur: (my idea is that it would be unneccessary to have an empty/toList/insert/member function exported by each collection library when it's possible to make single that do the same while using the same efficient implementation; would you think this would be a good idea to implement?)
09:58:40 <elliott> data MyExp p = Var Int | ...; instance Reifies p [VarName] => Show (MyExp p) where show (Var n) = reflect (Proxy :: Proxy p) !! n; ...
09:58:53 <jmcarthur> Iceland_jack: a fine idea. i just think it's waiting on a decent implementation that isn't a mess
09:59:03 <masak> jmcarthur: https://gist.github.com/4360239
09:59:32 <jmcarthur> masak: it works for me
09:59:33 <Iceland_jack> Thanks for the positive feedback jmcarthur :) I've never implemented a Haskell package (I've mostly been working with Agda) but I'm tempted to do so
09:59:36 <jmcarthur> masak: how are you running it?
09:59:55 <masak> ghc -o haskell-solution haskell-solution.hs
09:59:58 <masak> ./haskell-solution
10:00:02 <masak> ...and now it works :)
10:00:06 <masak> jmcarthur: thanks for the help.
10:00:15 <jmcarthur> maybe you just hadn't saved it properly or something the first time :)
10:00:16 <masak> most likely, I forgot to recompile or something.
10:00:17 <jmcarthur> np
10:00:18 <masak> right.
10:02:09 <parcs> hmm i wonder what neat stuff you can do with implicit params in instance contexts
10:03:49 <parcs> i guess you can construct instances at runtime
10:04:09 <elliott> parcs: that's what reflection does already, yeah
10:04:16 <elliott> if it works for implicit params you can do the same thing
10:04:27 <parcs> but reflection requires a lot of boilerplate, from what i'v eseen
10:04:53 <parcs> instance (?show :: a -> String) => Show (ShowProxy a) where show = ?show
10:05:13 <elliott> the boilerpltae is pretty minimal if you look at e.g. https://github.com/ekmett/reflection/blob/master/examples/Monoid.hs
10:05:41 <parcs> but compare that to the line i just gave :P
10:05:54 <elliott> parcs: one difference is that yours doesn't type.
10:05:56 <elliott> you need to unwrap the newtype
10:06:08 <parcs> oh, right
10:06:09 <elliott> and if you do Monoid you need to re-wrap, so already have the M ... runM boilerplate
10:07:56 * hackagebot snowball 1.0.0 - Bindings to the Snowball library.  http://hackage.haskell.org/package/snowball-1.0.0 (DagOdenhall)
10:09:57 <kmee> hello. is there a read that returns Maybe a?
10:10:03 <parcs> still, reflection performs black magic while this technique is fairly transparent
10:10:11 <jmcarthur> :t reads
10:10:13 <lambdabot> Read a => ReadS a
10:10:13 <parcs> kmee: readMaybe, if you have ghc 7.6
10:10:27 <kmee> thanks
10:10:30 <jmcarthur> readMaybe! didn't know about it
10:10:41 <kmee> i have 7.4.1
10:10:53 <jmcarthur> ah, lives in Text.Read
10:10:58 <kmee> I'll keep it in mind for future
10:11:06 <cmccann> readMaybe is nice
10:11:09 <elliott> parcs: actually you can implement reflection in h98 + ffi
10:11:13 <elliott> + rank2 + fundeps I guess
10:11:19 <elliott> it uses a faster implementation by default though
10:11:24 <elliott> you can read the oleg paper, it's actually quite elegant
10:11:24 <cmccann> now all I have to do is rename it to read, instead of writing my own
10:11:36 <jmcarthur> kmee: there's still reads, which isn't quite what you want, but gives you a way to implement what you want
10:11:55 <elliott> http://hackage.haskell.org/packages/archive/reflection/0.7/doc/html/src/Data-Reflection.html
10:12:02 <cmccann> or, well, copy and pasting the non-exported readEither function
10:12:25 <elliott> heh, that happens to coincide with the version where edwardk accidentally exported unsafeCoerce
10:12:28 <elliott> but the basic implementation is the same anyway
10:12:32 <kmee> I wish there was a way to access non-exported functions. maybe in future
10:12:53 <cmccann> cf. http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/src/Text-Read.html
10:12:57 <cmccann> near the bottom
10:13:05 <edwardk> kmee: the idea is that they often aren't exported because they can let you break invariants
10:13:16 <elliott> parcs: and actually the current implementation works on hugs
10:13:19 <cmccann> edwardk, which is clearly why readEither is not exported I'm sure
10:13:31 <elliott> parcs: it'll work with any implementation that implements typeclasses with dictionary passing more or less
10:13:34 <edwardk> that one wasn't exported because of silliness
10:13:36 <elliott> (and there's a fallback to the portable one)
10:13:52 <zenware> What's up with the Options module, every time I try to use defineOptions it throws errors..
10:14:45 <donri> @hackage Read a => a -> Maybe a
10:14:45 <lambdabot> http://hackage.haskell.org/package/Read a => a -> Maybe a
10:14:50 <masak> given a list, what's a nice way of getting a mapping of the elements to the number of occurrences in the list?
10:14:51 <donri> @hoogle Read a => a -> Maybe a
10:14:51 <lambdabot> Prelude Just :: a -> Maybe a
10:14:51 <lambdabot> Data.Maybe Just :: a -> Maybe a
10:14:51 <lambdabot> Control.Applicative pure :: Applicative f => a -> f a
10:14:59 <cmccann> edwardk, I think finding that readEither exists but isn't exported was the first time the Haskell standard libraries have made me really, seriously want to strangle somebody
10:15:00 <budger> zenware: confider OptionsApplicative (name my be slightly different)
10:15:01 <donri> well that's useful
10:15:07 <donri> kmee: there's one in the safe package
10:15:24 <edwardk> cmccann: heh
10:15:31 <donri> @hoogle Read a => String -> Maybe a
10:15:31 <lambdabot> Network.CGI.Protocol maybeRead :: Read a => String -> Maybe a
10:15:32 <lambdabot> Network.CGI readCookie :: (Read a, MonadCGI m) => String -> m (Maybe a)
10:15:32 <lambdabot> Network.CGI readInput :: (Read a, MonadCGI m) => String -> m (Maybe a)
10:15:48 <kmee> donri thanks, looks to be a useful package
10:16:10 <masak> I guess the datatype I'm looking for is Map.
10:16:10 <donri> or "errors" which exports safe and gives you more things
10:16:45 <cmccann> Monad lacking appropriate class constraints and mappend being an ugly name are one thing, but hiding a perfectly good readEither function.... >:[
10:17:28 <kennyd> masak association list works too if you don't have too many elements.
10:17:31 <kennyd> > lookup "bar" [("foo", 1), ("bar", 2)]
10:17:33 <lambdabot>   Just 2
10:17:50 <donri> masak: http://hackage.haskell.org/packages/archive/multiset/0.2.2/doc/html/Data-MultiSet.html how about this?
10:17:55 <masak> ooh
10:18:22 <mreh> I need ideas on how to debug callbacks in FFI code
10:18:56 <masak> yes, MultiSet.fromList seems to be what I needed.
10:19:15 <Diabellical> new to Haskell from Python, considering some chess evaluation experimentation in Haskell
10:19:20 <mreh> I'm passing haskell functions to C code to be called later
10:19:21 <donri> masak: hacking on pugs?
10:20:01 <zenware> budger: Thanks, I'll look into it
10:20:16 <mreh> Diabellical: check out monads, the list monad wouuld be good for evaluating chess moves
10:20:24 <masak> donri: heh, no :) just had a hunch a particular problem would be nicer to solve in Haskell.
10:20:31 <donri> :)
10:20:46 <masak> donri: getting "Failed to load interface for `Data.MultiSet'" -- is this something that I have to download separately?
10:20:50 <jmcarthur> :t map (head &&& length) . group . sort   -- masak
10:20:52 <lambdabot> Ord c => [c] -> [(c, Int)]
10:20:53 <Diabellical> @mreh thanks, completely new to haskell. Hoping to learn a lot in the process.
10:20:53 <lambdabot> Maybe you meant: free more
10:20:59 <donri> masak: cabal install multiset
10:21:04 <masak> ah.
10:21:17 <jmcarthur> :t Data.Map.fromList . map (head &&& length) . group . sort
10:21:18 <lambdabot> Ord k => [k] -> M.Map k Int
10:21:21 <donri> odd that you're not getting an *import* error though?
10:21:37 <jmcarthur> :t Data.Map.fromListWith (+)
10:21:39 <lambdabot> (Num a, Ord k) => [(k, a)] -> M.Map k a
10:21:49 <jmcarthur> :t Data.Map.fromListWith (+) . map (,1)
10:21:50 <lambdabot> Illegal tuple section: use -XTupleSections
10:21:52 <jmcarthur> bah
10:21:58 <jmcarthur> :t Data.Map.fromListWith (+) . map (flip (,) 1)
10:21:59 <lambdabot> (Num a, Ord k) => [k] -> M.Map k a
10:22:24 <jmcarthur> > Data.Map.fromListWith (+) . map (flip (,) 1) $ "aaabaabccd"
10:22:26 <lambdabot>   Not in scope: `Data.Map.fromListWith'
10:22:35 <donri> pwnd
10:22:37 <jmcarthur> > M.fromListWith (+) . map (flip (,) 1) $ "aaabaabccd"
10:22:39 <lambdabot>   fromList [('a',5),('b',2),('c',2),('d',1)]
10:23:10 <jmcarthur> > M.fromList . map (head &&& length) . group . sort $ "aaabaabccd"
10:23:12 <lambdabot>   fromList [('a',5),('b',2),('c',2),('d',1)]
10:23:20 <donri> masak: ^ or use Data.Map like jmcarthur shows. but if multiset works it seems more "proper"
10:23:51 <jmcarthur> i think  Compose Map Sum  would also be pretty proper, if it was convenient :(
10:24:01 <jmcarthur> i guess there's TMap
10:24:03 <masak> donri: well, I'm getting a weird problem when compiling: https://gist.github.com/4360326
10:24:12 <masak> I have no idea why it would fail during linking.
10:24:27 <jmcarthur> http://hackage.haskell.org/packages/archive/total-map/0.0.4/doc/html/Data-TotalMap.html
10:24:49 <jmcarthur> so, TMap k (Sum Int) would be a multiset, too
10:24:54 <donri> masak: -package multiset, maybe, but shouldn't need to i don't think ...
10:25:10 <catsbydlo> masak: does '--make' make any difference?
10:25:13 <donri> i rarely call ghc directly
10:25:32 <donri> --make is default since like, 7.0
10:25:52 <nh2> I have a library with a c bridge via c-sources and hsc2hs using functions from MagickWand. I also have an executable depending on that library. When I cabal build, I get a linker error missing MagickWand. Where do I have to give the linker options like "-lMagickWand"?
10:26:10 <donri> that -o is redundant though
10:27:31 <donri> nh2: extra-libraries: MagickWand -- i think
10:28:11 <mreh> nh2: yeah
10:28:43 <mreh> if it's an installed library
10:31:18 <nh2> donri, mreh: it is, but it doesn't work: same standard linker collect2 error. http://hpaste.org/79678 is my cabal file
10:32:20 <donri> nh2: not sure it's a comma list and you shouldn't pass -l in ghc-options
10:32:59 <mreh> yeah drop the -l options
10:33:16 <nh2> donri, mreh: are the extra-libraries supposed to go into the library or executable section?
10:33:36 <donri> nh2: library
10:33:40 <nh2> ahh
10:33:42 <nh2> I think it works
10:33:46 <mreh> it depends surely?
10:33:51 <donri> unless you have foreign imports in the exe sources
10:33:57 <mreh> yes
10:34:16 <mreh> he seems to have both, it can even go in the package scope I thibk
10:34:19 <mreh> think*
10:34:27 <donri> i think that's deprecated
10:34:43 <nh2> mreh, donri: decent! Library works.
10:34:49 <donri> yay!
10:34:53 <mreh> woop
10:35:29 <nh2> thank you!
10:35:34 <donri> np
10:40:11 <masak> catsbydlo: it... did.
10:40:17 <masak> catsbydlo: what does --make do?
10:40:44 <catsbydlo> it's magic~
10:42:04 <catsbydlo> http://www.haskell.org/ghc/docs/7.6.1/html/users_guide/modes.html#make-mode
10:42:20 <masak> how do I convert a List to a Data.Set (losing duplicates)?
10:42:26 <jmcarthur> toList
10:42:29 <jmcarthur> err
10:42:31 <jmcarthur> fromList
10:43:13 <masak> I don't see a fromList in http://www.haskell.org/haddock/libraries/Data.Set.html
10:43:47 <elliott> that's ancient
10:43:52 <elliott> http://hackage.haskell.org/package/containers
10:44:26 <masak> ah. excellent.
10:44:52 <catsbydlo> http://www.haskell.org/ghc/docs/latest/html/libraries/containers-0.5.0.0/Data-Set.html
10:44:59 <masak> much better.
10:45:01 <masak> thank you.
10:52:16 <Diabellical> curious about pattern analysis / "nearness" in matrix entries. Any suggestions of sources for pattern searching in Haskell would be great.
10:57:12 <hiptobecubic> Diabellical, go on?
10:57:58 * hackagebot snowball 1.0.0.1 - Bindings to the Snowball library.  http://hackage.haskell.org/package/snowball-1.0.0.1 (DagOdenhall)
10:59:56 <Diabellical> so I am looking at chess evaluation, and would like to find common "mobility" patterns of pieces which tend towards certain tactics. So representing a position as matrix or directed sub-graph, and finding (therein) patterns of mobility/position linked to the statistical base.
11:01:19 <Diabellical> so for example (if i have a matrix of binary values), suppose a particular arrangement statistically is deemed to end up lending a "pin"; then how "close" is the current matrix arrangement to the canonical form.
11:06:08 <hiptobecubic> i see
11:06:26 <hiptobecubic> Do you have a definition for distance then? Or is that what you're hoping for
11:08:38 <latro`a> coming from a mathematician's angle, does the distance need to actually be a metric?
11:08:53 <latro`a> and in any case what is the whole space?
11:09:33 <Diabellical> :hip I assume you mean distance as distance from canonical form: in that case, I am still toying with that, however that is what, on some level I am hoping to achieve by classifications of state
11:09:55 <latro`a> these are binary square matrices?
11:09:57 <Diabellical> ie: piece mobility index = x    "virility"= y etc....
11:10:01 <latro`a> i.e. {0,1}^(n^2)
11:10:02 <latro`a> ?
11:10:16 <latro`a> or perhaps {0,1}^(mn)
11:11:11 <Diabellical> The matrices will be square, however there will be additional data sitting at each node (if represented graph theoretically), binary but multivalued ie (0,1,0,1,1) etc for attributes of square
11:12:58 * hackagebot yaml 0.8.1.2 - Support for parsing and rendering YAML documents.  http://hackage.haskell.org/package/yaml-0.8.1.2 (MichaelSnoyman)
11:20:23 <masak> inside of a list comprehension, how do I do the equivalent of a 'where', defining a variable in terms of another?
11:20:52 <tromp> ,let a = expr,
11:21:23 <tromp> > [a|x<-[0..9], let a = x*x]
11:21:25 <lambdabot>   [0,1,4,9,16,25,36,49,64,81]
11:21:38 <masak> oh, 'let'. thank you.
11:28:01 <masak> if s is an Int, what do I need to make [2..s/2+1] work out as being typed as [Int] ?
11:30:29 <elliott> masak: use `div`
11:32:44 <masak> elliott: thank you.
11:38:20 <masak> here's my whole solution. https://gist.github.com/4360642
11:38:30 <masak> it compiles, and I've finished transcribing it.
11:38:47 <masak> there's a bug somewhere, because it outputs too many solutions. but it runs :)
11:38:56 <masak> any stylistic comments much appreciated.
11:39:09 <vella> hi
12:06:39 <fakhrazeyev> :q
12:08:32 <pmk> greetings
12:09:26 <pmk> (crickets)
12:09:33 <masak> hi, pmk
12:09:36 <pmk> hi
12:09:45 <fakhrazeyev> Is there a yesod irc channel?
12:10:13 <simpson> fakhrazeyev: I think #yesod is a channel.
12:10:39 <fakhrazeyev> thank you, simpson
12:10:50 <pmk> i am struggling to understand exactly why ((.).(.)) does what it does and it is unfortunately not very google-able
12:11:12 <`ramses> :t (.)
12:11:13 <lambdabot> Functor f => (a -> b) -> f a -> f b
12:11:23 <`ramses> ah, okay don't use that
12:11:27 <`ramses> :t (Prelude..)
12:11:29 <lambdabot> (b -> c) -> (a -> b) -> a -> c
12:11:30 <simpson> lambdabot lies here and uses fmap for (.).
12:11:33 <`ramses> use that
12:11:51 <`ramses> pick different names for the types in the three occurences of (.)
12:11:51 <pmk> :t (.).(.)
12:11:53 <lambdabot> (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
12:11:56 <`ramses> and fill them in
12:12:10 <simpson> :t (Prelude..) Prelude.. (Prelude..)
12:12:11 <lambdabot> (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
12:13:08 <jmcarthur> @. @djinn @type (Prelude..) Prelude.. (Prelude..)
12:13:08 <lambdabot> Plugin `compose' failed with: Unknown command: "@djinn"
12:13:13 <jmcarthur> @. djinn type (Prelude..) Prelude.. (Prelude..)
12:13:14 <lambdabot> f a b c d = a (b c d)
12:13:39 <pmk> it's a useful idiom but not the most readable thing in the world
12:14:17 <jmcarthur> @. pl . djinn type (Prelude..) Prelude.. (Prelude..)
12:14:18 <lambdabot> f = (.) . (.)
12:14:27 <`ramses> pmk: you get used to it, but you shouldn't use it (too much?) either in real code
12:14:35 <cmccann> :t (.:)
12:14:36 <lambdabot> (Functor g, Functor f) => (a -> b) -> f (g a) -> f (g b)
12:14:44 <cmccann> some people like to use that
12:14:56 <pmk> sure, but it's hardly the same thing
12:15:02 <`ramses> cmccann: that's not in any module I think?
12:15:08 <`ramses> :t fmap fmap fmap
12:15:10 <lambdabot> (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
12:15:11 <cmccann> not in any standard one
12:15:17 <`ramses> that's another one :)
12:15:19 <jmcarthur> (fmap.fmap) is way more clear to me than (.:)
12:15:20 <simpson> pmk: It's exactly the same thing, just more general.
12:15:35 <cmccann> but yes, ((.).(.)) = fmap fmap fmap in lambdabot's Caleskell
12:16:04 <jmcarthur> :t (fmap.fmap) `asTypeOf` (Prelude..) Prelude.. (Prelude..)
12:16:06 <lambdabot>     Precedence parsing error
12:16:06 <lambdabot>         cannot mix `asTypeOf' [infixl 9] and `GHC.Base..' [infixr 9] in the same infix expression
12:16:10 <jmcarthur> :t (fmap.fmap) `asTypeOf` ((Prelude..) Prelude.. (Prelude..))
12:16:12 <lambdabot> (a -> b) -> (a1 -> a2 -> a) -> a1 -> a2 -> b
12:16:53 <`ramses> pmk: the fmap versions are exactely the same as the ones with (.) if you use ((->) r) as the instance for functor
12:17:14 <cmccann> :t (<<<) >>> (<<<)
12:17:16 <lambdabot> Control.Category.Category cat => cat b c -> (a1 -> cat a b) -> a1 -> cat a c
12:17:21 <cmccann> that's my favorite :D
12:17:29 <pmk> whoa
12:17:52 <pmk> ah, ok, i see that
12:18:10 <cmccann> :t (<<<) >>> (<<<) >>> (<<<)
12:18:11 <lambdabot> Control.Category.Category cat => cat b c -> (a2 -> a1 -> cat a b) -> a2 -> a1 -> cat a c
12:18:15 <cmccann> it's even extensible!
12:18:29 <simpson> :t flip flip flip flip flip -- my favorite
12:18:30 <lambdabot> (a1 -> ((a -> b -> c) -> b -> a -> c) -> c1) -> a1 -> c1
12:18:58 <simpson> :t flip flip flip flip flip flip -- 'cause it stops changing after a point!
12:19:00 <lambdabot> (a1 -> ((a -> b -> c) -> b -> a -> c) -> c1) -> a1 -> c1
12:19:03 <jmcarthur> cmccann: how do you use that?
12:19:12 <jmcarthur> i don't quite see it
12:19:17 <cmccann> jmcarthur, you don't if you have any sense
12:19:49 <pmk> it would be fun to check a huge subset of all applications and compositions and find unexpected additional equivalences and generalizations
12:20:14 <cmccann> pmk, that kind of fun is why lambdabot's (.) is fmap
12:20:28 <hpaste> prsteele pasted “Primes” at http://hpaste.org/79679
12:20:44 <jmcarthur> pmk: there are many fun things you can compose, the same way as fmap
12:20:51 <jmcarthur> :t (liftA2.liftA2.liftA2)
12:20:52 <lambdabot> (Applicative f2, Applicative f1, Applicative f) => (a -> b -> c) -> f (f1 (f2 a)) -> f (f1 (f2 b)) -> f (f1 (f2 c))
12:20:59 <prsteele> who, hpaste bot
12:21:00 <jmcarthur> :t (foldMap.foldMap.foldMap)
12:21:01 <lambdabot> (Foldable t2, Foldable t1, Foldable t, Monoid m) => (a -> m) -> t (t1 (t2 a)) -> m
12:21:04 <prsteele> /s/who/whoa
12:21:14 <cmccann> incidentally, though
12:21:14 <jmcarthur> :t (traverse.traverse.traverse)
12:21:15 <lambdabot> (Applicative f, Traversable t2, Traversable t1, Traversable t) => (a -> f b) -> t (t1 (t2 a)) -> f (t (t1 (t2 b)))
12:21:28 <cmccann> :t (>>>) <<< (>>>) -- this is a valid implementation of fmap for Cont
12:21:29 <lambdabot> Control.Category.Category cat => cat a b -> (cat a c1 -> c) -> cat b c1 -> c
12:21:47 <simpson> ...Now that you say it, I can't unsee it.
12:22:07 <pmk> has an exhaustive search been performed?
12:22:20 <jmcarthur> exhaustive? that would be pretty hard to claim
12:22:33 <jmcarthur> there are always fun ways to compose things and get other things
12:22:44 <simpson> I think that the version for Category *is* the exhaustive one.
12:22:52 <simpson> And people just need to add more Category instances. :3
12:23:16 <pmk> well, exhaustive up to say four or five applications of higher-order functions, maybe
12:23:33 <cmccann> I just assume that if any novel, weird and interesting abstraction is possible edwardk will find it eventually and save the rest of us the trouble
12:23:36 <jmcarthur> still sounds hard
12:24:51 <jmcarthur> i desire a more PolyKind-friendly type class hierarchy, but i think that the resulting instances would still be a bit awkward due to the need to newtype wrap so many things
12:26:12 <jmcarthur> but for example, it would be nice if Functor worked for natural transformations, too
12:26:33 <edwardk> just make Int :: () -> *
12:26:42 <jmcarthur> oh great
12:26:45 <jmcarthur> :)
12:27:29 <cmccann> we need "newkind" definitions, so we can create things equivalent to *
12:27:49 <jmcarthur> oh the things we do to avoid dependent types
12:27:52 <edwardk> (->) :: (k -> *) -> (k -> *) -> k -> *
12:27:59 <cmccann> with some sort of auto-translation like generalized newtype deriving, since that's clearly a well-behaved extension as is
12:28:58 <jmcarthur> cmccann: i don't recall which, but it's either not so clearly well-behaved or it just used to have some awful bugs that broke implementation hiding
12:29:16 <cmccann> jmcarthur, clearly I was not being sarcastic in any way
12:29:23 <cmccann> as indicated by my use of the word "clearly"
12:29:25 <jmcarthur> i wasn't sure
12:29:46 <cmccann> there's a reason why GeneralizedNewtypeDeriving is disallowed by SafeHaskell
12:30:04 <jmcarthur> since you used "clearly" again, i now feel like you have just claimed that you always lie
12:30:21 <cmccann> that is clearly true
12:30:43 <jmcarthur> oh, you said "not sarcastic"
12:31:16 <jmcarthur> clearly, i have excellent reading comprehension skills
12:31:29 <cmccann> clearly!
12:32:09 <cmccann> anyway: http://joyoftypes.blogspot.com/2012/08/generalizednewtypederiving-is.html
12:32:59 <jmcarthur> GeneralizedNewtypeDeriving is both profoundly unsafe and amazingly useful :(
12:33:36 <Taneb> Does that extension change the effect of "deriving (Show)
12:33:38 <Taneb> "?
12:33:45 <jmcarthur> i don't think so
12:33:57 <jmcarthur> i think the built-in deriving stuff still works the same
12:34:10 <cmccann> I think even stuff like DeriveFunctor takes precedence
12:34:50 <simpson> IIUC, it *generalizes* the idea of deriving on a newtype by simply assuming the type-safety of coercions on the newtype and then using underlying instances.
12:35:04 <cmccann> yes
12:35:06 <simpson> So if you have something like DeriveFunctor which generates code, then that code will still be used.
12:36:56 <jmcarthur> it seems like GeneralizedNewtypeDeriving shouldn't be all that hard to implement safely. it should just generate haskell code that does whatever wrapping and unwrapping is necessary to implement the instance
12:36:58 <cmccann> as far as I know all the major problems with generalized newtype deriving require very contrived code to occur
12:37:50 <cmccann> jmcarthur, I think augustss has remarked the same in an eyerolling-tone along with a mention that that's how HE would do it
12:38:09 <jmcarthur> heh
12:40:11 <Heffalump> I've been writing some typeclass hierarchies with type families that would probably fall foul of GeneralizedNewtypeDeriving by accident if I'm not careful
12:40:47 <hpaste> Damnesia pasted “Error last line” at http://hpaste.org/79680
12:41:02 <BMeph> GeneralizedNewtypeDeriving: unsafeCoerse, for types! :)
12:41:07 <Damnesia> Okay soo...
12:41:20 <Damnesia> Can i do something what would achieve what im trying to do thare?
12:41:27 <Damnesia> *there
12:41:48 <BMeph> Damnesia: First: Do you know what you're trying to do there? ;)
12:42:01 <Damnesia> i know why it doesnt work :P
12:42:11 <Damnesia> cause it thinks xs is a char, right
12:42:26 <cmccann> Heffalump, I kinda figure that anybody capable of writing code that could possibly cause problems with GeneralizedNewtypeDeriving is going to know what they're doing enough to avoid it :P
12:43:11 <cmccann> would be nice if it wasn't an issue at all though :[
12:43:38 <eyebloom> When you are reading a syntax definition for say System Fc, what does it mean when a term has a horizontal line above it?
12:44:03 <Heffalump> cmccann: the point about Haskell is that I don't have to think about these things, even if I am capable of doing so
12:44:17 <Heffalump> honestly, one of my first designs for the hierarchy, I erally wasn't at all sure where I could safely use it
12:45:13 <BMeph> Damnesia: The big issue with your code is "'(' : xs : ')'" is not valid Haskell. :)
12:45:16 <cmccann> Heffalump, very much agreed, I don't like thinking about things either :D
12:45:29 <Damnesia> So BMeph is there a way I could split a String into first char - list of chars - last chars?
12:45:38 <`ramses> BMeph: it could be valid haskell, but it isn't in this case
12:45:39 <Damnesia> *last char
12:45:55 <cmccann> dunno, with the increasing use of fancy type system features maybe the GeneralizedNewtypeDeriving issue will become more pressing and will actually get fixed
12:46:23 <cmccann> given how severe the potential problems are I assume the reason it's still around is the expectation it doesn't occur in practical use
12:46:25 <BMeph> `ramses: Um, ...no. :)
12:46:49 <EarthServer> \quit
12:46:54 <EarthServer> \quit
12:46:54 * elliott sees no way for that snippet to be valid
12:47:05 <BMeph> Damnesia: Yes, but probably not the way you think. :)
12:47:12 <elliott> cmccann: I thought the reason was just nobody had gotten around to fix ingit.
12:47:13 <`ramses> if xs is a Char, you're just consing, right?
12:47:17 <elliott> also fixing it
12:47:24 <cmccann> > fix ingit
12:47:26 <lambdabot>   Not in scope: `ingit'
12:47:26 <lambdabot>  Perhaps you meant one of these:
12:47:26 <lambdabot>    `init' (imported ...
12:47:26 * BMeph is gonna go with elliott, here
12:47:28 <elliott> `ramses: '(' : 'x' : ')' -- not valid
12:47:36 <elliott> '(' : 'x' : ')' : xs might be, but that's another thing entirely
12:47:45 <elliott> ((:) is right-associative)
12:47:52 <`ramses> ah crap, no list to the right...
12:48:09 <`ramses> sorry for the noise ;)
12:48:12 <Damnesia> so BMeph, how would one do it then?
12:48:27 * BMeph goes, "ding-ding-ding"!
12:48:30 <cmccann> elliott, yes but things tend to be gotten around to faster if there are real-world use cases applying torque :P
12:49:25 <BMeph> Damnesia: You could try, '(':xs:")", but I imagine there's something better.
12:49:26 <cmccann> elliott, though I'm not sure why you're complaining about something that provides novel new ways to use unsafeCoerce
12:50:37 <simpson> Damnesia: I would imagine that you would like a parser.
12:50:49 <Damnesia> Yes.
12:52:50 <jmcarthur> cmccann: you forgot to use the word "clearly"?
12:53:20 <cmccann> nah, elliott's hobby of unsafeCoercing things is 100% legit :P
12:54:09 <elliott> cmccann: hey, I was forced to write unsafeCoerce recently!
12:54:38 <elliott> cmccann: GHC will optimise (either Left Right) to id, but not (either (Left . runMyNewtype) Right)
12:54:44 <elliott> or even (either (Left . id) Right), iirc
12:54:50 <elliott> so I replaced it with unsafeCoerce...
12:54:53 <cmccann> haha
12:55:04 <BMeph> elliott: You mean, you were -> coerced <- to use unsafeCoerce? ;þ
12:55:19 <elliott> BMeph: :(
12:55:24 <elliott> cmccann: we get really good Core now though!
12:55:37 <ion> bmeph: YEEEEEEEEEEEAAAAAAAAAAHHH
12:55:56 <cmccann> elliott, yes but AT WHAT PRICE
12:56:15 <BMeph> ion: No, no, wait for it - I haven't asked yet if he was coerced UNSAFELY or not! ;þ
12:56:34 <jmcarthur> elliott: it's unfortunate that ghc doesn't catch that...
12:56:39 <cmccann> safeCoerce :: a -> a
12:56:47 <ion> heh
12:56:56 <ion> safeCoerce = unsafeCoerce
12:57:04 <elliott> jmcarthur: yes, it is
12:57:09 <jmcarthur> unsafeCoerce is a valid implementation for a lot of functions!
12:57:10 <cmccann> or would that be safeCoerce :: a -> Maybe b implemented as const Nothing?
12:57:20 <catsbydlo> :t cast
12:57:21 <lambdabot> (Typeable b, Typeable a) => a -> Maybe b
12:57:36 <cmccann> @quote unsafeCoerce
12:57:36 <lambdabot> roconnor says: unsafeCoerce isn't even safe
12:57:39 <cmccann> @quote unsafeCoerce
12:57:39 <lambdabot> ghc says: Dangerous-looking argument. Probable cause: bad unsafeCoerce#
12:57:43 <cmccann> @quote unsafeCoerce
12:57:43 <lambdabot> shachaf says: isTrue :: Bool -> Bool; isTrue = unsafeCoerce
12:58:24 <elliott> @quote unsafeCoerce
12:58:25 <lambdabot> Jafet says: unsafeCoerce takes any argument. AND IT WINS THAT ARGUMENT.
12:58:43 <cmccann> @quote ddarius unsafeCoerce
12:58:43 <lambdabot> ddarius says: isJust :: Maybe a -> Bool; isJust = unsafeCoerce
12:58:50 <cmccann> there, that's the one I was looking for
12:58:55 <elliott> @quote monochrom unsafeCorece
12:58:55 <lambdabot> No quotes match. :(
12:58:56 <elliott> @quote monochrom unsafeCoerce
12:58:56 <lambdabot> monochrom says: isTrue = (unsafeCoerce :: Either a b -> Bool) . (unsafeCoerce :: Maybe c -> Either a b) . (unsafeCoerce :: Bool -> Maybe c)
12:58:57 <jmcarthur> elliott: i've sadely used unsafeCoerce to avoid (map Wrap) on a couple occasions :\
12:59:00 <jmcarthur> *sadly
12:59:43 <elliott> jmcarthur: right. however, note that (fmap unsafeCoerce = unsafeCoerce) is not always a valid optimisation
12:59:53 <elliott> where unsafeCoerce can be Newtype, runNewtype, id, etc.
13:00:11 <elliott> (this only applies when fmap breaks laws, though)
13:00:18 <jmcarthur> right, i was about to say...
13:00:22 <elliott> but I think it can be "weak" breakage
13:00:33 <elliott> as in, you violate the laws only if you can peek at unexported implementation details like constructors
13:00:39 <elliott> and only expose operations that respect the laws
13:00:47 <elliott> even then fmap unsafeCoerce = unsafeCoerce might screw things up I think
13:01:12 <jmcarthur> i wouldn't use that trick if i don't already have access to the constructors anyway
13:01:20 <jmcarthur> otherwise i'm not promised that it's a newtype at all
13:01:32 * cmccann recalls http://hpaste.org/56741
13:02:20 <elliott> jmcarthur: no, I mean the functor's constructors
13:03:17 <jmcarthur> ah
13:04:31 <jmcarthur> but wouldn't the implementation still have to expose the distinction between fmap id and id in order for this to break it, therefore still "strongly" breaking the laws?
13:06:57 <elliott> jmcarthur: I'm thinking something with type families/GADTs
13:07:14 <elliott> all the obvious ways I can think of involve a constraint on the actual types though
13:07:17 <elliott> (and so wouldn't work for Functor)
13:07:24 <Damnesia> okay, fixed my code. Anyone wants to see it?
13:07:37 <jmcarthur> i miss polymorphic type operators, but it's still amusing what i can do with type operators now that i can define constructors without : prefixes.
13:08:49 <jmcarthur> data (<$>) :: (* -> *) -> [*] -> * where Nil :: f <$> '[]; (:::) :: f a -> f <$> as -> f <$> (a ': as)
13:09:33 <m_fulder> shouldn't:   "fmap ([(Expr.value expr dict)] ++) (exec stmts dict input)"  be equivalent to do {xs <- (exec stmts dict input); return ((Expr.value expr dict) : xs) }
13:10:06 <jmcarthur> i suppose a type family would be more appropriate for that, since then  f <$> '[a,b,c] ~ '[f a, f b, f c],  but it's still amusing
13:10:20 <cmccann> jmcarthur, hahaha that's cute
13:11:12 <Raynes> Well, i guess 2 hard lemonades and a lortab is my limit, guys.
13:12:03 <cmccann> m_fulder, looks the same to me. is it not working as expected for you?
13:13:41 <m_fulder> cmccann no it seems to return another type then the first one
13:14:13 <Taneb> Things that mildly annoy me about Haskell #3: hsp has had a big update and happstack-hsp hasn't
13:14:16 * Raynes Textual may or may not have just had a seizure and switched through 14 channels because of znc while I was sending a message and it may or may not have ended up here by accident, if so, sowwy.
13:14:18 <cmccann> m_fulder, if you have a concrete type they shouldn't, but the inferred type will have different constraints
13:16:08 <m_fulder> cmccann yeah I have concrete types .. the thing is my func type is :  [T] -> Dictionary.T String Integer -> [Integer] -> IO [Integer] .. where all T are defined types .. now the first call returns a IO [Integer] but the second one returns T [Integer] instead :S
13:17:32 <cmccann> m_fulder, what's the type of "exec stmts dict input" alone?
13:17:57 <m_fulder> cmccann the one I've written :P
13:18:26 <m_fulder> cmccann so it should be IO [Integer] I mean .. that was the exec func type
13:20:07 <cmccann> if that expression is IO [Integer] I really can't see how the second version could be something else...?
13:20:45 <cmccann> if you write the second version and give it an explicit type signature of what you expect, what does it complain about?
13:22:10 <m_fulder> cmccann, it complains about the return line saying "Couldn't match expected type IO [Integer] against type: Parser (is my own type) [Integer]
13:22:38 <cmccann> well I'm confused
13:22:58 <cmccann> maybe I'm missing something obvious and simple but I dunno
13:23:02 * hackagebot clay 0.0.1 - CSS preprocessor as embedded Haskell.  http://hackage.haskell.org/package/clay-0.0.1 (SebastiaanVisser)
13:23:10 <m_fulder> hehe yeah Im confused too ^^
13:23:21 <cmccann> hpaste the code in context, perhaps
13:23:29 <cmccann> might help if I could see more of it
13:23:54 <rwbarton> I guess you have oversimplified your problem
13:26:30 <m_fulder> cmccann, yeah hm what do you want to see except the functions itself? (http://pastebin.com/pG1SztKL)
13:26:37 <m_fulder> rwbarton, yeah could be the case :P
13:30:21 <rwbarton> so many parentheses
13:30:31 <m_fulder> hehe :P
13:30:36 <rwbarton> is it possible that somehow fmap is not what we think it is?
13:31:02 <cmccann> oh, it's calling itself
13:31:09 <m_fulder> yeah
13:31:11 <cmccann> at least that explains why it could be so inconsistent between the two
13:31:31 <m_fulder> hm but they both call itself?
13:32:48 <rwbarton> can you paste the whole function source at least
13:33:27 <m_fulder> that's the whole for now
13:34:13 <rwbarton> which one doesn't work with the type signature intact?
13:34:49 <m_fulder> version 1 (the one with the do) doesn't work with the type signature .. the second one (vers2= fmap) works good
13:36:38 <m_fulder> what is it that fmap will do btw, it will map the first argument with the IO [Integer] i.e. each element in the integer list?
13:37:02 <rwbarton> I assume the first one really has a } at the end
13:37:28 <m_fulder> yeah ops I missed it while pasting .. it does have it
13:38:06 <cmccann> ok, if I load your pasted code in GHCi after adding dummy definitions for the missing stuff, both versions are fine
13:38:16 <m_fulder> they are :O
13:38:18 <m_fulder> hmm
13:38:41 <rwbarton> (of course...)
13:40:43 <rwbarton> maybe you somehow screwed up your "instance Monad T"
13:40:51 <m_fulder> no omg I found the error
13:40:55 <m_fulder> was hiding Prelude return -_-
13:41:00 <rwbarton> yes exactly like that
13:41:08 <m_fulder> hehe :P sorry
13:41:10 <zomg> haha, completely by accident I stumble upon the first release of Text.Html... with full support for HTML 3.2!
13:41:55 <m_fulder> perfectly now it compiled without errors .. thanks a lot for your helt rwbarton and cmccann :)
13:42:03 <m_fulder> help *
13:43:09 <cmccann> m_fulder, glad you got it working :P
13:44:14 <tarleb> Hi *.  I'm fiddling with Template Haskell but ran into a problem: I'd like to build an expression along the lines of
13:44:14 <tarleb>     mkFoo "hi"
13:44:14 <tarleb> which then defines a value
13:44:14 <tarleb>     hi = Foo "hi"
13:44:27 <tarleb> is that even possible?
13:45:09 <tarleb> from what I see, TH tries to avoid my variable capture at all costs
13:45:36 <rwbarton> yes, it is possible
13:45:53 <tarleb> that's good news :)
13:46:12 <rwbarton> this is sort of the reverse of variable capture, right
13:46:20 <rwbarton> you want to inject a binding with a specific name
13:46:31 <rwbarton> or do I misunderstand
13:47:09 <tarleb> no, you are right
13:47:33 <tarleb> my current approach was mkFoo foo = [d| foo = Foo s |]
13:47:33 <tarleb>   where s = nameBase foo
13:47:55 <tarleb> that compiles, but doesn't seem to give the right result
13:48:22 <rwbarton> (I don't actually know how to do it off the top of my head)
13:48:29 <rwbarton> But, say, makeLenses from lens does something like this.
13:48:44 <tarleb> k, I will check that out
13:48:47 <tarleb> thanks!
13:49:27 <rwbarton> "[d| foo = Foo s |]" means you have a declaration binding a variable named "foo".
13:49:31 <rwbarton> It doesn't refer to the foo in scope
13:50:24 <tarleb> I tried splicing $(foo) = ..., but that didn't work either
13:50:36 <rwbarton> try [d| $(mkName foo) = Foo $(litE (StringL foo)) |]
13:51:01 <elliott> yeah use mkName
13:51:05 <cmccann> is your problem that you're letting it be helpful with names?
13:51:17 <cmccann> which I think is the point of rwbarton's suggestion anyway
13:51:42 <cmccann> sounds like you want the unhygenic just-give-me-this-name version
13:52:37 <tarleb> That gives me an error: Parse error in pattern: $(mkName foo)
13:53:47 <c_wraith> do you have TemplateHaskell enabled?
13:54:21 <elliott> I don't think you can splice there
13:54:24 <tarleb> I do, both in the file (via language pragma) and in my ghci session
13:54:27 <elliott> I think you have to construct the AST manually
13:54:48 <c_wraith> I thought you could splice patterns..
13:54:54 <tarleb> elliott: I don't understand, why is that?
13:55:53 <elliott> tarleb: who knows. TH is inconvenient
13:56:00 <elliott> I may be wrong
13:56:20 <c_wraith> oh, right.  You can splice a pattern, but not the binding name
13:56:22 <c_wraith> Which is annoying
13:57:05 <tarleb> well, TH most definitely a beast at times
13:57:12 <tarleb> is
13:58:29 <cmccann> elliott, no you're correct, TH is indeed inconvenient
13:58:35 <cmccann> that is a very correct statement
14:00:15 <aninhumer> Hmm, can I indicate in a type synonym that a type could be anything? (because it shouldn't be used)
14:00:50 <aninhumer> I tried forall a. but I got an error that it was a rigid type
14:02:36 <Saizan> aninhumer: i think you'll have to make it a parameter
14:02:54 <aninhumer> Saizan: Yeah, that's what I was hoping to avoid
14:03:14 <Saizan> aninhumer: can you show how this synonym will get used?
14:03:15 <Ngevd> aninhumer, possibly Void from Data.Void
14:05:17 <Saizan> it'd be cool to have implicit params in types, that then get implicitly generalized at each use site (unless otherwise more constrained)
14:05:23 <aninhumer> Saizan: Well, basically I am making a monad purely for syntax reasons, and it would be nice if the last line isn't restricted to being of type m ()
14:05:34 <Ngevd> I've got an idea for an extension to Haskell, but I'm not sure how useful it'd be or who to tell
14:05:35 <sclv> don't do that
14:05:46 <sclv> monads for syntax reasons are horrible
14:06:05 <Saizan> sclv: how are they horrible?
14:06:24 <sclv> because its a damn hack
14:06:38 <sclv> the syntax they buy you is not very important
14:06:46 <sclv> compared to e.g. just tossing <> on the end of each line
14:06:49 <x-SuriV> Hack the planet!
14:06:52 <x-SuriV> hehe :D
14:06:53 <elliott> if you have m () you probably want a monoid instead
14:06:55 <elliott> and can use mconcat
14:07:13 <hpaste> me pasted “record syntax with pipe” at http://hpaste.org/79681
14:07:36 <Saizan> dunno, we do have the Writer monad
14:07:38 <gr8_shampoo> Is it possible to do record syntax but still have a "|" in your data type? Like this, but without throwing lots of errors? http://hpaste.org/79681
14:07:42 <Ngevd> ArbitraryInfix, letting you do something like foo x y = x `(flip bar)` y
14:07:43 <elliott> Writer monad has an actual result though
14:08:17 <Ngevd> gr8_shampoo, keep the | out of the {}'s
14:08:30 <aninhumer> I'm making an EDSL, and intending to try and get non-haskell people to use it
14:08:31 <elliott> gr8_shampoo: data Node = Node {...} | Empty ...
14:08:40 <aninhumer> So the syntax matters more than it usually would
14:08:43 <Saizan> elliott: i guess the determining factor is whether there's a half-decent (>>=)
14:08:48 <gr8_shampoo> Ah. Great. So hard to search for stuff with special characters. We need a programmers google
14:09:00 <elliott> Saizan: you should see blaze-html's monad :(
14:09:15 <elliott> in their (m >>= f) they pass error to f
14:09:23 <Saizan> ugh
14:09:24 <elliott> as in f (error "what's a monad law")
14:09:29 <elliott> for performance!
14:09:56 <Saizan> do they get more performance by being a monad?
14:09:59 <sclv> sothe writer monad is a useful monad
14:10:15 <sclv> as eliott says
14:11:27 <elliott> Saizan: they get nicer syntax because they can use layout
14:11:28 <Saizan> some people complain that Binary shouldn't use a monad for Put
14:11:30 <elliott> html has lots of nesting
14:11:55 <elliott>  this a good argument for layout-based monoid syntax
14:12:14 <mikeplus64> elliott: what would that look like?
14:12:34 <Saizan> i think it's quite fine to have Put as a monad, and don't see the drawback
14:12:56 <Saizan> but if we are talking about stuff that has to lie for (>>) then i can agree
14:13:00 <elliott> mikeplus64: foo { a; b; c } --> a <> b <> c
14:13:04 <Saizan> *for (>>=)
14:13:05 <elliott> for some foo
14:13:08 <elliott> foo {} --> mempty
14:13:27 <mikeplus64> elliott: that's what i'm wondering, what do we call 'foo'?
14:13:38 <Saizan> mon
14:13:39 <elliott> depends on your favourite colour of bikeshed
14:13:44 <elliott> everything is either ugly or clashy
14:13:46 <Ngevd> "foo"
14:13:56 <elliott> this would also negate Saizan's objection to a large degree
14:14:00 <aninhumer> Perhaps we could have a restricted form of the monad syntax for non-monads?
14:14:03 <elliott> since there'd be no reason *not* to use a monoid, and it'd be more accurate
14:14:13 <mikeplus64> do we call it [foo| |]? ;)
14:14:20 <elliott> aninhumer: sure, that's what this would be. overloading "do" for it would be evil, you wouldn't be able to type do { a; b }
14:14:33 <elliott> and stuff can be both a Monoid and a Monad
14:14:42 <Ngevd> Maybe, for instance
14:14:42 <elliott> (as in, Monad m and Monoid (m a)
14:14:43 <elliott> )
14:14:50 <aninhumer> elliott: Ah I didn't read the scrollback, you're already talking about that :P
14:15:21 <cmccann> a layout-y sequence notation similar to do could be useful
14:15:36 <cmccann> to replace the idiom of list literals with each item on another line
14:15:46 <cmccann> drop the superfluous commas and use layout instead!
14:15:49 <elliott> yes
14:15:56 <cmccann> then you'd have your monoid-y do equivalent using mconcat
14:15:58 <elliott> it would also be good for Monad/Set/etc. to a lesser degree
14:16:18 <cmccann> and if you're trying to use do notation for something that isn't even a monoid then fuck you I don't care
14:16:20 <elliott> maybe we'd want foo f in { a; b; c } to be mconcat [f a, f b, f c]
14:16:26 <Saizan> i think it should be more general than Monoid, btw
14:16:27 <elliott> foo Map.singleton in ...
14:16:36 <elliott> Saizan: why? you have foo {} and foo {a;b}
14:16:45 <elliott> and you expect the same things you expect of (<>) in terms of laws
14:16:50 <Saizan> elliott: the type doesn't have to stay the same
14:16:53 <elliott> just from the obviousness of folding in foo blocks etc.
14:17:02 <aninhumer> Is mempty necessary for the syntax?
14:17:06 <elliott> aninhumer: foo {}
14:17:12 <aninhumer> Don't allow it?
14:17:15 <elliott> why not
14:17:20 <cmccann> I suppose you could make foo {} have a monoid constraint
14:17:23 <elliott> if we had a Semigroup superclass then foo {a;b} could be Monoid and foo {} could be Semigroup
14:17:23 <cmccann> and anything else just semigroup
14:17:25 <elliott> er
14:17:28 <elliott> the other way around
14:17:31 <cmccann> elliott yes good plan :P
14:17:37 <elliott> but nobody will ever add a superclass to anything in base ever because of dumb inertia
14:17:39 <mikeplus64> :t do {}
14:17:40 <lambdabot> Empty 'do' block
14:17:43 <elliott> so we have to make compromises
14:17:43 <Saizan> there are semigroupids and all kind of things
14:17:49 <cmccann> elliott, they'll remove superclasses though!
14:18:04 <elliott> cmccann: yes :(
14:18:05 <mikeplus64> > do () -- look at me i'm not a monad at all
14:18:07 <lambdabot>   ()
14:18:26 <elliott> cmccann: we really need someone to go rogue and just add an Applicative superclass already
14:18:30 <Ngevd> @type do ()
14:18:32 <lambdabot> ()
14:18:34 <cmccann> elliott, I nominate you
14:18:39 <aninhumer> mikeplus64: How does that work?
14:18:42 <elliott> cmccann: give me commit access to base and I'll work wonders
14:19:24 <mikeplus64> aninhumer: with only one thing in do notation, do notation is as good as 'id'
14:19:25 <cmccann> I wonder how much of hackage that would even break
14:19:52 <cmccann> the applicative superclass, that is
14:20:02 <cmccann> giving elliott commit access would probably break quite a lot of things
14:20:12 <popl> but would it be fun?
14:20:19 <cmccann> it would be glorious
14:20:50 <mikeplus64> aninhumer: arguably it shouldn't be like that, and it should only accept things :: Monad m => m a, but for whatever reason this is how it is
14:20:58 <eyebloom> What a vinculum over a term mean in a syntax definition? Such as on page 4 of this paper (figure 1):  http://research.microsoft.com/en-us/um/people/simonpj/papers/ext-f/fc-tldi.pdf
14:21:39 <tarleb> just to update on the TH issue: manually composing the declaration worked great
14:21:43 <tarleb> mkFoo foo = return [ValD (VarP (mkName $ foo)) (NormalB (AppE (ConE (mkName "Foo")) (LitE (StringL foo)))) []]
14:22:13 <tarleb> thanks again
14:22:36 <elliott> aninhumer: anyway mempty is "necessary" even if you disallow foo {} because you still get your binry operation from Monoid
14:22:52 <sclv> ?ty do 1
14:22:53 <elliott> if you invent a typeclass that's like Monoid without mempty, then that's just Semigroup. and it's not in base! and you don't inherit all the instances, etc.
14:22:53 <lambdabot> Num a => a
14:22:59 <sclv> ?do 1234
14:22:59 <lambdabot> 1234
14:23:14 <sclv> huh
14:23:29 <cmccann> > do do do do do do ":D"
14:23:31 <lambdabot>   ":D"
14:23:33 <catsbydlo> eyebloom: what's a vinculum?
14:24:23 <eyebloom> A horizontal line above the term.
14:24:24 <popl> catsbydlo: http://en.wikipedia.org/wiki/Vinculum_(symbol)
14:24:28 <popl> oh boy
14:25:22 <catsbydlo> eyebloom: "The notation an (where n ≥ 0) means the sequence a1···an; the “n” may be omitted when it is unimportant."
14:26:24 <aninhumer> elliott: Oh I was thinking Magma, but I guess it does need to be associative at least...
14:26:41 <elliott> a magma typeclass would be pretty terrible
14:26:50 <popl> catsbydlo: A vinculum is used elsewhere; that doesn't cover the rest.
14:26:52 <elliott> overloadings don't make sense when there are just too many possible instances for any given type
14:26:59 <popl> vinculii?
14:27:01 <catsbydlo> popl: where?
14:27:06 <catsbydlo> popl: vincula
14:27:10 <popl> are you high?
14:27:13 <popl> :)
14:27:22 <popl> It's obvious where they are in the figure
14:27:37 <catsbydlo> yes, but they are all instances of the pattern I described
14:28:11 <popl> like in p -> e_2 ?
14:28:18 <eyebloom> So basically it means you can have a term there, multiple terms or no term?
14:28:18 <byorgey> eyebloom: yeah, vinculum(X) means  "list of X"
14:28:24 <catsbydlo> popl: yes
14:28:25 <byorgey> think of it as  [X]
14:28:50 <cmccann> elliott: free magmas are handy though!
14:28:57 <catsbydlo> popl: after a 'case' you can have n patterns, the n is implicit, and the overline sort of macroexpands the list
14:29:10 <eyebloom> byorgey: I see so for example multiple variables in an abstraction.
14:29:24 <popl> OK
14:29:29 <eyebloom> But as n>0 we need at least one.
14:29:32 <byorgey> eyebloom: right.
14:29:46 <eyebloom> Actually it says n>=0
14:29:56 <byorgey> eyebloom: yes, I was about to say that =)
14:30:02 <popl> ah they omit the n when it is unimportant
14:30:15 <byorgey> "omit n when it is unimportant" means "any length"
14:30:23 <byorgey> vinculum(X)^n  means "list of length exactly n"
14:30:27 <catsbydlo> no, it means there won't be a superscript
14:30:40 <catsbydlo> (meta)syntactically, I mean
14:30:40 <byorgey> yes, but in practice that means it can be any length
14:30:45 <popl> it's also confusing because vinculum means something different in boolean algebra and propositional logic
14:30:50 <byorgey> that description is a bit imprecise
14:31:03 <popl> they use propositional logic f urther down
14:31:09 <eyebloom> Thanks for your help.
14:31:27 <catsbydlo> if they put an n there, it would still mean any length
14:31:34 <popl> next page actually
14:31:35 <catsbydlo> it would be a binder for n, I guess?
14:31:43 <byorgey> catsbydlo: oh, I guess you're right
14:32:40 <byorgey> usually an explicit n is used when it gets used multiple times, that is, there are several lists which are constrained to be the same length
14:32:51 <eyebloom> There are some terms where n is defined by another term. In the case of an n-ary type function.
14:33:01 <byorgey> right.
14:33:13 <simon> is there an Integer -> Integer -> Ordering? I'm looking for something like SML's Int.compare
14:33:21 <catsbydlo> :t compare
14:33:22 <lambdabot> Ord a => a -> a -> Ordering
14:33:25 <eyebloom> This is perhaps different in Fc-pro.
14:33:27 <simon> ah, thanks.
14:33:39 <eyebloom> That's what I'm attempting to learn.
14:33:41 <byorgey> eyebloom: it's not
14:33:50 <popl> catsbydlo: sorry I snapped at you
14:34:06 <popl> I am grumpy.
14:34:17 <eyebloom> I see well, I'll cross that bridge when I come to it.
14:34:21 <byorgey> eyebloom: if you want to learn Fc-pro I would actually recommend *not* reading "System F with Type Equality Coercions"
14:34:24 <catsbydlo> it's ok, I gave you a look of strong disapproval in response
14:34:31 <byorgey> it's a deeply confusing paper.
14:34:34 <eyebloom> Why not?
14:34:38 <eyebloom> I see
14:34:38 <popl> catsbydlo: it's just becasuse you're smarter than I am
14:34:52 <catsbydlo> ಠ_ಠ
14:35:18 <byorgey> eyebloom: the presentation of System FC has evolved over the years.  This initial presentation was very confusing.
14:35:33 <eyebloom> What is the best place to learn it?
14:35:38 <byorgey> eyebloom: just read the FC-pro paper, and if you have questions, ask me =)
14:36:39 <eyebloom> You're talking about "Giving Haskell a Promotion" correct?
14:36:58 <byorgey> yes
14:37:20 <popl> it annoys me that I am using Deja Vu Sans Mono and yet cannot see that rendered properly in irssi
14:37:59 <eyebloom> Is Fc-pro simplified by comparison to Fc
14:38:09 <eyebloom> ?
14:38:24 <catsbydlo> I don't think that character is in DejaVu
14:38:54 <catsbydlo> urxvt tells me it's using something called :lang=th
14:39:36 <popl> Maybe. I would to have to check since (although I have Deja Vu set to be default in Firefox) it is rendering in Firefox just fine.
14:40:12 <catsbydlo> firefox just grabs whatever it can if a particular character isn't in the default font
14:40:26 <popl> yeah, probably
14:40:48 <popl> whatever, I guess it's unimportant
14:41:02 <catsbydlo> see also: why <font face=wingdings>J</font> doesn't work in anything but IE
14:41:21 <popl> 😰
14:41:23 <byorgey> eyebloom: it is somewhat simplified, yes, and also extended
14:42:51 <popl> catsbydlo: does that render for you?
14:43:00 <eyebloom> Can you tell me what the principle differences are, just in terms of what is included in the syntax definition? Or are the differences primarily in the typing rules?
14:43:30 <m_fulder> what is the easiest way of converting a String to an Int?
14:44:04 <catsbydlo> catsbydlo: not in tmux/urxvt, no
14:44:09 <catsbydlo> er
14:44:12 <catsbydlo> popl:
14:44:31 * popl eyes popx_ 
14:44:38 <catsbydlo> m_fulder: length
14:44:47 <orospakr> hey, what's the best/most popular approach for integrating tests with cabal? test-framework plugged into cabal's test-suite detailed mode, if that's possible?
14:44:51 <popl> m_fulder: torture
14:45:04 <eyebloom> m_fulder: read "1234"
14:45:09 <catsbydlo> const 5
14:45:10 <popl> m_fulder: watch Homeland
14:45:11 <eyebloom> you
14:45:15 <tromp> const 42
14:45:19 <catsbydlo> ord . head
14:45:25 * cmccann is surprised noone has suggested unsafeCoerce yet
14:45:30 <cmccann> > read "1234"
14:45:32 <lambdabot>   *Exception: Prelude.read: no parse
14:45:34 <cmccann> > read "1234" :: Int
14:45:35 <lambdabot>   1234
14:45:46 <eyebloom> you'll need a type constraint to make it either an int or float.
14:45:53 <m_fulder> catsbydlo .. length returns only the length of the string .. I want the value .. yeah that's it thanks cmccann and eyebloom
14:45:55 <popl> cmccann: I picture big scary men poking someone in the chest "Do it. Do it. Do it."
14:45:59 <Nereid> > reads "1234" :: [(Int,String)]
14:46:01 <lambdabot>   [(1234,"")]
14:46:04 <tromp> :t fromEnum
14:46:05 <lambdabot> Enum a => a -> Int
14:46:09 <Nereid> > reads "1234" :: ReadS Int
14:46:11 <lambdabot>   Couldn't match expected type `Text.ParserCombinators.ReadP.ReadS
14:46:11 <lambdabot>           ...
14:46:14 <Nereid> eh
14:46:23 <Nereid> oops
14:46:38 <cmccann> > (reads :: ReadS Int) "1234"
14:46:40 <lambdabot>   [(1234,"")]
14:46:41 <Nereid> yes that
14:46:53 <popl> m_fulder: You asked to convert a String to an Int. You did not specify which Int
14:46:57 <Nereid> haha
14:47:05 <m_fulder> popl, hehe thats true sorry
14:47:32 <popl> catsbydlo: I've got your back.
14:47:48 <Nereid> > (reads :: ReadS Int) "notanint"
14:47:49 <lambdabot>   []
14:47:51 <eyebloom> byorgey: Can you tell me what the principle differences are, just in terms of what is included in the syntax definition? Or are the differences primarily in the typing rules?
14:48:05 <eyebloom> between Fc and Fc-pro
14:48:15 * mgsloan has reinvented dependency injection
14:48:16 <mgsloan> https://gist.github.com/4361578
14:48:26 <Nereid> > (reads :: ReadS Int) "1234" ^? traverse._1
14:48:29 <lambdabot>   Just 1234
14:48:31 <Nereid> > (reads :: ReadS Int) "moo" ^? traverse._1
14:48:34 <lambdabot>   Nothing
14:48:36 <Nereid> :)
14:49:00 <byorgey> eyebloom: if you look at Figure 1 it actually highlights the diff between FC and FC-pro
14:49:05 <byorgey> at least for the syntax
14:49:38 <byorgey> oh, and Figures 3 and 4
14:49:40 <Nereid> > (reads :: ReadS Int) "1234leftovers"
14:49:42 <lambdabot>   [(1234,"leftovers")]
14:49:45 <Nereid> so yeah.
14:49:53 <eyebloom> byorgey: Aha. Thanks, I'm getting ahead of myself I'm going to keep studying.
14:50:16 <byorgey> eyebloom: the two main things are (1) data constructors can now be used as types, and type constructors as kinds; (2) addition of abstraction forms for kinds (to get kind polymorphism)
14:52:07 <byorgey> eyebloom: as you have more questions feel free to leave a message with lambdabot if I'm not around, and I'll respond when I see it.  Or you can send me email.
14:52:10 <eyebloom> byorgey: I see, that makes sense, I think I need some more foundational knowledge and familiarity, so I'm just trying to get to the point where I can derive types and kinds by hand and looking for any resources that will make that easier.
14:52:36 <byorgey> eyebloom: OK, makes sense.
14:53:15 <byorgey> eyebloom: in that case you may be interested in reading/skimming through Benjamin Pierce's book "Types and Programming Languages" if you haven't looked at it before
14:53:51 <eyebloom> byorgey: I have not, I'll see if I can get a hold of it.
14:53:51 <byorgey> eyebloom: if you want to understand FC or FC-pro I suppose you should really start by understanding System F
14:53:59 <byorgey> which they are based on
14:54:26 <byorgey> and just understanding System F may already give you most of what you are looking for anyway.
14:54:35 <eyebloom> Right, I mostly understand it, but I'd like to see it clearly defined somewhere.
14:54:50 <byorgey> OK, then you want TaPL =)
14:56:01 <eyebloom> Ok, thanks, hopefully I can find it.
14:56:23 <mreh> http://hpaste.org/79682 -- is there anything obviously wrong with this?
14:57:56 <mreh> it's a callback to this spotify library I am using, but to no avail
14:58:37 <byorgey> eyebloom: yeah, I guess it's a bit expensive to buy a new copy.  Do you have access to any sort of university library?
14:58:59 <eyebloom> Not really.
14:59:10 <cmccann> how expensive is "expensive"?
14:59:20 <byorgey> like $60 or so
14:59:37 <byorgey> of course "expensive" is relative.
14:59:49 <Nereid> pretty reasonable for a textbook.
14:59:54 <eyebloom> Last minute christmas gift maybe.
14:59:57 <cmccann> haha, yeah
15:00:15 <byorgey> I got my copy as a Christmas gift =)
15:00:42 <byorgey> it really is a great book
15:01:02 * cmccann has a hardbound copy of "Lambda Calculus, Its Syntax and Semantics" from a used book shop
15:01:34 <cmccann> good luck buying a copy of that for anything like a reasonable price :P
15:02:20 <monochrom> mreh: I think unsafePerformIO is obviously wrong. but if you say, it's just like a global variable, then I would try that NOINLINE trick, but I still haven't thought it through what's going on
15:03:28 <eyebloom> All right you've convinced me. I'm drafting a letter and addressing it to 1 North Pole, we'll see how good I've been.
15:03:37 <cmccann> haha
15:03:49 <monochrom> the postal code is H0H0H0
15:04:52 <eyebloom> I'm imagining the look on a mall Santa's face when a kid tells him he wants "Lambda Calculus, Its Syntax and Semantics"
15:05:03 <cmccann> eyebloom, :D
15:05:39 <cmccann> speaking of which, holy rolling shitballs. the cheapest amazon lists for the hardbound version of that is "used from $516.60".
15:05:57 <cmccann> that's a bit more than I expected
15:06:18 <eyebloom> That's why you need to get Santa in on that deal.
15:06:29 <cmccann> I figure everyone who'd care either has a copy already or has a library with one available though
15:06:47 <mreh> monochrom: maybe I should rewrite the wrapping function to return a pure value then
15:06:50 <hpaste> LucasCampos pasted “RK4” at http://hpaste.org/79683
15:07:36 <mreh> "wrapper" is a pure FFI function I can assume?
15:08:04 * hackagebot tablestorage 0.2.1.0 - Azure Table Storage REST API Wrapper  http://hackage.haskell.org/package/tablestorage-0.2.1.0 (PhilFreeman)
15:08:08 <monochrom> no, I don't think anything about wrapper is pure
15:09:37 <mreh> monochrom: but it's only returning a function pointer, nothing else
15:09:44 <mreh> it's side effect free
15:09:56 <mreh> so I figured the unsafePerformIO would be acceptable
15:10:09 <mreh> one assumes :)
15:10:30 <mreh> it passes the unsafePerformIO test
15:11:24 <Ngevd> Want some fun? Try to install regex-parsec!
15:12:42 <mreh> I have no idea if wrapper is side effect free or not though
15:12:53 <rwbarton> Ngevd: well sure, some packages from 2007 will not work nowadays
15:13:39 <cmccann> I don't think you have to go as far back as 2007 to find non-working packages
15:13:53 <cmccann> two GHC versions back is usually sufficient
15:18:13 <FreeFull> "round x returns the nearest integer to x; the even integer if x is equidistant between two integers" I'm curious about why it does that rather than just returning the greater integer
15:18:31 <monochrom> mreh, there is a malloc or equivalent involved, and there is a hs_free_fun_ptr (if you want to do it from C) or freeHaskellFunPtr (if you want to do it from Haskell) to pair it off. that is why it is in IO
15:18:46 <tgehr> FreeFull: statistical bias, maybe
15:21:26 <monochrom> malloc or equivalent is involved because memory is allocated to store gluing code. there is something about this gluing code that is known only at run time, but I forgot what
15:24:59 <mreh> monochrom: if it's only allocating to empty memory then it doesn't have side effects
15:25:16 <mreh> that could affect the rest of the program
15:25:21 <mreh> semantically
15:26:02 <monochrom> http://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html has an explanation of why round to even. string-search for "round to even"
15:33:59 <orospakr> hum. test-framework or HTF?
15:34:21 <orospakr> I'm leaning towards test-framework
15:45:29 <lippin> Hello! I can't find a logical xor using hoogle. Is there one under a different name or something? Obviously I can implement it but just checking it's not in the library first.
15:46:30 <monochrom> use /= for boolean xor
15:47:01 <Hafydd> > [ b /= c | b <- [True, False], c <- [True, False] ]
15:47:03 <lambdabot>   [False,True,True,False]
15:47:28 <lippin> Ah! How delightful! Thanks
15:47:35 <applicative> Ngevd: https://github.com/michaelt/regex-parsec It is fine if you just scrap the cabal file and use cabal init
15:48:14 <monochrom> "this page is taking way too long to load"
15:48:37 <monochrom> and a pink unicorn
15:50:30 <applicative> yeah i just  noticed ... but now it seems okay
15:51:22 <monochrom> still no go for me. I guess I'm just living too far
15:52:25 <applicative> I'm getting other curiosities from github at the moment; but I'm in Germany
15:53:24 <orospakr> how do I ask cabal to install dependencies required by a test-suite target? cabal install naturally skips over them.
15:54:40 <Ngevd> applicative, right
15:55:23 <applicative> Ngevd: God knows if the package has any merit
15:55:44 <Ngevd> applicative, it was mentioned in regex-base and I got curious
15:57:11 <orospakr> yeah, I'm getting pink unicorns too
15:57:31 <elliott> Upload date	Mon Mar 5 14:55:12 UTC 2007
15:57:34 <elliott> Build failure	ghc-6.10 (log), ghc-6.12 (log), ghc-6.6 (log), ghc-6.8 (log), ghc-7.0 (log)
15:57:39 * elliott would not have much confidence in this package
15:58:00 <Ngevd> applicative, my main problem was I had no idea how to write regeces
15:58:43 <Ngevd> (which I've since worked out)
15:59:06 <Ngevd> But this endeavour has aided me in my quest to get all of Hackage working nicely with eachother
15:59:06 <Noldorin> can anyone recommend a good Haskell book for mathematicians?
15:59:21 <orospakr> huh, I just did "cabal install cabal", but a "cabal" binary did not appear in ~/.cabal/bin
16:00:33 <applicative> orospakr: cabal install cabal-install
16:00:58 <applicative> orospakr: but you should get rid of the new version of the Cabal library maybe
16:01:19 <applicative> you installed the associated lib not the binary
16:01:56 <applicative> Noldorin: this is a good question, I don't know who would best answer it.
16:02:31 <Noldorin> :)
16:02:37 <applicative> there aren't all that many Haskell books
16:02:49 <Noldorin> indeed, so a quick search seemed to show.
16:03:15 <applicative> Noldorin: It might also depend on what interests you about it and so forth
16:03:27 <Noldorin> most seem to focus on the practical aspects of it...
16:04:17 <monochrom> "cabal install cabal-install" will still likely get to the new version of the Cabal library
16:04:19 <Noldorin> applicative, a text that explored algebraic and categorical theoretical constructions in Haskel in particular
16:04:36 <monochrom> possessing two versions of any library will eventually confuse you and the computer
16:04:39 <orospakr> applicative, thanks :)
16:05:39 <Noldorin> perhaps one that included a little on logical/proof systems too.
16:05:40 <monochrom> Q: "but can't they live peacefully?" A: "yes as long as they are never used. one executable cannot host two lib versions"
16:06:25 <applicative> Noldorin: yes, there are any number of beautiful academic and quasi-academic papers on these topics, and e.g. the famous posts of sigfpe but at book length I don't know what to think
16:07:32 <Noldorin> applicative, if you have links/details on these papers and articles, i would still appreciate that.
16:09:24 <catsbydlo> @where futamura
16:09:24 <lambdabot> I know nothing about futamura.
16:09:35 <iFeelStupid> Any materials to read to overcome the problem of not being able to do assignments in Haskell because it cracks me up.
16:09:49 <iFeelStupid> ?
16:10:06 <catsbydlo> what's so funny about it?
16:11:18 <lippin> iFeelStupid: have you read a basic functional programming text?
16:11:28 <iFeelStupid> catsbydlo: I just freaking can't get my head around it, it seems to elude me pervertly
16:11:39 <catsbydlo> do you know any other programming languages?
16:12:30 <iFeelStupid> lippin: Yes, LYAH mostly.
16:12:52 <iFeelStupid> catsbydlo: Of course =)
16:12:58 <catsbydlo> which ones?
16:13:01 <lippin> iFeelStupid: i'm afraid from there it's all experience really
16:13:10 <applicative> Noldorin: here is a rather lame start http://www.haskell.org/haskellwiki/Research_papers/Functional_pearls
16:13:22 <lippin> iFeelStupid: take something you know how do do imperatively and try it functionally
16:13:33 <iFeelStupid> Mainstream ones, JS for example.
16:13:55 <catsbydlo> JS is good
16:13:59 <catsbydlo> do you know Perl and C++?
16:14:06 <catsbydlo> OCaml?
16:15:17 <iFeelStupid> lippin: I recreated multiple algorithms, I mainly can't decide how to approach writing a real software. Lets say I have a "program context". I guess if something changes, I have to recreate this whole with the changed parts?
16:15:30 <applicative> Noldorin: Theorems for Free may amuse http://homepages.inf.ed.ac.uk/wadler/topics/parametricity.html and one or another early paper here http://homepages.inf.ed.ac.uk/wadler/topics/monads.html
16:15:45 <iFeelStupid> catsbydlo: C++, yepp, Ocaml, no.
16:16:01 <catsbydlo> and Perl?
16:16:04 <lippin> iFeelStupid: sort of, yes, but you can use a monad to make that easier and to make passing that state around more implicit
16:16:13 <iFeelStupid> catsbydlo: Not :S. Why is perl important? :D
16:16:29 <catsbydlo> Perl has the notion of (return) type contexts
16:16:32 <lippin> iFeelStupid: but ideally you want to avoid a large program context - each function should only know about exactly the data that's relevant to it
16:16:50 <Noldorin> applicative, thanks. they're definitely going on my reading list.
16:16:58 <catsbydlo> JS gives you asynchronous/callback-based IO
16:17:03 <iFeelStupid> lippin: But how come the io monad and all those monad stuffs wont step on each others toe? I just can't imagine!
16:17:11 <catsbydlo> C++ has fake parametricity via templates
16:17:17 <hiptobecubic> iFeelStupid, imagine writing c++, but every variable is const, and nothing is global or static
16:17:35 <tgehr> that would be a strict language
16:17:49 <lippin> iFeelStupid: because each function is so specialised to a single task, you rarely need to be in more than one monad at once
16:17:52 <hiptobecubic> sure, but you have to start somewhere
16:17:56 <iFeelStupid> catsbydlo: I understand the type sysem (I think), immutability is what bugs me.
16:18:15 <catsbydlo> well, you can just write everything in IO and use mutable variables
16:18:21 <hiptobecubic> gross
16:18:25 <catsbydlo> it works
16:18:26 <lippin> iFeelStupid: just try to write code. you'll find that it doesn't cause problems as you think it would. come back and ask when you find a specific sticking point and we'll show you how to solve it
16:18:45 <iFeelStupid> I don't want that. I want to grok the concepts.
16:19:27 <iFeelStupid> catsbydlo: I mean the IO and mutable variables.
16:20:07 <lippin> iFeelStupid: you need to just try it rather than worrying about it
16:20:28 <tgehr> hiptobecubic: I started by implementing a lazy sorting routine in an imperative language.
16:20:31 <Y_Less> You can't grok anything without playing about with it and making mistakes
16:20:36 <catsbydlo> iFeelStupid: do you know how to convert imperative code to functional code mechanically?
16:21:30 <catsbydlo> like int n = 0; for (int i = 0; i < 10; i++) { int j = i % 2; if (j == 0) { n++; } } return n;
16:21:48 <iFeelStupid> catsbydlo: Yes. I think Y_Less is right, I wanted to start writing idiomatic Haskell code but I think I will just go and write shitty code until it clicks.
16:26:24 <mikeplus64> iFeelStupid: if you use hlint or similar i think you'll start writing idiomatic haskell quite quickly
16:26:39 <mikeplus64> well, syntactically idiomatic
16:26:52 <iFeelStupid> I am more interested in semantics.
16:27:24 <iFeelStupid> But thank you all for the encouragement I will go and get my hands dirty.
16:27:36 <hpaste> NemesisD pasted “Catching multiple exceptions” at http://hpaste.org/79685
16:27:36 <iFeelStupid> l8r
16:27:38 <Y_Less> Have you tried something like "learn you a Haskell for great good"?
16:27:57 <NemesisD> could someone take a look at that paste? i'm trying to figure out the least painful way to catch multiple types of exceptions
16:31:26 <NemesisD> it seems like it can't resolve the Right value of the either to a singular type
16:31:43 <catsbydlo> your type signature makes no sense
16:32:07 <catsbydlo> what are a and b supposed to be?
16:32:57 <NemesisD> actually b should just be a
16:33:53 <NemesisD> it compiles if i remove the typesig on line 6
16:33:55 <NemesisD> im not sure why
16:34:19 <Nereid> because that b should be a
16:34:24 <Nereid> probably
16:35:01 <Nereid> oh
16:35:05 <Nereid> you need ScopedTypeVariables.
16:35:07 <hpaste> NemesisD annotated “Catching multiple exceptions” with “Catching multiple exceptions (annotation)” at http://hpaste.org/79685#a79686
16:35:31 <NemesisD> oh
16:35:35 <hpaste> Nereid annotated “Catching multiple exceptions” with “Catching multiple exceptions (annotation)” at http://hpaste.org/79685#a79687
16:36:00 <Nereid> oops yeah, b should be a.
16:36:20 <NemesisD> Nereid: what is considered a better practice here, to take off the typesig or use ScopedTypeVariables
16:36:45 <Nereid> I don't think the type signature is necessary there.
16:36:57 <Nereid> also, action' = fmap Right action
16:37:14 <NemesisD> Nereid: yeah i was just replacing it with Right <$> action
16:37:20 <Nereid> I'd do that
16:37:42 <NemesisD> Nereid: it looked weird because i was working with someone on this last week and it was in much worse shape, so we were trying to not be clever till we got it working
16:40:00 <applicative> Noldorin: I think if you happen by here at other times, you might get a more fruitful answer, the crowd of mathematically sound aesthetes is different at different times. People on #agda will likely provide a pretty good subset of them.
16:41:14 <Noldorin> applicative, oh, they don't have to be aesthetes; just competent mathematicians and haskellers. thanks for the tip though
16:44:50 <Peaker> @src deleteBy
16:44:50 <lambdabot> deleteBy eq x []        = []
16:44:50 <lambdabot> deleteBy eq x (y:ys)    = if x `eq` y then ys else y : deleteBy eq x ys
16:45:00 <Peaker> deleteBy seems silly
16:45:09 <Peaker> taking both eq and x, only to always apply eq with x
16:45:32 <Peaker> would make more sense to get a pre-applied pred
16:45:39 <hiptobecubic> for consistency with the other *By functions i assume
16:45:41 <Peaker> so it's like filter, but only of the first element
17:12:47 <mreh> can I get cabal to send flags to CPP?
17:13:33 <mreh> I want some kind of top level debug flag
17:13:39 <mreh> across the whole program
17:15:46 <Saizan> i think you can pass -D flags to ghc
17:16:03 <mreh> http://stackoverflow.com/questions/6361846/where-can-i-learn-about-ifdef
17:16:08 <Saizan> oh, iirc in a cabal file there's cpp-options:
17:16:12 <mreh> Saizan, yeah :)
17:17:35 <koltar> tertl3-laptop:  another Gvl Haskell user?
17:18:16 <koltar> i didn't think there were any of us
17:18:26 <beaky> hello
17:18:45 <mreh> hi
17:31:43 <beaky> what's a good haskell style guie
17:31:45 <beaky> guide8
17:31:47 <beaky> guide*
17:33:09 <mreh> beaky, I think there is one on stackoverflow, but I've never really followed one
17:33:27 <mreh> it's fairly standard stuff I think though, 80 columns max per line
17:35:09 <mreh> Camel case... I'll see if I can find it
17:35:14 <dncr> @hoogle (a -> b -> c -> d) -> (a, b, c) -> d
17:35:15 <lambdabot> No results found
17:35:30 <Hermit> beaky: 80 columns max, no tabs, gramatically correct comments, consistent indentation, consistent formatting (choose any style you like and stick to it), avoid too much pointfree style, always add a type signature on top level functions
17:36:15 <Hermit> beaky: I know I'm missing a few things here but that's most of what you need to know
17:36:21 <beaky> ah
17:36:31 <mreh> and put spaces after your tuple commas
17:36:36 <fryguybob> beaky: hlint can be helpful too.
17:36:39 <Hermit> and list commas
17:36:53 <beaky> should I line up my equal signs? :D
17:37:02 <popl> something interesting about irssi's tab-complete here. type c<tab> and you never get to catsbydlo
17:37:05 <Hermit> beaky: and add some doc to complex functions
17:37:05 <mreh> yes :)
17:38:01 <beaky> what do guard clauses desugar to?
17:38:03 <popl> That was off-topic but it happened here first.
17:38:24 <beaky> popl: I got to catsbydlo
17:38:30 <popl> beaky: must be my client
17:38:34 <popl> beaky: thank you for testing
17:38:39 <beaky> he's after Cale :D
17:39:01 <popl> here it goes Cale->confound
17:39:11 <Hermit> beaky: I'd say cases
17:39:15 <popl> I'm not sure the order is preserved though so I don't know if it matters
17:41:44 <beaky> > map (+1) (1, 2)
17:41:46 <lambdabot>   Couldn't match expected type `[b0]' with actual type `(t0, t1)'
17:41:49 <beaky> :(
17:42:04 <mreh> :t map
17:42:06 <lambdabot> (a -> b) -> [a] -> [b]
17:42:20 <mreh> map operates on lists only
17:42:22 <popl> >map (+1) [1,2]
17:42:27 <popl> > map (+1) [1,2]
17:42:29 <lambdabot>   [2,3]
17:42:36 <popl> \o/
17:43:02 * popl gives the list to beaky 
17:43:02 <beaky> @pl showRow row = [f (row, j) | j <- [0..(x - 1)]]
17:43:03 <lambdabot> showRow = return . (<- [0..x - 1]) . (| j) . f . flip (,) j
17:43:16 <beaky> :t (<-)
17:43:17 <lambdabot> parse error on input `<-'
17:43:30 <mreh> <- is sugar
17:43:33 <popl> beaky: do it again
17:43:40 <Hermit> beaky: that's what I mean when I say avoid too much pointfree style, it get's easily out of hand
17:43:42 <mreh> that was mental output from pl
17:43:54 <beaky> hehe
17:44:11 <mreh> obviously it doesn't know about list comprehensions
17:44:15 <beaky> @pl map (f row) [0..(x-1)]
17:44:15 <lambdabot> map (f row) [0..x - 1]
17:44:27 <beaky> @pl showRow row = map (f row) [0..(x-1)]
17:44:27 <lambdabot> showRow = flip map [0..x - 1] . f
17:44:33 <beaky> that works :D
17:44:51 <Hermit> the rule of thumb for pointfree is to craft your own instead of using @pl. If you can construct it and follow it easily, then it's probably ok
17:44:51 <mreh> beaky, you can talk to lambdabot in private if you wish :)
17:44:58 <beaky> right
17:45:39 <beaky> @hoogle [a] -> (a -> b) -> b
17:45:40 <lambdabot> Prelude map :: (a -> b) -> [a] -> [b]
17:45:40 <lambdabot> Data.List map :: (a -> b) -> [a] -> [b]
17:45:40 <lambdabot> Prelude all :: (a -> Bool) -> [a] -> Bool
17:45:46 <beaky> @hoogle [a] -> (a -> b) -> [b]
17:45:46 <lambdabot> Prelude map :: (a -> b) -> [a] -> [b]
17:45:47 <lambdabot> Data.List map :: (a -> b) -> [a] -> [b]
17:45:47 <lambdabot> Control.Parallel.Strategies parMap :: Strategy b -> (a -> b) -> [a] -> [b]
17:45:53 <beaky> :(
17:45:57 <Hermit> beaky: move those queries to lambdabot in private please
17:46:00 <beaky> sorry
17:46:05 <simpson> :t flip map -- beaky
17:46:06 <lambdabot> [a] -> (a -> b) -> [b]
17:46:13 <beaky> ah thanks
17:46:17 <Hermit> unless you wish to denmostrate something for others
17:48:02 <Hermit> demonstrate*
17:48:14 <popl> Hermit: We knew what you meant.
17:48:38 <Hermit> it's just that it bothers me to leave typos alone
17:48:47 <quchen> Is it safe to assume that sugar has "fixity" of -infinity? I'm thinking of :: -> etc.
17:49:00 <popl> Hermit: You don't capitalize or use ending punctuation though.
17:49:07 <popl> !
17:49:11 <Hermit> popl: should I?
17:49:17 <popl> Hermit: Should you?
17:49:53 <popl> I suppose that's not in the same class as a typo but still it is syntactically incorrect.
17:50:35 <simpson> quchen: The fixity and associations for all builtin syntax are in the Report.
17:50:48 <popl> Hermit: As long as you don't abbreviate stuff into nonsense like those people in the SMS commercials then I do not have a single problem with how you type.
17:51:01 <popl> :)
17:51:57 <quchen> simpson: I thought asking here would be easier than scanning the whole report. If there's something weird, people would surely point it out instantly to me. (Also, -> has no fixity, I was asking about the "perceived fixity" or whatever you want to call it)
17:54:12 <popl> quchen: It probably would have been faster to check the report than it would have been to type out your question and the inevitable justification after someone said to rtfm. ;)
17:54:27 <jackss> can someone remind me how to write a function without =, to demonstrate that = is just a syntactic sugar and that all functions take and return one argument?  I'm halfway there.  add x = (\y -> x + y)
17:55:02 <monadicity> you can't do it without =
17:55:06 <simpson> quchen: Well, the truth of it is that I don't have them memorized offhand (and I bet the only regular to know is edwardk.) I just know what feels right and looks right syntactically.
17:55:55 <jackss> oh, must have remember it wron then. is what i typed it then
17:56:11 <popl> Why is edwardk so special?
17:56:25 <Hermit> jackss: at least you could reduce it to   add = (+)
17:56:32 <Hermit> but that's as far as you can get
17:57:00 <mreh> popl: it's a mystery
17:57:04 <Hermit> jackss: and remember the type signature or the MR will kick in
17:57:09 <popl> mreh: :(
17:59:32 <shachaf> jackss: Perhaps you're after add = (\x -> (\y -> x + y))
17:59:45 <shachaf> There's still an =, of course, but that's just to give the expression a name.
17:59:54 <shachaf> (Also, give it an explicit type signature when you do that.)
18:00:07 <popl> I'm sorry for being so ridiculous.
18:00:30 <jackss> shachaf yeah that was it.
18:01:10 <jackss> type would be (Int -> (Int ->Int)), which is the same as Int ->Int -> Int
18:02:06 <jackss> will that compile to the same code?
18:02:11 <jackss> under the hood
18:02:51 <popl> jackss: There is a way for you to find out.
18:03:17 <popl> jackss: sorry for misreading your handle.
18:03:19 <beaky> is case <foo> of the way to pattern match on foo?
18:03:51 <shachaf> jackss: Maybe?
18:03:55 <shachaf> GHC does a lot of trickery.
18:04:06 <shachaf> It probably won't compile the exact same way but it depends on the optimizer.
18:04:20 <shachaf> I think it might be fine in this case.
18:04:42 <kennyd> semantically it's the same though
18:14:33 <jozefg> Hey does anyone have advice for teaching programming to underprivileged kids?
18:14:43 <beaky> is there a strict version of iterate?
18:15:10 <Nisstyre-laptop> jozefg: how old?
18:15:23 <jozefg> 15-18
18:15:42 <Nisstyre-laptop> jozefg: http://htdp.org/
18:16:35 <jmcarthur> beaky: you could just force the result
18:16:54 <jmcarthur> beaky: but if it was itself strict it would not terminate
18:17:06 <jozefg> I considered scheme but I'm worried about the fact that it's just not very easy to do something tangible and rewarding (great language though, I use it and haskell the most)
18:17:13 <jmcarthur> unless you just mean the resulting list is value strict but not spine strict
18:18:09 <Jafet> Use TURBO PASCAL
18:18:16 <jmcarthur> jozefg: are these kids who are interested in learning or who are obligated to learn it?
18:18:19 <Jafet> Do they even have computers
18:19:05 <jozefg> jmcarthur:  They're interested but teniously so. I was leaning towards perl or python.
18:19:18 <jmcarthur> i see
18:19:26 <jmcarthur> i don't think i would try to teach them perl
18:19:29 <jozefg> Jafet: we're loaning out some cheap(ish) netbooks
18:19:37 <jmcarthur> python might be just fine though
18:20:03 <jozefg> problem is I don't know python very well, I definently don't want to give out false information
18:20:23 <Jafet> You probably know python as well as most python programmers
18:20:32 <jmcarthur> there's always things like scratch
18:20:43 <Jafet> Haskell rather sucks for this, or at least gloss sucks, but there is someone teaching it to kids
18:21:09 <Jafet> http://cdsmith.wordpress.com/2011/08/16/haskell-for-kids-week-1/
18:21:35 <dncr> how do I get from (Tree a) to (Tree String)?  a has a show instance.
18:21:45 <Jafet> fmap show
18:21:54 <simpson> dncr: Does Tree have a Functor instance?
18:22:16 <Jafet> By the time you finish writing this function, it will anyway
18:22:17 <dncr> Jafet: I thought so but that makes [String].  I don't get it
18:22:25 <Jafet> :t fmap show
18:22:26 <lambdabot> (Functor f, Show a) => f a -> f String
18:22:32 <dncr> simpson: yes, and a Foldable one
18:22:53 <dncr> hm
18:22:54 <dncr> oh
18:23:01 <dncr> i have a forest
18:23:09 <jmcarthur> jozefg: maybe you could start with something like scratch to explain some of the most basic ideas with an environment where they can get things done quickly, and then move on to a "real" language?
18:23:10 <dncr> thanks.  no puns please
18:23:21 <Jafet> @quote Cale Nature
18:23:21 <lambdabot> Cale says: Does X have the monad-nature?
18:23:27 <Jafet> @quote data.Nature
18:23:27 <lambdabot> Cale says: data Nature = Rock | Stream Nature | Tree Nature Nature
18:23:46 <zomg> Shouldn't that be Particle | Wave
18:23:47 <Jafet> jmcarthur: that's disorienting
18:23:52 <zomg> or have I been misreading my sciences again
18:23:53 <zomg> =)
18:23:57 <Jafet> I wonder if anything came out of eros
18:24:07 <jmcarthur> Jafet: it's not like that had to learn any sort of actual syntax to use scratch anyway
18:24:21 <Nisstyre-laptop> jozefg: maybe try teaching a simple algorithm that has cool results
18:24:26 <Nisstyre-laptop> like a shortest path algorithm
18:24:30 <zomg> jozefg: what's the purpose of this teaching?
18:24:40 <Nisstyre-laptop> you could make up some scaffolding code so it is easier
18:24:42 <zomg> I think that should be a factor in choosing what language you're going to use
18:25:25 <jozefg> zomg: It's a "So you want to learn what programming is like"
18:25:27 <Jafet> Oh, scratch is one of those clicky things
18:25:28 <jozefg> sorta thing
18:25:42 <jozefg> It's not a thing meant to prepare future computer scientists
18:25:48 <zomg> Okay, I wouldn't worry about using a "real" language too much then
18:25:53 <Nisstyre-laptop> jozefg: I would suggest some cool simple math stuff, like fibonnaci, but eh
18:25:56 <zomg> Just use something easy and fun that makes neat looking things
18:25:57 <Nisstyre-laptop> might scare them off
18:26:14 <Nisstyre-laptop> maybe some kind of geometry thing, fractal patterns?
18:26:18 <jozefg> I was leaning to Alice, Scratch, and a little Scheme (sneak in a simple but very cool language)
18:26:20 <Nisstyre-laptop> you could do the cantor set thing
18:26:37 <zomg> I doubt they'll understand "cool"ness about programming languages
18:26:52 <zomg> If it can load cat pictures from the internet
18:26:57 <zomg> Now that would probably go with them quite well
18:26:58 <zomg> =)
18:27:28 <jmcarthur> i think it's perfectly reasonable to try to show the coolness about programming
18:27:33 <zomg> My grandparents bought a telly with youtube, I set up wifi for them to it and showed them cat videos from youtube.. they were really amazed
18:27:36 <zomg> lol
18:27:40 <jmcarthur> there are a lot of people that start, voluntarily, at a very young age
18:27:53 <jozefg> jmcarthur: I know I'm one of them
18:28:00 <jmcarthur> yeah, me too
18:28:22 <beaky> that's one good thign about proramming: it's very accssible
18:28:25 <jmcarthur> i was pretty happy with all text
18:28:27 <zomg> jmcarthur: sure it's a reasonable thing to do but I think it's important to keep in mind whether they will actually find it cool or not which can be hard for an experienced programmer to determine
18:28:49 <jmcarthur> right. i was only responding to your *doubts* that they will understand
18:28:52 <zomg> Yeah :)
18:28:54 <jmcarthur> i think many of them will and many of them won't
18:28:56 <tgehr> I would not concentrate on coolness too much
18:29:02 <jmcarthur> nor would i
18:29:09 <jmcarthur> it's not for everybody
18:29:21 <zomg> Yeah I think biggest factor would be to show them it's not super hard or "mathy" to do something fun
18:29:24 <jmcarthur> and i think it's not productive to try to pretend it is
18:29:42 <tgehr> zomg: it would be better to show them that maths is actually fun
18:29:50 <jmcarthur> i would also not say anything about math like that
18:29:51 <jozefg> It's also worth mentioning that i'm sorta the beta for this community outreach program so I'm not in a position to be selective or be hardcore and just drop people who don't want to work
18:29:54 <zomg> tgehr: you expect too much of them ;)
18:30:03 <zomg> math is fun can come later
18:30:11 <tgehr> zomg: maybe :)
18:30:17 <jmcarthur> zomg: you seem to have little faith in children
18:30:30 <zomg> jozefg: if you can talk with your prospective students beforehand, I think it could be a good thing to do a questionnaire about what they think about programming
18:30:45 <zomg> jmcarthur: I'm pretty sure he mentioned teenagers... I don't have a lot of faith in teenagers :D
18:30:46 <jmcarthur> i don't think one can be a good teacher without expecting good things from your students
18:30:53 <zomg> haha =) yeah I'm just cynical
18:31:04 <jozefg> zomg: Thats a good point, I think I can do that
18:31:20 <zomg> Yeah if you can plan your material based on the results of that then I think it might be good
18:31:20 <jmcarthur> teenagers are great if they are engaged
18:31:29 <zomg> You can address their thoughts and such better
18:31:35 <monadicity> why don't you teach them the halting problem?
18:31:37 <monadicity> you don't need to use computesr for that
18:31:37 <shachaf> jmcarthur: Isn't it a little young to be engaged?
18:31:42 <zomg> jmcarthur: yeah but if you start with "LETS LEARN MATHS!" right away I think it might be a bit hard :)
18:31:44 <jmcarthur> i knew somebody would say that
18:31:52 <jmcarthur> zomg: i would not suggest that
18:32:23 <zomg> Well I'm just 25 and it's not long since I was in that age-group and I can remember pretty well most of the others were pretty hard to get engated in math/programming class :)
18:32:32 <jmcarthur> like i said, this is probably a going to be a mix of people that find they enjoy it and people who find that they don't enjoy it. it's best not to lose either
18:33:14 <Nisstyre-laptop> jozefg: btw, I'm involved in something similar for my university. CS outreach program for teenagers.
18:33:29 <Nisstyre-laptop> jozefg: the prof who is organizing it wants to do a dijkstra's algorithm thing.
18:33:59 <jozefg> Nisstyre-laptop: What do you guys use implementation?
18:34:04 <jmcarthur> zomg: yeah, i'm 27 and also remember that age. i was in a programming class in high school, with several people who were placed in it after their first choices were filled up
18:34:30 <jmcarthur> zomg: i still enjoyed it, and a lot of others enjoyed it, even some who didn't at first want to be in it
18:34:38 <Nisstyre-laptop> jozefg: I don't think he wants to use any real programming language
18:34:46 <jmcarthur> zomg: there were of course a few who quite vocally hated it
18:34:59 <Nisstyre-laptop> jozefg: we've found that they all know various languages and it's hard to teach a new one quickly
18:34:59 <zomg> Yeah what I'm saying is that if you're gonna teach programming to newbies, it's better to focus on actually programming rather than trying to teach a lot of things at the same time :)
18:35:08 <Nisstyre-laptop> jozefg: he implemented the website for it in Haskell though :P
18:35:35 <jozefg> Nisstyre-laptop:  of course :P Though in fairness I've been doing the same, it's kinda fun! Yay arrows
18:35:45 <zomg> The ones who are interested will probably find it cool enough and those who won't won't hate it that much if they can make a program that makes fart noises by a button press
18:35:48 <zomg> :D
18:35:59 <zomg> I'm probably more of a child than they are
18:36:01 <zomg> ha.
18:36:13 <zomg> for even coming up with a suggestion about a fart button that is.
18:36:34 <Jayrays> if I could've done something like that in gradeschool for math, I probably would've enjoyed it a whole lot more :P
18:37:05 <zomg> Yeah I know a lot of the people here are more of the "proper" computer science variant as far as I can tell
18:37:16 <jrajav> Those who cannot appreciate the magic of a fart button have lost their humanity.
18:37:18 <Jayrays> math classes in public schools are booooooring, and I've yet to see someone come up with a unique concept for teaching math to children
18:37:22 <zomg> but I'm more on the doing practical stuff side, so my opinion tends to go into that direction about teaching as well :)
18:37:27 <Jayrays> I've been waiting for the TEDtalk on it for years now
18:37:52 <Nisstyre-laptop> Jayrays: agreed. I had ONE decent math class in all of my public school education, and the guy was a former radio astronomer/programmer
18:38:09 <zomg> Biggest issue I ever had in math class was none of it seemed practical in any way whatsoever
18:38:13 <jmcarthur> i think vihart has roughly the right approach for math
18:38:20 <Jayrays> ^
18:38:23 <Jayrays> she's awesome :D
18:38:29 <Nisstyre-laptop> zomg: biggest issue I had was condescending teachers and terrible teaching
18:38:39 <zomg> Nisstyre-laptop: that could've been a factor in my perception as well
18:39:38 <zomg> Many of my peers shared my opinion as well, so at least here it would seem that if teachers were able to show the practicality of things better, or even things like talk about what sort of careers would use such knowledge
18:39:43 <zomg> might help.
18:40:11 <sw2wolf> :t curry
18:40:12 <lambdabot> ((a, b) -> c) -> a -> b -> c
18:40:24 <`^_^v> what if your view of how practical math is grew as a result of getting older
18:40:30 <jozefg> I always found that the cookie cutter method of schools kinda blows if your at all above or below the norm
18:40:36 <zomg> I still don't view math very practical
18:40:45 <jmcarthur> even apart from her interesting style and entertaining quirks, vihart teaches from several *angles* at once, attaching all kinds of seemingly disjoint areas of mathematics to make a point about one thing, and that makes it very engaging and interesting, even if there are only a couple specific areas of math that you actually like
18:40:47 <zomg> Only thing I've actually needed was trig and geometry
18:40:47 <Nisstyre-laptop> zomg: it's not so much the "how is this practical?" question for me, it's the "why is this interesting?" question
18:41:04 <zomg> Nisstyre-laptop: yeah I think that's kind of related in some ways
18:41:07 <Nisstyre-laptop> factoring 2nd degree polynomials != interesting for me
18:41:27 <jmcarthur> zomg: please watch a few vihart videos if you think math is about being practical
18:41:30 <jrajav> Yeah, tell me when you find a teenager that asks "how is this practical?"
18:41:31 <zomg> It was all just numbers and processing numbers into different numbers
18:41:39 <zomg> That was not very interesting always
18:41:41 <jmcarthur> jrajav: i've known several
18:41:55 <jrajav> I meant that it's more often "why is this interesting?"
18:42:05 <jrajav> Which is just as good for teaching purposes
18:42:12 <zomg> jmcarthur: I don't think it is which is why I haven't really learned it so well ever =)
18:42:19 <jmcarthur> jrajav: they've always meant it as in "why are they making us learn this?"
18:42:22 <Nisstyre-laptop> the problem is that the math they teach was outdated in 1790
18:42:38 <zomg> Most of my later math learning on my own was because I wanted to do 2D game stuff and such, so obviously I needed to learn trigonometry and geometry
18:42:44 <jrajav> jmcarthur: Ha, good point
18:42:45 <zomg> most of which I had forgotten by that point
18:43:18 <jrajav> zomg: Linear algebra might help too
18:43:34 <zomg> yeah I did study some vector stuff as well
18:43:50 <jmcarthur> i've always had minor interests in some math, but the haskell community has really opened my eyes to how fun a lot of it can be, areas that i would have never thought interesting before
18:44:08 <zomg> Yes it seems I must learn category theory at some point now
18:44:09 <zomg> lol
18:44:20 <jmcarthur> i still don't think i would want to make math my life, but i definitely wish i had taken some more maths in uni
18:44:36 <zomg> Even peeking at the page on wikipedia makes me cringe because none of it makes any sense
18:44:44 <jmcarthur> wikipedia makes me cringe anyway
18:44:44 <jrajav> jmcarthur: No you don't
18:44:50 <jmcarthur> jrajav: yes i do
18:44:54 <zomg> At least the page doesn't have much math symbols
18:44:58 <jmcarthur> there were some great math teachers there
18:45:01 <zomg> which I was never taught in school (didn't go to uni or such)
18:45:06 <jrajav> jmcarthur: Lots of math profs at uni teaching undergrad are downright poisonous
18:45:20 <jrajav> jmcarthur: You want to learn university-level math; there are better ways to do it
18:45:24 <jmcarthur> i don't know that i would say that if i had gone to a different uni
18:45:49 <zomg> I tried learning some stuff off khan academy but sort of got sidetracked
18:45:50 <jmcarthur> but i liked most of the math profs where i went. they kept it interesting, but still pretty dense
18:45:52 <zomg> Seemed alright though
18:46:03 <jmcarthur> it was a good style of teaching for me
18:46:04 <zomg> This was for the machine learning course MIT had for free
18:46:25 <jozefg> I should take more stats... why did my highschool teacher make it suck so hard
18:46:37 <jrajav> You probably had a better school than mine. At mine undergrad math classes were basically "go to the library and study like a monk or get out; we're not helping you and we're aiming for 80% dropout"
18:46:43 <jmcarthur> despite everything i just said, stats was the worst
18:46:49 <jmcarthur> ew
18:46:59 <jmcarthur> my teachers were always happy to help individuals
18:47:18 <Nisstyre-laptop> jmcarthur: lots of people have trouble with stats
18:47:28 <jmcarthur> i hated my uni's CS program, but the math department was overall pretty good, and engineering was too
18:47:31 <Nisstyre-laptop> I think it's because humans make all sorts of statistical fallacies easily
18:47:42 <jmcarthur> too bad i wanted to switch to cs and already had so many credits there
18:48:25 <jmcarthur> Nisstyre-laptop: i think that particular class was just presented in the most boring possible way, for me
18:48:49 <jmcarthur> Nisstyre-laptop: i still actually like stats and probability. fascinated by it sometimes, even
18:49:11 <jmcarthur> people are quite biased
18:50:07 <t7> > zipWith (\w h -> (h + w * succ h) == w + (h + w * h)) [5..10] [10..15]
18:50:08 <lambdabot>   [True,True,True,True,True,True]
18:51:19 <jmcarthur> @check \w h -> (h + w * succ h) == w + (h + w * h)
18:51:21 <lambdabot>   Not in scope: `myquickcheck'
18:51:30 <jmcarthur> broke!
18:51:45 <Nisstyre-laptop> jmcarthur: the base rate fallacy is probably the least recognized yet most common one
18:52:22 <jmcarthur> Nisstyre-laptop: i've been reading Thinking, Fast and Slow. there are tons of unrecognized biases ;)
18:53:02 <Nisstyre-laptop> jmcarthur: yeah I got a textbook on inductive logic by a philosophy professor
18:53:38 <Nisstyre-laptop> covers the philosophical problem of induction at the end
18:53:47 <jmcarthur> that sounds quite different from what i'm talking about, although related i guess
18:53:59 <Nisstyre-laptop> jmcarthur: well most of it is statistics and probability
18:54:05 <jmcarthur> ah, okay
18:54:05 <Nisstyre-laptop> the authors is a bayesian
18:54:08 <Nisstyre-laptop> *author
18:54:19 <t7> i need to prove this :( (h + w * suc h) ≡ w + (h + w * h)
18:54:34 <jmcarthur> i have no opinion on that debate which i am aware of :)
18:54:56 <jmcarthur> Nisstyre-laptop: is there a quick litmus test to determine whether i'm a bayesian?
18:55:23 <Nisstyre-laptop> jmcarthur: bayesian epistemology means that you think knowledge can be viewed through bayesian statistics, i.e. "degrees of belief"
18:55:44 <tgehr> t7: context?
18:55:47 <cmccann> in my experience bayesian statistics seems to appeal to the same sort of people who would use haskell because of correctness and think free theorems are the best thing ever
18:56:16 <simpson> t7: (h + w * (h + 1)) = (h + w * h + w * 1) = (h + w * h + w)
18:57:24 <t7> its 3 in the morning my brain hurts :(
18:57:25 <Nisstyre-laptop> cmccann: it appeals to me because it seems more cohesive and cleaner than frequentist approaches
18:57:30 <jmcarthur> Nisstyre-laptop: i guess i'm a bayesian, and in fact it sounds like everybody i work with are, too
18:57:41 <Nisstyre-laptop> jmcarthur: a lot of people are, e.g. Nate Silver
18:57:48 <cmccann> Nisstyre-laptop, exactly
18:57:51 <jmcarthur> we are always speaking in concrete terms of how confident we are in something
18:58:07 <jmcarthur> Nisstyre-laptop: he came to speak at my company!
18:59:15 <cmccann> from what I gather frequentist approaches lean more toward the "whatever works" ad-hoc collection of tools that aren't necessarily orthogonal or consistent with each other
18:59:30 <jmcarthur> it sounds like i'm getting a biased for of frequentists
18:59:34 <jmcarthur> *biased view of
19:00:00 <Nisstyre-laptop> jmcarthur: you are
19:00:47 <jmcarthur> are the two sides in fundamental opposition?
19:00:56 <cmccann> frequentist approaches have a lot of practical utility, I don't think anyone disputes that
19:01:44 <cmccann> jmcarthur, philosophically moreso than theoretically, is my impression
19:02:24 <jmcarthur> so it would not be heretical if the two views are intentially, explicitly used together?
19:02:32 <jozefg> On a somewhat random note... I may use Google's programming language, Go
19:02:32 <jmcarthur> s/heretical/contradictory/
19:02:48 <jmcarthur> jozefg: that seems like a weird choice to me. why use it?
19:03:12 <jmcarthur> *intentionally
19:03:30 <jrajav> Why not? It seems worth a try at least
19:04:12 <startling> jmcarthur: I don't think it makes sense to use them together
19:04:16 <jmcarthur> Go seems to be at a weird location on the axis of low-level to high-level for beginners, to me, is all
19:04:18 <cmccann> jmcarthur, it's not like bayes' law isn't objectively correct, it's more about starting assumptions
19:05:31 <jmcarthur> startling: so then you would say that bayesians and frequentists are basically in different fields?
19:05:32 <Nisstyre-laptop> cmccann: and that's why it captures scientific knowledge
19:05:52 <Nisstyre-laptop> cmccann: because science = tentative conjectures with various supporting observations (bayes nets)
19:06:14 <Nisstyre-laptop> well, part of science
19:06:25 <cmccann> yes, though you still have the problem of where your prior distributions come from
19:06:41 <cmccann> how to weight the inherent plausibility of conjectures &c.
19:07:02 <jmcarthur> i've always understood the differences between the two, but never really the consequences of the different assumptions or, obviously, whether they were incompatible
19:07:51 <cmccann> I don't see why they'd be inherently incompatible, it's just that the philosophical assumptions of each imply that much of what the other does is nonsense or unfounded :P
19:08:24 <jmcarthur> i see
19:09:04 <cmccann> it strikes me as kinda like arguing over the axiom of choice
19:09:05 <jmcarthur> alright, so i'm pretty sure i am opinion in at least two ways about math
19:09:11 <jmcarthur> ah
19:09:13 <jmcarthur> three :)
19:09:30 <jmcarthur> *opinionated
19:09:38 <Jafet> The Axiom of Choice is clearly the axiom of choice.
19:11:31 <cmccann> jmcarthur, at any rate, like I said earlier I suspect you'll find a distinct bayesian bias around here, from what I've seen of who it appeals to
19:11:53 <jmcarthur> the axiom of choice is true or it is not true
19:12:05 <cmccann> nah, it's not untrue
19:12:10 <cmccann> totally different
19:12:10 <jmcarthur> lol
19:12:38 <Nisstyre-laptop> axioms aren't true or false -_-
19:12:42 <jmcarthur> the axiom of choice is not true or it is not not true
19:12:47 <jmcarthur> Nisstyre-laptop: (i know)
19:12:49 <cmccann> Nisstyre-laptop, the platonists would disagree
19:12:50 <Nisstyre-laptop> well, actually they're "true"
19:12:54 <Jafet> @quote not-not-math
19:12:54 <lambdabot> ddarius says: Attempting to join #not-not-math sent me to #math.  Freakin' Boole.
19:13:00 <jmcarthur> Nisstyre-laptop: they are true by definition
19:13:05 <Nisstyre-laptop> yeah
19:13:11 <startling> Nisstyre: I can prove any axiom true!
19:13:19 <jmcarthur> lol
19:13:20 * cmccann was pondering dual-intuitionistic logic the other day
19:13:33 <Jafet> Only your proof that the axiom is true is true.
19:13:51 <jmcarthur> Jafet: that axiom is true
19:14:57 <cmccann> it's very strange to work with a logic where (a || not a) is always true, but (a && not a) is not always false
19:15:15 <hpaste> afgho pasted “IO readFile” at http://hpaste.org/79691
19:15:28 <startling> cmccann: weird
19:15:49 <cmccann> you also get double negation elimination, but not double negation introduction
19:16:21 <afgho> i don't understand why i get "  Couldn't match expected type `WS.WebSockets WS.Hybi00 t0' with actual type `IO String'   In the return type of a call of `readFile'
19:16:27 <startling> isn't that standard in intuitionistic logics?
19:16:35 <cmccann> other way around.
19:16:43 <startling> oh, right, heh
19:17:02 <cmccann> it's called "dual intuitionistic logic" for a reason :P
19:17:13 <jmcarthur> huh
19:17:26 <Jafet> That ain't nothing to worry about.
19:17:55 <Peaker> Are there any automatic relationships between Binary and Storable?
19:18:25 <cmccann> so you end up with a situation where double negation is a stronger notion of truth than un-negated
19:18:31 <Peaker> or Serialize?
19:18:32 <startling> Peaker: not iirc
19:18:40 <cmccann> but I think you can still embed classical logic via double-negation translation
19:18:45 <cmccann> very peculiar
19:19:04 <Peaker> It should be possible to derive both Binary and Storable from the same declaration
19:19:43 <jozefg> jmcarthur: I know it quite well, syntax is very small and orthagonal, and it's easy to write webstuff/concurrent stuff
19:19:45 <startling> Peaker: yeah. :/
19:20:13 <startling> cmccann: that's interesting. do you need to assume the axiom of choice to embed classical logic?
19:20:14 <jmcarthur> jozefg: i do not know it well, so i will not try to belabor the point
19:20:43 <cmccann> startling, I don't see why that would enter into it at all
19:20:45 <jmcarthur> the most exposure i've had to Go was a candidate i was interviewing choosing to use it to answer questions
19:20:46 <jozefg> jmcarthur: It's an odd choice, but I think that at a certain point it's really not gonna make a huge difference
19:20:52 <jmcarthur> and he had to explain a lot to me
19:21:03 <cmccann> the double-negation encoding is essentially identical to the one you'd use with intuitionistic logic
19:21:13 <cmccann> though with a few things inverted
19:21:13 <startling> cmccann: oh okay
19:21:26 <jozefg> It's different in very superficial ways, it's very similar to C underneath the syntax (with OO)
19:21:27 <startling> cmccann: so by classical, you don't mean not-intuitionistic
19:21:43 <cmccann> I mean classical logic in the usual sense
19:21:58 <jmcarthur> jozefg: yeah, that's the bit that i find weird for a beginner language. it's a low level language that sells itself as a high level languages
19:22:00 <jmcarthur> *language
19:22:01 <cmccann> where "a || not a" is always true and "a && not a" is always false
19:22:21 <startling> cmccann: excuse the double negative, heh
19:22:45 <cmccann> best to be careful with double-negation in context here, yeah :P
19:23:14 <jozefg> jmcarthur: Yeah... I've found it's kinda like python to be honest. But I really like the static typing, Im hoping that'll lead to a little bit easier to catch type errors pre-runtime
19:28:00 <cmccann> startling, you also have a dualized equivalent of implication... sort of an assertion that something excludes the possibility of the other thing
19:28:22 <startling> cmccann: neat
19:28:41 <cmccann> and "not A" is equivalent to saying "A excludes the possibility of True"
19:29:51 <cmccann> I could probably encode all of this in Haskell with a bit of boilerplate
19:29:57 <cmccann> but it would be clumsy to use
19:30:23 <Nisstyre-laptop> cmccann: fundeps?
19:30:37 <cmccann> no, without any type-level junk at all
19:30:46 <cmccann> something similar to my linear logic encoding, actually
19:33:04 <cmccann> and I kinda doubt anyone but me really cares much about this stuff heh
19:33:41 <tgehr> I consider it interesting
19:34:10 <shachaf> lens 3.7 had newtype Indexed i a b = Indexed { withIndex :: (i -> a) -> b }
19:34:15 <shachaf> Can you believe how terrible that is?
19:34:45 <shachaf> 3.8 will have newtype Indexed i a b = Indexed { runIndexed :: i -> a -> b }
19:35:26 <cmccann> tgehr, were you around for any of my long digressions about linear logic? :D
19:35:44 <tgehr> unfortunately no :D
19:35:49 <cmccann> shachaf, well that's almost the same thing, right? just remove some parentheses, big deal.
19:36:46 <shachaf> cmccann: I know, right?
19:36:54 <cmccann> tgehr, my toy encoding of linear logic is here: http://hpaste.org/75222
19:36:56 <shachaf> -> ought to be associative, anyway.
19:37:06 <tgehr> cmccann: thx
19:37:17 <cmccann> dunno if you're familiar with it at all but I have at least a few comments explaining things
19:37:24 <cmccann> shachaf, and commutative!
19:37:28 <cmccann> that would make things much easier.
19:37:55 <shachaf> cmccann: And idempotent!
19:38:01 <shachaf> (+) :: (->) {Int}
19:39:53 <zomg> Text.HTML or blaze-html for html combinators? Blaze seems nice and used by many other libs too, couldn't even find any decent examples for text.html
19:40:07 <zomg> Writing some stuff but need to learn to use it first...
19:40:07 <zomg> :D
19:40:27 <sclv> blaze is newer and everyone uses it these days
19:40:41 <zomg> Okay, that's what I thought :)
19:44:57 <otters> @pl \a b -> a:a:b
19:44:58 <lambdabot> liftM2 (.) (:) (:)
19:47:59 <jmcarthur> wha-
19:48:20 <jmcarthur> that is one of the weirdest-looking @pl results i've seen in a while
19:48:51 <jmcarthur> i see how it works, it's just... it seems like there might be some pattern lurking under that one that could be worth exploring
19:49:18 <jmcarthur> > liftM2 (.) f g a b
19:49:19 <lambdabot>   Ambiguous type variable `a0' in the constraints:
19:49:20 <lambdabot>    (GHC.Show.Show a0)
19:49:20 <lambdabot>     ...
19:49:29 <jmcarthur> > liftM2 (.) f g a b :: Expr
19:49:31 <lambdabot>   Ambiguous type variable `a0' in the constraints:
19:49:31 <lambdabot>    (GHC.Show.Show a0)
19:49:31 <lambdabot>     ...
19:50:54 <jmcarthur> :t liftA2 (Prelude..) -- a neat looking type, at least
19:50:55 <lambdabot> Applicative f => f (b -> c) -> f (a -> b) -> f (a -> c)
19:51:47 <jmcarthur> i see, it's not that interesting after all
19:51:50 <jmcarthur> :t join (.)
19:51:51 <lambdabot> (b -> b) -> b -> b
19:51:53 <jmcarthur> :t join $ liftA2 (.)
19:51:55 <lambdabot> Applicative f => f (b -> b) -> f (b -> b)
19:54:00 <beaky> is haskell turing complte?
19:55:02 <ezyang> Yes.
19:55:03 <Jafet> What do you think we are, a charity?
19:55:04 <cmccann> only if you can run it on a machine with unbounded amounts of memory
19:55:28 <zomg> beaky: brainfuck is turing complete and it has 8 possible commands =)
19:55:29 <shachaf> A tougher question is whether C is Turing complete.
19:55:48 <jmcarthur> zomg: the original brainfuck has a pretty strick limit on the amount of memory it has
19:55:52 <jmcarthur> *strict
19:56:02 <tgehr> zomg: that is not particularly impressing though. one instruction suffices
19:56:04 <Jafet> cmccann: that's why we have cloud haskell
19:56:08 <zomg> tgehr: hehe =)
19:56:24 <zomg> Yeah I admit I did not extensively study Brainfuck
19:56:32 <zomg> I did implement some really simple calculator in it though
19:56:35 <cmccann> pf, just ι is enough for me
19:56:35 <zomg> and even that was years ago
19:56:38 <zomg> such madness.
19:57:23 <jozefg> I have a friend who wrote an entires semesters worth of hw in brainfuck
19:57:24 <shachaf> cmccann: As if one Unicode codepoint would ever be enough for you.
19:57:32 <cmccann> good point.
19:58:02 <jozefg> :t join
19:58:03 <lambdabot> Monad m => m (m a) -> m a
19:58:38 <zomg> Can't spell monad without mad
19:58:46 <cmccann> monads and strife
19:58:51 * flebron likes to use join and not bind when explaining monads :p
19:59:17 <monadicity> join is called multiplication in category theory
19:59:26 <jozefg> How are you supposed to say ">>" in english?
19:59:35 <monadicity> then
19:59:37 <cmccann> jozefg, I think "then" is popular
19:59:39 <beaky> then
19:59:52 <jozefg> I'm picking up a general trend towards then haha
20:00:01 <beaky> does >> mean anything special outside the IO monad?
20:00:09 <cmccann> it means the same thing in every monad
20:00:11 <beaky> oh
20:00:17 <cmccann> @src (>>)
20:00:17 <lambdabot> m >> k      = m >>= \_ -> k
20:00:27 <zomg> I used to be an imperative programmer but >> I took -> to the knee
20:00:47 <beaky> now you use do notation :D
20:00:50 <Nisstyre-laptop> zomg: you took a type operator to the knee?
20:00:54 <Nisstyre-laptop> >.>
20:00:54 <zomg> Nisstyre-laptop: sshh
20:00:55 <cmccann> zomg, ಠ_ಠ
20:00:59 <Jafet> I used to hate mudcrabs like you
20:01:01 <beaky> what's a type operator?
20:01:01 <Nisstyre-laptop> zomg: I'm actually playing Skyrim atm
20:01:16 <zomg> I didn't even play Skyrim, and I found the arrow to the knee meme extremely annoying
20:01:19 <zomg> :D
20:01:30 <Nisstyre-laptop> zomg: they really don't say it that often in the game
20:01:38 <zomg> Yeah figured as much :D
20:01:39 <flebron> it's just the guards and who talks to the guards
20:02:15 <Nisstyre-laptop> the Riften guards say it the most often I find
20:02:19 <zomg> Jafet: what's a mudcrab
20:02:20 <zomg> :P
20:02:25 <tgehr> http://www.urbandictionary.com/define.php?term=Mudcrab
20:02:26 <flebron> well i guess monadplus talks to guards
20:02:45 <zomg> lol
20:02:50 <tgehr> :P
20:03:01 <zomg> "Can't wait to mudcrab some hotties this weekend."
20:03:04 <zomg> That just sounds wrong.
20:03:28 <tgehr> I think he used the second interpretation
20:04:45 <flebron> and when the girl runs you can shout "You can't fast travel with enemies nearby"
20:05:21 <Nisstyre-laptop> and then maybe "You must gather your party before venturing forth"
20:05:57 <zomg> tgehr: well yeah but it wasn't as nearly as funny as the first one
20:06:30 <Skillsob> So guys, what's happening in #haskell today?
20:06:37 <zomg> darnit why did all my haskell beginner helpers fade out for xmas holidays or something...
20:06:53 <zomg> trying to write beginner haskell material is sort of tricky if you don't know if it's actually easy to understand or not =)
20:07:03 <cmccann> well that's easy
20:07:04 <cmccann> it's not
20:07:08 <cmccann> mystery solved!
20:07:23 * cmccann is not helpful
20:07:24 <zomg> harr de har har =)
20:08:08 <zomg> I've written lots of technical material related to other languages, but those are easy because people are familiar with the mechanics of imperative programming
20:08:09 <flebron> well it depends on background
20:08:27 <flebron> in uni we teach it as the first programming language, solely not to confuse kids with state
20:08:38 <flebron> (and for the math-prone ones, with statements like "x = x+1")
20:08:46 <Skillsob> You want to write Haskell beginner material? Well shit; better learn category theory!
20:08:53 <zomg> I'm sort of targeting web developers with past experience in other languages so I guess they are tainted already making it a bit trickier =)
20:09:10 <zomg> Skillsob: lol I just said earlier today that it looks like I'm going to have to learn category theory...
20:09:11 <flebron> "i tried writing <?haskell but it didn't run"
20:09:20 <cmccann> fortunately or unfortunately everything related to web dev tends to be pretty terrible
20:09:26 <cmccann> so at least their standards will be low to start with
20:09:29 <zomg> flebron: I think there's something called Haskell Server Pages which lets you do something like that... :D
20:09:35 <flebron> :(((((((((
20:10:04 <zomg> cmccann: I think most web devs who would actually be interested in learning haskell would at least be the better ones ;)
20:10:24 <tgehr> flebron: I once taught my father some things about programming. He found Haskell more accessible than the imperative stuff.
20:10:26 <zomg> this coming from a PHP programmer \o/
20:10:33 <cmccann> zomg, which means they probably hate the stuff they work with currently, so that's a plus
20:10:34 <Skillsob> Do you guys have a good resource to recommend about category theory like a good book?
20:10:36 <Nisstyre-laptop> flebron: they offer Haskell as an optional intro here as well...although most people take either Python or Java.
20:10:39 <zomg> and just like that I ruined all my credibility.
20:10:40 <zomg> BAM.
20:10:50 <Nisstyre-laptop> but 90% of the grad students and profs use Haskell afaik
20:11:16 <Skillsob> I'm sort of interested. I mean, I love sorting out what's what. Strictly strongly typed languages are the only way I can cope with programming.
20:11:30 <flebron> we teach them first specification (i.e. "know what you want to solve"), then haskell ("write what you want to do, not how"), then a basic subset of c++ ("prove correctness of your loops with invariants")
20:12:04 <cmccann> Skillsob, Awodey's book on category theory is often recommended when people ask, if memory serves me
20:12:05 <tgehr> At my university the introductory course uses Eiffel
20:12:07 <flebron> honestly we would teach them python except there's more algorithmic magic in python
20:12:33 <cmccann> tgehr, that's the language that prides itself on being OO and emphasizing correctness that completely screwed up subtype variance, right?
20:12:42 <flebron> (and when i say haskell, i mean haskell without any sort of higher order functions)
20:12:44 * cmccann really cannot take eiffel seriously because of that
20:12:50 <tgehr> cmccann: exactly :)
20:12:58 <zomg> I wish people would pay me to just learn new stuff
20:13:01 <zomg> Now that would be awesome
20:13:09 <flebron> academia may be for you
20:13:20 <cmccann> zomg, isn't that basically SPJ's job description?
20:13:27 <zomg> Possibly
20:13:28 <Jafet> Academia is where they pay you to delegate work to grad students.
20:13:57 <zomg> In order to be even considered for any position like that I'd probably need a better degree
20:13:58 <Skillsob> At the uni I go to they used to use Haskell in like the early 2000s. Now they use an imperative subset of Java, and then later Java. I really liked it.
20:14:00 <zomg> :P
20:14:24 <tgehr> cmccann: there is now also a language called 'Modern Eiffel'
20:14:29 <cmccann> oh boy
20:14:34 <tgehr> cmccann: that one is type safe
20:14:41 <cmccann> that's an improvement at least
20:15:21 <tgehr> I have not looked into it in detail, but it seems to include a theorem prover
20:16:11 <flebron> i'd get into agda if i liked emacs
20:16:32 <tgehr> what do you like instead?
20:16:58 <flebron> currently? sublime text 2
20:17:11 <flebron> i've never been much for keyboard shortcuts to do everything :p
20:17:35 <Jafet> But, emacs lets you type out everything in longhand too.
20:17:38 <tgehr> all the commands are named in emacs
20:18:17 <Younos> editors are always very personal choices
20:18:24 <Nisstyre-laptop> flebron: so you don't use xmonad?
20:18:38 <flebron> i tried to install xmonad in os x, massive failure
20:18:41 <Jafet> Does xmonad work on Mac OS?
20:18:54 <flebron> "sort of, no"
20:19:15 <popl> The only thing academia teaches you to learn is how to game academia to advance. :P
20:19:25 <flebron> i'll buy a linux box soon enough and there will be xmonad aplenty
20:27:17 <jrajav> Jafet: https://github.com/xmonad/osxmonad
20:28:01 <m4n14c> hello world
20:30:32 <Hermit> is there a way to list from the ghci repl _just the definition_ of a typeclass without listing all the instances too?
20:30:51 <Hermit> (trying to reduce the flood)
20:32:48 <simpson> I always go to the Haddocks if I want that. Maybe there's a way to do it, but I don't know it. Which typeclass?
20:33:11 <Hermit> Enum for example, it has a ton of instances
20:33:17 <Hermit> I just want to see the methods
20:33:18 <cmccann> Hermit, typing ":i Eq" is always fun
20:33:34 <Hermit> cmccann: that's exactly what's bothering me
20:33:52 * cmccann doesn't know a solution, sorry
20:34:27 <simpson> http://hackage.haskell.org/packages/archive/base/latest/doc/html/Prelude.html#t:Enum
20:34:45 * simpson goes to Hoogle, types in the typeclass name, and gets a link to the docs
20:35:51 <Hermit> I need to make a local haddock repo
20:37:56 <startling> Hermit: iirc some people have something like lambdabot's @src in their ghci
20:38:50 <Hermit> startling: that would help quite a lot
20:39:02 * Hermit googles for that
20:39:38 <simpson> @src Category
20:39:38 <lambdabot> Source not found.
20:39:40 <simpson> :c
20:39:49 <startling> Hermit: looks like http://www.haskell.org/haskellwiki/GHC/GHCi#GHCi_on_Acid would be useful
20:41:10 <prsteele> :t (>>=)
20:41:11 <lambdabot> Monad m => m a -> (a -> m b) -> m b
20:42:12 <Hermit> startling: installing. This looks promising
20:42:16 <Hermit> :D
20:43:03 <Hermit> Browsing typeclasses when there's a lot of instances for C types is really annoying, specially on a small screen
20:46:20 <tgehr> a partial fix appears to be to buy a larger screen
20:48:59 <hpaste> Peaker pasted “Almost there” at http://hpaste.org/79693
20:52:12 <Hermit> tgehr: I have one, 24", but the issue here is that I'm not always working on that machine
20:52:54 <Hermit> and the other is a 10" netbook...
20:53:39 <flebron> @pl \f -> \x -> f x
20:53:39 <lambdabot> id
20:54:09 <flebron> I was expecting $
20:54:23 <cmccann> what's the difference?
20:54:34 <simpson> Kindedness?
20:54:42 <cmccann> @pl ($)
20:54:42 <lambdabot> id
21:02:11 <Rileld> Hi, I'm trying to install optparse-applicative. Cabal errors during the install though
21:02:20 <Rileld> [ 8 of 13] Compiling Options.Applicative.Builder ( Options/Applicative/Builder.hs, dist/build/Options/Applicative/Builder.o )
21:02:23 <Rileld> Options/Applicative/Builder.hs:77:34: Module `Data.Monoid' does not export `(<>)'
21:02:26 <Rileld> cabal: Error: some packages failed to install:
21:02:29 <Rileld> optparse-applicative-0.5.0 failed during the building phase. The exception
21:02:31 <Rileld> was:
21:02:34 <Rileld> ExitFailure 1
21:03:03 <orzo> Is there a way to copy a user's cabal configuration and packages for read-only use by another user on linux?
21:03:26 <orzo> i tried linking the .cabal to the other users
21:03:58 <popl> orzo: what do you mean?
21:04:54 <orzo> i mean, me and a friend have been working on a project togetehr, and its become apparent that we will occasionally want ot use the other's computer
21:05:14 <orzo> now our computers are all set up with all the packages required to build our project, but a new user account sees none of it
21:05:43 <orzo> i was hoping i could just symlink the .cabal directory over to the new user account and itd be usable
21:06:10 <popl> My ~/.cabal/config is already 0644
21:06:33 <orzo> so what
21:06:37 <orzo> that doesnt mean it will actually work
21:06:44 <orzo> ghc says the packages are not installed
21:06:55 <orzo> cabal list --installed agrees
21:07:07 <orzo> even though its all linked up and has read permisions
21:07:30 <popl> I didn't suggest cabal would work between users just because of that.
21:08:00 <orzo> well there are a lot of packages i dont want to re-install
21:08:18 <orzo> how do i avoid it
21:09:54 <rwbarton> symlink .ghc not .cabal
21:10:03 <rwbarton> (also this sounds like a fairly terrible idea, good luck)
21:10:04 <orzo> ill try that
21:10:17 <rwbarton> the new user won't be able to install anything then
21:10:29 <rwbarton> alternatively, you can try setting GHC_PACKAGE_PATH for the new user
21:10:55 <popl> YOu would also need to put your .cabal/bin in other-user's PATH
21:11:10 <popl> *You
21:11:34 <orzo> symlinking ghc did what i needed
21:11:43 <rwbarton> I guess you could also just symlink the individual directories under ~/.ghc/ghc-whatever-whatever/
21:11:59 <rwbarton> .../package.conf.d/
21:12:03 <orzo> its just a quick way to try something with the other perosns setup
21:12:15 <popl> seems hacky
21:12:46 <rwbarton> how about HOME=/home/otherguy :P
21:13:35 <orzo> its odd, we are using the same ghc, and compiling works for me, but he gets ghc trying to load template-haskell-2.7.0.0 twice and getting symbol errors
21:14:31 <hpaste> orzo pasted “weird linker errors” at http://hpaste.org/79694
21:15:34 <popl> orzo: is this error before or after linking .ghc to the other users home directory?
21:15:41 <orzo> before
21:15:43 <orzo> and after
21:16:07 <orzo> i mean, he was getting the error, i couldnt get hte error on his computer without doing the linkup
21:16:16 <orzo> but the linkup has obviously nothing to do with it as its the same thing he was seeing
21:16:21 <orzo> with a normal setup
21:16:51 <orzo> i notice he has quickcheck 2.5 but i have an earlier version, 2.4.2
21:16:57 <orzo> maybe that's the issue
21:17:06 <popl> could be
21:17:23 <popl> you're doing something weird so I bet the behavior is undefined. :)
21:17:37 <rwbarton> "template-haskell-2.8.0.0/ghc-7.4.1" is not a good thing
21:17:47 <rwbarton> ghc 7.4 comes with template-haskell-2.7.0.0
21:18:01 <rwbarton> he should uninstall template-haskell-2.8.0.0 and everything that depends on it
21:18:57 <orzo> okay
21:19:56 <rwbarton> (then maybe try to reinstall it with --constraint="template-haskell ==2.7.0.0")
21:21:34 <rwbarton> er, s/it/them/
21:22:08 <hpaste> Rileld pasted “errors installing optparse-applicative” at http://hpaste.org/79695
21:22:35 <johnw> hmm
21:22:45 <johnw> which version of GHC are you using?
21:23:10 <Rileld> Thanks for any help getting optparse-applicative to work :)
21:23:23 <johnw> Rileld: my question was to you
21:23:35 <Rileld> johnw: 7.0.4
21:23:47 <johnw> Rileld: then optparse-applicative is not compatible with 7.0.4
21:23:54 <johnw> you'll have to download the source, and change the uses of <> to mappend
21:24:24 <orzo> rwbarton: thanks, that resolved his issue
21:24:50 <Rileld> johnw: where should I put the source so that I can import it properly?
21:24:59 <rwbarton> orzo: for any package that is displayed in the top section of "ghc-pkg list", you should avoid installing any other version of that package
21:25:14 <rwbarton> really, you should avoid installing multiple versions of the same package in general, but particularly for those packages
21:25:39 <rwbarton> unfortunately, cabal seems to not always enforce this, even when it really needs to be enforced as in the case of template-haskell
21:25:51 <popl> rwbarton: what about Cabal?
21:25:58 <johnw> Rileld: just git clone it, edit the source, and then 'cabal install' within that directory
21:26:14 <rwbarton> popl: well, that one hasn't been causing any problems for me...
21:26:21 <popl> ok
21:26:39 <Rileld> johnw: thanks, I'll try that
21:27:59 <rwbarton> that's actually the one package I have both a global and user version of
21:28:49 <popl> rwbarton: ditto
21:29:12 <popl> rwbarton: I have multiple versions of some user packages, though.
21:38:13 * hackagebot http-conduit 1.8.5.2 - HTTP client package with conduit interface and HTTPS support.  http://hackage.haskell.org/package/http-conduit-1.8.5.2 (MichaelSnoyman)
21:42:58 <lolcathost> @hoogle stToIO
21:42:58 <lambdabot> Control.Monad.ST.Lazy stToIO :: ST RealWorld a -> IO a
21:42:59 <lambdabot> Control.Monad.ST stToIO :: ST RealWorld a -> IO a
21:42:59 <lambdabot> Control.Monad.ST unsafeSTToIO :: ST s a -> IO a
21:45:54 <dmwit> > 0.17*60
21:45:56 <lambdabot>   10.200000000000001
21:46:49 <kennyd> is there no generic flag for printf, that would just call show on any passed object?
21:47:10 <drdo> I can't figure out how to use Diagrams, can someone suggest another library in the same space?
21:48:01 <orospakr> hey, is it possible to have quicktest2 print input and output from a given property? right now, as far as I can tell, one's test expression and expected results are together in a single expression, never giving the harness an opportunity to see the output of the thing under test.
21:48:30 <lottylo> Conundrum: how can I see if two lists are equal to each other, disregarding the order of values in them? the values are Eq, but not Ordered
21:48:33 <dmwit> kennyd: Can't you just use %s and call show yourself?
21:50:09 <kennyd> dmwit sure, but it would be convenient to have one. it would also prevent runtime errors if you forgot show
21:50:40 <dmwit> Yeah, it would be convenient.
21:50:45 <rwbarton> it's actually not possible to implement that with the way printf works
21:50:56 <dmwit> Probably can't do it in H98, though -- you'd have to have some overlapping instances.
21:51:14 <cmccann> it'd probably fall over even with overlaps
21:51:15 <dmwit> err, and possibly even incoherent instances
21:51:18 <Jafet> oleg has something for that
21:51:19 <cmccann> too much ambiguity
21:51:25 <dmwit> which is a pretty good sign that you shouldn't do it at all
21:52:32 <Jafet> Ok, it may not be applicable here
21:54:08 <Jafet> @pl \a b -> ((&&) `on` null) (a \\ b) (b \\ a)
21:54:08 <lambdabot> (line 1, column 29):
21:54:08 <lambdabot> unexpected "\\"
21:54:08 <lambdabot> expecting variable, "(", operator or ")"
21:54:26 <Jafet> @pl \a b -> ((&&) `on` null) (a `wat` b) (b `wat` a)
21:54:26 <lambdabot> ap (ap . (((&&) `on` null) .) . wat) (flip wat)
21:55:28 <Jafet> @pl \a b -> ((&&) `on` (null . uncurry wat)) (a, b) (b, a)
21:55:28 <lambdabot> ap (ap . (((&&) `on` (null . uncurry wat)) .) . (,)) (flip (,))
22:03:40 <johnw> how do I install a fully static executable using 'cabal'?
22:03:54 <ezyang> cabal install?
22:04:04 <johnw> ah, I guess it's -optl-static -optl-pthread
22:04:16 <ezyang> ah, that's what you mean :_0
23:26:33 <johnw> wow, quiet tonight
23:26:59 <jackss> what functions should I look up to create a worker thread that builds a mutable Map and a printing thread that is continuously printing info from it?
23:28:06 <johnw> 'stm' library, or look up newMVar
23:28:35 <johnw> the other possibility is to use a Chan
23:28:42 <johnw> and post a description of Map changes to the channel
23:28:51 <johnw> that way, you know exactly when to print and what happened
23:31:20 <jackss_> I thought STM is about performance and keeping all the processors busy rather than IO. or is it appropriate for IO too?
23:32:33 <johnw> stm is about concurrency, which means it's about IO
23:38:25 <jackss_> thanks. btw which of the three is usually prefered for what I'm doing?
23:51:27 <johnw> i really couldn't say
23:51:37 <johnw> an MVar is the most basic
