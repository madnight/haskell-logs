00:01:27 <latermuse> how can I repeat an IO command X amount of times, then return them as a list of X length?
00:01:47 <osfameron> replicateM ?
00:01:49 <shachaf> @ty replicateM
00:01:50 <lambdabot> Monad m => Int -> m a -> m [a]
00:01:58 <latermuse> nice! :)
00:01:59 <latermuse> thanks
00:02:07 <shachaf> @hoogle Int -> m a -> m [a]
00:02:08 <lambdabot> Control.Monad replicateM :: Monad m => Int -> m a -> m [a]
00:02:08 <lambdabot> Test.QuickCheck.Gen vectorOf :: Int -> Gen a -> Gen [a]
00:02:08 <lambdabot> Test.QuickCheck vectorOf :: Int -> Gen a -> Gen [a]
00:02:11 <shachaf> latermuse: For future reference.
00:02:25 <latermuse> got it!, thanks shachaf
00:02:30 <statusfailed> also, www.haskell.org/hoogle/
00:04:08 <shachaf> @where cpr
00:04:08 <lambdabot> I know nothing about cpr.
00:04:11 <shachaf> @where+ cpr http://research.microsoft.com/en-us/um/people/simonpj/Papers/cpr/index.htm
00:04:12 <lambdabot> Good to know.
00:04:16 <shachaf> "doing my part"
00:16:45 <shachaf> What's the difference between a singleton unboxed tuple and the value in it?
00:18:21 <pqmodn> how do you construct a singleton tuple?
00:18:50 <pqmodn> :t (1)
00:18:51 <lambdabot> Num a => a
00:19:10 <shachaf> (# x #)
00:19:22 <shachaf> @ty (# 'a' #)
00:19:23 <lambdabot> (# Char #)
00:19:34 <pqmodn> that seems strange!
00:21:01 <neutrino> :kind (a, b)
00:21:08 <shachaf> Apparently it has different strictness.
00:21:14 <shachaf> I'm not sure how, though.
00:22:06 <neutrino> @kind (,)
00:22:08 <lambdabot> * -> * -> *
00:22:24 <pqmodn> > (# 'a' #) :: Char ~ (# Char #)
00:22:25 <lambdabot>   Kind mis-match
00:22:25 <lambdabot>  The left argument of the equality predicate had kind `*',
00:22:25 <lambdabot>  ...
00:23:41 <pqmodn> the other has kind (#). didn't realize primitives had a different kind
00:23:55 <shachaf> Well, they have to.
00:24:41 <pqmodn> why's that?
00:25:46 <shachaf> How do you pass an Int# to id?
00:26:23 <Kosta> Cool. My attoparsec laze logline parser is eating loglines at nearly 100% CPU and constant 4.3MB real memory
00:27:02 <shachaf> Great!
00:27:08 <shachaf> Now see if you can get it to 120% CPU
00:27:34 <Kosta> Let me first do some map/reducing. then my goal is 800% :)
00:27:43 <pqmodn> ah, http://www.haskell.org/ghc/docs/7.0.1/html/users_guide/primitives.html "there are some restrictions on the use of primitive types"
00:29:02 <Kosta> hmmm.... but it's taking rather long...
00:29:18 <pqmodn> Kosta: perhaps it's not actually parsing anything?
00:29:43 <Kosta> no it works fine on 100 log lines. and on millions, stream to stdout
00:30:10 <Kosta> but I wanted to see how long it takes to show 1 million log lines and pipe that to /dev/null
00:30:56 <pqmodn> Kosta: perhaps of interest: http://www.catonmat.net/blog/unix-utilities-pipe-viewer/
00:32:11 <Kosta> cool!
00:33:44 <Kosta> Never knew of it. But I do love `pv`
00:33:54 <Kosta> so I'm parsing log files at 6 MB/s :)
00:34:56 <Nereid> pv looks handy, thanks!
00:35:19 <pqmodn> no prob!
00:37:32 <newcumer> hello everybody
00:37:42 <newcumer> I'm a new cumer.
00:37:46 <Desert> Hi
00:37:48 <Desert> Me too
00:39:18 <newcumer> where u fm
00:40:24 <Desert> China
00:40:34 <newcumer> 哈哈
00:40:36 <newcumer> 我也是呀
00:40:38 <latermuse> 中国的什么地方？
00:40:41 <Desert> = =
00:40:45 <latermuse> haha
00:40:45 <newcumer> 囧
00:40:48 <newcumer> 果然任何时候
00:40:53 <Desert> 当然是现在大家都在睡觉了
00:40:57 <newcumer> 任何地方都会被攻占
00:41:01 <Desert> = =
00:41:07 <Desert> tryhaskell
00:41:08 <latermuse> 你们是什么地方的人
00:41:10 <newcumer> 学弟们好！
00:41:12 <Desert> 非常有意思啊
00:41:26 <Desert> Liaoning
00:41:42 <latermuse> 我在哈尔滨，这边死冷的
00:41:53 <charliesome> 你好
00:42:18 <Desert> = =你们是为什么去tryhaskell的？
00:42:42 <shachaf> There should be a channel for this.
00:42:56 <latermuse> or a lambdabot translation module
00:43:37 <latermuse> its not fair to speak in chinese in here because not everyone speaks chinese
00:43:50 <charliesome> #haskell 不喜欢汉语
00:45:27 <latermuse> im porting a huge project built in php to haskell, and the php coders were absolutely retarded in every possible way
00:45:45 <latermuse> so tiring
00:46:12 <charliesome> i have never actually seen good php
00:46:15 <Kosta> PHP is a very bad language, it's easy to do very stupid things there
00:46:30 <charliesome> despite what the php community says about "bad coders will write bad code in any language, it's not a php problem"
00:46:52 <charliesome> how is php even a language
00:47:02 <Nereid> well maybe that's what attracts them to php ;)
00:47:03 <simpson> Very carefully.
00:47:10 <latermuse> I understand php, and did a few projects in it myself. But the project that I am porting is the toilet of php.
00:47:18 <shachaf> PHP is off-topic in here.
00:47:38 <charliesome> let's talk about how bad haskell is instead
00:47:38 * latermuse nods
00:48:07 <latermuse> charliesome: I hate having to rewrite a bunch of haskell code because I want to change some modules around half-way through a project.
00:48:28 <charliesome> haskell is pretty good for the most part
00:48:41 <charliesome> one of the things that REALLY shits me is that you can't do circular imports
00:49:34 <Nereid> you can... sort of...
00:49:36 <Nereid> http://www.haskell.org/haskellwiki/Mutually_recursive_modules
00:50:58 <charliesome> sort of annoying though
00:53:25 <Taneb> Things that annoy me about Haskell:
00:53:40 <Taneb> - emacs acting not how I like it with if-then-elses
00:53:49 * hackagebot parallel-io 0.3.2.2 - Combinators for executing IO actions in parallel on a thread pool.  http://hackage.haskell.org/package/parallel-io-0.3.2.2 (MaxBolingbroke)
00:53:51 <latermuse> taneb: that sounds like an emacs problem
00:53:55 <Taneb> - Something to do with GADTs that I forget
00:54:18 <shachaf> Sounds like an emacs issue to me.
00:54:44 <Taneb> - Haddock docs are lacking when type families are about
00:55:34 <Taneb> - GADTs does not imply KindSignatures
00:56:22 <Kosta> I have a list of [Maybe a], I want to convert that to [a] throwing away the Nothings
00:56:31 <shachaf> @ty catMaybes
00:56:32 <lambdabot> [Maybe a] -> [a]
00:56:37 <shachaf> @hoogle [Maybe a] -> [a]
00:56:37 <lambdabot> Data.Maybe catMaybes :: [Maybe a] -> [a]
00:56:37 <lambdabot> Data.Maybe maybeToList :: Maybe a -> [a]
00:56:37 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
00:56:43 <shachaf> Kosta: Hoogle is your friend!
00:56:47 <companion_cube> :t sequence
00:56:48 <lambdabot> Monad m => [m a] -> m [a]
00:56:54 <shachaf> sequence doesn't do what you want.
00:56:59 <Kosta> shachaf: Thanks!
00:57:01 <shachaf> (And its type is different from what you asked for, so it's OK.)
00:57:02 <companion_cube> ok, didn't see the difference
00:57:30 <Iceland_jack> Sometimes [ a | Just a <- as ] is clearer
00:57:32 <fmap> :t \xs -> [x | Just x <- xs]
00:57:33 <lambdabot> [Maybe t] -> [t]
00:57:37 <Iceland_jack> but yes, catMaybes
00:58:21 <companion_cube> wow, this partial pattern matching works
00:58:23 <shachaf> @src catMaybes
00:58:23 <lambdabot> catMaybes ls = [x | Just x <- ls]
00:58:38 <Iceland_jack> companion_cube: partial pattern matching?
00:58:42 <pqmodn> companion_cube: fail "pattern match fail" :: [Int] == []
00:58:57 <companion_cube> well, Just x <- xs is not exhaustive
00:59:06 <Iceland_jack> companion_cube: read what pqmodn said
00:59:11 <companion_cube> yes, ok
00:59:13 <Iceland_jack> “fail” in lists is []
00:59:51 <companion_cube> I just did not know that a matching failure in a list comprehension would call the monad's fail
01:00:13 <Iceland_jack> Well now you do, and knowing is half the battle
01:00:15 <Taneb> I love it when I get crazy error messages when I'm messing about
01:00:28 <shachaf> companion_cube: It's evil, isn't it?
01:00:34 <shachaf> companion_cube: In Haskell 1.4 it used MonadZero instead.
01:00:51 <companion_cube> sounds better, but works in less situations
01:01:43 <Iceland_jack> > sum [ 1 | Nothing <- [Nothing, Nothing, Just 0, Nothing] ] -- Number of Nothings
01:01:43 <lambdabot>   mueval: recoverEncode: invalid argument (invalid character)
01:01:49 <Iceland_jack> hm
01:02:10 <Iceland_jack> > sum [ 1 | Nothing <- [Nothing, Nothing, Just 0, Nothing] ]
01:02:12 <lambdabot>   3
01:02:46 <lolcathost> Are monads with fail actual monads?
01:04:31 <Taneb> How can you set fixity in GHCI?
01:05:45 <statusfailed> lolcathost: you mean category-theory wise?
01:07:32 <`ramses> lolcathost: I think the fail mechanism should be viewed as a haskellism to be able to deal with pattern match failures, which is orthogonal to the monadic character. It is there to support haskell syntax
01:07:42 <Kosta> Ok, I have the following problem: I have a [Either String LogLine]. I want to (hPutStrLn stderr) all Lefts and keep on processing all Rights. I would like to end put with [LogLine], but if I simply map them, I actually end up with [IO LogLine]
01:07:45 <Kosta> any ideas?
01:08:43 <`ramses> Kosta: mapM?
01:09:41 <`ramses> you'll end up in IO anyway though
01:10:14 <pqmodn> Kosta: you can't "escape" IO, if your function does IO it must have an IO type. you can instead make a function that returns ([String], [LogLine]) and delegate the IO to the caller, though
01:11:14 <pqmodn> or, if you can live with IO [LogLine], there are ways to convert to it from [IO LogLine]
01:12:07 <Kosta> pqmodn: I want to process a stream of [LogLine]. Would IO [LogLine] require to evaluate all LogLines?
01:13:14 <pqmodn> Kosta: i'm fuzzy on where IO is strict or lazy, sorry.
01:13:37 <Kosta> well, I could try
01:13:47 <c_wraith> IO is generally strict, in that sense.
01:14:03 <c_wraith> Only a few things aren't, and they're all implemented in terms of unsafeInterleaveIO
01:14:17 <c_wraith> sadly, several of the few non-strict things are in the Prelude
01:14:20 <Kosta> Well, I can try. How would I convert [IO a] to IO [a]?
01:14:33 <c_wraith> :t sequence
01:14:35 <lambdabot> Monad m => [m a] -> m [a]
01:14:41 <c_wraith> sequence is definitely strict, though
01:14:54 <c_wraith> (for IO, anyway)
01:17:09 <`ramses> or instead of mapping and then sequencing, use mapM to do it in one go
01:25:11 <nlogax> I have these very repetitive handlers in an IRC bot.. https://github.com/nlogax/norby/blob/master/src/Commands.hs#L34
01:25:40 <nlogax> Any suggestions for how to clean it up? Can't quite see how to factor out the identical parts
01:43:50 * hackagebot yesod-fay 0.1.1 - Utilities for using the Fay Haskell-to-JS compiler with Yesod.  http://hackage.haskell.org/package/yesod-fay-0.1.1 (MichaelSnoyman)
01:48:02 <bitonic> can’t you start by factoring out ``isPrefixOf` last ps' and `nn `elem` admins' etc.?
01:48:05 <bitonic> nlogax:
01:49:13 <bitonic> nlogax: and also `liftIO (pointFree msg) >>= replyTo msg'
01:53:50 * hackagebot linear 0.4.2.1 - Linear Algebra  http://hackage.haskell.org/package/linear-0.4.2.1 (EdwardKmett)
02:21:43 <Kosta> great, now I have a stack overflow... :(
02:22:16 <Peaker> Kosta, you can try to add ghc stack traces
02:24:28 <Kosta> I think I know where that happens
02:24:37 <Kosta> But I don't know how to avoid that
02:25:09 <Kosta> I'll take a break and do it differently :)
02:29:35 <beaky> hello
02:32:18 <fmap> Kosta: if you have small reproducible stack overflow example it's perfectly fine to hpaste it here
02:33:51 <Kosta> nonono I hate code I wrote anyway
02:34:01 <fmap> okay
02:34:02 <Kosta> it's almost PHP ugly ;)
02:36:30 <beaky> In other languages, if you want to achieve modularity, safety, and speed, you can only have two of them at once. In haskell, you can have all of them :D
02:37:25 <Zetetic> [[Citation needed]]
02:37:42 <t3eblinder> beaky: And as in other languages, you have to work hard to achieve modularity, safety, and speed.
02:37:43 <beaky> cite: personal experience :D
02:37:44 <neutrino> [[Controversial]]
02:38:41 <latermuse> beaky: what did haskell sacrifice in order to achieve modularity, safety, and speed?
02:38:48 <latermuse> ease-of-use?
02:39:01 <latermuse> readability?
02:39:13 <beaky> it is simply a better language
02:39:48 <beaky> ... or am I mistaken and that even in haskell you must sacrifice one to get the other two too?
02:40:34 <liyang> You must sacrifice a virgin and two goats.
02:40:43 <latermuse> You said that languages should chose two of "modularity, safety, and speed". You then say that haskell has all three. If haskell does indeed have all three, then what did it sacrifice to achieve that?
02:40:52 <Zetetic> liyang: can the virgin be one of the goats?
02:41:11 <beaky> well, haskell makes you not need to sacrifice anything :D
02:41:12 <t3eblinder> To be sure, I recommend to sacrifice two virgins.
02:41:22 <liyang> Zetetic: I usually take that to mean a human. You can try a goat I suppose, I'm not sure what you'll get.
02:41:35 <beaky> haskell achieves safety, modularity, and speed through functional programming :D
02:41:39 <tdammers> haskell sacrifices pragmatism
02:41:58 <latermuse> beaky: then wouldnt all functional programming languages have saftey modularity and speed?
02:42:27 <beaky> right
02:42:29 <tdammers> much of the safety comes from the typing discipline and purity
02:42:39 <tdammers> most functional languages don't do these as extremely as haskell does
02:42:44 <merijn> latermuse: Only the pure ones (i.e. almost none of them)
02:42:55 <beaky> and the lazy ones
02:43:07 <tdammers> I don't think laziness makes haskell any safer
02:43:11 <latermuse> So all pure and lazy functional languages have safety, modularity, and speed?
02:43:11 <beaky> oh
02:43:32 <tdammers> latermuse: you also need non-optional strict static typing
02:44:14 <liyang> This is a silly discussion. Just sayin'.
02:45:44 <beaky> because the language is purely-functional, a sufficiently-smart compiler can produce code that is efficient and screaming fast
02:45:57 <merijn> beaky: Nonsense
02:46:12 <merijn> Unless by sufficiently smart you mean "super human intelligence smart"
02:46:59 <Iceland_jack> just putting beaky on ignore wasn't enough..
02:50:14 <yitz> tdammers: what kind of pragmatism do you think that haskell sacrifices? it's in use in practice for a wide swath of high-performance applications in industry now.
02:51:49 <arfy> do people here have experience using wxHaskell? what's it like to code for wx in haskell?
02:54:15 <nlogax> bitonic: Yes that works.. :) small wins. It's mostly `msg → when (stuff); _ → return ()` everywhere that bothers me
02:54:19 <yitz> tdammers: i wouldn't call it "discipline". it's consistency and predictability, which result in flexibility. other functional languages require extreme discipline to achieve that kind of flexiblity in large systems without collapsing under the weight of bugs.
02:54:29 <bitonic> nlogax: nice arrows!
02:55:10 <nlogax> bitonic: {-# LANGUAGE UnicodeSyntax #-} :D
02:55:36 <bitonic> nlogax: I personally don’t like that so much, but it is pretty
02:56:03 <apfel> hi there, can someone take a look, i don't know what hugs want from me ...
02:56:04 <hpaste> apfel pasted “substituteTest” at http://hpaste.org/78838
02:56:38 <liyang> arfy: exactly the same as C, possibly more painful. Gtk is somewhat better in Haskell versus C.
02:57:05 <liyang> apfel: Hugs wants you to leave its rotting corpse alone.
02:57:47 <yitz> latermuse: haskell sacrificed sticking to the imperative programming paradigm, which had been in use almost universally until recently.
02:57:57 <fmap> apfel: you probably meant `(x:y:xs)' not `(x,y:xs)'
02:58:06 <fmap> and yeah, what liyang said
02:58:42 <b_jonas> I should try this new fancy ghc version
02:58:46 <b_jonas> 7.6.1
02:59:29 <apfel> fmap: thanks it working
02:59:35 <liyang> apfel: are you sure you don't mean [Char] -> [Char]?
03:00:38 <apfel> liyang: yes thats right, i meant [Char] or String that was another mistake
03:01:11 <apfel> okay ... only [Char] :D
03:02:25 <mno|it> Hi
03:05:05 <yitz> arfy: i haven't used wx but i did a little gtk programming a few years ago. building the basic gui structure felt pretty much the same - not better or worse. it was nice being able to write the business logic in haskell, though.
03:06:57 <yitz> arfy: if you want to be daring, you could try something like reactive-banana, which is FRP built on top of wx. that would probably feel very different than conventional wx programming.
03:06:58 <peteriserins> what's a neat way to express f 1 ++ f 2 ++ f 3 ++ f 4 ++ …?
03:06:59 <yitz> peteriserins: sum . map f
03:06:59 <shachaf> concatMap f [1..]
03:07:00 <yitz> peteriserins: no, what shachaf said
03:07:00 <peteriserins> cheers
03:07:02 <arfy> yitz: Yeah, doing the processing in haskell looks nice, I've looked at the language a few years ago, but didn't really write anything in it, want to change that now.
03:07:03 <hpaste> liyang annotated “substituteTest” with “substituteTest (annotation)” at http://hpaste.org/78838#a78839
03:08:07 <apfel> is there a function "toString" to convert a char to a String?
03:09:11 <shachaf> There are lots of ways of converting a Char to a String. Which one do you have in mind?
03:09:17 <b_jonas> apfel: the smiley operator
03:09:22 <b_jonas> (:[])
03:09:25 <Iceland_jack> :[9
03:09:26 <Iceland_jack> *[]
03:09:29 <b_jonas> ugly smiley
03:09:44 <b_jonas> a bit scary it looks like, but it works
03:09:51 <Iceland_jack> > (:[]) 'a'
03:09:52 <lambdabot>   "a"
03:09:53 <arfy> apfel: remember String = [Char]
03:09:57 <b_jonas> > return 'a' :: String
03:09:59 <lambdabot>   "a"
03:10:56 * sopvop heads explodes  choosing GADTS and classes for safer code or ADTs and combinators for extendable code.
03:11:05 <apfel> ok thanks, i tought about the fromMaybe function but i think the smile will do the trick
03:11:41 <shachaf> > ['x']
03:11:42 <lambdabot>   "x"
03:12:30 <sopvop> > let singleton x = [x] in singleton 'c'
03:12:31 <lambdabot>   "c"
03:12:39 <sopvop> why this is not in base?
03:13:05 <fmap> > tail . init . show $ 'x'
03:13:05 <sopvop> also, why there is no 'bool' like maybe or either in base
03:13:07 <lambdabot>   "x"
03:13:16 <shachaf> sopvop: Why would it be?
03:13:26 <shachaf> pure, return, (:[]) are all shorter than singleton
03:13:49 <shachaf> fmap: That's certainly not the same operation.
03:14:39 <sopvop> because they are not specific to list and code is a little bit harder to understand without looking on type of 'consumer' function
03:14:57 <shachaf> (:[]) is specific to list.
03:15:03 <sopvop> but it is ugly
03:15:07 <shachaf> (\x->[x])
03:15:08 <shachaf> singleton
03:15:12 <shachaf> Same length.
03:15:17 <shachaf> (Also, it's not ugly.)
03:15:17 <b_jonas> yes, there are some functions like bool that we don't have in base out of tradition
03:15:23 <sopvop> but lambda has noize
03:15:23 <fmap> shachaf: yes
03:15:54 <b_jonas> @djinn Char -> [Char]
03:15:54 <lambdabot> Error: Undefined type Char
03:26:37 <ozgura> @djinn a -> [a]
03:26:37 <lambdabot> Error: Undefined type []
03:26:44 <ozgura> meh
03:26:48 <shachaf> ozgura: repeat
03:27:24 <sopvop> What is the better, define instances in same file as class, or with data-types?
03:27:40 <ozgura> shachaf: thanks, was only trying to see if it works for a, after b_jonas
03:28:05 <shachaf> ozgura: Lists aren't very interesting from Djinn's point of view.
03:28:11 <shachaf> @djinn a -> Maybe a
03:28:11 <lambdabot> f = Just
03:28:18 <shachaf> @djinn (a,a) -> Maybe a
03:28:18 <lambdabot> f (_, a) = Just a
03:28:22 <shachaf> @djinn (a,a) -> (a,Maybe a)
03:28:23 <lambdabot> f (a, b) = (b, Just a)
03:28:31 <SingingBoyo> sopvop:  I always do it in the same file as the data-type.  GHC actually warns you about orphaned types if you don't.
03:28:46 <ozgura> shachaf: true.
03:28:57 <b__> does anyone know of some interesting Haskell concepts/libraries/papers dealing with events, simulation and `relations of values over time`?
03:29:04 <shachaf> sopvop: It depends, if it's your own type and your own class, and they're in different files.
03:29:24 <sopvop> my own, in different files.
03:29:25 <shachaf> Clearly for other people's types you want it with the class, and for other people's classes you want it with the type.
03:29:50 <shachaf> It's probably nicer to put the instance declaration next to the type, if module dependencies work out that way.
03:31:03 <sopvop> I might need more than one type parameter in the class then. Or type families.
03:31:34 <shachaf> How would I figure out GHC's "calling convention" when reading assembly?
03:31:48 <SingingBoyo> sopvop: I wouldn't think where you define the instance would matter for how many type parameters your class needs.
03:31:57 <shachaf> sopvop: If it leads you to restructure your code, I'd say structure the code to be nicest first and then make the classes match. :-)
03:33:16 <apfel> how can i use filter to eleminate more then one element, filter (/='a'|'c') "abcd" ?
03:33:38 <shachaf> filter (`notElem`"ac")
03:36:18 <sopvop> You know why I love haskell? My 10k loc app is working, I decide to refactor it, do a +-500 commit and it still works. http://qkme.me/3s2gs1
03:37:01 <sopvop> My new habit - newtype everything!
03:38:39 <SingingBoyo> I don't newtype enough
03:39:24 <SingingBoyo> been using c++ typedefs and scala type ... = ... for too long, they don't have any real effect so you stop using them.
03:39:42 <Peaker> SingingBoyo, "newtype" is like a C++ struct of 1 element
03:39:51 <Peaker> SingingBoyo, not like "typedef".  "type" is like "typedef"
03:40:18 <Peaker> sopvop, yeah, Haskell makes code insanely scalable...
03:41:00 <Peaker> hey, our project just passed the 10KLOC line too :)
03:41:11 <Peaker> (technically 9.5KLOC + 0.7KLOC tests)
03:41:33 <shachaf> That's the new name for Bottle, right?
03:41:43 <sopvop> The more project evolves, the less lines of code :)
03:42:12 <SingingBoyo> Peaker: I know it's different.  but it feels similar, so I subconsciously don't do it.
03:42:20 <SingingBoyo> bad habits are bad
03:42:33 <sopvop> Also, newtype is not like C++ struct of 1 element, it's like typedef which forgets everything
03:42:48 <shachaf> sopvop: How is it different?
03:43:09 <Peaker> shachaf, yeah
03:43:21 <sopvop> it adds no overhead in form of (*pointer) dereferencing
03:43:31 <sopvop> Oh shit, C does that too
03:43:32 <shachaf> OK, but nor does a struct.
03:43:39 <sopvop> my bad
03:43:50 <shachaf> Besides, I don't think "overhead" is part of the definition of a newtype. :-)
03:44:26 <Peaker> shachaf, our implicit type variables are almost usable :)
03:44:52 <Peaker> (it's beginning to show signs of looking like an actually useful Haskell code editor!)
03:44:56 <sopvop> also $(makeIso ''MyNewtype) :)
03:45:39 <shachaf> C++ lets you have a syntactically uniform way of accessing all "newtypes".
03:45:43 <sopvop> Peaker: I've heard bottle has cool UI thing
03:45:52 <shachaf> struct Foo { int val; }; struct Bar { int val; };
03:46:19 <shachaf> (I don't know why we're talking about C++ rather than C, but so it is.)
03:46:21 <nlogax> Can I disable specific GHC warnings for a (portion of a) single source file?
03:46:35 <shachaf> Not for a portion.
03:47:01 <nlogax> How about a file?
03:47:50 <sopvop> {-# OPTIONS -fno-warn-orphans #-} on top of file
03:48:02 <nlogax> Ah, thanks :)
03:48:26 <Peaker> sopvop, yeah, bottle (now named "lamdu") is a work in progress towards an awesome UI for code editing (new generation IDE)
03:49:01 <shachaf> I have this function: bar :: Int -> Two; bar n = if sum [n*n,n] > 5 then First else Second
03:49:13 <shachaf> For some reason GHC isn't optimizing n*n into a mul instruction.
03:49:17 <Peaker> Hoping to realize many of the benefits of Haskell that we feel are completely unrealized now.. e.g: Runtime Debugging pure expressions should be *easier*, not harder than debugging an imperative program
03:49:18 <shachaf> Any idea why?
03:49:41 <Peaker> shachaf, what's Two?
03:49:42 <sopvop> Because Simons don't scale?
03:49:47 <shachaf> data Two = First | Second
03:50:17 <Peaker> shachaf, how are you looking to see what the (n*n) compiles to?
03:50:17 <shachaf> Oh, I see.
03:50:26 <shachaf> Looking at the generated assembly.
03:50:40 <Peaker> ah, I'm curious about your conclusion :)
03:50:41 <shachaf> OK, it's because the function isn't strict.
03:50:51 <shachaf> If I make it strict in n it turns into a mul instruction.
03:50:58 <shachaf> But otherwise it has to delay the multiplication anyway.
03:51:05 <Peaker> "sum" is horribly implemented with foldr, isn't it?
03:51:08 <shachaf> So it might as well use (*) :: Int -> Int -> Int instead of Int# multiplication.
03:51:12 <shachaf> No, with foldl
03:51:28 <shachaf> Not that I care -- the "sum" is only there to make bar big enough that GHC doesn't inline it. :-)
03:51:52 <Peaker> heh, {-# NOINLINE #-} ?
03:52:04 <SingingBoyo> shachaf: y no inlines?  optimization is good.
03:52:05 <shachaf> I don't want it to get in the way of other optimizations.
03:52:11 <shachaf> I'm trying to figure out what GHC does and doesn't do. :-)
03:52:35 * shachaf just read some of the CPR paper.
03:52:50 <shachaf> I'm wondering what it does for sums, if anything.
03:53:03 <shachaf> Apparently nothing much, in the cases that it doesn't manage to inline them.
03:55:31 <shachaf> "leaq -8(%rbp),%rax; cmpq %r15,%rax; jb _crE" at the beginning of a function.
03:55:54 <shachaf> Is that what GHC's heap check looks like?
03:55:58 <shachaf> I guess this isn't really enough context.
03:58:12 <Peaker> is %rbp a heap ptr or a stack frame ptr?
03:58:27 <Peaker> Maybe it's a stack frame ptr, and it's checking if the stack needs extension/shrinking?
03:59:00 <X421> Hi, i have a problem, but don't know what exactly it is and how to solve it. Here is the code and the errors from hugs: http://paste42.de/4557/
03:59:47 <shachaf> X421: 1. Try commenting out the type and seeing what Hugs infers for it.
03:59:49 <sopvop> X421: (Ord a, Num a) =>
03:59:50 <luite> shachaf: probably easier to check the cmm code for that function
04:00:02 <luite> since the registers will then still have the virtual names
04:00:17 <shachaf> You need Ord to compare (x < y), and not all numbers can be compared (e.g. Complex numbers).
04:00:29 <shachaf> X421: 2. You shouldn't be using Hugs. It's an old unmaintained project. You should be using GHC.
04:00:40 <shachaf> 3. You shouldn't use head and tail. :-) Instead, use pattern-matching.
04:00:48 <X421> shachaf: We have to.
04:00:57 <X421> use hugs..
04:01:00 <shachaf> Really?
04:01:09 <shachaf> You can't install GHC on your own?
04:01:11 * sopvop hugs X421
04:01:22 <shachaf> 4. Your function will probably be inefficient (O(n^2)) the way it's written. I don't know if you care about that.
04:01:22 <X421> I can, but then I don't know my way arount
04:01:26 <X421> *around
04:01:46 <X421> shachaf: I am a noob
04:01:46 <shachaf> Well, get GHC, and learn your way around.
04:01:53 <shachaf> luite: Good point.
04:02:14 * shachaf should get into the habit.
04:02:21 <shachaf> Maybe add Cmm to ghc-core. :-)
04:04:52 <SingingBoyo> X421: GHC really isn't that bad to learn.  just get it.
04:08:20 <chrisbuchholz> I'm giving project euler problem 37 a shot, and i have this program: https://gist.github.com/4223973 I do believe it will yield the correct result if it ever finishes, but its just too damn slow. I think the slowness is cursed mostly by my main and truncatablePrime functions but perhabs also my prime function. Can somebody comment on stuff i could look at to improve the efficiency?
04:08:41 <shachaf> luite: Thanks, this Cmm is way nicer than the x86
04:28:26 <shachaf> So if I have data Two = First | Second, GHC generates a bunch of places that say "First_closure+1" or "Second_closure+2"
04:28:30 <shachaf> What are those +s?
04:29:40 <SingingBoyo> god shachaf, what did you get yourself into now.  possibly some form of identifier?
04:33:34 <chrisbuchholz> I have this prime function which return True or False depending on whether or not the int given is a prime. Can i add memoization to this in any way? I get how i would add memoization to e.g. a function that calculates fibonacci, but how would i do it to a function that is called numerous times so that it can remember the results -between-the-evaluations-
04:35:55 <luite> shachaf: those are the tags
04:36:23 <shachaf> luite: Oh!
04:36:24 <shachaf> Hah.
04:36:27 <shachaf> Good point.
04:36:33 <luite> shachaf: First_closure is the word-aligned adress of the function (4 or 8 bytes), +1 means that the tag is 1, the first constructor
04:36:36 <luite> +2 is the second
04:36:45 <luite> if the tag is 0, it might be unevaluated
04:36:50 <luite> so it needs to be entered first
04:36:54 <shachaf> Yes, I know how the tags work (more or less).
04:36:59 <luite> ok
04:36:59 <shachaf> I just didn't connect it to this.
04:40:03 <Peaker> chrisbuchholz, you can do it in various ways.. One common (and probably inefficient) way is:  memoFib n = fibs !! n where fibs = map fib [0..]
04:40:03 <Peaker> chrisbuchholz, the same approach with a boxed array could be somewhat efficient
04:40:03 <Peaker> chrisbuchholz, another approach is using one of the "memo" packages on hackage which let you do something like:  memoFib = memo fib
04:40:13 <andsens> Is it possible to somehow create a 'where' that covers all equations?
04:40:36 <andsens> or do I need to use case … of
04:40:46 <merijn> chrisbuchholz: It depends on how comfortable you are with haskell atm? I remember a nice example of memoisation in the Fun with Typefuns paper, but if you're not really comfortable with haskell yet that might be a bit too intimidating
04:41:38 <SingingBoyo> andsens: if you need to use something across all equations, just create a new function that does that?
04:43:07 <shachaf> luite: If I give my sum 8 values, it always gives it a +1
04:43:15 <andsens> SingingBoyo. Already did that, it's simply that I have some DataRecords with quite a few fields, the two constructors I invoke need exactly the same invocations except one requires an additional field
04:43:34 <shachaf> Does that mean that it's just tagging it as "evaluated", and then dereferencing it or something to find an integer with a full value of the tag?
04:43:41 <chrisbuchholz> merijn: well, im not that comfortable with haskell yet. Im doing lyah and erik meijers videos at the moment, and are currently working on solving some project euler problems with what i learn.
04:43:43 <luite> shachaf: yeah then it knows that the constructor cannot be encoded in the tag directly, only tagging thunk/evaluated
04:44:15 <shachaf> OK, so it'll only ever do +1 or +0 then.
04:44:18 <shachaf> But it still doesn't need to actually jump to it, becaause it can just look up what it is and dispatch on that.
04:44:49 <luite> yeah it can look up the constructor number in the info table next to the closure entry point
04:44:57 <shachaf> Yep.
04:45:13 <merijn> chrisbuchholz: Completely unrelated, I think Project Euler is a terrible way to play with new languages. It's focussed to much on clever math and to little on writing code you'd write in real programs
04:45:25 <SingingBoyo> andsens: afaik you'd have to invoke them with all those fields and then the extra one where needed.  I don't think you can get around it.
04:45:29 <hpc> PE is a good way to learn number theory
04:45:37 <hpc> and... that's pretty much it
04:45:45 <andsens> OK, was afraid of that. Thanks anyways :-)
04:46:14 <merijn> chrisbuchholz: 99 Haskell problems might be better start, for example
04:46:26 <chrisbuchholz> Peaker: probably yeah, but i like project euler for learning new languages because it gives me a single very focused task to target for, where i can play with what i know of the language
04:46:35 <chrisbuchholz> merijn: ill take a look
04:46:46 <merijn> chrisbuchholz: http://www.haskell.org/haskellwiki/H-99:_Ninety-Nine_Haskell_Problems
04:47:32 <merijn> chrisbuchholz: Or grab an online copy of SICP and try to do the assignment in haskell instead of scheme, that should probably also work fairly well
04:47:53 <chrisbuchholz> Peaker: all right, thats one way. Perhabs i can translate that to my prime function
04:48:20 <chrisbuchholz> merijn: sicp?
04:48:32 <merijn> chrisbuchholz: Structure and Interpration of Computer Programs
04:48:38 <merijn> @where sicp
04:48:38 <lambdabot> http://mitpress.mit.edu/sicp/ | http://swiss.csail.mit.edu/classes/6.001/abelson-sussman-lectures/ | http://www.vex.net/~trebla/haskell/sicp.xhtml | "Storage and Identification of Cabalized Packages"
04:50:14 <shachaf> luite: By the way, until ghc-core does cmm automatically, you can just add -ddump-cmm to the end of the command line.
04:50:40 <luite> shachaf: ah tnx
04:50:42 <shachaf> (If the option comes after the file name it goes to GHC rather than the ghc-core.)
04:50:45 <shachaf> But I'll probably add an option to make it more convenient.
04:51:02 <shachaf> I need to dig through GHC options and come up with few nice sets of them for different verbosity levels, or something.
04:51:10 <chrisbuchholz> merijn: ah, thank you ;)
04:51:19 <luite> unfortunately for what i'm doing atm, looking at cmm output isn't terribly useful :/
04:51:19 <chrisbuchholz> merijn: i will take a look at them :)
04:51:48 <shachaf> luite: But you asked about it before. :-)
04:51:51 <shachaf> What are you doing at the moemnt?
04:51:58 <merijn> chrisbuchholz: It's one of the better known books in CS, it teaches Scheme, but many of the assignment can easily be reused to do in other languages
04:52:10 <luite> shachaf: yeah i know
04:52:23 <merijn> chrisbuchholz: Especially since the core basics of scheme (and thus the initial assignments) are mostly purely functional
04:52:46 <luite> shachaf: i need to handle StgLetNoEscape correctly otherwise parts of base will not compile correctly
04:52:54 * merijn waits to get stoned as heretic for saying that
04:53:12 <luite> shachaf: it's some limited form of escape analysis where GHC determines that an object can be allocated on the stack instead of the heap
04:53:14 <chrisbuchholz> merijn: all right, thank you :)
04:53:50 <chrisbuchholz> Peaker: with 10^4 primes, my memoPrime function is a lot slower than my prime function :D
04:55:19 <chrisbuchholz> Peaker: but i also dont get how that list of primes would be kept between different executions of memoPrime. Wouldnt it have to be recalculated for each?
04:55:22 <chrisbuchholz> Peaker: making it a lot slower
04:56:09 <andsens> Why is 'current' still a function when I pattern match like this: make_selector res z@(Crumb{current=(P.Variable {}),..}, _) ?
04:56:43 <andsens> ghc is messing with me, right?
04:56:50 <shachaf> No.
04:56:54 <merijn> andsens: The "current =" doesn't assign a value to current, you just have a pattern match on the right
04:56:57 <shachaf> You're matching *on* current.
04:57:09 <shachaf> > Sum 5
04:57:14 <lambdabot>   Sum {getSum = 5}
04:57:19 <luite> shachaf: according to comments in the ghc source code it's "advanced stuff" and one of "the two most annoying constructs to generate code for" (the other thing is unboxed tuples)
04:57:22 <shachaf> > let foo (Sum { x = y }) = y in foo (Sum 5)
04:57:23 <merijn> "f (Crumb{current=a}) = a" <- this returns the value of current
04:57:24 <lambdabot>   Constructor `Data.Monoid.Sum' does not have field `Debug.SimpleReflect.Vars...
04:57:28 <andsens> oh!. thx shachaf
04:57:32 <shachaf> > let foo (Sum { getSum = y }) = y in foo (Sum 5)
04:57:34 <lambdabot>   5
04:58:00 <shachaf> luite: Earlier I was trying to figure out the point of returning singleton unboxed tuples.
04:58:05 <merijn> andsens: btw, there's an extension that lets you use field names in variables on the right of the function definition
04:58:12 <shachaf> Something to do with not forcing evaluation.
04:58:12 <merijn> andsens: NamedFieldPuns or something like that
04:58:23 <andsens> you mean {..}?
04:58:37 <shachaf> NamedFieldPuns is somewhat evil.
04:58:50 <andsens> oh wait, thats wildcards
04:58:55 <osfameron> to actually call something "puns" in programming is quite odd
04:59:00 <shachaf> Why?
04:59:12 <merijn> andsens: http://www.haskell.org/ghc/docs/7.0.1/html/users_guide/syntax-extns.html#record-puns
04:59:22 <Peaker> chrisbuchholz, I put the "fibs" in where which might cause it to be recomputed every time, yeah :)
04:59:38 <merijn> shachaf: But sometimes it's so much nicer!
04:59:42 <Peaker> chrisbuchholz, though in practice, GHC tends to "float" these expressions to the top-level since they have no dependencies, and keep them around
04:59:46 <shachaf> merijn: Just, like, use lenses, man.
04:59:51 <osfameron> shachaf: because punning is a linguistic, social, *ambiguous* activity, that programming mostly isn't
04:59:57 <Peaker> chrisbuchholz, btw, are you using -O2 ?
05:00:22 <chrisbuchholz> Peaker: nope, dont know about that
05:00:42 <luite> shachaf: hmm, i wonder what the difference is, do you get different core other than the returned thing? in the generated code (# X #) and X are the same (this is sometimes used for shortcuts, because (# X, State# RealWorld #) and X are also the same)
05:00:47 <merijn> osfameron: You're programming wrong, man!
05:00:51 <osfameron> hehe
05:01:00 <andsens> I know what you mean merijn. Reminds me of this one: http://www.youtube.com/watch?v=jT3_UCm1A5I
05:03:18 <Peaker> chrisbuchholz, ghc -O2 will compile much faster code
05:03:20 <shachaf> luite: I saw http://www.haskell.org/pipermail/glasgow-haskell-users/2011-December/021364.html about it a little while ago.
05:03:44 <shachaf> I doubt ghc -O2 will do a good job with what chrisbuchholz pasted.
05:03:44 <Peaker> chrisbuchholz, without it, I'm not sure if even the "fibs = .." I used there would be floated to the top-level
05:04:02 <shachaf> luite: I'm not sure I understand dcoutts's response, though.
05:04:12 <shachaf> The CPR paper also talks about this.
05:05:03 <chrisbuchholz> Peaker: all right, i see. if i compile like `ghc --make -O2 ...` it doesnt seem to go any faster though. Not noticably anyways
05:07:18 <chrisbuchholz> Peaker: ah yes, my code runs a lot faster when compiled with -O2, but prime is still slower than memoPrime, sadly :P
05:07:19 <luite> shachaf: hmm, i think the idea is that you can force (# a #) without forcing the a
05:07:24 <Peaker> chrisbuchholz, you mean the opposite I suppose
05:07:39 <chrisbuchholz> Peaker: ah, yeah, sorry :P
05:07:48 <Peaker> chrisbuchholz, well, a memo-list with (!!n) is a very silly memo in practice :)
05:08:08 <Peaker> chrisbuchholz, you could use one of the memo packages for less silly memos
05:08:18 <luite> shachaf: dunno in what specific cases that can help, maybe it can prevent memory leaks in some places
05:08:33 <shachaf> luite: "force" in what sense?
05:08:40 <shachaf> Nothing is left over at runtime, right?
05:09:28 <luite> yeah but when retuning (# a #), some intermediate thunks might be squashed, maybe it's a let x = readsomethingFromArray in x `seq` (# x+1 #)
05:09:46 <luite> then you can force the array read before the (# #) return, but not the other calculation
05:10:45 <shachaf> Ah, hmm.
05:10:49 <chrisbuchholz> shachaf: all right, sad to hear that. Just looking for possible ways to optimize my program :P
05:11:17 <chrisbuchholz> Peaker: i will look at em, but first, i gotta figure out if that will even make a huge enough optimization
05:12:13 <shachaf> luite: Is there a good way of finding out about GHC's "calling convention"?
05:12:29 <shachaf> Or rather what's in all the registers at any particular point.
05:12:38 <shachaf> But that's a bit much to ask. :-)
05:12:59 <shachaf> I suppose it can vary a lot between functions because it has strictness information etc.
05:14:08 <luite> uh, that's a bit complicated, R1..Rn are general purpose, where R1 is the current closure, R2..R7 (or R8, not sure) the function arguments (and if there are a lot, the rest is on the stack)
05:14:10 <shachaf> I guess the // [R2] comments help.
05:14:27 <shachaf> I understand that it's a bit complicated. Calling conventions often are.
05:14:33 <shachaf> They also tend to be a bit documented. :-)
05:14:41 <Kosta> I'm getting a stack overflow parsing logfiles, but I don't have any recursion in my code
05:14:55 <luite> when some result is returned to some return point on the stack, it's in R1 (or in more registers if it's an unboxed tuple)
05:14:58 <jackss> > zipWith (,) [1..5] (repeat "haha")
05:14:59 <lambdabot>   [(1,"haha"),(2,"haha"),(3,"haha"),(4,"haha"),(5,"haha")]
05:15:05 <shachaf> Kosta: Stack overflows in Haskell are a bit different from in other languages.
05:15:25 <Kosta> shachaf: they are sponsored by that popular website?
05:15:43 <luite> shachaf: yeah i'm not sure if it is, there is some generated code example wiki page on the ghc wiki, but it uses an older calling convention (much more on the stack)
05:16:56 <shachaf> @localtime
05:16:59 <lambdabot> Local time for shachaf is Thu Dec  6 05:16:39 2012
05:17:00 * shachaf should go to sleep.
05:17:12 <shachaf> luite: Thanks for your help!
05:17:14 <luite> shachaf: entering the constructors to dispatch isn't done anymore btw
05:17:52 <shachaf> When reading either GHC code or GHC-generated code, I get the feeling that if I had someone who knew what they were talking about next to me they could explain in 5 minutes what can take an hour of crawling around the codebase to figure out.
05:17:55 <luite> somethign like enter b f t, enter :: Bool -> a -> a -> a, was used before
05:18:02 <luite> called vectored return
05:18:20 <shachaf> luite: Oh, that's not done at all?
05:18:34 <shachaf> They just evaluate the thunk and then examine the tag?
05:18:39 <luite> yeah it's been removed, no advantage anymore since tagging
05:18:47 <shachaf> Man, this "STG" thing is a total scam.
05:20:30 <shachaf> luite: I guess http://research.microsoft.com/pubs/67969/ptr-tagging.pdf is relevant?
05:20:58 <shachaf> luite: I was trying to figure out how viable something like CPR for returning sums would be.
05:21:58 <shachaf> I guess that's pretty similar to vectored returns.
05:22:09 <shachaf> Except the point is to avoid allocating the thunk in the first place.
05:22:24 <ToranLipse> If you were able to apply a regular expression to a PDA's stack on each transition function, would that add any extra functionality that couldnt be achieved with a PDA? (Sorry about it being off topic. =()
05:22:36 <Kosta> Ok, so I have a loooong list that is generated lazily (> 300k entries). If I call length on it, the program returns after 1s. If I do a foldl on it, I get a a stack overflow
05:22:58 <luite> hm apparently there is a patch for that
05:23:11 <shachaf> Oh?
05:23:19 <shachaf> Kosta: Try foldl'
05:23:26 <shachaf> Kosta: You should more or less never use foldl
05:23:46 <Hafydd> @impl fold'
05:23:46 <lambdabot> Maybe you meant: pl unpl
05:24:04 <eikke> @src foldl'
05:24:04 <lambdabot> foldl' f a []     = a
05:24:04 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
05:24:14 <shachaf> luite: Do you happen to know where?
05:24:29 <luite> shachaf: http://hackage.haskell.org/trac/ghc/ticket/5075
05:25:07 <Hafydd> @src foldl
05:25:07 <lambdabot> foldl f z []     = z
05:25:07 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
05:25:29 <shachaf> luite: Oh, that's not what I meant.
05:25:42 <luite> oh ok
05:25:55 <Kosta> But "left folding" is the right thing for lists?
05:26:01 <shachaf> That's just CPR where you only every use one aprt of the sum type.
05:26:07 <shachaf> Kosta: Maybe. Depends on what you're doing.
05:26:15 <shachaf> Kosta: Left folding won't be lazy; right folding might be.
05:26:36 <Kosta> doesn't need to be lazy
05:27:10 <shachaf> luite: I meant something along the lines of: bar x = if x > 5 then A else B; foo x = case bar x of A -> True; B -> False
05:27:22 <shachaf> luite: Where you never actually need to allocate A/B at all.
05:27:33 <shachaf> Well, assuming bar doesn't get inlined.
05:27:39 <shachaf> If it gets inlined GHC can figure it out, of course.
05:28:23 <Hafydd> @src seq
05:28:23 <lambdabot> Source not found. You untyped fool!
05:28:42 <Hafydd> :t seq
05:28:43 <lambdabot> a -> b -> b
05:29:38 <Hafydd> How strict.
05:29:57 <Saizan> what's CPR?
05:30:08 <shachaf> @where cpr
05:30:08 <lambdabot> http://research.microsoft.com/en-us/um/people/simonpj/Papers/cpr/index.htm
05:30:24 <shachaf> Saizan: It's where you optimize f :: ... -> (Int, Int) to returning an unboxed tuple.
05:30:42 <shachaf> (Or more generally for any product.)
05:30:52 <shachaf> Assuming f is constructing the product anyway, that is.
05:31:18 <shachaf> So if f x = (x + 1, x + 2), there's no point in allocating the tuple when the called is going to use it once right away.
05:31:35 <eikke> :t void
05:31:36 <lambdabot> Functor f => f a -> f ()
05:31:50 <Saizan> i see
05:32:49 <Kosta> Data.List.foldl' gives me a stack overflow after running for 5 minutes
05:33:07 <Botje> Kosta: which operation are you folding?
05:33:24 <Kosta> I'll paste it
05:33:36 <hpaste> kosta pasted “Stack Overflow” at http://hpaste.org/78844
05:33:43 <shachaf> luite: Do you know if someone's done something like that?
05:33:46 <Saizan> http://www.haskell.org/haskellwiki/Foldr_Foldl_Foldl' <- useful read
05:34:42 <luite> shachaf: hm dunno, it's probably been implemented for that paper? or has that never made it to production?
05:34:54 <shachaf> What paper?
05:34:58 <shachaf> Oh, the CPR paper?
05:35:02 <shachaf> I meant the thing for product types.
05:35:07 <shachaf> GHC certainly does CPR.
05:35:09 <Saizan> Kosta: if you replace line 34 with "count :: !Integer" it should work
05:35:16 <shachaf> Er.
05:35:19 <shachaf> I meant the thing for sum types.
05:35:46 <Kosta> Saizan: Let's give it a spin... :)
05:36:23 <luite> shachaf: oh then i don't know. i guess it would just rely on the inliner for that
05:37:02 <shachaf> luite: You might as well say the same thing about products. :-)
05:38:04 <shachaf> Hmm, half an hour ago I said something about going to sleep.
05:38:26 * shachaf will try it again.
05:41:02 <`ramses> is there an alternative to seq in the libraries which is not strict? So actually just flip const ?
05:41:24 <Kosta> Saizan: Yes, that was it. Now it went through an read 10 million log lines in 5 minutes
05:42:43 <Kosta> Saizan: thanks a lot!
05:43:19 <Saizan> Kosta: yay, you were accumulating a huge (... + 1 + 1 + 1) thunk in that count field which then caused a stack overflow when printed
05:43:23 <Saizan> Kosta: np
05:45:14 <parcs`> `ramses: that or const id
05:46:00 <b_jonas> yeah, (flip const) also known as (const id) is another of those combinators that are needed very frequently but doesn't have a short name in the libraries out of tradition :-)
05:46:08 <`ramses> ok, I was hoping for a simple predefined function, but I'll add it myself then :)
05:46:54 <b_jonas> @djinn a -> b -> a
05:46:54 <lambdabot> f a _ = a
05:47:47 <fmap> :t flip const
05:47:48 <lambdabot> b -> c -> c
05:48:16 <b_jonas> ah right
05:48:19 <Kosta> hahahaha making that counter strict decreased the memory consumption from 700 MB to 4 MB
05:48:22 <b_jonas> @djinn a -> b -> b
05:48:22 <lambdabot> f _ a = a
05:48:26 <b_jonas> @@ @pl @djinn a -> b -> b
05:48:26 <lambdabot>  f = const id
06:05:45 <`ramses> @pl \x y -> x ++ ". " ++ y
06:05:46 <lambdabot> (. (". " ++)) . (++)
06:10:55 <cizra> Are there true O(1) read O(1) update mutable arrays in Haskell, sort of FFI?
06:11:15 <cizra> short of *
06:11:27 <companion_cube> look at the ST monad
06:11:38 <Botje> cizra: IOArray
06:16:20 <quchen> cizra: There's also the Vector package. Array has more general indexing (Ix typeclass indices), vector has an interface similar to List.
06:20:21 <neworder> http://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours/First_Steps
06:20:32 <neworder> I was following this Haskell Tutorial
06:20:50 <neworder> I paste the code into WinGHCi
06:21:56 <neworder> I compiled it using :load filename.hs
06:22:17 <neworder> How do I give it arguments?
06:22:40 <neworder>      putStrLn ("Hello, " ++ args !! 0)
06:22:48 <neworder> So gotta give it some arguments
06:23:44 <`nand`> there was a way to do this in GHCi I think, but I forgot how
06:23:47 <sepp2k> neworder: Type in ":main arguments"
06:24:02 <`nand`> neworder: easiest way would be to use ‘runhaskell filename.hs arg1 arg2 arg3”
06:25:30 <neworder> Thanks
06:38:28 <cloudhead> hey, anyone know how I can send a signal to a child process? can't find any api that lets me do that.
06:39:04 <cloudhead> problem is signalProcess takes a pid, but all the functions to spawn processes return a ProcessHandle
06:39:22 <cizra> companion_cube, Botje, quchen: Thanks!
06:41:30 <`ramses> how do guys allign functions consisting of a single do block and a where clause? Should I both indent them by two chars? That makes it look so strange, as if the where is inside the do somehow
06:41:45 <`ramses> s/allign/align
06:42:05 <fryguybob> cloudhead: I think you would need to use some package that is less cross platform like `unix` which has signalProcess
06:42:08 <navaati> hi
06:44:04 <navaati> has anyone played with type level literals ?
06:44:04 <navaati> cause i don't understand why "sing :: Sing 5" gives me 5 but "sing :: Sing (3 * 4)" gives me "No instance for (SingI Nat (3 * 4)) arising from a use of `sing'"
06:45:16 <cloudhead> fryguybob: that's what I'm looking at, but signalProcess takes a pid..
06:45:24 <sepp2k> cloudhead: All base functions to spawn processes return ProcessHandles. The functions in the unix package return ProcessIDs
06:45:33 <Saizan> navaati: i think you've to take the "literals" in type-level literals more literally
06:45:46 <fryguybob> cloudhead: Right, so use `unix` to spawn the process in the first place.
06:45:48 <navaati> Saizan, uh ?
06:46:02 <hpaste> “Ertugrul Söylemez” pasted “do-where layout examples” at http://hpaste.org/78846
06:46:08 <pmade> I've written a library that makes a few HTTP requests.  How can I test this code without relying on a remote HTTP service?  In languages I'm more familiar with I'd "mock" out the HTTP part.  I'm leaning towards a data type that has functions as members and the functions either do the HTTP or you replace them to do something else.
06:46:10 <`nand`> navaati: wait, where did you take * from?
06:46:20 <mm_freak> `ramses: see the paste…  i have written a few examples
06:46:29 <cloudhead> sepp2k: fryguybob: ok, gotcha
06:46:32 <Saizan> navaati: IOW arithmetic expressions are not supported yet, iirc
06:46:32 <navaati> `nand`, import GHC.TypeLits
06:46:38 <mm_freak> `ramses: my layout would be 1, 4 or 5, depending on what i'm doing
06:46:58 <navaati> (*) :: Nat -> Nat -> Nat is a type family defined in this type module
06:47:08 <fmap> `ramses: I indent where by one space and code by two
06:47:09 <navaati> so, it *should* work
06:47:37 <`nand`> I uh
06:47:42 <`nand`> navaati: it doesn't seem to do any evaluation?
06:47:48 <luite> pmade: perhaps you can do local wai requests
06:47:50 <`nand`> Couldn't match type `3 * 4' with `12'
06:47:57 <navaati> `nand`, yeah, and that's the problem
06:48:02 * `nand` wonders why it's in there
06:48:07 <`nand`> perhaps for future use? (7.7+)
06:48:24 <navaati> maybe (i'm thinking about trying GHC head)
06:48:31 <`nand`> oh; wait
06:48:32 <Botje> .w 21
06:48:33 <`ramses> mm_freak: okay, thanks, I used the first for now but indented by two spaces
06:48:34 <Botje> oops
06:48:38 <navaati> (but i'm lazy to buold it, it's super long)
06:48:43 <`nand`> that Sing stuff was only in GHC 7.7+ wasn't it?
06:48:50 <`nand`> I remember coming across this in the past
06:48:54 <pmade> luite: That seems like a heavy-handed way of dealing with the problem.
06:48:55 <`ramses> as there is no general rule then, I'll experiment a bit to see what reads best for me
06:49:12 <`nand`> hmm, seems it *is* defined in GHC 7.6
06:49:21 <`nand`> that's odd
06:49:26 <navaati> well, every document talking about type level literals talks about 7.6
06:50:17 <luite> pmade: hmm, maybe
06:50:18 <`ramses> fmap: I find the were still hard to distinguish from the code if they differ only by one space..
06:50:25 <`ramses> s/were/where
06:50:30 <`nand`> I mean I remember reading in the ‘singletons’ source something like “#if GHC_VERSION >= 707 \n import GHC.TypeLits \n #else \n {- define all of that stuff -}”
06:50:46 <`nand`> navaati: yeah, to my knowledge they were added in 7.6 but without any operations
06:50:46 <`ramses> gotta run, thanks for the pointers!
06:50:57 <navaati> `nand`, ah, strange then
06:51:32 <`nand`> oh
06:51:35 <`nand`> looking at the source
06:51:46 <`nand`> type family (m :: Nat) * (n :: Nat) :: Nat -- no type instances
06:51:55 <`nand`> that would make sense and correspond to the current result
06:52:14 <`nand`> so it seems like it's just there to reify “multiplication”; but without actually performing type-level evaluation
06:52:36 <navaati> let's wait for 7.8, then…
06:52:46 <`nand`> that's what I'm doing :)
06:52:49 <`nand`> actually, that's not what I'm doing
06:52:56 <`nand`> I wrote my own type-level nats
06:53:03 <`nand`> but they're slow
06:53:11 <navaati> and less convenient to type, i guess
06:53:51 <xnyhps> navaati: Evaluation of type literals is not yet implemented in 7.6, but it works using the type-nats branch.
06:54:21 <navaati> xnyhps, is it tight now in 7.7 ?
06:54:23 <navaati> right*
06:54:37 <`nand`> navaati: I have a horribly ugly injection family :: Nat -> MyNat that covers the literals from 0 to 9
06:54:52 <`nand`> just so I can write stuff like (Meter / Second^2)
06:55:10 <navaati> `nand`, haha, good enough solution
06:55:20 <xnyhps> I don't know when it'll be merged in.
06:55:30 <xnyhps> But right now, I don't think it's in master.
06:55:33 <`nand`> navaati: I have more of an issue with type-level strings than type-level nats ;)
06:57:08 <`nand`> I need them to be comparable so I can use them as keys to a sorted association list; but they also have no operations
06:57:58 <`nand`> end result was implementing type-level Char with a bunch of constructors manually; then using TH to generate all of the comparison cases (there were a few thousand)
06:58:07 <`nand`> surprisingly, it compiles rather fast
06:58:55 <chrisirc> Hello. I'm rather new to Haskell. I'm trying to install something using cabal and getting:
06:59:19 <chrisirc> "Data/Hashable.hs:296:24: Not in scope: `BL.foldlChunks'"
07:00:01 <chrisirc> This is GHC 6.12.1 (Debian stable)
07:00:15 <`nand`> what version of ‘bytestring’?
07:00:36 <chrisirc> How do I tell?
07:01:16 <`nand`> “ghc-pkg describe bytestring”, I guess
07:01:50 <chrisirc> version: 0.9.1.5
07:02:10 <`nand`> seems like the function is newer than that
07:02:29 <`nand`> it should be in 0.10
07:02:30 <SingingBoyo> chrisirc: not sure what's wrong for your install, but just as a note, 6.12.1 is really quite old.
07:02:34 <`nand`> that too
07:03:39 <mSSM> How to use the State monad properly? I have `foo :: Int -> State () s', which creates a stateful computation updating my `s' using the `Int'. The Int is supposed to be randomly generated n times by an extra function `bar', but `bar' does not depend on the state s. Do I still make `bar' a stateful computation, so that I can bind both stateful computations together and use ReplicateM on this?
07:03:59 <chrisirc> cabal install bytestring; cabal install hashable worked now. Thanks!
07:04:02 <merijn> mSSM: State () s doesn't have state "s"
07:04:13 <merijn> mSSM: State () s has state ()
07:04:23 <chrisirc> Isn't this a problem with hashable, though, it should specify the correct dependency no?
07:04:24 <merijn> mSSM: s is the returned value
07:04:38 <xnyhps> `nand`: Heh, I actually looked at your Units library (I'm assuming that's what you were talking about), but decided I didn't like it because it used Template Haskell.
07:04:39 <`nand`> chrisirc: Yes. A bug should be filed :)
07:04:50 <`nand`> xnyhps: units, yeah
07:04:53 <chrisirc> Ok. How do I file a bug? :)
07:04:58 <`nand`> xnyhps: I would be pretty lost without TH ;)
07:05:03 <`nand`> tons of boilerplate is auto-generated
07:05:05 <mSSM> merijn: Yes, I am sorry, I keep confusing the type of State and the type of the computation it contains. I meant `foo :: Int -> State s ()'
07:05:14 <`nand`> I think like 70% of the library is TH splices
07:05:35 <merijn> mSSM: What type would bar have?
07:05:45 <mm_freak> edwardk: another 'bound' question:  i'm trying to implement a normal form function for lambda calculus with "data Expr a = … | Lam (Scope Name Expr a) | …"…  when a lambda is not applied, i'd like to NF its body, but with the regular interface i would need a name supply…  is there a shortcut?
07:06:44 <xnyhps> `nand`: You're using TH to get ordering on types, therefore the ability to construct the unit maps in a way that they are always equal when they are equivalent?
07:07:02 <`nand`> xnyhps: among many other things, yes
07:07:09 <`nand`> xnyhps: the main usage of TH would be auto-lifting functions to the type level
07:07:15 <`nand`> and generating their singleton equivalents
07:07:38 <xnyhps> I'm using a big, ugly mess of typeclasses for that, heh.
07:07:52 <`nand`> I avoided typeclasses pretty much completely, due to the requirements I had
07:07:59 <`nand`> well, s/had/set for myself/
07:08:03 <`nand`> it's all done through type families
07:08:04 <merijn> mSSM: Because if bar just returns an Int I don't think what you want makes sense, and if it doesn't you probably want to use a different approach
07:08:14 <mm_freak> edwardk: or would i just fmap Left the tree and give my new variable a Right name?
07:09:19 <`nand`> xnyhps: but yes; the goal was to only have a single representation for any possible unit; that way I can just write easy-to-understand type signatures like (+) :: Num a => a:@u -> a:@u -> a:@u
07:09:25 <mSSM> merijn: ok, let me think on this again.
07:09:28 <`nand`> (where :@u tags with the unit ‘u’)
07:10:16 <`nand`> instead of something like (Num a, u == v) => a:@u -> a:@v -> a:@u
07:10:29 <merijn> mSSM: It'd make more sense to (for example) use something like randomRs to generate a list of random input Ints and then use your state computation with that list
07:10:55 <`nand`> even better, (*) :: Num a => a :@ u -> a :@ v -> a :@ u*v; instead of something ugly like (Num a, Mult u v ~ r) => a :@ u -> a :@ v -> a :@ r
07:10:57 <merijn> mSSM: i.e. you can just do "mapM_ foo randList" to do what you want
07:11:05 <mm_freak> edwardk: btw, i'm using the Name in Scope Name Expr for accessing individual definitions in a let-binding, but reading the 'instantiate' documentation that's apparently not what i want to do
07:11:33 <ocharles> is there a way to make hpc exclude /all/ modules that have '.Tests' in the name?
07:13:21 <merijn> mSSM: "mapM_ foo . take 10 . randomRs (0, 10) (mkStdGen 0)" create a new RandomGen, use it to produce an infinite list of Ints between 0 and 10, take 10 Ints of the list and apply foo in sequence using those 10 items as input
07:14:31 <merijn> (Throwing away the result, since it's [()], which is not very helpful anyway)
07:14:42 <xnyhps> `nand`: Hm, that's definitely nicer than what I ended up with (it's at https://bitbucket.org/xnyhps/haskell-unittyped/): (.*.) :: (Fractional f, Convertible' a b, Convertible' c d, MapMerge a c u, MapMerge b d s) => Value f a b -> Value f c d -> Value f u s
07:15:31 <`nand`> ooh, “1 meter” <- fancy overloaded Num ?
07:15:41 <`nand`> in my library, it's a bit more explicit
07:15:46 <`nand`> 1 * meter + 35 * centi*meter
07:16:06 <`nand`> but I could probably adopt a function-Num approach
07:16:30 <jackss> > concat $ map show [1..5]
07:16:31 <lambdabot>   "12345"
07:16:38 <merijn> mSSM: Still following?
07:17:08 <mSSM> merijn: Well, what I want is a bit more complex: I have a ([Int],Int); on the [Int] want to perform n*m computations (n depends on the size of [Int]), and m is my initial choice, the Int I want to update for every step. At the end of n*m computations, I want to get the second part of the tuple (the Int) as some result.
07:17:23 <`nand`> xnyhps: on the other hand, I don't do conversion of (compound) units; my units aren't necessarily linearly related, eg. I wanted to keep open the ability to express something like °C ⇔ K or Planck units (which themselves have irrational relationships)
07:17:43 <xnyhps> `nand`: I had a weird Num instance yeah, but to be honest, in the last commits I had to remove it because something broke it. :P
07:18:10 <xnyhps> I've limited myself to linear dependencies, yes. It makes coercion very easy, but I know there are things I can't do
07:18:15 <`nand`> xnyhps: I would love a way to do fully automatic unit conversions, though: http://hub.darcs.net/nand/units/browse/src/Units/Convert.hs
07:18:23 <`nand`> my current approaches are all very ugly or intractible
07:18:26 <merijn> mSSM: Do you have some pastable example of what you're doing? (at least the types of the various bits) Kinda hard to tell from this description
07:19:09 <mSSM> merijn: hold on...
07:19:28 <`nand`> xnyhps: in particular, I can't “reverse” type families; eg. I can't automatically split up ‘m*s’ into ‘m’ * ‘s’ and select an instance based on that
07:19:36 <`nand`> so I'd conceivably need an instance for every combination of types
07:20:03 <`nand`> furthermore, you can't write instances for type family applications either way; which is imo a bug
07:20:14 <`nand`> so the code gets uglier and uglier
07:20:51 <mSSM> merijn: I have my origianl: http://hpaste.org/78848 and part of my rewrite: http://hpaste.org/78849
07:21:04 <mapf> kind propagation of parametrized types are not allowed?
07:21:05 <mapf> why?
07:21:36 <mSSM> merijn: the interesting part is the "update" in the rewrite line 92 line 82 "updateIsing" in the original
07:21:48 <`nand`> mapf: (was that in relation to what I said?)
07:22:25 <mapf> `nand`: nope, that's just my question)
07:22:59 <mSSM> merijn: what I am currently struggling with is rewriting "stepIsing" line 89 in the original so that it becomes stateful; I am not sure if it makes sense.
07:24:16 <mSSM> merijn: sorry, above I tried to express it more simplistic...
07:24:35 <xnyhps> `nand`: And can't convert the non-multiplicative relations when they are combined, like converting "0 Fahrenheit * second" into "Celcius * Second"
07:24:42 <mm_freak> edwardk: i found that simply destructing the Scope is the easiest method
07:24:51 <xnyhps> s/And/And one/
07:27:24 <jackss> is there something other than printf for formatted output that wont break at runtime if you passed a wrong type?
07:27:33 <mm_freak> in lambda calculus what's the normal form of (\x -> (\y -> y) x)?
07:27:41 <mm_freak> the same or (\x -> x)?
07:27:56 <mm_freak> jackss: Builder
07:29:00 <jackss> @hoogle builder
07:29:00 <lambdabot> Data.Text.Lazy.Builder data Builder
07:29:01 <lambdabot> Data.Generics.Builders module Data.Generics.Builders
07:29:01 <lambdabot> Data.Text.Lazy.Builder module Data.Text.Lazy.Builder
07:29:21 <mm_freak> jackss: it's a lot more to type, but is typesafe and very fast
07:30:28 <navaati> jackss, i don't know if it matches your "other than printf" criterion, but there is a template haskell version of printf
07:30:37 <navaati> which is runtime-error safe
07:31:03 <jackss> interesting. it uses string for formatting too?
07:31:18 <navaati> jackss, yeah, it's all the same
07:31:35 <`nand`> ooh ooh ooh
07:31:48 <`nand`> a type-level printf that uses Sing Symbol or something would be super cool
07:31:54 <`nand`> oh, assuming we get the ability to actually work with them
07:32:31 * `nand` wants all of the Haskell prelude on the type level
07:32:44 <navaati> `nand`, uh, now we'll start to wonder "should i use TH or type level hackery to do this", that's becoming crazy ^^"
07:33:10 <`nand`> navaati: disclaimer: I don't write any actual programs, I just spend the day doing hackery
07:33:18 <`nand`> because that's the fun part
07:33:30 <navaati> don't we all here do this ?
07:33:40 <`nand`> some of us have actual jobs
07:33:45 <`nand`> or write libraries that are actually used
07:33:48 <navaati> ah, they cheat
07:34:32 <navaati> eh, look at edwardk's reflection library, it's type hackery *and* it's used, isn't it ?
07:34:47 <`nand`> reflection is used? ;)
07:34:53 <`nand`> and it's only fast because he cheats. a lot
07:35:11 <`nand`> oh, you never said anything about it being fast or not
07:35:16 * `nand` must have been hallucinating
07:35:46 <navaati> yeah, actually for this one he hacked hackery…
07:36:10 <navaati> wondering : does "fast" in this case mean at runtime or compile time ?
07:37:33 <Taneb> Runtime, I think
07:41:25 <edwardk> reflection is fast at runtime. (its 2-3 orders of magnitude faster than the paper it is based on)
07:41:48 <`nand`> navaati: probably both ;)
07:41:48 <Taneb> 2-3 orders of magnitude
07:41:57 <`nand`> the ‘slow’ version is really, REALLY ugly
07:41:58 <Taneb> That's like, 300 times
07:42:40 <Hafydd> > 10**2.5
07:42:42 <lambdabot>   316.22776601683796
07:42:46 <`nand`> uses unsafePerformIO and stable pointers to store dictionaries somewhere in memory, then simulates type-level integers with a bunch of class instances to get them back again
07:43:16 <mm_freak> in lambda calculus what's the normal form of (\x -> (\y -> y) x)?
07:43:20 <`nand`> the ‘fast’ version just uses a single unsafeCoerce to convers “C => a -> b” to “c -> a -> b” (which is how GHC implements them internally)
07:43:24 <`nand`> it's like two lines
07:43:31 <edwardk> @tell mm_freak I use nf (Lam b) = Lam (toScope (nf (fromScope b)))  in examples/Simple.hs
07:43:31 <lambdabot> Consider it noted.
07:43:37 <jackss> how does template haskell compare to lisp macros?
07:43:47 <navaati> yeah, i've read the code, it was pretty funny to see
07:43:50 <Taneb> mm_freak, it reduces to the identity function
07:44:29 <navaati> damn, "instance HasResolution (n :: Nat) where resolution _ = fromSing (sing :: Sing n)" doesn't work…
07:44:31 <mm_freak> edwardk: using the same now
07:44:32 <lambdabot> mm_freak: You have 1 new message. '/msg lambdabot @messages' to read it.
07:44:41 <Hafydd> Define the normal form of a Lambda calculus term.
07:44:59 <navaati> Kind mis-match, The first argument of `HasResolution' should have kind `*', but `n' has kind `Nat'
07:45:28 <mm_freak> Taneb: that doesn't really answer my question…  are the bodies of unapplied lambdas reduced as well?
07:45:46 <Taneb> I'm afraid I don't really know
07:46:53 <Taneb> It beta reduces to \x -> x in one step
07:47:41 <edwardk> mm_freak: for nf, yes
07:47:53 <edwardk> mm_freak: see the bound examples folder, the simple example
07:48:38 <t7> > 512 * 3
07:48:39 <lambdabot>   1536
07:48:48 <copumpkin> what's the normal form of (\x -> x x) (\x -> x x)?
07:49:38 <navaati> copumpkin, it loops, right ?
07:49:56 <copumpkin> well, it reduces to itself
07:49:59 <bitonic> no normal form :(
07:50:15 <Taneb> (unsafeCoerce <*> unsafeCoerce) (unsafeCoerce <*> unsafeCoerce)
07:50:29 <mapf> why there are no newtype family?
07:50:41 <copumpkin> mapf: there are
07:50:49 <navaati> :t unsafeCoerce <*> unsafeCoerce
07:50:50 <lambdabot> Not in scope: `unsafeCoerce'
07:50:50 <lambdabot> Not in scope: `unsafeCoerce'
07:50:52 <copumpkin> data family Moo a :: *
07:50:59 <copumpkin> newtype instance Moo Int = Bar Double
07:51:22 <Taneb> navaati, a -> b
07:51:36 <Taneb> It's a fixed point operator
07:51:40 <Taneb> That is insane
07:51:56 <copumpkin> SII(SII)
07:51:57 <mapf> copumpkin: hell, indeed
07:51:59 <mapf> thanks
07:58:04 <meyersh_afk> @src elem
07:58:05 <lambdabot> elem x    =  any (== x)
07:59:52 <navaati> can i express in a constraint that t is of kind k ?
08:00:15 <hkBst__> what English language term abstracts function, class, expression, statement, subroutine, line of code, etc. is language neutral and makes sense to lays?
08:01:42 <PatrickRobotham> program?
08:01:47 <earthy> algorithm?
08:01:49 <earthy> instruction?
08:01:54 <t7> Statement
08:02:02 <earthy> action?
08:02:04 <t7> remember an expression can be a statement
08:02:32 <earthy> the better question would be 'why would you want to abstract over all those things?'
08:02:37 <byorgey> hkBst__: there is no such term.
08:02:44 <earthy> (as some of them are quite different)
08:03:12 <Hafydd> "software" is reminiscent of undergaments.
08:03:31 <Taneb> I'm wearing really comfy software
08:03:39 <meyersh_afk> hkBst__: source code?
08:05:14 <hkBst__> I'm trying to find a better term than "piece of source code", "source code element", "source code entity"...
08:05:38 <Taneb> "extract"?
08:06:41 <Taneb> I'm annoyed about how low-level I'm going to be programming
08:06:42 <Hafydd> Program element? Program component? Part of a program?
08:06:55 <navaati> why does ":t Proxy" gives me "Proxy :: Proxy * s" instead of "Proxy :: Proxy s" in ghc 7.6 ?
08:07:11 <geekosaur> code block/block of code?
08:07:40 <Taneb> navaati, is -XPolyKinds enabled?
08:08:13 <edwardk> Taneb: in 7.6 tagged compiles with polykinds turned on
08:08:13 <Taneb> Or kind signatures, actually
08:08:49 <edwardk> navaati: in 7.6. you can instantiate Proxy to other kinds. such as Proxy :: Proxy Monad
08:08:56 <edwardk> or Proxy :: Proxy Maybe
08:09:06 <Taneb> You can instantiate it to a constraint?
08:09:10 <Taneb> I guess that makes sense
08:09:18 <edwardk> Taneb: if you turn on constraint kinds and polykinds, yes
08:09:52 <Taneb> I need to figure out how to use constraintKinds
08:10:29 <hkBst__> thanks everyone for your suggestions
08:11:13 <mm_freak> edwardk: dunno why, but i like to figure these things out by myself without reading examples
08:11:22 <mm_freak> that's why i prefer to ask =)
08:12:02 <LucaS05> hi
08:12:17 <edwardk> mm_freak: fair enough.
08:12:48 <Taneb> Is there a slow-paced ConstraintKinds tutorial floating about t'interwebs anyway?
08:12:51 <edwardk> basically you shouldn't have to hand-unpack a Scope for 99% of the things you want to do with it. abstract, instantiate, fromScope, toScope, lift and (>>=) should be able to do everything
08:12:58 <edwardk> and (>>>=)
08:13:30 <mm_freak> yeah
08:14:43 <mm_freak> i implemented a special case of Scope myself, but it's some time ago
08:15:05 <mm_freak> in particular i didn't think of the 'b' parameter, which is actually very handy for multi-lets
08:15:14 <jackss> > show 10
08:15:15 <lambdabot>   "10"
08:15:18 <LucaS05> i'm doing this exercise (i don't know if it's corret right now) http://pastebin.com/L1nmDEeu anyway it gives me this error: Invalid type signature [...] Should be of form <variable> :: <type>
08:16:28 <ion> byorgey: Oh, i forgot it is different in 3.6 and i have been using the HEAD version of lens. Sorry for the noise. :-)
08:16:29 <FireFly> @ty (>>>=)
08:16:31 <lambdabot>     Not in scope: `>>>='
08:16:31 <lambdabot>     Perhaps you meant one of these:
08:16:31 <lambdabot>       `>>=' (imported from Control.Monad.Writer),
08:16:39 <mm_freak> FireFly: 'bound' package
08:16:52 <mm_freak> it's for substitution inside a scope
08:16:55 <jackss> > map show [1..]
08:16:56 <lambdabot>   ["1","2","3","4","5","6","7","8","9","10","11","12","13","14","15","16","17...
08:18:37 <FireFly> mm_freak: I see
08:23:58 * hackagebot scrypt 0.3.5 - Stronger password hashing via sequential memory-hard functions.  http://hackage.haskell.org/package/scrypt-0.3.5 (FalkoPeters)
08:24:55 <Taneb> I guess it's time for me to look at the scary Foreign.* stuff
08:30:02 <LucaS05> someone could help me?
08:30:12 <Taneb> Probably
08:30:14 <Taneb> What with?
08:33:40 <LucaS05> i'm doing this exercise (i don't know if it's corret right now) http://pastebin.com/L1nmDEeu anyway it gives me this error: Invalid type signature [...] Should be of form <variable> :: <type>
08:33:58 * hackagebot sqlite-simple 0.2.1.0 - Mid-Level SQLite client library  http://hackage.haskell.org/package/sqlite-simple-0.2.1.0 (JanneHellsten)
08:35:15 <Taneb> LucaS05, you're, I'm afraid, way off the mark
08:35:42 <LucaS05> i've started with haskell two days ago
08:35:48 <Taneb> Heh, fair enough
08:35:52 <Taneb> :t (:)
08:35:53 <lambdabot> a -> [a] -> [a]
08:36:03 <Taneb> Now, how are you using (:)?
08:36:23 <LucaS05> i'm usign it with map
08:36:28 <LucaS05> using
08:36:49 <Taneb> What type do you think the left hand side is?
08:37:07 <LucaS05> i think is a list
08:37:12 <LucaS05> of only one elemnt
08:37:19 <LucaS05> the head of the list
08:37:28 <LucaS05> i think....
08:37:41 <LucaS05> (maybe i'm wrong)
08:38:13 <Taneb> It's a list of any number of elements
08:38:23 <elliott> LucaS05: it's a type error
08:38:25 <Taneb> filter and map assume x is a list
08:38:43 <elliott> "x" isn't a list, "xs" is
08:39:06 <elliott> (yes, yes, "x" could be a list, since the function is polymorphic)
08:39:15 <elliott> (but that does not really matter here)
08:39:59 <mapf> how to specify kind in function signature? for exsample test :: (T (a :: Nat)) -> Int
08:40:05 <LucaS05> so the right side of the cons (:) is useless?
08:40:12 <Taneb> No, the left
08:40:20 <Taneb> (:) wants a single thingy
08:40:22 <Taneb> Not a list
08:40:22 <LucaS05> sorry the left yes ;)
08:40:38 <Taneb> Also, I don't think that does what you want it to do at all
08:40:53 <Taneb> What does [f x | x <- xs, p x] do?
08:41:03 <mapf> test :: Nat ~ a => T a -> Int -- doesn't work as well
08:41:06 <elliott> LucaS05's solution is close.
08:41:19 <elliott> the problem is the type signature, and the first argument to (:)
08:41:29 <LucaS05> it applies the function f to the elements of the list if the predicate is true
08:41:42 <elliott> (well, technically fixing these two problems would result in an imperfect solution, but it'd still work.)
08:42:17 <Taneb> LucaS05, so, it tests each element of the list with the predicate, and removes the ones that don't satisfy it, before applying the function, right?
08:42:42 <LucaS05> yes
08:43:29 <Taneb> So, if you have a predicate and a list, how do you get a list that's like the old list but only has elements that satisfy the predicate?
08:43:50 <rwbarton> mapf: forall a :: Nat. T a -> Int -- I guess
08:43:58 * hackagebot happstack-authenticate 0.9.8 - Happstack Authentication Library  http://hackage.haskell.org/package/happstack-authenticate-0.9.8 (JeremyShaw)
08:44:35 <robbe-> Is it a haskellish thing to put only a typeclass in a module? For example the graph typeclass in Grap
08:44:38 <elliott> I think that has to be (a :: Nat)
08:44:38 <robbe-> grr
08:44:47 <rwbarton> is T kind-polymorphic or something? because normally the kind of a would be inferred
08:44:50 <rwbarton> quite possibly
08:44:51 <elliott> I'm not sure you can actually do this even?
08:44:56 <elliott> well
08:44:56 <rwbarton> @type fmap
08:44:58 <lambdabot> Functor f => (a -> b) -> f a -> f b
08:45:01 <rwbarton> oh what
08:45:01 <elliott> you can do T (a `AsKindOf` 1)
08:45:05 <robbe-> Is it a haskellish thing to put only a typeclass in a module? For example the graph typeclass in Graph/Class.hs and the adjacency matrix in Graph/AdjMatrix.hs
08:45:15 <mapf> rwbarton: T :: Nat -> *
08:45:18 <elliott> using the AsKindOf trick
08:45:26 <rwbarton> so why do you need the kind signature on a at all
08:45:26 <elliott> mapf: then you don't need the signature
08:45:33 <robbe-> (Sorry for posting twice, as I hit the return key by accident.)
08:45:47 * elliott wonders if AsKindOf is anywhere on Hackage yet
08:46:12 <LucaS05> i've to test the predicate on each element of the list
08:46:51 <mapf> oh, yes.
08:46:55 <mapf> thx
08:50:15 <sweaty_emperor> From LYAH: "reverseWords = unwords . map reverse . words". He doesn't assign a variable, like "xs" (type string in this instance). Every time I try to make version that keeps the function composition but uses a variable I get an error
08:50:48 <sweaty_emperor> in example: reverseWords xs = unwords . map reverse . words xs
08:50:54 <sweaty_emperor> That's just one variation I've tried
08:50:56 <elliott> sweaty_emperor: That's because that's unwords . map reverse . (words xs)
08:51:04 <elliott> You want to apply the whole composition chain to xs, not just one part of it
08:52:39 <sweaty_emperor> This still doesn't compile: unwords . map reverse . (words xs). I'll paste
08:53:07 <hpaste> me pasted “revers.hs” at http://hpaste.org/78852
08:53:18 <Botje> sweaty_emperor: because it's equivalent to reverseWords xs y = unwords ( map reverse ( words xs y))
08:53:20 <mSSM> Does it make sense to use do-notation in a stateful computation? e.g.: foo = state \x -> do {...} ; what would the type would the return in there be?
08:53:21 <LucaS05> i've changed with this http://pastebin.com/bfhriYP7
08:54:12 <elliott> sweaty_emperor: That was an example of what you had done wrong, not a solution
08:54:22 <LucaS05> and it gives me this quite strange error http://pastebin.com/FdKHVcFp
08:54:25 <sweaty_emperor> Oh
08:54:31 <elliott> Your "unwords . map reverse . words xs" is equivalent to "unwords . map reverse . (words xs)", which isn't right :)
08:54:37 <elliott> since, like Botje says, it expands to the wrong thing
08:54:46 <elliott> Because function application binds tighter than .
08:56:56 <sweaty_emperor> elliot: so how does the variable fit in there (keeping the same structure)?
08:57:10 <elliott> sweaty_emperor: Well, it's just an operator precedence problem.
08:57:34 <elliott> a + b * c is a + (b * c), but you want to multiply a + b by c. So what do you do instead?
08:59:24 <sweaty_emperor> Okay, I read you elliot. But why would it work as given: "unwords . map reverse . words" as long as no variable is used? An implied variable has to go SOMEWHERE right? And it obviously works without changing that structure
08:59:33 <elliott> Do you know what (.) does?
08:59:46 <Botje> sweaty_emperor: I showed you above what it expands to.
08:59:52 <elliott> If you do "foo = func1 . func2", then "foo x" is "func1 (func2 x)".
08:59:52 <Botje> 17:53 < Botje> sweaty_emperor: because it's equivalent to reverseWords xs y =  unwords ( map reverse ( words xs y))
08:59:56 <elliott> It composes the two functions.
09:00:05 <elliott> That is, (f . g) x = f (g x)
09:00:14 <sweaty_emperor> needsA takesBgivesA B
09:00:15 <sweaty_emperor> like that?
09:00:33 <rwbarton> there are no "implied variables"
09:00:34 <elliott> So "reverseWords = unwords . map reverse . words" is the same as "reverseWords xs = unwords (map reverse (words xs))".
09:00:43 <elliott> Just because that's how the (.) operator is defined.
09:03:42 <andsens> Is there any way to make Prasec tokens not use a lexeme parser?
09:03:48 <andsens> *Parsec
09:06:08 <LucaS05> someone could help me?
09:06:51 <markfoley94> john levine
09:06:57 <Botje> LucaS05: the ads on that page are really annoying :(
09:07:14 <Botje> LucaS05: you do "filter p xs"
09:07:26 <Botje> LucaS05: xs is of type [a], and p is of type (c -> Bool)
09:07:35 <geekosaur> LucaS05, as far as I see, you are applying a filter (c -> Bool) to a list of [a]
09:07:39 <Botje> LucaS05: you cannot apply a function of type c -> Bool to a value of type a.
09:07:43 <geekosaur> maybe you want the filter *after* the map?
09:07:44 <LucaS05> sorry is the first site that has come to me in mind.
09:07:49 <geekosaur> @paste
09:07:49 <lambdabot> Haskell pastebin: http://hpaste.org/
09:08:25 <frihd> hey, I'm trying to bootstrap a haskell user group in Paris. hence if you want to meet and chat about haskell, please fill-in this doodle http://www.doodle.com/h5vdxr64tdn6kmv5  (description is in French)
09:08:36 <geekosaur> ("after" meaning "to the left of" so it operates on the result of the map)
09:08:59 * hackagebot test-framework 0.8 - Framework for running and organising tests, with HUnit and QuickCheck support  http://hackage.haskell.org/package/test-framework-0.8 (MaxBolingbroke)
09:09:01 * hackagebot test-framework-quickcheck2 0.3.0.1 - QuickCheck2 support for the test-framework package.  http://hackage.haskell.org/package/test-framework-quickcheck2-0.3.0.1 (MaxBolingbroke)
09:09:48 <LucaS05> but if i filter after the map i got wrong results
09:10:04 <LucaS05> cause i've to first filter the values and the apply the function
09:10:13 <LucaS05> then
09:10:40 <asdf___> hello?
09:10:57 <asdf___> anyone here in strathclyde uni?
09:11:12 <asdf___> I'm eating tuna out a tin.
09:11:17 <geekosaur> LucaS05, then you need to change your filter function, because a filter on (c -> Bool) cannot be applied to a list [a]
09:11:58 <LucaS05> but a filter is defined as (c -> Bool)
09:11:59 <geekosaur> how exactly were you expecitng that to work?
09:12:16 <geekosaur> so why do you expect it to work on an [a]?
09:13:15 <LucaS05> i'm doing this http://hpaste.org/new
09:13:27 <geekosaur> in fact your predlist type signature is generally confused
09:14:38 <geekosaur> you have a list [a] going in; smehow you're expecting [c]s to pop out of it, and you have a function that makes a b from an a but doesn't ever do anything with the b?
09:14:51 <geekosaur> and you didn't use hpaste right; did you submit the paste?
09:15:05 <geekosaur> (that's the page for entering a neew paste; if I go there I will get a new empty paste)
09:15:06 <glguy> LucaS05 authored this paste, at least: http://hpaste.org/78850
09:15:46 <geekosaur> and that one is even worse.  you start with an n, and you have a -> b and c -> d that come from nowhere?
09:16:00 <geekosaur> and end up with an e that also has no connection to anything else
09:17:56 <LucaS05> this is what i'm doing http://hpaste.org/78855
09:18:15 <geekosaur> LucaS05, could you explain what you intended that type signature to mean?
09:18:48 <LucaS05> geekosaur sorry but i'm a newbie i've started with haskell two days ago ;)
09:19:36 <LucaS05> for me that means that predlist is a function that takes three argument: a function another function that is the predicate and a list and then return a list
09:20:22 <geekosaur> so, a type signature needs to make a certain kind of sense.  you can't start with an [a] and suddenly start referring to the type of its elements as c, haskell cannot guess that you intended them to represent the same type.  if you intended them to be the same type, use the same type variable for them
09:21:11 <LucaS05> oh thanks!
09:21:43 <LucaS05> but i've to express that only for the list and the predicate cause the function can have differente argument
09:21:45 <rwbarton> LucaS05, it does say that. but there is more that needs to be said. more than just "function and function and list and list"
09:22:18 <rwbarton> compare the type of map
09:22:19 <rwbarton> @type map
09:22:21 <lambdabot> (a -> b) -> [a] -> [b]
09:22:44 <rwbarton> not for example (a -> b) -> [n] -> [e]
09:23:36 <rwbarton> because there is a relationship between the type of the elements of the input list, the type of the elements of the output list, and the type of the function
09:23:52 <geekosaur> note that this does not mean that the filter itself will forever be forced to that; it just has to be compatible with it when it
09:23:53 <geekosaur> 's used
09:24:08 <geekosaur> or in this case the mapping function
09:24:13 <mSSM> Should the following be a Stateful computation, or do I mix something up? I have a state s, e.g. s=[Int], and some external var x. If f(s,x) > 0, then s is changed. If not, s remains the same. And now I want to perform this operation 1000 times in a row. Does it make sense to use State for that?
09:24:23 <LucaS05> so i've to remove the filter?
09:24:30 <LucaS05> sory
09:24:34 <geekosaur> noi
09:24:34 <LucaS05> the predicate
09:24:42 <geekosaur> you have to give it a sane type
09:25:19 <elliott> mSSM: sure
09:25:29 <hpaste> mapf pasted “GHC internal error” at http://hpaste.org/78856
09:25:36 <geekosaur> note also that the type variable(s) used in one type signature are local to that signature.  if you have filter :: (a -> Bool) -> [a] -> [a] then that "a" has nothing to do with an "a" anywhere else
09:25:36 <LucaS05> ok so if i understand the right signature for the function is: predlist :: (a -> b) -> (a -> Bool) -> [a] -> [b]
09:25:37 <elliott> mSSM: it may be less overhead to skip State though
09:25:54 <geekosaur> that makes much more sense, yes
09:26:13 <mapf> i'm a debian zealot and have 7.4. Does that bug is fixed?
09:26:15 <elliott> mSSM: but you can write that like this: foo = do { s <- get; guard (fs x > 0) $ put (... new s...) }
09:26:21 <LucaS05> it makes sense and i hope is correct! i'm going to try it ;)
09:26:24 <elliott> *f s x
09:27:01 <mSSM> elliott: Well, my example is unfortunately more complex and I am really struggling to implement it properly. :(
09:27:52 <elliott> how do you change s? i.e. how do you compute the new s if f(s,x) > 0
09:27:52 <mSSM> elliott: The whole idea of why I wanted to use state is so I can use ReplicateM
09:27:58 <elliott> and where does this x come from
09:28:02 <mapf> is that code works well with new ghc?
09:28:37 <elliott> mapf: no error with GHC 7.6.1
09:28:39 <LucaS05> ok now it works!
09:28:49 <LucaS05> thanks geekosaur!
09:29:08 <elliott> mapf: fwiw, you do not need to define List.
09:29:18 <elliott> you can use [] and (x ': xs) in your type instances
09:29:20 <LucaS05> so if understand "a" is every element of the list
09:29:30 <elliott> then TpLs '[Int, String, Char] or whatever
09:29:54 <mapf> hm, ExistentialQuantification with DataKinds works with together but cause ghc cry
09:30:18 <LucaS05> http://hpaste.org/78858
09:30:18 <mapf> elliott: well, i'll try it
09:30:45 <mapf> also should i report maybe?
09:30:58 <mSSM> elliott: http://hpaste.org/78857 here is the beast; I am trying to make mcStep on line 16 into a stateful computation
09:31:31 <elliott> hm, why are you using state there?
09:31:31 <mSSM> elliott: the idea is that updateIsing on line 1 can use the outcome of mcStep to perform an update.
09:31:32 <elliott> :t state
09:31:33 <lambdabot> MonadState s m => (s -> (a, s)) -> m a
09:31:45 <elliott> your code is an obvious type error, it looks like?
09:31:51 <sannysanoff> hi folks, how to utilize free theorem generator in lambdabot; i tried to generate function to provide a->[a], but could not.
09:31:59 <mSSM> elliott: yeah, it is so far
09:32:25 <mSSM> elliott: that mcStep is plain wrong, but I can for my life figure out how to write this... so I guess I started out all wrong.
09:32:32 <mSSM> cannot*
09:33:55 <elliott> mSSM: you need to use StateT Blah IO, not State, at least
09:34:02 <elliott> since you want to do IO inside your stateful computation, you need the monad transformer
09:34:40 <LucaS05> anyway i don't know how to correctly call my function http://hpaste.org/78858
09:34:43 <glguy> sannysanoff: The generator is “djinn” and it isn’t going to be able to write a function of a->[a]
09:35:01 <beaky> I love haskell
09:35:10 <beaky> @djinn A -> B -> A
09:35:10 <lambdabot> Error: Undefined type A
09:35:14 <beaky> :(
09:35:18 <mSSM> elliott: I don't necessarily need to use IO... I just used it there because I didn't know how to create a random number and return it any better
09:35:19 <glguy> A isn’t a type variable
09:35:29 <beaky> @djinn a -> b -> a
09:35:29 <lambdabot> f a _ = a
09:35:32 <beaky> oh
09:35:33 <mapf> elliott: but how should i specify kind in TF header? type family TF (e :: [a]) doesn't works
09:35:42 <elliott> [*]
09:35:50 <beaky> @djinn [a] -> a
09:35:50 <lambdabot> Error: Undefined type []
09:36:02 <beaky> @djinn a -> b -> c -> c -> b -> a
09:36:02 <lambdabot> f a _ _ _ _ = a
09:36:07 <beaky> O.o
09:36:34 <FireFly> @djinn (a -> b) -> a -> b
09:36:34 <lambdabot> f a = a
09:36:36 <sannysanoff> glguy: this is not cool.
09:36:53 <elliott> djinn is very cool
09:37:08 <glguy> sannysanoff: I don’t think you understand what djinn is for, but it’s pretty neat
09:37:23 <sannysanoff> glguy: maybe ;-(
09:37:29 <mapf> elliott: nice, thanks
09:37:42 <rwbarton> [a] is logically useless anyways. need to produce an [a], how about []. get to consume an [a], well it may be [], so cannot do anything with it
09:37:54 <rwbarton> you can replace [a] by () before feeding your type to djinn
09:38:10 <elliott> well djinn tries to use all parameters
09:38:18 <elliott> so if it "could" do a -> [a], it'd give you pure
09:38:27 <rwbarton> well that's just some random heuristic
09:38:28 <sannysanoff> rwbarton: thanks, got it.
09:38:29 <elliott> yeah
09:38:35 <rwbarton> not really part of the core problem that it solves
09:39:19 <rwbarton> you can replace with Maybe a too
09:39:22 <rwbarton> equally useless
09:39:25 <rwbarton> @djinn a -> Maybe a
09:39:25 <lambdabot> f = Just
09:39:29 <rwbarton> and verify elliott's claim
09:40:44 <LucaS05> i'm a totally beginner (i come from imperative paradigms) and i'm finding very difficult this new paradigm that haskell implement
09:40:53 <LucaS05> maybe only at the start! ;)
09:41:21 <mSSM> If I produce a random number, e.g. through the use of `uniform' from MWC random, can I somehow bind the result and then continue making _non_monadic_ computations? I somehow end up binding this, and the return type is all IO x from there (and I don't even want IO).
09:41:49 <mSSM> It's seems wrong.
09:42:55 <elliott> mSSM: Well, your computation depends on a random number.
09:42:57 <ion> @djinn a -> Maybe b
09:42:57 <lambdabot> f _ = Nothing
09:43:01 <sannysanoff> @djinn Monad m => (a -> b) -> m a -> m b
09:43:01 <lambdabot> -- f cannot be realized.
09:43:03 <S11001001> mSSM: it's what fmap/liftM is for.
09:43:04 <elliott> It isn't pure: it's not a single Int.
09:43:11 <glguy> mSSM: If you compute one of your arguments using IO, then your result will be in IO, too
09:43:13 <elliott> It's a computation you can run to produce an int: IO Int.
09:44:10 <sannysanoff> @djinn Maybe m => (a -> b) -> m a -> m b
09:44:10 <lambdabot> Error: Class not found: Maybe
09:44:16 <sannysanoff> oh
09:44:32 <sannysanoff> @djinn (a -> b) -> Maybe a -> Maybe b
09:44:33 <lambdabot> f a b =
09:44:33 <lambdabot>     case b of
09:44:33 <lambdabot>     Nothing -> Nothing
09:44:33 <lambdabot>     Just c -> Just (a c)
09:45:48 <sannysanoff> no knowledge of fmap
09:46:01 <rwbarton> mSSM: you can separate out the rest of the computation as a pure function
09:46:03 <S11001001> @ty fmap
09:46:05 <lambdabot> Functor f => (a -> b) -> f a -> f b
09:46:46 <mSSM> Ok, so the difference is that I make all the rest pure, and then promote it using LiftM
09:46:50 <S11001001> @ty flip fmap (undefined :: IO Int)
09:46:51 <lambdabot> (Int -> b) -> IO b
09:47:00 <mSSM> But I can't make something impure pure... Guess that makes sense
09:47:50 <S11001001> @ty flip liftA2 (undefined :: IO Int)
09:47:51 <lambdabot> (Int -> b -> c) -> IO b -> IO c
09:50:15 <rwbarton> sannysanoff, djinn doesn't need fmap, it proves things from first principles :)
09:51:28 <sannysanoff> rwbarton: i have no more questions for djinn... ;)
09:56:06 <quchen> @djinn a -> a
09:56:06 <lambdabot> f a = a
09:56:13 <quchen> @djinn (a,b) -> a
09:56:13 <lambdabot> f (a, _) = a
09:56:26 <quchen> @djinn a -> a -> a
09:56:26 <lambdabot> f _ a = a
09:56:31 <quchen> He!
09:56:43 <quchen> That's not very unique.
09:57:28 <quchen> @djinn Maybe a -> a
09:57:28 <lambdabot> -- f cannot be realized.
09:57:36 <quchen> @djinn Maybe a -> Bool
09:57:36 <lambdabot> f a =
09:57:36 <lambdabot>     case a of
09:57:36 <lambdabot>     Nothing -> False
09:57:36 <lambdabot>     Just _ -> True
09:57:59 <quchen> That could also be switched around.
09:58:02 <quchen> Hmm
09:58:16 <Hafydd> @djinn Int -> Int
09:58:16 <lambdabot> Error: Undefined type Int
09:58:28 <rwbarton> contrary to popular belief, a Haskell function's behavior is not completely determined by its type signature
09:58:40 <Hafydd> @djinn Integer -> Integer
09:58:40 <lambdabot> Error: Undefined type Integer
09:58:54 <Hermit> rwbarton: like with unsafePerformIO?
09:59:05 <quchen> rwbarton: So what does Djinn do? I thought it gives you the only sensible definition of a function of a certain type (i.e. no bottoms etc)
09:59:26 <rwbarton> it gives you *some* function of the type if there is one and otherwise tells you there isn't one
09:59:39 <quchen> Ah, I see
10:01:10 <quchen> @djinn Bool -> Maybe a
10:01:11 <lambdabot> f _ = Nothing
10:01:35 <quchen> @djinn a -> b -> (a,b) -> (a,b)
10:01:35 <lambdabot> f a b _ = (a, b)
10:01:42 <quchen> @djinn a -> b -> (a,c) -> (a,b)
10:01:43 <lambdabot> f a b _ = (a, b)
10:01:48 <quchen> @djinn a -> c -> (a,b) -> (a,b)
10:01:48 <lambdabot> f _ _ (a, b) = (a, b)
10:02:01 <quchen> @djinn b -> c -> (a,c) -> (a,b)
10:02:01 <lambdabot> f a _ (b, _) = (b, a)
10:02:14 <quchen> Impressive :-)
10:03:36 <simpson> @djinn (s -> (s, a)) -> a -> s -> (s, b)
10:03:36 <lambdabot> -- f cannot be realized.
10:04:00 <simpson> Oh, duh that's not gonna realize.
10:04:00 * hackagebot hlint 1.8.39 - Source code suggestions  http://hackage.haskell.org/package/hlint-1.8.39 (NeilMitchell)
10:15:06 <kuznero> Hi All!
10:15:27 <Cale> hello
10:18:40 <kuznero> I'm trying to `cabal build` my project in which I start using wx (wxHaskell covering wxWidgets) package.... It also happened that I have some built-in resources (embed-file package) based on template haskell... So, when I'm calling cabal build it tries to load all packages defined in build-depends... which in turn fails loading wxc-0.90.0.4.... Can anybody help me with this ugly one?
10:19:16 <kuznero> `ghc --make` though works just fine...
10:20:44 <kuznero> Anybody?
10:21:48 <kuznero> It's saying that it cannot load wxc-0.90.0.4 ... can't load .so/.DLL for .../libwx_gtk2u_xrc-2.9.so
10:22:34 <kuznero> I'm thinking - can it be that cabal is x32 whether ghc is x64?
10:23:04 <andsens> what is the simplest way of creating a digest from a long string?
10:23:12 <qwr> kuznero: file blaah.so
10:23:22 <qwr> kuznero: tells you what format it is
10:23:51 <kuznero> qwr: yep, it's there - exists. file is a shared lib that is normally linked on compilation...
10:24:48 <rwbarton> some packages that are linked against C libraries don't seem to get along well with ghci/dynamic code loading/TH
10:25:39 <kuznero> rwbarton, does it mean that cabal facilities will not function? Is there any workarounds to fix it somehow?
10:26:34 <kuznero> Is it possible to say that I want these libs to be statically linked instead of dynamically? Not sure though if it will make any difference...
10:29:01 * hackagebot attoparsec-csv 0.1.0.1 - A parser for CSV files that uses Attoparsec  http://hackage.haskell.org/package/attoparsec-csv-0.1.0.1 (RobinBateBoerop)
10:30:32 <kuznero> Hm... then if one of the causes is template haskell who's unable to pre-load c-linking packages... maybe there is a way (or package) that could embed resources without using template haskell? The one I'm using now is called embed-file
10:32:26 <cads> andsens, maybe modding the string against some integer?
10:33:30 <kuznero> Ok, then I will try asking from another end... Is cabal files is de facto standard of describing packages in haskell? My idea is that if cabal cannot build such things, maybe there is something else that can (potentially)?
10:34:09 <andsens> cads: heh, that's a pretty cool idea. I am using sha1 right now.
10:34:29 <andsens> I'm not sure how unique the modding well be though
10:35:03 <andsens> *will
10:35:23 <kuznero> Maybe somebody knows if there is some other IRC channel discussing wxHaskell?
10:36:01 <Taneb> Okay, SDL isn't powerful enough for what I want to use it for...
10:36:54 <Taneb> And GTK seems a tad overkill
10:44:44 <LucaS05> i'm trying to redefine map using foldr http://hpaste.org/78861
10:45:30 <Iceland_jack> Is there a neat way of finding the first element of a list that is the same as the one before it?
10:45:45 <LucaS05> this is not correct cause it gives me this error http://hpaste.org/78862
10:45:50 <LucaS05> wha'ts the problem?
10:46:35 <Iceland_jack> I'm running a rewriter for typed assembly using something like: iterate rewrite initialMachine
10:46:48 <Iceland_jack> and no change means it has a result
10:48:10 <Iceland_jack> Something like “same [1,2,3,2,4,4] → 4” for same :: (Eq a) => [a] -> a
10:48:11 <glguy> > let f xs = listToMaybe [x0 | x0:x1:_ <- tails xs, x0 == x1] in f [1,2,3,3,4,5,5,6]
10:48:13 <lambdabot>   Just 3
10:48:37 <Iceland_jack> hm, no built-in function that does this?
10:49:12 <glguy> hopefully not
10:49:15 <rwbarton> why would there be
10:49:47 <Cale> > group [1,2,3,2,4,4]
10:49:48 <lambdabot>   [[1],[2],[3],[2],[4,4]]
10:49:52 <Iceland_jack> Because I think running evaluations using iterate is a nice idiom
10:49:56 <Cale> > map (drop 1) . group [1,2,3,2,4,4]
10:49:58 <lambdabot>   No instance for (GHC.Num.Num [a0])
10:49:58 <lambdabot>    arising from a use of `e_11123244'
10:49:58 <lambdabot>  P...
10:50:03 <Cale> > map (drop 1) . group $ [1,2,3,2,4,4]
10:50:05 <lambdabot>   [[],[],[],[],[4]]
10:50:08 <elliott> Iceland_jack: your evaluator should have a Maybe result or something
10:50:09 <Cale> > concatMap (drop 1) . group $ [1,2,3,2,4,4]
10:50:11 <lambdabot>   [4]
10:50:14 <Cale> > head .concatMap (drop 1) . group $ [1,2,3,2,4,4]
10:50:15 <elliott> so you can tell when it cannot reduce further
10:50:17 <lambdabot>   4
10:50:35 <Cale> lol, I can't type today.
10:51:20 <Cale> > drop 1 <=< group $ [1,2,3,2,4,4]
10:51:22 <lambdabot>   [4]
10:51:38 <Cale> > head . (drop 1 <=< group) $ [1,2,3,2,4,4]
10:51:39 <Iceland_jack> Should have a Maybe result..
10:51:40 <lambdabot>   4
10:51:41 <Iceland_jack> No
10:51:50 <Cale> > listToMaybe . (drop 1 <=< group) $ [1,2,3,2,4,4]
10:51:52 <lambdabot>   Just 4
10:51:55 <Cale> > listToMaybe . (drop 1 <=< group) $ [1,2,3,2,4,]
10:51:56 <Cale> > listToMaybe . (drop 1 <=< group) $ [1,2,3,2,4]
10:51:57 <lambdabot>   <hint>:1:47: parse error on input `]'
10:51:58 <lambdabot>   Nothing
10:52:02 <Iceland_jack> Evaluating something in normal form should not result in Nothing
10:52:15 <glguy> :t \f x -> fst $ until (uncurry (==)) (\(a,b) -> (b,f b)) (x, f x)
10:52:17 <lambdabot> Eq b => (b -> b) -> b -> b
10:53:04 <Iceland_jack> So no, my evaluator will always return a result: not a Maybe type
10:53:37 <elliott> Iceland_jack: you can easily write a wrapper function that has the behaviour you want
10:53:45 <elliott> (returning normal form stuff as it is)
10:54:04 <glguy> > let keep_applying f x = fst $ until (uncurry (==)) (\(a,b) -> (b,f b)) (x, f x) in keep_applying (`div` 2) 10
10:54:05 <lambdabot>   0
10:54:07 <elliott> if you want to do it inefficiently you'll have to write your own combinator :P
10:54:27 <Iceland_jack> I suppose, a middle ground would be to have any value not in NF be called recursively
10:54:35 <Iceland_jack> until there are no further rewrite rules
10:54:58 <elliott> you can do big-step evaluation rather than small-step, yes
10:55:46 <Iceland_jack> Either way, I prefer conceptually to have an infinite stream of evaluations and picking up on when it is fully evaluated
10:56:22 <rwbarton> what if you're evaluating (\f. f f) (\f. f f)
10:56:43 <rwbarton> do you want to stop just because the thing looks the same after an evaluation step?
10:56:48 <rwbarton> but then you don't stop after larger cycles
10:56:58 <elliott> just use a halting oracle
10:57:15 <elliott> or alpha-rename every step so you never get the same result!
10:57:44 <S11001001> @pl \f -> f f
10:57:44 <lambdabot> join id
10:58:06 <Iceland_jack> For my intended uses, those concerns do not apply
10:58:14 <byorgey> Iceland_jack: it's common to have a one-step evaluation function which returns Maybe.  You can then write another function which chains multiple calls together and returns the last non-Nothing value.
10:58:56 <Iceland_jack> I suppose I could do that, it means the same thing
10:59:17 <elliott> if you depend on lens you can say "eval = farthest step" ;)
10:59:37 <Iceland_jack> I don't depend on lenses :)
10:59:51 <edwardk> elliott: heh
11:00:29 * elliott becomes steadily more convinced edwardk has "lens" on highlight
11:00:51 * Iceland_jack is thinking of adding ‘lens’ to ignore
11:01:15 <c_wraith> elliott: he already confirmed he does
11:01:35 <elliott> Iceland_jack: i'll find an excuse to mention lens in all my advice then :P
11:01:52 <Iceland_jack> heh
11:03:15 <LucaS05> can someone could help me with redefine map using foldr?
11:03:38 <glguy> What have you tried so far?
11:03:52 <FireFly> Look at the type of map and the type of foldr
11:05:51 <LucaS05> i've tried this http://hpaste.org/78864
11:05:58 <LucaS05> but is totally uncorrect
11:06:18 <c_wraith> well, it has the wrong type, for starters
11:06:47 <c_wraith> If you're re-implementing map, you need the type to be the same as map
11:07:34 <c_wraith> So start by correcting the type signature.
11:08:49 <LucaS05> ok so it becomes mapF :: (a -> b) -> [a] -> [b]
11:09:06 <c_wraith> That's the first step, yes
11:09:19 <c_wraith> That gets you a correct target type signature.
11:09:34 <c_wraith> Now, you just need to fit the pieces together with foldr's type signature :)
11:10:22 <LucaS05> and this is the main problem
11:10:41 <c_wraith> :t foldr
11:10:43 <lambdabot> (a -> b -> b) -> b -> [a] -> b
11:10:56 <c_wraith> here's a big hint: foldr doesn't produce a list *unless* b is a list
11:11:17 <c_wraith> So to make it act like map, the function you pass as the first argument to foldr needs to produce a list
11:12:16 <LucaS05> but the book says foldr f v (x : xs)
11:12:29 <LucaS05> how can be the first argument a list?
11:12:39 <latro`a_> it isn't a list, the function returns a list
11:12:45 <LucaS05> oh saorry
11:12:50 <LucaS05> ;)
11:12:52 <FireFly> Substitute all the b's with something that is a list
11:12:57 <FireFly> such as [c]
11:13:11 <scp> @src nub
11:13:12 <lambdabot> nub = nubBy (==)
11:13:25 <FireFly> @ty nub
11:13:27 <lambdabot> Eq a => [a] -> [a]
11:13:53 <scp> >nub [1, 2, 3, 4, 4, 3, 2, 1]
11:14:02 <scp> > nub [1, 2, 3, 4, 4, 3, 2, 1]
11:14:04 <lambdabot>   [1,2,3,4]
11:14:07 <FireFly> Aha
11:14:33 <scp> in school we called it "setify", nub is a weird name =P
11:14:57 <FireFly> I wouldn't say "setify" is less weird :P
11:15:20 <LucaS05> i've not understand. cause i don't know what the function does
11:15:28 <beaky> hello
11:15:34 <LucaS05> so how can i say that it produce a list?
11:15:36 <FireFly> LucaS05: which one? foldr?
11:16:08 <LucaS05> c_wraith says the function you pass as the first argument to foldr needs to produce a list
11:16:21 <LucaS05> how can i say that?
11:16:32 <latro`a_> you know that the return type of the foldr you're going to write needs to be a list type, say [c], since the return type of map is a list type
11:16:42 <beaky> @hoogle Array i a -> [(i, a)]
11:16:42 <lambdabot> Data.Array assocs :: Ix i => Array i e -> [(i, e)]
11:16:42 <lambdabot> Data.Array.IArray assocs :: (IArray a e, Ix i) => a i e -> [(i, e)]
11:16:42 <lambdabot> Data.Graph.Inductive.Graph lpre :: Graph gr => gr a b -> Node -> [(Node, b)]
11:16:58 <latro`a_> that means the b at the end of the type of foldr needs to be [c], which means all the other b's need to be [c] too
11:18:10 <LucaS05> ok. but i don't know how to code that ;)
11:18:15 <Taneb> Aaaargh
11:18:16 <LucaS05> i've understand what you mean
11:18:26 <Taneb> SDL would be perfect for this, except it only supports a single window
11:18:44 <latro`a_> well, now we know the type of the function to give to foldr
11:18:47 <latro`a_> a -> [c] -> [c]
11:18:51 <Botje> Taneb: good news! sdl 2.0 supports multiple windows .. too bad it's not widely supported yet.
11:18:56 <latro`a_> given the arguments to map, how do we build such a function?
11:19:37 <`ramses> @src until
11:19:37 <lambdabot> until p f x | p x       = x
11:19:38 <lambdabot>             | otherwise = until p f (f x)
11:19:56 <rwbarton> wow that's a real thing?
11:20:08 <elliott> rwbarton: it's even in Prelude
11:20:24 <rwbarton> which I guess means it has been there forever
11:20:31 <elliott> I wish it was the far more useful until :: (a -> Maybe a) -> a -> a though
11:20:47 <`ramses> it's awesome for writing recursive functions :)
11:21:30 <LucaS05> i need to modify the signature?
11:21:37 <Taneb> Botje, yay! Haskell binding is 1.2
11:21:50 <LucaS05> mapF :: (a -> [b]) -> [a] -> [b] maybe?
11:21:51 <beaky> > map (+1) ['a'..'z']
11:21:53 <lambdabot>   No instance for (GHC.Num.Num GHC.Types.Char)
11:21:53 <lambdabot>    arising from a use of `GHC....
11:22:07 <c_wraith> LucaS05: Nope. You can't change the type of mapF
11:22:16 <LucaS05> right
11:22:29 <LucaS05> sorry
11:22:30 <c_wraith> LucaS05: you're going to have to pass different function than f to foldr
11:22:47 <c_wraith> LucaS05: but the function you pass will need to use f
11:24:09 <c_wraith> LucaS05: so let's look more at the function foldr takes
11:24:34 <LucaS05> so i need to 'create' a function that uses my f function?
11:24:43 <c_wraith> LucaS05: It has two arguments.  Those two arguments are, in order, "this element of the list", and "the result of applying foldr to the rest of the list"
11:25:19 <c_wraith> LucaS05: the result of the function is the result of the entire foldr computation
11:25:19 <dmwit> ?hoogle [Maybe a] -> [[a]]
11:25:20 <lambdabot> Data.Maybe catMaybes :: [Maybe a] -> [a]
11:25:20 <lambdabot> Data.Maybe maybeToList :: Maybe a -> [a]
11:25:20 <lambdabot> Data.Foldable toList :: Foldable t => t a -> [a]
11:26:04 <dmwit> :t splitOn
11:26:05 <lambdabot> Eq a => [a] -> [a] -> [[a]]
11:26:18 <dmwit> :t map catMaybes . splitOn [Nothing]
11:26:20 <lambdabot> Eq a => [Maybe a] -> [[a]]
11:26:55 <dmwit> :t map catMaybes . splitWhen isNothing
11:26:55 <c_wraith> dmwit: that will introduce some empty lists if you have consecutive Nothings..  Is that what you want?
11:26:57 <lambdabot> [Maybe a] -> [[a]]
11:27:00 <dmwit> c_wraith: yeah
11:27:04 <Taneb> I... could just support 1 window for now
11:27:07 <dmwit> c_wraith: Is there a better way to write this?
11:27:13 <c_wraith> dmwit: not that I know of
11:27:47 <c_wraith> LucaS05: so, the first argument of the function is the current element of the list. You know what map wants to do with the current element of the list, right?
11:29:14 <LucaS05> applying the function to it
11:30:32 <c_wraith> exactly
11:31:15 <c_wraith> So...  to write your function as a lamba, it looks sort of like this \x xs -> ... f x ...
11:31:32 <c_wraith> You're not quite sure what *else* to do, but you know you want to apply f to the first argument
11:31:37 <c_wraith> And that's getting somewhere.
11:34:04 <LucaS05> but foldr has a function with three argument
11:34:12 <c_wraith> :t foldr
11:34:13 <lambdabot> (a -> b -> b) -> b -> [a] -> b
11:34:18 <c_wraith> two arguments
11:34:23 <dgpratt> so I got the bits from this project http://hub.darcs.net/stepcut/mastermind and tried to "cabal-dev install", but dependency resolution failed
11:34:33 <LucaS05> oh is the same b
11:34:33 <hpaste> dgpratt pasted “error from cabal-dev install” at http://hpaste.org/78866
11:34:38 <c_wraith> Well, foldr has 3 arguments.  But its first argument is a function that takes two arguments
11:34:47 <c_wraith> the second b is the *result* type, not an argument type
11:35:32 <latro`a_> well...both, technically
11:35:32 <latro`a_> oh wait, nvm
11:35:32 <latro`a_> misunderstood "second"
11:35:49 <dgpratt> I guess that if I want to get it to build, I need to modify the .cabal file to be more specific about versions
11:36:19 <LucaS05> but what you mean with \x xs -> f x ?
11:36:19 <dgpratt> but I'm not sure based on the error(s) what version(s) I should be changing and to what
11:36:25 <dgpratt> suggestions?
11:36:42 <c_wraith> LucaS05: are you familiar with the lambda (anonymous function) syntax in haskell?
11:37:14 <c_wraith> > (\x y -> x + y) 5 7
11:37:16 <lambdabot>   12
11:37:24 <LucaS05> ok
11:37:45 <LucaS05> so -> is like defining a function
11:37:58 <LucaS05> the character -> i mean
11:37:58 <c_wraith> well, the combination of \ and ->
11:38:06 <LucaS05> ok
11:38:26 <c_wraith> the \ means "this is an anonymous function, these are the arguments it has", the -> means "and this is what to do with them"
11:39:38 <LucaS05> so the result is this ? mapF f xs = foldr(\x xs -> f xs) [] xs
11:39:48 <c_wraith> Well, that's not quite right.
11:39:51 <c_wraith> But it's getting close
11:40:03 <c_wraith> (I'd put a space before the open paren)
11:40:22 <c_wraith> The lambda isn't quite right.
11:40:55 <LucaS05> why? i'm defining a function that works on a list right (xs) ?
11:41:02 <c_wraith> For one, you need to apply the function to the current argument, not the rest, so f x, rather than f xs
11:41:10 <dmwit> foldr (\x xs -> f xs) says, given the front element of a list and the recursive value of applying this fold to the rest of the list, return f applied to the recursive argument.
11:41:11 <c_wraith> Second, you need the result to be a list
11:41:49 <dmwit> The first red flag should be that throwing away the front of the list can't be right. =)
11:41:51 <LucaS05> hey guys don't mind but one at time
11:41:53 <LucaS05> :D
11:42:01 <dmwit> Drink from the firehose, baby.
11:42:15 <dmwit> If you're mind's not exploding, the hose isn't on strong enough.
11:42:40 <c_wraith> Pfft. It's fine to want to take it a bit slower. :)
11:42:40 <LucaS05> what's hose?
11:44:01 <dmwit> LucaS05: Oh, "drink from the firehose" just a metaphor for getting a lot of information at once.
11:44:58 <LucaS05> ok :D (maybe not the right time after come back home from university)
11:46:46 <LucaS05> mapF f xs = foldr( \x xs -> f x:xs) [] xs like this?
11:48:40 <c_wraith> LucaS05: that's correct
11:48:49 <c_wraith> LucaS05: though maybe a little confusing, and that's my fault
11:48:59 <c_wraith> LucaS05: because you're shadowing the name xs in there
11:49:19 <c_wraith> LucaS05: you should renamed one of the xs variables to something else, just to make it clearer
11:49:34 <LucaS05> oh ok
11:49:38 <FireFly> If you're comfortable with points-free style you could even drop the outer ones
11:49:57 <FireFly> but.. that might not make things more clear.  Depends, I guess :P
11:50:08 <mgccl> I do not get the point of fgl's gr type variable. all the functions are gr a b->w/e, what's the point to redefined things so we have (Graph gr)=>gr a b? It was Graph a b back in 2000.
11:50:13 <LucaS05> you mean defin mapF like: mapF f = ...
11:50:28 <elliott> mgccl: it has multiple graph implementations
11:50:31 <glguy> mgccl: There are multiple implementations
11:51:11 <glguy> c_wraith++
11:51:33 <mgccl> ahh I see, I was confused since I was following the user manual in 2000 and can't get things to work. (like printing the graph)
11:51:44 <LucaS05> but guys can you please explain me the map redefinition a little bit well ?
11:51:45 <FireFly> LucaS05: yes, exactly
11:52:31 <elliott> maybe not such a great idea to use a manual from 2000 :)
11:52:44 <elliott> I understand fgl has gone through major renovations since then
11:53:21 <mgccl> that's the only user guide available...  oh well...
11:53:30 <c_wraith> LucaS05: Sure. Though it'd help us know where to start if you had a more specific question.
11:53:34 <andsens> Does anybodt have some experience with with Text.JSON?
11:53:44 <elliott> well you can read the haddocks, though they may be unhelpful
11:54:22 <c_wraith> andsens: which package is that?
11:54:28 <Clint> not aeson
11:54:30 <andsens> http://hackage.haskell.org/packages/archive/json/0.3.3/doc/html/Text-JSON.html
11:54:49 <larsrh> what's the state of the art for running QuickCheck tests from cabal?
11:54:58 <Botje> LucaS05: have you tried working through a small example of map-as-foldr by hand?
11:55:04 <hpaste> andsens pasted “TypeError” at http://hpaste.org/78867
11:55:15 <andsens> can't figure out what I am doing wrong
11:55:32 <LucaS05> i've not understand \x xs -> f x:xs
11:55:59 <LucaS05> and it's
11:56:05 <LucaS05> usage in the foldr
11:56:38 <rwbarton> apparently JSRational has a Bool field in addition to the Rational
11:56:48 <LucaS05> i mean i know that i need a 'new' function that retunrs a list (i hope is for that) but if you can explain well it's usage there i will be glad
11:57:02 <Botje> LucaS05: it's equivalent to defining "g x xs = f x : xs" somewhere and passing that to foldr.
11:57:16 <Botje> except shorter.
11:57:18 <andsens> hold on: Prelude Text.JSON.Types> :t JSRational
11:57:19 <andsens> JSRational :: Bool -> Rational -> JSValue
11:57:27 <andsens> wth is the boolean for?
11:57:41 <rwbarton>     | JSRational Bool{-as Float?-} !Rational
11:57:43 <pmade> What's the common idiom for composing methods that can fail so that you get the result of the first function to succeed?
11:57:44 <LucaS05> so it's for defining a function that return a function?
11:57:52 <rwbarton> whatever that means
11:57:55 <andsens> oh! Thanks rwbarton
11:58:05 <Botje> LucaS05: it doesn't return a function.
11:58:09 <rwbarton> I guess that means "1" -> JSRational False 1 and "1.0" -> JSRational True 1
11:58:17 <Botje> LucaS05: in haskell you can pass functions as values to other functions.
11:58:21 <andsens> exactly
11:58:21 <rwbarton> but that's pretty ugly
11:58:28 <rwbarton> why not use an Either Integer Double
11:58:31 <c_wraith> pmade: have them all return Maybe, then use msum to get the first Just result
11:58:36 <Botje> LucaS05: for example, you can write map (\x -> x + 1) [1..5]
11:58:46 <Botje> instead of map f [1..5] where f x = x + 1
11:58:48 <pmade> c_wraith: Great, that's exactly what I wanted!@
11:58:50 <rwbarton> hmm
11:59:03 <rwbarton> instance JSON Double where showJSON = JSRational False . toRational ; ...
11:59:11 <rwbarton> instance JSON Float where showJSON = JSRational True . toRational ; ..
11:59:27 <LucaS05> so in this foldr( \x xs -> f x:xs) what i'm doing exaclty?
11:59:45 <LucaS05> i'm passing a function that use a list?
11:59:59 <LucaS05> uses*
12:00:26 <rwbarton> LucaS05: I don't know whether this helps but: you can rewrite it like this: mapF f xs = foldr aux [] xs where aux x xs = f x : xs
12:01:13 <FireFly> Maybe looking at the type of the (\x xs -> f x:xs) lambda helps:  a -> [b] -> [b]
12:01:16 <LucaS05> thanks for the example but not :D it's a little bit difficult for now
12:01:36 <FireFly> (if x is a function  a -> b)
12:02:34 <LucaS05> so i'm passing a function that works on a list and returns a list
12:03:04 <FireFly> That is, it takes a value (of type a) and a list (of type b), and passes the value through the function `f` turning it into a thing of type b, then prepends it to the list of b's
12:03:07 <jang> LucaS05: it's doing a map, "starting at the back of the list and working forwards", sort of. the function modifies the head ofthe list and appends it to a tail that's "already been modified"
12:03:10 <jang> (modulo lazy evaluation0
12:03:48 <latro`a_> I don't think the "starting at the back" perspective on foldr is useful at all (and in the infinite case it's nonsensical)
12:04:26 <jang> I missed the start of this. I wasn't sure if LucaS05 was after an example of foldr or after an explanation of why this works as a map
12:04:48 <latro`a_> he was trying to implement map using foldr
12:05:01 <LucaS05> i've done this mapF f xs = foldr( \x xs -> f x:xs) [] xs
12:05:13 <LucaS05> and i want to understand \x xs...
12:05:28 <LucaS05> FireFly i'm reading your comments
12:05:35 <LucaS05> ;)
12:05:54 <latro`a_> you apply the function to x, then prepend it onto the result of the rest of the recursion
12:06:01 <latro`a_> let's try expanding:
12:06:24 <LucaS05> maybe there are a lot of xs
12:06:56 <latro`a_> foldr aux [] (x:xs) = aux x (foldr aux [] xs)
12:07:04 <latro`a_> now use aux
12:07:16 <latro`a_> and you get f x:(foldr aux [] xs)
12:07:24 <latro`a_> beginning to look familiar?
12:07:52 <LucaS05> yes!
12:08:00 <hpaste> andsens pasted “Another type error” at http://hpaste.org/78868
12:08:11 <andsens> This ^ I really don't get
12:08:58 <andsens> Why am I unable to create a list with tuples containing different instances of the same data record?
12:09:47 <sipa> andsens: that should work
12:10:05 <sipa> can you paste your code somewhere?
12:10:08 <andsens> sipa. right?!
12:10:23 <rwbarton> ("type", toJSString "offset"), ("i", JSRational True i), (toJSString "node", node_id (R.node o)) -- what's going on here
12:10:41 <andsens> oh crap
12:10:46 <beaky> what is tail recursion?
12:10:51 <andsens> the key wasn't supposed to be a jsstring
12:11:11 <andsens> doesn't change anything though
12:11:16 <Botje> beaky: when the last thing you do in a function is another function call, you can replace the current stack frame instead of making a new one.
12:11:43 <beaky> just the last thing?
12:11:51 <Raynes> That'd be the tail, yes.
12:11:54 <andsens> rwbarton: I am creating a JSObject
12:11:57 <c_wraith> Well, if it's not the last thing, you can't throw out the current context.
12:12:02 <c_wraith> Because you still need it
12:12:25 <beaky> what if it was something like go x = if x == 0 then go (x - 1) else go (x + 1)
12:12:29 <beaky> is that tail recursive?
12:12:34 <Botje> beaky: yup
12:12:35 <c_wraith> yes
12:12:36 <Ololo> @pl \x y -> (x, y)
12:12:36 <lambdabot> (,)
12:12:49 <Ololo> @pl thank you
12:12:49 <lambdabot> thank you
12:12:58 <c_wraith> It does have the minor problem that it never terminates, though. :)
12:13:02 <neutrino_> hi
12:13:19 <c_wraith> But at least it won't run out of memory while it runs forever!
12:13:47 <rwbarton> andsens: well toJSString doesn't produce a JSValue
12:13:51 <rwbarton> it produces a JSString
12:14:12 <mapf> :t '()
12:14:13 <beaky> ah
12:14:14 <lambdabot>     Syntax error on '()
12:14:14 <lambdabot>     Perhaps you intended to use -XTemplateHaskell
12:14:35 <andsens> A JSString is a JSValue rwbarton
12:14:43 <rwbarton> no
12:14:45 <beaky> > let go x = if x > 0 then go (x - 1) else go (x + 1) in go 10
12:14:46 <andsens> http://hackage.haskell.org/packages/archive/json/0.3.3/doc/html/Text-JSON.html
12:14:48 <lambdabot>   mueval-core: Time limit exceeded
12:14:53 <beaky> dan
12:14:54 <beaky> damn*
12:15:09 <rwbarton> there is a data constructor JSString that can make a JSValue out of a JSString
12:15:19 <beaky> I still get things like "stack depth exceeded" when I run functions like that
12:15:24 <mapf> i'm confused. ' is used in TemplateHaskell and for kinds. so '() is both kind and quote for exsample.
12:15:29 <beaky> is it because by default GHC doesn't do tail call elimination/
12:16:01 <Botje> beaky: actually, it's because of laziness in the x variable.
12:16:04 <andsens> Ah yes, I started using toJSString because I though ghc was complaining about that
12:16:05 <beaky> oh
12:16:06 <beaky> thunking
12:16:09 <Botje> yes.
12:16:09 <mapf> therefore ' is content dependent  ?
12:16:14 <Botje> you never examine x, so it overflows.
12:16:17 <Botje> *your memory
12:16:25 <Botje> uh, wait
12:16:29 <beaky> how do I tell haskell to not be lazy
12:16:30 <Botje> no, you _do_ examine it. hmm.
12:16:51 <Botje> then it's lack of tail recursion, yes.
12:17:53 <andsens> Oh my god, why? To create a JSString you have to run: JSString (toJSString "foo") what the actual f***
12:18:09 <rwbarton> you don't have to of course
12:18:21 <rwbarton> you can instead use showJSON for instance
12:18:24 <andsens> what's the alternative
12:18:38 <andsens> oh, ah yes. ok
12:19:24 <andsens> thank you rwbarton. Been sitting with this for a while.
12:26:06 <`ramses> @src sort
12:26:06 <lambdabot> sort = sortBy compare
12:26:14 <`ramses> @src sortBy
12:26:14 <lambdabot> sortBy cmp = foldr (insertBy cmp) []
12:26:23 <`ramses> @src insertBy
12:26:23 <lambdabot> insertBy _   x [] = [x]
12:26:23 <lambdabot> insertBy cmp x ys@(y:ys') = case cmp x y of
12:26:23 <lambdabot>                                  GT -> y : insertBy cmp x ys'
12:26:23 <lambdabot>                                  _  -> x : ys
12:30:35 <mizu_no_oto> Out of curiosity, why is GHC a git repository located at darcs.haskell.org (according to http://hackage.haskell.org/trac/ghc/wiki/Building/GettingTheSources), and not either a darks repository or on github?  Seems somewhat ironic.
12:30:36 <mreh> should I dish out work to threads using something like MVar [Work]?
12:31:31 <mreh> where [Work] is an unevaluated list of expressions
12:31:50 <mreh> or even a list of unevaluated expressions
12:32:59 <Botje> why not a channel?
12:33:30 <Botje> then the clients can fight for the read end while you have the write end to yourself
12:35:02 <mreh> I don't need to be waiting for input, I need to speed this thing up to utilise all my cores and do work whilst the singly threaded versions would otherwise block on I/O
12:35:54 <rwbarton> mizu_no_oto: historical reasons I presume. there is also a mirror https://github.com/ghc/ghc
12:36:07 <mreh> it writes the result of the 'Work's to a file
12:36:21 <hpaste> andsens pasted “duplicate definition for symbol” at http://hpaste.org/78871
12:37:16 <andsens> I think it has something to do with the Text library dependencies from Parsec and JSON. How to fix?
12:38:22 <S11001001> mizu_no_oto: also https://twitter.com/PLT_Borat/status/245241166273056768
12:38:31 <`ramses> do you guys write much code in pointfree style in real code? I'm getting better at it and while I like the way of thinking, I fear my code might be becoming harder to read to others..
12:39:53 <elliott> i use point-free a fair bit
12:39:54 * tac doesn't believe point-free is obviously better.
12:40:08 <elliott> you develop an intuition for when it's worth it or not in my experience
12:40:59 <Iceland_jack> I always use it with a series of function composition: foo = a . b . c . d . e
12:41:16 <Iceland_jack> otherwise it can turn unreadable pretty fast
12:41:38 <`ramses> elliott: and what are the factors determinig whether it's worth it then? readability?
12:42:20 <elliott> some vague combination of readability, simplicity, and (what point-free is all about in the end) compositionality
12:42:23 <`ramses> (for you, that is, of course that's a subjective thing)
12:42:38 <mreh> composability?
12:42:49 <elliott> mine has more letters
12:42:54 <mreh> :)
12:43:01 <elliott> `ramses: the best rule of thumb I can offer is that if you have to use @pl to get the point-free form and it includes parens or flip, it's probably not worth it :P
12:43:28 <mreh> > "compositionality" > "composability"
12:43:29 <lambdabot>   True
12:43:38 <`ramses> yeah, I started wondering when I wrote this:  remove = fmap (filter (not . null)) . map . filter . (/=)
12:44:29 <elliott> I probably wouldn't write that function that way, but it's not bad if you think it's nicer
12:44:31 <`ramses> does not pass the parens rule I guess :)
12:44:51 <elliott> well, that's for @pl's output, which is often horrible :)
12:44:58 <elliott> I wonder why you use fmap there though.
12:45:02 <elliott> isn't it just map there?
12:45:06 <andsens> how can I check which cabal packages i have installed?
12:45:10 <elliott> andsens: ghc-pkg list
12:45:15 <rwbarton> I was guessing it was (.)
12:45:20 <mreh> :t map . filter . (/=)
12:45:22 <lambdabot> Eq a => a -> [[a]] -> [[a]]
12:45:29 <`ramses> well, I'm not sure for myself yet, I'm trying to imagine my reaction if would encounter a line like that in someone else's code :)
12:45:35 <rwbarton> anyways I have no idea what this code does
12:45:52 <elliott> well the main problem of that code is that I don't know what the fmap is
12:46:07 <elliott> if it is indeed (.) then you should probably not use point-free style there, nested (.)s are when things start getting noisy
12:46:10 <mreh> yeah, I have no idea what that does either
12:46:13 <`ramses> fmap = (.) in this case..
12:46:13 <rwbarton> composing with a two-argument function is generally a bad move IMO
12:46:17 <elliott> yeah
12:46:31 <andsens> Does anybody have an idea how I should try to fix this problem: http://hpaste.org/78871 ?
12:46:33 <rwbarton> also "fake generalization" is definitely bad
12:46:34 <elliott> I don't like (.:) much precisely because it promotes this kind of noise where I can't tell which argument is going where
12:46:43 <rwbarton> don't write fmap when you know it is (.), etc.
12:46:46 <elliott> I would suggest never using fmap when you know your type makes it a (.)
12:46:52 <elliott> or map
12:46:57 <`ramses> e
12:47:01 <elliott> it just makes people think it is going to be something more exotic or general
12:47:11 <elliott> and they will confuse themselves trying to work out what special thing it is doing
12:47:14 <`ramses> the version with (.)'s is indeed quite horrible :(
12:47:26 <rwbarton> this looks like it would be good if you added back in one argument
12:47:31 <rwbarton> that seems like the optimal balance to me
12:47:32 <typoclass> andsens: oh wow, that's certainly a creative new error message :-/
12:47:41 <andsens> hehe
12:48:10 <rwbarton> remove x = filter (not . null) . map (filter (/= x))
12:48:11 <andsens> ghc-pkg list | grep text says I got 11.2.0 and 11.2.3
12:48:24 <andsens> Trying to figure out which library depends on 11.2.0
12:48:36 * elliott seconds rwbarton on the phrasing of that function
12:48:37 <rwbarton> so much more direct and obvious
12:48:50 <elliott> though actually I would try to change my data structure so you don't need that filter (not . null) pass entirely :P
12:49:01 <elliott> or actually
12:49:04 <elliott> you can just use concatMap here
12:49:10 <`ramses> I'm not in charge of the data structure...
12:49:17 <rwbarton> though it's hard for me to be entirely objective because I already succeeded in understanding what the first one did
12:49:18 <elliott> but I guess the two passes get optimised away by laziness
12:49:42 <Ololo> Hi, guys! Is there any combinator libraries for LALR/GLR parsing? I'm trying to make a compiler for BASIC, and currently I'm a bit disappointed with Parsec, as it doesn't scale to bigger grammars at all.
12:49:43 <elliott> yeah my paranoia was unfounded
12:50:08 <`ramses> but concatMap flatten the list, doesn't it? I need to keep it [[a]] but only remove any element lists that became empty
12:50:54 <elliott> well I meant you'd write it as concatMap (\xs -> case filter (/= x) xs of [] -> []; _ -> [[xs]]) or something awful like that
12:50:58 <elliott> but you should just use the filter version
12:50:58 <rwbarton> I guess this is the Goldilocks style of point-free programming
12:51:32 <`ramses> rwbarton: I'm not sure what exactly you mean by that?
12:51:44 <rwbarton> well "remove = fmap (filter (not . null)) . map . filter . (/=)"
12:51:47 <rwbarton> is too point-free
12:52:03 <rwbarton> "remove x xss = filter (not . null) (map (filter (/= x)) xss)" is not point-free enough
12:52:06 <peteriserins> what is the ordinal number of the set of computable functions?
12:52:08 <jang> heh
12:52:09 <rwbarton> "remove x = filter (not . null) . map (filter (/= x))" is just right :)
12:52:22 * typoclass wonders if in an ideal world, Prelude would include a function for (not . null)
12:52:43 <Ololo> peteriserins: it's a countable set
12:52:59 <`ramses> ah, ok :) I just didn't get the name reference..
12:53:05 <peteriserins> Ololo: yes, hence I'm asking the ordinality, not the cardinality
12:53:17 <rwbarton> what's your well-ordering
12:53:44 <peteriserins> rwbarton: hmm, lexicographic?
12:54:08 <peteriserins> rwbarton: in a rep using de Brujn indices, say
12:54:27 <rwbarton> I assumed "computable functions" was an extensional thing
12:54:39 <rwbarton> so you could say: lexicographic as sequences N -> N
12:55:02 <peteriserins> rwbarton: I see, that's nice
12:55:46 <Ololo> peteriserins: omega-small, I guess
12:56:12 <rwbarton> in which case: I don't know. interesting question
12:57:04 <rwbarton> wait, that set isn't well-ordered, is it
12:59:52 <neutrino_> hi
12:59:57 <neutrino_> is there a name for flip when?
13:00:06 <peteriserins> rwbarton: can you give a set without a least element?
13:00:10 <Taneb> :t flip when
13:00:11 <lambdabot> Monad m => m () -> Bool -> m ()
13:01:07 <clahey> @hoogle Monad m => m () -> Bool -> m ()
13:01:08 <lambdabot> Control.Monad unless :: Monad m => Bool -> m () -> m ()
13:01:08 <lambdabot> Control.Monad when :: Monad m => Bool -> m () -> m ()
13:01:08 <lambdabot> Data.Generics.Aliases extR :: (Monad m, Typeable a, Typeable b) => m a -> m b -> m a
13:01:11 <rwbarton> maybe I got my counterexample backwards
13:01:14 <peteriserins> rwbarton: you can construct the least element left to right I think
13:01:17 <fmap> neutrino_: no
13:01:29 <rwbarton> you can construct something left to right, but why is it in the set
13:01:43 <rwbarton> right, here is the example
13:01:46 <clahey> @src when
13:01:46 <lambdabot> when p s = if p then s else return ()
13:01:53 <rwbarton> { \n -> if n >= m then 1 else 0 | m <- [1..] }
13:02:17 <clahey> @src while
13:02:17 <lambdabot> Source not found. That's something I cannot allow to happen.
13:02:47 <peteriserins> rwbarton: right
13:03:07 <peteriserins> rwbarton: so the construction is just an inf, ok
13:03:38 <Taneb> @pl \i a j -> if i == j then const a else id
13:03:38 <lambdabot> flip flip id . (flip .) . (. const) . flip . (if' .) . (==)
13:04:04 <clahey> @hoogle Monad m => m Bool -> m ()
13:04:04 <lambdabot> Control.Monad replicateM_ :: Monad m => Int -> m a -> m ()
13:04:04 <lambdabot> Control.Monad forever :: Monad m => m a -> m b
13:04:04 <lambdabot> Control.Monad unless :: Monad m => Bool -> m () -> m ()
13:04:22 <clahey> @src forever
13:04:22 <lambdabot> Source not found. My pet ferret can type better than you!
13:05:37 <mizu_no_oto> Where does cabal download files to in OS X, and where is this documented?  I just got the error "fingertree-0.0.1.1 failed while unpacking the package. The exception was: user error (truncated tar archive)" so I need to delete the tar archive it incorrectly downloaded, but I can't figure out where it is.
13:05:44 <acowley> Yesterday, someone described Haskell as big and scary. Today I need to do some C++ work… H.P. Lovecraft wouldn't touch this.
13:06:06 <neutrino_> i did
13:06:14 <neutrino_> i said it's big and scary to newbies
13:06:15 <acowley> mizu_no_oto: It depends on how you have it setup. For me, it's in ~/.cabal/
13:06:27 <neutrino_> acowley i think you should read Ulysses
13:06:34 <neutrino_> that would make C++ a breeze
13:06:48 <dcoutts> mizu_no_oto: on most platforms it's ~/.cabal/packages/, but if not you can find out by looking at the log messages when you use -v3
13:07:09 <acowley> Yes, Joyce is usually recommended when dealing with horrors from below.
13:09:41 <mizu_no_oto> dcoutts: Thanks.  Mac needs to be clever about where it puts everything, so it's in /Users/mizu_no_oto/Library/Haskell/repo-cache/hackage.haskell.org/dlist/0.5/dlist-0.5.tar.gz
13:09:56 <mizu_no_oto> Obviously, that's the first place anyone would think to look
13:10:35 <dcoutts> mizu_no_oto: so I think the Haskell Platform for OSX sets the default to be /Users/name/Library/Haskell, rather than the unix convention of ~/.cabal/
13:10:45 <dcoutts> mizu_no_oto: unfortunately I can never remember that :-)
13:11:08 <acowley> Yeah, that's the HP version. If you install things yourself, you'll likely end up with ~/.cabal
13:11:12 <mapf> how to specify AnyK? suppose i have    type family (Head (xs :: [*])) :: *    and i want to take head of '[IO, Maybe] like this (Head '[IO, Maybe]) but here is kind mismatch because IO has kind * -> * and not *
13:11:18 <mizu_no_oto> How do I fix it to use ~/.cabal/?
13:11:40 <dcoutts> mizu_no_oto: there'll be a config file in /Users/name/Library/Haskell/
13:11:44 <acowley> It's in a config file
13:11:47 <mapf> on the other side Just have kind AnyK -> Maybe AnyK
13:12:00 <mapf> can i specify AnyK by hand?
13:12:17 <dcoutts> mizu_no_oto: unless bizarely the config file is still in ~/.cabal/  :-)
13:12:21 <acowley> The unix version of things asks you to put ~/.cabal/bin in your PATH, then puts packages elsewhere in ~/.cabal
13:12:39 <dgpratt> oh, hey dcoutts! I was just thinking of you :)
13:12:46 <dcoutts> mm? :-)
13:13:59 <dgpratt> so "cabal-dev add-source" tries to use the Cabal sdist command, which appears not to be supported on Windows
13:14:16 <dgpratt> due to lack of necessary tar.exe functionality
13:14:21 <neutrino_> @undo do { x <- foo; let y = bar x }
13:14:21 <lambdabot>  Parse error at "}" (column 30)
13:14:26 <neutrino_> @undo do { x <- foo; let y = bar x; }
13:14:26 <lambdabot>  Parse error at "}" (column 31)
13:14:39 <neutrino_> what's going on?
13:14:40 <dgpratt> is there a way forward here?
13:14:47 <neutrino_> @undo do { x <- foo; let y = bar x; return () }
13:14:47 <lambdabot>  Parse error at "}" (column 41)
13:14:50 <neutrino_> hmm
13:14:54 <neutrino_> ;|
13:14:57 <lispy> dgpratt: hmm...I've always used 'cabal-dev add-source' but creswick (one of the original cabal-dev authors) tells me I _should_ be using 'cabal-dev install <path>' instead as it doesn't need sdist
13:15:37 <dgpratt> lispy: ah, interesting, the guidance on that tool offers that as an option, but it suggests add-source is more efficient
13:16:07 <neutrino_> hey guys, how do i raise an ioexception?
13:16:10 <neutrino_> i am in the io monad
13:16:12 <dgpratt> (because add-source builds just once, I'm guessing?)
13:16:21 <neutrino_> do i just say: fail "whtever"?
13:16:24 <neutrino_> > fail "hello"
13:16:25 <lambdabot>   No instance for (GHC.Show.Show (m0 a0))
13:16:26 <lambdabot>    arising from a use of `M33209667...
13:16:27 <Hafydd> @undo  x <- foo; let y = bar x; return ()
13:16:27 <lambdabot>  Parse error at "<-" (column 3)
13:16:36 <mapf> > 1
13:16:38 <lambdabot>   1
13:16:47 <dcoutts> dgpratt: um, that may be true for custom build types, I don't quite recall
13:17:01 <dcoutts> dgpratt: certainly cabal-install itself has built-in tar.gz support
13:17:08 <dcoutts> dgpratt: precisely because of the windows issue
13:17:29 <acowley> :t ioError
13:17:31 <lambdabot> IOError -> IO a
13:17:37 <fmap> @undo do x <- foo; let {y = bar x}; return ()
13:17:37 <dgpratt> dcoutts: you're saying cabal-install doesn't delegate to tar.exe for that?
13:17:37 <lambdabot> foo >>= \ x -> let { y = bar x} in return ()
13:17:50 <LucaS05> sorry guys but i have some doubts. can anybody please explain me (again) this: foldr( \y ys -> f y:ys ) [] xs (it's the redefinition of the map function)
13:18:02 <LucaS05> using foldr
13:18:10 <neutrino_> thx fmap
13:18:18 <acowley> LucaS05: Try expanding it by hand
13:18:23 <dcoutts> dgpratt: right, but what I don't entirely recall is what we do for custom build types: if we call ./Setup sdist, or if we ignore it and do an sdist as if it were the simple build type
13:18:42 <dcoutts> dgpratt: btw, this sdist hack will go away in the next release of cabal which has native sandboxing
13:18:59 <dgpratt> *sigh* everything
13:19:02 <dgpratt> err...
13:19:10 <dcoutts> dgpratt: cabal-dev needs to take snapshots with sdist, but that's not the case for the builtin sandboxing
13:19:13 <dgpratt> everything's fixed in the next version :)
13:19:28 <dgpratt> dcoutts: ah, ok
13:19:47 <acowley> foldr (\y ys -> f y : ys) [] [1,2] == f 1 : foldr (\y ys -> f y : ys) [] [2] == f 1 : f 2 : foldr (\y ys -> f y : ys) [] [] == f 1 : f 2 : []
13:20:59 <applicative> LucaS05: there is the general picture of 'foldr op seed'  as it acts on a:b:c....:z:[]  -- it replaces [] with seed, and (;) with op
13:21:06 <applicative> (:) rather
13:21:31 <dgpratt> dcoutts: by the way, I don't know if it answers your question, but cabal-dev does issue a "setup.exe "dist/setup/setup" "sdist"" system command (when doing "cabal-dev add-source")
13:21:42 <dcoutts> dgpratt: ah, then that's the problem
13:22:15 <dcoutts> dgpratt: because ./setup doesn't have any built-in .tar.gz support, so has to call out to tar.exe
13:22:36 <dgpratt> dcoutts: ok, thanks for the explanation
13:23:24 <dgpratt> dcoutts: I'm sure there's a good reason, but it seems weird that cabal-install has built-in .tar.gz support, but not Cabal
13:24:03 <dcoutts> dgpratt: Cabal is a core package (and an older one), the zlib package is not a core package (just in the HP)
13:24:19 <dcoutts> dgpratt: the odd thing actually is that ./Setup has an sdist command at all
13:24:29 <dcoutts> it should just have a way to generate a source tree
13:24:48 <dcoutts> and let other tools (like cabal-install) turn that into a tar.gz or whatever
13:25:53 <LucaS05> thank you applicative. so f y : ys means the application of the function that i pass as parameter recoursively
13:26:42 <applicative> LucaS05: yes.  We could say the op
13:26:46 <neutrino_> @hoogle void
13:26:46 <lambdabot> Foreign.Marshal.Error void :: IO a -> IO ()
13:26:46 <lambdabot> Control.Monad void :: Functor f => f a -> f ()
13:26:46 <lambdabot> package void
13:27:32 <applicative> you are folding is: 'apply f and cons', instead of just 'cons'; and you are replacing the empty list at the end with the empty list (maybe in another type, depending on f)
13:29:12 <applicative> LucaS05: so its no different from 'sum' which replaces the : in a:b:c ... :z:[] with +, and the [] with 0
13:30:44 <applicative> LucaS05: oh I forget the fancy scheme in lambdabot
13:30:46 <applicative> > foldr (+) 0 (a:b:c:d:e:[])
13:30:47 <lambdabot>   a + (b + (c + (d + (e + 0))))
13:33:16 <pmade> I'm trying to use msum with Maybe to return the first non-Nothing value, but what I actually have is a list of IO (Maybe X).  How do I "lift" msum to work with the Maybes inside the IOs?
13:33:59 <shachaf> @hoogle (a -> b) -> IO a -> IO b
13:33:59 <lambdabot> Control.Applicative liftA :: Applicative f => (a -> b) -> f a -> f b
13:33:59 <lambdabot> Prelude fmap :: Functor f => (a -> b) -> f a -> f b
13:33:59 <lambdabot> Data.Functor fmap :: Functor f => (a -> b) -> f a -> f b
13:34:02 <applicative> @type liftM msum
13:34:03 <lambdabot> (Monad m, MonadPlus m1) => m [m1 a] -> m (m1 a)
13:34:25 <LucaS05> yes i know that applicative
13:34:33 <LucaS05> i was unsure of the lambda function
13:34:35 <pmade> applicative: liftM won'
13:35:13 <pmade> applicative: liftM won't work, I need [m1 (m2 a)] -> m1 (m2 a)
13:35:32 <pmade> liftA might work, thinking...
13:35:37 <applicative> oh a list of IO Maybe indeeed
13:36:44 <applicative> @type liftM msum . sequence
13:36:46 <lambdabot> (Monad m, MonadPlus m1) => [m (m1 a)] -> m (m1 a)
13:36:53 <`ramses> if I have a tail recursive function that at each step adds one element to an accumulating list, does using ++ kill the performance or does lazyness make it alright as long as I only associate to the right?
13:36:57 <pmade> applicative: That's it!
13:37:02 <pmade> Thanks!
13:37:07 <`ramses> right now I cons to the start of the list and reverse the final result
13:40:03 <mightybyte_> Ack!  Anyone know what causes an "unknown symbol" error during linking when cabal is loading a package?
13:40:29 <pmade> applicative: Works great, thank you.
13:40:47 <dcoutts> mightybyte_: is it a C symbol or a Haskell symbol? if the latter then it's likely someone forgot to list all their modules in the .cabal file for their lib
13:43:32 <gienah> mightybyte_: sometimes adding --verbose=3 gives some more info on the error
13:44:28 <mightybyte_> Ahh, let me see...
13:45:31 <mightybyte_> dcoutts: It looks like a Haskell symbol to me.  How do I tell the difference?
13:45:58 <dgpratt> dcoutts: bouncing around various source files for cabal and related, your explanation is making even more sense, but I have another question...
13:47:00 <dgpratt> is the presence of a Setup.hs file the only criteria for a package having a 'custom' build? doesn't that apply to pretty much every package?
13:47:03 <dcoutts> mightybyte_: Haskell symbols are long :-) and look like package-ver-Module names (with a few funny symbols in between)
13:47:17 <mightybyte_> Ok, then yeah, it's a Haskell symbol.
13:47:24 <dcoutts> mightybyte_: so that will tell you which package it's from
13:48:21 <mightybyte_> Ahh, that was my next question.  If it's localized to that package, or if it could be caused by a problem in one of its dependencies.
13:48:56 <clahey> `ramses: Maybe run it on a huge list and see what happens?
13:49:06 <clahey> `ramses: Or just use foldr?
13:49:45 <dcoutts> mightybyte_: if it's the usual problem, then the issue is that the package where the symbol is (supposed to be) defined is omitting that module from its .cabal file
13:49:58 <neutrino_> @hoogle just
13:49:58 <lambdabot> Prelude Just :: a -> Maybe a
13:49:58 <lambdabot> Data.Maybe Just :: a -> Maybe a
13:49:58 <lambdabot> Data.Text justifyLeft :: Int -> Char -> Text -> Text
13:50:42 <dcoutts> mightybyte_: ie if we're missing symbol foo-1.0-Foo.bar, then package foo is not listing the module Foo in it's .cabal file
13:52:20 <`ramses> clahey: I'm not folding a list, I search a "next best" from a double list, delete that element from all lists in the double list and repeat, accumulating the "next best" elements
13:52:30 <`ramses> I don't think I can easily get that into a foldr
13:52:57 <clahey> double list?
13:53:02 <`ramses> [[a]]
13:53:17 <zwass> Hey there, anyone know a package that will help with building a (non-Haskell) REPL into my Haskell program? (I've been told there may be one on Hackage, but haven't been able to find it)
13:53:24 <clahey> And what do you mean by next best?  You take the first element of each of them?
13:53:25 <beaky> is a list of strings a list or a nested list?A
13:53:29 <clahey> And compare them or something?
13:53:31 <mightybyte_> dcoutts: Hmmm, it doesn't look like that's the problem.
13:53:57 <typoclass> zwass: maybe the haskeline package?
13:54:04 <pdxleif> zwass: http://hackage.haskell.org/package/Shellac ?
13:54:08 <mightybyte_> It's complaining about Text.Digestive.Form.Encoding…ShowFormEncType2_closure
13:54:26 <pdxleif> It's used by a lambda calculus interpreter, for instance
13:54:45 <`ramses> clahey: no, I have a non-trivial function, :: [[a]] -> Maybe (a, [[a]]), that tries if there is a next element to take and returns that next element and the list with all occurences of that element removed
13:54:47 <mightybyte_> But that module is exported in the cabal file.
13:54:52 <clahey> `ramses: Well, regardless, try both ways and see which one runs faster?
13:54:53 <zwass> Thanks, pdxleif and typoclass. Just what I was looking for.
13:55:03 <`ramses> clahey: yeah, will do :)
13:55:06 <typoclass> zwass: you're welcome :-)
13:55:08 <clahey> `ramses: That sounds expensive.
13:55:40 <kuznero> Having a small issue with cabal-dev... Who knows how if it's possible to manually install dependencies with cabal-dev?
13:55:40 <clahey> `ramses: I'm guessing your algorithm is already more than O(n).
13:55:50 <`ramses> clahey: it is, but I have to examine all elements anyway to find the next best, I guess it runs O(n^2)
13:55:55 <clahey> `ramses: Oh, maybe use unfold?
13:55:57 <dcoutts> mightybyte_: don't know then, try rebuilding that package and see if that helps
13:56:09 <clahey> :t unfold
13:56:10 <lambdabot>     Not in scope: `unfold'
13:56:10 <lambdabot>     Perhaps you meant one of these:
13:56:10 <lambdabot>       `unfoldr' (imported from Data.List),
13:56:14 <clahey> :t unfoldr
13:56:15 <lambdabot> (b -> Maybe (a, b)) -> b -> [a]
13:56:27 <clahey> That's exactly what you want, right?
13:56:38 <`ramses> oh, that signature actually looks quite like what I have!
13:56:49 <LucaS05> i got some problem here http://hpaste.org/78876
13:56:51 <`ramses> thanks, I'll look into it!
13:57:03 <kuznero> Cabal-dev gurus?
13:57:53 <typoclass> kuznero: i think cabal has a flag "--only-dependencies" or "--dependencies-only". if cabal has it, cabal-dev probably has it too
13:58:25 <typoclass> kuznero: try putting the command you ran and the output it gave on hpaste
13:58:27 <typoclass> @where hpaste
13:58:27 <lambdabot> http://hpaste.org/
13:58:34 <dgpratt> I'm probably missing the bigger picture here, but it seems unfortunate that Setup.*hs is a standard part of Haskell packages
13:59:12 <macron> dgpratt: why that?
13:59:56 <dgpratt> macron: it seems to me that it makes packages non-declarative
14:00:03 <dgpratt> or not fully declarative
14:00:05 <dcoutts> dgpratt: historically the Setup.hs was intended as the primary interface to a package
14:00:06 <dgpratt> even if they could be
14:00:26 <dcoutts> dgpratt: and even now, it's the interface that distros use (and rightly so)
14:00:33 <kuznero> typoclass: how this will help me installing something manually? Exact issue is that I'm running small project in a sandbox that has a dependency to wxc (wxWidgets) which fails installing automatically - this is exactly why I need to kinda do the following (as I'm doing normally with cabal, not cabal-dev): * cabal unpack wxc; <fix blah.cpp>; cabal configure; cabal build; cabal install; But this time I need to do thi
14:00:33 <kuznero> s in my sandbox with cabal-dev somehow.
14:01:19 <dcoutts> dgpratt: but I somewhat agree, with the benefit of experience, the interface to a package should be initially the .cabal file, and secondarily the Setup.hs
14:01:37 <typoclass> kuznero: ah i see. have you tried "cabal-dev unpack ...", fix things, "cabal-dev configure" and so on?
14:01:56 <`ramses> clahey: it works and makes my code a lot simpler :)
14:01:59 <dcoutts> dgpratt: and additionally, in practice nobody uses totally custom Setup.hs (as was originally allowed for)
14:02:01 <dgpratt> dcoutts: at least if it was only present as necessary, that would be better, I think
14:02:11 <kuznero> typoclass: nope :) let me try that! thanks!
14:02:12 <kuznero> :)
14:02:29 <dcoutts> dgpratt: cabal can build packages with no Setup.hs, but distribution on hackage checks for it being there
14:02:43 <fmap> kuznero: btw, you don't need to do configure and build before install
14:02:45 <dcoutts> dgpratt: indeed cabal sdist will make a default one
14:03:09 <kuznero> fmap: good point, was always doing it :)
14:03:16 <kuznero> fmap: but this time I need to
14:03:28 <dcoutts> dgpratt: for example, at the moment it's impossible to declare that your Setup.hs itself depends on any package, or do any CPP in a Setup.hs etc
14:03:38 <neutrino_> hi
14:03:50 <neutrino_> i have a somewhat complicated question about monads
14:04:19 <neutrino_> say i have a piece of code which uses a monad. let's say that's a simplified version of IO which can only print to stdout, call it O.
14:04:34 <dcoutts> dgpratt: so I'd revise the cabal spec to make the Setup.hs a machine-oriented interface, not user, and make it secondary to the .cabal file as an initial entrypoint
14:05:03 <neutrino_> i would like to be able to run it in the O monad, but i would like to also be able to run it in the MO monad, which is the "mock output" monad. the output does not go to stdout, it only goes to a string which is returned by the runMO.
14:05:05 <dgpratt> dcoutts: I second that motion, make it so ;)
14:05:22 <neutrino_> how can i write code like this, where i can plug in different monads, so to speak?
14:05:35 <peteriserins> neutrino_: use monad transformers?
14:05:37 <neutrino_> or do i just need to keep the same monad, but a different run function?
14:05:45 <rwbarton> class Monad m => MonadO m where {- whatever -}
14:05:52 <neutrino_> peteriserins: i'm not sure how
14:06:11 <rwbarton> foo :: MonadO m => m ()
14:06:20 <byorgey> neutrino_: check out the 'operational' package
14:06:21 <neutrino_> bear in mind i want to use the same piece of code, but run it in one of two monads
14:06:28 <byorgey> it helps you do exactly that
14:06:31 <byorgey> among other things
14:06:39 <neutrino_> i'll check that out
14:06:42 <dcoutts> dgpratt: aye, if only I could work on cabal all day long :-(
14:06:49 <rwbarton> 'operational' is the other approach yes
14:06:52 <neutrino_> it sounds like something i'll need to do at some point during unit testing
14:07:00 <neutrino_> rwbarton: continue explaining your approach please
14:07:05 <neutrino_> i didn't understand it
14:07:28 <rwbarton> well you just make a type class for monads that support the operations you want to be able to use in your actions
14:07:48 <clahey> `ramses: I like it.
14:08:11 <neutrino_> so let's say i'd place putStrLnO in that class?
14:08:13 <rwbarton> and then define some instances
14:08:29 <rwbarton> instance MonadO IO where putStrLnO = putStrLn; instance MonadO (Writer [String]) where putStrLnO = tell
14:08:46 <rwbarton> then use your foo action at either type IO () or type Writer [String] ()
14:09:00 <kuznero> fmap: no, I don't need to call configure/build/install, but rather install in all the cases.... Btw, why then it is not automated yet in cabal?
14:09:05 <neutrino_> right
14:09:11 <rwbarton> what 'operational' basically does is give you a single "universal" instance of MonadO
14:09:19 <neutrino_> that's why we left foo polymorphic on m
14:09:27 <neutrino_> yes?
14:09:29 <rwbarton> yes
14:09:31 <dgpratt> dcoutts: given that cabal doesn't require Setup.hs, is there a good reason for hackage to?
14:09:34 <neutrino_> ahh, ok, i see
14:09:42 <neutrino_> what does that universal instance do?
14:09:44 <rwbarton> any m that is an instance of MonadO, so all it can do is Monad stuff and putStrLnO
14:10:03 <neutrino_> gotcha, that's pretty cool!
14:10:11 <dcoutts> dgpratt: the cabal spec says all packages should have a Setup.hs, because that's the primary interface, and tools rely on that spec (like distros)
14:10:17 <neutrino_> and much easier than i thought!
14:10:21 <dcoutts> dgpratt: that's why it's a spec revision issue
14:10:24 <mreh_> :t sequence_ . cycle
14:10:26 <lambdabot> Monad m => [m a] -> m ()
14:10:30 <dgpratt> dcoutts: I see
14:10:36 <dcoutts> kuznero: cabal install  does automate it by doing configure & build too
14:10:43 <mreh_> eh
14:10:46 <neutrino_> rwbarton: can i place putStrLn in my class?
14:10:58 <neutrino_> rwbarton: and shadow the already existing putStrLn this way?
14:11:12 <rwbarton> with operational you will get a single monad that has a putStrLnO operation and then any time you define an interpretation of putStrLnO in a particular monad then you get a way to convert the original monad to that new monad
14:11:18 <rwbarton> uh, I guess
14:11:28 <rwbarton> you could hide putStrLn and import it qualified
14:11:36 <neutrino_> ah
14:12:09 <neutrino_> gotcha
14:14:19 <LucaS05> problem solved!
14:14:40 <neutrino_> is there a mock version of the IO monad?
14:14:50 <LucaS05> anyway guys I hope you also have some problem when you start with haskell cause is not immediate....
14:15:07 <neutrino_> i'm thinking of being able to look at what files got what written to them, and being able to provide existing files
14:15:27 <neutrino_> similarly with handles
14:16:21 <rwbarton> I think I saw something like that on hackage but I forget what it was called
14:18:16 <neutrino_> same here. it's on the back of my tongue. seen it a year back or so.
14:19:14 <shachaf> lens now supports Overloaded Prismoid Mutator stabs
14:20:39 <monochrom> @stab monochrom
14:20:39 * lambdabot smashes a lamp on monochrom's head
14:20:45 <neutrino_> how can i join a thread?
14:21:05 <neutrino_> i don't know what to hoogle for :\
14:21:29 <SingingBoyo> neutrino_: it's in control.concurrent somewhere I think
14:21:37 <applicative> neutrino_: http://hackage.haskell.org/package/IOSpec/ maybe?
14:21:49 <typoclass> shachaf: but when will we get support for Overloaded Prismoid Doomsday Mutator stabs?
14:21:59 <peteriserins> rwbarton: my supervisor says that computables can be ordered in extension without choice. "There is a uniform wellorder of all the euivalence classes so you can define a choice function. I can't think offhand of an obviously cute way of doing it but that doesn't mean that there isn't one."
14:22:18 <neutrino_> applicative: oh, that might be it. pretty cool, thanks.
14:22:27 <applicative> neutrino_: associated with the paper http://www.cs.nott.ac.uk/~txa/publ/beast.pdf if I remember
14:24:09 <typoclass> neutrino_: there's some example code in the section "Terminating the program" http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Concurrent.html
14:24:32 <neutrino_> typoclass: nice! let me look at it
14:25:51 <typoclass> (i could'a sworn there was a "wait for thread" function somewhere, but apparently not ...)
14:26:14 <neutrino_> might be posix only?
14:26:19 <neutrino_> (i'm working on linux)
14:26:36 <shachaf> Nope.
14:26:51 <mapf> where can read about real implementation of PolyKinds? i can found only a proposal
14:26:56 <rwbarton> if you want to join on a thread then maybe you would want to use Control.Concurrent.Async
14:27:17 <neutrino_> why would i do that?
14:27:20 <dreixel> mapf: http://dreixel.net/research/pdf/ghp.pdf
14:28:03 <mapf> dreixel: oh, thank!
14:28:10 <neutrino_> basically, what i want to do is to fork off a thread, exec() a program in it, and in the main thread wait for execution and get the exit code.
14:28:12 <dreixel> you're welcome
14:28:46 <rwbarton> oh you are the fork/exec guy
14:28:55 <kuznero> neutrino_: http://www.mail-archive.com/haskell-cafe@haskell.org/msg33607.html
14:28:58 <neutrino_> rwbarton: yes
14:29:00 <neutrino_> it is i
14:29:15 <neutrino_> *deep laughter*
14:29:23 <SingingBoyo> neutrino_: unless you're doing something in the main thread at the same time, why fork in the first place?
14:29:45 <rwbarton> what's wrong with System.Process
14:29:59 <neutrino_> SingingBoyo: i am doing something in the main thread, i'll be checking the fork's stdout/err periodically and writing stuff to disk based on that
14:30:01 <typoclass> neutrino_: have you tried the ... er yeah, i second rwbarton
14:30:15 <neutrino_> we've all had this conversation already
14:30:25 <neutrino_> it really is fork then exec() because i need the pid
14:30:38 <neutrino_> :)
14:30:50 <rwbarton> do you actually need the pid as a number
14:30:56 <neutrino_> yeah
14:31:00 <rwbarton> createProcess gives you a handle to wait on the process
14:31:05 <rwbarton> pids are unsafe!!
14:31:11 <neutrino_> that's ok
14:31:20 <rwbarton> and fork/exec in haskell is lunacy
14:31:26 <rwbarton> well, in ghc anyways
14:31:32 <neutrino_> why is it lunacy?
14:31:48 <neutrino_> performUnsafeLunacy
14:32:01 <rwbarton> didn't we have this conversation before :P
14:34:03 <neutrino_> no before you didn't actually go into why it's lunacy
14:34:14 <neutrino_> you just said "ghc doesn't expect to be forked"
14:34:21 <neutrino_> but we never got to why
14:34:27 <neutrino_> so we can fill that in now :)
14:34:35 <rwbarton> see the giant warning on forkProcess
14:34:36 <typoclass> neutrino_: what are you going to do with the numeric pids?
14:34:39 <rwbarton> http://hackage.haskell.org/packages/archive/unix/latest/doc/html/System-Posix-Process-ByteString.html#v:forkProcess
14:35:15 <neutrino_> i need them for job control of runaway processes
14:36:20 <neutrino_> rwbarton: are you talking about that warning?
14:36:53 <neutrino_> rwbarton: what is the simplest piece of code that would trigger the dangerous behaviour mentioned there?
14:37:25 <rwbarton> the warning itself is enough for me not to use it
14:37:45 <neutrino_> i'm not scared of big warnings
14:37:49 <neutrino_> only small ones
14:37:59 <neutrino_> the devil's in the detail
14:38:28 <typoclass> neutrino_: anyway, i still think that job control of runaway processes could probably be done with the regular stuff from System.Process, in particular getProcessExitCode and terminateProcess
14:38:37 <neutrino_> nope
14:38:51 <rwbarton> well, consider these facts: System.Process defines a global lock using unsafePerformIO, and the fork/exec is not even done in Haskell, it is done in C
14:39:05 <rwbarton> so even GHC does not use forkProcess for this
14:39:06 * hackagebot vector-space 0.8.5 - Vector & affine spaces, linear maps, and derivatives  http://hackage.haskell.org/package/vector-space-0.8.5 (ConalElliott)
14:39:20 <neutrino_> sure
14:39:26 <neutrino_> i still need forkprocess though
14:39:30 <neutrino_> and i need the pid
14:39:30 <vamega1> Hi
14:39:44 <vamega1> I'm running into some issues with cabal, when trying to perform an update
14:40:03 <neutrino_> typoclass: this needs to be reported to other processes, that's why i need to know the pid, not have some non-transferrable handle to the process
14:40:49 <vamega1> cabal-install-1.16.0.2 depends on Cabal-1.16.0.3 which failed to install.
14:40:49 <vamega1> cabal install: /usr/hs/tools/cabal-0.14.0 failure (return code=1)
14:41:02 <neutrino_> i know haskell is nice and stuff, but this really has got to work more posixy than the usual modules like to
14:41:17 <neutrino_> and posix is not nice, i guess
14:41:35 <vamega1> That doesn't make much sense to me, since cabal-install seems to depend on a version of cabal greater that the cabal-install version
14:41:36 <neutrino_> vamega1: install Cabal first?
14:41:48 <typoclass> neutrino_: ok, just wanted to double-check
14:42:08 <vamega1> neutrino_ : is that just cabal install Cabal?
14:42:12 <neutrino_> yes
14:42:27 <neutrino_> in fact it's cabal install Cabal cabal-install
14:42:31 <monochrom> it may lead to the same error, the same point where you were stuck
14:42:45 <typoclass> vamega1: could you run the failing cabal command with "-v3" and put the output on hpaste?
14:42:47 <niteria> you install cabal via cabal?
14:42:48 <typoclass> @where hpaste
14:42:48 <lambdabot> http://hpaste.org/
14:42:49 <monochrom> but I would like to see the complete output
14:43:08 <vamega1> Sure
14:43:19 <Hafydd> @where waldo
14:43:19 <lambdabot> http://planet.haskell.org
14:43:34 <neutrino_> vamega1: try running my command first. i bet that's what you need.
14:43:38 <vamega1> I'm going to run cabal -v3 install Cabal cabal-install
14:43:46 <vamega1> and put that output on hpaste
14:43:46 <quchen> Is there some list of commands for Lambdabot?
14:44:08 <neutrino_> vamega1: no don't, just run it normally first and see if it succeeds.
14:44:18 <neutrino_> if it doesn't, run with -v3 and put it on hpaste.
14:44:32 <Hafydd> quchen: ask her in PM, @commands
14:44:59 <vamega1> I'm running the hub distribution of the haskell-platform if that makes any difference
14:45:25 <quchen> Hafydd: Thanks. It doesn't know @commands, but suggests @list when you type it in.
14:45:37 <neutrino_> the hub? don't eat those lizard on a stick
14:46:38 <quchen> @yhjulwwiefzojcbxybbruweejw
14:46:38 <lambdabot> "\"#$%&'()*+,\""
14:46:43 <quchen> ... really?
14:46:47 <elliott> really
14:46:55 <quchen> A useful command
14:47:03 <elliott> yes
14:47:05 <rwbarton> As useful as it is memorable
14:47:11 <quchen> If my special characters break I can just copy+paste them from #haskell
14:47:19 <rwbarton> well, ...
14:47:22 <quchen> @protontorpedo
14:47:23 <lambdabot> why would u write a interpreter for perl in haskell?
14:47:35 <quchen> @girl19
14:47:35 <lambdabot> am I supposed to be frantic with terror and anxiety?
14:47:48 <quchen> ... are these historic quotes from the channel or something?
14:47:51 <neutrino_> try using that in msg instead in here quchen
14:48:00 <quchen> Good point.
14:48:13 <vamega1> neutrino: http://www.justhub.org/
14:48:24 <vamega1> It was linked to off the haskell platform page
14:48:42 <vamega1> Seemed like a good way of getting a newer set of packages than what was available in my distro
14:49:07 * hackagebot docidx 1.1.0 - Generate an HTML index of installed Haskell packages and their documentation.  http://hackage.haskell.org/package/docidx-1.1.0 (AndyGimblett)
14:49:40 <monochrom> do you absolutely want the newer cabal-install?
14:49:56 <hpaste> vamega pasted “Cabal Error” at http://hpaste.org/78877
14:50:01 <vamega1> I'm not sure I do
14:50:13 <vamega1> When I ran cabal-update it told me to install cabal-install
14:50:15 <monochrom> alright, then my recommendation is don't "upgrade"
14:50:30 <monochrom> no, it is not a normative order
14:50:33 <hpaste> vamega pasted “Cabal Output” at http://hpaste.org/78878
14:50:50 <vamega1> Oh alright then, thanks
14:52:00 <neutrino_> i have absolutely no idea what hub is doing
14:52:02 <monochrom> do you have the env variable GHC_PACKAGE_PATH? as said in the error message
14:52:07 <neutrino_> this looks like something carayzay
14:53:36 <typoclass> vamega1: i agree with monochrom, i suspect the relevant line is this, but i'm not sure what to do about it -- "setup: Use of GHC's environment variable GHC_PACKAGE_PATH is incompatible with Cabal. Use the flag --package-db to specify a package database (it can be used multiple times)."
14:53:56 <monochrom> and yes I hate cabal-install nagging about "new version available". people mistake that as an absolute commendent to upgrade. it causes more problems than it solves.
14:54:39 <rwbarton> neutrino_: it looks like you could get the pid from System.Process.Internals   http://www.haskell.org/ghc/docs/latest/html/libraries/process-1.1.0.2/src/System-Process-Internals.html
14:54:51 <rwbarton> unless it's not exposed maybe
14:55:05 <monochrom> for most programmers it's best to just track the Haskell Platform.
14:55:06 <rwbarton> I guess it isn't
14:57:33 <rwbarton> importing it seems to work anyways in ghci at least
14:57:48 <b_jonas> monochrom: how about for libraries that are not in the Haskell Platform?
14:58:28 <monochrom> pick a version each time you upgrade the Haskell Platform
14:58:55 <dcoutts> monochrom: mm, I've also been wondering if I should disable that, or add a bit more control over when we suggest upgrades.
14:59:54 <rwbarton> a new version of cabal-install that can use the same version of Cabal shouldn't cause problems, right?
15:00:14 <monochrom> I consider this as a simple matter of consistency: "advise" new version of cabal-install iff "advise" new version of everything else under the sun
15:00:42 <vamega1> I think this might be a hub specific issue
15:00:52 <glguy> I think I want a mode where cabal never tries to upgrade stuff installed globally but is willing to upgrade installed in $USER
15:00:59 <vamega1> I'll confirm that when I fly back home and can test on my local install
15:01:21 <vamega1> glguy, I think that's what hub does for you
15:01:37 <vamega1> ( Either that or I've got a really bad idea of what hub does )
15:01:59 <dcoutts> monochrom: I don't think that's true, it should be fine to use a later cabal-install with an older set of other tools (ghc libs etc)
15:02:07 <vamega1> Hub  generalizes that thought, so that any directory can have it's own version of things if necessary
15:02:16 <dcoutts> glguy: or more generally a pinned set
15:02:28 <glguy> dcoutts: I’d be happy with more generality :)
15:03:08 <dcoutts> glguy: I'm moving more towards the idea that we should enforce that a single package environment (view / sanbox, whatever you want to call it) should have only one version of everything, including the usual per-user view.
15:03:10 <monochrom> it should be fine to thuly bring in a second version of Cabal (the lib), too?
15:03:15 <typoclass> i think the phrasing makes a world of difference. ("advice: ..." or "warning: ..." or whatever)
15:03:25 <glguy> I can do it manually with --constraint
15:03:56 <monochrom> I don't think so. years of watching this channel says two versions of any lib is confusing. for most people anyway. I know you pros have 10 versions of everything, that's not my point
15:04:25 <dcoutts> glguy: and so we should install new packages into the environment if they're consistent with the current ones, or if not, rebuild things to get the same packages
15:05:16 <dcoutts> glguy: and if that's not possible, if we'd have to throw existing packages out of the current env, then we don't do it, or we get the user to explicitly create a new view
15:05:47 <dcoutts> ie nix-like, and with each view into the package store having only one version of anything
15:06:17 <dcoutts> so, you'd start with your view being the HP, and so by default only install things compatible with that
15:06:22 <glguy> Is there a way (without throwing out all of .ghc and starting over) to get things built with --dynamic ?
15:06:52 <dcoutts> when that's not possible, then the user has to make a secondary view/env, or otherwise explicitly indicate they want to change their environment
15:07:00 <glguy> since cabal doesn’t know if you installed things with [static/dynamic]x[profiling,normal], changing any of those options seems to invalidate everything
15:07:04 <dcoutts> and switching between views/environments should be easy
15:07:26 <dcoutts> glguy: the right way to do that is to register each way separately
15:08:12 <dcoutts> glguy: so the answer at the moment, just like for profiling or installing docs, is no, we (ghc-pkg & cabal) don't track it so it's hard.
15:08:42 <glguy> Just making sure I hadn’t missed some new fancy feature :)
15:09:10 <rwbarton> dcoutts: sounds like this would help also with cabal not backtracking flags because it "succeeded" in finding an install plan (that would break other packages)
15:09:31 <rwbarton> er, help with the problem of that
15:10:25 <dcoutts> rwbarton: not sure, depends on exactly what you mean
15:11:08 <rwbarton> well, I remember one case where someone was trying to install a package with a "use blaze-html 3.5?" flag, which defaulted to false
15:11:09 <buhman> http://sprunge.us/ASai
15:11:21 <dcoutts> rwbarton: with this view/env idea, we'd tell the solver to find a solution that includes all the existing packages
15:11:28 <rwbarton> they already had blaze-html 3.5 installed
15:11:48 <rwbarton> but cabal install by default wanted to install the version that didn't use blaze-html 3.5
15:12:13 <rwbarton> but it didn't actually do the install because this would break some other packages for some reason that I forget
15:12:32 <rwbarton> if it was impossible to install blaze-html 3.4, then cabal-install would have backtracked to setting the flag to true
15:12:56 <buhman> so why are "directory" "process" and "unix" "missing or recursive" when they in fact exist?
15:12:59 <dcoutts> rwbarton: preferences on flags is a bit tricky, there's two cases we want to distinguish
15:13:37 <dcoutts> rwbarton: there are flags which people use which are completely determined by the versions of deps that we pick, those should have their prefs considered differently than "real" feature flags
15:13:44 <rwbarton> right, okay
15:14:43 <dcoutts> rwbarton: according to our informal spec we're actually doing the right thing there, because the package author indicated the "use blaze 3.5" should not be picked, unless it was impossible.
15:14:56 <monochrom> buhman: you have too many instances of directory, process, unix installed. it confuses ghc.
15:15:10 <rwbarton> yes,  but in practice it's a problem
15:15:37 <dcoutts> rwbarton: because the meaning of the preference is wrong
15:15:52 <buhman> monochrom: how do I fix this?
15:16:02 * dcoutts disappears
15:16:13 <rwbarton> hehe
15:16:16 <monochrom> erase the extra instances
15:16:42 <monochrom> use "ghc-pkg unregister" to erase the extra instances
15:17:19 <shachaf> Aw, dcoutts disappeared before I could ask about unboxed tuples.
15:17:33 <Nereid> make him undisappear!
15:21:34 <acowley> Darnit, I am once again having the problem where hlint by way of ghc-mod can't find modules.
15:21:47 <acowley> Why wouldn't it look in ~/.cabal?
15:22:38 <monochrom> no one look in ~/.cabal for modules. no one. not even ghc.
15:22:50 <acowley> Sorry
15:22:55 <monochrom> ghc looks into ~/.ghc/somethingsomething for modules
15:23:12 <acowley> I meant ~/.ghc/x86_64-darwin-7.6.1/package.conf.d/ in my case
15:23:30 <monochrom> then I don't know
15:23:33 <acowley> but my question is more, what would cause hlint to not find things?
15:24:07 * hackagebot kit 0.7.10 - A dependency manager for Xcode (Objective-C) projects  http://hackage.haskell.org/package/kit-0.7.10 (NickPartridge)
15:24:09 * hackagebot HTF 0.10.0.0 - The Haskell Test Framework  http://hackage.haskell.org/package/HTF-0.10.0.0 (StefanWehr)
15:29:07 * hackagebot HTF 0.10.0.1 - The Haskell Test Framework  http://hackage.haskell.org/package/HTF-0.10.0.1 (StefanWehr)
15:30:41 <applicative> buhman: what does ghc-pkg check say?
15:31:26 <monochrom> it will detect no problem. "ghc -v" is the one that knows the problem
15:32:43 <zomg> If I have a function with signature m a, and I lift something to IO there, how can I avoid do notation if I want to chain with another function of type m a ?
15:32:46 <monochrom> when you have multiple instances, you get shadowing. "ghc-pkg check" does not care about shadowing. ghc does.
15:32:52 <applicative> monochrom: Is it because this doesn't really entail that any package is broken>
15:33:12 <typoclass> zomg: you could use "action1 >> action2" ?
15:33:26 <zomg> No, the result from the IO function is used as a parameter for the second one
15:34:01 <monochrom> I don't know. what counts as "broken". when ghc refuses to continue, is that "broken"? or do you consider that "not broken, as long as there is no permanent data loss, nothing is broken"?
15:34:39 <monochrom> because when shadowing happens, there is no permanent data loss, just ghc refusing to continue
15:34:46 <zomg> typoclass: something like do x <- lift myIo; otherFun x would of course work, but just trying to figure out if I can do it without do :)
15:35:23 <`ramses> zomg: lift myIo >>= otherFun
15:35:25 <applicative> monochrom: it's just that when I have got the 'missing recursive blah blah' it wasn't just just that I had 2 versions of something, but one had overwritten the other
15:36:08 <applicative> lift myIo L >>= otherFun , zomg??
15:36:12 <zomg> with that, I just get an error about types, couldn't match expected type IO a with actual GHandler sub0 master0 RepJson
15:36:41 <applicative> lift myIo  >>= otherFun   rather
15:36:42 <`ramses> zomg: that's exactely the same as what the do block does, so the do should give the same errors then..
15:36:56 <`ramses> applicative: that's what I said :)
15:37:11 <applicative> `ramses: ah okay, just baffled.
15:37:27 <buhman> applicative: http://sprunge.us/LiZB
15:37:28 <applicative> `ramses: oh I see it right there :)
15:37:31 <zomg> `ramses: nope :)
15:37:59 <`ramses> @undo do x <- lift myIo; otherFun x
15:37:59 <lambdabot> lift myIo >>= \ x -> otherFun x
15:38:08 <buhman> looks like I broke it
15:38:10 <monochrom> well, I guess this case is spectacular
15:38:18 <zomg> `ramses: otherFun isn't in IO
15:38:20 <applicative> buhman: did you remove .cabal earlier?
15:38:25 <buhman> erm yeah
15:38:45 <buhman> can I just nuke the whole thing and start over?
15:39:08 * hackagebot HTF 0.10.0.2 - The Haskell Test Framework  http://hackage.haskell.org/package/HTF-0.10.0.2 (StefanWehr)
15:39:15 <applicative> buhman: you just didn't nuke enough.  The stuff in .ghc ;; monochrom can say what, I always forget
15:39:16 <`ramses> zomg: ok, I'm no expert either, I only know that the code you posted is just a regular bind..
15:39:24 <monochrom> removing .cabal is not enough. we need to see my http://www.vex.net/~trebla/haskell/sicp.xhtml#remove
15:39:26 <zomg> `ramses: yeah that's what I thought too :P
15:40:16 <zomg> I wonder if this'll work...
15:40:21 <zomg> @undo do x <- lift myIo :: IO a; otherFun x :: m a
15:40:21 <lambdabot> lift myIo :: IO a >>= \ x -> otherFun x :: m a
15:40:22 <buhman> http://sprunge.us/GGND that looks slightly better
15:40:26 <zomg> Hmh
15:40:43 <`ramses> I don't know if @undo does any typechecking
15:40:47 <`ramses> so might not be relevant
15:41:07 <`ramses> you don't have to know the types to rewrite the do syntax
15:41:22 <applicative> buhman: ghc is looking at into /home/zack/.ghc/<ghcversionname>/package.conf.d
15:41:37 <buhman> applicative: yeah, I just nuked .cabal and .ghc again
15:41:45 <buhman> applicative: and afterward I get http://sprunge.us/GGND
15:43:53 <applicative> hm, some things still want the older bytestring but I guess your ghc / platform came with bytestring-0.10?
15:44:22 <applicative> you can see what it thinks you have with ghc-pkg list, I guess you know
15:45:01 <monochrom> if you force reinstall, this is just seed for the same problem again next time
15:45:27 <buhman> yeah bytestring-0.10.0.0
15:46:12 <gwern> >  sort "gendoikari"  == sort "ignoreakid"
15:46:14 <lambdabot>   True
15:46:36 <Nereid> zomg: you're going to have to lift the other one to IO
15:47:16 <zomg> Nereid: yeah I just realized I was doing lift $ fun >>= ... instead of lift fun >>= ...
15:47:19 <zomg> :P
15:47:31 <zomg> So of course it wouldn't work
15:47:32 <Nereid> yeah, or chain them in m and lift the whole thing
15:47:33 <monochrom> I guess pandoc is not ready for ghc 7.6
15:47:50 <Nereid> monochrom: why not?
15:47:53 <monochrom> or something pandoc depends on
15:48:18 <monochrom> because someone wants bytestring that's in 7.4 but not in 7.6
15:48:35 <Nereid> oh, I had to specify a flag to get it to work
15:48:39 <Nereid> blaze_html_0_5
15:48:54 <monochrom> nice, that may help buhman
15:49:04 <buhman> erm
15:49:25 <Nereid> I wish cabal was smarter about choosing flags.
15:49:36 <buhman> heh, seems to work
15:50:20 <Nereid> as in: if one flag combination requires some reinstalls and the other doesn't, it should pick the latter
15:51:03 <monochrom> it has sufficiency backtracking ability. it just doesn't decide backtrack when it sees reinstall
15:51:20 <Nereid> yeah :(
15:52:38 <buhman> Nereid: thanks :D
15:52:52 <Nereid> np
15:52:53 <Nereid> :)
15:53:50 <monochrom> this is why Haskell Platform says: no 7.6 until April
15:54:47 <malorie> bah. why is subtract the wrong way around?
15:54:52 <malorie> > 1 `subtract` 0
15:54:54 <lambdabot>   -1
15:55:12 <monochrom> because the intended use is not 1 `subtract` 0
15:55:22 <malorie> it's for the (-) right section?
15:55:27 <monochrom> yes
15:55:27 <Nereid> yes
15:55:31 <malorie> fair enough
15:55:31 <vraid> subtract 1 (from) 0 ?
15:55:49 <Nereid> > (subtract 0) 1
15:55:51 <lambdabot>   1
15:58:01 <Hafydd> > 1 `flip subtract` 0
15:58:03 <lambdabot>   <hint>:1:9: parse error on input `subtract'
15:58:26 <vraid> > 1 flip `subtract` 0
15:58:27 <lambdabot>   -1
15:58:28 <monochrom> you can't have compound expressions inside ` `
15:58:35 <Hafydd> I'd better read the RFC again.
15:58:49 <Hafydd> Um, I mean... the BNF
15:58:50 <malorie> > (`(-)` 0) 1
15:58:52 <lambdabot>   <hint>:1:3: parse error on input `('
15:58:55 <vraid> what does the ` ` signify, actually?
15:59:01 <monochrom> infix
15:59:07 <vraid> ah yeah
15:59:08 <Nereid> a `f` b = f a b
15:59:21 <Nereid> the opposite to (*) a b = a * b
15:59:25 <vraid> does it work for any two-argument function?
15:59:31 <Nereid> yes
15:59:31 <monochrom> observe that you wrote (subtract (1 flip) 0)
15:59:47 <Nereid> > 1 `flip subtract` 0
15:59:49 <lambdabot>   <hint>:1:9: parse error on input `subtract'
15:59:52 <Nereid> yeah
16:00:00 <Nereid> > let f = flip subtract in 1 `f` 0
16:00:02 <lambdabot>   1
16:00:44 <Nereid> @src subtract
16:00:44 <lambdabot> subtract x y = y - x
16:01:04 <Hafydd> @src (-0)
16:01:04 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
16:01:07 <Hafydd> @src (-)
16:01:07 <lambdabot> x - y = x + negate y
16:01:12 <Nereid> @src negate
16:01:13 <lambdabot> negate x = 0 - x
16:01:17 <Hafydd> :O
16:01:23 <fmap> vraid: FSVO "two-argument function"
16:01:31 <vraid> FSVO?
16:01:33 <fmap> > ((:) `foldr` []) [1..5]
16:01:35 <lambdabot>   [1,2,3,4,5]
16:01:36 <Nereid> "for some value of"
16:01:55 <Nereid> any n-argument function is a 2-argument function, for n >= 2
16:02:20 <Nereid> > (id `id` id) id `id` id 5
16:02:22 <lambdabot>   5
16:02:25 <monochrom> polymorphic functions can be n-argument functions, too
16:02:37 <monochrom> @quote monochrom 17-ary
16:02:37 <lambdabot> monochrom says: I am 17-ary, going on 18-ary, I can take curry of you
16:02:53 <Hafydd> Hahah.
16:03:09 <Nereid> exercise: write down the types of each id there :(
16:03:11 <vraid> > 5 `add` 3
16:03:12 <lambdabot>   Not in scope: `add'
16:03:12 <lambdabot>  Perhaps you meant one of these:
16:03:12 <lambdabot>    `odd' (imported fro...
16:03:21 <vraid> > 5 `subtract` 3 2
16:03:23 <lambdabot>   -2
16:03:25 <Nereid> > 3 2
16:03:27 <lambdabot>   3
16:03:35 <vraid> ah
16:04:50 <Nereid> > f `id` x
16:04:52 <lambdabot>   Ambiguous type variable `a0' in the constraints:
16:04:52 <lambdabot>    (GHC.Show.Show a0)
16:04:52 <lambdabot>     ...
16:04:54 <Nereid> > f `id` x :: Expr
16:04:56 <lambdabot>   f x
16:09:47 <Chathurga> I'm getting an error that I can't figure out, I've reduced it to as small a piece of code as I can: http://hpaste.org/78880 The error is: No instance for (Data.String.IsString [a0]) arising from the literal `"abc"'
16:10:10 <Chathurga> Am I missing something incredibly obvious?
16:10:46 <Nereid> Chathurga: you're using OverloadedStrings, and it doesn't know what concrete type to pick for "abc"
16:10:59 <rwbarton> this sort of thing happens when you have excessive overloading
16:11:02 <Chathurga> There's no includes
16:11:12 <Nereid> it's an extension, not an include
16:11:17 <Nereid> writing ("abc" :: String) will fix it
16:11:49 <Chathurga> oh I thought I'd have to include a new string class for it to even know such things existed
16:12:03 <Nereid> no, typeclasses don't work that way
16:12:38 <S11001001> Nereid: classic first line on entering #haskell
16:13:05 <Nereid> someone could import your code and write a IsString [Int] instance and write palindrome "abc" and then even you wouldn't know which one to pick.
16:14:08 * hackagebot zoom-cache 1.2.1.6 - A streamable, seekable, zoomable cache file format  http://hackage.haskell.org/package/zoom-cache-1.2.1.6 (ConradParker)
16:15:10 <Chathurga> Ah I see, I thought there was no ambiguity in this case so it would infer String but I see the problem
16:15:57 <xenocons> is there a built-in for finding the index of a given char in a string?
16:16:14 <fmap> :t findIndex
16:16:16 <lambdabot> (a -> Bool) -> [a] -> Maybe Int
16:16:31 <xenocons> heh, thanks
16:16:40 <fmap> :t findIndices
16:16:41 <lambdabot> (a -> Bool) -> [a] -> [Int]
16:16:46 <xenocons> kept googling 'indexof'
16:17:28 <andsens> I have a problem where I am not sure if there is some kind of pattern that I can apply.
16:17:30 <shachaf> @hoogle Char -> String -> Maybe Int
16:17:31 <lambdabot> Data.List elemIndex :: Eq a => a -> [a] -> Maybe Int
16:17:31 <lambdabot> Data.Time.Format parseTime :: ParseTime t => TimeLocale -> String -> String -> Maybe t
16:17:31 <lambdabot> Data.Text.Encoding.Error ignore :: OnError a b
16:17:36 <shachaf> xenocons: ☝
16:18:01 <fmap> :t elemIndices
16:18:02 <lambdabot> Eq a => a -> [a] -> [Int]
16:18:07 <Nereid> Chathurga: the main point is that typeclasses are open, which means
16:18:09 <fmap> oh, even that exists
16:18:12 <xenocons> findIndex (== 'c') "abc" works
16:18:17 <xenocons> > findIndex (== 'c') "abc" works
16:18:18 <lambdabot>   Not in scope: `works'
16:18:18 <lambdabot>  Perhaps you meant one of these:
16:18:19 <lambdabot>    `words' (imported...
16:18:19 <Nereid> any working code should continue work even if additional instances are written
16:18:25 <xenocons> > findIndex (== 'c') "abc"
16:18:27 <lambdabot>   Just 2
16:18:28 <shachaf> xenocons: Did you see what I wrote above?
16:18:36 <andsens> I have a list of items referring to each other. These items should be filtered, so that conflicts are removed, I want to split that list up into valid items, warnings and errors.
16:18:39 <Nereid> (such that the instances don't overlap, etc)
16:18:43 <xenocons> shachaf: that came out as umm i cant really see it
16:18:52 <shachaf> @hoogle Char -> String -> Maybe Int
16:18:53 <lambdabot> Data.List elemIndex :: Eq a => a -> [a] -> Maybe Int
16:18:53 <lambdabot> Data.Time.Format parseTime :: ParseTime t => TimeLocale -> String -> String -> Maybe t
16:18:53 <lambdabot> Data.Text.Encoding.Error ignore :: OnError a b
16:18:57 <shachaf> Right there.
16:19:02 <shachaf> Do you know about Hoogle?
16:19:06 <shachaf> (You do now.)
16:19:16 <andsens> How can I do that so I can run various checks over these items, any one of them may return an error
16:19:23 <scp_> :w
16:19:26 <xenocons> shachaf: cool
16:19:29 <Chathurga> Nereid: Ah that is a satisfying answer, thanks
16:19:30 <scp_> sorry, you're not vim =]
16:19:42 <xenocons> so you give a type signature and it returns a candidate function that matches?
16:20:11 <xenocons> im guessing this is a unique feature of lambdabot heh
16:20:19 <Nereid> xenocons: there's also a hoogle website
16:20:25 <shachaf> @google hoogle
16:20:27 <lambdabot> http://www.haskell.org/hoogle/
16:20:27 <lambdabot> Title: Hoogle
16:20:29 <shachaf> (Do you know about Google?)
16:20:30 <xenocons> cool
16:20:32 <shachaf> (You do now!)
16:20:43 <xenocons> that is very cool
16:20:54 <xenocons> should steal this and write a F# version hmm
16:21:08 <Nereid> except it doesn't index every package ever, so you may also want to use hayoo
16:21:14 <Nereid> which indexes everything on hackage?
16:21:44 <xenocons> oh neat
16:21:50 <clahey> foogle!
16:22:22 <applicative>  @hoogle (a -> b) -> [a] -> [b]
16:22:44 <applicative> @hoogle (a -> b) -> [a] -> [b]
16:22:44 <lambdabot> Prelude map :: (a -> b) -> [a] -> [b]
16:22:44 <lambdabot> Data.List map :: (a -> b) -> [a] -> [b]
16:22:44 <lambdabot> Control.Parallel.Strategies parMap :: Strategy b -> (a -> b) -> [a] -> [b]
16:23:32 <clahey> Is haskell the only popular pure functional programming language?
16:24:05 <applicative> clahey: no, Excel is more popular
16:24:08 * hackagebot kit 0.7.11 - A dependency manager for Xcode (Objective-C) projects  http://hackage.haskell.org/package/kit-0.7.11 (NickPartridge)
16:24:09 <Nereid> haha
16:24:18 <andsens> scheme, lisp, F#?
16:24:21 <andsens> ml?
16:24:29 <Nereid> lisps aren't pure
16:24:37 <Elench> Lysis aren't generally pure functional
16:24:47 <Elench> *lisps
16:24:51 <andsens> didn't know. but scheme and ml are, right?
16:24:55 <Nereid> scheme is a lisp
16:25:06 <Elench>  And isn't purely
16:25:11 <jerojasro> mutation is easily available in scheme
16:25:13 <Elench>  functional
16:25:26 <clahey> applicative: An interesting point.
16:25:47 <andsens> huh, my programming languages professor would probably headbutt me right now for not knowing this stuff
16:25:51 <clahey> applicative: Not exactly a language, but pretty dang close.
16:26:00 <Nereid> applicative: what makes excel functional?
16:26:49 <Nereid> I agree with it being pure
16:27:19 <clahey> Oh, right.  Do excel formulas support some sort of first class function?
16:27:30 <applicative> Nereid: http://research.microsoft.com/en-us/um/people/simonpj/papers/excel/index.htm
16:27:59 <elliott> excel isn't pure
16:28:08 <xenocons> (F# is also not pure)
16:28:21 <Nereid> ok, a reasonably large fragment of it is pure?
16:28:24 <A1kmm> Does anyone know what the most idiomatic way to make a Data.Conduit.ResumableSource without supplying any initial data is? liftM fst . (mempty $$+) :: (Monad m => Sink a m b -> m (ResumableSource m a)) is ugly and unnecessarily in m
16:28:31 <A1kmm> Ideally I would want a function Monad m => Sink a m b -> ResumableSource m a
16:32:23 <applicative> doesnt excel have something like 'random' you can use where you might use, say 3
16:33:45 <monochrom> when you need a random number, type in "4" :)
16:34:07 <clahey> applicative: Is that paper implemented in excel?
16:34:52 <Nereid> I'm confused, is that describing ordinary excel or an extension to excel?
16:34:53 <applicative> clahey: i don't know; there's a powerpoint though....  web.cecs.pdx.edu/~black/S3S/PeytonJones.ppt
16:35:24 <Nereid> looks like an extension
16:35:24 <geekosaur> http://spreadsheets.about.com/od/excelfunctions/qt/080218_rand.htm
16:35:42 <clahey> Right, so without that extension to excel, excel is not functional.
16:36:13 <clahey> geekosaur: Win.
16:36:39 <geekosaur> spreadsheets are often mischaracterized as functional because they have a data-dependency-oriented solver and they work based on formulas.
16:37:03 <Nereid> "reactive" would be more appropriate?
16:37:06 <clahey> They do have a lot of the characteristics of being pure.
16:37:30 <clahey> Anyway, I'm going to go dance.  Talk to y'all later!
16:57:50 <xenocons> when you are passing in a function as a parameter (for example the function `*') what type signature should i give it? Num?
16:57:59 <shachaf> What?
16:58:14 <shachaf> I don't know what the rest of your sentence meant, but Num isn't a type.
16:58:22 <shachaf> Try giving an example. :-)
16:58:27 <xenocons> its the interface? okay
16:58:32 <shachaf> (Better yet, give ghci an example and let it infer the type for you.)
16:58:37 <shachaf> It's a type class.
16:58:45 <xenocons> test a b c = (b a c)
16:58:50 <fmap> :k Num
16:58:51 <lambdabot> * -> Constraint
16:58:52 <xenocons> test 5 (*) 3
16:59:02 <Nereid> :t (*)
16:59:04 <lambdabot> Num a => a -> a -> a
16:59:07 <shachaf> What's the question?
16:59:20 <xenocons> how do i write the type signature as test :: ?? -> int
16:59:30 <Nereid> :t ?test 5 (*) 3
16:59:31 <lambdabot> (?test::a -> (a1 -> a1 -> a1) -> a2 -> t, Num a2, Num a1, Num a) => t
16:59:44 <xenocons> thats awfully long
16:59:48 <Nereid> you can specialize it
17:00:14 <Nereid> :t ?test (5::Int) (*) (3::Int) :: Int
17:00:16 <lambdabot> (?test::Int -> (a -> a -> a) -> Int -> Int, Num a) => Int
17:00:24 <Nereid> oops
17:00:27 <ziman> :t ($)
17:00:29 <lambdabot> (a -> b) -> a -> b
17:00:31 <shachaf> xenocons: Why don't you figure out what test does first and then figure out its type?
17:00:39 <shachaf> @ty let test x f y = f x y in test
17:00:41 <lambdabot> t1 -> (t1 -> t2 -> t) -> t2 -> t
17:00:48 <shachaf> No Num involved.
17:00:54 <xenocons> hmm
17:01:00 <shachaf> a -> (a -> b -> c) -> b -> c would be a nicer way of writing that, of course.
17:01:07 <xenocons> right
17:01:10 <shachaf> @ty let test x f y = f (x+1) (y+1) + 1 in test
17:01:12 <lambdabot> (Num a, Num a1, Num a2) => a1 -> (a1 -> a2 -> a) -> a2 -> a
17:01:18 <xenocons> i dont understand what 't1' is
17:01:23 <Nereid> it's a type variable
17:01:24 <Nereid> like a
17:01:24 <shachaf> It's just a type variable.
17:01:29 <xenocons> ah right
17:01:34 <shachaf> It's a pretty bad name for a type variable.
17:01:46 <Nereid> it's what it does when it runs out of 't's
17:01:58 <xenocons> heh like with a
17:02:04 <shachaf> Nereid: Yes, but it shouldn't be.
17:02:15 <Nereid> what should it do?
17:02:26 <shachaf> Make up new one-letter names.
17:02:33 <vraid> t, т, τ
17:02:39 <vraid> naturally
17:02:45 <Peaker> lamdu makes "a", "b", ...
17:17:00 <randomclown> If I have a record data type i.e. newType MyType = MyType { unpack :: Int -> Int }, if I just put MyType in the module exports, is the "unpack" function exported as well?
17:17:30 <randomclown> newtype*
17:17:48 <Mortchek> No, but MyType(..) does that.
17:18:12 <Mortchek> (Exports the type and all its constructors.)
17:19:09 <randomclown> Mortchek: but unpack isnt a constructor
17:20:05 <Mortchek> Oh, er, my mistake
17:23:41 <Mortchek> "When the (..) form of import is used for a type or class, the (..) refers to all of the constructors, methods, or field names exported from the module."
17:23:51 <Mortchek> From the Report
17:23:57 <shachaf> That's about imports.
17:24:05 <shachaf> But it works for exports too.
17:24:11 <Mortchek> Ah, right.
17:25:09 <randomclown> ugh. Trying to write a transformer for Data.Binary.Get
17:25:38 <randomclown> impossible because they don't export the Get accessor
17:25:45 <davesque_> so with ghc, the io monad essentially keeps track of a fake counter value in order to order execution of io actions...but, how does it propagate error states?  the maybe monad does this with Nothing values.  is there any way that the io monad does this?
17:26:42 <davesque_> anyone have any thoughts on that question?
17:27:22 <elliott> davesque_: the IO monad does not keep track of a fake counter value, if that helps
17:27:23 <Nereid> IO is magical.
17:28:26 <davesque_> well, it's a real world value, which is passed between io actions and is required for evaluation, is that not correct?  this is according to the io wiki at haskell.org
17:28:53 <davesque_> it's hidden, happens in the background
17:29:10 * hackagebot lens 3.6.0.4 - Lenses, Folds and Traversals  http://hackage.haskell.org/package/lens-3.6.0.4 (EdwardKmett)
17:29:41 <Nereid> davesque_: but it's doesn't really hold the real world
17:29:49 <Nereid> in actuality it doesn't hold anything at all
17:29:49 <elliott> davesque_: there is no actual real world value.
17:29:58 <davesque_> right
17:30:00 <elliott> it doesn't exist at runtime, it's a compiler trick to prevent reordering
17:30:05 <elliott> (also this is a GHC implementation detail)
17:30:06 <davesque_> yes, i read that too
17:30:35 <elliott> basically the naive reading of the IO monad as a state monad with a realworld token as the state is inaccurate... it is actually just IO a = a with some hackery to stop the compiler reordering stuff
17:31:03 <davesque_> i don't know why i mentioned it.  perhaps just to give some context.  my real question is how or if io monads propagate error conditions.
17:31:05 <shachaf> That's the implementation in GHC
17:31:17 <shachaf> Oh, that's what you're talking about.
17:32:07 <elliott> well it's not done "in the monad"
17:32:11 <elliott> in fact you can throw exceptions even outside of IO
17:32:17 <elliott> it just raises them like any normal language, more or less
17:32:29 <davesque_> mkay
17:33:10 <Nereid> but somehow you can catch them in IO.
17:33:54 <davesque_> and the fail function has nothing to do with it, yes?  that's just what gets called when pattern matching fails in a bind statement?
17:34:09 <Nereid> in a do block*
17:34:12 <davesque_> ahh
17:34:13 <shachaf> fail is unrelated to anything.
17:34:24 <davesque_> okay, good :)
17:34:28 <Nereid> do { x <- m; y } is like
17:34:42 <shachaf> @undo do P x <- m; y
17:34:42 <lambdabot> m >>= \ a -> case a of { P x -> y; _ -> fail ""}
17:34:47 <Nereid> yes
17:35:01 <davesque_> ahh, okay
17:35:05 <Nereid> I didn't know undo knew that.
17:35:15 <elliott> I did
17:35:19 <Nereid> I do now
17:35:51 <davesque_> well, i guess in order to find out what i want to know, i should google around for "haskell exceptions" or something?
17:37:26 <davesque_> i'll take that as a yes
17:38:03 <ParahSailin> it seems slightly inconsistent that length for MVector -> Int but pretty much everything else -> m (result)
17:40:21 <Nereid> why? you can't mutate the length of a MVector.
17:40:42 <Nereid> so the type tells you that.
17:43:55 <ParahSailin> Nereid, so when you grow an MVector, the old MVector become invalid?
17:44:13 <Nereid> when you grow a MVector, you get a new one
17:44:37 <Nereid> which is why it returns a new one, not a m ()
17:45:46 <ParahSailin> so grow copies contents into a larger mutablearray?
17:46:05 <Nereid> I don't know anything about it, but my first guess is that it doesn't copy but it's still safe to use the old one
17:46:15 <Nereid> (since you can only grow, not shrink)
17:49:10 * hackagebot RANSAC 0.1.0.1 - The RANSAC algorithm for parameter estimation.  http://hackage.haskell.org/package/RANSAC-0.1.0.1 (AnthonyCowley)
17:50:43 <acowley> I needed to --force-reinstalls on travis-ci to get it to stop complaining about regex libraries. At least it went through, and gives me a way to test against 7.4.1!
17:54:41 <Ololo> @pl \x y -> x ++ [y]
17:54:41 <lambdabot> (. return) . (++)
17:54:56 <shachaf> Don't do it, Ololo!
17:55:18 <Ololo> shachaf: I just did that by hand, just checked
17:55:52 <newbix> hi guys i need some advice whether the curried function i made is the most efficient/best way to do what I'm trying to accomplish. For example print (sigma (+ 1) 1 2)  would print 5.
17:56:14 <hpaste> newbix pasted “function” at http://hpaste.org/78884
17:57:00 <newbix> it's basically the summation of a function
17:57:08 <Ololo> shachaf: not so long ago I thought it's impossible, but type-driven design helps a lot
17:57:25 <shachaf> Ololo: What would be impossible?
17:57:42 <Ololo> shachaf: writing something like this by hand
17:57:49 <shachaf> Oh.
17:57:57 <shachaf> Well, there are very mechanical rules for it. :-)
17:58:14 <Nereid> @type \f m n -> sum (map f [m..n])
17:58:16 <lambdabot> (Enum a1, Num a) => (a1 -> a) -> a1 -> a1 -> a
17:58:26 <Ololo> shachaf: Still not that much mechanical for me
17:58:44 <shachaf> Ololo: Well, you can always do it SKI-style.
17:58:46 <newbix> @Nereid i can't use map or folds
17:58:46 <lambdabot> Unknown command, try @list
17:59:09 <Ololo> shachaf: no, thanks :)
17:59:10 * hackagebot edge 0.8.18 - Top view space combat arcade game  http://hackage.haskell.org/package/edge-0.8.18 (ChristopherHoward)
17:59:27 <Nereid> newbix: you can initially, and then expand it  :p
17:59:33 <Nereid> (actually the sum and map could be fused here)
18:00:13 <Ololo> shachaf: pl-style would be better, but last time I read pl's sources, I didn't understand a thing. It was 2 years ago, though.
18:00:19 <newbix> Nereid: what I mean is i'm not allowed to use the map function to solve for this. the way i have it now it works fine, but i'm not sure if that's the proper 'haskell' way
18:00:25 <Nereid> looks fine
18:00:42 <Nereid> you don't need parentheses around the last (f m)
18:02:11 <CYaNOS> someone go write an OS in haskell. it needs to be done
18:02:38 <nyc> IIRC it's been done.
18:03:38 <newbix> Neried: what would be the type signature? I tried something like this sigma :: (((a -> b) -> a) -> a) -> a but that didn't work
18:04:17 <shachaf> ((a -> b) -> a -> a is a good signture.
18:04:20 <shachaf> (But not for sigma.)
18:04:34 <shachaf> Anyway, why are you asking us? Ask ghci
18:04:49 <Nereid> and if you consider ghci to be cheating, ask yourself what should the types of f, m, and n be?
18:04:57 <Nereid> and the result type
18:05:31 <newbix> i'm not sure how to ask ghc, not familiar yet. :(
18:05:53 <newbix> Nereid: well f is a function m and n are integers
18:06:07 <Nereid> but what's the type of f?
18:06:15 <Nereid> and you can ask ghci using :type (or :t)
18:06:38 <shachaf> @google how do i ask ghci for a type
18:06:40 <lambdabot> http://www.haskell.org/haskellwiki/Learn_Haskell_in_10_minutes
18:06:40 <lambdabot> Title: Learn Haskell in 10 minutes - HaskellWiki
18:07:09 <newbix> oh and i'm just using ghc to compile: ghc -o file file.hs
18:07:35 <Nereid> sure. but ghci is quite useful
18:07:44 <Nereid> :load file.hs, and then you can play with it
18:10:30 <newbix> Nereid: oh ok i see, sigma :: (Num a1, Num a, Ord a) => (a -> a1) -> a -> a -> a1
18:11:08 <Nereid> which you can specialize if you want
18:11:20 <Nereid> (replace a and a1 with Int, say)
18:12:03 <davesque_> read the haskell.org exception wiki...i think it cleared up my confusion
18:12:12 <davesque_> somewhat
18:25:55 <Nereid> @pl \x -> f x . h
18:25:55 <lambdabot> (. h) . f
18:26:03 <Nereid> @pl \x -> h . g x
18:26:03 <lambdabot> (h .) . g
18:59:57 <cieplak> Have any of you used Database Supported Haskell (DSH)?
19:02:48 <Ololo> @pl \ x y -> x <$ kw y
19:02:48 <lambdabot> (. kw) . (<$)
19:22:26 <newbix> how can i create a function with 3 variables, 2 of them are for ints, and a third is for an operator (+, *, -). Only way that i can think of is using if to check which operator was used.
19:24:31 <newbix> nevermind i got it :)
19:25:53 <S11001001> newbix: if your function isn't id it could be simpler :)
19:26:30 <S11001001> > id (+) 39 3
19:26:32 <lambdabot>   42
19:26:48 <shachaf> > (flip . flip id) 39 3 (+)
19:26:50 <lambdabot>   42
19:27:56 <S11001001> @djinn int -> int -> (int -> int -> int2) -> int2
19:27:56 <lambdabot> f a b c = c b a
19:28:44 <S11001001> not quite but pretty close and unfair
19:30:31 <S11001001> @ty Data.Distributive.distribute
19:30:33 <lambdabot> (Functor f, Data.Distributive.Distributive g) => f (g a) -> g (f a)
19:36:32 <S11001001> @ty Data.Distributive.distribute :: (a -> b -> c) -> b -> a -> c
19:36:33 <lambdabot> (a -> b -> c) -> b -> a -> c
19:36:54 <S11001001> let's make flip an alias for distribute, it'll be fun
19:37:13 <S11001001> more pointless tricks
19:42:15 <slack1256> MonadPlus and Alternative are the same idea for Monads and Applicative functors
19:42:27 <slack1256> or is possible to have semantic differences between instances?
19:48:02 <Ololo> @pl \a (b, c) -> Test a b c
19:48:02 <lambdabot> (`ap` snd) . (. fst) . Test
19:48:14 <Ololo> oh shi
19:49:00 <Ololo> @pl \a (b, c) -> uncurry (Test a) (b, c)
19:49:01 <lambdabot> (`ap` snd) . (. fst) . (. (,)) . (.) . uncurry . Test
19:49:05 <Ololo> OH SHI
19:52:09 <Ololo> it was just uncurry . Test
19:52:13 <Ololo> WHY
20:03:04 <gwern> @quote
20:03:04 <lambdabot> typoclass says: ... <lpsmith> You can't spell "fragile" without "agile".  :-P   <typoclass> you can't spell "dynamic language" without "oh god i've got to implement half a typechecker again in the
20:03:04 <lambdabot> form of repetitive unit tests, or else it will never run right"
20:06:50 <hpaste> nwf pasted “No non-star kinds for me?” at http://hpaste.org/78885
20:07:11 <nwf> Can somebody explain (slowly, please) why that paste doesn't work?  Is it because (->) is * -> * -> * even with PolyKinds?
20:08:02 <shachaf> Good evening, kernel.
20:08:09 <shachaf> nwf: That paste loads fine for me.
20:08:30 <rwbarton> shouldn't it not?
20:08:40 <rwbarton> what does :k HRList say?
20:08:58 <shachaf> HRList :: (* -> *) -> [*] -> *
20:09:06 <rwbarton> well
20:09:20 <shachaf> Oh, and with some extensions it says HRList :: (k -> *) -> [k] -> *
20:09:52 <shachaf> So that's still not k -> k'
20:09:54 <rwbarton> so i guess your ghc is happy to specialize the type signature
20:10:02 <rwbarton> right, because r a is used as the type of a value
20:10:06 <rwbarton> k' = *
20:10:10 <shachaf> Right, it has to be *
20:10:17 <shachaf> But at any rate I'm getting a different message from nwf
20:10:21 <shachaf> 's
20:11:02 <shachaf> My .ghci turns on 36 extensions so who knows which one does it.
20:11:27 <shachaf> Oh, and this is 7.6. I get a parse error in 7.4
20:11:36 <Nereid> in any case, it's going to have to be r :: k -> *
20:11:43 <shachaf> Right.
20:11:46 <cieplak> I'm having dependency issues installing a library using cabal, so I decided to install cabal-dev, but it also had depency issues installing.  What kind of dependency management do you guys use?
20:12:05 <Nereid> I don't understand why one puts type variables in a GADT declaration. before "where".
20:12:19 <Nereid> instead just writing HRList (k -> *) -> [k] -> *
20:12:26 <Nereid> instead of*
20:12:39 <Nereid> er, with a ::
20:13:08 <Nereid> after all, one doesn't put variable names in type signatures.
20:13:27 <shachaf> Oh, it's just PolyKinds.
20:13:47 <shachaf> The real kind is (k -> *) -> [k] -> *, but without PolyKinds turned on in ghci it just shows it with k = *
20:15:03 <nwf> Speaking of, as an aside, is there a reason I have to :set -XPolyKinds even if the Main module has {-# LANGUAGE PolyKinds #-} specified?
20:15:08 <parcs`> Nereid: perhaps one should be able to put variable names in type signatures
20:15:23 <Nereid> nwf: ghci doesn't seem to respect -X options
20:15:26 <shachaf> nwf: I assume it's related to the reason you can import a module that uses an extension without using that extension yourself.
20:15:47 <Nereid> oh wait it does.
20:16:00 <Nereid> why did I think it didn't.
20:16:07 <nwf> shachaf: I thought I remembered (perhaps mistakenly!) that ghci loaded pragmas from the Main module.
20:16:18 <Nereid> ghci loads whatever you tell it to load.
20:16:30 <Nereid> it won't adopt the same extensions as the ones used in what you loaded, though
20:16:41 <startling> what module hierarchy should I put an ExtX implementation in? System.FileSystem.Ext?
20:16:53 <Nereid> extensions are per-module. as far as I can tell.
20:17:40 <nwf> I am used to thinking (again, perhaps erroneously) of *Main> as being in the same context as lines in the file itself.
20:17:55 <nwf> Since, for example, export restrictions are ignored when modules are *.
20:18:16 <Nereid> when you are in ghci, you are not "in" the Main module
20:18:28 <Nereid> it's more like you have Main imported.
20:18:34 <nwf> Sure; apparently I developed an incorrect folk-theorem.
20:20:42 <mmcdermo> cieplak: You may have to uninstall everything and cabal-dev from there.
20:20:44 <shachaf> Well, it's halfway.
20:20:58 <shachaf> You still have access to thinkgs that are unexported in Main.
20:21:16 <Nereid> sure.
20:21:32 <mmcdermo> cieplak: Consider https://gist.github.com/1185421
20:22:12 <cieplak> @mmcdermo: Thank you.  You almost beat me to it.  I cd'd to .cabal and hit rm -rf * and then installed it
20:22:12 <lambdabot> Unknown command, try @list
20:23:41 <cieplak> has anyone here used Database Supported Haskell?
20:23:55 <cieplak> it seems pretty impressive
20:24:12 <cieplak> and as though it might be a great platform for building an application like SAS
20:24:29 <cieplak> because it would enable haskell to work with data sets larger than memory
20:25:02 <cieplak> I was messing with it earlier and it doesn't seem to support floating point numbers yet
20:26:17 <startling> speaking of which, how do I write a thing that seeks around a (poentially-huge) file and extracts data from it? Should I use Binary instances and lazy bytestrings, or will shuffling things to and from a data structure have a lot of overhead?
20:27:22 <cieplak> startling: you would be constrained by the size of the haskell heap, but if your file were larger, you would have to process it in chunks
20:27:22 <Nereid> cieplak: I'd keep some things under .cabal, like config, world, and bin/
20:27:33 <crdueck> if zipWithM uses a function f :: a -> b -> Maybe c, and f produces one Nothing result, the entire result of zipWithM will be Nothing right?
20:27:48 <Nereid> @src zipWithM
20:27:48 <lambdabot> zipWithM f xs ys = sequence (zipWith f xs ys)
20:27:58 <Nereid> yep
20:28:22 <mmcdermo> cieplak: Glad you found something that worked. You may have to contact the dev to get the current status of DSH.
20:28:22 <startling> cieplak: right, yeah, I plan on only accessing a chunk of the file at a time
20:28:24 <statusfailed> can I get Aeson to parse numbers in fixed point?
20:28:48 <startling> I don't think any of my data structures will require more than a 1024-bit chunk at a time.
20:28:50 <statusfailed> or: how do I get the 'raw string' of a number instead of parsed to an attoparsec Number
20:29:15 <startling> statusfailed: do you know that JSON doesn't support that?
20:29:36 <statusfailed> startling: nope! numbers are ints or doubles?
20:29:38 <statusfailed> did not know
20:29:48 <startling> statusfailed: numbers are all doubles in JSON. :/
20:29:53 <Nereid> aeson won't do it.
20:30:02 <statusfailed> well it's my fault haha
20:30:06 <statusfailed> cheers guys
20:30:08 <statusfailed> that makes my life easier
20:30:16 <statusfailed> not that I approve of everything being a double *cough*
20:30:24 <startling> statusfailed: I mean, do it if you want, but know that you're outside the JSON standard.
20:30:52 <statusfailed> startling: Nah, it's being generated elsewhere so i'm assuming it conforms to the standard
20:30:57 <startling> ah
20:31:25 <cieplak> startling: getContents reads a file lazily and I don't think it would overrun your ram
20:31:45 <startling> cieplak: I'm going to need to seek back to the beginning occasionally, though
20:31:59 <startling> that is, I need random access without storing the whole thing in memory
20:32:24 <cieplak> startling: maybe you need to index the file somehow
20:32:30 <cieplak> what sort of file is it?
20:32:41 <startling> cieplak: an ext2 image. :P
20:33:41 <cieplak> ha
20:35:35 <cieplak> startling: I am a noob at haskell.  I haven't even gotten to monads in Learn you a Haskell.  I'm on applicative functors.  But I sort of crept ahead to this chapter on zippers: http://learnyouahaskell.com/zippers#taking-a-walk
20:36:24 <cieplak> maybe you could use a zipper to index your filesystem
20:36:49 <statusfailed> Whee http://okmij.org/ftp/continuations/zipper.html#zipper-fs
20:36:53 <startling> cieplak, I don't think zippers will really help in this case -- once an element got evaluated, it would stay in memory.
20:37:28 <startling> though maybe I could have a list of data Offset = Offset Int (Maybe ByteString) or something?
20:39:44 <cieplak> startling: how are you interfacing with the ext2 image?
20:40:03 <startling> cieplak: I'm not yet.
20:40:22 <cieplak> as in, are you building an OS in haskell? or perhaps just trying to access a certain location and then go back to the index?
20:41:47 <cieplak> my understanding of ext2 is that there is an index for the first part of the image, containing a bunch on inodes pointing to the various blocks
20:42:29 <cicku> quit
20:42:32 <cieplak> if my understanding is correct then maybe you should store the index in some datastructure in memory so you never have to jump back to the beginning of the file
20:42:56 <rwbarton> I would probably just mmap the disk image
20:43:36 <statusfailed> startling: I agree with rwbarton: http://hackage.haskell.org/package/mmap-0.5.8
20:44:06 <startling> statusfailed, rwbarton: oh, interesting
20:44:10 <startling> that's a possibility
20:44:12 <cieplak> upvote
20:44:14 * hackagebot sym 0.2.3 - Permutations, patterns, and statistics  http://hackage.haskell.org/package/sym-0.2.3 (AndersClaesson)
20:44:28 <rwbarton> there's also bytestring-mmap which I've used in the past
20:44:46 <rwbarton> are you planning to write to the image?
20:44:48 <rwbarton> or just read
20:45:17 <startling> I'd like to write eventually
20:45:34 <startling> mostly I want to be able to generate them programmatically, though, so writing isn't much of priority.
20:46:08 <rwbarton> well bytestring-mmap mmaps a file and wraps it up in a ByteString and hands that to you
20:46:12 <rwbarton> it's very simple
20:47:28 <startling> rwbarton: very cool
20:47:44 <rwbarton> not very sensible if you want to write to the mmap though
20:47:46 <startling> rwbarton: and it automagically throws stuff out when necessary and then grabs it again when necessary?
20:47:55 <rwbarton> well the OS should do that
20:48:28 <startling> mhm
20:49:32 <rwbarton> so the file will reside in the disk cache to the extent that the OS thinks that's a good idea
20:49:43 <startling> rwbarton: right, right
20:50:45 <startling> another question: should I store the reserved and padding bytes in my data structure, or should I just leave them in the source? I like the idea of being able to test by serializing then deserializing, and to be able to be sure that I won't lose any information by deserializing, but I'm not sure how necessary those are.
20:56:02 <startling> rwbarton: that's a strict bytestring, yeah?
20:56:08 <rwbarton> yes
20:56:16 <rwbarton> there is a lazy byestring version too, but i don't see the point of it
20:56:22 <startling> understood.
20:56:38 <rwbarton> or at least i couldn't figure out when i would ever want it
20:57:22 <startling> rwbarton: if you have a Binary instance but not a Serial one? heh
20:58:23 <startling> er, Serialize.
20:59:14 * hackagebot base64-conduit 0.5.1 - Base64-encode and decode streams of bytes.  http://hackage.haskell.org/package/base64-conduit-0.5.1 (MichaelSnoyman)
21:07:55 <danny> Hey!
21:09:21 <jozefg> Does anyone have any suggestions for books on language design and functional programming theory in general?
21:14:20 <nyc> Foundations for Programming Languages by Mitchell, probably various of the ones by Pierce.
21:21:12 <startling> :t span
21:21:13 <lambdabot> (a -> Bool) -> [a] -> ([a], [a])
21:21:24 <startling> > span (== 1) [1, 1, 2, 1]
21:21:25 <lambdabot>   ([1,1],[2,1])
21:21:29 <startling> ah, cool
21:23:32 <ninegrid> i'm trying to newtype an integral, what is the suggested way of going about this?  should i use -XGeneralizedNewtypeDeriving or newtype explicitly?
21:23:45 <startling> ninegrid, you don't newtype an Integral.
21:23:49 <startling> Integral is a class.
21:24:11 <ninegrid> Ok, that would explain why doing newtype threw an error about needing an extra argument
21:24:13 <mgccl> are there newer tutorial for the new parsec? I don't even see run in parsec 3.
21:24:36 <startling> how do I decode a bytestring as latin1 into a String ?
21:24:48 <ninegrid> startling: say i want to newtype an integer, but i want to do integer division, how do i go about that?
21:25:48 <startling> ninegrid, oh, you can use GeneralizedNewtypeDeriving and derive (Enum, Num, Integral, Real)
21:28:16 <Nereid> Integer, Real?
21:28:20 <ninegrid> startling: thanks, i just tried that and it complains about an instance of Fractional MyNewType arising from use of `/'
21:28:28 <Nereid> oh yeah ok
21:28:33 * Nereid was thinking of RealFrac
21:29:08 <Nereid> Real looks like a sad class
21:29:08 <startling> ninegrid: you want "div", not "/"
21:29:16 * hackagebot lens 3.7 - Lenses, Folds and Traversals  http://hackage.haskell.org/package/lens-3.7 (EdwardKmett)
21:29:24 <startling> ninegrid: "div" is integer division defined for all Integrals.
21:29:30 <startling> ^^ \o/
21:29:59 <ninegrid> sweet
21:30:46 <ninegrid> now, using the GeneralizedNewtypeDeriving i feel like i've done too much work with other newtypes in which i do not need div by implementing instances of num for those newtypes
21:32:07 <antalsz> What's a good way to generate XML from Haskell?  (Is there something like blaze-HTML?)  I'm trying to write out data to an XML file format, but I don't want to manage all the angle brackets by hand…
21:35:25 <Cale> antalsz: I'd probably just go with http://hackage.haskell.org/package/xml-1.3.12
21:35:39 <Cale> Or perhaps hexpat-pickle
21:35:55 <Cale> http://hackage.haskell.org/package/hexpat-pickle
21:36:27 <Cale> There are fancy things like HXT, but those require some dedication to use.
21:36:50 <wodesuck> quit
21:37:13 <mm_freak> there is also xmlhtml
21:37:14 <antalsz> Cale: Thanks, I'll check those out
21:37:40 <antalsz> Although I don't need much, xml seems even a little too light (although it looks a nice base, and I could always write wrapper combinators myself)
21:39:07 <antalsz> mm_freak: Could be promising, thanks.
21:40:56 <antalsz> And I also found http://hackage.haskell.org/package/xmlgen just now (funny how asking questions makes libraries show up)
21:41:03 <edwardk> Cale: The new lens is awesome. All the cool kids are using it. You should too ;)
21:41:32 <edwardk> now with fewer naming conflicts
21:41:38 <edwardk> and Prism!
21:42:05 <startling> we should just have a @cabal-install command
21:42:23 <Marcel2> d
21:43:20 <shachaf> Cale: Be a cool kid, Cale.
21:48:48 <Nereid> edwardk: what's the rationale for the name Prism?
21:49:26 <edwardk> prisms split out light.  here we're looking at something that separates out a case
21:49:39 <edwardk> and BeamSplitter was too long ;)
21:49:48 <edwardk> and Splitter too overloaded and often taken
21:49:54 <Nereid> cute
21:50:15 <edwardk> it was Projection in 3.6 but that was wrong because fst, and snd are projections, this is for things like Left and Right
21:50:23 <Nereid> indeed
21:50:24 <edwardk> which would be injections or embeddings
21:50:42 <edwardk> so we kicked around a bunch of names for them, and prism won
21:51:18 <pharaun> cute :)
21:51:23 <pharaun> what's prism for
21:52:19 <Nereid> edwardk: but what it is is a colens, right?
21:55:06 <Nereid> neat.
21:55:30 <edwardk> Nereid: yep
21:56:10 <Nereid> I have a super busy week ahead of me but later I'll try to understand it.
22:04:27 <edwardk> Nereid: its actually pretty simple. consider the Prism for _just
22:04:33 <edwardk> it needs two functions
22:04:54 <Nereid> I'm sure it's simple, but I'd still want to play with it.
22:04:55 <edwardk> (b -> Maybe b, Maybe a -> Either (Maybe b) a)
22:04:57 <Nereid> :p
22:05:05 <Nereid> but you always have something good to say so go on.
22:05:15 <edwardk> the first one is obviously Just
22:05:35 <Nereid> and the second is Nothing -> Left Nothing, Just a -> Right a
22:05:45 <edwardk> yep
22:05:55 <Nereid> yeah, I remember this.
22:06:08 <edwardk> _right = prism Right (left Left)
22:06:16 <edwardk> is a little trickier because of the two Either's
22:06:39 <Nereid> sure, just don't lose track of things.
22:06:44 <edwardk> _right :: Prism (Either c a) (Either c b) a b
22:06:45 <Nereid> :t left
22:06:46 <lambdabot>     Ambiguous occurrence `left'
22:06:46 <lambdabot>     It could refer to either `Control.Arrow.left',
22:06:46 <lambdabot>                              imported from `Control.Arrow' at State/L.hs:5:1-20
22:06:51 <Nereid> :t Control.Arrow.left
22:06:53 <lambdabot> ArrowChoice a => a b c -> a (Either b d) (Either c d)
22:07:05 <Nereid> mhm
22:07:42 <edwardk> (b -> t, s -> Either t a)      so (b -> Either c b, Either c a -> Either (Either c b) a)
22:07:48 <Nereid> yeah
22:08:26 <Nereid> I'm impressed with how this still fits in the k (a -> f b) (s -> f t) pattern.
22:08:50 <edwardk> magic ;)
22:08:53 <Nereid> :p
22:09:08 <edwardk> it took us 2 weeks to figure out the right way to package it, seriously
22:09:16 <Nereid> good job :p
22:09:33 <Nereid> what's all this APrism and AIso stuff I see?
22:09:58 <edwardk> when we consume a lens or prism or traversal or getter we usually take some monomorphic version of it
22:10:03 <edwardk> :t (^.)
22:10:04 <lambdabot> s -> Getting a s t a b -> a
22:10:16 <edwardk> (^.) :: s -> Getter s a -> a  -- WOULD work
22:10:20 <edwardk> but it'd also be harder to use
22:10:33 <edwardk> because it'd require a rank 2 type on user code, and require you to put more annotations, etc.
22:10:36 <edwardk> so we concretize it
22:10:56 <edwardk> type APrism s t a b = Overloaded Prismoid Mutator s t a b -- sounds like an alien invader
22:11:12 <Nereid> lol
22:11:24 <edwardk> but it is just Prismoid (a -> Mutator b) (s -> Mutator t)
22:11:42 <Nereid> I don't want to be stabbed by an alien invader. :(
22:11:45 <edwardk> where 'Prismoid' has two constructors. one to force it into the mold of a Category
22:11:54 <edwardk> and one to let you get the two functions i named above out
22:12:29 <edwardk> Prism :: (b -> t) -> (s -> Either t a) -> Prismoid (a -> f b) (s -> f t) -- in practice there are some type families in there to aid inference
22:12:55 <edwardk> instance Prismatic Prismoid where prism = Prism
22:13:03 <edwardk> sounds colorful anyways
22:13:31 <Nereid> now make a more powerful one and call it a DiffractionGrating.
22:13:35 <edwardk> the tricky part was figuring out how to get it not to crap out in current GHC in the presence of the lack of type refinement
22:13:48 <edwardk> Grism ;)
22:14:03 <edwardk> GravitationalLens was also suggested
22:14:03 <Nereid> hm
22:16:13 <edwardk> anyways the nice thing is when we get done with Prism, the clear duality with lens makes Iso seem less arbitrary
22:16:20 <edwardk> since an Iso is just a Lens that is also a Prism
22:16:26 <Nereid> mhm
22:16:34 <edwardk> like how Lens was a Traversal that was also a Getter (function)
22:19:02 <Nereid> good job finding another optical term though :p
22:19:21 <edwardk> i was pretty pleased that we derived Prism by two completely different reasoning paths. rwbarton by dualizing lens and me by wanting a traversal you could turn around as an 'embedding/projection' pair
22:19:32 <Nereid> mhm
22:19:45 <edwardk> when we cleaned up the traversal you can turn around to make the types cleaner we had the same type as reid.
22:19:54 <edwardk> and the same laws =)
22:20:46 <edwardk> that feels a lot like how we get the laws for lens 2-3 different ways
22:21:48 <edwardk> (b -> t, s -> Either t a) also explains why trying to do 'state monad algebras' to dualize lens was going nowhere ;)
22:22:14 <sopvop> edwardk: So, you managed to make "Either" projection! You are my hero!
22:22:49 <edwardk> sopvop: it also gave us a ton of combinators for using them like 'first class patterns'
22:23:27 <Nereid> this is quite a long changelog.
22:24:15 <edwardk> Nereid: =)
22:24:17 * hackagebot plot 0.1.7 - A plotting library, exportable as eps/pdf/svg/png or renderable with gtk  http://hackage.haskell.org/package/plot-0.1.7 (VivianMcPhail)
22:24:19 <sopvop> So, now it's possible to make 'printer-parser' leses, say for http query params, without using Category. Right?
22:24:19 * hackagebot iproute 1.2.8 - IP Routing Table  http://hackage.haskell.org/package/iproute-1.2.8 (KazuYamamoto)
22:24:23 <edwardk> we let it sit for 2 weeks
22:24:29 <sopvop> It's pretty much bidirectional everything
22:24:51 <edwardk> sopvop: to compose prisms you need Control.Category..
22:24:59 <edwardk> you can compose them with (.) from the Prelude
22:25:00 <Nereid> that couldn't be done already with Iso?
22:25:02 <edwardk> but you only get a traversal
22:25:16 <edwardk> just like with Iso
22:25:24 <sopvop> Nereid: Iso is for totals
22:25:28 <edwardk> Iso dumbs down to a Lens when composed with (Prelude..)
22:25:40 <edwardk> Prism dumbs down to a Traversal when composed with (Prelude..)
22:26:35 <sopvop> can lens be lifted to dumb prism?
22:26:52 <Nereid> don't think so
22:26:59 <edwardk> a prism needs the injection in the opposite direction
22:27:05 <edwardk> i need b -> t
22:27:10 <edwardk> independent of the 's'
22:27:27 <edwardk> s -> (a, b -> t)  vs. (b -> t, s -> Either t a)
22:27:36 <edwardk> i need an 's' to do anything with the former
22:27:47 <edwardk> i can start with a 'b' or an 's' in the other
22:28:29 <edwardk> we can go the other way, sort of
22:28:33 <edwardk> outside :: Prism s t a b -> Lens (t -> r) (s -> r) (b -> r) (a -> r)
22:29:10 <edwardk> that one is fun to reason about ;)
22:29:30 <edwardk> inside :: Lens s t a b -> Lens (e -> s) (e -> t) (e -> a) (e -> b)
22:29:36 <edwardk> so is that one
22:29:39 <Nereid> is there one like that that goes from Lens to Prism?
22:29:49 <edwardk> nope the dual notion is that 'inside' one
22:29:53 <edwardk> it goes lens to lens
22:30:23 <edwardk> its one of those things where only one direction is 'twisted' if that makes any sense
22:30:28 <Nereid> makes sense in a vague sort of way.
22:31:41 <edwardk> its kind of like how (->) r is self-adjoint, so when you compose it one way you get Cont, and when you compose it the other way you get the dual of Cont in Hask^op, which gives you Cont when you look at it in Hask ;)
22:32:03 * sopvop head explodes
22:32:27 <shachaf> Is that just necause of Hadkell and intuitionism and so on or is it something more fundamental?
22:33:33 <edwardk> shachaf: well, you get lots of things in hask due to the fact that we have arbitrary exponentials and not co-exponentials, but if we 'fixed' that then you could show that the category would collapse under the weight of all those laws to a poset, which would make it boring again.
22:33:40 <sopvop> edwardk: It would be awesome if you gave example of adding metadata to lens. Like you described here http://www.reddit.com/r/haskell/comments/13xi63/datadriven_hacks_for_db_querying_is_this_evil/c7850ht
22:33:43 <sopvop> if you have time
22:33:56 <Nereid> now I'm wondering if all that is a special case of some
22:34:04 <edwardk> sopvop: i've been exploring writing a library for database access that works that way
22:34:09 <Nereid> Prism s t a b -> Lens s' t' a' b' -> Lens (? -> ?) (? -> ?) (? -> ?) (? -> ?)
22:34:40 <edwardk> Nereid: work it out. i don't know the answer =)
22:34:51 <Nereid> I will, but later!
22:35:19 <Nereid> (actually my silly justification wasn't quite right.)
22:35:35 <edwardk> inside ?l . outside ?r
22:35:35 <edwardk>   :: (Functor f,
22:35:37 <edwardk>       ?l::LensLike (Context b b) s t b b,
22:35:37 <edwardk>       ?r::APrism e e a b1) =>
22:35:39 <edwardk>      ((b1 -> b) -> f (a -> b)) -> (e -> s) -> f (e -> t)
22:35:40 <edwardk> is what i get when i smash them together
22:35:56 <edwardk> dunno at first why the b's had to match or the 'e's
22:36:11 <edwardk> outside ?l . inside ?r
22:36:11 <edwardk>   :: (Functor f,
22:36:13 <edwardk>       ?l::APrism s t a a,
22:36:13 <edwardk>       ?r::LensLike (Context a1 b) r r a1 b) =>
22:36:15 <edwardk>      ((a -> a1) -> f (a -> b)) -> (t -> r) -> f (s -> r)
22:36:15 <edwardk> that looks better
22:36:20 <edwardk> er sorry that was spammy
22:36:26 <Nereid> :p
22:36:39 <edwardk> oh no, still two matched a's and two matched r's
22:36:45 <Nereid> maybe it has to be.
22:36:46 <edwardk> thats all i've got
22:37:17 <edwardk> you might be able to do better by interlacing the reasoning
22:37:19 <sopvop> bot are afraid of  kicking edwardk for spamming.
22:38:19 <Nereid> no, I think for the thing I wanted to make sense, we'd need some way of tensoring two lenses together. or something
22:38:25 <Nereid> which should be easy, right.
22:38:35 <edwardk> :t alongside
22:38:36 <lambdabot> Functor f => LensLike (Context a b) s t a b -> LensLike (Context a' b') s' t' a' b' -> ((a, a') -> f (b, b')) -> (s, s') -> f (t, t')
22:38:40 <Nereid> something along  the lines of that yes
22:39:03 <Nereid> oh well, I'll think about it later when I have more time.
22:39:36 <edwardk> alongside also has a dual for prisms involving Either instead of (,)'s
22:39:41 <edwardk> 'without' iirc
22:39:41 <Nereid> I bet.
22:39:50 <Nereid> anyway, and then maybe see if these have useful generalizations to other categories.
22:40:04 <edwardk> well, now you have lenses in hask and hask^op to play with ;)
22:40:08 <Nereid> :p
22:40:15 <edwardk> heya glguy
22:50:59 <hpaste> sopvop pasted “Am I doing lens right, how should it compose?” at http://hpaste.org/78889
22:51:37 <edwardk> what is 'naming'?
22:51:47 <sopvop> I don't know, it's your code :)
22:51:53 <edwardk> oh for the thing i sketched
22:51:56 <sopvop> I only added Foo :)
22:52:10 <edwardk> look at the code for Isomorphic and Isoid in lens 3.7
22:52:23 <edwardk> the way Isoid is implemented is almost exactly what you'd need
22:52:37 <sopvop> Thanks
22:54:14 <edwardk> sopvop: you want class Category k => Naming k where
22:54:24 <edwardk> and data Named a b = Named [String] (a -> b)
22:54:31 <edwardk> that way you can use id = Named [] id
22:54:43 <edwardk> so you can see the chain of names used
22:55:06 <edwardk> composing the [String] with ++ using [] as its unit preserves the category laws
22:56:57 <edwardk> foo = naming "foo" $ \f v -> f (_foo v) <&> \a' -> v { _foo = a' }
22:57:20 <edwardk> then foo._1 does compose. yielding a lens.
23:01:16 <sopvop> Looks like my old 3.3 lens don't have a <&> :)
23:02:15 <Nereid> :t (<&>)
23:02:17 <lambdabot> Functor f => f a -> (a -> b) -> f b
23:02:48 <td123> :t fmap
23:02:49 <lambdabot> Functor f => (a -> b) -> f a -> f b
23:04:17 <edwardk> sopvop: now is a great time to upgrade to 3.7 ;)
23:05:37 <sopvop> I'm waiting for snap upgrading first
23:09:50 <edwardk> sopvop: then you're waiting for https://github.com/dreixel/generic-deriving/pull/5
23:10:07 <edwardk> once that goes through lens 3.7 retroactively works on ghc 7.0.4, and the new snap can ship
23:11:10 <Nereid> so snap is switching over to lens? good to hear :)
23:11:38 <edwardk> yeah they are just waiting on 3.7, since i had to patch in a ton of support for old GHC for them
23:12:09 <edwardk> 3.7 shipped, but part of the 7.0.4 support requires generic-deriving to build on 7.0.4 -- it would do so but for want of a single LANGUAGE pragma its currently missing
23:14:19 <Nereid> I've been wanting to try out snap but the data-lens stuff was kind of dismotivating. if that's a word.
23:14:32 <sopvop> hm, I cant figure out how type of namOf (Named n _) = n, keeps complaining about ambiguous Functor f in foo lens
23:14:55 <edwardk> sopvop: you need to pick a 'functor 'f' for that function
23:14:55 <sopvop> what typ nameOf should be
23:15:00 <Nereid> demotivating?
23:15:13 <edwardk> nameOf :: Named (a -> Mutator b) (s -> Mutator t) -> String
23:15:15 <edwardk> for instance
23:15:25 <edwardk> if you don't pick 'f' ghc won't default it for you
23:15:44 <sopvop> will Const be enough?
23:15:48 <edwardk> sure
23:15:57 <edwardk> Const, Mutator, Identity, [], anything
23:17:06 <sopvop> It god damn works
23:18:14 <edwardk> of course it does
23:18:16 <edwardk> i invented it ;)
23:18:57 <edwardk> 'nameOf' needed to pick a functor because 'Naming' demanded you pick one.
23:19:25 <edwardk> anyways with a little bit of TH magic you could derive that
23:19:45 <edwardk> and with something like 'upon' you could magically construct one from an accessor in a pinch
23:19:46 <sopvop> That was the plan :)
23:20:45 <sopvop> edwardk, you should fear zombies more. you have bra-a-a-ains! braa-a-a-ains!
23:21:12 <edwardk> :0
23:22:13 <Nereid> hmm, I have some old code from whatever random crap I've built sitting around doing no good, maybe I should throw it on github
23:23:56 <edwardk> putting your code online is insanely good for you from a job seeking perspective.
23:24:06 <hpaste> sopvop annotated “Am I doing lens right, how should it compose?” with “If anyone is interested” at http://hpaste.org/78889#a78890
23:26:46 <Fuuzetsu> :t lens
23:26:48 <lambdabot> Functor f => (s -> a) -> (s -> b -> t) -> (a -> f b) -> s -> f t
23:27:22 <Nereid> (s -> a) -> (s -> b -> t) -> Lens s t a b
23:27:44 <Fuuzetsu> heh http://stackoverflow.com/questions/13756188/composition-of-partial-lenses
23:27:53 <edwardk> i am sad that i put `lens` in `lens`. it tends to lead to people doing the wrong thing
23:27:57 <Fuuzetsu> strong amount of rep edwardk
23:27:58 <shachaf> We should deprecate the name "lens", given that it's a function you're not really supposed to use.
23:28:01 <Nereid> Fuuzetsu: heh
23:28:11 <Nereid> shachaf: why not?
23:28:22 <shachaf> Nereid: Because you don't get sharing, mostly.
23:28:28 <edwardk> Nereid: it is invariably slower than writing it directly
23:28:29 <Nereid> sure, ok.
23:28:30 <shachaf> I wonder whether GHC optimizes that for simple cases.
23:28:41 <Nereid> but for throwing something together without thinking too hard about it.
23:28:52 <Nereid> even then it might still be easier to write it directly
23:28:56 <shachaf> Nereid: But defining it directly is about the same length.
23:28:57 <edwardk> _2 f (a,b) = (,) a <$> f b -- shares work between the getter and setter
23:29:01 <Nereid> yeah
23:29:04 <edwardk> Nereid: same amount of work
23:29:09 <Nereid> or less
23:29:22 <shachaf> lens f (StructPattern val ...) = setter <$> f val
23:29:24 <Nereid> who wants to write \a (c,b) -> (c,a)
23:29:34 <edwardk> _2 = lens snd $ \(x,_) y -> (x,y)
23:29:37 <shachaf> Also it locks you in to `lens`.
23:30:03 <edwardk> to generalize _2 to both, you just start working over multiple fields
23:30:20 <edwardk> both f (a,b) = (,) <$> f a <*> f b
23:30:20 <edwardk> and now its a traversal
23:31:08 <edwardk> Fuuzetsu: i mostly mine through old haskell posts that didn't get the answers they deserve
23:32:10 <shachaf> ZipList syntax ought to be generalized to Applicative.
23:32:18 <shachaf> If only [] didn't have the wrong instance. :-(
23:32:30 <edwardk> shachaf: [] has the right instance. ;)
23:32:31 <shachaf> Er, not ZipList
23:32:36 <shachaf> Zip comprehensions.
23:32:51 <shachaf> both f (a,b) = [(a',b') | a' <- f a | b' <- f b]
23:32:52 <edwardk> zip comprehensions should be generalized to use fzip or something that can be forced to align =P
23:33:10 <shachaf> edwardk: But it has the perfect scoping behavior!
23:33:11 <edwardk> shachaf: thats horrifyingly bad looking =P
23:33:23 <shachaf> OK, imagine it for a parser or something.
23:33:50 <edwardk> what does it generalize two when you turn on all the monad comprehension stuff anyways?
23:33:54 <edwardk> er generalize to
23:34:34 <shachaf> Nothing, I think.
23:34:51 <edwardk> shucks
23:34:57 <shachaf> Oh, no.
23:34:58 <shachaf> MonadZip
23:35:12 <shachaf> I didn't even know that class existed?
23:35:14 <shachaf> Weird.
23:36:46 <shachaf> edwardk: By the way, it looks like GHC inlines lens to the right thing for small test cases like _1
23:36:59 <shachaf> Hmm, or maybe not.
23:37:00 <edwardk> shachaf: that much is heartening
23:37:07 <edwardk> or maybe not ;)
23:37:18 <shachaf> No, it looks OK.
23:38:01 <shachaf> Yep, set, view, and over behave the same.
23:38:22 <shachaf> (I realized that I'd forgotten to test over, which is actually the only case you really care about here.)
23:38:59 <edwardk> wonder how well it deals with compositions in those situations
23:41:22 <shachaf> Uh oh, mzero wants cryptography in haskell-platform.
23:42:43 * sopvop should make SO account to upvote edwardk
23:42:44 <shachaf> There ought to be a tool to compare Core code up to alpha-renaming.
23:42:59 <Nereid> sopvop: alas, you need some rep before you can upvote
23:43:30 <shachaf> OK, OK, I'll upvote him.
23:43:32 <sopvop> Now I'm sad
23:43:50 <shachaf> (Only because I was involved in writing the answer!)
23:44:08 <sopvop> It supports google openid, I don't need to register!
23:44:18 * hackagebot simple-sendfile 0.2.9 - Cross platform library for the sendfile system call  http://hackage.haskell.org/package/simple-sendfile-0.2.9 (KazuYamamoto)
23:44:38 <shachaf> Someone made a MonadZip instance that runs concurrently.
23:52:37 <Nereid> weird. http://stackoverflow.com/questions/4204086/is-the-monad-w-instance-anywhere-standard
23:55:47 <edwardk> Nereid: i think i proposed it on a libraries posting somewhere but i can't remember when/where
23:57:55 <rpglover64> edwardk: Help! I think I've stumbled unto para- and meta- morphisms and I don't know what I'm doing (-:
23:58:01 <Nereid> oops, I should have gone to bed already.
23:59:04 <edwardk> rpglover64: well, the good news is that most of the time they are boring.
23:59:34 <rpglover64> The other good news is that I'm pretty sure I understand paramorphisms now
