00:01:07 <ion> Naming the inner one, say, xs' makes it easy to refer to xs instead of it by mistake. That error won’t be caught by the type system and it won’t pop out when skimming the code.
00:02:04 <startling> -Wall complains about that? dang
00:02:16 <startling> what is this, coffeescript?
00:02:23 <Saizan> (shadowing is risky for refactoring though)
00:02:48 <startling> sure
00:04:04 <startling> hmmm, is there really not a way to make a differently-kinded class a superclass? I really want "class Monoid (b a) => Both b where ..."
00:04:29 <startling> I've tried class (forall a. Monoid (b a)) => Both b, but it didn't end up working.
00:04:59 <Saizan> there's the Skolem hack
00:05:07 <startling> Saizan: what's this?
00:05:51 <ion> I have forgotten what skolem means by every time someone mentions it.
00:06:19 <startling> it's a small undead dragon.
00:06:38 <Saizan> http://hackage.haskell.org/packages/archive/constraints/0.3.2/doc/html/src/Data-Constraint-Forall.html
00:06:51 <startling> similar to a thoralf but usually evil- or neutral-aligned.
00:07:21 <startling> Saizan: that's pretty ugly
00:07:41 <Saizan> it is an hack :)
00:07:54 <ion> TIL about unsafeCoerceConstraint
00:08:18 <startling> heh
00:10:08 <shachaf> ion: Well, it comes from that package.
00:12:51 <AfC> startling: heh
00:13:29 <startling> Saizan: but anyway, this is a known problem? No one's going to laugh at me for having a mappend-ish operation in my typeclass? :X
00:14:33 <shachaf> -- skolem variables, do not export!
00:14:33 <shachaf> data A
00:14:33 <shachaf> data B
00:15:08 <Saizan> startling: see Alternative and MonadPlus
00:15:53 <startling> Saizan: I haven't even got Functor. :(
00:16:02 <startling> oh, I see what you mean, heh.
00:19:20 <ion> case xs of (x:xs') hiding xs -> …
00:20:14 <Saizan> hiding++
00:23:58 <sgk284> quick q: I have two Maybe Int vars and want to True if a > b, otherwise False if a <= b or Nothing
00:24:03 <sgk284> I'm doing this via pattern matching
00:24:08 <sgk284> but feel that there is a better way
00:24:17 <sgk284> any suggestions?
00:24:30 <startling> sgk284: fromMaybe False $ (<) <$> a <*> b
00:24:46 <sgk284> so much shorter! thank you :)
00:28:31 <BMeph> :t (<*>).fmap (<) -- shorter still...
00:28:32 <lambdabot> (Ord a, Applicative f) => f a -> f a -> f Bool
00:29:30 <BMeph> Hmm, I guess that should be "(<*>) . fmap (>)"; whoops. :)
00:29:51 <ion> bmaph: It’s clear what startling’s code does, it’s not immediately clear what that does.
00:30:00 <Nereid> :t liftA2 (>)
00:30:01 <lambdabot> (Ord b, Applicative f) => f b -> f b -> f Bool
00:30:20 <startling> sgk284 wants a Bool, not an f Bool.
00:30:27 <ion> bmeph: Not to mention that… what startling said
00:30:46 <BMeph> There you go - Nereid's fragment is clear and concise; problem solved! :)
00:30:47 <Nereid> compose with fromMaybe False
00:31:12 <Nereid> :t fromMaybe False .: liftA2 (>)
00:31:14 <lambdabot> Ord b => Maybe b -> Maybe b -> Bool
00:31:19 <ion> A.k.a. startling’s original code :-P
00:31:28 <startling> 8)
00:31:31 <Nereid> indeed
00:31:35 <Nereid> except liftA2 is better
00:31:38 <sgk284> wow, impressive
00:31:46 * BMeph waves the white flag
00:31:57 <sgk284> thanks guys
00:32:04 <startling> it just depends whether a and b are already bound I guess.
00:33:32 <Nereid> I wish we could have more complex expressions as infix operators.
00:34:02 <Nereid> > a & f $ b :: Expr
00:34:03 <lambdabot>   f a b
00:34:08 <Nereid> good enough
00:34:18 <Nereid> a &f$ b
00:36:38 <ion> shiver :-P
00:37:08 <ion> > f $ a & g :: Expr
00:37:10 <lambdabot>   Ambiguous type variable `b0' in the constraints:
00:37:10 <lambdabot>    (GHC.Show.Show b0)
00:37:10 <lambdabot>     ...
00:37:24 <Nereid> heh
00:37:41 <Nereid> > f $ (a & g :: Expr) :: Expr
00:37:43 <lambdabot>   f (g a)
00:38:09 <ion> > (f :: Expr -> Expr) $ a & (g :: Expr -> Expr)
00:38:11 <lambdabot>   f (g a)
00:38:30 <Nereid> > Just 1 &liftA2 (<)$ Just 2
00:38:32 <lambdabot>   Just True
00:38:58 <ion> (| Just 1 < Just 2 |)
00:39:05 <Nereid> yeah well.
00:40:12 <Nereid> I'd rather live with liftA2 than import Control.Applicative.QQ.Idiom
00:42:27 <ion> That wouldn’t be quasiquotation, that would preferably be a language extension.
00:43:08 <Nereid> I suppose SHE does it.
00:44:48 <m3ga> i seem to remember a type family example using sparse vectors encoded as vector of (Int, Double) but which stored them as (Vector Int, Vector Double). anyone know the paper?
00:52:10 <ion> nereid: I’d prefer a language extension to QQ, and QQ to a preprocessor. Anyway, SHE gets it wrong because it doesn’t know about the fixities of operators.
00:56:00 <Jafet> vector already does that.
00:56:36 <simpson> Ugh. I have a curious problem. I'm doing FFI and wrapping a settings map which maps strings to ints, doubles, or strings, with the type varying by key.
00:57:08 <simpson> Do I need lots of Maybes?
00:57:46 <m3ga> Jafet: thanks, i'll take a look
00:58:22 <ion> data Foo = FooInteger Integer | FooDouble Double | FooString String
00:58:42 <Jafet> Everything is isomorphic to String.
00:59:04 <ion> jafet: IO?
00:59:11 <Jafet> It's a good lie.
00:59:26 <startling> ion, easy one
00:59:30 <startling> ion: (haskell code)
00:59:37 <sgk284> one more question. I have a list of Maybe's and want to return the first Just result. Right now I'm doing: (fromMaybe Nothing . find isJust)
00:59:38 <ion> startling: :-)
00:59:41 <sgk284> is that idiomatic?
00:59:59 <Jafet> :t listToMaybe . catMaybes
01:00:00 <lambdabot> [Maybe a] -> Maybe a
01:00:12 <Jafet> :t mconcat
01:00:13 <lambdabot> Monoid a => [a] -> a
01:00:32 <startling> > Just 1 <> Just 2
01:00:33 <lambdabot>   Ambiguous type variable `a0' in the constraints:
01:00:34 <lambdabot>    (GHC.Num.Num a0)
01:00:34 <lambdabot>      a...
01:00:44 <startling> > Just 'a' <> Just 'b'
01:00:45 <lambdabot>   No instance for (Data.Monoid.Monoid GHC.Types.Char)
01:00:46 <lambdabot>    arising from a use o...
01:00:50 <sgk284> Jafet: danke sehr :)
01:01:02 <startling> yeah, you need a Monoid internal type for mconcat
01:01:47 <Jafet> :t fromMaybe Nothing
01:01:48 <lambdabot> Maybe (Maybe a) -> Maybe a
01:01:56 <Jafet> :t join
01:01:57 <lambdabot> Monad m => m (m a) -> m a
01:05:44 <ion> > foldr (<|>) empty [Nothing, Just "foo", undefined]
01:05:45 <lambdabot>   Just "foo"
01:06:53 <shachaf> > preview (traverse._just) [Nothing, Just "foo", undefined]
01:06:55 <lambdabot>   Just "foo"
01:08:58 <shachaf> > msum [Nothing, Just "foo", undefined]
01:08:59 <lambdabot>   Just "foo"
01:09:45 <ion> Ah, msum/asum. I was trying to remember asum, but it wasn’t in Applicative and i didn’t remember the name.
01:10:13 <Jafet> @src msum
01:10:13 <lambdabot> msum =  foldr mplus mzero
01:10:40 <ion> and asum = foldr (<|>) empty
01:13:59 <lightquake> is reactive-banana still under active development?
01:14:18 <lightquake> no pushes to the repo in 2 months makes me a little wary, but it seems to make more sense than netwire
01:14:32 <startling> maybe it's done.
01:14:44 <startling> ( ;) )
01:18:15 <sclv> reactive-banana is very popular and well supported
01:18:38 <sclv> but yeah, my impression is that it does what it intends for the moment
01:18:40 <Gracenotes> software? done?
01:18:43 <Taneb> Is reactive-banana as close to the paper as lens is?
01:18:50 <Gracenotes> goodness
01:19:08 <sclv> haha i notice more haskell libraries are "done" than just about anywhere else
01:19:19 <lightquake> sclv: is the implementation it uses suitable for writing opengl games, or is netwire better for that?
01:19:51 <sclv> as far as i know both are suitable for that sort of thing. my recollection is that they have quite different styles
01:20:09 <sclv> so you will likely find one or the other suits you more in terms of how you want to structure your thoughts.
01:20:44 <lightquake> i think i might try reactive-banana, since i've heard that's 'simpler' to start with
01:20:55 <lightquake> and if i wind up running into some annoyance i'll look at netwire
01:20:58 <sclv> i.e. they're not shooting for the same notion of frp semantics. reactive-banana's is more classical, but netwire might be a simpler fit for game logic.
01:21:05 <sclv> yeah, sounds right
01:35:32 <lightquake> actually, hm, netwire does seem more obvious
01:35:41 <lightquake> er, more obviously fitting game design
02:05:45 <Lethalman> so it seems that a function that doesn't have an IO signature doesn't guarantee there are no side effects, right?
02:06:07 <Lethalman> for example foo = putStrLn "foo" `seq` "bar" is :: String
02:06:25 <companion_cube> it will not print "foo"
02:06:32 <Lethalman> companion_cube, it will
02:06:38 <Lethalman> at least I did it in ghci
02:06:42 <Lethalman> ah
02:06:54 <Lethalman> my bad
02:07:18 <Lethalman> companion_cube, so it evaluates putStrLn as an expression but does not execute it
02:07:23 <companion_cube> exactly
02:07:33 <Lethalman> companion_cube, and how does one execute an IO?
02:07:46 <companion_cube> you make it part of main :)
02:07:47 <`ramses> Lethalman: I would assume that such a gigantic flaw in the type system would have been documented by now ;)
02:08:01 <companion_cube> main is the only IO that is executed
02:08:22 <companion_cube> but of course main can be an arbitrarily complex expression computing an IO
02:08:27 <Lethalman> `ramses, wasn't going to look for a flaw, just to know how it works :P
02:08:46 <Lethalman> companion_cube, ah that's interesting
02:09:10 <Lethalman> companion_cube, so if I call an IO function from a non-IO function nothing happens?
02:09:37 <companion_cube> well, you can have pure functions compute IO values
02:09:47 <companion_cube> but those will remain values
02:10:02 <companion_cube> it's only if you bring them in main that they will be executed, in a sense
02:10:08 <Lethalman> ah
02:10:42 <companion_cube> :t \x -> [putStrLn $ show (x+1), putStrLn "done"]
02:10:44 <lambdabot> (Num a, Show a) => a -> [IO ()]
02:10:46 <Lethalman> is it something that haskell only can do because it's the main, or it's something an user can do outside of main? that is there some sort of function execute :: IO -> ... ?
02:10:53 <companion_cube> > (\x -> [putStrLn $ show (x+1), putStrLn "done"]) 42
02:10:54 <lambdabot>   No instance for (GHC.Show.Show (GHC.Types.IO ()))
02:10:55 <lambdabot>    arising from a use of ...
02:11:04 <companion_cube> > sequence $ (\x -> [putStrLn $ show (x+1), putStrLn "done"]) 42
02:11:05 <`ramses> Lethalman: calling an IO function from a non-IO function would imply you have to do something like what you started the discussion with, throw away the IO
02:11:05 <lambdabot>   No instance for (GHC.Show.Show (GHC.Types.IO [()]))
02:11:05 <lambdabot>    arising from a use o...
02:11:42 <companion_cube> Lethalman: you cannot (and should not) escape out of IO
02:13:41 <Lethalman> ok, convinced me
02:14:04 <Lethalman> :P
02:20:53 <neutrino> hello
02:26:07 <simpson> Well, this is curious. I have a library and a couple executables that depend on the library. I wanted to have one single package for all of it. How do I get cabal to understand that I require the library to be built prior to building the executables?
02:26:39 <neutrino> are there any CT/topology/graph theory people in here? i have a question about graphs. suppose i have a directed graph (nodes, edges) with a selected element e, and i want to create a directed graph (children(e), traverseChildren(e)) which connects all the children of e in a directed path. that is, children(e) is the set of such elements x such that e points at x directly through a single edge. traverseChildren(e) should be a
02:26:49 <neutrino> path which traverses all of them. does this concept have a name?
02:27:11 <neutrino> here, a path is a chain of edges.
02:29:56 <fmap> simpson: add library to build-depends?
02:30:27 <simpson> fmap: Only sort of helped. I've got hidden modules in the library, and when configuring the executable, it complains.
02:39:15 <fmap> simpson: you expect executable to get access to library modules that aren't exposed?
02:42:59 <simpson> fmap: I'm not sure why it wants that module; it should work when not exposed.
02:44:13 <Saizan> simpson: you should have the executables in a different source tree btw
02:44:15 <ClaudiusMaximus> could it be that executable and library are not in distinct directories so the executable can pull in the modules directly which causes ghc confused?
02:44:29 <simpson> Saizan: Nobody told me this.
02:45:22 <startling> does lens have a class for things you can do " Simple Lens s t -> f t -> f s" on ?
02:56:02 <simpson> Sweeeet, I've done a thing! Now to register for Hackage and share my stuff.
02:56:12 <simpson> ...Maybe I should sleep first.
02:57:21 * Lethalman trying to understand fmap
02:57:40 <Lethalman> so fmap for Maybe is (a -> b) -> Maybe a -> Maybe b ?
02:57:53 <simpson> Yes.
02:57:55 <merijn> Lethalman: Yes
02:58:05 <Lethalman> how can I see that type in ghci?
02:58:24 <Lethalman> like :t fmap for Maybe
02:58:53 <merijn> Lethalman: I'm not sure that's possible, although you can easily see it when you do manual subsitution
02:59:01 <merijn> :t fmap
02:59:02 <lambdabot> Functor f => (a -> b) -> f a -> f b
02:59:30 <merijn> Lethalman: Knowing that Maybe is a functor essentially means "you're allowed to drop the "Functor f =>" part and replace all fs with Maybe"
02:59:33 <Saizan> :t fmap `asTypeIn` \f -> f undefined (Just undefined)
02:59:34 <lambdabot> (a -> b) -> Maybe a -> Maybe b
02:59:35 <Lethalman> ah ok I can do fmap :: (a -> b) -> Maybe a -> Maybe b
02:59:47 <simpson> :t flip fmap (Just 42) -- it'd be sweet if there were a more obvious way to do it
02:59:48 <lambdabot> Num a => (a -> b) -> Maybe b
02:59:53 <ohYeah> what's a monad?
03:00:23 <merijn> Lethalman: When I started I did the substitution on paper by hand, but after a while you get quite handy with it and most substitutions become obvious
03:00:50 <merijn> Doing manual substitution is an educational process that's worth the effort anyway
03:01:20 <Lethalman> indeed, it was just to see if I got it right :)
03:02:00 <Lethalman> Saizan, asTypeIn not defined
03:02:24 <Saizan> yeah, it's from lambdabot
03:02:37 <Saizan> ?type asTypeIn
03:02:38 <lambdabot> a -> (a -> b) -> a
03:02:54 <Lethalman> oh :) was trying to find it in any module :P
03:03:10 <Saizan> it's just a cleverly-typed version of const
03:03:11 <ohYeah> I want to build simple websites (maybe simple webapps too) and want want a useful technical skill. My brain is telling me to just use node.js but I enjoy functional programming with my limited experience and am not sure if I should use haskell.
03:03:51 <Lethalman> for web development I'm following the opalang framework, anybody here used it?
03:04:07 <merijn> ohYeah: Haskell has quite a few decent web frameworks by now. HappStack and Snap are reasonably simple ones, I think? There's Yesod too, but it has a bunch of dark template magic which can be a bit complicated
03:04:38 <`nand`> :t over _just
03:04:39 <lambdabot> (a -> b) -> Maybe a -> Maybe b
03:04:52 <ohYeah> merijn: but I will also need to learn javascript, right?
03:05:01 <`nand`> ohYeah: not necessarily
03:05:02 <Saizan> ohYeah: if you're new to haskell you probably need to learn the basics by reading LYAH before you get to web developement
03:05:13 <`nand`> ohYeah: you can use Haskell for the client-side
03:05:14 <merijn> ohYeah: Depends on how dynamic and AJAX-y your website is supposed to be
03:05:31 <merijn> Oh, I guess we have multiple haskell-to-JS backends now, too
03:05:49 <Saizan> @where LYAH
03:05:49 <lambdabot> http://www.learnyouahaskell.com/
03:05:50 <ohYeah> Saizan: but I'm trying to figure out wether I should just use node, I'm not sure if the utility of haskell is worth it for my goals
03:05:54 <`nand`> including a few domain specific forks of Haskell specifically for web development
03:06:09 <`nand`> or languages /not/ originating from Haskell but similar in nature (pure, lazy, functional)
03:06:38 <`nand`> in the ideal case scenario, you never need to touch JavaScript
03:07:37 <neutrino> merijn: hi, do you know anything about graph theory?
03:07:41 * `nand` wonders if there are any larger websites that actually /use/ Haskell->JS scripts
03:07:43 <ohYeah> yeah guys in node were telling me about haskell on the client side (like coffee script), but isn't that another dialect to learn, I got to about chapter 4 about a month ago (maybe higher order function or monads don't remember) and am just unsure if starting to learn node is a waste of time
03:08:22 <neutrino> ohYeah: no, it's just like compiling C on msvc or gcc
03:08:27 <neutrino> not that different
03:08:33 <neutrino> library support may be different
03:08:36 <`nand`> then again, with how slow and resource-heavy popular websites are these days, it probably won't make much of an impact
03:09:11 <neutrino> luite's workbook used haskell in the browser
03:09:15 <`nand`> neutrino: I guess you usually just sacrifice IO?
03:09:27 <neutrino> i don't think you do
03:09:47 <neutrino> i guess it's just that there's no stdout or stderr
03:09:49 <ohYeah> I'm super ignorant guys bere with me. I was attracted to node when I saw Dhal so simply created a tcp chat server. How much more of a learning curve is haskell for deploying simple websites or web apps and other network IO>?
03:09:56 <`nand`> makes sense for luite to use client side haskell; gotta eat your own food after all :)
03:09:57 <neutrino> you still need to manipulate the real world, like the DOM
03:10:13 <neutrino> i wouldn't call it food
03:10:16 <neutrino> dog food maybe :P
03:10:41 <`nand`> neutrino: I was under the vague impression that you replace IO by some domain-specific JS monad that has DOM interaction and stuff as primitives
03:10:53 <neutrino> ohYeah: there are simple powerful examples for every language.
03:11:27 <`nand`> depending on how many features you want it to have, a chat server can be fairly small
03:11:29 <neutrino> ohYeah: for example, in fortran you can easily optimize functions much further than in C or Haskell. doesn't mean it's a better language in general.
03:11:44 <ohYeah> neutrino: but pertaining to network stuff and website deployment I'm looking for. I like the elegance and power of haskell, but I'm trying o asses if the extra learning curve is worth it
03:11:49 * `nand` wonders if something like cloud haskell could be leveraged for a chat program
03:12:00 <neutrino> ohYeah: and in assemnly, you can write a 3d fractal renderer in under 4 kilobytes of code.
03:12:19 <neutrino> beware of single examples that assert a language's superiority in general
03:12:43 <ohYeah> but pertaining to network stuff and website deployment I'm looking for. I like the elegance and power of haskell, but I'm trying o asses if the extra learning curve is worth it
03:12:50 <neutrino> yeah, i saw that
03:12:55 <neutrino> i wonder what i should answer
03:13:03 <neutrino> you'll get bored of doing websites one day
03:13:14 <neutrino> that day is sooner than you think
03:13:43 * hackagebot xss-sanitize 0.3.3 - sanitize untrusted HTML to prevent XSS attacks  http://hackage.haskell.org/package/xss-sanitize-0.3.3 (MichaelSnoyman)
03:13:46 * `nand` grew up doing web dev
03:13:51 <`nand`> now I won't touch it
03:13:54 <neutrino> if you just only ever want to make simple websites, maybe ones with higher than usual performance, you're probably better served with something like go or php
03:14:15 <`nand`> sill neutrino, recommending php
03:14:17 <`nand`> silly*
03:14:18 <neutrino> but nowadays websites are just frontends to much more complex systems that actually have nothing to do with the web in themselves
03:14:20 <ohYeah> yeah, I really just want to create a webserver for like some blogs lol, maybe make some other not too comlex web apps. But I like that haskell is functional and just seems powerful; like maybe it will help me solve other problems, or maybe Ithat is agda lol
03:14:37 <neutrino> well, blog is the php killer-app
03:15:01 <`nand`> if you ask me, the only reason to use php is if the software already exists, eg. mediawiki
03:15:21 <neutrino> so if you want something good for a blog, just use php. but if you want something to tinker with and widen your understanding of computer programming, haskell is a pretty good idea.
03:15:35 <neutrino> you won't be able to do much for a longer time, though
03:15:51 <`nand`> isn't stuff like ruby or python popular for web dev these days?
03:15:53 <neutrino> but once you're there it's worth it because of the various uses you suddenly have access to
03:16:02 <`nand`> I hear eg. django or whatever has a nice API
03:16:07 <neutrino> python and ruby are popular too
03:16:29 <neutrino> django has a nice api when you're doing stuff django wants you to do, otherwise it gets really bad real quick
03:16:41 <Saizan> yeah, i think newer generations can be spared from php
03:16:44 <`nand`> neutrino: oh, that's true. It took me like a year of doing Haskell before I started finding ways to use it for actual programs
03:18:05 <neutrino> Saizan: there isn't much reason to defend yourself from doing blogs in php, that's like saying newer generations can be spared from visual basic in response to "i want to automate a spreadsheet"
03:18:21 <`nand`> automate a spreadsheet? sounds like FRP!
03:18:36 <neutrino> yeah and profunctors
03:18:49 <ohYeah> so haskell can do all the website stuff and web app stuff node can do plus more? Eg. how easy is it to create a webserver in haskell? I'm thinking the learning curve is worth it
03:19:03 <Saizan> neutrino: i've had horrible experiences with php for anything more than templating
03:19:11 <`nand`> ohYeah: there are libraries for webservers in haskell
03:19:24 <`nand`> a trivial webserver would be like one line of code
03:19:52 <neutrino> ohYeah: well, node.js is a failed concept anyways. it uses a very dated paradigm, callbacks and reactors
03:19:59 <ohYeah> `nand`: and a hellow world app might be like how many more lines?
03:20:26 <neutrino> basically, it's the same thing that people did in the 70s on minicomputers such as the PDP-10.
03:20:31 <`nand`> depends on the framework you use
03:20:33 <ohYeah> neutrino: but is javascript the overlord? how much effort does it take to escape writing js?
03:20:41 <neutrino> "the overlord"?
03:21:10 <ohYeah> `nand`: so in order to create a webserver u have to use a webframework like yesod etc.
03:21:25 <`nand`> ohYeah: if you pick some high level web server abstraction like yesod, not very many; if you pick some lower level HTTP server library that just exposes Request -> Response or something; you might have to do some HTML generation yourself
03:21:28 <`nand`> ohYeah: oh, sure
03:21:38 <neutrino> you don't, you can manage sockets and the select() api call to posix yourself, but it makes no sense
03:21:49 <neutrino> you use something that's ready
03:21:59 <`nand`> ohYeah: you can forgo each layer of abstraction and do it yourself, but you trade that for more lines of code
03:22:24 <Jeanne-Kamikaze> I bet you can do it in less lines in assembly than in javascript
03:22:27 <neutrino> bear in mind haskell isn't tuned for tiny applications the way php, bash, python or node are
03:22:28 <`nand`> besides, for simple stuff, there wouldn't be much of a point, other than for educational purposes
03:22:48 <`nand`> neutrino: higher constant cost, lower scaling? :)
03:22:57 <ohYeah> `nand`:  so a webframework is just more efficient than having the extra lines of code in the .hs file that would essentially do what the webframework does?
03:23:06 <neutrino> its power shows up in medium to large sized apps where, in other languages, the complexity starts killing you and you have to add more and more boilerplate just so that your app doesn't fall apart
03:23:16 <`nand`> ohYeah: that's true for any library in any language
03:24:25 <`nand`> ohYeah: (it's not necessarily just more efficient, but also often simpler; as well)
03:24:48 <ohYeah> so if u wanted to make a tiny web app in haskell, might it be much more annoying than node? Is node just a better choice for making simple websites and web apps
03:25:00 <neutrino> no, it's much better than node in any case
03:25:16 <`nand`> I can't answer that, never used Node.js and never intend to
03:25:31 <neutrino> node is really terrible. you have to use callbacks, which don't allow you to analyze the program in any sensible way
03:25:40 <neutrino> you can't really reason about callbacks in a sensible way
03:26:16 <neutrino> and then node itself has a well deserved reputation for being messy under the hood
03:26:19 <ohYeah> what exactly is a call back? and there's something inherently wrong with it?
03:27:17 <neutrino> well, callbacks are a way of doing concurrent parallelism
03:27:18 <zomg> If the real world only cared about what's under the hood instead of what you can do and how easily =)
03:27:44 <neutrino> you have several tasks, and one cpu, and you have to share the cpu somehow
03:27:50 <neutrino> the linux kernel does preemptive multitasking
03:27:59 <neutrino> node does callback-based cooperative multitasking
03:28:36 <neutrino> in its simplest form, a single task is split into several functions. when one of those functions ends, it basically tells node "ok, you can safely hang up this task for now, and do other stuff"
03:28:51 <neutrino> in an OS, it is important so that you can e.g. calculate the GUI and play a movie at the same time.
03:29:03 <neutrino> in a web server, each request is a separate task.
03:29:48 <neutrino> basically, you split those tasks into tiny functions, and you give those functions to the "reactor" (similar in function to the OS kernel) and you tell the reactor to somehow figure out how to execute each.
03:30:21 <Peaker_> well, one thing I prefer about the callbacks approach -- is that it's easy to make it statically clear what handles input from a certain file/socket.. When you create the socket, you can be forced to give a single handler.  Whereas with Handles and threads, any number of threads might read from a handle
03:30:23 <neutrino> however, it's difficult to debug because in more complex systems there's little causality between the input data and the code that's being executed and the moment it's executed at
03:30:41 <neutrino> writing your application in callbacks basically means turning your application inside-out
03:30:46 <Peaker_> though this is also clear in the "pipes" or conduit approaches
03:31:23 <neutrino> callbacks and reactors are a crutch which has been created for runtimes and languages that don't have robust, lightweight multithreading
03:31:43 <Peaker_> neutrino, It's really just a very cumbersome syntax, but not that different from a linear thread ("do" notation is really chaining callbacks too)
03:31:44 <neutrino> haskell is one of the languages that do have it, so it doesn't need to resort to that
03:32:10 <neutrino> yeah, it's kind of the same, but different, especially when it's very different
03:32:16 <frontendloader> There are advantages to keeping it all in the same thread
03:32:21 <neutrino> i mean it's all turing complete anyways right
03:32:23 <frontendloader> no locking
03:32:26 <Peaker_> cumbersome syntax is a serious disadvantage, I agree
03:32:43 <Peaker_> but it isn't fundamentally different or requires any fundamental structure difference from threads
03:32:50 <neutrino> it's not only that
03:33:19 <Peaker_> also, it's not "callbacks vs. lightweight multithreading" -- in languages with by-default shared mutable state, I prefer the cooperative multitasking to preemptive one, simply because it makes it much easier to reason about shared state
03:33:31 <Peaker_> Haskell is the first language I prefer the threads' approach in :)
03:33:39 <neutrino> haskell's "do" is hierarchical composability. big things are made of smaller things are made of smaller things. callbacks are a flat, queue-based composability where you have one big thing and that's made out of thousands of smaller things.
03:33:57 <Peaker_> neutrino, no, you can definitely make hierarchial call structures with callbacks
03:33:59 <neutrino> because of this, it's difficult to reason of the "one huge blub" kind of thing
03:34:26 <Peaker_> neutrino, run_http_request(params, callback) ...    abstracts away the "http request" piece, and you build a chain of callbacks on top of that, without knowing the details inside it
03:34:33 <neutrino> the language that callback approaches are executed on doesn't know about this structure peaker
03:34:48 <neutrino> that's the issue right there
03:34:54 <Peaker_> Haskell doesn't know about "do" nesting either - that's why we have the monad laws
03:35:06 <Peaker_> what the monad laws say is that it shouldn't matter
03:35:17 <neutrino> to javascript, it's all just a single long-running function, executing thousands of unrelated functions, pushing around a huge global state object
03:35:46 <neutrino> you don't have this sort of thing in haskell because it's clear what calls what
03:35:47 <Peaker_> it doesn't necessarily push a "global state", it just pushes the same local variables you'd have in a "do" block, except you'd manually capture them in a record and pass that (cumbersome syntax)
03:35:53 <zomg> neutrino: every language channel seems to have people like you who can make all other languages sound like utter turds ;)
03:35:57 <neutrino> there isn't dynamic dispatch, or select-based dispatch
03:36:28 <neutrino> zomg: i've used all the languages i spoke of in long projects at work, i know many disadvantages and some advantages to each
03:36:37 <Peaker_> neutrino, the transformation from "do"-based code to callback based code is a very simple, reversible, superficial syntactic one.
03:36:50 <zomg> neutrino: yeah not saying you don't have good points there :)
03:36:56 <Peaker_> neutrino, I agree the cumbersome syntax for callbacks encourages people to do awful things
03:37:37 <neutrino> Peaker_: this breaks down in the real world. have you ever tried debugging or optimizing a callback-based application of 500k lines? it's a huge mess.
03:37:54 <Peaker_> also, things like loops/conditionals/etc require higher-order combinators, rather than simple constructs, which encourages not using them -- and getting spaghetti code
03:38:28 <Peaker_> neutrino, I worked on a project with more lines that that, but it was split into smaller components with far less lines than that. Does that count?
03:38:29 <neutrino> you can't just go and say "oh yeah, but ideally it's all the same" - in specific situations it's not the same, and you don't have the ability to go back and forth between paradigms at the press of a button
03:39:20 <Peaker_> neutrino, Using coroutines -- you can actually have both callbacks and blocking code.. You could have threads too, but you don't want to, in languages that encourage shared mutable state
03:39:21 <neutrino> i don't know, i've had those huge pieces of junk, and it was like trying to figure out a chronometer watch movement, but it's been taken apart by someone else
03:39:41 <neutrino> and you're not allowed to put them together and one of the cogs is wrong
03:39:56 <neutrino> sure you can
03:40:04 <neutrino> now go have that in node.js and tell me abot that :)
03:40:15 <Peaker_> neutrino, when I use Python (Fortunately less these days) I prefer callbacks over threads, and I am aware of the drawbacks, but I don't think it's that bad. It does require more discipline (to avoid the tendency to flatten out the call structure)
03:40:53 <neutrino> cpython doesn't have threads, it barely has green threads
03:41:07 <Peaker_> neutrino, when I use C, I use explicit callbacks over various threading constructs, simply because when I use C, I want to extract performance out of the machine, and even the lightest forms of threads are significantly heavier than the explicit context you can pass in most cases
03:41:08 <neutrino> saying python and threads in the same sentence is silly
03:41:53 <neutrino> python is the exact kind of limited runtime that callbacks are used as an aide to. that's why the terrible terrible world of twisted is accepted by so many programmers
03:41:54 <Peaker_> neutrino, I wrote rather large C programs, all in callback style, and have not really had much trouble w.r.t the callbacks' approach
03:42:10 <neutrino> what was that in, Qt?
03:42:28 <Peaker_> C, not C++.  The event loop was ours
03:42:49 <neutrino> so you were the first generation of programmer that worked on the code base?
03:43:10 <Peaker_> no -- it was a rewrite of code that used a hybrid threaded/callbacks approach
03:43:11 <hiptobecubic> what does that even mean
03:43:24 <Peaker_> neutrino, and it interfaces with code that uses coroutines
03:43:41 <neutrino> well then, i'm happy you've had a good experience
03:43:51 <neutrino> what was the key to your success?
03:44:41 <Peaker_> neutrino, it's entirely possible to successfully use callbacks -- the drawback is requiring more discipline, and a lot of boilerplate and ugly syntax.  The benefits are performance (in the C case, at least)
03:45:23 <neutrino> right, so you named the same drawbacks i did
03:45:48 <neutrino> in haskell there's no reason to do this because the drawbacks you talk about don't exist
03:46:53 <Peaker_> yes, Haskell gives the best of both worlds -- except for slightly higher cost for the concurrency (Haskell lightweight threads cost at least 1K of stack, whereas a C concurrent context can cost a few bytes)
03:47:12 <neutrino> yeah, but then you also get sparks
03:47:19 <neutrino> which are even cheaper
03:47:40 <neutrino> i guess they are concurrent contexts in the end too
03:47:45 <neutrino> i've never used them
03:48:35 <Peaker_> Well, sparks are useful for parallel evaluation, not for concurrent IO
03:48:56 <neutrino> can't sparks do concurrent IO too?
03:48:57 <Peaker_> if you want concurrent IO in Haskell you have to pay for light-weight threads.. which is reasonable until you want to have many millions of them
03:49:05 <neutrino> @type par
03:49:06 <lambdabot> a -> b -> b
03:49:10 <Peaker_> no, sparks are for pure evaluation
03:49:12 <neutrino> looks like it can be invoked in the IO monad too
03:49:18 <neutrino> ok
03:49:47 <Peaker_> if you want to read from millions of sockets in the threads model, for example, you're going to need to have a thread-per-socket
03:50:02 <neutrino> i'm not sure how to do better concurrent IO than threads in haskell
03:50:14 <neutrino> doing something like node.js or twisted is not the answer, that's sure
03:50:40 <Peaker_> you could have a static resource analysis on the threaded code you run, that could manage to put an upper bound on its stack use. Then you could allocate exactly that amount which can be far below 1K in some cases
03:50:44 <neutrino> you could have a thread per several sockets, and do dispatching. but then you're doing callbacks again.
03:51:01 <Peaker_> then you could get light weight threads that cost as much as the manual context representation would cost
03:51:09 <Peaker_> neutrino, yeah, exactly
03:51:19 <neutrino> you don't really need to do threads per socket either. you only need threads once the sockets become active.
03:51:26 <Peaker_> a static resource analysis is much easier in C than in Haskell, though
03:51:45 <Peaker_> you might have millions of "active" sockets (live connections with little data), though
03:52:06 <neutrino> then you're just abusing sockets
03:52:18 <neutrino> you can shoot yourself in the foot with many guns
03:53:46 <neutrino> a scenario where this happens is the sort of thing that websocket does
03:54:37 <neutrino> but then the question really becomes, what are you going to do about the execution context that your single session needs to process incoming thata?
03:54:40 <neutrino> incoming data
03:54:51 <Peaker_> neutrino, why is that abuse? Maybe you have millions of clients pulling data very slowly?
03:55:10 <neutrino> well, it depends on what you're doing really
03:55:15 <Saizan> tbf, callback-based APIs can look a lot like threaded-based ones by using some variation of the Cont monad
03:55:18 <neutrino> do you need a lot of context to provide that data?
03:55:34 <neutrino> if you do, then a 1K thread might be negligible
03:55:49 <neutrino> if you don't, you're probably better served with things like conduits
03:55:54 <neutrino> iiuc
03:56:06 <Peaker_> neutrino, yes, and the nice thing about explicit contexts in a language like C, is that the memory management is much more tight than threads, even light-weight threads.  This means you don't have to think about working around resource problems that are not inherent in your problem.. that's something I do like about this approach in C
03:56:16 <neutrino> it's easy to generalize like what i just did, though
03:56:31 <neutrino> it's different when an actual situation comes into play
03:56:38 <Peaker_> neutrino, how do conduits help here?
03:57:24 <neutrino> well, what approach would you use to serve a lot of slow clients with data that does not need to be processed?
03:57:54 <neutrino> i guess mm_freak_ would have the answer
03:58:05 * neutrino pokes mm_freak_ 
03:59:01 <neutrino> @ask mm_freak_ what approach would you use to serve a lot of slow clients with data that does not need to be processed?
03:59:02 <lambdabot> Consider it noted.
03:59:09 <Peaker_> neutrino, in C I'd just do the straightforward thing with manual callbacks :P
03:59:18 <neutrino> i know
03:59:27 <neutrino> callbacks are a natural thing in C
03:59:32 <Peaker_> in Haskell I'd buy more hardware and spread the connections on more machines
03:59:37 <neutrino> but then there are lots of deviations that are accepted in C
03:59:54 <neutrino> there's got to be some other approach though
04:00:34 <ohYeah> so then node might be easier for network IO and simply website deployment?
04:01:37 <neutrino> lol, no way
04:01:51 <neutrino> callbacks in node have none of the advantages that peaker is talking about
04:02:16 <neutrino> and his application is a very, very specific, unusual scenario, where you have huge load
04:02:23 <neutrino> on the order of amazon, or facebook
04:03:15 <neutrino> don't get confused into thinking that node.js shares these advantages or that it would be the first, second, or third choice in the scenario peaker has described
04:03:34 <ohYeah> I'm not really interested in building huge sites or apps, wouldn't node have less of a learning curve that might outweight the elegance of code your talking about neutrino:
04:03:48 <neutrino> no
04:03:51 <neutrino> node is complex
04:03:58 <neutrino> if you want something simple, go with php
04:04:02 <Peaker_> ohYeah, callbacks are useful when you want cooperative multitasking because mutable shared state is the default, and you don't have coroutines,    or when you want to squeeze performance.   Node may be good to work around Javascript's problems, but it does not squeeze performance. For Javascript it may be good, but it is worse in every way than the Haskell solution
04:04:09 <neutrino> s/simple/easy
04:04:36 <Peaker_> ohYeah, if you're force to use Javascript, Node is probably your best choice.. But if not, why use Javascript? :)
04:05:01 <neutrino> you are not forced to use javascript
04:05:42 * `nand` wonders if ohYeah is just going to spend all day asking about whether to use Node.js or Haskell, rather than just using both and seeing which one he likes better
04:05:45 <neutrino> when you're told you have to use javascript, the viable alternative always remains in seppuku
04:05:47 <ohYeah> Peaker_: I am not forced to use javascript, but I might be interested in cooperative multitasking.
04:05:59 <neutrino> and it's much more honorable
04:06:16 <Peaker_> ohYeah, cooperative multitasking is nicer than preemptive multitasking when you have tons of mutable shared state, which many languages encourage
04:06:24 <neutrino> well, if you want to experiment, to learn its limitations and possibilities, you can do that in haskell too
04:06:42 <byorgey> @remember neutrino when you're told you have to use javascript, the viable alternative always remains in seppuku. and it's much more honorable.
04:06:42 <lambdabot> It is stored.
04:06:53 <Peaker_> ohYeah, in Haskell, state is by default immutable, and shared mutable state is very rare and explicit -- so the advantage of cooperative multitasking in Haskell disappears, and you can have your cake (preemptive multitasking) and eat it too (no shared state problems)
04:07:29 <neutrino> ohYeah: you can do cooperative mutltitasking in haskell. it just shows you that, unless your runtime is very very specific (like C), there's absolutely no advantage, and very many big disadvantages, to doing it
04:07:53 <neutrino> ohYeah: you can do pretty much any programming paradigm you want in haskell, it's a great language for experimenting.
04:08:02 <Peaker_> neutrino, whereever shared mutable state is prevalent, cooperative multitasking is preferable
04:08:22 <neutrino> you have IORefs, MVars, TVars, ...
04:08:33 <neutrino> all those are mutable state in various different flavours
04:08:36 <Peaker_> it reduces the number of interleavings you have to think about
04:09:39 <neutrino> anyways, cooperative multitasking is only preferrable in small applications
04:09:48 <neutrino> you wouldn't write an OS with cooperative multitasking
04:09:57 <neutrino> unless it were small, like windows 3.x, which did.
04:10:03 <c_wraith> Ahem.  MacOS, pre OS X
04:10:05 <neutrino> *which did have it
04:10:07 <neutrino> yeah.
04:10:18 <neutrino> not really a huge complicated system.
04:10:31 <ohYeah> I'm somewhat burnt out with switching from languages to languages; I'm a jack of all trades but a master of nothing. I want to build and host some simple websites and maybe some web apps (like a chat client etc.). I think haskell is the mroe elegant and powerful language, but how much more is the learning curve for all the necessary webframeworks and haskell client side language etc.
04:10:47 <neutrino> haskell is one language you'll never run out of uses for
04:11:04 <neutrino> javascript is a language which seems attractive to you because it has this one new idea that you haven't used yet
04:11:09 <neutrino> haskell has all those ideas and more.
04:11:43 <neutrino> you'll switch to javascript to learn this one tiny thing, then you will run out of options and you'll use some other blub language to learn some other new idea
04:12:47 <neutrino> and you'll keep learning to use these weak languages which were made with optimizing for a set of constraints abandoned 20 years ago in mind
04:13:04 <Peaker_> neutrino, cooperative vs. preemptive doesn't matter in terms of malicious/bad behavior when you have shared mutable state anyway
04:13:47 <neutrino> or you could start using something which was made by leading language researchers. not necessarily haskell, but it's a good bet. you have things like, for example, ML or Erlang at hand
04:13:49 <Peaker_> neutrino, cooperative can starve, but threads overwriting each other's memory can do anything anyway :)
04:13:56 <neutrino> yeah, they can
04:14:24 <neutrino> but there's a reason why things are done this way, and the biggest one is that cooperative multitasking just doesn't scale
04:14:48 <Peaker_> what do you mean?
04:14:57 <Peaker_> in what axis doesn't it scale?
04:15:00 <neutrino> and in specific it's difficult to assure you're not doing something stupid in cooperative. in preemptive it's much more difficult to block the world.
04:15:08 <ohYeah> neutrino: I understand what you're saying. But with the interest of just making simple websites and simple multi user interactive web apps, might node be a better choice especially considering it has a lower curve. I understand I can do more in haskell, but I don't know how much more I'll really want to use and if thelearning curve is worth it.
04:15:21 <neutrino> ohYeah: well, you're fairly conflicted here
04:15:26 <Jafet> It's not webscale
04:15:28 <Jafet> !!!!!
04:15:48 <neutrino> on the one hand you want to say "i want to end my exile and stop wandering from language to decrepit language like a vagabond"
04:15:55 <Jafet> Have you ever seen a web service with coroutines
04:16:03 <neutrino> yes, amazon
04:16:08 <Peaker_> neutrino, cooperative requires trust. If you have that trust anyway, it is harmless. If you don't, it is harmful.  In Haskell threads don't need to trust each other much because they can't destroy each other's state.  In C, it is meaningless
04:16:42 <Peaker_> ohYeah, if you're going to do very little programming, Haskell is probably not worth the learning curve
04:16:47 <neutrino> ohYeah: on the other hand, you say "look at this old abandoned warehouse, it's got "coroutines" spraypainted on the walls. there are some dogs wandering around. let me move in and try make home there"
04:16:59 <Peaker_> ohYeah, most people get hooked on programming though, and do a lot.. So for most programmers, Haskell is probably worth the learning curve
04:17:49 <neutrino> Peaker_: no one in their right mind should trust *themselves* to write correct code above the 100kloc mark.
04:17:54 <Peaker_> I wouldn't learn Haskell to code for 2 weeks. Easier to get started with an untyped language.. can learn just the term level, rather than also learning the type level and the relationship between them
04:18:08 <neutrino> so, as i said, your example works for small things you can keep in your head all at once.
04:18:15 <neutrino> it doesn't work for bigger things.
04:18:37 <osa1_> so I don't know much about type systems and logics but I have a question: do Gödel's incompleteness theorem and curry-howard isomorphism imply that we cannot have a complete but also consistent type-sytem ? (here I think completeness mean being able to implement all correct programs)
04:18:47 <ohYeah> I'm creating a community in the jungle and want to build websites to share my voluntarist (i.e non aggressive philosophies), I may do some free lance web stuff or create apps for profit, however, I really like the elegance of functions and math interests me, but I don't know if I'll ever need haskell to do that
04:19:09 <Peaker_> neutrino, I don't think we've had more than one or two cooperative starvation bugs in a very large C code base that uses thread-per-core + cooperative callbacks/coroutines in each core
04:19:10 <ohYeah> philosophy*
04:19:24 <Peaker_> neutrino, you don't have to keep much in your head at once.. abstractions work
04:19:30 <neutrino> ohYeah: neither haskell nor node are suited for your use case. go with php.
04:20:13 <Peaker_> ohYeah, if you're even thinking of coding for profit, I'd suggest learning Haskell, it'll be worth the learning curve
04:20:14 <neutrino> in specific, you only use programming as a means to an end, and very incomplex means at that
04:20:22 <Saizan> osa1_: pretty much
04:20:58 <osa1_> Saizan: interesting. can you point me some resources for further investigation ? being consistent here means not having a bottom value with the type of forall a. a, right ?
04:20:58 <neutrino> "some web app programming to make extra cash" is best done in the most popular language available to you
04:21:09 <Jafet> If you manage to write BEW with Nat, I will be very impressed.
04:21:10 <neutrino> because that means job availability
04:21:41 <neutrino> the amount of haskell and node jobs on job boards in my area in the last year wasn't even 0.000001% of php jobs
04:21:48 <neutrino> because it was 0
04:21:54 <Saizan> osa1_: pretty much too :) i'm not sure which resources to point to though
04:22:20 <ohYeah> well, I'm not looking for a job, I just wanna host some sites, and learn a useful skill. Profit is honestly secondary.
04:22:21 <Jafet> @quote kmc curry-howard
04:22:21 <lambdabot> kmc says: "Haskell is great, because Curry-Howard!  Proving things in the type system.  We can prove that, uh, Ints exist, unless they're ⊥."
04:23:30 <Peaker_> neutrino, you can make your own job, though, and if you use superior technology you might manage to make much more money
04:23:39 <neutrino> yeah, i do that
04:23:49 <neutrino> i've been using haskell for almost everything this year
04:24:03 <Jafet> The Curry-Howard relation just says that values of types are proofs about propositions. So if you come up with an unprovable proposition, then there is a type for which you cannot produce a value, even though there should be one. If that sentence made any sense to you, try reading it again.
04:24:41 <ohYeah> neutrino: Peaker_: Peaker_ ........Ok what do u guys think: I built a simple messaging application in the past in php. I'll try the same thing with haskell. Should I finish LYAH? Up to what level of haskell should I learn first (I don't even know what moands are yet)? And then I'll see how easy that is and deploying simple websites
04:25:00 <Peaker_> ohYeah, I think LYAH has exercises
04:25:02 <neutrino> yeah lyah is necessary reading
04:25:07 <Peaker_> ohYeah, I'd finish the whole of LYAH
04:25:11 <derdon> Jafet: what is an "unprovable proposition"?
04:25:15 <Jafet> I think you should finish working on english first.
04:25:17 <AtomicStryker> hey guys, noob question, i'm supposed to create a data type that gets a list in its constructor and immediatly filters that list, but i cant find examples on how to write a signature for that .. help? :D
04:25:22 <Jafet> One language at a time, you know.
04:25:44 <Jafet> derdon: a proposition that cannot be proved.
04:25:45 <neutrino> Jafet: be nice
04:26:00 <Peaker_> AtomicStryker, you mean a "smart constructor" function?   Data Constructors cannot apply logic to their input
04:26:00 <derdon> Jafet: oh, thank you very much
04:26:01 <neutrino> derdon: a proposition the truth value of which cannot be inferred from your set of axioms.
04:26:22 <neutrino> you may decide on the truth value of it ad-hoc and call it a new axiom.
04:26:22 <AtomicStryker> Peaker_ that would explain why i cant find examples, however it is what im supposed to do, lol
04:27:01 <Peaker_> AtomicStryker, data Foo = Foo [Int] ;  mkFoo :: [Int] -> Foo ; mkFoo xs = Foo (filter (<5) xs)
04:27:28 <neutrino> AtomicStryker: you use a constructor function like peaker suggests.
04:27:29 <AtomicStryker> well ye, if i make it a function i can pull it off ;)
04:27:45 <AtomicStryker> ill just make it a function
04:27:51 <neutrino> for example, Map uses this approach
04:27:52 <AtomicStryker> thanks
04:28:08 <neutrino> @type Data.Map.fromList
04:28:09 <lambdabot> Ord k => [(k, a)] -> M.Map k a
04:28:45 <ohYeah> neutrino: Peaker_ Thanks for your help. I really appreciate it. I'm thinking haskell is just a more useful skill in the longrun and the effort might be worth it. Why do you guys use haskell? Do you use it for fun and how much does it help your brain?
04:29:04 <neutrino> yes, in the long run, if you want to stick with programming, haskell is loads better to learn than node.js
04:29:31 <neutrino> haskell is great for learning new concepts. it's like 100x better for that than node, python, and other languages like that
04:29:38 <neutrino> i use it for work.
04:29:43 <neutrino> it hasn't failed me yet.
04:29:54 <ohYeah> what about agda or caml lol?
04:30:00 <ohYeah> ocaml*
04:30:16 <neutrino> the ML family of languages is very similar to haskell in many ways
04:30:33 <neutrino> agda is a theorem prover. it is not a general purpose programming language.
04:30:41 <Saizan> osa1_: i guess TTFP is a good read if you're interested in such topics
04:30:45 <Saizan> @where TTFP
04:30:45 <lambdabot> http://www.cs.kent.ac.uk/people/staff/sjt/TTFP/
04:30:47 <Peaker_> ohYeah, I use it for my main project, and for scripting/miscellaneous automation
04:30:51 <Jafet> #agda knows about Agda and #ocaml knows about OCaml.
04:30:57 <Peaker_> ohYeah, and it has definitely expanded my brain :)
04:31:08 <osa1_> Saizan: thanks very much for TTFP
04:31:37 <zomg> I just wish I could get a job doing haskell
04:31:41 <zomg> That would be pretty awesome
04:31:47 <zomg> But since it would involve moving to god knows where...
04:31:51 <Saizan> Agda is a general purpouse programming language
04:32:09 <Saizan> it doesn't have a great ecosystem around it though
04:32:13 <Jafet> That's what adga programmers tell themselves
04:32:23 <Jafet> Or agda
04:32:32 <ohYeah> is haskell the shit or should I research Ocaml or other functional languages lol... erlang?
04:32:58 <zomg> I think Haskell is currently the FP language that is gaining most traction
04:33:04 <Saizan> @faq is haskell the shit?
04:33:04 <lambdabot> The answer is: Yes! Haskell can do that.
04:33:07 <neutrino> it is very good.
04:33:41 <Rarrikins> @faq Can Haskell turn my ordinary laptop into a robot that will do my chores around the house?
04:33:41 <lambdabot> The answer is: Yes! Haskell can do that.
04:33:42 <`nand`> ohYeah: maybe you should ask #ocaml, #erlang etc. and average the results
04:34:06 <`nand`> @faq Can Haskell power an autonomous Eee PC inside a hamster wheel?
04:34:06 <lambdabot> The answer is: Yes! Haskell can do that.
04:34:24 <Jafet> How is #haskell doing for Haskell, a nine or so?
04:34:48 <Jafet> A solid eight, possibly nine, might go up to nine-and-half if I go do something else.
04:34:49 <Peaker_> Saizan, is what's missing just the library work, or discovering some new paradigms/ways of doing things in Agda?
04:35:13 <Jafet> Peaker: I think those are to a large degree synonymous in a language like agda
04:35:17 <`nand`> so how long until lens is ported to agda?
04:35:26 <Jafet> Look at what mundane "library work" is done in haskell
04:35:39 <neutrino> `nand`: but i thought lenses were a turing-complete language.
04:35:48 <neutrino> and agda is total.
04:35:59 <`nand`> unless you ignore the termination warnings
04:36:01 <ohYeah> please guys... does my research end at haskell?
04:36:05 <ohYeah> just tell me it does
04:36:09 <neutrino> it does
04:36:10 <derdon> it does.
04:36:24 <ohYeah> *sigh of relief*
04:36:42 <`nand`> ohYeah: can't guarantee you won't try and research other languages like agda, idris, etc. later
04:36:42 <zomg> lol
04:36:45 <zomg> Prolog!
04:36:47 <neutrino> if you learn haskell there's no reason to learn things like ML including ocaml, or erlang, unless you have a very specific need that is targeted by those languages. you're unlikely to stumble into that though.
04:36:49 <Jafet> No, of course not. Next is scala
04:36:53 <Lethalman> prolog is very fine
04:37:01 <Lethalman> about prolog, is there anything you can do similar to prolog in haskell?
04:37:05 <ohYeah> fuck scala
04:37:10 <neutrino> yes, the Maybe monad
04:37:10 <Lethalman> like some logic programming with monads :)
04:37:17 <`nand`> neutrino: *groan*
04:37:23 <neutrino> `nand`: *roar*
04:37:35 <merijn> The next step is type-level Prolog :p
04:37:35 <zomg> Fuck yeah, I just used the tuple constructor as an applicative functor. I feel smart now.
04:37:56 <Jafet> I hear there's a pill for that now.
04:37:59 <ohYeah> so since I likely won't need ML, what else is there? idris, prolog, ocaml, whatelse?
04:38:03 <merijn> Lethalman: Well, conceptually you can write prolog style code in haskell's type system. It just means your compilation phase probably starts lasting rather long :p
04:38:16 <neutrino> ohYeah: stop making lists.
04:38:21 <neutrino> it doesn't get you anywhere.
04:38:32 <zomg> Yeah I already told ohYeah he's suffering from analysis paralysis
04:38:32 <zomg> :D
04:38:45 <Jafet> merijn: ghc's compilation stops very fast unless you raise -fcontext-stack
04:39:09 <merijn> Jafet: ah, yeah
04:39:13 <neutrino> zomg: well, he wasn't sure what a good choice was, now he is
04:39:15 <ohYeah> so what neutrino: just learn haskell and finish, no more research
04:39:16 <neutrino> so it's time to accept that
04:39:23 <neutrino> learn haskell and see what happens
04:39:43 <neutrino> it might well be the last general purpose language you'll learn in a decade's worth of time
04:39:48 <`nand`> maybe you could learn Haskell and Finnish
04:39:57 <ohYeah> lol
04:40:03 <Peaker> ohYeah, Haskell covers more concepts than OCaml, Prolog, ML, etc. By learning Haskell you'll learn more.  Agda, Idris, etc are even further up, but they are not quite usable for general purpose programming yet
04:40:05 <neutrino> do haskell identifiers allow umlauts?
04:40:28 <neutrino> > let knödel = 2 in knödel + knödel
04:40:28 <lambdabot>   mueval: recoverEncode: invalid argument (invalid character)
04:40:28 <ohYeah> Peaker: thank you u r the true boss
04:40:29 <Peaker> ohYeah, If you're just wondering what language will give you great super powers quick, Haskell is it :)
04:40:32 <neutrino> bah
04:40:43 <byorgey> neutrino: yes, but lambdabot doesn't
04:40:43 <`nand`> neutrino: yes
04:40:52 <companion_cube> Haskell does not cover more than OCaml or prolog
04:40:56 <companion_cube> it covers different stuff
04:40:56 <neutrino> right you can do utf8 mode right?
04:41:07 <neutrino> with → for type sigs etc
04:41:09 <`nand`> neutrino: Haskell sources files *are* UTF-8
04:41:13 <Peaker> companion_cube, I see Prolog as a tiny subset of Haskell
04:41:14 <`nand`> you can't turn it off, rather
04:41:19 <companion_cube> Peaker: really??
04:41:23 <companion_cube> I don't see how
04:41:28 <byorgey> neutrino: oh, sure, there's an extension for that, but you don't need that to use umlauts in identifiers
04:41:33 <Peaker> companion_cube, logic programming is much easier to encode in Haskell than all of Haskell to encode in Prolog
04:41:34 <companion_cube> prolog has more powerful pattern matching, and reflection
04:41:38 <neutrino> ah ok
04:41:39 <zomg> `nand`: yeah I'm pretty sure finnish is close to the syntax of some crazy programming language for most intents and purposes
04:41:52 <Jafet> This probably coming from someone who has never really used prolog
04:41:54 <zomg> maybe someone should go and write an article about finnish in the esolang wiki
04:41:55 <zomg> lol
04:42:01 <companion_cube> Peaker: real logic programming in haskell would require unification
04:42:04 <Peaker> and OCaml is like Haskell without a lot of the nice concepts, with more imperative stuff thrown in instead
04:42:06 <neutrino> companion_cube: what is reflection in prolog?
04:42:17 <companion_cube> neutrino: the ability to manipulate logic clauses as terms
04:42:25 <companion_cube> ie, manipulate the program itself
04:42:30 <neutrino> give me an example please
04:42:38 <Lethalman> yeah the dynamic database of prolog
04:42:38 <`nand`> zomg: neurolinguistic metaprogramming?
04:42:41 <companion_cube> there are some builtin predicates for this
04:42:45 <Lethalman> neutrino, add rule at run time that is
04:42:51 <neutrino> `nand`: you forgot "dynamic"
04:43:06 <companion_cube> http://en.wikibooks.org/wiki/Prolog/Built-in_predicates <-- look at "var" predicate for instance
04:43:13 <Peaker> companion_cube, porting prolog programs to Haskell is supposedly easy, according to various people (I've not done it myself), though the opposite is probably rather hard
04:43:15 <neutrino> companion_cube: i don't know prolog almost at all. can you give me a simple example and tell me what it achieves?
04:43:28 <companion_cube> Peaker: the backtracking algorithm is quite simple
04:43:54 <companion_cube> but I don't think that writing a DSL as powerful as prolog in Haskell is t hat easy
04:44:18 <zomg> `nand`: lol, something like that
04:45:48 <Lethalman> neutrino, for example assert (foo (X) :- bar (X)), it's special syntax for adding new rules to the database, also retract (...), and so on
04:46:03 <Lethalman> neutrino, a program is made of rules, and at run time you can add/retract new rules, as simple as that
04:46:09 <`ramses> Peaker: can you do difference lists as efficient in haskell as in prolog? Afaik the current implementations use functions which can not be pattern matched against
04:46:11 <companion_cube> neutrino: look at http://web.student.tuwien.ac.at/~e0225855/acomip/acomip.html (meta interpreters are easy to write in prolog)
04:46:51 <Peaker> `ramses, I'm not a prolog expert - but I think the whole notion of efficiency in Prolog is problematic because it really depends on the search algorithms used by the implementation. You can't even say what the O() of some prolog rule is
04:47:01 <`ramses> so maybe you can "port" stuff, but there are serious disadvantages to some paradigms
04:47:22 <companion_cube> Peaker: the same for haskell, isn't it?
04:47:33 <companion_cube> you cannot predict how long evaluating an argument will take
04:47:33 <Lethalman> Peaker, in fact that's the whole point of prolog, that you don't care about the implementation, you declare the problem
04:47:51 <`ramses> in reality you do care ;)
04:47:56 <Lethalman> yeah you do care
04:48:01 <Lethalman> but the philosophy is that :P
04:48:17 <`ramses> otherwise you could use the optimal implementation that just returns true
04:48:45 <Jafet> I'm not a prolog expert, but I'm going to say some crap that I heard from my friends. Therefore we should just write prolog programs in haskell.
04:48:46 <Lethalman> I think that prolog and haskell are much complementary, it's not easy to port programs either ways
04:49:10 <neutrino> :- is the same as right-tack ( |- ) right?
04:49:40 <Lethalman> neutrino, A :- B means if B then A, it's implication
04:49:42 <Peaker> companion_cube, you can talk about the O() in Haskell, it's just a bit harder
04:49:43 <`ramses> it is easy to port most prolog code to haskell (except the dynamic stuff) but you lose some nice features, mostly due to a lack of real unification
04:50:21 <Jafet> Yeah, it's a bit harder because you have to know the details of the implementation. Surprise.
04:50:23 <Lethalman> `ramses, the dynamic stuff is state, you'd have to transform the code to one more layer of abstraction in order to include state, or something like that (i'm no haskell expert)
04:50:26 <Peaker> Jafet, Do you believe it is false crap? :)
04:50:52 <Jafet> I believe I see more than one other person here telling you that it is false crap.
04:51:12 <Peaker> Jafet, I don't see anyone disagreeing with the efficiency claim? or do you mean something else?
04:51:48 <shachaf> <companion_cube> Peaker: the same for haskell, isn't it?
04:51:50 <`ramses> Lethalman: not sure whether it's that easy, it can manipulate the algorithm dynamically (e.g. change the current predicate and recurse), you probaby can do something similar with state and functions but it'll be a lot less flexible and understandable
04:52:00 <Peaker> shachaf, that's not disagreeing - that's just expanding the statement :)
04:52:04 <Lethalman> `ramses, you have to declare rules are data
04:52:22 <`ramses> what do you mean by that?
04:52:29 <Lethalman> `ramses, that rules ARE data
04:52:32 <ohYeah> Peaker: u seem like a knowledgeable cat... so haskell is the shit for me without any more questions asked, right
04:52:37 <shachaf> Haskell does not have an operational sematnics and therefore you can't reason about its runtime costs. An implementation might use substitution of laziness or something else.
04:52:39 <Lethalman> then there's some algorithm that go through rules to find a solution
04:52:41 <companion_cube> Peaker: I just say I don't think that's easier to reason about performance in Haskell than in Prolo
04:52:41 <`ramses> sure, but also code
04:52:44 <companion_cube> Prolog
04:52:50 <Lethalman> `ramses, the code would only be the backtracking algorithm
04:53:12 <Peaker> companion_cube, reasoning about performance in Prolog is as easy as in Haskell, you mean?
04:53:17 <`ramses> ha, but then you can say the same about haskell, the functions are just data, the runtime is the only code
04:53:34 <Lethalman> `ramses, to be transformed in prolog? of course :)
04:53:40 <Lethalman> but that's way harder I believe :P
04:53:43 <Peaker> shachaf, in practice, though, the Haskell report is just lip service, and often when we say Haskell we really mean GHC
04:53:48 <Jafet> Lethalman: you can write a prolog interpreter in haskell, but that just proves that prolog and haskell are turing complete. No surprises there.
04:53:57 <Lethalman> Jafet, of course
04:53:59 <shachaf> ohYeah: Why do you keep asking about Haskell vs. X for many different values of X? People here like Haskell. People here don't really care to insult other languages pointlessly. If you want to learn Haskell, feel free.
04:54:03 <Lethalman> I was talking about prolog code using dynamic features
04:54:07 <shachaf> Peaker: OK, so pick a Prolog implementation and reason about that.
04:54:12 <companion_cube> Peaker: for prolog the implementation is quite standard, it's the WAM
04:54:20 <Lethalman> that is, if a program doesn't use dynamic features, you can write it directly in haskell, otherwise it would be simpler to threat rules as data
04:54:27 <companion_cube> there is an abstract machine that is used by efficient compilers
04:54:38 <maky> how many times will this go through all list elements?  map str . filter odd . map foo $ list
04:54:51 <`ramses> maky: once
04:54:57 <luite> neutrino: ghcjs does have stdout/stderr, and you can make your own javascript-side handler for it (for example output the stuff to with console.log, or send it to the server), usually it doen't make much sense to use that though, the whole stdout and io buffering stuff is quite heavy, lots of code
04:54:59 <Rarrikins> maky: If it's fused, once.
04:55:03 <Rarrikins> Bah
04:55:07 <maky> fuses?
04:55:08 <`ramses> actually, not at all until you ask for results
04:55:10 <maky> fused?
04:55:11 <Rarrikins> Once regardless due to nonstrictness.
04:55:18 <Rarrikins> maky: Sorry, that was irrelevant.
04:55:34 <maky> ok, nice. I thought it was once but wasnt sure
04:55:37 <Jafet> maky: why does it matter how many "times" "this" goes through the list?
04:55:55 <Peaker> shachaf, companion_cube: Ok, given a particular implementation, is the search as predictable as, say, GHC evaluation order?
04:55:59 <Jafet> The answer can be one, two, three or some other number, depending on what you really mean.
04:55:59 <companion_cube> once if the compiler optimizes, right?
04:56:24 <Lethalman> Peaker, the search in prolog is very predictable
04:56:26 <`ramses> companion_cube: once due to lazyness, that has nothing to do with optimizations I think
04:56:43 <Rarrikins> companion_cube: No, it should make a bunch of thunks. The thunks will be evaluated one by one.
04:56:56 <ohYeah> what's the haskell community like compared to other functional languages?
04:57:00 <maky> Jafet: I meant how many times will the list be recursed over
04:57:21 <`ramses> ohYeah: how can you expect an objective answer for that question when asked here?
04:57:24 <Jafet> Peaker: it is probably even more predictable than GHC, especially when CAF and lambda lifting is considered.
04:57:35 <Peaker> maky, There's no guarantee, it depends on rewrite rules in scope, optimization passes, and the eventual use of the list
04:57:55 <ohYeah> `ramses: because maybe you guys can be objective
04:58:04 <shachaf> ohYeah: Comparing Haskell to other languages is really not the point of this channel.
04:58:07 <shachaf> ohYeah: You're asking a lot of the sorts of questions that cause arguments and don't give you much benefit. :-)
04:58:07 <Lethalman> Peaker, there's guarantee of the search order
04:58:15 <Peaker> Jafet, Lethalman, ok, thanks, that may correct a misperception I've read from others
04:58:21 <Lethalman> Peaker, optimizations are there in any language
04:58:28 <companion_cube> Peaker: GHC is predictable?
04:58:30 <maky> Peaker: why would it be done more than once when lists are lazy?
04:58:40 <Peaker> companion_cube, with practice :)
04:59:04 <`ramses> ohYeah: the question is in itself already subjective, since I don't think there are any objective measures for the quality of a community
04:59:17 <Peaker> maky, it could be done once for each of your list processors, or just once for the entire thing, if the optimizer was smart enough
04:59:24 <Jafet> maky: the answer, whatever it is, is most likely unimportant to you.
04:59:45 <Peaker> maky, there's also a "Streams" library you could use instead of the ordinary list functions, that guarantees fusion
04:59:53 <Rarrikins> Also, with infinite lists, you can't go through the list more than once.
04:59:58 <Jafet> maky: an assembly line paints a car. Does it matter whether the line has one, two, or three robots?
04:59:58 <Peaker> (or at least makes it much more likely)
05:00:07 <companion_cube> Peaker: well then, I assume it's the same for a prolog expert ;)
05:00:42 <Peaker> Rarrikins, you could go over it many times, just not end to end, but with parallel processing... map (+1) . map (*2) $ [1..]    could be fused or it could go over each element twice
05:01:00 <Peaker> "parallel" not in the parallelism sense
05:01:15 <Jafet> I suggest "interleaving".
05:01:21 <Peaker> yeah
05:01:22 <Lethalman> talking about haskell, I was going to reason about how to port a java simulation I've written in haskell
05:01:32 <Lethalman> I need a graph where I only do very simple stuff
05:01:55 <Lethalman> that is a list of nodes, and get edges from that node
05:01:56 <Rarrikins> Peaker: Ahh, I see what you mean.
05:02:04 <Lethalman> no search in the graph or anything like that
05:02:18 <Lethalman> plus I need a Double on nodes and on edges
05:02:22 <maky> I thought there was nothing to optimize here since lists are lazy. I must not be undertanding what lazy means then
05:02:25 <Rarrikins> Lethalman: There's probably a graph library or three.
05:02:35 <Lethalman> Rarrikins, yes I was reading those
05:02:39 <Rarrikins> maky: Well, you can optimize some of the work for each element away.
05:03:44 <Rarrikins> maky: For instance, map f . map g can be map (f . g) instead, so that, whatever stuff map itself does, it only does it once.
05:03:46 * hackagebot free-game 0.3.0.0 - Create graphical applications for free.  http://hackage.haskell.org/package/free-game-0.3.0.0 (FumiakiKinoshita)
05:04:31 <Jafet> maky: map destroys a list and creates another list. This part can be skipped sometimes.
05:04:37 <Rarrikins> maky: So, if it keeps a thunk where it remembers to apply g then to apply f, it can remember one less step.
05:09:17 <AtomicStryker> another question, now i have a data DerpList a = DerpList [a] (a -> [a] -> Bool)        ... and im trying to get it instantiated for Show ... but instance Show DerpList where show (DerpList x f) = show x     bitches about "a"
05:09:59 <AtomicStryker> no wait actually it demends "one more argument for DerpList"
05:10:11 <Jafet> Yes. Don't be selfish with that 'a'.
05:11:06 <AtomicStryker> when i make it instance Show (DerpList a) instead, it bitches about no instances of a arising from DerpList x f
05:11:22 <AtomicStryker> despite x being of type [a]
05:11:41 <Rarrikins> Are you doing show x?
05:11:45 <Jafet> How do you show something of type a?
05:11:54 <`ramses> AtomicStryker: add a class constraint (Show a) =>
05:11:56 <AtomicStryker> i dont, i pass it to show and run
05:12:12 <`ramses> a list is an instance of show only if its elements are
05:12:27 <Rarrikins> AtomicStryker: You need to restrict a to instances of Show.
05:12:29 <Jafet> Ah, the perennial pass-the-buck programmer.
05:13:22 <AtomicStryker> where exactly do i put (Show a) => ? in the type declaration?
05:13:38 <`ramses> Jafet: what do you mean by that?
05:14:18 <`ramses> AtomicStryker: instance (Show a) => Show (DerpList a) where ...
05:14:34 <AtomicStryker> thank you good sir
05:14:35 <`ramses> no parens needed actually
05:14:56 <Jafet> ramses: what do you mean by that?
05:15:15 <Rarrikins> There's no parentheses needed around Show a.
05:15:19 <`ramses> Jafet: "perennial pass-the-buck programmer"
05:15:53 <Jafet> What do you want to know about its meaning?
05:16:23 <`ramses> Rarrikins: somehow I got a mental image of class comstraints having parens, I'm working on getting rid of that :)
05:16:31 <Jafet> They do.
05:17:13 <Jafet> Actually, there seems to be no clear reason to require them, other than convenience of parsing.
05:17:19 <Rarrikins> Yeah, I had that too :)
05:17:38 <Rarrikins> It's nice for multiple typeclasses.
05:18:32 <Rarrikins> You don't have to add them in later if you have more than one, plus it's a consistent style.
05:19:08 <`ramses> Jafet: okay, I guess I misunderstood, I don't understand the word "perennial"
05:19:50 <Jafet> A dictionary might help there.
05:20:08 <Peaker> Rarrikins, well, that argument taken to its extreme means you need everything to have parens preemptively in case you ever extend it
05:20:11 <`ramses> Rarrikins: they are even required with multiple constraints if I'm not mistaken, and it kind of looks neat indeed
05:21:52 <Jafet> perennial, adj: 3. (figuratively) Continuing without cessation or intermission; perpetual; permanent; unceasing; never failing.
05:21:52 <`ramses> Jafet: yeah, google wasn't so helpful in this case, but that could just be me as well :)
05:22:10 <Jafet> I don't think google has a dictionary, though you can never be sure these days.
05:22:30 <`ramses> but it can take you to dictionaries
05:22:32 <Rarrikins> You can search for define:whatever
05:22:51 <Jafet> Why not go to a dictionary straight away.
05:22:51 <`ramses> anyway, I guess we can close this discussion ;)
05:23:43 <shachaf> https://encrypted.google.com/search?q=define:perennial
05:25:03 <deus_rex> Got a Parsec question, I wrote a parser which parses a string of characters which may be separated by \n; I want the parser to return the string without the \n characters though
05:25:10 <deus_rex> I wrote this, but it seems a little weird
05:25:14 <hpaste> deus_rex pasted “weird parsec parser, parse but ignore newlines” at http://hpaste.org/80007
05:25:58 <Jafet> Well, does that work?
05:26:04 <deus_rex> it does
05:26:16 <deus_rex> somethign seems strange about doing it in "two steps" though
05:26:30 <Jafet> There you go.
05:26:45 <Lethalman> is it possible to do instance Eq Something where ... where Something is a type alias and not data?
05:26:58 <ivanm> yes, but you probably shouldn't
05:27:02 <Rarrikins> Lethalman: If Something is a type, sure.
05:27:16 <Jafet> You can also make a parser that parses and discards a newline, but that seems pointless now.
05:27:18 <ivanm> if the underlying type isn't already an instance of Eq, it's better to work out why
05:27:57 <Lethalman> ivanm, I have type PArg = (String, Double) and I'd like to make it equal only on the string
05:28:02 <Jafet> You can also use one of the parsers-with-separators.
05:28:05 <shachaf> Lethalman: All it does is exapand the type alias.
05:28:11 <Lethalman> that is (s1, _) == (s2, _) = s1 == s2
05:28:16 <shachaf> You can't do that because (String, Double) already has an instance.
05:28:21 <vermeille> Hi !
05:28:44 <shachaf> type Foo = Bar is pretty much the same as #define Foo Bar
05:28:50 <vermeille> Could you help me ? I spent almost 5 days trying to understand the State Monad in vain
05:28:53 <ivanm> Lethalman: why not newtype it?
05:29:12 <ivanm> vermeille: the usual approach is to try writing it yourself
05:29:45 <Lethalman> ivanm, what's the difference with data?
05:29:49 <ivanm> starting with type State s a = s -> (a, s)
05:30:41 <ivanm> Lethalman: type just defines an alias; it's only there for documentation.  newtype is a write-time only wrapper (at runtime there's no overhead) specifically to distinguish different values, have different instances, etc.
05:30:44 <kennyd> Lethalman newtype is made to wrap existing types
05:30:49 <ivanm> and data creates a new type
05:30:56 <Lethalman> ok
05:31:04 <ivanm> in your case, you can have newtype PArg = PArg (String, Double)
05:31:09 <Lethalman> but at this point maybe data PArg = PArg String Double is better than PArg (String, Double)
05:31:16 <ivanm> yeah
05:31:24 <Lethalman> it should be a node in a graph with a label of double type
05:31:45 <ivanm> Lethalman: the other alternative is that where you're using it, you can use a function like ((==) `on` fst) rather than just ==
05:31:49 <ivanm> @type (==) `on` fst
05:31:50 <lambdabot> Eq b => (b, b1) -> (b, b1) -> Bool
05:32:33 <Lethalman> ivanm, I'd like to have a Map PArg PArgSet where PArgSet = Set PArg
05:32:34 <Jafet> I suggest PArg (String, Double), because you won't have to write any irrelevant instances.
05:32:50 <vermeille> Okay, in fact, I just have an algorithm in an imperative style, but I can't success to translate it in functional style. That's why I try to have kind of mutable states, and, if I understood correctly, the State Monad can save me
05:32:54 <ivanm> Lethalman: any particular reason for defining your own graph type?
05:33:15 <Rarrikins> vermeille: Is the algorithm very long?
05:33:19 <Lethalman> ivanm, no not really
05:33:20 <vermeille> Not at all
05:33:31 <Lethalman> ivanm, what library should I be using?
05:33:34 <vermeille> 5 or 6 lines, in imperative style
05:33:43 <deus_rex> Jafet: thanks for the help!
05:33:46 <Lethalman> ivanm, I don't need any search algorithm, just fast access to neighbors
05:33:58 <ivanm> Lethalman: there's FGL and Data.Graph in containers
05:34:07 <Lethalman> ivanm, I also need the inverse relation of edges
05:34:08 <companion_cube> Lethalman: use a map vertex -> neighbor list?
05:34:13 <vermeille> but there is three nested loops, and uses a lot of "mutability"
05:34:20 <Lethalman> companion_cube, that's what I'm doing
05:34:23 <Rarrikins> vermeille: What does it do?
05:34:41 <ivanm> Lethalman: if you're using a String as the key type, using unordered-containers rather than map is probably a better idea
05:34:46 <vermeille> Rarrikins: it solves a propositional logic theorem
05:35:06 <Lethalman> ivanm, yes nodes are labeled as string
05:35:07 <ivanm> note that both FGL and Data.Graph assume the key is Int
05:35:30 <Lethalman> assuming the key is int means I have to translate string to int and viceversa
05:35:36 <ivanm> *nod*
05:35:50 * Lethalman is unsure
05:36:02 <Jafet> Graph representations are well below the Fairbairn threshold, especially with how obtuse the hackage libraries are.
05:36:38 <vermeille> I think that if you give me the Haskell sample code doing something like `x = 41; x = x + 1` using State Monad, it could be enough
05:36:50 <Jafet> There's nothing wrong with writing one for this purpose.
05:36:53 * ivanm is working on yet another graph library, which should more easily let you have arbitrary key types
05:37:01 <Jafet> The state monad is incredibly simple.
05:37:24 <ivanm> vermeille: well, the "x + 1" bit is just: modify (+1)
05:37:25 <Jafet> > (do put 41; modify (+1)) `execState` undefined
05:37:26 <lambdabot>   42
05:37:28 <Lethalman> ivanm, FGL doesn't seem to have labels on edges
05:37:37 <ivanm> Lethalman: sure it does
05:37:37 <Lethalman> ah yes LEdge uhm
05:37:42 <Rarrikins> vermeille: I think you just write "put var", "var <- get"
05:37:47 <Lethalman> so lsuc and lpre
05:37:50 <Lethalman> is what I need
05:37:51 <Rarrikins> vermeille: On different lines in a do block.
05:38:06 <ivanm> Rarrikins: or using semicolons as Jafet demonstrated :)
05:38:18 <vermeille> Okay.
05:38:24 <ivanm> though I didn't realise you could put the do block in parens for lambdabot; I always used braces
05:38:33 <Rarrikins> vermeille: If you need more than one variable for state, you can store a tuple and use modify.
05:38:36 <Jafet> There is, in fact, no need to understand how State is implemented in order to use it.
05:38:40 <vermeille> what's the `execState` undefined stuff ?
05:38:49 * hackagebot Monaris 0.1.1.1 - A simple tetris clone  http://hackage.haskell.org/package/Monaris-0.1.1.1 (FumiakiKinoshita)
05:38:51 <ivanm> @type execState
05:38:52 <lambdabot> State s a -> s -> s
05:39:02 <ivanm> vermeille: the undefined is just to state that the initial value of the state is undefined
05:39:23 <ivanm> execState runs the State monad value by taking in the actual State monad action, an initial state and returns the final state
05:39:31 <ivanm> and discards the result from the action
05:39:44 * ivanm -> sleep
05:40:19 <vermeille> Okay, I'm gonna try it a little. Every paper I find on the state monad sounds really theoritical, there is *never* a simple sample code
05:40:44 <Jafet> Oh, so you haven't read the million blog posts on the subject...
05:40:54 <Jafet> Well, perhaps it is best not to.
05:41:42 <Jafet> Haskell can represent mutable state by having a series of functions chained together. The values that are passed through the functions represent state that is changing.
05:42:08 <Jafet> Writing chains of functions is tedious, so it is wrapped in a newtype called State. That is all.
05:43:02 <vermeille> I read a lot, but didn't success to translate this knowledge in a real world simple sample code
05:43:59 <merijn> vermeille: Did you check the Learn You a Haskell chapter discussing the State monad?
05:45:15 <vermeille> Ow. Nope. I just read articles
05:45:25 <merijn> @where lyah
05:45:25 <lambdabot> http://www.learnyouahaskell.com/
05:45:30 <vermeille> and some pages on haskell.org
05:45:33 <vermeille> thx
05:45:45 <Jafet> @where state
05:45:45 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/State/
05:45:48 <Jafet> @where State
05:45:48 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/State/
05:46:02 <merijn> vermeille: I thought the explanation was reasonably simple (it still requires a bit of playing around before things go *click*, but it should give you a starting point)
05:47:15 <Rarrikins> Why does everyone writing about the State monad assume that everyone wants to dive into the definition?
05:47:37 <merijn> Rarrikins: Because once the definition goes click, everything becomes so much simpler to understand
05:47:39 <Jafet> Because everyone does. Some just don't know it yet.
05:47:56 <merijn> Rarrikins: Otherwise things remain voodoo and you'll get confused when weird things happen
05:48:02 * Lethalman grasped the State monad concept by reading an example without monads and then the definition
05:48:49 * hackagebot tabular 0.2.2.4 - Two-dimensional data tables with rendering functions  http://hackage.haskell.org/package/tabular-0.2.2.4 (EricKow)
05:49:00 <merijn> Also, the definition of the state monad is just not that hard...
05:49:28 <edwardk> @ask startling how would such a class work?
05:49:28 <lambdabot> Consider it noted.
05:49:40 <bootcode_> the GHC doc tells that DatatypeContexts is now off by default and deprecated. Is there an alternative then? Can GADTs have context?
05:50:01 <vermeille> Okay. I start to understand. What if I want *named* instances of the Monad ?
05:50:14 <Lethalman> from this: http://www.engr.mun.ca/~theo/Misc/haskell_and_monads.htm
05:50:30 <merijn> vermeille: Oh, one minor tripping point with the LYAH example, it mentions a value constructor named "State", which, for slightly confusing reasons you shouldn't worry about now, has been removed. Instead use the function "state" wherever the LYAH chapter uses the "State" consturctor
05:50:58 <merijn> bootcode_: DatatypeContexts don't actually do anything, so you don't really need an alternative
05:51:19 <Jafet> Is there ever any reason to use the state constructor?
05:51:41 <bootcode_> merijn: so in Haskell98 datatypes can have context by default?
05:51:46 <merijn> Jafet: Sometimes, especially in trivial beginner examples
05:51:58 <merijn> bootcode_: No, it's just that *having* a context doesn't gain you anything
05:52:17 <bootcode_> merijn: Hm, good point
05:53:00 <merijn> bootcode_: You can't write "data Num a => Containter a" and then write functions "Container a -> a" where a is a Num instance. You'd still have to write "Num a => Container a -> a", even *with* the datatype context
05:53:01 <Lethalman> ok I'm reading about FGL
05:53:25 <Lethalman> and I want to define an alias type AAF = ... of a graph where labels on nodes are (String, Double) and edges are Double
05:53:53 <Lethalman> but I see class Graph gr, what's the data?
05:54:33 <Lethalman> ah PatriciaTree maybe
05:54:34 <Lethalman> Gr
05:54:37 * Lethalman still a little confused
05:54:44 <merijn> bootcode_: What did you want to use DatatypeContexts for? Or was it just curiosity?
05:55:13 <maky> how would one implement a measurement type in haskell that supports multiple units? for example Weight class where you can use both lbs and kg
05:55:32 <merijn> maky: Someone here was working on exactly that, but I forgot who
05:55:45 <bootcode_> merijn: mostly
05:55:58 <bitonic> @hackage dimensional-tf
05:55:58 <lambdabot> http://hackage.haskell.org/package/dimensional-tf
05:56:02 <bitonic> maky: ^^
05:56:17 <merijn> bootcode_: In that case it's best to just forget the extension ever existed, as I've never seen a valid reason to use it :)
05:56:54 <merijn> bootcode_: Although you should totally check out the GADTs extension if you're curious, as that one is freaking awesome :>
05:56:57 <maky> bitonic: thanks
05:58:12 <Jafet> "Please refer to the literate Haskell code for documentation of both API and implementation."
05:58:16 <Jafet> Heh
06:01:42 <vermeille> Can I deal with several State Monad instances in the same do block ?
06:02:02 <vermeille> (I'm sorry, I know that all my questions are really stupid...)
06:02:42 <Jafet> Each State only contains one state.
06:02:44 <`ramses> vermeille: how would that work?
06:03:16 <Jafet> ramses: StateT State
06:03:21 <Jafet> "yo dawg"
06:03:31 <bootcode_> vermeille: maybe you can contain them in a top-level state obj, and maybe uses lenses to modify the sub-states
06:04:14 <bootcode_> (if they are independent but related)
06:04:26 <Jafet> Fortunately the state can be anything, including an object that contains different parts of state
06:04:28 <vermeille> Okay, I mean, can't I name the Monad instances, and use them independantly ?
06:04:53 <`ramses> vermeille: I think it might be a good idea to right the code first with explicit state passing between functions (s -> (a,s)), that might clear up some details of how this works
06:04:56 <bootcode_> the monad instance is determined by the s type
06:05:01 <hiptobecubic> what's the benefit of using type families instead of functional dependencies in the dimensional-tf package?
06:05:19 <Jafet> Less confusing type errors? Who knows
06:05:27 <Jafet> @hackage dimensional
06:05:27 <lambdabot> http://hackage.haskell.org/package/dimensional
06:06:01 <shachaf> Did I ever tell you that Mrs. McKate / Had twenty-three monads, and named them all State?
06:06:03 <vermeille> something like do { let x = put 41; let y = put 665; modify (+1) x; modify (*2) y; }
06:06:25 <edwardk> hiptobecubic: you can get better 'defaulting' with type families rather than functional dependencies
06:06:41 <edwardk> we had to switch large parts of lens to TFs for that purpose
06:07:15 <hiptobecubic> 'defaulting' in what sense?
06:07:18 <shachaf> Large parts? Isn't it just Each?
06:07:37 <shachaf> Or, hmm, that was something else.
06:07:47 <shachaf> I guess you mean Fooid.
06:07:50 <edwardk> hiptobecubic: http://www.haskell.org/onlinereport/decls.html#sect4.3.4
06:08:04 <maky> I am a bit over my head trying to understand that Numerics library and it's implementation.  would newtype be a good choice for implementing different unit types? newtype Lbs = Lbs Double.  newtype Kg = Kg Double.
06:08:08 <edwardk> shachaf: we had lots of issues with iso and prism the old way if you recall
06:08:18 <shachaf> Right.
06:08:30 <edwardk> basically i spent 2 weeks trying to get defaulting working back then
06:08:32 <Jafet> I don't see the dimensional package attempting to default instances, though.
06:08:33 <bootcode_> vermeille: you can make data MySt = MySt { _x :: Int, _y :: int }, make lens for it using len's makeLenses, then: do x .= 41; y .= 665; x %= (1+); y %= (2*)
06:08:38 <edwardk> the new way is so much nicer for that ;)
06:08:50 <edwardk> x += 1; y *= 2  even
06:08:53 <Jafet> Instead, you need to explicitly convert numbers to dimensionless dimensional numbers.
06:09:07 <bitonic> maky: you can use the same newtype for both with different type parameters as tags, see <https://github.com/bjornbm/dimensional-tf/blob/master/Numeric/Units/Dimensional/TF.lhs>
06:09:11 <bootcode_> edwardk: oh, indeed. was translating literally
06:09:15 <bitonic> it’s actually well documented
06:09:45 <shachaf> maky: Note that that might not give you quite the behavior you're hoping for.
06:09:55 <vermeille> Okaaaaay, bootcode_ edwardk seems *very* interesting
06:09:57 <hiptobecubic> edwardk, i see. thanks
06:10:02 <shachaf> For example it'll give you (x :: Kg) * (y :: Kg) :: Kg
06:10:10 <shachaf> (If you use Num.)
06:11:02 <edwardk> Jafet: its more that the arg to things like Dimension v d a    can often be defaulted in places where it can't be in base dimensional.
06:13:49 * hackagebot cabal2ghci 0.0.1.0 - A tool to generate .ghci file from .cabal  http://hackage.haskell.org/package/cabal2ghci-0.0.1.0 (HiromiIshii)
06:13:51 <Jafet> You can't easily default v, d with fundeps?
06:14:03 <bootcode_> vermeille: you could achieve the same w/ sg like: modify (\myst -> myst { _x = _x myst + 1} ) instead of x += 1, but lenses spares you these kind of boilerplate
06:14:50 <vermeille> I'm reading documentation about lenses :)
06:16:26 <bootcode_> vermeille: edwardk had a nice lens video (although for Scala) which was for me a bit more understandable at first, but ymmv
06:16:33 <Rarrikins> Lenses help you see better!
06:17:33 <Jafet> lens isn't relevant at this point; it can come later. Unless there is somehow a State or ST wrapper for lens.
06:19:44 <roconnor> I will sometimes be using whitespace to avoid parentheses:
06:19:45 <roconnor>     print
06:19:46 <roconnor>       addOne 1
06:19:50 <roconnor> -- http://tailcalled.wordpress.com/2012/12/31/on-types-functional-programming-and-monads/
06:19:55 <roconnor> I had no idea you could do that!!
06:20:37 <Rarrikins> O-o
06:20:41 <Rarrikins> I didn't either
06:21:12 <Jafet> Another referral to the Society of Lisp Therapists.
06:21:26 <Rarrikins> Haha
06:22:07 <Saizan> does it actally work? or is it just a shorthand he's using for the blog?
06:22:16 <roconnor> let me try it
06:23:03 <Jafet> It parses as (print addOne 1).
06:23:10 <roconnor> ah poo
06:23:31 <roconnor> well at least that explains why I've never seen it.
06:24:22 <edwardk> bootcode_: i did a video on the new lens library too
06:24:31 <Jafet> Yes, if something is incorrect then it should not be seen often.
06:24:33 <edwardk> bootcode_: https://www.youtube.com/watch?v=cefnmjtAolY&hd=1
06:24:48 <derdon> I find it pretty strange that there is no builtin split function for String
06:24:54 <Jafet> But every now and then there is the function that insists on taking the longest argument first
06:24:57 <Jafet> Like map
06:25:20 <maky> bitonic: is dimensional-tf successor of dimensional (no tf)?
06:25:50 <Jafet> If you want to split strings, you most likely want to use Text.
06:27:15 <derdon> Jafet: I have a String and want to split it by a given Char. Which function is it?
06:27:57 <edwardk>  derdon : should it treat runs of the split character as one, should it take a list of them? should it take multicharacter splits? etc
06:28:03 <Jafet> It is... the function that splits a String by a given Char.
06:28:15 <Jafet> Or a function, as edwardk points out.
06:28:29 <mel-> hi
06:28:33 <edwardk> derdon: we have the split package which provides for all these usecases
06:28:46 <derdon> edwardk: and it's 3rd party
06:28:48 <edwardk> but since there isn't a good single canonical choice for them we tend not to provide it in base.
06:29:07 <edwardk> derdon: it is, but its also in the platform now so you can rely on it being installed going forward
06:29:19 <mel-> i know how to compose two functions, but, given a function f, how can i form f^n?
06:29:31 <edwardk> and on the fact that the api won't change radically any time soon
06:29:59 <bitonic> maky: yes, one works with fundeps, the other with type families, iirc.  gotta go, good luck!
06:30:01 <mel-> (which is supposed to be b times f . f . [...] . f )
06:30:08 <k00mi> span is in prelude and does what derdon wants, doesn't it?
06:30:16 <derdon> k00mi: no, it doesn't
06:30:23 <k00mi> ok
06:30:27 <derdon> k00mi: span returns a tuple of two things
06:30:42 <derdon> k00mi: I need [String] as return type
06:30:50 <k00mi> oh i see
06:31:08 <Jafet> > iterate f x
06:31:08 <chreekat> mel-: "(^n) . f" i believe
06:31:10 <lambdabot>   [x,f x,f (f x),f (f (f x)),f (f (f (f x))),f (f (f (f (f x)))),f (f (f (f (...
06:31:22 <Jafet> > iterate f x !! 5
06:31:24 <lambdabot>   f (f (f (f (f x))))
06:31:35 <chreekat> oh, I misunderstood
06:31:56 <mel-> aaaaah
06:32:02 <mel-> nice, thanks!
06:33:31 <bootcode_> edwardk: great, thx for the video
06:35:02 <edwardk> derdon you can write it as a 2-3 liner with unfoldr and span
06:35:32 <Jafet> It would be useful if infixOf didn't just return Bool.
06:35:58 <Jafet> "What is the lens brigade doing about THIS?"
06:36:24 <edwardk> Jafet: out of scope =P
06:36:47 <Jafet> No substring traversals?
06:37:12 <edwardk> its more that we tend to make existing things bidrectional
06:46:30 <Lethalman> i'm using fgl, and as label for nodes I have (String, Double)
06:46:49 <chrisdone> wait, what's the channel for lens
06:46:49 <Lethalman> but the real label is the string, while the double is some value associated to the node
06:46:59 <edwardk> #haskell-lens
06:47:03 <chrisdone> ah, cheers
06:47:37 <Lethalman> is there some particular why to use String as real label instead of always looking up the double value?
06:48:03 <Lethalman> like I want to provide graphs with edges "a","b" but I have to also specify the double value which is redundant
06:51:03 <Saizan> keep a separate Map String Double mappings
06:51:32 <hpaste> Subtrain pasted “structural induction” at http://hpaste.org/80010
06:53:07 <Subtrain> I want to ask if somebody could explain me how to do a structural induction on this example please: http://hpaste.org/80010
06:53:12 <aavogt> keeping a separate Map means there's a chance for unused (String,Double) to stick around
06:53:45 <Lethalman> Saizan, this is what I'm doing now: http://paste.debian.net/220562/
06:54:26 <Lethalman> probably I can keep this as is, I believe the only place where I need only the string is the construction of the graph
06:54:46 <Lethalman> the graph is small
06:55:02 <Subtrain> I know that the first step is about the empty list and the actual induction step ist (x:xs)
06:55:15 <Lethalman> is what I wrote something good or bad haskell? :P
06:55:18 <EarlGray1> Hello. Is there an idiomatic way to handle large binary structures in Haskell? I mean, using Data.Binary, I have a lot of ugly and imperative `getWord32le` calls, is there a way to describe a binary layout more declaratively?
06:57:00 <Lethalman> that is maybe there is something clever to define a PrAF from an AAF by adding Double to both nodes and edges?
07:08:15 <Subtrain> can somebody explain to me how to make a structural induction on this example? http://hpaste.org/80010
07:11:30 <vermeille> Lenses looks like overkill for what I want to achieve
07:11:54 <edwardk> probably - they do a lot
07:12:03 <vermeille> http://aima.cs.berkeley.edu/lisp/logic/algorithms/fol.lisp I want to code in Haskell the prove-by-refutation algorithm
07:12:28 <vermeille> but there is some push, pop, setf, and foreach
07:14:05 <vermeille> It should be at most 20 lines of code. I spent 4 days trying in vain \o/
07:14:54 <vermeille> Haskell is really hard to learn, in my point of view :(
07:15:19 <Subtrain> can nobody explain how to do that?
07:16:28 <Subtrain> http://hpaste.org/80010
07:16:29 <ion> vermeille: Compared to what?
07:16:39 <TheGreekBrit> Literally anything else
07:16:41 <TheGreekBrit> Haha
07:17:42 <vermeille> Haha, yes x)
07:17:47 <`ramses> vermeille: maybe you're trying too hard to port the specifics of that implementation. Have you tried understanding at a high level how the algorithm works and then writing that high level idea down in haskell?
07:18:12 <Saizan> Subtrain: you have to show that it's true for xs = [] and for xs = (y:ys) given that it's true for xs = ys
07:18:32 <vermeille> `ramses: yes, I make you a pastebin. The algorithm is really simple
07:19:45 <`ramses> vermeille: don't use the lisp syntax please, I hate matching those parens :)
07:19:51 <ion> “Anything else” sounds like you have learned a number of languages and are comparing the learning of Haskell to the learning of some other language that was very similar to the ones you already knew. :-P
07:20:23 <ion> Yes, learning a different kind of a language will take more effort than learning yet another CLispScript.
07:20:57 <vermeille> OCaml were simpler to learn
07:22:23 <TheGreekBrit> I am saying it like that, ion
07:22:25 <Subtrain> @Saizan I know that I need to show that but my problem is how to do that ^^
07:22:25 <lambdabot> Unknown command, try @list
07:23:09 <Subtrain> at Saizan I know that I need to show that but my problem is how to do that ^^
07:23:22 <`ramses> Subtrain: that's really an exercise in writing down a prove, isn't it?
07:23:29 <TheGreekBrit> Though that's coming from someone whose first experience with functional programming was Haskell
07:23:36 <`ramses> can you show it for [] ?
07:24:10 <Saizan> Subtrain: just use the definitions
07:24:15 <watermind> trying to install vacuum cairo I'm getting,  "setup: The pkg-config package librsvg-2.0 version >=2.16.0 is required but it could not be found."
07:24:20 <watermind> is this a missing package
07:24:20 <vermeille> http://pastebin.com/5g7vBSxD `ramses
07:24:31 <watermind> or something I should install externally in my linux distro?
07:24:37 <mauke> The paste 5g7vBSxD has been copied to http://hpaste.org/80011
07:24:46 <aavogt> watermind: the latter
07:24:49 <HugoDaniel> how can i transform f :: a -> a -> a -> a -> b into f :: (a,a,a,a) -> b ?
07:24:55 <watermind> thank you aavogt
07:25:01 <Saizan> HugoDaniel: by hand
07:25:16 <HugoDaniel> isnt' there a special function that does it for me ? :D
07:25:18 <vermeille> Hell, I master C++ template metaprogramming, I read Modern C++ Design, and I feel like a stupid guy when doing Haskell >_<
07:25:22 <Saizan> ?type uncurry3
07:25:24 <lambdabot>     Not in scope: `uncurry3'
07:25:24 <lambdabot>     Perhaps you meant `uncurry' (imported from Data.Tuple)
07:25:29 <Rarrikins> HugoDaniel: zomg f (a, b, c, d) = f a b c d ... then, zomgify f.
07:25:42 <HugoDaniel> :D
07:25:49 <HugoDaniel> okey, meh
07:26:04 <Rarrikins> hughfdjackson: Or there might be an uncurry3 or something, like Saizan indicates.
07:26:29 <Saizan> i don't think it reaches 4
07:26:41 <Saizan> btw 4-tuples are evil
07:26:51 <hughfdjackson> Rarrikins: ;) i think you meant  mr daniel
07:27:04 <Subtrain> at Saizan and ramses can you not explain to me how I do that and why it must be that way this would help me on an educational way.  :-/
07:27:07 <Taneb> I have a ridiculous idea for a type
07:27:08 <watermind> aavogt: I actually have version 2.34 installed which is >= 2.16 as required :S
07:27:14 <Rarrikins> hughfdjackson: Ahh, yes, sorry :)
07:27:16 <HugoDaniel> :D
07:27:18 <Taneb> newtype Ridiculous p a b = Ridiculous b
07:27:19 <Fuuzetsu> How can I have something like main = do {map (forkIO . someIOAction) [someList]} not kill the main thread before all the forked threads terminate? Is there a good guide on this? The pages I found just pretty much go `just stick forkIO in front of it'
07:27:25 <aavogt> watermind: and that's a -dev package?
07:27:35 <watermind> aavogt: ah good point
07:27:47 <Taneb> instance (Reifies p (b -> a), Eq a) => Eq (Ridiculous p a b)
07:27:52 <HugoDaniel> all haskell code should live inside a Pascal a datatype
07:28:03 <Taneb> instance (Reifies p (b -> a), Ord a) => Ord (Ridiculous p a b)
07:28:06 <Taneb> Is this possible?
07:28:07 <HugoDaniel> that would be the pascal language
07:28:12 <`ramses> Subtrain: try replacing statements with their definitions and use what is given. Have you been able to show it for [] ? That would be the first step
07:28:28 <aavogt> HugoDaniel: there's this: http://hackage.haskell.org/packages/archive/tuple/0.1.0.0/doc/html/src/Data-Tuple-Curry.html
07:28:58 <watermind> aavogt: yay, thanks, I was missing the dev package indeed
07:29:28 <Saizan> Taneb: i think so
07:29:38 <`ramses> vermeille: personally, I'd try to describe the algorithm at an even higher level, almost text, and then think how I could implement that in a functional way. You're still pretty close to the imperative implementation now
07:30:41 <`ramses> think about the problem in terms of data transformations
07:31:06 <HugoDaniel> thanks aavogt
07:31:39 <aavogt> it seems like Data.Tuple.Curry.Curry should have the 'r' parameter as a another parameter to the typeclass
07:32:32 <aavogt> since it should be possible to have:      :t curryN (\a b c d -> a+b+c+d :: Int)
07:32:42 <aavogt> claim the result is an Int
07:33:33 <vermeille> `ramses: Okay, let's try it immediately. But, from a learning point of view, is there any way to have the Haskell code look like this one ?
07:33:43 <vermeille> Just curiosity.
07:34:42 <Saizan> vermeille: you could use mutable data structures
07:36:02 <`ramses> vermeille: that's certainly possible, but mostly not desirable. If you want to write down an imperative algorithm, I'd use an imperative language :)
07:36:27 <`ramses> (some will argue that haskell can be an imperative language as well :) )
07:36:53 <vermeille> Yes. Obviously. But, like in this case, pattern matching is really good to deal with tree structures
07:37:14 <vermeille> So, using Haskell to manipulate a propositional logic sentence AST was really fine
07:38:25 <Saizan> haskell is a very fine imperative language too
07:38:27 <`ramses> for this argument, I'd try a recursive approach in which you pass the "new" and "clauses" collections along and create the new ones for the next call at each step
07:38:37 <ion> Haskell is a better imperative language than most others thanks first-class IO actions.
07:38:38 <`ramses> s/argument/problem
07:38:51 <Rarrikins> Haskell! Haskell! Haskell!
07:39:24 <`ramses> then, you could later on replace this state passing with a state monad. But I'd start with explicit passing if you're not too familiar with State
07:39:37 <vermeille> not at all
07:42:18 * cmccann would be tempted to describe Haskell as a "hybrid functional/imperative" language if a handful of imperative things were slightly more convenient
07:42:51 <aavogt> if only Data.Dynamic was less useless
07:43:21 * `nand` pokes in to paste https://github.com/mmirman/ImperativeHaskell/blob/master/Main.hs yet again
07:44:21 <shachaf> I don't think cmccann is talking about cute syntactic tricks so much as actual imperativeish code that you might write.
07:44:40 <shachaf> It tends to be pretty awkward.
07:44:42 <cmccann> there's a subtle distinction between syntactic tricks and actual code.
07:44:57 <`nand`> oh, this was not necessarily in response to cmccann
07:45:05 <cmccann> if syntactic tricks reduce the amount of hassle needed to write code for certain tasks, that's important
07:45:21 <shachaf> That's true.
07:45:30 <`nand`> isn't the entire lens library just a syntactic hack
07:45:44 <shachaf> How dare you! It's a semantic hack!
07:45:58 <fetter_oml> good evening dear gentlemen. I want to convert an int \in {0..255} to an Word8, but Im not quite sure how to do that, and some searching didnt help
07:46:04 <`nand`> fromIntegral
07:46:23 <fetter_oml> http://www.haskell.org/ghc/docs/7.4.2/html/libraries/base/Data-Word.html that wasnt particularly helpful, as was stackoverflow
07:46:23 <aavogt> @hoogle Int -> Word8
07:46:23 <lambdabot> Data.ByteString index :: ByteString -> Int -> Word8
07:46:23 <lambdabot> Data.ByteString.Unsafe unsafeIndex :: ByteString -> Int -> Word8
07:46:23 <lambdabot> Prelude (!!) :: [a] -> Int -> a
07:46:30 <ChrisDornan> I am considering using a hybrid of Haskell/Ruby for a project (Ruby calling out to Haskell)
07:46:32 <`nand`> well that search didn't go as expected
07:46:46 <sp3ctum> hehe
07:47:02 <cmccann> lens is actually a good example, because using IORef-style references as pointers for imperative algorithms is much clumsier than what you can do with lenses as pure references
07:47:06 * `nand` .oO( except for the third option. (!!) [0..255 :: Word8] )
07:48:03 <edwardk> :t fromIntegral
07:48:04 <lambdabot> (Integral a, Num b) => a -> b
07:48:06 <shachaf> cmccann: I've tried figuring out how you might make good lenses for things like IORefs.
07:48:14 <edwardk> likewise
07:48:17 <shachaf> I didn't end up with anything particularly nice.
07:48:25 <aavogt> in the whole list hoogle gives is also toEnum
07:48:27 <ChrisDornan> Anybody any recent experience of developing Ruby&Haskell and can recommend any  tools/frameworks? (Have been looking at Hubris.)
07:48:27 <cmccann> yeah.
07:48:30 <fetter_oml> nand: thanks very much, but im not sure how fromIntegral realises which wordX it should convert to o.O
07:48:33 <hpaste> DavidT pasted “For pointfree” at http://hpaste.org/80012
07:48:50 <xlr> is there a way to do > filter (\x -> 3<length x) [[1..5],[1..2]] without a lambda? I think there might be because the x only occurs at the right of the expression
07:49:17 <`nand`> fetter_oml: either it's inferred from context, or you give it a type annotation
07:49:19 <cmccann> but it would be nice (for "imperative programming") is something as handy as lens existed that did support IORef &al.
07:49:23 <ion> (3<) . length
07:49:25 <DavidT> http://hpaste.org/80012 <- DAK if there is a neat way to write that pointfree using the combinators in applicative, say? I've been trying various ideas for a good half an hour without luck
07:49:56 <`nand`> > fromIntegral 127 :: Word8
07:49:57 <lambdabot>   127
07:49:57 <ion> go <$> e1 <*> e2 <*> e3 <*> e4 or liftA4 go e1 e2 e3 e4
07:50:00 <fetter_oml> nand: ok, thank you very much :)
07:50:05 <`nand`> > fromIntegral 2000 :: Word16
07:50:07 <lambdabot>   2000
07:50:08 <`nand`> > fromIntegral 2000 :: Word8
07:50:09 <lambdabot>   208
07:50:52 <xlr> oh i wasn't bracketing, thanks ion
07:51:21 <`nand`> @pl \x -> 3 < length x
07:51:21 <lambdabot> (3 <) . length
07:51:24 <`nand`> look, automagic
07:52:56 <vermeille> wtf
07:52:59 <DavidT> ion: Doesn't seem to work for me, hangon...
07:53:01 <vermeille> Looks too easy to be true
07:53:03 <Fuuzetsu> DavidT: you can use @undo and @pl
07:53:16 <`ramses> xlr: watch out with "x appears on the right" because what you probably mean is that you've got something like "f x = g x <==> f = g" but this does not work if the x is in parentheses like in your example, which is like "f x = h (g x))". Any expression can be written point-free though :)
07:53:56 <DavidT> Fuuzetsu: what are they?
07:54:00 <ion> davidt: Sorry, i read the original a bit too hastily.
07:54:06 <vermeille> `ramses: I think aI have to thank you a LOT
07:54:15 <ion> join (go <$> e1 <*> e2 <*> e3 <*> e4) or join (liftA4 go e1 e2 e3 e4) should work.
07:54:20 <mikeplus64> @src liftA4
07:54:20 <lambdabot> Source not found. My mind is going. I can feel it.
07:54:20 <`ramses> vermeille: did it work out? :)
07:54:22 <Fuuzetsu> @undo result = runST $ do {a <- mon1; b <- mon2; c <- mon3; d <- mon4; go a b c d}
07:54:22 <lambdabot> result = runST $ mon1 >>= \ a -> mon2 >>= \ b -> mon3 >>= \ c -> mon4 >>= \ d -> go a b c d
07:54:38 <Fuuzetsu> @pl  result = runST $ mon1 >>= \ a -> mon2 >>= \ b -> mon3 >>= \ c -> mon4 >>= \ d -> go a b c d
07:54:38 <lambdabot> result = runST ((mon2 >>=) . (((mon3 >>=) . ((mon4 >>=) .)) .) . go =<< mon1)
07:54:43 <vermeille> `ramses: still not implemented. But on the paper, it seems to work :D
07:55:06 <DavidT> ion: I see, that would work if the last line were return $ go a b c d (your first answer)
07:55:13 <DavidT> join, right
07:55:20 <DavidT> Fuuzetsu: Mmm, pretty
07:55:21 <DavidT> :)
07:55:40 <ion> I think (go =<< e1) <*> e2 <*> e3 <*> e4 would also work.
07:55:48 <vermeille> Given two lists, how do you check if one is a subset of the other ?
07:55:51 <hpaste> Subtrain pasted “structural induction” at http://hpaste.org/80013
07:56:29 <Fuuzetsu> vermeille: isInfixOf?
07:56:53 <Fuuzetsu> > [2, 3] `isInfixOf` [1..10]
07:56:55 <lambdabot>   True
07:56:59 <vermeille> perfect :D
07:57:16 <Fuuzetsu> @hoogle [a] -> [a] -> Bool
07:57:16 <lambdabot> Data.List isInfixOf :: Eq a => [a] -> [a] -> Bool
07:57:16 <lambdabot> Data.List isPrefixOf :: Eq a => [a] -> [a] -> Bool
07:57:17 <lambdabot> Data.List isSuffixOf :: Eq a => [a] -> [a] -> Bool
07:57:18 <Subtrain> at ramses http://hpaste.org/80013
07:57:23 <DavidT> ion: The one with join is spot on, thanks
07:57:35 <vermeille> Okay, and for two lists of lists ?
07:57:45 <vermeille> Hoogle bookmarked.
07:58:02 <Fuuzetsu> Uhm, the same? Can you give an example?
07:58:08 <ion> let bind4 f a b c d = join (liftM4 f a b c d)
07:58:21 <Rarrikins> @src isInfixOf
07:58:21 <lambdabot> isInfixOf needle haystack = any (isPrefixOf needle) (tails haystack)
07:58:43 <Rarrikins> > [2, 3] `isInfixOf` [1,3,2,4]
07:58:45 <lambdabot>   False
07:59:12 <Rarrikins> > all (flip elem [1, 3, 2, 4]) [2, 3]
07:59:13 <lambdabot>   True
07:59:38 <Subtrain> oh ramses is not online anymore hmm can somebody tell me if the first step is right? http://hpaste.org/80013
08:00:01 <`ramses> Subtrain: what makes you think that :)
08:00:06 <vermeille> [[1..3],[4..7],[8..10]] contains? [[7, 4, 5, 6], [2, 3, 1]]
08:00:10 <vermeille> should be True
08:00:37 <Subtrain> oh ^^ ok than ramses could you tell me if I did that correct? please
08:00:42 <Fuuzetsu> I don't see how that would be true; the ordering is different
08:01:16 <Fuuzetsu> :t fmap
08:01:17 <lambdabot> Functor f => (a -> b) -> f a -> f b
08:01:43 <vermeille> Also Fuuzetsu , isInfixOf seems to check for a sub*sequence*, where I am looking for a sub*set*
08:01:49 <`ramses> Subtrain: looks ok
08:01:54 <Rarrikins> > let zomg xs ys = all (elem . map sort $ ys) . map sort $ ys in zomg [[1..3],[4..7],[8..10]] [[7, 4, 5, 6], [2, 3, 1]]
08:01:55 <lambdabot>   Occurs check: cannot construct the infinite type: a0 = [[a0]]
08:02:04 <Rarrikins> > let zomg ys xs = all (elem . map sort $ ys) . map sort $ ys in zomg [[1..3],[4..7],[8..10]] [[7, 4, 5, 6], [2, 3, 1]]
08:02:05 <lambdabot>   Occurs check: cannot construct the infinite type: a0 = [[a0]]
08:02:12 <`ramses> vermeille: maybe sort the lists first then
08:02:22 <Rarrikins> > let zomg ys xs = all (elem . map sort $ xs) . map sort $ ys in zomg [[1..3],[4..7],[8..10]] [[7, 4, 5, 6], [2, 3, 1]]
08:02:23 <lambdabot>   No instance for (GHC.Enum.Enum [[a0]])
08:02:23 <lambdabot>    arising from the arithmetic seque...
08:02:27 <vermeille> Could be an idea.
08:03:01 <Rarrikins> @hoogle a -> [a] -> Bool
08:03:01 <lambdabot> Prelude elem :: Eq a => a -> [a] -> Bool
08:03:01 <lambdabot> Data.List elem :: Eq a => a -> [a] -> Bool
08:03:01 <lambdabot> Prelude notElem :: Eq a => a -> [a] -> Bool
08:04:53 <Fuuzetsu> > (map (isInfixOf.sort) [[1..3],[4..7],[8..10]]) <*> map sort [[7, 4, 5, 6], [2, 3, 1]]
08:04:55 <lambdabot>   [False,True,True,False,False,False]
08:05:19 <Fuuzetsu> > True `elem` (map (isInfixOf.sort) [[1..3],[4..7],[8..10]]) <*> map sort [[7, 4, 5, 6], [2, 3, 1]]
08:05:21 <lambdabot>   Precedence parsing error
08:05:21 <lambdabot>      cannot mix `GHC.List.elem' [infix 4] and `Con...
08:05:24 <Fuuzetsu> uh
08:05:34 <Fuuzetsu> > True `elem` ((map (isInfixOf.sort) [[1..3],[4..7],[8..10]]) <*> map sort [[7, 4, 5, 6], [2, 3, 1]])
08:05:36 <lambdabot>   True
08:05:47 <Fuuzetsu> I think that works... First try as well
08:06:22 <vermeille> O_O
08:06:31 <Rarrikins> > let zomg xs ys = all (flip elem . map sort $ xs) . map sort $ ys in zomg [[1..3],[4..7],[8..10]] [[7, 4, 5, 6], [2, 3, 1]]
08:06:33 <lambdabot>   True
08:06:38 <Fuuzetsu> You should probably use a set though.
08:06:46 <vermeille> I understand it, but I never will be able to write such things O_O
08:07:02 <Rarrikins> vermeille: One thing, though: isInfixOf only works for sorted lists.
08:07:18 <Rarrikins> vermeille: And it also only works for consecutive elements.
08:07:21 <Fuuzetsu> vermeille: <*> is in LYAH; I'm very inexperienced with Haskell but I managed to conjure such monstrosity
08:07:33 <Rarrikins> > [2,4] `isInfixOf` [1..5]
08:07:34 <lambdabot>   False
08:07:58 <Fuuzetsu> @hoogle [a] -> Set a
08:07:58 <lambdabot> Data.Set fromDistinctAscList :: [a] -> Set a
08:07:58 <lambdabot> Data.Set fromList :: Ord a => [a] -> Set a
08:07:58 <lambdabot> Data.Set fromAscList :: Eq a => [a] -> Set a
08:08:04 <Rarrikins> > [2, 4] `flip elem` [1..5]
08:08:05 <lambdabot>   <hint>:1:14: parse error on input `elem'
08:08:09 <Rarrikins> Bah
08:08:33 <Lethalman> ha! looks like for converting a java code I need the random monad
08:08:47 <Fuuzetsu> @hoogle Set a -> Set a -> Bool
08:08:47 <lambdabot> Data.Set isProperSubsetOf :: Ord a => Set a -> Set a -> Bool
08:08:47 <lambdabot> Data.Set isSubsetOf :: Ord a => Set a -> Set a -> Bool
08:08:47 <lambdabot> Data.Set member :: Ord a => a -> Set a -> Bool
08:08:49 <Lethalman> because I'd have to pass the StdGen everytime to functions
08:08:56 <Fuuzetsu> there you go, written for you
08:08:58 <Lethalman> for doing a monte carlo simulation
08:09:07 <Rarrikins> > let xs `isSubsetOf` ys = all (flip elem ys) xs in [2,4] `isSubsetOf` [1..5]
08:09:08 <lambdabot>   True
08:09:18 <Lethalman> and I'm very scared to use a monad outside of IO :P
08:09:45 <Rarrikins> vermeille: I'd strongly recommend using "xs `isSubsetOf` ys = all (flip elem ys) xs" instead of isInfixOf.
08:10:17 <Fuuzetsu> :t all
08:10:19 <lambdabot> (a -> Bool) -> [a] -> Bool
08:10:38 <EvanR> Lethalman: no way dude, monads are way nicer without IO ;)
08:10:46 <Rarrikins> @let xs `isSubsetOf` ys = all (flip elem ys) xs
08:10:47 <lambdabot>  Defined.
08:11:08 <Lethalman> EvanR, I believe that, but I'm still scared :P
08:11:18 <tgeeky> > isSubsetOf [1,2,3] [1,2]
08:11:18 <Fuuzetsu> @src Data.Set.isSubsetOf
08:11:18 <lambdabot> Source not found.
08:11:20 <lambdabot>   False
08:11:24 <Lethalman> let me show you
08:11:26 <Fuuzetsu> @src isSubsetOf
08:11:26 <lambdabot> Source not found. It can only be attributed to human error.
08:11:29 <tgeeky> > isSubsetOf [1,2,3] [1,2,3]
08:11:30 <Fuuzetsu> sigh
08:11:31 <lambdabot>   True
08:11:34 <tgeeky> > isSubsetOf [1,2] [1,2,3]
08:11:36 <lambdabot>   True
08:11:38 <Rarrikins> > map sort [[7, 4, 5, 6], [2, 3, 1]] `isSubsetOf` map sort [[1..3],[4..7],[8..10]]
08:11:40 <lambdabot>   True
08:11:52 <Rarrikins> Fuuzetsu: xs `isSubsetOf` ys = all (flip elem ys) xs
08:12:06 <Fuuzetsu> Rarrikins: Is that the one from Data.Set?
08:12:14 <Rarrikins> Fuuzetsu: No, one I made up.
08:12:21 <EvanR> Lethalman: what kind of monad are you looking at
08:12:29 <Lethalman> EvanR, http://hackage.haskell.org/packages/archive/MonadRandom/0.1.3/doc/html/Control-Monad-Random.html
08:12:30 <Fuuzetsu> Also, why not just use sets? It will save the overhead of sorting (although I don't know how fast the sets are)
08:12:40 <Rarrikins> Fuuzetsu: Yeah, that's a better idea.
08:12:42 <EvanR> random monad is nice
08:12:49 <Lethalman> EvanR, this is my code: http://paste.debian.net/220585/
08:12:57 <Fuuzetsu> O(n+m). Is this a subset? (s1 isSubsetOf s2) tells whether s1 is a subset of s2.
08:13:12 <Lethalman> EvanR, that "sample" function gets a graph with probabilities and induces a graph out of it without probabilities
08:13:25 <Lethalman> EvanR, genRandoms generates an infinite list of randoms from a seed
08:13:52 <Lethalman> EvanR, of course you get the problem, I want to call sample repeatedly and thus I have to return the StdGen after the first sample, and so on
08:14:02 <Lethalman> so I believe I want that monad to keep track of the current generator
08:14:32 <b52> is it possible for a type to define a class instance?
08:14:42 <b52> or do i have to use at least newtype/data ?
08:16:39 <byorgey> b52: you can do it if you enable the  TypeSynonymInstances  extension
08:17:02 <byorgey> b52: note, however, that if  type S = T, you cannot have two different instances for S and T
08:17:09 <byorgey> for that you need a newtype
08:17:43 <b52> so i can't create an Ord instance for my type Foo = [Int] ?
08:17:54 <byorgey> TypeSynonymInstances is really just for convenience, to make the instance read better (e.g. to be able to say  instance Foo String   instead of  instance Foo [Char])
08:18:00 <byorgey> b52: no, you can't
08:18:05 <byorgey> you need a newtype for that
08:18:07 <b52> damn it
08:18:24 <Lethalman> EvanR, so my sample function should be (RandomGen g) => PrAF -> Rand g AAF right?
08:18:40 <byorgey> but if your Foo type really has a different Ord instance than [Int], then it is really a different type, and you should be glad of the compiler's help keeping them separate!
08:19:02 <byorgey> you wouldn't want to accidentally pass an [Int] where a Foo is expected, and vice versa.
08:20:13 <b52> but using a newtype i need this additional un/boxing code
08:21:10 <byorgey> yep
08:21:36 <byorgey> that's the price you have to pay for the compiler's help keeping the two types separate
08:21:49 <byorgey> I am arguing that it is a good tradeoff.
08:21:50 <b52> well, maybe i can solve my problem in another way
08:22:06 <byorgey> b52: also, take a look at the 'newtype' package, which has some tools for making it easier
08:22:39 <b52> is there a fast library which provides a sorted list and keeps it sorted?
08:23:06 <b52> by supplying a custom function which determines the ordering?
08:23:08 <elliott> lens has all the functionality of newtype now, btw
08:23:17 <byorgey> elliott: oh, does it? nice
08:23:21 <elliott> and more instances by default
08:23:29 <byorgey> b52: not that I know of
08:23:33 <edwardk> byorgey: ala is now effectively newtype's ala, we renamed the one that used an iso to 'au'
08:23:37 <elliott> byorgey: it's built on top of the Iso machinery
08:23:39 <edwardk> 'Wrapped' is our Newtype
08:23:46 <edwardk> :t ala
08:23:47 <lambdabot> Wrapped s s a a => (s -> a) -> ((s -> a) -> e -> a) -> e -> s
08:23:51 <edwardk> :t ala Sum
08:23:53 <lambdabot> ((s -> Sum s) -> e -> Sum s) -> e -> s
08:23:55 <edwardk> :t ala Sum foldMap
08:23:56 <lambdabot> (Num s, Foldable t) => t s -> s
08:24:02 <tgeeky> you updated lambdabot too? <3
08:24:03 <edwardk> :t au (wrapping Sum)
08:24:05 <lambdabot> ((t -> Sum t) -> e -> Sum t) -> e -> t
08:24:14 <byorgey> b52: if I wanted to do that, I would make a newtype and keep it in a Data.Set
08:24:21 <byorgey> edwardk, elliott: cool!
08:24:32 <byorgey> and can I lift two-argument functions over newtypes?
08:24:36 <tgeeky> edwardk: make the phrase "potatoes au gratin" mean something :o
08:24:58 <tgeeky> in lambdabot, that is
08:25:07 <edwardk> byorgey: interestingly the use of lens makes this a nice generalized form, because you can use the family structure
08:25:26 <byorgey> "the family structure"?
08:25:41 <tgeeky> the multiplate stuff?
08:26:04 <edwardk> you can put something in in a newtype and get it out with another. wrapped :: Iso a  b (Sum a) (Sum b)
08:26:07 <edwardk> for instance
08:26:17 <b52> byorgey: that was basically the idea that i had in mind
08:27:03 <edwardk> au :: AnIso s t a b -> ((s -> a) -> e -> b) -> e -> t
08:27:10 <edwardk> :t au (wrappings Sum Sum)
08:27:11 <lambdabot> ((s -> Sum s) -> e -> Sum t) -> e -> t
08:27:19 <edwardk> notice the Sum s and Sum t?
08:27:20 <elliott> hm, I guess there could be an Applicative for newtype unwrappings
08:27:48 <byorgey> edwardk: yeah, so what does that do?
08:28:32 * byorgey has discovered that he cannot intuitively comprehend any type with rank greater than 1.
08:29:38 <byorgey> I guess for the same reason it's difficult to intuitively grasp the meaning of sentences involving double (or more) negation
08:29:52 * elliott finds rank-2 types easy enough
08:29:54 <byorgey> stupid brains
08:29:55 <elliott> rank-3, OTOH...
08:29:57 <tgeeky> That doesn't not sound limiting.
08:30:07 <byorgey> see?
08:30:12 <edwardk> byorgey: terrible example
08:30:15 <byorgey> that took me a few seconds.
08:30:15 <edwardk> > runIdentity $ under (wrappings Identity Identity) (+1) (Identity 2)
08:30:17 <lambdabot>   3
08:30:30 <tgeeky> edwardk++
08:30:36 <edwardk> elliott: callCC is rank 3 done right
08:30:44 <byorgey> edwardk: agreed, that is a terrible example =)
08:30:57 <Subtrain> at ramses and now the next step is (x:xs) just fill in the definitions again?
08:31:06 <edwardk> i don't have a good use for the extra flexibility. it just arose when working on it
08:31:07 <elliott> edwardk: yeah and it takes me a few seconds to understand that form :P
08:31:41 <byorgey> edwardk: oh, so  under (wrappings Foo Bar) f  means to take off the Foo, apply f, then put back on a Bar?
08:32:09 <`ramses> Subtrain: yes, and use the fact that you know that the proposition is true for xs
08:32:12 <byorgey> (or maybe vice versa)?
08:32:44 <edwardk> byorgey: yeah if type inference didn't suck i could just say under wrapped
08:32:56 <byorgey> under wraps? =)
08:32:56 <edwardk> byorgey: actually its a little more subtle than what you said
08:33:02 <byorgey> oh, ok
08:33:04 <edwardk> :t wrapped
08:33:06 <lambdabot> (Functor f, Wrapped s t a b, Isomorphic k) => k (a -> f b) (s -> f t)
08:33:12 <edwardk> wrapped uses an instance of 'Wrapped'
08:33:21 <edwardk> instance Wrapped a b (Identity a) (Identity b)
08:33:31 <edwardk> this is often pretty underdetermined even though there are lots of fundes
08:33:33 <edwardk> er fundeps
08:33:54 <edwardk> so we have wrapping
08:33:56 <edwardk> :t wrapping
08:33:57 <lambdabot> (Functor f, Wrapped s s a a, Isomorphic k) => (s -> a) -> k (a -> f a) (s -> f s)
08:34:03 <edwardk> wrapping _ = wrapped
08:34:12 <edwardk> its just got a more limited type signature
08:34:18 <edwardk> but this doesn't let you change types
08:34:47 <edwardk> > runIdentity  $     Identity 5 & over (unwrapping Identity) +~ 1
08:34:48 <lambdabot>   Couldn't match expected type `Control.Lens.Internal.Mutator
08:34:48 <lambdabot>                ...
08:35:02 <edwardk> > runIdentity  $     Identity 5 & unwrapping Identity +~ 1
08:35:04 <lambdabot>   6
08:35:17 <edwardk> so we also have the horrible 'wrappings'
08:35:19 <edwardk> :t wrapings
08:35:21 <lambdabot>     Not in scope: `wrapings'
08:35:21 <lambdabot>     Perhaps you meant one of these:
08:35:21 <lambdabot>       `wrappings' (imported from Control.Lens),
08:35:22 <edwardk> :t wrappings
08:35:22 <`ramses> Subtrain: if you type "at username" my irc client does not notify me...
08:35:23 <lambdabot> (Functor f, Wrapped s t a b, Isomorphic k) => (s -> a) -> (t -> b) -> k (a -> f b) (s -> f t)
08:35:31 <edwardk> which takes two functions that 'should be the same function'
08:35:42 <edwardk> :t wrapping Identity
08:35:43 <lambdabot> (Functor f, Isomorphic k) => k (Identity s -> f (Identity s)) (s -> f s)
08:35:47 <edwardk> :t wrappings Identity Identity
08:35:48 <lambdabot> (Functor f, Isomorphic k) => k (Identity s -> f (Identity t)) (s -> f t)
08:35:58 <edwardk> to find the right wrapped instance
08:36:04 <byorgey> oh, I see
08:37:14 <edwardk> i don't have a way sans polykinds to improve inference on it much farther
08:37:46 <craigInnes> hi all, i am running into an "Illegal signature in pattern: SomeException" error with the following line:        handle (\(e::SomeException) -> print e ) $ do
08:37:53 <craigInnes> anyone know what im doing wrong?
08:37:57 <byorgey> edwardk: so my real question is whether there is some way to have something like 'over2' which lets one apply a two-argument function under a newtype
08:38:18 <byorgey> it always bugged me that the newtype package didn't have that, it seems I end up wanting it frequently
08:38:19 <edwardk> i don't currently have one
08:38:22 <byorgey> ok.
08:38:31 <edwardk> if you wanted to bang out a patch i'd probably take it though =)
08:38:42 <edwardk> also under2
08:38:47 <`ramses> craigInnes: you're pattern matching in a lambda and you cannot have type annotations in patterns
08:38:51 <byorgey> edwardk: ok, I'll probably get around to that at some point if no one else does =)
08:39:09 <byorgey> edwardk: oh, and do you use the same 'over' and 'under' as newtype, or did you switch the polarity?
08:39:11 <b52> just out of curiosity what do you guys think is the number of fellows here having a PhD?
08:39:19 <edwardk> i swapped polarity
08:39:23 <Rarrikins_q> 35
08:39:25 <byorgey> yay!!
08:39:26 <byorgey> edwardk++
08:39:28 <edwardk> over is used for all 'map' operations
08:39:29 <elliott> well you could do this as an applicative can't you
08:39:35 <edwardk> > over _1 (+1) (1,2)
08:39:37 <byorgey> b52: 47
08:39:37 <lambdabot>   (2,2)
08:39:54 <elliott> so you'd get overN out of it
08:39:55 <edwardk> > over both (+1) (2,3)
08:39:56 <lambdabot>   (3,4)
08:40:09 <b52> hm, thats not that much
08:40:11 <edwardk> > over both length ("hello","byorgey")
08:40:13 <lambdabot>   (5,7)
08:40:19 <byorgey> b52: I totally made up that number
08:40:45 <Lethalman> _omg omg_ I've just used the random monad
08:40:48 * elliott would be surprised if it wasn't less than both those made-up numbers
08:40:50 <craigInnes> `ramses: Apologies but could you elaborate on this? I am rather new to Haskell. What is the alternative to what I am doing here?
08:40:53 <Rarrikins_q> @src over
08:40:53 <aavogt> craigInnes: at the top of your file put {-# LANGUAGE ScopedTypeVariables #-}
08:40:53 <lambdabot> Source not found. You untyped fool!
08:40:56 <Lethalman> let me show it to the world!!!!
08:40:58 <Rarrikins_q> @type over
08:41:00 <lambdabot> Setting s t a b -> (a -> b) -> s -> t
08:41:04 <byorgey> edwardk: cool.
08:41:05 <edwardk> over l f = runIdentity . l (Identity . f)
08:41:07 <Rarrikins_q> @type both
08:41:08 <lambdabot> Applicative f => (a -> f b) -> (a, a) -> f (b, b)
08:41:12 <byorgey> Lethalman: congrats!
08:41:17 <edwardk> @ty let over l f = runIdentity . l (Identity . f) in over
08:41:18 <lambdabot> (Functor f, Functor f1) => (f1 (Identity a) -> f (Identity b)) -> f1 a -> f b
08:41:29 <aavogt> craigInnes: or write    handle (\e -> print (e::SomeException) )
08:41:32 <Lethalman> this is the code and I have a question: http://paste.debian.net/220597/
08:41:40 <`ramses> craigInnes: why did you put the type annotation in?
08:41:44 <Lethalman> see r1 <- getRandoms and r2 <- getRandoms
08:41:53 <Lethalman> will they be different series of numbers or will be the same?
08:42:02 <`ramses> craigInnes: couldn't the compiler infer that?
08:42:21 <craigInnes> `ramses: The reason I put the annotation code in was largely because of copy paste code from the real world haskell book which did not work
08:42:31 <Lethalman> I believe they will be different even if they are lazy
08:42:36 <Lethalman> but I'd like some confirmation :P
08:42:47 <craigInnes> `ramses: It used the old exception api and the above line was the proposed fix mentioned in a comment
08:42:47 <`ramses> craigInnes: did you try leaving it out? :)
08:43:11 <`ramses> craigInnes: ah ok, I don't really know about the exception stuff...
08:43:20 <aavogt> `ramses: Control.Exception lets you define your own exception types
08:43:31 <byorgey> Lethalman: looks like they will be different.  The implementation of getRandoms for the IO monad calls newStdGen.
08:43:45 <aavogt> and use handle with them too
08:43:53 * hackagebot wai-app-static 1.3.1 - WAI application for static serving  http://hackage.haskell.org/package/wai-app-static-1.3.1 (MichaelSnoyman)
08:43:55 * hackagebot wai-extra 1.3.1 - Provides some basic WAI handlers and middleware.  http://hackage.haskell.org/package/wai-extra-1.3.1 (MichaelSnoyman)
08:44:16 <byorgey> Lethalman: so every time you call getRandoms it creates a new (different) random number generator.
08:44:21 <`ramses> aavogt: ok, maybe you can help him out then because I don't know those libraries...
08:44:52 * aavogt already wrote out two solutions
08:45:07 <`ramses> hehe :)
08:45:24 <Lethalman> byorgey, oh ok, just for curiosity... if it wasn't creating a new prng, they would be different anyway right?
08:46:07 <Lethalman> byorgey, also, do you have any suggestions for that code? is it good to use getRandoms two times and pass the infinite list to selectInputs?
08:46:23 <Lethalman> so that I limit the monad use to only the sample function
08:46:36 <byorgey> Lethalman: the question is ill-defined.  If it wasn't creating a new prng then which one would it use?  Calling 'randoms' to generate an infinite list "consumes" the PRNG and you can't get it back (indeed, it wouldn't make sense to get it back)
08:46:40 <craigInnes> yea thanks `ramses and aavogt. Tried some the various solutions proposed out of curiosity and they all worked
08:47:04 <Lethalman> byorgey, not back, but you could create a prng first, then use the same for further randoms
08:47:19 <byorgey> Lethalman: in that case the lists would be identical.
08:47:32 <hpaste> Subtrain pasted “structural induction” at http://hpaste.org/80014
08:47:37 <Lethalman> byorgey, no you get the last generator from the first getRandoms
08:47:46 <Subtrain> at ramses http://hpaste.org/80014
08:47:54 <byorgey> Lethalman: there is no "last" generator, because the list is infinite
08:48:16 <Lethalman> byorgey, that's right, so would have done it differently perhaps?
08:48:19 <Lethalman> *would you
08:48:33 <byorgey> Lethalman: no, what you did looks good to me
08:49:48 <Lethalman> byorgey, awesome thanks :D
08:50:08 * Lethalman feels more newbie haskeller level 2 now
08:50:15 <`ramses> Subtrain: drop the "at" when referencing someone
08:50:30 <Subtrain> ok
08:50:43 <`ramses> Subtrain: you should discriminate between the two possibilities, either (p x) is true or it isn't
08:50:44 <gbacon> ?pl m >>= f = join $ (flip idfmap) m f
08:50:44 <lambdabot> (line 1, column 10):
08:50:44 <lambdabot> unexpected " "
08:50:44 <lambdabot> expecting operator
08:51:11 <Subtrain> ?
08:51:25 <gbacon> I expected join . flip idfmap to be equivalent
08:51:59 <gbacon> ?pl join $ (flip idfmap) m f
08:51:59 <lambdabot> join (idfmap f m)
08:52:00 <Subtrain> ramses what do you mean by that?
08:52:15 <elliott> what is idfmap
08:53:00 <gbacon> idfmap :: (a -> b) -> m a -> m b
08:53:19 <gbacon> the point-free incantation above doesn't typecheck
08:53:42 <`ramses> Subtrain: your algorithm can take either of two branches (the two guards) so your proof should check each of those branches
08:53:53 <gbacon> ?pl \m f -> join $ (flip idfmap) m f
08:53:53 <lambdabot> (join .) . flip idfmap
08:54:07 <gbacon> hrm
08:54:41 <gbacon> ?ty join .
08:54:42 <lambdabot> parse error (possibly incorrect indentation)
08:54:42 <`ramses> gbacon: (.) only works for one argument functions...
08:54:51 <gbacon> ?ty (join .)
08:54:52 <lambdabot> (Monad m, Functor f) => f (m (m a)) -> f (m a)
08:54:54 <gbacon> oh
08:55:22 <Rarrikins_q> gbacon: The dot after basically makes it wait until the first argument is taken care of, I think.
08:55:35 <`ramses> of course, due to currying you can say that it works for all, but that changes the types of what you can compose with
08:55:57 <gbacon> ?ty (f .)
08:55:58 <lambdabot> (Functor f, Show a, FromExpr b) => f a -> f b
08:56:02 <Rarrikins_q> @unpl (a .)
08:56:02 <lambdabot> (\ b e -> a (b e))
08:56:40 <elliott> gbacon: how does idfmap differ from fmap
08:56:43 <`ramses> (f .) is also (fmap f) for the ((->) r) instance of Functor
08:57:13 <gbacon> elliott: it's fmap for the Identity monad's Functor instance
08:58:19 <elliott> ok
08:59:22 <gbacon> ?pl \a b c -> f $ g a b c
08:59:22 <lambdabot> ((f .) .) . g
08:59:45 <`ramses> :t (fmap . fmap) f . g
08:59:46 <lambdabot> (Functor f2, Functor f1, Functor f, Show a, FromExpr (f (f1 (f2 a))), FromExpr b) => f (f1 (f2 b))
09:00:05 <`ramses> :t ((f .) .) . g
09:00:06 <lambdabot> (Functor f2, Functor f1, Functor f, Show a, FromExpr (f (f1 (f2 a))), FromExpr b) => f (f1 (f2 b))
09:01:04 <`ramses> where do those Show and FromExpr constraints come from?
09:01:15 <`ramses> some weird lambdabot thing?
09:01:32 <hpaste> Subtrain pasted “structural induction” at http://hpaste.org/80015
09:01:42 <Subtrain> ramses http://hpaste.org/80015
09:04:19 <`ramses> Subtrain: make two cases, first proof that the proposition holds of (p x) is true, then in a second branch of the proof, show that it also holds when (p x) is false
09:04:44 <`ramses> you need to write out clearly the two cases
09:05:29 <`ramses> (this is just elementary "writing down a proof" stuff btw, you never saw how to do this in a math course?)
09:06:30 <DrChaos[S]> are there any haskell programming exercises for people learning haskell using lyah?
09:06:33 <aavogt> > foldr (+) 0 [a,b,c] :: Expr
09:06:34 <lambdabot>   a + (b + (c + 0))
09:06:39 <DrChaos[S]> learn you a haskell has no exercises
09:06:55 <DrChaos[S]> I need practice so that things will cement in my brain
09:06:59 <Rarrikins_q> > foldl1 (+) [a, b, c]
09:07:01 <lambdabot>   a + b + c
09:07:03 <gbacon> ?src sequence
09:07:03 <lambdabot> sequence []     = return []
09:07:03 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
09:07:03 <lambdabot> -- OR: sequence = foldr (liftM2 (:)) (return [])
09:07:13 <zomg> DrChaos[S]: you could prob do project euler or something =)
09:07:14 <Rarrikins_q> Take that, parentheses!
09:07:21 <hpc> oh god, not project euler
09:07:24 <zomg> lol
09:07:24 <aavogt> `ramses: ^^ I think that stuff comes from http://hackage.haskell.org/package/simple-reflect
09:07:28 <hpc> the only thing you learn from that is number theory
09:07:31 <zomg> it was the only thing that came to mind about programming puzzles :(
09:07:40 <hpc> pick a program you want to write, then start writing parts of it in haskell
09:07:53 <DrChaos[S]> hpc, an IRC bot
09:07:55 <zomg> Yeah that is the way to go
09:07:56 <hpc> continue concurrently with lyah and stop when you get stuck to keep reading
09:07:59 <zomg> Just do whatevs.
09:08:02 <hpc> DrChaos[S]: perfect; is how i started too
09:08:12 <zomg> I need to write a new irc bot
09:08:24 <zomg> my old one doesn't compile on ghc 7 anymore because it depends on the GHC APIs for dynamic module loading
09:08:48 <hpc> zomg: heh, when i needed dynamic module loading i just gave up and went perl
09:08:53 * hackagebot connection 0.1.2 - Simple and easy network connections API  http://hackage.haskell.org/package/connection-0.1.2 (VincentHanquez)
09:09:20 <zomg> hpc: it wasn't actually that tricky, the biggest problem was making sense of the nearly completely undocumented GHC APIs :P
09:09:28 <DrChaos[S]> the first part I want to write is socket.hs
09:09:35 <NougatRillettes> DrChaos[S]: project euler is not imo a good source of exercices
09:09:43 <NougatRillettes> most of them use math tricks
09:10:03 <NougatRillettes> why don't you read write yourself a scheme in 48 hours ?
09:10:17 <zomg> I think euler does ok for basic exercise of the language itself
09:10:36 <zomg> but yeah it's probably not good for learning to do larger programs
09:10:46 <hpc> zomg: unless you are a mathematician, i think it gets too hard before you even make it past list comprehensions
09:10:58 <zomg> haha, yeah I recall that's the reason why I never bothered with it =)
09:11:24 <NougatRillettes> it really quickly starts to deal with artithmetics
09:11:28 <NougatRillettes> and prime numbers
09:11:31 <hpc> write yourself a scheme would be a good one
09:11:38 <DrChaos[S]> I really want to create a connectTorRCServer function that takes an IRC server hostname string and a port number and connects to the IRC server, giving back a socket to connect to
09:12:32 <NougatRillettes> or DrChaos[S] if you really are a newbie, just recode some of stdlib functions
09:12:34 <zomg> I'm writing some haskell learning material, using web dev as a background for it, so naturally the examples mostly circle around building a simple web app "framework"
09:12:53 <NougatRillettes> zomg: have you read about ocsigen ?
09:13:04 <zomg> nope
09:13:06 <DrChaos[S]> NougatRillettes, like which ones? I'm new to programming
09:13:17 <NougatRillettes> to see how type could be used to guarantee WC validity
09:13:35 <NougatRillettes> well definitely check that zomg it's in OCaml but the concepts are interesting
09:13:42 <zomg> Yeah looking at it now
09:13:54 <zomg> Interesting if it works in a reasonable way
09:13:57 <NougatRillettes> DrChaos[S]: well everything on List for exeple
09:14:00 <NougatRillettes> +m
09:14:12 <zomg> They sort of have done this with JavaScript already a long time ago but it never really got anywhere
09:14:17 <zomg> Now it's surfacing again with Node
09:14:35 <zomg> I mean the whole "use server side on the client" thing some of the ocsigen things seem to be about
09:16:04 <NougatRillettes> well it's really more than this
09:16:12 <zomg> The web framework concept is pretty useful for a basic learning exercise though.. you can use something like Warp as the base, and easily start by just doing simple stuff at first, then continuing to more advanced things like reader or writer
09:16:20 <NougatRillettes> but I don't really know enough to talk about it
09:17:51 <NougatRillettes> and DrChaos[S] you can then implement the sort algorithms
09:17:52 <ryant5000> is there a monad transformer with similar semantics to ST?
09:18:00 <NougatRillettes> and the different data Structures
09:18:22 <elliott> ryant5000: you can write one but it'll lose performance
09:19:07 <ryant5000> elliott; yeah, i kind of expect that; what i really want to do is layer it over [] or Logic
09:19:42 <elliott> something like StateT Vault should work (http://hackage.haskell.org/package/vault)
09:20:05 <ryant5000> elliott: oh, fantastic; that's exactly the kind of thing i'm looking for
09:20:24 <ryant5000> elliott: thanks
09:20:30 <elliott> well, "something like"... you can only make those keys in ST or IO still
09:20:36 <elliott> so it might require some unsafePerformIO or whatever
09:20:37 <ryant5000> ahh
09:20:55 <ryant5000> that wouldn't be so bad
09:21:18 <ryant5000> i might actually have MonadIO available
09:21:31 <ryant5000> but i can't just use ST straightforwardly because i need backtracking
09:21:46 <DrChaos[S]> huh? I don't understand how you'd implement (++)
09:22:09 <jeff_s2> What other languages have very good multithreaded runtimes?
09:22:14 <Rarrikins_q> DrChaos[S]: Do it element by element.
09:22:44 <elliott> ryant5000: right, the IO/ST are just to give you a supply of Keys
09:22:47 <DrChaos[S]> how do I know when I have reached the end of the first list? pattern matching?
09:22:57 <Rarrikins_q> DrChaos[S]: Yes
09:23:07 <Rarrikins_q> There sure are a lot of people with names that start with dr here :)
09:23:10 <elliott> ryant5000: you can't just e.g. offer an infinite stream of (Key a) or whatever because then you can read off the same Key twice at a different type and get unsafeCOerce
09:23:17 <elliott> same reason unsafePerformIO gives you unsafeCoerce
09:24:53 <ryant5000> elliott: yeah, that makes sense
09:33:18 <mel-> do i understand this correctly? when i write a numeric constant in haskell, this number has no 'fixed' type? all i know is that it belongs to a certain typeclass (Num), right?
09:33:29 <elliott> 0 is the same as fromInteger (0 :: Integer)
09:33:31 <elliott> :t 0
09:33:32 <lambdabot> Num a => a
09:33:36 <elliott> so it works as any type that is an instance of Num
09:33:39 <elliott> 0 :: Double, 0 :: Int, etc.
09:34:02 <mel-> ok, so what i wrote is correct. a plain number has no fixed type a priori
09:35:18 <aavogt> if there's nothing specifying the type for a number it gets `defaulted' to Integer or Double (there's a  default keyword to change it)
09:37:10 <DrChaos[S]> do I need any special syntax to make an infixl function?
09:37:16 <DrChaos[S]> my function is named ++'
09:37:37 <mel-> Is 'Double' bounded?
09:38:47 <DrChaos[S]> mel-, try maxBound :: Double
09:41:18 <DrChaos[S]> ok, I don't quite know how to do the pattern matching to have the result I want
09:41:45 <NougatRillettes> > maxBound :: Double
09:41:46 <lambdabot>   No instance for (GHC.Enum.Bounded GHC.Types.Double)
09:41:46 <lambdabot>    arising from a use o...
09:41:54 <NougatRillettes> mel
09:41:57 <mel-> DrChaos[S]: that throws an error. i guess that says it's not bounded?
09:42:10 <DrChaos[S]> mel-, I think it's not bounded
09:42:11 <NougatRillettes> yep " No instance for (GHC.Enum.Bounded"
09:43:04 <mel-> 'maxBound :: Int' prints a number. that is probably the upper bound.
09:43:23 <Lethalman> I have a [m a] that I want to process lazily
09:43:47 <Lethalman> I don't want to call sequence on it right? because it will create m [a] strictly I believe
09:44:07 <mel-> I was surprised to see that '<large number> :: Float' displays 'infinity' while so far i couldn't reproduce this with Double.
09:44:55 <elliott> mel-: just add more digits
09:44:55 <Lethalman> for example somelist <- createList, and that's my [m a]
09:45:07 <Lethalman> the I want to filter func somelist
09:45:14 <Lethalman> but func is (a -> Bool)
09:45:26 <Lethalman> is there something that unboxes each m a for me and call func?
09:45:46 <Clint> somelist <- fmap (filter func) createList ?
09:46:00 <Lethalman> oh let me see
09:46:17 <aavogt> that would work for   func :: m a -> Bool
09:46:20 <cmccann> Lethalman, you can filter it with (m a -> Bool), of course.
09:46:36 <Lethalman> cmccann, but I want to provide an (a -> Bool)
09:46:37 <cmccann> if you want to filter with (a -> Bool) you need a list [a], which means sequencing the list.
09:46:42 <mel-> elliott: hmmm, so what shall I do? I want to define a function which computes a new (larger) number from a input number. I cannot assume that input/output are integrals. and they can become pretty large. so i need something unbounded for non-integers.
09:46:46 <mel-> what type shall i use?
09:46:52 <Lethalman> Clint, what if I also want to map after the filter?
09:47:04 <elliott> mel-: there is no standard bigfloat type
09:47:10 <elliott> well there is Rational
09:47:12 <elliott> but that's not a float
09:47:22 <elliott> anyway just use Num a => a -> a
09:47:39 <mel-> (All involved numbers are rational)
09:48:10 <aavogt> > showCReal 100 pi
09:48:12 <lambdabot>   "3.141592653589793238462643383279502884197169399375105820974944592307816406...
09:48:14 <mel-> so, then I could use Rational, I guess
09:48:29 <Lethalman> Clint, thanks anyway will look at fmap deeper
09:49:04 <cmccann> Lethalman, about the closest you can get would be mapping with something like (a -> Maybe a) so you get a list [m (Maybe a)]
09:49:15 <cmccann> where the "filtered" elements will be Nothing
09:50:11 <cmccann> Lethalman, the important question is why do you not want to sequence the list?
09:50:25 <Lethalman> cmccann, because I want to process it step by step
09:50:39 <Lethalman> cmccann, I'm generating samples of a distribution with the random monad
09:50:40 <watermind> makes sense for lots of monads
09:50:46 <watermind> exactly
09:50:58 <cmccann> where process means sequencing each of the "m a" values?
09:51:02 <Lethalman> so I want to filter+genericLength it but step by step
09:51:24 <watermind> in any case your result will be an m something
09:51:25 <Lethalman> cmccann, this: genericLength $ filter satisfy samples
09:51:30 <Lethalman> where samples is an [m a]
09:51:44 <cmccann> you absolutely can't find the length of the filtered list without sequencing it.
09:52:26 <watermind> you don't have to explicitely sequence it, and then map it with filter, but you will end up sequencing it implicitely anyway
09:52:39 <watermind> like I said, your result will be an m something
09:52:42 <cmccann> knowing the length of the filtered list implies not just sequencing everything, but also forcing the evaluation of all the list elements.
09:52:48 <Lethalman> ok
09:53:04 <Lethalman> so if I do sequenced <- sequence samples it will eagerly generate everything
09:53:23 <watermind> cmccann: there is not even a final length, there's an m Int
09:53:35 <Lethalman> I'd like to count the number of elements satisfying a query
09:54:02 <cmccann> it will just force whatever is necessary to sequence the list. In some monads that can still be quite lazy.
09:54:05 <Lethalman> watermind, yes
09:54:25 <Lethalman> is it possible to count without creating the list then calculating the length?
09:54:48 <Lethalman> or genericLength does that?
09:55:05 <Lethalman> I mean, when calculating the length through the list, previous elements will be discarded?
09:56:43 <Lethalman> from a list [m a] i'd like to count the number of a satisfying a function, and do that without keeping the whole list in memory
09:56:43 <cmccann> Lethalman, you could consume the list, sequencing each element and then testing it and keeping a running total
09:57:16 <cmccann> but if these are random samples, the values the filter and count function sees would not be the same as the next time you use anything in the list
09:57:17 <Lethalman> cmccann, ok, that requires a custom function? or I can do that with existing functions?
09:58:54 * hackagebot zip-archive 0.1.3 - Library for creating and modifying zip archives.  http://hackage.haskell.org/package/zip-archive-0.1.3 (JohnMacFarlane)
09:59:49 <cmccann> Lethalman, it'd be simple enough to write with a few existing functions
10:00:02 * Lethalman is clueless :(
10:00:26 <cmccann> I'd probably just do the sequence, filter, length myself unless it became apparent that that really had performance issues
10:00:47 <cmccann> since I'm not sure if that will even need the whole list constructed in memory at once anyhow
10:01:55 <cmccann> if the computed length is used before the next time you generate a random value, it probably won't be in memory all at once
10:05:10 <cmccann> anyway, if you want to do it by other means, without ever generating a list, one the monadic folds is probably the way
10:05:56 <cmccann> and then use pretty much the same logic you would for a non-monadic version
10:08:43 <cmccann> Lethalman, anyway--sorry, I'm kinda busy and don't have time to give a more detailed example
10:08:54 * hackagebot filestore 0.6 - Interface for versioning file stores.  http://hackage.haskell.org/package/filestore-0.6 (JohnMacFarlane)
10:09:05 <Lethalman> cmccann, I'm just trying with sequence + filter + genericLength, thanks anyway :)
10:11:09 <cmccann> Lethalman, there's actually a filterM in Control.Monad, so you could just do length <$> filterM (fmap testFunc) listOfThings
10:11:27 <Lethalman> :S
10:12:07 <Lethalman> cmccann, thanks a lot, will get my head around that :P
10:12:08 <cmccann> but it's the same thing in the end
10:12:51 <cmccann> the (fmap testFunc) is because filterM expects a list [a] and a function (a -> m Bool)
10:13:24 <Lethalman> I don't get the type of fmap testFunc yet
10:13:48 <cmccann> well, say you're filtering on something simple like (> 5)
10:13:54 <Lethalman> ok
10:13:54 <cmccann> :t fmap (> 5)
10:13:55 <lambdabot> (Functor f, Num a, Ord a) => f a -> f Bool
10:14:10 <cmccann> :t filterM
10:14:11 <lambdabot> Monad m => (a -> m Bool) -> [a] -> m [a]
10:14:30 <cmccann> then the (f a -> f Bool) matches the first argument of filterM
10:14:36 <cmccann> :t filterM (fmap (> 5))
10:14:37 <lambdabot> (Monad m, Functor m, Num a, Ord a) => [m a] -> m [m a]
10:14:56 <Lethalman> shouldn't it be a -> f Bool instead ?
10:15:28 <cmccann> ergh, I think I'm confusing myself now, sorry
10:16:07 <cmccann> sorry, need another cup of tea
10:16:14 <Lethalman> ahah np :P
10:16:46 <Lethalman> so fmap somewhat changes the argument and the result of a function to be of some functor?
10:17:00 <cmccann> :t fmap
10:17:01 <lambdabot> Functor f => (a -> b) -> f a -> f b
10:17:17 <cmccann> note that every Monad is (or should be) a Functor instance
10:17:21 <cmccann> there's also liftM
10:17:22 <cmccann> :t liftM
10:17:24 <lambdabot> Monad m => (a1 -> r) -> m a1 -> m r
10:17:29 <cmccann> which does the same thing
10:17:32 <Lethalman> ah
10:17:37 <cmccann> :t filterM (liftM (> 5))
10:17:38 <lambdabot> (Monad m, Num a1, Ord a1) => [m a1] -> m [m a1]
10:18:05 <mel-> I don't understand the error message when trying to compile these two lines: "foo :: (Num a, Num b) => a -> b -> a", "foo x y = x * y". can anyone help me?
10:18:08 <cmccann> :t liftM length (filterM (liftM (> 5)))
10:18:09 <lambdabot> (Num a1, Ord a1) => [[a1]] -> Int
10:18:17 <cmccann> oops
10:18:27 <cmccann> :t \xs -> liftM length (filterM (liftM (> 5)) xs)
10:18:28 <lambdabot> (Monad m, Num a1, Ord a1) => [m a1] -> m Int
10:18:55 * hackagebot vector-conduit 0.5.0.0 - Conduit utilities for vectors  http://hackage.haskell.org/package/vector-conduit-0.5.0.0 (JaredHance)
10:19:17 <Lethalman> cmccann, so in the end, is that the same as length $ filter (> 5) xs ?
10:19:24 <Lethalman> ops
10:19:38 <Lethalman> yes, where xs is sequenced
10:19:50 <Lethalman> xs <- sequence somelist before that expression
10:19:51 <cmccann> where xs is what you get from sequence, yes
10:20:18 <Lethalman> will try to run it under ulimit and see if it kills itself :P
10:20:31 <Lethalman> or I can limit the memory of ghc somehow? let's see
10:20:44 <cmccann> :t \xs -> liftM (length . filter (> 5)) $ sequence xs
10:20:45 <DrChaos[S]> huh wait...you guys say to implement ++' by element by element
10:20:46 <lambdabot> (Monad m, Num a, Ord a) => [m a] -> m Int
10:20:56 <cmccann> same idea there
10:21:51 <DrChaos[S]> I really don't know how you'd do that...
10:21:59 <Lethalman> cmccann, ah that liftM there is interesting
10:22:03 <DrChaos[S]> it's like all my brain is is just mush
10:22:11 <Lethalman> :t liftM
10:22:12 <lambdabot> Monad m => (a1 -> r) -> m a1 -> m r
10:22:42 <Lethalman> that's too magic for me \o/
10:22:43 <cmccann> Lethalman, the only reason for that is that Monad does not (for historical reasons) require Functor
10:22:54 <DrChaos[S]> can I type my try in here and you tell me if it's correct?
10:23:03 <cmccann> just use fmap unless you really need to use something
10:23:07 <cmccann> or (<$>) which is fmap infix
10:23:22 <cmccann> @src liftM
10:23:22 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
10:23:33 <cmccann> it's also not very magical :P
10:23:59 <Lethalman> still too magic for me :P
10:24:29 <Luke> @src (<$>)
10:24:29 <lambdabot> f <$> a = fmap f a
10:24:30 <Lethalman> but yes, I see that's the same as doing xs <- sequence somelist; return length $ ...
10:24:35 <DrChaos[S]> argh...how do I include the current element of the list AND the rest of the list? I don't want infinite recursion!
10:24:36 <Luke> @src fmap
10:24:36 <lambdabot> Source not found. I've seen penguins that can type better than that.
10:24:50 <cmccann> @src Functor
10:24:50 <lambdabot> class  Functor f  where
10:24:50 <lambdabot>     fmap        :: (a -> b) -> f a -> f b
10:24:59 <Luke> cmccann: ;) thanks
10:25:17 <cmccann> would be nice if lambdabot did that automatically for typeclass functions
10:25:27 <Rarrikins_q> DrChaos[S]: How are you trying to do it?
10:25:56 <flebron> cmccann, what if there are multiple matches? (Not that I think that happens in Prelude)
10:26:00 <DrChaos[S]> ++' (x:xs) (y:ys) = ++' (x:xs) (y:ys) # Blows up
10:26:15 <cmccann> @src fromList
10:26:15 <lambdabot> Source not found. You type like i drive.
10:26:27 <cmccann> @src Data.Map.fromList
10:26:27 <lambdabot> Source not found. My pet ferret can type better than you!
10:26:28 <flebron> DrChaos[S], that is just something = something, you typed the same thing left and right
10:26:29 <cmccann> hm
10:26:29 <Rarrikins_q> DrChaos[S]: Oh yeah, that just calls ++' again.
10:26:46 <cmccann> flebron, dunno, just something unhelpful I guess. lambdabot is good at being unhelpful.
10:26:52 <Rarrikins_q> DrChaos[S]: Do you have the base case?
10:26:55 <Lethalman> cmccann, ok I've tried limiting the memory of ghci and it said Heap exhausted with sequence
10:26:59 <Rarrikins_q> DrChaos[S]: With empty list?
10:27:18 <cmccann> Lethalman, oh bother.
10:27:28 <DrChaos[S]> Rarrikins_q, yes
10:27:38 <Rarrikins_q> DrChaos[S]: What do you have for that?
10:27:43 <cmccann> Lethalman, just to clarify, this is a list of random distributions that you want to sample values from, right?
10:27:58 <Lethalman> cmccann, let me show the code
10:28:07 <cmccann> and you don't care about getting exactly the same set of values next time you use the list?
10:28:26 <KorriX> Hello
10:28:31 <Rarrikins_q> Hello!
10:28:45 <DrChaos[S]> Rarrikins_q, http://vpaste.net/oLegY
10:28:50 <KorriX> is there any good package manager for hackage? (I mean something better than cabal-install)
10:28:55 * hackagebot persistent-mongoDB 1.1.3 - Backend for the persistent library using mongoDB.  http://hackage.haskell.org/package/persistent-mongoDB-1.1.3 (GregWeber)
10:29:06 <Lethalman> cmccann, http://paste.debian.net/220638/
10:29:12 <Rarrikins_q> DrChaos[S]: Oh, I see.
10:29:28 <Lethalman> cmccann, praf is a graph with probabilities on nodes and edges
10:29:49 <Lethalman> cmccann, naiveSample samples a graph without probabilities given a praf
10:29:59 <cmccann> Lethalman, oh, one other thing--try compiling it in a test program and running that
10:30:06 <cmccann> GHCi doesn't optimize much of anything
10:30:09 <DrChaos[S]> Rarrikins_q, I think I've got it
10:30:17 <Lethalman> cmccann, I can still limit the heap size?
10:31:01 <DrChaos[S]> Rarrikins_q, if the result of a function is a list then: ++' (x:xs) (y:ys) x : (++' xs) ...
10:31:04 <cmccann> Lethalman, http://www.haskell.org/ghc/docs/7.4.1/html/users_guide/runtime-control.html
10:31:31 <cmccann> though check the GHC version you have, the RTS options stuff has changed a bit lately
10:31:37 <Rarrikins_q> DrChaos[S]: Yeah, that's getting there.
10:31:42 <Lethalman> thanks
10:31:59 <cmccann> you may need to compile with RTS options enabled, and use -O2 if that's not the default
10:32:04 <Rarrikins_q> DrChaos[S]: The basic idea of recursion is to take a small part of the input, work that, and combine it with the rest of the solution (that you'll do later).
10:32:12 <elliott> -O2 hasn't ever been the default has it?
10:32:29 <cmccann> I can't remember what is or has been the default
10:32:58 * jeff_s2 likes corecursive functions.
10:33:09 <Rarrikins_q> DrChaos[S]: So, that's the right idea. You take x (small part), work that (no work needed), and combine it with the rest of the solution (using (:)).
10:33:32 <DrChaos[S]> Rarrikins_q, but don't I have to take y and work that?
10:33:42 <Rarrikins_q> DrChaos[S]: Yeah, but not yet.
10:33:54 <Rarrikins_q> DrChaos[S]: You have to output all of xs before dealing with ys.
10:34:01 <Lethalman> cmccann, yes, heap exhausted by running the compiled version too
10:34:16 <Rarrikins_q> DrChaos[S]: That's like stage 2 or something :)
10:34:18 <DrChaos[S]> Rarrikins_q, ah, so do that in a different pattern match
10:34:24 <cmccann> Lethalman, ok, thanks for checking
10:34:25 <Rarrikins_q> DrChaos[S]: Yeah.
10:34:34 <Rarrikins_q> DrChaos[S]: Once xs is empty, then start in on ys.
10:34:57 <Lethalman> cmccann, maybe the issue is somewhere else in the program?
10:35:32 <cmccann> hm, you're building the list with replicate
10:36:15 <Lethalman> cmccann, if I don't do the filter, that is stop at res <- sequence samples, everything is fine
10:36:33 <cmccann> Lethalman, right, because that's not forcing anything
10:36:49 <Lethalman> but I don't know if either sequence or replicate hold any thunk
10:36:58 <Lethalman> you think that replicate does it?
10:37:01 <Lethalman> @src replicate
10:37:01 <lambdabot> replicate n x = take n (repeat x)
10:38:08 <Rarrikins> DrChaos[S]: Sorry, was disconnected after I said "Once xs is empty,..."
10:38:16 <cmccann> Lethalman, no, just noting that you're making the list that way
10:38:29 <Lethalman> ok
10:38:31 <DrChaos[S]> Rarrikins,  http://vpaste.net/wlWSH
10:38:47 <Lethalman> cmccann, will try your liftM version
10:38:58 <cmccann> it will probably be the same
10:39:16 <DrChaos[S]> Rarrikins, I guess the only way to figure out if I'm missing something is to try it out
10:39:31 <Rarrikins> DrChaos[S]: Yeah.
10:40:13 <Rarrikins> DrChaos[S]: Later on, there's QuickCheck and so on, but it requires a bit of Haskell knowledge.
10:41:27 <Rarrikins> DrChaos[S]: That last one is getting there.
10:41:31 <DrChaos[S]> Rarrikins, how do I get this thing to compile? It seems like I need parenthesis or some such
10:42:57 <Rarrikins> DrChaos[S]: I think ++' won't work.
10:43:45 <DrChaos[S]> how about change it to mPP for myPlusPlus?
10:43:55 <Rarrikins> DrChaos[S]: OK :)
10:45:50 <cmccann> Lethalman, ok try this: foldlM (liftM . (\t y -> if y then t + 1 else t)) 0 $ replicate n (satisfy <$> sample)
10:46:01 <cmccann> to replace the first three lines of montecarlo
10:46:17 <cmccann> and yes that's horribly confusing but I need to leave in a moment
10:46:22 <Lethalman> cmccann, btw if I just genericLength $ samples (not even by sequencing) I get memory exhausted
10:46:27 <DrChaos[S]> Rarrikins, please try to ghci this one: http://vpaste.net/O8Eoz
10:46:45 <DrChaos[S]> wait, let me script my ghci
10:46:46 <cmccann> if it works ask someone else to explain what it does, if not then ignore it
10:47:13 <Rarrikins> DrChaos[S]: It won't work because line 4 has an element used as a list.
10:47:31 <Lethalman> cmccann, wait a moment :P if genericLength $ samples gives problems, it's not even a sequencing problem, right?
10:47:50 <Rarrikins> DrChaos[S]: Line 5 does, too.
10:48:06 <cmccann> Lethalman, did you try that one outside of GHCi?
10:48:14 <DrChaos[S]> I don't get it
10:48:27 <Lethalman> cmccann, yours? not yet, still writing
10:48:31 <Rarrikins> DrChaos[S]: (:) has an element on the left and a list on the right.
10:48:44 <Rarrikins> DrChaos[S]: But you have x:y, which has an element on the right.
10:48:55 * hackagebot python-pickle 0.1.0 - Serialization/deserialization using Python Pickle format.  http://hackage.haskell.org/package/python-pickle-0.1.0 (VoMinhThu)
10:48:58 <Rarrikins> DrChaos[S]: So, you're trying to put an element on the front of a list that's not a list.
10:49:03 <Lethalman> @src <$>
10:49:03 <lambdabot> f <$> a = fmap f a
10:49:15 <DrChaos[S]> oh wait,: maybe I can do it like this then: (x:(y:[]))
10:49:27 <Rarrikins> DrChaos[S]: Yeah, that'll fix that :)
10:49:38 <cmccann> Lethalman, no, I mean trying the genericLength
10:49:42 <Rarrikins> DrChaos[S]: The fifth line has mPP y ys, but y isn't a list.
10:49:54 <cmccann> also, not sure why you're using genericLength there anyway
10:50:17 <cmccann> if your length is larger than an Int you have bigger things to worry about
10:50:29 <DrChaos[S]> Rarrikins, that's a bit tougher problem to fix
10:50:38 <Rarrikins> DrChaos[S]: Yeah :)
10:50:40 <cmccann> and you can just do (fromIntegral x) in the last bit
10:50:52 <Lethalman> cmccann, your version works
10:50:54 <DrChaos[S]> it probably means I need more pattern matches...something is missing and I don't know what
10:51:07 <cmccann> Lethalman, hooray
10:51:15 <cmccann> just in time for me to leave!
10:51:18 <Lethalman> cmccann, even in ghci, so it's not a ghci issue
10:51:28 <Lethalman> cmccann, genericLength is the issue then? :)
10:51:48 <cmccann> I dunno what generic length is or isn't responsible for
10:51:52 <Lethalman> cmccann, thank you very much
10:51:58 <Rarrikins> DrChaos[S]: What I'd recommend is starting over (you can keep a copy of the old one). Try making one line for each stage (three stages in all).
10:51:59 <cmccann> but my version should avoid everything that's possibly the cause
10:52:00 <Lethalman> will try to investigate further ;)
10:52:26 <cmccann> I'm out, feel free to ask someone else for help understanding wtf that line of code is doing :P
10:52:26 <Rarrikins> DrChaos[S]: That'll match the process of doing ++ better.
10:52:44 <Lethalman> ahah ok
10:53:00 <cmccann> Lethalman, it's not even trying to be idiomatic code, that was just hacking something to see if it helped quickly
10:53:14 <cmccann> anyway, glad it helped, seeya
10:53:20 <Lethalman> cmccann, helped a lot ;) see you thanks again
10:54:11 <Lethalman> @src genericLength
10:54:11 <lambdabot> genericLength []    = 0
10:54:11 <lambdabot> genericLength (_:l) = 1 + genericLength l
10:54:49 <Lethalman> ^^ if that's the definition, isn't storing thunks until [] ?
10:54:54 <Lethalman> *isn't it
10:55:32 <Rarrikins> Lethalman: Yeah, it should store one thunk the whole time.
10:55:50 <Lethalman> Rarrikins, it "should" in the sense that it's not doing it in that code, right?
10:55:57 <Lethalman> ah
10:56:02 <Lethalman> sorry misread you... ok
10:56:10 <Rarrikins> Well, it should do it in practice.
10:56:30 <Rarrikins> Also, the 1s should combine as it goes.
10:56:47 <Rarrikins> Not sure if it does that, though.
10:57:35 <Rarrikins> It'll have a thunk that accumulates the running total and the remainder of the list.
10:59:42 <Lethalman> Rarrikins, cmccann helped me in fixing http://paste.debian.net/220638/
11:00:10 <Lethalman> Rarrikins, that exceeds the heap size, while  foldlM (liftM . (\t y -> if y then t + 1 else t)) 0 $ replicate n (satisfy <$> sample) does not
11:00:11 <Rarrikins> Oh, OK
11:00:20 <Lethalman> and I'm trying to understand why :S
11:00:23 <Rarrikins> Ahh, OK.
11:00:29 <Rarrikins> I bet it doesn't add things as it goes.
11:00:39 <Rarrikins> So, it accumulates 1 + 1 + 1 + 1 + 1 + the rest
11:00:48 <Lethalman> but maybe there's something else because:
11:01:05 <Rarrikins> (why isn't genericLength strict?)
11:01:32 <Rarrikins> I suppose it'd make the definition messier.
11:01:40 <Lethalman> foldl (\t y -> if (satisfy y) then t + 1 else t)) 0 res also exceeds the heap
11:01:57 <Lethalman> satisfy is just (\_ -> True)
11:02:01 <elliott> Rarrikins: so you can use it with lazy types
11:02:16 <Rarrikins> elliott: Ahh, OK.
11:02:28 <elliott> e.g. data Nat = Z | S Nat
11:02:36 <elliott> then you can say "genericLength [1..] > 14"
11:02:37 <elliott> and get back True
11:03:40 <Rarrikins> Ahh, I see.
11:03:49 <dhilipsiva> Haskell!
11:03:52 <dhilipsiva> :)
11:03:55 * hackagebot yesod-markdown 0.5.1 - Tools for using markdown in a yesod application  http://hackage.haskell.org/package/yesod-markdown-0.5.1 (PatrickBrisbin)
11:05:04 <mel-> given a Fractional a / b -- how can i convert this into the the scientific numeric representation, i.e. of the form xey = x*10^y?
11:05:50 <Rarrikins> mel-: What are you rounding it to?
11:06:38 <Rarrikins> mel-: How many places?
11:06:46 <mel-> Rarrikins: i'd to like to specify that somehow.
11:07:03 <Rarrikins> Let's see
11:07:14 <mel-> 'xEy' where x has at most 2 decimal digits after the dot would already be a good start
11:07:25 <mel-> (and e.g. x between 0 and 10)
11:08:04 <thoughtpolice> lpsmith: thanks for the reference on indexed-extras, it does have shift/reset
11:08:19 <Lethalman> so, does anybody know why in the montecarlo function here http://paste.debian.net/220644/ the commented code exceeds the heap size while the uncommented does not?
11:08:36 <Lethalman> there's something keeping thunks in memory probably but I don't know what it is
11:10:26 <thoughtpolice> lpsmith: and thanks for the notes you took in ShiftReset.hs, i think i might do some digging and write about this
11:11:25 <DrChaos[S]> Rarrikins, is this a good try for the first stage? mPP (x:xs) (y:ys) = x : (mPP xs (y:ys))
11:11:55 <DrChaos[S]> Rarrikins, we pass the whole (y:ys) list because we are not ready to process it yet [done in second stage]
11:13:58 <Rarrikins> > let ratToSci :: Int -> Rational -> String; ratToSci places n = if n < 0 then '-':f places (-n) 0 else f places n 0 where f :: Int -> Rational -> Integer -> String; f p n e = if n > 10 then f p (n/10) (e + 1) else if n < 1 then f p (10*n) (e - 1) else show (floor n) ++ ('.':show (round ((n - fromInteger (floor n)) * 10^p))) in ratToSci 100 (1/7)
11:14:00 <lambdabot>   "1.428571428571428571428571428571428571428571428571428571428571428571428571...
11:14:08 <Rarrikins> mel-: ^^
11:14:20 <Rarrikins> mel-: Not sure if it's bug-free or if there's something better.
11:14:27 <mel-> holy shit! :)
11:14:40 <mel-> i thought i'm asking a rather trivial question about numeric conversion.
11:14:45 <Rarrikins> DrChaos[S]: Yep, but a better way to pass it in is to just call it ys.
11:14:49 <mel-> Rarrikins: thank you very much though
11:15:02 <Rarrikins> mel-: No problem :)
11:15:26 <Rarrikins> Oh, exponent.
11:15:40 <mel-> Rarrikins: oh, yeah. actually...
11:15:41 <DrChaos[S]> Rarrikins, ok, I used your suggestion
11:16:25 <Rarrikins> > let ratToSci :: Int -> Rational -> String; ratToSci places n = if n < 0 then '-':f places (-n) 0 else f places n 0 where f :: Int -> Rational -> Integer -> String; f p n e = if n > 10 then f p (n/10) (e + 1) else if n < 1 then f p (10*n) (e - 1) else show (floor n) ++ ('.':show (round ((n - fromInteger (floor n)) * 10^p))) ++ "*10^" ++ show e in ratToSci 3 (1/70)
11:16:27 <lambdabot>   "1.429*10^-2"
11:16:32 <Rarrikins> There, now with exponents :D
11:16:54 <Rarrikins> DrChaos[S]: That has the effect of also allowing empty lists for ys, but that's OK.
11:17:07 <DrChaos[S]> I'm not quite sure how to do the third stage where we process the second list only because it needs to be something like: mPP [] (y:ys) = y : (mPP [] ys)
11:17:17 <DrChaos[S]> or maybe that's it.
11:17:23 <Rarrikins> DrChaos[S]: Yeh, that's actually right.
11:17:50 <Rarrikins> DrChaos[S]: There's a trick for that part, but that's the way to do it directly.
11:18:24 <mel-> Rarrikins: am I thinking too complicated and working with the Rational numeric type is not very convenient? Basically I've only chosen Rational since at some point in my computation I need to divide and I've triggered typying errors otherwise
11:18:45 <DrChaos[S]> Rarrikins, ok check this out, I think I got an A+: http://vpaste.net/tr4v1
11:19:04 <Rarrikins> mel-: You can use Rational or CReal.
11:19:14 <Rarrikins> mel-: If you need exactness.
11:19:38 <Rarrikins> mel-: It's fairly convenient except for the lack of that function.
11:19:50 <DrChaos[S]> wait, I get a B as there is a non exhaustive pattern for two lists that have just one element in them
11:19:52 <Rarrikins> mel-: All your arithmetic and so on will work just great with rationals.
11:20:10 <Rarrikins> DrChaos[S]: Oh, can you paste your current version?
11:20:36 <elliott> DrChaos[S]: if you handle (x:xs) and [], you don't need to handle (x:[])
11:20:46 <elliott> since (x:[]) matches (x:xs) with xs = []
11:21:03 <mel-> Rarrikins: More important to me than high exactness is that my numbers will be very large and thus I need the type to be unbounded
11:21:04 <elliott> DrChaos[S]: also, if you look at "mPP [] (y:ys) = y : (mPP [] ys)"
11:21:30 <mel-> Rarrikins: More important to me than high exactness is that my numbers will be very large and thus I need the type to be unbounded
11:21:30 <elliott> mPP [] [1,2,3] = 1 : (mPP [] [2,3]) = 1 : 2 : (mPP [] [3]) = 1 : 2 : 3 : (mPP [] [])
11:21:32 <Rarrikins> mel-: Ahh, OK, then Rationals will work, since they use unbounded Integers.
11:21:38 <mel-> Rarrikins: aaah, sorry, for the double post :)
11:21:42 <elliott> DrChaos[S]: so you want mPP [] [] = []
11:21:46 <Rarrikins> mel-: No problem :)
11:21:47 <elliott> DrChaos[S]: but! note how then the result will be [1,2,3]
11:21:52 <elliott> mPP [] [1,2,3] = [1,2,3]
11:21:55 <elliott> so in actuality, all you want is
11:21:58 <elliott> mPP [] ys = ys
11:22:06 <elliott> it makes sense: the empty list, appended to any other list, is just that list
11:22:06 <Rarrikins> Yes, that's the lovely trick :)
11:24:16 <DrChaos[S]> huh? my mPP function isn't actually adding lists together :(
11:24:31 <Rarrikins> Oh, what is your mPP function?
11:24:58 <DrChaos[S]> oh wait
11:25:41 <elliott> DrChaos[S]: if you read what I said it might help you see the problem
11:25:49 <Rarrikins> Yes, that :)
11:27:00 <DrChaos[S]> you just delete this: mPP (x:[]) (y:ys) = x : (mPP [] ys)
11:27:41 <DrChaos[S]> that pattern match (in the right place) causes the function to not add two lists together
11:28:19 <Rarrikins> DrChaos[S]: Yeah, y disappears there.
11:28:32 <DrChaos[S]> if you delete that line, it will work right
11:28:53 <Rarrikins> Yeah, the (x:xs) will handle the x:[] case. Check what elliott said, it's pretty good.
11:29:13 <DrChaos[S]> I only have 2 lines of code in my source file, and it works perfectly!
11:29:38 <Rarrikins> That's how it should be :)
11:29:50 <Rarrikins> The actual definition has two lines (not counting the type signature)
11:29:55 <elliott> @src (++)
11:29:55 <lambdabot> []     ++ ys = ys
11:29:55 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
11:29:55 <lambdabot> -- OR
11:29:55 <lambdabot> xs ++ ys = foldr (:) ys xs
11:30:05 <elliott> spoilers :0
11:30:07 <elliott> *:)
11:30:48 <DrChaos[S]> oh wow, it's a recursive definition!
11:30:55 <Rarrikins> Yeah :)
11:31:57 <DrChaos[S]> here's my final attempt: http://vpaste.net/hlIkM
11:32:04 <DrChaos[S]> it works excellently
11:32:27 <Rarrikins> Yep, that's identical to the definition there.
11:32:34 <Rarrikins> Just replace mPP with ++ in the middle.
11:33:55 <mel-> Rarrikins: I figured something out, but I don't really understand it. See here: http://pastebin.com/RNydA9Fc. The first version is the one we have just discussed (I use the Rational data type and the result of the function computeInterest is a fraction which I would have to convert. But when I replace Rational with the Fractional type class, then the program does exactly what i want.
11:34:12 <mauke> The paste RNydA9Fc has been copied to http://hpaste.org/80020
11:34:38 <mel-> Rarrikins: i.e. the output of computeInterest is a number in scientific notation. do you understand what is going on here?
11:35:03 <DrChaos[S]> what is the syntax for a case expression?
11:35:03 <Rarrikins> mel-: Yeah, Rational is just on Fractional type. I think it probably defaults to doubles, which aren't infinitely precise, but are probably pretty good.
11:35:12 <DrChaos[S]> wait wait, hold on
11:35:18 <Rarrikins> mel-: But that second version will let you change the type easily.
11:37:33 <DrChaos[S]> if I had a job that went by lines of code, I'd get paid like 0.001 cent extra :P
11:37:59 <DrChaos[S]> head xs = case xs of [] -> []; (x:xs) -> x
11:38:16 <Rarrikins> That won't work.
11:38:19 <Rarrikins> See if you can see why.
11:38:26 <Rarrikins> (It'll be a type error)
11:38:30 <`nand`> sure it would; it just doesn't have the type you'd expect
11:38:40 <Rarrikins> Oh, I see.
11:38:42 <Rarrikins> Hehe
11:38:53 <Rarrikins> That won't work.
11:39:03 <Rarrikins> It won't have the right type ;)
11:39:11 <mel-> Rarrikins: So, version two is in this regard preferable I guess. but what about the boundedness? if 'Fractional' defaults to Double -- what happens when I reach the (upper) bound? Does it then switch to a different type?
11:39:14 <DrChaos[S]> Real World Haskell taught me that pattern matchinrg is just syntactic sugar for case expressions
11:39:24 <`nand`> that is correct
11:39:27 <`nand`> or, well
11:39:27 <Rarrikins> mel-: No, it just goes to Infinity.
11:39:31 <`nand`> case expressions /use/ pattern matching
11:39:35 <Rarrikins> mel-: The bigger problem is precision, though.
11:39:44 <Rarrikins> mel-: You'll get accumulated rounding errors.
11:40:07 <`nand`> but eg. f (x:xs) = ...  is sugar for f z = case z of (x:xs) -> ...
11:40:14 <Rarrikins> mel-: Rational both has perfect precision and no upper bound.
11:40:21 <mel-> mhhhh, I don't want no infinity!
11:40:32 <mel-> okay. version 1 is preferable, I get it.
11:40:38 <DrChaos[S]> wtf? it has this weird type: head' :: [[a]] -> [a]
11:40:45 <mel-> i hate numbers!
11:40:46 <`nand`> Infinity is an upper bound of Double
11:41:04 <Rarrikins> mel-: No, just use version two, but ask for Rational results.
11:41:15 <`nand`> (excluding NaN)
11:41:26 <Rarrikins> mel-: Like computeInterest 10.85 250 :: Rational
11:41:35 <elliott> DrChaos[S]: because [] and x have to have the same type
11:41:41 <elliott> so x must be a list
11:41:46 <elliott> so the list inputted must be a list of lists
11:41:48 <elliott> your [] -> [] case is wrong
11:41:49 <Rarrikins> mel-: That'll give you a Rational result, but if it ends up being too slow, getting a Double is very easy.
11:42:22 <elliott> mel-: it can't "switch to another type" because types are decided at compile-time
11:42:34 <Rarrikins> mel-: So, switching the type (in your source code) is very simple.
11:42:42 <elliott> it's just that if you have a value of type (Fractional a => a), it'll become Double by default unless you give it a more specific type signature
11:42:45 <elliott> (at compile-time)
11:42:47 <`nand`> elliott: of course, it could switch to another representation (using a different type)
11:43:29 <mel-> ok ok
11:43:33 <`nand`> (but Double doesn't do that)
11:44:32 <fmcauley> hello
11:45:14 <Rarrikins> Hello!
11:46:09 <byorgey> hi Rarrikins
11:46:22 <byorgey> oh, you were saying hello to fmcauley =)
11:46:27 <byorgey> hi fmcauley =)
11:46:29 <`nand`> hi byorgey
11:46:49 <Rarrikins> You're supposed to say Hello, so that the chain can continue, inadvertently causing us all to say hello to the newcomer :D
11:49:08 <`nand`> somebody once asked in here about how many ‘hello’s it'd take to start off a chain reaction that consumes the entire non-afk channel
11:49:18 <`nand`> I can't find the log :(
11:53:26 <byorgey> `nand`: there's only one way to find out, I guess
11:56:41 <DrChaos[S]> elliott, how can I fix my [] -> [] case?
11:57:09 <DrChaos[S]> I want head' [] to have a result of []
11:57:27 <elliott> DrChaos[S]: if you want it to do that then there's nothing you can do, you have to have that type
11:57:30 <elliott> well
11:57:31 <elliott> I guess you could do
11:57:39 <elliott> head' xs = case xs of [] -> []; x:ys -> [x]
11:57:43 <mel-> Rarrikins: aah, your function isn't too complicated after all :)
11:57:44 <elliott> but then it's the same as
11:57:48 <elliott> > take 1 [1,2,3]
11:57:49 <lambdabot>   [1]
11:57:50 <elliott> > take 1 []
11:57:51 <lambdabot>   []
11:58:12 <elliott> a function cannot have the result [] for some inputs and (1,2) for others
11:59:07 <DrChaos[S]> I don't understand. Why doesn't head' xs = case xs of [] -> []; (x:xs) -> x;
11:59:51 <DrChaos[S]> have the same type as: head' [] = []; head' (x:xs) = x
12:00:04 <Lethalman> @src foldl'
12:00:04 <lambdabot> foldl' f a []     = a
12:00:04 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
12:00:04 <DrChaos[S]> wait, that is an invalid function definition
12:00:24 <DrChaos[S]> I guess [] -> error "empty list" will have to do
12:00:53 <Lethalman> is foldl' tail recursive with that `seq` ?
12:01:17 <DrChaos[S]> yay, it works and has the type I want
12:06:19 <DrChaos[S]> I tried implementing last like this but I get a error: last' [] = []; last' (x:[]) = x; last' (_:xs) = last' xs;
12:07:03 <byorgey> Lethalman: it is not tail recursive, but tail recursion is fairly uninteresting in a lazy language.
12:07:18 <Rarrikins> DrChaos[S]: Yeah, you can't do anything with an empty list.
12:07:37 <Rarrikins> DrChaos[S]: There's no element for that, so it's usually just left undefined.
12:07:44 <Lethalman> @src genericLength
12:07:44 <lambdabot> genericLength []    = 0
12:07:44 <lambdabot> genericLength (_:l) = 1 + genericLength l
12:07:48 <byorgey> DrChaos[S]: that gives an error for the same reason as your old implementation of head'.  You can't sometimes return a list and sometimes return an element of the list.
12:07:58 <Lethalman> byorgey, ^^ how can I calculate the length of a list then without keeping thunks?
12:07:59 <byorgey> since they have different types.
12:08:03 <DrChaos[S]> byorgey, oh
12:08:15 <byorgey> Lethalman: using foldl'.
12:08:52 <Lethalman> byorgey, so if it's not tail recursive, doesn't it keep in memory the call stack?
12:08:58 <DrChaos[S]> but then how does the built in last function do it?
12:09:06 <elliott> tail recursion doesn't really apply to lazy languages as much
12:09:12 <byorgey> Lethalman: no.  The Haskell runtime does not have a call stack.
12:09:18 <elliott> it's a matter of whether you build up computations without evaluating them ("thunks")
12:09:21 <Lethalman> byorgey, sorry?
12:09:36 <DrChaos[S]> I give it a list as input and it gives an item as output
12:09:51 <Lethalman> byorgey, doesn't foldl' accumulate foldl'(foldl'(...... ?
12:10:03 <byorgey> Lethalman: if you want to think about the operational behavior of Haskell programs I suggest you forget everything you think you know about "call stacks" and "tail recursion" =)
12:10:03 <Lethalman> or something like that
12:10:10 <Rarrikins> Lethalman: It just keeps around thunks that are evaluated to various degrees. That's how it knows "where it is" so to speak in its evaluation.
12:10:28 <byorgey> Lethalman: operationally, foldl' behaves like what you would think of as "tail recursion"
12:10:49 <byorgey> but it is not tail recursive according to the definition.  That's why tail recursion is not a useful concept here.
12:11:28 <Lethalman> ok thanks
12:11:32 <Lethalman> let's get to the real question :P
12:11:36 <byorgey> Lethalman: the seq ensures that   f a x  is evaluated before evaluating the recursive call to foldl'.
12:12:15 <Lethalman> anybody can tell me why foldlM (fmap . (\t y -> t+1)) 0 samples works fine while sequence samples >>= \xs -> return (foldl (\a y -> a+1) 0 xs) exceeds the heap size?
12:12:23 <byorgey> Lethalman: sorry, but it is actually an important distinction with practical consequences that you're going to run into eventually.  Better to get it out of the way now. =)
12:12:41 <Lethalman> byorgey, of course, I'm here to learn
12:12:58 <byorgey> oh, I misunderstood your ":P"  =)
12:12:58 <monochrom> @src last
12:12:58 <lambdabot> last [x]    = x
12:12:58 <lambdabot> last (_:xs) = last xs
12:12:59 <lambdabot> last []     = undefined
12:13:40 <Lethalman> byorgey, ;) np that's the chat
12:13:55 <byorgey> Lethalman: what about if you use foldl'  instead of  foldl?
12:14:00 <Lethalman> byorgey, same
12:14:07 <monochrom> undefined has the same status as error. so the built-in last function does it by error, too
12:14:20 <Lethalman> byorgey, the monad in question is the random monad
12:14:43 <Lethalman> byorgey, it's like the problem resides somewhere in sequence, don't know why
12:14:48 <byorgey> Lethalman: (btw, there are essentially zero situations where you want to use foldl, you should always use foldl' instead)
12:15:03 <Lethalman> alright
12:15:13 <Lethalman> byorgey, it was just to match foldlM
12:15:20 <byorgey> fair enough
12:15:35 <byorgey> Lethalman: and how long is 'samples'?  just curious
12:15:46 <Nereid> > foldl (const id) undefined [1,undefined,3]
12:15:47 <lambdabot>   3
12:15:49 <Nereid> > foldl' (const id) undefined [1,undefined,3]
12:15:50 <lambdabot>   *Exception: Prelude.undefined
12:16:07 <Lethalman> byorgey, heap size is 100m and samples is 10000000 of graphs
12:16:19 <Nereid> this is one of the zero situations where you'd use foldl over foldl'
12:16:37 <Lethalman> byorgey, didn't let the foldlM end but well...
12:16:57 <Rarrikins> Nereid: Haha
12:16:58 <Lethalman> the sequence version ends with heap exhausted very fast
12:17:06 <Nereid> but if you are folding with a strict function, always use foldl'
12:17:07 <Lethalman> and I can't understand why
12:17:14 <Rarrikins> It has a zero probability of being useful.
12:17:21 <Nereid> :p
12:18:15 <Lethalman> I'm just learning haskell and the fact that the sequence version is not lazy as expected is annoying :(
12:18:44 <elliott> if you run out of memory probably it's too lazy
12:19:00 <Lethalman> elliott, I expect it to count a list of elements in [m a]
12:19:08 <Lethalman> elliott, and I expect it to do it step by step
12:19:18 <Lethalman> I'd like to understand why the sequence version goes oom
12:19:46 <elliott> well, I haven't seen your code
12:19:49 <nus> @src sequence
12:19:49 <lambdabot> sequence []     = return []
12:19:50 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
12:19:50 <lambdabot> -- OR: sequence = foldr (liftM2 (:)) (return [])
12:19:59 <elliott> counting the list of elements in [m a] is easy though, you can just use length!
12:20:00 <Lethalman> elliott, foldlM (fmap . (\t y -> t+1)) 0 samples works fine while sequence samples >>= \xs -> return (foldl (\a y -> a+1) 0 xs) exceeds the heap size
12:20:02 <nus> @src [] (>>=)
12:20:02 <lambdabot> xs >>= f     = concatMap f xs
12:20:13 <Lethalman> elliott, yes sorry, I have to filter based on a
12:20:18 <Lethalman> elliott, this is a simpler case
12:20:19 <nus> @src concatMap
12:20:20 <lambdabot> concatMap f = foldr ((++) . f) []
12:21:25 <Nereid> = concat . map f
12:21:41 <Rarrikins> Now with fusion!
12:21:44 <Lethalman> elliott, sequence samples >>= \xs -> return (genericLength $ filter satisfy xs) is the real stuff, but I threw the filter because apparently that's not the problem
12:21:44 <Nereid> sure.
12:21:48 <elliott> > let foo f = fmap length . filterM f in foo (>2) [[],[1,2],[3,4,5]]
12:21:49 <lambdabot>   Couldn't match expected type `f0 GHC.Types.Bool'
12:21:49 <lambdabot>              with actual t...
12:22:01 <elliott> > let foo f = fmap length . filterM (fmap f) in foo (>2) [[],[1,2],[3,4,5]]
12:22:03 <lambdabot>   []
12:22:03 <Nereid> foldr f z . map g = foldr (f . g) z
12:22:06 <elliott> oh
12:22:10 <elliott> I guess that's slow
12:22:33 <elliott> > let foo f = fmap (length . filter f) . sequence in foo (>2) [[],[1,2],[3,4,5]]
12:22:35 <lambdabot>   []
12:22:45 <elliott> Lethalman: the problem isn't anything to do with your sequence really
12:22:49 <elliott> it's to do with your foldl
12:22:55 <elliott> if you use the real length and filter it'll be fine
12:23:03 <elliott> genericLength is lazy on purpose, so you can use it with lazy result types
12:23:14 <Lethalman> elliott, ah!
12:23:16 <Lethalman> @src length
12:23:16 <lambdabot> Source not found. Maybe if you used more than just two fingers...
12:23:26 <Lethalman> @src [] (length)
12:23:26 <lambdabot> Source not found. You speak an infinite deal of nothing
12:23:51 <byorgey> elliott: are you sure?  what's wrong with Lethalman's foldl?
12:24:16 <elliott> > foldl (\a y -> a+1) 0 [1..10000]
12:24:17 <byorgey> Lethalman already said the same thing happens with foldl' in place of foldl
12:24:17 <lambdabot>   10000
12:24:25 <elliott> oh
12:24:30 <elliott> the genericLength mislead me, I guess
12:24:55 <elliott> I'm not sure what the leak could be if it's really as simple as "sequence samples >>= \xs -> return (genericLength $ filter satisfy xs)"
12:24:55 <Lethalman> elliott, sequence foo >>= \xs -> return (length xs) still goes oom
12:25:12 <elliott> what about "sequence foo"? does that go oom?
12:25:24 <elliott> what monad are you using?
12:25:33 <Lethalman> elliott, random monad
12:25:47 <Lethalman> elliott, sequence foo itself doesn't go oom, neither take 10 of the sequence does
12:25:51 <Lethalman> ah no wait
12:25:56 <DrChaos[S]> how does the last function take a list as input and give you a single item as output?
12:26:11 <elliott> Lethalman: which random monad?
12:26:16 <Rarrikins> DrChaos[S]: It's written to do that.
12:26:25 <Lethalman> elliott, http://hackage.haskell.org/packages/archive/MonadRandom/0.1.3/doc/html/Control-Monad-Random.html
12:26:36 <Rarrikins> DrChaos[S]: It throws away all elements until the list only has one, and it gives you that one.
12:26:50 <byorgey> for some monads, sequence introduces strictness, because it can't actually decide what to output before looking through the entire input list (thus resulting in the whole list in memory at once)
12:27:08 <byorgey> but I wouldn't have thought that was the case for Rand.
12:27:19 <Lethalman> let me show you the complete code, it's very simple
12:27:24 <DrChaos[S]> Rarrikins, err...I don't know how it does that
12:27:53 <elliott> I see RandT uses lazy State
12:27:55 <elliott> is that really intentional?
12:28:01 <Lethalman> let me show you the complete code, it's very simple: http://paste.debian.net/220661/
12:28:08 <elliott> tempted to lay the blame on MonadRandom here
12:28:19 <Lethalman> the relevant code is in montecarlo
12:28:22 <byorgey> elliott: why should lazy State matter?
12:28:41 <elliott> I guess it shouldn't here
12:28:56 <byorgey> elliott: if it keeps demanding the value of the generator it can't build up a thunk of the state
12:29:05 <Lethalman> I get N random samples and want to count the number of satisfying samples
12:29:23 <elliott> byorgey: yeah
12:30:35 <byorgey> and I can confirm that Rand seems lazy, i.e.   let r = getRandom :: Rand StdGen Int in evalRandIO $ sequence [r,r,undefined]  actually prints out two random Ints before crashing
12:31:19 <byorgey> so it seems like one should be able to consume the output of 'sequence' lazily, without consuming a ton of memory
12:31:40 <byorgey> Lethalman: are you compiling with -O2 ?
12:31:41 * elliott is a bit baffled as to what's wrong her
12:31:42 <elliott> e
12:31:45 * byorgey too
12:32:52 <Lethalman> byorgey, yes, goes oom with 100m and 5000000 samples
12:32:54 <c_wraith> that's not the correct definition of lazy
12:33:32 <c_wraith> if you could consume the result of sequence incrementally, you could go ... sequence (r:r:undefined)
12:33:58 * hackagebot persistent-mongoDB 1.1.4 - Backend for the persistent library using mongoDB.  http://hackage.haskell.org/package/persistent-mongoDB-1.1.4 (GregWeber)
12:34:20 <Lethalman> I was wrong about foldlM (fmap . (\t y -> t+1)) 0 samples, this one goes oom too
12:35:13 <elliott> are you sure you don't just not have enough memory to compute what's required? :P
12:35:24 <Lethalman> elliott, with less samples it works fine
12:37:37 <Lethalman> is there anything I can do? profiling maybe?
12:37:57 <elliott> profiling might be a good idea, yeah
12:39:31 <byorgey> c_wraith: oh, right, sorry. But that works too.
12:41:29 <Lethalman> here http://book.realworldhaskell.org/read/profiling-and-optimization.html it says +RTS -hc -p -K100M
12:41:30 <Lethalman> 500000.5 but -hc and -p are not valid options
12:41:30 <DrChaos[S]> how does the last function take a list as input and give you a single item as output?
12:42:13 <byorgey> Lethalman: try compiling with +rtsopts ?
12:42:23 <byorgey> I mean -rtsopts
12:42:35 <byorgey> DrChaos[S]: well, in the empty list case it throws an error
12:42:37 <DrChaos[S]> opps, I see that somebody said that it discards elements of a list until it gets to the last one, and then it returns the last element
12:42:42 <Lethalman> byorgey, I did, in fact I'm using -M100m but -hc and -p don't exist
12:42:48 <byorgey> hmm
12:42:49 <DrChaos[S]> but I don't know how it's coded to do that
12:42:50 <byorgey> not sure then
12:43:01 <DrChaos[S]> I don't know how to do the same thing
12:43:04 <elliott> did you compile with profiling?
12:43:15 <byorgey> DrChaos[S]: you can pattern-match on a single element list like this:  last [x] = ...
12:43:20 <Lethalman> elliott, yes
12:43:27 <byorgey> DrChaos[S]: that will match only on a list of length exactly 1, with an element called x
12:43:30 <Lethalman> elliott, -hc and -p don't exist
12:43:59 <DrChaos[S]> byorgey, I got that one down, but I don't understand how last can have a type signature of [a] -> a and do what it does
12:44:09 <Lethalman> elliott, ah -prof maybe?
12:44:19 <elliott> -prof -auto-all
12:44:42 <byorgey> DrChaos[S]: Hmm, I am not understanding your confusion.  You are trying to write last yourself, I suppose?
12:45:02 <Lethalman> elliott, ok thanks
12:45:17 <Lethalman> elliott, says I need monad random profiling libraries
12:45:26 <elliott> yep you need profiling libraries to profile your code
12:45:37 <DrChaos[S]> byorgey, yes
12:45:40 <byorgey> DrChaos[S]: ok, so let's go through the possibilities
12:45:44 <byorgey> DrChaos[S]: last [] = ?
12:45:51 <DrChaos[S]> last [] = []
12:45:58 <byorgey> no
12:46:03 <byorgey> that doesn't have the right type
12:46:03 <DrChaos[S]> oh, I see
12:46:13 <DrChaos[S]> last [] = error "empty list"
12:46:16 <byorgey> right
12:46:37 <byorgey> last [x] = ?
12:46:42 <DrChaos[S]> last (x:[]) = x
12:46:49 <byorgey> right
12:46:51 <byorgey> same thing
12:46:57 <byorgey> and (x:xs)?
12:47:06 <DrChaos[S]> last (_:xs) = last xs
12:47:11 <byorgey> yep
12:47:22 <byorgey> huzzah!
12:47:32 <mreh> \o/
12:48:42 <mreh> which, if any, alsa binding would you recommend
12:48:57 <mreh> is there an alternative to henning thielman's?
12:49:08 <mel-> When I have a type signature 'foo :: (Fractional a) => a', why can't I define 'foo = 0 :: Rational'? Doesn't Rational belong to the Fractional type class?
12:49:13 <mel-> what am I doing wrong?
12:49:19 <c_wraith> my experience with cross-platform audio programming leads me to this advice: "Just don't do it. It's not worth it."
12:49:56 <applicative> mel-: foo :: Rational
12:50:02 <fmap> mel-: http://stackoverflow.com/a/14088797/972985
12:50:04 <c_wraith> mel-: You are interpreting it backwards.  In haskell, the caller of a function gets to decide what type the type variables map to.
12:50:28 <c_wraith> ....  and fmap just linked to my long answer on the topic.  nice.  :)
12:50:49 <mel-> (basically I had a compile time error in a bigger program (10 lines) and have reduced the problem to this two liner -- that's why it seems so awkward)
12:51:09 <mreh> c_wraith, but I want to :(
12:51:29 <applicative> what is the definition attached to foo :: (Fractional a) => a
12:51:49 <applicative> mel-: oh it's foo = 0 :: Rational??
12:51:53 <c_wraith> mreh: I wanted to once. But maybe you have more strength of will than I do. Don't give up your dreams!
12:52:35 <mreh> c_wraith, it's not *that* cross platform
12:52:48 <mreh> how hard can it be to use alsa to play PCM?
12:53:07 <Lethalman> elliott,  byorgey, this is the hp file: http://paste.debian.net/220669/
12:53:11 <applicative> mel-: It sounds like you want a foo in all Fractional types, but always in Rational
12:53:48 * elliott would use the time profiling instead
12:53:52 <elliott> but that's just me
12:53:54 <mel-> This is my program: http://pastebin.com/cdwwt3Q9. It works alright when I remove the definition of 'interestRate' and replace it in the source with a numeric literal.
12:53:56 <elliott> I've never been good at hps
12:54:00 <elliott> Lethalman: you probably want to render that though
12:54:06 <elliott> e.g. with http://heap.ezyang.com/
12:54:11 <mauke> The paste cdwwt3Q9 has been copied to http://hpaste.org/80022
12:54:33 <c_wraith> mreh: actually, as I understand it, alsa has a really cool design - it exposes a filesystem device that you can write to, and select() on to see when it needs more data. The problems with it are massive hardware incompatability and bugginess
12:55:21 <applicative> mel-: yeah, you cant have interestRate in line 12 if it's Rational. Then you;d have to change the signature of computeInterest
12:55:40 <Lethalman> elliott, http://heap.ezyang.com/view/c22d319276422a52edcee9390ec2245958ca8c17#form is that fine?
12:56:00 <Lethalman> I don't know what that means :S
12:56:01 <elliott> yes but I'm still hopeless at interpreting it :)
12:56:06 <mel-> applicative: is there any other/better workaround than to change the type signature of computeInterest?
12:56:08 <c_wraith> mel-: The problem is that the type signature "(Fractional a) => a" means "any type the *user* of this value wants". But then you're saying "Also, it's Rational".  Rational isn't any type, so the compiler says "hold on"
12:56:22 <applicative> mel-: if interestRate is a Rational, then interestAfterOneYear interestRate is a Rational
12:56:29 <mel-> c_wraith: okay, I understand the problem.
12:56:38 <mel-> now I want to understand the (best) solution :)
12:56:53 <Lethalman> elliott, what should I do?
12:57:11 <elliott> find someone who can read heap profiles, probably
12:57:49 <applicative> mel-: I think you should be using exponent ^ or whatever, no?
12:57:59 <applicative> @type (^)
12:57:59 <mel-> applicative: what for?
12:58:00 <lambdabot> (Integral b, Num a) => a -> b -> a
12:58:27 <mel-> do you mean instead of iterate?
12:58:50 <Lethalman> elliott, do you want me to upload the time profiling?
12:59:00 <Lethalman> elliott, btw this is the per-type heap profiling: http://heap.ezyang.com/view/e81e2689f1b691ae9b208a2396e0de01265ed273#form
12:59:02 <applicative> mel-: as it stands you are telling the compiler 'multiply by z' a number of times
12:59:55 <applicative> mel-: yes. 10 ^100 is likely to be more efficient than iterate (*10) 1 !! 100
13:00:07 <mel-> applicative: i don't understand what you consider to be a problem. i have a function f and i want to apply this function n times. i.e. f(f(....(f(x))))
13:00:54 <mel-> applicative: you're right, that would be more compact. but is this related to my compile time error/
13:01:39 <applicative> mel,  the f is (* (1 + 5 / 100)) but yes this is independent of the compile error of course
13:02:34 <mdmkolbe> How do I catch a keyboard "ctrl-C" in a Haskell program on Windows?  (I'm on Linux, but I'd like my app to be portable.)
13:02:50 <mel-> applicative: i'm just slightly confused about how to fix this problem in a 'haskellish' way. your suggestion was to get rid of the typeclass and instead use a fixed type like Rationa. That would probably work.
13:04:22 <applicative> mel-: yes. My efficiency point was related to the use of Rational, which is a precise type, so  you are asking for a repeated expensive operation, rather than one ^ operation
13:04:48 <hpc> mdmkolbe: catch the signal instead; windows has its own shortcut for that, i thin
13:05:09 <hpc> and that should be "more portable" than implementing your own linux conventions
13:05:10 <Nereid> mdmkolbe: catch a UserInterrupt
13:05:13 <hpc> maybe
13:05:34 <applicative> mel-: it's a question have many years you are envisaging the loan running ...
13:06:27 <Nereid> mdmkolbe: this works on both windows and linux
13:06:35 <mel-> applicative: true. i've changed it. works.
13:07:40 <mdmkolbe> Nereid: thx, that looks like what I need
13:08:16 <mel-> applicative: well, that's funny. i have seen a tv show the other day about our financial system. and it was about 'compound interest' vs 'simple interest'. the question is the following: imagine joseph would have opened an account for jesus with one cent. how much money would be in this account today when adding compound interests.
13:09:05 <mel-> applicative: the result was something like: the money equivalent to several hundreds (or thousands?) balls of the size of the earth of pure gold.
13:09:38 <mel-> my result is actually 4.29e41 EUR.
13:09:51 <mel-> I dunno how many gold-planets this would be, though. :-D
13:11:40 <applicative> mel-: ah, if one penny had been invest at the birth of our Saviour, ... once much loved in the British  Parliament
13:11:46 <applicative> invested
13:12:48 <mel-> i'll try to compute it in gold :)
13:13:26 <ivanm> the LICENSE file for my project is in markdown; would there be any problems if I actually added a ".md" extension on to that so that hub.darcs.net, etc. treat it as markdown?
13:14:56 <byorgey> ivanm: should be OK, as long as you have  license-file: LICENSE.md  in your .cabal file
13:15:05 <ivanm> *nod*
13:15:11 <ivanm> that's what I thought, but I figured I'd check first
13:15:15 <Lethalman> ok from this program: http://paste.debian.net/220672/ I get the following heap profiling: http://heap.ezyang.com/view/423a32fa9d46f5bdb2a25dc02aae18add6414389#form
13:15:17 <Lethalman> anybody can help?
13:15:27 <ivanm> the only possible issue I can think of is any distro toolchains that assume it's either LICENSE or COPYRIGHT
13:15:29 <Lethalman> can't solve this problem since afternoon :S
13:15:34 <Lethalman> may it be caused by the random monad?
13:15:52 <byorgey> ivanm: yeah, I don't know about that, I've never actually tried having anything other than LICENSE
13:16:22 <byorgey> oh, look at all those nice Identity wrappers accumulating =P
13:16:40 <Lethalman> byorgey, what does it mean? :-(
13:16:43 <ivanm> Lethalman: do you have a profiling report?
13:16:54 <Lethalman> ivanm, http://heap.ezyang.com/view/423a32fa9d46f5bdb2a25dc02aae18add6414389#form
13:17:07 <ivanm> no, actual profiling
13:17:11 <byorgey> Lethalman: yes, looks like this is Rand's fault
13:17:12 <Rarrikins> 2.566×10^37 oz (gold ounces)
13:17:14 <ivanm> not a heap profile; the actual .prof file
13:17:21 <Lethalman> ivanm, how to generate it?
13:17:32 <ivanm> don't have the -hy flag
13:17:40 <ivanm> or else it will be there from your run, as a .prof file
13:17:40 <Lethalman> byorgey, what alternatives do I have?
13:17:59 <applicative> mel-: I'm getting 2391102204613552275946115709099559605695785 units for 1 unit at 5% on 'birth of our Saviour'
13:18:09 <Lethalman> ivanm, http://paste.debian.net/220673/
13:18:41 <ivanm> Lethalman: I highly recommend that you distinguish pretty-printing from the Show instance
13:18:43 <Nereid> mdmkolbe: also note: http://stackoverflow.com/questions/2349233/catching-control-c-exception-in-ghc-haskell
13:18:49 <ivanm> (I know FGL doesn't, and I should probably fix that one day)
13:19:05 <Nereid> mdmkolbe: although apparently this doesn't happen in Windows
13:19:16 <Rarrikins> I get $42940760203210743565647841210414542094336 after 2012 years.
13:19:22 <Lethalman> ivanm, ok, is that an issue to the profiling perhaps?
13:19:35 <ivanm> no, not really
13:19:43 <byorgey> Lethalman: well, ideally we will fix MonadRandom
13:19:43 <Lethalman> ok, it was just for styling then...
13:19:52 <byorgey> but I still don't understand the problem very well
13:20:07 <ivanm> the profiling doesn't mention MonadRandom ;s
13:20:14 <byorgey> ivanm: but it does mention Identity
13:20:25 <byorgey> ivanm: and Rand is defined as a newtype of RandT Identity
13:20:35 <ivanm> byorgey: no, the actual .prof file: http://paste.debian.net/220673/
13:20:39 <byorgey> so I assumed that's where it's coming from
13:20:40 <byorgey> oh.
13:21:01 <ivanm> though the actual montecarlo function is where the alloc is coming from
13:21:14 <ivanm> maybe it's because Lethalman didn't compile with -auto-all ?
13:21:21 <byorgey> ivanm: but that heap view Lethalman linked does mention Identity
13:21:25 <Lethalman> ivanm, I did
13:21:25 <ivanm> yeah
13:21:38 <ivanm> Lethalman: how about -caf-all ?
13:22:15 <mel-> applicative: 239.... i think you have used numberOfYears = 2000, no?
13:22:23 <Lethalman> ivanm: http://paste.debian.net/220675/
13:22:36 <cmccann> man, how did Lethalman get from avoiding sequencing a large list to finding problems with the Rand monad? :P
13:22:38 <mel-> applicative: for 2012 the number begins with 429... for me
13:23:05 <Lethalman> cmccann, looks like your foldlM version also exceeds the heap size :-(
13:23:09 <cmccann> aww.
13:23:17 <ivanm> hmmmm.... maybe a bang on samples, res and x in the montecarlo function?
13:23:40 <Lethalman> ivanm, eek, samples is 2000000 long :)
13:23:41 <byorgey> cmccann: the sequencing isn't the problem, because Rand is sufficiently lazy
13:23:51 <cmccann> I just got back so I didn't see the conversation, is the Rand monad building up a huge thunk on the seed?
13:24:05 <byorgey> Lethalman: note a bang will only evaluate things to weak head normal form
13:24:16 <byorgey> Lethalman: which for a list means just enough to see whether it is empty or cons
13:24:17 <cmccann> byorgey, well I think his original version would have blown up for its own reasons
13:24:23 <cmccann> but maybe it was just Rand all along
13:24:27 <byorgey> cmccann: that's quite possible
13:24:29 <applicative> mel- wait I was using my revision, maybe somethings wrong .
13:24:41 <Lethalman> cmccann, the code is: http://paste.debian.net/220672/ the -hy profiling: http://heap.ezyang.com/view/423a32fa9d46f5bdb2a25dc02aae18add6414389#form and .prof: http://paste.debian.net/220675/
13:24:42 <applicative> here's the immortal quote from Price at the bottom http://books.google.com/books?id=vQsMAAAAMAAJ&pg=PA707&lpg=PA707&dq='one+penny+put+out'+%22Saviour's+birth%22&source=bl&ots=jREZbll1ab&sig=MZctYySJdJ-4YymVQy2f_42nX6g&hl=en&sa=X&ei=PALiUL_oJsuH0QGv_oGYDQ&ved=0CFgQ6AEwCg#v=onepage&q='one%20penny%20put%20out'%20%22Saviour's%20birth%22&f=false
13:24:45 <byorgey> Lethalman: (however, I personally don't think ivanm's suggestion will help)
13:25:15 <cmccann> that's a lot of Identity.
13:25:36 <ivanm> byorgey: yeah, probably not
13:25:43 <byorgey> cmccann: that's what I said.
13:25:49 * applicative hadn't realized that compound interest madness had also afflicted our US Founding Fathers
13:26:11 <byorgey> presumably it's coming from Rand = RandT Identity
13:26:12 <Lethalman> what is stg_sel_upd ? I read from some search it's related to thunks
13:26:35 <mel-> i like Haskell, but I really need to get used to the strong type system :)
13:26:57 <Lethalman> there's something in my code preventing from discarding elements in the list maybe??
13:27:13 <Lethalman> the sample function perhaps is broken?
13:27:21 * Lethalman tries with a simple mkAAF
13:29:08 <byorgey> Lethalman: if I were you, at this point I would send an email to the haskell-cafe mailing list with links to your code and the profiling reports.
13:29:12 <Lethalman> mh no, still the same
13:29:26 <byorgey> there are certainly people who can figure out what is going on but they do not happen to be looking at IRC at this moment.
13:29:36 * cmccann is really not an expert at reading haskell profiling output :[
13:29:53 <Lethalman> byorgey, :(
13:30:04 <byorgey> Lethalman: why :( ?
13:30:28 <Lethalman> byorgey, is there any alternative to monad random that you know?
13:30:36 <byorgey> no.
13:30:41 <neutrino_> .
13:30:48 <cmccann> could just use the System.Random stuff and the strict state monad
13:30:54 <cmccann> if lazy state is the suspected problem
13:31:11 <cmccann> unless MonadRandom has other features that you're relying on?
13:31:20 <applicative> mel-: another way to harmonize the types and classes, insisting on interestRate::Rational  http://hpaste.org/80022
13:31:22 <Lethalman> cmccann, just the ones in the code
13:31:40 <mel-> does anybody know what the 'strategy' regarding Gtk3 will be? Updating Gtk2Hs or instead switching to gobject-introspection completely?
13:31:50 <Lethalman> cmccann, getRandoms maybe, but that seems simple to implement
13:32:04 <cmccann> Lethalman, ok, so you can just look at http://hackage.haskell.org/packages/archive/MonadRandom/0.1.8/doc/html/src/Control-Monad-Random.html
13:32:17 <cmccann> and then do the same stuff using the strict state monad
13:32:20 <Lethalman> \o/
13:32:21 <cmccann> and see if that helps
13:32:25 <elliott> cmccann: we decided the lazy state should be fine
13:32:31 <cmccann> oh, ok.
13:32:34 <cmccann> then what isn't fine? :P
13:32:48 <cmccann> I don't see why anything should be building up thunks here.
13:33:01 <cmccann> and everything in Lethalman's code itself seems straightforward.
13:33:10 <elliott> we have no idea
13:33:22 * Lethalman might given another look at haskell the next year :P
13:33:23 <cmccann> ok.
13:33:24 <Lethalman> *give
13:33:32 <Lethalman> or better... the next next year
13:33:52 <mel-> applicative: hmmm
13:34:25 <cmccann> Lethalman, you said before that my code seemed to work--what changed? were you running it on a smaller list then?
13:34:51 <Lethalman> cmccann, probably took longer and I thought it wasn't going oom
13:34:58 <cmccann> ah
13:35:12 <cmccann> so maybe an improvement after all, but not enough
13:35:23 <Lethalman> cmccann, foldlM (fmap . (\a y -> a+1)) samples right?
13:35:53 <Lethalman> where samples = replicate n sample
13:36:19 <cmccann> something like that yeah
13:36:30 <mel-> applicative: i see, thanks
13:37:56 <cmccann> hm
13:40:16 <Lethalman> cmccann, yes, but this time: http://heap.ezyang.com/view/2b8129868dc19841565b9e3d8fada32ee55ddafd#form
13:40:38 <Lethalman> cmccann, with x <- foldlM (fmap . (\a _ -> a+1)) 0 $ replicate n sample
13:40:45 <cmccann> heh, BLACKHOLE
13:41:10 <Lethalman> what's that?
13:41:31 <cmccann> I forget, but I think it involves evaluating nested thunks?
13:41:51 <Lethalman> suddenly Identity disappeared
13:42:10 <joar> RWH was certainly better than "The Hitchhiker's Guide to Haskell", thank you all who tipped me off.
13:42:17 * Lethalman really wished to learn haskell... do you think writing my random monad will fix it?
13:42:39 <cmccann> Lethalman, actually, how about trying it without using a random monad at all?
13:43:05 <Lethalman> cmccann, with a [1..2000000] it just works, what should I use instead of the random monad?
13:43:39 <cmccann> System.Random
13:44:04 <Lethalman> ok
13:44:54 <cmccann> you'll need to pass the PRNG around yourself, which is what the rand monad does for you
13:44:58 <applicative> mel-: here is the simpler version I was using http://hpaste.org/80025
13:45:02 <Lethalman> cmccann, I'll try
13:45:18 <cmccann> Lethalman, actually you can leave most of it alone
13:45:18 <Lethalman> cmccann, the problem is in calling "sample" repeatedly with the new prng everytime
13:45:23 <pnielsen> use mersenne twister or mwc if it's for statistics imo
13:45:47 <pnielsen> http://hackage.haskell.org/package/mwc-random-0.12.0.1
13:45:47 <cmccann> just use runRand or whatever on the sample function, it should be fine by itself
13:46:17 <pnielsen> R uses MT by default, FWIW
13:47:19 <cmccann> Lethalman, then just have a recursive function that takes a seed value, generates a sample, then recursively calls itself with the new seed to produce a lazy list
13:47:33 <cmccann> I can show you what I mean if it's not clear
13:47:42 <pnielsen> joar: LYAH is also great
13:47:55 <cmccann> sorry this is so annoying, normally I'd tell people to just something like MonadRandom BUT...
13:48:00 <pnielsen> joar: http://www.learnyouahaskell.com/
13:48:23 <troydm> happy new year haskell gurus!
13:48:34 <Lethalman> cmccann, np I can do it
13:49:27 <joar> pnielsen: Heard so, I just chose RWH because I liked the design better, AFAICT they both cover mostly the same areas.
13:49:31 <Lethalman> pnielsen, thank you will take a look at it after this test
13:50:21 <pnielsen> joar: kind of. RWH has more involved, practical examples. LYAH is more linear/connected. I found LYAH easier to read/more beginner-friendly, but I think both books are great
13:50:43 <pnielsen> joar: I also think they complement each other. It's not just the same book phrased differently
13:50:59 <cmccann> LYAH seems nicer as an introduction, though I never read the whole thing
13:51:19 <cmccann> RWH is a nice skim-and-reference book for specific topics with some good examples throughout
13:51:28 <pnielsen> yep
13:51:52 <cmccann> (didn't hear about LYAH until I was already pretty comfortable with Haskell, I think)
13:51:58 <cmccann> (also he was still writing it at that point)
13:52:12 <elliott> I think RWH is really bad for learning stuff initially since it is outdated in several ways
13:52:19 <elliott> whereas LYAH fixes are just like s/State/state/
13:52:44 <joar> Haskell is my fifth-or-so language, I'm stressing about learning it a bit, and threw myself into "The Hitchhiker's Guide to Haskell" but when going through that it never felt as if I understood why I did the things I did as I copied the examples verbatim. Then I came in here and asked some questions about type signatures, etc
13:52:54 <joar> .. and then RWH and LYAH came up
13:53:31 <cmccann> clearly people should start with the gentle introduction
13:53:38 <cmccann> it must be good for beginners because it is gentle
13:53:42 <cmccann> like it says right in the name
13:53:42 <Philippa_> and then go learn ML so they have the background for it
13:54:20 <zomg> joar: best to write some haskell, I didn't really learn any of it from just reading the stuff until I had spent a lot of time coding
13:54:38 <mel-> thanks, i'm off!
13:55:01 <joar> I've been skipping some fluffy parts of RWH, I'm currently on the third chapter and it feels far better.
13:55:13 <joar> I might read LYAH if I ever find the time.
13:55:14 <Eduard_Munteanu> cmccann: it's pretty good if you're looking for a reference, sometimes LYAH is too verbose / tutorial-y
13:55:33 <joar> zomg: I'm following the examples in my editor.
13:55:43 <joar> just to get the syntax into muscle memory
13:56:01 <Eduard_Munteanu> I guess it depends whether you trust LYAH with teaching you vs looking up topics yourself.
13:56:04 <zomg> Sure, I did that kind of stuff too but I didn't really "get" it until I did things myself
13:56:11 <zomg> For example, I sort of understood what a monoid was
13:56:16 <cmccann> Eduard_Munteanu, for most "reference" purposes at the level of an intro like LYAH I just look at the Haskell Report or GHC User's Guide
13:56:23 <zomg> but I didn't really get it until I wrote my own data type that was a monoid instance
13:56:40 <joar> zomg: I have a vague feeling about what a monad is, but I would not say that I know.
13:57:03 <applicative> LYAH is more in the nature of a tutorial than a language definition
13:57:09 <joar> zomg: and of course, not even the "Real World" Haskell tutorial will prepare anyone for the real world.
13:57:10 <cmccann> joar, a monad is a way of generating large numbers of very bad tutorials
13:57:16 <joar> as with any study
13:57:27 <cmccann> speaking of which, most monad tutorials are terrible, so be careful :P
13:57:31 <joar> cmccann: That's spot on.
13:57:34 <zomg> yeah it seems to me that many of the tutorials and "what is a monad" things are just making it harder to understand what it is
13:58:03 <cmccann> zomg, I am nearly certain that with some time and effort that could proven empirically using double-blind studies
13:58:05 <zomg> it seems very few really just define it as what it is: a typeclass which defines >>=, >> and return :P
13:58:14 <joar> I read a part about something similar to "monads in every language" with python examples, I can't understand it.
13:58:15 <applicative> joar: yes always ask here before reading any given monad tutorial, some are on the index of forbidden tutorials
13:58:19 <latro`a> not really even >> :p
13:58:49 <applicative> the Index Tutoriorum Prohibitorum
13:58:51 <latro`a> actually...can anyone come up with an example where the default >> and a valid custom >> have different strictness properties?
13:58:52 <joar> it's like sex, I guess.
13:58:56 <joar> monads, that is.
13:58:58 <Lethalman> I read http://www.engr.mun.ca/~theo/Misc/haskell_and_monads.htm and was very clear
13:59:17 <cmccann> most people seem to like sigfpe's explanation, and I've heard no complaints about LYAH's explanation
13:59:19 <applicative> "New: Updated to Haskell '98."
14:02:27 <snowylike> now this might be an annoying question, but what is the point of lenses?
14:02:40 <cmccann> what ISN'T the point of lenses?
14:02:43 <cmccann> that is a better question.
14:02:49 <ivanm> cmccann: world peace? :p
14:02:55 <ivanm> after all, it encourages stabbing! :p
14:02:55 <joar> what IS lenses?
14:03:12 <byorgey> what IS?
14:03:14 <applicative> actually http://www.engr.mun.ca/~theo/Misc/haskell_and_monads.htm looks pretty good as Lethalman says
14:03:17 <cmccann> what?
14:03:20 <ivanm> joar: IIUC, at the lowest level it lets you define getters/setters for data types
14:03:32 <r00723r0> Is it possible to make a function whose parameters and return value have undefined type?
14:03:32 <applicative> it also has the sense to link Wadlers tutorials
14:03:33 <Eduard_Munteanu> joar: an abstraction for setters/getters
14:03:42 <joar> what IS setters/getters?
14:03:43 <cmccann> I think it was snowylike who asked...
14:03:46 <ivanm> r00723r0: as in a polymorphic type?
14:03:50 <cmccann> first, at least.
14:04:01 <joar> http://en.wikipedia.org/wiki/Mutator_method ?
14:04:02 <r00723r0> ivanm: as in untyped.
14:04:04 <edwardk> snowylike: https://www.youtube.com/watch?v=cefnmjtAolY&hd=1 is a fairly long explanation i give on the topic of what lenses are and why you should care
14:04:06 <snowylike> yes, but i don't care who is adressed, as long as i see the answer
14:04:07 <ivanm> joar: consider the snd function: (a,b) -> b
14:04:15 <cmccann> snowylike, anyway, yes, it's an abstraction for getting and setting components of a value, like record fields
14:04:20 <applicative> haha speak of the devil and edwardk appears
14:04:21 <ivanm> r00723r0: use () or Void ?
14:04:28 <cmccann> so that they're first-class entities, unlike the built-in record field syntax
14:04:29 <Eduard_Munteanu> joar: you have a datatype containing a bunch of values, lenses give you a composable way of looking up / setting / modifying those values.
14:04:31 <ivanm> edwardk: is that downloadable yet?
14:04:43 <r00723r0> ivanm: so there's no general way to accept or return an untyped expression?
14:04:58 <cmccann> applicative, I'm pretty sure edwardk has his client ping him if anyone says "lens"
14:05:04 <cmccann> either that or he's just always watching
14:05:06 <cmccann> or both
14:05:07 <ivanm> r00723r0: I'm not reallly sure what you're after; can you give an example?
14:05:18 <r00723r0> ivanm: I'm not after anything -- just trying to grasp Haskell.
14:05:22 <applicative> cmccann: I have long since noticed, but am still amazed
14:05:25 <snowylike> does the video cover the implementation of lenses as well?
14:05:27 <ivanm> cmccann: he probably has this really clever bot... :p
14:05:35 <elliott> you can do (Dynamic -> Dynamic)
14:05:37 <elliott> but you don't want to
14:05:38 <ivanm> r00723r0: well, can you provide an example in another language?
14:05:45 <r00723r0> ivanm: any function in Python.
14:05:47 <r00723r0> Or JS.
14:05:49 <edwardk> snowylike: it does
14:05:50 <shachaf> r00723r0: It seems that you're trying to make Haskell into something else, rather than grasp it.
14:05:54 <snowylike> great
14:05:57 <ivanm> r00723r0: they have types though, don't they?
14:05:58 <elliott> Python/JS don't really do that.
14:06:00 <cmccann> ivanm, I think edwardk's clever bot that helps him is named "shachaf"
14:06:02 <r00723r0> shachaf: again, I'm not trying to do anything.
14:06:06 <r00723r0> ivanm: they do.
14:06:09 <edwardk> ivanm: you can probably use some youtube video downloader
14:06:15 <elliott> They just hide the secret types from you in the language semantics.
14:06:27 <ivanm> edwardk: yeah, I was just wondering if there was a torrent or something available
14:06:33 <ivanm> or at least an HTML5 version of the video
14:06:42 <edwardk> ivanm: not currently. there was for a while but the raw video is ~3 gigs
14:06:44 <Cale> r00723r0: You can use Dynamic, but you generally wouldn't.
14:06:51 <Lethalman> cmccann, http://paste.debian.net/220682/ and http://heap.ezyang.com/view/24b16a0a5636cf162027f3f37a0661b90127c4d8#form (emacs doesn't have som
14:06:54 <r00723r0> What would be one possible use for Dynamic?
14:06:55 <Eduard_Munteanu> Beware, I think shachaf became self-aware recently.
14:06:57 <Lethalman> but I believe here I'm doing something wrong
14:07:01 <ivanm> Eduard_Munteanu: heh
14:07:07 <cmccann> Eduard_Munteanu, hahaha
14:07:14 * applicative thinks, funny for a second I though r00723r0 said he wanted a 'general way to accept or return an untyped expression'
14:07:23 <r00723r0> applicative: that's what I said.
14:07:25 <Lethalman> (ignore the emacs thing I was saying)
14:07:30 <Cale> r00723r0: If you know nothing at all about the type of some value, then there's precisely nothing interesting which you could ever do with it -- you can push it around, but you can't observe what it is.
14:07:40 <r00723r0> Cale: aha, that makes sense.
14:07:46 <ivanm> Cale: so you can push it, but not pull it? :p
14:07:50 <r00723r0> So you'd want to use Dynamic if you're just passing a value through.
14:08:08 * ivanm tries to work out if there's anything else he needs to do before releasing
14:08:10 <shachaf> r00723r0: No. You wouldn't want to use dynamic.
14:08:15 <shachaf> Dynamic.
14:08:23 <r00723r0> shachaf: why is it part of the language?
14:08:31 <cmccann> r00723r0, to annoy shachaf
14:08:31 <applicative> r00723r0: Dynamic is for people like Lennart A.
14:08:38 <Cale> r00723r0: Dynamic rarely really gets used, but you might use it as part of some kind of plugin system for user data.
14:08:39 <cmccann> there's quite a few features that seem to be designed for that purpose
14:08:49 <ivanm> cmccann: heh
14:08:57 <shachaf> r00723r0: It's not.
14:08:58 <cmccann> Lethalman, ok I'm pretty sure it shouldn't have that much (,) and StdGen floating around
14:09:00 <r00723r0> Cale: I guess that makes sense.
14:09:34 <Lethalman> cmccann, yes using `seq` around now
14:09:39 <Cale> r00723r0: But usually if you want to abstract over lots of types, you'd work out which operations you need on some data, and make a type which encodes how those operations behave.
14:09:49 <r00723r0> So what's the relationship between types and typeclasses?
14:09:59 <r00723r0> Types have typeclasses, right?
14:10:07 <Cale> typeclasses are like things which may be true or false of any given type
14:10:12 <Cale> Like predicates on types
14:10:20 <r00723r0> I see, that makes sense.
14:10:21 <Cale> and they're used to restrict which types a type variable ranges over
14:10:48 <r00723r0> Can both types and typeclasses be used in function type definitions?
14:10:50 <Cale> So for example while  sort :: [a] -> [a]  doesn't quite make sense, because some types don't have a well-defined comparison operation for the sorting function to use
14:10:53 <r00723r0> What do you call a function type definition?
14:10:58 <Cale> We have  sort :: (Ord a) => [a] -> [a]
14:11:03 <Lethalman> now it's http://heap.ezyang.com/view/e452c39f91f3385774fc327cbba849de1d47a371#form
14:11:20 <cmccann> that is a lot of ints.
14:11:27 <Cale> which says that if a is any type which is an instance of the Ord typeclass, then sort can take a list of values of that type and produce a list of values of the same type
14:11:33 <Lethalman> cmccann, ahah
14:11:38 <Lethalman> the code is: http://paste.debian.net/220683/
14:11:40 <r00723r0> Cale: yeah, I completely understand that.
14:11:43 <Lethalman> but now I don't know whatelse to optimize
14:11:54 <Cale> When you define a class, you specify which operations need to be available, and when you define an instance, you provide implementations of those.
14:12:07 <r00723r0> Could I also say square :: (Int a) => a -> a?
14:12:15 <Cale> (Num a)
14:12:20 <Cale> Int is just a type
14:12:27 <r00723r0> Aha, so I have to use typeclasses in type definitions.
14:12:32 <Cale> Num is a typeclass which defines (+) and (*) etc.
14:12:40 <cmccann> Lethalman, I'm honestly not sure where the problem would be
14:12:59 <applicative> r00723r0: no, the type class system is an independent overlay on the world of types and values, to put it crudely
14:13:10 <r00723r0> applicative: this I don't understand.
14:13:13 <Lethalman> sigh
14:13:21 <Lethalman> maybe all those ints come from fgl?
14:13:31 <cmccann> I suppose that's possible
14:13:39 <cmccann> but you're not actually using the generated values, are you?
14:13:49 <Cale> class Num a where
14:13:54 <Cale>   (+) :: a -> a -> a
14:13:57 <applicative> r00723r0: I was respondingto Aha, so I have to use typeclasses in type definitions.
14:13:59 <Cale>   (*) :: a -> a -> a
14:13:59 * hackagebot graphviz 2999.15.0.0 - Bindings to Graphviz for graph visualisation.  http://hackage.haskell.org/package/graphviz-2999.15.0.0 (IvanMiljenovic)
14:14:01 * hackagebot double-conversion 0.2.0.6 - Fast conversion between double precision floating point and text  http://hackage.haskell.org/package/double-conversion-0.2.0.6 (BryanOSullivan)
14:14:05 <cmccann> Lethalman, actually, what happens if you just generate a random Int instead of your actual sample?
14:14:05 <Lethalman> cmccann, I'm not, I create graphs and discard them
14:14:05 <Cale>   fromInteger :: Integer -> a
14:14:09 <shachaf> r00723r0: Before understanding type classes, you should understand types.
14:14:10 <Cale>   ... other stuff ...
14:14:15 <cmccann> no, wait, generate something else
14:14:19 <shachaf> They're way more fundamental and also much simpler than type classes.
14:14:19 <applicative> r00723r0: though maybe I took it the wrong way
14:14:19 <cmccann> to avoid confusing the profile
14:14:24 <Cale> instance Num Integer where
14:14:38 <cmccann> Lethalman, generate a random Float or something I guess
14:14:40 <Cale>   x + y = ... low-level Integer-specific code for addition ...
14:14:41 <r00723r0> OK. All a type does is defines what operations can be performed on it, right?
14:15:14 <shachaf> No.
14:15:22 <Cale> r00723r0: Unless it's polymorphic, a type specifies exactly which pieces of data belong to it.
14:15:24 <Lethalman> cmccann, I'm doing nopSample' g = next g directly, is that fine?
14:15:30 <Cale> Which values, exactly.
14:15:43 <Cale> For example, if I define a type like:
14:15:52 <Cale> data Tree = Tip | Branch Tree Tree
14:16:04 <Cale> Then this says that Tip :: Tree
14:16:05 <Lethalman> cmccann, seems fine http://heap.ezyang.com/view/5e20e74223fcf211f4103784589a759a702a7727#form
14:16:11 <r00723r0> :: means "is of type"?
14:16:12 <Cale> and Branch x y :: Tree whenever x :: Tree and y :: Tree
14:16:14 <Cale> yeah
14:16:14 <Lethalman> cmccann, but it's nopSample' g = next g
14:16:30 <Cale> So, my Tree type has things like  Branch (Branch Tip Tip) Tip
14:16:33 <r00723r0> So what if x or y are not Trees?
14:16:39 <Cale> Then it's a type error.
14:16:42 <cmccann> Lethalman, yes, that's much more what I would expect to see
14:16:43 <r00723r0> Got it.
14:16:55 <Lethalman> cmccann, so the problem is in fgl? seems weird to me
14:17:00 <r00723r0> | means something different in data statements than it does in function blocks, doesn't it?
14:17:04 <Cale> yeah
14:17:08 <Cale> It's "or" here.
14:17:14 <r00723r0> In a function block, it's a guard, right?
14:17:18 <Cale> yeah
14:17:27 <r00723r0> That's confusing but now I understand.
14:17:42 <Cale> and it's also used to separate the initial expression of a list comprehension from the generators and guards
14:17:43 <cmccann> Lethalman, I'm not sure why it would be holding onto so much...
14:17:54 <r00723r0> Cale: oh yeah, that too.
14:17:57 <Cale> > [x^2 | x <- [1..10], even x]
14:17:57 <cmccann> you're seq'ing the sample value, right?
14:17:58 <lambdabot>   [4,16,36,64,100]
14:18:26 <hpaste> iFLip pasted “iFlip” at http://hpaste.org/80027
14:18:31 <cmccann> then again each value is discarded anyway.
14:18:42 <Cale> r00723r0: We can also make the tree hold values:
14:18:56 <Cale> data Tree a = Tip | Branch a (Tree a) (Tree a)
14:19:06 <r00723r0> Not following here.
14:19:12 <ivanm> cmccann: what's the error in FGL? (so that I can fix it)
14:19:13 <Cale> Here, 'a' is a type parameter
14:19:14 <r00723r0> data Tree = Tip | Branch Tree Tree
14:19:24 <Lethalman> cmccann, http://paste.debian.net/220684/
14:19:39 <r00723r0> Cale: why have a type parameter?
14:19:40 <cmccann> ivanm, I have no idea what is the error in which things where
14:19:47 <Cale> So for example,  Branch "hello" (Branch "there" Tip Tip) (Branch "world" Tip Tip) :: Tree String
14:19:53 <cmccann> ivanm, just trying to figure out why Lethalman's code is using so much memory
14:19:55 <ivanm> oh, just saw that Lethalman asking you if the error was in FGL
14:19:56 <Lethalman> cmccann, that aaf `seq` g' `seq` was needed
14:20:22 <Cale> and   Branch 1 (Branch 2 Tip Tip) (Branch 3 Tip (Branch 4 Tip Tip)) :: Tree Integer
14:20:41 <cmccann> Lethalman, you shouldn't NEED the seq on aaf, since you're ignoring the value here.
14:20:44 <Cale> (Or more generally, (Num a) => Tree a)
14:20:58 <cmccann> there's no reason to force those before filter does (if it does at all)
14:21:27 <Lethalman> ivanm, ivanm prof: http://paste.debian.net/220685/ hy: http://heap.ezyang.com/view/422447b131d70d974a181b4e4b8717b18d8d7cdc#form
14:21:50 <Cale> Tip and Branch are data constructors (which is also indicated by the fact that their names start with an uppercase letter), which means that when defining a function on trees, we can pattern match against them
14:21:55 <Lethalman> seems like those int come from fgl?
14:22:02 <Cale> size :: Tree a -> Integer
14:22:06 <Cale> size Tip = 0
14:22:06 <r00723r0> Cale: that I don't understand at all.
14:22:15 <Cale> size (Branch x l r) = 1 + size l + size r
14:22:22 <Cale> Like that
14:22:32 <ivanm> Lethalman: possibly, but that'd just be because you ahve a lot of nodes...
14:22:39 <Cale> Does the example help?
14:22:45 <Lethalman> ivanm, 2 nodes and 1 edge
14:22:51 <ivanm> Lethalman: are you generating Int values?
14:22:58 <r00723r0> Cale: what is x?
14:23:17 <Cale> x would be the value of type a in that branch node
14:23:18 <Lethalman> ivanm, here's the code: http://paste.debian.net/220687/
14:23:29 <Cale> For example, if we did:
14:23:42 <Cale> size (Branch 1 (Branch 2 Tip Tip) (Branch 3 Tip Tip))
14:24:00 * hackagebot heist 0.10.2.1 - An Haskell template system supporting both HTML5 and XML.  http://hackage.haskell.org/package/heist-0.10.2.1 (DougBeardsley)
14:24:00 <Lethalman> ivanm, noSample' is what creates the random graphs
14:24:01 <Cale> then x = 1,  l = (Branch 2 Tip Tip), and r = (Branch 3 Tip Tip)
14:24:10 <r00723r0> 1 is not a type?
14:24:18 <ivanm> your memory usage is from createSamples
14:24:19 <Cale> 1 is a number
14:24:26 <Cale> x, l, and r are values
14:24:36 <Cale> So are Tip and Branch
14:24:46 <Lethalman> ivanm, if I substitute with noSample' g = next g it works fine
14:24:51 <r00723r0> Tip and Branch are values?
14:24:54 <Cale> yes
14:25:03 <adnap> i want to start keeping track of my income and expenses. i was considering using an openoffice spreadsheet, but then i thought there might be something better in haskell. is there?
14:25:05 <applicative> Tip :: a -> Tree a
14:25:08 <Cale> Tip :: Tree a
14:25:18 <Cale> Branch :: a -> Tree a -> Tree a -> Tree a
14:25:30 <applicative> oops storing in the nodes
14:25:55 <cmccann> ivanm, what I can't figure out is why it would using so much memory to generate a bunch of graphs that aren't ever used
14:26:06 <applicative> data Tree a = Tip | Branch a (Tree a) (Tree a)
14:26:13 <Cale> yes
14:26:22 <ivanm> I'm trying to work out where the graphs are being generated...
14:26:23 <Cale> That's the definition I'm going with here :)
14:26:46 <Lethalman> ivanm, with mkAAF from noSample'
14:26:57 <Lethalman> *nopSample'
14:27:17 <applicative> r00723r0: so Tree Int, Tree Char etc are types, but they all have something called Tip in them
14:27:26 <r00723r0> Wait a second.
14:27:30 <Cale> So this says, every value of type Tree a is either the value Tip, or it is of the form  Branch x l r  where x has type a, and l and r have type Tree a
14:27:30 <r00723r0> Tip :: a -> Tree a
14:27:36 <r00723r0> Where did 'a' come from?
14:27:42 <Cale> r00723r0: That was a mistake on applicative's part
14:27:45 <applicative> r00723r0: drop that I made a wrong inference about Cale s type
14:28:09 <ivanm> oh, you're using NodeMap?
14:28:11 <ivanm> I never touched that
14:28:18 <r00723r0> Now I'm all confused.
14:28:19 <ivanm> but I've heard other people having issues with it
14:28:23 <Lethalman> :S
14:28:30 <Cale> r00723r0: We could start with simpler datatypes if you haven't seen any of this syntax before
14:28:35 <applicative> r00723r0: still the correct type is Tip :: Tree a
14:28:35 <Lethalman> ivanm, either ways, I'm still discarding the graph instance
14:28:44 <Cale> r00723r0: So, we could do something like a simple enumeration, to start with:
14:28:48 <r00723r0> Cale: the syntax makes sense when there's not much of it.
14:29:06 <Cale> data Colour = Red | Orange | Yellow | Green | Blue | Violet
14:29:10 <Lethalman> whatever broken it is, haskell is there to guarantee that mkAAF has no side effects as far as I understood
14:29:20 <r00723r0> Cale: that means that values can be of type Red?
14:29:30 <Cale> no
14:29:33 <applicative> the  type is Colour
14:29:39 <Cale> Red, Orange, etc. are values of type Colour
14:29:45 <applicative> the values are on the rhs
14:29:45 <r00723r0> Aha, so those are value literals.
14:29:46 <ivanm> Lethalman: well, you're seq'ing each graph
14:30:09 <ivanm> what happens if you remove the " aaf `seq` " from line 80?
14:30:39 <applicative> r00723r0: the right hand side is like a little grammar for building up expressions for values, in the case of Colour it's a trivial grammar
14:30:49 <Lethalman> ivanm, and keeping g' `seq` ?
14:31:01 <ivanm> with and without that
14:31:19 <Lethalman> ivanm, with: http://heap.ezyang.com/view/01a26bfd0e30526a412fc05c07a4248c8f056394#form
14:31:29 <r00723r0> applicative: could I do `let a = Red`?
14:31:33 <Cale> The syntax is like  data <Type-name> <type parameters...> = <case 1> | <case 2> | ... | <case n>, and each case consists of the name of a newly defined data constructor, followed by a sequence of types of its arguments.
14:31:34 <applicative> yes
14:31:44 <Lethalman> ivanm, without: http://heap.ezyang.com/view/a3ba0b4070aee9e6d3df92235aae10cabea505c2#form
14:31:46 <ivanm> or use length rather than your foldl' in line 87
14:32:00 <Cale> and this defines the type with the given name, as well as all its data constructors
14:32:12 <Cale> So we can do things like:
14:32:30 <Cale> data Employee = Boss String Integer | Whelp String
14:32:37 <Lethalman> ivanm, with length and without seqs: http://heap.ezyang.com/view/b46fa120ee6ba04e7c13e7fdb025c553da00d6af#form
14:32:54 <Cale> and then we have things like
14:33:01 <ivanm> Lethalman: I'd like to also point out that "data StdGen = StdGen Int32 Int32"
14:33:15 <Cale> Boss "Big Guy" 500000 :: Employee
14:33:25 <Lethalman> ivanm, ah
14:33:35 <ivanm> this makes it look like the graphs _aren't_ at fault
14:33:51 <Lethalman> ivanm, but again if I do nopSample' g = next g it works fine
14:34:14 <ivanm> *shrug*
14:34:20 * cmccann wouldn't have expected the graphs to be an issue
14:34:32 <cmccann> but I also wouldn't expect the rest of it to be an issue either :[
14:34:33 <Cale> Whelp "Noname" :: Employee
14:34:40 <cmccann> I'm probably missing something obvious
14:34:43 <ivanm> how does that even type-check? you don't have a Random instance for AAF...
14:34:47 <Cale> r00723r0: Does that much make sense?
14:34:57 <ivanm> is "next g" defaulting to the () instance?
14:35:09 <r00723r0> Cale: no. :(
14:35:11 <Cale> r00723r0: So this definition is simultaneously defining  Employee, Boss, and Whelp
14:35:11 <r00723r0> I'll keep reading.
14:35:15 <Lethalman> oh I think I found the issue
14:35:18 <r00723r0> I really just don't know enough to understand what you're saying.
14:35:59 <Lethalman> ivanm, cmccann, if I do nopSample' g = (123, snd $ next g) I get http://heap.ezyang.com/view/94fe36e16d37d62b25c3ccfee00b52e186dc9331#form
14:36:06 <Lethalman> so we dropped the graphs
14:36:07 <Cale> Employee is a new type introduced by the data declaration, and Boss and Whelp are values (functions in this case) which are used to construct values of our new data type.
14:36:19 <Lethalman> well I didn't find the issue, but reduced the test :P
14:36:25 <Cale> r00723r0: Boss has two parameters, one of type String, and one of type Integer
14:36:33 <Cale> r00723r0: and Whelp has just a String parameter
14:36:40 <dncr> is there a haskell library to look up a z-score
14:36:48 <applicative> r00723r0: maybe a type like data ArithExpr = Lit Int | Plus ArithExpr ArithExpr | Times ArithExpr ArithExpr would be better, or maybe worse.
14:37:11 <r00723r0> OK.
14:37:13 <r00723r0> I understand that.
14:37:17 <r00723r0> Kind of.
14:37:19 <Cale> Well, that one is recursive, so that's the next thing I was going to go after
14:37:25 <r00723r0> So here you're defining Times and Plus as well?
14:37:31 <Cale> yeah, and Lit
14:37:38 <Cale> as well as the type ArithExpr
14:37:41 <applicative> r00723r0: ArithExpr is type; some values are Lit 1 , Lit 2 , Plus (Lit 1) (Lit 2), Times (Lit 1) (Plus (Lit 1)(Lit2))
14:37:51 <r00723r0> How does Haskell know what Lit or Times mean?
14:38:09 <Cale> We're introducing those new terms with this data declaration
14:38:33 <Cale> This says that every value of type ArithExpr is one of the following:
14:38:35 <Lethalman> cmccann, ivanm, that's with `seq` otherwise I get (,) and StdGen again in the heap profile
14:38:37 <applicative> r00723r0: that question might be easier with data Color = Red |...
14:38:44 <Cale>   Lit x  where x :: Int
14:38:45 <applicative> 'how does haskell know what Red means'
14:38:59 <Cale>   Plus e1 e2 where e1, e2 :: ArithExpr
14:39:11 <Cale>   Times e1 e2 where e1, e2 :: ArithExpr
14:40:03 <r00723r0> Cale: got that, totally, but Plus and Times are undefined.
14:40:16 <Cale> Well, they're being defined by the data declaration
14:40:24 <Cale> (along with Lit)
14:40:56 <r00723r0> But what 'are' they?
14:40:56 <Cale> If they were already defined, then it would be an error to write that data declaration
14:40:59 <r00723r0> What do they mean?
14:42:03 <Cale> Well, they allow us to construct values like  Plus (Lit 1) (Lit 2)
14:42:14 <Cale> They themselves are function values
14:42:23 <Cale> Lit :: Int -> ArithExpr
14:42:39 <Cale> Plus :: ArithExpr -> ArithExpr -> ArithExpr
14:42:44 <Cale> Times :: ArithExpr -> ArithExpr -> ArithExpr
14:42:48 <r00723r0> Aha!
14:43:01 <cmccann> Lethalman, ok, I still can't think of what else to try. sorry. :[
14:43:04 <r00723r0> That's all implicit of course.
14:43:13 <Lethalman> cmccann, thank you a lot anyway
14:43:33 <Cale> Yeah, there's a newer notation you can use if you turn on the GADTs extension, where we could define the same data type with:
14:43:38 <Cale> data ArithExpr where
14:43:44 <Lethalman> I believe that makes me bye haskell
14:43:45 <Cale>   Lit :: Int -> ArithExpr
14:43:59 <Cale>   Plus :: ArithExpr -> ArithExpr -> ArithExpr
14:43:59 <Cale>   Times :: ArithExpr -> ArithExpr -> ArithExpr
14:43:59 <dncr> i guess i can do my own numerical integration..
14:44:00 * hackagebot persistent-mongoDB 1.1.5 - Backend for the persistent library using mongoDB.  http://hackage.haskell.org/package/persistent-mongoDB-1.1.5 (GregWeber)
14:44:21 <r00723r0> Cale: I like that syntax way better.
14:44:24 <cmccann> Lethalman, maybe someone else can help, dunno
14:44:24 <DrChaos[S]> hello
14:44:51 <applicative> dncr: have you looked at
14:44:51 <Lethalman> cmccann, either ways, if it takes so much time to sort out such a simple stuff, I can't imagine more complex stuff
14:44:56 <Cale> r00723r0: It allows for some more general things to happen which are somewhat more complicated for the compiler to support
14:44:57 <applicative> @where statistics
14:44:57 <lambdabot> I know nothing about statistics.
14:45:09 <applicative> @hackage statistics
14:45:09 <lambdabot> http://hackage.haskell.org/package/statistics
14:45:24 <Cale> r00723r0: But otherwise, yeah, I think it's perhaps a good deal clearer, at least, if you haven't seen BNF notation before
14:45:40 <applicative> dncr: that's the going library for straightforward statistical concepts^^^
14:45:49 <Cale> (the normal data declaration syntax is supposed to be somewhat reminiscent of BNF)
14:45:57 <cmccann> Lethalman, well, I haven't had similar issues in anything I've written... if I had I'd be able to help more :P
14:46:04 <r00723r0> So you can pretty much write anything in a data statement?
14:46:29 <Cale> Well, the names of the type and the data constructors are up to you
14:46:30 <Lethalman> cmccann, probably you have them but the size of your problem is not enough to give you troubles ;)
14:47:00 <Cale> The type is optionally followed by a whitespace-separated sequence of variables which are type parameters
14:47:26 <Cale> and each data constructor is optionally followed by a whitespace-separated sequence of types which are the types of its parameters
14:47:29 <dncr> applicative: i did, it has a normal distribution and some tests but no z tests..
14:47:30 <cmccann> Lethalman, more likely just that stuff I did was limited by disk or other IO
14:47:43 <r00723r0> Cale: optional?
14:47:49 <r00723r0> > data Asdf
14:47:50 <lambdabot>   <hint>:1:1: parse error on input `data'
14:48:03 <Cale> Can't put declarations into Lambdabot
14:48:10 <Cale> (it only wants expressions)
14:48:22 <cmccann> Lethalman, number crunching isn't really my kinda thing, heh
14:48:31 <Lethalman> :)
14:48:32 <Cale> You can have empty data declarations like that though, which define a type with no constructors.
14:48:42 <r00723r0> Cale: I see. :)
14:48:44 <Cale> (you can't make any defined values of such a type)
14:49:00 * hackagebot Graphalyze 0.14.0.0 - Graph-Theoretic Analysis library.  http://hackage.haskell.org/package/Graphalyze-0.14.0.0 (IvanMiljenovic)
14:49:02 * hackagebot SourceGraph 0.7.0.4 - Static code analysis using graph-theoretic techniques.  http://hackage.haskell.org/package/SourceGraph-0.7.0.4 (IvanMiljenovic)
14:49:06 <Mortchek> Cale, is such a type inhabited only by bottom?
14:49:06 <Cale> but the stuff I was referring to as optional were the parameter lists
14:49:13 <Cale> Mortchek: yes, that's right
14:49:23 <Cale> Just nonterminating programs
14:50:24 <Cale> r00723r0: So, suppose the usual list datatype wasn't in Haskell
14:50:34 <Cale> r00723r0: Then we could define an equivalent to it using:
14:50:43 <Cale> data List a = Nil | Cons a (List a)
14:51:18 <Cale> This would mean that for any type a, we have that every value of type List a is either  Nil  or consists of  Cons x xs  where x :: a and xs :: List a
14:51:18 <r00723r0> Fascinating.
14:51:29 <r00723r0> So we're just inventing Cons for the purposes of List.
14:51:33 <Cale> yeah
14:51:46 <r00723r0> Cons is a type that takes two arguments?
14:51:47 <Cale> and then we could write values of this type like   Cons 1 (Cons 2 (Cons 3 Nil)) :: List Integer
14:51:56 <r00723r0> Totally got it.
14:52:01 <Cale> Cons is a value that takes two arguments
14:52:20 <cmccann> and Cons is one of the constructors defining the type List
14:52:28 <DrChaos[S]> I know that tail xs = drop 1
14:52:31 <Cale> values are on the left side of :: and types are on the right side of it
14:52:40 <r00723r0> ?
14:52:43 <r00723r0> You mean vice-versa?
14:52:46 <cmccann> DrChaos[S], not quite
14:53:01 <Cale> values :: types
14:53:04 <cmccann> > drop 1 []
14:53:06 <lambdabot>   []
14:53:08 <cmccann> > tail []
14:53:09 <lambdabot>   *Exception: Prelude.tail: empty list
14:53:21 <Cale> 5 :: Integer -- here 5 is a value, and Integer is a type
14:53:38 <r00723r0> Can you give me a bigger example?
14:53:44 <Cale> Nil :: List String -- here Nil is a value, and List String is a type
14:53:47 <DrChaos[S]> hmm...ok, how would I even make a function that drops just one element off of the head of a list?
14:53:54 <r00723r0> Cale: ?!
14:54:02 <r00723r0> List String?
14:54:06 <DrChaos[S]> It might take some thought to do this
14:54:07 <r00723r0> That means the List has String elements?
14:54:10 <Cale> yeah
14:54:15 <Cale> though this one is empty
14:54:15 <Rarrikins> DrChaos[S]: That's easy enough.
14:54:31 <cmccann> DrChaos[S], isn't that what drop 1 does?
14:54:35 <Cale> Cons "Hello" (Cons "there" (Cons "world" Nil)) :: List String   as well
14:54:43 <r00723r0> Cale: so in that case Nil == ""?
14:54:44 <Rarrikins> DrChaos[S]: Take the first element and do nothing with it, then output the rest.
14:54:45 <dncr> I found what I wanted: pVal = cumulative standard zVal
14:54:50 <Cale> Nil is like []
14:54:51 <dncr> Statistics.Distribution.Normal
14:54:56 <DrChaos[S]> Rarrikins, if it's easy enough why don't I have the solution already
14:55:03 <r00723r0> Cale: but the list is of type string.
14:55:04 <Lethalman> cmccann, nopSample' g = (123, g) instead of (123, snd $ next g) is fine... could that help?
14:55:06 <Cale> and this list I just wrote is like ["hello", "there", "world"]
14:55:19 <r00723r0> Oh, string, not char.
14:55:23 <Cale> r00723r0: The elements of the list are of type String
14:55:26 <r00723r0> Yeah.
14:55:31 <Lethalman> @src snd
14:55:32 <lambdabot> snd (_,y) =  y
14:55:50 <Cale> and we could write:
14:55:53 <Cale> length Nil = 0
14:56:00 <Cale> length (Cons x xs) = 1 + length xs
14:56:09 <cmccann> Lethalman, hm
14:56:22 <Rarrikins> DrChaos[S]: Pattern matching will get you the part of the list you want to output.
14:56:22 <r00723r0> Cale: got it!
14:56:30 <Cale> and because every value of type List a is either constructed using Nil or Cons, this defines length for all lists.
14:56:31 <DrChaos[S]> Rarrikins, how do you put "do nothing with the first element" into code?
14:56:36 <DrChaos[S]> Rarrikins, pattern matching?
14:56:44 <r00723r0> DrChaos[S]: _.
14:56:47 <Cale> (every defined value, anyway)
14:56:49 <cmccann> Lethalman, if the former works and the latter doesn't, I guess that means that the thunk is being built up somehow by advancing the PRNG?
14:57:09 <r00723r0> DrChaos[S]: _ is a variable name like any other but it is well known to mean throwaway.
14:57:38 <Cale> Well, _ is genuinely a wildcard, you can use it multiple times
14:57:47 <Cale> So it doesn't bind a value
14:57:54 <r00723r0> Oh, cool.
14:58:02 <r00723r0> I think LYAH is wrong then.
14:58:17 <Cale> You couldn't write  foo (Cons x x), but you can write  foo (Cons _ _)
14:58:39 <Cale> and when you write _ on the right hand side of the = sign, you'll just have a syntax error -- it's only valid in patterns.
14:59:05 <pnielsen> _ <- forkIO foo :p
14:59:22 <pnielsen> (I know, just being annoying)
14:59:26 <cmccann> Lethalman, how about this--instead of using seq on just the RNG seed g, seq (show g)
14:59:27 <DrChaos[S]> ok guys, is this how you write tail?: tail' [] = error "empty list"; tail' (x:[]) = x; tail' (_:xs) = tail xs
14:59:51 <Rarrikins> DrChaos[S]: The second part isn't correct. x isn't in the tail.
14:59:58 <Cale> DrChaos[S]: Not quite -- think a little more about what you want tail (x:xs) to be
15:00:00 <pnielsen> DrChaos[S]: that's last, not tail
15:00:12 <Cale> yeah, that was last
15:00:17 <kkris> Happy New Year!
15:00:17 <Cale> > tail [1,2,3,4]
15:00:19 <lambdabot>   [2,3,4]
15:00:23 <rwbarton> actually it's neither :P
15:00:24 <tr3quart1sta> hello.. can sb tell me how to apply this patch? http://www.haskell.org/haskellwiki/Xmonad/Using_xmonad_on_Apple_OSX#Fitting_Other_Bits_For_Use_With_xmonad_on_OS_X
15:00:24 <Cale> > last [1,2,3,4]
15:00:27 <lambdabot>   4
15:00:46 <DrChaos[S]> I think mine just skips every second element
15:00:52 <Cale> oh, right, it's not really recursive because of typo :)
15:00:59 <cmccann> rwbarton, I'm assuming that final "tail" should be tail' instead...
15:01:00 <Cale> > let tail' [] = error "empty list"; tail' (x:[]) = x; tail' (_:xs) = tail' xs in tail' [1,2,3,4]
15:01:02 <lambdabot>   4
15:01:03 <pnielsen> tail' [] = error "empty list"; tail (_:xs) = xs
15:01:03 <rwbarton> so it doesn't even typecheck i guess
15:01:04 <Rarrikins> Ahh
15:01:31 <Cale> Assuming we fix your typo, then the function you wrote is 'last'
15:01:32 <pnielsen> erh, nevermind :)
15:02:26 <r00723r0> Can one catch exceptions?
15:02:41 <DrChaos[S]> ahahahahah, indeed, I had last' defined already and I read both function bodies and I discovered that my definition of tail' matches up with my definition of last'
15:03:05 <Cale> r00723r0: Well, exceptions thrown from pure code are tricky to catch, but it's technically possible from IO
15:03:49 <applicative> dncr: zscore :: Double -> U.Vector Double -> Double ; zscore guy population = (guy - mean population) / stdDev population
15:04:00 * hackagebot gitit 0.10.1 - Wiki using happstack, git or darcs, and pandoc.  http://hackage.haskell.org/package/gitit-0.10.1 (JohnMacFarlane)
15:04:07 <Cale> r00723r0: Usually though, stuff thrown by "error" isn't meant to be caught, and for that reason, head and tail and other things which can fail that way are usually best avoided in favour of explicit pattern matching on the possible cases.
15:04:22 <Cale> (so it's harder to miss any possibilities)
15:04:34 <r00723r0> Cale: I see. :)
15:04:39 <Rarrikins> Why doesn't head use Maybe?
15:04:57 <cmccann> Rarrikins, silly design decisions
15:04:59 <DrChaos[S]> well huh? I don't have any idea on how to write tail
15:05:02 <Rarrikins> Ahh
15:05:03 <dncr> applicative: ah thank you, but i think for looking up the p-value for a z-value i can just do: pVal = cumulative standard zVal
15:05:12 <Lethalman> cmccann, sorry didn't understand you
15:05:17 <Rarrikins> DrChaos[S]: Write the left side of the equal sign.
15:05:17 <DrChaos[S]> I don't know how to say: discard only the first element of the list
15:05:18 <kennyd> @src tail
15:05:18 <lambdabot> tail (_:xs) = xs
15:05:18 <lambdabot> tail []     = undefined
15:05:27 <DrChaos[S]> OH
15:05:40 <Cale> But IO actions have a nice system of exceptions which is easy to extend with new exception types, which can even be "supertypes" of existing exceptions -- you can completely define what it means to catch and throw them.
15:05:54 <DrChaos[S]> you really shouldn't have given me the answer kennyd
15:06:37 <rwbarton> I think there are not really that many steps between "how do I write tail?" and the answer
15:06:37 <elliott> we should just get rid of @src. its coverage is useless anyway
15:06:44 <Rarrikins> DrChaos[S]: Sometimes that's a decent way to learn.
15:06:55 <cmccann> Lethalman, instead of "g' `seq` ..." try "show g' `seq` ..."
15:06:56 <r00723r0> @src Maybe
15:06:56 <lambdabot> data Maybe a = Nothing | Just a
15:07:02 <r00723r0> @src Just
15:07:02 <lambdabot> Source not found. Where did you learn to type?
15:07:10 <cmccann> Lethalman, kinda stabbing in the dark here but I want to see if it'll make a difference
15:07:15 <Cale> r00723r0: Just is defined by that data declaration for Maybe :)
15:07:15 <r00723r0> > Nothing
15:07:16 <lambdabot>   Nothing
15:07:18 <Rarrikins> DrChaos[S]: See if you can figure out what init does to lists and then if you can make it.
15:07:20 <r00723r0> > Just 1
15:07:21 <lambdabot>   Just 1
15:07:33 <r00723r0> Cale: I see. :)
15:08:02 <Lethalman> cmccann, something changed but still stacks thunks
15:08:04 <pnielsen> DrChaos[S]: I already gave it :p
15:08:08 <Cale> > lookup 2 [(0,"hello"),(1,"there"),(2,"world")]
15:08:10 <lambdabot>   Just "world"
15:08:14 <Cale> > lookup 5 [(0,"hello"),(1,"there"),(2,"world")]
15:08:16 <lambdabot>   Nothing
15:08:38 <DrChaos[S]> Rarrikins, I think init would be: init' (x:[]) = []; init' (x:xs) = x : init xs
15:09:00 <DrChaos[S]> wait, I think that's infinite recursion
15:09:10 <Rarrikins> DrChaos[S]: I think that's right (though change init to init' at the end).
15:09:46 <Rarrikins> > let init' (x:[]) = []; init' (x:xs) = x : init' xs in init' [1..10]
15:09:48 <lambdabot>   [1,2,3,4,5,6,7,8,9]
15:09:52 <Rarrikins> Yep :)
15:10:04 <cmccann> Lethalman, what did it do differently?
15:10:08 <DrChaos[S]> how do you test for infinite recursion in your head as your writing code? it's like my brain needs more call stack space :P
15:10:23 <r00723r0> DrChaos[S]: base case, inductive step.
15:10:32 <Lethalman> cmccann, http://heap.ezyang.com/view/3484f7636274abbb99b70b5b49ed9908a7d4b04f#form the value for 0.1 seconds is lower
15:10:32 <Rarrikins> DrChaos[S]: Does the input to the function next time get smaller or not?
15:10:40 <Lethalman> cmccann, the memory usage is lower in general
15:10:43 <DrChaos[S]> Rarrikins, ah
15:10:44 <Rarrikins> DrChaos[S]: If it gets smaller in some way, it's going to not go forever.
15:11:12 <DrChaos[S]> Rarrikins, but why doesn't init' (x:xs) = x : init' xs go on forever?
15:11:19 <elliott> because init' xs doesn't go on forever
15:11:23 <elliott> xs is smaller than (x:xs)
15:11:24 <DrChaos[S]> OH
15:11:24 <elliott> and you have a base case
15:11:27 <Rarrikins> DrChaos[S]: One element is dropped each time.
15:11:29 <Nereid> @ty foldr ((<|>) . Just) Nothing
15:11:30 <lambdabot> [a] -> Maybe a
15:11:43 <Rarrikins> DrChaos[S]: Dropped from the next input.
15:11:44 <rwbarton> just try evaluating it manually on an example like [1,2,3]
15:12:04 <DrChaos[S]> but why doesn't the next invocation of init' in the recursive call execute the "x : " part?
15:12:28 <Rarrikins> DrChaos[S]: Oh, it does, but as long as it doesn't recurse with it, it will be productive.
15:12:32 <rwbarton> I stand by my suggestion
15:13:16 <Rarrikins> DrChaos[S]: Unless you mean x: from this call.
15:13:25 <Rarrikins> DrChaos[S]: The next invocation never sees that.
15:13:36 <DrChaos[S]> ah
15:13:49 <Rarrikins> DrChaos[S]: It can only see its arguments.
15:13:59 <DrChaos[S]> so "x : " from the first call doesn't reach into the next
15:14:07 <Rarrikins> DrChaos[S]: Right.
15:14:09 <DrChaos[S]> let me try evaluating it by hand
15:14:14 <Rarrikins> OK
15:14:14 <Nereid> always a good exercise.
15:14:22 <Lethalman> cmccann, this works fine nopSample' g = g `seq` (123, mkStdGen 123)
15:14:30 <chreekat> Rarrikins: fwiw, there's a safe package that provides headMay and a whole matrix of other alternatives to partial functions
15:14:33 <DrChaos[S]> I'll just write some commented lines in my Emacs window
15:14:50 <Rarrikins> chreekat: Ahh, cool.
15:14:55 <Lethalman> cmccann, is possible that "next" is being coded in C and leaks somewhere?
15:15:20 <elliott> DrChaos[S]: (x : init' xs) is
15:15:24 <elliott> DrChaos[S]: cons x (init' xs)
15:15:28 <elliott> (:) is just an infix function
15:15:35 <elliott> (cons isn't real but you can define cons x xs = x : xs)
15:15:36 <cmccann> Lethalman, http://hackage.haskell.org/packages/archive/random/1.0.1.1/doc/html/src/System-Random.html#stdNext
15:15:38 <elliott> which might make it easier to see
15:16:07 <monochrom> @src init
15:16:07 <lambdabot> init [x]    = []
15:16:07 <lambdabot> init (x:xs) = x : init xs
15:16:07 <lambdabot> init []     = undefined
15:16:51 <Lethalman> cmccann, that's pure haskell right? can't leak I hope
15:16:54 <monochrom> ah, it uses "init [x]" to stop just in time. note: it's the same as saying: init (x : []) = []
15:18:21 <latro`a> I have no intuition for this: f v = (:) <$> v <*> f v <|> pure []
15:18:27 <latro`a> :(
15:18:31 <cmccann> Lethalman, what happens if you use a plain Int instead of the StdGen value, and increment it each time?
15:18:39 <monochrom> haha
15:19:58 <monochrom> "(:) <$> v <*> f v" is analogous to do{ x<-v; y<-f v; return (x:y)}
15:20:54 <monochrom> "x<-v" may fail, or "y<-f v" may fail. when it fails, go with "pure []" instead, which is analogous to "return []"
15:21:32 <Lethalman> cmccann, that's fine: nopSample'' g = g `seq` (123, g+1)
15:21:41 <latro`a> huh, that makes sense
15:21:42 <latro`a> nice
15:22:03 <latro`a> incidentally, kind of a shame that the definition of some/many has to be repetitive like that
15:22:19 <latro`a> (in Control.Applicative)
15:22:28 <Jafet> @pl f v = (:) <$> v <*> f v <|> pure []
15:22:28 <lambdabot> f = fix (flip flip (pure []) . (((<|>) . ((:) <$>)) .) . ap (<*>))
15:22:28 <cmccann> Lethalman, where "fine" means it uses very little memory?
15:22:31 <latro`a> (both definitions are corecursive, and just isolate a different thing in the corecursion)
15:22:42 <monochrom> yeah
15:24:00 <latro`a> actually
15:24:01 * hackagebot pipes-attoparsec 0.1.0.1 - Utilities to convert an Attoparsec parser into a pipe Pipe.  http://hackage.haskell.org/package/pipes-attoparsec-0.1.0.1 (RenzoCarbonara)
15:24:03 <latro`a> *do* they have to be repetitive?
15:24:08 <latro`a> can you not do:
15:24:15 <DrChaos[S]> Nereid, http://vpaste.net/GlmD6
15:24:17 <latro`a> some v = (:) <$> v <*> many v
15:24:23 <latro`a> many v = some v <|> pure []
15:24:29 <Lethalman> cmccann, http://heap.ezyang.com/view/a2ee3626c5592e6766ae89bc33a396939abf9f13#form
15:24:37 <latro`a> (at top level)
15:24:52 <Lethalman> don't know if it cheats because the compiler does very good optimizations ;)
15:25:09 <cmccann> doing optimizations is what the compiler is SUPPOSED to do :P
15:25:12 <cmccann> ok, so
15:25:31 <DrChaos[S]> whoops, that's wrong
15:25:33 <Lethalman> ok should I try copying the stdNext? :)
15:25:37 <cmccann> if you increment an integer it's fine, if you advance a PRNG without doing anything else with it things fall apart
15:25:49 <DrChaos[S]> fixed here: http://vpaste.net/wXxBX
15:25:52 <monochrom> yes latro`a
15:25:54 <cmccann> even if you "seq" the PRNG?
15:26:05 <Nereid> what the heck is init 2?
15:26:20 <Nereid> DrChaos[S]: you should probably desugar the list notation to 1:2:3:[]
15:26:20 <cmccann> I am very confused :[
15:26:38 <Lethalman> cmccann, it was nopSample' g = (mkAAF ["a", "b"] [("a", "b")], snd $ next g)
15:26:58 <Lethalman> cmccann, and nopSample' g = g `seq` (mkAAF ["a", "b"] [("a", "b")], snd $ next g) was the same, doing bad
15:26:58 <Nereid> so, for example, init' (1 : (2 : 3 : [])) = 1 : init' (2 : 3 : [])
15:27:23 <DrChaos[S]> Nereid, does that help you see what I mean by all that text?
15:27:32 <Nereid> ???
15:27:34 <Nereid> I'm saying *you* should do this.
15:28:08 <Nereid> maybe justify each step carefully
15:28:09 <Nereid> for example:
15:28:25 <Nereid> init' (1 : 2 : 3 : []) = 1 : init' (2 : 3 : []), by the definition of init' (x:xs) where x = 1 and xs = 2:3:[]
15:29:34 <monochrom> DrChaos[S], when you write "init' 1" "init' 2" etc, they are wrong
15:29:42 <Lethalman> cmccann, this works as well: http://paste.debian.net/220703/ I've slightly copied stdNext
15:29:49 <Nereid> yes, those make no sense.
15:29:58 <cmccann> Lethalman, if all you change is "g + 1" for an Int vs. "snd $ next g" for StdGen, does the former work and the latter fail?
15:30:13 <Lethalman> cmccann, yes the former work and the latter fails
15:30:14 <monochrom> there is no "intermediate" step from "init' 2" to "2"
15:30:29 <cmccann> Lethalman, hunh
15:30:59 <monochrom> "init' (x:xs) = x  : init' xs" is not the same as "init' (x:xs) = init' x : init' xs"
15:31:10 <cmccann> Lethalman, did you change anything else in the copy of stdNext besides using a tuple?
15:31:16 <Lethalman> cmccann, maybe seq is something shallow? is there anything deeper?
15:31:26 <Lethalman> cmccann, yes, s2 = 123456
15:31:37 <Lethalman> cmccann, because StdGen is made up of two ints not only one
15:31:39 <elliott> there's deepseq but you don't want to use it
15:31:49 <cmccann> I don't think StdGen has an instance for deepseq anyway
15:32:08 <Lethalman> cmccann, will try with an (Int, Int) :S
15:32:15 <cmccann> Lethalman, that's what I was about to suggest!
15:32:43 <Jafet> Nearly everything has an instance for NFData. rnf = rnf . show
15:32:46 <Nereid> DrChaos[S]: you can think of evaluation of an expression as just a purely syntactic transformation
15:32:57 <cmccann> if using a tuple and the copied stdNext works but using StdGen itself doesn't that's worrying
15:33:04 <ivanm> Jafet: assuming the Show instance doesn't skip fields
15:33:14 <cmccann> the show instance for StdGen doesn't skip anything
15:33:22 <Fuuzetsu> @undo do { a <- [1, 2]; return a }
15:33:22 <lambdabot> [1, 2] >>= \ a -> return a
15:33:24 <Nereid> just carefully follow the rules given by the function definitoins
15:33:32 <cmccann> and I already had him try using `seq` on showing the stdgen
15:33:32 <Jafet> ivanm: it's not like NFData has any laws, anyway
15:33:42 <Nereid> Fuuzetsu: is the same as [1,2]
15:33:42 <DrChaos[S]> Nereid, I want you to see if I made a better attempt at evaluation by the contents of this URL: http://vpaste.net/Nv6s4
15:33:47 <ivanm> well, you'd expect it to evaluate the _entire_ value
15:34:00 <Fuuzetsu> Nereid: I'm trying to figure out what the hell does a <- [1, 2] do
15:34:01 <Nereid> init 1 still makes no sense.
15:34:10 <Nereid> Fuuzetsu: it does exactly what lambdabot told you.
15:34:12 <rwbarton> cmccann: but you didn't deepseq the show output did you
15:34:34 <Fuuzetsu> what's the type of a?
15:34:38 <DrChaos[S]> oh, I just keep that around as something I need to put at the beginning of the list
15:34:41 <Nereid> the same type as 1
15:34:49 <DrChaos[S]> it does not equal [1,1,1,1,1,2]
15:34:52 <cmccann> rwbarton, no, clearly that was my mistake
15:35:17 <DrChaos[S]> OH, I see what you mean
15:35:29 <Nereid> Fuuzetsu: do {a <- [1,2]; return a} is *exactly* the same as [1,2] >>= \a -> return a
15:35:44 <Nereid> to figure out the type of a, look at the types of the other things around it
15:35:48 <Nereid> like return and (>>=)
15:35:49 <DrChaos[S]> remove the word init from near the beginning of the second line of my hand evaluation and it will make more sense
15:35:50 <Fuuzetsu> I'm aware. I'm not sure what type a will be at a <- [1, 2] stage
15:36:02 <Fuuzetsu> I thought <- pulls out from the IO monad
15:36:13 <monochrom> <- is a bit more general than IO
15:36:14 <Nereid> it's syntax for any monad
15:36:18 <Nereid> in this case it's the [] monad
15:36:32 <Fuuzetsu> so what does it do for the [] monadV
15:36:34 <Fuuzetsu> ?*
15:36:34 <lambdabot> Maybe you meant: . ? @ v
15:36:34 <rwbarton> the desugaring is actually not type-aware at all
15:36:37 <Nereid> (>>=) :: Monad m => m a -> (a -> m b) -> m b
15:36:41 <Nereid> when m = [], it specializes to
15:36:49 <Nereid> (>>=) :: [a] -> (a -> [b]) -> [b]
15:36:55 <hpc> @src [] (>>=)
15:36:56 <lambdabot> xs >>= f     = concatMap f xs
15:37:00 <hpc> @src concatMap
15:37:00 <lambdabot> concatMap f = foldr ((++) . f) []
15:37:10 <hpc> (or, concatMap f = concat . (map f)
15:37:12 <hpc> )
15:37:15 <Lethalman> cmccann, with the tuple doesn't work
15:37:15 <monochrom> (>>=) for [] is a pretty long story
15:37:18 <Nereid> Fuuzetsu: let's just pretend all numbers are of type Int.
15:37:22 <Lethalman> cmccann, I'll write a simpler .hs file
15:37:31 <Nereid> so when you write [1,2] >>= whatever, you know that the thing on the left has type [Int]
15:37:36 <DrChaos[S]> Nereid, I am confident you will like this one: http://vpaste.net/uSWr5
15:37:40 <Nereid> which means we must hvae a = Int in (>>=) :: [a] -> (a -> [b]) -> [b]
15:37:41 <monochrom> actually, I can cut the story short by an example
15:38:08 <Nereid> DrChaos[S]: what happened to the 2 in the third line?
15:38:10 <monochrom> do { x<-[1,2]; y<-[3,4]; return (x-y) } = [x-y | x<-[1,2], y<-[3,4]]
15:38:36 <DrChaos[S]> oh, I think that's a major mistake
15:38:44 <Nereid> DrChaos[S]: maybe just start from scratch ;)
15:38:48 <Fuuzetsu> oh OK, I think I get it
15:38:52 <Nereid> also, going from line 2 to line 3 isn't by any definition.
15:39:01 <monochrom> Piaget's theory triumphs again
15:39:10 <Fuuzetsu> > [x-y | x<-[1,2], y<-[3,4]]
15:39:10 <rwbarton> the first two lines are good though!
15:39:11 <lambdabot>   [-2,-3,-1,-2]
15:39:25 <Nereid> Fuuzetsu: fwiw, [1,2] >>= (\a -> return a)  =  [1,2] >>= return  =  [1,2] (by one of the monad laws)
15:39:33 <Fuuzetsu> yeah
15:39:36 <Nereid> > do {a <- [1,2]; return a}
15:39:38 <lambdabot>   [1,2]
15:39:47 <Fuuzetsu> I think I get it now~
15:39:49 <Fuuzetsu> I think I get it now~
15:39:49 <Nereid> ~
15:39:53 <Fuuzetsu> oops
15:39:55 <monochrom> \∩/
15:40:10 <Nereid> \∪/
15:40:13 <Fuuzetsu> :t (~)
15:40:14 <lambdabot> parse error on input `)'
15:40:19 <cmccann> :k (~)
15:40:19 <Fuuzetsu> why ;;
15:40:21 <lambdabot> AnyK -> AnyK -> Constraint
15:40:22 <Rarrikins> \r/
15:40:23 <cmccann> :D
15:40:25 <Nereid> AnyK :(
15:40:26 <DrChaos[S]> Nereid, I think it's more clear by deleting the third line
15:40:27 <Fuuzetsu> What's :k?
15:40:31 <Fuuzetsu> kind?
15:40:33 <cmccann> yes
15:40:33 <Nereid> short for kind
15:40:40 <Nereid> :k Maybe
15:40:41 <lambdabot> * -> *
15:40:42 * Fuuzetsu doesn't get kinds
15:40:44 <hpc> the "next level up" from :t
15:40:55 <hpc> don't think about it too hard until later
15:41:02 <rwbarton> you know how you can write Maybe Integer, but not Maybe Maybe? that's kinds
15:41:13 <cmccann> like a type system for types
15:41:15 <Fuuzetsu> concrete type
15:41:30 <hpc> :k Int
15:41:31 <lambdabot> *
15:41:33 <Fuuzetsu> but Maybe Maybe a is fine because Maybe a is *, right?
15:41:35 <hpc> :k Maybe
15:41:36 <lambdabot> * -> *
15:41:39 <hpc> Fuuzetsu: yep
15:41:43 <Nereid> no, but Maybe (Maybe a) is
15:41:53 <Fuuzetsu> what I mean
15:41:57 <Nereid> :p
15:42:03 <cmccann> :k StateT
15:42:04 <lambdabot> * -> (* -> *) -> * -> *
15:42:10 <Fuuzetsu> so what does ~ do?
15:42:13 <Jafet> :k ContT
15:42:14 <lambdabot> * -> (* -> *) -> * -> *
15:42:16 <Rarrikins> Yo dawg, I heard you like type signatures, so I put some signatures in your types...
15:42:17 <Nereid> ~ is type equality
15:42:30 <hpc> > () :: (Int ~ Int) => ()
15:42:32 <lambdabot>   ()
15:42:37 <Fuuzetsu> Rarrikins: I put types in your types so you can type while you type types
15:42:37 <hpc> > () :: (Int ~ Bool) => ()
15:42:39 <lambdabot>   Couldn't match expected type `GHC.Types.Bool'
15:42:39 <lambdabot>              with actual type...
15:42:53 <Rarrikins> Haha
15:42:58 <hpc> Constraint is the kind of type constraints (harr harr)
15:43:08 <hpc> so (Ord a) :: Constraint
15:43:13 <hpc> among other things
15:43:18 <Nereid> > read "123" :: (a ~ Int) => a
15:43:19 <hpc> Ord :: * -> Constraint
15:43:19 <lambdabot>   123
15:43:28 <Fuuzetsu> lost be 10 lines up
15:43:29 <cmccann> :t (\x y -> [x, y]) :: (a -> b -> c)
15:43:30 <lambdabot>     Couldn't match type `c1' with `[a1]'
15:43:30 <lambdabot>       `c1' is a rigid type variable bound by
15:43:30 <lambdabot>            an expression type signature: a1 -> b1 -> c1 at <interactive>:1:1
15:43:30 <Rarrikins> :k Int
15:43:31 <lambdabot> *
15:43:33 <Fuuzetsu> me*
15:43:36 <cmccann> :t (\x y -> [x, y]) :: (a ~ b, c ~ [a]) => (a -> b -> c)
15:43:37 <lambdabot>     Illegal equational constraint a ~ b
15:43:37 <lambdabot>     (Use -XGADTs or -XTypeFamilies to permit this)
15:43:37 <lambdabot>     In an expression type signature: (a ~ b, c ~ [a]) => (a -> b -> c)
15:43:40 <cmccann> bah
15:43:41 <DrChaos[S]> Nereid, I need to rework it a little to trace every function to find what each function call returns
15:43:54 <Nereid> huh.
15:43:56 <cmccann> > ((\x y -> [x, y]) :: (a ~ b, c ~ [a]) => (a -> b -> c)) 'a' 'b'
15:43:57 <lambdabot>   "ab"
15:44:17 <cmccann> why does :t have different extensions enabled than the evaluator does
15:44:24 <Nereid> it is a mystery.
15:44:26 * cmccann grumbles
15:44:30 <hpc> because "> " is mueval
15:44:35 <hpc> but ":t" is a pipe to ghci
15:44:40 <Nereid> let's just yell at cale.
15:44:41 <hpc> and the two just haven't been made consistent
15:44:42 <Nereid> caaaaaaaaaale!
15:44:42 <DrChaos[S]> like how you go from (init (2 : 3 : []) and get the partially applied init (2 : )
15:44:46 <hpc> you have to change both at the same time
15:44:59 <Jafet> INTERCALE
15:45:02 <Fuuzetsu> :t init
15:45:03 <lambdabot> [a] -> [a]
15:45:10 <Fuuzetsu> @src init
15:45:10 <lambdabot> init [x]    = []
15:45:10 <lambdabot> init (x:xs) = x : init xs
15:45:10 <lambdabot> init []     = undefined
15:45:19 <Fuuzetsu> ah
15:45:31 <DrChaos[S]> Jafet, INTERCAL?
15:45:43 <monochrom> what? there is no init(2:)
15:46:22 <monochrom> "init (x:xs) = x : init xs" says: go from init(2:blah) to 2:init(blah). directly. there is nothing else.
15:46:26 <DrChaos[S]> well...I'll show it to you: from init' (2 : 3 : []) we have init' (2 : init ys)
15:46:33 <rwbarton> you are making things a lot more complicated than they need to be
15:46:35 <rwbarton> or are
15:46:36 <Nereid> it is my experience that people are generally not very good at following mechanical procedures.
15:46:50 <monochrom> what? there is no init' (2 : init ys)
15:46:53 <hpc> DrChaos[S]: you have an extra init on the outside
15:47:17 <monochrom> can you read "init (x:xs) = x : init xs"?
15:47:37 <monochrom> or "init' (x:xs) = x : init' xs" if you like
15:48:20 <Jafet> Nereid: clearly you've never been in a sweatshop
15:48:51 <pnielsen> or a call center :p
15:48:59 <Fuuzetsu> init [1, 2, 3]
15:49:07 <Fuuzetsu> > init [1, 2, 3]
15:49:08 <Nereid> Jafet: well they can be trained.
15:49:08 <lambdabot>   [1,2]
15:49:20 <DrChaos[S]> hmm...I can see that you are thinking that init' (x:xs) = <get first item from head of list> : <run recursive call only on the rest of the list, starting at the item just after x>
15:49:23 <monochrom> Jafet, most programmers-to-be have also never been in a sweatshop, or call centre, or things like that
15:49:32 <Jafet> Maybe they should!
15:49:42 <Fuuzetsu> does init = reverse . tail . reverse?
15:49:43 <Nereid> DrChaos[S]: we are just thinking about purely mechanical rewriting procedures.
15:49:50 <Nereid> Fuuzetsu: for finite lists, yes.
15:49:52 <Rarrikins> Fuuzetsu: For finite lists.
15:50:00 * Fuuzetsu has some code to refactor
15:50:05 <Nereid> but it's slower.
15:50:32 <Nereid> and can have asymptotically worse memory usage.
15:50:48 <Fuuzetsu> what can? init?
15:50:53 <Nereid> reverse . tail . reverse
15:51:01 <Fuuzetsu> ah, yes, I thought so
15:51:16 <Jafet> init = zipWith const <*> tail
15:51:18 <DrChaos[S]> http://vpaste.net/Vri97
15:51:44 <Fuuzetsu> in any case, can you please say why you would ever have something like () :: (Int ~ Int) ?
15:52:05 <cmccann> you wouldn't
15:52:12 <monochrom> init' (1: 2:3:[]) = 1 : init' (2: 3:[])
15:52:22 <monochrom> = 1 : 2 : init' (3:[])
15:52:26 <monochrom> = 1 : 2 : []
15:52:30 <monochrom> that is all
15:52:36 <Jafet> Thank you, stepeval.
15:52:36 <Fuuzetsu> Then can you give an example of where using ~ actually achieves something?
15:52:51 <cmccann> I can't think of any examples simple enough to type out on IRC
15:52:51 <monochrom> /nick stepeval :)
15:53:10 <Nereid> sometimes you can't use the same type variable in two different places, so instead you use two different type variables and have an equality constraint between them.
15:53:23 <ginetto> !list
15:53:23 <monochrom> ginetto: http://hpaste.org
15:53:33 <hpc> Fuuzetsu: when matching on a GADT you sometimes get a (~) constraint brought into scope automatically
15:53:46 <Jafet> What do all these people want a list of.
15:54:18 <hpaste> rwbarton pasted “init'” at http://hpaste.org/80028
15:54:18 <Fuuzetsu> !list
15:54:20 <monochrom> I don't know, but I sure give them Haskell stuff :)
15:54:23 <DrChaos[S]> thank you monochrom. I have fixed my hand evaluation because of what you wrote
15:54:26 <DrChaos[S]> http://vpaste.net/ZoSl5
15:54:30 <rwbarton> DrChaos[S]: see http://hpaste.org/80028
15:54:57 <rwbarton> there is no curried or (2 :) anything
15:54:59 <DrChaos[S]> oh wow
15:55:00 <monochrom> Fuuzetsu: I set a timeout of 1 minute to guard against flooding :)
15:55:08 <rwbarton> this is how simple it is
15:55:18 <Lethalman> cmccann, almost here
15:55:31 <Lethalman> cmccann, http://paste.debian.net/220707/
15:55:36 <cmccann> Lethalman, ah, was about to ask how it was going
15:55:46 <Lethalman> cmccann, look at the comments in sample1/2/3/4
15:55:47 <monochrom> w00t rwbarton nice ascii art
15:56:03 <Lethalman> cmccann, interestingly, it appears that the inefficiency comes from the arithmetic? :S
15:56:45 <cmccann> Lethalman, instead of "g", try pattern matching on the tuple and then using `seq` on the two components individually
15:56:56 <Nereid> I prefer this picture:
15:57:07 <hpaste> Nereid annotated “init'” with “init' (annotation)” at http://hpaste.org/80028#a80029
15:57:09 <Lethalman> cmccann, what? :S
15:57:20 <Fuuzetsu> monochrom: what does it -do- though?
15:57:34 <cmccann> Lethalman, e.g. sample5 (g1, g2) = g1 `seq` g2 `seq` ...
15:57:41 <monochrom> I have about 3 urls. each !list randomly picks one to show
15:57:47 <Nereid> DrChaos[S]: ^
15:57:50 <Fuuzetsu> !list
15:57:50 <monochrom> Fuuzetsu: http://hpaste.org
15:57:56 <Fuuzetsu> just my luck
15:58:04 <Lethalman> cmccann, ah btw this might interest you: if I seq s1 and s2 in next1 it works
15:58:31 <cmccann> that would be what I wanted to know, yes
15:58:36 <monochrom> the other two are hackage and oleg's page :)
15:58:48 <Lethalman> cmccann, really haskell is that hard even with arithmetic? :S
15:58:48 <cmccann> monochrom, bwahahaha oleg's page is a great idea
15:58:51 <Fuuzetsu> oleg is always related
15:59:12 <Fuuzetsu> it blew my mind when my housemate has shown it to me
15:59:21 <mel-> i cannot figure out the syntax required for defining a new show instance for a record data type. example: data Monom = Monom { monomFactor   :: Integer , monomExponent :: Integer } -- how can I write a show instance, which outputs monoms in the form "<monomFactor>X^<monomExponent>"?
15:59:42 <Nereid> instance Show Monom where
15:59:49 <cmccann> Lethalman, it really shouldn't be this hard
15:59:51 <Nereid>   show ... = ...
16:00:03 <Nereid> (or maybe you want to define showsPrec instead)
16:00:10 <cmccann> Lethalman, with using seq in next1, it works and is actually generating random numbers as you'd expect, right?
16:00:24 <Lethalman> cmccann, didn't test but I believe so
16:00:25 <mel-> Nereid: well, that is also my structure. but how do 'extract' the factor/exponent? i.e., what are the points on the left hand side?
16:00:26 <Fuuzetsu> isn't it recommended that read and show should work both ways?
16:00:32 <Lethalman> cmccann, also your proposal to seq the tuple works as well
16:00:40 <Nereid> mel-: two choices:
16:01:04 <Nereid> show (Monom factor exponent) = (something involving factor and exponent)
16:01:12 <cmccann> Lethalman, same idea. which I guess means that somehow a bunch of unevaluated thunks are getting built up inside the PRNG seed.
16:01:19 <Nereid> show x = (something using monomFactor x and monomExponent x)
16:01:31 <mel-> aaah, thanks
16:01:48 <Nereid> well there's another choice if you use record puns
16:01:49 <cmccann> which really seems like something that System.Random shouldn't allow
16:02:01 <Lethalman> cmccann, so seq did evaluate the tuple itself (s1, s2) but not the contents... sob :'-(
16:02:05 <Fuuzetsu> oh, apparently it's New Year's in UK... I was wondering what those fireworks were outside.
16:02:21 <Lethalman> cmccann, I bet that nobody would end up thinking arithmetic between a couple of numbers is that problematic
16:02:24 <Nereid> i.e.
16:02:26 <Lethalman> how can I trust haskell?
16:02:48 <Nereid> {-# LANGUAGE NamedFieldPuns #-}
16:02:48 <Nereid> show (Monom { monomFactor = a, monomExponent b} = (something involving a and b)
16:02:52 <Nereid> oops I forgot a )
16:03:08 <Jafet> {-# LANGUAGE TrustMe #-}
16:03:23 <Lethalman> cmccann, perhaps bangs should be added to the StdGen type?
16:03:36 * mel- wonders what the matter is with trusting Haskell's arithmetic
16:04:01 <cmccann> Lethalman, I can't think of any reason not to be strict in the PRNG data
16:04:03 <Jafet> @quote and.beyond
16:04:03 <lambdabot> identity says: "To " ++ (show $ log (2^1024)) ++ " and beyond!"
16:04:20 <Lethalman> mel-, can you spot the issue? http://hackage.haskell.org/packages/archive/random/1.0.1.1/doc/html/src/System-Random.html#stdNext
16:04:26 <cmccann> I don't know, somebody help me out here :P
16:04:44 <cmccann> what's the deal with System.Random and apparently building up thunks inside StdGen?
16:05:02 <rwbarton> well the real problem is here data StdGen  = StdGen Int32 Int32
16:05:31 <Lethalman> rwbarton, which should be StdGen !Int32 !Int32 ?
16:05:41 <rwbarton> I would think so
16:05:44 <cmccann> yeah.
16:06:01 <Lethalman> exactly that :( lost my entire afternoon and evening and... a little of life to understand that :S
16:06:05 <rwbarton> System.Random is not really suitable for "serious use" anyways
16:06:19 <Lethalman> rwbarton, should I be using mwc or whatelse?
16:06:22 <cmccann> would be nice if it was a little more helpful though
16:06:43 <Lethalman> StdGen looked very appealing due to the non-IO nature
16:06:56 <cmccann> given that it took this much fiddly crap just to figure out that apparently it's StdGen at fault
16:07:33 <Nereid> there are plenty of other non-IO rngs aren't there?
16:07:41 <rwbarton> hmm
16:07:45 <Lethalman> Nereid, yes, but what's a good one?
16:07:52 <cmccann> I think it's reasonable to expect stuff like StdGen that's a quasi-standard and an obvious place to start to not have pitfalls like that
16:07:54 <Lethalman> because apparently, writing broken libraries seem easy
16:07:59 <Nereid> I dunno, haven't looked.
16:08:04 <Rarrikins> The easiest to use is just randoms. You get a nice infinite list.
16:08:41 <Lethalman> Rarrikins, randoms is System.Random, which is what we're saying it's broken
16:10:05 <Fuuzetsu> can't you poke the maintainer to patch it?
16:10:18 <Rarrikins> Ahh.
16:10:50 <Lethalman> Fuuzetsu, I can yes, but after this I don't know how much I'm willing to keep learning haskell sincerely
16:10:54 <tootlyo> Happy new year everyone! Does anyone know an elegant way to work out if each item in a list is equal? Eq a => [a] -> Bool
16:11:08 <cmccann> rwbarton, strict fields in a data type are standard, right? so I don't think there's any reason StdGen shouldn't be defined that way...
16:11:52 <rwbarton> Haskell 98, yep. for instance Complex's fields are strict IIRC
16:12:07 <Fuuzetsu> Lethalman: well, if you don't and just give up on it, more people will make the same mistake
16:12:13 <Fuuzetsu> it can't get better if you don't report it
16:12:14 <hpc> :t all (==)
16:12:15 <lambdabot>     Couldn't match expected type `Bool' with actual type `a0 -> Bool'
16:12:15 <lambdabot>     Expected type: a0 -> Bool
16:12:15 <lambdabot>       Actual type: a0 -> a0 -> Bool
16:12:17 <hpc> :t all
16:12:19 <lambdabot> (a -> Bool) -> [a] -> Bool
16:12:36 <fmap> @ty zipWith (==) <*> tail
16:12:37 <lambdabot> Eq b => [b] -> [Bool]
16:12:46 <hpc> :t foldr (==) True
16:12:47 <lambdabot> [Bool] -> Bool
16:12:52 <Lethalman> Fuuzetsu, I know this pretty much, there's plenty of people in here more knowledgeable than me to report the bug though if you really want to make it better... since you use haskell every day
16:12:54 <cmccann> Lethalman, for whatever it's worth this isn't a matter of Haskell so much as it is an arguable bug in a quasi-standard library
16:13:00 <hpc> pah
16:13:01 <Lethalman> but I will certainly report it to the maintainer anyway
16:13:06 <Nereid> hmm, what was the cute solution to tootlyo's
16:13:14 <cmccann> Lethalman, what version of the random package do you have?
16:13:33 <Nereid> oh, fmap has it.
16:13:40 <fmap> @ty and .: zipWith (==) <*> tail
16:13:41 <lambdabot> Eq b => [b] -> Bool
16:13:42 <cmccann> though I guess that doesn't matter too much since you were using stdNext from the latest version on hackage.
16:13:42 <rwbarton> isn't random in the HP?
16:13:46 <Lethalman> cmccann, 1.0.1.1
16:13:52 <Nereid> @ty and . zipWith (==) <*> tail)
16:13:53 <lambdabot> parse error on input `)'
16:13:55 <Nereid> @ty and . (zipWith (==) <*> tail)
16:13:56 <lambdabot> Eq b => [b] -> Bool
16:14:02 <Nereid> eh
16:14:26 <rwbarton> I mean, it is a library described in the Haskell 98 report
16:14:26 <Nereid> substitute tail with drop 1 to make me happy.
16:14:28 <cmccann> rwbarton, yes, it is
16:14:31 <rwbarton> so effectively it is part of the language
16:14:36 <Lethalman> cmccann, I understand it's not a matter of haskell, but it's still a matter of a basic library, and since it's still haskell fault to do simple mistakes... I don't know if I will keep learning haskell really
16:14:58 <rwbarton> laziness sucks
16:15:07 <rwbarton> unfortunately strictness sucks too
16:15:10 <Nereid> random is not specified in any report.
16:15:18 <rwbarton> how about this one http://www.haskell.org/onlinereport/random.html
16:15:23 <cmccann> Lethalman, I suspect it's a matter of people doing serious stuff with RNGs using something else, and toy examples would work
16:15:28 <Nereid> we don't have a module Random.
16:15:31 <elliott> Lethalman: to be fair many people have made practical programs that use the RNG in Haskell
16:15:34 <Nereid> and it's not in haskell 2010
16:15:35 <rwbarton> ?
16:15:37 <rwbarton> ??
16:15:39 <elliott> and afaict nobody has run into this problem except you
16:15:56 <elliott> and there are "production-quality" RNG libraries that aren't built on the same infrastructure
16:16:00 <Nereid> ???
16:16:08 <rwbarton> oh, did it get removed from haskell 2010?
16:16:13 <cmccann> rwbarton, apparently so
16:16:14 <Lethalman> btw will end this simple test
16:16:20 <rwbarton> nevertheless it is in haskell 98
16:16:24 <rwbarton> I wonder what the story there is
16:16:30 <cmccann> it is in the HP though
16:16:48 <Lethalman> elliott, evidently they didn't exceed calling 100000 times the monad, probably didn't do a simulation with it
16:16:53 <Nereid> System.Random isn't in haskell 98, which didn't even have hierarchical libraries.
16:17:09 <rwbarton> this is shitty nitpicking
16:17:12 <Nereid> yes.
16:17:38 <cmccann> rwbarton, I would say it's only moderately irritating, not quite "shitty"...
16:17:40 * cmccann stops
16:17:45 <Nereid> also, haskell 98 leaves StdGen as "abstract".
16:17:52 <rwbarton> a much better reason to stop learning Haskell than any particular issue with System.Random
16:18:08 <rwbarton> no, seriously this kind of thing needs to stop
16:18:21 <Nereid> which kind of thing?
16:18:29 <Fuuzetsu> being precise
16:19:01 <cmccann> ok, seriously though
16:19:02 * hackagebot csv-nptools 0.3.0 - A collection of CSV tools  http://hackage.haskell.org/package/csv-nptools-0.3.0 (NicolasPouillard)
16:19:08 <cmccann> is there any reason why StdGen shouldn't have strict fields
16:19:12 <cmccann> and if not, why doesn't it
16:19:33 <kopi> Happy new year.:D
16:19:39 <cmccann> it's the RNG API specified in H98 and it's in the HP
16:19:48 <rwbarton> people making lame excuses like "well it's not part of the language", "well it's not in the report", "well System.Random is *totally* different from Random", etc.
16:20:02 <cmccann> it really ought to work decently even if used for large amounts of data
16:20:35 <cmccann> whether or not more experienced people doing serious work use other packages
16:21:02 <elliott> I am mostly just surprised nobody has run into this before
16:21:09 <Nereid> then someone should file the bug report. ask the maintainer.
16:21:12 <elliott> I guess it is understandable since you need really big numbers
16:21:20 <cmccann> elliott, not even all that big
16:21:22 <elliott> we did establish someone should fire a bug report ages ago
16:21:49 <cmccann> just big enough that if you're doing anything other than generating a whole bunch at once it probably wouldn't be that noticeable
16:22:04 <rwbarton> I wasn't around for the original issue but I think if you consume numbers as they are produced you can never run into this
16:22:16 <flebron> if i have a monad, f <$> x <*> y <*> z should be thought of as x' <- x, y' <- y, z' <- z, f x y z?
16:22:31 <Nereid> it is that.
16:22:51 <flebron> can i somehow think of it like that (i know it doesn't strictly make sense) for just an applicative?
16:22:54 <cmccann> rwbarton, Lethalman was generating a list of random samples, which were then filtered and the length of the list taken
16:23:09 <flebron> where "<-" is purely conceptual now, "take outside of the box" or whatever that means
16:23:24 <Nereid> flebron: an Applicative is like a Monad except that results aren't allowed to influence computation paths.
16:23:41 <cmccann> rwbarton, and just doing "snd $ next rng" was using more memory than makes sense
16:23:53 <flebron> i don't have a formal or intuitive notion of what a "computation path" is
16:23:57 <Lethalman> rwbarton, apparently the problem is that you create new numbers from old numbers, and they never get evaluated
16:23:58 <rwbarton> where's the original code?
16:24:04 <Nereid> I believe there have been proposals for applicative do notation.
16:24:06 <rwbarton> normally they would get evaluated
16:24:25 <rwbarton> the issue was accumulating thunks in the RNG state, right?
16:24:30 <cmccann> rwbarton, I never could figure out why they apparently weren't
16:24:36 <cmccann> rwbarton, that was my conclusion
16:24:41 <cmccann> but I'm really not an expert at this
16:24:44 <Nereid> flebron: the sequence of actions to be performed.
16:25:32 <Nereid> flebron: e.g. if you wrote an IO thing with only getLine, putStrLn, and applicative combinators, then every time it's executed, the same sequence of getLine and putStrLn actions will be performed.
16:25:35 <cmccann> I don't have the links to the code Lethalman pasted anymore though
16:25:37 <Nereid> although the things passed to putStrLn may vary.
16:25:56 <flebron> why could I not use "if" in applicative style?
16:26:06 <Nereid> in what way?
16:26:32 <cmccann> flebron, it would "execute" both branches, and then only keep the result of one
16:26:43 <hpc> :t if'
16:26:44 <lambdabot>     Not in scope: if'
16:26:44 <lambdabot>     Perhaps you meant f' (imported from Debug.SimpleReflect)
16:26:45 <Nereid> sure, you can have something that does that.
16:26:45 <jmcarthur> you can use if with applicative. it's just that you can't use it to control whether the side effects execute
16:26:54 <hpc> @let if' x y z = if x then y else z
16:26:55 <lambdabot>  Defined.
16:27:01 <Nereid> :t liftA3 if'
16:27:02 <lambdabot> Applicative f => f Bool -> f d -> f d -> f d
16:27:09 <hpc> > if' True <$> Just False <*> Nothing
16:27:11 <lambdabot>   Nothing
16:27:11 <elliott> Nereid: The things passed to putStrLn may vary?
16:27:19 <elliott> I don't see how that's true. They can't depend on effects in any way.
16:27:22 <jmcarthur> using if with applicative is like trying to define if in a language that doesn't have laziness
16:27:34 <Nereid> elliott: sure they can. they can depend on the results of the prevoius getLines.
16:27:40 <elliott> Nereid: ?
16:27:41 <elliott> No, you're wrong.
16:27:42 <rwbarton> btw fgl is even more not for serious use than random
16:27:45 <elliott> :t fmap putStrLn getLine
16:27:46 <lambdabot> IO (IO ())
16:27:49 <elliott> you need "join" to do that
16:27:50 <Nereid> uh
16:27:54 <Nereid> ok, bad example then!
16:28:11 <jmcarthur> you just can't do it
16:28:17 <flebron> LYAH gives an example of some birds on a stick
16:28:24 <elliott> rwbarton: what problems does fgl have? I know the API is apparently pretty bad
16:28:26 <Lethalman> cmccann, is there anything I can do to fix Rand in my code? should I use another library?
16:28:43 <Nereid> maybe a parser example would be better.
16:28:44 <Jafet> The API is better than the documentation
16:29:01 <cmccann> parsers probably rely on Alternative, not just Applicative
16:29:06 <Nereid> if you only use applicative stuff, you can't use the result of one parse to determine what parser to run next.
16:29:16 <rwbarton> well the last time I used it was like 10 years ago, but I doubt it's improved since then. it had horrible space usage from what I recall
16:29:25 <rwbarton> basically it is like the String of graph libraries
16:29:43 <flebron> oh hm
16:30:01 <cmccann> Lethalman, well, System.Random uses a RandomGen type class
16:30:11 <flebron> because the <*>'ing of my function will be <*>ing of a pure function, which does not understand anything about its environment
16:30:20 <jmcarthur> Nereid: that's right, you can't
16:30:23 <flebron> whereas with a monad, i can output a -> m b myself, to change the context
16:30:30 <cmccann> Lethalman, so you could use the implementation of next you have with your own data type and make a RandomGen instance, &c.
16:30:34 <Ralith> Lethalman: you shouldn't be surprised that StdGen isn't fit for very serious use; few standard library RNGs are. There are a lot of concerns involved in selecting an appropriate RNG for a particular task.
16:30:42 <flebron> in applicative, <*> takes care (and rights) of working with the environment
16:31:13 <cmccann> Ralith, it still shouldn't have major performance pitfalls :P
16:31:25 <hpc> cmccann: essentially yes
16:31:55 <Ralith> cmccann: sure, but if you're writing code so badly effected, perhaps it's time to consider a RNG algorithm more appropriate for your use anyway.
16:32:02 <hpc> cmccann: if you stick with just (>>), you have a parser for regular grammers; add Applicative and Alternative and that's CFG; use parsec's hidden state type var and you get context-sensitive
16:32:02 <cmccann> a bad RNG library should at least be able to generate numbers with bad statistical properties quickly
16:32:06 <kaan> hello
16:32:08 <Nereid> yeah, and that makes the getLine/putStrLn thing obvious too.
16:32:16 <Nereid> you can't use the result of a getLine to determine what to putStrLn next.
16:32:25 <Ralith> I'm not saying System.Random can't be improved, I'm saying it being shitty isn't a huge deal.
16:32:25 <cmccann> hpc, hunh, interesting!
16:33:02 <flebron> well that's not that clear to me nereid
16:33:07 <flebron> i mean, getLine gives me an IO String
16:33:13 <kaan> i've got a little question. i want to write something, where i have to 'show' a number. but when i type 'show 012' it return "12". i don't want, that it leaves the '0' out
16:33:23 <flebron> my function is <*>'d into String -> b, so I do get the input of what getLine is
16:33:29 <hpc> > 012
16:33:30 <lambdabot>   12
16:33:35 <Nereid> kaan: well, 012 = 12.
16:33:35 <mikeplus64> what version of haddock does hackage use?
16:33:45 <hpc> kaan: twelve is twelve
16:33:46 <c_wraith> kaan: 012 is not a different number from 12 or 000000000000012
16:33:51 <cmccann> flebron, but you can't execute IO actions based on that input
16:33:58 <Nereid> kaan: are you looking to format the output in a specific way?
16:34:03 <flebron> right, sure, i can't decide which IO actions to execute
16:34:13 <Nereid> putStrLn "a" and putStrLn "b" are different IO actions.
16:34:14 <flebron> in fact i can't execute any IO actions at all, <*> decides what to do for me
16:34:26 <Nereid> no one stops you from doing getLine *> putStrLn "hi", though
16:34:31 <flebron> i can only transparently thread functions along IO
16:34:37 <Nereid> note (*>) = (>>)
16:35:16 <ivanm> @pl \(x,y) -> print x >> print y
16:35:16 <lambdabot> uncurry ((. print) . (>>) . print)
16:35:28 <ivanm> OK, how come the version of pointfree on hackage goes into an endless loop for that? :s
16:35:31 <cmccann> Lethalman, sorry, keep getting distracted... did that make sense?
16:35:47 <kaan> Nereid, yes its a number like 12032 and i show it and afterwards split it in 12 and 032, and then read it again
16:35:54 <jmcarthur> ivanm: it doesn't for me, but mine might be older
16:35:59 <hpc> @pl-ver
16:35:59 <lambdabot> Unknown command, try @list
16:36:03 <hpc> @pl-
16:36:03 <lambdabot> pointless: sorry, nothing to resume.
16:36:09 <ivanm> 1.0.4.3 ?
16:36:09 <hpc> @help
16:36:09 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
16:36:12 <flebron> kaan, 032 is 32
16:36:15 <hpc> @list
16:36:15 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
16:36:19 <flebron> if you wish for 032 to not be 32, you can not use integers
16:36:25 <hpc> hmm
16:36:34 <jmcarthur> ivanm: i don't even know
16:36:54 <ivanm> yeah, doesn't help when it doesn't have a --version flag :s
16:36:59 <jmcarthur> yeah...
16:37:08 <jmcarthur> i'll back up my binary and try upgrading it
16:37:20 <Lethalman> cmccann, evalRandIO will call getStdRandom that will use StdGen, that seems the only thing other than a RandomGen instance that I should write
16:37:24 <hpc> dude, cabal-dev
16:37:36 <jmcarthur> hpc: (i have the backup already)
16:37:55 <rwbarton> > length $ replicate 100000 ()
16:37:56 <lambdabot>   100000
16:38:06 <jmcarthur> ivanm: you say the latest is 1.0.4? it's trying to install 1.0.3 for me
16:38:08 <rwbarton> > length $ take 10000 $ randoms (mkStdGen 17)
16:38:09 <lambdabot>   Ambiguous type variable `a0' in the constraint:
16:38:10 <lambdabot>    (System.Random.Random a0...
16:38:15 <cmccann> Lethalman, right, and you can pretty much copy and paste the definitions for StdGen
16:38:16 <jmcarthur> and that one fails to build
16:38:17 <rwbarton> > length $ take 10000 (randoms (mkStdGen 17) :: [Int])
16:38:19 <lambdabot>   10000
16:38:23 <Lethalman> cmccann, but now that I read the code I fear the Identity problem will come again: evalRandIO (Rand (RandT x)) = getStdRandom (runIdentity . runStateT x)
16:38:24 <rwbarton> > length $ take 100000 (randoms (mkStdGen 17) :: [Int])
16:38:26 <lambdabot>   100000
16:38:39 <jmcarthur> ah, dependency conflicts
16:38:54 <cmccann> Lethalman, you might as well define something like "StrictGen = StrictGen !Int32 !Int32"
16:38:57 <ivanm> jmcarthur: hackage has 1.0.4.3 accordingn to cabal
16:39:09 <jmcarthur> yeah it's dependency related
16:39:14 <ivanm> oh, I must have it built from before
16:39:17 <Lethalman> cmccann, of course, but what about getStdRandom (runIdentity . runStateT x) ? fearing the Identity now :P
16:39:20 <cmccann> Identity shouldn't actually take up any space, it should be a newtype
16:39:29 <Ralith> @src Identity
16:39:29 <lambdabot> newtype Identity a = Identity { runIdentity :: a }
16:39:31 <ivanm> anyway, I've got to pick up a sibling after a NYE party...
16:39:32 <ivanm> bbl
16:39:39 <cmccann> @src StateT
16:39:39 <lambdabot> Source not found. I am sorry.
16:39:46 <cmccann> dammit lambdabot
16:39:52 <Lethalman> cmccann, I remind you that before the current problem, I was using the monad and Identity was a peak in memory usage
16:39:53 <hpc> cmccann: "taking up space" isn't what you should care about when using newtype
16:40:00 <jmcarthur> @unmtl StateT s m a
16:40:00 <lambdabot> s -> m (a, s)
16:40:04 <hpc> it's purely a "how many bottoms" issue
16:40:19 <cmccann> Lethalman, it was probably getting blamed for something else
16:40:37 <cmccann> newtypes don't even exist at runtime
16:40:57 <jmcarthur> i believe newtypes are even in the spec as having that property, but don't quote me on that
16:41:44 <Jafet> Heh, StdGen leaks memory
16:41:58 <Lethalman> hope so
16:42:08 <cmccann> Lethalman, all of Rand, RandT, Identity, and StateT are newtypes
16:42:22 <hpc> Rand isn't a type alias?
16:42:29 <cmccann> it's a newtype.
16:42:32 <cmccann> for... some reason.
16:42:36 <jmcarthur> yeah, the spec says a newtype is "a new type whose representation is the same as an existing type." and "These coercions may be implemented without execution time overhead; newtype does not change the underlying representation of an object."
16:42:51 <Jafet> > last $ unfoldr (Just . random) $ mkStdGen 0 :: Int
16:42:54 <hpc> funny thought: Identity as an alias for IdentityT
16:42:56 <lambdabot>   mueval-core: Time limit exceeded
16:42:58 <hpc> let the monads never stop
16:43:22 <jmcarthur> hpc: pronouncing "IdentityT" just rolls right off the tongue
16:43:41 <hpc> jmcarthur: "identi-titty"
16:43:44 <Lethalman> cmccann, getStdRandom is a little complex :S
16:43:46 <cmccann> hpc, "Identity = IdentityT Identity", then?
16:44:07 <jmcarthur> and don't forget the monad transformer transformer, IdentityTT
16:45:01 <hpc> transformers: transformers in disguise
16:45:05 <rwbarton> right, so "length $ take 100000 (randoms (mkStdGen 17) :: [Int])" leaks but "foldl' (+) 0 $ take 100000 (randoms (mkStdGen 17) :: [Int])" doesn't leak
16:45:19 <hpc> "i am not optimus prime... i am..." *whoosh* "optimus double-prime!"
16:45:21 <cmccann> Lethalman, wait, hm
16:45:35 <cmccann> oh, of course, the randomIO stuff uses StdGen automatically, yay
16:46:16 <elliott> rwbarton: because each element depends on the previous one?
16:46:22 <elliott> er
16:46:24 <elliott> each cons cell rather
16:46:26 <elliott> depends on the previous element
16:46:29 <cmccann> Lethalman, just replace evalRandIO as well
16:46:33 <rwbarton> yeah
16:46:34 <elliott> that's very subtle
16:46:39 <cmccann> Lethalman, see http://hackage.haskell.org/packages/archive/MonadRandom/0.1.8/doc/html/src/Control-Monad-Random.html#evalRandIO
16:47:01 <rwbarton> and because the value returned by stdNext depends on the state of the new rng (but this is sort of obvious I guess)
16:47:08 <rwbarton> so if you force that then your problem goes away
16:47:20 <rwbarton> usually people consume random numbers
16:47:38 <rwbarton> let's try with a "filter even" or something
16:47:46 <elliott> filter was part of the original problem in fact!
16:47:46 <elliott> iirc
16:48:02 <rwbarton> length . filter even $ take 10000000 (randoms (mkStdGen 17) :: [Int]) -- doesn't leak
16:48:22 <rwbarton> which makes sense too
16:48:38 <Jafet> What is being leaked?
16:48:52 <rwbarton> in "length $ take 100000 (randoms (mkStdGen 17) :: [Int])" the RNG state is growing
16:48:55 <elliott> so one fix would be to make the cons cell in the list randoms produces seq the element
16:48:58 <elliott> since it depends on it anyway
16:49:02 <elliott> er
16:49:04 <elliott> seq the previous element
16:49:09 <elliott> *cells
16:49:09 <cmccann> Lethalman, so something like "fmap (evalRand x) newNotStdGen" would work, &c.
16:49:14 <elliott> sort of
16:49:41 <Jafet> I'm pretty sure the solution is to make the state strict
16:50:20 <cmccann> I would think MonadRandom should use the strict state monad and that StdGen should have strict fields
16:51:11 <rwbarton> well here is the relevant bit http://hackage.haskell.org/packages/archive/random/latest/doc/html/src/System-Random.html#stdNext
16:52:00 <rwbarton> elsewhere the tuple result of this function is being pattern-matched on, but not the components of the tuple
16:52:24 <monochrom> yeah, System.Random is a bit too non-strict
16:52:42 <rwbarton> it really should just force fromIntegral z' and s1'' and s2''
16:52:43 <monochrom> at least the Std one
16:53:18 <monochrom> "last (take n (randoms x))" is usually a stack overflow :)
16:53:19 <cmccann> monochrom, that's a popular topic today!
16:53:35 <rwbarton> monochrom: turns out even "length (take n (randoms x))" is a stack overflow
16:53:40 <rwbarton> or sorry
16:53:49 <rwbarton> not a stack overflow, but it takes order n space
16:55:09 <cmccann> not even an enormous amount of space, but far more than it should
16:55:55 <m3ga> rwbarton: isn't due the length rather than take ...
16:56:34 <m3ga> length [1..1000000000] doesn't fare very well either.
16:56:39 <rwbarton> try it
16:56:43 <elliott> m3ga: ?
16:56:46 <elliott> that's why there's a take n
16:56:51 <cmccann> it wouldn't bother me much except that stuff in quasi-standard libraries should behave reasonably well when used in a naive fashion, like filtering and counting a big list of random numbers
16:56:54 <rwbarton> with maybe slightly fewer 0s
16:57:01 <rwbarton> it does work with filtering
16:57:29 <Rarrikins_x> > 5
16:57:32 <lambdabot>   mueval-core: Time limit exceeded
16:57:33 <rwbarton> I think what happened in this case was something like generating a bunch of numbers and then generating some more numbers and inspecting the new ones
16:57:35 <Rarrikins_x> O-o
16:57:37 <mel-> i know how to use 'filter' on lists. is there a haskell short-cut for partitioning a list into two disjoint sublists where the first one is defined by a predicate being true and the second is defined by the predicate being false?
16:57:39 <elliott> so why did lethalman have a problem when using filtering
16:57:42 <elliott> which is how this all started
16:57:48 <Rarrikins_x> > 1 + 1
16:57:51 <lambdabot>   2
16:57:56 <Jafet> :t partition
16:58:00 <lambdabot> (a -> Bool) -> [a] -> ([a], [a])
16:58:03 <Jafet> Surprise
16:58:35 <mel-> :-D
16:58:35 <cmccann> elliott, honestly I'm still not sure exactly why his code used so much memory. I think there were multiple issues, but the StdGen thing was most irritating
16:58:36 <mel-> thanks
16:58:57 <Rarrikins_x> @hoogle (a -> Bool) -> [a] -> ([a], [a])
16:58:58 <lambdabot> Prelude break :: (a -> Bool) -> [a] -> ([a], [a])
16:58:58 <lambdabot> Data.List break :: (a -> Bool) -> [a] -> ([a], [a])
16:58:58 <lambdabot> Prelude span :: (a -> Bool) -> [a] -> ([a], [a])
16:59:10 <cmccann> Jafet, I love when people ask "is there a function to frob a widget?" and the answer is "yes, the standard library function frobWidget"
16:59:25 <Jafet> @hoogle frob
16:59:25 <lambdabot> package YFrob
16:59:28 <Jafet> @hoogle widget
16:59:29 <lambdabot> Text.Html widget :: String -> String -> [HtmlAttr] -> Html
16:59:29 <lambdabot> Text.XHtml.Strict widget :: String -> String -> [HtmlAttr] -> Html
16:59:29 <lambdabot> Text.XHtml.Frameset widget :: String -> String -> [HtmlAttr] -> Html
16:59:29 <Rarrikins_x> @src partition
16:59:29 <lambdabot> partition p xs = foldr (select p) ([],[]) xs
16:59:29 <lambdabot>     where select p x ~(ts,fs) | p x       = (x:ts,fs)
16:59:31 <lambdabot>                               | otherwise = (ts, x:fs)
16:59:41 <Jafet> It can probably frob widgets, too.
17:00:01 <Jafet> ~(ts, fs)
17:00:22 <Jafet> "Clever use of laziness there"
17:02:03 <monochrom> oh! that's neat, yes :)
17:02:46 <Jafet> Oh, it's using foldr. So that was a genuine use of laziness.
17:03:28 <elliott> cmccann: "is there a function to nub a list?"
17:03:53 <hpc> elliott: haha
17:04:34 <cmccann> elliott, well somebody might ask that maybe >:[
17:04:36 <Jafet> Little ol' nubby
17:05:09 <monochrom> in fact...
17:05:13 <monochrom> @type nubBy
17:05:14 <lambdabot> (a -> a -> Bool) -> [a] -> [a]
17:05:22 <monochrom> that's nubby for you! :)
17:05:56 <Jafet> No, 'e's nubbykins
17:09:35 <shapr> Is there a recommended IMAP client library on hackage?
17:11:06 <shapr> I'm looking for something that supports imap-ssl specifically.
17:11:26 * shapr yodels into the echo chamber
17:11:59 <hpc> * shapr yodels into the echo chamber
17:12:03 <shapr> ha
17:12:10 <hpc> uh
17:12:22 <hpc> http://hackage.haskell.org/package/imapget
17:12:23 * shapr installs haskellnet
17:12:28 <shapr> oh, I'll try that one
17:12:32 <shapr> hpc: Have you used it?
17:12:35 <hpc> no
17:12:41 <hpc> it's the only relevant results from "hoogle imap"
17:12:53 <hpc> so if it's not that you are fucked
17:13:08 <elliott> haskellnet looks kind of bitrotten
17:13:52 <cmccann> is haskellnet a purely functional implementation of skynet?
17:13:58 <ivanm> jmcarthur: so, any luck with newer version
17:13:58 <ivanm> ?
17:14:16 <shapr> elliott: Yah, could be.
17:14:24 <shapr> elliott: But I don't see any other options.
17:14:38 <shapr> I could use the Haskell wrapper for curl?
17:14:51 <Jafet> skynet runs on the cloud.
17:14:53 <shapr> Didn't CosmicRay do some imap code? Or was that only in Python?
17:15:14 <ivanm> shapr: that was in python
17:15:26 <shapr> oh, too bad.
17:16:04 <jmcarthur> ivanm: ah, no, i lost interest
17:16:14 <ivanm> heh, fair enough
17:16:22 <ivanm> looks like that might have been fixed in git...
17:17:07 <ivanm> benmachine is the maintainer, and nickserv says that someone with that nick is on IRC atm...
17:17:09 <ivanm> just not here
17:18:04 <cmccann> ivanm, probably hiding from you
17:18:15 <ivanm> that'd be right... >_>
17:27:21 <mercury^> I have a module which exports a type (Foo s) and a function (bar ∷ (Foo s) → X).  How can I hide the type variable s from the users?
17:28:38 <hpc> without any other information, i would say reconsider how you define Foo
17:29:08 <mercury^> (It would seem that something like (type Bar = (exists s. Foo s)) is what I need. But exists is not a keyword with any GHC extension, is it?)
17:29:37 <rwbarton> it is not
17:29:59 <elliott> you can do
17:30:04 <elliott> data Bar = forall s. Foo s
17:30:09 <elliott> which is the same as data Bar = Foo (exists s. s)
17:30:19 <elliott> you will find this type quite useless however, and be unable to write any reasonable bar
17:30:34 <rwbarton> but here you want data Bar = forall s. Bar (Foo s)
17:30:36 <mercury^> hpc: the module uses s internally as a shadow type to encode some form of bounds checking; I do not know how I should redefine Foo, as you suggest.
17:30:48 <rwbarton> but I'm not sure whether that is really what you want
17:30:51 <elliott> rwbarton: er right
17:31:12 <elliott> mercury^: this example is too abstract to help you with
17:31:55 <mercury^> Well, I will describe a more concrete example which is similar to mine then.
17:32:06 <mercury^> Describing my exact example would be unnecessarily complicated, I think.
17:32:22 <hpc> hpaste?
17:34:03 * hackagebot xmonad 0.11 - A tiling window manager  http://hackage.haskell.org/package/xmonad-0.11 (AdamVogt)
17:34:05 * hackagebot xmonad-contrib 0.11 - Third party extensions for xmonad  http://hackage.haskell.org/package/xmonad-contrib-0.11 (AdamVogt)
17:35:52 <hpaste> mercury pasted “Removing a shadow” at http://hpaste.org/80032
17:36:07 <mercury^> There you go.
17:37:02 <mercury^> I have another module which provides some function of type (Covering c → [[Int]]) and exports Covering.
17:37:16 <mercury^> But the users of that module do not need to know about the c parameter.
17:38:05 <mercury^> (Reading the whole paste is overkill, really) :)
17:41:36 <shapr> Ok, what's the best sqlite binding for Haskell?
17:42:32 <shapr> Is there a HaskellDB backend for sqlite?
17:42:42 <hpc> you mean hdbc?
17:42:48 <mercury^> Oh, a related issue: the type of fromList currently is polymorphic in the shadow parameter c. But the shadow should be a function of the argument – is there any way to encode that?
17:43:23 <pnielsen> shapr: http://hackage.haskell.org/package/HDBC-sqlite3-2.3.3.0
17:43:31 <mercury^> (Or at least to make sure that the shadows resulting from any two invocations are different.)
17:44:33 <hpc> benefit to the hdbc bindings is that when you realize that sqlite is horrible and you should feel bad, it's not overly painful to switch to a different rdbms
17:44:41 <hpc> ;)
17:44:53 <shapr> pnielsen: Have you tried http://hackage.haskell.org/package/sqlite-simple ?
17:45:11 <pnielsen> shapr: no. I would use HDBC and the sqlite driver
17:45:16 <DrChaos[S]> @src length
17:45:16 <lambdabot> Source not found. Just what do you think you're doing Dave?
17:45:19 <startling> hpc: why is sqlite bad?
17:45:19 <lambdabot> startling: You have 1 new message. '/msg lambdabot @messages' to read it.
17:45:29 <DrChaos[S]> @src Data.List.length
17:45:29 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
17:45:32 <pnielsen> shapr: there is an example in RWH: http://book.realworldhaskell.org/read/using-databases.html
17:45:47 <shapr> I haven't used persistent, and it has a sqlite backend. Is persistent only used in Yesod, or is it easy to use separately?
17:45:47 <pnielsen> sqlite provides fewer guarantees, has no real types, and performance is worse
17:45:59 <mercury^> rwbarton: any suggestion?
17:46:01 <pnielsen> it is very useful for portable applications, but not really preferable for most other things
17:46:09 <hpc> firefox uses it in the closest thing to a legit use-case that i can think of
17:46:11 <pnielsen> (it was designed to be a portable/lightweight db, hence the name)
17:46:20 <hpc> which is to be a config system
17:46:31 <pnielsen> hpc: there are plenty of legit use-cases: any time a portable applications needs to store info
17:46:40 <shapr> The code I'm writing will be executed on my Raspberry Pi, so I figure sqlite is a good choice.
17:46:44 <pnielsen> or a history, or credential storage, ...
17:46:48 <hpc> pnielsen: acid-state works for portable applications storing data
17:46:54 <hpc> and provides guarantees and performance
17:46:56 <pnielsen> so does sqlite
17:47:04 <hpc> and type safety
17:47:10 <hpc> sqlite does none of those 3 things
17:47:44 * shapr reads up on persistent
17:48:10 <pnielsen> fwiw persistent supports sqlite
17:49:40 <pnielsen> hpc: don't know if I would describe acid-state as portable. If the db is only going to be used by Haskell applications, sure.
17:49:45 <shapr> pnielsen: and it looks like it requires template haskell, which afaik doesn't exist on armhf
17:50:05 <pnielsen> shapr: hdbc is easy to use
17:50:31 <hpc> pnielsen: portable applications rarely need cross-application storage
17:50:33 <weirdguy> Hello
17:50:55 <pnielsen> but if you only need to store data from that one haskell application, then hpc's suggestion is better. acid-state is more like persistent serialized data
17:50:59 <DrChaos[S]> ok guys, is this how you implement the map function? don't show me the answer until you know that I've got it. : map' :: (a -> b) -> [a] -> [b]; map' (f a) [] = []; map' (f a) (x:xs) = f x : (map' (f a) xs)
17:51:28 <Nereid> DrChaos[S]: what is (f a)?
17:51:32 <shapr> Oh goody! Persistent does NOT depend on TH so it can be built with ghc-iphone! http://www.haskell.org/pipermail/haskell-cafe/2012-February/099399.html
17:51:39 * shapr bops cheerfully
17:51:40 <Nereid> DrChaos[S]: that doesn't even parse.
17:52:03 <DrChaos[S]> Nereid, ah, if you're asking me that then I forgot to apply the function named f to an element of the list
17:52:07 <Nereid> no
17:52:15 <Nereid> map' (f a) ...
17:52:17 <Nereid> =
17:52:20 <monochrom> "f x : (recursive call for xs)" is right
17:52:22 <Rarrikins_x> DrChaos[S]: No, it's in there, but it's strange.
17:52:55 <DrChaos[S]> huh, wait
17:53:09 <Nereid> DrChaos[S]: start by getting something that ghc can parse
17:53:11 <shapr> pnielsen: I check out acid-state, thanks.
17:53:16 <Nereid> and then typecheck
17:53:18 <pnielsen> DrChaos[S]: try to run it in ghci first. You can do let foo = bar in expr
17:53:23 <shapr> Yah, I'm with pnielsen
17:53:23 <monochrom> but "f a" is probably a symptom of mathematicians' incorrect wording "the function f(x)". (the correct wording is, clearly, "the function f")
17:53:35 <Nereid> monochrom: mathematicians do that?
17:53:40 <monochrom> Yes!
17:53:44 <hpc> all the time
17:53:47 <hpc> it's infuriating
17:53:57 <monochrom> mathematicians say many things wrong
17:54:02 <Rarrikins_x> Maybe f returns a function ;)
17:54:13 <hpc> it's really fun when they start using x
17:54:18 <cmccann> mathematicians also like spurious parentheses for function application
17:54:18 <monochrom> they get away with it because they are smart and they understand each other
17:54:22 <hpc> having "defined" it by saying "the function f(x)"
17:54:27 <Nereid> no.
17:54:31 <cmccann> I guess because they insist on using juxtaposition for something silly like multiplication
17:54:52 <hpc> monochrom: if only there existed a really stupid pedantic did-only-what-you-told-it mathematician
17:54:56 <hpc> like a computer of some sort...
17:54:57 <Nereid> I guess maybe you'd see it more frequently in applied math.
17:54:57 <hpc> :P
17:55:18 <DrChaos[S]> ok, how do I pass in a function to another function in Haskell?
17:55:24 <DrChaos[S]> that's what I need to do here
17:55:24 <pnielsen> they understand it because math papers have glossaries and specifications because of the amount of ambiguities/personal preferences...
17:55:33 <Nereid> DrChaos[S]: give it the name of the function.
17:55:35 <hpc> DrChaos[S]: a function is passed just like any other value
17:55:39 <cmccann> monochrom, I believe the goal when mathematicians communicate is to provide precisely enough information to convince the other person they could reconstruct your argument, and not an iota more
17:55:44 <DrChaos[S]> if you can show me that I might be able to give you something that ghci can parse
17:55:52 <monochrom> another thing they like saying is "there exists x such that P(x,y) for every y" leaving you to wonder whether it's "for all y, exists x, P(x,y)" or "exists x, for all y, P(x,y)"
17:56:04 <Nereid> DrChaos[S]: although that's different from pattern matching on a function value.
17:56:21 <Nereid> (f a) is not a legal pattern.
17:56:23 <Nereid> f is.
17:57:40 <DrChaos[S]> > let map' f (x:xs) = f x : (map' f xs) in map' (++ 1) [1,2,3]
17:57:42 <lambdabot>   Ambiguous type variable `a0' in the constraints:
17:57:42 <lambdabot>    (GHC.Num.Num a0)
17:57:42 <lambdabot>      a...
17:57:55 <Nereid> > 1 ++ 1
17:57:56 <lambdabot>   Ambiguous type variable `a0' in the constraints:
17:57:56 <lambdabot>    (GHC.Num.Num a0)
17:57:56 <lambdabot>      a...
17:58:01 <Nereid> that is what you're doing.
17:58:13 <Nereid> (also you forgot the base case)
17:58:19 <DrChaos[S]> OH *snort*
17:58:42 <Nereid> (it may be instructive to see what happens when you forget the base case)
17:58:59 <Nereid> > let map' f (x:xs) = f x : (map' f xs) in map' (+ 1) [1,2,3]
17:59:01 <lambdabot>   [2,3,4*Exception: <interactive>:3:5-37: Non-exhaustive patterns in function...
17:59:11 <Jafet> All lists are infinite
17:59:12 <DrChaos[S]> two plus signs for tack one list onto another, versus one plus sign for add one
17:59:54 <DrChaos[S]> woo
17:59:55 <DrChaos[S]> got it
17:59:57 <pnielsen> DrChaos[S]: : is cons, ++ is append, + is plus
18:00:08 <pnielsen> + is for numbers
18:00:23 <Nereid> the confusing message is because 1 is a polymorphic value. so conceivably it *could* be a list.
18:00:25 <Jafet> Sum 1 ++ Sum 2
18:00:25 <shapr> hrm, ghc-pkg check gives me a long list of problems, is there some command I can run to fix all the dependencies?
18:00:28 <Nereid> :t (++)
18:00:29 <Jafet> > Sum 1 ++ Sum 2
18:00:31 <lambdabot> Monoid m => m -> m -> m
18:00:33 <Nereid> oh yeah we fixed that.
18:00:33 <lambdabot>   mueval-core: Time limit exceeded
18:00:35 <Nereid> wait we didn't.
18:00:39 <Nereid> I thought we did?
18:00:44 <hpc> :t flip
18:00:45 <lambdabot> (a -> b -> c) -> b -> a -> c
18:00:47 <hpc> :t (.)
18:00:48 <lambdabot> Functor f => (a -> b) -> f a -> f b
18:00:52 <Nereid> oh yeah, flip is what we fixed.
18:00:54 <hpc> > 1 2 3
18:00:56 <lambdabot>   Could not deduce (GHC.Num.Num (a0 -> a1 -> t))
18:00:56 <lambdabot>    arising from the ambiguit...
18:01:04 <hpc> we fixed flip and number functions
18:01:14 <Jafet> shapr: there's rm
18:01:28 <hpc> i miss the awesome flip
18:01:40 <Nereid> I don't.
18:01:43 <shapr> Jafet: Is that the only fix? blow away ~/.ghc ?
18:02:08 <Jafet> Well, it's the most reliable one.
18:02:14 <Nereid> :t (<*)
18:02:15 <lambdabot> Applicative f => f a -> f b -> f a
18:02:16 <Nereid> er
18:02:19 <shapr> so, no automated way to fix dependencies then?
18:02:34 <Nereid> you could try reinstalling things until everything' sfixed.
18:02:44 <shapr> hrm
18:03:23 <Jafet> cabal install world --reinstall --remove-warranty-sticker
18:03:38 * shapr tries
18:03:59 <hpc> shapr: dependencies are hard; linux distros solve the problem by having one single version of everything
18:03:59 <Nereid> knowing that if you break something, there's always rm.
18:04:04 * hackagebot free-game 0.3.0.1 - Create graphical applications for free.  http://hackage.haskell.org/package/free-game-0.3.0.1 (FumiakiKinoshita)
18:04:15 <DrChaos[S]> what is the basic syntax for a list comprehension?
18:04:16 <hpc> and dedicating many many man-hours
18:04:30 <hpc> > [x | x <- "something like this"]
18:04:31 <DrChaos[S]> let's say I wanted all numbers divisible by two...how would I do that?
18:04:32 <lambdabot>   "something like this"
18:04:52 <Nereid> > [x | x <- [1..10], even x ]
18:04:54 <lambdabot>   [2,4,6,8,10]
18:05:31 <Jafet> All the numbers?
18:05:53 <Nereid> > [ (x,y) | x <- [1..5], y <- [1..5], even (x+y) ]
18:05:55 <lambdabot>   [(1,1),(1,3),(1,5),(2,2),(2,4),(3,1),(3,3),(3,5),(4,2),(4,4),(5,1),(5,3),(5...
18:06:01 <sw2wolf> :t const
18:06:03 <lambdabot> a -> b -> a
18:06:07 <hpc> > filter even [0..]
18:06:09 <lambdabot>   [0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,5...
18:06:10 <sw2wolf> :t const . return
18:06:11 <lambdabot> Monad m => a -> b -> m a
18:06:21 <beefcube> does someone know why: main =  whenM (not <$> (return False)) $ putStrLn "failure"  fails to compile, even though it seems to me that the type of (not <$> (return False)) is correct for this use?
18:06:24 <Nereid> I find I don't actually use list comprehension a lot.
18:06:47 <hpc> :t whenM
18:06:48 <lambdabot>     Not in scope: `whenM'
18:06:48 <lambdabot>     Perhaps you meant `when' (imported from Control.Monad.Writer)
18:06:52 <hpc> @hoogle whenM
18:06:52 <lambdabot> No results found
18:06:57 <beefcube> whenM is from Data.Bool.Extras
18:07:12 <hpc> is it the right type?
18:07:18 <Nereid> that should work if whenM is from Control.Conditional
18:07:29 <shapr> hpc: I'd still like some way to get all my libraries in a sane state.
18:07:32 <Nereid> but not if whenM is from Data.Bool.Extras
18:07:42 <Nereid> Data.Bool.Extras.whenM :: Monad m => (a -> m a) -> Bool -> a -> m a
18:07:55 <Nereid> Control.Conditional.whenM :: (ToBool bool, Monad m) => m bool -> m () -> m ()
18:08:05 <Jafet> ToBool
18:08:11 <Nereid> yes, overloaded booleans.
18:08:28 <Jafet> Jawohl
18:08:29 <DrChaos[S]> why can't I do [ x | x <- [1..10], x `mod` 2 == 0] ?
18:08:30 <hpc> i like exactly none of those type signatures
18:08:37 <Nereid> DrChaos[S]: you can.
18:08:49 <hpc> > [ x | x <- [1..10], x `mod` 2 == 0]
18:08:50 <lambdabot>   [2,4,6,8,10]
18:10:04 <beefcube> ah, nevermind :/
18:10:39 <DrChaos[S]> > let map' :: (a -> b) -> [a] -> [b]; map' f [] = []; map f (x:xs) = f x : (map' f xs) in map' [ x | x <- [1..10], x `mod` 2 == 0]
18:10:41 <lambdabot>   Couldn't match expected type `a0 -> b0' with actual type `[t0]'
18:10:53 <DrChaos[S]> whoops
18:11:03 <DrChaos[S]> > let map' :: (a -> b) -> [a] -> [b]; map' f [] = []; map f (x:xs) = f x : (map' f xs) in map' (/2) [ x | x <- [1..10], x `mod` 2 == 0]
18:11:04 <lambdabot>   Ambiguous type variable `b0' in the constraints:
18:11:04 <lambdabot>    (GHC.Real.Fractional b0...
18:11:08 <DrChaos[S]> there we go
18:11:11 <DrChaos[S]> there's my error
18:11:21 <hpc> :t mod
18:11:22 <lambdabot> Integral a => a -> a -> a
18:11:24 <Nereid> :t (/)
18:11:25 <lambdabot> Fractional a => a -> a -> a
18:11:31 <hpc> use div
18:11:32 <Nereid> use div instead of (/)
18:11:37 <DrChaos[S]> oh, type mismatch
18:11:42 <hpc> > map (`div` 2) [2,4..10]
18:11:44 <lambdabot>   [1,2,3,4,5]
18:11:54 <DrChaos[S]> div has type Integral a?
18:11:58 <Nereid> :t div
18:11:59 <lambdabot> Integral a => a -> a -> a
18:12:10 <Nereid> btw, Integral a isn't a type, it's a constraint on a
18:12:41 <Nereid> also, you already know how to define map, you can just use map now instead of defining it every time.
18:12:56 <Nereid> also, you mistyped map instead of map' once.
18:13:24 <DrChaos[S]> why would "map' (div 2) [ x | x <- [1..200], x `mod` 4 == 0]" return a list with only zeros in it/
18:13:38 <Nereid> because you're dividing 2 by the things in your list
18:13:52 <hpc> > (div 2) 5
18:13:53 <lambdabot>   0
18:13:58 <hpc> > (`div` 2) 5
18:13:59 <lambdabot>   2
18:14:02 <Rarrikins> 2/x, essentially.
18:14:02 <DrChaos[S]> ah
18:14:07 <hpc> > 5 `div` 2 -- it's a section
18:14:09 <lambdabot>   2
18:14:13 <Nereid> > flip div 5 2
18:14:15 <lambdabot>   0
18:14:17 <Rarrikins> flip div 2, too.
18:14:17 <Nereid> er
18:14:19 <Nereid> > flip div 2 5
18:14:20 <lambdabot>   2
18:14:20 <Rarrikins> Yes!
18:14:25 <DrChaos[S]> SWEET
18:14:27 <hpc> backticks make it "infix" like (+) or similar operators
18:14:28 <Nereid> I'm not sure which I prefer.
18:14:32 <DrChaos[S]> I'd love to flip it
18:14:34 <Nereid> flip or infix.
18:14:42 <Rarrikins> `infix` is the work of SATAN!
18:14:47 <hpc> everyone knows what (`` x) does
18:14:55 <Rarrikins> O-o
18:14:57 <hpc> and it's shorter
18:15:01 <Rarrikins> @type (``)
18:15:01 <Nereid> sure.
18:15:02 <lambdabot> parse error on input ``'
18:15:06 <Nereid> I'd probably lean toward it myself.
18:15:11 <Nereid> :t (`div`)
18:15:12 <lambdabot> parse error on input `)'
18:15:20 <Nereid> that's not consistent.
18:15:21 <Rarrikins> Oh
18:15:22 <Nereid> :t (`div` 5)
18:15:23 <lambdabot> Integral a => a -> a
18:15:24 <DrChaos[S]> :t `div`
18:15:25 <lambdabot> parse error on input ``'
18:15:27 <DrChaos[S]> LOL
18:15:29 <hpc> as far as syntactic evils go, this is the lightest of all
18:15:35 <DrChaos[S]> :t flip div
18:15:36 <lambdabot> Integral c => c -> c -> c
18:15:40 <DrChaos[S]> ooh
18:15:51 * DrChaos[S] wants to marry the flip function
18:16:37 <Nereid> :t flip flip flip
18:16:38 <lambdabot> (a -> ((a1 -> b -> c1) -> b -> a1 -> c1) -> c) -> a -> c
18:16:41 <Rarrikins> :t flip map
18:16:42 <lambdabot> [a] -> (a -> b) -> [b]
18:16:55 <Nereid> :t <&>
18:16:56 <lambdabot> parse error on input `<&>'
18:16:56 <Nereid> :t (<&>)
18:16:57 <lambdabot> Functor f => f a -> (a -> b) -> f b
18:17:14 <DrChaos[S]> where is flipping the map function useful?
18:17:15 <Nereid> > [1..5] <&> (*2)
18:17:18 <lambdabot>   [2,4,6,8,10]
18:17:33 <hpc> DrChaos[S]: for = flip map
18:17:36 <hpc> :t flip map
18:17:37 <lambdabot> [a] -> (a -> b) -> [b]
18:17:41 <Nereid> :t forM_
18:17:42 <lambdabot> Monad m => [a] -> (a -> m b) -> m ()
18:17:43 <Nereid> :t mapM_
18:17:44 <lambdabot> Monad m => (a -> m b) -> [a] -> m ()
18:17:49 <hpc> @let for = flip map
18:17:52 <lambdabot>  Defined.
18:18:04 <hpc> > for [1..5] $ \x -> x ** 2 + (5 `mod` x)
18:18:05 <lambdabot>   Ambiguous type variable `b0' in the constraints:
18:18:05 <lambdabot>    (GHC.Float.Floating b0)...
18:18:14 <hpc> > for [1..5] $ \x -> x ** 2 + (5 / x)
18:18:18 <lambdabot>   mueval-core: Time limit exceeded
18:18:21 <Rarrikins> > for [1..5] (+1)
18:18:23 <hpc> you suck lambdabot
18:18:23 <lambdabot>   [2,3,4,5,6]
18:18:24 <Nereid> > for [1..5] $ \x -> x ^ 2 + (5 `mod` x)
18:18:26 <lambdabot>   [1,5,11,17,25]
18:18:44 <Nereid> > for [1..5] $ \x -> x ** 2 + (5 / x)
18:18:46 <lambdabot>   [6.0,6.5,10.666666666666666,17.25,26.0]
18:18:49 <Rarrikins> map (for [1..5]) [(+1), (+2), (^2)]
18:19:16 <Rarrikins> > map (for [1..5]) [(+1), (+2), (^2)]
18:19:18 <lambdabot>   [[2,3,4,5,6],[3,4,5,6,7],[1,4,9,16,25]]
18:19:20 <Nereid> > [(+1), (+2), (^2)] <*> [1..5]
18:19:21 <lambdabot>   [2,3,4,5,6,3,4,5,6,7,1,4,9,16,25]
18:19:24 <Nereid> oops
18:19:25 <hpc> > [(+1), (+2), (^2)] <*> [1..5] -- Rarrikins
18:19:26 <lambdabot>   [2,3,4,5,6,3,4,5,6,7,1,4,9,16,25]
18:19:29 <hpc> Nereid: lol
18:19:53 <Rarrikins> There's some M2 function as well
18:20:01 <DrChaos[S]> Mwahahahahahah, I have implemented reverse'
18:20:04 <Rarrikins> @hoogle M2
18:20:04 <lambdabot> Control.Monad liftM2 :: Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
18:20:10 <Nereid> DrChaos[S]: show me.
18:20:21 <Nereid> :t liftA2
18:20:22 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
18:20:26 <Nereid> liftA2 is more general.
18:20:36 <Rarrikins> > liftM2 id [(+1), (+2), (^2)] [1..5]
18:20:38 <lambdabot>   [2,3,4,5,6,3,4,5,6,7,1,4,9,16,25]
18:20:53 <Rarrikins> Oh
18:20:56 <Rarrikins> > liftA2 id [(+1), (+2), (^2)] [1..5]
18:20:58 <lambdabot>   [2,3,4,5,6,3,4,5,6,7,1,4,9,16,25]
18:21:00 <Nereid> id = ($)
18:21:02 <DrChaos[S]> > let reverse' [] = []; reverse' (x:xs) = reverse' xs ++ [x] in reverse' [1..10]
18:21:04 <lambdabot>   [10,9,8,7,6,5,4,3,2,1]
18:21:05 <Rarrikins> Take that, puny monads!
18:21:11 <Nereid> DrChaos[S]: ah, the O(n^2) reverse.
18:21:34 <Nereid> > let reverse' [] = []; reverse' (x:xs) = reverse' xs ++ [x] in reverse' [1..1000000]
18:21:37 <lambdabot>   *Exception: stack overflow
18:21:39 <Nereid> > reverse [1..1000000]
18:21:41 <lambdabot>   [1000000,999999,999998,999997,999996,999995,999994,999993,999992,999991,999...
18:21:47 <DrChaos[S]> Nereid, how to make it faster? o/O\o
18:22:08 <Nereid> DrChaos[S]: it can be done in linear time. how would you reverse a linked list in an imperative language?
18:22:22 <Rarrikins> DrChaos[S]: let reverse' [] = []; reverse' xs = f [] xs where f rs xs = ...
18:22:32 <DrChaos[S]> Nereid, I've never written anything involving lists in an imperative language
18:23:03 <Nereid> DrChaos[S]: to reverse xs, start with a new empty linked list, and repeatedly take the head off of xs and put it onto the new one.
18:23:31 <Nereid> perhaps think of them as stacks.
18:23:33 <Rarrikins> It's like stack reversing!
18:23:38 <Nereid> it's exactly stack reversing!
18:23:45 <hpc> good god
18:23:53 <has> my first time here...I have a question. Where do I start from?
18:24:00 * DrChaos[S] will become uber advanced and do that
18:24:02 <hpc> Nereid: the last 5 lines you have said are almost character-exact what i wanted to type
18:24:06 <Nereid> haha
18:24:12 <mikeplus64> @where lyah
18:24:12 <lambdabot> http://www.learnyouahaskell.com/
18:24:12 <Rarrikins> has: Install Haskell platform.
18:24:14 <mikeplus64> has:
18:24:18 <hpc> and a split-second before i finish typing
18:24:27 <Rarrikins> has: While it's going, that other link :D
18:24:51 <shapr> Since I'm porting this code from Python, I'll just stick with sqlite-simple for the moment.
18:26:25 <Nereid> DrChaos[S]: so we use a helper function.
18:26:29 <has> i have everything installed, thanks. My question is about a function I am trying to write.
18:26:48 <Nereid> I'm going to write a function hepler :: [a] -> [a] -> [a]. it'll do this:
18:26:51 <Nereid> helper*
18:27:06 <mikeplus64> has: ask away, it's the only way you'll to get answers. if you need a pastebin, http://hpaste.org
18:27:09 <Nereid> helper xs ys will repeatedly take the head off of xs, and put it onto ys. when xs is empty, we'll return ys.
18:27:17 <Nereid> then, reverse xs = helper xs []
18:27:25 <Nereid> DrChaos[S]: can you see how to define helper?
18:27:46 <Nereid> two cases: helper [] ys = ...; helper (x:xs) ys = ...
18:28:05 <DrChaos[S]> oh wow
18:29:14 <Nereid> and this is linear time.
18:29:23 <Nereid> the reason your xs ++ [x] thing is quadratic is because
18:29:26 <has> I am writing a function that calculates the roots of a 2nd degree equation. The problem is, depending on the input values, it may result in a sqrt of a negative number. I am using pipes and where. Is there a way that I could write the code here? It is very small. Thanks
18:29:30 <neutrino_> hi
18:29:33 <neutrino_> happy new year
18:29:33 <Nereid> appending two lists takes time proportional to the length of the first list.
18:29:53 <DrChaos[S]> oh
18:29:55 <Nereid> has: if it's more than a line or two, http://hpaste.org/
18:30:18 <neutrino_> has anyone here used the atom edsl? i was wondering if it had any notion of parallelism
18:30:32 <has> ok i will try
18:30:35 <hpc> DrChaos[S]: it's roughly like trying to implement a queue by using a stack as the underlying data structure
18:30:59 <DrChaos[S]> ok, that's cool but not high performance
18:32:07 <sw2wolf> How to upgrade software installed by `cabal install` ?
18:32:08 <hpaste> has pasted “roots” at http://hpaste.org/80033
18:32:22 <DrChaos[S]> ok, I'd just find the length of the list, start at the end of the list, and while decrementing a counter copy the current item x into the the current index of the new list
18:32:22 <Nereid> sw2wolf: 1. cabal is not a package manager. 2. just cabal install the new version.
18:32:28 <DrChaos[S]> it sounds horrible I know
18:32:31 <Nereid> no indices!
18:32:44 <Nereid> the answer is very simple once you know it.
18:32:47 <sw2wolf> merijn: donot need to remove the old one
18:32:55 <DrChaos[S]> in fact, in a functional programming language it is horrible
18:33:06 <DrChaos[S]> AH
18:33:16 <has> I have copied the code to hpaste
18:33:18 <DrChaos[S]> if you find (x:[]) you know you are at the last item
18:33:25 <DrChaos[S]> with ZERO indices!
18:33:52 <Nereid> has: the issue is that the type of ["no real roots"] doesn't agree with the rest.
18:34:01 <DrChaos[S]> the question is how to start at the end of a list and work backwards
18:34:06 <Nereid> you don't.
18:34:13 <Nereid> you can do everything just by fiddling with heads.
18:34:24 <has> how can i fix that?
18:34:40 <Nereid> has: the quick way would be to return something like
18:34:44 <Nereid> > error "no real roots"
18:34:46 <lambdabot>   *Exception: no real roots
18:34:46 <DrChaos[S]> huh...holy guacamole I want to one day understand how to do that fully
18:35:08 <Nereid> DrChaos[S]: look again at how I described stack reversing earlier.
18:35:20 <Nereid> how would you reverse a stack of cards?
18:35:51 <Nereid> you take a card off the top of the first stack and put it on the second stack, and repeat until there are none left on the first stack.
18:36:06 <shapr> Oh look, this installs just fine: https://github.com/echaozh/HaskellNet.git
18:36:09 <Nereid> the two stacks are the arguments to helper, and "repeat" is recursion.
18:36:22 <DrChaos[S]> wait, it would help if I had a stack of cards to play with
18:36:29 <Nereid> sure.
18:36:48 <DrChaos[S]> let me try to visualize it
18:36:49 <Nereid> how frequent are card analogies, anyway?
18:36:50 <lispy> shapr: hiya
18:37:13 <DrChaos[S]> so I have a card stack 9 8 7
18:37:34 <Nereid> which one is on top?
18:37:38 <DrChaos[S]> 9 is
18:37:41 <Nereid> ok
18:37:49 <shapr> howdy lispy, how's life?
18:37:52 <rwbarton> a monad transformer stack is like a deck of cards
18:37:52 <Nereid> in haskell: 9:8:7:[]
18:37:54 <has> it does not work...
18:38:06 <Nereid> and we have a second, empty stack: []
18:38:36 <has> it is asking for a floating char
18:38:54 <Nereid> has: no, don't return a string.
18:38:56 <DrChaos[S]> if I append 9 to the empty stack the bigger stack becomes 8:7:[]
18:39:04 <DrChaos[S]> I wonder if I instead did this:
18:39:10 <DrChaos[S]> add to BEGINNING of new stack
18:39:26 <shapr> It's fun to port my Python code to Haskell.
18:39:26 <Nereid> what does the second stack look like after you do that?
18:39:30 <lispy> shapr: pretty good.
18:39:46 <DrChaos[S]> [9]
18:39:57 <lispy> shapr: just discovered mintty on windows and that is a nicer alternative to what I was using
18:40:05 <Nereid> sure, or 9:[]
18:40:10 <lispy> shapr: you?
18:40:10 <Nereid> in other words:
18:40:20 <Nereid> well
18:40:23 <Nereid> ok.
18:40:29 <Nereid> now that you have those two stacks, what do you do next?
18:40:45 <DrChaos[S]> 9:8:[] = 8:9:[]
18:40:46 <shapr> lispy: I'm working on my overarching project of building a wifi-only replacement for a smart phone.
18:40:58 <DrChaos[S]> just appending to the head of the new stack is enough
18:41:05 <lispy> shapr: ah. Sounds interesting.
18:41:14 <shapr> lispy: I suspect it would be cheaper and more-fun to use a Raspberry Pi with a 3G->wifi pocket widget.
18:41:18 <lispy> shapr: voip but for mobile?
18:41:44 <shapr> Even when I had a phone, I mostly used the data services like twitter and google voice sms messages.
18:41:55 <lispy> (I need to run to pickup dinner, bbiab)
18:41:59 <lispy> yeah
18:41:59 * shapr waves
18:42:01 <lispy> same here
18:42:07 <lispy> I very rarely use voice now
18:42:11 <Nereid> DrChaos[S]: ok I'm not sure what you just did.
18:42:20 * lispy disappears
18:42:34 <shapr> lispy: When you get back, I'd be interested in hearing what services you DO use with your wireless data.
18:42:36 <DrChaos[S]> I advanced to the next item, an 8 and appended it to the beginning of the new stack
18:43:45 <Nereid> DrChaos[S]: we have two stacks here.
18:44:00 <Nereid> we start with 9:8:7:[] and []
18:44:00 <DrChaos[S]> here, let me visualize it for you: *9* : <8> : [] = [<8>,*9*]
18:44:09 <Nereid> after one step, what are the two stacks?
18:44:38 <DrChaos[S]> after one step we have [9,8,7], [9]
18:44:41 <Nereid> nope
18:44:49 <Nereid> we removed 9 from the first one, remember?
18:44:54 <DrChaos[S]> oh
18:45:12 <DrChaos[S]> it's interesting how you discard the head of the first stack
18:45:20 <Nereid> we didn't discard it, we pushed it onto the second one.
18:45:27 <DrChaos[S]> [8,7] = [9]
18:46:03 <DrChaos[S]> after second step [7] = [8,9]
18:46:23 <DrChaos[S]> after third [] = [7,8,9]
18:46:33 <Nereid> I don't know why you write = there
18:46:42 <DrChaos[S]> I guess I just like the equal sign
18:46:48 <has> can i write something like:   | delta < 0 = Error ?
18:46:53 <Nereid> never use = between two things that aren't equal.
18:46:54 <DrChaos[S]> treat it as you would a comma
18:46:57 <DrChaos[S]> ok
18:47:10 <Nereid> has: use the error function.
18:47:19 <Nereid> ... | delta < 0 = error "no real roots"
18:47:21 <Nereid> :t error
18:47:22 <lambdabot> [Char] -> a
18:47:32 <has> I tried that
18:47:35 <has> I does not work
18:47:58 <Nereid> I think you forgot to write error.
18:48:08 <DrChaos[S]> Nereid, I think I will work on getting quantum computers to mainstream later in life...the first viable electronic quantum processor with at least 2,000 qubits (2000 processing cores)
18:48:10 <hpc> or your problem is somewhere else
18:48:10 <Nereid> based on the message you told me.
18:48:16 <has> let me try again
18:48:18 <Nereid> DrChaos[S]: good luck ;)
18:48:33 <Nereid> (does my computer have 64 billion processing cores?)
18:48:44 <DrChaos[S]> sorry, no
18:48:55 <Nereid> it's ok, I know what a qubit is.
18:49:20 <DrChaos[S]> is that the estimated number of atoms in the observable universe?
18:49:27 <has> Perfect...it is working
18:49:28 <Nereid> it's the number of bits in my computer's RAM.
18:49:36 <has> Thank you very much Nereid
18:49:44 <has> and happy New Year
18:49:47 <Nereid> :)
18:50:00 <DrChaos[S]> ok...how many gigs of RAM do you have? I have 4GB of RAM
18:50:03 <Nereid> 8
18:51:09 <DrChaos[S]> I wonder if there's a way to make a mu-Haskell
18:51:37 <JoeyA> I refuse to use TupleSections because I hope that some day, there will be an extension to support Python-style singleton tuples.
18:51:47 <DrChaos[S]> one implementation that is TINY in size and can be used to program systems firmware
18:51:48 <Nereid> why?
18:51:58 <Nereid> to JoeyA
18:52:08 <hpc> JoeyA: eh?
18:52:14 <DrChaos[S]> I would love to implement my bootloader in haskell
18:52:15 <JoeyA> In Python, (3,) is a tuple of one item.
18:52:23 <Nereid> JoeyA: in Haskell, 3 is a tuple of one item.
18:52:26 <JoeyA> Haskell has tuples of sizes 0, 2, 3, 4, ... 62 or so
18:52:35 <merijn> DrChaos[S]: Have you looked at HaLVM and House?
18:52:36 <hpc> 0 and 1 aren't tuples
18:52:39 <JoeyA> But 3 is not a tuple, it's a Num a => a
18:52:49 <Nereid> it's a 1-tuple of values of type Num a => a
18:52:54 <hpc> () is the unit type and the nearest thing to 1 is Identity
18:53:07 <JoeyA> Not if you want to write an instance for the one-tuple
18:53:08 <shapr> Hrm, imapget still doesn't work even with the very most recent HaskellNet .
18:53:17 <JoeyA> Since by the same argument, (a, b, c) is a one-tuple, too
18:53:20 <DrChaos[S]> merijn, I have looked at House, just haven't played with it yet. I haven't looked at HaLVM
18:53:38 <JoeyA> That's why postgresql-simple has an Only type.
18:53:44 <Nereid> I'd rather have TupleSections.
18:53:51 <Nereid> you can always use Identity.
18:54:35 * DrChaos[S] will be playing with House in a few minutes
18:54:39 <Nereid> I also wish we had a dual to TupleSections to extract components of a tuple.
18:54:56 <JoeyA> query c "select x from scores where x > ?" (Identity (42::Int))
18:55:00 <JoeyA> ^ I don't think so...
18:55:22 <Nereid> well sure, that library doesn't take it.
18:55:28 <Nereid> but that's up to the library.
18:55:36 <JoeyA> My eyes don't take it, either.
18:56:17 <JoeyA> Though (3,) syntax is pretty ugly, I'll admit (for a singleton tuple)
18:57:56 <shapr> DrChaos[S]: ooh fun!
18:58:03 <shapr> DrChaos[S]: Are you using LightHouse?
18:58:32 <shapr> speaking of which, I need to archive LightHouse with the explicit OSS license I got from the Gadgets authors.
18:59:05 <Nereid> what is LightHouse?
19:00:01 <shapr> Yay! now imapget is ALSO working!
19:00:09 <shapr> I should really NMU these hackages.
19:00:33 <shapr> Nereid: http://wiki.cs.pdx.edu/gitweb?p=lighthouse.git;a=summary
19:00:49 <shapr> Kenneth Graunke extended House to LightHouse for his thesis (master's?)
19:00:56 <Nereid> I see.
19:01:29 <shapr> His thesis is titled: "Extensible Scheduling in a Haskell-based Operating System"
19:02:02 <shapr> I also meant to poke the L4 microkernel group and see if I could track down licenses for all the contributors.
19:02:27 <shapr> Yay imap-ssl in Haskell!
19:02:30 * shapr dances cheerfully
19:15:04 <Nereid> guh
19:15:13 <Nereid> I forgot to suggest alternatives to error to has
19:15:18 <Nereid> like returning []
19:15:39 <sw2wolf> :t return []
19:15:40 <lambdabot> Monad m => m [a]
19:17:07 <JoeyA> "shapr> Yay imap-ssl in Haskell!" What do you mean?
19:17:10 <Nereid> no, I didn't mean `return`
19:18:02 <JoeyA> I can't cheer with you if I don't know what you're celebrating.
19:19:18 <monochrom> shapr was looking for imap or imaps lib for haskell. then he found some.
19:24:05 <DrChaos[S]> How do I build LightHouse?
19:24:32 <hpc> find a cliff and stack bricks in a circular shape
19:24:40 <hpc> put light on top
19:25:36 <Nereid> :-)
19:25:39 <DrChaos[S]> no, this thing: http://wiki.cs.pdx.edu/gitweb?p=lighthouse.git;a=summary
19:25:47 <Jafet> Where do I shot web
19:25:59 <Nereid> to the internets
19:26:22 <DrChaos[S]> Jafet, is that an eggnog slime web?
19:26:24 <Jafet> To the interbats
19:26:40 <DrChaos[S]> I want some :(
19:27:13 <DrChaos[S]> it would be awesome if you could make slime out of eggnog
19:29:06 * hackagebot Yablog 0.2.0 - A simple blog engine powered by Yesod.  http://hackage.haskell.org/package/Yablog-0.2.0 (HiromiIshii)
19:29:20 <mercury^> Why is Control.Monad.ST.Class from monad-st not Safe?
19:29:51 <mercury^> Or rather, not Trustworthy.
19:30:04 <mercury^> edwardk: ?
19:30:11 <monochrom> it says "safe-inferred" which is trustworthy for me
19:30:16 <monochrom> and also safe for me
19:30:28 <mercury^> Hmm.
19:30:36 <monochrom> my understanding is that "safe-inferred" is good enough
19:30:53 <mercury^> It should be. Let's see if an update fixes it.
19:30:55 <edwardk> i only bother to mark things explicitly safe or trustworthy when safe-inferred isn't enough
19:31:25 <mercury^> Well, I just tried to compile a module that used it with -XSafe and ghc complained.
19:31:51 <mercury^>     Control.Monad.ST.Class: Can't be safely imported!
19:32:00 <monochrom> the way I understand the GHC user guide, there should be no need to manually mark every bloody lib as Safe
19:33:01 <edwardk> mercury^: its  probably because ti imports Control.Monad.ST not Control.Monad.ST.safe or some such under the hood
19:33:43 <mercury^> Control.Monad.ST.Safe would be enough though, I think?
19:34:24 <edwardk> it would
19:34:28 <edwardk> it didn't exist when i wrote it
19:35:23 <monochrom> interesting. I build it myself. --enable-documentation. the built doc says "Safe Haskell: None" rather than "safe-inferred"
19:35:23 <Jafet> Is it possible to build a shared library for vector?
19:35:53 <monochrom> so it is likely not marked as "safe-inferred" on your disk either
19:37:54 <mercury^> edwardk: thanks in advance for fixing it. =) (I need to close my laptop for a while now.)
19:39:56 <monochrom> I now want to know why hackage marks it safe-inferred while building it myself doesn't. both ghc 7.4
19:40:15 <JoeyA> So {-# LANGUAGE Unsafe #-} is like throw, and {-# LANGUAGE Trustworthy #-} is like catch.
19:41:31 <Nereid> it is a mystery.
19:42:06 * lispy is back
19:42:27 <elliott> monochrom: haddock had some bug
19:42:31 <lispy> shapr: please define service
19:42:31 <elliott> that decided everything was safe-inferred
19:42:38 <JoeyA> Control.Monad.ST has {-# LANGUAGE Unsafe #-}
19:42:39 <monochrom> oh! haha. thanks
19:43:02 <JoeyA> (currently, due to the unsafe funcs it has)
19:43:17 <lispy> shapr: In terms of apps, I frequently use maps, tweetdeck, redditisfun, the webbrowser, google apps (calendar and email mostly)
19:43:28 <JoeyA> {-# LANGUAGE TrustMeI'mADoctor #-}
19:43:53 <JoeyA> (I'm not actually a doctor)
19:44:39 <lispy> shapr: oh, and I use sms
19:54:06 * hackagebot monad-st 0.2.2 - Provides a MonadST class  http://hackage.haskell.org/package/monad-st-0.2.2 (EdwardKmett)
19:54:46 <monochrom> w00t
19:55:33 <parcs> heh "(MonadTrans t, MonadST m, Monad (t m)) => MonadST (t m)"
19:55:38 <parcs> lazy lazy
19:57:13 <monochrom> now the local build says safe-inferred \∩/
19:58:31 <randomclown> Somebody have a look at my code (5 lines), trying to figure why maximum makes it stackoverflow, it should run in constant memory
19:58:35 <hpaste> randomclown pasted “stackoverflow with maximum” at http://hpaste.org/80034
19:58:46 <govno> @help
19:58:47 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
19:59:57 <parcs> randomclown: try 'foldl1' max' instead of 'maximum'
20:00:06 <parcs> er, that is, foldl1' max
20:00:34 <parcs> foldl1' can be found in Data.List
20:00:38 <monochrom> you're missing a few imports that I have to add back
20:00:57 <randomclown> oh yeah I cut that section out
20:01:23 <randomclown> parcs: ah right the strict fold, I should have seen that coming
20:01:40 <monochrom> "main :: IO" is a compiler error
20:02:04 <monochrom> I suppose you never expect anyone to actually use the scientific method i.e. start by reproducing the problem, do you?
20:03:24 <randomclown> monochrom: I didn't think anything so trivial will stop you :)
20:03:51 <monochrom> I compiled with -O and it uses constant memory so far and has not overflowed after a minute
20:04:31 <monochrom> the point is that it show how sincere you are
20:05:24 <monochrom> you are showing that you don't want your correspondences to use the scientific method. that is, you want people to never test anything, for example never test their own suggestions
20:05:38 <randomclown> monochrom: I think you are reading to deep into this
20:05:54 <cmccann> perhaps he is
20:05:56 <cmccann> he's also right
20:06:32 <Jafet> monochrom doesn't want to admit that he misplaced his crystal ball
20:06:34 <Jafet> Let him be
20:06:52 <cmccann> but perhaps more immediately relevant, if you're asking someone to help you out of the kindness of their heart, making it more difficult for them is really not in your best interest
20:08:08 <monochrom> I am certainly unusually easily ticked off by any behaviour that discourages the scientific method. call it my fetish if you like
20:09:17 <M30W_> Hello
20:09:47 <M30W_> Could someone here please go through their IRC logs and find the last occurance of "withMPD $ MPD."
20:09:58 <Jafet> cabal: internal error: could not construct a valid install plan.
20:09:58 <Jafet> The following packages are involved in a dependency cycle text-0.11.2.3, test-framework-quickcheck2-0.3.0.1, test-framework-0.8, xml-1.3.12, test-framework-hunit-0.3.0
20:10:14 <M30W_> Sorry, back.
20:12:35 <Jafet> <M30W_> Could someone here please go through their IRC logs and find the last occurance of "withMPD $ MPD."
20:12:41 <monochrom> I can't find it in all of December
20:12:50 <M30W> Jafet: -1
20:12:51 <M30W> lol
20:12:52 <hpaste> randomclown annotated “stackoverflow with maximum” with “scientific method edition” at http://hpaste.org/80034#a80035
20:13:20 <Jafet> @hoogle withMPD
20:13:21 <lambdabot> No results found
20:13:21 <randomclown> monochrom: that stackoverflows without fault if you compile with ghc, but will not overflow if you used ghci
20:13:37 <monochrom> ghci sets up a deeper stack
20:14:09 <randomclown> also overflows on -O2
20:14:14 <randomclown> annoyingly
20:14:18 <M30W> Jafet: If you have logs, can you please get the 3rd last result for that query?
20:14:21 <M30W> :P
20:14:34 <DrChaos[S]> OK, I am trying to implement a reverse function that operates in linear time
20:14:49 <monochrom> M30W: the topic has a URL for logs, if nothing else helps
20:14:56 <M30W> oh sigh
20:14:58 <M30W> Thanks mate
20:15:00 <randomclown> > foldr1 (:) "asdfasdf"
20:15:01 <lambdabot>   Couldn't match type `[GHC.Types.Char]' with `GHC.Types.Char'Couldn't match ...
20:15:09 <M30W> Forgot about them
20:15:19 <monochrom> don't thank me yet. that page is pretty hard to use. I only consider it a last resort
20:15:27 <parcs> randomclown: does foldl1' (+)  work?
20:15:33 <parcs> er, max
20:15:34 <randomclown> parcs: yeah the strict fold works
20:15:45 <randomclown> without overflow
20:16:04 <parcs> right, good
20:16:11 <pdxleif> You need a [] in there somewhere
20:16:41 <rwbarton> @src maximum
20:16:41 <lambdabot> maximum [] = undefined
20:16:41 <lambdabot> maximum xs = foldl1 max xs
20:16:53 <M30W> MPD.setVolume . (5 +) . MPD.stVolume =<< MPD.status -- here we go.
20:17:03 <monochrom> no, -O and -O2 do not overflow here. 7.4.2, ubuntu 32-bit
20:17:05 <Jafet> http://tunes.org/~nef/logs/haskell/12.12.28
20:17:21 <monochrom> you may need -fforce-recomp to ensure recompilation
20:17:36 <hpaste> DrChaos pasted “Reimplementation of reverse” at http://hpaste.org/80036
20:18:04 <monochrom> then again I am not sure I advocate relying on -O for this
20:18:07 <DrChaos[S]> So this function, it is giving me troubles
20:18:29 <DrChaos[S]> probably because y could also be a list of list type
20:18:54 <M30W> XMonad goes back to controlling the volume of these computers through keybindings and MPD. :)
20:19:02 <parcs> DrChaos[S]: the second to last line is teh problem
20:19:08 <parcs> DrChaos[S]: you want [y]
20:19:10 <parcs> not y
20:19:38 <monochrom> or (y:[])
20:19:41 <parcs> also rev is not exhaustive
20:19:51 <monochrom> clearly, (y:[]) corresponds well with (y:xs)
20:20:25 <randomclown> monochrom: I deleted the executable and still needed -fforce-recomp, that did the trick
20:20:57 <monochrom> you have to delete the .hi file. deleting the exe forces re-linking only
20:21:27 <randomclown> monochrom: noted
20:22:48 <monochrom> in "rev [] [] = ..." and "rev [] (y:ys) = ...", why do you even care that the first parameter must be []?
20:23:16 <|||tux||> Hi, does anyone know how to build a parser n p that fails if p succeeds and succeeds if p fails in PolyParse using the applicative interface?
20:25:48 <parcs> |||tux||: you can't. you need to use the monadic interface
20:26:03 <|||tux||> parcs: ok, thx
20:26:11 <parcs> |||tux||: (i don't know anything of polyparse but this applies to applicativesin general)
20:26:30 <randomclown> so it is standard to stackoverflow without optimisations on? Do you people usually work on -O2?
20:26:30 <hpaste> DrChaos annotated “Reimplementation of reverse” with “Reimplementation of reverse (annotation)” at http://hpaste.org/80036#a80037
20:26:38 <elliott> you should pretty much always use -O
20:26:41 <elliott> if not -O2
20:26:48 <monochrom> cabal-install defaults to -O
20:26:48 <DrChaos[S]> ok, would you look again?
20:27:00 <monochrom> I am usually too lazy to add 2
20:27:35 <hpaste> DrChaos annotated “Reimplementation of reverse” with “Reimplementation of reverse (annotation)” at http://hpaste.org/80036#a80038
20:27:50 <monochrom> why do you even care that the first parameter looks like a:[] ?
20:28:09 <randomclown> because I feel that I may make some dumb mistake that would normally leak space/etc but it gets optimised by O1/O2 and I'll just keep doing stupid thhings
20:28:16 <hpaste> DrChaos pasted “Reimplementation of reverse 2” at http://hpaste.org/80039
20:28:57 <monochrom> OK either I just tell you the right code, or you explain your logic to me
20:29:00 <mikeplus64> randomclown: i always compile executables with -O2, there's no harm in doing so, other than lnolger compile times
20:29:02 <mikeplus64> longer*
20:30:19 <DrChaos[S]> ok um...would somebody please look at that new paste? I know how to annotate now
20:30:36 <monochrom> randomclown: I like that. so test both no -O and has -O
20:33:09 <hpaste> DrChaos annotated “Reimplementation of reverse 2” with “Error message [type error]” at http://hpaste.org/80039#a80040
20:33:35 <mikeplus64> DrChaos[S]: y is not a list in line 4
20:34:18 <monochrom> that was said before. so it felt on deaf ears
20:34:39 <mikeplus64> @src reverse
20:34:39 <lambdabot> reverse = foldl (flip (:)) []
20:34:56 <mikeplus64> DrChaos[S]: http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/GHC-List.html#reverse is the actual implementation
20:34:59 <DrChaos[S]> now it compiles, but I try revfast [1,2,3] and it gives [] as the result
20:35:20 <DrChaos[S]> mikeplus64, I want to do it without all these weird functions I don't understand
20:35:38 <Modius> Is there any real preference for having a type constructor be in tuple form vs other?  E.g. data Foo = Bar Int Int   vs    data Foo = Bar (Int, Int)   ?  Or pros and cons?
20:35:42 <mikeplus64> DrChaos[S]: look at the second definition, after #else
20:35:54 <mikeplus64> that's pretty much exactly what you're trying to implement
20:35:59 <mikeplus64> except working :)
20:36:15 <DrChaos[S]> a reimplementation is supposed to be different, and I'm not wanting to look at somebody else's code because I want to learn how to code
20:36:27 <DrChaos[S]> this is an exercise in programming for me
20:36:31 <mikeplus64> understanding other people's code is a huge part of learning how to code
20:36:51 <monochrom> I offered to listen to your logic, but you turned that down
20:37:10 <DrChaos[S]> if I look at their code, my brain would just copy their implementation when I am trying to write my own
20:37:44 <DrChaos[S]> it's why people don't want their code to be decompiled as they want to protect their techniques
20:37:47 <mikeplus64> Modius: i think in the second case type Foo = (Int, Int) is preferred, or just data Foo = Bar Int Int (or with records)
20:38:15 <monochrom> "data Foo = Bar (Int, Int)" may be silly, unless you actually want to have "Bar undefined" once in a while
20:38:46 <mikeplus64> Modius: when you have data Foo = Bar (Int, Int), i think you'll get the overhead of "Bar" and the tuple (so if you really want it, use newtype Foo = Bar (Int, Int)))
20:38:48 <mikeplus64> -)
20:38:51 <Modius> I meant for Bar to be one of the options in |
20:39:05 <Modius> Sounds like the non-tuple form is preferred. .  .?
20:39:38 <monochrom> ok, but what I said still holds when Bar is one of many options
20:39:55 <Modius> I don't get the undefined thing
20:40:06 <startling> how kosher is it to make a lens that makes assumptions about its arguments? that is, a lens that is only a legal lens for a subset of its domain
20:41:03 <monochrom> ok, in short Bar Int Int is preferred, options or not
20:42:17 <monochrom> but one day you will understand undefined, and then you will see this is not a question of preference, this is a question of saying what you mean
20:42:28 <Modius> Can you explain a bit of undefined?
20:42:30 <Modius> I don't get it
20:42:44 <monochrom> I don't have time
20:43:24 <startling> Modius: it's semantically similar to f = f
20:44:00 <startling> Modius: that never terminates, so it doesn't really have a valid type, so it can be any type.
20:44:45 <elliott> sure it has a valid type...
20:44:51 <startling> elliott: well
20:45:17 <hpaste> DrChaos annotated “Reimplementation of reverse 2” with “Working revfast” at http://hpaste.org/80039#a80041
20:45:23 <Modius> I don't get the link between specifying it can be a tuple and the ability to accept an undefined.
20:45:43 <DrChaos[S]> does my revfast function run in linear time?
20:46:29 <applicative> Modius: the tuple pairs are an extra constructor, suppose we just used Pair a b = Pair a b.
20:47:00 <startling> DrChaos[S]: looks like it
20:47:01 <applicative> then data Foo = Bar (Int, Int) is data Foo = Bar (Pair Int Int)
20:47:06 <monochrom> the possible values of type (Int,Int): undefined, (undefined, undefined), (undefined, 1), (2, undefined), (2,1), ...
20:47:56 <monochrom> operationally, you have more computation overhead if there are more possible values containing undefined
20:48:05 <applicative> so now there are more undefined values than you might have expected Bar undefined , Bar (Pair undefined undefined)
20:48:47 <applicative> Modius: whereas if you just did Foo = Bar Int Int, there would just be Bar undefined undefined
20:49:16 <Modius> Thanks, it'll take time for that sort of thing to fully sink in; but you made the crux of it quite clear.
20:49:43 <DrChaos[S]> > let revfast [] = []; revfast (x:xs) = rev [] (x:xs) where rev _ [] = []; rev (a:[]) (y:ys) = rev y ys; rev xs (y:ys) = rev (y:xs) ys in revfast [1..1000]
20:49:44 <lambdabot>   Occurs check: cannot construct the infinite type: t0 = [t0]
20:49:46 <applicative> Modius: but this arrives indirectly, or maybe too directly at the main point, that you add 1) more size to the representation of course, and 2) another level of laziness
20:50:24 <M30W> Could one do maths accross multiple cores?
20:50:34 <monochrom> yes
20:50:45 <startling> M30W: "maths" is too vague for that to be a useful question
20:50:47 <M30W> monochrom: How? This doesn't work.. time ghc -e '2^2^120' +RTS -N3 > /dev/null
20:51:03 <applicative> Modius or rather, you deprive yourself of a possible imposition of strictness data Foo = Bar !Int !Int which is likely to be desirable in such a case
20:51:03 <M30W> Err, I mean; like a single operation like that that would take ages
20:51:12 <monochrom> not automatically like that. use either forkIO or par
20:52:04 <DrChaos[S]> erm...why is lambdabot giving me an error and the same code in ghci not?
20:52:11 <newsham> ?date
20:52:11 <lambdabot> Maybe you meant: dice paste vote
20:52:12 <monochrom> OTOH 2^2^120 isn't going to fly on 16 cores or less
20:52:14 <newsham> ?time
20:52:17 <lambdabot> Local time for newsham is Mon Dec 31 18:49:11 2012
20:52:23 <applicative> Modius: indeed, though the compiler is likely to do this anyway, with a wrapped tuple you block the way to the ugly but likely desirable data Foo = Bar {-#UNPACK#-} !Int {-#UNPACK#-} !Int
20:52:48 <newsham> ?time lambdabot
20:52:48 <lambdabot> I live on the internet, do you expect me to have a local time?
20:53:24 <DrChaos[S]> WOW. My function does run in linear time it seems!
20:54:04 <DrChaos[S]> how do I tell ghci to run a function and not show the result?
20:54:15 <DrChaos[S]> that's what is slowing down my revfast function
20:54:22 <applicative> Modius: it's maybe too complicated at the moment, but take a look at http://www.slideshare.net/tibbe/highperformance-haskell around p 35
20:54:26 <Modius> applicative:  Are you much of a fan of statically asserting the "at least one element in the list" invariant by using Foo a [a] or Foo (a, [a]) in place of Foo [a] with an 'error' in the pattern match?
20:55:21 <M30W> monochrom: How exactly?
20:55:43 <applicative> Modius: hm don't know.
20:57:43 * DrChaos[S] hi
20:57:56 <M30W> DrChaos[S]: _ <- function
20:58:10 <applicative> Modius: like this scheme http://hackage.haskell.org/packages/archive/NonEmptyList/0.0.9/doc/html/src/Data-List-NonEmpty.html#NonEmpty
20:58:36 <M30W> More or less /dev/null the output of the function. ^_^ -- in shell terms.
20:58:37 <shachaf> M30W: "_ <- function" in ghci is an error.
20:58:46 <M30W> shachaf: Ah
20:59:23 <M30W> shachaf: Hm, _ <- putStrLn "test" it gives me test lol?
20:59:32 * applicative just did _ <- getChar 
20:59:34 <shachaf> putStrLn "test" is not a function.
20:59:46 <shachaf> And anyway this isn't relevant to what DrChaos[S] is asking.
21:00:02 <applicative> ah
21:00:09 <shachaf> DrChaos[S]: You can measure the length of the list or something.
21:00:27 <shachaf> DrChaos[S]: But I'd focus on getting your code to be correct first.
21:00:39 <M30W> Hmm
21:01:28 <DrChaos[S]> shachaf, my code loads in ghci without issue, including the whole revfast definition
21:02:21 <shachaf> I don't believe that that particular code you pasted type-checks in any version of GHC.
21:02:37 <shachaf> And also "loads" is not the same as "works".
21:02:55 <shachaf> (Despite what the propagandists would have you believe!)
21:05:19 <hpaste> DrChaos annotated “Reimplementation of reverse 2” with “Working revfast (typechecks)” at http://hpaste.org/80039#a80042
21:05:21 <argiopeweb> shachaf: Lies, damn lies, and statistics.
21:05:45 <DrChaos[S]> shachaf, that typechecks on GHC 7.4.1
21:06:13 <DrChaos[S]> the question is, can you get it to fail on certain patterns of input?
21:06:23 <shachaf> Yes, that last thing you pasted should work.
21:06:38 <applicative> DrChaos[S]: that's the correct one looks like
21:06:39 <DrChaos[S]> does it run in linear time?
21:06:56 <Modius> applicative:  Has the world settled on a specific NonEmpty?  A page I found lists like 4 of them
21:07:04 <DrChaos[S]> @hoogle reverse
21:07:04 <lambdabot> Prelude reverse :: [a] -> [a]
21:07:04 <lambdabot> Data.List reverse :: [a] -> [a]
21:07:04 <lambdabot> Data.ByteString reverse :: ByteString -> ByteString
21:07:05 <shachaf> It's a bit redundant (though, amusingly, there are particular contexts where it makes sense to unroll one step of the recursion as you did).
21:07:18 <shachaf> It runs in constant time, like everything in Haskell. :-)
21:07:57 <DrChaos[S]> how fast does it run on 100000?
21:08:08 <shachaf> 84 fasts.
21:08:11 <applicative> Modius: I don't think so, but I'm not sure the demand is high enough to resolve matters.
21:08:19 <DrChaos[S]> lots of speed xD
21:08:30 <JoeyA> > head $ dropWhile (\x -> or [a == b | (a:b:_) <- permutations (show x)]) [1988..]
21:08:31 <lambdabot>   2013
21:08:33 <shachaf> The question is why you're overloading 100000 to be a list.
21:09:15 <JoeyA> ^ The above script tells you the current year.  I thoroughly tested it.  It should work in practice.
21:09:19 <mauke> because [] is an instance of Applicative
21:09:26 <DrChaos[S]> shachaf, lies! I wrote my reverse' function that runs in O(n^2) time
21:09:41 <JoeyA> You might have some timezone-related issues if you test it now, though.
21:09:57 <mauke> JoeyA: I expect a fix in the near future
21:10:24 * applicative anticipates deprecation some time not long thereafter
21:10:31 <Modius> http://hackage.haskell.org/packages/archive/semigroups/0.5.0/doc/html/Data-List-NonEmpty.html#t:NonEmpty   <-- does anything about this page tell me how to get Data.List.NonEmpty into my project?  Do I need a specific extension, or just import the .hs file directly?  (less desireable)
21:10:40 <JoeyA> {-# DEPRECATED Use 2014 instead #-}
21:11:10 <applicative> Modius, cabal install semigroups  ; then import Data.List.NonEmpty at the top of the file or in ghci
21:11:11 <DrChaos[S]> I just renamed the O(n^2) reverse' function to revslow and changed the revfast function's name to reverse
21:11:18 <DrChaos[S]> I mean, reverse'
21:12:44 <applicative> Modius: I see if the semigroups has NonEmpty it's likely to be the going package for them
21:13:10 <applicative> Modius, or rather If the semigroups package has them use it
21:13:48 <monochrom> haha JoeyA++
21:14:53 <applicative> Modius then you can whine to Edward on here when it turns out to be slow or something.
21:16:50 <Modius> Currently I'm going for expressive quality more than speed (at least this experiment)
21:18:16 <applicative> Modius: not that since it reuses half the Prelude's names you'll probably need to import it qualified.
21:21:46 <argiopeweb> JoeyA: I think this needs to be in the module with "randomInt = 4 -- Guaranteed random by fair dice roll"
21:21:54 <applicative> Modius: import qualified Data.List.NonEmpty as N and then use N.head and N.tail and so on.  or  import qualified Data.List.NonEmpty as N;  import qualified Data.List.NonEmpty ((<|),nonEmpty)
21:22:12 <JoeyA> argiopeweb: I'm working on an Acme module
21:22:18 <JoeyA> Still working on a testsuite
21:22:54 <argiopeweb> JoeyA: The test suite for an Acme module would be the stuff of nightmares.
21:23:11 <argiopeweb> Or trivially simple, depending on how you approach it.
21:23:25 <sw2wolf> :t uncurry
21:23:26 <lambdabot> (a -> b -> c) -> (a, b) -> c
21:24:51 <sw2wolf> :t sequence
21:24:52 <lambdabot> Monad m => [m a] -> m [a]
21:27:17 <Modius> I'm importing NonEmpty - import .... (NonEmpty) works for NonEmpty; but if I add :| to the list I can't import that.  How can I bring in a symbol like :| from a library?
21:27:39 <Modius> nvm - error tells me how to do it
21:27:40 <Modius> Sorry
21:28:02 <monochrom> import Whee(x, y, (:|), Z, (+++))
21:28:17 <Modius> (:|) didn't work, because it was a constructor
21:28:26 <monochrom> oh!
21:28:43 <Modius> That said, I've been very impressed with the GHC and HLint errors/fixup tools, looks like people have put as much work into this as the core language itsself.
21:28:52 <monochrom> probably Typename((:|)) or Typename(..)
21:29:43 <applicative> import NonEmpty (NonEmpty(..))
21:29:56 <applicative> import Data.List.NonEmpty (NonEmpty(..))
21:38:21 <applicative> omg the new year is only a few minutes old and already a new monad tutorial...
21:38:51 <applicative> maybe we should have announced a collective New Years' Resolution
21:39:29 <elliott> ooh is this one good
21:40:20 <monochrom> what? where is the new monad tutorial?
21:40:32 <applicative> http://tailcalled.wordpress.com/
21:40:40 <JoeyA> http://hackage.haskell.org/package/acme-year
21:41:14 <elliott> this looks a bit "2012"
21:41:41 <applicative> JoeyA: the test suite is awesome where's benchmarking?
21:42:07 <JoeyA> How do you make benchmarks in Cabal?
21:42:23 <monochrom> oh God acme-year :)
21:42:36 <JoeyA> acme-year is /very/ fast, by the way
21:44:10 * hackagebot acme-year 2013 - Get the current year  http://hackage.haskell.org/package/acme-year-2013 (JoeyAdams)
21:44:27 <elliott> you need some {-# INLINE #-}s
21:44:50 <applicative> not much room for them
21:45:22 <applicative> tailcalled thinks that he can get the effect of print (f 1) by putting f 1 on the next line
21:45:32 <JoeyA> The compiler should automatically inline it.  Actually, it might be worse to inline, since it reduces sharing.
21:46:45 <elliott> JoeyA: are you questioning speed
21:47:25 <shachaf> GHC's heuristics for inlining don't always do what you want. :-( Apparently it's hard to always do the right thing automatically.
21:47:54 <lambdabot> i love inlining
21:47:58 <lambdabot> it is so easy
21:48:07 <applicative> what?
21:48:14 <parcs> uh oh
21:50:05 <AfC> ha
21:50:44 <ivanm> hooray, yet another failing test case where magically any shrinking stops it from failing
21:51:49 <AfC> So I'm trying to improve the performance of some code. I deliberately started without using any strictness annotations, did +RTS -s and -p, and then started making changes. So far the profiling output hasn't changed a whit.
21:52:26 <AfC> I assume that means that the things I'm marking strict are already being evaluated? Meanwhile, I would have expected the memory overhead to drop, but not so far.
21:52:34 <AfC> Clearly I'm not yet on the right track.
22:02:10 <hpaste> Dame pasted “list comprehension question” at http://hpaste.org/80043
22:02:56 <ivanm> Dame: what are you trying to do there?
22:02:56 <Dame> hi, was just starting out with haskell and wondering why that wouldn't work ^
22:03:14 <Dame> ivanm: trying to make a recursive function call i guess
22:03:23 <ivanm> Dame: for starters, x `elem` [1,2..] will never end if x < 1
22:03:28 <shachaf> Dame: What is its type?
22:03:38 <ivanm> and that's what i was going to do next :)
22:03:43 <shachaf> Dame: If you figure out the type your job will be much easier. :-)
22:03:46 <Dame> ivanm: ok.
22:03:59 <Dame> shachaf: oh i haven't reached that chapter yet
22:04:08 <Dame> i'll wait for it i suppose
22:04:21 <shachaf> Uh oh.
22:04:41 <shachaf> OK, can you describe in words what that function should be?
22:05:11 <Dame> so suppose there is a list within a list, i want to return the inner list elements
22:05:40 <shachaf> Oh, I see what you're doing, I think.
22:05:55 <shachaf> "x `elem` [1,2..]" is meant to check whether x is a number (as opposed to a list)?
22:05:58 <Dame> yes
22:06:01 <Dame> exactly :)
22:06:22 <shachaf> OK, that won't work for several reasons.
22:06:44 <Dame> ok why not?
22:06:51 <shachaf> It's probably simplest if you keep reading, like you said. :-)
22:06:56 <shachaf> This is a tree function, not a list function.
22:07:16 <shachaf> A list in Haskell has all elements of the same type, and its "depth" is known at compiletime.
22:07:24 <Dame> yeh i haven't thought that part through, was just playing around :)
22:07:29 <Dame> aha that makes sense
22:07:33 <Dame> the depth of this one isn't known
22:07:46 <shachaf> Right, mostly because it's a tree, not a list. :-)
22:08:13 <Dame> oh yeah. i was assuming all the number-containing lists would be at the same level
22:08:13 <shachaf> Or maybe that's not quite true, depending on what you intended.
22:08:28 <Dame> i was gonna call it on such a list anyway
22:08:54 <ivanm> @type [1,2..]
22:08:55 <lambdabot> (Enum t, Num t) => [t]
22:09:30 <hpaste> Dame pasted “error” at http://hpaste.org/80044
22:10:08 <shachaf> (Pasting the error along with the code is a good habit!)
22:10:09 <Dame> shachaf: so, thats what the error means?
22:10:17 <Dame> shachaf: i'll keep that in mind!
22:10:31 <shachaf> The error means that GHC can't figure out the type of the list.
22:10:40 <shachaf> For example, is it a list of Ints? Or a list of lists of Ints?
22:10:57 <shachaf> It looks like it's a list of itself, which doesn't make any sense (because that would be a tree).
22:11:02 <Dame> ok
22:11:15 <shachaf> I recommend learning more about types, and then writing the type signature first for something like this. :-)
22:11:33 <Dame> yeah i'll keep reading. thank you for your help, shachaf!
22:13:35 <applicative> Dame: if then else means x and rec xs have to be the same type
22:13:55 <Dame> applicative: oh
22:14:00 <applicative> in if x `elem` [1,2..] then x else rec x
22:14:31 <applicative> so the compiler is trying to find something thats the same type as x, but is a list type that can contain x as an element
22:14:53 <Dame> applicative: cool, makes sense now!
22:25:44 <fragamus> doesanyone know how computationally intensive it is to finalize a SHA1 hash? I am trying to decide whether to recompute the finalize every time I need it or pass it around so it is not recomputed needlessly
22:27:35 <tgeeky> sounds like a question that has an answer somewhere on stack overflow
22:30:03 <shachaf> Hmm, what does it mean to "finalize" a hash?
22:30:22 <shachaf> To add on the padding/length/etc. and compute the function on the last block?
22:31:59 <fragamus> it produces the digest from some internal values
22:32:39 <fragamus> it appears that finalize for SHA1 merely concatenates some registers
22:33:04 <shachaf> I expect that it does more, but I don't know what the SHA1 API that you're using looks like.
22:33:22 <shachaf> Anyway I'd expect it to be relatively cheap, but you can always measure it if you really care.
22:34:00 <fragamus> Crypto.Hash.SHA1
22:36:39 <shachaf> OK, so it does what I said, more or less.
22:45:47 * cmccann resists the temptation to go an gratuitously lens-ify his alternate Prelude
22:47:59 <startling> 'head' should totally be a traversal
22:48:15 <startling> pun not intended
22:48:53 <AfC> cmccann: but think of the opportunity to gratuitously mix permutations of ! @ # $ % ^ & * + - to create new operators to obfuscate and further contribute to Haskell's reputation of being unreadable!
22:49:38 <cmccann> AfC, well I don't think the lensketeers really need my help with that
22:49:55 <AfC> heh
22:50:00 <cmccann> they seem to have that pretty well handled in fact
22:50:04 <AfC> indeed
22:50:09 <AfC> (bloody hell)
22:51:15 <shachaf> Speaking of which, we need an infix name for review.
22:51:18 <shachaf> elliott: Right?
22:51:23 <startling> (???)
22:51:29 <startling> :t (???)
22:51:30 <lambdabot> Not in scope: `???'
22:53:57 <elliott> shachaf: Dunno.
22:54:18 <elliott> AfC: If you know the operator scheme it's pretty simple.
22:55:13 <AfC> spent yesterday trying to make something -conduits work, battling the difference between $$, $$-, $$+- and $${fuckoffalready}
22:55:15 <shachaf> ion: Today I tried to write 142^.base 16
22:55:18 <shachaf> Of course that didn't work.
22:55:28 <shachaf> But remit (base 16) is awful.
22:55:43 <cmccann> yeah, lens is actually a very nice use of mnemonic value and self-consistent semantic interpretation of symbols
22:55:53 <AfC> so I'm a little tired (again) of people arbitrarily creating new operators and expecting other people to be able to figure it out.
22:56:32 <cmccann> AfC, what lens does is basically the right way to define a gratuitous pile of operators
22:56:49 <AfC> cmccann: I hope so
22:56:53 <shachaf> We should put that on the front page.
22:56:55 <mikeplus64> there is never a right way of defining a gratuitous pile of operators
22:57:05 <AfC> cmccann: though, really, if it's so good, then it should become a part of the language spec.
22:57:31 <elliott> lens is the kind of thing that sort of wants to be in the standard libraries, yes.
22:57:38 <elliott> It won't be, though.
22:57:53 <shachaf> It's not in a state where it ought to be in the standard libraries.
22:58:15 <AfC> [which is a high bar, and since that's difficult to achieve, should ricochet back to people wanting to define new operators. OMeta notwithstanding]
22:59:07 <startling> I wonder whether you could write a function String -> lens function
23:00:10 <elliott> startling: doing what?
23:00:18 <shachaf> AfC: Are you Andrew Coppin?
23:00:24 <cmccann> AfC, anyway, Haskell's reputation for being unreadable is kind of ridiculous to begin with so I really don't care about that
23:00:30 <AfC> shachaf: no, sorry
23:00:33 <shachaf> OK.
23:00:36 * shachaf didn't think so.
23:00:45 <shachaf> He had some other nick in here once.
23:00:46 <startling> elliott: generating a function like the lens operator that looks like the string
23:01:14 <elliott> that would have to be dependently-typed
23:01:39 <cmccann> could use it in a QQ'er!
23:01:44 <cmccann> that would be pretty useless though.
23:02:13 <AfC> cmccann: oh, I'm ok with Haskell's syntax. It's just when people start defining rafts of new operators in order to use library $x it puts a higher burden on putative new users [experienced haskellers] to have a chance of hell of reading code written in it.
23:02:14 <cmccann> a build-your-own-lens-operator TH quasiquoter would be hilarious though
23:02:43 <startling> elliott: would it? you could probably do it with a sum type
23:02:57 <elliott> well, sure
23:03:03 <elliott> then it's not really giving a function though
23:03:57 <cmccann> AfC, the main problem there is in knowing the fixities, really
23:04:18 <cmccann> since you can't even parse the code without knowing that
23:04:24 <startling> write a String -> Either Int Int, too
23:07:03 <startling> (that tells you the fixity of an operator)
23:35:54 <roconnor> @tell shapr Apparently I don't know how to, or cannot bootstrap GHC on an arm.
23:35:54 <lambdabot> Consider it noted.
23:52:45 <lispy> roconnor: RTFM harder?
23:53:19 <lispy> roconnor: Caveat: I do no speak from experience. The one time I used it on ARM I installed it via a package manager.
