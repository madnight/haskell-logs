00:00:36 <aavogt> yes it should be resolved relative to where the source file is
00:02:11 <pqmodn> aavogt: this might get you headed in the right direction http://www.haskell.org/pipermail/haskell-cafe/2011-December/097217.html
00:02:37 <pqmodn> aavogt: resolving relative to a source path might be tricky. once you've compiled to a binary, it might not make sense
00:03:53 <pqmodn> aavogt: that link won't help in GHCi, btw. only for compiled programs
00:03:56 <aavogt> getProgName is "<interactive>"
00:03:58 <aavogt> yeah
00:04:46 <pqmodn> aavogt: you can invoke your main function using withProgName, though
00:04:51 <pqmodn> from GHCi
00:04:58 <pqmodn> aavogt: http://www.haskell.org/ghc/docs/latest/html/libraries/base/System-Environment.html
00:05:16 <aavogt> the issue is getting that String in the first place :)
00:05:40 <pqmodn> you might stick it in a .ghci file in your project directory
00:06:09 <pqmodn> let progName = "/users/aavogt/project/src/Main" or something
00:07:19 <aavogt> yeah I could just include an absolute path for where the file (to be read at compile time) is located
00:08:13 <aavogt> hmm, maybe adding a .ghci can fix it too
00:16:07 <latermuse> Im trying to install hmatrix with cabal, and it gives me this error: Sorry, I can't link GSL.
00:16:26 <latermuse> What am I missing that is preventing this library from installing correctly?
00:16:58 <aavogt> probably this doesn't help, but hmatrix does need a C library called GSL
00:18:56 <latermuse> that probably does help! haha :) thanks
00:19:06 <mapf> i'm opened hackage page for category-extras-1.0.2 and i'm stunned...
00:19:06 <mapf>  
00:19:06 <mapf>  
00:19:06 <mapf>  
00:19:09 <mapf>  
00:19:13 <mapf>  
00:19:16 <mapf>  
00:19:20 <mapf>  
00:19:23 <mapf>  
00:19:24 <epta> с-с-с-с
00:19:24 --- mode: ChanServ set +o johnw
00:19:26 <mapf>  
00:19:28 --- kick: mapf was kicked by johnw (Kicked by johnw)
00:19:38 --- mode: johnw set -o johnw
00:19:49 * hackagebot gitlib 0.5.1 - Higher-level types for working with hlibgit2  http://hackage.haskell.org/package/gitlib-0.5.1 (JohnWiegley)
00:21:18 <sopvop> does forall . (a ~ Int) :: a -> a produce same code and subject to same optimizations as :: Int -> Int ?
00:34:50 * hackagebot connection 0.1.1 - Simple and easy network connections API  http://hackage.haskell.org/package/connection-0.1.1 (VincentHanquez)
00:41:16 <wuttf> Morning. I am trying to wrap my head around why I can only catch exceptions in the IO monad but I am not entirely convinced.
00:42:23 <wuttf> Wait, I am.
00:42:31 <wuttf> Ouch :D
00:47:16 <aavogt> sopvop: output from ghc-core seems to be different between the two if the function is NOINLINE. But if the function gets inlined (in my case (+1)) the two seem to generate the same code (except for some labels being different)
00:47:57 <aavogt> maybe there's no performance penalty in the first case (I would hope there's none)
00:49:50 * hackagebot alpha 1.0.11 - A compiler for the Alpha language  http://hackage.haskell.org/package/alpha-1.0.11 (MarcCoiffier)
00:50:34 <SrPx> Stupid question, but Haskell's range is inclusive and Python's range is exclusive... why?
00:51:29 <johnw> different people made those two languages
00:51:37 <Jafet> Because python is stupid
00:51:52 <shachaf> Also because Haskell is stupid.
00:51:59 <Jafet> > [minBound .. maxBound] :: [Word8]
00:52:01 <sopvop> aavogt: Thanks.
00:52:01 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
00:52:02 <srhb> Depending on whom you ask.
00:52:08 <ben_m> Another reason could be that ] is used for inclusive range in maths
00:52:23 <sopvop> any good intro tutorials for reading core?
00:52:24 <simpson> SrPx: Python's slice semantics are based on the classic arguments for array traversal. See e.g. Dijkstra's paper.
00:52:45 <shachaf> Y'all should know that these new lenses are the future.
00:52:47 <aavogt> > [ 1.1 .. 3 ]
00:52:49 <lambdabot>   [1.1,2.1,3.1]
00:52:57 <shachaf> (g a -> f b) -> g s -> f t
00:52:59 <simpson> Haskell's make a lot of sense when you consider that you can use the range operation on *any* Enum.
00:52:59 <pqmodn> sopvop: http://www.scs.stanford.edu/11au-cs240h/notes/ghc-slides.html#(1)
00:53:08 <Twisol> you get weird behavior with floating points and rangs.
00:53:10 <Twisol> *ranges.
00:53:28 <johnw> simpson: that's a great point
00:53:43 <aavogt> it would be less weird if that list didn't contain 3.1
00:53:54 <SrPx> hmm..
00:54:14 <wereHamster> is there a large haskell project hwich has a long history of using HPC? I'd like to graph the coverage over time
00:54:47 <Jafet> > [0.1,0.2..]
00:54:49 <lambdabot>   [0.1,0.2,0.30000000000000004,0.4000000000000001,0.5000000000000001,0.600000...
00:55:19 <FireFly> > [0.1,0.2..] !! 1000
00:55:21 <lambdabot>   100.10000000000618
00:55:43 <SrPx> I get it, but which one is better? Is there an agreement?
00:57:25 <johnw> um, you're asking that on #haskell?
00:57:26 <Jafet> I wonder if there is any language that uses (a, b] ranges.
01:03:13 <pyrtsa> > map (/10) [1,2..] !! 1000
01:03:14 <lambdabot>   100.1
01:03:42 <ben_m> > map (/10) [1::Int,2..] !! 1000
01:03:44 <lambdabot>   No instance for (GHC.Real.Fractional GHC.Types.Int)
01:03:44 <lambdabot>    arising from a use o...
01:03:48 <ben_m> derp.
01:14:25 <c_wraith> > map (/10) [1::Rational,..] !! 1000
01:14:27 <lambdabot>   <hint>:1:24: parse error on input `..'
01:14:47 <c_wraith> > map (/10) [1::Rational ..] !! 1000
01:14:48 <lambdabot>   1001 % 10
01:15:01 <c_wraith> the (!!) operator is zero-indexed
01:19:51 * hackagebot circle-packing 0.1.0.2 - Simple heuristic for packing discs of varying radii in a circle  http://hackage.haskell.org/package/circle-packing-0.1.0.2 (JoachimBreitner)
01:26:18 <`nand`> Is there a function Type -> Type (or similar) to do type-evaluation, the way :kind! does?
01:26:24 <`nand`> for use with TH
01:27:36 <`nand`> ah never mind, I can avoid it
01:49:46 <sopvop> can it be what -ddump-simpl-stats does not report SPEC rule because it actually inlines function, not just specializes?
01:51:55 <shachaf> That sounds reasonable.
02:08:14 <neutrino_> hi
02:08:42 <neutrino_> why does this: foldl (+) 0 [trace ("<" ++ (show x) ++ ">") x | x <- [1..10]]    show the same order as foldr?
02:09:24 <`ramses`> :t trace
02:09:26 <lambdabot> Not in scope: `trace'
02:09:37 <neutrino_> @hoogle trace
02:09:37 <lambdabot> Debug.Trace module Debug.Trace
02:09:37 <lambdabot> Debug.Trace trace :: String -> a -> a
02:09:37 <lambdabot> Debug.Trace traceShow :: Show a => a -> b -> b
02:09:43 <merijn> neutrino_: Because trace executes in the list comprehension, not the foldl?
02:09:43 <neutrino_> :t Debug.Trace.trace
02:09:45 <lambdabot> String -> a -> a
02:10:10 <merijn> (I think)
02:10:20 <neutrino_> merijn: i thought the list elements don't get executed until they're needed
02:10:28 <neutrino_> and they're needed when the fold gets to them
02:10:50 <merijn> neutrino_: Debug.Trace doesn't play by the rules, he's a rogue operator!
02:11:12 <neutrino_> heh
02:11:20 <neutrino_> i do think there should be a good explanation
02:11:24 <merijn> I have no clue how/when it evaluates, but clearly it's not evaluated by the fold
02:11:30 <quchen> merijn: I don't find that convincing. Trace uses unsafePerformIO, but that is still just packed in a thunk until it's needed.
02:12:47 <quchen> trace is essentially 'unsafePerformIO $ do { print a; return b }', and unsafePerformIO is just a function like any other (that has evil internals).
02:13:01 <quchen> Or is unsafePerformIO magical beyond its actual execution?
02:13:12 <Jafet> > error "a" + error "b"
02:13:14 <lambdabot>   *Exception: a
02:13:18 <Jafet> > (error "a" + error "b") + error "c"
02:13:20 <lambdabot>   *Exception: a
02:13:23 <Jafet> > error "a" + (error "b" + error "c")
02:13:24 <lambdabot>   *Exception: a
02:14:19 <neutrino_> Jafet: no surprises here
02:14:33 <`ramses`> neutrino_: I find the second line strange
02:14:39 <Nereid> why?
02:14:49 <merijn> neutrino_: Well, that also explains the fold behaviour
02:14:50 <`ramses`> shouldn't it evaluate the error c first?
02:14:54 <Nereid> why?
02:14:56 <merijn> `ramses`: Why?
02:14:57 <`ramses`> and then the expression in brackets?
02:15:01 <neutrino_> the outer plus evaluates the left argument first, i think.
02:15:02 <Nereid> why?
02:15:15 <Nereid> the first argument gets evaluated first
02:15:15 <merijn> `ramses`: It just evaluates the left side first
02:15:15 <`ramses`> ok, wait, I'm confused :)
02:15:57 <merijn> And since the bracketed left side evaluates to "error "a"", so does the entire expression
02:18:44 <neutrino_> right
02:18:48 <quchen> This error talk reminds me of a question I wanted to ask for a long time: 'error X' has type 'a'. How can such an error be caught? Using Control.Exception always means that the possibility of having an error is somewhere in the type.
02:18:51 <neutrino_> and if you look at the definition of foldr and foldl
02:19:10 <neutrino_> then in one of them <1> should be printed out first, and in another <10>
02:19:25 <quchen> neutrino_: foldr should evaluate 9+10 first, right.
02:19:36 <Botje> no, why should it?
02:19:38 <merijn> quchen: Eh, what? Control.Exception doesn't mean that at all
02:19:51 <quchen> merijn: It doesn't? Oh
02:19:53 <Botje> + evaluates its arguments from left to right.
02:19:57 <neutrino_> no, it should execute 1 first
02:20:04 <neutrino_> foldl should execute 10 first
02:20:10 <merijn> quchen: Where did you see Control.Exception put anything in the type?
02:20:24 <Botje> so no matter if you have ((((((((<thunk> + <thunk>) + ....) or <thunk> + (<thunk> + (....)))
02:20:32 <Botje> you will always print 1 first
02:20:32 <neutrino_>  foldr f z [x1, x2, ..., xn] == x1 `f` (x2 `f` ... (xn `f` z)...)
02:20:35 <neutrino_> or something
02:20:41 <neutrino_> i don't know! it's confusing
02:20:46 <quchen> foldr (+) 0 [1,2,3] = 1 + (2 + (3 + 0)  <=== 3+0 executed first
02:20:58 <merijn> > foldr (+) 0 [a,b,c,d,e]
02:20:59 <lambdabot>   a + (b + (c + (d + (e + 0))))
02:21:03 <merijn> > foldl (+) 0 [a,b,c,d,e]
02:21:04 <neutrino_> it's confusing because this formula says something different than the text
02:21:05 <lambdabot>   0 + a + b + c + d + e
02:21:13 <merijn> quchen: No
02:21:17 <quchen> e+0 first vs 0+a first
02:21:26 <merijn> quchen: The bracketing doesn't say anything about which is evaluated first
02:21:34 <quchen> Huh?
02:21:35 <merijn> quchen: You evaluate the outer plus first
02:21:42 <quchen> Oh.
02:21:47 <quchen> Color me surprised.
02:21:51 <merijn> quchen: And that one picks the left hand side
02:22:16 <neutrino_> maybe the formula should be: foldr f z [x1, ..., xn] == (...(z `(flip f)` xn) ... `(flip f)` x2) `(flip f)` x1
02:22:20 <neutrino_> what do you think?
02:22:20 <`ramses`> this is indeed quite confusing! I thought I completely grasped the folds
02:22:30 <neutrino_> assuming left-to-right argument evaluation
02:22:36 <merijn> It's not confusing at all
02:22:49 <neutrino_> in haskell, is the order of evaluation of function arguments defined?
02:22:55 <`ramses`> it is, until you clearly write it out
02:22:59 <merijn> fold affects the bracketing, but bracketing doesn't affect evaluation order in the case of (+)
02:23:01 <neutrino_> or at least, does ghc have a convention for that?
02:23:24 <neutrino_> merijn: hmm ok
02:23:26 <merijn> quchen, `ramses`: Do you understand how you can represent these nested expressions as a tree of expressions?
02:23:26 <quchen> I'm always confusing Haskell's parentheses with mathematical ones. (The result is the same, but the evaluation order is different from when I do something by hand.)
02:23:28 <Botje> neutrino_: top to bottom wrt clauses, then left to right wrt patterns.
02:23:39 <`ramses`> neutrino_: I guess that depends on implementation of the function
02:23:44 <merijn> quchen: Mathematical parenthesis don't have an evaluation order
02:24:00 <quchen> merijn: But I have one when I use them :-)
02:24:07 <`ramses`> merijn: I do, but I too linked the rbackets to evaluation order
02:24:22 <merijn> quchen: Wanna bet you don't follow a fixed evaluation order when calculating by hand?
02:24:23 <quchen> a + (b + c) most likely means you're adding b+c first. I just wanted to illustrate where my misconception came from.
02:24:47 <merijn> quchen: Counter example #1: 0 * (14071979471 * 101048048), compute by hand :)
02:24:58 <quchen> Pfffff
02:25:31 <quchen> Counter example #2 will be 1*x
02:25:35 <quchen> What's #3?
02:25:43 <merijn> `ramses`: (+) just traverses the expression trees on it left and right hand side, and goes left first. Hence why
02:25:50 <Botje> I think if you write a foldr' it will come out as you expected.
02:25:56 <merijn> > (error "a" + error "b") + error "c"
02:25:58 <lambdabot>   *Exception: a
02:25:58 <neutrino_> let f x y = x `seq` y `seq` (x+y)
02:26:10 <neutrino_> foldr and foldl with this f still show going from 1 to 10
02:26:40 <Botje> foldr' f z xs = foldr (\a b -> b `seq` a `seq` f a b) z xs
02:26:40 <merijn> neutrino_: Try f with foldr'?
02:26:48 <`ramses`> merijn: yes, I do understand that, I just never explicitely thought about that before, and then implicitly concluded the order depends on the brackets. But it's crystal clear now :)
02:27:01 <merijn> `ramses`: Good :)
02:27:36 <`ramses`> foldr' ? does that exist?
02:28:30 <neutrino_> aha, i just found out something interesting about foldl/foldr
02:28:34 <merijn> :t foldr'
02:28:35 <lambdabot>     Not in scope: foldr'
02:28:35 <lambdabot>     Perhaps you meant one of these:
02:28:36 <lambdabot>       BS.foldr' (imported from Data.ByteString),
02:28:42 <merijn> aww, no it doesn't, apparently
02:28:46 <quchen> merijn: Coming back to my exception question: how are exceptions encoded if not in the type? (I just had a look a the libs and convinced myself that there's no "throws" type. Now I'm even more confused.)
02:28:57 <neutrino_> it's not about right to left or left to right
02:29:10 <neutrino_> it's about evaluating the cells first or as you need them
02:29:12 <quchen> Is there some easy explanation on how exceptions are implemented? (Massive CPS magic would be my guess)
02:29:14 <neutrino_> let f2 x y = (traceShow x x) `seq` (traceShow y y) `seq` (x+y)
02:29:16 <merijn> quchen: They are not encoded anywhere, except in documentation
02:29:41 <neutrino_> look at how that works in: foldr f2 0 [trace ("<" ++ (show x) ++ ">") x | x <- [1..10]
02:29:41 <merijn> quchen: Yes, there's 2 papers on how exceptions in Haskell are implemented, lemme check if I remember the names
02:29:44 <neutrino_> and foldl
02:29:56 <neutrino_> awkward squad is one of them
02:29:58 <quchen> Counter example #2 will be 1*x
02:30:02 <quchen> Woops
02:30:04 <quchen> Ignore that
02:30:09 <quchen> @src throw
02:30:09 <lambdabot> throw exception = raise# exception
02:30:15 <neutrino_> quchen: i hate that you make me hungry :(
02:30:20 <luite> quchen: there are two parts of the implementation. one is the low-level implementation with GHC. throwing an exception is a primop that causes some code to unwind the stack to the topmost exception handler
02:30:24 <merijn> quchen: Actually, the docs for Control.Exception list three papers
02:30:28 <neutrino_> foodRelatedNicknames--
02:30:40 <quchen> neutrino_: Enjoy your German
02:30:56 <quchen> :>
02:31:05 <luite> quchen: the other one is the extensible exceptions mechanism that you usually use, that's based on Typeable and cast for checking whether the exception is something you want to catch in a handler
02:31:08 <neutrino_> meh
02:31:15 <neutrino_> i guess it's time for breakfast anyways
02:31:55 <luite> quchen: see fromException, that converts a SomeException to a specific exception
02:32:17 <quchen> merijn, luite: Thanks. I always thought exceptions were something implemented on a library level. So is it safe to say that it's as odd as IO?
02:32:31 <merijn> quchen: The idea is that you can throw exceptions from pure code (you have to sometimes, think stuff like out of memory/whatever) hence why the throw types have type "a", but exceptions can only be caught in IO
02:33:10 <neutrino_> @hoogle foldr'
02:33:11 <lambdabot> Data.Foldable foldr' :: Foldable t => (a -> b -> b) -> b -> t a -> b
02:33:11 <lambdabot> Data.ByteString.Char8 foldr' :: (Char -> a -> a) -> a -> ByteString -> a
02:33:11 <lambdabot> Data.IntSet foldr' :: (Int -> b -> b) -> b -> IntSet -> b
02:33:15 <luite> quchen: yes the regular throw/catch definitely is special, but there are alternatives of course
02:33:38 <merijn> quchen: Well, when people say exceptions there's two possible meanings, they can mean "pure" error handling, i.e. stuff like Either based exceptions or they can mean "true" exceptions like you'd have in Java, Python, whatever. These latter ones can only be caught/handled in IO and are not visible in the type
02:33:42 <neutrino_> foldr' evaluates right to left, merijn
02:34:45 <quchen> Lunch time, impatient colleagues. Thanks luite and merijn again, that clarified a lot. I'll have a look at the papers later.
02:34:49 <merijn> quchen: i.e. Control.Exception style exceptions are like Java's Runtime Exception (or, unchecked exceptions in general)
02:45:55 <neutrino_> merijn: have you tried f2 in ghci? it's very interesting
02:51:53 <neutrino_> btw, foldl' evaluates left to right
02:52:26 <Cale> (and so does foldr)
02:52:47 <shachaf> Cale: Did you hear about our new lenses?
02:52:52 <shachaf> They're about a bazillion times better.
02:53:12 <shachaf> type Iso s t a b = (Functor f, Functor g) => (g a -> f b) -> g s -> f t
02:54:02 <t7> > 254 * 254
02:54:04 <lambdabot>   64516
02:54:15 <johnw> shachaf: how so?
02:54:22 <shachaf> Just look at them!
02:54:27 <dblhelix> Cale: well, it traverses the spine left of the list folded over left to right, indeed. ;) Can't say anything about the elements, can you?
02:54:42 <johnw> shachaf: um, are they faster?
02:54:52 <dblhelix> s/spine left/spine
02:54:57 <shachaf> Faster than maximally fast?
02:55:02 <shachaf> They're prettier.
02:55:04 <johnw> ah
02:55:13 <shachaf> http://slbkbs.org/pr.hs
02:55:17 <johnw> maximally pretty?
02:56:04 <johnw> no Traversal?
02:56:12 <shachaf> Nah, we can add that later.
02:56:14 <shachaf> That doesn't change.
02:56:22 <johnw> that is indeed very pretty!
02:56:38 <johnw> where does the term "costrength" come from?
02:57:00 <shachaf> @google costrong functor
02:57:04 <elliott> Category theory, sort of.
02:57:04 <lambdabot> http://www.ams.org/bookstore/pspdf/crmm-29-prev.pdf
02:57:07 <shachaf> Hmm.
02:57:16 <shachaf> http://comonad.com/reader/2008/deriving-strength-from-laziness/
02:58:02 <epta> shachaf: what `slbkbs' stands for?
02:58:09 <epta> Nice domain name
02:58:41 <johnw> shachaf: is this revelation something edwardk came up with, or #haskell-lens?
02:59:36 <johnw> @pl \l -> getConst . l (Const . copoint) . point
02:59:37 <lambdabot> (getConst .) . (. point) . ($ Const . copoint)
02:59:52 <shachaf> I came up with it up to Isomorphism.
02:59:58 <shachaf> Then elliott came along.
03:00:08 <shachaf> I suspect other people knew about it before.
03:00:20 <elliott> johnw: I figured out prisms want costrength.
03:00:25 <epta> Is `(getConst .) . (. point) . ($ Const . copoint)' the same as `(getConst .) . (. point) . (Const . copoint)' ?
03:00:29 <johnw> this is a really nice development
03:00:38 <elliott> johnw: Mainly by banging my head against the wall repeatedly until the type reduced itself to that.
03:00:52 <johnw> three cheers for the haskell-lens team!
03:00:58 <elliott> johnw: It's not *completely* nice.
03:01:10 <elliott> It breaks compatibility and you can't use twanvl lenses directly as lenses any more.
03:01:24 <johnw> elliott: it reduces the core lens types into something that's actually readable
03:01:30 <johnw> that's a big step
03:01:37 <elliott> But also all this stuff is Haskell 98 + rank-2 types, so a lens-core for people to export stuff with would be much more viable, and you can turn twanvl lenses into these easily.
03:01:46 <johnw> i'll just need to bone up on Costrong now, to be able to reason with these definitions
03:01:50 <elliott> johnw: Well, Lens/Getter/Setter become more noisy.
03:01:53 <elliott> Prism/Iso become nicer though.
03:01:59 <`nand`> shachaf: what does this representation buy over the old one? Does it allow composing isos or prisms using (Prelude..) while getting a new iso/prism?
03:02:07 <shachaf> `nand`: Yep.
03:02:09 <johnw> and the relationships among them become very clear
03:02:12 <`nand`> that's quite awesome
03:02:13 <neutrino_> Cale: yeah
03:02:13 <johnw> shachaf: is Bazaar gone now?
03:02:19 <shachaf> No.
03:02:25 <shachaf> Bazaar is sort of orthogonal to this.
03:02:31 <johnw> and Context?
03:02:36 <shachaf> Also.
03:02:39 <johnw> ok
03:02:49 <`nand`> those are used when categorizing traversals and stuff; by filling them in for the ‘Functor f’ in the representation
03:02:52 <shachaf> A "real" version would probably use Applicative instead of Pointed.
03:02:53 <`nand`> in either
03:02:58 <elliott> johnw: Basically you need Costrong because you have "(s -> Either t a)" and "g (Either t a)", so you use "g (Either a b) -> Either a (g b)".
03:03:07 <elliott> Er, that turns into...
03:03:13 <elliott> Um, it's hard to explain.
03:03:17 <johnw> :)
03:03:22 <shachaf> IT JUST WORKS, OK?????
03:03:27 <elliott> The easiest way to see why it wants Costrong is probably to derive it from what shachaf started with yourself.
03:03:43 <shachaf> What did I start with?
03:03:47 <shachaf> I deleted that version. :-(
03:03:49 <`nand`> shachaf: I guess this raises the s/coerce/i count
03:03:54 <elliott> shachaf: Let's never remember.
03:04:13 <elliott> This doesn't use coerce any more than the current lens uses coerce.
03:04:19 <shachaf> elliott: Come on, it got us where we are today!
03:04:23 <johnw> Hakell: where "hand-waving" is really a semaphore code between people who understand this stuff way better than you ever will!
03:04:36 <elliott> Hey, I don't even really know what costrength means.
03:04:45 <shachaf> I don't either.
03:04:45 <johnw> that will help sleep tonight, acutally
03:04:47 <elliott> I just saw that it had the same type as costrength and that that is obviously totally elegant.
03:04:51 <johnw> me*
03:04:58 <shachaf> I mean, I recognized it when I saw the type.
03:05:28 <johnw> well, as long as we're all human, that's ok then
03:05:30 <`nand`> I know what strength is, because it makes perfect sense (and all haskell functors are strong); just by looking at the type
03:05:38 <`nand`> but this is the first time I've seen costrength
03:05:53 <shachaf> The fact that all Haskell functors are strong makes it *harder* to understand strength.
03:06:22 <`nand`> ‘strength’ in terms of the haskell function; not in terms of the categorical concept or whatever
03:06:31 <`nand`> (f a, b) -> f (a, b)
03:06:35 <elliott> `nand`: If it helps, the two "f"s that are used as Costrong are Identity and Proxxy
03:06:38 <elliott> Proxy
03:06:44 <elliott> Identity (Either a b) -> Either a (Identity b)
03:06:51 <elliott> Proxy (Either a b) -> Either a (Proxy b)
03:07:11 <`nand`> yeah
03:07:32 <`nand`> also Const r, which just always gives back Right
03:07:47 <elliott> Well, Const r is the same as Proxy here.
03:07:50 <elliott> They both always give back Right.
03:08:16 <`nand`> Right.
03:08:17 <elliott> All our instances either always give back Right or perform trivial case analysis (because (f a) is isomorphic to a single a).
03:08:31 <elliott> Maybe there's more interesting costrengths? Or maybe costrength encodes that your functor is boring like that.
03:08:44 <hpaste> neutrino pasted “folds” at http://hpaste.org/79353
03:08:59 <elliott> A nice thing about this version is that you can characterise all lenslikes by two typeclasses: one for f and one for g.
03:09:10 <elliott> And lenslikes compose if the subclasses line up. It's sort of like subtyping.
03:09:18 <neutrino_> Cale: ^
03:09:40 <`nand`> elliott: yeah, that's nice
03:09:43 <`nand`> but the best thing is composing prisms
03:09:56 <neutrino_> Cale: the important bit is at 11:28
03:10:06 <elliott> `nand`: Well, technically you can do that already, but you need Control.Category, which sucks.
03:10:15 <elliott> (OK, I like Control.Category, but it sucks that you need it to compose them.)
03:10:49 <`nand`> right; but (Control.Category..) is a mouthful; for lambdabot code
03:11:01 <`nand`> where you don't have the liberty of importing Prelude hiding ((.),id)
03:11:20 <`nand`> and, after all, showing off via lambdabot is the number one use case of lenses
03:12:01 <neutrino_> :t Prelude..
03:12:04 <lambdabot> parse error on input `Prelude..'
03:12:06 <neutrino_> :t (.)
03:12:08 <lambdabot> Functor f => (a -> b) -> f a -> f b
03:12:19 <neutrino_> you were saying, `nand`?
03:12:20 <alpounet> :t (Prelude..)
03:12:21 <lambdabot> (b -> c) -> (a -> b) -> a -> c
03:12:42 <neutrino_> :)
03:12:48 <neutrino_> :t (Control.Category..)
03:12:49 <lambdabot> Control.Category.Category cat => cat b c -> cat a b -> cat a c
03:12:52 <`nand`> okay, good point, lambdabot's (.) is already messed up
03:13:21 <neutrino_> is CCC's . a generalization of the functor . ?
03:13:49 <`nand`> I think they're orthogonal generalizations
03:13:51 <`nand`> not sure, thouogh
03:14:00 <shachaf> fmap is a silly generalization.
03:14:05 <shachaf> (.) is obviously the correct one.
03:14:11 <`nand`> agreed
03:14:32 <shachaf> Er.
03:14:39 <shachaf> I meant (Control.Category..).
03:14:43 <`nand`> the only ‘useful’ thing about the fmap generalization, I think, was having (.:) and (.::) for mapping over nested functors in a succinct way. That being said, lenses do this better
03:14:44 <shachaf> That wasn't very helpful, I suppose.
03:14:58 <Nereid> fmap.fmap.fmap does it better too
03:15:18 <shachaf> Nereid: So how 'bout them new lenses?
03:15:22 <shachaf> Pretty great, huh?
03:15:57 <sopvop> is that $fSchemaCoder... in `a_saAJ = getSchemaOfResource (userEncoder $fSchemaCoderSchemaOfResource)' a dictionary?
03:17:18 <parcs> sopvop: do you have a dictionary named SchemaOfResource?
03:17:22 <Nereid> shachaf: they turn me on a little, yes
03:17:34 <shachaf> sopvop: Yes.
03:17:36 <sopvop> I have a newtype called so, it is an instance of SchemaCoder
03:17:47 <Nereid> too bad we'll lose the ability to use Data.Traversable.traverse
03:18:08 <sopvop> Specialization pragmas dont' fire, top level specializations do. :( sad
03:19:05 <elliott> Nereid: That's no problem. pr.hs doesn't even do Traversals!
03:19:17 <elliott> lens 4.0: Removed traversals and folds because shachaf didn't bother with them
03:20:40 <sopvop> hm, pagmas made with TH don't fire, manual ones do.
03:20:56 <sopvop> Mist be fully qualified names
03:20:59 <sopvop> must
03:22:16 <sopvop> Nope, not names. So, how do I make TH SPECIALISATION pragma to work?
03:23:17 <sopvop> ah, http://hackage.haskell.org/trac/ghc/ticket/5463
03:29:54 * hackagebot network-conduit 0.6.2.1 - Stream socket data using conduits.  http://hackage.haskell.org/package/network-conduit-0.6.2.1 (MichaelSnoyman)
03:32:53 <sopvop> which of -ddump flags dumps the last pre-cmm stage?
03:33:59 <shachaf> Isn't that -ddump-stg?
03:34:09 <sopvop> I'll try
03:35:52 <sopvop> does not look like what I need. I guess I need one with inlines
03:36:15 <shachaf> Inlines?
03:36:23 <shachaf> You want Core or what?
03:36:26 <sopvop> yes
03:36:33 <shachaf> Oh, -ddump-simpl should be fine.
03:36:54 <shachaf> You can also use -ddump-simpl-phases or -dverbose-core2core or something to see every pass of the simlpified.
03:36:58 <shachaf> simplifier
03:38:04 <sopvop> I only need final one
03:39:33 <alpounet> -ddump-simpl is probably what you want then (or just use ghc-core)
03:39:51 <sopvop> Yup, it was what I need
03:42:16 <sopvop> So, I have a bunch of code like  :: a -> (a -> b) -> (a -> b), and (a->b) in the end. Simplified core packs/unpacs that b on every call. Even though only one field of b is touched. I'm sure it can't be optimized any more in pure. Hope stg or cmm or whatever low level magic optimize it even more.
03:43:42 <fmap> @djinn a -> (a -> b) -> (a -> b)
03:43:43 <lambdabot> f a b _ = b a
03:46:28 <sopvop> almost :)
03:47:18 <sopvop> anyway, I'm impressed with GHC. It is awesome. Simon for president! (of Facebook)
03:49:23 <Peaker> why does cereal not keep track of the offset (equiv. of Binary's Get.bytesRead)?
03:55:55 <parcs> sopvop: which one?
03:56:02 <parcs> oh, of Facebook :P
03:57:25 <Jafet> Once SPJ retires to Google, we can take over the internet.
03:58:20 <notdan> maybe google will even start paying taxes
03:58:37 <sopvop> they are too rich for taxes
04:04:13 <wuttf> Whats wrong with this?    https://gist.github.com/4317823
04:04:26 <wuttf> As soon as I print x, the web server never responds to request
04:04:59 <Botje> wuttf: hgetcontents will read until the connection is closed.
04:05:09 <Botje> wuttf: and that won't happen until two statements later.
04:05:12 <wuttf> Botje: Haha, what a fail. Thank you
04:05:58 <wuttf> Botje: But interestingly, print x happens
04:06:08 <Botje> wuttf: oh, yes. absolutely.
04:06:24 <Botje> wuttf: hGetContents will return a lazy stream that produces list elements as input comes in.
04:06:43 <wuttf> Botje so basically the printing itself is what triggers the hGetContents
04:06:57 <merijn> wuttf: print will start printing immediately and keep doing so until it hits the end of the string
04:07:14 <Botje> print will eat one list element at a time until it encounters the end of the list
04:07:16 <merijn> wuttf: But the string produced by hGetContents won't end until the connection does
04:07:38 <wuttf> how can I work around this? I want the HTTP header sent by the browser.
04:07:46 <Botje> don't use hGetContents.
04:07:56 <merijn> wuttf: For this type of thing you really don't want to use lazy IO
04:07:58 <wuttf> Alternative?
04:08:05 <b___> can this be written nicererer? `selTag t x@(Leaf t2 _) | t == t2 = [x]` etc
04:08:13 <merijn> wutff: hGetLine or the byte version
04:08:14 <Botje> wuttf: you could read until the first blank line, for example.
04:08:38 <Botje> b___: which part don't you like?
04:09:16 <b___> the part where I wish I could use t inside the pattern, instead of on the right of '|'
04:09:31 <Botje> ah. yeah. no :)
04:09:41 <b___> hehe ok
04:11:27 <b___> that would be cute though
04:11:49 <b___> but I understand that it would require different syntax
04:12:38 <Botje> no, it would require being able to compare these things somehow.
04:12:53 <Botje> which is not always the case (functions, monadic things)
04:33:34 <neutrino_> i wish haskell could do symbolic analysis of code
04:33:58 <neutrino_> to find out if two values are the same, without pretending it can never know
04:34:09 <byorgey> @faq can Haskell do symbolic analysis of code?
04:34:09 <lambdabot> The answer is: Yes! Haskell can do that.
04:34:53 <byorgey> if you want to do symbolic analysis of some code you just have to make a deep embedding.  i.e. pass around an AST and then run/interpret it as necessary.
04:34:55 * hackagebot diagrams-contrib 0.6.0.1 - Collection of user contributions to diagrams EDSL  http://hackage.haskell.org/package/diagrams-contrib-0.6.0.1 (BrentYorgey)
04:39:32 <elliott> :t (.)
04:39:33 <lambdabot> Functor f => (a -> b) -> f a -> f b
04:39:36 <elliott> Oh, come on.
04:40:44 <shachaf> (b->c)_>a-_>b_.>Ca->c
04:40:46 <shachaf> hth
04:41:38 <neutrino_> byorgey: yeah, i know, but that's basically implementing ghc in ghc.
04:41:56 <byorgey> neutrino_: oh! no, I didn't mean an AST of all of Haskell!
04:42:11 <byorgey> I just meant a tiny AST representing exactly the stuff you need to be able to analyze.
04:42:12 <neutrino_> byorgey: my sentiment is, it would be very cool if ghc could carry around those AST's itself
04:42:13 <alpounet> just an AST of your domain specific stuffs
04:42:16 <neutrino_> yeah, i know
04:42:25 <neutrino_> i just wish that domain == Haskell
04:42:41 <byorgey> and if you say "I want to do symbolic analysis of ALL THE THINGS", I say "no you don't".
04:43:01 <neutrino_> i guess that would make Haskell more lispy in some stupidly defined way
04:43:09 <neutrino_> where code becomes data again, just not lists
04:43:14 <neutrino_> instead, ASTs
04:43:21 <neutrino_> i guess it would make TH happier too
04:43:44 <t7> type safe quoting
04:43:52 <t7> would it be useful?
04:44:20 <t7> relevant to my interests
04:46:35 <neutrino_> byorgey: for one thing, i'm betting that using type inference it COULD be inferred which values need to carry their ASTs around with them
04:47:26 <neutrino_> maybe kind of like with STM or reflection
04:52:39 <alpounet> neutrino_, what would be your use case?
05:13:56 <bourbaki> I have split my class definitions and instances, to be able to import implementations by just using import. But i get the orphaned instances warning now, is this generally not a good idea to spread the code like this?
05:14:06 <shachaf> bourbaki: It's not a good idea.
05:14:11 <shachaf> Orphan instances are trouble.
05:14:24 <bourbaki> What is the right way then?
05:14:36 <shachaf> Put the instance in the same module as either the class or the type.
05:14:44 <bourbaki> Problem is that if i define it in the same module then i can not change some functions.
05:15:08 <bourbaki> Eg i have a distance function which either can be in flat space, torus, sphere etc.
05:15:20 <Peaker> is there something like the Get monad, but lazier?  e.g: I want:  head . runGet (replicateM 10 getWord8)  $ L.fromChunks [BS.pack [0], undefined]      to not hit undefined
05:15:24 <bourbaki> Is there no way to get something like named instances?
05:16:03 <Peaker> bourbaki, you can place the instance at the class-side or the type-side and not be an orphan.. either parent will do
05:16:25 <bourbaki> Both causes the same problem though.
05:16:42 <bourbaki> In case for the distance function for example everything stays the same, all types etc.
05:17:02 <bourbaki> But the function is different so when i put them in the same module this rules out having different distance functions.
05:17:14 <bourbaki> Well metric spaces to be more precise.
05:17:18 <Peaker> bourbaki, oh, you want "alternative" instances for the same type?
05:17:19 <bourbaki> Which is a class.
05:17:23 <bourbaki> Yes
05:17:24 <Peaker> bourbaki, you use newtype for that
05:17:38 <bourbaki> Where on the importing side?
05:17:38 <Peaker> bourbaki, instances are "inherent" to types, and inherently global
05:17:47 <Peaker> bourbaki, on the side that defines the instance/behavior
05:17:58 <Peaker> bourbaki, for example, "Maybe" can be a Monoid in many ways
05:18:05 <bourbaki> Ok so i wrap the instance in a new type?
05:18:07 <byorgey> if you use a different newtype for each instance you can even mix them in the same code, which might be useful
05:18:25 <Peaker> bourbaki, Data.Monoid defines newtypes First, Last around Maybe to get 2 instances
05:18:30 <Peaker> bourbaki, in addition to the default instance
05:18:37 <bourbaki> Totally, i read that on the site but did not understand the idea completely that is almost as good as naming.
05:19:09 <bourbaki> type forwarding will not do?
05:19:20 <bourbaki> Er synonymous that is.
05:19:47 <Peaker> bourbaki, newtype First a = First { getFirst :: Maybe a } ; instance Monoid (First a) where mempty = First Nothing ; mappend (First (Just x)) _ = First (Just x) ; mappend _ y = y
05:20:04 <Peaker> bourbaki, type synonyms don't define a new thing, just a new name for an existing thing
05:20:17 <bourbaki> Ok the name should have given it away ;)
05:20:34 <bourbaki> Hm ok this get quite complicated in the long run though ...
05:20:52 <Peaker> bourbaki, the disadvantage of the newtype approach is the packing/unpacking you have to do.. there are workarounds for some of the pain involved (e.g: The Newtype class)
05:20:59 <bourbaki> My classes already are defined over Sum Double
05:21:10 <Peaker> bourbaki, "Sum" is another example of such a newtype, of course :)
05:21:11 <bourbaki> So it would be something like Foo Sum Double now...
05:21:20 <Peaker> Foo (Sum Double)
05:21:31 <bourbaki> Peaker: yes, hm this feels a bit limiting
05:21:33 <Peaker> bourbaki, that is, if "Foo" need sot be parameterized on the monoid
05:21:38 <Peaker> needs to*
05:21:56 <bourbaki> Why are instances global?
05:21:59 <Peaker> bourbaki, there are advantages to "global" instances -- you get some guarantees
05:22:16 <Peaker> bourbaki, for example, you know that all Maps of the same key will necessarily use the same ordinal relationship
05:22:22 <Peaker> bourbaki, so it's safe to merge them without any checks
05:22:32 <Peaker> bourbaki, (assuming same sorted order in the trees)
05:22:37 <bourbaki> Ok but it also has disadvantages :)
05:22:41 <Peaker> Indeed :)
05:22:44 <b__> window 3
05:23:00 <bourbaki> Hm hm hm
05:23:05 <Peaker> b__, that's a lot to type just to switch a window :)
05:23:40 <Peaker> bourbaki, you can use ordinary records with record passing when you want the "named" instances.. though that will be cumbersome.  Otherwise, you'll need to do some cumbersome packing/unpacking :)
05:23:53 <bourbaki> The problem i have with all this is that I always need to work on the types inside the classes.
05:23:59 <b___> Peaker: w autocompletes to window
05:24:10 <Peaker> bourbaki, but I think the newtype approach is good -- the pain of packing/unpacking can be hidden away
05:24:19 <bourbaki> I thought abou the record thing, then i would get the bad oo model again :)
05:24:46 <bourbaki> Peaker: I did that already for Sum and Product so i know now what i had to do.
05:25:01 <Peaker> bourbaki, Haskell98 type-classes are very similar to auto-passed records (with some Rank2 thrown in)
05:25:22 <bourbaki> Could i maybe make a new type class and build my instances on that?
05:25:31 <Peaker> bourbaki, not sure why you think one is a "bad OO model"?
05:25:51 <bourbaki> I mean if i had a record storing all the functions etc.
05:25:55 <Peaker> bourbaki, you could, but that would probably be bad -- all your code for one class will have to be duplicated for another?
05:26:06 <Peaker> bourbaki, you know how classes get translated into records?
05:26:09 <bourbaki> If you follow down that road completely i end up wich C++
05:26:32 <bourbaki> Functions are captured in modules so this should work.
05:27:00 <bourbaki> Peaker: Nope :)
05:27:07 <bourbaki> Im rather new to Haskell
05:27:22 <Peaker> bourbaki, if you have:  class Foo a where foo :: String -> Bar a
05:27:37 <quchen> Oh wow, I just realized that the Applicative instance for functions is precisely SK(I) calculus: pure == k, (<*>) == S. That explains why I don't understand the instance (or how to use it properly).
05:27:38 <Peaker> bourbaki, and:   f :: Foo a => a -> Boo
05:28:19 <Peaker> bourbaki, then you get something like:   data Foo_dict a = Foo_dict { foo :: String -> Bar a }
05:28:51 <Peaker> bourbaki, f :: Foo_dict a -> a -> Boo
05:28:57 <bourbaki> Peaker: Hm wait a second, f does reside in the modules space right?
05:29:04 <Peaker> bourbaki, this is the transformation done by the compiler
05:29:20 <shachaf> And by Peaker.
05:29:32 <Peaker> :)
05:29:49 <bourbaki> Puh
05:30:01 <Peaker> bourbaki, what do you mean "modules space"?
05:30:17 <Peaker> bourbaki, you mean outside the class? Then yes
05:30:26 <bourbaki> I mean when i have a module then an instance even if residing in that module is global
05:30:50 <bourbaki> When i have a function inside a module and import it qualified i can discern it with the name qualified?
05:31:08 <bourbaki> Cause if so i am willing to not use classes on functions.
05:31:32 <bourbaki> Er functions in classes, but use the functions in the module.
05:32:17 <bourbaki> Let me post my file sec.
05:32:39 <hpaste> bourbaki pasted “Flat.hs” at http://hpaste.org/79357
05:33:56 <bourbaki> As you can see warpping the inner type is rather tedious here.
05:50:09 <bourbaki> What was the problem in Haskell with naming instances?
05:50:25 <bourbaki> Or ia
05:50:27 <bourbaki> er  is
05:50:50 <quicksilver> allowing you to have multiple instances of the same class by naming them?
05:51:03 <bourbaki> Yep
05:51:04 <quicksilver> the problem is "why bother? if you want to do that, just don't use a typeclass"
05:51:28 <quicksilver> showA :: X -> String; showB :: X -> String;
05:51:35 <quicksilver> ^^ two instances of Show for type X.
05:52:00 <quicksilver> the utility of type classes is in automatic selection - if you want to select manually, just use data types.
05:52:01 <bourbaki> Yes but what if i want to say that you need the following constraints to use function xy.
05:52:12 <quicksilver> make them function parameters.
05:52:22 <bourbaki> The classes?
05:52:23 <quicksilver> xy :: (a -> String) -> a -> Blah
05:52:36 <quicksilver> ^^ xy expects a "Show instance " for a along with an a
05:53:19 <bourbaki> Hm... i am not sure if this is really what makes it better :)
05:53:48 <bourbaki> Eg dist :: MetricSpace v => v -> v -> v is something that seems ok.
05:54:24 <bourbaki> But then i would have to implement everything again where i use it since the instances needed there are not able to be named.
05:54:34 <quicksilver> does dist :: MetricSpace v -> v -> v -> v
05:54:37 <quicksilver> look worse to you?
05:54:48 <quicksilver> does that extra line on = vs - matter?
05:54:56 <bourbaki> No that would be ok, since i can obfuscate dist then.
05:55:01 <quicksilver> (in my example, MetricSpace is a data type, not a class)
05:55:16 <bourbaki> The problem is that the instances needed of MetricSpace will run into the orphan problem again.
05:56:12 <bourbaki> Beeing able to name classes would really delete this problem entirely and i would like to understand why this was not done.
05:56:22 <bourbaki> Guess there is a good reason why.
05:57:23 <quicksilver> I don't understand what the different between a named instances and just a piece of data.
05:57:25 <bourbaki> On the other hand i could make records that store the distance functions etc, maybe with type families or somesuch, but i think that i would end up with something like C++s object model and templates then
05:57:26 <quicksilver> is
05:57:37 <quicksilver> how is a value of type 'MetricSpace v' different from a named instance?
05:57:48 <quicksilver> except that it's simpler, and requires no extra language support.
05:57:49 <bourbaki> My problem is that i would like to have multiple instances of the same types.
05:57:54 <quicksilver> yes
05:58:01 <bourbaki> So if i would be able to have
05:58:01 <quicksilver> you can have multiple objects of type MetricSpace v
05:58:03 <quicksilver> it's just a type
05:58:09 <bourbaki> FlatSpace.innerProduct
05:58:12 <quicksilver> you can have as many values of that type as you want.
05:58:17 <bourbaki> and Torus.innerProduct
05:58:21 <bourbaki> Then it would be all ok.
05:58:27 <quicksilver> it is all ok.
05:58:31 <quicksilver> just forget about type classes
05:58:34 <quicksilver> never ever use typeclasses
05:58:34 <bourbaki> But instances are global, so this does not work.
05:58:42 <quicksilver> don't use type classes, don't use instances
05:58:49 <quicksilver> forget they ever existed
05:58:53 <quicksilver> they are not what you think they are
05:58:54 <bourbaki> Heh what is the use haskell then?
05:58:59 <quicksilver> just use data types.
05:59:11 <bourbaki> I mean classes are really nice there but also limiting there.
05:59:20 <quicksilver> Instead of "I want to maek the type 'x' an instance of MetricSpace'
05:59:27 <quicksilver> just have "a value of type MetricSpace x"
05:59:36 <quicksilver> then you don't have the global limit
05:59:39 <quicksilver> you can have as many as you want.
05:59:51 <bourbaki> That is what i said earlier, if you go down that road you end up with OO
05:59:56 <quicksilver> no, you don't.
06:00:06 <quicksilver> you just end up with a useful data structure and sensibel types.
06:00:08 <quicksilver> that is all.
06:00:13 <bourbaki> Well if i start storing functions in records.
06:00:16 <quicksilver> you don't have OO, you certainly dont' have broken C++ templates
06:00:26 <quicksilver> you just have nice data structures which happen to contain functions.
06:00:41 <bourbaki> Yeah but that is OOP :)
06:01:12 <bourbaki> Then you would think two days later that it would be nice to derive these objects.
06:01:15 <`ramses`> bourbaki: no, you don't have message dispatch
06:01:23 <bourbaki> Or have polymorphisom over them etc etc.
06:01:33 <quicksilver> honestly, it's not
06:01:41 <quicksilver> functions-in-data is really not OOP
06:01:47 <bourbaki> Anyway that is not what i want to do.
06:01:59 <quicksilver> from what you've explained so far, it appears to be exactly what you want to do.
06:02:12 <quicksilver> data like this is exactly "mulitple instances of the same class selected by name"
06:02:19 <quicksilver> except you don't pretend they are a typeclass, because they are
06:02:21 <quicksilver> n't
06:02:21 <bourbaki> No that is a solution to the problem at hand.
06:02:51 <bourbaki> But i want to know what the problem with the naming is, since this seems a really limiting issue.
06:03:01 <bourbaki> At least for any mathy structures.
06:03:38 <quicksilver> well I don't have time to explain it now, but yes, there is a problem
06:03:58 <quicksilver> and the solution is just not to use typeclasses since they have no advantages in this case.
06:04:00 <bourbaki> What is on the pro side of classes then? I think it is all the type inference and other sugar.
06:04:09 <quicksilver> typeclasses are for overloading
06:04:10 <quicksilver> that's all
06:04:17 <quicksilver> they're not an abstraction, they're not a way to write programs
06:04:26 <quicksilver> they're just a neat way to get regimented polymorphic overloads
06:04:26 <bourbaki> I want the constraint.
06:04:46 <bourbaki> I want to be able to say that if you want to use this function you need to make sure that there are these structures defined.
06:05:41 <quicksilver> yes, and you can do that by passing the definition of the structure
06:05:42 <bourbaki> Can anyone else comment on this also please, not using classes as a solution to this problem makes me cringe...
06:05:58 <bourbaki> Other packages like vector-space use classes also.
06:05:58 <quicksilver> passing the structure definition is exactly like choosing a named instance, isn't it?
06:06:08 <quicksilver> it's a way of selecting the one you want.
06:06:25 <bourbaki> Ok so then i would also add a factory?
06:06:37 <bourbaki> To instanciate the object etc?
06:07:20 <bourbaki> To me this still smells like old wine in new flasks and not very fpish, then i could just use Scala or F#.
06:07:39 <Botje> such a 'factory' would be called a 'smart constructor'
06:07:46 <bourbaki> Ah ok
06:07:59 <Botje> which is a fancy synonym for 'function'
06:08:06 <bourbaki> So this is a common idiom to solve the problem?
06:08:32 <Botje> I didn't follow the discussion on your problem.
06:08:34 <bourbaki> I mean wrapping everything into data.
06:08:56 <bourbaki> My problem is multiple instances and instance orphanage.
06:09:40 <Botje> are you absolutely sure you want objects for that, instead of higher-order function?
06:09:42 <bourbaki> I am neither inclined to wrap my inner types into a newtype nor do i really like the idea of wrapping all my functions into other objects.
06:10:08 <bourbaki> Well what i want to do is define a basis of mathematical structures.
06:10:24 <bourbaki> So i stared out with nands help and definded some classes.
06:10:47 <bourbaki> Now i have instances of these classes and want to have for example different instances of a MetricSpace
06:10:55 <bourbaki> one for flat spaces one for tori etc.
06:11:06 <bourbaki> Since the instances are global though this does not work.
06:11:54 <bourbaki> And although i am aware that what quicksilver proposes is a valid solution i think that it is kind of a bleh approach in fp.
06:12:16 <Botje> well, type classes are only there to do polymorphism. they are not supposed to be used like objects
06:12:36 <typoclass> bourbaki: how do you mean, it does not work? the instances overlap?
06:12:50 <bourbaki> typoclass: The instances are over the same types.
06:13:18 <typoclass> bourbaki: and yes, what Botje says, it's usually not a good idea to try to do everything through typeclasses
06:13:58 <bourbaki> Ok but wrapping the mathematical structures into objects does not seem to be fancy at all.
06:14:18 <typoclass> bourbaki: by 'objects' you mean newtypes?
06:14:22 <bourbaki> And i am totally convinced that if you follow that approach completely then you get MOP or CLOS.
06:14:27 <bourbaki> Yes.
06:14:57 <bourbaki> I mean object that has a distance, innerProduct etc does the job
06:14:59 <Philippa_> bourbaki: you get a nice version of MLish modules en route
06:15:11 <bourbaki> Philippa_: Uh?
06:15:58 <Philippa_> bourbaki: typeclasses and ML's modules are closely related. ML's modules offer a mid-point that you might or might not build a MOP-alike on top of
06:16:12 <bourbaki> I mean in the end you end up with something like vectorSpace.dist x y ...
06:16:19 <Philippa_> (then you might or might not reify structures as individual values)
06:16:35 <Philippa_> yeah. And you /don't/ do single inheritance
06:17:06 <bourbaki> What is the problem with named instances then?
06:17:11 <`ramses`> bourbaki: I think you should not be talking about objects because that's just confusing, haskell does not have objects
06:17:24 <bourbaki> I mean to me that seems like the resolution to this problem.
06:17:37 <bourbaki> Ok then newtypes :) ?
06:17:46 <Philippa_> the problem with named instances is that people have to think about how to separate them from unnamed ones - because the unnamed ones have a 1:1 type:instance mapping
06:18:00 <Philippa_> (and Haskell really, really assumes it can lean on that)
06:18:27 <Philippa_> it might be nice to experiment with named modules as a separate sort of constraint though
06:18:28 <bourbaki> Ok but if the solution to a problem this common is then to not use typeclasses what are they good for then?
06:18:38 <Philippa_> making people rant in here :-)
06:18:42 <bourbaki> That is what i mean to be more precise.
06:18:52 <`ramses`> bourbaki: overloading, as said before
06:19:00 <Philippa_> (personally I'm of the "if the system's that big, go ahead and use them" POV, give or take thinking a bit about the appropriate discipline - I'm not of the "go OO" POV)
06:19:04 <bourbaki> I would be totally ok to address the instance through the module name.
06:19:23 <Philippa_> *nod*. So long as the types say it's an instance of some class
06:19:51 <bourbaki> ramses but is also is a way to ensure structure, which is what i want there.
06:20:01 <typoclass> bourbaki: typeclasses aren't really "the central fundamental part" of haskell that needs to be used at every turn :-) it's a common misunderstanding, coming from other languages
06:20:09 <bourbaki> With the typeclass i ensure that the types are governed by these functions.
06:20:17 <Philippa_> typoclass: bourbaki isn't a newbie, FWIW!
06:20:34 <typoclass> Philippa_: ok thanks for the heads-up
06:20:40 <Philippa_> (I think typeclasses are the most important 'new thing' in Haskell, though)
06:20:51 <bourbaki> FWIW? And i am kind of a newbie again did not do Haskell for some years.
06:20:59 <Philippa_> For What It's Worth
06:20:59 <strebe> for what it's worth
06:21:03 <bourbaki> Ah
06:21:23 <Philippa_> *nod*. Even as a renewbie I attribute you with some brains, though
06:21:34 <bourbaki> :) heh thanks
06:22:07 <bourbaki> Is there anything like MOP for Haskell btw?
06:22:30 <Philippa_> hmm. I've not seen anyone actually build one myself, no
06:23:02 <Philippa_> I do really, really wish we had "full" reflection on datatypes :-( But only if you do it the hard way via Template Haskell
06:23:16 <Philippa_> (I may have to write some TH code for a library I'm working on, it annoys me)
06:23:23 <bourbaki> I wonder if the guys working on vector-space and these other packages encounter similar problems and thoughs.
06:23:24 <Philippa_> (well, "have". It's that or painful duplication)
06:23:29 <Philippa_> probably!
06:23:47 <Philippa_> it's the sort of thing that comes up in here once in a while - I think you've just picked the wrong time of day for a good convo about it
06:23:52 <Philippa_> (talking of which, I'll have to head out soon)
06:23:54 <bourbaki> Is it hard to work on the compiler to get an extension like that?
06:24:08 <Philippa_> dunno - never did try patching GHC myself in the end!
06:24:22 <bourbaki> Well ill try to pitch the problem later maybe.
06:24:43 <bourbaki> I have a 3 weeks vacation and would like to port some of my differential geometry stuff.
06:29:23 <typoclass> bourbaki: i'm not sure i could even contribute usefully to your discussion, but maybe you could make a hpaste to introduce the players? "function foo, function bar with such-and-such signatures are supposed to work on all instances of MetricSpace, of which i have these 2 instances", etc.
06:29:50 <bourbaki> typoclass: Sure
06:30:10 <bourbaki> It is seperated in two files now though, which caused the initial problem
06:30:25 <bourbaki> The orphaned instance incident :)
06:31:16 <hpaste> bourbaki pasted “foofoo” at http://hpaste.org/79363
06:33:57 <quchen> @pf (f.g)
06:33:58 <lambdabot> Maybe you meant: bf pl
06:34:29 <`ramses`> \x -> f (g x)  ?
06:37:49 <benmachine> would appreciate if someone could help me with http://stackoverflow.com/q/13914500/812053 - "Does {-# OPTIONS_HADDOCK hide #-} have any effect on non-exported modules?"
06:38:08 <benmachine> I suspect it does not, but I'm unsure
06:39:23 <killy9999> is there any reasonable way to work around the fact that GHCi clears all declared variables when reloading a source file?
06:40:10 <typoclass> killy9999: put the definitions in the file?
06:40:11 <killy9999> I'm tired of re-running all let declarations every time I want to test my changed sources...
06:40:49 <killy9999> typoclass: but if I run these definitions from a file won't ghci unload the module I want to test? :>
06:40:55 <`ramses`> killy9999: I often make an extra file containing test data, let it import the file I'm testing and then load the first file in ghci
06:41:08 <killy9999> hm...
06:41:21 <killy9999> import you say... haven't thought abou that
06:41:44 <`ramses`> but there may exist a better option still that I'm not aware of either
06:42:09 <typoclass> killy9999: i meant, the file that you're working on and that you're reloading. you could put some extra definitions in there. if they're just for development, you can remove them later
06:42:54 <fmap> typoclass: file may not have all needed imports :[
06:43:37 <killy9999> typoclass: I'd rather not. It's easy to forget about such things and leave them in the sources...
06:43:54 <killy9999> I'm trying out `ramses`'s solution
06:44:37 <typoclass> fmap: right, but you can add those imports as well :-) you don't even need to put a "-- TODO" marker on the imports, because you'll get warnings later about unused imports
06:45:55 <wuttf> is there a function like this:    "hello" =>  [ "h", "he", "hel", "hell", "hello"]
06:46:05 <opqdonut> inits
06:46:11 <opqdonut> > inits "hello"
06:46:12 <lambdabot>   ["","h","he","hel","hell","hello"]
06:46:24 <wuttf> opqdonut: Neat, thanks.
06:46:27 <`ramses`> so tail . inits ;)
06:46:28 <typoclass> > tail $ inits "hello"
06:46:30 <lambdabot>   ["h","he","hel","hell","hello"]
06:46:33 <typoclass> ;-)
06:47:07 <wuttf> :D
06:47:14 <wuttf> I thought of filtering it
06:47:18 <wuttf> :D
06:48:00 <typoclass> wuttf: i guess in this case, filtering is basically the same thing
06:48:45 <wuttf> typoclass: I guess filtering is inefficient compared to tail, assuming no optimizations by GHC
06:50:06 <typoclass> wuttf: oh, i wouldn't worry about that :-) until you have confirmed via profiling that it is a significant bottleneck
06:51:09 <wuttf> typoclass: Yea, I have an embedded/ASM/C/C++ background :D. Old habits die hard.
07:04:06 <wuttf> Are exceptions idiomatic/often used?
07:04:37 <wuttf> I still can't decide on what kind of error handling to use.
07:04:56 <shachaf> Depends on what you're doing.
07:06:17 <wuttf> For example, I am building an app where people can construct timetables, if somebody gives inputs an interval "12:00-8:00" which is invalide
07:06:18 <wuttf> what to do?
07:07:12 <typoclass> wuttf: i'd probably use Either. the Left would hold an error message for display to the user, the Right would hold a correct, parsed interval
07:08:22 <typoclass> wuttf: but yeah, there's usually several plausible options
07:09:42 <blueonyx> wuttf: i just use exception in IO, mostly Maybe and Either for custom error handling, although error monads can be neat too
07:10:08 <hugli> Can I somehow use Text.printf with a tamplate and a tuple?  e.g. ``printf "name: %s\nage: %d" ("hugli", 6)''
07:10:33 <wuttf> typoclass: That is the closes to my thingking too, but after spending a year in Go I am seriously considering exceptions as the sanest way to error handling, 90% of the time its a PITA to check for values indicating errors.
07:10:38 <shachaf> hugli: It won't take a tuple.
07:11:22 <wuttf> Imagine divison giving back an Either monad, would that be a PITA
07:11:31 <blueonyx> not in the either monad
07:11:47 <benmachine> hugli: uncurry (printf fmt)?
07:11:52 <`nand`> ^
07:12:04 <`ramses`> wuttf: then you change function application in (>>=) and (<$>) :)
07:12:15 <benmachine> hugli: works for two parameters but not more
07:12:21 <blueonyx> but which exceptions are sane? i have more trouble with them compared to pure data structures
07:12:31 <hugli> shachaf: I found that. I'm looking for a shortcut to printf template (t !! 0) (t !! 1) &c.
07:12:39 <S11001001> wuttf: you don't check, you lift your operations
07:12:46 <`nand`> > uncurry3 (printf "foo %s bar %d bat %d") ("frob", 4, 2) :: String
07:12:46 <S11001001> wuttf: as `ramses` says
07:12:48 <lambdabot>   Not in scope: `uncurry3'
07:12:48 <lambdabot>  Perhaps you meant `uncurry' (imported from Data.T...
07:12:53 <`nand`> ah, that doesn't exist?
07:12:56 <typoclass> wuttf: right. an Either monad is probably an improvement over a plain Either if you have a long chain of functions with something like "if it's Left, bail out, if it's Right, then we go on with the next function in the chain, which again gives back a Left or a Right"
07:12:59 <eacameron> Everyone always tells me to use Data.Text for text but I keep seeing ByteString in places I would expect to see Text. Maybe I'm just confused. Why does Aeson use ByteStrings for JSON? I thought JSON was a plain-text format.
07:13:16 <wuttf> I have read about that lifting yesterday but I can't comprehend it yet, S11001001 `ramses`
07:13:36 <fmap> eacameron: for speed I guess
07:13:47 <fmap> i.e. it parses jsons with attoparsec anyway
07:13:55 <`ramses`> wuttf: given a monad, it performs the function inside the monad, instead of applying something to the monad
07:13:57 <S11001001> opThatWontFail <$> valueThatMightVail, wuttf, or valueThatMightFail >>= opThatMightFail
07:14:04 <benmachine> hugli: have you considered not using printf but just pattern-matching on the list and assembling a string with the values?
07:14:26 <`ramses`> S11001001: (=<<) would make it more symmetric ;)
07:14:44 <alpounet> eacameron, you can convert back and forth with Data.Text.Encoding's decodeUtf8 and encodeUtf8 (it doesn't answer your question, right)
07:14:44 <benmachine> hugli: I find I very rarely use printf, more often I just use concat [list, of, strings]
07:15:29 <`ramses`> > liftM (+3) (Right 4) :: Either String Int
07:15:31 <lambdabot>   Right 7
07:15:32 <S11001001> wuttf: in these arrangements, <$> and, as `ramses` says, =<<, do the checking for you, and they can't accidentally flip the condition or other similar errors.  Error recovery is also possible with `mplus` (supposing an appropriate instance)
07:15:42 <`ramses`> > liftM (+3) (Left "error") :: Either String Int
07:15:44 <lambdabot>   Left "error"
07:15:53 <wuttf> `ramses`: S11001001  So you say I can get around the awful error checking? I can't understand that stuff you told yet but I will take your word for it.
07:16:09 <`ramses`> wuttf: yes, that's what monads are about!
07:16:15 <blueonyx> S11001001: what do you do if you have a longer chain with different types (eg Int -> String -> [String])
07:16:25 <eacameron> fmap: is ByteString faster than Text then?
07:16:27 <S11001001> wuttf: it's not so much "getting around" a real problem as it is that languages without these facilities are lacking
07:16:28 <`ramses`> blueonyx: keep on chaining
07:16:37 <eacameron> alpounet: ahh...good to know
07:16:59 <benmachine> S11001001: do-notation can be helpful in those cases
07:17:22 <fmap> eacameron: I assume parsing byte stream is faster than parsing Text, yes
07:17:29 <`ramses`> > Right 4 >>= \x -> Right x +2 >>= \x -> Right . replicate 3 :: Either String [Int]
07:17:29 <S11001001> benmachine: I'm not a fan anyway
07:17:31 <lambdabot>   Couldn't match expected type `[GHC.Types.Int]'
07:17:31 <lambdabot>              with actual typ...
07:17:37 <alpounet> eacameron, aeson maybe uses bytestring because you quite often get your json data from the network, and you tend to send/receive bytestrings through the network
07:17:45 <hugli> benmachine: concat will do for me. thanks (Python user starting with Haskell. two weeks so far)
07:17:58 <benmachine> S11001001: I might have meant to say that to blueonyx
07:18:02 <`ramses`> > Right 4 >>= \x -> Right (x + 2) >>= \x -> Right . replicate 3 $ x :: Either String [Int]
07:18:04 <lambdabot>   Right [6,6,6]
07:18:06 <blueonyx> `ramses`: but i want meaningful errors from the different stages :/
07:18:07 <eacameron> alpounet: that makes sense
07:18:15 <blueonyx> ah k
07:18:20 <`ramses`> blueonyx: you'll get the first error encountered
07:18:29 <blueonyx> yea
07:18:31 <alpounet> eacameron, err, wait! http://hackage.haskell.org/packages/archive/aeson/0.6.0.2/doc/html/Data-Aeson.html
07:18:35 <`ramses`> > Right 4 >>= \x -> Left "error" >>= \x -> Right . replicate 3 $ x :: Either String [Int]
07:18:37 <lambdabot>   Left "error"
07:18:49 <alpounet> see the Value type there? the constructor with String uses Text
07:19:02 <alpounet> Object also uses Text
07:19:11 <wuttf> Thats neat, I will keep on learning haskell then S11001001, `ramses`. For the time being I think I will go with exceptions (error), because I have to finish this job :-D. (Yes, I actually intended to learn haskell while coding a project with a near deadline)
07:19:30 <`ramses`> wuttf: brave ;)
07:19:34 <alpounet> eacameron, so basically it's only about encode/decode here, and I guess it's for receiving/sending through the network or stuffs like that that it uses bytestring
07:19:51 <eacameron> alpounet: very enlightening thank you
07:19:59 <benmachine> wuttf: using error is not too bad if you don't intend to recover from it
07:20:09 <eacameron> That leads me to another question. I've been trying to gain an intuition for what the Typeable class is for
07:20:12 <benmachine> especially in prototyping
07:20:13 <eacameron> I don't understand it!
07:20:46 <benmachine> eacameron: the main use of it is in combination with the evil of unsafeCoerce
07:20:46 <`ramses`> wuttf: maybe you should at least like at functor if you have the time
07:20:49 <Saizan> ?type cast
07:20:51 <lambdabot> (Typeable b, Typeable a) => a -> Maybe b
07:20:57 <`ramses`> wuttf: and use that with either
07:21:02 <Saizan> that's the main point ^^^
07:21:12 <wuttf> Since its a web app I wont care, input will be checked on frontend by JS, and if somebody POSTS exotic data then I will just let that HTTP connection blow up
07:21:28 <`ramses`> ah, sounds reasonable :)
07:22:02 <`ramses`> just wondering, what web framework are you using?
07:22:43 <osfameron> "unsafeCoerce" is a near anagram of "son of scarface"
07:22:48 <eacameron> benmachine: I see it also in conjunction with DataTypeDerivable or something like that
07:22:52 <eacameron> what is that for?
07:23:16 <benmachine> eacameron: DeriveDataTypeable just allows you to write Typeable instances safely and conveniently
07:23:31 <benmachine> (and also Data instances)
07:23:37 <eacameron> benmachine: but that what I don't understand, why would you want to?
07:23:38 <wuttf> Nothing yet :-D. I am reading the Snap documentation. TBH these frameworks are even harder to grasp than Haskell itself but hey
07:23:59 <wuttf> `ramses:
07:24:08 <benmachine> eacameron: so that you could use cast, as Saizan pointed out, and the entire generics/syb framework, which is based on those two classes
07:25:13 <benmachine> eacameron: basically Typeable gives you a way to specify behaviour based on runtime inspection of a type, a sort of reflection, while Data gives you even more than that – you can at runtime get hold of constructors for a value and deconstruct it
07:25:41 <killy9999> what do I do with literate haskell sources? can I compile them with latex to pdf??
07:26:24 <eacameron> benmachine: yikes...that sounds "unhaskell-like"
07:26:48 <benmachine> eacameron: weeeeelll, yes and no
07:27:05 <benmachine> it may involve a lot of runtime errors, but it's a huge abstraction
07:27:09 <eacameron> benmachine: law of non-contradiction exploding in my brain ;)
07:27:27 <benmachine> and imo, lightweight abstraction is a key part of what makes Haskell so great
07:28:01 <benmachine> as an example of what generics can give you, "mkQ False (== x)" will tell you if a list contains x
07:28:03 <eacameron> benmachine: I think I get it...from what I was reading Typeable is a way of "abstracting" the idea of Types from with Haskell itself
07:28:13 <benmachine> it will also tell you if a tuple contains x, or a Maybe
07:28:18 <benmachine> or a list containing tuples of Maybes
07:28:21 <S11001001> > head [3, error "oops"] -- wuttf: in that case, just keep in mind that if you don't "use" an error, it won't actually be "thrown".  Like so
07:28:22 <lambdabot>   3
07:29:00 <S11001001> > length [3, error "oops"]
07:29:02 <lambdabot>   2
07:29:11 <benmachine> > mkQ False (== 'a') "hello"
07:29:13 <lambdabot>   Not in scope: `mkQ'
07:29:17 <benmachine> oh :(
07:29:38 <benmachine> :t gmapQ
07:29:40 <lambdabot> Not in scope: `gmapQ'
07:30:00 <benmachine> oh no my example was wrong
07:30:20 <wuttf> S11001001: Lazyness again? :)
07:30:22 <eacameron> benmachine: WEIRD! that seems like it bypasses the type system completely
07:30:25 <benmachine> "gmapQ (mkQ False (== x))"
07:30:38 <S11001001> wuttf: right
07:30:40 <benmachine> eacameron: it doesn't! it just uses type classes to always know how to look inside things
07:30:59 <eacameron> benmachine: so each instance of Typeable tells how to answer mkQ, etc?
07:31:22 <benmachine> eacameron: well, the magic is cast :: (Typeable a, Typeable b) => a -> Maybe b
07:32:02 <eacameron> eacameron: which isn't as evil as unsafeCoerce, I assume?
07:32:08 <benmachine> eacameron: what Typeable gives you is the ability to turn a function, say, Integer -> Bool, to a function (Typeable a) => a -> Bool, that answers False on anything that's not an integer
07:32:08 <eacameron> *benmachine: ^^
07:32:30 <merijn> eacameron: cast is typesafe, it will only work if a and b are the same :p
07:32:30 <benmachine> eacameron: right, because /as long as your Typeable instances are correct/, it only returns Just when the types really are the same
07:32:48 <benmachine> eacameron: it's a /bit/ evil because if the Typeable instance lies it all goes horribly wrong
07:32:57 <merijn> :t cast
07:32:58 <lambdabot> (Typeable b, Typeable a) => a -> Maybe b
07:33:13 <benmachine> eacameron: I've been told there IS a safe way of implementing cast that doesn't have that problem, but I don't know what it is
07:33:22 <merijn> :t let eq a b = Just a == cast b in eq
07:33:23 <eacameron> benmachine: haha got it: but Haskell never promises that hte programmer won't like (like for the Functor laws)
07:33:23 <lambdabot> (Eq a, Typeable a1, Typeable a) => a -> a1 -> Bool
07:33:34 <merijn> :t let eq a b = Just a == cast b in eq 1 'a'
07:33:35 <lambdabot> Bool
07:33:40 <merijn> > let eq a b = Just a == cast b in eq 1 'a'
07:33:42 <lambdabot>   False
07:33:44 <merijn> > let eq a b = Just a == cast b in eq 1 1
07:33:45 <benmachine> eacameron: Typeable is worse than Functor, though, because a lying Typeable instance effectively gives you unsafeCoerce
07:33:45 <eacameron> * benmachine: won't lie
07:33:46 <lambdabot>   True
07:34:03 <saml> hey, give me a short program that makes ghc not halt
07:34:18 <benmachine> eacameron: with Safe Haskell enabled, you can't write Typeable instances, you can only derive them
07:34:23 <merijn> eacameron: Correct
07:34:51 <benmachine> saml: sec, I submitted a bug like that which hasn't been fixed yet
07:34:58 <benmachine> saml: http://hackage.haskell.org/trac/ghc/ticket/5722
07:35:25 <saml> benmachine, thanks. is thre a website that has short programs that makes various compilers not halt?
07:35:43 <benmachine> saml: I've no idea, seems like an odd sort of thing to put on a website :P
07:35:54 <luite> ! LaTeX Error: \mathit allowed only in math mode. <- has anyone seen this when running latex produced by lhs2tex?
07:36:20 <merijn> luite: Means someone didn't write valid LaTeX :)
07:37:06 <benmachine> eacameron: anyway, Typeable becomes cooler when used in combination with Data; Data gives all that generic-traversal stuff I was talking about
07:37:21 <benmachine> unfortunately lb seemingly hasn't got it imported
07:37:55 <luite> merijn: yes it produces some code that uses mathit when not in math mode, but i'm not sure what's wrong
07:38:08 <luite> a simple standalone example works fine
07:38:33 <nomeata> Hi. Is there really no easy way to export a gloss drawing as an image, preferably vector image, besides taking screenshots?
07:38:52 <neutrino_> nomeata: what is a gloss drawing?
07:39:09 <typoclass> neutrino_: drawing made with the gloss library ...
07:39:11 <nomeata> neutrino_: a value of type Picture, http://hackage.haskell.org/package/gloss
07:39:23 <neutrino_> oh
07:40:11 <eacameron> benmachine: lb?
07:40:16 <benmachine> eacameron: lambdabot, I meant
07:40:23 <eacameron> benmachine: ahh
07:40:39 <eacameron> benmachine: well that is very helpful...I am wiser now
07:40:48 <neutrino_> hi benmachine
07:40:55 <benmachine> eacameron: let anyA thing = everything (||) (mkQ False (== 'a')) thing in (anyA "hello", anyA "hallo", anyA (Just (True, 'a')))
07:41:02 <benmachine> neutrino_: hi?
07:41:54 <benmachine> eacameron: that with Generics.SYB imported
07:43:28 <wuttf> Do you think Haskell can increase math skills, my little brother is a math/physics guy and I am thinking about teaching Haskell to him.
07:43:44 <wuttf> (AFTER I grasp it myself of course)
07:43:54 <benmachine> wuttf: it's possible, but it would probably be far more effective just to teach maths :P
07:43:56 <Clint> @faq can haskell increase math skills?
07:43:57 <lambdabot> The answer is: Yes! Haskell can do that.
07:44:25 <wuttf> @faq can haskel asdas asdasdasdasd
07:44:26 <lambdabot> The answer is: Yes! Haskell can do that.
07:44:31 <wuttf> hahaha, very funny
07:45:08 <`ramses> wuttf: I don't think he'll learn much maths from it, but it might appeal to him
07:45:18 <`ramses> it did to me as a theoretical physicist
07:47:04 <wuttf> It can't hurt I guess.
07:47:33 <`ramses> not literally ;)
07:48:10 <tcrayford> I don't know, haskell is being used at a company that does nuclear reactor stuff, so it could kill, at least in theory
07:48:12 <wuttf> :D
07:48:26 <wuttf> tcrayford: Is that for real?
07:48:37 <tcrayford> I think so
07:48:42 <Adeon> what about haskell programmed robots? couldn't those literally hit you
07:48:47 <tcrayford> they were hiring on the haskell subreddit recently
07:49:07 <benmachine> tcrayford: in fairness, people sometimes hire haskellers without getting them to do haskell
07:49:33 <benmachine> tcrayford: all of the functional languages share recruits, because there aren't too many of them :P
07:49:51 <`ramses> from that point of view, many programming languages could be lethal
07:49:58 <wuttf> tcrayford: I guess they appreciate purity      func randomNumber() int  { detonateReactor(); return 4 }
07:50:33 <`ramses> unless detonateReactor uses unsafePerformIO
07:50:41 <wuttf> `ramses: :D
07:51:25 <merijn> `ramses: Like FORTRAN 77...
07:52:40 <`ramses> merijn: I guess I'm lucky never to have touched fortran before :) I will have to in a couple of months however, not looking forward to that
07:53:01 <merijn> New FORTRAN is not that bad, but old FORTRAN :p
07:53:39 <`ramses> ah, ok, then I might be ok :) I don't know anything about it but I've seen many rants
07:55:42 <merijn> `ramses: Well, you were doing physics, right? At least FORTRAN has proper multi-dimensional array support. That's not something you can say about C...
07:55:49 <wuttf> sorry for asking so much but how can I flattern a [[String]] into a [String]
07:55:58 <wuttf> flatten*
07:55:58 <`ramses> wuttf: concat
07:56:05 <elliott> @hoogle concat
07:56:06 <lambdabot> Prelude concat :: [[a]] -> [a]
07:56:06 <lambdabot> Data.List concat :: [[a]] -> [a]
07:56:06 <lambdabot> Prelude concatMap :: (a -> [b]) -> [a] -> [b]
07:56:09 <elliott> @hoogle [[String]] -> [String]
07:56:10 <lambdabot> Prelude unlines :: [String] -> String
07:56:10 <lambdabot> Data.List unlines :: [String] -> String
07:56:10 <lambdabot> Data.String unlines :: [String] -> String
07:56:12 <elliott> bah
07:56:18 <elliott> @hoogle [[a]] -> [a]
07:56:18 <`ramses> merijn: I have a degree in physics but I'm in computer science now :)
07:56:18 <lambdabot> Prelude concat :: [[a]] -> [a]
07:56:18 <lambdabot> Data.List concat :: [[a]] -> [a]
07:56:19 <lambdabot> Data.List intercalate :: [a] -> [[a]] -> [a]
07:56:28 <wuttf> ty
07:56:59 <`ramses> merijn: all computational physics stuff that I've done was either matlab, maple or plain C
07:58:08 <mreh> what's the strategy of including c source files into a haskell program for marshalling?
07:58:38 <mreh> I'm trying to develop an application that uses a drop in c source file for an application key
07:59:03 <mreh> it's a thirdparty lib so I have little control over the format of the key
07:59:12 <merijn> mreh: I have an example with some C files, maybe that helps?
07:59:23 <mreh> yes please
07:59:42 <merijn> mreh: https://github.com/merijn/SNet2.0/tree/master/SNet/Interfaces
07:59:59 <merijn> mreh: Also take a look at the cabal file, which compiles them, it's not that hard, fortunately
08:05:38 <mreh> merijn: thanks :)
08:06:03 <mreh> google is pretty poor at finding the phrase "c source files"
08:06:13 <mreh> despite  it being there in the cabal docs
08:08:17 <`ramses> mreh: did you quote it? otherwise google ignores single letter words
08:09:14 <mreh> `ramses: no
08:09:19 <mreh> my downfall
08:15:06 <pqmodn> is their a concise way to write do { x' <- x; y' <- y; f x' y' } where f :: a -> a -> m a, x :: m a, y :: m a?
08:15:23 <sipa> liftM2 f
08:15:32 <tcrayfor> from Control.Monad
08:16:02 <pqmodn> oh, of course
08:19:54 <pqmodn> wait, no. f is not pure -- liftM2 f would yield m (m a)
08:20:07 <pqmodn> join $ liftM2 f works, i suppose
08:21:54 <`ramses> @hoogle (Monad m) => (a -> b -> m c) -> m a -> m b -> m c
08:21:55 <lambdabot> Control.Monad zipWithM :: Monad m => (a -> b -> m c) -> [a] -> [b] -> m [c]
08:21:55 <lambdabot> Control.Monad zipWithM_ :: Monad m => (a -> b -> m c) -> [a] -> [b] -> m ()
08:21:55 <lambdabot> Control.Monad foldM :: Monad m => (a -> b -> m a) -> a -> [b] -> m a
08:22:07 <tdammers> :t f <$> x <*> y
08:22:09 <lambdabot>     Couldn't match expected type `f0 a0' with actual type `Expr'
08:22:09 <lambdabot>     In the second argument of `(<$>)', namely `x'
08:22:09 <lambdabot>     In the first argument of `(<*>)', namely `f <$> x'
08:22:35 <`ramses> tdammers: that might require some WrappedMonad foo
08:22:45 <tdammers> mhm
08:25:32 <tcrayfor> well, you can just extract that out as a function yourself, right?
08:26:04 <pqmodn> sure, you mean helper = join . liftM2?
08:26:17 <tcrayfor> yeah
08:26:41 <tcrayfor> I bet category theory has a name for that function ;)
08:29:40 <tcrayfor> I often do that in the middle of coding, just extract out the pattern I want to reuse, and then hoogle it later
08:30:15 <tcrayfor> my git commit hook fails if it finds any TOHOOGLE comments in the diff ;)
08:30:52 <mreh> is it safe to marshall size_t to an Int? Seeing as Foreign.Storable.sizeOf returns one.
08:31:08 <mreh> I keep getting segfaults when trying
08:31:10 <benmachine> pqmodn: join . liftM2 doesn't look right to me
08:31:33 <benmachine> pqmodn: you want \f x y -> join (liftM2 f x y), not \f x y -> join (liftM2 f) x y
08:31:45 <pqmodn> right
08:32:07 <crdueck> :t (join .) . liftM2
08:32:08 <lambdabot>     Occurs check: cannot construct the infinite type:
08:32:08 <lambdabot>       m0 = (->) (m0 a20)
08:32:09 <lambdabot>     Expected type: (a10 -> a20 -> a0)
08:32:27 <benmachine> crdueck: unfortunately even that isn't right, I'd stick with the explicit lambda
08:32:55 <benmachine> :t fmap fmap fmap join . liftM2 -- <_<
08:32:56 <lambdabot> Monad m => (a1 -> a2 -> m a) -> m a1 -> m a2 -> m a
08:33:21 <mreh> oh, CSize
08:33:24 <pqmodn> i hereby call thee applyM2
08:33:46 <pqmodn> wish there was a way to generalize to Applicatives instead
08:33:52 <benmachine> pqmodn: I personally wouldn't, that brings to mind "ap" which this function isn't
08:34:12 <latro`a> @pl \f x y -> g (h f) x y
08:34:12 <lambdabot> g . h
08:34:21 <latro`a> er
08:34:23 <benmachine> pqmodn: generally speaking if you have a -> m b things in the typesig, it genuinely is monad-only
08:34:27 <latro`a> @pl \f x y -> g (h f x y)
08:34:27 <lambdabot> ((g .) .) . h
08:34:33 <latro`a> ah
08:35:04 <benmachine> :t result
08:35:06 <lambdabot>     Not in scope: `result'
08:35:06 <lambdabot>     Perhaps you meant `resultAt' (imported from Control.Lens)
08:35:26 <benmachine> @let result = (.)
08:35:28 <lambdabot>  Defined.
08:35:39 <benmachine> :t (result.result.result) join liftM2
08:35:40 <lambdabot> Monad m => (a1 -> a2 -> m a) -> m a1 -> m a2 -> m a
08:36:04 <latro`a> 5 fmaps because why the hell not
08:36:04 <benmachine> that says "do join on the result of the result of the result of liftM2"
08:37:11 <guttypi> How do I know what exceptions to look for? I'm writing a program that does simple IO, using writeFile for example. How do I know what exceptions to look for? The docs don't say which exceptions I need to catch. I'm coming from a Java background and it's funny that the one side effect that Java does include in the type system, exceptions, Haskell does not!
08:37:41 <latro`a> haskell's exceptions are in the type system
08:37:42 <latro`a> sort of
08:38:23 <benmachine> guttypi: it's /possible/ to put exceptions in the type system in Haskell, unfortunately most libraries don't
08:38:40 <guttypi> If I'm doing some real world programming, what error handling do I need around a call like writeFile?
08:38:49 <c_wraith> IOException
08:38:52 <c_wraith> in nearly all cases
08:38:57 <eikke> are exceptions encoded in the type system in Java? I'd think that info is bound to methods, which aren't represented by some type as-is, iirc (although I'm not very much into Java :) )
08:39:03 <benmachine> guttypi: see also http://hackage.haskell.org/package/explicit-exception
08:39:28 <benmachine> eikke: well, you can tell from the signature of a method which exceptions to expect
08:39:36 <guttypi> eikke: it's weak, but it's the only side effect that java even notes
08:39:39 <eikke> non-runtime exception that is
08:40:30 <guttypi> Ok, but ignoring possibilities for the moment, I just have to catch any kind of IOException for a call like writeFile?
08:40:51 <mreh> calling a binding to a C const seems to cause a segfault
08:40:56 <benmachine> guttypi: oops, that was the wrong link
08:41:15 <c_wraith> guttypi: there aren't multiple kinds of IOException.
08:42:12 <benmachine> c_wraith: there are in a way, cf. isDoesNotExistError
08:43:05 <c_wraith> Well, there are multiple fields, one of which is an IOErrorType enum - but it's still just one type
08:43:27 <benmachine> guttypi: this is the lirbary I meant to link you to (although it doesn't really help you, just might interest you) http://hackage.haskell.org/package/control-monad-exception
08:43:45 <benmachine> c_wraith: sure, there's one *type* of IO exception, but there are multiple *varieties* of IO exception
08:58:24 <dgpratt> if I already have two versions of the Foo package installed, and I try to install package Bar, which could be built against any version of Foo, what determines which version of Foo that will be used?
09:00:22 <elliott> dgpratt: it picks the one most likely to break your system
09:00:29 <dgpratt> elliott: ah
09:00:49 <dgpratt> elliott: is there a way to override its judgement?
09:01:00 <elliott> --constraint should work I think
09:01:02 <benmachine> dgpratt: if you're talking about cabal-install, I think it prefers things you already have installed
09:01:12 <benmachine> and then whatever's latest
09:01:14 <elliott> two packages installed is hell anyway.
09:01:17 <elliott> you should fix that instead
09:01:21 <elliott> er, two versions of a package
09:01:24 <benmachine> elliott: not /entirely/ true
09:01:40 <dgpratt> I have two versions of Cabal (the library) installed
09:01:57 <benmachine> it's not a problem 'til it's a problem
09:02:04 <dgpratt> but buildwrapper gets built against the lower of the two available versions
09:02:32 <dgpratt> maybe there's another constraint that gets in the way of choosing the higher version
09:02:36 <benmachine> maybe
09:02:53 <benmachine> for example, the ghc package depends on old-Cabal, probably
09:02:56 <dgpratt> I suppose forcing the higher version will tell me if that is indeed the case
09:03:02 <benmachine> so if buildwrapper uses ghc, it will need to use old-Cabal too
09:03:13 <benmachine> you can pass -v to cabal install and sometimes that helps
09:05:02 <dgpratt> indeed, ghc appears to be the source of the conflict
09:08:07 <benmachine> dgpratt: cabal works under the (pessimistic) assumption that in order to use two libraries together, they have to be built against the same versions of their shared dependencies
09:09:14 <aninhumer> Hmm, I'm not sure why this doesn't work: http://hpaste.org/79367
09:10:19 <benmachine> aninhumer: "doesn't work"?
09:10:28 <aninhumer> benmachine: It doesn't compile
09:10:33 <benmachine> aninhumer: message?
09:11:11 <aninhumer> benmachine: Could not deduce (T a ~ T a0) from the context (C a)
09:11:26 <aninhumer> I should probably say I've tried using ScopedTypeVariables
09:11:27 <Guest33793> Could anyone here explain why a basic hello world is 882K in file size?
09:11:45 <neutrino_> Guest33793: because it is statically linked.
09:12:22 <archeyDevil> neutrino_: for..... main = putStrLn "Hello World!"
09:12:41 <neutrino_> Guest53788: that 882K could run on a bare system. a typical dynamically linked program might be 50K in size, but it'll load several megabytes of images into memory
09:12:43 <S11001001> archeyDevil: you know about static linking?
09:12:44 <neutrino_> yes, for that
09:12:56 <benmachine> Guest53788: you can dynamically link haskell executables too, but it's not done by default
09:13:02 <archeyDevil> S11001001: Yes, but I find that quite large for such little.
09:13:03 <benmachine> because haskell libraries are less commonly available
09:13:04 <neutrino_> is your operating system 882K?
09:13:15 <neutrino_> because if it's not then you're doing a tradeoff when using dynamic linking.
09:13:20 <S11001001> archeyDevil: in comparison to what?
09:13:29 <archeyDevil> benmachine: nick change after nickserv identify btw.
09:13:33 <archeyDevil> S11001001: C
09:13:43 <S11001001> archeyDevil: C how?
09:13:49 <benmachine> archeyDevil: oh, right, silly me
09:13:53 <neutrino_> S11001001: what do you mean?
09:14:04 <benmachine> Guest53788: if you're going to call yourself that you deserve everything you get :P
09:14:07 <neutrino_> archeyDevil: anyways, "hello world" is not really what GHC was made for compiling..
09:14:14 <neutrino_> archeyDevil: and it's not what Haskell was made for, either
09:14:22 <S11001001> archeyDevil: there are various ways to compile C too
09:14:27 <archeyDevil> -rwxr-xr-x 1 archey users 4.8K Dec 18 04:13 a.out*
09:14:28 <neutrino_> archeyDevil: there's a lot to be said about synthetic benchmarks. this is one of them.
09:14:36 <S11001001> ldd a.out
09:14:57 <lispy> Haskell PSA: Set documentation: True in your ~/.cabal/config and fix all your haddock build errors!
09:14:58 <neutrino_> however, with the newest version of ghc, which supports dynamic linking, that executable might be tens of KB
09:15:07 <archeyDevil> linux-gate.so.1 libc.so.6 => /usr/lib/libc.so.6 /lib/ld-linux.so.2
09:15:14 <monochrom> I don't understand your worry. Are you worrying that n lines of code becomes n*882K of executable?
09:15:14 <lispy> Srsly ppl. Fix your haddocks :)
09:15:16 <neutrino_> lispy: i was wondering about just that yesterday
09:15:33 <S11001001> archeyDevil: looks like you measured apples on one hand and oranges on the other
09:15:35 * lispy just tried to install language-c-quote and it has haddock errors
09:15:44 <elliott> :t asks
09:15:46 <lambdabot> MonadReader r m => (r -> a) -> m a
09:16:00 <lispy> neutrino_: I try to remember to turn it on when I do travis-ci builds.
09:16:08 <lispy> neutrino_: but not everyone is using that yet
09:16:10 <archeyDevil> S11001001: That was hello world in c vs haskell. ghc --make test; cc test
09:16:19 <benmachine> archeyDevil: fwiw I compiled a haskell hello-world with dyn linking and got 13K
09:16:22 <neutrino_> lispy: using what.. travis-ci?
09:16:33 <S11001001> archeyDevil: cc dynamically links by default, whereas ghc does the opposite.
09:16:43 <archeyDevil> S11001001: Okay.
09:16:50 <benmachine> archeyDevil: which is still large by comparison to your example, but in the same ballpark
09:16:57 <archeyDevil> That takes it to 14K
09:17:13 <archeyDevil> benmachine: What's your code? 1K diff :P
09:17:31 <benmachine> archeyDevil: I suspect different rounding, mine's actually 13679
09:17:38 <lispy> neutrino_: it's a continuous integration system that you can use for free with public github repostitories.
09:17:45 * monochrom does not understand this executable size pissing war
09:17:48 <lispy> neutrino_: they offer a linux build slave that has ghc-7.4 on it
09:17:51 <archeyDevil> benmachine: 13666
09:17:52 <archeyDevil> Heh.
09:18:01 <benmachine> archeyDevil: probably compiler differences
09:18:02 <archeyDevil> 666, my number ^_^
09:18:02 <monochrom> what is your real problem?
09:18:06 <neutrino_> lispy: i know travis ci, i was wondering if that was what you meant
09:18:10 <archeyDevil> benmachine: Probally.
09:18:16 <benmachine> monochrom: I have in the past struggled to get Haskell working on a webserver with a small quota
09:18:23 <benmachine> monochrom: so it's not 100% irrelevant
09:18:23 <archeyDevil> benmachine: OS?
09:18:30 <pmade> I uploaded a package to hackage and it's saying that it failed to build on GHC 7.6, so I decided I better install 7.6 and try it out.  However HP 2012.4.0.0 doesn't seem to build with it (OpenGL), is it stupid to try to install HP with 7.6?
09:18:33 * archeyDevil arch as suggested by /nick.
09:18:34 <neutrino_> last time i checked, you could run a standalone of travis ci.. is that so?
09:18:44 <benmachine> archeyDevil: me too, but I don't use packaged GHC
09:18:48 <lispy> neutrino_: yeah, I'm really pleased with their service. It's so much easier to configure use than any of their competitors and it's free :)
09:18:54 <archeyDevil> But devil suggests bsd but meh. Haven't played around with bsd in too long.
09:18:59 <monochrom> I understand, benmachine. but that was your real problem, not his real problem. no one knows his real problem.
09:19:16 <benmachine> pmade: it's not stupid, but if it breaks you get to keep the pieces
09:19:16 <fmap> pmade: yes
09:19:18 <neutrino_> i wish hackage had a build system
09:19:18 <archeyDevil> benmachine: Ahh, I only use the packaged cause it's faster. Use cabal-install for everything else tho.
09:19:21 <neutrino_> but it doesn't
09:19:25 <aninhumer> Added the complete output from GHCi, http://hpaste.org/79367, I'm probably misunderstanding how type families work in classes, but I'm not sure why this doesn't compile
09:19:29 <lispy> neutrino_: I don't know. Never tried that. I'd actually like to pay travis-ci to help them stay in business but I can't figure out how to upgrade to a paid account.
09:19:37 <archeyDevil> benmachine: Any haskell vs c programs where c produces larger files?
09:19:44 <neutrino_> lispy: hahaha
09:19:49 <neutrino_> that sort of sucks.
09:19:50 <alpounet> neutrino_, it will, at some point, we're working on this :)
09:19:50 <benmachine> archeyDevil: I don't know, never tried
09:19:53 <archeyDevil> cc vs ghc
09:19:54 <lispy> neutrino_: which is not so good for their business model <insert fry saying take my money>
09:20:06 <archeyDevil> not gcc with it's optimizations.
09:20:20 <neutrino_> alpounet: i'm working on a related kind of build server.. i wonder if i could contribute some of the code.. it's not pretty though
09:20:29 <pmade> fmap, benmachine: does that mean I should install cabal-install separately and then just bring in the packages I need?
09:20:36 <alpounet> neutrino_, in what timezone are you?
09:20:38 <alpounet> err wait
09:20:38 <eacameron> I installed cabal as sudo and now running `sudo cabal install cabal-install` only upgrades my user-based cabal and not the system-wide one...how can I fix that?
09:20:41 <alpounet> @localtime neutrino_
09:20:42 <lambdabot> Local time for neutrino_ is Mon Dec 17 18:19:59 2012
09:20:46 <fmap> pmade: cabal-install doesn't install ghc
09:20:48 <alpounet> oh great, same as mine
09:20:49 <archeyDevil> cabal-dev-0.9.1 depends on Cabal-1.2.4.0 which failed to install.
09:20:50 <neutrino_> timezone? heh
09:20:50 <archeyDevil> Hmm.
09:20:53 <benmachine> pmade: that's what I do
09:20:58 <pmade> benmachine: thanks.
09:21:11 <archeyDevil> Tue Dec 18 04:20:53 EST 2012
09:21:11 <benmachine> pmade: be aware that different versions of GHC can happily coexist
09:21:12 <alpounet> neutrino_, i'm a bit busy right now, but are you available later to talk about this?
09:21:18 <archeyDevil> neutrino_: Early ^_^
09:21:18 <neutrino_> sure
09:21:27 <pmade> benmachine: That I know, I'm putting them in different directories.
09:21:31 <benmachine> pmade: I have every version since 6.12.3 installed at once :P
09:21:37 <archeyDevil> Oh noes
09:21:38 <neutrino_> archeyDevil: i have a healthy sleeping rhythm
09:21:49 <archeyDevil> ~ >> cabal install yesod cabal-dev |& ix
09:21:49 <archeyDevil> http://ix.io/3Fu
09:21:59 <archeyDevil> neutrino_: Heh.
09:22:40 <archeyDevil> Anyone have any suggestions for that failure compile?
09:22:45 <archeyDevil> of cabal
09:23:00 <fmap> archeyDevil: Cabal-1.2.4.0?
09:23:14 <archeyDevil> cabal-install version 1.16.0.2
09:23:24 <archeyDevil> ^ In arch-repos.
09:23:34 <archeyDevil> Idk why it's trying to install old....
09:23:40 <kosmikus> luite: lhs2tex problem solved?
09:23:53 <archeyDevil> But yesod want's cabal-devel.
09:24:10 <fmap> archeyDevil: well, it's not "old", it's "ancient"
09:24:12 <archeyDevil> dev *
09:24:34 <archeyDevil> One sex...
09:24:42 <fmap> archeyDevil: try cabal install with -v or something, it will say why it picks Cabal-1.2.4.0
09:24:57 <monochrom> you have to repeat that when he comes back
09:24:57 <archeyDevil> Back ^_^
09:25:09 <archeyDevil> monochrom: Come again?
09:25:11 <archeyDevil> :P
09:25:11 <fmap> archeyDevil: try cabal install with -v or something, it will say why it picks Cabal-1.2.4.0
09:25:28 <Guest86332> Oh crap
09:25:59 <monochrom> yesod does not want cabal-dev here. "cabal install --dry-run yesod" does not list cabal-dev
09:26:04 <benmachine> aninhumer: it's strange how writing type T (D b) = D (T b) isn't allowed
09:26:45 <kosmikus> cabal-dev is a binary anyway. it'd be strange for yesod to depend on it. probably it's just suggested to use cabal-dev in order to do yesod development.
09:26:56 <archeyDevil> monochrom: Hmm, well it's wanted on the page I was looking at.. http://yannesposito.com/Scratch/en/blog/Yesod-tutorial-for-newbies/
09:27:34 <aninhumer> benmachine: Hmm, I was under the impression it was allowing it, but failing to typecheck the function? If I omit gen it works (apart from the warning)
09:27:41 <byorgey> if you want cabal-dev you have to build it from github
09:27:49 <byorgey> the version on Hackage is super outdated
09:27:53 <yitz> benmachine: type aliases cannot be recursive. why doesn't that make sense?
09:28:23 <benmachine> yitz: it makes sense; is it true?
09:28:53 <archeyDevil> I'll just try installing yesod alone.
09:29:30 <archeyDevil> So.. Ghc by default makes binaries static so... I could build a webserver and upload it to a friend's laptop and run it?
09:29:48 <archeyDevil> Without having to worry about any dependencies.
09:29:56 <monochrom> it is true. "Although recursive and mutually recursive datatypes are allowed, this is not so for type synonyms, unless an algebraic datatype intervenes."
09:30:00 <Hafydd> Why are you running a web server on your friend's laptop?
09:30:09 <benmachine> Hafydd: does it matter?
09:30:10 <yitz> benmachine: yes i think so. the compiler is only expected to do a shallow replace of the symbol, without looping.
09:30:22 <Hafydd> No, my question doesn't imply that it matters.
09:30:25 <benmachine> archeyDevil: well, it may dynamically link against libgmp
09:30:34 <benmachine> archeyDevil: as long as that matches, yes, you're fine
09:30:36 <kosmikus> archeyDevil: they're static by default in the Haskell libraries, not completely
09:31:08 <archeyDevil> Hafydd: I'm not, but wouldn't hurt to have a web server running there and have port 8001 forwarded to there instead of my mpd/mp3 stream lol.
09:31:18 <archeyDevil> I "borrow" his laptop from time to time lol.
09:31:42 <Hafydd> I see.
09:31:50 <archeyDevil> benmachine: So.. Could libgmp be made in the binary staticly instead of being linked still?
09:31:56 <monochrom> bring your 882K hello world to that laptop and try it. play with ldd etc
09:31:57 * yitz checks his system logs to see if archeyDevil is running a webserver on his system
09:31:58 <archeyDevil> Hafydd: Permitted ssh access.
09:32:10 <archeyDevil> yitz: lol.
09:32:21 <benmachine> archeyDevil: I don't know, but many systems have it anyway
09:32:28 <archeyDevil> monochrom: He's banned me from that computer haha
09:32:36 <archeyDevil> benmachine: Okay
09:32:50 <monochrom> then try it in a virtual machine
09:33:08 <archeyDevil> Banned cause I root'd him several ways and he can't figure out where all my suid z shells are hidden hehe.
09:33:30 <archeyDevil> monochrom: :|
09:33:36 <archeyDevil> monochrom: You make me laugh.....
09:33:39 <archeyDevil> Resuming in non X mode: xrandr not found. For package install advice run: inxi --recommends
09:33:42 <archeyDevil> CPU~Dual core Intel Pentium Dual CPU E2160 (-MCP-) clocked at 1200.000 Mhz Kernel~3.7.0-1-ARCH x86_64 Up~6:53 Mem~163.8/1998.4MB HDD~402.0GB(4.3% used) Procs~128 Client~Irssi 0.8.15 inxi~1.8.24
09:33:47 <archeyDevil> VM=I WISH
09:33:53 <benmachine> oh, hold on
09:33:55 <archeyDevil> Notebook: CPU~Single core Intel Atom CPU N270 (-HT-) clocked at 800.000 Mhz Kernel~3.6.7-1-ARCH i686 Up~18 days Mem~337.5/2012.0MB HDD~320.1GB(3.0% used) Procs~124 Client~Shell inxi~1.8.23
09:33:59 <archeyDevil> Lol
09:34:11 <aninhumer> Hmm, if I just have the recursive typefamily, it compiles fine, but if I try to use it in a function it complains?
09:34:11 <archeyDevil> HDD lies = fuse mounts/sshfs.
09:34:17 <benmachine> monochrom: when you quoted that thing about recursive type synonyms, did you realise it was in the context of an associated type in a class instance?
09:34:41 <monochrom> no, I was just reading Haskell 2010
09:34:47 <benmachine> ah, right
09:34:56 <benmachine> so recursive type *families* may or may not be allowed
09:35:49 <aninhumer> benmachine: Certainly the type family compiles fine on its own
09:35:56 <monochrom> there is a good chance type synonym family follows type synonym in this regard
09:36:26 <monochrom> just as data family follows data
09:36:49 <archeyDevil> ~/blog/haskell/archey >> cabal install |& ix
09:36:50 <archeyDevil> http://ix.io/3Fw
09:36:51 <benmachine> monochrom: I just tried it with a different example and it worked, so it isn't disallowed in general
09:36:52 * archeyDevil is confused...
09:37:10 <hpaste> benmachine annotated “Type families problem” with “Working example” at http://hpaste.org/79367#a79369
09:37:21 <monochrom> it may be a non-recursion that looks like a recursion
09:37:28 <archeyDevil> Just installed, and I haven't updated the cabal database since...
09:37:34 * eacameron is dumb. Just chown .cabal :(
09:37:36 <benmachine> aninhumer: the above works (thing is probably unnecessary)
09:37:56 <archeyDevil> Why would there be an update that is *now* made required...
09:38:33 <hpaste> benmachine annotated “Type families problem” with “Simpler working example” at http://hpaste.org/79367#a79370
09:38:38 <monochrom> I don't see recursion in "type T (D a) = (a, D a)"
09:38:59 <benmachine> monochrom: you're right, but the thing I just pasted does have recursion and still works
09:39:10 <archeyDevil> Any suggestions ?
09:39:30 <monochrom> then it is what I said, non-recursion that looks like recursion
09:39:57 <aninhumer> benmachine: Thanks, I'll have a play around with that
09:40:00 <benmachine> monochrom: well, call it recursion or not, it's pretty close to the solution to the problem
09:40:01 <`nand`> it doesn't even look like recursion
09:40:13 <eikke> anyone knows the state of the "resource (de)allocation" work that's supposed to become part of Pipes?
09:40:21 <monochrom> (T (D a)) is one type. (T a) is another type. this is analogous to:
09:40:42 <monochrom> "instance Show [a] where show (x:_) = show x" is not recursion
09:40:55 <archeyDevil> benmachine: ?
09:41:25 <benmachine> archeyDevil: I'm busy
09:41:30 <archeyDevil> Okay.
09:41:44 <benmachine> and aninhumer's problem is more interesting than yours :P
09:41:45 <`nand`> isn't type family evaluation strict? So a recursive type, if possible, would be non-terminating either way?
09:41:46 <monochrom> I respect that you just want working code and you don't care what is recursion, but I thought you raised the question.
09:42:27 <tromp> > 3137-2930 `div` 2
09:42:28 <benmachine> monochrom: in fairness, the term "recursion" was originally brought up by something else, because I pasted a snippet that syntactically looked recursive, even though as you point out it wasn't
09:42:29 <lambdabot>   1672
09:42:36 <aninhumer> monochrom: Why not both? :P
09:42:40 <benmachine> tromp: div binds tightly
09:42:51 <monochrom> um, both what?
09:42:57 <benmachine> monochrom: I agree with you now that you point it out
09:43:02 <aninhumer> monochrom: Working code and interest in recursion
09:43:13 <archeyDevil> xmonad, only haskell project I've never had any issues compiling. :|
09:43:46 <`nand`> what kind of issues do you have compiling haskell projects?
09:43:46 <monochrom> one can do both, yes, but it is up to one to make that choice, not me
09:43:58 <tromp> > (3137-2930) `div` 2
09:44:00 <lambdabot>   103
09:44:27 <archeyDevil> `nand`: Like for now.. I can't get cabal to compile/install the yesod project that I just created due to version conflicts. After just installing yesod.
09:44:30 <archeyDevil> lol
09:44:42 <archeyDevil> vodik's ircbot was a pain in the ass.
09:45:20 <`nand`> I remember having some issues with yesod in particular as well
09:45:32 <archeyDevil> `nand`: Listed?
09:50:31 <archeyDevil> `nand`: ?
09:50:51 <`nand`> archeyDevil: hang on, looking up logs
09:50:56 <archeyDevil> Okay
09:51:31 <`nand`> ah
09:51:56 <`nand`> it was just an unidentified ‘Build failure’ when running `yesod devel`; due to (presumably) incompatibility of yesod with GHC 7.6.1
09:52:14 <`nand`> it did install fine though: http://bpaste.net/show/54256/ :P
09:53:13 <archeyDevil> `nand`: Any idea for my issue?
09:54:25 <dgpratt> I've been pondering my buildwrapper problem over lunch, and the thought occurs to me...
09:56:54 * archeyDevil tries with --force-reinstalls
09:56:56 <`nand`> archeyDevil: I don't know what your issue is, for starters, but I would recommend staying as far away as possible from cabal-install
09:57:06 <`nand`> in my experience it's caused nothing but headaches and breakage
09:57:07 <dgpratt> taking cabal's suggestion and running "cabal install cabal-install" caused EclipseFP to be broken
09:57:10 <archeyDevil> hehe
09:57:28 <monochrom> that's for taking suggestions
09:57:38 <dgpratt> and broken in a fashion that I cannot easily figure out how to fix it
09:57:59 <dgpratt> which seems unfortunate
09:58:26 <monochrom> perhaps you just need to unregister everything in --user
09:58:27 <benmachine> `nand`: I work with cabal-install pretty succesfully
09:58:36 <luite> kosmikus: no
09:58:37 <benmachine> you just need to know how not to upset it
09:58:48 <`nand`> benmachine: how do you not upset it?
09:58:49 <luite> kosmikus: although apparently it does work if i use --math instead of the default
09:58:52 <dgpratt> and now I am wondering, what should be changed (if anything) to prevent this occurence in the future?
09:59:37 <monochrom> most important: change your brain, do not be hypnotized by cabal suggestions such as "new version available" or "use --force-reinstall"
09:59:40 <benmachine> `nand`: always use local installs, often use --dry-run, pay attention to what it is doing
09:59:59 <dgpratt> should EclipseFP contain and distribute its own copy of the libraries/utilities that it uses?
10:00:02 <benmachine> oh, and read monochrom's thing that he wrote with the unfortunate acronym
10:00:02 <monochrom> and yeah, use --dry-run and manually scrutinize the list
10:00:21 <monochrom> that's http://www.vex.net/~trebla/haskell/sicp.xhtml
10:00:45 <archeyDevil> monochrom: too late if you're talking to me, lol. Just about finished haha
10:00:58 <archeyDevil> done but failed O.o
10:01:11 <`nand`> benmachine: I see
10:01:14 <archeyDevil> I try dry run
10:01:19 <monochrom> the only cabal suggestion you ever trust: "cabal update"
10:01:20 <`nand`> benmachine: that sounds like a lot of effort :)
10:01:42 <benmachine> `nand`: it doesn't feel like a lot of effort to me
10:02:06 <benmachine> `nand`: especially when I recently tried to learn ocaml, and they don't have a cabal-install-alike (at least not backed by something the size of hackage)
10:02:14 <dgpratt> monochrom: but "cabal update" suggests I "cabal install cabal-install"! ;) so conflicted!
10:02:37 <`nand`> personally, I think it's wrong for each language to provide its own package manager
10:02:45 <monochrom> no, I don't mean that
10:02:49 <`nand`> like ruby gems and whatnot
10:02:56 <dcoutts> `nand`: if only there were some suitable language neutral system, but there isn't
10:02:59 <monochrom> I mean: trust only this suggestion: "run cabal update"
10:03:24 <dcoutts> `nand`: in principle you are of course right
10:03:58 <`nand`> dcoutts: I've managed to get pretty far with portage; the only thing that isn't being handled through portage on my system the kernel configuration, because it would be way too complex to fit into portage nicely either way; the ncurses menu is a much nicer API
10:04:00 <tac> `nand`: better each language than each flavor of linux
10:04:03 <monochrom> use hugs to avoid all kinds of cabal problems. that's how ruby does it. by going interpreter so there is no ABI issue
10:04:26 <`nand`> other than that, everything (vim plugins, weechat plugins, latex libraries, perl modules, haskell libraries, etc.) is through portage
10:04:42 <dcoutts> `nand`: that's the problem, we also cannot pick a distro-specific system
10:04:44 <benmachine> monochrom: replace all cabal problems with the single, simple problem "you can't install anything interesting" :P
10:04:44 <`nand`> monochrom: haha
10:05:14 <`nand`> a better approach would be http://www.yesodweb.com/blog/2012/04/replacing-cabal
10:05:26 <monochrom> well, yes, it's unfortunate that hugs is not updated and is not popular. but suppose it were, then it would still lack most of cabal problems
10:05:42 <monochrom> in fact once upon a time cabal supported hugs
10:05:50 <dcoutts> cabal does still support hugs
10:05:57 <benmachine> monochrom: aiui cabal supports building stuff with hugs
10:06:06 <monochrom> "building"
10:06:07 <`nand`> dcoutts: the problem with supporting different distros would be nonexistant if every distro just used portage
10:06:15 <benmachine> installing, ykwim :P
10:06:16 <dcoutts> `nand`: ;-)
10:06:17 <archeyDevil> ~/blog/haskell/archey >> cabal install |& ix
10:06:18 <archeyDevil> http://ix.io/3Fx
10:06:18 <`nand`> as far as I can tell, there wouldn't be a problem with that
10:06:22 <archeyDevil> Any suggestions?
10:06:44 <benmachine> although I'm currently stripping out the stuff that (nominally, but probably not in reality) allows hugs to actually run Cabal itself
10:06:55 <`nand`> I think it's the most powerful package manager in actual use. An even better approach could be Nix; but that's far from being polished
10:07:33 <benmachine> `nand`: unfortunately a lot of people are quite attached to their own distribution systems
10:07:43 <benmachine> `nand`: does portage work on Windows?
10:07:47 <`nand`> archeyDevil: install happy version >=1.18.5
10:07:56 <`nand`> benmachine: most likely
10:07:58 <elliott> nix is pretty polished
10:08:12 <`nand`> benmachine: it runs on python; and POSIX-specific stuff can be had through Interix
10:08:22 <archeyDevil> `nand`: cabal should have tho?
10:08:30 <elliott> monochrom: cabal officially still supports hugs
10:08:30 <archeyDevil> As dependency?
10:08:34 <elliott> i think it does not build on hugs though
10:08:35 <dgpratt> `nand`: Interix is somewhere between dead and dying
10:08:38 <`nand`> archeyDevil: I guess so? (I don't use cabal-install)
10:08:40 <elliott> at least
10:08:46 <elliott> I remember seeing things in cabal's source that would not work on hugs
10:08:49 <archeyDevil> Hmmm
10:09:08 <archeyDevil> seems to be installing now
10:09:09 <archeyDevil> :)
10:09:25 <archeyDevil> To be happy... Literally install "happy" :D
10:10:20 <watermind> So I'm trying to selectively derive instances of Num (m a)    and I have some code that already does some work
10:10:23 <hpaste> wm pasted “deriving Num instances selectively” at http://hpaste.org/79372
10:10:28 <Hafydd> We will have to see if that remains when you try to write a parser using it.
10:10:28 <watermind> ^
10:10:46 <elliott> watermind: that Num instance does not mean what you think it means
10:11:00 <elliott> and you fundamentally cannot have both
10:11:11 <elliott> when the instance resolver searches for an instance it only looks at the instance head, not your constraint
10:11:18 <`nand`> instance selection is independent of the context
10:11:23 <`nand`> Num (m a) and Num (m a) overlap
10:11:24 <elliott> so there can only ever be one instance of the form "instance ... => Num (m a)"
10:11:39 <elliott> the only correct solution is to not have such an instance
10:11:45 <watermind> I see :(
10:11:48 <`nand`> there's some work on context-based instance resolution, but it won't look like that
10:11:59 <`nand`> that is; it uses various forms of trickery
10:13:08 <watermind> that already gives me some power, in the sense that now I'm able to simple choose to derive Num [a]  but  not Num (Maybe a)   from their respective monad instances
10:13:27 <watermind> which is better than nothing
10:14:43 <watermind> but being able chose to derive such instances in multiple ways would be even better
10:15:24 <watermind> hmm I had another idea brb
10:22:52 <archeyDevil> Night world....
10:23:02 * archeyDevil sure aint gonna sleep for a bit but will try.....
10:23:06 <archeyDevil> Tue Dec 18 05:22:48 EST 2012
10:23:22 <bartavelle> I have just realized that "withFile path ReadMode hGetContents" will return an empty string
10:23:45 <bartavelle> I have to do this to get my contents :
10:23:51 <bartavelle> withFile path ReadMode (\x -> do { !y <- hGetContents x; return y} )
10:23:55 <bartavelle> is there a better way ?
10:24:11 <bartavelle> (also why don't I use readFile ...)
10:24:20 <wuttf> Anyone tried Clean?
10:25:14 <donri> bartavelle: readFile leaves it semi-closed
10:25:25 <bartavelle> yes that's my problem, FD leaks
10:25:49 <bartavelle> at least, a problem I want to avoid, it is not yet a problem as this code is not in production
10:25:54 <elliott> bartavelle: in fact your way is not sufficient
10:26:00 <elliott> y <- hGetContents; evaluate (length y); return y
10:26:01 <elliott> is though
10:26:17 <bartavelle> elliott, ah I understand this. But I have to say this sucks !
10:26:22 <elliott> yes it does
10:26:23 <donri> maybe try strict text or bytestring IO
10:26:26 <elliott> bycott lazy IO!
10:26:28 <elliott> also boycott
10:26:57 <bartavelle> I should use bytestring, but I started this when I started with haskell, so it's String. As soon as it is stable I'll work on a v2
10:27:05 <bartavelle> is there strict String IO somewhere ?
10:27:29 <parcs> Text
10:27:35 <c_wraith> just don't use getContents or readFile
10:27:39 <c_wraith> everything else is strict
10:27:44 <c_wraith> (more or less)
10:28:16 <bartavelle> Text is inappropriate in my case
10:29:07 <donri> well you can unpack it into a string
10:29:18 <tomeo> Would the expression [ (x,y) | x <- [1..10000], x == 2000, y <- [1..100], odd y] and [ (x,y) | x <- [1..10000], y <- [1..100], x == 2000, odd y] be totally equivalent or would there be difference in performance due to the order of the predicates?
10:29:28 <bartavelle> Text doesn't work with anything else than text
10:29:43 <bartavelle> it will not work with binary file
10:29:48 <c_wraith> neither will String
10:30:04 <bartavelle> you can put the fd in binary mode
10:30:05 <c_wraith> in fact, using String for binary data can crash ghc
10:30:10 <bartavelle> really ?
10:30:23 <c_wraith> because it attempts to use the system encoding settings to convert bytes to unicode
10:30:27 <bartavelle> it seems I will have to start the v2 earlier than expected
10:30:30 <c_wraith> if you want binary, use ByteString
10:30:37 <c_wraith> That's the only correct answer
10:30:37 <bartavelle> bleh :(
10:30:44 <c_wraith> String is unicode
10:30:55 <neutrino_> tomeo: run each a thousand times and tell us
10:30:57 <c_wraith> That means it assumes you're giving it valid unicode
10:31:03 <bartavelle> yes, just like Text
10:36:58 <parcs> hi
10:37:02 <parcs> oops
10:37:27 <elliott> hi
10:43:29 <hpaste> Moggle pasted “permutations” at http://hpaste.org/79373
10:43:41 <Moggle> Would anyone care to tell me if I did anything horrifically wrong here?
10:43:51 <Moggle> Just a simple function to make a list of all the permutations of a list
10:44:10 <Moggle> (If your name is shachaf, no it isn't for project euler, I was just bored)
10:46:09 <Botje> Moggle: well, you didn't use Data.List.permutations ;)
10:46:23 <Moggle> Botje: you make a compelling argument
10:46:27 <Botje> wait, I think i'm getting languages switched..
10:46:33 <Moggle> (I
10:46:36 <Botje> ah, phew.
10:46:43 <Moggle> (I'll admit I never looked to see if the function existed)
10:46:56 <Botje> Moggle: you could combine the first two cases in perms [] = [[]]
10:47:11 <S11001001> Moggle: your fold can be written as =<< and that would be faster too
10:47:36 <Moggle> Botje: I'm pretty sure that wouldn't work D:
10:47:46 <Moggle> As for =<<
10:47:48 <Moggle> what does that even do
10:47:54 <Moggle> I keep seeing everyone use it and it scares me
10:47:57 <Botje> it's concatMap in disguise.
10:47:59 <Botje> at least for lists
10:48:25 <S11001001> @ty (=<<) `asTypeOf` concatMap
10:48:27 <lambdabot> (a -> [b]) -> [a] -> [b]
10:48:27 <Moggle> It... basically takes a list of lists and squishes it into one list?
10:48:28 <Clint> @unpl =<<
10:48:29 <lambdabot> (\ b c -> c >>= b)
10:48:37 <`ramses> if you're new to haskell, I'd stick to list-specific functions and stay away from the monadic ones like (>>=)
10:48:37 <Botje> that's concat
10:48:46 <Botje> concatMap applies a function which yields lists first
10:48:51 <Moggle> `ramses: new is a dangerous word
10:49:14 <`ramses> is it? :)
10:49:21 <Moggle> How would I write it with concatMap?
10:49:34 <mm_freak_> > concatMap (\x -> [x ++ "!", x ++ "?"]) ["hello", "haskell", "world"]
10:49:35 <lambdabot>   ["hello!","hello?","haskell!","haskell?","world!","world?"]
10:49:37 <S11001001> Moggle: your fold is a loop that just appends onto an accumulating list, right?
10:49:43 <Moggle> Yes, S11
10:49:46 <Moggle> That's what it does!
10:49:48 <S11001001> Moggle: that's concatMap except less efficient.
10:49:58 <Moggle> Hooray! :D
10:50:04 <Moggle> A way to increase efficiency.
10:50:07 <Moggle> I like those.
10:50:12 <Moggle> @where hoogle
10:50:12 <lambdabot> http://haskell.org/hoogle
10:50:21 <S11001001> something like combs x =<< perms xs should work
10:50:23 <mm_freak_> > concatMap (\x -> [x - 1, x + 1]) [11, 22, 33]
10:50:25 <lambdabot>   [10,12,21,23,32,34]
10:50:51 <mm_freak_> > do x <- [11, 22, 33]; [x - 1, x + 1]
10:50:53 <lambdabot>   [10,12,21,23,32,34]
10:51:05 <Moggle> Aha! sense is made, mm_freak.
10:51:07 <Moggle> Thanks.
10:51:10 <S11001001> now that works because you don't look at l
10:51:14 <Moggle> As for =<<
10:51:19 <mm_freak_> > [11, 22, 33] >>= \x -> [x - 1, x + 1]
10:51:20 <Moggle> uh, you said that's concatMap
10:51:21 <lambdabot>   [10,12,21,23,32,34]
10:51:24 <mm_freak_> all the same thing
10:51:27 <Moggle> so uh... how does that work exactly
10:51:38 <c_wraith> it's a combination of map and concat
10:51:49 <c_wraith> ...  seriously, that's all it is.
10:51:54 <Moggle> sorry, let me rephrase
10:52:00 <mm_freak_> Moggle: think of a list comprehension applied to concat
10:52:00 <Moggle> "what's the argument order to =<<"
10:52:09 <Moggle> where does the function go
10:52:13 <mm_freak_> > concat [ [x - 1, x + 1] | x <- [11, 22, 33] ]
10:52:14 <Moggle> and where does the source list go
10:52:14 <S11001001> @ty (=<<) `asTypeOf` concatMap
10:52:15 <lambdabot>   [10,12,21,23,32,34]
10:52:16 <Moggle> D:
10:52:16 <lambdabot> (a -> [b]) -> [a] -> [b]
10:52:20 <mm_freak_> the list monad is really just that
10:52:46 <mm_freak_> and the underlying worker is concatMap aka (=<<)
10:53:05 <mm_freak_> concatMap itself is just:  concatMap f = concat . map f
10:53:24 <mm_freak_> > map (\x -> [x - 1, x + 1]) [11, 22, 33]
10:53:26 <lambdabot>   [[10,12],[21,23],[32,34]]
10:53:28 <mm_freak_> > concatMap (\x -> [x - 1, x + 1]) [11, 22, 33]
10:53:30 <lambdabot>   [10,12,21,23,32,34]
10:53:32 <Moggle> :t =<<
10:53:32 <mm_freak_> that's it
10:53:34 <lambdabot> parse error on input `=<<'
10:53:39 <Moggle> :t (=<<)
10:53:40 <mm_freak_> don't ask for the type
10:53:41 <lambdabot> Monad m => (a -> m b) -> m a -> m b
10:53:47 <S11001001> well you've done it now
10:53:55 <Moggle> Monads aren't THAT scary
10:54:05 <Moggle> I'm just... hmm.
10:54:10 <Moggle> so I would call it like
10:54:13 <mm_freak_> Moggle: ok, now that you asked for the type, replace 'm' by '[]' and you get the type for concatMap
10:54:13 <`ramses> they shouldn't :)
10:54:15 <Moggle> function =<< (list)
10:54:19 <mm_freak_> exactly
10:54:26 <mm_freak_> and function has to produce another list
10:54:31 <Moggle> that syntax is _weird_
10:54:37 <Moggle> but for the sake of efficiency
10:54:38 <`ramses> (=<<) = flip (>>=), they just have their arguments reversed
10:54:54 <mm_freak_> it isn't weird…  it's actually quite useful
10:55:03 <Moggle> I didn't say it wasn't useful
10:55:04 <Moggle> :P
10:55:10 <mm_freak_> Moggle: think of a function that returns all square roots of a number
10:55:20 <monochrom> weird = not seen before
10:55:20 <mm_freak_> sqrts :: (Floating a) => a -> [a]
10:55:31 <mm_freak_> you want all fourth roots?
10:55:41 <mm_freak_> \x -> sqrts x >>= sqrts
10:55:47 <mm_freak_> or even nicer:  sqrts >=> sqrts
10:55:48 <monochrom> you want all fourth roots? use list comprehension
10:56:11 <mm_freak_> that's basically what the list comprehension compiles to =)
10:56:17 <monochrom> [ y | s <- sqrts x, y <- sqrts s ]
10:56:35 <nyc> All square roots in what rings?
10:56:46 <monochrom> in the ring "a"
10:57:09 <mm_freak_> @let sqrts x | x < 0 = [] | x == 0 = [0] | otherwise = let s = sqrt x in [-s, s]
10:57:11 <lambdabot>  Defined.
10:57:13 <mm_freak_> > sqrts 4
10:57:14 <hpaste> Moggle pasted “permutationsb” at http://hpaste.org/79375
10:57:16 <lambdabot>   [-2.0,2.0]
10:57:17 <nyc> Floating a suggests real rings.
10:57:17 <mm_freak_> > sqrts (-1)
10:57:20 <lambdabot>   []
10:57:22 <Moggle> Alright, so uh
10:57:28 <mm_freak_> > (sqrts >=> sqrts) 16
10:57:30 <lambdabot>   [-2.0,2.0]
10:57:53 <mm_freak_> > (sqrts >=> sqrts) (16 :+ 0)
10:57:54 <lambdabot>   No instance for (GHC.Classes.Ord (Data.Complex.Complex a0))
10:57:54 <lambdabot>    arising from...
10:57:58 <Moggle> any suggestions on making combs smaller?
10:58:06 <mm_freak_> uh
10:58:12 <Moggle> the idea is that combs takes a number and makes a list with that number interspersed
10:58:21 <Moggle> ie. combs 1 [2,3] ====> [[1, 2, 3], [2, 1, 3], [2, 3, 1]]
10:59:28 <mm_freak_> Moggle: write a "select" function that transforms "abc" into [("", "abc"), ("a", "bc"), ("ab", "c"), ("abc", "")]
10:59:37 <mm_freak_> then just map over those tuples
10:59:50 <Moggle> mm_freak, that's what inits ys and tails ys does
11:00:04 <mm_freak_> Moggle: you need to combine them
11:00:21 <mm_freak_> > liftA2 zip inits tails "abc"
11:00:23 <lambdabot>   [("","abc"),("a","bc"),("ab","c"),("abc","")]
11:00:48 <mm_freak_> then map over that
11:00:50 <`ramses> mm_freak_: nice function! :)
11:00:53 <Moggle> huh, what's liftA2?
11:01:02 <`ramses> not the easiest applicative to grasp, though
11:01:15 <mm_freak_> Moggle: liftA2 a f g x = a (f x) (g x)
11:01:29 <mm_freak_> liftA2 zip f g x = zip (f x) (g x)
11:01:32 <Moggle> interesting
11:01:40 <mm_freak_> again, don't ask for the type =)
11:01:45 <mm_freak_> `ramses: =)
11:02:13 <mm_freak_> `ramses: thinking of ((->) e) as Reader in disguise makes me come up with such things all the time =)
11:02:50 <`ramses> mm_freak_: I'm quite comfortable with the ((->) r) applicative, but I notice that a lot of people have a hard time reading such codes
11:03:03 <`ramses> it's Data.Function.on on steroids :)
11:03:35 <`ramses> (and I mean people in my surroundings, probably not here)
11:04:29 <Hafydd> Data.Function.on.steroids
11:06:31 <Moggle> mm_freak: is where combs y ys = map (\(i, t)->i++(y:t)) $ liftA2 zip inits tails ys really all that much better than combs y ys = zipWith (\f l -> f ++ (y : l)) (inits ys) (tails ys)
11:06:35 <Moggle> or did I do something wrong
11:06:43 <Moggle> uh, I could format that better
11:06:56 <Moggle> is:
11:06:58 <Moggle> combs y ys = map (\(i, t)->i++(y:t)) $ liftA2 zip inits tails ys
11:07:04 <yitz> > (zip `on` ($ "abc")) inits tails
11:07:05 <Moggle> better than combs y ys = zipWith (\f l -> f ++ (y : l)) (inits ys) (tails ys)
11:07:06 <lambdabot>   [("","abc"),("a","bc"),("ab","c"),("abc","")]
11:07:28 <Moggle> :t on
11:07:30 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
11:07:45 <`ramses> liftA2 zip init tails =<< perms xs
11:07:55 <`ramses> Moggle: ^
11:07:55 <crdueck> :i inits
11:08:09 <crdueck> @src inits
11:08:09 <lambdabot> inits []     =  [[]]
11:08:09 <lambdabot> inits (x:xs) =  [[]] ++ map (x:) (inits xs)
11:09:13 <yitz> > groupBy ((==) `on` (!! 2)) $ words "To get to the other side."
11:09:14 <lambdabot>   [["To"*Exception: Prelude.(!!): index too large
11:09:22 <yitz> > groupBy ((==) `on` (!! 1)) $ words "To get to the other side."
11:09:23 <lambdabot>   [["To"],["get"],["to"],["the"],["other"],["side."]]
11:09:49 <yitz> > sortBy  (compare `on` (!! 1)) $ words "To get to the other side."
11:09:51 <lambdabot>   ["get","the","side.","To","to","other"]
11:10:02 <`ramses> > let f = (+) `on` sum in f [1,2,3] [4,5]
11:10:04 <lambdabot>   15
11:10:32 <yitz> > "Why did the multithreaded chicken cross the road? " ++ unwords (sortBy  (compare `on` (!! 1)) $ words "To get to the other side.")
11:10:34 <lambdabot>   "Why did the multithreaded chicken cross the road? get the side. To to other"
11:10:56 <Moggle> haha yitz
11:11:06 <neutrino_> hi
11:11:21 <neutrino_> i'm reading the stm paper, and i can't understand the definition of writeMChan
11:11:26 <neutrino_> can someone help me figure it out?
11:11:50 <neutrino_> http://research.microsoft.com/en-us/um/people/simonpj/papers/stm/stm.pdf
11:12:02 <neutrino_> it is on page 6 on the left
11:12:40 <mm_freak_> > liftA2 (zipWith (\xs ys -> xs ++ 'x':ys)) inits tails "abc"
11:12:42 <lambdabot>   ["xabc","axbc","abxc","abcx"]
11:12:47 <mm_freak_> @ Moggle
11:12:57 <watermind> so ghci eats this:   class Lift (a :: ( * -> * , * ) )  where
11:13:05 <watermind> but now I cannot write any instances
11:13:18 <watermind> (Maybe, Int) is not accepted
11:13:29 <mm_freak_> Moggle: mapping over a zip is just using zipWith instead of zip =)
11:13:39 <watermind> am I confused here or should that not even be accepted?
11:13:39 <monochrom> haha yitz, now I get it!
11:13:57 <mm_freak_> :t \y -> liftA2 (zipWith (\xs ys -> xs ++ y:ys)) inits tails
11:13:59 <lambdabot> a -> [a] -> [[a]]
11:14:13 <yitz> monochrom: didn't make it up, but always liked that one
11:14:16 <mm_freak_> (\y -> liftA2 (zipWith (\xs ys -> xs ++ y:ys)) inits tails) 'x' "abc"
11:14:21 <mm_freak_> > (\y -> liftA2 (zipWith (\xs ys -> xs ++ y:ys)) inits tails) 'x' "abc"
11:14:23 <lambdabot>   ["xabc","axbc","abxc","abcx"]
11:14:24 <watermind> i.e. I didn't even think we could write tuples ( * -> * , * )
11:14:31 <neutrino_> watermind: are you sure you don't mean forall?
11:14:34 <watermind> but it is accepted in the class declaration
11:14:36 <`nand`> I'm really at a loss here; what could possibly be causing this? Loading package base ... linking ... ghc: /usr/lib64/ghc-7.6.1/base-4.6.0.0/HSbase-4.6.0.0.o: unknown symbol `stat'
11:14:38 <`nand`> ghc: unable to load package `base'
11:14:51 <watermind> neutrino_: forall where?
11:14:53 <`nand`> I've reinstalled glibc, gcc and ghc a few times now, with different versions
11:14:55 <neutrino_> as in, forall b c d (b -> c, d)
11:15:03 * hackagebot shake 0.3.9 - Build system library, like Make, but more accurate dependencies.  http://hackage.haskell.org/package/shake-0.3.9 (NeilMitchell)
11:15:14 <`nand`> I also tried disabling distcc and compiling them all locally, which took about a day; but it didn't change the error
11:15:18 <neutrino_> i've never seen classes specify their instance methods with kinds
11:15:26 <`nand`> Is there something else I could try, or am I out of luck here?
11:15:29 <watermind> neutrino_: I haven't used polymorphic kinds
11:15:39 <watermind> neutrino_: well that you can do
11:15:43 <Moggle> mm_freak: where combs y = liftA2 (zipWith (\i t->i ++ (y:t))) inits tails        does have a pleasing sort of look to it
11:15:43 <neutrino_> yes, but you've used kinds
11:15:47 <neutrino_> why are you using kinds?
11:15:49 <Moggle> thanks!
11:15:59 <neutrino_> i'm curious because i don't know how they would work there
11:16:04 <`nand`> (I have a deadline to meet here too, it has to work in about a month)
11:16:16 <watermind> neutrino_: because the argument of a class is a type constructor, so it has a kind
11:16:31 <watermind> no problem in using a kind
11:16:50 <yitz> `nand`: is this on some esoteric platform?
11:16:59 <akamaus> hi. Is there a way to first build a project with cabal and then load compiled modules with ghci? Seems ghci can't find precompiled files in dist directory.
11:17:05 <watermind> I'm just,    1 - surprised (* -> * , * )  is a valid kind    and 2 - surprised (Maybe , Int) doesn't satisfy such a kind
11:17:13 <`nand`> yitz: x86_64
11:17:27 <`nand`> yitz: linux; the configuration is pretty much identical to my workstation where it works fine
11:17:27 <fmap> akamaus: cabal-dev ghci does that
11:17:32 <neutrino_> @kind (Maybe, Int)
11:17:33 <lambdabot>     Kind mis-match
11:17:33 <lambdabot>     The second argument of a tuple should have kind `* -> *',
11:17:33 <lambdabot>     but `Int' has kind `*'
11:17:34 <`nand`> yitz: I'm all out of ideas
11:17:42 <watermind> exactly
11:17:53 <yitz> `nand`: if not, it's probably a path issue of some kind. perhaps you have remnants of some incompatible ghc version laying around on your path.
11:17:57 <watermind> but ghci accepts thayt class declaration
11:18:15 <yitz> `nand`: or your load path
11:18:30 <`nand`> yitz: perhaps. Note that `ghc' itself works fine; it's just ghci that crashes (or template haskell)
11:18:39 <watermind> i.e. doesn't complain about class Lift (a :: ( * -> * , * ) )  where
11:18:40 <`nand`> so it seems to be linked to the interpreter
11:18:56 <neutrino_> `nand`: strace that
11:18:58 <watermind> so I'm thinking ghc bug
11:19:02 <watermind> but unsure
11:19:14 <yitz> `nand`: watch out for a weird path that may be lurking in some old .cabal/config or .ghci file, or something in .ghc.
11:19:34 <neutrino_> watermind: interesting
11:19:34 <`nand`> yitz: none of those directories exist
11:19:39 <yitz> ok
11:19:43 <watermind> "Haskell defines kinds as κ ::= * | κ -> κ."
11:19:53 <watermind> doesn't even say anything about pairing
11:20:04 <neutrino_> @kind (Int, Int)
11:20:05 <lambdabot> *
11:20:14 <yitz> `nand`: what distro/version?
11:20:14 <neutrino_> @kind (Maybe, Maybe)
11:20:16 <lambdabot>     Expecting one more argument to `Maybe'
11:20:16 <lambdabot>     In a type in a GHCi command: (Maybe, Maybe)
11:20:21 <`nand`> (* -> *, *) is a valid kind in GHC 7.4
11:20:28 <hpaste> Moggle pasted “permutationsfinal” at http://hpaste.org/79378
11:20:34 <`nand`> yitz: Gentoo Linux (same as my other PCs), GHC 7.6.1 (again, same as my other PCs)
11:20:34 <Moggle> alright, this is as simple as I can get it
11:20:37 <Moggle> thanks for your help everyone
11:20:43 <Moggle> it only hurts my brain twice as much as the original version
11:20:44 <Moggle> :D
11:20:47 <neutrino_> yitz: did you mean distro "version"? aka issue?
11:20:47 <watermind> `nand`: I noticed :)  but can you write anything concrete of that kind?
11:20:50 <akamaus> fmap, can I avoid installing cabal-dev by using flags or something? Seems it's going to break my system by downgrading Cabal to 1.14
11:21:02 <watermind> `nand`: can I make any instance of     class Lift (a :: ( * -> * , * ) )  where
11:21:09 <yitz> `nand`: ah so you're compiling ghc then.
11:21:46 <`nand`> watermind: sure, why not?
11:21:51 <yitz> `nand`: have you tried just installing the generic linux binary tarball?
11:21:56 <mm_freak_> Moggle: you're welcome (to applicative style) =)
11:22:03 <`nand`> watermind: instance Lift '(Maybe, Int)
11:22:07 <`nand`> yitz: nope
11:22:16 <Moggle> mm_freak: well, the reason I chose to learn Haskell was to bend my mind a little
11:22:18 <`nand`> I should probably try that
11:22:23 <Moggle> Prolog started me on the journey, Haskell is finishing it
11:22:26 <yitz> `nand`: worth a try, only takes a few minutes.
11:22:28 <watermind> `nand`: that's what I tried
11:22:34 <Moggle> Haskell is kind of Prolog but with actual features
11:22:36 <watermind> `nand`: but I get an error
11:22:56 <fmap> akamaus: well, you can check how cabal-dev does that in source or install cabal-dev from github i guess
11:23:17 <Moggle> oooh, I could probably simplify the list concat thing with some function composition
11:23:20 <fmap> (github version works with cabal-install-1.16)
11:23:20 <watermind> `nand`:     kind mismatch,  The second argument of a tuple should have kind `* -> *',  but `Int' has kind `*'
11:23:22 <Moggle> i will DO THAT.
11:23:30 <neutrino_> `nand`: if stracing doesn't work, i'd think about setting up a VM with the same distro, clean, and seeing if it works there
11:24:08 <`nand`> neutrino_: my netbook is as clean as it gets. Installing GHC is pretty much the first thing I did after installing the OS
11:24:21 <watermind> `nand`: using GHC 7.4.2 by the way
11:24:40 <neutrino_> `nand`: ok. is this a 64 bit or 32 bit os?
11:24:56 <`nand`> though I did build some other stuff first (system upgrade, setting up distcc, xorg-xserver)
11:25:01 <yitz> `nand`: in that case this may be a problem with that ebuild
11:25:10 <neutrino_> `nand`: i'm thinking, maybe it expects some 32 bit prefix or something.
11:25:14 <neutrino_> and can't find it.
11:26:05 <neutrino_> `nand`: for example, under ubuntu, if i'm on 64 bit ubuntu, i'd install ia32-libs
11:26:27 <hpaste> “`nand`” pasted “(* -> *, *)” at http://hpaste.org/79379
11:26:35 <`nand`> watermind: try this? ^
11:26:46 <`nand`> neutrino_: 64 bit OS
11:27:12 <neutrino_> `nand`: try compiling ghc as a 32 bit binary
11:27:35 <neutrino_> or, if you are (and you might be without knowing it) try compiling as a 64 bit binary
11:27:54 <`nand`> neutrino_: here's the output of `strace ghci': http://bpaste.net/show/65024/
11:27:58 <neutrino_> it's just a hunch
11:28:09 <`nand`> neutrino_: I have no idea how I'd compile as a 32 bit binary without changing my BINHOST, which would break everything
11:28:14 <`nand`> I'd have to compile ghc manually for that
11:28:27 <neutrino_> ok well first of all
11:28:34 <neutrino_> check if arch has some version of ia32-libs
11:28:40 <neutrino_> or multiarchitecture support
11:28:42 <monochrom> wait, do you have to compile ghc yourself?
11:28:44 <neutrino_> aka multiarch
11:29:16 <watermind> `nand`: oh nice,  it works. What is that '  ?
11:29:19 <`nand`> neutrino_: my profile's set to default/linux/amd64/10.0/desktop (same as workstation) which includes multilib support
11:29:24 <`nand`> watermind: promoted tuple
11:29:30 <watermind> `nand`: ah!
11:29:36 <watermind> `nand`: thank you
11:29:42 <`nand`> neutrino_: if I wanted everything 64 bit only, the profile would be /no-multilib; if I wanted everything 32-bit only, it'd be /x32
11:29:49 <`nand`> the default is to have both
11:30:45 <`nand`> the perplexing thing is that, as far as I can tell, there's no difference between my netbook and my workstation in terms of configuration except for a few fairly esoteric things (eg. wireless support on the netbook, audio support on the workstation)
11:31:16 <`nand`> also a few kernel config differences. Maybe I'm missing some obscure kernel option that GHCi relies on?
11:36:00 <`nand`> oh, I guess I could use the binpkg for ghc
11:36:29 <neutrino_> `nand`: i don't think ghci relies on obscure kernel options
11:36:51 <hpaste> bootcode pasted “dep conflict” at http://hpaste.org/79380
11:37:01 <monochrom> @src replicateM
11:37:02 <lambdabot> replicateM n x = sequence (replicate n x)
11:37:04 <neutrino_> `nand`: build a 32 bit binary on something and copy it to your netbook, see if it runs
11:37:15 <monochrom> @src sequence
11:37:16 <lambdabot> sequence []     = return []
11:37:16 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
11:37:16 <lambdabot> -- OR: sequence = foldr (liftM2 (:)) (return [])
11:37:19 <bootcode__> any remarks about the above paste?
11:38:08 <bootcode__> as I see all deps specify ranged versions on their bytestring dep, not sure why cabal chooses different bytestrings
11:38:21 <neutrino_> `nand`: look here: https://wiki.archlinux.org/index.php/Arch64_FAQ#Can_I_run_32-bit_apps_inside_Arch64.3F
11:39:06 <`nand`> neutrino_: I'm not sure how that's related
11:39:27 <akamaus> fmap, thanks for an idea, cabal-dev from github works for me
11:39:56 <neutrino_> `nand`: i'm assuming you got ghc in some binary package, and it's expecting a 32 bit environment
11:40:08 <neutrino_> `nand`: but maybe you should explain, how did you get ghc on that computer in the first place?
11:40:45 <`nand`> neutrino_: I downloaded a GHC binary (I don't actually know whether that binary was 32 or 64 bit); then built GHC from source using the downloaded version
11:40:50 <`nand`> then I deleted the downloaded binary and installed the one I built
11:41:43 <neutrino_> could a 32 bit ghc build a 64 bit ghc?
11:42:28 <neutrino_> if a 32 bit ghc is used to build a 32 bit ghc on a 64 bit os, but there is no proper 32 bit support on the os, will things work?
11:42:36 <neutrino_> ^ some q's
11:43:00 <neutrino_> that's basically what i'd chase up on next
11:44:17 <neutrino_> if you figure it out let me know `nand`
11:45:10 <`nand`> /usr/lib64/ghc-7.6.1/ghc: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked (uses shared libs), for GNU/Linux 2.6.16, stripped
11:45:14 <`nand`> I guess that means it's 64-bit?
11:45:21 <sipa> yes
11:45:26 <neutrino_> yes
11:45:41 <neutrino_> but was the original one 32 or 64 bit?
11:45:46 <bootcode__> slightly related question: if gloss-1.7.6.5 depends on bmp 1.2.*, then why does cabal say "package gloss-1.7.6.5 requires bmp-1.2.3.2"? Why not 1.2.3.1 for example, which also fits 1.2.*?
11:45:53 <neutrino_> and does building a 64 bit out of a 32 bit ghc "work"?
11:46:09 <neutrino_> bootcode__: i'm looking at your paste..
11:47:07 <bootcode__> neutrino_: in the mean time I discovered that the pulled in bmp version specifies the newer bytestring
11:47:13 <`nand`> neutrino_: the binary I built that from was http://code.haskell.org/~slyfox/ghc-amd64/ghc-bin-7.6.1-amd64-fix-dyn.tbz2
11:47:27 <`nand`> I guess that means it's 64 bit
11:47:31 <neutrino_> bootcode__: aha
11:47:40 <neutrino_> yes `nand`
11:48:05 <neutrino_> is that the dynamic linking one? maybe your new ghc was built dynamically too?
11:48:14 <kosmikus> luite: can you send me a mail deacribing the problem, please?
11:48:23 <neutrino_> and there's a bug in that somewhere?
11:48:29 <bootcode__> neutrino_: still not sure why does text-0.11.1.3 not pull the older bmp version, since it specifies >= 0.9, < 1.0
11:48:32 <neutrino_> there should be a flag somewhere for statically linking
11:48:53 <`nand`> oh, another difference is -march; I use -march=native on my workstation but -march=atom on my netbook
11:49:00 <bootcode__> is there a flag for cabal to explain its version choices a little more verbosely?
11:49:39 <neutrino_> bootcode__: no idea sorry :\
11:49:52 <bootcode__> neutrino_: np
11:50:04 <`nand`> ah
11:50:04 * hackagebot shake 0.3.10 - Build system library, like Make, but more accurate dependencies.  http://hackage.haskell.org/package/shake-0.3.10 (NeilMitchell)
11:50:06 <`nand`> the binary version works
11:50:22 <`nand`> I guess I can live with that. Takes too long to recompile ghc on the netbook either way
11:50:22 <neutrino_> `nand`: check the sizes of the executables?
11:50:29 <`nand`> too late
11:50:31 <`nand`> old executable's gone
11:50:33 <neutrino_> haha
11:50:52 <`nand`> (installing the binary ver overwrite the old one, they're in the same path)
11:50:52 <neutrino_> well, i'm thinking that ghc got built dynamically linked and that there's a bug in the dynamic linker.
11:51:11 <`nand`> then wouldn't that bug affect my workstation?
11:51:27 <neutrino_> maybe you built it with a version which didn't support dynamic linking?
11:51:32 <neutrino_> it's fairly new
11:51:55 <`nand`> neutrino_: there's no difference in `ldd' output between my workstation and my netbook
11:52:12 <`nand`> (the workstation uses a self-built GHC; the netbook uses the prebuilt binary now)
11:52:17 <fmap> bootcode__: -v
11:52:27 <`nand`> the build procedure between the workstation and the netbook (before I installed the binary) was exactly the same
11:52:51 <neutrino_> yes `nand`, but maybe the previoius generation of ghc on your workstation was something that didn't support dynamic linking
11:52:52 <`nand`> neutrino_: perhaps. I could try rebuilding ghc on my workstation and seeing if that breaks anything
11:52:55 <fmap> bootcode__: i.e -v0, -v1, -v2 or -v3
11:53:36 <neutrino_> also, i think ldd wouldn't be aware of ghc's linking? i'm not sure though. i don't know how it works exactly.
11:53:47 <`nand`> oh, good point re: ldd
11:54:02 <neutrino_> it just might be, this is only a guess.
11:54:56 <`nand`> the version of 7.6.1 on my workstation was built from the same URL as the workstation; but about two months ago. It's certainly possible that the URL broke in the meantime
11:55:05 <`nand`> same URL as the netbook*
11:55:10 <`nand`> let me try re-building GHC on the workstation
11:55:30 <neutrino_> you'd have to build twice
11:55:40 <`nand`> what do you mean?
11:55:47 <neutrino_> once to get a ghc which supports dynamic linking (if yours doesn't) and once to build it dynamically linked
11:56:02 <`nand`> no, I'd be bootstrapping off the binary I linked earlier
11:56:06 <`nand`> like I said, exact same build procedure
11:56:07 <neutrino_> ah ok
11:56:10 <neutrino_> yeah try it
11:56:36 <neutrino_> i'm only venturing very wild guesses here btw
11:56:38 <thoughtpolice> ldd works just as you expect with dynamic linking and GHC
11:56:43 <neutrino_> thoughtpolice: ok
11:56:59 <thoughtpolice> it sets the rpath on the generated executables to point to the correct versions, too
11:57:04 <neutrino_> thoughtpolice: do you know why `nand` might be having issues he mentioned above?
11:57:15 <thoughtpolice> i don't know what the issue is, i just saw the mention about ldd
11:57:25 <bootcode__> hm.. cabal only considers my installed versions of libs when doing dependency resolution? so it doesn't use the full hackage db to figure out what would be best for me?
11:57:27 * thoughtpolice scrolls back
11:57:28 <neutrino_> do you have enough scrollback? i could paste it in /msg
11:57:35 <neutrino_> ok
11:59:15 <`nand`> thoughtpolice: the issue is: Loading package base ... linking ... ghc: /usr/lib64/ghc-7.6.1/base-4.6.0.0/HSbase-4.6.0.0.o: unknown symbol `stat'
11:59:17 <`nand`> ghc: unable to load package `base'
11:59:21 <`nand`> when trying to run ghci
11:59:33 <thoughtpolice> what version of GHC? does the program compile fine with e.g. -O2
12:00:04 <`nand`> thoughtpolice: ghc itself works fine, it's just GHCi, runhaskell, template haskell etc. that do not
12:00:15 <`nand`> that is; I can compile and run haskell programs
12:00:18 <thoughtpolice> GHC version?
12:00:23 <`nand`> it's in the error message; 7.6.1
12:00:26 <thoughtpolice> well actually it doesn't matter, i assume you build statically right
12:00:29 <thoughtpolice> oh, sorry :P
12:00:44 <fmap> bootcode__: reinstalls are dangerous, that's why cabal prefers installed versions by default
12:01:16 <thoughtpolice> if so, then it's probably a bug with the runtime linker inside GHC. i'd actually file a ticket if there's not one already. the runtime linker in GHC is pretty crufty and has obscure bugs, that's part of the reason people GHC is going to dynamic-by-default
12:01:23 <bootcode__> fmap: why would I need to reinstall? would the different versions not live peacefully next to each other?
12:01:25 <monochrom> cabal cannot know what is "best" for you, since you never define what "best" means
12:02:03 <bootcode__> monochrom: to figure out which versions to use, with the given dependency constraints, that there aren't any conflicts
12:02:10 <monochrom> and even if it is defined, we do not know computable it is
12:02:29 <thoughtpolice> `nand`: it's also possible something else is going on, for example, base was built incorrectly and thinks 'stat' is an external symbol, when in a lot of libc's, stat is a macro
12:02:31 <monochrom> ok, cabal does that
12:02:42 <`nand`> (got disconnected just now)
12:02:54 <`nand`> thoughtpolice: yes, stat is a macro in glibc
12:03:10 <thoughtpolice> then that's probably it; i couldn't tell you how your base got built incorrectly, however
12:03:18 <watermind> ok so I managed to define two instances for lifting, one that works with Applicative and another with Monad... now I just don't know if it is possible to use them... is there a way to desambiguate this?
12:03:18 <thoughtpolice> did you build this GHC yourself?
12:03:21 <hpaste> wm pasted “Generic Lifting” at http://hpaste.org/79381
12:03:24 <`nand`> neither could I. I did try rebuilding it about 3 or 4 times
12:03:26 <`nand`> thoughtpolice: yes
12:03:30 <`nand`> thoughtpolice: works fine on my workstation though
12:03:34 <bootcode__> monochrom: but not using full hackage db it seems, only local versions
12:03:35 <monochrom> multiple versions live peacefully if you never used them
12:03:50 <monochrom> s/used/use/
12:03:50 <thoughtpolice> `nand`: same binary? or just a build of the same version works
12:04:04 <`nand`> thoughtpolice: same build procedure
12:04:05 <watermind> so the class is defined in terms of a pair of type constructures and the selected constraint
12:04:12 <watermind> but then the constraint isn't used anywhere
12:04:18 <bootcode__> monochrom: and how could i knowwhich versions to install locally
12:04:20 <`nand`> thoughtpolice: (I'm not actually building it myself. A script does the building for me, and I use the same script on both machines)
12:04:55 <thoughtpolice> `nand`: perhaps take tarballs of both versions of GHC, and run './configure' and see what it says about stat? you'll also probably need to run the configure for base, but i think you can do that too
12:05:16 <thoughtpolice> er, take a tarball of GHC, and put it on both machines, and compare ./configure output
12:05:20 <thoughtpolice> is more what i meant
12:07:28 <bootcode__> so i should just draw a graph of deps and figure out the exact versions to install
12:08:06 <fmap> bootcode__: you would need reinstalls because you probably want all dependencies depend on one version of bytestring
12:08:41 <bootcode__> fmap: you mean deps of deps are linked at install time?
12:09:07 <bootcode__> fmap: that is horrible :/
12:09:33 <fmap> bootcode__: well, yes, that's why sandboxes exist
12:10:01 <bootcode__> fmap: do sandboxes exist? :)
12:10:04 * hackagebot edge 0.9.0.2 - Top view space combat arcade game  http://hackage.haskell.org/package/edge-0.9.0.2 (ChristopherHoward)
12:10:30 <fmap> bootcode__: sure, cabal-dev, hsenv (, next cabal-install release)
12:10:53 <bootcode__> fmap: will check it, thanks
12:12:50 <watermind> :r
12:12:51 <watermind> ops
12:13:53 <bootcode__> in the mean time can I use the community as a cloud compiler? I would need this compiled on Windows (just with plain ghc, using packages lens and gloss): https://github.com/robinp/dragon-defense
12:14:39 <monochrom> yes but fewer people are experts on windows
12:15:24 <bootcode__> the code is pretty messy, intended for an LD25 entry
12:15:40 <bootcode__> monochrom: well, at least they have windows :)
12:16:50 <bootcode__> originally I planned to use haste to target js, but it choked on the Data.Text dep of lens
12:17:22 <bootcode__> might try to do a local lens install with the text lens part stripped however
12:18:24 <monochrom> "cabal install --dry-run lens" doesn't list text here
12:20:01 <bootcode__> haste-inst install lens tries text-0.11.2.3
12:20:04 * hackagebot swish 0.9.0.0 - A semantic web toolkit.  http://hackage.haskell.org/package/swish-0.9.0.0 (DouglasBurke)
12:20:06 * hackagebot configurator 0.2.0.2 - Configuration management  http://hackage.haskell.org/package/configurator-0.2.0.2 (BryanOSullivan)
12:20:41 <monochrom> text-0.11.2.3 comes with ghc 7.4.2
12:20:58 <monochrom> err, sorry, no
12:22:00 <neutrino_> can someone help me with this stm paper? http://research.microsoft.com/en-us/um/people/simonpj/papers/stm/stm.pdf
12:22:29 <neutrino_> i'm trying to understand writeMChan from page 6
12:25:25 <monochrom> I have text-0.11.2.3 from haskell platform. I start from haskell platform. "cabal install lens" builds fine
12:26:14 <hpaste> neutrino pasted “cannot understand this definition of writeMChan” at http://hpaste.org/79383
12:26:58 <neutrino_> actually i think i got it
12:27:17 <monochrom> oh, that is your specific question. we want mc to point to the end of the queue, for the next write.
12:27:33 <neutrino_> the end of the queue is always Empty?
12:27:37 <neutrino_> yeah.
12:29:14 <neutrino_> so basically c' <- newTVar Empty is like malloc and writeTVar mc c' is like incrementing a pointer?
12:29:37 <monochrom> yes. it is exactly like first-year imperative linked list code
12:29:39 <neutrino_> and writeTVar c (Full v c') is like linking from the previously empty c to the new empty location c'?
12:29:42 <neutrino_> ok.
12:29:57 <neutrino_> i've never done imperative linked list code, only read about it vaguely
12:31:48 <neutrino_> thanks for clarifying monochrom
12:31:50 <hpaste> wm pasted “Generic Lifting - witnesses” at http://hpaste.org/79384
12:31:57 <watermind> so this is closer
12:32:19 <watermind> the idea is that I'd provide a witness to the function wrap which would desambiguate between using Monad or Applicative
12:32:53 <watermind> but it doesn't seem able to resolve type equality :S
12:34:15 <`nand`> neutrino_: rebuilt ghc on my workstation from the binary
12:34:17 <`nand`> neutrino_: works fine
12:35:07 <`nand`> so that pretty much rules out any differences in how GHC was built; the only difference could be external (like glibc/gcc or some other surrounding parameters)
12:36:45 <watermind> hmm wait I think I know
12:45:27 <Sylvain_> Hi there !
12:52:16 <watermind> can ghc determine equality between type constructors?
12:52:40 <watermind> or is  ~  only useful with  types (i.e. 0-ary type constructors)?
12:53:43 <Saizan> it's useful for constructors too
12:54:03 <thoughtpolice> the kind of (~) is k -> k -> Constraint i think, so you should be able to use things that are not of kind-*
12:54:20 <thoughtpolice> (NB: i haven't tried this, but if you go into GHCi and ask ':k (~)' that's what you get)
12:54:38 <thoughtpolice> so i imagine it works as you expect
12:55:52 <watermind> :/
12:56:10 <watermind> yeap...
12:56:21 <watermind> not sure what is the problem here
12:56:57 <Sylvain_> Hello, I'm new to Haskell and I'm trying to understand monad transformers
12:58:38 <Sylvain_> For testing purposes, I'm coding a very simple game : the program draw 2 random numbers a and b and the player has to guess a*b
12:59:03 <hpaste> wm pasted “Type Equality  ” at http://hpaste.org/79387
12:59:28 <Saizan> watermind: 't' only appears as argument to type families in wrap's type, that means GHC will never be able to deduce which one is being used
12:59:37 <Sylvain_> My first function is : answer :: Int -> Int -> Int -> Writer (Sum Int) Bool
12:59:55 <Sylvain_> the Sum Int is for storing the score
13:00:11 <Saizan> watermind: define your Lift class in the curried version, it'll be easier
13:00:52 <watermind> Saizan: But when I do   :t wrap :: Int -> FST '([],Monad) Int     it shouldn't have to deduce it, just typecheck it
13:00:55 <Sylvain_> My second function is : randomNumber :: State StdGen Int
13:00:59 <watermind> Saizan: and it still fails
13:01:58 <Sylvain_> Is it possible to write a guess function which is StateT StdGen Writer (Sum Int) Bool and use the 2 functions above ?
13:02:18 <watermind> Saizan: not sure what you mean by curried version... where is the AxB->C  you're suggesting me to uncurry?
13:02:43 <Saizan> watermind: wrong, it still has to deduce what t is, knowing that FST t Int ~ [] Int doesn't help to determine t
13:03:15 <Saizan> watermind: at best you could figure out that the first field is [], but you won't know what the second one is
13:03:19 <acowley> Sylvain_: I take it your randomNumber action already works with your composite transformer stack?
13:03:19 <lambdabot> acowley: You have 1 new message. '/msg lambdabot @messages' to read it.
13:03:46 <watermind> Saizan: right right of course
13:04:04 <Saizan> watermind: Lift :: (* -> *, (* -> *) -> Constraint) -> Constraint
13:05:07 <Saizan> watermind: it'd work better to have a family from the witness' type to the class, btw
13:05:57 <Sylvain_> acowley_: my randomNumber don't use the stack, it's just State StdGen Int
13:06:14 <Saizan> watermind: or you could just define data Proxy ((* -> *) -> Constraint) = Proxy
13:07:01 <Sylvain_> acowley: Do I need to rewrite it using the target transformer stack or is there another mean ?
13:07:16 <Saizan> watermind: then class Lift (t :: * -> *) (c :: (* -> *) -> Constraint) where wrap :: c t => Proxy c -> a -> t a
13:07:17 <acowley> Sylvain_: Oops, sorry I misread that!
13:07:53 <Saizan> watermind: then monad = Proxy :: Proxy Monad; appli = Proxy :: Proxy Applicative
13:08:20 <watermind> Saizan:  (thinking... ... ..)
13:08:46 <mpu> When you use an AST, what is the best way to carry location information for each node?
13:09:19 <watermind> Saizan: need to think about what you just said for a little while, let me see
13:11:00 <Saizan> mpu: data AST = AST' :@ Location; data ASTInner = App AST AST | Lit Int | ...
13:11:19 <Saizan> mpu: sorry, s/AST'/ASTInner/
13:11:34 <Saizan> mpu: it's one way at least :)
13:16:07 <acowley> Sylvain_: Sorry for the delay. You will want to generalize your auxilliary functions to, e.g., randomNumber :: Monad m => StateT StdGen m Int
13:16:48 <acowley> Sylvain_: likewise, answer :: Monad m => Int -> Int -> Int -> WriterT (Sum Int) m Bool
13:17:27 <neutrino> hi
13:17:34 <neutrino> i have a question about formal logic
13:17:55 <neutrino> in this haskell paper they're talking about formal semantics, and they use a notation i forgot how to use
13:18:03 <Sylvain_> acowley: Thanks, I got it. I also find http://www.haskell.org/haskellwiki/All_About_Monads#Combined_Monads which contains more explanation of how to combine monads
13:18:10 <acowley> Sylvain_: The only wrinkle beyond the new types is that you need to dig into your stack to get to the Writer needed by answer, so you will use lift answer
13:18:15 <acowley> Sylvain_: Awesome!
13:18:20 <neutrino> it basically looks like a fraction with a formula above and a formula below
13:18:31 <neutrino> does this mean "if (above), then (below)"?
13:18:32 <acowley> neutrino: Search for natural deduction
13:18:40 <acowley> neutrino: yes
13:18:42 <neutrino> ok
13:18:49 <acowley> premises over conclusions
13:20:13 <neutrino> thanks
13:20:22 <neutrino> are premises the same as propositions?
13:21:01 <acowley> Sylvain_: One little gotcha you may want to consider is that you probably won't benefit from a lazy Writer, so you should use the Strict version.
13:21:23 <neutrino> hmm i guess it's not exactly like implication
13:21:28 <neutrino> http://upload.wikimedia.org/math/1/5/2/1526a08a0aa793a162becdc67f265bb5.png
13:21:36 <neutrino> how would you explain this formula acowley?
13:22:06 <neutrino> oh
13:22:16 <neutrino> "prop" is basically just a type declaration
13:22:19 <neutrino> ok
13:22:24 <mpu> neutrino: This is a contruction rule for propositions, it says that if A is a valid proposition, ~A is also a valid proposition.
13:22:38 <acowley> neutrino: A conclusion is a proposition, too, so it's not a very good term to distinguish them.
13:23:19 <neutrino> right
13:23:33 <watermind> Saizan: that was really nice, thanks :)
13:23:38 <acowley> neutrino: As mpu says, that is kind of a syntactic operation rather than an inference in the logic.
13:23:39 <neutrino> if there are two lines in a fraction, then it's "(above) <=> (below)" right?
13:23:51 <neutrino> acowley: well, i'd just call it type inference
13:24:19 <neutrino> it kind of looks like this to me:      (a :: prop) / (~ a :: prop)
13:24:42 <watermind> Saizan: all makes perfect sense now
13:27:12 <Saizan> watermind: cool :)
13:29:23 <Saizan> neutrino: that works in this case, but remember that in general this syntax is used to define arbitrary relations (you can see "_ prop" as a unary relation on terms)
13:29:43 <gunniy> What does <<loop>> mean? It's impossible to Google for! I'd guess it means that it thinks my program is in an infinite loop, but if it can work out that hasn't it solved the halting problem?
13:30:08 <Saizan> gunniy: no, it can only spot fairly simple loops
13:30:09 <Hafydd> It's possible to determine in _some_ cases when a program loops.
13:30:37 <Saizan> gunniy: only those where to evaluate x you immediately find that you have to evaluate x
13:30:56 <Saizan> gunniy: the simplest case being let x = x in x
13:31:01 <gunniy> Ok, any tips for debugging this, apart from looking at my code very hard
13:31:51 <Saizan> are you using mtl?
13:32:00 <rwbarton> compile with -Wall and be on the lookout especially for shadowing warnings
13:32:22 <gunniy> Shadowing warnings - i have one of those, i'll have a look
13:32:52 <gunniy> I'm not using mtl - nothing but prelude, just slightly too complex to pastebin
13:33:15 <Saizan> ok, mtl-2.1 had a bug causing this
13:33:43 <gunniy> It could do with a more google-able name btw
13:34:30 <glguy> gunniy: Halting problem is only hard if you want a solution that can answer for all programs, <<loop>> just detects one kind of non-termination
13:34:55 <Virus-X_> HaltTM, undecidable :D
13:35:32 <neutrino> @hoogle (a -> b) -> a -> a
13:35:33 <lambdabot> Data.Generics.Schemes everywhere :: (forall a. Data a => a -> a) -> (forall a. Data a => a -> a)
13:35:33 <lambdabot> Data.Generics.Schemes everywhere' :: (forall a. Data a => a -> a) -> (forall a. Data a => a -> a)
13:35:33 <lambdabot> Prelude until :: (a -> Bool) -> (a -> a) -> a -> a
13:37:05 <neutrino> huh
13:37:07 <neutrino> @type sortWith
13:37:09 <lambdabot> Not in scope: `sortWith'
13:37:16 <glguy> ?type sortBy
13:37:16 <lambdabot> (a -> a -> Ordering) -> [a] -> [a]
13:37:27 <neutrino> not the one i mean
13:37:36 <neutrino> @type GHC.Exts.sortWith
13:37:38 <lambdabot> Ord b => (a -> b) -> [a] -> [a]
13:37:41 <glguy> gunniy: If you need a better search term for <<loop>> try "blackhole detection"
13:37:46 <neutrino> is this related to Pierce's Law?
13:38:12 <gunniy> glguy: i thought blackholes were a problem in parallelism - how can a thunk become a black hole in sequential code?
13:38:47 <c_wraith> gunniy: let xs = tail xs in xs
13:40:08 <neutrino> in specific, Pierce's Law is the type of call/cc.
13:40:20 <neutrino> does this mean sortWith is somehow related to call/cc?
13:40:52 <glguy> neutrino: Not as far as I can tell. Why do you think it is?
13:41:27 <glguy> ?type \f -> sortBy (comparing f)
13:41:28 <lambdabot> Ord a1 => (a -> a1) -> [a] -> [a]
13:41:30 <neutrino> because the type of call/cc is supposed to be (a -> b) -> a -> a
13:41:51 <glguy> neutrino: You're missing a new things in that type
13:41:55 <neutrino> and, well, (a -> b) -> [a] -> [a] is fairly close.
13:42:01 <neutrino> what things am i missing glguy?
13:42:08 <glguy> parentheses
13:42:18 <neutrino> oh
13:42:21 <neutrino> of course
13:42:42 <glguy> ((a->b)->a)->a
13:42:42 <neutrino> @hoogle ((a -> b) -> a) -> a
13:42:43 <lambdabot> No results found
13:42:48 <neutrino> aww
13:44:48 <Cale> neutrino: No, it's ((a -> b) -> a) -> a
13:44:58 <Cale> ah, glguy already mentioned this
13:45:06 * hackagebot themoviedb 0.1.0.1 - Haskell API bindings for http://themoviedb.org  http://hackage.haskell.org/package/themoviedb-0.1.0.1 (PeterJones)
13:45:34 <glguy> Cale: have you considered letting <$> be fmap and <> be mappend?
13:45:48 <Cale> glguy: They are...
13:45:49 <Nereid> glguy: it already is
13:46:00 <glguy> so can (.) be compose and (++) be append, then?
13:46:05 <Nereid> can we put (++) and (.) back to prelude please
13:46:21 <Cale> But I like those definitions
13:46:29 <Nereid> I don't.
13:46:43 <monochrom> you can learn to be independent of lambdabot
13:47:25 <monochrom> this is what you get for a free service. where "free" is as in "free samples"
13:55:28 <neutrino> what does ⊢ mean in logic?
13:55:39 <neutrino> i can't find my logic book :\
13:55:54 <Peaker> Cale, lambdabot is useful for teaching beginners, but having a non-Haskell prelude makes that harder :(
13:56:00 <glguy> neutrino: http://en.wikipedia.org/wiki/Logical_consequence
13:56:04 <monochrom> a,b,c⊢y means: use assumptions a,b,c to prove conclusion y
13:56:04 <glguy> Syntactic consequence
13:56:31 <monochrom> and yeah, syntactic, i.e., use proof rules
13:57:40 <monochrom> a,b,c⊫y uses models (aka interpretations)
13:59:53 <Peaker> bah, the Dwarf spec defines a tree of DIEs (Debug Info Entries), and says something like: "If the writer feels like it, they can put a sibling ptr in a node. If they don't, you have to read the whole subtree to get to the sibling, have fun"
14:00:32 <Peaker> I wanted to convert the dwarf lib to be completely lazy, and let you traverse the tree in random order with O(1) memory use (with mmap)
14:00:38 <Peaker> but due to that silliness, I can't
14:00:53 <Peaker> I have to parse everything to parse anything
14:01:06 <bootcode__> any guess why this error happens:     Couldn't match expected type `Distribution.Simple.UserHooks.UserHooks' with actual type `Cabal-1.16.0.3:Distribution.Simple.UserHooks.UserHooks'
14:01:27 <Peaker> bootcode__, you've got 2 versions of the Cabal lib being used in the same build
14:01:44 <monochrom> yes, that's what you get for multiple versions living peacefully
14:01:47 <Peaker> bootcode__, you can get rid of the "shadowing" user version you have with: ghc-pkg unregister Cabal
14:02:19 <monochrom> the only problem is that one executable is too small for two versions
14:04:33 <Clint> how would i do "case mu of Nothing -> return Nothing; Just u -> get u" without case?
14:04:59 <monochrom> maybe (return Nothing) get mu
14:05:06 <monochrom> @type maybe
14:05:08 <lambdabot> b -> (a -> b) -> Maybe a -> b
14:05:15 <monochrom> yeah, in that order
14:05:21 <Clint> oh duh
14:05:24 <Clint> thanks
14:06:42 <mm_freak_> bruce schneier is an endofunctor that turns all automorphisms into identities
14:06:54 <monochrom> hahahah
14:07:34 <monochrom> @remember mm_freak bruce schneier is an endofunctor that turns all automorphisms into identities
14:07:35 <lambdabot> Done.
14:09:00 <bootcode__> is it a good idea to use ghc+cabal from the package manager? or would it be better to build own?
14:09:54 <mm_freak_> bootcode__: both are a good idea, but the combination isn't
14:10:05 <monochrom> not sure what you mean. but if the package manager has the ghc version and the cabal-install version you like, you can use them
14:10:16 <mm_freak_> in other words, if you're happy with the set of haskell packages your distrubtion provides, use your package manager
14:10:22 <mm_freak_> otherwise use cabal-install
14:11:44 <bootcode__> i meant using prebuilt cabal, but then getting new packages with cabal install
14:11:56 <neutrino> thanks glguy
14:12:02 <glguy> yw :)
14:12:13 <mm_freak_> bootcode__: that's what i assumed you meant
14:12:33 <monochrom> perhaps I should just tell you to read my http://www.vex.net/~trebla/haskell/sicp.xhtml
14:12:34 <neutrino> monochrom: what is the difference between the signle and double turnstile?
14:12:48 <monochrom> use inference rules vs use models
14:13:37 <neutrino> i'm not sure what models are?
14:13:40 <monochrom> inference rules means: you're given a bunch of machine-checkable rules, you stick to them. the rules may or may not be meaningful to you
14:13:49 <neutrino> ok
14:13:50 <neutrino> go on
14:16:19 <neutrino> monochrom: what does "use models" mean?
14:16:47 <dskippy> Does anyone know if there's a Haskell function akin to Perl's Digest::SHA::sha1_base64? There is a very simple script, called sha1pass, that I am trying to rewrite in Haskell. It uses sha1_base64. The thing is it takes a salt. The Haskell modules in Crypto and SHA Pure do not.
14:17:27 <monochrom> ⌛
14:17:31 <dskippy> I understand the basic theory of salting a password before encrypting it, but I don't know how exactly that Perl  function is doing it. It might append to the end of the string, or append to the front, etc.
14:17:51 <dskippy> I'd like a Haskell library function that basically does the task of sha1pass.
14:18:37 <mreh> passwdstore?
14:18:49 <bootcode__> monochrom: great! reading
14:18:59 <mreh> pwstore*
14:19:26 <mreh> dskippy: ^
14:19:38 <monochrom> models aka interpretations means: map symbols in the formula to a mathematical domain, do your reasoning there
14:19:58 <mreh> as an alternative to salting your own passwords
14:20:02 <acowley> neutrino: You could check out http://en.wikipedia.org/wiki/Model_theory for more information
14:20:58 <neutrino> monochrom: ah.
14:21:35 <neutrino> monochrom: but i see no difference between the rules of the model, and the set of rules in "you're given a bunch of machine-checkable rules, you stick to them."
14:21:41 <neutrino> acowley: checking that out
14:22:00 <neutrino> thank you very much
14:23:09 <dskippy> mreh: passwdstore I looked into. This uses only SHA256.
14:23:24 <monochrom> the rules of the model are exactly the rules of mathematics, which is "just think"
14:23:26 <dskippy> I am interested in supporting SHA1,256,512 and MD5.
14:26:17 <neutrino> dskippy: well, without salting you initialize an empty context (type Ctx), update it once with your string you want to digest, and then finalize that to get a bytestring
14:26:26 <mm_freak_> dskippy: check out the pwstore-fast library
14:26:37 <neutrino> dskippy: with salts, you either update the context with the salt and then your data, or first your data and then your salt.
14:26:47 <mm_freak_> (or pwstore-purehaskell if you prefer)
14:26:51 <neutrino> given that there are only two options, just check against the perl implementation and you should be happy
14:26:55 <mm_freak_> @hackage pwstore-fast
14:26:55 <lambdabot> http://hackage.haskell.org/package/pwstore-fast
14:27:25 <zzo38> Do you know if monad transformers laws implies   t Finalize = Finalize   and comonad transformers laws implies   t Initialize = Initialize   ?
14:27:31 <dskippy> neutrino: That sounds promising. You can update a context?
14:27:36 <Peaker> Clint, You probably want: maybe (pure Nothing) (Just <$> foo)  (you missed the Just <$>)
14:27:55 <Peaker> Clint, and that is exactly Data.Traversable.traverse
14:28:12 <orzo> How strickly does GHC respect the INLINE pragma?  If I define a composition operator using the unicode symbol, is there a chance I'll pay for it?  I have separate modules if that's relevent.
14:28:14 <zzo38> (Initialize is the endofunctor which all objects becomes the initial object. Finalize is the endofunctor which all objects becomes the final object. In all categories, Finalize (if it exists) is a monad and Initialize (if it exists) is a comonad; this should be easy to prive.)
14:28:20 <Peaker> @type [traverse, \foo bar -> maybe (pure Nothing) (Just <$> bar)]
14:28:22 <mm_freak_> dskippy: the only downside of pwstore-fast is that you don't get to choose the hash method (it uses PBKDF1 with SHA256), but you can set your salt yourself, if you wish (or just use the simplified IO interface that generates a random salt for you)
14:28:22 <lambdabot>     Couldn't match expected type `a0 -> Maybe a1'
14:28:22 <lambdabot>                 with actual type `Maybe a2'
14:28:22 <lambdabot>     In the second argument of `(<$>)', namely `bar'
14:28:26 <Peaker> oops
14:28:39 <thoughtpolice> orzo: INLINE makes GHC unconditionally inline the definition, regardless of its size
14:28:48 <orzo> wow
14:28:51 <mreh> dskippy: I would contact the maintainer of the package and ask if you could add support for those too?
14:28:57 <dskippy> mm_freak_: I need to chose. I am password cracking.  So I need to support what exists.
14:29:01 <Peaker> @type [traverse, \foo bar -> maybe (pure Nothing) (Just <$> foo) bar]
14:29:03 <lambdabot> [(a -> Maybe b) -> Maybe a -> Maybe (Maybe b)]
14:29:10 <orzo> thoughtpolice: does that mean INLINE is absolute?  It will never not-inline something i request to be inlined?
14:29:22 <mm_freak_> dskippy: if you're password cracking you should use the low level hash functions…  high level libraries will be too slow
14:29:25 <Clint> Peaker: the outer monad isn't a Maybe
14:29:28 <thoughtpolice> orzo: INLINEABLE gives ghc a little more leeway, basically saying the choice of inlining at the call site is up to the compiler (it operates slightly differently than INLINE at the low level)
14:29:31 <Peaker> Clint, yeah I made another mistake there:
14:29:35 <Peaker> @type [traverse, \foo bar -> maybe (pure Nothing) (fmap Just . foo) bar]
14:29:36 <lambdabot> Applicative f => [(a -> f b) -> Maybe a -> f (Maybe b)]
14:29:39 <thoughtpolice> orzo: well, if the inliner's run. i don't think it is at e.g. -O0
14:29:57 <orzo> thanks
14:30:00 <dskippy> mm_freak_: Yeah I can't seem to figure out how they relate to the ones in my reference implementation.
14:30:15 <Peaker> Clint, though if your function there also returns a maybe, you need something else, but similar
14:30:17 <mm_freak_> dskippy: most hashing libraries allow you to init, feed, close, so you would init once and refeed for every password
14:30:18 <Clint> Peaker: what i ended up with is: maybe (return Nothing) get (emailUser . entityVal =<< me)
14:30:31 <Peaker> Clint, your "get" is getting a Maybe value?
14:30:36 <mm_freak_> dskippy: check out the cryptohash library
14:30:39 <orzo> thoughtpolice: is your understanding from docs or source?
14:30:42 <dskippy> Yeah I have been.
14:30:50 <zzo38> Is my questions difficult for you to understand?
14:30:56 <Peaker> Clint, you put the "Just" wrapping inside your "get"?
14:31:27 <mm_freak_> dskippy: in the Crypto.Hash.SHA512 module for example you get three functions:  init, update and finalize
14:31:29 <Clint> Peaker: get is (key -> b m (Maybe val)) or so
14:31:43 <Peaker> Clint, does get sometimes return Nothing?
14:31:55 <Clint> Peaker: yes, if it doesn't find the key/val pair
14:32:07 <Clint> Peaker: or rather b m Nothing
14:32:08 <zzo38> All of the examples I gave still apply if x is zero
14:32:15 <mm_freak_> dskippy: 'init' isn't actually a function, but a simple value, and it gets reused, because it's a CAF…  so all you need to do is to update the initial context as much as needed and then apply 'finalize'
14:32:29 <thoughtpolice> orzo: from usage and reading, although it does seem to have changed a little since i last read the docs: http://www.haskell.org/ghc/docs/latest/html/users_guide/pragmas.html#inline-noinline-pragma
14:32:47 <mm_freak_> dskippy: if the salt is /prepended/, it's even better:  ctx0 = update init "my-salt"
14:32:55 <mm_freak_> then work with ctx0 as your initial context
14:33:06 <dskippy> mm_freak_: update it as much as needed, meaning, for example, once for the salt and once for the password, and finalize?
14:33:46 <mm_freak_> dskippy: how exactly you do it depends on where the password comes from…  for example it may pay off speedwise to use blaze-builder to actually build the passwords
14:33:58 <mreh> do I need to take any precautions if my calls to unsafePerformIO perform no side effects? Such as peeking a C variable defined constant?
14:33:59 <dskippy> I'll try this. I didn't realize that's what salting was doing. The libraries from other languages I've seen don't separate it that way. The all accept salt, pass, and give a string.
14:34:02 <dskippy> Makes sense though.
14:34:16 <Peaker> Clint, hmm.. if you have the form:  maybe Nothing ... then what you have is =<< or fmap.  If you have:  maybe (pure Nothing) ...  then what you have is some variation of traverse
14:34:24 <Peaker> @type traverse
14:34:26 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
14:34:46 <mm_freak_> dskippy: if you're performing a dictionary attack you can simply use the list monad to generate the candidates:  liftM2 mappend salts passwords
14:35:21 <mm_freak_> dskippy: assuming salts :: [Builder] and passwords :: [Builder]
14:36:14 <dskippy> Hm...
14:37:18 <Clint> Peaker: thanks
14:37:55 <mm_freak_> dskippy: the libraries in other languages just provide a higher level interface for what is essentially just hashing of a concatenation
14:38:18 <mm_freak_> in some cases though it's more complicated:  they might use HMAC and provide the salt as a key or vice versa
14:38:46 <nejucomo> Why can't I say: instance A t => B t where ...  ?
14:39:07 <mm_freak_> cryptohash also comes with an HMAC function in the Crypto.MAC.HMAC module
14:39:22 <mm_freak_> it's a higher order function, so you can simply provide the hash function as a plugin
14:39:26 <c_wraith> nejucomo: you can say it.  with -XUndecideableInstances, anyway
14:39:29 <acowley> nejucomo: Because that is interpreted as saying that every type t is an instance of B. Now, when you want that definition, go grab t's A instance.
14:39:29 <mm_freak_> nejucomo: because that's undecidable
14:39:37 <c_wraith> nejucomo: the thing is, you're declaring every type to be an instance of B
14:40:37 <mm_freak_> nejucomo: to give a concrete example of why this is a problem:  instance (Monad f) => Applicative f
14:40:47 <mm_freak_> what if there is an Applicative instance for f?
14:41:00 <mm_freak_> the usual solution is to give a newtype wrapper
14:41:09 <Peaker> Clint, not sure it's an improvement at all, but: maybe (return Nothing) f == fmap join . traverse f    (maybe there's a nicer way to formulate it still)
14:41:24 <mm_freak_> newtype AppOf m a = App (m a)
14:41:34 <mm_freak_> instance (Monad m) => Applicative (AppOf m)
14:42:33 <mm_freak_> that also gets along without FlexibleInstances
14:42:47 <orzo> hmm, is the INLINE pragma syntax for infix operator functions similar to other situations where the name of the function should be parenthesized?
14:43:02 * Clint nods.
14:43:47 <mm_freak_> orzo: yes…  the only exception to that rule is an infix/infixl/infixr annotation, where you specifically have to write the infix variant
14:43:54 <mm_freak_> infixl 7 `mod`
14:45:37 <neutrino> dskippy: yes you can
14:46:01 <neutrino> @type Data.CryptoHash.SHA1.update
14:46:03 <lambdabot> Couldn't find qualified module.
14:46:31 <mm_freak_> :t Crypto.Hash.SHA512.update
14:46:32 <lambdabot> Couldn't find qualified module.
14:46:41 <mm_freak_> :t SHA512.update
14:46:42 <lambdabot> Couldn't find qualified module.
14:46:44 <neutrino> http://hackage.haskell.org/packages/archive/cryptohash/0.5.1/doc/html/Data-CryptoHash-SHA1.html
14:46:44 <mm_freak_> too bad
14:46:54 <neutrino> anyways
14:47:06 <neutrino> monochrom: if you could expand a little bit (see my question above) that would be great
14:47:12 <mm_freak_> neutrino: your version is severely outdated, btw
14:47:34 <mm_freak_> the current version is 0.7.x and the module tree is below Crypto.Hash
14:47:48 <neutrino> here you go http://hackage.haskell.org/packages/archive/cryptohash/0.8.2/doc/html/Crypto-Hash-SHA1.html
14:47:57 <neutrino> @type Crypto.Hash.SHA1.update
14:47:58 <lambdabot> Couldn't find qualified module.
14:48:04 <mm_freak_> oh, i'm outdated, too =)
14:48:11 <mm_freak_> but it's probably just a dependency issue
14:48:29 <neutrino> what do you mean by "i'm outdated"?
14:49:08 <mm_freak_> i have cryptohash 0.7 installed (as a dependency)
14:49:14 <neutrino> ok.
14:49:34 <neutrino> gotcha.
14:49:49 * neutrino is confused by this single/double tee thing
14:51:42 <monochrom> where are you seeing ⊢?
14:55:13 <scooty-puff> can anything think of a better name for deleteMonotonicallyDecreasing :: [Int] -> Seq a -> Seq a, or a data structure other then Seq that has a snoc, efficient iteration, and random-access (delete only)?
14:55:31 <scooty-puff> *other than
14:57:14 <neutrino> monochrom: well i'm still not clear what the difference between single and double turnstile is
14:57:21 <neutrino> monochrom: they look exactly the same to me
14:58:31 <neutrino> scooty-puff: what does deleteMonotonicallyDecreasing do?
14:58:53 <kmels> hello, any reading recommendations for a 22 hour trip? i like type systems
14:59:06 <scooty-puff> delete all indices given in the list, requiring that the list of indices be strictly decreasing
14:59:25 <neutrino> just "delete".
14:59:31 <nejucomo> Ok, I was distracted in another channel.  So if I have instance A t => B t where ...  - I don't understand why "every type is an instance of B".  Why is it not "every type which is an instance of A is an instance of B"?
14:59:37 <neutrino> and encode the requirement in the type system.
14:59:38 <scooty-puff> k
14:59:52 <scooty-puff> err.. that could be tricky - though .. hmm
14:59:59 <neutrino> scooty-puff: no excuses!
15:00:04 <neutrino> ;)
15:00:11 <monochrom> ⊩ says, translate to a second system, and do your proof in the second system. perhaps you say, the rules of the second system may be the same as the rules of the first system. yes that's possible, but usually not the case
15:00:11 <nejucomo> I think the constraints on an instance head must not mean what I expect them to mean.
15:00:26 <neutrino> monochrom: i meant |=
15:00:34 <simpson> nejucomo:
15:00:38 <neutrino> i think you did too didn't you?
15:00:43 <simpson> Er. nejucomo, you're correct.
15:00:54 <acowley> nejucomo: They come in *after* the instance head has been resolved so that they can be used in the method definitions.
15:00:59 <monochrom> oops, yeah, ⊧
15:01:23 <scooty-puff> data Changes = Zero | Keep Delete | Delete Changes
15:01:33 <neutrino> monochrom: i'm just saying, "use rules in the second system" is isomorphic to "use rules in the first system" if the second system is isomorphic to the first system.
15:01:33 <scooty-puff> err..
15:01:41 <scooty-puff> data Changes = Zero | Keep Changes | Delete Changes
15:01:59 <neutrino> monochrom: so it doesn't really make a difference if the rules are defined in the second or first system, because rules of the second system can be translated to the first, right?
15:02:14 <nejucomo> acowley: if I have: instance A t => B (Maybe t) ...
15:02:24 <neutrino> scooty-puff: well, how would you write the type of a list of decreasing indices?
15:02:42 <nejucomo> Wouldn't this mean, by analogy, that every Maybe is a B?
15:02:47 <neutrino> expecting some zermelo here i guess
15:02:51 <acowley> nejucomo: Yes, exactly!
15:02:53 <nejucomo> -regardless of A?
15:03:10 <monochrom> are you still assuming that the two systems are isomorphic?
15:03:12 <scooty-puff> neutrino: think it may turn out its no more efficient that just calling delete repeatedly.. Seq is too good..
15:03:27 <acowley> nejucomo: This trips a lot of people up, btw
15:03:28 <scooty-puff> wait, nevermind, wasn't efficiency, was correctness
15:03:31 <neutrino> scooty-puff: you're giving up too easily
15:03:32 <neutrino> :)
15:03:42 <nejucomo> So this is also illegal: instance B t => A (Maybe t) ...; instanve C t => A (maybe t) ...;
15:03:59 <simpson> nejucomo: Right, because the instances *overlap*.
15:04:00 <scooty-puff> problem is that it has to come from mapWithKey
15:04:04 <neutrino> monochrom: "still"? i don't know if there's any reason to think they're not?
15:04:14 <scooty-puff> which has no type system guarantee of ordering (though its obvious what it is)
15:04:15 <monochrom> they are usually not
15:04:21 <acowley> nejucomo: Yup, looking at the head, A (Maybe t), the type checker can't differentiate them.
15:04:28 <scooty-puff> *mapWithIndex
15:04:36 <nejucomo> In all the cases I've discussed, is this an overlapping instance problem?  Is that distinct from undecidable instance?
15:04:43 <neutrino> why would you want to translate theorems from one system to another if their rules are different?
15:05:04 <neutrino> ok i understand if the target system embeds the source system
15:05:06 <nejucomo> I assume it's not possible or consistent to have a type checking system which includes the head constraints?
15:05:08 <neutrino> but other than that i don't
15:05:20 <acowley> neutrino: theorems about Monoids apply to the Sum Int model, but not everything about Sum Int applies to all Monoids
15:05:37 <neutrino> that's the embedding situation
15:05:41 <acowley> yes
15:05:54 <neutrino> but what about a situation where the embedding does not hold?
15:06:04 <simpson> nejucomo: Check out the OverlappingInstances extension for GHC.
15:06:05 <neutrino> i.e. where you gain some properties but lose others?
15:06:09 <neutrino> is it possible to model like this?
15:06:15 <hpaste> dskippy pasted “encrypt” at http://hpaste.org/79396
15:06:34 <nejucomo> simpson: I'm looking at http://www.haskell.org/ghc/docs/7.0.1/html/users_guide/type-class-extensions.html#undecidable-instances and it seems separate from overlapping instances.
15:06:35 <neutrino> do i need to reduce to a common sub-system, and then climb up to my target system?
15:06:38 <simpson> nejucomo: Also, you usually would either combine the constraints onto a single typeclass, or split the typeclass.
15:06:46 <acowley> Then it's not a model of the theory
15:06:49 <dskippy> Hey guys, I'm back and I am having trouble with the ByteString library.
15:07:01 <neutrino> acowley: mhm
15:07:16 <dskippy> I believe what I pasted above should give me the encrypted string from my /etc/shadow
15:07:25 <dskippy> But I get non-ascii back.
15:07:28 <simpson> nejucomo: Scroll down to the next section.
15:07:40 <acowley> Intuitively, Monoid is not a model for Sum Int because there are sentences about Sum Int that are not provable in Monoid.
15:07:40 <neutrino> ok, so modeling only means "embed in something more powerful, and use its strength to be able to reason more easily"
15:08:14 <neutrino> however, when reasoning through modeling, the model will not let you come to conclusions you couldn't come to in the original theory, right?
15:09:38 <acowley> Haskell, Sum Int |= Sum 3 <> Sum 4 == Sum 7 ... but Haskell,Monoid m |/- m 3 <> m 4 == m 7
15:09:48 <acowley> neutrino: I think it's the reverse of what you said
15:09:49 <neutrino> dskippy: no idea, i never used bytestring
15:09:50 <neutrino> sorry
15:10:07 <neutrino> acowley: in what way?
15:10:11 <dskippy> Hm, odd. I never expected it to give me non-ascii :)
15:10:28 <acowley> You can say things about specific models that are not true of the general theory.
15:10:44 <acowley> Such as, Sum 3 <> Sum 4 == Sum 7
15:10:49 <neutrino> oh, so (+, Int) is a model of Monoid?
15:10:54 <acowley> Right!
15:11:03 <neutrino> i thought you were saying Monoid is a model of Int
15:11:07 <neutrino> ok
15:11:20 <neutrino> yeah i can see that
15:12:11 <neutrino> so when using |=, you go from a general theory, translate your theorems to the model, reason inside that model, and then translate back to the general theory?
15:12:40 <mm_freak_> neutrino: all kinds of things are monoids, including things that don't look like numbers at all
15:12:45 <neutrino> how would a use of |= look when talking about (Int, +) and Monoid?
15:12:55 <neutrino> mm_freak_: i know that
15:13:12 <mreh> golfing question: (peek sess >>= peek) >>= (return . Right)
15:13:15 <mreh> that sucks
15:13:17 <acowley> Well, that translation back is probably going to be to a new theory that incorporates the parts of the model you needed for your inference if you're trying to define a generalization.
15:13:18 <companion_cube> Monoid m |= 0 + (x + 0) = x
15:13:48 <neutrino> companion_cube: where 0 is from (Int, +)?
15:13:54 <acowley> 0 = mempty
15:14:14 <companion_cube> yes , the monoid is on (+, 0)
15:14:17 <companion_cube> sorry for the notation
15:14:17 <neutrino> sure, i know 0 is mempty but i'm trying to identify which parts of the formula companion_cube come from the model
15:14:25 <Peaker> mm_freak_, AppOf == Control.Applicative.WrappedMonad?
15:14:37 <mm_freak_> the usual notation is (Int, +, 0)
15:14:44 <neutrino> since |= seems to bind a theory and a model
15:14:54 <mm_freak_> Peaker: probably
15:15:11 <neutrino> but i'm not sure what the model is in "Monoid m |= 0 + (x + 0) = x"
15:15:16 <mm_freak_> Peaker: yeah
15:15:29 <acowley> I would have written something like, Monoid m |- mempty <> (x <> mempty) = x and (Int,+,0) |= 0 + (x + 0) = x
15:15:56 <acowley> The m is assumming x::m
15:16:13 <neutrino> acowley: could you write the second in a logical sequence, without having mentioned the first?
15:16:13 <companion_cube> hmm, it's more that 0 + (x + 0) = x is true in any model of Monoid(Int,+,0)
15:16:19 <c_wraith> mreh: (foo >>= return . bar) always can be (fmap bar foo) or (bar <$> foo)
15:16:21 <neutrino> or is the first necessary context for the second?
15:16:46 <acowley> Ah! companion_cube is introducing another level of modelling!
15:17:01 <neutrino> is he?
15:17:23 <acowley> Sure, we could implement Int, +, and 0 in a variety of ways
15:17:28 <companion_cube> because the x is not bound
15:17:29 <neutrino> yes
15:18:08 <companion_cube> Monoid, [x → 42] |= 0 + (x + 0) = x  is an assertion in a given model
15:18:22 <neutrino> aha
15:18:54 <neutrino> whereas Monoid m |= 0 + (x + 0) = x is an assertion in all models?
15:21:44 <neutrino> thanks guys
15:21:49 <neutrino> that was really interesting
15:24:05 <mm_freak_> i find the usage of categories (including monoids) for programming very useful
15:24:17 <neutrino> why?
15:24:19 <mm_freak_> category theory is the best web framework
15:24:28 <neutrino> ?
15:24:58 <mm_freak_> neutrino: let's say a web server is something that accepts a request and either produces a response or rejects the request
15:25:37 <mm_freak_> if w1 and w2 are web servers, then w1 <|> w2 is also a web server that accepts a request, if either w1 or w2 accept it and returns the corresponding response
15:25:40 <neutrino> maybe in 1981
15:25:58 <mm_freak_> and there is the zero web server that rejects all requests
15:26:07 <mm_freak_> no, today
15:26:08 <neutrino> but yeah
15:26:14 <neutrino> i see what you mean
15:26:17 <acowley> http://coq.inria.fr/ is hosted on the zero web server :(((
15:26:18 <mm_freak_> most haskell web frameworks are built on that
15:26:25 <neutrino> acowley: so is hackage
15:26:37 <acowley> Yes, it's a popular choice
15:27:09 <mm_freak_> neutrino: the point is:  if you prove w1 and w2 to be correct web servers, then w1 <|> w2 is proven to be correct, no matter what w1 and w2 are
15:27:21 <neutrino> mm_freak_: you don't really "produce responses" nowadays, it's not an atomic return-style operation
15:27:31 <neutrino> you can emit a stream
15:27:41 <mm_freak_> neutrino: that's a response in this sense
15:28:31 <neutrino> mhm
15:28:47 <mm_freak_> neutrino: however, monoids aren't that useful…  web servers also form a category
15:29:13 <tertl3-laptop> someone make haskell on .net plz
15:29:19 <mm_freak_> if w1 and w2 are web servers, then so is the composition w1 . w2…  however, w1 and w2 don't know anything about each other
15:29:32 <mm_freak_> in other words:  CT allows you to build web components in total isolation
15:29:51 <shachaf> What is the type of (<|>)?
15:29:58 <neutrino> what is w1 . w2?
15:30:09 * hackagebot alpha 1.0.12 - A compiler for the Alpha language  http://hackage.haskell.org/package/alpha-1.0.12 (MarcCoiffier)
15:30:16 <mm_freak_> shachaf: the usual Control.Applicative one
15:30:28 <shachaf> That seems like a monoid to me.
15:30:31 <neutrino> mm_freak_: i thought you meant Alternative?
15:30:37 <mm_freak_> neutrino: hold on, i'm writing a new version of webwire that uses this concept =)
15:30:43 <acowley> neutrino: It's defined in Control.Applicative
15:30:44 <mm_freak_> neutrino: Alternative is from Control.Applicative
15:31:03 <neutrino> ah ok. i thought it was in Control.Alternative. bad memory
15:31:21 <neutrino> mm_freak_: ok, waiting
15:31:48 <mm_freak_> neutrino: in the meantime, both happstack and snap are built on that, and it's very useful
15:32:20 <neutrino> can you put in simple words what . does?
15:32:28 <mm_freak_> neutrino: speaking as someone who has developed web applications on the far other end of the abstraction ladder:  using PHP and the zend framework or TYPO3
15:32:41 <mm_freak_> neutrino: composition of web servers…  it's the one from Control.Category
15:32:46 <ParahSail1n> @ty (.)
15:32:47 <lambdabot> Functor f => (a -> b) -> f a -> f b
15:32:56 <mm_freak_> :t (Control.Category..)
15:32:57 <lambdabot> Control.Category.Category cat => cat b c -> cat a b -> cat a c
15:33:08 <neutrino> yeah but mm_freak_ i don't know what "composition of web servers is" and i've never used Control.Category
15:33:20 <neutrino> so you have to make it easier for me :)
15:33:49 <neutrino> i mean ok
15:34:06 <neutrino> the response from w2 is plugged into w1 as a request?
15:34:13 <neutrino> how is a response a valid request?
15:37:42 <mm_freak_> neutrino: it isn't, but a web server doesn't have to result in a response
15:37:55 <mm_freak_> neutrino: only the final composition has to
15:37:58 <neutrino> what else could it result in?
15:38:28 <mm_freak_> serve :: WebServer Request Response -> IO ()
15:38:48 <mm_freak_> w2 :: WebServer DatabaseResult Response
15:39:10 <mm_freak_> w1 :: WebServer Request DatabaseResult
15:39:22 <mm_freak_> w2 . w1 :: WebServer Request Response
15:39:31 <neutrino> mhm
15:39:43 <mm_freak_> that's highly simplified, but it's not far from what it actually looks like
15:39:48 <neutrino> so in that case it isn't really a "web" server
15:39:57 <neutrino> but some specific server still
15:40:08 <neutrino> but yes i see what you mean
15:40:12 <mm_freak_> since WebServer is also a family of applicative functors you can build components just like you build option parsers using optparse-applicative
15:40:17 <neutrino> snap calls these snaplets, right?
15:40:27 <c_wraith> No.
15:40:31 <mm_freak_> no, snaplet isn't categorical
15:40:35 <c_wraith> snaplets are much higher-level
15:40:35 <pqmodn> shachaf: if you were asking about the difference between (<|>) and mappend, compare them each with [Int] args, then Just Int args
15:40:39 <mm_freak_> s/snaplet/snap/
15:40:47 <neutrino> ok
15:40:55 <shachaf> pqmodn: I didn't say anything about mappend.
15:41:33 <ciaranm> but you were thinking it
15:41:41 <mm_freak_> neutrino: imagine you have a menu that comes from a database, and you have some page content
15:41:48 <pqmodn> my point is to illustrate the difference between Alternative and Monoid
15:42:05 <shachaf> I didn't say "Monoid", I said "monoid". :-)
15:42:05 <mm_freak_> liftA2 Page (menu . queryMenu) pageContent
15:42:07 <neutrino> ok
15:42:14 <shachaf> Which is only fair because mm_freak_ was talking about categories.
15:42:22 <pqmodn> my mistake, then
15:42:39 <mm_freak_> neutrino: now the great feature of this framework is that you can develop menu, queryMenu and pageContent in total isolation from each other
15:42:53 <mm_freak_> that's a big win in maintainability
15:43:20 <neutrino> yes
15:43:31 <neutrino> it is very good
15:44:04 <neutrino> but how will you compose systems that need to be modular, but those modules can't be all isolated?
15:44:11 <neutrino> that's not so easy.
15:46:53 <mm_freak_> neutrino: composition is the interface between modules
15:47:37 <neutrino> yes but here we can only go module 1 -> module 2 -> module 3
15:47:49 <neutrino> what if module 4 depends on data provided by 2, and by 3?
15:48:30 <mm_freak_> neutrino: Applicative (or Arrow, if you wish)
15:48:59 <neutrino> ah?
15:49:08 <neutrino> how would you use them?
15:50:27 <mm_freak_> neutrino: applicative style: m4 . liftA2 (,) m3 id . m2 . m1
15:51:03 <mm_freak_> neutrino: arrow style:  proc x1 -> do x2 <- m1 -< x1; x3 <- m2 -< x2; x4 <- m3 -< x3; m4 -< (x3, x4)
15:51:51 <neutrino> couldn't you do the same thing as arrow style with a monad?
15:52:05 <neutrino> and a monadic do block?
15:52:19 <mm_freak_> neutrino: it's not a monad
15:52:38 <neutrino> oh? why not?
15:52:41 <mm_freak_> (well, it is one, but a very inefficient one)
15:53:03 <acowley> My goodness do I prefer Applicative style. I keep thinking I'll eventually get used to Arrow sytanx....
15:53:03 <mm_freak_> neutrino: data Stream a = Stream a (Stream a)
15:53:15 <neutrino> go on
15:53:25 <mm_freak_> neutrino: write an Applicative instance for that one
15:53:38 <neutrino> acowley: i don't know, arrow syntax seems very simple to me, i couldn't understand the applicative.
15:53:43 <mm_freak_> a stream of functions applied to a stream of values is a stream of applied functions
15:53:55 <neutrino> neutrino: i don't know where to start (bear in mind it's 1 hour after my bed time)
15:54:03 <neutrino> ok
15:54:14 <mm_freak_> acowley: arrow syntax is much easier to understand once you know the rationale for arrows…  see http://ertes.de/new/tutorials/arrows.html
15:54:26 <neutrino> why are we talking about streams when we were talking about applicative?
15:54:27 <acowley> neutrino: You need to let Applicative into your heart
15:54:54 <neutrino> acowley: i want to. i really do.
15:55:52 <aavogt> there's no sugar for applicatives like http://hackage.haskell.org/packages/archive/haskell-src-meta/0.2/doc/html/src/Language-Haskell-Meta-QQ-ADo.html
15:56:06 <mm_freak_> neutrino: because my framework is using a super-duper-generalized version of Stream =)
15:56:25 <neutrino> ok
15:56:27 <neutrino> :
15:56:27 <mm_freak_> neutrino: the underlying problem of implementing Monad for Stream is the same, though, so this will make you understand why it's difficult
15:56:28 <neutrino> )
15:56:30 <neutrino> :)
15:56:45 <neutrino> go on
15:56:52 <acowley> mm_freak_: I've read that before. I've done a fair bit of work with HXT. Arrow notation still makes me go cross eyed and get sad simultaneously :(
15:57:00 <mm_freak_> neutrino: just try it yourself…  it's an eye opener
15:57:26 <neutrino> i've like literally never used Applicative.
15:57:28 <mm_freak_> acowley: to understand the full arrow notation, read the GHC manual
15:57:31 <mm_freak_> it isn't that bad
15:57:35 <neutrino> i just understood <$> and <*> the other day
15:57:50 <neutrino> and right now i can't remember exactly so i probably forgot it again
15:57:53 <mm_freak_> neutrino: the types are pretty much self-explanatory, if you can think abstractly a bit
15:58:20 <mm_freak_> neutrino: pure and (<*>) together are a generalization of zipWith
15:58:31 <mm_freak_> liftA2 = zipWith for ZipList
15:58:36 <mm_freak_> liftA3 = zipWith3 for ZipList
15:58:38 <mm_freak_> etc.
15:58:50 <mm_freak_> pure f <*> xs <*> ys <*> zs
15:58:58 <mm_freak_> zipWith3 f xs ys zs
15:59:06 <ion> @type zipWith Data.Traversable.for ZipList
15:59:07 <lambdabot>     Couldn't match expected type `[t0 a0]'
15:59:07 <lambdabot>                 with actual type `[a1] -> ZipList a1'
15:59:08 <lambdabot>     In the second argument of `zipWith', namely `ZipList'
15:59:12 <mm_freak_> that makes a whole lot of sense for streams like the Stream type i presented you
15:59:48 <neutrino> @type zipWith3
15:59:50 <lambdabot> (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]
15:59:59 <mm_freak_> fs <*> xs is the stream that has each function in fs applied to the corresponding element in xs
16:00:05 <neutrino> @type pure f
16:00:06 <lambdabot> (Applicative f, FromExpr a) => f a
16:00:16 <mm_freak_> :t pure
16:00:17 <lambdabot> Applicative f => a -> f a
16:00:18 <neutrino> @type <*>
16:00:20 <lambdabot> parse error on input `<*>'
16:00:25 <neutrino> @type (<*>)
16:00:27 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
16:00:53 <neutrino> ok i see that
16:01:09 <neutrino> right, i remember now, <*> was basically just passing further arguments.
16:01:14 <mm_freak_> if you think in containers, fmap allows you to map a function over all positions in the container
16:01:24 <mm_freak_> (<*>) allows you to map a different function at every position
16:01:27 <neutrino> @type fmap
16:01:28 <lambdabot> Functor f => (a -> b) -> f a -> f b
16:01:40 <neutrino> ok
16:01:42 <neutrino> yes
16:01:53 <mm_freak_> you see, the types are almost the same =)
16:02:02 <neutrino> heh :)
16:02:08 <mm_freak_> in (<*>) the function type is lifted as well
16:02:19 <mm_freak_> f (a -> b) vs. (a -> b)
16:02:50 <neutrino>  mhm
16:03:00 <mm_freak_> > getZipList $ [(+1), (3*), (^2)] <*> [1, 2, 3]
16:03:01 <lambdabot>   Couldn't match expected type `Control.Applicative.ZipList'
16:03:02 <lambdabot>              wit...
16:03:09 <mm_freak_> > getZipList $ ZipList [(+1), (3*), (^2)] <*> ZipList [1, 2, 3]
16:03:10 <lambdabot>   [2,6,9]
16:04:23 <mm_freak_> > zipWith ($) [(+1), (3*), (^2)] [1, 2, 3]
16:04:24 <lambdabot>   [2,6,9]
16:04:42 <neutrino> :))
16:04:57 <neutrino> @type zipWith
16:04:59 <lambdabot> (a -> b -> c) -> [a] -> [b] -> [c]
16:05:00 <mm_freak_> yeah, (<*>) is zipWith ($) generalized to functors
16:05:03 <neutrino> k
16:05:10 <neutrino> yeah
16:05:12 <mm_freak_> :t zipWith ($)
16:05:14 <lambdabot> [b -> c] -> [b] -> [c]
16:05:27 <neutrino> sure
16:05:32 <mm_freak_> now go ahead…  write the Applicative instance for Stream =)
16:05:40 <mm_freak_> (start with Functor, of course)
16:05:54 <watermind> I thought I was going to be able to define default Lifings for a type but I'm stuck :(  seems so close
16:05:54 <neutrino> i think i might have to cut this short
16:05:58 <hpaste> wm pasted “Liftings and defaults” at http://hpaste.org/79397
16:06:06 <neutrino> i would love to spend time with Applicative right now
16:06:13 <neutrino> but i literally can't keep my eyes open anymore
16:06:15 <neutrino> heh
16:06:21 <neutrino> this is too interesting :)
16:06:25 <watermind> any idea why that wrap' cannot have that default instance in the class
16:06:26 <mm_freak_> hehe
16:06:27 <watermind> ?
16:06:29 <neutrino> you're great at explaning this mm_freak_
16:06:35 <neutrino> we should continue tomorrow :)
16:06:49 <mm_freak_> thanks…  sure
16:06:50 <neutrino> ok? :)
16:07:38 <watermind> the first part is pretty straightforward... it allows us to do    lift monad (+1)  [1,2]  and  lift applicative (+1) [1,2]
16:07:54 <watermind> monad and applicative are witnesses to get the types right
16:08:00 <watermind> so monad :: Proxy Monad
16:08:11 <watermind> and appli :: Proxy Applicative
16:08:32 <shachaf> cmccann: What are you doing reading month-old questions on SO?
16:08:36 <watermind> now the idea was to be able to have easily definable defaults for these liftings
16:08:57 <cmccann> shachaf, finding ways to annoy you?
16:09:11 <Fuuzetsu> >Process haskell segmentation fault
16:09:17 <cmccann> anyway, that question has recent activity.
16:09:17 <Fuuzetsu> ;_;
16:09:19 <shachaf> cmccann: And what was that person asking me for, anyway?
16:09:24 <watermind> so I associate with types the constraint I want to be default
16:09:25 <cmccann> I have no idea.
16:09:41 <watermind> so e.g., for [ ] I could associate Monad
16:09:58 <cmccann> shachaf, perhaps you simply radiate an aura of nonspecific expertise.
16:10:31 <shachaf> cmccann: Also, did you see the fancy new lenses?
16:10:39 <watermind> so the goal would be to defined   Def [] = Monad  ;   instance LiftDef [] where ;    and automatically get default liftings based on monad
16:11:12 <cmccann> shachaf, I'm almost afraid to ask what might be fancy and new with lenses
16:11:15 <watermind> for that I need the liftDef class to have default definitions
16:11:15 <edwardk> which i would like to add we are not planning on switching to in the near future, just in case anyone gets the idea they shouldn't learn lenses because of some big imminent change =P
16:11:32 <watermind> and that's where I'm stuck :S
16:11:39 <Moggle> Anyone know if there are any good Haskell libraries for writing mp3s/oggs/wmas?
16:11:44 <edwardk> but they are neat
16:11:50 <Moggle> If there are not, I may be forced to right one and that would be terrible.
16:11:54 <Moggle> wirte*
16:11:56 <Moggle> ... write
16:12:07 <edwardk> shachaf came up with a way to make the treatment of prism and lens much more symmetric, at the expense of being able to use traverse directly as a traversal.
16:12:07 <shachaf> cmccann: Yes, this isn't "the new lens".
16:12:11 <edwardk> and more newtype noise
16:12:12 <shachaf> It's just a different representation.
16:12:24 <edwardk> but its pretty cool
16:12:35 <mreh> bah, can't I derive a Storable instance if all the constructors are in the right order?
16:12:49 <edwardk> elliott has been banging away building a lens branch that works that way so we can at least fully realize all of the issues with it
16:12:49 <mreh> s/constructors/fields/
16:13:13 <cmccann> I still haven't even installed the lens package because I'm too lazy to resolve dependency bullshit and my cabal-install binary was non-working for a while
16:13:27 <mreh> everyone is talking about lenses these days
16:13:27 <cmccann> haven't been doing much coding lately, really
16:13:37 <watermind> edwardk: I got quite lost on the whole lenses story... one day I read about them and they were an elegant way to work with record fields, then I dropped by and they seemed to have evolved beyond my recognition :S
16:14:00 <edwardk> watermind: there should be a video up this week explaining what the new lenses give you
16:14:18 <watermind> cool :)
16:14:19 <mreh> edwardk: is that from the NYCHUG?
16:14:34 <edwardk> watermind: the short answer is that they now generalize functors, foldable, traversable and functions in a more composable way. you already know how to use all the little pieces that i use to build lenses, this just makes those pieces more composable
16:14:41 <edwardk> mreh: yeah
16:14:49 <mreh> cool
16:15:11 <mm_freak_> watermind: why the types have changed drastically the interface is almost the same (except that you write composition in reverse)
16:15:12 <watermind> edwardk: it does sound pretty cool
16:15:14 <Moggle> huh, a .Net interop library
16:15:20 <Moggle> i am intrigued
16:15:27 <edwardk> watermind: the new form works better for reasoning about containers, maps, etc.
16:15:28 <mm_freak_> why → while
16:15:31 <mreh> that sounds pretty general
16:15:41 <shachaf> The main principle behind lens is to add newtype noise everywhere to make a bunch of unrelated types fit into a uniform shape.
16:15:46 <edwardk> > (1,2,3,4)^._2
16:15:48 <watermind> edwardk: ah, nice
16:15:48 <lambdabot>   2
16:15:53 <shachaf> All the symmetric representation does is extend that. :-)
16:15:57 <edwardk> > (1,2,3,4) & _2 .~ "hello"
16:15:59 <lambdabot>   (1,"hello",3,4)
16:16:20 <mreh> MOTHER OF GOD
16:16:27 <edwardk> the main benefits of the approach is you can do 'type changing assignment' like i did there
16:16:36 <djahandarie> @type ((1,2,3,4)^.)
16:16:37 <lambdabot> (Num t4, Num t3, Num t2, Num t1) => Getting a (t1, t2, t3, t4) t a b -> a
16:16:45 <edwardk> > [(1,2,3,4),(5,6,7,8)] & traverse._2 .~ "hello"
16:16:47 <lambdabot>   [(1,"hello",3,4),(5,"hello",7,8)]
16:16:51 <mreh> > (1,2) & _2 .~ "WUT"
16:16:52 <lambdabot>   (1,"WUT")
16:16:54 <shachaf> Well... Type-changing assignment is something you can get with any lens representation.
16:17:01 <mreh> ?!?!?
16:17:01 <lambdabot> Unknown command, try @list
16:17:03 <edwardk> > [(1,"hello",3,4),(5,"world",7,8)] & traverse._2 %~ length
16:17:05 <lambdabot>   [(1,5,3,4),(5,5,7,8)]
16:17:13 <shachaf> mreh: It just uses a type class for different tuple sizes.
16:17:20 <edwardk> shachaf: sure, but nobody _did_
16:17:29 <pqmodn> :t (^.)
16:17:31 <lambdabot> s -> Getting a s t a b -> a
16:17:44 <mm_freak_> shachaf: can you?  what about the classic data-lens representation?
16:17:45 <cmccann> lambdabot gonna stab you
16:17:50 <mreh> :t length
16:17:51 <lambdabot> [a] -> Int
16:17:53 <edwardk> mm_freak_: you need 4 parameters
16:17:56 <edwardk> and a custom category-like class
16:17:57 <Peaker> mm_freak_, you just need to add lots of type params :)
16:18:02 <shachaf> mreh: You generalize it exactly the same way you generalize these.
16:18:07 <shachaf> Er, mm_freak_:
16:18:12 <clahey> Have any of y'all read "To Mock a Mockingbird"
16:18:12 <clahey> ?
16:18:16 <mm_freak_> hmm
16:18:19 <edwardk> the benefits of this approach is that you can get that and still use (.) from the Prelude
16:18:23 <Peaker> mm_freak_, data Lens oldfield newfield oldrecord newrecord = Lens { get :: oldrecord -> oldfield, set :: newfield -> oldrecord -> newrecord }
16:18:26 <edwardk> clahey: yes
16:18:29 <shachaf> Here, let's generalize the representation s -> (a, b -> t)
16:18:49 <Moggle> ohey I could probably just find an encoder
16:18:51 <mm_freak_> hmm, indeed
16:18:54 <shachaf> @ty let _1 (x,y) = (x, \x' -> (x',y)) in _1
16:18:55 <lambdabot> (t, t2) -> (t, t1 -> (t1, t2))
16:18:57 <Moggle> there's got to be one of those for ogg files and such
16:19:05 <mm_freak_> why did i never think of that?
16:19:05 <Peaker> mm_freak_, oldfield/newfield/oldrecord/newrecord  are  a/b/s/t
16:19:05 <shachaf> See? It just works out naturally from type inference.
16:19:19 <mm_freak_> :t _1
16:19:20 <lambdabot> (Functor f, Field1 s t a b) => (a -> f b) -> s -> f t
16:19:21 <shachaf> If you make your own newtype wrapper you have to give the parameters explicitly.
16:19:32 <mm_freak_> Field1 s t a b
16:19:33 <mm_freak_> lol
16:19:33 <edwardk> _1 is overloaded to work with different tuple sizes and get proper inference
16:19:36 <mm_freak_> lambdabot stabbed me
16:19:54 <Peaker> no, edwardk stabbed you, with lambdabot as proxy
16:19:54 <shachaf> @ty view
16:19:56 <lambdabot> MonadReader s m => Getting a s t a b -> m a
16:20:11 <edwardk> instance Field2 (a,b) (a,b') b b' where _2 f ~(a,b) = (,) a <$> f b -- etc.
16:20:12 <mm_freak_> i'm gonna get a stab
16:20:59 * shachaf thinks the tuple representation is pretty nice.
16:21:16 <shachaf> The real advantage of lenses that the "lens" representation has is that it can represent a lot more than lenses.
16:21:27 <shachaf> Like traversals, lenses that focus on more than one value.
16:21:36 <shachaf> > (1,2) & both +~ 1
16:21:38 <lambdabot>   (2,3)
16:21:44 <mm_freak_> yeah, that seems like a nice feature to have
16:21:53 <mm_freak_> although i haven't quite found a use for it yet
16:22:06 <shachaf> > [("hello","there"),("lens","lenses")] & traverse._1.traverse %~ toUpper
16:22:08 <lambdabot>   [("HELLO","there"),("LENS","lenses")]
16:22:28 <mm_freak_> i could imagine using that in a game to refer to the same property in many objects
16:22:44 <pqmodn> > (1,2) & both %~ (1 +)
16:22:45 <shachaf> mm_freak_: Sure: world.monsters.traverse.appendages.traverse.position.x +~ 1
16:22:46 <lambdabot>   (2,3)
16:23:41 <mm_freak_> :t traverse
16:23:42 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
16:23:44 <simpson> world.monsters.active.position.towards(player) +~ 1
16:23:49 <mm_freak_> oh, it's just that one
16:23:57 <pqmodn> :t (&)
16:23:59 <shachaf> traverse is just ~ mapM
16:23:59 <lambdabot> a -> (a -> b) -> b
16:24:22 <clahey> :t flip ($)
16:24:23 <lambdabot> b -> (b -> c) -> c
16:24:33 <mm_freak_> that's actually very elegant
16:24:45 <mm_freak_> the towards view that is
16:25:10 <clahey> Does it exist?  That is quite slick.
16:25:14 <simpson> mm_freak_: I would expect that you would write a lens "towards" that could be used to do that.
16:25:20 <simpson> It doesn't exist, no.
16:25:23 <mm_freak_> clahey: i guess not, but it should be easy to write
16:25:25 <edwardk> clahey: (&) is in Control.Lens.Combinators
16:25:47 <simpson> Last time I started writing a game, I had a standard XYWH box which I made lenses for, and the lenses were for moving the entire box, resizing, reshaping, etc.
16:25:49 <edwardk> er Control.Lens.Getter for historical reasons and should move
16:25:58 <mm_freak_> clahey: you can use lenses to access the same data in a different representation, and towards is just that
16:26:21 <edwardk> simpson: i like the towards lens thats cute
16:26:50 <simpson> edwardk: In Bravo, I had to write those kinds of things. They turned out to be useful; you could have "lenses" which talked about positions relative to other positions.
16:27:21 <mm_freak_> towards :: Position -> Lens Position Position Position Position
16:27:39 <mm_freak_> just rotated so that (0, 1) gets 1 closer to the given position
16:27:55 <clahey> edwardk: I assume it's flip ($) since the only other implementation of that type is _|_.
16:28:07 <clahey> ?
16:28:07 <shachaf> That sounds like an Iso
16:28:19 <shachaf> clahey: There are totally other implementations that ⊥!
16:28:22 <shachaf> Like const ⊥
16:28:26 <shachaf> And const (const ⊥)
16:29:07 <shachaf> (But given that it was used several times above, I think you can work out how it behaves. :-) )
16:29:15 <clahey> shachaf: My point is that the only implementations of a -> (a->b) -> b are flip ($) or things which return ⊥, no?
16:29:30 <clahey> shachaf: You would think that, but I don't have my mind quite wrapped about lens yet.
16:30:02 <clahey> I suppose there could be unsafe things that return the same thing as flip ($).
16:32:05 <clahey> Whether or not that's what & does, I'm curious if I'm not forgetting something in my thinking that that must be its value.
16:32:14 <jmcarthur> i, too, like the towards lens
16:32:32 <jmcarthur> it inspires a lot of other interesting "transformation"-like lenses
16:32:37 <edwardk> clahey: yep
16:32:52 <jmcarthur> there could be lenses for, say, affine transformations and such
16:32:57 <mm_freak_> when i used data-lens i often had a 'polar' lens
16:33:10 <edwardk> jmcarthur: i've written some for reversible transformations
16:33:14 <mm_freak_> polar :: Lens (Complex a) (a, a)
16:33:22 <mm_freak_> + Floating a
16:33:26 <edwardk> :t Data.Complex.Lens._polar
16:33:27 <lambdabot> (Functor f, RealFloat a, Isomorphic k) => k ((a, a) -> f (a, a)) (Complex a -> f (Complex a))
16:33:36 <mm_freak_> towards isn't much different from that one
16:33:48 <edwardk> polar has a stated side-condition that its not a proper lens on 0
16:33:57 <edwardk> but that doesn't stop it from being useful
16:34:03 <edwardk> (it loses phase information there, after all)
16:34:16 <clahey> There it becomes a Getter?
16:34:18 <mm_freak_> edwardk: towards has the same problem, when the points overlap
16:34:40 <edwardk> at 0 i can't change its implementation. it just has a stated side-condiiton that it'll lose phase info at 0 ;)
16:35:00 <Moggle> Question: how many bits is a Float and is it possible to have floats of different precision
16:35:15 <Moggle> (I ask for music generation purposes)
16:35:25 <jmcarthur> mm_freak_: maybe instead of towards it could be distanceFrom
16:35:28 <mm_freak_> Moggle: check out the RealFrac class
16:35:34 <clahey> edwardk: Ah, it breaks the axioms of the typeclass.
16:35:40 <edwardk> yeah
16:35:42 <mm_freak_> jmcarthur: indeed
16:35:42 <Moggle> mm_freak: why are you so gosh darn helpful
16:35:45 <c_wraith> Moggle: In general, Float will be 32-bit, Double will be 64-bit.
16:35:51 <Philippa_> Moggle: Floats are single-precision - so something like 24 bits' precision, 7 for range and a sign bit
16:35:56 <Moggle> c_wraith: I'd like something _guaranteed_
16:36:04 <c_wraith> Moggle: the spec does not guarantee them
16:36:10 <c_wraith> Moggle: you're at the mercy of the implementation
16:36:11 <Philippa_> there aren't a lot of things you can do re music generation that need more than a single-precision float
16:36:18 <jmcarthur> c_wraith: a shame, that
16:36:24 <Philippa_> hell, you have to try pretty hard to need it for audio processing outright
16:36:36 <mm_freak_> Moggle: using RealFrac you can perform a run-time check, but there is no static guarantee, unless you implement your own type, or there may be a package on hackage
16:36:50 <Moggle> Philippa_: I like generating sine waves with floats between -1 to 1
16:36:56 <Moggle> It's a failing of mine.
16:36:57 <jmcarthur> Moggle: well, you could guarantee that you are using a C float or a C double by using CFloat or CDouble, I guess, but i don't know if C provides any guarantees either
16:37:01 <Moggle> I find it easier to work with floats rather than integers
16:37:09 <Moggle> as an engineering major, well... :P
16:37:21 <Philippa_> Moggle: oh, floats are *good* for audio. You just don't need more than single precision
16:37:24 <Moggle> jmcarthur: C is notorious for being terrible at that too
16:37:36 <Moggle> THOUGH
16:37:45 <Moggle> I think chars are defined to be 8 bits in one of the C specs
16:37:49 <Moggle> so I'll give C that much
16:37:51 <Philippa_> (and I wish like hell GPGPU support for new VST(i)s was normal!)
16:37:51 <Moggle> :P
16:38:04 <jmcarthur> Moggle: and we have Int8/Word8 for that ;)
16:38:07 <edwardk> ieee 32 bit floats have 1 sign bit, 8 exponent bits (biased), 23 explicit bits for the mantissa. which gives you 24 bits of mantissa due to the virtual 1 at the front.
16:38:14 <Moggle> jmcarthur: Yes, I love how Haskell has that
16:38:19 <Moggle> .Net has Int32 and the like as well
16:38:21 <Moggle> IT IS WONDERFUL
16:38:21 <elliott> no
16:38:25 <elliott> bytes can be >8 bits in C
16:38:26 <edwardk> to be pedantic ;)
16:38:28 <Moggle> To be 100% positive: word is an unsigned int, right?
16:38:28 <elliott> er, char that is
16:38:29 <c_wraith> Moggle: No, they're defined as the minimal addressable chunk of memory.  Some systems don't have 8-bit bytes
16:38:31 <elliott> CHAR_BIT etc.
16:38:40 <c_wraith> Moggle: the guarantee is that size_of(char) == 1
16:38:42 <hpaste> wm pasted “Liftings and defaults” at http://hpaste.org/79398
16:38:57 <watermind> I give up for now :S
16:38:57 <mm_freak_> and "char" is severly misnamed in C
16:39:20 <mm_freak_> it's very difficult to get encoding right in C
16:39:31 <Moggle> It's difficult to do anything with strings in C
16:39:32 <Moggle> :P
16:39:40 <mm_freak_> s/with strings//
16:39:46 <Moggle> haha
16:39:55 <jmcarthur> it's easy to manipulate memory in C
16:39:58 <jmcarthur> well
16:40:01 <Moggle> as a computer engineer, I have a certain fondness for the low-level memory management in C
16:40:03 <mm_freak_> that's easy in haskell as well
16:40:05 <jmcarthur> if you know what your types are
16:40:06 <Moggle> its very easy to work with
16:40:17 <mm_freak_> jmcarthur: in fact it's easier in haskell
16:40:20 <Moggle> but... STRINGS
16:40:23 <Moggle> striiiiiings
16:40:23 <jmcarthur> in haskell it's easy (and easier to be sure of what you're doing), but verbose
16:40:37 <jmcarthur> i love things like alloca though :)
16:40:47 <marxx> why doesnt this work?
16:40:54 <marxx> > mapM_ (putStrLn . show) [1..5]
16:40:56 <lambdabot>   No instance for (GHC.Show.Show (GHC.Types.IO ()))
16:40:56 <lambdabot>    arising from a use of ...
16:41:05 <jmcarthur> Moggle: if you haven't looked at it, you would probably really like haskell's FFI
16:41:10 <jmcarthur> *at it yet
16:41:14 <Moggle> I haven't looked into it jmcarthur
16:41:25 <flebron> marxx, mapM_ returns IO ()
16:41:26 <Moggle> I'm doing _tons_ of research right now as to how to make a proper music generation program in Haskell
16:41:27 <jmcarthur> Moggle: you can basically write C in haskell
16:41:28 <flebron> lambdabot can't print IO ()
16:41:33 <Moggle> O:
16:41:37 <Moggle> Color me... intrigued
16:41:37 <mm_freak_> jmcarthur: is it?  mapM_ (\i -> pokeElemOff ptr i 15) . map (^2) $ [0..9]
16:41:48 <jmcarthur> mm_freak_: yeah, it can be convenient, too
16:42:00 <jmcarthur> Moggle: see mm_freak_'s little example there :)
16:42:17 <mm_freak_> jmcarthur: not long ago we had a discussion here where someone insisted that python dictionaries are much easier than Data.Map in haskell
16:42:18 <marxx> flebron: and why isnt it printing ints?
16:42:23 <Moggle> Question: even if the size of floats isn't defined, can I at least find out what it is in my implementation programmatically?
16:42:25 <jmcarthur> mm_freak_: i was involved in that
16:42:40 <Nereid> marxx: because putStrLn is IO
16:42:42 <mm_freak_> jmcarthur: ok, well, i think the same applies here again
16:42:45 <flebron> marxx, I think lambdabot evaluates, it doesn't show you output
16:42:51 <Moggle> mm_freak_ speaking for myself, I would argue that they are moderately because imperative languages make that sort of thing easier
16:42:53 <Nereid> lambdabot does not execute IO actions.
16:42:59 <jmcarthur> Moggle: not this again
16:43:04 <Moggle> :P
16:43:08 <mm_freak_> Moggle: do they?
16:43:09 <jmcarthur> Moggle: haskell maps are far nicer for crazy things
16:43:09 <Moggle> Don't worry, I don't want to argue the point
16:43:16 <Moggle> I am working on music generation
16:43:20 <jmcarthur> Moggle: python maps are okay for silly naive things ;)
16:43:26 <Moggle> don't want to get into a programming argument on ease of use (when I have no experience with Haskell)
16:43:27 <mm_freak_> so are C pointers
16:43:36 <Moggle> well I do want to get into one
16:43:43 <mm_freak_> doing something complicated with C pointers makes you go crazy, whereas in haskell you can do it easily
16:43:46 <Moggle> but preferably when I have some kind of knowledge so I'm not arguing based on no information
16:43:48 <mm_freak_> haskell gets /operations/ right
16:45:02 <Peaker> I love Haskell but I disagree it's as usable as C for low-level memory management
16:45:19 <Peaker> Pointer chasing and such are not memory management
16:45:22 <hpaste> Moggle pasted “uh” at http://hpaste.org/79399
16:45:26 <Moggle> ON THE SUBJECT OF MAPS
16:45:29 <mm_freak_> Peaker: what's an example that is difficult?
16:45:31 <Moggle> this is pretty much my extent of experience with them
16:45:36 <Moggle> and is why I say they feel kind of awkward to use
16:45:43 <Moggle> did I do something WRONG or harder than I had to here
16:45:47 <Chathurga> I'm just getting into C now, pointers have a beautiful insanity about them
16:45:55 <Moggle> Chathurga: that they do
16:45:56 <Peaker> mm_freak_, doing code that has no dynamic allocations, controlling memory layout
16:46:05 <marxx> > mapM_ putStrLn $ words "aa bb cc"
16:46:07 <lambdabot>   No instance for (GHC.Show.Show (GHC.Types.IO ()))
16:46:07 <lambdabot>    arising from a use of ...
16:46:18 <Peaker> I guess the latter is a weak point, since C structs don't let you control layout that well
16:46:18 <marxx> meh
16:46:30 <marxx> this works in ghci
16:46:47 <jmcarthur> Moggle: i see you have started catching on to point free code
16:46:47 <Peaker> when I write C, my code has virtually no dynamic allocations
16:46:56 <jmcarthur> Moggle: your next hurdle will be finding the right balance ;)
16:47:07 <mm_freak_> Peaker: in haskell you can write a library that writes lenses into a bytestring for you for all storable types…  so again memory layout is easier in haskell than in C
16:47:09 <Moggle> jmcarthur: I'm getting better and it's mainly due to all the help here :P
16:47:38 <mm_freak_> dynamic allocation is as easy as importing Foreign.Marshal and using the functionality from there…  and it's again easier in haskell, because you get higher order functions for most things
16:47:40 <Peaker> mm_freak_, that's not memory layout, you don't control where that ByteString is. In C I can have it in my .bss or on the stack or on the heap, with an easy choice
16:47:53 <jmcarthur> Moggle: point free works best if you factor subexpressions into separate definitions liberally, so that your code reads more straightforwardly
16:47:57 <Peaker> mm_freak_, I write C code that has *no* dynamic allocations. I just can't do that with Haskell
16:48:07 <mm_freak_> Peaker: that's true
16:48:10 <Moggle> jmcarthur: yeah, my main problem with my haskell code is that I tend to make sure long one liners
16:48:19 <mm_freak_> to accept haskell you have to accept dynamic memory and GC
16:48:21 <Peaker> mm_freak_, tight control of memory resources is a very nice feature in C
16:48:32 <Moggle> super*
16:48:40 <mm_freak_> Peaker: it's not really a C feature, it's an ld feature there
16:49:00 <Moggle> jmcarthur: my question stands, am I using Data.Set correctly here?
16:49:03 <jmcarthur> Peaker: while you only have so much control over it, i would *almost* claim that minor heap allocations that are never promoted are *basically* not as bad as allocations in C anyway
16:49:03 <Moggle> It seems kind of... awkward
16:49:06 <mm_freak_> Peaker: for static stuff you can do that in haskell as well, except that you would need to add an assembly file into the compilation
16:49:07 <Peaker> mm_freak_, interesting perspective. However even if you ignore ld, C lets you do one big malloc at your main() and then nobody else needs to do any dynamic allocation
16:49:18 <acowley> Does anyone know if improved type nats are going to be in 7.8?
16:49:32 <Nereid> I thought they'd be in 7.6.2
16:49:35 <mm_freak_> Peaker: GHC haskell allows you to do that, too
16:49:43 <Peaker> jmcarthur, sure - but it's still worse than stack allocations in C or no-allocations at all
16:49:49 <jmcarthur> agreed
16:49:50 <Peaker> mm_freak_, how?
16:49:50 <acowley> Hm. In 7.6.1 they're deficient
16:49:52 <Ralith> mm_freak_: how do you do that in GHC?
16:49:54 <acowley> I don't know about 7.6.2
16:50:05 <jmcarthur> Moggle: looking. trying to figure what's going on
16:50:09 <Peaker> mm_freak_, any sub-expression in Haskell is likely to cause dynamic allocations
16:50:17 <mm_freak_> Peaker, Ralith: +RTS -H512m -M512m
16:50:23 <Ralith> mm_freak_: that is rather different.
16:50:30 <Moggle> jmcarthur: my apologies for making it incomprehensible, then.
16:50:34 <jmcarthur> Moggle: it's hard for me to see the boundaries between your arguments to foldl'
16:50:35 <acowley> There is not 7.6.2 release, so perhaps they are improved there
16:50:39 <Peaker> mm_freak_, no, what I mean is that in C, my calling convention between my functions can involve "get all allocations as arguments"
16:50:44 <Peaker> mm_freak_, something I can't really do in Haskell
16:50:50 <Nereid> they're basically there in 7.6.1, it's just that the constraint solver doesn't really know about them so they're basically useless
16:51:15 <mm_freak_> Peaker: so global variables?
16:51:29 <acowley> Nereid: As I understand it, you can't write typically useful instances since you can't differentiate them based on constructor.
16:51:31 <Peaker> mm_freak_, that's one useful way to allocate the data needed by everyone in the lower layers, yeah
16:51:48 <mm_freak_> Peaker: well, again, haskell can do that
16:51:49 <Peaker> mm_freak_, but these "global variables" are basically just "ld allocations" as you named them, and used by main only
16:52:07 <Peaker> mm_freak_, (others use sub-fields of them they get via ptr args)
16:52:19 <jmcarthur> Moggle: i would say your folds seem more awkward than your sets
16:52:21 <mm_freak_> Peaker: link a small assembly file that contains the memory area and use a Ptr to it
16:52:22 <Moggle> Side question: what IRC client is considered best here? I'm using Chatzilla and it's kind of... eh
16:52:33 <jmcarthur> let me try playing around with it
16:52:36 <Moggle> jmcarthur: how would I go about improving that? just tons of factoring out code and making it more readable?
16:52:38 <Moggle> oh, thanks
16:52:54 <Peaker> mm_freak_, I think we disagree on what "that" is. For me, it is writing functions whose allocation semantics are "Does not allocate anything", and practically writing my whole program that way
16:53:07 <acowley> Moggle: I'm in erc, and it's kind of... eh. I sometimes use Textual, which is also... eh. I usually assume the problem is me.
16:53:15 <Peaker> mm_freak_, The point isn't to have a memory area and mutate it
16:53:19 <mm_freak_> Peaker: that doesn't make sense, because haskell does not have those "functions" you're talking about
16:53:25 <Peaker> mm_freak_, the point is for that area to be used *in place of all other allocations*
16:53:35 <Moggle> acowley: I don't think it is. I've used mIRC and a few other programs and they've all also sucked. The only chat problem I've liked is Google Talk basically.
16:53:45 <Moggle> chat program(
16:53:48 <Peaker> mm_freak_, Haskell will still allocate stuff dynamically in my functions. I can't write a Haskell function that takes its allocations as arguments
16:54:04 <mm_freak_> Peaker: the execution schemes of haskell and C are so vastly different that you can't really compare the two…  chances are what you're doing manually in C is what the corresponding haskell program gets compiled to
16:54:15 <mm_freak_> Peaker: i understand that…  no, you can't
16:54:22 <acowley> erc has the advantage of living in my favored tiling window manage on OS X (aka emacs)
16:54:26 <mm_freak_> it's just that i don't see a use for that
16:54:29 <Peaker> mm_freak_, not really, because GC will still be more expensive than this technique in C
16:54:58 <acowley> Peaker: do you do any hobby microcontroller coding?
16:55:02 <Peaker> acowley, nope
16:55:05 <acowley> hm
16:55:26 <mm_freak_> Peaker: calling a function is already more expensive in C than what haskell does in most cases
16:55:27 <acowley> I'd like to find someone(s) to work with on at least a hacky DSL for generating Arduino code.
16:55:32 <Peaker> mm_freak_, traversing my pointers is more expensive already than what I do in C.  This approach in C is very CPU cache friendly, too.
16:55:33 <mm_freak_> Peaker: and no, inlining doesn't help
16:55:45 <Peaker> mm_freak_, how so?
16:56:08 <Peaker> mm_freak_, If you mean that GHC has very nice optimizations available to it that C doesn't, that's true, and makes Haskell code so much nicer
16:56:20 <mm_freak_> Peaker: functions don't exist at runtime…  there are code blocks that don't necessarily have a come-do-return structure
16:56:21 <Peaker> mm_freak_, but of course you can (and have to!) do these optimizations manually in C
16:56:50 <Peaker> mm_freak_, and what magic makes jumping between these code blocks cheaper than a CALL/RET?
16:57:01 <mm_freak_> there are optimizations you can't do in C without reinventing GHC's RTS and essentially writing STG in C
16:57:09 <Peaker> mm_freak_, example?
16:57:35 <mm_freak_> Peaker: not returning makes it cheaper…  for example GHC doesn't perform tail call optimization, because it doesn't have to
16:58:01 <mm_freak_> Peaker: and you get fine-grained parallelism for free in haskell
16:58:17 <Peaker> mm_freak_, GHC does perform TCO for strict/forcing code AFAIU
16:58:41 <Moggle> Maybe I should write an IRC client in Haskell.
16:58:48 <Peaker> mm_freak_, I agree about parallelism, and that may finally be a point where it becomes impractical to write C as efficient as Haskell (though we're not there yet)
16:58:50 <Moggle> That'd be a fun project.
16:58:50 <mm_freak_> well, GHC doesn't strictly use the STG technique anymore, so i'm a bit out of date there
16:58:52 <hpc> it's not so much that it does TCO as that the generated code is what it should be in the first place ;)
16:58:53 <mpu> I have, L :: * -> * (a type synonym) and I want to give it an Applicative instance, but ghc complains about my "Illegal instance definition", I use 'instance Applicative L where' what is wrong with this?
16:59:18 <Peaker> mm_freak_, Whatever it is that GHC does, C facilitates very cheap functions/jumping around, cheaper than forcing thunks/etc
16:59:31 <mm_freak_> Peaker: actually we are there…  just yesterday i have demonstrated a piece of code that is so difficult to write in C that my haskell implementation is the fastest one to this date
16:59:54 <Peaker> mm_freak_, cool, how much parallelism do you have there, though?
17:00:10 <mm_freak_> let me find the hpaste link
17:00:13 <Moggle> Ohey, is multithreading in Haskell easy?
17:00:15 <Peaker> mm_freak_, also, it's hard to demonstrate that it's very difficult in C, you need to talk to a dedicated C guy who agrees :)
17:00:16 <Moggle> to the GOOGLE
17:00:20 <jmcarthur> Moggle: quite
17:00:28 <acowley> mpu: type synonyms get substituted rather early on, so aren't allowed for instances. There is a LANGUAGE pragma TypeSynonymInstances, however.
17:00:32 <jmcarthur> Moggle: just use forkIO
17:00:41 <Peaker> Moggle, good parallelism is hard in Haskell, but much easier than in other languages
17:00:41 <jmcarthur> Moggle: of course, if it's parallelism you're after, there are often better ways
17:00:52 <mpu> acowley: I used it I think.
17:00:58 <mm_freak_> Peaker: http://hpaste.org/79286
17:01:22 <mm_freak_> Peaker: a few people have tried and failed to outperform my code in C/C++ =)
17:01:32 <acowley> mpu: In general, you will want to use newtypes instead of type synonyms to make the type really distinct.
17:01:49 <mm_freak_> Peaker: good parallelism in haskell requires some experience, but is actually very easy to achieve
17:02:12 <Peaker> mm_freak_, By "good parallelism" I also mean low data overhead, predictive algo's, etc.
17:02:20 <Peaker> mm_freak_, it's much easier, but still hard
17:02:32 <mm_freak_> i don't understand what you mean
17:02:41 <Peaker> mm_freak_, sure the correctness and "getting CPUs busy" part is easy
17:02:43 <mpu> acowley: Ghc suggests that I could use FlexibleInstances, I don't really get it, my instance seems (syntactically) clean.
17:02:56 <hpc> Peaker: it's an up-front hardness
17:02:59 <acowley> I'll just throw this out there, concurrency (ala forkIO) with boost or C++11 is surprisingly nice.
17:03:06 <acowley> mpu: hpaste it
17:03:09 <hpc> (if you know what i mean)
17:03:15 <Peaker> mm_freak_, but the "low inter-core communication overhead" and doing the right amount of "predictive/optimistic work", etc are hard problems still
17:03:18 <c_wraith> mpu: FlexibleInstances typically means you have a concrete type instead of a type variable in the instance head
17:03:30 <acowley> And don't hesitate to turn on FlexibleInstances
17:04:04 <c_wraith> FlexibleInstances can do no harm. It just isn't what the original Haskell spec allowed.
17:04:07 <Peaker> mm_freak_, there was a talk (I think by dcoutts ?) about how Haskell is still not quite as good as OpenMP in a certain (important) benchmark, and how it's going to improve
17:04:26 <mpu> c_wraith: My code is 'instance Applicative L where', so except if the synonym L is substitued, I have no concrete type.
17:04:27 <mm_freak_> Peaker: ./primes {200..299}
17:04:40 <acowley> OpenMP is also pretty great when it fits your problem
17:04:53 <c_wraith> mpu: type synonyms are always expanded
17:05:01 <jmcarthur> Moggle: i don't know what this code is doing, so it's hard for me to be confident in refactorings
17:05:08 <acowley> It's basically the same as changing map to parMap and just trusting it to do the right thing.
17:05:12 <mpu> c_wraith: they could be a bit later
17:05:26 <jmcarthur> Moggle: why are you applying tails to abns and then just using the head of each tail in the fold?
17:05:36 <mm_freak_> Peaker: on my machine that takes 10.6 seconds with one core, 5.6 seconds with two
17:05:37 <mpu> c_wraith: And if it is the case, what is the point in TypeSynonymInstances?
17:05:46 <jmcarthur> Moggle: (if i'm even reading it right)
17:05:50 <c_wraith> mpu: the other thing that sometimes causes FlexibleInstances to be required is using the same type variable multiple times
17:06:11 <c_wraith> mpu: what's L defined as?
17:06:22 <mm_freak_> Peaker: with four cores (maximum here) it takes 3.7 secs
17:06:29 <Peaker> mm_freak_, that sounds great, though it doesn't really prove much about the general case
17:06:42 <Peaker> mm_freak_, nor do you know how close you are to the optimum
17:06:44 <mpu> c_wraith: type L = StateT (Int {- line num -}, String) Maybe
17:06:46 <mm_freak_> Peaker: it shows why i don't believe in benchmarks by others
17:06:58 <mm_freak_> Peaker: over the years i have become good at writing very fast haskell programs
17:06:59 <Peaker> mm_freak_, the work on nested-data-parallelism is for a reason, for example :)
17:07:14 <c_wraith> mpu: ah.  It's the concrete types in there (Int, String, Maybe)
17:07:26 <c_wraith> mpu: but that should already have an applicative instance
17:07:41 <jmcarthur> Moggle: ah, i was indeed misunderstanding it
17:07:45 <mm_freak_> Peaker: certainly…  but let me put it this way:  you get the parallelism for free and your program does run faster
17:07:48 <acowley> and if you want a different Applicative instances, you *need* a newtype.
17:07:48 <jmcarthur> you are using the whole tail after all
17:08:01 <Peaker> mm_freak_, did anyone try just translating that code to C and use OpenMP for the parMap?
17:08:06 <mpu> c_wraith: This does not say so I think: http://hackage.haskell.org/packages/archive/mtl/1.1.0.2/doc/html/Control-Monad-State-Lazy.html
17:08:16 <Peaker> mm_freak_, that is nice, I agree, it's just not what I meant by "good parallelism"
17:08:29 <mm_freak_> Peaker: i know…  well, feel free to translate it
17:08:31 <c_wraith> mpu: that's an ancient version of mtl
17:08:34 <Peaker> though it is literally good, and it is parallelism :)
17:08:48 <mm_freak_> Peaker: i'd be happy to be proven wrong =)
17:08:49 <Peaker> mm_freak_, I'm working on something more important though, of making Haskell FFI to C much easier :)
17:09:03 <mm_freak_> honestly i've never used the FFI
17:09:04 <mpu> c_wraith: oops, it is deprecated...
17:09:10 <c_wraith> mpu: there have been 7 mtl releases since then...
17:09:15 <acowley> mpu: http://hackage.haskell.org/packages/archive/transformers/0.3.0.0/doc/html/Control-Monad-Trans-State-Lazy.html
17:09:18 <mm_freak_> well, i certainly did use the FFI, just not directly =)
17:09:27 <mpu> c_wraith: I used google results...
17:09:39 <Moggle> @jmcarthur: I can explain anything if needed
17:09:40 <lambdabot> Unknown command, try @list
17:09:47 <Peaker> mm_freak_, well, I just had a terrible time wrapping a C library with the FFI
17:09:49 <jmcarthur> Moggle: is this a PE problem?
17:09:52 <Peaker> so I'm gonna try making FFI much easier
17:10:00 <Moggle> jmcarthur: Yes, alas. :(
17:10:08 <Moggle> jmcarthur: I feel so bad when people ask me that now and I blame shachaf.
17:10:12 <mpu> c_wraith: I even have Alternative, awesome. Thanks c_wraith and acowley.
17:10:13 <jmcarthur> Moggle: could you link me to it?
17:10:26 <mm_freak_> Peaker: in many cases FFIing to a C library is more expensive than just rewriting the library in haskell
17:10:46 <mm_freak_> "expensive" in terms of programmer hours
17:11:01 <Moggle> jmcarthur: https://projecteuler.net/problem=23
17:11:17 <Peaker> mm_freak_, if the API is ~10 functions with ~5 structs, and there are about ~5KLOC of C code, I'm betting on FFI :)
17:11:30 <jmcarthur> ah, i see
17:12:01 <mm_freak_> Peaker: if a bunch of IO actions is sufficient, yes…  also a page of C code hardly does anything, so the equivalent haskell code is probably just 300 lines
17:12:53 <Peaker> mm_freak_, C can be much more concise than that
17:12:58 <Moggle> jmcarthur: the thing I found most awkward about sets in Haskell is naming them inside the lambdas
17:13:04 <Moggle> I did set and set' and it felt so weird
17:13:12 <Chathurga> abundant = (<) <*> sum . factors'
17:13:17 <jmcarthur> you should name them based on what they mean, just like with lists
17:13:20 <Chathurga> good god I love <*>
17:13:32 <mm_freak_> after FFI-wrapping a C library you almost always have to write a higher level library around that one anyway, and the expense is often the same as rewriting the C library
17:13:35 <Moggle> Chathurga: that is witchcraft and I will not have it
17:13:49 <Chathurga> Haha
17:13:49 <Moggle> (Another operator for me to look up :D)
17:13:51 <mm_freak_> also you often have to rewrite just to get rid of the GPL
17:13:58 <jmcarthur> Moggle: you will love applicative :)
17:14:09 <jmcarthur> which is of course somebody's nick here :\
17:14:09 <Peaker> mm_freak_, I think this would be closer to 800 lines in Haskell (Basically FreeType OpenGL wrapping, with algorithms to fill up textures efficiently, lots of OpenGL munging, etc)
17:14:31 <Moggle> jmcarthur: as I recall, I was on the Learn You a Haskell page dealing with the applicative style or whatever and I stopped reading halfway through because I had to study for finals :P
17:14:48 <Chathurga> Moggle: It just means x < (sum . factors') x
17:14:48 <mm_freak_> Peaker: in that case yeah, the haskell version isn't going to be shorter in expression, but still shorter in number of code lines
17:15:13 <Peaker> mm_freak_, 5KLOC -> 800 lines is my estimate, but just 300 lines of FFI wrapping
17:15:16 <Chathurga> Except I get to omit x from the definition
17:15:52 <mm_freak_> Peaker: my estimate is still lower, because in haskell you have first class actions
17:16:15 <mm_freak_> just think of error handling in C
17:16:18 <Peaker> mm_freak_, well, it's all just throwing guesses into the wind :)
17:16:29 <mm_freak_> most explicit error handling in C disappears in the haskell version
17:16:42 <Peaker> mm_freak_, There's a macro to do that:  CHECK_CALL(func, (arg list), goto_label_in_err)
17:17:02 <Peaker> and a couple of lines at the end of the function to free resources/return err at the label
17:17:11 <Peaker> (very few of the lines relate to error handling)
17:17:22 <mm_freak_> there is still the error threading through a stack of function calls…  you need to do that manually
17:18:04 <Peaker> the error label has:  return -1; or such, and the caller has CHECK_CALL too,  or just:   if(0 != other_func(....)) goto Error;
17:18:35 <mm_freak_> well, CHECK_CALL_INT, CHECK_CALL_PTR, CHECK_CALL_…
17:18:38 <Peaker> doesn't add lines at the call-site, does add a couple of lines for errors in each function. But functions are >10 lines mostly, so it's less than 10% of the code
17:18:58 <Peaker> mm_freak_, actually the CHECK_CALL is just for freetype2 errors. The direct if() goto  is used for other things
17:19:14 <Peaker> (which just makes the line slightly uglier, but is still in one line :)
17:19:40 <mm_freak_> Peaker: you're missing the big picture:  comp1 <|> comp2 <|> comp3
17:19:44 <mm_freak_> then comp1 fails, try comp2
17:19:46 <mm_freak_> etc.
17:20:00 <Peaker> mm_freak_, have you used Graphics.Rendering.OpenGL? :)
17:20:28 <mm_freak_> except for the actual opengl plumbing, where you can write some useful combinators, but not much can be done there…  the actual application logic is far easier and more concise to express in haskell
17:20:29 <Peaker> what a terrible API :(
17:20:37 <mm_freak_> yes, i've used it
17:20:43 <mm_freak_> it's not much better than the C API
17:21:00 <mm_freak_> but you still have haskell to work around it…  in C you effectively can't work around it
17:21:31 <Peaker> anyway, I'll go back to making FFI bearable :)
17:21:39 <mm_freak_> have fun =)
17:22:41 <Ralith> aren't the haskell opengl bindings all pretty out of date?
17:22:57 <Peaker> Ralith, ?
17:23:05 <Peaker> in what sense?
17:23:31 <jmcarthur> Ralith: they only lack opengl 4, really
17:23:48 <Ralith> jmcarthur: they've got 3?
17:23:50 <Ralith> nice
17:23:51 <jmcarthur> Ralith: the raw ones, that is. the "high level" (not really) ones only support 2, i think
17:23:53 <marxx> how can I make this work without assigning action result to a variable first?  mapM putStrLn <action returning IO String>
17:24:00 <Ralith> I thought the high level ones were still around 1
17:24:04 <jmcarthur> they are
17:24:08 <Ralith> well then
17:24:12 <jmcarthur> they just haven't changed much
17:24:14 <Chathurga> Moggle: What are you using sets for on 23? I happened to use them too but maybe not for the same reason
17:24:18 <cmccann> :t \x -> mapM putStrLn =<< x
17:24:20 <lambdabot> IO [String] -> IO [()]
17:24:20 <jmcarthur> i see no reason not to use openglraw anyway
17:24:33 <Chathurga> It's nice seeing someone going through euler in haskell at the same time as me
17:24:36 <Ralith> high level bindings are nice sometimes
17:24:40 <jmcarthur> the high level stuff isn't really high level anyway. you still have to manipulate pointers
17:24:40 <marxx> that should have been actiob returning IO [String]
17:24:48 <Ralith> ah, well
17:24:59 <jmcarthur> Ralith: the only thing you get with the high level bindings is an inability to merely use the standard opengl documentation
17:24:59 <Moggle> Chathurga: It wants to know the sum of the numbers that aren't sums of two abundant numbers
17:25:04 <Ralith> hah
17:25:05 <Ralith> kay
17:25:14 <cmccann> marxx, see what I said above
17:25:15 <Nereid> :t ?action >>= mapM_ putStrLn
17:25:17 <lambdabot> (?action::IO [String]) => IO ()
17:25:20 <Moggle> Chathurga: So, I make a set of all the numbers from 1..28123, and then subtract all the possible combinations of summed baundant numbers from it
17:25:35 <marxx> cmccann: thanks. I know about =<< but didnt think it eould work. I see why it does though
17:25:35 <cmccann> marxx, also you probably want mapM_ there I think
17:25:36 <Moggle> Chathurga: the remaining numbers aren't sums of abundant numbers, and then I sum those
17:25:44 <Chathurga> Ah yup basically the same
17:25:49 <marxx> cmccann: yeah
17:25:53 <Moggle> It's quite slow in practice
17:25:55 <Moggle> I blame Haskell
17:26:03 <Moggle> I wish I had been able to use an array :/
17:26:07 <Moggle> it'd be faster than a set for this problem
17:26:11 <Moggle> MUTABLE array*
17:26:25 <Moggle> But I heard dire warnings of how bad the performance of arrays were in haskell so :(
17:26:46 <hpc> haskell arrays aren't slow
17:26:50 <mm_freak_> Moggle: ignore the warnings
17:26:52 <Nereid> Moggle: where did you hear that.
17:26:55 <hpc> but the language can sometimes encourage you to do slow things with them
17:26:56 <Chathurga> Moggle: How long does it take to run?
17:27:24 <Moggle> Chathurga: uh, I had to compile it, and ~15 seconds as I recall?
17:27:35 <Moggle> I'll run it now
17:27:36 <Chathurga> Ah yeah same as me
17:27:37 <Moggle> one second
17:27:40 <hpc> haskell IOArray has exactly the same performance characteristics as arrays in a language like java
17:27:45 <jmcarthur> i guarantee you this can be written more efficiently
17:27:55 <hpc> immutable arrays perform nicely until you try to "modify" one
17:28:00 <hpc> in which event, it's done as a copy
17:28:08 <Moggle> hpc: IOArray is mutable, right?
17:28:14 <Moggle> Chathurga: ~10 seconds there
17:28:17 <hpc> Moggle: yes
17:28:20 <mm_freak_> hpc: not necessarily
17:28:20 <c_wraith> hpc: well.  IOUArray does.  IOArray has unfortunate GC interactions, sometimes.
17:28:28 <mm_freak_> hpc: see the vector and repa libraries
17:28:42 <Moggle> hpc: Why on earth would anyone use an immutable array as opposed to a mutable one?
17:28:50 <mm_freak_> Moggle: i do it all the time
17:28:55 <hpc> Moggle: pure code wants very fast random access
17:28:56 <Moggle> mm_freak_: example/reasoning?
17:28:59 <acowley> Moggle: To indicate its immutability
17:29:04 <Moggle> hpc: so it's for fast-reading?
17:29:04 <hpc> see: an RTS game terrain grid
17:29:06 <Moggle> NOT writing?
17:29:15 <jmcarthur> Moggle: with fusion it can actually be REALLY fast
17:29:22 <Moggle> jmcarthur: fusion?
17:29:27 <mm_freak_> Moggle: i'm even using boxed immutable arrays
17:29:29 <hpc> @hoogle freeze
17:29:29 <lambdabot> Data.Array.MArray freeze :: (Ix i, MArray a e m, IArray b e) => a i e -> m (b i e)
17:29:30 <lambdabot> package safe-freeze
17:29:30 <lambdabot> Data.Text.Array unsafeFreeze :: MArray s -> ST s Array
17:29:39 <hpc> you can build an array with a mutable operation
17:29:42 <hpc> then freeze it
17:29:44 <jmcarthur> Moggle: a simple example of fusion is turning  map f . map g  into  map (f . g)
17:29:54 <Chathurga> Moggle: Woops mines twice as slow. I see why, silly me
17:29:56 <Moggle> hpc :O
17:30:07 <jmcarthur> Moggle: but we have an array library that some pretty crazy fusion, even with mutable arrays under the hood
17:30:11 <hpc> a safe freeze will do one final copy and return that
17:30:11 * hackagebot unix-compat 0.4.1.0 - Portable POSIX-compatibility layer.  http://hackage.haskell.org/package/unix-compat-0.4.1.0 (JacobStanley)
17:30:13 <jmcarthur> Moggle: all under a purely functional interface
17:30:20 <mm_freak_> Moggle: http://hackage.haskell.org/packages/archive/instinct/0.1.0/doc/html/src/AI-Instinct-Brain.html#activation
17:30:34 <mm_freak_> Moggle: this is my code for calculating the activations of a neural network
17:30:35 <Moggle> jmcarthur: I'll have to rewrite my solution to Problem 23 then using Arrays.
17:30:46 <Moggle> jmcarthus: What's the fastest mutable array in Haskell?
17:30:46 <mm_freak_> it's using a boxed immutable vector and is very fast
17:30:59 <jmcarthur> Moggle: use http://hackage.haskell.org/package/vector
17:31:04 <hpc> so what exactly is the difference between vector and array?
17:31:11 <mm_freak_> Data.Array is faster than Data.Vector
17:31:14 <jmcarthur> Moggle: try it without mutation if you can (not sure you can completely in this case)
17:31:15 <mm_freak_> but only slightly
17:31:22 <c_wraith> interface is the difference between vector and array
17:31:28 <mm_freak_> Moggle: could you explain what you're doing?
17:31:43 <Moggle> jmcarthur: My idea is to have a fixed array of 28123 elements (Boolean array that is), initialize everything to False
17:31:51 <Saizan> and which kind of fusion is used, no?
17:32:00 <Moggle> mm_freak: after doing that, then calculate all possible sums of abundant numbers, and set their numbers in the array to True
17:32:06 <Moggle> mm_freak: after, sum all the entries with False
17:32:11 <jmcarthur> Moggle: i think you don't need an accumulator at all for this problem
17:32:12 <hpc> c_wraith: i probably wasn't paying much attention, but i don't recall any difference in interface between vector and array
17:32:26 <mm_freak_> Moggle: don't explain your algorithm, explain the application
17:32:33 <mm_freak_> try without using programming terms
17:32:36 <jmcarthur> mm_freak_: that's it. it's project euler
17:32:44 <mm_freak_> ah
17:32:49 <Moggle> https://projecteuler.net/problem=23
17:32:52 <jmcarthur> i mean, it has a higher level spec, but barely
17:33:10 <Chathurga> I hate all euler problems with primes
17:33:19 <jmcarthur> Chathurga: so almost all euler problems?
17:33:25 <ORioN63> ^
17:33:25 <Moggle> Chathurga: I made a fairly efficient infinite prime list generator, makes those problems easy
17:33:34 <jmcarthur> Moggle: there's one on hackage ;)
17:33:35 <Chathurga> Yeah after a while all of them
17:33:36 <c_wraith> hpc: vector has generic functions that work with boxed, unboxed, storable, etc implementations.  It has a bunch of operations that are implemented such that they fuse if compiled with optimizations enabled
17:33:37 <Moggle> Chathuga: I saw some insane ones using sieves and stuff on the Haskell wiki though
17:33:56 <Chathurga> Moggle: I wanted to try and make my own but I broke down in tears
17:34:07 <Moggle> Chathurga: let me see if I can find mine :P
17:34:12 <Chathurga> I think I'll just grab a pre made one
17:34:18 <hpc> c_wraith: so a more "list-like" interface, essentially?
17:34:34 <hpc> (ie, higher level like [] instead of lower-level)
17:34:37 <c_wraith> hpc: more higher-order, really
17:34:44 <hpc> er yes, that
17:34:53 <hpaste> Moggle pasted “primes” at http://hpaste.org/79401
17:34:59 <hpc> i'll have to take another look then
17:35:12 <Moggle> Chathuga: fear the disgusting
17:35:25 <jmcarthur> Moggle: http://hackage.haskell.org/packages/archive/primes/0.2.1.0/doc/html/Data-Numbers-Primes.html
17:36:23 <jmcarthur> Moggle: as far as your set manipulation, i might be more clear to create a set of things to remove and then use set difference to come up with the result
17:36:35 <jmcarthur> Moggle: also, you can use Data.Foldable.sum instead of Set.foldl' (+) 0
17:36:39 <Moggle> jmcarthur: my original solution did that
17:36:49 <Moggle> jmcarthur: i then refactored code to work like this, it made it smaller :P
17:36:54 <jmcarthur> Moggle: set difference is going to be less efficient of course
17:36:59 <Moggle> jmcarthur: i shall now use Data.Vector and see how fast I can get it
17:37:05 <jmcarthur> ah, i don't think your code is smaller than what i propose would be
17:37:28 <Moggle> solution: 4179871
17:37:34 <Moggle> now to rewrite with VECTORS
17:37:38 <Moggle> oh god how do vectors work
17:37:47 <Moggle> ooh, draft tutorial
17:37:49 <jmcarthur> Moggle: make sure to look at this http://hackage.haskell.org/packages/archive/vector/0.10.0.1/doc/html/Data-Vector-Unboxed.html#g:14
17:38:02 <jmcarthur> Moggle: note that those are *pure* but use mutation under the hood
17:38:17 <coldpizza72i> Are SplayTrees and RBtrees well suited for functional programming?
17:38:33 <johnw> it sort of depends on how you intend to use them
17:38:35 <Moggle> jmcarthur: but how does that... that can't...
17:38:40 <jmcarthur> Moggle: since you are just using a vector as an accumulator (and you can use vectors for the "list" processing you're doing, too), you can do all this without mutable arrays
17:38:44 <Moggle> jmcarthur: if it's pure, it can't possibly be mutable, no?
17:38:47 <Peaker> coldpizza72i, RBTrees at least, yeah. Not sure how splay trees work
17:38:52 <jmcarthur> Moggle: it's mutable underneath, that's all
17:38:55 <c_wraith> coldpizza72i: splay trees are not well-suited for immutable data, since every operation involves heavy mutation
17:38:58 <jmcarthur> Moggle: you never see the mutation
17:38:59 <johnw> finger trees and tries have some nice benefits, but it's all based on usage
17:39:14 <Peaker> coldpizza72i, take a look at https://github.com/yairchu/red-black-tree
17:39:18 <jmcarthur> Moggle: the trick is that you never see the original array, so it's okay to mutate
17:39:29 <jmcarthur> Moggle: that is, the mutation is simply unobservable
17:39:31 <Peaker> https://github.com/yairchu/red-black-tree shows how easy it is to get type-guaranteed invariants on RBTrees/AVLTrees
17:39:46 <Peaker> which makes one wonder why Haskell's libraries don't use these techniques
17:40:05 <jmcarthur> Moggle: when you take an array and apply once of these accum functions to it, there are two possibilities here
17:40:32 <c_wraith> Peaker: Red/Black Trees mutate too much in practice.  The best performance comes from structures with invariants that are much looser, and so much harder to encode in the types
17:40:46 <jmcarthur> Moggle: if you have used the array already, it will make a mutable copy, accumulate into that, and then freeze it (which just means it won't be allowed to mutate anymore after that) and hand it to you as an immutable array
17:40:54 <c_wraith> and AVL trees mutate even more than Red/Black trees do
17:41:06 <jmcarthur> Moggle: however, if you never actually read from it in the first place (say you just created it) it will not copy anything at all
17:41:18 <Moggle> jmcarthur: interesting
17:41:27 <jmcarthur> Moggle: so you can chain these accumulations and stuff without making copies
17:41:28 <Peaker> c_wraith, It's a trade-off, sometimes the strict invariants are good (lots of reads, fewer writes)
17:41:57 <c_wraith> still, at least AVL and R/B only mutate on updates.
17:42:03 <c_wraith> splay trees mutate on reads, too
17:42:33 <mpu> @pl \(x, (y, z)) -> ((y, x), (y, z))
17:42:34 <lambdabot> uncurry ((`ap` snd) . (. fst) . (`ap` (,)) . (((.) . (,)) .) . flip (,))
17:42:40 <mpu> hmmm....
17:43:42 <jmcarthur> :t (snd.fst &&& fst) &&& (snd.fst &&& snd.snd)
17:43:43 <lambdabot> ((a, c), (a1, c')) -> ((c, (a, c)), (c, c'))
17:44:21 <jmcarthur> hmm
17:44:34 <rwbarton> too much lens? :)
17:44:40 <jmcarthur> no lens at all
17:44:57 <jmcarthur> this would surely be easy with lens
17:44:58 <coldpizza72i> and binary random access lists are well suited for FP correct?
17:45:03 <jmcarthur> if only i was better practiced
17:45:13 <rwbarton> you seem to have forgotten the order of composition
17:45:23 <jmcarthur> so i have
17:45:42 <jmcarthur> i don't like the structure of what i wrote either, though
17:45:52 <Moggle> jmcarthur: when folding over an array, is it possible to get the index rather than the value at index, or am I going to have to zip with [1..] and use pattern matching/tuples?
17:46:07 <jmcarthur> Moggle: you can have either!
17:46:13 <jmcarthur> Moggle: there are foldi functions and such
17:46:19 <jmcarthur> Moggle: or you can use zip and fold
17:46:30 <jmcarthur> Moggle: and with fusion, it shouldn't (in theory) matter which you use
17:46:47 <johnw> Moggle: if you are folding, maintain an index value
17:46:47 <mpu> when I do f <$> a <*> b what is the order of evaluation?
17:46:52 <edwardk> :t \x p -> (set _2 x p, p)
17:46:54 <lambdabot> Field2 t1 t a b => b -> t1 -> (t, t1)
17:46:56 <jmcarthur> johnw: unnecessary
17:47:06 <edwardk> @pl \x p -> (set _2 x p, p)
17:47:06 <lambdabot> (line 1, column 14):
17:47:07 <lambdabot> unexpected "_"
17:47:07 <lambdabot> expecting variable, "(", operator or ")"
17:47:16 <jmcarthur> mpu: (<$>) is evaluated first
17:47:16 <roconnor> mpu: the order of "execution" is the effects of a followed by the effects of b.
17:47:18 <johnw> foldr (\(acc,idx) x -> (x : acc,idx+1)) ([],0) xs
17:47:25 <mm_freak_> Moggle: i've just written a naive implementation that takes eight seconds here
17:47:27 <mpu> roconnor: thanks.
17:47:31 <edwardk> @pl \x p -> (set _2 x p, p)
17:47:31 <lambdabot> (line 1, column 14):
17:47:32 <lambdabot> unexpected "_"
17:47:32 <lambdabot> expecting variable, "(", operator or ")"
17:47:43 <jmcarthur> actually, no
17:47:44 <edwardk> @pl \x p -> (,) (set _2 x p) p
17:47:44 <lambdabot> (line 1, column 18):
17:47:44 <lambdabot> unexpected "_"
17:47:44 <lambdabot> expecting variable, "(", operator or ")"
17:47:45 <Moggle> mm_freak_ with vectors?
17:47:48 <edwardk> @pl \x p -> pair (set _2 x p) p
17:47:48 <Chathurga> mm_freak_: Can I see it?
17:47:48 <lambdabot> (line 1, column 19):
17:47:48 <lambdabot> unexpected "_"
17:47:48 <lambdabot> expecting variable, "(", operator or ")"
17:47:57 <mm_freak_> Moggle: no, just lists and sets
17:47:57 <edwardk> what am i screwing up
17:48:00 <Moggle> jmcarthur: oh nevermind I'm an idiot, just found ifoldl
17:48:02 <edwardk> @pl \x -> hello x
17:48:03 <lambdabot> hello
17:48:03 <rwbarton> _2
17:48:09 <edwardk> @pl \x p -> pair (set sad x p) p
17:48:09 <roconnor> mpu: but, like everything in Haskell, things are only evaluated when demanded, which may have little to do with the order the effects are sequenced.
17:48:09 <lambdabot> join . (pair .) . set sad
17:48:13 <jmcarthur> mpu: (<*>) is evaluated first, actually
17:48:21 <pqmodn> :t sad
17:48:21 <jmcarthur> mpu: and (<*>) determines the rest of it
17:48:22 <lambdabot>     Not in scope: `sad'
17:48:23 <lambdabot>     Perhaps you meant `snd' (imported from Data.Tuple)
17:48:31 <edwardk> join . ((,) .) . set _2
17:48:37 <roconnor> mpu: f <$> a <*> b = (f <$> a) <*> b
17:48:38 <mm_freak_> Moggle, Chathurga: let me optimize it first
17:48:44 <mm_freak_> i'm not even using a sieve =)
17:49:02 <mpu> roconnor: it is funny to ask this kind of question for Haskell :)
17:49:05 <jmcarthur> mpu: (and in fact, (<*>) doesn't even determine it. the consumer of the whole thing does)
17:49:06 <edwardk> > join . ((,) .) . set _2 $ (1,(2,3))
17:49:07 <lambdabot>   No instance for (GHC.Show.Show (b0 -> (a0, b0)))
17:49:07 <lambdabot>    arising from a use of `...
17:49:12 <roconnor> mpu: a little
17:49:20 <edwardk> > uncurry (join . ((,) .) . set _2) $ (1,(2,3))
17:49:22 <lambdabot>   ((2,1),(2,3))
17:49:35 <Chathurga> In what areas does the llvm backend generally outperform gcc at the moment?
17:49:43 <jmcarthur> edwardk: ew. maybe i was wrong when i said this should be easy with lens :)
17:49:43 <Chathurga> if something like that can even be said for sure
17:50:13 <mpu> jmcarthur: While I get roconnor's answer I don't really understand yours...
17:50:58 <jmcarthur> mpu: f <$> a <*> b = (f <$> a) <*> b = (<*>) ((<$>) f a) b
17:51:09 <jmcarthur> mpu: so (<*>) evaluates first
17:51:25 <roconnor> > const id <$> undefined <*> put 7
17:51:27 <lambdabot>   No instance for (GHC.Show.Show (f0 ()))
17:51:27 <lambdabot>    arising from a use of `M17014171...
17:51:36 <edwardk> its not a very lensy problem
17:51:37 <mpu> jmcarthur: Because haskell evaluation order is specified? I would not have expected so.
17:51:56 <edwardk> and @pl in this case is silly
17:52:14 <pqmodn> > (+) (error "a") (error "b")
17:52:14 <mpu> > const <$> put 7 <*> undefined
17:52:15 <jmcarthur> mpu: i'm making assumptions about the implementation, but really in order for a consumer to get anything from it, (<*>) has to go first
17:52:16 <lambdabot>   *Exception: a
17:52:16 <lambdabot>   can't find file: L.hs
17:52:32 <johnw> Moggle: also, Vector has a fold which provides an index, fyi
17:52:40 <roconnor> > runState (const id <$> undefined <*> put 7) 0
17:52:42 <lambdabot>   ((),7)
17:52:42 <pqmodn> > (error "+") (error "a") (error "b")
17:52:44 <lambdabot>   *Exception: +
17:52:53 <roconnor> > runState ((\a b -> b) <$> undefined <*> put 7) 0
17:52:55 <lambdabot>   ((),7)
17:53:25 <mpu> jmcarthur: ok, my question was simply relative to the effects inside the applicative
17:53:32 <flebron> > fix error
17:53:33 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
17:53:44 <pqmodn> good, it's fixed
17:53:52 <hpaste> Peaker pasted “Dwarf reader and sample output” at http://hpaste.org/79402
17:54:05 <Peaker> cool! Dwarf parsing made easy :)
17:54:19 <Peaker> now need to convert the dwarf to a nice ADT
17:54:57 <roconnor> mpu: btw, you can reverse the order of the effects by using Backwards
17:55:39 <roconnor> > (runState . forward) ((\a b -> b) <$> undefined <*> Backwards (put 7)) 0
17:55:41 <lambdabot>   Not in scope: `forward'Not in scope: data constructor `Backwards'
17:56:00 <roconnor> > (runState . Control.Applicative.Backwards.forward) ((\a b -> b) <$> undefined <*> Control.Applicative.Backwards.Backwards (put 7)) 0
17:56:02 <lambdabot>   Not in scope: `Control.Applicative.Backwards.forward'Not in scope:
17:56:02 <lambdabot>    data ...
17:56:08 <roconnor> pfft
17:56:37 <shachaf> roconnor: Did you see the alternative (g a -> f b) -> g s -> f t representation of lenses?
17:56:54 <coldpizza72i> sorry i forgot how to scroll up in my irc client.... are binary random access lists well suited for FP
17:57:38 <edwardk> roconnor: if you use f,g dialgebras you can come up with constraints on f and g to get prisms and iso to work using (.) the consequence is you lose traverse, and lots of other good stuff and get lots of clutter
17:57:51 <jmcarthur> coldpizza72i: it depends on what you're doing, what tradeoffs you're willing to make
17:59:10 <jmcarthur> coldpizza72i: Purely Functional Data Structures describes an implementation of binary random-access lists
17:59:22 <coldpizza72i> i have used that book
18:00:56 <roconnor> shachaf: no
18:01:32 <roconnor> edwardk: doesn't sound like much of a win
18:01:38 <shachaf> roconnor: What edwardk said. Also http://slbkbs.org/pr.hs
18:02:01 <shachaf> roconnor: But, but, type Iso s t a b = (Functor f, Functor g) => (g a -> f b) -> g s -> f t !
18:02:14 <edwardk> roconnor: the Iso presentation is the best gem in the bunch
18:02:41 <roconnor> edwardk: ya, that one is the most intruging
18:02:42 <shachaf> I agree that it loses a lot of important points of lens.
18:02:46 <roconnor> I'd like to see the proofs
18:02:57 <edwardk> shachaf was delegating those to you ;)
18:03:07 <roconnor> even the van laarhoven lens representation is very very non-obvious
18:03:12 <roconnor> IMHO
18:03:22 <roconnor> edwardk: ha
18:04:13 <mm_freak_> Moggle, Chathurga:  is 4207994 the correct answer?
18:04:27 <roconnor> where are all the category theoriest?
18:04:34 <roconnor> why don't they already have all the answers for us?
18:04:35 <Moggle> Answer:
18:04:37 <Moggle> 	4179871
18:04:37 <Chathurga> mm_freak_: close, 4179871
18:04:40 <Moggle> according to project euler, mm_freak
18:05:07 <Moggle> Apologies for not working on my own efficient solution
18:05:13 <Moggle> I got into an argument with friends and I do love to debate
18:05:16 <edwardk> roconnor: this is the point in your career where you look around for the cavalry and realize that you're it ;)
18:05:19 <Chathurga> mm_freak_: 28123 is the difference so it's a slight bug
18:06:04 <mm_freak_> ah, i had an off by one error
18:07:56 <mm_freak_> ok, my implementation runs in 1.2 secs
18:08:12 <mm_freak_> but it cheats, because it uses the arithmoi library for finding the divisors
18:08:15 <Chathurga> Ah here
18:08:24 <Chathurga> Still, lemme see
18:08:39 <marxx> filter foo works with [String], but does not work with IO [String] even though I have used <$>. what's up with that?
18:08:43 <djahandarie> roconnor, I'm sure they do already have all the answers, but they're talking about something entirely different so we wouldn't know.
18:09:22 <edwardk> the lens laws probably fall out from some foo-symmetric blah-category
18:09:26 <hpaste> “Ertugrul Söylemez” pasted “Project Euler problem 23 (spoiler alert!)” at http://hpaste.org/79404
18:09:30 <djahandarie> Haha.
18:09:39 <mm_freak_> Moggle, Chathurga: see paste
18:10:15 <pqmodn> @type filter (const True) (return ["a","b"] :: IO [String])
18:10:16 <lambdabot>     Couldn't match expected type `[a0]' with actual type `IO [String]'
18:10:17 <lambdabot>     In the second argument of `filter', namely
18:10:17 <lambdabot>       `(return ["a", "b"] :: IO [String])'
18:10:31 <Chathurga> Thanks, I gotta learn where you can bleed more performance out of haskell
18:10:31 <pqmodn> @type filter (const True) <$> (return ["a","b"] :: IO [String])
18:10:33 <lambdabot> IO [String]
18:10:52 <mm_freak_> Chathurga: that's far from optimal…  i'm sure i can optimize this to a few milliseconds
18:11:05 <djahandarie> lenses laws are just those of locally cartesian closed categories, and we end up slowly implemented a dependent type theory in the lens library without knowing it.
18:11:07 <pqmodn> marxx: perhaps you're trying to use the return value inappropriately? you'd have to hpaste an example
18:11:31 <Chathurga> Still, a pretty nice speedup
18:13:33 <djahandarie> @remember roconnor < roconnor> where are all the category theoriest? < roconnor> why don't they already have all the answers for us?
18:13:34 <lambdabot> It is forever etched in my memory.
18:14:01 <shachaf> djahandarie: You should add edwardk's bit!
18:14:04 <acowley``> yeah
18:14:37 <mm_freak_> 42 :: Functor a Unit
18:14:39 <acowley``> I wish I had a categorical horse so I could be part of the cavalry.
18:14:45 <hpc> @forget roconnor < roconnor> where are all the category theoriest? < roconnor> why don't they already have all the answers for us?
18:14:45 <lambdabot> Done.
18:14:46 <marxx> I figured it out, but no idea why I needed parens in here: filter foo <$> (mapM something =<< somethingElse)
18:15:11 <hpc> @remember roconnor < roconnor> where are all the category theoriest? why don't they already have all the answers for us? < edwardk> roconnor: this is the point in your career where you look around for the cavalry and realize that you're it ;)
18:15:11 <lambdabot> It is forever etched in my memory.
18:16:19 <marxx> shouldnt it be the same without parens?
18:17:24 <Saizan> marxx: it's "(filter foo <$> mapM something) =<< somethingElse" without parens
18:17:30 <marxx> unless <$> has higher priority than $ and doesnt act like it which would ve wreird
18:18:12 <copumpkin> <$> really isn't very much like $
18:18:13 <marxx> so its operato priority issue?
18:18:14 <Saizan> marxx: that's quite the case
18:18:23 <copumpkin> I guess it kinda is
18:18:24 <copumpkin> hmm
18:18:28 <Saizan> yep
18:18:34 <copumpkin> :t (=<<)
18:18:36 <lambdabot> Monad m => (a -> m b) -> m a -> m b
18:19:18 <Saizan> <$> is mostly designed to work well with <*> as in foo <$> x <*> y
18:20:01 <Saizan> which means it has to have higher precedence than <*>
18:20:29 <marxx> i would prefer if they used a different name then
18:21:36 <acowley> copumpkin: I usually say that <$> is basically $ which is basically just  (whitespace) when you read it.
18:21:43 <acowley> copumpkin: It's noisy whitespace!
18:22:55 <cmccann> Saizan, (<$>) and (<*>) have the same precedence
18:23:12 <copumpkin> acowley: fair enough
18:23:51 <Saizan> cmccann: ah, it's just the associativity making them work thne
18:24:10 <cmccann> Saizan, right, they're left-associative. just like whitespace. :]
18:25:48 <Saizan> so i guess we could have made them both precendence 0, but would ($) still work the same in an expression with all three then?
18:27:11 <Peaker> wow, it takes ages to build the dwarf lib now that I added many auto-derived Ord/Read instances
18:27:55 <roconnor> do we still have quadratic time derviations?
18:30:47 <copumpkin> are derviations what dervishes do?
18:31:09 <shachaf> roconnor: You mean DeriveFunctor etc.?
18:31:22 <roconnor> my recolation his hazy
18:31:37 <roconnor> recollection
18:31:42 <shachaf> Derive{Functor,Foldable,Traversable} still makes quadratic instances. twanvl wrote a patch but it hasn't been merged yet.
18:31:54 <shachaf> I think the ticket got lost. :-( I hope it makes it into 7.6.2
18:32:25 <nus> heh, I guess the category theorists are as all other theorists too busy proving the full employment theorem
18:32:58 <twanvl> shachaf: maybe you or I should mention it on cvs-ghc again?
18:32:58 <lambdabot> twanvl: You have 2 new messages. '/msg lambdabot @messages' to read them.
18:33:19 <shachaf> twanvl: I mentioned it to Igloo the other day but the timing was unfortunate, since Hackage was down.
18:34:48 <shachaf> twanvl: Is cvs-ghc a list that people actually read?
18:35:15 <twanvl> shachaf: the developers probably do
18:38:57 <nus> seems the ticket needs spj's ack
18:39:33 <shachaf> Ah, I suppose so.
18:40:32 <shachaf> He seemed pretty surprised by it. Maybe GHC is supposed to optimize that?
18:54:32 <jmcarthur> Moggle: my somewhat bruteforce vector solution runs in 0.2s
18:54:49 <Moggle> jmcarthur: sweetness, I'm going to work on mine soonish, I hope I get similar performance.
18:55:33 <jmcarthur> Moggle: i could probably improve it by using a decent factorization algorithm for finding the divisors
18:57:50 <coldpizza72i> people say that in functional languages you dont need as much commenting as code thats in imperative languages right?
18:58:18 <dmwit> Do people say that? It doesn't sound too likely to me.
18:59:08 <byorgey> IMO, you might need fewer comments per "unit of functionality", but probably about the same per line of code.
18:59:15 <dmwit> All generalizations are false.
18:59:34 <applicative> I think it's a myth Haskell people spread around so they don't have to do it.
19:00:17 <applicative> I think its now proven that the more extensive the commentary, the more widely used the library. -- With plenty of qualifications
19:01:01 <jmcarthur> Moggle: and down to 0.13s :)
19:01:06 <Moggle> <3
19:01:08 <Moggle> nice job
19:01:12 <dmwit> Hah! I have a very well documented library with zero users. (It used to be one, but now it's zero!)
19:01:38 <applicative> what is it? I'll use it, if its not about networking
19:01:46 <amindfv> I think the thing that's commonly-said is that FP code serves as its own documentation
19:01:48 <dmwit> I doubt you will.
19:02:00 <dmwit> It's a library for parsing a file format used for storing games of go.
19:02:07 <cmccann> sounds useful.
19:02:11 <applicative> oh, don't even know the rules
19:02:13 <coldpizza72i> Chris Osaki doesnt comment his code does he... in his books
19:02:33 <cmccann> in that case I think the book IS the comments
19:02:38 <applicative> he does write books though...
19:02:42 <dmwit> Maybe documentation and commentary are necessary but not sufficient for wide-spread use. =P
19:02:53 <cmccann> a catchy name is also important.
19:03:04 <dmwit> like "text"? =)
19:03:14 <sclv> arguably haddocks aren't comments so much as pure documentation
19:03:24 <applicative> what, like lens?
19:03:24 <sclv> that happens to be written with comments
19:03:42 <startling> dmwit: that *does* sound useful
19:04:31 <coldpizza72i> so in RB trees pointers arent getting updated in a functional implementation as they are in imperative implementations right
19:04:48 <applicative> I think people don;t say 'oh the type signatures are the documentation' like the did when I was first learning haskell...
19:05:03 <applicative> ... as if I could  follow their type signatures....
19:05:05 <startling> yeah, those people are kind of silly.
19:05:20 <startling> Int -> Bool doesn't tell me anything.
19:06:21 <Virus-X_> how wide spread is Haskell in term of commercial, industry or other private sector use?
19:06:26 <applicative> coldpizza72i: I think that would be the typical case, unless you are thinking of the pointers that are implicit in laziness or however one puts it
19:06:29 <dmwit> ?wiki Haskell in Industry
19:06:30 <lambdabot> http://www.haskell.org/haskellwiki/Haskell_in_Industry
19:06:34 <shachaf> applicative: What, you have a problem with ixEach :: (Indexable (IxKey m) k, Applicative f, Eq (IxKey m), Each (IxKey m) f m m (IxValue m) (IxValue m)) => IxKey m -> SimpleOverloaded k f m (IxValue m)
19:06:46 <edwardk> shachaf: =P
19:06:50 <applicative> Virus-X_: it's taking over the world; Haskell and Javascrilpt
19:07:05 <Moggle> applicative: not sure if serious
19:07:16 <shachaf> dmwit++
19:07:17 <amindfv> ?wiki Haskell in industry
19:07:17 <lambdabot> http://www.haskell.org/haskellwiki/Haskell_in_industry
19:07:23 <amindfv> (lowercase 'i')
19:07:24 <applicative> shachaf: actually, at this point I can read it
19:07:38 <applicative> but imagine when Id been studying for a couple months
19:07:42 <x-Suriv> so is functional the future of programming then?
19:07:52 <latermuse> x-Suriv: sure
19:07:56 <shachaf> applicative: Well, sure, it's just (Each (IxKey m) f m m (IxValue m) (IxValue m))
19:08:13 <shachaf> I solve six constraints like that before breakfast.
19:08:30 <dmwit> x-Suriv: That question wrongly assumes that programming has a single future which we can point to and say "That. That right there is THE future.".
19:08:36 <edwardk> shachaf: i hope so you usually don't sleep the night before
19:08:46 <coldpizza72i> applicative: what do u mean?
19:08:50 <shachaf> edwardk: That's only when exciting things are going on!
19:09:02 <shachaf> edwardk: Also, it's pretty much your fault.
19:09:07 <x-Suriv> dmwit: Well not a single future, but there are paradigms that seem to overshadow given parts of the field, like imperative programming does noe
19:09:09 <edwardk> welcome to the dark side
19:09:10 <x-Suriv> now*
19:09:20 <shachaf> edwardk: I prefer "colight side".
19:09:44 <edwardk> i tend not to put co in front of things. it scares people. the dark side sounds cozy
19:10:12 <dmwit> Different people use different tools. Some people use imperative tools, some use object-oriented tools, some use functional tools, and some use even more exotic things. Some mix-and-match. I expect this to continue for the indefinite future.
19:10:14 <hpaste> jmcarthur pasted “pe23” at http://hpaste.org/79405
19:10:39 <jmcarthur> Moggle: spoilers, but you can check that out once you're done for ideas ^^
19:10:51 <Moggle> Thanks jmcarthur, going to start work now.
19:10:52 <Moggle> :D
19:11:02 <Moggle> As for imperative programming... I don't think it's going anywhere fast.
19:11:18 <dmwit> If that sounds vague enough as to be devoid of meaning, well, that's sort of my point, yeah.
19:11:26 <Moggle> Haskell is my first functional language :P
19:11:29 <Moggle> I know like 8 imperative ones
19:11:34 <Moggle> perhaps that's a fault of exposure
19:11:47 <Moggle> "know" meaning "tinkered with and can read competently"
19:11:54 <cmccann> the future of programming is large masses of semi-competent programmers continuing to use inferior tools to produce software of poor quality
19:12:04 * applicative is secretly checking out the lens source so he can back up his bold claim of comprehension
19:12:29 <ORioN63> Hey. I have a question. Could you help me?
19:12:34 <edwardk> cmccann: a sad truth that
19:12:40 <edwardk> ORioN63: shoot
19:12:44 <Moggle> If there's one thing #haskell is good at OriN63, it's questions.
19:13:05 <sclv> what part of pSwitch :: Functor col => (forall sf. (in -> col sf -> col (ext, sf))) -> col (SF ext out) -> SF (in, col out) (Event mng) -> (col (SF ext out) -> mng -> SF in (col out)) -> SF in (col out) *isn't* self-documenting?
19:13:11 <dmwit> ORioN63: That's a good question. But it's impossible to answer until you tell us what the next question is.
19:13:11 <ORioN63> I created a datatype Auctions with several atributes: owner, value, etc...
19:13:35 <Peaker> interestingly, my ghc objects contain "/home/ian" in their component directory. I wonder if that's a debian thing or a binary dist of ghc thing
19:13:47 <sclv> in the new version of lens, that will be the only control operator
19:13:47 <shachaf> sclv: Uh, what does it mean when you have two or three lowercase letters next to each other in a type?
19:14:00 <shachaf> sclv: Is that a GHC extension? I've never seen it before.
19:14:03 <applicative> coldpizza72i: here's a variant of rampions zipperized redblacktrees 2660297
19:14:07 <ORioN63> But further in the code I need to use a very similar datatype which I called it Auctions', with a few more atributes. And after that I had to create Auctions''
19:14:20 <applicative> coldpizza72i: opps https://gist.github.com/2660297
19:14:23 <cmccann> shachaf, multi-letter type variables is an experimental new extension
19:14:26 <sclv> shachaf: its a notoriously confusing signature from yampa :-)
19:14:30 <ORioN63> They have a lot in common, can I do anything, to not repeat myself?
19:14:35 <edwardk> shachaf: =P
19:14:35 <shachaf> cmccann: I don't get it.
19:14:43 <dmwit> ORioN63: Why not parameterize Auctions, e.g. data Auctions a = Actions { field1 :: Int, field2 :: Bool, extras :: a }
19:14:53 <cmccann> shachaf, yes it's quite confusing and not very popular
19:14:55 <sclv> @remember cmccann multi-letter type variables is an experimental new extension
19:14:55 <lambdabot> I will remember.
19:15:34 <dmwit> but don't replicate my spelling errors ;-)
19:16:00 <sclv> i gotta say cmccann i'm dying of laughter at the moment
19:16:01 <ORioN63> hm...maybe
19:16:08 <ORioN63> let me show you the code
19:16:32 <shachaf> cmccann: I always thought part of the definition of "variable" was "one letter".
19:16:33 <dmwit> I feel like shachaf deserves credit for that joke somehow.
19:16:38 <Moggle> jmcarthur: How'd you time your code?
19:16:52 <jmcarthur> Moggle: i just used time
19:16:58 <cmccann> sclv, unfortunately bad jokes are my primary contribution around here these days
19:16:59 <shachaf> dmwit: It's all part of the grand scheme of things, man.
19:17:01 <hpaste> ORioN63 pasted “aa” at http://hpaste.org/79406
19:17:13 <sclv> its what drew me to haskell in the first place
19:17:17 <Moggle> jmcarthur: as in, that's an OS thing that can time a script or something?
19:17:24 <Moggle> jmcarthur: or like a haskell internal thing?
19:17:31 <jmcarthur> Moggle: oh, and i built with -fllvm. the llvm backend tends to do better than ghc's code gen
19:17:33 <ion> shachaf: Mathematicians cheat with their own conventions: they have sin, cos, tan, lim instead of s, c, t, l in blackface comic sans serif.
19:17:42 <dmwit> Moggle: It's an executable and, in some shells, a shell built-in.
19:17:43 <jmcarthur> Moggle: time ./PE23
19:17:48 <jmcarthur> Moggle: should work in any unix
19:17:59 <Moggle> jmcarthur: bloody windows always getting in the way here :P
19:18:06 <Moggle> I'd use linux in a heartbeat if I wasn't such an avid gamer
19:18:10 <Moggle> dual booting is just annoying
19:18:14 <dmwit> It's probably possible to build a similar tool in Windows, though I don't know off-hand if there's one canonical such implementation.
19:18:19 <jmcarthur> Moggle: well, steam is coming... :)
19:18:30 <sclv> if mathematicians could, they would only have one symbol, and overload it to mean every possible operation
19:18:31 <Siphonblast> Moggle: There's Steam at least now, if you're into that.
19:18:43 <ORioN63> THQ also wants to move to Linux
19:18:51 <Moggle> jmcarthur: steam, and maybe like 2 valve games. The rest of the industry ain't about to start switching to openGL over directX and compiling for linux.
19:18:56 <sclv> and then the physicists would try to rip that out and replace it with adjunction
19:19:05 <jmcarthur> the rest of the industry isn't just using directx anyway
19:19:08 <cmccann> sclv, which symbol would it be, though?
19:19:11 <cmccann> I'm guessing ⊗
19:19:14 <cmccann> it seems pretty popular
19:19:31 <ion> They could overload space to do that.
19:19:32 <dmwit> ORioN63: Some other choices: have three constructors for one type; have one constructor and one type but use Maybe for some fields.
19:19:46 <dmwit> Each of the three possibilities have tradeoffs.
19:20:00 <applicative> ORioN63: following dmwit 's advice the original Auction would be Auction () perhaps; the ...
19:20:06 <sclv> i bet you could totally do it to, if you just made sure to take appropriate morphisms to various categories in between applications
19:20:15 <applicative> oh he's still outlineing the possibilities, ORioN63
19:20:24 <Moggle> jmcarthur: Just a question on compiling, what're the best flags for compiling? I've been using -O3 and that's about all I can recall from my days of gcc on Ubuntu
19:20:42 <dmwit> I think I'm done outlining if you want to flesh out my advice.
19:20:52 <ORioN63> yep, just thinking :P
19:21:31 <applicative> ORioN63: it is pretty common to have a record with a lot of Maybe fields. Then you are making Auction, Auction' and Auction'' the same type; the differ over whether something's Nothing
19:22:26 <dmwit> The upside of using Maybe's is that there's only one type and only one constructor to deal with. The downside is that there's only one type you can deal with.
19:22:54 <applicative> ORioN63 the devices you need to use to get some of the effects easily achieved with extensible records elsewhere are a little tough sleading.
19:23:03 <dmwit> (i.e. you can't tell the compiler that some particular field can be statically known to be a Just or a Nothing.)
19:23:06 <applicative> tough sledding, rather, in Haskell
19:23:21 <ORioN63> right
19:24:01 <jmcarthur> Moggle: for ghc, there is not difference between -O2 and -O3. normally this is enough. it's also worth trying -fllvm sometimes. if you really need to squeeze everything out of the compiler that you can, stuff like -fexcess-precision exists, plus if you use the llvm backend you can tweak its settings
19:24:22 <jmcarthur> Moggle: i said that weirdly. in ghc, there is no difference between -O2 and -O3
19:24:28 <jmcarthur> Moggle: and normally -O2 is all you need
19:24:33 <jmcarthur> (if that)
19:24:34 <Moggle> Can you use -O3 with -fllvm
19:24:36 <Moggle> ?
19:24:41 <ORioN63> I'm fairly new to Haskell as you can see, and I never used Maybe before. If I create an instance of Auctions with no argument in the Maybe, will it define it as Nothing, or do I need to specify it?
19:24:59 <applicative> If you make Auction' have a field auction :: Auction,  and Auction have a field auction':: Auction, you could go to town with edwardk &co's lenses
19:24:59 <jmcarthur> it won't change anything. if you want to tweak the llvm backend you have to do something else (i forget how off the top of my head)
19:25:08 <Moggle> Kay, thanks!
19:25:39 <jmcarthur> Moggle: there are some flags for inlining settings that can be helpful sometimes, too
19:25:54 <ORioN63> you lost me applicative
19:25:55 <byorgey> ORioN63: you need to specify it.
19:26:05 <applicative> Orion, a value will be data Auction = Actions { field1 = 3, field2= True, field3=Nothing,field4=Nothing }
19:26:32 <applicative> or equivalently Auction 3 True Nothing Nothing
19:26:41 <ORioN63> ... I have unit tests, that I need to pass, and I can't change them...
19:27:38 <applicative> that would be an Auction of your first sort; Auction 3 True (Just Cucumbers) Nothing would be an Auction'; Auction 3 True (Just Cucumbers) (Just Singapore) would be an Auction''
19:27:59 <applicative> except they;re all  one type
19:28:13 <ORioN63> yep, I think I got it, unfortunately I can't use them
19:28:31 <applicative> you need different types? or what else?
19:28:52 <ORioN63> I have unit tests that were given
19:29:05 <ORioN63> and I'm pretty sure I can't change them
19:29:26 <applicative> hm. Then put the different Auctions in different modules, I guess?
19:29:30 <hpaste> ORioN63 pasted “unitTest” at http://hpaste.org/79407
19:30:53 <applicative> I see but these are all Auction = Auction Int String String Int String
19:31:02 <ORioN63> yep
19:31:26 <ORioN63> But later in the code I will have Auction Int String String Int Int String
19:31:34 <ORioN63> and Auction Int String String String Int String
19:32:43 <ORioN63> I will probably use the Maybe
19:32:56 <applicative> well, maybe Auction = Auction Int String [String] [Int] String
19:33:48 <applicative> note that you are already using the last string field as "maybe-like', taking advantage of the empty string
19:33:51 <dmwit> Why not multiple constructors?
19:34:25 <dmwit> Actually, don't take my advice. I really don't understand the requirements, as they seem self-contradicting to me.
19:34:42 <ORioN63> probably, is just me...
19:34:53 <applicative> i'm  not getting it yet.
19:35:20 <dmwit> Why do you need additional fields?
19:35:27 <applicative> but are you stuck with similar unit tests for your later Auction' and Auction''
19:36:37 <ORioN63> I have no idea
19:37:02 <ORioN63> Don't worry. I will probably use the maybe
19:37:39 <ORioN63> thanks by the way ;)
19:38:28 <applicative> if data Auction' = Auction {auction::Action, price::Int} and Auction'' = Auction'' {auction'::Auction', buyer:: String}
19:38:44 <applicative> substituting Auction for Action
19:39:09 <applicative> if so then like I said, there are smooth combinators for updating and extracting in Control.Lens
19:39:41 <applicative> buried fields like this are not a problem any more.
19:42:05 <ORioN63> Nice. I like it.
19:43:08 <x-Suriv> I see the  ' alot in datatype names in Haskell
19:43:15 <x-Suriv> is there any significance to it?
19:43:21 <Nereid> it's just another character
19:43:26 <sclv> laziness
19:43:40 <sclv> if you don't want to come up with a new name
19:43:48 <vjraj> circumference :: Double -> Double
19:43:48 <vjraj> <interactive>:9:1: Not in scope: `circumference'
19:43:53 <vjraj> why is that ?
19:44:04 <x-Suriv> oh so beyond that it's not significant? Cool. Reminded me of the functional notation used in calculus when calculating asympotic values
19:44:09 <applicative> ORioN63: here's how it would look if you were using tuples not records
19:44:11 <applicative> > _1._1._3 .~ "Radio"$ ( ((1, "Peter", "TV", 60,""),34),"Mary")
19:44:13 <lambdabot>   (((1,"Peter","Radio",60,""),34),"Mary")
19:44:14 <sclv> in this context you can call it 'prime' as in y and y prime
19:44:14 <amindfv> a lot of times the ' is used to indicate a helper function
19:44:16 <Nereid> vjraj: in ghci, you need to use "let" to define things.
19:44:30 <Nereid> vjraj: let circumference :: Double -> Double; circumference x = ...
19:44:34 <vjraj> thanks! forgot that !
19:46:08 <ORioN63> O_O what?
19:46:30 <applicative> > > ( ((1, "Peter", "TV", 60,""),34),"Mary") ^. _1._1
19:46:32 <lambdabot>   <hint>:1:1: parse error on input `>'
19:46:39 <applicative> > ( ((1, "Peter", "TV", 60,""),34),"Mary") ^. _1._1
19:46:41 <lambdabot>   (1,"Peter","TV",60,"")
19:46:46 <applicative> pardon neo-moronism
19:49:22 <vjraj> let circumference' :: Double -> Double
19:49:22 <vjraj> <interactive>:17:5:
19:49:22 <vjraj>     The type signature for circumference' lacks an accompanying binding
19:49:34 <applicative> > let auction = _1; auction' = _1 in ( ((1, "Peter", "TV", 60,""),34),"Mary")^.auction'.auction
19:49:36 <lambdabot>   (1,"Peter","TV",60,"")
19:49:49 <vjraj> I am trying to just do some sample from the Learn You a Haskell book
19:50:01 <applicative> > let auction = _1; auction' = _1 in ( ((1, "Peter", "TV", 60,""),34),"Mary")^.auction'.auction._2
19:50:03 <lambdabot>   "Peter"
19:50:13 <vjraj> trying to explicitly specify type, but giving error
19:50:13 <vjraj> let circumference' :: Double -> Double
19:50:13 <vjraj> <interactive>:17:5:
19:50:13 <vjraj>     The type signature for circumference' lacks an accompanying binding
19:50:18 <zomg> vjraj: it might be a good idea to try writing the samples in code files unless the tutorial specifies that you can run it in ghci
19:50:21 <edwardk> > let auction = _1 in ( ((1, "Peter", "TV", 60,""),34),"Mary")^.cloneLens auction.cloneLens auction
19:50:24 <lambdabot>   (1,"Peter","TV",60,"")
19:50:25 <zomg> to avoid problems
19:50:52 <applicative> this maintains sharing or something, edwardk ?
19:51:05 <edwardk> the probem is in each place there it is being instantiated with a different type
19:51:05 <dmwit> vjraj: Read Nereid's sample code again. It has the answer to your question before you even asked it (twice).
19:51:15 <edwardk> cloneLens lets you pick one type that subsumes both usecases
19:51:18 <edwardk> :t cloneLens
19:51:20 <lambdabot> Functor f => LensLike (Context a b) s t a b -> (a -> f b) -> s -> f t
19:51:36 <edwardk> it uses (Context a b) to characterize the lens
19:51:52 <applicative> edwardk: yeah i was trying to emulate a record embedded in a record according to ORioN63 's plan
19:53:13 <applicative> edwardk: would you say that lenses are a decent approach to the desire to add more fields to a record, in a new type?
19:53:28 <applicative> that's a bit muddled, or more than a bit
19:54:01 <edwardk> applicative: have you seen makeClassy?
19:54:07 <applicative> no
19:54:17 <edwardk> that is how i recommend making extensible records
19:54:21 <edwardk> let me get you an example
19:54:21 <applicative> i can only handle on module/month
19:54:36 <applicative> ORioN63: are you listening?
19:54:39 <edwardk> https://github.com/ekmett/lens/blob/master/examples/Turtle.hs
19:55:23 <edwardk> import Control.Lens; data Point = Point  { __x, __y :: Double  } deriving (Eq,Show); makeClassy ''Point   -- this would give you lenses named _x and _y for accessing the coordinates of a Point. more importantly it does so in a tricky way relative to makeLenses.
19:55:25 <dmwit> one module per month... I like it
19:55:38 <ORioN63> yep
19:55:46 <ORioN63> you lost me in lenses
19:56:00 <edwardk> makeClassy ''Point will define class HasPoint t where point :: Simple Lens t Point; _x,_y :: Simple Lens t Double
19:56:02 <lispy> lost in lenses
19:56:10 <applicative> what is the trick, is the extra power used  in Turtle.hs
19:56:21 <applicative> ah I see
19:56:30 <edwardk> this means you can make other instances of HasPoint.
19:56:46 <edwardk> so the Turtle in that example is an instance of HasPoint
19:56:53 <applicative> each with a 'point' function to extract or update
19:56:56 <edwardk> so you can directly use _x and _y to access the x and y coordinate of it
19:57:11 <edwardk> not just point, but also with _x and _y automatically lifted
19:57:22 <edwardk> so it gets you all the members directly
19:57:25 <applicative> right I see it, HasPoint , HasColor
19:57:35 <edwardk> you can then use lenses to read and write to those leaf level properties
19:57:42 <applicative> edwardk: so you don't compose lenses
19:57:53 <edwardk> forward d t = t & y +~ d * cos (t^.heading) & x +~ d * sin (t^.heading)
19:58:13 <edwardk> forward d t = t & _y +~ d * cos (t^.heading) & _x +~ d * sin (t^.heading) -- using the lens names i've been using here
19:58:19 <Moggle> OOh.
19:58:22 <applicative> ^^^ ORioN63 I'm sure youll be wanting to write that ^^
19:58:23 <edwardk> so you don't have to
19:58:24 <Moggle> I'm down to 2.57 seconds.
19:58:28 <Moggle> This is pleasing.
19:58:35 <Moggle> Not quite the 0.2 seconds of solution code though.
19:58:46 <shachaf> On your "pe" problem?
19:58:47 <edwardk> ORioN63: i recommend starting with the README for lens.
19:58:47 <Chathurga> Moggle: On 23?
19:58:51 <Moggle> Yes.
19:59:02 <edwardk> ORioN63: https://github.com/ekmett/lens#examples
19:59:08 <Chathurga> Who got it down to 0.2?!
19:59:15 <hpaste> Moggle pasted “23c” at http://hpaste.org/79408
19:59:18 <edwardk> http://lens.github.com has a lot more resources
19:59:23 <shachaf> We should make a competing channel: #haskell-projecteuler
19:59:30 <ORioN63> wow
19:59:52 <edwardk> ORioN63: you can just cabal install lens and import Control.Lens in ghci and play around too
19:59:58 <applicative> Orion, the elements of lenses are surprisingly easy; can't say I've figured out the deeper modules
20:00:07 <Moggle> shachaf: :(
20:00:23 <edwardk> the basic idea with lens is that you should just be able to reach for a combinator that sounds like it should work and it should work =P
20:00:37 <edwardk> but there is a deeper underlying abiding set of principles and laws that makes it all work coherently
20:00:39 <Moggle> Chathurga: jmcarthur got it down to 0.2
20:00:47 <shachaf> applicative: Surprising easy? Don't worry, we're working on it
20:00:48 <applicative> ORioN63: and besides everyone here is talking about them all the time....so there's no paucity of advice
20:00:50 <Chathurga> That's crazy
20:00:58 <Moggle> http://hpaste.org/79405
20:01:00 <Moggle> that's his code
20:01:04 <ORioN63> ahha thanks
20:01:22 <applicative> shachaf: if you go too far me and ocharles will introduce lens-retro
20:01:40 <applicative> gods-lenses
20:01:55 <Chathurga> Moggle: Ooh never used unboxed, his code is pretty much 100 times faster than my original
20:02:03 <edwardk> applicative: i'll likely keep generalizing lens, but my goal is to keep existing usecases the same
20:02:06 <jmcarthur> Moggle, Chathurga: actually, i got it down to 0.1
20:02:14 <Moggle> jmcarthur: no need to brag now :P
20:02:15 <edwardk> shachaf's goal is to change everything completely
20:02:27 <Moggle> What's the point of Unboxed vectors, exactly?
20:02:31 <shachaf> edwardk: I'm not sure it's my goal.
20:02:43 <jmcarthur> Moggle, Chathurga: and i still claim that it could probably be faster with a better divisor algorithm
20:02:50 <applicative> edwardk: I think thats the main thing, people seem to be tolerating the abstractness as things are, picking up the combinators they need
20:02:51 <jmcarthur> Moggle: less indirection
20:03:15 <edwardk> applicative: this has been incredibly heartening for me ;)
20:03:16 <Moggle> Unboxed make me take 3.4 seconds :(
20:03:17 <applicative> Moggle: Data.Vector.Unboxed is the greatest module on Hackage
20:03:17 <shachaf> edwardk: I'm actually somewhat less enthusiastic than elliott about it, even though this representation is really nice.
20:03:20 <jmcarthur> Moggle: an unboxed vector of Ints is basically the representation of a C array of Ints, but a boxed vector of ints is more like a C array of pointers to ints
20:03:23 * lispy waits for the cartesian closed comic about lens
20:03:49 <edwardk> lispy: it should be interesting
20:03:51 <Moggle> jmcarthur: unboxed vector definitely slowed me down
20:04:01 <jmcarthur> Moggle: you must be using it wrong ;)
20:04:07 <Moggle> jmcarthur: no doubt :D
20:04:13 <shachaf> applicative: Come on, functions between g,f-dialgebroids are obviously the right way to represent lenses.
20:04:21 <Moggle> http://hpaste.org/79408
20:04:25 <ORioN63> well
20:04:27 <Moggle> perhaps you could critique the horribleness that is this?
20:04:32 <ORioN63> got to go... 4 am here
20:04:47 <jmcarthur> Moggle: there are two common reasons to ever prefer boxed vectors over unboxed. laziness and greater polymorphism / fewer constraints
20:04:52 <jmcarthur> looking
20:04:53 <edwardk> shachaf arguably the argument order should be the other way around for g,f so they can be f,g-dialgebroids
20:05:09 <shachaf> edwardk: Possibly, yes.
20:05:16 <edwardk> then you get lenses as LensLike Identity f s t a b
20:05:28 <jmcarthur> Moggle: for one, i see mostly list operations there
20:05:30 <applicative> well, you boys figure out what broids are needed
20:05:32 <lispy> I was assuming the g,f-dialgebroids talk was a snarky joke
20:05:39 <dmwit> What the heck does this PE description mean? "By mathematical analysis, it can be shown that all integers greater than 28123 can be written as the sum of two abundant numbers. However, this upper limit cannot be reduced any further by analysis even though it is known that the greatest number that cannot be expressed as the sum of two abundant numbers is less than this limit."
20:05:44 <Chathurga> jmcarthur: How long have you been using haskell?
20:05:45 <shachaf> lispy: No, it's completely serious.
20:05:53 <shachaf> Well. It's somewhat serious.
20:05:56 <edwardk> lispy: its what shachaf and elliott spent the night trying to convince me was a nice representation for lenses
20:05:59 <dmwit> There are finitely many abundant numbers below 28123, right? So what makes it impossible to get the exact bound?
20:06:06 <edwardk> in practice its got a number of benefits and a number of limitations
20:06:20 <jmcarthur> Chathurga: umm...
20:06:27 <copumpkin> jmcarthur: over 9000 days!?
20:06:32 <edwardk> i like the symmetry. i don't like some of the consequences
20:06:32 <shachaf> edwardk: Do you think defining a type synonym would impact readbility for regular lens types?
20:06:37 <Moggle> dmwit: nothing
20:06:41 <Moggle> dmwit: they have the lower bound
20:06:45 <shachaf> type Lens s t a b = forall f. Functor f => Coal f a b -> Coal f s t
20:06:53 <Moggle> dmwit: they just are saying _through mathematical analysis_, ie. not brute forcing it
20:07:01 <jmcarthur> Chathurga: i dunno, something like 5-6 years?
20:07:03 <Moggle> they're essentially saying mathematics is falling short here
20:07:05 <applicative> dmwit: on the face of it, it does seem absurd
20:07:07 <dmwit> Is brute force not analysis?
20:07:07 <shachaf> Moggle: Why is brute force not mathematical analysis?
20:07:12 <copumpkin> almine?
20:07:14 <edwardk> shachaf: i'd rather not hide it in the existing code, since its about the same length or longer and just makes the user go fish
20:07:23 <Chathurga> Ah grand I've got plenty of time yet
20:07:28 <shachaf> edwardk: I'm wondering if people would get better error messages.
20:07:38 <applicative> worse obviously
20:07:41 <shachaf> edwardk: I.e. an error that says "you don't need to worry about this ->"
20:07:43 <edwardk> type aliases don't really help error messages
20:07:51 <shachaf> Hmm.
20:07:54 <shachaf> Better inferred types?
20:07:57 <Moggle> shachaf: because mathemeticians would prefer to be able to use number theory and such to arrive at the correct answer, as doing so likely means a few theorems are going to be proved along the way
20:08:01 <edwardk> ghc is pretty eager with expanding them
20:08:07 <Moggle> shachaf: which can then be used on other open problems
20:08:13 <lispy> who uses error messages anyway? I extract the line number 99% of the time and just stare at the code
20:08:17 * applicative is going back to fc-labels; such nice error messages
20:08:21 <edwardk> if ghc was more careful about leaving type synonyms in place then i'd be all about it
20:08:23 <Moggle> shachaf: it's not like they're saying brute forcing is invalid, just that they'd like to do it without brute forcing
20:08:27 <edwardk> applicative: =P
20:08:49 <shachaf> Moggle: I think "mathematical analysis" is kind of meaningless.
20:08:57 <shachaf> Anyway the statement they made is just weird.
20:09:03 <Moggle> shachaf: Most math is meaningless.
20:09:10 <Chathurga> Yeah I found it hard to parse too
20:09:13 <lispy> The only things that error messages are good at: line number, subexpression, type of error (type mismatch, missing instance, kind error, etc)
20:09:19 <Moggle> shachaf: We just discover some of the previously discovered meaningless math is less meaningless than we thought occasionally
20:09:23 <Moggle> which is why we keep it around :P
20:09:30 <shachaf> Moggle: I think we're talking about different things and at any rate it won't be a useful discussion.
20:09:35 <Moggle> this is true!
20:09:50 <shachaf> Just like most discussions in this channel motivated by "project euler".
20:10:04 * shachaf is just a h8r
20:11:47 <edwardk> clearly we need to talk about lenses more here
20:11:53 * shachaf thinks Coal would help readability a lot.
20:11:58 <jmcarthur> Moggle: i suspect that the reason switching to unboxed hurt you is that you made ghc have to go through some extra effort to unbox and rebox the ints, since you aren't using unboxed vectors so pervasively throughout your code
20:11:59 <edwardk> we went and hid all the development in #haskell-lens and other topics slipped in
20:12:12 <shachaf> But maybe that's just because I've been thinking about Dial f g a b -> Dial f g s t
20:12:15 * lispy thinks Coal is what naughty kids get for christmas
20:12:17 <Moggle> jmcarthur: this could be true! I shall look into using less lists.
20:12:27 <edwardk> shachaf: i think its that
20:12:37 <hpaste> Peaker pasted “10 seconds to compile this module!!” at http://hpaste.org/79409
20:12:47 <Peaker> is this a pathologic ghc case?
20:13:09 <jmcarthur> Moggle: btw, it may not have occurred to you that there's some magic going on to allow unboxed vectors to store things like pairs :)
20:13:21 <shachaf> Peaker: Do you have a standalone version of that that takes 10 seconds?
20:13:23 <jmcarthur> Moggle: but now you won't be able to stop thinking about how it manages that
20:13:25 <lispy> Peaker: IIRC, I've seen that before and it's due to the number of data constructors
20:13:28 <Peaker> I'm pretty sure it's the Read or Ord instances
20:13:32 <Moggle> jmcarthur: you are evil
20:13:36 <jmcarthur> lol
20:13:40 <edwardk> Peaker: put a sig on getDW_OP_ and see if it helps
20:14:06 <jmcarthur> Moggle: even pairs of things that don't take up the same numbers of words!
20:14:23 <Chathurga> I'm surprised there's no CPLEX bindings for haskell, thought there might be
20:14:24 <jmcarthur> s/words/bytes/
20:14:26 <shachaf> Peaker: Commenting out everything past the "deriving" line, it compiles pretty quickly.
20:14:27 <Moggle> jmcarthur: stoppppit D:
20:14:32 <shachaf> <1s
20:14:36 <jmcarthur> Moggle: it's a simple trick, really
20:14:48 <jmcarthur> Moggle: Vector (a, b) == (Vector a, Vector b)
20:15:00 <Moggle> :O
20:15:01 <Moggle> CLEVER.
20:15:05 <jmcarthur> Moggle: a nice side effect of this is that zip and unzip are free
20:15:14 <edwardk> Peaker: its inferring a bunch of signatures and probably having a hard time mashing them together in the type for getDW_OP_. given the signature it'd probably just push the type down into each branch
20:15:29 <sclv> Covered in Coal, use Dial!
20:15:36 <aavogt> Chathurga: there are (two?) bindings glpk
20:15:36 <edwardk> sclv: =)
20:16:10 <shachaf> sclv: What if I'm vered in Algae?
20:16:11 <jmcarthur> Moggle: or at least they are free for manifest vectors, not necessarily so in the presence of fusion...
20:16:28 <Chathurga> aavogt: It's a speed competition in class, glpk is just that bit slower
20:16:37 <Chathurga> For solving the TSP
20:16:48 <shachaf> Maybe the swapped Dialgebra should be called Codialgebra!
20:17:20 <sclv> a ver is what we maximize on cosets, right?
20:17:26 <Peaker> edwardk, ok, I'll try thanks
20:18:42 <applicative> Peaker: here it takes 7.5 seconds just for the datatype DW_OP
20:19:02 <Peaker> edwardk, still very slow :(
20:19:12 <Peaker> applicative, that's nuts!
20:19:14 <edwardk> Peaker: interesting
20:19:37 <Peaker> I can make it smaller by reducing the redundant constructors (e.g: take an Int instead of lit0..lit31)
20:19:46 <applicative> its also     deriving (Eq, Ord, Read, Show) though maybe thats nothing
20:19:50 <Peaker> (this is from the dwarf lib which I'm overhauling)
20:20:53 * applicative knows nothing about dwarves
20:20:53 <dmwit> Word6
20:21:06 <dmwit> uh
20:21:09 <dmwit> Word5
20:21:13 <dmwit> <- master of binary
20:21:28 <Peaker> getting rid of lit0..31 and having just Lit Int goes from 10.7 sec to 7.9
20:21:28 <lispy> Peaker: oh, hmm...someone at work overhauled it to but I don't know if their work made it back to hackage
20:21:31 <Peaker> I'll do some more
20:21:34 <lispy> Peaker: we added write support
20:21:42 <Peaker> lispy, ah, I'm just making it saner
20:21:57 * lispy makes a note to bug co-worker about releasing it
20:22:27 <Peaker> Returning the DIEs for compilation units, instead of just the Map.. Making the DIEs much simpler, reducing duplication, and so on
20:22:32 <Peaker> clean hlint, clean -Wall, etc
20:22:46 <lispy> cool
20:23:00 * lispy should use hlint more
20:23:21 <lispy> I've only even remember to use it 0 times so far
20:23:39 <Peaker> I have a crazy habit of converting all monadic uses to applicative ones, too :)
20:23:42 <Peaker> (all the ones I can)
20:23:50 <Peaker> s/return/pure and so forth
20:24:30 <lispy> Ah, I have nothing against Monad when Applicative will do.
20:24:44 <applicative> occam's razor says, do not multiply monads beyond necessity
20:25:13 <Peaker> reduced a lot of the constructors, now 2.4 sec
20:25:58 <Peaker> hopefully now I can make changes without fear of waiting a couple of minutes for the rebuild
20:26:12 <Peaker> 24 sec for the whole build (including rebuild for profile)
20:26:12 <jmcarthur> Moggle: oh, yours has an optimization i didn't do
20:26:41 <applicative> how did you reduce them?
20:26:47 <jmcarthur> Moggle: i didn't avoid computing redundant sums of abundant numbers
20:26:57 <lispy> Peaker: now that I think about it, it was ELF that my co-worker was using not dwarf
20:27:03 <dskippy> I am having trouble understanding the output of a ByteString.Char8 base program I have written. Basically, it's outputting non-ascii and I can't figure out why, or if that's even reasonable.
20:27:06 * lispy mixes them up sometimes
20:27:08 <hpaste> dskippy pasted “password hash” at http://hpaste.org/79410
20:27:14 <dskippy> There's the paste bin.
20:27:18 <shachaf> dskippy: ASCII is a lie.
20:27:23 <shachaf> dskippy: ByteString.Char8 is a lie, too.
20:27:33 <dskippy> I knew it!
20:27:54 <shachaf> dskippy: You should use ByteString, not ByteString.Char8
20:28:02 <shachaf> Wait, why are you expecting base64-encoded output?
20:28:48 <dskippy> I what expecting ASCII characters, actually.
20:29:11 <shachaf> But ByteString is the type of bytes, not "ASCII characters"...
20:29:17 <dskippy> I essentialy am trying to duplicate the process by which Ubuntu is encoding /etc/shadow passwords.
20:29:32 <shachaf> Wow, is there seriously no base64 function :: ByteString -> Text, or ByteString -> String?
20:29:48 <shachaf> I see on Hackage ByteString -> ByteString and String -> String
20:29:49 <dskippy> I couldn't figure it out.
20:30:00 <shachaf> bos likes to do this kind of thing. :-(
20:30:07 <dskippy> bos?
20:30:15 <shachaf> Never mind.
20:30:42 <shachaf> dskippy: Other notes: You shouldn't call your function "encrypt", and you should give it a type signature. :-)
20:30:59 <dskippy> Yeah yeah this is pastebin
20:31:19 <dskippy> Both of those are actually addressed in the program I actually wrote.
20:31:24 <dskippy> this is a reduction.
20:31:47 <shachaf> Don't reduce the type signature out of those that you paste, because people have to read them. :-)
20:32:16 <applicative> dskippy: finalize outputs things like "\207\131\225\&5~\239\184\189\241T(P\214m\128\a\214 \228\ENQ\vW\NAK\220\131\244\169!\211l\233\206G\208\209<]\133\242\176\255\131\CAN\210\135~\236/c\185\&1\189GAz\129\165\&82z\249'\218>"
20:32:35 <dskippy> applicative: Okay.
20:32:44 <shachaf> applicative: Well, no, it outputs things like pack [207, 131, 225, 53, ...]
20:32:50 <shachaf> The Show instance is misleading.
20:33:20 <shachaf> dskippy: Anyway, what you want is probably base64.
20:33:35 <archeyDevil> Could anyone here explain how map (2^) [1..20] works? As it seems it's doing 2^x as expected but how does it get ordered this way when.. map (+5) [1..20] also works which looks like x+5
20:33:36 <shachaf> sha512 will give you the raw bytes.
20:33:47 <shachaf> archeyDevil: Why wouldn't it work?
20:33:55 <shachaf> Which part is confusing, I mean?
20:33:55 <dskippy> shachaf: I agree. So.... you mean the byte string library should be base-64?
20:33:57 <applicative> ah i knew this once. how do I get it to show me the word8s
20:34:02 <shachaf> map f [1,2,3] = [f 1, f 2, f 3]
20:34:06 <shachaf> Is that part clear?
20:34:08 <archeyDevil> shachaf: I know it works and I expect it to .. Just the ordering differing is kinda confusing me
20:34:15 <archeyDevil> Heh
20:34:18 <dskippy> Because, when it all comes down to it, I do really need the string I mentioned above.
20:34:27 <archeyDevil> f as in function
20:34:31 <shachaf> dskippy: No, I mean *you* should base64.
20:34:35 <ion> What ordering differing?
20:34:38 <archeyDevil> So... +5 is the literal function that runs
20:34:38 <lispy> archeyDevil: (2^) is the same as \x -> (2^x)
20:34:39 <shachaf> It's not the library's job. It just gives you raw bytes.
20:34:50 <archeyDevil> lispy: Yea, I just ticked on that :)
20:34:51 <lispy> archeyDevil: and (+5) is the same as \x -> (x + 5)
20:35:06 <archeyDevil> Yea.
20:35:33 <lispy> > zipWith (+) [1..3] [4..6]
20:35:35 <lambdabot>   [5,7,9]
20:35:36 <archeyDevil> That just explained the only thing that got me a little confused for the concept underneith :)
20:36:06 <dskippy> shachaf: I really don't understand this. I see how SHA512 gives me pure bytes.
20:36:08 <saml> waht do you use for logging?
20:36:19 <dskippy> But in /etc/shadow... that string is ASCII, right?
20:36:29 <ion> > map (+5) [a..e]
20:36:31 <lambdabot>   *Exception: not a number
20:36:38 <shachaf> dskippy: I'm going to say it's UTF-8.
20:36:45 <shachaf> dskippy: (But a restricted subset thereof.)
20:36:55 <ion> > a+5
20:36:57 <lambdabot>   a + 5
20:36:58 <archeyDevil> lispy: I understood the second you did 15:33      shachaf | map f [1,2,3] = [f 1, f 2, f 3]
20:36:59 <ion> ಠ_ಠ
20:37:03 <Peaker> lispy, ELF is a weird format.. Yet another file container
20:37:08 <lispy> > map (+5) [a..e] :: [Expr]
20:37:09 <lambdabot>   *Exception: not a number
20:37:17 <shachaf> ion: [a..e] /= [a,b,c,d,e]
20:37:20 <Peaker> (so many reinvent a Map String String container fmt)
20:37:25 <ion> Oh, duh.
20:37:42 <ion> > map (+5) [a,b,c,d,e]
20:37:44 <lambdabot>   [a + 5,b + 5,c + 5,d + 5,e + 5]
20:37:46 <ion> > map (2^) [a,b,c,d,e]
20:37:50 <lambdabot>   mueval-core: Time limit exceeded
20:37:59 <ion> > map (2**) [a,b,c,d,e]
20:38:02 <shachaf> dskippy: You need a function that turns a string of bytes into a string of characters.
20:38:03 <lambdabot>   mueval-core: Time limit exceeded
20:38:12 <shachaf> dskippy: The latter will be a longer string, most likely.
20:38:18 <archeyDevil> ion: You trying to get aa, bb, cc, dd, ee?
20:38:20 <shachaf> This function is most likely base64 in this case.
20:38:30 <ion> archeyDevil: No, “2^a”.
20:38:38 <shachaf> ion: It won't work with (2^)
20:38:39 <archeyDevil> But... a isn't defined.
20:38:40 <shachaf> @src (^)
20:38:40 <lispy> Peaker: I suppose, but given that it has to be implemented in C with virtually no libc support I can see why they might try to specialize it and make it simple (not that they have)
20:38:40 <lambdabot> x ^ 0            =  1
20:38:41 <lambdabot> x ^ n | n > 0    =  f x (n-1) x
20:38:41 <lambdabot>   where f _ 0 y = y
20:38:41 <lambdabot>         f x n y = g x n
20:38:41 <lambdabot>           where g x n | even n  = g (x*x) (n `quot` 2)
20:38:42 <lambdabot>                       | otherwise = f x (n-1) (x*y)
20:38:44 <lambdabot> _ ^ _            = error "Prelude.^: negative exponent"
20:39:00 <ion> > map (2**) [a,b,c,d,e]
20:39:02 <lambdabot>   [2**a,2**b,2**c,2**d,2**e]
20:39:15 <archeyDevil> O.o
20:39:16 <ion> shachaf: yeah
20:39:41 <archeyDevil> 15:37          ion | > map (2**) [a,b,c,d,e]
20:39:43 <archeyDevil> 15:38          ion | > map (2**) [a,b,c,d,e]
20:39:50 <archeyDevil> Why one work second didn't. ....
20:40:08 <archeyDevil> first didn't *
20:40:19 <applicative> archeyDevil:  unpack $ B.encode $ C.finalize C.init "z4PhNX7vuL3xVChQ1m2AB9Yg5AULVxXcg/SpIdNs6c5H0NE8XYXysP+DGNKHfuwvY7kxvUdBeoGlODJ6+SfaPg=="
20:40:21 <zomg> this talk about infix functions makes me think.. is there some way to partially apply a normal function `foo a b` so that you apply b, but not a?
20:40:24 <ion> archeyDevil: lambdabot was running a bit slow and the code didn’t get to run before the timeout.
20:40:34 <archeyDevil> Okay
20:40:38 <applicative> dskippy: rather for you ^^^
20:40:38 <zomg> I guess you could use flip but without that =)
20:40:40 <archeyDevil> applicative: ?
20:40:48 <ion> zomg: (`foo` b)
20:40:51 <applicative> archeyDevil: I meant dskippy
20:40:53 <applicative> I think
20:41:04 <dmwit> zomg: \a -> foo a b
20:41:10 <archeyDevil> base64 -d<<<'z4PhNX7vuL3xVChQ1m2AB9Yg5AULVxXcg/SpIdNs6c5H0NE8XYXysP+DGNKHfuwvY7kxvUdBeoGlODJ6+SfaPg=='
20:41:17 <archeyDevil> applicative: What are you doing with unicode?
20:41:28 <zomg> dmwit, ion, yeah thought so. Guess there is no not-so-obvious ways for it then
20:41:40 <ion> not-so-obvious?
20:41:50 <zomg> haha
20:41:51 <ion> oh, i missed “no”.
20:41:56 <zomg> oh ok =)
20:42:02 <applicative> oh, just fiddling with dskippy
20:42:06 <applicative> 's paste
20:42:18 <Peaker> lispy, I always wonder why these container fmts aren't simply replaced with a directory
20:42:24 <Peaker> lispy, which is a pre-existing universal container
20:42:32 <archeyDevil> > unpack $ B.encode $ C.finalize C.init "z4PhNX7vuL3xVChQ1m2AB9Yg5AULVxXcg/SpIdNs6c5H0NE8XYXysP+DGNKHfuwvY7kxvUdBeoGlODJ6+SfaPg=="
20:42:34 <lambdabot>   Not in scope: `unpack'
20:42:34 <lambdabot>  Perhaps you meant one of these:
20:42:34 <lambdabot>    `BS.unpack' (imp...
20:42:39 <archeyDevil> Oh duhh
20:43:35 <applicative> yeah, B = Data.ByteString.Base64 C is Crypto.Hash.SHA512 and  unpack is D.B.Char8\
20:43:57 <dskippy> Trying ...
20:44:02 <shachaf> Data.ByteString.Base64 makes me sad. :-(
20:45:17 <lispy> Peaker: I can understand why elf doesn't use a directory though. Having said that, I do think next step style app bundles are a good way to deploy applications.
20:45:23 <dskippy> applicative: Did you pass this string to C.init?
20:45:36 <archeyDevil> "Terminated!"
20:45:36 <archeyDevil> Naww
20:45:46 <archeyDevil> http://tryhaskell.org/#16 -- let square x = x * x in map square [1..2^20]
20:45:46 <archeyDevil> Hehe
20:46:08 <archeyDevil> ghci ftw CPU: 92% lol
20:46:10 <hpaste> jmcarthur annotated “pe23” with “pe23 (improved)” at http://hpaste.org/79405#a79411
20:46:25 <jmcarthur> Moggle: 0.076s ^^
20:46:27 <lispy> Peaker: At least in the linux world, glibc has to have very low level C code to parse elf. The elf loading code has to happen before glibc is dynamically linked into a process so that means the elf stuff has to happen 'before libc is available'. So you kind of want some gross C format.
20:46:39 <jmcarthur> microoptimization is fun ^_^
20:46:42 <Moggle> jmcarthur: my jelly is reaching sky high
20:46:48 <Moggle> i have a new approach though I'm trying out :O
20:46:50 <Moggle> I have high hopes
20:47:00 <jmcarthur> yay!
20:47:00 <Peaker> lispy, but you do have basic system calls
20:47:22 <Peaker> lispy, you already open a path to read the elf. so why not open a bunch of paths underneath a directory instead?
20:47:41 <archeyDevil> Still going XD
20:48:49 <hpaste> applicative annotated “password hash” with “password hash (annotation)” at http://hpaste.org/79410#a79412
20:48:57 <lispy> Peaker: the data on disk can change before you read it? Would this require new security considerations?
20:49:28 <applicative> dskippy no, I just picked up nonsense from Cryto.  Do you need that string, or does thiswork ^^
20:49:44 <dskippy> applicative: Is there a "..." between C.finalize and C.init in your code?
20:50:39 <Peaker> lispy, atomic snapshot of a directory could be useful here, instead of manually making a file-which-is-a-directory :)
20:50:48 <archeyDevil> Whoo lets see how long this takes :D time ghc -e 'let s x = x * x in s [1..2^20]
20:50:49 <applicative> no,   unpack $ B.encode $ C.finalize C.init  is the whole expression, the rest is the result. see the annotation for somethingmore like your function  http://hpaste.org/79410#a79412
20:50:52 <dskippy> applicative: The goal is to crack a password. I know that the password "lexicon" with the salt given "iojt..." results in my expected output in /etc/shadow
20:50:52 <Peaker> (could have more uses elsewhere)
20:51:06 <archeyDevil> > let s x = x * x in s [1..2^20]
20:51:08 <lambdabot>   No instance for (GHC.Num.Num [t0])
20:51:08 <lambdabot>    arising from a use of `e_11220'
20:51:08 <lambdabot>  Poss...
20:51:10 <archeyDevil> die bot
20:51:11 <dskippy> applicative:  I want to write code that takes that password and that salt and produces just that string.
20:51:12 <archeyDevil> Naww
20:52:26 <applicative> dskippy: you think the bytestring you get from finalize should somehow be ascii chars?
20:52:54 <dmwit> > let s x = x * x in map s [1..2^20]
20:52:56 <lambdabot>   [1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,48...
20:53:23 <archeyDevil> Oh... Whoops
20:53:36 <dskippy> applicative: Well no.
20:53:38 <archeyDevil> I have map in my code ^^
20:53:44 <dskippy> I agree it's base 64 enocded.
20:53:52 <archeyDevil> 659626606276 What it got up to lol.
20:53:59 <dskippy> But somehow I should be able to turn it into that String, right?
20:54:11 <dskippy> I mean, the Linux C program does just that.
20:54:36 <lispy> > let s x = x * x in map s (map s [1..2^20])
20:54:38 <lambdabot>   [1,16,81,256,625,1296,2401,4096,6561,10000,14641,20736,28561,38416,50625,65...
20:55:14 <lispy> > iterate (\x -> x * x) 2
20:55:16 <lambdabot>   [2,4,16,256,65536,4294967296,18446744073709551616,3402823669209384634633746...
20:55:46 <archeyDevil> Hmm
20:55:49 <x-Suriv> how did 2 get in the list?
20:56:03 <x-Suriv> Shouldn't 4 be first?
20:56:05 <shachaf> No.
20:56:09 <shachaf> 2 should be first
20:56:13 <dskippy> So applicative, my expected output I guess is an ascii encoding of a base64 encoded bytestring...?
20:56:15 <shachaf> iterate is nicer that way.
20:56:17 <jmcarthur> > iterate undefined "foo"
20:56:19 <lambdabot>   ["foo","*Exception: Prelude.undefined
20:56:32 <archeyDevil> drop 1 $ iterate (\x -> x * x) 2
20:56:37 <archeyDevil> >drop 1 $ iterate (\x -> x * x) 2
20:56:39 <archeyDevil> > drop 1 $ iterate (\x -> x * x) 2
20:56:41 <lambdabot>   [4,16,256,65536,4294967296,18446744073709551616,340282366920938463463374607...
20:56:45 <archeyDevil> x-Suriv: ^
20:56:49 <x-Suriv> iterate (\x -> x + 1) 1
20:56:53 <byorgey> x-Suriv: counting starts at zero, so the first result of iterate is applying the function zero times =)
20:57:06 <x-Suriv> byo: ahhh
20:57:13 <shachaf> If only counting started at (-1)
20:57:15 <lispy> > iterate (join (^)) 2
20:57:18 <archeyDevil> x-Suriv: byorgey *
20:57:20 <lambdabot>   mueval: ExitFailure 1
20:57:20 <lambdabot>  mueval: Prelude.undefined
20:57:28 <x-Suriv> iterate (\x -> x + x) 1
20:57:43 <archeyDevil> > iterate (\x -> x^x) 1
20:57:45 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
20:57:47 <archeyDevil> > iterate (\x -> x^x) 2
20:57:52 <lambdabot>   mueval: ExitFailure 1
20:57:53 <lambdabot>  mueval: Prelude.undefined
20:58:01 <archeyDevil> > iterate (\x -> x^x) 2
20:58:06 <lambdabot>   mueval: ExitFailure 1
20:58:06 <lambdabot>  mueval: Prelude.undefined
20:58:07 <archeyDevil> No?
20:58:22 <archeyDevil> > iterate (\x -> 2 ^ x) 2
20:58:24 <lambdabot>   [2,4,16,65536,2003529930406846464979072351560255750447825475569751419265016...
20:59:02 <latro`a> lol
20:59:04 * archeyDevil thinks haskell would be quite efficient for a RNG given some random numbers. Fast to calculate them :D
20:59:13 <archeyDevil> Err
20:59:19 <dskippy> applicative: You're output gives an out of a string with almost the right length (except the "==" at the end) but it's a different string than expected from my /etc/shadow
20:59:21 <archeyDevil> RNG given RN's O.o
21:01:06 <lispy> > length (show (head (drop 4 (iterate (\x -> 2 ^ x) 2))))
21:01:08 <lambdabot>   19729
21:01:12 <lispy> man that grows quickly
21:01:43 <lispy> > length (show (head (drop 5 (iterate (\x -> 2 ^ x) 2))))
21:01:49 <lambdabot>   mueval: ExitFailure 1
21:01:49 <lambdabot>  mueval: Prelude.undefined
21:01:52 <popl> Wow. 1001 handles in #haskell.
21:02:08 <popl> :/
21:02:14 <lispy> Where it's at. We got two turntables and a lambdabot
21:02:32 <simpson> Wait, we broke 1000? Woot!
21:03:05 <archeyDevil> Possum living in my tree :O
21:03:13 <popl> /msg alis list * -min 1000
21:03:40 <popl> #ubuntu :/
21:03:57 <jmcarthur> simpson: we break it all the time now
21:04:01 <simpson> #python is still bigger, but not by much.
21:04:11 <popl> does that mean anything important?
21:04:38 <applicative> dskippy: the == at the end is some Base64 marker I think; some kind of magic?
21:04:40 <lispy> does everyone in #python have to wait on the global interpret lock when someone is typing?
21:05:03 <popl> lispy: interesting thought
21:05:18 <applicative> dskippy: I was looking at Data.Text.Encoding but it was fruitless
21:05:22 <shachaf> What a tragedy.
21:05:40 <popl> Is this where people start bashing Python?
21:05:50 <lispy> popl: nah, I just make bad jokes
21:05:53 <popl> s/where/when/
21:05:57 <x-Suriv> one of my professors would always rant about how Python sucks
21:06:11 <popl> x-Suriv: Everything sucks.
21:06:21 <Moggle> Curses.
21:06:22 <lispy> I tried to use Jython the other day, man that was miserable. CPython would have been much better.
21:06:26 <Moggle> My new solution is incredibly slow.
21:06:31 <popl> I had a professor who would rant about MS.
21:06:37 <Moggle> It is, however, cleaner-looking, which is a plus?
21:06:53 <Moggle> x-Suriv: are you trying to claim Python does not, in fact, suck.
21:06:54 <lispy> Moggle: maintainability? Pshaw, that's not worth much ;)
21:07:03 <lispy> Moggle: Have you read Chapter 25 of Real-World Haskell?
21:07:18 <lispy> Moggle: http://book.realworldhaskell.org/read/profiling-and-optimization.html
21:07:23 <Moggle> lispy: :D Who needs the real world?
21:07:45 <dskippy> applicative: I think I might need to apply this 5k times to get the right answer.
21:08:00 <dskippy> It's hard to find explicit docs on how this works in my exact implementation.
21:08:03 <dskippy> But I found this:
21:08:07 <dskippy> http://www.akkadia.org/drepper/SHA-crypt.txt
21:08:13 <lispy> > take 1 (iterate (join (^) 2)
21:08:15 <lambdabot>   <hint>:1:29: parse error (possibly incorrect indentation)
21:08:19 <lispy> > take 1 (iterate (join (^) 2))
21:08:20 <lambdabot>   Couldn't match expected type `[a0]' with actual type `a1 -> [a1]'
21:08:57 <hpaste> Moggle pasted “23d” at http://hpaste.org/79413
21:09:09 <Moggle> jmcarthur: dear god why is this so slow?
21:09:14 <Moggle> is it the fromList?
21:09:18 <Moggle> I think it's the fromList.
21:09:45 <lispy> I wonder why take 2 (iterate (join (^)) 2) can't be evaluated
21:09:53 <applicative> dskippy: I see.This is a little confusing. I guess thats the point
21:09:56 <lispy> join (^) 4 is fine
21:10:10 <lispy> and the one after that is fine too
21:10:21 <shachaf> (join (^) 2) is not a function
21:10:33 <lispy> > join (^) 2
21:10:34 <lambdabot>   4
21:10:41 <copumpkin> > join (*) 2
21:10:42 <dskippy> applicative: Yes but it definitely is deterministic and duplicable. It should even be well documented. Sadly, there's just *so* much noise about this on Google.
21:10:43 <lambdabot>   4
21:10:43 <copumpkin> > join (+) 2
21:10:44 <lambdabot>   4
21:10:46 <lispy> > join (^) 256
21:10:48 <lambdabot>   323170060713110073007148766886699519604441026697154840321303454275246551388...
21:10:49 <copumpkin> omg (+) = (*) = (^)
21:10:53 <shachaf> > join ack 2
21:10:55 <jmcarthur> Moggle: fromList is certainly not the fastest of vector operations, yes
21:10:55 <lambdabot>   7
21:11:01 <copumpkin> ick
21:11:02 <jmcarthur> Moggle: prefer things like enumFromN
21:11:03 <popl> copumpkin: what?
21:11:10 <shachaf> ack 2 2 /= 4 :-(
21:11:13 <Moggle> jmcarthur: but is it so slow that I should be taking 8 seconds on this code?
21:11:16 <copumpkin> popl: I have proved that (+) = (*) = (^) /= ack
21:11:21 <Moggle> the code is so CLEAN LOOKING :(
21:11:25 <copumpkin> proof by example!
21:11:32 <jmcarthur> Moggle: eh, i doubt that's all there is to it if it's that slow
21:11:36 <jmcarthur> i'm off to bed
21:11:38 <lispy> copumpkin: your math breaking approachs that of keal
21:11:39 <lispy> @keal
21:11:40 <lambdabot> the fractal is 5 irrationals
21:11:41 <Moggle> night!
21:11:41 <popl> jmcarthur: night
21:11:48 <lispy> @keal
21:11:49 <lambdabot> i changed my user od
21:11:51 <applicative> copumpkin argues from 2; real mathematicians use 17
21:11:53 <copumpkin> lispy: I'm pretty good
21:12:08 <applicative> @keal
21:12:08 <lambdabot> i try make program called Glyph to do it but my script lang called T too slow. i invent T
21:12:21 <popl> applicative: /msg lambdabot
21:12:27 <popl> :(
21:12:29 <applicative> ok
21:12:37 <lispy> I am mystified why this iterate thing breaks but lambdabot can calculate the iterates past the ones I'm taking no problem.
21:12:38 <popl> actually goa head
21:12:43 <popl> I have no authority in this channel
21:12:46 * applicative loves keal
21:12:58 <popl> what's a keal?
21:13:05 * copumpkin goes to sleep too
21:13:08 <lispy> keal was a troll that used to come by
21:13:09 <shachaf> @yarr
21:13:10 <lambdabot> Gangway!
21:13:25 <lispy> keal was amusing at first but then it got old.
21:13:32 <popl> like trolls do
21:13:33 <applicative> he seems to have been russian or something.
21:13:57 <applicative> popl they haul him out when there's a suitable troll
21:14:04 <applicative> @protontorpedo
21:14:04 <lambdabot> what is the best absolute beginner utorial for haskell?
21:14:19 <applicative> protontorpedo is somewhat better
21:14:55 <popl> HOLY SHIT there are many pseudonyms in operation in this channel.
21:15:08 <edwardk> meh, sure
21:15:28 <archeyDevil> Noo!!! haskell lost a few people now we're less than 1000 D:
21:15:30 <mikeplus64> for a text editor, which is preferred as the type for the text? data E = E { text :: Data.Text{.Lazy?}.Text.Text, row :: Int, col :: Int } or { before :: [String], this_line :: (String, String), after :: [String] } or a combination e.g.. using [strict Text] or just lazy Text for before/after?
21:15:38 <archeyDevil> 998 D:
21:15:51 <mikeplus64> i'm thinking that using String might actually be preferrable, or the latter
21:15:53 <popl> archeyDevil: It's OK. Some people probably count double (according to the airlines).
21:16:06 <lispy> mikeplus64: Yes.
21:16:07 <archeyDevil> popl: ?
21:16:22 <lispy> mikeplus64: (as in, I don't actually know how to answer that)
21:16:23 <copumpkin> mikeplus64: a rope
21:16:28 <popl> archeyDevil: On most airlines it is a policy that you have to pay for two seats if you are hefty.
21:16:33 <applicative> mikeplus64: a zipper!
21:16:34 <copumpkin> mikeplus64: I think edwardk has one lying around somewhee
21:16:48 <mikeplus64> applicative: that's what my two last solutoins are i think
21:16:52 <copumpkin> applicative: if you only use your arrow keys to move around, maybe
21:16:53 <mikeplus64> solutions too
21:17:12 <edwardk> mikeplus64: you can look in the code for trifecta. it has a rope type that works pretty well for editable text
21:17:22 <lispy> mikeplus64: I'd say make it abstract-ish for now and focus on using an api to acess it. Later you can swap it out when you know what characteristics need to be optimized.
21:17:39 <edwardk> notably the column/line meta-information is handled for you by the rope
21:17:43 <mikeplus64> lispy: yeah
21:17:56 <archeyDevil> Lol
21:18:01 <archeyDevil> Win!
21:18:08 <archeyDevil> -.-
21:18:27 <edwardk> mikeplus64: i gave a talk on using monoids that used 'tracking line and column info' as a monoid example i used that approach in the ropes there
21:18:28 <archeyDevil> I ran out of installs D: I don't wannt duplicate anything lawl.
21:18:31 <applicative> copumpkin: http://stackoverflow.com/questions/12358083/purely-functional-data-structures-for-text-editors/12361200#12361200
21:19:09 <applicative> but yeah maybe the mouse will require a 14D zipper
21:19:09 <mikeplus64> edwardk: interesting, i'll read up on finger trees too
21:19:11 <lispy> mikeplus64: have you ever read dons slides about designing xmonad?
21:19:16 <mikeplus64> no
21:19:48 * popl uses xmonad. spiffy.
21:19:54 <lispy> mikeplus64: http://xmonad.wordpress.com/2009/09/09/the-design-and-implementation-of-xmonad/
21:19:59 <mikeplus64> so do i, spiffy indeed :)
21:20:04 <popl> thanks for the URL lispy
21:20:08 <lispy> mikeplus64: It seems that the design process used for xmonad would apply to making an editor
21:20:22 <shachaf> The zipper for xmonad is kind of funny.
21:20:27 <lispy> mikeplus64: focus on the kernel of the editor, get it working really well, build the rest on it.
21:20:47 <lispy> popl: I got the link from here: http://stackoverflow.com/questions/3077866/large-scale-design-in-haskell
21:20:49 <mikeplus64> yeah, i think haskell lends itself very nicely towards a text editor
21:20:56 <popl> thanks
21:21:02 <mikeplus64> undo history can simply be [Text editor state]
21:21:05 <popl> mikeplus64: how so?
21:22:08 <mikeplus64> commands could be implemented just as text editor state -> text editor state, and a DSL could be made to build those at runtime, or use an embedded ghci or the plugins package
21:22:09 <applicative> mikeplus64: surely there's a lens combinator that will solve all this
21:22:42 <lispy> mikeplus64: you could look at the yi source (the old yi from when dons first wrote it)
21:22:43 <mikeplus64> i find when i use lenses i spend more time trying to make code cute using the lenses rather than actually coding :(
21:23:06 <lispy> mikeplus64: I think dons was still mastering haskell back then, so I doubt it's as nice as say xmonad, but it's probably still nice
21:23:15 <mikeplus64> alright
21:23:42 <lispy> I don't know if you know it, but yi was a vi clone in Haskell that first demonstrated hs-plugins
21:23:55 <lispy> these days it's a graphical monstrosity
21:24:16 <mikeplus64> yeah, it's kind of nice to use
21:24:20 <popl> lispy: it's a process
21:24:35 <lispy> popl: what is a process?
21:24:44 <dmwit> pfft, [state] is a lousy undo model; why not DAG state (like git) or Set patch (like darcs) instead? ;-)
21:24:50 <Peaker> thinkinga bout using mfix in the lazy State monad, is that evil?
21:25:05 <popl> lispy: attrition
21:25:18 <lispy> Peaker: I think lazy State is a bit of a code smell, isn't it?
21:25:41 <Peaker> lispy, hmm.. maybe mfix in strict state then :)
21:25:58 <Peaker> lispy, I'm parsing dwarf entries which can cyclically refer to each other, and that's valid
21:26:10 <Peaker> lispy, and I want to convert that to a cyclic Haskell data-type
21:26:16 <lispy> ah
21:26:27 <lispy> Well, you may need laziness then
21:26:49 <Peaker> forcing a cyclic structure is ok, I think, strict might be ok
21:27:07 <Peaker> (there's no deepseq anyhow)
21:27:12 <lispy> Well, don't think you have to switch to strict just because of me.
21:27:35 <lispy> (I know far less about what you're doing that you do :)
21:28:01 <Peaker> I have:  Map Id Entry,  and I want to do something like: if Id doesn't exist yet, add it. But to give the Entry to add, I need to recursively look the Id up of other entries
21:28:15 <Peaker> these other entries should find me already in the dict
21:28:16 <mikeplus64> i'm not sure how i would represent having multiple cursors (the new fad) with a zipper
21:31:07 <mm_freak_> from the Applicative laws i'm deriving this:  f <*> pure x = fmap ($ x) f
21:31:09 <mm_freak_> is that correct?
21:31:49 <shachaf> mm_freak_: Looks correct.
21:32:00 <archeyDevil> In comparasion, which should be faster? compiling a webserver written in haskell or C ?
21:32:05 <lispy> mm_freak_: should be f <*> pure x = fmap (`id` x) f ;)
21:32:20 <archeyDevil> ^ If both covered the same minimal functionality.
21:32:45 <lispy> :t (`id` x)
21:32:46 <lambdabot> (Expr -> t) -> t
21:32:48 <mm_freak_> lispy: same thing, except more confusing to beginners ;)
21:33:21 <sw2wolf> :t id
21:33:22 <mm_freak_> archeyDevil: the haskell version is likely faster, if written by an experienced haskell programmer
21:33:22 <lambdabot> a -> a
21:33:45 <archeyDevil> mm_freak_: And if written by an experienced C programmer?
21:33:59 <shachaf> mm_freak_: Are you spreading C FUD?
21:34:08 <cmears> Experienced C programmers might not be very good at Haskell (:
21:34:22 <archeyDevil> cmears: Not by same person then haha
21:34:35 <lispy> archeyDevil: I'm not sure what you want to learn with that question, but it's not really answerable. Too much vagueness. You need to pick specific compilers and specific webservers.
21:34:38 <mm_freak_> archeyDevil: if single-threaded, the C version is probably faster…  when multi-threaded the haskell version will scale better
21:35:17 <archeyDevil> lispy: gcc vs ghc, minimal webserver returning a static file compiled into the server
21:35:24 <mm_freak_> and to take lispy into consideration, i'm assuming GHC and one of the common web servers in haskell, like snap-server or warp
21:35:41 <sw2wolf> Mayve compare Warp with nignx ?
21:35:42 <simpson> Why not compare CGI performance? >:3
21:36:03 <lispy> archeyDevil: have you seen the benchmark game?
21:36:14 <archeyDevil> lispy: Posibly?
21:36:15 <archeyDevil> Link?
21:36:18 <mm_freak_> warp outperformed nginx in my own benchmarks in a multi-threaded configuration
21:36:19 <stepcut> mm_freak_: but which is faster to *compile*
21:36:21 <lispy> archeyDevil: http://benchmarksgame.alioth.debian.org/index.phphttp://benchmarksgame.alioth.debian.org/index.php
21:36:24 <lispy> oops
21:36:26 <lispy> archeyDevil: http://benchmarksgame.alioth.debian.org/index.php
21:36:34 <simpson> The benchmark game is bogus, though.
21:36:45 <mm_freak_> and the benchmark game is pointless
21:37:14 <lispy> the benchmark game is one of the best starting points we have.
21:37:31 <lispy> But yes, it's faaaaar from perfect
21:37:31 <shachaf> Starting point for what?
21:37:34 <simpson> It explicitly excluded several known-faster implementations for some languages.
21:37:48 <shachaf> The benchmark game is a scam.
21:37:52 <stepcut> archeyDevil: I expect that *compiling* a web server in C will be faster than a web server in Haskell.. the amount of work done by a Haskell compiler is far greater than the amount done by a C compiler.. especially back when compilers like GHC compiled haskell code to C code and then compiled the C code :)
21:37:53 <lispy> shachaf: realizing that it's pointless to compare languages without being specific
21:39:00 <mm_freak_> stepcut: actually compiling a haskell web server is usually much faster, because most of what the C programmers do is already built into haskell
21:39:04 <sw2wolf> The key is compiling quality not speed :P
21:39:07 <archeyDevil> lispy: Too many numbers. But I've got the point :D
21:39:36 <archeyDevil> stepcut: Yea, haha.
21:39:39 <stepcut> mm_freak_: well.. of all the things I plan to do.. benchmarking compilation speed of C vs Haskell programs is not one of them ;)
21:39:54 <archeyDevil> stepcut: Is it still possible to get haskell code transcoded into C?
21:39:57 <popl> shachaf: the benchmark game is how video game companies drive hardware sales
21:40:12 <stepcut> mm_freak_: also.. we have to consider whether or not 'compilation' includes the 'linking' stage.. because GHC sure does drive ld pretty hard
21:40:13 <archeyDevil> With great optimization and performance.
21:40:21 <shachaf> popl: I doubt video game companies care about http://benchmarksgame.alioth.debian.org/index.php
21:41:01 <stepcut> archeyDevil: GHC probably still has -fvia-C.. I'm really actually not sure how GHC gets from Haskell to object code these days
21:41:09 <popl> shachaf: Oh, I was thinking of a generalized benchmark thing -- not that.
21:41:11 <popl> nevermind
21:42:24 <archeyDevil> stepcut: What exactly is object code?
21:42:40 <archeyDevil> Is it non architecture machine code? i.e ready to be compiled for an arch
21:43:19 <mm_freak_> stepcut: the haskell version is going to compile faster for a good reason:  first of all, nginx does much more than, say, happstack-server or snap-core + snap-server and much much much more than WAI + warp
21:43:29 <stepcut> archeyDevil: machine code is a type of object code
21:43:36 <lispy> archeyDevil: in this context, I imagine .o files as you might feed to a linker
21:43:50 <stepcut> mm_freak_: nginx might.. but if you compared warp to a C version of warp...
21:44:18 <mm_freak_> stepcut: secondly most of what is written explicitly for nginx is precompiled for haskell, notably the RTS which handles multithreading
21:44:23 <archeyDevil> c warp vs haskell warp....
21:44:26 <archeyDevil> Compare ^^
21:44:30 <archeyDevil> (compile time)
21:44:32 <mm_freak_> the second reason may account for a C version of warp to still take longer to compile
21:44:48 <lispy> in addition time to optimize, type checking haskell is slow. The worst-case is exponential, right?
21:44:50 <shachaf> I don't care at all how long my web server takes to compile.
21:44:56 <stepcut> mm_freak_: I'm still not convinced that the C version would compile faster...
21:45:14 <archeyDevil> lispy: type checking disabled.
21:45:14 <mm_freak_> stepcut: that's what i'm saying
21:45:28 <lispy> (actually, I mean type inference I suppose, type checking should be faster)
21:45:37 <stepcut> mm_freak_: oops.. I mean not convinced that the Haskell version would compile faster
21:46:04 <stepcut> mm_freak_: though, I am not about to find out either : )
21:46:25 <stepcut> instead I am going to eat messy wings and ignore IRC for a while
21:46:50 <lispy> stepcut: smart choice
21:47:30 <stepcut> then maybe I'll work on my pipes based HTTP backend some more :)
21:47:55 <mm_freak_> have fun =)
21:48:23 <archeyDevil> Wait.. Does math like 5+5 2^20 get evaluated compile time or every run time?
21:48:49 <archeyDevil> I know the intereactive is atleast lazy like that. But it's got all the components that don't change.
21:49:35 <lispy> archeyDevil: that optimization is known as constant folding.
21:50:02 <lispy> archeyDevil: I don't know underwhat circumstances ghc does constant folding, but I'd bet it does some.
21:50:26 <archeyDevil> I'd hope ^_^
21:50:45 <lispy> archeyDevil: for example, if 5+5 :: Num a => a, then you can't do constant folding. But if the type is Int you can.
21:50:52 <archeyDevil> map (\x -> 2^x) [0..] !! 9931 -- Crap method but I wrote it without thinking :P
21:50:59 <archeyDevil> 2^9931 lawl
21:51:14 <applicative> theres a pluginthat does it, or some of it archeyDevil https://github.com/kfish/const-math-ghc-plugin
21:51:57 <archeyDevil> Okay
21:52:24 <pdxleif> There was a compiler flag where you could have stuff pre-computed up to a certain point at compile time, but I think they took that out?
21:53:10 <lispy> pdxleif: is that known as super compilation or am I thinking of something else?
21:54:18 <x-Suriv> wow...FFI is the shizit!. That is all. We now go back to your normally scheduled programming.
21:55:04 <pdxleif> lispy: Sounds like something like that; I just heard about this secondhand - you would set a max upper bound for time you wanted it to spend pre-computing.
21:58:27 <Ghostofthelastxm> Does ghc compile to portable c?
21:59:43 <lispy> Ghostofthelastxm: no
21:59:54 <lispy> Ghostofthelastxm: even the RTS requires gcc
22:00:00 <lispy> (and the RTS is handwritten)
22:00:25 <lispy> Ghostofthelastxm: there is a haskell compiler with the goal of being portable ansi c, jhc
22:00:27 <Ghostofthelastxm> It doesnt compile to c, or portable c?
22:01:08 <lispy> Ghostofthelastxm: I don't think compilation to C is the default anymore (it probably still works though), and when it did compile to C it wasn't portable C.
22:01:14 <Ghostofthelastxm> But jhc is stuck with 98 and many libs do not support that.
22:01:21 <lispy> right
22:01:43 <Enigmagic> "The -fvia-C flag does nothing; it will be removed in a future GHC release"
22:02:23 <Enigmagic> i believe you're stuck using the NCG or LLVM nowadays
22:02:52 <Ghostofthelastxm> Can ghc to llvm bitcode be used to compile to c?
22:03:11 <johnw> i'm not aware of an LLVM->C backend
22:03:26 <johnw> but why do you want that, if you have bitcode?
22:03:27 <lispy> Enigmagic: you could write a Core to C compiler :)
22:03:30 <shachaf> Even if you get C code, it'll be very bizarre C.
22:03:30 <Enigmagic> no, there used to be a C backend in the earlier days though
22:04:03 <Enigmagic> i think it died around LLVM 2.4 and was removed after a while
22:04:12 <lispy> being able to translate to portable C is actually quite useful assuming you have a similarly portable RTS
22:04:21 <Ghostofthelastxm> I just want to compile haskell to a library that an app on an arm base cpu can use it.
22:04:24 <archeyDevil> > let (f:s) = "uppfirstchar" in toUpper f:s
22:04:25 <lambdabot>   "Uppfirstchar"
22:04:33 <archeyDevil> Anyone see any better ways for doing that?
22:04:36 <simpson> I seem to remember that LLVM uses an LLVM->C emitter to implement its C++-to-C transformation.
22:04:51 <shachaf> archeyDevil: Better way: Handle the empty string case.
22:04:52 <lispy> Ghostofthelastxm: someone linked a ghc-for-ios project from github the other day.
22:05:02 <archeyDevil> shachaf: example code?
22:05:08 <archeyDevil> oh
22:05:09 <archeyDevil> hmm
22:05:30 <shachaf> > map (over _head toUpper) ["hello there",""]
22:05:32 <lambdabot>   Not in scope: `_head'
22:05:32 <lambdabot>  Perhaps you meant one of these:
22:05:32 <lambdabot>    `head' (imported ...
22:05:36 <shachaf> Pfooey.
22:05:40 <archeyDevil> let upfst (f:s) = toUpper f:s in upfst "name"
22:05:45 <pdxleif> Idris looks like Haskell, and compiles via C... Don't know if it's portable, though.
22:05:45 <archeyDevil> > let upfst (f:s) = toUpper f:s in upfst "name"
22:05:47 <lambdabot>   "Name"
22:06:07 <Ghostofthelastxm> Lispy is that a new one, or the same old wiki page?
22:06:09 <archeyDevil> Any other suggestions?
22:06:30 <Enigmagic> guess i'm wrong, looks like someone has started working on the LLVM C-backend again: http://lists.cs.uiuc.edu/pipermail/llvmdev/2012-August/052858.html
22:06:52 <shachaf> Does GHC not even do unregisterised C anymore?
22:07:03 <archeyDevil> Trying to do (\x -> ..
22:07:12 <Enigmagic> shachaf: it says unregisterised only via LLVM
22:08:07 <archeyDevil> shachaf: How would that go (\x ?
22:08:18 <archeyDevil> (\x -> (f:s) -> toUpper f:s) "archey"
22:08:24 <archeyDevil> That's what I've got..
22:08:47 <Ghostofthelastxm> Too bad modern haskell is not supported on mobile.
22:08:49 <lispy> Ghostofthelastxm: https://github.com/ghc-ios/ghc/wiki
22:08:50 <shachaf> archeyDevil: "... -> ..." isn't an expression.
22:09:17 <archeyDevil> shachaf: I've noticed, I'm not sure how to join them
22:09:29 <shachaf> archeyDevil: Here's a list of expressions in Haskell :-) http://www.haskell.org/onlinereport/exps.html
22:09:44 <lispy> Ghostofthelastxm: yeah, mobile is kind of a hostile place right now with vendors that are power mad.
22:09:49 <shachaf> Are you familiar with "case"?
22:09:54 <archeyDevil> That's....... SOOOO not-noob friendly D:
22:09:59 <archeyDevil> shachaf: yes
22:10:23 <shachaf> archeyDevil: If you read it you'll find that it's not that scary.
22:11:03 <Jafet> (\x -> let u (f:s) = toUpper f:s in u x)
22:11:15 <Ghostofthelastxm> Lispy thanks! Not sure how they managed that.
22:11:39 <archeyDevil> oh sigh let!
22:12:11 <archeyDevil> Wait.. I'm trying to remove that.. This is an annon function!
22:12:56 <shachaf> Ah, Jafet.
22:13:13 <archeyDevil> @src toUpper
22:13:13 <lambdabot> Source not found. Do you think like you type?
22:13:18 <archeyDevil> Where it live?
22:13:33 <archeyDevil> Which module?
22:13:44 <archeyDevil> @hackage toUpper
22:13:44 <lambdabot> http://hackage.haskell.org/package/toUpper
22:14:24 <coleman-> hsc2hs, c2hs or greencard? any recommendations?
22:14:24 <shachaf> @where hoogle
22:14:24 <lambdabot> http://haskell.org/hoogle
22:14:40 <shachaf> coleman-: I think greencard is pretty dead.
22:14:45 <archeyDevil> import Data.Char (toUpper)
22:14:47 <archeyDevil> Whoo
22:14:56 <shachaf> Probably you should use hsc.
22:15:01 <shachaf> But it depends on what you're doing.
22:15:54 <lispy> coleman-: I prefer hsc2hs. c2hs sounds better, but I've found it to be worse in practice.
22:16:41 <johnw> i like hsc2hs too
22:16:48 <lispy> It tries to be magical and clever, which is great when it's ideas match your own. hsc2hs gives you more control but requires you to have a deeper understanding of C at times.
22:17:04 <archeyDevil> Is hsc2hs a transcoder from c to hs?
22:17:32 <shachaf> No.
22:17:34 <lispy> archeyDevil: hsc2hs takes a haskell/c hybrid and generates C code for some bits and Haskell for some bits and mashes it together for you.
22:17:37 <shachaf> It's a transformer from hsc to hs.
22:17:46 <archeyDevil> O.o
22:18:00 <archeyDevil> And c2hs what I was thought?
22:18:07 <johnw> there is also c2hsc, which tries to jump-start the creation of your .hsc files from your .c files
22:18:15 <lispy> johnw: oh neat.
22:18:19 <shachaf> johnw: Funny you should mention that program.
22:18:20 <lispy> and bindings dsl, does that do ffi stuff?
22:18:25 <johnw> shachaf: yeah, funny that I should :)
22:18:35 <johnw> lispy: Bindings-DSL is a library that makes .hsc files easier to write
22:18:46 <ion> I like bindings-DSL.
22:18:48 <johnw> (c2hsc uses Bindings-DSL)
22:19:07 <lispy> Well then, who needs greencard ;) (actually, greencard always sounded like the right approach, too bad it's so dead)
22:19:11 <coleman-> from what you just said I take it that c2hsc requires less boilerplate?
22:19:29 <johnw> coleman-: depends on the library, but in my case (wrapping libgit2), c2hsc does about 90% of the work
22:19:30 <lispy> coleman-: it gives you help constructing said boilerplate
22:19:50 <lispy> coleman-: it also tries to be smart about stdcall vs. ccall
22:19:56 <johnw> you still need to handle macros, decide whether some functions should _not_ be in IO, etc.
22:20:09 <lispy> c2hs has to be able to parse the C, that can be good or bad depending on the C and your point of view.
22:20:16 <lispy> hsc2hs uses a real C compiler to deal with the C
22:20:35 <johnw> c2hsc uses the language-c library, I'm not sure if c2hs uses that too
22:20:39 <coleman-> lispy what problems did you have with c2hs in practice?
22:20:43 <lispy> johnw: yes it does
22:20:50 <lispy> coleman-: windows
22:21:15 <coleman-> it choked on winapi?
22:21:17 <lispy> coleman-: I've tried to consume 2-3 libraries on windows that used it and it always ended in tears
22:21:34 <lispy> I don't think the c2hs devs test on windows, ever
22:21:52 <Nafai> maybe I'm just biased, but doing anything outside of the direct MS ecosystem on Windows just sounds painful
22:22:27 <johnw> hi Nafai!
22:22:33 <lispy> Nafai: yeah, I tend to agree actually. Shame that visual studio doesn't care about c99. The GHC RTS uses C99 IIRC
22:22:49 <lispy> or was it c90?
22:23:01 <johnw> there is no c90
22:23:06 <johnw> c89, c99, c11
22:23:11 <lispy> oh right, 89
22:23:28 <lispy> is the next one c22?
22:23:35 <johnw> i have no idea
22:23:37 <Nafai> Read an interesting article from Walter Bright about porting D to 64 bit Windows.  Sounded painful.
22:24:09 <johnw> Walter is an extremely nice guy
22:24:12 <shachaf> Nafai: I saw that article.
22:24:56 <lispy> if you're porting unix apps to windows, you're gonna have a bad time
22:25:07 <shachaf> lispy: Also vice versa.
22:25:34 <archeyDevil> Ahh
22:25:43 <archeyDevil> Haskell can't do ^decimals?
22:25:51 <archeyDevil> i.e 9^.5 = 3
22:26:02 <lispy> > 9 ** .5
22:26:03 <lambdabot>   <hint>:1:6: parse error on input `.'
22:26:06 <lispy> > 9 ** 0.5
22:26:08 <lambdabot>   3.0
22:26:12 <archeyDevil> Hmm
22:26:19 <lispy> :t (**)
22:26:21 <lambdabot> Floating a => a -> a -> a
22:26:21 <lispy> :t (^)
22:26:22 <lambdabot> (Integral b, Num a) => a -> b -> a
22:26:32 <lispy> :t 0.5
22:26:33 <lambdabot> Fractional a => a
22:26:51 <archeyDevil> > map (**0.5) [9,64]
22:26:52 <lambdabot>   [3.0,8.0]
22:27:00 <archeyDevil> How to make int not double?
22:27:05 <archeyDevil> not floating *
22:27:27 <shachaf> @ty (**)
22:27:29 <lambdabot> Floating a => a -> a -> a
22:27:36 <shachaf> (**) is for Floating square root.
22:27:43 <shachaf> Integer square root is a very different operation.
22:28:01 <archeyDevil> Hmm
22:28:55 <archeyDevil> > map (**1/3) [27]
22:28:56 <lambdabot>   The operator `GHC.Float.**' [infixr 8] of a section
22:28:57 <lambdabot>      must have lower pr...
22:29:06 <archeyDevil> err
22:29:16 <archeyDevil> > 7^3
22:29:17 <lambdabot>   343
22:29:21 <archeyDevil> > map (**1/3) [343]
22:29:23 <lambdabot>   The operator `GHC.Float.**' [infixr 8] of a section
22:29:23 <lambdabot>      must have lower pr...
22:29:41 <archeyDevil> > map (**(1/3)) [343]
22:29:43 <lambdabot>   [6.999999999999999]
22:29:52 <archeyDevil> ... 7 -_-
22:30:00 <coleman-> > map (floor . (** 0.5)) [9,64]
22:30:02 <lambdabot>   [3,8]
22:30:54 <archeyDevil> map (floor . (** 1/3) [7^3, 8^3]
22:31:04 <archeyDevil> > map (floor . (** 1/3)) [7^3, 8^3]
22:31:05 <lambdabot>   The operator `GHC.Float.**' [infixr 8] of a section
22:31:06 <lambdabot>      must have lower pr...
22:31:15 <archeyDevil> > map (floor . (** (1/3))) [7^3, 8^3]
22:31:17 <lambdabot>   [6,7]
22:31:25 <archeyDevil> Ehh.
22:31:34 <archeyDevil> floor -> round up function is?
22:31:35 <archeyDevil> lol
22:32:00 <archeyDevil> > map (floor . (** (1/4))) [7^4, 8^4]
22:32:02 <lambdabot>   [7,8]
22:32:05 <archeyDevil> :P
22:32:39 <coleman-> > map (("LOL" ++) . show . floor . (** 0.5)) [9,64]
22:32:41 <lambdabot>   ["LOL3","LOL8"]
22:33:53 <archeyDevil> > let surdToInt x = (**(1/x)) in surdToInt 3 343
22:33:54 <lambdabot>   6.999999999999999
22:34:00 <archeyDevil> Sigh
22:34:15 <archeyDevil> coleman-: what's the oposite to floor?
22:34:49 <johnw> :t ceil
22:34:51 <lambdabot> Not in scope: `ceil'
22:34:52 <johnw> :t ceiling
22:34:54 <lambdabot> (Integral b, RealFrac a) => a -> b
22:39:48 <coleman-> there's also round depending on how you want to round negative numbers
22:41:57 <bourbaki> Greetings
22:43:10 <bourbaki> I recently was trying to implement some algebraic structures like fields etc and then go on to vector spaces. I encontered some problems within there with orphanage of instances and multiple definitions of classes.
22:43:30 <shachaf> Don't make orphan instances.
22:43:39 <shachaf> If you need multiple instances for a single type, use a newtype for each one.
22:43:40 <bourbaki> Both require me to extend the inner types of the classes and i find this very inconvenient.
22:43:59 <shachaf> I don't know what an inner type is.
22:44:06 <bourbaki> Sec
22:44:07 <shachaf> Type classes are indeed inconvenient.
22:44:37 <bourbaki> I would like to know why the design decision was made that instances are global and not in module scope.
22:44:42 <bourbaki> Or named.
22:44:53 <bourbaki> With inner type i mean the type the classes spans.
22:45:01 <shachaf> A named instance defeats the purpose of type classes.
22:45:14 <shachaf> You can just use a record:
22:45:26 <bourbaki> Wait
22:45:32 <shachaf> (*) additionInstance 5 3 -- 8
22:45:43 <shachaf> (*) multiplicationInstance 5 3 -- 15
22:45:48 <bourbaki> I know i can use a record but this it not the same since i can not constrain the types then.
22:45:55 <shachaf> There you go, a named instance. :-)
22:45:56 <shachaf> ?
22:46:23 <bourbaki> A record is not able to force the user to implement structures.
22:46:53 <bourbaki> Eg if i have a field of type a you need to provide some instances of a multiplicative and additive unit element ec.
22:46:56 <bourbaki> etc
22:47:05 <shachaf> I still don't know what you mean.
22:47:12 <bourbaki> Sec let me post the code
22:47:16 <shachaf> What can you force me to do with a type class and not with a record?
22:47:23 <shachaf> Multiple instances are a disaster, anyway.
22:47:35 <hpaste> bourbaki pasted “Structures.hs” at http://hpaste.org/79414
22:47:37 <shachaf> Take Data.Set: It's represented as a sorted balanced binary tree.
22:47:50 <shachaf> If you changed the ordering, a valid tree would become invalid.
22:48:17 <bourbaki> Have a look at the Magma for example, there is one for Sum and one for Product.
22:48:45 <bourbaki> If i was able to put instances in modules i would not have to pull the diversification into the type the Magama spans over for example.
22:49:09 <shachaf> Here you're using newtypes.
22:49:12 <bourbaki> It gets worse once i instanciate classes since i would basically need to add a newtype anytime.
22:49:24 <shachaf> You could do the same thing with explicit record passing, but of course you'll have to pass your named instance in yourself.
22:50:09 <bourbaki> So records can build up constraints like i did now  with the typeclasses?
22:50:40 <hpaste> bourbaki pasted “Flat.hs” at http://hpaste.org/79415
22:51:04 <bourbaki> Eg for a flat vector space you would have to implement the following instances to make it work.
22:51:27 <bourbaki> This is the minimum you need to do. I do not yet know a way to force this with records.
22:52:24 <bourbaki> I was recently pointed out that lenses would solve my problem and i am aware that this seems to be a solution but it does not force the user of this code to implement the types within the constraints i am forcing on him with typeclasses.
22:53:01 <bourbaki> Besides the problem that i can not force him to proof that the types used follow the other laws like distributivity etc...
22:53:33 <edwardk> bourbaki: i have an 'algebra' package that was developed along the lines in your paste
22:53:34 <bourbaki> So falling back to records makes me think why i should use fp at all.
22:53:46 <bourbaki> edwardk: COOL! Finally :)
22:53:57 <bourbaki> Ok so you encountered the same problems?
22:54:13 <bourbaki> I have had a look at some of the packages and thought that they expose similar problems.
22:54:17 <edwardk> bourbaki: its largely unsupported, but i was exploring some fun things with very weak algebraic data structures
22:54:27 <shachaf> Something like ala with newtypes is an alternative way of doing pseudo-"named instances".
22:54:56 <bourbaki> The problem is i do not want to work on the types i put into a structure, i want to work on the structure itself.
22:55:06 <lispy> making newtype wrappers to select the instance you want is kind of broken, IMO
22:55:21 <bourbaki> So passing Sum a and Product a into a Magma feels bad.
22:55:25 <shachaf> lispy: Well, the root cause is that type classes are the devil.
22:55:31 <bourbaki> I want something like namespaces.
22:55:31 <edwardk> bourbaki: then you can use reflection, or another tool to build up such a typeclass from a dictionary
22:55:53 <bourbaki> edwardk: That still feels like hollow succor.
22:55:54 <edwardk> bourbaki: but in general typeclasses are going to be a hard tool to use for this job
22:56:05 <edwardk> bourbaki: have you seen the reflection package?
22:56:11 <edwardk> its not like java reflection
22:56:21 <bourbaki> Ok ill have a look at it.
22:56:24 <edwardk> its simply a tool for turning a term into a type you can reflect back down
22:56:35 <edwardk> this lets you build dictionaries that depend on values
22:56:44 <bourbaki> Still i would like to know why there are no named instances or why they can not stay within the scope of a module.
22:56:49 <edwardk> but it requires a lot of rank-n style thinking
22:57:03 <edwardk> named instances lead to very bad problems with confluence
22:57:12 <bourbaki> I still need to get an idea of the rank-n stuff i am on that though.
22:57:27 <bourbaki> Confluence is what?
22:57:40 <lispy> edwardk: named instances lead to problems with confluence? do you have an example?
22:57:52 <edwardk> If I hand you a Set Int you know it is sorted according to the only instance available for Int.
22:58:02 <edwardk> lispy: yes. tons of them
22:58:10 <lispy> bourbaki: https://en.wikipedia.org/wiki/Confluence_(abstract_rewriting)
22:58:17 <johnw> edwardk: I wish your libraries came with more simple examples of usage
22:58:26 <lispy> bourbaki: order of rewriting doesn't matter => confluent
22:58:30 <johnw> the docs to Data.Reflection leave me completely mystified as to what I'd ever use it for :(
22:58:39 <edwardk> this means that when you go to insert into a set, you can get an instance of Ord Int _by any means_, since they are all the same, and use that to insert directly into the set
22:58:43 <bourbaki> edwardk: But the problem arises if there is not a single but several possible structures.
22:58:45 <johnw> i'll check out examples/Monoid.hs
22:58:54 <edwardk> now, if you have local instances, you might have build up that set using your local instance before handing it off to me
22:59:02 <edwardk> bourbaki: for that we have newtypes and reflection
22:59:04 <lispy> johnw: you need to read the Oleg paper that goes with it. IIRC, Implicit Configurations
22:59:08 <edwardk> both are safe and preserve confluence
22:59:09 <johnw> ok
22:59:25 <edwardk> if you want a language that lacks these guarantees there is scala
22:59:31 <johnw> the example is pretty opaque too :(
22:59:34 <johnw> i'll try the paper
22:59:46 <bourbaki> edwardk: But that forces you to build things like the sum and product magama within the types they span.
23:00:08 <bourbaki> edwardk: Heh no i rather want to use Haskell :)
23:00:12 <lispy> edwardk: Hmm...I think I'm starting to see the confluence problem.
23:00:39 <bourbaki> Still it does not feel natural that way, though there are problems with this.
23:01:26 <lispy> edwardk: so, Haskell solves the problem by making the dictionary unique to the type/type-class combo. There must be other solutions.
23:01:33 <bourbaki> So i can make the user provide the structures i require with reflection and newtypes?
23:01:43 <edwardk> You can try programming in scala, where you don't have confluence on implicits like you do with typeclasses for ~6 months and we'll see you when you get back and you've grown a lock of white hair and you have gained a thousand-yard stare. ;) You can then armwrestle with the fact that some code in another module loaded a completely unrelated implicit, and sets silently stop accepting values, containers start doing wonky things and
23:01:43 <edwardk>  generally bad things happen all around
23:02:17 <edwardk> lispy: you can put a tag on the type at the type level for the instance. but this, in the end by the time you work through it is the same as using my reflection library ;)
23:02:37 <bourbaki> I do bet that there are problems with this also :) that is the way of life, but now at least i know why this decision was made.
23:03:14 <bourbaki> edwardk: Sorry to ask this again but the reflection is solving the problem of the instances over the same type?
23:03:30 <edwardk> bourbaki: some very very smart people have tackled the 'local instances' problem and come away burned. ;)
23:03:34 <bourbaki> Eg i want to have a vector space and thus a metric space over different structures but the same types.
23:03:44 <edwardk> chung-chieh shan has some stuff written on the topic
23:03:45 <bourbaki> Like one for a torus and one for a sphere.
23:03:45 <lispy> bourbaki: reflection allows the type class dictionary that you're are using to depend on the value.
23:04:07 <edwardk> bourbaki if you want to share a type you need to pass some kind of explicit dictionary around.
23:04:17 <bourbaki> Ok ill have a tour through the reflection package then
23:04:23 <edwardk> reflection lets you lift this to the type level despite starting at the value level
23:04:41 <lispy> bourbaki: http://www.okmij.org/ftp/Haskell/types.html#Prepose
23:04:42 <edwardk> i highly recommend reading oleg's paper on implicit configurations to get a sense of what the reflection package is about
23:04:43 <Saizan> tbf a better syntax for locally using a different instance which still desugars to newtypes or reflection could be nice
23:04:47 <bourbaki> But i still get the constraints of the classes with reflection?
23:05:11 <bourbaki> edwardk: Got an url at hand for that paper?
23:05:19 <lispy> bourbaki: I just gave it to you
23:05:26 <bourbaki> Oh sorry :)
23:05:29 <archeyDevil> main x = (**(1/x))
23:05:36 <bourbaki> Just clicked it for later reading.
23:05:55 <edwardk> Saizan: in the end that 'local use' turns into constructing a type that is like another type with some crap replaced. this means you need to adopt some kind of linear type system for those instances so they can escape scope or deal with strictly nested scopes and no escaping values. i don't think you /can/ get a nice syntax for it, but i'd love to be proven wrong
23:05:55 <lispy> bourbaki: the direct pdf link is: http://www.cs.rutgers.edu/~ccshan/prepose/prepose.pdf
23:05:57 <archeyDevil> Anyone mind telling me what I'm doing wrong for writing a basic program that runs as ./program 3 343
23:06:06 <edwardk> bourbaki: the link lispy gave
23:06:12 <bourbaki> Thanks a bunch.
23:06:13 <statusfailed> what does makeLenses do for an ADT like "data Foo = Bar String | Baz String Int"?
23:06:22 <edwardk> statusfailed: without any field names? nothing
23:06:26 <statusfailed> oh ok
23:06:37 <edwardk> if you name the string the same in both constructors you get a lens to the string
23:06:45 <edwardk> if you name the Int in the one constructor you get a traversal
23:06:46 * lispy >=> bed
23:07:14 <edwardk> data Foo = Bar { fooString :: String } | Baz { fooString :: String, fooInt :: Int }; makeLenses ''Foo
23:07:38 <edwardk> will give you fooString :: Simple Lens Foo String; fooInt :: Simple Traversal Foo Int
23:07:48 <edwardk> its a traversal since if you give it a Bar, fooInt has no target.
23:08:37 <archeyDevil> Night lispy
23:08:37 <Saizan> edwardk: why linear type system to let them escape? i was thinking of something like strong sigmas work
23:09:21 <edwardk> you can probably do that too. i was thinking in terms of the 'linear regions are all you need' to ensure you collect the type.
23:09:23 <statusfailed> edwardk: cheers :)
23:09:27 <edwardk> but a strong sigma should work
23:10:42 <Saizan> we also need a Functor on steroids to apply the transformations
23:15:33 <archeyDevil> Could anyone here tell me how I could make a program which takes.. `let s x = (**(1/x)) in s 3 343 -- 7` work from running the binary? I.e `./binary 3 343 # 7`
23:16:29 <Nereid> archeyDevil: you can get the command line arguments with getArgs
23:17:00 <Nereid> so you'd have to parse those (with something like read, perhaps) and print the result
23:18:36 <archeyDevil> Nereid: Which module?
23:18:39 <dmwit> do { s <- getArgs; case map reads s of { [(n1,""):_, (n2,"":_)] -> print (s n1 n2); _ -> putStrLn "usage: ./binary n1 n2" } }
23:18:43 <dmwit> ?index getArgs
23:18:43 <lambdabot> System.Environment
23:18:44 <shachaf> archeyDevil: Do you know about Hoogle?
23:18:49 <dmwit> ?hoogle getArgs
23:18:50 <lambdabot> System.Environment getArgs :: IO [String]
23:18:50 <lambdabot> Graphics.UI.GLUT.Initialization getArgsAndInitialize :: IO (String, [String])
23:18:50 <archeyDevil> shachaf: No?
23:18:58 <shachaf> I think I mentioned it to you before.
23:18:59 <shachaf> @where hoogle
23:19:00 <lambdabot> http://haskell.org/hoogle
23:19:03 <shachaf> It's a very useful tool.
23:19:04 <archeyDevil> Oh
23:19:12 <Nereid> @where hayoo
23:19:12 <lambdabot> http://holumbus.fh-wedel.de/hayoo/hayoo.html
23:19:24 * archeyDevil has taken a several month break from haskell for school, etc.
23:19:26 <dmwit> Whoops, my parens are in a funny place.
23:19:28 <archeyDevil> Forgot about hoogle.
23:19:38 <archeyDevil> Completly.
23:19:55 <tertl3> she looks good
23:19:59 <Nereid> dmwit: why not use readIO?
23:20:01 <tertl3> she looks fine
23:20:05 <CooL> :)
23:20:16 <Nereid> er
23:20:44 <archeyDevil> @hoogle getArgs
23:20:44 <lambdabot> System.Environment getArgs :: IO [String]
23:20:44 <lambdabot> Graphics.UI.GLUT.Initialization getArgsAndInitialize :: IO (String, [String])
23:20:58 <dmwit> Nereid: *shrug*
23:21:12 <dmwit> Nereid: exceptions or pretty error messages, your choice
23:21:23 <archeyDevil> Hmm
23:21:35 <archeyDevil> (a,b) <- getArgs
23:21:42 <archeyDevil> I'm guessing that's the wrong syntax?
23:21:47 <Nereid> (a,b) isn't a list.
23:22:06 <archeyDevil> Nereid: So.. It has to be a list? Can't just export to variables?
23:22:11 <Nereid> huh?
23:22:12 <CooL> are you ready ?
23:22:14 <Nereid> you can get things out of a list.
23:22:20 <archeyDevil> Hmm
23:22:25 <archeyDevil> <- is that right for getArgs?
23:22:25 <dmwit> archeyDevil: [a,b] <- getArgs
23:22:32 <archeyDevil> Oh I was close
23:22:36 <CooL> ok wait :D
23:22:39 <CooL> start
23:22:41 <Nereid> yes you can even pattern match on a list.
23:22:50 <archeyDevil> Oh god.
23:23:08 <archeyDevil> IP ADDRESSES :D
23:23:09 <archeyDevil> lol
23:23:12 <Nereid> uh what
23:23:14 <archeyDevil> No need to scan the internets
23:23:20 <archeyDevil> Netsplit?
23:23:25 <dmwit> No, not a netsplit.
23:23:26 <Nereid> no, bot attack
23:23:32 <dmwit> That was a malicious packet.
23:24:07 <archeyDevil> joins/parts on ignore list ^_^
23:24:15 <archeyDevil> Nereid: Where were we?
23:24:23 <archeyDevil> I hope you aren't getting spammed still
23:24:28 <Nereid> yep
23:24:53 <CooL> how ?? :)
23:25:00 <archeyDevil> CooL: How what?
23:25:06 <CooL> clone
23:25:09 <charliesome> what
23:25:15 <CooL> attack
23:25:22 <charliesome> wtf
23:25:36 <CooL>  think is fun
23:25:37 <popl> seriously?
23:25:43 <popl> any ops awake?
23:25:47 <dibblego> Yes.
23:25:50 <dibblego> what is the issue please?
23:25:50 <shachaf> @where ops
23:25:51 <lambdabot> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
23:25:56 <shachaf> Oh.
23:26:15 <shachaf> dibblego: Does your IRC client show joins/parts?
23:26:23 <glguy_> Looks like it stopped
23:26:25 <dibblego> Yes. I see a join flood, is CooL part of this?
23:26:36 <CooL> ok :)
23:26:37 <dmwit> dibblego: That was my guess, but I have no evidence.
23:26:39 <glguy_> Oh, it's an actual thing, different nicks :(
23:26:39 <CooL> bye
23:26:45 <Nereid> all the idents are good or ~good so
23:26:47 <CooL> #help :D
23:26:47 <Nereid> should be easy to +b
23:26:56 --- mode: ChanServ set +o glguy_
23:27:13 <Nereid> oh wait, a lot of them are different.
23:27:33 --- mode: glguy_ set +b *!good@*
23:27:35 --- mode: glguy_ set +b *!~good@*
23:27:38 <glguy_> That's a start, at least
23:27:53 <glguy_> chat about this topic in #haskell-ops if you have any questions, let's keep this channel clean :)
23:28:07 <archeyDevil> :)
23:28:10 <popl> a little late
23:28:15 <archeyDevil> Not so good ban... But works
23:28:27 <archeyDevil> glguy_: Pitty it wasn't a registered user.
23:28:49 <archeyDevil> Better for banning.
23:29:25 <Nereid> I bet it's over anyway.
23:29:46 <charliesome> why would someone do that
23:29:52 <popl> charliesome: to be annoying
23:29:54 <neutrino> please notify the opers in #freenode
23:30:04 <neutrino> glguy_: ^
23:30:06 <Nereid> already have
23:30:09 <dax> The opers are always very aware.
23:30:17 <neutrino> nice
23:30:18 <archeyDevil> Nereid: I bet that attack was written in haskell lol
23:30:22 <dax> already, even
23:30:27 <archeyDevil> Or python trying to kill us
23:30:30 <Nereid> or always =)
23:30:33 <dax> but pretending we're omniscient is good too
23:30:43 <charliesome> lol python
23:30:47 <archeyDevil> charliesome: :P
23:31:03 <popl> just make sure if you've got logging enabled in your IRC client that it doesn't log joins/parts to disk
23:31:14 <neutrino> ha ha
23:31:14 <popl> otherwise that'd suck
23:31:19 <charliesome> actual quote from guido: "You can write reduce() in a few lines of Python. Not so in a functional language."
23:31:25 <archeyDevil> popl: Hehehehe...
23:31:33 <archeyDevil> 32G USB = my rootfs haha
23:31:42 <glguy_> charliesome: He's right, you can't easily execute Python code in a functional language
23:31:47 <popl> archeyDevil: flash?
23:31:51 <archeyDevil> popl: Yupp
23:31:57 <popl> archeyDevil: it's got a shelf life
23:31:59 <archeyDevil> popl: It's faster than my borked HDD
23:32:15 <popl> flash memory has an upper limit on the number of writes
23:32:20 <dibblego> charliesome: I tried teaching Guido functional programming for quite a few weeks; I don't think he will ever know what it means.
23:32:25 <popl> it's huge but it exists
23:32:26 <archeyDevil> HDD = 60% badblocks + crypto + lvm + btrfs = FUCKING SLOW
23:32:27 <archeyDevil> lol
23:32:35 <charliesome> dibblego: oh really?
23:32:37 <archeyDevil> popl: Yea. but ^^
23:32:53 <dibblego> charliesome: truly, though I'd prefer this stay between all 996 of us :)
23:33:02 <archeyDevil> popl: Compared to my HDD, and it's super portable haha. Useful for school don't have to worry about things
23:33:02 <charliesome> fukc
23:33:05 <Nereid> what
23:33:09 <archeyDevil> Nereid_mcx_ca: lol
23:33:09 <popl> omfg
23:33:11 <Nereid_mcx_ox> Nereid mcx baby :) Nereid mcx baby :) Nereid mcx baby :) Nereid mcx baby :)
23:33:11 <Nereid_mcx_es> Nereid mcx baby :) Nereid mcx baby :) Nereid mcx baby :) Nereid mcx baby :)
23:33:11 <Nereid_mcx_jC> Nereid mcx baby :) Nereid mcx baby :) Nereid mcx baby :) Nereid mcx baby :)
23:33:11 <Nereid_mcx_AM> Nereid mcx baby :) Nereid mcx baby :) Nereid mcx baby :) Nereid mcx baby :)
23:33:11 <Nereid_mcx_GH> Nereid mcx baby :) Nereid mcx baby :) Nereid mcx baby :) Nereid mcx baby :)
23:33:11 <Nereid_mcx_qn> Nereid mcx baby :) Nereid mcx baby :) Nereid mcx baby :) Nereid mcx baby :)
23:33:11 <Nereid_mcx_dG> Nereid mcx baby :) Nereid mcx baby :) Nereid mcx baby :) Nereid mcx baby :)
23:33:11 <Nereid_mcx_vJ> Nereid mcx baby :) Nereid mcx baby :) Nereid mcx baby :) Nereid mcx baby :)
23:33:11 <Nereid_mcx_sH> Nereid mcx baby :) Nereid mcx baby :) Nereid mcx baby :) Nereid mcx baby :)
23:33:11 <Nereid_mcx_Pt> Nereid mcx baby :) Nereid mcx baby :) Nereid mcx baby :) Nereid mcx baby :)
23:33:22 <Nereid_mcx_hY> Nereid mcx baby :) Nereid mcx baby :) Nereid mcx baby :) Nereid mcx baby :)
23:33:23 <Nereid_mcx_hY> Nereid mcx baby :) Nereid mcx baby :) Nereid mcx baby :) Nereid mcx baby :)
23:33:23 <Nereid_mcx_hY> Nereid mcx baby :) Nereid mcx baby :) Nereid mcx baby :) Nereid mcx baby :)
23:33:23 <Nereid_mcx_hY> Nereid mcx baby :) Nereid mcx baby :) Nereid mcx baby :) Nereid mcx baby :)
23:33:23 <Nereid_mcx_hY> Nereid mcx baby :) Nereid mcx baby :) Nereid mcx baby :) Nereid mcx baby :)
23:33:23 <Nereid_mcx_ty> Nereid mcx baby :) Nereid mcx baby :) Nereid mcx baby :) Nereid mcx baby :)
23:33:23 <Nereid_mcx_ty> Nereid mcx baby :) Nereid mcx baby :) Nereid mcx baby :) Nereid mcx baby :)
23:33:23 <Nereid_mcx_pZ> Nereid mcx baby :) Nereid mcx baby :) Nereid mcx baby :) Nereid mcx baby :)
23:33:23 <Nereid_mcx_pZ> Nereid mcx baby :) Nereid mcx baby :) Nereid mcx baby :) Nereid mcx baby :)
23:33:23 <Nereid_mcx_JQ> Nereid mcx baby :) Nereid mcx baby :) Nereid mcx baby :) Nereid mcx baby :)
23:33:30 <charliesome> sigh
23:33:32 <archeyDevil> 18:33             <-- Nereid_mcx_hY has quit irc [Killed (idoru (Spam is off topic on freenode.))]
23:33:34 --- mode: ChanServ set +o dibblego
23:33:35 <archeyDevil> Heh
23:33:38 <archeyDevil> I like taht one :D
23:33:40 --- mode: glguy_ set +b *!*@183.221.12.215
23:33:41 <dmwit> Yep, these k-lines are looking promising.
23:33:42 <Nereid_mcx_sE> Nereid mcx baby :) Nereid mcx baby :) Nereid mcx baby :) Nereid mcx baby :)
23:33:42 <Nereid_mcx_vI> Nereid mcx baby :) Nereid mcx baby :) Nereid mcx baby :) Nereid mcx baby :)
23:33:43 <Nereid_mcx_pG> Nereid mcx baby :) Nereid mcx baby :) Nereid mcx baby :) Nereid mcx baby :)
23:33:43 <Nereid_mcx_NU> Nereid mcx baby :) Nereid mcx baby :) Nereid mcx baby :) Nereid mcx baby :)
23:33:43 <Nereid_mcx_Zh> Nereid mcx baby :) Nereid mcx baby :) Nereid mcx baby :) Nereid mcx baby :)
23:33:43 <Nereid_mcx_Ik> Nereid mcx baby :) Nereid mcx baby :) Nereid mcx baby :) Nereid mcx baby :)
23:33:43 <Nereid_mcx_ya> Nereid mcx baby :) Nereid mcx baby :) Nereid mcx baby :) Nereid mcx baby :)
23:33:54 <glguy_> ahh, k-lines, yay opers
23:34:06 <archeyDevil> glguy_: :)
23:34:16 <Nereid> maybe we should just +r for now?
23:34:32 <dibblego> Yes. agree
23:34:35 --- mode: glguy_ set +r
23:34:36 <archeyDevil> Nereid: Hehe. Agree
23:34:46 <shachaf> @yarr
23:34:47 <lambdabot> Shiver me timbers!
23:34:51 <charliesome> Nereid: ooooh so that's why #php is +r
23:34:55 <Nereid> haha
23:35:19 * hackagebot general-prelude 0.1.2 - Prelude replacement using generalized type classes where possible  http://hackage.haskell.org/package/general-prelude-0.1.2 (JohnWiegley)
23:35:21 <mikeplus64> what happens when someone who isn't registered tries to talk? do they get like a freenode message saying "register first" or what?
23:35:24 <simpson> charliesome: And #python, too. It turns out that it works *really* well.
23:35:31 <charliesome> i can imagine
23:35:35 <shachaf> +r annoys me
23:35:36 <dibblego> mikeplus64: yes, a server response
23:35:41 <Nereid> mikeplus64: it just tells them they can't speak.
23:35:46 <mikeplus64> dibblego: oh ok that's good
23:35:47 <Nereid> but +r prevents nonregistered users from joining
23:35:52 <jayne> +r is useful as a short-term mitigation. Just remember to remove it later.
23:35:57 <neutrino> i don't think this has anything to do with nereid
23:36:03 <Nereid> haha
23:36:07 <shachaf> Short-term I don't mind it.
23:36:18 <dibblego> No, it has to do with a user in the channel who is reading.
23:36:44 * archeyDevil will laugh if they register the bot lol.
23:36:55 <archeyDevil> +b $a:whatevertheyregisterd
23:36:57 <archeyDevil> :)
23:38:17 <CooL> Nereid :)
23:38:25 <Peaker> is there some nice auto-generated pretty-printer via TH?
23:38:29 <Peaker> for ADTs?
23:38:29 <CooL> see you later ;)
23:38:34 <Nereid> cu
23:38:38 <CooL> `m attack boi
23:38:42 <CooL> :D
23:39:41 <CooL> let me banned
23:39:47 <CooL> and  go
23:40:05 --- mode: ChanServ set +o johnw
23:40:15 <CooL> johnw banned me
23:40:16 <CooL> please
23:40:20 --- kick: CooL was kicked by johnw (Kicked by johnw)
23:40:41 <charliesome> what a tool
23:40:53 <johnw> must be a pretty lonely tuesday night somewhere
23:41:03 <shachaf> Or a monday night.
23:41:13 <shachaf> Or maybe not even a night!
23:41:17 <johnw> shachaf: you just added a day to my week :)
23:41:28 <johnw> oh, and thanks for talking about StablePtr last night
23:41:31 <Peaker> awesome, my dwarf parser generates a high-level ADT successfully for a ghc output exec
23:41:31 <johnw> you saved me a lot of time
23:41:45 <shachaf> johnw: Sure!
23:41:53 <shachaf> I didn't actually know the solution myself until last night.
23:42:22 <johnw> it's all working well now, using the foreign import/export scheme for the free function, and wrappers for everything else
23:42:42 <shachaf> ?
23:42:52 <johnw> the S3 backend I was working on
23:42:59 <shachaf> Don't StableNames give you more or less the same issue as wrappers?
23:43:04 <shachaf> You still have to free them manually.
23:43:08 <johnw> yeah, I free them in my free function
23:43:57 <shachaf> Er, I mean StablePtr, notStableName
23:44:07 <johnw> yep
23:44:23 <shachaf> OK, I suppose that's valid because you explicitly derefStablePtr which gives you an IO action.
23:44:23 <johnw> https://github.com/jwiegley/gitlib-s3/blob/master/Data/Git/Backend/S3.hs
23:44:43 * shachaf would probably say to use a StablePtr for the whole thing, not just free().
23:45:02 <johnw> line 187 is where I free everything
23:45:53 * archeyDevil nmap's this lucky 100th banned person/bot ^_^
23:46:26 <archeyDevil> #haskell gets abused often?
23:46:40 <johnw> not really, no
23:46:50 <archeyDevil> johnw: Yet enough to get 100th ban?
23:47:09 <shachaf> It's a big channel.
23:47:15 --- mode: johnw set -o johnw
23:47:17 <JoeyA> 993
23:47:18 <shachaf> I think discussions of Haskell bans should go to #haskell-ops
23:47:24 <archeyDevil> #archlinux is a bigger channel, doesn't get abused like that.
23:47:24 <JoeyA> Need 7 more converts.
23:47:33 <shachaf> Also discussions of whatever it is you're doing to bots.
23:51:11 --- mode: dibblego set -o dibblego
23:54:12 <Nereid> do we still need +r?
23:54:22 <johnw> i'd give it a few more hours
23:54:31 <johnw> i can disable +r when I head to bed in a few hours
23:57:23 <earthy> morning all
23:59:05 <orospakr> hey, is it possible to link against libHSrts.so dynamically rather than libHSrts.a statically?  This seems to be a useful thing for efficiently packaging haskell apps on UNIX-compatibles.
