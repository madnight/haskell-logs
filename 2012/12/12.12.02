00:00:16 <xenocons> lets face it, its syntactically cleaner than let (|MyActivePattern|) a b = ..
00:00:59 <xenocons> well i guess its a matter of opinion
00:01:08 <xenocons> but i always found active pattern syntax to be obtrusive
00:01:34 <Heffalump> I didn't mean for the active pattern, just to use a let instead of where in general
00:01:55 <xenocons> hmm
00:02:56 <xenocons> so let myfunction x = let something = 1, match x with | b when x = something ..
00:03:02 <xenocons> (or am i missing the point)
00:03:25 <Heffalump> since F# doesn't have multi-clause guards in quite the same as Haskell, you don't really need where either. And strictness also means that it would be confusing to have a definition after its use
00:03:29 <Heffalump> yes, that
00:04:15 <jfischoff> Is anyone familiar with an implementation of the Karatsuba multiplication algorithm for polynomials in Haskell?
00:04:33 <xenocons> Heffalump: fair enough
00:08:37 <xenocons> how let behaves is quite familiar
00:09:00 <hpaste> sw2wolf pasted “Why donot `cabal build` create Eval.o ?” at http://hpaste.org/78628
00:12:28 <mysticc> Is there a guarded version of if or case ?
00:13:51 <mysticc> I have a variable on which I can not pattern match but can only do == operator so I need something like guard. I dont want to write lots of nested if
00:14:25 <portnov> >> 2+2 where 2+2=5
00:14:33 <portnov> > 2+2 where 2+2=5
00:14:35 <lambdabot>   <hint>:1:5: parse error on input `where'
00:14:53 <startling> > let 2 + 2 = 5 in 2 + 2
00:14:54 <lambdabot>   5
00:15:15 <simpson> mysticc: There are things called pattern guards. They are part of Haskell 2010.
00:15:17 <mauke> mysticc: so use a guard
00:15:21 <nus> > let c0 = compare 0; f (c0 -> EQ) = undefined; f (c0 -> LT) = True; f (c
00:15:21 <simpson> They may or may not do what you want.
00:15:21 <nus> 0 -> GT) = False in f 2
00:15:23 <lambdabot>   <hint>:1:72: parse error (possibly incorrect indentation)
00:15:31 <mysticc> mauke: How ?
00:15:36 <mauke> uh
00:15:55 <mauke> PATTERN | EXPRESSION -> EXPRESSION
00:15:56 <nus> > let c0 = compare 0; f (c0 -> EQ) = undefined; f (c0 -> LT) = True; f (c0 -> GT) = False in f 2
00:15:58 <lambdabot>   True
00:16:06 <xenocons> pattern identifier
00:18:18 <mysticc> mauke: maybe you can give a link to an example
00:19:28 <randomclown> easiest way to negate every second number in a [Int]?
00:19:33 <mauke> > case sqrt 5 of { x | x < 1 -> "less than 1"  | x > 3 -> "more than 3"  | otherwise -> "somewhere in the middle" }
00:19:35 <lambdabot>   "somewhere in the middle"
00:20:02 <randomclown> zip with [1..] and delet evens?
00:20:15 <mauke> :t zipWith id (cycle [id, negate])
00:20:16 <lambdabot> Num c => [c] -> [c]
00:20:32 <mysticc> mauke: oh, thanks
00:21:00 <randomclown> :t zipWith
00:21:01 <lambdabot> (a -> b -> c) -> [a] -> [b] -> [c]
00:22:00 <neutrino> @hoogle Monad m => (a -> b) -> (a -> m b)
00:22:01 <lambdabot> Control.Monad liftM :: Monad m => (a1 -> r) -> m a1 -> m r
00:22:01 <lambdabot> Control.Monad ap :: Monad m => m (a -> b) -> m a -> m b
00:22:01 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
00:22:12 <neutrino> @hoogle+
00:22:12 <lambdabot> Data.Function ($) :: (a -> b) -> a -> b
00:22:12 <lambdabot> Prelude ($!) :: (a -> b) -> a -> b
00:22:12 <lambdabot> Prelude fmap :: Functor f => (a -> b) -> f a -> f b
00:22:29 <byrdmansniper> what is a UMinus in haskell?
00:22:41 <mauke> :t (return .)
00:22:42 <lambdabot> (Monad m, Functor f) => f a -> f (m a)
00:22:53 <mauke> :t (return Prelude..)
00:22:55 <lambdabot> Monad m => (a -> b) -> a -> m b
00:23:06 <mauke> byrdmansniper: what
00:23:11 <neutrino> unary minus
00:23:28 <neutrino> > -2
00:23:30 <lambdabot>   -2
00:23:45 <byrdmansniper> thanks
00:23:48 <neutrino> yw
00:28:19 <neutrino> thanks mauke
00:30:29 * hackagebot cipher-aes 0.1.3 - Fast AES cipher implementation with advanced mode of operations  http://hackage.haskell.org/package/cipher-aes-0.1.3 (VincentHanquez)
00:34:05 <DexterLB> anyone here using aura? It seems that it can't download the AUR package db (it used to work fine, this problem appeared recently)
00:34:21 <DexterLB> (sorry, a bit OT)
01:00:30 * hackagebot cabal-src 0.2.1 - Alternative install procedure to avoid the diamond dependency issue.  http://hackage.haskell.org/package/cabal-src-0.2.1 (MichaelSnoyman)
01:03:02 <neutrino> :t id id
01:03:03 <lambdabot> a -> a
01:03:06 <neutrino> :t id
01:03:08 <lambdabot> a -> a
01:41:26 <rtharper> is there no function in Data.List to replace all instances of one element with another?
01:41:56 <rtharper> ah nevermind, tehre is in Data.List.Utils
01:42:28 <neutrino> rtharper: this reminds me of a package i saw recently
01:42:39 <rtharper> oh?
01:42:44 <neutrino> where one guy implemented (some part of) posix regex, not for [Char] but for [a]
01:43:16 <neutrino> only tangentially related, but pretty cool i think
01:44:09 <neutrino> it's called RegExDot i believe.
01:44:54 <rtharper> oh cool
01:45:13 <rtharper> I'm currently making a rather hacky parser for my bank files
01:45:23 <rtharper> they only export as HTML from their website -_-
01:47:51 <neutrino> ugh
01:48:21 <neutrino> i think python had something specifically for parsing html to manageable data structures
01:49:20 <rtharper> Hehe I have to do dynamic languages ALL DAY
01:49:34 <rtharper> Home time is static time
01:49:46 <neutrino> hahaha.
01:50:22 <neutrino> well, i can understand the sentiment. it's just that if you can easily transform that html to e.g. json, then you have more static-time for actual useful problems :)
01:51:21 <rtharper> hehe
01:51:24 <rtharper> true
01:51:45 <rtharper> the docs for this are pretty small, it's pretty easy to strip it down to the useful bits
01:55:47 <b____> who owns the google (webmasters etc) account for haskell.org?
01:58:02 <statusfailed> Is there a way to get this to load when I do  "ghci Foo.hs"? http://www.reddit.com/r/haskell/comments/144biy/pretty_output_in_ghci_howto_in_comments/
01:58:28 <statusfailed> currently it only seems to work when I just do "ghci"
02:03:07 <neutrino> rtharper: ahh :)
02:03:28 <neutrino> rtharper: sounds like what i did in awk to get a local risto's menu displayed in the terminal.
02:04:29 <neutrino> statusfailed: tried running that :set after it's opened?
02:07:04 <neutrino> statusfailed: someone in here was looking for a way to keep variables around after you :load (yesterday), might want to check the logs
02:10:25 <statusfailed> neutrino: myPrint isn't in scope when I do that- but I will check the logs, that sounds like a useful feature too :p
02:11:04 <neutrino> it seems vaguely related
02:11:25 <byrdmansniper> how do you return null? from a method
02:11:37 <zhulikas> use Maybe a
02:12:59 <zhulikas> > let a b = if b > 5 then Just b else Nothing in a 6
02:13:01 <lambdabot>   Just 6
02:13:02 <zhulikas> > let a b = if b > 5 then Just b else Nothing in a 4
02:13:03 <lambdabot>   Nothing
02:20:01 <rtharper> neutrino: haahah yeah this is definitely an awkable problem
02:20:19 <rtharper> I really just need to get it into CSV for my finance software
02:20:26 <neutrino> rtharper: at some point it stopped working. when i reinstalled ubuntu it put in mawk instead of awk.
02:20:35 <rtharper> waah
02:20:37 <neutrino> er instead of gawk
02:20:43 <neutrino> mawk sucks :(
02:22:59 <johnw> hawk is cool, though
02:23:03 <johnw> he attacks mice from afar
02:30:32 * hackagebot persistent 1.1.0 - Type-safe, multi-backend data serialization.  http://hackage.haskell.org/package/persistent-1.1.0 (MichaelSnoyman)
02:30:34 * hackagebot persistent-mongoDB 1.1.0 - Backend for the persistent library using mongoDB.  http://hackage.haskell.org/package/persistent-mongoDB-1.1.0 (MichaelSnoyman)
02:30:36 * hackagebot persistent-mysql 1.1.0 - Backend for the persistent library using MySQL database server.  http://hackage.haskell.org/package/persistent-mysql-1.1.0 (MichaelSnoyman)
02:30:38 * hackagebot persistent-postgresql 1.1.0 - Backend for the persistent library using postgresql.  http://hackage.haskell.org/package/persistent-postgresql-1.1.0 (MichaelSnoyman)
02:30:41 <byrdmansniper> how do you do a while loop?
02:31:27 <charliesome> byrdmansniper: you don't
02:31:42 <charliesome> byrdmansniper: what are you trying to do? i'll help you figure out how to do it in haskell
02:32:47 <byrdmansniper> i am recieving an integer and a string of statements. i need to apply all of the statements to the integer and then return the integer
02:33:36 <cmears> sounds like a fold!
02:34:07 <charliesome> byrdmansniper: what cmears said
02:34:18 <charliesome> byrdmansniper: basically a fold lets you reduce a list of values down to one
02:34:37 <charliesome> for example, you can fold over addition
02:34:42 <byrdmansniper> but i am already all in
02:34:55 <charliesome> > foldl (+) 0 [1,2,3,4]
02:34:56 <lambdabot>   10
02:35:08 <byrdmansniper> wait what is fols? i am a haskell noob
02:35:16 <charliesome> that takes the starting value (0), and adds it to the first element in the list
02:35:34 <charliesome> 0 + 1 = 1, so it adds 1 to the next element in the list
02:35:44 <charliesome> 1 + 2 = 3, so it adds 3 to the next element in the list
02:35:51 <charliesome> and so on, until it's gone through the whole list
02:36:19 <byrdmansniper> ok. thanks!
02:36:25 <charliesome> so your integer would be the starting value
02:36:31 <charliesome> and the list would be the list of statements
02:36:39 <byrdmansniper> ok
02:36:41 <charliesome> you'd write a function that takes an integer and a statement, and returns the next integer
02:36:50 <charliesome> then you can fold over that function
02:37:19 <charliesome> hope that helps :)
02:37:23 <byrdmansniper> what is the syntax for the actual fold?
02:37:33 <charliesome> :t foldl
02:37:34 <lambdabot> (a -> b -> a) -> a -> [b] -> a
02:37:54 <byrdmansniper> ok
02:37:54 <charliesome> so it takes a function, then a starting value, then a list
02:37:59 <charliesome> and returns the accumulated value
02:39:55 <byrdmansniper> thanks guys
02:40:20 <FireFly> These images might also help: http://en.wikipedia.org/wiki/Foldl#Folds_as_structural_transformations
02:40:32 * hackagebot persistent-sqlite 1.1.0 - Backend for the persistent library using sqlite3.  http://hackage.haskell.org/package/persistent-sqlite-1.1.0 (MichaelSnoyman)
02:40:34 * hackagebot persistent-template 1.1.0 - Type-safe, non-relational, multi-backend persistence.  http://hackage.haskell.org/package/persistent-template-1.1.0 (MichaelSnoyman)
02:40:36 * hackagebot pool-conduit 0.1.1 - Resource pool allocations via ResourceT.  http://hackage.haskell.org/package/pool-conduit-0.1.1 (MichaelSnoyman)
02:43:03 <cmears> byrdmansniper: maybe you want something like this
02:43:05 <cmears> > foldl (flip ($)) 10 [(+2), (*4), (+1)]
02:43:07 <lambdabot>   49
02:43:22 <cmears> i.e. start with 10, then add 2, then multiply by 4, then add 1
02:44:06 <byrdmansniper> dude you guys are really helpful
02:48:42 <mauke> > foldr (.) id [[(+2), (*4), (+1)] 10
02:48:43 <lambdabot>   <hint>:1:36: parse error (possibly incorrect indentation)
02:48:50 <mauke> > foldr (.) id [(+2), (*4), (+1)] 10
02:48:52 <lambdabot>   46
02:49:42 <byrdmansniper> what is "ambiguous occurance 'foldl'
02:50:15 <mauke> it means you fail at copy/paste
02:50:22 <mauke> it's "occurrence"
02:51:31 <byrdmansniper> ok, spelling inaccuracies aside, what does the error mean? haha
02:51:39 <typoclass> mauke: very helpful ...
02:51:53 <statusfailed> @djinn Lens s t a a -> s -> t
02:51:54 <lambdabot> Error: Undefined type Lens
02:51:54 <typoclass> byrdmansniper: it means you have two functions of the name foldl defined
02:52:08 <statusfailed> @manual_djinn Lens s t a a -> s -> t
02:52:09 <lambdabot> Unknown command, try @list
02:52:20 <byrdmansniper> oh
02:52:24 <mauke> byrdmansniper: you should copy/paste the whole message, not just the first 3 words
02:52:25 <typoclass> byrdmansniper: could be that you have one imported from Prelude, one defined by you
02:52:35 <mauke> it will tell you exactly what's wrong
02:52:41 <byrdmansniper> can i rename one, or is it a set name?
02:53:05 <k00mi_> byrdmansniper: did you import any modules?
02:53:07 <byrdmansniper>  Ambiguous occurrence `foldl'     It could refer to either `Prelude.foldl',                              imported from `Prelude' at hw3_haskell.hs:1:1                              (and originally defined in `GHC.List')                           or `Map.foldl',                              imported from `Data.Map' at hw3_haskell.hs:150:1-22
02:53:37 <statusfailed> oh %%~ id
02:54:13 <FireFly> you could put something like `import Map hiding (foldl)` in hw3_haskell.hs
02:54:21 <FireFly> (assuming it's the Prelude foldl you want to use
02:54:27 <mauke> better idea: import qualified Data.Map as M
02:54:31 <FireFly> Or that
02:54:46 <byrdmansniper> ok
02:55:16 <byrdmansniper> so how do i call foldl after it is imported?
02:55:42 <shachaf> By its name.
02:55:47 <cmears> just "foldl" ; it doesn't need any qualification
02:56:57 <startling> how does ghc represent Char internally?
02:57:07 <mauke> @src Char
02:57:08 <lambdabot> data Char = C# Char#
02:57:36 <startling> how is Char# implemented internally? ;)
02:57:48 <mauke> int, probably
02:58:03 <startling> so utf-32? yeah.
02:58:21 <byrdmansniper> ok
02:58:38 <arcatan> is trifecta in usable state? i gather there's somekind of rewrite going or something... edwardk?
03:05:44 <byrdmansniper> hw3_haskell.hs:828:9:     Ambiguous occurrence `foldl'     It could refer to either `Prelude.foldl',                              imported from `Prelude' at hw3_haskell.hs:1:1                              (and originally defined in `GHC.List')                           or `Map.foldl',                              imported from `Data.Map' at hw3_haskell.hs:150:1-22
03:05:57 <byrdmansniper> still getting the error message
03:06:38 <cmears> you have "import Data.Map", yes?
03:06:57 <mauke> on line 150, apparently
03:07:25 <cmears> indeed
03:07:28 <cmears> change it to "import qualified Data.Map as M"
03:10:23 <byrdmansniper> ok
03:11:13 <byrdmansniper> [1 of 1] Compiling Main             ( hw3_haskell.hs, hw3_haskell.o )  hw3_haskell.hs:456:19:     Not in scope: type constructor or class `Map'     Perhaps you meant `Map.Map' (imported from Data.Map)  hw3_haskell.hs:465:11:     Not in scope: `foldlWithKey'     Perhaps you meant one of these:       `Map.foldlWithKey' (imported from Data.Map),       `Map.foldWithKey' (imported from Data.Map),       Map.foldlWithKey' (imported f
03:11:20 <byrdmansniper> now that happened
03:11:44 <shachaf> byrdmansniper: I bet you can guess what that means based on the preceding conversation. :-)
03:11:47 <neutrino> you need to learn how to use qualified imports
03:12:05 <typoclass> byrdmansniper: yup, when you do "import qualified ...", the module's functions will only be available as "M.foldWithKey" and so on
03:12:23 <neutrino> if you have a dog in a Room it's going to be Room.dog
03:12:23 <byrdmansniper> lovely
03:13:47 <Palmik> Hmm... I can not find a GHC reference page an Haskell Prime wiki entry for TypeOperators extension...
03:13:59 <Palmik> s/an/or/g
03:16:10 <bitonic> Palmik: ghc manual
03:16:14 <danr> Palmik: was that g really necessary?
03:17:05 <arcatan> hmm. cabal-dev ghci says "cabal-dev: user error (Warning: cannot determine version of /Users/miikka/Library/Haskell/bin/fake-ghc-cabal-dev"
03:17:11 <arcatan> it used to work...
03:17:33 <bitonic> Palmik: <http://www.haskell.org/ghc/docs/latest/html/users_guide/data-type-extensions.html> doesn’t mention TypeOperators, weirdly.
03:17:52 <arcatan> aha, https://github.com/creswick/cabal-dev/issues/50
03:19:35 <typoclass> (hm, i wish we had a list of all the -XSomethings with links to the relevant sections of the user guide)
03:19:38 <Palmik> danr: force of habit. :)
03:20:43 <Palmik> bitonic: indeed. There is a talk about infix type constructors, but not about the extensions and what it adds.
03:20:45 <bitonic> typoclass: I just grep the manual
03:22:06 <arcatan> typoclass: maybe make one in the wiki?
03:22:18 <typoclass> bitonic: hm, good idea. i discovered i have it on disk ...
03:22:47 <Palmik> typoclass: there is actually such a list, give me a second to find it (it does not have a link for TypeOperators though :)).
03:23:36 <neutrino> wow, .cabal is really heavy isn't it
03:23:53 <Palmik> typoclass: http://www.haskell.org/ghc/docs/latest/html/users_guide/flag-reference.html
03:23:54 * neutrino just typed rm -rf .cabal.bak and it's been going for a few minutes now.
03:24:28 <Palmik> neutrino: are you sure you did not type rm -rf . cabal.bak? :P
03:24:30 <typoclass> Palmik: ah, very good
03:24:51 <neutrino> yeah
03:24:55 <neutrino> it just finished
03:25:13 <neutrino> now removing .bak2 ...
03:25:16 <neutrino> heh
03:25:31 <neutrino> i ran du -sh on it two days ago and it took like 15 minutes.
03:25:36 <neutrino> must be yesod.
03:25:39 <Palmik> typoclass: the haskell prime wiki is also pretty good resource (the entry from the wiki usually link to the ghc manual, not the other way round though)
03:25:55 <Palmik> I agree that it would be nice to have links to all the extensions in one place.
03:26:16 <neutrino> removing both just freed up a gigabyte each.
03:27:25 <Palmik> neutrino: wow.
03:27:47 <typoclass> Palmik: yes but isn't exactly that in the link you gave? section 4.20.12
03:28:07 <Palmik> typoclass: yes, but there are not the link to the haskell prime wiki or the haskell wiki entries.
03:28:12 <Palmik> links
03:28:51 <typoclass> Palmik: ah yes, got you
03:28:53 <bitonic> Palmik: I would report a bug for that (the -XTypeOperators thing)
04:09:36 <Peaker> I wish Data.Map's Monoid instance was recursive... Map.union is less useful than recursive mappend
04:10:06 <Peaker> and if you want union from mappend, you could also fmap First, and then fmap getFirst
04:10:25 <Peaker> Though I don't want to use TMap because it can't enumerate its keys and also doesn't have a useful Show instance :(
04:15:34 * hackagebot test-framework-th 0.2.4 - Automagically generate the HUnit- and Quickcheck-bulk-code using Template Haskell.  http://hackage.haskell.org/package/test-framework-th-0.2.4 (OscarFinnsson)
04:17:55 <Palmik> Peaker: hmm... recursive in what sense? I could not find TMaps Monoid instance.
04:18:20 <Peaker> Palmik, when both keys exist, don't just ignore the second value (as Map mappend does) but mappend the values
04:19:11 <Peaker> Palmik, Conal Elliott's paper "Type class morphisms" is saying something nice: If you can, find some simple denotation for your type. For example, he changes "Map" slightly so that it becomes total, and then its denotation is simply (k -> v)  (though this does leave the issue of enumerating keys aside)
04:19:39 <Peaker> Palmik, and then, the paper says, once you have a simple denotation -- you can make sure all of your type's instances for type-classes have the same semantics as the instances of the denotation
04:19:56 <Peaker> Palmik, so the Monoid instance for a total map (TMap) is the same as the Monoid instance for (a -> b)
04:20:04 <bitonic> Peaker: well but even Map *does* denote `k -> v', but v might be _|_ :)
04:20:06 <Peaker> (which is to mappend the b's)
04:20:07 <Palmik> Peaker: oh I see. I was looking at a wrong TMap. :)
04:20:31 <Peaker> bitonic, not quite _|_ since it can figure out whether it is _|_ or not. Also it can enumerate keys
04:20:41 <bitonic> Peaker: that’s the whole point about _|_
04:20:52 <bitonic> you can’t tell if it is _|_
04:21:01 <bitonic> see halting problem etc etc
04:21:13 <sipa> but you can observe for a normal Map whether a value exists for a key or not
04:21:18 <Peaker> recovering the behavior of Map from one where mappend is recursive is:    old_mappend x y = getFirst $ (mappend `on` First) x y
04:21:19 <bitonic> sipa: yes
04:21:35 <Peaker> there is no way to recover the recursive mappend from the mappend that Data.Map uses now (you have to use unionWith mappend)
04:21:37 <Palmik> Peaker: what is the advantage of the TMap apart from the different mappend impl. (which you could implement for Data.Map as a separate function).
04:21:52 <Peaker> bitonic, right, but you *can* tell if the "k" would be inside the Map or not
04:22:00 <bitonic> Peaker, sipa: I was just saying that you can give Map a denotation
04:22:21 <bitonic> maybe not the most useful one - and I don’t know what TMap does
04:22:25 <Peaker> bitonic, that denotation wouldn't account for the "Maybe" wrapper on a result value
04:22:44 <bitonic> Peaker: I was simply thinking of !
04:22:59 <Peaker> ah, if you only have Map and (!) and no other operations, then that is a valid denotation
04:23:06 <Peaker> (but you do have other methods and those need a denotation too)
04:23:18 <bitonic> which pretty much turns Map into `Ord k => k -> v'
04:23:19 <Palmik> bitonic: it's just a Data.Map with default value.
04:23:25 <Peaker> bitonic, if you use a Map that has a "default background value" for missing keys, you can just use Nothing for that and recover the existing Map (modulu enumeration)
04:23:44 <Palmik> That is used for lookup in case the key is not present in the underlying Data.Map.
04:23:48 <sipa> Peaker: that requires a default value to exist for k, no?
04:23:49 <Peaker> but the default value makes it more like a simple function, so it can behave more like a simple function, share all the same semantics for instances, etc
04:23:57 <bitonic> Palmik, Peaker: yes, I had guess that’s what TMap does, but I don’t know the details - there are various ways of doing it
04:23:58 <sipa> Peaker: and Ord k does not provide that
04:24:04 <Palmik> Peaker: Umm... what If I store Nothing in the TMap of Maybes? :)
04:24:09 <Peaker> sipa, you only need a default value for "v", not for "k"
04:24:11 <sipa> Peaker: uh, for v
04:24:19 <sipa> yes, of course - still waking up
04:24:22 <Peaker> sipa, yeah, when constructing a TMap you give a default value
04:24:29 <Peaker> Palmik, then you can't distinguish it
04:24:33 <Palmik> Indeed.
04:24:40 <sipa> So the TMap becomes a v -> k -> v?
04:24:44 <Peaker> Palmik, and there's a "trim" function to get rid of redundancies, that has the denotation of "id"
04:24:49 <Peaker> Palmik, (but can operationally be important)
04:24:57 <bitonic> Peaker: but the naive “default map” does not let you distinguish the default values and the non-default ones
04:25:08 <Peaker> sipa, No, the TMap is just (k -> v).  To construct a tmap, you need to give a default "v", once
04:25:17 <bitonic> that’s why I was asking, I don’t know TMap
04:25:19 <Peaker> bitonic, right, but that's not a problem
04:25:24 <Palmik> Well, the paper souds interesting, I will take alook at it.
04:25:35 <Peaker> bitonic, because if you need to store Nothings, you could always have values of type (Maybe (Maybe a))
04:26:22 <Palmik> I just do not see the value of TMap when I can use lookupWithDefault (or if it does not exist, write such function).
04:26:29 <Peaker> Palmik, the value is in the simplicity
04:26:40 <Peaker> :bro Data.Map yields many dozens of methods
04:26:46 <Palmik> Hmm, that might be so.
04:26:56 <Peaker> Data.TotalMap has 4 methods, with (almost) the same power...
04:27:05 <Peaker> though I do think it's missing a couple :)
04:27:27 <Peaker> Palmik, so many operations on Data.Map's are really just Monoid compositions for various value monoids
04:27:57 <Palmik> Peaker: well, I do not think that is a fair comparison as Data.Map includes more functions than just lookup functions. :)
04:28:05 <Peaker> so does Data.TotalMap
04:29:12 <Palmik> Peaker: well... I do not see how I could do somethink like splitLookup for example.
04:29:15 <Peaker> Palmik, By re-using the function instances for Functor, Applicative, Monad, Monoid, we don't need: Map.map, Map.empty, Map.union*, Map.intersect*, Map.... and virtually the entire huge API can be replaced by just those instances
04:29:43 <Peaker> Well, the splits, minView, keys, etc, are all about enumeration - and those are indeed lacking
04:32:52 <Palmik> You can use mempty and fmap with Data.Map as well. But having intersection and union for free sounds cool.
04:33:43 <hpaste> statusfailed pasted “ArrowState instance for Kleisli m a b UndecidableInstances??” at http://hpaste.org/78632
04:34:08 <statusfailed> Can anyone help me with that^? I'm trying to make MonadState m => Kleisli m a b an instance of ArrowState
04:34:27 <Peaker> Palmik, the Functor instance is good. The Monoid instance is not the function one, and is far less useful
04:34:38 <statusfailed> (oops, I mean "MonadState s m" and "ArrowState s"
04:36:25 <statusfailed> Also, does anyone know where the utility functions for ArrowState are? it seems like it's missing lots of stuff like  'modify'
04:37:31 <Peaker> statusfailed, what are you using arrows for?
04:38:34 <statusfailed> Peaker: composing functions of the form (a -> m b)
04:38:38 <statusfailed> specifically stateful functions
04:38:43 <statusfailed> and arrow notation is useful
04:39:27 <c_wraith> :t (<=<)
04:39:29 <lambdabot> Monad m => (b -> m c) -> (a -> m b) -> a -> m c
04:40:37 <Peaker> statusfailed, Do you use proc do?
04:40:44 <statusfailed> Peaker: yep
04:40:58 <statusfailed> but maybe I can do everything with do? I haven't really considered it
04:41:13 <mm_freak> edwardk: i have a language, in which an expression is only well-formed when there are no free variables…  is there an easy way in 'bound' to check whether that's the case?
04:41:16 <Peaker> ah, I dislike the Arrow class so I've never tried using proc do
04:41:49 <mm_freak> edwardk: nevermind, found it myself again =)
04:42:16 <mm_freak> 'closed' is what i was looking for
04:43:48 <mm_freak> the bound library really saves me from a lot of manual work
04:45:08 <mm_freak> statusfailed: you don't need the arrow interface for a monad…  you have Applicative, and the equivalents to the Category combinators are (<=<) and 'return'
04:46:06 <mm_freak> ArrowState ⇒ MonadState, ArrowLoop ⇒ MonadFix, ArrowChoice ⇒ Monad, ArrowApply ⇒ Monad, etc.
04:46:23 <mm_freak> there is really no reason to use arrow combinators here
04:47:22 <booski> Is there a way to get only one value X from a record A {X, Y, Z} in pattern matching? I wanna something like `record@(X = x)' instead of `record@(Record x _ _)'
04:47:40 <mm_freak> booski: Constr { field = name }
04:48:04 <statusfailed> mm_freak: yeah... now I feel dumb :D
04:48:13 <sipa> so in your case: record@(Record { x = x })
04:48:15 <statusfailed> It just seems to fit dataflow so well ;_;
04:48:35 <mm_freak> statusfailed: don't feel dumb, just recognize that you only need Arrow when whatever you're using is /not/ a monad ;)
04:49:15 <b____> I have this cute little EDSL that basically wraps around Map to provide a way to specify recurring payments, contracts and so on (which can be executed inside the State monad). Basic use of these operations is `do [Day] $ Operation; [Day] $ Operation; etc`. I would now like to write a command line tool that provides an interface to arbitrary haskell files with such do statements, but I realise I can't dynamically load haskell code.
04:49:15 <b____>  What's the way to make this happen?
04:49:29 <booski> mm_freak: nice, thanks
04:49:43 <mm_freak> statusfailed: http://ertes.de/new/tutorials/arrows.html for an unfinished arrow tutorial that explains all of this
04:49:59 <statusfailed> mm_freak: Actually I read that a while ago, I must have not paid enough attention :D
04:50:05 <statusfailed> I think that was the first arrow tutorial I read
04:50:33 <mm_freak> b____: see the 'hint' library
04:51:00 <b____> thanks mm_freak
04:51:08 <mm_freak> statusfailed: then read it again…  it explains the correspondence between Category and monadic combinators
04:51:15 <statusfailed> New additions?
04:51:25 <mm_freak> nope
04:51:28 <statusfailed> dangit :D
04:51:32 <statusfailed> Ok, will do
04:51:48 <mm_freak> the tutorial explains arrows fully…  what's missing is a full explanation of the automaton arrow =)
04:51:53 <mm_freak> a very interesting non-monad =)
04:52:06 <mm_freak> (well, it is a monad, but a very impractical one)
04:53:39 * bitonic is still waiting for an ArrowLoop instance for SF
04:54:00 <mm_freak> bitonic: SF has an ArrowLoop instance since ages
04:54:11 <bitonic> mm_freak: which SF?
04:54:18 <mm_freak> bitonic: you, you mean StreamFunction
04:54:26 <mm_freak> i thought you mean yampa's SignalFunction =)
04:55:06 <mm_freak> bitonic: what's the definition?  newtype SF a b = SF ([a] -> [b])?
04:55:11 <bitonic> mm_freak: `[a] -> [b]'
04:55:12 <bitonic> yes
04:55:29 <mm_freak> is it zipping or producting?
04:55:38 <bitonic> and Huges tutorial has that as an exercises
04:55:54 <mm_freak> i guess it's zipping, when it says "stream" function
04:56:03 <bitonic> mm_freak: wait, let me dig up the paper
04:57:41 <bitonic> instance Arrow SF where
04:57:41 <bitonic>     arr f = SF (map f)
04:57:41 <bitonic>     SF f >>> SF g = SF (f >>> g)
04:57:49 <bitonic> I’m pretty sure it was that one
05:01:13 <mm_freak> bitonic: it's going to have a very weird ArrowLoop instance just like the weird MonadFix instance for []
05:01:55 <bitonic> mm_freak: I’d like to see an ArrowLoop instance that behaves well for that - I remember that me, you, and elliott couldn’t find one
05:06:42 <bitonic> and it’s an exercises in Huges’ tutorial
05:06:47 <bitonic> so that was annoying.
05:07:19 <mm_freak> bitonic: wait a minute, i think i can write the ArrowLoop instance =)
05:09:06 <hbegott> What would implementing a bittorrent client for linux  teach me about linux?
05:09:47 <Nereid> bluh
05:09:52 <Nereid> snap uses data-lens?
05:10:02 <`nand`> quick, call in the edwardk tag team
05:16:58 <mm_freak> bitonic: my quick attempt failed, but i can provide a "partial" ArrowLoop instance
05:17:29 <Nereid> but I don't want to use data-lens.
05:17:32 <bitonic> mm_freak: well, I can provide a “partial” instance of every class.  of every type, in fact!
05:17:42 <bitonic> :)
05:18:42 <hbegott> What would implementing a bittorrent client for linux  teach me about data communication?
05:18:51 <kennyd> laptop
05:18:52 <bitonic> hbegott: I think you’re in the wrong channel
05:19:23 <ClaudiusMaximus> bitonic: i seem to remember SF / ArrowLoop / delay being implemented by prepending an element
05:20:35 <bitonic> ClaudiusMaximus: uhm, OK
05:20:37 * hackagebot yesod 1.1.5 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-1.1.5 (MichaelSnoyman)
05:20:42 <bitonic> I’m not sure I see how that would work right now
05:22:59 <ClaudiusMaximus> bitonic: nevermind, delay is for ArrowCircuit, i must have been getting confused
05:23:33 <Saizan>  ?type loop
05:23:36 <Saizan> ?type loop
05:23:37 <`nand`> bitonic: can you write a partial instance Monad Int? ;)
05:23:38 <lambdabot> ArrowLoop a => a (b, d) (c, d) -> a b c
05:25:34 <hbegott> bitonic: id be doing it in haskell
05:25:38 <Saizan> ?type \f -> \bs -> let (cs,ds) = unzip . f . zip bs $ ds in cs
05:25:39 <lambdabot> ([(a1, b)] -> [(a, b)]) -> [a1] -> [a]
05:25:39 * hackagebot base-compat 0.2.1 - A compatibility layer for base  http://hackage.haskell.org/package/base-compat-0.2.1 (SimonHengel)
05:25:41 * hackagebot yesod-auth 1.1.2.1 - Authentication for Yesod.  http://hackage.haskell.org/package/yesod-auth-1.1.2.1 (MichaelSnoyman)
05:25:43 * hackagebot yesod-form 1.2.0.2 - Form handling support for Yesod Web Framework  http://hackage.haskell.org/package/yesod-form-1.2.0.2 (MichaelSnoyman)
05:25:46 * hackagebot yesod-persistent 1.1.0.1 - Some helpers for using Persistent from Yesod.  http://hackage.haskell.org/package/yesod-persistent-1.1.0.1 (MichaelSnoyman)
05:25:48 * hackagebot yesod-test 0.3.2 - integration testing for WAI/Yesod Applications  http://hackage.haskell.org/package/yesod-test-0.3.2 (MichaelSnoyman)
05:26:38 <Saizan> bitonic: considered the implementation above the hackagebot messages?
05:26:47 <bitonic> Saizan: going out now I’ll check it later but I’m pretty sure that lacks in lazyness
05:27:36 <bitonic> or something like that - I really don’t remember the details now, I just remember it being annoying
05:27:47 <hpaste> ClaudiusMaximus pasted “ArrowLoop SF” at http://hpaste.org/78634
05:28:02 <Saizan> well, you loop can only work for sufficiently lazy f's
05:28:14 <ClaudiusMaximus> which I probably copy/pasted from some paper or other
05:28:25 <Saizan> ClaudiusMaximus: ah, makes sense
05:29:05 <bitonic> ClaudiusMaximus, Saizan, mm_freak: ah wait, then it was another data type
05:29:13 <bitonic> I’ll check when I come back
05:30:48 <Saizan> > fix (const [])
05:30:50 <lambdabot>   []
05:31:09 <Saizan> ClaudiusMaximus' instance kind of kills that option
05:31:34 <Saizan> oh, actuallt it doesn't, because stream won't be forced in that case
05:33:38 <Saizan> it's quite cleverly exploiting that a non-strict [a] -> [b] function has to decide whether it returns [] or (x:xs) before lookting at it's argument, and in the first case it'll never need the argument
05:37:56 <Nereid> looks like I can't avoid data-lens if I want to use snaplets :(
05:38:31 <bindy> Hi, does anyone know how to share type parameters between class definition and its instance?
05:38:36 <bindy> eg. I have: data DB a = forall z. (IConnection z) => DB (ReaderT z IO a)
05:38:43 <bindy> Now when I need to make DB an instance of MonadReader, I would like to say, that the first parameter of MonadReader is same as the 'z' parameter from the forall in DB.
05:39:00 <Nereid> you can't do that.
05:39:43 <Nereid> given a value of type DB a, you don't know what 'z' was used to construct it.
05:39:44 <bindy> I can say: instance IConnection z => MonadReader q (DB (ReaderT z IO a)), but then it's not (*->*)
05:40:02 <Nereid> no, you can't, the right side doesn't make sense.
05:40:10 <bindy> I know :(
05:40:15 <Nereid> don't confuse the type DB with the constructor DB.
05:40:24 <Nereid> DB :: forall z. IConnection z => ReaderT z IO a -> DB a
05:40:38 * hackagebot stringbuilder 0.4.0 - A writer monad for multi-line string literals  http://hackage.haskell.org/package/stringbuilder-0.4.0 (SimonHengel)
05:40:49 <Nereid> you can't get a z value out of DB a, because you don't know what z was.
05:40:58 <mm_freak> bitonic: i mean, i can provide a "useful" instance
05:41:44 <Saizan> at best you can defined data AnyIConn = forall z. IConnection z => AnyIConn z; instance MonadReader AnyIConn DB where ..
05:41:50 <Saizan> *define
05:41:53 <Nereid> yes
05:41:54 <bindy> Nereid: well, all my code is just an abstraction that all it needs to know is that the parameter is 'some instance' of IConnection, I can't do that?
05:42:20 <mm_freak> @src [] mfix
05:42:20 <lambdabot> mfix f = case fix (f . head) of
05:42:20 <lambdabot>            []    -> []
05:42:20 <lambdabot>            (x:_) -> x : mfix (tail . f)
05:42:28 <Saizan> bindy: that's roughly what you get with my code
05:42:34 <Nereid> but, depending on IConnection, you may or may not be able to write an IConnectio ninstance for AnyIConn
05:42:45 <bindy> Saizan: hmm, i think i get it...
05:43:23 <Nereid> why do you want to use an existential, anyway?
05:44:16 <Saizan> yeah, it probably makes more sense to have z as a parameter of DB
05:44:25 <Nereid> probably
05:44:34 <bindy> Saizan: Nereid: a sec, i will show you what is the purpose of it
05:45:29 <bindy> Saizan: Nereid: I was trying to do something like this: http://codereview.stackexchange.com/questions/2140/idiomatic-haskell-database-connectivity
05:45:39 <bindy> but I wanted to generalize the Connection
05:46:05 <bindy> the Connection can be anything that instances Database.HCBC.IConnection
05:46:26 <Saizan> yeah, using an existential is logically wrong there
05:47:03 <bindy> so I would be better with the AnyIConn here?
05:47:10 <mm_freak> bitonic: i think i did it
05:47:11 <Saizan> no, AnyIConn is the same thing
05:47:34 <Saizan> what you want is "newtype DB c a = D (ReaderT c IO a)"
05:48:21 <bindy> but then I would have to explicitly say what connection I use for each function defined. and that's wrong because it's just a wrapper, database agnostic
05:48:22 <`nand`> oh crap, I think I understood how Data.Reflection.reify works; it uses unsafeCoerce to turn (Ctx => a -> b) into Ctx -> a -> b
05:48:25 <`nand`> that's nasty
05:48:27 <bindy> should work for all databases
05:48:40 <hpaste> “Ertugrul Söylemez” pasted “ArrowLoop for StreamFunction” at http://hpaste.org/78636
05:48:41 <Saizan> bindy: you'd be polymorphic in that parameter in your functions
05:49:01 <mm_freak> bitonic: see paste
05:49:23 <bindy> I see, make every single function polymorphic?
05:49:27 <Saizan> yep
05:49:45 <Saizan> bindy: another option is to wrap the polymorphism in the DB type itself: newtype DB a = D (forall c. IConnection c => ReaderT c IO a)
05:50:16 <bindy> hey this looks like what i need!
05:50:43 <Saizan> you'd still need AnyIConn for the MonadReader instance though
05:50:58 <Saizan> mh, but it'd be useless
05:51:27 <Saizan> i still think the easiest way to work with this is keep the 'c' parameter
05:52:46 <bindy> Saizan: so that last solution would not work with GeneralizedNewtypeDeriving to derive MonadReader automatically?
05:52:53 <bindy> like in that example?
05:52:57 <Saizan> bindy: nope
05:53:14 <Saizan> the version with the 'c' parameter would
05:53:21 <bindy> yeah, I know
05:53:53 <bindy> it would be better if I knew a bit more what I am doing :) I guess I have some reading ahead
05:54:14 <bindy> thank you for showing me the direction, anyway
05:54:19 <Saizan> np
05:55:23 <Saizan> (the MonadReder AnyIConn DB version might be useful with the last solution, but only if you never care that you always get the same type of connection out)
05:55:38 * hackagebot doctest 0.9.4 - Test interactive Haskell examples  http://hackage.haskell.org/package/doctest-0.9.4 (SimonHengel)
05:55:53 <bindy> what do you mean, same connection?
05:56:32 <bindy> the connection will actually be same throughout whole application, but different in a different application
05:56:56 <bindy> i mean *type of connection*]
05:57:53 <Saizan> i mean that e.g. in the expression "do AnyIConn c1 <- ask; AnyIConn c2 <- ask; ..."  in the ... c1 and c2 won't have the same type
05:58:15 <neutrino_> hi
05:58:25 <neutrino_> i have a practical question
05:58:33 <neutrino_> what are some useful examples of comonads?
05:59:10 <Nereid> lenses are all about the store comonad
05:59:50 <neutrino_> interesting
05:59:52 <Nereid> Store s a = (a -> s, a)
06:00:04 <Nereid> Lens s a = s -> Store s a
06:00:05 <neutrino_> is "a" the monoid?
06:00:15 <Nereid> a is the "inner" type of the lens
06:00:41 <mm_freak> neutrino_: Store is probably one of the most useful comonads
06:00:50 <Nereid> Store s is the comonad. (exercise: implement the comonad methods)
06:01:01 <neutrino_> i'm not good enough for that yet
06:01:07 <Nereid> yes you are.
06:01:12 <Nereid> just follow the types, and check the laws
06:01:19 <mm_freak> neutrino_: write the identity comonad first
06:01:21 <neutrino_> i don't know what Store does
06:01:33 <neutrino_> and i've only barely ever used lenses
06:01:46 <Nereid> that's ok, you don't need to know to write the instance
06:01:47 <Nereid> :p
06:02:02 <mm_freak> neutrino_: then write the instance for coreaders:  instance Comonad ((,) e)
06:02:11 <mm_freak> finally write Store =)
06:02:53 <mm_freak> monads are to comonads what localization is to globalization =)
06:03:01 <Nereid> why
06:03:13 <mm_freak> Nereid: check the type of 'extend'
06:03:24 <Nereid> yes, it's a thing
06:03:31 <Nereid> but what does that have to do with local/global
06:03:52 <mm_freak> (>>=) allows you to construct a structure by looking at a certain spot of another structure
06:04:08 <mm_freak> 'extend' allows to construct a certain spot of a structure by looking at the entirety of another structure
06:05:08 <neutrino_> hmm
06:05:11 <neutrino_> what's a coreader?
06:05:31 <neutrino_> :t extend
06:05:31 <mm_freak> (>>=) constructs a world by looking at a grain of sand, while 'extend' constructs a world grain by grain by looking at the entirety of another world
06:05:32 <jackss> is there a function that turns x into [x] ?
06:05:32 <lambdabot> Not in scope: `extend'
06:05:37 <neutrino_> right
06:05:38 <mm_freak> jackss: return
06:05:38 * hackagebot cipher-aes 0.1.4 - Fast AES cipher implementation with advanced mode of operations  http://hackage.haskell.org/package/cipher-aes-0.1.4 (VincentHanquez)
06:05:58 <jackss> > return 10
06:06:00 <lambdabot>   No instance for (GHC.Show.Show (m0 a0))
06:06:00 <lambdabot>    arising from a use of `M44276244...
06:06:08 <mm_freak> neutrino_: Reader is really just (->), and the dual Coreader is really just (,)
06:06:13 <jackss> mm_freak: huh?
06:06:15 <mm_freak> > return 10 :: [Integer]
06:06:17 <lambdabot>   [10]
06:06:27 <mm_freak> jackss:
06:06:29 <mm_freak> :t return
06:06:30 <lambdabot> Monad m => a -> m a
06:06:32 <jackss> okay
06:06:34 <neutrino_> jackss: return
06:06:36 <mm_freak> now set m = []
06:06:44 <typoclass> jackss: you can use (:) to prepend it to an empty list -- "x : []"
06:06:45 <neutrino_> oh you got help already
06:06:47 <typoclass> > 42 : []
06:06:49 <lambdabot>   [42]
06:06:58 <jackss> thanks all
06:07:09 <mm_freak> jackss: of course that's the list-monadic notion of "turning x into [x]"
06:07:11 <b____> why is this illegal: `type Universe = Num a => Map String a`
06:07:17 <mm_freak> there are many other sensible notions
06:07:53 <neutrino_> mm_freak: how do you know what the dual to something is?
06:08:13 <mm_freak> neutrino_: i've been told =P
06:08:53 <neutrino_> k :)
06:08:55 <mm_freak> but it's really intuitive:  monads are "always safe to get into (return)", comonads are "always safe to get out of (extract)"
06:09:16 <mm_freak> you can always go into (e ->) and get out of (e,)
06:09:28 <neutrino_> can you
06:09:35 <neutrino_> why :|
06:09:40 <mm_freak> goInto x = \env -> x
06:09:46 <mm_freak> getOutOf = snd
06:10:11 <mm_freak> goInto :: a -> Reader e a
06:10:14 <neutrino_> i don't know what that means
06:10:19 <mm_freak> getOutOf :: (e, a) -> a
06:10:24 <neutrino_> hm
06:10:35 <mm_freak> getOutOf :: Coreader e a -> a
06:10:36 <neutrino_> right
06:11:02 <neutrino_> because you can't get out of a monad
06:11:03 <mm_freak> neutrino_: do you understand Monad in an abstract sense?
06:11:09 <neutrino_> once you've caught a monad you can never get rid of it
06:11:14 <mm_freak> you can get out of the Identity monad
06:11:23 <neutrino_> that's not a *real* monad ;)
06:11:30 <mm_freak> why not=
06:11:31 <mm_freak> ?
06:11:35 <neutrino_> i'm just joking
06:11:39 <mm_freak> ;)
06:11:45 <mm_freak> you get out of monads all the time
06:11:51 <neutrino_> but other than Identity i don't know any monads you can just disregard like that
06:11:58 <mm_freak> every time you use 'foldr', 'maybe' and 'runState' you get out of a monad
06:12:14 <neutrino_> that's not really "getting out" imo, just "burning it off"
06:12:29 <mm_freak> it is
06:12:41 <mm_freak> foldMaybe :: b -> (a -> b) -> Maybe a -> b
06:12:45 <neutrino_> the only good monad analogy i've ever heard of is that monads are like std's
06:13:02 <mm_freak> foldList :: b -> (a -> b -> b) -> [a] -> b
06:13:11 <neutrino_> then i guess runState would be like dying with one and having your skeleton repurposed.
06:13:14 <mm_freak> "to get out of" can be formalized as folding
06:13:33 <neutrino_> right, folding is actually a neat way to evaluate a monad
06:13:39 <mm_freak> foldIdentity :: (a -> b) -> Identity a -> b
06:13:47 <neutrino_> i never use it though, wonder why
06:13:53 <mm_freak> you should =)
06:13:59 <neutrino_> probably
06:14:16 <neutrino_> @type foldMaybe
06:14:18 <lambdabot> Not in scope: `foldMaybe'
06:14:21 <mm_freak> :t maybe
06:14:22 <lambdabot> b -> (a -> b) -> Maybe a -> b
06:14:27 <neutrino_> aha
06:14:27 <mm_freak> that's Maybe's fold =)
06:14:31 <mm_freak> :t either
06:14:32 <lambdabot> (a -> c) -> (b -> c) -> Either a b -> c
06:14:34 <mm_freak> Either's fold =)
06:14:41 <neutrino_> why aren't they all just called "fold"?
06:14:47 <bitonic> ClaudiusMaximus, Saizan, mm_freak: sorry, that SF was the wrong type - Huges define ArrowLoop in that paper
06:15:05 <mm_freak> neutrino_: because you would get name clashes
06:15:12 <bitonic> I was actually thinking of `data SP a b = Put b (SP a b) | Get (a -> SP a b)'
06:15:17 <neutrino_> why would you?
06:15:22 <bitonic> I... think
06:15:23 <neutrino_> you don't get name clashes on return etc
06:15:35 <ClaudiusMaximus> bitonic: ah, then i have no clue
06:15:36 <mm_freak> neutrino_: because 'return' has a common structure for all monads
06:16:02 <mm_freak> neutrino_: i defined a Fold class once, but it uses language extensions and is not particularly useful
06:16:37 <mm_freak> there is a formal notion of "folding" in category:  a natural transformation
06:16:52 <mm_freak> and it's very difficult to capture this notion in a type class in a sensible way
06:17:02 <mm_freak> category theory*
06:22:27 <mSSM> Why does hoogle not find a definition of (,) ?
06:23:05 <mSSM> i.e.: "the non-monadic two-argument function (,)" as defined on http://en.wikibooks.org/wiki/Haskell/Understanding_monads/State in the Example: Rolling Dice section.
06:23:37 <danr> neutrino_: you can abstract over folds (or catamorphisms) using an F-algebra, see http://www.haskell.org/haskellwiki/Catamorphisms
06:25:22 <rwbarton> @hoogle ,
06:25:22 <lambdabot> Parse error:
06:25:22 <lambdabot>   ,
06:25:22 <lambdabot>   ^
06:25:32 <rwbarton> ah
06:25:46 <mSSM> rwbarton: (,) freaks out as well
06:26:13 <rwbarton> , is syntax, and (,) is a bit of a special case
06:26:48 <mm_freak> n :: X a -> Y a  -- when fmap f . n = n . fmap f, then this is in fact an infranatural transformation, because of the polymorphic type a, right?
06:26:50 <mSSM> I didn't think of of (,) as a binary function.
06:26:57 <jackss> :t (,)
06:26:59 <lambdabot> a -> b -> (a, b)
06:27:13 <mSSM> It's pretty cool though.
06:27:25 <jackss> > (,) 1 "one"
06:27:27 <lambdabot>   (1,"one")
06:27:32 <rwbarton> perhaps hoogle is a bit confused about whether you are searching for a type or a value
06:28:25 <rwbarton> @hoogle (,)
06:28:25 <lambdabot> Prelude undefined :: a
06:28:25 <lambdabot> Data.Function fix :: (a -> a) -> a
06:28:25 <lambdabot> Control.Monad.Fix fix :: (a -> a) -> a
06:28:28 <jackss> if , is infix function why doesnt 1, 2 (without parenthesis) work?
06:28:52 <rwbarton> , isn't an infix function
06:29:19 <rwbarton> as i said above a bit it is part of the syntax
06:31:33 <rogerthealien> i'm trying to create a complex number out of a double:  1.0 :: Complex Double works, but if I try let a = 1.0, a :: Complex Double doesn't work... how would I be able to find out what type 1.0 is in the first expression?
06:31:43 <rwbarton> there's also (,,), etc. which wouldn't arise from any infix function anyways
06:38:58 <dcoutts_> http://www.reddit.com/r/haskell/comments/145g9t/hackage_2_test_instance_up_again_now_with_more_of/
06:40:17 <bindy> Saizan: moving the polymorphism into the DB type and then using AnyIConn for instancing MonadReader worked great! solved my problem entirely, thanks again.
06:41:17 <Saizan> bindy: np
06:46:51 <FireFly> Does "non-generic"  \x -> [x]  have a name? I mean, something that does precisely that (and is of type  a -> [a]), rather than pure/return
06:47:13 <bitonic> FireFly: it’s the monkey operator (:[])
06:47:21 <FireFly> ...oh, right
06:47:37 <mSSM> How do I desugar a `let' expression inside a do block?
06:47:48 <bitonic> mSSM: >>= + return
06:47:58 <umpalumpa> hello everybody I have a question about this function (I just began with haskell) foldTree :: (Ord a) => b -> (a -> b -> b -> b) -> BSTree a -> b foldTree b _ Nil = b foldTree b f (Node a leftTree rightTree) = f (a) (foldTree b f leftTree) (foldTree b f leftTree)
06:48:05 <mSSM> bitonic: wut?
06:48:21 <mSSM> bitonic: e.g.: do { foo <- bar ; let ... }
06:48:22 <bitonic> mSSM: do let x = ...; ... === return ... >>= \x -> ...
06:48:44 <neutrino_> i don't think you can desugar let, can you?
06:48:46 <sipa> or just let x in [what follows of do block]
06:48:55 <umpalumpa> ghci tells me that its applied for 3 argument but I have only 2 ....what I'm suppose to do here?
06:49:00 <bitonic> or yes what sipa said
06:49:08 <mm_freak> edwardk: i'm failing to use a free monad with 'bound'…  is there an example for that?
06:49:14 <mm_freak> or is it even possible?
06:49:35 <neutrino_> right, you can bubble up the let, but not actually remove it (i think)
06:49:37 <mSSM> @undo do { foo <- bar ; let baz = qux ; return baz }
06:49:58 <mSSM> > @undo do { foo <- bar ; let baz = qux ; return baz }
06:50:11 <sipa> @botsnack
06:50:19 <mSSM> lambdabot don't like me :(
06:50:29 <mSSM> FU lambdabot!
06:50:59 <mm_freak> mSSM: (do x1 <- c1; let x2 = f x1; c x2) = c1 >>= \x1 -> let x2 = f x1 in c x2
06:51:07 <mm_freak> really straightforward translation
06:51:24 <umpalumpa> hello everybody I have a question about this function (I just began with haskell) foldTree :: (Ord a) => b -> (a -> b -> b -> b) -> BSTree a -> b foldTree b _ Nil = b foldTree b f (Node a leftTree rightTree) = f (a) (foldTree b f leftTree) (foldTree b f leftTree)
06:51:29 <umpalumpa> ghci tells me that its applied for 3 argument but I have only 2 ....what I'm suppose to do here?
06:51:43 <mSSM> mm_freak, bitonic, sipa : thanks
06:52:14 <statusfailed> Does the pairing of (a -> b -> a) and an initial a in the definition of foldl have a name like Monoid does?
06:52:16 <mm_freak> umpalumpa: first of all, repeating yourself won't get you answers more quickly, secondly please use hpaste.org
06:53:09 <umpalumpa> sorry won't happen again
06:53:22 <mm_freak> statusfailed: it's a fold
06:53:52 <mm_freak> statusfailed: well, no, it isn't
06:53:57 <mm_freak> foldl is not a fold
06:54:59 <mm_freak> statusfailed: a certain class of folds (hylomorphisms) forms a category
06:56:42 <byorgey> umpalumpa: that code looks OK to me, we'd have to see the exact error message
06:56:52 <byorgey> umpalumpa: you can paste the error message along with the code on hpaste.org
06:57:10 <statusfailed> mm_freak: but there's no x for "Mean is to x what Sum is to Monoid"?
06:57:16 <umpalumpa> ok thank you for your help
06:57:43 <peteriserins> why is II an endofunctor?
06:57:59 <mm_freak> statusfailed: the "base element" (as i call it) of foldr is an artefact of [], there is nothing special about it
06:57:59 <peteriserins> doesn't it map to a different category
06:58:36 <byorgey> peteriserins: what's II ?
06:58:55 <peteriserins> category of pairs
06:58:57 <mm_freak> statusfailed: imagine a fold for this type:  newtype Pair a = Pair a a
06:59:10 <mm_freak> statusfailed: foldPair :: (a -> b) -> (a -> b) -> Pair a -> b
06:59:29 <peteriserins> byorgey: so it takes sets into their cartesian products
06:59:47 <peteriserins> byorgey: || A = A x A
06:59:54 <mm_freak> statusfailed: no "base element" (or whatever you call it) to be seen anywhere
06:59:56 <statusfailed> mm_freak: I'm not following what foldPair is supposed to do, could you explain?
07:00:04 <byorgey> peteriserins: sounds like it is a functor  Set -> Set
07:00:10 <mm_freak> statusfailed: foldPair does to Pair what foldr does to []
07:00:16 <byorgey> peteriserins: I mean you could also think of it as a functor from  Set -> Set x Set
07:00:30 <peteriserins> byorgey: I see, so it's fine if its not surjective?
07:00:34 <byorgey> the two formulations are equivalent
07:00:35 <byorgey> sure
07:00:48 <byorgey> functors definitely don't have to be surjective
07:00:56 <byorgey> (or injective)
07:01:05 <statusfailed> mm_freak: I'm probably being dumb here, why are there two functions instead of one?
07:01:32 <mm_freak> statusfailed: my bad, it should be one binary function =)
07:01:43 <mm_freak> foldPair :: (a -> a -> b) -> Pair a -> b
07:01:46 <peteriserins> byorgey: makes sense
07:01:58 <statusfailed> mm_freak: oh right, now i'm with you haha
07:02:05 <mm_freak> sorry
07:02:28 <mm_freak> but there is this:  newtype TwoTimes a = One a | Two a
07:02:33 <mSSM> Something I was thinking of recently: is there research under way to create a "functional" computer?
07:02:39 <mm_freak> foldTwoTimes :: (a -> b) -> (a -> b) -> TwoTimes a -> b
07:02:51 <mm_freak> (it's Either and either in disguise of course)
07:02:57 <statusfailed> mSSM: I think it's been done (kinda
07:03:54 <mSSM> statusfailed: Can you point me to something?
07:04:13 <statusfailed> mSSM: http://www.cs.york.ac.uk/fp/reduceron/
07:04:54 <statusfailed> also I think lisp machines might be relevant, depending on what you meant :)
07:05:45 <statusfailed> mm_freak: I guess what i'm really looking for is stateful functions, like Mean
07:05:55 <mm_freak> statusfailed: what's Mean?
07:06:07 <statusfailed> the mean*
07:06:21 <mm_freak> question remains
07:06:54 <mSSM> statusfailed: looks dead though, does it now?
07:07:12 <statusfailed> mSSM: yep looks that way
07:07:30 <statusfailed> mm_freak: sorry, absolutely horrible connection, having trouble being prompt :p
07:08:05 <statusfailed> mm_freak: ok, I mean a function iteratively computing the mean, which has only one valid start state
07:08:48 <mm_freak> statusfailed: i don't think of that as something stateful, but as something composition
07:08:56 <mm_freak> there is not a "start state", but an "empty sum"
07:09:07 <mm_freak> and there is an associative binary function
07:09:15 <mm_freak> associative, closed binary function that is
07:09:19 <statusfailed> mm_freak: i'm not sure about the associative part tho
07:09:20 <mm_freak> and that's nothing but a monoid
07:10:25 <mm_freak> 'and', 'or', 'sum', 'product' and 'concat' all work in that manner
07:11:20 <hpaste> umpalumpa pasted “foldTree” at http://hpaste.org/78638
07:11:39 <statusfailed> mm_freak: right; but that mean function is not associative, right?
07:11:53 <statusfailed> depending on what that initial state is, anyway
07:12:18 <Philonous> Is it feasible to implement a Handle interface for custom connection types (e.g. tls)?
07:12:33 <umpalumpa> byorgey, I just paste the code into hpaste.org.
07:12:36 <rwbarton> (a -> b -> b) can be called "an action of a on b". then you can also say "b is an a-module"
07:13:32 <mm_freak> statusfailed: you can interpret the mean as summing pairs
07:13:38 <rwbarton> provided a is a monoid and the action is compatible with that
07:13:41 <statusfailed> rwbarton: When that function is paired with a unique seed a, does that combination have a name?
07:14:02 <mm_freak> statusfailed: (x1, y1) + (x2, y2) = (x1 + x2, y1 + y2)
07:14:16 <Philonous> And can I get the rts to deschedule my thread until an event arrives?
07:14:56 <mm_freak> statusfailed: in that monoid you would express 'mean' as:  mean = foldl' (+) 0 . zip (repeat 1)
07:15:01 <rwbarton> I switched a and b on you
07:15:25 <zhulikas> @src (+) :: (a, b)
07:15:25 <lambdabot> Source not found. Are you on drugs?
07:15:38 <zhulikas> who told you that??
07:15:38 <rwbarton> but, not really
07:15:48 <mm_freak> Philonous: you should probably not do that, but instead use a stream processing abstraction
07:16:22 <Philonous> mm_freak:  You are talking about the Handle interface, right?
07:16:30 <mm_freak> Philonous: i am
07:17:04 <mm_freak> Philonous: as a side note TLS is already implemented for conduit and enumerator
07:17:11 <mm_freak> so you don't have to reinvent the wheel
07:17:41 <Philonous> mm_freak:  Conduits are awkward to use when you want to grab a few bytes in multiple places
07:17:53 <mm_freak> why?
07:18:30 <Philonous> mm_freak:  Your application would either have to live in the Sink monad or you have to figure out how to handle leftovers
07:18:44 <mm_freak> Philonous: a conduit is low level…  you can have a high level interface to the conduit:  let it run in one thread and provide the actual data via an MVar/TMVar
07:19:06 <hpaste> umpalumpa pasted “foldTree” at http://hpaste.org/78639
07:19:19 <Philonous> mm_freak:  That's actually exactly what I'm doing.
07:19:30 <Peaker> hmm.. getting an ambiguous type error upon :load, but a-ok when building non-interactively
07:19:43 <Peaker> I guess ghci's no-MR-by-default is the problem?
07:19:43 <mm_freak> Philonous: also conduits can actually handle leftovers across multiple runResourceTs, but i recommend using the concurrency solution
07:19:47 <rwbarton> you might be interested in the recently announced io-streams package
07:20:00 <hpaste> umpalumpa pasted “foldTree” at http://hpaste.org/78640
07:20:03 <Peaker> ah, yeah, that's it
07:20:21 <hpaste> me pasted “Palindrome” at http://hpaste.org/78641
07:20:46 <Amoeba1> Hi all.
07:20:51 <mm_freak> Philonous: http://hackage.haskell.org/packages/archive/conduit/0.5.5/doc/html/Data-Conduit.html#g:6
07:21:09 <Amoeba1> I remember a Haskell lecture series from a German University. Does anyone have a link to that?
07:21:19 <the37yrOldVirgin> So the Palindrome thing I just pasted. Can someone tell me if the zipped list is fully evaluated when I start taking from it, or not? Wrapping my head around lazy evaluation
07:21:25 <hpaste> umpalumpa pasted “foldTree” at http://hpaste.org/78642
07:21:29 <Philonous> mm_freak:  Yes, but than you have to pass around the new conduit
07:21:44 <mm_freak> Philonous: just like you would have to pass a Handle around
07:22:03 <mm_freak> or an MVar, or an …
07:22:05 <hpaste> umpalumpa pasted “foldTree” at http://hpaste.org/78643
07:22:24 <mm_freak> Philonous: the other option in all three cases would be a global variable, and you really don't want that =)
07:22:29 <Amoeba1> I think I found it. Thanks.
07:22:32 <Amoeba1> http://video.s-inf.de/#FP.2005-SS-Giesl.(COt).HD_Videoaufzeichnung
07:22:35 <Shamanoid> guys, is there a way to stop print functions from showing double quotations
07:22:39 <Clint> how does one pass a conduit around anyway?
07:22:48 <mm_freak> Shamanoid: no, use putStrLn for strings
07:22:52 <hpaste> umpalumpa pasted “foldTree” at http://hpaste.org/78644
07:23:28 <Philonous> mm_freak:  I can pass the MVar to two threads and don't worry about it. I can't do the same for a conduit. I'd have to synchronize with an MVar
07:23:36 <mm_freak> Clint: just like you pass around other first class things
07:23:50 <mm_freak> Philonous: hence my suggestion
07:23:56 <hpaste> umpalumpa pasted “foldTree” at http://hpaste.org/78645
07:24:23 <mm_freak> use network-conduit-tls for the low level, concurrency for communication
07:25:27 <hpaste> umpalumpa pasted “foldTree” at http://hpaste.org/78646
07:26:05 <Clint> mm_freak: what i actually want to do is convert a m (Response (ResumableSource m ByteString)) to a ResumableSource m ByteString
07:28:13 <rogerthealien> noob question, i get a parse error when i have 2 '<-' operators in a do block... can you use only one <- in a do block? or is just my indentation wrong?
07:28:50 <Clint> rogerthealien: hpaste.org
07:29:00 <Philonous> rogerthealien:  It has to be something else
07:29:25 <`nand`> > do { a <- [1..3]; b <- [4..5]; return (a,b) }
07:29:27 <lambdabot>   [(1,4),(1,5),(2,4),(2,5),(3,4),(3,5)]
07:31:43 <Philonous> mm_freak:  So would you say it's not worth bothering to create a Handle interface for a new connection type?
07:31:46 <rogerthealien> Clint, Philonous: it was the indentation, thanks... i'm working with some legacy code and every now and again i get these indentation problems, do you know of any tools to fix indentation? maybe something from python?
07:32:43 <mm_freak> Philonous: because it's hard low level work
07:33:29 <`nand`> I thought ‘indentation fixing’ tools only exist for languages which are /not/ indentation sensitive
07:33:29 <Philonous> So I won't bother.
07:33:38 <deech> How do I include static libraries at the REPL? I'm trying to use with libclang and compiling and running the binary works but the REPL can't find the library.
07:34:29 <umpalumpa> http://hpaste.org/78646 hpaste give no warnings on this anymore but ghci says: line 93:1 parse error (possyibly incorrect indentation)
07:35:25 <Clint> umpalumpa: (Node
07:35:28 <mSSM> Is there a plugin you can recommend for Haskell syntax highlighting in ViM?
07:35:37 <mm_freak> rogerthealien: you can't really fix the indentation for haskell code
07:36:09 <Clint> mSSM: the default one?
07:36:15 <mm_freak> unless you use it in combination with djinn
07:36:57 <rwbarton> hpaste gives no warnings *because* it cannot parse your file
07:38:12 <hpc> mSSM: the one that comes with vim is fantastic
07:38:14 <statusfailed> mm_freak: sorry, lost connection again: point is- I think I picked a bad example, and I was going to suggest the exponential moving average instead (because it's not associative), but that even better demonstrates your "artifact of []" comment from earlier
07:38:32 <hpc> if it's not showing up, make sure vim has color and syntax enabled
07:38:34 <umpalumpa> Clint: with ( Node......... it tells me now parse error on input '=' on the line 92:38
07:39:58 <Clint> umpalumpa: mapTree f (Node x leftTree rightTree) = Node (f x) (mapTree f leftTree) (mapTree f rightTree)
07:40:38 <mSSM> Clint, hpc: It doesn't seem to highlight a lot of things for me.
07:40:49 <hpc> like?
07:41:09 <mSSM> hpc: I don't know; it's just not colorful. :)
07:41:10 <ijp> what's the "standard" way of determining whether you are on unix vs windows?
07:41:14 <hpc> for me, syntax is purple, yellow, and green
07:41:21 <hpc> identifiers are white
07:41:25 <mSSM> hpc: Can you make a shot of your vim with some random haskell on?
07:41:27 <hpc> infix operators are yellow
07:41:37 <mSSM> hpc: My stuff is mostly white. :(
07:42:14 <hpc> https://dl.dropbox.com/u/37707/Untitled.png
07:42:36 <umpalumpa> <Clint>: now it says Constructor 'node' is applied to 3 arguments but it has only two line 88:12
07:42:39 <hpc> the "$" at end of line is :set list
07:43:00 <ijp> using System.FilePath.pathSeparator?
07:43:00 <Clint> umpalumpa: and what do you think that means?
07:43:10 <pchiusano> > 1 + 1
07:43:11 <lambdabot>   2
07:43:22 <ciaranm> > let 1 + 1 = 3 in 1 + 1
07:43:24 <lambdabot>   3
07:43:33 <hpc> mSSM: my setup is debian testing in putty on win7
07:43:45 <pchiusano> > or (repeat False)
07:43:47 <hpc> default vim config with :set list, in screen
07:43:50 <lambdabot>   mueval: ExitFailure 1
07:43:50 <lambdabot>  mueval: Prelude.undefined
07:43:52 <umpalumpa> that I need one more argument ........but which ...
07:44:09 <hpc> er
07:44:17 <Clint> umpalumpa: which one's missing?
07:44:18 <hpc> here's my vimrc
07:44:19 <pchiusano> I just noticed the implementation of 'or' is not tail recursive
07:44:35 <hpc> http://hpaste.org/78649
07:44:48 <hpc> so in your vim window, type
07:44:48 <pchiusano> won't it use excessive stack space if the list contains a huge number of True at the start?
07:44:50 <pchiusano> http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/GHC-List.html#or
07:44:50 <hpc> :syntax on
07:44:57 <hpc> and it should just work
07:44:57 <mSSM> hpc: And the only options you have set are :set syntax on
07:45:02 <arbn> ijp: I hope not.
07:45:10 <mSSM> hpc: Well, maybe it's my colorscheme
07:45:16 <ijp> arbn: then can you suggest something less stupid? :)
07:45:51 <umpalumpa> (Clint)hmm,....I do not know :-/
07:46:00 <byorgey> pchiusano: no, because || is strict in its first argument
07:46:22 <byorgey> pchiusano: and even if it did, tail recursion would not help
07:46:23 <adek05> I am going to write a server. It will have to keep track of currently connected clients, some actions they did, essentially it will have state. What is the best way to store state in Haskell if I want to use threads within it?
07:46:23 <Clint> umpalumpa: then you would seem to have a problem
07:47:11 <arbn> ijp: System.Info.os
07:47:42 <pchiusano> byorgey: well, it will also evaluate its right argument if the left is False
07:47:44 <byorgey> pchiusano: what I mean by my first comment is that   or [True, True, ...] = True || or [True, ...]   and at that point you have to evaluate the  True ||  part *before* the recursive call is made
07:48:03 <byorgey> er, sorry, I got that mixed up
07:48:20 <ijp> arbn: is there any reasonably complete list of values that is likely to take on?
07:48:35 <byorgey> pchiusano: if a list has a bunch of Trues at the beginning, or will return True immediately after looking at the first element, without looking at the rest
07:48:38 <umpalumpa> (Clint) : so you do not know either? :-/
07:48:55 <byorgey> pchiusano: because if the first argument to (||) is True, it returns True without looking at the second argument
07:48:58 <pchiusano> byorgey: wait, did I say true, I mean or (repeat False)
07:49:04 <byorgey> > True || error "don't look at me"
07:49:05 <lambdabot>   True
07:49:19 <byorgey> pchiusano: ok, that's what I thought you meant, so what I said applies =)
07:49:30 <pchiusano> yeah, I understand that || is lazy and will terminate the traversal early if True is found
07:49:49 <byorgey> pchiusano: or [False, False, ...] = False || or [False, ...]   and at that point you have to evaluate the  False ||  part *before* the recursive call is made
07:49:54 <Squarism> maybe not the right place to ask.. but you guys know immutability. Need some FP advice here. I have this "tree-like" structure :https://github.com/gurgl/variabletree/blob/master/variabletree/src/main/scala/se/pearglans/ucr/graph.scala ... As you can see it has a "var value:Option[T]" in base type Node. I was wondering if theres some neat FP trick to make my tree immutable, but easily be able to produce
07:49:54 <Squarism>  a new tree with that value "decorated" onto the origingal mutable one?
07:49:56 <pchiusano> i am concerned about what happens when we have [False, False .. ]
07:50:01 <Clint> umpalumpa: i can only guess at what you're trying to write. you should know.
07:50:10 <byorgey> pchiusano: so you won't get a big build-up of unevaluated   False || False || False || ...
07:50:57 <byorgey> pchiusano: this has nothing to do with tail recursion and everything to do with laziness/strictness
07:51:15 <pchiusano> byorgey: won't we have to keep the left False around to actually implement ||
07:51:19 <arbn> ljp: http://hackage.haskell.org/trac/ghc/ticket/2614
07:51:40 <ijp> ah, thanks
07:51:41 <arbn> ljp: " osx, darwin, freebsd, openbsd, netbsd, linux, mingw32, win32, solaris" looks like a good place to start.
07:52:01 <pchiusano> as in, we still have to pass the False as the first argument to ||, even if || is going to ignore it
07:52:21 <ijp> arbn: that should be sufficient for now, cheers
07:52:26 <hpc> @src (||)
07:52:26 <lambdabot> True  || _ =  True
07:52:26 <lambdabot> False || x =  x
07:52:43 <hpc> pchiusano: a somewhat cop-out answer is that your first False isn't bound to a name
07:52:57 <hpc> so once it hits the right pattern, it can be garbage collected
07:53:18 <byorgey> pchiusano: I don't understand what you're asking
07:53:39 <ramses_> Squarism: I did not look at it in detail, but a zipper might be what you're looking for
07:53:59 <byorgey> pchiusano: the evaluation will look like this:  or [False,False,False] = False || or [False,False] = or [False,False] = False || or [False] = or [False] = False || or [] = or [] = False
07:54:37 <byorgey> pchiusano: note that we never get a big buildup of unevaluate stuff.  Each call to (||) is evaluated as soon as it is encountered.
07:54:58 <byorgey> because (||) pattern-matches on its *first* argument
07:55:05 <byorgey> @src (||)
07:55:05 <lambdabot> True  || _ =  True
07:55:05 <Squarism> ramses_, does those work well with trees?
07:55:05 <lambdabot> False || x =  x
07:55:21 <umpalumpa> (Clint): I try to advance a function BSTree with following functions: innenPath,mapTree,foldTree. than I try to redefine the size and depth functions with foldTree and than I want to add a balanced function to look if  the binärytree (t) is perfectly balanced
07:55:43 <Clint> umpalumpa: describe what you want innenPath to do
07:55:46 <pchiusano> byorgey: ahh, i think i got it
07:56:01 <ramses_> Squarism: they work very well with trees :)
07:56:27 <ramses_> Squarism: http://learnyouahaskell.com/zippers
07:57:07 <pchiusano> byorgey: I was thinking that || had to 'return' its value, but it doesn't - in this case, the right side is just a lazy computation representing the rest of the loop
07:58:20 <Squarism> i love lyah has these kidsbook drawings. Takes the dullness away
07:58:26 <pchiusano> byorgey: thanks
07:58:48 <byorgey> pchiusano: oh, I think I see what you mean.  Right, || does 'return' its value, but simply by returning its (possibly unevaluated) second argument in the case the first argument is false
08:00:01 <pchiusano> hpc: i do not understand your comment about the first False not being bound to a name
08:00:02 <umpalumpa> how do I send prv messages?
08:01:33 <rwbarton> most people I think would prefer to receive replies here
08:02:05 <byorgey> umpalumpa: /msg nick message.  But note it can be somewhat rude to message someone privately unless they invite you to.
08:02:31 <hpaste> Canar pasted “Need help optimizing this...” at http://hpaste.org/78650
08:02:40 <Squarism> from lyah "While Haskell's purity comes with a whole bunch of benefits, it makes us tackle some problems differently than we would in impure languages." ... "impure!" gotto love it
08:02:41 <umpalumpa> ok, thanks for the answers
08:04:37 <cnr> Anyone around that could give me a critique of why simple-looking code is running quite slowly?
08:05:22 <Mortchek> Canar, post the code and probably someone will comment
08:05:26 <Canar> http://hpaste.org/78650
08:05:41 <Mortchek> Woop, I thought I was in another channel, heh
08:05:42 <Canar> I know it's kind of ugly at the moment. I'm new and learning.
08:06:02 <rwbarton> how are you building it?
08:06:12 <rwbarton> foldl' instead of foldr should help some
08:06:28 <Canar> just ghc -O2
08:06:33 <latermuse> this look nice: http://ocharles.org.uk/blog/posts/2012-12-01-24-days-of-hackage.html
08:06:44 <rwbarton> okay, good
08:06:56 <rwbarton> btw you don't need to write "withFile fn WriteMode (\handle -> B.hPutStr handle (rp x))", there is "B.writeFile fn (rp x)"
08:07:03 <Canar> i've tried some of the profiling stuff
08:07:05 <Canar> ok, sweet
08:07:39 <Canar> my code is where all the slowdown happens, so i guess i'm doing it right in that regard
08:08:00 <rwbarton> how slow is "quite slowly", also
08:08:05 <Canar> well
08:08:53 <Canar> slower than i expected
08:09:02 <Canar> :P
08:09:16 <Canar> the code writes raw mono audio data
08:09:20 <rwbarton> > 44100 * 3 * 512
08:09:21 <lambdabot>   67737600
08:09:28 <ramses_> Canar: that code is really terrible to read, you might want to put in some newlines between functions and give better names then temp
08:09:30 <Canar> it's me experimenting with software synthesis
08:09:33 <umpalumpa> Clint : innenPath should give me the numbers of the nodes /// it should be a binäry search tree
08:09:41 <yepyep> Hi, I'm still having trouble with the State Monad.  I believe I have the basic idea down-- it executes a stateful computation wrapped in a State Monad and then retuns another State Monad based upon that result
08:09:44 <ramses_> s/then/than
08:09:57 <rwbarton> looks like it might take around 1 second? very roughly
08:10:10 <Canar> ramses_: duly noted. i am an admitted newbie to Haskell
08:10:20 <rwbarton> probably less than that
08:10:33 <ramses_> Canar: to haskell or to programming? because this style would look terrible in any language :)
08:10:41 * hackagebot cprng-aes 0.2.5 - Crypto Pseudo Random Number Generator using AES in counter mode.  http://hackage.haskell.org/package/cprng-aes-0.2.5 (VincentHanquez)
08:10:43 * hackagebot crypto-random-api 0.1.0 - Simple random generators API for cryptography related code  http://hackage.haskell.org/package/crypto-random-api-0.1.0 (VincentHanquez)
08:10:49 <Canar> ramses_: ...
08:11:06 <ramses_> Canar: not trying to be mean btw
08:11:09 <Canar> clearly
08:11:12 <hpaste> umpalumpa pasted “foldTree” at http://hpaste.org/78651
08:11:17 <yepyep> What I don't understand is how state is passed through one iteration of bind to another,   namely, how the variable \s is passed around in the part of State that goes roughly like:
08:11:36 <Canar> i'm not looking for critique of style here, ffs, i'm looking for obvious things i'm doing wrong that would make my code slower
08:11:47 <Canar> that's why it's a short snippet
08:11:48 <yepyep> (State h) >>= f = State $ \s -> ...
08:11:50 <rwbarton> did you switch foldr -> foldl'?
08:11:56 <Canar> not yet
08:12:12 <Canar> normally instead of 44100*3, it's 44100*520, which makes 1 second way longer.
08:12:18 <ramses_> Canar: I know, but I find it hard too parse the code because it's so dense
08:12:19 <umpalumpa> http://hpaste.org/78651 can someone tell me what is missing? I mean which 3th argument in line 88:12 ?
08:12:23 <ClaudiusMaximus> Canar: use foldl', use :: Double -> Double -> Double instead of polymorphic type
08:12:28 <Amoeba1> Is there a good follow along basic Haskell video lecture series?
08:12:41 <yitz> Canar: looks to me that rwbarton' issue is the main bottleneck there at the moment, foldr => foldl'
08:12:52 <Mortchek> umpalumpa, you're missing the first argument
08:12:53 <Canar> all right
08:13:09 <yepyep> i understand that runstate passes the initial state, but I don't understand how the intermediate states get passed around in the monad, namely how \s is getting changed from one iteration to the next of bind
08:13:37 <yepyep> s/runstate/runState
08:13:59 <ramses_> umpalumpa: (Node Nil Nil) should be (Node _ Nil Nil)
08:14:06 <Mortchek> umpalumpa, namely, you've got the subtrees, but you don't have the current node's value
08:14:09 <yitz> yepyep: what do you mean by "iteration"?
08:14:33 <yepyep> >>= iter >>= iter2 >>= iter3
08:14:40 <ramses_> umpalumpa: and I have a feeling you might want to do something with the value, don't you?
08:14:41 <yitz> ah ok
08:14:44 <mSSM> hpc: Well, I just switched over to solarized, and now I get nice syntax highlighting for Haskell as well. ;)
08:15:02 <Mortchek> Value is irrelevant for calculating inner path; it just has to do with the tree's structure
08:15:23 <ramses_> ah ok I see, hadn't looked at the semantics yet
08:15:34 <yitz> yepyep: >>= is just an ordinary function that takes two arguments. since its name is symbol characters, this function is called an "operator" and is written in infix style.
08:15:40 <yepyep> I see that the initial state get passed in when calling runState on the Monad with some initial state
08:15:43 <yitz> @type (>>=)
08:15:44 <lambdabot> Monad m => m a -> (a -> m b) -> m b
08:15:46 * hackagebot zmidi-core 0.6.0 - Read and write MIDI files.  http://hackage.haskell.org/package/zmidi-core-0.6.0 (StephenTetley)
08:15:48 * hackagebot cprng-aes 0.3.0 - Crypto Pseudo Random Number Generator using AES in counter mode.  http://hackage.haskell.org/package/cprng-aes-0.3.0 (VincentHanquez)
08:16:19 <umpalumpa> yes but I do not get it what is missing :-/
08:17:00 <Mortchek> umpalumpa, you have a parameter at the front whose value you don't need, but it's still one of the parameters - so just stick a _ at the front
08:17:07 <yepyep> I understand that.  but it looks to me like iter1 >>= iter2 returns State s a, which, IIRC is simply a wrapped form of the function (s -> (s,a))
08:17:19 <yitz> yepyep: right
08:17:34 <Mortchek> umpalumpa, Node _ Nil Nil, or Node _ leftTree rightTree
08:18:02 <yitz> yepyep: and that happens to be exactly the type you want for the first argument of another application of >>=
08:18:50 <yepyep> yitz: sorry, i've been cracking my brain on this for a while.  i just need help with the first part here:
08:19:06 <rwbarton> odd, foldl' made it slower somehow
08:19:23 <yepyep> (State h) >>= f= State $\s -> ...
08:19:24 <Mortchek> umpalumpa, by the way, you don't need the Node _ Nil Nil case; that's covered by the other two cases together
08:19:54 <yepyep> State h is an entire stateful computation wrapped in a state, correct?
08:19:58 <Mortchek> Or wait, maybe you do for this one…
08:20:00 <Canar> Weird.
08:20:07 <yepyep> or is it partially applied?
08:20:07 <Canar> foldl' doubles execution time for me.
08:20:09 <umpalumpa> hmm now ghci is telling me that one argument is missing in the line bellow 89:12
08:20:42 * hackagebot shake 0.3.7 - Build system library, like Make, but more accurate dependencies.  http://hackage.haskell.org/package/shake-0.3.7 (NeilMitchell)
08:20:44 <ramses_> umpalumpa: same issue there
08:21:05 <umpalumpa> so Node _leftTree
08:21:08 <yitz> yepyep: it represents a calculation that can be done for any given value of the state.
08:21:23 <ramses_> umpalumpa: (Node _ leftTree rightTree)
08:21:26 <umpalumpa> innenPath (Node_leftTree rightTree)
08:22:09 <umpalumpa> ok now he tells me not in scope 'leftTree' 89:54 ^^
08:22:17 <yepyep> yitz:  ohhhhhhhhhh, so once the 's' in \s is bound, it doesn't actually get changed?
08:22:26 <ramses_> umpalumpa: spaces around the field
08:22:30 <Mortchek> umpalumpa, don't mash your identifiers together; you need spaces
08:22:47 <yitz> yepyep: right!
08:23:17 <umpalumpa> ahh now it works
08:23:23 <umpalumpa> thank you so much :-)
08:23:45 <yitz> yepyep: the right hand argument says how to construct a new such calculation, given the result after having done the previous one.
08:24:21 <Canar> rwbarton, ClaudiusMaximus: replacing foldr with foldl' or foldl results in double the execution time, according to the time command
08:25:36 <yepyep> hmmm
08:26:15 <yepyep> so the stateful calculation h takes the intial state and returns a tuple with the result and the new state
08:26:39 <yepyep> i going mainly by material in LYAH, for reference
08:27:24 <rwbarton> for me it was much less than double, but still a significant increase in run time
08:27:33 <rwbarton> I don't understand why that would happen
08:28:37 <yepyep> then the result is passed to a function f of type  (a -> s -> State s a)
08:29:00 <yepyep> then the stateful computation is passed to the new state and finally wrapped in a State
08:29:24 <yepyep> where it is passed to the next bind
08:29:30 <yepyep> have i understood that correctly?
08:30:33 <yitz> yepyep: yes i think so. you meant a -> State s a though. Also, the result type can change an each step, so it can be a -> State s b.
08:30:37 <yitz> *at
08:31:02 <yepyep> within the second argument of bind
08:31:04 <yitz> yepyep: (the s parameter is implied, inside the State constructor)
08:31:11 <yitz> yes
08:32:41 <yepyep> yitz: tell me more about the s being implied.  this is where i'm stumbling
08:32:56 <SirStean> hey anyone knows a good c/c++ irc?
08:33:54 <otters> ##c
08:33:56 <otters> maybe
08:34:10 <yitz> yepyep: well State s a is just another way of saying s -> (s,a). the symbol "State" is defined as a newtype, which you can think of as being a kind of alias
08:35:27 <yepyep> yitz: i understand newtypes, but isn't the State constructor wrapping a function that takes a state?
08:35:39 <yepyep> hence where does the state come from
08:36:19 <yitz> yepyep: a stateful calculation doesn't have a state in it. it has a way of computing something from a state later on, when you have one.
08:36:26 <yepyep> I know it gets bound from runState
08:36:57 <yepyep> runState takes the State Monad/newtype and an initial state
08:37:15 <yepyep> how do the intermediate states get passed around?
08:37:55 <yepyep> so iter1 >>= iter2 takes initialState
08:38:06 <flebron> This is off topic, but I figure this crowd will appreciate it: "And some people prefer not to commingle the functional, lambda-calculus part of a language with the parts that do side effects. It seems they believe in the separation of Church and state." -- Guy Steele
08:38:51 <yitz> yepyep: they don't need to be passed anywhere. >>= just combines two State s a to get a new State s a. Any State s a can take an s and give you an (s, a).
08:40:06 <yitz> @quote steele
08:40:06 <lambdabot> JamesIry says: 1970 - Guy Steele and Gerald Sussman create Scheme. Their work leads to a series of "Lambda the Ultimate" papers culminating in "Lambda the Ultimate Kitchen Utensil."
08:40:13 <yitz> @quote steele
08:40:13 <lambdabot> JamesIry says: 1970 - Guy Steele and Gerald Sussman create Scheme. Their work leads to a series of "Lambda the Ultimate" papers culminating in "Lambda the Ultimate Kitchen Utensil."
08:40:34 <yepyep> is it the same state \s? that is taken.  I guess more of my
08:40:40 <yitz> @remember GuySteele Some people prefer not to commingle the functional, lambda-calculus part of a language with the parts that do side effects. It seems they believe in the separation of Church and state.
08:40:40 <lambdabot> Nice!
08:40:42 <yepyep> sorry mistype
08:40:48 <robbe-> I used cabal install stylish-haskell, and it installed fine, but when I try to run it, I get:
08:40:56 <robbe-> Language.Haskell.Stylish.Parse.parseModule: could not parse <unknown>: ParseFailed (SrcLoc {srcFilename = "<unknown>.hs", srcLine = 2, srcColumn = 1}) "TemplateHaskell is not enabled"
08:41:12 <djahandarie> yitz, hah, awesome quote.
08:41:30 <nicoo> yepyep: Ahah :)
08:41:32 <yitz> djahandarie: yes flebron just quoted it ^^
08:41:55 <djahandarie> Oh, heh. Nice quote flebron :P
08:42:25 <robbe-> Any pointers on where I can look to solve this issue? I'm rather new to haskell, and I don't know whether I should enable TemplateHaskell, nor how I should do that. :-)
08:42:55 <yitz> yepyep: yes it will be the same s.
08:43:34 <yepyep> yitz: so the stateful computatons are "aware" of previous changes in state?
08:43:46 <yitz> yepyep: here's a simple example: modify (+ 2) >>= modify (+ 3) == modify (+ 5)
08:44:20 <yitz> yepyep: they're not really aware of anything. you are just composing two functions. the result of one goes into the input of the next.
08:44:37 <yitz> @type modify
08:44:38 <lambdabot> MonadState s m => (s -> s) -> m ()
08:45:23 <yepyep> yitz: oh, ok.  someone told me yesterday that the State monad was not like function composition
08:45:40 <yepyep> that makes perfect sense then.  Thanks so much!
08:45:57 <yepyep> This channel is great.  It's probably the most helpful IRC channel I've ever been to.
08:48:57 <rtharper> Is there a good lib with date types for operating on calendar days?
08:49:01 <rtharper> but not time
08:49:11 <rtharper> I want to use it for representing parsed dates
08:51:34 <yitz> rtharper: if not time, then no, by definition it won't be a good lib. because time is the good one.
08:51:44 <rtharper> yitz: it is just..too much information for this
08:51:48 <rtharper> but I guess I'll just roll my own, then
08:52:21 <yitz> rtharper: i don't know what you mean by "parsed date". but why do thing that the type Day, for example, has too much information?
08:52:33 <rtharper> yitz: I dunno about the type Day =p
08:52:36 <rtharper> That is what I am asking for ;)
08:52:51 <rtharper> I mean there are dates in a file that I want to parse, they are just in yyyy-mm-dd format
08:53:20 <rtharper> a quick look and it seemed most libs were geared toward recording hour/second or finer info too
08:54:30 <rtharper> but I see the Day type is good enough
08:54:39 <rtharper> since I don't need data pre 1858
08:55:35 <yitz> rtharper: no Day has an instance of FormatTime. So you can take a string in that form and get a Day. then you have toGregorian :: Day -> (Integer, Int, Int)
08:55:43 <rtharper> thanks =
08:55:44 <rtharper> =)
08:56:19 <rwbarton> Canar: I translated your program to C and it ran only about 20% faster than your original code
08:56:29 <rwbarton> so I think your expectations are just off
08:56:39 <yitz> rtharper: actually the day number is allowed to be negative too
08:56:48 <rtharper> aha
08:56:49 <rwbarton> (and mine, apparently, since I underestimated the runtime by a factor of 10 or more)
08:57:43 <Canar> rwbarton: interesting
08:58:07 <Canar> any chance i could see your c?
08:58:13 <rwbarton> sure
08:58:38 <hpaste> rwbarton annotated “Need help optimizing this...” with “Need help optimizing this... (annotation)” at http://hpaste.org/78650#a78653
09:00:07 <yitz> rtharper: sorry you are interested in the ParseTime instance. the FormatTime instance is for *creating* a string like that from a Day.
09:00:13 <rwbarton> actually I was comparing the wrong version, your original code is almost identical in performance to that C
09:00:26 <yitz> anyway
09:00:54 <Canar> rwbarton: looks like an instance of... *shades* sinus pain
09:01:11 * Canar hides
09:01:25 <rwbarton> using macros for min/max makes the C a few percent faster (really, gcc?)
09:02:16 <yitz> rwbarton: "original code" means with the foldr?
09:02:52 <rwbarton> yeah
09:03:06 <rwbarton> still baffled about how that can be faster than foldl'
09:03:36 <rwbarton> Canar: btw aren't all but two of the numbers in temp_s t equal to zero
09:03:47 <rwbarton> oh maybe not
09:03:53 <yitz> rwbarton: i mean, true, it's only adding up 512 numbers at a time, so stacking them up is probably masked by the cache. but it shouldn't be faster than just adding them.
09:05:03 <rwbarton> an explicit loop is a few percent faster
09:12:29 <Canar> rwbarton: in the "main" use case for that, the *3 changes to *520
09:12:37 <Canar> it's a software synthesis experiment
09:12:59 <Canar> adding one harmonic a second until the full bandwidth is covered
09:13:23 <Canar> that said, thank you for your analysis, and the C test you ran
09:13:38 <rwbarton> there is a formula for summing sin at values of an arithmetic sequence btw
09:14:21 <rwbarton> so that could eliminate your factor of 512 from the loop
09:15:10 <Canar> http://math.stackexchange.com/questions/117114/sum-cos-when-angles-are-in-arithmetic-progression
09:15:12 <Canar> aha
09:15:18 <Canar> that's a biggie.
09:17:40 <Canar> doesn't work in this context htough because i'm summing sins with custom coefficients for each term
09:18:59 <rwbarton> but aren't all but one of them either 0 or 1
09:19:04 <Canar> nope
09:19:10 <Canar> actually
09:19:11 <Canar> yes
09:19:36 <rwbarton> so you can add up the 1s, not add up the 0s and then throw in the other guy
09:19:44 <Canar> in this instance, yes.
09:19:50 <rwbarton> right
09:19:57 <Canar> future revisions will depend on variable co-efficients for each term
09:26:58 <hpaste> jmcarthur annotated “Need help optimizing this...” with “Need help optimizing this... (annotation)” at http://hpaste.org/78650#a78654
09:27:07 <jmcarthur> Canar: ^^ 33% faster than the original
09:27:49 <jmcarthur> Canar: also, this looks trivially parallelizable. maybe look into repa?
09:29:50 <jmcarthur> i gained another small speed boost by only exporting main
09:30:48 <jmcarthur> -fllvm is also faster than without
09:31:07 <Peaker> not having import/export hygiene is terrible :)
09:31:13 <Canar> jmcarthur: awesome, i was just looking into Vector.
09:31:35 <Canar> And yes, highly parallelizable.
09:31:54 <DMcGill> can somebody explain netwire's "context" to me please? I've had a look at the source but don't really understand it
09:43:03 <rodlogic> Getting more and more comfortable with monads, I am quite intrigued by the Free monad. However, I think I am not getting the right intuition about it. Why is it useful and when would you use it?
09:43:06 <deech> Hi all, I trying to working with the LibClang bindings and getting a "Segmentation Fault (core dumped)" error on the test data that comes with the library. What's the best way of debugging a binding? Running with +RTS didn't give me anything.
09:44:16 <mSSM> What confuses me about the State monad is that what it actually does is "take a state and produce a result from it". If you want to go to another state, you have to implement that, or define a stateful computation that has the result (newState,oldState)
09:46:22 <triageman> rodlogic: are you familiar with fixed points of functors?
09:46:24 <hpc> mSSM: eh?
09:46:37 <hpc> @untml State s a
09:46:37 <lambdabot> Maybe you meant: unmtl unpl
09:46:46 <hpc> @unmtl State s a
09:46:46 <lambdabot> s -> (a, s)
09:47:00 <hpc> (State s a) is a function from s to (a, s)
09:47:32 <hpc> so i think your misunderstanding is that "take a state and produce a result from it" should actually be "take a state and produce a pair of result and new state"
09:48:03 <mSSM> hm
09:48:28 <hpc> what you are thinking of would actually be the Reader monad
09:48:36 <hpc> which is "take an environment and produce a result from it"
09:48:49 <hpc> and you can emulate State very poorly with it using
09:48:50 <hpc> :t local
09:48:51 <lambdabot> MonadReader r m => (r -> r) -> m a -> m a
09:51:14 <rodlogic> triageman: I have seen the word thrown around but still an inch above my head
09:51:21 <mSSM> hpc: alright; thanks
09:58:35 <triageman> rodlogic: when taking a fixed point of a (Functor f), you recursively fill in all occurences of first parameter of f with instances of the datatype itself
09:58:45 <triageman> rodlogic: newtype Fix f = In { out :: f (Fix f) }
09:59:16 <triageman> if you look at the datatype used in a free monad, you'll see that it shares one of its constructors with this Fix datatype
09:59:19 <robbe-> Hmm, say one has a [Maybe a], and wants to remove all elements == Nothing (okay), and then convert the resulting list to [a]. I don't see how this can be done using maybe. What am I missing?
09:59:35 <triageman> rodlogic: the other constructor is named Pure a
09:59:41 <elliott> you can't do it with map + maybe but you can do it with a fold + maybe
09:59:45 <elliott> (btw, that function already exists: catMaybes)
10:00:06 <robbe-> Thanks elliott!
10:00:07 <Peaker> @src catMaybes
10:00:07 <lambdabot> catMaybes ls = [x | Just x <- ls]
10:00:12 <elliott> > foldr (\m xs -> maybe xs (\x -> x:xs) m) [] [Just 1, Just 2, Nothing, Just 3]
10:00:14 <lambdabot>   [1,2,3]
10:00:30 <elliott> or shorter:
10:00:39 <triageman> rodlogic: so taking a free monad of a Functor f basically gives you the fixed point of that functor together with the option of plugging a recursive instantiation with a Pure a value
10:00:39 <elliott> > foldr (maybe id (:)) [] [Just 1, Just 2, Nothing, Just 3]
10:00:41 <lambdabot>   [1,2,3]
10:00:52 <elliott> see if you can work that one out :)
10:01:04 <triageman> rodlogic: so, now the problem is reduced to understanding fixed points of Functors :)
10:02:08 <robbe-> elliott: I think the id will pass on the accumulator, because that's what maybe does when it's applied to Nothing.
10:02:40 <cmccann> of course, a fixed point of a functor just means applying the functor to its fixed point. so that helpfully reduces the problem to understanding fixed points of functors.
10:02:43 <mSSM> I feel like I am abusing the IO monad ... should I really be returning the final result in the following code? http://hpaste.org/78657
10:02:56 <robbe-> elliott: Otherwise, cons the element
10:03:18 <elliott> yeah, you can expand it like: (maybe id (:)) -> (\mx -> maybe id (:) mx) -> (\mx -> maybe (\xs -> xs) (\x xs -> x:xs) mx) -> (\mx xs -> maybe xs (\x -> x:xs) mx)
10:03:31 <elliott> -> (\mx xs -> case mx of Nothing -> xs; Just x -> x:xs)
10:03:46 <mm_freak> edwardk: again nevermind, i solved it myself…  i was using Scope b ExprF a instead of Scope b Expr a =)
10:04:02 <mm_freak> although it seems like it's going to be easier writing the monad myself
10:04:11 <dmwit> mSSM: I don't see anything egregiously bad in that code.
10:04:12 <Peaker> mm_freak, what project are you working on?
10:04:14 <triageman> rodlogic: take data ExpF r = Val Int | Add r r, if we take (Fix ExpF), then all occurences of r will be filled in with other expressions, and those expressions will also have filled in their r-positions with expressions etc
10:04:22 <dmwit> modulo typos =)
10:04:37 <robbe-> elliott: I see :-) Thanks for your time, and elaboration.
10:04:37 <mm_freak> Peaker: i'm evaluating the 'bound' library for use in a small language i'm going to develop
10:04:38 <mSSM> mm_freak: I feel like I am only wrapping stuff into that IO monad, to then unwrap ita gain.
10:04:41 <mSSM> sorry
10:04:43 <mSSM> wrong person
10:04:45 <mSSM> dmwit: * ^^
10:05:08 <triageman> so type Exp' = Fix ExpF is isomorphic to the datatype data Exp = Val Int | Add Exp Exp
10:05:12 * cmccann wonders whether equivalence classes of programs modulo typos are computable
10:05:43 <dmwit> :t liftM2
10:05:44 <lambdabot> Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
10:06:07 <elliott> robbe-: yw :)
10:06:09 <dmwit> mSSM: The pattern in that code is so common and unmalicious it even has a name in the standard libraries. =)
10:06:15 <dmwit> :t liftM2 (,)
10:06:16 <lambdabot> Monad m => m a1 -> m a2 -> m (a1, a2)
10:06:25 <rodlogic> triageman: with data Exp = Val Int | Add Exp Exp I can construct a composite expression. Why would I add Fix here?
10:06:36 <dmwit> :t join (liftM2 (,))
10:06:37 <lambdabot> Monad m => m a1 -> m (a1, a1)
10:06:51 <rodlogic> triageman: or iow, what does Fix buy me
10:07:35 <dmwit> rodlogic: Haven't been following the conversation, but generally you want to use Fix when you need some code that works generically for any recursive type.
10:07:56 <dmwit> rodlogic: e.g. there are some unification packages on Hackage, and they require you to use Fix (or similar)
10:07:56 <mSSM> dmwit: The part I am uncomfortable about is why I should be wrapping the thing in IO; the line that uses that function is then just calling it with `pos <- randomPos gen n', and the IO part is never to be seen again.
10:08:13 <mSSM> But I don't know any better...
10:08:26 <rodlogic> dmwit: so would the argument be that I can decouple the recursive logic from the expression itself and possibly reuse them across any number of expressions that are totally different from each other?
10:08:30 <dmwit> If you can do it without doing IO, you should. If you can't, don't.
10:08:35 <Peaker> mm_freak, ah, cool.. all the variable binding business is something I'm meddling with a lot too
10:08:39 <rogerthealien> i'm trying to do some exception handling, but i can't seem to figure it out... can anyone please take a look at http://hpaste.org/78658 and point me in the right direction
10:08:41 <dmwit> rodlogic: That's the idea, yeah.
10:08:58 <Peaker> mm_freak, (doing type checking, some inference, and a structural editor for a SystemF)
10:09:05 <rodlogic> dmwit: is there any downside (mostly worried about runtime penalties)
10:09:56 <hpaste> umpalumpa pasted “foldTree” at http://hpaste.org/78659
10:10:14 <dmwit> rodlogic: The downside is that it requires more (keyboard) typing. =)
10:10:47 <dmwit> rodlogic: There are other downsides, too; for example, if your type is parameterized, you have to either create a new kind of Fix or give up on higher-kinded classes like Monad, Foldable, etc.
10:11:18 <rodlogic> dmwit: if you were to design a new expression/embedded language in haskell, then it seems that there is no reason NOT to use it.
10:11:59 <triageman> rodlogic: for a functor f, you can define a function f a -> a which specifies how to unrap each layer of recursion, and then you can use a function fold :: Functor f => (f a -> a) -> Fix f -> a to fold over it
10:12:29 <umpalumpa> http://hpaste.org/78659  if I try to test foldTree with::: foldTree 1 + (Node 1 (Node 2 Nil Nil) (Node 3 Nil Nil)) ::::: ghci tells me that it can not match
10:12:45 <triageman> rodlogic: so expressing some datatype as the fixed point of some functor allows you to define these kinds of folds over it
10:13:12 <dmwit> rogerthealien: Have you tried getting the bits in the first argument correct first? Your problems have nothing to do with catching exceptions. =)
10:13:20 <rodlogic> dmwit: ok, does that mean Fix works only with a type with kind * -> *?
10:13:26 <dmwit> :k Fix
10:13:28 <lambdabot> Not in scope: type constructor or class `Fix'
10:13:30 <dmwit> :k Mu
10:13:30 <triageman> rodlogic: fold f = f . fmap (fold f) . out
10:13:31 <lambdabot> (* -> *) -> *
10:13:37 <dmwit> rodlogic: =)
10:13:50 <dmwit> rodlogic: However, be careful with what you mean here.
10:13:59 <dmwit> rodlogic: You can still define parameterized fixpoints; e.g.
10:14:04 <mm_freak> Peaker: yeah, that's exactly where the library helps (a lot!)
10:14:13 <rodlogic> triageman: ok, so the same idea of fix
10:14:25 <dmwit> data ListF a b = NilF | ConsF a b; type List a = Fix (ListF a)
10:14:58 <mm_freak> Peaker: i just wanted to save even more typing by using a free monad, but apparently that becomes even more typing quickly
10:15:48 <triageman> rodlogic: anyway, a free monad is just this, only the r-positions in ExpF can also be filled with Pure a values, instead of only other values of ExpF
10:16:18 <rodlogic> dmwit: I see, in the same way that Either a b is a monad?
10:16:19 <triageman> so Fix ExpF ~ Exp, and Free ExpF ~ Exp + plugged expressions
10:17:03 <rodlogic> triageman, dmwit: would it be correct to say that it is like a list/recursion at the type level?
10:17:09 <mm_freak> i'll go with a manually defined monad instead of a free monad for now
10:17:34 <dmwit> rodlogic: I don't understand the question "in the same way that Either a b is a monad?".
10:17:48 <dmwit> rodlogic: It is correct to say that Fix is like recursion at the type level.
10:18:00 <umpalumpa> http://hpaste.org/78659 with the test foldTree 1 + (Node 1 (Node 2 Nil Nil) (Node 3 Nil Nil)).....this are tu much arguments aren't they?
10:18:28 <dmwit> umpalumpa: Perhaps you wanted "(+)" instead of "+".
10:18:30 <triageman> rodlogic: wouldn't say that, but to give another example, define `data ListF a f = Nil | Cons a f`, now define `type List a = Fix (ListF a)`
10:18:52 <triageman> rodlogic: or maybe I would say that ;P
10:20:03 <triageman> rodlogic: The List a)
10:20:08 <edwardk> mm_freak: bound isn't quite. you have to write the recursion by hand using (>>>=) for the place with the binder in it
10:21:21 <umpalumpa> with (+) it says occurs check: cannot construct the infinite type: t10 = t10 ->t10............expected type: t10->t10->t10->t10.....actual type: t10->t10->t10
10:21:27 <Peaker> mm_freak, Some day I'll have to take a look at that :)
10:21:30 <triageman> rodlogic: nm that, I must be going now, I hope this was helpful :)
10:21:44 <Peaker> mm_freak, we already have quite a lot of code regarding our exprs so I'm not sure it'll fit in
10:21:59 <Peaker> https://github.com/Peaker/lamdu/blob/master/codeedit/Editor/Data.hs <-- our expression format
10:22:01 <rodlogic> dmwit: "instance [safe] Monad (Either e)", here Either l r is parameterized by l and r but an instance of Monad which is * -> *
10:22:24 <dmwit> Yes, but Either l r isn't a monad. Either l is.
10:22:32 <dmwit> Either l has kind * -> *
10:22:40 <dmwit> (when l has kind *)
10:22:49 <edwardk> mm_freak: i mean bound monads aren't quite free
10:23:54 <rodlogic> dmwit: I can grasp that but not yet comfortable/intuitive. There is just a whole new abstraction level in haskell that is simply not present in something like Java
10:24:03 <dmwit> Who came up with the name "bound monads"? That seems like an awful pun. =P
10:24:14 <rodlogic> dmwit: or not present without some crazy "typing"
10:24:21 <dmwit> rodlogic: Right, it takes a bit of acclimation.
10:24:28 <mm_freak> edwardk: hehe that sounds about right =)
10:24:38 <umpalumpa> http://hpaste.org/78659 how can I test this foldTree here?
10:24:50 <hpaste> Clint pasted “ResourceT confusion” at http://hpaste.org/78661
10:24:52 <mm_freak> Peaker: you can use it for new ASTs
10:25:01 <Clint> can someone help me destupidify that? ^
10:25:25 <mm_freak> Peaker: however, if you're already using monadic ASTs, bound might function as a drop-in replacement perhaps with some modifications
10:25:28 <rodlogic> triageman: yes, that makes sense now (data ListF a f ...)
10:25:38 <Peaker> mm_freak, what are "monadic ASTs"? My AST is just data
10:26:04 <mm_freak> Peaker: there was a paper, but i don't quite remember what it was called
10:26:07 <dmwit> umpalumpa: e.g. foldTree 3 (\rec l r -> rec + l + r) (Node 40 Nil Nil)
10:26:26 <Peaker> mm_freak, oh, like Free monad ASTs representing the stuff-to-be-done?
10:26:39 <rodlogic> dmwit, triageman: thanks for the insights/explanations.
10:26:42 <mm_freak> Peaker: i think richard bird is one of the authors, because it uses generic recursion/folding quite a lot…  the Monad instance allows you to do substitution easily
10:26:58 <mm_freak> search for "bird locally nameless"
10:27:05 <mm_freak> or "bird de bruijn"
10:27:12 <mm_freak> something like that
10:27:59 <Peaker> mm_freak, but substitution assumes I want to interpret it?  I do have redex-reduction in my "inference"
10:28:40 <umpalumpa> @dmwit: it says now exeption non exhaustiive pattern in Lambda
10:28:40 <lambdabot> Unknown command, try @list
10:29:01 <mSSM> Can my function names contain question marks?
10:29:28 <elliott> no
10:29:38 <morel> can unsafePerformIO cause serious problems? i just need it to test something, i don't wanna use it for a the actual code. (i don't wanna debug either, i'd use Debug.Trace if i would want to debug.)
10:29:47 <Clint> they can contain interrobangs
10:30:15 <elliott> morel: depends what you meab yserious problems
10:30:18 <elliott> you can derive unsafeCoerce from it
10:30:35 <Peaker> mm_freak, we don't want to execute yet
10:30:49 <morel> elliott: hm okay...
10:31:15 <umpalumpa> @dmwit: the test you told me doesn't work :-/
10:31:15 <lambdabot> Unknown command, try @list
10:38:53 <rtharper> > "\&"
10:38:55 <lambdabot>   ""
10:39:02 <rtharper> what is that character?
10:39:06 <elliott> it is no character at all
10:39:12 <elliott> \& is used so you can do both of these:
10:39:15 <elliott> > "\240"
10:39:17 <lambdabot>   "\240"
10:39:18 <elliott> > "\24\&0"
10:39:20 <lambdabot>   "\CAN0"
10:39:30 <elliott> the former is [chr 240]
10:39:33 <elliott> the latter is [chr 24, '0']
10:39:43 <elliott> it "terminates" an \ escape, basically, by being a 0-length string
10:40:07 <elliott> (as far as I know nobody actually uses this)
10:40:07 <rtharper> jaha
10:40:15 <rtharper> it appears in print
10:40:24 <rtharper> \160\&2012-11-22\
10:40:26 <elliott> right, print will be putting it there to disambiguate things
10:40:35 <rtharper> thank you =)
10:40:36 <elliott> > "\1602012-11-22"
10:40:38 <lambdabot>   <hint>:1:9: numeric escape sequence out of range at character '2'
10:40:40 <umpalumpa> http://hpaste.org/78659 can someone please tell how to test the function foldTree
10:40:41 <rtharper> aye that makes sense
10:40:43 <umpalumpa> ?
10:41:02 <mm_freak> Peaker: type checking uses substitution in any sensible type language
10:41:26 <mSSM> In the stackyStack code on http://learnyouahaskell.com/for-a-few-monads-more#state , when he calls `stackNow <- get', shouldn't stackNow result in a tuple (Stack, Stack) ? The result of `get' has to be a tuple, right?
10:41:39 <mm_freak> Peaker: if it's system F i assume you have a separate type for type-level expressions, in which you have a "forall", which is basically type-level lambda
10:41:41 <Peaker> mm_freak, for type synonyms?
10:42:03 <Peaker> mm_freak, it's not a type-level lambda, it's a value-level lambda that takes a type as an argument
10:42:14 <the37yrOldVirgin> So the Palindrome thing I just pasted. Can someone tell me if the zipped list is fully evaluated when I start taking from it, or not? Wrapping my head around lazy evaluation. http://hpaste.org/78641
10:42:15 <umpalumpa> no one?
10:42:19 <Peaker> (at the type-level, it's a type-dependent Pi rather than an ordinary arrow)
10:42:36 <the37yrOldVirgin> I know I asked this earlier, I got dragged away from my comp
10:42:44 <mm_freak> Peaker: i actually meant the type-level one
10:43:02 <mm_freak> but yeah, you're right, you can get along without it
10:43:06 <Peaker> mm_freak, e.g:   id :: (a :: *) -> a -> a ; id = \(a :: *) (x :: a) -> x
10:43:16 <mm_freak> at least as long as you don't have higher-rank types
10:43:31 <Peaker> mm_freak, we want a Haskell-like type-system for now (which means only fully applied type synonyms get substituted, for now)
10:43:36 <mSSM> Or put differently, isn't the LYAH example wrong? How can he compare a tuple ([Int],[Int]) == [Int] ??
10:43:38 <Peaker> mm_freak, we do have higher-rank types
10:43:46 <Peaker> mm_freak, but no beta reductions on type-level
10:44:00 <mm_freak> how do you compare types?
10:44:01 <DMcGill> umpalumpa: what do you mean "test"? If you just want to make sure that it works, make a tree yourself and try it! If you want to use quickcheck on it, then you need to make BSTree an instance of Arbitrary
10:44:13 <Peaker> mm_freak, alpha equality
10:44:50 <mm_freak> i see…  i think i haven't done alpha-equality for a long time
10:45:10 <Peaker> mm_freak, we do actually have substitutions for type checking though, which I forgot about when I said we don't need execution yet :)
10:45:28 <Peaker> when you have:   (id Int) in code, then the resulting type is (Int -> Int)
10:45:55 <mm_freak> Peaker: my core language would be dependently typed anyway, so you could put any lambda-cube type system you like on top of that
10:46:12 <mm_freak> but i haven't done totality checking yet
10:47:05 <Peaker> mm_freak, ah, dependent types complicate inference for us a.t.m
10:47:22 <Eelis> the tensor package and the random package currently do not depend on eachother. what would be the ideal place for Random instances for the tensor package's Vector types? a new package with orphan instances in it?
10:47:22 <mm_freak> Peaker: you don't do type inference in the core language
10:47:24 <Peaker> we are doing some very ambitious things so we decided we ought not to be too ambitious w.r.t the type system
10:47:56 <mm_freak> it's really just the final high level representation before it gets to the bones
10:48:31 <Peaker> mm_freak, our "core language" is the one where we do all the inference, execution, etc.  And there's a "sugared" language. But we unconventionally go from the core lang to the sugared with automatic sugaring, rather than have a de-sugaring
10:48:55 <Peaker> so you get a GUI that edits the sugared representation, but in fact it translates the edits to be edits of the unsugared "core" language
10:49:57 <mm_freak> hmm, ok
10:52:26 <mSSM> Nope, LYAH is right. Ignore my question please.
10:52:34 <xplat> the lambdamoo server uses invertible bytecode compilation, which is kind of similar to invertible sugaring ...
10:53:27 <Peaker> xplat, we really want to avoid having multiple syntactic forms for the same structure
10:53:47 <Peaker> xplat, so toying with whitespace, sugaring, etc are not going to be exposed in the gui
10:54:38 <xplat> oh, right, you're using inverted sugar more than invertible sugar
10:55:35 <xplat> maybe you should call that module C6H12O6
10:55:38 <Peaker> yeah, sugar and concrete syntax are just presentation things
10:55:48 <Peaker> xplat, what module?
10:56:07 <Peaker> oh :)
10:56:10 <xplat> the one that applies inverted sugar to your core rep
10:56:26 <Peaker> my chemistry is weak :)
10:56:41 <rwbarton> Glucose.L
10:57:17 <xplat> http://en.wikipedia.org/wiki/Inverted_sugar_syrup
10:57:36 <hpaste> apfel__ pasted “listOfPowers” at http://hpaste.org/78663
10:58:30 <rogerthealien> hi, i'm trying to do some exception handling but i can't seem to figure it out. In http://hpaste.org/78662, my r is never Nothing, is there something wrong with the catch statement?
10:59:02 <rwbarton> "return (f x y)" can never raise an exception
10:59:20 <hpaste> apfel__ annotated “listOfPowers” with “listOfPowers (annotation)” at http://hpaste.org/78663#a78664
10:59:27 <apfel_> can someone take a look at my programm, i don't know whats going on, i think im only use Float and [Float] http://hpaste.org/78663
10:59:31 <rwbarton> it is an IO action that will always succeed
10:59:55 <mzero> rogerthealien: also, line 8 should be    setStack sr (n:stack')
10:59:57 <rwbarton> but, the result of that action might raise an exception when evaluated
11:00:09 <rwbarton> @type evaluate
11:00:10 <lambdabot>     Not in scope: `evaluate'
11:00:10 <lambdabot>     Perhaps you meant `evalState' (imported from Control.Monad.State)
11:00:14 <mzero> you've already taken the Maybe value apart with the case, no need to call things like fromJust (which you should banish from your code base0
11:00:20 <rwbarton> @hoogle evaluate
11:00:20 <lambdabot> Control.Exception.Base evaluate :: a -> IO a
11:00:20 <lambdabot> Control.Exception evaluate :: a -> IO a
11:00:20 <lambdabot> Control.OldException evaluate :: a -> IO a
11:00:24 <rogerthealien> rwbarton: what if f (Int -> Int -> Int) has incomplete pattern matching?
11:00:58 <rwbarton> it won't matter until something actually evaluates (f x y), which will happen after that catch has executed
11:01:01 <mzero> still won't happen until later
11:01:04 <hpaste> Peaker annotated “exceptionhandling” with “Use evaluate” at http://hpaste.org/78662#a78665
11:01:15 <mzero> return (f x y) just creates a thunk to apply f later one, should the result be needed
11:01:20 <Peaker> apfel_, your "f" returns Just, always, right?
11:01:35 <mzero> the (case r) is where it will finally throw, if it does
11:01:38 <Peaker> apfel_, My annotation also moves the "Just" wrapping outside of "f"
11:02:00 <apfel_> what do you mean with "f"
11:02:01 <Peaker> mzero, the use of "n"
11:02:06 <Peaker> (not the "case r")
11:02:12 <xplat> fromJust should almost never be used.
11:02:26 <xplat> i don't even know why it's in the library
11:02:31 <Peaker> oh right
11:02:36 <rogerthealien> rwbarton: is there away to create dependencies to force evaluation of an expression?
11:02:42 <hpaste> Peaker annotated “exceptionhandling” with “Use evaluate (annotation)” at http://hpaste.org/78662#a78666
11:02:54 <hpaste> Clint annotated “ResourceT confusion” with “m confusion (annotation)” at http://hpaste.org/78661#a78667
11:02:55 <rwbarton> did you see my query for 'evaluate' above or Peaker's annotation on your paste
11:03:15 <mzero> ah, rigth Peaker
11:03:20 <b____> are there any articles known among the people online right now about the uses of GADTs in the design of EDSLs?
11:03:28 <HN93> i hope someone can help me with this: i always get the error "Equations give different arities for "polyvalue"" for my function polyvalue [a:as] x = (a*x + (polyvalue [as] x)) does someone know why? :(
11:03:29 <rogerthealien> rwbarton: yes, thanks
11:03:29 <hpaste> neutrino pasted “type errors when using quickcheck” at http://hpaste.org/78669
11:03:36 <neutrino_> hi guys
11:03:49 <neutrino_> any tips on how to fix this? i'm trying to use qc2 with test-framework..
11:04:04 <rwbarton> HN93: because you have another equation for polyvalue with a different number of formal arguments (than 2)
11:04:14 <DMcGill> HN93: get rid of the []
11:04:24 <rwbarton> also yes, that code looks probably wrong
11:04:28 <DMcGill> i.e. the first bit should be "polyvalue (a:as)"
11:04:42 <DMcGill> and the last bit should be "polyvalue as x"
11:04:46 <xplat> a blast from the past courtesy of that wacky new book: forever $ putChar.chr.(0x2571+)=<<randomRIO(0,1)
11:04:51 <rwbarton> apfel_: you can't use : to append an element to a list
11:05:25 <Peaker> neutrino_, what exact error text do you get?
11:05:41 <hpaste> mzero annotated “exceptionhandling” with “exceptionhandling (annotation)” at http://hpaste.org/78662#a78670
11:05:47 <apfel_> rwbarton: but in other functions i used ":" for that and it worked, what should i use instead?
11:05:57 <mzero> handle is your friend
11:06:18 <hpaste> mzero annotated “exceptionhandling” with “exceptionhandling (annotation) (annotation)” at http://hpaste.org/78662#a78671
11:06:24 <hpaste> neutrino annotated “type errors when using quickcheck” with “type errors when using quickcheck (with error)” at http://hpaste.org/78669#a78672
11:06:29 <neutrino_> let me Peaker ^
11:06:31 <rwbarton> mzero, won't this still result in the exception appearing when the stack is viewed
11:06:33 <mzero> no maybes in sight!
11:06:37 <neutrino_> err
11:06:39 <neutrino_> Peaker: ^
11:06:49 <mzero> depends on how deep the possible exception inside n is
11:06:58 <rwbarton> well 'n' doesn't match anything at all :)
11:07:02 <mzero> I don't know what the type of the stack is!
11:07:04 <rwbarton> so, that is not a very high standard
11:07:05 <neutrino_> mzero: i thought you were mempty today :(
11:07:07 <DMcGill> apfel_: "1 : [2,3]" works fine, "[1,2] : 3" does not - (:) puts an element on the front of a list, not the back
11:07:25 <Peaker> what the heck is "@=?<" ? :)
11:07:42 <neutrino_> extracts the right side from a monad
11:07:46 <Peaker> neutrino_, oh I see -- you're hitting the dreaded MR
11:07:49 <mzero> even evaluate only does WHNF
11:07:56 <slack1256> Not all Arrows are a Monad, but are all Arrows a Functor?
11:07:57 <apfel_> DMcGill: thanks, i thought ":" works like (cons) in lisp
11:08:02 <xplat> maybe return wanted a turn as mempty
11:08:05 <Peaker> neutrino_, tp = testProperty is getting a monomorphic type
11:08:07 <DMcGill> HN93: read http://learnyouahaskell.com/starting-out#an-intro-to-lists to instand why
11:08:07 <rwbarton> but your last case f x y of n -> ... does no pattern matching at all
11:08:24 <neutrino_> Peaker: why would i hit it, if i define new lambdas every time?
11:08:33 <DMcGill> apfel_: read the link I posted above to understand why (:) only joins on the front
11:08:43 <xplat> apfel_: it does work like cons
11:08:44 <hpaste> mzero annotated “exceptionhandling” with “exceptionhandling (annotation) (annotation) (annotation)” at http://hpaste.org/78662#a78673
11:08:47 <rwbarton> cons also works that way in lisp
11:08:48 <mzero> shorter still!
11:08:53 <xplat> (you can't cons on the back of a list in lisp either)
11:08:56 <Peaker> neutrino_, things of the form:   x = y    (with no args on x)    get a single monomorphic type
11:09:09 <Peaker> neutrino_, so your "tp" gets a single type -- once you try calling it with 2 different types, it fails
11:09:09 <hpaste> mzero annotated “exceptionhandling” with “exceptionhandling (annotation) (annotation) (annotation) (annotation)” at http://hpaste.org/78662#a78674
11:09:16 <mzero> I keep copying that dang fromJust!
11:09:24 <neutrino_> right Peaker
11:09:26 <Peaker> neutrino_, if you use testProperty directly, or add a type annotation to tp, or use   tp x = testProperty x   or add a pragma: {-# LANGUAGE NoMonomorphismRestriction #-}  it will solve it
11:09:41 <Peaker> neutrino_, Very annoying, I hate the monomorphism restriction
11:09:50 <neutrino_> how do i make a shorthand for testProperty that has exactly as many arguments?
11:10:03 <Peaker> neutrino_, it doesn't have to.. as long as there's at least 1 arg
11:10:07 <neutrino_> aha
11:10:11 <neutrino_> gotcha
11:10:17 <neutrino_> that's a great tip. thanks!
11:10:24 <neutrino_> btw, i heard it's off by default in 7.6?
11:10:31 <Peaker> neutrino_, I'd recommend using some other method rather than f x = g x
11:10:35 <Peaker> neutrino_, only in ghci
11:10:53 <Peaker> neutrino_, I'd just use testProperty directly
11:12:20 <neutrino_> i prefer succint code for something i repeat a hundred times
11:12:28 <neutrino_> i'll just use tp x = ...
11:13:03 <neutrino_> Peaker: i'm putting @=?< and co, also an operator for checking against a regex, in a package
11:13:14 <neutrino_> hopefully i get a login sometime soon on hackage and can upload it
11:13:39 <Peaker> neutrino_, what is the type of @=?<
11:13:40 <ForSpareParts> How do I get fall-through behavior between parser functions in Parsec? I know there's supposed to be a way to do that -- where it gets halfway through a parser, fails, then tries the next one?
11:13:42 <neutrino_> and this code is for another package too, for mocking up VCS repos
11:14:13 <Peaker> neutrino_, I think having opaque operators like that is a bad idea -- it gives Haskell a line-noise reputation
11:14:22 <seydar> ahoy mateys
11:14:37 <seydar> kind of OT, but does anyone have any resources for implementing the Immix GC? i already have the original paper.
11:14:40 <Peaker> neutrino_, maybe the combinator you are looking for with @=?< already exists
11:15:23 <neutrino_> Peaker: no idea, inferred. (@=?<) expected monadic = do { received <- monadic; expected @=? received }
11:18:18 <hpaste> apfel_ annotated “listOfPowers” with “listOfPowers (annotation) (annotation)” at http://hpaste.org/78663#a78676
11:18:23 <Peaker> and what's @=?   or is that a typo and should be a recursive?
11:18:41 <apfel_> now i have a new error ... but i don't know why ...
11:18:55 <Peaker> neutrino_, you can define operators in infix form, btw:    expected @=?< monadic = ...
11:19:16 <Peaker> neutrino_, but this operator sounds like it could be replaced with something nicer...  if you build with -Wall you'll get the top-level type for free
11:19:23 <rwbarton> apfel_:
11:19:28 <rwbarton> @type (^)
11:19:30 <lambdabot> (Integral b, Num a) => a -> b -> a
11:19:49 <rwbarton> you probably want Integer or Int for 'n'
11:21:27 <apfel_> rwbarton: oh yes, thanks
11:28:09 <mSSM> Is there a function that lets me run a state-ful computation n times?
11:28:14 <mSSM> Starting from some initial state.
11:28:30 <Clint> replicateM?
11:29:53 <neutrino_> Peaker: what would you replace it with?
11:31:14 <neutrino_> Peaker: i'm guessing it's something like (Eq a, Show a, Monad m) => a -> m a -> Assertion
11:31:20 <neutrino_> but that might be wrong
11:31:45 <Peaker> neutrino_, why guess? Just enable -Wall and fix all the warnings :)
11:31:48 <Peaker> neutrino_, and get the actual type
11:33:22 <neutrino_> that's a good tip. how do i enable -Wall?
11:33:33 <neutrino_> i only know how to compile my module via "cabal install"
11:33:41 <neutrino_> and/or "cabal test"
11:34:47 <Peaker> neutrino_, In your .cabal file, in the exec/lib section, add: ghc-options:         -Wall
11:38:02 <neutrino_> ok!
11:40:09 <neutrino_> ok well this is what it inferred:                (@=?<) :: forall a. (Eq a, Show a) => a -> IO a -> IO ()
11:40:33 <neutrino_> it's funny that the resulting type is IO () and not Assertion. yet, it works well in test-framework.
11:40:39 <DMcGill> wow, that is quite an operator
11:41:22 <neutrino_> yeah i just added an angle bracket to @=?
11:41:43 <neutrino_> Peaker: why does it work? any idea?
11:42:02 <neutrino_> i use it in place of @=? when the right value is wrapped in a monad.
11:43:11 <Peaker> neutrino_, Assertion is just an IO ()
11:43:16 <neutrino_> hmm right
11:43:17 <Peaker> neutrino_, that asserts and succeeds or throws an error
11:43:32 <neutrino_> ah right, it's an alias?
11:43:42 <Peaker> where is @=? from?
11:44:06 <neutrino_> http://hackage.haskell.org/packages/archive/HUnit/1.2.2.1/doc/html/src/Test-HUnit-Lang.html#Assertion
11:44:11 <neutrino_> Peaker: it's from HUnit
11:44:47 <neutrino_> its usage is: expected @=? test
11:44:55 <Peaker> I think this should work: (left @=?) =<< right
11:45:12 <neutrino_> yeah it probably would
11:45:23 <neutrino_> but, i prefer less clutter
11:45:27 <Peaker> I think proliferation of operators is clutter :)
11:45:32 <neutrino_> i use this 100s of times in simple packages
11:45:38 <Peaker> I prefer: assertEqual left =<< right
11:45:52 <neutrino_> mhm
11:46:04 <neutrino_> with code highlighting it's easier for me to see operators though
11:46:10 <neutrino_> so i know the type of assertion immediately
11:46:29 <Peaker> operators require more working memory of your names to figure out your code
11:46:36 <Peaker> harder to dive in to random code...
11:46:54 <Peaker> and they make Haskell look like line noise :(
11:47:25 <neutrino_> :(
11:47:42 <neutrino_> but noise is the natural sound-envelope of the human habitat
11:47:55 <neutrino_> embrace the primal instinct, Peaker
11:51:04 <hpaste> Trek pasted “BSTree” at http://hpaste.org/78679
11:52:56 <Trek> http://hpaste.org/78679 the foldTree in BSTree  is compiled by ghci but it does not work
11:54:10 <Trek> do someone know why?
11:55:12 <danr> Trek: how do you mean does not work?
11:59:08 <Trek> danr?
11:59:25 <Peaker> Trek, you can get mapTree for free with the DeriveFunctor extension
12:04:30 <neutrino_> hey guys
12:04:51 <neutrino_> just like there are monad transformers, are there things you could call "data structure tranformers"?
12:04:57 <neutrino_> i wonder what those could look like
12:06:39 <sipa> you mean map?
12:06:52 <sipa> eh, fmap
12:06:55 <neutrino_> no, not really
12:07:22 <neutrino_> what i mean is, if you have a data structure with holes, and another one, you mix them and get a third data structure
12:07:39 <cmccann> neutrino_, if your data structures are functors then monad transformers will transform those data structures :P
12:08:13 <neutrino_> for example, let's say you have a tree type, but the part where you plug a value or a subtree is a hole
12:08:37 <neutrino_> then you transform that with a tuple type, for example (,)
12:08:42 <neutrino_> and you have a binary tree
12:09:00 <neutrino_> if you transform it with an n-tuple type you have an n-ary tree.
12:09:08 <cmccann> so "Tree f a = Leaf a | Branch (f (Tree f a))"?
12:09:17 <rwbarton> looks familiar
12:09:25 <neutrino_> maybe?
12:09:28 <neutrino_> i think so
12:09:31 <cmccann> that's a well-known idiom but I can't remember where it's well-known from
12:09:37 <rwbarton> anyways yeah, you don't need any fancy language like "data structure transformers", you just write down the parameterized type
12:09:40 <rwbarton> it's Fre
12:09:42 <rwbarton> e
12:09:53 <neutrino_> sure
12:09:58 <rwbarton> the point of monad transformer is if you plug in a monad, you get out another monad
12:10:02 <neutrino_> but then, if you had a lot of those, you could mix and match
12:10:04 <ozgura> cmccann: data types a la carte?
12:10:09 <rwbarton> but "being a data structure" isn't anything special to check
12:10:18 <cmccann> ozgura, ah that sounds plausible
12:10:28 <neutrino_> i heard of that paper
12:10:41 <neutrino_> is that related to the zippers paper?
12:12:16 <Peaker> Trek, don't pm please -- it means that if you add: "deriving (Functor)" after the definition of your tree type, you will have "fmap" with the same type and value as mapTree
12:36:01 <HN93> hi
12:37:30 <HN93> i want that my function : powers (a:as) x = [x^b] ++ powers as x  adds 1 to the value of b for every time it "throws away the a" do you understand what i mean? :D
12:37:42 <HN93> b starts with 0
12:38:04 <rodlogic> ghci
12:38:19 <monochrom> Prelude >
12:38:31 <rodlogic> :-) wrong window...
12:38:43 <monochrom> and slow human computer :)
12:40:09 <monochrom> you need one more parameter. powers (a:as) x b = [x^b] ++ powers as x (b+1)
12:41:22 <HN93> is it so easy? :D
12:41:26 <monochrom> yes
12:41:29 <mm_freak> @botsnack are you there, little buddy?
12:41:30 <lambdabot> :)
12:41:45 <mm_freak> lambdabot ignores invitations…  too bad
12:43:05 <elliott> mm_freak: admins can get it to @join channels, though
12:43:30 <monochrom> normally, I ignore invites, too
12:43:46 <mSSM> Are the state monads from transformers and mtl different?
12:44:11 <monochrom> they are the same. mtl is just a wrapper of transformers
12:44:32 <Canar> it's more than meets the eye
12:44:34 * Canar hides
12:44:58 <monochrom> use :info to find out where a type or value or... is really defined. then you will know
12:45:47 * hackagebot SybWidget 0.5.5 - Library which aids constructing generic (SYB3-based) widgets  http://hackage.haskell.org/package/SybWidget-0.5.5 (MadsLindstroem)
12:45:49 * hackagebot void 0.5.10 - A Haskell 98 logically uninhabited data type  http://hackage.haskell.org/package/void-0.5.10 (EdwardKmett)
12:45:53 <mm_freak> elliott: then the question remains, who are the admins?
12:46:46 <elliott> mm_freak: there are quite a lot of them (I am one), not sure there's a list... what channel is it?
12:47:15 <mm_freak> lambdabot is quiet in the channel unless queried, right?
12:47:30 <elliott> yeah
12:47:35 <elliott> totally quiet, in fact, AFAIK
12:47:45 <elliott> @list-chans
12:47:45 <lambdabot> ##freebsd ##logic ##proggit ##villagegreen #agda #arch-haskell #codez #darcs #esoteric #fedora-haskell #friendly-coders #functionaljava #gentoo-haskell #gentoo-uy #ghc #happs #haskell #haskell-blah #
12:47:45 <lambdabot> haskell-books #haskell-br #haskell-fr #haskell-freebsd #haskell-game #haskell-in-depth #haskell-lens #haskell-overflow #haskell-pl #haskell.au #haskell.cz #haskell.de #haskell.dut #haskell.es #
12:47:45 <lambdabot> haskell.se #haskell.tw #learnanycomputerlanguage #macosx #macosxdev #rosettacode #scala #scalaz #scannedinavian #snapframework #tanuki #teamunix #unicycling #xmonad #yi weird#
12:47:57 <atriq> lambdabot popular
12:48:06 <elliott> I think you need to ask Cale if you want your channel to be automatically joined when lambdabot restarts, but @join works otherwise
12:48:13 <Ralith> weird#? o.O
12:48:24 <atriq> I hope #unicycling is actually about unicycling
12:48:43 <neutrino_> what's weird#
12:49:00 <monochrom> a GHC internal weirdness :)
12:49:02 <mm_freak> elliott: /noticed
12:49:38 <elliott> mm_freak: are the ops ok with lambdabot being there?
12:50:17 <Ralith> elliott: doesn't one normally need to be an op to send invites?
12:50:30 <elliott> good point
12:50:42 <elliott> there we go, then
12:50:51 * hackagebot SybWidget 0.5.6 - Library which aids constructing generic (SYB3-based) widgets  http://hackage.haskell.org/package/SybWidget-0.5.6 (MadsLindstroem)
12:50:53 * hackagebot WxGeneric 0.8.1 - Generic (SYB3) construction of wxHaskell widgets  http://hackage.haskell.org/package/WxGeneric-0.8.1 (MadsLindstroem)
12:52:38 <mSSM> How do I pass a constructor to lambda? E.g. I have `data Foo = Foo Int' and now I have a lambda somewhere: \(Foo myInt) -> ... Is this correct?
12:52:55 <atriq> Yeah
12:53:05 <shachaf> That's not passing a constructor to lambda, it's pattern-matching.
12:53:11 <atriq> :t \(Just n) -> n
12:53:11 <shachaf> But anyway have you tried it? :-)
12:53:13 <lambdabot> Maybe t -> t
12:53:37 <neutrino_> > let x = Nothing in (\(Just y) -> y) x
12:53:39 <lambdabot>   *Exception: <interactive>:3:21-34: Non-exhaustive patterns in lambda
12:54:07 <neutrino_> atriq: it's funny we both decided to use Just as an example.
12:54:14 <atriq> :)
12:54:24 <atriq> Except I'm quicker :P
12:54:44 <mSSM> shachaf: Nope ... ghci complains about something, and I thought this was the problem. :(
12:55:22 <neutrino_> atriq: i checked in /msg first
12:55:29 <monochrom> you should not trust your own guess
12:55:53 <neutrino_> trust someone else's guess, then you're not to blame
12:56:08 <atriq> I have confidence in myself, and don't get embarrassed easily
12:56:52 <monochrom> actually, if you use the scientific method, you don't need trust, and you can guess all you want
12:59:14 <neutrino_> but if you use the scientific method you need to decide on a sigma value at which you start taking things as true
12:59:19 <neutrino_> and that's again trust
13:01:12 <mm_freak> neutrino_: we trust in formalisms with certainty…  we need sigma when we need to trust in nature
13:01:35 <monochrom> why should I do that. I can keep track of "probability of X is 99.9%, probability of Y is 98.5%". I don't have to convert them to "true"
13:02:41 <neutrino_> or can you
13:03:47 <elliott> yes
13:09:52 <neutrino_> monochrom: i believe the notion of truth and untruth is a fundamental part of the way the subconscious works
13:13:43 <absence> i'm trying to load a file into ghci, and get the error Couldn't match expected type `bytestring-0.9.2.1:Data.ByteString.Lazy.Internal.ByteString' with actual type `B.ByteString'
13:13:54 <absence> i have 0.9.2.1 installed, why doesn't it use it`
13:13:55 <absence> ?
13:14:14 <atriq> Because the strict and lazy bytestring types are different
13:14:17 <atriq> Probably
13:14:41 <absence> atriq: it's a version thing. when i compile using cabal and force the bytestring version, it works
13:14:52 <c_wraith> then uninstall one of the bytestring versions
13:14:53 <atriq> Aaah
13:15:01 <atriq> absence, what c_wraith said
13:15:14 <c_wraith> or at the very least, hide it
13:15:24 <neutrino_> it sounds like you're in cabal hell
13:16:01 <absence> how do i hide it? i can't uninstall it, other packages depend on it
13:16:22 <c_wraith> other packages depending on it is *why* things are broken
13:16:36 <c_wraith> You've built yourself diamond dependencies
13:16:54 <c_wraith> You're going to have to unregister a bunch of things, and re-install things *carefully*
13:17:23 <absence> c_wraith: 0.9.2.1 is part of haskell-platform
13:17:28 <c_wraith> so?
13:17:49 <c_wraith> (I don't respect the platform much, because it tends to cause problems like these)
13:17:56 <mSSM> Can somebody explain to me why I am getting this error message? I am trying to use the State monad, but I am failing: http://hpaste.org/78682
13:18:08 <mSSM> (at the bottom)
13:18:58 <c_wraith> mSSM: runState is pure, but you're trying to execute it as an IO action
13:19:05 <Jeanne-Kamikaze> that ^
13:19:16 <Jeanne-Kamikaze> > :t runState
13:19:17 <lambdabot>   <hint>:1:1: parse error on input `:'
13:19:23 <Jeanne-Kamikaze> well, whatever
13:19:31 <c_wraith> mSSM: the error message is saying that the return type of runState, a pair, isn't IO
13:19:33 <atriq> :t runState
13:19:34 <lambdabot> State s a -> s -> (a, s)
13:19:36 <Jeanne-Kamikaze> ah
13:20:21 <Jeanne-Kamikaze> :t return . runState
13:20:23 <lambdabot> Monad m => State s a -> m (s -> (a, s))
13:20:41 <c_wraith> need more composition
13:20:48 * hackagebot simple-reflect 0.3 - Simple reflection of expressions containing variables  http://hackage.haskell.org/package/simple-reflect-0.3 (TwanVanLaarhoven)
13:20:52 <atriq> :t return .: runState
13:20:53 <lambdabot> Monad m => State s a -> s -> m (a, s)
13:21:05 <c_wraith> But that's a pretty useless action
13:21:23 <c_wraith> Because it doesn't actually do anything
13:21:26 <atriq> :t runStateT
13:21:27 <lambdabot> StateT s m a -> s -> m (a, s)
13:21:35 <absence> c_wraith: ghc-pkg says that unregistering 0.9.2.1 will break a million packages
13:21:53 <c_wraith> absence: your other options is unregistering whatever other bytestring version you have installed
13:21:56 <c_wraith> *option
13:22:05 <c_wraith> that will probably only break a few packages
13:22:07 <Jeanne-Kamikaze> :t (.:)
13:22:08 <lambdabot> (Functor g, Functor f) => (a -> b) -> f (g a) -> f (g b)
13:22:21 <c_wraith> Jeanne-Kamikaze: it's a lambdabot special
13:22:24 <atriq> @hackage pointless-fun
13:22:24 <lambdabot> http://hackage.haskell.org/package/pointless-fun
13:22:27 <atriq> It's in there
13:22:33 <Jeanne-Kamikaze> thanks
13:22:34 <quchen> :t (.:)
13:22:35 <lambdabot> (Functor g, Functor f) => (a -> b) -> f (g a) -> f (g b)
13:22:42 <absence> c_wraith: yes. i won't be able to use those packages then
13:22:45 <mSSM> c_wraith: Ok... it wasn't my intetion; does this have to do with my definition of `update' in that code?
13:23:15 <absence> c_wraith: is this a bug/missing feature in ghci?
13:23:17 <c_wraith> absence: or you can reinstall them depending on the other version of bytestring
13:23:31 <c_wraith> absence: it's what happens when you install multiple versions of the same package.  Just don't do that.
13:23:49 <shachaf> Multiple versions of the same package in general might not be that bad.
13:23:56 <shachaf> But for bytestring it's probably pretty bad.
13:24:00 <absence> c_wraith: i didn't install multiple versions. it happened by itself through dependencies
13:24:06 <Jeanne-Kamikaze> c_wraith, and why doesn't it actually do anything ?
13:24:36 <absence> c_wraith: either way it's a bit strange that ghc compiles it fine, but ghci isn't able to load it
13:25:13 <c_wraith> absence: like I said, you could hide one of the versions, which would get you more or less the same view cabal has - but things would still be potentially broken if they use the wrong combination of packages
13:25:48 * hackagebot simple-reflect 0.3.1 - Simple reflection of expressions containing variables  http://hackage.haskell.org/package/simple-reflect-0.3.1 (TwanVanLaarhoven)
13:27:05 <c_wraith> Jeanne-Kamikaze: well, by the monad laws, return is the action that doesn't do anything. If you do bind the result, you might as well name it with a let binding instead. It's simpler and clearer.
13:27:40 <Jeanne-Kamikaze> ah you mean his line of cod e?
13:27:50 <Jeanne-Kamikaze> or wait
13:27:57 <Jeanne-Kamikaze> ok nevermind
13:28:51 <c_wraith> mSSM: no, your update function is probably fine. The problem is you're using runState wrong.
13:29:42 <mSSM> c_wraith: Yeah; I noticed that and fixed it. :) Now it works! Thank you!
13:30:00 <absence> c_wraith: ah, ghci -hide-package
13:30:08 <absence> that did the trick :) thanks
13:30:29 <c_wraith> absence: you can also use ghc-pkg to make packages hidden by default
13:32:18 <mSSM> I have yet another question: why do I need to use `print', not `show', in this definition? http://hpaste.org/78683 All I want to do is inspect a part of my `Ising' data structure, which is deriving Show
13:32:45 <sipa> print = putStr . show
13:33:09 <sipa> show: conversion to a String; print: sending that to stdout
13:33:25 <mSSM> Oh, I guess I am confusing show used from ghci and within a script
13:34:33 <rwbarton> ghci wraps an implicit 'print' around anything that isn't an IO action
13:37:32 <mSSM> Good to know
13:37:34 <mSSM> thank you
13:37:46 <mSSM> #haskell is nice :)
13:40:50 <monochrom> having more than one version of bytestring will confuse you. it has confused you.
13:41:06 <ciaranm> edwardk: data Foo = Foo { _foo :: Int } ; makeClassy ''Foo <-- what exactly is it that makes that not work? it ends up with multiple declarations of foo
13:41:33 <shachaf> ciaranm: "not work" is kind of vague.
13:41:45 <ciaranm> shachaf: see following sentence!
13:41:55 <edwardk> ciaranm: makeClassy is making a lens named 'foo' to find a Foo. and one named 'foo' for the member
13:42:09 <ciaranm> ooh
13:42:17 <edwardk> class HasFoo t where foo :: Simple Lens t Foo;    foo :: Simple Lens t Int
13:42:26 <monochrom> people who say "it's fine to have several versions" are irresponsible IMO. the pros can do it because they know how to work around problems. but you don't know how to work around problems, you only get confusion
13:42:26 <edwardk> t wants to call the first foo from the second foo
13:42:35 <ciaranm> i find i'm doing quite a few makeClassys for single fields
13:43:05 <edwardk> you can tell it to make a different member name or a different class name using makeLensesWith $ classyRules & … modify the classyRules here ...
13:43:55 <ciaranm> i'm not really using the Foo, just the foo
13:45:33 <monochrom> wait a second, you can have two foo's?
13:46:07 <zenzike> whois nominolo
13:46:11 <ciaranm> you can have a barFoo and a fnordFoo, and a HasFoo typeclass that has a foo
13:46:50 <edwardk> monochrom: he can't thats his problem
13:46:58 <monochrom> I see, thanks
13:47:02 * zenzike is looking for Joachim Breitner
13:48:25 <zenzike> are there any debian Haskell maintainers around?
13:48:40 <edwardk> he can just change it out with something like makeLensesWith $ classyRules & lensClass .~ const ("HasFoo","bar")
13:49:08 <edwardk> that would change it it makes a class named HasFoo and uses the 'bar' member of that class for what it prepends onto all of his other lenses
13:49:53 <edwardk> er const (Just ("HasFoo","bar"))
13:50:20 <ciaranm> hrm. thinking about it more, i think some of these need to be just getters, rather than lenses. so maybe classes aren't going to work anyway.
13:51:15 <edwardk> in general if its just a getter i don't bother to write a combinator, i juse use 'to'. https://github.com/ekmett/lens/wiki/faq#wiki-using-getters
13:52:08 <arcatan> zenzike: Joachim's nick is nomeata, but I don't remember seeing him here for ages
13:53:16 <shachaf> edwardk: classyRules & lensClass.mapped ?~ ("HasFoo","bar") :-)
13:53:26 <edwardk> shachaf: even better
13:53:32 * shachaf isn't sure that's better.
13:53:47 <shachaf> It's a new use of mapped, though.
13:53:50 <edwardk> its sneakier for sure
13:54:09 <zenzike> arcatan: thanks
13:54:40 <edwardk> the :-) for some reason causes it not to parse for me though ;)
13:54:42 <zenzike> arcatan: I had the feeling it startied with nom ... :-)
13:55:01 <mSSM> If I want to make a data type `data Spin = Up | Down', what would be the easiest way to represent `Up' with +1 and `Down' with -1, so that I can actually work with these values?
13:55:45 <edwardk> mSSM: charge Up = 1; charge Down = -1;  and work with charge when you need it as a number.
13:56:03 <edwardk> (or spin or whatever you want to call it)
13:56:32 <mSSM> edwardk: Where doesw that charge function go?
13:56:42 <mSSM> I.e. where would I define it?
13:56:56 <edwardk> mSSM: its just a function, put it wherever you want.
13:57:17 <robbe-> I can't seem to find an existing function that will replace the nth element of a list. As I don't think I should reinvent the wheel: did I miss it?
13:57:31 <shachaf> robbe-: Nope.
13:57:54 <shachaf> robbe-: Replacing the nth element is a pretty unusual operation on a list -- indexing isn't that common, especially doing it more than once.
13:58:13 <edwardk> > [a,b,c,d] & element 2 .~ e
13:58:13 * edwardk shakes lambdabot.
13:58:14 <lambdabot>   [a,b,e,d]
13:58:52 <shachaf> Well, and there's that.
13:58:56 <edwardk> that is lens code though ;)
13:58:56 <shachaf> But that won't give you sharing!
13:59:04 <edwardk> sadly
13:59:07 <apfel_> how can i write a function without an input value but with an output value of type [Int], the function should do the following [x | x <- [3000..7000], sum (listOfDigits x) == 19]
13:59:17 <robbe-> lens code?
13:59:24 <shachaf> apfel_: Why make it a function?
13:59:30 <shachaf> Sounds like a plain list to me.
13:59:33 <edwardk> robbe-: that was written using the lens library, its not a standard function
13:59:49 <edwardk> robbe-: the short answer is that there is no such function defined for you
13:59:52 <robbe-> edwardk: Oh, okay :-)
14:00:15 <edwardk> robbe-: the long answer is that if you need to update the nth element of the list regularly, then a list is a terrible data structure to choose, and that is _why_ the function doesn't exist ;)
14:00:24 <apfel_> shachaf: because thats what i have to do :)
14:00:24 <akahn> my program won't compile and I can't tell why. http://hpaste.org/78685 Why is Message -> Char the expected type here?
14:00:33 <shachaf> apfel_: What?
14:00:57 <shachaf> apfel_: There's no such thing as "a function without an input value", so if you *have* to do that, you're in trouble.
14:01:11 <robbe-> edwardk and shachaf, thanks for the feedback :) And indeed, I am playing around with [[a]] to represent a matrix. Arrays would be better suited.
14:01:13 <apfel_> shachaf: i see
14:01:54 <shachaf> Arrays are probably not optimal either if you're doing updates like this.
14:02:23 <shachaf> akahn: What's the type of (messages Transcript)?
14:02:40 <shachaf> Oh, that doesn't actually matter.
14:02:51 <akahn> schlaftier: (messages Transcript) is [Message]
14:02:55 <shachaf> akahn: The type of hPutStr handle is String -> IO ()
14:03:05 <shachaf> I.e., [Char] -> IO ()
14:03:34 <akahn> and I'm giving it a list of Strings!
14:03:43 <shachaf> Right, but it only wants one string.
14:03:55 <akahn> thank you schlaftier
14:03:58 <Gunni> I'm having problems with network-2.3.1.0 on Windows. connect seems to be blocking the runtime, preventing other threads from running while it's connecting. I'm compiling with -threaded. What could explain this issue?
14:04:01 <akahn> shachaf, that is
14:04:10 <robbe-> shachaf: Oh, why would arrays not be optimal either?
14:04:34 <shachaf> robbe-: Well, updating a single element of an immutable array involves copying the whole thing.
14:05:52 <bgamari> If I have a space leak of [] objects, how do I tell what it is a list of?
14:06:48 <robbe-> shachaf: Right, so basically 'updating' data structures is not what Haskell is good at? Or what are the alternatives.
14:07:05 <shachaf> There are various alternatives, depending on what you're doing.
14:07:30 <monochrom> that statement is false. haskell is good at updating some data structures.
14:07:48 <shachaf> The issue with lists isn't updating but indexing.
14:08:01 <tryhaskell> can someone help me with this? derive (a:as) = [a*(length (a:as)-1)] ++ derive as gives as neede the derivates, but it adds a 0 at the end, which i dont want
14:08:47 <monochrom> wait, what is the base case?
14:09:20 <monochrom> also why is "[x] ++ recursive call" so popular these days?
14:09:54 <pikhq_> Because some people don't like x : recursive call?
14:10:21 <monochrom> and some people like me don't like [x] ++ recursive call
14:10:41 <Mortchek> n ++ m is O(n), right?
14:11:02 <monochrom> depends on what you extract from n++m
14:11:12 <bitonic> Mortchek: well, you need to traverse and copy the first list, if that’s what you mean
14:11:21 <Mortchek> Yeah, that is what I meant.
14:11:29 <bitonic> well then yes :)
14:11:41 <monochrom> null (repeat True ++ []) is not going to be O(∞)
14:12:09 <Mortchek> Makes sense.
14:12:27 <mgccl> I have the following problem and don't know how to write a program for: I need a function readData, so it is a loop: first getLine, then it check if the first character in the next line is '>', if so then stop and return, if not then get another line and concat with the previous line.
14:12:44 <mapf> probably here should be claim 'for fully evaluated list complexity is X'
14:14:48 <bitonic> yeah I think that’s understood - you’re only accounting for the ++, and assuming that you force the entire list
14:15:07 <bitonic> if you start taking things out of context or the other way around it’s pointless to talk about complexity :P
14:15:23 <Mortchek> It's a reasonable point to make though - laziness certainly changes things.
14:15:31 <monochrom> readData = do { x <- getLine; case x of { '>':_ -> return ""; _ -> do { y <- readData; return (x++y) }}}
14:15:35 <Mortchek> (Assuming you are used to strictness.)
14:15:43 <bitonic> n ++ m might be exponential, maybe `n' is a thunk!
14:15:55 <Mortchek> bitonic, how so?
14:16:25 <bitonic> Mortchek: maybe `n' hasn’t been forced yet
14:16:29 <xcv_> Hi, I'm pretty new to haskell (currently learning about typeclasses, just read applicative functors) and I'm trying to make a "Formula" typeclass where I have a "derivative" function. How can I make the return type generic so I can return an Addition or a Constant for example?
14:16:44 <Mortchek> bitonic, but why might that make it exponential?
14:17:17 <mgccl> monochrom: thanks! I see how it is done now (never used return before actually)
14:17:34 <bitonic> Mortchek: it might make it O(whatever) really - my point is just that when you say “what’s the complexity of X” it’s usually understood that the arguments are evaluated
14:17:46 <akahn> with aeson is there a way to determine why decode is returning Nothing?
14:17:49 <bitonic> and that you are going to force the result afterwards
14:18:02 <Mortchek> bitonic, what I'm failing to understand is how that could be any *worse* than O(n).
14:18:31 <bitonic> Mortchek: if you have a `n ++ m' in Haskell code you don’t really know what’s going to happen without looking at the context
14:18:41 <bitonic> because `n' might have not been fully evaluated yet
14:18:57 <Mortchek> bitonic, ah, I see what you're saying.
14:19:11 <Mortchek> The operation creating the list could easily be of any complexity.
14:19:26 <bitonic> yes
14:19:52 <Mortchek> I suppose that is yet another implication of my question I was not aware I was making. :)
14:20:06 <Mortchek> s/implication/assumption/
14:20:18 <bitonic> yeah.  but your assumptions were the reasonable ones :)
14:20:44 <bitonic> note that sometimes lazyness is important - e.g. when calculating amortised complexity
14:22:01 <xcv_> this is what I'm trying to do, I hope it helps http://pastebin.com/se7j4YmF
14:22:05 <mauke> The paste se7j4YmF has been copied to http://hpaste.org/78688
14:23:57 <bitonic> xcv_: I don’t have the time to talk about it now, but I think that doesn’t do what you think it does.  `(Formula b, Formula c) => f -> b -> c' says that I can decide *any* b and c, as long as they’re Formulas.  I think you just want a `Formula' datatype, and a `derive :: Formula -> Formula'.
14:24:56 <xcv_> bitonic: Is there a way I can make it extensible so I can add other types such as Sine or Cosine? Thanks
14:25:01 <neutrino_> hey guys, how can i use quickcheck with monads?
14:25:13 <monochrom> I join the "I don't have time but" club while we're at it. why have a Formula type class and a Constant type and an Addition type etc? this is a mis-design.
14:25:50 <monochrom> type class is not type. there is no such thing as "a value of type class Formula".
14:25:58 <tertl3> hi
14:26:01 <bitonic> xcv_: right, so you want a way to “plug in” new functions.  then a type class might be involved, but not in the way you are trying to involve it :P
14:26:31 <hpaste> ciaranm pasted “Baby constraint solver” at http://hpaste.org/78689
14:26:35 <neutrino_> i understand that the "prop" in a quickcheck property test has to have final value Bool. I don't know how that can work when i need to check the properties of a function which e.g. does IO. how can i do this?
14:26:46 <bitonic> xcv_: if you want to do simple symbolic differentiation, I strongly suggest to write it with a simple, monolithic data type first.  then the various drawbacks will be much more evident
14:26:46 <xcv_> bitonic: this is what I'm trying to guess, but I can't find how to do it... is it too complex for me?
14:26:59 <bitonic> xcv_: do the simple case first as I suggested
14:27:00 <ciaranm> ^^ if anyone has a few moments, i'd like feedback on making that prettier (the structure, not the algorithm). in particular, i want to be able to get rid of the :: Int qualifications towards the end
14:27:29 <xcv_> bitonic: thanks, I'll do that first. I may come back later when I try to do the typeclass version :)
14:27:52 <bitonic> xcv_: OK.  my guess is that you’ll be satisfied with the “simple” version :)
14:29:44 <mSSM> In an expression like this: let { v1 = x1 ; ... } in { f1 v2 ; ... } where { v2 = x2 v1 }, why is v1 not in scope?
14:29:57 <hpaste> Trek pasted “acc” at http://hpaste.org/78690
14:30:13 <bitonic> xcv_: btw, do you happen to go to Imperial?  because they have precisely that exercises in the first term of the first year.  although I think December is a bit late
14:31:37 <xcv_> bitonic: no, one day I read an article about haskell and I decided to learn it with "learn you a haskell for great good". I have a similar project in C++ (much bigger of course) so I thought this would be an interesting exercise
14:31:44 <monochrom> mSSM: you should not cut away code. you really have: blah = let { v1 = x1 ; ... } in { f1 v2 ; ... } where { v2 = x2 v1 }. because that's how it's legal to have that "where" in the first place
14:32:32 <mSSM> monochrom: ok, I am sorry; but is that v1 in scope now?
14:32:33 <monochrom> and it's important because it answers your question. "where { v2 = x2 v1 }" belongs to "blah =". therefore, there is no v1 there.
14:32:57 <mSSM> monochrom: Ok, I wasn't sure about that.
14:33:01 <bitonic> xcv_: yes, it is a nice exercise
14:33:35 <Amoeba1> Hi all.
14:33:35 <monochrom> logically, if you weren't sure, you would give complete information, not cut out information thinking that you knew what to cut out
14:33:49 <Amoeba1> Is there some way to look at how a function is written internally?
14:33:55 <Amoeba1> Length function for instance?
14:34:06 <ciaranm> Amoeba1: hoogle it and click on the Source link
14:34:18 <mSSM> monochrom: I mean, I wasn't sure this part was important. Thank you for your help.
14:34:18 <ciaranm> @source length
14:34:19 <lambdabot> length not available
14:34:19 <Amoeba1> ciaranm:  thanks.
14:35:13 <bitonic> @src length
14:35:13 <lambdabot> Source not found. Just try something else.
14:35:31 <bitonic> yeah, I was going to say not to trust @src :)
14:35:39 <Amoeba1> em ..
14:35:58 <Amoeba1> So it's a mystery function?
14:36:34 <ciaranm> no, @src is just dodgy
14:36:52 <bitonic> Amoeba1: it’s not.  hoogle should have the source.  but if you want a reference implementation that’s a bad idea as well, because they might be optimised making the code less clear
14:37:40 <Amoeba1> bitonic: yes I found the reference implementation for length.
14:37:41 <Amoeba1> http://www.haskell.org/onlinereport/standard-prelude.html
14:37:57 <bitonic> Amoeba1: oh yes, that works.
14:38:07 <bitonic> for the Prelude anyhow.
14:38:21 <bitonic> except when GHC breaks compatibility with the std, so watch out
14:40:18 <cvii> is it possible to write function reverse that takes function a->b as argument and returns b->a ? operating on haskell code?
14:40:26 <Athas> cvii: no.
14:40:38 <Athas> Well, not if you want it to be total, anyway.
14:40:53 <cvii> and in simpler cases?
14:41:21 <bitonic> cvii: you can’t write a meaningful `(a -> b) -> (b -> c)' function.
14:41:54 <bitonic> cvii: you can easily write a function like that for types with 0 or 1 elements
14:42:05 <cvii> like "add2 x = x + 2" -> "reverse_add2 x = x - 2" ?
14:42:12 <bitonic> @type \f -> not . f
14:42:13 <lambdabot> Functor f => f Bool -> f Bool
14:42:23 <bitonic> @type \f x -> not (f x)
14:42:24 <lambdabot> (t -> Bool) -> t -> Bool
14:42:28 <Amoeba1> map and unmap the map?
14:42:52 <Amoeba1> bitonic: Maybe I am going too far too fast why can't it be done?
14:43:30 <bitonic> Amoeba1: for many reasons.  the first one is that not all functions are “invertible” (bijective)
14:43:41 <Amoeba1> Fair enough.
14:43:46 <cvii> i understand
14:44:04 <Amoeba1> Thanks.
14:44:10 <cvii> but is manipulating haskell code that way possible?
14:44:17 <akahn> I'm having trouble parsing JSON with aeson. there's no error but calling decode returns Nothing rather than my type. can anyone tell why? http://hpaste.org/78691
14:44:28 <bitonic> cvii: look at Template Haskell
14:45:07 <cvii> ok
14:45:17 <fmap> akahn: because 1234 is not a String?
14:45:24 <Athas> cvii: in general, it is an undecidable problem.
14:45:30 <Athas> Not even Template Haskell can help you there.
14:45:33 <cvii> yes i know
14:45:53 <neutrino_> how can i test a function which results in IO Bool with quickcheck?
14:46:06 <akahn> fmap: of course! thank you
14:48:23 <monochrom> I have students who keep equating strings with numbers
14:49:00 <ciaranm> instance Num String
14:49:06 <ciaranm> mwa ha ha ha ha
14:49:25 <monochrom> they write like { x ∈ {0,1}* | x is even }. OK, x is a string, so what the hell does even mean?
14:49:55 <ion> hah
14:49:56 <Athas> Probably that x is even when viewed as a binary number.
14:50:11 <Athas> I don't really find that too confusing, when the string is over an alphabet of digits.
14:50:29 <ciaranm> it means whatever gets them the marks
14:50:39 <Athas> I mean, a number is represented as a string of digits, isn't it?
14:50:50 <ciaranm> nope
14:51:04 <ciaranm> a number is represented as Succ (Succ (Succ Zero))
14:51:08 <ciaranm> or a load of lambdas!
14:51:17 <monochrom> and then I have a correspondence in haskell-cafe who do not know why "instance IsString (Int -> t)" is a depravity
14:51:36 <Athas> Yes, in our particular branch of the mathematical orthodoxy, but complexity theory people love their strings of symbols!
14:51:57 <ion> monochrom: t or Something t => … t?
14:52:07 <rwbarton> as in "\\x -> x + 1" ?
14:52:21 <rwbarton> or is this to do with bases
14:52:27 <shachaf> http://www.samuelhughes.com/isstring/index.html
14:52:33 <elliott> "abc" 1 == 'b' hopefully?
14:52:36 <monochrom> Athas, it is does not confuse me, but only because I am smart. it is sloppy and imprecise. it can lead you to wrong conclusions.
14:52:42 <elliott> i mean it's better than "\\x -> x+1"
14:52:51 <rwbarton> maybe "14" 9 = 13
14:53:01 <ion> shachaf: Classy.
14:53:51 <typoclass> shachaf: heh, that's cute
14:54:37 <monochrom> ion: you may like to see it verbatim, start from http://thread.gmane.org/gmane.comp.lang.haskell.cafe/101576/focus=101597
14:55:03 <monochrom> that is, the guy is writing like :t "a" 3
14:55:41 <ion> monochrom: hehe
14:55:48 <ion> “I am confused, in what sense this is depravity?”
14:56:20 <monochrom> perhaps I should reply, "I am also confused, in what sense is this not obviously depravity?"
14:56:49 <monochrom> and it would be honest. I am confused as to why care about "a" 3
14:58:03 <ion> Well, obviously it would be great to be able to have "minus" 3 == (-3)
14:58:42 * cmccann can't help but read "minus" as being scare-quotes, like it's not really negating anything
14:58:47 <Athas> Yes.  This is an elegant solution to the problems wrt. prefix minus and tuple sections.
14:59:24 <Athas> Who'll write up the Haskell' proposal?
14:59:35 <monochrom> I have a more elegant solution. screw the quotes. minus 3
14:59:42 <ion> "putStrLn" "Hello world"
14:59:42 <jmcarthur> you could use OverloadedStrings to do that :)
14:59:44 <Athas> Er, not tuple sections, not sections.
15:01:09 <Saizan> monochrom: i think the guy doesn't understand typeclasses and/or Num and brought up string literals for contrast
15:01:26 <cmccann> really though, might as well take things to their logical conclusion. make everything an instance of IsString, and eval the string using hint or whatever.
15:01:35 <cmccann> problem solved.
15:02:07 <latro`a_> instance isString a where
15:02:11 <ion> Sounds like a plan.
15:02:12 <latro`a_> *IsString
15:02:13 <latro`a_> >.>
15:02:16 <Athas> monochrom: out of curiosity, how would you propose that the students describe this set?  As { {0,1}*0 }?
15:02:56 <monochrom> yes. or "x is the binary representation of an even number"
15:03:27 <mauke> monochrom: big endian or little endian‽
15:03:40 <monochrom> as long as you recognize that x is a string and there is a gap to bridge before you can talk about numbers, that is sufficient, it shows that you are aware of the issues
15:03:46 <ion> Some of us like middle-endian, you insensitive clod!
15:03:48 <monochrom> 3/4 endian, mauke
15:03:57 <mauke> ¾
15:04:44 <Amoeba1> Why is succ defined the way it is defined? For example, succ 1.1 gives 2.2. Why is it not restricted to integers? isn't 1.3 a successor of 1.1?
15:05:23 <ciaranm> > [1.1 .. 4.4]
15:05:25 <lambdabot>   [1.1,2.1,3.1,4.1]
15:05:27 <latro`a_> well, there's good reason for floats to be Enum
15:05:36 <latro`a_> but making them Enum requires a default step size
15:05:39 <monochrom> because, 15 years ago, succ was restricted to integers, but someone asked in #haskell, "why is it not generalized to floating point numbers"
15:05:42 <cmccann> Amoeba1, because people want to use range notation in confusing ways for some reason
15:05:45 <ciaranm> succ of 1.1 is 2.1, isn't it?
15:05:48 <ciaranm> >succ 1.1
15:06:18 <Amoeba1> ciaranm: yes.
15:06:31 * ciaranm never really liked list comprehensions anyway
15:06:32 <Amoeba1> Sorry about that. I got confused.
15:06:48 <Amoeba1> monochrom: Is that a joke or for real?
15:07:04 <cmccann> > [1.1 .. 2.6]
15:07:05 <lambdabot>   [1.1,2.1,3.1]
15:07:09 <monochrom> it is not a joke. it is not real. it is an exaggeration.
15:07:10 <cmccann> sensible!
15:07:29 <byrdmansniper> when using a "case" statement how do you write a statement that does not receive a variable?
15:07:41 <ciaranm> > [1, pi .. 10]
15:07:43 <lambdabot>   [1.0,3.141592653589793,5.283185307179586,7.424777960769379,9.566370614359172]
15:07:48 <monochrom> someone wanted it. someone had enough influence to get it. perhaps because "someone" is enough number of people, or the right group of people
15:07:48 <ciaranm> totally makes sense
15:08:03 <ciaranm> byrdmansniper: rephrase your question please
15:08:23 <Amoeba1> cmccann: Ok so my final variable in that list is not the final variable but the closest?
15:08:37 <monochrom> take the time to learn that what goes and doesn't go into a language/library is a tug war between conflicting interests. it is politics. there is no "why" apart from that.
15:08:48 <cmccann> dunno, I actually can't recall what the float Enum instance does
15:09:10 <rwbarton> basically it rounds the purported end element to the closest thing that actually appears in the arithmetic sequence
15:09:15 <cmccann> it's probably whatever is "intuitive" but I can't recall what that would be
15:09:35 <monochrom> another tug war is "why Monad is not a subclass of Functor"
15:09:44 <byrdmansniper> i am using a "case variable of" switch and on of the possible cases has been predefined to not receive a variable; how do i write that particular case?
15:10:16 <Amoeba1> monochrom: I am just a first chapter beginner. Maybe I will reserve this Monad question for next weekend, when I am at chapter 15 of the book :)
15:10:17 <ciaranm> byrdmansniper: _ -> blah possibly? not sure i understand your question
15:10:26 <Amoeba1> Thanks all.
15:10:45 <Philippa> byrdmansniper: there is no such thing as "case variable of" switches, case statements discriminate on arbitrary expressions
15:11:02 <Philippa> > case 1 + 2 of 3 -> "Woo!"; _ -> "oh shit, the universe exploded"
15:11:04 <lambdabot>   "Woo!"
15:11:29 <Philippa> byrdmansniper: does that manage to accidentally answer your question? :-)
15:11:34 <ciaranm> > let 1 + 2 = 4 in case 1 + 2 of 3 -> "Woo!"; _ -> "oh shit, the universe exploded"
15:11:36 <lambdabot>   "oh shit, the universe exploded"
15:11:50 <Philippa> because launching missiles isn't bad enough
15:11:54 <byrdmansniper> not really, let me copy the code over
15:13:20 <Cale> byrdmansniper: What do you mean by "not receive a variable"?
15:13:50 <byrdmansniper> evalStatement :: Statement -> Memory -> Memory  827 evalStatement s m =  828         case s of  829                 Skip            ->        830                 Assign  s1      ->      (assignVar s1 m)  831                 Seq     s1 s2   ->      (evalStatement s1 m) ++ (evalStatement s2 m)  832                 If      m s1    ->      (evalStatement s1 m)  833                 While   m s1    ->      (evalStatement s1 m)
15:14:02 <byrdmansniper> the numbers are line numbers
15:14:11 <byrdmansniper> is there a way to paste it better?
15:14:12 <niteria> > let 1 + 2 = 4 in case 1 + 2 + 2 of 5 -> "Woo!"; _ -> "oh shit, the universe exploded"
15:14:14 <lambdabot>   "*Exception: <interactive>:3:5-13: Non-exhaustive patterns in function +
15:14:16 <typoclass> byrdmansniper: hello, we have hpaste available
15:14:18 <typoclass> @where hpaste
15:14:18 <lambdabot> http://hpaste.org/
15:14:22 <typoclass> ... more readable :-)
15:14:55 <niteria> I don't understand
15:15:13 <hpaste> byrdmansniper pasted “"skip" issue” at http://hpaste.org/78692
15:15:21 <monochrom> you have a line "Skip ->" and it is unfinished
15:15:40 <monochrom> and I don't know what you want to put there
15:15:45 <byrdmansniper> yes; how do i write the line since skip does not call anything or use any recieved variables
15:15:52 <niteria> oh, I see, (+) is defined locally
15:15:55 <monochrom> perhaps "Skip -> m"?
15:16:09 <typoclass> niteria: you can define functions as "let x +++ r = ... in ...". this is what you (accidentally?) did in "let 1 + 2 = 4"
15:16:19 <Peaker> The lack of (Applicative m => Monad m) relationship is so painful for me that I really wish they took the plunge and just broke things
15:16:21 <monochrom> I am also unconvinced about (evalStatement s1 m) ++ (evalStatement s2 m)
15:16:32 <Peaker> The Num breakage was not so bad at all!
15:16:58 <Philippa> Peaker: I'm inclined to agree. Announce that it's happening and be 'nice' about it, but...
15:17:00 <Peaker> Having to use Applicative.WrappedMonad all the time or passing (Applicative m, Monad m) =>  everywhere is insane
15:17:01 <byrdmansniper> it works! thanks guys
15:17:07 <rwbarton> monochrom, your computer's memory doesn't double in size each time you perform an operation?
15:17:15 <rwbarton> or two operations, rather
15:17:25 <Philippa> and don't get me started on MonadState etc when they should be effect signatures separated from whether they're part of a monad, applicative or random POS
15:17:57 <neutrino_> woop, figured out how to test IO in test-framework
15:17:58 <Peaker> Philippa, you mean add language support for "effect signatures"?
15:18:14 <Philippa> Peaker: "language support"?
15:18:29 <Philippa> I just mean factor the typeclasses so that get and put don't insist they're /monadic/ operations
15:18:34 <monochrom> haha rwbarton, that would be too good to be true, wouldn't it? if I want 8GB of RAM, I can start with 1GB of RAM, then perform three simple operations!
15:18:43 <Philippa> it's perfectly sensible to have a stateful applicative
15:18:46 <Peaker> Philippa, ah, so: Get and Put classes
15:19:06 <Peaker> Philippa, so the name and superclass constraint.. Yeah, I see, good point
15:19:07 <Philippa> no. StatefulThingy or StateFunctor rather than StateMonad
15:19:40 <neutrino_> i have a question
15:19:56 <Philippa> suffice to say that I'm writing code where (much like with parsing) wanting to stick to an applicative fragment can be exceedingly sensible...
15:20:02 <Peaker> I just avoid these classes and use concrete operations..
15:20:22 <Peaker> Philippa, Yeah, Non-monad Applicatives have popped up several times for me in the last while
15:20:27 <Peaker> Very useful
15:20:35 <neutrino_> the combination of monads + typeclasses basically allows us to define different versions of functions according to context, right? i.e. "if this code is supposed to return type m a, then look up function foo for that specific m"
15:20:46 <Peaker> One is the "lens" library which does very nice things with the Applicative-ity/non-monadness
15:21:56 <Peaker> and another is when I wanted (Writer w (Unit a))  (There's no Unit transformer, so can't represent that otherwise).  So (Writer w :. Unit) a gives me the Applicative I need, but there is no Monad to be had
15:22:00 <shachaf> lens uses State in a place where a Monad requirement is invalid, actually.
15:22:22 <Peaker> (newtype Unit a = Unit, or alternatively, Unit = Const ())
15:22:35 <shachaf> data Unit a = Unit :-)
15:22:42 <Peaker> oops :)
15:23:15 <Peaker> deriving (Functor, Applicative, Monad, Foldable, Traversable, Eq, Ord, Show) :)
15:23:29 <Peaker> derive makeBinary ''Unit  for good measure, too :)
15:24:11 <Peaker> "derive makeBinary" has been annoying lately when I wanted some "Map" things in my data types, when the key type was a type parameter.. It can't make a constrained instance, so it forces me to manually write Binary instances :(
15:24:18 <monochrom> that is getting close to buying a sandwich and getting asked what toppings you want on it
15:24:33 <monochrom> "deriving (everything except olives and onion)"
15:24:47 <neutrino_> monochrom: i hope you like capers.
15:24:59 <Philippa> see, this was the problem: I wanted to newtype derive state
15:25:19 <Philippa> because, well, monads and applicatives are something you /should/ be able to build easily like lego
15:25:30 <Philippa> and then wrap to taste
15:25:37 <Philippa> (see? Burrito!)
15:27:10 <jrajav> Burritos, legos and Haskell, together at last.
15:28:03 <BobFunk> what's the best library for sending an email over smtp?
15:28:04 <lambdabot> BobFunk: You have 1 new message. '/msg lambdabot @messages' to read it.
15:28:37 <neutrino_> in a lambda, can i somehow annotate just the argument?
15:29:23 <neutrino_> i guess i can do \(x :: Etc)
15:30:13 <neutrino_> but i have to use XScopedTypeVariables? is that a good idea?
15:30:35 <Philippa> it's one of the simpler extensions
15:31:25 <rwbarton> it only changes the meaning of your code if you are in the habit of writing explicit foralls
15:32:14 <bitonic> or if you are refining the type
15:33:28 <bitonic> well, if it typechecks before and after the annotation and the only change is the annotation, then yeah you are not changing the meaning
15:33:29 <Amoeba1> Can Haskell be used with Hadoop?
15:34:26 <aristid> Amoeba1: i'm pretty sure that should be possible, but it might be some effort on your part to get it working.
15:35:18 <neutrino_> oh there's asTypeOf
15:35:58 <neutrino_> @faq Can Haskell not be used with Hadoop?
15:35:59 <lambdabot> The answer is: Yes! Haskell can do that.
15:36:15 <rwbarton> I'm not using Haskell with Hadoop right now.
15:36:39 <neutrino_> rwbarton: thousands of people around the world not-use Haskell with Hadoop right now.
15:36:57 <Amoeba1> rwbarton: is there a reason why?
15:37:09 <monochrom> what is hadoop?
15:37:22 <neutrino_> Amoeba1: he was just joking, as an answer to my joke.
15:37:29 <Rotaerk> probably more like billions of people not-using haskell with hadoop right now...
15:37:29 <lambdabot> Rotaerk: You have 2 new messages. '/msg lambdabot @messages' to read them.
15:37:29 <rwbarton> Because, for example, I am eating dinner instead
15:37:30 <Amoeba1> Was the next biggest thing.
15:37:33 <neutrino_> haskell is good for hadoop.
15:37:40 <Amoeba1> Thanks.
15:37:51 <neutrino_> Rotaerk: billions are thousands too!
15:37:56 <neutrino_> just many more of those.
15:38:00 <Rotaerk> :P
15:38:07 <Rotaerk> millions of thousands of them
15:38:12 <Amoeba1> monochrom: http://hadoop.apache.org/
15:38:14 <monochrom> thousands are also billions.
15:38:25 <neutrino_> rwbarton: wait, does that mean we're joining you for dinner?
15:38:40 <Rotaerk> monochrom, it's not polite to talk about pieces of people
15:38:50 <monochrom> haha
15:39:27 <monochrom> in every 10 persons, 3.6 persons die a bit everyday, on average :)
15:39:30 <neutrino_> rwbarton: would you happen to have some Grey Poupon?
15:39:45 <jrajav> The average nuclear family has 2.4 kids
15:39:45 <rwbarton> Not on me
15:40:13 <jrajav> It's traumatizing to have .4 of a kid, let me tell ya
15:40:16 <neutrino_> rwbarton: i'm not into eating off bodies.
15:41:08 <Philippa> jrajav: not half as much as /being/ .4 of a kid
15:41:37 * neutrino_ just remembered the "weight loss through amputation" sketch on SNL.
15:42:16 <neutrino_> is it common to use asTypeOf to ascertain the type of an argument in a lambda?
15:43:18 <startling> heh, "If you don't understand monads, you aren't yet ready to write a Haskell compiler." http://yhc06.blogspot.com/2011/04/yhc-is-dead.html
15:43:41 <neutrino_> monads are simple, they're just co-comonads
15:44:04 <Rotaerk> oh that's all? it makes sense now !
15:44:31 <startling> coco monads.
15:45:43 <monochrom> coco avant chanel monads
15:45:52 <centrinia> co . co = id
15:46:01 <centrinia> So cocomonads are simply monads.
15:46:06 <Gunni> Is there a reason why c_connect (called from Network.Socket.connect) is imported as unsafe in the network library? It seems to be making my program freeze as other threads don't run.
15:46:12 <rwbarton> does that mean a coconut is simply a nut
15:46:30 <centrinia> rwbarton, yes.
15:46:53 <neutrino_> mind ==> mind == blown
15:47:37 <shachaf> That's cocoa reasonable explanation.
15:47:43 <startling> neutrino_: Not in scope: `==>'
15:47:52 <Squarism> I try to test the example in http://learnyouahaskell.com/zippers#taking-a-walk by cut-n-paste the statements into ghci - but i get errors mostly?
15:48:14 <shachaf> Squarism: Yes, ghci isn't a Haskell file.
15:48:31 <shachaf> Have you followed along with the rest of the book? You should've encountered this by now. :-)
15:48:38 <monochrom> Gunni: it is a known bug and fixed in newer versions. https://github.com/haskell/network/pull/64
15:49:03 <monochrom> but I don't know how new you need
15:49:07 <Squarism> shachaf, eh.. no.. im too impaticent for that =D
15:49:26 <Gunni> monochrom, 2.4.0.1 on Hackage seems to import it as unsafe.
15:49:32 <shachaf> Squarism: OK, then your question is answered in the chapters you did not read.
15:49:36 <eikke> Gunni: any chance the socket isn't set to non-blocking mode?
15:49:53 <Squarism> shachaf, doh
15:49:55 <Squarism> =D
15:50:07 <Gunni> eikke, I've been looking for a way to set it such. I seem to be blind somehow...
15:50:09 <monochrom> ok, it was fixed just a month ago. perhaps nothing is released
15:50:20 <eikke> oh, right, windows, cant help you there I'm afraid :)
15:51:05 <monochrom> the problem with all these new hipster github kids. they're so comfortable with "just do a git pull" themselves, they don't make formal releases for the rest of us
15:52:15 <typoclass> Squarism: in ghci, not everything is possible interactively. have you tried copy-pasting the code into a file and ":l file.hs" ?
15:54:25 <Peaker> Why isn't "(,) a" Traversable?
15:54:39 <eikke> monochrom: deciding when to do a formal release isnt such an easy task... especially for stuff like "network", I'd imagine
15:54:51 <eikke> (or any other package which is widely used)
15:56:29 <shachaf> Peaker: Because it's not Foldable. :-)
15:57:24 <shachaf> I don't know why. Maybe an oversight or something.
15:57:27 <shachaf> Peaker: There's always _2
15:57:52 <Peaker> shachaf, I often have:   (a, f b) and I want to convert it to: f (a, b)
15:58:11 <startling> the optparse-applicative readme tells me about a function called "addOptions". This isn't exported by Options.Applicative. Any idea where it's gone?
15:58:21 <Squarism> typoclass, ill try
15:58:23 <Peaker> @type traverseBy _2 id
15:58:24 <lambdabot>     Not in scope: `traverseBy'
15:58:24 <lambdabot>     Perhaps you meant one of these:
15:58:24 <lambdabot>       `traverse' (imported from Control.Lens),
15:58:38 <shachaf> traverseOf
15:58:39 <edwardk> traverseOf
15:58:42 <edwardk> but thats just id
15:58:42 <shachaf> Although traverseOf = id
15:58:46 <edwardk> :t _2 id
15:58:48 <lambdabot> (Functor f, Field2 s t (f b) b) => s -> f t
15:58:51 <Peaker> oops
15:59:06 <edwardk> > _2 id (1,2,3)
15:59:08 <lambdabot>   No instance for (GHC.Num.Num (f0 b0))
15:59:08 <lambdabot>    arising from a use of `e_12123'
15:59:08 <lambdabot>  P...
15:59:15 <edwardk> > _2 id (1,[2,3],4)
15:59:16 <lambdabot>   [(1,2,4),(1,3,4)]
15:59:21 <lpsmith> Does somebody know offhand how to set a CPP flag from Setup.hs?
15:59:39 <edwardk> :t sequenceOf
15:59:40 <lambdabot> LensLike (WrappedMonad m) s t (m b) b -> s -> m t
15:59:48 <edwardk> :t sequenceOf _2 (1,[2,3])
15:59:50 <lambdabot> (Num t1, Num t) => [(t, t1)]
15:59:52 <edwardk> > sequenceOf _2 (1,[2,3])
15:59:54 <lambdabot>   [(1,2),(1,3)]
16:00:07 <edwardk> > transposeOf _2 (1,[2,3])
16:00:09 <lambdabot>   [(1,2),(1,3)]
16:00:21 <Squarism> typoclass, it worked!
16:00:26 <edwardk> > transposeOf traverse [[1,2,3],[4,5,6]]
16:00:29 <lambdabot>   [[1,4],[2,5],[3,6]]
16:00:38 <lpsmith> Or,  some good way of conditionally compiling based on the output of an external command?  (in this case pg_config --version)
16:01:24 <Peaker> edwardk, nice, so I just need sequenceOf.. though I already wrote Data.Traversable.Instances for the missing tuple instance
16:01:31 <lpsmith> aight,  I found it
16:01:39 <typoclass> Squarism: ;-)
16:02:40 <shachaf> Orphan instances. :-(
16:03:15 <shachaf> Is there no name for Applicative-sequence?
16:03:30 <shachaf> Oh, sequenceA
16:03:58 <monochrom> sequence Eh!
16:04:13 <ciaranm> can Data.Array really not deal with empty arrays?
16:04:43 <lpsmith> hmm, even better would be if I could add some of my own definitions to dist/build/autogen/cabal_macros.h
16:04:47 <lpsmith> from Setup.hs
16:06:23 <monochrom> that is the problem with "(first index, last index)" as opposed to "(first index, length)". it cannot deal with empty arrays or empty ranges.
16:06:49 <monochrom> something similar in PVS pissed me off
16:07:18 <rwbarton> > listArray (1,0) []
16:07:20 <lambdabot>   array (1,0) []
16:07:24 <rwbarton> seems to work fine
16:07:41 <rwbarton> > listArray (1,-1) []
16:07:42 <lambdabot>   array (1,-1) []
16:07:50 <rwbarton> that is a little weird
16:08:26 <shachaf> > listArray (minBound::Int,minBound-1) []
16:08:27 <lambdabot>   array (-9223372036854775808,9223372036854775807) [(-9223372036854775808,*Ex...
16:08:46 <rwbarton> heh
16:09:19 <rwbarton> > listArray (minBound::Int,minBound-1) ((minBound::Int,1) : repeat undefined) !! minBound
16:09:21 <lambdabot>   Couldn't match expected type `[a0]'
16:09:21 <lambdabot>              with actual type `GHC.Arr....
16:09:25 <rwbarton> > listArray (minBound::Int,minBound-1) ((minBound::Int,1) : repeat undefined) ! minBound
16:09:27 <lambdabot>   *Exception: Error in array index; 0 not in range [0..0)
16:09:50 <rwbarton> well that is true, but...
16:10:24 <shachaf> Any code that involves minBound-1::Int is undefined behavior anyway.
16:10:35 <rwbarton> > listArray (minBound::Int,maxBound) ((minBound::Int,1) : repeat undefined) ! minBound
16:10:36 <lambdabot>   *Exception: Error in array index; 0 not in range [0..0)
16:10:51 * hackagebot xmobar 0.16 - A Minimalistic Text Based Status Bar  http://hackage.haskell.org/package/xmobar-0.16 (JoseAntonioOrtegaRuiz)
16:12:29 <ciaranm> > listArray (0, 0) []
16:12:30 <lambdabot>   array (0,0) [(0,*Exception: (Array.!): undefined array element
16:12:33 <ciaranm> confus!
16:13:01 <rwbarton> hmm?
16:13:11 <rwbarton> you didn't give it an element at 0
16:13:19 <ciaranm> oh, yeah, (0, 0) isn't empty
16:13:28 * ciaranm has been using the other programming language for too long...
16:13:52 <elliott> how do you express an empty array with Data.Array anyway
16:14:05 <ciaranm> (0, -1) [] seems to work
16:14:17 <edwardk> elliott: (0,-1) works in GHC but not some other haskell implementations
16:14:24 <elliott> joy
16:14:34 <edwardk> iirc hugs and nhc used to crap out
16:15:08 <rwbarton> then you can have m x 0 arrays for varying m
16:15:21 <rwbarton> gotta keep them straight!
16:15:44 <Squarism> ive learned that "zip" can be used to combine two lists into a list of tuples... now ive read about "Zippers" in lyah and as understand they dont really have much to do with the zip function?
16:15:59 <edwardk> Squarism: yeah the concepts are unrelated
16:16:07 <xenocons>  zipper is a datastructure afaik
16:16:15 * xenocons waits to be corrected
16:16:22 <Squarism> thanx
16:16:24 <edwardk> think of a zipper like a zipper on a coat. you can pull it down and it splits the entire structure apart as you move downward
16:16:37 <elliott> monochrom:
16:16:39 <elliott> oops
16:16:42 <elliott> typo :)
16:16:53 <edwardk> you can zip it back up and it puts the two halves back together. so i guess in that sense there is some 'zipping' going on
16:16:54 <shachaf> elliott: My "monochrom:" key is right next to my Enter key too.
16:17:02 <elliott> shachaf: i should get it removed
16:17:08 <edwardk> but its not like the 'zip' function
16:17:16 <xenocons> edwardk: unless your hands are cold and fumbly
16:17:20 <xenocons> im taking this metaphor too far
16:17:52 <edwardk> > zipper (1 :: Int) & fromWithin traverseBits & focus %~ not & rezip
16:17:54 <lambdabot>   Not in scope: `traverseBits'
16:17:54 <lambdabot>  Perhaps you meant `traverseMin' (imported fro...
16:18:00 <Squarism> Yay, ive learned myself some haskell today
16:18:02 <edwardk> > zipper (1 :: Int) & fromWithin Data.Bits.Lens.traverseBits & focus %~ not & rezip
16:18:03 <lambdabot>   Not in scope: `Data.Bits.Lens.traverseBits'
16:18:11 <edwardk> aw Data.Bits.Lens not in scope
16:18:21 <shachaf> You can't use qualified names in > anyway.
16:18:59 <edwardk> > Data.Traversable.traverse id ["why,not?"]
16:19:00 <lambdabot>   ["w","h","y",",","n","o","t","?"]
16:19:09 <shachaf> Well, that's imported explicitly.
16:19:18 <shachaf> I mean you can't refer to unimported names.
16:19:22 <edwardk> =)
16:19:27 <shachaf> @ty Unsafe.Coerce.unsafeCoerce
16:19:28 <lambdabot> a -> b
16:19:30 <shachaf> > Unsafe.Coerce.unsafeCoerce
16:19:31 <lambdabot>   Not in scope: `Unsafe.Coerce.unsafeCoerce'
16:19:38 <edwardk> i know. i was just giving you grief =)
16:19:40 <shachaf> Given a traversal how would you modify just the first element like that?
16:19:52 <`nand`> (I take it infinite zippers are not supported yet then?)
16:19:52 <shachaf> You could use partsOf but that's kind of ugly.
16:20:14 <edwardk> > "hello" & elementOf traverse 0 %~ toUpper
16:20:15 <shachaf> I guess that's what Zipper does, anyway.
16:20:16 <lambdabot>   "Hello"
16:20:21 <edwardk> > "hello" & element 0 %~ toUpper
16:20:23 <lambdabot>   "Hello"
16:20:27 <shachaf> Ah, I guess.
16:20:27 <edwardk> > "hello" & _head %~ toUpper
16:20:29 <lambdabot>   Not in scope: `_head'
16:20:29 <lambdabot>  Perhaps you meant one of these:
16:20:29 <lambdabot>    `head' (imported ...
16:20:41 <shachaf> _head is not what I'm talking about. :-)
16:20:42 <edwardk> > "hello" & upon head %~ toUpper
16:20:44 <lambdabot>   "Hello"
16:20:50 <xenocons> upon?
16:20:57 <edwardk> upon is magic
16:21:00 <xenocons> :t upon
16:21:01 <lambdabot> (Data.Data.Data s, Typeable a, Applicative f, Indexed Int k) => (s -> a) -> k (a -> f a) (s -> f s)
16:21:15 <shachaf> `nand`: Infinite zippers are fine.
16:21:16 <edwardk> > "jello" & upon last .~ 'y'
16:21:18 <lambdabot>   "jelly"
16:21:32 <xenocons> upon sounds like a really good match for text stemmers
16:21:34 <shachaf> `nand`: Infinite traversals of strict types are a problem.
16:21:53 <xenocons> @src upon
16:21:53 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
16:22:07 <shachaf> upon is not a good match for anything. :-(
16:22:18 <xenocons> why?
16:22:21 <edwardk> http://hackage.haskell.org/packages/archive/lens/3.6/doc/html/src/Data-Data-Lens.html#upon
16:22:29 <edwardk> xenocons: it does evil things to make itself work
16:22:29 <xenocons> ty
16:22:32 <xenocons> ah
16:22:50 <shachaf> > "jello" & _last .~ 'y'
16:22:52 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
16:22:52 <lambdabot>              with actual ty...
16:22:53 <xenocons> i guess the type 'Typeable' should sound alarm bells?
16:23:19 <edwardk> > "hello" & uponTheDeep (tail.tail) .~ "y there"
16:23:21 <lambdabot>   "hey there"
16:23:41 <xenocons> there is a mind boggling ammount of functions in haskell :<
16:23:53 <shachaf> xenocons: This is in "lens", not in the standard library.
16:23:55 <edwardk> xenocons: this is in a particular library of mine, not general haskell ;)
16:23:57 <shachaf> @let _lastish f [] = []; _lastish f xs = (\x' -> init xs ++ [x']) <$> f (last xs)
16:23:59 <lambdabot>  Defined.
16:24:00 <xenocons> ahhh
16:24:00 <xenocons> heh
16:24:08 <shachaf> > "jello" & _lastish .~ 'y'
16:24:09 <lambdabot>   Couldn't match expected type `Control.Lens.Internal.Mutator b0'
16:24:09 <lambdabot>            ...
16:24:31 <shachaf> Oops.
16:24:33 <edwardk> xenocons: i wouldn't consider upon to be indicative of a style of function you should use in general, its mostly good for showing off on lambdabot ;)
16:24:35 <shachaf> @ty _lastish
16:24:37 <lambdabot> (a -> [a]) -> [a] -> [[a]]
16:24:40 <xenocons> no wonder i just had a horrible sinking feeling that i wasnt even scratching the surface..
16:24:46 <shachaf> @undefine
16:24:50 <xenocons> edwardk: experimentation, i like it
16:24:54 <startling> is there a way to have a module used only in a specific executable with cabal?
16:24:55 <elliott> rename upon to augh
16:24:57 <shachaf> @let _lastish f [] = pure []; _lastish f xs = (\x' -> init xs ++ [x']) <$> f (last xs)
16:24:58 <lambdabot>  Defined.
16:25:01 <shachaf> > "jello" & _lastish .~ 'y'
16:25:02 <lambdabot>   "jelly"
16:25:16 <edwardk> elliott: upon is now 'onceUpon' and 'uponTheDeep' is now 'upon'
16:25:19 <startling> :t _lastish
16:25:21 <lambdabot> Applicative f => (a -> f a) -> [a] -> f [a]
16:25:26 <xenocons> i did chuckle at uponTheDeep
16:25:28 <elliott> onceUpon can become auuugh
16:25:29 <edwardk> that way we get fewer errors from people reaching for the one with the short name
16:25:34 <xenocons> lol
16:25:36 <edwardk> elliott++
16:25:51 <shachaf> edwardk: Now we need to export aTime = view
16:25:58 <shachaf> Such that onceUpon (aTime l) = l
16:25:59 <`nand`> oneUpon aTime
16:26:02 <`nand`> once*
16:26:08 <`nand`> ah
16:26:11 <edwardk> heh
16:26:11 <`nand`> shachaf was faster
16:26:43 <xenocons> im up to recursion in learn you a haskell, its been very breezy using ghci so far
16:26:43 <rwbarton> edwardk, i like it
16:26:49 <xenocons> wonder when traversables will come up
16:26:55 <`nand`> I looked at the source code and I have absolutely no idea how ‘upon’ works
16:27:02 <edwardk> rwbarton: upon?
16:27:03 <`nand`> what kind of blasphemous magic it uses
16:27:08 <rwbarton> the new names
16:27:24 <startling> like, I have an executable that has a dependency that the associated library doesn't share. I'd like to separate that executable into a number of files. How could I do that?
16:28:01 <xenocons> :t sybChildren
16:28:02 <lambdabot> Not in scope: `sybChildren'
16:28:04 <startling> the executable's source, I mean, of course.
16:28:42 <xenocons> how much of okazakis purely functional data structures does haskell core implement?
16:28:45 <edwardk> `nand`: uponTheDeerp basically takes your value of type s and a function (s -> a) uses biplate to replace all the 'a's in your s with exceptions, tries your function on that, figures out which exception fired, then takes that 'a' and uses 'uniplate' to drill deeper, replacing all the a's within that a with exceptions until it can't drill deeper
16:28:50 <edwardk> xenocons: very few
16:29:01 <edwardk> xenocons: there was a library 'edison' with a lot of okasaki structures in it
16:29:05 <`nand`> > zipper (1 :: Int) & fromWithin bits & focus %~ not & rezip
16:29:07 <lambdabot>   0
16:29:11 <`nand`> that was renamed
16:29:13 <xenocons> edwardk: why isnt it more popular?
16:29:22 <`nand`> edwardk: oh
16:29:28 <xenocons> did the ideas just evolve into something better, or was it just disregarded entirely
16:29:30 <`nand`> edwardk: that's.. an interesting approach
16:29:36 <`nand`> edwardk: and surely that involves unsafePerformIO?
16:29:40 <edwardk> `nand`: once it has found the last 'a' that trips the exception, that is the location it returns.
16:29:40 <edwardk> `nand`: this sounds really slow, but its O(n) for the list.
16:29:50 <edwardk> `nand`: yes
16:29:59 <edwardk> and Data and general craziness
16:30:14 <shachaf> > (0::Int) & elementsOf bits even .~ True
16:30:16 <lambdabot>   6148914691236517205
16:30:17 <edwardk> xenocons: not that its disregarded, just that we don't use many banker queues, etc. in practice
16:30:26 <startling> heh
16:30:28 <shachaf> > (0::Int) & elementsOf bits odd .~ True
16:30:30 <lambdabot>   -6148914691236517206
16:30:45 <`nand`> :t elementsOf
16:30:45 <edwardk> xenocons: we evolved 'fingertrees' since okasaki, which obviates the need for a lot of his structures in practice
16:30:46 <lambdabot> (Applicative f, Indexed Int k) => LensLike (Control.Lens.Internal.Indexing f) s t a a -> (Int -> Bool) -> Overloaded k f s t a a
16:31:12 <edwardk> they are a better purpose general data structure than most of his. but that said, i use brodal-okasaki heaps in my 'heaps' package for instance.
16:31:28 <xenocons> edwardk: fair enough, ill have to look up fingertrees, some guys have been working on porting a lot of haskell\okazakis structures into fsharpx
16:31:30 <edwardk> they are bootstrapped skew-binomial heaps
16:31:45 <xenocons> cool
16:31:53 * startling bootstraps edwardk and skews his binomial
16:31:54 <xenocons> in this 'lens' package?
16:32:02 <edwardk> the heaps? no those are in 'heaps'
16:32:05 <edwardk> @hackage heaps
16:32:05 <lambdabot> http://hackage.haskell.org/package/heaps
16:32:11 <xenocons> oh right
16:33:32 <edwardk> xenocons: http://comonad.com/reader/2010/finger-trees/ is a bunch of slides from a talk i gave on fingertrees. http://www.soi.city.ac.uk/~ross/papers/FingerTree.pdf is the original paper
16:33:44 <edwardk> they do a good job of describing why its cool to annotate trees with monoids
16:33:59 <xenocons> cool, i will look at both, edwardk you seem to be rather famous :)
16:34:31 <startling> Oh, other-modules works. duh.
16:34:51 <edwardk> i write a lot of code
16:34:58 <xenocons> awesome
16:35:29 <cmccann> edwardk, and then trick other people into taking responsibility for it after you move on to the next thing, right?
16:35:38 <startling> haha
16:35:42 <edwardk> cmccann: i only did that to a couple of people ;)
16:35:47 <edwardk> everyone else wised up after that
16:35:50 <cmccann> haha
16:35:54 <edwardk> thats why i maintain so many packages ;)
16:35:58 <startling> cmccann, until he goes back and renders them obsolete!
16:36:13 <edwardk> and yeah, i gave data-lens to roconnor and then killed it with lens ;)
16:36:19 <cmccann> haha
16:36:28 <edwardk> my other efforts to hand stuff off have been even less successful
16:36:46 * cmccann should probably stop habitually using data-lens one of these days
16:36:54 <edwardk> i guess dmwit capstoned category-extras with the 'where the heck did it all go' package at 1.0
16:36:54 <edwardk> cmccann: yes, lens is cooler
16:36:58 <byrdmansniper> how exactly do you write a if-then-else on one line?
16:36:58 <xenocons> question, why does the representation of polymorphic type parameters differ between haskell and ocaml\sml ?
16:37:06 <cmccann> there's also the category-extras stuff but nobody actually uses that so it hardly counts
16:37:09 <elliott> if a then b else c
16:37:19 <byrdmansniper> thanks
16:37:28 <romildo> What is the precedence of the type annotation operator :: ?
16:37:30 <edwardk> xenocons: because we don't like their syntax, and ours is closer to what miranda was doing, in terms of argument position
16:37:35 <xenocons> i mean, semantically the same but 'a vs a
16:37:41 <cmccann> because Haskell has a lot of non-ML-ish syntax for reasons
16:37:53 <cmccann> also names
16:37:57 <edwardk> I would hardly consider ML syntax to be a goal to aspire to ;)
16:38:01 <mauke> romildo: almost lowest
16:38:01 <xenocons> well, haskell is cleaner in its representation...
16:38:05 <cmccann> e.g. Maybe vs. Option
16:38:10 <xenocons> but ultimately it feels like ML to me
16:38:22 <xenocons> (im onlyscratching the surface)
16:38:32 <xenocons> also, horrible latency atm
16:39:14 <xenocons> its probably because you can see the influence of ML in haskell
16:39:25 <cmccann> well, Haskell is not an ML dialect and that's really all there is to say on the matter
16:39:45 <xenocons> so you wouldn't say haskell is a ML?
16:39:50 <cmccann> but there's a closer relationship than to anything else
16:39:57 <xenocons> (just they share some similarities)
16:39:57 <Philippa> xenocons: it's a cousin
16:39:57 <xenocons> right
16:40:00 <bitonic> cmccann: Haskell and ML are very much related
16:40:02 <edwardk> haskell puts a lot more emphasis on polymorphism in part due to 'constructor classes' needing variables in lots of places ML traditionally didn't put them, but in general the direct linguistic ancestor of Haskell is a language named Miranda, not ML.
16:40:11 <romildo> mauke, can it be told precisely which is the precedence of :: ?
16:40:27 <xenocons> didnt miranda stem from ML though? (im not trying to flame)
16:40:30 <cmccann> Haskell is an ML dialect like Java is a C++ dialect
16:40:35 <Philippa> xenocons: from ISWIM
16:40:44 <bitonic> and KRC (was it KRC?)
16:40:44 <xenocons> oh,
16:40:48 <bitonic> something with initials.
16:40:51 <xenocons> if you see what i mean, or something
16:40:58 <monochrom> maybe you could say, haskell is a lazy ml
16:41:02 <Philippa> "I see what I mean(!)"
16:41:07 <xenocons> heh
16:41:23 <Philippa> monochrom: except that the relationship between type classes and modules is an even bigger deal
16:41:30 <edwardk> xenocons: sure. but miranda and haskell's syntax make a lot of conscious breaks with ML syntax. laziness obviates the need for fun and val keywords. you don't need to explicitly group, let rec can be the default, etc.
16:41:33 <Philippa> yeah, you can build Haskell as a diff from a "lazy miniML", sure
16:41:42 <bitonic> well Lazy ML is an actual language :P
16:41:54 <Philippa> bitonic: yep. It's not as ML-like as you might expect though, IIRC
16:41:58 <xenocons> yeah there is lazy extensions to SML though
16:42:06 <xenocons> $ i think is the operator heh
16:42:11 <xenocons> edwardk: right
16:42:21 <bitonic> xenocons: I was talking about the language by Augustsson
16:42:32 <xenocons> bitonic: i haven't seen it
16:42:39 <xenocons> (i will now)
16:43:28 <bitonic> xenocons: the first Haskell compiler was actually implemented in LML
16:43:38 <xenocons> edwardk: ive always had a bit of fence sitting with fun vs let vs val etc
16:43:43 <monochrom> the first ML was implemented in Lisp
16:43:51 <xenocons> bitonic: cool, i just read that on the wikipedia page
16:44:02 <edwardk> xenocons then it should be nice to know you don't have to care about the distinction any more ;)
16:44:51 <xenocons> it is nice, and i think ultimately i will prefer the haskell way of handling it, atm i have a bit of confusion around the use of let binding in haskell though
16:44:59 <cmccann> the few times I've tried doing stuff in an ML dialect it felt clumsy and ugly compared to Haskell. :T mostly a matter of taste I guess.
16:45:09 <xenocons> (im coming from a language where almost EVERYTHING is a let binding)
16:45:36 <edwardk> let is solely used for 'letrec' purposes. to order effects you 'do' stuff in the IO monad.
16:45:53 <xenocons> hm, but i have seen let bindings inside functions in haskell
16:46:00 <mauke> let it = b
16:46:12 <xenocons> and you can use them inside comprehensions too
16:46:13 <edwardk> yes, lets just binding a name for something, not sequencing effects
16:46:14 <xenocons> apparently
16:46:19 <xenocons> ahh
16:46:20 <cmccann> xenocons, for the most part, think of the simplest interpretation of what a "let" expression does and that's probably how it works in Haskell :P
16:46:39 <xenocons> cmccann: gives a name to a function =p
16:46:39 <cmccann> modulo some details that beginners can ignore
16:46:50 <mauke> xenocons: s/function/value/
16:47:17 <edwardk> > let x = 2 in x + x
16:47:19 <lambdabot>   4
16:47:30 <edwardk> just makes it easy to refer to it twice (and helps enforce sharing)
16:47:37 <startling> > let 2 + 2 = 5 in 2 + 2
16:47:38 <edwardk> > let ones = 1 : ones in ones
16:47:39 <lambdabot>   5
16:47:40 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
16:47:51 <edwardk> startling: not helpful =P
16:47:55 <startling> hehe
16:48:08 <xenocons> a value is a function
16:48:15 <cmccann> > let 2 + 2 = "math is broken!" in 2 + 2
16:48:16 <c_wraith> other way around
16:48:17 <lambdabot>   "math is broken!"
16:48:21 <monochrom> a lot of people are unable to think of the simplest interpretation or simplest whatever
16:48:23 <c_wraith> functions are values
16:48:31 <c_wraith> not all values are functions
16:48:32 <xenocons> hmm
16:48:46 <xenocons> cmccann: i figured functions and values are exactly the same things ?
16:49:04 <startling> xenocons: you can't call any value.
16:49:11 <c_wraith> > () ()
16:49:13 <lambdabot>   The function `()' is applied to one argument,
16:49:13 <lambdabot>  but its type `()' has none
16:49:30 <c_wraith> heh.  That's a confusing error message, for this case
16:49:31 <monochrom> > let "math is broken" = 2+2 in 2+2
16:49:32 <lambdabot>   No instance for (GHC.Num.Num [GHC.Types.Char])
16:49:33 <lambdabot>    arising from a use of `GH...
16:49:38 <mauke> > (\() -> ()) () ()
16:49:39 <lambdabot>   The function `\ () -> ()' is applied to two arguments,
16:49:39 <lambdabot>  but its type `() ->...
16:49:56 <c_wraith> > let f = () in f ()
16:49:56 <xenocons> > (\x -> ())
16:49:57 <lambdabot>   The function `f' is applied to one argument,
16:49:57 <lambdabot>  but its type `()' has none
16:49:57 <lambdabot>   can't find file: L.hs
16:50:14 <xenocons> > (\x -> ())
16:50:15 <lambdabot>   *Exception: show: No overloading for function
16:50:18 <c_wraith> I kinda think that's a bad error message from the typechecker
16:50:20 <xenocons> > (\x -> ()) 0
16:50:22 <lambdabot>   ()
16:50:35 <djahandarie> > fix 3
16:50:37 <lambdabot>   3
16:50:51 <FireFly> > break 8
16:50:53 <lambdabot>   No instance for (GHC.Num.Num GHC.Types.Bool)
16:50:53 <lambdabot>    arising from the literal `8...
16:50:57 <djahandarie> > fix math where math = 2+2
16:50:58 <lambdabot>   <hint>:1:10: parse error on input `where'
16:51:00 <startling> :t \n -> fix (n + 1)
16:51:01 <xenocons> > (\x -> ()) id
16:51:01 <lambdabot> Num a => (a -> a) -> a
16:51:02 <lambdabot>   ()
16:51:08 <cmccann> c_wraith, it's not that bad except in the context of "is everything a function" discussions
16:51:20 <monochrom> "where" cannot be part of an expression
16:51:24 <c_wraith> which, unfortunately, this is
16:51:26 <djahandarie> Yes yes
16:51:37 <FireFly> @ty break
16:51:39 <lambdabot> (a -> Bool) -> [a] -> ([a], [a])
16:51:44 <startling> I think the confusion is usually that "nullary functions" in most languages are a way of controlling evaluation order.
16:51:45 <FireFly> Ah, right
16:51:50 <monochrom> although, Landin is turning in his grave for this!
16:52:16 <xenocons> nullary functions?
16:52:28 <startling> xenocons, in haskell there's no such thing.
16:52:32 <edwardk> xenocons: the habit in ML of making a function from ()
16:52:47 <edwardk> xenocons: which is a mostly unnecessary habit in haskell due to laziness
16:52:50 <monochrom> @quote 17-ary
16:52:51 <lambdabot> monochrom says: I am 17-ary, going on 18-ary, I can take curry of you
16:52:58 <cmccann> heh
16:53:17 <xenocons> edwardk: ah, like having unit as a function arument so that it isnt bound until called?
16:53:19 <startling> monochrom, do you have all your jokes memorized? if so, why do you need @quote?
16:53:21 <xenocons> argument*
16:53:36 <cmccann> we should use the -adic terms instead of -ary, to promote more extensive confusion
16:53:46 <edwardk> xenocons: yes. since we don't have side-effects in general. this 'doesn't happen until called' distinction is all rather silly
16:53:50 <monochrom> I am lazy. typing @quote is less work
16:53:58 <startling> haha
16:54:00 <edwardk> > let ones () = 1 : ones () in ones ()
16:54:01 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
16:54:07 <xenocons> i usually use '_' as a parameter for my forced lazyness
16:54:07 <edwardk> > let ones = 1 : ones in ones
16:54:08 <cmccann> startling, no, monochrom has just made jokes about everything so he asks for a quote on the topic at hand :P
16:54:09 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
16:54:35 <xenocons> edwardk: this is going to be a hurdle for me when it comes to network IO i think
16:54:49 <xenocons> (a hurdle as in, something i will find difficult learning the correct way)
16:54:54 <edwardk> the version we derive without the _ parameter is even better than the one you get with it. because it is cal by need so it 'ties the knot' and gets sharing.
16:55:23 <edwardk> by the time you get to network IO, you'll understand the IO monad well enough to note why things work this way ;)
16:55:37 <xenocons> ah, heh, like enlightenment
16:55:43 <xenocons> you will know it when you know it!
16:56:09 <edwardk> Network IO in haskell is the sound of one hand clapping.
16:56:36 <xenocons> IO is the thorn in the functional programmers side (or so ive believed so far)
16:56:50 <xenocons> interested to see how haskell solves it
16:56:58 <edwardk> IO is a perfectly reasonable tool in your toolbox. It doesn't mean its the only tool in the box though.
16:57:54 * Philippa tries to decide if she's too tired to write Yet Another H-M Typechecker while she's waiting for her gf to get home (her home, not mine)
16:58:19 <xenocons> IO is that specific allen hole that you never have an allen key for, and you end up tryin to use a screwdriver and making a mess of it
16:58:58 <xenocons> tbh there is nothing more frightening than a -> ()
16:58:59 <startling> can the "yaml" package on hackage deal with directives like "!!binary"? it seems like it's mostly aeson-based, so I'm not sure.
16:59:00 <xenocons> lol
16:59:12 <xenocons> its like falling into a black abyss
16:59:19 <edwardk> xenocons: fortunately in haskell that is about the safest thing you can have ;)
16:59:21 <c_wraith> :t const ()
16:59:22 <lambdabot> b -> ()
16:59:25 <rwbarton> that package uses FFI to a C yaml library as I understand it
16:59:28 <c_wraith> whew.  b.  we're safe!
16:59:31 <tac> xenocons: I find functions *from* an empty type to be even scarier!
16:59:31 <edwardk> xenocons: since it can't have any effects for the most part
16:59:45 <startling> rwbarton: yeah, but it has a high-level interface based on aeson's types
16:59:52 <monochrom> IO is both salad and burrito. http://www.vex.net/~trebla/photo/unorganized/burrito-salad.jpg
16:59:53 <xenocons> tac: thats true heh
16:59:54 <rwbarton> yeah, so i don't know what it would hand you then
17:00:02 <rwbarton> when I tried using it it behaved pretty oddly on numbers
17:00:06 <xenocons> well actually, there are scarier things
17:00:20 <c_wraith> unsafeCoerce is the scariest type
17:00:21 <startling> is there any other yaml thing?
17:00:39 <xenocons> there are older and fouler things than Unit in the deep places of the world
17:01:03 <edwardk> xenocons: in haskell since you don't have side-effects without marking things with a monad (or doing stupid unsafePerformIO-like things), (a -> ())  is just a function that takes its argument, maybe forces it, and gives you back () or some error. ;) when you inspect the ().
17:01:07 <startling> part of the reason this is annoying is that I want to use yaml because json doesn't have a way to specify binary data. :/
17:01:22 <xenocons> edwardk: right
17:01:43 <edwardk> a -> IO () is our version of your lovecraftian horror
17:01:53 <xenocons> ah
17:02:04 <xenocons> IO is some state related change?
17:02:17 <c_wraith> IO is "unleash the horrors of the universe"
17:02:19 <elliott> IO has nothing to do with state and don't let anyone tell you otherwise :P
17:02:29 <xenocons> heh
17:02:32 <edwardk> to have effects, like printing, or editing a reference, or what have you, you need to be inside the IO monad.
17:02:36 <elliott> well, IO lets you keep mutable state among other things
17:02:40 <elliott> but that's a different thing
17:02:46 <tac> IO is leaving anything you can formally prove about a program.
17:02:51 <monochrom> IO is I/O. and some other imperative features
17:03:03 <xenocons> so the IO monad threads state ?
17:03:04 <tac> and trying to package it up into a toxic waste bin
17:03:06 <cmccann> regarding IO and Lovecraft: http://lambda-the-ultimate.org/node/3893#comment-58299
17:03:09 <elliott> xenocons: no!
17:03:12 <elliott> that's the state monad
17:03:13 <edwardk> IO is a little imperative language embedded in haskell
17:03:17 <xenocons> okay
17:03:19 <tac> xenocons: sorta... kinda.... it does other things, too
17:03:42 <xenocons> haskell is the best OOP and imperative language there is
17:03:48 <monochrom> I don't see why you need another IO story than "I/O" or "imperative stuff"
17:04:01 <edwardk> xenocons: the IO monad threads 'the world' through your code nominally, not state per se. that said this abstraction leaks when you have multiple threads, since they are each talking about the same world ;)
17:04:11 <xenocons> cmccann: i will read that, usually LtU is beyond me though
17:04:13 <Philippa> xenocons: dunno about OOP. It does some message passing models pretty well via embedded langs though
17:04:28 <xenocons> Philippa: well you can just write your own OOP model as a DSL right
17:04:36 <monochrom> no one says that ML or Java "threads state". so why suddenly Haskell's IO does?
17:04:39 <edwardk> and with lens we're getting pretty good at objects and inheritance-style stuff
17:04:51 <xenocons> edwardk: i see
17:04:52 <edwardk> monochrom: good point
17:04:57 <xenocons> that makes sense
17:05:22 <xenocons> threading to me is like dragging an accumulator through a fold
17:05:25 <edwardk> if you just think of IO as 'sequenced actions that can interact with the world' you're good
17:05:43 <xenocons> edwardk: okay
17:05:43 <Philippa> edwardk: I still really need to have a play. When I'm not busy writing my multityped constraint programming lib and/or tests for it, anyway
17:05:46 <edwardk> xenocons: we have the State monad if that is all you need.
17:05:57 <xenocons> im going to read that alloud before bed each night ;)
17:06:08 <edwardk> xenocons: the state monad has the benefit of being completely pure, too.
17:06:13 <Philippa> (I now have an H-M checker! Too bad the constraint lang for it still needs to know what 'instantiate', 'generalise' and 'mtEquals' mean)
17:06:34 <xenocons> edwardk: im not sold on purity yet
17:06:37 <edwardk> newtype State s a = State { runState :: s -> (a, s) }  -- would be a perfectly cromulent monad to write.
17:06:49 <Philippa> (but I figure that's a couple of handfuls of LoC I didn't have to write today)
17:06:52 <startling> bah, maybe I just won't deal with the binary data
17:06:55 <jmcarthur> xenocons: purity is a hard sell at first, but then it's hard to give up
17:06:59 <edwardk> you have a function that takes a starting state, and gives you back a value, and a new state.
17:07:07 <edwardk> you can chain these together.
17:07:10 <edwardk> that forms the monad
17:07:11 * Amoeba1 offers $100 purity bonds for state monad at 200% face value. 
17:07:22 <Philippa> xenocons: purity is great. Lets me do screwy continuation-flavoured stuff without worrying about it being messed up by /other/ screwy continuation-flavoured stuff
17:07:22 <startling> ugh, but json doesn't do hex literals. :/
17:07:33 <startling> Philippa: hahaha
17:07:44 <xenocons> well, ive always felt so far that purity where you need is is great, but part of a languages advantage \ power is in encapsulating impureness to the benefit of sanity
17:07:49 <edwardk> you can lift a pure value into the state monad.   a -> State s a        this is just 'return a = State (\s -> (a, s)) for the state monad
17:08:10 <Philippa> xenocons: right. If there is an impure region of a program that can have a pure interface, you still get that
17:08:12 <xenocons> i think loving purity might come to me once i get the language more
17:08:17 <edwardk> xenocons: to me the benefit of being pure by default is that you can embed little languages where you know there are no side-effects.
17:08:19 <Philippa> it's just that you have to admit how far the impurity leaks
17:08:34 <Philippa> edwardk: wait, you mean my typechecker won't nuke anybody?!
17:08:35 <edwardk> xenocons: for example in haskell. you can rely on laws you couldn't dream of safely in ML. take 'map'
17:08:58 <edwardk> if you have some list and you go to map a function over a list and then map another function over that list.
17:08:58 <Philippa> (might be useful if I'm doing a backtracking search for a suitable solution...)
17:09:19 <edwardk> > map (+1) (map (*2) [1..10]
17:09:21 <lambdabot>   <hint>:1:27: parse error (possibly incorrect indentation)
17:09:21 <edwardk> > map (+1) (map (*2) [1..10])
17:09:24 <lambdabot>   [3,5,7,9,11,13,15,17,19,21]
17:09:26 <xenocons> right
17:09:39 <edwardk> > map ((+1).(*2)) [1..10])
17:09:40 <lambdabot>   <hint>:1:24: parse error on input `)'
17:09:42 <edwardk> > map ((+1).(*2)) [1..10]
17:09:44 <lambdabot>   [3,5,7,9,11,13,15,17,19,21]
17:09:56 <Philippa> edwardk: also the version with tupling instead of composition!
17:09:59 <xenocons> so the . is function composition here
17:10:11 <edwardk> we can fuse together maps safely.  map f . map g = map (f . g) is a law that follows just from the law map id = id and parametricity
17:10:18 <edwardk> yes
17:10:36 <edwardk> in ML you always have to worry about the fact that that would shuffle your effects
17:10:36 <xenocons> but wouldnt this also share the same identity in ML?
17:10:54 <Philippa> only in an effectless ML
17:10:56 <edwardk> xenocons: you'd have to worry that the user might be editing a reference or something
17:11:03 <xenocons> hmm
17:11:13 <xenocons> ive never encountered the need to think about this
17:11:21 <Philippa> edwardk: or inverting the control flow of your list traversal Oleg-style!
17:11:26 <edwardk> xenocons: you probably have, you just haven't known it ;)
17:11:36 <Amoeba1> Philippa: Thanks for the code snippet. It's good code for a beginner to be exposed to.
17:11:40 <Philippa> mmm. Often what you encounter is your foot hurting
17:11:53 <xenocons> edwardk: i haven't written code that anyone but me has used i dont think ;)
17:12:19 <xenocons> i still don't understand how editing a reference can change the outcome
17:12:24 * Amoeba1 is falling deeply in love with Haskell ...
17:12:37 <Amoeba1> My precious ....
17:12:39 <edwardk> xenocons: this 'purity by default' turns out to be a very powerful tool. there are things we can write in Haskell that you just can't write in say C# or an ML-like language with effects. One example is "STM". We _need_ the fact that there aren't side-effects to reason about STM.
17:13:18 * startling sigh. He just wants a structured data format that lets him specify that a number be written as a hex literal and lets him output potentially base64-encoded binary data.
17:13:29 <monochrom> in ML, define f x = print "a", g x = print "b". then (map f . map g) has a different output from (map (f . g))
17:13:30 <xenocons> stm as in threading?
17:13:38 <edwardk> STM is 'software transactional memory'. The idea is that in general, locks as they exist in the imperative world suck because they aren't compositional. if you take two functions written using the same locks and prove that those functions in isolation will not deadlock, the composition of those two functions executing one after another _can_ deadlock.
17:13:39 <hpc> xenocons: a decent chunk of haskell can be explained by "it's not about what you can't do, it's about what you know for certain is never going to happen"
17:13:51 <xenocons> right
17:13:55 <cmccann> yeah, STM was "hey, we'll toss this in" for Haskell, in most other languages STM implementations end up crippled or failed completely
17:13:57 <edwardk> so the deadlock-freeness of your java-style program requires you to reason about the entire program all the time.
17:13:58 <dsantiago> edwardk: Can you explain that? Clojure also has STM…
17:13:59 <xenocons> whoah ok let me read
17:14:03 <monochrom> and if you say, ignore output, you just care about return values, I can cook up an example for that too
17:14:33 <edwardk> dsantiago: and you can launch missiles in the middle of an STM transaction obviating the safety guarantee ;)
17:14:40 <cmccann> clojure emphasizes immutability to a large extent
17:14:48 <cmccann> based on what I've seen written about it, at least
17:14:50 <Amoeba1> Do people begin to use Haskell structures in other languages too?
17:14:57 <edwardk> as long as you stick to the culture of immutable structures its fine there
17:14:58 <cmccann> and it had STM added at a very early stage
17:14:59 <startling> Amoeba1: how do you mean?
17:15:02 <Amoeba1> I mean is that a natural effect?
17:15:09 <monochrom> yes
17:15:24 <dsantiago> edwardk: OK, so what you were saying was it could enforce the safety. I can see that.
17:15:29 <Amoeba1> startling:  as in you learn Haskell and it rubs off on your c programming style ...
17:15:37 <Amoeba1> monochrom: thanks.
17:15:40 <xenocons> whoah
17:15:43 <mauke> startling: why do you want hex and base64?
17:15:43 <hpc> Amoeba1: i had to write some code in perl that ultimately ended up being State (output, input -> IO output) ()
17:15:46 <monochrom> and the natural effect after that is pain, since using Haskell structures in other languages is not so easy
17:15:47 <xenocons> okay
17:15:51 <dsantiago> Clojure has a macro you can wrap code in called io!, which will throw an error if you try to use it during an STM transaction. But of course, nothing forces you to use it.
17:16:04 <Philippa> Amoeba1: um, no problem. Have to admit, I've forgotten what snippet I showed you
17:16:17 <Amoeba1> hpc: :)
17:16:21 <monochrom> so the third natural effect is writing a blog to say "don't learn haskell, you'll be depressed when you get back to work"
17:16:29 <Amoeba1> Philippa:  it was map (a.b) code.
17:16:57 <xenocons> i dont program for $ so i dont mind learning haskell
17:16:58 <Amoeba1> monochrom: lol possble.
17:17:00 <edwardk> with STM what you do is instead of grabbing a lock you say 'i want to do this atomically' and read or write to variables. as it runs it reads the current value, logs what it read and proceeds apace. when it goes to commit at the end of the transaction it grabs all the locks for all the variables it read in order (or uses lockfree techniques) and checks that they all have the right values, and then commits.
17:17:24 <edwardk> if you could have side-effects along the way then you risk checking that one key was turned, and the other was turned and launching missiles before the transaction was complete.
17:17:31 <Philippa> Amoeba1: ah. Yeah, I can't remember the last time I was the one doing that talk :-)
17:17:33 <Amoeba1> So everyone here is lying about the side-effects!
17:17:58 <xenocons> monochrom: regarding your ML example, i think i get this, but i assumed that is just the behaviour of map :(
17:17:58 <edwardk> the ability to roll-back and start over with an STM transaction is -key- to it being a viable implementation technique and you can't rollback launching the missiles or printing to the screen
17:17:58 <Amoeba1> Haskell has side-effects!
17:18:07 <c_wraith> would any code anywhere break if ghc switched its stm implementation to mvcc?
17:18:32 <xenocons> i thought, well of course map f >> map g is <> map (f >> g)
17:18:43 <xenocons> sorry '.' in haskell
17:18:43 <slack1256>  /part
17:19:22 <edwardk> re haskell mvcc the actual implementation is smarter than what i described
17:19:45 <xenocons> so in haskell, (map f . map g) == (map (f .g))
17:19:49 <cmccann> edwardk, there's even a movie about being unable to rollback launching the missiles!
17:20:03 <edwardk> xenocons: yes
17:20:09 <xenocons> wow ok
17:20:19 <xenocons> thats going to trip me up
17:20:20 <edwardk> xenocons: you can reason about that equationally
17:20:27 <hpc> cmccann: a curious game; the only winning move is to callCC
17:20:34 <edwardk> xenocons: this means it is always safe to 'fuse' passes
17:20:41 <edwardk> xenocons: this is a big deal in our world ;)
17:20:45 <xenocons> edwardk: right, it also means it is a lot more predictable
17:20:51 <cmccann> hpc, was thinking of a different movie actually :P
17:20:51 <xenocons> in terms of having just one rule
17:20:54 <xenocons> as opposed to many
17:21:15 <startling> xenocons: it also means you can have one function that does a map and compose it with another function that does a map and not need to iterate over the list twice.
17:21:26 <startling> so you get more compositionality.
17:21:31 <xenocons> right, that is definetly an advantage
17:21:34 <cmccann> xenocons, stuff like that compounds as well--lots of simple equivalences that are guaranteed, it adds up to a surprising amount of stuff you don't have to worry about
17:21:38 <xenocons> definitely
17:21:41 <edwardk> xenocons: this actually is more general than map, we have 'fmap' which describes how to map over any kind of 'Functor' (a sort of container) no relation to the ML concept by the same name and this law applies to all of them
17:21:43 <cmccann> which makes it easier and more pleasant to concentrate on the stuff that matters
17:22:06 <xenocons> edwardk: yeah i figured if it works for once case the abstraction is equivilant
17:22:25 <xenocons> (i mean, it has to be)
17:22:34 <xenocons> if it wernt, the model would be broken i think
17:22:48 <edwardk> in general i find it is a very pleasant experience to refactor in haskell. in other languages i find that the functions i put somewhere 'stick' you can't move them over another function without a lot of reasoning. it is much more fluid to slide things around in haskell.
17:23:29 <edwardk> moreover, the absence of side-effects and the strong type system let me still have a high degree of confidence that the program is correct when i'm done moving things around
17:24:08 <xenocons> well, im... highly interested in the 'if it compiles it works' thing (kinda what got me into functional languages)
17:24:18 <xenocons> i hadn't considered 'if it compiles it is correct' heh
17:24:40 <edwardk> xenocons: that thinking works a lot better the more abstract your types get
17:24:42 <edwardk> :t const
17:24:44 <lambdabot> a -> b -> a
17:24:54 <xenocons> right, funny about that
17:24:56 <edwardk> const could only have one reasonable implementation
17:25:10 <edwardk> well, you could be silly and just give back undefined or something
17:25:13 <xenocons> i felt like i was re-writing my own abstractions in F# because i wanted to go 'higher' lol
17:25:18 <edwardk> but if the author of const isn't an idiot it does what you expect
17:25:19 <edwardk> :t fst
17:25:21 <lambdabot> (a, b) -> a
17:25:22 <neutrino_> hi
17:25:26 <edwardk> fst has the same thing going for it
17:25:31 <xenocons> well, hm
17:25:49 <xenocons> why is the parens around the (a,b) ?
17:25:54 <xenocons> shouldnt fst be a function type
17:25:55 <edwardk> you can't look at the type and do different things based on it, its not like a c++ template where you can use partial template specialization
17:25:56 <neutrino_> can i somehow run a quickcheck property so that, if the property is falsified, it does a fail with the error message explaining what was falsified?
17:25:59 <edwardk> fst takes a pair
17:26:00 <xenocons> (a,b-a)
17:26:02 <neutrino_> rather than print to stdout
17:26:04 <edwardk> > (1,2)
17:26:05 <lambdabot>   (1,2)
17:26:08 <edwardk> > fst (1,2)
17:26:08 <xenocons> ((a,b) -> a)
17:26:09 <ion> > fst (a,b)
17:26:10 <lambdabot>   1
17:26:10 <lambdabot>   can't find file: L.hs
17:26:23 <edwardk> @undefine
17:26:24 <xenocons> hrm
17:26:31 <edwardk> :t curry
17:26:32 <lambdabot> ((a, b) -> c) -> a -> b -> c
17:26:37 <xenocons> i always saw fst as ('a * 'b -> 'a)
17:26:42 <edwardk> that function looks complicated but it can only really do one thing
17:26:46 <jmcarthur> :t curry fst
17:26:47 <lambdabot> c -> b -> c
17:26:52 <edwardk> curry f a b = f (a,b)
17:26:54 <jmcarthur> :t const
17:26:56 <lambdabot> a -> b -> a
17:26:57 <mauke> xenocons: * is spelled (,) in Haskell
17:27:03 <ion> @djinn ((a,b)->c)->a->b->c
17:27:03 <lambdabot> f a b c = a (b, c)
17:27:08 <jmcarthur> :t uncurry const
17:27:09 <lambdabot> (c, b) -> c
17:27:12 <xenocons> mauke:yeh, hehe
17:27:34 <xenocons> (i did notice that! i am less familiar with haskells type signatures still)
17:27:42 <edwardk> xenocons: 'const' takes a value and returns a new function from any other value giving you back the value you gave it first
17:27:52 <xenocons> hm
17:27:55 <edwardk> fst takes a pair, and gives you back the first value in the pair
17:27:57 <edwardk> > const 1 2
17:27:59 <lambdabot>   1
17:28:00 <flonum> Hey, I wrote the Levenshtein distance function using Data.Memocombinators, but generalizing the code using Memo.boundedList instead of Memo.memo2 loses the memoization -- any suggestions?  http://pastebin.com/V0Cvsj7V
17:28:01 <edwardk> > const 1
17:28:02 <xenocons> > const id
17:28:03 <lambdabot>   *Exception: show: No overloading for function
17:28:04 <lambdabot>   *Exception: show: No overloading for function
17:28:04 <mauke> The paste V0Cvsj7V has been copied to http://hpaste.org/78699
17:28:07 <edwardk> :t const 1
17:28:08 <lambdabot> Num a => b -> a
17:28:10 <edwardk> :t const ()
17:28:11 <lambdabot> b -> ()
17:28:16 <Philippa> edwardk: PM, btw?
17:28:24 <edwardk> Philippa: ah whoops
17:28:27 <xenocons> > const . curry
17:28:29 <lambdabot>   *Exception: show: No overloading for function
17:29:01 <edwardk> :t const . curry
17:29:02 <lambdabot> ((a, b1) -> c) -> b -> a -> b1 -> c
17:29:28 <edwardk> :t (const . curry) fst x y z
17:29:29 <lambdabot> Expr
17:29:34 <edwardk> > (const . curry) fst x y z
17:29:36 <lambdabot>   y
17:29:40 <xenocons> cool
17:29:52 <xenocons> does curry support an abritrary number of parameters to curry
17:30:30 <edwardk> :t curry
17:30:31 <lambdabot> ((a, b) -> c) -> a -> b -> c
17:30:38 <edwardk> curry just takes a function from a pair of args
17:30:42 <xenocons> hm, how is fst x y z working, i mean x,y,z are defined how?
17:30:45 <cmccann> it supports an arbitrary number of parameters as long as the number is arbitrarily two
17:30:52 <xenocons> cmccann: hah
17:31:11 <edwardk> xenocons: heh, lambdabot loads a module calle Debug.SimpleReflect.Vars which supplies a..z  as values of type 'Expr'
17:31:13 <edwardk> > a + b
17:31:15 <lambdabot>   a + b
17:31:17 <xenocons> ah
17:31:30 <edwardk> they print showing what was done to them for some operations where they can get away with it
17:31:37 <xenocons> :t (+)
17:31:37 <edwardk> > foldr f z [a,b,c,d]
17:31:38 <lambdabot> Num a => a -> a -> a
17:31:38 <lambdabot>   f a (f b (f c (f d z)))
17:31:46 <edwardk> > foldl f z [a,b,c,d]
17:31:47 <lambdabot>   f (f (f (f z a) b) c) d
17:31:53 <xenocons> is num just the default interface
17:31:57 <edwardk> its useful for showcasing functions like this
17:32:05 <edwardk> Num is the class that provides (+), etc.
17:32:20 <xenocons> > [1,2] + [3,4]
17:32:22 <lambdabot>   No instance for (GHC.Num.Num [t0])
17:32:22 <lambdabot>    arising from a use of `e_11234'
17:32:22 <lambdabot>  Poss...
17:32:29 <xenocons> fiures
17:32:35 <xenocons> figures*
17:32:49 <xenocons> so how far does the polymorphism of (+) extend heh
17:33:00 <xenocons> just int\float and stuff in Num?
17:33:14 <xenocons> or can you use it on vertices\matrce etc
17:33:15 <cmccann> anything you create an instance of Num for
17:33:24 <xenocons> right
17:33:28 <edwardk> xenocons: you can write custom instances
17:33:30 <glguy> Int/Float aren’t special cases
17:34:12 <edwardk> > diff sin x
17:34:13 <edwardk> > grad (\[x,y] -> x * y + 3) [x,y]
17:34:14 <lambdabot>   can't find file: L.hs
17:34:14 <lambdabot>   cos x * 1
17:35:06 <monochrom> (+) is just Num. but many types are in Num
17:35:12 <edwardk> that is using a numeric type provided by my 'automatic differentiation library' on top of the one that provides 'Vars'
17:35:14 <edwardk> > grad (\[x,y] -> x * y + 3) [x,y]
17:35:15 <lambdabot>   [0 + (0 + y * (0 + 1 * 1)),0 + (0 + x * (0 + 1 * 1))]
17:35:24 <edwardk> Expr really could use a simplifier ;)
17:35:59 <edwardk> > map reduction $ grad (\[x,y] -> x * y + 3) [x,y]
17:35:59 <cmccann> xenocons, the only reason there's no Num instance for lists of numbers is that it's not obvious what it should do
17:36:00 <lambdabot>   [[0 + (0 + y * (0 + 1 * 1)),0 + (0 + y * (0 + 1)),0 + (0 + y * 1)],[0 + (0 ...
17:36:07 <edwardk> > last $ map reduction $ grad (\[x,y] -> x * y + 3) [x,y]
17:36:09 <lambdabot>   [0 + (0 + x * (0 + 1 * 1)),0 + (0 + x * (0 + 1)),0 + (0 + x * 1)]
17:36:11 <xenocons> cmccann: right
17:36:20 <edwardk> aw shucks it doesn't help
17:36:32 <parcs`> > map (last . reduction) $ grad (\[x,y] -> x * y + 3) [x,y]
17:36:33 <lambdabot>   [0 + (0 + y * 1),0 + (0 + x * 1)]
17:36:34 <xenocons> :t ($)
17:36:35 <lambdabot> (a -> b) -> a -> b
17:36:53 <xenocons> hmm?
17:36:57 <xenocons> oh
17:37:03 <xenocons> i see
17:37:08 <edwardk> > last $ transpose $ map reduction $ grad (\[x,y] -> x * y + 3) [x,y]
17:37:10 <lambdabot>   [0 + (0 + y * 1),0 + (0 + x * 1)]
17:37:32 <edwardk> > map (last.reduction) $ grad (\[x,y] -> x * y + 3) [x,y]
17:37:34 <lambdabot>   [0 + (0 + y * 1),0 + (0 + x * 1)]
17:37:41 <edwardk> i guess it can't do better than that
17:38:06 <edwardk> > map (last.reduction) $ grad (\[x,y] -> sin x * cos y + 3) [x,y]
17:38:08 <lambdabot>   [0 + (0 + cos x * (0 + cos y * 1)),0 + (0 + negate (sin y) * (0 + sin x * 1...
17:38:10 <xenocons> so the lambda parameter can be a list?
17:38:17 <xenocons>  \[x,y]
17:38:28 <edwardk> xenocons: that is using a pattern match directly in the lambda
17:38:33 <xenocons> right
17:38:34 <edwardk> not very good style because it can fail ;)
17:38:48 <edwardk> :t vgrad
17:38:49 <lambdabot>     Not in scope: `vgrad'
17:38:49 <lambdabot>     Perhaps you meant `grad' (imported from Numeric.AD)
17:39:01 <edwardk> but vgrad isnt in scope, so its the only sensible thing i can do
17:39:02 <cmccann> but inline case expressions are a bit hideous
17:39:05 <snyp_> I am reading learn u a haskell, i need to make sure what actually happens when I do
17:39:06 <snyp_> sum (takeWhile (<10000) [n^2 | n <- [1..], odd (n^2)])
17:39:24 <edwardk> > grad sum [1,2,3,4]
17:39:26 <lambdabot>   [1,1,1,1]
17:39:31 <edwardk> > grad product [1,2,3,4]
17:39:33 <lambdabot>   [24,12,8,6]
17:40:19 <aristid> :t grad
17:40:21 <lambdabot> (Num a, Traversable f) => (forall (s :: * -> *). Numeric.AD.Types.Mode s => f (AD s a) -> AD s a) -> f a -> f a
17:40:37 <shachaf> @let reduce' :: Expr -> Maybe Expr; reduce' e = if e == e' then Nothing else Just e' where e' = reduce e
17:40:38 <lambdabot>  Defined.
17:40:40 <aristid> oh, didn't realize lambdabot has AD.
17:40:50 <edwardk> yeah
17:40:54 <shachaf> > farthest reduce' $ grad (\[x,y] -> sin x * cos y + 3) [x,y]
17:40:55 <snyp_> So sum asks takewhile for a list, which in turn wants a list to include elements from. so after 1 is included in takeWhile's list , does the list on which sum operates look like
17:40:55 <lambdabot>   Couldn't match expected type `Debug.SimpleReflect.Expr.Expr'
17:40:55 <lambdabot>              w...
17:40:56 <snyp_> sum ([1] ++ takeWhile(<1000) [n^2| n <- [2..], odd(n^2)])
17:41:01 <shachaf> Hmph.
17:41:06 <edwardk> > diff (\x -> cos (exp x)) y
17:41:08 <lambdabot>   negate (sin (exp y)) * (exp y * 1)
17:41:09 <parcs`> edwardk: what's the meaning of grad sum and grad product?
17:41:09 <cmccann> snyp_, why not try it in GHCi and find out?
17:41:31 <monochrom> I think yes, snyp_ .
17:41:45 <edwardk> parcs`: sum will compute the sum of all of the elements, thats giving you the gradient at that point which is the amount it would change if you changed that one element
17:41:48 <edwardk> > grad product [1,2,3,4]
17:41:50 <lambdabot>   [24,12,8,6]
17:41:56 <parcs`> edwardk: oh, right
17:42:09 <parcs`> awesome
17:42:11 <edwardk> locally if you edited '3' the answer would change by a factor of about 8 larger
17:42:15 <snyp_> I just need to understand how lazy evaluation works, i don't know how to test individual steps of the operation of the function in ghci
17:42:29 <edwardk> > grad' product [1,2,3,4]
17:42:30 <lambdabot>   (24,[24,12,8,6])
17:42:35 <edwardk> > grad' product [1,2,6,4]
17:42:37 <lambdabot>   (48,[48,24,8,12])
17:42:39 <jmcarthur> oh, i was just saying the other day that it would be nice if lambdabot had some sort of automatic differentiation library
17:42:43 <rwbarton> @type grad'
17:42:45 <lambdabot> (Num a, Traversable f) => (forall (s :: * -> *). Numeric.AD.Types.Mode s => f (AD s a) -> AD s a) -> f a -> (a, f a)
17:42:50 <xenocons> oh right, you need to put parens around function body in a lambda ?
17:42:54 <rwbarton> oh is that the value
17:43:04 <xenocons> > (\x -> snd x, fst x) (1,2)
17:43:05 <lambdabot>   Couldn't match expected type `(t0, b0)'
17:43:05 <lambdabot>              with actual type `Debu...
17:43:17 <edwardk> > (6 - 3) * 8
17:43:19 <lambdabot>   24
17:43:27 <edwardk> > 24 + (6 - 3) * 8
17:43:28 <lambdabot>   48
17:43:29 <xenocons> > (\x -> (snd x, fst x)) (1,2)
17:43:29 <jmcarthur> xenocons: it's the pair than needs parens
17:43:30 <lambdabot>   (2,1)
17:43:43 <monochrom> always put in more parens :)
17:43:44 <snyp_> monochrom: hm.. thanks
17:43:46 <xenocons> not sure why
17:43:47 <jmcarthur> xenocons: the lambda only needs it there due to precendences
17:43:56 <edwardk> of course for non-linear functions this starts to fall off
17:44:05 <jmcarthur> xenocons: pairs just require parens as part of their syntax (i don't like this property, but it is what it is)
17:44:22 <xenocons> > (\(x,y) -> (y,x) ) (1,2)
17:44:23 <lambdabot>   (2,1)
17:44:31 <xenocons> jmcarthur: yeah that is a bit different
17:44:38 <edwardk> :t uncurry (flip (,))
17:44:39 <lambdabot> (a, b) -> (b, a)
17:44:47 <edwardk> > uncurry (flip (,)) (1,2)
17:44:48 <lambdabot>   (2,1)
17:45:20 <xenocons> > let swap (a,b) = (b,a) in (1,2)
17:45:22 <lambdabot>   (1,2)
17:45:47 <otters> lol
17:45:48 <edwardk> :t Data.Tuple.swap
17:45:49 <lambdabot> (a, b) -> (b, a)
17:45:53 <xenocons> hah
17:45:54 <otters> > let swap (a,b) = (b,a) in swap (1,2)
17:45:55 <lambdabot>   (2,1)
17:46:11 <xenocons> otters: is that using your definition?
17:46:19 <xenocons> or is it using Data.Tuple.swap
17:46:24 <otters> xenocons: my definition
17:46:30 <xenocons> hm
17:46:33 <otters> let bindings override other bindings iirc
17:46:39 <otters> xenocons: you forgot to put "swap" in your example
17:46:53 <shachaf> let bygones override bygones
17:46:54 <xenocons> oh right
17:46:56 <xenocons> duh
17:46:56 <c_wraith> well, all bindings shadow bindings at higher scopes
17:47:04 <otters> yeah, that's what I meant
17:47:06 <otters> couldn't think of the word
17:47:09 <edwardk> xenocons: the reason has to do with the fact that we like to be able to end a function on a ,.   (\x -> x, \y -> y)    gives you back a pair of functions, not (\x -> (x, \y -> y))  -- which you'd get the other way
17:47:19 <xenocons> otters: i seem to do this a lot heh
17:47:24 <otters> so do I
17:47:43 <shachaf> What was the reason that "f do ..." or "f case ..." is forbidden again?
17:48:01 <edwardk> @let bygones = bygones
17:48:03 <lambdabot>  Defined.
17:48:05 <xenocons> edwardk: i see
17:48:06 <cmccann> haha
17:48:11 <cmccann> > bygones
17:48:15 <lambdabot>   mueval-core: Time limit exceeded
17:48:23 <cmccann> fitting
17:48:28 <xenocons> > id bygones
17:48:32 <lambdabot>   mueval-core: Time limit exceeded
17:48:34 <jmcarthur> edwardk: that seems a pretty unusual situation, for me
17:48:51 <xenocons> im used to the lambda body not requiring parens
17:49:08 <xenocons> but im willing to look past this infraction ;)
17:49:11 <edwardk> jmcarthur: i admit it'd be more regular the other way, the issue is that , plays some pretty magic roles in the syntax.
17:49:31 <rwbarton> (\x -> x, \y -> y) is not ambiguous anyways
17:49:32 <edwardk> so you need to look at the grammar which does different things inside ()'s based on how many ,'s it encounters
17:49:47 <rwbarton> because , needs to go along with ()
17:49:56 <edwardk> rwbarton: the point was what if it didn't have to
17:50:00 <jmcarthur> rwbarton: that is the thing we are talking about
17:50:00 <rwbarton> oh ok
17:50:06 <edwardk> rwbarton: which is what jmcarthur was advocating
17:50:21 <rwbarton> ah, that was above the top of my screen :P
17:51:05 <jmcarthur> > let swap = snd &&& fst in swap (1,2)
17:51:06 <lambdabot>   (2,1)
17:51:21 <xenocons> > let f = \x -> x
17:51:22 <lambdabot>   not an expression: `let f = \x -> x'
17:51:22 <edwardk> syntactically when you parse ('s you start grabbing expressions, delimited by , and then build either just a (), a value or a tuple depending on how many (,)'s you got
17:51:48 <xenocons> let f = \x -> x + 1 in f 5
17:51:48 <edwardk> if , was an operator like any other living in the precedence system that would be much harder to do
17:51:56 <xenocons> > let f = \x -> x + 1 in f 5
17:51:58 <lambdabot>   6
17:52:10 <jmcarthur> ocaml seems to manage
17:52:43 <edwardk> ocaml proves you _can_ do many things, but it also provides good counter examples for why you shouldn't do others. ;)
17:52:46 <edwardk> bbiab
17:52:48 <jmcarthur> sure
17:53:00 <jmcarthur> optional arguments... *shudder*
17:53:01 <xenocons> > let f = \x y z -> x + 1 + y + z = in f 5 6 7
17:53:02 <lambdabot>   <hint>:1:33: parse error on input `='
17:53:12 <xenocons> > let f = \x y z -> x + 1 + y + z in f 5 6 7
17:53:14 <lambdabot>   19
17:53:21 <xenocons> okay this works as expected
17:53:29 <xenocons> > let f x y z = x + 1 + y + z in f 5 6 7
17:53:30 <lambdabot>   19
17:53:57 <xenocons> jmcarthur: F# has no optional argumens for functions hehe
17:54:19 <jmcarthur> but i don't use F# at work
17:54:22 <xenocons> i dont know how much i care for them, never used them really
17:54:33 <xenocons> makes things confusing
17:54:54 <jmcarthur> there are two things i really don't like about ocaml's optional arguments
17:55:05 <jmcarthur> one is that if you use them then you have to "terminate" them with a non-optional argument
17:55:36 <jmcarthur> the other is that if you assign a default in the function definition then the code for the default is execute at the call site instead of once, statically, including its side effects
17:55:43 <jmcarthur> *executed
17:55:46 <xenocons> right, defaultArg or whatever
17:55:48 <edwardk> foo (def & namedArg .~ 1 & optionalArg ?~ 2) x y z
17:55:49 <xenocons> ive seen this somewhere
17:55:56 <edwardk> problem solved. use lenses ;)
17:56:04 <rwbarton> jmcarthur: isn't that exactly the opposite of what people complain about with python's default arguments
17:56:17 <jmcarthur> in ocaml you just say   let foo ?x:(side effecting stuff here) y = ...
17:56:22 <jmcarthur> rwbarton: yeah
17:56:28 <jmcarthur> rwbarton: the takeaway is that they both suck!
17:56:39 <rwbarton> fair enough :)
17:56:43 <c_wraith> if you don't have mutability, the difference doesn't matter!
17:56:47 <c_wraith> that's the lesson I took from it
17:56:50 <jmcarthur> c_wraith: yeah
17:57:05 <jmcarthur> c_wraith: i still stand by my first argument against it in that case
17:57:08 * cmccann agrees with c_wraith
17:57:47 <edwardk> no love for the optional arg syntax, eh?
17:57:57 <shachaf> edwardk: Record syntax would work there too...
17:58:03 <jmcarthur> edwardk: isn't that basically a record trick?
17:58:20 <xenocons> yep, i pass records as parameters to solve optional syntax
17:58:23 <xenocons> pretty easy
17:58:31 <xenocons> but when i prototype i usually cheat and use ints :)
17:58:31 <xenocons> heh
17:58:36 <edwardk> jmcarthur: just updated a little to use the ?~ combinator for writing to the Maybe inhabited field
17:58:44 <jmcarthur> i think it's ugly and confusing since you have to remember what the "default" value is
17:58:48 <edwardk> shachaf: the maybe is the issue
17:59:01 <jmcarthur> i'm not really happy with any of the optional argument schemes i've seen
17:59:05 <shachaf> Oh, ?~
17:59:06 <edwardk> always hated calling functions with default args because you have to put Just somewhere
17:59:37 <edwardk> jmcarthur: as for default' i was using Data.Default for 'def', but yes, default arguments are usually evil
17:59:39 <jmcarthur> edwardk: at least with Maybe it's easy to see what you're expected to use
17:59:53 <jmcarthur> Data.Default...
17:59:55 * jmcarthur looks it up
17:59:59 <edwardk> jmcarthur: the maybe is still there
18:00:05 <edwardk> :t (?~)
18:00:06 <lambdabot> Setting s t a (Maybe b) -> b -> s -> t
18:00:09 <jmcarthur> i see
18:00:21 <edwardk> > M.empty & at 2 ?~ "hello"
18:00:23 <lambdabot>   fromList [(2,"hello")]
18:00:29 <edwardk> > M.empty & at 2 .~ Just "hello"
18:00:31 <lambdabot>   fromList [(2,"hello")]
18:00:46 <jmcarthur> the maybe isn't necessary in the general case for the record trick
18:00:46 <glguy> No way you didn’t know what ?~ was, but immediately understood the type signature edwardk pasted
18:01:19 <edwardk> jmcarthur: it is if you want to have a truly optional arg and know that it wasn't present. its not necessary for something with a _default_ value. there is a distinction ;)
18:01:29 <edwardk> glguy: hahahah
18:01:39 <c_wraith> glguy: if you've looked at lens a few times, but not a ton, it makes enough sense
18:01:54 <xenocons> where does the a go?
18:01:54 <jmcarthur> edwardk: i just mean that if you need to know whether it was present, you use Maybe, otherwise you don't
18:01:58 <glguy> c_wraith: If you’ve looked at lens a few times you’ve seen ?~ :-p
18:02:05 <c_wraith> glguy: I haven't
18:02:08 <xenocons> :t (?~)
18:02:09 <lambdabot> Setting s t a (Maybe b) -> b -> s -> t
18:02:22 <xenocons> is the 'a' the optArg?
18:02:31 <edwardk> jmcarthur: yes. i was just showing that the existing plumbing let you avoid having to write the Just which always came across as so much syntactic noise to me. nevermind.
18:02:32 <xenocons> confusing
18:02:34 <c_wraith> It's just an unused type argument
18:02:39 <xenocons> oh
18:02:49 <c_wraith> well, unconstrained.  Since it's used in only one spot
18:02:51 <xenocons> does ghc warn on unused arguments ;)
18:02:57 <c_wraith> it's a *type* argument
18:03:00 <c_wraith> not a value argument
18:03:05 <xenocons> oh right, because its a type signature
18:03:18 <edwardk> xenocons: it is a type argument, and no it doesn't, and shouldn't.
18:03:22 * xenocons has to get used to a <> 'a
18:03:31 <xenocons> sorry, a = 'a heh
18:03:34 <fatbrain> Hi, pseudo c code, foo(callback) where foo calls callback a couple of times, is there some way one could transform the foo(callback) into => [ [1, 2, 3], [4, 5, 6] ], if foo called the callback twice, first with 1, 2, 3 and then with 4, 5, 6?
18:03:38 <jmcarthur> edwardk: well, at least Data.Default is kind of neat as long as you don't mind using a unique type for each default you need
18:04:21 <jmcarthur> edwardk: i suspect that xenocons meant in the function definition, not at the call site
18:04:37 <edwardk> jmcarthur: i tend to use Data.Default to make a FooOptions for a function foo, smash all the names i want into it, and then use the ability to pun lenses though a type class to be able to use the same named argument names
18:04:42 <jmcarthur> xenocons: ghc can warn about unused variables
18:04:49 <xenocons> cool
18:04:56 <jmcarthur> xenocons: just use -Wall
18:05:07 <edwardk> jmcarthur: term variables, not type variables
18:05:12 <jmcarthur> edwardk: ah, right
18:05:14 <xenocons> right, thats familiar
18:05:21 <jmcarthur> xenocons: what edwardk said
18:05:26 <xenocons> got it
18:05:40 * cmccann ponders the koan of generating warnings for unused type variables without explicit foralls enabled
18:05:45 <shachaf> fatbrain: You'll have to be more specific.
18:05:45 <edwardk> i have plenty of real code that needs to ignore type variables. someone who tried to require that type variables be used would be pretty roundly laughed at ;)
18:05:55 <shachaf> fatbrain: It might be that the answer will involve something like Writer.
18:06:01 <jmcarthur> ah, another little thing i've come to appreciate in ocaml without realizing until now is that i don't have to name type variables that i won't need more than once. i can just use _
18:06:10 <edwardk> cmccann: you could push for the addition of _ at the type level perhaps
18:06:16 <shachaf> id :: forall a b. a -> a
18:06:27 <shachaf> <interactive>:3:19: Warning: Unused quantified type variable `b'
18:06:32 <cmccann> edwardk, no, I mean "completely unused". like the type variable "c" is not used in "a -> b -> a"
18:06:57 <edwardk> cmccann: ah
18:07:10 <jmcarthur> shachaf: win
18:07:35 <cmccann> (obviously with explicit foralls such an error makes sense)
18:07:46 <cmccann> as in shachaf's example
18:08:13 <fatbrain> shachaf: I don't know how I can be more specific :/. I provide the callback function, someone else wrote foo, it calls the callback with useful information, but I rather have it as a list. Makes sense?
18:08:22 <xenocons> hrm, i just started reading about BK Trees, quite cool
18:08:53 <edwardk> cmcann: i was thinking like in data Foo a b = Foo a
18:08:57 <edwardk> data Proxy a = Proxy
18:09:10 <edwardk> lots of places where you need to explicitly ignore something
18:09:16 <shachaf> fatbrain: Well, an example in Haskell syntax would be useful. :-)
18:09:29 <shachaf> fatbrain: Anyway, you can't do it with pure functions, because it would be a side effect.
18:09:35 <xenocons> :t L.mapAccumL
18:09:35 <shachaf> fatbrain: But you can probably do it with something like Writer.
18:09:37 <lambdabot>     Not in scope: `L.mapAccumL'
18:09:37 <lambdabot>     Perhaps you meant one of these:
18:09:37 <lambdabot>       `BSL.mapAccumL' (imported from Data.ByteString.Lazy),
18:10:02 <fatbrain> shachaf: I don't know how I would write it in Haskell, that's why I posed the question like that ;).
18:10:07 <xenocons> i like how ghci suggests things :>
18:10:11 <fatbrain> shachaf: The side effect would be, creating a list?
18:10:14 <edwardk> fatbrain: is your callback an IO action or something?
18:10:30 <shachaf> fatbrain: The side effect would be "storing the argument to the function".
18:10:46 <edwardk> fatbrain: you could make an IORef, start it with an empty list and have your callbac update the IORef by consing onto the list, and them later check the ioref for what has been done to it
18:11:03 <fatbrain> well, do I really need to "store" them?
18:11:05 <shachaf> I'm pretty sure that's not what fatbrain means...
18:11:24 <shachaf> I assume fatbrain means something like toListOf + traverse/mapM, though they don't know it. :-)
18:11:49 <xenocons> fatbrain: if you have teh C code maybe u can paste it, i wont be able to help most likely but i like looking at code :>
18:11:50 <shachaf> foo :: (Int -> Int) -> Int; foo f = f 3 + f 4
18:11:50 <edwardk> fatbrain: main = do myRef <- newIORef []; foo (\xs -> modifyIORef myRef (xs:)); finalAnswer <- readIORef myref
18:11:55 <shachaf> You want to extract 3 and 4 from foo
18:11:57 <shachaf> Is that right?
18:12:08 <shachaf> Or let's say (Int -> Bool)
18:12:13 <edwardk> fatbrain: if the function doesn't let you work in IO or ST then you can't do it
18:12:39 <shachaf> fatbraind: foo :: (Int -> Bool) -> Int; foo f = f 10 && f 20 -- you want to somehow extract [10,20] from foo? Or am I completely misunderstanding?
18:13:08 <fatbrain> edwardk: I can't modify foo, but the callback is something I would write, and that function is passed all the data I need. But that would maybe involve some strange non-functional thingie.
18:13:10 <shachaf> If that's the case then, yes, it's not possible. But if you changed foo's type a bit to cooperate then it would be possible.
18:13:19 <edwardk> what is the _actual_ type signature of foo?
18:13:26 <shachaf> fatbrain: Is there a concrete thing involved here?
18:13:45 <fatbrain> Kinda like in JavaScript: list = []; foo(function() { list.push(arguments); }); list would now contain data.
18:13:48 <edwardk> fatbrain: we need to know if you have a monad you can hang the effect on. otherwise we're just talking in circles.
18:14:14 <fatbrain> shachaf: yes, but unfortunately not Haskell related :(
18:14:26 <shachaf> fatbrain: If it just takes a plain function, no, it's not possible. If it takes a function with Applicative/Monad effects, then yes, it's possible.
18:14:42 <xenocons> surely you can encapsulate a callback
18:15:04 <shachaf> You want your function to have side effects, and the way we usually represent that is with Applicative/Monad.
18:15:09 <edwardk> xenocons: to build a callback you need to have an effect. that means the callback should be a function (a -> IO b) or something like that not just (a -> b)
18:15:18 <edwardk> the _absence_ of callbacks is important in some places
18:15:21 <shachaf> fatbrain: This isn't Haskell?
18:15:35 <edwardk> shachaf: it think he was using the java example as a way to showcase what he wanted
18:15:39 <xenocons> edwardk: right, does IO b alter b?
18:15:53 <edwardk> xenocons: IO b is an 'i/o action that when run will produce a b'
18:16:04 <xenocons> hmm right
18:16:14 <edwardk> a -> IO b  is a function that takes an a and gives you back an IO action you can run.
18:16:15 <startling> xenocons: so readFile is a FilePath -> IO String
18:16:16 <fatbrain> shachaf: No, but I want to do it in a functional manner. This is the first channel I thought of.
18:16:27 <shachaf> fatbrain: Oh.
18:16:39 <fatbrain> Thanks, I'll probably go with the Applicative/Monad approach.
18:16:43 <shachaf> I suspect the answer is too context-dependent to do you much good.
18:16:52 <xenocons> hm, i see
18:17:05 <xenocons> callback is quite challenging to encapsulate..
18:17:08 <edwardk> :t putStrLn
18:17:10 <lambdabot> String -> IO ()
18:17:15 <edwardk> that prints to the screen.
18:17:15 <xenocons> like reference passing
18:17:18 <fatbrain> Thanks for the input all.
18:17:28 <edwardk> it takes a string, and gives you back an io action, that you can run that will print the string
18:17:41 <fatbrain> yes, the problem is the api I'm working with, it's not pretty.
18:17:57 <xenocons> edwardk: so it is like it returns a function and that function can be used to perfor the action
18:18:05 <shachaf> I don't think the Haskell solution will translate very directly to most languages.
18:18:09 <xenocons> as opposed to just String -> ()
18:18:17 <shachaf> (Except for the whole "you have implicit effects everywhere" thing.)
18:18:27 <edwardk> xenocons: pretty much. we consider the 'io action' a first class object you can compose with other io actions
18:18:27 <shachaf> xenocons: No, "IO ()" isn't a function.
18:18:34 <shachaf> It's just a thing.
18:18:41 <edwardk> :t readFile "foo" >>= \x -> putStrLn x
18:18:42 <lambdabot> IO ()
18:19:04 <xenocons> hmm
18:19:12 <xenocons> i think i roughly get it
18:19:34 <xenocons> it looks like you can use it without having to know too deeply what it does? (at least at the start)
18:19:39 <edwardk> that composes two things an IO String  that it got back from readFile "foo"       and an action that takes a string and prints it, giving you back an IO (), and the composition is a new IO action that does the first, takes the answer and passes it to the other function, gets the answer action and performs that
18:19:44 <edwardk> xenocons: exactly
18:19:54 <edwardk> foo = do x <- readFile "foo"; putStrLn x
18:20:04 <xenocons> right, i can see how composing IO () is actually useful
18:20:09 <edwardk> xenocons: that should look pretty much like the 'chain of lets' you are used to
18:20:12 <xenocons> especially for performance
18:20:27 <edwardk> xenocons: but it doesn't actually do anything, it just builds up an action that when run will do something
18:20:41 <edwardk> main :: IO () is where you in theory plumb all your io actions to to run them
18:20:42 <xenocons> hm, but it doesnt return something when the action is computed?
18:20:51 <shachaf> xenocons: This isn't really related to performance at all.
18:21:13 <edwardk> xenocons: you are building a composite action, not running it. i can take the same IO () and run it 20 times, to get the same set of effects over and over
18:21:38 <xenocons> maybe i should just not read into IO yet
18:21:40 <edwardk> xenocons: the runtime system runs the effects described by main for you, you can fork an IO action, etc.
18:22:09 <jmcarthur> xenocons: IO is like a description of an imperative program. the main function in your program happens to be such a description.
18:22:24 <edwardk> xenocons: but an 'IO String' very much isn't a string. its a program that when run will produce a string
18:22:27 <jmcarthur> xenocons: you can also create IO actions that are not ever executed
18:22:29 <shachaf> @quote /bin/ls
18:22:29 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
18:22:40 <xenocons> ah
18:22:45 <jmcarthur> shachaf: that's a good one
18:22:47 <xenocons> it makes sense to model 'main' in the imperative sense'
18:23:06 * xenocons would like to see how haskell does optparsing
18:23:29 <edwardk> xenocons: http://www.ugcs.caltech.edu/~keegan/talks/first-class-concurrency/talk.pdf is a good overview of the power of thinking this way
18:23:34 <jmcarthur> xenocons: it's a little different in that the structure of the imperative program can differ depending on values obtained at runtime, whereas in most imperative languages you can't actually do that
18:23:39 <shachaf> Recently I wrote this thing on different ways I/O could work: http://stackoverflow.com/questions/13536761/what-other-ways-can-state-be-handled-in-a-pure-functional-language-besides-with/13538351#13538351
18:23:53 <xenocons> edwardk: ill read that
18:24:10 <xenocons> jmcarthur: hm
18:24:55 <xenocons> oh right thats easy
18:25:04 <xenocons> x <- readLn :: IO Integer
18:25:05 <xenocons> heh
18:25:28 <edwardk> :t readLn
18:25:30 <lambdabot> Read a => IO a
18:25:40 <edwardk> it doesn't know what type its reading otherwise ;) its kind of a hack ;)
18:25:43 <edwardk> :t getStrLn
18:25:44 <lambdabot>     Not in scope: `getStrLn'
18:25:44 <lambdabot>     Perhaps you meant one of these:
18:25:44 <lambdabot>       `putStrLn' (imported from Prelude),
18:25:48 <edwardk> :t getLine
18:25:49 <lambdabot> IO String
18:26:01 <edwardk> :t getLine >>= \x -> return (read x)
18:26:02 <lambdabot> Read b => IO b
18:26:10 <mauke> @index liftIO
18:26:10 <lambdabot> Control.Monad.Trans, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
18:26:11 <edwardk> thats the implementation of readLn
18:26:16 <edwardk> > read "300" :: Integer
18:26:18 <lambdabot>   300
18:26:21 <edwardk> > read "300" :: Double
18:26:23 <lambdabot>   300.0
18:26:24 <shachaf> (Except not exactly.)
18:26:27 <edwardk> > read "300" :: (Integer,Integer)
18:26:28 <lambdabot>   *Exception: Prelude.read: no parse
18:26:42 <shirt> I'm using quickcheck, how do i generate an int that falls between a min and max value?
18:26:42 <xenocons> i figure readLn :: IO Integer isnt necessarily the best way of handling i think it is best to read everything first, then convert it to its type
18:26:48 <Nereid> :t fmap read getLine
18:26:50 <lambdabot> Read b => IO b
18:27:00 <shachaf> @ty getLine >>= readIO
18:27:02 <lambdabot> Read b => IO b
18:27:06 <Nereid> better
18:27:07 <edwardk> xenocons: we would probably agree with you
18:27:12 <neutrino_> shirt: using preconditions? you can also create a new Gen, but i'm not sure how
18:27:30 <edwardk> xenocons: i had honestly forgotten the function existed until keegan's slides ;)
18:27:41 <edwardk> shachaf: good point
18:27:58 <xenocons> heh
18:28:03 <neutrino_> shirt: preconditions can exhaust searches without failing or passing any, so the whole property check ends up failing
18:28:11 <xenocons> hmm
18:28:15 <xenocons> :t (>>=)
18:28:16 <lambdabot> Monad m => m a -> (a -> m b) -> m b
18:28:29 <xenocons> :t fmap
18:28:30 <lambdabot> Functor f => (a -> b) -> f a -> f b
18:28:31 <neutrino_> shirt: a Gen would make it work "always" i guess
18:28:33 <shirt> neutrino_: that doesn't sound good
18:28:38 <edwardk> > Just 12 >>= \x -> Just (x + 1)
18:28:39 <lambdabot>   Just 13
18:28:45 <xenocons> oh
18:28:46 <neutrino_> shirt: it's not as bad. just don't have too many preconditions.
18:28:46 <edwardk> > Just 12 >>= \x -> Nothing
18:28:48 <lambdabot>   Nothing
18:28:58 <edwardk> > [12,13] >>= \x -> [x, x*10]
18:29:00 <lambdabot>   [12,120,13,130]
18:29:13 <neutrino_> shirt: i think it's normal to have a property test fail because of exhausted search every now and then.
18:29:22 <edwardk> :t getLine >>= readFile
18:29:24 <lambdabot> IO String
18:29:37 <neutrino_> shirt: bear in mind that property will not always fail, just sometimes.
18:29:53 <jmcarthur> or you could do the right thing and only generate valid inputs in the first place
18:30:02 <shirt> neutrino_: what do you think of the idea of generating a number, and then using "rem" to contrain is to my desired range?
18:30:02 <jmcarthur> sadly, that requires using some sort of newtype much of the time
18:30:11 <jmcarthur> shirt: that's a reasonable workaround
18:30:14 <edwardk> (>>=) is a very very commonly used function in haskell. 'do' sugar is just a way to chain a bunch of (>>=)'s
18:30:25 <neutrino_> :t rem
18:30:26 <lambdabot> Integral a => a -> a -> a
18:30:45 <edwardk> @undo do x <- [12,13]; [x,x*10]
18:30:46 <lambdabot> [12, 13] >>= \ x -> [x, x * 10]
18:30:53 <jmcarthur> neutrino_: it's like mod but faster and less sane
18:31:01 <neutrino_> umm
18:31:17 <Nisstyre-laptop> :t divMod
18:31:18 <lambdabot> Integral a => a -> a -> (a, a)
18:31:23 <neutrino_> shirt: you probably don't want to use mod.
18:31:25 <ion> “<edwardk> thats the implementation of readLn” Actually, i think it’s getLine >>= \x -> evaluate (read x)
18:31:27 <startling> isn't there a reason you're not supposed to use mod or rem random numbers?
18:31:29 <jmcarthur> neutrino_: quotRem always rounds the quotient toward zero (upward if it’s less then zero and downward if it’s greater than zero) and is more efficient than divMod, but divMod rounds the quotient toward negative infinity (always downward).
18:31:41 <edwardk> ion that is the readIO version that shachaf showed
18:31:46 <Nisstyre-laptop> startling: doesn't matter if it's within a certain range (natural numbers)
18:31:47 <edwardk> i was stating sort of a simplification ;)
18:31:54 <jmcarthur> startling: it depends on what you are modding or remming by and what your application is
18:32:03 <neutrino_> jmcarthur: i have no idea how to understand what you just said.
18:32:08 <neutrino_> but then, it's 3:30 am.
18:32:13 <otters> :t evaluate
18:32:13 <lispy> startling: IIRC, the man page for rand comments on it
18:32:14 <lambdabot>     Not in scope: `evaluate'
18:32:14 <lambdabot>     Perhaps you meant `evalState' (imported from Control.Monad.State)
18:32:17 * lispy goes to check
18:32:24 <edwardk> the differences between errors in pure terms and errors sequenced rigorously with IO was something i was going to gloss over ;)
18:32:30 <Nereid> evaluate = id :: a -> a
18:32:30 <jmcarthur> startling: if the range of generated numbers is a power of two and you are modding by a power of two it's probably okay, for example
18:32:37 <ion> syr
18:32:40 <ion> “aye” even.
18:32:54 <xenocons> can you apply a constraint to a type? like type Abc is rane 1 .. 10
18:32:57 <jmcarthur> startling: and you really only care if teeny tiny biases are bad
18:33:07 <Nereid> xenocons: no :(
18:33:08 <edwardk> xenocons: no
18:33:11 <Nisstyre-laptop> xenocons: you mean a dependent type
18:33:20 <Nereid> haskell does not have dependent types
18:33:27 <xenocons> ah
18:33:29 <xenocons> ok
18:33:29 <jmcarthur> xenocons: there are some languages that can do it, but not haskell
18:33:31 <lispy> startling: I think part of the reason is that histocially rand() didn't have the same amount of randomness in the higher and lower order bits
18:33:35 <Nisstyre-laptop> Nereid: it kind of does, but it's very hackish
18:33:36 <xenocons> jmcarthur: Ada can
18:33:37 <edwardk> Nisstyre-laptop: well lots of non-dependent languages have constraints like that, e.g. ada.
18:33:41 <jmcarthur> (actually you can kind of do it, but it's not newb friendly)
18:33:48 <jmcarthur> (it's not even expert friendly)
18:34:07 <Nisstyre-laptop> edwardk: fair enough, but dependent types are the best way of implementing that imo
18:34:14 <neutrino_> jmcarthur: how can you do it?
18:34:20 <neutrino_> using value promotion?
18:34:26 <jmcarthur> neutrino_: singleton types
18:34:28 <edwardk> xenocons: in general we don't have lots of ad hoc numeric types with specified ranges. we encourage a different pattern
18:34:45 <edwardk> instead of say using -1, 0 , 1 for comparisons, we use LT, EQ, GT
18:34:50 <startling> jmcarthur, lispy: ah, alright
18:34:50 <lispy> ghc has an extenions for type level nats
18:34:50 <edwardk> data Ordering = LT | EQ | GT
18:34:54 <neutrino_> jmcarthur: that wouldn't work for Double, would it?
18:34:58 <edwardk> > fromEnum LT
18:34:58 <xenocons> right
18:34:59 <lambdabot>   0
18:35:02 <ion> Int is an ad hoc numeric type with a somewhat specified range. :-P
18:35:08 <edwardk> (they start them at 0 though)
18:35:11 <Nisstyre-laptop> xenocons: http://www.haskell.org/haskellwiki/Smart_constructors
18:35:17 <edwardk> :t toEnum 2 :: Ordering
18:35:18 <lambdabot> Ordering
18:35:22 <edwardk> > toEnum 2 :: Ordering
18:35:23 <jmcarthur> neutrino_: it could. you would just have to emulate floats at the type level :\
18:35:24 <lambdabot>   GT
18:35:33 <neutrino_> jmcarthur: IEEE floats.
18:35:36 <jmcarthur> yeah
18:35:43 <jmcarthur> not fun, but probably still doable
18:35:47 <xenocons> Nisstyre-laptop: my list of tabs is getting longer!
18:35:48 * jmcarthur isn't about to try
18:35:49 <neutrino_> jmcarthur: with denormals.
18:35:53 <jmcarthur> yes
18:35:58 <jmcarthur> i know all about how painful that would be
18:36:07 <edwardk> type level ieee floats are a crime against nature. i had to implement them in c++ for template meta programming once. never ever again
18:36:15 <jmcarthur> edwardk: :o
18:36:15 <xenocons> haha
18:36:20 <neutrino_> jmcarthur: edwardk wants you to implement this.
18:36:23 <ion> edwardk: Haha. Is the sauce available somewhere?
18:36:26 <cmccann> edwardk, oh good lord
18:36:45 <edwardk> ion: it was a decade ago. i probably have it somewhere. i was using it to compile-time generate fft and wavelet lookup tables
18:36:52 <Nereid> lol
18:36:56 <Nisstyre-laptop> edwardk: could you mirror the construction of reals through the set theoretic definition somehow?
18:36:56 <cmccann> hahaha
18:37:05 <shachaf> edwardk: :-(
18:37:13 <edwardk> Nisstyre-laptop: doesn't work. the reals aren't constructive.
18:37:14 <jmcarthur> edwardk: just writing a program to generate source was too mainstream?
18:37:25 <Nereid> you could do the constructive reals though
18:37:26 <edwardk> jmcarthur: i wanted it to fit my existing toolchain ;)
18:37:28 <neutrino_> edwardk: why didn't you just use a preprocessor?
18:37:29 <Nisstyre-laptop> edwardk: rationals?
18:37:33 <cmccann> type-level floats in C++ might be the most horrible thing I've ever heard of
18:37:45 <ion> I think this is worthy of a quote.
18:37:48 <ion> @remember edwardk type level ieee floats are a crime against nature. i had to implement them in c++ for template meta programming once. never ever again
18:37:48 <lambdabot> Done.
18:37:55 <jmcarthur> hell yes
18:38:26 <aristid> edwardk: you actually implemented a simulation of ieee 754 in c++ templates, presumably based on integers??
18:38:53 <edwardk> neutrino_: because i needed it to work with the template i had for generating big fft calculations directly. it'd be odd to half generate the code with the template and them plug in some weird macro expansion based set of numbers
18:38:55 <edwardk> aristid: yes
18:39:18 <Nisstyre-laptop> that sounds interesting
18:39:26 <aristid> edwardk: did it seem like a good idea at the time? :P
18:39:42 <jmcarthur> edwardk implemented type level floats in C++ because otherwise it would be "odd"
18:39:48 <edwardk> Nisstyre-laptop: the actual purpose was for FFTs so I needed sine and cosine, so rationals don't help ;)
18:39:57 <cmccann> jmcarthur, that says it all, really
18:40:02 <Nisstyre-laptop> edwardk: fair enough
18:40:05 <neutrino_> edwardk: weird like haskell weird or weird like yankovich weird
18:40:17 <edwardk> jmcarthur: i had a beautiful templte you could instantiate for the size of the transform you were doing, etc.
18:40:27 <edwardk> but i wanted to compute the FFT table at compile time
18:40:54 <Nisstyre-laptop> edwardk: that actually sounds brilliant
18:41:12 <edwardk> i dug up a bunch of material on cordic functions and just had at it
18:41:18 * jmcarthur mutters something about a fine line between genius and insantiy
18:41:29 <edwardk> took about two days, but in the end i had my templates ;)
18:41:38 <Nisstyre-laptop> and presumably a much faster program
18:41:50 <edwardk> well, i don't know that i ever used it ;)
18:41:51 <aristid> Nisstyre-laptop: not counting the compile time.
18:41:58 <Nisstyre-laptop> aristid: yeah, of course
18:42:18 <Nisstyre-laptop> although, you could've just memoized them
18:43:01 <edwardk> it did work pretty well though, and i learned a lot about floating point numbers
18:43:05 <Nereid> or generated the tables some other way
18:43:22 <Nisstyre-laptop> Nereid: I would make a json file or something
18:43:41 <Nereid> write a program that generates a header file with the tables to be #included or so
18:43:54 <Nisstyre-laptop> or that
18:43:55 <aristid> edwardk: i suppose you used multiple integers for each float?
18:43:56 <edwardk> Nereid: i could have generated them at runtime, but for some of the mallat wavelet stuff that would have been quite slow
18:44:09 <Nereid> no, still at compile time
18:44:13 <cmccann> edwardk, and throwing rocks at their hive is a good way to learn a lot about bees
18:44:15 <edwardk> Nereid: the problem is i didn't just have one fft. i had a template for generating them
18:44:26 <edwardk> so you could just use fft<parameters> inline in your code
18:44:34 <Nereid> heh
18:44:35 <Nisstyre-laptop> yeah presumably he wanted to keep changing them while programming it
18:44:49 <edwardk> so the include file approach is almost 100% useless to me
18:44:52 <jmcarthur> i bumped into somebody one time (no idea who, might even be here) who took a word list and generated one massive nested switch statement in C as a lookup trie
18:44:57 <jmcarthur> took forever to compile
18:45:06 <cmccann> haha
18:45:11 <mauke> jmcarthur: oh yeah, I used to write code like that
18:45:13 <rwbarton> that sounds like the sort of thing I would do
18:45:29 <jmcarthur> i don't even know if it was fast
18:45:36 <jmcarthur> for that matter, i don't know if he ever finished compiling it
18:45:43 <Nisstyre-laptop> jmcarthur: that reminds me of "sleepsort"
18:45:45 <edwardk> jmcarthur: kw= new RegExp('^(?:break|c(?:a(?:se|tch)|on(?:st|tinue))|d(?:e(?:fault|lete)|o)|else|f(?:alse|inally|or|unction)|i(?:n(?:stanceof)?|f)|n(?:ew|ull)|return|switch|t(?:h(?:is|row)|r(?:ue:y)|ypeof)|v(?:ar|oid)|w(?:hile|ith))$')   -- is floating around in my javascript compiler
18:45:59 <Nisstyre-laptop> because you're taking advantage of another program to do something
18:46:04 <Nisstyre-laptop> but making it look like you're doing it
18:46:10 <mauke> edwardk: pfft, perl's regex compiler does that automatically
18:46:11 <edwardk> though there i did use code to generate the trie
18:46:47 <Nisstyre-laptop> anyone who doesn't know ... http://news.ycombinator.com/item?id=2657277
18:47:53 <Nereid> haha
18:48:56 <edwardk> jmcarthur: anyways, yes it was crazy. yes i learned a lot. and no i will never do it again
18:49:18 <edwardk> it was bad enough when i wrote type level 2s and 16s complement integer arithmetic in haskell
18:49:40 <cmccann> "I'll never do that again" is the best kind of learning
18:49:42 <jmcarthur> that doesn't sound so horrible by comparison
18:49:46 <jmcarthur> yeah
18:49:50 <edwardk> exactly =)
18:49:52 <xenocons> is there a haskell to JS compiler?
18:50:01 <edwardk> @google ghcjs
18:50:03 <lambdabot> https://github.com/ghcjs/ghcjs
18:50:12 <xenocons> nice
18:50:31 <jmcarthur> also see projects like fay
18:50:40 <xenocons> hmm
18:50:45 <jmcarthur> @google fay language
18:50:46 <lambdabot> http://fay-lang.org/
18:50:47 <lambdabot> Title: The Fay Programming Language — A Haskell subset
18:50:57 <xenocons> its actually hard to find JS compilers that are equivilant to js_of_ocaml
18:51:13 <xenocons> there is like 4 F# ones which are pretty dissapointing
18:51:18 <xenocons> jmcarthur: nice
18:52:02 <Nisstyre-laptop> there is a Racket one
18:52:05 <Nisstyre-laptop> whalesong
18:52:05 <xenocons> that looks like a proper to JS compiler
18:53:40 <startling> writing a lisp -> x compiler is cheating.
18:53:58 <hpaste> sw2wolf pasted “How to fix such a error in hackage ?” at http://hpaste.org/78702
18:56:13 <cmccann> startling, what's wrong with compiling an AST? :D
18:56:31 <Shin-LaC> what library should I use to read XML?
18:56:33 <akahn> If I need to cache the result of some HTTP requests and use that throughout my program, would I turn to the State monad?
18:56:44 <startling> cmccann: too easy
18:57:03 <larss> is there a function like zipWith that calls a function with all the combinations of lists elements
18:57:37 <ion> larss: liftA2
18:57:37 <cmccann> all combinations meaning the cartesian product?
18:58:03 <cmccann> > liftA2 (*) [2,3] [5,7]
18:58:05 <lambdabot>   [10,14,15,21]
18:58:05 <jmcarthur> > liftA2 (,) [1..3] [4..6]
18:58:06 <lambdabot>   [(1,4),(1,5),(1,6),(2,4),(2,5),(2,6),(3,4),(3,5),(3,6)]
18:58:08 <Nereid> > liftA2 f [a,b] [c,d,e]
18:58:09 <lambdabot>   Ambiguous type variable `c0' in the constraints:
18:58:09 <lambdabot>    (GHC.Show.Show c0)
18:58:09 <lambdabot>     ...
18:58:17 <cmccann> pf
18:58:17 <Nereid> > liftA2 f [a,b] [c,d,e] :: [Expr]
18:58:19 <lambdabot>   [f a c,f a d,f a e,f b c,f b d,f b e]
18:58:21 <larss> that's it thanks
18:58:25 <jmcarthur> > c
18:58:27 <lambdabot>   c
18:58:35 <Shin-LaC> there are several libraries and I'm not sure which one I should choose
18:58:36 <ion> > (c++)
18:58:37 <cmccann> no, no, I think we need more people demonstrating with lambdabot
18:58:37 <lambdabot>   No instance for (Data.Monoid.Monoid Debug.SimpleReflect.Expr.Expr)
18:58:37 <lambdabot>    arisi...
18:59:30 <xenocons> ah yes, 4 chan the only place where tail recursion turns into (tail (anus! 'my))
18:59:56 * xenocons Nisstyre-laptop i shouldn't have clicked on that link
19:00:03 <cmccann> heh
19:01:24 <xenocons> its actually a cool tricky though, impractical but cool
19:01:28 <xenocons> trick*
19:01:40 <xenocons> (http://news.ycombinator.com/item?id=2657277) first comment explains it
19:03:14 <startling> it's a good joke.
19:03:23 <larss> how about the other way around for list comprehensions, is there a syntax similar to this [(i,j) | i <- [1,2], j <- [3,4]] that returns [(1,3), (2,4)] ?
19:03:57 <xenocons> lol
19:04:08 <xenocons> having a chuckle at the haskell teases on the4chan thingy
19:04:22 <cmccann> > [(x,y) | x <- [1,2] | y <- [3,4]]
19:04:24 <lambdabot>   [(1,3),(2,4)]
19:04:38 <cmccann> that's a GHC extension I think
19:04:51 <larss> ah. nice one though
19:05:37 <Shin-LaC> ok, I'll try HXT
19:06:12 <larss> thanks for help everyone
19:08:44 <xenocons> there are some cool comments in there..
19:08:55 <xenocons> C has a 'goes to' operator, <-- heh
19:08:59 <xenocons> and runs to <----
19:13:11 <jrunning>  
19:14:17 <shachaf> jrunning makes a good point, though I think that
19:15:34 <latermuse> when is it necessary to use (@)?
19:15:47 <shachaf> I think (@) is a syntax error.
19:16:07 <shachaf> Cale: I think I broke lambdabot. :-( Sorry.
19:16:14 <shachaf> Oh, no I didn't.
19:16:17 <shachaf> @botsnack
19:16:18 <lambdabot> :)
19:16:22 <latermuse> like: case e of {xs@(x:rest) -> if x==0 then rest else xs}
19:16:27 <shachaf> latermuse: Oh.
19:16:32 <shachaf> It's never necessary to use @
19:16:52 <latermuse> is it ever recommended?
19:17:02 <elliott> can someone make haskell-src-exts not freeze my system when i try to compile it
19:17:04 <latermuse> or rather, under which situations would you use it?
19:17:45 <shachaf> latermuse: I recommend searching some codebase for it. :-)
19:20:35 <latermuse> shachaf: got it. thanks :)
19:21:35 <ion> elliott: Huh. Does it overheat or something?
19:21:37 <shachaf> latermuse: I mean, I can give you the definition, but I suspect you already have that.
19:21:53 <latermuse> shachaf: yes, I already have it. I was just wondering when it is useful.
19:22:12 <latermuse> its just syntactic sugar, correct?
19:22:50 <elliott> ion: it just uses a ton of RAM and CPU :p
19:29:11 <sw2wolf> What's the type of "const . return"?
19:29:31 <startling> :t const . return
19:29:38 <shachaf> sw2wolf: Have you tried ghci? :-)
19:29:54 <lambdabot> Monad m => a -> b -> m a
19:29:55 <sw2wolf> shachaf: this box cannot run ghci
19:29:58 <startlebot> sw2wolf: const . return :: Monad m => a -> b -> m a
19:30:00 <sw2wolf> now
19:30:18 <shachaf> sw2wolf: tryhaskell.org?
19:32:02 <sw2wolf> shachaf: thx
19:45:04 <Nisstyre-laptop> sw2wolf: lambdabot is good for that sort of thing
19:45:30 <shachaf> Right now lambdabot isn't good for much of anything. :-(
19:45:32 <shachaf> My fault.
19:45:41 <Nisstyre-laptop> ideone.com and codepad.org can run Haskell programs (although they can't do input)
19:45:44 <edwardk> oh?
19:45:50 <edwardk> @botsnack
19:45:56 <edwardk> you killed her?
19:46:03 <shachaf> Sort of.
19:46:07 <Nisstyre-laptop> and codepad just has hugs
19:46:18 <shachaf> I was trying to demonstrate how harmless it was to do X.
19:46:19 <edwardk> an unacknowledged botsnack is about the saddest thing ever
19:46:24 <edwardk> hahahah
19:46:38 <lambdabot> :)
19:46:45 <shachaf> hi lambdabot
19:46:54 * edwardk hugs lambdabot.
19:47:22 <Clint> poor bot
19:48:14 <xtremenoob> im having monomorphism issues using Data.Array.IArray
19:48:32 <xtremenoob> a = array (1,100) ((1,1) : [(i, i) | i <- [2.0 ..100]])
19:48:48 * lambdabot hugs edwardk.
19:49:01 <xtremenoob> Specifically I am confused as to how to type the variable declaration
19:49:14 <xtremenoob> a :: ???
19:49:19 <xenocons> those slides were helpfull for understanding IO ()
19:49:34 <shachaf> xtremenoob: You could try declaring it in ghci and seeing what type is inferred.
19:49:42 <shachaf> Maybe with -XNoMonomorphismRestriction.
19:49:51 <shachaf> Or alternatively just :t array (1,100) ...
19:50:23 <xtremenoob> I used the xNoMo flag and the array is then useless
19:50:34 <xtremenoob> Rather ghci cant tell its type
19:50:35 <rwbarton> that doesn't look right
19:50:47 <rwbarton> what do you *want* the type to be?
19:50:51 <xtremenoob> Int
19:50:58 <rwbarton> of the array
19:51:04 <xtremenoob> I just want to declare an array of ints
19:51:06 <rwbarton> an array, indexed on Int, of Ints?
19:51:09 <rwbarton> then don't write 2.0
19:51:12 <xtremenoob> right
19:51:41 <xtremenoob> prior to instantiating a, i need a type declaration right /
19:51:42 <xtremenoob> ?
19:51:51 <shachaf> "instantiating"?
19:51:57 <xtremenoob> assignment rather
19:52:03 <Nereid> no
19:52:21 <shachaf> That thing you have there works fine for me with rwbarton's modification.
19:52:33 <shachaf> That is, I can type "array (1,100) ((1,1) : [(i, i) | i <- [2 ..100]])" into ghci and get a result.
19:52:45 <xtremenoob> I cannot without using xnomo
19:52:49 <xenocons> inference, its a helluva drug
19:52:52 <Nereid> why not just [(i,i) | i <- [1..100]]?
19:52:59 <Nereid> well yes, turn off the MR
19:53:38 <Nereid> or give a type annotation
19:53:47 <xtremenoob> What does that mean?
19:53:57 <Nereid> a :: ...; a = ...
19:53:57 <xtremenoob> Type annotation
19:54:05 <xtremenoob> Yes thats what I am trying now.
19:54:14 <xtremenoob> Lacked the terminology to describe
19:54:25 <Nereid> but if you turn off the MR and don't give a type annotation, it'll just make a polymorphic
19:54:43 <rwbarton> (I guess Ix is not defaultable? And xtremenoob is loading this from a .hs file?)
19:54:49 <applicative> array (1,100::Int) ((1,1) : [(i, i) | i <- [2 ..100::Int]]
19:55:01 <Nereid> or that
19:56:04 <applicative> xtremenoob: ^^^ thats enough to tell it what you mean by '1' etc
19:56:41 <shachaf> You don't even need one of the ::Ints.
19:57:08 <applicative> indeed
19:59:32 <xtremenoob> What would be the proper type annotation for the array variable a ?
20:00:51 <applicative> your array above is a :: Array Int Int; array (1,100) ((1,1) : [(i, i) | i <- [2 ..100]]
20:01:34 <Nereid> I don't know why you don't just write [(i,i) | i <- [1..100]]
20:01:36 <applicative> your array above is a :: Array Int Int; a = array (1,100) ((1,1) : [(i, i) | i <- [2 ..100]]
20:01:37 <applicative> rather
20:06:24 <xenocons> is there a verbatim string operator in haskell
20:06:48 <shachaf> That depends on what a verbatim string operator is.
20:06:52 <xenocons> i.e. "c:\test.txt" vs "C:\\test.txt"
20:07:03 <shachaf> You can probably do something with quasiquotes.
20:07:04 <xtremenoob> like a toString() ?
20:07:14 <startling> xenocons: you want to enter the former and get the latter?
20:07:21 <xenocons> startling: being able to use the former
20:07:29 <startling> xenocons, use it how
20:07:34 <shachaf> You can write foo such that [foo|C:\test.txt|] = "C:\\test.txt"
20:07:38 <xenocons> readFile @"C:\test.txt"
20:07:50 <xenocons> (using @ as the example operator)
20:08:06 <startling> xenocons: right, haskell has nothing like that. you can write a quasiquoter as shachaf says, but I wouldn't.
20:08:17 <xenocons> yeah, if thats the case then escaping slashes is easier
20:08:53 <shachaf> You don't have to escape slashes. Only backslashes. :-)
20:09:01 <xtremenoob> applicative : a = array (1,100::Int) 	((1,1) : [(i, i) | i <- [2 ..100]])
20:09:04 <xtremenoob> yields
20:09:13 <xenocons> startling: heh right
20:09:15 <xtremenoob>  No instance for (IArray a0 Int)       arising from a use of `array'     Possible fix: add an instance declaration for (IArray a0 Int)     In the expression:       array (1, 100 :: Int) ((1, 1) : [(i, i) | i <- [2 .. 100]])     In an equation for `a':         a = array (1, 100 :: Int) ((1, 1) : [(i, i) | i <- [2 .. 100]])
20:09:19 <shachaf> xtremenoob: Don't use tabs. :-(
20:09:28 <shachaf> xtremenoob: Anyway, just give it an explicit type.
20:10:09 <xtremenoob> Which was my original question; BTW Im using Data.List.IArray
20:10:21 <xtremenoob> err Data.Array.IArray
20:10:44 <startling> is there a nice way to get stdin as a lazy bytestring or do I need to mess around with file handles?
20:12:10 <Eduard_Munteanu> startling: getContents :: IO ByteString  ?
20:12:24 <Eduard_Munteanu> "getContents. Equivalent to hGetContents stdin. Will read lazily"
20:12:28 <startling> Eduard_Munteanu: nice, didn't see that.
20:13:13 <Eduard_Munteanu> 'interact' should do too.
20:13:35 <startling> I'm conditionally writing to a file instead of stdout, though
20:14:19 <startling> interact :: (X -> IO x) -> IO () would be a more useful thing imo
20:14:33 <xenocons> is there some sugar for do x <- f; g x
20:15:15 <Eduard_Munteanu> That is sugar itself, for  f >>= g
20:15:24 <applicative> f >>= g
20:15:32 <shachaf> It's actually sugar for f >>= (\x -> g x)
20:15:33 <startling> xenocons: congratulations, you just derived do notation!
20:15:42 <xenocons> heh
20:16:05 <xenocons> i was doing let printFile f x = do x <- f; putStr x
20:16:12 <statusfailed> hahah that's awesome
20:16:14 <xenocons> printFile (readFile "C:\\test.txt")
20:16:37 <xenocons> er
20:16:38 <Hafydd> That's what comes of learning do notation without knowing what a monad is.
20:16:46 <xenocons> let printFile f = do x <- f; putStr x sorry
20:16:51 <startling> Hafydd: meh
20:16:52 <Eduard_Munteanu> @undo do {x <- f; g x}
20:17:00 <shachaf> Hafydd: Nothing wrong with learning about do notation without knowing what a monad is.
20:17:01 <Eduard_Munteanu> :(
20:17:03 * statusfailed blinks
20:17:04 <applicative> It's best to know what a monad is.
20:17:07 <applicative> NOT
20:17:08 <applicative> rather
20:17:18 <shachaf> Especially if IO is the only monad you're dealing with anyway.
20:17:53 <xenocons> sweet, so i can do let printFile f = f  >>= putStr
20:17:55 <xenocons> hrmm
20:18:09 <xenocons> wonder if i can flip then remove need for parameter
20:18:14 <shachaf> printFile = (>>= putStr)
20:18:16 <Hafydd> =<<
20:18:21 <xenocons> oh right
20:18:22 <xenocons> cool
20:18:43 <xenocons> then you dont really even need the printFile function
20:18:49 <applicative> printfile = (putStr  =<<)
20:18:51 <edwardk> xenocons: exactly =)
20:19:14 <xenocons> cool
20:19:17 <Hafydd> printFile = (=<<) putStr
20:20:14 <applicative> xenocons: but it is advisable to go through these motions repeatedly at first :)
20:20:35 <xenocons> of course
20:20:45 <xenocons> do notation was just an eyesore though
20:20:57 <byrdmansniper> whats the haskell command to compare a boolean value to true, i.e. bool == true
20:21:11 <startling> byrdmansniper, if x then y else z
20:21:17 <Eduard_Munteanu> (== True)
20:21:24 <startling> or "id" I guess
20:21:25 <byrdmansniper> ok
20:21:27 <Eduard_Munteanu> :)
20:21:28 <byrdmansniper> thanks
20:21:38 <startling> id True == True; id False == False
20:21:46 <Hafydd> What's a Haskell command?
20:22:10 <startling> Hafydd: they're for when GHC is acting surly
20:22:46 <byrdmansniper> wait so i would just type the booleans name and do name == true
20:22:57 <Hafydd> No, just use the boolean itself.
20:23:01 <startling> byrdmansniper: why do you think you need this?
20:23:19 <byrdmansniper> homework assignment
20:23:24 <Eduard_Munteanu> byrdmansniper: normally you'd e.g. pattern-match on a boolean value
20:23:36 <Eduard_Munteanu> like    f True = ...
20:23:58 <while1> Hello everyone, I want to pretty my haskell data to JSON string, how?
20:24:02 <startling> byrdmansniper, you realize (== True) is useless
20:24:03 <Eduard_Munteanu> byrdmansniper: startling is asking what you're doing with it
20:24:08 <applicative> while1: aeson?
20:24:10 <startling> while1, aeson
20:24:12 <byrdmansniper> oh
20:24:32 <byrdmansniper> i am making a while loop with built in methods and variables the teacher made in haskell
20:24:33 <while1> aeson is a library?
20:24:39 <applicative> while1: yes
20:24:40 <Hafydd> I read: "< while1> Hello everyone, I want to feel pretty my haskell data to JSON string, how?"
20:25:13 <bartamues> I have a question that I think relates to state monads: How would I implement a PRNG? Say just a simple Xorshift. It initially seems like a PRNG is by definition impossible with a purely functional language
20:25:34 <while1> Hafydd: Yes
20:25:34 <Jesin> <byrdmansniper> wait so i would just type the booleans name and do name == true
20:25:38 <Eduard_Munteanu> bartamues: PRNGs are usually State-like monads.
20:25:40 <startling> bartamues: course not.
20:25:52 <byrdmansniper> sweet!
20:25:55 <Jesin> byrdmansniper: the result of "name == True" is always exactly the same as the result of "name"
20:26:01 <applicative> while1: https://github.com/bos/aeson/tree/master/examples
20:26:01 <byrdmansniper> gotcha
20:26:11 <byrdmansniper> you guys are really helpful
20:26:20 <while1> applicative: Thank you!
20:26:29 <Eduard_Munteanu> bartamues: you probably want to have a look at State first.
20:26:49 <startling> bartamues: you could just write it as a Int -> (Int, Int)
20:27:39 <bartamues> Eduard_Munteanu: Will do
20:27:56 <bartamues> startling: I like that solution
20:28:13 <applicative> while1: there was a pretty simple tutorial the other day http://blog.raynes.me/blog/2012/11/27/easy-json-parsing-in-haskell-with-aeson but it was going the other direction
20:28:18 <mauke> goddammit
20:28:28 <startling> bartamues, it's equivalent to a State Int Int. :)
20:28:34 <Eduard_Munteanu> You just need to hide the state and provide a function that returns a pseudorandom value and updates the internal state.
20:28:48 <mauke> how do I get ghc to pick up existing .o/.hi files from a directory?
20:29:51 <mauke> I'm in a module directory, I've 'cabal build' it, and now I want to compile a little program that uses the freshly compiled module
20:29:57 <bartamues> startling: yeah, I'm seeing that in the type definition right now. That's pretty cool. I think I'm starting to understand Monads a bit better now, which was the goal of my question. Thanks!
20:30:00 <xenocons> cabal is really cool O_O
20:30:02 <ion> while1: Here’s some code of mine. The ToJSON instances in https://github.com/ion1/beagle_bone_pins/blob/master/Generate/Types.hs define the conversions to JSON and https://github.com/ion1/beagle_bone_pins/blob/master/Generate/JSON.hs uses them to generate a JSON file.
20:30:17 <mauke> if I use --make, ghc insists on recompiling everything from source
20:30:21 <startling> bartamues: cool. :) State is an easy monad, but Reader is an easier one.
20:30:47 <mauke> if I don't use --make, ghc ignores my -i directive and complains about undefined references
20:31:02 <Eduard_Munteanu> mauke: mm, I think cabal somehow avoids that, but I'm unsure how.
20:31:09 <mauke> ... actually that means it does pick up the .hi files
20:31:11 <mauke> just not .o
20:31:34 <applicative>  ghc --help   # link three .o files into an executable called "test":  % ghc -o test Foo.o Bar.o Baz.o
20:31:47 <mauke> applicative: yes, that's exactly what I don't want to do
20:31:55 <shachaf> mauke: -odir?
20:31:58 <applicative> ah
20:32:16 <shachaf> Ah, no.
20:32:21 <mauke> that's for output
20:32:46 <Eduard_Munteanu> Supposedly ghc --make is the bare minimum one can expect, in the absence of a reasonable build system.
20:33:07 <mauke> looks like ghc just can't do this
20:33:11 <shachaf> mauke: Are you sure?
20:33:42 <mauke> no
20:33:48 <mauke> but I don't see anything in the manual
20:33:56 <shachaf> mauke: shachaf@carbon:~/iv$ ghc -odir blah/ -hidir blah/ foo.hs # shachaf@carbon:~/iv$ rm blah/Main.o # shachaf@carbon:~/iv$ ghc -odir blah/ -hidir blah/ foo.hs # [1 of 1] Compiling Main             ( foo.hs, blah/Main.o )
20:35:15 <mauke> ?
20:35:31 <mauke> one of us is very confused
20:35:36 <shachaf> It's probably me.
20:35:46 <shachaf> I think I'm not understanding the issue.
20:36:16 <mauke> I've got a module in dist/build/Some/Module.{o,hi}
20:36:31 <mauke> I've got a program in t/hello.hs
20:36:40 <shachaf> Oh, I see.
20:36:58 <mauke> I want to compile t/hello.hs using the directory hierarchy under dist/build/
20:37:19 <shachaf> I'm not sure if that's possible.
20:37:48 <shachaf> Evidence that it's not possible is that cabal tends to compile files twice when you have a library and an executable.
20:38:12 <mauke> this is fucking stupid
20:39:02 <shachaf> Maybe the people in #ghc would know.
20:39:25 <jmcarthur> shachaf: but you can at least have the executable depend on the library within the same cabal project and separate their sources
20:39:42 <shachaf> jmcarthur: "depend on"?
20:39:48 <shachaf> Does it still compile the library code twice?
20:39:54 <jmcarthur> yeah, as in list in the dependencies
20:39:56 <jmcarthur> nope
20:39:59 <shachaf> Oh.
20:40:05 <shachaf> How does it do that?
20:40:15 <jmcarthur> it just uses the library it just built
20:40:24 <mauke> how?
20:40:27 <shachaf> Oh, that's the "in-place registering" thing?
20:41:12 <shachaf> cabal register --inplace # register the package in the build location, so it can be used without being installed
20:41:26 <jmcarthur> you don't have to use that explicitly
20:41:45 <jmcarthur> you just have to have the sources in separate hs-source-dirs
20:41:48 <shachaf> How do you get GHC to respect package-conf.inplace?
20:42:16 <jmcarthur> i've never had to fiddle with that
20:42:23 <jmcarthur> so i don't know
20:42:55 <shachaf> I think that'll do what mauke wants.
20:43:10 <shachaf> mauke: ghc -package-db dist/package-conf.inplace ...?
20:43:17 <jmcarthur> but in direct response to "Evidence that it's not possible is that cabal tends to compile files twice when you have a library and an executable.", i think the only reason this happens is that cabal puts the object files in different places. correct me if you know i'm wrong, though
20:43:22 <shachaf> package.conf.inplace
20:43:30 <mauke> ooh, interesting
20:43:37 <shachaf> jmcarthur: Yes, I was clearly just wrong when I said that.
20:43:48 <shachaf> Since apparently it's possible.
20:44:32 <shachaf> cabal generates this inplace file with ("/usr/local/bin/ghc-pkg",["update","-","--global","--user","--package-db=dist/package.conf.inplace","-v2"])
20:45:16 <shachaf> Though I guess that's not relevant to you.
20:45:20 <startling> how should I write the lazy bytestring that aeson's "encode" gives me? is Data.ByteString.Lazy.Char8.putStrLn alright, since json should not contain anything other than ascii and escaped unicode codepoints?
20:45:54 <shachaf> startling: You should rather use Data.ByteString.Lazy.putStr and have a newline at the end of it. :-(
20:46:12 <shachaf> startling: By the way, are you sure that Aeson escapes Unicode codepoints?
20:46:26 <startling> shachaf: no. but that's how json is supposed to be.
20:46:26 <shachaf> Past 127, that is.
20:46:30 <shachaf> startling: No it's not.
20:46:35 <startling> isn't it?
20:46:38 <shachaf> It's not.
20:46:46 <startling> oh, I guess I'm mistaken.
20:46:52 <startling> shachaf: no, I'm not sure, then.
20:46:53 <shachaf> JSON can contain any code point within "", other than special characters.
20:47:12 <shachaf> But presumably Aeson.encode takes care of that somehow?
20:47:18 <startling> shachaf: I have no idea.
20:47:38 <shachaf> Yes, encode gives you UTF-8
20:48:00 <mauke> shachaf++ jmcarthur++
20:48:02 <shachaf> Just don't use .Char8 if you can avoid it. :-)
20:48:14 <mauke> now I just have to find out why dash sucks so much
20:48:21 <startling> shachaf: if it's already utf-8 encoded, why does it matter?
20:48:31 <shachaf> startling: Principles.
20:48:44 <shachaf> I mean, you're printing bytes, not Char8s.
20:49:22 <startling> OH
20:49:38 <startling> putStrLn is only there because it relies on '\n'
20:49:39 <startling> got it.
20:49:43 <shachaf> (Not that there's such a thing as Char8s.)
20:50:11 * startling splits shachaf into 8 chars.
20:50:56 * startling encodes those chars with utr-21 or whatever
20:52:19 <mauke> crap
20:54:26 <ion> corak
20:54:32 <mauke> looks like ghc really really likes to search the current directory for source files anyway
20:54:38 <mauke> -i ftw
20:55:20 <startling> does aeson not have a pretty-printer?
20:55:57 <shachaf> @google aeson pretty printer
20:57:19 <lambdabot> http://hackage.haskell.org/package/aeson-pretty
20:57:20 <lambdabot> Title: HackageDB: aeson-pretty-0.7
20:57:25 <startling> oh, neat.
20:59:33 <mauke> TAP++
20:59:56 <shachaf> TAP?
21:00:04 <mauke> test anything protocol
21:00:20 * startling tests mauke.
21:00:41 <mauke> I just wrote a TAP module in Haskell and used it to test itself ... sort of
21:01:24 <edwardk> has anyone been able to get stackage set up and running?
21:02:20 <edwardk> i was going to spend a few hours working on putting my packages on it tonight, but it blows up pretty spectacularly for me before i even touch it. i upgraded to the latest platform, upgraded Cabal and cabal-install, and it can't derive a build plan or something
21:04:00 <shachaf> @hooray
21:04:07 <lambdabot> Unknown command, try @list
21:04:19 <shachaf> @botsnark
21:04:25 <lambdabot> :)
21:04:35 <edwardk> @botsmack
21:04:37 <startling> lambdabot seems distracted lately. I wonder if it's plotting something.
21:04:39 <lambdabot> :)
21:04:46 <startling> @botcrack
21:04:51 <lambdabot> :)
21:04:55 <edwardk> @botattack
21:05:01 <lambdabot> stop it
21:05:03 <lambdabot> Unknown command, try @list
21:05:07 <mauke> does the 'detailed-1.0' testing thing in cabal actually work?
21:05:10 <ion> @botslack
21:05:17 <lambdabot> :)
21:05:18 * edwardk stops
21:05:20 <startling> mauke: it seems to, but nothing supports it
21:05:52 <mauke> oh, good
21:11:13 * hackagebot mega-sdist 0.2.0.6 - Handles uploading to Hackage from mega repos  http://hackage.haskell.org/package/mega-sdist-0.2.0.6 (MichaelSnoyman)
21:11:15 * hackagebot http-conduit 1.8.4.4 - HTTP client package with conduit interface and HTTPS support.  http://hackage.haskell.org/package/http-conduit-1.8.4.4 (MichaelSnoyman)
21:11:17 * hackagebot http-conduit 1.8.4.5 - HTTP client package with conduit interface and HTTPS support.  http://hackage.haskell.org/package/http-conduit-1.8.4.5 (MichaelSnoyman)
21:11:31 <edwardk> is there irony in the fact that the first package stackage fails to compile for me is one of snoyman's?
21:12:04 <ion> heh
21:12:16 <edwardk> rejecting: http-conduit-1.8.4.3 (conflict: cprng-aes==0.3.0, http-conduit => cprng-aes>=0.2 && <0.3)
21:12:53 <shachaf> -- TODO: instance Zoom m m k a a => Zoom (ContT r m) (ContT r m) k a a where
21:13:00 <shachaf> Should two of those ms be ns?
21:13:00 <startling> edwardk: haha
21:13:34 <edwardk> shachaf: they had to agree iirc back when zoom took a lens
21:13:44 <edwardk> now that zoom takes a traversal i don't know how to do it at all
21:13:51 <shachaf> Hmm.
21:13:59 <shachaf> I was hoping it'd be one of those "guided by the types" deals.
21:14:12 <shachaf> But when zoom x y = y typechecks it doesn't really help.
21:14:23 <edwardk> nah its a lot messier than that
21:14:37 <shachaf> Oh well. Maybe you actually have to figure Zoom out to do it.
21:14:53 <edwardk> you can write out a hand rolled zoom for a Lens for ContT pretty easily
21:15:09 <edwardk> but in its shinier more general form it gets trickier
21:24:02 * applicative isn't sure he's following this 'Stackage' idea 
21:24:15 <Nereid> stackoverflow + hackage?
21:25:03 <applicative> http://www.yesodweb.com/blog/2012/11/stable-vetted-hackage  https://github.com/fpco/stackage
21:25:08 <startling> Nereid: oh god
21:25:35 <applicative> is it that there is an immense pile of libraries which are all somehow buildable together
21:25:44 <applicative> in any order etc
21:26:00 * applicative secretly loves so called cabal hell
21:26:13 * hackagebot wai-handler-devel 1.3.0.3 - WAI server that automatically reloads code after modification.  http://hackage.haskell.org/package/wai-handler-devel-1.3.0.3 (MichaelSnoyman)
21:27:35 <latermuse> What would the complexity of this small algorithm be? Data.List.Split.chunksOf 120 $ take 10000 [1..]
21:27:51 <mauke> O(1)
21:27:52 <Nereid> O(1)
21:27:54 <shachaf> "not very complex"
21:28:01 <Nereid> damn, mauke beat me to it
21:28:23 <startling> shachaf: "pretty simple"
21:28:40 <shachaf> startling: I wouldn't call it pretty.
21:28:59 <startling> "ugly simple"?
21:29:45 <latermuse> hahaha thanks guys :)
21:30:50 <latermuse> By the way, how do you guys determine the complexity of haskell programs? Its easy to do it with imperative languages, but im not sure how it works in haskell.
21:31:37 <Nereid> it's not really imperative vs functional that makes it harder.
21:31:37 <shachaf> It is?
21:31:39 <Nereid> it's the laziness.
21:32:02 <popl> Nereid: That's what mauke does. Constantly.
21:32:23 <Nereid> popl: that was awful
21:32:31 <popl> I propose we strap weights about his ankles and wrists.
21:32:43 <mauke> of constant weight
21:33:21 <Nereid> all algorithms are O(1) in practice
21:33:34 <Nereid> bounded by the lifetime of the universe or whatever
21:33:36 <shachaf> O(no)
21:33:48 <mauke> O(yeah)
21:33:50 <Nisstyre-laptop> Nereid: not all functions are well known
21:34:08 <Nereid> really? name the first non-well-known function
21:34:17 <Fuuzetsu> O(O(O(O(O(O(O...
21:34:29 <Nisstyre-laptop> Nereid: f x = "whatever"
21:34:45 <Nereid> is that the first?
21:34:48 <mauke> fix O
21:34:56 <Nereid> > fix o
21:34:59 <lambdabot>   Couldn't match expected type `a0 -> a0'
21:34:59 <lambdabot>              with actual type `Debu...
21:34:59 <Nisstyre-laptop> Nereid: O(1) is for things like * / ^ + - ! log ln etc...
21:35:19 <shachaf> Nereid: By one ordering, yes.
21:35:20 <Nereid> Nisstyre-laptop: I don't know what your point is.
21:35:43 <Nisstyre-laptop> Nereid: my point is that not every funtion is O(1) -_-
21:35:45 <Fuuzetsu> log doesn't run in constant time, does it?
21:35:56 <Nereid> I didn't say function, and I also said "in practice
21:35:56 <Nereid> "
21:35:59 <shachaf> Nor do any of the other operators Nisstyre-laptop mentioned.
21:36:00 <Nisstyre-laptop> Fuuzetsu: doesn't matter, neither does *
21:36:23 <Fuuzetsu> yeah but I didn't want to nit-pick so I picked the most obvious one
21:36:52 <Nisstyre-laptop> Fuuzetsu: well if you gave someone an expression with log in it they wouldn't say it's not a closed form because of that
21:37:24 <shachaf> What does that have anything to do with it?
21:37:43 <popl> mauke: I was thinking of Harrison Bergeron (obviously).
21:37:56 <popl> or not-obviously
21:37:58 <popl> I don't know.
21:44:24 <Mar> ok
21:45:23 <Mar> so if i did "let b = drop 2 [2,3,5] in b"...would it assign a new list with the first 2 elements only to the variable b?
21:45:46 <mauke> no
21:45:49 <Mar> ok
21:45:52 <edwardk> popl: i got it. i loved that story as a kid =)
21:45:57 <Fuuzetsu> > drop 2 [2,3,5]
21:45:58 <Mar> then what does it do??
21:45:59 <lambdabot>   [5]
21:46:05 <Mar> yes
21:46:12 <Mar> but does b = [5]?
21:46:13 * hackagebot eq 3.0 - Leibnizian equality  http://hackage.haskell.org/package/eq-3.0 (EdwardKmett)
21:46:16 <mauke> yes
21:46:23 <mauke> but [5] is not the first two elements
21:46:30 <Mar> oh ok
21:46:31 <Mar> yeah
21:46:34 <Mar> oops
21:46:59 <Fuuzetsu> it will simply evaluate to [5]
21:47:09 <Mar> so if i have a function lastElement :: [a] --> [b]
21:47:27 <Mar> and lastElement = length [a - 1
21:47:50 <mauke> > last [2,3,5]
21:47:52 <lambdabot>   5
21:48:09 <Mar> would it be correct to say "lastElement let b = drop x [a] in b
21:48:18 <Mar> ohh ok
21:48:46 <Mar> i know
21:48:56 <Mar> but i have to code my own version of the last function
21:49:20 <Fuuzetsu> you can do it elegantly using pattern matching
21:49:56 <Fuuzetsu> @src last
21:49:56 <lambdabot> last [x]    = x
21:49:56 <lambdabot> last (_:xs) = last xs
21:49:56 <lambdabot> last []     = undefined
21:51:11 <Fuuzetsu> I believe that the way you want to do it is let myLast x = x !! (lenght x) - 1
21:51:44 <Fuuzetsu> (typo)
21:52:30 <Fuuzetsu> ...and apparently broken
21:52:49 <Fuuzetsu> let myLast x = x !! ((length x) - 1)
21:53:48 <Mar> where x is the last element of the list
21:54:00 <mauke> no, x is the list
21:56:13 * hackagebot ircbot 0.5.2 - A library for writing irc bots  http://hackage.haskell.org/package/ircbot-0.5.2 (JeremyShaw)
21:56:15 * hackagebot syb-extras 0.2.3 - Higher order versions of the Scrap Your Boilerplate classes  http://hackage.haskell.org/package/syb-extras-0.2.3 (EdwardKmett)
21:56:22 <Fuuzetsu> saying let b = {whatever} in b   is no very meaningful; you probably want to do something to be; let b = {whatever} in a + b is something you'd more commonly see
21:56:33 <Fuuzetsu> not*
21:58:06 <Mar> let lastElement  x = x!! (length x)-1)
21:58:12 <Mar> ?
21:58:15 <Mar> that?
21:58:56 <Fuuzetsu> that will do what you want
21:59:01 <shachaf> Mar: You should try to balance your parentheses and things. :-)
21:59:05 <Fuuzetsu> (fix those spaces)
21:59:19 <Fuuzetsu> you could now do something like
22:00:07 <Fuuzetsu> let lastElement x = x !! ((length x) - 1) in lastElement [1, 2, 3]
22:02:21 <Mar> ok
22:02:30 <Mar> but im creating a function
22:02:44 <Mar> lastElement [a]  -> [b]
22:02:52 <mauke> no, you're not
22:03:02 <Fuuzetsu> you mean lastElement [a] -> a
22:03:02 <Mar> yes thats what im supposed to do
22:03:09 <Fuuzetsu> you can't do that
22:03:19 <shachaf> You can create a function :: [a] -> [b]
22:03:24 <shachaf> But it won't do what you want.
22:03:28 <Fuuzetsu> yeah
22:05:31 <Mar> lastElement : [a]  -> [a]
22:05:36 <Fuuzetsu> ::
22:05:41 <Mar> im supposed to return a list containing the last element
22:06:00 <Twey> Mar: [a] → [b] is a function that takes a list of an arbitrary element type a and produces a list of an arbitrary element type b — e.g. given a list of Strings it might produce a list of Ints.
22:06:09 <Fuuzetsu> it's possible but why does it have to be a list?
22:06:14 <Mar> idk
22:06:18 <Mar> thats what the teacher said
22:06:39 <Fuuzetsu> You sure?
22:06:49 <Twey> Fuuzetsu: Possibly to avoid introducing Maybe
22:06:57 <Fuuzetsu> then
22:08:34 <Mar> how about reversing a string?
22:08:58 <Mar> this would be a recursive function
22:09:00 <Mar> right?
22:09:00 <Twey> Mar: How about it?
22:09:07 <Twey> Yes
22:09:25 <Mar> im trying to write a function :  reverseString String -> String
22:09:46 <Fuuzetsu> reverseString :: String -> String
22:10:02 <shachaf> Mar: Have you read any introduction to Haskell?
22:10:14 <shachaf> You should probably read one. I don't think you know enough for this to be very useful to you.
22:10:49 <Mar> i have already looked at some basics
22:10:54 <Fuuzetsu> shachaf: What's your typing speed?
22:11:12 <shachaf> Fuuzetsu: 22,804
22:11:24 <Twey> Mar: Not enough — try reading learnyouahaskell.com
22:11:35 <Fuuzetsu> Is that in gallons per Newtons?
22:11:45 <Nereid> shachaf: wow, that's fast! mine is only 8
22:11:46 <rwbarton> or tryhaskell.com
22:12:58 <Twey> Maybe not tryhaskell.com — I got a timeout on a sort of a pre-sorted three-element list :þ
22:13:17 <Fuuzetsu> huh
22:15:56 <Fuuzetsu> Apparently it takes sort"stuff" fine
22:16:00 <Fuuzetsu> without the space
22:16:27 <Twey> Heh, irrelevant, just happened to go through that time
22:16:45 <Fuuzetsu> That's not what I'm saying here
22:16:57 <Mar> if im doing a reverseString function...do i always have to have reverseString before the variable that i want to declar?
22:17:12 <shachaf> Did you know "hello" doesn't get compiled into the same thing as ['h','e','l','l','o']?
22:17:19 <Fuuzetsu> no
22:17:22 <Fuuzetsu> and no
22:18:09 <Twey> shachaf: It doesn't?
22:18:15 <Twey> Is it strict?
22:18:36 <Twey> Mar: Your question doesn't make sense
22:18:41 <shachaf> Oh, I'm sure it has the same strictness.
22:19:16 <Fuuzetsu> Twey: Pretty sure he's asking whether he can define a function lower down in the file.
22:19:22 <koala_man> shachaf: what's the difference?
22:19:24 <Twey> I don't think so.
22:20:03 <shachaf> koala_man: One gets turned into unpackCString# and the other into a bunch of conses.
22:20:18 <shachaf> Fuuzetsu: If you play mind reader, it only encourages people to ask vague questions.
22:20:32 <Fuuzetsu> I guess.
22:20:39 <koala_man> shachaf: even with optimization?
22:20:46 <shachaf> koala_man: Why not?
22:21:24 <`nand`> "hello" gets compiled into something like GHC.CString.unpackCString# "hello" ?
22:21:36 <edwardk> `nand`: yes
22:21:44 <`nand`> oh, shachaf said it already
22:21:51 * `nand` is still to slow even today
22:22:07 <shachaf> You're still to slow? I've yet to slow!
22:22:16 <`nand`> too slow
22:22:18 <`nand`> incorrect as well
22:22:23 <`nand`> today has not started well
22:22:30 <shachaf> @localthyme `nand`
22:22:30 <lambdabot> Local time for `nand` is Mon, 03 Dec 2012 07:22:12 +0100
22:24:31 <edwardk> anyone know why stackage bothers to set up both a stackage and stackage-extra repo pointing at hackage just to double the update time?
22:25:36 <`nand`> shachaf: now the question is, which one is faster?
22:25:48 <shachaf> `nand`: The answer is, neither one has a speed.
22:26:14 * hackagebot pointed 3.0.1 - Haskell 98 pointed and copointed data  http://hackage.haskell.org/package/pointed-3.0.1 (EdwardKmett)
22:26:35 <shachaf> Uh oh.
22:26:39 <shachaf> What happened?
22:26:48 <shachaf> Last commit is 3 months ago.
22:26:48 <edwardk> shachaf: dep pump on data-default
22:26:52 <edwardk> er bump
22:26:56 <`nand`> as measured in execution cycles needed to print fully (excluding library calls); assuming we're using the x86_64 code generator?
22:26:59 <edwardk> i just never pushed 3.0.1 to hackage
22:27:09 <shachaf> Ah.
22:27:09 <edwardk> found it by fighting with stackage
22:27:11 <shachaf> instance Default e => Pointed ((,)e) where
22:27:20 <shachaf> That's not compatible with the Applicative instance. :-(
22:27:28 <shachaf> Unless def = mempty, I guess.
22:27:36 <edwardk> if the Default isn't compatible with the Monoid you're screwed in general
22:27:38 <`nand`> I don't think that's necessarily the case
22:27:43 <`nand`> oh?
22:27:46 <elliott> Default is screwed in general :P
22:27:56 <edwardk> that assumption is made more or less across the board in a lot of code
22:28:06 <elliott> why does Default exist :(
22:28:09 <edwardk> otherwise you can you make yet another Default class with an extra law or something
22:28:10 <`nand`> edwardk: maybe Default should be renamed to Unit or something
22:28:12 <shachaf> Don't you get an extra type class depenency?
22:28:24 <edwardk> shachaf: sure. you get one with semigroup too
22:28:27 <`nand`> (of course, that doesn't make a lot of sense without an operation for it to be the unit /to/)
22:28:57 <edwardk> i'm forced to pick some class somewhere. data-default provides something that is compatible with the monoid for all the cases that come up in practice.
22:29:15 <edwardk> and it most importantly doesn't force some other law on you
22:29:39 <shachaf> I suppose Default is about as principled as Pointed.
22:29:41 <elliott> well, I guess Default is a good fit for Pointed
22:29:44 <elliott> in that they're both bad
22:29:51 <edwardk> yep
22:29:56 <edwardk> Pointed is a pile of crap
22:30:06 <simpson> What's the point of Pointed, exactly?
22:30:17 <simpson> It looks like a standalone return...?
22:30:24 <edwardk> simpson: that is basically what it is
22:30:28 <elliott> class Pointed a where points :: a -> NonEmpty String  -- lists the holes used in the pointful expression
22:30:37 <edwardk> elliott: =P
22:31:18 <edwardk> my efforts to get stackage to recognize new packages pushed to hackage are not encouraging me to want to maintain all my packages with it
22:31:41 <elliott> don't you have to update all the version numbers by hand or something
22:32:14 <edwardk> my understanding was it was supposed to magically pull the latest, but i'm not getting that ;)
22:33:20 <edwardk> i just keep getting rejecting: pointed-3.0.1 (global constraint requires ==3.0.0.1)
22:33:24 <edwardk> constraints like that
22:33:47 <shachaf> Is there a list of the packages in "stackage"?
22:33:57 <edwardk> its the 'Stackage.Config'
22:34:18 <edwardk> https://github.com/fpco/stackage/blob/master/Stackage/Config.hs#L58
22:34:21 <rwbarton> how exactly is stackage supposed to work with upgrading
22:34:54 <rwbarton> or in general
22:34:54 <edwardk> rwbarton: the model as i understand it is that everything maintained in stackage gets built against everything else in stackage's latest version
22:35:04 <edwardk> so when you push a new version you can see how it breaks stackage
22:35:17 <edwardk> in theory i'm perfectly okay with this
22:35:31 <edwardk> i just can't get stackage to see any new versions i pushed out =(
22:35:39 <elliott> do you have to cabal update or something
22:35:50 <edwardk> did that, did cabal-dev update, blew everything away
22:35:52 <edwardk> started over
22:35:55 <edwardk> repeated
22:35:57 <edwardk> nothing
22:36:04 <elliott> maybe it is caching something in some hidden file somewhere
22:36:18 <rwbarton> interesting, that's not what i imagined from the name
22:36:37 <elliott> stackage sounds like an infinite tower of bootstrapped hackages
22:36:40 <edwardk> i nuked my ~/.ghc, even
22:37:00 <elliott> have you tried setting fire to your computer and buying a new one and see if it finds it then
22:38:35 <rwbarton> sounds more like unstackage
22:38:48 <edwardk> elliott: that i've yet to bring myself to do. mostly for lack of a lighter
22:38:55 <edwardk> i'm obviously doing something terribly wrong because i can't even get it to work for snoyman's packages
22:39:09 <edwardk> it doesn't see his new version of http-conduit for instance
22:39:59 <edwardk> so my plans to push all my packages into it are kind of on hold. until i can get it to even run
22:40:50 <edwardk> if i comment out snoyman's packages it seems to start some kind of sandboxed build
22:42:21 <edwardk> but then even that crashes it seems
22:44:39 * BMeph wonders if nailing a computer to a tree, and then tossing that, counts as a new sport different from a simple caber toss...
22:49:26 <dsantiago> Earlier there was some discussion about IO actions as functions that return IO actions that can be executed to perform the IO. What then makes those actions finally execute?
22:50:07 <mauke> dsantiago: the runtime system (and it only executes one action)
22:50:21 <mauke> and the IO actions aren't functions themselves
22:50:56 <dsantiago> So is it just that main is hard-coded as the one that will actually make all the IO execute?
22:51:10 <mauke> yes
22:51:49 <dsantiago> And does forkIO also have hard-coding?
22:52:17 <mauke> what do you mean?
22:52:38 <shachaf> dsantiago: It's just like C.
22:52:46 <dsantiago> Well, I guess maybe if you do forkIO in an IO action called from main, and it creates threads that do IO… I guess that could still all come back down to one IO action.
22:52:47 <shachaf> main() is hard-coded to run, and it runs other things.
22:54:26 <dsantiago> I guess I'm just thrown by main also having the same type signature as something taht returns "a list of IO actions to perform."
22:54:44 <shachaf> dsantiago: main *is* just an IO action.
22:55:06 <shachaf> It's the same type because it's the same thing.
22:55:10 <mauke> I don't see the "return" and "list" part
22:55:59 <shachaf> mauke: >>= is just a fancy cons.
22:56:08 <shachaf> Therefore it's a list!
22:57:09 <mauke> hah
22:59:00 <dsantiago> Does this mean if your IO actions get too recursive there can be a space leak beacuse of them?
22:59:33 <mauke> @pl \z x -> (.) f x z
22:59:34 <lambdabot> flip (f .)
22:59:59 <shachaf> dsantiago: Why would it mean that?
23:00:21 <shachaf> If your list is cyclic does it take up too much space because of that?
23:00:25 <shachaf> (Or even if it's infinite.)
23:00:48 <dsantiago> I don't know… it seems like if your whole program is building up a gigantic series of thunks to encapsulate all the IO actions… isn't there that danger?
23:00:58 <dsantiago> I mean, remember, I clearly have no idea what I'm talking about.
23:01:36 <shachaf> What do thunks have to do with it?
23:01:46 <dsantiago> Hm, I don't know.
23:01:54 <dsantiago> I figured that was what you meant by "lists of IO actions."
23:02:00 <dsantiago> Since you can compose the IO actions.
23:02:17 <Nereid> dsantiago: thunks have to do with laziness. this discussion of IO is the same whether we're in a lazy language or not.
23:02:41 <dsantiago> But isn't that deferment of all IO into one big IO action part of laziness?
23:02:43 <dsantiago> Is that done strict?
23:03:03 <mauke> huh?
23:03:07 <mauke> it's not deferred
23:03:11 <mauke> it's just a data structure
23:03:53 <shachaf> dsantiago: IO could work exactly the same as the way it works in Haskell in a strict language.
23:04:21 <mauke> and we could call it "ajax"!
23:04:54 <shachaf> That's not quite the same thing.
23:04:57 <dsantiago> Hm.
23:04:58 <shachaf> But similar.
23:05:03 <mauke> close enough
23:08:02 <shachaf> mauke: Ignoring the choice of language, http://slbkbs.org/toys/callfront.txt
23:08:48 <dsantiago> I thought the idea was that the monads were needed to force the correct order of evaluation of IO due to laziness or something?
23:08:55 <shachaf> dsantiago: Nope.
23:09:09 <mauke> shachaf: is that coffeescript?
23:09:13 <shachaf> mauke: Yes.
23:09:16 <mauke> yuck
23:09:24 <shachaf> I know, man. Malicious scoping and all.
23:09:27 <Nereid> dsantiago: did you read shachaf's SO answer about this?
23:09:45 <dsantiago> Yes.
23:09:53 <ion> CoffeeScript is less painful than JavaScript. I wish it also copied static typing from Google’s Closure Compiler.
23:10:02 <mauke> ion: you're fired
23:10:03 <Nereid> well that should have refuted that idea then
23:10:04 <Nereid> :p
23:10:30 <mauke> dsantiago: *evaluation* of IO is pure because "IO" is simply a data structure
23:10:35 <ion> mauke: You can’t fire me because i quit!
23:10:39 <mauke> so the order doesn't matter
23:11:02 <mauke> on the other hand, the execution of IO actions isn't part of Haskell itself, monads or no
23:11:26 <shachaf> dsantiago: You read my post? In that case I don't need to bother typing it all into this little IRC prompt!
23:11:30 <mauke> monads are just a nice way to structure the composition of stuff
23:12:06 <dsantiago> If you're talking about the one about other ways IO has worked in Haskell, yeah, I didn't understand it very well.
23:12:45 <shachaf> Hmm. I thought I was a bit unclear. :-(
23:13:02 <shachaf> dsantiago: Did you do the exercise?
23:13:47 <dsantiago> I did understand the other post about uniqueness typing in Clean.
23:14:03 <Nereid> sure, but that has little to do with haskell :p
23:14:06 <shachaf> Uniqueness typing is pretty different from the way Haskell does I/O.
23:14:09 <dsantiago> I did not feel like I knew where to start with the exercise.
23:14:16 <dsantiago> Yeah, I know, I was just saying.
23:14:26 <shachaf> dsantiago: OK, then it was completely unclear. :-(
23:14:46 <shachaf> Can you tell me where you get lost, maybe?
23:14:51 <Nereid> I understood it but probably only because I already knew it.
23:14:54 <Nereid> :(
23:15:07 <shachaf> Nereid: Yes, that's what worried about. The same is true for me.
23:15:51 <Nereid> you should write an expository article about this.
23:16:00 <shachaf> I was planning to at one point.
23:16:12 <dsantiago> It is probably as hard for you to remember what it was like to not undersatnd it as for me to describe why I don't…
23:16:16 <dsantiago> I'll try.
23:16:17 <shachaf> It's on my list of things to write about since I'm not happy with the way most other people have written about.
23:16:26 <dsantiago> The part about interpreting a list of IO things to do, I think I undersatnd.
23:16:43 <dsantiago> And I understand the code in the snippet above, I think.
23:16:58 <shachaf> Which snippet, DialogueIO?
23:17:03 <dsantiago> But putting that all together in a function that takes that datatype and then does the IO actions… no idea how to start on that.
23:17:08 <dsantiago> No, the ContIO one.
23:17:10 <shachaf> Ah.
23:17:18 <shachaf> Well, you're allowed to use "real" IO to implement it.
23:17:25 <Nereid> well, you have to.
23:17:31 <shachaf> Right.
23:17:39 <shachaf> So interpret :: ContIO -> IO ()
23:17:56 <shachaf> Now just think about how you write any Haskell function that takes a data type as an argument. :-)
23:18:06 <shachaf> You'll want to pattern-match on it, and then handle each case.
23:19:47 <Mathnerd314> is there a good way to write an extensible type checker? e.g. one where it's easy to replace Hindley-Milner with OutsideIn, or add dependent typing, or...
23:20:17 <dsantiago> YEah, the data structure part makes sense to me… I guess I don't know what to do about recursiviness with IO.
23:20:35 <shachaf> dsantiago: Well, the data structure is recursive. But interpret is also allowed to be recursive. :-)
23:20:52 <dsantiago> I know, it seems like it would have to be.
23:21:15 <dsantiago> I'm sure if I already understood IO and/or monads better, it'd be very clear to me what to do.
23:21:18 <edwardk> Mathnerd314: in many ways that _is_ OutsideIn(X) ;)
23:21:20 <shachaf> OK, start with the simple case.
23:21:23 <dsantiago> Could write this in Clojure, for example.
23:21:41 * shachaf should read the OutsideIn paper.
23:21:43 <edwardk> Mathnerd314: the dependent typing otoh kind of changes the architecture
23:22:28 <shachaf> dsantiago: interpret :: ContIO -> IO (); interpret Exit = ?; interpret (PutStrLn s i) = ?; interpret (GetLine f) = ?
23:22:38 <shachaf> Do them in that order.
23:22:38 <dsantiago> Well, if it's Exit, I assume you just return nothing and let main end?
23:22:57 <shachaf> There's no main -- it's just your interpret function here. But sure. Do you know how to write that?
23:23:04 <dsantiago> I think.
23:23:20 <dsantiago> interpret Exit = return () ?
23:23:33 <Mathnerd314> edwardk: right, that's where it gets interesting, ;-) I looked at Idris and Agda but they don't seem to be written with modularity in mind
23:23:53 <shachaf> Yep.
23:24:00 <shachaf> What about the next one?
23:25:03 <ion> interpret (Fork i j) =
23:25:20 <dsantiago> interpret (PutStrLn s i):rest = do x <- putStrLn s i interpret rest
23:25:42 <Twey> Mathnerd314: If you have a dependently-typed checker, I think you can emulate any other type system
23:26:35 <shachaf> dsantiago: That doesn't type-check (or even syntax-check).
23:26:45 <Nereid> therea re no lists here
23:26:45 <shachaf> Where's the : coming from? What's the second argument to putStrLn doing?
23:26:46 <dsantiago> I figured.
23:27:04 <dsantiago> The : is because you need to have the rest of the list available to recurse on?
23:27:09 <Nereid> what list?
23:27:24 <dsantiago> The list of IO actions.
23:27:29 <Nereid> I see no list.
23:27:29 <dsantiago> Er, IO action specs.
23:27:33 <Mathnerd314> Twey: how do you handle the constraint solving?
23:27:41 <dsantiago> Oh, whoops. Yeah, the structure itself is recursive.
23:27:50 <dsantiago> My bad.
23:27:55 <dsantiago> I was thinking it was a list of actions.
23:28:01 <Twey> Mathnerd314: IIRC Idris actually has a pluggable constraint-solver
23:28:24 <Twey> (not written in the type-system itself, mind)
23:28:28 <shachaf> dsantiago: The interesting part here is that this is "like" a list, as long as you only have things like PutStrLn
23:28:30 <dsantiago> interpret PutStrLn s i = do x <- putStrLn s; interpet i
23:28:43 <shachaf> Yep, that'll work once you fix the syntax.
23:28:52 <shachaf> (You could be putting this into a file and trying it out for yourself! :-) )
23:29:05 <Nereid> there's no point in writing "x <- " though
23:29:11 <dsantiago> Yeah, I was trying to do things in ghci, but it was giving me errors.
23:29:20 <shachaf> Just put it in a file.
23:29:28 <dsantiago> parse error on input =
23:29:32 <shachaf> (Also, when you get errors, read the errors. They're often helpful.)
23:29:41 <shachaf> OK, put it in a file to fix that. :-)
23:30:26 <Nereid> I am pleased at how small a modification is needed to let ContIO take a type parameter.
23:30:30 <shachaf> Anyway, GetLine is different from cons in an important way.
23:31:20 <jerng> I fail to understand how to manually pass (HamletSettings) into a [shamlet| quasi quote... can anyone show me a working example, please?
23:31:54 <shachaf> @where web
23:31:54 <lambdabot> #haskell-web | #happs - http://happstack.com/ | #snapframework - http://snapframework.com/ | #yesod - http://yesodweb.com/
23:32:00 <Nereid> :r
23:32:02 <Nereid> oops
23:32:05 <shachaf> jerng: Maybe #yesod would know more than we do. :-)
23:32:25 <jerng> Ok, thanks!
23:32:59 <shachaf> Hmm, roconnor has a good exercise.
23:33:13 <shachaf> "Exercise for the reader: Extend Dialogue2 to support concurrency. Then check to see if this can still be generalized to a monad in the same way that we have done for sequential I/O."
23:33:35 <shachaf> I don't see why it couldn't, at least depending on what they mean by concurrency.
23:33:38 <Nereid> what's Dialogue2?
23:33:45 <shachaf> Nereid: http://r6.ca/blog/20110520T220201Z.html
23:35:55 <dsantiago> Right, I'm pretty stumped on GetLine… what do you do with the thing you got?
23:36:41 <Nereid> well, the thing you have is a function String -> ContIO
23:36:45 <shachaf> Well, what do you have in scope right no?
23:36:57 <shachaf> "what do I have in scope at this point" would be a really useful feature.
23:37:02 <Nereid> heh
23:37:02 <shachaf> Maybe the new GHC holes do it.
23:37:36 <ion> Typecheck you, ghchole!
23:37:48 <mauke> what has it got in its pockets?
23:37:52 <Twey> …es
23:38:23 <mauke> what has it gotes in its pockets?
23:38:31 <Twey> Heh
23:40:09 <ion> Can one make GHC warn you about ambiguous names even if your code doesn’t refer to them?
23:42:09 <osfameron> why would they be ambiguous if you don't refer to them?
23:43:51 <Nereid> why wouldn't they?
23:46:16 * hackagebot hspec 1.3.0.2 - Behavior Driven Development for Haskell  http://hackage.haskell.org/package/hspec-1.3.0.2 (SimonHengel)
23:46:18 * hackagebot hspec 1.4.0.1 - Behavior Driven Development for Haskell  http://hackage.haskell.org/package/hspec-1.4.0.1 (SimonHengel)
23:51:20 * hackagebot hspec 1.4.1.1 - Behavior Driven Development for Haskell  http://hackage.haskell.org/package/hspec-1.4.1.1 (SimonHengel)
23:51:22 * hackagebot hspec 1.4.2.2 - Behavior-Driven Development for Haskell  http://hackage.haskell.org/package/hspec-1.4.2.2 (SimonHengel)
23:59:23 <dsantiago> OK I just remembered f was a function.
