00:00:29 <`nand`> STM is good for high-performance concurrency without deadlocks; MVar is good for very simple stuff or when you want blocking/locking
00:07:37 <jackss_> to give more details, while one thread is building the map, other should keep displaying it (refreshing the display relatively fast, 30+ times per second)
00:07:51 <`nand`> sounds like STM would be better
00:08:21 <`nand`> when only one thread is accessing the map, STM has little overhead; the overhead is only when one thread was in the process of displaying it (reading it out) while the other thread changed it
00:08:26 <`nand`> then one of the two will realize it and re-try
00:14:23 <jackss_> nand thanks. I'll give STM a try
00:16:47 <`nand`> (also, you can choose where you want your TVars; ie. TVar (Map k v) vs. Map k (TVar v) vs. TVar (Map k (TVar v)) depending on what kind of updates you want to do, but I don't have much experience with this)
00:55:43 <johnw> joeyh: ping
00:56:58 <lolcathost> @hoogle liftIO
00:56:59 <lambdabot> Network.CGI liftIO :: MonadIO m => IO a -> m a
00:56:59 <lambdabot> Control.Monad.IO.Class liftIO :: MonadIO m => IO a -> m a
00:56:59 <lambdabot> Network.CGI liftIO :: MonadIO m => forall a. IO a -> m a
01:01:09 <bobry_> Is it possible to implement something like 'tee' for conduits?
01:01:35 <popl> bobry_: Are you referring to the UNIX command?
01:01:48 <bobry_> yup
01:02:45 <bobry_> I need the source to go into two different sinks, depending on some condition
01:03:18 * hackagebot bifunctors 3.0.2 - Haskell 98 bifunctors  http://hackage.haskell.org/package/bifunctors-3.0.2 (EdwardKmett)
01:03:36 <bobry_> this looks like a natural pattern, but unfortunately I can't find anything similar in 'Data.Conduit'
01:04:41 <latermuse> is there an easier way of doing this?  filterMaybe = map fromJust . filter (/= Nothing)
01:04:52 <cmccann> :t catMaybes
01:04:53 <lambdabot> [Maybe a] -> [a]
01:05:31 <lolcathost> > catMaybes [Just 1, Nothing, Just 2, Nothing, Just 3]
01:05:33 <lambdabot>   [1,2,3]
01:05:58 <cmccann> see also mapMaybe which is sometimes what you want in the first place
01:06:00 <cmccann> :t mapMaybe
01:06:01 <lambdabot> (a -> Maybe b) -> [a] -> [b]
01:06:11 <latermuse> nice! thanks!
01:06:17 <popl> bobry_: I don't know. Sorry.
01:06:50 <lottylo> Hello - I'd like to learn to use quickcheck. I hope I'm not offending anyone when I say that this page is hilariously useless http://www.haskell.org/haskellwiki/Introduction_to_QuickCheck. From that I have absolutely no idea at all how to write a file of tests. Can anyone point me somewhere else?
01:07:15 <latermuse> lottylo: Check out some projects on github and see how they are using quickcheck
01:07:21 <cmccann> QuickCheck is an incredibly simple tool that somehow manages to not be usefully explained anywhere
01:07:28 <cmccann> I really never understood that
01:07:38 <popl> cmccann: maybe someone should explain it usefully
01:07:39 <bobry_> popl: it's okay, thanks :)
01:07:54 <cmccann> popl, a revolutionary idea!
01:07:55 <lottylo> I've even read the paper, so I know all the ideas, but in terms of what bloody file do i put them in, what should the main be etc, i'm stumped
01:07:57 <popl> Is somebody here good at explaining things?
01:08:06 <shachaf> Nobody.
01:08:14 <popl> I guess we're screwed.
01:08:19 <popl> :(
01:08:21 <cmccann> yes, certainly not me, I am well known for being terrible at explaining things.
01:08:32 <popl> cmccann: well-known for what?
01:08:51 <cmccann> good question
01:09:36 <cmccann> incidentally I'm finally trying to get the hang of all this fancy convoluted new lens nonsense!
01:09:44 <shachaf> cmccann: Oh boy!
01:09:50 <shachaf> http://slbkbs.org/k.hs
01:09:53 <edwardk> cmccann: gratz! =)
01:09:55 <lottylo> Is there a github repo that someone could recomend as decent?
01:09:55 <popl> I can't understand a freaking word you are saying man
01:09:57 <shachaf> Note: This isn't how lens actually works.
01:10:24 <popl> Ok, I'm done. The joke is not funny.
01:10:26 <popl> I apologize.
01:11:42 <cmccann> edwardk, one thing I couldn't figure out is if there's a good way to chain join-able getters, e.g. collapsing a bunch of partial getters into a single Maybe or concatenating lists
01:11:55 <cmccann> obviously that doesn't work for setting for multiple reasons
01:12:15 <edwardk> you have a bunch of folds?
01:12:15 <popl> edwardk: someone earlier was wondering why you were so special.
01:12:42 <edwardk> popl: i mostly gave up sleep. it helped my productivity after an initial lull ;)
01:13:21 <popl> That is an interesting proposition.
01:13:29 <popl> If I had money for stimulants I might consider it.
01:13:30 <cmccann> edwardk, is that what I should be doing? all these weird constraints and type synonyms make it hard to take my usual approach of asking the type in GHCi and then figuring out what fits :P
01:13:48 <popl> Then again I think I might have a heart condition because my chest hurts sometimes.
01:13:59 <latermuse> why doesnt [1.1 .. 1.9] return [1.1,1.2,1.3 ... 1.9] ?
01:14:07 <popl> But hey, if it helps then maybe.
01:14:14 <shachaf> cmccann: What are you doing?
01:14:15 <popl> to hell with a healthy heart
01:14:23 <cmccann> latermuse, because the floating point Enum instance is bullshit
01:14:24 <edwardk> cmccann: a 'partial getter' is a fold of 0 or 1 elements
01:14:36 <popl> edwardk: Thanks for your answer.
01:14:48 <lolcathost> Is it possible to convert a huge mutable data structure full of STRefs to an equivalent data structure full of IORefs when using stToIO?
01:14:52 <edwardk> popl: i don't recommend trying this if you have a heart condition ;)
01:14:57 <latermuse> cmccann: so its a bug?
01:15:04 <popl> I'd rather die smart.
01:15:05 <cmccann> it's a misfeature
01:15:16 <popl> or at least satisfied
01:15:19 <popl> :P
01:17:51 <cmccann> shachaf, trying to get a value if it exists from inside some nested records that are the state value in a StateT
01:18:26 <cmccann> and a couple of the intermediate steps have Maybe values that I'd like to collapse
01:18:51 <shachaf> cmccann: Ah, just use .traverse, I think
01:18:58 <shachaf> traverse :: Traversal (Maybe a) (Maybe b) a b
01:19:33 <shachaf> > toListOf (traverse.traverse.traverse) (Just (Just (Just 5)))
01:19:35 <edwardk> just keep going in with .traverse and read from the resulting traversal with (^?)
01:19:35 <shachaf> > toListOf (traverse.traverse.traverse) (Just (Just Nothing))
01:19:35 <lambdabot>   [5]
01:19:38 <lambdabot>   []
01:19:42 <cmccann> but if I just tack a ". traverse" onto it the type I get in GHCi seems to claim it will always give me a value
01:19:48 <shachaf> Oh, and use (^?) to get it, yes (or the prefix version "preview").
01:19:49 <cmccann> which is obviously bogus
01:19:53 <shachaf> cmccann: Does it?
01:19:54 <edwardk> its a 'traversal' not a lens
01:20:02 <shachaf> cmccann: If f is Applicative, it can use "pure"
01:20:08 <shachaf> In which case it never gives you a value.
01:20:11 <wunki> I keep getting a `~` directory in my haskell projects with cabal-dev. Anyone else having this?
01:20:12 <edwardk> > M.fromList [("hello","world")] ^. at "hello"
01:20:14 <lambdabot>   Just "world"
01:20:18 <edwardk> > M.fromList [("hello","world")] ^. at "hello" . traverse
01:20:21 <lambdabot>   "world"
01:20:25 <edwardk> > M.fromList [("hello","world")] ^? at "hello" . traverse
01:20:28 <lambdabot>   Just "world"
01:20:35 <edwardk> > M.fromList [("hello","world")] ^. at "not-hello" . traverse
01:20:38 <lambdabot>   ""
01:20:39 <edwardk> > M.fromList [("hello","world")] ^? at "not-hello" . traverse
01:20:41 <lambdabot>   Nothing
01:20:53 <edwardk> it used the monoid on String when using ^.
01:20:54 * shachaf wonders whether that did more harm than good.
01:20:57 <edwardk> heh
01:21:02 <edwardk> i should have picked integers ;)
01:21:33 <shachaf> Also the whole (^. at "hello") vs. (^? at "hello" . traverse)
01:21:45 <cmccann> the type I'm trying to get isn't a Monoid so the Monoid instance on Maybe doesn't work
01:21:58 <edwardk> cmccann: ignore the monoid i just mentioned
01:22:00 <shachaf> cmccann: Use (^?) or preview
01:22:02 <edwardk> the idea is this
01:22:04 <cmccann> and half this stuff still looks like line noise to me :P
01:22:04 <edwardk> use ^?
01:22:39 <edwardk> (^?)  will get you the first result of a fold wrapped in Just or Nothing if there is no target
01:22:40 <shachaf> > [Just 1, Nothing, Just 2] ^? (traverse.traverse)
01:22:43 <lambdabot>   Just 1
01:22:50 <cmccann> hm
01:22:55 <shachaf> > [Nothing, Nothing, Nothing] ^? (traverse.traverse)
01:22:58 <lambdabot>   Nothing
01:23:12 <shachaf> That'll scan through the list until it sees the first Just, if it exists.
01:23:20 <edwardk> > "hello"^?element 3
01:23:23 <lambdabot>   Just 'l'
01:23:26 <edwardk> > "hello"^? element 10
01:23:29 <lambdabot>   Nothing
01:23:39 <edwardk> > "hello" & element 10 .~ "!"
01:23:41 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
01:23:42 <lambdabot>              with actual type...
01:23:50 <edwardk> > "hello" & element 10 .~ '!'
01:23:53 <lambdabot>   "hello"
01:23:54 <edwardk> > "hello" & element 4 .~ '!'
01:23:58 <lambdabot>   "hell!"
01:24:28 <mreh> & is some kind of lens combinator?
01:24:36 <shachaf> It's just flipped ($)
01:24:38 <edwardk> element takes a traversal and gives you back a traversal. it cant update an element that isn't there. if you drill into your maybes with traverse, it'll have the same consequences
01:24:42 <shachaf> > 5 & (+1)
01:24:45 <lambdabot>   6
01:24:49 <edwardk> > 4 & succ
01:24:52 <lambdabot>   5
01:24:58 <mreh> right
01:25:03 <friendly_chap> I can' do this?     myFunc :: Int -> Wai.responseLBS  GHC tells parse error on 'Wai.responseLBS'
01:25:36 <popl> where's element defined?
01:25:42 <popl> hoogle won't say
01:25:46 <Cale> friendly_chap: Well, what is Wai.responseLBS? GHC is expecting a type there.
01:25:56 <shachaf> friendly_chap: Because a type (that isn't a variable) starts with an uppercase letter.
01:26:04 <shachaf> responseLBS starts with a lowercase letter.
01:26:08 <shachaf> Type variables can't be qualified.
01:26:12 <friendly_chap> Cale: Ohhh I must be so tired :D
01:26:43 <friendly_chap> Thanks.
01:27:25 <cmccann> ok it being 4:30 am probably has something to do with it
01:27:36 <shachaf> edwardk: lastOf (traverse.traverse) :: [Maybe a] -> Maybe a compiles into something that stack-overflows. :-(
01:27:51 <shachaf> Well, overflows if it sees a bunch of Justs.
01:27:55 <cmccann> but I still can't figure out how to get the result I need out of the state without jumping through a bunch of hoops
01:27:56 <shachaf> I guess it's a bit tricky not to.
01:28:06 <edwardk> shachaf: how could it do anything else?
01:28:06 <shachaf> cmccann: Do you have some code?
01:28:09 <latermuse> how do i get an Integer from a getLine?
01:28:15 <latermuse> do i have to convert it?
01:28:17 <edwardk> :t readLn
01:28:19 <lambdabot> Read a => IO a
01:28:25 <latermuse> thanks!
01:28:33 <shachaf> edwardk: That's a good point.
01:28:35 <edwardk> latermuse: or you can use read or readIO to edit the string you got
01:28:57 <cmccann> shachaf, I do but there's too much cruft around the relevant bit and I'm too lazy to extract something sensible right now
01:29:02 <cmccann> think I'll just go to bed instead
01:29:11 <latermuse> thanks edward
01:30:03 <shachaf> > preview (_left._left) (Left (Left 5))
01:30:05 <lambdabot>   Just 5
01:30:07 <shachaf> > preview (_left._left) (Left (Right 5))
01:30:10 <lambdabot>   Nothing
01:31:10 <cmccann> shachaf, but the code I actually have right now is basically { x <- use (getFoos . at bar); case view baz =<< x of Just x' -> .... }
01:31:43 <shachaf> Oh, so x is an action?
01:31:49 <shachaf> Er, no.
01:31:53 <shachaf> That's a Maybe (>>=)
01:31:56 <cmccann> yes
01:32:37 <shachaf> Maybe something like x <- preuse (getFoos . _at bar . baz); case x of Just x' -> ... ?
01:33:42 <shachaf> Where _at x = at x.traverse
01:34:14 <cmccann> shachaf, that seems to leave me with nested Maybes
01:34:21 <cmccann> but otherwise that's better than anything I could figure out
01:34:28 <shachaf> Nested maybes?
01:34:32 <shachaf> Oh.
01:34:39 <shachaf> preuse (getFoos . _at bar . baz . traverse)?
01:35:28 <cmccann> that seems to work!
01:35:36 <cmccann> ok, tomorrow I figure out wtf that actually does
01:36:59 <cmccann> thanks for the help, there's too much stuff in this library to keep track of when I've only been trying to use it for a few hours D:
01:37:36 <shachaf> The idea of traversals is the most important one in the library, probably.
01:38:41 <cmccann> yeah I figured that's what I needed, but getting it to join the Maybes while pulling from the state value was apparently a bit too subtle :[
01:39:17 <shachaf> It'll make sense in the morning. :-)
01:39:30 <cmccann> otherwise though everything seemed pretty simple
01:39:40 <cmccann> as long as I didn't worry about wtf those type signatures mean :P
01:40:00 <shachaf> Think of it as getFoos (_at bar (baz (traverse (\x -> Const (First (Just x))))) mything
01:40:06 <shachaf> ...In retrospect that may be unhelpful.
01:40:13 <ciaranm> the type signatures are the important bit
01:40:22 <ciaranm> the actual code is irrelevant!
01:40:33 <cmccann> the other thing I should try to make sense of is all the plate mangling whatnot. right now I'm using uniplate as well which seems like it ought to be superfluous?
01:40:39 <shachaf> Just remember that every lens is like a mapM function!
01:40:51 <shachaf> Yep, lens pretty much replaces Uniplate.
01:41:11 <shachaf> You can just use the operators in Control.Lens.Plated, which I think more or less match Uniplate.
01:41:27 <shachaf> Except they're parameterized -- you can get a Data.Data uniplate from Data.Data.Lens
01:41:37 <edwardk> cmccann: lens exports C.L.Plated which generalizes all of uniplate to work on arbitrary traversals
01:41:53 <edwardk> and Data.Data.Lens uniplate is like the uniplate from uniplate, just faster
01:41:59 <ciaranm> i've only got a Data.Data.Bork.Bork.Bork.Swedish.Chef.Plate
01:42:01 <edwardk> (and as a traversal)
01:42:41 <cmccann> mostly I'm using uniplate for descendBiM
01:43:59 <cmccann> which it wasn't immediately obvious to me how to do with the stuff in lens
01:44:05 <shachaf> Hmm, what does that do?
01:44:26 <shachaf> descendOnM biplate
01:44:26 <cmccann> exactly what it sounds like, obviously :P
01:44:40 <edwardk> descendBiM :: (Monad m, Biplate from to) => (to -> m to) -> from -> m from
01:45:06 <cmccann> it's the biplate version of descend with monadic junk also
01:45:32 <edwardk> :t mapMOf (biplate . uniplate)
01:45:34 <lambdabot> (Monad m, Data.Data.Data a, Data.Data.Data t) => (a -> m a) -> t -> m t
01:45:56 <edwardk> we used to have aliases for all that crap
01:45:58 <cmccann> (Data.Data.Data.Data.Data b) =>
01:46:21 <edwardk> :t mapMOf (?bi . plate)
01:46:23 <lambdabot> (?bi::(b -> WrappedMonad m b) -> s -> WrappedMonad m t, Monad m, Plated b) => (b -> m b) -> s -> m t
01:46:59 <edwardk> bi there is the traversal that finds the 'things you want to look in' plate there is finding the descendants
01:47:16 <edwardk> :t mapMOf (biplate . plate)
01:47:18 <lambdabot> (Monad m, Data.Data.Data t, Typeable a, Plated a) => (a -> m a) -> t -> m t
01:47:25 <edwardk> would be the closest analogy to the uniplate signature
01:47:29 <cmccann> ok
01:47:51 <edwardk> we don't have a Biplate class as it leads to pretty crappy overapping instances or instance explosion
01:47:51 <cmccann> I'll give that a shot tomorrow as well
01:47:59 <edwardk> so we offer 'biplate' in Data.Data.Lens
01:49:03 <shachaf> Uniplate sounds scary.
01:49:08 * shachaf has never used it.
01:49:26 <shachaf> The lens approach looks more sensible to me.
01:49:30 <cmccann> it's pretty simple to use once you know what the pieces do but kind of baffling at first glance
01:49:49 <shachaf> type BiplateType from to = from -> ([to], [to] -> from)
01:49:56 <cmccann> the biplate stuff is really convenient for quick and dirty data munging though
01:50:57 <edwardk> > "hello"^..uniplate :: [String]
01:50:57 <edwardk> > universe "hello"
01:50:59 <lambdabot>   can't find file: L.hs
01:51:00 <lambdabot>   ["ello"]
01:51:13 <edwardk> > universe "hello"
01:51:15 <lambdabot>   ["hello","ello","llo","lo","o",""]
01:51:46 <shachaf> uniplate :: on -> (Str on, Str on -> on)
01:51:52 <shachaf> data Str a = Zero | One a | Two (Str a) (Str a)
01:52:07 <shachaf> Is that some sort of strange approximation of a monoid or what?
01:52:13 <shachaf> I mean, do they use it that way.
01:52:25 <edwardk> shachaf: its approximating the capture we do in the environment directly
01:52:31 <shachaf> Or do they actually use the tree?
01:52:36 <edwardk> we get to fuse together two passes
01:52:46 <edwardk> Neil builds the tree then have to reinterpret it
01:52:49 <edwardk> er then has
01:53:01 <edwardk> thats the source of our speed
01:55:38 <cmccann> edwardk, oh btw I was pondering dual intuitionistic logic the other day. I mention this to you mostly because I assume you like dualizing everything.
01:55:49 <edwardk> heh
01:56:08 <shachaf> cmccann: Did you hear that dualized lenses got way nicer?
01:56:13 <shachaf> Over the past few hours, that is.
01:56:15 <cmccann> thinking it might be fun to build a simple programming language around it. should be workable I think, but weird.
01:56:28 <shachaf> What's dual intuitionistic logic?
01:56:33 <edwardk> prisms are pretty much awesome now
01:56:41 <cmccann> shachaf, the dual of intuitionistic logic
01:56:53 <hpaste> Noone pasted “Please bear with my I am stuck.” at http://hpaste.org/79696
01:57:01 <cmccann> that is, "a || not a" is always true, but "a && not a" is not always false
01:57:02 <shachaf> Thanks, that clears it up.
01:57:06 <friendly_chap> Thats my.
01:57:06 <shachaf> Ah.
01:57:16 <friendly_chap> me*
01:57:40 <shachaf>  In the expression: App.app a dbConn cargs
01:57:40 <shachaf>  In the second argument of `Warp.run', namely
01:57:40 <shachaf>    `(\ a -> App.app a dbConn cargs)'
01:57:41 <friendly_chap> Damn I am replacing y and e constantly.
01:57:49 <shachaf> I don't see that expression in your code.
01:58:12 <cmccann> shachaf, you also have double negation elimination, but not introduction
01:58:34 <cmccann> so double negation is actually a stronger notion of truth than non-negated
01:58:41 <friendly_chap> shachaf: That is an other file, I just don't get how a printf can change the type of that function! Could anyone point me to a material from which I can acquire that knowledge
01:58:56 <shachaf> cmccann: What about double-double-negated?
01:58:58 <cmccann> shachaf, and I think you can embed classical logic via double-negation is nearly the same way you can with intuitionistic logic
01:59:08 <shachaf> friendly_chap: It happens because you don't put type signatures on your functions.
01:59:15 <shachaf> friendly_chap: Add types to every function.
01:59:58 <shachaf> friendly_chap: You probably want something like liftIO (print q)
01:59:59 <Saizan> friendly_chap: well, it's simple, return is polymorphic but print isn't
02:00:06 <Saizan> ?type return
02:00:07 <lambdabot> Monad m => a -> m a
02:00:10 <Saizan> ?type print
02:00:11 <lambdabot> Show a => a -> IO ()
02:00:57 <friendly_chap> Omg that sounds like a reason indeed, thank you Saizan and shachaf
02:01:34 <shachaf> Is there a reason Profunctor doesn't have a function like bimap that does both at the same time?
02:01:46 <shachaf> Hmm, I guess in practice it's much less common.
02:01:50 <cmccann> anyway, dual intuitionistic logic is related to the negative polarity half of linear logic, which is why I was thinking about it
02:02:07 <cmccann> trying to see how it would work as a programming language is fun in its own right though
02:03:06 <cmccann> seems like you kind of have to do everything backwards, with it all being completely demand-driven, instead of a program that does something on its own
02:04:11 <cmccann> reminded me a bit of trying to figure out edwardk's coalgebra stuff I suppose
02:04:46 <edwardk> shachaf: its just not something most people ask for in the theory, but we could add it
02:04:49 <edwardk> dimap probaby
02:05:13 <shachaf> edwardk: After asking I realized that dimap is something you almost never want in practice.
02:05:21 <shachaf> Also, dimap = iso
02:05:28 <shachaf> For profunctor lenses.
02:06:09 <edwardk> well, dimap is the map for the underlying functor from Hask^op x Hask -> Set
02:07:02 <ciaranm> opposite categories are creepy
02:07:36 <hpaste> mapf pasted “reinterpret memory” at http://hpaste.org/79697
02:07:55 <mapf> why undrop returns not 0?
02:10:28 <mapf> 'offset' should 'ptr' there
02:10:29 <shachaf> mapf: Why would it?
02:11:39 <mapf> shachaf: I want to get offset from strict bytestring. I force thunk then get ptr to payload and when get second int.
02:11:56 <mapf> That's wrong?
02:12:08 <shachaf> Yes, that's wrong.
02:12:15 <mapf> why?
02:12:59 <shachaf> Because the memory representation of ByteStrings is more complicated than you think.
02:13:22 <shachaf> You can import Data.ByteString.Internal and pattern-match on it to get the offset.
02:14:01 <shachaf> What's your goal here?
02:14:23 <mapf> shachaf: but constructor is (PS !(ForeignPtr Word) !Int !Int) all unpacked
02:14:59 <mapf> oh, I didn't know that I can import construct, thanks
02:15:10 <mapf> *constructor*
02:15:11 <Heffalump> you shouldn't assume anything about the internal representation of Haskell datatypes
02:16:05 <mapf> well but I tried offsets 0/1/2 and all of them returns just random numbers. I completely didn't understand that
02:16:24 <shachaf> mapf: If you really want to do this, a good way to figure it out is to compile code that accesses a ByteString and look at the generated Cmm/assembly.
02:17:22 <mapf> shachaf: okies, i'll just use Internal :)
02:19:38 <pluto> ciao
02:19:46 <pluto> !list
02:19:46 <monochrom> pluto: http://hpaste.org
02:28:13 <shachaf> Oh boy, I made mapf's program work.
02:28:19 <shachaf> Don't ever do this.
02:35:41 <shachaf> Oh, it's easier to fix than what I did: offset = Ptr (int2Addr# (word2Int# ((unsafeCoerce# b `and#` (int2Word# (-8#))))))
02:35:57 <shachaf> (And of course that won't work in general.)
02:37:05 <hpaste> “:-)” pasted “Jafet” at http://hpaste.org/79698
02:38:23 <Jafet> Well, I should have made that an annotation
02:40:41 <Jafet> > printf "%x" ((-8) :: Word)
02:40:43 <lambdabot>   Ambiguous type variable `a0' in the constraints:
02:40:43 <lambdabot>    (GHC.Show.Show a0)
02:40:43 <lambdabot>     ...
02:40:50 <Jafet> > text $ printf "%x" ((-8) :: Word)
02:40:52 <lambdabot>   fffffffffffffff8
02:40:52 <aristid> so it is still popular to make monoidal APIs into monads, but at least Writer monads now, instead of just fake monads.
02:43:05 <simply-chris> Hello peeps
02:44:17 <Jafet> @wn peeps
02:44:18 <lambdabot> No match for "peeps".
02:44:50 <simply-chris> peeps = people :)
02:45:07 <Jafet> @wn peep
02:45:08 <lambdabot> *** "peep" wn "WordNet (r) 3.0 (2006)"
02:45:08 <lambdabot> peep
02:45:08 <lambdabot>     n 1: the short weak cry of a young bird [syn: {cheep}, {peep}]
02:45:08 <lambdabot>     2: a secret look [syn: {peek}, {peep}]
02:45:08 <lambdabot>     v 1: look furtively; "He peeped at the woman through the window"
02:45:10 <lambdabot> [6 @more lines]
02:45:21 <simply-chris> @more
02:45:22 <lambdabot>     2: cause to appear; "he peeped his head through the window"
02:45:22 <lambdabot>     3: make high-pitched sounds; "the birds were chirping in the
02:45:22 <lambdabot>        bushes" [syn: {peep}, {cheep}, {chirp}, {chirrup}]
02:45:22 <lambdabot>     4: speak in a hesitant and high-pitched tone of voice
02:45:22 <lambdabot>     5: appear as though from hiding; "the new moon peeped through
02:45:24 <lambdabot>        the tree tops"
02:45:31 <simply-chris> @more
02:46:09 <shachaf> Jafet: Well, using Data.ByteString.Internal is cheating.
02:47:15 <Jafet> I doubt that makes it any more portable, or readable, or have whatever other undesirable property you're thinking about
02:51:09 <shachaf> Jafet: If you're importing .Internal anyway, what's the point?
02:51:29 <shachaf> Hmm, I guess what you're doing isn't getting the offset anyway.
02:51:57 <Jafet> That was some code I wrote to convert to a UArray
02:52:01 <shachaf> Ah.
02:52:31 <Jafet> I wonder why (-8) appears in both.
02:52:54 <shachaf> Both what?
02:52:58 <shachaf> Oh, in my code too.
02:53:15 <shachaf> I should probably have subtracted 1 instead.
02:53:24 <shachaf> Then in theory it might work on 32-bit machine too.
03:29:19 <Skillson> Hey guys, what's going on?
03:36:05 <jozefg> Skillson: Hey
03:36:59 <neutrino_> Skillson: hi.
03:38:43 <jozefg> Does anyone know any good FOSS projects for haskell to start with?
03:39:43 <tdammers> jozefg: start as in start using? start learning haskell? start contributing?
03:39:58 <jozefg> tdammers: contributing
03:40:08 <neutrino_> jozefg: scoutess is a pretty good idea
03:40:46 <tdammers> the most visible projects are probably xmonad and pandoc
03:40:59 <`nand`> you could contribute to lens
03:41:16 <tdammers> or maybe one of the web frameworks
03:41:21 <tdammers> yesod, happstack, snap
03:41:31 <tdammers> not sure how open they are to contributions though
03:41:41 <osa1> hmm strange. can anyone explain why I'm getting an error in fun2 http://hpaste.org/79699
03:41:51 <tdammers> otherwise, consider contributing to one of the hackage libraries you are using already
03:41:59 <edwardk> lens is pretty open to contribution. #haskell-lens. github.com/ekmett/lens/issues has a laundry list of stuff. we can always use more tests, better docs, work on the wiki, etc.
03:42:06 <neutrino_> well, scoutess is fairly new right now, so you don't need a lot of haskell knowledge to contribute
03:42:12 <`nand`> osa1: because you're changing the type
03:42:26 <`nand`> osa1: ‘Right’ has different types on the left and right hand side of ->
03:42:53 <edwardk> its also on the crazily-complex end of the haskell spectrum so its a good way to learn from the bottom of the pool at the 'deep end' ;)
03:42:53 <tdammers> and of course I wouldn't mind contributions to my own stuff
03:43:11 <`nand`> you could write benchmarks for lens :)
03:43:25 <tdammers> if template engines are your thing, that is
03:43:38 <edwardk> we have some, could definitely use more, especially for zippers and prisms
03:43:56 <tdammers> https://bitbucket.org/tdammers/hpaco for example
03:45:47 <jozefg> Im a bit worried that lens would be over my head, it looks quite cool though
03:46:17 <`nand`> if crazily complex is your sort of thing you could also contribute to diagrams
03:54:10 <jozefg> tdammers: Hey are you still working much on Hako? That looks simple enough to start with
03:55:47 <Shapeshifter> Do you guys know if Bonus (author of LYAH) ever hangs around in here anymore? Has anyone been able to contact him via email?
03:56:11 <Botje> @seen BONUS
03:56:12 <lambdabot> Unknown command, try @list
03:56:17 <Botje> !seen BONUS
03:56:26 <Botje> huh, we used to have bots that reacted to that.
03:56:31 <shachaf> Yep, they're all gone.
03:56:32 <`nand`> preflex
03:56:45 <`nand`> Shapeshifter: I think she's pretty much gone from here
03:57:31 <Shapeshifter> Mhh
03:57:54 <`nand`> I tried contacting her per email once (aeons ago) and haven't gotten a reply either
03:59:55 <Shapeshifter> yeah me neither, months ago.
04:00:49 <`nand`> maybe the e-mail @learnyouahaskell.com is dead
04:00:59 <`nand`> you could try miran.lipovaca@gmail.com
04:01:05 <Shapeshifter> thanks
04:01:58 <Shapeshifter> Miran's a girls name? Looks like a dude in this picture http://www.unmeetup.com/members/47831692/?op=&memberId=47831692
04:02:13 <Peaker> programming complex Haskell code with lots of intermediate type signatures can sometimes make things so much easier
04:02:14 <Shapeshifter> or in any other picture.
04:02:35 <Peaker> took 5 minutes to write something I was having a hard time with for ~1 hour when I tried doing the types in my head
04:02:42 <`nand`> that page gets me stuck in an infinite redirect cycle
04:04:00 <`nand`> maybe I was remembering incorrectly
04:04:33 <Peaker> it's gonna be so much nicer when IDE's show you the intermediate types on demand, very easily
04:04:45 <Jafet> Who cares what their gender is.
04:04:46 <Shapeshifter> `nand`: well it doesn't matter either way ;-)
04:08:22 * hackagebot snaplet-sqlite-simple 0.3.1 - sqlite-simple snaplet for the Snap Framework  http://hackage.haskell.org/package/snaplet-sqlite-simple-0.3.1 (JanneHellsten)
04:15:24 <osa1> can anyone tell me a good way to concatenate `n` times a constant string ?
04:16:02 <Peaker> > let foo n = concat . replicate n in foo 5 "hello"
04:16:04 <lambdabot>   "hellohellohellohellohello"
04:16:16 <osa1> ah, replicate, thanks
04:19:22 <fmap> there should be `mappend-n-times' function in Data.Monoid but there isn't one :[
04:20:11 <Peaker> fmap, why should there be?  mconcat . replicate n  is not that common
04:21:18 <shachaf> Peaker: Well, you can be smarter than mconcat . replicate n
04:21:34 <Peaker> oh, you mean inside the class
04:21:40 <shachaf> No, even outside.
04:21:48 <shachaf> (a*a)*(a*a) can be done with three applications of (*)
04:21:55 <shachaf> Er.
04:22:00 <Peaker> oh, right, nice :)
04:22:08 <shachaf> OK, that wasn't a good example.
04:22:11 <shachaf> But you get the point.
04:22:28 <plat0> Can I get GHC to warn on incomplete pattern matches on the left of "<-" rather than invoking fail at runtime?
04:22:31 <Peaker> in the case of lists, it wouldn't help much
04:22:34 <Peaker> but maybe in other Monoids it would
04:22:38 <shachaf> plat0: Not really.
04:22:51 <shachaf> With lists you want it to be right-biased.
04:23:05 <Peaker> a right-associative mconcat would be better than a half-split one, yeha
04:23:12 <shachaf> With two applications of * is what I meant.
04:23:20 <shachaf> mconcat is actually a nice operator.
04:23:29 <shachaf> You can define both mempty and mappend in terms of it.
04:23:52 <shachaf> It maps things back from lists to other monoids.
04:24:38 <Peaker> yeah, so basically what you want is   rmconcat = mconcat ; midmconcat = same semantics, but does a minimal amount of mappends.  lmconcat = left-associative mconcat
04:25:13 <Peaker> maybe also parmidmconcat which is like midmconcat but with more parallelism
04:25:37 <shachaf> Peaker: midmconcat is hard because it gets a list.
04:25:59 <shachaf> Lists are free monoids but they're right-biased. :-(
04:26:53 <Peaker> shachaf, but if you're gonna O(N) anyway...
04:27:06 <Peaker> shachaf, or maybe you're not, if it's not the list monoid
04:27:14 <Peaker> so yeah, the replicate case is interesting on its own
04:27:25 <shachaf> Yep.
04:27:33 <Peaker> but those are interesting too, perhaps :)
04:27:34 <shachaf> Monoid exponentiation.
04:52:09 --- mode: services. set +o ChanServ
05:32:46 <cloudhead> hey is there a way I can tell cabal-dev to ignore packages I've installed with cabal? It's conflicting with packages I have installed globally
05:49:11 <neutrino_> hi
05:49:13 <neutrino_> i have a question
05:49:26 <neutrino_> do threads that block forever due to STM get garbage collected?
05:51:56 <cloudhead> neutrino_: they throw an exception afaik
05:55:57 <neutrino_> not here
05:56:06 <neutrino_> only if the main thread gets blocked indefinitely
05:56:24 <neutrino_> oh, wait
05:56:26 <neutrino_> let me check that again
05:57:43 <neutrino_> nope
05:57:46 <neutrino_> they don't
05:57:59 <johnw> can I "bake in" a -K setting?  I have a program that just needs more stack space than the default
05:59:03 <`ramses> is there an option to make ghc warn about unnecessary class constraints? e.g. if you have written "(Eq a, Ord a) =>" the Eq constraint is already implied by the Ord one.
05:59:58 <johnw> hlint doesn't help?
06:00:10 <cloudhead> johnw: in your cabal file
06:00:23 <johnw> cloudhead: ghc-option?
06:00:24 <cloudhead> johnw: -with-rtsopts=-K32M
06:00:29 <johnw> ah, thank you
06:00:41 <`ramses> johnw: it might, but I have a hard time getting that installed locally
06:00:45 <cloudhead> also -rtsopts is necessary
06:01:01 <`ramses> I always get build failures
06:01:06 <`ramses> so I kinda gave up on it
06:03:08 <johnw> i put this in my cabal file:
06:03:10 <johnw> ghc-options:   -threaded -with-rtsopts=-K256M
06:03:44 <johnw> now it's working; now I need to figure out how to move my allocations to the heap
06:05:06 <cloudhead> what kind of objects are you allocating?
06:06:03 <johnw> the function I'm having trouble with is here:
06:06:06 <johnw> https://github.com/jwiegley/sizes/blob/master/Main.hs#L178
06:06:35 <johnw> it blows stack when measuring a certain set of directories that are shallow, but have 342K entries
06:07:10 <johnw> i've tried adding strictness all over the place, but it had no effect whatsoever
06:07:31 <johnw> in fact, the stack blows always at exactly the same place (verified with tracing)
06:08:44 <parcs> johnw: where?
06:08:52 <johnw> i meant, in the filesystem
06:08:59 <johnw> i don't know which line is dying in the code
06:09:12 <johnw> toTextIgnore is causing 42% of the allocations, but I don't think that relates to stack
06:09:34 <johnw> sadly, Filesystem.Path.FilePath != FilePath
06:09:52 <johnw> so I have to convert everything to String just to call getFileStatus, which is just sad
06:11:53 <cloudhead> johnw: hmm seems like it's just from recursion?
06:12:01 <johnw> the recursion is really shallow
06:12:08 <johnw> not more than 4 calls deep at any point
06:12:21 <cloudhead> oh weird
06:12:26 <johnw> i think it's just due to how many EntryInfo objects are being created
06:12:37 <johnw> because there are indeed a ton of them
06:13:30 <johnw> but to be honest, I don't know exactly when GHC uses stack and when it uses heap
06:14:03 <notdan> > mapM print [1,2,3]
06:14:05 <lambdabot>   No instance for (GHC.Show.Show (GHC.Types.IO [()]))
06:14:05 <lambdabot>    arising from a use o...
06:14:16 <notdan> hm
06:17:22 <cloudhead> I would think most of it is heap, as it can't determine in advance how much space it will need
06:17:38 <notdan> :t copyFile
06:17:40 <lambdabot> Not in scope: `copyFile'
06:17:55 <notdan> How can I check what kind of expresion does the function throw?
06:17:59 <parcs> johnw: what if you remove the uses of 'parallel $ map ...'  and replace them with mapM
06:18:13 <johnw> notdan: you can use IOException and then print it
06:18:22 <johnw> parcs: tried that, no effect at all
06:18:33 <notdan> thanks johnw , will try that
06:22:41 <neutrino> still a bit worried about the GC status of threads that block forever
06:22:46 <neutrino> not sure how to check
06:23:01 <notdan> Hm, sorry, which `catch' function I should use?
06:23:06 <notdan> Some of them are depricated, right?
06:23:10 <johnw> Control.Exception.catch
06:23:31 <johnw> that's now the standard one in 7.6
06:23:35 <notdan> right, thanks
06:23:47 <johnw> in fact, in 7.4 you can hide the Prelude one and use that one
06:23:56 <parcs> johnw: i think the culprit is the large lists that you pass to 'parallel . map' and 'sequence . map'
06:24:18 <johnw> doesn't mapM = sequence . map?
06:24:26 <parcs> yeah
06:24:29 <parcs> mapM too
06:24:41 <johnw> ah
06:24:47 <parcs> you should try to refactor your code to use foldM
06:24:48 <johnw> maybe i should sequence the file list first?
06:24:52 <johnw> ok, let me try that
06:25:12 <johnw> actually, changed the code to use foldM
06:25:15 <johnw> and it still died
06:25:18 <johnw> but let me try once more
06:25:26 <parcs> everywhere?
06:25:38 <johnw> no, just at line 193
06:25:53 <johnw> would it make a difference anywhere else?
06:28:18 <parcs> probably not
06:29:54 <hpaste> johnw pasted “foldM.hs” at http://hpaste.org/79706
06:29:56 <johnw> no effect
06:31:10 <parcs> oh, i meant use foldM to replace lines 193-201, not just 193-194
06:31:18 <johnw> oh, isee
06:31:27 <johnw> let me try that
06:38:03 <hpaste> johnw annotated “foldM.hs” with “foldM.hs (annotation)” at http://hpaste.org/79706#a79707
06:38:09 <johnw> still no effect
06:38:23 <johnw> although i like this code more
06:42:39 <parcs> hmm
06:43:28 <parcs> try strictifying the contents of the tuple on line 8
06:43:53 <johnw> ok
06:44:00 <johnw> i'm also going to use DList
06:44:05 <johnw> to avoid the bazillion ++ calls
06:44:23 <shachaf> DList is all about the ++ calls
06:47:23 <johnw> i strictified by changing the return to return $ seq y $ seq ys
06:47:26 <johnw> that should do it, yeah?
06:47:28 <johnw> no effect
06:47:55 <johnw> shachaf: did you not sleep last night?
06:48:24 <shachaf> Sleep is a strange thing.
06:48:36 <johnw> i haven't slept yet
06:48:54 <johnw> i had half a coke at 5pm yesterday, and that's all it takes
06:49:16 <neutrino> how about some movement
06:49:31 <neutrino> half a coke is only 15 minutes of cardio worth of calories
06:49:34 <ion> half a gram?
06:49:45 <johnw> ok, just to disambiguate
06:49:59 <johnw> 6 ounces of the carbonated beverage known as Coca-Cola
06:50:10 <ion> Coca-Cola™
06:50:13 <neutrino> the one that had cocaine with it?
06:50:14 <johnw> thank you
06:50:14 <ion> FTFY
06:50:26 <neutrino> ;)
06:50:54 <neutrino> johnw: same reason i never drink any soda anymore. keeps me up unless i go excercising.
06:54:38 <johnw> parcs: interestingly, i'm not blowing stack by much.  All I have to do is bump to 16m and it works; looks like I'm just grazing it
06:57:14 <parcs> johnw: i think you want 'seq y $ seq ys $ return' instead of 'return $ seq y $ seq ys'
06:57:52 <parcs> actually, that won't matter, because you're pattern matching on the tuple anyway
06:58:51 <johnw> yes, i wondered about that
06:58:59 <parcs> johnw: so you're saying that you get some output from reportEntries before it overflows the stack?
06:59:15 <parcs> er, reportEntry
06:59:25 <johnw> only if I trace
06:59:38 <parcs> oh
07:02:44 <hpaste> Peaker pasted “Monoid Exponentiation” at http://hpaste.org/79708
07:03:08 <Peaker> shachaf, Hmm.. just spent a few minutes doing the mreplicate thing -- what do you think?
07:03:24 <Enigmagic> johnw: generally good to avoid <> when building up large lists. better pattern is to use cons and reverse. and it's a good habit to toss bang patterns inside the tuple when accumulating with tuples.
07:03:24 <lambdabot> Enigmagic: You have 1 new message. '/msg lambdabot @messages' to read it.
07:04:30 <johnw> Enigmagic: interesting, I was used to that trick in Lisp; I'd sort of forgotten about it in Haskell
07:04:57 <johnw> but in this case, i'm not appending single elements, i'm joining actually lists from sub-invocations
07:05:18 <hpaste> Peaker annotated “Monoid Exponentiation” with “Generalized for any K” at http://hpaste.org/79708#a79709
07:05:20 <shachaf> Peaker: This is the implementation of (^), for comparison: http://hackage.haskell.org/packages/archive/base/4.6.0.0/doc/html/src/GHC-Real.html#%5E
07:05:25 <Enigmagic> build list of lists, reverse and concat?
07:05:58 <Peaker> shachaf, they seem to switch to a faster loop once they reached an exact exponent
07:06:35 <Peaker> I didn't super-optimize the non-monoid related part (of figuring out how many times to mappend)
07:07:07 <Peaker> johnw, do you know DLists?
07:07:21 <Peaker> if you're building large sub-lists you need to concat, DList sounds appropriate
07:07:59 <shachaf> Peaker: Your code has a bug.
07:08:03 <shachaf> The annotation, that is.
07:08:04 <johnw> Peaker: i'm using DList now
07:08:30 <Peaker> shachaf, ah, what?
07:08:35 <shachaf> I don't know.
07:08:43 <shachaf> Try mreplicate 3 5 "hi"
07:09:05 <Peaker> oops :)
07:09:08 <shachaf> (Does it make sense to generalize it beyond 2, anyway?)
07:10:35 <Peaker> shachaf, not sure :)
07:11:08 <parcs> johnw: btw, where did you put your call to trace?
07:11:21 <johnw> it's varied greatly over time
07:11:24 <hpaste> Peaker annotated “Monoid Exponentiation” with “Better now?” at http://hpaste.org/79708#a79710
07:14:48 <johnw> here's what I came to https://github.com/jwiegley/sizes/blob/master/Main.hs#L196
07:14:53 <johnw> but same exact issue
07:15:13 <johnw> is there some way to see what is being allocated on the stack?
07:16:23 <johnw> also, note in my failing case that curDepth < depth opts is always false
07:16:23 <Enigmagic> i use gdb
07:16:31 <johnw> so it's not even building big DLists
07:16:32 <luite> you can also derive it from the stg
07:16:32 <parcs> @where stacktrace
07:16:32 <lambdabot> compile with -prof -fprof-auto -rtsopts and run with +RTS -xc
07:16:49 <johnw> parcs: that says it dies in gatherSizes'
07:17:29 <parcs> johnw: does it die during the call to 'listDirectory'?
07:17:50 <johnw> does this have anything to do with the way >>= works?  i mean, this does end up with hundereds of thousands of nested calls via >>= in foldM
07:17:58 <johnw> let me try gd
07:17:59 <johnw> b
07:18:49 <Enigmagic> johnw: if you link with -debug the printTSO helper function is good to know
07:19:16 <johnw> sounds interesting; what does that do?
07:19:31 <Enigmagic> prints out stuff related to the haskell thread
07:19:34 <johnw> i bet this is really due to having so many >>= calls chained together
07:19:52 <johnw> will one have a stack frame?
07:19:55 <johnw> each one*
07:19:58 <parcs> johnw: yeah i think it has to do with excessive recursion involving (>>=). for instance, the simple program 'main = print . length =<< mapM return (replicate 1000000 ())' overflows the stack
07:20:05 <Enigmagic> johnw: they have a linked list of stack chunks, yes
07:20:10 <johnw> ok, that's it then
07:20:14 <johnw> hmm
07:22:02 <notdan> parcs: can you avoid that by pulling out strict evaluation in some way?
07:22:12 <johnw> so how does large recursion in IO work then?
07:22:23 <johnw> any sequencing of a large enough list of IO actions will blow stack?
07:24:16 <Peaker> johnw, why do you use both fst/snd and not pattern matching the tuple?
07:24:24 <johnw> it means my fold isn't folding the way I'm used to; rather, it's building an IO action that's really a huge number of nested calls
07:24:28 <johnw> Peaker: no good reason
07:24:34 <johnw> i'll do that
07:25:23 <t7> #origami or #haskell ?
07:25:25 <johnw> oh, hey
07:25:27 <johnw> Peaker that did it!
07:25:37 <Peaker> johnw, what did it?
07:25:40 <johnw> oh, no, it didn't :(
07:26:08 <t7> bang pattern on the pattern match
07:26:24 <t7> (type)
07:26:32 <johnw> that would only lower heap usage though, right?
07:26:38 <Peaker> parcs, it doesn't overflow my stack...
07:26:42 <johnw> it won't affect the stack usage from >>= chaining
07:26:51 <johnw> oh, we're cross-talking
07:27:28 <Peaker> johnw, are you building with -O2?
07:27:34 <johnw> Enigmagic: does this mean there's a limit to the number of IO actions a program can be made out of?
07:27:45 <johnw> Peaker: at the moment i'm building with profiling
07:27:47 <johnw> i'll try O2
07:28:01 <Peaker> johnw, can you fill me in on what's the problem?
07:28:08 <Peaker> the program you pasted doing stack overflows?
07:28:14 <johnw> see https://github.com/jwiegley/sizes/blob/master/Main.hs#L196
07:28:24 <johnw> that function is blowing stack at 8m, but not at 16m
07:28:36 <johnw> -O2 has no effect
07:29:21 <johnw> i guess i could use unsafePerformIO to relieve the pressure...
07:32:14 <parcs> Peaker: sorry, my mistake. that program overflows the stack because of 'length', but this program actually overflows the stack because of deep recursion in IO 'main = print . last =<< mapM return (replicate 10000000 ())' (compile with -O2)
07:33:29 <latermuse> What kinds of arcanely cool things will I be able to do if I study the haskell type system in detail?
07:33:56 <parcs> notdan: i don't know.. perhaps you can use IORefs to alleviate the stack pressure somehow
07:34:17 <pmk> (.)(.)(.)(.)(.)(.)(.)(.)(+1)(.)(+1)(+1)(-1) == 2
07:34:24 <c_wraith> latermuse: well, you could go read some of Oleg's papers, and see what he's done..
07:48:26 <t7> johnw: maybe write your own foldM with seq or something?
07:48:29 * hackagebot transformers-compat 0.1 - Lenses, Folds and Traversals  http://hackage.haskell.org/package/transformers-compat-0.1 (EdwardKmett)
07:48:37 <t7> no that wouldnt work
08:00:59 <jmcarthur> @src mapM
08:00:59 <lambdabot> mapM f as = sequence (map f as)
08:01:34 <jmcarthur> maybe a strict mapM would be a good idea for some monads, one with a tail recursive implementation
08:02:11 <jmcarthur> (building the result list as an accumulator with (:) and then reversing the whole thing at the end)
08:02:55 <jmcarthur> at least, i've observed mapM on large lists in the IO monad biting a lot of people
08:03:28 <hpaste> johnw pasted “simplest yet” at http://hpaste.org/79711
08:03:36 <johnw> i was able to make the code even simpler
08:03:38 <johnw> but still same problem :(
08:04:09 <jmcarthur> there is a lot to read for me to catch up. is there a short summary of what this code is supposed to do and what its problem is?
08:04:15 <johnw> my problem is the huge chain of calls to gatherSizesW
08:04:38 <johnw> or at least, I think iti s
08:04:50 <jmcarthur> is that the function you're defining? (are these recursive calls?)
08:05:24 <jmcarthur> there's not enough context in that paste for me to make reasonable guesses about the problem, i think
08:13:04 <sm> jmcarthur: here's an earlier link with full code: https://github.com/jwiegley/sizes/blob/master/Main.hs#L196
08:13:41 <johnw> sm: did he say something in channel?  I don't have him on ignore...
08:13:46 <jmcarthur> thanks
08:14:05 <itzmjauz_> yolo
08:14:13 <jmcarthur> johnw: i had said a couple things
08:14:45 <jmcarthur> wow, that's a big function
08:15:15 <jmcarthur> at least most of it is under where (lol)
08:17:11 <jmcarthur> johnw: a number of things worry me about this code. for one, using catch recursively sounds like you're asking for trouble. apart from that, it's very complex, so it's not surprising that there are some problems that are hard to track down
08:17:27 <sm> this might be the poor man's solution, but could it be done more easily using mutation ?
08:18:11 <jmcarthur> fighting complexity with complexity? if it was my code, i would push pretty hard against that suggestion
08:18:31 <johnw> maybe
08:18:58 <jmcarthur> surely there's a decent way to decompose it into simpler functions which have nearly obviously correct or nearly obviously incorrect implementations
08:18:59 <sm> it seems simple in my mind.. just an imperative solution mimicking how you'd get it done in a non FP language
08:19:14 <sm> but ignore me, carry on jm
08:19:17 <sm> jmcarthur:
08:19:23 <johnw> you mean johnw?
08:19:26 <hpaste> pmk pasted “daysToXmas” at http://hpaste.org/79712
08:19:26 <jmcarthur> johnw: are you seeing the things i'm saying now, or am i still invisible?
08:19:49 <jmcarthur> sm: i suspect i am unintentionally ignored or something
08:20:07 <johnw> night all
08:20:13 <jmcarthur> :( oh well
08:20:16 <sm> johnw: are you seeing jmcarthur  ?
08:20:23 <sm> sigh :/
08:23:44 <sm> jmcarthur: emailed him a transcript. I'd like to see this solved too
08:24:58 <jmcarthur> sm:  ah, thanks
08:26:28 <hpaste> pmk pasted “daysToXmasBad” at http://hpaste.org/79713
08:28:04 <pmk> heh, GHC 7.4.2 can't compile my second example
08:33:30 * hackagebot sizes 2.0.4 - Recursively show space (size and i-nodes) used in subdirectories  http://hackage.haskell.org/package/sizes-2.0.4 (JohnWiegley)
08:48:11 <orospakr> Hey guys, I'm having some issues with recursion, and I'm fairly stumped. https://gist.github.com/4364251  I'm pretty sure that I've bounded it, but...
08:49:40 <pmk> ghc 7.4.2 runs out of memory on this little example, at least on my mac:   http://hpaste.org/79713
08:50:30 <parcs> orospakr: if none of the elements in the list satisfy the predicate then 'break predicate list' will return '([],list)'
08:52:09 <hpaste> Quchen pasted “Why does this stack overflow?” at http://hpaste.org/79714
08:53:03 <quchen> ^ The code seems fairly simple and leaves me confused.
08:53:11 <jmcarthur> quchen: addition on Ints and Integers is already strict, so that extra function doesn't help you
08:53:25 <pmk> orospakr: once your predicate is satisfied, your code will just loop on it.   consider what happens when the first element of a list satisfies the predicate with break.
08:53:28 <jmcarthur> quchen: the issue is that you are just running to the appropriate index of the list without forcing anything on the way apart from the spine
08:54:08 <jmcarthur> quchen: the spine of the list can be computed without performing any of the additions, so your code just isn't strict enough
08:54:59 <quchen> jmcarthur: So it builds up a huge tree of zipWiths?
08:55:15 <jmcarthur> i think it's a huge tree of (+.)
08:55:21 <jmcarthur> or, well
08:55:25 <parcs> pmk: typechecking that requires a lot of memory
08:55:25 <jmcarthur> a huge stack of them
08:55:38 <pmk> parcs: clearly :)
08:55:56 <pmk> orospakr: still here?
08:56:05 <quchen> jmcarthur: Thanks, I'll see where that leads me.
08:57:13 <jmcarthur> quchen: that is, despite that (+.) is strict, you are still not demanding the result until you have put a ton of them together, so that strictness just isn't doing anything
08:57:21 <parcs> pmk: yeah, it's not a bug or anything. it's sort of a degenerate case for the type checker
08:57:35 <pmk> parcs: agree
08:57:52 <orospakr> pmk, I am, still trying to make sense of it with your help
09:00:11 <orospakr> pmk, the case where the first element of a list satisfies the predicate seems to make sense.  I would just be doing [] ++. I don't see any problems there.
09:00:24 <quchen> jmcarthur: I understand. Thanks for the help!
09:00:54 <pmk> orospakr: but then you make no further forward progress on your input list
09:03:44 <orospakr> pmk, holy crap, I get it now. Thanks! :D
09:11:14 <orospakr> pmk, as a matter of interest, here is how I solved it: https://gist.github.com/4364251
09:12:45 <pmk> orospakr: hang on, i have my solution
09:13:43 <Peaker> if you use hpaste you'll get hlint hints for free
09:13:43 <flebron> From the category theoretical sense, what do I know if I know that some endofunctor F of Hask is applicative? Is there a known term for what haskell calls applicative?
09:13:58 <orospakr> Peaker, point taken, thanks :)
09:14:43 <shachaf> flebron: See the original Applicative paper: http://www.soi.city.ac.uk/~ross/papers/Applicative.html
09:14:52 <flebron> Thanks :)
09:15:14 <shachaf> It's monoidal functors, or something like that.
09:15:16 <orospakr> Peaker, does it take literate?
09:15:37 <lolcathost> What exactly makes a functor an applicative one? The fact function application is possible "inside" the functor?
09:15:38 <Peaker> orospakr, yes, it's one of the options in the language dialog box
09:15:50 <orospakr> nice. :)
09:16:04 <jmcarthur> strong lax monoidal functors or somesuch
09:16:07 <Peaker> lolcathost, the fact you can "fuse" together values of an "f <something>" type
09:17:02 <lolcathost> Peaker: Ah, so "ap" is just a particular instance of that, right?
09:17:24 <Peaker> lolcathost, yeah, also you can make a mempty-like "f" value (i.e: no "effects" in the effects-based world view) with "pure"
09:18:08 <jmcarthur> lolcathost: yeah. basically Applicative allows you to compose effects and to compose the values that the functors contain, but the resulting values aren't necessarily allowed to influence the effects like they are in monads
09:18:21 <pmk> orospakr:   http://hpaste.org/79717
09:18:21 <jmcarthur> *functor contains
09:18:48 <Peaker> jmcarthur, I think it's ok to drop the "necessarily" -- they aren't allowed to influence (via the Applicative API)
09:19:04 <jmcarthur> Peaker: but monads are also applicatives
09:19:18 <flebron> since they never output applicative values themselves, if you're only using <*>
09:19:22 <jmcarthur> if something is an applicative, that doesn't mean it's not allowed to be a monad, is all i mean
09:19:29 <Peaker> sure, but if you use them to influence the effects then you're not using the applicative aPI
09:19:51 <jmcarthur> there could also be non-monadic ways to do it, depending on the functor
09:20:10 <jmcarthur> i'm just being precise about what is Applicative and what is not
09:20:19 <lolcathost> jmcarthur: Ah, makes sense. With monads, the "a"s the "m a" "contains" can influence the "bs" the "m b" will contain. That is not the case with Applicatives. Makes sense.
09:20:34 <jmcarthur> grr
09:20:37 <jmcarthur> that wasn't right
09:20:42 <jmcarthur> lolcathost: that's not quite right
09:20:58 <jmcarthur> lolcathost: the a in m a can influence the b in m b, even in applicative
09:21:09 <jmcarthur> lolcathost: but the a in m a cannot influence the m in m b
09:21:10 <flebron> but it can't influence the context of the m b
09:21:13 <flebron> right
09:21:47 <flebron> you can't throw a Nothing from a Maybe (a -> b)
09:21:47 <pmk> orospakr: still here?
09:21:48 <lolcathost> jmcarthur: :-O
09:22:02 <flebron> not voluntarily at least
09:22:31 <flebron> <*> will make it into a Maybe a -> Maybe b, but the result will only output Nothing when its input is Nothing, the previous a -> b function has no say on whether it can output Nothing
09:22:54 <flebron> whereas with a Monad, a -> m b means the function can choose to throw a Nothing in the middle of the computation
09:23:23 <jmcarthur> yeah, Maybe and [] are good examples for demonstrating this, indeed
09:24:08 <jmcarthur> lolcathost: if i'm using the [] functor, (<*>) and liftA2 and such do not allow me to vary the number of elements in the result by changing the functions i'm applying, but the monad interface does
09:24:23 <pmk> orospakr: your splitBy function has the property that only the first item in its result can be a list that doesn't begin with one or more values that satisfy the predicate.  all the later items in its result list are lists of the form [ hit, hit, hit, miss, miss, miss ... ]
09:24:52 <jmcarthur> > liftA2 f [a,b,c] [d,e]
09:24:55 <lambdabot>   Ambiguous type variable `c0' in the constraints:
09:24:55 <lambdabot>    (GHC.Show.Show c0)
09:24:55 <lambdabot>     ...
09:24:58 <jmcarthur> > liftA2 f [a,b,c] [d,e] :: [Expr]
09:25:00 <lambdabot>   [f a d,f a e,f b d,f b e,f c d,f c e]
09:25:17 <jmcarthur> lolcathost: ^^ there is nothing i can do to f to change the number of elements in that result
09:26:16 <pmk> is there ever any reason to use liftA instead of fmap?  aren't they always the same thing in an Applicative instance?
09:26:40 <jmcarthur> i see no reason to prefer liftA over fmap
09:26:51 <jmcarthur> but for the higher liftA* functions you have no choice, of course
09:27:16 <pmk> sure.
09:34:11 <elliott> pmk: You can use liftA to define fmap
09:34:17 <elliott> instance Functor MyApplicative where fmap = liftA
09:34:21 <elliott> intsance Applicative MyApplicative where ...
09:34:46 <pmk> elliott: Functor is a superclass of Applicative
09:34:53 <flebron> well i'd think one defines first Functor, then Applicative
09:35:36 <elliott> pmk: I know.
09:35:38 <elliott> pmk: It still works.
09:35:58 <jmcarthur> this isn't haskell specific, but it's kind of slow in here right now. i'm trying to think of a way that a tournament could be arranged in which players play games against each other and then upload the results of their matches to a central server, but in a way that combats malicious players who might try to falsify information or deny their own losses
09:35:58 <elliott> Just like you can do "instance Applicative M where pure = return; (<*>) = ap" for any Monad, and this would keep working even if Applicative became a superclass of Monad.
09:36:01 <elliott> pmk: Try it.
09:36:21 <jmcarthur> include coordinated efforts by multiple agents
09:36:24 <pmk> ok
09:36:43 <jmcarthur> *including
09:37:37 <pmk> but surely a "liftA = fmap" in the library would seem to be somewhat neater
09:37:49 <jmcarthur> the ranking system would be some bayesian system that would prevent a player from being able to elevate his rank too high by falsifying matches against other fake players, unless the fake ones are otherwise high-ranking against other real players
09:38:15 <jmcarthur> but that still doesn't help against a player denying a loss or claiming a win without agreement from the other player
09:39:19 <elliott> pmk: That wouldn't work.
09:39:25 <elliott> Because then when you did "fmap = liftA", it'd be "fmap = fmap".
09:39:43 <elliott> The point is that given the Applicative options, you can implement fmap f x as pure f <*> x -- Applicative is more powerful than Functor, so of course you can.
09:39:48 <elliott> And that's why Functor is a superclass of Applicative.
09:40:02 <jmcarthur> maybe liftA should be called defaultFmap
09:40:03 <elliott> So if you've defined an Applicative instance, you can just give the Functor instance as fmap f x = pure f <*> x
09:40:09 <elliott> So liftA is defined as liftA f x = pure f <*> x
09:40:12 <elliott> So you can just say fmap = liftA
09:41:13 <jmcarthur> oh, and obviously the results would be signed so that you can't falsify matches against other real players
09:44:46 <lolcathost> Is there any way to get an Int from a Word8?
09:44:57 <lolcathost> @hoogle Word8 -> Int
09:44:59 <lambdabot> Data.ByteString count :: Word8 -> ByteString -> Int
09:44:59 <lambdabot> Foreign.Storable alignment :: Storable a => a -> Int
09:44:59 <lambdabot> Foreign.Storable sizeOf :: Storable a => a -> Int
09:45:04 <jmcarthur> lolcathost: fromIntegral
09:45:10 <lolcathost> jmcarthur: ty!
09:45:11 <t7> > fromIntegral (8 :: Word8) :: Int
09:45:13 <lambdabot>   8
09:49:00 <roconnor> I'm thinking of removing the Data prefix on my next release of Colour.
09:49:04 <roconnor> any comments?
09:49:18 <roconnor> comments not involving removing u's?
09:49:19 <jmcarthur> i am perfectly happy with more packages doing the same thing
09:49:32 <elliott> Data.Colo.U.R
09:49:58 <jmcarthur> the Color/Colour thing could be addressed easily by just making both, where one simply rexports the other
09:50:20 <jmcarthur> at least for modules. the package is another matter unless you want to make another package that depends on the first :P
09:52:12 <cmccann> roconnor, you could move it to Control.Colour instead just to highlight the absurdity of it all
09:52:20 <cmccann> it's alliterative!
09:52:48 <roconnor> *l*
09:53:19 <roconnor> How about Data.Colour and Control.Color
09:53:26 <roconnor> so everyone is happy!
09:53:30 <cmccann> hahaha
09:53:58 <pmk> Data.Hue
09:54:12 <cmccann> pf, hue is not the same thing as color
09:54:22 <aristid> Date.He *u removed*
09:54:46 <cmccann> actually doing anything correctly involving color is ridiculously complicated and gives me a headache
09:56:28 <t7> thats why i allways use greyscale
09:56:39 <t7> also it looks edgy
09:57:54 <orospakr> pmk, back
10:00:55 <roconnor> cmccann: my colour library allows you do do colour blending more correctly than usual.
10:01:01 <cmccann> yes, I know
10:01:11 <roconnor> but ya, it is a bit complicated
10:01:17 <roconnor> probably less complicated than time though :d
10:01:20 <cmccann> and if I have to spell it weird that's a small price to pay for having someone else deal with that stuff for me
10:01:45 <cmccann> yeah, color is fourth on my list of things that are too complicated for me.
10:01:57 <roconnor> cmccann: oh what else is there?
10:01:59 <cmccann> after dates/times, unicode text, and floating point.
10:02:06 <roconnor> good list
10:02:40 <roconnor> cmccann: that's why I use CReal for everything.
10:02:53 <cmccann> @quote cmccann category.theory
10:02:54 <lambdabot> cmccann says: programming is a lot easier if you avoid working with dates/times, text, or numbers. I say stick to category theory, it's simpler
10:03:28 <cmccann> obviously that's from before I read up a bit on color theory!
10:03:41 <lolcatho`> Is there any way to convert the first 4 bytes from a ByteStream to an Int, without manually taking 4 Word8s, converting them to Word32, multiplying them by the appropriate coefficients, adding them, etc.?
10:05:35 <jmcarthur> Catnaroek: http://hackage.haskell.org/packages/archive/cereal/0.3.5.2/doc/html/Data-Serialize-Get.html
10:05:37 <rwbarton> you could use the binary package
10:05:51 <`nand`> Catnaroek: have a look at ‘get’ from cereal
10:05:55 <`nand`> bleh
10:05:57 <rwbarton> probably more total lines of code than doing it manually
10:05:58 <`nand`> too slow
10:06:16 <Catnaroek> What is too slow? :O
10:06:18 <cmccann> roconnor, have you seen any of this stuff? http://www.handprint.com/LS/CVS/color.html
10:06:20 <`nand`> rwbarton: runGet get :: ByteString -> Either String Int -- shouldn't be an awful lot of code
10:06:26 <jmcarthur> i don't think it would take more than one like to do that specific thing
10:06:37 <jmcarthur> *line
10:06:37 <`nand`> Catnaroek: my response is
10:06:48 <rwbarton> plus an import line, plus a dependency in the .cabal file, ...
10:06:51 <roconnor> cmccann: I don't think I have
10:06:56 <Catnaroek> `nand`: Ah, okay!
10:07:04 <Catnaroek> ty jmcarthur `nand` rwbarton
10:07:09 <`nand`> wait, what's the difference between binary and cereal?
10:07:10 <cmccann> roconnor, and also www.handprint.com/HP/WCL/wcolor.html though there's some overlap
10:07:23 <`nand`> oh
10:07:24 <`nand`> strict vs lazy
10:07:28 <jmcarthur> `nand`: binary uses error, or at least used to
10:07:47 <`nand`> ah
10:07:54 <cmccann> roconnor, it's interesting stuff, about a wide range of color theory topics
10:07:58 <roconnor> nice
10:08:05 <cmccann> though biased somewhat toward working with pigments on a physical medium
10:08:11 <Catnaroek> conduit uses lazy ByteStrings, right?
10:08:22 <jmcarthur> i don't think conduit has to
10:08:32 <jmcarthur> it might
10:08:35 <cmccann> which has its own set of massive complications that don't apply to computer displays
10:09:50 <`nand`> looks like Data.Conduit.Binary.source uses strict, and sourceLbs uses lazy
10:10:33 <byorgey> drdo: gloss is another library in a similar space to diagrams, which is much easier to get started with
10:10:35 <cmccann> roconnor, you should read it sometime, though probably you already know more of it than I did
10:10:36 <Catnaroek> What about Data.Conduit.Binary.take and Data.Conduit.Binary.drop?
10:10:45 <byorgey> drdo: that said, however, we are a friendly and helpful bunch in #diagrams
10:10:55 <`nand`> Catnaroek: lazy
10:10:56 <byorgey> and happy to help you get started
10:11:04 <roconnor> cmccann: ya, I'm familiar with most of the topics on the TOC of the first link, but I might be due for a review.
10:11:25 <`nand`> Catnaroek: http://hackage.haskell.org/packages/archive/conduit/0.5.5/doc/html/src/Data-Conduit-Binary.html#take <- L.ByteString means lazy
10:11:27 <`nand`> oh
10:11:36 <`nand`> never mind what I said
10:11:46 <osfameron> Catnaroek... the twilight of the cats?
10:11:48 <`nand`> I don't know enough about how conduits work; the signature mentions both S.ByteString and L.ByteString
10:11:53 <`nand`> it's possible L. is only intermediate or something
10:11:56 <Catnaroek> `nand`: Yeah, the docs say it should be strict ByteStrings, but... ghci says otherwise.
10:12:03 <Catnaroek> osfameron: Pretty much.
10:12:09 <cmccann> roconnor, the stuff most new to me was things like people having different anchor points for "pure" colors, with less variance in yellow than any other
10:12:47 <`nand`> sourceFile definitely mentions S.ByteString though
10:12:57 <`nand`> Catnaroek: looks like it's all strict
10:14:49 <cmccann> roconnor, e.g. http://www.handprint.com/HP/WCL/IMG/unique.gif
10:14:50 <`nand`> Is there a Haskell library for working with audio files; in particular the API I need is to be able to decode an audio file, split it into segments then re-code those audiofiles; perhaps throwing around metadata/tags in the process
10:14:55 <Catnaroek> `nand`: Yeah, but, for some reason, "CB.take 1 >>= return . fromIntegral . B.head" only works when B is Data.ByteString.Lazy. (CB is Data.Conduit.Binary.)
10:15:28 <cmccann> shows the range of CIELAB hue angles for what people chose as being the purest version of each color
10:18:31 <`nand`> cmccann: neat
10:19:05 <cmccann> `nand`, did you see the links I mentioned to roconnor earlier?
10:19:20 <`nand`> cmccann: yeah
10:19:45 <cmccann> reading those pages is a good way to appreciate the existence of his colour package :P
10:20:17 <`nand`> I was familiar with the absurd complexity of color theory (thus grateful for the library) beforehand :)
10:20:26 <cmccann> haha
10:20:49 <cmccann> I knew it was trickier than it seemed but... man.
10:21:34 <`nand`> the reason is more or less that color perception is a (biological and psychological) human phenomenon
10:21:42 <`nand`> remove humans from the equation and it boils down to wavelength
10:22:06 <roconnor> `nand`: there is also the whole issue of mixing printer inks
10:22:07 <cmccann> well if you remove human perception you're not really talking about color anymore
10:22:17 <hiptobecubic> what ever happened to good old  red=0xFF0000
10:22:27 <`nand`> blue=0xFF0000
10:22:28 <roconnor> hiptobecubic: it is now Data.Colour.Names.red
10:22:33 <`nand`> in BGR, evidently
10:22:56 <cmccann> yeah, subtractive mixing is its own can of unexpectedly chromatic worms, which those pages also cover
10:23:01 <roconnor> opaqueblack = 0xFF000000
10:23:02 <`nand`> roconnor: which red is that? BT.709?
10:23:37 <roconnor> `nand`: it is the red from SVG
10:24:04 <`nand`> SVG? As in, the image format?
10:24:14 <roconnor> http://www.w3.org/TR/SVG11/types.html#ColorKeywords
10:24:22 <cmccann> roconnor, anyway, if nothing else those pages are a pretty comprehensive overview of some essential color theory that's approachable by people with little or no background, might make a good resource for people using your package
10:24:55 <`nand`> “All RGB colors are specified in the sRGB color space [SRGB]”
10:25:17 <roconnor> `nand`: which is sRGB's pure red, and I think sRGB was based on BT.601 but I would need to double check
10:25:26 <`nand`> sRGB and BT.709 use the same gamut
10:25:29 <roconnor> oh
10:25:38 <`nand`> which is great for HD movies
10:26:32 <roconnor> ah you are right
10:27:10 <roconnor> cmccann: oh good idea.
10:27:17 <roconnor> I'll try to remember to add a link
10:28:52 <roconnor> `nand`: Hmm, maybe I should finish my HDTV module
10:29:03 <cmccann> if memory serves me the author is a former professor who decided to take up painting as a hobby and the site is basically his organized notes from learning color theory on his own over the course of a few years
10:29:20 <`nand`> roconnor: I don't think BT.709 actually defines a gamma anywhere
10:29:36 <roconnor> really?
10:29:43 <roconnor> oh
10:29:45 <roconnor> a gamma
10:29:47 <roconnor> hmm
10:29:57 * roconnor thought you said gammut
10:30:12 <`nand`> I think what we do in mpv is just assume BT.709 content approximately uses 2.2
10:30:20 <`nand`> (ie. bluray movies)
10:30:47 <`nand`> but I've seen values anywhere from 2.2 to 2.4 thrown around
10:32:41 <`nand`> but if you assume that the average TV has a gamma from 2.3 to 2.4 and throw in the fact that studios under-encode to compensate for decreased ambient brightness in typical viewing situations vs mastering room references; it makes sense
10:32:58 <`nand`> (of course, every region handles this differently iirc)
10:33:33 * hackagebot hsemail 1.7.3 - Internet Message Parsers  http://hackage.haskell.org/package/hsemail-1.7.3 (PeterSimons)
10:33:35 * hackagebot vinyl 0.1.0.0 - Extensible Records  http://hackage.haskell.org/package/vinyl-0.1.0.0 (JonSterling)
10:33:56 <roconnor> `nand`: the difficult bit is that the forward and reverse transfer functions don't have the same gamma to componsate for the darker viewing environment of the display compared to the bright enviroment where video is generally acquired.
10:34:36 <`nand`> yeah, that's what I meant
10:34:47 <`nand`> but if you compand with 1/2.2 and decode with 2.4; the result will be darker
10:34:55 <`nand`> which is what you want in a darker environment
10:35:01 <`nand`> so it fits
10:35:26 <`nand`> (in mpv though we defer this to the user, and not the encoding studio; assuming that the user will add his own gamma correction on top of ‘reference light’ to compensate for his/her own situation)
10:37:16 <roconnor> `nand`: ya I only see the assumeded encoding transfer function in BT.709
10:38:04 <roconnor> but no decoding function
10:38:23 <roconnor> But I recalled using the sRGB decoding function always
10:38:48 <`nand`> I don't think any TV uses the sRGB function
10:38:51 <`nand`> but I could be wrong
10:40:01 <`nand`> “Conception non-linear precorrection of primary signals γ = 0.45” 1/0.45 ≈ 2.22
10:40:08 <`nand`> Conceptual*
10:40:51 <`nand`> that's for the analog representation though
10:43:33 * hackagebot optparse-applicative 0.5.1 - Utilities and combinators for parsing command line options  http://hackage.haskell.org/package/optparse-applicative-0.5.1 (PaoloCapriotti)
10:43:55 <mantovani> guys how I transforma a char with "getLine" in numbers to sum ?
10:44:08 <mantovani> like the input "1 2 3 4"
10:44:40 <mantovani> http://paste.scsys.co.uk/220191
10:44:49 <mantovani>     let sumHours = sumList listHours
10:44:53 <mantovani> I need become it number
10:45:28 <catsbydlo> do { s <- getLine; let n = sum (map read (words s));
10:45:42 <mantovani> thanks
10:45:59 <jmcarthur> > sum . map read . words $ "1 2 3 4"
10:46:02 <lambdabot>   10
10:46:12 <jmcarthur> :t sum . map read . words <$> getLine
10:46:13 <lambdabot> (Num b, Read b) => IO b
10:49:00 <mantovani> still error
10:49:57 <mantovani> http://paste.scsys.co.uk/220193
10:51:16 <mantovani> works
10:51:17 <mantovani> thanks
10:51:20 <mantovani> what $ means ?
10:53:00 <hiptobecubic> mantovani, function applicatoin
10:53:08 <hiptobecubic> @src ($)
10:53:09 <lambdabot> f $ x = f x
10:53:35 <mantovani> sorry
10:53:42 * mantovani still confuse
10:53:52 * mantovani very noob
10:54:01 * mantovani reading http://learnyouahaskell.com/recursion
10:54:04 <hiptobecubic> mantovani, it just applies a function to an argument
10:54:09 <mantovani> ah, ok
10:54:13 <catsbydlo> be less helpless
10:56:03 <mantovani> I'm doing SPOJ using haskell
10:56:06 <mantovani> I did with Perl
10:56:06 <mantovani> http://br.spoj.com/status/ALADES,mantovani/
10:56:12 <mantovani> Now I'm doing with haskell
10:59:28 <ion> Is there a way to make a multiline doctest?
10:59:43 <osfameron> SPOJ?
10:59:53 <catsbydlo> http://spoj.pl/
10:59:57 <mantovani> computer olympic
11:00:16 <osfameron> ah
11:00:41 <mantovani> haskell will make think from a differente perpective
11:02:22 <mantovani> make me think*
11:03:13 <flebron> Is there a better way of writing "x <- fmap f action"? (Specifically, n <- fmap (read :: String -> Integer) getLine inside IO)
11:03:35 <ion> flebron: readLn
11:03:58 <flebron> How can I give it the Integer typehint?
11:04:18 <ion> flebron: Also, always use readIO instead of read in IO. (readLn = readIO =<< getLine)
11:04:24 <ion> flebron: readLn :: IO Integer
11:05:08 <flebron> What is the difference between readIO read of a getLine?
11:05:50 <ion> readIO calls read and makes sure the result is evaluated before the next IO action, so the exception, if any, happens immediately.
11:06:29 <ion> (read shouldn’t usually be used in pure code either, reads/readMaybe etc. are better.)
11:06:30 <catsbydlo> @src readLn
11:06:30 <lambdabot> readLn =  do l <- getLine; r <- readIO l; return r
11:06:34 <catsbydlo> @src readIO
11:06:34 <lambdabot> Source not found. stty: unknown mode: doofus
11:06:56 <ion> readIO = evaluate . read or something along those lines.
11:07:25 <`nand`> pattern matching on the result of reads should do the trick, no?
11:08:13 <catsbydlo> readIO throws IOErrors
11:08:26 <catsbydlo> it doesn't just let read fail
11:09:33 <mantovani> argh why take don't accept negative values
11:09:38 <mantovani> to start from the end
11:09:53 <ion> mantovani: You’re using the wrong data structure for that.
11:10:12 <mantovani> what should I use ?
11:12:08 <ion> mantovani: Try, for instance, Data.Sequence. It supports accessing the end without iterating over the entire sequence first.
11:12:14 <s_kilk> hey mantovani, I just wanted to point out that the '$' symbol is often used as a substitute for parentheses. for example if we have code like this: foo (bar x)  , we can re-write it as : foo $ bar x
11:12:43 <mantovani> s_kilk: thanks!
11:13:18 <mantovani> ion: I don't even know hose to use haskell imagine a module :P
11:14:12 <parcs> > let takeFromEnd n xs = zipWith const xs (drop n xs) in takeFromEnd 3 [1..10]
11:14:13 <lambdabot>   [1,2,3,4,5,6,7]
11:14:15 <yitz> dmwit: ping
11:15:14 <ion> s_kilk: I’d argue that specific example makes it worse, but granted, there are cases where $ makes an expression better.
11:15:36 <s_kilk> to explain $ further, you can imagine that it means "apply the stuff on the left to the result of the stuff on the right", so it works very much like the parens in our foo (bar x) example. we can read that as "apply foo to the result of the stuff to the right of the ( symbol"
11:17:26 <flebron> ion, what if I wanted to read two consecutive integers (separated by a space)?
11:17:54 <Nereid> parcs: that's dropFromEnd. ;)
11:17:59 <flebron> I should readIO a [String]?
11:18:03 <flebron> Err, an [Integer]?
11:18:34 * hackagebot profunctors 3.1.1 - Haskell 98 Profunctors  http://hackage.haskell.org/package/profunctors-3.1.1 (EdwardKmett)
11:18:39 <leventov> hello, how can i use the hidden module of the separate package?
11:18:47 <edwardk> you can't
11:18:47 <Nereid> flebron: no, that would be if you wanted to read consecutive integers separated by commas and surrounded with []
11:18:58 <Nereid> :s
11:19:12 <Nereid> :t map read . words
11:19:13 <lambdabot> Read b => String -> [b]
11:19:14 <ion> flebron: mapM readIO =<< fmap words getLine or something.
11:19:23 <flebron> Ah, OK
11:19:25 <Nereid> or that
11:19:32 <Nereid> but why IO?
11:20:08 <leventov> maybe make a submodule, or ghc flag? is there any way?
11:20:34 <`nand`> edwardk: you could add a legal fold for ‘words’, right?
11:20:43 <`nand`> if not a traversal
11:20:50 <ion> nereid: It behaves better in IO. It evaluates the result immediately and raises IO errors.
11:20:50 <edwardk> `nand`: fold, yes
11:20:53 <edwardk> but folds are boring
11:20:57 <edwardk> can you make a list?
11:21:01 <Nereid> ion: sure.
11:21:01 <edwardk> yes, then you can make a fold
11:21:03 <edwardk> :t folding
11:21:05 <lambdabot> (Applicative g, Foldable f, Gettable g) => (s -> f a) -> LensLike g s t a b
11:21:13 <edwardk> :t words
11:21:14 <lambdabot> String -> [String]
11:21:17 <edwardk> :t folding words
11:21:19 <lambdabot> (Applicative g, Gettable g) => LensLike g String t String b
11:21:21 <koltar> this code doesn't produce any output until i Ctrl-C the process
11:21:24 <koltar> http://pastebin.com/qtrvrJeu
11:21:27 <edwardk> :t "hello there"^..folding words
11:21:28 <`nand`> ah
11:21:29 <lambdabot> [String]
11:21:29 <edwardk> > "hello there"^..folding words
11:21:32 <lambdabot>   ["hello","there"]
11:21:39 <edwardk> > "hello there"^?folding words
11:21:41 <lambdabot>   Just "hello"
11:21:49 <`nand`> > sumOf (folding words.to readMaybe._just) "1 2 3 4"
11:21:50 <lambdabot>   Not in scope: `readMaybe'
11:21:52 <`nand`> :(
11:22:25 <koltar> oh sorry, missed the hpaste link
11:22:38 <Nereid> koltar: turn off output buffering
11:22:44 <Nereid> @hoogle hSetBuffering
11:22:44 <lambdabot> System.IO hSetBuffering :: Handle -> BufferMode -> IO ()
11:22:45 <lambdabot> GHC.IO.Handle hSetBuffering :: Handle -> BufferMode -> IO ()
11:23:12 <edwardk> > sumOf (folding words.to read) "1 2 3 4"
11:23:15 <lambdabot>   10
11:23:22 <`nand`> yeah, but I wanted it to be non-crashy
11:23:24 <edwardk> that reads well
11:23:35 <edwardk> i know, just enjoying the "sound" of it
11:23:47 <dmwit> yitz: pong
11:23:48 <mantovani> http://paste.scsys.co.uk/220200
11:23:52 <mantovani> how I do this beaultiful ?
11:24:08 <mantovani> 1 2 3 4
11:24:17 <mantovani> 1 2 = sleep time
11:24:21 <mantovani> 3 4 = wake up time
11:24:33 <`nand`> you could add a fold for read too (akin to readMaybe._just)
11:24:54 <dmwit> yitz: Are you support@? =)
11:27:07 <koltar> Nereid: i'm still not getting any output
11:27:37 <koltar> oops, nvm, set NoBuffering for stdin instead of stdout :P
11:28:09 <Nereid> :p
11:28:36 <flebron> Is this incorrect? "line <- readLn           let n = read line :: Integer" . I'm getting a "no parse", when typing 5, followed by the enter key.
11:28:54 <dmwit> flebron: No nead to call read yourself if you're using readLn.
11:29:06 <flebron> Oh you're right, that's if I were using getLine.
11:29:09 <Nereid> flebron: readLn already reads
11:29:09 <`nand`> edwardk: of course, toListOf . folding = id
11:29:14 <flebron> Yeah, thanks.
11:29:16 <dmwit> just "n <- readLn" will work, then use it in a way that tells the compiler it's an Integer (or give an explicit type declaration)
11:29:22 <edwardk> `nand`: yeah thats stated as a law
11:29:22 <hpaste> koltar pasted “guess” at http://hpaste.org/79724
11:29:38 <Refried_> is there already something like (s -> Bool) -> (s -> s) -> State s ()    to conditionally transform a state?
11:29:49 <ion> mantovani: [sleepHour, sleepMin, wakeHour, wakeMin] = words line
11:30:00 <koltar> any advice on the new version of my code?
11:30:09 <dmwit> :t \p f -> gets p >>= flip when (modify f)
11:30:10 <lambdabot> MonadState s m => (s -> Bool) -> (s -> s) -> m ()
11:30:18 <dmwit> Refried_: I don't think so, sorry.
11:30:34 <dmwit> :t \p f -> gets p >>= (`when` modify f)
11:30:35 <lambdabot> MonadState s m => (s -> Bool) -> (s -> s) -> m ()
11:30:42 * Refried_ tries to parse
11:30:43 <yitz> dmwit: can i pm you?
11:30:46 <dmwit> yes
11:31:21 <Nereid> :t \p f -> do { b <- gets p; when b (modify f) }
11:31:22 <lambdabot> MonadState s m => (s -> Bool) -> (s -> s) -> m ()
11:31:56 <Refried_> thanks —  where's `when` defined?
11:32:01 <Nereid> ask hoogle
11:32:05 <Refried_> ok
11:32:54 <Refried_> is this a common thing to do?  or does it not come up because people do something else?
11:33:12 <Refried_> i guess "when" is the common thing that people do that I need to play with
11:33:12 <mantovani> ion: thanks
11:35:38 <`nand`> edwardk: by the way, where do I get awesome haskell clothing?
11:35:48 <flebron> Is there a cleaner way of writing "print . rev $ (rev a) + (rev b)"?
11:35:59 <flebron> (rev :: Integer -> Integer)
11:35:59 <edwardk> `nand`: i had that hoodie custom printed. i can find the link to the company that did it
11:36:01 <Nereid> you don't need those parentheses.
11:36:15 <flebron> god damn function application
11:36:30 <flebron> thanks :)
11:36:51 <nexor> So whats the preferred emacs haskell these days?
11:36:54 <nexor> still no IDE?
11:37:23 <`nand`> edwardk: how much was it?
11:37:25 <edwardk> `nand`: http://www.ooshirts.com/d/90005878 is the design i used
11:37:28 <koltar> nexor:  there's always Leksah
11:37:37 <edwardk> you can click on get a quote there
11:37:42 <edwardk> it varies based on how many you get made
11:38:15 <dmwit> flebron: print . rev $ on (+) rev a b
11:38:26 <dmwit> if that's what you're into
11:38:30 <Nereid> I like the original better.
11:38:34 * hackagebot pretty-show 1.3.2 - Tools for working with derived Show instances.  http://hackage.haskell.org/package/pretty-show-1.3.2 (IavorDiatchki)
11:38:43 <flebron> I always think on should be flip on, for some reaso
11:38:56 <Nereid> on is often used infix
11:39:03 <edwardk> i used two colors for the logo and a black zip hoodie
11:39:11 <flebron> ah, yeah, that makes sense
11:39:27 <Nereid> ((+) `on` rev) a b
11:39:33 <edwardk> `nand`: you can save a little if you leave off the front logo and what not
11:39:50 <ion> https://github.com/sol/doctest-haskell/blob/master/src/Interpreter.hs#L20
11:39:51 <`nand`> ah
11:39:58 <`nand`> I'm afraid I'd have to try it on or something first either way
11:40:03 <`nand`> was just curious
11:40:23 <edwardk> i figured it was a hoodie so if it came in too big i was fine ;)
11:40:48 <`nand`> it being big just means you have room to expand
11:40:55 <edwardk> and they position the logos to standard positions, which i found out after obsessing about placement
11:41:18 <edwardk> well i was meaning more in terms of it just being outerwear so i can swim in it a little
11:41:49 <edwardk> i have another haskell hoodie from last year that i bought, but it didn't zip in the front so its a lot less convenient.
11:41:51 <ion> The hoodie is nice indeed.
11:42:04 <edwardk> the big haskell logo on the front was quite an eye-catcher though
11:42:11 <`nand`> I'm particularly picky about the things I wear, or rather, how they feel :(
11:42:17 <edwardk> fair enough
11:42:50 <`nand`> I wonder if I could just get one of the articles I already wear printed
11:42:52 <Nereid> now make a lens hoodie
11:42:59 <`nand`> does lens have a logo?
11:43:03 <edwardk> Nereid :we need a lens logo first ;)
11:43:05 <Nereid> haha
11:43:16 * koltar keeps forgetting about Haskell2010
11:43:19 <edwardk> right now i just use lots of images of photographic bokeh for the website
11:43:32 <`nand`> the Haskell logo is just a stylized >>=; the lens logo can be a stylized <<>+~ or something
11:43:38 <Nereid> haha
11:44:05 <x-SuriV> the >>= logo is the best
11:44:06 <koltar> <<>+~ is one heck of an operator
11:44:13 <edwardk> `nand`: probably %=
11:44:25 <edwardk> <>= is a lens operator
11:44:33 <edwardk> that might work as an homage
11:44:41 <`nand`> perhaps
11:44:53 <joeyh> I've seen some scarves with something very close to >>= on them.. perhaps it was <$> ? I can't remember, but I want a >>= scarf
11:44:56 <`nand`> but it's not used an awful amount
11:45:10 <jmcarthur> if you use a lens operator as a logo, it needs to be one of the common ones
11:45:22 <edwardk> yeah
11:45:25 <`nand`> I want to be plastered from head to toe with lens operators. And they need to light up when I walk around, implying that I'm using them for my everyday bodily functions
11:45:30 <edwardk> %~ or .= or something
11:45:31 <koltar> >>= is probably best; >> will make people think you're a C++ fanatic
11:46:02 <`nand`> edwardk: maybe a stylized prism overlaid onto a stylized lens or something; be creative
11:46:09 <edwardk> could try to figure out some kind of dark side of the moon   prism version of the haskell logo for lens. given the newfound appreciation we have for prisms
11:46:27 <prsteele> I have foo.hs and bar.hs, where foo.hs declares 'module Foo (foo) where ...'; why is 'import Foo' failing in bar.hs?
11:46:37 <edwardk> replace the triangle in the dark side of the moon logo with a lambda
11:46:49 <jmcarthur> koltar: >>= is a C operator too
11:46:50 <dmwit> prsteele: Because you need to name foo.hs Foo.hs.
11:46:57 <`nand`> the back needs to say “Costate Comonad Coalgebras, what's the problem?”
11:46:59 <prsteele> dmwit: thanks
11:47:11 <jmcarthur> koltar: but less iconic, at least
11:47:12 <koltar> jmcarthur: yeah, but it's not as iconic
11:47:21 <prsteele> dmwit: I was confused because ghc --make bar.hs -v showed that it was searching foo.hs...
11:47:35 <ciaranm> the back of my haskell hoodie has "kleisli composition forms a category"
11:48:07 <dmwit> prsteele: Strange. Does it work now?
11:48:30 <prsteele> dmwit: yup, everything is good, I'm guessing it's a poorly-worded erro message
11:48:32 <`nand`> prsteele: what about ‘ghc bar.hs foo.hs’ ?
11:48:32 <dmwit> prsteele: Maybe that just meant it observed that foo.hs existed (but didn't look inside yet).
11:48:42 <elliott> edwardk: Remember when prisms were projections and sucked?
11:48:44 <elliott> dark times
11:49:11 <prsteele> `nand`: that actually does work as well
11:49:12 <edwardk> elliott: now we have a full exception hierarchy with them ;)
11:49:46 <edwardk> and wow, prisms have come a long way
11:49:56 <edwardk> i've kind of forgotten how to think of them the old way
11:51:35 <elliott> edwardk: did anyone bother thinking of them the old way?
11:51:48 <`nand`> edwardk: it would be interesting to see if, with a suitable third component; the Haskell logo + lens logo + some other logo could be formed into a tri-force logo
11:52:06 <edwardk> `nand`: hah
11:52:11 <`nand`> then we can call it the ‘holy trinity of functional programming’
11:52:15 <shachaf> elliott: What's a projections?
11:52:16 <ciaranm> or an isle of man twisty kind of thing with lambdas
11:52:28 <Peaker> does base have support for a float modulus?
11:52:35 <edwardk> i guess the snap guys use >>λ
11:52:49 <shachaf> You mean when they were (s -> b -> t -> a -> uh -> something, b -> s -> t, hi)?
11:53:17 <hpaste> sj pasted “.emacs” at http://hpaste.org/79725
11:53:27 <nexor> http://hpaste.org/79725
11:53:34 * hackagebot husk-scheme 3.6.2 - R5RS Scheme interpreter, compiler, and library.  http://hackage.haskell.org/package/husk-scheme-3.6.2 (JustinEthier)
11:53:44 <nexor> ^^ doesnt autoturn on haskell mode for me, why not?
11:54:51 <nexor> i have to M-x haskell-mode
11:55:08 <Peaker> my answer is yes, Data.Fixed
11:55:47 <elliott> shachaf: class Projective k a d where projective :: (d -> a) -> (x -> y) -> k x y
11:56:06 <shachaf> elliott: what does that even mean
11:56:16 <shachaf> elliott: Anyway I meant the thing they corresponded to.
11:56:32 <shachaf> (s -> Either t (a, b -> t), b -> t), or something.
11:56:52 <elliott> shachaf: Apparently it was just (b -> s, s -> Maybe a)?
11:56:59 <elliott> at least that's how you constructed them, but that's not right is it
11:57:23 <mightybyte> http://imgur.com/6oYlh
11:57:33 <elliott> the dark days of december 7 2012
11:57:56 <koltar> mightybyte: so New York depends on them?
11:58:14 <mightybyte> :)
12:09:47 <jmcarthur> i bind new york
12:13:32 <Peaker> I wonder why OpenGL's Vector2 has no Num instance
12:14:51 <Nereid> Peaker: what does it mean to multiply two Vector2s?
12:15:05 <jmcarthur> Peaker: it could be component-wise
12:15:07 <jmcarthur> err
12:15:09 <jmcarthur> Nereid: ^^
12:15:17 <Nereid> but componentwise multiplication is useless
12:15:39 <jmcarthur> so? component-wise addition is useful, and component-wise multiplication is still principled enough
12:16:13 <jmcarthur> i wouldn't say it's useless, either, actually
12:16:15 <Nereid> componentwise addition makes geometric sense though. componentwise multiplication doesn't.
12:16:22 <jmcarthur> a Num instance would allow you to say myVector * 2
12:16:24 <Y_Less> The problem is probably that it *could* be component wise or *could* be matrix-multiply, so can't be said to be either
12:16:38 <Nereid> jmcarthur: that would be gross though, I'd rather have a VectorSpace instance.
12:16:41 <jmcarthur> Y_Less: can it really? i don't think the types would allow the latter
12:16:45 <Nereid> 2 *^ myVector
12:16:50 <jmcarthur> Nereid: but how is it gross?
12:16:54 <ClaudiusMaximus> componentwise is what GLSL does
12:17:12 <ClaudiusMaximus> since we're talking GL
12:17:20 <Y_Less> Oh yeah, no they wouldn't, but that actually probably supports the idea of not making it Num
12:17:22 <Nereid> GLSL also makes no distinction between points in space and colours
12:17:54 <jmcarthur> neither does Vector2, for that matter
12:19:32 <Peaker> Nereid, it could just be the ordinary Applicative Num instance
12:19:41 <Peaker> (regardless of the mathy nature of Vectors)
12:19:54 <jmcarthur> yeah, that's why componentwise is actually principled
12:20:25 <Nereid> well, depends on what extra structure you want to see it as having.
12:20:37 <jmcarthur> what other structure could it have?
12:20:57 <Nereid> vector space? ring?
12:21:26 <jmcarthur> neither of those actually make it meaningless to have componentwise multiplication, though. those are just certain views of the same representation
12:21:43 <jmcarthur> heck, component-wise multiplication fits fine in a ring
12:21:51 <Nereid> yes, that's where it fits fine.
12:22:11 <jmcarthur> just because something is a vector space doesn't mean it is nothing else
12:22:23 <jmcarthur> Double is also a vector space
12:22:27 <Nereid> sure.
12:23:26 <Nereid> but componentwise multiplication isn't preserved by linear changes of coordinates, for instance.
12:23:29 <jmcarthur> i would take issue if two instances for the same type claimed mutually exclusive things about what the type is for
12:23:36 <jmcarthur> but that's not happening here
12:23:50 <Nereid> and, after all, it is named Vector2.
12:24:14 <jmcarthur> a vector is really just an indexable thing
12:24:24 <ciaranm> a vector is an element of a vector space
12:24:24 <jmcarthur> it has special meaning in linear algebra, of course
12:24:26 <Nereid> but a vector is a thing in a vector space.
12:24:33 <Nereid> anyway, my point is
12:24:40 <Nereid> more structure isn't necessarily good.
12:24:45 <Nereid> because more structure => fewer morphisms
12:25:05 <jmcarthur> you would have to hide the implementation if that was your concern
12:25:11 <jmcarthur> Vector2 is exposed
12:26:09 <Nereid> well sure, something has to be exposed, or else you could never do anything with it.
12:26:33 <Peaker> I'm just transliterating a little Python gravity simulator to Haskell, and not having a Num instance is a PITA
12:26:44 <jmcarthur> but if it was morphisms you were concerned about, you would have to control what's exposed. since the representation of vector is already exposed, i can really define whatever operations on it i want, regardless of morphisms
12:30:20 <Nereid> I would rather have Num instances than nothing, I guess.
12:32:20 <lolcathost> @pl \f g -> f (g x y)
12:32:20 <lambdabot> (. flip ($ x) y)
12:32:39 <lolcathost> @pl \x y -> f (g x y)
12:32:39 <lambdabot> (f .) . g
12:33:36 <Nereid> :t let (.) = (Prelude..) in (.).(.)
12:33:38 <lambdabot> (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
12:33:47 <Nereid> cale :(
12:36:06 <lolcathost> Is there any difference between "newtype A = A { b :: B }" and "data A = A { b :: !B }" ?
12:36:32 <Nereid> yes
12:36:36 <Nereid> http://www.haskell.org/haskellwiki/Newtype
12:40:36 <lolcathost> @src ($!)
12:40:36 <lambdabot> f $! x = x `seq` f x
12:40:48 <lolcathost> Oh.
12:41:05 <lolcathost> Strictness annotations are not what I thought they were.
12:45:45 <Rileld> Hi, I'm trying to use cabal to build my project, but I can't figure out how to get submodules to work.
12:45:47 <hpaste> Rileld pasted “Trying to figure out cabal” at http://hpaste.org/79726
12:54:00 <aavogt> Rileld: with your setup you shouldn't have to mention Hs-source-dirs
12:54:17 <aavogt> you might have to list those additional modules, sort of like http://hackage.haskell.org/packages/archive/xmonad/0.10/xmonad.cabal
13:12:54 <zhulikas> can you give me a less trivial example of Monad than Maybe?
13:13:03 <zhulikas> and except IO
13:13:30 <kennyd> list
13:13:48 <zhulikas> hmmm
13:14:07 <zhulikas> so I was reading wikipedia page on monads and of course it features a Maybe as an example
13:14:19 <zhulikas> with a nice explanation of what is it for
13:14:31 <zhulikas> "We would like to be able to use this type as a simple sort of checked exception: at any point in a computation, the computation may fail, which causes the rest of the computation to be skipped and the final result to be Nothing."
13:14:46 <zhulikas> this is completely reasonable and understandable
13:15:07 <zhulikas> now can anyone give me examples of other monads and their explanations in similar way?
13:15:25 <zhulikas> let's take list then []
13:15:49 <zhulikas> how is it a monad and how does it behave?
13:16:33 <companion_cube> http://en.wikibooks.org/wiki/Haskell/Advanced_monads#The_List_monad
13:17:16 <monadicity> zhulikas, return x = [x]
13:17:25 <Nereid> State is a very nice monad to understand.
13:17:26 <x-SuriV> uh huh huh huh huh uh hey Beavis he said Monah uh huh huh heh huh
13:17:33 <aristid> [] is an _advanced_ monad (instance)?
13:17:34 <x-SuriV> Monad*
13:17:46 <zhulikas> Computations that are in the list monad (that is, they end in a type [a]) represent computations with zero or more valid answers
13:17:54 <zhulikas> that's a great explanation :)
13:17:54 <zhulikas> and a way to think about a list
13:18:31 <Nereid> in other words, [] represents a nondeterministic computation.
13:18:31 <zhulikas> > [1,2,3] >>= (+1)
13:18:33 <lambdabot>   No instance for (GHC.Num.Num [b0])
13:18:33 <lambdabot>    arising from a use of `e_11231'
13:18:33 <lambdabot>  Poss...
13:18:40 <Peaker> zhulikas, the list monad is like Maybe in that if you have 0 elements ,it also shortcircuits the next steps which don't have any data to work with. But it can also feature *more* than 1 element, in which case the entire rest of the computation is "forked" on each as a "possibility"
13:19:01 <Nereid> > [1,2,3] >>= \x -> [x+10,x+20]
13:19:03 <lambdabot>   [11,21,12,22,13,23]
13:19:29 <Peaker> a nice example of that is filterM, which is like filter, but the predicate is (a -> m Bool) rather than (a -> Bool)
13:19:31 <zhulikas> oh. I misread the (>>=) definition
13:19:33 <Peaker> so you can do:
13:19:35 <zhulikas> of Monad []
13:19:41 <Peaker> > filterM (\x -> [True, False]) [1,2,3]
13:19:42 <lambdabot>   [[1,2,3],[1,2],[1,3],[1],[2,3],[2],[3],[]]
13:19:59 <Nereid> > filterM (const [True,False]) [1..]
13:20:01 <lambdabot>   *Exception: stack overflow
13:20:01 <Peaker> so for each item, we have a decision whether to keep it in or out of the list.  We return "do them both"
13:20:03 <Nereid> doh
13:20:35 <Peaker> zhulikas, so each item gets a "fork effect" where we fork into two possible results, keep in list, remove from list, and the entire rest of computation continues from there
13:20:39 <bzm3r> Is Haskell a member of the "Lisp family"?
13:20:53 <Peaker> bzm3r, probably not
13:20:57 <Nereid> I don't know. is javascript a member of the "lisp family"?
13:21:02 <Nereid> (some people say it is!)
13:21:07 <bzm3r> If a book starts with that in the introduction, should I dismiss it as silly?
13:21:12 <kennyd> zhulikas try do { x <- [1..5]; y <- [10,20,30]; return (x, y) }.
13:21:13 <aristid> bzm3r: yes.
13:21:15 <koltar> quite possibly
13:21:17 <Nereid> bzm3r: the statement or the book?
13:21:22 <companion_cube> javascript isn't homoiconic
13:21:28 <bzm3r> Nereid: The book.
13:21:36 <Nereid> zhulikas: then try [ (x,y) | x <- [1..5], y <- [10,20,30] ]
13:21:38 <bzm3r> I am talking about "The Haskell Road to Maths, Logic and Programming"
13:21:52 <Nereid> then read about MonadComprehensions
13:21:56 <Nereid> (optionally)
13:22:18 <Nereid> does lambdabot have it?
13:22:32 <Nereid> > [ x+y | x <- Just 1, y <- Just 2 ]
13:22:34 <lambdabot>   Couldn't match expected type `[t0]'
13:22:34 <lambdabot>              with actual type `Data.May...
13:22:36 <Nereid> nope
13:22:49 <Nereid> time to go.
13:23:36 * hackagebot th-expand-syns 0.3.0.4 - Expands type synonyms in Template Haskell ASTs  http://hackage.haskell.org/package/th-expand-syns-0.3.0.4 (DanielSchuessler)
13:23:39 <bzm3r> I can't afford Richard Bird's "Introduction to Functional Programming using Haskell", and I only have access to his first edition "Introduction to Functional Programming", which aims to be language independent. Is anyone familiar with either edition? Should I make it a point (i.e. beg my parents for some money) to buy the second edition?
13:24:23 <zhulikas> I can't imagine a situation where anyone would need to beg their parents asking for a programming book
13:24:38 <Eelis> bzm3r: could try a library
13:24:45 <zhulikas> like - what can be better investment than a programming book for a motivated dude? :)
13:24:49 <bzm3r> Urmm, if you only have enough to pay for tuition, and food, and rent, and have nothing much left over, and the university library is closed for the holidays.
13:24:56 <`nand`> zhulikas: an internet connection?
13:25:00 <zhulikas> :D
13:25:03 <zhulikas> ok, that one too
13:25:06 <bzm3r> Oh yeah, I pay for the internet connection too.
13:25:14 <bzm3r> Also, I eat a lot of chocolate :/
13:25:22 <koltar> zhulikas: i had an easier time getting my parents to pay for books than internet service
13:25:30 <zhulikas> but I doubt it's hard to make a relatively comfortable living in US
13:25:34 * `nand` has found every single book he purchased is either available online or can be replaced by online texts
13:25:38 <zhulikas> as a CS student
13:26:07 <koltar> it's surprisingly difficult, unless you're a web developer
13:26:07 <zhulikas> although... not sure how much time does it take to study the subjects :)
13:26:22 <bzm3r> zhulikas: I'm not a CS student, so...
13:26:37 <zhulikas> and web development is a skill you can learn in like a couple of weeks until you are good enough you can start earning money
13:26:57 <Heffalump> bzm3r: I've got both, and I don't think the second is worth a lot of hassle to get over the first
13:27:10 <bzm3r> Heffalump: thank you very much
13:29:08 <koltar> i live in an area where the libraries have a dismal collection of computing texts
13:29:23 <bzm3r> same here, the public libraries are awful
13:29:31 <bzm3r> the university library is awesome, but also closed for the holidays
13:30:05 <aristid> bzm3r: http://book.realworldhaskell.org/read/
13:30:06 <zhulikas> central city library here has only books on boring stuff
13:30:23 <`nand`> @here LYAH
13:30:23 <lambdabot> http://www.learnyouahaskell.com/
13:30:28 <bzm3r> aristid: I want math.
13:30:36 <koltar> the entire set of CS books in our libraries fills a single shelf.
13:30:44 <bzm3r> I have drank Dijkstra's kool aid.
13:30:51 <aristid> bzm3r: http://www.math.vcu.edu/2011publishing.html
13:31:54 <bzm3r> No, I mean, I want a math-y introduction to functional programming.
13:32:14 <bzm3r> So, that's why I'll go with Bird's book.
13:32:27 <zhulikas> I got an introduction to higher math through functional programming
13:32:29 <zhulikas> so that's another way to go
13:33:10 <bzm3r> Yeah, I've dabbled a bit with FP already, and understand the basics of types, but I mean
13:33:19 <bzm3r> I think there is benefit in doing it in a less ad-hoc fashion.
13:33:26 * flebron is about 20 pages away from finishing LYAH
13:33:57 <koltar> i finally got a grasp of Haskell monads two days ago
13:33:59 <bzm3r> flebron: sweet :)
13:34:00 <`nand`> Haskell doesn't have a complete formal semantics, and many bits of it are “theory-breaking” for convenience (eg. unsafeCoerce, unsafePerformIO, some type system extensions)
13:34:09 <`nand`> just thought I'd mention it
13:35:32 <Peaker> What's a complete definition for Num?
13:35:53 <zhulikas> in my opinion such things as unsafeCoerce/etc and extensions are to be learned only when haskell limits are reached or something is really inconvenient to do with vanilla haskell
13:36:31 <zhulikas> otherwise we may end up with programmers who do not understand language fundamentals
13:36:37 <zhulikas> and that happen really often in other languages :)
13:38:23 <koltar> zhulikas: rosettacode has a bunch of aggressively imperative Haskell examples
13:38:50 <`nand`> Peaker: all except negate or (-)
13:39:36 <Peaker> signum?
13:40:22 <`nand`> could you expand that question?
13:41:01 <Peaker> it seems like signum could be derived by default
13:41:05 <Peaker> but apparently you do need to define it
13:41:16 <ClaudiusMaximus> Peaker: see signum for Complex
13:41:16 <Peaker> > map signum [-3..3]
13:41:18 <lambdabot>   [-1,-1,-1,0,1,1,1]
13:41:27 <ClaudiusMaximus> > signum (1 :+ 1)
13:41:28 <lambdabot>   0.7071067811865475 :+ 0.7071067811865475
13:41:34 <`nand`> keep in mind Num doesn't even have Eq/Ord anymore, so you'd have no way of figuring out whether something's negative or not
13:41:39 <Peaker> oh
13:41:47 <`nand`> also what ClaudiusMaximus said
13:42:16 <aristid> ClaudiusMaximus: how is signum defined for Complex?
13:42:37 <`nand`> signum x * abs x = x
13:42:45 <`nand`> signum gives the ‘phase’, with unit magnitude
13:43:17 <flebron> > let powerset xs = filterM (const [True, False]) xs in powerset [1, 2, 3]
13:43:19 <lambdabot>   [[1,2,3],[1,2],[1,3],[1],[2,3],[2],[3],[]]
13:43:26 <`nand`> conceptually, you can think of it via triangles
13:43:32 <flebron> way cool.
13:44:26 <`nand`> > subsequences [1,2,3]
13:44:28 <lambdabot>   [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]
13:45:38 <flebron> @src subsequences
13:45:38 <lambdabot> Source not found. Maybe you made a typo?
13:46:24 <cajla> hi, not sure if this is the right forum but I've tried to find the answer to this question and have resorted to this channel. Why does the binaries built by ghc use pthreads? Is it becase it gives an abstraction to the varius clone and a like syscalls? And why glibc?
13:46:48 <`nand`> > filterM (const [False..]) [1..3]
13:46:50 <lambdabot>   <hint>:1:24: parse error on input `]'
13:47:00 <`nand`> > filterM (const [False, True]) [1..3]
13:47:02 <lambdabot>   [[],[3],[2],[2,3],[1],[1,3],[1,2],[1,2,3]]
13:47:07 <`nand`> ah, not quite the same
13:47:16 <dmwit> cajla: Yes, GHC offers threading abstractions. See forkIO and friends.
13:47:49 <dmwit> Not sure why glibc, but I wouldn't be surprised if it was because of libgmp somehow.
13:47:55 <cajla> Ah probably
13:47:57 <cajla> however
13:48:04 <cajla> gmp is a mess
13:48:11 <`nand`> it links against some things in libc surely, no? for example stat()
13:48:26 <cajla> stat is a syscall
13:49:01 <cajla> you need no knowledge but it's number and the syscall invocation procedure to call that
13:49:18 <`nand`> ah
13:49:37 <dmwit> (And by the way, answering your implicit question: this is a fine forum to ask in.)
13:49:46 <`nand`> well, I remember libc linking failures relating to some symbol like ‘stat’
13:49:58 <`nand`> you could try #ghc as well
13:50:55 <zhulikas> is there an online ghci anywhere?
13:50:55 <dmwit> Right, #ghc and of course StackOverflow will catch some eyes that aren't looking right at the moment (and won't bother reading their entire scrollback).
13:51:06 <dmwit> zhulikas: lambdabot, tryhaskell.org
13:51:08 <`nand`> zhulikas: tryhaskell.org?
13:51:11 <cajla> well anyway for haskell binaries linked for usage in Unix like systems I have no issue with them linking in pthreads if is for abstraction, glibc is a bit intrusive imo
13:51:16 <`nand`> lambdabot isn't GHCi though, and I think neither is tryhaskell
13:51:21 <zhulikas> let's tryhaskell.org
13:51:22 <`nand`> not sure what exactly it is you want from GHCi
13:51:42 <zhulikas> > import Control.Monad.State
13:51:44 <lambdabot>   <hint>:1:1: parse error on input `import'
13:51:47 <cajla> Not that I like pthreads, it's a joke of an abstraction and general blackhole of documentation
13:51:50 <zhulikas> didn't really work on tryhaskell :)
13:52:01 <zhulikas> I don't have a ghci on my machine atm
13:52:08 <zhulikas> and wanted to play with one code example
13:52:18 <dmwit> Is there a "debugging" version of libc around that stubs all the functions and just prints to stdout when they're called? That seems like a handy thing to have lying around.
13:52:26 <dmwit> Or even one that doesn't stub but still prints. =P
13:52:45 <`nand`> dmwit: surely some arcane debugging tool from the C world can log library calls?
13:53:12 <cajla> both libraries are often refered to in the kernel documentation with smug comments like "Read this library documentation, you should never use this kernel feature without it" which is absolute BS. And i wish to rid the world from them both
13:53:24 <cajla> strace
13:53:28 <cajla> oh library
13:53:32 <cajla> just use gdb
13:53:33 <dmwit> strace is for syscalls, not library calls, yeah
13:53:46 <cajla> watchdogs
13:53:54 <dmwit> gdb... how do I set a breakpoint on all the functions exposed by libc? =P
13:54:05 <cajla> ah, eh
13:54:08 <cajla> macros?
13:54:09 <cajla> or
13:54:14 <cajla> use a preload
13:54:17 <cajla> ;)
13:54:35 <dmwit> Right, hence my question about whether there was a debugging version that printed each call. =)
13:54:43 <dmwit> (Isn't that what your "preload" comment is driving at?)
13:55:36 <cajla> :)
13:55:47 <dmwit> Oh, I bet it's for getArgs and stuff like that.
13:56:25 <cajla> My usecase is too obscure to be considered anyones problem but my own really
13:56:32 <shachaf> dmwit: ltrace?
13:56:51 <shachaf> (It's what it sounds like.)
13:57:04 <dmwit> shachaf: righteous
13:57:08 <cajla> oh i forgot about that one
13:57:11 <dmwit> apt-cache search also turns up latrace
13:57:22 <cajla> i was about to sugest
13:57:38 <cajla> some sort of script that parses objdump
13:57:49 <cajla> to setup watchdogs
13:58:03 <shachaf> dmwit: See also xtrace and other traces.
13:58:05 <elliott> cajla: I don't understand how pthreads is less objectionable than glibc...
13:58:12 <elliott> every C program you compile links to libc too
13:58:21 <cajla> a libc
13:58:26 <cajla> well no
13:58:30 <cajla> not even that is true
13:58:35 <elliott> GHC works with other libcs too
13:58:37 * hackagebot th-build 0.3.0.0 - More convenient construction of TH ASTs  http://hackage.haskell.org/package/th-build-0.3.0.0 (DanielSchuessler)
13:58:47 <cajla> libc is definitly voluntary
13:58:49 <elliott> (I know you can compile programs that don't use a libc with gcc, or statically link to a libc -- you get my point)
13:58:55 <dmwit> What the heck am I supposed to give for the "library" argument? c, libc, and libc.so.6 all fail
13:59:27 <cajla> that is good enough
14:00:04 <cajla> pthreads is horrible tho
14:00:34 <dmwit> Huh, GHC uses C's malloc and free.
14:00:36 <dmwit> amazing
14:00:39 <cajla> omg
14:00:46 <cajla> for real?
14:01:24 <cajla> there are some quite good optimizations to do there with splitstacks
14:01:44 <cajla> and mmap():ing directly instead of through malloc,
14:01:59 <cajla> also solves the problem of being able to return memory to the system
14:02:30 <hpaste> dmwit pasted “ltrace "main = print 3"” at http://hpaste.org/79729
14:03:37 * hackagebot optparse-applicative 0.5.2 - Utilities and combinators for parsing command line options  http://hackage.haskell.org/package/optparse-applicative-0.5.2 (PaoloCapriotti)
14:03:39 <dmwit> So yeah, argument stuff, environment stuff, signal control, malloc/free... and also isatty, haha.
14:04:04 <cajla> Yeah, im starting to believe we don
14:04:08 <cajla> gah..
14:04:23 <elliott> cajla: GHC uses its own allocator/GC.
14:04:30 <elliott> probably it uses C malloc/free for some auxiliary stuff
14:04:41 <cajla> don't have many bad languages, we just have a lot of bad compilers
14:05:01 <cajla> ah right
14:05:15 <cajla> all the heavy memory usages will be in decent allocations
14:05:36 <cajla> and it's a very contained problem to the gc
14:05:46 <cajla> (speaking of returning memory)
14:07:26 <cajla> anyway, not really a fan of "heaps", an unachievable dream, gc is not really a proper solution as i believe it to be a compiletime problem
14:08:43 <cajla> On the otherhand, can't say it seems ghc code suffers much from the gc overhead
14:11:35 <cajla> Anyway, thanks for the answers and gn
14:17:03 <zhulikas> man... do-notation in LYAH when explaining State monad is really complicating things
14:18:13 <zhulikas> newtype State s a = State { runState :: s -> (a,s) }
14:19:24 <zhulikas> so let's say there is a function stackManip :: State [Int] Int (from LYAH)
14:19:29 <`nand`> isn't compile-time GC undecidable?
14:20:12 <`nand`> or are you saying we just need good enough heuristics, with runtime GC taking care of the rest?
14:21:03 <zhulikas> runState stackManip [1,2,3] -- this looks a bit weird to me
14:21:13 <companion_cube> I suppose allocation on the stack is a limited form a compile-time GC?
14:21:21 <zhulikas> shouldn't it be like 'runState stackManip $ [1,2,3]' ?
14:21:23 <ijp> I think there is one ML implementation that works out most (if not all) GC at compile time
14:21:36 <ijp> I don't recall the name offhand though
14:21:39 <flebron> zhulikas, what's the difference?
14:21:58 <zhulikas> flebron, otherwise it looks like runState is taking two arguments
14:22:07 <companion_cube> ijp: mlton ?
14:22:14 <flebron> a b c = (a b) c
14:22:23 <ijp> companion_cube: maybe, but I don't think so
14:22:32 <cmccann> why wouldn't runState take two arguments?
14:22:47 <zhulikas> I thought runState takes a state as an argument
14:22:56 <zhulikas> and returns a function which makes a calculation
14:22:59 <zhulikas> based on that state
14:23:17 <cmccann> no, runState takes a (State s a) value and returns a value of type (s -> (a, s))
14:23:18 <zhulikas> and then you provide a state for that returned function (state happens to be [1,2,3] here)
14:23:23 <flebron> runState :: State s a -> s -> (a, s)
14:23:24 <zhulikas> ohhhh
14:23:28 <zhulikas> of course
14:23:29 <zhulikas> my bad
14:23:34 <flebron> it's a sort of accessor to a State's functio
14:23:35 <flebron> n
14:23:59 <cmccann> so first you're unwrapping the State type, then applying the state function to a state value
14:24:18 <cajla> `nand`: I don't think we need a system capable of handling memory allocation that humans can't. GC's can but we need finitly abstractable systems to comprehend the flow of execution and I think that is good enough for software used in finite machines used by humans
14:24:18 <zhulikas> now what is not clear for me is how the magic works inside a monad
14:24:25 <zhulikas> stackManip :: State Stack Int
14:24:25 <flebron> which magic, zhulikas?
14:24:26 <zhulikas> stackManip = do
14:24:26 <zhulikas>     push 3
14:24:26 <zhulikas>     a <- pop
14:24:26 <zhulikas>     pop
14:24:36 <zhulikas> oh, wait
14:24:46 <flebron> remember stackManip will return a function
14:24:53 <flebron> well, a State-wrapped function
14:25:05 <hpaste> zhulikas pasted “state monad” at http://hpaste.org/79730
14:25:08 <flebron> when you give it an initial state, it will push 3 onto it, then it'll pop twice
14:25:11 <zhulikas> that
14:25:17 <zhulikas> that's the complete definition of exmaple
14:25:27 * flebron read that example about 1h ago in LYAH :)
14:25:42 <ijp> companion_cube: maybe I was confusing myself with the implementation of region-based memory management in mlkit
14:25:52 <`nand`> State needs to be changed to ‘state’ to get it to work with mtl, mind
14:25:57 <zhulikas> so push 3 looks like it is creating a state
14:26:02 <flebron> it isn't
14:26:05 <`nand`> ‘push 3’ is modifying the state
14:26:11 <cajla> Also, i think the halting problem is very uninteresting because such systems don't need to be considered valid code
14:26:15 <flebron> stackManip can be thought of as returning a function
14:26:28 <flebron> a function \initialState -> some manipulation
14:26:50 <cmccann> zhulikas, a while back I wrote a simple walk-through reimplementation of the state monad, you might find that helpful: http://stackoverflow.com/a/1957379/157360
14:26:51 <zhulikas> so how can a function be inside some sort of monad and modify it?
14:26:53 <ion> \initialState -> (resultValue, newState)
14:27:02 <flebron> the manipulation will be that you first push 3 onto that state. since you have runState, given that s, you now get an (a, s'), with a being () here, and s' being your new stack
14:27:10 <flebron> s' will be the initial state, with 3 pushed onto it
14:27:25 <cmccann> zhulikas, where I'm starting from just functions, imitating the do notation with only lambdas, then translating back to State s a
14:27:56 <zhulikas> I understand what it does and what is the state at every moment, but I don't understand how the state can be changed that simply :) I thought it should be passed around as a value in a function chain or something
14:28:05 <cmccann> it is
14:28:13 <zhulikas> cmccann, that may be acutally helpful
14:28:13 <flebron> that's what >>= is doing
14:28:14 <cmccann> you just don't see the functions being chained
14:28:19 <zhulikas> because I thought of how to write that in lambdas
14:28:48 <cmccann> zhulikas, reimplementing the state monad without the wrapper type is a popular exercise that I've heard several people recommend
14:28:51 <shachaf> cmccann: Did you work out your traversal issue?
14:28:59 <`nand`> zhulikas: it is passed around as a value; just hidden away in the definition of >>=
14:29:08 <`nand`> which you don't see because ‘do’ sugars it
14:29:09 <flebron> zhulikas, >>= is passing around states every time
14:29:16 <`nand`> @undo do { push 3; a <- pop; pop }
14:29:16 <lambdabot> push 3 >> pop >>= \ a -> pop
14:29:21 <flebron> it's the same as when you get 3 random values, and you have to pass the generator back and forth
14:29:23 <cajla> `nand`: However, I think achieving a system capable of making the same abstractions humans can make is probably not economicly defendable today and good enough heuristics combined with a GC that rarely has to works is good enough
14:29:33 <cmccann> shachaf, haven't gotten back to it yet! you worked out the issue anyway, I just need to keep track of what all these goofy combinators do :P
14:29:56 <shachaf> cmccann: The most important one is (.)
14:30:06 <cmccann> but it works backwards :[
14:30:11 <shachaf> No it doesn't!
14:30:22 <shachaf> @let mapBoth f (x,y) = (f x, f y)
14:30:24 <lambdabot>  Defined.
14:30:30 <shachaf> > map (mapBoth (+1)) [(1,2),(3,4)]
14:30:33 <lambdabot>   [(2,3),(4,5)]
14:30:36 <shachaf> > (map . mapBoth) (+1) [(1,2),(3,4)]
14:30:38 <lambdabot>   [(2,3),(4,5)]
14:30:41 <shachaf> See? Not backwards.
14:30:56 <elliott> cmccann: just think of them as SECs like fmap
14:30:59 <elliott> not as getters
14:31:05 <cmccann> yes, I know how it works :P
14:31:06 <shachaf> (That's the kind of composition that's happening when you compose lenses, because a lens is really a mapping function.)
14:31:29 <cmccann> elliott, it's a completely spurious complaint made purely in hopes of annoying shachaf
14:31:39 <elliott> cmccann: oh. I understand. I do that a lot too
14:31:55 <`nand`> cmccann: it's okay, you can use (>>>)
14:32:22 <cmccann> oh man I should find an excuse to use my back-and-forth operators with lens
14:32:26 <cmccann> that would be hilariously terrible
14:32:32 <`nand`> > ([1,2,3],[4,5]) & sumOf (traverse >>> both)
14:32:34 <lambdabot>   15
14:32:35 <`nand`> see? completely natural
14:33:05 <shachaf> cmccann: By the way, it would be way better if lenses worked like p a b -> p s t
14:33:12 <zhulikas> cmccann,
14:33:13 <shachaf> Where you can pick p = whatever
14:33:14 <zhulikas> len2State :: String -> (Int -> (Bool, Int))
14:33:14 <zhulikas> len2State s i = (len2' s, i)
14:33:28 <zhulikas> there is a mistake here
14:33:59 <Nereid> what is len2'?
14:34:00 <cmccann> zhulikas, entirely possible, I wrote that with little editing years ago
14:34:02 <`nand`> yes, there are two completely unnecessary parentheses
14:34:16 <Nereid> oh
14:34:19 <Nereid> I should look further up
14:34:40 <zhulikas> also len2, not len2'
14:34:45 <zhulikas> but you are forgiven :D
14:34:47 <flebron> that makes sense
14:34:48 <cmccann> heh, I don't actually define len2' anywhere
14:35:06 <cmccann> sorry, I should probably edit that post before I keep referring people back to it
14:35:10 <shachaf> That's a weird way to spell lens'
14:35:28 <Taneb> I've... just downloaded most of Happstack for pretty much no reason
14:35:39 <Taneb> I've already got Snap, and I'm about to start on Yesod
14:35:40 <flebron> hooray for disk space
14:35:44 <cmccann> shachaf, why? it 2eem2 rea2onable to me.
14:35:45 <Taneb> Help I'm addicted to Cabal
14:36:14 <shachaf> `nand`: You have an unusual use of semicolons.
14:36:54 <`nand`> shachaf: for some reason ‘;’ seems more natural and easy to type than ‘,’
14:36:59 <`nand`> in my keyboard layout, that is
14:37:02 <`nand`> perhaps I should exchange them, heh
14:39:46 <`nand`> shachaf: I also suffer from chaining sentences together where not grammatically appropriate, while intermixing ‘,’ and ‘;’ to separate them in a seemingly random fashion
14:40:58 <zenzike> I have a function foo :: (Float, Float) -> Float
14:41:27 <zenzike> I accidentally wrote foo 1 and hit enter too soon without thinking, and was astonished to see the answer is 0.0
14:41:28 <cmccann> `nand`, I do that too; it's a bad habit, but hard to break...
14:41:55 <`nand`> cmccann: and nothing wrong with it, if you ask me; it's not like we're writing publications here or anything
14:42:07 <zenzike> do pairs really satisfy the Num constraints given by constants?
14:42:07 <elliott> zenzike: you have some evil instances
14:42:18 <elliott> someone has given an instance for (Num a, Num b) => Num (a,b)
14:42:22 <elliott> and your 1 is interpreted as (1,1)
14:42:30 <`nand`> zenzike: :i Num
14:42:39 <zhulikas> > (do { a <- (+4); b <- (+5); return (a, b) }) 5
14:42:40 <zenzike> elliott: hm. it must be imported in Repa then, that trickery is not my doing
14:42:41 <lambdabot>   (9,10)
14:42:41 <zhulikas> also this magic
14:42:46 <cmccann> `nand`, true--but I try not to do it too many times in one sentence; if nothing else, mixing things up with dashes as well.
14:42:48 <`nand`> :i will show all the instances
14:43:06 <elliott> cmccann: I JUST WRITE TELEGRAMS STOP IT WORKS FOR ME STOP
14:43:11 <cmccann> :D
14:43:12 <zenzike> :i Nu isn't giving me a pair instance
14:43:39 <zenzike> I mean :i Num of course. This is bizzare.
14:43:40 <elliott> cmccann: SOMETIMES I WANT TO STOP BUT I CAN'T STOP STOP
14:43:45 <`nand`> cmccann: I used to have em-dashes mapped to my keyboard for this purpose; but I seem to have stopped using them a year or two ago - incidentally, I find single hyphens much more comfortable (and readable), even if grammatically incorrect (or whatever, I don't remember these things too well)
14:44:01 <simpson> elliott: YOU FORGOT TO ESCAPE ESCAPE ESCAPE STOP STOP
14:44:07 <`nand`> (this conversation just got so meta)
14:44:58 <`nand`> zenzike: to confirm; fromInteger 1 :: (Float, Float) -- works?
14:45:00 <elliott> simpson: WHAT YOU MEAN I FORGOT TO INSERT THE TEXT ESCAPE ESCAPE ESCAPE ESCAPE ESCAPE ESCAPE ESCAPE STOP INTO MY MESSAGE STOP
14:45:09 * elliott cannot be bothered to figure out further nestings of escapes.
14:45:40 <simpson> elliott: THAT WOULD BE AFFIRMATIVE COMMA GOOD SIR STOP
14:50:22 <Nisstyre> bzm3r: technically you could say Haskell is a lisp if by lisp you mean "based on the lambda calculus model of computation"
14:50:48 <`nand`> ‘lisp’ to me means “based on list processing”
14:50:49 <ijp> Nisstyre: which, incidentally, lisp 1.5 wasn't
14:50:56 <nexor> are the KEYMAP=svlatin1 available by fefault? how do reload so this i s used because nothing happens by just creatng vconsole.conf and adding that
14:50:57 <`nand`> I'm not sure I'd like to conflate it with functional programming
14:51:03 <Nereid> zhulikas:
14:51:09 <Nereid> > (liftA2 (,) (+4) (+5)) 5
14:51:11 <lambdabot>   (9,10)
14:51:14 <Nisstyre> ijp: I'm not overly familiar with the details of early lisps
14:51:57 <zhulikas> by the way, what is the type of right side of a <- (+4) ?
14:51:58 <zhulikas> assuming it's in do-notation
14:52:08 <Nereid> :t (+4)
14:52:10 <lambdabot> Num a => a -> a
14:52:20 <Nisstyre> I'm pretty sure that's a type error
14:52:33 <c_wraith> nope, it's fine
14:52:37 <Nereid> Nisstyre: no, there is a Monad instance for (t ->)
14:52:41 <Nisstyre> oh ok
14:52:43 <Nisstyre> cool
14:52:45 <zhulikas> ok, it is of type of whatever do wants it to be
14:53:09 <zhulikas> so it's probably silently doing a <- return (+4)
14:53:13 <Nereid> zhulikas: no
14:53:25 <`nand`> :t do { a <- (+4); return a }
14:53:26 <lambdabot> Num b => b -> b
14:53:51 <`nand`> @undo do { a <- (+4); return a }
14:53:51 <lambdabot> (+ 4) >>= \ a -> return a
14:53:56 <`nand`> :t (>>=)
14:53:57 <lambdabot> Monad m => m a -> (a -> m b) -> m b
14:54:03 <zhulikas> so this is possible because of monad instance for (->) ?
14:54:05 <c_wraith> > (do { a <- (+4) ; b <- (*2) ; return $ a + b }) 7
14:54:07 <lambdabot>   25
14:54:09 <`nand`> ^ this just matches Monad m => m a with Num a => a -> a
14:54:13 <Nereid> (>>=) :: (t -> a) -> (a -> t -> b) -> (t -> b)
14:54:26 <`nand`> zhulikas: (->) a, yes
14:55:06 <Nereid> @djinn (t -> a) -> (a -> t -> b) -> (t -> b)
14:55:07 <lambdabot> f a b c = b (a c) c
14:55:25 <`nand`> Num a => a -> a  is  Num a => ((->) a) a; so to match that with Monad m => m a  you let m ~ ((->) a)
14:55:39 <`nand`> and the constraint becomes Monad ((->) a)
14:55:45 <flebron> it was pretty cool when i understood why (->) r is the reader monad
14:56:00 <flebron> r -> a is some object which will give you an a, just as soon as you give it an r
14:56:04 <newsham> "let a = readConst + 4; b = readConst * 2; return (a+b)" for the const 7
14:56:17 <zhulikas> I guess I should install haskell platform on my laptop and try implementing state monad...
14:56:30 <Nereid> > runReader (do { a <- asks (+4) ; b <- asks (*2) ; return $ a + b }) 7
14:56:32 <lambdabot>   25
14:56:35 <flebron> Nereid, is there some categorical way of reasoning why (->) r is reader?
14:56:37 <`nand`> aren't there some online services that can do code execution if snippets?
14:56:39 <zhulikas> only then I will be able to understand why does it allow this monadic operations
14:56:44 <`nand`> codepad or so
14:56:50 <`nand`> s/if/of/
14:56:51 <zhulikas> which look like functions without arguments yet doing something
14:56:54 <flebron> ideone as well
14:57:16 <Nereid> flebron: I don't know what you mean. reader is (->) r, basically by definition
14:57:33 <`nand`> flebron: it's by definition
14:57:34 <zenzike> `nand`: yep, fromInteger :: (Float, Float) works
14:57:36 <flebron> why "morphisms from r" form a monoidal object, perhaps there's some clever reasoning
14:57:46 <`nand`> zenzike: then yeah, you've got a funky Num instance somewhere :)
14:57:54 <`nand`> quite possibly repa or whatever you mentioned
14:58:03 <zenzike> `nand`: indeed. Strange that it's not showing up in :i Num
14:58:11 <`nand`> yeah, I'd have expected it to
14:58:18 <`nand`> maybe that doesn't show exported orphan instances? or something
14:58:19 <Nereid> flebron: well for theory it's easier to think about monads in terms of return and join :: m (m a) -> m a
14:58:25 <flebron> yeah
14:58:31 <Nereid> which for functions is (r -> r -> a) -> (r -> a)
14:58:41 <zenzike> `nand`: hm, yes, missing orphans sounds probable
14:58:57 <Nereid> which looks like it comes from the diagonal r -> (r,r)
14:59:01 <flebron> right
14:59:06 <zhulikas> whoa, I almost understand it
14:59:13 <Nereid> so
14:59:22 <Nereid> if you want to say it this way, it's because everything is a comonoid
14:59:25 <flebron> \f -> \r -> f r r
15:00:06 <flebron> hrm, i haven't studied comonoids
15:00:11 <`nand`> zenzike: you could try defining your own “instance (Num a, Num b) => Num (a, b)” <- and look at the resulting ‘Duplicate instance declarations’ error
15:00:15 <Nereid> just the categorical dual of monoids.
15:00:16 <flebron> i assume there's a coproduct and a coidentity :p
15:00:25 <Nereid> comempty :: a -> (), comappend :: a -> (a,a)
15:00:29 <Nereid> yeah
15:01:22 <flebron> hrmph
15:01:27 <zenzike> `nand`: nice idea. looking at my imprts, I thinkit can only be Repa or Gloss, and I wouldn't be too surprised if it was Gloss
15:01:36 <cmccann> gloss sounds plausible
15:01:39 <flebron> ok, sure, append goes from a x a to a, so coappend has to go from a to a x a
15:01:44 <cmccann> trying to be helpful for working with coordinates
15:01:48 <`nand`> gloss has it
15:01:51 <`nand`> I added it to gloss
15:01:53 <`nand`> sorry
15:01:55 <zenzike> thanks for the help :-)
15:02:20 <cmccann> I hate writing Num instances for coordinates because there's no sensible multiplication >:[
15:02:21 <`nand`> (actually, it might've been there before, but defined in a silly way)
15:02:22 <Catnaroek> Nereid: And what would be the categorial duals of the monoid laws?
15:02:39 <`nand`> cmccann: I gave it element-wise, which makes sense with stuff like 3 * (x,y) = (3*x, 3*y)
15:02:41 <Nereid> Catnaroek: first write the monoid laws in terms of commutative diagrams.
15:02:43 <Nereid> then reverse all arrows
15:03:09 <cmccann> `nand`, pointwise is probably the only useful one that fits the required type, for precisely that reason
15:03:17 <Nisstyre> Nereid: where is that Monad instance defined?
15:03:39 <cmccann> but pointwise multiplication isn't really sensible otherwise
15:03:41 <Nisstyre> the one for (t ->)
15:03:54 <Nereid> it isn't in the prelude?
15:04:01 <c_wraith> depends on the version of ghc
15:04:01 <Nereid> or maybe Control.Monad.Instances
15:04:07 <Nisstyre> Nereid: when I do :i Monad, I don't see it
15:04:20 <c_wraith> but importing Control.Monad.Instances will always pick it up
15:04:27 * cmccann sees "instance Monad ((->) r) -- Defined in GHC.Base"
15:04:27 <`nand`> cmccann: it's all informally hand-wavy helper-magic either way; usually you'd use a real VectorSpace class
15:04:29 <fragamus> all I want for Christmas is to understand comonads
15:04:42 <Nisstyre> c_wraith: that worked
15:04:59 <Nisstyre> cmccann: well for some reason it didn't show up when I started ghci
15:05:16 <Nisstyre> maybe that's a problem with my version of GHC/Haskell Platform?
15:05:50 <cmccann> `nand`, yeah, trying to wedge vector-y things into Num is a long-standing annoyance of mine
15:06:12 <`nand`> cmccann: at the end of the day, gloss is just about convenience, and having Num (a,b) is just too convenient
15:06:13 <cmccann> wedge was totally not intended to be a pun there fyi
15:06:24 <Nereid> flebron: anyway, it's basically dual to how (r,) is a monad if r is a monoid
15:06:38 <flebron> right
15:06:40 <`nand`> fragamus: do you understand monads?
15:06:43 <cmccann> `nand`, yeah and I write instances like that when I just want to do some simple stuff with coordinates
15:07:06 <`nand`> cmccann: if anything, it's the orphan instances that cause problems
15:07:13 <cmccann> `nand`, one of these days I need to finish that geometric algebra implementation I was working on, multivectors actually have a 100% legit Num instance!
15:07:16 <Nereid> and (r,) is always a comonad (because r is a comonoid), and (r ->) is a comonad if r is a monoid.
15:07:17 <Nereid> :p
15:07:30 <zenzike> `nand`: yes, I have no issue with the instances being there, I was just shocked when it happened, and :i Num gave me nothing
15:07:33 <cmccann> `nand`, I usually make my own type instead of using (,) actually
15:07:46 <hiptobecubic> which one is free? newtype?
15:07:52 <cmccann> and then give it a zippy Applicative instance
15:08:14 <`nand`> cmccann: fair enough. My use case was using lens combinators like *= 3, += v and ‘both’ ;)
15:08:33 <skp> hi there
15:08:40 <Nereid> hi
15:08:42 <elliott> pfft, both is old hat
15:08:46 <elliott> each is the fancy new thing
15:08:51 <`nand`> :t each
15:08:52 <lambdabot> Not in scope: `each'
15:08:53 <cmccann> `nand`, man why is everything is about lenses these days
15:09:06 <Nereid> each is to be releasde in 3.8
15:09:06 <elliott> http://ekmett.github.com/lens/Control-Lens-Each.html
15:09:07 <`nand`> each :: (Indexable i p, Each i f s t a b) => IndexedLensLike p f s t a b
15:09:08 <`nand`> there is no god
15:09:12 <elliott> also exists in reno
15:09:15 <elliott> argh
15:09:17 <elliott> also exists in released versions
15:09:20 <elliott> Nereid: no, each is already out
15:09:25 <Nereid> it is?
15:09:26 <elliott> http://hackage.haskell.org/packages/archive/lens/3.7.1.2/doc/html/Control-Lens-Each.html
15:09:27 <cmccann> cf. http://hackage.haskell.org/packages/archive/lens/3.7.1.2/doc/html/Control-Lens-Each.html
15:09:29 <Nereid> oh ok
15:09:31 * cmccann shakes his fist
15:09:37 <Nereid> then lambdabot is out of date.
15:09:40 <elliott> yes
15:09:44 <`nand`> is ‘each’ a generalization of ‘traverse’?
15:09:46 <elliott> cmccann: lens is the new Prelude!
15:09:50 <cmccann> lambdabot? out of date? madness!
15:09:53 <elliott> `nand`: not really, consider tuples
15:09:58 <`nand`> oh, right
15:10:05 <elliott> also there's e.g. no instance for Either because it wants to deal with "monomorphic containers" instaed
15:10:14 <`nand`> just figuring out when I can use ‘each’ for stuff like String instead of ‘traverse’
15:10:46 <elliott> the thing with each is it e.g. gets the keys of maps right etc.
15:11:01 <`nand`> itraverse doesn't?
15:11:27 <elliott> well, yes
15:11:29 <elliott> that's not traverse though :)
15:11:29 <Catnaroek> Nereid: Is the categorical dual of the left identity for monoids a right identity and vice versa?
15:11:49 <Nereid> ??
15:11:51 <`nand`> ah, well; I meant traverse/itraverse
15:12:01 <eyebloom> byorgey: The book we were talking about yesterday is Types and Programming Languages by Benjamin C. Pierce?
15:12:04 <`nand`> come to think of it, I've absolutely never used indexed traversals
15:12:10 <`nand`> explicitly, at least
15:12:28 <Nereid> Catnaroek:
15:12:44 <Nereid> ok, abstracting to an arbitrary monoidal category with unit I and product *,
15:12:57 <Nereid> a monoid is a thing M together with a unit I -> M and product M * M -> M
15:12:58 <edwardk> `nand`: the main use of 'each' is that it can be used for things like Text
15:13:27 <Nereid> the statement that the unit is a left identity says that
15:13:29 <Nereid> uh
15:13:40 <`nand`> what, so you don't have to import Data.Text.Lens (text) ?
15:13:50 <Nereid> M = I * M --(unit * id)-> M * M -> M is the identity.
15:13:50 <edwardk> `nand`: correct.
15:13:53 <`nand`> I see
15:13:59 <edwardk> the latter may be useful for disambiguation
15:14:02 <ben_> @pl "f x = x + x"
15:14:03 <lambdabot> "f x = x + x"
15:14:07 <edwardk> but if you have the type you can of course just use each
15:14:33 <`nand`> edwardk: the idiom shall me “whichever makes the code read out loud nicer”
15:14:38 <`nand`> s/me/be/
15:14:44 <edwardk> you can even go back and forth to the strict and lazy versions without importing
15:14:47 <c_wraith> edwardk: did I see that the minimal requirements for a package data type to use lens is to implement Traversable?
15:14:50 <edwardk> `nand`: pretty much
15:14:54 <Catnaroek> Nereid: I find your notation somewhat confusing... I thought the left identity law was something like "forall x : M, id * x = x"
15:14:55 <Nereid> Catnaroek: so its dual, for a comonoid M, is that M -(coproduct)-> M * M -(counit * id)-> I * M = M is the identity
15:15:00 <`nand`> yeah, that's a nice pro
15:15:03 <ben_> @type map
15:15:04 <lambdabot> (a -> b) -> [a] -> [b]
15:15:17 <`nand`> I've always thought the common elements between strict/lazy versions of libraries should be overloaded
15:15:17 <edwardk> c_wraith: basically Traversable is a valid traversal. you can use all the lens combinators with it
15:15:20 <Nereid> Catnaroek: sure, on points. but we don't want to talk about points.
15:15:25 <edwardk> you can make other traversals or lenses for your types
15:15:35 <edwardk> but you don't need anything outside of the prelude to define them
15:15:37 <`nand`> c_wraith: depends on what lenses you want to write
15:15:51 <`nand`> edwardk: does that change with the new profunctor representation and stuff?
15:15:52 <edwardk> you need to go fancier if you want prisms or isomorphisms or indexed traversals, etc.
15:16:00 <Nereid> Catnaroek: so we replace points with arrows out of (), so that we can talk about things in terms of category
15:16:15 <Catnaroek> Nereid: Okay.
15:16:16 * elliott isn't sure what c_wraith's question means
15:16:29 <elliott> what does it mean for a data type to use lens?
15:16:29 <edwardk> `nand`: the profunctor representation makes it so you can import profunctors and you could with enough elbow grease define your own prisms and isomorphisms and equalities that are lens-compatible without lens
15:16:33 * Catnaroek brings a notebook.
15:16:46 <edwardk> `nand`: profunctors is a completely haskell 98 package
15:16:48 <c_wraith> elliott: to use the combinators in the lens package to work with the data type
15:16:57 <edwardk> that means lens is only needed to do getters and folds and setters
15:16:59 <elliott> c_wraith: no, you can work with non-Traversable data types in lens of course
15:17:02 <`nand`> edwardk: that's what I figured. and yeah, that sounds nice
15:17:07 * cmccann wonders if his linear logic encoding could be translated into some sort of lens stuff
15:17:12 <edwardk> oh and indexing
15:17:13 <elliott> c_wraith: what is true is that "traverse" works directly as a Traversal for any Traversable instance
15:17:18 <elliott> simply due to how Traversals are defined
15:17:19 <zhulikas> newtype State s a = State { runState :: s -> (a,s) }
15:17:20 <zhulikas> instance Monad (State s) where
15:17:28 <elliott> cmccann: something about affine and relevant traversals...
15:17:44 <zhulikas> sorry!
15:18:02 <zhulikas> soon after pasting I realised that s in monad instance is a value which is returned by runState
15:18:05 <edwardk> elliott: heh, see, with cmccann on board nobody will be able to stop my affine/relevant naming scheme ;)
15:18:06 <cmccann> elliott, plus the representation is pretty similar
15:18:17 <c_wraith> elliott: I should have said "a minimum", not "the minimum".  It's one of those bare-minimum efforts which works.
15:18:17 <Nereid> Catnaroek: ah, there are pictures. http://en.wikipedia.org/wiki/Monoid_object
15:18:42 <elliott> c_wraith: sure. but it's only one kind of "working with" lens, really
15:18:50 <elliott> you don't get, like, lenses for record fields that way
15:18:52 <Catnaroek> Nereid: ty lemme see
15:18:55 <elliott> just the ability to traverse traversable stuff :P
15:19:46 <`nand`> edwardk: slightly weakens the hypothetical “write a lens combinator and it'll work with every lens package henceforth” argument, because how many are incorporating profunctors? ;)
15:19:54 <Nereid> Catnaroek: so to get the comonoid laws, you just reverse all the arrows, replacing the unit and product with the counit and coproduct
15:19:55 <`nand`> s/combinator//
15:20:04 <elliott> `nand`: well it beats previously, when you couldn't define isos/prisms without lens itself
15:20:12 <`nand`> elliott: definitely
15:20:22 <Nereid> (and alpha/lambda/rho with their inverses)
15:20:24 <`nand`> “how many other lens packages have prisms?”
15:20:24 <elliott> profunctors just depends on comonad and tagged and it's H98-only, so it's not that much to ask
15:20:32 <elliott> of course maybe profunctors should be in base, but... :P
15:20:49 <ben_> @PL "divisible n divisor = mod n divisor == 0"
15:20:49 <lambdabot> Maybe you meant: . ? @ bf do ft id pl rc v wn
15:20:54 <`nand`> rmap and lmap needs to be in Prelude
15:21:14 <ben_> @pl "divisible n divisor = mod n divisor == 0"
15:21:15 <lambdabot> "divisible n divisor = mod n divisor == 0"
15:21:21 <Nereid> use fewer ""
15:21:23 <`nand`> that's a string literal, ben_
15:21:37 <Catnaroek> Nereid: This will keep me thinking for a while. Sorry.
15:21:44 <ben_> @PL "f x = x + x"
15:21:45 <lambdabot> Maybe you meant: . ? @ bf do ft id pl rc v wn
15:21:54 <Nereid> @pl divisible n divisor = mod n divisor == 0
15:21:54 <lambdabot> divisible = flip flip 0 . ((==) .) . mod
15:21:58 <Nereid> heh.
15:22:02 <`nand`> ..
15:22:03 <Nereid> @pl divisible n divisor = 0 == mod n divisor
15:22:03 <lambdabot> divisible = ((0 ==) .) . mod
15:22:13 <`nand`> :t (0==) .: mod
15:22:13 <ben_> hah
15:22:14 <lambdabot> Integral a => a -> a -> Bool
15:22:20 <Nereid> what the heck is flip flip 0?
15:22:22 <Nisstyre> how does on use lambdabot to look up instances?
15:22:25 <Nisstyre> *one
15:22:26 <Nereid> you don't
15:22:30 <Nisstyre> ah ok
15:22:30 <Nereid> @instances Int
15:22:32 <lambdabot> Couldn't find class `Int'. Try @instances-importing
15:22:33 <ben_> my apologies people
15:22:36 <Nereid> @instances Monoid
15:22:37 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, First a, Last a, Maybe a, Ordering, Product a, Sum a, [a]
15:22:39 <Nereid> oh ok
15:22:40 <`nand`> :t flip flip
15:22:41 <lambdabot> b -> (a -> b -> c) -> a -> c
15:22:45 <Nisstyre> Nereid: yeah I meant the actual source
15:22:46 <Nereid> ah right.
15:22:56 <Nisstyre> not possible then?
15:22:56 <Nereid> ok, lambdabot won't do that.
15:23:00 <Nisstyre> okay
15:23:05 <`nand`> Nisstyre: depends on the instance
15:23:13 <Nisstyre> `nand`: Monad instances?
15:23:20 <`nand`> @src Monad Writer
15:23:21 <lambdabot> Source not found. It can only be attributed to human error.
15:23:23 <`nand`> hmm
15:23:28 <Nereid> @instances also won't show constraints
15:23:29 <`nand`> @src Monad (->)
15:23:29 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
15:23:31 <Catnaroek> Nereid: Are alpha, lambda, and rho the proofs themselves of the monoid laws?
15:23:33 <`nand`> there should be some like that
15:23:39 <Nereid> Catnaroek: no, they're part of the structure of the monoidal category
15:23:42 <elliott> @src -> return
15:23:42 <lambdabot> Source not found. I feel much better now.
15:23:44 <elliott> @src (->) return
15:23:44 <lambdabot> return = const
15:23:46 <elliott> @src (->) (>>=)
15:23:47 <lambdabot> f >>= k = \ r -> k (f r) r
15:23:48 <Nereid> Catnaroek: e.g. alpha is the isomorphism ((a,b),c) -> (a,(b,c))
15:23:59 <`nand`> there you go
15:24:16 <Nisstyre> `nand`: okay, thanks
15:24:16 * `nand` always forgets the arcane pseudo-syntax @src uses
15:24:21 <Nereid> elliott: what, that's new.
15:24:24 <Catnaroek> Nereid: How is that isomorphism not a proof of the associativity law?
15:24:40 <`nand`> @src State (>>=)
15:24:40 <elliott> Nereid: no it's not :P
15:24:40 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
15:24:41 <Nereid> Catnaroek: that isomorphism has nothing to do with monoids.
15:24:49 <Nereid> elliott: it is to me!
15:25:02 <Nereid> Catnaroek: it's the diagram that is the statement of the associativity law.
15:25:07 <Nereid> of the coproduct.
15:25:25 <Nereid> alpha gives associativity of the monoidal product in the monoidal category.
15:25:32 <Nereid> it has nothing to do with M itself.
15:25:36 <mikeplus64> @src (a,b) mappend
15:25:36 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
15:25:41 <`nand`> seems like it's missing State/Writer/Reader; but it the Prelude ones like Maybe
15:26:33 <`nand`> (of course, it's all very hocus pocus; the real source file is here: http://code.haskell.org/lambdabot/State/source )
15:26:46 <mikeplus64> @src Maybe fmap
15:26:46 <lambdabot> fmap _ Nothing       = Nothing
15:26:47 <lambdabot> fmap f (Just a)      = Just (f a)
15:26:59 <mikeplus64> @src (Maybe a) mappend
15:26:59 <lambdabot> Source not found. That's something I cannot allow to happen.
15:27:02 <Nisstyre> @src [a] fmap
15:27:02 <lambdabot> Source not found. Maybe if you used more than just two fingers...
15:27:03 <neutrino> hi
15:27:08 <`nand`> so instead of consulting @src, you might as well just grep that file; or better yet, check haddock
15:27:11 <Nisstyre> hmm
15:27:16 <Nisstyre> my syntax must be off there
15:27:18 <`nand`> s/haddock/hackage\/haddock/
15:27:19 <neutrino> does the function "old" from the "stm invariants" paper have an implementation?
15:27:24 <`nand`> @src [] fmap
15:27:24 <lambdabot> fmap = map
15:27:25 <Nisstyre> `nand`: fair enough
15:27:56 <neutrino> it is used for accessing the previous version of a tvar, that is the value it had at the beginning of the atomic bloc
15:29:11 <Nereid> :t const mempty *** id
15:29:12 <lambdabot> Monoid c => (b, c') -> (c, c')
15:29:22 <Nereid> :t uncurry mappend
15:29:24 <lambdabot> Monoid c => (c, c) -> c
15:29:33 <Nereid> :t uncurry mappend . (const mempty *** id)
15:29:34 <lambdabot> Monoid b => (b1, b) -> b
15:29:38 <Nereid> is supposed to equal snd.
15:29:49 <Nereid> well,
15:29:58 <Nereid> :t uncurry mappend . ((\() -> mempty) *** id)
15:29:59 <lambdabot> Monoid b => ((), b) -> b
15:30:26 <ben_> @pl f x = x * x
15:30:27 <lambdabot> f = join (*)
15:31:08 <mikeplus64> :t join (*)
15:31:09 <lambdabot> Num a => a -> a
15:31:46 <Nereid> @let eta = \() -> mempty; mu = uncurry mappend; alpha ((a,b),c) = (a,(b,c))
15:31:48 <lambdabot>  Defined.
15:32:02 <Nereid> :t mu . (mu *** id)
15:32:04 <lambdabot> Monoid b => ((b, b), b) -> b
15:32:10 <Nereid> :t mu . (id *** mu) . alpha
15:32:12 <lambdabot> Monoid b => ((b, b), b) -> b
15:33:02 <Nereid> Catnaroek: ^
15:33:13 <Nereid> the associativity law is the statement that these two are equal.
15:33:47 <Catnaroek> Nereid: Oh, by "the isomorphism", I meant "the morphism and the proof that it is an isomorphism".
15:33:58 <Nereid> huh?
15:35:35 <Catnaroek> Well, I am too dumb to understand this abstractly, so I am focusing on one particular monoidal category: the objects are types, and the morphisms are functions, with I = () and (x) = the tuple type constructor.
15:35:54 <Nereid> yes.
15:36:28 <Nereid> then alpha :: ((a,b),c) -> (a,(b,c)); alpha ((a,b),c) = (a,(b,c))
15:36:44 <Nereid> lambda ((),a) = a, rho (a,()) = a
15:37:25 <Nereid> @let lambda ((),a) = a; rho (a,()) = a
15:37:27 <lambdabot>  Defined.
15:37:45 <Catnaroek> Wait, wait, what exactly are a,b,c? (Regular) values or types?
15:37:49 <Nereid> any type
15:37:51 <Nereid> well
15:38:04 <Nereid> in the type sig, they're types. in the definition, they're values.
15:38:15 <Catnaroek> Ah, of course.
15:38:22 <mikeplus64> how does GHC define simple ADTs like Bool? just as a single Word64 (where 0 might be False, 1 might be True)?
15:38:34 <Nereid> but alpha, lambda, and rho are part of the structure of the monoidal category
15:38:39 * hackagebot splot 0.3.7 - A tool for visualizing the lifecycle of many concurrent multi-staged processes.  http://hackage.haskell.org/package/splot-0.3.7 (EugeneKirpichov)
15:38:44 <Nereid> mikeplus64: data Bool = False | True
15:38:55 <Nereid> or do you mean how is that represented?
15:39:01 <mikeplus64> i mean it's representation
15:39:08 <mikeplus64> its*
15:39:17 <luite> mikeplus64: a pointer
15:39:24 <luite> to a statically allocated heap object
15:39:50 <Catnaroek> Nereid: So just alpha, alpha_inv (a,(b,c)) = ((a,b),c), and a proof that alpha . alpha_inv = id would be a proof of the associativity law alone, right?
15:40:13 <mikeplus64> luite: ok
15:40:18 <Nereid> Catnaroek: that's required as part of the definition of a monoidal category.
15:40:23 <Nereid> that alpha is an isomorphism.
15:40:37 <Nereid> >>> unsafeCoerce False :: Int
15:40:38 <Nereid> 1090478512
15:40:59 <Nereid> oh I probably should have used Word64.
15:41:11 <Nereid> same result
15:42:07 <luite> mikeplus64: ghc uses pointer tagging, so for small adts, the constructor is encoded directly in the tag, pointer never needs to be dereferenced
15:42:08 <mikeplus64> Nereid: maybe unsafeCoerce False :: Ptr Word64?
15:42:14 <mikeplus64> oh
15:42:47 <Catnaroek> luite: Oh, smart.
15:42:56 * Nereid knows nothing about ghc internals
15:43:22 <zhulikas> fewLogs' :: State [String] String
15:43:22 <zhulikas> fewLogs' = do { a <- log' "whatup"; b <- log' "mkay"; return $ a ++ b } -- so what happens here is a some sort of state change composition which will be applied upon running fewLogs' against a certain state
15:43:55 <zhulikas> similarly as do { a <- (+5); b <- (+4); return $ a + b }
15:44:38 <zhulikas> so all this 'magic' where get/put functions of a State monad look like they doesn't act upon values, they actually will do when value will be supplied for a runState
15:44:58 <mikeplus64> luite: interesting, that maybe explains unsafeCoerce True :: Ptr Word64 causing a segfault?
15:45:26 <zhulikas> so the last bit of mistery is how is this composition being done and for that I need to look into (->) a
15:45:37 <zhulikas> am I so far correct or talking nonsense?
15:45:49 <mikeplus64> luite: wait no it's just peeking at it that does
15:45:54 <zhulikas> http://codepad.org/GS1tTiEt
15:46:02 <Nereid> zhulikas: I don't understand what you're saying.
15:46:07 <zhulikas> ok :/
15:46:11 <luite> mikeplus64: hm, would it segfault if the pointer is not aligned properly?
15:46:19 <zhulikas> thought so
15:46:44 <luite> i guess you can fix it by clearing the lower 3 bits
15:46:47 <zomg> zhulikas: I recall with state the get/put stuff is achieved by implementing >>= and >> in certain ways, since that's what the do-notation translates into
15:47:17 <ben_> @let divis = ((0 ==) .) . mod
15:47:19 <lambdabot>  Defined.
15:47:41 <nexor> > divis 9
15:47:43 <lambdabot>   No instance for (GHC.Show.Show (a0 -> GHC.Types.Bool))
15:47:43 <lambdabot>    arising from a us...
15:47:47 <nexor> > divis 9 3
15:47:49 <lambdabot>   True
15:47:52 <nexor> > divis 9 4
15:47:54 <lambdabot>   False
15:48:04 * elliott wants "divides" in Prelude
15:48:05 <ben_> @pl f x y = not $ divis x y
15:48:06 <lambdabot> f = (not .) . divis
15:48:38 <nexor> > let divides a b = mod a b == 0 in divies 9 3
15:48:39 <lambdabot>   Not in scope: `divies'
15:48:40 <lambdabot>  Perhaps you meant one of these:
15:48:40 <lambdabot>    `divides' (line ...
15:48:47 <nexor> > let divides a b = mod a b == 0 in divides 9 3
15:48:48 <lambdabot>   True
15:48:52 <ben_> f 9 3
15:48:53 <nexor> > let divides a b = mod a b == 0 in divides 9 4
15:48:55 <lambdabot>   False
15:49:11 <nexor> > let divides a b = mod a b == 0 in divides 10 0
15:49:13 <lambdabot>   *Exception: divide by zero
15:49:25 <ben_> > f 9 3
15:49:27 <lambdabot>   Ambiguous type variable `a0' in the constraints:
15:49:27 <lambdabot>    (GHC.Show.Show a0)
15:49:27 <lambdabot>     ...
15:49:52 <zhulikas> zomg, so >>= allows chaining States...
15:49:57 <nexor> @let divides a b = (mod a b) == 0
15:49:59 <lambdabot>  Defined.
15:50:14 <zhulikas> then I guess I am doing something similar in that above mentioned do notation
15:50:25 <nexor> > 9 `divides` 3
15:50:28 <lambdabot>   True
15:50:52 <zhulikas> > (1,2) + (3,4)
15:50:54 <lambdabot>   No instance for (GHC.Num.Num (t0, t1))
15:50:54 <lambdabot>    arising from a use of `e_11234'
15:50:54 <lambdabot>  ...
15:50:59 <zomg> zhulikas: >>= and >> chain monads, but what it does is specific to the monad being chained
15:51:26 <nexor> @let divides a b = (mod b a) == 0
15:51:27 <lambdabot>  <local>:6:1:
15:51:27 <lambdabot>      Warning: Pattern match(es) are overlapped
15:51:27 <lambdabot>               In...
15:51:30 <zhulikas> ok, thanks
15:51:36 <nexor> > 9 `divides` 3
15:51:37 <zhulikas> just realized it's sort of time to sleep
15:51:39 <lambdabot>   True
15:51:45 <nexor> damn it backwards
15:52:02 <zhulikas> hopefully tomorrow being refreshed I'll be able to comprehent it much easier
15:52:19 <zhulikas> see you around
15:52:26 <popl> > reverse "damn it"
15:52:28 <lambdabot>   "ti nmad"
15:52:32 <popl> nexor: ^
15:52:44 <x-SuriV> Does Lamba bot only respond to certain people?
15:53:10 <popl> x-SuriV: yes
15:53:29 <Nereid> yes, it only response to the people who give it commands
15:53:39 * hackagebot timeplot 1.0.19 - A tool for visualizing time series from log files.  http://hackage.haskell.org/package/timeplot-1.0.19 (EugeneKirpichov)
15:53:42 <x-SuriV> reverse "wtf"
15:53:43 <monochrom> hehe, exactly what I wanted to say :)
15:53:56 <Nereid> > reverse "wtf"
15:53:58 <lambdabot>   "ftw"
15:54:07 <Nereid> note the >
15:54:14 <x-SuriV> OHHH
15:54:17 <popl> Nereid: He would have never figured it out.
15:54:22 <x-SuriV>  > "Hello " ++ "World"
15:54:23 <Nereid> :-)
15:54:33 <x-SuriV> > "Hello " ++ "World"
15:54:35 <lambdabot>   "Hello World"
15:55:08 <popl> x-SuriV: You can talk to the bot in a private message and it will respond
15:55:12 <x-SuriV> monochrom: Are you the same monochrom on the various IRC math channels?
15:56:05 <monochrom> I am in efnet #math. I am in no other math channels
15:56:24 <x-SuriV> yep that's where I have seen you before "D
15:56:25 <x-SuriV> :D
15:56:55 <popl> oh brother
15:58:33 <monadicity> any tips on succeeding in math class?
15:58:45 <Taneb> Don't waste your time on IRC
15:58:53 <x-SuriV> Do all the homework
15:59:14 <djahandarie> Learn the material before taking the class.
15:59:21 <popl> give up and look for a job in the service industry
15:59:28 <popl> beat the curve
15:59:33 <monadicity> I try to do homeowkr but some is harder than my capability
15:59:52 <popl> monadicity: McDonald's is always hiring.
16:00:20 <Taneb> monadicity, don't be afraid to ask questions
16:00:37 <popl> s/ask questions/look stupid/
16:00:46 <x-SuriV> popl: Quite the optimist aren't you? lol
16:01:24 <parcs> most schools and universities have provide peer tutoring
16:03:25 <popl> x-SuriV: Optimism will get you killed.
16:04:47 <cmccann> elliott: ok so I can rewrite my linear logic stuff as something resembling a lens but I can't quite mangle it enough to work as one
16:05:15 <elliott> cmccann: heh
16:05:20 * roconnor finds myself wanting a ML module functor
16:05:24 <elliott> cmccann: well you don't have to worry so much about the (a -> f b) -> s -> f t thing
16:05:33 <elliott> the hip new theoretical one is (k a b -> k s t)
16:06:15 <roconnor> `nand`: do I use the same transfer function for both Rec 709 and Rec 601?
16:06:32 <cmccann> and my linear logic encoding is basically (forall r. (g r -> r) -> (f r -> r))
16:07:24 <cmccann> and I can easily make it more flexible in the result type instead of using the closed-off cps-y business
16:08:19 <cmccann> but I can't see any way around needing something of a kind that isn't * to represent to source and target types
16:09:40 <elliott> cmccann: oh you have the cokleisli form
16:09:45 <elliott> shades of symmetric lenses
16:09:52 <cmccann> yes
16:10:12 <cmccann> it's actually inspired by modeling some generalized version of categories
16:10:16 <cmccann> that I got from nlab
16:10:24 <elliott> cmccann: that should be ok theoretically. we like (p a b -> p s t) for profunctors p these days, and Cokleisli w is a profunctor
16:10:39 <elliott> well, DownStar is probably more accurate than Cokleisli, but whatever
16:11:00 <cmccann> anyway, the real problem is that the source and target types need to be parameterized by the result type
16:11:06 <cmccann> in order to encode negation
16:11:28 <elliott> I forget what your negation encoding is
16:11:40 <cmccann> it might help if I had any idea what this would actually do if it did work
16:11:41 <cmccann> but pf
16:11:55 <popl> cmccann: science
16:12:00 <cmccann> elliott: cf. http://hpaste.org/75222
16:12:29 <cmccann> I have a buncha newtype clutter but that can actually be removed as it turns out
16:12:34 <cmccann> not sure why I didn't realize that before
16:12:59 <cmccann> at which point you get the same id is id and (.) is backwards composition behavior as lenses
16:13:50 <cmccann> elliott: so (Not f) is (f r -> r) where "r" is the ambient result type
16:14:06 <cmccann> which basically means you can throw away a value of whatever "f" means in a useful way
16:14:32 <elliott> cmccann: right
16:14:35 <cmccann> since "not a" means a sink for something of type a
16:14:39 <cmccann> basically a continuation
16:15:30 <cmccann> negation is kind of the heart of the whole thing, at least for my encoding
16:15:47 <cmccann> since the positive connectives work like the regular (,) and Either
16:15:59 <cmccann> and I get the negative connectives via de morgan
16:18:08 <cmccann> elliott, brb getting pie
16:18:22 <cmccann> figure this out while I'm afk plzkthx
16:20:29 <hpaste> mewalz pasted “Meter” at http://hpaste.org/79732
16:20:31 <mewalz> any ideas on how to write the function test
16:22:34 <ben_> divis 2 3
16:22:55 <sdrodge> Is there an easy way to modify a function from a module not under your control that makes use of non-exported symbols?
16:22:55 <hpaste> Rileld pasted “New user having trouble with cabal build” at http://hpaste.org/79733
16:23:08 <byorgey> ben_: ?
16:23:13 <Taneb> > divis 2 3
16:23:16 <lambdabot>   False
16:23:21 <ben_> hello
16:23:23 <byorgey> sdrodge: no
16:23:24 <Rileld> Hi, I'm fairly new to haskell, and I'm trying to get cabal to build me project
16:23:32 <sdrodge> byorgey: no module inheritance?
16:23:39 <byorgey> sdrodge: nope
16:23:42 <elliott> cmccann: I already figured it all out and am just hiding it from you for the good of the universe, sorry
16:23:42 <sdrodge> :(
16:23:56 <cmccann> elliott, dammit I should have known
16:24:14 <cmccann> what sorta category do lenses give you?
16:24:19 <Rileld> If anyone know what's wrong with http://hpaste.org/79733 let me know :)
16:24:23 <elliott> um, ask shachaf
16:24:23 <byorgey> Rileld: if you have a module named Sync it needs to be in  Sync.hs, not Sync/Sync.hs
16:24:36 <byorgey> Rileld: in general the module Foo.Bar.Baz  needs to be in  Foo/Bar/Baz.hs
16:25:11 <byorgey> Rileld: also, it's probably easier to use 'cabal init' to create an initial .cabal file, rather than copying it
16:25:15 <ben_> @pl f xs = (filter (\x -> not $ (divis x 2)) xs)
16:25:16 <lambdabot> f = filter (not . flip divis 2)
16:25:25 <Taneb> cmccann, http://en.wikipedia.org/wiki/Category:History_of_England_by_county is the category lenses give us
16:25:26 <Taneb> Of course
16:25:40 <cmccann> haha
16:26:05 <Rileld> byorgey: The file Sync.hs is in the directory Sync. Should it be in the base directory?
16:26:12 <ben_> @pl f n xs = (filter (\x -> not $ (divis x n)) xs)
16:26:13 <lambdabot> f = filter . (not .) . flip divis
16:26:31 <byorgey> Rileld: yes, if it contains 'module Sync where' ...
16:26:50 <byorgey> Rileld: if Sync.hs is in the directory Sync then it has to contain 'module Sync.Sync where ...'
16:29:36 <mewalz> never mind on my question, the problem was more structural than anything
16:29:39 <eyebloom> byorgey: The book we were talking about yesterday was  Types and Programming Languages by Benjamin Pierce?
16:32:02 <nexor> > 9 `divides` 3
16:32:05 <lambdabot>   True
16:33:16 <Rileld> byorgey: Thanks, that worked. However cabal says "there is no Main module", even though I have "main-is: Sync.hs" is the cabal file.
16:38:40 * hackagebot zeromq3-haskell 0.2 - Bindings to ZeroMQ 3.x  http://hackage.haskell.org/package/zeromq3-haskell-0.2 (ToralfWittner)
16:38:44 <lolcathost> Hello. Using conduit or some other iteratee library, is it possible to open two or more files simultaneously, and process the contents of one in a way that is dependent from the data read from the other one?
16:39:08 <lolcathost> dependent on*
16:40:15 <lolcathost> For example, reading a number from one file, and then reading that number of lines from the second file.
16:40:32 <droidboi> I am trying to install the Haskell Platform on this Linux Mint 11. I get to  http://packages.debian.org/squeeze/haskell-platform , but then don't know what to.
16:40:44 <byorgey> eyebloom: yes
16:40:58 <eyebloom> Thanks
16:42:08 <byorgey> Rileld: hmm, strange.  Can you paste your current .cabal file and directory structure again?
16:45:20 <hpaste> Rileld pasted “Cabal issue: updated file structure and cabal file” at http://hpaste.org/79734
16:49:54 <hpaste> Rileld annotated “Cabal issue: updated file structure and cabal file” with “Cabal issue: updated file structure and cabal file (annotation)” at http://hpaste.org/79734#a79735
16:50:52 <cmccann> elliott, is there anything comparable to (***) or (&&&) for lenses?
16:52:48 <elliott> :t (&&&)
16:52:49 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
16:52:50 <elliott> :t (***)
16:52:51 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
16:52:52 <elliott> I always mix those up
16:53:17 <Rileld> droidboi: Is your Mint debian based? If so try sudo apt-get install haskell-platform
16:53:29 <elliott> cmccann: you can't really do (&&&) AIUI
16:53:33 <elliott> cmccann: the problem is: _1 &&& _1
16:53:41 <elliott> the two lenses/traversals can overlap
16:53:42 <cmccann> right
16:53:56 <elliott> cmccann: (***) is http://hackage.haskell.org/packages/archive/lens/3.7.1.2/doc/html/Control-Lens-Type.html#v:alongside
16:54:30 <cmccann> ah, and it has the Either version as well
16:54:35 <cmccann> ok so
16:54:54 <cmccann> turning linear implication into a lens ought to allow (&&&) to work
16:54:55 <cmccann> somehow
16:55:00 <edwardk> we can do (***) but (&&&) requires bad things. you use the parts of the container in a non-linear manner ;)
16:55:08 <cmccann> by not letting you use both sides somehow
16:55:15 <byorgey> Rileld: what happens if you do 'cabal clean' and then 'cabal configure && cabal build' again?
16:55:43 <byorgey> actually, I need to go, but hopefully that helps
16:55:44 <edwardk> what you need for that is to split the lens into the target of the lens and the 'bokeh' and run the remaining lenses on that
16:56:34 <edwardk> we started playing with designs for that and then just kind of optimized our corner of the problem space until we didn't need it enough to bother implementing ;)
16:56:34 <cmccann> edwardk, I'm still just trying to decide what treating linear implication as a lens would actually mean
16:57:12 <edwardk> well, you get some of that, a lens can't use 'part of the structure' more than once, etc.
16:57:17 <popl> go team edwardk!
16:57:26 <cmccann> yeah
16:57:41 <cmccann> and like I was saying earlier, the encoding I used is already pretty similar
16:57:55 <cmccann> more flipped Kleisli Cont stuff
16:58:07 <edwardk> you can use prisms for the dual notion with similar guarantees
17:01:29 <cmccann> hm, choosing and alongside should work exactly as I'd expect for the positive connectives
17:02:07 <t7> when is the o'reilly Lens book out?
17:02:26 <bitonic``> edwardk: mhm.  I am in the situation when I want to use bound to replace variables only if I need to.  is there an easy way to do that?  I can think of various uglish ways
17:03:10 <cmccann> in particular a and b being the same for choosing but combining two of each for alongside is nice
17:05:19 <t7> this should probably be in blah but; The floss weekly episode on YESOD is really good, check it out!
17:11:56 <edwardk> bitonic: if i need to preserve the original name in the syntax tree i usually just modify the syntax tree to hold strings next to each binder
17:13:42 <bitonic> edwardk: well in my case in my REPL I have some context the terms are in.  If I have a type `foo : Nat -> Type = \n:Nat -> <long expression>' and a term `bar : foo 5', I want `foo 5' to stay `foo 5', without replacing foo
17:13:50 <bitonic> however, sometimes I do have to replace them to type check
17:14:25 <edwardk> nothing prevents you from building an environment and associating that with the 'free' variables
17:14:39 <Moggle> Anyone know of the simplest way to play any kind of music file in a platform-independent way?
17:15:21 <bitonic> edwardk: well what I have works, but I find it hard to come up with a nice solution that lets me optionally decorate terms with names - what I do now is simply to replace all the things with their value before typechecking
17:15:25 <cmccann> Moggle, SDL can be handy for stuff like that
17:16:22 <Rileld> Moggle: this might help http://stackoverflow.com/questions/14005592/play-a-wav-file-with-haskell/14006411
17:17:22 <Moggle> RileId: and it even uses SDL :D
17:17:27 <Moggle> thanks cmccann/RileId
17:17:29 <Moggle> useful!
17:17:38 <Moggle> i was scratching my head at all the music packages on hackage
17:17:41 <bitonic> edwardk: if you have names explicitly you can simply replace at the last moment
17:17:42 <Moggle> so many of them are UNIX onl
17:17:55 <cmccann> Moggle, quite a lot of those are not about "I want to play this sound file"
17:18:08 <Moggle> cmccann: yes, that was the issue :D
17:18:17 <ben_> @pl filterFalse cond xs = filter (\x -> not $ (cond x)) xs
17:18:17 <lambdabot> filterFalse = filter . (not .)
17:18:51 <edwardk> i think we've got the same solution going, we're just talking about it in different ways
17:19:35 <ben_> filterFalse (>5) [1..10]
17:19:35 <cmccann> ok I'm not seeing any way to directly translate my linear implication into lenses, meh
17:19:41 <cmccann> back to doing something else
17:20:08 <edwardk> cmccann: when i have more bandwidth i'll take a stab at it
17:20:23 <cmccann> don't you mean a s t a b?
17:20:47 <Nereid> the lens logo will depict stabbing
17:21:11 * FireFly is convinced the Lens names are just a huge build-up for a silly joke
17:21:20 <ben_> @let filterFalse = filter . (not .)
17:21:22 <lambdabot>  Defined.
17:21:26 <Moggle> I'm on Windows, would anyone recommend MingW or Cygwin?
17:21:30 <edwardk> great, now it involves prisms, a dark side of the moon logo, lambda and blood.
17:21:38 <cmccann> haha
17:21:39 <ben_> filterFalse (>5) [1..10]
17:21:57 <Moggle> > filterFalse (>5) [1..10]
17:21:59 <lambdabot>   [1,2,3,4,5]
17:22:00 <zomg> Moggle: Cygwin in my experience works quite well, though you might want to consider just running a VM
17:22:33 <Moggle> zomg: Platform-independence is ideal, zomg
17:22:39 <Moggle> oh god I use dyour name twice
17:22:42 <Moggle> i am a terrible person
17:22:45 <Moggle> alright, cygwin it is
17:22:48 <edwardk> FireFly: I had it start to tell me that "i m m r s t a b" the other day. i figure when it tells me "i m g o i n g t o e a t y o u r s o u l" that that will be my cue to stop development.
17:23:14 <popl> edwardk: By then it will be too late.
17:23:26 <neutrino> hi
17:23:57 <neutrino> does the function "old" from the "stm invariants" paper have an implementation? it is used for accessing the previous version of a tvar, that is the value it had at the beginning of the atomic block.
17:24:04 * Peaker is insane, when I see cute Python thingies on Reddit, I translate them to Haskell to show it off in Reddit
17:24:28 <neutrino> Peaker: what was the last cute python thingie you did this with?
17:24:31 <Peaker> http://www.reddit.com/r/programming/comments/15bqd4/simulating_a_solar_system_with_python/c7l9ijh?context=3
17:24:32 <popl> Peaker: That just means you're a show off.
17:24:42 <popl> :)
17:24:46 <cmccann> in the next version of Haskell, (->) will be redefined to mean a lens, with the current definition renamed as "BoringFunction"
17:24:59 <Peaker> popl, I want to enlighten others that Haskell fully supercedes Python :)
17:25:00 <elliott> cmccann: ask edwardk about his lens type system
17:25:05 <elliott> and get vagueness in response
17:25:30 <Peaker> popl, the disadvantages are minor and the advantages are huge
17:25:46 <neutrino> Peaker: i asked the php team if haskell supercedes php and they said no because it doesn't do type juggling
17:25:58 <Peaker> "type juggling"?
17:26:01 <edwardk> elliott: =P
17:26:04 <neutrino> yeah
17:26:13 <elliott> 1
17:26:15 <elliott> oops
17:26:18 <neutrino> 12.3 + "5 pigs" = 17.3
17:26:25 <catsbydlo> type juggling is when the language mangles your values sometimes
17:26:38 <Moggle> neutrino: ew, please keep that out of here
17:27:01 <neutrino> why would i, it's a joke as good as any
17:28:58 <neutrino> speaking of stm, i wonder if haskell has a useful vector clock based concurrency control?
17:29:10 <ben_> @pl rm p xs = filterFalse (\x -> x `divisible` p) xs
17:29:11 <lambdabot> rm = filterFalse . flip divisible
17:29:49 <neutrino> ben_: you could have used a section there
17:30:13 <neutrino> (\x -> x `y` z) is the same as (`y` z)
17:31:13 <ben_> aha, thanks
17:31:32 <neutrino> yw
17:31:53 <neutrino> > map (+2) [1..10]
17:31:55 <lambdabot>   [3,4,5,6,7,8,9,10,11,12]
17:31:59 <neutrino> ben_: ^
17:32:31 <neutrino> > map (2/) [1..5]
17:32:33 <lambdabot>   [2.0,1.0,0.6666666666666666,0.5,0.4]
17:32:47 <neutrino> > map (/2) [1..5]
17:32:48 <lambdabot>   [0.5,1.0,1.5,2.0,2.5]
17:33:07 <ben_> the above I use, but I was having trouble with this
17:33:11 <catsbydlo> > map ("%d :-(" `printf`) [1 .. 5] :: [String]
17:33:13 <lambdabot>   ["1 :-(","2 :-(","3 :-(","4 :-(","5 :-("]
17:33:38 <ben_> removeMultiples (p:ps) xs = removeMultiples ps (filterFalse (\x -> x `divisible` p) xs)
17:34:23 <ben_> removeMultiples (p:ps) xs = removeMultiples ps (filterFalse (`divisible` p) xs)
17:35:09 <neutrino> much more readable
17:35:49 <catsbydlo> filter (not . (`divisible` p))
17:37:16 <DrChaos> would somebody please tell me why my lastButOne function has a type of [[a]] -> [a]? http://vpaste.net/oVZ7e
17:37:32 <popl> aw, are we already done bashing PHP?
17:37:38 <latermuse> > map ((++ " :-(") . show) [1..5] :: [String]
17:37:39 <lambdabot>   ["1 :-(","2 :-(","3 :-(","4 :-(","5 :-("]
17:37:45 <x-SuriV> I hate PHP!
17:37:47 <x-SuriV> There
17:37:48 <x-SuriV> done
17:38:25 <ijp> popl: well, it's kinda like beating up a crippled kid
17:38:31 <popl> ijp: fun?
17:38:35 <ijp> :(
17:38:40 <popl> KIDDING
17:38:48 <DrChaos> I'm really trying to get the element just before the last
17:38:51 <catsbydlo> DrChaos: because you're returning [] in the first clause
17:39:03 <catsbydlo> also, stop using length
17:39:37 <zomg> > length [1..]
17:39:41 <lambdabot>   mueval-core: Time limit exceeded
17:40:13 <DrChaos> catsbydlo -> returning [] in the first clause?
17:40:23 <catsbydlo> DrChaos: yes
17:40:27 <Jafet> > nubBy ((>1).:gcd) [2..]
17:40:28 <DrChaos> if a list has only length 1, it should return []
17:40:30 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
17:40:35 <catsbydlo> DrChaos: no, it shouldn't
17:40:44 <catsbydlo> and your code doesn't do that
17:41:40 <DrChaos> well huh, how do I stop using the length function? This requires some thought, and I'm not really sure of all the facilities Haskell makes available to me
17:41:52 <DrChaos> can I use pattern matching?
17:41:57 <catsbydlo> you only need pattern matching (and recursion)
17:42:07 <catsbydlo> (you're already using pattern matching)
17:42:57 <DrChaos> so just before the line that reads "lastButOne (x:xs) = ...", I put "lastButOne (x:y:yz) = ..."?
17:43:20 <Jafet> > (last . init) [a,b,c]
17:43:22 <lambdabot>   b
17:44:31 <DrChaos> well, I'll tias
17:45:18 <popl> DrChaos: typically best
17:45:34 <DrChaos> grr...I
17:45:40 <DrChaos> I'm having trouble with the type signature
17:46:12 <DrChaos> it tells me something to the effect of lastButOne can't have type [a] -> a
17:46:38 <catsbydlo> start with the simplest case (only)
17:49:16 <DrChaos> do I really even need the null function? how fast does the null function run? does it run in constant time?
17:49:25 <cmccann> yes.
17:49:34 <Jafet> @src null
17:49:34 <lambdabot> null []     = True
17:49:34 <lambdabot> null (_:_)  = False
17:49:34 <simpson> DrChaos: null [] = True; null _ = False
17:49:46 <catsbydlo> you don't need the null function
17:50:00 <DrChaos> do I even need an if statement?
17:50:12 <cmccann> not if you pattern match.
17:50:28 <cmccann> which you should, if you're checking for an empty list because you want the first element if it exists.
17:51:19 <DrChaos> hold on, let me tinker with the code for a while
17:53:15 <DrChaos> ok, I have this: lastButOne (x:y:xs) = if null xs then x else lastButOne xs
17:53:45 <catsbydlo> too complicated
17:53:50 <catsbydlo> that's not the simplest case
17:54:15 <tgehr> I don't think it is correct either
17:54:24 <DrChaos> the simplest case is an empty list
17:54:42 <catsbydlo> DrChaos: really? what is the result for an empty list?
17:54:47 <x-SuriV> []
17:54:53 <DrChaos> an empty list is the result
17:54:57 <catsbydlo> DrChaos: impossible
17:55:01 <catsbydlo> your function doesn't return a list
17:55:20 <DrChaos> OH
17:55:38 <DrChaos> makes sense
17:56:00 <DrChaos> it returns a single item of a list
17:56:40 <DrChaos> the simplest case follows from a list with only a single item in it
17:57:06 <catsbydlo> what happens for a single item?
17:57:15 <DrChaos> the result of that is simply the item in that list
17:57:29 <catsbydlo> hmm, ok. that's not the last-but-one, though
17:57:46 <DrChaos> alternatively, you could make it error out
17:58:36 <catsbydlo> lastButOne [] = error "lastButOne: empty list";  lastButOne (x : []) = x {- or: error "lastButOne: short list" -}
17:59:17 <DrChaos> so including that empty list pattern match does not change the type of my function?
17:59:39 <DrChaos> I mean, when that pattern match just throws an exception?
17:59:39 <catsbydlo> :t let foo [] = error "..." in foo
17:59:41 <lambdabot> [t1] -> t
17:59:52 <catsbydlo> :t []
17:59:54 <lambdabot> [a]
17:59:57 <catsbydlo> :t error
17:59:59 <lambdabot> [Char] -> a
18:00:01 <DrChaos> oh, nice
18:00:26 <catsbydlo> :t let foo [] = error "..." in foo :: [a] -> b
18:00:27 <lambdabot> [a] -> b
18:00:47 <catsbydlo> that equation alone just says 'foo' takes some kind of list and returns whatever you want (because it doesn't return)
18:01:14 <DrChaos> nice
18:01:52 <DrChaos> what I have chosen to do is: lastButOne (x:y:xs) = if null xs then x else lastButOne xs
18:02:28 <DrChaos> oh hell, it doesn't work for some reason
18:02:31 <catsbydlo> too complicated
18:02:46 <catsbydlo> what's the next simplest case? (after lists with 0 and 1 elements)
18:03:08 <DrChaos> lists with two elements
18:03:12 <catsbydlo> yep
18:03:19 <catsbydlo> lastButOne (x : y : []) = x
18:03:29 <catsbydlo> definitely correct
18:03:56 <catsbydlo> now that we've handled 0, 1, and 2 elements, all remaining lists must have at least 3 elements
18:04:12 <catsbydlo> in which case we can just shave off the first one and retry
18:04:20 <catsbydlo> lastButOne (x : xs) = lastButOne xs
18:05:42 <DrChaos> my function works perfectly now
18:14:42 <newsham> > lastButOne []
18:14:43 <lambdabot>   Not in scope: `lastButOne'
18:38:41 <Skillsob> What drew you guys to Haskell?
18:39:19 <Saizan> lisp
18:39:58 <Moggle> It was a functional language!
18:40:01 <Moggle> I had never used one before.
18:40:06 <Moggle> I enjoy bending my mind.
18:40:15 <Skillsob> I learnt a bit of Lisp before Haskell, but I'd consider Haskell my true introduction.
18:40:26 <popl> to Haskell?
18:40:36 <Skillsob> To FP.
18:40:39 <popl> ;)
18:40:58 <Skillsob> I find functional programming so much more fun for reasons I can't explain.
18:41:47 <Skillsob> If anyone said something like "I want to learn something that will make me a better programmer", I'd probably tell them to learn Haskell. It's quite an experience.
18:42:28 <popl> more fun than what?
18:42:47 <Nereid> than lisp, I imagine
18:42:51 <cmccann> Haskell is a great way to realize how much other languages are holding you back
18:42:55 <Skillsob> More fun than programming that isn't FP.
18:43:10 <Nereid> haskell is a great way to come to not want to program in other languages
18:43:22 <cmccann> lisp is pretty cool though. I should learn clojure one of these days.
18:43:52 <Skillsob> I really want algebraic datatypes in other languages. Enums are usually poorly implemented (C's unfortunate integer thing, Java's stupid verbosity, etc.)
18:44:24 <popl> The only programming language I feel OK bashing is PHP.
18:44:36 <Skillsob> After using Haskell's type system, every other type system just seems awful.
18:44:40 <Cale> Skillsob: Much less time spent in a debugger wondering what the fuck is going on is pretty nice. :)
18:44:58 <simpson> popl: What about C++?
18:45:12 <popl> simpson: I cut my teeth on C++.
18:45:44 <popl> well, when I got "serious" about programming.
18:45:46 <simpson> popl: You don't feel okay bashing it?
18:46:29 <lpvb> I feel comfortable bashing haskell
18:46:44 <popl> simpson: Bjarne Stroustrup looks like such a nice guy.
18:46:49 <Skillsob> lpvb: You feel comfortable saying nothing?
18:47:19 <catsbydlo> >fix bash
18:48:01 <lpvb> Skillsob: I feel comfortable saying that haskell is an unstable language that has its main compiler break a third or more of hackage with new releases and due to that, few business feel comfortable using it
18:48:48 <simpson> popl: I'm sure he is!
18:49:42 <Skillsob> lpvb: I didn't know about that. Sounds like it's kind of an issue. I would have thought that Simon PJ just fired eye-beams at his computer and the new version of GHC perfectly sprung into existence.
18:50:07 <popl> simpson: I had to write PHP to generate Excel spreadsheets.
18:50:29 <popl> It was more like Excel-flavored CSV. It was horrible.
18:50:29 <Skillsob> popl: Jesus Christ, how horrifying.
18:51:01 <popl> Maybe the trauma is why I feel OK talking trash.
18:51:15 <simpson> popl: Oh my.
18:51:29 <m3ga> i'm trying out tibbe's ekg library, but all the values in the ekg web ui are zero. anyone know why?
18:51:58 <popl> simpson: I will never, ever again read those words in a voice other than George Takei's.
18:52:00 <x-SuriV> simpson: I loves me some C__ :)
18:52:03 <lpvb> Skillsob: "avoid success at all costs"
18:52:07 <x-SuriV> C++*
18:52:08 <lpvb> see http://www.simple-talk.com/opinion/geek-of-the-week/simon-peyton-jones-geek-of-the-week/
18:54:20 <simpson> popl: That's how I always say them. :3
18:56:31 <lpvb> Skillsob: also the annoying endless array of compiler language extensions that are plastered everywhere
19:18:59 <latermuse> will GHC stagnate now that simon has moved on to other things?
19:19:47 <lpvb> I hope for it
19:20:01 <latermuse> lpvb: why?
19:20:30 <lpvb> because I'm fine with haskell the way it is and I don't want it breaking
19:20:41 <latermuse> :D
19:20:54 <popl> That's a horrible reason.
19:20:59 <lpvb> why
19:21:11 <lpvb> if you're a language researcher that's a horrible reason
19:21:19 <rwbarton> well uh
19:21:28 <rwbarton> for one thing you could just use ghc 7.4 forever
19:22:07 <lpvb> and how about libraries that use new features that you will be barred from using
19:22:21 <elliott> I thought you said you were fine with Haskell the way it is
19:22:28 <rwbarton> you don't need those libraries
19:22:47 <rwbarton> anyways this is obviously ridiculous
19:24:34 <monochrom> you could use hugs
19:24:41 <elliott> monochrom: please. gofer
19:24:55 <monochrom> but I like to promote hugs! :)
19:24:57 <Jafet> GOFER PLS
19:52:19 <idnar> @hoogle a -> a -> Bool -> a
19:52:20 <lambdabot> Data.Time.Calendar.MonthDay monthAndDayToDayOfYear :: Bool -> Int -> Int -> Int
19:52:20 <lambdabot> Graphics.Rendering.OpenGL.GL.VertexSpec TexCoord3 :: a -> a -> a -> TexCoord3 a
19:52:20 <lambdabot> Graphics.Rendering.OpenGL.GL.VertexSpec Normal3 :: a -> a -> a -> Normal3 a
19:52:29 <idnar> @hoogle Bool -> a -> a -> a
19:52:29 <lambdabot> Data.Time.Calendar.MonthDay monthAndDayToDayOfYear :: Bool -> Int -> Int -> Int
19:52:29 <lambdabot> Graphics.Rendering.OpenGL.GL.VertexSpec TexCoord3 :: a -> a -> a -> TexCoord3 a
19:52:29 <lambdabot> Graphics.Rendering.OpenGL.GL.VertexSpec Normal3 :: a -> a -> a -> Normal3 a
19:52:35 <idnar> meh
19:55:12 <idnar> @src if'
19:55:12 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
19:55:19 <elliott> idnar: gotta define it yourself
19:55:52 <idnar> looks like there are versions in general-prelude and Control.Conditional
19:56:25 <idnar> I thought there was something more "stock", but I guess not
19:59:55 <hrumph> hi
20:02:22 <hpaste> Hrumph pasted “Get error after trying example” at http://hpaste.org/79740
20:02:41 <hrumph> This example was taken from http://en.wikibooks.org/wiki/Haskell/Monad_transformers
20:03:44 <hrumph> I included the full text ot the error in a comment at the bottom of the code. The error starts with <interactive>:1:1: and continutes with No instance for (Show(MaybeT IO String)) on the next line
20:04:52 <hrumph> i just cut and paste the very first example of a monad transformer and it doesn't seem to work
20:04:59 <hrumph> either because i made a mistake or it doesn't work
20:14:47 <hrumph> it seems to work ok in ghc but not ok in ghci
20:17:21 <hrumph> haskell seems pretty brutal so far
20:17:50 <hrumph> soo as i got to these monad transformers and stuff it really started to get hairy
20:18:39 <strebe> monad transformers are frequently considered hairy
20:18:56 <hrumph> ok i think i know my mistake
20:19:43 <mikeplus64> hrumph: it works fine for me
20:19:46 <hrumph> yes
20:19:51 <hrumph> i had to call runmaybeT
20:19:52 <mikeplus64> that paste
20:20:49 <hrumph> ok here's the thing. i did main=runMaybeT askPassword
20:20:51 <hrumph> that compiled
20:20:56 <hrumph> and ran right
20:21:19 <hrumph> i loaded the program in ghci and i can call main ok
20:21:34 <hrumph> when i type runMaybeT askPassword
20:21:40 <hrumph> i get not in scope errors
20:22:14 <mikeplus64> that's probably your ghci only importing the main function
20:22:30 <hrumph> ues when i take the main function out its fine
20:22:36 <hrumph> just determined that
20:22:38 <mikeplus64> i don't know how to fix that, but it doesn't happen with ghc 7.6.1
20:23:40 <flebron> mikeplus64, tried deleting the .o and .hi before running the .hs in ghci?
20:24:29 <hrumph> just a few seconds ago i was trying to call askPassword directly and that wasn't going to go
20:24:36 <mikeplus64> flebron: i don't have any problems (hrumph does)
20:24:44 <flebron> ah ok
20:25:16 <hrumph> not that it should or shouldn't be callable directly i have no real clue
20:26:02 <hrumph> i don't understand why it can't be called direct to be frank
20:26:44 <mikeplus64> neither ... i guess that's why the behaviour has seemingly changed since your version of ghc to 7.6.1
20:27:20 <hrumph> i know that fedora 18 will have an upto date haskell
20:27:35 <hrumph> i wonder why its so many minor versions behind in 17
20:27:38 <popl> hrumph: Do you really understand monad transformers?
20:27:51 <hrumph> popl the blunt answer is no but i'm working at it
20:28:08 <hrumph> if i said yes i'd doubtless be opening myself up to tests that i would flunk
20:28:10 <popl> then is it possible there are other things you don't understand? :)
20:28:38 <rwbarton> are you still on http://hpaste.org/79740 ?
20:28:38 <strebe> hrumph: the differences between ghc and ghci can be a bit of a sharp edge at first
20:29:10 <rwbarton> that error message suggests you tried to just enter 'askPassword' at the ghci prompt
20:29:13 <rwbarton> which can't work
20:29:16 <hrumph> rwbarton: we'eve moved on
20:29:21 <rwbarton> ok
20:29:25 <rwbarton> well I don't see another paste :P
20:29:40 <popl> rwbarton: I ate it.
20:29:43 <hrumph> rwbarton: yes i did try that at first before wrapping it in runmaybeT
20:30:01 <hrumph> as i said i dind't see why i could call it direct
20:30:20 <hrumph> i don't mean wrapping i guess unwrapping is what i should have said
20:30:36 <hrumph> see don't quiz me at the moment please
20:30:52 <popl> hrumph: What's the capital of Michigan?
20:31:43 <mikeplus64> godspeed hrumph, godspeed
21:13:01 <beaky> hello
21:13:25 <beaky> how do I decide what should be a typeclass vs. what should simply be an ADT?
21:13:36 <ezyang> beaky: ADTs are closed
21:13:38 <beaky> ah
21:13:54 <ezyang> USually it's pretty clear. Do you have an example?
21:14:20 <beaky> I'm thinking of having all the creatures (the player character, monsters, NPCs, etc) be a typeclass
21:14:46 <ezyang> What operations does a creature support? That's what would go in your typeclass
21:14:49 <dmwit> Oh man, there's totally a wiki page about this exact question, down to NPCs and monsters.
21:14:53 <beaky> wow
21:14:54 <ezyang> lol
21:14:58 <flebron> is there a recommended explanation of the technique of "tying the knot"?
21:15:09 <ezyang> flebron: HaskellWiki has a page about it
21:15:34 <beaky> http://www.haskell.org/haskellwiki/FAQ#I.27m_making_an_RPG._Should_I_define_a_type_for_each_kind_of_monster.2C_and_a_type_class_for_them.3F
21:15:36 <dmwit> http://www.haskell.org/haskellwiki/FAQ#I.27m_making_an_RPG._Should_I_define_a_type_for_each_kind_of_monster.2C_and_a_type_class_for_them.3F
21:15:38 <flebron> saw that, my brain ReferenceError'd on "let (first,last) = go last xs first"
21:15:39 <dmwit> yes
21:15:40 <beaky> :D
21:15:59 <simpson> ezyang: I've been digging your FFI articles recently. Are those still up-to-date as far as best practices?
21:16:02 <beaky> ah
21:16:27 <ezyang> simpson: I don't think there have been any notable shifts in the FFI landscape
21:16:28 <zomg> Oh nice wiki article
21:16:45 <zomg> Do people really make that many RPGs in Haskell?
21:16:46 <zomg> :D
21:17:06 <ezyang> simpson: There is a kind of interesting library binding_DSL which I haven't used but might be a good idea.
21:17:10 <dmwit> People really *start* that many RPGs in Haskell, anyway.
21:17:15 <zomg> heh
21:17:30 <zomg> it's xmas, 7 AM and I haven't slept yet, and I was just writing some haskell article stuff I'm working on...
21:17:32 <sw2wolf{away}> dmwit: what's RPG ?
21:17:33 <zomg> I am such a nerd.
21:17:42 <flebron> How does "mkDList xs = let (first,last) = go last xs first            in  first" make sense?
21:17:47 <zomg> Rocket Propelled Grenade!
21:17:49 <beaky> I'm making a roguelike
21:18:01 <Ralith> I'm making a weapons system!
21:18:04 <beaky> but I'm still struggling with basic design :(
21:18:18 <Ralith> well I'd like to be
21:18:20 <simpson> ezyang: Yeah, I've had that recommended to me. It doesn't have quite enough documentation to make things obvious, but it does seem pretty nifty.
21:18:46 <zomg> beaky: yeah haskell app design is a bit tricky at first :)
21:18:53 <zomg> monaaaaaaaads
21:18:54 <zomg> =)
21:19:16 <ezyang> simpson: Anyway, if you find anything out of date, let me know and I'll update it.
21:19:36 <beaky> a few days ago I pasted a very basic design (nothing more than showing off the TUI library and basic player movements) and everyone said I should use lenses :D
21:19:48 <startling> is there a get-a-new-number-whenever-you-ask-for-one monad somewhere?
21:20:03 <flebron> random state?
21:20:07 <zomg> beaky: oh I bet you should be using all the cool thingamajigs, but you can do it without them too =)
21:20:07 <startling> it's just a StateT + one function, but.
21:20:10 <dmwit> sw2wolf{away}: role-playing game
21:20:21 <startling> flebron: nah, I want it to guarantee I won't get duplicates
21:20:22 <sw2wolf{away}> dmwit: thz
21:20:38 <zomg> I was writing about passing a database connection to some web app handlers
21:20:38 <dmwit> sw2wolf{away}: Well, that tells you what it stands for, anyway. It probably doesn't explain much about what it actually *is*, though.
21:20:38 <sw2wolf> dmwit: thx
21:20:49 <zomg> Obviously you would want a Reader monad for that
21:20:56 <zomg> but works without it too
21:21:00 <shachaf> ezyang: Hey, you like strange type class operations, right? Do you happen to know what (p a b -> p a (a,b)) and (p a b -> p (Either b a) b) are, for some profunctor p?
21:21:03 <dmwit> But think Final Fantas(ies), they're pretty canonical in that realm.
21:21:21 <popl> Final Fantas? I didn't hear about that one.
21:21:34 <dmwit> It was the greates.
21:21:48 <shachaf> (I also remember that you were asking about Applicative; I think the profunctor equivalent is Category.id + (Arrow.&&&) or so.
21:22:12 <ezyang> shachaf: No idea.
21:22:58 <beaky> so if something like Monster attributes and behavior shouldn't be a typeclass, what should be?
21:23:11 <startling> beaky, a data structure
21:23:15 <shachaf> Functor is a good type class.
21:23:19 <beaky> ah
21:23:25 <beaky> maybe monsters are functors? :D
21:23:44 <startling> beaky: data Monster = Monster { move :: State World () ... }
21:23:45 <zomg> A list of monsters would be a functor
21:23:50 <zomg> Not sure if the monster itself would be
21:23:54 <shachaf> Invariant and Contravariant and Anyvariant are good, too!
21:23:58 <startling> zomg: not really
21:24:08 <beaky> maybe monsters are monads! :D
21:24:10 <startling> list is a functor, a list of monsters isn't quite
21:24:32 <zomg> But if a list is a functor, why wouldn't a list of monsters be? ;)
21:24:46 <startling> zomg, *a* list isn't, list is
21:24:57 <zomg> Bah, semantics!
21:24:57 <ezyang> shachaf: They look kind of like arrow operations
21:24:58 <zomg> :D
21:25:07 <simpson> ezyang: Nah, I'm just a little wonked-out at the flexibility of this task.
21:25:07 <startling> newtype Monsters = Monsters [Monster] isn't a functor.
21:25:15 <beaky> so it's better to define an ADT over a typeclass when possible?
21:25:18 <shachaf> ezyang: Yep, they're related.
21:25:27 <simpson> ezyang: It's not like other languages, where you have to build a really clean FFI binding and then dress it up later.
21:25:34 <shachaf> ezyang: You can get the first one as (id &&&) and the second one as (||| id), or something along those lines.
21:25:43 <shachaf> ezyang: But these are much more restricted.
21:25:46 <ezyang> simpson: Well, you can just build a really clean FFI and dress it up later
21:26:04 <shachaf> ezyang: (The first one is what you need for profunctor lenses and the second one is what you need for profunctor prisms.)
21:26:21 <simpson> ezyang: Yep! That's what I'm doing.
21:26:55 <startling> zomg: would you rather just discuss syntax??
21:26:57 <ezyang> shachaf: My guess is that your formulation is not in the clearest possible form (similarly the difference between bind and join). Look for equivalent phrasings?
21:27:23 <shachaf> ezyang: This is clearer than the form we had it before.
21:27:24 <ezyang> ...oh, wait, this does look familiar
21:27:25 <ezyang> Just a sec.
21:27:48 <ezyang> Have you seen the recent POPL paper about lenses from UPenn?
21:27:49 <shachaf> ezyang: An earlier version of the first operation was (a -> b -> c) -> p a b -> p a c
21:28:40 <shachaf> ezyang: Nope.
21:30:18 <ezyang> shachaf: I *think* you want Edit Lenses
21:30:19 <elliott> didn't edwardk already tell you what they are :P
21:30:39 <shachaf> elliott: I'm not satisfied. :-(
21:30:49 <ezyang> slides: http://dmwit.com/papers/201107EL_slides.pdf
21:30:56 <elliott> strength/costrength is pretty clear
21:31:14 <shachaf> Oh, I have seen those slides.
21:31:15 <ezyang> keyword, "stateful monoid homomorphism"
21:31:19 <ezyang> ok
21:31:29 <shachaf> elliott: I have the feeling we're missing something.
21:31:30 <elliott> Prostrength Coprostrength Quidproquostrength
21:31:44 <shachaf> Mostly because lenses-as-corepresentable-profunctors work out so much more nicely.
21:31:58 <shachaf> And I want a direct formulation that's nice. :-(
21:32:07 <elliott> did you ever write each
21:32:15 <shachaf> Nope.
21:33:15 <shachaf> elliott: If Lenticular is really "generalizing upstar of a strong functor", you should be able to write frtw :: (forall f. Functor f => (a -> f b) -> s -> f t) -> (forall p. Lensy p => p a b -> p s t)
21:33:26 <shachaf> In a non-"grosse" way.
21:33:49 <shachaf> elliott: Did your plan to get sharing work?
21:33:54 <elliott> not really? the functor is built into p
21:33:54 <shachaf> I think that might be related to making this nice.
21:34:12 <elliott> i was going to write each firsr
21:34:13 <elliott> t
21:34:40 <shachaf> This shouldn't be so hard.
21:36:08 <flebron> i don't think coprostrength means what you think it means
21:38:17 <shachaf> elliott: So any ideas on each?
21:38:24 <shachaf> Is our problem related to the recursion somehow?
21:38:43 <beaky> how do you name functions?
21:38:48 <beaky> or data types?
21:43:47 <johnw> beaky: what do you mean?
21:43:50 <shachaf> elliott: Is there a way to get Twanny to work without an MPTC?
21:44:24 <beaky> I want to know the best names to give my functions
21:44:29 <beaky> and ADTs
21:44:40 <beaky> or even programs :D I haven't decided on a good name for my roguelike yet :(
21:44:45 <johnw> oh
21:45:05 <johnw> you mean, how do we pick a certain name
21:45:05 <johnw> how about "brigand"
21:45:08 <beaky> hehe
21:45:34 <beaky> brigand... that's a nice one that's probably not taken
21:45:40 <elliott> shachaf: I don't think there's a problem with each
21:46:09 <shachaf> elliott: We have the same operations, so it *ought* to be possible.
21:46:12 <beaky> what should I name my types though?
21:46:30 <elliott> beaky: T
21:46:34 <elliott> and put them all in their own modules
21:46:39 <shachaf> And call the modules M
21:46:42 <beaky> hehe
21:46:55 <popl> That's not funny.
21:47:05 <beaky> atm all my haskell programs are single-file
21:47:16 <popl> Name them all Malkovich.
21:47:29 <Nereid> btw
21:47:36 <Nereid> all your functions should be called f
21:47:39 <johnw`> Control.Beaky.ProgramOne
21:47:52 <beaky> I have lots of functions on data, so I don't know how to separate my file into modules :(
21:48:13 <Nereid> that's what mutually recursive modules are for.
21:48:33 <johnw> Nereid: how does that work?  I always get error about recursion inclusion
21:48:47 <Nereid> there's a trick
21:48:50 <Nereid> http://www.haskell.org/haskellwiki/Mutually_recursive_modules
21:48:52 <beaky> hehe
21:48:52 <shachaf> @google haskell mutually recursive modules
21:48:54 <lambdabot> http://www.haskell.org/haskellwiki/Mutually_recursive_modules
21:48:54 <lambdabot> Title: Mutually recursive modules - HaskellWiki
21:49:01 <beaky> in C++ I had that problem of recursive modules as well :(
21:49:07 <beaky> and in C
21:49:08 <johnw> to date I've been resolving it by having a common "Internel" module
21:49:12 <johnw> but i have to read up on this trick
21:49:32 <beaky> at least haskell has a proper module system :D unlike C and C++
21:50:01 <elliott> btw the hs-boot files are awful
21:50:04 <elliott> I wouldn't recommend it to anyone
21:50:08 <Nereid> :P
21:50:36 <johnw> Nereid: that web page doesn't tell you how to actually do it
21:50:52 <johnw> what is an *.hs-boot file?
21:50:55 <elliott> ghc manual has docs on hs-boot
21:50:56 <Nereid> sure, but it has a link to the ghc docs which do tell you
21:50:57 <johnw> oh, there's a link
21:51:01 <johnw> following...
21:51:54 <johnw> hm... i think my aesthetic senses cannot handle this solution
21:52:50 <Nereid> of course not
21:54:34 <beaky> what are alternatives to Maybe?
21:54:38 <beaky> Either?
21:54:46 <johnw> what do you mean by "alternative"?
21:54:54 <johnw> you mean, for alerting the caller to an error?
21:54:58 <beaky> yes
21:55:03 <johnw> Either is good
21:55:09 <johnw> there is also the Attempt module
21:55:09 <beaky> for non-exhaustive patterns :D
21:55:22 <johnw> non-exhaustive patterns will cause an exception
21:55:29 <beaky> which is bad :(
21:55:37 <johnw> to use Attempt you simply return: failure "foo"
21:55:49 <johnw> and the caller decides what kind of error reporting they want based on how they call the function
21:56:25 <johnw> that is, if you do failure "foo", and they call your function in a context requiring a Maybe, they will get Nothing.  If they call it in a context require an Either String a, they will get a Left "foo".  If they call it in the IO monad, they will get an exception, etc.
21:57:17 <beaky> ah
21:57:21 <beaky> it's like more general
21:57:34 <johnw> it leaves some of the details to the context
21:57:44 <johnw> which can be good, or it can be bad
21:57:52 <dmwit> non-exhaustive patterns do not invariable cause exceptions
21:57:53 <johnw> it can be bad in that type inference errors will be harder to understand
21:58:02 <johnw> dmwit: no?
21:58:03 <dmwit> > do { 3 <- Just 0; return () }
21:58:04 <lambdabot>   Nothing
21:58:10 <johnw> oh yeah
21:58:13 <johnw> it calls "fail"
21:58:18 <johnw> i forgot about the monad case
21:58:22 <johnw> (do-notation sugar)
21:58:40 <beaky> I like do notation
22:01:54 <popl> I do like notation.
22:02:24 <Nereid> dmwit: that's secretly not a non-exhaustive pattern though?
22:02:28 <Nereid> @undo do { 3 <- Just 0; return () }
22:02:28 <lambdabot> Just 0 >>= \ a -> case a of { 3 -> return (); _ -> fail ""}
22:06:50 <bzm3r> If there multiple ways to reduce an expression, does the compiler choose the most efficient way to do so (like, the least number of steps)?
22:07:06 <shachaf> Not really.
22:07:15 <shachaf> That's kind of a hard problem. :-)
22:07:15 <bzm3r> I see.
22:07:24 <bzm3r> Yeah, I was trying to figure it out for myself
22:07:48 <bzm3r> if I could set up a notation or something that would let me easily determine how many different ways of reducing an expression there are
22:07:55 <bzm3r> and I didn't really get anywhere.
22:08:06 <bzm3r> Why is it a hard problem though/
22:09:17 <bzm3r> Is it because there is no way of knowing the least expensive way without knowing all the possible ways?
22:10:03 <Nereid> sounds like the halting problem.
22:10:30 <bzm3r> hmm
22:14:30 <johnw> bzm3r: http://en.wikipedia.org/wiki/Full_employment_theorem
22:15:04 <johnw> there might always be a more optimal solution
22:22:33 <Enigmagic> johnw: did you get your thing fixed this morning? i had to run
22:22:55 <johnw> no, I tried several more tricks today but still the identical result
22:23:33 <johnw> https://github.com/jwiegley/sizes/blob/master/Main.hs#L191
22:23:40 <johnw> as a result of all this, the gatherSizes function keeps getting simpler
22:24:37 <johnw> but I still want to understand what the stack actually looks like
22:24:49 <johnw> gdb doesn't give me a trace, and -xc's trace is not very illuminating
22:25:09 <Enigmagic> johnw: link with -debug and set a breakpoint on stg_raisezh or stackOverflowHelper (i think)
22:25:14 <johnw> ok
22:25:23 <Enigmagic> stg_raisezh will get all exceptions though
22:27:11 <Enigmagic> johnw: so once you get the exception, if you're running the single threaded rts (aka: don't link -threaded) you can dump out MainCapability to get the TSO, which you can dump out directly (the stack pointers are in there with a little digging) or use printTSO/printStack
22:27:55 <johnw> let me disable threading
22:28:04 <beaky> besides making a roguelike, what are some other good ways to learn haskell?
22:28:14 <johnw> make a second roguelike
22:28:17 <beaky> hehe
22:28:30 <johnw> it's the same as for any language
22:28:36 <johnw> solve a problem whose solution you want to use
22:28:53 <Enigmagic> johnw: you don't *need* to do it but i'd recommend avoiding the threaded runtime for a while when debugging in gdb
22:29:03 <johnw> ok
22:29:09 <bzm3r> johnw: thanks for the link!
22:29:34 <johnw> bzm3r: sure thing
22:31:44 <johnw> Enigmagic: p (void)printTSO(MainCapability->..?)
22:32:01 <johnw> r.rCurrentTSO seems ilke
22:32:15 <johnw> yes, that works
22:32:28 <johnw> the output is not very large
22:35:09 <Enigmagic> johnw: i don't think it walks all the chunks
22:35:23 <Enigmagic> usually the top portion should have the repeating parts you want to look at anyways
22:35:24 <johnw> how do I use printStack?  There's printStackChunk, printStackObj
22:35:39 <johnw> the "top" is this:
22:35:40 <johnw> RET_SMALL (0x100715b60)
22:35:40 <johnw>    stk[129] (0x10775fbf8) = 0x10120d000
22:35:49 <johnw> then I see a bunch of CATCH_FRAMEs
22:35:54 <johnw> and then an UNDERFLOW_FRAME
22:37:04 <Enigmagic> johnw: try setting it on StackOverflowHook not stg_raisezh
22:37:12 <Enigmagic> you're probably getting an earlier exception
22:39:07 <johnw> ok, after doing that, then p (void)printTSO(MainCapability.r.rCurrentTSO) crashes with an attempt to dereference a NULL
22:39:25 <Enigmagic> heh ok
22:39:36 <Enigmagic> (thats why i use debugger scripts instead of functions)
22:40:10 <sopvop> Ghc is awesome. Reading core and finding just how well it optimizes things I thought it's not going to optimize. Magic.
22:40:29 <Enigmagic> johnw: once you're in there just use regular gdb commands like 'x/1000a' to dump the stack out
22:41:00 <johnw> Enigmagic: but what will reading a hex dump tell me?
22:41:36 <johnw> oh, I see
22:41:48 <Enigmagic> johnw: addresses for objects on the stack. printObj(obj) will pretty print each one if you want to look at it.
22:42:12 <johnw> https://gist.github.com/4368098
22:42:45 <johnw> which address do I pass to printObj?
22:42:54 <johnw> the one I tried died with a null pointer access inside printClosure
22:43:29 <Enigmagic> johnw: on the top line you want to print out 0x1072fdd58 (not 0x...9)
22:43:54 <johnw> subtract 1 from any addr?
22:44:06 <Enigmagic> no, mask off the stg tag bits
22:44:12 <Enigmagic> low 3 bits on x86_64
22:44:20 <johnw> aha
22:44:25 <johnw> most of these are my EntryInfo values
22:44:52 <johnw> because every monadic bind is passing one as a value, I bet
22:45:56 <Enigmagic> well now you know what's on the stack
22:46:03 <johnw> but why is it on the stack?
22:46:19 <johnw> i would have expected the tuple to be on the stack, but the EntryInfo and [EntryInfo] inside it to be on the heap?
22:46:57 <Enigmagic> johnw: the tuple is on the heap too
22:47:12 <johnw>  why is there an EntryInfo on the stack?
22:51:50 <johnw> Enigmagic: are these tricks recorded anywhere?
22:52:19 <Enigmagic> johnw: no i haven't written them down
22:53:00 <shachaf> We should make a Twitter account with quotes from Enigmagic in IRC.
22:53:09 <bzm3r> hahaha
22:53:20 <shachaf> I keep seeing him say all these useful things at times when I'm not in a position to use them.
22:53:35 <bzm3r> i love hoarding
22:53:45 <bzm3r> you never know when something comes in handy
22:53:49 * hackagebot HSGEP 0.1.5 - Gene Expression Programming evolutionary algorithm in Haskell  http://hackage.haskell.org/package/HSGEP-0.1.5 (MatthewSottile)
22:55:01 <bradleyayers> hi
22:55:21 <beaky> does haskell have OOP features?
22:55:48 <beaky> or is 'data' just a bag of data?
22:56:04 <johnw> which OOP feature are you particularly fond of?
22:56:14 <beaky> polymorphism
22:56:44 <Raynes> Yes.
22:56:49 <Raynes> Typeclasses and whatnot.
22:56:52 <Heffalump> do you mean generics, or virtual methods, or something else?
22:56:54 <beaky> ah
22:56:58 <beaky> virtual methods
22:57:06 <beaky> I think haskell has that
22:57:17 <beaky> as typeclasses
22:57:20 <otters> yeah
22:57:25 <popl> TSO?
22:57:26 <Heffalump> yes, though there's less emphasis on the dynamic dispatch aspects
22:58:17 <popl> oh, thread state object
22:59:25 <beaky> :t uncurry
22:59:27 <lambdabot> (a -> b -> c) -> (a, b) -> c
22:59:53 <beaky> :t uncurry 0 0
22:59:55 <lambdabot> (Num (a, b), Num (a -> b -> c)) => c
23:00:03 <beaky> is that the way to turn a tuple into a pair of arguments?
23:00:12 <Enigmagic> johnw: good question, i'd guess it's from line 197
23:00:20 <Skillsob> beaky, curry
23:00:24 <Skillsob> :t curry
23:00:24 <beaky> oh right
23:00:26 <lambdabot> ((a, b) -> c) -> a -> b -> c
23:00:38 <Nereid> beaky: you also need to give a function
23:00:45 <Skillsob> lambdabot is a champ.
23:00:54 <Nereid> > uncurry (+) (2,3)
23:00:56 <lambdabot>   5
23:00:57 <popl> Skillsob: of what?
23:01:00 <beaky> > curry (\(a,b) -> a + b) 3 1
23:01:02 <lambdabot>   4
23:01:05 <beaky> :D
23:01:07 <Nereid> > curry id 1 2
23:01:09 <lambdabot>   (1,2)
23:01:20 <Skillsob> :t (curry id)
23:01:22 <lambdabot> a -> b -> (a, b)
23:01:29 <beaky> curry id :D
23:01:39 <beaky> curry is a very neat name
23:01:46 <Nereid> :t (((,) .) .)
23:01:47 <lambdabot> (Functor f1, Functor f) => f (f1 a) -> f (f1 (b -> (a, b)))
23:01:50 <Nereid> oops
23:01:53 <popl> beaky: It's a proper name.
23:01:56 <Skillsob> :t (.).(.)
23:01:57 <lambdabot> (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
23:02:03 <Enigmagic> johnw: really i'd recommend using a strict tuple if you're going to use tuples, lists and recursion together
23:02:09 <popl> The only curry I like is Curry.
23:02:15 <Skillsob> :t fmap . fmap
23:02:16 <lambdabot> (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
23:02:18 <popl> well and curry
23:02:21 <popl> but I hate curry.
23:02:32 <johnw> Enigmagic: you mean like return $! (.., ..)?
23:03:31 <Nereid> :t (. (,)) . (.)
23:03:32 <Enigmagic> johnw: no, the contents of the tuple are still lazy. with a fold you'd use bang patterns like \ (!x, !y). return $! (x, y) just evaluates the tuple
23:03:32 <lambdabot> ((a, b) -> b1) -> a -> b -> b1
23:03:39 <Nereid> curry is made of punctuation.
23:05:10 <Enigmagic> johnw: you can also move the if/then/else outside of the return. that way the if statement is always evaluated before return, rather than by creating a thunk within the tuple
23:10:24 <fragamus> Quick one: is there a function that will take a function and return a type string for it
23:10:50 <Enigmagic> > typeOf (undefined :: Int -> Int)
23:10:51 <lambdabot>   Int -> Int
23:10:54 <fragamus> A string containing a type sig
23:11:31 <lolcathost> fragamus: What do you mean by "a type string"?
23:12:28 <Nereid> fragamus: typeOf will do it if it is a monomorphic value of a Typeable instance. but more likely you are really wanting to do something else.
23:12:35 <bzm3r> Imagine a language of finite sequences of 0s and 1s. The rules for simplifying strings in this language are given as 1) 1??x => x1101 and 2) 0??x => x00, where x is any arbitrary sequence of 0s and 1s, and ? is a single 0 or 1. What would the string 10 reduce to in this language?
23:12:38 <Nereid> :t show . typeOf
23:12:39 <lambdabot> Typeable a => a -> String
23:12:58 <lolcathost> @instances Typeable
23:12:59 <lambdabot> Couldn't find class `Typeable'. Try @instances-importing
23:13:07 <popl> bzm3r: homework?
23:13:15 <bzm3r> No, just self-reading.
23:13:27 <Nereid> it wouldn't reduce at all.
23:13:29 * popl ponders other-reading
23:13:31 <bzm3r> An exercise in the book, and...is 10 even well formed?
23:13:32 <lolcathost> Is there an instance of Typeable for (Typeable a, Typeable b) => a -> b ?
23:13:40 <Nereid> there is.
23:13:51 <popl> bzm3r: What book?
23:13:52 <fragamus> That's what I needed
23:14:04 <bzm3r> popl: Bird's "Introduction to Functional Programming"
23:14:11 <popl> Thanks
23:14:15 <bzm3r> no problem
23:14:32 <bzm3r> Nereid: it's already in canonical form?
23:14:32 <shachaf> > typeOf chr
23:14:34 <lambdabot>   Int -> Char
23:14:41 <Nereid> bzm3r: there are no reduction rules that apply.
23:14:43 <bzm3r> right
23:14:57 <popl> no, no left
23:15:10 <bzm3r> Nereid: right, that was blindingly simple, actually
23:15:14 <bzm3r> thank you
23:16:03 <fragamus> Thank you
23:16:36 <popl> No, thank you.
23:18:12 <beaky> what's a good design pattern for modelling states
23:18:47 <beaky> e.g. a monster in my game can be asleep, hungry, and poisoned at the same time
23:19:01 <beaky> but he can't be asleep and dead, for example
23:19:23 <beaky> sounds like logic programming
23:19:46 <Heffalump> beaky: just make a datatype that can express the possible states. E.g. a record of Bools
23:19:53 <beaky> ah
23:19:57 <beaky> that's easy :D
23:20:15 <Heffalump> or if you want to be more explicit, make a datatype for each state (data Sleep = Asleep | Awake)
23:20:33 <lolcathost> beaky: data Status1 = Asleep | Hungry | Poisoned     data Status2 = Alive [Status1] | Dead
23:20:52 <Nereid> [Status1] may not be the most appropriate though.
23:20:58 <beaky> maybe lenses might help :D
23:21:30 <slehuito> Hi there,
23:21:30 <slehuito> I'm looking for a video of a SPJ's presentation about... you guessed it: Haskell! ;-)
23:21:33 <lolcathost> Nereid: Oh, true... One may accidentally insert the same status twice.
23:21:37 <slehuito> I'm not really sure the precise topic, but he presented a program dealing with neighbours of distance 1 and 2 in a graph, using sets and set difference.
23:21:38 <slehuito> He also mentioned that the Haskell version was *faster* than a C version, presumably because of the use of immutable sets.
23:21:38 <slehuito> Does that ring a bell to anyone?
23:21:57 <beaky> hmm... sets
23:22:30 <beaky> sets is a nice word
23:22:47 <beaky> immutable sets?
23:23:08 <popl> sets that are immutable
23:23:29 <beaky> what's good about immutable sets?
23:23:44 <Nereid> they're not mutable
23:23:48 <slehuito> the lack of immutable sets in C was alledged to cost a lot of extra copies, thus yeilding a defavorable computing time...
23:23:49 <bzm3r> Alright, another stupid question Nereid. What would the evaluator simplify 0000 (four zeroes) in that language to, given that 0??x =>x00? A reduction rule applies, but it would not reduce anything, so I can assume the evaluator would stop when it notices it got just what it started with?
23:24:06 <Nereid> bzm3r: surely 0000 matches 0??x
23:24:14 <Nereid> with x = 0
23:24:27 <Nereid> so it reduces to 000
23:24:29 <bzm3r> Nereid: make that five zeroes, sorry.
23:24:35 <bzm3r> Ahh, wait.
23:24:36 <Nereid> ok, then 00000 -> 0000
23:24:41 <bzm3r> That would give you 4 zeroes back.
23:24:42 <bzm3r> yeah.
23:25:00 <Nereid> and it would reduce further.
23:25:07 <Heffalump> bzm3r: is the evaluator supposed to be applied until it stops? Normally you'd expect that.
23:25:39 <popl> http://www.amazon.com/gp/offer-listing/0134841972/ref=tmm_pap_new_olp_sr/179-3504723-6821560?ie=UTF8&condition=new # $365.70
23:25:47 <popl> :/
23:26:14 <popl> Someone is high.
23:26:53 <Nereid> also 000 matches 0??x, where x is empty. presumably.
23:27:04 <bzm3r> Yes.
23:27:10 <bzm3r> I was applying the rule incorrectly
23:27:30 <bzm3r> and so kept on getting the same thing back (I was doing 0?x => x00)
23:27:44 <bzm3r> I am pretty foolish
23:27:45 <bzm3r> oh well
23:28:01 <popl> bzm3r: It happens.
23:28:10 <popl> Don't be too hard on yourself.
23:29:14 <system64> Just getting started with haskell, not able to getghc interactive running. Install it via brew on OSX.
23:29:23 <bzm3r> lol popl
23:29:41 <popl> system64: who is?
23:30:56 <bzm3r> johnw: way back in November or early December, I asked you about how to get ghci to pretty print, kind of like in LYAH -- I found an answer: http://www.reddit.com/r/haskell/comments/144biy/pretty_output_in_ghci_howto_in_comments/
23:31:04 <bzm3r> not sure if you have seen it already, but in case you haven't
23:31:39 <Nereid> cool.
23:31:56 <system64> @popl sorry, didn't get you.
23:31:57 <lambdabot> Maybe you meant: pl unpl
23:32:09 <bzm3r> http://i.imgur.com/t6hOx.png is what it looks like, only the output is in pretty print though, unlike how even the input in LYAH is in pretty print
23:33:04 <Nereid> well highlighting input is going to be hard. :p
23:33:26 <bzm3r> haha, yeah...
23:33:43 <bzm3r> that means someone put in a lot of formatting effort into LYAH
23:33:46 <Nereid> does it still work with incremental output?
23:33:49 * hackagebot mathgenealogy 1.1.0 - Discover your (academic) ancestors!  http://hackage.haskell.org/package/mathgenealogy-1.1.0 (PeterRobinson)
23:34:08 <bzm3r> hrmm, i am not sure about that, Nereid
23:34:10 <popl> I'm using that bzm3r
23:34:26 <bzm3r> I mean, I didn't figure out how to do it, I just found that post :p
23:35:21 <popl> I had to :set -XNoMonomorphismRestriction
23:35:23 <system64> popl: I'm getting this message "The build-tool has reset ENV. --lame-env required." when I run ghci
23:35:41 <popl> :O
23:35:50 <Nereid> that's a bad workaround, better to add a type sig.
23:36:00 <popl> Nereid: I know.
23:36:00 <Nereid> although I turn off the MR in ghci anyway.
23:36:12 <popl> Nereid: I am laaaaaazy.
23:36:16 <popl> lazier than Haskell
23:36:17 <bzm3r> lol
23:36:36 <Nereid> yeah, incremental output doesn't work.
23:36:40 <Nereid> > [1..]
23:36:42 <Nereid> *no output*
23:37:08 <popl> I get output
23:37:26 <popl> It's not pretty though. :/
23:37:36 <popl> That's strange.
23:37:49 <bzm3r> Nereid: what is incremental output exactly?
23:38:05 <Nereid> bzm3r: shows output as it is computed.
23:38:13 <bzm3r> example?
23:38:20 <Nereid> instead of forcing the whole string
23:38:23 <Nereid> [1..]
23:38:32 <Nereid> it obviously doesn't evaluate the whole infinite string before showing it.
23:38:35 <bzm3r> ahh
23:38:51 * hackagebot yesod 1.1.7.1 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-1.1.7.1 (MichaelSnoyman)
23:43:34 <Nereid> also it doesn't work after :load
23:43:39 <Nereid> how sad
23:44:29 <bzm3r> yeah, the guy who came up with it noted that: Edit: It turns out that this gets disabled once you load a new module into GHCi. I'm looking for a workaround. So far, I have found a way to preserve it when you use :load (redefine :load to set everything back up), but if you pass the file as a command line argument then you still lose it. Edit 2: You will need to either :seti -XNoMonomorphismRestriction or give myPrint an explicit type a
23:45:05 <Nereid> I'm happy enough with my coloured prompt.
23:48:50 * hackagebot persistent 1.1.2 - Type-safe, multi-backend data serialization.  http://hackage.haskell.org/package/persistent-1.1.2 (MichaelSnoyman)
23:48:52 * hackagebot persistent-mongoDB 1.1.2 - Backend for the persistent library using mongoDB.  http://hackage.haskell.org/package/persistent-mongoDB-1.1.2 (MichaelSnoyman)
23:48:54 * hackagebot persistent-mysql 1.1.2 - Backend for the persistent library using MySQL database server.  http://hackage.haskell.org/package/persistent-mysql-1.1.2 (MichaelSnoyman)
23:48:56 * hackagebot persistent-postgresql 1.1.2 - Backend for the persistent library using postgresql.  http://hackage.haskell.org/package/persistent-postgresql-1.1.2 (MichaelSnoyman)
23:53:58 * hackagebot persistent-sqlite 1.1.2 - Backend for the persistent library using sqlite3.  http://hackage.haskell.org/package/persistent-sqlite-1.1.2 (MichaelSnoyman)
23:54:00 * hackagebot persistent-template 1.1.2 - Type-safe, non-relational, multi-backend persistence.  http://hackage.haskell.org/package/persistent-template-1.1.2 (MichaelSnoyman)
23:55:14 <system64> Can't get ghci running. Installed ghc via brew.
