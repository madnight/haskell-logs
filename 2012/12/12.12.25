00:24:39 <edeloa> I'm trying to install darcs via cabal, but it requires base < 4.4.  GHC (or cabal) require a newer version of base.  I'm not sure how to get around this issue
00:34:26 * hackagebot shelly 0.15.3.3 - shell-like (systems) programming in Haskell  http://hackage.haskell.org/package/shelly-0.15.3.3 (GregWeber)
00:53:09 <fmap> edeloa: 4.4?
00:59:18 <startling> does anyone have a good name for a monad transformer that lets me assign each k to a that I see to some (unique) v?
01:00:27 <startling> I guess, more generally, it allows you to query for a unique v of some type.
01:05:05 <startling> anyone know of anything like this? it's useful for e.g. pseudo-pointer-equality for graph nodes
01:14:55 <startling> man, I wish there were a Enum-ish type with succ :: a -> Maybe a
01:32:36 <Ralith> startling: isn't that just a trivial StateT Integer?
01:32:53 <startling> Ralith: sure, but it's useful to rename it so I can use it to modify another StateT
01:33:12 <startling> so as to not get ambiguity out of 'get' and 'put'
01:33:17 <Ralith> ah
01:34:29 <fmap> startling: Supply monad with infinite list of Ints?
01:34:49 <startling> fmap: an infinite list of unique Ints? do tell
01:35:28 <startling> Supply does look promising, though, thanks
01:35:29 <fmap> startling: well, for some value of 'infinite' I guess
01:36:00 <Ralith> iterate succ 0 :: [Integer]
01:36:33 <shachaf> startling: spoon to the rescue!
01:37:08 <startling> Ralith: that would work, but I feel like [minBound..maxBound] :: [Int] is more useful
01:37:18 <startling> well, less overhead, not likely to overflow anyway
01:37:37 <Ralith> I wouldn't assume that the overhead matters
01:37:46 <Ralith> in fact, I would assume it does not
01:38:04 <shachaf> @ty teaspoon
01:38:04 <Ralith> and thus choose the option that keeps things sanely total
01:38:06 <lambdabot> Not in scope: `teaspoon'
01:38:07 <shachaf> Aw.
01:38:23 <startling> Ralith: yeah, good point.
01:40:41 <startling> shachaf: what's it do?
01:41:13 <shachaf> startling: teaspoon :: a -> Maybe a
01:41:27 <shachaf> teaspoon ⊥ = Nothing; teaspoon x = Just x
01:41:45 <startling> uh.
01:42:22 <shachaf> startling: (It uses unsafePerformIO and catches exceptions. It doesn't really work for any ⊥.)
01:42:23 <startling> shachaf: isn't that solving the halting problem
01:42:25 <startling> oh
01:42:38 <Ralith> shachaf: that is just silly
01:42:57 <startling> I can see the use; it's more silly that it needs to exist.
01:43:17 <startling> teaspoon . head would be useful.
01:43:51 <johnw> but quite a bit less efficient than using safeHead, right?
01:43:51 <Ralith> not very, since you can trivially implement that sanely
01:44:10 <startling> johnw: I dunno
01:44:18 <Ralith> I imagine it would take a very badly written lib indeed to render it really necessary.
01:44:21 <startling> Ralith: sure, but.
01:44:29 <johnw> startling: every failure catches an exception
01:45:56 <startling> johnw, I have no idea about the performance characteristics of exceptions. Is catching them expensive?
01:46:16 <johnw> in c++ it is, i don't know about GHC
02:17:12 <neutrino> edwardk: hey, you around? :)
02:18:36 <neutrino> startling: it's more expensive in STM, i don't know about generally. however, haskell isn't made for exceptions-as-flow-control, so i'd say they don't optimize for having loads of them. that was the general feel presented in the stm paper. other languages live and breathe exceptions and are optimized for them.
02:19:32 <startling> neutrino: so what you're saying is "I don't know"
02:20:17 <neutrino> i don't know for sure but i think there's a reasonable impact.
02:20:38 <neutrino> so don't use exceptions, unless they're for implementing exceptions
02:20:41 <startling> okay.
02:29:46 <Saizan> exceptions could well be less expensive than long Maybe's >>= chains, especially if not right-associated
02:31:18 <`nand`> benchmark
02:48:04 <davorak> I am trying to get distributed-process, formally "cloud haskell" to work from my local machine to my server on amazons cloud. I have my simple ping-pong application working locally on either my machine or amazons.  But I can not get the two to talk. The aws security group is set to open the right ports and ufw is set to allow the correct port as well.  What am I missing, are their any other ports that need to open to establish a 
02:49:49 * hackagebot aws-sdk 0.7.1.0 - AWS SDK for Haskell  http://hackage.haskell.org/package/aws-sdk-0.7.1.0 (YusukeNomura)
02:49:57 <`nand`> davorak: that got cut after ‘establish’
02:51:01 <Bynbo7> davorak: using something like wireshark might be a good way to help diagnose the problem
02:53:01 <davorak> `nand`: you did not miss much the rest was  a connection?
02:53:27 <k0ral> is it right to write: instance (MonadIO m, MonadReader (IORef s) m) => MonadState s m
02:54:29 <`nand`> davorak: as for your question; I don't know anything about cloud haskell but a simple test you could perform is seeing if ‘netcat’ on the associated ports works, in both directions
02:54:29 <davorak> Synbo7: I know how to use tcpdump enought that I can do some testing, but I thought I would ask if it was a common stumbling block since I have spent the last 20 minutes playing around with firewall rules to no avail.
02:56:07 <neutrino> davorak: try telneting into that port..
02:56:08 <davorak> `nand`: I will give it a try, have not used that to diagnose problems before but it looks stright forward.
02:57:44 <`nand`> davorak: what backend are you using?
02:58:22 <davorak> `nand`: the tcp form network.transport.tcp
02:58:37 <DrCode> hi all
02:59:32 <DrCode> hi all
02:59:38 <DrCode> MXms
03:01:46 <`nand`> davorak: I'm not sure what you mean. ‘distributed-process’ claims “You will probably also want to install a Cloud Haskell backend such as distributed-process-simplelocalnet” <- are you using no such backend?
03:02:12 <davorak> `nand`: Yep netcat works great over the ports in question, thanks for the quick test to see if it was a firewall issue on those ports at least.  I will look around the function calls and see if any other ports are in use
03:02:23 <oddthingy> beginner Q. How can I define a new function using the interactive interpreter? Tried lucky::(Integral a)=> a-> String     it gives error 'Not in scope lucky'
03:02:35 <shachaf> oddthingy: let foo x = bar
03:02:36 <neutrino> let foo x = 2
03:02:36 <ciaranm> oddthingy: let
03:02:47 <neutrino> first
03:02:57 <shachaf> oddthingy: Or let foo :: Maybe Int -> Int; foo Nothing = 0; foo (Just x) = x
03:03:03 <edwardk> neutrino: of course
03:03:44 <neutrino> edwardk: is that to say you are always there? :)
03:03:59 <davorak> `nand`: Yes that is the backend I am using.  The local part seemed to be for the udp autodetect of the slaves, though I did not do any deep digging to see if there wree more limitations.
03:04:33 <oddthingy> Thx. But got error 'not an expression' when I tried 'let foo x = 2'
03:04:35 <`nand`> simplelocalnet will not work unless your hosts are all in the same broadcast domain
03:04:35 <davorak> `nand`: Since I was just hard coding the nid I thought I could get it to work.
03:04:40 <neutrino> edwardk: `nand` helped me figure out how to use reflection in a clean way, i was wondering if you could have a look at it. we were wondering why oleg didn't show this approach in his paper.
03:04:42 <`nand`> no?
03:05:06 <`nand`> edwardk: that is to say, we're both pretty much stumbling around in the dark here
03:05:18 <edwardk> neutrino: pretty much
03:05:22 <neutrino> oddthingy: are you sure that's what you typed?
03:05:29 <k0ral> anyone cares to answer me ? :)
03:05:35 <oddthingy> I'm using the 'try haskell' online interpreter. sample code on defining functions from websites, forums doesn't seem to be working.
03:05:38 <neutrino> oddthingy: show us a screenshot or something
03:05:40 <`nand`> oddthingy: tryhaskell isn't GHCi
03:05:43 <neutrino> oh
03:05:47 <neutrino> yeah, it's not
03:05:57 <davorak> `nand`: Thanks I thought that the restriction was only for the autodect feature.
03:05:59 <edwardk> sure
03:06:00 <`nand`> I don't think you can define functions in tryhaskell, can you?
03:06:10 <oddthingy> thanks, that explains it
03:06:17 <`nand`> davorak: oh, you may be right
03:06:19 <neutrino> um
03:06:47 <neutrino> oddthingy: you can do let (function_definition) in (code_that_uses_that_function)
03:07:25 <hpaste> LAMMJohnson pasted “SDL Audio Testing” at http://hpaste.org/79793
03:07:39 <LAMMJohnson> Season's greetings, all.
03:07:42 <neutrino> edwardk: basically, the idea was to carry around the proxy variable in a reader. but then `nand` decided to write his own monad so that reader gets freed up.
03:07:46 <oddthingy> neutrino: ah. that worked.
03:08:12 <neutrino> edwardk: check out the code here: http://hpaste.org/79757#a79770 -- the block called ReifyT
03:08:13 <edwardk> neutrino: you can use 'Tagged' from tagged
03:08:14 <`nand`> might as well just look at the hpaste
03:08:20 <LAMMJohnson> I'm having terrible problems with SDL.Mixer underruns. Does anybody have experience with it?
03:08:29 <neutrino> `nand`: i was typing :)
03:08:33 <edwardk> ReifiyT doesn't need to carry the Proxy
03:08:39 <edwardk> just the 's' in the phantom type parameter
03:08:39 <neutrino> edwardk: how would i use Tagged?
03:08:57 <neutrino> edwardk: right, it carries the s
03:08:57 <edwardk> newtype ReifyT s m a = ReifyT { runReifyT :: m a }
03:09:10 <edwardk> that gets you vastly better sharing
03:09:18 <`nand`> oh, of course
03:09:38 <neutrino> what's "sharing"?
03:09:39 <edwardk> Tagged is like your 'Reify'
03:09:41 <`nand`> that'd be the same as the ‘With s a’ in http://hpaste.org/79765 but as a transformer
03:09:48 <edwardk> sure
03:10:12 <edwardk> yeah With is just rediscovering Tagged
03:10:26 <edwardk> if you want to get fancy, there is a package I have called representable-profunctors
03:10:33 <neutrino> `nand`: huh, when did you make the "with" version? :)
03:10:36 <shachaf> hi
03:10:37 <edwardk> in there the 'representation' of Tagged s is Proxy s
03:10:43 <`nand`> neutrino: it's in the history you linked
03:10:58 <neutrino> damn. i must've been real sleepy then
03:11:03 <edwardk> so you can tabulatePro :: (Proxy s -> a) -> Tagged s a      and indexPro :: Tagged s a -> Proxy s -> a     ;)
03:11:18 <shachaf> That corresponds to using (Proxy a -> f b) -> Proxy s -> f t instead of Tagged a (f b) -> Tagged s (f t)
03:11:30 <edwardk> in a much more mundane way the fromProxy and toProxy functions are in Data.Tagged )
03:11:31 <edwardk> ;)
03:11:46 <neutrino> edwardk: i'm not sure what tabulatePro and indexPro do, can you explain?
03:12:24 <edwardk> Tagged s a is isomorphic to (Proxy s -> a
03:12:34 <edwardk> they witness that isomorphism
03:12:41 <edwardk> same as fromProxy/toProxy do
03:12:41 <`nand`> edwardk: also, I came across an interesting barrier when replicating your using/usingT from the examples; the problem with them is that ‘a’ needs to be mentioned by the result type; so using's ‘a’ or usingT's ‘t a’ works. But ideally, I'd want to generalize this to accept any type which /mentions/ a somewhere; eg. ([a], [Map k a]) without having to make a using' that uses t (l a) (l (m a)) or
03:12:43 <`nand`> whatever to have it fit the right shape
03:13:07 <neutrino> edwardk: i'm not sure how what you said relates to what i asked?
03:13:11 <edwardk> `nand`: sadly you need to use newtype wrappers and proxies and scoped type variables to pull it off
03:13:54 <edwardk> neutrino: Tagged is the canonical name for Reify.      tabulatePro and indexPro are each half of the isomorphism
03:14:03 <neutrino> ok
03:14:12 <edwardk> tabulatePro :: (Proxy s -> a) -> Tagged s a  goes one way
03:14:15 <`nand`> edwardk: you mean as seen here? http://hpaste.org/79764
03:14:23 <edwardk> indexPro :: Tagged s a -> (Proxy s -> a)  goes the other
03:14:48 <edwardk> yeah
03:15:52 <neutrino> edwardk: i don't see tabulatePro in the "tagged" package anywhere. is this something you just came up with?
03:16:34 <edwardk> [06:10] edwardk:	 if you want to get fancy, there is a package I have called representable-profunctors
03:16:34 <edwardk> [06:10] edwardk:	 in there the 'representation' of Tagged s is Proxy s
03:16:46 <edwardk> the ones in tagged are toProxy and fromProxy
03:16:49 <edwardk> i mentioned that above too
03:17:14 <edwardk> tabulatePro and indexPro are in another package tied up in a lot more theory ;)
03:17:21 <neutrino> thanks for clarifying
03:18:31 <neutrino> that's fairly difficult to understand, from a theory standpoint, at least for me. have you thought about updating the reflection package to have an api that is easier to use?
03:20:13 <edwardk> neutrino: its about as minimal of an API as you can get, its two functions and a class. and i don't even need instances for the class ;)
03:20:41 <neutrino> yes, it's minimal, but i meant easy to use
03:21:48 * fmap still isn't sure whether the only purpose of reflection is trolling
03:22:12 <neutrino> it's actually a good idea, but the reflection package is difficult to use
03:22:26 <neutrino> at least to me
03:22:30 <`nand`> edwardk: would you say it's idiomatic, for simple code, to just pass around a ‘Proxy s’?
03:23:02 <fmap> neutrino: what would be a better api?
03:23:07 <`nand`> and use this as the usual ‘configuration’ passing, but with the added benefit of it not being able to escape the rank-2
03:36:06 <neutrino> fmap: something like what `nand` presented yesterday, with the improvements that edwardk mentioned just now
03:36:29 <`nand`> so import representable-profunctors and move on with life? :P
03:36:34 <edwardk> `nand`: in general the problem with Proxy s is that you often need to get 'under' the function
03:36:43 <edwardk> and Tagged lets you push the instance down
03:36:44 <bradleyayers> hmm `cabal: Couldn't read cabal file "hashable/1.2.0.0/hashable.cabal"'
03:37:03 <edwardk> neutrino: figure out a better API and get back to me
03:40:40 <golosone> ciaooooooooooo
03:40:49 <golosone> !list
03:40:49 <monochrom> golosone: http://hpaste.org
03:42:41 <`nand`> I don't get it. I'm pretty sure I asked it before, but how come somebody constantly comes in and says “ciao”, followed by “!list” and then quits immediately afterward? I don't think I've seen it on any other channel
03:42:50 <`nand`> and what's with monochrom's hpaste response? Makes no sense to me
03:43:27 <shachaf> I don't think I've seen it on any other channel, or this channel, for that matter.
03:43:52 <shachaf> monochrom has a bot set to respond to !list
03:44:08 <shachaf> Apparently I *have* seen it on this channel.
03:44:28 <catsbydlo> I've seen it happen all the time on mozilla
03:44:34 <catsbydlo> #firefox in particular
03:44:43 <catsbydlo> I think it's stupid italians
03:46:29 <`nand`> grep ciao -C1 irc.freenode.#haskell.weechatlog | grep '!list' | wc -l => 26
03:46:51 <`nand`> of course, two of those are probably false positives triggered by me asking about the phenomenon
03:51:48 <`nand`> http://bpaste.net/show/66426/
03:52:31 <catsbydlo> CIAO A TUTTI!!
03:53:17 <`nand`> (there's actually one more match that goes “ciao a tutti” and then “!list”)
03:56:40 <Mon_Ouie> I know the !list command is used on some IRC servers that also serve files (through DCC queries) to get the list of available downloads
03:56:54 <Mon_Ouie> (No idea why someone would try that here, though)
03:57:38 <Eelis> to get pirated versions of ghc, of course ;)
03:58:10 <`nand`> there should be torrents for GHC / the haskell platform
03:58:34 <shachaf> !list
03:58:34 <monochrom> shachaf: http://hackage.haskell.org/packages/archive/pkg-list.html
03:58:36 <shachaf> !list
03:58:39 <shachaf> Aw.
03:58:54 <Hafydd> Someone sold me a CD with GHC in a parking lot.
03:59:07 <bradleyayers> Hafydd: you bought it?
03:59:38 <Hafydd> Yes. If I hadn't, I wouldn't know what Haskell is.
04:00:01 <shachaf> GHC fits on a CD?
04:00:12 <Hafydd> It was an early version.
04:00:23 <Eelis> Hafydd: did you have to sit through the fbi warning screen at the start?
04:00:31 <bradleyayers> Hafydd: Was this recently?
04:00:38 <Hafydd> 3 days ago.
04:00:53 <`nand`> -rw-rw-r--  1 portage portage  26M Jun  6  2012 ghc-7.4.2-src.tar.bz2
04:00:55 <bradleyayers> That seems very unusual.
04:00:55 <`nand`> shachaf ^
04:01:14 <Hafydd> I am in fact making this all up, as you might guess.
04:01:17 <`nand`> even the binary package is only 94 MB large
04:01:24 <`nand`> in .tar.gz form
04:01:37 <shachaf> thanks `nand`
04:01:40 <bradleyayers> Hafydd: I did not suspect you were being untruthful.
04:02:01 <catsbydlo> a master ruseman
04:02:33 <catsbydlo> http://1-media-cdn.foolz.us/ffuuka/board/q/image/1352/04/1352043140847.png
04:04:20 <Eelis> heh
04:04:55 <Hafydd> Precisely.
04:14:15 <neutrino> `nand`: those are bots looking for xdcc servers. they /list the server to get the largest channels, then they join them and do this.
04:14:51 <neutrino> if they see a response, they notify the bot owner, who then joins in and can check out what files you have available for download.
04:15:19 <`nand`> that makes sense. Why the ‘ciao’?
04:16:13 <neutrino> in many such channels, if you joined in and used a trigger without saying anything, you'd get kickbanned because you were sure to be a bot
04:16:25 <neutrino> so they would camouflage in this way
04:16:38 <`nand`> ‘hello’ wouldn't have worked?
04:16:54 <neutrino> sure, it would have, but the owner is probably italian
04:19:53 <neutrino> edwardk: regarding to the API - i think `nand`'s "ReifyT" thing is pretty good
04:20:24 <neutrino> edwardk: you said there were improvements to be made - so there's that on top
04:20:28 <edwardk> neutrino: taocerrsuc
04:20:37 <edwardk> that only covers your usecase
04:20:43 <neutrino> yep
04:20:47 <neutrino> it does, doesn't it?
04:21:10 <edwardk> i have tagged and the ability to easily convert tagged to proxy
04:21:13 <neutrino> but it also covers the use case of: reify foo $ (\p -> reflect p)
04:21:14 <edwardk> and back
04:21:19 <neutrino> yeah
04:21:20 <neutrino> *you* do
04:21:26 <neutrino> *i* don't
04:21:27 <neutrino> many others don't
04:21:28 <edwardk> and it completely fails for when you need multiple reifies
04:21:36 <edwardk> *shrug*
04:21:39 <edwardk> i used to use tagged
04:21:41 <edwardk> it sucked
04:21:43 <edwardk> i changed it
04:22:10 <edwardk> the proxy approach requires fewer ScopedTypeVariable hacks on the behalf of most users and can be readily converted to tagged
04:22:31 <edwardk> i'm not going to change the api back
04:22:41 <neutrino> i'm not sure how what you're saying makes the reflection package any easier to use to me and many others who aren't really strong in haskell type systems
04:23:01 <neutrino> i'm just saying there's a problem there, so it would be nice to have a simplified api
04:23:21 <neutrino> not to replace the one there is already, just as an alternative for those who don't understand high-fly category theory and type hacks
04:23:22 <edwardk> reflection isn't really for that audience. its a tool in the toolbox for when you need to make a dictionary dynamically. 90% of the time that _isn't what you should do. and if you do need it you probably know enough haskell to do it right
04:23:31 <ion> > let reify = flip id; reflect = id in reify 6 $ \p -> reflect p + reflect p
04:23:33 <lambdabot>   12
04:23:40 <edwardk> i don't view your API proposal as a simplifcation
04:23:59 <edwardk> here is no category theory in proxy
04:24:52 <neutrino> i thought the paper said reflection was a tool for configuring code without passing around parameters (like with reader) and while being able to make a type-level distinction between pieces of code that were configured differently (what reader doesn't do)
04:25:24 <edwardk> the proxy API is the exact api from the paper with better type safety
04:25:39 <edwardk> the tagged API i had temporarily bolted in was worse for its major usecase
04:25:40 <neutrino> yes, i know it is
04:25:58 <neutrino> i'm just saying, i have no idea what it has to do with something called "making a dictionary dynamically"
04:26:04 <neutrino> because i don't understand it
04:26:08 <edwardk> fromProxy reflect  gets you tagged
04:26:09 <Jafet> "and better optimization"
04:26:22 <edwardk> Jafet: yeah the fact that its 3 orders of mangitude faster is a nice perk
04:26:25 <catsbydlo> neutrino: oh, that's about typeclass implementation details
04:26:48 <edwardk> neutrino: you have a function a -> a -> a   and a value of type a. make an instance of Monoid dynamically from it
04:26:56 <edwardk> neutrino: thats what reflection lets you do
04:26:59 <Jafet> https://github.com/ekmett/reflection/blob/master/examples/Monoid.hs
04:26:59 <neutrino> and that's exactly the issue, one shouldn't understand what "making a dictionary dynamically" is to be able to propagate configuration around your program. as `nand` showed, one doesn't *have* to either
04:27:10 <edwardk> it lets you take those values and reify then into a type you can reflect back down to get the values
04:27:13 <neutrino> edwardk: i don't see how that works
04:27:31 <neutrino> edwardk: you're trying to explain it to me but you're just saying things which require experience i don't have
04:27:37 <edwardk> neutrino: this is why its a library. because its a damn difficult concept to get right
04:27:48 <catsbydlo> reflection is about teleporting values through the type system
04:27:56 <neutrino> statements like "fromProxy reflect gets you tagged" are meaningless to me
04:28:01 <neutrino> catsbydlo: i realize that much
04:28:02 <edwardk> it lets you do something you'd think you can't do
04:28:21 <neutrino> edwardk: what i'm saying is, there should be a way for people who aren't experts in haskell to use this stuff
04:28:25 <edwardk> fromProxy reflect :: Reifies s a => Tagged s a
04:28:37 <Jafet> Is neutrino trolling
04:28:46 <edwardk> neutrino: nd what i'm saying is that anybody who isn't an expert in haskell isn't going to be able to understand reflection in the first place
04:29:11 <edwardk> Jafet: he's being neutrino. which is the same thing to a first approximation ;)
04:29:23 <neutrino> well i understood the basics of reflection, how they reify values to types, and then reflect back to values
04:29:47 <edwardk> neutrino: and the proxy is a placeholder for the type you can then do anything you want with it
04:29:57 <catsbydlo> wait, let's see: reflect :: (Reifies s a) => we s -> a
04:30:04 <vu3rdd> haskell n00b here, trying to understand this code. Wondering what the bang (!) operator here means, can someone help? https://github.com/bjpop/berp/blob/master/libs/src/Berp/Base/SemanticTypes.hs#L117
04:30:08 <Jafet> That's true
04:30:15 <neutrino> vu3rdd: lookup in Array
04:30:34 <catsbydlo> vu3rdd: strictness annotation
04:30:52 <neutrino> oh, right. the other bang. sorry
04:30:54 <`nand`> (would it make sense to have the ‘s’ in Reifies be of kind Void?)
04:31:56 <neutrino> vu3rdd: check this out: http://www.haskell.org/haskellwiki/Keywords
04:32:01 <vu3rdd> catsbydlo: neutrino: thanks.
04:32:23 <vu3rdd> neutrino: thanks. I also found this one that explains it. http://www.haskell.org/haskellwiki/Performance/Data_types
04:32:38 <ethercrow> does it make sense to try and port a package from using data-accessor to using lens?
04:32:56 <edwardk> ethercrow: a lot of folks have been doing it. you know you want to ;)
04:32:57 <neutrino> edwardk: anyways, once you started talking about tagged, profunctors, and a lot of other stuff (basically the whole explanation you gave me in the first place) i got really confused. i think what you were saying was just basic machinery behind the actual idea, which could be boxed away.
04:33:14 <edwardk> there is no box
04:33:33 <catsbydlo> well, there is black magic
04:33:35 <edwardk> and the very idea is that you need to be able to move those types to places you can't get them with a monad
04:34:02 <edwardk> so the monad you keep pushing is not only useless, it directly fights the major usecase.
04:34:06 <`nand`> catsbydlo: reflection already is black magic
04:34:15 <catsbydlo> `nand`: that's what I mean
04:34:35 <`nand`> actually, it's probably more like heavy wizardry
04:34:36 <catsbydlo> wait, if you're doing this with a monad, isn't that just Reader?
04:34:40 <ethercrow> edwardk: thank you for unbiased advice :)
04:34:41 <edwardk> the profunctor comment was mostly because i have profunctors on my brain due to their use in lens and the fact that i'd just written that instance.
04:34:49 <`nand`> catsbydlo: Tagged
04:34:55 <catsbydlo> what's Tagged?
04:34:58 <`nand`> as edwardk pointed out, a Reader is unnecessarily inefficient
04:34:59 <edwardk> ethercrow: you'll find in life that virtually all advice is biased ;)
04:35:02 <`nand`> newtype Tagged s a = Tagged a
04:35:08 <`nand`> Flip Const ;)
04:35:55 <catsbydlo> is that Identity?
04:36:11 <`nand`> Tagged s ≅ Identity
04:36:20 <`nand`> but you carry around a phantom parameter
04:36:23 <ethercrow> I'm just looking at yi's build-depends list and feeling that it's rather large
04:36:35 <neutrino> edwardk: i didn't know it was the idea to move types "to places you can't get them with a monad"
04:36:51 <ethercrow> also yi is the only reverse dependency of data-accessor-mtl, that's suspicious
04:36:52 <neutrino> edwardk: why would you want that? that's an interesting observation
04:37:11 <catsbydlo> isn't that what the original paper was about?
04:37:23 <edwardk> neutrino: let me work slowly through the monoid example
04:37:32 <catsbydlo> distributing configuration data without having to pass it explicitly or putting all code in a monad?
04:37:57 <edwardk> lets say you have a function a -> a -> a and a value of type a, and you want a Monoid that uses those as its mappend and mempty
04:38:15 <edwardk> you could completely ignore reflection and write a version of this
04:38:15 <`nand`> the example in the paper was about constructing different Num instances on the fly for modulo arithmetic
04:39:08 <bzm3r> Let a, b, c, and d be arbitrary strings composed of 0s and 1s. If dab = 1c0cd, then I reason that d must be at least, eb, where e is any arbitrary string of 0s and 1s, If I continue that line of reasoning on, trying to figure out what e is, I eventually get to a situation where fab = 1c0cf, So, I can never deduce what d is by reasoning like that?
04:39:12 <`nand`> speaking of which; surely that can be done easily with DataKinds
04:39:35 <bzm3r> Sorry, I am not sure why I didn't put any periods in there...
04:39:49 <edwardk> newtype MyMonoid a = (a -> (a -> a -> a) -> a)   then mempty = MyMonoid (\e _ -> e)
04:40:20 <edwardk> mappend (MyMonoid f) (MyMonoid g) = MyMonoid (\e p -> p (f e p) (g e p))
04:40:25 <edwardk> but this kind of sucks
04:40:49 <edwardk> if you did something that built up a value and then reused it you get sharing of the functions… not of the _values_ you are computing
04:41:04 <edwardk> you get to share values of type (a -> (a -> a -> a) -> a)  not of type a.
04:41:27 <`nand`> if a, b and c are empty; then dab = d = 10d = 101010...; if a is ‘c0cd’ and c/b is empty; then d = 1; and a = ‘01’
04:41:34 <`nand`> or am I misunderstanding something here?
04:41:35 <catsbydlo> wait, this is basically a Reader ClassDict
04:41:39 <`nand`> (re: bzm3r)
04:41:39 <edwardk> let y = mappend x x; z = mappend y y; w = mappend z z in w
04:41:43 <edwardk> that does more and more and more work
04:42:02 <bzm3r> `nand`: a, b and c are not empty
04:42:03 <neutrino> edwardk: ok, 1 sec
04:42:05 <edwardk> if you iterate this dozens of times you get an exposive amount of work
04:42:12 <bzm3r> `nand`: however, d can be empty
04:42:20 <neutrino> in MyMonoid a, what does the "a" represent? is it the modulo?
04:43:22 <bzm3r> `nand`: maybe I should write the problem like this dAB = 1C0CD -- where capitals denote non-empty strings whose values we know, and the lower case letters represent strings whose values we don't know, and they could thus be empty
04:43:37 <catsbydlo> neutrino: the 'a' represents the type
04:43:44 <bzm3r> argh, dAB = 1C0Cd**
04:43:47 <edwardk> neutrino: say 'a' is the carrier type, that you are computing the monoid on
04:43:49 <bzm3r> (d has to be lower case too)
04:43:50 <edwardk> Int
04:43:51 <edwardk> for instance
04:43:59 <edwardk> with a = 0, a -> a -> a = (+)
04:44:15 <edwardk> or with choosing mempty = 1, and the function = (*)
04:44:23 <edwardk> or minBound and max
04:44:26 <edwardk> or maxBound and min
04:44:27 <neutrino> right
04:44:27 <edwardk> etc.
04:45:16 <neutrino> so in MyMonoid Int, why does that definition of mempty evaluate to 0?
04:45:20 <Jafet> Another reflection example: http://hpaste.org/79794
04:45:31 <neutrino> if I use (+)
04:45:44 <catsbydlo> neutrino: it doesn't
04:46:00 <catsbydlo> the definition of mempty turns into a ... suspended lookup, sort of
04:46:16 <catsbydlo> you need a runMyMonoid function around the result
04:46:22 <neutrino> ah
04:46:23 <edwardk> runMyMonoid mempty 0 (+) = 0
04:46:52 <neutrino> i was missing that bit
04:46:55 <edwardk> embed :: a -> MyMonoid a; embed = MyMonoid (\_ _ -> a)
04:47:09 <edwardk> runMyMonoid (embed 2 `mappend` embed 3) 0 (+)
04:47:16 <edwardk> so far so good?
04:47:20 <edwardk> this would be a valid monoid
04:47:22 <edwardk> it just sucks
04:47:30 <edwardk> because you have sharing, but only sharing of functions
04:47:30 <catsbydlo> instance Monad MyMonoid
04:47:41 <edwardk> catsbydlo; a occurs in negative position. try it
04:47:43 <neutrino> wait a sec, still reading
04:47:57 <Taneb> GEDCOM really wasn't designed to be nice to Haskell
04:48:27 <catsbydlo> oh right, I'd need separate type variables
04:49:32 <neutrino> ok, in here: "mappend (MyMonoid f) (MyMonoid g) = MyMonoid (\e p -> p (f e p) (g e p))" -- the f and g would be the int values, so e.g. f == 2 and g == 3?
04:49:46 * neutrino is still not clear on how newtype works..
04:50:04 <catsbydlo> no, f/g would be functions
04:50:20 <catsbydlo> neutrino: if you knew how it works, you would've seen that it's a syntax error :-)
04:50:30 <neutrino> :S
04:50:31 <catsbydlo> do you know how 'data' works?
04:50:42 <johnw> neutrino: i believe newtype creates a type which is distinguished in the GHC type checker, but has no runtime bits to indicate the value constructor, the way "data" does
04:50:42 <catsbydlo> data MyMonoid a = MyMonoid (a -> (a -> a -> a) -> a)
04:51:02 <catsbydlo> f, g :: a -> (a -> a -> a) -> a
04:51:14 <catsbydlo> f and g are functions that are waiting for two arguments
04:51:22 <shachaf> johnw: data Foo = Foo has no runtime bits to indicate the value constructor. :-)
04:51:26 <catsbydlo> the first argument is the neutral element, the second argument is the combining function
04:51:30 <neutrino> but we're not using a data, we're using a newtype catsbydlo
04:51:34 <shachaf> (Well, OK, I guess you could say that it does. But it's not for distinguishing a sum.)
04:51:35 <catsbydlo> neutrino: same thing
04:51:53 <edwardk> neutrino: the distinction here is largely irrelvant
04:52:05 <johnw> shachaf: fair enough; is what I said true for data Foo a = Foo a vs. newtype Foo a = Foo a?
04:52:06 <edwardk> neutrino: newtype just makes a data type that has no overhead
04:52:07 <catsbydlo> catsbydlo: 'newtype' is limited to 1 data constructor and the differences don't matter for this example
04:52:13 * neutrino glares
04:52:37 <shachaf> johnw: I think I was just nitpicking your phrasing, come to think of it.
04:52:42 <shachaf> So never mind.
04:54:10 <edwardk> neutrino: so embed works by making a function like that, that skips its arguments and just gives you the a you specified
04:54:16 <edwardk> mempty works by taking the first argumnt
04:54:29 <edwardk> mappend uses the second on the result of passing those args down to each of its arguments
04:55:18 <edwardk> mappend (MyMonoid f) (MyMonoid g) = MyMonoid (\e p -> p (f e p) (g e p))   is ackind the first monoid to compute its answer, then the right to compute its answer and then stitching them together with p.
04:55:18 <neutrino> (reading)
04:55:44 <catsbydlo> s/ackind/asking/?
04:56:28 <edwardk> but now y = mappend x x; z = mappend y y; w = mappend z z; v = mappend w w; u = mappend v v; r = mappend u u… is doing an explosive amount of work
04:56:40 <edwardk> because its asking the same function to do the same work given the same args over and over
04:57:02 <edwardk> 6 such chains and you do 2^6 calculations
04:57:07 <edwardk> you share the functions, but that doesn't help
04:57:19 <neutrino> i like how you go x y z w v u r
04:57:22 <edwardk> 100 such operations in sequence and you do 2^100 calculations
04:57:26 <neutrino> ok, i see his problem
04:57:35 <edwardk> but if you had
04:57:56 <edwardk> newtype Foo = Foo Int; instnace Monoid Foo where mempty = 0; mappend = 1, and used that same sequence of operations
04:58:04 <edwardk> you'd do O(n) work
04:58:09 <simon> being someone whose IRC client highlights on "Simon", I must say Simon PJ is being excessively idolized in this channel.
04:58:09 <edwardk> not O(2^n) work
04:58:21 <edwardk> simon: i recommend changing your nick ;)
04:58:36 <ion> Let’s stop referring to simon from now on.
04:58:45 <shachaf> I hear there's a naming convention for nicks in this channel.
04:58:48 <edwardk> people playing simon says must get really annoying too
04:58:49 <shachaf> /nick shachafb
04:58:50 <Botje> do you also trigger on SimonPJ?
04:58:52 <ion> I can understand how simon finds excess highlighting annoying.
04:59:11 <Hafydd> Is Jones in this channel?
04:59:15 <simon> Botje, yes.
04:59:26 <Botje> ah. might want to change that :)
04:59:34 <ion> hafydd: Simon Jones?
04:59:40 <ion> hafydd: No, Simon isn’t here AFAIU.
04:59:48 <Hafydd> I see.
04:59:57 <Jafet> Is Simon Jones related to Simon Peyton-Jones?
05:00:12 <Hafydd> Yes, it's what I incorrectly called him.
05:00:14 <hpaste> “`nand`” annotated “ZZZ” with “Modulo arithmetic” at http://hpaste.org/76852#a79795
05:00:16 <shachaf> Jafet: His last name is actually "Peyton Jones".
05:00:27 <simon> Botje, it would only weed out a fraction anyways :P
05:00:30 <`nand`> Jafet: ^
05:01:05 <neutrino> edwardk: ok, i see that
05:01:17 <neutrino> i think i need to learn how "newtype" and "data" really work
05:01:35 <neutrino> because there's a lot of confusing stuff i just read about them :X
05:01:41 <Jafet> @hoogle Data.Singletons
05:01:42 <lambdabot> No results found
05:01:54 <neutrino> that should be my next endeavour
05:03:34 <`nand`> withMod (SSucc (SSucc (SSucc SZero))) $ 2^10^1000  => 1
05:03:40 <`nand`> of course, writing numbers like that isn't very nice
05:04:14 <Jafet> Doesn
05:04:20 <Jafet> 't sound very efficient
05:04:38 <`nand`> yeah the modulo would be constructed every time I think
05:04:50 <`nand`> by repeated addition
05:05:09 <`nand`> of course, all we need is proper support for Nat
05:05:25 <`nand`> that is, if GHC 7.8 or whatever gives us singletons and a reflection typeclass for them, it could be efficient
05:05:25 <bzm3r> is it bad form to repeat a question in irc i'm wracked with insecurity
05:05:32 <Hafydd> Google suggests "simon peyton jones haskell is useless", heh.
05:05:50 <bzm3r> argh
05:05:57 <neutrino> edwardk: thanks for trying to explain it to me. i think you've shown me well where my limits are right now :) i'll try to learn the things i didn't understand at that point
05:06:16 <bzm3r> is it bad form to repeat a question in irc?* i'm wracked with insecurity -- i have no clue why i am missing all my punctuation today
05:06:24 <neutrino> also thanks catsbydlo / johnw
05:06:28 <edwardk> neutrino: anyways, with reflection you can get the same sharing as the simple Foo Monoid.
05:06:29 <`nand`> newtype introduces a new name for an existing type
05:06:34 <`nand`> that is distinct from the original
05:06:53 <catsbydlo> it's syntactically data and semantically type
05:07:26 <neutrino> right, but I don't understand what newtype Foo a = Foo (a -> (a -> a -> a) -> a) means
05:07:28 <simon> bzm3r, probably not.
05:07:47 <`nand`> it means ‘Foo a’ is another name for ‘a -> (a -> a -> a) -> a’
05:07:55 <`nand`> but the two are distinct types
05:08:02 <catsbydlo> neutrino: same as 'data' (to a first approximation)
05:08:08 <`nand`> you can convert between the two by applying/matching on the ‘Foo’ constructor
05:08:43 <ion> neutrino: Do you understand what newtype Foo = Foo Integer means? How about Foo a = Foo a?
05:08:44 <edwardk> neutrino: its making up a type named Foo. that takes a type argument a, and where you have a data constructor Foo at the value level that you can pattern match on Foo :: (a -> (a -> a -> a) -> a) -> Foo a
05:09:17 <fmap> edwardk: so the point is to construct instances in runtime?
05:09:33 <edwardk> fmap: that is exactly what reflection is used for
05:09:47 <neutrino> ion: not right down to the definitions, no. only vague intuitions.
05:09:53 <edwardk> you normally can't make an instance that depends on some value you have lying around
05:09:57 <edwardk> reflection lets you fix this
05:10:03 <edwardk> by making a type out of an arbitrary value
05:10:07 <`nand`> newtype T x = F { g :: y } -- ‘T x’ and ‘y’ are the same, the isomorphism is ‘F :: y -> T x’ and ‘g :: T x -> y’
05:10:09 <edwardk> that you can reflect to get the value back out
05:10:22 <edwardk> i use this for all sorts of fun things
05:10:33 <neutrino> `nand`: aha
05:10:38 <neutrino> `nand`: that i understand
05:11:03 <Skillsob> Can anyone tell me what a profunctor is? I've seen the word thrown around here a fair bit in the last few days.
05:11:18 <neutrino> so basically, T and g go together like a record
05:11:33 <neutrino> Skillsob: edwardk can because he's the one who's been throwing it around ;)
05:11:45 <`nand`> Skillsob: class Profunctor f where rmap :: (a -> b) :: f c a -> f c b; lmap :: (a -> b) :: f b c -> f a c
05:11:58 <`nand`> canonical example: (->)
05:12:19 <edwardk> Skillsob: http://hackage.haskell.org/packages/archive/profunctors/3.1.1/doc/html/Data-Profunctor.html has docs now
05:12:34 <edwardk> it also links to an article by dan piponi on the topic that explains it better than i do in the docs
05:12:43 <catsbydlo> `nand`: what are the syntax errors for?
05:12:57 <`nand`> catsbydlo: huh?
05:13:07 <catsbydlo> (a -> b) ::
05:13:09 <edwardk> but basically its a a type p which takes two arguments that is functor on the right and is contravariant in the first argument.
05:13:11 <`nand`> oh
05:13:19 <`nand`> wow, I really screwed that up
05:13:20 <`nand`> (a -> b) ->
05:13:22 <`nand`> not ::
05:13:27 <edwardk> Skillsob: we're using it a _lot_ in lens now
05:14:01 <ion> The alot of profunctors
05:16:06 <`nand`> edwardk: you should probably set LANGUAGE PolyKinds in Data.Profunctor, to make the instance Profunctor (Tagged *) more polymorphic
05:16:20 <edwardk> `nand`: doesn't work
05:16:33 <edwardk> i was an idiot and put it in in an older version
05:16:42 <edwardk> i'm still mapping with a function
05:16:45 <edwardk> that pins its type down
05:16:49 <edwardk> er its kind
05:17:11 <`nand`> I don't understand
05:17:25 <`nand`> oh
05:17:27 <`nand`> lmap
05:17:34 <edwardk> Tagged is a profunctor because i can map over the left argument with a function a -> b
05:17:35 <edwardk> yes
05:17:41 <`nand`> yeah that makes sense, ignore me
05:17:43 <edwardk> this only works if that arg has kind *
05:17:46 <edwardk> np
05:17:54 <edwardk> its an understandable mistake
05:18:12 <edwardk> if i had profunctors between arbitrary categories it'd be a perfectly reasonable request
05:18:22 <edwardk> but all we have are Hask -/-> Hask Profunctors
05:19:10 <`nand`> isn't Tagged also a Bifunctor?
05:19:15 <shachaf> Yep.
05:19:24 <`nand`> no instance for it in Data.Bifunctor :(
05:19:38 <shachaf> You can even make bifunctor lenses with it.
05:19:39 <edwardk> i didn't add a dependency there
05:19:42 <shachaf> And bifunctor prisms.
05:19:52 <edwardk> i could be talked into it but it requires a major release
05:20:02 <`nand`> I'll wait until I find a use case first
05:20:05 <edwardk> if you make an issue on the bifunctors package i'll add the instance when i get around to releasing it again
05:20:08 <`nand`> lazy development
05:20:16 <shachaf> `nand`: Bifunctor isomorphisms are a use case!
05:20:22 <shachaf> iso = bimap
05:20:25 <shachaf> p s b -> p a t
05:21:22 <`nand`> but how does that connect to Tagged?
05:21:54 <Jafet> The language of category theory seems extremely amenable to agglutination.
05:21:54 <shachaf> Tagged s b -> Tagged a t
05:21:55 <shachaf> b -> t
05:22:04 <edwardk> `nand`: for reading back
05:22:05 <mreh> Is there some kind of error monad transformer that throws custom errors? Not just String messages like MonadError + ErrorT String m
05:22:06 <shachaf> You use it to use a prism.
05:22:19 <shachaf> mreh: EitherT?
05:22:25 <shachaf> @hackage either
05:22:26 <lambdabot> http://hackage.haskell.org/package/either
05:22:28 <shachaf> That one, probably.
05:22:31 <mreh> ahah
05:23:38 <`nand`> shachaf: ah, same role as Const then?
05:23:57 <shachaf> `nand`: Well, for the other half.
05:24:08 <shachaf> Const is for the (s -> a) of lenses, Tagged is for the (b -> t) of prisms.
05:24:58 <`nand`> yeah
05:25:21 <shachaf> `nand`: I don't know how to get Setters working, though. :-(
05:25:38 <shachaf> Find Foo such that (Foo s b -> Foo a t) ~~ (a -> b) -> s -> t
05:25:53 <shachaf> (Where the definition of Foo can mention s/t/a/b.)
05:25:55 <edwardk> pretty sure you can't write a setter for the bifunctor form
05:26:01 <edwardk> you can't cross the -> more than once
05:26:29 <johnw> `nand`: your definition of profunctor is completely wrong, isn't it?
05:26:43 <shachaf> johnw: Why?
05:26:47 <shachaf> Unless you mean the extra ::s.
05:27:01 <johnw> oh, n/m
05:27:08 <johnw> for (->), rmap is just (.), right?
05:27:20 <`nand`> yeah, and lmap flip (.) or whatever
05:27:41 <edwardk> johnw: yep
05:27:58 <johnw> so does rmap always = fmap?
05:28:03 <shachaf> Yep.
05:28:11 <edwardk> johnw: yes
05:28:11 <`nand`> yeah
05:28:15 <`nand`> there can only be one Functor instance after all
05:28:19 <edwardk> johnw: you can prove it given parametricity and their laws
05:28:21 <`nand`> so if rmap id = id; and fmap id = id; fmap = rmap
05:28:22 <johnw> so what's the usefulness of this abstraction?
05:28:41 <johnw> if I have fmap, don't I have the same utility as profunctor?
05:28:47 <edwardk> johnw: there are lots of profunctors other than arrow
05:28:48 <`nand`> fmap doesn't give you lmap
05:28:50 <shachaf> No, you're missing lmap. :-)
05:29:02 <johnw> ah, lmap requires an actual definition
05:29:07 <edwardk> Consider UpStar f a b = UpStar (a -> f b)  for a functor f
05:29:08 <`nand`> (or dimap)
05:29:09 <johnw> got it
05:29:38 <edwardk> johnw: so far so good?
05:29:42 <johnw> edwardk: is that like Kleisli for general functors?
05:29:53 <`nand`> like kleisli for profunctor composition
05:30:20 <johnw> edwardk: go on
05:30:28 <edwardk> johnw: well, there is a form of 'profunctor' composition that works for any profunctor that when you use it for two 'UpStar's of basic functors give you the UpStar of their composition
05:30:32 <edwardk> lets consider
05:30:35 <`nand`> Procompose (UpStar f) (UpStar g) ≅ UpStar (Compose f g)
05:30:44 <`nand`> Procompose (DownStar f) (DownStar g) ≅ DownStar (Compose g f)
05:30:52 <johnw> makes sense
05:31:08 <edwardk> newtype Procompose p q a c = forall b. Procompose (p a b) (q b c)
05:31:12 <edwardk> er not newtype, data
05:31:27 <edwardk> there if p = UpStar f and g = UpStar g, you have
05:31:37 <edwardk> exists b. (a -> f b, b -> g c)
05:31:46 <johnw> i see the definitions on http://hackage.haskell.org/packages/archive/profunctors/3.1.1/doc/html/Data-Profunctor.html
05:31:48 <johnw> you don't have to repeat
05:31:54 <edwardk> but since you know nothing else about b, the only thing you could do is fmap to push the g c into f
05:32:04 <edwardk> so you have a -> f (g c)
05:32:10 <edwardk> which is UpStar (Compose f g)
05:32:55 <johnw> and lmap let's you apply the composition?
05:33:03 <edwardk> profunctors are kind of like 'relations' in that you can lift a 'function' (Functor) into a relation in one of two ways, by going forward (UpStar) or backwards (DownStar)
05:33:18 <johnw> ohh
05:33:20 <edwardk> lmap lets you map over the inputs rmap lets you map over the outputs
05:33:45 <johnw> so fmap lift a function into the functor, but profunctor lets you map half of it, so to speak
05:33:51 <`nand`> where is Procompose defined?
05:34:02 <edwardk> profunctor-extras
05:34:06 <edwardk> it takes extensions
05:34:09 <edwardk> profunctors is haskell 98
05:34:10 <`nand`> ah
05:34:14 <`nand`> right, existentials
05:34:16 <fmap> edwardk: why don't I need `Reifies s (Monoid_ a)' instance to be able to use `Monoid (M a s)' instance?
05:34:23 <fmap> I guess this is stupid question but still
05:34:47 <`nand`> instance Reifies s (Monoid_ a) => Monoid (M a s) where -- what do you mean?
05:34:50 <edwardk> fmap: you do, effectively
05:34:57 <edwardk> fmap: i just magic it up out of thin air
05:35:24 <fmap> edwardk: yes, but there isn't `Reifies s (Monoid_ a)' anywhere?
05:35:25 <edwardk> instance Reifies s (Monoid_ a) => Monoid (M a s)  is used in the target code
05:35:33 <`nand`> fmap: ‘reify’ gives it
05:35:36 <edwardk> no, i make the dictionaries up for Reifies by black magic
05:35:37 <`nand`> :t reify
05:35:38 <lambdabot> Not in scope: `reify'
05:35:59 <`nand`> reify :: a -> (forall s. Reifies s a => Proxy s -> r) -> r
05:36:01 <edwardk> reify :: a -> (forall s. Reifies s a => Proxy s -> r) -> r
05:36:11 <edwardk> that is where the dictionary is constructed
05:36:20 <edwardk> it used to be fairly comprehensible
05:36:36 <edwardk> fmap: lets work through how a principled version of this idea could work
05:36:48 <edwardk> then we'll explore the hack elliott and i came up with
05:36:48 <fmap> so second `reify' argument is some "environment" where this instance is "defined"?
05:37:26 <`nand`> (the paper's approach uses type-level pointers and unsafePerformIO to get dictionaries into memory :P)
05:37:36 <edwardk> fmap: the way i usually do this is to walk through this by getting the person i'm explaining it to to accept a series of propositions, each slightly more outlandish than the last
05:37:46 <fmap> yeah, I skimmed through the paper but didn't find anything similar
05:38:07 <edwardk> fmap: ok, we have type level naturals, right? w could define them with data Z and data S a
05:38:28 <edwardk> we can make an class that reflected such a type level natural to its value level, right?
05:38:57 <fmap> yes
05:39:03 <edwardk> class IsNat t where nat :: Proxy t -> Int; instance IsNat Z where nat _ = 0
05:39:15 <edwardk> instance IsNat n => IsNat (S n)
05:39:25 <edwardk> then i could give you a function
05:39:30 <`nand`> fmap: the paper defines a slightly less generic reifyIntegral :: Integral a => a -> (forall s. ReflectNum s => s -> w) -> w
05:40:12 <edwardk> reifyNat :: Int -> (forall s. IsNat s =>  Proxy s -> r) -> r can then be defined
05:40:17 <edwardk> take your natural number
05:40:36 <`nand`> oh, and later on it defines the same ‘reify’ that edwardk provides
05:40:38 <edwardk> and then check if its 0, if its 0, use Proxy Z
05:40:38 <`nand`> in 4.3
05:40:39 <edwardk> etc
05:41:07 <edwardk> this gives us the ability to reify natural numbers from the value level to types
05:41:21 <edwardk> it isn't all that earthshaking, but its a useful trick
05:41:29 <edwardk> but it only deals with numbers ;)
05:41:39 <edwardk> we can similarly do this for lists of things we can lift to the type system
05:41:56 <edwardk> so reifyNats :: [int] -> ...
05:42:09 <edwardk> er [Int] -> ..
05:42:32 <edwardk> then there are Storable data types that can be represented by a list of bytes
05:42:43 <edwardk> so we could reify any storable value
05:42:53 <edwardk> and StablePtrs are storable
05:43:26 <edwardk> so we can take a stablePtr to any haskell data type at all including functions, and we can store it and retrieve it
05:43:34 <edwardk> the target won't go away in the meantime since its a stable ptr
05:43:49 <edwardk> if you go back to old versions of reflection this is exactly what i did
05:43:56 <edwardk> with some hacks to avoid leaking stable ptrs
05:43:57 <`nand`> and now for the heavy wizardry
05:44:11 <edwardk> but this is a lot of work just to make a dictionary that holds onto a single value of type 'a'
05:44:32 <edwardk> for that we just cheat. the representation of such a dictionary that holds one value is the value
05:45:02 <edwardk> class Default a where def :: a    -- if it has no superclass and no other members is represented behind the scenes by 'a'
05:45:18 <`nand`> (this is GHC-specific, mind)
05:45:22 <epta> What is a complexity of list_length_n ++ list_length_m? O(n*m)?
05:45:28 <edwardk> `nand`: not entirely. it also works in hugs ;)
05:45:37 <ceii_> epta: O(n)
05:45:58 <epta> ceii_: why?
05:46:12 <edwardk> `nand`: we have a 'slow path' available in the package that deals with other platforms if you want to use it on jhc or nhc or something
05:46:28 <Taneb> epta, it finds the end of n and puts a pointer to m there
05:46:38 <edwardk> that guy just builds up the reification of bytes and the ability to reify 8 bytes to store the pointer
05:46:39 <Taneb> Ish
05:46:42 <`nand`> isn't ‘compexity’ a difficult thing to talk about in lazy environments? If you force it completely, you're walking through 2*n+m cons cells
05:46:44 <edwardk> its a bit simpler than oleg's version
05:47:50 <ceii_> `nand`: but if you forced the two separate lists you'd walk through n+m, so I suppose the difference (n) can be seen as the cost of appending
05:48:16 <`nand`> that sounds reasonable
05:53:32 <johnw> edwardk: some interesting clarification: http://blog.sigfpe.com/2011/07/profunctors-in-haskell.html
05:59:39 <yitz> epta: it's actually O(1), until you force it.
06:05:09 * hackagebot http-reverse-proxy 0.1.1 - Reverse proxy HTTP requests, either over raw sockets or with WAI  http://hackage.haskell.org/package/http-reverse-proxy-0.1.1 (MichaelSnoyman)
06:06:42 <portnov> hi all
06:06:58 <portnov> Q: is there any `standard' implementation of priority queue in Haskell?
06:07:22 <neutrino> try looking at modules which depend on stm
06:07:29 <neutrino> s/modules/packages
06:08:12 <`nand`> there seems to be package ‘pqueue’
06:08:21 <`nand`> and package ‘queuelike’
06:09:03 <`nand`> also ‘priority-queue’
06:09:10 <portnov> heh
06:09:15 <`nand`> and ‘pure-priority-queue’
06:09:19 <portnov> which of them is standard? :)
06:09:22 <`nand`> no idea :)
06:09:29 <`nand`> try them all, see which one fits best? maybe benchmark them
06:09:39 <portnov> okay :)
06:11:56 <portnov> in fact, i want smth like
06:11:57 <portnov> atomically $ do
06:11:57 <portnov>   x <- getNextQueueItem queue
06:11:57 <portnov>   y <- readTVar var
06:11:57 <portnov>   doSomethingWith x
06:11:58 <portnov>   when condition $ putItemToQueue queue (x+y)
06:12:26 <`nand`> there might also be something in Edison
06:15:10 <`nand`> pqueue provides maxView :: MaxQueue a => Maybe (a, MaxQueue a) which you could use (+ TVar (MaxQueue a)) to implement getNextQueueItem
06:15:46 <portnov> ok, thanks
06:15:51 <`nand`> or MaxPQueue k a
06:15:54 <`nand`> where k is the priority
06:23:22 <johnw> you know what I want?  a monadic case
06:23:44 <johnw> mcase f of _ -> y, instead of x <- f; case x of _ -> return y
06:23:58 <aristid> johnw: you know about lambda-case?
06:24:18 <johnw> you mean \case of?
06:24:40 <aristid> johnw: with -XLambdaCase... \case { p1 -> e1; ...; pN -> eN }
06:24:49 <PthariensFlame> It's just \case, no of
06:24:55 <johnw> i guess i could always do: f <&> \case _ -> y
06:25:07 <johnw> but my code needs to complie under 7.4 ;(
06:25:30 <aristid> johnw: yeah 7.6 is far from widespread yet, and i don't actually recommend using it
06:25:50 <PthariensFlame> f <&> const y
06:26:00 <johnw> well, in this case yeah :)
06:26:06 <johnw> npi
06:26:06 <aristid> :t (<&>)
06:26:08 <lambdabot> Functor f => f a -> (a -> b) -> f b
06:26:23 <johnw> it's flipped <$>
06:26:32 <aristid> i can read types:)
06:27:29 <PthariensFlame> Or f *> pure y
06:27:45 <aristid> :t (<$)
06:27:46 <lambdabot> Functor f => a -> f b -> f a
06:28:02 <johnw> or f >> return y
06:28:09 <aristid> y <$ f
06:28:26 <aristid> :t ($>)
06:28:27 <lambdabot>     Not in scope: `$>'
06:28:27 <lambdabot>     Perhaps you meant one of these:
06:28:27 <lambdabot>       `$' (imported from Data.Function), `$!' (imported from Prelude),
06:28:34 <otters> I feel like <$ would make more sense as $>
06:28:53 <PthariensFlame> Incidentally, does lambdabot support LamdaCase?
06:30:17 <PthariensFlame> :t flip flip flip
06:30:19 <lambdabot> (a -> ((a1 -> b -> c1) -> b -> a1 -> c1) -> c) -> a -> c
06:30:25 <PthariensFlame> ...Huh
06:31:17 <aristid> :t flip
06:31:18 <lambdabot> (a -> b -> c) -> b -> a -> c
06:31:24 <aristid> ah, flip has been reverted.
06:31:32 <aristid> :t (.)
06:31:33 <lambdabot> Functor f => (a -> b) -> f a -> f b
06:31:38 <aristid> heh.
06:32:31 <PthariensFlame> Where's that definition of (.) from???
06:32:43 <aristid> PthariensFlame: (.) = fmap
06:32:46 <johnw> it's lambdabot
06:33:29 <PthariensFlame> I noticed.  I was just wondering if it was part of a module or something.
06:33:35 <PthariensFlame> That got imported.
06:33:37 <aristid> no
06:34:31 <PthariensFlame> :t itraverse
06:34:32 <lambdabot> (Applicative f, TraversableWithIndex i t) => (i -> a -> f b) -> t a -> f (t b)
06:34:47 <PthariensFlame> So is lens permanently in scope now?
06:35:06 <edwardk> PthariensFlame: yes
06:35:33 <edwardk> PthariensFlame: the custom (.) is a cale-ism
06:35:48 <PthariensFlame> 3.7 or cutting edge?
06:35:53 <`nand`> 3.7
06:35:53 <edwardk> 3.7.0
06:36:01 <`nand`> speaking of which, we need 3.8 :(
06:36:11 <edwardk> 3.8 will be a lot cooler =)
06:36:44 <shanse> and 3.9 will be even better I hope
06:36:53 <`nand`> what's new in 3.8, other than ‘each’?
06:37:50 <edwardk> `nand`: we redesigned prisms and isomorphisms so they work with (.) from the prelude
06:37:56 <`nand`> I thought that was 3.7
06:38:11 <johnw> i can't even imagine what 4.0 will be
06:38:23 <johnw> lenses-with-effects
06:38:37 <`nand`> 4.0 will have redesigned prisms and isomorphisms so they're all just ‘id’
06:38:45 <`nand`> oh, that reminds me
06:39:01 <edwardk> type Prism s t a b = forall k f. (Prismatic k, Applicative f) => k (a -> f b) (s -> f t) is the 3.7 prism
06:39:28 <edwardk> type Prism s t a b = forall p f. (Prismatic p, Applicative f) => p a (f b) -> p a (s t) is the 3.8 prism
06:39:45 <edwardk> that makes the outer arrow an (->) so it composes with (.) from the prelude
06:39:51 <`nand`> edwardk: any chance for supporting read-only zippers (ie. zippers on Folds)?
06:40:05 <edwardk> `nand`: possibly
06:40:08 <`nand`> or ultimately MonadFold zippers
06:40:11 <edwardk> it may be a consequence of what i'm doing now
06:40:20 <edwardk> but it'd make the Zipper type a _lot_ uglier
06:40:23 <`nand`> so you can zip through a directory structure where each ‘within’ lives in a monad
06:40:30 <edwardk> because right now we show the breadcrumb trail
06:40:44 <`nand`> maybe something distinct from Zipper
06:40:56 <edwardk> and if you got that then i'd only be able to give you a much uglier type with the index and the set of constraints introduced at each layer
06:41:17 <edwardk> monadic zippers aren't going to happen any time soon
06:41:33 <shachaf> Zipper might get other changes, though. :-)
06:41:40 <`nand`> edwardk: okay
06:41:47 <edwardk> we are currently investigating if we build a free magma as a fake applicative then we can zip through more things cheaply
06:42:27 <PthariensFlame> A free what?
06:42:45 <`nand`> https://en.wikipedia.org/wiki/Magma_(algebra)
06:42:50 <`nand`> very unfortunate name
06:43:03 <PthariensFlame> Ty
06:43:43 <shachaf> Think of a monoid without assocativity or identity. :-)
06:44:13 <PthariensFlame> Got it.
06:44:19 <otters> class Magma where
06:44:25 <PthariensFlame> Just a binary operation then.  :)
06:44:26 <otters> easy
06:44:37 <`nand`> otters: you forgot the operation :)
06:44:42 <otters> oh yeah whoops
06:44:54 <`nand`> PthariensFlame: a total one, yeah
06:45:39 <shachaf> Hah, Zipper.hs didn't have rank-2 types.
06:46:39 <PthariensFlame> I though you just ignored non-totality in set theory.
06:47:12 <PthariensFlame> And just acted as if the whole world were total.
06:47:31 <shachaf> I think `nand` means closure.
06:47:39 <shachaf> Which is related to totality, I guess.
06:47:56 <`nand`> I meant totality
06:48:03 <PthariensFlame> Ah, ok.
06:48:15 <PthariensFlame> ?
06:48:49 <`nand`> but closure and totality are pretty much equivalent, just formulated in different ways
06:49:25 <`nand`> it actually gets a meaning in a haskell context though, prevents you from writing mappend = undefined
06:49:27 <PthariensFlame> I thought totality was a specific instance of closure.
06:49:33 <neutrino_> in set theory, bottom is not an element of any set, right?
06:50:25 <PthariensFlame> Like, total = closed over the class of non-bottom values
06:50:49 <neutrino_> total function means that if one of the arguments is bottom, the function is bottom
06:51:31 <PthariensFlame> But you could also be closed over the class of all Haskell values, including bottom
06:51:44 <PthariensFlame> which wouldn't be total at all
06:51:51 <PthariensFlame> Or am I getting his
06:51:56 <PthariensFlame> *this
06:52:00 <PthariensFlame> All wrong?
06:52:51 <neutrino_> functions in haskell don't have to be total
06:53:09 <neutrino_> that's one of the defining properties of haskell, as far as i understand it
06:53:13 <PthariensFlame> Right.
06:53:39 <PthariensFlame> But they have to be closed over the class of all possible
06:53:46 <PthariensFlame> Haskell values, by definition, yes?
06:54:13 <neutrino_> define "closed"
06:54:49 <fmap> I guess I can just believe that this unsafeCoerce magic somehow constructs `Reifies' instances :[
06:54:53 <PthariensFlame> Does not escape from the enclosing set or class.
06:55:10 <neutrino_> that is not a rigorous definition
06:55:16 <neutrino_> you won't be able to figure out anything here
06:55:22 <`nand`> fmap: think about how instances are passed in the GHC implementation
06:55:28 <PthariensFlame> Ok, what is?
06:55:30 <`nand`> Foo a => a -> b compiles to Foo a -> a -> b
06:56:59 <fmap> `nand`: and we pass `a' as `Foo a'?
06:57:36 <PthariensFlame> ...
06:58:00 <edwardk> fmap: basically i coerce a function of the form (a -> b -> a) into   (Reifies s a => p s -> a)    a becomes Reifies s a, p s becomes b  and the result is 'a'
06:58:07 <`nand`> well, less directly, we pass ‘Foo a’. Then comes the next step; which is that dictionaries with just one value are treated like newtypes; with no extra representation sugar
06:58:13 <abc> Hey
06:58:13 <edwardk> i pass it 'const'
06:58:20 <edwardk> and then i pass that 'a'
06:58:31 <`nand`> so we can coerce ‘Proxy s -> a’ to ‘Reifies s a’ because Reifies s a just contains ‘Proxy s -> a’
06:58:41 <neutrino_> pthariensflame needs to get some patience :)
06:58:53 <neutrino_> actually, what IS a good definition of closed function in haskell terms?
06:58:59 <edwardk> er rather
06:59:13 <neutrino_> i guess it's meaningless? i think all functions are closed, right? is a function that emits bottom for non-bottom closed?
06:59:14 <edwardk> i pass the partial application of const as Reifies s a
06:59:53 <edwardk> class Reifies s a where refies :: p s -> a    is represented by a function (p s -> a)
07:00:21 <edwardk> so i coerce the partial application of const to a value 'a' as that function
07:02:19 <edwardk> git diff
07:02:25 <edwardk> er woops
07:08:54 <tgeeky_> edwardk: 404 not found
07:09:00 <edwardk> tgeeky_: ?
07:09:09 <tgeeky_> edwardk: re: git diff
07:09:13 <edwardk> hah
07:09:21 <tgeeky_> edwardk: merry christmas or other holiday thing! <3
07:09:28 <edwardk> likewise
07:09:43 <ciaranm> may all your functors be pointed
07:09:57 <edwardk> ciaranm: man you don't know me very well ;)
07:11:38 <shachaf> Pointed functors are edwardk's second-greatest enemy.
07:11:43 <edwardk> As an atheist, I don't believe in pointed functors. I think shachaf is a believer though.
07:11:51 <monadicity> any examples of adjunction based programming?
07:12:00 <shachaf> edwardk: Hey, I believe in affine traversals, just like you.
07:12:11 <shachaf> It's just that I'm willing to accept the consequences rather than live in denial.
07:12:36 <edwardk> just because we can see their effects, doesn't mean there isn't some other explanation than "some pointed functor did it" ;)
07:15:44 <monadicity> wtf is a pointed functor
07:16:14 <ciaranm> a crippled monad
07:16:49 <portnov> another question: is it safe to use monad transformers over STM monad? Say, ErrorT StateT STM () ?
07:17:18 <shachaf> Yep.
07:17:33 <johnw> monadicity: http://ncatlab.org/nlab/show/pointed+endofunctor
07:18:02 <shachaf> johnw: I'm sure that'll help monadicity terribly.
07:18:09 <johnw> it means there is a natural transformation I -> F some endofunctor F
07:18:25 <edwardk> in practice this means class Pointed f where point :: a -> f a
07:18:47 <edwardk> i don't make that a pointed _functor_ per se, because the only law connecting that to fmap is a free theorem in haskell
07:19:01 <edwardk> so you can have pointed data for types that aren't able to be a haskell Functor.
07:19:06 <edwardk> consider 'Set'
07:19:17 <edwardk> a -> Set a works well even though you can't make an instance of Functor for Set.
07:19:41 <edwardk> portnov: yes, it works fine
07:19:51 <monadicity> cool
07:19:53 <portnov> edwardk: nice.
07:20:15 <edwardk> Codensity STM is particularly useful
07:20:49 <edwardk> it lets you back up and retry over a wider scope
07:22:53 <monadicity> (a -> b) -> (f a -> f b)?
07:43:17 <Industrial> I don't understand this program; https://gist.github.com/8d6fbdeb42a6b452e1dc where does lastName come from?
07:43:45 <Industrial> oh, right it returns b
07:43:53 <Industrial> (maybe)
07:45:03 <shachaf> > case Just 5 of Just x -> x
07:45:05 <lambdabot>   5
07:46:22 <hoknamahn> hi guys. I have a GADT Vector a where a is constrained to Floating. How can i declare a type class in the way that functions of that class know what type of data that Vector contains?
07:48:22 <lolcathost> Is there any way to read ByteStrings from a Handle?
07:48:31 <dylukes> class Whatever (Vector a) where; foo :: Vector a -> a; end would work, no?
07:50:01 <dylukes> lolcathost: You can use the hGet function.
07:50:14 <lolcathost> @hoogle hGet
07:50:15 <lambdabot> System.IO hGetBuf :: Handle -> Ptr a -> Int -> IO Int
07:50:15 <lambdabot> GHC.IO.Handle hGetBuf :: Handle -> Ptr a -> Int -> IO Int
07:50:15 <lambdabot> System.IO hGetBuffering :: Handle -> IO BufferMode
07:50:15 <dylukes> It's in Data.Bytestring
07:50:21 <lolcathost> dylukes: Ahhh!
07:50:31 <dylukes> @hoogle Data.Bytestring.hGet
07:50:31 <lambdabot> Data.ByteString.Lazy hGet :: Handle -> Int -> IO ByteString
07:50:32 <lambdabot> Data.ByteString.Lazy.Char8 hGet :: Handle -> Int -> IO ByteString
07:50:32 <lambdabot> Data.ByteString hGet :: Handle -> Int -> IO ByteString
07:50:34 <lolcathost> dylukes: I was expecting it to be in System.IO. MY bad.
07:50:47 <dylukes> There's also
07:51:00 <dylukes> @hoogle Data.ByteString.hGetNonBlocking
07:51:00 <lambdabot> Data.ByteString hGetNonBlocking :: Handle -> Int -> IO ByteString
07:51:00 <lambdabot> Data.ByteString.Char8 hGetNonBlocking :: Handle -> Int -> IO ByteString
07:51:00 <lambdabot> Data.ByteString.Lazy hGetNonBlocking :: Handle -> Int -> IO ByteString
07:51:42 <neutrino_> hi dylukes
07:51:43 <lolcathost> dylukes: ty ty
07:51:53 <neutrino_> have you been gone?
07:52:10 <dylukes> gone where?
07:52:19 <neutrino_> i don't know!
07:52:29 <neutrino_> i haven't seen you in here for some time now.
07:55:46 <lolcathost> Are iteratees fundamentally incompatible with nonsequential reading of files/streams?
07:56:24 <johnw> that would sort of imply something other than iteration, yes ;)
07:56:38 <Eduard_Munteanu> lolcathost: I think non-trivial r/w patterns were the point of iteratees
07:57:04 <Eduard_Munteanu> If you're doing sequential r/w, lazy I/O is mostly fine.
08:04:53 <hoknamahn> dylukes: this is what i want http://pastebin.com/xAsGfeX2
08:05:10 <hoknamahn> i understand why it does not work but i have no idea how to fix it
08:06:32 <hoknamahn> all what i need is x to be of the same type as a vector component
08:06:46 <dylukes> hm, not sure atm, but there's a way somewhere
08:07:00 <dylukes> I'm a bit out of practice at the moment ^^;
08:11:12 <fmap> hoknamahn: `class Floating b => Vector a b | a -> b where' and then `instance Floating a => Vector (Vector2 a) a where'?
08:11:15 <hpaste> johnw pasted “contravariant.hs” at http://hpaste.org/79797
08:11:34 <hoknamahn> fmap functional dependency?
08:11:35 <fmap> or I don't understand what you want :]
08:11:42 <fmap> hoknamahn: yes
08:11:43 <mreh> shame there's no `catchLeft` in this either package
08:11:54 <hoknamahn> fmap: let me try it
08:12:06 <fmap> hoknamahn: you will probably need FlexibleInstances too, but that's fine
08:12:14 <mreh> it is just "catchLeft f = either f id" though
08:13:00 <mreh> :t either f (return . id)
08:13:02 <lambdabot> (Monad m, Show a, FromExpr (m a1)) => Either a a1 -> m a1
08:13:18 <fmap> hoknamahn: functional dependencies aren't strictly needed but otherwise this class will be highly unusable
08:14:27 <mreh> edwardk: could you put a neat way of catching errors in your either package?
08:14:35 <mreh> unless there already is one
08:14:44 <edwardk> mreh: have you seen 'errors'?
08:14:45 <mreh> using "either" is always a bit baggy
08:14:56 <mreh> no, I haven't
08:15:09 <edwardk> thats built on either and gives you everything and the kitchen sink
08:15:21 <mreh> cool
08:15:37 <edwardk> in lens 3.8 i'll have some neat stuff for Control.Monad.Error using prisms
08:15:57 <mreh> edwardk, thanks for the tip
08:24:57 <BMeph> edwardk: Do you have a blarticle on prisms, yet? :)
08:25:03 <edwardk> not yet
08:25:08 <edwardk> :t _left
08:25:10 <lambdabot> (Applicative f, Prismatic k) => k (a -> f b) (Either a c -> f (Either b c))
08:25:16 <edwardk> _left is a prism
08:25:24 <edwardk> you can use it like a traversal of the left side of an Either
08:25:34 <edwardk> or you can use it to generate an Either. like a smart constructor
08:25:42 <edwardk> > "hello"^.remit _left
08:25:44 <lambdabot>   Left "hello"
08:26:04 <edwardk> 'traversing the 'left side of the either' can be viewed as a form of using it for pattern matching
08:26:16 <edwardk> prisms are to sums what lenses are to products
08:26:20 <edwardk> thats all there is to them
08:32:10 <sorbo_> I'm new to Haskell. Do all functions need to have type signatures? Or is it just good practice/for clarity?
08:32:21 <johnw> sorbo_: it's extremely good practice
08:32:32 <johnw> sorbo_: but no, all functions do not need type signatures
08:32:45 <sorbo_> johnw: Thanks!
08:32:48 <johnw> in general, top-level functions should always have them, whereas local functions (in a 'where' block) rarely do
08:32:59 <sorbo_> johnw: I'll keep doing it. Good habits early on, and all that. Plus it helps organize my thoughts
08:33:17 <johnw> just keep in mind that the more signatures you have, the better and more accurate type errors will be
08:33:36 <sorbo_> For sure
08:33:39 <johnw> yeah, it's a great habit
08:33:51 <johnw> i have my editor highlight functions without type signatures in blue, so that I never have them
08:34:00 <hpaste> portnov pasted “STM recursive calls” at http://hpaste.org/79798
08:34:11 <portnov> next question
08:34:54 <portnov> in http://hpaste.org/79798, will it deadlock on recursive call?
08:41:39 <beaky> hello
08:41:59 <beaky> whny are monads considered mechanisms for flow of control?
08:42:17 <beaky> so much that they live in Control.Monad ?
08:42:44 <ciaranm> beaky: read "the essence of functional programming"
08:43:00 <Jafet> I always thought that Control.Monad was there for you to maintain control over your monads.
08:43:15 <johnw> Monads Gone Wild
08:43:25 <beaky> ah
08:43:55 <beaky> is Control.Monad part of Prelude?
08:43:58 <Jafet> Binders full of monads
08:43:59 <parcs> i always thought the Control and Data and the other base hierarchies are arbitrary and disingenuous
08:44:02 <beaky> or is it some GHC extension?
08:44:08 * ciaranm looks at beaky 
08:44:12 <johnw> beaky: I think you mean, is it part of the core libraries
08:44:18 <beaky> ah right
08:44:34 <johnw> yes, it's in 'base'
08:44:44 <beaky> I want to use things like forM_ and stuff for my roguelike
08:44:55 <johnw> maybe I recommend Foldable to you
08:45:09 <beaky> ah
08:45:12 <johnw> it's funny that my fingers type things other than what I'm thinking
08:46:50 <beaky> monads are very cool
08:46:56 <johnw> they sure are
08:47:51 <hoknamahn> hey fmap: in this bit 'instance Floating a => Vector (Vector2 a) a where' a has to be a rigid type right?
08:48:05 <hoknamahn> looks like compiler just doesn't like a type variable
08:49:27 <johnw> is there a way to create a alias for a group of constraints?
08:49:35 <DrChaos> would somebody please tell me why lists don't inherit the Eq typeclass?
08:49:40 <johnw> I find myself repeating this often: (MonadResource m, MonadBaseControl IO m, Failure C.HttpException m) => ...
08:49:41 <hpaste> beaky pasted “Monads ftw” at http://hpaste.org/79799
08:50:31 <johnw> beaky: there's a better way to do that
08:50:40 <beaky> there is?
08:50:47 <johnw> split your function into two parts: getInput and processInput
08:50:50 <beaky> ah
08:50:52 <johnw> move the pure logic out of the monad
08:51:16 <DrChaos> I try evaluating this expression, but it says "No instance for (Eq a) arising from a use of `==' in the expression (x : xs) == (reverse' (x : xs))
08:51:17 <beaky> I thought about that but what if processInput doesn't match a character?
08:51:29 <parcs> johnw: sure, with ConstraintKinds you can do 'type MyAlias m = (MonadResource m, ...)'
08:51:31 <johnw> have it return Maybe Input
08:51:33 <beaky> ah
08:51:42 <johnw> parcs: do I need 7.6 for that?
08:51:45 <beaky> so the Maybe Monad is alright to use?
08:51:51 <parcs> johnw: 7.4 i think
08:51:53 <DrChaos> beaky -> you emit Nothing in the case that it doesn't match a character
08:51:55 <johnw> beaky: why wouldn't it be?
08:52:33 <johnw> parcs: yeah, works great in 7.4.2, thanks!
08:52:58 <parcs> johnw: by the way did you manage to fix the stack overflow thing?
08:53:17 <johnw> parcs: no, never did
08:53:32 <parcs> aw
08:55:53 <Jello_Raptor> hmm, is there someway to read a file in ghci, something like "(fileRead 'input.txt') >>= (interact doStuff)"
08:56:04 <hpaste> fmap pasted “for hoknamahn” at http://hpaste.org/79800
08:56:07 <mreh> :t readFile
08:56:08 <lambdabot> FilePath -> IO String
08:56:15 <fmap> hoknamahn: ^ that should compile
08:56:32 <mreh> Jello_Raptor, like that
08:56:48 <hoknamahn> hi fmap yeah i figured that i need flexible instances. thanks a lot
09:05:38 <hpaste> “http://www.facebookcreditsgenerator.me” pasted “http://www.facebookcreditsgenerator.me” at http://hpaste.org/79801
09:05:59 <hpaste> “http://www.facebookcreditsgenerator.me” pasted “http://www.facebookcreditsgenerator.me” at http://hpaste.org/79802
09:06:25 <parcs> sounds legit
09:09:43 <Jafet> YOUR FRIENDS NEED MORE VESPENE GAS
09:10:24 <Eduard_Munteanu> What's a good Haskell lib for image processing / analysis?
09:10:50 <Eduard_Munteanu> Say I want to get a HSV representation of an image, or stuff like that.
09:11:01 <Eduard_Munteanu> Maybe downscale as well.
09:12:24 <Eduard_Munteanu> I'm trying some funny stuff, namely implementing dynamic contrast in software, in case you're wondering.
09:13:27 <Eduard_Munteanu> So I'm thinking of downsampling the image with linear interpolation, and getting some luminance value for every pixel.
09:13:35 <Jafet> http://gamesetwatch.com/110620-HDR-in-video-games.jpg
09:13:50 <Eduard_Munteanu> And perhaps prioritize pixels in the center of the screen.
09:15:34 <Eduard_Munteanu> Jafet: yep, but AFAIH, LCD dynamic contrast algos are notoriously bad
09:16:24 <Jafet> Well, the LCD can do something you can't. It can turn the backlighting off.
09:16:43 <Eduard_Munteanu> Jafet: I can do that too
09:17:06 <Eduard_Munteanu> Jafet: well, my LCD can't turn it completely off, but it can manipulate the brightness.
09:17:13 <Eduard_Munteanu> I can do that through ddccontrol.
09:17:59 <Eduard_Munteanu> I'm not altering the image per se.
09:18:30 <Eduard_Munteanu> Just controlling the backlight brightness, pretty much what the monitor does.
09:25:26 <Jafet> You probably need to borrow from a C library
09:26:35 <Eduard_Munteanu> :(
09:26:39 <Jafet> Unless correctness is irrelevant
09:26:44 <Jafet> Actually, it probably is
09:27:16 <Eduard_Munteanu> It is kinda irrelevant, I don't need much precision.
09:30:42 <beaky> @src fromMaybe
09:30:43 <lambdabot> fromMaybe d x = case x of {Nothing -> d;Just v  -> v}
09:30:49 <beaky> oh
09:31:09 <Jafet> @djinn a -> Maybe a -> a
09:31:10 <lambdabot> f a b =
09:31:10 <lambdabot>     case b of
09:31:10 <lambdabot>     Nothing -> a
09:31:10 <lambdabot>     Just c -> c
09:31:26 <beaky> wow
09:31:55 <Jafet> I didn't know that layout was allowed
09:32:51 <beaky> let f a b = case b of {Nothing -> a; Just c -> c} in f "foo" (Just "bar")
09:32:58 <beaky> >t let f a b = case b of {Nothing -> a; Just c -> c} in f "foo" (Just "bar")
09:32:59 <Phlogistique> @djinn Maybe a -> Maybe b -> Maybe (a,b)
09:32:59 <lambdabot> f a b =
09:32:59 <lambdabot>     case a of
09:32:59 <lambdabot>     Nothing -> Nothing
09:32:59 <lambdabot>     Just c -> case b of
09:32:59 <lambdabot>               Nothing -> Nothing
09:33:01 <lambdabot>               Just d -> Just (c, d)
09:33:09 <Jello_Raptor> hmm, is there a infinite (pseudo/pretend infinite?) random access array type? with O(1) lookup, or should I just use a map?
09:33:50 <Jafet> @hoogle HashTable
09:33:50 <lambdabot> Data.HashTable module Data.HashTable
09:33:50 <lambdabot> Data.HashTable data HashTable key val
09:33:50 <lambdabot> package hashtables
09:34:30 <Jafet> Integer indices. Sounds fast
09:34:31 <siracusa> @djinn Maybe a -> Maybe a -> a
09:34:32 <lambdabot> -- f cannot be realized.
09:34:42 <siracusa> @djinn a -> Maybe a -> Maybe a -> a
09:34:43 <lambdabot> f a b c =
09:34:43 <lambdabot>     case b of
09:34:43 <lambdabot>     Nothing -> case c of
09:34:43 <lambdabot>                Nothing -> a
09:34:43 <lambdabot>                Just d -> d
09:34:45 <lambdabot>     Just e -> e
09:34:46 <Jello_Raptor> Jafet: err, sorry i tend to use Hash, Map, and Dictionary interchangably when talking about data structures
09:34:59 <johnw> what about Data.IntMap?
09:35:11 <johnw> it's not O(1) though
09:35:18 <typoclass> Jello_Raptor: i'd try the simplest solution first (possibly Data.Map). when profiling shows that it's a bottleneck, you can always get fancier
09:35:22 <Jafet> Well, you can pretend one of two things
09:35:26 <Jafet> You can pretend it is infinite
09:35:30 <Jafet> Or you can pretend it is O(1)
09:35:49 * Jello_Raptor nods
09:35:55 <Martty_> is ther a data structure that is O(1) everything
09:36:07 <otters> no
09:36:12 <Martty_> not even in theory?
09:36:15 <Jafet> My data structure implements every operation using only O(1) operations.
09:36:25 <Jello_Raptor> Jafet: har har har
09:36:32 <Jello_Raptor> Martty_: it's called a wizard
09:36:41 <Martty_> abracadabra
09:37:11 <Jafet> Martty: is there a train whose length is 5
09:46:37 <jmcarthur> Martty_: data Foo a = Foo a
09:46:58 <jmcarthur> Martty_: it's always constant time to access or update the 'a'
09:47:44 <beaky> if I want a fixed-size map or table, is it better to use a function?
09:47:50 <beaky> rather than Data.Map?
09:47:58 <jmcarthur> it depends
09:48:29 <DrChaos> err...is there a 64 bit version of the Haskell platform for windows?
09:50:14 <typoclass> Martty_: you could e.g. make inserting quick ("just put the stuff any old place"), but then later you'll have to look in a lot of places to find the desired thing. or as another example, you could make retrieving quick because the data is all sorted perfectly, but then when inserting something you're going to spend time keeping it all sorted, moving stuff around, etc.
09:51:39 <typoclass> Martty_: so very roughly speaking, you're either going to spend time when inserting or when retrieving. these kinds of tradeoffs are what you have with any data structure
09:58:20 <johnw> DrChaos: GHC 7.6 is the first version to officially support 64-bit Windows, and there has yet to be a haskell platform release made with that version of GHC
10:03:52 <Yerzhan> hi everyone!
10:03:56 <johnw> hello!
10:04:01 <Eduard_Munteanu> Hi.
10:04:08 <Yerzhan> hi!
10:04:13 <Yerzhan> good tutorial
10:04:24 <Yerzhan> going though it now )
10:04:26 <Eduard_Munteanu> tryhaskell?
10:04:31 <Yerzhan> yeah
10:05:21 <Yerzhan> could someone answer what is the advantage of the functional programming language?
10:05:46 <johnw> it's funny how often we get asked that
10:06:00 <Yerzhan> )
10:06:14 <johnw> FP is easier to think about, once you learn how to think that way
10:06:29 <parcs> tautology?
10:06:38 <johnw> not really
10:06:45 <johnw> once you learn how to ride a bike, riding a bike is faster
10:06:52 <johnw> if you don't know how to ride a bike, walking is faster
10:07:17 <jmcarthur> Yerzhan: different people will claim different advantages of FP depending on what they mean by FP in the first place
10:08:20 <jmcarthur> "more composeable" "more concise" "easier to reason about" "easier to parallelize or use with concurrency" etc.
10:08:23 <typoclass> i'd back the claim that learning a functional language (haskell in particular) makes you a better programmer, no matter what language you end up using
10:09:13 <jmcarthur> or it makes you worse. e.g. i burn out more quickly with other languages because i know i could be using something better or at least more fun
10:10:08 <Yerzhan> is it faster?
10:10:11 <Yarou> Yerzhan: one advantage is that it's formally provable (if you care about that sort of thing)
10:10:12 <Yerzhan> or not?
10:10:23 <Eduard_Munteanu> @where shootout
10:10:23 <lambdabot> http://shootout.alioth.debian.org/
10:10:37 <Eduard_Munteanu> In response to "is it faster?". ^^
10:10:54 <Eduard_Munteanu> @where faq
10:10:54 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
10:11:26 <typoclass> jmcarthur: not sure if that remark was tongue-in-cheek, but that'd be like saying "no, don't show them the hammer, because when they go back to pounding nails in with their shoe, they'll be all frustrated"
10:11:48 <jmcarthur> typoclass: it wasn't meant to be discouragement
10:11:49 <Clint> sounds right to me
10:12:11 <jmcarthur> typoclass: using a hammer doesn't make you better at using a frozen banana
10:12:51 <jix> jmcarthur: but if you used an unfrozen banana having seen a hammer might give you the idea that turning the banana into something hard is a good idea
10:13:07 <typoclass> jix: well put
10:14:10 <jmcarthur> jix: if only i hadn't used such a manipulable example :P
10:14:47 <edwardk> hah, it looks like i can do path-compression to make faster zippers that can deal with more kinds of infinities
10:15:04 <jmcarthur> in lens?
10:15:10 <edwardk> yeah
10:15:23 <typoclass> edwardk: that's exactly the kind of thing edwardk would say
10:15:37 <edwardk> https://github.com/ekmett/lens/blob/master/src/Control/Lens/Compression.hs is the start of it
10:15:44 <jmcarthur> at least i understood "faster zippers"
10:15:49 <jmcarthur> :)
10:16:04 <jmcarthur> pretty sure i know what is meant by path compression
10:16:13 <jmcarthur> not sure of the "more kinds of infinities"
10:16:13 <edwardk> basically we can abuse the fact that traversing the same thing multiple times will use exactly the same parenthesization
10:16:43 <edwardk> so lets build up a data type, as a free magma while we traverse it
10:16:50 <edwardk> just tracking where we went left or right
10:17:04 <catsbydlo> oh shit, free magmas
10:17:05 <edwardk> but this is going to wind up with a bunch of mempty `mappend` ….  nodes wherever you use fmap
10:17:22 <catsbydlo> a free something is something that arises naturally from the laws, isn't it?
10:17:38 <edwardk> so we compress those away by counting how many times we wasted our time mappending something that was mempty
10:17:44 <ciaranm> it's a thing that satisfies the laws, and nothing else
10:18:25 <edwardk> then when we play it back we just keep giving each branch the entire tree until we get down to the depth where the split occurred then we split the environment there
10:18:26 <ciaranm> the fact that such a thing tends to exist comes down to various flavours of the adjoint functor theorem
10:18:56 <edwardk> effectively compressed traverse.traverse = traverse
10:19:03 <catsbydlo> do magmas even have mempty?
10:19:10 <edwardk> catsbydlo: its a unital free magma
10:19:17 <catsbydlo> assoc + mempty
10:19:28 <jmcarthur> not assoc
10:19:30 <edwardk> and here i'm using path compression to smash units
10:19:32 <edwardk> non-assoc
10:19:32 <Yerzhan> Thank you for replies about FP advantages!
10:19:33 <edwardk> just mempty
10:19:51 <catsbydlo> oh right, magmas were the ones with just a binary operation that goes back into the set
10:19:56 <catsbydlo> unital adds mempty
10:20:04 <catsbydlo> and if it was assoc, we'd have a monoid
10:20:11 <jmcarthur> right
10:20:19 <jmcarthur> and assoc without mempty is a semigroup
10:20:44 <edwardk> so i take my unital magma, lie to claim its a monoid, and get a recording of the parenthesization used by traverse of its aps
10:21:00 <edwardk> then i can replay modified data into the original structure
10:21:16 <edwardk> and i have no 'Ap' nodes in the tree that don't have leaves in them
10:21:38 <edwardk> its a patricia trie, where i don't have to worry about edits
10:21:52 <edwardk> so i don't have to store whether i went left or right along each individual layer above me
10:21:52 <jmcarthur> that lie makes me sad
10:22:06 <edwardk> jmcarthur: its for a good cause
10:22:10 <catsbydlo> data M = E | J M M
10:22:14 <jmcarthur> i see the trick, but it still makes me sad
10:22:26 <edwardk> it'll let us do things like zip around inside of a Map to target keys in log time
10:22:35 <edwardk> because they have a real foldMap
10:22:54 <edwardk> so i'll get a 'mirror' of the intmap tree structure in my magma
10:23:25 <edwardk> if i can write the containers patch to make a real foldMap for sequence you can do the same thing to data.sequence
10:24:03 <edwardk> having zippers that just did the right thing when it came to taking advantage of tree structures like that with no end-user support other than foldMap/foldMapWithKey  is pretty sweet ;)
10:24:26 <edwardk> anyways i need the actual parenthesization because re-associating exposes me to infinities
10:25:37 <edwardk> so now all i need is the derivative of my path compressed tree, and we can do zipping inside it
10:44:05 <edwardk> @ask dcoutts With libraryConfig ripped out of Distribution.Simple.LocalBuildInfo how does one build a Setup.lhs that accesses it and that is compatible with Cabal 1.17 but also with earlier Cabal versions? I don't know if I'm given any cpp defines for Setup.lhs to hack around this change. =/
10:44:06 <lambdabot> Consider it noted.
10:44:50 <edwardk> @tell dcoutts https://github.com/haskell/cabal/commit/321815bdb27a341ac94ccb52e498767e868afb03#L3L115 (in particular)
10:44:50 <lambdabot> Consider it noted.
10:55:45 <hpaste> lolcathost pasted “Isn't this ugly?” at http://hpaste.org/79803
10:56:33 <Taneb> How well does (<**>) chain?
10:56:34 <lolcathost> Could anyone possibly help me make this code less ugly? I particularly dislike the lambdas there.
10:56:57 <Taneb> > [1,2] <**> [3,4] <**> [(+),(*)]
10:56:59 <lambdabot>   Ambiguous occurrence `<**>'
10:56:59 <lambdabot>  It could refer to either `Control.Applicative....
10:57:20 <Taneb> > [1,2] Control.Applicative.<**> [3,4] Control.Applicative.<**> [(+),(*)]
10:57:21 <lambdabot>   Could not deduce (GHC.Num.Num (a0 -> a))
10:57:22 <lambdabot>    arising from the ambiguity chec...
10:57:31 <Taneb> Not great, huh
11:03:04 <Yerzhan> Can explain what is implication introduction and implication elimination and how to express it in haskell ?
11:03:39 <Eelis> Yerzhan: implication means function types. you make/introduce a function with a lambda. implication elimination means function application
11:04:39 <Eelis> you should look at the typing rules for lambdas and function application
11:05:07 <Yerzhan> Eelis: didn't get properly. So implication is a function. it is ok. By implication introduction we introduce functions. How? and reason?
11:05:43 <Eelis> Yerzhan: well, consider  \(x,y) -> (y,x)  of type  (a,b)->(b,a)  . if we read pairing as conjunction this "proves" that (a and b) implies (b and a)
11:06:17 <osfameron> @pl write str = FileT $ \h -> hPut h str
11:06:17 <lambdabot> write = FileT . flip hPut
11:06:20 <osfameron> lolcathost: ^^ ?
11:06:47 <osfameron> the first one ends up with two flips, which I think is harder to understand than the lambda
11:07:05 <Hail_Spacecake> I have a custom Date ADT
11:07:15 <Hail_Spacecake> and I'd like to parse text strings into Date
11:07:31 <lolcathost> osfameron: Oh.
11:07:53 <Hail_Spacecake> right now I'm just having Date derive Read and using read, which works, but only if I type dates exactly the way that I formatted them when I made the type
11:07:56 <lolcathost> osfameron: ty
11:08:03 <Eduard_Munteanu> Yerzhan: are you familiar with the Curry-Howard isomorphism?
11:08:13 <Hail_Spacecake> so I'm wondering what the proper way to do this is
11:08:40 <Hail_Spacecake> should I make a new read function specifically, or should I just make any random function String -> Date?
11:08:42 <Yerzhan> Eduard_Munteanu: a bit
11:09:01 <Yerzhan> Eduard_Munteanu: didn't understand it fully
11:09:09 <Hail_Spacecake> like, does it matter if I make the function part of the Read typeclass at all, I guess I'm saying
11:09:31 <Eduard_Munteanu> Yerzhan: well, that's what this is about. It relates logical formulas to types.
11:10:16 <Eduard_Munteanu> Yerzhan: for instance, a very simple example is Haskell's  id :: a -> a. You can interpret that as "forall P. P -> P" in logic.
11:10:38 <Yerzhan> Eduard_Munteanu: ok
11:11:20 <Eduard_Munteanu> Types correspond to propositions. A proposition is true if the corresponding type is inhabited.
11:11:22 <Yerzhan> Eduard_Munteanu: implication introduction maybe some lines make it clear to understand?
11:11:53 <Hail_Spacecake> what does it mean for a type to be inhabited?
11:12:17 <Eduard_Munteanu> Hail_Spacecake: a type is inhabited if you can provide a value of that type.
11:12:29 <Eduard_Munteanu> Hail_Spacecake: for instance id :: a -> a; id a = a
11:13:03 <Hail_Spacecake> aren't all types that have a value constructor inhabited, then?
11:13:19 <Hail_Spacecake> like, what's a type that's *not* inhabited?
11:13:48 <Yerzhan> Eduard_Munteanu: Types correspond to propositions. Examples please.
11:14:11 <Eduard_Munteanu> Hail_Spacecake: in Haskell all types are inhabited, but we normally disregard those less well-behaved values (undefineds)
11:14:22 <stepkut> what is the easiest way to detect keydown/keyup sequences in Linux+Haskell? I want to read the arrow keys to control a robot, so I need to know key up as well.. but would prefer to not have to resort to X/SDL/etc
11:14:52 <roconnor> Hail_Spacecake: ((a -> b) -> a) -> a
11:15:00 <roconnor> @djinn ((a -> b) -> a) -> a
11:15:00 <lambdabot> -- f cannot be realized.
11:15:20 <Eduard_Munteanu> Yerzhan: a simple one is a -> a, which reads "forall P. P implies P" in logic. Another one is (a, b), which reads "a and b" in logic.
11:15:25 * stepkut ponders ncurses
11:16:13 <Hail_Spacecake> what is the domain of the logical proposition when we're talking about types? the function whose signature they are?
11:16:18 <Eduard_Munteanu> Hail_Spacecake: but stuff like   data Void   shouldn't be inhabited if we're doing logic stuff.
11:16:31 <Yerzhan> Eduard_Munteanu: where are types? Type means data types?
11:16:55 <Eduard_Munteanu> Yerzhan: all values have types
11:17:37 <Eduard_Munteanu> Hail_Spacecake: if you have a value, its type is the proposition and the definition itself is the proof
11:18:07 <Hail_Spacecake> ah okay
11:18:07 <Eduard_Munteanu> Yerzhan: not only data types as in 'data' stuff, but also function types etc.
11:18:11 <Hail_Spacecake> I've seen that before
11:18:42 <Yerzhan> Eduard_Munteanu: in haskell every values have types. I agree. proposition correnponds to some type. How to understand this correnpondence
11:20:42 <ktosiek> is there some method to use big monad stacks without lots of lifting?
11:20:50 <Eduard_Munteanu> Yerzhan: what are you having difficulties with?
11:21:07 <ktosiek> I mean monad transformers stacks
11:21:23 <Nereid> I wish all the standard IO actions had types MonadIO m => ... -> m ...
11:21:27 <Eduard_Munteanu> ktosiek: for Reader, Writer and similar stuff, there are typeclasses which do the lifting for you, namely MonadReader etc.
11:21:31 <Yerzhan> Eduard_Munteanu: ), just making some tasks and don't understand how to express implication introduction and similar stuf in haskell
11:22:04 <ktosiek> Eduard_Munteanu: and for custom transformers?
11:22:25 <ktosiek> oh, and what about using the same transformer multiple times in a stack?
11:22:43 <hpaste> jaspervdj pasted “Hakyll + clay” at http://hpaste.org/79804
11:22:44 <Eduard_Munteanu> ktosiek: well, in that case it won't do
11:23:29 <Eduard_Munteanu> Yerzhan: ok, what are the logic formulas you're looking at?
11:23:45 <otters> hscolour version >=1.8 is required but it could not be found when I'm installing haskell platform from homebrew.
11:23:49 <Eduard_Munteanu> In logic, not Haskell.
11:23:58 <otters> I have hscolour in /usr/local/bin and it's version 1.20.
11:24:02 <otters> How do I fix this
11:24:30 <Eduard_Munteanu> otters: what's it doing in /usr/local/ ?
11:24:40 <otters> oh I dunno I just put it there
11:24:46 <otters> but putting it in /usr/bin solves my problem
11:25:17 <Yerzhan> Eduard_Munteanu: any examples for conjunction introduction, conjunction elimination
11:25:42 <Yerzhan> Eduard_Munteanu: using haskell
11:26:19 <catsbydlo> Yerzhan: what's conjunction introduction?
11:26:49 <owst_> catsbydlo: given a, b (separately), you can conclude a ^ b
11:26:59 <catsbydlo> what is ^?
11:27:01 <owst_> where ^ is meant to be AND
11:27:06 <catsbydlo> oh, &
11:27:08 <owst_> the logical connective
11:27:12 <catsbydlo> a -> b -> (a, b)
11:27:50 <simpson> Yerzhan: You've already heard the "Haskell doesn't enforce totality" spiel, right?
11:28:57 <hpaste> jaspervdj annotated “Hakyll + clay” with “Hakyll + clay (annotation)” at http://hpaste.org/79804#a79805
11:28:59 <Yerzhan> catsbydlo: conjunction introduction is like the pair constructor in haskell (t,u)
11:29:06 <Yerzhan> simpson: didn't get
11:29:12 <Yerzhan> simpson: didn't heard
11:29:16 <_wsad_> need help installing and configuring xmonad on arch linux x64
11:29:37 <_wsad_> withoutany DE involved
11:29:41 <simpson> Yerzhan: _|_ inhabits all types in Haskell.
11:30:02 <simpson> Yerzhan: So you don't have any guarantee that a given function is total.
11:30:19 <simpson> Yerzhan: This is not a bad thing, but you have to be aware of it if you're going to be using the type system to describe proofs.
11:30:46 <simpson> :t \_ -> undefined :: a -> b -- for example
11:30:47 <lambdabot> t -> a -> b
11:31:04 <simpson> Oh, ha, forgot how that binds.
11:31:12 <simpson> :t (\_ -> undefined) :: a -> b
11:31:14 <lambdabot> a -> b
11:31:30 <Yerzhan> simpson: mm
11:32:01 <simpson> Yerzhan: But yeah, as long as you expect all proofs of types to be total, and check them yourself, you can express stuff in Haskell.
11:32:24 <neutrino_> what is a good definition of a closed function in haskell terms?
11:32:54 <neutrino_> also, in set theory, is bottom contained in every set? no set? how does that work?
11:33:06 <neutrino_> i guess the question should be "how does set theory represent bottom?"
11:33:16 <Eduard_Munteanu> neutrino_: no, of course not
11:33:20 <monochrom> set theory does not represent or care about bottom
11:33:28 <Eduard_Munteanu> neutrino_: it's just Haskell is unsound logically.
11:34:24 <neutrino_> Eduard_Munteanu: huh?
11:34:39 <neutrino_> :)
11:35:48 <Eduard_Munteanu> neutrino_: if you want 'sound', go to #agda :P
11:35:52 <monochrom> "Haskell is unsound logically" is the same as "1 + (-1) = 0 is unsound logically"
11:36:41 <k00mi> _wsad_: i think there is a channel for xmonad
11:37:38 <monochrom> explanation: "Haskell is unsound logically" means: if apply curry-howard and treat "let x=x in x" as a proof for "every statement is true", you get an unsound logic. Moral: don't apply curry-howard
11:37:41 <NemesisD> anyone use vim to code haskell? i'm looking to figure out some good tools for coding haskell in vim
11:38:05 <NemesisD> i used to have a nice hook into syntactical that did syntax checking but it doesn't seem to play well with cabal-dev and such
11:38:06 <`nand`> I use vim
11:38:15 <`nand`> but I don't have any fancy tricks for it
11:38:17 <`nand`> sorry to disappoint
11:38:23 <NemesisD> damn
11:38:37 <_wsad_> k00mi: thanks will try asking there, anything else i should know
11:38:39 <_wsad_> ?
11:38:40 <monochrom> "1 + (-1) = 0 is unsound logically" means: if you treat 1 as true, -1 also as true, 0 as false, + as "or", you get "true or true = false", which is unsound logically. Moral: don't treat 1, -1 as true, 0 as false, + as "or"
11:39:00 <k00mi> _wsad_: sorry, i don't use xmonad
11:39:39 <monochrom> over-arching moral: don't use the strawman attack, don't make a flawed mapping to conclude that the subject is flawed. the subject is not flawed, your mapping is.
11:39:49 <neutrino_> i have integration of lamdbabot into vim
11:39:52 <neutrino_> and other stuff
11:40:09 <monochrom> haskell is not unsound logically. curry-howard is unsound logically when applied to the wrong things
11:40:30 <`nand`> _wsad_: it might help if you asked a question
11:40:30 <monochrom> that is my words for you curry-howard fanatics
11:40:52 <roconnor> monochrom: burn in hell
11:41:08 <roconnor> hell wroght by fix id
11:41:20 <roconnor> or maybe fix error
11:41:26 <roconnor> > or maybe fix error
11:41:27 <lambdabot>   The function `GHC.List.or' is applied to three arguments,
11:41:27 <lambdabot>  but its type `[G...
11:41:36 <catsbydlo> unsafeCoerce or maybe fix error
11:41:39 <BMeph> monochrom: That's not what Robert Harper says...all the time. ;þ
11:41:41 <_wsad_> `nand`: need help installing and configuring xmonad on arch linux x64
11:42:07 <_wsad_> unable to login after entering creds in lxdm
11:42:14 <_wsad_> 8credentials
11:42:19 <_wsad_> *credentials
11:42:37 <catsbydlo> define "unable to login"
11:43:49 <monochrom> perhaps xmonad hangs
11:44:05 <_wsad_> catsbydlo: nothing happens, the lxdm screen dosent change
11:44:43 <_wsad_> however if i use tty1 login and issue startx, then xmonad starts properly
11:44:49 <catsbydlo> anything in .xsession-errors?
11:44:59 <catsbydlo> probably a path issue
11:45:42 <_wsad_> where is .xsessions-errors located
11:46:01 <_wsad_> Xorg.0.log  ??
11:46:09 <_wsad_> is that what you mean
11:46:10 <_wsad_> ?
11:46:51 <_wsad_> did check Xorg.0.log and there were no errors for X, nothing under (EE)
11:46:52 <`nand`> so it's a lxdm issue and not an xmonad issue? if xmonad on its own works fine
11:47:07 <_wsad_> any idea how to fix it
11:47:26 <`nand`> ask the LXDM folks?
11:47:51 <bytes> so for christmas i've been given a good sum of money, are there any useful haskell resources i could spend it on?
11:47:57 <bytes> or just programming in general
11:48:48 <k00mi> your favorite distro/open source project maybe
11:48:51 <monochrom> I am too afraid to suggest anything, since I don't know what works for you
11:48:57 <Eduard_Munteanu> Buy more RAM to typecheck categories stuff in Agda :P
11:49:17 <simpson> bytes: I'd sing you a parody of "Can't Buy Me Love," but in all seriousness, you can't purchase skill nor wisdom.
11:49:17 <catsbydlo> _wsad_: ~/.xsession-errors
11:49:56 <bytes> i'm not trying to buy skill
11:50:15 <johnw`> bytes: what are you doing with Haskell?
11:50:29 <bytes> just learning it over the break from uni
11:50:57 <johnw`> nice
11:51:23 <johnw`> fortunately, the Haskell experience only requires time and effort, not money
11:51:40 <monochrom> I know. buy a laptop from me. I pre-install the Haskell Platform on it :)
11:51:57 <aristid> monochrom: sounds like a potential huge business
11:53:29 <`nand`> who would want such an outdated copy of GHC, though?
11:53:50 <`nand`> bytes: donate it all to various haskell groups of interest?
11:54:11 <johnw`> or buy a good book on algorithms or something
11:54:21 <`nand`> find the books online, save money
11:54:29 <monochrom> answer: those who want most of hackage packages to actually compile
11:54:54 <`nand`> monochrom: do you have any statistics on package compatibility with GHC versions?
11:54:58 <monochrom> 7.6.1 is too new for most of hackage
11:55:05 <monochrom> no, I don't
11:55:07 <`nand`> I ask because my entire world is compatible with 7.6.1
11:55:13 <aristid> `nand`: those who don't like bytestring packages with a rather devastating bug :P
11:55:22 <johnw`> i had to fight to get my world compatible with 7.6, but it is now
11:55:37 <`nand`> I just need to wait a week or two post-release
11:55:40 <`nand`> needed*
11:56:10 <aristid> i have both 7.4 and 7.6 installed anyways though. but i use 7.4 most of the time
11:57:06 <monochrom> 7.4 is not outdated
11:57:22 <johnw`> aristid: same here
11:57:28 <monochrom> we are not talking about "hi I'm on ubuntu 10.04 LTS, GHC 6.12.1"
11:57:35 <johnw`> i have 7.4.2, 7.6.1, 7.6.2-rc1 and HEAD installed
11:57:50 <aristid> johnw`: which package manager do you use?
11:58:36 <monochrom> I use the --prefix=/usr/local/ghc-7.4.2 package manager
11:59:07 <johnw`> aristid: homebrew, which is equivalent to monochrom's suggestion
11:59:11 <aristid> monochrom: yes, but you hate everything that might make things easier for you :P
11:59:15 <johnw`> and i rely heavily on cabal-dev
11:59:30 <monochrom> no, I don't hate everything that might make things easier for me
11:59:31 <aristid> johnw`: ah i use nix even on os x for the haskell stuff
11:59:43 <monochrom> in fact, --prefix=/usr/local/ghc-7.4.2 makes things easier for me
11:59:44 <aristid> monochrom: ok ok. just most things
11:59:48 <johnw`> i couldn't get nix working well enough, although I did try
12:00:33 <monochrom> you don't know me and you don't know what's easier for me
12:00:50 <aristid> johnw`: the OpenGL stuff does not work, that might be a problem if i wanted to use Peaker's structure editing stuff
12:00:52 <monochrom> but if you say, I hate certain things that makes things harder for you, sure
12:01:17 <monochrom> anyway, I take offense in your judgement on me
12:01:26 <johnw`> monochrom: I think he was just joking with you
12:01:37 <monochrom> yes, but I find it offensive
12:01:50 <aristid> monochrom: sorry for causing offence, then.
12:05:58 <monochrom> perhaps you don't know that I use --prefix= just for a handful of programs: ghc and haskell platform, hol4, polyml (just because of hol4), and mathspad
12:06:45 <monochrom> for all other programs, even pidgin and vlc, I apt-get from ubuntu
12:07:52 <aristid> monochrom: i only vaguely remembered that you had some non-standard opinions on how to install haskell packages.
12:09:05 <monochrom> that would be independent of how to get or install GHC itself
12:09:44 <aristid> monochrom: yes, but it made me think "he likes to do things complicated"
12:10:09 <aristid> now admittedly me using nix isn't entirely what most people would call straightforward either, i guess
12:10:13 <neutrino_> `nand`: you want my lambdabot command shell for vim?
12:12:16 <`nand`> no thanks, I'm fine
12:14:27 <johnw`> what's the recommend way to decode a ByteString containing base64 ASCII into a ByteString?
12:14:49 <johnw`> ah, base64-bytestring
12:15:45 <otters> has anybody else had a problem with -fno-warn-unused-do-bind being ignored by cabal-dev in .cabal files?
12:31:10 <Ralith> bytes containing ASCII-encoded base64-encoded bytes
12:31:18 <Ralith> software is silly sometimes
12:32:51 <otters> these Lens metaphors are getting out of hand
12:32:58 <otters> Control.Lens.Optometrist
12:33:07 <otters> exports numberOne, numberTwo, numberThree, numberFour
12:33:15 <otters> which all have random performance
13:02:57 <johnw`> at least it doesn't ask you to cover your right eye
13:06:07 <monochrom> hahaha
13:07:33 <johnw`> joeyh: how stable is direct mode now?
13:07:51 <neutrino_> hey guys
13:08:17 <neutrino_> so has anyone seen the work by herlihy on "transactional boosting"? does it have an equivalent in haskell?
13:08:32 <neutrino_> he says it is superior to stm in several ways
13:08:49 <johnw`> link?
13:08:58 <sclv> twilight-stm supports boosting as i recall
13:08:59 <lambdabot> sclv: You have 1 new message. '/msg lambdabot @messages' to read it.
13:09:59 <neutrino_> sclv: how does twilight-stm do it?
13:10:10 <neutrino_> johnw`: http://www.youtube.com/watch?v=0slg39aJTok&feature=youtu.be
13:10:39 <sclv> ?google twilight-stm
13:10:41 <lambdabot> http://hackage.haskell.org/package/twilight-stm
13:10:41 <lambdabot> Title: HackageDB: twilight-stm-1.2
13:10:55 <johnw`> does twilight-stm come with emo vampires too? :)
13:14:11 <Industrial> There's not a lot of documentation on Warp is there? (web server)
13:14:49 <Industrial> at least, none on it's github
13:15:47 <Twisol> Are there any open/free Haskell-related journals online? I just read Brent Yorgey's "Monoids: Theme and Variations" paper and I'm looking for more like it.
13:17:10 <johnw`> there's the Monad.Reader
13:17:23 <johnw`> but there are hundreds of quality Haskell articles out there, if you search for a while
13:17:32 <johnw`> i can give you a bunch of them
13:17:58 <Twisol> That would be great.
13:18:10 <johnw`> http://ftp.newartisans.com/pub/HaskellDocs.tar.xz
13:18:24 <Twisol> Nice, thanks!
13:19:24 <eikke> 243MB?!
13:22:51 <parcs> Industrial: the haddocks are sufficient last time i checked
13:24:31 <neutrino_> Industrial: just ask mm_freak_
13:25:06 <neutrino_> Twisol: google for "this ftp site"
13:25:49 <neutrino_> sclv: i can't see that twilight does transactional boosting, can you elaborate on this?
13:27:22 <Industrial> parcs: I'm not sufficiently well known yet with the haskell ecosystem, newbie :X
13:27:24 <johnw`> eikke: hey, that's the old version too ;)
13:27:58 <Twisol> neutrino_: Thanks
13:28:06 <Industrial> Coming from NodeJS, I thought maybe webprogramming is a nice angle to learn some Haskell :)
13:28:17 <neutrino_> Twisol's famous last words
13:29:01 <Industrial> hehe, I grabbed the package aswell if you don't mind
13:29:12 <johnw`> not at all, everyone can get it if they want
13:29:21 <johnw`> that VPS provider gives me enormous free bandwidth
13:29:23 <parcs> Industrial: then i recommend happstack
13:29:35 <parcs> Industrial: it has a very accessible tutorial
13:29:41 <Industrial> parcs: ok
13:29:56 <parcs> http://www.happstack.com/docs/crashcourse/index.html
13:30:17 <sclv> don't recall the details, actually. but i think you can build on it with the "twilight" phase to get there.
13:30:28 <sclv> its not out of the box
13:31:52 <neutrino_> johnw`: an arabic dictionary?
13:31:55 <neutrino_> sclv: hmm...
13:32:18 <johnw`> neutrino_: in that FTP directory?  it's a Persian dictionary
13:32:38 <neutrino_> johnw`: a persian dictionary?
13:32:46 <johnw`> what's the question?
13:32:58 <neutrino_> just surprised, that's all
13:33:01 <neutrino_> are you learning persian?
13:33:10 <johnw`> i have been for >20 years
13:33:25 <neutrino_> arabic and persian aren't super popular second languages, that's why i'm surprised
13:33:29 <neutrino_> oh, that's cool
13:33:33 <johnw`> we can discuss on -blah if you like :)
13:33:49 <neutrino_> is it as invariant as arabic?
13:33:58 <johnw`> neutrino_: join #haskell-blah
13:37:21 <Industrial> parcs: so it's multi threaded (per request) out of the box eh? NodeJS will never do that :(
13:37:43 <Industrial> I'd have to manually send/receive/manage events from child processes
13:40:22 <neutrino_> johnw`: sector inspector, huh? i wrote a data recovery tool in haskell once..
13:40:25 * hackagebot hdevtools 0.1.0.4 - Persistent GHC powered background server for FAST haskell development tools  http://hackage.haskell.org/package/hdevtools-0.1.0.4 (BitConnor)
13:41:26 <niteria> I'm looking for a good read on applicative style
13:43:11 <roconnor> niteria: it's pretty easy.  Instead of writing liftMn f a b c ... you write f <$> a <*> b <*> c <*> ...
13:43:16 <johnw`> niteria: the classic use case is parser libraries, which I think showcase the capabilities quite well; if you read up on Parsec, you'll see a ton of examples of using Applicative in all its many forms
13:44:27 <johnw`> the Typeclassopedia has a good section on Applicative
13:44:40 <niteria> Parsec uses Applicative? I've used it and haven't noticed
13:44:53 <johnw`> niteria: you use *> and <*, right?
13:45:01 <niteria> no
13:45:05 <johnw`> oh!
13:45:14 <johnw`> string "hello" *> string "world"
13:45:20 <johnw`> that parses "helloworld", but only returns "world"
13:45:45 <niteria> I have monads everywhere
13:46:07 <Guest68791> i can live with that
13:46:21 <niteria> so I guess Parser has Applicative instance
13:46:27 <johnw`> ype
13:47:40 <Guest68791> my wife gave me haskell for christmas so I'm trying it out now
13:48:13 <niteria> there's no <* <*> *> in the whole Parsec guide, that's why I'm surprised
13:48:20 <johnw`> my wife would want me to put *away* Haskell for Christmas :)
13:48:36 <johnw`> niteria: huh
13:49:18 <mvj4_> anyone familiar with the SBV SMT solver module? I'm having trouble with concrete and symbolic values, some value is left as symbolic when evaluating.
13:52:09 <niteria> I've seen applicative mostly used as Constructor <$> a <*> b <*> c, I don't know what's the benefit of that
13:52:19 <Guest68791> so string sorting is case sensitive....interesting
13:53:19 <eikke> hmh... I built "lens" from git using cabal-dev, build seems to succeed, but when trying to run one of the generated executables, I get this error: "cannot satisfy -package doctest-0.9.5", at runtime?!
13:53:45 <johnw`> > 10 <$ [1..5]
13:53:46 <lambdabot>   [10,10,10,10,10]
13:54:00 <johnw`> applicative is just a convenient way of dealing with effects
13:54:06 <Industrial> parcs: how do I view this haddoc documentation of warp?
13:54:06 <eikke> :t (<$)
13:54:07 <lambdabot> Functor f => a -> f b -> f a
13:54:10 <johnw`> or rather, computations with context
13:55:03 <johnw`> if you find yourself using case to peek inside Maybe's and Either's a lot, applicative may help make the code more straightforward
13:55:04 <jmcarthur> Guest68791: i can think of no language off the top of my head where that is not the case
13:55:08 <applicative> Guest68791: you can define whatever order you like
13:55:20 <applicative> @type sortBy
13:55:22 <lambdabot> (a -> a -> Ordering) -> [a] -> [a]
13:55:26 <jmcarthur> not that i'm denying they exist
13:56:43 <Guest68791> actually, you're right..so used to using wrappers
13:57:31 <Guest68791> ("Gary", "Gues68791")
13:58:25 <Guest68791> awkward, typed in the wrong window
13:59:14 <niteria> I find myself using case going from Maybe to Either and back again
13:59:35 <johnw`> show me an example, and maybe I can help you applicify it
14:00:29 <hpaste> niteria pasted “case overload” at http://hpaste.org/79813
14:00:37 <niteria> see infer
14:01:25 <johnw`> infer could stand to use Attempt
14:01:33 <johnw`> then you wouldn't have to care about Maybe vs. Either
14:02:12 <Axman6> :t comparing
14:02:13 <johnw`> using Attempt would look like this:
14:02:14 <lambdabot> Ord a => (b -> a) -> b -> b -> Ordering
14:02:32 <Axman6> :t comparing (map toUpper)
14:02:33 <lambdabot> [Char] -> [Char] -> Ordering
14:02:47 <johnw`> infer env (Var l id) = maybe (Failure $ "Could not find " ++ l) Success (lookVar env id l)
14:03:41 <johnw`> with return type Attempt Type
14:04:07 <johnw`> yeah, Attempt would seriously simplify this entire file
14:04:18 <johnw`> or just using 'maybe'
14:04:55 <niteria> 'maybe' would help
14:05:11 <niteria> with going Maybe -> Either
14:05:38 <johnw`> the whole point of Attempt is let the caller decide how errors are made available
14:05:51 <johnw`> if they case analyze the return value as a Maybe, it will use Nothing to represent failure
14:05:56 <johnw`> if they analyze it as an Either, Left String
14:06:09 <johnw`> if they analyze it in IO, it will throw an exception, etc.
14:07:05 <johnw`> ok, you see line 75 in your file?
14:07:18 <johnw`> that could be written: typecheck <$> foldM addArg env args <*> pure block
14:08:15 <johnw`> few variable names in a function is good when the variable exists only exist to shuffle values around
14:08:18 <johnw`> fewer*
14:08:46 <niteria> I thought about hiding env in a State
14:08:57 <johnw`> do you change it?
14:09:43 <lennart_> pluma
14:09:53 <niteria> it changes as I go down AST
14:10:49 <johnw> i wonder if it makes sense as an implicit parameter
14:10:50 <niteria> but it stops changing on the level of expressions
14:11:10 <niteria> expressions only read env
14:11:19 <niteria> statements modify it
14:12:46 <niteria> I guess I could use State for statements, and downgrade it to Reader for exprs
14:12:51 <johnw`> maybe you only need a Reader?
14:14:07 <niteria> I need to work with types though, errors should have its own ADT
14:14:43 <niteria> also my AST types are badly designed
14:15:11 <johnw`> the Attempt type can represent errors as anything that an instance of SomeException
14:15:18 <johnw`> so you can pass back whatever info you want
14:16:15 <niteria> is there some example code for Attempt?
14:16:34 <johnw`> just use Success and Failure instead of Right and Left
14:16:37 <johnw`> that's pretty much all there is to it
14:18:06 <niteria> and use 'attempt' instead of 'maybe'?
14:18:23 <johnw`> no
14:18:34 <johnw`> if your function need to return a successful value, return Success value
14:18:43 <johnw`> if it needs to report a failure, return Failure someException
14:20:15 <niteria> sure, but sometimes I have to promote an error to some higher level error
14:20:31 <johnw`> what do you mean?
14:21:54 <applicative> Guest68791: note also that the "String" type is a linked list of Chars and that the sort from Data.List uses a list, of course
14:21:56 <niteria> lookupEnv can return Failure SymbolNotFound, but at typecheck level I want to return Failure $ UndefinedReference lineNo
14:22:10 <applicative> Guest68791:  so 'sorting strings' would mean sorting a list of lists and returning one, all this might not be best
14:22:43 <applicative> Guest68791: I mean, there are other representations of strings in Haskell, and other things to sort besides lists
14:23:03 <johnw`> niteria: then do this:
14:23:33 <johnw`> attempt (\_ -> Failure (UndefinedReference lineNo)) id someFunctionCall
14:23:44 <johnw`> you can transform either side using 'attempt' the way you would with 'maybe'
14:24:01 <niteria> that's what I menad by "and use 'attempt' instead of 'maybe'?"
14:24:04 <niteria> meant*
14:24:07 <johnw`> ah, ok
14:25:17 <johnw`> the other possibility is just use Either everywhere, and 'maybe' to convert
14:25:27 <johnw`> using Attempt is usually for the sake of your users, not you
14:25:39 <Guest68791> applicative: thanks, I don't know why I was surprised by it, but once i dug into the docs I saw how it worked
14:25:46 <johnw`> i mean, you already know what want the return types to look like in every case
14:32:06 <applicative> Guest68791: yeah, I was making a separate perhaps unhelpful point, that e.g. Data.Text or Data.ByteString give completely different representations of 'strings'; a list of Texts would be sorted by Data.List.sort  directly, as Text has its own Ord  instance, or ordering concept or however it should be put
14:43:01 <johnw`> aristid: ping
14:43:14 <aristid> johnw`: pong
14:44:24 <aristid> johnw``: what's the matter?
14:45:07 <johnw``> sorry
14:45:16 <johnw``> my internet keeps dropping me
14:45:24 <Industrial> Does cabal use all my codes by default i.e. make -j ?
14:45:30 <Industrial> cores*
14:45:39 <johnw``> if I add a PATCH request method (http://tools.ietf.org/html/rfc5789), would you release a new http-types?
14:46:33 <aristid> johnw``: http-types uses ByteString for the http method most of the time, so i don't see the need.
14:46:37 <lispy> Industrial: I don't think so
14:46:50 <johnw``> it's just that you have methodFoo for all the other methods
14:46:50 <lispy> Industrial: there is a config option for changing how many cores it uses by default
14:46:54 <Guest68791> applicative: thanks, it was helpful =D
14:46:59 <johnw``> so it really breaks uniformity to have to deal with PATCH separately
14:47:05 <johnw``> the GitHub API uses PATCH
14:47:13 <lispy> Industrial: emphasis, on me not being sure how the default works. I'm looking now.
14:47:59 <lispy> Industrial: here is the user guide but I can't find documentation for this feature: http://www.haskell.org/cabal/users-guide/
14:48:11 <Industrial> ty
14:49:00 <lispy> Industrial: I have this line in ~/.cabal/config: jobs: 8
14:49:24 <lispy> that makes the default number of jobs match the number of cores that I have
14:49:29 <johnw``> aristid: pull request sent
14:49:51 <Industrial> k
14:50:53 <aristid> johnw: why is patch in the middle of the list? it's decidedly not in RFC 2616
14:51:08 <aristid> also, ETOOMANYJOHNW
14:51:09 <johnw> i didn't realize that's how you had ordered it
14:51:15 <johnw> ETOOMANYJOHNW?
14:51:23 <lispy> Industrial: https://github.com/haskell/cabal/blob/master/cabal-install/Distribution/Client/Install.hs#L826
14:51:26 <aristid> johnw: oh you eliminated the others
14:51:37 <johnw> PATCH is like a PUT that can modify part of an item, so that's why I put it there
14:51:38 <aristid> i thought there were johnw and johnw` and johnw`` :D
14:52:20 <aristid> johnw: well i just thought it would be nice to have the rfc 2616 methods as a contiguous block...
14:52:27 <johnw> sounds good to me
14:52:31 <lispy> Industrial: just -j tells it to use "numberOfProcessors" but I'm not sure if that would be 4 or 8 or my machine. I have 4 dual cores, IIRC
14:52:35 <johnw> want me to fix the patch?
14:52:43 <aristid> johnw: yes please
14:52:56 <johnw> now i have to go read 2616...
14:53:10 <aristid> johnw: but those that i already have are those of rfc 2616
14:53:22 <aristid> (the HTTP 1.1 RFC)
14:53:37 <lispy> Industrial: and this is the implementation of the function to get the number of processors: https://github.com/haskell/cabal/blob/master/cabal-install/cbits/getnumcores.c
14:54:14 <Peaker> aristid, it's pretty weird so many here have OpenGL issues.. Linux, I guess
14:54:25 <Peaker> I don't think Macs/Windows have OpenGL issues, hopefully
14:54:59 <lispy> I believe that will give the number of cores...
14:55:02 <_ft_> hi everyone, I'm trying to generate some haskell code from a command line utility (also written in haskell), what do you think it would be the best way to implement it ?
14:55:12 <johnw> aristid: pull req updated
14:55:20 <aristid> Peaker: i have that problem on OS X...
14:55:24 <lispy> _ft_: maybe haskell-src-exts?
14:55:30 <johnw> ooh, i like the travis integration with github, that's very cool...
14:55:32 <aristid> Peaker: because i use nix, and nix doesn't support os x as well as linux
14:55:50 <aristid> Peaker: but i love my binary packages for ghc, and the other nice things
14:56:10 <lispy> _ft_: you could probably even use some quasiquotation feature so that the static bits of haskell could be parsed in instead of manually encoded as Haskell
14:57:22 <Industrial> lispy: holy crap :P I just wanted to get some more speed into this install s'all xD
14:57:50 <johnw> "#haskell, where we answer the questions you didn't even think to ask"
14:57:51 <_ft_> lispy, ok I'm checking the haskell-src-exts, but is it good to use quasiquotation ?
14:57:52 <lispy> Industrial: um...merry christmas? ;)
14:58:20 <Peaker> aristid, can't you install OpenGL via the ordinary OS X ways?
14:59:11 <aristid> Peaker: no, because then i link against some important libraries twice and... all hell breaks loose
14:59:19 <lispy> _ft_: I guess it really depends on what you're doing. If you have very static bits of haskell you can just print them verbatim. But if those bits are a template you could use quasiquotation to parse the instantiated template and then haskell-src-exts has a pretty printer for haskell.
14:59:56 <aristid> Peaker: really i should try to fix those nix packages, i guess. or get someone who knows more about nix than i do to do so. i have filed a bug already so if somebody randomly feels the desire to do so, that'd be that
15:00:07 <_ft_> lispy, ok I see, thanks!
15:07:59 <Industrial> lispy: to you too
15:09:26 <johnw> jmcarthur: hey there
15:15:46 <bradleyayers> I'm reading LYAH and have found a bug
15:16:26 <bradleyayers> http://learnyouahaskell.com/making-our-own-types-and-typeclasses `(==) :: a -> -a -> Bool'
15:16:32 <bradleyayers> shouldn't be `-a' right?
15:18:23 <owst_> bradleyayers: correct, that's a typo.
15:19:01 <bradleyayers> How do I get it changed?
15:19:37 <owst> No idea I'm afraid
15:20:08 <Industrial> get a name, find an address, post a mail (e-mail ..) :D
15:20:26 <bradleyayers> I will investigate.
15:20:49 <Guest68791> so you can pass functions to other functions like they're some sort of first class citizen, interesting
15:21:03 <Industrial> we heard you like functions
15:21:12 <Fuuzetsu> :t (>>>)
15:21:13 <lambdabot> Control.Category.Category cat => cat a b -> cat b c -> cat a c
15:21:19 * bd_ wonders if any research has been done into typesystems in which the set of all types forms a ring...
15:22:23 <Guest68791> Industrial: syntax error, missing "yo dawg"
15:22:35 <bradleyayers> 'bonus' has been emailed.
15:23:22 <Industrial> \o/ enjoyment shall be had
15:23:53 <tgehr> yay
15:23:56 <tgehr> ghc: panic! (the 'impossible' happened)
15:26:24 <jmcarthur> johnw: hey
15:26:58 <jmcarthur> johnw: i'm leaving, so that was just bad timing
15:27:01 <jmcarthur> sorry
15:48:12 <Fuuzetsu> I'm looking to do some web parsing (which involves crawling a site), is there something you would recommend? Shpider looks awesome but it doesn't seem to pick up the login form when asked to. I can authenticate with HTTP.Conduit and download the page fine but it doesn't seem to be very flexible... Should I just stick with it?
15:49:35 <elliott> there's http://hackage.haskell.org/package/tagsoup
15:49:42 <elliott> that just handles the parsing part, though
15:51:01 <Fuuzetsu> I was going to use HXT for the parsing part; more concerned on the crawling part
15:54:01 <aristid> Fuuzetsu: there is a -brower package for http-conduit
15:55:46 <mreh> could I represent exceptional values (e.g. Left e) from different functions as their own types and still sequence them without the type system complaining?
15:56:17 <mreh> there's clearly no static way of doing it without a monolithic type for exceptions
15:56:40 <mreh> but I'd quite like to document the possible exceptions that can occur in a function
15:56:53 <mreh> and then users may handle accordingly
15:56:54 <Peaker> mreh, there's a trick to do that with type-classes in some package (I think monad exceptions)
15:57:07 <mreh> Peaker, oh cool
15:57:31 <Peaker> http://hackage.haskell.org/package/control-monad-exception
15:58:34 <mreh> GHC will only bleat when missing a matched constructor in a case statement right?
15:59:17 <mreh> i'm too lazy to try :)
15:59:24 <mreh> let me check
16:01:12 <Taneb> What's the difference between an Alternative that is also a Monad, and a MonadPlus?
16:09:59 <Saizan> there shouldn't be one
16:13:36 <hpaste> beefcube pasted “Understanding simple State example” at http://hpaste.org/79816
16:14:09 <beefcube> can someone explain this? I'm totally stuck
16:15:10 <Cale> beefcube: n would be just the result of get, so it will have type Int
16:15:18 <Peaker> beefcube, put discards the previous state, but you still have the information from previous computation in the form of the lambda variables you got from before
16:15:20 <beaky> hello
16:15:24 <Cale> beefcube: which in this case will be 1
16:15:49 <mreh> hi
16:19:11 <Taneb> My ghc-pkg dot is beautifully horrible
16:21:01 <Fuuzetsu> in case anyone was wondering, Network.Browser seems to do what I need
16:28:18 <mreh> Peaker, you couldn't explain how monad-exceptions works could you? Being rather non-mainstream the concepts are rather hard to understand from the material I can find :)
16:30:01 <Peaker> mreh, I've never used it.. but I imagine if you had a: Left l a   as the type of all your computations, and when you threw, you didn't throw a specific type, but something like: MyException l => l,   then unifying all those l's would be possible and you'd get all the possible exception types as constraints
16:30:11 <Peaker> mreh, oops, s/Left/Either
16:31:06 <mreh> Peaker, do you know how you handle specific exceptions in generic code then?
16:31:23 <mreh> without the type system wanting to unify all the ls to the same type
16:32:19 <mreh> i'll read on
16:33:18 <gaze__> Hey, is anyone here really familiar with the conduits library?
16:33:31 <gaze__> I'm having a difficult time understanding what the upstream is
16:37:23 <gaze__> and for that matter, what's the difference between >+> and =$=?
16:38:27 <Fuuzetsu> :t (>+>)
16:38:28 <lambdabot>     Not in scope: `>+>'
16:38:28 <lambdabot>     Perhaps you meant one of these:
16:38:28 <lambdabot>       `>>' (imported from Control.Monad.Writer),
16:40:28 <gaze__> it's part of the conduits package
16:40:37 <gaze__> they both have similar types and provide a way to fuse two things together
16:41:27 <lolcathost> How do I build a ByteString consisting of n times the null character?
16:41:37 <lolcathost> strict ByteString*
16:44:00 <parcs> lolcathost: replicate
16:44:27 <lolcathost> parcs: ty
16:52:45 <hpaste> tgehr pasted “Ambiguous instances” at http://hpaste.org/79819
16:53:21 <tgehr> why does this fail? the second instance should not match as far as I can see
16:54:09 <tgehr> (the missing 'Show' instance error is expected)
16:58:11 <lolcathost> @pl \max str = putByteString str >> putByteString $ replicate (max - length str) 0
16:58:11 <lambdabot> (line 1, column 10):
16:58:12 <lambdabot> unexpected "="
16:58:12 <lambdabot> expecting pattern or "->"
16:58:48 <lolcathost> @pl \max str -> putByteString str >> putByteString $ replicate (max - length str) 0
16:58:48 <lambdabot> liftM2 (>> putByteString) putByteString . flip flip 0 . (replicate .) . (. length) . (-)
17:04:07 <lolcathost> @type liftM
17:04:08 <lambdabot> Monad m => (a1 -> r) -> m a1 -> m r
17:04:36 <lolcathost> @hoogle Monad m => a -> m (a -> r) -> m r
17:04:37 <lambdabot> Control.Monad ap :: Monad m => m (a -> b) -> m a -> m b
17:04:37 <lambdabot> Control.Monad liftM :: Monad m => (a1 -> r) -> m a1 -> m r
17:04:37 <lambdabot> Control.Applicative (<**>) :: Applicative f => f a -> f (a -> b) -> f b
17:05:11 <lolcathost> @hoogle Monad m => m (a -> r) -> a -> m r
17:05:12 <lambdabot> Control.Monad ap :: Monad m => m (a -> b) -> m a -> m b
17:05:12 <lambdabot> Control.Monad liftM :: Monad m => (a1 -> r) -> m a1 -> m r
17:05:12 <lambdabot> Control.Applicative (<*>) :: Applicative f => f (a -> b) -> f a -> f b
17:09:04 <edwardk> @tell otters its Control.Lens.Opthamologist actually.
17:09:05 <lambdabot> Consider it noted.
17:11:01 <parcs> does a updating a field of a record with n fields cause ~n words to be copied?
17:14:27 <cmccann> edwardk, so I'm now plagued by the nagging suspicion that at least half the code I'm writing could be replaced with a single cryptic lens-y one-liner
17:14:29 <cmccann> good job
17:15:00 <edwardk> cmccann: muahahhaa
17:15:13 <edwardk> parcs: yes
17:17:03 <cmccann> edwardk, basically the code is walking all over something AST-ish, tearing out nodes and altering others while creating and mangling a bunch of Data.Map fields in a StateT
17:17:30 <edwardk> cmccann: you did see 'rewrite' right?
17:17:43 <cmccann> yeah
17:18:00 <simpson> :t rewrite -- did you port this to be all lensy?
17:18:01 <lambdabot> Plated a => (a -> Maybe a) -> a -> a
17:18:09 <cmccann> but I've got enough hoops I have to first set up and then jump through that I'm sure how to make that work here
17:18:10 <edwardk> :t rewriteOf
17:18:12 <lambdabot> SimpleSetting a a -> (a -> Maybe a) -> a -> a
17:18:18 <cmccann> ditto for the uniplate stuff that I would have used previously
17:18:36 <simpson> Uh, what. What does that even mean?
17:18:50 <cmccann> maybe once I get it working I can try to simplify things to use stuff like rewrite &c.
17:19:30 <edwardk> simpson: rewriteOf will take a traversal that knows how to find, say, immediate subexpressions, and a rewrite you want to perform on the tree, and it'll start down at the bottom of the tree rule over and over until it doesn't fire, and work its way up the tree
17:20:30 <edwardk> rewriteOf myChildren $ \case Neg (Lit i) -> Just (Lit (-i)); _ -> Nothing    -- will go through a syntax tree replacing all negated literals with literals with negated values
17:20:37 <edwardk> you can do constant folding, etc. similarly
17:21:07 <edwardk> rewriteOf myChildren $ \case Add (Lit i) (Lit j) -> Just (Lit (i + j)): … ; _ -> Nothing
17:21:12 <simpson> I should port my plated stuff, and then see what I can optimize. I wrote really *really* clean code before, with a bunch of clearly delineated steps.
17:21:21 <simpson> :t myChildren
17:21:22 <lambdabot>     Not in scope: `myChildren'
17:21:23 <lambdabot>     Perhaps you meant `children' (imported from Control.Lens)
17:21:27 <simpson> :t children
17:21:28 <lambdabot> Plated a => a -> [a]
17:21:33 <elliott> myChildren is something you define
17:21:34 <edwardk> its whatever traversal you want it to be
17:21:36 <simpson> Aha.
17:21:43 <edwardk> you can always use uniplate
17:21:44 <elliott> any setter :P
17:21:45 <edwardk> :t uniplate
17:21:46 <lambdabot> (Data.Data.Data a, Applicative f) => (a -> f a) -> a -> f a
17:21:51 <aristid> > children (Just 4)
17:21:53 <lambdabot>   No instance for (Control.Lens.Plated.Plated (Data.Maybe.Maybe a0))
17:21:53 <lambdabot>    arisi...
17:22:02 <aristid> :(
17:22:05 <edwardk> > children "hello"
17:22:05 <simpson> So rewriteOf uniplate === rewrite ?
17:22:07 <lambdabot>   ["ello"]
17:22:17 <edwardk> simpson: almost. Plated is a class you can instantiate
17:22:23 <edwardk> its like the old Uniplate class
17:22:42 <edwardk> except since all the combinators are parameterized so they can take any traversal you can make instances for it that are polymorphic
17:23:04 <edwardk> without worrying about importing something that somewhere imports the stupid data instance and breaks all your custom uniplates
17:23:14 <aristid> edwardk: how fast is the Data.Data-based uniplate lens stuff?
17:23:17 <simpson> Oooh! I see! I could make a traversal for my data type and not need SYB!
17:23:49 <edwardk> aristid: 35-50% faster than the stuff in uniplate itself. Plated can be about 2-2.5x faster still with a hand rolled traversal
17:24:03 <edwardk> simpson: yeah
17:24:23 <simpson> edwardk: Ingenious!
17:24:30 <edwardk> and if in part of your program you want to treat antiquotations as non-expressions you can, and elsewhere you can use a different traversal.
17:24:37 <aristid> edwardk: fast enough that you'd use it yourself?
17:25:04 <edwardk> i tend to just use Data.Data.Lens stuff. its really convenient.
17:25:08 <edwardk> and this works both ways
17:25:18 <edwardk> you can use other traversals for the uniplate combinators
17:25:27 <edwardk> but you can also use uniplate and biplate on their own as traversals
17:25:49 * elliott bets edwardk actually uses upon
17:25:51 <simpson> So I could port myself off of Uniplate using Data.Data.Lens, and move to handwritten stuff later if needed?
17:26:03 <edwardk> > ("hello",["world","!!!"],("this","is","neat")) ^.. biplate :: [String]
17:26:06 <lambdabot>   ["hello","world","!!!","this","is","neat"]
17:26:21 <edwardk> > ("hello",["world","!!!"],("this","is","neat")) & biplate %~ toUpper
17:26:23 <lambdabot>   ("HELLO",["WORLD","!!!"],("THIS","IS","NEAT"))
17:26:32 <edwardk> simpson: correct
17:26:39 <elliott> btw, that new overlapping type family stuff coming in GHC 7.8
17:26:42 <`nand`> > ("hello",["world","!!!"],("this","is","neat")) ^.. biplate :: String
17:26:44 <lambdabot>   "helloworld!!!thisisneat"
17:26:44 <elliott> does it break parametricity?
17:26:51 <elliott> it seems like you could case on type equality without changing your signatures
17:26:52 <edwardk> elliott: dunno
17:26:58 <`nand`> elliott: whoa, it's coming in GHC 7.8?
17:26:58 <elliott> but maybe they avoided that the same way TypeEq doesn't let you do that
17:27:09 <elliott> (because you get an overlapping instance error and need to put the constraint on)
17:27:10 <edwardk> it should match with the TypeEq functionality
17:27:12 <elliott> `nand`: I hear it's in HEAD
17:27:27 <elliott> `nand`: http://typesandkinds.wordpress.com/2012/12/22/ordered-overlapping-type-family-instances/
17:27:36 <elliott> I don't like the syntax but that's a minor quibble
17:27:36 <`nand`> elliott: is this related to the ‘instance groups’ that one proposal talks about?
17:27:54 <`nand`> oh
17:27:55 <`nand`> yes, yes it is
17:27:58 <elliott> it groups overlapping type family instances into a single ordered block
17:28:00 <elliott> dunno about that proposal
17:28:07 <simpson> > rewriteOf biplate (\x -> case x of { 'o' -> Just '0'; _ -> Nothing }) ("hello",["world","!!!"],("this","is","neat"))
17:28:07 <edwardk> Richard is an insanely smart guy, so I'm pretty confident that what he's doing will be the right solution
17:28:08 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
17:28:09 <lambdabot>              with actual type...
17:28:12 <simpson> Aw. :c
17:28:18 <`nand`> yeah that's exactly what I was thinking of; you can overlap lines in a single ‘type instance where’ block; but not outside of them
17:28:23 <elliott> edwardk: high praise :)
17:28:28 <simpson> :t rewriteOf biplate (\x -> case x of { 'o' -> Just '0'; _ -> Nothing })
17:28:30 <lambdabot> Char -> Char
17:28:41 <elliott> I look forward to trying something like Oleg's statically-typed type-casing generics with it
17:28:44 <`nand`> I wonder if this will come before Jan 14th
17:28:47 <simpson> I guess I didn't really think about how that traversal works.
17:28:49 <elliott> sounds much nicer than Data
17:28:53 <edwardk> rewriteOf uniplate is probably what you want
17:28:54 <`nand`> (stable, that is)
17:29:05 <simpson> :t rewriteOf uniplate (\x -> case x of { 'o' -> Just '0'; _ -> Nothing })
17:29:06 <lambdabot> Char -> Char
17:29:07 <edwardk> in general biplate is used like in uniplate, to find the branches you want to use uniplate on
17:29:16 <elliott> :t transformOf uniplate (\x -> case x of { 'o' -> '0'; _ -> x })
17:29:18 <lambdabot> Char -> Char
17:29:44 <elliott> I guess rewrite can save work over transform
17:29:58 <edwardk> rewrite is going to keep doing the change
17:29:58 <elliott> well, it can share better, I guess
17:30:13 <elliott> but I guess it also probably doesn't
17:30:43 <edwardk> rewriteOf l f = go where go = transformOf l (\x -> maybe x go (f x))
17:31:30 <elliott> right
17:31:34 <elliott> but it could theoretically share better
17:31:43 <elliott> by reusing subtrees that you immediately returned Nothing on the children of
17:36:26 <bootcode> hello
17:38:06 <bootcode> I'm trying to get acquainted with hsenv, however getting the following warning when creating the env:  "Failed to copy optional package ghc from system's GHC" (also for ghc-binary). Have you encountered this?
17:39:44 <bootcode> when inspecting the hsenv.log, a ghc-pkg failure for "bin-package-db" precedes these warnings, but not sure if it is relevant
17:43:08 <edwardk> elliott: if you can come up with a nice way to get that sharing i'll take it!
17:43:31 <elliott> edwardk: probably it doesn't belong in rewriteOf
17:43:47 <elliott> instead you'd have a transformFooOf that has the same type of rewriteOf but only rewrites once
17:43:50 <elliott> and then build it on top of that
17:46:50 <beefcube> Peaker: thanks, I had forgetten that >> is implemented in term of >>=, having trouble wrapping my head around that
17:49:30 <Direc> Is there a concise way I can do: joinMapped f x = x ++ (map f x) without defining it as a method?
17:53:31 <elliott> Direc: you can drop the parens around (map f x)
17:53:52 <elliott> "joinMapped f = (++) <$> id <*> map f" is technically equivalent but I don't recommend it
17:54:25 <Direc> elliott: ah, any reason you don't recommend it?
17:54:31 <owst> elliott: why the <$> id ?
17:54:46 <owst> elliott: isn't (++) <*> map f enough?
17:55:28 <elliott> owst: no
17:55:35 <bootcode> The source of my problem seems to be that I unregistered the global Cabal package somehow.
17:55:38 <elliott> Direc: it's harder to understand for no real reason
17:55:41 <elliott> Direc: what you wrote is just fine
17:55:48 <elliott> also it's even uglier :P
17:55:57 <aristid> :t joinMapped f = (++) <$> id <*> map f
17:55:58 <lambdabot> parse error on input `='
17:55:59 <elliott> owst: oh wait
17:56:03 <elliott> owst: I think you are right
17:56:06 <Direc> elliott: yeah I'm just looking for a way to do it with just one 'x', as I want to do it inline in a function and the 'x' is quite a bit longer
17:56:10 <elliott> :t \f -> (++) <*> map f
17:56:10 <aristid> :t \f -> (++) <$> id <*> map f
17:56:11 <lambdabot> (a -> a) -> [a] -> [a]
17:56:12 <lambdabot> (a -> a) -> [a] -> [a]
17:56:15 <aristid> :)
17:56:20 <elliott> owst: right you are, apologies :)
17:56:57 <elliott> Direc: then I guess something like: "ap (++) (map f) $ ...x..." might be viable. I really suggest just factoring this out though :)
17:57:20 <owst> elliott: no need to apologise :-)
18:01:16 <hpaste> conal pasted “Fundep fail” at http://hpaste.org/79823
18:01:35 <Direc> elliott: lost me little with how that ap works, thank you though, I'll think on it a bit more I guess
18:01:52 <elliott> Direc: ap = (<*>)
18:02:21 <elliott> but for monads only. but you are just using (->) here so it doesn't matter and the non-infixity is nicer for ($)ing
18:02:25 <elliott> do you know the S combinator?
18:02:35 <elliott> it is the same thing. for functions, (f <*> g) x = f x (g x)
18:02:40 <Direc> elliott: very very beginner functional anything, been playing with Haskell maybe 3 days so
18:02:48 <Direc> I'm googling a lot just from this conversation
18:03:01 <elliott> right. I suggest not worrying about this stuff then :)
18:03:03 <Direc> Literally just trying to do rot13 right now
18:03:22 <elliott> don't write "fancy" code until you can understand it (and make a judgement as to when it's a win) is a decent rule of thumb
18:03:30 <Direc> I was going to try doing it with lookup and a list of [(Char,Char)], making my list with
18:03:44 <lolcathost> I have two ByteStrings. Their lengths are known to be equal. If the "meaning" of a ByteString s is "fromIntegral (unsafeHead s) + 256 * meaning (unsafeTail s)", how should I implement addition on these ByteStrings?
18:03:51 <Direc> uncurry zip (splitAt 13 ['a'..'z'])
18:03:53 <bootcode> Reinstalling ghc package solved the problem. Now an unrelated question. Can I get cabal to auto-download and install the best dependency set for a cabalized project?
18:04:03 <Direc> I wanted to apply Data.Tuple.swap to it and append it to the end
18:04:17 <Direc> And was wondering if I could do that inline without just putting that part in a where clause ors omething
18:04:38 <Direc> to make x ++ (map Data.Tuple.swap x)
18:04:51 <Jafet> lolcathost: what is the "meaning" of addition
18:05:23 <Jafet> what is the "meaning" of brown tulips on an autumn day in bhopal
18:05:54 <Direc> elliott: that's why I was wondering about the function in particular, I figured I could do something like joinMapped swap $ ... the list thing I did above ...
18:06:09 <Direc> Just figured maybe I coudl do it with something built in
18:07:20 <Jafet> @where rot13
18:07:21 <lambdabot> (let e[a,b,c]=zip[a..c]$[b..c]++[a..]in map$fromMaybe<*>(`lookup`(e"anz"++e"ANZ")))
18:08:18 <conal> I ran into a simple falure with functional dependencies (in GHC 7.4.1). Would appreciate a sanity check. What am I missing? http://hpaste.org/79823
18:09:30 <Jafet> Is ghc supposed to?
18:10:13 <Direc> Jafet: oh that's cool, thank you, though you kind of killed my attempt to write it myself ;p
18:10:42 <NemesisD> hi guys. i've had it about up to hear with other libraries throwing random exceptions. i need to ensure that when something bad happens, it dumps to a log and *doesnt* kill my thread. I'm about to implement http://pastie.org/5479236, is there any simpler/better thing i can do?
18:12:21 <elliott> Jafet: lolcathost's question seemed clear to me... you want to implement "bs1 + bs2" s.t. "meaning (bs1 + bs2) = meaning bs1 + bs2"
18:12:56 <elliott> conal: I think I agree you can deduce (ta ~ tb) from foo's signature, but I'm not sure GHC promises to
18:13:16 <Jafet> elliott: meaning is polymorphic
18:13:52 <conal> elliott: oh, hm. thanks.
18:15:35 <elliott> conal: I agree it's a bit odd and probably deserves a bug report?
18:15:53 <elliott> Jafet: hm?
18:16:03 <conal> elliott: perhaps so. i'll start with a query to glasgow-haskell-bugs
18:16:33 <Jafet> That makes (+) polymorphic
18:17:00 <elliott> *meaning bs1 + bs2
18:17:02 <elliott> argh
18:17:03 <elliott> *meaning bs1 + meaning bs2
18:17:09 <elliott> "byteStringPlus bs1 bs2" s.t. "meaning (byteStringPlus bs1 bs2) = meaning bs1 + meaning bs2", if you insist
18:17:19 <Jafet> @instances Num
18:17:21 <lambdabot> Double, Float, Int, Integer
18:17:48 <elliott> huh?
18:17:55 <Jafet> :t (+)
18:17:57 <lambdabot> Num a => a -> a -> a
18:18:03 <elliott> I have no idea what your point is, honestly... I know what (+)'s type is
18:19:06 <Jafet> So byteStringPlus :: Integral a => BS -> BS -> a?
18:20:19 <elliott> I would assume byteStringPlus :: ByteString -> ByteString -> Integer, but it really doesn't matter... the question makes sense either way
18:20:25 <elliott> er
18:20:25 <Heffalump> conal: I've run into this problem before too - GHC just won't infer that kind of equality.
18:20:33 <elliott> it's byteStringPlus :: ByteString -> ByteString -> ByteString, I mean
18:20:39 * elliott misread your question
18:20:52 <Jafet> You can't implement that without knowing which instance of (+)
18:20:58 <elliott> ??
18:20:58 <Jafet> that you're implementing
18:21:05 <conal> Heffalump: oh, hrmf. thx.
18:21:10 <elliott> I think you're misunderstanding something
18:21:28 <Heffalump> I'm fairly sure I asked about it, just trying to find the mailing list post
18:21:36 <elliott> a reformulation of the question would be "if you interpret a ByteString as a little-endian base-256 integer, how should you implement addition?"
18:22:16 <beaky> hello
18:22:27 <beaky> @hoogle Monad m => a -> m a
18:22:28 <lambdabot> Prelude return :: Monad m => a -> m a
18:22:28 <lambdabot> Control.Monad return :: Monad m => a -> m a
18:22:28 <lambdabot> Control.Monad.Instances return :: Monad m => a -> m a
18:22:39 <Jafet> I don't think "Integer" was mentioned anywhere
18:23:03 <Heffalump> conal: http://www.haskell.org/pipermail/glasgow-haskell-users/2007-December/013668.html
18:23:15 * conal looks
18:23:39 <beaky> what would haskell code look like without type inference?
18:23:49 <catsbydlo> Terrible!
18:24:17 <conal> Heffalump: yep. same issue. oh well. thx for the pointer.
18:24:28 <Jafet> Like not haskell code
18:24:32 <tam1138> hello
18:25:20 <elliott> Jafet: ok, so your objection is that (+) and (*) can be overloaded to do arbitrary things that do not obey any reasonable laws? I don't think that's really reasonable... people assume some kind of mathematical reasonability from Num/etc., unless they're using it for introspection (a la simple-reflect)...
18:25:28 <elliott> this doesn't really seem related to your original objection though
18:25:30 <elliott> anyway, whatever
18:26:25 <Jafet> So all the Data.Int instances are unreasonable?
18:26:27 <Jafet> O kay
18:26:30 <sclv> holy moley, it works
18:26:53 <sclv> i'm using llvm bindings to generate assembly for dfa on the fly
18:27:04 <sclv> now i just need to decide what to build on top of it
18:27:33 <sclv> propositional logic over columnar stores was my initial use case, so i could stick to that
18:27:38 <tam1138> i love haskell, but i have only a shallow understanding of it, particularly things i've only heard of but haven't seen demonstrated, like lenses and transformers.  is there a list of "type classes everybody should know" with accompanying documentation?
18:27:40 <elliott> Jafet: a reasonable byteStringPlus's meaning will overflow when the sum of its meanings would...
18:27:55 <elliott> tam1138: there's the typeclassopedia
18:27:57 <elliott> @where typeclassopedia
18:27:57 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
18:28:07 <edwardk> tam1138: lenses are a fairly recent innovation, despite all the chatter here about them
18:28:23 <tam1138> elliott: i'm actually going through that now :)
18:28:26 <sclv> but the idea of building, e.g. zeptoparsec is also very tempting
18:28:44 <sclv> like an applicative parser that throws the parsing component directly to llvm
18:28:49 <elliott> sclv: LLVM JITting parser combinator library would be the coolest thing
18:28:57 <beaky> are Lists monads?
18:29:02 <elliott> beaky: [] is a monad
18:29:06 <beaky> ah
18:29:22 <elliott> sclv: you could even implement Monad by JITting each part separately
18:29:23 <sclv> its such a fun idea for a toy -- just turn your problems into dfa and throw llvm at them
18:29:27 <beaky> > [1..10] >>= show
18:29:29 <lambdabot>   "12345678910"
18:29:42 <elliott> (and if you use some fancy tricks with unsafePerformIO and observable sharing type stuff you could even have it optimise away some "applicative" uses of monads, I guess (e.g. arising from do notation))
18:29:43 <sclv> hrm -- that sounds tricky?
18:29:48 <tam1138> edwardk: thanks.  i feel like "recent innovations" are adopted pretty quickly, leaving those of us lacking a solid understanding of the underlying fundamentals running even further behind
18:29:57 <sclv> like it would have to generate code on the fly, right?
18:30:04 <elliott> sclv: well, at the simplest you could just have a "Bind" node in your AST
18:30:06 <sclv> as opposed to something i could just "compile once" to llvm
18:30:12 <elliott> well, right
18:30:20 <elliott> but if you have your compilation packaged into a function that's not so much work
18:30:21 <sclv> yeah, that'll kill performance :-)
18:30:25 <elliott> this isn't required to make it useful, of course, it'd just be cool :)
18:30:38 <sclv> it would be less efficient than just doing it in haskell tho :-(
18:30:40 <elliott> sclv: right, so it'd need said optimisations to be useful in practice... just thinking
18:30:43 <edwardk> tam1138: part of the issue with lenses is we're still trying to find a good way to present them pedagogically
18:30:48 <elliott> pfft, just doing things in Haskell is so passe
18:31:02 <sclv> the applicative interface i have in mind is it just spits out numbers for where the parser recognizes meaningful fragments
18:31:05 <Jafet> I have a feeling that you should usually leave compilation to the compiler
18:31:13 <sclv> then we chop those back up and feed them to the right parts of the haskell layer
18:31:38 <sclv> building these sorts of things to play well with streaming is a whole other tricky bit
18:31:42 <elliott> nothing wrong with JITs
18:32:29 <sclv> jits are great. but generating code on the fly and passing in and out of it will, i'm sure, have a high cost
18:32:30 <catsbydlo> my intuition for now is lenses are like .foo member lookup, except functional and nestable and read/write and with three tons of sugar
18:32:50 <edwardk> catsbydlo: and able to deal with multiple targets
18:32:58 <Jafet> I don't think people are meant to understand how lens works anyway
18:33:00 <edwardk> since we have traversals, etc.
18:33:21 <sclv> i'm thinking of just starting with a regex frontend, but it seems not so easy to just rip out the core of text.regex.tdfa and compile it down
18:33:29 <catsbydlo> I read that traversals are like traverse but I don't know traverse
18:33:32 <sclv> because it plays tricks with laziness and stuff
18:33:47 <tam1138> edwardk: cool, thanks
18:34:00 <edwardk> catsbydlo: have you ever used mapM?
18:34:04 <catsbydlo> yes
18:34:11 <edwardk> catsbydlo: then you understand traversable
18:34:16 <catsbydlo> hah
18:34:19 <edwardk> it puts a class on mapM
18:34:27 <catsbydlo> or else it gets the hose again?
18:34:28 <edwardk> 'things that you can mapM'
18:34:44 <edwardk> traverse is just a slightly generalized mapM
18:34:54 <edwardk> it works with an arbitrary Applicative rather than just a Monad
18:35:01 <catsbydlo> I can imagine a few different generalizations
18:35:08 <catsbydlo> :t mapM
18:35:09 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
18:35:15 <edwardk> so we generalize it two ways
18:35:20 <edwardk> Monad m becomes Applicative m
18:35:30 <edwardk> and then the [a] becomes other container types
18:35:34 <catsbydlo> (Monad m, List f) => (a -> m b) -> f a -> m [b]
18:35:35 <edwardk> :t traverse
18:35:36 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
18:35:59 <catsbydlo> ah, it generalizes the result type too (and to the same type)
18:36:03 <edwardk> yeah
18:36:15 <edwardk> our 'List' class btw- is 'Foldable'
18:36:26 <edwardk> :t toList
18:36:28 <lambdabot>     Not in scope: `toList'
18:36:28 <lambdabot>     Perhaps you meant one of these:
18:36:28 <lambdabot>       `Data.Foldable.toList' (imported from Data.Foldable),
18:36:33 <edwardk> :t Data.Foldable.toList
18:36:35 <lambdabot> Foldable t => t a -> [a]
18:36:50 <Jafet> :t fold
18:36:52 <lambdabot> (Foldable t, Monoid m) => t m -> m
18:36:53 <edwardk> that is a superclass of traversable
18:37:07 <catsbydlo> @src Traversable
18:37:08 <lambdabot> class (Functor t, Foldable t) => Traversable t where
18:37:08 <lambdabot>     traverse    :: Applicative f => (a -> f b) -> t a -> f (t b)
18:37:08 <lambdabot>     sequenceA   :: Applicative f => t (f a) -> f (t a)
18:37:08 <lambdabot>     mapM        :: Monad m => (a -> m b) -> t a -> m (t b)
18:37:08 <lambdabot>     sequence    :: Monad m => t (m a) -> m (t a)
18:37:13 <sclv> anyway, i haven't generated assembly in years. the bindings make it surprisingly pleasant
18:37:18 <edwardk> so you can write the signature you thought of, by traversing and then applying toList  under your monad with liftM
18:37:37 <edwardk> the minimal definition is 'traverse'
18:37:39 <Jafet> llvm assembly is much more pleasant than real assembly yes
18:37:44 <sclv> except for llvm, truly irritatingly, forcing you to terminate every block, instead of giving you fallthrough
18:37:53 <sclv> or auto-inserting the jumps
18:38:02 <catsbydlo> effectful transformation of the values in a container
18:38:22 <edwardk> catsbydlo: exactly. you can walk the container and modify the elements, with side effects in some monad or applicative.
18:38:25 <sclv> luckily i'm just doing dfa type stuff, so i can mainly avoid this phi nonsense too
18:38:32 <edwardk> :t both
18:38:34 <lambdabot> Applicative f => (a -> f b) -> (a, a) -> f (b, b)
18:38:48 <edwardk> if you squint, that kind of looks like the signature of 'traverse'
18:39:00 <sclv> there's one place i can use a proper phi to eliminate a pointer, but it seems like such a mess i can't decide if its worth it
18:39:04 <edwardk> replace 't a' with (a,a) and 't b' with (b,b)
18:39:10 <catsbydlo> yes, if Join (,) was a type
18:39:10 <edwardk> thats what i call a 'traversal'
18:39:19 <edwardk> :t traverse.traverse
18:39:21 <lambdabot> (Applicative f, Traversable t1, Traversable t) => (a -> f b) -> t (t1 a) -> f (t (t1 b))
18:39:46 <edwardk> here t (t1 a)   and t (t1 b) take the place of t a   and t b    in the original traverse definition
18:39:58 <edwardk> :t Data.Text.Strict.Lens.text
18:40:00 <lambdabot> (Applicative f, Indexable Int k) => k (Char -> f Char) (Data.Text.Internal.Text -> f Data.Text.Internal.Text)
18:40:15 <edwardk> here 'Text' takes the place of 't a' and 't b'
18:40:55 <edwardk> this is how a traversal generalizes traverse from Traversable.
18:41:06 <edwardk> now everything in Data.Traversable is defined in terms of 'traverse'
18:41:17 <edwardk> so we provide analogues to those functions that takes any traversal
18:41:22 <edwardk> :t mapMOf both
18:41:24 <lambdabot> Monad m => (a -> m b) -> (a, a) -> m (b, b)
18:41:35 <catsbydlo> wait, now it makes sense that stuff reads left to right
18:41:47 <edwardk> =)
18:41:49 <catsbydlo> that's not what you were explaining but I'll take what I get
18:42:10 <edwardk> :t traverse.both
18:42:12 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t (a, a) -> f (t (b, b))
18:42:39 <edwardk> yeah the fact that its cps'd like that gives you the counter-intuitive argument order
18:44:31 <catsbydlo> :t mapMOf
18:44:32 <lambdabot> LensLike (WrappedMonad m) s t a b -> (a -> m b) -> s -> m t
18:45:08 <edwardk> :t mapMOf _1
18:45:10 <lambdabot> (Monad m, Field1 s t a b) => (a -> m b) -> s -> m t
18:45:22 <catsbydlo> :t _1
18:45:23 <lambdabot> (Functor f, Field1 s t a b) => (a -> f b) -> s -> f t
18:45:30 <edwardk> > mapMOf _1 (\x -> [x,x + 1]) (10,20)
18:45:33 <lambdabot>   [(10,20),(11,20)]
18:45:41 <edwardk> > mapMOf both (\x -> [x,x + 1]) (10,20)
18:45:43 <lambdabot>   [(10,20),(10,21),(11,20),(11,21)]
18:46:19 <catsbydlo> wait, now I need to think about [] in terms of effects
18:46:29 <catsbydlo> to explain why it bubbles to the top
18:46:45 <Jafet> [] is the effect
18:46:57 <catsbydlo> yes
18:47:02 <edwardk> :t mapMOf both putStrLn ("hello","world")
18:47:04 <lambdabot> IO ((), ())
18:47:08 <edwardk> :t mapMOf_ both putStrLn ("hello","world")
18:47:09 <lambdabot> IO ()
18:47:39 <edwardk> interestingly because IO is applicative:
18:47:42 <catsbydlo> subtyping without subtypes
18:47:43 <edwardk> :t both putStrLn ("hello","world")
18:47:45 <lambdabot> IO ((), ())
18:54:06 <catsbydlo> :t \f (a, b) -> f a *> f b *> pure ()
18:54:08 <lambdabot> Applicative f => (t -> f a) -> (t, t) -> f ()
18:54:26 <catsbydlo> :t \f (a, b) -> (,) <$> f a <*> f b
18:54:27 <lambdabot> Applicative f => (t -> f a) -> (t, t) -> f (a, a)
18:55:11 <elliott> catsbydlo: "both" in lens
18:55:13 <elliott> :t both
18:55:14 <lambdabot> Applicative f => (a -> f b) -> (a, a) -> f (b, b)
18:55:21 <catsbydlo> o rly
18:55:48 <beaky> does haskell have bitfields?
18:55:55 <edwardk> beaky: no
18:56:01 <beaky> ah
18:56:14 <edwardk> beaky: its hard to evaluate them lazily ;)
18:56:19 <beaky> oh right
18:56:35 <beaky> maybe I can use something else to represent the roguelike world
18:56:42 <catsbydlo> bytefields?
18:56:59 <edwardk> you can make up a data type that represents your bitfield and then provide masks on it, etc.
18:57:09 <beaky> ah
18:57:09 <edwardk> you just have to do it by hand
18:57:17 <edwardk> with enough combinators nothing stops you from doing it
18:57:26 <catsbydlo> but what if I don't have 2MB of memory to store all game state?
18:57:39 <beaky> hehe
18:58:17 <bootcode> beaky: algebraic data types are bitfields on steroids ;)
18:58:38 <bootcode> or rather bits on steroids?
18:58:58 <startling> steroids on bitfields
18:59:11 <startling> monoids on steroids
18:59:17 <beaky> ^^
18:59:57 <beaky> I'm struggling to implement my roguelike :( I don't know the best way to represent everything
19:00:39 <bootcode> data Cell = Empty | Player PlayerStatus | Enemy EmemyStatus
19:00:47 <bootcode> type Pos = (Int, Int)
19:00:55 <catsbydlo> class Steroid a
19:01:10 <bootcode> type World = [(Pos, Cell)]
19:01:18 <beaky> lol
19:01:26 <bootcode> approximately enough to get started :)
19:01:58 <startling> newtype Cell = Cell [Monster]
19:02:03 <beaky> ah, but can't Cells have items as well?
19:02:10 <beaky> or even doodads
19:02:15 <bootcode> well, as you wish
19:02:27 <beaky> and why not have players and monsters be both Creatures :D
19:02:28 <startling> beaky: data Cell = Cell [Monster] [Item]
19:03:22 <edwardk> beaky: my recommendation is to write 'intuitive' haskell for now, and only later figure out if you need to move to bitfields, etc.
19:03:28 <beaky> ah
19:04:03 <beaky> right. I need all the elegance of haskell I can get :D
19:04:21 <edwardk> e.g. data Flag = Sticky | Whatever           and then just use Set Flag
19:04:29 <edwardk> and later on you may find that that sucks
19:04:39 <edwardk> but you can get alarmingly far without replacing that sort of thin
19:05:02 <beaky> roguelikes seem pretty complex
19:05:20 <Jafet> Just read nethack code, see how slow it really is
19:05:39 <beaky> I think I'll bail and implement a sidescrolling shooter instead :D
19:05:53 <beaky> but I've already done so much :(
19:06:06 <Jafet> Side scrolling rogue
19:06:08 <bootcode> beaky: rouge is better for first, since it is turn-based
19:06:09 * elliott thinks implementing a roguelike in Haskell sounds easier than implementing a sidescrolling shooter
19:06:21 <elliott> no realtime (hence performance) worries, no (or fewer) graphics library worries
19:06:36 <beaky> right
19:06:59 <Jafet> Well, talking to xterm is more aggravating than to opengl
19:07:04 <bootcode> try limiting the scope - e.g. no full rougelike support, but only 1 kind of enemy, only 1 kind of item (or even no items at all), only a single room, goal is to get to the door without getting hit by monster
19:07:17 <bootcode> and then build up stuff from there
19:07:28 <catsbydlo> DWARF FORTRESS
19:07:30 <simpson> GL is indeed easier than ANSI, at least IMO.
19:07:37 <bootcode> Jafet: curses lib is fun (if windows support is not needed)
19:07:50 <elliott> so use vty
19:07:51 <Jafet> forall n. n curses
19:07:55 <elliott> or one of the thousand ncurses bindings
19:08:25 <beaky> vty seems nice; it can do the TUI for me :D
19:08:33 <Jafet> curses is so terrible that dwarf fortress uses opengl to emulate a terminal
19:08:40 <bootcode> rendering is not important - you can play rouge in ghci
19:09:03 <beaky> maybe even in lambdabot :D
19:09:24 <tsuraan> How is one supposed to specify a MonadError constraint on a function? I have a function using `throwError "foo"`, and I expect that the function's signature would be `(MonadError String m) => m a`, but ghc says that's invalid without flexible contexts
19:10:13 <catsbydlo> tsuraan: enable flexible contexts
19:11:07 <tsuraan> the exact error when using a constraint of `MonadError String m` is "Non type-variable argument in the constraint: MonadError String m".  What does that mean?  Enabling flexible contexts does work, but is there something I'm doing wrong?
19:11:39 <Jafet> String is not a type variable
19:12:12 <tsuraan> ok, fair enough :)
19:12:43 <tsuraan> if I replace the String with `e`, it likes that even less
19:12:56 <tsuraan> well, the error message is longer, anyhow.  I assume that means it likes it less
19:13:18 <Jafet> "foo" is not an e
19:13:26 <beaky> also, I wonder how I'm going to represent creatures; there are so many different creatures, from the player character to bunnies to dragons, slimes, liches, humanoids, aliens, etc. Maybe some haskell feature can help here?
19:14:01 <beaky> atm creatures are just bags of data attributes and functions
19:14:09 <startling> beaky: sounds right
19:14:11 <tsuraan> so the flexible type instances is what's allowing me to specify a concrete type instead of a type variable?
19:14:11 <beaky> and they each keep track of their location
19:14:22 <Jafet> @faq can haskell read sicp for me?
19:14:23 <lambdabot> The answer is: Yes! Haskell can do that.
19:14:32 <startling> 8)
19:14:36 <tel> In Wadler's "Theorems for Free" he mentions in the intro that the whole thing can be stated more concisely as lax natural transformations and that it'll be the subject of a later paper. Does anyone have that citation?
19:14:40 <Jafet> > "FlexibleContexts" == "FlexibleInstances" -- tsuraan
19:14:42 <lambdabot>   False
19:15:09 <Jafet> The former is harmless (so is the latter by itself, but it's a well-known gateway to II)
19:15:14 <tsuraan> yeah, flexible contexts.  no idea why I said instances
19:15:28 <reinterpret_cast> Is there anything like a mutable ByteString inside ST, which can be turned into a regular ByteString upon exiting ST?
19:15:46 <startling> reinterpret_cast: not that I know of. :(
19:15:49 <startling> it sucks
19:15:59 <startling> you can do an MArray Char or whatever though
19:16:00 <Jafet> Sure, implement it with unsafeIOToST
19:16:04 <startling> errrr
19:16:08 <startling> MArray Word8
19:16:25 <applicative> reinterpret_cast: Data.Vector.Mutable.MVector Word8
19:17:03 <applicative> ByteString -> Vector Word8 is V.unfoldr B.uncons
19:17:05 <reinterpret_cast> applicative: When quitting ST, the contents of the MVector would have to be *copied* into the ByteString, right? :-|
19:17:15 <reinterpret_cast> ST/IO/whatever
19:17:34 <applicative> reinterpret_cast: with 'unsafeFreeze' no
19:17:45 <reinterpret_cast> :-O What does unsafeFreeze do?
19:18:00 <mikeplus64> probably mutable something -> immutable something
19:18:01 <applicative> it makes the mutable vector into a regular vector
19:18:11 <Jafet> I think unsafeFreeze is the least unsafe part of turning a Vector into a ByteString
19:18:20 <reinterpret_cast> applicative: Oh, sweet.
19:18:37 <reinterpret_cast> Well, I can live with mutable/immutable Vectors of Word8.
19:18:39 <applicative> Vector -> ByteString is B.unfoldr V.uncons
19:18:44 * startling casts unsafeBlizzaga
19:19:21 <sclv> we really should put scoped type variables in haskell prime
19:19:30 <sclv> feels so silly that i have to remember to add it
19:20:41 <Jafet> Just use Glasgow Haskell, the language recognized by the Glasgow Haskell compiler.
19:20:42 <shachaf> sclv: That would involve adding forall, right?
19:20:52 <sclv> yep
19:21:09 * shachaf approves of adding forall, even if just for rank-1 types.
19:21:45 <elliott> can we add th ebetter form of scoped type variables
19:21:47 <Jafet> What about all the enterprise legacy code that uses variables named "forall"
19:21:52 <elliott> where you get the scoping without having to add foralls for no reason
19:22:03 <elliott> (the better and more backwards compatibility-breaking)
19:22:51 <beaky> haskell's motto: success is failure
19:22:58 <beaky> what does that mean?
19:24:00 <beaky> oh it's "Avoid success at all costs"
19:24:42 <Jafet> Ignorance is strength
19:28:06 <applicative> reinterpret_cast: I should have said Data.Vector.Unboxed.Mutable.MVector Word8 and Data.Vector.Unboxed.Vector Word8
19:28:38 <reinterpret_cast> applicative: Yeah, I do not want each vector element to be a lazy thunk. :-|
19:29:19 <Fuuzetsu> @pl f x = map a (b x)
19:29:20 <lambdabot> f = map a . b
19:31:20 <reinterpret_cast> By the way, is the indexing scheme the only difference between Arrays and Vectors?
19:31:45 <adnam> beaky: read it as "avoid: success at all costs"
19:31:47 <applicative> Vector just uses Int indexes
19:32:21 <Jafet> Avoid "success at all" costs
19:32:39 <adnam> hehe
19:32:41 <elliott> reinterpret_cast: no
19:32:49 <applicative> reinterpret_cast: of course there are different optimizations happening; I prefer vector because the 'api' is so straightforward
19:39:43 <reinterpret_cast> applicative: elliott: Ah, I see.
19:48:10 <applicative> reinterpret_cast: of course if you really wanted to 'mutate' the bytestring you'd use Data.ByteString.Internal and ForeignPtr and suchlike unpleasantness thus http://benchmarksgame.alioth.debian.org/u64q/program.php?test=regexdna&lang=ghc&id=2
19:48:35 <applicative> but that would be wrong
19:56:03 <reinterpret_cast> Is it safe/okay to download and use a new version of a package that comes with GHC itself?
19:57:16 <Jafet> Yes. Mainly because GHC doesn't allow you to use it
19:58:00 <reinterpret_cast> Jafet: Oh. So there is no way for me to use, for example, bytestring-0.10.2.0 if GHC came with bytestring-0.10.0.0 ?
19:59:26 <rwbarton> it's probably more hassle than it's worth
19:59:49 <applicative> you  can certainly install and use it; there will be difficulties using things built on top of the old bytestring of course
20:00:07 <Jafet> That is technically possible, except you can't use anything that was built on bytestring-0.10.0.0
20:00:14 <reinterpret_cast> Ah, I see...
20:00:15 <Jafet> Decide if that is a problem for you
20:06:49 <beaky> what is the difference between lenses and zippers?
20:07:35 <edwardk> beaky: a lens is single a path to get to some element, a zipper lets you move around. the lens package provides zippers based on lenses so the distinction is pretty blurry now ;)
20:07:43 <edwardk> :t zipper
20:07:45 <lambdabot> a -> Top :> a
20:07:53 <beaky> ah
20:08:27 <edwardk> > rezip $ zipper ("hello","world") & downward _1 & fromWithin traverse & focus .~ 'j' & rightmost & focus .~ 'y'
20:08:30 <lambdabot>   ("jelly","world")
20:09:13 <edwardk> there i have a zipper that lets me go down and use lenses and traversals to drill deeper
20:09:25 <edwardk> and then i can move around within the layers i've built up
20:11:01 <beaky> so the & operator composes lenses?
20:11:08 <edwardk> :t (&)
20:11:09 <lambdabot> a -> (a -> b) -> b
20:11:12 <edwardk> its just flip (.)
20:11:14 <edwardk> er
20:11:16 <edwardk> flip ($)
20:11:20 <edwardk> :t flip ($)
20:11:22 <lambdabot> b -> (b -> c) -> c
20:11:29 <edwardk> :t flip id
20:11:30 <lambdabot> b -> (b -> c) -> c
20:11:34 <beaky> oh
20:11:41 <edwardk> :t downward
20:11:42 <lambdabot> SimpleLensLike (Context a a) s a -> (h :> s) -> (h :> s) :> a
20:11:59 <edwardk> :t rightmost
20:12:01 <lambdabot> (a :> b) -> a :> b
20:12:27 <shachaf> !list
20:12:28 <monochrom> shachaf: http://hpaste.org
20:12:32 <shachaf> thanks monochrom
20:12:34 <edwardk> :t zipper ("hello","world") & downward _1
20:12:35 <lambdabot> (Top :> ([Char], [Char])) :> [Char]
20:13:04 <edwardk> thats saying that that is a zipper that starts at a pair of strings, and which is looking at strings in it. here it only has one target
20:13:19 <edwardk> :t zipper ("hello","world") & downward _1 & fromWithin traverse
20:13:21 <lambdabot> ((Top :> ([Char], [Char])) :> [Char]) :> Char
20:13:37 <edwardk> that adds another layer where we're looking at the individual characters in that string
20:16:18 <beaky> and .~ is the setter operator?
20:16:23 <beaky> :t (.~)
20:16:25 <lambdabot> Setting s t a b -> b -> s -> t
20:16:29 <beaky> ah
20:23:20 <beaky> are lenses related to monads?
20:23:28 <edwardk> not really
20:25:03 <applicative> much simpler than monads
20:25:15 <applicative> if you dont look at the actual types
20:25:19 <beaky> ah
20:25:22 <applicative> > _1 .~ "goodbye" $ ("hello","cruel","world")
20:25:24 <lambdabot>   ("goodbye","cruel","world")
20:25:46 <applicative> > ("hello","cruel","world") & _1 .~ "goodbye"
20:25:48 <lambdabot>   ("goodbye","cruel","world")
20:25:55 <beaky> so .~ seems to be a particular kind of setter
20:26:13 <beaky> one that just changes a field to a new value
20:26:30 <applicative> right given a lens for that field as first argument
20:27:31 <applicative> > ("goodbye","cruel","world") ^. _1
20:27:33 <lambdabot>   "goodbye"
20:27:40 <dylukes> Lens syntax: it's like APL all over again.
20:27:54 <dylukes> No one let edwardk anywhere near -XUnicodeSyntax.
20:27:55 <applicative> so (^.) is the main 'getter' operation, or accessor
20:28:09 <edwardk> beaky: in the vocbaulary of lens we'd usually say that .~ takes a Setter, and sets its targets to a given value.
20:28:20 <edwardk> rather than .~ is a setter.
20:28:34 <dylukes> My god, it has its own lexicon already. It's a cult, I say.
20:28:38 <edwardk> over takes a Setter and applies a function to each one of its targets
20:28:46 <applicative> the Setter is the lens
20:28:49 <edwardk> also i don't like unicode syntax
20:29:09 <edwardk> it turns programming from an easy bidirectional acitivity into the 'lets find the codepoint' game
20:29:14 <beaky> haha
20:29:22 <applicative> dylukes: it's a good cult; here have some cookies.
20:29:34 <beaky> and my terminal doesn't show unicode stuff so nicely :(
20:29:43 * dylukes backs away slowly.
20:29:52 <dylukes> These cookies have pieces of broken eyeglasses in them.
20:29:54 <dylukes> Lens cookies D:.
20:30:01 <dylukes> THE LENS CULT IS TARGETING ME.
20:30:10 <dylukes> They've set their sights on me.
20:30:33 <Jafet> Open your heart to the divine truth and be touched by the contact lens
20:30:35 <dylukes> They're get'ting their knives and want to s t a b me.
20:31:30 <edwardk> have you accepted the lens into your heart?
20:31:31 <beaky> lenses seem great for those nested structures I end up making in my roguelike :(
20:33:36 <beaky> when pattern matching ends up making my code look like 'f (Foo (Bar x y z) (Baz (Qux a b c) d e) f g h i) = Foo (Bar x y (z + 1)) (Baz (Qux a b c) d e) f g h (i - 1)
20:34:41 <beaky> btw, does ghc really make a whole copy of my data structure just to increment a field? :D
20:34:42 <reinterpret_cast> How do I "reinterpret" a Word8 as an Int8?
20:34:57 <beaky> unsafeCoerce?
20:35:15 <edwardk> beaky: data structures in haskell tend to be very small
20:35:24 <beaky> ah
20:35:26 <reinterpret_cast> beaky: I'm not really familiar with the unsafe* functions.
20:35:28 <edwardk> :t fromIntegral
20:35:30 <Jafet> Normally I would answer unsafeCoerce, but the problem here is that it actually works
20:35:30 <lambdabot> (Integral a, Num b) => a -> b
20:35:46 <edwardk> beaky: keep in mind you're used to thinking of whole data structures as being everything underneath it too
20:35:53 <beaky> right
20:35:56 <edwardk> here its a handful of pointers to immutable data that it can share
20:36:18 <edwardk> so if you edit one key in a map it only has to make a logarithmic amount of new stuff and shares almost everything else with the original map
20:36:48 <Jafet> GHC doesn't "make a copy" of anything, ever
20:36:53 <beaky> I saw an illustration somewhere of how neat it is to update a purely functional data structure
20:37:35 <reinterpret_cast> > unsafeCoerce (128 :: Word8) :: Int8
20:37:37 <lambdabot>   Not in scope: `unsafeCoerce'
20:38:00 <edwardk> so while you may locally copy a few more words when editing any one thunk within that structure that you might in an ideally tuned imperative structure where you 'know' you'll never access it in a non-ephemeral situation, it turns out that the imperative approach is fairly brittle, in that you often later _want_ to break those self-imposed invariants to get parallelism, etc.
20:38:14 <edwardk> reinterpret_cast: fromIntegral was for you =P
20:38:24 <edwardk> > fromIntegral (128 :: Word8) :: Int8
20:38:25 <lambdabot>   -128
20:38:33 <reinterpret_cast> edwardk: Ah! Nice! Thanks!
20:45:30 <monadicity> can someone show me how to  turn a number into base 5?
20:45:49 <monadicity> in haskell
20:45:57 <Jafet> :t showIntAtBase
20:45:58 <lambdabot> (Integral a, Show a) => a -> (Int -> Char) -> a -> ShowS
20:46:15 <catsbydlo> > showIntAtBase 5 intToDigit 2 ""
20:46:17 <lambdabot>   "2"
20:46:22 <monadicity> thnaks
20:46:26 <monadicity> > showIntAtBase 5 intToDigit (10^100) ""
20:46:28 <beaky> wow
20:46:28 <lambdabot>   "10241422120332320213311333103110222010033001000000000000000000000000000000...
20:58:54 <gaze__> How can I get attoparsec to eat input until the end of the input OR until I hit a space?
20:59:52 <catsbydlo> many (noneOf " ")  -- is that valid attoparsec?
21:01:02 <gaze__> well, I'm getting a Partial _
21:01:09 <gaze__> because the string terminates earily
21:01:14 <gaze__> it wants a space
21:01:28 <gaze__> I mean yes, but that's effectively the same as what I'm doing now
21:01:40 <catsbydlo> sorry, I only know regexes
21:04:14 <gaze__> I hope you don't do your big parsing jobs with them :)
21:07:22 <shachaf> !list
21:07:22 <monochrom> shachaf: http://hackage.haskell.org/packages/archive/pkg-list.html
21:08:21 <johnw> gaze__: have you try using satisfy?
21:12:01 <reinterpret_cast> Is there any type like ByteString, but which does not keep internal information regarding its own size?
21:12:39 <catsbydlo> Ptr CChar
21:12:56 <johnw> aka CString
21:13:22 <gaze__> ahh... I need to use parseonly
21:14:04 <mercer> hello. if someone has accoustical upright or grand piano could you please measure the height of the pedal?  from the floor to the top of the pedal
21:14:21 <mercer> wrong channel :|
21:15:19 <applicative> mercer, there's a lens for that
21:15:27 <reinterpret_cast> Can I allocate CStrings in regular Haskell code?
21:15:34 <mercer> applicative :)
21:15:36 <johnw> reinterpret_castmalloc
21:15:55 <johnw> ptr <- mallocBytes 1000 :: CString
21:16:07 * applicative proposes to reinterpret_castmalloc too
21:16:17 <mercer> there is also newCString
21:16:43 <johnw> yeah, Foreign.C.String has lots of goodies
21:16:48 <reinterpret_cast> :-O Nice. So I can program in C without using that horrible syntax!
21:17:59 <shachaf> I think Haskell syntax is worse than C syntax for writing Cish code.
21:18:02 <applicative> are you sure 'do ptr <- mallocBytes 1000 :: CString' is more advanced syntax
21:18:16 <sorbo_> !id Hello!
21:19:35 <sorbo_> !quit
21:19:44 <shachaf> !list
21:19:44 <monochrom> shachaf: http://hackage.haskell.org/packages/archive/pkg-list.html
21:19:51 <beaky> games are so complex to make :(
21:19:55 <beaky> even in haskell :D
21:20:00 <applicative> !list
21:20:12 <roconnor> beaky: even hex?
21:20:23 <beaky> hex? what's that
21:20:31 <roconnor> @google hex game
21:20:33 <lambdabot> http://en.wikipedia.org/wiki/Hex_(board_game)
21:20:33 <lambdabot> Title: Hex (board game) - Wikipedia, the free encyclopedia
21:20:37 <sorbo_> SPOCK you are doing a bad job.
21:21:11 <Clint> is spock_ your poorly-written bot?
21:22:02 * applicative is finding  this all very confusing
21:25:17 <Jafet> Obligatorily
21:25:22 <Jafet> @let xo s=let[p,q]=(show=<<).(`elemIndices`filter(/='|')s)."XO";i(n,[])=":-"++["(|O"!!(n+1)];i(_,q)=c q."012|345|678"++if w q then" :-)"else"";c q x|x=='|'='|'|elem x p='X'|elem x q='O'|True='.';w p=ap(==)(sort.intersect p)`any`words"012 345 678 036 147 258 048 246";n=first(0-);x a b p q|w p=(1,[])|w q=(-1,[])|True=z$(:p).(['0'..'8']\\union p q)where z[]=(0,[]);z m=foldr y a m;y p a|a<b=max a(fst.n$x(n b)(n a)q p,p)|True=a;in i$x(-1,[])(1,[])q p
21:25:25 <lambdabot>  Defined.
21:25:31 <Jafet> > xo "...|X..|..."
21:25:33 <lambdabot>   "...|X..|O.."
21:26:35 <sorbo_> !id hello!
21:26:35 <spock_> hello!
21:26:43 <sorbo_> much better
21:27:01 <shachaf> This is not the channel to test your bots in.
21:27:10 <sorbo_> sorry.
21:27:12 <sorbo_> !quit
21:27:30 <Jafet> Aww, I wanted to quine it first
21:29:14 <popl> Jafet: any qcheese?
21:29:28 <mercer> is MVar appropiate only when one thread writes to it and other reads from it?  I
21:29:58 <mercer> what should I use if same thread that writes to it also has to read from it?
21:31:08 <johnw> mercer: IORef?
21:31:17 <c_wraith> MVar is appropriate when you want reads to block when there's no data, and writes to block when there is data.
21:31:19 <Jafet> A thread can read from and write to the same MVar.
21:32:59 <mercer>  not when there's anothre thread that reads from it. at least I didn't find a way to make it work
21:33:07 <mercer> without deadlocks
21:33:22 <c_wraith> MVar is good when it has the semantics you want
21:33:38 <c_wraith> If you want different semantics, tells us what they are
21:33:52 <shachaf> mercer: "reading" is not one of the primitive operations on an MVar
21:33:58 <Jafet> My program deadlocks, MVar sucks
21:33:59 <shachaf> The primitive operations are taking and putting.
21:34:15 <mercer> one thread only reads from MVar, another modifies MVar. I solved this by keeping both the MVar and another variable, but it seems odd passing both everywhere
21:34:28 <mercer> and updating both
21:34:57 <c_wraith> that...  totally fails to actually explain to us what semantics you want
21:35:24 <mercer> I want one thread to read from a variable, and another to read and write to it (ie to modify it)
21:35:42 <c_wraith> Do you want blocking? Notification?
21:35:49 <c_wraith> What semantics do you want?
21:36:10 <shachaf> c_wraith: Is "I want it to work" a semantics?
21:36:14 <c_wraith> no
21:36:18 <shachaf> :-(
21:36:39 * shachaf can't tell whether "semantics" is singular or plural or what.
21:36:48 <Jafet> Someone should formalize IWITW
21:36:53 <popl> yes
21:36:57 <popl> shachaf: ^
21:37:06 <Jafet> There seems to be a broad demand for it
21:37:10 <mercer> it would be nice if reader thread blocked until value is changed
21:37:25 <shachaf> Maybe what you want is STM and TVars.
21:37:36 <mercer> I can do this myself though, so I just need a safe way to read from multiple threads, where one also writes to a var. I would use locks in another language
21:37:36 <shachaf> (Or maybe not.)
21:37:40 <popl> shachaf: semantics is both the plural and singular form. :)
21:38:18 <rwbarton> there's no unsafe way to do it
21:38:42 <popl> shachaf: you can say semasiology if you are referring to the science of it in particular.
21:38:54 <Jafet> People attach a lot of weight to semantics, so it must be a mass noun.
21:39:09 <mercer> rwbarton, doing it with MVar is unsafe. if reader thread reads from a variable before a writer thread, writer thread will deadlock trying to modify it's value
21:39:18 <rwbarton> that's not "unsafe"
21:39:20 <rwbarton> that's just you doing it wrong
21:39:51 <rwbarton> what are you doing in the reader thread, taking the MVar?
21:40:16 <popl> Jafet: It's a very forceful noun.
21:40:21 <mercer> yes.. reader thread shoud block until the var is updated
21:40:30 <rwbarton> sigh.
21:42:46 <popl> Jafet: get it? because mass != weight
21:43:04 <popl> nevermind
21:43:07 * popl sees himself out
21:44:51 <gaze__> hmm... how do I get parsec to try a parser, and if it fails, try a different one?
21:45:07 <johnw> a combination of try and <|>
21:45:20 <johnw> try (some-deep-parsing-chain) <|> another-parser
21:45:33 <johnw> try will cause it to rewind the token stream before attempting another-parser
21:52:11 <mercer> what I basically want is something like TVar shared between reader and writer thread that won't block when the writer thread modifies it's value (reads it's current value and writes a new one)
21:52:30 <mercer> something like MVar*
22:13:16 <latermuse> :q
22:13:21 <latermuse> oops wrong window, sorry
22:16:22 <sclv> ok i want a good name for my dfa -> llvm library
22:16:34 <sclv> i'm thinking Control.Automata.LLVM as the module namespace
22:16:54 <sclv> but a cute name would be awesome
22:17:35 <sclv> (just hooked it up to my prop logic simplifier, so now it can handle transitions based on standard propositional logic)
22:28:48 <rtpg> Is there a document out there that explains how ghc figures out instances?
22:29:24 <rtpg> Mainly when used in compbination with functional dependencies
23:06:17 <monadicity> if a magician flips a weird looking coin and it shows up heads.. then he hands you it and you look and one side is heads another is tails you are to flip it.. what probability is of getting tails?
23:06:43 <`nand`> depends on what you bet on
23:06:58 <monadicity> llol
23:11:09 <statusfailed> monadicity: does it have an interesting answer?
23:11:20 <monadicity> I think answer is 0.5
23:18:48 <statusfailed> monadicity: aww :D
23:51:17 <shachaf> @where rts-xc
23:51:17 <lambdabot> ghc -prof -fprof-auto -rtsopts -osuf .p_o foo.hs && ./foo +RTS -xc # print stack traces on unhandled exceptions
