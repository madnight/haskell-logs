01:01:11 <Taneb> Hmm
01:01:36 <Taneb> I'm looking at edwardk's package (just started looking so it's all really new)
01:01:46 <Taneb> *machines package
01:03:11 <AfC> I assume that if I upload a new package to Hackage that has an unsatisfied dependency the upload will fail?
01:03:19 <Taneb> No
01:03:28 <Taneb> I found out the hard way after missing a decimal point
01:04:17 <Taneb> family-tree-3.0.0.0 wants a version of containers somewhere between 0.42 and 0.6
01:08:06 * hackagebot sym 0.4.1 - Permutations, patterns, and statistics  http://hackage.haskell.org/package/sym-0.4.1 (AndersClaesson)
01:25:16 <AfC> Taneb: heh
01:26:07 <AfC> Taneb: so in this case, the library I depend on hasn't been released yet. I assume that means that the Haddock documentation won't generate at all (due to compile failure?)
01:26:37 <Taneb> If I were you I'd hold your horses
01:27:24 <Taneb> Wait until the lib gets released and release then
01:27:34 <Taneb> I've got family-tree 3.1.0.0 all ready now
01:29:01 <Taneb> But it needs lens-3.7
01:29:03 <Taneb> *8
01:30:11 <AfC> Taneb: fair enough, I'll wait.
01:30:43 <AfC> (it's a case of wanting someone to have a review of the API as much as anything. I'll post the Haddock I've generated elsewhere)
01:31:37 <Taneb> What library, by the way?
01:33:52 <peterGriffin> I get this error when using a record defined in a module of mine, in an another module of mine: `fieldName' is not a (visible) constructor field name, I did export the field accessors too. Whats the problem?
01:34:24 <Taneb> What does ":t fieldName" give you?
01:34:46 <shachaf> peterGriffin: How did you export the field accessors?
01:35:31 <peterGriffin> module Cargs ( RecordConstructor,    fieldAccessor1, fieldAccessor2 ) where
01:35:38 <peterGriffin> shachaf:
01:36:33 <shachaf> Try RecordConstructor(..)
01:36:37 <peterGriffin> Taneb: fieldName :: RecordConstructor -> Int
01:36:52 <shachaf> Hmm, no.
01:36:55 <shachaf> Sorry.
01:46:09 <cmccann> shachaf, out of curiosity, do you ever sleep?
01:46:12 <cmccann> my sleep schedule is incoherent at best but no matter at what absurd hour I'm on IRC you always seem to be here.
01:46:19 <cmccann> are you a robot?
01:48:04 <Taneb> cmccann, some say he roams the streets of California, coding Haskell all day long. Some say he eats his weight in poorly written monad tutorials a week.
01:48:10 <Taneb> All we know, he's shachaf
01:48:24 <cmccann> how mysterious.
01:48:44 <shachaf> cmccann: My sleep schedule is also incoherent, and exactly synchronized with yours.
01:49:12 <cmccann> that's disconcerting.
01:50:58 <Gracenotes> I tried to sleep normally and had a miserable time at it
01:51:23 <Gracenotes> now I'm even more awake, and that melatonin seems to be ineffectual
01:52:12 <shachaf> Gracenotes: You should move to California and get three more hours a day.
01:52:49 <shachaf> It's not even 02:00 here!
01:53:03 <Gracenotes> I should get a job. Those help.
01:53:14 <cmccann> I have a job. it didn't help.
01:53:29 <cmccann> worse, it's a holiday weekend.
01:53:51 <cmccann> therefore, I am awake at 5am and writing boilerplate-generating code.
01:54:31 <Gracenotes> in the past, having to get up and commute has helped, assuming it's with some regularity.
01:54:48 <shachaf> Gracenotes: How does that help you with going to sleep?
01:55:23 <cmccann> I tend to alternate between staying up too late a few nights in a row, then collapsing from exhaustion really early
01:56:06 <Gracenotes> shachaf: I'm not sure, but after taking up at a consistent time for a few weeks, I ended up feeling very sleep around 12am, and subsequently sleeping.
01:56:10 <Gracenotes> *waking
01:56:22 <Saizan> i'm always wondering if i'm trying to get awake or i'm getting sleepy
01:56:39 * shachaf finds the waking up bit almost as tricky as the going to sleep bit.
01:57:03 <shachaf> A job has never helped in my experience. Maybe I should try again, though.
01:57:11 * shachaf tends to be the "immovable object" type.
01:57:24 <Gracenotes> The same thing doesn't apply at school, because my coursework causes me to have little respect for my own time and code at strange hours of the night :p
01:57:37 <Gracenotes> with enough regularity that it messes things up.
01:57:55 <cmccann> shachaf, I end up with way too much inertia in either state. can't get the sleep when I'm awake, can't wake up when I'm asleep.
01:58:07 * hackagebot crypto-numbers 0.1.0 - Cryptographic numbers: functions and algorithms  http://hackage.haskell.org/package/crypto-numbers-0.1.0 (VincentHanquez)
01:58:35 <Taneb> Hmm
01:58:47 <Taneb> Is there a way to cabal-install from GitHub?
01:58:54 <shachaf> cmccann: Yes, it's the state transitions that get you.
02:00:27 <shachaf> cmccann: Did you get any more of my work not done?
02:00:44 <cmccann> no, I've been too busy with my own work to not get yours done.
02:00:50 <cmccann> your work is very time-consuming to not do.
02:04:38 <Taneb> I tend to wake up earlier when I really want a lie in
02:04:44 <shachaf> cmccann: Have you puzzled through http://slbkbs.org/k.hs ?
02:06:04 <cmccann> you're very dedicated to this profunctor thing, aren't you.
02:06:46 <Saizan> still trying to figure out Traversal?
02:06:48 <shachaf> I think we're missing something about prisms.
02:07:13 <shachaf> Saizan: Well, we have an "each", sort of.
02:07:51 <shachaf> And a both.
02:08:01 <shachaf> Travesals are really awkward to write this way, though, and also terribly inefficient.
02:08:06 <shachaf> And all sorts of things.
02:09:04 <shachaf> Also, diffract :: p a b -> p a c -> p a (b,c) and prismy :: p a b -> p (Either b a) b are enough to write each
02:09:08 <shachaf> But not enough to write ignored?
02:09:59 <Saizan>  :t ignored ?
02:10:15 <shachaf> A travesal that's always empty.
02:10:17 <shachaf> r
02:10:25 <shachaf> You can write it with id, of course
02:11:23 <cmccann> shachaf, you should use profunctors to figure out a way to make my linear logic stuff work.
02:11:54 <shachaf> cmccann: I was trying out double-contravariant bifunctors before and elliott said it reminded him of your linear logic thing.
02:12:41 <Saizan> lmap should have a flipped infix synonym
02:12:49 <cmccann> the lens type in general is pretty similar
02:13:21 <cmccann> in both cases it's a sort of flipped Kleisli Cont that expects things to be used in a linear-ish fashion
02:14:06 <cmccann> I just can't figure out how to make negation fit in with the lens stuff
02:14:25 <cmccann> or how to handle the negative connectives without rendering all the lens stuff unusable
02:15:13 <cmccann> your profunctor stuff might help with the latter? not sure.
02:16:41 * shachaf wonders whether there exist any types in any Haskell library that are double-contravariant.
02:16:46 <shachaf> As in class Conbi p where conbimap  :: (b -> a) -> (y -> x) -> p a x -> p b y
02:18:52 <Ralith> I want a screensaver like that one that generates weirdass shapes and formal names for them
02:18:56 <elliott> shachaf: Const Proxy
02:19:01 <Ralith> except instead of shapes it's type signatures
02:19:24 <Ralith> bonus points if it's a lambdabot module
02:20:46 <cmccann> Ralith, picking random types from edwardk's packages would get you pretty close. there'd be enough to choose from that you wouldn't really notice that it's not just generating things randomly.
02:21:05 <Ralith> heh
02:35:53 <googya> how to set completion for haskell in vim?
02:36:09 <googya> I got error: ghc.vim: GHCi reports errors (try :make?)
02:36:16 <googya> Omni completion (^O^N^P) Pattern not found
02:36:38 <shachaf> I just use ^P
02:37:32 <googya> ^P   same error
02:38:07 <shachaf> I mean that I don't use omni completion.
02:43:08 * hackagebot dataenc 0.14.0.5 - Data encoding library  http://hackage.haskell.org/package/dataenc-0.14.0.5 (MagnusTherning)
03:11:05 <b52> In http://lambda-diode.com/programming/monads-are-a-class-of-hard-drugs the author states "While they have been turned into a tool of intellectual terrorism, the original paper on monads is actually quite easy to understand and fun to read", which paper does he link to?
03:12:37 <parcs> this i think http://homepages.inf.ed.ac.uk/wadler/papers/marktoberdorf/baastad.pdf
03:12:42 <bitonic> b52: I’d guess wadler
03:13:19 <bitonic> well, parcs was quicker
03:14:15 <Jafet> "Baastad."
03:14:35 <bitonic> I was confused by that too lol
03:17:54 <parcs> @where monad
03:17:54 <lambdabot> I know nothing about monad.
03:17:55 <parcs> @where monads
03:17:56 <lambdabot> http://mauke.dyndns.org/stuff/haskell/All_About_Monads.pdf
03:18:24 <Taneb> 404
03:18:53 <Taneb> Actually, my DNS can't find it
03:18:57 <Taneb> Which is worse?
03:19:41 <Jafet> @google all about monads filetype:pdf
03:19:44 <lambdabot> http://ompldr.org/vY29zdw/All_About_Monads.pdf
03:19:45 <lambdabot> Title: All About Monads Contents
03:19:56 <Jafet> @where+ monads http://ompldr.org/vY29zdw/All_About_Monads.pdf
03:19:57 <lambdabot> Nice!
03:20:41 <hiptobecubic> would it break old code to use the polymorphic folds from Data.Foldable in prelude? If so, why?
03:20:44 <Jafet> The PDF document contains... a website.
03:21:11 <Jafet> Okay, someone went to the website and printed it as a PDF document.
03:21:48 <Jafet> @where+ monads http://homepages.inf.ed.ac.uk/wadler/papers/marktoberdorf/baastad.pdf
03:21:48 <lambdabot> It is stored.
03:22:28 <covi> I don't feel like I have programmed enough in any language.
03:22:52 <Jafet> Try two hours of php
03:22:57 <zomg> try 10 years of php
03:22:59 <zomg> lol
03:23:12 <Jafet> That is very conservative, but it will work.
03:23:18 <bitonic> hiptobecubic: this is an old discussion.  designing good general interfaces is hard, and giving beginners polymorphic functions is confusing
03:23:32 <srhb> We should just have two Preludes. :-)
03:23:50 <Jafet> If it is polymorphic, it should be a fugue.
03:23:59 <hiptobecubic> bitonic, so it's s sociopolitical issue and not a technical one ?
03:24:02 <srhb> We could name the intermediate-one Ouverture
03:24:03 <bitonic> I think that the Prelude is fine.  importing stuff is really not a big deal.
03:24:06 <bitonic> hiptobecubic: it’s both
03:24:10 <zomg> As much as I wanted to do something else than PHP for a living, the other alternative was always Java which I want to use even less than PHP
03:24:22 <bitonic> hiptobecubic: as I said, coming up with generic interfaces a community can agree on is very hard
03:24:49 <covi> They say if you want to be truly good at anything, it takes 10 years.
03:25:08 <hiptobecubic> But the definitions in Foldable are the same as prelude for lists, correct?
03:25:13 <NihilistDandy> srhb: Already exists: https://github.com/isomorphism/Overture
03:25:14 <hiptobecubic> So those are already agreed on
03:25:24 <cmccann> heh
03:25:29 <srhb> NihilistDandy: Ah, too obvious.
03:25:47 <cmccann> I really need to update that repo one of these days
03:25:56 <elliott> cmccann: if you're isomorphism, what would prism's prelude be?
03:26:06 <bitonic> hiptobecubic: well we agree how they should work on lists, but the abstraction is not set in stone (although Foldable looks like it’s going to last :P)
03:26:24 <Jafet> @hackage fugue
03:26:25 <lambdabot> http://hackage.haskell.org/package/fugue
03:26:25 <cmccann> elliott, probably something with shachaf's profunctors everywhere
03:27:11 <elliott> cmccann: too bad those things suck for traversals
03:27:24 <elliott> well okay you can just use (co)representable profunctors
03:27:29 <shachaf> elliott: Too bad you can use corepresentability to get everything twanvl gives you.
03:27:34 <bootcode_> a cabal question: I have an "Executable" entry with main-is A/B/C/Main.hs, yet cabal build tells no output will be generated because there is no Main module. Why could that be?
03:27:36 <shachaf> Even GHC patches.
03:28:08 <cmccann> I like how there's a dedicated channel for lens stuff and yet arguing about esoteric lens stuff is still like 30% of the conversation in here
03:28:50 <shachaf> There are at least three dedicated lens channels.
03:28:54 <srhb> It seems to come and go, but it has been particularly bad recently. :P
03:29:11 <elliott> shachaf: right the only cost is that it requires MPTCs and fundeps or type families,
03:29:17 <elliott> and is uglier than twanvl
03:30:27 <hiptobecubic> NihilistDandy, fugue reexports all of prelude?
03:31:00 <hiptobecubic> ah i see
03:31:39 <cmccann> srhb, though for what it's worth I do alias a bunch of Prelude functions to more generic versions in Overture :P
03:33:27 <hiptobecubic> Why does :m -Prelude not work in ghci anymore? It definitely used to
03:33:50 <cmccann> y'know I swear someone should ask benabou how he came up with the term "monad" just so we have a solid authoritative answer
03:34:27 <elliott> I nominate cmccann
03:34:56 <cmccann> I don't really feel like contacting some elderly french mathematician about something that silly though
03:36:16 <NihilistDandy> WHAT? There's a :set +m now? I've been doing all that annoying :{}: for nothing?
03:37:37 <parcs> what does :set +m do?
03:37:42 <elliott> cmccann: are you suggesting you can think of anything better to do
03:38:01 <cmccann> well there's always not doing shachaf's work
03:38:01 <NihilistDandy> hiptobecubic: First :set -XNoImplicitPrelude (from within ghci). Then you can do it.
03:38:06 <cmccann> that takes up a lot of my time as it is
03:38:13 <NihilistDandy> parcs: Multiline input
03:38:21 <hiptobecubic> ah
03:38:24 <elliott> cmccann: right but now shachaf is busy not doing your work
03:38:26 <elliott> so you have to do it
03:38:41 <cmccann> no, he's also not doing his work
03:38:44 <cmccann> he has a lot of work to not do
03:38:57 <hiptobecubic> NihilistDandy, still no
03:39:06 <NihilistDandy> ghc version?
03:39:17 <hiptobecubic> 7.4.2
03:40:04 <NihilistDandy> Hmm. Works in 7.6.1. I'm sure I could do it in 7.4.2, as well, even without the NoImplicit
03:40:29 <NihilistDandy> Prelude> :set -XNoImplicitPrelude
03:40:39 <NihilistDandy> Prelude> :m -Prelude
03:40:43 <NihilistDandy> >
03:47:22 <burbul> Is there a standard name for this?
03:47:23 <burbul>      f t | t == a = b
03:47:23 <burbul>          | otherwise = t
03:48:10 <Taneb> burbul, no, but lens can do that
03:48:16 <edwardk> Taneb: hah
03:48:28 <Jafet>  @lens-faq
03:48:37 <edwardk> that reminds me we need an equality prism
03:48:40 <burbul> @lens-faq
03:48:41 <lambdabot> Unknown command, try @list
03:48:51 <burbul> @hoogle lens
03:48:52 <lambdabot> package lenses
03:48:52 <lambdabot> package data-lens
03:48:52 <lambdabot> package data-lens-fd
03:48:55 <Taneb> > let f = resultAt 0 .~ 0 $ pref in map f [0,1,2]
03:48:57 <lambdabot>   Not in scope: `pref'
03:48:57 <lambdabot>  Perhaps you meant `pred' (imported from Prelude)
03:49:01 <Taneb> > let f = resultAt 0 .~ 0 $ pred in map f [0,1,2]
03:49:03 <lambdabot>   [0,0,1]
03:49:05 <elliott> edwardk: what would the equality prism look like?
03:49:35 <burbul> @hoogle resultAt
03:49:36 <lambdabot> No results found
03:49:42 <edwardk> foo :: Eq s => s -> Prism' s ()
03:49:46 <hiptobecubic> NihilistDandy, i remember it being like that in earlier versions
03:50:04 <Taneb> burbul, it's pretty new, and already almost deprecated
03:50:06 <burbul> Umm.... was the lens thing a suggestion I should follow up?
03:50:10 <burbul> ok
03:50:30 <edwardk> burbul: it was mostly a joke, lenses are a pretty deep concept
03:50:33 <burbul> I know there's a Wadler paper about lenses and bananas, but I've not read it
03:50:44 <burbul> right!
03:50:46 <edwardk> burbul: lenses and bananas by erik meijer is unrelated
03:51:05 <shachaf> Barbed wire, on the other hand...
03:51:08 <edwardk> https://github.com/ekmett/lens/wiki/faq#wiki-bananas
03:51:29 <Jafet> lens is enveloped by barbed wire
03:51:49 <burbul> @edawrdk: so there are TWO distinct things called lenses??
03:51:50 <lambdabot> Unknown command, try @list
03:51:52 <edwardk> i've been trying to add a little bit of foam padding here and there.
03:52:20 <edwardk> burbul: to be fair, nobody but erik ever called (| |) bananas or [(  )] lenses.
03:52:31 <Jafet> If you only see two, you may need to get your eyes checked.
03:52:59 <shachaf> Haskell is eclipsed by Java.
03:53:08 <burbul> This is going over my head...
03:53:37 <shachaf> Everyone calls these lenticular, though: 【】
03:54:50 <cmccann> I think I've called (| |) "banana brackets" a few times
03:54:59 <cmccann> mostly because the alliteration makes it catchy
03:55:10 <cmccann> his other names are meh.
03:55:28 <cmccann> fun paper, though.
04:15:56 <bootcode_> about TypeFamilies: when in class R i have an associated type (or data) T, and having a function `f :: (R r) => r -> T -> IO ()`, i see that T is inferred to be the associated T
04:16:47 <bootcode_> i'm happy about that, however would it not be possible that the T instance is an instance associated with an other R instance (not r)?
04:21:22 <watermind> bootcode_: when you say another... which one would it possibly be?
04:21:33 <covi> How can I and should I put in comments for several functions that serve similar purposes? E.g. "-- | The IO functions.". Or should I put the functions in a seperate file as a module?
04:26:36 <bootcode_> covi: something like -- * The IO functions ?
04:27:42 <bootcode_> watermind: fair enough. I was just surprised I didn't need additional context elements, which is nice
04:27:45 <covi> bootcode_: can you point me to a link that shows this style?
04:29:33 <bootcode_> covi: http://hackage.haskell.org/packages/archive/gloss/1.7.8.1/doc/html/src/Graphics-Gloss-Data-Picture.html
04:30:42 <covi> bootcode_: I see in this code "-- Description ---------------" which meets my need. Is this use recommended?
04:31:12 <bootcode_> I'm not sure that is parsed. See the -- * Xyz in the module export list
04:34:28 <covi> bootcode_: But I only want to add those comments in the source code, not in the export list.
04:41:04 <bootcode_> covi: you mean not to make them appear in haddock apidoc?
04:41:24 <bootcode_> in that case it is pretty freeform isn't it?
04:43:18 <mm_freak_> @oeis 1 3 6 10 15
04:43:21 <lambdabot>  Triangular numbers: a(n) = C(n+1,2) = n(n+1)/2 = 0+1+2+...+n.
04:43:21 <lambdabot>  [0,1,3,6,10,15,21,28,36,45,55,66,78,91,105,120,136,153,171,190,210,231,253,2...
04:49:54 <covi> How should I determine the `portability' and `stability' of my code? In particular, is there lists of things/functions that are classified into different categories?
04:52:31 <bootcode_> covi: http://stackoverflow.com/questions/11526701/hackage-haskell-org-documentation-convention-meaning
05:00:29 <covi> bootcode_: thanks
05:04:55 <bootcode_> np
05:32:52 <mroman> @check \x -> id x == x
05:32:54 <lambdabot>   Not in scope: `myquickcheck'
05:33:00 <mroman> Still broken.
05:56:13 <covi> @src maybe
05:56:13 <lambdabot> maybe n _ Nothing  = n
05:56:13 <lambdabot> maybe _ f (Just x) = f x
06:00:04 <c_wraith> @djinn b -> (a -> b) -> Maybe a -> b
06:00:04 <lambdabot> f a b c =
06:00:04 <lambdabot>     case c of
06:00:04 <lambdabot>     Nothing -> a
06:00:04 <lambdabot>     Just d -> b d
06:00:54 <c_wraith> It's the only total implementation of that type.
06:01:07 <c_wraith> err, I guess not.
06:01:15 <c_wraith> It's just the only total implementation that uses all 3 of its args
06:05:47 <`nand`> hmm
06:06:29 <`nand`> I'm still running into the “unknown symbol `stat'” error when linking HSbase
06:06:55 <`nand`> it's preventing me from trying on GHC 7.7; but I've had the same occur when attempting to compile GHC 7.6 manually. The binary works fine. The same build script works fine on my other machines
06:07:32 <`nand`> same version of glibc everywhere, built with the same flags; same version of gcc everywhere, again built with the same flags
06:16:37 <covi> Wow, liftIO is such a handy and important function.
06:16:46 <covi> @src liftIO
06:16:46 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
06:17:07 <parcs> > logBase 2 65536
06:17:09 <lambdabot>   16.0
06:17:30 <covi> Why no source.
06:17:41 <merijn> covi: @src only shows explicitly code samples. To look at *actual* source just go to Hoogle and click the source links there
06:18:02 <merijn> covi: (Occasionally @src will also show code that doesn't match the actual implementation)
06:18:18 <merijn> s/explicitly/explicitly stored
06:19:41 <nicoo> c_wraith: Nope; /wg 24
06:19:46 <nicoo> Oops
06:19:55 <nicoo> Sorry
06:21:00 <c_wraith> covi: also, liftIO is a class function. The source depends on the type.
06:23:13 * hackagebot crypto-pubkey 0.1.0 - Public Key cryptography  http://hackage.haskell.org/package/crypto-pubkey-0.1.0 (VincentHanquez)
06:29:01 <dustyk> Hello. Is anyone aware of research into making Haskell safer and more robust by removing partial functions - those that call diverge on some input like head and tail?
06:29:44 <hiptobecubic> dustyk, by "research" you mean making a different prelude? There are many
06:30:18 <merijn> dustyk: Also, are you aware of languages like Agda?
06:30:28 <dustyk> hiptobecubic: yeah, if you can point me at any of those. also, has anyone considered extension to the language that prevent any kind of divergent behaviour beyond non-termination?
06:30:43 <hiptobecubic> dustyk, the approach i see being used is wrapping all of these functions in Maybe
06:30:49 <elliott> well non-termination is the worst kind of _|_
06:30:50 <merijn> dustyk: Agda actually even prevent non-termination (unless you explicitly disable that)
06:30:57 <elliott> since (error "x") is like an infinite loop but you get a useful error
06:31:03 <elliott> undefined = let x = x in x  -- this is not better
06:31:55 <dustyk> are head, tail etc in the prelude just for historical reasons? i always do a full pattern match on lists and call error myself on data that violates preconditions
06:32:30 <yitz> dustyk: a new ghc feature, Safe Haskell, allows you to manage guarantees about that kind of safety claimed by the authors of libraries you use
06:33:13 <yitz> elliott: <<loop>>
06:33:23 <yitz> but yeah, in the general case
06:33:44 <tdammers> module question here:
06:33:49 <hiptobecubic> i wish it could tell you something a little more informative
06:34:00 <hiptobecubic> "<<loop>>" is frustrating to see
06:34:01 <tdammers> suppose I have two functions that call each other, and I want them in separate modules
06:34:07 <hiptobecubic> might as well be "No"
06:34:25 <tdammers> is that at all possible?
06:34:26 <merijn> yitz: SafeHaskell doesn't prevent partial functions, though. It's more guaranteeing that libraries don't have a hidden "unsafePerformIO (system "rm -rf /")"
06:34:54 <hiptobecubic> how nefarious
06:35:07 <yitz> merijn: it doesn't even guarantee that. its purpose is to manage claims of safety by package authors, and to make your own compilations conditional on those claims.
06:35:18 <hiptobecubic> has anyone made this library? import Control.SelfDestruct
06:35:44 <merijn> yitz: It guarantees that doesn't happen provided that any library you explicitly trust doesn't do that
06:35:44 <yitz> merijn: but in practice that is very useful.
06:36:23 <merijn> yitz: If you only allow safe-inferred then it can't happen (but limits what you can do, of course). If you use trusted, then all bets are off for the stuff you trust, of course
06:36:56 <flebron> afaik safehaskell handles not loading of libraries (or parts of libraries) you did not want
06:37:08 <yitz> merijn: if i mark my module as Safe and then explicitly include an unsafe usage of unsafePerformIO, does my module fail to compile?
06:37:32 <flebron> so you can have module m and module m.private, where the private part contains, say, keys for something, or has functions to do evil things
06:37:34 <yitz> merijn: i think it will still compile
06:37:40 <merijn> yitz: No, but *my* code won't accept your module as safe unless it's either safe inferred or trusted
06:37:58 <flebron> you can have unsafePerformIO in a safe module, i think
06:37:58 <merijn> yitz: It's not about protecting code *you* write, it's about protecting against code you *don't* write
06:38:03 <flebron> right
06:38:10 <yitz> merijn: so Safe Haskell guarantees exactly nothing. and doesn't claim to guarantee anything, either. that's not what it's designed for.
06:38:13 * hackagebot snaplet-oauth 0.0.6 - snaplet-oauth  http://hackage.haskell.org/package/snaplet-oauth-0.0.6 (HaishengWu)
06:38:15 <flebron> for protecting data flow, there's labeled IO
06:38:37 <flebron> http://hackage.haskell.org/package/lio-0.0.1
06:38:57 <yitz> merijn: well, it guarantees things about claims. nothing about the actual safety of any code.
06:39:00 <merijn> yitz: It does, it means that if I accept plugin source from you, then I don't have to check whether you do nasty IO or not, because SafeHaskell won't let me compile *unless* your module is safe-inferred *or* I explicitly trust it
06:39:10 <flebron> that's for things like "i'll give you this information. i want a proof that you will not send this information to facebook, you can only compute with it"
06:39:32 <merijn> (or, of course the IO is in the signature, but allowing plugins with an IO signature is, of course, dumb)
06:39:48 <yitz> merijn: it says nothing at all about whether or not you have to check anything
06:40:09 <yitz> merijn: that's a decision you make on your own.
06:40:15 <merijn> yitz: Why not? If your code does not obey safe haskell, it won't be safe-inferred, and thus it will refuse to link
06:40:25 <flebron> (so you can work with information of a high privilege, you just can't send it to someone of a lower privilege. )
06:41:04 <flebron> (i think the idea is the same as the bell-lapadula model)
06:41:26 <merijn> yitz: The fact that I can explicitly override this using trusted settings is irrelevant. Trusted is only if your own modules are not safe-inferred but need to link against stuff that should be safe-inferred. (i.e. selectively disabling the safe-inferred requirement on your trusted modules, hence the name)
06:41:43 <yitz> merijn: wrong. your code can complete violate all the rules of safe haskell, create the worst kinds of segfaults, and it will still compile and link. safe haskell is only a tool that allows you to automate relying on claims of library authors and your own claims and beliefs of safety.
06:42:11 <yitz> merijn: as i said, that is extremely useful. but don't be misled to believe that safe haskell is any kind of actual proof of safety.
06:42:21 <merijn> yitz: The wiki explicitly contradicts what you're saying
06:42:35 <flebron> what won't compile is you importing an untrusted module
06:42:39 <yitz> merijn: i don't think it does at all.
06:42:43 <merijn> "This is a proposal for a Haskell extension through which people can safely execute untrusted Haskell code, much the way web browsers currently run untrusted Java and JavaScript"
06:42:45 <flebron> but a trusted module that uses black magic is OK
06:42:59 <yitz> merijn: yes, exactly what i said.
06:43:01 <flebron> if you're trusting it, you're trusting it
06:43:29 <merijn> yitz: Either you're arguing the same thing I am, or you're completely confused about what I and the safe haskell page are saying
06:43:38 <flebron> if it's untrusted, then it can't do black magic
06:43:58 <merijn> You said: "your code can complete violate all the rules of safe haskell, create the worst kinds of segfaults, and it will still compile and link."
06:44:03 <yitz> merijn: i think i know pretty well how safe haskell works. i've read the paper and seen how simon uses in practice in quite a few places.
06:44:14 <merijn> I said
06:44:16 <yitz> merijn: yep, that's true.
06:44:24 <merijn> "It's not about protecting code *you* write, it's about protecting against code you *don't* write"
06:44:34 <merijn> How is anything you say disagreeing with me?
06:44:48 <flebron> you're disagreeing about disagreeing?
06:44:55 <flebron> i think that reduces to agreeing
06:44:58 <yitz> merijn: no. it's about *trusting* code you don't write. it doesn't protect you against malicious or erroneous code in any way.
06:45:05 <hiptobecubic> flebron, clearly not
06:45:12 <flebron> boo
06:45:26 <`nand`> I only caught the tail end but from what I know, yitz seems to be describing the situation accurately. I have no opinion on whether or not what merijn said contradicts that or not
06:45:34 <flebron> yitz, it protects you against malicious code by being able to import it untrusted
06:45:37 <merijn> yitz: It does, in the sense that anything that does not have "IO" in the signature won't do IO
06:45:46 <flebron> (i.e. -XSafe)
06:46:27 <`nand`> “anything that does not have "IO" in the signature won't do IO” <- like ByteString?
06:46:49 <merijn> `nand`: It won't be safe-inferred if it does
06:46:58 <yitz> merijn: that for sure is not right. you can do whatever IO you want and properly mark your module as Safe. that's even without any errors or violations of the social contracts of safe haskell/
06:47:31 <merijn> yitz: Marking a module as safe doesn't make the compiler accept it, unless you *trust* the module, which of course you don't for code you don't actually trust
06:47:37 <`nand`> merijn: but you can use other libraries that are marked safe which do IO, and your package will be safe-inferred
06:47:41 <flebron> you can do IO, you just can't do things like unsafePerformIO
06:47:43 <merijn> That's my entire fucking point...
06:47:45 <yitz> merijn: oh you mean that it has to have an IO type? well ok, yes. that's the social contract.
06:48:03 <flebron> right, you can return IO, but it'll be clearly marked as such
06:48:05 <merijn> "< merijn> (or, of course the IO is in the signature, but allowing plugins with an IO signature is, of course, dumb)"
06:48:13 * hackagebot HGamer3D-Data 0.2.0 - Windows Game Engine for the Haskell Programmer - Data Definitions  http://hackage.haskell.org/package/HGamer3D-Data-0.2.0 (PeterAlthainz)
06:48:30 <yitz> merijn: but there is no guarantee that the contract was followed. you are just automating your reasoning about statements of trust.
06:49:48 <`nand`> for example, consider the scenario where ByteString or another marked-safe-but-unsafe package has an exploit that lets you run arbitrary IO
06:49:56 <merijn> yitz: I'm talking from the point where you *don't* trust modules, that's the entire thing SafeHaskell is there for...if you trust stuff all bets are off, that's like the first thing I said
06:50:39 <`nand`> if you don't trust the module, sandbox - not safe haskell
06:50:50 <yitz> merijn: so, for example, in a defense application, you can't just use safe haskell pragmas off hackage out of the box. you'll need some kind of policy and enforcement for verifying them, and for assigning responsibility for them to persons and organizations. but that is a very complex problem, and safe haskell is a great start to make it more tractable.
06:51:22 <merijn> `nand`: Depends on your goal
06:51:33 <`nand`> yitz: presumably, you still only have to very the ‘trustworthy’ packages; if you verify all of those then the safe-inferred ones should come free
06:51:37 <`nand`> verify*
06:51:38 <merijn> `nand`: You might want to let people run untrusted plugins in your program
06:52:18 <yitz> `nand`: not really. someone could have made a false claim of Trustworthy.
06:52:34 <merijn> `nand`: In that case sandboxing doesn't really help, but non-IO safe-haskell interface would be easy. Of course they could still infinite loop/resource consume, but whether that's a problem depends on your threat model
06:52:55 <merijn> yitz: SafeHaskell allows you ignore Trustworthy claims, not doing so is dumb
06:53:14 <`nand`> if you ignore trustworthy, does that mean I can't use ByteString in my plugins?
06:53:40 <cmccann> can't you whitelist specific trustworthy modules or something?
06:53:45 <merijn> `nand`: You'd have to explicitly add that ByteString is trusted
06:53:49 <merijn> cmccann: You can
06:53:55 <`nand`> yitz: that doesn't seem to relate to what I said
06:53:59 <merijn> cmccann: Otherwise SafeHaskell would be pointless
06:54:18 <merijn> `nand`: That's the exact disagreement I've been having the entire conversation so far
06:54:26 <yitz> `nand`: there is some attempt being made to support safe haskell in the haskell platform. once that is in place, then if you are familiar with the vetting process for getting packages approved to the platform, there will be an actual real-world semantics you can then apply to safe haskell pragmas in platform packages.
06:54:28 <cmccann> well, safe-inferred would still be useful information
06:55:40 <merijn> cmccann: Sure, but with so many core libraries *not* being safe-inferred you need that
06:56:11 <hpaste> merijn pasted “safe-haskell trust policy” at http://hpaste.org/79976
06:58:14 * hackagebot HGamer3D-Ogre-Binding 0.2.0 - Windows Game Engine for the Haskell Programmer - Ogre Bindings  http://hackage.haskell.org/package/HGamer3D-Ogre-Binding-0.2.0 (PeterAlthainz)
06:58:50 <`nand`> how odd
06:59:01 <merijn> `nand`: What?
06:59:01 <`nand`> the GHC nightly builds seem to be erroneous
06:59:29 <`nand`> the configure script invokes utils/ghc-pwd/dist-install/build/tmp/ghc-pwd-bindist in line 2138, but that file isn't included in the distribution
06:59:41 <`nand`> (which causes ./configure --prefix=foo to error)
07:01:27 <`nand`> the particular error is: checking for path to top of build tree... ./configure: line 2138: utils/ghc-pwd/dist-install/build/tmp/ghc-pwd-bindist: No such file or directory
07:07:36 <flebron> that it's in /tmp would seem to indicate it's something that should be built during the compilation
07:08:14 * hackagebot cryptohash 0.8.3 - collection of crypto hashes, fast, pure and practical  http://hackage.haskell.org/package/cryptohash-0.8.3 (VincentHanquez)
07:08:16 * hackagebot HGamer3D-SFML-Binding 0.2.0 - Windows Game Engine for the Haskell Programmer - SFML Bindings  http://hackage.haskell.org/package/HGamer3D-SFML-Binding-0.2.0 (PeterAlthainz)
07:09:25 <`nand`> the 7.7.20121212 build seems to have it
07:13:14 * hackagebot HGamer3D-CEGUI-Binding 0.2.0 - Windows Game Engine for the Haskell Programmer - CEGUI Bindings  http://hackage.haskell.org/package/HGamer3D-CEGUI-Binding-0.2.0 (PeterAlthainz)
07:13:16 * hackagebot HGamer3D-Enet-Binding 0.2.0 - Windows Game Engine for the Haskell Programmer - Enet Bindings  http://hackage.haskell.org/package/HGamer3D-Enet-Binding-0.2.0 (PeterAlthainz)
07:14:05 <`nand`> right, the 20121212 nightly works fine
07:14:11 <`nand`> it's just 20121213 that seems to be bugged
07:18:14 * hackagebot HGamer3D-Bullet-Binding 0.2.0 - Windows Game Engine for the Haskell Programmer - Bullet Bindings  http://hackage.haskell.org/package/HGamer3D-Bullet-Binding-0.2.0 (PeterAlthainz)
07:24:30 <covi> newIORef :: a -> IO (IORef a)hhe -rd
07:25:02 <elliott> covi: hi
07:25:43 <covi> newIORef :: a -> IO (IORef a)  returns an IORef inside the IO monad. How can I retrive that IORef in a function that returns a non-IO monadic value? (Sorry for the previous post)
07:26:01 <mauke> you don't
07:26:33 <covi> mauke: that's what I thought. So what's the get around here? I want to construct an IORef a value from a.
07:26:46 <mauke> then you should use newIORef
07:27:28 <elliott> main :: IO (); main = do { r <- newIORef 42; ... r is an IORef here... }
07:28:19 <covi> elliott: I want to use newIORef in a function that is M _, not IO _
07:28:30 <mauke> you can't
07:28:36 <covi> ok
07:28:41 <elliott> what is M
07:28:54 <covi> a monad other than IO
07:29:03 <elliott> what monad
07:29:12 <elliott> if it's, e.g. StateT Int IO, then you can do it
07:29:15 <elliott> if it's, e.g. Maybe you can't
07:32:59 <covi> mauke: seems like I can create a nested do that operates within IO, and then call liftIO on it
07:33:14 * hackagebot HGamer3D 0.2.0 - Windows Game Engine for the Haskell Programmer  http://hackage.haskell.org/package/HGamer3D-0.2.0 (PeterAlthainz)
07:34:57 <mauke> covi: only if it's really IO underneath
07:35:10 <mauke> you said you had a non-IO type
07:35:57 <covi> Sorry I didn't mean to confuse you. It's not exactly the IO monad, but sth stacked upon the IO monad.
07:36:23 <covi> Why is this possible? What's behind the scene? How does the nested do desugar?
07:38:21 <deus_rex> I tried to find a functino like this on Hoogle, to no avail. I wrote it with lists and sets in mind, is there a better typeclass to use in this case?
07:38:27 <deus_rex> http://hpaste.org/79980
07:39:02 <deus_rex> the idea is you can compose it with a function which returns (Monoid m) => Either t m
07:45:56 <fmap> @ty either (const mempty) id
07:45:57 <lambdabot> Monoid c => Either a c -> c
07:47:16 <deus_rex> > const 42 "gllo"
07:47:18 <lambdabot>   42
07:50:31 <fmap> @ty (^. right)
07:50:32 <lambdabot>     Couldn't match expected type `Accessor a0 t0'
07:50:33 <lambdabot>                 with actual type `Either d0 (Accessor a0 b0)'
07:50:33 <lambdabot>     Expected type: Getting a0 (Either d0 a0) t0 a0 b0
07:50:42 <fmap> @ty (^. _right)
07:50:44 <lambdabot> Monoid a => Either c a -> a
07:52:26 <`nand`> not the same thing
07:52:33 <zomg> lol
07:52:39 * `nand` gave up thinking of a lens-y way to do this :(
07:52:42 <zomg> "MonadWriter class -- tell is like tell on the MUD's it shouts to monad"
07:52:52 <zomg> http://hackage.haskell.org/packages/archive/mtl/latest/doc/html/src/Control-Monad-Writer-Class.html
07:53:01 <zomg> Why doesn't that show up in the hackage docs, would be funny
07:53:02 <fmap> `nand`: why?
07:53:03 <zomg> =)
07:53:21 <`nand`> fmap: just ignores values on the right/left
07:53:37 <`nand`> wait
07:53:50 <`nand`> that's exactly what he wanted
07:53:52 <`nand`> nvm
07:54:49 <Taneb> :t view _right :: Monoid m => Either t m -> m
07:54:50 <lambdabot> Monoid m => Either t m -> m
07:54:59 <`nand`> :t view _right `asAppliedTo` undefined
07:55:00 <lambdabot> Monoid b => Either c b -> b
07:55:02 <Taneb> If you don't want the infixiness
07:55:26 <elliott> `nand`: `asAppliedTo` undefined = ($)
07:55:28 <elliott> :t (view _right $)
07:55:29 <lambdabot> Monoid b => Either c b -> b
07:55:38 <`nand`> excellent
07:56:08 <Taneb> > view _right (Right "hello")
07:56:10 <lambdabot>   "hello"
07:56:18 <Taneb> > view _right (Left 10 :: Either Int String)
07:56:20 <lambdabot>   ""
08:01:53 <westclox> Hello, I'm confused with the comments section in the Haskell 2010 report (2.3), namely the statement "the first unmatched occurrence of the string '-}' terminates the nested comment."  Why is it unmatched instead of matched?
08:02:39 <mauke> if it was matched, comments couldn't be nested
08:04:56 <westclox> mauke: I could assume as much from the statement, but why is that the case?  I don't understand what that means.  Given that there must always be a matching "{-" somewhere, it seems convoluted.
08:05:10 <mauke> huh?
08:05:27 <`nand`> I don't see why “unmatched” is in there as well, but I'm probably missing context
08:05:47 <imbric> Hi guys, I'm trying to go through the Learn You A Haskell book and I'm hitting a snag. In the section introducing 'where' clauses, they give an example that assigns multiple variables used in the pattern match "skinny", "normal", "overweight" (its a bmi calculation). However, I can't get it to compile when it uses multiple assignments.  Here's a pastebin of what won't compile: http://pastebin.com/2Y9CbE5h  This however works:
08:05:48 <imbric> http://pastebin.com/jD1TskqZ
08:05:59 <`nand`> maybe they meant ‘unmatched’ as in first unmatched altogether; rather than just saying ’the first -} from that point forwards’ or something?
08:06:05 <mauke> The paste 2Y9CbE5h has been copied to http://hpaste.org/79981
08:06:05 <mauke> The paste jD1TskqZ has been copied to http://hpaste.org/79982
08:06:23 <mauke> `nand`: if it was "the first -} terminates the comment", '{- {- {- -}' would be valid
08:07:00 <`nand`> mauke: the way I read that sentence, it would still only terminate the innermost {-
08:07:15 <`nand`> but arguing about this is pointless; there's a proper grammar there to prevent these kinds of ambiguities
08:08:18 <`nand`> imbric: okay for starters line 2 shouldn't be indented, and line 3-7 probably need to be indented more than line 2
08:08:25 <mauke> `nand`: how do you get that reading?
08:08:37 <`nand`> mauke: “the first -} terminates the nested comment” <- keyword: nested
08:08:48 <`nand`> that's how I get my reading
08:08:53 <`nand`> ‘nested’ to me refers to only the inner one
08:09:02 <mauke> `nand`: ah, no
08:09:11 <mauke> "nested" is actually a lie. comments cannot nest
08:09:18 <burbul> I'm getting some super-long 'exciting arity' messages, which seem to be a GHC bug mentioned that http://hackage.haskell.org/trac/ghc/ticket/5929
08:09:27 <mauke> "nested comment" refers to the only thing that is actually a comment, which is the thing started by the first "{-"
08:09:32 <`nand`> oh, okay
08:09:35 <`nand`> yeah, that makes sense
08:09:39 <burbul> But I don't know how I suppress them...
08:09:42 <`nand`> I can agree with your reading then
08:09:48 <burbul> Or even how I change my code so they don't arise
08:10:04 <`nand`> imbric: if you fix those two, it should probably work
08:10:32 <imbric> sorry, the indentation is wrong in the paste bin. I'll make an hpaste with the indentation I have
08:10:46 <`nand`> (also, what's with RealFloat? Shouldn't Fractional work?)
08:11:28 <rwbarton> needs Ord too
08:11:35 <hpaste> imbric pasted “Learn you a where clause” at http://hpaste.org/79983
08:12:02 <imbric> I'm not sure about the types 9I'm just following the examples in the book)
08:12:21 <rwbarton> imbric: it works fine
08:12:38 <rwbarton> http://hpaste.org/79983 I mean
08:12:44 <byorgey> ugh that example from LYAH is so dumb =P
08:12:49 <`nand`> yes that looks like it should work
08:13:07 <rwbarton> not only does it look like it should work, ghci accepts it :P
08:13:09 <imbric> I get a "parse error on input `=' " on the line defining "normal"
08:13:38 <`nand`> imbric: are you using tab characters or spaces?
08:13:38 <mauke> imbric: you're using tabs
08:13:40 <rwbarton> i bet you are copy-pasting out of vi and using narrow tabs
08:13:42 <byorgey> imbric: my guess is because you're using tab characters
08:14:02 <imbric> hmm, ok i'll try to switch to all spaces
08:14:04 <`nand`> this is what you get for messing with the tabstop
08:14:23 <byorgey> hehe, four people giving the same answer simultaneously is probably close to the record
08:14:32 <merijn> imbric: Haskell standard defines tab == 8 spaces, if you mix tabs and spaces weird things will happen :)
08:14:37 <`nand`> merijn: not quite
08:14:43 <`nand`> haskell standard defines the tabstop as 8 spaces
08:14:57 <merijn> imbric: Which editor are you using? Most support a soft-tab option that lets you use tab to insert X spaces
08:15:02 <imbric> sublime
08:15:23 <rwbarton> i wonder how you have spaces in hpaste then
08:15:39 <byorgey> burbul: you probably can't suppress them, or change your code so they don't arise
08:15:40 <mauke> I see tabs in hpaste
08:15:42 <`nand`> rwbarton: copy/pasting out of a terminal should do that, no?
08:15:50 <rwbarton> oh, wrong line
08:15:52 <merijn> imbric: Maybe this helps? http://sublimetext.userecho.com/topic/114466-force-soft-tabs-spaces-when-using-yaml-syntax-highlighting/
08:15:55 <rwbarton> i was looking at line 8
08:15:59 <byorgey> burbul: it's a bug.  Probably how they arise is very complicated.
08:16:02 <mauke> line 7
08:16:21 <rwbarton> hpaste should warn about tabs and display them differently
08:16:30 <byorgey> burbul: however, looking at that ticket it says it's been fixed in 7.6, so one answer is "upgrade your GHC"
08:16:38 <`nand`> merijn: Tab stops are 8 characters apart.
08:16:41 <`nand`> A tab character causes the insertion of enough spaces to align the current position with the next tab stop.
08:16:44 <`nand`> (from haskell 2010 ch10)
08:17:03 <merijn> `nand`: Right, anyway. The correct answer is still "use soft-tabs" :p
08:17:11 <`nand`> that, or fix your editor
08:17:14 <`nand`> :)
08:17:21 <Cale> Use spaces
08:17:51 <`nand`> the reason I use spaces isn't because ‘tabs are bad’, it's because 8 characters is way too much indentation
08:18:08 <westclox> mauke: It's perfectly correct to have "{- some comment -}", so how could you call the second "-}"  unmatched? Rather than say unmatched it seems correct to say the first "-}" encountered will terminate it. a nested comment.  What's wrong with that?
08:18:16 <burbul> byorgey: thanks. That would mean I had to upgrade GHC , independently of the Haskell platform, right?
08:18:17 <Cale> I think the standard should be modified to not allow tab characters as whitespace
08:18:19 <byorgey> burbul: oh, reading a bit more carefully it looks like you can suppress it by passing the -dno-debug-output flag
08:18:21 <merijn> Cale: soft-tabs == tab is converted to spaces by editor
08:18:47 <`nand`> Cale: that might be a solution to at least settle the debate
08:18:53 <imbric> that worked guys! thank you
08:19:55 <mauke> westclox: again, if the first "-}" would terminate it, "{- {- {- -}" would parse as one comment
08:20:21 <burbul> I'll try that -- thanks!
08:20:36 <mauke> westclox: the way I see it, you're in "code mode" by default. when you encounter a "{-", you switch into "comment mode"
08:20:42 <westclox> mauke: That I understand, but I don't feel it's right to use the term "unmatched" when it's not always the case, especially given that "first" will suffice.
08:21:05 <mauke> westclox: now you have to determine where the comment ends so you can switch back to code mode
08:21:05 <rwbarton> think of the body of the comment
08:21:20 <rwbarton> {- hello -} -- body is "hello"
08:21:30 <rwbarton> as i am reading hello and then I hit -} the -} is unmatched
08:21:46 <mauke> rwbarton++ # wording my thinks
08:21:47 <rwbarton> if i read (as the body) {- {- -} then the -} isn't unmatched
08:21:54 <rwbarton> so it doesn't close the comment
08:22:29 <westclox> rwbarton: But that is an odd way of looking at things imo.
08:23:26 <burbul> ah, I made it go away by changing
08:23:37 <burbul> all is_plural_sum_of_referents [a,b] to
08:23:39 <burbul> is_plural_sum_of_referents a && is_plural_sum_of_referents b
08:23:42 <`nand`> the key thing is that you aren't looking at “{- hello -}”, you're looking at “hello -}”
08:23:56 <Taneb> Is there an option to GHC to just throw everything away when it's done?
08:24:00 <`nand`> in the latter, -} is unmatched, and thus terminates the comment
08:24:59 <`nand`> or, in “{- hello {- foo -} bar -}”, you're really looking at “hello {- foo -} bar -}”, the last -} is unmatched
08:25:11 <byorgey> Taneb: I don't know of one; but there is an option to put intermediate files in some directory you specify
08:25:33 <byorgey> Taneb: then it's easy to just delete the contents of that directory
08:25:56 <`nand`> Taneb: -fno-code ?
08:26:12 <`nand`> that just does typechecking etc. but doesn't produce any output
08:26:15 <westclox> Okay, I just find it a weird, unnecessary way to put things.  Every language has nested comments and none use this "unmatched x" to convey it.
08:26:26 <Taneb> `nand`, I want to time things, so that's not what I want
08:26:35 <Taneb> byorgey, thank you, I'll look into that
08:27:05 <`nand`> time things? the compilation? or do you want to run the resulting binaries?
08:27:20 <burbul> thanks
08:28:31 <Taneb> `nand`, the compilation
08:28:59 <`nand`> I see
08:29:12 <`nand`> what's a good haskell implementation for embedded purposes? preferably as small as possible
08:35:37 <Saizan> nhc, i'm told
08:39:26 <sgk284> Does anyone know if there is a haskell function in the platform that does something like: [1,2,3] = [(1, [2,3]), (2, [1,3]), (3, [1,2])]
08:39:50 <sgk284> effectively removing each item from the list and creating a tuple of that item, along with the list without that item
08:41:41 <mauke> I don't know but I like to call it "select"
08:42:37 <mauke> :t let select [] = []; select (x : xs) = (x, xs) : map (fmap (x :)) (select xs) in select
08:42:38 <lambdabot> [t] -> [(t, [t])]
08:42:48 <mauke> > let select [] = []; select (x : xs) = (x, xs) : map (fmap (x :)) (select xs) in select "abc"
08:42:50 <lambdabot>   [('a',"bc"),('b',"ac"),('c',"ab")]
08:42:58 <sgk284> mauke: thanks!
08:43:08 <sgk284> way more elegant than what I was writing
08:43:37 <mauke> is there a cool way to do this with lenses?
08:45:10 <sgk284> lenses would be interesting for sure
08:45:55 <parcs> > map (head &&& tail) . filter (\xs -> length xs == 3) . permutations $ "abc"
08:45:58 <lambdabot>   [('a',"bc"),('b',"ac"),('c',"ba"),('b',"ca"),('c',"ab"),('a',"cb")]
08:46:00 <byorgey> I'm pretty sure there's a cool way to do it with lenses
08:46:11 <byorgey> something with zippers/one-hole contexts
08:46:15 <byorgey> not sure what it is though
08:46:18 <`nand`> yeah probably
08:46:25 <mauke> parcs: filter??
08:46:40 <`nand`> permutations includes shorter ones
08:46:43 <mauke> no
08:46:50 <`nand`> o
08:46:52 <parcs> o
08:46:53 <`nand`> it doesn't
08:46:54 <`nand`> no*
08:47:02 <parcs> > permutations "abc"
08:47:03 <lambdabot>   ["abc","bac","cba","bca","cab","acb"]
08:47:04 <mauke> o.o
08:47:08 <parcs> oops
08:47:18 <deus_rex> > map (head &&& tail) . permutations $ "abc"
08:47:20 <lambdabot>   [('a',"bc"),('b',"ac"),('c',"ba"),('b',"ca"),('c',"ab"),('a',"cb")]
08:47:27 <parcs> > \xs -> map (head &&& tail) . take (length xs) . permutations $ xs
08:47:29 <lambdabot>   No instance for (GHC.Show.Show ([c0] -> [(c0, [c0])]))
08:47:29 <lambdabot>    arising from a us...
08:47:30 <deus_rex> @t (&&&)
08:47:31 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
08:47:33 <parcs> > (\xs -> map (head &&& tail) . take (length xs) . permutations $ xs) "abc"
08:47:34 <deus_rex> @ty (&&&)
08:47:36 <lambdabot>   [('a',"bc"),('b',"ac"),('c',"ba")]
08:47:36 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
08:47:49 <parcs> does that work in general?
08:47:53 <parcs> > (\xs -> map (head &&& tail) . take (length xs) . permutations $ xs) "abcde"
08:47:55 <lambdabot>   [('a',"bcde"),('b',"acde"),('c',"bade"),('b',"cade"),('c',"abde")]
08:48:03 <byorgey> that doesn't keep the ordering though
08:48:11 <nicoo> @pf (\xs -> map (head &&& tail) . take (length xs) . permutations $ xs) "abcde"
08:48:11 <lambdabot> Maybe you meant: bf pl
08:48:16 <nicoo> @pl (\xs -> map (head &&& tail) . take (length xs) . permutations $ xs) "abcde"
08:48:16 <lambdabot> map (head &&& tail) (take 5 (permutations "abcde"))
08:48:27 <nicoo> :)
08:50:00 <sgk284> what does @pl stand for?
08:50:53 <sgk284> point-less
08:50:59 <sgk284> nevermind :)
08:51:33 <hamid> @src premutations
08:51:33 <lambdabot> Source not found. Just what do you think you're doing Dave?
08:51:51 <hamid> @src permutations
08:51:51 <lambdabot> Source not found. :(
08:52:59 <mauke> > permutations ""
08:53:01 <lambdabot>   [""]
08:53:40 <parcs> > transpose (permutations "abcd")
08:53:42 <lambdabot>   ["abcbcadccdbbdaadbbdaadcc","babcaccdbbdcadbbdaadccda","ccaabbbbdccdbbdaadc...
08:54:54 <parcs> very strange
09:00:06 <byorgey> what's strange?
09:02:01 <parcs> byorgey: the order of the permutations
09:03:13 <byorgey> it has the property that   permutations [1 .. n] == take (factorial n) (permutations [1..])
09:03:22 <byorgey> i.e. it works nicely with infinite lists
09:03:52 <byorgey> that doesn't explain all of it though
09:04:52 <Itkovian> hell yeah
09:05:02 <Itkovian> assassin's creed II and limbo purchased
09:05:12 <mauke> hello and welcome to #haskell
09:05:14 <parcs> byorgey: i don't get it
09:05:29 <parcs> byorgey: oh, i missed the infinite list at the end
09:05:35 <parcs> interesting
09:06:06 <byorgey> oh, there needs to be another take in there
09:06:39 <byorgey> but the idea is that if you look at, say, the first six elements of  permutations [1..4]  it's the same as  permutations [1..3], but with an extra 4 tacked on the end of all of them
09:06:47 <byorgey> > permutations [1..4]
09:06:48 <lambdabot>   [[1,2,3,4],[2,1,3,4],[3,2,1,4],[2,3,1,4],[3,1,2,4],[1,3,2,4],[4,3,2,1],[3,4...
09:06:53 <byorgey> > permutations [1..3]
09:06:55 <lambdabot>   [[1,2,3],[2,1,3],[3,2,1],[2,3,1],[3,1,2],[1,3,2]]
09:07:10 <byorgey> but then I'm not sure how to explain the rest
09:09:53 <byorgey> edwardk, roconnor
09:09:58 <edwardk> ?
09:10:01 <byorgey> whoops
09:10:08 <byorgey> hit enter too soon =)
09:10:40 <parcs> > transpose (permutations "abc")
09:10:42 <lambdabot>   ["abcbca","babcac","ccaabb"]
09:10:45 <byorgey> edwardk, roconnor: so is there a nice way to implement 'select' (e.g. select [1,2,3] = [(1, [2,3]), (2, [1,3]), (3, [1,2])] )  with lens?
09:11:05 <edwardk> not really. it changes the length of the resulting list
09:11:09 <byorgey> I tried poking around with 'holesOf traverse' but I can't find a way to convert the resulting Context thingys into tuples
09:11:38 <byorgey> edwardk: I don't follow
09:11:48 <edwardk> if you wanted [(1, [1,2,3]), (2, [1,2,3]), ([3, [1,2,3])] its easy
09:12:13 <mauke> is there a way to fancy up 'map (fmap (x :)) (select xs)'?
09:12:21 <byorgey> sure, that's just like   map (pos &&& extract) . holesOf traverse  or something, right?
09:12:34 <edwardk> if you wanted [(f,1 ), (g, 2), (h, 3) ]   where f g and h  replaced the target element with a new value, that also works
09:12:38 <rwbarton> maybe (1) map over the list with Just (2) use "insides" or whatever to zip around nondeterministically and replace a value with Nothing
09:12:48 <rwbarton> then post-process with catMaybes
09:13:06 <edwardk> but lenses generally don't change the shape of lists or trees by deleting elements
09:13:18 <byorgey> edwardk: ohh, now I understand, right.
09:14:08 <byorgey> so maybe that was the wrong question.  My real question is whether there's a nice way to generically get Hancock's "cursor down" operator for any functor
09:14:17 <edwardk> cursor down?
09:14:42 <edwardk> what does it do?
09:14:42 <shachaf> @ty let iaep e [] = [[e]]; iaep e (x:xs) = (e : x : xs) : (map (x:) (iaep e xs)) in iaep
09:14:44 <lambdabot> t -> [t] -> [[t]]
09:14:49 <byorgey> edwardk: f a -> f (a, Diff f a)
09:15:19 <byorgey> edwardk: I mean, it's basically just  holesOf traverse
09:15:28 <edwardk> thats basically holesOf. you can rethread it through the structure
09:15:40 <byorgey> except I want to get my hands on the resulting values + one-hole contexts
09:15:53 <byorgey> and I can't figure out how to do it
09:16:13 <edwardk> well, you can use withins in lens head
09:16:21 <edwardk> and that will give you zippers to each of the children
09:16:41 <edwardk> in head that works as a derivative of a magma rather than as a list zipper
09:16:42 <shachaf> withins gives you a list, not t (...)
09:16:50 <edwardk> true
09:17:12 * shachaf still hasn't figured out a satisfactory solution even to t a -> t (Store a (t a))
09:17:25 <edwardk> shachaf: see, had we given the user a way to get the magma out, we'd be fine now ;)
09:17:46 <shachaf> Well, withins *does* use mplus...
09:18:12 <shachaf> But anyway a magma is one particular kind of derivative.
09:18:41 <edwardk> byorgey: there are a few ways to do this, depending on what notion of a one-hole context you want. if you want just a lens to get there, there is rmap in C.L.Representable that gives you access to the path
09:19:20 <\rs> a very interesting intro on algebraic manipulations on types: http://www.haskellforall.com/2012/12/the-continuation-monad.html (Algebraic Data Types) could someone tell me where is the + * ^ magic come from?
09:19:34 <edwardk> but this requires the structure to be representable
09:19:41 <cmccann> I think the really important question here is can I use lenses to focus sunlight and set anthills on fire
09:19:55 <edwardk> f you want to be able to move around in the Dif, then you probably want to do something else
09:20:13 <edwardk> cmccann: sounds like a side-effect
09:20:17 <shachaf> \rs: If you think about the number of inhabitants of a type -- i.e. values that have that type -- it makes sense.
09:21:00 <\rs> shachaf: i mean stuff like (a -> b) <=> b ^ a  and Either a b <=> a + b
09:21:14 <byorgey> that's what shachaf meant
09:21:32 <byorgey> \rs: how many elements are there of the type  Either a b ?
09:21:43 <shachaf> \rs: For example: data Bool = False | True; data Ordering = LT | EQ | GT
09:22:08 <\rs> then?
09:22:11 <shachaf> How many things are there whose type is (Either Bool Ordering)? (Bool,Ordering)? (Bool -> Ordering)?
09:22:35 <shachaf> (Also Ordering -> Bool.)
09:23:44 <byorgey> \rs: the isomorphism really goes deeper than just number of elements, though.  Maybe I'm not understanding your question.  When you say "where does the magic come from" what do you mean?
09:23:50 <\rs> Either Bool Ordering = Bool + Ordering ?
09:25:03 <shachaf> I'm not sure what you're asking there.
09:25:36 <Nereid> Either, (,), and (->) are coproduct, product, and exponential in an appropriate category.
09:25:57 <Nereid> and if you pretend bottom doesn't exist, then you get what you expect for the number of elements.
09:26:33 <\rs> byorgey: i mean that the three rules listed in http://www.haskellforall.com/2012/12/the-continuation-monad.html is good to formalize how complicated types are transformed (for example, (a -> b) -> (c -> b) = (c -> (a -> b) -> b)
09:27:19 <byorgey> \rs: yes, and what is your question?
09:28:01 <\rs> byorgey: where does these thoughts come from? it seems rather elusive but magical
09:28:37 <rwbarton> it's actually completely unmagical
09:29:14 <byorgey> \rs: well, the way you might first think of it is by noting that if |A| is the number of elements of type A, then |A + B| = |A| + |B|,  |(A,B)| = |A| * |B|, and so on
09:29:24 <rwbarton> the whole point of addition on integers is that it is determined by how the cardinalities of sets add under union
09:29:39 <Nereid> disjoint union.
09:29:40 <rwbarton> it was literally invented for this purpose
09:29:54 <rwbarton> by prehistoric farmers or whatever
09:30:01 <shachaf> Addition on natural numbers, at least.
09:30:05 <rwbarton> right
09:30:30 <byorgey> \rs: then you can prove that all the usual laws of addition, multiplication, and exponentiation hold for types under isomorphism.
09:30:38 <elliott> thank god prehistoric farmers anticipated type theory
09:30:53 <byorgey> for example, addition is associative, and there is an isomorphism from  Either a (Either b c) to  Either (Either a b) c
09:31:21 <byorgey> in fact, djinn can tell us what it is
09:31:29 <byorgey> @djinn Either a (Either b c) -> Either (Either a b) c
09:31:29 <lambdabot> f a =
09:31:29 <lambdabot>     case a of
09:31:29 <lambdabot>     Left b -> Left (Left b)
09:31:29 <lambdabot>     Right c -> case c of
09:31:29 <lambdabot>                Left d -> Left (Right d)
09:31:31 <lambdabot>                Right e -> Right e
09:31:54 <shachaf> If the thing Djinn tells you is an isomorphism then you've gotten lucky, for the most part.
09:32:00 <\rs> A -> B <=> B ^ A    as there are exactly |B| ^ |A| morphisms from A to B and this definition satisfies all usual laws
09:32:09 <jfischoff> edwardk: did you see the issue I'm having with AD?
09:32:10 <lambdabot> jfischoff: You have 1 new message. '/msg lambdabot @messages' to read it.
09:32:15 <jfischoff> @messages
09:32:16 <lambdabot> shachaf asked 10h 13m 34s ago: When are you getting back?
09:32:19 <byorgey> \rs: right
09:32:31 <byorgey> shachaf: well, I think it usually tries hard to use all the arguments
09:32:32 <edwardk> jfischoff: haven't had a chance to look. anniversary, will probably be tomorrow ;)
09:32:53 <jfischoff> aye, nice :)
09:33:09 <byorgey> which will often result in an isomorphism if the types you give it are in fact isomorphic
09:33:09 <jfischoff> shachaf: getting back tonight actually
09:33:10 <mauke> @djinn Either a a -> Either a a
09:33:10 <lambdabot> f a = a
09:33:29 <shachaf> That's a pretty good isomorphism.
09:33:30 <mauke> @djinn (a, a) -> Either a a
09:33:31 <lambdabot> f (_, a) = Left a
09:33:37 <mauke> @djinn (a, b) -> Either a b
09:33:38 <lambdabot> f (a, _) = Left a
09:33:47 <Nereid> lambdabot's djinn doesn't show all possible solutions.
09:33:55 <Nereid> (or even tell you if there are more than one, :(
09:34:05 <Nereid> @djinn Either a b -> Either b a
09:34:06 <lambdabot> f a =
09:34:06 <lambdabot>     case a of
09:34:06 <lambdabot>     Left b -> Right b
09:34:06 <lambdabot>     Right c -> Left c
09:34:14 <Nereid> @djinn Either Void a -> a
09:34:15 <lambdabot> f a =
09:34:15 <lambdabot>     case a of
09:34:15 <lambdabot>     Left b -> void b
09:34:15 <lambdabot>     Right c -> c
09:34:32 <Nereid> that's not void.
09:34:39 <mauke> huh?
09:35:07 <Taneb> void :: Void -> a
09:35:22 <Taneb> Principle of explosion, I think
09:35:32 <Nereid> initial morphism, I think.
09:35:58 <mauke> inimorphs!
10:35:22 <jdavis> How come neither "hint" nor "Language.Haskell.Interpreter" return results in hoogle? And when I look at the repo, it looks like it hasn't been updated in years.
10:36:12 <shachaf> Hoogle doesn't search very much.
10:36:33 <shachaf> Hayoo! searches more.
10:36:38 <jdavis> Oh, ok.
10:37:02 <jdavis> So is that what I should primarily use for searching packages?
10:37:20 <shachaf> Depends on what kind of searching you're doing.
10:38:21 <jdavis> OK. I'll just try a few places then and see what comes up.
10:38:33 <jdavis> Hayoo does find hint.
10:38:45 <byorgey> jdavis: if you know what package you want to serch in, you can search for   foo +package  on Hoogle
10:39:14 <byorgey> Hayoo is good for searching all of Hackage.  Hoogle is good for searching by type.
10:39:27 <jdavis> Ok, that worked, too.
10:39:42 <monochrom> yikes, I keep forgetting about Hayoo :)
10:40:17 <jdavis> Would you say that it's reasonable to develop against hint, given that it's version < 1 and hasn't been updated in a couple years?
10:41:19 <monochrom> don't worry about the version number, people somehow just stick with 0.whatever.
10:42:01 <monochrom> long time no update is a problem iff the software actually doesn't work
10:42:13 <jdavis> OK
10:42:23 <jdavis> It seems to work and be reasonably well-documented.
10:42:45 <monochrom> I still use much older software
10:44:46 <jdavis> I'm investigating what it will take to embed haskell as a scripting language in postgres. Still working a few things out. One issue is that Language.Haskell.Interpreter eval does not accept an "import" statement, so I need to find a good way to do that.
10:45:28 <jdavis> What does GHCI do for that? Does it parse out the import statements ad-hoc, and then execute them? Or is there a cleaner way to do that?
10:46:29 <byorgey> jdavis: well, 'eval' doesn't accept import statements, but you can set up whatever imports you want in the interpreter monad prior to calling eval.
10:46:48 <jdavis> Right, but they come from the user somehow.
10:47:20 <byorgey> jdavis: I think you can still make that work.
10:47:29 <jdavis> So I either need to give them a separate "import" language that I make up myself, and they specify them separately, or I need to work it into the main program like in GHCI where it somehow differentiates them.
10:48:08 <jdavis> Not the most difficult parsing exercise, but I thought there might be a cleaner, more accepted way to do that.
10:48:12 <byorgey> jdavis: I don't understand what you mean about GHCI "differentiating" imports
10:48:39 <jdavis> Well, you can write "1 + 1" or "import Data.Set" in GHCI, and it somehow gets that right.
10:48:46 <byorgey> oh, I see.
10:48:53 <byorgey> yes, I guess it must be doing a bit of parsing itself.
10:49:11 <byorgey> I mean, you can also do  :set +s  or whatever and it also needs to be able to handle that
10:49:21 <jdavis> I suppose so. I wonder if it's ad-hoc or if it's using some cleaner approach (like a library function).
10:49:29 <byorgey> I don't know.
10:50:38 <shachaf>  | "import " `isPrefixOf` stmt
10:50:38 <shachaf>  = do addImportToContext stmt; return False
10:50:47 <jdavis> :set seems more like an escape, so that one is a little different. The import syntax it accepts seems identical to a full haskell program.
10:51:22 <jdavis> shachaf: is that our of the GHCI source?
10:51:26 <shachaf> Yep.
10:51:32 <byorgey> hehe, nice
10:51:33 <shachaf> Then it uses GHC.parseImportDecl str
10:51:41 <thetallguy> anyone have experience with arm/ubuntu/haskell?  Looking for a read on the general state of bumpiness.
10:51:55 <jdavis> Is there a convenient way to see the source on the web?
10:52:13 <lispy> jdavis: github.com/ghc/ghc
10:52:16 <shachaf> Perhaps https://github.com/ghc/ghc/tree/master/ghc
10:52:35 <shachaf> In particular the line I quoted is from InteractiveUI.hs
10:53:02 <lispy> I find the code in InteractiveUI.hs a bit hard to read
10:54:08 <jdavis> shachaf: Thank you! I think that answers my question.
10:56:06 <jdavis> lispy: yeah, especially for someone who doesn't know much haskell, like me.
10:56:55 <shirt> InteractiveUI.hs has lots of great code snippets that would be useful if extracted in a separate library
10:57:19 <lispy> I'm sure that can be said for much of ghc
10:58:10 <jdavis> now I need to figure out how it knows to wait for more lines, like "let f x = x*2", which is an error when passed to "eval" but works in ghci.
10:59:02 <shachaf> I would assume that "let" is special-cased too.
10:59:09 <monochrom> "let f x = x*2" does not lead to waiting for more lines
10:59:30 <monochrom> it is also not covered by eval
11:00:05 <jdavis> Oh.
11:02:25 <jdavis> It doesn't look like "let" is treated specially. It's not null, in declPrefixes, or "import ", so it falls into the "otherwise"
11:05:50 <r00723r0> ++ means list concatenation, correct?
11:05:54 <mauke> yes
11:05:54 <Botje> yes
11:06:07 <lightquake> is thinking of the haskell runtime as a very particular kind of VM at all useful?
11:07:06 <startling> I don't think there's a bytecode
11:07:56 <`nand`> is hackage.haskell.org down?
11:08:05 <`nand`> oh, seems not
11:08:08 <cmccann> works for me
11:08:09 <startling> wfm
11:08:13 <lispy> lightquake: sure. that's how HalVM works. Take the GHC RTS and make it run on the baremetal
11:08:34 <`nand`> what about hackage.haskell.org/trac/ghc ?
11:09:06 <cmccann> not so much
11:10:54 * lispy dislikes trac for a reason
11:11:09 <joar> `nand`: down for me
11:14:08 <lispy> multiline input in ghci is such a hack :(
11:14:12 <lispy> (reading that source still)
11:14:59 <`nand`> I like how your prompt setting doesn't affect it, so typing :{ gets me like 5 lines of loaded modules
11:16:19 <hugosthlm> Is arch linux a bad platform for Haskell?
11:16:41 <nik9000> hello irc channel that I am sure is wonderful.  I'm just learning Haskell and I'm stumped on something that doesn't work but *feels* like it *should* work.  I want to merge two (a -> Bool) functions together into one (a -> Bool).  a || b doesn't work because || only wants booleans but it feels like there should be some way to, well, convince it to work how I want it to. \n -> if a n then True else b n just doesn't seem right.  sorry for w
11:17:01 <joar> hugosthlm: why would it be?
11:17:04 <mauke> nik9000: \n -> a n || b n
11:17:07 <ion> hugosthlm: Any distro is fine.
11:17:13 <r00723r0> We don't write = for function blocks but we do for function expressions?
11:17:32 <mauke> r00723r0: we write = for let/where bindings
11:17:35 <jonkri> when a data type is used as both an Error and an Exception, what do you call it? :-)
11:17:36 <lambdabot> jonkri: You have 1 new message. '/msg lambdabot @messages' to read it.
11:17:47 <mauke> Errception
11:17:51 <jonkri> :-D
11:17:55 <ion> Exceptror
11:17:59 <nik9000> mauke: that just didn't feel right - if that is idiomatic I'll go with it
11:18:01 <joar> hugosthlm: are you worried about something specific? My perception is that arch is pretty good at installing almost *anything*.
11:18:05 <cmccann> > filter (liftA2 (||) (< 4) (> 8)) [0..10]
11:18:06 <lambdabot>   [0,1,2,3,9,10]
11:18:11 <lispy> `nand`: I don't think that would be too hard to fix
11:18:14 <mauke> nik9000: liftA2 (||)
11:18:23 <jonkri> Errception is better, i think :-)
11:18:26 <r00723r0> mauke: calcBmis xs = [bmi | (w, h) <- xs, let bmi = w / h ^ 2]
11:18:31 <joar> hugosthlm: This article may help you on the road: https://wiki.archlinux.org/index.php/Haskell_Package_Guidelines
11:18:31 <lispy> `nand`: I think we want to introduce a new prompt string for the multiline case
11:18:38 <mauke> r00723r0: go on
11:18:39 <jonkri> does it sound like i'm doing something wrong?
11:18:41 <r00723r0> mauke: talking about the first equals.
11:18:50 <mauke> r00723r0: that's a 'where' binding
11:18:54 <cmccann> > filter ((||) <$> (< 4) <*> (> 8)) [0..10] -- r00723r0: or this way
11:18:55 <lambdabot>   [0,1,2,3,9,10]
11:19:05 <r00723r0> mauke: I don't see a where.
11:19:18 <mauke> r00723r0: do you have a 'module' declaration at the top of your file?
11:19:19 <r00723r0> Is it implicit?
11:19:19 <ion> r00723r0: bmis = map bmi; bmi (w,h) = w/h^2
11:19:30 <mauke> r00723r0: if not, it defaults to 'module Main (main) where'
11:19:31 <r00723r0> mauke: I'm reading a tutorial.
11:19:35 <r00723r0> I see.
11:19:58 <`nand`> lispy: I think we would want to indent it or something
11:20:01 <lispy> `nand`: https://github.com/ghc/ghc/blob/master/ghc/InteractiveUI.hs#L704 that's where you'd have to fetch it, default would be "%s| "
11:21:03 <nik9000> mauke: that makes sense.  I was having trouble wrapping my head around that.  which is normal, I imagine.
11:22:02 <lispy> `nand`: and here is the data type to add mlPrompt to: https://github.com/ghc/ghc/blob/master/ghc/GhciMonad.hs#L63
11:22:07 <lispy> `nand`: what do you want to indent?
11:22:49 <r00723r0> Haskell optimizes recursion, right?
11:23:07 <mauke> what
11:23:08 <`nand`> lispy: the prompt itself; to distinguish it from a non-multi-line prompt?
11:23:16 <`nand`> lispy: I haven't thought this through
11:23:18 <r00723r0> TCO for example?
11:23:27 <`nand`> lispy: just thought it's a better behavior than, yknow, the current
11:23:39 <lispy> `nand`: my idea is just to make the multiline prompt (currently "%s| ") user configurable
11:23:40 <mauke> r00723r0: function calls don't use the stack
11:23:50 <`nand`> lispy: yes, but as a user, I don't really want to configure two prompts
11:24:02 <lispy> really?
11:24:06 <`nand`> what would I put in the multi-line prompt?
11:24:16 <lispy> in your case, "| "
11:24:23 <lispy> Just remove the modules
11:24:33 <r00723r0> mauke: what uses the stack?
11:24:36 <Philippa> r00723r0: TCO doesn't quite mean what you'd expect in a lazy language, so sometimes you won't get what you expect
11:25:02 <r00723r0> Philippa: I know it just takes away the stack from proper recursion.
11:25:04 <mauke> r00723r0: forcing thunks
11:25:18 <r00723r0> mauke: no other language construct?
11:25:25 <`nand`> depends on which evaluation model you're looking at; Haskell is a language definition
11:25:34 <r00723r0> GHC.
11:25:38 <lispy> r00723r0: ghc uses a graph reduction to do evaluation. In particular, it uses a heavily optimized algorithm that pushes certain things on the stack, but not in the way an imperative language would use the stack
11:26:03 <r00723r0> lispy: interesting.
11:26:09 <`nand`> GHC uses eval/apply (as opposed to push/enter or whatever the alternative is called), so it skips the stack where possible
11:26:12 <`nand`> even for its evaluation
11:26:53 <lispy> r00723r0: maybe start here? http://www.haskell.org/haskellwiki/GHC_optimisations#Execution_Model
11:27:07 <Philippa> I assume the strict subset does TCO sensibly?
11:27:12 <r00723r0> I'm still reading a tutorial. :)
11:27:23 <`nand`> joar: seems to have loaded now; the trac/ghc stuff
11:27:32 <shachaf> Talking about TCO doesn't really make much sense in the context of Haskell evaluation.
11:27:48 <shachaf> I guess people have already said that.
11:28:08 <lispy> r00723r0: this and the associated haskellwiki pages (linked from the package description) are worth a look too: http://hackage.haskell.org/package/ministg
11:28:16 <lispy> r00723r0: I seek to overwhelm ;)
11:28:34 <shachaf> lispy: You don't need to overwhelm to explain this.
11:28:40 <shachaf> A simple substitution model would do just as well.
11:28:42 <`nand`> there's a whole series of books and papers on GHC's evaluation model
11:28:47 <`nand`> look up stuff by SPJ
11:28:49 <shachaf> You don't even need graph reduction.
11:28:59 <`nand`> right
11:29:19 <`nand`> the point about TCO was already made, this seemed to be heading more in the direction of ‘what is GHC's evaluation model like’
11:29:26 <r00723r0> One day processors will implement Haskell.
11:29:38 <`nand`> r00723r0: they already have
11:29:44 <`nand`> well, not directly
11:29:48 <r00723r0> I mean directly. :)
11:29:52 <`nand`> that would be pointless
11:29:58 <`nand`> you don't see processors running C++ natively
11:30:23 <r00723r0> That is a good point. Why is that?
11:30:34 <lispy> there is a CPU that runs the graph reduction natively
11:30:38 <lispy> the reduceron?
11:30:41 <`nand`> lispy: yeah
11:30:41 <lispy> something like that
11:30:42 <mauke> r00723r0: what would be the point?
11:30:45 <`nand`> lispy: there are also a few before it
11:30:49 <r00723r0> mauke: speed.
11:30:51 <`nand`> r00723r0: there would be so much overhead
11:30:56 <mauke> r00723r0: why do you think it would be faster?
11:31:04 <`nand`> r00723r0: you can compile C++ into something much simpler and run it with pretty much the same result
11:31:13 <r00723r0> Well clearly it would be faster if there's less software involve to compute Haskell.
11:31:18 <mauke> r00723r0: why?
11:31:22 <`nand`> the compiler only runs once
11:31:28 <mauke> you'd have to basically implement a C++ compiler in hardware
11:31:30 <shachaf> mauke: Because clearly.
11:31:39 <r00723r0> Don't scoff, I think I'm making sense.
11:31:46 <mauke> ...
11:31:47 <joar> `nand`: I can confirm that; You are not hallucinating.
11:31:48 <`nand`> r00723r0: the compiler runs only once..
11:31:51 <lispy> which do you want to be simpler the RTS/translation to object code or the implementation for the object languages?
11:31:57 <r00723r0> `nand`: that's true.
11:32:45 <`nand`> mauke: easy, just solder together gcc. Just hope you don't have to perform any security patches in the near future
11:32:52 <lispy> Besides, we don't want compiler writers to get bored ;)
11:33:16 <ion> r00723r0: http://en.wikipedia.org/wiki/Lisp_machine#End_of_the_Lisp_Machines
11:33:18 <r00723r0> Are there Haskell interpreters/JITs?
11:33:25 <`nand`> r00723r0: yes
11:33:42 <`nand`> lambdabot uses one, for example
11:33:49 <`nand`> so does GHCi
11:33:51 <`nand`> and runhaskell
11:34:01 <r00723r0> Are there JITs?
11:34:04 <shachaf> @google haskell jit
11:34:06 <lambdabot> http://www.haskell.org/haskellwiki/HaskellImplementorsWorkshop/2012/Schilling
11:34:06 <lambdabot> Title: HaskellImplementorsWorkshop/2012/Schilling - HaskellWiki
11:34:15 <sclv> oh man loving these llvm bindings
11:34:23 <sclv> i can write a polymorphic stack!
11:34:43 <shachaf> sclv: Polypiling?
11:34:45 <r00723r0> That's awesome.
11:34:46 <sclv> the llvm dsl in haskell is more powerful than c
11:34:46 <`nand`> well you can always invoke GHC-as-library to compile and run native code, I guess
11:34:55 <`nand`> hey, xmonad would qualify for that, right?
11:35:08 <sclv> i think it invokes ghc-as-executable
11:35:16 <`nand`> oh, yeah, probably
11:35:20 <`nand`> still, not much of a difference
11:35:44 <shachaf> r00723r0: You should get a less numbery nick. It would be better.
11:35:46 <`nand`> effectively, you're running haskell code at runtime
11:36:07 <r00723r0> shachaf: you should get a more numbery nick.
11:36:17 <shachaf> I don't think so.
11:36:29 <r00723r0> Well, you like numbers, don't you?
11:36:41 <shachaf> OK, you should get a less digity nick.
11:37:01 <r00723r0> How am I supposed to use numbers in my nick without digits?
11:37:18 <`nand`> ‘shachaf’ is a perfectly fine number
11:37:19 <parcs> there's a person doing a haskell jit for their doctorate
11:37:27 <h45k3311R0072> l337
11:37:28 <ion> shachaf: We can simply refer to rr without the numbers.
11:37:44 <r00723r0> Hahaha.
11:37:53 <ion> λ> "shachaf" ^?! base 36
11:37:55 <ion> 61995208839
11:38:26 <`nand`> base?
11:38:31 <shachaf> Base.
11:38:38 <`nand`> what exports it?
11:38:40 <ion> nand: Numeric.Lens in lens master.
11:38:51 * `nand` updates
11:38:58 <shachaf> ion: You should call it HEAD even though that's not correct git terminology at all.
11:39:24 <`nand`> (why does HEAD refer to in git terms?)
11:39:24 <ion> shachaf: Well, it is kind of correct git terminology, it just refers to a different thing. :-P
11:39:27 <`nand`> s/why/what/
11:39:44 <ion> nand: Whatever you have checked out in your working tree at a given moment in time.
11:40:03 <`nand`> okay, so it's Numeric.Lens in ion's lens HEAD? :P
11:40:08 <shachaf> ion: Yes, that's what makes it incorrect git terminology, as opposed to not git terminology.
11:41:11 <ion> “master” also refers to whatever “master” is in some unspecified repo, though. :-P
11:41:51 <Puffton> Howdy, folks
11:42:13 <ion> https://github.com/ekmett/lens/blob/master/src/Numeric/Lens.hs
11:42:59 <joar> "upstream master" would be the correct term
11:43:13 <Puffton> Isn't (*2) a partially applied anonymous function? Or do anonymous functions require lambda notation?
11:43:18 <Puffton> \x -> x * 2
11:43:19 <Puffton> like that
11:43:21 * hackagebot OddWord 1.0.0.1 - Provides a wrapper for deriving word types with fewer bits.  http://hackage.haskell.org/package/OddWord-1.0.0.1 (RobinKay)
11:43:27 <t7> (*2) is a function
11:43:38 <`nand`> it's anonymous, in that it isn't given a name, I guess
11:43:41 <`nand`> but yes, it's a function
11:44:03 <mauke> nymous = (*2)
11:44:09 <mauke> now it has a name!
11:44:12 <ion> puffton: And yes, those two things mean the same thing.
11:44:13 <shachaf> "anonymous" is a mostly useless word.
11:44:18 <shachaf> It's a function.
11:44:18 <Puffton> ok, but not strictly anonymous then?
11:44:28 <`nand`> depends on what you mean by ‘anonymous’
11:44:37 <Puffton> I'm trying to make sense of the word myself
11:44:40 <Puffton> which is why I'm just giving examples
11:44:41 <shachaf> The best way to resolve this issue is to stop caring about what's anonymous and what isn't.
11:44:43 <`nand`> forget about it
11:44:53 <mauke> Puffton: not all words are sensical
11:45:01 <mauke> has anyone really been far even as decided to use even go want to do look more like?
11:45:54 <`nand`> mauke: no
11:46:43 <joar> mauke: I once did that thought more like full has been yes cool
11:47:32 <ion> mauke: everywhere like such as and I believe that they should.
11:50:00 <joar> ion: did you ever type that more than ever has been relative to six five four one brought as with seen ever feel anonymous function refrigerator.
11:51:25 <ion> #haskell is doing a rather good job of emulating a Markov chain.
11:52:22 <`nand`> “ATTENTION! You have an old time package in your GHC Tree! Please remote it (eg. "rm -r libraries/time"), and then run "./sync-all get" to get the new repository.” <- I deleted it, ran the command, throws the exact same error
11:52:26 <`nand`> s/remote/remove/
11:53:22 <joar> #haskell is ever been refrigerator :) yes .Plus one ion++ " -Provides a wrapper for anonymous package (RobinKay)
11:53:43 <mauke> >implying
11:54:13 <shachaf> lispy: That page is somewhat out of date.
11:54:16 <`nand`> it worked a few hours ago on a different machine. Is this the part where I rm -rf ghc; re-clone the repository, and re-run sync get from scratch?
11:56:08 <`nand`> eh, screw it, I'll just go with what I said
11:56:55 <`nand`> can git cache objects in ~/.git or something like darcs does?
11:57:13 <`nand`> So I don't have to ever spend time redownloading all of this stuff if I re-clone in the future
11:57:45 <ion> nand: You can use --referrence <other local repository> when cloning to grab objects from there.
11:57:46 <joar> what kind of objects?
11:58:03 <`nand`> ion: ah, okay
11:58:04 <ion> joar: Git objects
11:58:27 <lispy> I think the ghc trac is back up
11:58:47 <ion> nand: (modulo typos)
11:59:01 <lispy> shachaf: which page?
11:59:06 <lispy> shachaf: I posted several links in a row
11:59:39 <shachaf> GHC_optimisations#Execution_Model
11:59:59 <joar> ion: gotcha; "all git objects"
12:00:05 <shachaf> Perhaps it was never in date in the first place.
12:01:40 <ion> ("e76dpe", "t7ee587") & partsOf (both . traverse) . base 36 *~ 2
12:15:52 <Puffton> Another tricky definition-question: If a function has a recursive call in its definition, which is never called, is it still a recursive function?
12:16:14 <vanseverk> Why would you have a call when it's never called?
12:16:20 <shachaf> No, that's an argument about words.
12:16:43 <shachaf> It's more pointlessness. Define "recursive function" and then people can answer.
12:16:51 <`nand`> if it's never called, it isn't recursive
12:16:56 <shachaf> This way it's just a recipe for getting people to argue for their pet definition.
12:16:56 <`nand`> that seems trivially true
12:17:10 <mauke> the function isn't recursive, the definition is
12:17:11 <mauke> NOW WHAT
12:17:26 <`nand`> who cares about the definition
12:17:46 <mauke> Puffton
12:18:05 <shachaf> A function is a set of ordered pairs. I don't know how a set can be recursive.
12:18:26 <mauke> >implying
12:18:28 <shachaf> (Unless you're referring to non-well-founded set theory or something.)
12:18:49 <shachaf> What am I implying?
12:19:19 <`nand`> edwardk: how did you get the lens.github.com domain?
12:19:42 <shachaf> By getting the account at github.com/lens
12:20:15 <`nand`> is this connected to the ‘lens.github.com’ repository?
12:20:38 <arkydo> I get an error while try to load a script: http://sprunge.us/XQDA
12:20:39 <shachaf> Yes.
12:21:02 <shachaf> That's not a script.
12:21:12 <`nand`> does github just automatically recognize aptly named repositories, or is there some extra configuration for it somewhere?
12:21:57 <shachaf> @google how do i host a website on github
12:22:03 <lambdabot> http://pages.github.com/
12:22:04 <shachaf> I assume it's something like that.
12:22:09 <lambdabot> Title: GitHub Pages
12:23:25 <startling>  `nand`: for a user page, you just make a repository named myname.github.com. for projects, you push the website to an empty branch called gh-pages iirc
12:23:35 <`nand`> shachaf: looks like it's the case
12:23:44 <`nand`> startling: fair enough
12:23:46 <shachaf> arkydo: "If we wanted to multiply our list by 8 in an imperative language and did doubleMe(doubleMe(doubleMe(xs))), it would probably pass through the list once and make a copy and then return it."
12:23:55 <arkydo> I get this error when I try to load the script: func.hs:2:1: Parse error: naked expression.
12:23:56 <shachaf> arkydo: That paragraph isn't talking about Haskell, and that's not Haskell code.
12:24:22 <shachaf> (Although it could be parsed and evaluated as Haskell.)
12:24:36 <arkydo> shachaf: How can I do that?
12:24:42 <`nand`> shachaf: it could be, with -XTemplateHaskell
12:24:43 <shachaf> Do what?
12:24:57 <mauke> arkydo: yes, you have a naked expression in that file
12:24:58 <`nand`> assuming doubleMe :: ... -> Q [Dec]
12:25:02 <mauke> what did you expect it to do?
12:25:17 <shachaf> `nand`: That's not the point. I'm not talking about that file, I'm talking about the expression "doubleMe(doubleMe(doubleMe(xs))"
12:25:33 <`nand`> oh, missing )
12:25:35 <`nand`> you're right
12:25:37 <shachaf> Er, no.
12:25:40 <`nand`> ?
12:25:46 <mauke> `nand`: ?
12:25:48 <shachaf> That was just me miscopying.
12:25:53 <`nand`> I see that now
12:26:16 <shachaf> In the context of the book that expression came from, that's not Haskell code.
12:26:22 <`nand`> I see
12:27:07 <startling> woah, what's this? https://github.com/lens/lens-core
12:27:11 * `nand` wasn't aware it came from any book, is it from RWH or something?
12:27:21 <shachaf> startling: An experiment in splitting up lens.
12:27:30 <shachaf> Pretty much abandoned, though we might do something like it later.
12:27:36 <shachaf> (But the code has changed quite a bit since then.)
12:27:56 * shachaf wasn't aware either, but fortunately Google is aware.
12:28:25 <startling> shachaf: I'm never gonna believe a lens faq again
12:29:38 <shachaf> startling: Hmm, I wonder whether that's out of date with profunctors.
12:30:15 <startling> shachaf: no idea!
12:30:41 <shachaf> Hah, it still talks about Projection.
12:30:46 <shachaf> Someone ought to update it.
12:30:49 <shachaf> (Not me.)
12:34:06 <shachaf> Nereid ought to fix it.
12:43:06 <lispy> shachaf: it's a wiki, you should update it :)
12:50:20 <edwardk> startling: lens-core was an experiment. i wanted to see how minimal a support package would be. in theory it'd just be Gettable and Settable now, and depend on profunctors
12:50:38 <edwardk> the pain in the ass is that you still wind up wanting two packages to support everyone
12:52:16 <startling> understood!
12:54:55 <ihm123> can someone explain why difference lists are necessary when we have lazy evaluation?
12:55:23 <shachaf> They aren't necessary.
12:55:23 <c_wraith> That's an odd question
12:55:31 <arkydo> Does anyone know to get identation in vim for Haskell?
12:55:33 <c_wraith> Can you explain what you mean a little better?
12:55:35 <ihm123> sure
12:55:41 <`nand`> arkydo: press tab?
12:56:40 <ihm123> What I mean is, isn't `xs ++ ys` effectively equivalent to `(xs ++) . (ys ++) $ []` in terms of the O(1) appending?
12:57:25 <ihm123> since when the actual list is built both expressions do the same thing, and before then, `xs ++ ys` is a thunk
12:57:57 <shachaf> ihm123: Think of ((xs ++ ys) ++ zs)
12:58:04 <simpson> I thought that it was because you'll get another thunk with each unwrapping of ++, so you'd end up with a thunk for every item in the first list.
12:58:09 <c_wraith> except nested about 20 levels deeper
13:01:12 <`nand`> Can cabal-install work with multiple versions of ghc?
13:01:42 <`nand`> say I have 7.6.1 and 7.4.2 installed, and I want to tell it to install a certain library using ghc 7.4.2
13:01:55 <`nand`> that is; to ~/.ghc/x86_64-linux-7.4.2 instead of -7.6.1
13:02:11 <`nand`> or does it not work that way?
13:02:51 <edwardk> ihm123: if i pile up (++)'s i have to walk over each of the ones i've bolted on. difference lists trade the fact that if you re-evaluate with a different tail you have to force the entire structure all over again, for not having to walk hand-over-hand over the same elements
13:03:12 <edwardk> ihm123: this is a fundamental tension in an immutable world
13:03:19 <edwardk> strict _or_ lazy
13:03:28 <edwardk> the strict guys just have to pay the price up front
13:04:02 <ihm123> oh i see
13:04:03 <ihm123> thanks
13:05:50 <hugosthlm> Anyone have a nice description of how to keep your Haskell installation up to date and  in sync with a platform like Arch?
13:06:24 <`nand`> oh, I can use --with-compiler=/home/nand/ghc-head/bin/ghc
13:09:09 <lispy> hugosthlm: dons used arch linux for a while and back then it was always up to date (I think largely because of him). I don't know if many people still use Arch
13:09:59 <lispy> hugosthlm: as for keeping things up to date, I run cabal update (to get the latest list from hackage) and then use cabal-dev to actually build things. That way each thing I build gets the latest versions of its deps that it can use
13:10:01 <hugosthlm> lispy, so, there is no wasy way?
13:10:13 <lispy> Well, I don't properly know. I've never tried arch
13:10:31 <lispy> there is also the tool cab that is supposed to recursively update your packages
13:10:35 <lispy> ?hackage cab
13:10:35 <lambdabot> http://hackage.haskell.org/package/cab
13:12:37 <hugosthlm> lispy: so, you rebuild everything? The old  packages, any way to get rid of?
13:12:56 <tgeeky> If only we were given the ability to lock the dozen maintainers of packages (which do almost the same thing (say, manage latest versions)) in a room somewhere and demand that they have only one or two packages when they emerge.
13:16:02 <hugosthlm> Would you keep all Haskell code in ONE cabal database?
13:16:22 <hugosthlm> Local or global?
13:19:07 <Twisol> Wow. I've never even used `lens`, but I just caught myself defining an "over xyz" function in JavaScript. Haskell is awesome.
13:22:47 <flebron> Twisol, what does that function do?
13:23:30 <Twisol> digs into part of a value, applies a function to that part, then puts the result back where the old value was
13:23:34 <Twisol> AFAIK.
13:24:00 <flebron> Interesting. And in JS how would you do it, having no algebraic constructors?
13:25:12 <Twisol> roughly, function overValueOne(obj, f) { obj.val1 = f(obj.val1); return obj }
13:25:25 <stephenjudkins> Twisol: i suppose you could call it a "lens", and it could be kind of useful, if it's mutating an object
13:25:51 <Twisol> The concept of it is helping me refactor some ugly code.
13:25:53 <stephenjudkins> but IMO a the term "lens" is really only really meaningful for immutable data structures
13:26:02 <Twisol> I never called it a lens ;)
13:26:12 <Twisol> I was referring to the package.
13:27:00 <Twisol> The value I'm operating over is actually a bitfield, so the data's actually immutable anyway.
13:27:42 <stephenjudkins> flebron: if you're interested, https://docs.google.com/file/d/0ByK3AAy5ubqaMTQ3M2FiZTktODQyNi00OTc2LTkwNTgtNzQ2MWE0OWVlZWJk/edit?hl=en_US
13:28:51 <flebron> I must read "applicative programming with effects" first :))
13:29:57 <hugosthlm> I see that cabal-dev creates ONE build.
13:35:56 <Rileld> I'm having trouble with the pipes library. I'm trying to write a simple example that traverses the file system, and prints the name of each directory. Thanks for any help
13:35:58 <hpaste> Rileld pasted “Pipes library ” at http://hpaste.org/79998
13:38:08 <plat0> Rileld: Check this out: http://www.reddit.com/r/haskell/comments/cs54i/how_would_you_write_du_in_haskell/c0uvqqo
13:38:19 <mauke> childDirs <- liftIO $ do { contents <- getDirectoryContents path; filterM isSubDir contents }
13:38:23 * hackagebot bindings-cctools 3.6.1.0.1.0.0 - Bindings to the CCTools WorkQueue C library  http://hackage.haskell.org/package/bindings-cctools-3.6.1.0.1.0.0 (BadiAbdulWahid)
13:43:23 * hackagebot cctools-workqueue 3.6.1.0.1.0.0 - High-level interface to CCTools' WorkQueue library  http://hackage.haskell.org/package/cctools-workqueue-3.6.1.0.1.0.0 (BadiAbdulWahid)
13:44:58 <Rileld> plat0: What I'm trying to figure out is how to use pipes and how useful it is. I'd be ok writing this otherwise :)
13:47:05 <hpaste> Rileld annotated “Pipes library ” with “Pipes library  (annotation)” at http://hpaste.org/79998#a79999
13:47:12 <Rileld> mauke: your suggestion produced a different error, that I also can't figure out
13:51:00 <mauke> Rileld: looks like your type signature is wrong
13:51:10 <mauke> @hackage pipes
13:51:10 <lambdabot> http://hackage.haskell.org/package/pipes
13:52:19 <mauke> Rileld: yeah, that 'r' should be '()'
13:52:50 <Rileld> Oh, because it terminates?
13:53:11 <mauke> because it returns ()
13:54:09 <Rileld> mauke: Then I get the original error again
13:54:33 <mauke> unlikely
13:57:21 <adek05> Aeson library can can map JSON to Haskell structures with defined mapping between JSON field name and record field. However the mapping funciton definition cannnot be in the same file as invocation of $(deriveJSON map ''type). Is it of good practice if I place mapping function in separate file or there is other, better way to overcome this error?
13:59:05 <Rileld> mauke: it kinda works if I use lift where you had liftIO. It doesn't recurse into subfolders for some reason.
14:00:13 <Rileld> mauke: nvm. I see what's wrong now. Thanks for your help
14:16:54 <zenzike> I expect this is a question for the cafe, and that it's because the statistics package isn't finished, but does anyone know why there's no DiscreteGen PoissonDistribution instance?
14:23:24 * hackagebot iptables-helpers 0.4.2 - Static checking of iptables rules  http://hackage.haskell.org/package/iptables-helpers-0.4.2 (EvgenyTarasov)
14:36:40 <shachaf> Oh, tagToEnum# is a nice magical function.
14:36:56 <shachaf> Magical enough that you can't :t it
14:38:06 <latro`a> wut
14:39:13 <aristid> shachaf: where is it defined?
14:39:44 <shachaf> GHC.Prim, I guess?
14:39:49 <shachaf> Yep.
14:41:11 <ion> nice
14:43:23 <`nand`> neutrino: oh hey, I managed to fix that HSbase.o `stat' linking error
14:43:25 * hackagebot csv-nptools 0.2.0 - A collection of CSV tools  http://hackage.haskell.org/package/csv-nptools-0.2.0 (NicolasPouillard)
14:43:33 <`nand`> I don't know why, but after building off GHC HEAD, it worked fine
14:45:27 <r00723r0> zipWith' f (x:xs) (y:ys) = f x y : zipWith' f xs ys
14:45:34 <r00723r0> What does : mean after f x y?
14:45:42 <`nand`> :t (:)
14:45:43 <lambdabot> a -> [a] -> [a]
14:45:43 <ion> @type (:)
14:45:44 <lambdabot> a -> [a] -> [a]
14:46:01 <ion> [4,5,6] is sugar for 4 : 5 : 6 : []
14:46:08 <r00723r0> Oh, got it.
14:46:24 <r00723r0> So that's just whitespace.
14:46:36 <`nand`> what's just whitespace?
14:46:46 <ion> No, (:) prepends an item to a list.
14:46:52 <ion> > 4 : [5,6]
14:46:53 <lambdabot>   [4,5,6]
14:46:56 <Hafydd> 4 : 5 : 6 : [] is sugar for (:) 4 ((:) 5 ((:) 6 []))
14:47:08 <r00723r0> It prepends (f x y) to (zipWith' f xs ys)
14:47:21 <ion> yes
14:50:13 <r00723r0> Could I as well do f x y:zipWith' f xs ys?
14:50:24 <r00723r0> Since function binding is so important in Haskell syntax?
14:50:29 <ion> Yes, that’s the same code.
14:50:35 <ion> > 4 + 5
14:50:37 <lambdabot>   9
14:50:37 <ion> > 4+5
14:50:39 <lambdabot>   9
14:53:08 <r00723r0> Do people usually use parentheses in these situations?
14:53:18 <ion> In what way?
14:53:51 <Clint> 4+(5)
14:53:58 <r00723r0> zipWith' f (x:xs) (y:ys) = f x y : zipWith' f xs ys
14:54:13 <ion> The two sets of parentheses in that are necessary.
14:54:17 <r00723r0> I would rather see (f x y):(zipWith' f xs ys) personally.
14:54:48 <shachaf> You'll get over it.
14:54:49 <ion> You usually avoid redundant parentheses, but as far as i’m concerned, feel free to use them if you like to.
14:56:07 <mauke> r00723r0: that's crazy
14:56:15 <mauke> I wouldn't write (1 + 2)*3 either
14:56:42 <mauke> except this is more like (a * b)+c
14:56:58 <r00723r0> Are types functions?
14:56:58 <ion> mauke: How would you prefer to write (1 + 2)*3?
14:57:09 <ion> Type constructors are type-level functions.
14:57:12 <r00723r0> > String()
14:57:13 <lambdabot>   Not in scope: data constructor `String'
14:57:30 <mauke> ion: (1+2) * 3 or (1 + 2) * 3
14:57:53 <ion> String doesn’t exist in the namespace of values, it only exists in the namespace of types. And it doesn’t take a parameter.
14:57:55 <shachaf> 1+2 * 3+4
14:58:18 <r00723r0> ion: that's useful. How can I access the namespace of types other than defining one?
14:58:31 <mauke> ...
14:58:32 <Twisol> type signatures, usually
14:58:48 <r00723r0> So there's no type introspection or that kind of thing?
14:58:54 <shachaf> You need to pay a fee to access the namespace of types.
14:59:02 <Clint> :t "insert fee here"
14:59:03 <lambdabot> [Char]
14:59:14 <mauke> > typeOf ""
14:59:15 <lambdabot>   [Char]
14:59:25 <mauke> r00723r0: it's all made of wood
14:59:37 <r00723r0> What the hell is anyone saying right now?
14:59:40 <shachaf> There is "type introspection" but it won't help you with any of the problems that you think it'll help you with.
14:59:46 <ion> In ‘foo :: Bar’ foo is a value and Bar is a type. In ‘data Quux = Poit’ Quux is a type and Poit is a value.
14:59:51 <shachaf> So you should forget about it, and learn how types work.
14:59:53 <r00723r0> I just want to know, to see what I can do.
14:59:57 <r00723r0> Can I do it?
15:00:03 <mauke> do what?
15:00:09 <r00723r0> Deal with types introspectively.
15:00:17 <flebron> (The objects of Hask are types, its morphisms are your functions. You write functions, but the functions will take _values_ in certain objects of Hask.)
15:00:20 <ion> In order to achieve what?
15:00:24 <r00723r0> Knowledge.
15:00:24 <mauke> r00723r0: what does that mean?
15:00:29 <r00723r0> Of the ability to do something.
15:00:34 <shachaf> No, you can't.
15:00:39 <mauke> but do *what*?
15:00:45 <mauke> "deal with types" doesn't mean anything
15:00:46 <flebron> What do you mean by "introspectively"? Do you want to be moody while you inspect types?
15:00:59 <r00723r0> Say I wanted to change a particular function's return type on the fly.
15:01:03 <r00723r0> I don't know why.
15:01:08 <`nand`> types are static
15:01:09 <flebron> But how would that make sense?
15:01:10 <Twisol> Do you mean like Java's reflection, just so we can get out of this mire of abstractness?
15:01:16 <mauke> what does "change a function's return type" mean?
15:01:22 <flebron> It's a function, it returns what it returns.
15:01:35 <Twisol> r00723r0: You can compose the function with something else that maps between return type a and return type b.
15:01:36 <flebron> If you want polymorphism, Haskell has that.
15:01:48 <r00723r0> OK, objects always have a type, right?
15:01:58 <mauke> what's an object?
15:02:11 <r00723r0> A variable contained within a name.
15:02:19 <Twisol> we just call that a value
15:02:27 <r00723r0> Values always have a type, right?
15:02:27 <flebron> 5 is not an object?
15:02:28 <ion> Values don’t need to have a name.
15:02:41 <mauke> names don't contain variables
15:02:45 <shachaf> A variable contained within a name wrapped in an enigma.
15:02:47 <mauke> r00723r0: no, expressions do
15:02:59 <r00723r0> mauke: what do you call the things you assign expressions to?
15:03:02 <Twisol> *sigh* Yes, values have types.
15:03:06 <Twisol> Those are names.
15:03:13 <lightquake> are there any good tutorials on using reactive-banana?
15:03:16 <Twisol> We "name" expressions.
15:03:24 <hiptobecubic> this is great
15:03:33 <`nand`> I don't know what's going on in this conversation
15:03:35 <shachaf> I suspect mauke is being the most correct here.
15:03:35 <`nand`> it sounds very meta
15:03:36 <Clint> > let this = "great" in this
15:03:37 <lambdabot>   "great"
15:03:39 <Twisol> We don't evaluate expressions and put the result into a variable. Haskell is non-strict, so the expression is only evaluated when we want.
15:03:48 <r00723r0> `nand`: I'm trying to understand Haskell.
15:03:54 <flebron> r00723r0, have you read LYAH?
15:04:04 <Twisol> shachaf: most correct is sometimes not conducive to understanding, sadly.
15:04:05 <r00723r0> flebron: reading it right now actually.
15:04:21 <shachaf> Twisol: Well, saying wrong things is also not conducive to understanding.
15:04:29 <flebron> OK, well, that should go through the process of "understanding Haskell".
15:04:39 <Twisol> shachaf: no argument there
15:04:41 <shachaf> r00723r0: I suspect all those digits in your name are hindering you.
15:04:48 <r00723r0> So again all values have types, right?
15:04:54 <flebron> If you want a more formal approach, the functions you write do not take types, because there is no Type object in Hask, the category of Haskell types.
15:04:56 <r00723r0> shachaf: no, just people's perception of me.
15:05:07 <Twisol> r00723r0: For what you mean by your question, yes. Values have types.
15:05:09 <hiptobecubic> values definitely have types.
15:05:16 <r00723r0> hiptobecubic: thanks.
15:05:19 <flebron> (That's "rootzero" in 1337)
15:05:31 <r00723r0> So types are why Haskell is compiled.
15:05:37 <shachaf> 15:02 <r00723r0> Values always have a type, right?
15:05:39 <shachaf> 15:02 <mauke> r00723r0: no, expressions do
15:05:41 <hiptobecubic> that's a strange way to say it
15:05:43 <flebron> You can have types without compilation.
15:05:49 <flebron> You can also have compilation without types.
15:06:06 <Twisol> as an example, ghci (the haskell interpreter) lets you play with Haskell without straight-up compiling it
15:06:08 <lightquake> for example, writing a brainfuck compiler is trivial, but it's an untyped language
15:06:10 <r00723r0> flebron: I doubt that second one.
15:06:11 <flebron> Haskell can also be interpreted, not compiled. What it can not be, is typeless :p
15:06:14 <hiptobecubic> shachaf, are there values which do not have a type?
15:06:17 <flebron> r00723r0, how so?
15:06:34 <Twisol> r00723r0: Assembly is relatively untyped.
15:06:40 <ion> r00723r0: Please give a concrete example of what you’d like to achieve. Whatever “change a function’s return type” means, that wouldn’t be the purpose of your code in itself, you would do it to achieve some goal. What would that be?
15:06:41 <flebron> Assembly has higher order functions :)
15:06:52 <mauke> "values have types" is dynamic typing
15:06:59 <r00723r0> Twisol: what types does Assembly have anyway?
15:07:14 <flebron> Word, doubleword, etc..
15:07:21 <flebron> (It depends on the ISA)
15:07:23 <Twisol> r00723r0: I'm no assembly connoisseur, but pretty much just numbers.
15:07:25 <hiptobecubic> mauke,  'a' is a value with a type, no?
15:07:33 <mauke> hiptobecubic: no, 'a' is an expression with a type
15:07:35 <r00723r0> Twisol: anyway, good point.
15:07:45 <hiptobecubic> mauke, does haskell have values?
15:07:50 <mauke> yes
15:07:59 <flebron> r00723r0, anyway, what I told you is a formal way of seeing what you are constrained to compute in.
15:08:03 <hiptobecubic> and those values have types or not?
15:08:24 <r00723r0> Types are like .h files, no?
15:08:25 <mauke> hiptobecubic: I don't think they do
15:08:30 <Twisol> hiptobecubic: I think you could say values don't have types until they're part of an expression.
15:08:45 <shachaf> A value is not part of an expression.
15:08:45 <hiptobecubic> well i'm not sure what we're calling a value
15:08:45 <Twisol> hiptobecubic: You could have a concrete value, but the expression it's in might only require a typeclass
15:08:49 <flebron> There is a category (you can think of it as a set if you want) called Hask. It has objects in it. These are the types in Haskell. There are some arrows between types. Those are Haskell functions. This is why you write f: X -> Y. Your function will take elements of type X, and give elements of type Y.
15:09:06 <shachaf> This channel is being very unhelpful.
15:09:08 <flebron> For an f to compute with types, there would need to be a Type object in Haskell, for you to say f: Type -> Type for instance.
15:09:10 <Twisol> shachaf: then what is Just 42? :/
15:09:20 <`nand`> flebron: I don't think category theory is at all relevant here
15:09:30 <simpson> shachaf: Well, AFAIK nobody in here can read minds.
15:09:38 <r00723r0> You guys are great, actually.
15:09:39 <flebron> Doesn't really need to be category theory, he can just think of it as sets.
15:09:41 <r00723r0> Thank you so far.
15:09:44 <hiptobecubic> r00723r0, isn't it fun?
15:10:02 <r00723r0> hiptobecubic: yes. :)
15:10:14 <mauke> Twisol: a string
15:10:17 <hiptobecubic> mauke, can you give an example of a value in Haskell? Or is it not possible because you aren't evaluating it
15:10:20 <Twisol> mauke: How is that a string?
15:10:39 <flebron> What can happen is that a value is not of a defined type (that is, it's not necessarily of a type), but of a typeclass. For instance...
15:10:43 <mauke> Twisol: it's made of characters
15:10:43 <flebron> > :t 5
15:10:44 <lambdabot>   <hint>:1:1: parse error on input `:'
15:10:49 <flebron> :t 5
15:10:50 <lambdabot> Num a => a
15:10:53 <Twisol> mauke: Because I typed it into IRC? That's really pedantic. :|
15:11:00 <mauke> Twisol: you started it
15:11:10 <flebron> What lambdabot is saying here, is that "For every type a you want, that meets the interface Num, 5 can be of that type."
15:11:13 <`nand`> my personal opinion: expressions express values; values have types
15:11:41 <flebron> (In other words, "Num a", which means "a meets the interface Num", implies (=>) that the type of 5 is a.)
15:11:43 <shachaf> What is the value of the expression "x + 5"?
15:11:46 <mauke> hiptobecubic: it's not possible because values have no visible representation
15:11:47 <Twisol> mauke I'm genuinely asking.
15:11:55 <mauke> Twisol: but WHAT are you asking?
15:12:03 <hiptobecubic> i'm not really clear on the difference between an expression and a value in a language with higher order everything and currying by default
15:12:11 <flebron> That is why you can say 5/2, and 5 can also be an Integer, where 5/2 makes no sense.
15:12:14 <Twisol> mauke: We just "established" that values aren't part of expressions
15:12:21 <Twisol> mauke: My question is, what is Just 42 in that context?
15:12:30 <mauke> Twisol: that's not a question. it makes no sense
15:12:32 <sclv> anyone got experience with llvm bindings around here?
15:12:39 <mauke> Twisol: what do you mean by "Just 42"?
15:12:54 <sclv> i'd like to be able to take pointers to blocks/labels
15:12:55 <Twisol> mauke: The Haskell type constructor Just applied to an integer 42.
15:12:57 <sclv> and stick them in a structure
15:13:04 <sclv> so i can pop them out and jump back to them
15:13:06 <mauke> Twisol: the value or the expression?
15:13:09 <Twisol> mauke: It appears to be an expression to me. With a value as part of it.
15:13:12 <sclv> what's the proper way to do this in llvm?
15:13:21 <hiptobecubic> well surely 42 is also an expression
15:13:30 <flebron> If you wanted to "change a function's return type", Haskell will allow you to do something a bit cooler. If it makes sense for your function to return a type foo, you can say f x :: Foo, and "cast it" to Foo. This will only happen if indeed f x can be of type Foo. But, perhaps, it could also be of type Bar, and you could also "cast" it as f x :: Bar. Whatever type you need it to be, if it makes sense for it to be that type, you can
15:13:30 <flebron>  "cast" it to that type.
15:13:37 <Twisol> hiptobecubic: with a single item in it, surely? Doesn't it end somewhere?
15:13:48 <hiptobecubic> arbitrarily?
15:13:52 <hiptobecubic> why would it?
15:13:59 <shachaf> flebron: I'd recommend not trying to read their mind.
15:14:02 <flebron> So if you have f x = x + 5, you can say something like f 6 :: Float, f 6 :: Integer, etc...
15:14:17 <Twisol> hiptobecubic: because an expression tree of infinite height makes no sense...
15:14:17 <shachaf> There are more fundamental things that you need to understand before understanding type classes.
15:14:25 <hiptobecubic> are values only in nf then?
15:14:44 <r00723r0> shachaf: I'm listening.
15:14:45 <flebron> I tend to give more info than wanted, yeah. Sorry about that xP
15:14:49 <mauke> hiptobecubic: expressions are the things you write in your editor. values are the things your program deals with at runtime
15:15:04 <shachaf> r00723r0: You'd be best off listening to mauke, who's probably the only person not saying nonsense in here.
15:15:13 <flebron> *snif*
15:15:16 <shachaf> Anyway I'm not sure what you're listening for.
15:15:17 <Twisol> mauke: that's the kind of answer I was expecting. Thanks.
15:15:19 <mauke> >implying I'm not spouting nonsense
15:15:36 <shachaf> mauke: Funny, I write strings in my editor.
15:15:51 <mauke> yes, there's another level of indirection in there :-)
15:15:53 <hiptobecubic> mauke, strings are what i write in the editor. Expressions *must* be part of actual Haskell, no? That aren't known until evaluation?
15:15:58 <mauke> hiptobecubic: no
15:16:06 <mauke> there is no actual Haskell
15:16:11 <Twisol> I think we're getting vaguely into philosophy now
15:16:18 <hiptobecubic> mauke, there clearly is
15:16:20 <Twisol> nevermind that vaguely
15:16:23 <mauke> Twisol: yes, it's called "programming"
15:16:24 <r00723r0> Twisol: lol'd hard.
15:16:50 <mauke> you write strings, which the parser turns into expressions
15:16:53 <simpson> The Haskell that can be typed is not the true Haskell.
15:16:54 <flebron> One could ask if, during the course of execution of a Haskell program, structures representing "x + 6" exist in memory.
15:16:59 <simpson> (Pun intended.)
15:17:17 <hiptobecubic> mauke, which is part of evaluation
15:17:18 <r00723r0> mauke: are you saying names are strings?
15:17:21 <flebron> In that case, I would call those things "expression representations".
15:17:26 <mauke> hiptobecubic: no, parsing is not part of evaluation
15:17:33 <mauke> r00723r0: what's a name?
15:17:46 <r00723r0> A thing you use to refer to a value.
15:17:48 <hiptobecubic> mauke, which program are you running to parse this that is not evaluating anything?
15:17:52 <Twisol> r00723r0: I highly recommend reading Learn You a Haskell for Great Good. It'll be very enlightening.
15:18:00 <r00723r0> Twisol: I am reading it right now, thank you.
15:18:01 <mauke> hiptobecubic: a compiler
15:18:04 <flebron> hiptobecubic, parsing doesn't need to evaluate...
15:18:14 <flebron> ghc Foo.hs -o Foo does not evaluate any expression, I think.
15:18:15 <mauke> hiptobecubic: also, why are you talking about programs? I parse Haskell brainically
15:18:23 <flebron> (Unless you're using crazy stuff like Template Haskell...)
15:18:44 <hiptobecubic> mauke, i thought there was no Haskell?
15:18:59 <mauke> no, I just said there is no actual Haskell
15:19:09 <hiptobecubic> what are you parsing then?
15:19:14 <hiptobecubic> virtual haskell?
15:19:23 <mauke> no, Haskell
15:19:32 <flebron> > let haskell = "banana" in haskell
15:19:34 <lambdabot>   "banana"
15:19:38 <hiptobecubic> do you know what actual means?
15:19:47 <mauke> no
15:20:04 <hiptobecubic> then how do you know there's no actual Haskell?
15:20:18 <sclv> ah, thre's an indirectbr in llvm but we don't bind to it :-(
15:20:21 <flebron> Is this hypothesis falsifiable?
15:20:48 <hiptobecubic> Vacuously, yes.
15:20:50 <mauke> hiptobecubic: because it means nothing
15:21:11 <Nisstyre> meaningless things can't be falsifiable :P
15:21:21 <flebron> Anyway, r00723r0, is your question answered satisfactorily, among all the garbage?
15:21:34 <mauke> >implying there was an answerable question
15:21:46 <flebron> Sure, it might not have been stated.
15:21:48 <hiptobecubic> Why does "actual" Haskell mean nothing? And how would you know anyway, given that you don't know what "actual" means?
15:22:00 <Twisol> Yum, popcorn.
15:22:06 <r00723r0> flebron: I am mainly just asking questions to strengthen my understanding.
15:22:09 <Nisstyre> mauke: I think a lot of programmers would benefit from reading a bit of philosophy of science (specifically A.J. Ayer's "Language, Truth, and Logic")
15:22:16 <Nisstyre> it would definitely make better questions
15:22:22 <hiptobecubic> I am genuinely confused about what the hell is going on
15:22:27 <flebron> r00723r0, do 3 sets of 10 reps of Learn You A Haskell.
15:22:34 <Twisol> hiptobecubic: Sit back and have some popcorn.
15:22:36 <flebron> You can go to failure in the last set.
15:22:44 <hiptobecubic> Twisol, actual popcorn?
15:22:56 <Twisol> hiptobecubic: *facepalm*
15:23:16 <r00723r0> Where's the interesting stuff, like monads?
15:23:22 <flebron> > "Ceci n'est pas une Haskell"
15:23:23 <lambdabot>   "Ceci n'est pas une Haskell"
15:23:26 <Twisol> r00723r0: It's later on in the bool.
15:23:29 <mauke> hiptobecubic: actually, the proper answer to "do you know what actual means?" is "I don't know"
15:23:30 <Twisol> *book
15:23:40 <mauke> r00723r0: monads aren't very interesting
15:23:50 <mauke> Functors are where it's at
15:23:58 <shachaf> Profuncotrs are where it's at.
15:23:59 <flebron> Natural transformations are where it's at.
15:24:02 <shachaf> Profunctors, rather.
15:24:03 <hiptobecubic> mauke, depends on what "know" means.
15:24:15 <flebron> hiptobecubic, it depends on what "means" means.
15:24:18 <hiptobecubic> but this is getting a bit clinton-ish for me
15:24:27 <Nisstyre> /facepalm
15:24:27 * mauke transforms into a profunctor, naturally
15:24:34 <pantsman> science is interesting
15:24:41 <Nisstyre> It depends upon what meaning of "is" is
15:24:43 <flebron> I wish this were science.
15:24:45 <shachaf> mauke: I heard invariant functors are where it's at.
15:24:49 <Nisstyre> that is the actual Clinton quotation
15:24:50 * hiptobecubic is just an amateur functor :(
15:24:57 <shachaf> class Invariant f where inmap :: (a -> b) -> (b -> a) -> f a -> f b
15:25:22 <mauke> oh, nice
15:25:43 <aristid> shachaf: hey i thought profunctors are the one true functor these days!
15:25:57 <flebron> inmap = const fmap
15:26:10 <flebron> Do I know Haskell now mom?
15:26:22 <mauke> flebron: do you know how to fix fmap return?
15:26:25 <shachaf> aristid: They're pretty pro. But infunctors are in.
15:26:25 <r00723r0> Man, Haskell is beautiful.
15:26:26 <mauke> er
15:26:28 <mauke> fmap fix return
15:26:45 <Nisstyre> s/Haskell/Scheme/
15:26:55 <Nisstyre> >.>
15:26:58 <Twisol> r00723r0: Absolutely. You don't even have to use it to enjoy the benefits. ;)
15:27:04 <mauke> s/beautiful/)))))))))/
15:27:21 <hiptobecubic> Scheme is a lot of nice things, but beautiful isn't one that i'd pick
15:27:29 <hiptobecubic> in fact, it's hideous
15:27:34 <Nisstyre> hiptobecubic: you don't like looking at parse trees?!?
15:27:46 <mauke> trees are invisible
15:27:50 <hiptobecubic> Hopelessly overpowered
15:28:09 <flebron> > fix error
15:28:11 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
15:28:13 <r00723r0> Whoa, types have constructors?
15:28:23 <shachaf> whoa, dude
15:28:25 <flebron> Well yes, you need to construct your types.
15:28:45 <flebron> (Or construct your instances, damned semantics.)
15:28:55 <Twisol> r00723r0: This is going to be very lowbrow, to the Haskell pros here, but think of them like C++ template parameters or Java generics.
15:29:14 <r00723r0> Twisol: Python metaclasses?
15:29:19 <Twisol> Not a Python guy, sorry.
15:29:20 <shachaf> Twisol: What does that have to do with constructors?
15:29:24 <flebron> I like to think of them as labels.
15:29:40 <mauke> r00723r0: "constructor" does not mean that
15:29:42 <Twisol> shachaf: Isn't, for example, Maybe a type constructor?
15:29:46 <flebron> data Nat = Zero | Successor Nat.
15:29:46 <simpson> r00723r0: No, just normal Python initializers.
15:29:48 <shachaf> Twisol: Also, C++ template parameters are very different from anything Haskell has.
15:29:56 <flebron> Maybe constructs types, not values of a type.
15:30:13 <Nisstyre> r00723r0: type constructors are used to create new types
15:30:20 <Twisol> shachaf: I mean normal usage, like list<string>
15:30:23 <Nisstyre> data constructors are used to create instances of types
15:30:30 <hiptobecubic> all scheme programs just end up as a furiously shredded pile of newspaper and paste, folding in on itself and scrambling its own brains
15:30:40 <r00723r0> Nisstyre: is all there is types and data?
15:30:47 <Nisstyre> r00723r0: no
15:30:48 <hiptobecubic> it's a wonder anyone is able to write anything in it at all
15:30:51 <Twisol> well, we have kinds as well.
15:31:01 <flebron> Define "data".
15:31:03 <Nisstyre> r00723r0: wait, I misunderstood your question
15:31:05 <r00723r0> You have types and kinds!? What kind of language is this?
15:31:13 <hiptobecubic> a great one
15:31:21 <mauke> r00723r0: a great language! (of sorts)
15:31:35 <hiptobecubic> kinds are like types, but instead they are kinds
15:31:36 <Nisstyre> r00723r0: are you asking if only types and data are what exists in Haskell?
15:31:39 <pantsman> haha, metaclasses in Python, I'd forgotten about those
15:31:45 <r00723r0> Nisstyre: yes.
15:31:50 <shachaf> Twisol: Can you write data T a = A a | B (T (a,a)) with C++ templates?
15:32:05 <flebron> Functions take values of a type, and produce values of another type.
15:32:06 <Twisol> shachaf: This is what I meant by a lowbrow comparison.
15:32:18 <flebron> So one could ask if there's something that _takes a type_, and returns _another type_. And that's a type constructor.
15:32:41 <Nisstyre> -> is a type constructor r00723r0
15:32:52 <Nisstyre> an infix one
15:33:06 <shachaf> whoa, dude
15:33:15 <mauke> template<typename a> union T { a *A; T< pair<a, a> > *B; };
15:33:27 <Twisol> I was waiting for someone to do that.
15:33:43 <flebron> That's awesHom.
15:33:52 <cmccann> forget C++. "generics" like in Java and C# are the same idea as type constructors in Haskell, but more limited.
15:34:07 <Twisol> cmccann: C# is a much better example than C++, thanks
15:35:14 <cmccann> pretty sure generics as in C# and Java are descended (directly or indirectly) from ML-style parametric polymorphism, so they really are the same thing
15:35:33 <cmccann> not just convergent evolution
15:35:36 <c_wraith> Philip Wadler was directly involved with Java's generic system
15:35:40 <cmccann> right
15:35:56 <c_wraith> So certainly not an accident
15:36:06 <cmccann> and the C# team has a buncha people who like Haskell and they were certainly influenced by Java
15:36:28 <hiptobecubic> C# just seems like Java2
15:36:35 <Peaker> you can say, in C++,  template <class T> class Foo { T x; void show() { return x.show(); } };
15:36:46 <cmccann> C# is what Java would be if they actually tried to improve it
15:36:54 <hiptobecubic> right
15:36:59 <Peaker> but you can't really say that in Java (and afaik not in C# either)
15:37:00 <cmccann> instead of letting it stagnate because java programmers are afraid of progress, abstraction, and new ideas
15:37:18 <hiptobecubic> i'm not sure that's it
15:37:35 <cmccann> yeah, C++ templates are very much not the same thing as generics in C# or Java
15:37:35 <hiptobecubic> My experience has been one of overwhelming apathy
15:37:41 <Hafydd> Afraid of lambda abstraction.
15:37:45 <Peaker> cmccann, I thought C# started from a Java-like mess and then got Haskellers to try and improve it
15:37:45 <Twisol> Isn't Linq inspired heavily by functional methods?
15:37:57 <hiptobecubic> Twisol, yes. it's a monad
15:38:02 <mauke> list nqomprehensions
15:38:03 <cmccann> linq is inspired directly from the list monad in Haskell, yes
15:38:13 <Twisol> Very cool.
15:38:19 <cmccann> and then GHC added an extension for fancier list comprehensions that was inspired by linq!
15:38:29 <donri> wait, java programmers are afraid of abstraction?
15:38:30 <mauke> which no one used
15:38:30 <Hafydd> Hahah.
15:38:38 <cmccann> mauke, but it's the thought that counts
15:38:45 <Twisol> What is this extension called?
15:38:49 <hiptobecubic> the people at work that do java all day aren't afraid of abstraction, they just don't give two shits
15:38:54 <c_wraith> I've used MonadComprehensions in toy code!
15:38:59 <r00723r0> Java's concept of abstraction is ridiculous.
15:39:00 <c_wraith> ...  But not most of the features.
15:39:01 <startling> cmccann: MonadComprehensions?
15:39:05 <mauke> c_wraith: not that
15:39:11 <hiptobecubic> it's not about producing more and better programs, it's about producing for 38 hours a week
15:39:27 <donri> TransformListsComps or something like that
15:39:31 <cmccann> no, not monad comprehensions
15:39:33 <cmccann> http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#generalised-list-comprehensions
15:39:57 <hiptobecubic> The only people I know that use Java for fun are still in university and literally don't know anything else very well.
15:40:02 <donri> too many s's
15:40:13 <startling> wut
15:40:17 <c_wraith> ah.  MonadComprehensions does enable generalized list comprehensions
15:40:18 <hiptobecubic> Everyone else treats like the cash cow that it is and nothing more.
15:40:24 <hiptobecubic> treats*
15:40:33 <cmccann> linq is pretty neat but the marginal benefit of what that extension does in haskell is pretty tiny compared to the benefits of linq in C#
15:40:35 <hiptobecubic> it*, rather.
15:40:39 <Twisol> I have to use Java because I'm still in college. :(
15:40:47 <cmccann> though I end up using lambdas and methods instead of linq syntax a lot anyway...
15:40:53 <donri> c_wraith: oh? i thought it was just compatible with, if also enabled
15:41:19 <c_wraith> from the docs: "All these features are enabled by default if the MonadComprehensions extension is enabled"
15:41:37 <c_wraith> Including Parallel list comprehensions and transform list comprehensions
15:41:42 <donri> aha
15:41:43 <cmccann> Twisol, look on the bright side, at least it's not PHP
15:41:45 <cmccann> or, uh
15:41:49 <cmccann> COBOL
15:41:50 <Twisol> cmccann: I have to use PHP at work.
15:41:53 <cmccann> or
15:41:57 <startling> ruby
15:41:59 <cmccann> ok I can't think of anything else that bad
15:42:24 <Twisol> I'm exposed to IDL occasionally at work.
15:42:41 <Twisol> So far, IDL is my least favorite language.
15:42:47 <c_wraith> Ruby as a language probably wouldn't be too bad, except that the most commonly-used framework written in it is a case of horrible software engineering.
15:42:47 <donri> the way i understood TransformListComp is that it enables some optimizations over the naive desugaring
15:42:50 <cmccann> blarrrgh don't talk to me about IDL
15:42:55 <donri> so it's not merely sugar
15:43:04 <Twisol> startling: Ruby's awesome. :(
15:43:08 <cmccann> assuming you mean the bizarre interface specification language thing
15:43:13 <Twisol> cmccann: http://en.wikipedia.org/wiki/IDL_(programming_language)
15:43:23 <Twisol> cmccann: It's different.
15:43:28 <cmccann> oh, ok.
15:43:39 <Twisol> It's based on Fortran, apparently
15:43:46 <cmccann> haha, oh boy.
15:43:53 <cmccann> at least fortran is good for what it does.
15:43:56 <startling> Twisol, at least it isn't dcpu16 assembly
15:44:09 <Twisol> startling: Yeah, but dcpu16 assembly is fun.
15:44:20 <startling> hehe
15:44:23 <hiptobecubic> fortran isn't terrible, as long you don't treat it like a general purpose language
15:44:45 <cmccann> anyway, ruby is a weird mishmash of ideas from perl, smalltalk, and lisp
15:44:52 <cmccann> there's a lot of potential there
15:45:01 <cmccann> there's also a lot of ways that other people can do horrible things that you have to work around
15:45:09 <epta> If x ∷ IO (Maybe α), f ∷ α → Maybe β, how can I get IO B?
15:45:19 <epta> If x ∷ IO (Maybe α), f ∷ α → Maybe β, how can I get IO β?*
15:45:44 <shachaf> @ty \f -> fmap (>>= f)
15:45:46 <lambdabot> (Monad m, Functor f) => (a -> m b) -> f (m a) -> f (m b)
15:45:50 <Twisol> frankly, as long as a language supports a couple different things, I'm happy. Higher order functions, and multiple return values.
15:45:57 <cmccann> epta, you'll need a default value or something
15:46:02 <cmccann> otherwise what will you do with Nothing?
15:46:16 <shachaf> Oh, I misread.
15:46:20 <startling> Twisol: ruby supports higher-order functions? :S
15:46:24 <shachaf> cmccann: ⊥ is a great default.
15:46:26 <cmccann> unless you want to keep running "x" until you get the right value or something
15:46:32 <hiptobecubic> startling, ruby is surprisingly functional
15:46:38 <Twisol> starting: Absolutely
15:46:42 <startling> hiptobecubic: blockical
15:46:43 <shachaf> cmccann: That would work if α ~ β
15:46:43 <Twisol> *startling
15:46:46 <hiptobecubic> startling, despite being super-oop
15:46:58 <Nisstyre> startling: they have like 3 different ways of passing around code as data
15:47:17 <cmccann> shachaf, eh?
15:47:19 <startling> Nisstyre, I know.
15:47:21 <hiptobecubic> startling, what would you prefer?
15:47:38 <startling> I don't actually mind ruby, I was just teasing Twisol.
15:47:47 <Twisol> ;)
15:48:23 <shachaf> cmccann: Oh, running "x"
15:48:26 * hackagebot iptadmin 1.3.3 - web-interface for iptables  http://hackage.haskell.org/package/iptadmin-1.3.3 (EvgenyTarasov)
15:48:26 <shachaf> cmccann: Never mind.
15:48:26 <startling> but non-first-class functions ("methods") is pretty weird.
15:48:32 <DrChaos> can I learn how to program if my first programming language is Haskell?
15:48:39 <startling> DrChaos: definitely.
15:48:40 <Twisol> can you? yes.
15:48:41 <Nisstyre> DrChaos: yes
15:48:48 <flebron> It's what we teach in uni, so yes.
15:48:52 <cmccann> if you have a first programming language, you've learned how to program by definition :P
15:49:00 <Nisstyre> DrChaos: I know of professors who teach it to people in their first semester
15:49:11 <Nisstyre> s/people/students/
15:49:15 <flebron> cmccann, that's a nice way of saying Haskell. "Programming by definitions".
15:49:32 <Nisstyre> obviously you can't teach them a lot of the language (type class related stuff)
15:49:38 <Twisol> startling: You can use obj.method(:methodname) to get a callable item loose from its bound object
15:49:38 <Nisstyre> but you can use it to teach really basic stuff
15:49:43 <chirpsalot> Nisstyre: really?  How does that go?  I am curious about such a thing.
15:49:51 <Nisstyre> chirpsalot: it goes very well apparently
15:49:52 <flebron> Right, we don't even use higher order functions or typeclasses, but they learn just fine. First semester.
15:49:56 <cmccann> you can even teach Haskell to kids using gloss :D
15:50:02 <DrChaos> Nisstyre -> where do I get beginning exercises for learning programming
15:50:17 <Nisstyre> DrChaos: I think LYAH is targeted at non-programmers
15:50:35 <Nisstyre> DrChaos: but uh, for learning programming from scratch I like http://htpd.org
15:50:36 * shachaf wonders why DrChaos addresses people with arrows.
15:50:39 <cmccann> seriously though, reading http://cdsmith.wordpress.com/ about what he did with those kids is not a bad idea for anyone new to Haskell
15:50:46 <mauke> shachaf: to kill them
15:50:49 <DrChaos> shachaf -> I like how they look
15:50:51 <chirpsalot> Nisstyre: awesome!  That's what I was hoping for :).  I come from a C background (like a lot of people, I suppose)...  I thought Haskell would be interesting for a first language.
15:50:56 <Twisol> shachaf: the message is dependent on the person it's adressed to? :D
15:51:19 <flebron> He's already doing Haskell.
15:51:36 <DrChaos> shachaf -> I'd rather make my own UTF-8 character and include a custom font using that character and address people with error message dialogs
15:52:28 <mauke> DrChaos � like this?
15:52:38 <DrChaos> mauke -> yes
15:52:47 <mauke> don't make me zalgo
15:53:02 <Nisstyre> DrChaos: why not use :: ?
15:53:22 <Nisstyre> I think there is actually a character for that
15:53:33 <mauke> ∷
15:53:40 <Nisstyre> indeed
15:54:38 <flebron> {-# LANGUAGE UnicodeIRCSyntax #-}. All better.
15:54:52 <cmccann> ⦃ shachaf ⦄ ↦ how about if I address people like this?
15:55:44 <mauke> `c̀mccanń´ how about this?
15:55:55 <cmccann> stylish.
15:56:01 <Twisol> and today was the day that #haskell went loopy
15:56:11 <cmccann> nobody's talking in fraktur yet
15:56:15 <cmccann> so we're still ok
15:57:26 <DrChaos> cmccann ∷ how about this?
15:57:43 <mauke> >𝔦𝔪𝔭𝔩𝔶𝔦𝔫𝔤
15:57:49 <cmccann> haha
15:58:06 <ion> 𝔉𝔯𝔞𝔨𝔱𝔲𝔯, 𝔶𝔬𝔲 𝔰𝔞𝔶? https://gist.github.com/3909452
15:58:22 <flebron> D:D:D:D:
15:58:26 <flebron> LESS THAN IDEAL FONT
15:58:34 <Twisol> um, my IRC client barfed all over that.
15:58:39 <cmccann> hahahaha
15:58:39 <ion> 𝕎𝕙𝕒𝕥 𝕚𝕤 𝕨𝕣𝕠𝕟𝕘 𝕨𝕚𝕥𝕙 𝕕𝕠𝕦𝕓𝕝𝕖-𝕤𝕥𝕣𝕦𝕔𝕜?
15:58:45 <Twisol> the hyperlink is offset to the left. O_o
15:59:45 <flebron> OS X sees it just fine. The analog transmission to my eyes, however...
16:00:07 <Nisstyre> ion: it looks like a 3D film without wearing glasses
16:00:07 <mauke> Hᴏᴡ ᴀʙᴏᴜᴛ ᴛʜɪs?
16:00:31 <`nand`> I can read most of ion's line, the ‘w’ seems to be missing
16:00:35 <`nand`> maybe it's too wide for my terminal to like?
16:00:40 * `nand` wonders what happens if he allows full width characters
16:00:42 <ion> ¿sᴉɥʇ ɹo
16:00:42 <cmccann> for anyone who can't see the text: http://i.imgur.com/FR1ZP.png
16:00:47 <DrChaos> flebron ∷ what font is OS X using?
16:01:02 <mauke> ℋℯℓℓℴ
16:01:04 <flebron> I'd have to check, but it's some monospace thing.
16:01:06 <startling> mauke: heh
16:01:15 <flebron> Lucida Grande
16:01:18 <startling> there are unicode codepoints for cursive?
16:01:25 <Nisstyre> I am a fan of Andale Mono
16:01:38 <hpc> startling: for the natural/real sets, etc
16:01:41 <mauke> startling: and bold
16:01:51 <hpc> er, those aren't cursive...
16:01:52 <shachaf> DrChaos: You should really just use "nick: message"
16:01:53 <startling> hpc: oh, makes sense
16:01:59 <mauke> ℕ⁰
16:02:02 <startling> well, almost.
16:02:10 <Nisstyre> shachaf: I convinced  him to switch from -> to ::
16:02:14 <Nisstyre> I think that's an improvement
16:02:16 <startling> hpc: you get points for convinving me, at least.
16:02:20 <shachaf> Great. Now improve all the way to ": "
16:02:27 <Nisstyre> yep
16:02:32 <`nand`> I think ‘$’ would be hilarious, personally; but annoying
16:02:54 <mauke> [shachaf|I think this is nice|]
16:02:56 <shachaf> The goal is not hilarity. This is protocol-level.
16:03:19 <flebron> We should use Huffman coding for mass protocol gains.
16:03:31 <mauke> do you even lift?
16:04:04 <Nisstyre> do you even liftM?
16:04:05 <`nand`> nope, added USE="wcwidth" <- which claims to add wide char width support; but fraktur's ‘w’ is still missing
16:05:27 <DrChaos> BullShark ∷ I thought you never wanted to learn Haskell
16:13:40 <`nand`> I sometimes wish foo $ bar + bat :: Baz  would parse as foo $ (bar + bat :: Baz)
16:14:10 <BullShark> DrChaos ∷ http://www.youtube.com/watch?v=TkLkB_Zo4Ig
16:14:10 <BullShark> DrChaos ∷ i dont
16:14:10 <BullShark> DrChaos ∷ a lot of people learn haskell just so they can write their xmonad config
16:14:10 <BullShark> i believe xmonad is good but i dont want to learn it just so i can write my config
16:14:11 <BullShark> s/it/haskell/
16:14:37 <Clint> i know plenty of xmonad users who don't know haskell
16:14:58 <`nand`> I've managed to use software that does configuration in C without knowing C
16:15:13 <`nand`> (then again, it was all #defines)
16:15:35 <mauke> cc -Depress -Dalmatian
16:15:58 <hiptobecubic> BullShark, your entire config will come from examples in the documentation of the various features you want anyway. It's not like you're programming something new
16:32:25 <NougatRillettes> is there any haskell function that would make n -> \n
16:32:29 <NougatRillettes> r -> \r
16:32:35 <NougatRillettes> and so on ?
16:32:48 <NougatRillettes> (\n \r are special char, not \\n or \\r)
16:36:31 <Clint> NougatRillettes: what?
16:36:57 <NougatRillettes> if this function was called escape for example
16:37:15 <NougatRillettes> escape 'n' = '\n'
16:37:21 <NougatRillettes> escape 't' = '\t'
16:37:29 <NougatRillettes> escape 'k' = error
16:37:45 <NougatRillettes> as k is no special char
16:42:55 <randomclown> @pl \x -> map ($ x) list
16:42:55 <lambdabot> flip map list . flip id
16:53:48 <kennyd_> NougatRillettes no such function as far as I know
16:54:30 <simpson> NougatRillettes: Why do you want this?
16:54:40 <NougatRillettes> to parse them
16:54:52 <NougatRillettes> without hardcoding the case matching
16:54:54 <fragamus> whats the best code editor for haskell
16:55:01 <NougatRillettes> but I've coded the case
16:55:16 <NougatRillettes> fragamus: I recently switched to emacs + haskell-mode, a pleasure !
16:55:27 <fragamus> yay
17:10:40 <mauke> NougatRillettes: show/read, sort of
17:11:01 <NougatRillettes> well Ive found thing that could do it
17:11:12 <NougatRillettes> but nothing simplier than the case ... of
17:11:46 <mauke> > (init . tail . show) '\n'
17:11:47 <lambdabot>   "\\n"
17:15:59 <NougatRillettes> that's not what I'm looking for
17:16:32 <mauke> oh, you want unescape
17:17:10 <mauke> > (read . printf "'\\%c'") 'n' :: Char
17:17:12 <lambdabot>   '\n'
17:20:54 <gdeest_> Ok, is someone using this s... called Ubuntu, that does not seem to have any GHCi in its version of haskell-platform ?
17:20:59 <gdeest_> (Problem: need one.)
17:22:06 <mauke> nope, debian here
17:23:40 <NougatRillettes> thanks mauke
17:23:41 <gdeest_> Looks like it is supposed to be a ghc-ghci virtual (?) package on Precise:
17:23:42 <gdeest_> http://packages.ubuntu.com/fr/precise/ghc-ghci
17:23:51 <gdeest_> Completeloy unknown on my system...
17:24:20 <Clint> gdeest_: are you sure you don't have ghci?
17:24:38 <gdeest_> Oh ok, that's because I'm trying to install it on an old, headless ... PowerPC
17:25:02 <gdeest_> Hum, not sure that's it
17:25:03 <Clint> then you need an older version of ghc before it got all broken on powerpc
17:25:46 <gdeest_> Unfortunately, I'm sure there is no ghci on that system
17:25:56 <gdeest_> Well, I can't afford going back to GHC 6
17:26:34 <Clint> then you should get someone to fix linking on powerpc
17:26:34 <NougatRillettes> don't you have a VPS
17:26:52 <NougatRillettes> or any sshable machine
17:27:17 <gdeest_> Well, the thing is, I'm writing a program interfacing an USB device
17:27:29 <gdeest_> So, VPS are out
17:28:15 <gdeest_> And maintainers for PPC aren't legions, I fear :P
17:28:25 <Clint> yes, it's broken because no one cares
17:33:07 <gdeest_> I *should* be able to upgrade to the latest version of the OS, let's hope it does the trick
17:33:42 <gdeest_> (I will probably have to to modify a library to support Big-Endian words, too, but it looks like it should be pretty easy)
17:33:51 <gdeest_> (I should find others hobbies :P)
17:34:01 <Clint> no, no one has fixed ghci on powerpc since whenever you've installed
17:35:44 <gdeest_> How do you know ? (Not that I doubt it, but I'm a bit lost on Ubuntu's website)
17:36:11 <gdeest_> GHC has been upgraded, at least (7.4.1 -> 7.4.2)
17:37:10 <maky> how would one safely wrap/call a C function that modifies a global variable? in C it is has independent  value per thread, but what happens if I use it in haskell threads?
17:37:56 <Clint> gdeest_: http://hackage.haskell.org/trac/ghc/ticket/2972
17:38:13 <Fuuzetsu> @pl f x = do { y <- x; putStrLn y }
17:38:14 <lambdabot> (line 1, column 10):
17:38:14 <lambdabot> unexpected '{'
17:38:14 <lambdabot> expecting variable, "(", operator or end of input
17:38:59 <mauke> Fuuzetsu: @undo
17:39:29 <gdeest_> Clint: ok, so basically you think Ubuntu /disabled/ GHCi because of that issue ?
17:39:31 <Fuuzetsu> @undo
17:39:31 <lambdabot> ()
17:39:36 <gdeest_> That would make sense
17:39:41 <Fuuzetsu> How do I use it?
17:39:46 <Fuuzetsu> @help undo
17:39:46 <lambdabot> undo <expr>
17:39:46 <lambdabot> Translate do notation to Monad operators.
17:40:29 <Fuuzetsu> @undo do { y <- x; putStrLn y }
17:40:29 <lambdabot> x >>= \ y -> putStrLn y
17:40:38 <Clint> gdeest_: yes, you can use the ghc package out of debian experimental if you want ghci
17:40:43 <Fuuzetsu> heh, exactly what I got
17:41:05 <Fuuzetsu> @pl f x = x >>= \y -> z y
17:41:05 <lambdabot> f = (z =<<)
17:41:34 <Fuuzetsu> @pl f x = x >>= \y -> a $ b $ c y
17:41:34 <lambdabot> f = (a . b . c =<<)
17:41:37 <gdeest_> Looks like someone /did/ fix it 5 months ago
17:41:56 <Clint> yes, but not in ubuntu
17:42:08 <gdeest_> But there is hope ! ;)
17:42:14 <gdeest_> Thanks, btw
17:44:43 <shirt> maky: why do you think you need to specially wrap it?
17:45:26 <maky> shirt just thought I do. am I wrong?
17:46:09 <shirt> maky: if the C code is already thread safe, then what could go wrong?
17:46:19 <maky> I am not sure what happens if I use it concurrently, in haskell threads
17:46:33 <mauke> fun things
17:46:49 <mauke> I'd look very carefully at the documentation of forkOS
17:46:50 <maky> since one OS thread can run many haskell threads
17:46:57 <startling> maky: just make it an IO thing
17:47:16 <startling> or am I missing something?
17:47:27 <mauke> startling: yes, the whole threading thing
17:47:36 <startling> heh
17:47:40 <shirt> maky: when you use it in C, are you supposed to always call the function from the same thread? if so then you do indeed need to use forkOS
17:49:41 <maky> shirt: no, function is thread safe as global variable has per thread value. but again I am not sure what that means when using it with forkIO, as one OS thread can run many haskell threads
17:50:26 <charlieky> Hello! Is there a way to get GHC to tell me functions which may be exported by a module, but aren't actually used anywhere in my application? I've got old library functions lying around and want to prune the unused ones.
17:50:57 <sclv> don't know of a good way.
17:51:26 <sclv> you can add an explicit export list to your module, and just see what "unknown" errors you get elsewhere
17:51:32 <shirt> maky: if multiple haskell threads are running on a single OS thread, then all calls to your C function will happen sequentially
17:52:32 <Nisstyre> charlieky: do what sclv said and just remove imports until you get errors about unknown names
17:52:43 <Nisstyre> er, remove imported functions
17:53:26 <charlieky> Nisstyre: do people think there's a demand for this in general? i don't know how amenable the GHC internals are to whole program analysis though.
17:53:35 <startling> maky, can you make it take a pointer to whatever and keep your own global state?
17:53:39 <Nisstyre> charlieky: I have never needed this before
17:53:47 <Nisstyre> I usually know when I imported something I don't really need
17:53:52 <maky> shirt: sure, but isnt there a race condition if I try to acess the value of that global variable after a call to a C function?
17:54:22 <charlieky> Nisstyre: ah you see I always import all members of my own modules, is that bad practice?
17:54:41 <Nisstyre> charlieky: no, if you expect to need all of them
17:54:45 <maky> startling: no. it is errno like variable
17:55:03 <Nisstyre> charlieky: you might need to do qualified imports though
17:55:10 <startling> maky: ugh. :(
17:55:11 <Nisstyre> if they clash with stuff from other modules like Prelude
17:57:58 <shirt> maky: if it's like errno, then you DO need to use forkOS, otherwise, since a single haskell thread can at anytime spontaneously jump between OS threads
17:58:48 <shirt> main = call_c_function >> print_c_function_val
17:59:10 <shirt> the two calls happen on the same haskell thread, but it is actually possible for them to be called on 2 separate OS threads
18:00:46 <maky> so even without forkIO things could go wrong
18:01:39 <Nereid> no, the main thread is always bound
18:01:47 <Nereid> http://hackage.haskell.org/packages/archive/base/latest/doc/html/Control-Concurrent.html#boundthreads
18:01:50 <shirt> maky: i think that the haskell main thread is always guaranteed to be a single OS thread, so no problem there
18:03:26 <DrChaos[S]> Hello from Skippy
18:03:54 <maky> so I have to always use forkOS whenever want to call that function from a separate thread? I was hoping I could wrap it safely, so that it is usable eveywhere
18:05:27 <DrChaos[S]> what is new in ghc 7.4.2 versus 7.4.1?
18:05:30 <DrChaos[S]> anything major?
18:06:46 <lightquake> bugfixes
18:07:29 <Nereid> you can also read the release notes.
18:08:35 <DrChaos[S]> lol
18:08:48 <mauke> http://www.haskell.org/ghc/docs/7.4.2/html/users_guide/release-7-4-2.html
18:09:36 <DrChaos[S]> why doesn't fedora 18 have 7.4.2 if it says things like "buffer overflow fixed", "fixed arguments passed to clang" and "segfault fixed"
18:09:45 <shirt> maky: maybe you can use `runInBoundThread` http://hackage.haskell.org/packages/archive/base/latest/doc/html/Control-Concurrent.html#v:runInBoundThread
18:15:09 <tom39291> One argument against making Functor a super typeclass of Monad is that then implementors of monad need to implement fmap and bind, which usually (always?) amounts to duplication.
18:15:12 <tom39291> What language features would we need to be able to do something like "typeclass Applicative implements Functor { fmap = (<*>) . pure }" and then have all Applicatives automagically be Functors too? Presumably this has been considered.
18:15:40 <Nereid> there have been many proposals.
18:15:52 <tom39291> s/making Functor a super typeclass of Monad/making Functor a superclass of Applicative/
18:15:57 <maky> shirt: thanks
18:15:58 <mauke> well, the duplication required is a fixed 'instance Functor M where fmap = liftM' for every type M
18:16:09 <mauke> ok, liftA for Applicative
18:16:40 <mauke> this could be shortened to 'instance Functor M' with the latest ghc extensions
18:17:07 <Nereid> it can?
18:17:25 <latro`a> of course the usual UndecidableInstances problem is that without changing how head matching works, you can't make custom instances of the superclasses, yes?
18:18:12 <latro`a> that is, if you define a Monad instance for M, you now can't handwrite a Functor instance for M without adding some functionality to check for "specificity"
18:18:23 <mauke> {-# LANGUAGE DefaultSignatures #-}
18:18:36 <latro`a> and sometimes you might want to (as I recall there's significant efficiency differences in certain cases)
18:18:49 <latro`a> (also differences in strictness)
18:19:00 <Nereid> mauke: oh sure, but the class definition needs to have that.
18:19:16 <mauke> class Functor f where { fmap :: (a -> b) -> f a -> f b; default fmap :: (Applicative f) => (a -> b) -> f a -> f b; fmap = liftA }
18:20:24 <latro`a> can that "stack", though? for example can you make a default Applicative instance from a Monad instance and then have the default Functor instance come from the Applicative instance?
18:20:32 <latro`a> (I'm new to DefaultSignatures, sorry)
18:20:48 <`nand`> ^ I was about to ask the same
18:21:24 <startling> wow, neat.
18:21:50 <mauke> latro`a: I've never used them :-)
18:22:39 <mauke> you can definitely do: instance Functor M where { fmap = liftA }; instance Applicative M where { pure = return; (<*>) = ap }; instance Monad M where { return = ...; (>>=) = ... }
18:22:46 <latro`a> well, I mean can you do what you wrote there, then the obvious thing with Applicative (class Applicative f where ... default (<*>) ... (<*>) = ap
18:22:49 <mauke> no duplication, just lots of boilerplate
18:22:50 <latro`a> and then do instance Monad ...
18:23:08 <latro`a> and get Applicative and Functor without writing the instances
18:23:10 <mauke> so I'd expect it to work the same way with DefaultSignatures
18:23:31 <latro`a> I'm just not sure how DefaultSignatures actually works
18:23:48 <mauke> http://www.haskell.org/ghc/docs/7.6.1/html/users_guide/type-class-extensions.html#class-default-signatures
18:23:48 <latro`a> for example if it's just a single-pass macro (a naive thing), then you can't "stack" it like I described
18:23:51 <latro`a> I imagine it's cleverer than that
18:24:11 <latro`a> I am looking at that now, and it doesn't mention this stacking idea
18:24:23 <mauke> try it?
18:25:49 <`nand`> what I'd be interested about is eg. default fmap :: Applicative f => (a -> b) -> f a -> f b; default fmap :: Profunctor f => (a -> b) -> f c a -> f c b
18:26:45 <latro`a> seems like there's no perfect way to do this anyway, because of the possibility that the inheritance graph is complicated
18:27:03 <sw2wolf> :t ap
18:27:04 <lambdabot> Monad m => m (a -> b) -> m a -> m b
18:27:16 <latro`a> obviously a linear hierarchy is straightforward enough, but what happens if a default is supplied from two places?
18:27:35 <mauke> probably a duplicate definition error
18:27:44 <mauke> there's only one default definition
18:27:52 <`nand`> okay, so what I asked isn't possible
18:28:12 <tom39291> Thanks guys, this is a lot for me to work through.
18:29:17 <`nand`> suppose a scenario where you have a class containing ‘foo’ and ‘bar’; with the minimal complete default being either one - that is, each is defaulted in terms of the others; For this class, is it also possible to add a separate default for ‘foo’ from a superclass?
18:29:20 <`nand`> err, subclass
18:29:23 <`nand`> w/e
18:29:42 <`nand`> or will that get you another duplicate definition error
18:39:56 <startling> is there a Default typeclass somewhere? I remember vague discussion of one
18:40:49 <plump_nexus> What is "-:" . Hoogle is no help.
18:41:10 <startling> plump_nexus: what do you have imported?
18:41:29 <plump_nexus> From lyah: "Suppose we make a function like this: x -: f = f x..."
18:41:31 <mauke> startling: yes
18:41:40 <Nereid> plump_nexus: it's just an operator
18:41:41 <mauke> plump_nexus: that's the name of the function
18:41:42 <flebron> That is a definition, plump_nexus.
18:41:52 <Nereid> > let x -: y = x + y in 3 -: 8
18:41:53 <flebron> x --:-- f would be another.
18:41:54 <lambdabot>   11
18:42:02 <flebron> It's the same as (-:) x f = f x
18:42:15 <plump_nexus> ah...
18:42:18 <plump_nexus> Got it
18:42:19 <flebron> When the name of the function is all symbols, if I'm not mistaken, you can just define it infix like that.
18:42:27 <startling> :t let x --:-- f = x + f in (--:--)
18:42:28 <lambdabot> parse error (possibly incorrect indentation)
18:42:34 <startling> flebron: ;)
18:42:38 <flebron> Well not -- :p
18:42:42 <Nereid> you can also define regular functions infix
18:42:44 <flebron> :-:-:
18:42:47 <Nereid> > let x `f` y = x + y in f 6 7
18:42:48 <lambdabot>   13
18:42:57 <flebron> Right but you need the special syntax of backticks
18:42:58 <Nereid> flebron: --:-- is fine.
18:43:01 <startling> :t let a (+) = 1 + 1
18:43:02 <flebron> Is it?
18:43:02 <lambdabot> <no location info>: not an expression: `let a (+) = 1 + 1'
18:43:12 <Nereid> -- starts a comment as long as the next character isn't a symbol
18:43:12 <flebron> Isn't it a comment?
18:43:14 <startling> :t let a (+) = 1 + 1 in a
18:43:15 <lambdabot> (Num a, Num a1) => (a -> a1 -> t) -> t
18:43:19 <flebron> Oh really! Did not know that, thanks.
18:43:33 <startling> Nereid: what's the parse error, then?
18:43:55 <Nereid> startling: you didn't finish your let
18:43:56 <flebron> It's lambdabot.
18:44:02 <flebron> ghci understands it just fine.
18:44:03 <startling> mauke: I give up, where is it?
18:44:21 <Nereid> oh
18:44:29 <mauke> http://hackage.haskell.org/packages/archive/data-default/0.5.0/doc/html/Data-Default.html
18:44:35 <Nereid> > let a (+) = 3 + 2 in a (*)
18:44:37 <flebron> >  --:-- f = x + f in 1 --:-- 2 :: Num a => a
18:44:37 <lambdabot>   6
18:44:37 <flebron> GOA> let x --:-- f = x + f in 1 --:-- 2
18:44:38 <lambdabot>   <hint>:1:1: parse error on input `--:--'
18:44:51 <startling> mauke: thanks. :)
18:44:57 <flebron> lambdabot's parser might be screwed up.
18:45:06 <Nereid> > let x --:-- f = x + f in 1 --:-- 2
18:45:08 <lambdabot>   3
18:45:20 <Nereid> what's wrong with it?
18:45:27 <startling> :t let x --:-- f = x + f in (--:--)
18:45:29 <lambdabot> parse error (possibly incorrect indentation)
18:45:35 <startling> it's the parens-ing, apparently.
18:45:44 <Nereid> hmm.
18:45:53 <startling> > let (--:--) = (+) in 1 --:-- 2
18:45:54 <lambdabot>   3
18:45:58 <startling> weird.
18:46:00 <Nereid> ghci accepts it
18:46:10 <startling> indeed.
18:46:36 <mauke> :t (--:)
18:46:38 <lambdabot> parse error (possibly incorrect indentation)
18:46:43 <mauke> :t (+--:)
18:46:44 <lambdabot> parse error (possibly incorrect indentation)
18:46:46 <mauke> :t (+-:)
18:46:47 <lambdabot> Not in scope: `+-:'
18:46:54 <startling> :t (--:--)
18:46:55 <lambdabot> parse error (possibly incorrect indentation)
18:47:17 <startling> bleh.
18:49:50 <jonkri> should i use the failure package? <http://www.haskell.org/haskellwiki/Failure>
18:51:16 <hpc> doesn't seem to give you anything useful
18:51:22 <hpc> all the helpful error messages will be String
18:51:34 <hpc> in which case, you already have your polymorphic failure
18:51:36 <hpc> :t fail
18:51:37 <lambdabot> Monad m => String -> m a
18:52:09 <hpc> or write your own exception type and incorporate it into the typical try-catch convention
18:52:16 <jonkri> i'm currently using IOExceptions, custom Exception and Error instances, and ErrorT
18:52:16 <hpc> or use (Either e)
18:52:22 <Nereid> "fail" describes itself quite well
18:52:25 <Nereid> :(
18:52:55 <jonkri> i was thinking that this perhaps could add some consistency to it all
18:53:23 <hpc> not really, imo
18:53:41 <hpc> pick one way of doing errors internally, then expose a failure-less API
18:53:50 <hpc> or have your API return Maybe foo, or something
18:54:23 <jonkri> not to force the failure package upon users of my api?
18:54:33 <hpc> essentially, yes
18:55:06 <hpc> nobody wants to filter through edwardk levels of polymorphic type signatures when (Either ParseError SyntaxTree) will do
18:55:30 <hpc> (unless you are as smart as edwardk and can make a good argument)
18:55:47 <jonkri> ok
18:57:19 <startling> :S
18:59:31 <Nereid> but it's so damn convenient to write stuff like Just foo <- blah in a MaybeT
18:59:31 <Nereid> :(
19:02:55 <hpc> heh, i too am a big fan of fail exploits
19:03:11 <hpc> but they are not to be undertaken lightly
19:04:23 <Nereid> but then it makes no sense for fail to take a String argument
19:04:32 <startling> indeed.
19:04:56 <startling> Monad should obviously be a MultiParamTypeclass
19:05:20 <hpc> class Monad m f | m -> f where fail :: f -> m a, ...
19:05:38 <hpc> i... can almost see that working
19:05:48 <aavogt> that one looks nicer as an associated type
19:05:58 <hpc> yeah
19:06:07 <startling> it's basically MonadError
19:06:20 <startling> it's exactly MonadError
19:06:24 <hpc> coming up with a thing to give "fail" when doing (<-) is tricky though
19:06:32 <startling> yeah
19:21:13 <doddlek> If I want to implement Ord, why on earth do I have to implement Eq? You don't need Eq for anything in Ord!
19:21:25 <hpc> :t compare
19:21:27 <lambdabot> Ord a => a -> a -> Ordering
19:21:29 <hpc> @src Ordering
19:21:30 <lambdabot> data Ordering = LT | EQ | GT
19:21:51 <hpc> there's clearly no way Ord would require anything related to EQuality
19:21:56 <hpc> ;)
19:22:07 <doddlek> hpc: but why do I need to implement Eq, if I didn't what would not work? nothing!
19:22:12 <mauke> doddlek: instance Eq YourType where x == y = compare x y == EQ
19:22:31 <doddlek> mauke: yeah, I know that, but why do I need to do it if I'm not going to use it? it's a waste
19:22:50 <doddlek> if I'm never going to use the members of Eq, just those in Ord, why do I need to implement them?
19:22:55 <mauke> it makes no sense to have a type that supports 'compare' but not '=='
19:22:57 <hpc> doddlek: same reason Monad (should) imply Functor and Applicative
19:23:17 <doddlek> hpc: exactly! but it doesn't!
19:23:35 <mauke> it just forces redundant class constraints on your users
19:23:40 <hpc> there's laws your instance should follow, and "decidable ordering implies decidable equality" is one the compiler can enforce
19:23:44 <doddlek> mauke: if i never use == with my data type, why waste time by implementing it?
19:23:45 <hpc> so it does
19:23:59 <mauke> it just forces redundant class constraints on your users
19:24:00 <hpc> or more precisely, the haskell report specifies it
19:24:28 <hpc> nobody wants to throw around (Eq a, Ord a) constraints everywhere just to write nice code
19:24:47 <hpc> in the war between (x == y) and (case compare x y of ...), there can only be one winner
19:27:03 <hpc> :t \f x -> f <$> join x
19:27:05 <lambdabot> (Monad f, Functor f) => (a -> b) -> f (f a) -> f b
19:27:33 <hpc> doddlek: that (Monad f, Functor f) constraint is flat out ridiculous
19:27:41 <madjestic> hmmm.  I can see the same-named modules, defined in different libraries.  (e.g. Control.Monad is defined in base-4.6.0.0 and haskell2010.1.1.1.0). Is not that going to cause a conflict?
19:27:43 <hpc> when it's obvious that any Monad is already a Functor
19:28:03 <hpc> and it's a historical accident that Monad doesn't do what Ord does and require Functor
19:28:07 <Nereid> :t \f x -> f `liftM` join x
19:28:08 <lambdabot> Monad m => (a1 -> r) -> m (m a1) -> m r
19:28:38 <Nisstyre> hpc: you can't really blame the type inference engine for that
19:29:12 <Nereid> madjestic: don't use the haskell2010 package
19:29:32 <madjestic> Nereid: should I unregister it?
19:29:50 <Nereid> you could hide it
19:30:08 <Nereid> ghc-pkg hide
19:31:18 <Nereid> (and should)
19:37:03 <madjestic> Nereid: thanks.  I see now that it's actually hidden, however Leksah shows them in the package browser anyways
19:58:47 <MaybeCallMe> I want to write a Haskell DLL method which has state. but I don't know how to marshal the state monad and give it back each time I call the method from another language.
20:01:40 <parcs> from what language?
20:01:43 <parcs> C?
20:01:48 <CoolChapChad> y do ppl want shinies?
20:01:51 <CoolChapChad> centos, fedora, gentoo
20:02:18 <simpson> MaybeCallMe: IIRC you're supposed to use IORefs.
20:02:20 <mauke> CoolChapChad: welcome to #haskell
20:02:33 <parcs> why _do_ people like shiny things?
20:02:36 <CoolChapChad> firepokemon don't get involved
20:02:56 <mauke> CoolChapChad: how would you pass the turing test?
20:03:00 <CoolChapChad> Hi Zero, join wofl
20:03:24 <parcs> oh, because water is shiny
20:03:54 <simpson> CoolChapChad: Say one single sentence that doesn't resemble a Markov process. >:3
20:03:57 <CoolChapChad> i haqve a problem.
20:04:13 <CoolChapChad> what is markov
20:04:16 <CoolChapChad> and why does it matter
20:04:27 <simpson> Doesn't matter. What's the problem?
20:04:32 <CoolChapChad> Is there a way I can check for the second ' ' (blank) in a string with index();?
20:04:46 <mauke> CoolChapChad: what is index()?
20:04:50 <CoolChapChad> or maybe not, did aeroblast become Special?
20:04:52 <CoolChapChad> "owning" people doesnt make people annoyed
20:05:12 --- mode: ChanServ set +o mauke
20:05:12 --- kick: CoolChapChad was kicked by mauke (CoolChapChad)
20:05:24 <mauke> looks more like relay than markov
20:05:48 <simpson> I haven't dealt much with non-Markovian analysis.
20:07:12 --- mode: mauke set -o mauke
20:11:18 <chidy> \msg lambdabot
20:21:04 <jonkri> can anyone tell me what's going on at this line? https://github.com/jonkri/pontarius-xmpp/blob/master/source/Network/Xmpp/TLS.hs#L76 ... why is TLSError added after the TLSError type constructor?
20:21:07 <CoolChapChad> i cant finish step 4
20:22:18 <jonkri> TLSError seems not to be defined elsewhere
20:22:55 <mysticc> @hoogle Data.Random
20:22:56 <lambdabot> package random
20:22:56 <lambdabot> package random-access-list
20:22:56 <lambdabot> package random-extras
20:28:03 * thoughtpolice cut runtime in a benchmark in half with RULES
20:28:30 <thoughtpolice> it's nice being able to tell the compiler that
20:31:20 <startling> is there something like withStateT that lets you change the type of the state?
20:31:25 <CoolChapChad> hate.
20:32:27 <startling> hm?
20:34:42 <jonkri> nevermind, somehow TLSError referred to TLSError in Network.TLS, even though that module was imported as qualified. anyway :-)
20:43:32 <gwern> @quote
20:43:32 <lambdabot> EvilTerran says: Hylo morphism batman!
20:51:50 <monochrom> haha
21:01:21 <qasd> what does <3 mean?
21:01:25 <CoolChapChad> "owning" people doesnt make people annoyed
21:02:17 <simpson> qasd: It's supposed to look like a heart.
21:35:44 <ivanm> *grumbles* looks like I forgot to record and push a patch I made before leaving home, so I have to remember how I did it if I'm going to release a new version of this package :s
21:37:09 <shirt> if x then y else z
21:37:11 <shirt> what is x called?
21:37:19 <shirt> and what are y and z called?
21:38:03 <mikeplus64> shirt: they're all expressions
21:38:41 <mikeplus64> but i guess you call x the predicate
21:38:56 <shirt> what about y and z?
21:39:43 <mikeplus64> branches maybe
21:42:30 <lightquake> hey #haskell, any opinions on reactive-banana vs netwire?
21:44:22 <TheGreekBrit> They're definitely libraries
21:52:08 <latermuse> how can i make a function do nothing if a list is empty?
21:52:35 <shachaf> What does it mean to do nothing?
21:53:13 <latermuse> if list' == [] then dontDoAnything else doStuff
21:53:40 <Clint> what's the type signature?
21:54:43 <shachaf> I guess latermuse's IRC client decided to do nothing.
21:54:57 <otters> if cannotUnderstandQuestion then return ()
22:17:17 <mikeplus64> is it possible to make variadic type families?
22:21:48 * applicative cant see how
22:24:45 <mikeplus64> what i wanted can be emulated by using type level lists so everything is fine and horrific
22:24:54 <Nereid> how awful
22:29:03 <applicative> certainly you can do something like type family M (a :: [*]) :: *; type instance M '[] = (); type instance M '[Int] = Char
22:30:23 <applicative> type instance M '[Int,Char] = Bool
22:30:24 <mikeplus64> applicative: i wanted to make a variadic type composition thing
22:30:58 <mikeplus64> so i just made type family Wrap (f :: [* -> *]) x
22:32:20 <applicative> I see, type constructor composition, so to say.
22:32:30 <mikeplus64> yeah
22:33:01 <applicative> I  see but the thought is, Wrap is hideous.
22:33:18 <applicative> I take it type checks or kind checks....
22:33:26 <mikeplus64> haha
22:33:28 <mikeplus64> yeah
22:34:23 <startling> has anyone done any parsing-type things with lenses? I've got this neat demo: https://gist.github.com/bc34fe8cd1ae4526c92f
22:34:36 <startling> any suggestions? I feel like I could use Zoom somehow but I'm not completely sure.
22:35:32 <applicative> type family Wrap (f :: [* -> *]) x ;type instance Wrap '[] x = x; type instance Wrap (f ': fs) x = f (Wrap fs x)
22:36:25 <mikeplus64> yep
22:36:26 <applicative> mikeplus64: I wonder how one could get something useable like a Functor   or Applicative constraint on  the fs in there
22:36:56 <mikeplus64> instance Functor f => Wrap '[f] might work
22:37:16 <applicative> I  guess its obvious
22:37:20 <mikeplus64> nope
22:37:23 * applicative tries it
22:37:29 <applicative> oh
22:37:36 * applicative tries it anyway
22:37:45 <mikeplus64> can't use type families in instances
22:39:02 <applicative> yeah, how sensible of the compiler
22:39:57 <applicative> even if it made sense, how could the compiler see that instance Functor f => type instance Wrap (f ': fs) x = f (Wrap fs x)
22:40:12 <applicative> together with the other
22:40:26 <applicative> entailed that all the fs were Functor too
22:41:15 <mikeplus64> i think if types were curried like ordinary functions you might be able to have type family Wrap fs :: * -> * using some type composition function
22:46:14 <startling> So I've got a class of things with kind * -> *; can I make it a subclass of Monoid somehow?
22:46:39 <applicative> instance Monoid (Startling a) where...
22:46:52 <applicative> oh a class
22:47:39 <applicative> what's the extension youd need for instance Startling f => Monoid (f a)
22:48:19 <startling> I want class Monoid (f a) => Startling f where ...
22:49:51 <startling> oh, I see what you're saying.
22:49:52 <applicative> oh dear, that's not going to work.
22:50:39 <applicative> class forall a (Monoid (f a) => Startling f
22:50:47 <r00723r0> So there are types and type classes?
22:51:14 <applicative> r00723r0: yes, and the latter are (extensible) classes of the former, even
22:51:33 <r00723r0> So typeclasses are types?
22:51:38 <r00723r0> What's the difference?
22:51:41 <applicative> no
22:52:17 <sclv> a type is something that a value has or "belongs to"
22:52:27 <r00723r0> sclv: OK, understood.
22:52:28 <sclv> it is like a class in java
22:52:31 <applicative> r00723r0: a named class of types is associated with a bunch of 'methods' which are thereby overloaded
22:52:37 <startling> applicative: I need ConstraintKinds?
22:52:39 <mikeplus64> r00723r0: typeclasses take types and return a Constraint, and have functions/values involving the classes's paramaters
22:52:45 <sclv> a type class is something that a type may belong to (and a type may belong to many)
22:52:52 <r00723r0> mikeplus64: can you rephrase please?
22:53:02 <mikeplus64> r00723r0: what sclv is saying :)
22:53:07 <sclv> it is (waves hands) like an interface in java
22:53:34 * Jafet loads the shotgun
22:53:40 <r00723r0> 01:52 < sclv> a type class is something that a type may belong to (and a type  may belong to many)
22:53:43 <r00723r0> What?
22:53:49 <r00723r0> Can you give me an example?
22:53:52 <sclv> Eq is a typeclass
22:53:52 <startling> r00723r0, Show
22:54:00 <sclv> it says "this class can be compared for equality"
22:54:01 * applicative  doesnt know java but interface is not too bad a word for that material, is it?
22:54:03 <sclv> Ord is another typeclass
22:54:20 <sclv> it says "this class can be compared for less than"
22:54:21 <r00723r0> So types implement typeclasses?
22:54:22 <startling> r00723r0: we can use the function "show" to turn any value of a type that's an instance of Show into a string
22:54:25 <sclv> so Bool is both Eq and Ord
22:54:27 <shachaf> r00723r0: You're probably best off ignoring type classes as much as you can until you understand regular types. They're a much more complicated (and less fundamental) concept.
22:54:30 <sclv> types *can* implement typeclasses
22:54:34 <sclv> they're usable without them as well
22:54:41 <r00723r0> Interesting. OK.
22:54:45 <r00723r0> Can I make my own typeclass?
22:54:47 <sclv> yes
22:54:54 <r00723r0> And I can make my own type.
22:54:57 <sclv> yes
22:54:58 <mikeplus64> yep
22:55:00 <applicative> r00723r0: if you want to use the literals 1 2 3 for your type you must make a Num instance forthem
22:55:02 <startling> (but you don't often want to make a typeclass)
22:55:24 <r00723r0> applicative: it's made implicitly, no?
22:55:24 <sclv> class ShowMe a where showMe :: a -> String
22:55:28 <applicative> r00723r0: making a typeclass is just as easy, but frequentlyinadvisable
22:55:30 <shachaf> applicative: Is literal overloading really the thing to bring up right now?
22:55:38 <applicative> shachaf: maybe not
22:55:50 <sclv> that says that there's a class showme and for something to be an instance of it, you have to tell haskell how to turn it into a string
22:56:04 <applicative> but is 'overloading'  the wrong thing to bring up?
22:56:36 <sclv> instance showMe Bool where showMe x = case x of {True -> "TrueBool"; False -> "FalseBool" }
22:56:50 <sclv> or instance ShowMe Bool, rather
22:56:56 <applicative> sclv: don't class names have...
22:57:22 * Jafet loads the minigun
22:57:26 <ofan> types specialize typeclasses, data specializes types
22:57:46 <sclv> so that now says that we had a ShowMe class, and we had a Bool, but now we have tied to two together, and taught the compiler that Bool is an instance of ShowMe
22:58:00 <shachaf> ofan: The relationship between types and type classes is very different from the relationship between values and types.
22:58:10 <shachaf> (Or should I say expressions and types? Anyway.)
22:58:18 <Jafet> Expressions are syntactical
22:58:22 <applicative> ofan: but that doesn't seem right really; types and values would be the same if typeclasses didn't exist, leaving out some extensions
22:58:52 <startling> shachaf: you know lens pretty well, right? are there any fancy types I should learn to simplify this kind of thing? https://gist.github.com/bc34fe8cd1ae4526c92f
22:59:12 <Jafet> lens-consulting
22:59:25 <applicative> a type and its values come into the world together,  but whether any classes get instanced is optional
22:59:26 <startling> ;)
22:59:54 <applicative> ah, startling has found a proper soldier in the lens army
23:00:18 <startling> applicative: :S
23:00:23 <shachaf> startling: There's always #haskell-lens for lens questions in general. :-)
23:00:55 <applicative> oh  god not #haskell-lens
23:01:15 * applicative opens #haskell-type-level-nats
23:01:17 <startling> applicative: fwiw, class (forall a. Monoid (b a)) => Both b where doesn't seem to work -- it asks for ConstraintKinds and UndecidableInstances and then I get Could not deduce (forall a. Monoid (Deserialize a)) even though there is an instance.
23:01:25 <startling> shachaf: oh, forgot about that.
23:01:33 <applicative> yipe
23:02:37 * applicative opens #haskell-constraintkinds in hope of figuring them out
23:02:52 <startling> hehe
23:04:11 * applicative opens #haskell-syntax-complaints with a view to avoiding it
23:06:18 * applicative  thinks 'that's the shul I don't go to.'
23:06:49 <Nereid> I've never heard of forall being used like that.
23:07:48 <applicative> Nereid: It cant be, but I remember something on haskell cafe...
23:08:53 <papyrus> hi
23:09:12 <Nereid> hi
23:09:19 <applicative> I think lispy got into it, and claimed there were actually no impediments to implementing such a thing, Nereid
23:09:20 <r00723r0> What are Haskell's biggest weaknesses, other than lack of support/popularity?
23:09:34 <applicative> hi papyrus
23:09:47 <applicative> r00723r0: syntax of course
23:09:57 <Jafet> Kryptonite
23:09:58 <r00723r0> applicative: what else?
23:10:14 <ion> Syntax is a weakness in Haskell? ಠ_ಠ
23:10:17 <r00723r0> Does it have any inconsistencies?
23:10:19 <Nereid> the overwhelming number of monad tutorials
23:10:28 <applicative> ion, it's a bit late for me....
23:10:37 <ion> I find Haskell’s syntax one of its strengths.
23:10:43 <r00723r0> ion: me too.
23:10:44 <ofan> r00723r0: lack of array or sequential data structures support,IMHO
23:10:44 <applicative> ion, of course.
23:10:53 <r00723r0> ofan: linked lists?
23:10:55 <Nereid> ofan: since when?
23:11:06 <ofan> roconnor: nope, i mean arrays
23:11:12 <r00723r0> Is there no arrays in Haskell?
23:11:13 <ofan> r00723r0: ^^
23:11:14 <Nereid> there are arrays
23:11:14 <Jafet> People like ofan writing misleading blog posts about haskell
23:11:27 <ion> and misleading people on IRC
23:11:50 <applicative> r00723r0: all kinds of arrays
23:11:56 <Nereid> the worst thing about haskell is that it makes me not want to write code in other languages.
23:12:07 <ofan> yeah i come form c++ btw, saw the arrays in haskell is really hard to use
23:12:24 <r00723r0> I want to know what you hate about Haskell.
23:12:35 <Nereid> arrays are fine.
23:12:40 <applicative> are they, I guess some of the obvious syntax is missing for arrays
23:12:44 <Nereid> although often they're not what you want anyway.
23:12:46 <Jafet> You come from C++ and think Haskell is hard to use?
23:12:50 <Jafet> Fascinating
23:12:51 <Nereid> haha
23:13:22 <ofan> Jafet: haskell is more abstract than c++
23:13:25 <Jafet> C++ has like four interfaces to arrays, all different
23:13:31 <applicative> there used to be a preprocessor for the arr[i] sort of notation
23:13:34 <ion> r00723r0: There aren’t really things i *hate* about Haskell, but some of the historical mistakes in certain standard typeclasses are slightly annoying (but not at all debilitating).
23:13:44 <mikeplus64> Jafet: to be fair, we have loads of array interfaces
23:13:48 <r00723r0> ion: like?
23:14:07 <papyrus> i want to describe a type that can have a value 1 ~ 100. like MyData 1 , MyData 2 , ... MyData 100,
23:14:16 * applicative didn't understand Jafet to be dissing Haskell arrays
23:14:24 <ion> r00723r0: Monad not depending on Applicative, Monoid not depending on Semigroup for instance.
23:14:31 <startling> ^ yeah, agreed
23:14:31 <ion> r00723r0: “fail” being in Monad
23:14:37 <startling> that's just historical baggage though
23:15:08 <applicative> papyrus: I recommend  against enumeration; the compiler spends too long thinking about it
23:15:35 <mikeplus64> r00723r0: i don't like monad transformers like ReaderT or ContT, or big ugly stacks of monad transformers
23:15:41 <Jafet> papyrus: you cannot (or should not) add this limit to the MyData constructor, but you can write a function.
23:15:41 <applicative> data Quarter = First|  Second|Third
23:16:02 <ion> What’s the deal with big enums being slow to compile in GHC and could that be optimized?
23:16:10 <simpson>  /bu26
23:16:14 <simpson> Urgh, fail.
23:16:18 <Jafet> myData n | 1 <= n && n <= 100 = MyData n | otherwise = undefined
23:16:33 <applicative> oh I see papyrus you want it to be say newtype MyData = MyData Int but restricted to Ints less than 100
23:16:36 <mikeplus64> r00723r0: (which see a lot of use)
23:16:52 <applicative> > maxBound :: Word8
23:16:53 <lambdabot>   255
23:16:54 <applicative> too big
23:17:10 <papyrus> yes. restriedted to Int less than 100
23:17:12 <Jafet> > 0x100
23:17:13 <lambdabot>   256
23:17:22 <papyrus> Jafet : good idea.
23:18:00 <applicative> papyrus: it can be done by hiding, but why bother
23:18:10 <Jafet> @where smart
23:18:10 <lambdabot> I know nothing about smart.
23:18:14 <Jafet> @where smart-constructors
23:18:14 <lambdabot> I know nothing about smart-constructors.
23:18:28 <Jafet> where is pretty useless
23:18:29 <Jafet> http://www.haskell.org/haskellwiki/Smart_constructor
23:18:29 <applicative> papyrus: it  is also not to hard to define a type that has 100 constructors, then make a Num instance or whatever
23:18:50 <applicative> @where monad
23:18:50 <lambdabot> I know nothing about monad.
23:18:57 <applicative> moron
23:19:00 <Jafet> @where waldo
23:19:00 <lambdabot> http://planet.haskell.org
23:19:07 <applicative> !!!
23:19:16 <Jafet> Colour me striped.
23:19:52 <ion> ofan: lens might make arrays nicer to use.
23:20:25 <ofan> ion: thanks, is it a library?
23:20:26 <mikeplus64> ion: how? can you make lenses for mutable arrays somehow?
23:21:16 <mikeplus64> immutable ones are fine though i guess
23:21:17 <applicative> data Digit  = D0|D1|||||D9 ; data Papyrus = Papyrus Digit Digit; instance Num Papyrus where fromInteger =  ...
23:22:02 <Jafet> I believe this is rapidly approaching irrelevance
23:22:17 <papyrus> hmm...:-)
23:23:26 <papyrus> i think it need to describe numeric operation. :-)
23:23:45 <mikeplus64> ofan:
23:23:47 <mikeplus64> @hoogle vector
23:23:47 <lambdabot> Test.QuickCheck.Arbitrary vector :: Arbitrary a => Int -> Gen [a]
23:23:47 <lambdabot> Test.QuickCheck vector :: Arbitrary a => Int -> Gen [a]
23:23:47 <lambdabot> package vector
23:24:06 <Nereid> not the quickcheck stuff
23:24:15 <mikeplus64> erm ofan: http://hackage.haskell.org/package/vector
23:24:19 <Jafet> @hackage repa
23:24:19 <lambdabot> http://hackage.haskell.org/package/repa
23:24:25 <ofan> thanks mikeplus64
23:24:35 <mikeplus64> oh, there's a @hackage, cool
23:24:39 <applicative> ofan: Data.Vector.Unboxed  and Data.Vector.Unboxed.Mutable are the most awesome modules on hackage
23:24:51 <Jafet> Why not go for something that actually smokes C++ directly
23:25:01 <Nereid> but @hackage x is just "http://hackage.haskell.org/package/" ++ x
23:25:23 <Jafet> @hackage "\""
23:25:23 <lambdabot> http://hackage.haskell.org/package/"\""
23:25:27 <Nereid> @hackage ../
23:25:27 <lambdabot> http://hackage.haskell.org/package/../
23:25:41 <sw2wolf> @where repa
23:25:41 <lambdabot> I know nothing about repa.
23:25:54 <startling> @hackage repa
23:25:54 <lambdabot> http://hackage.haskell.org/package/repa
23:25:56 <mikeplus64> ofan: also yes look at repa
23:26:03 <sw2wolf> @where xmonad
23:26:03 <lambdabot> http://xmonad.org/
23:26:11 <applicative> ofan: I was a ninety pound weakling, kids kicked sand in my eyes at the beach....
23:26:21 <applicative> then I discovered Data.Vector.Unboxed
23:26:37 <Jafet> I simply avoid beaches
23:28:28 <ofan> thanks applicative, mikeplus64
23:53:15 <ion> It might be nice if there was a way (with -Wall) to do something like “case xs of (x:xs) -> foo x xs; …”, a special case where the “xs” is shadowed intentionally: without shadowing, all the outer xs can do for “foo” is to cause bugs the type system won’t catch. Perhaps some character in front of the xs in the pattern or something.
23:55:08 <shachaf> That seems confusing to me.
23:55:18 <shachaf> Why have both an outer and an inner xs?
23:58:17 <Saizan> it's kind of the same reason the State monad is better than s s' s'' s'''
23:58:57 <Saizan> poor man's uniqueness typing
