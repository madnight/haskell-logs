00:00:04 <edwardk> :t paraOf
00:00:06 <lambdabot> Getting (Endo [a]) a b a b -> (a -> [r] -> r) -> a -> r
00:02:20 <rpglover64> So here's what I'm doing: I have an Ast type and I'm recursing on it; for accumulating free variables, I noticed that a paramorphism generalizes the code I was writing nicely, so I factored it out. Then I needed to implement tree substitution and it broke down, because I needed a way to put trees back together.
00:03:31 <edwardk> rpglover64: have you looked at bound?
00:04:06 <edwardk> @hackage bound
00:04:06 <lambdabot> http://hackage.haskell.org/package/bound
00:04:23 <rpglover64> Not at that one, but my coworker/project lead wants to minimize dependencies
00:04:31 <rpglover64> and I'm having fun playing with recursion schemes
00:04:39 <rpglover64> I'll take a look anyway, though
00:04:39 <edwardk> bound is 5 very short modules with no third party dependencies
00:04:47 <edwardk> and its haskell 98
00:04:59 <edwardk> and you can reimplement the core of it in a screen if you have to in your project
00:05:01 <edwardk> =P
00:05:06 <edwardk> well, a bit more
00:05:31 <edwardk> and i lied it has a dependency on a package it needs to get usable equality/show instances
00:05:59 <edwardk> rpglover64: the example on https://github.com/ekmett/bound/#goals might highlight what you can do with it
00:06:21 <edwardk> in the end you get a Monad for your expression type, where (>>=) is substitution of free variables
00:06:26 <rpglover64> I'll keep it in mind for the project :)
00:06:35 <edwardk> and the Traversable instance is letting you visit all the variables
00:06:47 <edwardk> (er all the free variables, skipping bound variables)
00:07:03 <shachaf> Uh oh, deriving (Functor,Foldable,Traversable)
00:07:19 <edwardk> shachaf: yeah. you can hand roll them if you must ;)
00:07:48 <edwardk> in our compiler here we gave in and wrote a class for simultaneously (>>=)'ing and traverse'ing
00:08:00 <edwardk> and then use that to implement (>>=) and traverse in one go
00:09:03 <hpaste> rpglover64 pasted “recursion schemes” at http://hpaste.org/78891
00:09:12 <edwardk> class (Traversable t, Monad t) => Mangled t where mangled :: Applicative f => (a -> f (t b)) -> t a -> f (t b); mangled f = join <$> traverse f -- gets you a default definition in terms of the other two
00:09:40 <edwardk> rpglover64: that makes my eyes bleed
00:09:51 <rpglover64> I think I might be slightly happy about that
00:10:02 <rpglover64> why?
00:10:29 <edwardk> so what are the Int's in this expression?
00:10:48 <edwardk> lets go back and derive the goal ;)
00:10:49 <rpglover64> other parts of the Ast that recursion doesn't directly touch
00:11:13 <edwardk> do you have a notion of free variables?
00:11:20 <rpglover64> not in this tree
00:11:26 <edwardk> in general?
00:11:28 <rpglover64> yes
00:11:53 <rpglover64> (this is a completely toy example, if it wasn't clear)
00:11:59 <edwardk> would data Expr a = Var a | A Int | B Int (Expr a) | C Int (Expr a) (Expr a)   be closer to a real world example?
00:12:14 <edwardk> or even one where one of them binds names? like a Lam?
00:12:37 <edwardk> data Expr a = Var a | Lam (Scope () Expr a) | App (Expr a) (Expr a) | B Int (Expr a) | ...
00:12:42 <rpglover64> no PHOAS; we're just using strings for variable names
00:12:51 <edwardk> this isn't PHOAS
00:13:06 <rpglover64> hmm
00:13:09 <edwardk> this is a much accelerated form of locally-nameless de-bruijn
00:13:27 * rpglover64 is not enlightened
00:13:31 <edwardk> but you never see a debruijn index and don't have to work in a monad.
00:13:45 <rpglover64> regardless, though, I have to stick to plain old strings
00:13:59 <edwardk> i'm willing to let you have Expr String in the end ;)
00:14:28 <edwardk> true = lam "F" $ lam "T" $ V"T"
00:14:35 <edwardk> or whatever
00:15:16 <edwardk> but if you deal with the binders in a more intelligent manner you can avoid conflicts with the free variable strings
00:15:24 <rpglover64> I'm fully aware
00:15:34 <rpglover64> but such are my constraints
00:15:40 <edwardk> fair enough
00:17:41 <rpglover64> data Expr = Var String | Lam Binder Expr | Prod Expr Expr | Prim Int | Appl Expr Expr | Tag String Expr
00:17:51 <rpglover64> Something like that is more representative of my Ast
00:18:00 <edwardk> how… retro =P
00:18:01 <edwardk> =)
00:18:08 <rpglover64> where Binder is a more complex datatype than just String
00:18:11 <edwardk> sure
00:19:07 <mm_freak> wow, i remember the days of manual substitution =)
00:19:12 <edwardk> That is analogous to https://github.com/ekmett/bound/blob/master/examples/Deriving.hs#L17 where my patterns are built up by smart constructors https://github.com/ekmett/bound/blob/master/examples/Deriving.hs#L67
00:19:19 <edwardk> lam (conp "Hello" [varp "x", wildp]) (V "y")
00:19:46 <edwardk> the difference is now you have to deal with all the headaches of naive substitution
00:19:54 <edwardk> and i can't screw it up ;)
00:19:58 <mm_freak> rpglover64: you should really check out locally nameless and the 'bound' library =)
00:19:59 <rpglover64> Oh, come on; they're not that bad
00:20:16 <rpglover64> mm_freak: I'm constrained by other people on the project
00:20:34 <mm_freak> rpglover64: then i recommend convincing them to use locally nameless
00:20:51 <mm_freak> naive 200 lines, LN with bound 20 lines
00:21:05 <edwardk> i have to admit its kinda silly to go down a path that leads to 10x as much code
00:21:20 <edwardk> just to save explaining a monad transformer to someone
00:21:29 <mm_freak> you don't really have to
00:21:51 <rpglover64> It's not the explaining part… It's the convincing part. And trust me, I've tried.
00:22:47 <edwardk> data Expr a = Var a | Lam (Pat Expr a) (Expr a) | Prod (Expr a) (Expr a) | Prim Int | Appl (Expr a) (Expr a) | Tag String (Expr a) deriving (Eq,Show,Functor,Foldable,Traversable) and you are 8 lines from being done with substitution and free variable extraction completely =P
00:23:05 <mm_freak> rpglover64: convince them with code
00:23:14 <mm_freak> it's really a factor of 10 in code size
00:23:30 <nyc> 8 lines? That's a bit surprising to me.
00:23:44 <rpglover64> *sigh* I'll try again. Still: I'm curious about recursion schemes _for their own sake_, and I think I ran into them while playing around, incidentally, with free variables and substitution.
00:23:50 <edwardk> nyc: https://github.com/ekmett/bound/#goals the example there is almost identical
00:24:07 <mm_freak> edwardk: you can do it even with less lines, if you live without Traversable
00:24:20 <mm_freak> in fact i only need the DSL, the Monad instance and that's it
00:24:36 <mm_freak> for most uses that's sufficient
00:24:43 <edwardk> mm_freak: well the traversable instance is automatically derived by ghc (crappily i might add) so its just one line and it gets you the free variable set
00:24:59 <edwardk> if you add lens 'setOf traverse' is your free variable list ;)
00:25:06 <mm_freak> edwardk: it's about five lines, because then you need to define all the prelude-extras instances
00:25:24 <edwardk> well, i usualy just use Eq1 and Show1
00:25:47 <edwardk> i need to ship a new version of prelude-extras that changes the defaults to default signatures
00:26:02 <edwardk> that would cut the noise way down
00:26:54 <mm_freak> it's not that i have a problem with the instances, but they are really trivial and a bit noisy
00:26:58 <edwardk> rpglover64: i realize we got stuck on your example. i'm rather decidedly anti-recursion-schemes these days, so i'm afraid i'm not going to be much help beyond helping you classify something you find ;)
00:27:28 <mm_freak> rpglover64: at least do this:  data Expr a = Var a | …
00:27:37 <rpglover64> edwardk: Thanks anyway; classification is still useful
00:27:38 <shachaf> edwardk prefers recursion haskells these days.
00:27:55 <mm_freak> then you can write a Monad instance that does substitution for you…  you'll still have to handle name clashes etc.
00:28:24 <edwardk> i just write shachaf-morphisms these days. they are incredibly self-optimizing. i write some code, and then he looks at the core, cries, and goes and fixes it up for me.
00:28:58 <edwardk> mm_freak: it doesn't work with real binders in there like that
00:29:10 <shachaf> The trouble is that the crying stage gets longer and longer with every iteration.
00:29:12 <rpglover64> edwardk: in the horrific code I posted, is the thing I called para a paramorphism, and is the thing I called meta anything named?
00:29:27 <statusfailed> Is ScopedTypeVariables supposed to let me use type vars in the function type signature inside the function body? it doesn't seem to work for me
00:29:34 <edwardk> oh yeah the eyebleeding thing
00:29:39 <mm_freak> statusfailed: remember to add "forall"
00:29:50 <rpglover64> edwardk: yep, that's the one
00:29:54 <mm_freak> statusfailed: "forall m. (Monad m) => m Int" instead of just "(Monad m) => m Int"
00:29:57 <edwardk> type signatures would really really help
00:30:07 <statusfailed> oh!
00:30:16 <statusfailed> fancy that... thanks
00:30:16 <rpglover64> brb, getting types
00:30:47 <mm_freak> edwardk: you're right
00:31:06 <mm_freak> you can't differentiate between free and bound variables =/
00:31:19 <hpaste> rpglover64 annotated “recursion schemes” with “recursion schemes (annotation)” at http://hpaste.org/78891#a78892
00:31:32 <rpglover64> according to ghci, at least
00:31:36 <edwardk> mm_freak: yep. so hand-rolled recursion it is =/
00:32:31 <edwardk> i don't quite grok your para yet, so let me derive one that i believe is a paramorphism and you can come up with something equivalent. =P
00:32:57 <edwardk> data ExprF a = A Int | B Int a | C Int a a  is the base functor for 'Expr'
00:32:58 <rpglover64> and ignore the meta signature; it's from before a ghci reload
00:33:01 <edwardk> Expr = Mu ExprF
00:33:09 <edwardk> right?
00:33:14 <shachaf> That and a paramorphisms will buy you a cup of coffee.
00:33:41 <hpaste> “Ertugrul Söylemez” pasted “Simple lambda calculus using 'bound'” at http://hpaste.org/78893
00:33:52 <mm_freak> rpglover64: see my paste
00:33:56 <mm_freak> http://hpaste.org/78893
00:33:58 <rpglover64> edwardk: right
00:34:38 <edwardk> so now, para :: (ExprF (Expr, a) -> a) -> Expr -> a
00:34:56 <hpaste> rpglover64 annotated “recursion schemes” with “recursion schemes (annotation) (annotation)” at http://hpaste.org/78891#a78894
00:35:10 <neutrino_> rwbarton: hy, you around?
00:35:21 <edwardk> you can split this apart to get rid of the explicit ExprF's
00:35:42 <neutrino_> @tell rwbarton with system.process.internals you can get the pid of a process from the constructors of ProcessHandle and ProcessHandle__
00:35:42 <lambdabot> Consider it noted.
00:36:00 <mm_freak> actually my type is stupid…  i should use Scope a Expr a instead of Scope Name Expr a
00:36:14 <edwardk> because ExprF (Expr, a) ~  Int | (Int, Expr, a) | (Int, Expr, a, Expr a)
00:36:46 <edwardk> and Either a b -> c    is equivalent to passing two functions a -> c, and b -> c
00:36:48 <edwardk> so we can get
00:37:18 <edwardk> para :: (Int -> a) -> (Int -> Expr -> a -> a) -> (Int -> Expr -> a -> Expr -> a -> a) -> Expr -> a
00:37:36 <edwardk> that doesn't match up with your paramorphism
00:37:42 <edwardk> so i'm thinking yours isn't one ;)
00:37:46 <rpglover64> k
00:39:18 <rpglover64> Thanks
00:39:33 <rpglover64> And I'll look at bound, but I'm not going to get my hopes up
00:39:50 <nyc> I'm at a bit of a loss as to what's going on in that, probably because I'm unfamiliar with the libraries relied upon.
00:40:33 <merijn> statusfailed: ScopedTypeVariables lets where/let clauses inside a function reuse the variables in the top level type, which lets you write some type signatures which are otherwise impossible to write </late response>
00:40:56 <edwardk> nyc: bound is mostly self-contained. what it provides is a monad transformer for dealing with bound variables
00:41:13 <edwardk> you build your expression type or what have you, say 'Expr a'
00:41:25 <edwardk> and when you want name capture in it you use the 'Scope' monad transformer.
00:41:49 <edwardk> e.g. data Expr a = Var a | Lam (Scope () Expr a) | App (Expr a) (Expr a)
00:42:13 <nyc> Higher-order module systems FTW.
00:42:18 <edwardk> there we're saying that a lambda binds a group of variables where you can select between them with the type (), so there is only one variable.
00:42:46 <edwardk> to write the monad, you write it like usual, but replace the >>= for the Scope with >>>=
00:42:53 <neutrino_> hi edwardk :)
00:43:13 <edwardk> instance Monad Expr where Var a >>= f = f a; Lam b >>= f = Lam (b >>>= f); App l r >>= f = App (l >>= f) (r >>= f)
00:43:27 <edwardk> and congratulations you've dealt with capture-avoiding substitution
00:43:40 <edwardk> you can abstract :: (a -> Maybe b) -> f a -> Scope b f a
00:43:58 <edwardk> you can instantiate :: (b -> f a) -> Scope b f a -> f a
00:44:20 <edwardk> and if you need to convert back and forth to get under a binder for 'nf' purposes you can use fromScope and toScope
00:44:30 <edwardk> behind the scenes Scope is a fancy version of EitherT
00:44:55 <edwardk> its fancy because it lets me do a generalized 'de bruijn' representation where i can 'succ' an entire tree rather than just succ variables.
00:45:19 <edwardk> this lets substitution (>>=) avoid walking portions of the tree that can't contain any bound variables (wherever they've been 'succ'd)
00:45:32 <edwardk> which greatly speeds up debruijn indices
00:45:39 <edwardk> to the point where they don't feel like de bruijn ;)
00:46:03 <edwardk> it also lets me succ the entire tree in O(1) so lifting into the monad transformer is cheaper than it would be with EitherT.
00:46:34 <edwardk> Scope b f a    represents terms in the monad 'f' with free variables in 'a' and a layer of bound variables 'b'
00:46:45 <edwardk> heya neutrino_
00:47:19 <lewis1711> does anyone know of a functional version of bresenham floating around? or a functional equivalent that does the same thing?
00:47:30 <lewis1711> the line one, that is
00:48:11 <edwardk> do you need exact bresenham with the integer ops and everything? because nowadays thats kind of a bad way to implement the line drawing stuff
00:48:48 <lewis1711> edwardk: I basically want stepwise linear interpolation. I'm not sure what you mean by itneger ops
00:48:53 <lewis1711> or rather, how they effect anything
00:49:08 <lewis1711> and I don't need the actual line drawing, just the points
00:49:16 <edwardk> ah
00:49:20 * hackagebot generic-deriving 1.4.0 - Generic programming library for generalised deriving.  http://hackage.haskell.org/package/generic-deriving-1.4.0 (JosePedroMagalhaes)
00:49:27 <edwardk> yay
00:49:37 <edwardk> generic-deriving is out
00:50:26 <mm_freak> edwardk: data Expr v a = … | Let (Map v (Scope v (Expr v) a)) (Scope v (Expr v) a) | …
00:50:46 <mm_freak> that's a multi-letrec…  does that seem right to you?
00:51:23 <edwardk> mm_freak: i usually just use Let [Scope Int Expr a] (Scope Int Expr a)
00:51:25 <hpaste> sopvop pasted “Lens naming database fields. Can that "Sel" be more generic and allow strings?” at http://hpaste.org/78895
00:51:29 <edwardk> you can map to name them if you want
00:51:41 <sopvop> Sel is on http://hpaste.org/78895#line71
00:51:41 <edwardk> or just pair them with their names
00:52:22 <mm_freak> edwardk: yeah, but i wonder how i can handle failure…  'instantiate' doesn't allow that
00:52:45 <mm_freak> of course i could require well-formed expressions
00:53:04 <edwardk> thats what i do
00:53:12 <mm_freak> ok, thanks
00:53:24 <mm_freak> could probably just as well use Int then
00:53:49 <sopvop> edwardk: Can you please take a look at pastie. Of course it can just be select [nameOf foo, nameOf bar], but I want to avoid nameOf :)
00:54:24 <edwardk> sopvop: popping my stack and working down towards you, really ;)
00:54:32 <sopvop> Cool :)
01:01:30 <shachaf> Should I mentioned on libraries@ that Foldable provides whenJust in the form of for_?
01:02:35 <edwardk> yes
01:03:26 <yoyo> "hello
01:03:32 <yoyo> hello
01:03:38 <yoyo> is there any one here?
01:03:58 <shachaf> There is only silence and some second-hand clothes.
01:04:07 <yoyo> lol
01:04:21 <yoyo>  i was just wondering how should i learn haskeel
01:04:54 <yoyo> and if that is the best programing language to learn for a new program
01:06:24 <kranius> a new program or a new programmer ?
01:06:33 <yoyo> programer
01:06:54 <sopvop> @where lyah
01:06:54 <lambdabot> http://www.learnyouahaskell.com/
01:07:03 <yoyo> i have  a lot of speling mistakes as you can se,,
01:07:47 <yoyo> its just that i heard that this is a " functional"
01:08:05 <yoyo> and i need to bee good in programing so that i can pass an intervew in the army
01:08:33 <yoyo> so i am looking for some fun thing to learn, that i will be able to crate games with, or at least program some cool stuff
01:08:33 <sopvop> Marine Hacker Corps?
01:08:48 <yoyo> not exatly, but somting like that
01:09:20 <yoyo> they teach you most of it, but you still need to know a bit too pass the test's
01:09:40 <yoyo> any way,  is a  "purely functional" program good for me?
01:09:43 <sopvop> Thats the strangest reason to learn programming I've ever heard
01:09:48 <yoyo> lol
01:09:51 <yoyo> i realy love it
01:09:58 <yoyo> i enjoyed java
01:10:12 <yoyo> but i got sick of it beacuse they teached us so slolwy
01:10:27 <yoyo> and i realy would like to learn that in the army, i find it fasentaing
01:10:36 <yoyo> so i want to pass the test
01:11:05 <kranius> actually that's rather interesting
01:11:10 <kranius> where are you from ?
01:11:13 <yoyo> israel
01:11:20 <yoyo> we have to go to the army
01:11:29 <yoyo> so i would like to do somting intresting
01:11:47 <yoyo> so i need to learn programing :)
01:12:49 <yoyo> again, is haskell good for fast programing (probably gonna ask me to program stuff in fast speed (and alot of stuff,, so i need to program fast)
01:13:38 <yoyo> and is it good for making games (i programes a eazy game called "nim" in java and i loved it (its very eazy, i made it so that the comuter will always win)
01:13:45 <yoyo> programed*
01:14:08 <kranius> you can do anything with haskell
01:14:08 <t7> its good for trees
01:14:18 <kranius> but it has quite a heavy learning curve
01:14:20 <t7> you cant do y-combinator
01:14:31 <t7> cant do nasty python dynamic stuff
01:14:35 <Eelis> is there any module which provides      data Any u = forall c . u c => Any c    ? (yes, this only works with ConstraintKinds and ExistentialQuantification)
01:14:37 <shachaf> You can get anything you want at Alice's Restaurant...
01:14:46 <kranius> if you really want to learn fast, and then build fast, i'd pick ruby or python
01:14:49 <yoyo> sorry for beaing stubet
01:14:58 <yoyo> umm
01:15:01 <merijn> shachaf: to be fair, I much prefer whenJust/withJust to for_, it's much clearer imo
01:15:15 <yoyo> tnx man
01:15:50 <yoyo> what is phyton for, what exacty is the difference?
01:15:57 <shachaf> You should ask in #python.
01:15:59 <yoyo> i just want to make sure i learn the right stff
01:16:26 <madjestic> hey guys, fighting with diamond dependencies and I would love to wipe currently installed cabal packages.  Which dirs should be wiped?
01:16:37 <Chousuke> python and haskell are very different languages. you could write a book about the differences :P
01:16:46 <sopvop> ~/.cabal ~/.ghc
01:16:50 <yoyo> lol
01:16:52 <hkBst> yoyo: what kind of test is it that you need to pass?
01:16:59 <yoyo> actualy
01:17:03 <yoyo> its classfied
01:17:08 <yoyo> but somone told me a bit
01:17:41 <yoyo> they will let me program diffent things, with any program that i wnat (small programing things that are inoing to see if i do it fast and how do i think)
01:17:52 <yoyo> but its a "siber fighting" unit
01:17:57 <yoyo> so
01:18:17 <yoyo> i can astimat it has somting to do with haking
01:18:50 <yoyo> what are the differnt uses for phiton and haskell, and witch one is funner (i also want to injoy it!)
01:19:01 <yoyo> i am not gonna learn somting that is not intresting
01:19:11 <madjestic> haskell has hackage, that's similar to hacking
01:19:15 <hkBst> yoyo: so they might ask you to write factorial or reverse a list or something?
01:19:15 <kranius> rofl
01:19:28 <yoyo> they might
01:19:31 <yoyo> i have no idia
01:19:41 <Chousuke> haskell is definitely very interesting
01:19:59 <yoyo> i used the "try haskel"
01:20:02 <yoyo> and its fun
01:20:25 <kranius> when do you pass the test ? how many time are you willing to dedicate to your learning ?
01:21:25 <yoyo> to tell you the truth
01:21:30 <yoyo> i am in class in school right now
01:21:36 <yoyo> i have a comuter
01:21:44 <hkBst> yoyo: perhaps they are more interested in your knowledge of internet protocols and security than programming
01:21:47 <yoyo> so idisded that insted of playing in "armor games"
01:22:01 <yoyo> i should do somting efactive
01:22:08 <sopvop> Cyber fighting Unit, it's like real life Crysis and Deus Ex. Pew pew, transforming! Bzzz-Bzzz!
01:22:13 <yoyo> if its fun, i gess i can go 1-5 hower again
01:22:24 <yoyo> a day*
01:23:06 <yoyo> and i think i will go to the test in about a mounth or so (maby less maby more, first i will have to pass the first tests, but i realy think i did)
01:23:12 <vreg> M 7.3 Earthquake, off the east coast of Honshu, Japan
01:23:16 <vreg> 59 minutes ago
01:23:38 <vreg> :|
01:23:50 <yoyo> damn!
01:24:03 <sopvop> is 7.3 much?
01:24:09 <yoyo> yes!
01:24:11 <Ralith> very
01:24:16 <yoyo> it 10 times 6.3
01:24:20 * hackagebot yesod-pnotify 0.3.0.0 - Yet another getMessage/setMessage using pnotify jquery plugins  http://hackage.haskell.org/package/yesod-pnotify-0.3.0.0 (KatsutoshiItoh)
01:24:50 <statusfailed> bbc has it: http://www.bbc.co.uk/news/world-asia-20638696
01:24:56 <yoyo> i think ill go for haskell
01:24:59 <yoyo> it sound nice
01:25:08 <Ralith> we agree.
01:25:11 <statusfailed> good choice :)
01:25:11 <Ralith> mostly.
01:25:34 <yoyo> do you think i can get "ok" in a mouth ?
01:25:41 <yoyo> if i go 1-4 howes a day?
01:25:53 <neutrino_> imagining katutoshi quickly commit his changes right before his computer disintegrates in the aftershock
01:26:11 <Chousuke> yoyo: that depends on how you spend those hours
01:26:15 <neutrino_> yoyo an ok on what?
01:26:17 * sm thinks it'll take longer
01:27:21 <yoyo> ok i will go for hashkell
01:27:27 <yoyo> how should i learn?
01:27:31 <yoyo> just from this site
01:27:38 <yoyo> ?
01:27:46 <yoyo> or from a differnt sourse
01:28:31 <Chousuke> the haskell wiki seems to have a good page on tutorials.
01:28:32 <sopvop> yoyo: since you have experience with java, I think http://www.learnyouahaskell.com/ is appropriate
01:28:54 <yoyo> i have just a bit
01:29:21 <yoyo> we learnd a year, and we got to a "while" loop
01:29:38 <yoyo> it was so slow
01:29:48 <yoyo> thats why i stoped learining it at school
01:29:58 <yoyo> but i will do my best
01:31:09 <yoyo> if it will be to hard for me, i will go for phitom
01:31:10 <sopvop> yoyo: Your country is counting on you!
01:31:50 <neutrino_> remember, python is like haskell, just a little bit worse
01:32:15 <startling> neutrino_: that's... not really a useful thing to say.
01:33:42 <neutrino_> you're right, i should have not said "a little bit"
01:34:15 <sopvop> PHP is a little bit worse than Hitler
01:34:36 <t7> a little bit?
01:34:40 <Jafet> Bad analogies are like leaky screwdrivers.
01:34:42 <neutrino_> i don't think the spectrum of worseness is still linear at those extreme values
01:35:01 <neutrino_> Jafet: i find car analogies work well in computer programming
01:35:49 <neutrino_> the IO monad is like the tyre, which separates the exacting machinery of the automobile from the rough terrain that might be encountered in the real world
01:36:11 <tharper> I would argue 'tis more like the "tire"
01:36:15 <sopvop> and Haskell is like a HumVee and python is like a Mini Cooper?
01:36:24 <neutrino_> if programming languages were like cars, haskell would be a kit car where you brew your own fuel from hops
01:36:56 <neutrino_> tharper: http://dictionary.reference.com/browse/tyre
01:37:00 <neutrino_> do you even english?
01:37:31 <t7> haskell would be a reliant robin
01:37:46 <merijn> neutrino_: tire is the US-ian variant, silly buggers
01:37:55 <mgsloan> No no, it would be a delorean
01:37:57 <merijn> t7: Did you see the reliant robin topgear episode?
01:38:01 <mgsloan> complete with flux capacitor ;)
01:38:13 <t7> i think i remember parts of it
01:38:22 <Peaker> Python's advantage over Haskell is that it's much easier to learn. They aim much lower than Haskell.   Haskell tries to be as concise as Python, while also proving much correctness to the compiler, and that requires more techniques and much more learning.
01:38:30 <sopvop> If I ever make drawing library, it will have "Colour" just for fun.
01:38:50 <neutrino_> merijn: i just found it funny that tharper stylized his sentence in old english and caught himself adhering blindly to an americanism.
01:38:53 <Chousuke> t7: falls over if you take too sharp turn?
01:38:56 <mgsloan> sopvop: that's already true of diagrams etc.  http://hackage.haskell.org/package/colour
01:38:58 <Chousuke> I think that's PHP
01:39:09 <Peaker> SPJ talked about type-safe string formatting at some place, GvR thought to himself "In Python that's just a for loop, silly Haskell!" and missed the point entirely
01:39:17 <t7> rolling is a feature
01:39:41 <Chousuke> I don't see haskell needing training wheel.
01:39:42 <Chousuke> s
01:39:46 <neutrino_> sopvop: it should
01:40:19 <sopvop> I wonder if it gets pull requests for fixing names
01:41:02 <neutrino_> no but i bet there's a usa fork on someone's harddrive
01:41:07 <neutrino_> probably in the valley
01:42:59 <Chousuke> Peaker: I think because of the type system, haskell requires more abstraction than python to achieve concise code.
01:43:12 <Chousuke> then again, because of the type system it's also capable of that abstraction
01:44:00 <sopvop> I hate python for my mistyping
01:44:03 <Peaker> Chousuke, it requires learning more to write the "same programs", except they're not exactly the same programs, they're programs that happen to include much more built-in proofs of their correctness, without writing more code (or very little more code, and sometimes less)
01:44:08 <Chousuke> the side-effect is that the programmer needs to learn all those abstractions :P
01:44:25 <t7> in python you dont even know you have an error until your program reaches that point
01:44:47 <Peaker> For small programs, where correctness is trivial to achieve anyway, Python is better to learn because you'll have to spend far less time learning and manage to write these programs
01:45:04 <Peaker> But scaling to large programs is not fun in Python
01:45:07 <Chousuke> I'm currently using python for a small web application
01:45:14 <Chousuke> it's fine for that purpose, and convenient
01:45:16 <sopvop> python - when bash is not enough
01:45:41 <Chousuke> the other option was java :P
01:46:12 <sopvop> Also, python is good for UI.with PySide or PyQt
01:46:18 <nyc> Programming in the large often wants module system features more than language features per se.
01:47:20 <Chousuke> automatic reloading of code is neat to have when doing web dev.
01:48:20 <wereHamster> how do I catch exceptions from read?
01:48:42 <wereHamster> or is there a function like read which returns Maybe instead of throwing an error?
01:50:08 <nyc> wereHamster: reads
01:50:28 <nyc> :t reads
01:50:30 <lambdabot> Read a => ReadS a
01:50:40 <nyc> :info ReadS
01:51:26 <fmap> wereHamster: ghc 7.6 has readMaybe and readEither in base
01:51:42 <wereHamster> ah, that's neat
01:51:42 <sopvop> ReadS :: String -> [(a, String)]
01:52:37 <wereHamster> fmap: I have 7.6.1 but no readMaybe
01:52:47 <shachaf> :m + Text.Read
01:54:38 <wereHamster> works beautifully, thanks
01:54:46 <sopvop> I'm surprised readMaybe and readEither appeared only in 4.6. How hard is it to get such simple changes, as adding readMaybe to base?
01:55:07 <shachaf> Someone proposes it on the list and people vote on it.
01:55:18 <wereHamster> if it's that easy, you can write it yourself, probably a one-liner
01:55:41 <neutrino_> no reason to pollute base
01:55:47 <neutrino_> you can roll your own modules
01:56:03 <sopvop> Thats not a pollution, it's a convenience.
01:56:04 <yoyo> my intent faled
01:56:09 <yoyo> i am here again
01:56:29 <yoyo> can you pease send me aging the link to where should i learn it?
01:56:44 <sopvop> Otherwise just remove Text.Read from base
01:59:21 * hackagebot cipher-rc4 0.1.0 - Fast RC4 cipher implementation  http://hackage.haskell.org/package/cipher-rc4-0.1.0 (VincentHanquez)
01:59:28 <yoyo> ?
01:59:39 <yoyo> i downlowed the haskell platform
01:59:39 <statusfailed> yoyo: learnyouahaskell.com
01:59:46 <yoyo> but i cant seems to find it
02:00:18 <yoyo> how can i open it
02:00:23 <yoyo> ?
02:00:35 <frontendloader> ghci in a command line to get the REPL open
02:00:56 <yoyo> in english now XD
02:01:03 <yoyo> plz
02:02:06 <quchen> run "ghci" in a command line.
02:02:26 <quchen> If you have installed the Platform, that is.
02:03:15 <yoyo> good i found it
02:03:21 <neutrino_> yoyo: well done
02:03:50 <yoyo> lol sorry for beain stuped lol
02:03:57 <yoyo> one more thing
02:04:08 <yoyo> i can see that when i type a commend it works
02:04:17 <yoyo> but, for do i write a "whole" program
02:04:21 * hackagebot cipher-rc4 0.1.1 - Fast RC4 cipher implementation  http://hackage.haskell.org/package/cipher-rc4-0.1.1 (VincentHanquez)
02:04:31 <yoyo> and one more thing, the site http://learnyouahaskell.com/ does not work
02:04:55 <quchen> "Does not work" isn't a very helpful error description.
02:05:03 <frontendloader> needs the www
02:05:13 <quchen> Nope, works like that
02:05:21 <neutrino_> yoyo: maybe you mistyped it.
02:05:30 <Peaker> neutrino_, it's not very easy to "roll your own modules" that are available everywhere. You need hackage upload rights or to inconveniently distribute thos emodules
02:05:50 <mroman> Can I declare an instance of a "class"?
02:05:52 <mroman> for example
02:05:53 <wereHamster> doesn't anyone who signs up have access to hackage?
02:06:06 <neutrino_> Peaker: i stumbled into that recently. i requested a hackage upload login last week and there wasn't an answer yet.. do you know if that's normal?
02:06:09 <yoyo> i went cntrol c control b
02:06:13 <mroman> given I have a class Binary a where high :: a -> Bool; low :: a -> Bool
02:06:13 <yoyo> http://learnyouahaskell.com/
02:06:16 <wereHamster> mroman: instance SomeClass YourType where...
02:06:19 <neutrino_> wereHamster: yes
02:06:26 <neutrino_> wereHamster: they're the same
02:06:41 <mroman> Now I could write a Num instance for all types that are an instance of Binary
02:06:47 <Peaker> neutrino_, also, you then need to import those modules for these trivial tiny one-liners.. so you just end up duplicating them everywhere or just writing worse code (e.g: using partial "read" than "readMaybe")
02:07:01 <mroman> "could" because I can't because I don't have a concrete type
02:07:19 <quchen> :info readMaybe
02:07:26 <quchen> @info readMaybe
02:07:26 <lambdabot> readMaybe
02:07:32 <neutrino_> what is partial read?
02:08:15 <mroman> instance (Binary a) => Num a
02:08:19 <mroman> I'd want that.
02:08:54 <Jafet> > read ":-)"
02:08:55 <lambdabot>   *Exception: Prelude.read: no parse
02:08:59 <mroman> hm.
02:09:00 <mroman> well.
02:09:02 <mroman> damn :(
02:09:23 * hackagebot ipprint 0.4.2 - Tiny helper for pretty-printing values in ghci console  http://hackage.haskell.org/package/ipprint-0.4.2 (GlebAlexeyev)
02:09:25 * hackagebot configuration 0.1.1 - Simple data type for application configuration.  http://hackage.haskell.org/package/configuration-0.1.1 (HiromiIshii)
02:10:37 <merijn> mroman: You can just write "instance Binary a => Num a where", but it'll probably conflict horribly and create all sorts of overlapping instances...
02:11:29 <startling> I've got a ReaderT x (MaybeT m) (Maybe a); how do I turn it into a ReaderT x (MaybeT m) a ?
02:12:28 <Peaker> @type mapReaderT
02:12:30 <lambdabot> (m a -> n b) -> ReaderT r m a -> ReaderT r n b
02:13:03 <startling> Peaker: I don't think that does what I want.
02:13:07 <Peaker> @type mapMaybeT
02:13:08 <lambdabot>     Not in scope: `mapMaybeT'
02:13:08 <lambdabot>     Perhaps you meant one of these:
02:13:08 <lambdabot>       `mapMaybe' (imported from Data.Maybe),
02:13:19 <Peaker> hmm.. that one is probably missing :) but if it existed, you could:
02:13:29 <Peaker> (mapReaderT . mapMaybeT) join
02:14:21 <Peaker> but since it doesn't, you can just do:  maybe mzero return  =<< act
02:14:28 <Peaker> @type maybe mzero return
02:14:29 <lambdabot> MonadPlus m => Maybe a -> m a
02:14:37 <startling> oh neat
02:14:42 <Peaker> @type (>>= maybe mzero return)
02:14:44 <lambdabot> MonadPlus m => m (Maybe b) -> m b
02:19:17 <wereHamster> mroman: can you elaborate what you're trying to do?
02:20:33 <t7> whats this called:   x * y = z  ->  z / x = y   ?
02:21:35 <niteria> t7: division?
02:21:51 <t7> no but the axiom or re-write rule
02:21:56 <hkBst> t7: (wrongful) deduction
02:22:10 <niteria> it's at least 2 rules
02:22:59 <niteria> depends on if you're in a group or abelian group
02:23:02 * ski would write it as `x * y = z  ->  x = z / y'
02:23:29 <niteria> bc in a group it's not necessarily true
02:24:05 <hkBst> t7: products have divisors? division is the inverse of multiplication?
02:24:08 <ski> t7 : if you squint, it looks like an adjunction
02:24:19 <niteria> and multiplying by inverse is prefered to division
02:24:54 <ski> `(* y)' is an after-inverse of `(/ y)'
02:25:32 <ski> hm, no, the other way around, before-inverse
02:26:32 <ski> (i.e. `(/ y) . (* y) = id')
02:28:21 <t7> not for integers
02:28:38 <t7> but my thing doesnt hold for ints either
02:29:44 <neutrino_> > reverse "lambda"
02:29:46 <lambdabot>   "adbmal"
02:29:54 <neutrino_> hmm.
02:29:57 <neutrino_> > reverse "lamda"
02:29:59 <lambdabot>   "admal"
02:30:07 <neutrino_> much better.
02:30:39 <ski> t7 : if you're talking about integral division, you may want `x * y =< z  <->  x =< z / y', at least when `y' is positive
02:31:47 <majoh> > reverse "naturrutan"
02:31:49 <lambdabot>   "naturrutan"
02:32:13 <ski> > onLetters reverse "Eva, can i stab bats in a cave?"
02:32:15 <t7> this 'starting with maths' course is so painful :(
02:32:15 <lambdabot>   "Eva, can i stab bats in a cave?"
02:32:52 <ski> t7 : .. why ?
02:33:09 <t7> i remember school problems being harder than these
02:33:38 <neutrino_> "find a number such that it equals its opposite."
02:33:45 * ski idly wonders whether majoh is aware of #haskell.se
02:33:48 <neutrino_> that's a question a third year maths student couldn't answer once
02:33:54 <hkBst> anyone got a good definition of when source code is malleable or fluid or viscous (or better terms than these)?
02:34:22 <neutrino_> hkBst: print the source code out, then put that in a blender.
02:34:36 <neutrino_> you control the viscosity by the time you leave the blender on.
02:34:36 <ski> .. perhaps when TIMTOWTDI ?
02:38:37 <t7> source code is fluid if it is webscale
02:38:44 <t7> written in node.js
02:39:22 * hackagebot safecopy 0.8.0 - Binary serialization with version control.  http://hackage.haskell.org/package/safecopy-0.8.0 (DavidHimmelstrup)
02:40:26 <t7> i very rarely say anything helpful... i am going to start now
02:43:02 <yoyo> toUpper 'a'
02:44:02 <Botje> *snrk* webscale
02:50:38 <quchen> yoyo: use > in front of code to make Lambdabot run it
02:50:41 <quchen> > toUpper 'a'
02:50:42 <lambdabot>   'A'
02:51:07 <sopvop> > map toUpper "web-scale"
02:51:08 <lambdabot>   "WEB-SCALE"
02:51:17 <yoyo> i love it
02:51:22 <yoyo> its so eazy to do stuff with it
02:51:25 <sopvop> lambdabot can make your logo bigger
02:51:41 <yoyo> indet of "for" look
02:51:44 <t7> can i do a naf solid colour background ?
02:51:47 <yoyo> you just right "ap"
02:51:50 <yoyo> its soo good lol
02:52:54 <yoyo> i still can understand how can you write a fool program with it (you can just write one line)
02:52:56 <yoyo> but ok XD
02:53:20 <quchen> You can write full programs. GHCi is just a small testing environment.
02:53:21 <t7> yoyo your program is one big expression now
02:53:30 <t7> no more statements
02:53:42 <yoyo> what do you mean?
02:54:02 <scientes> :source (/)
02:54:08 <yoyo> ok, so when i am done with this totrial here
02:54:17 <scientes> :src (/)
02:54:18 <yoyo> what do i do from there?
02:54:29 <Hafydd> @src (/)
02:54:29 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
02:54:44 <quchen> yoyo: Learn you a Haskell uses GHCi for the first chapters. You'll learn to write longer code and how to compile it later.
02:54:50 <scientes> @src (/)
02:54:50 <lambdabot> Source not found. The more you drive -- the dumber you get.
02:54:56 <scientes> @src (+)
02:54:56 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
02:55:22 <scientes> @src foldl
02:55:22 <lambdabot> foldl f z []     = z
02:55:22 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
02:57:04 <yoyo> can somone please exlpain to me step 22?
02:57:14 <yoyo> i dont understand the answer to the exercise
02:57:32 <yoyo> "Try to get the 'a' value from this value using pattern matching:  (10,"abc")"
02:57:42 <yoyo> and the answer is  ": let (_,(a:_)) = (10,"abc") in a"
02:57:43 <yoyo> why?
02:58:21 <yoyo> and dont understan what this did :(
02:58:28 <ski>   "abc"
02:58:28 <yoyo> *understand
02:58:32 <ski> is short for
02:58:39 <ski>   'a':'b':'c':[]
02:59:22 * hackagebot lifted-base 0.2.0.2 - lifted IO operations from the base library  http://hackage.haskell.org/package/lifted-base-0.2.0.2 (BasVanDijk)
02:59:31 <ski> > let (x,y) = (10,"abc") in replicate x y
02:59:32 <lambdabot>   ["abc","abc","abc","abc","abc","abc","abc","abc","abc","abc"]
02:59:44 <ski> > replicate 3 "oops"
02:59:45 <lambdabot>   ["oops","oops","oops"]
02:59:53 <ski> yoyo : do you understand that ?
03:00:27 <yoyo> yes
03:00:35 <yoyo> i understand that it is a short cut
03:01:04 <yoyo> but i still dont understand what did the question want me to do
03:01:13 <yoyo> and why is this the answer lol
03:01:46 <ski> > let x:y:rest = "abc" in rest ++ (y:y:x:x:rest)
03:01:48 <lambdabot>   "cbbaac"
03:02:04 <yoyo> ski?
03:02:26 <frontendloader> is there an unofficial standard editor for haskell? I've tried using a vim plugin and textmate but they both have problems with indentation which i sm yonly real concern.
03:02:32 <frontendloader> is my only*
03:02:39 <FireFly> vim works fine for me
03:02:46 <ski> yoyo : i think they probably wanted you to pratice with pattern-matching, and thinking about how the character  'a'  in the larger compound datum  (10,"abc")  can be accessed
03:02:50 <Nereid> vim works fine for me
03:02:51 <FireFly> Configure your editor better :P
03:03:09 <ski> in this case, the acces is "get the second element of the pair, which should be a list, then get the first element of that list"
03:03:14 <Ralith> emacs is very common, but if you can't configure vim right, well...
03:03:43 <hiptobecubic> It's not like configuring vim is easy
03:04:05 <yoyo> ski
03:04:18 <hiptobecubic> if you have more than two plugins then it becomes pretty annoying i think. Every stupid asshole thinks his plugin should have some random default bindings
03:04:23 <yoyo> sorry but what did they want me do to
03:04:33 <yoyo> why is it ":  (_,(a:_)) = (10,"abc")
03:04:53 <ski> let's say youit had been
03:04:57 <FireFly> hiptobecubic: I have about two plugins, and I rarely use them anyway
03:05:09 <yoyo> and not "a,(b,(c))= (10, "abc")
03:05:12 <ski>   (x,(y:z)) = (10,"abc")
03:05:16 <hiptobecubic> FireFly, that must be terrible :)
03:05:22 <hiptobecubic> There are so many great plugins.
03:05:23 <ski> then this would simplify to
03:05:25 <ski>   x = 10
03:05:30 <ski>   y:z = "abc"
03:05:31 <yoyo> yea
03:05:32 <yoyo> ok
03:05:35 <FireFly> Shrug. I like the vim builtins
03:05:36 <ski> and the latter simplifies to
03:05:38 <ski>   y = 'a'
03:05:42 <ski>   z = "bc"
03:05:45 <yoyo> ok
03:05:48 <yoyo> i got it
03:05:49 <yoyo> but why
03:05:55 <yoyo> : (_,(a:_))
03:05:56 <frontendloader> http://projects.haskell.org/haskellmode-vim/ I was using this
03:05:57 <yoyo> and not
03:05:58 <hiptobecubic> I really miss pattern matching when i'm in python and c
03:06:16 <Hafydd> Python has pattern-matching.
03:06:18 <yoyo> (a,(b,(c))
03:06:23 <ski> yoyo : so, `let (a,(b:(c))) = (10, "abc") in b' (not quite what you said, but perhaps what you meant) would have been fine, imo
03:06:23 <hiptobecubic> it's weak though
03:06:49 <yoyo> yea
03:06:53 <yoyo> thats what i ment
03:07:08 <yoyo> i just did not understand why is the a in the wong place
03:07:24 <ski> `_' can be used to emphasize that we don't care about some parts of matched thing
03:07:32 <yoyo> i know
03:07:33 <yoyo> i mean
03:07:34 <yoyo> why
03:07:47 <yoyo> t (_,(a:_))  and not :  (a,(_:_))
03:07:49 <ski> what do you mean, "a in the wong place" ?
03:07:51 <Hafydd> I don't think the parentheses add anything.
03:07:52 <ski> well
03:07:53 <yoyo> the a is in the secend playse
03:08:02 <ski> > let (a,(_:_)) = (10, "abc") in a
03:08:04 <lambdabot>   10
03:08:10 <ski> here `a' gets matched with `10'
03:08:16 <yoyo> hooo
03:08:23 <yoyo> they wanted me to match a with a?
03:08:31 <yoyo> now i got the question and the answer lol
03:08:33 <yoyo> so just
03:08:50 <ski> but they wanted you to extract the first element of (the list which is) the second component of the pair
03:09:05 <ski> i don't think the actual variable name you use would matter
03:09:15 <ski> > let (_,(banana:_)) = (10, "abc") in banana
03:09:16 <lambdabot>   'a'
03:09:18 <yoyo> let (_,a,_,__) = (10,"abc") in a
03:09:28 <ski> you forgot to prefix with `> '
03:09:37 <yoyo> let (_,'a',_,__) = (10,"abc") in a
03:09:44 <yoyo> like this?
03:10:00 <ski> no, like : > let (_,'a',_,__) = (10,"abc") in a
03:10:06 <ski> also, note that strings a lists, and lists are not tuples
03:10:07 <sipa> (10,"abc") is not a 4-tuple, it's a 2-tuple
03:10:11 <sipa> so you can't match on it
03:10:19 <ski> > let (_,'a',_,__) = (10,"abc") in a  -- type error
03:10:21 <lambdabot>   Couldn't match expected type `(t0, GHC.Types.Char, t1, t2)'
03:10:21 <lambdabot>              wi...
03:10:36 <sipa> the type of (10,"abc") is a tuple, where the first element is an integer, and the second is a list of characters
03:10:45 <ski> > let (_,[a,_,_]) = (10,"abc") in a
03:10:45 <sipa> (Int,[Char])
03:10:46 <lambdabot>   'a'
03:11:49 <yoyo> damn it
03:11:53 <yoyo> i cant get it lol
03:11:58 <yoyo> so
03:12:08 <yoyo> tuples cant be machet with intager
03:12:09 <yoyo> sooo
03:12:23 <yoyo> i have to make the "a" inside an tuples?
03:12:40 <ski> no, you can use any other variable name
03:12:41 <Hafydd> How long have you been speaking English for, yoyo?
03:12:58 <ski> > let (_,(_:yoyo)) = (10, "abc") in yoyo
03:13:00 <lambdabot>   "bc"
03:13:36 <yoyo> i talk english fine
03:13:49 <yoyo> i am just not good in writing (as you can se)
03:13:59 <ski> > let (chalk,cheese) = ("cheese","chalk") in chalk ++ " is tastier than " ++ cheese
03:14:01 <lambdabot>   "cheese is tastier than chalk"
03:14:09 <yoyo> lol nice
03:14:36 <yoyo>  let (_,('a',_,__)) = (10,"abc") in a
03:14:49 <startling> forgot >
03:14:50 <hiptobecubic> nope
03:14:57 <startling> > let (_,('a',_,__)) = (10,"abc") in a
03:14:59 <lambdabot>   Couldn't match expected type `(GHC.Types.Char, t0, t1)'
03:14:59 <lambdabot>              with a...
03:15:08 <hiptobecubic> "abc" is not a tuple of char
03:15:21 <yoyo>   > let (_,('a',_,__)) = (10,"abc") in a
03:15:29 <yoyo> > let (_,('a',_,__)) = (10,"abc") in a
03:15:31 <lambdabot>   Couldn't match expected type `(GHC.Types.Char, t0, t1)'
03:15:31 <lambdabot>              with a...
03:15:41 <ski> > let (_,['a',_,__]) = (10,"abc") in a  -- a list is not a tuple
03:15:43 <lambdabot>   a
03:15:59 <startling> yoyo, ('a', _, _) matches a tuple but "abc" is a list
03:16:02 <ski> > let (_,['a',_,__]) = (10,['a','b','c']) in a  -- a string is a list
03:16:03 <lambdabot>   a
03:16:03 <yoyo> > let (_,['a',_,__]) = (10,"abc") in a
03:16:05 <lambdabot>   a
03:16:07 <yoyo> okkkkk
03:16:09 <yoyo> nice
03:16:14 <ski> > ['a','b','c']
03:16:16 <lambdabot>   "abc"
03:16:18 <ski> > reverse ['a','b','c']
03:16:19 <hiptobecubic> :t "abc"
03:16:19 <lambdabot>   "cba"
03:16:20 <lambdabot> [Char]
03:16:32 <yoyo> ok
03:16:34 <yoyo> that is cool
03:16:49 <yoyo> so, the reason i ned to put it in a []
03:16:59 <yoyo> is beacuse abs is a list
03:17:13 <yoyo> while () means a tuple
03:17:13 <yoyo> yea?
03:17:17 <hiptobecubic> [] syntax lets you construct list literals, yes
03:17:22 <ski> yes,  "abc"  is  list
03:17:38 <ski> @type reverse
03:17:39 <lambdabot> [a] -> [a]
03:17:40 <yoyo> ok
03:17:41 <yoyo> cool
03:17:48 <yoyo> so now
03:17:49 <ski> `reverse' reverses lists
03:17:50 <yoyo> just to make sure
03:17:55 <yoyo> what is a tuple
03:17:59 <yoyo> yea i got the reverse
03:18:09 <hiptobecubic> > let c:b:a = "abc" in b:c:b:c:b:a
03:18:11 <lambdabot>   "bababc"
03:18:17 <yoyo> my problem with learining is that i dont terms like "tuple"
03:18:28 <yoyo> so i cant exactly understand the expnation :)
03:18:31 <hiptobecubic> ah
03:18:46 <yoyo> but i do get "map"
03:18:49 <yoyo> an reverse
03:18:51 <yoyo> and filter
03:18:56 <yoyo> so what is a tuple
03:18:58 <hiptobecubic> Well, in simple terms, a tuple has fixed length and the elements can be of different types
03:18:59 <yoyo> and what is a list
03:19:03 <ski> lists are for varying-length, where the elements are in some sense "of the same kind" or "treated similarly"
03:19:06 <theorbtwo> yoyo: A tuple is just the generic term for single, double, triple, etc.
03:19:33 <ski> (and therefore list elements in the same list have to have the same type)
03:19:59 <ski> while tuples are for fixed-length, the components can have different types, and are normally not "treated similarly"
03:20:08 <startling> yoyo: tuples look like (a, b) and (a, b, c); lists look like [a, b, c] or a : b : c : []
03:20:34 <yoyo> ok
03:20:39 <yoyo> list is like a "groop" in math
03:21:11 <startling> uhhhh not really
03:21:14 <yoyo> so yoy can add as much as you want
03:21:22 <yoyo> but have to be the same type
03:21:41 <yoyo> while tuples can have as manny stuff inside them, but you cant "add more"
03:21:52 <startling> yoyo: sounds right-ish
03:21:57 <yoyo> and beacuse of that they can be watever type i like
03:22:05 <yoyo> ok
03:22:18 <yoyo> right ish it 200% more then 10 sec ago lol
03:22:39 <startling> yoyo: right, and also (1, 2) and (1, 2, 3) are different types, but [1, 2] and [1, 2, 3] are the same type
03:23:10 <startling> yoyo: so the number of elements for tuples is defined in the type, but lists can be any length
03:23:37 <yoyo> umm i kind of get it
03:23:39 <yoyo> so
03:23:52 <yoyo> (yuyu, a) and (1,2) are the same
03:24:14 <yoyo> and [2] and [2,3] are the same
03:24:18 <startling> depends what the types of yuyu and a are.
03:24:47 <yoyo> but [2] and [a]  are differnt like and (1) and (1,2)
03:25:21 <ski> > foldr (\x -> flip $ \k -> ($ (k . (x :) . k))) ($ []) [a,b,c,d] id
03:25:24 <lambdabot>   [a,b,a,c,a,b,a,d,a,b,a,c,a,b,a]
03:25:30 <yoyo> what i said is right?
03:25:38 <yoyo> about the same and difference
03:25:55 <ski> > let a = 2 in [a]
03:25:56 <lambdabot>   [2]
03:25:59 <yoyo> i g2g
03:26:03 <yoyo> plz answer fast
03:26:08 <yoyo> i g2g in 30 sec
03:26:20 <ski> if `a' is a number, then `[a]' can be the same type as `[2]'
03:26:40 <ski> but `(1)' (which is short fot just `1') and `(1,2)' are different types
03:27:17 <ski> (unless you use number overloading to use a number literal as a tuple, but that's not common to want to do)
03:27:20 <sopvop> 23 seconds, ski is good
03:31:30 <scientes> @src Hashable
03:31:31 <lambdabot> Source not found. I feel much better now.
03:31:36 <scientes> @src Data.Hashable
03:31:36 <lambdabot> Source not found. :(
03:34:03 <ski> @where src
03:34:03 <lambdabot> The fixed database for the `src' lambdabot command is at <http://code.haskell.org/lambdabot/State/source>
04:28:28 <ocharles> is there any standard combinator for 'pass through monadic actions'? for example, I have an 'a', and I want something that is (a -> m b) -> a -> m a
04:29:01 <ocharles> namely I'm using parsec to do some validation, but the final output should just be the original input (assuming the parsec succeeds)
04:29:38 <merijn> ocharles: As in, run the argument and at the end just do "return" on the input to the initial action?
04:29:46 <ocharles> yea
04:29:55 <merijn> ocharles: I don't think it exists, as I have written it myself a few times as well
04:29:59 <sopvop> <*
04:30:13 <sopvop> if your monad is also applicative
04:30:22 <ocharles> hm, i'm not sure that's what I want
04:30:35 <ocharles> because i have '(a -> m b)', not 'm b'
04:31:29 <merijn> :t (<*)
04:31:30 <lambdabot> Applicative f => f a -> f b -> f a
04:31:43 <merijn> sopvop: Also, doesn't that discard the f b?
04:31:59 <ocharles> yea, that discards the rhs
04:32:44 <merijn> :t \act x -> act x >> return x
04:32:46 <lambdabot> Monad m => (b -> m a) -> b -> m b
04:33:38 <merijn> I think I ended up writing something like
04:34:04 <merijn> :t \f -> (>>) <$> f <*> return
04:34:06 <lambdabot> Monad m => (b -> m a) -> b -> m b
04:34:21 <ocharles> merijn: ok, i'll probably write my own too
04:35:21 <merijn> Also, isn't <* just const in disguise?
04:35:31 <fmap> no
04:35:41 <fmap> it runs both actions
04:35:58 <sopvop> afaik <* should evaluate rhs, but return lhs
04:36:08 <sopvop> otherwise it is useless
04:36:46 <merijn> Now I'm unsure
04:36:49 <merijn> (<*) = liftA2 const
04:37:18 <sopvop> @sec liftA2
04:37:18 <lambdabot> liftA2 f a b = f <$> a <*> b
04:38:23 <merijn> hmmm, then I'm unsure why that didn't end up working for me, or maybe I'm just misremembering
04:38:36 <hpc> sopvop: getLine <* getLine
04:38:41 <hpc> reads two lines, returns the first
04:39:05 <sopvop> but there are both side effects
04:39:10 <hpc> put another way, (*>) = (>>)
04:39:10 <sopvop> "reading lines"
04:39:13 <hpc> sopvop: exactly
04:39:22 <sopvop> Thats what I'm telling
04:39:31 <hpc> ah
04:39:46 <hpc> oh merijn has it wrong ;)
04:40:13 <quchen> hpc: That's a nice way of looking at *>. Both can be defined as liftX const, but thanks for showing me the obvious :-)
04:42:22 <fmap> > ((<*) (Just ()) Nothing, const (Just 1) Nothing)
04:42:23 <lambdabot>   (Nothing,Just 1)
04:55:09 <quchen> Is there a way of modifying the current log of a Writer? Something of the type (a -> b) -> Writer a c -> Writer b c?
04:55:50 <hpc> @hoogle (a -> b) -> Writer a c -> Writer b c
04:55:50 <lambdabot> Data.Graph.Inductive.Graph nmap :: DynGraph gr => (a -> c) -> gr a b -> gr c b
04:55:50 <lambdabot> Control.Arrow (^>>) :: Arrow a => (b -> c) -> a c d -> a b d
04:55:50 <lambdabot> Data.Graph.Inductive.Basic elfilter :: DynGraph gr => (b -> Bool) -> gr a b -> gr a b
04:55:57 <hpc> uh
04:56:00 <hpc> maybe :P
04:56:04 <quchen> Arrows, uuugh
04:56:19 <quchen> Censor doesn't change type :/
04:56:21 <quchen> :t censor
04:56:21 <hpc> quchen: if there is one, hoogle will find it
04:56:22 <lambdabot> MonadWriter w m => (w -> w) -> m a -> m a
04:56:45 <quchen> Can't ask Djinn either ;-)
04:57:19 <Botje> quchen: you wouldn't be able to >>= it.
04:58:10 <quchen> Botje: yeah, it would change the monad
05:02:39 <`ramses> :t (\f -> writer . (\(x,y) -> (f x, y)) . runWriter)
05:02:40 <lambdabot> MonadWriter w m => (t -> a) -> Writer w t -> m a
05:02:49 <fmap> quchen: there is mapWriter
05:03:30 <fmap> @ty mapWriter (second ?f)
05:03:32 <lambdabot> (?f::w -> w') => Writer w b -> Writer w' b
05:03:44 <`ramses> :t (\f -> writer . fmap f . runWriter)
05:03:45 <lambdabot> MonadWriter w m => (a1 -> w) -> Writer a1 a -> m a
05:04:15 <fmap> oops
05:04:20 <fmap> @ty \f -> mapWriter (second ?f)
05:04:22 <lambdabot> (?f::w -> w') => t -> Writer w b -> Writer w' b
05:04:54 <fmap> well, you get the idea
05:05:05 <merijn> :t mapWriter
05:05:06 <lambdabot> ((a, w) -> (b, w')) -> Writer w a -> Writer w' b
05:05:17 <`ramses> @src mapWriter
05:05:17 <lambdabot> Source not found. My pet ferret can type better than you!
05:06:48 <romildo> Is it possible to obtain the trace of function calls when a program finishes with an error?
05:07:41 <Sedols> alrite
05:08:01 <hpc> romildo: you would have to track that stuff yourself
05:08:47 <Rogach> Hello! How can I get number of milliseconds from Data.Time.Clock.NominalDiffTime?
05:09:05 <hpc> romildo: (>>=) is a function, so even straight-line IO actions would quickly fill up your "call stack"
05:10:23 <`ramses> hpc: you say that any stack trace functionality would give completely unwielding output anyway?
05:10:54 <merijn> `ramses: It would also be very confusing as in a lazy language the stack trace might be completely unrelated to the part of the program that is misbehaving
05:12:00 <`ramses> you mean because the evalutation of the expression that errors out can happen anywhere where it is evaluated?
05:12:21 <`ramses> that might make it difficult indeed..
05:12:23 <merijn> `ramses: Yes
05:12:58 <`ramses> so to have good output, the runtime should remember where thunks came from
05:13:02 <merijn> `ramses: Which I think is the main reason there's no stack trace for haskell, once you start thinking of what it'd mean it quickly becomes clear it'll probably be rather useless and thus not really worth the effort
05:13:41 <merijn> OTOH, if all your functions are total anyway then crashing shouldn't be possible anyway
05:14:10 <`ramses> in an ideal world... the prelude contains a lot of partial functions already
05:14:26 <Saizan> i thought marlow managed to build relevant stack traces
05:14:32 <hpaste> nunquam pasted “distorted message problem” at http://hpaste.org/78901
05:14:47 <merijn> `ramses: Yes, but you can avoid most of them rather easily
05:14:49 <`ramses> but wouldn't it be possible to retain more info at runtime in a sort of debugging mode to allow for useful stack traces?
05:14:50 <Saizan> only available with profiling libs though
05:14:53 <alocacoc> Good afternoon :)
05:15:08 <`ramses> of course it would kill performance
05:15:11 <alocacoc> Anyone got any tips on this problem: http://hpaste.org/78901
05:15:11 <Saizan> `ramses: yeah, that's what i'm talking about
05:15:35 <alocacoc> I am trying to implement it in haskell
05:15:41 <`ramses> Saizan: interesting, I'll have a look
05:15:53 <alocacoc> I understand how to solve it in a "human way", but don't have a clue how to implement it
05:16:51 <`ramses> alocacoc: haha, I guess we're in the same class :)
05:17:09 <alocacoc> hah =)
05:17:35 <alocacoc> any idea yet :)?
05:17:49 <`ramses> I solved it yesterday..
05:17:53 <hpc> `ramses: in any event, you should be thinking about equational reasoning
05:18:02 <alocacoc> nice.. :p
05:18:21 <hpc> it'll let you solve much harder problems than any runtime debugging could
05:19:02 <`ramses> hpc: yes, but if a small error anywhere suddenly causes some exception being thrown from a lib function, it's not always obvious where to start looking
05:19:11 <`ramses> not that that happens a lot :)
05:19:25 <merijn> alocacoc: Well, think in terms of problem decomposition. How would you solve it for two lists containing only a single character?
05:19:39 <`ramses> hpc: certainly not if the problem lies in the lib code...
05:19:42 <Saizan> https://plus.google.com/107890464054636586545/posts/EPnW2WvDrWt <- anyhow, try +RTS -xc next time
05:19:47 <hpc> `ramses: it'll always be in the part of the code you understand least ;)
05:19:49 <merijn> `ramses: Most haskell libraries won't throw exceptions
05:19:53 <alocacoc> mmm
05:20:14 <`ramses> merijn: yeah, but I guess most code wont contain bugs either :)
05:20:31 <alocacoc> thats pretty trivial merijn, if i would get ["a","b"] the original message must be "ba" or "ab"
05:21:33 <hpc> Saizan: oh wow, that's amazing
05:21:36 <merijn> alocacoc: Yes, but how would you write the function that produces those outputs?
05:24:13 <hpc> here's another way
05:24:29 <hpc> write a function that takes a constraint and a string and returns True if that constraint is met
05:24:55 <hpc> then generate all strings and filter by every constraint
05:25:07 <hpc> (of a certain length, ofc)
05:25:47 <alocacoc> talking to me I guess hpc? :) I also was thinking about such a solution
05:26:32 <alocacoc> I could generate a list of constraints and apply all of them on all permutations of strings, although I think this won't be efficient
05:26:32 <hpc> downside is it's exponential with the number of characters in the original message
05:26:33 <peteriserins> alocacoc: you're faced with a topological sorting problem
05:26:49 <alocacoc> yes
05:27:15 <peteriserins> alocacoc: so you either do a dfs or pluck out leaves :)
05:27:18 <Jafet> Fortunately, you can use topological sorting to solve topological sorting problems.
05:27:19 <alocacoc> should I work with indices then maybe? if their "place" is the only thing that mathers
05:27:36 <alocacoc> *matters
05:28:45 <alocacoc> are you suggesting I use this: http://hackage.haskell.org/packages/archive/containers/latest/doc/html/Data-Graph.html#v:topSort Jafet?
05:29:05 <hpc> oh i see what Jafet is saying
05:29:06 <alocacoc> and I present the problem as a tree/graph
05:29:15 <alocacoc> ?
05:29:17 <hpc> turn the constraints into a tree and present every traversal of that tree
05:29:21 <hpc> ?
05:29:29 <saml> hey, how do I parse text file and build binary tree?
05:29:39 <saml> lines, words
05:29:41 <Jafet> You might want all topological sorts, not a topological sort.
05:29:57 <peteriserins> alocacoc: yes a list "abc" is just saying that there are edges ab bc
05:29:58 <saml> buildTree :: [[Int]] -> Tree Int    ?
05:30:30 <hpc> @let buildTree :: [[Int]] -> Tree Int; buildTree = undefined
05:30:32 <lambdabot>  Defined.
05:30:41 <saml> i mean, binary tree.  [[1], [2,3], [4,5,6], ...]  turn that into data Tree a = Leaf a | Tree a (Tree a) (Tree a)
05:30:43 <hpc> er
05:30:57 <alocacoc> hmm
05:31:08 <hpc> saml: so your input string is "[[1], [...
05:31:09 <hpc> ?
05:31:15 <hpc> :t buildTree . read
05:31:17 <lambdabot> String -> Tree Int
05:31:23 <saml> no, let's say i parsed and built the list of list of ints
05:31:37 <hpc> :t map words . lines
05:31:38 <lambdabot> String -> [[String]]
05:32:00 <saml> yah i have that so far.
05:32:37 <saml> buildTree (heads:tails) = Tree ... buildTree tails
05:33:43 <saml> oh i should think simpler and map a list over
05:34:41 <alocacoc> peteriserins I could present ["acd","bce"] then as:
05:34:42 <alocacoc> a b
05:34:42 <alocacoc> |/
05:34:42 <alocacoc> c
05:34:42 <alocacoc> |\
05:34:42 <alocacoc> d e
05:35:09 <peteriserins> alocacoc: exactly, but directed
05:35:23 <alocacoc> ok
05:35:23 <peteriserins> alocacoc: but yeah if you're directing vertically, that's exactly it
05:35:54 <peteriserins> alocacoc: you can take either top sort algorithm, and examine where a choice is made, and just explore all alternatives
05:36:10 <peteriserins> alocacoc: simplest probably is to pick a leaf and place it at the beginning of the string
05:36:24 <peteriserins> alocacoc: and then keep doing that until you've exhausted the graph
05:36:31 <alocacoc> ah ok
05:36:40 <alocacoc> like starting at the bottom of tree
05:36:46 <alocacoc> and keep prepending the string
05:36:49 <alocacoc> untill i'm at the top
05:36:50 <alocacoc> ?
05:36:57 <hiptobecubic> I keep reading about all of these proposals to fix the namespace issue with record accessors, but it seems like nothing is going anywhere with it
05:37:00 <alocacoc> if I direct the tree vertically
05:37:11 <peteriserins> alocacoc: well it's not a tree, it'll be a DAG
05:37:26 <peteriserins> alocacoc: or a directed graph without cycles
05:37:32 <alocacoc> Directed Assymetric Graph :p?
05:37:34 <alocacoc> ah k
05:38:03 <xming> does this error says anyting to you guys? http://pastebin.com/UCx1mFWH BTW, hi I am new here o/
05:38:21 <peteriserins> alocacoc: I would really recommend reading the section on topological sorting in "Introduction to Algorithms"
05:38:35 <alocacoc> got any link?
05:38:36 <alocacoc> :)
05:39:24 <alocacoc> found it i think, thanks
05:43:37 <saml> \f x -> f x       is there shorter version of that?
05:43:42 <saml> apply?
05:43:56 <saml> let me hoogle it coz i'm good
05:43:58 <alpounet> it's ($)
05:44:29 <latermus1> xming: it looks like you are missing some dependencies
05:44:33 <alpounet> saml, or id
05:44:49 <saml> alpounet, thanks
05:45:21 <fmap> @pl \f x -> f x
05:45:21 <lambdabot> id
05:46:01 <xming> latermus1: shouldn't cabal(-dev) solved that? Anyway I am doing cabal-dev install --upgrade-dependencies should that help?
05:47:36 <alocacoc> any tips on preseting a graph in haskell?
05:48:00 <alocacoc> should I use the predifined Data.Graph package or build my own data structure?
05:48:03 <fmap> xming: according to hackage simple-sendfile-0.2.9 doesn't build, try simple-sendfile-0.2.8
05:51:04 <dmwit> ?hackage fgl is pretty complete, alocacoc
05:51:04 <lambdabot> http://hackage.haskell.org/package/fgl is pretty complete, alocacoc
05:51:08 <xming> fmap: okay thanks, 0.2.8 builds w/o issues
05:52:43 <hkBst> the plasticity of source code is the amount of efforrt necessary to ....
05:52:45 <xming> I now see that there's a link to "build failure"
05:53:07 <alocacoc> hey peteriserins , why should my graph be without cycles?
05:53:11 <alocacoc> a-b
05:53:11 <alocacoc> |/
05:53:11 <alocacoc> c
05:53:11 <alocacoc> |\
05:53:11 <alocacoc> d-e
05:53:30 <peteriserins> alocacoc: because otherwise there are no strings that work
05:53:39 <alocacoc> all edges are directed downwards except a-b and d-e
05:53:52 <alocacoc> cause you know nothing about the order of a and b
05:53:57 <alocacoc> it could be "ab", or "ba"
05:54:04 <peteriserins> alocacoc: then there is no edge between them
05:54:20 <alocacoc> mmm ok...
05:54:23 <peteriserins> alocacoc: you only place edges where there are restrictions
05:54:51 <saml> > map (\x -> map read x) . map words . lines $ "1 2\n3 4" :: [[Int]]
05:54:53 <lambdabot>   [[1,2],[3,4]]
05:54:58 <saml> is there a better way to write that?
05:57:10 <merijn> alocacoc: I would say the simplest (but inefficient) approach is for each list, select the first element followed by recursive call to your function with the same list (except, remove the picked character)
05:58:43 <merijn> alocacoc: i.e. to give the simplified two list case "foo (x:xs) (y:ys) = map (x:) (foo xs (y:ys)) ++ map (y:) (foo (x:xs) ys)"
05:59:27 * hackagebot AbortT-transformers 1.0.1 - A monad and monadic transformer providing "abort" functionality  http://hackage.haskell.org/package/AbortT-transformers-1.0.1 (GregoryCrosswhite)
06:00:09 <alocacoc> hmmm
06:01:34 <merijn> alocacoc: Mind you, that code might not actually be 100% correct, but I hope it illustrates the basic idea
06:09:26 * hackagebot AbortT-monadstf 1.0 - Monads-tf instances for the AbortT monad transformer.  http://hackage.haskell.org/package/AbortT-monadstf-1.0 (GregoryCrosswhite)
06:09:27 <cloudhead> hey, I'm trying to find the 'catch' function for IO errors, but it's not where I'm told it is, where do I find it?
06:09:52 <quchen> @hoogle catch
06:09:52 <lambdabot> Prelude catch :: IO a -> (IOError -> IO a) -> IO a
06:09:52 <lambdabot> System.IO.Error catch :: IO a -> (IOError -> IO a) -> IO a
06:09:52 <lambdabot> Control.OldException catch :: IO a -> (Exception -> IO a) -> IO a
06:10:13 <merijn> cloudhead: catch has been removed from Prelude in more recent GHC versions (I think 7.6?)
06:10:23 <cloudhead> merijn: ah.
06:10:36 <merijn> Control.Exception is that place you want for future compatibility
06:10:41 <merijn> s/that/the
06:10:50 <quchen> merijn: Good to know. Any reason given? I heard that Prelude.catch differed from Control.Exception.catch
06:10:52 <cloudhead> merijn: but that's for all kinds of exceptions?
06:11:24 <cloudhead> merijn: problem is it's telling me I need to type the exception
06:11:52 <cloudhead> I'm trying to catch a closeFd:     catch closeFd (\_ -> return ())
06:11:53 <Clint> that's not so much a problem as an annoyance
06:12:00 <merijn> cloudhead: Yeah, but type inference can usually solve that for you if you inspect the exception type
06:12:07 <cloudhead> Clint: yes, except I'm not sure how to do it :D
06:12:27 <Clint> use an explicit type
06:12:55 <Clint> like IOException if that's what you really want
06:13:00 <quchen> cloudhead: The most generic Exception type is SomeException. Just catch that one in case you don't want to be more specific.
06:13:05 <cloudhead> Clint: yes, but how do I specify that?
06:13:06 <merijn> cloudhead: You can specify a type in your lambda "(\(ex :: IOException) -> return ())"
06:13:14 <cloudhead> ahh
06:13:32 <cloudhead> ok, that should work
06:13:47 <merijn> cloudhead: If you inspect the exception argument the type inference usually determines the right type for you
06:14:12 <cloudhead> merijn: makes sense, in this case it doesn't really matter if it throws an exception, so I'd rather keep it simple
06:14:31 <merijn> quchen: The new exception uses Typeable, which didn't really exist back when catch was first written, I think
06:14:56 <cloudhead> merijn: hmm, I'm getting Illegal type signature
06:16:12 <merijn> cloudhead: Yeah, you could also use "SomeException" which is the most generic exception type.
06:16:28 <merijn> cloudhead: Ah, seems you need ScopedTypeVariables enabled for this
06:16:37 <cloudhead> merijn: yea, that's what it's telling me
06:16:44 <cloudhead> merijn: is that a common thing?
06:17:07 <Clint> you can get around it by typing the entire expression
06:17:12 <merijn> cloudhead: Another option is to define "dummyHandler :: IOException -> IO (); dummyHandler _ = return ()"
06:17:14 <mm_freak> any chance to ask for an additional module in lambdabot?
06:17:48 <Clint> you can still do that with the lambda
06:17:50 <merijn> cloudhead: ScopedTypeVariables is one of the most sensible extensions in existence :)
06:18:22 <merijn> Clint: Yeah, but I couldn't remember the proper way to type it and I didn't want to give a non-compiling example (I failed :p)
06:18:28 <cloudhead> merijn: ok great : )
06:18:33 <Clint> heh
06:18:45 <bartavelle> oh god I never heard of ScopedTypeVariables ... it is super useful
06:19:15 <cloudhead> Clint: (\_ -> return () :: IOException -> IO ())   gives me a type error
06:19:28 <cloudhead> is it incorrect?
06:19:59 <merijn> cloudhead: ScopedTypeVariables basically means that when you use type variables in local (i.e. let/where) functions definitions or type signatures then any matches with the type variables of the top level function will make them the same
06:20:14 <cloudhead> merijn: ah that's really nice
06:21:17 <merijn> "foo :: a -> a; foo x = let bar :: a -> a in bar x" <- here the a's in the signature of bar are different from the a's of foo, this actually makes it impossible to write down type signatures for some local functions (I don't know an example of the top of my head)
06:21:38 <merijn> With ScopedTypeVariables the a's in the signature of bar will be the same as those in the signature of foo
06:21:58 <merijn> bartavelle: Word.
06:22:27 <cloudhead> gotcha
06:22:38 <quchen> merijn: Scoping works only with explicit foralls though, right?
06:22:45 <cloudhead> thanks merijn & Clint !
06:23:35 <merijn> quchen: I don't think so?
06:24:56 <quchen> merijn: I always thought so because the Haskell Wiki uses them.
06:25:03 <quchen> Maybe I should've asked the GHC manual instead
06:25:45 <merijn> quchen: Ah, you're right. It requires an explicit forall according to the GHC manual
06:25:49 <quchen> http://www.haskell.org/ghc/docs/latest/html/users_guide/other-type-extensions.html#scoped-type-variables
06:25:55 <quchen> Yeah, I'm about 90% sure
06:26:00 <quchen> It's not too explicit about it
06:26:54 <quchen> "The type variables bound by a forall scope ..." <== It doesn't say "explicit" in this sentence anymroe, only in the first one. Oh well, I'll just keep writing foralls :-)
06:27:20 <merijn> quchen: The examples list one without explicit forall and says that's wrong
06:31:12 <quchen> Ah, right.
06:31:28 <quchen> Autosuggestive reading got me again
06:32:33 <quchen> merijn: Why is mkpair2 illegal though?
06:32:47 <quchen> Ah wait, nevermind
06:41:37 <patricklong> Hi. Can anyone recommend a good vector math library? I'm just talking simple 2d and 3d vectors and basic ops on them. Having trouble googling as i tend to find vector-as-in-collection libraries, or big BLAS stuff.
06:42:41 <donri> vector, repa?
06:43:30 <parcs`> linear
06:43:32 <patricklong> donri: that's exactly what i'm not looking for - Data.Array.Repa.Repr.Vector is a library for vectors, as in arrays, lists, collections
06:44:15 <peterjan> theezakje heb je een minuutje?
06:44:36 <quchen> So what *are* you looking for? Something that defines a "+" operation on some vector and not much more?
06:44:50 <peterjan> digihash have a minute?
06:45:11 <patricklong> quchen: yeah, pretty much, but without going into a full BLAS implementation
06:46:20 <peterjan> any KU Leuven students online?
06:46:25 <peterjan> or maybe teachers? :p
06:46:42 <quchen> Well, if all you need is 3D vectors and simple operations, why not code it yourself? It sounds like you're looking for a didactic library rather than a complex one
06:48:02 <blueonyx> hi, how can i static link against network?
06:49:03 <blueonyx> oh just warnings
06:49:12 <blueonyx> but i get /usr/bin/ld: cannot find -llapack
06:52:13 <peterjan> anyone has an algorithm for this: function [[1,2,3],[5,2,3,4,0],[1,5,8,4]] needs to result in [1,5,2,3,8,4,0]
06:52:27 <dmwit> blueonyx: Have you installed lapack (possibly the -dev version is needed)?
06:52:44 <peterjan> the list is a list of messages and you need to reconstruct the original message
06:52:57 <peterjan> any help would me very very much appreciated i've been at it for 7 hours now
06:53:02 <peterjan> would be*
06:53:41 <dmwit> shortest common supersequence?
06:53:43 <alocacoc> hah idem peterhil
06:53:44 <quchen> peterjan: Looks like you want to sort topologically http://en.wikipedia.org/wiki/Topological_sort
06:53:50 <alocacoc> peterjan :(
06:54:22 <alocacoc> I think we have to represent the problem as a graph
06:54:29 <alocacoc> and then perform topsort on the DAG
06:54:35 <dmwit> quchen: That seems like it wouldn't work very well if some messages are duplicated.
06:54:51 <dmwit> alocacoc: @you, too
06:56:43 <mysticc> How to make a func poitfree here?
06:57:27 <Phlogistique> @pf \a b c d -> d c b a
06:57:27 <lambdabot> Maybe you meant: bf pl
06:57:32 <Phlogistique> @pl \a b c d -> d c b a
06:57:32 <lambdabot> flip (flip . (flip .) . flip (flip . flip id))
06:57:38 <Phlogistique> mysticc: ^
06:57:42 <dmwit> ?tell patricklong You might like the vector-space package. Try ?hackage vector-space
06:57:43 <lambdabot> Consider it noted.
06:58:22 <mysticc> @pl \a b -> a && even b
06:58:22 <lambdabot> (. even) . (&&)
06:59:39 <quchen> @unpf (. even) . (&&)
06:59:39 <lambdabot> (\ d g -> d && (even g))
06:59:50 <blueonyx> dmwit: can't find a dev package for archlinux :/
06:59:50 <Clint> cloudhead: parens
07:00:26 <bgamari> PatrickRobotham, Did you get an answer?
07:00:28 <bgamari> oops, oh well
07:00:38 <PatrickRobotham> bgamari: Sorry?
07:00:39 <dmwit> blueonyx: Arch doesn't separate -dev and non-dev versions of packages, so if you have the right package installed, you have the -dev stuff, too.
07:00:50 <dmwit> PatrickRobotham: mis-nick for patricklong, I suspect
07:00:54 <bgamari> PatrickRobotham, Sorry, wrong patrick
07:00:55 <PatrickRobotham> Ah.
07:01:02 <PatrickRobotham> No problem.
07:01:07 <dmwit> bgamari: see my ?tell above =)
07:01:23 <blueonyx> dmwit: still /usr/bin/ld: cannot find -llapack
07:01:29 <bgamari> dmwit, I was thinking of either vector-space or linear
07:01:46 <blueonyx> dmwit: using -optl-static though
07:02:27 <dmwit> blueonyx: Well, being pedantic: you still haven't said whether you have lapack installed... =P
07:02:48 <blueonyx> i have
07:02:55 <dmwit> okay
07:02:55 <blueonyx> works without -optl-static
07:03:13 <dmwit> What does locate liblapack.a say?
07:03:47 <blueonyx> nothing
07:04:05 <dmwit> You don't have a static library for lapack, then.
07:04:11 <blueonyx> xD
07:04:18 <dmwit> Build it yourself, and maybe complain to the lapack packager for Arch.
07:04:34 <blueonyx> kthx
07:04:41 <dmwit> It's also possible that you have it, but it was created since the last updatedb.
07:04:49 <dmwit> Did you just recently install lapack?
07:05:00 <blueonyx> i did updatedb
07:05:06 <blueonyx> and no
07:05:09 * dmwit nods
07:06:11 <blueonyx> thanks anyhow
07:14:28 * hackagebot toolshed 0.14.0.0 - Utilities used by other packages.  http://hackage.haskell.org/package/toolshed-0.14.0.0 (AlistairWard)
07:14:30 * hackagebot factory 0.2.0.5 - Rational arithmetic in an irrational world.  http://hackage.haskell.org/package/factory-0.2.0.5 (AlistairWard)
07:14:32 * hackagebot squeeze 1.0.2.4 - A file-packing application.  http://hackage.haskell.org/package/squeeze-1.0.2.4 (AlistairWard)
07:19:29 * hackagebot regexdot 0.11.1.0 - A polymorphic, POSIX, extended regex-engine.  http://hackage.haskell.org/package/regexdot-0.11.1.0 (AlistairWard)
07:24:31 * hackagebot regexchar 0.9.0.10 - A POSIX, extended regex-engine.  http://hackage.haskell.org/package/regexchar-0.9.0.10 (AlistairWard)
07:24:33 * hackagebot tie-knot 0.1 - "Ties the knot" on a given set of structures that reference each other by  keys.  http://hackage.haskell.org/package/tie-knot-0.1 (PetrPudlak)
07:28:56 <Aune> I want to try to solve a sudoku by defining all possible basis and trying to fit to these. What is the best way to do this? My basis in this case is: basis :: [(Int,Int)] where no pair shares a coordinate and there is exactly one pair in each subsquare of the sudoku grid.
07:29:15 <Aune> Can this be done with a list comprehension?
07:30:31 <peterjan> ramses: online?
07:40:42 <mapf> is it possible to concat two promoted to type level string literals?
07:40:55 <`nand`> not to my knowledge
07:41:00 <`nand`> 7.6 literals are very inflexible
07:41:13 <`nand`> as in, the only operation they have is (~) :: Nat -> Nat -> Constraint
07:41:15 <`nand`> and Symbol
07:46:46 <neutrino> will we at some point have promotion of functions?
07:47:19 <`nand`> we almost do
07:47:20 <`nand`> but I hope
07:47:22 <`nand`> actually
07:47:32 <`nand`> the proper question is “will we at some point have dependent types”?
07:47:51 <`nand`> Why promote all functions to the type level if you can just use regular values at the type level instead? :P
07:48:06 <`nand`> but either way; you can auto-promote some function definitions using the ‘singletons’ library and lots of TH
07:48:10 <`nand`> but it's currently very limited
07:48:26 <`nand`> eg. you can't pattern match very effectively; at least not without http://hackage.haskell.org/trac/ghc/wiki/NewAxioms
07:48:45 <`nand`> type families also aren't lazily evaluated
07:48:49 <`nand`> so you have to work with that in mind
07:49:01 <`nand`> many other syntax forms are invalid; eg let..in
07:52:05 <hpaste> “Ertugrul Söylemez” pasted “Lambda calculus with 'letrec'” at http://hpaste.org/78902
07:52:30 <mm_freak> edwardk: would you say that my implementation of nfExpr for Let is sensible?
07:52:54 <mm_freak> Let is for multi-let with recursion
07:53:37 <mm_freak> just like in haskell
07:54:24 <edwardk> mm_freak: putting out fires for a minute. then i'll look ;)
07:54:42 <mm_freak> sure =)
07:55:11 <mm_freak> the main difference is that i'm using Data.Vector instead of lists and that i haven't seen your NF code =)
08:02:48 <`ramses> peterjan: now I am (kind of)
08:03:20 <jerojasro> is it possible to have a key, value data structure with O(1) access, without using arrays?
08:03:36 <peterjan> could you give a hint how you solved the haskell task in under 4 hours? :p
08:03:46 <peterjan> i'm looking into Data.Graph am I way off?
08:03:58 <peterjan> I just don't understand their algorithm
08:04:09 <peterjan> it bothers me to bits :
08:04:11 <peterjan> :p*
08:04:30 * hackagebot uuagc-cabal 1.0.4.0 - Cabal plugin for the Universiteit Utrecht Attribute Grammar System  http://hackage.haskell.org/package/uuagc-cabal-1.0.4.0 (JeroenBransen)
08:04:32 * hackagebot uuagc 0.9.42.2 - Attribute Grammar System of Universiteit Utrecht  http://hackage.haskell.org/package/uuagc-0.9.42.2 (JeroenBransen)
08:04:34 <bitonic> jerojasro: no.  you could argue that it’s impossible to have O(1) operations, period
08:04:58 <peterjan> `ramses: saw my guestion?
08:05:23 <jerojasro> bitonic: any links to back that up? That's my gut feeling, too, but I'd like something more certain ...
08:06:12 <`ramses> I didn't use the topological sorting approach, I just generate a list of all possible first characters and take the smallest, keep doing so to generate the output list
08:06:20 <`ramses> it's probably O(n^2)
08:06:45 <peterjan> but how the hell do you know if it's a possible first
08:07:13 <`ramses> think about it, that's not too hard to decide
08:07:30 <peterjan> :p now you're just making fun of me
08:07:33 <`ramses> try it for some small examples
08:07:44 <bitonic> jerojasro: I’m afraid I can’t back it up right now (I’m in a lecture and my knowledge is quite shady on that) but others probably will
08:07:54 <`ramses> see whether you can decide by reasoning which ones could appear as the start
08:07:56 <peterjan> lol think i didn't do that already? for like 5 hours straight
08:08:15 <peterjan> the thing is i have my own algorithm and it works
08:08:19 <peterjan> but not for the days problem
08:08:36 <`ramses> ah, then your functions probably aren't polymorphic enough
08:08:48 <peterjan> no my algorithm 's just wrong
08:08:50 <peterjan> it sucks
08:08:57 <peterjan> i know where my problem is i just don't get his hint
08:09:03 <crdueck> Control.Lens's provides (over both) :: (a -> b) -> (a, a) -> (b, b). is there a combinator for Foo a => (a -> b) -> (a, a) -> (b, b)
08:09:03 <peterjan> he gives us the algorithm..
08:09:11 <peterjan> and i just don't get it :
08:09:12 <peterjan> :p*
08:09:14 <mm_freak> jerojasro: do you need to change or is it a create-once-read-only data structure?
08:09:26 <`ramses> huh? so it works for both ints and chars but not for the custom data type?
08:09:30 <peterjan> jup
08:09:35 <peterjan> but its a crazy way of doing it
08:09:43 <peterjan> it's not really that crazy
08:09:55 <jerojasro> mm_freak: create-once-read-only, please :D
08:10:03 <peterjan> it works well even but not for the days example + i'm sure the algorithm isn't foolproof
08:10:22 <peterjan> ok just tell me this then
08:10:28 <peterjan> if you try and collect your possible first
08:10:41 <peterjan> do you loop each and every char or int
08:10:44 <mm_freak> jerojasro: if you don't mind very fast O(log n) lookup you can use my quickset library…  it's faster than Map/HashMap, but allows query only
08:10:47 <mm_freak> @hackage quickset
08:10:47 <lambdabot> http://hackage.haskell.org/package/quickset
08:10:51 <`ramses> no :)
08:11:06 <peterjan> lol ok :)
08:11:13 <peterjan> i was hoping you would say yes :p
08:11:21 <`ramses> well, no, sorry, in fact I do
08:11:54 <bartavelle> mm_freak, is there a metric about memory footprint reduction from Set -> QuickSet ?
08:11:55 <`ramses> you can generate a small list of candidates, but you have to compare them with all others to decide whether they're eligible
08:12:08 <jerojasro> mm_freak: my question is more theoretical. is there any structure with that property? (without constraining the domain of the keys)
08:12:30 <mm_freak> bartavelle: QuickSet and QuickMap use a thunk and a value per element…  in particular the tree structure is gone from memory
08:12:32 <peterjan> pf damn ok
08:12:41 <peterjan> guess i just dont see it then :p
08:12:46 <peterjan> i'll keep trying
08:12:47 <bartavelle> mm_freak, ah interesting !
08:12:51 <bartavelle> will test that right now
08:12:52 <shapr> jewel: Hey, still writing Haskell?
08:12:54 <mm_freak> jerojasro: many lookup-only structures are that way…  a hash table for example
08:12:57 * shapr yawns
08:12:59 <peterjan> but man, it sucks i've been at for 9 hours now i think
08:13:03 <`ramses> you know that all lists are in the correct order, they just miss some elements
08:13:06 <jewel> no, just lurking
08:13:14 <shapr> jewel: Ah ok
08:13:17 <mm_freak> jerojasro: by "lookup only" i mean that insert can be an expensive operation
08:13:18 <jewel> :-)
08:13:29 <`ramses> so for sure, the first element of the original stream can't be the last element of any given list
08:13:43 <peterjan> thx
08:13:44 <jerojasro> mm_freak: but hash tables are backed by arrays (most common implementations)
08:14:01 <mm_freak> bartavelle: i'm talking bullshit
08:14:18 <mm_freak> bartavelle: it uses exactly as much memory as there are elements in the underlying vector
08:14:21 <jerojasro> I'm curious about array-less key, value data structures with O(1) query time
08:14:24 <mm_freak> bartavelle: QuickSet and QuickMap are unboxed
08:14:43 <bartavelle> so, strict
08:14:45 <`ramses> peterjan: stronger even, if you have a list [a,b], b cannot possibly come before a in the original stream
08:14:50 <mm_freak> bartavelle: yes
08:14:55 <bartavelle> perfect for my usage
08:14:56 <bartavelle> thanks
08:15:12 <peterjan> `ramses: ok thx
08:15:24 <mm_freak> bartavelle: it uses binary search on a sorted, unboxed vector
08:15:34 <peterjan> `ramses: i'll write your notes down and stare at it for a while
08:15:34 <bartavelle> figured this out
08:15:45 <peterjan> `ramses: don't know whats happening but i just dont see it
08:15:52 <bartavelle> didn't figure what Data.Vector.Algorithms.AmericanFlag was from the name though :)
08:15:56 <alocacoc> you're not alone peterjan :)
08:16:05 <mm_freak> it's O(log n), but outperforms many other O(log n) and even O(1) data structures, where your keys are complicated and/or elements come in in undefined order
08:16:05 <peterjan> thx :D
08:16:08 <bartavelle> ah but thtat's in Data.Vector
08:16:11 <peterjan> and normally i love haskell
08:16:15 <peterjan> but now, FUCK it
08:16:29 <`ramses> peterjan: I think it's the problem you hate, not the language
08:16:34 <mm_freak> bartavelle: i'm using heap sort…  it turned out to be the fastest for large arrays after a few benchmarks
08:16:34 <`ramses> don't shoot the pianist ;)
08:16:49 <peterjan> i'm gonna shoot you if you don't pm your answer right away
08:17:01 <peterjan> :p
08:17:07 <peterjan> no no thx for all the help
08:17:08 <`ramses> kinda hart with only an ip address
08:17:16 <`ramses> s/hart/hard
08:17:28 <peterjan> i'll write a path finding script
08:17:30 <peterjan> i'll find you
08:20:43 <peterjan> i understand the first 2
08:20:59 <peterjan> nope
08:21:01 <peterjan> just the first one :p
08:21:06 <peterjan> y is d in front e
08:21:19 <peterjan> ah no i get it
08:21:58 <saml> if i like haskell, where do i tweet to? is there hashtag?
08:22:15 <saml> i want the world know about it through twitter
08:23:39 <peterjan> i think i see it
08:23:39 <peterjan> oh my
08:24:56 <`ramses> yeah it's not that hard, you were probably just looking in the wrong direction
08:24:58 <alocacoc> do you compare lists pairwise or all lists at one?
08:25:06 <alocacoc> *once
08:25:19 <peterjan> `ramses: i'm not quite sure if i do it  your way though
08:25:30 <peterjan> if you delete the item you just added
08:25:35 <peterjan> you don't really delete right?
08:25:37 <peterjan> you splitAt..
08:25:43 <peterjan> so you get the items to the left of them as well
08:26:25 <peterjan> f.e. in example 3: you first find 1, then you find 2 but instead of deleting you need to splitAt them so you'll have the 5 as well?
08:26:52 <peterjan> hm i dont quite have it yet
08:26:55 <alocacoc> :p
08:26:58 <peterjan> this is killing me :p
08:27:28 <alocacoc> any more hints for the less gifted ones `ramses ?
08:27:28 <peterjan> also i lost all honor
08:27:36 <peterjan> haha alocacod :p
08:27:41 <peterjan> i feel so stupid
08:27:44 <alocacoc> :(
08:29:17 <wereHamster> how do I integrate the version from the .cabal file into my executable?
08:30:30 <`ramses> alocacoc: what do you mean?
08:30:47 <`ramses> peterjan: every element is guaranteed to appear only once in the original stream...
08:31:21 <alocacoc> when you say generate all possible firsts
08:31:44 <alocacoc> in casu of [[1,2,3],[5,2,3,4],[1,5,4]]
08:31:54 <alocacoc> that is [1,5,1]
08:31:57 <alocacoc> then you pick 1
08:31:57 <peterjan> i think it's 1,5,1 and you have to pick 1.
08:32:00 <peterjan> ok nice
08:32:04 <alocacoc> yes
08:32:08 <alocacoc> then you delete 1
08:32:17 <alocacoc> so new possible firsts are
08:32:20 <peterjan> scnd one is 2,5,5
08:32:22 <alocacoc> [2,5,5]
08:32:23 <`ramses> 5 can never be the first
08:32:35 <`ramses> cause the third list tells you it is preceded by one
08:32:41 <peterjan> lol :p
08:33:04 <alocacoc> ye but how do you take in account that constraint
08:33:12 <peterjan> haha
08:33:42 <alocacoc> ok if 5 never can be the first
08:33:44 <`ramses> well, how would you express it?
08:33:45 <alocacoc> it is 2 then
08:34:12 <alocacoc> but then you have [1,2] as solution which makes no sense?
08:34:37 <`ramses> huh? no, you correctly took all the heads as candidates, but there is an additional constraint that eliminates some of this candidates, 5 does not satisfy that constraint in this case
08:34:51 <`ramses> s/this/these
08:35:18 <alocacoc> just 2 < 5
08:35:58 <`ramses> I don't know where that 2 comes from
08:35:58 <peterjan> we have to go back to step 1 because [1,5,1] isnt correct
08:36:09 <peterjan> so we take [1,5,1] and perform extra check
08:36:16 <peterjan> it should eliminate 5
08:36:36 <peterjan> because there is a list which contains 5 and where the 5 isn't at the head of the list
08:36:45 <alocacoc> in this case there's only one possible first
08:36:54 <peterjan> so we have [1,1] left we take 1 and delete all 1's from each list
08:37:15 <alocacoc> ok I follow you peterjan
08:37:23 <alocacoc> but after that step...
08:37:24 <peterjan> then there is 2,5,5
08:37:26 <`ramses> yes, don't use delete by the way, that only deletes the firs occurence
08:37:37 <peterjan> ok
08:37:39 <peterjan> but now its weird
08:37:45 <peterjan> because now 5 is at the head of a list
08:37:48 <peterjan> since we deleted 1
08:37:57 <peterjan> so in 2,5,5 5 is a possible first
08:38:42 <alocacoc> since we deleted 1 2 is also at the front of a list:(
08:38:45 <peterjan> so first one was 1 we deleted it every where then you get [2,3] [5,2,3,4] [5,4]
08:38:58 <alocacoc> yes
08:39:01 <peterjan> now [2,5,5] as poss. and 5 is possible here..
08:39:06 <peterjan> so we have to take 2.
08:39:07 <peterjan> wtf :p
08:39:18 <neutrino> hey guys
08:39:19 <peterjan> this litt. is fucking my (tiny) brains up
08:39:38 <neutrino> when doing cabal test, how can i pass a command line argument to the test executable?
08:39:41 * hackagebot lens 3.7.0.1 - Lenses, Folds and Traversals  http://hackage.haskell.org/package/lens-3.7.0.1 (EdwardKmett)
08:39:51 <`ramses> peterjan: why 2?? 2 is preceded by 5, as can be seen in the second list
08:40:09 <alocacoc> yes we know that
08:40:15 <peterjan> aha that's an extra check then?
08:40:17 <alocacoc> but how to find that out algoritmatcally
08:40:38 <`ramses> well, how do you check it yourself?
08:40:39 <alocacoc> check alll other lists
08:40:39 <peterjan> lol alocacoc, he's so stupid, he can't algorithmatically right
08:40:47 <alocacoc> : DD
08:41:05 <alocacoc> brb f00d
08:41:08 <peterjan> :p
08:41:49 <peterjan> oh lol
08:41:51 <peterjan> we have the answer
08:41:55 <peterjan> but we keep applying it wrong
08:42:14 <peterjan> we do it correctly but for some reason we keep messing up at the same time
08:42:19 <peterjan> but our algorithm is right i think
08:42:40 <peterjan> 1: [1,5,1] -> 5 is impossible because there is a list which contains 5 and 5 isnt head
08:42:46 <peterjan> 2: delete all ones
08:43:08 <`ramses> rinse, repeat
08:43:09 <peterjan> 3: [2,5,5] -> 2 is impossible because there is a list which contains 2 and 2 isnt head
08:43:14 <`ramses> now write that in general
08:43:35 <peterjan> think i got it now thx
08:43:46 <peterjan> want to see my previous algorithm? :p
08:43:49 <peterjan> wait i'll pastebin
08:44:07 <`ramses> use hpaste, then you can immediately reference here
08:44:18 <hpaste> peterjan pasted “old algorithm” at http://hpaste.org/78905
08:45:48 <hpaste> peterjan pasted “old algorithm” at http://hpaste.org/78906
08:46:24 <cryptopsy> http://www.theweeklyvice.com/2012/12/erin-haskell-teacher-charged-with.html
08:46:29 <cryptopsy> haskell has sex with underage student
08:46:44 <`ramses> peterjan: the warnings at the bottom of the paste are pretty useful
08:46:58 <peterjan> yes i see that now thx :p
08:47:05 <peterjan> i did it once before and had no warnings i guess
08:47:21 <`ramses> you posted line numbers together with the content so it couldn't parse it
08:47:22 <peterjan> awesome little check-tool
08:47:29 <cryptopsy> you had sex with a child and there were no warnings?!
08:47:30 <peterjan> the second time i didn't
08:47:39 <`ramses> no, then it did gave the warnings :)
08:47:58 <peterjan> ah no i used it like a month ago
08:48:07 <peterjan> i was talking about then not just now
08:48:25 <peterjan> you should take a look at my algorithm its pretty smooth :p
08:48:32 <peterjan> not really but it's original to say the least
08:48:32 <elliott> cryptopsy: off-topic...
08:48:52 <`ramses> ah ok :)
08:49:24 <peterjan> it sucks :p i was finding all left elements, permutating those and ordering them, then i kept the middles ones and did the same with the right ones
08:49:29 <`ramses> yeah, it's not the easiest to read.. :)
08:49:34 <peterjan> whatever thx i'll try and put it into code
08:49:38 <peterjan> i didn't refactor it yet :p
08:49:41 * hackagebot timeout-with-results 0.1 - Runs a time-limited computation alowing it to return intermediate results.  http://hackage.haskell.org/package/timeout-with-results-0.1 (PetrPudlak)
08:50:12 <peterjan> i really just lost all my dignity
08:50:20 <peterjan> fuck it
08:50:47 <cryptopsy> it sucks, and blows, and the gets arrested
08:50:51 <cryptopsy> then*
08:51:26 <peterjan> its a hooker!
08:51:32 <copumpkin> o.O
08:51:58 <copumpkin> how about we refrain from that
08:52:21 <peterjan> not the least bit interested
08:52:43 <elliott> copumpkin++
08:54:14 <JonFairbairn> Trying graphics-drawingcombinators, I get a segfault for trivial programme.  Anyone know anything about this?
08:57:15 <tomeo> What is the difference of quot and div?
08:57:23 <tomeo> It appears to me they do the same thing
08:57:39 <vraid> > quot 5 -3
08:57:40 <lambdabot>   *Exception: show: No overloading for function
08:57:49 <tac> @type quot
08:57:50 <lambdabot> Integral a => a -> a -> a
08:58:01 <vraid> > quot 5 $ negative 3
08:58:02 <lambdabot>   Not in scope: `negative'
08:58:03 <lambdabot>  Perhaps you meant `negate' (imported from Prelude)
08:58:04 <copumpkin> > (5 `quot` negate 3, 5 `div`  negate 3)
08:58:05 <tac> > quot (-2) 1
08:58:06 <lambdabot>   (-1,-2)
08:58:06 <lambdabot>   -2
08:58:07 <tac> > div (-2) 1
08:58:09 <lambdabot>   -2
08:58:17 <vraid> > quot 2 (-1)
08:58:19 <lambdabot>   -2
08:58:20 <vraid> > div 2 (-1)
08:58:22 <lambdabot>   -2
08:58:24 <vraid> hmm
08:58:43 <tomeo> they both have the exact same type too
08:58:47 <copumpkin> > ((5 `quotRem` negate 3, 5 `divMod`  negate 3)
08:58:48 <lambdabot>   <hint>:1:46: parse error (possibly incorrect indentation)
08:58:49 <JonFairbairn> 3 `quot` (-2)
08:58:53 <copumpkin> > (5 `quotRem` negate 3, 5 `divMod`  negate 3)
08:58:55 <lambdabot>   ((-1,2),(-2,-1))
08:58:59 <JonFairbairn> 3 `div` (-2)
08:58:59 <copumpkin> does that help?
08:59:09 <mm_freak> tomeo: the difference is visible for negative numbers
08:59:41 <mm_freak> > (quotRem (-3) 17, divMod (-3) 17)
08:59:42 <lambdabot>   ((0,-3),(-1,14))
08:59:59 <mm_freak> div and mod are most useful for modular arithmetic
09:00:10 <tomeo> mm_freak: so quot is more like "integer division"?
09:00:12 <mm_freak> they keep the representants nonnegative i.e. canonical
09:00:23 <tomeo> in the traditional sense
09:00:33 <mm_freak> quot and rem can be used for traditional integer division
09:01:21 <tomeo> thanks mm_freak
09:01:48 <mm_freak> tomeo: divMod and quotRem have in common that they satisfy this equation:  x = q*d + r (quotient, divisor, remainder resp.)
09:01:56 <mm_freak> they differ in 'r'
09:02:04 <tomeo> okay
09:02:07 <mm_freak> for divMod 'r' is always nonnegative
09:02:43 <copumpkin> [11:58:36] <copumpkin>	 > (5 `quotRem` negate 3, 5 `divMod`  negate 3)
09:02:43 <copumpkin> [11:58:38] <lambdabot>	  ((-1,2),(-2,-1))
09:03:32 <mm_freak> uh
09:03:54 <mm_freak> for divMod 'r' is always nonnegative, if 'd' is nonnegative =)
09:03:59 <mm_freak> i never think of negative divisors
09:04:17 <copumpkin> :)
09:04:56 <mm_freak> anyway, rule of thumb is, if you do modular arithmetic, use divMod, and for everything else use quotRem =)
09:05:18 * rwbarton wonders what exactly is covered under quotRem
09:05:25 <rwbarton> or under "everything else" rather
09:05:39 <copumpkin> quotRem emulates C behavior
09:05:41 <JonFairbairn> Int is modular arithmetic :-P
09:05:52 <rwbarton> right, but has anyone ever wanted quotRem for correctness
09:05:58 <copumpkin> I doubt it
09:06:00 <copumpkin> probably just for speed :P
09:06:01 <mm_freak> rwbarton: you want canonical representants in modular arithmetic…  quotRem doesn't guarantee that, but is also faster
09:06:07 <rwbarton> I guess if you are writing an emulator for C's broken behavior :P
09:06:11 <rwbarton> for speed, yes
09:06:36 <rwbarton> another question is whether anyone has intentionally passed a negative denominator to divMod/quotRem
09:06:44 <mm_freak> if you know that your arguments are nonnegative you should use 'rem' for speed
09:07:44 <mm_freak> btw, C's behavior is not "broken" per se…  the machine's behavior is broken =)
09:10:51 <mm_freak> anyway, most applications really just need the equation above to hold, so for them you can use quotRem just as well
09:11:16 <rwbarton> or you can use (,) 0 then
09:11:23 <copumpkin> lol
09:11:48 <ParahSail1n> if i have a constructor containing an {-# UNPACK #-} !MutVar, what would the representation in memory be
09:12:00 <copumpkin> it'll still be boxed
09:13:07 <ParahSail1n> any way to do it unboxed?
09:13:13 <mm_freak> btw, what happens when you unpack two Bools?  do you get bit magic or just two bytes/words?
09:13:23 <copumpkin> you don't get bit magic
09:13:36 <mm_freak> ok, lenses FTW
09:13:49 <copumpkin> ParahSail1n: not as far as I know. Your best bet is to make a small ByteArray#
09:13:59 <ParahSail1n> bytearray is unboxed?
09:14:29 <copumpkin> it's a flat region of memory
09:14:29 <copumpkin> make it as big as you need for whatever you put in it
09:14:35 <Ankhers> could someone please explain why "zipWith (+) a $ tail a" works, but "let a = 1 : 1 : zipWith (+) a $ tail a" does not work?
09:14:37 <copumpkin> well, you'll want the mutable flavor
09:14:39 <ParahSail1n> "A MutVar behaves like a single-element mutable array associated with a primitive state token" i read this to mean a
09:14:45 <`^_^v> has anyone used alex? i'm trying to generate an error token for anything that doesn't match a rule, what would be a good way of implementing that?
09:14:45 <ParahSail1n> small byte array?
09:15:04 <copumpkin> ParahSail1n: if it's polymorphic, it isn't unboxed.
09:15:35 <ParahSail1n> if i make it a Word, it can be unboxed?
09:15:40 <copumpkin> no
09:15:57 <copumpkin> newByteArray# :: Int# -> State# s -> (#State# s, MutableByteArray# s#)Source
09:16:16 <glguy> Ankhers: Because $ and : don’t work together like that, for one
09:16:20 <copumpkin> readWordArray# :: MutableByteArray# s -> Int# -> State# s -> (#State# s, Word##)
09:16:28 <copumpkin> writeWordArray# :: MutableByteArray# s -> Int# -> Word# -> State# s -> State# s
09:16:37 <copumpkin> ParahSail1n: I'm 99% sure you don't need any of this crap, though
09:17:00 <ParahSail1n> copumpkin: i actually am trying to implement a low level data structure
09:17:07 <copumpkin> still :)
09:17:54 <ParahSail1n> i want like a billion of these in memory
09:18:15 <copumpkin> heh
09:18:23 <copumpkin> then keep them flat
09:18:28 <copumpkin> each of these things has overhead
09:18:54 <ParahSail1n> normally i'd do it in c, but i want to haskell for fun
09:19:24 <ParahSail1n> what's the overhead of a data in haskell?
09:19:56 <copumpkin> whatever the closure size is. Probably two or three words on top of your data at least
09:20:16 <Ankhers> glguy: alright, thanks.
09:20:23 <ParahSail1n> thats fine, probably close to malloc's overhead right?
09:20:48 <copumpkin> if you make a billion of these ByteArray#s, each 8 bytes large
09:20:57 <copumpkin> that'll be 24-32 bytes each
09:20:58 <copumpkin> maybe more
09:21:09 <copumpkin> it'll eat a lot of memory :)
09:21:24 <ParahSail1n> i've 500 GB to spare
09:21:47 <elliott> of RAM?
09:21:53 <ParahSail1n> yes
09:21:56 <vraid> impressive
09:22:03 <`ramses> holy crap, supercomputer?
09:22:04 <ParahSail1n> not mine, employer
09:22:17 <copumpkin> then why go to all these lengths? designing a simpler structure with direct pointers rather than these mutable cells is probably going to be better
09:22:41 <djahandarie> You can fit 512GB in rack units these days, you don't need a 'supercomputer' :p
09:23:07 <`ramses> oh, okay, didn't know they scale that high
09:23:36 <ParahSail1n> copumpkin: well, actually the data structure i want to make is a single word bitmap plus a mutable array of up to 64 length
09:23:57 <ParahSail1n> copumpkin: i want to minimize memcpys
09:24:34 <ParahSail1n> i figured mutableByteArray would be good for the second part, maybe i should use a single mutableByteArray for both?
09:26:41 <ParahSail1n> maybe even use just a MutableByteArray naked without any sort of type constructor around it?
09:28:23 <elliott> newtype is free
09:29:34 <kate_r> hi
09:29:39 <kate_r> i have a somewhat logic related question
09:29:40 <kate_r> if i were to pattern match f(x), where f and x are polymorphic variables, agains c(d,e), how are f and x instantiated?
09:30:06 <`ramses> kate_r: f is a data constructor?
09:30:07 <kate_r> beside f |-> c(d)
09:30:27 <kate_r> `ramses: well not necessarily, it's just a general logic question
09:30:44 <kate_r> are there ways to instantiate x such that both d and e are contained inside it?
09:30:50 <`ramses> kate_r: I guess they cannot be unified, as they don't have the same arity
09:30:57 * elliott doesn't understand this question.
09:31:17 <kate_r> `ramses: but f |-> c(d) and x |-> e is one, right?
09:32:11 <`ramses> kate_r: then f(x) :- c(d)e ?? Your question is quite ambiguous
09:33:03 <kate_r> `ramses: sorry, it should be f |-> \lambda x. f(d,x)
09:36:34 <`ramses> kate_r: I don't think you can do something like that..
09:36:51 <`ramses> but then I don't really get your syntax either
09:38:32 <bgamari> hmm, cabal 1.16.0.2 seems to refuse to build executables with profiling, even with --enable-executable-profiling
09:43:14 <alocacoc> if ((elem e x) (&&) ((head x) /= e)) then
09:43:22 <FreeFull> What would be a better way of writing  insertNewlines n string = foldr (\(x,y) acc -> if and [x `mod` n == 0,x /= 0] then '\n':y:acc else y:acc) [] $ zip [0..] string
09:43:29 <bgamari> tibbe, Can you think of any reason why cabal would produce an executable linked against the non-profiling RTS despite the package being configured with --enable-executable-profiling?
09:43:33 <alocacoc> The function `elem' is applied to four arguments,
09:43:33 <alocacoc> but its type `a0 -> [a0] -> Bool' has only two
09:43:38 <alocacoc> hmm?
09:43:39 <glguy> alocacoc: You’ve got way too many parentheses
09:43:49 <glguy> if elem e x && head x /= e then
09:43:52 <tibbe> bgamari: not really, but that part of the code is not my area of expertise
09:44:03 <bgamari> tibbe, Alright
09:44:17 <tibbe> bgamari: using HEAD or a released version?
09:44:22 <bgamari> 1.16.0.2
09:44:25 <glguy> alocacoc: When you write (&&) it means you want the and *function* rather than *operator*
09:44:29 <alocacoc> ty glguy
09:44:36 <glguy> (&&) x y     is   x && y
09:44:51 <davean> bgamari: I believe I had that issue also
09:44:54 <tibbe> bgamari: ok, there are no know issues there
09:45:12 <bgamari> davean, Good to know; how did you end up dealing with it?
09:45:13 <tibbe> bgamari: if you figure it out (using e.g. cabal -v to see how GHC gets invoked) please file a bug
09:45:28 <davean> bgamari: uh, I just injected the flag even though it spit out a ton of warnings :)
09:45:28 <tibbe> bgamari: I have used executable profiling recently and it worked for me using the latest release
09:45:31 <davean> bgamari: I was in a rush
09:45:35 <bgamari> tibbe, sure
09:46:47 <bgamari> davean, Unfortunately this doesn't seem to work in my case
09:47:10 <bgamari> with -prof injected,
09:47:12 <bgamari> WormLikeChain.hs:1:1:
09:47:12 <bgamari>     Dynamic linking required, but this is a non-standard build (eg. prof).
09:47:57 <davean> Ah, well, I wasn't using dynamic linking
09:48:02 <davean> Infact, I never have
09:48:56 <bgamari> Yeah, I'm actually not sure how dynamic linking got switched on in this ghc build (7.6.1)
09:49:42 * hackagebot tie-knot 0.2 - "Ties the knot" on a given set of structures that reference each other by  keys.  http://hackage.haskell.org/package/tie-knot-0.2 (PetrPudlak)
09:54:48 <alocacoc> what is the best way to remove 1 element out of a list of lists?
09:55:10 <alocacoc> delete 2 from [[2,3],[1,2,3,4]]
09:55:13 <alocacoc> should produce
09:55:22 <alocacoc> [[3],[1,3,4]]
09:55:45 <EvanR> map delete
09:55:52 <EvanR> map . delete 2
09:56:04 <EvanR> for some definition of 'best'
09:56:29 <alocacoc> wow will that work even on 2d lists?
09:56:36 <EvanR> er, map (delete 2)
09:56:56 <alocacoc> map (delte 2) [[2,3],[1,2,3,4]]
09:57:02 <EvanR> > map (delete 2) [[2,3],[1,2,3,4]]
09:57:04 <lambdabot>   [[3],[1,3,4]]
09:57:04 <alocacoc> will produce [[3],[1,3,4]]
09:57:07 <alocacoc> ?
09:57:15 <alocacoc> oh damm yes
10:07:44 <prowannabe> hi
10:08:20 <prowannabe> it is possible call 2 functions inside 1?
10:08:56 <clahey> prowannabe: What do you mean?
10:09:01 <hpaste> keep_learning pasted “Excercise of GADT” at http://hpaste.org/78911
10:09:14 <keep_learning> Hello All
10:09:33 <prowannabe> ex: test list = function1(list) funtion2(list)
10:09:39 <ski> > let f as = reverse (drop 3 as)  in f "reverse"
10:09:39 <keep_learning> I am trying to solve this exercise from http://en.wikibooks.org/wiki/Haskell/GADT
10:09:40 <lambdabot>   "esre"
10:09:41 <clahey> alocacoc: That's what the map part does.
10:10:02 <keep_learning> but I am stuck with values in the context.
10:10:04 <neutrino> when doing cabal test, how can i pass a command line argument to the test executable?
10:10:04 <eacameron> what is the difference between Real and RealFrac?
10:10:06 <clahey> prowannabe: What do you want to do with the return values of function1 and function2?
10:10:07 <ski> prowannabe : where should the result value of `function1(list)' be passed ?
10:10:28 <keep_learning> Could some one please tell me how to proceed.
10:10:55 <neutrino> i don't know much about gadt's, sorry
10:11:10 <ski> what is the exercise ?
10:11:33 <keep_learning> ski, Exercise: Despite our goal, it may still be instructional to implement the eval function; do this.
10:11:46 <prowannabe> my function test should edit a list... first funtion add some numbers and returns a int, and function 2 erase de first entry of each list
10:11:48 <prowannabe> got it?
10:11:49 <Eelis> hm, maybe hoogle shouldn't choke on the arrow in a query like "Maybe a → [a]". i use UnicodeSyntax all the time and actually have to turn it /off/ to be able to do hoogle searches :)
10:12:01 <Eelis> *turn ibus off
10:12:39 <clahey> prowannabe: So, you can't edit something in a function.  A function can only return a value.
10:14:06 <clahey> keep_learning: So, I would like to see you reimplement this without using case.
10:14:28 <clahey> neutrino: It turns out the exercise is before the GADTs are introduced.
10:14:46 <prowannabe> clahey: I have a list of lists. in each list i need to sum it and add a entry with the result in the head
10:14:49 <hpaste> nunquam pasted “empty list error” at http://hpaste.org/78912
10:14:56 <clahey> keep_learning: What is eval (Add Nothing _) ?
10:15:07 <prowannabe> it is a matrix
10:15:14 <alocacoc> anyone spots why I'm getting a empty list exception of head?
10:15:14 <prowannabe> this is for the lines
10:15:22 <clahey> prowannabe: Right.
10:15:32 <nunquam> overe here: http://hpaste.org/78912
10:15:35 <clahey> prowannabe: So in haskell what you have to do is write a function that returns a new list of lists.
10:15:35 <keep_learning> clahey, In case if my expression returns nothing then it should be Nothing.
10:15:44 <ski> keep_learning : `eval :: Expr -> Maybe (Either Int Bool)' ?
10:15:46 <clahey> keep_learning: So just write that.
10:15:58 <clahey> eval (Add Nothing _) = Nothing
10:16:13 <clahey> keep_learning: Then ask, what is eval (Add _ Nothing)
10:16:17 <clahey> And continue on your way.
10:16:29 <ski> ok
10:16:34 <clahey> keep_learning: And finally, what is eval (Add (Int a) (Int b))
10:16:36 <keep_learning> clahey, Nothing ?
10:16:39 <solarus> shouldn't the arguments to Add be Expr not maybe something?
10:16:44 <clahey> keep_learning: Right.
10:16:52 <clahey> Oh, I mean:
10:16:59 <keep_learning> Int ( a + b )
10:17:01 <nunquam> the only place where I'm using head is here:
10:17:02 <nunquam> realFirst :: Eq a => [[a]] -> a -> Bool
10:17:02 <nunquam> realFirst [] _ = True
10:17:02 <nunquam> realFirst (x:xs) e = if elem e x && head x /= e then False
10:17:02 <nunquam>                      else realFirst xs e
10:17:07 <prowannabe> clahey: my idea to sum the columns is: sum the head of each list and then, do "drop 1 list"
10:17:10 <ski>   eval (Add e0 e1) = case (eval e0,eval e1) of
10:17:21 <prowannabe> i have a function to sum and other to make the drop
10:17:28 <ski>     (Nothing,_      ) -> Nothing
10:18:02 <clahey> Oh, ski has a good point, you need to eval the sub fields.  My bad.
10:18:08 <prowannabe> but i don't know how to put both of function in the main function
10:18:35 <clahey> prowannabe: How do you want to combine the results of the two functions?
10:18:40 <crdueck> @src join
10:18:40 <lambdabot> join x =  x >>= id
10:19:45 <clahey> keep_learning: Well, a and b are already integers, so you don't need to use the constructor Int.
10:20:08 <clahey> keep_learning: And ski makes a very good point that you need to eval the two sub expressions first.
10:20:11 <nunquam> anyone? :(
10:20:17 <nunquam> http://hpaste.org/78912
10:20:55 <clahey> keep_learning: Though I would use a named function instead of a case statement, that's just a matter of taste.
10:20:58 <keep_learning> clahey, Actually I am stuck with this on eval ( I n )  = Just ( Left n )
10:21:16 <clahey> keep_learning: That loos right to me.  Does it not work?
10:21:55 <clahey> keep_learning: Oh, also, don't forget that eval (Add (I a) (I b)) = Just (a + b), not a + b.
10:22:17 <keep_learning> Why not Just ( Left ( a + b ) ) ?
10:22:24 <clahey> I was wrong, when I asked what eval (Add (Int a) (Int b)) was.  That statement is non-sensical.
10:22:31 <clahey> keep_learning: Cause I forgot about the Either.  :)
10:22:37 <clahey> keep_learning: You're absolutely right.
10:22:43 <keep_learning> clahey, :)
10:22:47 <clahey> keep_learning: Did you understand what ski was saying about having to eval the sub expressions?
10:23:00 <clahey> keep_learning: And then match on them being Left or Right, not Int?
10:23:06 <prowannabe> clahey: i need to create a need entry for with the sums.  the other function it is "void", i just need it to remove all the first entries to call again the main function with recursion
10:23:12 <clahey> keep_learning: I totally flubbed up describing this.  :)
10:23:22 <keep_learning> Yes , First keep evaluating the subexpression then combine the results if I got ski correctly.
10:23:33 <clahey> keep_learning: I believe so.
10:24:03 <keep_learning> My problem is when all the expression will evaluate then how to get out of Just ( Left  value ) ?
10:24:04 <prowannabe> this is what i got: addLine (x:list) = (sumPosX list) elimFirst(list) : addLine(list)
10:24:05 <clahey> prowannabe: So, returning "void" (which we would probably call ()) from a function doesn't actually make sense in haskell.
10:24:15 <keep_learning> otherwise it will be nothing
10:24:22 <clahey> prowannabe: Because functions aren't allowed to have side effects.
10:24:29 <clahey> prowannabe: Give me one sec.
10:24:35 <keep_learning> if we are trying to add  Bool to Int value
10:25:06 <crdueck> is there a monadic version of (<*) from Control.Applicative?
10:25:26 <elliott> (<*)
10:25:33 <clahey> keep_learning: So, I would write eval a b = combine (eval a) (eval b) where combine (Just (Left a)) (Just (Left b)) = something; combine _ _ = something else.
10:25:37 <prowannabe> clahey: the sumPosx return a int with the sum of a column and elimFirst delete the head of the sub-list
10:25:43 <elliott> all monads are applicative; almost all Monads are Applicative
10:25:56 <clahey> keep_learning: Sorry, I screwed that up again.  Eval (Int a b)
10:26:02 <clahey> keep_learning: Sorry, I screwed that up again.  eval (Int a b) =
10:26:08 <clahey> keep_learning: Sorry, I screwed that up again.  eval (Add a b) =
10:26:12 <clahey> Okay, I'm done typing.  :)
10:26:25 <prowannabe> clahey: then i need to call again the funtion to make this process to the rest of positions
10:26:34 <nunquam> :rr
10:26:48 <clahey> prowannabe: So, how did you define elimFirst?
10:26:54 <keep_learning> clahey, Looks like I got you.
10:26:58 <prowannabe> clahey: that's why i have in the end ":addLine(list)"
10:27:06 <clahey> prowannabe: I got you.
10:27:11 <keep_learning> clahey, Thank you!
10:27:16 <clahey> prowannabe: But you're thinking procedurally instead of functionally.
10:27:22 <prowannabe> clahey: it is basicaly a drop 1 list...
10:27:37 <clahey> prowannabe: elimFirst list = drop 1 list?
10:27:50 <clahey> prowannabe: So the thing to understand is that drop 1 list doesn't change list.
10:27:52 <prowannabe> clahey: elimFirst (x:xs) = (drop 1 x):(elimFirst xs)
10:28:21 <clahey> prowannabe: It returns a new one.
10:28:34 <clahey> prowannabe: So elimFirst matrix doesn't change matrix, it returns a new one.
10:28:42 <prowannabe> clahey: i know
10:29:00 <clahey> prowannabe: So if you were to write
10:30:11 <prowannabe> clahey: imagine a matrix. i need to sum each column and put the result on the top
10:30:19 <clahey> Well, there's no real way to write this.
10:30:28 <clahey> But if you wrote:
10:30:36 <eacameron> Hackage says that Double is an instance of Real. Is that because it is an instance of RealFrac, which is an instance of Real? I don't understand how the hierarchy works
10:31:03 <elliott> typeclasses aren't instances of other typeclasses
10:31:03 <clahey> addLine list = useSecondReturnValue (elimFirst list) (addLine list)
10:31:11 <elliott> you gotta declare all your instances
10:31:23 <elliott> superclasses just give you an obligation to write an instance, they don't write it for you
10:31:23 <prowannabe> clahey: my guess is to sum all the head's and then remove it, so i can sum again the head
10:31:26 <neutrino> clahey: aha
10:31:38 <prowannabe> clahey: i think it is easiest way to do it
10:31:39 <clahey> Then the same original list would be passed to addLine.
10:31:44 <clahey> (Thus creating an infinite loop)
10:32:00 <clahey> prowannabe: I agree, but you can't remove the heads from the matrix.
10:32:08 <eacameron> elliott: ahh...isn't it frowed upon to explicitly define superclasses? I seem to recall something about that in Real World Haskell
10:32:08 <clahey> prowannabe: You can return a new matrix with the heads removed.
10:32:13 <nunquam> noone? http://hpaste.org/78912
10:32:13 <neutrino> maybe i can ask again. when doing cabal test, how can i pass a command line argument to the test executable?
10:32:20 <clahey> prowannabe: And in fact, that's what you've coded in elimFirst.  That function looks great.
10:32:23 <elliott> eacameron: um, not really... maybe you misunderstood
10:32:35 <clahey> prowannabe: So what you actually want to do is pass the result of elimFirst to addLine.
10:33:13 <clahey> prowannabe: Well, there's another problem, but let's start with this one.
10:33:26 <fmap> neutrino: --test-option[s]?
10:34:02 <eacameron> elliott: I must be thinking of something else. Ok, so this tells me that RealFrac promises to implement Real: "class (Real a, Fractional a) => RealFrac a where"
10:34:05 <eacameron> elliott: right?
10:34:23 <prowannabe> clahey: this function just creat the line. i have another funtion where i will add this line
10:34:32 <elliott> eacameron: not really
10:34:34 <clahey> prowannabe: That was the second problem I was going to bring up.  :)
10:34:35 <Clint> it tells you that you can't have a RealFrac that's not a Real
10:34:38 <elliott> it says that if you want to make an instance of RealFrac
10:34:43 <elliott> you need to make the same type an instance of both Real and Fractional
10:34:45 <elliott> or it's not allowed
10:34:51 <clahey> prowannabe: Do you understand what I mean about passing the return value of elimFirst to addLine?
10:34:53 <prowannabe> clahey: i never "edit" the matrix
10:34:54 <elliott> this also means that if you do foo :: (RealFrac a) => ..., you get (Real a, Fractional a) for free
10:35:19 <prowannabe> clahey: no. elimFirst just remove the head's
10:35:39 <clahey> prowannabe: Right, and then you want to generate the next element of the list.
10:35:49 <clahey> Of the new line, that is.
10:36:08 <clahey> So you need to pass the return value of elimFirst to addLine to do the recursive step.
10:36:14 <clahey> To write it mathematically, we might say:
10:37:00 <clahey> Well, forget mathematically.
10:37:03 <eacameron> elliott: ahh ok. So RealFrac is just adding an aditional "constraint" (if you will) to things that are already Real and Fractional
10:37:09 <clahey> You're absolutely right to have : addLine(...) at the end.
10:37:14 <clahey> But you're passing in the original list.
10:37:16 <prowannabe> clahey: it is possible call more than 1 function inside another?
10:37:22 <elliott> eacameron: sort of, sure
10:37:24 <clahey> What you want is the list with the first elements eliminated.
10:37:28 <clahey> prowannabe: Absolutely.
10:37:57 <clahey> function1 list = something (list): somethingelse (list) is perfect.
10:38:03 <prowannabe> and how do i creat a list with the values?
10:38:14 <eacameron> elliott: is it safe to say that "RealFrac" is less general than Real (in terms of abstraction)?
10:38:16 <clahey> prowannabe: With the : exactly as you've done.  That's perfect.
10:38:40 <prowannabe> clahey: hugs give my an error
10:39:43 * hackagebot alpha 1.0.5 - A compiler for the Alpha language  http://hackage.haskell.org/package/alpha-1.0.5 (MarcCoiffier)
10:39:52 <clahey> prowannabe: Right, the problem is elsewhere.
10:40:06 <clahey> prowannabe: Is this for a class?
10:40:15 <prowannabe> clahey:hugs points that line
10:40:18 <clahey> prowannabe: Specifically, is it for a programming class?
10:40:27 <clahey> prowannabe: That line is definitely wrong, it's the : that is correct.
10:40:40 <prowannabe> yes
10:40:57 <clahey> prowannabe: Okay, say we have two functions.
10:41:03 <nunquam> how to patternmatch with an empty list of lists?
10:41:09 <clahey> timestwo x = 2 * x
10:41:22 <nunquam> suppose I'm shrinking my list of lists like this
10:41:33 <nunquam> [[1],[2],[3]]
10:41:37 <clahey> nunquam: An empty list of lists is just a list.
10:41:42 <nunquam> => [[],[],[]]
10:41:48 <clahey> nunquam: You can't pattern match on a list of empty lists.
10:41:53 <mapf> return kind of type constructor is self inferred?
10:41:58 <clahey> nunquam: You can pattern match on a list where the first list is empty.
10:42:02 <clahey> nunquam: Or even the first n lists.
10:42:11 <clahey> Okay, so timetwo x = 2 * x
10:42:16 <clahey> plusone x = 1 + x
10:42:36 <clahey> prowannabe: Now say I want a function that computes 2 * x + 1?
10:42:52 <clahey> prowannabe: How do I implement timestwoplusone x = ...
10:42:59 <clahey> In terms of timestwo and plusone?
10:43:08 <Mortchek> > (+1 . 2*) 10
10:43:09 <lambdabot>   <hint>:1:9: parse error on input `)'
10:43:15 <Mortchek> > ((+1) . (2*)) 10
10:43:17 <lambdabot>   21
10:43:34 <clahey> Mortchek: Very good, but completely not the point.  :)
10:43:41 <nunquam>     where mkList :: Eq a => [[a]] -> [a] -> [a]
10:43:41 <nunquam>           mkList [[]:_] acc = acc
10:43:48 <prowannabe> clahey: timetwo(plusone (x))
10:43:54 <Taneb> How would a Co-RWST work?
10:44:01 <clahey> prowannabe: Well, that would give you 2 * (1 + x)
10:44:11 <nunquam>     Could not deduce (a1 ~ [t0])
10:44:11 <nunquam>     from the context (Eq a)
10:44:11 <nunquam>       bound by the type signature for oorsprong :: Eq a => [[a]] -> [a]
10:44:11 <nunquam>       at or from (Eq a1)
10:44:11 <nunquam>       bound by the type signature for
10:44:12 <nunquam>                  mkList :: Eq a1 => [[a1]] -> [a1] -> [a1]
10:44:27 <prowannabe> clahey: so how do i do it?
10:44:36 <Botje> nunquam: please don't paste to the channel
10:44:36 <clahey> prowannabe: You just switched the two functions.
10:44:50 <clahey> timestwo (plusone x) = 2 * (1 + x)
10:44:59 <clahey> plusone (timestwo x) = 1 + (2 * x)
10:45:23 <clahey> nunquam: What does [a:b] mean vs a:b?
10:45:32 <prowannabe> clahey: but that it is not useful to me
10:45:37 <clahey> prowannabe: I'm getting there.
10:45:44 <prowannabe> clahey: ok
10:45:52 <clahey> What you're doing is equivalent to saying timestwo x plusone x
10:46:04 <prowannabe> clahey: yap
10:46:08 <clahey> Multiply by 2, then add 1.
10:46:19 <clahey> But you don't add 1 to the original number, you add it to this new number.
10:46:21 <nunquam> hmmm
10:46:28 <nunquam> problem is I want to stop my recursion
10:46:36 <clahey> nunquam: You're really close.
10:46:42 <nunquam> I got it
10:46:43 <nunquam> mkList ([]:_) acc = acc
10:46:47 <clahey> Right.
10:46:50 <nunquam> but I want it only to stop
10:46:54 <nunquam> when all n lists are empty
10:47:08 <clahey> nunquam: Then you need to use a guard or something like that and not just a pattern match.
10:47:11 <prowannabe> clahey: sorry but i have to leave. but thanks anyway
10:47:27 <clahey> I hope I was helpful.
10:47:39 <clahey> nunquam: Unless you know the length of the outer list.
10:48:21 <clahey> Man, it's really hard because the solution to the actual problem can be done in one line by combining like 4 functions.
10:48:29 <nunquam> I don't clahey
10:48:37 <clahey> nunquam: Then you have to use a guard or something.
10:48:39 <nunquam> but I think I see my problem
10:48:45 <clahey> nunquam: Is this the same problem he was solving?
10:48:55 <nunquam> who is he?
10:49:08 <neutrino> fmap: let me see, thanks
10:49:26 <nunquam> when I do map (delete 2) [[2],[1,2]] I get [[],[1]]
10:49:28 <clahey> nunquam: prowannabe.
10:49:36 <clahey> nunquam: Then it's not the same problem.
10:49:42 <nunquam> Instead I want [[1,2]]
10:49:55 <clahey> nunquam: Do you only want to delete it if it's the first thing?
10:50:03 <clahey> nunquam: Or only the first match?
10:50:09 <nunquam> first match
10:50:18 <nunquam> in every list ofc
10:50:35 <nunquam> [[1,2],[2],[1,2]]
10:50:50 <nunquam> when I do delete 2 on that it should return [[1],[1]]
10:51:09 <clahey> So then [[2],[1,2]] should become [[1]], no?
10:51:15 <nunquam> yes
10:51:23 <clahey> So you want to delete and then get rid of empty lists.
10:51:28 <nunquam> exactly
10:51:30 <clahey> :t filter
10:51:32 <lambdabot> (a -> Bool) -> [a] -> [a]
10:51:35 <clahey> :t null
10:51:36 <lambdabot> [a] -> Bool
10:51:45 <clahey> :t not
10:51:46 <lambdabot> Bool -> Bool
10:52:04 <nunquam> filter not null on list?
10:52:14 <clahey> :t on
10:52:15 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
10:52:19 <clahey> I don't think you need that.
10:52:25 <clahey> But I don't think you actually meant that.  :)
10:52:27 <nunquam> no the on was just english :p
10:52:28 <nunquam> :DD
10:52:49 <clahey> nunquam: That's what I'd do.
10:54:17 <tambo> Anyone know of any range tagged type for lists/sequences? I want to be able to run folds and transformations over a sequence
10:54:28 <tambo> and know where the results came from in my "original" tagged list
10:54:42 <clahey> nunquam: Well, on the result of your map, not on the original list, but if you don't already get that, I don't think I can explain it again right now.  :)
10:54:49 <simpson> tambo: Kind of a decorate-sort-undecorate pattern?
10:54:56 <mapf> the main problem with type families is that we can't pass one type family into another. or we can?
10:55:12 <tambo> simpson: that sounds right
10:56:22 <simpson> tambo: I've never done it on the type level. I'm assuming you know how to (ab)use zip and friends to do it on the value level.
10:56:56 <tambo> simpson: Yes I was doing that until I got the stupid idea to do things "properly"
10:57:19 <simpson> tambo: Hm. I dunno what the proper way is. :3
10:57:44 <tambo> simpson: Wouldn't bother me too much if it wasn't for that I don't need the undecorate step
10:58:02 <tambo> simpson: I *want* to have that in my type :D
10:58:37 <simpson> tambo: Hm.
10:58:47 <ski> keep_learning : any luck ?
10:59:51 <mapf> why we can't do that?
11:00:55 <tambo> simpson: I'm thinking of writing something using Data.Ix
11:01:24 <byorgey> mapf: type synonyms and type families must be fully applied.
11:01:50 <byorgey> mapf: and if you pass a fully applied type family you may as well just pass whatever it reduces to.
11:04:09 <mapf> byorgey: yes, i understand. but not requring type synonyms to be fully applied implies some undecidable things or something? is it impossible i mean?
11:06:17 * neutrino .oO(this channel has fmap and mapf, we're just missing fapm and mfap...)
11:06:22 <grandMaster> are there any good tutorials to learn monads?
11:06:23 <ski> mapf : hm .. how about `type Fix f = FixAux f (FixAux f); type FixAux f g = f (g g)' ?
11:06:38 <neutrino> grandMaster: there are no good monad tutorials.
11:06:51 <byorgey> mapf: it's rather complicated.  see this StackOverflow answer I wrote: http://stackoverflow.com/questions/7866375/why-does-ghc-think-that-this-type-variable-is-not-injective/7950614#7950614
11:06:57 <neutrino> grandMaster: use some monads, learn to use do notation and >>= and other monad-related functions, then you've "learnt monads"
11:06:58 <ski> neutrino : not to forget `pamf'
11:07:17 <mapf> heh
11:07:19 <neutrino> ski: that's going too far. you have quite a temper to suggest such a thing.
11:07:31 * ski has used `pamf'
11:07:36 <neutrino> :)
11:07:42 <mapf> byorgey: oh, shiny. thanks
11:07:54 <grandMaster> neutrino: so its more or less trial and error??
11:08:09 <neutrino> grandMaster: no, it's learning by using and experience.
11:08:10 <grandMaster> it will be a little hard without any good resources?
11:08:10 <bgamari> grandMaster, I absolutely agree with neutrino; just use them
11:08:12 <neutrino> copy code from others.
11:08:21 <neutrino> use what works for you when you need it.
11:08:31 <neutrino> trying to learn monads is like trying to learn hammers.
11:08:32 <bgamari> grandMaster, I made no progress reading monad tutorials until I started actually writing code
11:08:41 <eacameron> grandMaster: learning monads is like learning what red is...you just gotta see it a bunch of times before you pick up on the commonalities ;)
11:08:43 <neutrino> you can't really learn hammers, but you can learn to do a lot of stuff with them.
11:08:51 <bgamari> grandMaster, If you get stuck, we're here
11:09:06 <grandMaster> nice too know
11:09:08 <neutrino> that's probably because monads are like burritos. you can't learn burritos either.
11:09:16 <t7> monads are like buritos in a space suit
11:09:16 <grandMaster> thanks people
11:09:20 <t7> snap
11:09:33 <neutrino> on a platform in the middle of the ocean next to radioactive waste.
11:09:36 <ski> @where burrito
11:09:36 <lambdabot> http://byorgey.wordpress.com/2009/01/12/abstraction-intuition-and-the-monad-tutorial-fallacy/
11:10:08 <ski> grandMaster : read that ^ to learn why you probably shouldn't try to write (yet another) monad tutorial after you "get it"
11:10:14 <grandMaster> is there anyone who uses haskell in the industry??
11:10:32 <Taneb> Yes.
11:10:53 <grandMaster> and what exactly are you using it for?
11:10:59 <neutrino> i use 100% haskell in my day job
11:11:11 <neutrino> i use it to write system administration applications
11:11:16 <neutrino> general unix crap
11:11:21 <Taneb> It's a general-purpose programming language. It can be used for practically anything
11:11:22 <bgamari> grandMaster, There are a number of users in finance
11:11:24 <neutrino> same thing you'd do in C but 1000000000x faster to write
11:11:25 <Taneb> Even TIME TRAVEL
11:11:29 <shapr> grandMaster: I've used Haskell to convert ms.doc files into a custom XML flavor for a client. That was a weekend contract job, but their in-house guy had given up on the task after 1.5 months.
11:11:46 <Taneb> (time travel is rather difficult in Haskell)
11:11:52 <shapr> grandMaster: I've used Haskell to build webapps and been paid for that.
11:11:57 <neutrino> i've used haskell for data recovery.
11:12:01 <bgamari> Taneb, There is always Tardis
11:12:06 <neutrino> and i've used haskell for data manipulation.
11:12:11 <grandMaster> ok got the point
11:12:19 <neutrino> and now i'm using haskell for saving data.
11:12:23 <shapr> grandMaster: Do you have a particular use in mind?
11:12:30 <parcs`> i've used haskell for clever fibonacci sequence implementations
11:12:32 <neutrino> i guess that completes the circle, now i need to use haskell to mangle data again.
11:12:34 <Taneb> bgamari, that was what I was thinking of
11:12:37 <neutrino> parcs`: NO!!!!!!
11:12:40 <neutrino> *table flip*
11:12:47 <eacameron> parcs`: haven't we all...
11:12:50 <grandMaster> basically I am second year computer science
11:12:56 <shapr> grandMaster: In most cases, the Haskell runtime is not a good choice for systems with less than 256mb of memory.
11:13:04 <shapr> grandMaster: Oh, I'm a third year computer science undergrad!
11:13:06 <grandMaster> and I've been taught haskell in the first term
11:13:12 <shapr> grandMaster: Whoa, I'm jealous!
11:13:13 <Taneb> Where at?
11:13:16 <bgamari> Taneb, bah, sorry I'm quite good at ruining jokes
11:13:23 <neutrino> grandMaster: yeah don't worry about it. just keep in mind: what you learn in university will have absolutely 0 application to your job later on.
11:13:29 <shapr> I wish my university taught Haskell any at all :-(
11:13:35 <shapr> neutrino: be nice
11:13:37 <neutrino> grandMaster: so asking about haskell in the industry is a bit moot if you're not in the industry.
11:13:38 <grandMaster> in a uni in england
11:13:48 <grandMaster> i will leave it anonymously :p
11:13:55 <Taneb> grandMaster, I need to apply to one of those in the next three days
11:13:57 <neutrino> shapr: i am, i'm just saying that there's a huge disconnect
11:13:58 <bgamari> grandMaster, I do my experimental data analysis in Haskell
11:14:05 <shapr> neutrino: I don't think that's true.
11:14:06 <Taneb> Before my school starts shouting at me
11:14:09 <bgamari> grandMaster, I work in single molecule spectroscopy
11:14:48 <neutrino> grandMaster: enjoy while it lasts. you'll be able to use the concepts you've learnt after you get through the puberty of writing 199 crud apps in php.
11:14:56 <shapr> grandMaster: Do you have interest in any particular part of CS? Maybe I could tell you how Haskell has been used in areas where you have interest?
11:14:58 <eacameron> I use haskell to blow my brains
11:15:03 <shapr> neutrino: srsly, stop it.
11:15:04 <neutrino> it's really worth learning everything, but it won't be obvious at all how to apply.
11:15:22 --- mode: ChanServ set +o shapr
11:15:25 <neutrino> shapr: i.. don't know why you think what i'm saying is offensive
11:15:28 <grandMaster> I don't know yet many things
11:15:31 <parcs`> me neither
11:16:07 <eacameron> neutrino: some schools are better than others are being industry-minded
11:16:15 <grandMaster> what i have understood from my hakell module is that haskell and functional proramming in general is very interesting but is also a pain in the ass
11:16:34 <eacameron> grandMaster: and it will stay that way for the rest of your life
11:16:35 <eacameron> ;)
11:16:36 <bgamari> grandMaster, How so?
11:17:13 <neutrino> grandMaster: i wouldn't say so. it just gives you a lot of power, some people get lost in the detail. once you get into it you can really appreciate the flexibility, modularity, while you get none of the downsides
11:17:30 <hpaste> nunquam pasted “Non-exhaustive patterns” at http://hpaste.org/78927
11:17:40 <nunquam> what's non-exhaustive in this function?
11:17:54 <eacameron> neutrino: grandMaster: the only downside to Haskell is how smart you have to be to use it well (mostly not joking here)
11:17:54 <grandMaster> I have been told also OOP and I guess I have used to it
11:18:17 <rwbarton> nunquam: compile with -Wall, ghc will tell you
11:18:19 <grandMaster> haskell doesn
11:18:28 <neutrino> eacameron: i wouldn't exactly say so. i'm mostly crawling through the high concepts, but i don't need them to use it very effectively.
11:18:43 <neutrino> it's really empowering. there's a really high ceiling, but you don't have to try and reach it.
11:19:10 <parcs`> nunquam: what if the first list is non empty but the second list is empty
11:19:12 <neutrino> it's optional to know category theory, abstract algebra, and whatever else people come up with to think about functional code.
11:19:22 <shapr> eacameron: Really? I don't think Haskell requires someone to be smart or have any particular education.
11:19:44 <shapr> I'm about to take my first calculus course, but I've been using Haskell commercially for some years.
11:19:52 <b__> shapr, I think it does require someone to be smart
11:19:55 <osfameron> being smart probably helps
11:20:02 <grandMaster> my point is, i am kind of interested to learn more about haskell and now in the christmas brake maybe I can spend some time for it
11:20:08 <osfameron> but I guess that's true of many fields
11:20:10 <tambo> I don't feel smart when I use haskell...
11:20:12 <nunquam> thx parcs`
11:20:22 <dcoutts> neutrino: re test, see --help
11:20:43 <djahandarie> You need to be smart to take the initiative to learn something new, on your own, which is different from what you already know.
11:20:49 <djahandarie> It's not unique to Haskell.
11:21:00 <shapr> djahandarie: That's a good point.
11:21:13 <eacameron> djahandarie: agreed
11:21:42 <eacameron> maybe its just because no-one (almost) teaches Haskell in school--you have to learn it yourself
11:22:04 <eacameron> and it's not like most other big languages--so you can just ask your cousin
11:22:13 <shapr> eacameron: You think that makes Haskell self-selecting to those who are willing to explore?
11:22:18 <eacameron> *you can't just ask your cousin
11:22:26 <eacameron> shapr: definitely
11:23:04 <osfameron> shapr's cousin?
11:23:08 <grandMaster> eacameron: is hard to learn haskell by yourself
11:23:44 <nunquam> how can I catch an error I throw?
11:23:55 <nunquam> say my function bar throws error "error"
11:23:56 <eacameron> grandMaster: harder than Java, Ruby, Python, C, C++, PHP, Perl
11:24:11 <nunquam> in foo i call bar when there's an error I want True else False
11:24:11 <eacameron> grandMaster: but not too bad--there are great books
11:24:28 <djahandarie> It's only harder to learn than Java, Ruby, Python, C, C++, PHP, Perl, if you already know one of the former (or another similar language).
11:24:37 <djahandarie> If it's the first language you ever learn, not hard.
11:24:53 <eacameron> djahandarie: that might be true. I was (unfortunately) taught all those first!
11:25:05 <Cale> It's comparable in difficulty to learning the first programming language you learned
11:25:22 <djahandarie> Yeah. I taught Haskell to a small group of middle schoolers without any issue. They picked it up as easily as they would have picked up Java.
11:25:22 <shurikas> nice
11:25:24 <lispy> Cale: what do you use for maths on your blog? somesort of latex-based solution?
11:25:28 <eacameron> Cale: that has been my experience
11:25:41 <Cale> lispy: Yeah
11:25:50 <eacameron> djahandarie: makes sense
11:25:55 <grandMaster> eacameron: agree, my personal opinion is that inorder to understand functional programming in depth you need a strong mathematical background
11:26:01 <ski> learning a new programming paradigm is a bit like learning to program all over again (some things carry over, several things don't)
11:26:24 <Cale> lispy: It took a bunch of hackery which I don't clearly recall the details of.
11:26:30 <eacameron> grandMaster: I can't speak to that. anyone?
11:26:56 <shurikas> best thing about haskell is that nothing else is as hard as it is. So any other concept you ever pick up will be relatively easy :D
11:27:03 <shapr> osfameron: I don't think I have any cousins that do programming.
11:27:28 <parcs`> shurikas: that's not true :)
11:27:31 * osfameron makes a note not to ask shapr's cousin about perl (or haskell)
11:27:36 <djahandarie> I don't agree with grandMaster really. Knowing high school algebra helps, but beyond that there isn't much in math that would be remotely useful until you get to abstract algebra, and that would only be useful for understanding how to abstract things (which you can learn from programming itself).
11:27:38 <Hafydd> You need a mathematical background to do anything useful in any language.
11:27:55 <shapr> Hafydd: Really? I don't have a mathematical background :-(
11:28:00 <Cale> I have a strong mathematical background, and I would say that it helps a bit, but if you didn't have one it wouldn't stop you from understanding this stuff. You can come at it from the other direction as well, and understand computation and then the mathematical abstractions which apply.
11:28:00 <parcs`> i guess being mathematically inclined helps when learning haskell
11:28:01 <shurikas> me neither
11:28:15 <shapr> Hafydd: But I am able to program in several languages.
11:28:18 <lispy> Cale: I was playing with hevea again last night and realized that I can force normal latex to generate svgs (which I can embed in the normal hevea output) whenever hevea would normally generate crappy html
11:28:18 * shurikas also can't do anything useful in any language
11:28:21 <Hafydd> But note the lack of the word "strong".
11:28:32 <lispy> Cale: as a demo: http://dagit.github.com/hello.html
11:28:50 <Cale> lispy: Pretty nice
11:29:37 <Hafydd> If you don't, there's a large class of problem you're incapable of solving programmatically.
11:29:59 <shapr> Hafydd: Do you have some examples?
11:30:06 * elliott doesn't agree with Hafydd unless you're using a non-standard definition of mathematical background
11:30:16 <shurikas> roll out your own lens for example
11:30:22 <Cale> Well, we all know that writing programs and writing proofs are really the same thing :)
11:30:23 <Hafydd> shapr: writing a 3D software renderer.
11:30:42 <elliott> well that's more to do with the problem itself than the act of programming it
11:30:46 <shapr> Hafydd: That's a good example.
11:30:48 <shurikas> machine learning requires certain math background
11:31:07 <nunquam> E.catch (oorsprong list) (\err -> return True)
11:31:24 <nunquam> how can I return in my catch a Bool to my function?
11:31:36 <nunquam> I don't want any IO on the screen
11:31:47 <nunquam> just True/False for Exception/No Exception
11:31:51 <elliott> isn't that what your code already does?
11:32:08 <elliott> you'll need \(err::SomeException) though, and note that catching every exception unconditionally is a bad idea
11:32:25 <glguy> oorsprong needs to return a Bool, as well
11:32:29 <Hafydd> Another example: implementing the RSA cryptosystem.
11:32:34 <glguy> or add a >> return False
11:33:03 <simpson> Hafydd: I don't think people are *incapable* of doing these things, but they might not write very good or tight code.
11:33:22 <nunquam> what do you mean with that glguy?
11:33:25 <Hafydd> simpson: I agree, which is why I qualified it with "useful".
11:33:37 <nunquam> E.catch (oorsprong list) (\err -> a >> return True)
11:34:03 <nunquam> gives me "not in scope 'a'"
11:34:13 <elliott> well, because a isn't in scope :P
11:34:23 <nunquam> ye :p
11:34:24 <Hafydd> Things as simple as solving linear equations, which some programmers apparently can't do, come up often IME.
11:34:28 <elliott> glguy meant "add a '>> return False'"
11:34:30 <elliott> to the oorsprong part
11:34:46 <shapr> Hafydd: I certainly don't know how to do that. Can you think of some situations where linear equations are useful?
11:35:04 <shurikas> gimme an example of linear equation
11:35:12 <Hafydd> shapr: printing a progress var for a file download.
11:35:13 * shurikas last time had math in high school
11:35:16 <Hafydd> *boar
11:35:20 <Hafydd> *bar
11:35:21 <Hafydd> <_>
11:35:27 <monochrom> 5*x + 3 = 4
11:35:40 <grandMaster> I was planning to study python in the christmas but it looks that haskell is more useful
11:35:41 <shurikas> oh, ok
11:35:45 <otters> @hoogle a -> (a -> Bool) -> Maybe a
11:35:45 <lambdabot> Data.List find :: (a -> Bool) -> [a] -> Maybe a
11:35:45 <lambdabot> Data.Foldable find :: Foldable t => (a -> Bool) -> t a -> Maybe a
11:35:45 <lambdabot> Test.QuickCheck.Gen suchThatMaybe :: Gen a -> (a -> Bool) -> Gen (Maybe a)
11:35:52 <shurikas> my excuse is also that I'm not familiar with english terms for math :P
11:36:06 <shurikas> hah, I'll probably catch on haskell during christmas too
11:36:09 <shurikas> have 4 weeks of holidays
11:36:14 <monochrom> equationus linearis  <duck>
11:36:21 <shurikas> nobody ever will disturb me with any work
11:36:51 <grandMaster> shurikas: unfortunately I have to keep up with java too
11:36:57 <grandMaster> :p
11:36:59 <shurikas> there is nothing to keep up with
11:37:02 <shurikas> :D
11:37:16 <shurikas> unless you are learning it
11:37:20 <Hafydd> They're adding explicit lambda abstraction to Java, I hear.
11:37:26 <shurikas> yeah, that's exciting
11:37:33 <shurikas> although that will be available only late 2013
11:37:38 <shurikas> general availability I mean
11:37:56 <shurikas> but then it will be available, I will abuse the shit out of those lambdas
11:38:01 <shurikas> just like haskell taught me
11:38:02 <grandMaster> does anyone know any site with exercises for begginers to experts??
11:38:28 <shurikas> grandMaster, project euler \o/
11:38:40 <shurikas> also - scala course on coursera
11:39:06 <b__> write something you actually use
11:39:13 <grandMaster> shurikas: what is this??
11:39:28 <shurikas> it's math exercises for proglamers
11:39:32 <shurikas> if you ask about euler
11:39:35 <shurikas> luv it
11:39:48 <hpaste> keep_learning annotated “Excercise of GADT” with “Excercise of GADT (annotation)” at http://hpaste.org/78911#a78930
11:39:53 <shapr> b__: Yes, I like to write tools in Haskell that help me manage my music collection.
11:40:19 <keep_learning> ski, Yeah Its working and hopefully I implemented it correctly
11:40:24 <shurikas> and I still want to learn attoparsec/TH
11:40:36 <shurikas> maybe that's what I should focus on during holidays
11:40:41 <otters> heh, TH is such a bitch
11:40:43 <Hafydd> Hmm... well, I suppose the class of problems solvable with just intuition is large too.
11:40:54 <shurikas> and then implement some crazy-ass type-safe DSL
11:40:59 <otters> it needs a far more accessible construction mechanism
11:41:01 <shapr> grandMaster: I like b__'s idea of writing a useful utility for yourself. Do you have any utilities that would be useful to you?
11:41:13 <shurikas> maybe something like esqueleto but much cooler
11:41:43 <Cale> shapr: On the more complicated end of the spectrum, you have Google. At its core, what Google's PageRank is doing is trying to estimate the probability that if you started on a random page on the web and clicked links for a long time that you'd end up on any given page. This is a problem which involves a lot of linear algebra to solve.
11:41:55 <shapr> Cale: That's an excellent point.
11:42:14 <shapr> One of my personal-use utility ideas is a tool that finds webpages I would want to read based on the pages I've read before.
11:42:21 <ski> keep_learning : an alternative is to do what i suggested :
11:42:23 <ski>    eval (Add e0 e1) = case (eval e0,eval e1) of
11:42:25 <shapr> So having my own version of PageRank would be handy.
11:42:30 <Hafydd> A better example (on the simple end) is how Youtube knows when to start playing while buffering at a constant speed.
11:42:30 <ski>      (Nothing,_      ) -> Nothing
11:42:37 <nunquam> can I let my function return 2 things? a type variable 'a' and a Bool?
11:42:39 <ski>      (_      ,Nothing) -> Nothing
11:42:45 <ski>      ...
11:42:56 <keep_learning> ski, Yeah , removing the combine function.
11:43:00 <rwbarton> nunquam: it can return a pair -- of type (a, Bool)
11:43:06 <rwbarton> ('x', False)
11:43:10 <Cale> nunquam: You can't return types from functions, but presumably you want to return a value of type a
11:43:15 <keep_learning> I am going to implement that.
11:43:19 <keep_learning> ski, Thank you!
11:43:41 <ski> keep_learning : you'll have to decide whether *you* think the `case' or the `combine' version looks prettiest
11:43:46 <Hafydd> The people who wrote mspaint surely needed a bit of mathematics to draw circles and such, too.
11:44:30 <grandMaster> shurikas: that seems really hard...does it even help to expand your knowledge in haskell??
11:44:33 <monochrom> unfortunately, not many programmers need to write mspaint
11:44:37 <keep_learning> ski, Both looks great and its great learning experience :)
11:45:00 <Hafydd> It's been done at least twice in the history of the universe.
11:45:23 <neutrino> dcoutts: thanks.. i'm fairly stupid for not having tried that!
11:46:25 <mapf> which web server is used for haskell.org?
11:46:50 <bitonic> mapf: haskell.org is largely based on mediawiki
11:47:23 <bitonic> so it’s most likely {apache,nginx} + PHP, or something similar
11:47:59 <bitonic> probably nmap can tell you more :P
11:48:13 <monochrom> apache, and whatever mediawiki uses
11:48:24 <mapf> i'm just wondering
11:48:41 <bitonic> monochrom, mapf: well it’s probably going to be mod_php
11:48:45 <luite> the headers say apache 2.2.9
11:48:56 <monochrom> yeah, I merely read the header
11:48:59 <bitonic> unless things have changed in the past 5 years or so :P
11:49:15 <Hafydd> Another example: analysing the time or space complexity of any algorithm.
11:49:45 * hackagebot HTF 0.10.0.3 - The Haskell Test Framework  http://hackage.haskell.org/package/HTF-0.10.0.3 (StefanWehr)
11:50:28 <Hafydd> It helps to know about the LCM of two natural numbers when stitching two animations together into one.
11:51:30 <monochrom> Hafydd, I'm cynical, IMO it's a loss cause to argue for programmers learning math. empirically, only a tiny fraction of programmers use that kind of math. in some cases, you could argue that math is not used but should be used, but that is a lost cause too.
11:51:57 <shapr> monochrom: I think it would be nice if there were motivational examples for those of us who don't know much math.
11:52:15 <shapr> For example Cale's mention of PageRank as linear equations.
11:52:41 <luite> yeah an eigenvector
11:53:35 <monochrom> no, I think it is better off to have fewer programmers learn math, so that those of us who learn math are more valuable, we get those high pay quant, graphics, google, etc jobs that they can't
11:53:48 <luite> yes!
11:54:59 <monochrom> and this is the most convincing way. money. you tell them, "look at me, I know linear equations and you don't, and just for that I get double pay. it's really your call."
11:55:37 <monochrom> don't bother persuading. let the money speak for itself
11:55:55 <roconnor> monochrom: what if I know semi-rings and dioids?
11:55:58 <Hafydd> Oh, well, I was just stating the truth. I found programming rather frustrating before I learned some mathematics.
11:56:21 <monochrom> roconnor: I don't know
11:56:37 <spiderweb> does haskell implement higher order functions?
11:56:39 <Hafydd> (Or "my interpretation of the truth" if you prefer)
11:57:00 <Hafydd> spiderweb: I can't imagine the answer to any meaning of that being "no".
11:57:05 * roconnor is of the opinion that "math" is useful for programming, just not so much the math that is taught for a mathematics degree.
11:57:24 <Hafydd> spiderweb: a function may have type (a -> b) -> c
11:57:33 <spiderweb> are functions first class?
11:57:36 <ski> yes
11:57:37 <Hafydd> They are.
11:57:58 <mapf> Hafydd: a function can
11:58:04 <mapf> 't have such type
11:58:08 <monochrom> Hafydd: I heard a programmer stating another truth. "I have never needed calculus in my job. my job is writing code to query databases." most programmers are of that kind. if you are of that kind too, you would not be frustrated for lack of math, at least the continuous part of math
11:58:13 <spiderweb> so vs C I could implement an operating system using haskell and utilizing functions as input and generate functions as output?
11:58:14 <rwbarton> see, here we go again
11:58:22 <rwbarton> quantifier confusion
11:58:36 <monochrom> the blind spot is, of course, that for database work you would better know a bit of relational algebra/calculus
11:59:02 <Hafydd> :t (\f -> let fx = f 1 in "hello")
11:59:03 <lambdabot> Num a => (a -> t) -> [Char]
11:59:09 <monochrom> OTOH what relational algebra/calculus you need is rather trivial, you don't need a course for that
11:59:50 <Hafydd> mapf: I suppose you're referring to the implied polymorphism of my type variables, but I just meant those as placeholders.
12:00:11 <mapf> Hafydd: well, i'm just joking. with typeclasses they are
12:00:11 * ski idly ponders derivating database schemas
12:00:14 <spiderweb> I guess I am thinking that haskell would be much more powerful than C when designing an operating system.
12:00:28 <ski> (hm, s/derivating/differentiating/)
12:00:33 <Cale> spiderweb: http://programatica.cs.pdx.edu/House/
12:00:57 <spiderweb> neat
12:01:32 <mapf> someone tried to run that?
12:01:58 <Hafydd> Ah yes, the number of unfortuanate souls who use a relational DB without knowing the meaning of "relation".
12:02:15 <shapr> Cale: Any idea what happened to LightHouse?
12:02:22 <monochrom> since the basic relational algebra/calculus you need for practical database work is rather trivial and should not need a course, it is also sad/fun to see that it's way over the head of most students in such a course
12:02:24 <Cale> No idea
12:02:36 <shapr> I have a copy around here somewhere, but I'd like to see if there's a more recent version.
12:02:38 <mux> relations? what's that? I always thought databases are just a cute way to store key-value data ;-)
12:02:47 * shapr emails Kenny Graunke
12:02:58 <lolcathost> mux: lol... everything is a glorified hashmap!
12:03:03 <glguy_> Maybe we should open a window to let all the smug out
12:03:06 * mux grins
12:03:13 <glguy_> its getting hard to see
12:03:24 <snappy> never really got into relational calculus, but relational algebra is nice
12:03:26 * shapr grins
12:03:30 <Hafydd> A database table is a relation on the types of its columns, with each row relating N such values to each other.
12:03:49 <Hafydd> (N columns)
12:03:51 <snappy> and it's also used outside of databases
12:04:32 <monochrom> very few people know relational division!
12:04:45 * hackagebot web-plugins 0.1.1 - dynamic plugin system for web applications  http://hackage.haskell.org/package/web-plugins-0.1.1 (JeremyShaw)
12:05:08 <snappy> went through a course on constraint satisfaction problems which based most of it's theory on relational algebra
12:05:18 <monochrom> I finally figured it out after learning something even more advanced, such as Galois connection and data refinement
12:05:24 <hpaste> keep_learning annotated “Excercise of GADT” with “Excercise of GADT (annotation) (annotation)” at http://hpaste.org/78911#a78931
12:05:54 <roconnor> oh yea, galois connections seem like something that I'd put in a CS degree requirement.
12:06:07 <shapr> Cale: Ok, I emailed the author of LightHouse and asked for latest sources. If he sends me something I'll put it up on github and try to get it added to the Haskell organization.
12:06:21 <Hafydd> http://www.proofwiki.org/wiki/Definition:Relation
12:06:35 <ski> relational division is fun
12:06:51 <mapf> keep_learning: you don't need to place extra parens in case clauses
12:07:46 <mapf> keep_learning: oh, i'm inattentive
12:07:58 * ski prefers specifying `abs',`max',`min' and other stuff with "adjunctions", as well
12:08:11 <ski> (perhaps the proper term is "universal property", i'm not sure)
12:09:57 <roconnor> ski: checkout Galculator
12:10:10 <roconnor> granted I haven't checked it out yet, so maybe it isn't good
12:10:19 <roconnor> @go Galculator
12:10:19 <lambdabot> Maybe you meant: google googleit do
12:10:23 <roconnor> @google Galculator
12:10:25 <lambdabot> http://galculator.sourceforge.net/
12:10:25 <lambdabot> Title: galculator - a GTK 2 / GTK 3 based scientific calculator
12:10:30 <roconnor> pfft
12:10:34 <Nereid> roconnor: but galois connections are a special case of adjoint functors.
12:10:46 <keep_learning> Any one why I am getting this error.
12:10:51 <monochrom> floor as one side of a Galois connection is also pretty nice and easy to use.  for all int x, real y: int_to_real x <= y iff x <= floor y
12:10:51 <roconnor> Nereid: yes
12:11:22 <roconnor> Nereid: I think they are a useful steping stone to understandng adjoint functors, and there are many many useful galois conections.
12:11:40 <roconnor> I have a feeling that proper use of galois connections would shrink my proofs by 90%
12:11:53 <roconnor> though that feeling is based on very little data
12:11:55 <monochrom> actually, it's hard to use for most people. but it's easy to use for those of us calculational proof people, such as Dijkstra, Backhouse...
12:12:39 <ski> roconnor : check it out for what .. ?
12:12:46 <monochrom> because we usually work with "iff" and indirection equality: to prove b=c, prove instead for all x: x<=b iff x<=c
12:12:58 <roconnor> @google Galculator galios
12:12:59 <lambdabot> Plugin `search' failed with: No Location header found in 3xx response.
12:13:13 <ski> monochrom :)
12:13:42 <monochrom> and then a lot of proofs of floor properties go short and sweet and formal, without needing case analysis or factoring x = floor(x) + frac(x)
12:13:48 <roconnor> http://dl.acm.org/citation.cfm?id=1389456
12:14:05 <roconnor> Galculator is the name of the prototype of a proof assistant of a special brand: it is solely based on the algebra of Galois connections. When combined with the pointfree transform and tactics such as the indirect equality principle, Galois connections offer a very powerful, generic device to tackle the complexity of proofs in program verification.
12:14:35 <monochrom> sounds fun. thanks roconnor
12:14:53 <roconnor> I haven't got around to reading that paper yet myself
12:16:01 <roconnor> monochrom: are you one of those calculational proof people?
12:16:16 <sclv> anyone played w/ CoCoA ?
12:16:17 <monochrom> I am not famous. but I consider myself one
12:16:21 <roconnor> :)
12:16:24 <roconnor> I'm a wannabe
12:16:48 <roshan> Hi! I've been reading the Typeclassopedia page and doing the exercises to get a feel for the relationship between Functor/Applicative/Monad. I have a few questions and I was wondering if anyone could help me out
12:17:39 <roconnor> roshan: sure
12:18:55 <roshan> roconnor: Thanks! What I've been trying to do is to make my own version of the Applicative and Monad classes that are "minimal" in some sense. For example, defining Applicative to have pure and <*> is not really minimal, because you aren't using fmap from Functor anywhere (and in fact you can define fmap in terms of those)
12:19:17 <sclv> galculator paper w/o paywall: http://alfa.di.uminho.pt/~paufil/publications/PPDP08.pdf
12:19:32 <roshan> So instead I defined Applicative as unit :: f () and (**) :: f a -> f b -> f (a, b)
12:19:33 <ski> roconnor : oh, interesting
12:19:42 <roconnor> roshan: okay
12:19:50 <roconnor> sclv: thanks!
12:20:10 <sclv> thanks for pointing it out -- looks interesting
12:20:11 <monochrom> and thanks ski
12:21:30 <roshan> And now I want to do the same for Monad, which I define as Applicative plus join. But now I can derive the usual monad >>= operation using just join and fmap, without using any other applicative functions. I was wondering if there is some more "primitive" operation than join that we can define a Monad in terms of, so that we're actually using the rest of Applicative
12:21:46 <b__> can liftM2 f a b be written with Applicative?
12:22:05 <elliott> f <$> a <*> b
12:22:08 <elliott> or liftA2 f a b
12:22:21 <b__> thanks
12:22:53 <ronwalf> Uhg.  I seem to be able to segfault any of my GHC installations with "ceiling (-1.1 :: Double)"  (OS X 10.8.2, HP 2012.4.0.0)
12:23:08 <ronwalf> ghci only, compiled code works
12:23:51 <roconnor> roshan: Interesting.  I don't know of any, and it is plausible that there is no such operation.
12:24:12 <roconnor> roshan: though I'd be a little suprised if there wasn't
12:26:41 <ronwalf> Interesting.  Floats work fine
12:26:55 <ronwalf> (32bit vs 64bit?)
12:27:26 <monochrom> roconnor, ski: I've just read the introductory example in the Galculator paper. "shit. shit. how did I miss it before!" ;)
12:27:29 <ronwalf> Anyone else have a 32bit ghci on OS X ?
12:28:08 <aristid> is there the Monad instance for Monoid a => (,) a somewhere? or do i need to use Writer?
12:28:40 <sclv> monochrom: also see this: http://www.iis.sinica.edu.tw/~scm/2010/calculating-programs-from-galois-connections/
12:28:54 <roconnor> monochrom: the adjuction between multiplication and integer division?
12:28:59 <roconnor> er the galois connection
12:29:22 <sclv> i've never done serious proofs with galois connections but learning about them has helped me in informal reasoning a whole bunch
12:29:42 <monochrom> no, to actually use it to prove x÷y = (x-y)÷y + 1
12:29:47 <roshan> roconnor: Yeah, I found it puzzling. You don't even need anything other than pure for all the Monad laws either. I guess I'll just work on it some more and see if I can find such an operation. Thanks!
12:30:22 <sclv> & this: http://www.logicmatters.net/resources/pdfs/Galois.pdf
12:30:23 <monochrom> wait, I guess I did it before, and just forgot that I did
12:30:49 <roconnor> roshan: what do you mean by "You don't even need anything other than pure for all the Monad laws either."?
12:31:40 <k00mi> quit
12:32:51 <Nereid> aristid: yeah, there isn't
12:33:17 <Nereid> http://stackoverflow.com/questions/4204086/is-the-monad-w-instance-anywhere-standard
12:33:19 <roshan> roconnor: Ah, I just meant that the monad laws as they are stated depend only on pure and >=>, and they don't depend on the Applicative laws that relate pure to <*>. I guess I'm just being redundant though, since we know that we can write an Applicative instance for any Monad
12:33:45 <aristid> Nereid: a pity!
12:33:55 <aristid> Nereid: not a real problem, but still:)
12:34:00 <Nereid> yeah it's strange
12:34:40 <monochrom> more in #haskell-blah
12:37:14 <ski> monochrom : examples of what i meant by "adjunctions" are stuff like `forall y. abs x =< y <-> -y =< x =< y',`forall m. max (a,b) =< m <-> a =< m /\ b =< m',`forall n : |N. forall (forall i : |N ; i < n. a_i : R). p | (product i. a_i) <-> (exists i. p | a_i)',`forall n, m = n <-> P n',`forall n. m =< n <-> P n',`forall n. m =< n <-> exists o. o =< n /\ P o',`forall m. m =< n <-> forall i. m =< f i'
12:37:56 <aristid> Nereid: maybe they don't want to add more stuff to a module as terrible as Control.Monad.Instances?
12:38:12 <Nereid> but why only go partway?
12:40:07 <saml> f [x1,x2, ... xN]   [y1, y2, ... yM]  ==> [x1+x2+y1, x2+x3+y2, ....]  how do I do this?  M + 1 = N
12:41:11 <Nereid> :t zipWith (+) . (zip <*> drop 1)
12:41:12 <lambdabot> Num b => [b] -> [(b, b)] -> [(b, b)]
12:41:15 <Nereid> oops
12:41:20 <Nereid> :t zipWith (+) . (zipWith (+) <*> drop 1)
12:41:22 <lambdabot> Num c => [c] -> [c] -> [c]
12:42:03 <Nereid> > (zipWith (+) . (zipWith (+) <*> drop 1)) [a,b,c] [d,e]
12:42:04 <lambdabot>   [a + b + d,b + c + e]
12:42:21 <saml> what's <*> ?
12:42:30 <Nereid> (f <*> g) x = f x (g x)
12:42:38 <Nereid> from Applicative
12:43:32 <saml> oh drop 1 is safer than tail
12:43:37 <Nereid> you could also use ap instead of it, since (<*>) = ap for monads
12:43:46 <saml> how can you know this kind of stuff immediately?
12:43:49 <Nereid> yeah, it would still work with tail, but I prefer total functoins.
12:44:00 <Nereid> uh, I've seen the zip <*> drop 1 pattern before.
12:44:01 <Nereid> ;v
12:44:50 <rwbarton> @let behead = drop 1
12:44:52 <lambdabot>  Defined.
12:44:52 <aristid> Nereid: Writer being written in terms of WriterT makes it quite inconvenient to use instead of a tuple *sigh*
12:45:06 <Nereid> haha rwbarton.
12:45:19 <aristid> > behead "rwbarton"
12:45:21 <lambdabot>   "wbarton"
12:47:48 <homiesGaming> http://www.youtube.com/watch?v=3JYPDaX2-Zc    A Legendary Parody to Far cry 3 of "Vaas" character including a very funny challenge(Hint: Green Pepper)
12:49:28 <shapr> faster than a speeding op...
12:53:36 <saml> I don't understand how (zipWith (+)) <*> drop 1  works
12:54:05 <ski> @quote aztec
12:54:05 <lambdabot> quicksilver says: zip`ap`tail - the Aztec god of consecutive numbers
12:54:10 <saml> zipWith (+)  :: [Int] -> [Int] -> [Int]
12:54:18 <Nereid> (zipWith (+) <*> drop 1) x = zipWith (+) x (drop 1 x)
12:54:21 <saml> but <*> :: f (a -> b)  ->  ...
12:54:27 <Nereid> where f = (t ->)
12:54:38 <ski> `f' gets `([Int] ->)'
12:54:41 <Nereid> Applicative instance for (t ->)
12:55:09 <Nereid> (well, as far as we can write (t ->), but we can't, so it's (->) t)
12:55:20 <ski> > (zip `ap` tail) "foobar"
12:55:21 <lambdabot>   [('f','o'),('o','o'),('o','b'),('b','a'),('a','r')]
12:55:32 <roconnor> @quote aztec
12:55:32 <lambdabot> quicksilver says: zip`ap`tail - the Aztec god of consecutive numbers
12:55:51 <Nereid> > (zip`ap`tail) "foobar" ^.. traverse.both
12:55:53 <lambdabot>   "foooobbaar"
12:56:31 <tomeo> map (const (++)) :: [a] -> [[a1] -> [a1] -> [a1]] Does this mean that the function takes one or three arguments?
12:56:40 <roconnor> Nereid: I can even undrestand that!
12:56:47 <Nereid> :p
12:56:53 <Nereid> tomaw: it can't take more than one
12:57:04 <tomeo> Nereid: was that for me?
12:57:08 <Nereid> oops yes
12:57:11 <Cale> tomeo: one, and returns a list of two parameter functions
12:57:35 <tomeo> thanks Cale Nereid
12:58:36 <Cale> It will send the list [1,2,3] for instance, to the list [(++),(++),(++)]
12:59:07 <tomeo> yes, the resulting list will only contain (++). how is that a list of two parameter functions?
12:59:49 <tomeo> ah
12:59:51 <tomeo> lol
12:59:59 <tomeo> two parameter functions as in a function which takes two paramters
13:00:02 <tomeo> sorry :D
13:08:41 <simon> I have a Data.Map.Map S [S], where S is a chunk of abstract syntax. this necessitates that S has the typeclass Ord. does it make sense to derive it automatically for this purpose?
13:08:47 <simon> s/I have/I want/
13:09:21 <elliott> sure
13:09:46 <illissius> is there any way to force GHCi to print the type of something and also include all of the kinds?
13:09:57 <Nereid> it doesn't particularly matter what Ord instance is used, as long as it's lawful
13:10:30 <simon> I think I'll have a problem in that the entire sub-tree of that S chunk needs to have typeclass Ord as well, right?
13:10:55 <simon> (this means, as far as I can see, three other types, but that's not too bad.)
13:11:04 <Nereid> in order to derive Ord S? yeah
13:11:21 <illissius> in particular I'm wondering about 'error'. foo :: () -> (# #); foo () = undefined doesn't compile (can't match # with *, as expected), but foo () = error "blabla" works just fine
13:11:36 <simon> thanks, elliott and Nereid!
13:12:07 <elliott> illissius: turning on PolyKinds makes it talk about kinds a bit more
13:12:28 <illissius> and interestingly it also works "as expected": main = case foo () of _ -> print 9 results in "blabla", and not 9, meaning that in fact (# #) is unlifted as expected, and doesn't contain bottoms
13:13:09 <illissius> elliott: hmm, it still only says that error :: [Char] -> a though :\
13:13:46 <Nereid> yes, where a is a boxed type
13:13:58 <Nereid> unboxed types don't have undefined
13:14:54 <illissius> Nereid: that's what I'd expect! but it _lets_ me use error as the value of an unboxed empty tuple.
13:14:58 <illissius> but not undefined
13:15:12 <Nereid> hmm!
13:15:17 <illissius> ergo the 'a' in error :: [Char] -> a and undefined :: a probably don't have the same kind
13:15:23 <illissius> but I can't get GHCi to tell me that :)
13:15:24 <Nereid> hmm!!
13:15:37 <Nereid> I've got nothing.
13:19:34 <xenocons> hrm
13:20:59 <xenocons> accidentally googled free monads and tumbled down that monad rabbit hole
13:21:16 <ski>   > :browse GHC.Prim
13:21:18 <ski>   ...
13:21:28 <ski>   mkWeak# :: forall (a :: ?) b c. a -> b -> c -> State# RealWorld -> (# State# RealWorld, Weak# b #)
13:21:32 <ski>   ...
13:21:57 <ski>   > :t GHC.Prim.mkWeak#
13:22:06 <ski>   GHC.Prim.mkWeak# :: forall t b c. t -> b -> c -> State# RealWorld -> (# State# RealWorld, Weak# b #)
13:22:19 <monochrom> hrm
13:22:19 <ski> note the absence of `:: ?'
13:22:36 <tomeo> Why is it that Haskell interprets this do [12, 22, 32, 42]; "foo" as "foofoofoofoo"?
13:23:07 <monochrom> because it's using the [] monad
13:23:23 <sipa> tomeo: what does that statement desugar to?
13:23:33 <byorgey> tomeo: it desugars to  [12,22,32,42] >> ['f', 'o', 'o']
13:23:38 <byorgey> oops =)
13:23:39 <monochrom> > do { [undefined, undefined, undefined, undefined]; "foo" }
13:23:40 <lambdabot>   "foofoofoofoo"
13:24:04 <scp> hey, if I want to have -XTupleSections enabled for a file, how do I declare that in the source?
13:24:12 <ski> aha ! indeed :
13:24:17 <sipa> {-# LANGUAGE TupleSections #-}
13:24:22 <ski>   > :browse GHC.Err
13:24:24 <scp> sipa: thanks! =]
13:24:27 <ski>   ...
13:24:30 <tomeo> monochrom: where can I read about [] monad? never heard of it
13:24:32 <ski>   error :: forall (a :: ?). [Char] -> a
13:24:36 <ski>   ...
13:24:49 <monochrom> in a tutorial that covers monad
13:25:18 <illissius> ski: neat! what GHC are you using, or how are you getting it to print to explicit foralls?
13:25:37 <illissius> mine just says error :: [Char] -> a all the same in :browse as well
13:25:44 <illissius> *to print the
13:26:20 <ski> illissius : try something like `:set -XExplicitForAll' ?
13:27:13 <Nereid> that doesn't work for me
13:28:30 <illissius> me neither. and I checked, all the way back from HEAD to 6.10, :browse says the same thing, though I didn't also test -XExplicitForAll with all of them :)
13:29:31 <illissius> (bbiab)
13:29:41 <ski> > do c:s <- ["this","is","a","dream"]; return (toUpper c) `mplus` (do c <- s; " " `mplus` return c) `mplus` "\n"
13:29:43 <lambdabot>   "T h i s\nI s\nA\nD r e a m\n"
13:29:50 <hpaste> keep_learning pasted “Gadt learning” at http://hpaste.org/78933
13:30:07 <keep_learning> Hello all
13:30:16 <lispy> hello
13:30:39 <keep_learning> I just copied the GADT from http://en.wikibooks.org/wiki/Haskell/GADT and its working fine except I have one case.
13:31:11 <keep_learning> eval $ B True `Eq` B True is rejected by compiler based on Eq definition
13:31:27 <keep_learning> so how to put this one in GADT.
13:31:56 <Nereid> well, look at the types
13:31:59 <Nereid> Eq True has type Expr Bool
13:32:04 <Nereid> er, B True, I mean.
13:32:09 <Nereid> but Eq requires Expr Ints
13:32:13 <keep_learning> The previous one based on Maybe ( Either  Int Bool ) worked but this one is rejected by compilers
13:32:55 <Nereid> do you see how this makes it a type error?
13:33:05 <keep_learning> Nereid, Yes  and thats why compiler is reject but  how to solve this one if this is valid case
13:33:38 <Nereid> one way would be to make separate EqInt an EqBool constructors.
13:33:40 * bgamari really despises stateref's collision with data-accessor
13:33:47 <Nereid> or you could generalize Eq :: Expr a -> Expr a -> Expr Bool
13:33:59 <ski> Nereid,illissius : hm, i'm not sure which (if any) language enables this. i got it by `-fglasgow-exts'
13:34:51 <keep_learning> Nereid,  Thank you!
13:36:37 <Nereid> ski: I turned on all the extensions the ghc doc says -fglasgow-exts does
13:36:39 <Nereid> and it still didn't
13:36:45 <Nereid> but -fglasgow-exts did it
13:36:52 <Nereid> ??????
13:37:17 <ski> keep_learning,Nereid : `Eq :: Expr a -> Expr a -> Expr Bool' doesn't work, directly
13:37:31 <ski> (adding `Eq a' to the constructor should work, i think)
13:37:36 <ski> Nereid : .. strange
13:37:39 <Nereid> ski: what?
13:37:41 <ski> perhaps it's some other option ?
13:38:04 <Nereid> ah yeah, it'll be useless
13:38:15 <ski> Nereid : if you have `Eq e0 e1' then you know `eval e0,eval e1 :: a', but you also need to know `Eq a'
13:38:20 <Nereid> you wouldn't be able to usefully deconstruct an Eq
13:38:27 <Nereid> no?
13:38:32 <Nereid> this has nothing to do with the Eq class
13:38:47 <ski> `(==)' has everything to do with the `Eq' class
13:38:48 <ninegrid> whats it called when you annotate a type like: Integer a => a -> a -> a
13:38:52 <Nereid> this isn't (==)
13:38:55 <elliott> ninegrid: "invalid"
13:38:59 <Nereid> oh, but for eval.
13:39:00 <ninegrid> is that a 'type annotation' as it is called in other languages?
13:39:01 <ski>   eval ( Eq e1 e2 ) = eval e1 == eval e2
13:39:02 <elliott> Integer isn't a typeclass :)
13:39:07 <ninegrid> sorry
13:39:11 <Nereid> ninegrid: yes. or type signature
13:39:12 <ninegrid> Num a => a -> a -> a
13:39:22 <Nereid> ski: yes, for eval you'd need it.
13:39:27 <ski> ninegrid : if you mean the `Integer a =>', then it's called a "context", usually a "class context"
13:39:31 <Nereid> Eq :: Eq a => Expr a -> Expr a -> Expr Bool
13:39:36 <ninegrid> ski: thanks
13:39:39 <ski> aye
13:39:45 <Nereid> but this sounds like an ugly way to do things
13:40:07 <ninegrid> now another question, is it possible to provide two class contexts and what is the syntax to do that?
13:40:17 <ski> ninegrid : it describes some restrictions on the type variables that must be satisfied for one to be able to use the operation
13:40:18 <Nereid> ninegrid: pair them up with (,)
13:40:46 <ninegrid> alright so lik Foo a, Bar b => a -> b -> b
13:40:52 <Nereid> no, with parentheses.
13:40:55 <ninegrid> ok
13:40:59 <tomeo> can I write multiline functions in ghci somehow?
13:41:07 <Nereid> tomaw: you can turn on multiline input.
13:41:11 <ski> @type round
13:41:13 <lambdabot> (Integral b, RealFrac a) => a -> b
13:41:44 <b_jonas> or just write it all in one very long line
13:41:47 * tomaw turns off Nereid's tab completion
13:41:48 <tomeo> thanks Nereid
13:41:52 <Nereid> :(
13:41:52 <ski> Nereid : the whole `round :: (Integral b, RealFrac a) => a -> b' would be a type signature
13:41:55 <ski> er
13:41:58 <Nereid> tomeo: :set +m, or :{ and :}
13:41:58 <ski> ninegrid ^
13:42:09 <Nereid> now I don't feel so bad.
13:42:10 <Nereid> :p
13:42:27 <ninegrid> ski: *nod*
13:42:44 <Nereid> tomaw: 5 character lowercase name, sharing the first 3 letters. I have to look closely to tell the difference.
13:42:53 <ski> ninegrid : however, if you say e.g. `foo s = (read s :: Int) * 2' then the *expression* `read s :: Int' is said to be the expression `read s' *ascribed with the type `Int' -- a type ascription
13:43:04 <Nereid> I've never heard that term.
13:43:24 <tomaw> Nereid: use irssi. It bases completions partially on channel activity so they're more likely to be correct :)
13:43:39 <Nereid> but I don't.
13:44:06 <tomaw> pfft.
13:44:27 <ninegrid> ski: very helpful
13:44:35 <ski> keep_learning : btw, it seems you're missing the `B' case ?
13:45:14 <xenocons> http://www.haskellforall.com/2012/06/you-could-have-invented-free-monads.html found it interesting
13:45:19 <keep_learning> ski, Yes I just copied the code from page and running it ghci.
13:45:47 <Guest74748> if i have a list of lengths, how do i map those to start positions of adjacent segments with those lengths
13:46:01 <Guest74748> = the sum of all previous lengths
13:46:32 <Nereid> Guest74748: scanl (+) 0
13:46:34 <keep_learning> ski, If I got you correctly then I have to add Eq ::  Eq a => Expr a -> Expr a -> Expr Bool and it means that a is member of Eq class and we are putting this
13:46:35 <ski> > scanl (+) 0 [2,5,4,5]
13:46:36 <lambdabot>   [0,2,7,11,16]
13:46:44 <Guest74748> sweet
13:46:48 <keep_learning> restriction on Eq constructor
13:46:56 <keep_learning> ?
13:47:00 <Nereid> keep_learning: yes
13:47:05 <ski> keep_learning : yes, so you need no `Eq a' on `eval :: Expr a -> a'
13:47:09 <ninegrid> so coming back to haskell after about a half year hiatus and being not very proficient with it at all, i decided to start tinkering with it again.  working with some toy problems i decided to newtype up some integers to make some type signatures more informative, but dealing with all the from/to casting makes some codes look ponderous... what is the correct strategy to use in that regard?
13:47:17 <Nereid> ski: which wouldn't have worked anyway
13:47:23 <Guest74748> scan is awesome, now i will map this solution into ruby ;)
13:47:35 <ski> keep_learning : when matching on `Eq e0 e1', it will discover `Eq a', so that you can use `(==)',`(/=)', and other operations requiring `Eq a'
13:48:02 <ski> Nereid : possibly not, i'm unsure what GHC would respond with in that case
13:48:02 <Nereid> ninegrid: if you're using typeclass methods, you can make an instance for those (say, with GeneralizedNewtypeDeriving)
13:48:17 <Nereid> ninegrid: otherwise you'll just have to deal with the wrapper noise
13:48:29 <keep_learning> Nereid, ski Thank you
13:48:32 <ski> > scanl1 (+) [2,5,4,5]
13:48:34 <lambdabot>   [2,7,11,16]
13:48:36 <ski> yw
13:48:42 <ag90> ninegrid: Or use type synonyms if making type signatures more informative is all that matters.
13:48:46 <ninegrid> Nereid: that is the approach I took... well I first manually implemented the instances, then found the GeneralizedNewTypeDriving so I threw that in the LANGUAGE pragma and removed my manual instancing
13:48:47 <Nereid> > scanl1 (+) []
13:48:48 <lambdabot>   []
13:49:07 <`nand`> > scanl (+) 0 []
13:49:09 <lambdabot>   [0]
13:49:38 <Nereid> > scanl (:) [] [1..5]
13:49:39 <lambdabot>   Occurs check: cannot construct the infinite type: a0 = [a0]
13:49:41 <Nereid> oop
13:49:49 <Nereid> :t scanl (:) []
13:49:50 <lambdabot>     Occurs check: cannot construct the infinite type: a0 = [a0]
13:49:50 <lambdabot>     Expected type: [a0] -> [[a0]] -> [a0]
13:49:50 <lambdabot>       Actual type: [a0] -> [[a0]] -> [[a0]]
13:49:59 <Nereid> oh duh.
13:50:01 <Nereid> :t scanr (:) []
13:50:02 <lambdabot> [a] -> [[a]]
13:50:08 <Nereid> scanr (:) [] [1..5]
13:50:12 <`nand`> > tails [1..5]
13:50:13 <lambdabot>   [[1,2,3,4,5],[2,3,4,5],[3,4,5],[4,5],[5],[]]
13:50:18 <Nereid> > scanr (:) [] [1..5]
13:50:20 <`nand`> or rather
13:50:20 <Nereid> yeah
13:50:20 <lambdabot>   [[1,2,3,4,5],[2,3,4,5],[3,4,5],[4,5],[5],[]]
13:50:21 <`nand`> > inits [1..5]
13:50:23 <lambdabot>   [[],[1],[1,2],[1,2,3],[1,2,3,4],[1,2,3,4,5]]
13:50:24 <`nand`> oh?
13:50:26 <`nand`> oh, scanr
13:50:31 <Nereid> > scanl (flip (:)) [] [1..5]
13:50:33 <lambdabot>   [[],[1],[2,1],[3,2,1],[4,3,2,1],[5,4,3,2,1]]
13:50:35 <Nereid> heh
13:50:46 <ski> > scanl (\as a -> as ++ [a]) [] [0 .. 4]
13:50:48 <lambdabot>   [[],[0],[0,1],[0,1,2],[0,1,2,3],[0,1,2,3,4]]
13:50:52 <`nand`> > scanl (flip mappend . return) [] [1..5]
13:50:53 <Nereid> awful
13:50:54 <lambdabot>   Occurs check: cannot construct the infinite type: a0 = [a0]
13:51:04 <ski> indeed
13:51:05 <Nereid> (:) is not mappend.
13:51:13 <ag90> Quick question. Is there a way to have my local cabal-dev sandbox inherit packages from another environment (or the global environment)?
13:51:19 <`nand`> Nereid: but (++) is
13:51:32 <Nereid> oh you're copying that.
13:51:42 <Nereid> > scanl (flip (mappend . return)) [] [1..5]
13:51:43 <lambdabot>   [[],[1],[2,1],[3,2,1],[4,3,2,1],[5,4,3,2,1]]
13:51:50 <`nand`> it was not my intention to copy ski
13:51:54 <Nereid> yeah.
13:52:11 <Nereid> > scanl (flip (flip mappend . return)) [] [1..5]
13:52:12 <lambdabot>   [[],[1],[1,2],[1,2,3],[1,2,3,4],[1,2,3,4,5]]
13:52:14 <ag90> Or rather, if not inherit, can I re-use packages (perhaps by copy-pasting) without re-compiling everything?
13:52:18 <ski> no copy
13:52:45 <`nand`> Nereid: yes, that's what I was looking for :)
13:53:25 <xenocons> hmm
13:53:44 <ninegrid> ag90: it's not even that it matters, it's just playing around... I guess a more specific question would be: suppose I have a function that computes the maximum number of regions defined by n lines in a plane.  say:  plane :: Lines -> Regions,  where both Lines and Regions are newtype Integers.   the base case of 0 lines is 1 region so the recurrance is this: plane n = plane (n - 1) + (toRegions . fromLines $ n)   then, is there a be
13:53:58 <ski> ninegrid : cutoff near ".. then, is there a be"
13:54:24 <Nereid> ninegrid: toRegions . fromLines = fromIntegral
13:54:24 <ninegrid> .. then, is there a better way of handling the (toRegions . fromLines $ n) than what I have here?
13:54:37 <xenocons> is there a built in for: test x f = case f x of Just x -> x Nothing -> -1 (im guessing not due to the -1)
13:54:51 <Nereid> :t fromMaybe (-1)
13:54:52 <lambdabot> Num a => Maybe a -> a
13:55:00 <xenocons> isnt fromJust\fromMaybe evil?
13:55:08 <Nereid> fromJust is. fromMaybe is not
13:55:08 <ski> `fromMaybe' is fine
13:55:11 <Nereid> @src fromMaybe
13:55:11 <lambdabot> fromMaybe d x = case x of {Nothing -> d;Just v  -> v}
13:55:12 <ninegrid> hi xenocons
13:55:19 <xenocons> ah right, heh
13:55:21 <xenocons> ninegrid: hey :)
13:55:25 <tdammers> fromMaybe is total, fromJust is not
13:55:32 <ski> (however `maybe' is more composable than `fromMaybe')
13:55:45 <ninegrid> Nereid: thanks
13:55:45 <simpson> :t maybe
13:55:46 <lambdabot> b -> (a -> b) -> Maybe a -> b
13:56:09 <Nereid> sure, fromMaybe x = maybe x id
13:57:19 <ski> `fromMaybe' is for the special case when you have a `Maybe a', and already have a sensible default value in `a' to use in the `Nothing' case
13:57:35 <Nereid> no
13:57:45 <sipa> :t fromMaybe
13:57:46 <lambdabot> a -> Maybe a -> a
13:58:12 <Nereid> ski: that is not where fromMaybe and maybe differ
13:58:38 <ski> `maybe' is for the more general case when you have a `Maybe a', and perhaps has no sensible default value in `a', but instead you are allowed to convert the `a' (if any) to any `b' you like, where you have a default value for `b'
13:58:40 <Nereid> oh, on the other hand:
13:58:49 <Nereid> maybe x f = fromMaybe x . fmap f
13:58:55 <Nereid> so neither is more general than the other
13:59:05 * ski didn't claim that :)
13:59:20 * Nereid didn't claim that anyone claimed or didn't claim it
13:59:43 <simpson> :t \x f -> fromMaybe x . fmap f
13:59:44 <lambdabot> b -> (a -> b) -> Maybe a -> b
13:59:47 * ski didn't claim that anyone claimed this claim
13:59:49 <shachaf> Nereid; I think requiring both fmap and fromMaybe is more than requiring just maybe
13:59:54 <xenocons> > fromMaybe (-1) (findIndex (== 'c') "abc")
13:59:56 <lambdabot>   2
13:59:58 <xenocons> > fromMaybe (-1) (findIndex (== 'c') "abt")
14:00:00 <lambdabot>   -1
14:00:01 <Nereid> I don't consider fmap to be much of a requirement.
14:00:03 <xenocons> perfect!
14:00:17 <shachaf> Nereid: You can do any deconstruction of a Maybe using just maybe.
14:00:20 <simpson> shachaf: That's what I thought, but fmap is applied on Maybe's Functor instance, isn't it?
14:00:22 <simpson> So it's okay.
14:00:23 <Nereid> sure.
14:00:24 <shachaf> You can't do any deconstruction of a Maybe using just romMaybe
14:00:31 <shachaf> simpson: ?
14:00:40 <Nereid> but to me, fmap is part of the structure of Maybe.
14:00:45 <simpson> shachaf: Oh, nevermind, I see what you're saying. Derp.
14:00:46 <Nereid> even if that's not explicit in the code.
14:01:08 <rwbarton> being able to pattern match is part of the structure of Maybe! so there
14:01:17 <Nereid> lol
14:01:41 <shachaf> Given (exists m. (m, forall a b. b -> (a -> b) -> m a -> b)) you can do whatever you want with the m
14:02:14 <Nereid> that is a kind error
14:02:20 <shachaf> Er, m a
14:02:41 <shachaf> Anyway, that's not true of (exists m. (m a, forall a. a -> Maybe a -> a))
14:02:53 <shachaf> s/Maybe/m/
14:04:02 <Nereid> but you can if m is a Functor
14:04:09 <Nereid> which is my point
14:04:44 <shachaf> I must have missed your point, then. :-)
14:06:58 <ski> i think `fromMaybe' vs. `maybe' is a bit like `catch :: Exception e => IO a -> (e -> IO a) -> IO a' vs. a possible `catchBind :: Exception e => IO a -> (e -> IO b) -> (a -> IO b) -> IO b' -- the latter is nicer to state laws in terms of, see "Exceptional Syntax" by Nick Benton,Andrew Kennedy in 2001 at <http://research.microsoft.com/en-us/um/people/akenn/sml/exceptionalsyntax.pdf>
14:07:30 <Nereid> don't get me wrong. I like maybe more than fromMaybe.
14:08:11 <Nereid> but I feel like Functor instances are morally intrinsic. if that even makes sense.
14:09:20 <`nand`> at the end of the day, I just use ‘fromMaybe’ when I want to use ‘fromMaybe’ and ‘maybe’ when I want to use ‘maybe’
14:09:21 <ski> (in the paper, they case `catchBind' as a combined `let'-`in' and `try'-`unless' construct : `try x <= M in P unliess E_0 => N_0 | ... | E_{n-1} => N_{n-1}')
14:09:46 <monochrom> I use safeFromJust :: Maybe a -> Maybe a :)
14:09:55 <`nand`> monochrom: haha
14:10:00 <elliott> monochrom: = unsafeCoerce?
14:10:01 <ski> (s/case/cast/)
14:11:59 <Nereid> `nand`: well yes, that's the reasonable thing to do.
14:15:25 <sclv> @remember monochrom I use safeFromJust :: Maybe a -> Maybe a
14:15:25 <lambdabot> I will remember.
14:16:02 <ski> @quote unjust
14:16:02 <lambdabot> SamB says: [on the subject of fromJust] SamB_XP thinks that unJust would be a more fun name for that
14:16:53 <illissius> ski: indeed, -fglasgow-exts did it, thanks
14:17:02 <illissius> and in newer GHCs it seems ? is called OpenKind
14:18:21 <`nand`> whoa, :browse is cool
14:18:27 * `nand` just used tab completion until now
14:18:33 * hpc hopes ?? is called OpenKindOpenKind
14:18:45 <`nand`> ClopenKind
14:20:34 <Clint> what do people get for fmap fileMode (getFileStatus x) where x is the path to a symlink?
14:21:09 <typoclass> clint: how do you mean? 'what do people get'?
14:21:20 <ski> illissius : oh
14:21:33 <Clint> typoclass: i am wondering if anyone gets the correct answer or if it's universally buggy
14:21:33 <glguy> he wants you to run that and report the result
14:22:27 <merijn> Clint: In what sense is it buggy?
14:22:53 <koala_man> Clint: 16872
14:23:04 <Clint> merijn: in the sense that i get the wrong fileMode (33188)
14:23:06 <Clint> koala_man: huh
14:23:09 <glguy> Clint: you know to convert that number to octal, right?
14:23:14 <Clint> yes
14:23:22 <Clint> but the point is that it's not the right mode, and isSymbolicLink fails
14:23:25 <typoclass> clint: i'd expect it'll tell you the permissions of the symlink. if you want the permissions of the file the symlink points to, you'd have to do readlink() or whatever the haskell equivalent is
14:23:34 <glguy> "100644" is a legal file mode
14:23:37 <Clint> yes
14:23:44 <Clint> but not of a symlink here
14:23:45 <glguy> What should it be
14:23:50 <Clint> /usr/include/bits/stat.h:#define        __S_IFLNK       0120000 /* Symbolic link.  */
14:23:55 <hpc> glguy: gah, what
14:24:01 <Clint> it should be 0120777
14:24:14 <JoeyA> Do people still use recent versions of the network package with Hugs?
14:24:20 <typoclass> clint: is 100644 the mode of the file that the symlink points to?
14:24:27 <elliott> do people still use hugs
14:24:28 <glguy> hpc: you’re going to have to be much more specific
14:24:37 <hpc> JoeyA: i think anyone using hugs is totally surrendering any semblance of "recent"
14:24:42 <Clint> typoclass: UGH, i'm an idiot
14:24:51 <hpc> glguy: what do the extra bits mean?
14:24:59 <typoclass> clint: anyway, i very much doubt that the "this is a symlink" flag will show up in the permissions
14:25:11 <merijn> JoeyA: I think people don't really use hugs
14:25:18 <typoclass> hpc: set group id, set user id, or sticky bit. i forgot which
14:25:22 <JoeyA> In other words, can we drop Hugs support from the network package?
14:25:25 <geekosaur> <Clint> /usr/include/bits/stat.h:#define        __S_IFLNK       0120000 /* Symbolic link.  */
14:25:29 <geekosaur> this is not what you think it is
14:25:40 <geekosaur> it is JUST the type bits, no a complete mode
14:25:41 <JoeyA> (I doubt anyone has tested it any time recently)
14:25:55 <Clint> geekosaur: yes, i am aware
14:25:58 <glguy> hpc: man fstat
14:26:04 <glguy> and look for the st_mode field
14:26:10 <geekosaur> then why are you complaing about what it "should be"?
14:26:13 <Clint> i just mixed up the descriptions of getFileStatus and getSymbolicLinkStatus
14:26:20 <JoeyA> A bunch of the system calls don't even check for errors under Hugs, due to a mistake in the #ifdefs I noticed.
14:26:23 <typoclass> ... on second thought, i'm not sure. 1755, 2755, 4755 are ok, but 100755 is news to me
14:26:42 <xenocons> victory!!
14:26:47 <xenocons> my first working haskell program
14:26:47 <geekosaur> typoclass, most utilities strip away the S_FMT bits
14:26:48 <glguy> typoclass: man fstat, /st_mode
14:26:50 <geekosaur> s_IFMT
14:26:54 <geekosaur> darn it, cannot type
14:26:56 <geekosaur> S_IFMT
14:27:11 <geekosaur> 1 is typical for a regular file
14:27:19 <merijn> xenocons: \o/
14:27:26 <`nand`> xenocons: main = return ()  -- ?
14:27:30 <xenocons> hah
14:27:34 <illissius> hpc: iirc ?? is ArgKind
14:27:38 <xenocons> 1 sec ill paste it (warning its probably very ugly)
14:28:06 <hpc> illissius: i was making a terrible joke on how hacky those old symbols were
14:28:07 <geekosaur> (S_IFMT are the bits describing the type of node, and are set on creation and cannot be changed.  the mode stuff like 1777 is the changeable part.)
14:28:16 <merijn> xenocons: I spend the entire week grading FP homework, I think it's impossible for you to surprise me :p
14:28:33 <glguy> Clint: I think it might be resolving the symlink
14:28:40 <Clint> glguy: yes, that's the problem
14:28:42 <illissius> hpc: sure! it would be cool if it were OpenOpenKind :)
14:28:46 <illissius> I was just being informative.
14:28:52 <glguy> getSymbolicLinkStatus
14:28:55 <glguy> Clint: try that?
14:28:57 <Clint> yup
14:28:57 <hpaste> xenocons pasted “first” at http://hpaste.org/78934
14:28:59 <`nand`> OpenerKind
14:29:04 <merijn> Clint, glguy: Try man 7 symlink?
14:29:11 <`nand`> just missing a ??? for OpenestKind
14:29:20 <merijn> Specifies that all syscalls except a specific set of listed ones will follow symlinks
14:29:29 <merijn> (on OSX, ymmv on other unices)
14:29:29 <glguy> The answer is that you should use getSymbolicLinkStatus
14:29:30 <illissius> `nand`, I think that would have to be ?????....
14:29:37 <illissius> not sure what the proper syntax is :)
14:29:38 <Clint> yes, it's all fixed up now
14:29:41 <glguy> merijn: The question is about the Haskell API, not the POSIX one
14:29:41 <xenocons> i suspect now that i have it 'chalked out' using let bindings, i can refactor using some composition
14:29:48 * hackagebot hledger-irr 0.1 - computes the internal rate of return of an investment  http://hackage.haskell.org/package/hledger-irr-0.1 (JoachimBreitner)
14:29:53 <geekosaur> note that fstat() can never see a symlink bevause symlinks are already resolved by the time a file descriptor is returned
14:29:53 <illissius> ? with a line above it
14:29:56 <hpc> :k ¿
14:29:56 <lambdabot> fd:9: commitBuffer: invalid argument (invalid character)
14:29:59 <`nand`> illissius: ?!?
14:29:59 <illissius> but I can't type that
14:30:17 <merijn> xenocons: Well, you can start with HLint's recommendations :)
14:30:36 <illissius> ski, Nereid: I can't resist a good mystery: by grepping the GHC source it turns out -fglasgow-exts enables all of the various language extensions, _and also_ -fprint-explicit-foralls, which is what actually controls the behaviour in question
14:30:38 <xenocons> merijn: didn't even see that
14:30:41 <xenocons> (i do now)
14:30:42 <ski> xenocons : `px ... xs = map (...) xs' can be simplified to `px ... = map (...)'
14:30:46 <Nereid> illissius: hah.
14:30:50 <ski> illissius : ty
14:30:58 <xenocons> ski: i had trouble removing that parameter
14:31:09 <Nereid> time to add -fprint-explicit-foralls to my ghci.conf :)
14:31:09 <xenocons> but it could have been due to my borged type signature
14:31:11 <merijn> xenocons: I would replace all uses of let/in with where
14:31:27 <rwbarton> -f! how sneaky
14:31:29 <xenocons> merijn: my F# implementation just chains it all together with composition and flip
14:31:44 <ski> xenocons : instead of nested `let'-`in', you can use a single `let'-`in' (or a `where') with (aligned) multiple declarations inside
14:31:44 <xenocons> (ill try to do the same in haskell
14:31:45 <xenocons> )
14:31:48 <Nereid> I guess it's technically not a language extension
14:31:51 <Nereid> just a change in ghci behavrious
14:31:52 <merijn> xenocons: And "((!!) s gxi) : [] )" can be simplified to "[s !! gxi]"
14:31:55 <Nereid> behaviour. whoa typo.
14:32:00 <xenocons> merijn: nice!
14:32:04 <xenocons> ski: noted, cool
14:32:08 <xenocons> this is exciting
14:33:10 <ski> xenocons : if you want to, you can "Annotate" your paste with updates
14:33:28 <xenocons> sure :)
14:33:33 <xenocons> good way to learn!
14:34:30 <xenocons> my findE could be: findE c = fromMaybe (-1) (elemenIndex c)?
14:34:45 <xenocons> er probably even findE = fromMaybe (-1) elemIndex
14:34:46 <ski> s/elemen/elem/
14:34:54 <xenocons> because the parameters are applied in order later on anyway
14:34:56 <ski>   findE = fromMaybe (-1) . elemIndex
14:35:00 <xenocons> right
14:35:02 <xenocons> cool
14:35:10 <ski> hm
14:35:29 <ski> no, not quite
14:35:42 <ski>   findE c xs = fromMaybe (-1) (findIndex (== c) xs)
14:35:44 <ski> is
14:35:51 <ski>   findE c = fromMaybe (-1) . findIndex (== c)
14:35:53 <ski> is
14:36:00 <ski>   findE c = fromMaybe (-1) . elemIndex c
14:36:09 <ski> if you really want to, you can say
14:36:10 <rwbarton> currying strikes again
14:36:22 <ski>   findE = (fromMaybe (-1) .) . elemIndex
14:36:23 <ski> or
14:36:30 <ski>   findE = fromMaybe (-1) .: elemIndex
14:36:35 <ski> provided that you define
14:36:39 <ski>   infixr 9 .:
14:36:45 <Heffalump> has anyone come across bytestring handle reading not working on non-FD handles?
14:36:46 <ski>   (.:) = (.) . (.)
14:36:52 <xenocons> hmm
14:37:05 <xenocons> strange
14:37:09 <xenocons> i guess its easier to leave the c in
14:37:14 <ski> xenocons : it's a tradeoff between readability and terseness/conciseness
14:37:24 <ski> you should should the version which is most clear to your
14:37:31 <ski> s/your/you/
14:37:32 <rwbarton> a tradeoff between readability and unreadability
14:37:51 * ski grins
14:38:01 <xenocons> i think findE c = fromMaybe (-1) . elemIndex c is the most readable to me
14:38:52 <merijn> xenocons: I would leave the c in, yes
14:39:16 <hpaste> merijn annotated “first” with “first (annotation: guards and where!)” at http://hpaste.org/78934#a78935
14:39:36 <merijn> xenocons: If you use guards + where I think the last function improves a lot too
14:39:49 <xenocons> oh nice, it does too
14:39:57 <xenocons> i want to remove 'm' and just make it an ADT
14:40:00 <xenocons> at some stage
14:40:00 <merijn> xenocons: Actually, you don't seem to use i anywhere?
14:40:15 <xenocons> merijn: good catch, typo
14:40:21 <xenocons> its meant to be in the decrypt
14:40:46 <xenocons> "Decrypt" -> x (-) b (*) i
14:41:25 <xenocons> it seems redundant to have to type m == "Encrypt"
14:41:40 <merijn> xenocons: Yes, you could replace the last one with "otherwise"
14:41:40 <xenocons> shouldnt you just be able to type Mode = Encrypt | Decrypt
14:41:50 <xenocons> | Encrypt = x (*) ...
14:41:58 <xenocons> | Decrypt = x (-) ..
14:42:01 <rwbarton> not 'type', 'data'
14:42:07 <xenocons> oops
14:42:11 <pqmodn> f (Decrypt) a b = ..
14:42:15 <pqmodn> f (Encrypt) a b = ..
14:42:21 <pqmodn> well, no parens
14:42:21 <ski>   f Decrypt a b = ...
14:42:26 <xenocons> oh right thats easy
14:42:50 <merijn> If you do that you can't use where to share the local functions, though
14:43:01 <xenocons> its silly to bind i to findModInverse anyway though
14:43:06 <xenocons> unless you are actually decrypting
14:43:09 <xenocons> but thats nitpicking i guess
14:43:12 <merijn> Ah, true
14:43:46 <mm_freak> :t putStrLn
14:43:47 <lambdabot> String -> IO ()
14:44:09 <merijn> Wait
14:44:19 <merijn> Why do you even have parentheses around the operators?
14:44:39 <xenocons> i dont need to?
14:44:54 <rwbarton> you do
14:44:54 <merijn> I'm actually surprised this is not a syntax error
14:45:05 <clahey> merijn: Why would it be?
14:45:06 <merijn> Unless I'm not paying attention to types...
14:45:09 <merijn> oh
14:45:11 <merijn> Wait
14:45:19 <merijn> x accepts them as arguments
14:45:25 <merijn> That's confusing :<
14:45:26 <clahey> > map (+) [3, 5] <*> [7, 8]
14:45:28 <lambdabot>   [10,11,12,13]
14:45:29 <xenocons> merijn: i win! 16:27 < merijn> xenocons: I spend the entire week grading FP homework, I think it's impossible for you to surprise me :p
14:45:41 <rwbarton> hahaha
14:47:02 <hpaste> merijn annotated “first” with “first (annotation: guards and where!) (annotation)” at http://hpaste.org/78934#a78936
14:47:21 <xenocons> oh nice
14:47:40 <xenocons> i just wrote something similar, but yours is much nicer :(
14:47:51 <hpc> @remember merijn <merijn> xenocons: I spend the entire week grading FP homework, I think it's impossible for you to surprise me :p <merijn> That's confusing :<
14:47:51 <lambdabot> Nice!
14:48:23 <merijn> hpc: I've still seen much worse, though
14:48:44 <hpc> challenge accepted!
14:48:47 <clahey> merijn: Why not derive Read?
14:49:39 <merijn> clahey: Dunno, was feeling arbitrary
14:49:56 <merijn> xenocons: I see why you're type signature (on px) is wrong, btw
14:50:14 <xenocons> yeh? i gave up on it, was driving me nuts
14:50:35 <merijn> xenocons: You have (amongst other things) (Int -> a -> b) as type for (+) and (-)
14:50:59 <xenocons> it isnt :( ?
14:51:07 <rwbarton> why does the function you pass map return a list?
14:51:10 <merijn> But those have types "Num a => a -> a -> a", although you could get away with a type like "Int -> Int -> Int"
14:51:22 <rwbarton> don't you get output like ["a","b","c"] then?
14:51:23 <xenocons> ah
14:51:27 <xenocons> rwbarton: i do
14:51:48 <xenocons> (although the data is correct, that is what i was aiming for atm)
14:52:01 <xenocons> is it better to fold instead of map or something?
14:52:07 <merijn> THat too
14:52:08 <xenocons> if you want to produce a string "abc"
14:52:13 <rwbarton> no, just don't build a list
14:52:20 <xenocons> oh
14:52:23 <rwbarton> in the function you pass to map, I mean
14:52:26 <merijn> Just have the lambda return Char instead of [Char]
14:52:35 <xenocons> heh, right
14:52:40 <rwbarton> then I think your type signature will be right
14:52:59 <rwbarton> it took me a while to figure out how the type signature was right! then I noticed it was commented out
14:53:18 <xenocons> heh
14:53:32 <merijn> rwbarton: Well, if you fix that it still complains becuase it can't determine that "Eq a => a ~ Int"
14:54:05 <merijn> But if you make the signatures of the operator functions more generic or less generic then it should work
14:54:19 <xenocons> hmm, right
14:54:26 <xenocons> well, first i want to remove the lambda \c
14:54:32 <xenocons> because if its only used once that feels redundant
14:55:18 <xenocons> surely i can do map (flip findE s . flip f x . g y . (!!) s) or something
14:55:33 <merijn> xenocons: You probably want either of these signatures:
14:55:33 <merijn> px :: Num a => String -> (a -> a -> a) -> a -> (a -> a -> a) -> a -> String -> String
14:55:38 <merijn> or
14:55:38 <merijn> px :: String -> (Int -> Int -> Int) -> Int -> (Int -> Int -> Int) -> Int -> String -> String
14:55:47 <xenocons> i think the second one is probably better
14:56:03 <merijn> Probably, yes
14:56:19 <rwbarton> really you should just pass (\n -> a * n + b) as the argument rather than all this (Int -> Int -> Int) -> Int -> (Int -> Int -> Int) -> Int -> stuff
14:56:24 <merijn> Well, "Integral a" probably makes more sense
14:56:39 <xenocons> in haskell you can do data integerfunction = (Int -> Int -> Int) ?
14:56:48 <xenocons> then use integerfunction in your type signature
14:56:53 <xenocons> rwbarton: ah
14:56:58 <merijn> xenocons: "type IntegerFun = Int -> Int -> Int"
14:57:00 <xenocons> rwbarton: thats probably neater
14:57:08 <xenocons> merijn: right okay
14:57:19 <merijn> xenocons: type introduces a type alias (i.e. the left hand is substituted with the righthand)
14:57:28 <xenocons> but isnt (a -> a -> a) different from a -> a -> a ?
14:57:30 <merijn> One example is "type String = [Char]"
14:57:45 <xenocons> (also im bloody confused about the difference between datatype, type and data in haskell)
14:57:48 <merijn> xenocons: Type aliases have implicit parens around them
14:58:09 <xenocons> hmm i see
14:58:18 <merijn> xenocons: data (the keyword) defines a datatype, type defines a type alias (it's really just a simple macro for another type)
14:58:38 <xenocons> hmm
14:58:45 <xenocons> and datatype ?
14:59:02 <SingingBoyo> xenocons: datatype is a general term for something defined by data/newtype.
14:59:05 <merijn> xenocons: There is no datatype keyword in haskell
14:59:25 <merijn> xenocons: data == datatype definition
14:59:34 <xenocons> (i wish someone made some kinda law that said 'there shall be one keyword and one keyword alone for abstract data types'
14:59:37 <xenocons> )
14:59:41 <merijn> xenocons: There is
14:59:46 <merijn> And it's "data"
14:59:57 <xenocons> so you can define a type alias with 'data' alone ?
15:00:12 <merijn> xenocons: No, because type aliases are not data types
15:00:23 <glguy> type makes a nickname, data defines a new datatype with new constructors
15:00:25 <xenocons> :( that is.. mental...hurdle
15:00:27 <elliott> Haskell has 0 keywords for *abstract* data types, really
15:00:54 <glguy> xenocons: don’t worry, lots of people have worked through this successfully
15:01:17 <ijp> do many haskellers actually use views?
15:01:18 <sipa> elliott: i'd say there is one: "class"
15:01:22 <merijn> xenocons: A type alias is just a shorthand for a longer type, if you'd use sed/find+replace/whatever to replace all type names with their right hand side, your code would still work
15:01:59 <aavogt> ijp: -XViewPatterns, or something more complicated?
15:02:01 <elliott> sipa: well, class is no more abstract than data, really
15:02:01 <xenocons> merijn: right, reason its a hurdle for me is that in some MLs (F#) you define a type alias using type, but also you can define any abstract data type with type
15:02:13 <ijp> aavogt: i know they are there, it was a question of popularity
15:02:29 <aavogt> I use them sometimes
15:02:49 <merijn> "type MyLongFun a b = a -> b -> a -> b -> a -> Int" means that wherever you write "MyLongFun Bool Char" in a type signature the compiler will treat it as "(Bool -> Char -> Bool -> Char -> Bool -> Char -> Bool -> Int)"
15:03:01 <ski> xenocons : .. but not in SML
15:03:07 <xenocons> ski: yeh true
15:03:24 <xenocons> been too long in MS land instead of MOSML land ;)
15:03:50 <ski> (however, O'Caml is like F# in this regard)
15:03:52 <merijn> xenocons: The main difference is "data" has data constructor on the right hand side, "type" has type constructors on the right hand side
15:04:04 <xenocons> right
15:04:19 <ski> (.. unsurprisingly)
15:05:22 <xenocons> hm, i have to go, thanks all for help, will be doing some more haskell this week for sure!
15:05:44 <xenocons> i have a rough idea how to join haskell functions together i think now
15:09:26 <|||tux||> What's the best way to parse a date and time of the type "13.08.2012 10:00"  (with error checking)? Is there a better way than to put everything in a maybe monad and use take drop and read?
15:09:50 <hpc> :t parseTime
15:09:51 <lambdabot> Not in scope: `parseTime'
15:10:00 <hpc> @hoogle formatTime
15:10:00 <lambdabot> Data.Time.Format class FormatTime t
15:10:00 <lambdabot> Data.Time.Format formatTime :: FormatTime t => TimeLocale -> String -> t -> String
15:10:00 <lambdabot> System.Time formatTimeDiff :: TimeLocale -> String -> TimeDiff -> String
15:10:10 <Ralith> |||tux||: if you want useful errors, I'd use Either, personally.
15:10:13 <hpc> there's a counterpart to formatTime that will interest you
15:16:26 <johkke> Is there any function predefined for selection every head when you've got an list of lists
15:16:50 <johkke> *selecting
15:17:01 <parcs`> johkke: are the lists guaranteed to be non empty
15:17:29 <johkke> Yes
15:17:37 <|||tux||> map head list ?
15:18:51 <johkke> |||tux|| thanks!
15:19:30 <parcs`> :t head . transpose
15:19:31 <lambdabot> [[a]] -> [a]
15:19:53 <xenocons> okay, my train doesn't leave for another 40 minutes
15:19:58 <xenocons> rwbarton: i just implemented what you suggested
15:21:01 <johkke> parcs` head list works better in my situation. But still thanks! :)
15:25:52 <shachaf> Cale: Can we have lens 3.7 in lambdabot?
15:25:54 <shapr> Cale: Got a reply from the lighthouse author: git://svcs.cs.pdx.edu/git/lighthouse.git
15:26:15 * shapr clones very slowly
15:26:27 <simpson> shapr: Oh snap, it's alive?
15:26:42 <simpson> Also it occurs to me that I can and should poke the PSU people directly. Like with sticks.
15:27:22 <shapr> simpson: Well, I emailed Kenneth Graunke since his lighthouse webpage is gone, so he pointed me to that git repo.
15:27:35 <shapr> simpson: I just don't want to lose that source forever :-)
15:28:12 <simpson> !!!
15:28:22 <simpson> I know him from Mesa! He does graphics for Intel.
15:28:51 <shapr> Cool, I had no idea.
15:28:58 <shapr> simpson: I'm guessing you're Corbin?
15:29:23 <xenocons> bingo!
15:29:38 <simpson> shapr: Yes.
15:29:49 * hackagebot simple-sendfile 0.2.10 - Cross platform library for the sendfile system call  http://hackage.haskell.org/package/simple-sendfile-0.2.10 (KazuYamamoto)
15:30:01 <simpson> I'm one of the non-cool groupies.
15:30:31 <shapr> heh, various webpages imply that you are in fact, cool.
15:30:40 <simpson> I wish. :c
15:31:26 <shapr> simpson: Hi, I'm Shae!
15:31:46 <simpson> shapr: Hi! Have we met and not realized it?
15:31:47 <navaati> hi
15:32:01 <pqmodn> hi!
15:32:01 <shapr> simpson: Oh, probably not. But next time I'm in the Northwest I'll make an effort to meet you.
15:32:17 <navaati> really, these type level nats are difficult to use…
15:32:38 <shapr> simpson: I mostly do Haskell community organizing things. One of the tasks I give myself is to archive nifty Haskell source code.
15:32:41 <merijn> navaati: Well, there's no type level arithmetic/comparison yet, so yes
15:32:49 <simpson> shapr: Awesome.
15:32:59 <navaati> i've got a "getResolution (f ∷ Fixed r) = fromSing (sing ∷ Sing r)" where "newtype Fixed (r ∷ Nat) = MkFixed Integer"
15:33:11 <navaati> (so no arithmetic needed ;)
15:33:13 * simpson is off to find junk food
15:33:30 * elliott resists the temptation to plug reflection to navaati
15:33:31 <navaati> and i get an error "No instance for (SingI Nat r) arising from a use of `sing'"
15:33:35 <navaati> grmbl
15:34:09 <shapr> So the lighthouse license seems sufficiently OSS to be able to put it up on github.
15:34:10 <shapr> Well, mostly.
15:34:20 <shapr> I think I should pursue a real OSS license for Gadgets :-/
15:34:56 <navaati> well, reflection is not exactly what i want, i guess : here the interest is to use "f :: Fixed 15" and have automatically precision to the 1/15
15:35:39 <tanob> hey, I was playing a little bit with webdev with Haskell and using hack2 because I'm already familiar with servers like Rack. Now I'm looking for some templating language for the pages, any suggestion?
15:35:45 <hpaste> xenocons pasted “first2” at http://hpaste.org/78937
15:35:56 <xenocons> rwbarton: fixed it using your suggestion
15:36:02 <xenocons> much neater now!
15:36:15 <navaati> seems that typenats look like a cool idea but the implementation make them very hard to use…
15:36:31 <merijn> xenocons: I would actually have the function bodies for short definitions like here on the same line as the = sign
15:36:50 <shapr> tanob: I know that Yesod has its various templating languages, hamlet for html, cassius for css and Julius for javascript: http://www.yesodweb.com/book/shakespearean-templates
15:36:51 <xenocons> merijn: is there a style guidelines thing for this?
15:37:00 <merijn> xenocons: Not really, I think?
15:37:04 <xenocons> oh
15:37:05 <xenocons> hmm
15:37:17 <elliott> navaati: well, you can do things like that
15:37:19 <tomeo> The type Fractional a => a -> a, does that mean that my function will take all kinds of fractional values? Like float, double and so on
15:37:21 <xenocons> i guess if its less than 74 col (or is it 76) its best to be on one line?
15:37:30 <Peaker> JonFairbairn, if you're still wondering, I think I know why you're getting the segfaults
15:37:31 <merijn> xenocons: I try to stick with 80 chars per line, so if it'll fir without wrapping I keep it on one line
15:37:36 <elliott> navaati: just you use the type reify gives you rather than saying 15 directly
15:37:43 <merijn> tomeo: Yes
15:37:44 <elliott> but yes, probably type-level nats are more convenient for your use-case
15:37:46 <Peaker> what I wonder is: I installed the freetype2 package on Windows successfully -- but it has a bunch of c files. How did they get built? I don't think there's any C compiler installed there (unless one is included with the Haskell Platform?)
15:37:56 <xenocons> merijn: okay that makes sense, i will do just that
15:37:59 <tanob> shapr: yep, was looking several of them yesterday on Haskell's wiki but I'm not a fan to leave the template inside the Haskell code, would like to have them external.
15:38:19 <xenocons> oh man, now i have to go back and fix up my F# version heh
15:38:19 <tomeo> merijn: so redefining it as Double -> Double would make it stricter, which may or may not be a good idea depending on application?
15:38:31 <merijn> tomeo: Yup
15:38:31 <shapr> tanob: I'm pretty sure the Shakespearean templates are that way by default.
15:38:36 <tomeo> thanks a bunch merijn
15:38:42 <shapr> tanob: At least, I was able to use them that way this past summer.
15:39:10 <Peaker> oh, it comes with a binary for windows
15:39:13 <merijn> tomeo: Keep in mind that in many cases GHC can (at least partially) inline/specialise typeclass uses, eliminating most of the overhead of using them
15:39:35 <tanob> shapr: oh, I think that's true, I'm confused with some other alternatives like blaze-html :)
15:39:49 <tomeo> merijn: okay :)
15:39:58 <shapr> tanob: I haven't tried to use Yesod's templates outside of Yesod, if it works for you, I'll start using them with scotty.
15:40:17 <shapr> scotty is currently my favoret Haskell web framework, but I use Yesod more because it covers EVERYTHING you could ever need.
15:40:20 <shapr> favorite*
15:40:25 <shapr> Jag kan inte stava :-|
15:41:18 <merijn> @remember andr00 Today's software engineering word is "farpotshket." This is a Yiddish word meaning, "broken, because someone tried to fix it."
15:41:18 <lambdabot> Okay.
15:41:33 <shapr> merijn: Ooh, I like that.
15:41:36 <shapr> @quote
15:41:36 <lambdabot> hongos_malos says: Esta ingestin provoca una enfermedad mortal llamada ergotismo, que en la Edad Media era conocida como fuego de San Antonio.
15:41:39 <shapr> um
15:41:42 <shapr> @quote Haskell
15:41:42 <lambdabot> Haskell says: I'm a bitching language
15:41:44 <shapr> @quote Haskell
15:41:44 <lambdabot> Haskell says: I'm a bitching language
15:41:46 <shapr> uhh
15:41:49 <shapr> @quote haskell
15:41:49 <lambdabot> haskell says: wow am I in the wrong chat maybe?
15:41:52 <shapr> Ok, nm
15:42:41 <Saizan> @quote *haskell*
15:42:41 <lambdabot> Plugin `quote' failed with: regex failed: (ReturnCode 13,"Invalid preceding regular expression")
15:42:59 <Saizan> @quote .haskell
15:42:59 <lambdabot> ghc says: Can't represent a guarded lambda in Template Haskell
15:44:54 <shapr> I keep meaning to fix lambdabot's quote plugin, but I can never get lambdabot to build.
15:45:48 * bgamari was very surprised to learn that hamlet doesn't support record syntax even slightly
15:45:50 <tanob> shapr: also looked scotty but I see it uses WAI, dunno what are the real differences between WAI and hack2. I see more ppl using yesod for web than these microframeworks
15:45:51 <Peaker> oops, freetype2 doesn't contain windows binaries.after all -- and yet it installed successfully on a computer that just had the Haskell Platform
15:45:58 <Peaker> What magic is this? does the HP come with C compilers?
15:46:06 <Peaker> (For Windows?)
15:46:13 <bgamari> I really don't know how people work around this
15:46:15 <shapr> tanob: I agree, Yesod is more popular than scotty, I just prefer the simplicity of scotty.
15:47:25 <tanob> shapr: agree, I'm just starting with webdev with Haskell and Yesod just scares me with complexity, was trying to go step by step and glue frameworks by myself :)
15:48:15 <tanob> there's also miku, would need to check which one is more well-maintaned
15:48:28 <tanob> maintained*
15:51:45 <illissius> hermf
15:52:56 <monochrom> as it happens, windows Haskell Platform contains part of mingw, which contains a C compiler
15:53:25 <illissius> am I right that there's absolutely no way to produce a value of type State# Thingamabob, where Thingamabob is anything that's not RealWorld, except by using unsafeCoerce#? (for State# RealWorld there's realWorld#)
15:54:24 <monochrom> I don't know. but I am unconvinced that you absolutely must produce such a value.
15:56:25 <bgamari> illissius, What are you doing that you would need such a thing?
15:56:54 <illissius> bgamari: on the one hand, I'm just plain curious
15:57:51 <illissius> bgamari: on the other hand I'm wondering if a type with that property might be useful for something like http://typesandkinds.wordpress.com/2012/12/01/decidable-propositional-equality-in-haskell/ in place of 'Falsehood', so you couldn't just make one with undefined
15:58:00 <illissius> (but you still could with unsafeCoerce#, so...)
15:58:22 <k0001> tanob shapr: Just adding my point of view here. I was under the same impression of Yesod being more complex than the alternatives. Two days ago I decided to go ahead and read Yesod's book, and realized that most of the complexity I percieved came from the automagic scaffolding Yesod optionally provides, which makes use of many of the Yesod available features at the same time. Considering each of those features can be understood and used se
16:04:32 <tanob> k0001: thanks :) I think it is pretty similar to what exists in the Ruby ecosystem with Rails and Sinatra-likes, the latter is pretty minimal - you can lookup how to do things pretty fast, the former has lots already there, sometimes it is scary. I remember my first thoughts on Rails too, "from where is this coming? how does it work?", too many magic and things to look up :)
16:06:58 <cmccann> "a wizard did it"
16:07:24 <cmccann> kinda think snoyman is a better wizard than the rails guy though
16:14:53 <johkke> How do I need to filter out elements of an list, that don't meet an certain condition in an other list?
16:15:15 <johkke> Filter only seems to work with one list
16:15:36 <navaati> define "meet an certain condition"
16:16:07 <tcrayford> seems like you could do that with zip and filter
16:16:39 <tcrayford> filter (\(a,b) -> pred b) (zip list1 list2)
16:17:49 <johkke> I need to filter out in list A ([a]) all the elements that aren't first in an other list [[a]]
16:18:18 <tcrayford> oh, that's just set exclusion, right?
16:18:36 <tcrayford> doing that with lists might be slow for large lists, but:
16:19:11 <tcrayford> filter (not . (`elem list2))
16:19:19 <tcrayford> typo
16:19:29 <tcrayford> filter (not . (`elem` list2)) list1
16:20:06 <johkke> tcrayford let me have a try! Thanks in advance already :P
16:21:03 <johkke> What does that dot do? I haven't seen that before
16:22:10 <cmccann> > (f . g) x
16:22:11 <lambdabot>   Ambiguous type variable `a0' in the constraints:
16:22:11 <lambdabot>    (GHC.Show.Show a0)
16:22:11 <lambdabot>     ...
16:22:15 <cmccann> bah
16:22:21 * cmccann can't remember how to make that work
16:24:15 <shapr> tanob: I've not even heard of miku
16:25:32 <johkke> sipa zijt ge hier nu terug? :O
16:29:31 <fmap> > ((f :: Expr -> Expr) . g) x
16:29:33 <lambdabot>   f (g x)
16:31:34 <cmccann> fmap, aha thanks.
16:31:45 <cmccann> that was for johkke btw
16:31:53 <cmccann> to show what (.) does
16:32:35 <latermuse> the (.) is for function composition
16:32:49 <latermuse> (b -> c) -> (a -> b) -> a -> c
16:33:07 <johkke> thanks all! :)
16:35:04 <cmccann> johkke, so in the case of filtering, it's negating the result of elem
16:35:19 <cmccann> apparently because tcrayford forgot that notElem is a thing ;]
16:39:03 <cmccann> is there a quasi-standard non-empty list type on hackage that most people use?
16:39:10 <cmccann> or is this one of those things where everyone rolls their own :[
16:39:32 <dmwit> rollin' rollin' rollin', RAWHIDE!
16:40:16 <cmccann> :[
16:40:27 <dmwit> cmccann is a sad robot
16:40:33 <djahandarie> cmccann, if you can find the different ones, I suppose we could check reverse deps and see which is more popular
16:40:50 <cmccann> djahandarie, yes but that's already more effort than I'd hoped to expend on this
16:40:50 <elliott> cmccann: edwardk has one
16:40:53 <djahandarie> Ed has one in semigroups
16:40:57 <elliott> so use that one
16:41:12 <cmccann> oh well if edwardk has one that changes matters
16:41:17 * elliott honestly uses edwardk as a way to decide which package to use
16:41:21 <cmccann> since I'm guaranteed to indirectly depend on it anyhow
16:41:33 <elliott> haha
16:41:35 <edwardk> cmccann: hahaha
16:41:50 * elliott wishes that NonEmpty was in a more obvious package
16:42:05 <djahandarie> Yeah, it'd be nice if that was in a seperate package, actually.
16:42:45 <elliott> looks like "nonempty" is available :P
16:42:55 <cmccann> yeah, my prelude-replacement alone pulls in maybe a half dozen edwardk packages
16:43:00 <djahandarie> elliott, oh God.
16:43:02 <djahandarie> Please no.
16:43:07 <djahandarie> NonEmpty is taken.
16:43:11 <elliott> djahandarie: even better
16:43:19 <cmccann> hooray for case-sensitivity!
16:43:22 <elliott> edwardk wasn't afraid to take lens even though lenses was taken!
16:43:31 <edwardk> cmccann: i just decided to name my prelude-replacement 'lens' and see who noticed.
16:43:35 <elliott> lol
16:43:36 <cmccann> haha
16:43:56 <cmccann> elliott: edwardk names package and doesn't afraid of anything
16:44:22 <elliott> pretty sure edwardk afraids of users
16:44:30 <edwardk> it helps to have remarkably thick skin, and be big enough to not fear physical intimidation ;)
16:44:57 <cmccann> nobody messes with tall guys who have vaguely malevolent facial hair
16:45:01 <elliott> so this proves once and for all that edwardk is a troll!
16:45:09 <edwardk> elliott: i finally decided to face that fear with lens. i'm trying out having users to see how bad it is.
16:45:25 <dmwit> pfft, I could take you
16:45:34 <elliott> edwardk: we are complaining extra hard to give you the full experience
16:45:47 <djahandarie> edwardk, the package documentation is definitely getting better.
16:45:51 <dmwit> just aim for the knees
16:45:53 <djahandarie> Especially with that github wiki.
16:45:53 <edwardk> dmwit: you'd mop the floor with me in go at least ;)
16:45:57 <dmwit> ;-)
16:46:26 * cmccann notes that there seems to be a NonEmpty and a NonEmptyList already
16:46:33 <cmccann> and of course, the latter includes more than one data type
16:46:49 <elliott> clearly NonEmpty needs generalising
16:46:56 <elliott> newtype NonEmpty f a = NonEmpty a (f a)
16:46:59 <mikeplus64> @src (/)
16:46:59 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
16:47:00 <elliott> er data
16:47:02 <cmccann> whereas the former only has a non-empty list type
16:47:12 <edwardk> djahandarie: we have a wiki, small examples, big examples, hundreds of doctests, thousands of extra signatures you can use to think about the combinators with, laws, a faq, pretty much anything i can think of to encourage adoption
16:47:28 <aristid> mikeplus64: (/) is a class method and the implementation is type-dependent.
16:47:33 <elliott> just needs a good tutorial
16:47:42 <mikeplus64> aristid: oops i was scrolled up very very far
16:47:47 <mikeplus64> when someone tried :source (/)
16:48:11 <djahandarie> edwardk, well, making it not scary still needs work, I think.
16:48:35 <djahandarie> Especially this page: http://hackage.haskell.org/package/lens
16:48:55 <AtomicStryker> hey gents, could someone point out to me how to declare a data type in haskell that includes a list of ... things
16:49:05 <dmwit> ?src
16:49:05 <lambdabot> src <id>. Display the implementation of a standard function
16:49:09 <dmwit> ?src [a]
16:49:09 <lambdabot> Source not found. My pet ferret can type better than you!
16:49:14 <dmwit> ah well
16:49:17 <aristid> djahandarie: clearly the diagrams need to contain friendly smileys, indeed
16:49:21 <dmwit> AtomicStryker: What's wrong with [a]?
16:49:39 <AtomicStryker> mh ... what does the a stand for ... or was that the type
16:49:57 <AtomicStryker> i thought it was Int[] not [Int] herp
16:49:57 <edwardk> i'm not so good at doing the 'not scary' part. ;)
16:50:01 <dmwit> It's a type variable. You can make it a concrete type if you know what concrete type you want.
16:50:09 <dmwit> Nope, it's [Int]. =)
16:50:18 <AtomicStryker> yeah thanks, problem solved xD
16:50:25 <Jafet> []Int
16:50:34 <cmccann> that works too
16:50:44 <AtomicStryker> ... why would they allow that
16:50:47 <AtomicStryker> but not Int[]
16:50:56 <dmwit> Because [] is a function but Int isn't. =)
16:50:56 <cmccann> because [] is the type constuctor
16:51:00 <shachaf> @src []
16:51:00 <lambdabot> data [] a = [] | a : [a]
16:51:03 <cmccann> :k []
16:51:05 <lambdabot> * -> *
16:51:25 <cmccann> you can also write "(->) A B" instead of "A -> B"
16:51:27 <djahandarie> :t [1,2,3] :: [] Int
16:51:28 <lambdabot> [Int]
16:51:30 <cmccann> not that you generally want to
16:51:38 <dmwit> Or, to say it another way: why should accepting []Int imply accepting Int[]?
16:52:04 * djahandarie thinks spaces are useful
16:52:27 <djahandarie> []Int is particularly weird because it's not using a space for application.
16:53:27 <djahandarie> Of course, space is not application, it's juxtaposition, and those are parsed as two seperate tokens, which is why it works, but I don't think that'd be immediately clear for most people ;).
16:53:41 <AtomicStryker> another question. i tried the "giving data .. fields? contents? names thing" like data DerpType = Derp {herp :: Int, derp :: Int}
16:53:43 <monochrom> flame war seed: http://thread.gmane.org/gmane.comp.lang.haskell.cafe/102087 :)
16:54:15 <AtomicStryker> i was under the impression i could then make another data HerpType = Herp {herp :: Int, derp :: Int}
16:54:31 <AtomicStryker> but apparently, herp and derp are taken now
16:54:34 <monochrom> no, cannot have duplicate field names like that
16:54:41 <dmwit> Yes, you have to put that in a separate module.
16:54:44 <AtomicStryker> they are not private
16:54:56 <AtomicStryker> is there a smart reason for this
16:54:57 <dmwit> Private and public are not really a thing in Haskell. =)
16:55:00 <monochrom> however, this is allowed: data Two = One { herp :: Int } | Two { herp :: Int }
16:55:11 <dmwit> Privacy is done via the module mechanism.
16:55:14 <monochrom> there is no smart reason for this
16:55:20 <Axman6> boop
16:55:25 <AtomicStryker> then i call it stoopid
16:55:34 <mikeplus64> AtomicStryker: herp and derp are functions defined in that record as HerpType -> Int
16:55:50 <dmwit> I feel like "there is no smart reason for this" isn't really accurate.
16:56:05 <dmwit> There's no critically acclaimed record system that's unilaterally better than what we have now.
16:56:27 <djahandarie> AtomicStryker, well, the field name is used as the deconstructor for values of that type, so if you allowed non-unique field names, you'd need to somehow support overloaded functions. So there isn't an immediately obvious answer.
16:56:27 <dmwit> (Though there are many proposals that are better in one dimension or another, and lots of people think their dimension is the most important.)
16:56:32 <mikeplus64> if you could define herp and derp somewhere else, they'd have different types, which would be very confusing
16:57:03 <AtomicStryker> but arent they defined by the data i am definining them in
16:57:20 <AtomicStryker> like, if i am using DerpType its a DerpType derp
16:57:28 <AtomicStryker> which is completely different from HerpType derp
16:57:31 <dmwit> How do you know if you are using DerpType?
16:58:03 <AtomicStryker> uuuh ... pattern matching or whatever it was called?
16:58:13 <monochrom> it is accurate. other language communities managed to reach a consensus on their record systems. we haven't managed. that is a reason, and a non-smart reason.
16:58:25 <dmwit> What if I just write "foo = derp" and don't have any pattern matching around?
16:58:29 <mikeplus64> AtomicStryker: so if record field access wasn't defined with normal functions then i think it would be O.K. to have data X = X { x :: Int } and data Y = Y { x :: something else }
16:58:35 <dmwit> Should "foo" use HerpType's derp or DerpType's derp?
16:58:54 <AtomicStryker> im thinking very much like java here, youll have to excuse me
16:58:56 <dmwit> (Or "foo x = derp x" if you're not comfortable with eta reduction yet. =)
16:59:05 <monochrom> of course, record systems in other languages aren't unilaterally best in all aspects either. that has never stopped them.
16:59:48 <dmwit> We have reached a consensus in exactly the same sense other language communities have: there's an implementation with a record system. =)
17:00:12 <monochrom> where do we have an implemented record system?
17:00:18 <dmwit> GHC
17:00:27 <monochrom> I haven't seen it in GHC
17:00:32 <cmccann> AtomicStryker, while it's true there's no "smart reason" for it the obvious alternatives are, in the context of Haskell, significantly worse overall
17:00:34 <Axman6> ...
17:00:35 <Nereid> there are various proposals/etc for improved records but none of them have really caught on.
17:00:38 <dmwit> Don't pretend that records don't exist in Haskell.
17:00:46 <dmwit> That's even more disingenuous than usual for you.
17:00:53 <Jafet> -XCardsGoneWild
17:00:56 <cmccann> dmwit, we've also reached consensus that the current approach sucks, and consensus that there's no consensus on how to change it
17:01:03 <dmwit> cmccann: all true
17:01:09 <monochrom> are you saying that Haskell 2010 already has a record system?
17:01:26 <Axman6> there seems to be movement towards a consensus that lenses are a better aproach
17:01:38 <Axman6> now we need to figure out how to lenses properly =)
17:01:46 <Nereid> Axman6: lenses don't really constitute a record system
17:01:59 * cmccann suspects monochrom is using some definition of "record system" here contrived for the purpose of supporting some point.
17:02:12 <simpson> No true record system~
17:02:20 <Axman6> indeed, but they (can) solve a lot of the problems we have with the current record system
17:02:26 <Nereid> sure.
17:02:30 <edwardk> Nereid: not directly but with makeClassy i can general get to the point where i don't notice the lack of one
17:02:32 <Nereid> well,
17:02:40 <Nereid> edwardk: heh
17:02:47 <dmwit> monochrom: 4.2.1 of the spec, the "Labelled Fields" subsection
17:02:56 <elliott> > 2+2
17:02:57 <lambdabot>   Could not find module `Data.Monoid.Lens'
17:02:57 <lambdabot>  It is a member of the hidden pack...
17:02:59 <elliott> who broke lambdabot
17:03:05 <edwardk> oh did we upgrade?
17:03:07 <monochrom> no, I am not using any exact definition of record system. I am just using feeling. SML has something that I feel is a record system. Haskell's story doesn't feel like a record system to me. but I'm fine with you disagreeing.
17:03:11 <Nereid> caaaaaaaale!
17:03:15 <edwardk> :t farthest
17:03:15 <lambdabot> Not in scope: `farthest'
17:03:19 <Nereid> yeah, Data.Monoid.Lens no longer exists right?
17:03:22 <edwardk> yeah
17:03:24 <elliott> edwardk: you call this an upgrade
17:03:26 <mikeplus64> :t makeClassy
17:03:26 <lambdabot> Not in scope: `makeClassy'
17:03:26 <edwardk> Data.Monoid.Lens is gone
17:03:40 <Nereid> Cale !
17:03:46 <dmwit> Okay, I need to get something done.
17:03:55 <Cale> oh
17:03:55 <Nereid> > 2+2
17:03:56 <lambdabot>   Could not find module `Data.Monoid.Lens'
17:03:56 <lambdabot>  It is a member of the hidden pack...
17:03:57 <Nereid> > ()
17:03:58 <lambdabot>   Could not find module `Data.Monoid.Lens'
17:03:58 <lambdabot>  It is a member of the hidden pack...
17:03:59 <djahandarie> dmwit, nevar, IRC will hold you hostage forevar.
17:04:00 <Nereid> huh
17:04:10 <Nereid> must have happened in the last few hours or so then
17:04:18 <monochrom> yeah, you should educate me on what record means
17:05:25 <Cale> @undefine
17:05:28 <Cale> > 1
17:05:31 <lambdabot>   1
17:05:37 <Axman6> a circular disk, often made from pressed vinyl, quite often used for the distribution of music
17:05:38 <Nereid> records are product types. haskell has product types. therefore, haskell has records.
17:05:39 <cmccann> it's what guinness puts in their book
17:05:40 * djahandarie hums "We are programmed to receive, you can check-out any time you like, but you can never leave."
17:05:59 <Nereid> what we could use is a more convenient way of dealing with records.
17:06:02 <Hafydd> It's a type of red-tinted potato.
17:06:47 <shachaf> Cale: Hooray!
17:07:09 <edwardk> :t farthest
17:07:10 <lambdabot> (a -> Maybe a) -> a -> a
17:07:15 <edwardk> :t farthest leftward
17:07:16 <lambdabot> (h :> a) -> h :> a
17:07:27 * edwardk hugs cale
17:07:43 <Nereid> :>
17:07:44 <djahandarie> :t ala
17:07:46 <lambdabot> Wrapped s s a a => (s -> a) -> ((s -> a) -> e -> a) -> e -> s
17:07:49 * djahandarie glares at edwardk
17:07:52 <edwardk> djahandarie: you should be proud
17:07:59 <edwardk> it works like Newtype now
17:08:04 <monochrom> soon, we will have lens expressions such as "south farthing"
17:08:08 <edwardk> :t ala Sum foldMap [1,2,3,4]
17:08:09 <lambdabot> Num s => s
17:08:12 <edwardk> > ala Sum foldMap [1,2,3,4]
17:08:14 <lambdabot>   10
17:08:23 <edwardk> > au (wrapping Sum) foldMap [1,2,3,4]
17:08:25 <lambdabot>   10
17:08:34 <Axman6> :t au
17:08:35 <elliott> djahandarie: you sohuld be horrified
17:08:35 <lambdabot> AnIso s t a b -> ((s -> a) -> e -> b) -> e -> t
17:08:37 <elliott> it works like Newtype now
17:08:41 <monochrom> and generally names from the Toikien world!
17:08:55 <mikeplus64> edwardk: is there a way to update multiple "fields" of a lens at once?
17:09:10 <edwardk> monochrom: rightward/leftward were a sop to Control.Arrow so we couldn't have to collide with left/right
17:09:11 <monochrom> "one simply ^_2 into Mordor"
17:09:24 <cmccann> I still prefer "dextral" and "sinistral".
17:09:38 <Nereid> mikeplus64: x & l1 .~ a & l2 .~ b
17:09:38 <edwardk> > (4,5)^.both *~ 2
17:09:40 <lambdabot>   No instances for (GHC.Num.Num (Control.Lens.Internal.Mutator t0),
17:09:40 <lambdabot>          ...
17:09:44 <Nereid> ?
17:09:48 <cmccann> though "turnwise" and "widdershins" are also acceptable
17:09:48 <Peaker> Do I need to tell cabal anything in the .cabal to use haskell2010 stuff? ghci insists on -package haskell2010 stuff just to get the new modules in the FFI
17:09:52 <edwardk> > (4,5) & both *~ 2
17:09:54 <lambdabot>   (8,10)
17:09:57 <Nereid> although that's not "a lens"
17:09:59 <edwardk> heh forgot my own package for a sec
17:09:59 <Hafydd> What about "port" and "starboard"?
17:10:00 <djahandarie> :t ala Cont traverse
17:10:01 <lambdabot>     Not in scope: data constructor `Cont'
17:10:01 <lambdabot>     Perhaps you meant one of these:
17:10:01 <lambdabot>       `Const' (imported from Control.Applicative),
17:10:04 <merijn> Peaker: default-language, I think?
17:10:06 <shachaf> It would be nice if there was a way to export a prism without depending on lens.
17:10:06 <mikeplus64> :t (*~)
17:10:07 <lambdabot> Num a => Setting s t a a -> a -> s -> t
17:10:08 <cmccann> Hafydd, also fine
17:10:10 <mikeplus64> :t (&)
17:10:11 <lambdabot> a -> (a -> b) -> b
17:10:14 <elliott> shachaf: there sort of is, isn't there
17:10:19 <shachaf> Is there?
17:10:20 <Jafet> Port and sherry
17:10:22 <mikeplus64> :t both
17:10:23 <lambdabot> Applicative f => (a -> f b) -> (a, a) -> f (b, b)
17:10:26 <edwardk> :t ala Backwards traverse
17:10:28 <lambdabot> Not in scope: data constructor `Backwards'
17:10:29 <elliott> shachaf: well nothing actually takes Prism itself does it
17:10:34 <elliott> so you can define your own equivalent class
17:10:36 <Peaker> merijn, any idea about how to tell ghci to have h2010 stuff?
17:10:38 <Nereid> no, they take APrism
17:10:52 <merijn> Peaker: Not really
17:10:58 <edwardk> elliott: the data type or class would have to be available
17:11:09 <elliott> i guess your users have to give an instance to use lens combinators
17:11:17 <mikeplus64> :t _1
17:11:19 <lambdabot> (Functor f, Field1 s t a b) => (a -> f b) -> s -> f t
17:11:38 <mikeplus64> lens is terrifying
17:11:52 <edwardk> mikeplus64: that is solely used as a hack to permit
17:11:58 <edwardk> > (4,5)^._2
17:12:00 <lambdabot>   5
17:12:01 <edwardk> > (4,5,6)^._2
17:12:03 <lambdabot>   5
17:12:05 <edwardk> > (4,5,6,7)^._2
17:12:07 <lambdabot>   5
17:12:08 <edwardk> etc.
17:12:22 <shachaf> > (4,5,6,7,8,9,10,11,12,13)^._2
17:12:24 <lambdabot>   Could not deduce (Control.Lens.Tuple.Field2
17:12:24 <lambdabot>                      (t1, t2, t...
17:12:25 * elliott doesn't like this encouragement of big tuples
17:12:32 <edwardk> :t let my_2 f (a,b) = (,) a <$> f b in my_2
17:12:33 <lambdabot> Functor f => (t -> f a) -> (a1, t) -> f (a1, a)
17:12:40 <edwardk> thats what it works out to in practice
17:12:48 <mikeplus64> :t _2
17:12:49 <lambdabot> (Functor f, Field2 s t a b) => (a -> f b) -> s -> f t
17:13:05 <elliott> I guess I can see an argument for _3 existing.
17:13:06 <mikeplus64> edwardk: could a fromInteger for _2, _1, etc be made?
17:13:13 <Nereid> they exist up to _9
17:13:17 <edwardk> there is an instance Field2 (a,b) (a,b') b b'
17:13:32 <edwardk> mikeplus64: no they are higher rank, it wouldn't dispatch even if it could
17:13:53 <Nereid> (1,2,3,4,5,6,7,8,9) ^. _7
17:13:56 <Nereid> > (1,2,3,4,5,6,7,8,9) ^. _7
17:13:57 <edwardk> they end at 9-tuples
17:13:57 <lambdabot>   7
17:14:03 <Peaker> ghci -package haskell2010 conflicts with base... how do I tell it to avoid base?
17:14:16 <mikeplus64> edwardk: higher rank? dispatch?
17:14:23 <edwardk> Peaker: just don't use the haskell2010 its a great way to cripple yourself
17:14:37 <Nereid> what is it even?
17:14:46 <Nereid> ah
17:14:47 <edwardk> mikeplus64: lenses have a 'forall' in a funny place in the signature that keeps you from doing certain things with them
17:15:09 <AtomicStryker> another question: how do i instantiate a data type in my .hs file without getting a top level naked expression error
17:15:18 <Nereid> instantiate?
17:15:28 <AtomicStryker> get/save/show an instance
17:15:39 <monochrom> ghci -package haskell2010 -hide-package base
17:15:55 <Nereid> AtomicStryker: I don't know what that means.
17:16:06 <AtomicStryker> say i have data DerpType = Derp {herp :: Int, derp :: Int} again
17:16:25 <AtomicStryker> then i want to put something like show (Derp 1 2)
17:16:30 <mikeplus64> AtomicStryker: data X = ... deriving (Show, Read, ...); instance Whatever X where ... ?
17:17:10 <AtomicStryker> or even if i just write Derp 1 2 into the file
17:17:17 <AtomicStryker> naked expression at top level error
17:17:17 <Nereid> AtomicStryker: hm? are you trying to do what could be done by loading your code into ghci?
17:17:23 <monochrom> either "x = show (Derp 1 2)" or "main = print (Derp 1 2)" depending on what you mean
17:17:33 <AtomicStryker> oh, print
17:17:43 <monochrom> my point is "="
17:17:48 <mikeplus64> AtomicStryker: expressions at the "top level" ie outside of a function declaration aren't allowed
17:18:12 <mikeplus64> so you have to give it a name, e.g. derp12 = Derp 1 2
17:18:14 <Nereid> (they are if you use TH!)
17:18:22 <mikeplus64> lalalalala don't listen to neried
17:18:25 <mikeplus64> nereid
17:18:28 <Nereid> (hence parentheses)
17:18:36 <AtomicStryker> A NAME IT IS
17:18:42 <Nereid> (the "don't listen to me" parentheses)
17:18:54 <Hafydd> (don't listen to me)
17:19:19 <Nereid> AtomicStryker: do you know how to use ghci?
17:19:46 <AtomicStryker> no. the fact i cant copy paste into the window is driving me mildly insane
17:20:09 <Nereid> you load your code into ghci with :load
17:20:20 <Nereid> and then you can play with it, evaluate (showable) expressions and whatnot
17:20:23 <AtomicStryker> oh i know about  load and reload
17:20:46 <mikeplus64> AtomicStryker: you should be able to copy/paste easily in the window, just middle click or whatever...
17:21:01 <mikeplus64> unless you're on windows in which case you might want to invest in a better terminal emulator
17:21:07 <Nereid> you can paste on windows too
17:21:13 <AtomicStryker> uhm, i cant
17:21:19 <AtomicStryker> not right mouse not middle mouse
17:21:20 <Nereid> if you know how
17:21:20 <Peaker> edwardk, what do you mean?
17:21:21 <lolcathost> AtomicStryker: You can also create definitions on the fly in GHCi, but they have to be preceded by "let", as if inside a do block.
17:21:25 <Nereid> but it's more annoying
17:21:27 <Peaker> edwardk, I don't want to cripple myself :)
17:21:38 <Peaker> edwardk, I just want to use the new FFI stuff from 2010?
17:21:40 <AtomicStryker> i think ill just stick to np++ing it
17:21:50 <AtomicStryker> and then :r
17:22:05 <edwardk> Peaker: i mean that using the haskell2010 _package_ is a terrible idea. Using the Haskell2010 language on the other hand is fine
17:22:06 <mikeplus64> AtomicStryker: i think with cmd you have to right click -> paste
17:22:09 <mikeplus64> maybe on the title bar
17:22:19 <Peaker> edwardk, how do I tell ghci to use the 2010 language?
17:22:24 <Hafydd> cmd.exe doesn't paste on right click by default, but you can configure it to.
17:22:24 <Nereid> Peaker: it already does
17:22:38 <edwardk> Peaker: they have little to do with one another other than the haskell2010 package is used to provide a restricted form of base
17:22:39 <AtomicStryker> oh, on the bar indeed allows me to select paste
17:22:40 <Peaker> interestingly, it tells me it can't find the relevant modules from 2010
17:22:48 <Nereid> whwat modules?
17:22:57 <edwardk> Peaker: its a cabal flag, one sec
17:23:13 <Peaker> Foreign.Marshal.Alloc -- though it seems to relate to my PATH, weird
17:23:16 <AtomicStryker> there is a flag ticked for "insertion mode" but i have no idea what that does
17:23:27 <Peaker> never mind, with a certain PATH I can get it to import. Now missing Foreign.Marshal.Alloc.Calloc - wonder if its from some package
17:23:33 <Hafydd> Insertion mode, as opposed to overwrite mdoe.
17:23:42 <edwardk> Peaker: default-language; Haskell2010
17:23:49 <Peaker> ah, missing-foreign package
17:23:50 <AtomicStryker> ah quickedit mode = rightclick paste
17:23:50 <Peaker> edwardk, thanks
17:23:53 <AtomicStryker> oh so good
17:23:54 <edwardk> Peaker: use that _not_ the build-depends: haskell2010
17:24:02 <edwardk> the latter is a great way to screw yourself
17:24:03 <Peaker> Ok, will do, thanks :)
17:24:17 <AtomicStryker> always looking for more ways to screw myself
17:24:21 <AtomicStryker> its why im here
17:24:22 <edwardk> haskell2010 exists solely for those who want to ensure their code uses only haskell 2010 and nothing interesting
17:24:37 <elliott> interesting, n. lens
17:24:38 <monochrom> and how does that screw yourself?
17:24:39 <edwardk> default-language: Haskell2010 flips to the new language features by default
17:25:03 <edwardk> monochrom: because as I recall it conflicts with base all over the place
17:25:31 <monochrom> it does. but suppose I don't request base in my build-depends?
17:26:05 <monochrom> well, then you will say, that means my lib is inoperable with all the other great libs out there, they want base
17:26:12 <edwardk> then you can write your pedantic haskell 2010 compliant haskell, and keep wondering why nothing is there ;)
17:26:35 <monochrom> ok, but suppose my user doesn't mind that inoperability?
17:26:41 <hpaste> Nereid pasted “how to use ghci” at http://hpaste.org/78939
17:26:46 <Nereid> AtomicStryker: ghci is easy ^
17:27:11 <edwardk> monochrom: my statement was a sweeping generalization. it holds for 95% of the users who accidentally depend on haskell2010 when what they want is the language features.
17:27:19 <Nereid> if you're pasting large chunks of things into ghci, you're probably doing it wrong.
17:27:34 <edwardk> monochrom: it wasn't intended an exhaustive statement covering all possible uses of the package
17:27:40 <monochrom> I think my point is, instead of just classifying it as "screw yourself" and close the case, you should say what's the specific problem, so your audience can decide for themselves
17:27:50 <edwardk> but most of the time i see someone try to use the haskell2010 package they are doing it in error
17:28:09 <Nereid> what is a good use for the package?
17:28:26 <edwardk> Nereid: checking haskell 2010 language compliance, really thats about it
17:28:31 <Nereid> heh
17:28:49 <Nereid> likewise for haskell98?
17:28:55 <edwardk> Nereid: correct
17:29:20 <monochrom> I hate 95% of sweeping generalizations
17:29:33 <edwardk> the 5% usecase is where you really want to ensure you have portability to a haskell-2010 or haskell-98 compliant language implementation
17:29:37 <johkke> map tail [[],[2,3]] -> empty list error. How can I fix this? :(
17:29:37 <c_wraith> I like sweeping generalizations under the carpet
17:29:48 <AtomicStryker> thanks yall really should get to sleep now
17:29:50 <Nereid> johkke: what were you expecting?
17:29:59 <Axman6> > map (drop 1) [[],[2,3]]
17:30:00 <lambdabot>   [[],[3]]
17:30:09 <monochrom> the other 5% are mine, so I don't hate them. for example, "don't allow multiple instances of template-haskell"
17:30:10 <Nereid> or maybe he wanted [[3]]
17:30:13 <Nereid> that's why I ask
17:30:23 <edwardk> monochrom: i was originally answering peaker. and as a user i was pretty sure i knew his usecase.
17:30:39 <edwardk> monochrom: somewhere along the way my advice turned from talking to peaker to everyone else chiming in
17:30:59 <johkke> Nereid I know. But I need to use map with empty list in my algoritm
17:31:22 <Nereid> johkke: no, I am non-rhetorically asking you what result you were expecting.
17:31:39 <Nereid> or rather, what result you want.
17:31:41 <johkke> [3]
17:32:35 <Nereid> [3]?
17:32:43 <johkke> Nereid yeah
17:32:49 <Nereid> I don't understand.
17:33:02 <Nereid> what should it do with [[1,2],[],[3],[4,5,6]]?
17:33:29 <johkke> oh sorry. [[3]] I mean!
17:33:40 <Nereid> ah, so you want to throw away the empty lists.
17:33:42 <Nereid> ?
17:33:45 <johkke> yeah
17:33:54 <Nereid> simplest way would be to filter them out first
17:33:58 <Nereid> filter (not . null)
17:34:06 <Peaker> my hsc2hs doesn't seem to recognize #alignment, any idea?
17:34:06 <Nereid> and then map
17:34:12 <Peaker> Is it a matter of versions or such?
17:34:33 <Nereid> > map tail . filter (not . null) $ [[1,2],[],[3],[4,5,6]]
17:34:36 <lambdabot>   [[2],[],[5,6]]
17:34:42 <johkke> Nereid thanks :)
17:34:54 <oscarvarto> Hi! I want to start doing exercises in Haskell. For example, I just found https://github.com/tonymorris/course/ However, I don't know what to do to "compile" the project. Suggestions?
17:35:25 <Nereid> @let safeTail [] = Nothing; safeTail (x:xs) = Just xs
17:35:27 <lambdabot>  Defined.
17:35:35 <Nereid> > catMaybes . map safeTail $ [[1,2],[],[3],[4,5,6]]
17:35:36 <lambdabot>   [[2],[],[5,6]]
17:35:39 <Nereid> I like this better.
17:36:18 <Axman6> safeMaybe, aka, listToMaybe
17:36:39 <cmccann> not as cool as safeFromJust.
17:36:40 <Nereid> safeHead, you mean.
17:36:44 <Nereid> cmccann: :))
17:36:45 <Axman6> uh, yeah
17:36:57 <Nereid> safeUnsafeCoerce :: a -> Maybe b
17:37:10 <cmccann> though safeFromNothing would be better still
17:37:15 <Nereid> haha
17:37:20 <Hafydd> Hah.
17:37:34 <Axman6> safeFromJust (Just x) = x; safeFromJust x = safeFromJust x
17:37:47 <Nereid> that's not total
17:37:48 <Axman6> -- Keep trying until it mutates
17:37:49 <cmccann> safeFromNothing Nothing = Just (); safeFromNothing (Just _) = Nothing
17:37:57 <Hafydd> oscarvarto: do you have a piece of software like ghc or hugs?
17:38:05 <monochrom> no, safeFromJust :: Maybe a -> Maybe a
17:38:34 <oscarvarto> Hafydd: yes, I've installed the haskell platform in Ubuntu linux. Thanks for helping.
17:39:07 <Nereid> safeFromNothing Nothing = Nothing; safeFromNothing (Just x) = Nothing
17:39:10 <Hafydd> oscarvarto: compile with `ghc', or more likely to be useful, run straight away with `runhaskell'
17:39:32 <cmccann> Nereid, no no you need to extract the unit type from the Nothing
17:39:36 <cmccann> otherwise what's even the point?
17:39:41 <Hafydd> (a.k.a. `runghc')
17:39:57 <Nereid> cmccann: but it's a safe version of fromNothing :: Maybe a -> a
17:40:03 <Nereid> oh hmm that doesn't make sense.
17:40:20 <Nereid> cmccann: ok I agree with yours now.
17:40:31 <cmccann> no no, fromNothing Nothing = (); fromNothing (Just _) = error "fromNothing: Just"
17:40:36 <Nereid> yes yes.
17:40:36 <cmccann> a very useful function
17:40:40 <cmccann> ok.
17:40:41 <Nereid> very
17:40:42 <Nereid> :)
17:40:57 <Nereid> too bad that const () is more defined than it.
17:40:58 <monochrom> Maybe a -> Maybe () ?
17:41:14 <cmccann> yes, const () would be an incorrect implementation
17:41:56 <Nereid> safeRun :: TuringMachine -> Maybe Tape
17:42:03 <Nereid> returns Nothing if it doesn't halt
17:43:54 <shachaf> hi SamB_XP
17:45:12 <Hafydd> Nereid: right, the implementation will probably be trivial.
17:45:59 <Nereid> Hafydd: it's an exercise.
17:46:17 <cmccann> just implement it as "const Nothing". Nereid's spec didn't say what it should return if the machine does halt.
17:46:20 <cmccann> problem solved!
17:46:31 <Nereid> you win!
17:47:37 <monochrom> sweeping generalizations...
17:48:17 <Nereid> exercise 2: replace "if" with "iff"
17:48:35 <Hafydd> Does it have to halt itself?
17:48:52 <Nereid> what does that mean?
17:48:55 <Nereid> oh
17:48:55 <Ralith> he didn't explicitly require that, so of course not
17:49:20 <cmccann> "this turing machine halts because I decided to stop running it"
17:49:23 <Nereid> I don't see how that would make it any easier.
17:49:27 <monochrom> hehehe
17:49:27 <Nereid> haha
17:49:29 <Hafydd> "returns Nothing" might be taken to mean "eventually halts, returning Nothing", or "if it halts, it returns Nothing".
17:49:50 <typoclass> "this turing machine halts because this dude turing pulled the plug"
17:49:53 * hackagebot lens 3.7.0.2 - Lenses, Folds and Traversals  http://hackage.haskell.org/package/lens-3.7.0.2 (EdwardKmett)
17:49:59 <Nereid> Hafydd: how could it possibly be taken to mean the latter?
17:50:06 <monochrom> when you give no time bound, you allow infinite procrastination
17:50:24 <Nereid> monochrom: no bound? not even \omega?
17:51:23 <monochrom> even when you say "must terminate", if that's all you say, you still allow infinite procrastination, because there is no finite point of time such that at that time you can say you have an observation to refute the termination claim
17:52:00 <burrows> I've been looking through Data.Time.Clock and Data.Time.LocalTime and I don't really understand how I can get an integer version of the current time.  As UTCTime doesn't seem to expose it's records and I don't see a path from UTCTime -> TimeOfDay.  Noob ?
17:52:36 <Peaker> What's a good way to go from Char -> CWchar?
17:52:49 <typoclass> burrows: by integer version, you mean stuff like month 12?
17:53:01 <monochrom> (if you say, read my source code, then there are two problems. first problem: perhaps our contract doesn't let you do that. second problem: perhaps you don't understand my source code. it's the halting problem again, but this time on your brain.)
17:53:07 <burrows> typoclass: YEs.
17:53:21 <burrows> I want to seed with the current time.
17:53:36 <burrows> So seconds of the day would work.
17:54:10 <Hafydd> Nereid: I can imagine running a function that "returns" some input read from a terminal, then leaving it to run forever with no input.
17:54:32 <Nereid> stop chainging the meaning of things.
17:54:33 <Nereid> :c
17:54:43 <Hafydd> What was the original meaning?
17:55:06 <monochrom> does CWchar has enough bits to hold what's in Char?
17:55:12 <Nereid> we're talking about functions. not IO stuff
17:55:27 <typoclass> burrows: ok to get the seconds since midnight out of a UTCTime, you can do "utctDayTime u". also, you could look at Data.Time.Clock.POSIX, which gives you the familiar unix kinda timestamp
17:55:32 <Nereid> monochrom: yes
17:55:34 <monochrom> if yes, then: does CWchar has a Num instance?
17:55:36 <Nereid> it's 32 bits
17:55:39 <Nereid> and yes
17:55:42 <Nereid> you could look this up yourself
17:55:45 <Peaker> Foreign.Marshall.alloc needs to be explicitly freed, but ForeignPtr.malloc is GC'd?
17:55:53 <Nereid> oops
17:55:53 <monochrom> if also yes, then: perhaps fromIntegral . ord
17:55:55 <Nereid> you're talking to someone.
17:56:01 <edwardk> Hafydd: 'read line' doesn't make an assertion that input will eventually happen, so your case doesn't fit ;)
17:56:08 <monochrom> I'm being Socratic :)
17:56:28 <Nereid> monochrom: I thought you were just asking everyone.
17:56:28 <shachaf> Peaker: "alloc"?
17:56:29 <Nereid> :v
17:56:36 <Nereid> clearly, unsafeCoerce is the way to go.
17:57:00 <monochrom> I don't think there is a need for the false dichotomy of "Peaker" vs "everyone"
17:57:14 <Hafydd> An IO function takes the state of the universe as input.
17:57:19 <monochrom> i.e., anything that helps Peaker is good
17:57:30 <shachaf> Hafydd: That's not true. :-(
17:57:33 <hpc> IO actions aren't functions
17:57:35 <Jafet> "On procrastination, with an application to the Schularbeitsproblem"
17:57:45 <monochrom> haha
17:57:47 <Peaker> shachaf, what?
17:57:48 <Nereid> and "IO functions" aren't a thing
17:58:07 <Hafydd> A value of type IO takes the state of the real world and produces some output.
17:58:12 <shachaf> Peaker: What's Foreign.Marshal.alloc?
17:58:16 <Nereid> I have never seen the state of the real world.
17:58:28 <hpc> @hoogle realworld
17:58:29 <lambdabot> Control.Monad.ST data RealWorld :: *
17:58:29 <lambdabot> Control.Monad.ST.Lazy data RealWorld :: *
17:58:35 <monochrom> IO actions are W->(a,W) functions http://thread.gmane.org/gmane.comp.lang.haskell.cafe/102087
17:58:36 <Nereid> that's an imposter.
17:58:37 <hpc> there's an acme package
17:58:39 <typoclass> burrows: oh and the utctDayTime thingy gives a fractional number; you may want to use 'floor' on it
17:58:40 <burrows> typoclass: I think I do not understand what "utctDayTime u" means? I seem to understand that utctDayTime is a constructor for UTCTime, but this constructor seems to not be exposed.
17:58:56 <Nereid> monochrom: that doesn't make W the state of the real world :v
17:58:58 <Hafydd> But I wasn't talking about Haskell in particular, in fact!
17:59:01 <shachaf> Hafydd: There is no RealWorld anywhere in the Haskell report.
17:59:02 <Peaker> what are all the 0 suffixed funcs in ForeignPtr?
17:59:05 <monochrom> I know. I'm mocking it
17:59:08 <typoclass> burrows: i imported Data.Time and could use it ...
17:59:19 <hpc> Peaker: do they memset 0?
17:59:24 <monochrom> it is very sad that the false story is the clear and intuitive story
17:59:29 <shachaf> monochrom: I saw that email and it made me sad.
17:59:50 <Peaker> hpc, no idea: pokeArray0 :: Storable a => a -> Ptr a -> [a] -> IO ()  vs:  pokeArray :: Storable a => Ptr a -> [a] -> IO ()
18:00:00 <Hafydd> I'm just saying in an abstract sense, an IO action defines what to do for each possible sequence of inputs.
18:00:13 <typoclass> burrows: oh i see what you mean :-) when the haddock page says "Constructors", it means, "this thing has one constructor, named UTCTime, and that constructor has the following two fields ..."
18:00:15 <Nereid> anyway, unsafeCoerce :: Char -> CWChar works perfectly well
18:00:18 <Nereid> :p
18:00:24 <typoclass> burrows: (i'm looking at http://hackage.haskell.org/packages/archive/time/1.1.4/doc/html/Data-Time-Clock.html )
18:00:44 <monochrom> I was going to reply "every year, during Christmas Eve, NORAD has a clear and intuitive web page showing Santa Claus's location too"
18:00:53 <burrows> Oh okay that is different than my understanding.
18:00:58 <burrows> Let me see if I can get it working.
18:01:19 <Nereid> burrows: UTCTime :: Day -> DiffTime -> UTCTime; utctDayTime :: UTCTime -> DiffTime
18:01:20 <monochrom> however, since I can't think of much constructive things to say in addition to that, I haven't written it
18:01:27 <cmccann> true fact: the IO monad is implemented in terms of santa claus
18:01:55 <Nereid> burrows: peek at the source to see how the haddock doc corresponds to the code.
18:02:28 <typoclass> shachaf: do you know if lens has accessory gettery things for e.g. pulling the "month" part out of a ZonedTime?
18:02:54 <edwardk> typoclass: we used to a loooong time ago. i pulled it out anticipating a lens-time package that could do it better
18:02:58 <monochrom> all I could think of is destructive acidic things like "RW is up there with tooth fairies, flying pasta monster, santa claus, and the Platonic astral plane of ideal mathematics"
18:03:19 <Hafydd> > length [1..]
18:03:22 <lambdabot>   mueval-core: Time limit exceeded
18:03:33 <Hafydd> There's a function that returns something.
18:03:34 <typoclass> edwardk: right, i dimly remembered i told you about time-lens or some such (one of ro-che's packages), and you said you'd assimilate the things that you like :-)
18:03:42 <Nereid> Hafydd: no it doesn't
18:03:52 <burrows> Awesome, thanks typoclass. Did getCurrentTime >>= return . utctDayTime
18:03:53 <Nereid> at best, it returns bottom
18:03:58 <typoclass> edwardk: so this lens-time package is planned, not real?
18:04:25 <aristid> does TH work across packages?
18:04:54 <typoclass> burrows: you're welcome :-) the Data.Time stuff is one of the more confusing parts of haskell. it's all reasonably straightforward in the end, but you'd never know it from the haddocks
18:05:11 <Nereid> aristid: in what sense?
18:05:12 <Hafydd> Nereid: okay, I actually agree with you that "returns" should indicate halting, but I maintain that it could be interpreted otherwise.
18:05:31 <aristid> Nereid: well, inspecting constructors of types from other packages
18:05:43 <aristid> that way, lens' TH stuff could be used on the time types :)
18:06:22 <Nereid> well, afaik TH can't produce code you couldn't write yourself.
18:06:32 <typoclass> aristid: or you could just use this :-) http://hackage.haskell.org/package/time-lens
18:06:46 <Nereid> that's data-lens
18:07:13 <typoclass> *shrug* it works as far as i can tell
18:07:22 <aristid> typoclass: :)
18:07:32 <cmccann> Nereid, pretty sure you can make stuff with TH's constructors that couldn't be parsed from actual source
18:07:33 <aristid> Nereid: sure, but it can be convenient
18:07:35 <cmccann> not that that matters
18:08:00 <cmccann> especially since it's probably either equivalent to something valid, or horrendously broken and won't compile
18:08:06 <elliott> cmccann: you can make case x of {} for example
18:08:27 <cmccann> oooh, really? man, why don't we have that as a GHC extension anyway.
18:08:43 <edwardk> typoclass: correct
18:08:50 <typoclass> edwardk: yup, thanks
18:08:53 <cmccann> gotta pattern match properly on those empty data types I mean cmon
18:09:00 <edwardk> typoclass: if you wanted to start one i'd happily contribute
18:09:26 <mikeplus64> hm, could a "modern" TH that is typesafe be built with GADTs?
18:09:47 <cmccann> by typesafe, you mean that if the TH typechecks the output will also typecheck?
18:09:53 <mikeplus64> yeah
18:10:03 <cmccann> the answer is probably "yes, but it would be awkward to use"
18:10:24 <cmccann> it's very easy to make toy implementations of that sort of thing
18:11:53 <elliott> there was work on doing such a thing at ghc hq(tm) iirc
18:12:49 <typoclass> edwardk: my gigantic cluelessness about the lens package might be an issue :-) but let's see if i can get the hang of it, bit by bit
18:13:38 <pdxleif> Gah, was befuddled why people were talking about TH in here, before I realized I was in #haskell. :/
18:14:02 <shachaf> Being in #haskell is not sufficient reason to talk about TH.
18:14:15 <shachaf> There are all these nice things in Haskell.
18:14:19 <shachaf> Why spend your time with TH?
18:14:46 <SamB_XP> did TH get worse, then?
18:15:17 * shachaf is just biased.
18:15:18 <typoclass> elliott: was that the effort with the name 'supercompilation'? or am i mixing things up?
18:15:34 <elliott> typoclass: unrelated
18:15:56 <typoclass> right, thanks
18:18:32 <SamB_XP> shachaf: ... perhaps you prefer the ghc api?
18:27:37 <aristid> is there a nice tutorial on how to do profiling with ghc?
18:53:04 <popl> aristid: I don't know if there is a tutorial. There is documentation (the entirety of chapter 5) on haskell.org, though: http://www.haskell.org/ghc/docs/7.6.1/html/users_guide/profiling.html
18:57:33 <Jesin> hmm...  I'm wondering if anyone here knows about Sage vs Mathematica in terms of capabilities...  Or should I ask this in some other channel instead?
18:57:48 <shachaf> Doesn't seem very Haskell-related.
19:07:04 <popl> Jesin: ##math-software exists
19:19:21 <oscarvarto> I just installed the Haskell platform in Mac OS X Lion with homebrew. Is that the right way to do it, or will I have problems (for example, with upgrades)? Should I prefer the installation from http://www.haskell.org/platform/mac.html ?
19:22:30 <latermuse> oscarvarto: I believe homebrew uses older versions for proven stability. If you want the newest GHC compiler, then you might want to look into the installation from haskell.org
19:24:16 <mikeplus64> in ghc core i see a lot of __integer x for integer literals, where is __integer defined?
19:28:57 <shachaf> I think it's just a magic Core thing for literals.
19:29:14 <shachaf> See basicTypes/Literal.lhs
19:30:24 <oscarvarto> latermuse: Is it more problematic to install ghc 7.6.1 than ghc 7.4.2? http://www.haskell.org/ghc/download_ghc_7_6_1
19:31:11 <oscarvarto> "a larger set of libraries that are known to work together" <-- Is that true?
19:32:46 <slack1256> is darcsden down or doesn't exist more?
19:33:02 <latermuse> oscarvarto: I believe not all the libraries have been ported to 7.6.1 yet. You might be better off using 7.4.2 for another few weeks at least.
20:00:40 <startling> what's _|_ in TeX?
20:01:11 <dolio> \perp
20:01:20 <dolio> Or \bot
20:02:05 <startling> aha, thanks
20:03:19 <Eduard_Munteanu> @google detexify
20:03:20 <lambdabot> http://detexify.kirelabs.org/
20:03:21 <lambdabot> Title: Detexify LaTeX handwritten symbol recognition
20:03:33 <Eduard_Munteanu> (can come in handy, if you don't know it)
20:03:48 <startling> Eduard_Munteanu: neat,t hanks
20:08:04 <mikeplus64> is there an unsafePeek, which does not copy?
20:09:30 <sw2wolf> Anybody here uses xmonad ? How can i display message in xmonad ?
20:09:43 <startling> @hoogle a -> Ptr a
20:09:44 <lambdabot> Foreign.ForeignPtr unsafeForeignPtrToPtr :: ForeignPtr a -> Ptr a
20:09:44 <lambdabot> Prelude id :: a -> a
20:09:44 <lambdabot> Data.Function id :: a -> a
20:10:01 <mikeplus64> @hoogle Ptr a -> a
20:10:01 <lambdabot> Foreign.Ptr ptrToIntPtr :: Ptr a -> IntPtr
20:10:01 <lambdabot> Foreign.Ptr ptrToWordPtr :: Ptr a -> WordPtr
20:10:01 <lambdabot> Prelude id :: a -> a
20:10:11 <mikeplus64> @hoogle Ptr a -> IO a
20:10:11 <lambdabot> Foreign.Storable peek :: Storable a => Ptr a -> IO a
20:10:11 <lambdabot> Foreign.Marshal.Alloc free :: Ptr a -> IO ()
20:10:11 <lambdabot> Network.Socket.Internal peekSockAddr :: Ptr SockAddr -> IO SockAddr
20:53:49 <fengshaun> if I have a function that accepts a function of type [a] -> [a] -> [a], but uses this function to operate on [(a,b)], what would be the type of the original function?
20:53:53 <fengshaun> let me paste the cod
20:53:54 <fengshaun> e
20:54:44 <hpaste> fengshaun pasted “function type” at http://hpaste.org/78943
20:54:52 <fengshaun> ^^
20:55:05 <fengshaun> what is the type of traverseHelper?
20:55:13 <shachaf> traverseHelper :: Eq a => ([a] -> [a] -> [a]) -> AdjMatrix a -> [Node a]
20:55:15 <shachaf> It says it right there.
20:55:23 <fengshaun> shachaf, that doesn't work
20:55:35 <fengshaun> gives me 'couldn't match type' erro
20:55:36 <fengshaun> r
20:55:37 <shachaf> What do I look like to you, GHC?
20:55:42 <shachaf> Try asking GHC.
20:56:08 <fengshaun> I checked it with ghci and it expands the type to [(Node a, [Node a])] -> [same] -> [same]
20:56:15 <shachaf> Well then.
20:56:24 <fengshaun> but I don't want to expose the internals of AdjMatrix like that
20:56:35 <shachaf> Then you'll have to change your function.
20:56:46 <fengshaun> shachaf
20:56:48 <fengshaun> ah
20:56:49 <fengshaun> how?
20:57:07 <shachaf> I don't know.
20:57:13 <fengshaun> :(
20:57:17 <fengshaun> okay, thanks
20:57:17 <shachaf> I'm not sure your traverse' is right either. What's b?
20:57:26 <fengshaun> it's not right
20:57:31 <fengshaun> I was just experimenting
20:58:01 <fengshaun> unless I make AdjMatrix a Monoid
21:18:42 <oscarvarto> I'm trying to work with https://github.com/tonymorris/course/ I did cabal install but now I don't know how to run the code. Sorry for this question, I'm just starting...
21:19:23 <shachaf> ghci
21:19:39 <shachaf> @google how do i run haskell code
21:19:41 <lambdabot> http://www.haskell.org/haskellwiki/Haskell_in_5_steps
21:19:41 <lambdabot> Title: Haskell in 5 steps - HaskellWiki
21:19:48 <shachaf> Like that. :-)
21:20:14 <shachaf> "4.1 Write your first parallel Haskell program" -- really, person-who-wrote-that-page?
21:20:17 <shachaf> I bet it's dons.
21:20:41 <rwbarton> what's step 4.2
21:20:50 <shachaf> Yep, dons.
21:20:51 <popl> What's a dons?
21:20:59 <rwbarton> @wn dons
21:21:00 <lambdabot> No match for "dons".
21:21:18 <rwbarton> popl: the page was written by a collection of mafia lords
21:21:30 <popl> I ride the bus to school every other weekday. There is a homeless man named Don who rides the same bus.
21:21:54 <popl> His hygiene is limited.
21:22:17 <popl> Is that anything like your dons?
21:22:35 <rwbarton> Probably a different guy
21:26:30 <popl> rwbarton: I realized that was pretty lame. Sorry.
21:29:13 * popl is a pariah.
21:32:36 <sporkball> I'm totally new to Haskell (about three days of reading Learn Your a Haskell) and I've just written my first "real" program with it, I was wondering if anyone is interested in looking at it with a critical eye and pointing me toward things I can improve / need to learn. It's at: https://github.com/biesnecker/haskell-dice
21:33:31 <pharaun> first thing i notice is '=' ?
21:34:22 <sporkball> pharaun: the file? Yeah, not sure how that got in the repo (subl mishap, I'm guessing).
21:34:50 <pharaun> btw when you got time you might want to look into cabal for building/dependency stuff
21:34:54 <pharaun> but for now the build is ok
21:36:56 <pharaun> i'm pretty bad with pointers but i think the code seems acceptable to me
21:37:02 <pharaun> certainly better than my first attempt :p
21:38:30 <sporkball> pharaun: :) thanks! one place where it seems clunky is handling the arguments
21:38:39 <sporkball> particularly:args <- getArgs
21:38:40 <sporkball>   let [x,y,z] = handleArgs args
21:39:00 <crdueck> pharaun:  http://sprunge.us/TPNB
21:39:01 <sporkball> it seems there should be a way to (basically) let [x,y,z] = handleArgs <- getArgs
21:39:15 <shachaf> [x,y,z] <- handleArgs <$> getArgs ?
21:39:52 <pharaun> crdueck: well yeah :)
21:40:35 <sporkball> crdueck: schachaf: awesome
21:40:50 <sporkball> shachaf (that is) -- awesome
21:41:09 <sporkball> I've read about lifting but I honestly don't quite understand it yet.
21:41:36 <shachaf> Another possibility (with a GHC extension): (handleArgs -> [x,y,z]) <- getArgs
21:41:40 <shachaf> sporkball: Do you understand map?
21:41:43 <shachaf> > map (+1) [1,2,3]
21:41:45 <lambdabot>   [2,3,4]
21:42:06 <sporkball> shachaf: yeah (I'm coming at FP from Clojure)
21:42:22 <shachaf> OK, so this is the same thing, except for IO instead of for lists.
21:42:29 <shachaf> fmap :: (a -> b) -> IO a -> IO b
21:43:20 <shachaf> In particular fmap :: (String -> [YourType]) -> IO String -> IO [YourType]
21:44:48 <sporkball> shachaf: Ah, OK, I think I get it.
21:45:32 <sporkball> shachaf: How to deal with values inside IO is something I'm sort of winging.
21:45:46 <sporkball> shachaf: With this I just did my best to keep everything I could out of it.
21:45:56 <shachaf> sporkball: OK, the first trick is that there's no such thing as "values inside IO". :-)
21:46:09 <shachaf> There's IO actions, which are rather different matter.
21:46:11 <shachaf> @quote /bin/ls
21:46:12 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
21:46:45 <sporkball> shachaf :-)
21:50:02 <scp_> can anyone give me a brief explanation of what supercompilation is and whether or not GHC does it?
21:50:07 <sporkball> shachaf: I guess I'm conceiving of "running an IO action that returns a value" as "unboxing an IO and getting the value inside," incorrectly.
21:50:25 <cmccann> scp_, ghc does not
21:50:46 <shachaf> sporkball: Yep.
21:50:52 <shachaf> sporkball: There is no value inside.
21:51:00 <shachaf> An IO action is a program that you can run to get a result.
21:51:18 <cmccann> scp_, though I think there's been some experimental stuff done along those lines
21:51:21 <shachaf> getLine :: IO String doesn't "contain" any particular String
21:51:54 <pharaun> hehe yeah i keep on tripping on that sometime :)
21:51:58 <scp_> cmccann, I was looking at http://hackage.haskell.org/trac/ghc/wiki/Supercompilation
21:52:04 <sporkball> shachaf: And then <- runs that program?
21:52:11 <shachaf> sporkball: Sort of.
21:52:14 <pharaun> sorta
21:52:20 <shachaf> sporkball: The way it actually works is that you can combine programs into bigger programs.
21:52:27 <pharaun> keep in mind the do notation you are using is sort of a syntax sugar
21:52:32 <pharaun> for >>= and etc
21:52:38 <shachaf> So you can say "do { x; y }" to make a program that runs program x and then program y
21:53:01 <shachaf> In the end, GHC uses compiler magic to run the action "main", which is in turn made up of lots of other actions.
21:53:05 <pharaun> strike out sort, it is pretty much syntaxical sugar
21:53:43 <shachaf> pharaun: It is, but that's not strictly relevant for understanding the basic idea. :-)
21:54:24 <pharaun> shachaf: that is true :) i guess for me the whole do thing being syntaxical sugar and me doing it manually kind of made it *click* a bit better :)
21:54:30 <shachaf> sporkball: The other day I wrote this thing about IO: http://stackoverflow.com/questions/13536761/what-other-ways-can-state-be-handled-in-a-pure-functional-language-besides-with/13538351#13538351
21:55:05 <sporkball> shachaf: excellent, will read.
22:00:28 <sporkball> sorry, dirty diaper to change
22:00:47 <sporkball> shachaf: and an IO action just happens to be a program that deals with impure information from outside of the program
22:01:02 <shachaf> I'm not sure what that means.
22:02:14 <sporkball> shachaf: Sorry, just trying to carry the "an IO action is a program that you can run to get a result" analogy, but as I read it again I realize I got it wrong.
22:04:30 <sporkball> shachaf pharaoh crdueck -- thanks so much for the help! I'm going to put my head down for a couple of days and see if I don't figure things out a little bit more. :)
22:04:51 <sporkball> er, pharaun (sorry, muscle memory) -- thanks!
22:05:08 * cmccann writes code that parses a language description in order to output code that parses an API description in order to output code that wraps the API for use by other code
22:05:11 <cmccann> I think it is time to realize
22:05:16 <cmccann> that something has gone horribly wrong
22:05:33 <shachaf> Why realize it yourself when you can write code to realize it for you?
22:05:38 <cmccann> good point!
22:06:56 <cmccann> I'm sure there was a better way to do this but oh well
22:07:06 <cmccann> it's working so far
22:09:42 <pharaun> cmccann: that yak must be bald by now
22:10:20 <cmccann> I think he's in deep exfoliation territory at this point
22:11:46 <cmccann> anyway I think that's enough of this crap for tonight
22:11:56 <cmccann> tomorrow I'll finish the final step and wash my hands of the whole process
22:12:17 <cmccann> on the bright side I'm pretty sure that doing all this manually would have taken much longer and been more error-prone
22:12:44 <pharaun> :)
22:22:50 <dented42> is it possible to turn of GHC's garbage collector?
22:22:55 <sw2wolf> :m + Language.Haskell.Interpreter
22:23:07 <sw2wolf> interpret "1+1"
22:23:28 <sw2wolf> Ambiguous type variable `m0' in the constraint:
22:23:28 <sw2wolf>       (MonadInterpreter m0) arising from a use of `interpret'
22:23:35 <shachaf> Turn of GHC's garbage collector? Is that like a turn of phrase?
22:23:41 <dented42> er
22:23:42 <sw2wolf> How to fix ?
22:23:48 <dented42> turn off the garbage collector, I mean
22:23:54 <shachaf> Why?
22:24:01 <shachaf> You'll certainly get into trouble if you don't GC.
22:24:08 <dented42> yes, I'm aware
22:24:20 <dented42> no particular reason other then perverse curiousity, I suppose
22:25:00 <shachaf> Are you aware of how much trouble?
22:25:01 <dsantiago> The language rust has an interesting feature where the type system can guarantee that there is only one reference to a particular object, and it can let this single reference be passed to another variable (ensuring the original does not use it). I wonder if Haskell could do something like that.
22:25:05 <rwbarton> you could set the gc sizes to huge numbers
22:25:06 <cmccann> just take all the RAM out of your system
22:25:11 <cmccann> the overall effect should be similar
22:25:47 <shachaf> For example, "last [1..100000000]" runs in <3 seconds allocates 8GB.
22:26:03 <newsham> doesnt Clean do that too?
22:26:13 <cmccann> yes, Clean has uniqeness types
22:26:17 <cmccann> and is Haskell-ish
22:26:29 <shachaf> How do you catch a unique type?
22:26:45 <dented42> jesus christ
22:27:10 <cmccann> shachaf, by assaulting it with terrible puns until it loses all will to live
22:27:12 <cmccann> obviously
22:27:29 <shachaf> cmccann: I prefer funpuns.
22:27:35 <cmccann> heh
22:28:25 <shachaf> @@ @read @run (@where rot13) @show shachaf
22:28:26 <lambdabot>  funpuns
22:28:39 <cmccann> anyway-- dsantiago, take a look here: http://en.wikipedia.org/wiki/Clean_(programming_language)
22:28:56 <dsantiago> Yeah, I know about Clean. I was just wondering if Haskell's type system could handle that. Sounds like no.
22:29:08 <cmccann> there's no reason why not
22:29:09 <shachaf> anyway++
22:29:26 <cmccann> but it doesn't have anything like that right now
22:29:52 <dsantiago> What I mean is, it sounds like the language or compiler would need updates. It's not just a library, right?
22:30:13 <cmccann> pretty much
22:31:44 <cmccann> you can do some trickery with weird type stuff to restrict some things
22:32:33 <cmccann> but trying to fake uniqueness types in Haskell is pretty fundamentally going against the grain of assumptions underlying the type system
22:33:13 * cmccann has tried at various points, as part of his tinkering with linear logic
22:34:28 <dented42> given how dangerous it can be, is it possible?
22:35:15 <shachaf> You can try what rwbarton said.
22:36:39 <rwbarton> specifically -A<all of your RAM>
22:37:09 <rwbarton> or really, more than all of your RAM+swap. then it will fail before GCing I guess
23:05:01 * hackagebot hums 0.5.0 - Haskell UPnP Media Server  http://hackage.haskell.org/package/hums-0.5.0 (BardurArantsson)
23:26:10 <burrows> If I have a case statement and on one of the conditions I want to do a couple of different things (push something onto a stack, look up another value, modify a third value), is this where I would/should/could use a Monad?
23:27:04 <shachaf> Maybe?
23:27:10 <burrows> Okay.
23:27:11 <shachaf> That's too vague to answer.
23:27:33 <shachaf> At any rate you would use some specific monad, not "monad in the abstract".
23:27:50 <burrows> It seems like I need to use the >> operator
23:28:01 <c_wraith> You don't need to
23:28:01 <shachaf> What would it do?
23:28:11 <c_wraith> But maybe you could use it to simplify something
23:28:12 <burrows> Because I need to do a couple of things whose inputs and ouputs are unrelated.
23:28:25 <shachaf> >> isn't magic. Anything you can do with it you can do without it.
23:28:34 <burrows> Fair enough.
23:28:35 <shachaf> (Except in the case of IO or something. Presumably that's not relevant here.)
23:28:48 <burrows> I just don't <understand> how to accomplish what >> accomplishes.
23:29:09 <shachaf> OK, in that case you should almost certainly not use (>>). :-)
23:29:15 <burrows> Haha
23:29:24 <burrows> I know what it does I think.
23:29:24 <shachaf> (Really.)
23:29:33 <Mortchek> What >> does depends on the type you're working with
23:29:53 <shachaf> If you know what it does then you know how to manage without it.
23:29:57 <burrows> Alright, before I talk myself into a bigger hole, can I show you what I'm trying to do.
23:30:06 <burrows> With code.
23:30:07 <shachaf> That would have been a good start right at the beginning!
23:31:17 <burrows> http://pastebin.com/GJ7EwvqN
23:31:32 <burrows> The case statement on line 24.
23:33:09 <shachaf> I'm not quite sure what you're doing, but I suspect writing out your types would help here. :-)
23:33:28 <shachaf> (There are a lot of stylistic notes, by the way, many of which you would get automatically if you pasted on hpaste.org instead of pastebin.com.)
23:33:59 <burrows> Okay, you mean pull out those small functions and give them types?
23:34:12 <shachaf> You don't have to pull out anything.
23:34:16 <shachaf> But types are good. :-)
23:34:21 <burrows> Cool.
23:34:38 <shachaf> So the issue is just that you want to do a bunch of different operations on a maze?
23:34:53 <shachaf> It seems like you could just do those operations.
23:34:57 <shachaf> Not that I know what a Maze is.
23:35:00 <burrows> Yeah if that condition is met I need to update a couple different data fields
23:35:12 <burrows> Oh yeah should have included the data types.
23:35:23 <burrows> I'll post the whole file.
23:36:21 <burrows> http://hpaste.org/78947
23:36:56 <shachaf> Hmm, somehow hlint didn't pick it up.
23:37:29 <shachaf> Oh, because there's a syntax error.
23:37:40 <burrows> Yeah codes broke.
23:38:07 <shachaf> I have the feeling lists are vrey inappropriate to what you're doing here.
23:39:40 <burrows> I see.
23:39:47 <burrows> What suggests that?
23:40:24 <burrows> Need an NxN matrix with 8 properties or so (I think). To describe cells in a grid (maze).
23:40:33 <burrows> That's the idea at any rate.
23:43:55 <burrows> I added types, much easier to read.
