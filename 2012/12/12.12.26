00:12:18 <sopvop> searching "comonad" in google shows me "command & conquer" on first page.
00:12:43 <sopvop> comonad & conquer - good blog title
00:19:05 <Ralith> sopvop: careful, you might give edwardk ideas...
00:23:56 <sopvop> conquer - will be a traversal in lens 3.9
00:30:08 <LAMMJohnson> Is anybody about to help me unstupid my little function?
00:30:09 <LAMMJohnson> http://pastebin.com/R4RLS79e
00:31:47 <shachaf> That's a terrible way to check whether a file exists.
00:31:54 <Industrial> What do I do with an ExitFailure 9 with cabal?
00:31:57 <shachaf> @ty System.Directory.doesFileExist
00:32:00 <lambdabot> FilePath -> IO Bool
00:32:09 <LAMMJohnson> shachaf: I know, right?
00:32:26 <Hafydd> It will also sometimes give the wrong answer.
00:32:29 <shachaf> The `catchError` is only catching errors in the last line of your code.
00:32:32 <LAMMJohnson> I hoogled for a while, thanks for the heads-up.
00:33:33 <sopvop> industrial: What does log say?
00:33:52 <Industrial> https://gist.github.com/e6448ffab1cb20f7d0fd
00:33:57 <LAMMJohnson> Well, the pinnacle of unstupiding code is being able to use a standard function.
00:34:20 <Industrial> hehe
00:34:45 <sopvop> looks like linker error or something
00:35:30 <fmap> looks like cabal-install was killed because of OOM
00:35:38 <Industrial> hm okay. This is in a vm
00:35:42 <sopvop> 9 = sigkill
00:35:56 * Industrial pulls a memory slider
00:37:01 * sopvop still does cat foo.txt | grep and kill -9 :(
00:40:26 <b__> killall thethings
00:40:56 <Industrial> fmap, sopvop : yep that was it :) cheers
00:41:12 * shachaf regularly exits the shell with kill -9 $$
00:41:16 <shachaf> So regularly that I have an alias for it!
00:41:40 <fmap> shachaf: ^D i guess?
00:42:00 <shachaf> The goal is not to save history.
00:42:33 <Skillson> Hi Johnson! I enjoy your /g/ posts.
00:42:59 <Ralith> ln -s /dev/null ~/.histfile?
00:43:35 <LAMMJohnson> Hello there, Skillson.
00:44:13 <LAMMJohnson> Good to see a fellow Haskellbro from /g/
00:44:19 <Skillson> What are you working on?
00:44:21 <bradleyayers> hi
00:44:23 <shachaf> Ralith: I don't want to lose *all* bash history.
00:44:28 <shachaf> Just for this particular session.
00:44:34 <LAMMJohnson> Silly little screensaver.
00:44:51 <LAMMJohnson> Just to get myself familiar with Graphics.UI.SDL
00:44:54 <Ralith> ah, the session you use for browing porn?
00:45:02 <Skillson> Will you be putting it on your Github?
00:45:17 <ion> shachaf: unset HISTFILE; ^D
00:45:30 * shachaf has a limited bash history file with lots of useful one-liners.
00:45:32 <Skillson> I am working on a Brainfuck interpreter in Haskell at the moment, just as a tiny bit of practice before I start my real project of a MIX emulator.
00:45:36 <shachaf> I don't want to get nonsense into it.
00:45:42 <shachaf> ion: That would be the alternative.
00:45:42 <LAMMJohnson> Nice stuff.
00:45:48 <shachaf> ion: (I think HISTSIZE=0 might also do.)
00:45:52 <LAMMJohnson> Yes, it's up on my githib. I'll link you.
00:45:52 <Ralith> this seems perhaps less than the optimal solution
00:45:55 <LAMMJohnson> Terrible code warning
00:46:04 <LAMMJohnson> https://github.com/JohnAnthony/Nyancat
00:46:41 <shachaf> Ralith: Works for me!
00:46:44 <ion> shachaf: Dunno if there’s a setting like this for bash, but in zsh you can setopt hist_ignore_space and it’ll refrain from saving commands if there’s a space in front.
00:48:04 <shachaf> ion: Yep, I have that and use it too.
00:53:49 <Jafet> Having to add a space in front of most lines seems wrong.
00:54:35 <Jafet> > cycle "nyan "
00:54:36 <lambdabot>   "nyan nyan nyan nyan nyan nyan nyan nyan nyan nyan nyan nyan nyan nyan nyan...
00:56:26 <Industrial> my unit test output is nyancat :P it gets googly eyes for every test that fails while it's running :P
00:58:51 <LAMMJohnson> If that's true you're actually a legend
01:03:18 <johnw> shachaf: what's the link again for the new Iso based on profunctors?
01:03:21 <johnw> i want to show somebody
01:03:48 <shachaf> The way it "should" work or the way it works in lens?
01:03:55 <johnw> the way it "should" work
01:03:59 <johnw> that .hs you linked before
01:04:26 <Skillson> I've noticed that the ceiling of enjoyment in #haskell is in direct proportion to the amount of category theory you know.
01:04:41 <Skillson> I really have to learn some.
01:05:08 <shachaf> You don't really need to know category theory for most of Haskell things.
01:05:20 <johnw> Skillson: I find it breathtakingly beautiful at times
01:05:38 <shachaf> As far as I can tell that's mostly a myth spread by people who don't know category theory.
01:05:52 <shachaf> (There are some exceptions, naturally.)
01:05:54 <Jafet> I thought it was a lie spread by people who do
01:06:56 <shachaf> That's also possible.
01:07:15 <shachaf> I don't have anything against category theory, mind you.
01:07:36 <johnw> :)
01:07:41 <johnw> you do love you some profunctors
01:08:16 <beaky> hello
01:08:28 <beaky> what is the Lens equivalet of (.) ?
01:08:32 <beaky> equivalent*
01:08:34 <johnw> (.)
01:08:40 <beaky> ah
01:12:43 <beaky> @hoogle (Lens a -> Lens b) -> (Lens b -> Lens c) -> (Lens a -> Lens c)
01:12:44 <lambdabot> Warning: Unknown type Lens
01:12:44 <lambdabot> No results found
01:12:47 <beaky> :(
01:16:19 <Skillson> Hello, iosq
01:37:01 <sopvop> @hoogle ($$)
01:37:01 <lambdabot> Text.PrettyPrint.HughesPJ ($$) :: Doc -> Doc -> Doc
01:37:01 <lambdabot> Text.PrettyPrint ($$) :: Doc -> Doc -> Doc
01:37:01 <lambdabot> Language.Haskell.TH.PprLib ($$) :: Doc -> Doc -> Doc
01:37:03 <sopvop> nope
01:37:06 <beaky> how do I configure cabal's CFLAGS?
01:37:09 <sopvop> @hoogle (=$)
01:37:09 <lambdabot> No results found
01:38:37 <sopvop> it was enumerator (if anyone cares)
01:38:49 <mikeplus64> @hoogle ($=)
01:38:49 <lambdabot> No results found
01:38:54 <mikeplus64> odd
01:39:24 <mikeplus64> @hoogle ($=) +StateVar
01:39:24 <lambdabot> No results found
01:40:17 <neutrino_> i have just wached the talk on data parallel haskell, it was fairly interesting. since then, has there been a development of non-shared-memory implementations?
01:40:28 <neutrino_> such as assigning tasks over MPI etc
01:41:45 <johnw> neutrino_: distributed-process
01:44:37 <sopvop> what are the ways of adding context to computation besides monad reader?
01:46:02 <johnw> State
01:46:11 <johnw> Implicit Parameters
01:46:16 <johnw> IORefs
01:46:18 <sopvop> ok, without "monad" thing in it
01:46:23 <sopvop> Now that is gross
01:46:30 <johnw> without any monad at all?
01:46:33 <johnw> function parameters
01:46:50 <fmap> reflection
01:46:56 <fmap> (I didn't say that.)
01:47:21 * sopvop is still mad about reflection
01:47:32 <sopvop> What about all that comonad things?
01:47:39 <johnw> you still need to pass one around
01:47:48 <ethercrow> you can also not say unsafePerformIO
01:48:18 <johnw> sure, if you want to use unsafePerformIO then just say "global variable" and hide your face from this channel forever more
01:50:27 <sopvop> Actually comonads look like it
01:50:46 <sopvop> (<<=) :: Comonad w => (w a -> b) -> w a -> w b   - is pretty much it
01:51:03 <neutrino_> johnw has a strict policy
01:52:56 <sopvop> I wonder what is the diffirence between ComonadApply and Apply?
01:54:39 <shachaf> class (Comonad w, FunctorApply w) => ComonadApply w
01:55:47 <sopvop> Methods have same signature
01:56:27 <sopvop> and it is class Comonad w => ComonadApply w where
01:56:34 <sopvop> Difference only in constraints.
01:58:16 <bartavelle> is it recommended to go with the HP when trying 7.6.1, or to bootstrap manually ?
02:00:26 <shachaf> Don't use the currently Haskell platform with 7.6.
02:01:40 <beaky> @hoogle (&)
02:01:41 <lambdabot> Prelude (&&) :: Bool -> Bool -> Bool
02:01:41 <lambdabot> Data.Bool (&&) :: Bool -> Bool -> Bool
02:01:41 <lambdabot> Control.Arrow (&&&) :: Arrow a => a b c -> a b c' -> a b (c, c')
02:01:55 <fmap> :t (&)
02:01:56 <lambdabot> a -> (a -> b) -> b
02:02:03 <fmap> :t ($)
02:02:05 <lambdabot> (a -> b) -> a -> b
02:04:08 <beaky> what's a good lens package for Haskell?
02:05:34 <fmap> bartavelle: you can get ghc-7.6.1 binaries from ghc website, no need to bootstrap yourself
02:06:08 <sopvop> beacky: lens
02:06:56 <vexy> is there a thread join function?
02:08:23 <bartavelle> fmap, I still need cabal to do anything useful, that's what I meant (improperly) by bootstrapping
02:08:25 <sopvop> wait on mvar
02:08:40 <bartavelle> I am doing manual cabal right now, donwloading and building all the prerequisites
02:09:00 <Saizan> there's a bootstrap.sh script
02:09:02 <sopvop> bartavelle: just unpack cabal-install and run bootstrap.sh
02:09:09 <bartavelle> ah !!!
02:12:07 <beaky> what ist he difference between Control.Lens and Data.Lens
02:12:40 <Taneb> Control.Lens is a lot fancier-schmancier
02:13:00 <Taneb> It allows for changing types with lenses
02:13:13 <Taneb> > _1 .~ 'a' $ (1, 2)
02:13:15 <lambdabot>   ('a',2)
02:13:26 <Taneb> And comes with a lot of built-in lenses
02:13:44 <Taneb> Also, it includes variations on the theme of lenses, with more or less power
02:13:45 <sopvop> beaky: Data.Lens are Costate Comonad Coalgebra, and Control.Lens are traversals
02:13:45 <beaky> ah
02:14:13 <beaky> Costate Comonad Coalgebra sounds pretty advanced :(
02:14:24 <beaky> guess I'll use Control.Lens
02:14:38 <sopvop> ;-)
02:14:53 <Taneb> Calling Data.Lens.Lens a Costate Comonad Coalgebra is like calling a Monad a monoid in the category of endofunctors
02:15:06 <Taneb> It's correct but doesn't help unless you already know what it means
02:15:24 <beaky> so what is a Costate Comonad Coalgebra?
02:16:04 * sopvop does not know
02:16:30 <Taneb> Essentially "a -> (b -> a, b)"
02:16:40 <beaky> ag
02:16:43 <beaky> ah*
02:16:57 <beaky> so it's just a getter/setter pair
02:17:02 <Taneb> Precisely
02:17:33 <sopvop> A ComonadApply w is a strong lax symmetric semi-monoidal comonad on the  category Hask of Haskell types. That it to say that w is a strong lax symmetric semi-monoidal functor on  Hask, where both extract and duplicate are symmetric monoidal natural  transformations. (c) Edwardk documenation.
02:17:51 <beaky> OOP folks called them getters and setters (or accessors and mutators) :D
02:17:57 <Taneb> The Costate Comonad, also called the Store comonad, is data Store s a = Store (s -> a) s
02:19:04 <sopvop> If you only need getters and setters then Data.Lens are fine, as long is you don't do polymorphic updates.
02:19:22 <beaky> what are polymorphic updates
02:19:27 <Taneb> Except with Control.Lens, you don't actually need to import anything to make one
02:19:33 <Taneb> beaky, updates that change the type
02:19:47 <beaky> my roguelike might need those :D
02:19:51 <Taneb> > _1 %~ length $ ("Hello", "World")
02:19:53 <lambdabot>   (5,"World")
02:20:02 <Taneb> Can't do that with a Data.Lens lens
02:20:06 <beaky> ah
02:20:06 <sopvop> Say you have data Foo a = Foo { foo :: a }. Data.Lens cant change Foo Int -> Foo String.
02:20:15 <Taneb> _1 is a Control.Lens lens
02:20:34 <beaky> what does %~ do
02:20:42 <aristid> :t (%~)
02:20:44 <lambdabot> Setting s t a b -> (a -> b) -> s -> t
02:20:52 <sopvop> Setting s t a b - lens
02:21:10 <aristid> it allows you to supply a modification function to a setter (a lens is also a setter)
02:21:11 <Skillson> I might seem quite dense for asking this, but is all of this lens stuff basically "we want to formalise getters and setters in the type system, so we'd better ask our category theory PhD friends how they would do it"?
02:21:41 <aristid> Skillson: fortunately we are all category theory PhDs here anyways.
02:21:42 <beaky> btw, why do lenses pack both the getter and setter together?
02:21:54 <Taneb> beaky, it makes it quite useful like that
02:22:02 <Taneb> It means you can both set and get
02:22:03 <aristid> beaky: you mean why Control.Lens.Lens lenses do that?
02:22:16 <beaky> ye
02:22:25 <Jafet> I don't think edwardk has a PhD in category theory
02:22:59 <Taneb> The type of the Control.Lens.Lens is type Lens s t a b = Functor f => (a -> f b) -> s -> f t
02:23:06 <Jafet> @quote edwardk dawg
02:23:06 <lambdabot> edwardk says: yo dawg, in haskell we can be so oop that even our accessors have UML diagrams describing their accessors.
02:23:07 <Taneb> (someone correct me if I go wrong, it's early)
02:23:10 <aristid> beaky: and specifically you wonder why they are not (getter,setter) but instead use a weird functor function?
02:23:23 <beaky> yeah
02:23:31 <beaky> is it for composition or something?
02:23:36 <Taneb> If f is "Const r", that becomes (a -> r) -> s -> r
02:23:41 <aristid> beaky: i think the main reason is that you can use Prelude's (.) for composition this way.
02:23:45 <Taneb> Which, if you give it id, becomes s -> a
02:23:48 <Taneb> Which is a getter
02:23:49 <beaky> ah
02:23:52 <shachaf> Skillson: No, it doesn't have much to do with that.
02:24:01 <Taneb> If you give it "Identity", it becomes (a -> b) -> s -> t
02:24:04 <Taneb> Which is a setter
02:24:12 <beaky> lenses make life easy
02:24:37 <Taneb> > _1 (`replicate` 'a') (2,3)
02:24:39 <lambdabot>   [('a',3),('a',3)]
02:24:47 <Taneb> Okay, that was stupid
02:24:51 <shachaf> Skillson: It has to do with making a bunch of different kinds of things fit into a common pattern.
02:25:16 <aristid> :t _1 (`replicate` 'a')
02:25:18 <lambdabot> Field1 s t Int Char => s -> [t]
02:25:54 <vexy> how come there is no thread join function, and just letting everyone define their own?
02:26:02 <Jafet> > over _1 (`replicate` 'a') (2, 3)
02:26:04 <lambdabot>   ("aa",3)
02:26:11 <beaky> lenses seem really great for programming situations where you have lots of coupling between data
02:26:18 <shachaf> vexy: Feel free to use a library that provides that, if you want that.
02:26:26 <shachaf> vexy: For example "async".
02:26:38 <mm_freak_> what does it mean to "join" threads?  making them agree?
02:26:50 <merijn> mm_freak_: Waiting for threads to terminate
02:27:00 <Jafet> Something to do with tying knots, I bet
02:27:27 <mm_freak_> merijn: sure, but what exactly?  i mean, waiting can be as simple as waiting for an MVar ()
02:27:37 <mm_freak_> or equivalently a TVar Bool
02:27:53 <Jafet> Yes, that's usually how you join threads.
02:28:03 <merijn> mm_freak_: Sure, but vexy was just asking why there was no predefined thing for that
02:28:45 <mm_freak_> well, there are too many ways to join threads, but i understand the desire
02:29:10 <shachaf> mm_freak_: vexy was asking why there's no waitForThread :: ThreadId -> IO () or so.
02:29:18 <whaletechno> &quit bbl
02:30:04 <Jafet> @hoogle ThreadId -> IO ()
02:30:05 <lambdabot> Control.Concurrent killThread :: ThreadId -> IO ()
02:30:05 <lambdabot> GHC.Conc.Sync killThread :: ThreadId -> IO ()
02:30:05 <lambdabot> GHC.Conc killThread :: ThreadId -> IO ()
02:30:13 <mm_freak_> i don't know where that would be useful…  i'd rather want something like:  async :: IO a -> IO (IO a)
02:30:13 <Jafet> Sounds right
02:30:27 <aristid> Jafet: join would _wait_, not kill
02:30:34 <Jafet> Pft
02:30:37 <mrout> how do I haskell?
02:30:56 <aristid> mrout: by installing GHC and typing funny text into files.
02:31:08 <Jafet> You can has kell
02:31:28 <Taneb> @where lyah
02:31:28 <lambdabot> http://www.learnyouahaskell.com/
02:31:32 <Taneb> mrout, that
02:31:46 <mrout> Taneb: tyvm
02:32:01 <vexy> mm_freak_: when you want to prevent main from returning (and terminating the program) before other threads terminated
02:32:45 <shachaf> vexy: So spawn those threads with async instead of forkIO
02:32:55 <shachaf> Async is a standard library meant exactly for this.
02:33:01 <shachaf> Er, not "standard library" standard.
02:33:05 <shachaf> Just, y'know, standard.
02:33:16 <mm_freak_> vexy: if you have a fixed set of such threads, i'd say your best option is to write a combinator for running them
02:33:36 <mrout> "The channel #haskell on the freenode network is a great place to ask questions if you're feeling stuck. People there are extremely nice, patient and understanding to newbies." <-- lol, but it's irc. that's unpossible.
02:33:37 <mm_freak_> withThread :: IO a -> (MVar a -> IO b) -> IO b
02:33:50 <Jafet> It's marketing drivel
02:33:56 <Jafet> Let us abuse you
02:34:10 <mm_freak_> vexy: except that one is probably easier to write using STM
02:34:23 <mm_freak_> withThread :: IO a -> (TMVar a -> IO b) -> IO b
02:34:48 <mrout> this seems very mathematical. "If you say that a is 5, you can't say it's something else later because you just said it was 5. What are you, some kind of liar?"
02:35:10 <Taneb> Yeah, it is
02:35:40 <Taneb> Don't let that scare you
02:35:44 <mm_freak_> mrout: haskell uses the mathematical notion of variables
02:35:47 <mrout> shit no, I love maths
02:35:53 <Jafet> > do let{ a = 5 }; let{ a = 6; }; [a]
02:35:54 <Skillson> Well you're in luck then!
02:35:55 <lambdabot>   [6]
02:36:05 <mrout> mm_freak_: how so?
02:36:15 <Taneb> It's all maths
02:36:33 <Taneb> And category theory, which is just one math of the many maths
02:36:43 <Skillson> If you like maths, you'll love Haskell. If you don't like maths, that alone won't stop you from loving Haskell.
02:36:45 <mm_freak_> mrout: simple: reassigning variables makes no sense in haskell
02:37:08 <mm_freak_> category theory is the one to rule them all
02:37:10 <mrout> mm_freak_: oh sorry I thought you said "the mathematical NOTATION of variables"
02:37:25 <mrout> ignore the "how so?" comment.
02:37:42 <mrout> Taneb: category theory? excellent.
02:38:03 <mm_freak_> mrout: well, the notation is also very mathematical =)
02:38:10 <mm_freak_> > let x = 3 in sin x
02:38:12 <lambdabot>   0.1411200080598672
02:38:17 <mrout> Also, can you write proper programs in Haskell? Like a compiler, or an interpreter, or a game or something? Or is it just for mathematics, etc.?
02:38:31 <mm_freak_> mrout: all of those have been written in haskell
02:38:35 <Jafet> @quote abstract.research
02:38:35 <lambdabot> Jafet says: Haskell is an abstract research language used only in academia, education, banking, stock trading, circuit design, embedded systems, cryptography, operating systems research, bioinformatic
02:38:35 <lambdabot> s, phone apps, and web services.
02:38:35 <mrout> not that mathematics isn't a proper program. but you know what i mean
02:38:37 <Taneb> @faq Can you write proper programs in Haskell?
02:38:37 <lambdabot> The answer is: Yes! Haskell can do that.
02:38:43 <Ralith> the main haskell compiler is written in haskell
02:38:53 <mm_freak_> mrout: GHC is a compiler and interpreter, there are also agda, idris and a lot of other languages implemented in haskell
02:39:22 <mm_freak_> ipwn has written an iphone game in haskell
02:39:24 <mrout> "... cryptography, operating systems research, ..." <-- this sounds like my sort of language.
02:39:37 <Ralith> haskell is easily my first choice for compiler stuff these days
02:39:54 <vexy> mrout: xmonad is window manager written in haskell
02:39:54 <mrout> referential transparency sounds like it will be useful.
02:39:55 <mm_freak_> there is also a proof of concept 3D game implementation that allows you to load and walk through Q3A maps:  frag
02:40:00 <mrout> I dunno what for, but it sounds useful.
02:40:42 <mm_freak_> mrout: all those features together allow you to write programs as compositions of isolated pieces
02:40:51 <mm_freak_> that makes programming much easier and bugs much less likely
02:41:07 <mrout> awesome
02:41:19 <mrout> this should be a nice change from debugging segfaults and pointer arithmetic
02:41:23 <vexy> and it is a lot more fun too, for me at least
02:41:50 <mrout> picking up dog shit is more fun than debugging segfaults
02:42:47 <monadicity> what is the best dog shit to pick up?
02:43:03 <vexy> I didnt mean in comparison to segfaults but when compared to higher level imperative or OOP languages
02:43:05 <mm_freak_> i don't think i've ever really "debugged" a haskell program…  most of my bugs are like memory leaks or infinite loops, where i would have expected a value
02:43:24 <mm_freak_> and they have all been quite straightforward to fix
02:43:36 <shachaf> mm_freak_: Really?
02:43:52 <mrout> mm_freak_: ahh, but how do you know it's an infinite loop and it won't eventually halt?
02:43:57 <monadicity> no one does crypto in haskell don't be absurd
02:44:01 <mrout> :P
02:44:13 <shachaf> You've never written a Haskell program with a bug?
02:44:23 <mm_freak_> shachaf: so far yes…  i think my worst bug took me around 10-15 minutes to fix, and that was when i got alpha equivalence wrong for a home-made programming language
02:44:24 <shachaf> Or you just haven't bothered fixing the bugs?
02:44:28 <ethercrow> mm_freak_: could you pretty please fix all the leaks in yi then?
02:44:33 <mm_freak_> shachaf: nowadays that can't happen anymore, because i'm using 'bound' =)
02:44:51 <mrout> monadicity: bitch please http://www.haskell.org/haskellwiki/Applications_and_libraries/Cryptography
02:45:22 <mm_freak_> shachaf: i certainly wrote haskell programs with bugs, but debugging them was so straightforward that i hardly call this "debugging"
02:45:32 <mm_freak_> in particular, i saw the behavior and fixed it right away
02:46:16 <`ramses> instead of debugging, you get to wrestle with the type checker :)
02:46:16 <mrout> mm_freak_: tell us more about your homemade programming language
02:46:17 * Ralith reiterates ethercrow's request
02:46:18 <mm_freak_> mrout: well, in some cases it's obvious enough that your program throws a "<<loop>>" exception =)
02:46:27 <mm_freak_> mrout: in other cases you can only observe program behavior
02:46:30 <mrout> mm_freak_: I was joking :P
02:47:46 <mrout> It has ==? :( Can't have everything
02:48:12 <mm_freak_> mrout: you use (==) much less frequently in haskell
02:48:24 <ethercrow> mrout: it doesn't have != as "not equals"
02:48:32 <mrout> Oh good.
02:48:34 <mrout> to both of those
02:48:45 <Ralith> we have /= instead!
02:48:52 <Ralith> much prettier..
02:49:08 <`ramses> and you still need some way to distinguish between assignement and equality testing
02:49:11 <ethercrow> except that you can forget if it's /= or \=
02:49:29 <mm_freak_> mrout: i have a library that spans 3363 lines of code, where i use (==) exactly three times =)
02:49:48 <mm_freak_> that's because Bool is considered harmful
02:50:08 <ethercrow> is 'if' considered harmful?
02:50:09 <mrout> harmful? Bool is a Bad Thing(tm)?
02:50:19 <srhb> ethercrow: I would never write not equal with the dash wrong like that :P
02:50:23 <Jafet> In which parts of the world is not-equals written \=?
02:50:37 <mm_freak_> ethercrow: that follows…
02:51:05 <ethercrow> Jafet: same question about /=
02:51:18 <mm_freak_> ≠
02:51:20 <ethercrow> why not =/= then
02:51:20 <srhb> ethercrow: Mentally transpose the line on top of the equals sign
02:51:21 <Jafet> Everywhere
02:51:25 <srhb> It's the standard :P
02:51:25 <mrout> I write not-equals =/=
02:51:43 <Ralith> I write it [*&[&&^%, myself.
02:52:02 <Ralith> but maybe that's just me.
02:52:07 <mm_freak_> i think symmetric operators should be reserved for applicative style…
02:52:18 <mm_freak_> or monoidal stuff
02:52:23 <ion> ≠
02:52:36 <ethercrow> we should just use `noWayTheseAreEqual`
02:52:43 * ion notices mm_freak already said that.
02:52:45 <Jafet> a =/= b = a /= b
02:53:47 <Jafet> Ralith: disregarding ghc, how does your text editor deal with the brackets
02:53:57 <Yuu-chan> |\|[]*|*[-[],\//-\|_
02:54:07 <kennyd> > x =/= y = x /= y
02:54:08 <lambdabot>   <hint>:1:9: parse error on input `='
02:54:27 <kennyd> > let x =/= y = x /= y
02:54:28 <ethercrow> vim thinks that digraph <C-k>/= is ‡, not ≠
02:54:29 <lambdabot>   not an expression: `let x =/= y = x /= y'
02:54:42 <Yuu-chan> > let x =/= y = x /= y in 1 =/= 2
02:54:44 <lambdabot>   True
02:55:13 <Yuu-chan> Fancy!
02:55:37 <mrout> Jafet: why would a text editor need to deal with brackets?
02:56:36 <vexy> .
02:56:40 <ethercrow> he just wants to be sure you won't be tempted by lisp too much
02:57:00 <mrout> ((()()(((()()()))))()())()))) fuck lisp
02:59:18 <vexy> 1 downloadFiles = mapM_ (forkIO . downloadFile)  <- with standard threads how would you launch only N threads at the time, until all the files are downloaded?
02:59:26 <Skillson> Lisp is kind of neat to study, but fuck making anything in it. It's ultimate power through the complete removal of safety.
02:59:30 <ofan> mrout: +1
02:59:53 <srhb> vexy: Seems easier to make a recursive handler with some MVars that gets stuck when the MVar is above some number
02:59:56 <Skillson> You can build these wonderful abstractions and feel the power of code and data being equal, but fuck one tiny thing up, and you shoot your foot so hard that you destroy the Earth.
03:00:16 <srhb> Well, maybe not an MVar..
03:00:35 <mrout> Syntax Error Detected. Earth self-destruct will activate in 5, 4, 3...
03:00:43 <ofan> sounds like c++
03:00:52 <Skillson> launchMissiles :: IO ()
03:00:58 <Ralith> Jafet: for convenience, I encode it in base64 when programming.
03:01:10 <Jafet> Seems easier to use a library that launches only N threads at a time
03:01:41 <vexy> Skillson: I found it to be safer than some other dynamic languages,for example python. CL compiler warns about far more things
03:01:49 <Ralith> Skillson: clearly you've never used forth
03:02:17 <Skillson> Fuck dynamic languages. Ralith, you're correct. Should I have?
03:02:27 <Ralith> depends
03:02:35 <Ralith> are you a student of PL design?
03:02:42 <mrout> dynamic languages are excellent. I love python
03:02:56 <Skillson> No, I am not.
03:02:56 <Jafet> Oh, it's troll hour
03:03:18 <luto> ha! the /topic on #haskell is valid haskell! :D
03:03:22 <Ralith> Skillson: then I wouldn't bother.
03:03:28 <mrout> Ralith: did you say forth? :D
03:03:43 <mrout> forth is fucking amazingsauce
03:03:48 <Ralith> Skillson: and I also wouldn't make sweeping generalizations.
03:04:02 <vexy> python is lisp for idiots, ruby is smalltalk for idiots
03:04:27 <srhb> This is off-topic (and silly)
03:04:28 <mrout> "Python is lisp for idiots" <-- wow, the stupidest thing I've read all day
03:04:35 <luto> vexy: what is java then? :D
03:04:41 <mrout> C++ for idiots
03:04:49 <Hafydd> Haha.
03:04:50 <Skillson> COBOL for the modern businessman?
03:04:57 <mrout> Skillson: roflmao
03:06:09 <beaky> haskell is like haskell
03:06:38 <beaky> :t let haskell = haskell in haskell
03:06:40 <lambdabot> t
03:06:56 <Skillson> Haskell is Haskell for people with PhDs in category theory.
03:07:10 <mrout> I need a PhD in category theory.
03:07:21 <mrout> Not because of haskell though. Just because it looks mighty interesting.
03:08:15 <ion> :t let haskell = haskell in haskell :: haskell
03:08:16 <lambdabot> haskell
03:08:31 <Skillson> Types should have capital letters, ion.
03:09:00 <ion> :t let haskell = haskell in haskell :: hASKELL -- ok, sir
03:09:02 <lambdabot> hASKELL
03:09:21 <mrout> Skillson: you sound like someone that would support linguistic prescriptivism.
03:10:37 <`ramses> Skillson: type variables don't :)
03:12:16 <`ramses> let haskell = haskell in haskell ;; Haskell -- Skillson this wont even type check without a real type "Haskell" being in scope
03:12:37 <`ramses> err
03:12:39 <`ramses> > let haskell = haskell in haskell :: Haskell
03:12:41 <lambdabot>   Not in scope: type constructor or class `Haskell'
03:12:57 <sopvop> newtype Haskell = { getHaskell :: RealWorld# }
03:14:04 <mrout> Haskell seems kinda similar to forth. dunno why.
03:14:30 <ion> Yes, both are stack-based impure languages.
03:15:15 <mreh> *sarcasm detected*
03:15:15 <mrout> haskell is pure functional, apparently.
03:15:40 <mrout> just the composition of functions thing, that's all
03:15:45 <wuttf> Any example of a basic MVCish app written in Haskell I can learn from?
03:16:30 <mm_freak_> wuttf: look at the common web frameworks…  most of them have a collection of links to real world projects with source code
03:16:41 <mm_freak_> at least for happstack, snap and yesod
03:16:58 <sopvop> mm_freak_ you have time for... reflection? :)
03:17:05 <wuttf> mm_freak_: I hoped for something small, but thanks.
03:17:09 <mm_freak_> sopvop: always =P
03:17:19 <mm_freak_> wuttf: they are "small" =)
03:17:29 <mreh> happstack is pretty light
03:17:32 <ion> > let model = 42; view = show; controller = view model in controller
03:17:34 <lambdabot>   "42"
03:17:55 <mrout> 42
03:18:03 <sopvop> So can you annotate with reflection way? http://hpaste.org/79629
03:18:07 <wuttf> mm_freak_: Really? Nice!
03:19:03 <mm_freak_> wuttf: the core of happstack and snap is very light…  yesod is heavier, but still far from the monoliths of the common web frameworks in other languages
03:20:05 <sopvop> happstack has lots of utility libraries, easy to get lost
03:20:07 <mm_freak_> sopvop: you seem to be mixing up type/value level there
03:20:35 <aristid> i thought you were talking about the size of applications written using these frameworks, not the frameworks themselves *confused*
03:20:42 <srhb>  aristid: Me too.
03:20:56 <sopvop> The thing is, I have type of 'a', but not value of 'a'. and want to get some value from type.
03:21:06 <mm_freak_> well, applications written using happstack/snap/yesod tend to be very small
03:21:42 <mrout> any haskell interpreters on windoze? I cbf restarting to linux, installing X, gdm, etc.
03:21:43 <mm_freak_> even form handling is pretty much a solved problem using digestive-functors or its modern variant reform
03:21:51 <mm_freak_> mrout: GHC
03:22:04 <mrout> mm_freak_: how nicely does it work?
03:22:10 <aristid> mm_freak_: and yesod also has some relatively nice stuff for form handling
03:22:23 <mm_freak_> mrout: except for some edge cases it works just as nice as the linux version
03:23:32 <Hafydd> mrout: why do you need X to use a Haskell interpreter?
03:24:01 <kennyd> mrout haskell platform comes with everything you need
03:24:20 <mrout> because I hate lynx
03:24:22 <mm_freak_> aristid: i don't really like yesod's approach (or any approach that is bound to the underlying framework)
03:25:01 <Hafydd> Fair point.
03:25:08 <Jafet> Trolling aside, some GHC distributions try to install x11.
03:25:25 <aristid> Jafet: which?
03:25:31 <sopvop> GHC or HP?
03:25:50 <Jafet> Perhaps it is the platform that does this.
03:25:55 <mrout> well to be truthful, I installed x and it didn't work, so I uninstalled it again
03:25:56 <sopvop> HP includes at least OpenGL
03:26:12 <aristid> mm_freak_: the reform package is a bit hard to understand from the haddocks
03:26:26 <mm_freak_> aristid: it's really just digestive-functors on steroids
03:26:34 <mm_freak_> however, i don't use it yet
03:26:47 <Jafet> aristid: you sound surprised
03:27:08 <aristid> Jafet: yes, i'm like a goldfish: always surprised at every blink of the eye
03:31:04 <Jafet> Speaking of which, where is the OpenGL package documentation?
03:32:06 <Jafet> Oh, there actually is documentation!
03:32:10 * Jafet is surprised
03:32:30 <aristid> stepcut: you seem to put most of your docs in the crash course. could you please link the crash course chapters from the haddocks?
03:32:45 <aristid> i found the reform docs: http://happstack.com/docs/crashcourse/Reform.html#reform
03:35:49 <vexy> silly question: why can you use do notation for yielding a STM (software transaction memory) object? I was under the impression that do is just for IO
03:36:16 <merijn> vexy: do notation is just syntactic sugar for >>= and >> which are functions that work on any monad
03:36:24 <mrout> monad?
03:36:39 <srhb> mrout: A type class.
03:36:47 <srhb> mrout: (That provides >>= and return)
03:36:47 <merijn> vexy: So, in fact, do notation will also work for STM, list, Maybe, Either a and any other data structure that's an instance of the monad typeclass
03:36:57 <mrout> srhb: what's a monad?
03:37:03 <neutrino_> hey guys
03:37:03 <vexy> merijn: oh I see
03:37:07 <ion> @src Monad
03:37:08 <lambdabot> class  Monad m  where
03:37:08 <merijn> vexy: Including data structure you defined yourself
03:37:08 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
03:37:08 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
03:37:08 <lambdabot>     return      :: a -> m a
03:37:08 <lambdabot>     fail        :: String -> m a
03:37:12 <srhb> mrout: A type class that provides >>= and return functions.
03:37:20 <mrout> that means nothing to me
03:37:32 <neutrino_> i just made a page on the DPH paper, i was wondering if anyone had anything to add: http://functionalpapersupdated.wikia.com/wiki/Harnessing_the_Multicores
03:37:36 <ion> mrout: LYAH will cover monads.
03:37:40 <mrout> ok
03:37:41 <mrout> ty
03:37:42 <srhb> mrout: Probably will once you've experimented with those functions. :)
03:37:47 <merijn> vexy: The basic rule is that "do { foo; bar }" translates to "foo >> bar" and "do { x <- foo; bar x }" translates to "foo >>= bar"
03:37:55 <kennyd> mrout http://en.wikipedia.org/wiki/Monad_%28functional_programming%29
03:38:12 <mm_freak_> > do x <- [1,2,3]; y <- [10,20,30]; return (x + y)
03:38:13 <lambdabot>   [11,21,31,12,22,32,13,23,33]
03:38:25 <vexy> whoa what?
03:38:27 <aristid> haha. type SimpleForm = Form (AppT IO) [Input] AppError [AppT IO (XMLType (ServerPartT IO))] ()
03:38:42 <aristid> simple indeed
03:38:48 <ion> hah
03:38:50 <mm_freak_> > [1,2,3] >>= \x -> [10,20,30] >>= \y -> return (x + y)
03:38:51 <lambdabot>   [11,21,31,12,22,32,13,23,33]
03:39:10 <vexy> looks like what you would get with list comprehension
03:39:16 <mm_freak_> > concatMap (\x -> concatMap (\y -> [x + y]) [10, 20, 30]) [1,2,3]
03:39:16 <Jafet> aristid: with types like that, why do you even need written documentation?
03:39:17 <lambdabot>   [11,21,31,12,22,32,13,23,33]
03:39:31 <mm_freak_> in other words, for lists (>>=) is flip concatMap and return x = [x]
03:39:58 <mm_freak_> interestingly in most cases i'd prefer the ZipList semantics, but then [] wouldn't be a monad anymore
03:40:04 <kennyd> > do x <- Just 10; y <- Just 20; return (x + y)
03:40:05 <lambdabot>   Just 30
03:40:07 <mm_freak_> (it would be, but not a very useful one)
03:40:08 <srhb> > let foo = Nothing in do { x <- foo; return (x+42) }
03:40:10 <lambdabot>   Nothing
03:40:19 <aristid> vexy: list comprehensions are in fact basically a specialization of monad syntax
03:40:24 <neutrino_> feel free to contribute to that page if you spot any omissions or errors
03:41:25 <mm_freak_> aristid: list comprehensions are equivalent to monadic syntax
03:41:37 <mm_freak_> well, if you add MonadPlus
03:41:41 <mm_freak_> ah
03:42:06 <vexy> mm_freak_: why wouldn't it be a monad if it used ZipList?
03:42:08 <Jafet> > (do x <- succ; y <- pred; return $ x * y) 100
03:42:10 <lambdabot>   9999
03:42:19 <mm_freak_> vexy: it would be a monad, but a very inefficient one
03:43:28 <aristid> mm_freak_: yes, and without -XMonadComprehensions they are specialized to lists.
03:43:43 <mm_freak_> vexy: with ZipList semantics you would have:  do x <- [10, 20, 30]; y <- [1, 2, 3]; return (x + y) = [11, 22, 33]
03:44:02 <mm_freak_> implementing that in terms of '
03:44:07 <aristid> mm_freak_: i believe ZipList join can sometimes require infinite time
03:44:18 <mm_freak_> implementing that in terms of 'return' and (>>=) gives you linear time complexity for element positions
03:44:31 <mm_freak_> so it essentially squares the time needed to ask for the n-th element
03:44:57 <mm_freak_> aristid: what exactly?
03:45:21 <mm_freak_> join (return 1) would produce an infinite list, of course, but that's not equivalent to infinite time in haskell
03:45:28 <mm_freak_> uhm
03:45:33 <mm_freak_> join (return (return 1))
03:47:26 <aristid> mm_freak_: well how would you implement join for ZipList?
03:47:49 <mm_freak_> aristid: diagonalization
03:48:13 <mm_freak_> join ((x:_):xs) = x : join (map tail xs)
03:48:17 <mm_freak_> something like that (untested)
03:48:59 <ion> or drop 1
03:49:09 <aristid> mm_freak_: that only works for infinite ziplists, but i get the idea
03:49:14 <aristid> ion: no that breaks the monad laws
03:49:17 <ion> oh
03:49:35 <mm_freak_> i don't think the ZipList /monad/ is really well defined for finite lists
03:49:37 <aristid> wait drop 1 doesn't even have the right type
03:49:46 <ion> @type [tail, drop 1]
03:49:48 <lambdabot> [[a] -> [a]]
03:50:01 <aristid> mm_freak_: oh i suppose that's the real reason why ZipList is not a monad
03:50:03 <aristid> Stream is
03:50:17 <mm_freak_> Stream also seldomly has a Monad instance, precisely because of this
03:50:22 <mm_freak_> 'join' is sloooooooow
03:50:26 <mm_freak_> just like (>>=)
03:50:28 <aristid> mm_freak_: yes, but it exists
03:50:32 <mm_freak_> sure
03:50:36 <aristid> it's just rather useless
03:50:41 <Jafet> Why is it slow
03:50:56 <aristid> mm_freak_ should know given that netwire is basically a fancy Stream type ;)
03:51:14 <mm_freak_> Jafet: the tails are chained for every element
03:51:39 <mm_freak_> asking for the fourth element is asking for the head . tail . tail . tail of a list
03:52:11 <Jafet> Uh, what is Stream
03:52:25 <aristid> data Stream a = Stream a (Stream a)
03:52:42 <Jafet> That looks like a list
03:52:47 <aristid> it isn't.
03:52:51 <Jafet> I fail to understand
03:52:54 <aristid> note the lack of a Nil constructor.
03:53:10 <aristid> it's a list that is bound to be infinite by construction
03:53:35 <Jafet> It's not going to be more efficient than a list
03:53:37 <mm_freak_> Jafet: head and tail are total for Stream
03:53:38 <aristid> which then allows for a valid but slow ZipList-like monad
03:53:44 <mm_freak_> Stream is even a comonad
03:53:53 <mm_freak_> and a very weird monad
03:53:59 <Jafet> The obvious comonad
03:54:03 <ceii> exit
03:54:07 <ceii> oops, sorry
03:54:12 <aristid> the obvious comonad is Identity IMHO
03:54:20 <Jafet> No, that's the trivial comonad
03:54:27 <mm_freak_> Jafet: forget fusion/deforestation for a moment
03:54:29 <vexy> it is completely new to me that Maybe, List, etc are Monads, and that you can use do/=<< to chain operators on them. I think I am not far from grokking monads
03:54:31 <Jafet> (someone will now mention Trivial)
03:54:35 <mm_freak_> when you do that, you will find that Stream is /more/ efficient
03:54:45 <mm_freak_> and because of the lack of Nil it's also easier to optimize using RULEs
03:55:10 <aristid> it's also easier to reason about if you know your lists are infinite and the type guarantees that...
03:55:14 <mm_freak_> it makes many programs well-defined, where they would be ill-defined when they used lists
03:55:33 <mm_freak_> for example 'find' doesn't give you a Maybe for Stream
03:55:41 <mm_freak_> find :: (a -> Bool) -> Stream a -> a
03:55:47 <aristid> mm_freak_: it's still partial oO
03:56:04 <Jafet> Totally partial
03:56:14 <mm_freak_> yes, but you don't need fromJust
03:56:26 <shachaf> Stream find is partial all on its own.
03:56:27 <aristid> obviously you can't return a Maybe because you can't prove the element is not there from inside the system
03:56:31 <shachaf> For list find, you need fromJust to make it partial.
03:56:48 <shachaf> Clearly stream find is more convenient.
03:57:14 <Jafet> You have to import Data.Maybe to search lists. So inconvenient.
03:57:43 <aristid> Jafet: while i'm not sure what mm_freak_'s point regarding find is, this is pretty certainly not it.
03:57:52 <mm_freak_> well, i often have the problem that i have a stream and want to find an element, for which i can mathematically prove that it exists
03:58:09 <mm_freak_> so 'find' would be total with the corresponding proof
03:58:12 <Jafet> I'm not sure what we are talking about anyway
03:58:27 <shachaf> Lenses?
03:58:35 <shachaf> Patricia trees!
03:58:36 <aristid> Stream is a useful type sometimes. just believe it, everyone.
03:58:42 <shachaf> Is it reasonable to make a lazy patricia tree?
03:58:49 <aristid> shachaf: that was in #haskell-lens :)
03:59:09 <mm_freak_> aristid: obviously it's useful…  Stream gave us AFRP =)
03:59:23 <Jafet> Why not a lazy susan tree?
04:01:48 <akamaus> hi! Then I apply show to a string with cyrillic letters, I receive the result in a quoted  unreadable representation. Is there a way to make show output strings in utf-8?
04:02:14 <shachaf> The show instance for Strings will give you escape sequences.
04:02:19 <Yerzhan> which FP language is the fastest ?
04:02:21 <srhb> akamaus: The whole point of show is to escape.
04:02:21 <shachaf> If you want to print the string, just print it.
04:02:36 <shachaf> putStrLn "я"
04:02:39 <shachaf> Should work fine.
04:02:48 <arrowdodger> Hi guys. I wrote a binding to some C lib and that lib calls select() somewhere inside it. The problem is that using this lib from haskell causes that select() to constantly return EINTR. When i add +RTS -V0 to the command line, the problem is gone. Any ideas?
04:03:14 <mrout> according to this tutorial, ifs MUST have elses.
04:03:21 <mrout> that seems.. difficult to work around
04:03:28 <ciaranm> mrout: everything is an expression
04:03:39 <mrout> oh I know WHY
04:03:42 <ciaranm> mrout: if you don't have an else, what's the value of the expression?
04:03:42 <ion> mrout: Do you have an example of where you think it would be difficult?
04:04:06 <mm_freak_> Yerzhan: for what?
04:04:39 <Yerzhan> mm_freak_: just if we compare performance
04:04:41 <mrout> ion: Not really
04:04:47 <srhb> Yerzhan: There's no such thing.
04:04:55 <mm_freak_> arrowdodger: it's mostly just wrong to call select() via FFI
04:05:03 <Hafydd> Yerzhan: languages do not possess speed.
04:05:21 <ion> mrout: Whatever you’re thinking of, if probably isn’t appropriate for that anyway.
04:05:35 <Yerzhan> srhb: didn't get it
04:05:43 <arrowdodger> mm_freak_: Well, it's not me, but foreign lib. Is it wrong to write bindings to things, that may call select()?
04:05:43 <mrout> ion: yeah, probab.y
04:05:46 <mrout> probably
04:05:46 <Yerzhan> srhb: the language has a speed ?
04:05:47 <mm_freak_> Yerzhan: the answer depends on application and compiler (let's assume GHC)
04:05:52 <arrowdodger> Anyway, what should i do now?
04:06:22 <mm_freak_> arrowdodger: create a new thread for that particular library using forkOS
04:06:29 <shachaf> arrowdodger: Have you tried running it in its own thread?
04:06:31 <Yerzhan> mm_freak_: for instance I made a recursion for counting n! in haskell and  C++ and scala which will be faster?
04:06:33 <mm_freak_> arrowdodger: and don't do any waiting on the haskell side for that thread
04:06:38 <mrout> Hafydd: what?
04:06:49 <ciaranm> Yerzhan: that's a silly way to calculate n!
04:07:00 <Jafet> My buddy next door, however, possesses some good speed.
04:07:05 <arrowdodger> Don't do any waiting? Hmm...
04:07:10 <mm_freak_> Yerzhan: you want to calculate n!?
04:07:14 <Yerzhan> ciaranm: just want to know about s speed
04:07:25 <Yerzhan> mm_freak_: no
04:07:27 <srhb> I wish our resident bot had a rant about speed questions, they take up so much space.
04:07:30 <ciaranm> Yerzhan: well it depends. if you're doing it in c++, you'd produce a lookup table at compile time
04:07:37 <mm_freak_> arrowdodger: in other words, don't call getLine or anything else that might wait (and thus cause an epoll in haskell)
04:07:37 <mrout> how else do you calculate n! ?
04:07:39 <Yerzhan> mm_freak_: just want to choose a FP language is it good for making projects
04:07:46 <mm_freak_> Yerzhan: haskell
04:07:54 <mrout> n! = n*( (n-1)! )
04:07:58 <mm_freak_> but now you're asking an entirely different question
04:08:06 <ciaranm> mrout: iteratively. but ghc optimises to that anyway.
04:08:21 <arrowdodger> mm_freak_: But that lib is a GUI toolkit. How i'm supposed to implement mainGUI then?
04:08:22 <Yerzhan> mm_freak_: performance is the important factor in my project
04:08:23 <mrout> ciaranm: Exactly. I thought FP languages had tail recursion optimsation anyway
04:08:25 <ciaranm> Yerzhan: haskell is usually fast enough
04:08:36 <ciaranm> mrout: "tail recursion" is a dodgy term. don't use it.
04:08:43 <mm_freak_> Yerzhan: there is Integer computation performance, Double computation performance, I/O performance, etc.
04:08:45 <akamaus> shachaf, I have a type record with string fields and I want to inspect the values in ghci.
04:08:46 <mrout> ciaranm: how?
04:08:50 <mm_freak_> Yerzhan: please choose one
04:08:52 <mrout> it's a pretty well defined term
04:09:02 <aristid> mrout: when applied to haskell, it does not make a lot of sense.
04:09:10 <mm_freak_> arrowdodger: see the documentation of 'bound' and 'forkOS'
04:09:10 <ciaranm> mrout: whether or not a compiler can eliminate recursion has little to do with whether it's "tail"
04:09:11 <aristid> because of the non-strict evaluation model
04:09:23 <mm_freak_> :t bound
04:09:25 <lambdabot>     Not in scope: `bound'
04:09:25 <lambdabot>     Perhaps you meant one of these:
04:09:25 <lambdabot>       `round' (imported from Prelude),
04:09:25 <akamaus> srhb, but compiler happily accepts unicode strings in unescaped form.
04:09:28 <mm_freak_> uhm
04:09:30 <ciaranm> mrout: in particular, if you're rewriting your code to be "tail recursive", you're doing it horribly wrong
04:09:36 <Yerzhan> mm_freak_: for instace Integer computation performance and I/O performance
04:09:38 <srhb> akamaus: So?
04:09:59 <mm_freak_> aristid: runInBoundThread that is
04:09:59 <srhb> Yerzhan: Yes, Haskell can be very fast for those jobs.
04:10:14 <aristid> mm_freak_: you meant arrowdodger?
04:10:21 <Jafet> Perhaps Yerzhan is too poor to afford a stopwatch.
04:10:23 <mm_freak_> Yerzhan: you get very good concurrent I/O and Integer performance in haskell
04:10:32 <mm_freak_> other languages are better for Double computations
04:10:36 <mm_freak_> aristid: yes, sorry
04:10:40 <mm_freak_> arrowdodger: runInBoundThread that is
04:10:58 <arrowdodger> Ok, let me RTM a bit.
04:11:21 <akamaus> srhb, why doesn't it return them in the same form? Maybe it's a pointless complaint.. I'm just looking for a way  to my data types.
04:11:30 <Yerzhan> Jafet: It's silly to install all FP languages and compare performances if i just can get answer
04:11:40 <mm_freak_> > scanl (*) 1 [1..]
04:11:42 <lambdabot>   [1,1,2,6,24,120,720,5040,40320,362880,3628800,39916800,479001600,6227020800...
04:11:42 <ciaranm> Yerzhan: it's a silly question
04:11:43 <Yerzhan> Thank you for answers!
04:11:43 <srhb> akamaus: Because show is a function designed to escape whatever value is there in a String form
04:11:58 <srhb> akamaus: You're asking why show does exactly what it does: Because that's what it's supposed to do. :)
04:12:23 <srhb> akamaus: If you want to output the String, do so with putStr or something similar. If you want to pass it on in an unescaped form, do nothing to it.
04:12:34 <akamaus> srhb, got it :) Still, is there a way to relax that behavior a bit?
04:12:53 <mrout> Can you have the equivalent of python's generators in Haskell?
04:12:54 <srhb> akamaus: Yes, you can implement your own Show instance (but that's very silly, why would you do that)
04:12:59 <srhb> akamaus: What are you trying to do?
04:13:22 <mm_freak_> Yerzhan: Integer computation in GHC haskell uses GMP, but outperforms C, when you use the mpz_* interface, so haskell is a very good language for Integer computation, especially when you want to parallelize it
04:13:24 <akamaus> srhb, ghc had derived Show instances for my types using show. That bothers me
04:13:29 <ciaranm> mrout: the "equivalent" in haskell is quite a bit more sophisticate
04:13:30 <ciaranm> d
04:13:33 <ion> mrout: IO or pure? For the latter, lists.
04:13:52 <srhb> akamaus: I don't understand why.
04:13:56 <edwardk> sopvop: what makes you made about reflection?
04:13:57 <mrout> ciaranm: how so?
04:14:09 <edwardk> sopvop: the difference between Apply and ComonadApply is in the laws.
04:14:09 <Yerzhan> mm_freak_: Thank you if haskell outperforms C at some points I guess it's really fast
04:14:13 <ciaranm> mrout: haskell is lazy / non-strict
04:14:29 <mrout> i've heard lazy. non-strict?
04:14:44 <Jafet> akamaus: it is an accident that typing strange characters into your text file happens to cause the same characters to be in your program
04:14:47 <sopvop> edwardk: Well, mm_freak_ said "reflection is cool and you should use it" and I spen
04:14:55 <akamaus> srhb, I'm debugging my code in ghci. I have a bunch of record types with show instances automatically derived by ghc. I'm trying to inspect the values and getting them in unreadable form.
04:15:00 <sopvop> and I've spent half a day trying to undrestand just how
04:15:01 <edwardk> sopvop: you can write an 'Apply' instance for any comonad. its easily.
04:15:08 <Jafet> Show String prints number sequences because typing those into your text file always puts those characters into the program.
04:15:08 <ozataman> Hey all. Anyone know the memory footprint per item when using Data.Vector.Unboxed of Word8s?
04:15:14 <edwardk> just extract from one and use it to fmap over the other.
04:15:21 <edwardk> but thats asymmetric
04:15:23 <mm_freak_> Yerzhan: as a nice benchmark, this program gives you a parallel safe prime searcher:  http://hpaste.org/79286
04:15:29 <edwardk> ComonadApply adds the symmetry requirement
04:15:33 <mm_freak_> Yerzhan: i have yet to see the C code that outperforms my program =)
04:15:40 <Jafet> ozataman: if you use it correctly, about 0 bytes
04:15:52 <srhb> akamaus: I would write a debug function for that usage. But your call, you can write your own Show if you want to.
04:15:55 <Jafet> That doesn't include allocation overhead though
04:15:58 <Yerzhan> mm_freak_: =)
04:16:07 <ozataman> Jafet: how can it be 0? I didn't mean *overhead*, I meant the actual total footprint per item
04:16:29 <edwardk> e.g. if you have two non-empty lists, it requires that you zip them together or take a cross product or do something where you can flip id   and get the same result in the opposite arg order
04:16:30 <akamaus> srhb, I understand, I'm just too lazy :)
04:16:30 <sopvop> edwardk: Thanks. And I really hope you can find a bit of time to document comonads, they look really powerful.
04:16:37 <Jafet> Add the size of 1 byte to that number, then.
04:16:43 <mrout> can you zip multiple lists? e.g. zip [1, 1, 1] [1, 2, 3] [1, 4, 9]
04:16:55 <shachaf> @ty zip3
04:16:56 <lambdabot> [a] -> [b] -> [c] -> [(a, b, c)]
04:16:57 <shachaf> @ty transpose
04:16:58 <ozataman> when I looked into this a while back, I found out that GHC was using full 64-bit words (on a 64-bit platform) to represent even a Word8.. Just don't know if that's still true.
04:16:59 <lambdabot> [[a]] -> [[a]]
04:17:06 <shachaf> ozataman: Still true.
04:17:38 <mrout> shachaf: tyvm
04:17:47 <Jafet> ozataman: in fact, it uses two.
04:18:04 <ozataman> shachaf: ouch. so there's still no gain in memory usage trying to squeeze into a word8
04:18:08 <Jafet> However, Vector and Array implement their own representations.
04:18:20 <ozataman> Jafet: why 2? you mean when values are boxed?
04:18:55 <Jafet> All data values are boxed. (Except the unboxed ones)
04:19:18 <mm_freak_> ozataman: a boxed Word8 is always going to be large, unless GHC finds a way to optimize the box away
04:19:27 <shachaf> ozataman: If you use an unboxed array or something it'll be packed.
04:19:27 <ozataman> I'm finding if you can squeeze your data into int8s (or similar), numpy is several times over more memory efficient than anything I can do in Haskell
04:19:47 <shachaf> ozataman: But there's an even bigger overhead for an actual Word8 object, since it's going to be allocated on the heap with an extra pointer or two.
04:19:53 <mm_freak_> ozataman: are we talking about individual Word8s or Word8s as part of a data structure?
04:19:58 <ozataman> right, I expect boxed versions to be large. I'm wondering about the Unboxed vector case
04:20:12 <ozataman> mm_freak_: we're talking about UVector Word8
04:20:14 <Jafet> UVector Word8 does not actually contain Word8 objects.
04:20:18 <mm_freak_> ozataman: unboxed vectors take as much memory as necessary for Word8
04:20:23 <Jafet> It contains an array of bytes.
04:20:26 <ethercrow> unboxed vector gets smaller as you expect
04:20:47 <mm_freak_> ozataman: and that's assuming that no fusion applies…  if fusion applies, then the vector may disappear entirely
04:21:27 <ozataman> hmmm. alright, so this actually warrants some testing on my part then
04:21:57 <mm_freak_> ozataman: if you want bits instead of bytes, use Data.Array instead
04:22:03 <mm_freak_> Vector uses one byte per bit
04:22:22 <mm_freak_> (at least in 0.9, so you may want to check out vector 0.10 first)
04:22:39 <Jafet> One byte per bit of what
04:22:44 <ozataman> mm_freak_: Do you mean if the use case is UVector Bit?
04:22:56 <mm_freak_> U.Vector Bool
04:22:59 <ozataman> right
04:23:04 <mm_freak_> Array is faster in general, if you know that the array will be memory-resident
04:23:09 <mm_freak_> vector is faster in all other cases
04:23:30 <Jafet> Also if you know the array size in advance
04:23:56 <ozataman> well, I could possibly do an initial pass over the data to determine size
04:24:27 <mm_freak_> ozataman: that's not the point
04:24:34 <Jafet> That doesn't sound very fast
04:24:48 <ozataman> I don't care so much about the "setup" time
04:24:53 <ozataman> it's not ideal, but can be done
04:25:04 <mm_freak_> ozataman: V.sum (V.replicate n x) doesn't use an in-memory vector, but compiles to a small loop
04:25:20 <mm_freak_> stream fusion optimizes the vector away
04:25:26 <mm_freak_> the array library doesn't do that
04:25:46 <ozataman> I see. my use cases will likely contain lots and lots of slicing of the in-memory dataset
04:25:59 <ozataman> I can't mentally see at once if stream fusion will apply
04:26:15 <ozataman> I may take sub-selections, sort them, etc.
04:26:32 <Jafet> Vector also does that, array doesn't
04:26:39 <Jafet> I think vector does that
04:26:42 <mm_freak_> ozataman: slicing doesn't use extra memory for the array content
04:26:46 <mm_freak_> just for the slice specification
04:26:51 <ozataman> right
04:27:20 <mm_freak_> since vectors are immutable a slice is just a pointer into an existing array
04:27:56 <ozataman> yeah, I'm already relying on sharing quite heavily
04:28:05 <ozataman> but I'm currently wasting lots of memory with UVector Double
04:28:41 <ozataman> I might be able to play some tricks to lose some precision and get it down to Word8s or something like that
04:28:59 <mm_freak_> are you actually using the vector library?  the name "UVector" suggests you're not
04:29:09 <ozataman> I'm also digitizing categorical variables (many with <256 cases), so Word8 works perfectly there
04:29:17 <ozataman> I am using the vector
04:29:33 <ozataman> yeah, sorry I'm using a pseudo notation here
04:29:40 <ozataman> makes the conversation easier :)
04:31:05 <mm_freak_> ok =)
04:32:22 <ozataman> is there a good way to grow the vector incrementally while loading the data?
04:32:44 <ozataman> i guess I could start with a mutable vector, grow by 1 for each row of data and freeze at the end
04:33:08 <mm_freak_> ozataman: for creating vectors there are often two variants
04:33:20 <mm_freak_> generate and generateN, enumFromTo and enumFromN, etc.
04:33:27 <mm_freak_> uhm, not generate
04:33:34 <ozataman> well, I'm always loading from an external source
04:33:41 <mm_freak_> that's fine
04:33:43 <ozataman> a CSV file for example
04:33:54 <ozataman> and the data is large enough that I have to stream
04:34:33 <mm_freak_> ozataman: do you really need the whole file in memory?
04:34:57 <ozataman> for certain sets of analyses, yes
04:35:15 <ozataman> not all algos can be expressed in "streaming" variants
04:35:35 <mm_freak_> well, growing a vector can be slow
04:35:42 <ozataman> a large number of ML algorithms, for example, require the whole dataset to be loaded
04:35:50 <ozataman> right, that's what I've noticed
04:36:08 <ozataman> I could accumulate a list and call fromList at the end, but then I get initial memory explosion due to all the linked list overhead
04:36:35 <nus> akamaus, make 'em Text, not String
04:36:58 <mm_freak_> ozataman: i think the best option is to have two vectors while reading
04:36:59 <srhb> nus: Huh?
04:37:31 <mm_freak_> ozataman: one total vector and one running vector…  create the running vector with a fixed size, and each time it's filled append it to the existing total vector
04:37:32 <nus> srhb, he wants a unicode-nonescaping pretty printer for Strings, that's easier for Text
04:38:03 <ozataman> mm_freak_: append is O(n+m) though, isn't it?
04:38:07 <srhb> nus: Why?
04:38:46 <akamaus> nus, oh, sorry, I told about String. Actually fields are already Text. It doesn't matter, really.
04:39:02 <mm_freak_> ozataman: yes, but it makes allocation happen much less frequently
04:39:30 <mm_freak_> ozataman: on the other hand, you should measure 'snoc' performance for vectors
04:39:33 <mm_freak_> it may not be as bad
04:40:32 <nus> srhb, I think Text processing libraries should be more Unicode-aware
04:40:41 <arrowdodger> mm_freak_: Now i'm getting "Alarm clock" ¯\(°_o)/¯
04:41:25 <nus> akamaus, also in 7.6 or so there is '-interactive-print"
04:41:49 <mm_freak_> ozataman: my strategy would be to write a stream consumer that creates a vector using whatever algorithm is the most performant…  then you can start with a slow version and optimize it later without having to change the rest of the program
04:42:05 <mm_freak_> ozataman: see conduit/enumerator/pipes
04:42:12 <ozataman> mm_freak_: I'm a little surprised there is no clean method for data "loading" in vector.. this is a very, very common use cases in data analysis
04:42:30 <ozataman> well, that thought process really doesn't apply to what I'm doing right now
04:42:36 <mm_freak_> ozataman: that's because there is no clean way in general, when you don't know the size in advance
04:42:45 <mm_freak_> if you know it you have many ways to create the vector
04:43:42 <mm_freak_> ozataman: why doesn't it apply?
04:43:45 <ozataman> that's why I was thinking a practical way might be to count # of records in CSV, initialize mutable vector, write each row and freeze
04:44:05 <ozataman> well my use case is 1) load external data 2) do a bunch of analyses on it 3) output results
04:44:13 <mm_freak_> yes, that's a practical way to do it
04:44:16 <ozataman> but it's not a "streaming" data processing pipeline
04:44:26 <mm_freak_> you only use streaming to produce the vector
04:44:36 <mm_freak_> then you can perform whatever in-memory transformations you want to perform
04:44:41 <ozataman> well I'm already loading the CSV from my csv-conduit library
04:45:09 <mm_freak_> also look into the design of the repa library…  it shows you how to perform complicated things on vectors while retaining the ability to parallelize everything
04:45:17 <mm_freak_> i'm off now, see you later
04:45:24 <ozataman> mm_freak_: alright - thanks for all the help
04:46:39 <akamaus> nus, oh, thanks. A bit too heavy for my particular case, but I'll consider using it in the future.
04:54:02 <Modius> http://www.reddit.com/r/programming/comments/15d7yj/why_learning_haskell_makes_you_a_better_programmer/  <-- posts by sacundim and Tekmo.
04:54:35 <Modius> Are there any good links or passages/parts of LYAH or RWH that address the special properties of "type signature tells you a lot about/constrains the function" like this?
04:54:54 <Modius> Their posts do a great job; but I'd rather hand off something more formal to others.
04:56:32 <shachaf> Modius: Maybe something about parametricity.
04:57:17 <nus> http://www.haskell.org/onlinereport/haskell2010/haskellch4.html -- this is (quite a bit) more formal
05:10:21 <__Hybris__> Noob question: I want to check if a number is divisble by all n from 1 to 10, with this: divble n = all (\m -> n `mod` m == 0) [1..10]   but I get lots of errors: http://pastebin.com/gUesKBif
05:11:08 <shachaf> __Hybris__: You didn't paste your actual code.
05:11:15 <shachaf> Is it *exactly* the same as what you wrote in here?
05:11:31 <__Hybris__> Only the type definition is missing, I'll paste the whole thing.
05:11:49 <shachaf> @ty \n -> all (\m -> n `mod` m == 0) [1..10]
05:11:51 <lambdabot> Integral a => a -> Bool
05:11:53 <shachaf> Works fine.
05:12:02 <__Hybris__> http://pastebin.com/TxgrbCpi
05:12:25 <shachaf> Oh, the type is wrong.
05:12:28 <__Hybris__> Aha..
05:12:29 <__Hybris__> Devil.
05:12:32 <__Hybris__> Thanks!
05:12:33 <shachaf> Comment out the type and it'll work fine.
05:12:42 <shachaf> Then you can use ghci to find out what the type really is.
05:12:47 <__Hybris__> Great.
05:13:26 <Hafydd> __Hybris__: if the value of 10 is constant, you can optimise by that checking if it's divisible by the GCD of [1..10]
05:13:52 <__Hybris__> Is that a theorem?
05:13:53 <Hafydd> Sorry, the LCM
05:13:57 <adnam> __Hybris__: a -> Bool means it can take any type as an argument, but if you check the definition of mod it does not allow any type:
05:14:00 <adnam> :t mod
05:14:01 <lambdabot> Integral a => a -> a -> a
05:14:25 <__Hybris__> That would explain it.
05:15:10 <__Hybris__> Hafydd, is there a theorem that says that if a number is divisible by the lcm of a set of numbers, it is divisible by all those numbers?
05:15:22 <__Hybris__> Maybe it's obvious, but thinking is hard...
05:15:54 <__Hybris__> Ok, it is obvious.
05:16:12 <__Hybris__> nvmind
05:16:25 <Hafydd> __Hybris__: the reverse implication might be a little less obvious, but it's also true.
05:17:03 <Hafydd> Namely: the number, if it is divided by each of the numbers, is a multiple of their LCM.
05:21:47 <statusfailed> Is there a good way to do "length xs > n" lazily? (This is definitely premature optimization, but i'm just curious)
05:22:05 <shachaf> not . null . drop n or something like that.
05:22:17 <shachaf> statusfailed: Not using length isn't really premature optimization.
05:22:42 <shachaf> length is the devil, and makes your programs ugly and your heart icy.
05:22:43 <statusfailed> oh, is length pretty much universally considered terrible code?
05:22:50 <statusfailed> ok, your answer is better than my question :p
05:22:58 <statusfailed> merry christmas btw :p
05:23:10 <shachaf> length is OK for some things.
05:23:33 <shachaf> For example, if you're only doing it once, at the end of some computation.
05:23:50 <statusfailed> Ah, as in if you know the list will only be evaluated once?
05:23:51 <shachaf> It sort of corresponds to keeping an accumulator in a loop.
05:23:59 <shachaf> Since Haskell lazy lists ~ loops.
05:25:00 <shachaf> statusfailed: If you were using lazy natural numbers, length would be fine.
05:25:04 <statusfailed> ooh speaking of, did you find anything interesting about that nested code mikeplus64 gave a while ago?(i.e. a way to get nested loops?)
05:25:07 <shachaf> The issue with length is that it forces the whole list.
05:25:14 <shachaf> Nested code?
05:25:53 <statusfailed> I think he was rendering pixels, but the nested lists were being particularly slow
05:26:08 <statusfailed> I lost your conversation once you started getting into ghc-core
05:26:36 <statusfailed> don't know if that's specific enough for you to remember... it was a while ago
05:26:56 <shachaf> I don't remember exactly.
05:27:16 <shachaf> Oh, it was the thing with forM_ [1..n] $ \i -> forM_ [1..m] $ \j -> ...?
05:27:20 <statusfailed> yeah that's it!
05:27:23 <shachaf> I've forgotten the details.
05:27:31 <statusfailed> fair enough, hehe
05:27:46 <shachaf> Also I've had at least two conversations in this channel about that particular topic in the recentish past. :-)
05:28:35 <statusfailed> Seems like it would be hard to distinguish between when caching the inner list would be a good idea or not
05:28:47 <statusfailed> hard for the compiler that is
05:28:51 <shachaf> Oh, in that case it certainly wouldn't be a good idea.
05:28:55 <shachaf> Oh.
05:29:04 <shachaf> Well, sometimes.
05:29:25 <statusfailed> Yeah, I guess that case is reasonably easy given it's just enumFromTo
05:29:26 <shachaf> Usually it doesn't do too much in the way of CSE and so on, for that reason.
05:29:31 <statusfailed> CSE?
05:29:41 <shachaf> Common subexpression elimination.
05:29:45 <shachaf> Not that that's relevant here.
05:30:08 <shachaf> You can explicitly say let ms = [1..m] in forM_ [1..n] $ \i -> forM_ ms $ \j -> ... if you want sharing.
05:30:45 <statusfailed> but no way to explicitly forbid it?
05:30:51 <statusfailed> at least without recursion
05:31:37 <shachaf> Well, things naturally won't be shared if they're the results of function calls inside lambdas.
05:33:43 <statusfailed> oh, I think I misunderstood the reason for the slowness then... it wasn't that the inner ms was being shared?
05:34:23 <shachaf> No, it was that GHC wasn't being sufficiently clever.
05:34:41 <shachaf> It was converting the outer list to a straight loop -- no allocations anywhere, just incrementing a variable.
05:34:50 <shachaf> For some reason it didn't manage it with the inner list.
05:35:22 <shachaf> (The forM_ of the list, that is, not the list itself. There were no lists in the generated code.)
05:36:14 <statusfailed> ah ok, that makes more sense now
05:59:00 <Taneb> Debugging my code, just debugging my code...
06:05:47 * hackagebot shakespeare-js 1.1.1 - Stick your haskell variables into javascript/coffeescript at compile time.  http://hackage.haskell.org/package/shakespeare-js-1.1.1 (MichaelSnoyman)
06:08:25 <qnikst> hello, I have some troubles with c2hs: I've got need to pass a call back of type (virConnectPtr conn,
06:08:30 <qnikst> void * opaque)
06:09:01 <qnikst> so I've done a type A a = Connection -> Domain -> Ptr a -> IO ()
06:09:06 <qnikst> and a wrapper
06:09:34 <qnikst> but when I want to pass it in c2hs I've it wants Ptr () -> Ptr () -> Ptr () -> IO ()
06:19:22 <Taneb> Is there a type for dates with missing information anywhere?
06:21:16 <tryhasker> I hate it when my date gets amnesia.
06:22:00 <Taneb> Making a genealogy library
06:22:16 <`ramses> tryhasker: odd sentence when you read it before the preceding context :)
06:24:49 <Taneb> data ApproxDate = ApproxDate DateTagThingy ApproxDatePart
06:25:03 <Taneb> data DateTagThingy = Before | Exactly | About | After
06:25:34 <Taneb> data ApproxDatePart = ApproxDatePartY Integer | ApproxDatePartYM Integer Int | ApproxDatePartYMD Integer Int Int
06:25:48 * hackagebot persistent 1.1.3 - Type-safe, multi-backend data serialization.  http://hackage.haskell.org/package/persistent-1.1.3 (MichaelSnoyman)
06:25:50 * hackagebot hamlet 1.1.3 - Haml-like template files that are compile-time checked  http://hackage.haskell.org/package/hamlet-1.1.3 (MichaelSnoyman)
06:26:04 <Taneb> That'd be how I'd do it
06:27:51 <Taneb> Any advances on that?
06:36:17 <Taneb> I might just use (Maybe Int, Maybe Int, Maybe Integer)
06:46:22 <aristid> Taneb: an interval type isn't what you want? because it's possible that you know month and day but not year?
06:47:07 <Taneb> aristid, can you give an example of an interval type?
06:47:22 <aristid> data Interval a = Interval a a
06:47:28 <aristid> :)
06:47:42 <Taneb> And how would that help?
06:47:55 <Taneb> Oh, wait
06:50:25 <parcs> @hackage intervals *cough*
06:50:25 <lambdabot> http://hackage.haskell.org/package/intervals *cough*
06:57:00 <Taneb> Hmm
07:17:36 <parcs> > 0x80
07:17:37 <lambdabot>   128
07:24:06 <Taneb> Right, switched to intervals
07:24:21 <Taneb> Gonna make a few utility functions for turning partial dates into intervals
07:28:19 <drdo> How do i write an instance for λa.(a,a) ? Assuming that means a type-level abstraction and (,) is a tuple
07:28:34 <shachaf> You don't.
07:28:45 <shachaf> newtype Pair a = Pair (a,a)
07:28:50 <shachaf> instance Functor Pair
07:29:04 <drdo> I thought of that, but that's not really the same thing
07:30:04 <shachaf> That's why I said "You don't.". :-)
07:30:07 <Taneb> It's as close as you can get
07:30:13 <shachaf> Sometimes, even Dr. Do Doesn't.
07:30:17 <drdo> Has this sort of thing been discussed?
07:30:23 <drdo> shachaf: So funny! :D
07:30:41 <Taneb> It gets discussed a lot
07:30:51 <Taneb> It's one of Haskell's standard newb questions
07:31:09 <drdo> It's an extremelly reasonable thing to do
07:31:15 <drdo> I'm rather surprised it's not possible
07:31:30 <drdo> Same deal with parameter order
07:31:33 <drdo> On the type level
07:31:47 <drdo> I remember asking about type-level flip at some point
07:32:36 <hpaste> mantovani pasted “error let ” at http://hpaste.org/79832
07:32:41 <shachaf> Think about it from the perspective of the type checker.
07:32:46 <shachaf> What should fmap (+1) (1,2) do?
07:33:09 <drdo> That instance shouldn't even be defined
07:33:13 <drdo> In my opinion
07:33:24 <mantovani> guys what is wrong with "let" ?
07:33:26 <drdo> You can have the bifunctor instance, which makes sense
07:33:29 <mantovani> line 6
07:33:36 <drdo> Choosing one side or the other is rather arbitrary
07:33:42 <mantovani> alades.hs:9:33: parse error on input `='
07:33:55 <Taneb> drdo, that is an opinion not many share
07:34:20 <drdo> Taneb: And what is the argument?
07:34:32 <Taneb> Functor expects an argument of kind * -> *
07:34:34 <drdo> "Why not? Better than nothing at all"
07:34:50 <mantovani> what is wrong in line 9 http://hpaste.org/79832 ? "alades.hs:9:33: parse error on input `='"
07:34:58 <Taneb> "(,) x" is conveniently of that kind
07:35:02 <mantovani> ion: ^
07:35:26 <Taneb> You can't make something of that kind easily to use the first part of the tuple rather than the second
07:35:51 <drdo> I know, i was trying to :D
07:36:06 <Taneb> Because defining a Functor for the second part of the tuple is easy, and the first is pretty much impossible
07:36:17 <drdo> Apropos, is it a technical problem to have this kind of thing? Or just never happened?
07:36:33 <Taneb> The decision of which side to make the functor isn't as arbitrary as it seems
07:36:46 <Taneb> I don't know what you mean by that
07:37:03 <drdo> Taneb: Nothing, i just realised it's not a technical problem
07:37:28 <drdo> Dependently typed languages, etc
07:37:37 <mantovani> someone can help me ??
07:37:39 <parcs> > 200 + 200 :: Word8
07:37:40 <lambdabot>   144
07:37:55 <drdo> mantovani: What ails you, my son?
07:38:07 <mantovani> what is wrong in line 9 http://hpaste.org/79832 ? "alades.hs:9:33: parse error on input `='"
07:38:17 <drdo> mantovani: Also, in the future, don't ask to ask
07:38:22 <geekosaur> mantovani, if I had to guess, that's the first line indented enough that tabs might be involved.  make sure you're only using spaces for indentation.  otherwise it seems to look okay to me (and to the local ghc except you forgot parens or $ on line 11)
07:39:06 <mantovani> same error geekosaur I don't know what to do anymore...
07:39:09 <drdo> Haskell's syntax rules are black magic
07:39:12 <quchen> mantovani: I don't get a "let" error.
07:39:17 <geekosaur> ^^
07:39:24 <mantovani> 13:37 < mantovani> what is wrong in line 9 http://hpaste.org/79832 ? "alades.hs:9:33: parse error on input `='"
07:39:27 <mantovani> quchen: ^
07:39:42 <geekosaur> right, we're not getting the let error
07:39:53 <mantovani> you guys can compile the code?
07:40:07 <drdo> nop
07:40:14 <geekosaur> this is why I suggested checking for tabs; that kind of error usually means your tabs don't expand the way ghc expects and things aren't lined up so it's being read as a continuation line
07:40:26 <drdo> mantovani: But not because of syntax
07:40:27 <quchen> Couldn't match expected type `IO ()' with actual type `String' <= That's the error I get.
07:40:51 <quchen> Oh, misuse of tabs may explain it as well.
07:41:23 <mantovani> drdo: can you fix it ?
07:41:23 <drdo> Oh, while we're at it? What do you guys use for indentation these days? Is there anything new?
07:41:37 <geekosaur> that one is from missing $ on lines 11 and 12.  but there's another one somewhere after that
07:42:08 <quchen> drdo: I've written something about that recently: https://github.com/quchen/tabs_vs_spaces
07:42:12 <drdo> I just use haskell-mode with haskell-simple-indent, which is very primitive
07:42:32 <drdo> But the other indentation functions available do the wrong thing
07:42:44 <quchen> tl;dr: use spaces, but for other reasons than everyone tells you :-)
07:42:50 <drdo> quchen: I don't think you meant that for me
07:42:57 <mantovani> guys
07:43:03 <mantovani> haskell identation sux
07:43:12 <mantovani> half hour just wasting time with this
07:43:18 <mantovani> syntax is right
07:43:18 <drdo> ye bro, totallrey suxorz
07:43:21 <mantovani> and for some magic reason
07:43:25 <mantovani> doesn't work
07:43:39 <quchen> Syntax is wrong, sir. Whitespace has semantic relevance.
07:43:49 <mantovani> so why should I do ?
07:43:51 <quchen> You can't sprinkle your code with "+" wherever you want, same thing with whitespace.
07:43:52 <mantovani> what*
07:44:26 <parcs> drdo: it's not an extremely reasonable thing to do if you're, say, a type checker. having type level lambdas breaks the fundamental property that f a ~ g a => f ~ g
07:45:01 <drdo> parcs, I never asked for that, it was just notation
07:45:20 <drdo> If you introduce arbitrary type-level expressions, you make type checking undecidable
07:45:44 <drdo> Which is fine in practice most of the time anyway, but that's off the point
07:45:46 <parcs> what would eg instance Functor \a -> (a,a) mean if not a type level lambda
07:46:00 <osfameron> mantovani: I get a different syntax error from http://hpaste.org/79832 (type error, not whitespace error)
07:46:24 <quchen> mantovani: This is a correct tabbed version. https://gist.github.com/raw/4380992/6cf0a93aa973add7f799f79765e9fdb60b32ba4d/gistfile1.txt
07:46:36 <neutrino> "Tabs: Every interpreter (editor, compiler, ...) can choose the tab width to its likings. If you like you tabs 8 spaces long and get code written by someone who likes them 4 spaces long, you won't even notice"
07:46:40 <neutrino> how wrong
07:46:42 <neutrino> tabs are 8 spaces. always.
07:47:04 <drdo> parcs, it was the notation i used to express it, do you understand that difference?
07:47:09 <osfameron> 8 space is far too tabby
07:47:17 <neutrino> "using tabs incorrectly breaks programs, just like incorrect syntax" <<< following your guide makes people use tabs incorrectly :P
07:47:28 <drdo> Use 2 spaces for indentation
07:47:36 <drdo> End of discussion
07:47:38 <drdo> This is known!
07:47:45 <neutrino> osfameron: unix source code practices define tabs to be interpreted as 8 spaces. all languages follow that.
07:48:26 <parcs> drdo: i don't think so. what would be the point of having notation used to express a type level lambda without having type level lambdas implemented?
07:48:38 <drdo> parcs: It was notation i used to talk to people in the channel
07:48:49 <quchen> neutrino: I don't think "tabs are 8 spaces, always" makes a good argument, neither does "your guide's wrooong".
07:48:50 <drdo> Are you just out to argue for no reason?
07:49:24 <neutrino> quchen: well, just read up on how different compilers and interpreters analyze tabs
07:49:39 <quchen> There's a difference between not liking something and criticising it and calling something wrong. The first one works against all evidence, the second one not so good.
07:49:48 <neutrino> quchen: that is my argument. what you put in quotes wasn't an argument, it was a conclusion
07:49:52 <neutrino> yes, i know
07:49:54 <neutrino> i called it wrong
07:49:58 <neutrino> anyways, bbl
07:50:13 <mantovani> thanks
07:53:35 <parcs> drdo: you seem bitter. did you have an unsatisfactory christmas?
07:53:49 <drdo> parcs: :)
07:54:35 <drdo> I do not wish to escalate this into some internet though guy showdown, let's just leave it at this.
08:02:38 <parcs> drdo: sorry about that. but i truly am curious what you are expressing with the notation \a -> (a,a) at the type level
08:03:44 <drdo> parcs: I was trying to make the homogeneous pair an instance of a class
08:05:50 <Jafet> > over both (^2) (1, 2)
08:05:52 <lambdabot>   (1,4)
08:06:10 <Jafet> Just add more type variables.
08:07:10 <fmap> > over both (^2) (0,1)
08:07:12 <lambdabot>   (0,1)
08:07:15 <fmap> better example
08:08:21 <Jafet> > (0,1) & over _2 (^3)
08:08:23 <lambdabot>   (0,1)
08:08:59 <hiptobecubic> :t both
08:09:02 <lambdabot> Applicative f => (a -> f b) -> (a, a) -> f (b, b)
08:26:27 <shurikas> @src (_2)
08:26:27 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
08:31:56 <fmap> :t let _2 f (x,y) = (\y -> (x,y)) <$> f y in _2
08:31:58 <lambdabot> Functor f => (t -> f t2) -> (t1, t) -> f (t1, t2)
08:32:05 <fmap> shurikas: ^
08:32:57 <fmap> except real _2 is generalized
08:43:42 <`nand`> > (0,1) & _2 ^~ 3
08:43:45 <lambdabot>   (0,1)
08:44:01 <`nand`> > (1,2) & _2 ^~ 3
08:44:03 <lambdabot>   (1,8)
08:44:07 <`nand`> (bad example with 1, really :P)
08:44:21 <shachaf> edwardk: (^~) is a confusing lens operator.
08:44:31 <shachaf> Took me a bit to figure it out.
08:44:40 <`nand`> shachaf: I just noticed that as well; it looks like some sort of getter
08:44:52 <`nand`> it's ambiguous between a getter and a setter
08:45:18 <`nand`> overall though I think it's worth it for the consistency with +~ etc.
08:45:22 <shachaf> Clearly it should be the operator that gives you a Context.
08:45:51 * hackagebot openpgp-crypto-api 0.4 - Implement cryptography for OpenPGP using crypto-api compatible libraries  http://hackage.haskell.org/package/openpgp-crypto-api-0.4 (StephenWeber)
08:45:51 <`nand`> > (1,2) & _2 ^^~ 3
08:45:53 <lambdabot>   (1,8.0)
08:46:05 <shachaf> @let s ^~~ l = l (Context id) s
08:46:08 <lambdabot>  Defined.
08:46:27 <`nand`> ^%%~
08:46:32 <edwardk> shachaf: i put it in for consistency with the rest of the base operators
08:46:42 <shachaf> Sure.
08:47:26 <`nand`> (what's Context all about anyway?)
08:47:37 <shachaf> `nand`: Context a b t = (a, b -> t)
08:47:47 <shachaf> It's the result of applying a lens to a structure. That's all.
08:47:52 <`nand`> looks like some overloaded Store
08:48:07 <shachaf> It's like Store except it lets a and b vary.
08:48:11 <shachaf> Just like Lens does.
08:48:40 <deus_rex> @type prism
08:48:41 <lambdabot> (Applicative f, Prismatic k) => (b -> t) -> (s -> Either t a) -> k (a -> f b) (s -> f t)
08:48:42 <edwardk> `nand`: its an indexed store comonad
08:48:56 <`nand`> edwardk: indexed, that's the word I was looking for
08:49:05 <`nand`> but yeah, makes sense in a lens context
08:49:36 <`nand`> now I just have to know what Bazaar is all about
08:49:42 <shachaf> deus_rex: prism is going to be about a billion times better.
08:49:53 <shachaf> (Rough estimate.)
08:50:30 <shachaf> `nand`: Bazaar is like Context, but for Traversal
08:50:34 <edwardk> its now (Prismatic p, Applicative f) => (b -> t) -> (s -> Either t a) -> p a (f b) -> p s (f t)
08:50:48 <shachaf> I.e. Bazaar a b t = forall f. Applicative f => (a -> f b) -> f t
08:50:51 <`nand`> shachaf: the  type signature (b -> t) -> (s -> Either t a) -> Prism s t a b -- works for all versions, right?
08:51:01 <shachaf> Where Context a b t = forall f. Functor f => (a -> f b) -> f t
08:51:04 <shachaf> `nand`: Yes.
08:51:05 <edwardk> :t flip _2 ("hello","world")
08:51:06 <lambdabot> Functor f => ([Char] -> f b) -> f ([Char], b)
08:51:14 <edwardk> :t flip both ("hello","world")
08:51:16 <lambdabot> Applicative f => ([Char] -> f b) -> f (b, b)
08:51:25 <edwardk> the former is a form of 'Context' the latter is a form of 'Bazaar'
08:51:50 <shachaf> welcome back monqy
08:52:10 <edwardk> Bazaar is a 'traversal applied to some value' but where you haven't picked what function (a -> f b) to use yet
08:52:16 <edwardk> its a 'traversal in context'
08:52:30 <`nand`> shachaf: is there an interpretation of Bazaar that's similar to (a, b -> t) -- ?
08:52:42 <edwardk> Context is a lens applied to some value but where you have figured out what function a -> f b  to use yet. its a 'lens in context'
08:52:52 <shachaf> `nand`: exists (n:Nat). (a^n, b^n -> t)
08:52:54 <edwardk> `nand`: yes, sorta
08:53:08 <shachaf> Where a^n means "a list of 'n' 'a's"
08:53:09 <edwardk> ou can also use a 'fun list'
08:53:14 <shachaf> Also that.
08:53:18 <edwardk> but that fails for infinite traversals
08:53:23 <edwardk> also the n there can be infinite
08:53:33 <shachaf> edwardk: Infinite traversals don't exist.
08:53:38 <edwardk> whatever
08:53:50 <shachaf> data Bazaar a b t = Buy t | Trade (Bazaar a b (b -> t)) a
08:53:55 <edwardk> they exist for some infinities, you just lose associativity ;)
08:53:55 * dmwit snaps his fingers in a Z shape
08:54:33 <simpson> Infinite traversals don't exist?
08:54:45 <shachaf> They're a lie.
08:54:50 <Nereid> doesn't using a Bazaar "flatten" whatever structure you had into a list or something?
08:54:50 <edwardk> simpson: infinite traversals cause some interesting pain points
08:54:57 <Nereid> in some sense
08:55:05 <shachaf> Nereid: Yep.
08:55:11 <Nereid> sounds inefficient
08:55:17 <shachaf> Nereid: Fortunately the Applicative laws require things to be monoids.
08:55:24 <shachaf> So you're allowed to flatten it.
08:55:27 <edwardk> the formal proof shows that in a set-like domain they don't exist. in haskell they 'sometimes do', but the associativity law breaks down because you can only do finite reassociations
08:55:29 <Nereid> sure, but at what cost
08:55:40 <shachaf> AT WHAT COST, edwardk?
08:55:44 <shachaf> At what cost?
08:55:45 <`nand`> THE CORE MUST BE FAST
08:56:16 <Nereid> maybe it should be a tree-like thing instead?
08:56:19 <edwardk> one can argue that the traversal laws only state that you can reassociate once, which you can reason by induction to do a finite number of reassociations, but that this doesn't give you the infinite reassociations you'd need to turn an infinite left-biased traversal into a right-biased traversal
08:56:22 <shachaf> Nereid: That's why we have an alternative representation that uses an illegal monoid!
08:56:25 <Nereid> yes
08:56:26 <edwardk> i personally find this to be acceptable
08:56:52 <`nand`> shachaf: you know your representation breaks down when you need to use illegal instances to fix it into place :(
08:56:59 <edwardk> since its analogous to the cases you get in topology for finite vs. infinite intersections and unions.
08:57:07 <shachaf> `nand`: Hardly.
08:57:24 <edwardk> and mathematicians have been living with that for a long time
08:57:45 <edwardk> i'd rather live in the actual problem domain than a restricted subset of it that skips useful cases
08:58:04 <dmwit> The problem with mathematical laws is they don't say what the penalties are for breaking them.
08:58:18 <dmwit> You just have to figure out what fucks up yourself.
08:58:21 <edwardk> dmwit: the math police haven't been there to visit you yet?
08:58:30 <edwardk> you must only be watchlisted.
08:58:44 <Nereid> uh what am I trying to say.
08:58:52 * dmwit thanks Big Brother for the reprieve
08:58:57 <`nand`> http://ro-che.info/ccc/05.html
08:59:06 <Taneb> Downside of using the intervals library: my genealogy library indirectly depends on numeric-extras
08:59:15 <sclv> still trying to come up with a name for my dfa -> llvm library
08:59:20 <Nereid> let's call this illegal thing a magma.
08:59:26 <sclv> llautomata is my current stab but it doesn't roll off the tongue
08:59:27 <edwardk> the math-police have me on house-arrest. i have to wear a little ankle bracelet that goes off all the time when i try to use an improper prior distribution
09:00:07 <Nereid> or a pointed magma.
09:00:13 <shachaf> sclv: How about dfa2llvm
09:00:14 <Nereid> then it's fine as long as our pointed magma is associative as viewed through any pointed magma homomorphism from our thing to a real monoid
09:00:17 <Nereid> and unital
09:00:20 <shachaf> Nereid: Pointed magma with a distinguished element.
09:00:30 <Nereid> that's what pointed means.
09:00:39 <sclv> shachaf: so boring :-(
09:00:45 <sclv> but it is clear and expressive i'll grant
09:00:55 <shachaf> sclv: OK, be original: llvmFromDfa
09:01:00 <dmwit> sclv: How about "Victoria"?
09:01:11 <shachaf> Oh, lambdabot has a Haskell project name generator.
09:01:13 <shachaf> @fresh
09:01:14 <lambdabot> Haiv
09:01:18 <shachaf> sclv: Haiv
09:01:19 <edwardk> Nereid: the point is while we capture the magma we never reassociate it, and we put it back right where we found it.
09:01:28 <dmwit> oooo, the United States of LLVM
09:01:34 <sclv> ouch
09:01:35 <edwardk> so while it isn't a monoid, it isn't a particularly egregious abuse
09:01:44 <aninhumer> Hmm, how do I use template haskell to generate an associated data instance for a class, DataD only takes TyVars and DataInstD generates a superfluous instance keyword...
09:01:47 <sclv> it involves a pun, so its on track though :-P
09:02:01 <dmwit> How about dysgraphia?
09:02:06 <aninhumer> Possibly I need to restructure my code slightly
09:02:35 <sclv> hmm… dfadfa?
09:02:43 <sclv> damn fast assembled dfas
09:02:53 <elliott> sclv: how about llvdfa
09:02:55 <shachaf> asdfdfa
09:03:07 <Nereid> yes
09:03:20 <dmwit> a small, damn fast DFA
09:03:30 <sclv> haha that's awesome
09:03:36 <sclv> asdf-dfa maybe
09:03:42 <sclv> so there's some hope of remembering the name
09:03:50 <edwardk> anyways, when someone shows me a nice law-compliant monoid that some how deals with the infinities that arise in practice. i'll let the magma go =P
09:03:53 <sclv> with just asdfdfa i'd forget the name myself
09:04:26 <dmwit> a small, dirty, fast-as-shit DFA, asdfasdfa
09:04:36 <elliott> sclv: scllvmdfa
09:05:51 * hackagebot shelly 0.15.4 - shell-like (systems) programming in Haskell  http://hackage.haskell.org/package/shelly-0.15.4 (GregWeber)
09:07:14 <mantovani> quchen: man, why now "main" is not party of "when" ?
09:08:03 <dmwit> That question just looks so strange.
09:14:10 <`nand`> @hoogle Eq a => [a] -> Bool
09:14:10 <lambdabot> Prelude elem :: Eq a => a -> [a] -> Bool
09:14:10 <lambdabot> Data.List elem :: Eq a => a -> [a] -> Bool
09:14:10 <lambdabot> Prelude notElem :: Eq a => a -> [a] -> Bool
09:14:33 <`nand`> anything like this somewhere? something like (==0) . length . group
09:15:31 <shachaf> I think that's called null
09:16:03 <`nand`> err
09:16:05 <`nand`> (==1)
09:16:21 <aninhumer> Hmm this ticket suggests DataInstD shouldn't generate "data instance" inside InstanceD anymore: http://hackage.haskell.org/trac/ghc/ticket/5886
09:16:54 <aninhumer> But it seems to be doing so anyway...
09:17:13 <aninhumer> Or possibly something else, the error doesn't seem to match the reported splice body
09:17:27 <shachaf> all (==x) xs is the closest idiom I know.
09:22:31 <mantovani> guys
09:22:36 <mantovani> there is "when not" in haskell ?
09:22:41 <dmwit> unless
09:22:43 <Taneb> unless
09:22:50 <simpson> :t unless
09:22:51 <lambdabot> Monad m => Bool -> m () -> m ()
09:23:02 <mantovani> thanks
09:23:15 <dmwit> ?check \p v -> when p v == unless (not p) v
09:23:17 <lambdabot>   Not in scope: `myquickcheck'
09:23:25 <dmwit> ?get-cale
09:23:26 <lambdabot> Unknown command, try @list
09:23:35 <elliott> cale knows @check is broken but not how to fix it
09:23:40 <dmwit> aww
09:23:56 <dmwit> ?smallcheck \p v -> unless p v == when (not p) v
09:23:57 <lambdabot> Unknown command, try @list
09:24:27 <shachaf> @scheck \p -> p
09:24:29 <lambdabot>   Not in scope: `myquickcheck'
09:24:34 <dmwit> ?list
09:24:35 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
09:25:06 <shachaf> That list is not up to date.
09:25:13 <dmwit> seems not
09:25:17 <shachaf> There's a way to get a list of all the commands but it's kind of spammy.
09:25:45 <monochrom> happy "data Box a = Box a" day!
09:26:25 <awgn> ByteStrings seem to be non Traversable. Is there any compelling reason for this ?
09:27:05 <dmwit> awgn: wrong kind
09:29:01 <shachaf> lens has a traversal for them. :-)
09:30:12 <noobdude> hi guys
09:30:31 <Taneb> Hey
09:30:47 <Taneb> Would it be bad to name a function "family"?
09:30:51 <noobdude> I recently viewed a lecture by Martin Odersky on features of 2.10 scala , but he outlayed
09:31:13 <noobdude> philosophy of scala and how it borrows its functional roots from Haskell
09:31:34 <noobdude> but he kinda kept on beating on haskell , atleast on 3 occasions
09:32:03 <aninhumer> Taneb: If you do, the function can't be used by any module using the TypeFamilies extension
09:32:05 <noobdude> saying that haskell module system is broken and type-class declarations are global
09:32:13 <sclv> good for him
09:32:26 <sclv> i'm sure he's very proud of his language
09:32:45 <aninhumer> Taneb: So if it's part of your external interface, you should probably chose a different name
09:33:01 <noobdude> so my basic question is , are typeclass declarations visible from everywhere?
09:33:09 <Taneb> aninhumer, I'm currently using traverseFamily, but that's somewhat cumbersome
09:33:13 <noobdude> if so why?
09:33:44 <sclv> yes they are
09:33:49 <sclv> on purpose
09:34:02 <noobdude> i have not  completely understood basic scope management in haskell
09:34:02 <noobdude> why?
09:34:04 <sclv> we have for example a map built as a tree
09:34:15 <sclv> and it relies on a global Ord instance for its keys
09:34:17 <noobdude> He also said SML is better at this
09:34:39 <sclv> so now if we have two maps, we can take an efficient union of them because we know the orderings on their internals match
09:35:02 <aninhumer> Taneb: Well, I dunno what else would make sense, but that's the caveat if you call it family
09:35:06 <sclv> but if we don't have global instances, we could have two different orderings on the maps, even though their keys are the same type
09:35:20 <aninhumer> Taneb: I'd probably just call it that for now, and worry about it later :)
09:35:26 <sclv> and then whoops! our union algorithm gets very expensive
09:35:36 <hiptobecubic> oopsy!
09:35:43 <aninhumer> Taneb: Naming things is one of the hard problems after all :P
09:35:59 <elliott> Taneb: can't you just call it traverse
09:36:02 <jozefg> Do you have to do anything special with happstack to use external style sheets
09:36:14 <sclv> haskell's tree based collection libraries give better asymptotics and more methods than scala's for this reason
09:36:36 <Taneb> elliott, I'm also making traversePerson and traverseEvent, I'd like consistency
09:36:42 <noobdude>  ok, but what about if I want to define
09:36:42 <Taneb> I can't call them all traverse
09:37:00 <sclv> sml indeed has fancier modules that let us have our cake and eat it too buy not letting the two instances get confused while simultaneously letting us bring both into scope
09:37:01 <elliott> Taneb: yes you can
09:37:02 <elliott> :t traverse
09:37:03 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
09:37:07 <elliott> write a Traversable instance
09:37:09 <noobdude> a typeclass , which is confined to a particular module ,just because i want
09:37:19 <sclv> but there is an established proof of an equivalence in encodings between modules and typeclasses
09:37:24 <Taneb> elliott, they're too not the right kind-y!
09:37:25 <sclv> if you do a little work
09:37:38 <noobdude> is there?
09:37:38 <noobdude> link please
09:37:39 <`nand`> edwardk: equalOf :: Eq a => Fold s a -> s -> Bool; equalOf l xs = case xs^?l of Nothing -> True; Just x -> allOf l (==x) xs
09:37:42 <elliott> Taneb: what is your operation's type
09:37:48 <noobdude> or just keywords so that i can search
09:37:59 <noobdude> sclv:
09:38:12 <sclv> anyway you can define a typeclass internal to a specific module
09:38:15 <sclv> instances are global
09:38:24 <Taneb> FamilyID -> SimpleIndexedTraversal FamilyID FamilyTree Family
09:38:24 <sclv> but you can not export the typeclass itself
09:38:26 <edwardk> `nand`: why the funny base case?
09:38:33 <noobdude> sclv:ok
09:38:38 <edwardk> > allOf traverse (=='c') ""
09:38:40 <lambdabot>   True
09:38:42 <shachaf> edwardk: You get x from preview.
09:38:50 <aninhumer> Hmm, yeah, I'm pretty sure the -ddump-splices output doesn't match the actual result
09:38:52 <shachaf> The question is "are all the elements of this traversal equal"
09:38:57 <`nand`> all elements of an empty fold are equal
09:38:59 <edwardk> shachaf: ah
09:39:04 <shachaf> You can answer the question just as well by converting to a list, though.
09:39:08 <noobdude> sclv:that is sad , i might want to and even if typeclasses are equivalent to modules , they are just abstract modules
09:39:35 <sclv> erm, i meant "you can, if you choose, decide not to export the typeclass"
09:39:37 <noobdude> sclv:I might want to export implementations ,not just look up interfaces
09:39:52 <sclv> i don't know what you mean "export implementations"
09:39:53 <`nand`> edwardk: well, munge around the types/implementation if you want, but something similar to that would be nice
09:40:15 <`nand`> eg. equalOf (traverse._1) [(1,1), (1,2), (1,3)] == True
09:40:16 <aninhumer> Since if I copy the claimed splice output in place of the splice, it fails...
09:40:18 <edwardk> `nand`: it seems kinda hackish
09:40:23 <shachaf> I don't see the point of making that a lens operation.
09:40:47 <edwardk> `nand`: and i can't point to a base operation that is in scope to say it generalizes
09:40:59 <noobdude> sclv:typeclasses are just specifications on types right(over simplification)
09:41:01 <sclv> noobdude: here's one of the papers on modules and typeclasses http://lambda-the-ultimate.org/node/1558
09:41:18 <Catnaroek> Can two different ByteString values use slices of the same internal Word8 array?
09:41:29 <sclv> no they're nothing like specifications on types. they're mappings between types and sets of functions
09:41:30 <noobdude> I might wanna export a chunk of code , which looks up a typeclass confined to that particular scope and satisfy it
09:41:41 <shachaf> Catnaroek: Yes, that's what you get when you take a substring of a ByteString.
09:41:43 <sclv> or values rather
09:41:47 <noobdude> sclv: wait
09:41:49 <Catnaroek> shachaf: Nice, ty!
09:42:39 <noobdude> yeah,values
09:43:20 <sclv> anyway, yes. there are things that typeclasses aren't the right tool for, while modules might have been the right tool for them in scala.
09:43:41 <sclv> but that's fine. we have lots of other tools for abstraction, including parametric polymorphism, GADTs, ec.
09:43:48 <noobdude> sclv:so again isn't it complecting two things
09:44:12 <sclv> erm, i suppose.
09:44:12 <noobdude> sclv: program construction(implicit) and ad-hoc polymorphism
09:44:39 <sclv> basically if you want something to work over some arbitrary function, pass that function in
09:44:44 <sclv> ?ty maximum
09:44:46 <lambdabot> Ord a => [a] -> a
09:44:48 <sclv> ?ty maximumBy
09:44:49 <lambdabot> (a -> a -> Ordering) -> [a] -> a
09:44:53 <sclv> ?src maximum
09:44:54 <lambdabot> maximum [] = undefined
09:44:54 <lambdabot> maximum xs = foldl1 max xs
09:45:02 <sclv> ?src max
09:45:02 <lambdabot> max x y = if x <= y then y else x
09:45:06 <sclv> ah, drat
09:45:19 <sclv> in the real code, as i recall, maximum is defined in terms of maximumBy (or can be)
09:45:36 <sclv> so you can just "pass in the ord dictionary" if you want
09:45:53 <sclv> you just have to write your functions to allow that to begin with
09:46:38 <sclv> the distinction is that typeclasses tend to used when things "cannonically are" something, and therefore where the global property is desirable. and other methods tend to be used when there are many ways to do something
09:46:57 <Nereid> but if you didn't, you could still use something evil to do it
09:47:04 <sclv> another place you want the global property -- serialization. i want to always write doubles the same way and read them the same way and enforce an isomorphism
09:47:25 <shurikas> @hoogle maximumBy
09:47:26 <lambdabot> Data.List maximumBy :: (a -> a -> Ordering) -> [a] -> a
09:47:26 <lambdabot> Data.Foldable maximumBy :: Foldable t => (a -> a -> Ordering) -> t a -> a
09:47:44 <elliott> sclv: you can also user reflection to acheive the "pass the dictionary in" use-case without sacrificing the nice properties of typeclasses
09:47:45 <shurikas> :t maximumBy ==
09:47:46 <lambdabot> parse error (possibly incorrect indentation)
09:47:49 <elliott> or writing things in By terms
09:47:53 <shurikas> :t maximumBy (==)
09:47:54 <lambdabot>     Couldn't match expected type `Ordering' with actual type `Bool'
09:47:54 <lambdabot>     Expected type: a0 -> a0 -> Ordering
09:47:55 <lambdabot>       Actual type: a0 -> a0 -> Bool
09:47:56 <shurikas> ok
09:47:57 <shurikas> :D
09:47:59 <elliott> *use reflection
09:47:59 <noobdude> <sclv>hmm , but those things can be confined in a module isn't it? it is not that hard to say import foo.lang
09:48:16 <shurikas> wrong type
09:48:56 <noobdude> sclv: there is a paper called modular typeclasses by harper et al.
09:49:02 <noobdude> going through it
09:49:34 <noobdude> one of first hits on instances are global typeclasses
09:51:02 <sclv> ?ty compare
09:51:03 <lambdabot> Ord a => a -> a -> Ordering
09:51:06 <sclv> ?ty maximumBy compare
09:51:07 <lambdabot> Ord a => [a] -> a
09:54:25 <`nand`> using (Ord (flip compare)) $ maximum [1,2,3]
09:54:33 <`nand`> would evaluate to 1
09:58:34 <`nand`> this Haskell program crashes with a <socket: 7>: hPutChar: resource vanished (Broken pipe) -- error
09:58:48 <`nand`> is there a simple way to debug it to figure out where the error is coming from?
09:59:00 <shachaf> @where rts-xc
09:59:00 <lambdabot> ghc -prof -fprof-auto -rtsopts -osuf .p_o foo.hs && ./foo +RTS -xc # print stack traces on unhandled exceptions
10:01:04 <aninhumer> Hmm, is there a way to dump the entire output from the TH pass and then stop?
10:01:33 <aavogt> aninhumer: different from  -ddump-splices?
10:02:11 <aninhumer> aavogt: Well, -ddumpsplices appears to be incorrect for my code (I've submitted a ticket)
10:02:20 <aninhumer> So I'm wondering if there's an alternative
10:03:21 <aavogt> this has bitrotted http://hackage.haskell.org/package/zeroth
10:03:58 <aninhumer> aavogt: Ah thanks, I'll have a look
10:04:58 <aavogt> also haskell-src-meta might be helpful too, but I'm not sure you can get the data types that represent splices out of ghc easily
10:08:18 <`nand`> shachaf: thanks, worked great
10:12:52 <Catnaroek> @pl \x y -> f (g x) (g y)
10:12:53 <lambdabot> (. g) . f . g
10:14:03 <BMeph> Catnaroek: AKA, "on f g". :)
10:14:12 <Catnaroek> @hoogle on
10:14:13 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
10:14:13 <lambdabot> Control.Exception.Base onException :: IO a -> IO b -> IO a
10:14:13 <lambdabot> Control.Exception onException :: IO a -> IO b -> IO a
10:14:30 <Catnaroek> BMeph: ty
10:15:05 <fmap> > (f `on` (g :: Expr -> Expr)) x y :: Expr
10:15:07 <lambdabot>   f (g x) (g y)
10:17:04 <Catnaroek> What binds more tightly? `on` or . ?
10:17:45 <shachaf> :i in ghci probably knows better than we do. :-)
10:18:08 <beaky> hello
10:18:15 <parcs> infixl 0 `on`
10:18:15 <parcs> infixr 9 .
10:18:22 <edwardk> Catnaroek (.) has the tightest precedence it can
10:18:37 <Catnaroek> edwardk: Ah!
10:18:39 <beaky> infixr 9?
10:18:45 <Catnaroek> shachaf: edwardk: ty
10:22:10 <mantovani> I did 3 codes, Perl,C and Haskell
10:22:18 <mantovani> and Haskell is the slow of the 3
10:22:26 <mantovani> it should be faster than Perl
10:22:50 <mantovani> http://paste.scsys.co.uk/220738 Perl
10:23:09 <beaky> did you turn on optimization :D
10:23:16 <mantovani> haskell http://hpaste.org/79837
10:23:22 <mantovani> beaky: yes -O2
10:23:35 <mantovani> beaky: can u check my haskell code to optimize it ?
10:23:42 <mantovani> the problem compare two times
10:23:48 <mantovani> 1 20 1 30
10:23:52 <mantovani> and take the difference
10:23:57 <mantovani> in minutes
10:23:59 <mantovani> like here
10:24:02 <mantovani> return 10
10:24:33 <mantovani> and if the first time is bigger than the second I have to sum 24H
10:24:34 <mantovani> like
10:24:40 <Hail_Spacecake> what's the difference between import and :m in ghci?
10:24:46 <mantovani> 21 33 21 10
10:25:02 <mantovani> will print 1417
10:25:09 <simpson> mantovani: I get the impression that "interact" might help you.
10:25:11 <Fuuzetsu> Hail_Spacecake: afaik :m goes into the module, disregarding everything else
10:25:13 <simpson> :t interact
10:25:13 <mantovani> 21:33 21:10
10:25:14 <lambdabot> (String -> String) -> IO ()
10:25:17 <mantovani> right
10:25:35 <`nand`> :m - lets you unimport
10:26:19 <Hail_Spacecake> also does the name of a module as specified in the module X where... line have to be the same as the .hs file it's in?
10:26:24 <mantovani> simpson: can you show me an example of code using interact ?
10:27:06 <`nand`> but I can't find a difference between :m + and import
10:27:16 <`nand`> (I guess import lets you import qualified and stuff, does :m + do that?)
10:27:44 <rwbarton> no
10:32:10 <Hail_Spacecake> okay so I've made a module testModule in the folder I'm in
10:32:14 <Hail_Spacecake> and called the file testModule.hs
10:32:18 <Hail_Spacecake> but I can't seem to import it
10:32:28 <rwbarton> also 'import' doesn't import as many instances as :m, I think. but that's just a bug
10:32:31 <rwbarton> maybe fixed by now
10:33:04 <rwbarton> you can't have a "module testModule", it needs to start with a capital letter
10:33:07 <Hail_Spacecake> ah
10:34:10 <Hail_Spacecake> should ghci tab-complete modules in the current directory automatically?
10:34:19 <Hail_Spacecake> I'm still not sure why this isn't importing
10:35:31 <ricree> Is there an html parsing library that preserves the contents of <script> tags? I don't need it to actually parse them, but HXT seems to be throwing them out completely
10:40:47 <derdon> hello, newbie here. I defined a function where I use both the function (/) and the function even. (/) expects a Fractional type and even expects an Integral type. what function signature matches to these conditions?
10:41:30 <slack1256> derdon: let's ask hoogle for that
10:42:25 <derdon> slack1256: and what should I enter in the search field?
10:42:45 <slack1256> The type signature of a function you are searching :-)
10:43:04 <slack1256> for example, the function 'floor' meets the criteria
10:43:10 <slack1256> @type floor
10:43:11 <lambdabot> (Integral b, RealFrac a) => a -> b
10:43:35 <slack1256> > floor 5.5
10:43:37 <lambdabot>   5
10:44:11 <siracusa> @hoogle (Integral a, Fractional b) => a -> b
10:44:12 <lambdabot> Prelude (^^) :: (Fractional a, Integral b) => a -> b -> a
10:44:12 <lambdabot> Data.List genericIndex :: Integral a => [b] -> a -> b
10:44:12 <lambdabot> Prelude fromIntegral :: (Integral a, Num b) => a -> b
10:44:59 <keep_learning> :t  modifyMVar_
10:45:01 <slack1256> @hoogle (Integral b, Fractional a) => a -> b
10:45:01 <lambdabot> Not in scope: `modifyMVar_'
10:45:02 <lambdabot> Prelude ceiling :: (RealFrac a, Integral b) => a -> b
10:45:02 <lambdabot> Prelude floor :: (RealFrac a, Integral b) => a -> b
10:45:02 <lambdabot> Prelude round :: (RealFrac a, Integral b) => a -> b
10:45:17 <hpaste> derdon pasted “collatz” at http://hpaste.org/79838
10:45:27 <keep_learning> Hello all
10:45:47 <keep_learning> modifyMVar_ :: MVar a -> (a -> IO a) -> IO ()
10:45:50 <slack1256> derdon: so there you go, you can use ceiling (round to the upper), floor (round to the lower) and round (round upper if >.5)
10:45:59 <siracusa> derdon: Use `div` instead of /
10:46:02 <keep_learning> writeIORef :: IORef a -> a -> IO ()
10:46:24 <keep_learning> Why don't we have some function like modifyMVar_ for IORef.
10:46:37 <derdon> siracusa: ah yes, I was looking for div. thank you
10:46:58 <siracusa> derdon: Or do you actually want it to work for all kind of numbers?
10:47:26 <derdon> siracusa: for all natural numbers
10:47:52 <siracusa> Well, there's no such type in Haskell
10:48:07 <slack1256> siracusa: maybe he refers to Int?
10:48:08 <siracusa> Integer you mean, I guess
10:48:14 <derdon> yup
10:48:16 <siracusa> Or that, yes
10:48:17 <ricree> I figured out my problem from earlier. Apparently I had an oddly formed html page, one that contained a random comment tag at the start of the script
10:48:42 <derdon> Integral is more general, so I took that and it works
10:49:05 <slack1256> keep_learning: we have modifyIORef
10:50:05 <deus_rex> Are there any caveats I should be aware of wrt. having installed copies of ghc and hugs side by side?
10:51:28 <keep_learning> slack1256, I imported GHC.IORef and only function I see is atomicModifyIORef.
10:51:36 <lispy> deus_rex: you might accidentally use hugs for something?
10:52:14 <slack1256> keep_learning: import Data.IORef (generality trumph specificy MUAHAHAHAHA)
10:52:22 <slack1256> no seriously use Data.IORef
10:52:56 <keep_learning> slack1256, Thank you! What is the difference between these two  ?
10:53:08 <keep_learning> I see more functions in Data.IORef
10:53:44 <slack1256> keep_learning: as I understand. somefunctions are imported from the GHC.* into the Data.*
10:54:04 <slack1256> but the things is that the ghc.* is more specific because is used to bootstrap the compiler
10:54:13 <slack1256> not to write general programs
10:54:27 <shachaf> No, the things in GHC.* have nothing to do with compiling GHC itself.
10:54:48 <shachaf> They're GHC-specific things that are provided to other programs.
10:55:20 <slack1256> shachaf: oh. good to know that!
10:55:30 <monochrom> "import GHC.IORef" is clearly not portable
10:55:59 <shachaf> It'll work on every Haskell compiler as long as it's GHC.
10:56:40 <rwbarton> ricree: IIRC '<script language="javascript"><!-- blah blah blah --></script>' is sometimes used to hide the javascript from old (well, ancient by now) browsers that don't know about the script tag
10:56:46 <monochrom> if you say, "but I will only use GHC", ok, but it may change over different GHC versions
10:57:28 <shachaf> monochrom: If you say "but I will only use Haskell", ok, but it may change over different Haskell versions.
10:57:38 <shachaf> In fact, it may even change over different GHC versions.
10:57:44 <shachaf> For example the superclasses of Num
10:58:09 <monochrom> yes, but Data.IORef and Num change much less often than GHC does
11:00:50 <aristid> and GHC.IORef changes less often than GHC does
11:05:38 <Tarailo> hello from a beginner
11:05:50 <byorgey> hi Tarailo, welcome
11:05:57 <slack1256> Hello Tarailo
11:06:38 <byorgey> Tarailo: if you have any questions as you are learning, this is a great place to ask
11:07:02 <Tarailo> thnx boyrgey
11:07:17 <Tarailo> i have just instaled haskell
11:07:27 <Tarailo> and leksah too
11:11:15 <shurikas> any recommendations for ghc on windows
11:11:23 <shurikas> should I go for 64-bit version or 32-bit one?
11:13:11 <Taneb> Have you got 64-bit windows?
11:15:27 <monochrom> if you want GHC 7.4, you only have 32-bit. if you want 7.6, you have a choice
11:15:42 <shurikas> I guess it doesn't make much difference....
11:19:29 <Ke> is this BSD 3 http://trumpetti.atm.tut.fi/gentoo-portage/licenses/BSD ?
11:19:32 <Tarailo> src\Main.hs:24:1: parse error on input `module'
11:19:42 <Tarailo> i got this message
11:19:48 <Tarailo> on leksah
11:19:52 <Tarailo> what does it mean?
11:20:46 <shirt> can anyone recommend a hackage package that has a very large codebase, and not a lot of dependencies?
11:21:49 <rwbarton> 'module' is a keyword, are you trying to name a function 'module'? you can't do that
11:23:50 <parcs> shirt: not a lot of direct dependencies or not a lot of direct & indirect dependencies?
11:24:21 <shirt> not a lot of total dependencies (direct&indirect)
11:24:28 <monochrom> base is huge and has few dependencies. I'll try to think of a better example!
11:24:30 <parcs> base :P
11:25:07 <monochrom> xmonad should be large and has few dependencies
11:26:46 <elliott> isn't xmonad still <500 lines of code
11:26:47 <Tarailo> is the any complete guide, step by step for start
11:26:51 <elliott> xmonad-contrib is huge though
11:27:02 <Tarailo> it is confusing
11:27:12 <elliott> Tarailo: as far as the language itself goes I recommend http://learnyouahaskell.com/
11:27:36 <Tarailo> thnx
11:28:25 <Tarailo> and about leksah, about packeges, etc
11:28:30 <Tarailo> all on one place
11:28:42 <Tarailo> sorry for disturbing
11:28:52 <shachaf> Most people don't use Leksah.
11:29:14 <Tarailo> o?
11:29:16 <Liskni_si> elliott: xmonad-core is a bit over 1k nowadays
11:29:17 <monochrom> I have certainly not seen any article that covers both leksah and anything else
11:29:47 <Tarailo> ok, so i have chosen hard way haha
11:29:54 <Tarailo> what do you use?
11:30:02 <magneticduck> I forgot all my haskell after a break.. quick question: I'm making a data type an instance of Num, and implementing signum. I need to use signum (for another type, in this case a Float) inside the implementation for signum for my data type. However, ghc doesn't compile it, and give me an error
11:30:11 <monochrom> I use any editor
11:30:12 <magneticduck> how can I fix that
11:30:27 <magneticduck> *gives
11:30:32 <shachaf> magnetic: I suggest reading the error, then thinking about the error, then changing your code so it doesn't give you an error anymore.
11:30:38 <magneticduck> mm
11:30:39 <rwbarton> read your code too
11:30:41 <magneticduck> that usually helps
11:30:43 <magneticduck> I did
11:30:44 <shachaf> Step 2 is optional (but recommended).
11:30:45 <magneticduck> xD
11:30:54 * hackagebot fdo-trash 0.0.0.2 - Utilities related to freedesktop Trash standard.  http://hackage.haskell.org/package/fdo-trash-0.0.0.2 (EmilKarlson)
11:30:55 <magneticduck> it's expecting type Vector (the type I'm implementing)
11:30:58 <magneticduck> but I'm giving it a float
11:31:00 <shachaf> Actually it's step 1 that's optional.
11:31:09 <magneticduck> however, signum runs fine with floats
11:31:12 <magneticduck> in other parts of the code
11:31:18 <byorgey> magneticduck: without seeing your actual code it is pretty much impossible to give specific advice.
11:31:19 <magneticduck> err
11:31:22 <magneticduck> wait
11:31:23 <magneticduck> kk
11:32:01 <magneticduck> inside the "instance Num Vector where" I have the equation
11:32:23 <magneticduck> signum (Vector x y) = (signum x) * (signum y)
11:32:29 <magneticduck> x and y are floats
11:32:47 <rwbarton> :t signum
11:32:48 <lambdabot> Num a => a -> a
11:32:52 <magneticduck> because Vector is defined as "data Vector = Vector Float Float" ...
11:32:54 <byorgey> magneticduck: signum is supposed to return the same type as it is given.
11:32:59 <rwbarton> so that's not going to work
11:33:02 <magneticduck> ah
11:33:04 <byorgey> here you are taking a Vector and returning a Float
11:33:18 <magneticduck> ..oh
11:33:31 <byorgey> in fact, signum does not really make sense for Vector.  I suggest implementing it as  'signum _ = error "signum does not make sense for Vector"'
11:33:39 <ciaranm> that's naughty
11:33:47 <magneticduck> naah
11:33:53 <monochrom> I have a naughtier idea
11:33:57 <ciaranm> also... it can make sense for vectors
11:33:57 <magneticduck> I'll just return Vector (signum x) (signum y)_
11:34:02 <magneticduck> that makes more sense in math
11:34:07 <magneticduck> s/_//
11:34:14 <mjv> isn't signum supposed to return a normalized vector?
11:34:22 <magneticduck> that could work too
11:34:24 <mjv> that seems like the generalization of the sign function for floats
11:34:25 <monochrom> signum _ = Vector (error "signum does not make sense for Vector) (error "signum does not make sense for Vector")
11:34:29 <magneticduck> yeah
11:34:36 <magneticduck> lol monochrom
11:34:38 <byorgey> monochrom: hehe
11:34:41 <magneticduck> >_____>
11:34:51 <magneticduck> well
11:34:59 <mjv> then you have the relation abs * signum = id
11:35:01 <magneticduck> that way, unless you evaluate it fully
11:35:04 <magneticduck> it won't give you an error
11:35:12 <rwbarton> also consider just using Complex
11:35:19 <magneticduck> that would make an intresting bug some day
11:35:36 <magneticduck> mjv: yeah, that's probably the best idea
11:35:42 <magneticduck> thanks dudez
11:35:50 <shachaf> > signum (3 :+ 4)
11:35:52 <lambdabot>   0.6 :+ 0.8
11:36:09 <ciaranm> signum is weird
11:36:33 <magneticduck> btw, does anyone really know how it's supposed to act?
11:36:59 <rwbarton> did you define *?
11:37:11 <magneticduck> yeah
11:37:17 <magneticduck> I did it the dirty way
11:37:29 <magneticduck> if there's any mathematicians here, don't look
11:37:31 <magneticduck> xD
11:37:34 <magneticduck> I'm not going to use it
11:37:47 <shurikas> > signum (1 :+ 2)
11:37:49 <lambdabot>   0.4472135954999579 :+ 0.8944271909999159
11:37:53 <shurikas> what the hell
11:38:03 <magneticduck> so I just put (x1, y1) * (x2, y2) = ((x1 * x2), (y1 * y2))
11:38:16 <magneticduck> alright
11:38:16 <`nand`> shurikas: what about it?
11:38:19 <ciaranm> > sqrt 5.0
11:38:21 <lambdabot>   2.23606797749979
11:38:23 <arbn> So, in Text.Parsec.Token, the identifier tokenizer consumes whitespace, including '\n'. How, then is one supposed to use haskellDef to parse Haskell, since Haskell does use \n to separate things?
11:38:25 <magneticduck> it gives the normalized
11:38:34 <ciaranm> > 1.0 / sqrt 5.0
11:38:35 <lambdabot>   0.4472135954999579
11:38:38 <ciaranm> there you go
11:38:41 <monochrom> @type abs
11:38:43 <lambdabot> Num a => a -> a
11:38:47 <shurikas> @src signum
11:38:48 <lambdabot> Source not found. The more you drive -- the dumber you get.
11:38:55 <`nand`> signum is a class member
11:39:00 <`nand`> of class Num
11:39:03 <shurikas> ok
11:39:31 <rwbarton> well if you're "not going to use it" then define it with error
11:39:54 <monochrom> arbn, a separate layout stage turns whitespace to {;} first
11:39:57 <`nand`> shurikas: that coincides with https://www.wolframalpha.com/input/?i=signum%20(1%20%2B%202i)
11:40:37 <magneticduck> rwbarton: I guess, but I don't like errors
11:40:39 <magneticduck> :D
11:40:43 <magneticduck> I almost never use errors
11:40:46 * BMeph doesn't think 'signum' is a prime example of why definition-by-example is a bad idea, but it makes a good go-to answer to those who ask...
11:40:47 <magneticduck> actually, I never use errors
11:40:47 <monochrom> haskellDef is not meant to be a complete solution for parsing Haskell. haskellDef is only meant to be "Haskell-like tokens"
11:40:55 <shurikas> ok, that makes sense
11:41:01 <shurikas> wolframalpha on signum
11:41:06 <elliott> magneticduck: well silent nonsense is worse than errors
11:41:50 <`nand`> shurikas: it makes sense when you consider the invariant: x = signum x * abs x
11:42:46 <c_wraith> > signum 0
11:42:48 <lambdabot>   0
11:42:51 <c_wraith> ok then
11:43:18 <shachaf> > signum (-0.0)
11:43:20 <lambdabot>   0.0
11:43:46 <ricree> In HXT, is there a way to get it to keep html comments?
11:46:40 <ricree> withPreserveComment True, apparently
11:47:29 <magneticduck> > signum (1, 1)
11:47:31 <lambdabot>   No instance for (GHC.Num.Num (t0, t1))
11:47:31 <lambdabot>    arising from a use of `e_111'
11:47:31 <lambdabot>  Po...
11:47:33 <magneticduck> kk
11:47:36 <magneticduck> just checking
11:47:38 <magneticduck> :D
11:47:38 <shurikas> :D
11:47:59 <monochrom> that's alright
11:48:00 <shurikas> @type signum
11:48:01 <lambdabot> Num a => a -> a
11:51:56 <`nand`> with the usual NumInstances-style tuple instance that would get you (1, 1)
12:05:55 * hackagebot hoovie 0.1 - Haskell Media Server  http://hackage.haskell.org/package/hoovie-0.1 (PeterVanDenBrand)
12:09:01 <neutrino> hi
12:09:55 <pdxleif> If I make a simple product data type, and define an Eq instance for it, if I say deriving Ord, will it use my Eq definition, or a default one?
12:11:33 <phao> rpearl, does haskell let you add types to extend how many errors you can detect at compile time? I am not sure if that's clear, but, for example, I read once that a bunch of people develop a type system for some database application which was able to find some not so obvious problems with the database schema.
12:11:40 <phao> ops, forget that rpearl =D
12:11:52 <elliott> yes
12:11:55 <elliott> sometimes it's not always convenient though
12:12:04 <phao> elliott why?
12:13:26 <elliott> depends on the problem :)
12:15:55 * hackagebot fast-tagsoup 1.0.4 - Fast parser for tagsoup package  http://hackage.haskell.org/package/fast-tagsoup-1.0.4 (VladimirShabanov)
12:16:00 <neutrino> phao: i think you would find the curry-howard isomorphism interesting
12:16:16 <neutrino> since that's basically what you're asking about
12:16:46 <pmk> pdxlief: defining an Eq instance for a type does not appear to affect the behavior of a derived Ord instance
12:17:27 <pmk> pdxleif: which is counterintuitive, IMO, since Ord depends on Eq
12:18:34 <stripes> good day, any advice or uber-wisdom on how to unhide tagsoup and/or get the binary/executable of it working? :-D
12:19:13 <phao> ok
12:21:27 <byorgey> stripes: what about it doesn't work?
12:22:00 <stripes> ahhh , it was complaing about 0.6 and 0.12.8 is installed as well
12:22:17 <stripes> reinstall forceinstalls seemed to have gotten some of it working,, let me try the ghc compile again...
12:22:41 <stripes> small burp...
12:22:49 <stripes> Main.hs:3:8:
12:22:50 <stripes>     Could not find module `Text.HTML.Download'
12:22:52 <stripes>     It is a member of the hidden package `tagsoup-0.6'.
12:22:54 <stripes>     Use -v to see a list of the files searched for.
12:22:57 <stepkut> is there a more sensible way to format cents as a dollar amount than this:
12:22:59 <stepkut> > (\cents -> showFFloat (Just 2) (fromRat $ cents % (100 :: Integer)) "") 1000
12:23:01 <lambdabot>   Not in scope: `%'
12:23:01 <lambdabot>  Perhaps you meant `R.%' (imported from Data.Ratio)
12:23:02 <pmk> pdxleif: the 2010 report seems somewhat ambiguous on this point in section 11.1, i think.  an implementation in which the behavior of (==)/(/=) determined the derived behavior of the Ord methods would perhaps be permitted, although GHC doesn't do so.
12:23:07 <stepkut> > (\cents -> showFFloat (Just 2) (fromRat $ cents R.% (100 :: Integer)) "") 1000
12:23:09 <lambdabot>   "10.00"
12:23:33 <stripes> (is a small paste like that acceptable?)
12:24:48 <byorgey> stripes: it's borderline =)
12:24:55 <stripes> hehe
12:24:57 <pmk> pdxleif: still there?
12:25:13 <byorgey> stripes: are you making your own cabal package?  or are you just compiling a source file directly with ghc?
12:25:16 <stripes> should I just unregister tagsoup-0.6? is there  cabal command to uninstall it
12:25:28 <stripes> compiling a source file that uses tagsoup's library
12:25:36 <byorgey> stripes: sure,  ghc-pkg unregister tagsoup-0.6
12:25:41 <byorgey> stripes: there is no cabal uninstall
12:25:45 <stripes> :-/
12:29:25 <hugosthlm> setup: The program happy version >=1.17 is required but it could not be found.
12:29:38 <hugosthlm> Failed to install haskell-src-exts-1.13.5
12:29:51 <stripes> manually install it using cabal, and make sure your .cabal/bin is in your path, or you symbolically link to the exec for happy
12:29:54 <hugosthlm> Installed happy-1.18.10
12:29:55 <donri> stepkut: how about the text-format package
12:30:06 <stripes> can you run happy from the cli?
12:31:02 <stepkut> donri: hmm
12:31:20 <stepkut> donri: not sure I want to add two new dependencies for that
12:31:21 <donri> stepkut: or printf in base?
12:33:10 <hugosthlm> stripes: writing "happy" in my Linux terminal doesn't work.
12:33:38 <stripes> how about
12:33:51 <stripes> ~/.cabal/bin/happy --help
12:33:53 <stripes> ?
12:34:20 <donri> > printf "%.2d" (1000 R.% 100)
12:34:21 <lambdabot>   No instance for (Text.Printf.PrintfArg (GHC.Real.Ratio a0))
12:34:22 <lambdabot>    arising from...
12:34:35 <stripes> in general there are no IO functions in lambdabot
12:34:36 <hugosthlm> stripes: works!
12:34:37 <donri> > printf "%.2d" (1000 / 100)
12:34:39 <lambdabot>   Ambiguous type variable `a0' in the constraints:
12:34:39 <lambdabot>    (GHC.Show.Show a0)
12:34:39 <lambdabot>     ...
12:35:03 <donri> > printf "%.2d" (1000 / 100) :: String
12:35:05 <lambdabot>   "*Exception: Printf.printf: bad argument
12:35:06 <donri> :p
12:35:48 <hugosthlm> stripes: I'm using cabal for the installations.
12:36:53 <hugosthlm> stripes: didn't understand about the link to happy or .cabal/bin
12:39:20 <hugosthlm> stripes "ln -s /usr/bin/happy /root/.cabal/bin/happy" ?
12:39:37 <hugosthlm> stripes: It's installing on my user ?!
12:40:50 <geekosaur> yes, cabal installs as user, that si expected
12:41:02 <geekosaur> likewise expected is that you know how to add a directory to $PATH
12:45:31 <chrisdone> chris@midnight:~$ ./haskell-docs Control.Concurrent.Chan newChan
12:45:32 <chrisdone> Build and returns a new instance of “Chan”.
12:45:32 <chrisdone> ლ(╹◡╹ლ)
12:45:56 * hackagebot hoovie 0.1.1 - Haskell Media Server  http://hackage.haskell.org/package/hoovie-0.1.1 (PeterVanDenBrand)
12:47:15 <hugosthlm> geekosaur: I made the link(the correct way) and now its installing. Thanx!
13:06:11 <pdxleif> Is there any sort of "multi-map" functionality, that is, a "[(a, b)] -> Data.Map a [b]" kinda thing?
13:07:05 <cmccann> pdxleif, probably most people use (Data.Map a (Data.Set b))
13:07:36 <cmccann> there's probably one somewhere on hackage, but I don't think there is in the standard libraries
13:09:07 <pdxleif> To get there, on my [(a, b)], I do a sortBy fst, groupBy fst, map head fst?
13:09:26 <byorgey> :t foldr (uncurry $ M.insertWith (++)) M.empty . (map . second) (:[])
13:09:27 <lambdabot> Ord a => [(a, b)] -> M.Map a [b]
13:09:38 <pdxleif> Maybe I should define a new datatype, to save me all the (fooBy fst) stuff.
13:09:58 <pdxleif> Ooh, that looks fancy
13:10:06 <shachaf> Probably should be foldl'
13:10:31 <byorgey> sure, though then you need an extra call to 'flip' somewhere
13:10:36 <pdxleif> I'll give that a shot
13:13:33 <pdxleif> What's "second" - the "snd" in my Prelude?
13:14:06 <shachaf> second :: (a -> b) -> (e,a) -> (e,b)
13:14:07 <Ralith> :t second
13:14:09 <lambdabot> Arrow a => a b c -> a (d, b) (d, c)
13:14:15 <shachaf> Ignore the "Arrow" bit.
13:14:25 <shachaf> Also known as "over _2"
13:14:27 <message144> Is "Programming in Haskell" (draft version) found here http://sources.haskell.cz/Programming%20in%20Haskell.pdf a good source for learning?
13:14:57 <shachaf> Hutton's book by that name is good.
13:15:11 <message144> shachaf, ok thanks
13:15:13 <shachaf> That PDF says "NOT FOR DISTRIBUTION" so you probably oughtn't distribute it.
13:15:34 <lawliet> http://learnyouahaskell.com/
13:15:53 <lawliet> free HTML version, I haven't read it all, but first glance looks like a nice beginner
13:16:11 <hpaste> chrisdone pasted “haskell-docs” at http://hpaste.org/79847
13:17:32 <chrisdone> try it out =)
13:18:27 <S11001001> @quote lyah
13:18:28 <lambdabot> tnks says: I'm astounded that LYAH makes an FP language accessible, while Why's Poignant Guide makes a straight-forward imperative language look arcane.
13:25:30 <mjv> is there an easy way in haskell to register keypresses (of, say, the arrow keys?)
13:27:54 <johnw> under X11?
13:29:25 <mjv> is that directed at me? i don't think i know what X11 is
13:29:43 <johnw> well, registering keypresses is usually the job of the window manager
13:30:01 <johnw> i think hReadChar maybe will give you unbuffered character input
13:30:06 <johnw> :t hReadChar
13:30:07 <lambdabot> Not in scope: `hReadChar'
13:30:23 <johnw> sorry, hGetChar
13:30:24 <S11001001> johnw: will that put the terminal in noncanonical mode?
13:30:25 <johnw> :t hGetChar
13:30:26 <lambdabot>     Not in scope: `hGetChar'
13:30:27 <lambdabot>     Perhaps you meant `getChar' (imported from Prelude)
13:30:49 <johnw> S11001001: i don't know, I never deal with interactive I/O
13:31:42 <mjv> what's the difference between hGetChar and getChar?
13:31:49 <johnw> hGetChar takes a file handle
13:31:50 <S11001001> johnw: in canonical mode (the default), the terminal doesn't release any input for reading until you press RET; that allows backspace &c to work without the prog supporting it.
13:32:07 <mjv> oh, haha, of course
13:32:10 <johnw> S11001001: ah,  I call that line buffered mode
13:32:56 <mjv> i'm on windows with ghc, from what i've read there's no obvious way to turn off line buffering
13:33:11 <S11001001> mjv: how about seeing what darcs does.
13:33:22 <chrisdone> mjv: hSetBufferingMode NoBuffering?
13:33:28 <chrisdone> or does windows ignore that
13:33:35 <S11001001> as darcs most certainly puts its term in noncanonical mode during darcs record
13:33:47 <mjv> yeah, i'm pretty sure windows does ignore that
13:33:54 <mjv> i had a se question earlier
13:34:27 <mjv> http://stackoverflow.com/questions/2983974/haskell-read-input-character-from-console-immediately-not-after-newline
13:34:37 <shachaf> @google how to turn off input buffering in haskell
13:34:41 <lambdabot> http://hackage.haskell.org/trac/ghc/ticket/2189
13:34:41 <lambdabot> Title: #2189 (hSetBuffering stdin NoBuffering doesn't work on Windows) – GHC
13:34:41 <shachaf> Seems to confirm it.
13:35:29 <S11001001> https://www.gnu.org/software/libc/manual/html_node/Canonical-or-Not.html
13:36:11 <shachaf> I'm not sure that a gnu.org libc manual page about POSIX systems will help with Windows problems.
13:37:25 <S11001001> shachaf: It's a discussion of terminal concepts.
13:38:57 <aavogt> @hackage haskelline
13:38:57 <lambdabot> http://hackage.haskell.org/package/haskelline
13:39:11 <aavogt> @hackage haskeline -- the actual spelling
13:39:12 <lambdabot> http://hackage.haskell.org/package/haskeline -- the actual spelling
13:39:41 <cmccann> windows does not have a terminal so much as it has an utter travesty masquerading as one. the so-called shell is no better, but is at least more easily replaced.
13:40:52 <`nand`> it should be possible to replace the windows terminal emulator (and shell)
13:40:56 <t7> windows cmd line is much better than linsucks
13:41:08 <aristid> oO
13:41:20 <`nand`> maybe rxvt runs under Interix + XMing
13:42:04 <`nand`> apart from that, Gtk runs on windows; so that means vte should as well (which is what most major terminals use, but it's very slow)
13:46:44 * ion wrote https://github.com/ekmett/lens/wiki/Evaluations in case anyone finds that useful
13:50:14 <hugosthlm> I didn't manage to install  SourceGraph..would break a lot of packages
13:50:30 <`nand`> I wonder if https://github.com/nandykins/nanoterm/blob/master/nanoterm.hs works on windows
13:53:08 <`nand`> is ‘both’ implemented as ‘each’ in 3.8?
13:53:48 <catsbydlo> what's each?
13:54:00 <`nand`> a traversal for each element of some container
13:54:05 <hugosthlm> I didn't manage to install  snap..would break a lot of packages
13:54:40 <johnw> `nand`: how is that different from traverse?
13:54:40 <`nand`> johnw: traverse and each can differ
13:54:43 <`nand`> johnw: the motivating example is (a, a)
13:55:33 <`nand`> traverse is defined for (,) b so traverse on (a, a) would only traverse over the second element
13:55:33 <hugosthlm> Just trying to install a development environment in Eclipse according to a description.
13:55:33 <`nand`> ‘each’ on (a,a) traverses over both
13:55:33 <`nand`> it's supposed to be a generalization of ‘both’
13:55:33 <johnw> ah
13:55:33 <`nand`> it's defined for larger tuples as well
13:55:37 <ion> nand: each for (a,b) is like both, but indexed.
13:55:50 <`nand`> interesting
13:56:49 <`nand`> johnw: also, Each can be monomorphic, whereas Traverse has to support polymorphic containers
13:57:01 <`nand`> so for example you can use ‘each’ to traverse over the Word8s of a ByteString
13:57:06 <ion> That is, (a,a). (Actually (a ~ a') => (a,a'))
13:57:35 <aavogt> > everywhere (mkT (+1)) (1,2,(3,4))
13:57:37 <lambdabot>   Not in scope: `everywhere'Not in scope: `mkT'
13:58:05 <`nand`> everywhere?
13:58:12 <aavogt> from syb
13:58:31 <aavogt> if it was in scope, it'd give you (2,3,(5,6))
13:58:45 <`nand`> > (1,2,(3,4)) & biplate +~ 1
13:58:47 <lambdabot>   (2,3,(4,5))
13:58:51 <aavogt> > Data.Generics.everywhere (Data.Generics.mkT (+1)) (1,2,(3,4))
13:58:52 <lambdabot>   Not in scope: `Data.Generics.everywhere'Not in scope: `Data.Generics.mkT'
14:00:27 <aavogt> yeah, it would do the same thing as that uniplate-inspired thing
14:00:42 <`nand`> I think the biplate interface is superior :)
14:01:31 <shachaf> That's the lens interface, not the biplate interface.
14:01:41 <`nand`> I meant ‘biplate’ as in the function from lens
14:02:23 <Clint> Biplated
14:02:33 <shachaf> edwardk: Hmm, our Tree type is the same as the tree uniplate uses now, right?
14:02:39 <edwardk> yes
14:02:43 <edwardk> i noticed that the other day
14:02:52 <edwardk> its their tree type annotated with stuff
14:02:56 <shachaf> Do they only read, not write?
14:03:13 <edwardk> they read and write to it, but they don't zip around in it
14:03:20 <shachaf> Well, by our Tree type I meant the simple one I wrote at first. :-)
14:03:25 <edwardk> heh
14:03:28 <shachaf> Do they use it to write back to a traversal, I mean?
14:03:56 <edwardk> they don't have the concept of a traversal, but the uniplate stuff is used to both read and write, yes
14:04:06 <shachaf> Oh, right, they don't use them directly.
14:04:21 <shachaf> So they can get away with being more explicit about everything.
14:05:50 <edwardk> yeah
14:05:59 <edwardk> they pay for this rep everywhere though
14:06:03 <edwardk> which is why we wind up faster
14:06:31 <shachaf> Right.
14:06:42 <cordawyn> Hello! I'm trying to write a function which is sort of a stub for Network.HTTP.simpleHTTP. The function always returns a "success" response. Here it is:
14:06:49 <cordawyn> simulatedHTTP :: HStream ty => Request ty -> IO (Network.Stream.Result (Response ty))
14:06:49 <cordawyn> simulatedHTTP req = return $ Right $ Response (2,0,0) "OK" [] ("hello" :: ty)
14:06:55 <shachaf> Well, if we could figure out a way to make zipper more implicit... :-)
14:07:09 <cordawyn> GHC complains:     Could not deduce (Data.String.IsString ty1) ...
14:07:25 <shachaf> cordawyn: The (... :: ty) isn't being matched up the the "ty" in the type.
14:07:38 <cordawyn> so, I need to use forall?
14:07:44 <shachaf> If you want that you can use the GHC extension ScopedTypeVariables.
14:07:47 <shachaf> And, yes, a forall.
14:07:58 <shachaf> There are usually ways to get that behavior without the extension, too.
14:08:06 <cordawyn> I tried that, but it didn't help
14:08:14 <`nand`> what happens if you remove the signature
14:08:15 <c_wraith> It's really too bad that extension wasn't part of the standard.
14:08:17 <shachaf> Tried what?
14:08:18 <cordawyn> simulatedHTTP :: forall ty. (HStream ty) => Request ty -> IO (Network.Stream.Result (Response ty))
14:08:30 <shachaf> cordawyn: Did you turn on ScopedTypeVariables?
14:08:33 <cordawyn> yep
14:08:43 <cordawyn> however
14:08:46 <shachaf> And it was the same error?
14:08:59 <`nand`> cordawyn: Can't GHC infer the type of "hello"?
14:09:12 <cordawyn> with "forall" it said: "Could not deduce (Data.String.IsString ty)"
14:09:15 <cordawyn> ty1 -> ty
14:09:24 <cordawyn> apparently, this should be correct then
14:09:28 <shachaf> cordawyn: Oh.
14:09:32 <shachaf> Are you sure your type is correct?
14:09:40 <shachaf> What happens if you comment it out and ask ghci for the type?
14:09:50 <shachaf> I bet you don't even need the signature.
14:10:05 <`nand`> HStream doesn't imply IsString
14:10:22 <`nand`> so you probably need (HStream ty, IsString ty)
14:10:29 <pdxleif> Is there a way to do import renames?  Like say I want to have the "Text" type from both Data.Text and Data.Text.Lazy in scope?
14:11:02 <`nand`> pdxleif: import qualified
14:11:08 <`nand`> well
14:11:20 <`nand`> technically you just need to append ‘as Name’ to quote the names with Name.whatever
14:11:32 <`nand`> if you import qualified as well, you *have* to quote them
14:11:43 <`nand`> which can prevent ambiguities
14:11:58 <`nand`> eg. if you want strict by default and lazy with a prefix, you can import the lazy version qualified as Lazy or whatever
14:13:03 <shachaf> pdxleif: No, Haskell (post-1.2) doesn't have import renaming.
14:13:33 <cordawyn> `nand`: "IsString ty" restriction helped, actually
14:13:37 <shachaf> Haskell 1.2 had it but I doubt you want to use that.
14:13:39 <chrisdone> i was gonna compile this .hs module, but then i got .hi
14:14:42 <cordawyn> thanks, shachaf and `nand`
14:15:27 <pdxleif> T.Text works; thanks!
14:15:58 * hackagebot sizes 2.0.5 - Recursively show space (size and i-nodes) used in subdirectories  http://hackage.haskell.org/package/sizes-2.0.5 (JohnWiegley)
14:16:06 <pdxleif> chrisdone: Are you trying to get a .exe or a lib?
14:16:25 <catsbydlo> pdxleif: lern2songs
14:17:32 <cordawyn> `nand`: so "instance HStream String" and "instance IsString [Char]" defined in Data.String have nothing to do with this HStream -> IsString implication?
14:17:54 <chrisdone> pdxleif: it's a song, "i was gonna X but then i got high" :p
14:18:12 <pdxleif> Oh, yeah, shoulda read it out loud. :/
14:18:29 <`nand`> cordawyn: correct; Just because some type exists that is instances of both doesn't mean /all/ instances are instances of both
14:18:42 <`nand`> the compiler has no way of knowing that, since type classes are open
14:18:58 <bradleyayers> hi
14:19:24 <`nand`> cordawyn: of course, you could just use String instead of forall ty. ty; then you wouldn't need to add either constraint to your context
14:20:11 <cordawyn> `nand`: yes, I used to do that, but I felt like trying to be more flexible ;-)
14:20:17 <cordawyn> `nand`: thanks for the explanation!
14:22:41 <`nand`> cordawyn: if a class instance implies another class instance, then the class would be defined like this: class Foo a => Bar a -- where Bar a would imply Foo a; that is, every instance of Bar must also be an instance of Foo
14:23:00 <`nand`> you can see that HStream t implies BufferType t, but BufferType doesn't imply anything else
14:24:51 <cordawyn> hmm, that makes sense, indeed
14:28:47 <byorgey> hi bradleyayers
14:28:54 <bradleyayers> thanks byorgey
14:29:21 <bradleyayers> i am curious how many people do haskell commercially?
14:29:41 <chrisdone> @google haskell survey 2011
14:29:43 <lambdabot> http://blog.johantibell.com/2011/07/its-time-for-this-years-state-of.html
14:29:50 <bradleyayers> oh neat
14:30:14 <pmk> ok, what's the purpose of       module Foo (module Foo) where ...
14:30:24 <chrisdone> looks like a mistake
14:30:40 <`nand`> module Foo (module Bar) where ... -- means to re-export Bar
14:30:50 <`nand`> but I can't see a reason for re-exporting Foo from Foo
14:31:47 <pmk> module Foo (module Bar) exports every x in the namespace for which both x and Bar.x are visible
14:32:59 <pmk> ah, maybe     module Foo (module Foo)     is intended to export all definitions in Foo, but none of its unqualified imports?
14:33:18 <`nand`> those don't get re-exported either way, do they?
14:33:32 <Ralith> shouldn't
14:33:39 <pmk> no, they shouldn't
14:33:40 <`nand`> no, I'm certain they don't; otherwise I wouldn't need to import Control.Applicative in every single module
14:36:26 <mreh> how do you marshall to a C bool type?
14:36:34 <mreh> from what I recall they're are integers
14:38:29 <pmk> ah, i think i see the purpose of     module Foo(module Foo)      -- i think it exports all the value constructors, whereas an empty export list exports the types but not the value constructors
14:39:36 <mreh> module Foo(Foo) -- will export the type Foo from module Foo but not the constructors
14:39:38 <`nand`> value constructors are exported by default
14:43:24 <beaky> what is the most elegant line of haskell?
14:43:43 <applicative> > let a = 1 in a
14:43:45 <lambdabot>   1
14:43:50 <c_wraith> > let x = x in x
14:43:54 <lambdabot>   mueval-core: Time limit exceeded
14:43:55 <lispy> > let a = a in 1
14:43:56 <beaky> wow
14:43:56 <lambdabot>   1
14:44:05 <chrisdone> > let in "wait, this works? ;-)"
14:44:06 <beaky> how does that second one work
14:44:07 <lambdabot>   "wait, this works? ;-)"
14:44:12 <beaky> haha
14:44:28 <beaky> ideas for obfuscated haskell :D
14:44:28 <c_wraith> it doesn't really work
14:44:30 <elliott> > do let in ()
14:44:32 <lambdabot>   ()
14:44:39 <c_wraith> it's an infinite loop if you try to evaluate let x = x in x
14:44:47 <c_wraith> For possibly-obvious reasons.
14:44:55 <beaky> ah sorry I meant the 'let in foo' one
14:44:55 <lispy> beaky: if you're asking about 'let a = a in 1', it's due to laziness. You don't need a.
14:44:57 <elliott> > let s=();me=() in do let in do do s for me
14:44:58 <lambdabot>   Not in scope: `for'
14:44:59 <lambdabot>  Perhaps you meant one of these:
14:44:59 <lambdabot>    `Data.Traversable.f...
14:45:11 <elliott> > let s _ _=();for=();me=() in do let in do do s for me
14:45:12 <lambdabot>   ()
14:45:25 <chrisdone> elliott: ʘ‿ʘ
14:45:29 <pmk> (.)(.)(.)(.)(.)(.)(.)(.) f g x y z = f (g x y z)      for any multiple of four (.)'s greater than or equal to 8
14:45:45 <lispy> > let no = const; evil = text "evil" in do no evil
14:45:46 <lambdabot>   No instance for (GHC.Show.Show
14:45:47 <lambdabot>                     (b0 -> Text.PrettyPrint....
14:45:50 <elliott> chrisdone: do you have a problem with letting in dodos? :P
14:45:58 <elliott> if only we had better keywords
14:46:00 <lispy> > let no = id; evil = text "evil" in do no evil
14:46:01 <lambdabot>   evil
14:46:14 <elliott> > let don't _ = () in don't do anything
14:46:16 <lambdabot>   <hint>:1:27: parse error on input `do'
14:46:23 <elliott> :(
14:46:24 <pmk> ($) = flip id
14:46:30 <elliott> pmk: no, ($) = id
14:46:34 <pmk> right
14:46:35 <lispy> > let don't _ = () in don't (do anything)
14:46:36 <lambdabot>   Not in scope: `anything'
14:47:01 <beaky> > map$+3$[1..10]
14:47:03 <lambdabot>   Not in scope: `$+'
14:47:03 <lambdabot>  Perhaps you meant one of these:
14:47:03 <lambdabot>    `$' (imported from D...
14:47:06 <mreh> $ = `id`
14:47:06 <beaky> :(
14:47:29 <mreh> makes the point a bit clearer
14:47:44 <lispy> > zipWith id [(+1),(+2),(*3)] [1..]
14:47:45 <lambdabot>   [2,4,9]
14:47:47 <pmk> let $ = id
14:47:52 <chrisdone> > do not (let in vampires)
14:47:55 <lambdabot>   False
14:48:10 <mreh> > cake
14:48:12 <lambdabot>   ["One 18.25 ounce package chocolate cake mix.","One can prepared coconut pe...
14:48:28 <mreh> > unlines cake
14:48:30 <lambdabot>   "One 18.25 ounce package chocolate cake mix.\nOne can prepared coconut peca...
14:48:32 <beaky> :t vampires
14:48:34 <lambdabot> Bool
14:48:38 <beaky> O.o
14:48:42 <`nand`> > length cake
14:48:44 <lambdabot>   42
14:48:49 <mreh> :O
14:48:53 <`nand`> :t vampires
14:48:54 <lambdabot> Bool
14:49:01 <lispy> > let f x | x > 0 = 5 | vampires = 10 in f -1
14:49:03 <lambdabot>   No instance for (GHC.Num.Num (a0 -> a1))
14:49:03 <lambdabot>    arising from a use of `e_105101...
14:49:11 <beaky> @src vampires
14:49:11 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
14:49:15 <beaky> :(
14:49:25 <chrisdone> > flip take cake 3 -- ヽ (＾▽＾) ﾉ all mine
14:49:26 <lambdabot>   mueval: recoverEncode: invalid argument (invalid character)
14:49:29 <lispy> > let f x | x > 0 = 5 | vampires = 10 in f (-1)
14:49:31 <lambdabot>   10
14:49:34 <chrisdone> ~_~
14:49:43 <lispy> > vampires == otherwise
14:49:45 <lambdabot>   True
14:49:51 <mreh> @let therefore = "aliens"
14:49:53 <lambdabot>  Defined.
14:49:57 <lispy> ?check vampires == otherwise
14:49:58 <mreh> > therefore
14:49:58 <lambdabot>   Not in scope: `myquickcheck'
14:50:00 <lambdabot>   "aliens"
14:51:36 <chrisdone> @let loeb x = fmap (\a -> a (loeb x)) x
14:51:39 <lambdabot>  Defined.
14:52:01 <`nand`> :t loeb
14:52:02 <lambdabot> Functor f => f (f b -> b) -> f b
14:52:02 <mreh> ??!
14:52:08 <chrisdone> > loeb [const 0,const 1,\me -> me!!0]
14:52:10 <lambdabot>   [0,1,0]
14:52:28 <`nand`> clever
14:52:52 <chrisdone> > loeb [const 0,const 1,\me -> me!!0,sum . map (*2) . take 3]
14:52:54 <lambdabot>   [0,1,0,2]
14:52:58 <beaky> :t [[[]]]
14:53:00 <lambdabot> [[[a]]]
14:53:02 <mreh> can we use that to make fib?
14:53:11 <beaky> :t let xs = [xs] in xs
14:53:13 <lambdabot>     Occurs check: cannot construct the infinite type: t0 = [t0]
14:53:13 <lambdabot>     In the expression: xs
14:53:13 <lambdabot>     In the expression: [xs]
14:53:30 <chrisdone> mreh: i don't *think* so
14:53:45 <mreh> oh, the definition of fix is very nice
14:53:46 <chrisdone> i once tried to use it to solve sudokus, but it's like a spreadsheet, can't do backtracking D:
14:53:57 <mreh> @src fix
14:53:57 <lambdabot> fix f = let x = f x in x
14:54:17 <mreh> it is the Y combinator
14:54:40 <mreh> not the Y combinator
14:54:45 <mreh> what am I talking about
14:54:54 <mreh> it's the definition of a fix point :)
14:54:58 <`nand`> > loeb $ [const 0, const 1] ++ zipWith (\x y -> liftM2 (+) (!!x) (!!y)) [0..] [1..]
14:55:02 <lambdabot>   mueval-core: Time limit exceeded
14:55:05 <`nand`> shame
14:55:08 <chrisdone> > (fix $ \l x -> fmap (\a -> a (l x)) x) [const 0,const 1,\me -> me!!0,sum . map (*2) . take 3]
14:55:11 <lambdabot>   [0,1,0,2]
14:55:18 <`nand`> > take 10 . loeb $ [const 0, const 1] ++ zipWith (\x y -> liftM2 (+) (!!x) (!!y)) [0..] [1..]
14:55:21 <lambdabot>   [0,1,1,2,3,5,8,13,21,34]
14:55:30 <`nand`> very, very inefficient
14:55:54 <`nand`> like fib n = fib (n-1) + fib (n-2) but with the added overhead of loeb and stuff
14:56:05 <chrisdone> cheating!!
14:56:13 <mreh> there's an even better fib definition
14:56:41 <beaky> how do I construct an infintiely-nested list in haskell
14:56:49 <`nand`> > let fibs = scanl (+) 0 (1:fibs) in fibs
14:56:50 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
14:56:54 <chrisdone> beaky: shouldn't be well typed
14:56:59 <beaky> ah
14:57:06 <beaky> so haskell's type system isn't powerful enough for that?
14:57:25 <chrisdone> not that kind of infinite type, i don't think
14:57:34 <mreh> there only exist one value in that type _|_?
14:57:54 <chrisdone> what type?
14:58:05 <mreh> the type of infinitely nested lists
14:58:28 <c_wraith> beaky: haskell's type system doesn't support infinite types by choice - if you want an infinite type, you can emulate it with a newtype wrapper
14:58:30 <chrisdone> oh, i don't know
14:58:41 <c_wraith> mreh: no.  []
14:58:41 <chrisdone> :k Mu
14:58:43 <lambdabot> (* -> *) -> *
14:58:55 <`nand`> Mu [] ≅ [[[....
14:59:02 <mreh> yes, you're perfectly right
14:59:08 <`nand`> mreh: [[[]]] etc. as well
14:59:16 <`nand`> also [[], []]
14:59:17 <c_wraith> beaky: the reason infinite types are unsupported is that if you allow infinite types, many things that should be type errors aren't.
14:59:18 <beaky> ah
14:59:39 <mreh> > let xs = [xs] in xs
14:59:41 <lambdabot>   Occurs check: cannot construct the infinite type: t0 = [t0]
14:59:46 <`nand`> mreh: Mu [] is isomorphic to Tree ()
14:59:47 <mreh> beaky, ^
14:59:49 <r00723r0> Does tail have to walk the list?
14:59:50 <`nand`> where Tree is rose trees
14:59:54 <c_wraith> r00723r0: yes
15:00:12 <r00723r0> c_wraith: thanks.
15:00:18 <c_wraith> r00723r0: lists are just singly-linked lists.  There's no shortcut available for anything like tail
15:00:36 <r00723r0> c_wraith: OK, that's very useful.
15:01:11 <r00723r0> Wait, if they're singly-linked, can't you just start the chain from the second element?
15:01:33 <c_wraith> sure, but that doesn't let you avoid walking the rest of the list
15:01:35 <monadicity> haskell
15:01:42 <r00723r0> c_wraith: why not?
15:01:52 <`nand`> r00723r0: if you want something more powerful, you could look at Data.Sequence.Seq
15:01:54 <r00723r0> Because a copy has to be made?
15:01:56 <`nand`> which supports O(1) tail access
15:02:10 <c_wraith> > let x = [1..10]; y = 0 : x in (x, y, tail x, tail y)
15:02:12 <lambdabot>   ([1,2,3,4,5,6,7,8,9,10],[0,1,2,3,4,5,6,7,8,9,10],[2,3,4,5,6,7,8,9,10],[1,2,...
15:02:16 <Philippa> r00723r0: because how did you know where it was?
15:02:16 <`nand`> r00723r0: because you have no idea what the second element is without looking at the first
15:02:26 <c_wraith> Oh, tailt
15:02:35 <r00723r0> Right, just the first. You don't have to walk, right?
15:02:36 <Philippa> `nand`: indeed, you have no idea if there /is/ one (as opposed to a term that claims to produce one)
15:02:41 <c_wraith> r00723r0: sorry, tail is O(1).  I thought you said last.
15:02:45 <c_wraith> r00723r0: you are correct
15:02:47 <r00723r0> OK, cool, thanks.
15:03:06 <`nand`> oh
15:03:11 <`nand`> I was thinking of last as well :)
15:03:18 <c_wraith> man, we're not very good at this today
15:03:21 <`nand`> not at all
15:03:49 <r00723r0> Why does one use null rather than == []?
15:03:58 <`nand`> r00723r0: null is more general
15:04:04 <`nand`> r00723r0: look at the types
15:04:07 <`nand`> :t (==) []
15:04:08 <lambdabot> Eq a => [a] -> Bool
15:04:09 <`nand`> :t null
15:04:10 <lambdabot> [a] -> Bool
15:04:53 <r00723r0> Are there mutable types in Haskell?
15:05:10 <`nand`> there are types of mutable containers
15:05:10 <beaky> yes
15:05:15 <beaky> :t IORef
15:05:15 <`nand`> which you can mutate eg. in the IO or ST monad
15:05:17 <lambdabot> Not in scope: data constructor `IORef'
15:05:19 <r00723r0> Are they widely used?
15:05:21 <beaky> :(
15:05:26 <c_wraith> Not often.
15:05:28 <`nand`> when the problem calls for it
15:05:34 <c_wraith> Mostly in concurrency-related things
15:05:44 <`nand`> ST can be fairly efficient if you're writing algorithms that rely on a lot of imperative array munging
15:05:45 <r00723r0> Interesting, I'd expect the opposite.
15:06:08 <`nand`> there's also STM, which is used for concurrency (in particular, sharing values between threads)
15:06:31 <c_wraith> well, most of the uses of mutable values are updating values seen by other threads.  ST's use case of performance is one of the few other cases
15:06:53 <`nand`> IORef or MVar is good for very simple concurrency stuff; or when you want blocking
15:07:20 <`nand`> and, of course, if you want to simulate mutability you can go much simpler than that
15:07:42 <`nand`> for example, the State monad offers you with a way to sequence state mutations together (that are, under the hood, just pure functions)
15:09:07 <`nand`> > runState (do { id .= 3; id += 1; id *= 4; view id }) 0
15:09:09 <lambdabot>   No instance for (Control.Monad.Reader.Class.MonadReader
15:09:09 <lambdabot>                    ...
15:09:19 <`nand`> oh
15:09:26 <`nand`> > runState (do { id .= 3; id += 1; id *= 4; use id }) 0
15:09:28 <lambdabot>   (16,16)
15:09:46 <`nand`> > runState (do { id .= 3; id += 1; id *= 4; return "hello!" }) 0
15:09:48 <lambdabot>   ("hello!",16)
15:09:50 <BMeph> `nand`: Really? Like calling it "id" isn't going to muddy the waters? ;þ
15:09:52 <`nand`> 16 here is the state
15:10:16 <`nand`> meh, the functions are too convenient :P
15:10:23 <`nand`> I'll admit, that's probably a confusing example
15:11:04 * BMeph is frankly surprised someone didn't use "it" instead... ;)
15:11:06 <`nand`> r00723r0: for even simpler functions, you can just use tail-calling with extra parameters for the values that change from iteration to iteraiton
15:11:11 <`nand`> BMeph: haha
15:11:14 <`nand`> edwardk: let it = id
15:11:30 <shachaf> it is taken
15:12:38 <`nand`> yeah, GHCi overwrites it (anything else?)
15:23:45 <newsham> ?type (.=)
15:23:47 <lambdabot> MonadState s m => Setting s s a b -> b -> m ()
15:24:56 <r00723r0> What's the best Haskell compiler?
15:25:07 <`nand`> depends on what you want to compile Haskell for
15:25:08 <newsham> yhc?
15:25:18 <r00723r0> It's gotta have a nice REPL.
15:25:19 <`nand`> or to, rather
15:25:25 <`nand`> r00723r0: you might be interested in GHC
15:25:35 <`nand`> it's fairly ubiquitous for personal computers; and comes with a nice REPL (GHCi)
15:25:36 <r00723r0> `nand`: is that the de-facto standard?
15:25:40 <r00723r0> OK, nice.
15:25:41 <`nand`> r00723r0: you could say so, yeah
15:26:00 <`nand`> it's also probably the most advanced, extension-wise
15:26:18 <r00723r0> OK, so probably most useful for my purposes.
15:26:53 <`nand`> there's also hugs, which used to be a pretty popular recommendation for newcomers, and was the first iirc to provide a repl; some claim it has simpler errors but with a bit of squinting GHC's aren't that unreadable
15:27:46 <Saizan> ghc typechecks before desugaring, i think that's quite a plus for error messages
15:27:50 <shachaf> Did Hugs have a REPL before hbi?
15:28:00 <Saizan> unlikely
15:29:46 <r00723r0> WTF is going on here? [ x | x <- [9..11], x <- [1..10], 4 < x && x < 10 ]
15:30:08 <shachaf> Shadowing?
15:30:13 <newsham> two different x's with the same name?
15:30:18 <shachaf>  [ x | _ <- [9..11], x <- [1..10], 4 < x && x < 10 ]
15:30:34 <shachaf> Oh.
15:30:37 <shachaf> > "[ x | x <- [9..11], x <- [1..10], 4 < x && x < 10 ]"
15:30:40 <lambdabot>   "[ x | x <- [9..11], x <- [1..10], 4 < x && x < 10 ]"
15:30:43 <chrisdone> QUINE!
15:30:43 <shachaf> Ah, no.
15:30:54 <r00723r0> chrisdone: hahahaha!
15:31:16 <newsham> shachaf: quit yer quinin'
15:31:20 <`nand`> r00723r0: yes, looks like shadowing
15:31:27 <derdon> chrisdone: for a few seconds, you really confused me :D
15:31:30 <r00723r0> But anyway, this one is an infinite list, compared to [ x | x <- [1..10], 4 < x && x < 10 ] which is finite.
15:31:32 <`nand`> > [ x | x <- [1,2,3], x <- [4,5,6] ]
15:31:33 <lambdabot>   [4,5,6,4,5,6,4,5,6]
15:31:41 <r00723r0> What makes that happen?
15:31:47 <r00723r0> The repitition?
15:31:57 <`nand`> r00723r0: what you pasted shouldn't be infinite
15:32:02 <newsham> r007:  its like nested loops with their own definition for what x is
15:32:09 <r00723r0> > [ x | x <- [1..10], 4 < x && x < 10 ]
15:32:11 <lambdabot>   [5,6,7,8,9]
15:32:19 <`nand`> > length [ x | x <- [9..11], x <- [1..10], 4 < x && x < 10 ]
15:32:21 <lambdabot>   15
15:32:35 <r00723r0> OK, why is it of length 15?
15:32:58 <newsham> for(int x = 9; x <= 11; x++) { for(int x = 1; x <= 10; x++) { if(x<4 && x<10) printf("%d\n", x); } }
15:33:02 <shachaf> > filter (\x -> 4 <- x && x <- 10) [1..10]
15:33:03 <lambdabot>   <hint>:1:17: parse error on input `<-'
15:33:05 <`nand`> there are 5 elements of [1..10] that are between 4 and 10
15:33:14 <`nand`> and the list gets repeated 3 times due to the first x <- [9..11]
15:33:15 <shachaf> > filter (\x -> 4 < x && x < 10) [1..10]
15:33:16 <`nand`> 3 * 5 = 15
15:33:17 <lambdabot>   [5,6,7,8,9]
15:33:19 <catsbydlo> > [ x | x <- [9..11], x <- [1..10], 4 < x && x < 10 ]
15:33:21 <lambdabot>   [5,6,7,8,9,5,6,7,8,9,5,6,7,8,9]
15:33:27 <beaky> can the lambda calculus express anything that a universal turing machine can?
15:33:35 <newsham> beaky: yes
15:33:50 <catsbydlo> all aboard the lambda calculus express
15:34:02 <r00723r0> Oh awesome!
15:34:04 <r00723r0> Thanks guys.
15:34:37 <beaky> so the lambda calculus can easily do things like parsing?
15:34:53 <Philippa> beaky: "easily" has nothing to do with the question, but yes
15:34:53 <catsbydlo> no one said "easily"
15:35:11 <catsbydlo> first you'd have to define strings and data structures for the result
15:35:18 <Philippa> Hutton&Meijer's paper on monadic parsing might work for you
15:35:32 <Philippa> (Parsec is descended from it)
15:35:37 <beaky> ah
15:35:46 <beaky> what are turing machines good for?
15:35:47 <BMeph> catsbydlo: As an aside, you'd have to do that with a UTM as well. :)
15:35:56 <c_wraith> turing machines are good for bugs
15:36:11 <`nand`> the only thing the lambda calculus has is parsers (if you grant me the freedom of conflating ‘parser’ and ‘function’)
15:36:11 <newsham> beaky: yup... just write a parsec lib :)
15:36:14 <catsbydlo> beaky: proving the existence of undecidable problems
15:36:21 <beaky> oh
15:36:27 <beaky> why don't they use the lambda calculus for that?
15:36:37 <newsham> beaky: who doesnt?
15:37:00 <catsbydlo> a turing machine is an abstract mathematician
15:37:06 <catsbydlo> a computer
15:37:12 <r00723r0> Is Haskell provable?
15:37:19 <`nand`> provable?
15:37:24 <`nand`> provable that it exists?
15:37:32 <r00723r0> No, its results.
15:37:35 <catsbydlo> exists haskell. haskell
15:37:40 <elliott> you can prove it resulted in its results
15:37:40 <monadicity> monadic
15:37:53 <`nand`> haskell has results?
15:37:53 <r00723r0> elliott: can you prove its results beforehand?
15:38:01 <cmccann> @quote kmc ints.exist
15:38:01 <lambdabot> kmc says: "Haskell is great, because Curry-Howard!  Proving things in the type system.  We can prove that, uh, Ints exist, unless they're ⊥."
15:38:08 <elliott> r00723r0: depends what you want to prove about them
15:38:13 <elliott> and what the results in question are
15:38:16 <r00723r0> I don't know.
15:38:21 <r00723r0> There are provable languages. That's all I know.
15:38:26 <catsbydlo> it's at least as provable as C
15:38:32 <r00723r0> catsbydlo: that's not saying much.
15:38:35 <`nand`> I don't know what a provable language is
15:38:36 * elliott isn't sure "provable language" means much
15:38:41 <r00723r0> Me either. Oh well.
15:39:59 <newsham> you can reason about some haskell programmers more easily than reasoning about some java programs
15:40:01 <byorgey> there are languages whose type system corresponds to a consistent logic.
15:40:05 <newsham> programs :)
15:40:09 <newsham> not programmers :)
15:40:12 <byorgey> (Haskell isn't one)
15:40:27 * cmccann suspects that whatever "provable" means in that context, Haskell is not provable, but most mainstream languages are even less provable.
15:40:31 <`nand`> depends on what you mean by ‘correspond’; I guess?
15:40:41 <byorgey> however it is easy to *pretend* that Haskell is one of those languages, and it's actually quite useful to do so.
15:41:08 <`nand`> maybe there's some mapping of type systems to some form of logic which is consistent other than curry-howard?
15:41:09 * cmccann reasons about haskell programmers and proves the theorem that they spend a lot of time debating semantics on IRC.
15:41:19 <elliott> r00723r0: anyway even outside the realms of formal proof haskell has advantages for simply reasoning
15:41:21 <newsham> but even if you use haskell as a "slightly" inconsistent logic, its not ideal for proving complex mathematical proofs with it
15:41:37 <hugosthlm> Any easy way to get this package? https://github.com/rrnewton/opencl/commit/af1322be964c5ce1b7f080286ec5111e7728bc87 rejecting: OpenCL-1.0.3.2, 1.0.3.1, 1.0.3.0, 1.0.2.6, 1.0.2.4, 1.0.2.3,
15:41:37 <hugosthlm> 1.0.2.2, 1.0.1.3 (global constraint requires ==1.0.3.3)
15:42:08 <`nand`> there is certainly lots of reasoning one can do in haskell
15:42:11 <newsham> r007: http://www.thenewsh.com/~newsham/formal/reverse/ and http://www.thenewsh.com/~newsham/formal/curryhoward/
15:42:31 <`nand`> for example manual reduction and instantiation to prove two expressions are equivalent
15:42:35 <r00723r0> So can Haskell be formally reasoned about?
15:42:39 <`nand`> sure
15:42:43 <`nand`> everything can be formally reasoned about
15:42:44 <elliott> well, C can be formally reasoned about too
15:42:48 <byorgey> hugosthlm: apparently that hackage is not released on Hackage
15:42:57 <byorgey> hugosthlm: see http://hackage.haskell.org/package/OpenCL
15:43:04 <byorgey> hugosthlm: you'll have to compile it from github
15:43:10 <c_wraith> according to the title of the one paper, you can fast-and-loosely reason about haskell, with moral correctness. :)
15:43:27 <byorgey> hugosthlm: git clone https://github.com/rrnewton/opencl.git && cd opencl && cabal install
15:43:37 <`nand`> ‘formal’ just means it's structured
15:43:52 <byorgey> hugosthlm: heh, I meant "apparently that version of the package is not released on Hackage"
15:44:01 <catsbydlo> manual insinuation
15:44:01 <hugosthlm> byorgey: thanks!
15:44:02 <`nand`> structured and strict, I guess
15:44:43 <r00723r0> In what way is Haskell more fit for formal reasoning than other languages?
15:45:25 <`nand`> in that Haskell uses lots of pure functions; which can be replaced by their results at any time without changing their meaning
15:45:30 <byorgey> r00723r0: the lack of side-effects means you can do "equational reasoning", i.e. if you have a definition  x = y  then you can replace x with y anywhere
15:45:47 <byorgey> this is quite a powerful reasoning technique, as it turns out
15:46:03 <rwbarton> in most languages you cannot really write expressions that represent values at all
15:46:15 <rwbarton> expressions represent computations; only variables have values
15:46:33 <r00723r0> So how is this different than formal reasoning on C?
15:46:58 <hugosthlm> byorgey: Installed!
15:47:00 <chrisdone> my colleague wrote some x.onclick(add(this,andthat)) in JS last week. i said “this ain't Haskell! get outta here! and buy a haskell book and let's talk”
15:47:07 <`nand`> rwbarton: well, the computation that returns just ‘3’ is functionally equivalent to the number 3
15:47:08 <Philippa> r00723r0: with C, you have to keep track of changes you might cause anywhere in the computer's memory (and worse)
15:47:35 <Nereid> r00723r0: if you write x = getchar(); you can't replace x with getchar() and expect it to not change the meaning of the program.
15:47:55 <newsham> with C your array write might alter future control flow in ways the programmer didnt anticipate :)
15:47:56 <catsbydlo> realloc((void *)rand(), 42); /* happy fun time */
15:47:58 <c_wraith> yeah, formal reasoning about C is approximately the same as formal reasoning about bf.  You have to construct a memory model, then reason about the way the code changes the values in that memory
15:48:05 <Philippa> `nand`: not unless it's first class and does nothing else whatsoever
15:48:31 <`nand`> Philippa: well, for example, numeric constants in many imperative languages come to mind
15:48:41 <r00723r0> So what's Haskell's GC like?
15:48:50 <`nand`> r00723r0: depends on the implementation
15:48:56 <r00723r0> GHC?
15:49:01 <catsbydlo> >implying Haskell has a GC
15:49:04 <c_wraith> GHC's GC is a stop-the-world generational copying collector
15:49:05 <`nand`> (Haskell itself doesn't specify a GC, does it?)
15:49:25 <`nand`> (well, maybe some base-stuff does imply a GC, like ForeignPtr or whatever)
15:49:58 <sclv> sweet. so i turn an nfa into a dfa and get the usual exponential explosion and i'm too lazy to do anything about it
15:49:59 <c_wraith> eh, I don't think you break ForeignPtr's specification if no memory is ever reclaimed..
15:50:08 <sclv> then i take the generated bytecode and toss it at llvm's optimizer
15:50:15 <sclv> and it strips out all the unreachable states for me!
15:50:17 <c_wraith> it's just kind of vacuously true
15:50:35 <elliott> sclv: awesome
15:50:47 <sclv> 5.7 megs for the original
15:50:53 <sclv> down to 980 bytes for the optimize
15:50:57 <rwbarton> sclv: that's pretty cool
15:50:58 <rwbarton> haha
15:51:17 <rwbarton> you still have to strictly feed in all the possible states to LLVM, I guess
15:51:24 <`nand`> c_wraith: yeah I think all of the GC-related specifications in base are vaguely open-ended
15:51:34 <sclv> yeah -- i'm just using text.regex.tdfa to do all the work
15:51:38 <`nand`> to the effect of “this could be reclaimed at any time, but is not necessarily instant”
15:51:42 <sclv> it uses a trie to lazily generate the states it needs
15:51:59 <sclv> i'm sure i could do something clever to only traverse the parts i want to begin with
15:52:09 <sclv> but this is really a proof of concept
15:52:24 <sclv> the last thing haskell needs is another ridiculous regex engine
15:52:25 <chrisdone> Philippa: check out this sexy sauce
15:52:25 <chrisdone> λ> :doc Data.List.Split splitWhen
15:52:25 <chrisdone> Split on elements satisfying the given predicate. Equivalent to
15:52:25 <chrisdone>  `split . dropDelims . whenElt`. For example:
15:52:28 <chrisdone>  
15:52:31 <chrisdone>      splitWhen (<0) [1,3,-4,5,7,-9,0,2] == [[1,3],[5,7],[0,2]]
15:52:31 <rwbarton> are you planning to publish this library? I was thinking of writing something similar
15:52:42 <`nand`> :doc?
15:52:56 <catsbydlo> :what's up doc
15:53:15 <chrisdone> code: https://gist.github.com/4384163
15:53:24 <chrisdone> only took me 6 hours to produce ಠ_ಠ
15:54:35 <chrisdone> \(✿◠‿◠)/ i'm gonna go show haskell-cafe
15:54:48 <ion> chrisdone: Nice!
15:54:55 <rwbarton> I got as far as feeding a text file into a little LLVM assembly program (written in the EDSL) that spits out every line of the file to a callback
15:55:16 <rwbarton> let me tell you, LLVM assembly as a Haskell EDSL is not a pleasant programming experience
15:55:25 <Eelis> is any of the ivans here ivan miljenovic?
15:55:29 <chrisdone> ion: if you're gonna try it, make sure you have the haddock library installed, but it should match the version you got with ghc
15:55:37 <chrisdone> Eelis: he usually goes by ivanm
15:55:41 <Eelis> chrisdone: ah, thanks
15:57:32 <`nand`> chrisdone: is it going onto hackage?
15:57:42 <`nand`> (or does it have a .cabal file, for that matter)
15:58:07 <sclv> rwbarton: yeah, i'm calling it adf-dfa
15:58:07 <rwbarton> chrisdone: it would be neat if it could automatically pick the 'splitWhen' that's in scope, so you don't have to specify the module name
15:58:11 <sclv> a darn fast dfa
15:58:16 <Philippa> chrisdone: nice!
15:58:27 <sclv> it just takes a simple dfa description and compiles it as llvm
15:58:28 <chrisdone> `nand`: i'll make a hackage packge… once i'm sure how to deal with the versioning of haddock. maybe it's not a big deal
15:58:29 <`nand`> +1 for what rwbarton suggested
15:58:34 <`nand`> it would be great to get the name as it would be in-scope
15:58:38 <sclv> rwbarton: what's your concept specifically?
15:58:38 <rhodesd> Is there a library that will type check partially written haskell programs?
15:58:54 <`nand`> chrisdone: it's a lot less effort for me to port and install it once it's on hackage :)
15:58:57 <sclv> i actually find llvm to be not horrible to work with given our bindings
15:59:02 <sclv> except i had to learn some things the hard way
15:59:05 <sclv> about blocks and ssa
15:59:06 <`nand`> rhodesd: GHC, with holes?
15:59:16 <sclv> and i'm still sort of avoiding ssa and doing some load/stores i could probably avoid
15:59:18 <rhodesd> `nand`: I'll look into that, thanks.
15:59:22 <sclv> just so i don't have to wrangle phi nodes
15:59:36 <`nand`> I'm not sure if we even have holes yet
15:59:47 <chrisdone> rwbarton: how would you do that from ghci? hmmm. can you get the output of a GHC command (e.g. :i ) from within a command?
16:00:01 <`nand`> isn't there some GHCi monad?
16:00:07 <sclv> oh, you meant more a full fledged llvm edsl in haskell?
16:00:27 <chrisdone> is there? afaiknew it's the IO monad
16:00:34 <rwbarton> sclv: yeah, the basic blocks phi nodes were a particular pain point
16:01:08 <rwbarton> sclv: basically I want to be able to do regular expression searches against a large text file
16:01:16 <rwbarton> and see whether I can beat grep for speed
16:01:34 <rwbarton> however I also want, for example, approximate matching
16:02:13 <`nand`> chrisdone: http://hackage.haskell.org/packages/archive/base/4.6.0.0/doc/html/src/GHC-GHCi.html
16:02:24 <rwbarton> which is easier to express as an operation on NFAs than on regular expressions
16:02:34 <`nand`> oh
16:02:39 <`nand`> “EXPERIMENTAL! DON'T USE.”
16:02:43 <`nand`> it's upper case, must be serious
16:02:58 <Gracenotes> rwbarton: incidentally, you've read this, yes? http://ridiculousfish.com/blog/posts/old-age-and-treachery.html
16:03:10 <rwbarton> heh
16:03:17 <chrisdone> `nand`: well you can implement this one, i'll do the next one :p
16:03:27 <`nand`> chrisdone: can't you run template-haskell in macros? maybe query or something
16:04:13 <sclv> yeah i'd be shocked if anything can beat grep
16:04:17 <`nand`> you could munge a ' in front of the name to get a Language.Haskell.TH.Syntax.Name then look that up
16:05:37 <Fuuzetsu> @src return :: IO
16:05:38 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
16:05:43 <Fuuzetsu> :t (&&&)
16:05:45 <rwbarton> chrisdone: I was imagining using TH -- but that would require the ghci to be running with -XTemplateHaskell I guess
16:05:45 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
16:06:01 <rwbarton> I suppose you could always set that inside the macro, right?
16:06:35 <rwbarton> but there should be a better way
16:06:43 <`nand`> {-# LANGUAGE TemplateHaskell #-} 'id syntax errors in GHCi without TemplateHaskell set
16:06:47 <`nand`> oh
16:06:52 <chrisdone> really i can do this with a bit of emacs, but none of you non-emacsers would benefit :p
16:06:52 <`nand`> you mean with :set -XTemplateHaskell in a macro
16:07:20 <rwbarton> `nand`: yeah, I've never tried writing a ghci command but it sounds plausible...
16:07:38 <sclv> rwbarton: here's what i've got so far, if you're interested: hub.darcs.net/gershomb/adf-dfa
16:07:46 <chrisdone> ghci commands are IO String. the string they returns can be :foo to run further commands
16:07:57 <sclv> but the project from my standpoint is more of a general dfa library than a matcher as such
16:09:10 <sclv> an applicative parser on top of llvm would be fun tho, in an over-the-top sort of way
16:09:43 <rwbarton> for all those parsers that are known only at run time
16:10:39 <sclv> eh, it could compile llvm that you could link statically too :-)
16:11:02 <sclv> what i really want is combinator-style syntax combined with yacc-style brutal efficiency
16:11:20 <sclv> although i suppose you could just write an applicative dsl for yacc :-P
16:13:49 <niteria> peg is supposed to be efficient
16:14:41 <sclv> sure. but can it compete with a state machine generated directly in assembly :-P
16:14:48 <`nand`> chrisdone: can the String contain newlines to separate individual commands to run?
16:15:08 <sclv> basically i've written a toy which is overkill for just about anything i can think of that's not on a massive scale
16:15:13 <chrisdone> `nand`: not sure, try it
16:15:32 <sclv> but its nice to know its there
16:16:13 <rwbarton> yes, it can
16:16:25 <rwbarton> example from ghc-vis: :def asu \x -> getChar >>= \c -> case c of { 'q' -> return ""; _ -> return $ ":step " ++ x ++ "\n:update\n:asu" }
16:16:30 <`nand`> I cam to the same conclusion
16:16:32 <`nand`> came*
16:16:40 <`nand`> interestingly, it can also contain haskell expressions to be evaluated
16:16:50 <`nand`> I guess that makes sense
16:16:51 <rwbarton> so I guess you can write loops that way
16:17:06 <rwbarton> though it's pretty awful
16:17:19 <chrisdone> i'm making a hackage package, you make the GHCi magic =)
16:17:22 <`nand`> I think they should live in a much nicer GHCi monad
16:17:45 <`nand`> like, Args -> GHCi ()
16:18:46 <`nand`> actually, Args -> GHCi Output would probably make more sense
16:19:05 <`nand`> then you can run other commands and reprocess their output without trapping stdout or an-- hey there's an idea
16:20:15 <`nand`> open up a handle (or whatever), redirect stdout to it; serialize the handle to a bytestring, run the next command with that bytestring as the argument; and :i in between
16:24:58 <`nand`> s/bytestring/string/
16:27:00 <monadicity> are initial objects used in haskell?
16:27:13 <`nand`> initial objects?
16:27:20 <johnw> as in categorically initial
16:27:22 <`nand`> you mean, in the CT sense?
16:27:26 <monadicity> yes
16:27:34 <johnw> I forget, is () initial or terminal?
16:27:36 <`nand`> I guess that would be Void ?
16:27:40 <`nand`> () is terminal
16:27:45 <`nand`> forall a. a -> () -- exists
16:27:45 <johnw> ok, then I guess Void is initial
16:27:51 <`nand`> forall a. Void -> a -- exists as well
16:28:03 <johnw> but it's not used terribly much
16:28:14 <rwbarton> oh ugh, I'm running into the TH staging restriction
16:28:27 <Fuuzetsu> @pl f x = x >>= mapM_ putStrLn
16:28:27 <lambdabot> f = (mapM_ putStrLn =<<)
16:28:38 <johnw> `nand`: does Void -> a explain why functors like [] are covariant?
16:28:50 <`nand`> TH staging gets fun when you need a cyclic graph of functions that depend on TH splices that depend on functions that ...
16:29:06 <niteria> what inhibits Void -> a?
16:29:14 <elliott> niteria: "absurd"
16:29:25 <elliott> think of it as an empty case expression
16:29:33 <niteria> apart from undefined
16:29:54 <`nand`> const undefined
16:30:12 <`nand`> (I guess that's not what you were asking for)
16:30:17 <Nereid> @let blah :: Void -> a
16:30:18 <niteria> :)
16:30:18 <lambdabot>  <local>:23:1:
16:30:18 <lambdabot>      The type signature for `blah' lacks an accompanying bindi...
16:30:19 <`nand`> it's a total function though
16:30:27 <Nereid> @let blah :: Void -> a;
16:30:28 <lambdabot>  <local>:23:1:
16:30:28 <lambdabot>      The type signature for `blah' lacks an accompanying bindi...
16:30:29 <Nereid> hmm
16:30:36 <Nereid> mmmmm
16:30:38 <Nereid> what to do.
16:30:54 <`nand`> easy
16:30:57 <`nand`> let blah = blah
16:31:09 <Nereid> @let blah :: Void -> a; blah = blah
16:31:10 <lambdabot>  <local>:23:9: Not in scope: type constructor or class `Void'
16:31:13 <Nereid> oh heh
16:32:32 <jmcarthur> johnw: newtype Initial = Initial (forall a. a); data Terminal = forall a. Terminal a  -- unfortunately we don't have existentials for newtypes
16:32:37 <Nereid> `nand`: that doesn't behave right wrt seq
16:32:51 <Nereid> blah x = blah x
16:32:52 <jmcarthur> johnw: anyway, i like those definitions because they make it clear how you can create/destroy those types
16:32:54 <Nereid> is better
16:33:12 <chrisdone> `nand`: figured out a solution yet?
16:33:25 <jmcarthur> johnw: that is, you can take an Initial and get any type out of it you want, and you can take any type you want and create a Terminal out of it
16:33:37 <`nand`> chrisdone: I gave a horrendously ugly but probably feasible approach earlier; but I won't try implementing it
16:34:10 <`nand`> which is to redirect stdout and run the actual :i in the meantime
16:34:25 <rwbarton> I have a pretty horrendous thing using TH which I'm trying to test with your code now
16:34:58 <chrisdone> :D
16:35:03 <rwbarton> how do I install the library haddock
16:35:24 <rwbarton> I seem not to have it (?)
16:35:48 <chrisdone> rwbarton: cabal install haddock==x.x.x -- where x.x.x is from haddock --version
16:36:06 * hackagebot haskell-docs 0.1.0.0 - A program to find and display the docs of a name from a  given module.  http://hackage.haskell.org/package/haskell-docs-0.1.0.0 (ChrisDone)
16:36:09 <chrisdone> (otherwise the one from hackage won't be compatible with the file versions, and probably won't built with your ghc)
16:36:15 <cmccann> man. memorizing all these lens functions is gonna take a while.
16:36:27 <edwardk> cmccann: heh
16:36:32 <rwbarton> cmccann: quiz on friday
16:36:35 <chrisdone> lol
16:36:38 <cmccann> haha
16:36:42 <edwardk> cmccann: one goal was to build a vocabulary you could grow into
16:36:45 <chrisdone> pop keeuz
16:36:50 <`nand`> rwbarton: that would be awesome
16:36:55 <`nand`> if school tests involved lens functions
16:36:56 <cmccann> yeah, I'm starting to get the hang of the patterns
16:37:19 <`nand`> cmccann: it's okay, you can leave out all of the ones that are just aliases for id
16:37:38 <cmccann> edwardk, but now that I've lured you out by complaining, is there anything that works like a filtered each? :D
16:37:45 <Fuuzetsu> @src neg
16:37:45 <lambdabot> Source not found. I feel much better now.
16:37:47 <cmccann> obviously you'd lose the ability to change the element type
16:37:47 <`nand`> filtered?
16:38:10 <edwardk> you want to filter out some of the targets?
16:38:17 <edwardk> :t filtered
16:38:19 <lambdabot> Applicative f => (a -> Bool) -> SimpleLensLike f a a
16:38:31 <cmccann> I want to leave them in the collection, but have a lens looking at them
16:38:34 <cmccann> like a multi-target at
16:38:36 <edwardk> > [1..10] ^.. each.filtered even
16:38:38 <lambdabot>   Not in scope: `each'
16:38:41 <cmccann> haha
16:38:44 <edwardk> > [1..10] ^..traverse.filtered even
16:38:46 <lambdabot>   [2,4,6,8,10]
16:38:56 <edwardk> > [1..10] & traverse.filtered even +~ 1
16:38:59 <lambdabot>   [1,3,3,5,5,7,7,9,9,11]
16:39:01 <edwardk> that last line is evil
16:39:04 <`nand`> edwardk: that's nasty
16:39:04 <mikeplus64> :t (^..)
16:39:06 <lambdabot> s -> Getting (Endo [a]) s t a b -> [a]
16:39:14 <edwardk> filtered is only 'legal' when used on folds
16:39:21 <`nand`> mikeplus64: (^..) = toListOf
16:39:24 <`nand`> or flip
16:39:26 <`nand`> flip toListOf*
16:39:29 <edwardk> or when you use it to traverse with a function that doesn't break the predicate on its targets
16:39:35 <edwardk> there i'm using it to break the predicate
16:39:57 <c_wraith> That's kinda scary
16:39:57 <rwbarton> chrisdone: oh, haddock-the-executable comes with ghc? that explains a lot. the install seems to be working
16:39:59 <edwardk> this means that subsequence invocations of the same 'filtered' traversal will miss some of the targets and violate the traversal laws
16:40:15 <cmccann> edwardk, awesome, for some reason I thought filtered worked differently
16:40:15 <edwardk> this is great if thats exactly what you want, but its something to keep in mind
16:40:39 <elliott> it's "great" :(
16:40:43 <edwardk> in head we have the safer 'whereby' clause that you can use only on indices, so you can't screw up
16:41:07 <Nereid> :t toListOf folded
16:41:08 <lambdabot> Foldable f => f b -> [b]
16:41:10 <chrisdone> rwbarton: cool =)
16:41:29 <Nereid> oh right this is done with Endo.
16:41:37 <edwardk> tables is shaping up nicely and is built rather heavily on 'evil' traversals like that one
16:41:53 <elliott> shaping up evilly
16:41:53 <cmccann> and no, I want to alter some records that are values in Data.Map
16:41:56 <edwardk> it gives my prescriptivist side (and elliott) fits, but its nice to work with
16:42:01 <cmccann> selecting based on one field, modifying another
16:42:11 <edwardk> cmccann: yeah for that filtered works fine and safely
16:42:41 <covi> Hi all. I understand the 'get' function for State monad is actually a function that is analogous to id wrapped in the monad. However, I don't understand how  st <- get  in a do block of a function can fetch the 'current state'. And what is this 'current state' anyway?
16:43:07 <cmccann> edwardk, I don't think there's any way to make a "safe" version that does that though, is there?
16:43:18 <Nereid> covi: do you know how do notation desugars?
16:43:27 <covi> Nereid: yes
16:43:45 <Nereid> ok, read the definitions for the Monad instance
16:43:54 <edwardk> cmccann: not sanely
16:43:56 <Nereid> or better yet, try coming up with them yourself ;)
16:43:56 <edwardk> >>> test & with FooId (<) 3 . rows . fooBar_ . traverse %~ toUpper
16:43:56 <edwardk> fromList [Foo {fooId = 1, fooBar = "ONE", fooBaz = 1.0},Foo {fooId = 2, fooBar = "TWO", fooBaz = 2.0},Foo {fooId = 3, fooBar = "Three", fooBaz = 3.0},Foo {fooId = 4, fooBar = "Four", fooBaz = 4.0},Foo {fooId = 5, fooBar = "Five", fooBaz = 5.0}]
16:44:01 <cmccann> even if something used two different lenses for the filtering and modifying, you could still give it the same lens twice
16:44:09 <edwardk> having the ability to do selection based on one field and editing others is quite handy
16:44:11 <catsbydlo> covi: State get is not id
16:44:33 <Nereid> modulo newtype stuff, we have get :: s -> (s,s)
16:44:52 <catsbydlo> Reader ask = id, though
16:45:19 <covi> yes, I know get :: s -> (s, s)
16:45:19 <cmccann> edwardk, I suppose you could use that stupid type inequality constraint I wrote to ensure that the type being filtered on and the one being updated differ :D
16:45:23 <Nereid> ok
16:45:26 <cmccann> that rules out legitimate uses, of course
16:45:35 <cmccann> also it would be stupid.
16:45:39 <cmccann> but still!
16:45:44 <Nereid> so get is a function that receives a state, and well
16:45:50 <catsbydlo> @src State
16:45:50 <rwbarton> isn't that sort of what whereby does?
16:45:50 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
16:45:54 <catsbydlo> @src StateT
16:45:54 <lambdabot> Source not found. My brain just exploded
16:46:01 <Nereid> @src get
16:46:01 <lambdabot> Source not found. Sorry.
16:46:06 <catsbydlo> class method
16:46:08 <edwardk> cmccann: doesn't ensure they are disjoint
16:46:17 <edwardk> i can compose through an isomorphism and edit the same field
16:46:17 <cmccann> ah, true
16:46:27 <edwardk> or edit _1 of your field, etc.
16:46:28 <cmccann> foiled again.
16:46:36 <covi> What confuses me, even in a function such as  f :: State Int  f = do { st <- get; return () }, I don't see "from where" it fetches the state
16:46:38 <Nereid> it would be so handy though.
16:46:38 <cmccann> see, I could express it easily with linear logic.
16:46:45 <Nereid> CoverSlide: it doesn't.
16:46:51 <Nereid> it builds a bigger state action
16:46:59 <edwardk> if i had the bokeh style lenses we've talked about from time to time on #haskell-lens we coul ensure some queries were disjoint
16:47:08 <edwardk> but we've found a nicer solution to most usecase anyways
16:47:12 <Nereid> which you can feed a state with runState or one of its friends.
16:47:22 <Nereid> er,
16:47:22 * cmccann should probably start idling in #haskell-lens
16:47:27 <edwardk> (and one which will make chrisdone happy, since it gives you fully polymorphic field updates)
16:47:29 <Nereid> yeah
16:47:38 <`nand`> oh wow, it took me until now to realize why edwardk was using bokeh imagery for the lens page
16:47:46 <edwardk> `nand`: heh
16:47:49 <catsbydlo> covi: State Int () is like Int -> ((), Int)
16:48:02 <catsbydlo> there's an implicit function parameter here
16:48:15 <edwardk> `nand`: just seemed arbitrary?
16:48:26 <`nand`> seemed like stock design arbitrary yeah
16:48:42 <Nereid> edwardk: now that we have prisms, you should have some diffraction patterns there too
16:49:12 <edwardk> Nereid: i need to post up the video with links to the slides, etc.
16:49:19 <Nereid> that too
16:49:46 <`nand`> use a diffracted picture of various zippers with a bokeh background
16:49:51 <Xeross> Does GHCi never complain when it can't find a module or? As I can import Asjdhbhsdbf and it returns nothing
16:50:01 <Xeross> Would expect a module not found or something
16:50:03 <`nand`> I'd tell you to throw in a profunctor, but I have no idea what a profunctor looks like
16:50:13 <Nereid> Xeross: since when? I get a "could not find module ..."
16:50:19 <catsbydlo> `nand`: it has a lmap and an rmap
16:50:31 <`nand`> right. I mean, visually :)
16:50:46 * cmccann wonders what a fresnel lens would be
16:50:51 <catsbydlo> well, like two half maps glued together, one reversed
16:51:14 <Xeross> Nereid: well I messed something up then
16:51:17 <edwardk> cmccann: had my path compression hack worked from the other day, probably something like that
16:51:27 <`nand`> Xeross: that was a bug in a particular version of GHC
16:51:29 <`nand`> 7.4.1 maybe?
16:51:30 <gwern> > foldr (\a b -> a + b a*b) 0.1 (replicate 99 0.1)
16:51:32 <lambdabot>   Occurs check: cannot construct the infinite type: t0 = t0 -> t1Occurs check...
16:51:38 <cmccann> edwardk, sounds plausible
16:51:46 <Nereid> ah I'm using 7.6.1 here
16:52:02 <`nand`> or maybe it was 7.0.x
16:52:02 <Xeross> `nand`: bingo
16:52:08 <Xeross> 7.4.1 here
16:52:13 <covi> Ah, after desugaring the do notation everything is clearer. The f function I gave as an example is actually a State monad instance.
16:52:14 <Xeross> Time to unmask a newer version then
16:52:17 <`nand`> right, you should probably upgrade to 7.4.2
16:52:33 <`nand`> mainly a bugfix release, eg. the deriving (show) stuff
16:52:41 <Nereid> that bug :)
16:53:22 <Xeross> `nand`: *nods* thanks
17:04:40 <bradleyayers> is it possible to put logic into a value constructor?
17:04:50 <shachaf> No.
17:04:53 <bradleyayers> thanks
17:04:54 <chrisdone> they're called "smart constructors"
17:04:57 <shachaf> But you can make a "smart constructor"
17:05:26 <shachaf> data Foo = Foo Int Char; foo :: Int -> Char -> Foo; foo = ...
17:05:28 <catsbydlo> "dumb function"
17:05:42 <shachaf> No, just a regular function.
17:05:52 <rwbarton> chrisdone: so, I added another "entry point" to HaskellDocs.hs so that main is just getArgs >>= doMain
17:05:54 <rwbarton> then I wrote this:
17:06:01 <catsbydlo> coDoMain?
17:06:08 <rwbarton> :def doc \n -> return $ ":set -XTemplateHaskell\n(doMain . read) $(let unpackName x = let Language.Haskell.TH.Syntax.Name (Language.Haskell.TH.Syntax.Internals.OccName s) (Language.Haskell.TH.Syntax.NameG _ (Language.Haskell.TH.Syntax.Internals.PkgName pkg) (Language.Haskell.TH.Syntax.Internals.ModName mod)) = x in [mod, s, pkg] in fmap (Language.Haskell.TH.Syntax.LitE . Language.Haskell.TH.Syntax.StringL . show . unpackName . Data.Maybe.fromMaybe (erro
17:06:09 <chrisdone> newFoo is one convention (e.g. newMVar, newIORef, newChan)
17:06:22 <rwbarton> Please don't hate me. :(
17:06:38 <chrisdone> rwbarton: lol
17:06:41 <rwbarton> but it works
17:06:47 * chrisdone pukes in his mouth a little
17:06:48 <rwbarton> *Main> :doc return
17:06:48 <rwbarton> Inject a value into the monadic type.
17:06:55 <chrisdone> wow =)
17:07:22 <chrisdone> can you hpaste the whole thing? i think the irc network cut off your message
17:07:29 <rwbarton> sure
17:07:31 <ivanm> rwbarton: wait, is that a pure TH-based haskell-docs implementation?
17:07:33 <shachaf> rwbarton: How about adding an import?
17:07:44 <rwbarton> I didn't want to mess with the user's imports
17:07:55 <rwbarton> though I am messing with -XTemplateHaskell, so...
17:07:59 <shachaf> import it qualified as RWBTH
17:08:06 <rwbarton> hmm
17:08:10 <chrisdone> ivanm: it's using the haskell-docs code. what it's doing is resolving the module so you don't have to write it yourself
17:08:27 <shachaf> I suppose you only have to get it working once.
17:08:29 <shachaf> But still.
17:08:51 <hpaste> rwbarton pasted “haskell-docs ghci atrocity” at http://hpaste.org/79856
17:08:52 <chrisdone> yeah i think if someone enables it they can accept that it will sit in the namespace, not a big deal
17:09:24 <message144> yay.. i think i finally understand currying
17:09:44 <rwbarton> and it finds imported things, too
17:09:47 <rwbarton> *Main Graphics.Gloss> :doc circle
17:09:47 <rwbarton> A circle with the given radius.
17:10:05 <byorgey> message144: +985 XP! Level up!
17:10:13 <shachaf> !list
17:10:14 <monochrom> shachaf: http://okmij.org/ftp
17:10:23 <Fuuzetsu> rwbarton: absolutely disgusting
17:10:28 <rwbarton> so for this to work it would be handy if haskell-docs produced a library implementing this "doMain" -- probably under a better name :)
17:10:31 <elliott> rwbarton: nice obfuscated code
17:10:35 <chrisdone> Fuuzetsu: disgustingly sexy
17:11:17 <ivanm> chrisdone: ahhh, bit hard to see with the cut-off
17:11:23 <message144> byorgey, my big "aha!" moment was when i read somewhere that haskell functions only actually take one argument
17:11:35 <rwbarton> see http://hpaste.org/79856 for the full, one-line glory
17:11:44 <byorgey> message144: it's true!
17:12:04 <rwbarton> btw something seems to go horribly wrong when there is no documentation
17:12:28 <byorgey> message144: and yes, that really gets at the essence of currying
17:12:40 <rwbarton> that seems to be a haskell-docs issue though
17:12:59 <chrisdone> when there's no docs it prints to stderr
17:13:13 <covi> Is the source for Parsec available?
17:13:14 <chrisdone> i think. let me check
17:13:18 <rwbarton> for me it goes into an infinite loop consuming memory
17:13:44 <chrisdone> eek
17:13:49 <chrisdone> $ haskell-docs Data.List.Split foo
17:13:49 <chrisdone> Couldn't find name ``foo'' in Haddock interface: Data.List.Split
17:13:51 <chrisdone> it should do that ^
17:14:08 <rwbarton> ah not when the name doesn't exist, but when it does exist, but doesn't have any associated documentation
17:14:23 <chrisdone> oh, what's an example? sounds like a bug
17:14:26 <rwbarton> e.g. haskell-docs Prelude '+'
17:14:34 <rwbarton> not the best example
17:14:36 <rwbarton> e.g. haskell-docs Prelude '+' base
17:14:54 <byorgey> covi: of course.  'cabal unpack parsec'
17:14:58 <rwbarton> or sin instead of '+'
17:15:14 <flebron> So, finished LYAH. Now to try to understand the categorical stuff. First off, I noticed Hask is very... peculiar. For every a, b objects in Hask, Mor_{a, b} (i.e. morphisms from a to b) is also an object in Hask. Does this property of a category have a name?
17:15:35 <chrisdone> rwbarton: hm, good catch. i'll see where that's happening
17:15:46 <byorgey> flebron: yes, 'cartesian closed'
17:16:23 <covi> flebron: Why is that morphism also an object in Hask? I thought Hask has types as objects
17:16:33 <flebron> Yes, and a -> b is a type.
17:16:37 <covi> flebron: ah, functions in Haskell is actually a type
17:16:38 <cmccann> byorgey, why not just "closed"?
17:16:40 <covi> got it
17:16:53 <catsbydlo> (->) a b
17:17:01 <catsbydlo> ((->) a) b
17:17:03 <flebron> The terminal object in Hask is unit?
17:17:20 <flebron> Hrm, no, that's the co-terminal or whatever that is named.
17:17:34 <catsbydlo> initial?
17:17:36 <rwbarton> aside from qualms involving undefined, yes
17:17:37 <cmccann> flebron, depends on whether you pretend bottom doesn't exist
17:17:48 <byorgey> cmccann: well, I suppose that's more technically correct, but Hask is in fact cartesian closed, and it's probably more useful to point flebron towards reading about CCC's than about more general monoidally closed categories
17:18:10 <flebron> I'd like to consider bottom exists, yes. So bottom is a type as well, whose only member is _|_?
17:18:12 <cmccann> byorgey, very true, I was just quibbling for no good reason
17:18:51 <catsbydlo> newtype Void = V Void
17:18:59 <cmccann> flebron, no, bottom refers collectively to the least-defined value inhabiting each lifted type
17:19:19 <catsbydlo> fix V = bottom
17:19:26 <flebron> Well, then what object would be the terminal object in Hask?
17:19:28 <cmccann> haskell doesn't have a "bottom" type in the sense that would usually mean, though arguably (forall a. a) could qualify
17:20:12 <rwbarton> if you consider bottom to exist then you have to start being really careful about what you consider to be a function
17:20:15 <chrisdone> rwbarton: ah, i think i know. seems like sin is exported in GHC.Float, and from GHC.Float it's not actually declared either, but it's somehow generated from there. so my resolver gets in an infinite loop of GHC.Float → GHC.Float → GHC.Float. i'll just make a check for this case
17:20:30 <rwbarton> oh interesting
17:20:31 <cmccann> flebron, if you include bottom values then otherwise-uninhabited types would be terminal... I guess, you're inviting headaches at that point
17:20:43 <rwbarton> I wonder if that was the case in the other example I had too, from gloss
17:20:47 <cmccann> everything is much tidier if you ignore bottom, which is why that's popular :P
17:20:47 * flebron wants the full monty
17:21:21 <rwbarton> if you define functions to be "the obvious thing" then it isn't cartesian closed any more and in general everything starts to fall apart
17:21:22 <chrisdone> rwbarton: still, sin should have docs somewhere… hm. i'll look further. takes ages to inspect the data structures involved in this stuff. not surprised no one has bothered to do this yet
17:22:02 * cmccann isn't sure about the details of just what gets how awkward if you consider _|_ seriously across the board
17:22:47 <flebron> Oh sorry, I misread Wiki, it seems clear that unit is in fact terminal :)
17:23:09 <flebron> (If you go to Wiki for terminal, it silently redirects to initial, and the first sentence of the article is the definition of initial object, not terminal :))
17:24:00 <rwbarton> "nice"
17:24:05 <`nand`> is there something like a monad without return?
17:24:15 <elliott> Bind in edwardkpackage#9428
17:24:21 <`nand`> I guess that would be a semigroup in the category of endofunctors
17:24:54 <covi> What companies might provide Haskell programmers internships?
17:26:06 <flebron> When one says "the product of X and Y", with X and Y objects in Hask, this means (a, b), correct? And the exponential map for X, Y would be X -> Y?
17:26:17 <hpaste> rwbarton annotated “haskell-docs ghci atrocity” with “haskell-docs ghci atrocity (annotation)” at http://hpaste.org/79856#a79858
17:26:38 <rwbarton> chrisdone: here's a version that doesn't require any modifications to haskell-docs -- just assumes it is in the PATH
17:27:00 <rwbarton> flebron: "product" is a general category-theoretic notion
17:27:14 <flebron> Right, but in Hask, would the product of X and Y be (X, Y)?
17:27:19 <cmccann> flebron, probably, and Either would be the "usual" coproduct
17:27:22 <rwbarton> again, with some qualms about undefined
17:27:23 <flebron> Right.
17:27:43 <rwbarton> in Haskell the product (X, Y) has an "extra" value undefined /= (undefined, undefined)
17:28:07 <cmccann> you can have as many distinct types as you want that are all isomorphic to (,) or Either
17:28:11 <flebron> (As soon as I'm done with this I'm going to mentally masturbate with that paper of "the derivative of a type is its type of one-hole contexts", coupled with zippers, between which I think I see a ridiculously cool connection)
17:29:01 <flebron> The sheer idea of calculating the derivative of a type is insanely cool haha
17:29:11 <`nand`> x -> y is y^x, mind
17:29:31 <rwbarton> chrisdone: the error messages when something goes wrong are pretty horrific. they could be fixed but that would mean even more Language.Haskell.TH.Make.It.Stop.Already
17:30:13 <shachaf> rwbarton: You could make a proper package on Hackage that exports this code.
17:30:21 <rwbarton> yeah
17:30:27 <flebron> `nand`, Ah yes, I always forget that notation :) Yes, every x goes to some y, so there's y*y*y*...*y possible funcs, with y repeated x times.
17:30:27 <rwbarton> then I could write it on more than one line! what luxury
17:30:43 <shachaf> A luxury we in #haskell don't have.
17:30:48 <flebron> (And of course we abuse this notation freely when talking about infinite sets.)
17:30:58 <mikeplus64> how bad is it to define an instance for Alternative IO based on exceptions/exception catching?
17:31:03 <chrisdone> rwbarton: ok, i pushed a fix for the infinite loop
17:31:08 <chrisdone> to git, anyway
17:31:11 <chrisdone> will push to hackage now
17:31:27 <cmccann> flebron, you might find this interesting if you haven't seen it already: http://stackoverflow.com/q/9190352/157360
17:31:28 <rwbarton> @hackage haskell-docs
17:31:28 <lambdabot> http://hackage.haskell.org/package/haskell-docs
17:32:00 <flebron> cmccann, haha that's crazy, thanks :))
17:32:21 <cmccann> flebron, the answers and comments there mention a lot of stuff you'd probably find interesting
17:32:46 <chrisdone> rwbarton: shachaf: sounds good -- we can expose this TH code in a module in haskell-docs
17:33:40 <flebron> my god he is counting binary trees purely algebraically
17:34:10 <rwbarton> whatever "Updating documentation index /home/rwbarton/.cabal/share/doc/index.html" needs to not take several minutes.
17:34:21 <rwbarton> s/needs/does needs/
17:34:31 <cmccann> flebron, wait till you get to the stuff about an isomorphism between trees and 7-tuples of trees!
17:34:35 * shachaf agrees.
17:35:00 <rwbarton> it must be quadratic time
17:35:02 <rwbarton> in something
17:35:13 <chrisdone> rwbarton: hehe, i guess that's never had a finger of optimization on it
17:35:33 <rwbarton> $ ghc-pkg list --user | wc -l
17:35:33 <rwbarton> 307
17:35:46 <rwbarton> Surely some people here have even more than that
17:36:03 <shachaf> 310
17:36:04 <chrisdone> i only have 135. that's more than usual for me since the advent of cabal-dev
17:36:05 <shachaf> I guess that counts?
17:36:07 * hackagebot haskell-docs 0.1.1.0 - A program to find and display the docs of a name from a  given module.  http://hackage.haskell.org/package/haskell-docs-0.1.1.0 (ChrisDone)
17:36:28 <c_wraith> I have so many different package directories that the starts are horribly skewed by that
17:36:47 <startling> edwardk: is there a nice way to put together a thing with lenses?
17:36:55 <elliott> rwbarton: well the idea is it encourages you to wipe all your packages regularly
17:36:58 <elliott> thus saving you problems
17:37:01 <shachaf> startling: Put together?
17:37:17 <edwardk> startling what kind of thing?
17:37:21 <ivanm> chrisdone: you still didn't fix the .cabal file for the new version :p
17:37:37 <Fuuzetsu> How can I get ghci to automatically :set the the extensions that are in a pragma in a file that I :load ?
17:37:37 <chrisdone> ivanm: lol i noticed, knew you'd mention it :p
17:37:43 <ivanm> heh
17:37:45 <tomsthumb> is reverse lazy?  trying to do reverse [2..LARGE] and want to know if it's taking forever to revves the list
17:37:52 <ivanm> Fuuzetsu: don't think you can
17:37:58 <ivanm> you can specify them in a .ghci file though
17:38:04 <ivanm> either a per-user or a per-project one
17:38:09 <ivanm> @where lazy-reverse
17:38:09 <lambdabot> I know nothing about lazy-reverse.
17:38:15 <ivanm> @where hack
17:38:15 <lambdabot> I know nothing about hack.
17:38:16 <startling> data X = X { _a :: Char, _b :: Char, _c :: Char }; makeLenses ''X; can I make an X given those lenses and three characters?
17:38:17 <chrisdone> Fuuzetsu: you mean with {-# LANGUAGE … #-} or {-# OPTIONS -X… #-}?
17:38:24 <Fuuzetsu> LANGUAGE
17:38:30 <startling> that is, I don't want to use the constructor.
17:38:31 <ivanm> bah, wasn't there some really lazy reverse in @where?
17:38:33 <edwardk> tomsthumb: reverse isn't as lazy as it could be but its about as efficient as it can be
17:38:48 <edwardk> you can make the spine a little lazier
17:39:02 <Fuuzetsu> Uhh ignore me
17:39:02 <shachaf> edwardk: Arguably that definition isn't correct.
17:39:12 <Fuuzetsu> I forgot the # in {-#
17:39:21 <ivanm> Fuuzetsu: heh
17:39:22 <chrisdone> ʘ‿ʘ
17:39:24 <Fuuzetsu> now it just werks (TM)
17:39:36 <shachaf> Should reverse (1:2:⊥) be (⊥:⊥:⊥) or ⊥?
17:39:53 <chrisdone> @src reverse
17:39:54 <lambdabot> reverse = foldl (flip (:)) []
17:40:56 <tomsthumb> so  if i do 'head [2..LARGE]' does it expand the entire list befoer getting the first element
17:40:57 <tomsthumb> ?
17:41:28 <tomsthumb> it's actually a list comprehenstion with a few conditions on it, but it should be the same methinks
17:41:35 <rwbarton> head? no
17:41:44 <tomsthumb> mm, didn't think so
17:41:50 <Fuuzetsu> :t (-<)
17:41:55 <lambdabot>     Not in scope: `-<'
17:41:55 <lambdabot>     Perhaps you meant one of these:
17:41:55 <lambdabot>       `<' (imported from Data.Ord), `-' (imported from Prelude),
17:42:57 <byorgey> tomsthumb: yes, it's the same with a list comprehension
17:43:18 <byorgey> tomsthumb: if you call head on it, it will only do just enough work to find the first element that satisfies the conditions
17:43:18 <ivanm> @hoogle (-<)
17:43:19 <lambdabot> keyword -<
17:43:19 <lambdabot> keyword -<<
17:43:25 <`nand`> shachaf: my intuition says ⊥
17:43:43 <rwbarton> those results are more useful if you do the search on the Hoogle web interface
17:44:05 <beaky> > let in [1..10]>>=show
17:44:08 <lambdabot>   "12345678910"
17:44:10 <`nand`> because ⊥:⊥:⊥ is not the same as ⊥ ++ [2,1]
17:45:05 <r00723r0> Is using `read` bad practice?
17:45:06 <`nand`> chrisdone: src/Main.hs:177:7: Not in scope: data constructor `DocURL'
17:45:11 <`nand`> r00723r0: depends on what for
17:45:16 <r00723r0> `nand`: not writing a REPL?
17:45:29 <r00723r0> What purpose can read be used for?
17:45:44 <r00723r0> Also what do backticks mean around functions?
17:45:52 <chrisdone> `nand`: did you install with the haddock constraint as written here? http://hackage.haskell.org/package/haskell-docs
17:45:54 <startling> r00723r0: makes them infix
17:46:07 <startling> > 8 `div` 4
17:46:09 <r00723r0> Gotcha.
17:46:09 <lambdabot>   2
17:46:12 <startling> > div 8 4
17:46:14 <lambdabot>   2
17:46:16 <rwbarton> > read "17" :: Int
17:46:17 <lambdabot>   17
17:46:33 <r00723r0> What is a valid purpose for `read`?
17:46:49 <chrisdone> convenience/prototyping, really
17:46:54 <`nand`> chrisdone: oh, no
17:46:57 <chrisdone> anything else is a hack
17:47:15 <Philippa> feeding your Showed output back in
17:47:17 <`nand`> r00723r0: well, what might still be acceptable is reading something you show'd yourself, I guess
17:47:23 <`nand`> but there might be something better for that
17:47:28 <`nand`> eg. going through a bytestring
17:47:40 <chrisdone> > read "12e1000000000000" :: Integer
17:47:41 <r00723r0> Are Chars Unicode?
17:47:42 <lambdabot>   *Exception: Prelude.read: no parse
17:47:47 <rwbarton> if you wrote a Parsec parser for a string of digits, converting that string to an integer
17:47:49 <chrisdone> ah they fixed that one =)
17:47:51 <`nand`> r00723r0: yes
17:47:51 <startling> r00723r0: yes.
17:47:52 <elliott> r00723r0: unicode codepoints, yes
17:47:54 <r00723r0> Oh, thank god.
17:47:57 <elliott> not unicode characters
17:47:59 <startling> haha
17:48:19 <tomsthumb> is there an obvious reason this would take up massive amounts of memory when run:  http://pastebin.com/EMgQNk7N
17:48:21 <tomsthumb> ?
17:48:35 <tomsthumb> ohhhh snap
17:48:35 <rwbarton> yes
17:48:37 <tomsthumb> nvm
17:48:43 <`nand`> r00723r0: be aware of readMaybe :: Read a => String -> Maybe a -- which won't crash your program if something goes wrong
17:48:59 <`nand`> so if you're attempting to parse something that's user-facing, you could use that for simple stuff I guess
17:49:00 <ivanm> great, I made my code use Data.Vector.Generic because I figured I might as well allow the end-user to choose which type of vector they want to use
17:49:18 <startling> tomsthumb: use "null factors", not length factors == 0
17:49:20 <ivanm> only to find that I can't actually write the class instance I need for the same reason Set isn't an instance of Functor :s
17:49:25 <chrisdone> `nand`: does it compile with that version?
17:49:37 <tomsthumb> startling: ahh, ty
17:49:56 <ivanm> tomsthumb: also, it looks rather strange to reverse a list you've just constructed via Enum
17:49:56 <startling> tomsthumb: "length" traverses the whole list to find the length, "null" just compares it to [].
17:50:08 <startling> ^^ that too
17:50:14 <rwbarton> that is the actual problem yes
17:50:19 <ivanm> `enumFromThenTo (num - 1) (num - 2) 2' vs 'reverse [2..(num-1)]'
17:50:26 <tomsthumb> startling: so, as soon as it finds there is an element in the comprehension it will stop?
17:50:33 <startling> tomsthumb: yeah.
17:50:36 <`nand`> startling: | null factors = True | otherwise = False -- also reduces to just ‘null factors’
17:50:39 <tomsthumb> startling: sweeeett
17:50:42 <`nand`> cc tomsthumb
17:50:50 <rwbarton> or [num-1, num-2 .. 2]
17:50:56 <tomsthumb> `nand`:  baller
17:50:57 <startling> `nand`: also a good point
17:51:09 <chrisdone> it's amazing how many languages don't have a sane Show/Read-like derivable class
17:51:33 <latermuse> is there a library which can clean/sanitize user input for display on an html website?
17:51:56 <chrisdone> yeah on hackage there is an anti-xss package, something sanitize
17:51:58 <ivanm> chrisdone: on the other hand, it's amazing how many people abuse Show for pretty-printing...
17:52:18 <startling> there should be a pretty-print class too. >:(
17:52:25 <ivanm> startling: there are quite a few available
17:52:35 <ivanm> depends on which pretty-printing library you want to use
17:52:46 <chrisdone> ivanm: yeah, though they feel the limits of that and learn eventually. having the option with some abuse is far better than not at all
17:52:58 * ivanm personally prefers writing a custom pretty-printing class as needed, as different types are pretty-printed differently depending on the circumstances
17:53:01 <startling> yeah? I haven't looked into it much. it'd be cool if it could be automically derived, too
17:53:04 <ivanm> chrisdone: true
17:53:13 <r00723r0> reverse [2..(num - 1)]
17:53:20 <chrisdone> i abused read/show in fay for automatic serialization of data types for a while
17:53:25 <r00723r0> reverse [2..(num - 1)]
17:53:31 <r00723r0> Does that create the list, then reverse it?
17:53:32 <ivanm> startling: pretty-class is for the pretty package; the wl-pprint-based packages have the class as well
17:53:36 <chrisdone> now i'm using data/typeable more
17:53:37 <ivanm> r00723r0: yes
17:53:50 <r00723r0> ivanm: so that's bad, right?
17:53:52 <startling> ivanm: oh cool
17:54:03 <r00723r0> Should be [-1,2..(num-1)]?
17:54:07 <ivanm> r00723r0: in this case, yeah
17:54:22 <r00723r0> > [-1,2..(num-1)]
17:54:23 <ivanm> r00723r0: that will give you [-1,2,5,8,...]
17:54:24 <lambdabot>   Not in scope: `num'
17:54:25 <lambdabot>  Perhaps you meant one of these:
17:54:25 <lambdabot>    `sum' (imported fro...
17:54:32 <r00723r0> > [-1,2..5]
17:54:34 <lambdabot>   [-1,2,5]
17:54:45 <r00723r0> > [-1,5..2]
17:54:47 <lambdabot>   [-1]
17:54:47 <ivanm> here, you want [num-1,num-2..2]
17:54:53 <byorgey> > [5,4 .. 1]
17:54:55 <lambdabot>   [5,4,3,2,1]
17:54:56 <ivanm> > [10,9..2]
17:54:57 <rwbarton> it just ... makes an arithmetic sequence that goes through the numbers you specify
17:54:58 <lambdabot>   [10,9,8,7,6,5,4,3,2]
17:55:08 <rwbarton> it's not some random step first last thing
17:55:11 <r00723r0> Oh, so you say the start, the second, and the last.
17:55:21 <ivanm> even though I would personally prefer a "step" value rather than a "next" value
17:55:23 <r00723r0> > [-1, -2..3]
17:55:24 <lambdabot>   []
17:55:29 <r00723r0> > [-1, 0..3]
17:55:31 <ivanm> r00723r0: optional second and optional last
17:55:31 <lambdabot>   [-1,0,1,2,3]
17:55:36 <ivanm> @src Enum
17:55:36 <lambdabot> class  Enum a   where
17:55:36 <lambdabot>     succ                     :: a -> a
17:55:36 <lambdabot>     pred                     :: a -> a
17:55:36 <lambdabot>     toEnum                   :: Int -> a
17:55:36 <lambdabot>     fromEnum                 :: a -> Int
17:55:38 <lambdabot> [3 @more lines]
17:55:52 <r00723r0> > [-3,..]
17:55:54 <lambdabot>   <hint>:1:5: parse error on input `..'
17:55:56 <monadicity> > [2,2+5..]
17:55:59 <lambdabot>   [2,7,12,17,22,27,32,37,42,47,52,57,62,67,72,77,82,87,92,97,102,107,112,117,...
17:56:06 <ivanm> r00723r0: ^^ it's just syntactic sugar for the Enum list-based functions
17:56:19 <r00723r0> ivanm: can you translate for me?
17:56:23 <ivanm> > [-3..]
17:56:24 <lambdabot>   [-3,-2,-1,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,...
17:56:32 <ivanm> @src Enum
17:56:32 <lambdabot> class  Enum a   where
17:56:32 <lambdabot>     succ                     :: a -> a
17:56:32 <lambdabot>     pred                     :: a -> a
17:56:32 <lambdabot>     toEnum                   :: Int -> a
17:56:32 <lambdabot>     fromEnum                 :: a -> Int
17:56:33 <ivanm> @more
17:56:34 <lambdabot> [3 @more lines]
17:56:36 <ivanm> @more
17:56:36 <lambdabot>     enumFrom                 :: a -> [a]
17:56:38 <lambdabot>     enumFromThen, enumFromTo :: a -> a -> [a]
17:56:38 <r00723r0> [-3,0..]
17:56:40 <lambdabot>     enumFromThenTo           :: a -> a -> a -> [a]
17:56:41 <r00723r0> > [-3,0..]
17:56:43 <lambdabot>   [-3,0,3,6,9,12,15,18,21,24,27,30,33,36,39,42,45,48,51,54,57,60,63,66,69,72,...
17:56:46 <ivanm> r00723r0: enumFrom x == [x..]
17:56:55 <r00723r0> I see.
17:56:57 <ivanm> enumFromThenTo a b c == [a,b..c]
17:59:22 <r00723r0> So types have certain functional interfaces.
17:59:38 <r00723r0> Can the interface be implicit or does that not make sense?
18:01:11 <`nand`> I'm not sure what you mean by ‘functional interfaces’, or types having them; are you talking about typeclasses?
18:02:38 <r00723r0> `nand`: I don't know.
18:02:48 <r00723r0> What makes types different from each other?
18:03:21 <`nand`> having different definitions?
18:05:22 <`nand`> (though I guess that's not sufficient, considering type aliases.)
18:07:48 <latermuse> > [1.1,1.2..10]
18:07:50 <lambdabot>   [1.1,1.2,1.2999999999999998,1.3999999999999997,1.4999999999999996,1.5999999...
18:07:55 <latermuse> meh
18:08:14 <`nand`> > [1.1, 1.2 .. 10] :: [CReal]
18:08:16 <lambdabot>   [1.1,1.2,1.3,1.4,1.5,1.6,1.7,1.8,1.9,2.0,2.1,2.2,2.3,2.4,2.5,2.6,2.7,2.8,2....
18:08:53 <latermuse> I see..
18:09:10 <latermuse> >[1.0001, 1.0002 .. 10] :: [CReal]
18:09:21 <latermuse> > [1.0001, 1.0002 .. 10] :: [CReal]
18:09:24 <lambdabot>   [1.0001,1.0002,1.0003,1.0004,1.0005,1.0006,1.0007,1.0008,1.0009,1.001,1.001...
18:09:35 <latermuse> nice... I have to install that CReal library
18:10:51 <`nand`> it's in package numbers
18:11:01 <`nand`> > [1.1, 1.2 .. 10] :: [Rational]
18:11:03 <lambdabot>   [11 % 10,6 % 5,13 % 10,7 % 5,3 % 2,8 % 5,17 % 10,9 % 5,19 % 10,2 % 1,21 % 1...
18:11:08 * hackagebot heist 0.10.2 - An Haskell template system supporting both HTML5 and XML.  http://hackage.haskell.org/package/heist-0.10.2 (DougBeardsley)
18:12:09 <biscarch> ls
18:12:24 <biscarch> whoops, sorry
18:14:17 <covi> What do reads and readsPrec do?
18:14:44 <`nand`> ‘reads’ gives you a list of all possible interpretations; and Prec has to do with the precedence
18:14:57 <byorgey> :t reads
18:14:59 <lambdabot> Read a => ReadS a
18:15:19 <`nand`> ReadS a = String -> [(a, String)]
18:15:27 <covi> > reads "1 2 3"
18:15:29 <lambdabot>   []
18:15:33 <`nand`> reads = readsPrec 0
18:15:36 <covi> > reads "+ 1 2 3"
18:15:38 <lambdabot>   []
18:15:39 <rwbarton> > readsPrec 10 "Just 3" :: [(Maybe Integer, String)]
18:15:41 <lambdabot>   [(Just 3,"")]
18:15:43 <rwbarton> > readsPrec 9 "Just 3" :: [(Maybe Integer, String)]
18:15:44 <lambdabot>   [(Just 3,"")]
18:15:55 <r00723r0> Maybe?
18:15:56 <aavogt> > reads "1 2 3" :: [(Int, String)]
18:15:56 <rwbarton> > readsPrec (-1) "Just 3" :: [(Maybe Integer, String)]
18:15:58 <lambdabot>   [(1," 2 3")]
18:15:59 <lambdabot>   can't find file: L.hs
18:16:00 <r00723r0> What else can it be?
18:16:01 <rwbarton> > readsPrec (-1) "Just 3" :: [(Maybe Integer, String)]
18:16:02 <lambdabot>   [(Just 3,"")]
18:16:07 <rwbarton> > readsPrec 11 "Just 3" :: [(Maybe Integer, String)]
18:16:09 <lambdabot>  Terminated
18:16:11 <covi> > reads "1"
18:16:13 <lambdabot>   []
18:16:15 <rwbarton> > readsPrec 11 "Just 3" :: [(Maybe Integer, String)]
18:16:16 <lambdabot>   []
18:16:19 <rwbarton> there we go
18:16:31 <byorgey> covi: you have to specify a type, otherwise it is defaulting to ()
18:16:38 <byorgey> > reads "()"
18:16:40 <lambdabot>   [((),"")]
18:16:44 <rwbarton> if we are parsing "X Just 3", then X will be consumed, and the rest will be parsed with readsPrec 11
18:16:59 <`nand`> man, has anything good ever come out of defaulting to () ?
18:17:19 <covi> byorgey: got it, thanks
18:17:21 <`nand`> I think I'd rather have an ambiguous type error than a silent default to ()
18:17:27 <byorgey> `nand`: impressing noobs with impossible quickcheck properties that are nonetheless true?
18:17:28 <rwbarton> but if we are parsing "2 :+ Just 3", then after 2 :+ is consumed, the rest will be parsed with readsPrec p where p depends on the precedence of :+
18:17:51 <byorgey> @check \xs -> xs == reverse xs   -- all lists are palindromes!
18:17:53 <lambdabot>   Not in scope: `myquickcheck'
18:17:56 <byorgey> aww
18:18:07 <`nand`> byorgey: ah, heh
18:18:11 <rwbarton> `nand`: not being able to display [] in ghci would be annoying
18:18:19 <`nand`> rwbarton: yeah that makes sense
18:18:32 <rwbarton> but still... the () default can cause a lot of trouble
18:19:23 <byorgey> rwbarton: I don't think defaulting to () has anything to do with displaying []
18:19:35 <`nand`> > show (read "()")
18:19:37 <lambdabot>   "()"
18:19:44 <byorgey> if you type [] at the ghci prompt and then say   :type it   you get  [a]
18:19:52 <rwbarton> well it needs to be able to default (Show a) to something
18:19:53 <rwbarton> > []
18:19:55 <lambdabot>   []
18:19:58 <rwbarton> > [] :: String
18:20:00 <lambdabot>   ""
18:20:13 <byorgey> oh, hmm
18:20:17 <elliott> I think it defaults to [()] in GHCi
18:20:22 <elliott> but I think it defaults to [Any] in GHC
18:20:27 <`nand`> Any?
18:20:32 <elliott> Any
18:20:41 <`nand`> oh, that Any
18:20:45 <c_wraith> Any is GHC's equivalent of void *
18:20:50 <byorgey> Any is a concrete type which can be used to stand in for unconstrained type variables
18:20:55 <byorgey> since by parametricity it doesn't matter
18:21:12 <elliott> except in this case it does matter I guess
18:21:23 <elliott> of course I could actually check whether "main = print []" compiles
18:21:24 <byorgey> well, the type variable isn't unconstrained
18:21:29 <rwbarton> my guess is no
18:21:34 <byorgey> it has a Show constraint
18:21:46 <rwbarton> "No instance for (Show a)" will be your error
18:21:52 <`nand`> rwbarton is right
18:21:58 <elliott> rwbarton: yeah
18:22:03 <elliott> hm isn't there a specific error for ambiguous instances
18:22:10 <`nand`> there is
18:22:15 <`nand`>     The type variable `a0' is ambiguous
18:22:28 <`nand`> just after “No instance for (Show a0) arising from a use of `print'”
18:22:52 <`nand`> (even with an ambiguous type variable, you can have an instance Show a where ...)
18:22:55 <rwbarton> right
18:23:39 <rwbarton> if there was a single "Show a" instance, then we would be okay by parametricity again -- that's why the error message has that form
18:25:12 <rwbarton> hmm
18:25:30 <rwbarton> I feel like it could maybe make sense to default (Show a) when it is the *only* constraint
18:26:43 * applicative thinks, Oh man, 80 reddit comments on the haskell tabs-v-spaces debate; no way I'm looking at that....
18:26:54 <cmccann> applicative, good plan
18:27:53 <`nand`> what's the big deal? just use 2 or 4 spaces according to preferences
18:29:23 <cmccann> clearly the best option is to alternate spaces and tabs, and set your code editor's font to Comic Sans MS
18:29:24 <r00723r0> applicative: link?
18:32:25 <cmccann> applicative, the summary is that almost everyone uses spaces in Haskell but they still manage to disagree over WHY they use spaces, and that there's a correct way to mix tabs and spaces that you can't use because other people will screw it up
18:32:33 <cmccann> and also some people still don't like syntactic whitespace
18:32:41 <cmccann> I think that covers most of the comment threads
18:33:51 <`nand`> I don't see much of a difference between using tabs and spaces, if your editor renders them the way GHC parses them
18:34:08 <cmccann> which roughly nobody's editor does
18:34:12 <covi> @src null
18:34:12 <lambdabot> null []     = True
18:34:12 <lambdabot> null (_:_)  = False
18:34:13 <`nand`> mine does
18:34:20 <`nand`> it did so by default, even
18:34:50 <`nand`> I think the problem comes down to people's editors diverging from what GHC thinks tab characters are. spaces solve this issue
18:36:13 <parcs> the obvious solution is to use explicit layout
18:37:02 <covi> Can someone point me to an example use of continuation monad?
18:37:03 <cmccann> layout cares about alignment, as far as I'm concerned it's not indentation, it's ASCII art
18:37:05 <`nand`> converting from tabs to spaces is a minor and (with a sufficiently smart editor) functionally transparent thing
18:37:13 <`nand`> changing the language syntax is a much greater effort
18:37:28 <`nand`> (or rewriting the program to use explicit layout, for that matter)
18:38:23 <cmccann> just use explicit layout and no whitespace beyond what's needed to separate tokens.
18:38:25 <cmccann> problem solved!
18:38:32 <`nand`> cmccann: there is a case in which indentation depth itself can change the way haskell parses
18:38:44 <`nand`> well
18:38:44 <elliott> cmccann: do you ever *need* whitespace?
18:38:47 <`nand`> that's also about alignment
18:39:00 <`nand`> elliott: I don't think so
18:39:02 <cmccann> elliott, iffoothenbarelsebaz?
18:39:11 <cmccann> you could use parens or something I suppose.
18:39:12 <`nand`> if(foo)then(bar)else(baz)
18:39:14 <parcs> covi: the continuation monad is often used for (but not limited to) callCC, which can simulate the 'break' and 'continue' statements of other languages
18:39:24 <Jafet> importControlLens
18:39:31 <Jafet> (that's a keyword)
18:39:36 <`nand`> there wer go
18:39:38 <`nand`> we*
18:39:41 <parcs> covi: callCC can also be used to simulate labels & goto
18:40:13 <`nand`> module Prelude (module Control.Lens) where
18:41:02 <covi> parcs: is there any tutorial that you recommend? I don't fully understand the continuation concept yet.
18:41:21 <mikeplus64> if i have something like "let b = True; f x = if b then foo else bar in seq f (forever (f y))", will that if-then-else be done every time or will that part be evaluated by seq?
18:42:05 <applicative> r00723r0: http://www.reddit.com/r/haskell/comments/15gz8q/a_nondirty_shot_at_tabs_vs_spaces/ I'm sticking with cmcann's precis, myself...
18:42:13 <cmccann> wise.
18:42:16 <applicative> cmccann rather
18:42:35 <Peaker> I just really wish I could go back in time and uninvent \t
18:42:36 <byorgey> mikeplus64: seq will have no effect there.
18:42:38 <parcs> covi: but aside from callCC, the continuation monad is useful for attaching 'finalizers' to monadic actions, similar to how eg 'withFile "foo" ReadMode action' makes sure that the file gets closed after the action finishes
18:42:58 <byorgey> mikeplus64: whether the if-ithen-else is done every time depends on whether it is optimized away by the compiler.
18:43:22 <byorgey> mikeplus64: in particular, seq has no effect since f is already in weak head normal form
18:43:33 <byorgey> since it is a lambda.
18:43:46 <parcs> covi: i tried tons of tutorials and none of them helped, so instead i spent months staring at the definition of Cont, callCC and its Monad instance and until i fully understood it
18:44:00 <Jafet> @quote boundless
18:44:00 <lambdabot> Kukkua says: They say there are two things, once mastered, you will harness boundless strength from the cosmos itself, continuations and monads.
18:44:05 <covi> parcs: lol, maybe I should do the same thing
18:45:17 <`nand`> Cont clicked for me when I learned about the yoneda lemma
18:45:21 <cmccann> understanding how the continuation monad works is much easier than understanding how to actually do anything meaningful with callCC...
18:45:31 <`nand`> ^
18:45:37 <`nand`> by Cont I mean Cont the type, not callCC
18:45:51 <`nand`> I've never worked with callCC, too many sets of parentheses for me to want to look at
18:45:55 <cmccann> I can CPS things all day and not break a sweat but callCC gives me a splitting headache after about ten minutes of thinking about it
18:46:08 <cmccann> and that's on a good day
18:46:10 <mikeplus64> byorgey: what's the "best" way of "optimizing" functions like that? in particular i'm thinking of the graphics loop for a game engine, where i don't really want to have if isEnabled someFeature then ... else ... on every frame
18:46:10 <latermuse> foldl is just a function which can operate on the list monoid, correct?
18:46:14 <covi> cmccann: how do you learn CPS
18:46:22 <`nand`> yoneda lemma
18:46:30 <byorgey> mikeplus64: I don't know.
18:46:38 <applicative> covi, it's just a question of having a sufficiently twisted mind.
18:46:41 <`nand`> a ~ forall b. (a -> b) -> b
18:46:47 <applicative> covi http://blog.sigfpe.com/2011/10/quick-and-dirty-reinversion-of-control.html
18:46:59 <parcs> covi: before going down that path try reading http://en.wikibooks.org/wiki/Haskell/Continuation_passing_style and http://www.haskell.org/haskellwiki/MonadCont_under_the_hood
18:47:09 <Peaker> mikeplus64, maybe you can just precompute those if's outside the loop?
18:47:13 <r00723r0> Are there IIFEs in Haskell?
18:47:26 <Jafet> mikeplus: is that the slowest part of the program?
18:47:27 <ssl_> hello! diving into Haskell for the first time - just wanted to say hi!
18:47:27 <parcs> callCC is so trivial, even djinn can implement it
18:47:35 <byorgey> latermuse: I don't understand your question
18:47:40 <byorgey> ssl_: hello, and welcome!
18:48:03 <Peaker> latermuse, foldl doesn't use any Monoid instance
18:48:07 <`nand`> latermuse: foldl operates on lists so that's pretty trivially true
18:48:26 <Peaker> latermuse, better to say "list" than "The list monoid" if the Monoid instance is not involved :)
18:48:37 <latermuse> Peaker: I was under the impression 'monoid instances' arent a pre-requisite to using monoids.
18:48:42 <mikeplus64> Peaker: yeah, but i'm unsure of how to do that with functions
18:48:50 <Jafet> :t foldmap
18:48:51 <lambdabot>     Not in scope: `foldmap'
18:48:51 <lambdabot>     Perhaps you meant one of these:
18:48:51 <lambdabot>       `foldMap' (imported from Data.Foldable),
18:48:52 <Jafet> :t foldMap
18:48:52 <r00723r0> Anyone?
18:48:53 <lambdabot> (Foldable t, Monoid m) => (a -> m) -> t a -> m
18:48:54 <`nand`> foldl doesn't even use the list monoid's operations
18:48:55 <latermuse> Peaker: When would you use a 'monoid instance' explicitly?
18:48:56 <cmccann> r00723r0, I'm not sure that even makes sense in Haskell
18:48:59 <`nand`> regardless of Monoid
18:49:07 <cmccann> r00723r0, what do you expect it to do?
18:49:10 <Peaker> latermuse, when you use mappend/etc on the value?
18:49:17 <r00723r0> cmccann: just curious.
18:49:19 <latermuse> Peaker: Ahh! Gotcha.
18:49:22 <Peaker> mikeplus64, concrete example?
18:49:28 <latermuse> Peaker: I think that answers my question. Thanks peaker.
18:49:57 <`nand`> latermuse: no, a monoid instance isn't a pre-requisite to using a monoid; For example, I can evaluate 2+3 in which I use addition of integers, which forms a perfectly fine monoid
18:50:24 <latermuse> `nand`: Then what is the purpose of explicitly using the monoid type?
18:50:34 <felipe_Brz> i know mentioning php is something like a deadly sin but there is a feature i can't remember seeing anywhere else and I would like to if haskell (or any other language for that matter) has an elegant way of doing this... i mean setting a variable with another variables value... $foo = "bar";$bar="baz"; echo $$foo; //prints "baz"
18:50:38 <`nand`> latermuse: when things start getting polymorphic
18:50:39 <cmccann> r00723r0, I don't think that idiom really has any counterpart in Haskell, in that everything it offers is probably either irrelevant or easy
18:50:40 <parcs> :t let callCC f = ContT $ \k -> runContT (f (\a -> ContT $ \_ -> k a)) k in callCC
18:50:42 <lambdabot> ((a -> ContT r m a1) -> ContT r m a) -> ContT r m a
18:50:58 <`nand`> then it's useful to talk about ‘monoids’
18:51:10 <mikeplus64> Peaker: forever $ if fixed_function_interface then ... else if glsl then ... else if assembly then ... else ...
18:51:11 <latermuse> felipe_Brz: haskell doesnt use variables like php
18:51:12 <bos> @pl \(a,b) (c,d) -> (c,b+d)
18:51:13 <lambdabot> (`ap` snd) . (. fst) . flip ((.) . (,)) . (+) . snd
18:51:17 <bos> eeeeeeeeeee
18:51:27 <Jafet> felipe: let myphp :: Map String PHPValue
18:51:37 <bpalmer>  felipe_Brz: other languages support that, but there are often better designs for it
18:51:55 <latermuse> `nand`: do you have any quick examples of when things start getting polymorphic, necesitating the explicit usage of the monoid type?
18:51:55 <felipe_Brz> bpalmer:  could you give some examples?
18:52:18 <`nand`> latermuse: well, I meant the term monoid; not the type
18:52:47 <bpalmer> felipe_Brz: often, the better design is using an explicit map and passing around a key to that map
18:53:09 <`nand`> latermuse: but for example, ‘foldMap folds a list containing monoids’ is a perfectly valid assessment of what ‘foldMap’ does
18:53:39 <latermuse> `nand`: Ah, that makes perfect sense.
18:53:51 <Peaker> mikeplus64, the "if" will just happen once then
18:54:01 <latermuse> `nand`: And I can see it in the type declaration for foldMap: foldMap :: (Foldable t, Monoid m) => (a -> m) -> t a -> m
18:54:07 <Peaker> mikeplus64, since it is pure, and will compute a final argument to "forever"
18:54:09 <`nand`> latermuse: in fact, you could say that ‘foldMap is a monoid homomorphism from lists’
18:54:16 <Peaker> mikeplus64, so every iteration shouldn't repeat the "if"s
18:54:55 <`nand`> latermuse: the question is whether or not something being a monoid is an interesting property; that's not something that can be formally answered
18:55:06 <mikeplus64> Peaker: ok, i'll try test it
18:55:55 <parcs> @djinn ((a -> (b -> r) -> r) -> (a -> r) -> r) -> (a -> r) -> r
18:55:55 <lambdabot> f a b = a (\ c _ -> b c) b
18:55:58 <latermuse> `nand`: So monoids are just the 'bread and butter', and arent anything special?
18:56:01 <hpaste> beefcube pasted “understanding get for State monads” at http://hpaste.org/79859
18:56:10 <`nand`> I have no idea what that means
18:56:46 <`nand`> latermuse: this was about mentioning or not mentioning a property of something if it's irrelevant to the context (or: uninteresting)
18:56:54 <cmccann> `nand`, monoids are useful, therefore a being a monoid is usually interesting, so something being a monoid not being an interesting fact is an interesting fact
18:57:04 <beefcube> can someone explain why 'get' returns what I believe to be a non-tuple, when in conjunction with <- it seems to return a function?
18:57:08 <cmccann> therefore being a monoid is always interesting, QED
18:57:21 <beefcube> a non-tuple, as in a single term, non-function
18:57:21 <Peaker> wow, ekg is truly awesome. It just worked, as advertised.
18:57:32 <`nand`> cmccann: sure, and every natural number is interesting because if it weren't it would be the only natural number that isn't interesting, an interesting property
18:57:48 <cmccann> `nand`, indeed. the logic is flawless.
18:57:53 <latermuse> That goes back to the 'bread and butter' example.
18:58:04 <latermuse> Everyone needs 'bread and butter', and its not explicitly interesting.
18:58:22 <`nand`> ‘interesting’ is contextual
18:58:51 <parcs> `nand`: what is the relationship between Cont and the yoneda lemma?
18:59:00 <cmccann> how interesting bread and butter is depends on how hungry you happen to be at the time!
18:59:08 <latermuse> yes
18:59:24 <latermuse> so, could you say that monoids are the building blocks of functional programming?
18:59:27 <`nand`> parcs: Cont/CPS is about observing an equivalence forall b. (a -> b) -> b ~ a
18:59:54 <`nand`> parcs: the yoneda lemma is a genearlization of this; about Functor f => forall b. (a -> b) -> f b ~ f a
19:00:07 <Jafet> :t get
19:00:08 <lambdabot> MonadState s m => m s
19:00:20 * rwbarton would go out on a limb and suggest that functions are the building blocks of functional programming
19:00:24 <`nand`> parcs: so Cont ~ Yoneda Identity
19:00:27 <Jafet> > do { put 5; x <- get; return x }
19:00:29 <lambdabot>   No instance for (GHC.Show.Show (m0 b0))
19:00:30 <lambdabot>    arising from a use of `M44908040...
19:00:33 <parcs> `nand`: oh, i see
19:00:39 <Jafet> > do { put 5; x <- get; return x } `runState` undefined
19:00:41 <lambdabot>   (5,5)
19:00:52 <latermuse> rwbarton: functions need something to act on though
19:01:01 <cmccann> do they really?
19:01:02 <`nand`> latermuse: other functions!
19:01:03 <sclv> other functions
19:01:08 <cmccann> lambda, the ultimate building block
19:01:10 <latermuse> oh you guys ;)
19:01:15 <latermuse> <3
19:01:17 <`nand`> (we're being serious, by the way)
19:01:22 <hpaste> “Ryan Eagle Scam” pasted “EWA Scam” at http://hpaste.org/79860
19:01:26 <`nand`> the lambda calculus has nothing but functions
19:01:51 <`nand`> every value is a function from a function to another function; T ≅ T → T
19:01:56 <cmccann> amusingly enough, you represent data using functions via church encoding, which is related to CPS transform
19:02:07 <`nand`> and that brings us full circle
19:02:18 <cmccann> :D
19:02:21 <beefcube> Jafet: the definition for get feels like it contradicts what I've seen in it's usage examples
19:02:46 <beefcube> Jafet: get = State $ \s -> (s, s) ?
19:02:54 <`nand`> `M44908040 <- ???
19:03:24 <monochrom> hint filenames
19:03:27 <parcs> what's contradictory about that?
19:03:31 <rwbarton> if you could just see the rest of the module name, it would make perfect sense
19:04:05 <mikeplus64> Peaker: a simpleish case like "let run = if unsafePerformIO readLn then putStrLn "great" else putStrLn "good" in forever run" seems to work; i only have to input one line
19:04:16 <mikeplus64> but that could be an unsafePerformIO quirk too
19:04:18 <Jafet> Regardless of the definition, get gets.
19:04:27 <beefcube> 0_o
19:04:42 <cmccann> :t get gets
19:04:44 <lambdabot> (MonadState s1 m, MonadState s ((->) ((s1 -> a) -> m a))) => s
19:04:47 <cmccann> mystery solved!
19:04:51 <parcs> :t gets get
19:04:52 <lambdabot> (MonadState a ((->) s), MonadState s m) => m a
19:05:29 <`nand`> cmccann: haha
19:05:52 <parcs> :t gets gets
19:05:54 <lambdabot> (MonadState s m1, MonadState (s -> a) m) => m (m1 a)
19:06:05 <`nand`> :t gets use
19:06:06 <byorgey> beefcube: the definition says: get is a State computation which, when started in state s, leaves the state unchanged and also returns that same state as its result
19:06:06 <lambdabot> (MonadState s m1, MonadState (Getting a s t a b) m) => m (m1 a)
19:06:37 <byorgey> beefcube: usage examples for get are going to feel entirely different, because they are on a very different level of abstraction
19:06:50 <byorgey> i.e. typically they would make use of the Monad instance for State to hide the plumbing of actually passing the state around
19:07:06 <byorgey> whereas the implementation of get is more "low-level"
19:07:56 <monadicity> is 2^N -> N injective a contradiction in constructive math?
19:08:32 <beefcube> ah, sorry, yet another newbie mistake of tunnel vision on parts of certain documentation *sigh*
19:08:39 <beefcube> thanks
19:09:42 <applicative> > let bos = fmap .  (+) . snd in bos (1,2) (100,200)
19:09:45 <lambdabot>   (100,202)
19:09:54 <`nand`> monadicity: (out of interest) what does “constructive math” mean in this context?
19:10:06 <monadicity> prove without excluded middle
19:10:15 <cmccann> :t get it
19:10:16 <lambdabot>     Not in scope: `it'
19:10:17 <lambdabot>     Perhaps you meant one of these:
19:10:17 <lambdabot>       `id' (imported from Data.Function),
19:10:24 <cmccann> bah, that's not funny enough.
19:10:36 <cmccann> lambdabot doesn't get it :[
19:10:50 <rwbarton> irc is serious business
19:10:58 <arbn> monadicity: And without double negation elimination.
19:11:19 <`nand`> arbn: doesn't that arise from excluded middle?
19:11:51 <rwbarton> what is 2?
19:12:07 <`nand`> set containing two elements, presumably
19:12:11 <rwbarton> the classical two element set?
19:12:24 <applicative> > let bos = fmap (fmap fmap (+))  snd in bos (1,2) (100,200)
19:12:26 <lambdabot>   (100,202)
19:12:28 <monadicity> 2 is Bool
19:12:38 <rwbarton> set of truth values?
19:12:48 <monadicity> data Bool = True | False
19:12:52 <rwbarton> those are different
19:12:57 <arbn> `nand`: Is it? That's not obvious to me at the moment.
19:13:09 <monochrom> I have only heard of "this function is/is-not injective". I have never heard of "this function space is/is-not injective". what does that mean? what is the definition?
19:13:18 <mgsloan> 'lo all!  I was taking a look at writer today, and was curious, why is "pass" included?
19:13:21 <mgsloan> ?type pass
19:13:22 <lambdabot> MonadWriter w m => m (a, w -> w) -> m a
19:13:34 <mgsloan> I thought the whole point of writer was restricting mutation to be monoidal
19:13:46 <beaky> hello
19:15:58 <cmccann> mgsloan, what about local?
19:16:00 <cmccann> :t local
19:16:01 <lambdabot> MonadReader r m => (r -> r) -> m a -> m a
19:16:02 <`nand`> what does ‘pass’ do? Does it mutate the log, or does it just append the new result?
19:16:04 <cmccann> same idea.
19:16:09 * hackagebot conductive-base 0.3 - a library for live coding and real-time musical applications  http://hackage.haskell.org/package/conductive-base-0.3 (RenickBell)
19:16:25 <`nand`> oh
19:16:31 <`nand`> if it appended, there would be a Monoid constraint
19:16:34 <`nand`> never mind
19:16:41 <applicative> @djinn (w,(a, w -> w)) -> (w, a)
19:16:41 <lambdabot> f (a, (b, c)) = (c a, b)
19:17:03 <`nand`> let me take that back, class MonoidWriter w m implies Monoid w
19:17:04 <monadicity> let f : (N -> Bool) -> N
19:17:05 <rwbarton> isn't Monoid w a superclass of MonadWriter w m
19:17:05 <parcs> :t let pass m = lift (runWriterT m) >>= \((a,f),w) -> tell (f w) >> return a in pass
19:17:07 <lambdabot> (Monad m, MonadTrans t, MonadWriter w1 (t m)) => WriterT w m (b, w -> w1) -> t m b
19:17:10 <monadicity> prove f is not injective
19:17:18 <cmccann> note that functions like pass and local are still fundamentally different from what you can do with the State monad
19:17:47 <parcs> :t let pass m = WriterT (fmap (flip (,) mempty) (runWriterT m)) >>= \((a,f),w) -> tell (f w) >> return a in pass
19:17:48 <lambdabot> (Monad m, Functor m, Monoid w) => WriterT w1 m (b, w1 -> w) -> WriterT w m b
19:19:16 <mgsloan> cmcann: ahh, thanks!  I didn't quite pay attention to the fact that the argument was wrapped in the monad
19:20:43 <ssl_> anyone have advice for someone completely new to functional programming and Haskell (coming from a background in Ruby)?
19:21:05 <cmccann> ssl_, read LYAH
19:21:11 * hackagebot conductive-song 0.2 - a library of functions which are useful for composing music  http://hackage.haskell.org/package/conductive-song-0.2 (RenickBell)
19:21:13 * hackagebot conductive-hsc3 0.2 - a library with examples of using Conductive with hsc3  http://hackage.haskell.org/package/conductive-hsc3-0.2 (RenickBell)
19:21:15 * hackagebot conductive-clock 0.2 - a library for displaying musical time in a terminal-based clock  http://hackage.haskell.org/package/conductive-clock-0.2 (RenickBell)
19:21:16 <cmccann> @where lyah
19:21:17 <lambdabot> http://www.learnyouahaskell.com/
19:21:44 <beaky> what are types?
19:22:03 <cmccann> ssl_, once you get through LYAH you will no longer be new to functional programming or haskell :]
19:22:36 <beaky> LYAH will learn you a haskell for great good
19:23:09 <ssl_> cmccann, thanks! I'm pretty excited - have only heard great things about Haskell + the community
19:23:19 <`nand`> let me second LYAH
19:24:59 <sw2wolf> I donot know how to translate Applicative to Chinese ?
19:26:17 <sw2wolf> Functor:函子， Monad:单体, Applictive:?
19:26:31 <`nand`> perhaps you could look at the definition of ‘applicative’ and see if there's a suitable Chinese word
19:27:05 <cmccann> "applicative" is derived from "application", in the same sense as "function application"
19:27:06 <sw2wolf> up to now i cannot find an appropriate word
19:27:07 <cmccann> if that helps
19:27:47 <cmccann> so if you have a translation for "function application" that could be a place to start
19:28:16 <`nand`> ?wn applicative
19:28:16 <lambdabot> *** "applicative" wn "WordNet (r) 3.0 (2006)"
19:28:17 <lambdabot> applicative
19:28:17 <lambdabot>     adj 1: readily applicable or practical [syn: {applicative},
19:28:17 <lambdabot>            {applicatory}]
19:28:52 <rwbarton> you could translate it as "monoidal" which is what it really is
19:29:05 * cmccann doesn't think that definition of applicative really fits
19:29:11 <rwbarton> which is apparently 么半
19:29:21 <rwbarton> according to http://zh.wikipedia.org/wiki/%E4%B9%88%E5%8D%8A%E7%AF%84%E7%96%87
19:29:30 <rwbarton> (what a useful URL)
19:29:43 <sw2wolf> Applicative == 么半 ?
19:29:56 <rwbarton> it's the best I can do. :)
19:30:23 <rwbarton> It's possible no one has translated it into Chinese before -- it's not a real category theory word
19:30:52 <cmccann> if all else fails, invent some sort of vaguely-relevant pun.
19:31:00 <cmccann> conor mcbride would probably approve of that.
19:31:02 <sclv> well monoidal functor
19:31:09 <sw2wolf> If we regard Applicative as an interface which wants you implement: <$>, <*> and pure, then ...
19:31:35 <sclv> but applicative is short for applicative functor
19:32:00 <sw2wolf> It is a special functor ?
19:32:04 <sclv> so perhaps apply-able would be a word with the right connotation?
19:32:09 <sclv> it is a functor with additional properties
19:32:21 <sclv> category-theoretically it is a "strong lax monoidal functor"
19:32:23 <cmccann> sclv, given the wordnet definition above I think I'm going to start interpreting that as "practical functor"
19:32:31 <sw2wolf> ,wn applyable
19:32:33 <sclv> but monoidal functor is sufficien
19:32:43 <rwbarton> lax is redundant (and confusing)
19:32:49 <rwbarton> er
19:32:53 <sclv> yeah i agree
19:32:56 <rwbarton> *strong* is redundant (and confusing)
19:32:59 <rwbarton> see how confusing it is :)
19:33:08 <rwbarton> lax I don't like to leave off
19:33:08 <sclv> both are redundant and confusing i think
19:33:22 <sclv> strong is tensoral strength, not "strong monoidal"
19:33:40 <sclv> but lax is also redundant in that that's the weakest condition, right?
19:34:00 <sw2wolf> So i always use Applicative as it is, i donot translate it
19:34:04 <sclv> unless people like to talk about stronger monoidal functors without the prefix?
19:34:06 <rwbarton> if I had my way I would use "monoidal" for strong monoidal and "lax monoidal" for lax monoidal
19:34:14 <sclv> ah, gotcha
19:34:32 <sclv> fair enough
19:34:47 * simon shudders at the path through abstract algebra to make any sense of these things.
19:34:52 <sw2wolf> ?wn applicative
19:34:52 <lambdabot> *** "applicative" wn "WordNet (r) 3.0 (2006)"
19:34:52 <lambdabot> applicative
19:34:53 <lambdabot>     adj 1: readily applicable or practical [syn: {applicative},
19:34:53 <lambdabot>            {applicatory}]
19:35:19 <sclv> ?wn apply
19:35:19 <lambdabot> *** "apply" wn "WordNet (r) 3.0 (2006)"
19:35:19 <lambdabot> apply
19:35:19 <lambdabot>     v 1: put into service; make work or employ for a particular
19:35:19 <lambdabot>          purpose or for its inherent or natural purpose; "use your
19:35:21 <lambdabot>          head!"; "we only use Spanish at home"; "I can't use this
19:35:23 <lambdabot> [29 @more lines]
19:35:38 <sclv> so "able to be applied" could give you a decent word, i think?
19:35:51 <sclv> simon: applicatives really aren't bad
19:36:12 <sclv> the usual presentation in haskell hides the monoidal-ness a bit
19:36:55 <cmccann> understanding the terminology needed to specify Applicative in Category Theory-speak is more difficult than understanding what it actually is
19:37:10 <simon> sclv, I imagine there's a difference between being able to use Haskell's typeclasses and understanding category theory. :-P
19:37:17 <`nand`> what cmccann said
19:37:22 <monadicity> so what is category theory needed fro?
19:37:32 <applicatory> @type Control.Monad.Zip.mzip
19:37:32 <cmccann> stealing terminology from
19:37:33 <lambdabot> Control.Monad.Zip.MonadZip m => m a -> m b -> m (a, b)
19:37:43 <cmccann> alas, they didn't have a good term for Applicative :[
19:37:48 <simon> monadicity, overcoming Russell's paradox?
19:37:58 <sw2wolf> able to be applied : 能够应用
19:38:11 <sclv> if you know what a functor is, and you know what a monoid is
19:38:12 <`nand`> it's the same with most things, really; enumerating the formal properties of something is going to invoke lots of dependencies
19:38:20 <beaky> what is the difference between a type and a type class?
19:38:22 <sclv> and you think of this as the primitive operation of applicative
19:38:29 <sclv> ?ty liftA2 (,)
19:38:30 <lambdabot> Applicative f => f a -> f b -> f (a, b)
19:38:37 <sclv> then its entirely straightforward
19:38:53 <`nand`> I mean, you can talk about a ‘monad’ as a ‘lax 2-functor from a terminal bicategory’ or a ‘monoid in the category of endofunctors’; but both of those are going to be way more complicated than necessary if you only want to explain/understand them
19:39:01 <cmccann> `nand`, it's even worse when you get into version conflicts between terminological dependencies
19:39:15 * cmccann talks about triples instead
19:39:20 <beaky> 'monoid in the category of endofunctors' is a pretty nice definition
19:39:28 * applicatory uses workflows
19:39:34 <cmccann> hahaha
19:39:54 <cmccann> there's always "warm fuzzy thing".
19:40:08 <sclv> monoidal triple is what i recall it was at first?
19:40:29 <simon> beaky, yes. we have a comp.sci. revue sketch built up around understanding women through knowledge of monads (a reverse on the monad tutorial fallacy).
19:40:29 <sclv> i just thank the stars mipple didn't catch on
19:40:37 <sw2wolf> I feel it is better NOT to translate it
19:40:48 <simon> beaky, the analogy stops at that, because I don't think women are like a monoid in the category of endofunctors.
19:41:13 <beaky> right
19:41:23 <simon> but maybe that's just me being politically correct.
19:44:33 <dolio> sclv: I think 'standard construction' might be even earlier.
19:44:48 <dolio> Obviously the best name.
19:44:52 <sclv> haha yeah
19:45:03 <sclv> there's only one standard construction
19:45:32 * `nand` still thinks the name Grothendieck construction is awesome
19:45:51 <jozefg> Why is applicative favored over monadic? I understand what both are but I'm confused of what makes applicative simpler to understand
19:46:14 <jmcarthur> jozefg: it's not about being simpler. it's about being more general
19:46:20 <`nand`> applicatives are more general than monads; not sure about simpler or favorable
19:46:35 <jmcarthur> jozefg: more things are applicative than monadic, so if you use applicative instead of monad then your code might be more reusable
19:46:38 <sclv> also the syntax is pleasant
19:46:48 <`nand`> keep in mind Monad was popularized before Applicative in Haskell
19:46:52 <sclv> so you can write foo <$> bar <*> baz <*> quux
19:46:59 <jmcarthur> jozefg: also, just like with parametric polymorphism, it turns out that the more generic code is harder to get wrong
19:47:10 <sclv> and that's just pleasant compared to using three lines in do notation or the like
19:47:26 <`nand`> foo `liftM` bar `ap` baz `ap` quux
19:47:29 <jmcarthur> i'm not really a fan of (<*>)
19:47:29 <`nand`> what nonsense do you blaspheme
19:47:36 <monochrom> haha
19:47:39 <jmcarthur> i much prefer the liftA* family of functions
19:47:44 <sclv> gax
19:48:00 <startling> why does Either's MonadError instance need Error on the Left type?
19:48:12 <sclv> it really shouldn't as i recall
19:48:19 <sclv> i think there's been some discussion of fixing it
19:48:24 <jmcarthur> well, it shouldn't need it for the Monad instance
19:48:24 <sclv> it was just there to support fail
19:48:28 <startling> oh.
19:48:28 <jozefg> its because of fail if i remember
19:48:31 <jmcarthur> for MonadError it makes more sense, iirc
19:48:33 <startling> silly.
19:48:40 <`nand`> I thought the consesus was ‘don't use Either's instances’
19:48:41 <sclv> freaking fail
19:48:45 <`nand`> consensus, even
19:48:48 <startling> `nand`: heh
19:48:51 <cmccann> how about "get rid of fail" instead
19:48:54 <cmccann> that sounds like a good plan
19:48:56 <sclv> one step at a time
19:48:58 <jmcarthur> i like "get rid of fail
19:49:00 <jmcarthur> "
19:49:05 <`nand`> cmccann: and after that, make Applicative a darn superclass
19:49:13 <sclv> yeah i think even if it broke a fair amount of code, ditching fail would be popular
19:49:25 <cmccann> the change to Num already broke a buncha stuff and people survived
19:49:32 <jozefg> `nand`:  backwards compatibality is overrated anyways
19:49:40 <monochrom> this is too early for Christmas wishes for Christmas 2013 :)
19:49:45 <bradleyayers> jozefg: big call
19:49:56 <`nand`> yeah, who needs a compatible Prelude? it's time to re-export Control.Lens
19:50:03 <monochrom> haha
19:50:03 <jozefg> bradleyayers: sorry?
19:50:13 <edwardk> `nand`: wait for 3.8 first ;)
19:50:15 <bradleyayers> backwards compat being overrated
19:50:18 <monochrom> @remember `nand` yeah, who needs a compatible Prelude? it's time to re-export Control.Lens
19:50:19 <lambdabot> It is stored.
19:50:25 <`nand`> edwardk: no, we will simply push a new base every time you update
19:50:31 <edwardk> that works too
19:50:31 <cmccann> haha
19:50:46 <startling> git hooks!
19:50:54 <edwardk> If we could move the rest of the haskell ecosystem to my release schedule, it'd be a lot easier on me.
19:51:01 <cmccann> I'm not sure I like the idea of Prelude taking every possible operator of three of fewer characters :[
19:51:19 <`nand`> cmccann: and quite some longer ones, too
19:51:23 <startling> is flip when somewhere?
19:51:33 <jmcarthur> > fix error
19:51:35 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
19:51:35 <jmcarthur> > fix fail
19:51:37 <lambdabot>   ""
19:51:43 <startling> @hoogle Monad m => m () -> Bool -> m ()
19:51:44 <lambdabot> Control.Monad unless :: Monad m => Bool -> m () -> m ()
19:51:44 <lambdabot> Control.Monad when :: Monad m => Bool -> m () -> m ()
19:51:44 <lambdabot> Data.Generics.Aliases extR :: (Monad m, Typeable a, Typeable b) => m a -> m b -> m a
19:51:56 <startling> thanks, lambdabot
19:52:24 <jmcarthur> > mfix fail
19:52:26 <lambdabot>   No instance for (GHC.Show.Show (m0 GHC.Base.String))
19:52:26 <lambdabot>    arising from a use ...
19:52:32 <jmcarthur> ah, duh
19:52:59 <jmcarthur> trying to get something interesting out of some variant on "fix fail" that i can use as a silly political statement about the Monad class
19:53:02 <`nand`> cmccann: worst comes to worst, we'll just have to move some other operators to make room. <> can become |\/|/-\|-|-|=|\||> should the need arise
19:53:10 <jozefg> :t optional
19:53:12 <lambdabot> Alternative f => f a -> f (Maybe a)
19:53:15 <`nand`> I'm sure nobody would object
19:53:19 <jozefg> :info Alternative
19:53:26 <jmcarthur> `nand`: seems reasonable
19:53:30 <jozefg> aww do we not get that :(
19:54:31 <beefcube> byorgey: sorry to bring this up so late, from the usecase in my paste, where in the documentation does 'get' actually return just the state from the monad? I understand this is what happens in reality during executution, but what I don't understand is why they would leave that out of the source docs.
19:55:10 <`nand`> “Return the state from the internals of the monad.”
19:55:19 <`nand`> that's the documentation for ‘get’
19:55:35 <monadicity> an f-algebra is a type a and map alpha : f a -> a satisfying alpha . return = id, alpha . join = alpha . fmap alpha
19:55:45 <beefcube> `nand`: yes, but i'm assuming that I'm going to get a description of how it does this in hackage, unless I'm looking in the wrong place
19:55:46 <monadicity> does this ever get used in haskell?
19:56:15 <jozefg> Why on earth does many $ Just 1 loop forever...
19:56:21 <`nand`> beefcube: no, that's an internal concern - there are multiple instances of that class either way
19:56:36 <`nand`> if you're interested in how the actual implementation works, however, you can always press ‘Source’ to view the source code of a certain definition
19:56:59 <beefcube> `nand`: that is my problem, I can't find it in the source link :(
19:57:41 <`nand`> by clicking on ‘Source’ next to ‘get’:     get = state (\s -> (s, s))
19:57:43 <monochrom> because mtl is a wrapper over transformers. go look the source code of transformers
19:57:46 <`nand`> that's the default definition
19:57:57 <cmccann> http://hackage.haskell.org/packages/archive/transformers/0.3.0.0/doc/html/src/Control-Monad-Trans-State-Lazy.html#get
19:58:17 <`nand`> oh yeah, that as well
19:58:54 <dolio> monadicity: Probably more in a theoretical background capacity than in practice.
19:59:10 <beefcube> `nand`: but then i'm expecting a "\s -> (s,s)" with "<- get" which isn't what is occuring the example
20:00:08 <edwardk> jozefg: many p = ps where ps = (:) <$> p <*> ps <|> pure []    -- however many (Just 1) = ps where ps = (:) <$> Just 1 <*> ps     this never figures out that the outer constructor is Just because it just keeps forcing (<*>) nodes trying to figure out if its Just or Nothing
20:00:16 <`nand`> beefcube: I don't know what you mean
20:00:39 <cmccann> "many" does not do something useful for all instances
20:00:52 <edwardk> jozefg: many is intended for parser combinators and what not, for many types its rather silly
20:01:51 <jozefg> edwardk: thanks, the documentation of 0 or more didn't really help in this context haha
20:02:33 <`nand`> many (Identity 1) would be Identity (repeat 1) ?
20:03:22 <monochrom> Identity is not even an Alternative
20:03:31 <`nand`> oh, yes
20:03:36 <`nand`> lacking empty
20:04:58 <lightquake> what's that ghc option that gives you stack traces?
20:05:29 <monochrom> @where +RTS-xc
20:05:30 <lambdabot> I know nothing about +rts-xc.
20:05:50 <`nand`> @where rts-xc
20:05:50 <lambdabot> ghc -prof -fprof-auto -rtsopts -osuf .p_o foo.hs && ./foo +RTS -xc # print stack traces on unhandled exceptions
20:06:34 <`nand`> hmm, I need to configure my IRC client to have :q close buffers
20:07:26 <edwardk> > many (Identity 1)
20:07:28 <lambdabot>   No instance for (Control.Applicative.Alternative
20:07:28 <lambdabot>                     Data.F...
20:07:31 <lightquake> it looks like the -rtsopts -osuf .p_o is unnecessary
20:07:37 <edwardk> no Alternative
20:08:01 <`nand`> the -osur seems to be unnecessary, at the very least; is -rtsopts on by default?
20:08:07 <`nand`> s/osur/osuf/
20:08:24 <monochrom> -rtsopts is half off by default
20:08:30 <cmccann> `nand`, since people tend to use lambdabot as an online GHCi typing :q in channel should make lambdabot kick you
20:08:51 <beaky> when should I use a newtype over a type?
20:08:54 <cmccann> (except that lambdabot does not have ops so this wouldn't work)
20:09:05 <`nand`> cmccann: I suffered from the same, except in a /query
20:09:27 <beaky> what is the difference between a newtype anda  type?
20:09:27 <monochrom> but lambdabot can stab you
20:09:34 <monochrom> @stab monochrom
20:09:34 <lambdabot> go slap monochrom yourself
20:09:35 <`nand`> well, except for the GHCi part; no need to use an online GHCi when I have my own instance
20:09:43 <cmccann> lambdabot is big on stabs these days
20:09:44 <monochrom> sometimes :)
20:09:57 <beaky> ghci doesn't have neat lambdabot tools like @pl, @djinn, etc.
20:10:14 <cmccann> you can install both of those on their own though.
20:10:14 <lightquake> `nand`: it looks like -prof enables enough of -rtsopts to use +xc
20:10:18 <beaky> ah
20:10:26 <beefcube> `nand`: i think my question is the same as asking how <- determines what to extract from the monad, and where that is implemented for a given monad
20:10:28 <lightquake> under the assumption that you won't be using prof binaries in development, i guess
20:10:40 <cmccann> djinn actually has a lot more features and its own little interactive prompt and stuff.
20:10:40 <monochrom> lambdabot doesn't have neat ghci tools like import and cabal-install
20:10:51 <beaky> ah
20:10:53 <`nand`> beefcube: oh, are you asking about the <- syntax? that's just sugar for >>=
20:10:57 <`nand`> more precisely:
20:11:07 <`nand`> do { a <- b; c } is sugar for b >>= \a -> c
20:11:07 <lightquake> @undo {a <- x; b <- y; f a b}
20:11:08 <lambdabot>  Parse error at "{a" (column 1)
20:11:12 <lightquake> @undo do {a <- x; b <- y; f a b}
20:11:13 <lambdabot> x >>= \ a -> y >>= \ b -> f a b
20:11:45 <`nand`> beefcube: so you're looking at (>>=), which is a member of the Monad class; and subsequently the Monad instance for StateT
20:11:56 <lightquake> note that >>= is right-associative, so this means x >>= (\a -> y >>= (\b -> f a b))
20:12:18 <monochrom> look at how StateT implements >>=
20:12:27 <`nand`> beefcube: which can be found here: http://hackage.haskell.org/packages/archive/transformers/latest/doc/html/src/Control-Monad-Trans-State-Lazy.html#StateT
20:12:53 <`nand`> (though that's for the transformer, so it's a bit more complicated)
20:13:19 <monochrom> actually, look at http://www.engr.mun.ca/~theo/Misc/haskell_and_monads.htm , completely explains State
20:13:30 <`nand`> beefcube: for a simpler introduction, you could read http://learnyouahaskell.com/for-a-few-monads-more#state
20:13:36 <monochrom> which he calls StateTrans
20:14:35 <beefcube> `nand`: ok, the example evaluates to get >>= \s ... but how did it know to choose s?
20:15:14 <beefcube> `nand`: ok, checking those links
20:15:56 <monochrom> don't just check. spend an hour reading and thinking. no royal road.
20:16:02 <jozefg> :t mappend
20:16:03 <lambdabot> Monoid a => a -> a -> a
20:16:25 <Nostromo56> `nand`: another  nuby question. I'm reading  Real   World Haskell,  how does that compare to LYAH?
20:16:37 <monochrom> and perhaps s/thinking/calculating/
20:16:44 <`nand`> I can't really answer that since I never really read RWH
20:17:01 <`nand`> but I don't like the code samples I've seen in RWH
20:17:04 <`nand`> they look ugly
20:17:26 <Jafet> nand isn't a fan of the RealWorld.
20:17:37 <`nand`> haha
20:17:57 <monochrom> there is no spaghetti flying monster or readworld
20:18:06 <gwern> @quote
20:18:06 <lambdabot> elven says: foldr sounds like a web-2.0 service
20:18:14 <`nand`> (yeah, Codensity (Free FFI) or whatever is much better ;)
20:18:15 <monochrom> haha
20:18:30 <`nand`> gwern: gosh, it does
20:18:37 <`nand`> web-2.0 online directory service
20:18:43 <Nostromo56> `nand`: Yeah, I check ed out LYAH, and it seems more  intuitive.
20:18:57 <`nand`> Nostromo56: (you seem to be generating extra spaces)
20:19:55 <Jafet> Thievingrascals
20:20:15 <monochrom> foldr.com is cute
20:20:20 <gwern> `nand`: now, for bonus points, what does foldr do?
20:20:58 <gwern> 'sudo btrfs fi show /dev/device should show no free space on any drive. ' check
20:21:01 <cmccann> clearly foldr is a web2.0 social networking site dedicated to summarizing lists of things
20:21:25 <gwern> cmccann: a worthy competitor to pinterest1
20:22:29 <`nand`> gwern: organizes online folders of information
20:22:44 <`nand`> ..right-associatively
20:24:03 <monochrom> at least it's a catamorphism :)
20:24:46 <`nand`> cat-a-morph ism?
20:24:54 <monochrom> oh!
20:25:08 <`nand`> I think morph-a-cat would make more sense in English
20:25:23 <monochrom> http://www.vex.net/~trebla/photo/unorganized/pumpkin-catmorphism.jpg
20:26:30 <beaky> How do I test my software to find bugs in Haskell?
20:26:47 <beaky> my roguelike rbably has tons of bugs now :(
20:26:52 <beaky> probably*
20:26:59 <`nand`> finding and standardizing a valid ‘pumpkin’ fold is left as an exercise to the reader
20:27:03 <jozefg> beaky: unit tests, unit tests everywhere
20:27:32 <beaky> how do unit tests work? lots of my code depends on other parts of code
20:27:54 <monadicity> post your code ill say if it has a bug
20:28:05 <monochrom> perhaps read the book "writing solid code"
20:28:09 <beaky> ah
20:29:07 <beaky> maybe haskell can prove that my program is correct
20:29:13 <`nand`> “Haskell code doesn't have bugs. It just conforms to different specifications, that's all”
20:29:26 <beaky> since a program is essentially a proof
20:29:38 <monochrom> that is not true
20:30:08 <beaky> it isn't? I thought that was what was meant by curry-howard isomorphism :(
20:30:24 <jmcarthur> the program proves the type
20:30:25 <monochrom> the curry-howard isomorphism does not apply to haskell
20:30:29 <jmcarthur> it is not its own proof
20:30:34 <beaky> oh
20:30:45 <jmcarthur> and yes, it's not a glove-like fit for haskell in any case
20:30:53 <beaky> so if my roguelike runs properly, then it proves that my types are all consistent?
20:30:59 <jmcarthur> well
20:31:05 <beaky> or if it even compiles*
20:31:12 <johnw> monochrom: so why is there a page like http://en.wikibooks.org/wiki/Haskell/The_Curry-Howard_isomorphism
20:31:18 <johnw> beaky: it applies a lot more than he's suggesting
20:31:22 <`nand`> maybe you could write your whole program on the type level and use a program to prove certain properties about it
20:31:34 <monochrom> applying the curry-howard isomorphism to haskell is like applying the Boole-Ritchie correspondence to the equation 1 + (-1) = 0
20:32:12 <jmcarthur> in a language for which CH applies, the existence of an implementation for a type can be taken as proving the property that the type is isomorphic to
20:32:23 <`nand`> hmm, since the new TF stuff gives use case expressions; I wonder if there's anything left on the value level that can't be ported to the type level?
20:32:26 <applicatory> @quote useful
20:32:27 <lambdabot> unknown says: codependent types are useful for dysfunctional programming
20:32:32 <applicatory> @quote useful
20:32:33 <lambdabot> sigfpe says: Haskell is so strict about type safety that randomly generated snippets of code that successfully typecheck are likely to do something useful, even if you've no idea what that useful
20:32:33 <lambdabot> thing is.
20:32:40 <`nand`> (in terms of expressions, not in terms of features like IO or exceptions)
20:32:40 <monochrom> the Boole-Ritchie correspondence: non-zero numbers map to "true" (Ritchie's C language), + maps to logical-or (Boole's idea)
20:32:45 <sclv> does CH freaking apply anywhere then?
20:32:46 <applicatory> there beaky ^^^
20:32:56 <jmcarthur> `nand`: runtime values? (although singleton types kinda does that...)
20:33:20 <monochrom> applying the Boole-Ritchie correspondence to 1 + (-1) = 0: you get true||true = false
20:33:23 <`nand`> jmcarthur: singletons gives us runtime values?
20:33:33 <`nand`> jmcarthur: well, through an existential I guess
20:34:02 <cmccann> haskell programs are proofs of "main :: IO ()". that is, a program exists, and you can run it.
20:34:06 <cmccann> problem solved.
20:34:15 <jmcarthur> `nand`: well, a one-to-one correspondance between values and types, at least, which is about all you need to simulate depend types in conjunction with a few other features we already have
20:34:21 <jmcarthur> *dependent
20:34:24 <sclv> haskell is the sugared typed lambda calculus
20:34:34 <sclv> the typed lambda calculus was basically ground zero for CH
20:34:55 <sclv> so i think CH applies to haskell just about as well as anywhere. you just have to be thoughtful with it
20:35:10 <sclv> and anyway we don't just "apply" it like a hammer
20:35:12 <monochrom> johnw, wikibook is written under the influence of self-selection. overly enthusiastic authors write it and add all sorts of extraneous information they personally like
20:35:14 <jmcarthur> it applies "fast and loose"
20:35:17 <sclv> we use it to reason about programs in lots of ways
20:35:37 <flebron> if you want a more powerful link between functional programming and proofs, see agda or coq
20:35:48 * cmccann already did this earlier but...
20:35:55 <cmccann> @quote kmc ints.exist
20:35:55 <lambdabot> kmc says: "Haskell is great, because Curry-Howard!  Proving things in the type system.  We can prove that, uh, Ints exist, unless they're ⊥."
20:36:18 <sclv> its a decent enough page
20:36:26 <sclv> it opens ppl up to the idea, i think
20:37:15 <jmcarthur> `nand`: do those type level case expressions give us the ability to define closed functions at the type level with exhautiveness checks, or is that still a hack?
20:37:27 <jmcarthur> *exhaustiveness
20:37:56 <`nand`> I doubt that
20:37:58 <`nand`> type families are still open
20:38:06 <`nand`> you can just overlap instances within groups
20:38:31 <`nand`> jmcarthur: that being said, with the new changes singletons should be able to lift many more syntactical forms into the type level
20:39:14 <`nand`> so you'd get exhaustiveness checks for the value-level definitions
20:39:35 <jmcarthur> `nand`: oh, when i said "singletons" earlier, i didn't actually mean the library
20:39:46 <jmcarthur> `nand`: i just meant the more generic notion of singleton types
20:39:55 <`nand`> right
20:40:04 <`nand`> but my point stands regardless
20:40:08 <jmcarthur> just making sure that was clear, is all
20:40:20 <tomsthumb> can you guys help me out with an error in this?? primeFactors y = primeFactors' y []; primeFactors' z factors = [k | k <- [2..z - 1], (mod z k) == 0]; primeFactors 8
20:40:30 <`nand`> (it wasn't, but it doesn't change the meaning in retrospect, since singletons' idea of singletons is coincident)
20:40:44 <jmcarthur> yeah, the name comes from somewhere ^_^
20:40:58 <tomsthumb> i  cut out some things for now, so it doesn't actually do prime factors, but there's a problem with the types in there
20:41:52 <sclv> tomsthumb: paste the real code on hpaste
20:41:56 <sclv> it will be much clearer
20:42:01 <Jafet> > let primeFactors y = primeFactors' y []; primeFactors' z factors = [k | k <- [2..z - 1], (mod z k) == 0] in primeFactors 8
20:42:03 <lambdabot>   [2,4]
20:42:16 <rwbarton> and the error
20:42:25 <sclv> yes, and the error!
20:43:54 <tomsthumb> http://pastebin.com/KrP3YLh0
20:44:34 <`nand`> your type signature is lacking some typeclass constraints
20:44:40 <`nand`> try adding (Enum a, Num a)
20:44:51 <`nand`> oh, and Eq
20:44:58 <sclv> or just go from [a] to [Double] or [Int]
20:45:06 <tomsthumb> why doesn't it infer that?
20:45:12 <sclv> because you explicitly told it not to
20:45:25 <sclv> you declared the type as being for all [a]
20:45:31 <tomsthumb> well balls
20:45:31 <sclv> not [a] with constraints
20:45:38 <Jafet> > let primeFactors y = primeFactors' y []; primeFactors' z factors = [k | k <- [2..z - 1], (mod z k) == 0, and [mod k i /= 0 | i <- [2..k - 1]]] in primeFactors 5040
20:45:40 <lambdabot>   [2,3,5,7]
20:45:43 <sclv> you either give a full correct type signature, or no signature
20:45:59 <tomsthumb> how is [a] constraining?
20:46:04 <sclv> what compiler are you using by the way?
20:46:07 <tomsthumb> a should just mean anything
20:46:10 <sclv> [yes
20:46:12 <tomsthumb> ghci on osx 10.7
20:46:15 <sclv> it does mean anything
20:46:31 <sclv> *but* you are doing things with the a, like math
20:46:45 <sclv> which means it can't be just anything, but only things you can do math with, and compare, and etc.
20:46:55 <tomsthumb> ohhhh
20:46:56 <sclv> so your function doesn't work on any [a] even though you declared that it does
20:47:00 <tomsthumb> hmmmmmm
20:47:12 <rwbarton> "anything" means the caller can choose anything
20:47:20 <sclv> hence (Eq a, Ord a, Num a) => [a] -> [a] , or the like
20:47:27 <sclv> so you put your typeclass constraints in the signature
20:47:31 <monochrom> if it cannot be ()->[()], it cannot be a->[a]
20:47:45 <sclv> you can also just load the file in ghci and get the type of your function, to see the inferred signature for yourself
20:48:13 <tomsthumb> awesome
20:48:41 <tomsthumb> most of my stuff is python so this is kind of a trip. pretty cool though
20:49:11 <flebron> i think lyah is the first programming book i've read front to back
20:49:26 <tomsthumb> yeah, that's what's starting me off
20:49:34 <tomsthumb> it's good
20:50:02 <tomsthumb> have any of you written in F# ?
20:50:51 <tomsthumb> … not to start/say anything dumb, just wondering how you think it compares to this
20:52:40 * `nand` never finished LYAH :(
20:52:52 <ninegrid> tomsthumb: F# is a good language if you are targeting windows
20:53:08 <`nand`> F# sort of works via mono as well
20:53:24 <sw2wolf> ?wn racket
20:53:25 <lambdabot> *** "racket" wn "WordNet (r) 3.0 (2006)"
20:53:25 <lambdabot> racket
20:53:25 <lambdabot>     n 1: a loud and disturbing noise
20:53:25 <lambdabot>     2: an illegal enterprise (such as extortion or fraud or drug
20:53:25 <lambdabot>        peddling or prostitution) carried on for profit [syn:
20:53:27 <flebron> `nand`, based on your responses here, i doubt you need to :p
20:53:27 <lambdabot> [16 @more lines]
20:53:31 <`nand`> tomsthumb: as I understood it, F# still has a fairly limited type system
20:53:35 <`nand`> but it adds sum types
20:53:48 <cmccann> F# is a distant cousin of Haskell as far as languages go. it's fine for what it is, but I think most people would pick other languages unless they really want to target .NET.
20:54:03 <ninegrid> tomsthumb: F# has its niche in "type providers"
20:54:07 <`nand`> flebron: it's okay, I only missed the last chapter (about zippers) and I use edwardk's zippers either way ;)
20:54:36 <`nand`> what ever happened to Haskell.NET?
20:55:14 <`nand`> I have a rudimentary Core-to-.NET compiler lying around, but I've never plugged it into ghc, nor figured out a good interface to native .NET types
20:55:18 <cmccann> sw2wolf, if you're trying to translate the name of the language "Racket", it's a pun off of "scheme", so roughly the second definition there
20:55:45 <sw2wolf> cmccann: yes
20:56:07 <ninegrid> tomsthumb: and the "type providers" in conjunction with other language features, like units of measure and `these kinds of identifiers that can be specified as such` give it an edge in turning simi-structured remote data accessible from cloud services into strongly typed local data with intellisense
20:57:07 <`nand`> (every language with a decently powerful type system can implement units of measure)
20:58:02 <ninegrid> `nand`: but F# integrates it syntactically and the type encapsulating the underlying numerical type is erased at compile time
20:58:11 <`nand`> right
20:58:54 <`nand`> (if this is about Haskell, GHC erases types at compile time too; so all you lose is the syntax bonus. That being said, you can get something just as nice using appropriately defined operators)
20:59:14 <ninegrid> i forgot that point
20:59:16 <`nand`> but I won't continue harping on one minor point
20:59:46 <Jafet> @remember ninegrid the "type providers" in conjunction with other language features, like units of measure and `these kinds of identifiers that can be specified as such` give it an edge in turning simi-structured remote data accessible from cloud services into strongly typed local data with intellisense
20:59:47 <lambdabot> I will remember.
21:02:52 <sw2wolf> :t (->) r
21:02:53 <lambdabot> parse error on input `->'
21:03:03 <sw2wolf> :t (->)
21:03:04 <lambdabot> parse error on input `->'
21:03:14 <Fuuzetsu> Oh man, I just managed to get HXT to do what I wanted on the very first try... At this stage, this is close to a miracle
21:03:37 <Fuuzetsu> arrows uguu
21:05:19 <Maxdamantus> :t undefined :: ((->) r)
21:05:21 <lambdabot>     Expecting one more argument to `(->) r'
21:05:21 <lambdabot>     In an expression type signature: (->) r
21:05:21 <lambdabot>     In the expression: undefined :: (->) r
21:05:53 <Catnaroek> Maxdamantus: (->) is the type constructor of functions, it takes two type parameters (the type of the input and the type of the result).
21:05:56 <Jafet> :k (r ->)
21:05:57 <lambdabot> parse error on input `)'
21:06:00 <Maxdamantus> I know.
21:06:04 <Jafet> :k (->) arrr
21:06:05 <lambdabot> Not in scope: type variable `arrr'
21:06:08 <Maxdamantus> 18:02:33 < sw2wolf> :t (->) r
21:06:08 <Maxdamantus> 18:02:34 < lambdabot> parse error on input `->'
21:06:29 <Catnaroek> :k ((->) r)
21:06:30 <lambdabot> Not in scope: type variable `r'
21:07:24 <Catnaroek> :t undefined :: (->) r s
21:07:26 <lambdabot> r -> s
21:08:58 <Jafet> :t undefined :: undefined
21:09:00 <lambdabot> undefined
21:09:06 <Jafet> :t undefined :: (undefined :: *)
21:09:07 <lambdabot>     Illegal kind signature for `undefined'
21:09:07 <lambdabot>       Perhaps you intended to use -XKindSignatures
21:09:09 <sw2wolf> thx
21:35:27 <applicatory> man awesome quote you recorded there Jafet
21:45:18 <sopvop> http://comonad.com/reader/2012/abstracting-with-applicatives/ have you seen that? applicative writer - it's just the thing I wanted.
21:45:37 <johnw> sopvop: why was it better for you than a monadic writer?
21:46:05 <sopvop> because I need to get writer output even if computation fails
21:46:10 <sopvop> whole output
21:50:28 <applicatory> hm, "Maybe over Writer gives us the same effects we'd get in a Monad — either the entire computation fails, or we get the result and the trace. But Writer over Maybe gives us new behavior. We get the entire trace, even if some computations have failed! "
21:55:56 <`nand`> “Who among us still prefers to write liftM2 foo a b when we could instead write foo <$> a <*> b?” <- is this irony?
21:57:03 <sopvop> I only use liftM* stuff if I don't want to add applicative to constraints
21:57:12 <sopvop> or functor
21:57:22 <`nand`> I only use the <$> <*> stuff when it lets me avoid parentheses
21:57:35 <JoeyA> <$> <*> looks more verbose in some cases, and may require parens
21:57:35 <`nand`> eg. liftM2 (a b) (c d) (e f) is much uglier than a b <$> c d <*> e f
21:58:02 <`nand`> but I'll use liftM2 f a b for simple stuff like that; especially because it lends itself to nicer eta reduction in many cases
21:58:25 <`nand`> eg. \g -> liftM2 foo bar (f g) can be nicely rewritten as liftM2 foo bar . f; whereas..
21:58:30 <`nand`> @pl \g -> foo <$> bar <*> f g
21:58:30 <lambdabot> (foo <$>) . (bar <*>) . f
21:59:40 <Enigmagic> sure, but that's the same for fmap/liftA2/etc too. infix operators don't pointfree well.
21:59:53 * applicatory writes liftM2 foo a b  but thinks foo <$> a <*> b
21:59:59 <sopvop> I prefere let over lambda in most cases. But I agree, parentheses are worse than lift(M|A)*
22:00:52 * applicatory writes liftM2 foo a b  but thinks  (| foo a b |)
22:01:25 <ivanm> I often use lift{M,A} stuff as it can scale nicer rather than lots of infix stuff
22:01:44 <Enigmagic> yeah. things i want in ghc: applicative do notation, banana brackets
22:03:03 <sopvop> :i (<*>)
22:04:05 <sopvop> infixl 4 <*>
22:06:50 <kallisti> what is a monad
22:07:11 <sopvop> warm fuzzy monoid in category of endofunctors
22:07:19 <sopvop> in a space suit
22:07:28 <Enigmagic> a burrito in a space station
22:07:41 <kallisti> help
22:07:53 <Enigmagic> pull the red lever and wait
22:07:57 <sopvop> warm fuzzy space suit in category of burritos
22:08:48 <sopvop> kallisti: you want to learn about that math monad or haskell Monad type class?
22:10:22 <`nand`> Enigmagic: she can do banana brackets
22:10:57 <sw2wolf> haha
22:13:16 <jdavis> (learning) http://hpaste.org/79864 is a program I wrote a while ago. The idea is to read a postgres data file, which is structured as datums in tuples stored in pages; and then do some very simple processing. I hacked my way through it, but there's a lot that I don't like about it, and was hoping someone could help.
22:13:30 <Enigmagic> `nand`: that doesn't really help me though
22:13:52 <`nand`> I guess it doesn't apply to GHCi, and running a preprocessor can still be a bit tedious
22:14:03 <Hafydd> The Internet is a small place.
22:14:24 <Enigmagic> `nand`: it'd be easier to just add them to ghc really :P
22:15:01 <jdavis> ... for one thing, I am using ByteString.Lazy.readFile, which seems a little awkward to me. Also, I've read that lazy IO is no longer recommended.
22:17:21 <jdavis> And every time I work with haskell, I have a little trouble telling which libraries are the current recommended way to do something, and finding the documentation for the version that I'm using.
22:18:18 <x-SuriV> whats it called when you refer to a list in code using the @ notation? like @list(x:xs) where list is a reference to the complete list?
22:18:34 <`nand`> Enigmagic: iunno, banana brackets make me feel weird personally
22:19:06 <Hafydd> x-SuriV: do you mean "list@(x:xs)"?
22:19:13 <Enigmagic> `nand`: i prefer applicative do notation myself, but either would be fine
22:19:29 <x-SuriV> er yes
22:19:39 <x-SuriV> Theres a name for that way of doing it but I cant remember it
22:19:57 <Hafydd> Patterns of the form var@pat are called as-patterns, and allow one to use var as a name for the value being matched by pat.
22:20:02 <Hafydd> http://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-580003.17
22:20:05 <ivanm> x-SuriV: @-pattern? *shrug*
22:20:13 <ivanm> oh, as-patterns, not at-patterns
22:20:32 <applicatory> Hafydd to the rescue
22:20:58 <`nand`> Enigmagic: how does applicative do work?
22:21:07 <Hafydd> What would you do without my spec-reading skills?
22:21:14 <`nand`> Enigmagic: (similar to) regular do but you can only use variables in applications or something?
22:21:20 <`nand`> freshly bound variables*
22:21:45 <Enigmagic> `nand`: yep... it just builds a lambda up then applies it
22:22:11 <Enigmagic> `nand`: you can do that with arrow notation (all applicatives are arrows) but it's kinda klunky
22:23:08 <applicatory> jdavis: somehow I feel the succession of filters in the definition of `process` could be simplified
22:24:41 <jdavis> applicatory: Probably so. I was more concerned that I'm using the wrong overall techniques or libraries.
22:25:24 <applicatory> these are all excellent libraries taken by themselves certainly...
22:26:30 <jdavis> applicatory: what is lazy IO exactly? Does that mean that the IO can happen at arbitrary times?
22:26:59 <monadicity> yeah it's unsafe
22:27:30 <jdavis> monadicity: is it contraindicated?
22:28:29 <applicatory> jdavis: lazy io is great. Its just not ideal for certain purposes
22:29:10 <jdavis> Oh, OK. I think, for my purposes, I probably do not want lazy IO.
22:30:10 <`nand`> I wonder if as-patterns could be generalized to ‘and-patterns’, which would be a pattern that has to match both sides
22:30:38 <jdavis> When do I use String and when do I use Text?
22:30:49 <`nand`> and perhaps even ‘or-patterns’
22:31:27 <ivanm> jdavis: if you're doing textual manipulations, you probably want Text
22:31:47 <jdavis> OK. When would I want String?
22:31:54 <ivanm> string exists solely due to history, as a low-level 'common denominator' and for error messages
22:32:02 <jdavis> Oh, I see.
22:32:03 <sopvop> When you need list of characters - use String
22:32:19 <applicatory> You  use String all the time when using Text
22:32:20 <mikeplus64> jdavis: you probably want Text for 90% of things involving text (not just strings of bytes) unless you want a list of Char for some reason e.g. for a zipper
22:32:25 <ivanm> e.g. error still takes a String, not Text
22:32:41 <`nand`> Text is more efficient in-memory than String, quite significantly for suitably designed benchmarks
22:32:44 <applicatory> fromString uses String :)
22:32:46 <ivanm> mikeplus64: but there are zipping functions available for Text
22:33:00 <`nand`> yeah
22:33:00 <ivanm> applicatory: yes, but isn't that done at compile-time (when using OverloadedStrings)?
22:33:02 <dainanaki> I'm trying to use GHC.Generics in a stupidly simple way, but I'm having issues. I really want a function of the type 'Generic a => a -> String' that just dumps the datatype name as a string, but I can't get 'datatypeName . from' to typecheck. Anyone able to help?
22:33:08 <`nand`> I was going to suggest foldr and friends but there are folds for Text too :)
22:33:18 <mikeplus64> applicatory: but may be "RULE"d out ;)
22:33:22 <Jafet> String is much more efficient than Text, for suitably designed benchmarks
22:33:26 <`nand`> dainanaki: (do you want Typeable?)
22:34:02 <mikeplus64> ivanm: i mean somtehing like data Zipper a = Zipper { before :: [a], this :: a, after :: [a] }
22:34:12 <ivanm> oh, right
22:34:18 <dainanaki> `nand`, I was also wanting to be able to pull out record selector names soon, so I figured that GHC.Generics seemed more appropriate
22:34:20 <`nand`> :t zipper text
22:34:21 <lambdabot> Top :> (String -> Doc)
22:34:33 <ivanm> @type zipper
22:34:34 <lambdabot> a -> Top :> a
22:34:35 <`nand`> oh
22:34:37 <`nand`> wrong text
22:34:40 <`nand`> and wrong way of using it
22:34:41 <`nand`> I should sleep
22:34:43 <ivanm> @hoogle zipper
22:34:43 <lambdabot> package zipper
22:34:44 <lambdabot> package instant-zipper
22:34:44 <lambdabot> package ListZipper
22:35:02 <Enigmagic> dainanaki: you need to navigate down to a D1 constructor. M1 (what 'from' returns) isn't a datatype
22:35:16 <Enigmagic> it's not necessarily a datatype, rather
22:35:20 <`nand`> and we don't have lens 3.8, grumble grumble
22:35:31 <edwardk> `nand`: its better for the wait
22:35:43 <applicative_> jdavis: certainly in a program like yours, if you are thinking of the ByteStrings as text you should use Text.
22:35:58 <`nand`> long story short, we can use generalized zippers and ‘text’ to access the characters of a Text
22:36:09 <`nand`> ByteString and Text are inherently unrelated
22:36:43 <jdavis> applicative_: Many really are byte strings, so I'll leave those as-is. But some of them will eventually be text.
22:37:42 <mikeplus64> i never did come up with a "nice" way to represent a text editor's text (with cursors) that can have multiple cursors. maybe a list of zippers, but that might have to make the assumption that cursors have to be on seperate lines :(
22:41:32 <hpaste> Enigmagic annotated “readdat” with “clean up 'process'” at http://hpaste.org/79864#a79866
22:41:39 <mikeplus64> a zipper of zippers :)
22:41:53 <applicative_> jdavis: now I see you are using the binary-strict package, I wonder if this is up  to date after all...
22:42:32 <jdavis> applicative_: yeah, I think I had trouble compiling it on another system, and I needed to find that package.
22:42:59 <jdavis> applicative_: what should I use instead?
22:45:26 <dainanaki> Enigmagic, I think I'll be fine once I see what the type signatures would be for recursing down the structure, but I'm kind of stumped how to deconstruct the rep that I get.
22:46:07 <Enigmagic> :t GHC.Generics.D1
22:46:08 <lambdabot> Not in scope: data constructor `GHC.Generics.D1'
22:46:11 <Enigmagic> hum
22:46:21 <jdavis> Enigmagic: thank you, that is cleaner.
22:47:31 <Enigmagic> dainanaki: hang on a sec, i'll hack you something up
22:48:26 <dainanaki> D1 is a type synonym
22:48:39 <Enigmagic> yes it is
22:49:10 <jdavis> What is the best way to do deserialization/parsing of binary data? For instance, when it contains various machine words or bit patterns that may be platform-dependent?
22:49:38 <jdavis> I was using binary-strict, but applicative_ indicated that it may be out-of-date.
22:49:45 <simpson> jdavis: I'm relatively sure that people endorse cereal these days.
22:49:49 <simpson> @hackage cereal
22:49:49 <lambdabot> http://hackage.haskell.org/package/cereal
22:50:28 <Enigmagic> jdavis: binary or cereal. binary probably does what you want already. cereal has a few more features and may or may not be slower than binary.
22:50:53 <jdavis> OK. Why a whole new library? Is there a big difference?
22:51:44 <Enigmagic> jdavis: binary was traditionally for decoding where cereal also had parser combinator stuff, did backtracking, etc
22:51:55 <Enigmagic> i think binary has some of those features now too though
22:52:03 <jdavis> Binary.Strict is deprecated but Binary is not?
22:54:57 <Enigmagic> jdavis: right
22:56:43 <jdavis> Enigmagic: is there some way that I should have known that?
22:58:09 <sclv> just look at the hackage pages
22:58:14 <jdavis> (sincere question; I am not complaining... I just have trouble navigating the libraries and best practices sometimes)
22:58:19 <sclv> see which are actively maintained, and which are bitrotted
22:58:55 <sclv> other than that, you can check reverse dependencies
22:59:01 <sclv> (there are a couple of sites for that)
22:59:09 <sclv> and you'll see which ones are popular and which ones aren't
22:59:13 <jdavis> OK
22:59:37 <beaky> what would haskell be like if it had a dynamic type system?
22:59:37 <applicative_> jdavis: as sclv says, note the maintainer of binary-strict is also the maintainer of binary
22:59:41 <sclv> as we grow the platform, it'll get better, i think
22:59:54 <sclv> b/c we'll have a "default" binary serialization package, etc. in there
23:00:12 <jdavis> OK.
23:00:46 <jdavis> Thanks for your help, everyone. I think I have enough to chew on for a while.
23:01:24 <applicative_> jdavis: http://packdeps.haskellers.com/reverse shows how much a package is used so its a sort of sign of merit. Anything not updated on hackage in a year is purely speculative.  It might be great...
23:05:48 <hpaste> Enigmagic pasted “fun with generics” at http://hpaste.org/79867
23:06:14 <Enigmagic> dainanaki: it's a little dense but that yanks out the data type name and record selector names
23:08:42 <Enigmagic> dainanaki: working with generics usually means lots of typeclasses. in this case you only need typeclasses once you start working with the record selectors, so i lumped them all in together.
23:09:30 <beaky> Does haskell have undefined behavior?
23:09:39 <beaky> like in C and C++
23:09:51 <beaky> besides the unsafeFoo functions
23:10:14 <simpson> beaky: "undefined" and "error", I suppose? Although they're guided by the Report somewhat, I think.
23:10:22 <beaky> ah
23:10:31 <beaky> so haskell is a well defined language :D
23:10:52 <simpson> Dunno.
23:12:57 <monadicity> whats a good site to waste timeon
23:13:03 <r00723r0> Reddit.
23:13:10 <r00723r0> NSFW = Not Sexy For Women.
23:13:12 <m3ga> monadicity: coursera
23:13:17 <simpson> monadicity: Kongregate. If you're going to waste time, it might as well be on timewasters. >:3
23:13:24 <monadicity> :D
23:13:29 <beaky> monadicity: facebook
23:13:36 <beaky> look for parties to crash
23:23:21 <hpaste> lukexi pasted “mtl typeclasses” at http://hpaste.org/79868
23:23:39 <beaky> what is the difference between a type and a typeclass
23:23:46 <frelux> ^is there any way to do this?
23:25:48 <hpaste> Saizan annotated “mtl typeclasses” with “mtl typeclasses (annotation)” at http://hpaste.org/79868#a79869
23:26:21 <lukexi> ah, awesome, thanks Saizan! : )
23:26:29 <Enigmagic> :r
23:26:34 <Saizan> np
23:27:00 <beaky> also, when should I use typeclasses
23:27:03 <beaky> over data
23:27:42 <applicative_> beaky: it isn't common that one has occasion to define a type class
23:27:49 <applicative_> it is a major event
23:28:17 <beaky> so a typeclass is something that Ph.D.s research
23:28:23 <applicative_> not at all
23:28:39 <applicative_> Num Eq Ord Show are type classes
23:29:30 <applicative_> if a type is a Num type it supports 1 2 3 , + etc. If it is an Eq type it supports ==
23:30:10 <beaky> ah
23:30:29 <beaky> should game monsters be type classes?
23:30:37 <beaky> what about spells
23:30:40 <beaky> or items
23:30:48 <applicative_> so if you have typed digits or == you were using expressions that pertain to a whole class of  types
23:31:23 <beaky> so typeclasses are for types that have notions of stuff
23:31:27 <beaky> common operations*
23:31:43 * applicative_ knows intuitively that anything called monster or spell is a data type.
23:32:13 <applicative_> beaky: right, it is a system for overloading expressions for use with many types, in the firstinstance
23:32:29 <applicative_> but the types are the main thing.
23:33:41 <applicative_> on the other hand the type classes also express certain major abstractions inside the system of types like Functor or whatever; but this is a secondary effect, so to speak
23:33:41 <beaky> ah
23:35:03 <applicative_> I think the distinction is explained pretty well in lyah no? http://learnyouahaskell.com/types-and-typeclasses
23:35:45 <beaky> if a typeclass is a set of types
23:35:54 <beaky> is there anything like a set of typeclasses?
23:37:01 <beaky> I heard of generalized abstract data types
23:38:18 <applicative_> a class can have a superordinate class as a constraint, thus Ord presupposes Eq -- you cant define > and < without == first
23:39:24 <applicative_> if you type :i Ord you can see this
23:39:40 <applicative_> inside ghci, I mean; or :info Ord
23:39:40 <Enigmagic> :r
23:39:45 <Enigmagic> damnit.
23:40:01 * kallisti :: Human
23:41:15 * hackagebot hamlet 1.1.3.1 - Haml-like template files that are compile-time checked  http://hackage.haskell.org/package/hamlet-1.1.3.1 (MichaelSnoyman)
23:41:17 * hackagebot persistent 1.1.3.1 - Type-safe, multi-backend data serialization.  http://hackage.haskell.org/package/persistent-1.1.3.1 (MichaelSnoyman)
23:46:19 * hackagebot yesod 1.1.7.2 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-1.1.7.2 (MichaelSnoyman)
23:46:21 * hackagebot persistent-postgresql 1.1.2.1 - Backend for the persistent library using postgresql.  http://hackage.haskell.org/package/persistent-postgresql-1.1.2.1 (MichaelSnoyman)
23:46:23 * hackagebot yesod-core 1.1.7 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-core-1.1.7 (MichaelSnoyman)
23:46:25 * hackagebot yesod-static 1.1.1.2 - Static file serving subsite for Yesod Web Framework.  http://hackage.haskell.org/package/yesod-static-1.1.1.2 (MichaelSnoyman)
23:46:27 * hackagebot yesod-test 0.3.3 - integration testing for WAI/Yesod Applications  http://hackage.haskell.org/package/yesod-test-0.3.3 (MichaelSnoyman)
23:48:00 <applicative_> hackage is being repeatedly hit from someplace near the Lebanon border
23:52:07 <startling> so why isn't there a IOT?
23:56:02 <Enigmagic> unsafePerformIO to the rescue?
23:56:50 <Heffalump> startling: how would it work?
23:57:13 <Enigmagic> "i want my IO somewhat arbitrarily ordered"
23:59:23 <simpson> I thought that this is why MonadIO exists.
