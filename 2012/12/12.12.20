00:00:36 <Enigmagic> i was trying to build the date math lenses by requiring a state transformer that held all the intermediate results
00:01:10 <Enigmagic> that made the regular case of 'give me the hour of the day' messy if there was no intention of doing more complicated updates
00:02:29 <startling> does anybody actually use the Text.Parsec.Language stuff?
00:02:58 <shachaf> Hmm, actually what I said doesn't really match the operations you want.
00:03:22 <shachaf> Because you want (Hour -> Day -> Day), just one that silently truncates the hour or something.
00:03:27 <shachaf> (Right?)
00:03:40 <shachaf> Oh, maybe that does give it to you.
00:03:57 <shachaf> Oh, but you want to be able to view the hour.
00:04:41 <startling> is there a decimal package that's not as bizarre as @hackage decimal ?
00:04:53 <Enigmagic> shachaf: well what i really want is the abillity to add an hour to the day and have it work properly, and to view a date in some timezone and set some portion of it (like hour and minute)
00:05:14 <startling> essentially I want a lossless format to parse numbers into.
00:05:33 <shachaf> Enigmagic: And a day is just a day, not a complete date?
00:06:09 <shachaf> It seems like if you have Date = (Year,Month,Day,Hour,Minute,Second,Timezone) or something, that gives you a natural thing to do when you give it an hour past 24
00:06:33 <shachaf> Oh, but that's still not a legal lens.
00:06:59 <Enigmagic> shachaf: i need to regularly do actions like 'create a time that is 1800 minutes since midnight on 8/1/2012 in new york', or 'find the last friday in london'
00:08:01 <ClaudiusMaximus> startling: Rational ?
00:08:49 <startling> ClaudiusMaximus: oh huh
00:09:15 <shachaf> Hmm.
00:09:48 <ClaudiusMaximus> > read "123.45641246184761284761287461" :: Rational
00:09:49 <lambdabot>   *Exception: Prelude.read: no parse
00:10:01 <ClaudiusMaximus> ah
00:10:07 <Enigmagic> shachaf: naively it seems like '(parse "8/1/2012" :: Time "America/New_York") . minuteOfDay ~= 1800' would be fine to do the first part.
00:10:09 <ClaudiusMaximus> > readFloat "123.45641246184761284761287461" :: Rational
00:10:11 <lambdabot>   Couldn't match expected type `GHC.Real.Rational'
00:10:11 <lambdabot>              with actual t...
00:10:27 <Enigmagic> shachaf: with the appropriate operators, since i'm just making shit up.
00:10:31 <ClaudiusMaximus> huh, stupid Numeric module
00:11:02 <shachaf> Enigmagic: And the question is what should happen if that number is > 24*60*60 or < 0?
00:11:29 <shachaf> Er, just 24*60
00:11:37 <Enigmagic> shachaf: the question is what happens if i want to add 10 minutes to a time, not just set it to a constant
00:12:10 <shachaf> Well, there's an isomorphism from any time to "seconds since 1970" or whatever scheme you want to use.
00:12:33 <shachaf> So if you take a view like that of a time, you can easily add N minutes to it.
00:13:09 <Enigmagic> sorta, except i need nanoseconds resolution. and tsuru uses milliseconds (i think), and deutsche bank uses something else, and standard chartered uses their own thing too
00:13:49 <shachaf> Well, any isomorphism onto some simple time format should work.
00:14:01 <Enigmagic> some other companies use their own formats and calendars, i'm trying to find something that more or less works for arbitrary representaitons
00:14:17 <shachaf> I'm not saying you have to use this representation.
00:14:44 <shachaf> I'm saying define foo :: Iso' MyComplicatedTime SomeSimpleTime, and then operate on the time with that.
00:14:48 <Enigmagic> internally we break stuff down into year/month/day/hour/second/nanosecond
00:15:21 <Enigmagic> but other companies don't, so i'd like the package to work over arbitrary representations without requiring conversion to a common type
00:16:10 <Enigmagic> (that way we might all be able to actually use a datetime-lens package instead of assuming people use the time package)
00:17:04 <shachaf> Well, these lenses/isomorphisms are just "views" into your time format.
00:17:21 <shachaf> I must be misunderstanding, though.
00:18:22 <shachaf> What sorts of things are you imagining in datetime-lens, if it can't refer to a common time type?
00:18:31 <Enigmagic> they are, the question is can a standard be agreed on. it's easier to get adoption if they can drop in with minimal effort and runtime overhead into an existing codebase
00:19:35 <Enigmagic> converting between two representations has minimal overhead until you're looking at an options feed
00:19:49 <shachaf> Fair enough.
00:20:06 <Enigmagic> so the goal would be to have an 'hour' lens that can work over any time representation, with some glue.
00:20:11 <shachaf> So you want something that operates directly on some particular representation, and also acts like a legal lens.
00:20:23 <Enigmagic> yep
00:20:47 <shachaf> That sounds tricky.
00:21:00 <shachaf> Well, you can make a separate Setter that would be legal and a Getter than would be legal.
00:21:23 <Enigmagic> where most of the community would probably use the time package, and most commercial users would use their own internal package until we can build a time package that acutally works for everyone (if ever)
00:22:00 <shachaf> Because even if adding 10 minutes will overflow, presumably your setter still satisfies onMinutes f . onMinutes g = onMinutes (f . g)
00:22:18 <shachaf> So the obvious solution for making it legal is to provide a separate getter and modifier.
00:22:25 <shachaf> (But that's kind of annoying.)
00:22:35 <Enigmagic> that's what i was trying out last night
00:23:02 <shachaf> Was there an issue with that?
00:23:27 <Enigmagic> it's just annoying
00:23:42 <shachaf> Agreed.
00:23:57 <Enigmagic> which is why i originally started by trying to change the container type if a lens was modified, but that's not legal
00:25:01 <startling> is there a good way to parse a Rational out of a number written like
00:25:04 <shachaf> I think that's somewhat more illegal than violating the view l (set l x s) = x law
00:25:10 <startling> "13" or "3.14"?
00:25:17 <Enigmagic> anyways i'm just spamming in here now, i have a few other ideas i'm toying with that might be legal and could be fast enough to use
00:26:20 <shachaf> Would something like using a "nanoseconds since epoch" representation along with some RULES not work?
00:26:23 <fmap> startling: `rational' from attoparsec?
00:26:52 <shachaf> Er, that doesn't actually help you, I guess, if you really do want a lens for "hours since midnight".
00:27:18 <startling> fmap: :/ already wrote most of my code for parsec
00:27:39 <Enigmagic> shachaf: yeah, i really do need compounded (?) lenses... day of week, day of year, hours since midnight, minutes since midnight, etc
00:28:15 <shachaf> What happens when you set day of week to 8? Does it modify a different part of the date?
00:29:01 <Enigmagic> shachaf: well if you could pick the resolution it'd be fine to say 'hours since epoch += 1'
00:29:01 <shachaf> I.e. set hours 25 ("tuesday 08:00") = "wednesday 01:00"?
00:29:22 <Enigmagic> shachaf: if it's just 'hours += 1' it would need to roll the date over at midnight
00:29:47 <shachaf> But that modifies a different part of the structure, right?
00:29:52 <startling> Enigmagic: but then you lose the set/view correspondence
00:30:31 <Enigmagic> startling: that's why we're having this conversation ;)
00:30:54 <shachaf> I think it's relatively important that a lens focuses on one specific part of the structure and doesn't modify a different part.
00:31:14 <Enigmagic> startling: and most of the existing date lenses don't work right wrt the laws anyways
00:31:24 <startling> Enigmagic: people are bad at lenses. :/
00:32:12 <shachaf> The epoch representation seems like the obvious solution to the issue, but it doesn't let you view "hours since midnight".
00:33:02 <Enigmagic> shachaf: but setters allow updates, not just assignments from a constant right?
00:33:33 <shachaf> Right, but updates should be fine.
00:33:38 <sw2wolf> Is it possible to embed a light weight haskell REPL into xmonad ? same as CL repl in stumpwm
00:34:01 <shachaf> Setters just need to obey the functors laws -- over l f . over l g = over l (f . g), over l id = id
00:34:31 <Enigmagic> shachaf: so they can roll a date over on hours += 25?
00:34:48 <shachaf> Yes, that sounds fine to me.
00:34:56 <Enigmagic> ok, stuff to think about
00:35:16 <Enigmagic> think i spent enough time on this tonight, need to do some regular work again :-)
00:35:46 <shachaf> So a setter + a viewer should be fine for what you want, but it's annoying that you can't stick them together in one operation.
00:35:53 <shachaf> Given that a lens is exactly a setter + a getter.
00:35:57 <shachaf> Enigmagic: Fair enough. :-)
00:36:23 <Enigmagic> shachaf: that was the thinking the led me into last night's issue :-)
00:36:26 <fmap> startling: fortunately translation from parsec to attoparsec is mostly mechanical :)
00:37:09 <fmap> sw2wolf: you probably get better answers in #xmonad, but I use scratchpads with ghci open in them
00:38:04 <sw2wolf> fmap: i want to install xmonad into some box without GHC
00:38:17 <shachaf> The issue here isn't just that when you set something it gets lost, it's that a lens modified a different part of the structure from the part it's supposed to be focusing on.
00:38:18 <startling> fmap: yeah, heh, just did
00:38:33 <shachaf> This seems like a broader issue than working with times, and I'm not sure what a good solution is.
00:39:20 <shachaf> I guess a related issue is that you can't have a legal Iso MyTimeFormat (Hour,Minute,Second)
00:39:50 <shachaf> If you could make that, then you could just compose it with _3 or something.
00:40:30 <Enigmagic> shachaf: i think it's the notion of having legal or canonical values... urls also have this property, arbitrary text is not necessarily a url but a url is text
00:40:42 <M30W> any (<=5) [1,3,7] -- How could one do an exact match?
00:40:46 <M30W> Err. Nvm.. == :D
00:40:52 * M30W sigh.
00:41:03 <startling> hehe
00:41:11 <M30W> Fail of the year ^_^
00:41:13 <startling> > 5 `elem` [1, 3, 7]
00:41:14 <lambdabot>   False
00:41:18 <Enigmagic> other times there is just a canonical form, like times. the 25th hour might be ok as an intermediate representation but it needs to be legalized later
00:41:23 <M30W> -_-
00:41:26 <M30W> Seriously!
00:41:29 <M30W> Nice
00:41:42 <startling> M30W: yeah, elem is another way. doesn't make much of a difference though
00:42:08 <M30W> startling: Doesn't make much of a difference, but it is slightly cleaner
00:42:13 <Enigmagic> i can represent that with an ADT or GADT but not without requiring users to change their types. making a "data MightNotBeLegal a" to wrap it helps work around it but that violates the lens laws.
00:42:30 <M30W> startling: This is haskell, almost always a better way to do things :P
00:42:59 <startling> M30W: yeah, luckily (?) there are thousands of variations of the list functions in the prelude
00:43:14 <M30W> Heh
00:43:16 <shachaf> Enigmagic: Right. One type is too big for the thing you really want to talk about.
00:43:39 <M30W> lambdabot: What modules has it loaded?
00:44:00 <shachaf> Maybe some notion of a "one-directional isomorphism" is relevant.
00:45:08 <shachaf> So you have (BigType -> SmallType, SmallType -> BigType), where converting from the big type to the small type might normalize it first.
00:45:17 * shachaf might just be saying nonsense at this point.
00:46:52 <Enigmagic> shachaf: i think of it more like (Type Canonical -> Type NotCanonical, Type NotCanonical -> Type Canonical)
00:47:51 <shachaf> So n2c (c2n x) = x, but c2n (n2c x) might /= x
00:48:09 <Enigmagic> shachaf: yeah
00:48:32 <M30W> Is there any package that supports downloading through http, ftp, torrent, direct, etc?
00:48:44 <M30W> direct as in.. nc host port > file
00:48:55 <M30W> No protocole but ip ^
00:49:58 <Enigmagic> M30W: just piping a socket to disk? the network package should give you enough rope to do that
00:50:28 <Enigmagic> if you want http or other protocol support you'll need to pick more specific packages
00:50:45 <M30W> Enigmagic: Kinda.. Needs to track progress if available too.
00:50:47 <shachaf> I doubt there's any package that does all of those, but there's probably at least one package for each one.
00:51:17 <M30W> http://hackage.haskell.org/package/download vs http://hackage.haskell.org/package/download-curl
00:51:20 <M30W> O.o
00:51:49 <M30W> That also covers xml crap which I won't be using.
00:52:04 <M30W> Acturally.. Not a bad idea, support for RSS feeds like podcasts.. Hmm..
00:52:33 <M30W> bloody hell.. Wtf xorg?
00:52:37 <M30W> Brb.. gotta reboot
00:53:46 <mightybyte> Is there an existing way to convert [Either a b] to Either [a] [b]?
00:54:07 <companion_cube> how would it choose a side?
00:54:19 <ivanm> you could get ([a],[b])
00:54:20 <mightybyte> Ugh, yeah.
00:54:20 <hpaste> mw pasted “rle” at http://hpaste.org/79548
00:54:21 <companion_cube> I mean, what would [Left 1, Right "foo"] return?
00:54:27 <ckerr> I'm wanting to create a super-set language of iptables based around the iptables-helpers package (which uses Parsec). I want to keep the existing iptables-helpers clean of any super-language constructs, but would like to extend its data-types (and reuse its parser functions). The issue I face is that I can't extend inherit data-types (AFAIK), in that if iptables-helpers has a type-level parser 'data' type Rule, then I can't say 'give me own version of Rule,
00:54:30 <mightybyte> It's too late.
00:54:32 <ivanm> @type partitionEithers
00:54:34 <lambdabot> [Either a b] -> ([a], [b])
00:54:35 <mightybyte> I'm not thinking straight.
00:54:36 <mightybyte> Yeah
00:54:40 <marekw2143> hello, why following code doesn't compile: http://hpaste.org/79548?
00:54:57 <M30W> Bloody intel driver seems to have gotten really unstable in the past week. :(
00:55:26 <ivanm> marekw2143: what's the error message?
00:55:37 <mightybyte> I guess I want it to aggregate all the Lefts
00:55:46 <ivanm> but x == [] is better expressed as null x
00:55:53 <ivanm> mightybyte: fst . partitionEithers ?
00:56:03 <mightybyte> Nah, that's just lefts
00:56:11 <mightybyte> I'm working in the EitherT monad.
00:56:25 <marekw2143> ivanm: parse error( possibly  incorrect indentation)
00:56:29 <mightybyte> EitherT [String] a
00:56:47 <ivanm> marekw2143: oh, indentation issue for ra
00:56:58 <mightybyte> And I'm running a bunch of EitherT String computations and I want them to fold in nicely.
00:57:13 <marekw2143> ivanm: but what's wrong with that? how should it be indented?
00:57:14 <Enigmagic> mightybyte: fold . lefts ?
00:57:22 <mightybyte> I guess this might not fit a pre-existing pattern.
00:57:36 <Enigmagic> oh EitherT
00:57:42 <Enigmagic> i dunno :P
00:57:49 <M30W> Who was I talking to before reboot
00:57:50 <M30W> ?
00:57:50 <shachaf> EitherT tends to be about early termination, not aggregating.
00:57:58 <shachaf> That sounds a bit more like WriterT :-)
00:58:12 <hpaste> ivanm annotated “rle” with “rle (annotation)” at http://hpaste.org/79548#a79549
00:58:23 <mightybyte> shachaf: Yeah, that's the fundamental issue that I'm grappling with.
00:58:26 <ivanm> marekw2143: ^^
00:58:30 <mightybyte> I'm wanting a little of both.
00:59:07 <marekw2143> ivanm: thanks, so "|" character should be indented?
00:59:17 <ivanm> yes, relative to the function it's attached to
00:59:29 <M30W> shachaf, Do you think "download" or "download-curl"
00:59:30 <M30W> ?
01:00:26 <ivanm> marekw2143: note also that I changed the variable name for ra so as to avoid conflating them
01:01:07 <marekw2143> i'm just haskell beginner, need some time to get familiar
01:01:56 <shachaf> M30W: How should I know?
01:02:24 <marekw2143> thanks ivanm
01:02:31 <ivanm> np
01:04:21 <M30W> shachaf: You might. :) But apparently no. :(
01:04:27 <M30W> Thanks anyway.
01:05:50 <M30W> http://code.haskell.org/~dons/code/download/Network/Download.hsc <- nothing about monitoring the progress of the download, canceling or anything. D: :|
01:06:29 <shachaf> If it says dons is the maintainer, that's just another way of saying it's unmaintained.
01:08:17 <M30W> dons? So.. Not a real user?
01:08:28 <M30W> DonaldStewart
01:08:30 <shachaf> Just busy.
01:08:36 <M30W> Okay.
01:08:49 <Ralith> speaking of which
01:08:57 <Ralith> what's bos up to these days
01:09:41 <Enigmagic> hacking python at facebook! ;-)
01:09:55 <Enigmagic> err php
01:09:57 <Enigmagic> whatever they use
01:10:07 <Enigmagic> both i guess
01:10:18 <Ralith> not unrelatedly, what's the procedure for taking over maintainership of something on hackage?
01:10:34 <shachaf> Ralith: Maintainership of what?
01:10:51 <shachaf> If you can get in contact with the official maintainer, get in contact with the official maintainer.
01:11:02 <shachaf> If you can't I think you send some emails or something.
01:11:17 <shachaf> (You can also just overwrite their package with a new version, but it's considered rude.)
01:11:25 <Ralith> heh
01:11:25 <Ralith> kay
01:14:18 <osa1> Ralith: will you take llvm's ownership ?
01:14:48 <Ralith> osa1: If nobody else steps up, I'd rather take ownership than let it continue to be unmaintained.
01:16:05 <Enigmagic> Ralith: i'd certainly appreciate someone trying to merge all the branches. i've been porting it (slowly) over to the type-nats ghc branch too ... https://github.com/alphaHeavy/llvm/commits/gep-nats
01:16:18 <Enigmagic> even if it's not officially updated on hackage
01:16:36 <Ralith> one of the reasons I might not be the best person for this is because I don't really care about the high-level bindings
01:17:28 <Ralith> as they seemingly require absurd amounts of effort to use for a compiler backend, which is the only usecase I'm interested in
01:17:57 <Enigmagic> Ralith: well it's a stack, better mid-level bindings helps out with the high level bindings too
01:18:31 <Enigmagic> one of the problems with the current package is that it assumes you're either doing raw ffi or you're doing very high level work
01:18:36 <Ralith> right
01:18:47 <Ralith> and the mid level is what I want to, and am qualified to, work on
01:19:04 <Enigmagic> that's very valuable, even for people with high level compilers like me :P
01:19:04 <Ralith> (well, what I *do* work on, it's just doomed to sit in a pull request)
01:20:03 <Enigmagic> and i'm happy to send pull requests with bug fixes or new features if you're willing to do the general maintainership stuff
01:20:23 <Ralith> what I'm saying is just that I'm not a good person to judge whether or not changes to the high level stuff are appropriate to merge.
01:21:58 <Enigmagic> i can help out with that part
01:22:24 <Ralith> okay
01:22:40 <Ralith> I'll see about emailing bos next time I come back to the bindings, then
01:23:04 <Enigmagic> sounds good
01:36:37 <neutrino> hi
01:37:02 <neutrino> is there a good tutorial of stm design techniques or data structures?
01:37:58 <rfw> @pl \x -> (x, x)
01:37:58 <lambdabot> join (,)
01:39:29 <fmap> @ty join (&&&) id
01:39:31 <lambdabot> c -> (c, c)
01:39:58 <ivanm> neutrino: SPJ's original paper, and possibly his chapter from Beautiful Code?
01:40:12 <ivanm> fmap: show-off
01:40:34 <neutrino> read that
01:40:41 <neutrino> insatiating
01:40:59 <neutrino> *unsatiating
01:41:03 <Enigmagic> neutrino: i'd say the answer is not really
01:42:18 <pnielsen> ivanm, neutrino: http://research.microsoft.com/en-us/um/people/simonpj/papers/stm/index.htm  - Composable memory transactions and Lock-free data structures using STM in Haskell especially
01:42:47 <ivanm> pnielsen: well, yes, that's what I was referring to...
01:42:59 <pnielsen> ivanm: I was just adding to what you said. No correction.
01:42:59 <neutrino> yeah read that
01:43:05 <neutrino> all of it
01:43:15 <neutrino> except for the one that introduces "check"
01:43:30 <neutrino> since it's not in ghc so far
01:43:35 <neutrino> speaking of which
01:43:43 <neutrino> is there any plan to implement check in stm?
01:43:52 <ivanm> what does check do?
01:44:26 <neutrino> it's for stating invariants
01:44:30 <neutrino> but i only skimmed
01:44:45 <mreh> if only I could derive exceptions from an enumeration
01:45:06 <neutrino> i think you give haskell a property :: STM Bool which gets run every time an STM action is performed..
01:45:08 <pnielsen> ivanm: "The idea is simple: a programmer writes check E where E is an expression that should be preserved by every atomic update for the remainder of the program's execution. We have extended STM Haskell to dynamically evaluate check statements atomically with the user's updates: the result is that we can identify precisely which update is the first one to break an invariant."
01:45:20 <neutrino> ah yes, every time it gets committed
01:46:13 <ivanm> that sounds like it could get expensive in production code
01:46:50 <neutrino> so does stm, but it works
01:47:02 <neutrino> i think there's little reason to worry
01:47:16 <neutrino> but i'm surprised about the "for the remainder of the program's execution" part
01:47:27 <neutrino> i thought it was, well, composable.
01:47:46 <neutrino> or is it something that gets garbage collected when the data it's checking gets gc'd?
01:48:26 <pnielsen> http://hackage.haskell.org/packages/archive/stm/2.4.2/doc/html/src/Control-Monad-STM.html#check
01:48:38 <pnielsen> check :: Bool -> STM ()     check b = if b then return () else retry
01:48:46 <johnw> is there any way to download all the Haddock HTML documentation that's on haskell.org?
01:49:02 <johnw> i want to populate my .cabal/share/doc, but without actually building all the packages
01:49:24 <pnielsen> seems like it returned () or undefined in earlier versions
01:49:36 <hpaste> mw pasted “rle” at http://hpaste.org/79550
01:50:23 <mreh> what's a nice way of wrapping up FFI bindings that return error codes and use in-out parameters?
01:50:53 <hpaste> mw pasted “rle” at http://hpaste.org/79552
01:50:54 <mreh> If i'm just going to throw exceptions for non-zero error codes then I'd quite like a way of catching specific errors
01:51:17 <mreh> IO (Either e a) is the best I can think of so far
01:51:25 <marekw2143> why following code doens't work for strings like "aabbbcc": http://hpaste.org/79552
01:52:04 <marekw2143> I also don't understand why its type is: t->[a] -> [(a, Int)]
01:52:13 <mreh> :t group
01:52:14 <lambdabot> Eq a => [a] -> [[a]]
01:52:17 <Botje> marekw2143: that definition expands to re x y = map f (group y)
01:52:21 <marekw2143> why isn't it just [a] -> ( [a], Int])
01:52:23 <mreh> group "aabbbccc"
01:52:31 <mreh> ? group "aabbbccc"
01:52:31 <mreh> > group "aabbbccc"
01:52:33 <lambdabot>   ["aa","bbb","ccc"]
01:52:45 <Botje> marekw2143: if you drop the x from the definition of re it's correct.
01:54:35 <mreh> it takes the first argument, discards it and returns your desired function, that's why the compiler things it's a function of two args
01:58:48 <neutrino> actually, IS check not implemented?
01:58:50 <neutrino> i'm not sure
01:58:55 <neutrino> because it looks like it is
01:59:10 <neutrino> http://hackage.haskell.org/packages/archive/stm/2.4.2/doc/html/src/Control-Monad-STM.html#check
01:59:57 <Ralith> anyone have an implementation of log on nats?
02:00:12 <Ralith> (for integer bases, of course)
02:00:49 <shachaf> Ralith: Well, the function "log" in Haskell is a "natural" log.
02:01:10 <Ralith> shachaf: that is entirely not what I mean :P
02:01:22 <Ralith> given data Nat = O | S Nat
02:01:28 <shachaf> Yes, yes.
02:01:50 <Ralith> I want log :: Nat -> Nat -> Nat where log 2 32 == 5
02:01:58 <Ralith> (with appropriate Num instance)
02:02:56 <Ralith> I guess it'd have to be Maybe
02:02:59 <neutrino> what should log 2 31 return?
02:03:02 <Ralith> hm
02:03:04 <neutrino> yeah.
02:03:10 <neutrino> in which case the code becomes easy.
02:03:35 <neutrino> and in fact, just tail recursion with a carried accumulator
02:04:59 <johnw> Ralith: see the definition of log2_aux on http://coq.inria.fr/V8.2pl1/contribs/CoLoR.Util.Nat.Log2.html
02:05:10 <johnw> that should be easy enough to port to Haskell
02:05:15 <Ralith> thanks!
02:05:26 <Ralith> heh, of course it'd be from coq code
02:05:40 <johnw> well, they do love nats, those guys
02:05:46 <shachaf> Assuming you're only taking logBase 2.
02:06:10 <shachaf> If that's all you need your life is much easier, of course.
02:06:20 <shachaf> @google highest set bit
02:06:21 <lambdabot> http://stackoverflow.com/questions/53161/find-the-highest-order-bit-in-c
02:06:22 <lambdabot> Title: Find the highest order bit in C - Stack Overflow
02:06:31 <johnw> true
02:06:32 <Enigmagic> there is an assembly instruction for it
02:06:35 <johnw> that link was only for log2
02:06:50 <neutrino> so you're back to tail recursion with an accumulator.
02:07:26 <Ralith> shachaf: poke
02:07:43 <neutrino> you COULD first make a quick log in floats to see if it could work out at all
02:07:44 <fmap> johnw: what's `struct' means?
02:07:45 <shachaf> bsr?
02:07:52 <Ralith> johnw: fortunately that's actually all I needed.
02:07:53 <shachaf> Ralith: ?
02:08:00 <Ralith> shachaf: see #idris
02:08:06 <fmap> err
02:08:13 <shachaf> Ralith: I don't know Idris, man!
02:08:16 <fmap> johnw: what does `struct' mean?
02:08:34 <shachaf> Anyway, what's the issue?
02:08:42 <Ralith> shachaf: that's no excuse to ignore the channel!
02:08:52 <Enigmagic> shachaf: yeah, was implemented on the i7 i think. llvm and gcc have intrinsics for it though
02:08:59 <Ralith> shachaf: actually I think I might have it solved now.
02:09:01 <bartavelle> fmap, that you are about to define a "structure" if you are talking C
02:09:08 <shachaf> Enigmagic: x86 does not have a Nat type. :-)
02:09:21 <Ralith> heh, if only
02:09:31 <Enigmagic> shachaf: i have a modified process that does ;)
02:09:44 <Enigmagic> processor
02:09:52 <fmap> bartavelle: I don't think coq has c structs
02:10:09 <johnw> fmap: I'm not entirely sure
02:10:09 <shachaf> Given that Ralith is doing this thing at the type level, I'd be very surprised if LLVM instrinsics are going to help much.
02:10:24 <companion_cube> there should be records in coq
02:10:38 <bartavelle> I believe he was talking about "struct" in coq
02:10:47 <johnw> it seem to specify the "rigid parameter" of the function
02:10:54 <johnw> as talked about in section 2.3 of http://coq.inria.fr/V8.2pl1/refman/Reference-Manual004.html
02:10:57 <johnw> i'd ask in #coq
02:11:09 <shachaf> There should really a name for lenslikes/symmteric lenslikes.
02:11:13 <Enigmagic> shachaf: i was talking about bsr, not doing it at the type level
02:11:26 <Enigmagic> if i was doing it at the type level i'd implement it in ghc :P
02:11:56 <shachaf> Oh great, BSR is different on amd64 and Intel 64.
02:13:40 <shachaf> What was that trick that edwardk used that involved de Bruijn sequences?
02:14:15 <shachaf> Oh, https://en.wikipedia.org/wiki/Find_first_set
02:14:26 <shachaf> That's for trailing zeros.
02:15:31 <shachaf> De bruijn sequences are the future.
02:15:49 <Jafet> "find first set (ffs)"
02:16:39 * hackagebot conduit-resumablesink 0.1 - Allows conduit to resume sinks to feed multiple sources into it.  http://hackage.haskell.org/package/conduit-resumablesink-0.1 (AndrewMiller)
02:20:40 <fmap> johnw: interesting, thanks
02:28:01 <Scriptal> Hello?
02:28:19 <simpson> Howdy.
02:28:28 <Jafet> @hello
02:28:28 <lambdabot> Maybe you meant: help tell
02:29:13 <Scriptal> Okay, I'm on the "try haskell" webpage
02:29:38 <Scriptal> So...
02:29:45 <Scriptal> I have some questions
02:29:55 <Scriptal> That I'm sure you all can answer
02:30:05 <Scriptal> If you don't mind that is.
02:30:15 <Jafet> Don't worry, the remaining people don't mind answering newbie questions.
02:30:25 <shachaf> Scriptal: Now look what you did.
02:30:29 <shachaf> Everyone left because of you.
02:30:34 <Jafet> What are the questions?
02:30:40 <shachaf> (Don't ask if you can ask a question. Just ask the question.)
02:30:50 <Scriptal> I don't believe I'm a newbie
02:30:52 <Scriptal> anywho
02:31:03 <shachaf> lens now exports a function called "unalgebraically"
02:31:16 <shachaf> Well, Lens.Internal exports it, at any rate.
02:31:26 <Scriptal> I'm a sophomore CS major in college and have been programming since junior year of high school. What on earth is functional programming?
02:31:34 <Jafet> categorytheoretically?
02:31:42 <Jafet> Programming that isn't dysfunctional
02:31:43 <Hafydd> You are a newbie.
02:31:44 <Jafet> Duh
02:31:53 <shachaf> Scriptal: It's a meaningless phrase.
02:32:17 <A1kmm> Scriptal: http://en.wikipedia.org/wiki/Functional_Programming
02:32:29 <Scriptal> Let me ask something more straightforward.  Does the order of things matter in haskell? in a completely literal sense
02:32:52 <shachaf> Does anything truly matter?
02:32:56 <Hafydd> The order of textual characters?
02:32:58 <Hafydd> Yes.
02:33:02 <`ramses> Scriptal: define order :)
02:33:12 <Jafet> I program in chaos
02:33:19 <shachaf> Jafet *is* chaos.
02:33:22 <Scriptal> Order: a sequence of definitions?
02:33:27 <Hafydd> . o O (A programming language with semantics defined up to the set of characters occuring in the source code)
02:33:42 <A1kmm> Scriptal: You can write let { y = x + 1; x = 1; } in y and that expression will evaluate to 2
02:33:43 <`ramses> the order of definitions in a haskell file? no, doesn't matter
02:33:44 <Saizan> Scriptal: depends e.g. definitions can be given in any order, but the order of patterns within a single definition matters
02:34:01 <Hafydd> . o O (or the multiset)
02:34:42 <Scriptal> hm. okay
02:34:48 <simpson> > let y = x + 1; x = 1 in y
02:34:50 <lambdabot>   2
02:35:30 <benj_> the order in which sub-expressions are evaluated does not matter in pure code
02:35:39 <Scriptal> how is this better than something imperitive like C
02:35:55 <Scriptal> I could say:
02:36:00 <Scriptal> int x = 1;
02:36:07 <Scriptal> int y = x+1;
02:36:23 <shachaf> It's not. Haskell is no good compared to C.
02:36:24 <Jafet> In that case, all code that is actually run on a computer is impure code.
02:36:29 <Jafet> @quote einstein
02:36:30 <lambdabot> monochrom says: einstein's theory implies that haskell cannot be faster than c
02:37:17 <xlr> lol
02:37:41 <Scriptal> Then... What is the advantage?  I come from a world of Java, C/++, python, and perl so I don't have any experience with something like this
02:38:05 <Hafydd> It's cute.
02:38:13 <Jafet> It creates employment for grad students
02:38:17 <`ramses> I like the way of thinking better
02:38:20 <A1kmm> Scriptal: Obviously there is no universal definition of better; but in your C example, x is mutable state, and sometimes it is easier to reason about functional programs.
02:38:21 <Enigmagic> i taught Haskell how to cook breakfast
02:38:27 <Saizan> Scriptal: not every feature is an advantage
02:38:47 <Hafydd> It has nice invariants.
02:39:11 <`ramses> It allows for equational reasoning
02:39:16 <Saizan> Scriptal: but in this case it just lets you have mutually recursive definitions without worrying about it
02:39:29 * shachaf manages to worry.
02:39:43 <`ramses> it has scary names such as "monad" which make you feel smart :)
02:39:45 <neutrino> ok, i think "check" is probably implemented, given that it is used in Beautiful Concurrency
02:39:57 <johnw> Scriptal: i'm not sure an informal discussion on IRC is the best way to be introduced to such a fundamentally new concept; I'd recommend doing a bit of reading and coming back after
02:39:58 <Saizan> s/worry about it/extra syntax overhead/ -- happy?:)
02:40:12 <bitonic> yes, Haskell main advantage is that it buys you the right to smugness.
02:40:50 <Scriptal> I've been looking around for a language to learn that isn't "mainstream" something to set me apart
02:40:52 <shachaf> bitonic: I don't need Haskell to be smug.
02:40:55 <rtharper_> lol brilliant, bitonic
02:41:05 <johnw> Scriptal: then i'd definitely recommend Haskell
02:41:12 <bitonic> Scriptal: jokes aside, it does introduce you to many concepts that other PLs wouldn’t, so it’s great for learning
02:41:14 <Jafet> @quote learn.agda
02:41:14 <lambdabot> ManuelChakravarty says: We used to say, "Learn Haskell, it makes you a better Java programmer." Now we say, "Learn Agda, it makes you a better Haskell programmer."
02:41:20 <rtharper_> Oh man, does being a Haskell programmer make me a hipster
02:41:22 <rtharper_> hahaha
02:41:29 <shachaf> I recommend not trying to set yourself apart.
02:41:48 <Jafet> shachaf: but, but, everyone else is doing that nowadays.
02:41:55 <bitonic> Jafet: the real programmer programs in yet-to-be-implemented theories.
02:42:01 <neutrino> Scriptal: the advantage of functional languages, and haskell in particular, is that while they're only similar and not exactly the same as C/C#/Java/Python, they are built up in a way that allows for very advanced, automatic, analysis of your code
02:42:28 <neutrino> Scriptal: this is a great thing once you understand what it buys you, but it'll take a couple years of using haskell to really appreciate it
02:42:52 <Scriptal> Why? It looks great on a resume?  "Oh, you know all the languages you were taught in your college classes, but I see you have a passion in this field outside because you know a language most others dont"
02:43:06 <neutrino> haha
02:43:12 <neutrino> @protontorpedo
02:43:12 <lambdabot> Im really only a bash person and even then Im tin
02:43:44 <bitonic> Scriptal: as I said, Haskell will teach you stuff that other PLs won’t if just because of the culture surrounding it.  I probably learnt as much in this channel than in school
02:43:57 <shachaf> So you want to learn Haskell to impress people into thinking that you learn things for reasons other than impressing people?
02:44:05 <bitonic> of course the language itself reflects quite thought out choice
02:44:20 <neutrino>  <lambdabot> here is the big one: is it mroe prctical than say python?
02:44:30 <neutrino> that's the one i was looking for.
02:44:33 <Scriptal> I want to learn haskell because i don't understand it
02:44:41 <neutrino> that's a good reason Scriptal
02:44:49 <shachaf> I recommend Malbolge.
02:44:51 <johnw> yeah, that's actually a really good reason
02:44:53 <neutrino> widening your horizons is very fun
02:44:56 <`ramses> @where lyah
02:44:56 <lambdabot> http://www.learnyouahaskell.com/
02:44:57 <neutrino> don't listen to shachaf
02:45:05 <`ramses> Scriptal: ^ start with that
02:45:25 <`ramses> he explains the benefits of haskell quite good imho
02:45:25 <Hafydd> http://www.haskell.org/onlinereport/haskell2010/
02:45:31 <shachaf> hi Argue
02:45:35 <Hafydd> When you get sick of it, start with that.
02:45:38 <Jafet> Haskell works anywhere, even under bridges.
02:45:39 <neutrino> Scriptal: i've been motivated by something similar. i was looking for more powerful languages, but every time i switched it was basically the same lang as before, just with a couple nice minor additions thrown in
02:45:45 <Argue> sup shachaf
02:45:49 <neutrino> so the ceiling was pretty low
02:46:00 <neutrino> in haskell the ceiling is so high i will probably never bump into it
02:46:11 <shachaf> Argue: How're the lenses going?
02:46:31 <Argue> oh, i didn't really try em out -_-
02:46:33 <Scriptal> @neutrino That's what i've been going through
02:46:34 <lambdabot> Unknown command, try @list
02:46:45 <Argue> unless you mean the lenses of the camera on the raytracer i'm writing :v
02:46:49 <neutrino> well then you'll find yourself right at home
02:46:53 <shachaf> Argue: That works!
02:47:02 <shachaf> Argue: ":v", eh?
02:47:06 <Jafet> edwardk should write a raytracer
02:47:14 <Argue> :v is a perfectly good smiley
02:47:19 <neutrino> haskell is a language 1000x times more different from C than, say, Java is
02:47:28 <shachaf> Jafet: That's the main thing he was talking about for a while.
02:47:53 <shachaf> Argue: I heard you have to pay $10 to be allowed to use that.
02:47:55 <neutrino> Jafet: a raytracer using lenses. *rimshot*
02:47:55 <Scriptal> lol, makes sense. java's based off c++, which is based off of C
02:48:01 <Jafet> A raytracer for UML diagrams
02:48:08 <Scriptal> Also, is that book you linked me to a joke? :P
02:48:12 <neutrino> Scriptal: well, "based". but really it's just regurgitating the same old ideas.
02:48:15 <Argue> lol
02:48:21 <Scriptal> nvm
02:48:23 <Scriptal> dumb question
02:48:26 <Argue> shachaf, facebook has it too
02:48:27 <`ramses> no! it's written very informal but it's very good as well
02:48:32 <neutrino> Scriptal: LYAH is one of the better haskell tutorials, but i don't like it myself
02:48:44 <neutrino> you'll progress very quickly with it though
02:48:48 <Argue> also if you wanna be pedantic about it the $10 version is :v:
02:49:04 <Scriptal> ^hah
02:49:19 <shachaf> Argue: Well, I wouldn't know about that, now would I.
02:49:23 <Scriptal> @argue
02:49:24 <lambdabot> Unknown command, try @list
02:49:39 <Scriptal> Well I'll definitely look through it
02:49:42 <Argue> it is a secret to everybody
02:49:46 <Scriptal> learn me a haskell
02:50:21 <Scriptal> Anybody here do Project Euler?
02:50:40 <shachaf> No.
02:51:04 <Scriptal> Might want to look into it. I do it in my free time.
02:51:15 <Scriptal> www.projecteuler.net
02:51:22 <shachaf> It's actually illegal in #haskell.
02:51:23 <johnw> yes, a few of us have worked on Euler
02:51:25 <shachaf> Little-known fact.
02:51:44 <Argue> i have a hard time doing even the simple euler problems in haskell
02:51:46 <Scriptal> You, sir, are a troll in my dungeon
02:51:48 <Enigmagic> lamdabot wrote the first 30 questions
02:52:09 <shachaf> Is there an OEIS sequence of the answers to all "project euler" problems?
02:52:16 <Hafydd> Hahah.
02:52:19 <Argue> lol
02:52:28 <Argue> aren't there floating point and string problems too
02:52:33 <shachaf> Scriptal: One of us is a troll, certainly.
02:52:38 <Scriptal> plenty
02:52:40 <shachaf> It's very possible that it's me.
02:52:53 <Scriptal> noted ;P
02:53:10 <Scriptal> Someone said those problems would be hard to do in haskell?
02:53:22 <johnw> Scriptal: they are not
02:53:32 <Peaker> is there a generalization of Data.List.intercalate for Monoids anywhere?
02:53:44 <Peaker> @type \x -> mconcat . intersperse x
02:53:45 <lambdabot> Monoid b => b -> [b] -> b
02:53:58 <Scriptal> @johnw ty
02:53:59 <lambdabot> Not enough privileges
02:54:11 <johnw> Scriptal: if you want another good mind expander, try this: http://www.cis.upenn.edu/~bcpierce/sf/
02:54:32 <Hafydd> Scriptal, do you use twitter a lot?
02:54:40 <johnw> it's a better use of your time than Euler
02:54:56 <Scriptal> How so? And no, I don't have a twitter.
02:55:17 <Scriptal> or do I care to.
02:55:35 <mikeplus64> @djinn a -> a -> b -> b -> [(a, b)]
02:55:36 <lambdabot> Error: Undefined type []
02:55:47 <shachaf> mikeplus64: _ _ _ _ -> []
02:56:14 <mikeplus64> shachaf: just seeing if djinn can do something interesting with it :)
02:56:35 <Jafet> @djinn a -> a -> a -> (a, a, a)
02:56:35 <lambdabot> f a b c = (c, b, a)
02:56:36 <shachaf> mikeplus64: It's a very boring type from Djinn's perspective.
02:57:01 <mikeplus64> @djinn a -> a -> a -> (a, a, a, a)
02:57:01 <lambdabot> f a b c = (c, c, b, a)
02:57:08 <mikeplus64> @djinn a -> a -> a -> (a, a, a, a, a)
02:57:08 <lambdabot> f a b c = (c, c, c, b, a)
02:57:11 <johnw> and when djinn gets bored, people don't get their wishes
02:57:19 <mikeplus64> @djinn a -> a -> a -> a -> a -> (a, a, a, a, a)
02:57:20 <lambdabot> f a b c d e = (e, d, c, b, a)
02:57:36 <mikeplus64> odd that it reverses it all, but it's valid so who am i to complain
02:58:01 <johnw> djinn is solving for types, not values, isn't it?
02:58:09 <earthy> it is
02:58:14 <shachaf> What does it mean to solve for a type?
02:58:18 <johnw> so there's no "reversed" in this sense
02:58:19 <Hafydd> @djinn ()
02:58:19 <lambdabot> f = ()
02:58:37 <johnw> shachaf: meaning, it provides a definition which is valid for the type, it doesn't care about the values involved
02:58:46 <earthy> @djinn b -> (b -> a) -> [a]
02:58:46 <lambdabot> Error: Undefined type []
02:58:49 <earthy> @djinn b -> (b -> a) -> a
02:58:50 <lambdabot> f a b = b a
02:59:05 <shachaf> djinn b -> (b -> a) -> Maybe a
02:59:11 <shachaf> Maybe ~ [] from Djinn's perspective.
02:59:17 * earthy nods
02:59:34 <Jafet> @djinn a -> а
02:59:35 <lambdabot> No output from Djinn; installed?
02:59:43 <Hafydd> @djinn a
02:59:44 <lambdabot> -- f cannot be realized.
03:01:38 <Yuu-chan> How can it be proven that a -> [a] can only have three "right" implementations?
03:01:55 <shachaf> Yuu-chan: It has many more than three.
03:03:26 <fmap> Yuu-chan: define "three"?
03:03:38 <johnw> (:[]), repeat, and ...?
03:03:41 <Jafet> > 3
03:03:42 <lambdabot>   3
03:03:50 <Yuu-chan> return
03:03:55 <johnw> return == (:[])
03:04:02 <Yuu-chan> er, const []
03:04:07 <shachaf> @ty \x -> [x,x]
03:04:09 <lambdabot> t -> [t]
03:04:15 <b_jonas> I thoguht it had omega plus one right implementations: (\x -> []), (\x -> [x]), (\x -> [x, x]), (\x -> [x, x, x]), ..., repeat
03:04:24 <johnw> shachaf: good
03:04:48 <Jafet> 1 + ω = ω
03:04:49 <neutrino> b_jonas: that's just aleph_0
03:05:11 <Jafet> Hm ok, repeat is different
03:05:41 <shachaf> repeat is the devil.
03:05:48 <xlr> can you create a list with empty elements, eg. [,,,3,]
03:06:00 <earthy> xlr: not really
03:06:04 <Yuu-chan> xlr: please define "empty"
03:06:31 <Yuu-chan> xlr: at least you can have [Nothing, Nothing, Just 3, Nothing]
03:06:35 <Hafydd> :t [Nothing,Nothing,Nothing,3,Nothing]
03:06:37 <lambdabot> Num (Maybe a) => [Maybe a]
03:07:00 <Hafydd> Er... well you know.
03:07:05 <hpaste> blueonyx pasted “unrecognized option `--disable-benchmarks'” at http://hpaste.org/79558
03:07:07 <johnw> so, (:[]), repeat, and ∀n (replicate n).  Is there another definition for a -> [a]?
03:07:15 <shachaf> Sure, undefined
03:07:16 <earthy> const []
03:07:23 <Jafet> Or even const undefined
03:07:36 <shachaf> Or const (undefined:undefined)
03:07:53 <blueonyx> hi, i can't find where i should've specified that option ^
03:07:54 <Yuu-chan> or const (repeat undefined)?
03:08:02 <earthy> but \n (replicate n)  is not of type a -> [a]
03:08:06 <shachaf> Or const (cycle [x, undefined])
03:08:09 <shachaf> So many possibilities!
03:08:24 <shachaf> earthy: I assume he meant\x -> replicate n x, for some n
03:08:29 <earthy> for any n
03:08:30 <earthy> yeah
03:08:30 <Yuu-chan> But they are useless!
03:08:46 <johnw> i guess I meant for all n>0
03:09:07 <shachaf> You probalby meant >1, since you gave (:[])
03:09:09 <Jafet> We're partial to them.
03:09:13 <johnw> good point
03:09:23 <shachaf> Yuu-chan: All of Haskell is useless.
03:09:41 <shachaf> @yarr
03:09:42 <lambdabot> Aye
03:09:44 <Yuu-chan> shachaf: you've ruined my childhood
03:10:07 <Jafet> But not all of Haskell is pointless.
03:10:47 <shachaf> Yuu-chan: At least you had one!
03:13:23 <shachaf> @quote Jafet
03:13:23 <lambdabot> Jafet says: unsafeCoerce takes any argument. AND IT WINS THAT ARGUMENT.
03:13:26 <shachaf> @quote Jafet
03:13:27 <lambdabot> Jafet says: Javascript is pretty much a DSL for making your web browser take up more CPU
03:14:07 <shachaf> Hmm, JavaScript is perhaps the best example of a domain-specific language.
03:14:12 <shachaf> What with the same-origin policy and all.
03:14:40 <bitonic> JavaScript isn’t that specific to its domain
03:14:49 <Jafet> Domain-specific languages improve security!
03:15:07 <Jafet> I wonder if javascript on a phone is an embedded domain-specific language
03:15:07 <bitonic> I mean it’s good as a generic purpose language
03:15:11 <shachaf> bitonic: Do you know what the same origin policy is?
03:15:22 <Yuu-chan> @quote lambdabot
03:15:22 <lambdabot> lambdabot says: <tristes_tigres> @vixen unsafe <lambdabot> you're turning me on :)
03:15:22 <bitonic> shachaf: nope
03:15:52 <shachaf> bitonic: You should! Just think of all the puns you're missing out on.
03:15:57 <bitonic> shachaf: ah, I just googled, and I did know what it is but not the name :P
03:16:36 <bitonic> lol OK, I get it now.
03:18:17 <xlr> Yuu-chan: thanks, i thought that syntax might be similar to using _ for function argument or something
03:19:50 <Yuu-chan> xlr: _ is used to match a value, not an "emptiness" :)
03:20:10 <xlr> Yuu-chan: I mean more like, is not going to be used for anything
03:21:45 <Yuu-chan> xlr: you can match lists too: foo [_, _, _, 3, _] = "The fourth element is three"
03:22:12 <shachaf> > has (element 3) "hello"
03:22:16 <lambdabot>   True
03:22:16 <shachaf> > has (element 3) "hi"
03:22:19 <lambdabot>   False
03:23:50 <Yuu-chan> xlr: but if you need to store an empty value, you need a way to express it. _ is not an "empty value", it's more like an "any value", and not a value internally :)
03:29:18 <odi> hi, is there a way to visualize my algebraic data structures?
03:29:40 <Jafet> I use my eyes
03:30:18 <mreh> odi: typeclass Show?
03:30:28 <mreh> you can derive that for almost everything
03:30:41 <mreh> apart from anything with an -> in it
03:31:04 <odi> yes but i like to print it out
03:31:24 <mreh> :t print
03:31:25 <neutrino> mreh: i don't think functions are a set of measure 0 in the set of all values.
03:31:26 <lambdabot> Show a => a -> IO ()
03:31:43 <mreh> neutrino: I dont understand
03:32:15 <neutrino> "almost everything", and "almost everywhere" has a precise meaning in mathematics and related disciplines
03:32:45 <mreh> neutrino: he was asking about ADT, that was the implied context
03:32:45 <Jafet> @google almost everything
03:32:47 <lambdabot> http://www.youtube.com/watch?v=FiQo6DoXknY
03:33:30 <neutrino> mreh: your context was that you were estimating the size of a subset of the set of values.
03:33:34 <neutrino> mreh: just saying.
03:35:51 <Yuu-chan> That reminds me of "almost all graphs have the radius of 2"
03:37:48 <Jafet> I'm curious to hear neutrino's definition of the Lebesgue measure on Hask.
03:37:54 <mreh> how can "almost" be precise?
03:38:22 <Jafet> @google almost everywhere
03:38:23 <lambdabot> http://en.wikipedia.org/wiki/Almost_everywhere
03:38:24 <lambdabot> Title: Almost everywhere - Wikipedia, the free encyclopedia
03:47:50 <NoICE> fryguybob: hi! do you remember when I tried to find a bug in my STM broadcastTChan code? :D I mentioned it to a friend and he found it instantly :D #my_fail :D
03:47:58 <NoICE> fryguybob: Duplicate a TChan: the duplicate channel begins empty, but data written to either channel from then on will be available from both. Hence this creates a kind of broadcast channel, where data written by anyone is seen by everyone else.
03:51:04 <wuttf> How come GHC accepts string literals from source code as type Collection = Text, but if I input the same in GHCi it whines that [Char] is not a Collection?
03:51:23 <ivanm> wuttf: do you have OverloadedStrings set for your file?
03:51:35 <ivanm> in ghci, do: :set -XOverloadedStrings
03:51:44 <wuttf> ivanm: Yes. Thank you :-D
03:51:46 <ivanm> you can add that into your ~/.ghci file, or a per-project .ghci file
03:52:02 <ivanm> file-level pragmas aren't applied to ghci :)
03:54:19 <edwardk> shachaf just made it so prisms and isos can compose with (.) from the Prelude without giving up compatibility with traversals. impressive stuff =)
03:55:13 <edwardk> and in such a way that its compatible with my indexed changes, 3.8 is looking nice
03:55:27 <ivanm> edwardk: how fugly is the code though? :p
03:55:36 <edwardk> ivanm: its pretty good
03:56:16 <edwardk> he changed (a -> f b) -> s -> f t     to k a (f b) -> k s (f t)    for a suitably constrained k such that (->) is a valid choice for each k
03:56:54 <ivanm> hmmm
03:57:26 <m_fulder> guys, Im still stuck with the IO functions ... how can I create a function that for one pattern does one thing (like create an if statement) and for other pattern prompt the user for some variable and save the written value ....
03:57:27 <m_fulder> the thing is I am creating a simple parser for a language and I have a bunch of statements like if/while etc. but now I want to create a "read" function that will prompt the user for a value of a variable
03:58:02 <Botje> just create function clauses like you would, normally
03:58:10 <Botje> and put different bits of code in
03:58:30 <shachaf> Can we swap iso to use (b -> t) -> (s -> a) -> , by the way?
03:59:38 <bladie> where can i get good haskell tutorials , guys  ?
03:59:57 <ivanm> @where lyah
03:59:57 <lambdabot> http://www.learnyouahaskell.com/
04:00:00 <ivanm> @where yaht
04:00:01 <lambdabot> "Yet Another Haskell Tutorial", Hal Daume III,<http://www.cs.utah.edu/~hal/htut/>,<http://en.wikibooks.org/wiki/Haskell/YAHT>,<http://hal3.name/docs/daume02yaht.p(df|s)>,<http://darcs.haskell.org/
04:00:01 <lambdabot> yaht/yaht.p(df|s)>
04:00:03 <ivanm> @where wikibook
04:00:03 <lambdabot> http://en.wikibooks.org/wiki/Haskell
04:00:05 <ivanm> @where rwh
04:00:05 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
04:00:08 <ivanm> @where tutorials
04:00:08 <lambdabot> http://haskell.org/haskellwiki/Tutorials
04:00:11 <bladie> ty guys ^^
04:00:15 <ivanm> bladie: ^^ take your pick :)
04:00:24 <bladie> haaha D:
04:00:26 <bladie> :D
04:01:05 <Jafet> @where gentle
04:01:05 <lambdabot> http://www.haskell.org/tutorial/
04:01:21 <ivanm> Jafet: isn't that only recommended to trolls? :p
04:01:27 <Jafet> Or by
04:01:43 <ivanm> well, I didn't want to suggest that you were one ;-)
04:02:51 <tdammers> bladie: there's also Real World Haskell
04:03:12 <tdammers> bit outdated, but nice if you have a programming background already
04:03:39 <ivanm> tdammers: see my second-last @where :p
04:03:50 <tdammers> oops, read over that
04:03:56 <tdammers> in that case, nm
04:09:41 <leocassarani>  what's outdated about RWH?
04:10:04 <ivanm> leocassarani: exception handling for starters
04:10:10 <tdammers> leocassarani: the haskell ecosystem has changed a considerable bit since it was written
04:10:12 <ivanm> extensible-exceptions came out just after RWH did
04:10:19 <leocassarani> ah right
04:10:34 <leocassarani> I'll definitely keep that in mind as I continue reading it then :)
04:10:44 <ivanm> also, doesn't it use parsec-2?
04:10:56 <ivanm> (when all the cool kids use attoparsec nowadays anyway :p)
04:10:56 <tdammers> yep
04:11:06 <tdammers> Text.ParserCombinators.Parsec
04:11:17 <ivanm> or trifecta if your name is edwardk :p
04:11:42 * hackagebot spy 0.5 - A compact file system watcher for Mac OS X, Linux and Windows  http://hackage.haskell.org/package/spy-0.5 (StefanSaasen)
04:11:51 <tdammers> RWH also doesn't mention many of the incredibly useful abstractions that modern Haskell has to offer
04:11:54 <Yuu-chan> ivanm: what is parsec-2?
04:12:04 <ivanm> Yuu-chan: version 2.x of parsec
04:12:07 <tdammers> Monoid, Applicative, Arrow, etc. etc.
04:12:16 <ivanm> it mentions Monoid IIRC
04:12:22 <tdammers> hmm let me check
04:12:34 <ivanm> and Applicative and Arrow were already around, but Applicative parsing might not have been as common
04:13:17 <ivanm> Arrow isn't really used much apart from dealing with tuples and maybe netwire
04:13:25 <tdammers> yeah you're right
04:13:43 <tdammers> Arrow is pretty damn nice though
04:14:33 <ivanm> I don't think I've used anything except the function/tuple instance of Arrow
04:14:43 <Yuu-chan> ivanm: does it differ a lot from 3.x? Incompatible, or something?
04:15:11 <fmap> ivanm: tuple instance of Arrow?
04:15:36 <fmap> oh, you mean manipulating tuples with Arrow combinators probably
04:15:39 <ivanm> Yuu-chan: parsec-3 has a clone of the parsec-2 interface but isn't as performant IIRC; parsec-3 has a new API (if you use the new modules)
04:16:01 <ivanm> fmap: yeah, I can never remember whether the instance in question is for functions or for tuples
04:16:04 <ivanm> @instances Arrow
04:16:05 <lambdabot> (->), Kleisli m
04:16:10 <ivanm> right, functions
04:16:47 <fmap> fortunately lenses subsume that use case
04:17:35 <tdammers> lenses subsume everything if I can believe recent activity on #haskell
04:17:46 <edwardk> tdammers: pretty much
04:17:47 <ivanm> heh
04:17:54 <shachaf> @remember fmap <ivanm> right, functions <fmap> fortunately lenses subsume that use case
04:17:54 <lambdabot> Okay.
04:18:24 <ivanm> edwardk: what was your use-case for graph that had everything be within a monad?
04:18:37 <edwardk> ivanm: something big enough to require offline storage
04:18:49 <ivanm> *nod*
04:18:52 <edwardk> ivanm: otherwise i was content to use my comonadic representation
04:19:01 <ivanm> is that still around anywhere?
04:19:08 <edwardk> i may revisit graphs now that i have lenses to talk about them with
04:19:12 * ivanm is finally starting his new library as he thinks he's got all the bits sorted
04:19:15 <edwardk> not really
04:19:30 <edwardk> it was a long time ago. i pasted it to the hnn guys a bunch before i gave up and wrote graphs
04:19:38 <ivanm> oh, there wasn't anything more?
04:19:57 <edwardk> just that paste
04:20:00 <edwardk> i've long lost it
04:20:33 <edwardk> the monadic form in graphs is what you get when you pull the environment out of the env comonad and make it the env in a monad, and then generalize it to allow any monad
04:21:00 <ivanm> the basis of my (planned with no real code as yet) library is the notion of graph "transformers", which I think is similar to what you had
04:21:48 <edwardk> thats basically what graphs is
04:22:10 <ivanm> yeah, but I don't like your API all that much :p
04:22:12 <edwardk> i'll see if i can free up some bandwidth to recode graphs with lenses
04:22:14 <edwardk> me neither
04:22:57 <ivanm> I'm not sure if it will work (but I think it will) is to have a "transformer" class, and then have all classes have method defaults that go down to the base class
04:23:09 * benj_ starts a fund to find and preserve edwardk's pastes for future generations
04:23:12 <edwardk> here, come up with something. if its nice and you do it before i start a lens-based rewrite of graphs, you can have the graphs name ;)
04:23:38 <edwardk> given my backlog, you'll probably get there before i do
04:23:41 <ivanm> so in most cases you can just have instances looking like "instance (FooGraph g) => FooGraph (Wrapper g)" without needing any actual method definitions
04:23:45 <edwardk> i'll also warn you before i start ;)
04:23:48 <ivanm> heh
04:23:58 <ivanm> that's why I'm working on this lookup table thingy
04:24:04 <ivanm> and quite probably using vectors all wrong
04:24:17 <ivanm> I'll be having it on hub.darcs.net rather than github though :p
04:24:40 <edwardk> meh. feel free to push stuff to hub.darcs.net. it must be lonely over there though =P
04:25:38 <edwardk> i find it very hard to give up the huge community i get access to from github to get a little bit nicer of a personal toolchain and a more awkward patch submission process
04:26:01 <hiptobecubic> github is excellent
04:26:06 <edwardk> moving to github was probably the best thing i've done. amusing that i did so out of spite.
04:26:48 <edwardk> i mean best thing in the sense of getting users and opening up my development process. it was like a switch flipped and all of a sudden i was getting patches as fast as I could keep up with them
04:26:54 <hiptobecubic> github *almost* fixes the "i'm too lazy to contribute this patch" problem
04:27:00 <edwardk> hiptobecubic: exactly
04:27:01 <ivanm> edwardk: "spite"?
04:27:14 <hiptobecubic> which is a huge problem, i think
04:27:15 <edwardk> ivanm: patchtag ate a bunch of my repos, some of which i didn't have locally
04:27:28 <edwardk> because i was switching computers at the time and decided i'd just repull
04:27:32 <ivanm> ahhhh
04:27:41 <hiptobecubic> ouch
04:27:42 <edwardk> so i moved everything over to git in a marathon session
04:28:50 <hiptobecubic> A lot of people bitch about git being difficult to use, but I'm not convinced. It's even more confusing that these people are usually coming from SVN
04:29:08 <tdammers> hiptobecubic: it's not confusing
04:29:14 <hiptobecubic> I don't think so either
04:29:21 <ivanm> hiptobecubic: I find git to be much more of a PITA than darcs
04:29:23 <hiptobecubic> But that's the reputation it seems to have.
04:29:26 <tdammers> they have put some really hard work into bending their minds to the svn mindset
04:29:39 <tdammers> and then git comes along and pushes them out of their comfort zone
04:29:47 <ivanm> admittedly, I do like rebase for a "I really should do lots of little commits whilst developing but don't want to submit fugly patches"
04:30:12 <hiptobecubic> I usually have the opposite problem
04:30:26 <Botje> the look on my professor's face when I tell him I routinely rebase stacks of 30-40 patches ... <3
04:30:31 <hiptobecubic> Here are 12 unrelated minor changes that I forgot to make intermediate commits for
04:31:14 <tdammers> hiptobecubic: git commit -p
04:31:17 <tdammers> life saver
04:31:31 <Botje> git add -p you mean
04:31:50 <Botje> commit -p isn't nearly as helpful
04:31:57 <hiptobecubic> I think the most difficult thing about it is the "treeish" idea. But it seems reasonable to me, given the way you can abuse it so badly and still have everything work
04:32:59 <ivanm> the other reason I like darcs: it does interactive patch editing by default!
04:33:17 <neutrino> hg has crecord, which is a curses based interface for that sort of thing. it is the #1 hg command i use.
04:33:31 <neutrino> git sucks because it doesn't have that.
04:33:38 <hiptobecubic> heh
04:34:06 <mreh> ivanm: it does? since when?
04:34:11 <hiptobecubic> If you throw vim-fugitive in as an interface, then I think git wins the race
04:34:24 <quchen_> @pf \x -> (1,x)
04:34:24 <lambdabot> Maybe you meant: bf pl
04:34:28 <quchen_> @pl \x -> (1,x)
04:34:29 <lambdabot> (,) 1
04:34:29 <ivanm> mreh: "darcs record" lets you choose which bits you want to add to the patch
04:34:30 <neutrino> nope
04:34:37 <ivanm> and there's the ability to edit hunks
04:34:42 <quchen_> @pl \x -> (x,1)
04:34:43 <lambdabot> flip (,) 1
04:34:44 <neutrino> hg definitely still wins for me, fugitive barely adds anything i use
04:34:58 <ivanm> quchen_: there's also TupleSections which lets you write (,1)
04:35:00 <mreh> ivanm: oh yes, I thought you meant editing the individual changes
04:35:09 <ivanm> mreh: yes, you can do that now :)
04:35:10 <t7> git is better than hg because linus wrote it. goodnight.
04:35:13 <ivanm> for the past few versions
04:35:23 <mreh> great
04:35:31 <ivanm> choose "e" at the prompt
04:35:50 <mreh> git's model is far more complicated than it need be
04:35:53 <tdammers> git is better than hg because I use it routinely and know its quirks.
04:35:59 <mreh> cf. darcs
04:36:08 <owst> mreh: the model itself isn't complicated
04:36:19 <tdammers> a while ago, I used hg on a daily basis. Back then, hg was better than git.
04:36:20 <owst> darcs' model is lacking (no good story for conflicts)
04:37:05 <yitz> owst: have you ever been a heavy darcs user?
04:37:39 <owst> yitz: yes, I use it daily :-) (I'm also one of the few developers who sometimes work on it)
04:37:44 <yitz> owst: what do you think is missing?
04:38:22 <owst> A solid underlying foundation
04:38:24 <hiptobecubic> a good story for conflicts, apparently
04:38:28 <owst> yes
04:38:43 <t7> what happened to proving patch theory ?
04:38:52 <yitz> owst: i was forced from darcs to hg at work. i'm still hurtng from it.
04:39:02 <aninhumer> I think some functions like these would be useful in lens: http://hpaste.org/79561
04:39:09 <owst> Igloo was working on a coq formalisation, but it's not finished
04:39:11 <yitz> owst: please be more specific.
04:39:13 <aninhumer> Probably with better names
04:39:27 <mreh> you hold darcs to a different standard to git?
04:39:37 <mreh> git has no model, the model is the implementation
04:39:42 <yitz> what does "a good story" mean?
04:39:44 <edwardk> aninhumer: i used to call writer 'whisper' in an old version
04:39:51 <edwardk> since its a weaker version of 'tell'
04:39:59 <owst> yitz: there are corner cases in the way patches are represented, which means darcs can get into a state that isn't handled by the code
04:40:35 <edwardk> aninhumer: pop on github.com/ekmett/lens/issues and open up an issue. we can probably at least add something like whisper back
04:40:36 <owst> mreh: sure, the implementation, but the first versions of git essentially fixed the "model"
04:40:38 <mreh> git can get into a state that cannot be handled by any normal human being
04:40:44 <yitz> owst: is that a result of the move to hashed repos?
04:41:00 <owst> yitz: no, it's the darcs2 patch implementation
04:41:02 <aninhumer> edwardk: Will do, was there a reason it was removed?
04:41:13 <yitz> mreh: git *starts* in a state that cannot be handled by any normal human being imo
04:41:25 <mreh> heh
04:41:26 <owst> yitz: you can have hashed repositories with the old-style patch semantics (i.e. darcs v1 patches)
04:41:33 <yitz> owst: ok
04:41:58 <neutrino> yitz: well said
04:42:29 <mreh> and have you read the documentation?! :)
04:42:46 <owst> I'd love to see a new patch theory worked out and implemented for darcs, but it's a case of (very limited) time and desire (as is always the case)
04:42:48 <yitz> owst: what is the basic kind of case where the patch model runs into trouble? can it be described briefly?
04:43:27 <owst> yitz: err, not really :-) that's why we haven't fixed it. I did work out a case that causes broken behaviour at the last hacking sprint, but it's not trivial to describe
04:43:54 <yitz> owst: did you post it somewhere?
04:44:00 <owst> yeah, I'm trying to find it
04:44:13 <mreh> that sounds a little frightening
04:44:30 <owst> the code implementing the v2 patches is unreadable, and understood by (probably) no-one, these days
04:45:26 <owst> mreh: it is, to some extent.
04:45:32 <Saizan> weren't darcs very strict about accepting code?
04:45:47 <owst> ?
04:46:06 <owst> In what sense, darcs the project or darcs the scm *program*?
04:46:09 <yitz> mreh: me? sure i've read the documentation. in fact, every time i need to type a git command i read the documentation.
04:46:13 <Saizan> the project
04:46:19 <owst> Saizan: we'd love contributions, and help!
04:46:35 <owst> Saizan: (maybe it's not always been that way, I've only been around for a couple of years)
04:46:43 * hackagebot hsc3-process 0.8.0 - Create and control scsynth processes  http://hackage.haskell.org/package/hsc3-process-0.8.0 (StefanKersten)
04:46:45 * hackagebot hsc3-server 0.5.0 - SuperCollider server resource management and synchronization.  http://hackage.haskell.org/package/hsc3-server-0.5.0 (StefanKersten)
04:46:47 * hackagebot dwarf-el 0.1 - Parser for DWARF debug format.  http://hackage.haskell.org/package/dwarf-el-0.1 (EyalLotem)
04:46:53 <Saizan> owst: my question was more about how unreadable code got in :)
04:47:16 <owst> Saizan: Ah! Well, it was written by David, who was the creator/maintainer of darcs at the time
04:47:39 <yitz> owst: oh i thought he was pretty much out at the time of the move to v2
04:48:09 <owst> yitz: what do you mean?
04:48:46 <jeannekamikaze> yo mreh
04:49:04 <yitz> owst: at some point david stopped doing very much active work on darcs, and others took over. do you know when that was relative to v2?
04:50:01 <owst> yitz: Oh, I see, I misread "he" for "it". Yeah, about that time, though I'm not really sure. The v2 release announce is a bit infamous :-)
04:50:54 <yitz> owst: yes i agree with Saizan. while i didn't see very much of the code itself, i did see a whole code review process going on via the mailing list.
04:51:20 <edwardk> aninhumer: people gave me crap about nobody wanting it
04:51:33 <edwardk> aninhumer: so you can be the one voice for writer ;)
04:51:43 * hackagebot dwarfadt 0.1.0.0 - High-level wrapper around the dwarf library  http://hackage.haskell.org/package/dwarfadt-0.1.0.0 (EyalLotem)
04:51:44 <yitz> owst: but you're saying the code that determined (or failed to determine) the semantics of v2 patches was created just before that review process was set up?
04:52:24 <yitz> Peaker: yay! nice work.
04:53:07 <owst> yitz: I don't really know. All I know is that the people who are left working on darcs now don't understand it, and it's fairly incomprehensible (I tried, and gave up)
04:53:19 <yitz> edwardk: maybe you should reimplement it with "yell" instead of "whisper"
04:53:48 <aninhumer> edwardk: Well, for reference the use case I have is replacing a State with a Writer
04:53:53 <Peaker> yitz, :-)
04:54:37 <hpaste> Peaker pasted “dumpadt example output when run on itself” at http://hpaste.org/79562
04:54:44 <owst> yitz: http://bugs.darcs.net/issue2047 the last message, sort of describes what's going on (though it'll be meaning less unless you understand the internals). Essentially, the commute function for duplicates/conflictors isn't
04:54:54 <owst> meaningless*
04:55:07 <owst> heh, "isn't an iso"
04:55:23 <Peaker> yitz, take a look at the example output if you haven't already :)
04:55:31 <owst> yitz: when the developers of darcs can't even write a sensible IRC message, what hope is there? :-)
04:55:46 <Peaker> (it's not all the information parsed from the dwarf, but it's a useful demo of the top-level info)
04:56:25 <yitz> Peaker: haha ghc's secrets revealed
04:56:58 <yitz> compDir  = "/home/ian/zz/ghc-7.4.1/libffi/build/i386-unknown-linux-gnu"
04:57:18 <Peaker> :-)
04:59:03 <hpaste> Peaker pasted “Example output of the low-level dwarf parser” at http://hpaste.org/79563
04:59:07 <yitz> owst: oh ok :) i thought you meant isn't commutative :)
04:59:39 <owst> yitz: so I didn't really say what the issue is - it's a (supposed) property of darcs patches that if you can commute AB to B'A' then you should be able to recommute B'A' to get AB again, the example I pasted was a case where that doesn't hold - it can cause strange behaviour.
05:00:11 <edwardk> aninhumer: i'm sold. i just want to be able to point to at least one user before i go reverse myself again, hence the issue ;)
05:00:25 <edwardk> er hence why i requested you create an issue
05:01:09 <yitz> owst: yes that would be a problem. commutation ought to be really communtation. otherwise, it seems that the whole advantage of the darcs concept loses much of its value.
05:01:44 <yitz> *commutation
05:03:28 <yitz> Peaker: i can't make any sense out of that one. but anyway, this looks like a really useful tool and worth learning about. thanks for the binding.
05:04:12 <owst> yitz: indeed so. Luckily this appears to only crop up in less-frequently occurring circumstances
05:04:52 <hiptobecubic> I need more rams :(
05:05:11 <Peaker> yitz, the "dwarf" lib is originally Erik Charlebois's who did most of the heavy lifting.. I spent a few days cleaning it up, fixing some issues/improving the API, and published my fork (hopefully can merge back one day).. then I made the dwarfadt which is much easier to make sense of as you saw :)
05:07:01 <edwardk> aninhumer: https://github.com/ekmett/lens/issues/204 is the issue to track. it'll probably go in in 3.8
05:07:07 <edwardk> aninhumer: the name may change
05:07:45 <neutrino> hiptobecubic: https://bitbucket.org/ludovicchabant/vim-lawrencium/src/75e9d909758accee9147116ec53c3d6e5e17ae3a/doc/lawrencium.txt?at=default
05:07:54 <neutrino> hiptobecubic: installing that
05:09:07 <hiptobecubic> neutrino, fuhgitive :) ?
05:11:08 <hiptobecubic> neutrino, can't read it now. can't open browser :(
05:12:34 <hiptobecubic> damnit... oom got me.
05:12:39 <typoclass> neutrino: o hai :-) you had an idea?
05:12:39 <lambdabot> typoclass: You have 1 new message. '/msg lambdabot @messages' to read it.
05:13:02 <hiptobecubic> Why doesn't lambdabot /msg those?
05:13:40 <nicoo> hiptobecubic: Or even /notice; but yes, it should
05:14:15 <neutrino> hiptobecubic: something like that
05:14:22 <yitz> Peaker: yes, very nice. i don't deal so much with low level stuff these days, but this is obvioulsy very useful.
05:14:25 <neutrino> typoclass: yeah, right
05:14:30 <neutrino> typoclass: let me recollect it
05:14:55 <neutrino> right, the idea was very simple, you had two threads for the update, not just one
05:15:43 <typoclass> oh, interesting
05:15:45 <neutrino> so your main thread writes to a TMVar which says how far it is finished. then another thread reads from that tmvar, blocking until it's full, and writes that value to a tvar
05:16:02 <neutrino> a third thread checks the tvar and prints out the percentage and then does threaddelay
05:16:05 <neutrino> it's very simple really
05:16:12 <neutrino> and you don't have to register timeouts anymore
05:16:40 <neutrino> but really, you could skip the whole tmvar and just write to the tvar
05:16:47 <neutrino> now that i think about it?
05:16:53 <typoclass> right, that could be possible. thanks a lot
05:16:56 <merijn> neutrino: Yup
05:16:57 <neutrino> i'm not sure why we needed the tmvar at all
05:17:13 <neutrino> i think it was something i needed, and then i presented you my solution to my problem
05:17:18 <neutrino> your problem just needs the tvar i guess
05:46:44 * hackagebot ghc-heap-view 0.4.0.0 - Extract the heap representation of Haskell values and thunks  http://hackage.haskell.org/package/ghc-heap-view-0.4.0.0 (JoachimBreitner)
05:56:32 <neutrino> there should be a website which lists all haskell papers, but updates them to what the implementation in haskell actually does.
05:56:44 <neutrino> haskell-papers-updated.org
06:00:05 <lewisx> how can I make .hs file importable from every directory, not just the one where it is in?
06:01:22 <merijn> lewisx: Cabalize it and let cabal figure out where to install?
06:03:29 <neutrino> use a .cabal file
06:03:33 <neutrino> so what merijn said
06:03:49 <neutrino> you can start by going to an empty dir and writing "cabal init"
06:03:57 <lewisx> do I have to use cabal? would prefer to just place it in some directory if it can work that way
06:04:00 <neutrino> and then pressing enter
06:04:06 <neutrino> no, you can't do that
06:04:09 <neutrino> you have to use cabal
06:04:18 <lewisx> ok thanks
06:04:27 <fmap> lewisx: there is -iDIRECTORY option to ghc
06:04:34 <neutrino> cabal is much easier than fussing with files though
06:04:41 <neutrino> ..or ghc options
06:11:09 <fmap> it depends, ghc options are handy when runhaskelling some scripts
06:11:59 <nand`windows> Anybody know if I can use Network.WebSockets with a HTTP proxy?
06:23:57 <neutrino> nand`windows: good question.. why not start something simple? for example, there's privoxy for windows
06:24:17 <nand`windows> neutrino: I'm not sure what you're saying
06:24:38 <nand`windows> I need Network.WebSockets.connect to respect proxy settings; or alternatively, get something similar to it which does
06:25:04 <fryguybob> NoICE: Ah, I didn't have a chance to track that down.  It was good you had that example though as it spurred me to investigate the fix to the other bug and I found that it caused another problem.
06:25:16 <nand`windows> there's runWebSocketsWith but I think that's just for servers
06:25:23 <nand`windows> there seems to be no way to run a custom client?
06:25:59 <nand`windows> ah, there's runWebSocketsClient
06:26:15 <nand`windows> it doesn't seem to be exported, but I'll hack something together
06:26:18 * nand`windows is off for now
06:26:45 * hackagebot netclock 0.5 - Netclock protocol  http://hackage.haskell.org/package/netclock-0.5 (AlexMcLean)
06:26:47 * hackagebot Xec 0.1.6 - Gtk command launcher with identicon  http://hackage.haskell.org/package/Xec-0.1.6 (DaikiHanda)
06:27:41 <neutrino> @tell `nand` privoxy is a web proxy you can run on windows.
06:27:41 <lambdabot> Consider it noted.
06:41:45 * hackagebot pulse-simple 0.1.14 - binding to Simple API of pulseaudio  http://hackage.haskell.org/package/pulse-simple-0.1.14 (DaikiHanda)
06:42:37 <sopvop> @faq can haskell help me find a good job?
06:42:37 <lambdabot> The answer is: Yes! Haskell can do that.
06:42:47 <neutrino> lol
06:42:50 <sopvop> Ah, reassuring.
06:49:21 <ivanm> mwahahahaha! I now generate code for my code generator from a table using orgtbl-mode so that I can more easily tell what every value is!
06:49:24 <ivanm> @time
06:49:26 <lambdabot> Local time for ivanm is Fri Dec 21 01:49:07
06:49:33 <ivanm> though I should probably sleep >_>
06:49:41 <shachaf> @time
06:49:45 <lambdabot> Local time for shachaf is Thu Dec 20 06:49:24 2012
06:49:48 <shachaf> So should I.
06:50:10 <ivanm> it's almost time for you to _stop_ sleeping! :o
06:50:55 <ivanm> anyway, if anyone's interested, it's from line 620 here: http://hub.darcs.net/ivanm/graphviz/browse/utils/AttributeGenerator.hs (or just search for "ORGTBL: SEND")
07:05:28 <ncs> i'm playing with existential types and I want to define a function foo :: forall a. a->Int , but i want foo to be able to handle also more than 1 arguments, i.e. that type a might be a->a... is that possible?
07:06:44 <fmap> foo :: forall a. a -> Int isn't existential, is it?
07:07:24 <aavogt> @ty const (1::Int)
07:07:26 <lambdabot> b -> Int
07:08:45 <ncs> isn't it?
07:08:50 <`nand`> neutrino: I still don't see how that's related
07:08:50 <lambdabot> `nand`: You have 1 new message. '/msg lambdabot @messages' to read it.
07:08:57 <`nand`> neutrino: I don't want to run a proxy, I want to /connect to/ a proxy
07:08:59 <`nand`> @messages
07:08:59 <lambdabot> neutrino said 41m 18s ago: privoxy is a web proxy you can run on windows.
07:11:11 <typoclass> ncs: sounds tricky to me. there's the Printf module which uses typeclass witchcraft to do "varargs in haskell". it's explained in an oleg article and a few stack-overflow questions. but honestly, you can make your life much easier if you solve it some other way =) passing a list or whatever
07:12:46 <ncs> ok, i'll check out what oleg says! thanks!
07:13:27 <mysticc> when I do b =  a:as, does it copies the whole as again or shares it?
07:14:36 <`ramses> mysticc: it's shared
07:15:29 <`ramses> that's the beauty of immutability, since it can be mutated, it can safely be shared
07:15:37 <`ramses> s/can/can't
07:32:38 <Sculptor> g'day
07:33:12 <byorgey> hi Sculptor
07:42:30 <hjliang> haskell is wonderful
07:44:54 <simon> is it bad style to overload Ord MyType with a topological sort? I mean, I thought it'd be neat with sort :: [MyType] -> [MyType], but I wonder if what is implied with this typeclass is general sorting.
07:45:18 <fmap> :t value
07:45:20 <lambdabot> (Applicative f, Indexable k k1) => (k -> Bool) -> k1 (v -> f v) ((k, v) -> f (k, v))
07:45:31 <fmap> edwardk: could you rename that please?
07:45:45 <edwardk> fmap: sure. you can armwrestle roconnor for the name
07:45:58 <edwardk> i'm not wedded to it at all
07:46:16 <edwardk> i suppose its not necessary any more
07:46:45 <edwardk> if the indexed traversal instance for (,) e   used 'e' as the key then you could use iwhere
07:47:09 <edwardk> his requires a couple things though, it means (,) e would have to be Traversable
07:47:09 <merijn> simon: Depends, does topological sort make more sense than general sort for your type?
07:47:28 <edwardk> > traverse (\x -> [x]) (1,2)
07:47:30 <lambdabot>   No instance for (Data.Traversable.Traversable ((,) t0))
07:47:31 <lambdabot>    arising from a u...
07:47:39 <simon> merijn, yes. but I could just have a topologicalSort that uses sortBy...
07:47:56 <merijn> I was just gonna ask whether you were familiar with sortBy :)
07:48:18 <simon> right :) I'll do so.
07:50:26 <roconnor> (,) e should totally be traversable!
07:51:06 <roconnor> well, I can sort of see it being a little confusing
07:55:33 <jackss> why doesn't this print Hello?
07:55:38 <jackss> (const True . putStrLn) "Hello"
07:55:52 <shachaf> Why would it?
07:56:03 <shachaf> (const True . putStrLn) "Hello"
07:56:09 <shachaf> = const True (putStrLn "Hello")
07:56:11 <shachaf> = True
07:56:32 <jackss> what does it do if not passing "Hello" to putStrLn, then () to const True
07:57:17 <jackss> I wanted it to do something like this:  (\x -> do putStrLn x; return True)
07:57:23 <shachaf> It passes "Hello" to putStrLn, but that action is never executed.
07:57:26 <shachaf> @ty putStrLn
07:57:27 <lambdabot> String -> IO ()
07:57:32 <shachaf> IO () is a very very different thing from ()
07:58:23 <jackss> so I need monadic version of . or?
07:58:39 <Botje> jackss: have you looked at Debug.Trace?
07:58:43 <shachaf> @ty (=<<)
07:58:44 <Botje> it's very probably what you want.
07:58:45 <lambdabot> Monad m => (a -> m b) -> m a -> m b
07:58:49 <shachaf> Botje: It very probably is not.
07:58:58 <shachaf> Well...
07:59:01 <shachaf> Depending on what you want.
07:59:12 <shachaf> You should understand how IO works in Haskell *before* using Debug.Trace
07:59:48 <`ramses> jackss: what's wrong with the version with do ?
08:00:16 <jackss> it's slightly verbose. and I was curious how to do it with combinators
08:00:47 <`ramses> @ty \x -> putStrLn x >> return True
08:00:48 <roconnor> @undo (\x -> do putStrLn x; return True)
08:00:48 <lambdabot> String -> IO Bool
08:00:49 <lambdabot> (\ x -> putStrLn x >> return True)
08:01:51 <roconnor> \x -> const True <$> putStrLn x
08:02:29 <jackss> that's nicer
08:02:31 <jackss> can it be done without lambda?
08:03:37 <`ramses> roconnor's version can be eta reduced
08:03:56 <`ramses> to get rid of the lambda
08:04:19 <`ramses> > let f = const True <$> putStrLn in f "hello"
08:04:21 <lambdabot>   True
08:04:30 <Iceland_jack> That is the normal course of action when cabal fails?
08:04:32 <ion> \x -> True <$ putStrLn x
08:04:36 <`ramses> (you don't see the printed string)
08:04:48 <ion> @type const True <$> putStrLn
08:04:49 <lambdabot> String -> Bool
08:04:56 <ion> @type \x -> const True <$> putStrLn x
08:04:58 <lambdabot> String -> IO Bool
08:04:59 <`ramses> hmm, seems the action actually isn't even performed in ghci...
08:05:33 <ion> fmap (const True) . putStrLn
08:05:36 <`ramses> ok, forget what I said, you can't eta reduce it if you want the action to performed
08:05:55 <roconnor> \x -> const True <$> putStrLn x and const True <$> putStrLn are not the same!
08:06:12 <roconnor> @pl  \x -> const True <$> putStrLn x
08:06:13 <lambdabot> (const True <$>) . putStrLn
08:06:51 <roconnor> ion's idea is good though
08:07:01 <jackss> yeah it worked
08:07:02 <roconnor> (True <$) . putStrLn
08:07:15 <roconnor> @src (<$)
08:07:15 <lambdabot> (<$) = (<$>) . const
08:07:50 <roconnor> I've never used <$ before!
08:08:15 <ion> I’ve used it a lot.
08:08:34 <roconnor> ion: which is better <$ or $> ?
08:08:35 <roconnor> :D
08:10:24 <Yuu-chan> Wow, 1010 people!
08:11:07 <krakrjak> <$ you just made my day TY ion!
08:11:21 <jackss> <$ is cute
08:12:26 <ion> roconnor: What’s $>? :-)
08:12:49 <shachaf> ($>) :: forall (f :: * -> *) a b. Functor f => f a -> b -> f b
08:12:52 <shachaf>   	-- Defined in `Control.Comonad'
08:13:09 <ion> So, flip (<$).
08:13:35 <edwardk> ($>) comes up in Comonad because it gets used with wfix a fair bit
08:13:39 <Yuu-chan> :t ( <3 )
08:13:40 <lambdabot> (Num a, Ord a) => a -> Bool
08:17:23 <parcs> <$ goes well with guard
08:17:43 <parcs> > "foo" <$ guard (1 == 0) :: Maybe String
08:17:44 <lambdabot>   Nothing
08:19:19 <monochrom> > "foo" <$ guard (1 == 1) :: Maybe String
08:19:21 <lambdabot>   Just "foo"
08:23:17 <roconnor> > guard (1 == 1) $> "foo" :: Maybe String
08:23:18 <lambdabot>   Not in scope: `$>'
08:23:18 <lambdabot>  Perhaps you meant one of these:
08:23:18 <lambdabot>    `$' (imported from D...
08:23:26 <roconnor> I see
08:34:31 <ion> > reverse . unfoldr (\n -> swap (n `quotRem` 10) <$ guard (n /= 0)) $ 1237890
08:34:33 <lambdabot>   [1,2,3,7,8,9,0]
08:34:42 <elliott> nice
08:34:45 <ion> > reverse . unfoldr (\n -> swap (n `quotRem` 16) <$ guard (n /= 0)) $ 0x123789f
08:34:48 <lambdabot>   [1,2,3,7,8,9,15]
08:35:16 <elliott> > reverse . map (['0'..'9'] !!) . unfoldr (\n -> swap (n `quotRem` 10) <$ guard (n /= 0)) $ 1237890
08:35:18 <lambdabot>   "1237890"
08:35:46 <ion> ['0'..'9'] ++ ['a'..'z']
08:40:44 <lolcathost> Is there any Hackage package for SQL-like numeric values?
08:41:45 <lolcathost> Oh, nothing, forget it. I just needed to search more intelligently ("cabal list decimal" instead of "cabal list numeric")
08:45:11 <mreh> ping
08:45:17 <`ramses> pong
08:45:26 <mreh> :@
08:45:31 <mreh> just checking my inbox
09:07:36 <S11001001> Sometimes I hold private conversations with lambdabot. lambdabot keeps all my secrets
09:08:53 <beekor> so you think.  we see your types.
09:08:56 <Sculptor> you mean, the guy who runs it
09:09:06 <tac> .@remember lambdabot I always love you. Always.
09:09:37 <bourbaki> Moin
09:09:58 <hpaste> bourbaki pasted “NonEmpty” at http://hpaste.org/79572
09:10:33 <bourbaki> Can anyone explain how this NonEmpty data type works and what the return type of a tail function would have to be?
09:13:49 <tac> NonEmpty is an empty type
09:13:55 <tac> It's a phantom type, actually
09:14:22 <bourbaki> Maybe i just do not understand how Cons reall works.
09:14:24 <tac> Basically, when you construct a safelist, you have to either construct an object of SafeList Empty or an object of SafeList NonEmpty
09:14:50 <tac> err, it has an extra parameter
09:14:56 <bourbaki> It takes some type a and then some SafeList a b, what does the last SafeList a NonEmpty do then?
09:14:59 <tac> You have to either construct an object of SafeList a Empty or an object of SafeList a NonEmpty
09:15:14 <tac> ahh
09:15:23 <tac> that tells you what you're actually making
09:15:28 <bourbaki> I read it like a function.
09:15:48 <tac> You give it an "a" and a "SafeList a b"
09:15:54 <tac> and you get a SafeList a NonEmpty in retur
09:15:56 <tac> n
09:16:21 <bourbaki> Yes sure but what is SafeList a NonEmpty?
09:16:29 <bourbaki> And how is it recursive?
09:16:31 <tac> It's a type, like an Int or a List A
09:17:16 <tac> You have two kinds of SafeList: SafeList a Empty -- which has to be Nil (because Nil is the only constructor that ends with a SafeList a Empty)
09:17:26 <bourbaki> :t Cons "x" "y" gives an error sayin that [Char] can not be matched with SafeList [Char] b0
09:17:27 <lambdabot> Not in scope: `gives'
09:17:27 <lambdabot>     Not in scope: `an'
09:17:28 <lambdabot>     Perhaps you meant one of these:
09:17:38 <tac> ah
09:17:40 <tac> You need to do
09:17:53 <bourbaki> I know
09:18:02 <tac> Cons "x" (Cons "y" Nil)
09:18:15 <bourbaki> But how does it get the SafeList a NonEmpty for b ?
09:18:38 <tac> Look at the types as you construct it
09:18:50 <tac> Nil :: SafeList String Empty
09:18:52 <bourbaki> So what would the tail function look like?
09:19:05 <bourbaki> tail :: SafeList a NonEmpty -> ?
09:19:23 <tac> Cons :: String -> SafeList String b -> SafeList NonEmpty
09:19:29 <tac> Cons "y" :: SafeList String b -> SafeList NonEmpty
09:19:40 <tac> Cons "y" Nil :: SafeList String NonEmpty
09:19:45 <tac> (I missed the String in the end there)
09:21:20 <hpaste> tac pasted “SafeList” at http://hpaste.org/79573
09:21:40 <tac> (I corrected the mistakes there)
09:22:19 <bourbaki> Ah meh the other Cons has a different type then of course ...
09:22:33 <bourbaki> But what would have the return type of tail would have to look like?
09:22:57 <bourbaki> Either Nil something?
09:23:53 <hpaste> tac annotated “SafeList” with “SafeList (annotation)” at http://hpaste.org/79573#a79574
09:24:15 <tac> There's no need for an Either, actually
09:26:07 <bourbaki> So NonEmpty is SafeList a NonEmpty?
09:28:21 <tac> no. NonEmpty is just there to tell you about a SafeList
09:29:20 <bourbaki> Ok so if i pass on Nil or SafeList ... as a secod type to Cons how does it fit in the a or NonEmpty type?
09:29:30 <hpaste> tac annotated “SafeList” with “SafeList (annotation) (annotation)” at http://hpaste.org/79573#a79575
09:30:02 <bourbaki> Your tail is a head :)
09:30:02 * elliott thinks a better name for SafeList is InconvenientList
09:30:07 <tac> bourbaki: doops
09:30:07 <acowley> Has anyone here used the Bound library or something similar for binding manipulation?
09:30:28 * elliott hasn't used bound in practice yet but likes its structure
09:30:33 <elliott> there's also http://hackage.haskell.org/package/unbound
09:31:21 <acowley> elliott: Yeah, I suggested previously that I'd give bound a shot since my earlier PHOAS code doesn't type check under 7.6
09:31:27 <acowley> elliott: But I've run into a problem
09:31:51 <acowley> elliott: I have a GADT for my Exp type that nails down the types of some expressions.
09:32:01 <hpaste> tac annotated “SafeList” with “SafeList (annotation) (annotation) (annotation)” at http://hpaste.org/79573#a79576
09:32:19 <acowley> elliott: If I add another type parameter for the "name" type of bound identifiers, then I can make a Functor instance in that type parameter
09:32:39 <tac> bourbaki: I hope that makes a little bit of sense :)
09:32:41 <acowley> elliott: But I can't (?) make a Monad instance in the cases where the return type isn't fully polymorphic
09:33:01 <bourbaki> tac: That gives me an error.
09:33:05 <elliott> acowley: you could add an artificial return constructor? honestly you're probably better off asking edwardk :)
09:33:06 <bourbaki> Tried that already.
09:33:11 <acowley> elliott: Like, I have a term Exp Int n (I use 'n' as the type variable for my names)
09:33:23 <tac> bourbaki: I didn't typecheck it, so it could be wrong
09:33:33 <acowley> elliott: The problem is that my Monad instance head is instance Monad (Exp r) where …. so the 'r' is rigid
09:33:40 <acowley> NMR doesn't fix it, either
09:33:48 <bourbaki> And if that was true NonEmpty would be of type SafeList
09:34:22 <acowley> elliott: Yeah, I'll ask him, but I figured disgorging all that here might trigger someone who recognizes my folly to pipe up :)
09:34:43 <bourbaki> I do not understand what happens in the second step of Cons, does it pass the SafeList to the NonEmpty constructor that is not there?
09:35:38 <tac> bourbaki: maybe I'm wrong about the SafeList a b return type.
09:35:41 <tac> yeah.... I am
09:35:47 <tac> (it should be an existential......)
09:36:18 <tac> I don't know how Haskellers would typically handle that
09:37:05 <bourbaki> Ok so we can not write a tail ... But do you know what Cons actually does with the values to come up with a NonEmpty typed value?
09:37:13 <bourbaki> There is not even a constructor.
09:37:24 <tac> Ideally, you'd want to do "exists b. SafeList a NonEmpty -> SafeList a b"... but that's not legitimate Haskell code :<
09:37:35 <acowley> If I bung an extra existential into things, I think it will work
09:37:39 <tac> bourbaki: Cons and Nil *are* constructors
09:37:47 <bourbaki> tac: Btw the example is from here http://en.wikibooks.org/wiki/Haskell/GADT
09:37:52 <elliott> you can define existential types
09:37:55 <bourbaki> tac: But NonEmpty has none.
09:37:58 <elliott> you need a constructor though
09:38:06 <elliott> (this is one of the many reasons this construction is impractical)
09:38:10 <bourbaki> So how is the SafeList a NonEmpty build?
09:38:23 <elliott> note that you can have SafeList track its _length_
09:38:25 <elliott> then you can type tail
09:38:28 <tac> bourbaki: You are never actually asked to create a NonEmpty or Empty object
09:38:32 <bourbaki> NonEmpty is of kind * but has no type.
09:38:38 <tac> That's why we call them "phantom" types.
09:38:40 <elliott> NonEmpty is a type
09:38:56 <tac> They only serve to make other types "more interesting"
09:39:06 <tac> They, themselves, are pretty useless.
09:39:31 <bourbaki> Ok i do not get it...
09:39:51 <bourbaki> :k NonEmpty is * but :t NonEmpty is an error.
09:39:53 <lambdabot> parse error on input `*'
09:40:08 <bourbaki> I also do not get how a value is constructured by Cons.
09:40:38 <bourbaki> Also the value constructed with Cons is different from the SafeList a b type.
09:41:01 <bourbaki> So that b has to fit somewhere in that SafeList a NonEmpty since it can not be a it has to be fit in NonEmpty.
09:41:20 <tac> bourbaki: The order goes: Terms have a Type, Types have a Kind.
09:41:27 <tac> Types do not have a Type in Haskell
09:41:44 <bourbaki> 18:38 < elliott> NonEmpty is a type
09:41:46 <tac> You wouldn't ask for :k 1 + 1
09:41:53 <tac> bourbaki: yep
09:41:55 <tac> Types have a kind
09:42:00 <bourbaki> Yes
09:42:02 <tac> :k NonEmpty is *
09:42:04 <lambdabot> parse error on input `*'
09:42:04 <tac> * is the kind
09:42:35 <bourbaki> Cons is a constructor thus it takes types and retrieves a type right?
09:43:10 <tac> no
09:43:15 <tac> a constructor takes terms
09:43:17 <tac> and returns a term
09:43:22 <tac> a constructor itself is also a term
09:43:27 <tac> You can do :t Cons
09:43:29 <tac> or :t Nil
09:43:55 <acowley> No, the existential wrapping only takes me so far.
09:44:16 <bourbaki> Meh ok i do not think that i will get what Cons actually does.
09:44:29 <tac> It's a function.
09:44:34 <eacameron> I want to write something like try1 <|> Error "cannot do this or that" >>= try2 <|> Error "cannot do other thing >>= etc...   how would I do that? (I would like to use Maybe for try1, try2, etc.)
09:44:40 <tac> It takes two arguments, a "thing" and a list
09:44:50 <bourbaki> Functions are written with small letters right?
09:44:52 <tac> and it gives you a non-empty list back
09:45:24 <tac> Cons is actually a constructor
09:45:36 <bourbaki> Yes so is Nil.
09:45:41 <tac> Constructors are always written with caps
09:45:49 <tac> They work just like functions, but you can also pattern-match on them
09:46:12 <bourbaki> So let us pretend Cons was a function, what would it look like?
09:46:21 <tac> It is a function
09:46:25 <tac> You don't need to pretend :)
09:46:33 <bourbaki> Ok so what does it do?
09:46:47 <acowley> eacameron: Can't you just write exactly that modulo the capitalization of Error?
09:46:50 <tac> It creates list objects
09:46:55 <bourbaki> How?
09:47:02 <tac> bourbaki: because it's a constructor, it doesn't have a "definition" like you're probably expecting
09:47:18 <bourbaki> tac: I want the layout of the functions.
09:47:28 <bourbaki> cons x y = SafeList ...
09:47:32 <tac> nope!
09:47:35 <tac> doesn't work like that
09:47:42 <tac> It doesn't have a "definition" in that sense
09:47:54 <bourbaki> So it is just like magic happens here?
09:47:57 <tac> Because it's a constructor, it has a bit of a "built-in" nature to it
09:48:13 <bourbaki> And that is the stuff i want to know :)
09:48:18 <acowley> > Just 2 <|> error "nope" >>= return . (+1)
09:48:20 <lambdabot>   Just 3
09:48:28 <acowley> > Nothing <|> error "nope" >>= return . (+1)
09:48:29 <tac> What does a definition allow you to do? If I wrote cons x y = ....?
09:48:30 <lambdabot>   *Exception: nope
09:48:38 <tac> The answer is it allows me to *simplify* my term
09:48:44 <tac> But Cons's can't be simplified
09:48:52 <tac> If I have Cons "x" Nil
09:48:57 <bourbaki> tac: Then i also would know why there is no tail function.
09:49:00 <tac> That's it. I'm done. It's already evaluated.
09:49:19 <tac> There is a tail function, but it's type requires something called existential types.
09:49:52 <bourbaki> Yes so then please tell me how to write a tail function and what the type of (Cons _ x) = x is.
09:50:11 <bourbaki> Sorry but i think we are not getting anywhere :(
09:51:41 <eacameron> acowley: I want to return the error in Either
09:52:42 <hpaste> tac annotated “SafeList” with “SafeList tail” at http://hpaste.org/79573#a79578
09:52:50 <tac> bourbaki: That's one way to do a safeTail
09:53:04 <tac> but, like I said, it require existential types, which are poorly supported in Haskell
09:53:29 <tac> UnknownList is a list for which you don't know if it's empty or nonempty
09:53:41 <xplat>     parm = (,) <$> takeTill (('&'==) <||> ('='==) <||> isEndOfLine)
09:53:44 <xplat>                <*> A.optional (A.char '=' *> takeTill (('&'==) <||> isEndOfLine)
09:53:55 <acowley> eacameron: Oh, sorry!
09:54:00 <xplat> parser combinators, why are you ugly?  :(
09:56:45 <Yuu-chan> @src (*>)
09:56:46 <lambdabot> (*>) = liftA2 (const id)
09:57:06 <Yuu-chan> @unpl liftA2 (const id)
09:57:06 <lambdabot> liftA2 (\ _ b -> b)
09:57:55 <tac> bourbaki: I hope you figure it out soon :)
09:57:58 <bourbaki> Sec
09:58:08 <tac> GADTs are, in my opinion, kind of advanced
09:58:18 <tac> So don't worry if they don't make sense right away
09:58:21 <tac> I'm off to get some lunch
09:58:32 <djahandarie> I think they're easier to understand than non-GADTs.
09:59:09 <bourbaki> bb
09:59:18 <yitz> xplat: i use extra where bindings with nice names to take advantage of the neat semantic nature of the applicative style better
09:59:39 <djahandarie> Whenever I teach Haskell to people, I teach GADTs first, then teach the usual data syntax as shorthand for that.
09:59:45 <xplat> djahandarie: GADT syntax may be easier to understand, the extra power is not quite so easy
09:59:53 <tac> djahandarie: not once you get to indexed types. Equality constraints make life more safe, but also more difficult
10:00:11 <yitz> xplat: like maybe parm = (,) <$> firstOpt <*> A.optional secondOpt
10:01:07 <djahandarie> xplat, I don't think it's consideribly more difficult. Sure, certain types may be hard to understand, but I don't think that learning the basics of GADTs is particularly hard if it's explained from the start.
10:01:08 <yitz> xplat: firstOpt = takeTill endFirstOpt; secondOpt = "=" *> takeTill endSecondOpt
10:01:43 <yitz> etc.
10:01:53 <xplat> yitz: that's a good idea, but what really burns me is i have to specify both the separators and that the text between doesn't contain them, i can't just do like takeTextUngreedy or something
10:03:06 <thoughtpolice> edwardk: so intern is pretty cool, but i think your example is old and broken. it can also be made a bit shorter with 7.6.1, since you can use Generic to derive instances
10:03:34 <thoughtpolice> i think i may submit a pull request for this :P also edwardk, is bound modeled after unbound at all? unbound has had my interest for a while but i've never used it
10:06:17 <acowley> thoughtpolice: bound hews quite close to the cited McBride paper
10:06:34 <yitz> xplat: depending on how your code is structured, a way around that is to parse a bigger chunk of text and then feed that into another parser that breaks it up.
10:07:34 <hpaste> ciphergoth pasted “First experiments with Haskell STM” at http://hpaste.org/79579
10:08:32 <ciphergoth> So far I can't even get the above paste to compile; I just get "73.hs:15:13: parse error on input `return'"
10:10:47 <ciphergoth> would it be bad if there were syntactic sugar for < return $
10:10:56 <ciphergoth> for "<- return $" even?
10:11:06 <elliott> ciphergoth: "let foo = x" is "x <- return foo"
10:11:13 <elliott> er
10:11:15 <elliott> "foo <- return x"
10:11:26 <elliott> (except you save a return/bind so it's possibly faster)
10:11:42 <elliott> ciphergoth: the problem is that in your "in ...", the ... isn't in a do block
10:11:52 <edwardk> thoughtpolice: intern is old and busted. patches welcome
10:12:03 <hpaste> elliott annotated “First experiments with Haskell STM” with “First experiments with Haskell STM (annotation)” at http://hpaste.org/79579#a79580
10:12:05 <ciphergoth> elliott: ah, so I need another do!
10:12:07 <elliott> ciphergoth: you can add another do or just do ^
10:12:11 <elliott> (preferably the latter)
10:12:22 <edwardk> thoughtpolice: bound was my attempt to write a version of unbound that was lighter weight. i'm pretty happy with the minimalism of the result
10:12:40 <edwardk> it also feels a lot more 'fundamental' than unbound or other approaches
10:12:41 <crdueck> how do i apply a function to a field, and update the field with the result of the function using lens?
10:12:58 <edwardk> > (1,"hello") & _2 %~ length
10:13:00 <lambdabot>   (1,5)
10:13:06 <crdueck> edwardk: thanks
10:13:11 <edwardk> > over _2 length (1,"hello")
10:13:13 <lambdabot>   (1,5)
10:13:17 <edwardk> either works
10:13:48 <lispy> > length 1
10:13:50 <lambdabot>   No instance for (GHC.Num.Num [a0])
10:13:50 <lambdabot>    arising from the literal `1'
10:13:50 <lambdabot>  Possibl...
10:13:56 <lispy> oh, you said _2
10:14:01 <lispy> So it ignores the 1?
10:14:07 <ciphergoth> elliott: aha, that's great, thanks!  So now, after I fix the writeArray to actually give the index, I get a whole page of errors instead of one line, much better :)
10:14:14 <acowley> edwardk: I can't figure out how to have an Exp type that's polymorphic in its payload (e.g. classic motivating example of GADT expressions) and an instance of Monad.
10:15:18 <edwardk> lispy: _2 is the lens to access the second part of a tuple
10:15:40 <acowley> edwardk: I extended my Exp type to take a second type parameter for names, but then I have a constructor that takes a subexpression (Exp Int n), and so I can't write Foo x y >>= fb = Foo (x >>= fb) (y >>= fb)
10:15:45 <edwardk> acowley: i have a worked example using 'indexed' monads that does a strongly typed DSL but its not able to use bound directly
10:15:52 <edwardk> acowley: let me paste
10:15:54 <hpaste> ciphergoth annotated “First experiments with Haskell STM” with “First experiments with Haskell STM (annotation) (annotation)” at http://hpaste.org/79579#a79581
10:16:17 <edwardk> @hpaste
10:16:18 <lambdabot> Haskell pastebin: http://hpaste.org/
10:16:33 <hpaste> edwardk pasted “strongly typed bound for acowley” at http://hpaste.org/79582
10:17:03 <edwardk> basically its bound repeated 'one level up' so everything works on args of kind k -> * instead of *
10:17:17 <thoughtpolice> edwardk: i like how it's only a few months old and it's old and busted :P
10:17:43 <edwardk> thoughtpolice: the original design didnt work so i was forced to go with a compromise design that i don't like
10:17:59 <acowley> edwardk: gah
10:18:09 <thoughtpolice> ah, i see. i do think the mkCache bit is a bit ugly for sure :P
10:18:11 <edwardk> acowley: it gives you strong types =)
10:18:18 <budger> anyone use cabal on macos?  I did a cabal install darcs, looking for the path of the executable
10:18:32 <edwardk>   Lam :: Scope (Equal b) Remote f a -> Remote f (b -> a)
10:19:29 <wuttf> Who designed the haskell logo?
10:19:32 <edwardk> this means your free variables all have strong types
10:19:36 <acowley> edwardk: Yeah, but it's quite a load.
10:19:50 <edwardk> wuttf: it was a bit of a collaboration. if you look in the logo contest you can find the original proposal
10:19:59 <edwardk> it was originally paired with a stylized 'haskell'
10:20:23 <acowley> edwardk: What is Nat short for here?
10:20:30 <edwardk> acowley: this was a large part of why i started the indexed package, but with product kinds gimped until 7.8 or so i'm holding off
10:20:36 <edwardk> acowley: natural transformation
10:20:41 <wuttf> It looks extremely good.
10:20:41 <acowley> edwardk: I thought so
10:20:56 <acowley> edwardk: Nat is rather overloaded
10:21:18 <edwardk> wuttf: i've had multiple people approach me when I was wearing my haskell hoodie and make similar comments
10:21:34 <acowley> I spent some time reading this code wondering why you insisted on using natural numbers so concretely
10:21:46 <ciphergoth> ah the problem is that runSTArray is totally the wrong thing
10:23:44 <wuttf> edwardk: Overally, I am surprised how good is the design of the logo, haskell.org, hackage etc.
10:24:10 <edwardk> haskell.org was polished a couple of years back after the logo was introduced. it used to look pretty bad ;)
10:24:21 <c_wraith> ciphergoth: there's a nick that looks familiar. You been using haskell long?
10:24:32 <ciphergoth> c_wraith, not really
10:24:50 <ciphergoth> c_wraith, it's been on  my to learn list fora  long time, had a few goes and bounced off
10:24:54 <ciphergoth> but trying again
10:25:04 <wuttf> edwardk: :-)
10:25:15 <ciphergoth> wouldn't surprise me if I'd been in this channel asking for help before many moons ago :)
10:25:15 <Nereid> the old haskell logo was pretty awful
10:25:38 <Nereid> http://www.haskell.org/haskellwiki/Image:Haskellwiki_logo_big.png
10:25:55 <c_wraith> I suspect I have seen you here before..  But I was actually thinking of your work helping with the original openid draft. (I was one of the first implementers, so we interacted a bit back then)
10:26:37 <acowley> It's hard to come up with something nice to say about even the old logo's personality.
10:27:07 <acowley> Haskell: Press the unicode button!
10:27:15 <djahandarie> Hahaha
10:27:38 <wuttf> Nereid: +1
10:28:24 <elliott> Nereid: it had charm
10:28:33 <Nereid> that's not necessarily a good thing :p
10:28:47 <wuttf> But the new one. I will make a tattoo if Haskell turns out to be a good companion in my work.
10:29:09 <elliott> edwardk: I have to wonder how many people actually read haskell.org rather than just the first few sentences, the "recent package updates" section used to be months (years?) out of date
10:29:19 <elliott> seems like now it is just a link, heh
10:29:48 <xplat> edwardk: it seems like lately the more i look at really strong typing the more i see slice categories everywhere
10:30:44 --- mode: asimov.freenode.net set +o ChanServ
10:30:58 <benzap> ping
10:31:12 <Nereid> benzap: pong :)
10:31:50 * hackagebot semigroups 0.8.5 - Haskell 98 semigroups  http://hackage.haskell.org/package/semigroups-0.8.5 (EdwardKmett)
10:33:58 <bourbaki_> Do the constructors in the GADT extension always construct Sums of the values provided with the type on the right and under the, whatever the thing on the left is called?
10:35:23 <acowley> GADTs have a thing on the left?
10:35:29 <acowley> whitespace?
10:35:32 <bourbaki_> Sec
10:35:53 <hpaste> bourbaki pasted “blubb” at http://hpaste.org/79583
10:36:02 <bourbaki_> Eg Cons here.
10:36:40 <wuttf> After Go, where every function/type starts with the packagename, I feel blind when trying to comprehend Haskell code
10:36:46 <bourbaki_> It constructs a sum of values (Cons . .) :: the type on the right
10:36:49 <acowley> We usually say that SafeList is a sum of products, where each product is uniquely identified by its data constructor
10:37:15 <wuttf> Should I use an IDE or sumtin?
10:37:31 <bourbaki_> acowley: Ok and what is Cons called in (Cons . .) ?
10:37:41 <bourbaki_> What i called the thingy on the left.
10:38:09 <acowley> wuttf: You're in for a helluva ride, http://hackage.haskell.org/packages/archive/gnuplot/0.5.1/doc/html/Graphics-Gnuplot-Terminal.html
10:38:18 <acowley> bourbaki_: The data constructor
10:38:25 <acowley> bourbaki_: Or just constructor, for short
10:38:40 <bourbaki_> acowley: So the constructor an the thingy on the left in the brackets is the same?
10:39:00 <bourbaki_> I thought it was becoming somehow part of the type.
10:39:06 <acowley> wuttf: (That package is an extreme example of Haskell namespacing and is not representative of any general trend.)
10:39:33 <acowley> bourbaki_: I don't see any brackets in the definition of SafeList
10:40:07 <bourbaki_> acowley: When i do :t (Cons "x" (Cons "y" Nil))
10:40:16 <bourbaki_> then i get (Cons "x" (Cons "y" Nil)) :: SafeList [Char] NonEmpty
10:40:22 <xplat> data ThisIsAGADT :: * -> * where { ThisIsAConstructor :: Int -> String -> ThisIsAGADT Bool }
10:40:57 <wuttf> After a week of Haskell I can say that I am really pleased, and most of my fears regarding the language proved to be false.
10:41:19 <acowley> bourbaki_: Cons and Nil are data constructors. SafeList is a type constructor. Data constructors take values as parameters, such as "x", "y", and Nil. Type constructors take types as arguments, such as [Char] and NonEmpty.
10:42:32 <wuttf> However, doing Go for the past 6 months, I can't help but notice that while Haskell can be used for big applications, the culture around it does not plan for _extremely big_ software.
10:42:51 <xplat> _extremely big_ how?
10:43:11 <wuttf> Like corporate setting, 200 coders, millions of lines etc
10:43:30 <wuttf> But it's more about conventions than language
10:44:01 <acowley> I think if you looked at how many lines of library code get pulled into a big, modern Haskell project, the number would be fairly respectable.
10:44:25 <elliott> I would say Go does that way worse
10:44:30 <xplat> what conventions do Go coders have that are better than that?
10:44:41 <Yuu-chan> wuttf: usually n lines of Haskell code does the same functionality as about 10n of C++ or Java
10:44:42 <elliott> I can't imagine programming Go in anything but the small given the amount left implicit and done unsafely
10:44:47 <wuttf> Don't get me wrong, I aint intend to bash. I will most probably do most of my future work in Haskell.
10:44:59 <xplat> *better at that
10:45:10 <wuttf> Yuu-chan: I realize that.
10:45:43 <Yuu-chan> Btw, how Go-ers live without parametric polymorphism?
10:45:50 <stephenjudkins> Yuu-chan: [citation needed]
10:46:05 <xplat> Yuu-chan: you could always say 'but then i want to make a haskell project that does as much as 500 million lines of go'
10:46:14 <acowley> The best we can do for "proof" of industrial use in the Haskell community is point to some vague slides by financial companies suggesting they have large quantities of proprietary Haskell code.
10:46:45 <Yuu-chan> stephenjudkins: mainly personal experience
10:46:51 * hackagebot ghc-heap-view 0.4.1.0 - Extract the heap representation of Haskell values and thunks  http://hackage.haskell.org/package/ghc-heap-view-0.4.1.0 (JoachimBreitner)
10:47:19 <wuttf> xplat: First the already mentioned packagename prefix. Then the language itself is designed to have the least possible amount of solution to a problem, so
10:47:31 <stephenjudkins> Yuu-chan: Haskell is clearly a great tool, but a 10x difference in LOC per-functionality is a fantastic claim
10:47:52 <wuttf> you don't have to learn the "others way of solving a given problem"
10:48:11 <xplat> wuttf: so all your parsec stuff is like 'parsecMany', 'parsecIsEndOfLine', etc?
10:48:25 <Yuu-chan> stephenjudkins: but it is a real personal experience!
10:48:30 <wuttf> Yuu-chan: We suffer. The type system is exactly why I migrate to Haskell.
10:48:52 <stephenjudkins> Yuu-chan: i'm sure a diehard Go programmer has "real personal experience" too
10:49:05 <wuttf> xplat: I don't really get that.
10:49:48 <stephenjudkins> personally, I'm sympathetic to the claim that, for certain selected bits of functionality, you can see a 10x difference in LOC
10:49:51 <xplat> wuttf: can you give an example of what this packagename prefix looks like?
10:49:57 <Yuu-chan> Not only in small synthetic examples. When I rewrote my work from C++ into Haskell, I was simply amazed.
10:50:00 <stephenjudkins> but over an entire, large, codebase?
10:50:40 <Heffalump> I do have some sense that Haskell creates obstacles to large scale programs
10:51:06 <lolcathost> Heffalump: How so?
10:51:07 <Heffalump> (and I at least have some connection to medium amounts of proprietary Haskell code)
10:51:25 <wuttf> xplat: Of course, lets say you import       "github.com/xplat/stringHack" , then all of your methods, type etc are prefixed with  "stringHack", like   stringHack.DoWhatever()
10:51:34 <stephenjudkins> Yuu-chan: perhaps that is because you are a much better Haskell programmer than a C++ one? or, rather, you have a greater affinity for reusing Haskell abstractions than C++ ones?
10:51:52 <wuttf> xplat: It is verbose compared to haskell, but at first glance, you see the origin of all methods, types, consts etc
10:52:19 <xplat> wuttf: have you tried 'import qualified String.Hack'?
10:52:46 <wuttf> xplat: Thats why I say its a convention thingie. Nobody does that. In go, it is a must
10:53:00 <Heffalump> lolcathost: namespacing (e.g. record labels), awful debugging support, compilation times
10:53:35 <Yuu-chan> stephenjudkins: or I'm just a blind enthusiastic newbie.
10:53:54 <xplat> people absolutely do that, more with some packages than others (Data.Map, string packages and so on).  only they use 'as' to make the prefix shorter, because otherwise there would be more prefixes than the rest of the code
10:54:33 <benzap> what are the major differences between haskell, and lisp?
10:54:48 <xplat> Heffalump: ime haskell compilation times are nothing compared to C++
10:54:49 <benzap> i hear haskell is more a restriction to enable more pure functional programming
10:54:58 <wuttf> Whats the deal with that record thingie, I hear everywhere that there is some kind of problem with that regarding "namespaces" but I don't get it
10:55:00 <monochrom> use hugs to reduce compilation times
10:55:01 <Canar> benzap: types!
10:55:26 <lolcathost> benzap: In Haskell much more so than in any other widely used language, types direct your reasoning.
10:55:39 <Yuu-chan> But really, C++ simply didn't have enough expression power. There were even two external DSLs in our project to reduce the boilerplate. In Haskell, I implemented the first via TH macros, and the second via eDSL on combinators.
10:55:40 <wuttf> Heffalump, xplat when you have an interpreter it doesnt matter
10:55:46 <Heffalump> xplat: I have experience of both and I disagree :-)
10:56:08 <Heffalump> wuttf/monochrom: it's more work to maintain code in a way that it can be used from an interpreter
10:56:19 <xplat> Heffalump: realistically i suppose it depends what dialect of C++
10:56:20 <Heffalump> even ghci, and hugs is way out there in unusability
10:56:42 <wuttf> Heffalump: I am not aware of that. What is the difference?
10:56:47 <Yuu-chan> The only thing I wanted was the convenient IDE
10:57:00 <Heffalump> wuttf: difference between what and what?
10:57:14 <wuttf> Heffalump: GHCi and GHC
10:57:16 <Heffalump> between compiled ghc and ghci: memory usage, speed, setting up the context for your code to run in
10:57:33 <benzap> how low-level can haskell be? Like can you make a conditional of some sort, and know waht the underlying assembly code would produce?
10:57:41 <Heffalump> with an average large project you can't just run ghci on some source file and expect to ebe able to do anything useful
10:57:42 <wuttf> Heffalump: But you can use the interpreter while developing, no? To avoid long compile times.
10:57:56 <Yuu-chan> benzap: yes, see chapter 25 of RWH
10:58:05 <Heffalump> wuttf: only if you can feasibly run whatever you are actually developing from within the interpreter
10:58:40 <benzap> what is RWH? where's the chapter? http://www.rwhconstruction.ca/index.jsp
10:58:47 <Yuu-chan> benzap: it tells about profiling, low-level optimizations and so on
10:58:52 <Yuu-chan> @where rwh
10:58:52 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
10:59:04 <wuttf> Will the development of Haskell slow down now that Simon Marlow left?
10:59:09 * Yuu-chan is mastering lamdabot
10:59:18 <wuttf> Or did I join the party at the worst possible time?
10:59:21 <xplat> a good example of interpreter/compiler difference is that in the interpreters it matters if you use foldl or foldl', with optimization on it basically doesn't
10:59:35 <monochrom> I don't understand. "runhugs main.hs" and "main.exe" are different in compilation time and execution time, sure, that's my point. but I don't see a difference in "maintaining code"
10:59:53 <Heffalump> wuttf: the direct impact will definitely be negative. But I sense that it's actually triggering changes in process that will over time speed up GHC development.
10:59:56 <wuttf> monochrom: That's my question too.
11:00:02 <Heffalump> (by bringing lots more people into play)
11:00:23 <wuttf> Heffalump: How come?
11:00:46 <benzap> Yuu-chan: ah thanks
11:00:51 <Heffalump> ganesh@urchin:~/darcs/screened$ runhugs darcs/darcs.hs
11:00:51 <Heffalump> runhugs: Error occurred
11:00:51 <Heffalump> ERROR "darcs/darcs.hs" - Can't find imported module "Version"
11:00:56 <monochrom> if you say, testing using "ghci main.hs" is different, I know. but I am not thinking "ghci main.hs". I'm thinking "runhugs main.hs"
11:01:09 <xplat> wuttf: it creates a status vacuum that will make learning the GHC internals more attractive to status-seeking programmers
11:01:09 <Heffalump> wuttf: how come what?
11:01:41 <xplat> especially ones named Simon
11:01:50 <wuttf> Heffalump: How will that bring people in?
11:02:10 <wuttf> xplat: :D lol
11:02:32 <monochrom> ok, module Version not found is just a search path issue
11:02:36 <Heffalump> wuttf: because people (like Simon PJ) are actively trying to do so and looking at what barriers to entry there are
11:02:41 <wuttf> Also I think SPJs productivity will be impacted, I mean they were mates, no?
11:02:47 <monochrom> and possibly forgetting to turn on some extensions
11:02:52 <xplat> as a side effect of a lot of new people learning the internals there will be a lot of refactorings that make it easier to learn and hack
11:02:54 <Heffalump> monochrom: no, it's a build issue: Version.hs is generated by cabal running Setup.hs
11:03:03 <Yuu-chan> "Let's wait for PHP with monads and software transactional memory :)" (Alex Ott)
11:03:17 <Heffalump> if we get past all the dependencies we'll discover that darcs doesn't actually run in hugs at all due to language extensions
11:03:57 <monochrom> ok, then "runghc" will work?
11:04:13 <Heffalump> personally, I typecheck darcs in ghci (which is itself a bit of a pain to get hold of the right ghci commandline to use) and then build it to actually test it running
11:04:21 <wuttf> gtg guys, have a good night
11:04:45 <xplat> the monads in PHP will come with a convenience unwrapper to get the value out if you feed it to a function expecting a non-monadic value :)
11:04:55 <Heffalump> and to get that working I vaguely recall I had to do some work to fix some stuff in darcs that didn't work in ghci due to external libraries not doing so
11:05:38 <Heffalump> that experience (of using an interpreter) with darcs roughly mirrors my commercial experience with a different project
11:05:39 <xplat> and the STM will have explicit commit and rollback and no automatic retry
11:06:30 <Yuu-chan> xplat: :D
11:07:50 <hpaste> Heffalump pasted “ghci command-line” at http://hpaste.org/79584
11:08:23 <Heffalump> monochrom: that's the command-line I currently use - which I generate by trappign the output of cabal build -v and messing around with it quite a bit
11:09:33 <epsil> so in haskell, functions are values; therefore it makes perfect sense that functional types can be types in their own right. for example:
11:09:36 <epsil> type ReadS a = String -> [(a,String)]
11:09:38 <epsil> is there a name for such types? tried to google for details, but found little.
11:09:45 <Heffalump> type synonym?
11:10:00 <Heffalump> oh, never mind
11:10:09 <Heffalump> "function type"?
11:10:38 <monochrom> String -> [(a,String)] is already a type in its own right
11:11:20 <epsil> monochrom: sure :)
11:11:54 <epsil> Heffalump: there's the problem, "function type" just gives hits about how functions have types
11:13:15 <Yuu-chan> "A parser of things is a function of strings to the list of pairs of things and strings"
11:13:47 <ceii> epsil: strictly speaking (at least in the ML tradition) types are tied to expressions, so the existence of "function types" precisely means that there are function-valued expressions
11:13:48 <Yuu-chan> I get this mantra now :3
11:14:00 <ceii> if that's what you were asking
11:17:36 <johnw> edwardk: pin
11:17:37 <johnw> g
11:17:43 <edwardk> yo
11:17:51 <johnw> hey, where should I start reading to begin using trifecta?
11:18:08 <johnw> a look in the usual places yielded nothing so far
11:19:56 <edwardk> johnw: for trifecta pretend its parsec and use some different combinators to launch the parser
11:20:07 <epsil> Yuu-chan: who said that, Graham Hutton? I think it was in Programming in Haskell :)
11:20:11 <epsil> ceii: hm, I don't think I have a well-defined question yet. I'm just looking for more details on "type" and "data", most of what I find is pretty introductory
11:20:17 <johnw> edwardk: alright, let me give that a go
11:20:23 <edwardk> johnw: i've been meaning to do more or less a full rewrite on it, but its been pushed down the stack a ways
11:20:52 <Yuu-chan> epsil: I don't know the author, I've seen that in this chat :)
11:21:12 <johnw> rewriting the whole library API?  should I avoid it then?
11:21:13 <edwardk> Yuu-chan: that sounds like the 'list of successes' parser model
11:21:30 <edwardk> johnw: the overall combinator set won't change much
11:21:34 <edwardk> johnw: it'll just get nicer to use
11:22:02 <edwardk> also the current layout parsing stuff is broken, so be careful
11:22:16 <johnw> i won't be doing layout parsing
11:22:28 <johnw> i just want to write a new parser for Ledger, and thought trifecta could give me good error reporting
11:24:39 <epsil> Yuu-chan: found it, it's in chapter eight. their rendition is: "A parser for things / Is a function from strings / To list of pairs / Of things and strings"
11:25:06 <edwardk> johnw: thats the sort of thing it'd be great for
11:25:33 <Yuu-chan> epsil: Hutton, or Seuss? I've found http://www.willamette.edu/~fruehr/haskell/seuss.html
11:26:59 <epsil> Yuu-chan: Hutton, don't know the original source though
11:51:55 <mreh> hSetEcho False stdin seems to have no effect
11:53:55 <Nereid> mreh: it works as long as you're not in ghci
11:54:21 <mreh> Nereid: I'm not!
11:54:32 <Nereid> well it works for me!
11:54:46 <mreh> oh, I see what I did wrong :)
11:55:02 <fried_taters> Question: Why ever use getStdGen, when you can use newStdGen and get a new generator while re-seeding at the same time? I'm missing something
11:55:24 <johnw> edwardk: in Parser r e a, what is r and a?  which one is the result type of the parse?
11:55:52 <mreh> :t getStdGen
11:55:54 <lambdabot> IO StdGen
11:57:00 <johnw> edwardk: found the examples :)
11:57:25 <fried_taters> :t newStdGen
11:57:27 <lambdabot> IO StdGen
11:57:30 <ceii> fried_taters: I'd suspect performance. Everything you do with the system random generator is pretty slow
11:57:31 <xnyhps> fried_taters: Sometimes you don't want to reseed it.
11:57:41 <edwardk> is the result type for the continuation, you should never use it basically. a is the result of the parse action
11:57:42 <ceii> but getStdGen only retrieves a cached seed
11:57:51 <edwardk> er r is
11:57:55 <edwardk> bah
11:57:57 <monochrom> perhaps because you want to save it in a file
11:57:58 <johnw> interesting, MonadParser m => m a
11:58:08 <johnw> i guess 'm' is Parser?
11:58:09 <edwardk> r is the result type of the continuation you shouldn't use. a is the result of the parse action
11:58:11 <edwardk> yeah
11:58:22 <Nereid> m would be Parser r e, then
11:58:23 <Nereid> ?
11:58:40 <johnw> ah
11:58:40 * Nereid hasn't looked at trifecta
11:58:44 <johnw> so, not *quite* like Parsec :)
11:58:49 <johnw> the combinators seem to be
11:58:58 <Nereid> I think that's the point.
11:59:07 <fried_taters> Yah, that makes sense. Sometimes you wouldn't want to reseed. I guess everything I had in mind would need some sort or reseeding
11:59:12 <edwardk> johnw: unlike parsec trifecta's parsers are able to be monad transformed
11:59:13 <monochrom> under the iron wrist of shapr, #haskell has grown over 2^10 :)
11:59:49 <edwardk> clearly he should have just sat in this channel and kicked anyone who tried to join
11:59:57 <monochrom> general advice: if you don't find something in the library useful, just don't use it
11:59:58 <edwardk> think of all the extra productivity we'd all have
12:00:31 <Nereid> edwardk: why kick the new people? it should be more like a queue. :p
12:01:52 * hackagebot buildwrapper 0.6.4 - A library and an executable that provide an easy API for a Haskell IDE  http://hackage.haskell.org/package/buildwrapper-0.6.4 (JeanPhilippeMoresmau)
12:11:56 <mvj4_> what's the general approach to dealing with broken dependencies on hackage? no haddocks generated for my package. any way to generate all documentation except some subset?
12:12:37 <mvj4_> to clarify: my package depends on something that won't compile on hackage.
12:13:54 <Saizan> mvj4_: sadly there's no solution for that
12:14:58 <c_wraith> yeah.. It hits native bindings especially hard.
12:18:24 <mvj4_> alright, thanks!
12:23:43 <roconnor> When I write my own haskell report, it will be illegal to export values from a module without all components of its type also being exported.
12:25:52 <Heffalump> roconnor: .NET has that rule
12:26:52 <budger> roconnor: how will you support types such as Text that have computational constraints?
12:27:07 <roconnor> what are computational constraints?
12:27:26 <budger> roconnor: I was afraid you were going to ask that
12:28:49 <budger> roconnor: the Text constructor is not exposed because the data is packed.  All access to the data goes through functions that understand that packed structure
12:29:11 <roconnor> oh I'm okay with not exporting constructors
12:29:26 <budger> roconnor: oh, okay, then I misunderstood
12:29:28 <roconnor> just if you export foo : Bar -> Baz, then you must export the types Bar and Baz.
12:29:46 <roconnor> (not necessarily the type constructors for Bar and Baz though)
12:29:58 <roconnor> s/type constructors/constructors/
12:31:23 <budger> roconnor: I've actually never run across that.  The hidden constructor problem is what aggravates me.  Or rather, the lack of certain instances that results.
12:34:36 <Heffalump> budger: that's a question of abstraction (or not)
12:35:21 <roconnor> I'm a big fan of orphan instances
12:35:30 <budger> Heffalump: It's a question of abstraction not being fully supported
12:36:05 <Heffalump> budger: in what sense?
12:36:47 <budger> Heffalump: I'm fine with the library hiding the details, but only if all the language features continue to be supported.  Generics has been the big problem.
12:37:28 <budger> Heffalump: it is getting better with GHC.Generics, but I haven't had time to really push on it.
12:38:39 <roconnor> So far, uniplate and it's derivatives have been adquate for my (light) generic programming needs
12:38:53 <budger> roconnor: why? (orphan instances)
12:39:27 <roconnor> the nice thing about uniplate is that you can make "semantic" substructures instead of only syntactic substructures.
12:39:42 <roconnor> you need "semantic" substructures to work nicely with abstract data types.
12:39:44 <budger> roconnor: Data.Data was broken for Text and similar types for a long time.
12:40:15 <budger> roconnor: but Uniplate only takes you so far.  It doesn't get you serialization, for example
12:40:20 <roconnor> budger: I like orphan instances because then I don't need my package dependences to be in a total ordering.
12:40:43 <roconnor> budger: well, you should have said: serialization and data abstraction don't mix. :D
12:40:46 <Heffalump> budger: but Generics arguably violate abstraction
12:41:08 <budger> roconnor: hah
12:41:34 <budger> Heffalump: I'm not convinced of that.
12:41:40 <johnw> is there another name for "either id id"?
12:41:45 <roconnor> at least if you want to serialize wrt implementation details.
12:42:31 <johnw> edwardk: can you take a peek at my grammar?
12:42:41 <budger> Heffalump: Neil Mitchell has some nice generic methods for handling opaque types in a blog somewhere
12:42:43 <johnw> edwardk: it's claiming I'm accepting an empty string, but I don't see what's wrong with that
12:42:53 <hpaste> johnw pasted “Text.hs” at http://hpaste.org/79587
12:42:56 <roconnor> My Colour type is an abstract data type and I declined to provide a Data instance. ... for serialization I demand the user convert Colour to an RGB triple if they want serialization.
12:43:08 <budger> Heffalump: I should pick that up and wave it on a flag soon
12:43:29 <edwardk> johnw: 'many' is 0 or more
12:43:31 <roconnor> that way if I change my colour representaiton, the serialization function won't change (modulo floating point stuff).
12:43:42 <edwardk> ou may want some journalParser on the outside
12:43:42 <johnw> edwardk: ok...
12:44:08 <johnw> a journal could be empty, or have one or more RawEntity's inside it
12:44:17 <budger> roconnor: while that seems reasonable from a theoretical perspective, it's goit to be a problem for my image ibrary
12:44:52 <roconnor> budger: your code will be better for it ;P
12:45:05 <Heffalump> budger: http://neilmitchell.blogspot.co.uk/2011/11/abstract-generics-with-uniplate.html
12:45:12 <budger> similarly, to have to fight upstream to get a Text object through JSON encoding, as I did a few years ago, is not going to win us more users
12:45:17 <edwardk> johnw: https://github.com/DylanLukes/Winchester-STG-Compiler/blob/master/WSC/Parser.hs might give you a feel for what an idiomatic parser written with trifecta would look like
12:45:52 <johnw> I don't know what you mean yet by "on the outside"
12:45:55 <budger> roconnor: you might like my code better, but my users will be talking to python developers
12:46:17 <edwardk> Heffalump, budger : FWIW, the uniplate stuff in lens generalizes uniplate and happens to be faster
12:46:44 <budger> edwardk: It's on my list to try soon.
12:46:56 <simpson> edwardk: Wait, it's faster *and* more flexible?
12:47:01 <edwardk> simpson: yes
12:47:22 <edwardk> 35% faster for most benchmarks and you can use all the uniplate combinators on any traversal
12:47:24 <budger> edwardk: but I'm still getting used to aspects of Control.Lens
12:47:24 <simpson> edwardk: Nice work!
12:47:38 <roconnor> edwardk: are you using Oleg's benchmarks?
12:47:39 <edwardk> > universe "hello"
12:47:41 <lambdabot>   ["hello","ello","llo","lo","o",""]
12:47:59 <edwardk> roconnor: oleg wrote benchmarks?
12:48:04 <edwardk> roconnor: (you can take that to be no)
12:48:23 <roconnor> http://dl.acm.org/citation.cfm?id=1543134.1411301
12:48:31 <johnw> edwardk: so, what is Parser.hs doing that I'm not doing?
12:48:31 <simpson> > universe ("hello", "world!")
12:48:33 <lambdabot>   No instance for (Control.Lens.Plated.Plated
12:48:33 <lambdabot>                     ([GHC.Types...
12:48:36 <budger> edwardk: so here's a question I stumbled on a week ago...
12:48:40 <roconnor> it is supposed to be "the" standard in comparing generic programming libraries in haskell
12:48:41 <edwardk> roconnor: i'll give that a shot at some point
12:48:55 <budger> edwardk: i wanted to build compare and swap using lenses
12:49:05 <edwardk> > universeOn both ("hello,"world")
12:49:07 <lambdabot>   <hint>:1:33:
12:49:07 <lambdabot>      lexical error in string/character literal at end of input
12:49:09 <weasels> :t universe
12:49:11 <lambdabot> Plated a => a -> [a]
12:49:12 <edwardk> > universeOn both ("hello","world")
12:49:14 <lambdabot>   ["hello","ello","llo","lo","o","","world","orld","rld","ld","d",""]
12:49:18 <johnw> on EOF I'm getting: /tmp/foo.dat:4:1: panic: 'many' applied to a parser that accepted an empty string, expected: ";", "\n", "\r\n"
12:49:26 <budger> edwardk: at first I thought I could make one Setter to do it, but it seems to violate the lens laws
12:50:00 <edwardk> > over (partsOf both) reverse (1,2)
12:50:02 <lambdabot>   (2,1)
12:50:08 <johnw> if I had a parse rule for (eof *> pure EndOfFile), it doesn't change anything
12:50:33 <edwardk> johnw: you have bigger problems than i can solve in the ~5 minutes i have left. but i will help ;)
12:50:42 <edwardk> you need to resolve the ambiguity of your grammar
12:51:21 <edwardk> right now you have no way to tell the journal when its 'done'. the outer thing can accept 0 or more of the inner things.
12:51:23 <johnw> ambiguity?  I have two terms: ';.*<EOL>', and '<whitespace><EOL>'
12:51:57 <johnw> i see
12:52:03 <johnw> ok, i'll track it down then
12:52:04 <johnw> thanks edwardk
12:52:17 <edwardk> if you change many for some in places that would help
12:52:45 <edwardk> budger: cas would be an operation that takes a setter rather than a setter itself
12:53:24 <budger> edwardk: Okay, that;s what I decided.
12:53:43 <johnw> edwardk: is there a way to get it to tell me which parsing function it was in when the error occurred?
12:53:57 <edwardk> you can make better use of (<?>) in your grammar
12:53:57 <johnw> i suppose i do that with <?>
12:57:09 <neutrino_> @hoogle <?>
12:57:09 <lambdabot> Text.Parsec.Prim (<?>) :: (ParsecT s u m a) -> String -> (ParsecT s u m a)
12:57:09 <lambdabot> Text.ParserCombinators.Parsec.Prim (<?>) :: (ParsecT s u m a) -> String -> (ParsecT s u m a)
12:57:13 <neutrino_> ah
12:58:01 <johnw> aha
12:58:30 <johnw> manyTill (satisfy isSpace) needed to be satisfy isSpace <*> manyTill (satisfy isSpace)
12:58:41 <johnw> i needed to at least make it LL(1)
12:58:55 <johnw> err, *>, not <*>
12:59:13 * neutrino_ gets confused when parsers come up
12:59:34 <johnw> neutrino_: why is that?
12:59:38 <neutrino_> i used to know what LL(1) was, but then i have successfully managed to erase any trace of that knowledge
12:59:45 <neutrino_> dunno
12:59:52 <johnw> LL(1) means your parser always branches on the current token
12:59:53 <neutrino_> i guess a subset of innumeracy
12:59:55 <neutrino_> ;)
13:00:01 <neutrino_> johnw: oh
13:00:07 <neutrino_> what does it mean that the parser branches?
13:00:21 <johnw> case currentToken of a -> parseA; b -> parseB; etc.
13:00:38 <neutrino_> why would it not branch?
13:00:58 <johnw> well, i'm generalizing; a branch with only one leg is a special case
13:01:05 <johnw> case currentToken of a -> parseA
13:01:15 <johnw> in both cases, failure to match is a parsing error
13:01:24 <neutrino_> what about "of _" ?
13:01:31 <neutrino_> is that still LL(1)?
13:01:44 <johnw> at some point you have to address what _ is
13:02:08 <johnw> your parser can't continue without resolving _
13:02:24 <johnw> even if it's just "take the token and stuff it in this box, then get the next one"
13:02:30 <johnw> which is why "many anyChar" will do, for example
13:02:41 <neutrino_> yeah
13:03:00 <neutrino_> the last time i used parsec to parse something i was still very new to haskell
13:03:09 <neutrino_> it worked, but it was real bad :D
13:03:31 <neutrino_> and it was mostly me bugging everyone here to hold my hand writing it :D
13:12:58 <johnw> too bad it's out of print ,but Holub's book on parsing is a great intro
13:13:19 <johnw> http://www.amazon.com/Compiler-Design-C-Prentice-Hall-software/dp/0131550454
13:13:28 <johnw> used price isn't so bad actually
13:14:11 <johnw> i wrote an LALR generator in Perl based on his explanations in that book, which caused it all to finally sink in
13:15:01 <acowley> It's fun how I recognize I'm working on some edwardk code when, amidst horrifically sophisticated type-level shenanigans, I stumble into an unsafeCoerce.
13:15:10 <johnw> haha
13:21:54 * hackagebot HueAPI 0 - API for controlling Philips Hue lights  http://hackage.haskell.org/package/HueAPI-0 (SjoerdVisscher)
13:31:09 --- mode: asimov.freenode.net set +o ChanServ
13:47:46 <elainebenes> how would you go about learning tcp/ip? is their some good program to write that could teach me about it?
13:49:31 <parcs> what do you want to learn about it?
13:49:38 <parcs> wikipedia is a good resource, as always
13:50:24 <budger> anyone know a magic incantation to get lens to cabal install on haskell platform?
13:51:42 <hpc> which platform, which lens version?
13:51:55 * hackagebot semigroups-actions 0.1 - Semigroups actions  http://hackage.haskell.org/package/semigroups-actions-0.1 (PetrPudlak)
13:57:00 <edwardk> budget: 'cabal install lens' should do it
13:59:56 <budger> edwardk: I had tried that, of course.  I think my cabal install was corrupted.  Previously I got nothing but version conflicts.  Working beautifully now.
14:00:34 <edwardk> budger: next time you get stuck feel free to hpaste the conflict report and we can try to work through it
14:01:23 <budger> edwardk: thanks.  it was enormous.  I think the solution is to buy a linux laptop and ditch my mac.
14:01:44 <edwardk> interesting way to try to improve things
14:02:18 <budger> edwardk: well, I'm on vacation trying to hack on a new project, and so far all I've done is configure...
14:02:38 <simpson> budger: You can put Linux on most Apple hardware. It's a little bit of an adventure, but the results are satisfactory, according to my Apple-buying friends.
14:03:00 <budger> simpson: adventure is precisely what I'm looking to avoid
14:03:21 <r2jitu> simpson: battery life sucks with Linux on an MBP
14:03:26 <budger> I just need a real photographic manager for linux
14:03:30 <simpson> r2jitu: 'k.
14:03:39 <r2jitu> actually, a better solution is to install linux in a VM
14:03:41 * simpson is still too poor to afford the White 'n' Shiny
14:04:12 <budger> r2jitu: yeah, maybe
14:05:07 <budger> I know it's time to do something else when I yell like Fry: Fix it! Fix it! Fix it!
14:05:28 <sm> budger: generally the quick way to solve cabal package conflicts is clear your installed packages and start over
14:05:55 <johnw> haha
14:05:56 <budger> sm: I think that's what I did, but I forgot to retry instlaling lens
14:05:59 <johnw> sm: I _just_ did that right now
14:06:12 <johnw> I have a script called "cabal-bootstrap.sh" which wipes me out and then returns me to a working state
14:06:16 * sm too
14:06:28 <budger> sigh
14:06:42 <edwardk> the few times i break cabal i just rm ~/.ghc and carry on
14:06:43 <johnw> in fact, I'm just going to run it nightly after a "cabal update"
14:06:46 <sm> johnw interesting to see your parsing experiments! I also need better ways to debug parsers.
14:06:58 <sm> http://hub.darcs.net/simon/hledger/browse/hledger-lib/Hledger/Utils.hs#346 (parsec) has been quite a hlep
14:07:00 <johnw> this trifecta parser is coming along nicely
14:07:00 <sm> help
14:07:10 <hpaste> johnw pasted “Test2.hs” at http://hpaste.org/79592
14:07:21 <johnw> this is the "raw" journal parser I was telling you about
14:07:35 <johnw> next will be to write Ledger.Parser.Cooker
14:07:42 <edwardk> you may want to try switching to a token parser to free yourself from wrestling with whitespace and newlines
14:08:02 <johnw> edwardk: the journal format is too freeform for that, I think
14:08:24 <edwardk> predefined format?
14:08:31 <johnw> a format i invented
14:08:37 <johnw> but which now has many users
14:09:20 <johnw> there are times when "space space | TAB | space TAB" is as significant delimiter
14:09:37 <budger> johnw: ouch
14:09:47 <Clint> that's bitten me
14:09:48 <johnw> yeah, well, that's what you get for allowing spaces in account names...
14:09:49 <sm> I suppose you could still tokenise all that though
14:09:58 <johnw> sm: perhaps I could
14:10:07 <johnw> i'll check that out
14:10:07 <sm> some of my parsers are excessively tricky because of lack of tokenisation I think
14:10:22 <johnw> anything to improve error reporting and reduce corner cases
14:10:25 <sm> +1
14:10:36 <johnw> although, how do I preserve spaces in account names?
14:10:46 <johnw> or in directive argument,s which are 100% freeform?
14:10:51 <johnw> it would be a lexer with a lot of states
14:10:58 <budger> johnw: one thing I've learned from usng Safecopy. data migration can free your soul...
14:11:55 * hackagebot alpha 1.0.13 - A compiler for the Alpha language  http://hackage.haskell.org/package/alpha-1.0.13 (MarcCoiffier)
14:12:02 <budger> snowing outside, cat on my lap, ...and cold tea.  Grrr
14:12:29 <johnw> snowing just stopped here, after few hours
14:12:32 <johnw> still very windy though
14:12:57 <budger> I'm in the midwest, about to get dumped on
14:16:01 <budger> I think Setup.hs should not be including Path_ modules
14:31:55 * hackagebot sqlite-simple 0.3.0.0 - Mid-Level SQLite client library  http://hackage.haskell.org/package/sqlite-simple-0.3.0.0 (JanneHellsten)
14:33:04 <johnw> edwardk: can a trifecta parse also give me the line/col of the entity parsed?
14:33:15 <johnw> i want to track that info
14:37:01 <johnw> sometimes cabal makes it very difficult to track down which dependency in which package is causing another package to downgrade another dependency
14:37:43 <johnw> ah
14:37:51 <johnw> edwardk: trifecta needs to relax its upper bound for hashable
14:38:10 <johnw> pull request coming..
14:41:06 <HugoDaniel> hi
14:44:52 <edwardk> johnw: you'll need to go off an older version. master on github is pretty far away from whats on hackage
14:45:06 <johnw> i'm trying to fix Trifecta now
14:45:15 <johnw> to use the new hashable
14:45:16 <edwardk> i'll give you commit access to the repo
14:45:30 <johnw> thx!
14:45:33 <edwardk> you can fork off a branch in there for the current hackage version and put the commit directly in
14:45:41 <johnw> ok
14:46:00 <edwardk> you're added
14:46:43 <`ramses> I've read in some places (including here) that monads are less efficient compared to applicatives, but I can't find a reference that explains why that is. Anyone got a pointer to some detailed information?
14:48:22 <monochrom> I haven't heard that one
14:49:04 <`ramses> applicatives would use less memory, something about monads having to remember stuff..
14:49:37 <monochrom> I haven't heard that one either
14:50:38 <`ramses> I've read that for instance a common problem with monadic parser combinators was their memory usage, and applicative parsers would be more space efficient
14:51:02 <`ramses> but I only read that somewhere, I'd like to know the details though, hence the question :)
14:51:29 <lispy> `ramses: is it because of backtracking?
14:51:59 <johnw> edwardk: dewa
14:52:03 <johnw> edwardk: https://github.com/ekmett/trifecta/tree/new-hashable
14:52:06 <johnw> working now
14:52:08 <`ramses> could be... but I think the problem is not limited to parsers
14:52:45 <roconnor> there is an issue with parser's not being online and returning Maybe Foo.
14:52:57 <roconnor> thus to test if Nothing or Just requires parsing the entire file!
14:53:00 <`ramses> I had the impression that in general using e.g. liftA instead if liftM lead to more space efficient code
14:53:13 <roconnor> I'm not sure if this is an applicative vs monad issue.
14:53:24 <elliott> it's more that with an applicative interface you can do more optimisations on parsers
14:53:30 <elliott> whereas join restricts what you can do a bit
14:53:32 <monochrom> I would be surprised if "liftA2 (++) getLine getLine" is more efficient than "liftM2 (++) getLine getLine"
14:53:38 <elliott> but monadic parsers are more flexible
14:53:46 <elliott> not really to do with lower-level details of liftA/liftM or whatever
14:54:32 <`ramses> ah, but is it a property of monads/applicatives and how they are compiled and optimised or is it rather a result of how they are used (for instance in those parsers)
14:54:58 <`ramses> I mean, is this a general thing or is it limited to their usage for parsers
14:56:19 <elliott> it's... not really either
14:56:26 <elliott> monads let you do more so you can optimise less in certain situations
14:56:40 <elliott> the more dynamic tools you have the less you can optimise them statically
14:58:09 <johnw> edwardk: can I capture the current line number at any time during parsing?
14:58:16 <edwardk> yes
14:58:27 <edwardk> you can even capture the contents of the line with a caret to that location
14:58:35 <johnw> which module is that in?
14:59:07 <johnw> it's just 'caret'?
14:59:28 <edwardk> position gives you a 'Delta'
14:59:48 <johnw> ah, that's it
14:59:49 <johnw> great, thanks!
15:00:01 <Philippa> elliott: Another way of putting it is that >>= is pretty antagonistic to static analysis (it's those outermost ->s that do it)
15:00:02 <edwardk> you can rend will give you a 'Rendering' that gets to the current position that is nice for errors
15:00:12 <elliott> Philippa: yeah
15:00:14 <Philippa> (or rather, it's the one in the RHS)
15:00:15 <johnw> i like your lexeme guy too, i see what you mean about tokens
15:00:17 <edwardk> you can scribble carets and ~~~'s and fixits all over that
15:00:23 <elliott> one of the cases where (>>=) lets you see something more obviously than join
15:00:45 <johnw> can I come back later after the parse and produce a rendering?
15:00:46 <Philippa> that depends how you see things: join says "my language is higher-order!", which coupled with return is what we call a hint ;-)
15:00:46 <edwardk> lexeme is stolen from parsec i just make it easier to use
15:00:51 <`ramses> Philippa: you mean that it's harder to optimise code inside that lambda?
15:00:58 <edwardk> you can capture the renderings as you go they are pretty lightweight
15:01:04 <johnw> ok, that works
15:01:04 <edwardk> just stuff them in the syntax tree
15:01:09 <edwardk> and then draw on them later if need be
15:01:09 <johnw> that's what I really wanted, not the position
15:01:20 <elliott> Philippa: yeah. I think it's easier to see directly if you have that pesky function arrow
15:01:27 <Philippa> `ramses: you can't see how a function-as-in-(->) 'decides' things
15:01:28 <johnw> is the parser lazy, or do I need to restart it?
15:01:55 <Philippa> elliott: yeah. But we can go as far as "...has all the problems of general Haskell"
15:02:12 <Philippa> what you /can/ do is work with the applicative fragment still. Regardless of whether the relevant chunks of it are inside a function
15:02:13 <elliott> `ramses: these kinds of inefficiencies only come up when you specifically "optimise" your parsers in your parser library, basically
15:02:25 <johnw> i guess it can't be lazy, same reason as with parsec?
15:02:29 <elliott> you can take advantage of the fact that not supporting a monadic interface means you don't have any parsers that depend on results of previous parsers
15:02:35 <elliott> so you can do more
15:02:42 <`ramses> Philippa: I don't understand that sentence.. what do you mean with "seeing what it decides"? Not guessing it's result, I guess?
15:02:55 <Philippa> elliott: or even support a limited, friendlier form of context-dependence where you're not passing actual, live functions around
15:03:09 <Philippa> `ramses: you're not allowed to ask "how does a function work?" once it's a function
15:03:13 <edwardk> johnw: yeah same problem as parsec
15:03:18 <Philippa> `ramses: so there's not a lot you can do to optimise it as such
15:03:23 <johnw> easy enough to solve with a fold
15:03:45 <Philippa> whereas with an applicative you're free to run all kinds of static analyses that your parse function depends on
15:03:46 <elliott> Philippa: (>>=#) :: a -> (a -># Parser b) -> Parser b :)
15:04:02 <elliott> actually, with the notion of (->#) as closureless function, that might buy you something in some cases
15:04:27 <`ramses> Philippa: I don't get that, why can't you ask how a lambda works while you can optimise general functions? Or do you mean that the lambda is an argument?
15:04:37 <Philippa> you *can't* optimise general functions
15:05:06 <`ramses> huh? but that's what the optimiser does, doesn't it?
15:05:13 <Philippa> whether they're defined within a lambda or not doesn't matter
15:05:16 <`ramses> I don't mean general as in "unknown"
15:05:20 <Philippa> no: the optimiser manipulates AST data
15:05:29 <Philippa> (don't believe me? Go read GHC's source :p)
15:06:07 <Philippa> the difference is that you can write an Applicative that /optimises itself/
15:06:22 <`ramses> as in, a smart definiton for <*>?
15:06:25 <Philippa> yeah
15:06:29 <Philippa> (and for pure)
15:07:08 <`ramses> ah, and you can define that better than >>= because you have a less flexible interface then?
15:07:16 <Philippa> right
15:07:31 <`ramses> ok, I'll need to process that a bit, but thanks! :)
15:07:32 <Philippa> (and even if you have >>= as well, code that only uses <*> can optimise itself)
15:07:56 <`ramses> gotta go, but thanks for the info!
15:10:08 <johnw> oh, lexeme has been change to token, and is now in another library
15:19:59 <johnw> edwardk: um, in the GitHub trifecta, where did all the combinators go?
15:20:07 <johnw> i grepped the sources for manyTill and it's missing
15:20:14 <edwardk> most of the ones in 0.90 are outsourced to 'parsers'
15:20:19 <edwardk> parsers is shipped
15:20:30 <edwardk> but i don't have any bindings for anything other than HEAD trifecta
15:20:31 <johnw> now trifecta is just error reporting on top of parsers?
15:20:35 <edwardk> ep
15:20:36 <edwardk> er yep
15:20:39 <johnw> makes sense
15:21:00 <edwardk> that way you'll be able to write more minimal parsers for environments that need better guarantees using the same combinators
15:21:06 <monochrom> you realize that more splitting of packages means more DLL hell? :)
15:21:25 <edwardk> monochrom: hence why lens is one megapackage =P
15:21:31 <monochrom> haha ok!
15:22:00 <edwardk> also parsers is all but haskell 98. trifecta uses _everything_
15:22:16 <edwardk> so the break is good in that regard as well
15:22:28 <edwardk> (its 98 + existential types I think)
15:22:55 * cmccann is surprised trifecta hasn't been turned into some unholy lens apparatus that pulls error messages and other information out of a parser somehow
15:23:08 <elliott> cmccann: all in good time
15:23:13 <edwardk> cmccann: thats probably going to happen soon
15:23:17 <cmccann> haha
15:23:18 <edwardk> i need to use trifecta in january
15:23:25 <elliott> I hear lens exports too much unsafeCoerce for that because of that pesky elliott
15:23:32 <edwardk> only in HEAD
15:23:39 <elliott> hey we don't know that yet!!
15:24:01 <monochrom> I heard that "head is unsafe". now I know why
15:24:06 <cmccann> I figure that in a few months all of edwardk's packages will be subsumed by lens
15:24:16 <cmccann> within a year, all of hackage will also
15:24:28 <elliott> edwardk: will trifecta also use that fancy machines thing?
15:24:31 <elliott> maybe I'll understand it by then
15:24:32 <edwardk> besides elliott only added 41% of the unsafeCoerces we have in lens
15:24:37 <elliott> haha
15:24:51 <johnw> i wish ghc would just auto-add new dependencies to my cabal file...
15:24:55 <edwardk> i guess technically you touched the ones in C.L.I.Composition too
15:25:03 <johnw> i've gotta add that to haskell-mode
15:25:25 <edwardk> a parser that uses machines is likely in the near future
15:25:46 <elliott> would that be streaming?
15:25:58 <shachaf> I like how people somehow consider me their savior who removes unsafeCoerces rather than adds them.
15:26:05 <shachaf> Even though I started the whole trend.
15:26:44 <elliott> shachaf: finding unsafeCoerce in HEAD is your chance to repent
15:27:14 <blueonyx> hi, how does hint's setImports work? i use setImports ["My.Module"] and the code i interpret uses types from this module and errors "not in scope" works with an import My.Module in the interpreted code though
15:27:42 <shachaf> elliott: I've tracked a bunch of them down to Iso.hs.
15:27:44 <shachaf> Hope that helps.
15:28:40 <edwardk> elliott: yes
15:29:22 <edwardk> elliott: note: trifecta head is set up so that most combinators can work with a streaming implementation
15:29:23 <elliott> quadfecta?
15:29:26 <edwardk> i just didn't write one
15:29:46 <Shamar> hi, I'm tring to build haskell platform with ghc-7.6, but I'm getting an error in OpenGL
15:30:07 <johnw> edwardk: is there a convenient way to parse from a byte string giving a delta, and return the result and a Maybe Delta for the next parse?
15:30:30 <elliott> edwardk: cool
15:30:31 <Shamar> "Graphics/Rendering/OpenGL/GL/VertexArrays.hs:557:1: Unacceptable argument type in foreign declaration: AttribLocation"
15:31:11 <edwardk> just parse using something like:   (,) <$> yourParser <*> position   then you can read the delta out of the answer
15:31:20 <monochrom> high on the HEAD was an unsafeCoerce, layee-o-dl layee-o-dl layee-o
15:31:20 <johnw> gotcha
15:31:32 <edwardk> as for setting the starting delta that should also work. some combinator in there for parsing takes a starting delta
15:31:39 <edwardk> its usually used to pass a filename
15:31:48 <edwardk> but you can pass an actual positional delta too
15:32:16 <Shamar> being a ccall I think might be a missing library... any one know if this is a known bug?
15:33:16 <monochrom> it is ghc-7.6 being more restrictive with foreign types. more restrictive means actually following a Haskell 2010 rule
15:33:17 <johnw> that worked nicely, thanks
15:33:29 <elliott> Shamar: you're using an unsupported compiler for that haskell platform version
15:33:39 <hpaste> johnw pasted “deltas.hs” at http://hpaste.org/79593
15:33:59 <johnw> that's my lazy parser
15:34:33 <johnw> need a "result :" in there
15:35:00 <johnw> and a detection of failed parse
15:35:45 <mreh> how am I supposed to use the transformer stacks without dependent types and the type classes?
15:35:52 <Shamar> mmm... should I try with a different branch?
15:36:02 <monochrom> you should try ghc 7.4.2
15:36:13 <hpaste> johnw annotated “deltas.hs” with “deltas.hs (annotation)” at http://hpaste.org/79593#a79594
15:36:17 <Shamar> ok... sorry...
15:36:19 <Shamar> :-)
15:36:23 <Shamar> thanks
15:36:31 <monochrom> see my http://www.vex.net/~trebla/haskell/haskell-platform.xhtml
15:36:45 <johnw> i think that can't work, and that flymake is fooling me; but it's close enough
15:37:14 <binroot> Hey guys, how many functions come with haskell? (Including Prelude, Data.List, etc)
15:37:29 <mreh> :)
15:37:47 <monochrom> strange question
15:37:54 <johnw> >1
15:37:55 <elliott> binroot: lots
15:38:01 <binroot> im trying to get a number on it
15:38:10 <elliott> depends on what you mean by "Haskell"
15:38:13 <elliott> and "function" for that matter :)
15:38:26 <mreh> over 9000
15:38:28 <binroot> a function, including (.), map, (+), etc
15:38:36 <monochrom> oh yeah, "getLine" is not a function, but you certainly want to count it
15:38:38 <mreh> I asked a legitimate question :(
15:39:02 <shachaf> monochrom: According to the Report getLine is a function.
15:39:13 <monochrom> oh yikes
15:39:21 <johnw> shachaf: i bet that keeps you from sleeping at nights, doesn't it
15:39:23 <shachaf> Though I think it's just an oversight.
15:39:40 <shachaf> http://www.haskell.org/onlinereport/haskell2010/haskellch7.html#x14-1430007.1
15:39:56 <elliott> clearly this means you're forced to implement IO as a function under the hood
15:39:58 <binroot> Any idea at a rough estimate? would "OVER 9000" actually be accurate?
15:40:13 <shachaf> Display all 9954 possibilities? (y or n)
15:40:18 <elliott> you're going to have to count for yourself if you really want an answer
15:40:27 * cmccann wonders whether (+) reasonably counts as one function per Num instance
15:40:39 <shachaf> cmccann: (+) counts as one function per argument!
15:40:40 <monochrom> mreh, I don't know why you need dependent types
15:40:43 <johnw> shachaf: that looks like an Emacs error message!
15:40:44 <shachaf> (+) 0 is a different function from (+) 1
15:40:47 <johnw> er, prompt
15:40:52 <johnw> oh, bash
15:40:55 <mreh> monochrom: to derive the Monad* classes in mtl
15:41:00 <shachaf> Neither!
15:41:00 <Liskni_si> Is there any way to update ~/.cabal/share/doc/ without cabal installing a package?
15:41:03 <binroot> shachaf, i'm talking about built in functions
15:41:06 <mreh> not dependent types, fun-deps
15:41:10 <mreh> pardon
15:41:21 <johnw> I think he means "named things in the standard library"
15:41:23 <cmccann> shachaf, yes, but those are user-defined functions, not ones included :]
15:41:24 <simpson> binroot: "Built-in?" As in, they're part of the language itself, and not in the Prelude?
15:41:28 <shachaf> More like unfun-deps
15:41:31 <shachaf> -funfun-deps
15:41:36 <elliott> shachaf: at least it says "The getChar operation" after that
15:41:46 <binroot> I guess what johnw said, im talking about "named functions"
15:41:54 <binroot> both in Prelude and all the other packages
15:41:57 * hackagebot HueAPI 0.1 - API for controlling Philips Hue lights  http://hackage.haskell.org/package/HueAPI-0.1 (SjoerdVisscher)
15:41:59 <elliott> you probably really don't mean "functions"
15:42:01 <elliott> all other packages??
15:42:03 <elliott> as in everything on hackag?
15:42:06 <shachaf> elliott: Then it says "Typically, the read operation from class Read is used to convert the string to a value."
15:42:06 <elliott> hackage is huge
15:42:10 <elliott> I assumed you meant ghc or haskell platform
15:42:17 <binroot> ghc
15:42:30 <binroot> not hackage, just within the local GHC
15:42:38 <cmccann> the haskell report is not known for using only shachaf-compliant terminology.
15:42:52 <shachaf> cmccann: Hey, I'm just responding to elliott.
15:43:09 <cmccann> shachaf, yes but you're the one who complains more
15:43:13 <elliott> cmccann: it would be nice if it didn't lie
15:43:37 <shachaf> cmccann: elliott is working me in the unsafeCoerce mines.
15:43:51 <Shamar> a question about good practice in haskell: what extensions are safe to use? and using an extension like MultiParamClasses, GADT or Existential Types in a library imposes the same extensions to all consumers?
15:43:52 <elliott> cmccann: shachaf is complainint about the Report's terminology instead of finding an unsafeCoerce for me.
15:43:52 <cmccann> it would also be nice if GHC didn't occasionally refer to functions with no arguments in error messages :P
15:44:13 <shachaf> GHC has a notion of arity, though.
15:44:16 <shachaf> Which is justified.
15:44:39 <Botje> ha
15:44:58 <shachaf> It would also be nice if it didn't say "you gave too many arguments to this function: it expects 5 and you gave it 2"
15:45:09 <cmccann> hahaha
15:45:14 * cmccann can't remember what causes that
15:46:13 <shachaf> I've gotten it in lots of different contexts.
15:46:20 <shachaf> I don't mind so much -- it adds character, y'know.
15:46:23 <shachaf> cmccann: Hey, I bet you'd love to find an unsafeCoerce for elliott.
15:46:50 <shachaf> I mean, just look at this code: https://github.com/ekmett/lens/blob/master/src/Control/Lens/Iso.hs#L163
15:46:50 <monochrom> mreh: if you write code to just import "Control.Monad.Trans.State" and specifically say "StateT blahblah", you don't need fundeps multiparamtypeclass etc. Notice that Control.Monad.Trans.State.Strict/Lazy exports put get modify too
15:46:57 * hackagebot pretty-show 1.3 - Tools for working with derived Show instances.  http://hackage.haskell.org/package/pretty-show-1.3 (IavorDiatchki)
15:47:04 <cmccann> pf, I'll let other people get their hands dirty with this unsafeCoerce stuff.
15:47:44 <elliott> cmccann: I could lie and say it involves type hackery
15:47:58 <shachaf> It involves the sort of type hackery where you give up.
15:47:59 <cmccann> unfair trickery!
15:48:03 <shachaf> That's a kind of hackery, right?
15:48:17 <shachaf> cmccann: You should've seen BazaarT.
15:48:34 <cmccann> do I even want to know?
15:48:49 <shachaf> cmccann: We had an unsafeCoerce there for a long time and we had to play all sorts of module tricks to hide it from the user.
15:49:08 <shachaf> Then it turned out it was never getting called under normal circumstances.
15:49:08 <elliott> cmccann: how can you not be tempted to try and find an unsafeCoerce in https://github.com/ekmett/lens/blob/master/src/Control/Lens/Iso.hs#L163
15:49:18 <shachaf> So we could just replace it with undefined
15:49:22 <shachaf> And everything kept working.
15:49:40 <cmccann> shachaf, sounds perfectly safe to me
15:50:05 <elliott> type AnIso s t a b = Cokleisli (IsoChoice IsoG ()) a (IsoChoice IsoF a b) -> Cokleisli (IsoChoice IsoG ()) s (IsoChoice IsoF a t)
15:50:09 <elliott> the most beautiful type I have ever written
15:52:09 <cmccann> elliott that's read as "a nice-o stab" right?
15:52:19 <elliott> yes
15:52:21 <cmccann> ok
15:52:25 <elliott> you can pass it to functions that are getting a stab too
15:52:32 <cmccann> I should hope so
15:52:33 <elliott> actually that's a lie you'd have to use cloneIso
15:52:56 <cmccann> as long as something gets stabbed it's all good.
15:52:59 <simpson> I just don't get all these fancy parts of lens.
15:53:24 <simpson> I mean, I understand the whole getter/setter thing, and the composability thing, but I don't get this whole iso/indexed/bazaar/traversal stuff.
15:53:32 <shachaf> simpson: We made these types so complicated that we can't even figure them out anymore.
15:53:41 <shachaf> So elliott just stuck unsafeCoerce everywhere.
15:53:49 <shachaf> Now I'm supposed to try to break it.
15:53:51 <elliott> simpson: bazaar is an implementation detail you don't have to care about
15:53:51 <shachaf> (That's a lie.)
15:53:55 <elliott> traversals are just multi-lenses
15:54:01 <elliott> _1 f (a,b) = (,b) <$> f a
15:54:05 <elliott> _2 f (a,b) = (a,) <$> f b
15:54:10 <elliott> both f (a,b) = (,) <$> f a <*> f b
15:54:17 <simpson> shachaf: At this point, I'm relatively certain that you understand all of it and just say things like this to hide your power level. :3
15:54:24 <elliott> so you can use "traverse" as a traversal for any Traversable
15:54:28 <elliott> so you can traverse over lists etc.
15:54:32 <shachaf> > over _1 (+1) (1,2)
15:54:34 <lambdabot>   (2,2)
15:54:36 <elliott> > (1,2) & both %~ (+1)
15:54:38 <lambdabot>   (2,3)
15:54:38 <shachaf> > over _2 (+1) (1,2)
15:54:40 <lambdabot>   (1,3)
15:54:45 <elliott> > [1,2,3,4] & traverse %~ (+)
15:54:46 <elliott> er
15:54:46 <shachaf> > over both (+1) (1,2)
15:54:46 <lambdabot>   No instance for (GHC.Show.Show (t0 -> t0))
15:54:47 <lambdabot>    arising from a use of `M56705...
15:54:47 <elliott> > [1,2,3,4] & traverse %~ (+1)
15:54:48 <lambdabot>   (2,3)
15:54:49 <lambdabot>   can't find file: L.hs
15:54:52 <elliott> shachaf. :(
15:54:55 <elliott> you ruined my demonstration
15:54:56 <elliott> > [1,2,3,4] & traverse %~ (+1)
15:54:58 <lambdabot>   [2,3,4,5]
15:54:59 <elliott> :P
15:55:14 <elliott> thankfully simpson can just read every other line
15:55:18 <shachaf> > toListOf (traverse._1) [(1,2),(3,4),(5,6),(7,8)]
15:55:22 <lambdabot>   [1,3,5,7]
15:55:48 <elliott> simpson: the indexed stuff is just when you have a traversal or whatever with an index. as in the index of an element in a list, or the key of an element in a map
15:56:18 <elliott> > iover (\i a -> "at index: " ++ show i ++ " there's: " ++ show a) traversed [1,2,3,4]
15:56:19 <lambdabot>   The lambda expression `\ i a
15:56:19 <lambdabot>                           -> "at index: "
15:56:19 <lambdabot>     ...
15:56:23 <elliott> oops
15:56:29 <elliott> > iover traversed (\i a -> "at index: " ++ show i ++ " there's: " ++ show a) [1,2,3,4]
15:56:31 <lambdabot>   ["at index: 0 there's: 1","at index: 1 there's: 2","at index: 2 there's: 3"...
15:56:37 <elliott> > iover traversed (\i a -> "at index: " ++ show i ++ " there's: " ++ show a) ['a','b','c']
15:56:39 <lambdabot>   ["at index: 0 there's: 'a'","at index: 1 there's: 'b'","at index: 2 there's...
15:56:57 <elliott> > iover traversed (\i a -> "at index: " ++ show i ++ " there's: " ++ show a) $ M.fromList [('a',1), ('b',2)]
15:56:58 <lambdabot>   fromList [('a',"at index: 0 there's: 1"),('b',"at index: 1 there's: 2")]
15:57:25 <elliott> shachaf: what's the indexed traversal for maps in lambdabot's lens?
15:57:37 <shachaf> itraversed?
15:57:47 <elliott> > iover itraversed (\i a -> "at index: " ++ show i ++ " there's: " ++ show a) $ M.fromList [('a',1), ('b',2)]
15:57:48 <lambdabot>   fromList [('a',"at index: 'a' there's: 1"),('b',"at index: 'b' there's: 2")]
15:57:50 <elliott> right
15:57:55 <shachaf> The 0 bone's connected to the: 1 bone
15:57:59 <elliott> simpson: hopefully that helps at least a little
15:58:27 <simpson> elliott: Maybe it's the Django and JS I've been writing all day, but this just makes me want to hit my head against the wall even harder. :3
15:58:44 <simpson> I'll come back to this later. I've gotta finish writing my FFI stuff for Fluidsynth first.
15:59:27 <shachaf> Hey, this is nice.
15:59:29 <shachaf> lens = twan $ \f s -> mk <$> f s
15:59:29 <shachaf> iso = unalgebraic $ \f s -> mk <$> f (un <$> s)
15:59:43 <shachaf> I guess I should've noticed the pattern before.
16:00:08 <blueonyx> of course
16:00:10 <blueonyx> ;)
16:00:23 <elliott> shachaf: wait, what's mk there
16:00:36 <shachaf> ??? = cotwan $ \f s -> f (un <$> s)
16:00:53 <shachaf> Er.
16:00:59 <shachaf> I'm wrong about the lens part.
16:01:11 <shachaf> lens = twan $ \f s -> mk <$> f (un s)
16:01:18 <shachaf> Or something like that.
16:01:38 <shachaf> By adding in a functor you get access to the un part too.
16:01:57 * hackagebot Twofish 0.3.1 - An implementation of the Twofish Symmetric-key cipher.  http://hackage.haskell.org/package/Twofish-0.3.1 (RonLeisti)
16:02:01 <shachaf> boring = conal $ \f s -> mk (f (un s))
16:02:08 <shachaf> That's just a setter.
16:02:25 <elliott> shachaf: um, is this the lens in current lens?
16:02:31 <shachaf> No.
16:02:34 <shachaf> That's an actual lens.
16:02:35 <shachaf> Sorry.
16:02:38 <elliott> oh, I see what you mean
16:02:41 <elliott> this is parameterised on mk and un
16:02:44 <shachaf> Right.
16:02:50 <elliott> what's cotwan?
16:02:54 <shachaf> I don't know!
16:02:59 <shachaf> It's a (g a -> b) -> g s -> t thing.
16:03:12 <shachaf> And I was wrong.
16:03:14 <elliott> oh, you mean the "colens" from pr.hs?
16:03:19 <shachaf> ??? = cotwan $ \f s -> mk (f (un <$> s)) ?
16:03:28 <shachaf> Right, something like that.
16:03:40 <shachaf> I don't think that line makes sense, though.
16:03:49 <krakrjak> \q
16:04:24 <shachaf> OK, this mk (f (un <$> s)) thing doesn't make sense.
16:04:54 <acowley> Why isn't Show defined for Identity?
16:05:10 <shachaf> Who knows. :-(
16:05:16 <johnw> huh, good question
16:05:38 <shachaf> It's annoying.
16:05:44 <acowley> I think I ran into that recently. So this makes twice in a month or two.
16:06:00 <shachaf> I've run into it a lot more than that recently.
16:06:15 <shachaf> Probably because I've been working on symmetric lens code. :-)
16:06:29 <shachaf> (Identity a -> Identity b) -> Identity s -> Identity t
16:06:53 <shachaf> elliott: over = sets = unsafeCoerce??
16:07:01 <acowley> I hate things that get between me and my precious printfs
16:07:18 <elliott> shachaf: good idea
16:12:13 <shachaf> Oh, I get it.
16:12:23 <shachaf> In somelens = twan $ \f s -> mk <$> f (un s), mk has s in scope.
16:12:28 <shachaf> In someiso = unalgebraic $ \f s -> mk <$> f (un <$> s) it doesn't
16:12:45 <elliott> It doesn't?
16:12:53 <shachaf> Not the contents of s
16:12:55 <elliott> (You should use edwardk naming for your variables)
16:12:59 <elliott> That should be gs or whatever.
16:13:15 <shachaf> _1 = twan $ \f (x,y) -> (,y) <$> f x
16:13:25 <shachaf> Here (,y) has access to y
16:13:37 <shachaf> But if you add another fmap, then s is just an opaque functor.
16:13:40 <shachaf> (Except for un)
16:13:51 <shachaf> So you have to do (s -> a, b -> t) instead of (s -> (a, b -> t))
16:14:57 <shachaf> elliott: I don't like edwardk naming. :-(
16:15:04 <shachaf> Also it means I have to do type inference in my head.
16:15:24 <elliott> not if you write the type signature first
16:15:40 <shachaf> But this way I don't have to write it at all.
16:16:31 <elliott> so you don't know what it does!
16:16:34 <cmccann> just do unsafeCoerce in your head to infer the type you want it to be
16:16:37 <cmccann> problem solved!
16:16:55 <shachaf> cmccann: Doing a few too many unsafeCoerces in his head is how edwardk got to be the way he is.
16:17:02 <shachaf> I'm trying to avoid that fate.
16:17:25 <cmccann> I think it's an inevitable fate for his minions, sorry.
16:18:20 <Jafet> Better than unsafeTetraplegia
16:18:45 <shachaf> Nereid: Why does Profunctor have Upstar and Downstar but not Bothstar?
16:18:54 <Nereid> who knows!
16:19:28 <elliott> cmccann: hey, I did the unsafeCoerces /after/ writing the safe implementation!
16:19:38 <shachaf> edwardk hadn't opened his mind to the beauty of symmetric lenses.
16:19:42 <elliott> cmccann: I am contractually prohibited from making fun of edwardk's unsafeCoerces, so mmf fmm mmf mmf mmmf
16:19:48 <cmccann> haha
16:19:54 <Nereid> shachaf: I like the twanvlens-compatibility though
16:19:58 <shachaf> Dialgebroids are the future, man.
16:20:04 <shachaf> Nereid: Yes, it's nice.
16:20:04 <elliott> shachaf: we should define Star and use it I think
16:20:12 <elliott> oh then we couldn't make a (->) instance
16:20:13 <elliott> yuk
16:20:22 <acowley> What's the relationship between Downstar and Algebra?
16:20:32 <cmccann> elliott, but does anyone actually use (->) anyway?
16:20:35 <shachaf> acowley: Algebroid
16:20:37 <shachaf> They're the same thing.
16:20:39 <cmccann> it's so mundane
16:20:40 <shachaf> In this case.
16:20:42 <elliott> cmccann: people who haven't opened their minds to the beauty of symmetric lenses
16:20:44 <shachaf> Well, the type is the same.
16:21:02 * cmccann isn't even sure what a symmetric lens is
16:21:08 <elliott> (g a -> f b) -> g s -> f t
16:21:10 <shachaf> Nereid: I have a version off to the side that's compatible with Setters.
16:21:14 <cmccann> I really should figure out what all this lens crap is about one of these days
16:21:14 <elliott> it's symmetric because you have a functor on both sides
16:21:23 <Nereid> shachaf: of symmetric lenses?
16:21:31 <elliott> cmccann: you can watch edwardk's talk once he posts it publicly
16:21:34 <elliott> (did that happen yet?)
16:21:37 <elliott> it's in the -lens topic anyway
16:21:39 <shachaf> Nereid: Yep.
16:21:40 <shachaf> *Main> toListOf both (5,10)
16:21:40 <shachaf> [5,10]
16:21:40 <shachaf> *Main> both (+1) (5,10)
16:21:40 <shachaf> (6,11)
16:21:46 <elliott> maybe I'm not allowed to say that
16:21:50 <shachaf> So it's just k a b -> k s t
16:21:50 <acowley> So why don't we use the Algebroid and Coalgebroid terminology?
16:21:59 <cmccann> pf, videos
16:22:02 <shachaf> acowley: And Dialgebroid!
16:22:10 <shachaf> acowley: I called the type class Algebraic. That counts, right?
16:22:11 <elliott> cmccann: it has the real live edwardk!
16:22:12 <acowley> shachaf: If you insist :)
16:22:30 <cmccann> elliott, as opposed to one of his robot stunt doubles?
16:22:32 <acowley> How many times does he unsafeCoerce in his talk? Are they bleeped?
16:22:36 <elliott> n.b. may not be real of live
16:22:44 <Nereid> shachaf: :t both
16:22:54 <shachaf> *Main> :t both
16:22:54 <shachaf> both :: (Applicative f, Dialy Identity f k) => k a b -> k (a, a) (b, b)
16:22:54 <elliott> acowley: when edwardk unsafeCoerces, he unsafeCoerces the audience to not even know it happened
16:23:13 <elliott> unsafeCoerce :: AudienceGraduallyBeginningToExpectUnsafeCoercions -> BlissfullyUnawareAudience
16:23:45 <Nereid> shachaf: I see.
16:23:55 <shachaf> Nereid: "pretty cool huh"
16:23:58 <shachaf> conal would like it.
16:24:01 <Nereid> shachaf: but that doesn't work with lenses!
16:24:09 <shachaf> Nereid: But it works with SECs!
16:24:24 <Nereid> but SECs are (comparatively) boring!
16:24:32 <shachaf> Nereid: Lenses are comparatively boring!
16:24:39 <shachaf> Compared to symmetric lenses.
16:24:39 <Nereid> or something
16:25:08 <elliott> edwardk: so you give an instance for Foo f a b = a -> f b, right?
16:25:20 <elliott> err
16:25:21 <elliott> shachaf:
16:25:45 <shachaf> elliott: It's symmetric.
16:25:52 <shachaf> newtype Dial g f a b = Dial { runDial :: g a -> f b }
16:25:59 <shachaf> instance Dialy Identity Identity (->) where
16:26:07 <shachaf> (class Dialy g f k | k -> g f where)
16:26:15 <acowley> Dialy?!?!?
16:26:30 <shachaf> redial :: ...
16:26:35 <shachaf> (I don't actually have something called redial.)
16:27:09 <elliott> disclaimer: this isn't actually in lens proper
16:27:16 <acowley> These names are insane :(
16:27:18 <shachaf> But it should be!
16:27:30 <shachaf> acowley: That name is in a file I have.
16:27:31 <shachaf> It's not in lens.
16:27:58 <shachaf> But just imagine:
16:28:08 <acowley> I don't want to :((((
16:28:15 <Nereid> haha
16:28:24 <cmccann> introducing shachaf's new dial-a-stab service
16:28:26 <shachaf> *Main> (both.map) toUpper ("hello","there")
16:28:26 <shachaf> ("HELLO","THERE")
16:29:32 <acowley> > (both.map) toUpper ("Hello.", "Yes, this is stab.")
16:29:34 <lambdabot>   [('H','Y'),('H','E'),('H','S'),('H',','),('H',' '),('H','T'),('H','H'),('H'...
16:29:52 <shachaf> See?
16:29:54 <Nereid> haha
16:29:59 <shachaf> What you get with lens don't even make sense.
16:30:10 <Nereid> > over (both.map) toUpper ("Hello.", "Yes, this is stab.")
16:30:12 <lambdabot>   Couldn't match expected type `Control.Lens.Internal.Mutator b0'
16:30:12 <lambdabot>            ...
16:30:19 <Nereid> > over (both.mapped) toUpper ("Hello.", "Yes, this is stab.")
16:30:22 <lambdabot>   ("HELLO.","YES, THIS IS STAB.")
16:30:29 <shachaf> > over (both.sets map) toUpper ("Hello.", "Yes, this is stab.")
16:30:29 <Nereid> :t both.map
16:30:31 <lambdabot> (a -> b) -> ([a], [a]) -> [(b, b)]
16:30:32 <lambdabot>   ("HELLO.","YES, THIS IS STAB.")
16:30:41 <shachaf> sets :: Conal -> Twan
16:30:51 <shachaf> over :: Twan -> Conal
16:30:54 <Nereid> sure
16:32:27 <parcs> does ghc perform any alignment of unpacked fields?
16:32:40 <shachaf> Nereid: The best part is that over = sets = unsafeCoerce!
16:32:58 <shachaf> Have twanvl and conal ever been seen in the same room?
16:33:08 <Nereid> they are right now!
16:33:20 * twanvl waves
16:33:33 <elliott> twanvl will go down in history as that guy who forgot a functor
16:33:40 <cmccann> heh
16:33:47 <shachaf> twanvl: how could you :'(
16:33:51 <Nereid> elliott: but what about Data.Traverse
16:34:10 <shachaf> imo all haskell functions should be replaced with dialgebroids
16:34:29 <acowley> shachaf: It's what the people want!
16:34:33 <cmccann> shachaf, elliott would probably replace them all with unsafeCoerce instead.
16:34:41 <shachaf> cmccann: Why not both?
16:34:44 <Nereid> actually, I suppose it's only traverse that we'd loes compatibility with by going for symmetric lenses
16:34:46 <cmccann> good point!
16:35:08 <shachaf> Nereid: Well, there's also the whole "defining your own lenses" thing.
16:35:16 <Nereid> ah right
16:35:18 <shachaf> _1 f (x,y) = (,y) <$> f x
16:35:26 <shachaf> You need an extra combinator.
16:35:31 <elliott> Nereid: Data.Traverse should use symmetric lenses!!
16:35:37 <shachaf> _1 = twan $ \f (x,y) -> (,y) <$> f x
16:35:38 <Nereid> or write {run,}Identity everywhere
16:35:46 <shachaf> Right.
16:35:50 <rwbarton> an extra combinator named "unsafeCoerce"
16:36:10 <shachaf> Can you believe Identity isn't in base yet?
16:36:29 <rwbarton> what is it in, transformers?
16:36:31 <Nereid> it isn't?
16:36:32 <shachaf> Yep.
16:36:36 <Nereid> ah
16:36:42 <Nereid> close enough to base.
16:37:13 <acowley> shachaf: That would hopefully make it easier to get the missing instances added
16:38:03 <shachaf> elliott: Hey, we should tag *every lens* with twan $ ... or whatever it is.
16:38:14 <shachaf> That way switching Control.Lens to another representation would be trivial!
16:38:53 <shachaf> Also, I like how those two lines lined up. Should I try to keep doing that?
16:39:04 <elliott> shachaf: good idea! let's not do it
16:40:02 <johnw> they didn't line up with proportional fonts
16:40:48 <shachaf> johnw: Well, fix your fonts.
16:40:59 <shachaf> elliott: I think it would be kind of nice. Everything could be representation-independent.
16:41:10 <shachaf> elliott: It would give us a good excuse to move things to the right side of the =
16:41:14 <elliott> shachaf: you'd need to use (%%~) everywhere you consume a lens too
16:41:17 <elliott> it's not worth it
16:41:24 <shachaf> It would all just get inlined away.
16:41:34 <shachaf> elliott: I think maybe it is worth it!
16:41:42 <shachaf> Using traverseOf when you traverse with a lens seems sensible to me.
16:42:04 <Nereid> :t (%%~)
16:42:06 <lambdabot> LensLike f s t a b -> (a -> f b) -> s -> f t
16:42:09 <Nereid> ah.
16:42:42 <shachaf> That way we could even experiment with the newtype representation.
16:43:48 <elliott> shachaf: ok go get edwardk's approval
16:48:15 <parcs> > 0x2000
16:48:17 <lambdabot>   8192
17:02:14 <lispy> > 0x8192
17:02:16 <lambdabot>   33170
17:02:22 <lispy> > 0x33170
17:02:24 <lambdabot>   209264
17:02:28 <parcs> > 0x4000
17:02:29 <lambdabot>   16384
17:03:20 <lispy> > iterate (\x -> read ("0x" ++ show x)) (10::Int)
17:03:22 <lambdabot>   [10,16,22,34,52,82,130,304,772,1906,6406,25606,153094,1388692,20481682,5415...
17:03:46 <lispy> > iterate (\x -> read ("0" ++ show x)) (10::Int)
17:03:48 <lambdabot>   [10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10...
17:04:33 <r2jitu> > let foo = 1 : map succ foo
17:04:35 <lambdabot>   not an expression: `let foo = 1 : map succ foo'
17:04:49 <r2jitu> > let foo = 1 : map succ foo in foo
17:04:50 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
17:05:17 <r2jitu> lol, this lambdabot is awesome
17:12:43 <jackss> why can local function capture variables defined with let, but not variables assigned by <- ?
17:13:46 <c_wraith> jackss: that's an odd assertion.
17:13:49 <monochrom> what local function? what actual code?
17:13:56 <jackss> I will paste
17:14:30 <acowley> Oh dangit, I need poly kinds everywhere
17:14:37 <acowley> this is maddening
17:18:37 <mm_freak_> is there a flipped const monad defined somewhere?
17:18:40 <jackss> why can't func access x and y?  http://hpaste.org/79598
17:18:46 <mm_freak_> such that Const a b is isomorphic to b
17:18:54 <mm_freak_> such that Const a = Id
17:19:16 <mm_freak_> ideally as a transformer ConstT a m b
17:19:34 <monochrom> the computer sees test=do{blahblah} where func = x++y
17:19:37 <mm_freak_> jackss: because they are out of scope
17:20:02 <elliott> mm_freak_: um, what would you use ConstT for?
17:20:18 <mm_freak_> jackss: use a let binding within the do-block or pass x and y as arguments
17:20:20 <monochrom> "where func" belongs to test, not the do-block
17:20:22 <jackss> shame it doesn't work. the alternatives are less readable (passing all the arguments, defining function in the middle of the code)
17:20:39 <mm_freak_> elliott: we talked about it not long ago…  i'd like to use a Reader based on reflection =)
17:21:14 <elliott> ah
17:21:26 <elliott> I don't think it's anywhere standard
17:21:29 <mm_freak_> jackss: the scoping makes sense, because you could just as well refer to 'func' outside of the do block
17:22:21 <mm_freak_> jackss: for the sake of readability, if func is going to be something nontrivial it also makes a lot of sense to pass x and y as arguments
17:22:57 <rwbarton> or inside the do block but before x and y are bound
17:23:50 <monochrom> use do-rec to define func inside the do block, before x and y are bound, and still not needing parameters! :)
17:24:17 <mm_freak_> monochrom: doesn't work for many monads (for which i would love it to work)
17:24:18 <jackss> mm_freak_ i am capturing like 5 variables and after the call to the function I am cleaning things up
17:24:22 <monochrom> hehe
17:24:43 <mm_freak_> jackss: then make use of the fact that haskell is higher order and actions are first class
17:24:49 <monochrom> inline func at the call site
17:25:09 <mm_freak_> jackss: withSomeStuff $ \x y -> …
17:25:43 <mm_freak_> jackss: or see how 'bracket' works
17:25:48 <mm_freak_> (Control.Exception)
17:29:19 <tcrayford> hey, does haskell have a streaming data library? Something like http://blog.nodejs.org/2012/12/21/streams2/
17:30:06 <johnw> is mike-burns here?
17:30:15 <jackss> mm_freak yeah I should probably refacture things. I am doing dirty thougs though (system ffi stuf), and just wanted to get it done with so I can concentrate on higher level abstractions
17:30:32 <jackss> refactore*
17:30:36 <mm_freak_> tcrayford: lots
17:30:59 <mm_freak_> tcrayford: most people are going towards conduit and pipes today, but there is also the enumerator library that implements the iteratee pattern
17:31:41 <mm_freak_> and of course the iteratee library itself, although i prefer enumerator
17:31:52 <tcrayford> mm_freak: hmmm. So would you reccomend enumerator?
17:32:13 <mm_freak_> no, i prefer enumerator over iteratees
17:32:22 <mm_freak_> in terms of simplicity i'd recommend pipes
17:32:49 <tcrayford> huh. Does it have support for stuff like tcp streaming, file streaming, and parsing and stuff like that?
17:33:05 <mm_freak_> jackss: combinators are the way to go…  they are pretty low level in a language like haskell
17:33:19 <mm_freak_> jackss: check out 'bracket' and as an example check out 'withFile'
17:33:30 <mm_freak_> tcrayford: all of them can do that
17:33:42 <cmccann> tcrayford, those are pretty trivial
17:33:50 <tcrayford> mm_freak_ oh, sweet, thanks.
17:34:01 <cmccann> stuff like that tends to be used as the simple "here's how to do things" examples in most streaming libraries
17:34:05 <mm_freak_> tcrayford: these features aren't even builtin…  they are "plugins" so to speak
17:34:38 <tcrayford> so I'd have to write them?
17:34:49 <mm_freak_> no, there are ready-made libraries
17:34:50 <tcrayford> or are there libraries I can just drop into my application?
17:34:55 <mm_freak_> yeah
17:34:55 <cmccann> if parsing is a builtin feature of your streaming library that would be kind of worrying
17:34:55 <tcrayford> oh awesome
17:35:14 <mm_freak_> yeah, if parsing is builtin, it's an indication that the library isn't well designed
17:35:50 <cmccann> mm_freak_, or rather that both libraries aren't well designed, as well as being improperly combined as one "library" :P
17:36:19 <mm_freak_> cmccann: "both"?
17:36:31 <cmccann> mm_freak_, the streams and the parser
17:36:49 <mm_freak_> ah, i misread =)
17:37:56 <madjestic> hey guys, which IDE/editor allows to jump to a definition of a function, defined in an imported module?
17:38:02 <mm_freak_> newtype Parser a = Parser (EitherT SomeException (RWST SocketConfig () String IO) a)
17:38:03 <elliott> cmccann: did your linear logic stuff ever get any further?
17:38:05 <mm_freak_> =)
17:38:10 <elliott> madjestic: probably leksah
17:38:26 <cmccann> elliott, haven't really spent much time on it lately... still in the back of my head though
17:38:32 <mm_freak_> madjestic: emacs with haskell-mode can do that
17:38:41 <tcrayford> madjestic: vim and emacs and most text editors can do that if you use ctags (ghci has a thing that can spit out TAGS files)
17:38:49 * cmccann should probably write a blog post about linear logic or something, but that would require creating a blog first
17:38:54 <mm_freak_> tcrayford: you don't need ctags with emacs
17:39:23 <tcrayford> mm_freak_: right, was guessing there ;). Technically you don't need it with ghc-mod and vim these days
17:39:43 <ivanm> mm_freak_: how do you do it without ctags?
17:39:49 <ivanm> imenu only works in the same file IIUC
17:39:56 <mm_freak_> cmccann: i have the same problem…  i have no blog, and all the common blogging solutions are in PHP, as well as i don't have enough time to write my own blogging software =)
17:40:05 <mm_freak_> ivanm: inferior-haskell
17:40:09 <cmccann> elliott, I was toying with some ideas about how the same design could be expressed as a recursive data type in a language with algebraic data types that used linear logic connectives
17:40:33 <ivanm> mm_freak_: I've never seen how to jump to a different file even when I used inferior-haskell (I'm using chrisdone's stuff now)
17:40:33 <tcrayford> mm_freak_/cmccann: I'm actually writing blogging hosting software in haskell *right* now, weirdly
17:40:49 <hpc> my "blog" is haskell, but embarassingly primitive
17:40:53 <cmccann> elliott, but that went down a few too many rabbit holes and I never came back up before something else got in the way
17:40:55 <mm_freak_> tcrayford: what framework/library?
17:41:10 <elliott> cmccann: heh
17:41:11 <tcrayford> mm_freak_: snap, with some of my own stuff over the top of it
17:41:59 <mm_freak_> ivanm: oh, it doesn't actually jump to the definition…  it just tells you where it is…  weird
17:42:12 <mm_freak_> i've never used it myself
17:42:14 <ivanm> about to say... :)
17:42:30 <mm_freak_> should put a feature request =)
17:42:40 <cmccann> elliott, I think it was around the point where I started giving serious consideration to the idea of implementing a toy Haskell-style language with linear types that I realized I'd lost control of things
17:42:48 <madjestic> I keep getting ctags errors with vim, I guess I need to fix that first
17:42:49 <cmccann> and set it aside until I had more time
17:42:59 <elliott> cmccann: I'd use that language!
17:43:22 <mm_freak_> tcrayford: i'd like to write a proof-of-concept coroutine-based web framework on top of snap…  i like snap, but not 100% happy with it
17:43:24 <cmccann> elliott, but would you help me invent and/or implement it, that's the more important question
17:43:38 <madjestic> elliott, mm_freak_, tcrayford thanks
17:44:45 <tcrayford> mm_freak_: heh. My stuff is much simpler than that ;). Most of it is based around a typeclass so you can take arguments to your handler that get "injected" out of the http request, rather than having to grab stuff out of the snap monad directly
17:45:30 <ivanm> mm_freak_: I think inferior-haskell just passes ":info" to ghci and gets the results back
17:45:57 <elliott> cmccann: implementing sounds hard
17:46:02 <elliott> cmccann: can I use unsafeCoerce if the types are too confusing
17:46:06 <mm_freak_> tcrayford: well, having seen racket's web framework i want that in haskell, too…  then i'd be happy to write web apps =)
17:46:07 <cmccann> ivanm, obviously it should use lambdabot's info command instead
17:46:19 <mm_freak_> not saying that snap is bad, but it's too stateless
17:46:23 <cmccann> elliott, no
17:46:40 <cmccann> >:[
17:46:43 <mm_freak_> tcrayford: in fact the proof of concept code exists…  i've just written it yesterday to demonstrate the concept
17:47:08 <tcrayford> mmm_freak_: that's coroutines/continuatins right? That stuff is weird to me. I can see it being hella convenient, but I'd be wary of actually running it in production.
17:47:20 <mm_freak_> why?
17:47:31 <shachaf> Are you wary of threads too? :-)
17:47:39 <elliott> cmccann: hmph. I prefer working on edwardk's code
17:47:44 <elliott> he lets me push unsafeCoerce
17:47:59 <tcrayford> keeping session state in memory on the server is kinda funky when your servers die every month or two (AWS)
17:48:42 <tcrayford> I guess you could persist the sessions using something like Static from distributed-process and a out of process database
17:49:07 <mm_freak_> tcrayford: that's exactly what i'm considering
17:49:35 <tcrayford> mm_freak: haha, good thinking then
17:49:35 <mm_freak_> i just have to find a way to make this convenient
17:49:49 <tcrayford> yeah. I wish ghc actually implemented Static as a language extension
17:50:26 <mm_freak_> that would make things much easier, yes, but i guess i'll end up with a category and some custom combinators
17:50:39 <cmccann> elliott, well if I ever need someone to coerce some types with reckless abandon I'll be sure to ask you
17:51:30 <tcrayford> mm_freak: I'm also probably too used to more traditional style webapps, or stuff where most of the state like things are done on the client side in js (sadly)
17:52:21 <elliott> cmccann: more importantly I don't know anything about linear logic really
17:52:52 <tcrayford> mm_freak: you should post your proof of concept on hpaste or something
17:53:16 <cmccann> elliott, see that's why I need to write a blog post or something
17:59:54 <mm_freak_> tcrayford: just a sec
18:03:46 <et09> how do i remove a package with cabal?
18:03:51 <et09> is it even possible
18:03:59 <johnw> ghc-pkg unregister
18:04:11 <johnw> but that won't remove all the files, it just tells ghc isn't not available anymore
18:04:17 <et09> oh
18:04:22 <et09> how do i remove all the files
18:04:24 <johnw> there is a utility called cabal-delete which actually deletes stuff
18:04:58 <et09> where do i get that?
18:05:00 <et09> ugh
18:05:12 <johnw> @google cabal-delete
18:05:13 <lambdabot> https://github.com/iquiw/cabal-delete
18:05:24 <hpaste> “Ertugrul Söylemez” pasted “Continuation-based user interaction (again)” at http://hpaste.org/79601
18:05:53 <hpaste> “Ertugrul Söylemez” annotated “Continuation-based user interaction (again)” with “Example interaction” at http://hpaste.org/79601#a79602
18:06:05 <mm_freak_> tcrayford: see the paste…  there is an example interaction annotated
18:06:43 <tcrayford> thanks
18:06:46 <mm_freak_> tcrayford: in the code see the 'main' action
18:06:50 <mm_freak_> that's what the code looks like
18:07:09 <mm_freak_> imagine that it's not a console application, but a web application, and "request" actually presents a form to the user
18:08:17 <mm_freak_> do (user, pass) <- form (liftA2 (,) (textField "Username") (passwordField "Password")); …
18:08:28 <tcrayford> mm_freak_: yeah, makes sense. I assume you've seen https://gist.github.com/260052 ?
18:09:47 <mm_freak_> tcrayford: haven't seen it, no
18:10:04 <mm_freak_> but yeah, it seems to do something similar
18:10:09 <tcrayford> it's old, but very similar
18:10:52 <mm_freak_> tcrayford: the advantage of my method is that you can actually have a generic "App" monad that isn't specific to web stuff or anything
18:11:09 <tcrayford> mm_freak_: hah, so you could just swap stuff out to be a console app
18:11:15 <mm_freak_> exactly
18:11:30 <mm_freak_> one code, many interfaces =)
18:11:33 <mm_freak_> including web =)
18:11:35 <jackss> is it possible to cast unsigned integer type to signed? or a pointer to signed integer?  I am doing FFI and can't get my code to compile
18:12:16 <jackss> castPtrToUINT was the only thing I found, but I need signed integer
18:12:27 <mm_freak_> jackss: the former is easy:  fromIntegral
18:12:28 <liyang> jackss: castPtr perhaps?
18:12:45 <mm_freak_> jackss: the latter is a bad idea
18:12:47 <jackss> I think castPtr just casts between different pointer types
18:13:06 <johnw> yes
18:13:19 <liyang> Why would you want to treat a Ptr as a number?
18:14:00 <johnw> jackss: you can always use unsafeCoerce, just ask edwardk
18:14:13 <liyang> (unsafeCoerce will always do what you want, provided what you want is to have your code compile.)
18:14:22 <johnw> compile yes, run maybe
18:14:25 <jackss> ah nice, sounds like exactly what I need
18:14:36 <johnw> for Ptr -> Int, I doubt that's what you want
18:14:40 <johnw> you probably want Ptr -> CUint
18:14:43 <johnw> CUInt
18:15:01 <jackss> nope function accepts signed int. (Long)
18:15:08 <johnw> then CInt or CLong
18:15:09 <jackss> C long
18:15:16 <johnw> but an Int a Haskell boxed integer
18:15:18 <jackss> yes CLong
18:15:21 <liyang> jackss: sorry, I was trolling. You really do not want unsafeCoerce.
18:15:39 <jackss> what do I want then?  for Ptr -> Clong
18:16:27 <liyang> jackss: that doesn't make sense. Could you provide more details of what you're trying to accomplish?
18:16:28 <Ralith> jackss: you shouldn't be doing that.
18:16:28 <johnw> why wouldn't unsafeCoerce work for that, liyang?
18:16:45 <johnw> Ptr a -> CLong should mean to just interpret those bytes as a long
18:17:19 <elliott> johnw: and you know the compiler's representation of Ptr?
18:17:20 <elliott> how?
18:17:29 <johnw> oh, how about ptrToIntPtr?
18:18:02 <johnw> elliott: I thought Ptr was a raw pointer
18:18:05 <elliott> yes, that's probably what jackss wants
18:18:12 <johnw> isn't that how I'm able to pass them directly to C functions?
18:18:23 <Saizan> @src Ptr
18:18:23 <lambdabot> data Ptr a = Ptr Addr#
18:18:29 <johnw> ah, n/m then
18:18:44 <johnw> jackss: ptrToIntPtr :)
18:18:57 <elliott> johnw: the FFI handles conversion like that for you
18:19:08 <johnw> elliott: i guess so, thanks for the clarification
18:19:12 <elliott> I am pretty sure Ptr representation is compiler-specific
18:19:20 <elliott> I think unsafeCoercing Ptr to Int *might* work on GHC
18:19:25 <elliott> but you definitely shouldn't rely on it :)
18:19:28 <johnw> it feels... unsafe
18:19:49 <jackss> ptrToIntPtr should work, let me try
18:20:06 <johnw> and then fromIntegral on the result to -> CLong
18:20:29 <jackss> elliott wouldn't the result of using unsafeCoerce like that be the same as doing (long)pointer in C?
18:21:05 <johnw> jackss: not necessarily
18:21:06 <Twisol> the question is whether 'pointer' is actually represented the way you expect it to. Apparently that isn't guaranteed.
18:21:13 <johnw> jackss: as Saizan pointed out, Ptr is a boxed type
18:21:43 <elliott> jackss: you should really just forget anyone said unsafeCoerce :P
18:21:52 <elliott> if it's the right thing to do you'll know it
18:21:59 <johnw> and /ignore edwardk and shachaf from time to time
18:22:03 <elliott> unless you're doing *really* out there FFI stuff or type hackery
18:22:15 <elliott> (or extreme performance stuff)
18:22:18 <elliott> johnw: hey, shachaf has been bugging me about the last unsafeCoerce I put in lens!
18:22:20 <johnw> unsafeCoerce is usually for optimizations when you absolutely know what's going on
18:24:27 <Ralith> jackss: you still haven't explained why you're doing this nonsensical thing.
18:24:52 <johnw> i'm guessing somebody returned a number as a void*
18:27:00 * hackagebot alpha 1.0.14 - A compiler for the Alpha language  http://hackage.haskell.org/package/alpha-1.0.14 (MarcCoiffier)
18:28:16 <jackss> Ralith I am doing nasty system programming in windows, and I have to pass a pointer as LPARAM to SendMessage's, which is CLong. alternatively I could redefine SendMessage's declaration just for this use, but I'd prefer not to do that.
18:28:48 <Ralith> why do you have to pass a pointer?
18:28:51 <shachaf> GHC has addr2Int#
18:29:29 <shachaf> Oh, ptrToIntPtr
18:29:33 <shachaf> That's what you want.
18:29:39 <jackss> to read other proc's memory.
18:30:34 <shachaf> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Foreign-Ptr.html
18:30:51 <shachaf> Better yet, ptrToWordPtr
18:30:56 <shachaf> Since LPARAM is probably unsigned?
18:30:59 <jackss> it uses LPARAM as sort of a generic argument, the actual type depends on the use
18:31:08 <jackss> it is signed
18:31:09 <shachaf> Oh, no, it's signed.
18:31:11 <jackss> CLong
18:31:27 <shachaf> OK, so use what I said.
18:31:37 <shachaf> It's not actually Long, it's the size of the machine word.
18:31:43 <shachaf> Or something.
18:32:08 <jackss> yes true
18:32:17 <jackss> CLong in here
18:48:54 <hpaste> anton pasted “a little bit abstract” at http://hpaste.org/79604
18:50:19 <alien> I reduced some code to an echo http://hpaste.org/79603, but it doesn't quite behave as expected. When its run the echo is ``delayed'' by a line. Can someone help?
18:51:23 <rwbarton> well 'intercalate "\n"' doesn't add a trailing newline, so it should be delayed
18:51:32 <rwbarton> use unlines instead
18:52:39 <rwbarton> (that and output to stdout is line-buffered by default if stdout is a terminal)
18:52:53 <alien> Thanks That makes complete sense now.
19:33:04 <m3ga> @lastseen hvr
19:33:05 <lambdabot> Unknown command, try @list
19:33:10 <m3ga> @list
19:33:10 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
19:33:41 <m3ga> @seen hvr
19:33:42 <lambdabot> Unknown command, try @list
19:34:40 <m3ga> @last hvr
19:34:40 <lambdabot> No module "hvr" loaded
19:45:25 <Ralith> @yhjulwwiefzojcbxybbruweejw
19:45:25 <lambdabot> "\"\\\"\\\\\\\"\\\\\\"
19:45:29 <Ralith> huh.
19:45:41 <elliott> yes
19:45:57 <Ralith> what's the deal with that
19:46:00 <elliott> yes
19:46:23 <shachaf> > fix show
19:46:25 <lambdabot>   "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\...
19:47:00 <Ralith> o.O
19:47:19 <Hafydd> Heh.
19:48:57 <Ralith> oh, yes
19:51:01 <lispy> Ralith: @yhjulwwiefzojcbxybbruweejw is a nod to the fact that once upon a time, you could reference the previous command and it led to all manner of shenanigans
19:51:17 <lispy> Ralith: at some point the name of 'it' became randomized
19:52:19 <rwbarton> @it
19:52:19 <lambdabot> Maybe you meant: ft id
19:52:52 <geekosaur> actualy it was:
19:52:53 <geekosaur> @v
19:52:53 <lambdabot> "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\"
19:52:59 <geekosaur> "it" is what ghci uses
19:53:00 <rwbarton> ah
19:53:44 <lispy> lambdabot has a long sordid past
19:53:50 <lispy> @vixen isn't that so?
19:53:50 <lambdabot> Voters quickly forget what a man says.
19:54:25 <lispy> @nixon
19:54:25 <lambdabot> I've never canceled a subscription to a newspaper because of bad cartoons or editorials. If that were the case, I wouldn't have any newspapers or magazines to read.
20:18:31 <shachaf> Is there a name for newtype Foo a b = Foo b?
20:21:26 <ion> Tagged?
20:21:34 <ion> i think
20:21:50 <elliott> shachaf: yeah Tagged
20:21:51 <shachaf> ion: Thanks!
20:21:59 <shachaf> I should've known.
20:22:09 <shachaf> After Proxy helped me and all.
20:22:12 <elliott> shachaf: use (Proxy s ->) instead :(
20:23:25 <shachaf> elliott: Why. :-(
20:23:33 <elliott> because Tagged is gross to use
20:23:50 <jackss> why is this returning false?  "hello1" =~ "hello\\d" :: Bool
20:24:29 <shachaf> Try hello[0-9]
20:24:36 <shachaf> It must be a different type of regexp from what you're use to.
20:24:39 <shachaf> elliott: I'm trying to work out how nice lens would be if it used k a b -> k s t
20:24:54 <ion> jackss: You may want PCRE. Or Parsec.
20:25:09 <shachaf> elliott: You could probably do away with a lot of the functor nonsense and  just use the appropriate types directly.
20:25:14 <shachaf> Reviewing s t a b = Tagged a b -> Tagged s t
20:25:16 <jackss> thanks
20:25:17 <edwardk> shachaf got his first alternate reality. now he wants another one =)
20:25:20 <shachaf> Setting s t a b = (a -> b) -> s -> t
20:25:28 <shachaf> edwardk: Hey, I'm just trying things out!
20:26:02 <shachaf> Getting s t a b = Foo a b -> Foo s t, where Foo a b = (a -> r)?
20:26:12 <popl> where is operator =~ at?
20:26:18 <shachaf> @hoogle =~
20:26:19 <lambdabot> Text.Regex.Posix.Wrap (=~) :: (RegexMaker Regex CompOption ExecOption source, RegexContext Regex source1 target) => source1 -> source -> target
20:26:19 <lambdabot> Text.Regex.Posix.Wrap (=~~) :: (RegexMaker Regex CompOption ExecOption source, RegexContext Regex source1 target, Monad m) => source1 -> source -> m target
20:26:35 <popl> hoogle
20:26:35 <popl> hah
20:26:37 <popl> sorry
20:26:39 <ivanm> copumpkin: am I able to pick your brains regarding vectors (seeing as how you said I was doing it wrong yesterday :p)?
20:27:14 <shachaf> elliott: I think if there turned out to be a good set of operations this could turn out really nice.
20:28:13 <elliott> shachaf: not convinced SEC lenses are the way to go
20:28:49 <shachaf> elliott: They're more convenient than symmetric lenses!
20:29:04 <shachaf> Even ignoring the overloading, Foo a b -> Foo s t seems like the right shape for lenses.
20:29:08 <elliott> less convenient than twan leness
20:29:27 <elliott> lenses
20:37:41 <popl> oh boy
20:38:00 <clj-newb-234> is (= (m-bind (m-result value) function)) (function value)) correct? or should i be (= (m-bind (m-result value) function) (m-result (functoin value))) ?
20:38:33 <lispy> what is (= ...) ?
20:38:35 <ivanm> edwardk: is there a non-flash version of your lens talk anywhere?
20:38:48 <ivanm> lispy: I'm going to guess it's lisp
20:38:51 <popl> lispy: looks lispy
20:38:51 <clj-newb-234> (= .. ) meaing the two should be equal
20:38:59 <ivanm> which - given your nick - I would have thought you'd know :p
20:39:06 <ivanm> clj-newb-234: you sure you're asking in the right channel?
20:39:09 <clj-newb-234> yes
20:39:16 <clj-newb-234> haskell people known monads and are friendly
20:39:30 * popl is not a haskell person
20:39:31 <ivanm> oh, is that meant to be monadic?
20:39:33 * popl growls
20:39:40 <ivanm> popl: what are you then?
20:39:43 <clj-newb-234> (m-bind (m-result value) function) <-- should this be: (function value) or (m-result (function value)) ?
20:39:47 <clj-newb-234> I'm referring to the first monad law
20:39:53 <popl> ivanm: I don't know. I haven't chosen a team.
20:39:53 <elliott> going by your nick i believe you want #clojure
20:40:09 <popl> elliott: We all need clojure, once in awhile.
20:40:43 <ivanm> clj-newb-234: technically it's "equivalent to", not "equal to" for the monadic laws
20:40:49 <ivanm> since they can deal with side effects
20:41:06 <shachaf> ivanm: Hmm?
20:41:09 <ivanm> note that the function returns a monadic value
20:41:25 <shachaf> What do side effects have to do with the monad laws?
20:42:06 <ivanm> shachaf: clj-newb-234 seems to be trying to implement the monad laws in some form of lisp; is doing equality testing really correct?
20:42:23 <elliott> seems right to me? I don't know Clojure though
20:42:32 <elliott> if you're quickcheck-checking, for instance
20:42:36 <shachaf> The monad laws should apply as far as you can test equality.
20:42:36 <ivanm> if in some IO-like Monad "return" also did a `putStrLn "hi" ' then just doing equality testing won't give you the same result
20:42:37 <elliott> or just stating it as a boolean property that should hold
20:42:46 <lispy> does m-result force a monadic value?
20:42:47 <shachaf> Of course, they don't apply to identity, but that's a different thing.
20:43:00 <shachaf> ivanm: No instance for Eq (IO ())
20:43:04 <elliott> if you're writing an IO monad then it better not execute when you "force" it
20:43:09 <ivanm> shachaf: ahhh, right
20:43:10 <elliott> but that's a whole other thing imo
20:43:19 <lispy> (m-result value) is roughly value >>= ... ?
20:43:21 <shachaf> ivanm: Comparing the ()s will give you (==) but that's a different matter.
20:43:40 <ivanm> lispy: I think m-result is return
20:43:50 <shachaf> clj-newb-234: I suspect people here are better equipped to tell you about monads in Haskell than in Clojure.
20:43:51 <ivanm> shachaf: right
20:44:23 * elliott thinks we need a #monads. lots of people come in asking off-topic questions involving monads here
20:44:38 <popl> elliott: better than gonads
20:44:49 <popl> Am I right?
20:44:59 <Twisol> That's a bit of a tired joke. :P
20:45:06 * popl waits for the laugh...
20:45:23 <lispy> ah, so the original question asked if ((return v) >>= f) = (f v) or is it (return v) >>= f = (return (f v)), with extra parens because they are cheap
20:45:24 <XexonixXexillion> (m-bind (m-result x) f) === (return x >>= f)
20:45:39 <popl> Twisol: Not as tired as my arms!
20:46:09 <M30W> Hmm
20:46:16 <lispy> clj-newb-234: f is assumed to have a monadic retrun type
20:46:26 <M30W> http://hackage.haskell.org/package/download -> All examples return with the following error..
20:46:31 <M30W> Loading package array-0.4.0.1 ... linking ... <interactive>: /home/archey/.cabal/lib/download-0.3.2/ghc-7.6.1/HSdownload-0.3.2.o: unknown symbol `stat64'
20:46:34 <lispy> clj-newb-234: so, (return (f v)) would be Monad m => m (m a)
20:47:14 <M30W> Any ideas?
20:47:15 <lispy> clj-newb-234: (or a similar variation depending on stuff, but that's the simplest type for which you can see that it's type incorrect)
20:47:20 <ivanm> M30W: as in you're trying to use it in ghci?
20:47:35 <M30W> ivanm: Yes
20:48:01 <M30W> ivanm: Hence the <interactive>
20:48:11 <ivanm> I thought so; just checking :)
20:48:20 <popl> M30W: Is this on a 32-bit system?
20:48:36 <ivanm> you might need to specify to ghci where the cbits are
20:48:38 <M30W> popl: 64
20:49:06 <M30W> ivanm: Yea..... how?
20:49:15 <ivanm> M30W: have you tried creating a file with some code using it, then compiling it and running it?
20:49:25 <M30W> ivanm: No, but I shall
20:49:56 <ivanm> I assume you used cabal-install to install this?
20:50:17 <M30W> x.hs:3:5: parse error on input `<-'
20:50:18 <M30W> Hmm
20:50:20 * ivanm isn't sure what cabal-install does with the C parts of packages
20:50:22 <M30W> oh ofc
20:50:25 <ivanm> M30W: shove it in main
20:50:47 <simpson> If I've got an FFI with its own monad wrapper around IO, how polite should I be about exposing the constructor?
20:50:59 <M30W> ivanm: Did that.
20:51:03 <M30W> but...
20:51:08 <ivanm> and does it work?
20:51:08 <M30W>     The last statement in a 'do' block must be an expression
20:51:09 <M30W>       doc <- openURI "http://haskell.org"
20:51:13 <M30W> So, I put doc after that.
20:51:20 <M30W> more errors
20:51:24 <ivanm> print doc
20:51:27 <ivanm> or something like that
20:51:36 <M30W> heh, just tried show. print, okay :)
20:51:37 <simpson> I mean, I don't *really* care if people can wrap/unwrap the monad too much, I just read that it was good practice to have a separate type for doing this kind of work.
20:51:55 <M30W> Left "Failed to connect: Temporary Redirect"
20:51:57 <clj-newb-234> lispy: got it sorted out; thanks!
20:52:07 <ivanm> M30W: OK, so it was definitely a linking/C issue
20:52:07 <ion> m30w: Look at the types of openURI, show and print.
20:52:19 <ivanm> which can be a PITA to use with ghci
20:52:46 <M30W> ivanm: So what.. I've found 2 ghci bugs now?
20:53:19 <M30W>   :: String -> IO (Either String Data.ByteString.Internal.ByteString)
20:55:01 <ivanm> this isn't a ghci bug
20:55:06 <ivanm> it's possible, I just can't recall how
20:55:18 <M30W> ivanm: Okay and :(
20:55:32 <M30W> Oh and "PITA" ?
20:55:44 <ivanm> M30W: so the package couldn't get that page; if it exists then that hints that the package isn't working properly
20:56:12 <M30W> ivanm: No the example led to a redirect. I tried with my own site, worked as expected.
20:56:39 <M30W> Even then, it shouldn't give a redirect but should listen to it haha.
20:57:04 * hackagebot vector-fftw 0.1.3 - A binding to the fftw library for one-dimensional vectors.  http://hackage.haskell.org/package/vector-fftw-0.1.3 (JudahJacobson)
20:57:30 <ivanm> @google PITA
20:57:31 <lambdabot> http://en.wikipedia.org/wiki/Pita
20:57:31 <lambdabot> Title: Pita - Wikipedia, the free encyclopedia
20:57:42 <elliott> good result
20:57:43 <ivanm> I somehow don't think that's the correct meaning of the acronym...
20:58:30 <popl> mmm
20:58:37 <popl> to hell with acronyms
20:58:42 <popl> pita + hummus
20:58:45 <M30W> Yea, I looked around before asking
20:58:59 <popl> I'm hungry now
20:59:06 <M30W> popl: Same
20:59:47 <M30W> http://en.wikipedia.org/wiki/Pita_%28disambiguation%29
20:59:48 <M30W> Acronym of pain in the ass
20:59:49 <M30W> Hehe
21:00:38 * M30W learnt something about wikipedia; easy to get a list of other meanings :P
21:01:27 * M30W tries download-curl instead to see if that works interactive
21:02:12 <M30W> Worked
21:04:52 * M30W might just use Network alone.
21:05:03 <M30W> No downloader crap w/ xml jump
21:05:05 <M30W> junk *
21:06:08 <M30W> @hoogle http-monad
21:06:09 <lambdabot> package http-monad
21:06:19 <M30W> That was useful
21:06:35 <M30W> I don't see any documentation on that page..
21:06:53 <M30W> http://hackage.haskell.org/package/http-monad ?
21:06:57 <simpson> Yes.
21:07:11 <simpson> http://hackage.haskell.org/package/http-monad-0.1.0.1 has docs built.
21:07:12 <M30W> No links for docs D:
21:07:17 <simpson> But the newest version failed to build.
21:07:21 <M30W> :D
21:07:28 <M30W> I see.
21:07:42 <M30W> And fuck all documtation that gives haha
21:09:13 <M30W> How is the documtation generated exactly?
21:09:23 <M30W> English != good to generate, still human?
21:10:19 <M30W> Or documentation in code gets referenced?
21:10:26 <simpson> It's Haddock documentation.
21:10:39 <simpson> Special formatted comments in the code are extracted and used to build the documentation.
21:11:00 <M30W> Okay
21:16:35 <edwardk> ivanm: i have the mp4 file, but its ~3 gigs
21:16:51 <edwardk> right now i'm bothering to go clean up the closed captioning ;)
21:18:07 <ivanm> heh, fair enough
21:18:21 <popl> mp4?
21:18:29 <popl> PIRATE
21:19:12 <edwardk> popl: worse, the version google finally accepted was an mkv
21:19:14 <popl> does haskell have something for modular exponentiation?
21:19:20 <edwardk> popl: nope
21:19:26 <popl> weak sauce
21:19:36 <shachaf> Are you pirating your own talks now, edwardk?
21:19:39 <shachaf> A new low for you.
21:21:07 <ivanm> isn't that what torrents are for? ;-)
21:22:04 * hackagebot vector-fftw 0.1.3.1 - A binding to the fftw library for one-dimensional vectors.  http://hackage.haskell.org/package/vector-fftw-0.1.3.1 (JudahJacobson)
21:23:31 <monochrom> mkv is fine. my TV can play mkv
21:24:26 <`nand`> wait, what's wrong with mkv?
21:25:28 <XexonixXexillion> Isn't mkv just a container format for something else?
21:25:41 <popl> XexonixXexillion: How do you pronounce your handle?
21:25:45 <orospakr> hey, I've got a silly question here: I've defined "Paragraph" as a synonym of "String", but it seems that [String] does not type match with [Paragraph]. " Couldn't match expected type `Paragraph' with actual type `String'"
21:26:01 <orospakr> I guess I'm making a bogus assumption somewhere.
21:26:12 <simpson> XexonixXexillion: Yes, Matroska can hold just about anything.
21:26:21 <orospakr> I guess I could explicitly convert with a list comprehension.
21:26:22 <monochrom> show actual code
21:28:59 <orospakr> monochrom, sure... https://gist.github.com/4350859
21:29:19 <XexonixXexillion> popl: something like zekzoniks zekzileon. I could write it in IPA, but my terminal isn't utf-8 compliant
21:29:40 <Clint> that's not a type synonym
21:29:53 <monochrom> "data Paragraph = String" is not defining synonym. use "type Paragraph = String"
21:30:02 <orospakr> huh!
21:30:03 <orospakr> neat.
21:30:05 <orospakr> thanks. :)
21:31:32 <johnw> aristid: ping
21:31:33 <simpson> In my FFI binding, I have a handful of types. For a given type (let's say Event), I want to have three types: Event, which is the high-level ADT; InternalEvent, which is an empty data declaration, and EventPtr, which is type EventPtr = ForeignPtr InternalEvent
21:31:47 <simpson> What's the conventional name for InternalEvent?
21:31:53 <M30W> Is there any media player written in haskell?
21:32:01 <johnw> simpson: you mean, like Void?
21:32:07 <M30W> Like mplayer but written in haskell.
21:32:42 <elliott> you can just use ForeignPtr Event
21:32:44 <elliott> or ForeignPtr ()
21:32:45 <elliott> or whatever
21:32:46 <simpson> johnw: Well, yes, but typesave.
21:32:50 <simpson> Er, *typesafe.
21:33:07 <johnw> what I think he wants is StablePtr Event
21:33:27 <johnw> you want to be able to pass Haskell values through C code, yeah?
21:33:37 <simpson> This particular API manages all of its memory, and keeps all of its structures opaque. I only have pointers and no idea what the internals look like.
21:33:45 <johnw> in which case, see the 'with' function in the FFI
21:33:49 <monochrom> discovery: how to find out undocumented valid fields for project.cabal files: write an invalid field, then the error message will list valid fields
21:34:04 <johnw> monochrom: nice
21:34:26 <simpson> I don't need StablePtr. The only things I'm ever passing out like that are CStrings, and the existing helpers are sufficient for that.
21:34:47 <johnw> so what is an "Event" then?
21:34:48 <simpson> I want to have a high-level series of ADTs that represent the underlying pointers.
21:34:52 <hrumph> hi
21:35:10 <hrumph> if i want to use an ide should i use lakseh?
21:35:18 <hrumph> so most people use lakseh now?
21:35:19 <simpson> Well, in this case, data Event = PitchBend | NoteOn | ... -- which mirrors a wall of fluid_event_pitchbend(...) C calls.
21:35:30 <johnw> how is that a CString?
21:36:49 <johnw> a StablePtr can give you a Ptr for any Haskell value, guarding it from garbage collection, as long as you manage the memory for it.  A ForeignPtr is lower level, and you'll have to do some work to stuff a Haskell ADT into it
21:37:14 <johnw> you could, I suppose, wrap a StablePtr in a ForeignPtr, and make deRefStablePtr the finalizer
21:37:14 <simpson> But I'm going the other way: The ADT mirrors opaque data inside the library.
21:37:28 <johnw> hmm
21:37:33 * simpson hpastes
21:37:36 <johnw> well, if you show me the actual design.. :)
21:37:40 <johnw> heh, you read my mind
21:38:28 <hpaste> simpson pasted “Some FluidSynth FFI” at http://hpaste.org/79608
21:38:32 <johnw> oh, and ForeignPtr forces you to write Storable instances
21:39:19 <Clint> simpson: if you were using bindings-DSL, you could #opaque_t AudioDriver
21:39:27 <johnw> yeah
21:39:38 <johnw> i use Bindings-DSL also, it's great
21:39:44 <simpson> Hey, I don't know which tools are the right tools.
21:40:29 <simpson> Anyway, the *entire* fluidsynth API looks like this. You call new_*() to get handles, you manipulate them using only builtin C types, and eventually you delete_*() them when done.
21:40:48 <johnw> if you did this:
21:41:03 <simpson> I've already written enough of the actual C calls to start writing my higher-level bindings, I just am not sure if I'm Doin' It Horribly Wrong.
21:41:10 <johnw> #ccall delete_fluid_audio_driver , Ptr <audio_driver_t> -> IO ()
21:41:19 <johnw> then you'd get a Haskell value called p'delete_fluid_audio_driver
21:41:25 <johnw> which you could pass to newForeignPtr
21:41:25 <dmwit> Okay, this is strange. I tried "cabal install ./glib ./gio ./cairo ./pango ./gtk", which complained that glib-0.12.4 failed during the configure step. But if I manually "cabal configure" in ./glib it succeeds just fine.
21:41:40 <johnw> (I'm assuming you also did #opaque_t audio_driver_t, or whatever it's called)
21:42:17 <johnw> and for new_fluid_audio_driver you'd write:
21:42:32 <johnw> #opaque_t settings_t
21:42:37 <`nand`> M30W: I've wondered that in the past before. If you want to write one, I'd be happy to contribute (eg. color management) :)
21:42:50 <johnw> #ccall new_fluid_audio_driver , Ptr <settings_t> -> Ptr <synth_t> -> IO (Ptr <audio_driver_t>)
21:42:54 <johnw> and you'd call c'new_fluid_audio_driver
21:43:06 <johnw> simpson: take a look at c2hsc
21:43:10 <johnw> it will generate most of this magic for you
21:43:14 <M30W> `nand`: Yea.... I'd love to, but my haskell skills are quite noob ^_^
21:43:21 <`nand`> same, unfortunately
21:44:18 <`nand`> at least when it comes to this kind of stuff
21:44:22 <simpson> johnw: Hm. Does that really result in less binding code? I mean, at this point, what I've got is working and appears to follow both the law and spirit of GC...
21:44:41 <johnw> simpson: it results in a TON less work, especially if the API changes on you
21:44:57 <johnw> I wrote it because libgit2 was just too big an API for me to write all that boilerplate for
21:45:14 <johnw> and I didn't want to hunt down what the changes were between every new release
21:45:15 <simpson> johnw: This API will never change. It's been stable for years and years. I'm really just trying to port this last bit of FFI so that I can move a library off of Python.
21:45:28 <johnw> well, then you don't need it
21:45:40 <johnw> so, explain now what you're lacking in that pastie?
21:46:00 <simpson> I just wanted to know if there was a convention for naming the phantom type that I'm using for the type-safe pointers.
21:46:09 <elliott> you don't need to use a phantom type
21:46:12 <elliott> just use the struct name or whatever
21:46:18 <elliott> er as in the adt name
21:46:30 <johnw> which one is the phantom type in your pastie?_
21:46:39 <simpson> The empty one: data AudioDriver
21:46:52 <johnw> oh
21:47:08 <johnw> the "convention", I believe, to have new_fluid_audio_driver return Ptr (), and delete_fluid_audio_driver take Ptr ()
21:47:13 <johnw> you don't need a "type" for that pointer
21:47:22 <johnw> at least, not just to stuff it in a ForeignPtr
21:47:44 <simpson> Hm, okay. I just took ezyang's advice on his blog post about typing those pointers.
21:47:52 <johnw> link?
21:47:58 <simpson> http://blog.ezyang.com/2010/06/principles-of-ffi-api-design/ and related.
21:47:58 <johnw> ezyang would know a lot better than me about this
21:48:02 <`nand`> I think a type-safe pointer is much, much better than a Ptr ()
21:48:16 <`nand`> prevents you from accidentally mixing them
21:48:33 <johnw> yeah, do what ezyang says :)
21:48:42 <johnw> i don't know the naming convention for these phantom pointer types
21:48:49 <johnw> BatPtr
21:49:03 <simpson> Maybe I'll just stick a Ptr on the end of everything. Or a P. Or something.
21:49:18 <`nand`> I think Ptr AudioDriver is fine, personallhy
21:49:20 <`nand`> lly*
21:49:30 <`nand`> the pointery-ness comes from ‘Ptr’, no need to suffix it or anything
21:49:36 <simpson> Right, but I was going to have a high-level AudioDriver type up above.
21:49:38 <elliott> simpson: you can data P a
21:49:44 <elliott> then Ptr (P MyCorrespondingADT)
21:49:47 <elliott> if you really want to keep them separate
21:49:50 <`nand`> and since it's a phantom type, it's not like something else is going to use them
21:49:52 <`nand`> ah
21:50:31 <johnw> Bindings-DSL, fwiw, turns #opaque_t Foo into this: data C'Foo = C'Foo
21:50:39 <`nand`> if your ADT corresponds to different types of devices internally you could be really sneaky and use DataKinds here ;)
21:50:42 <popl> Is the only reason Haskell hasn't got any modular arithmetic modules because nobody's written them?
21:50:46 <johnw> so, a C' prefix could be a nice convention
21:50:52 <simpson> Yeah, that could work well.
21:51:13 <simpson> As usual, this channel (and its inhabitants) rock.
21:51:21 <johnw> it kind of reads "a type only C knows about"
21:51:26 <elliott> 's are weird
21:51:37 <johnw> shh.... you'll wake Nereid
21:51:57 <`nand`> a ' in the second position of a type or constructor name can be unfortunate
21:52:02 <`nand`> try quoting it for TemplateHaskell, for example
21:52:13 <`nand`> I don't like that convention at all
21:52:28 <johnw> i'm very used it to now
21:52:37 <`nand`> or; I would be more open to it if the Char ambiguity thing was worked around somehow
21:52:44 <johnw> Bindings-DSL uses: C' c' p' mk' mK'
21:55:49 <johnw> edwardk: still awake?
21:58:51 <sopvop> @faq can haskell stop doomsday?
21:58:52 <lambdabot> The answer is: Yes! Haskell can do that.
21:59:22 <popl> @faq can haskell bring people back from the dead?
21:59:22 <lambdabot> The answer is: Yes! Haskell can do that.
21:59:36 <popl> :(
21:59:41 <popl> GET TO WORK
21:59:42 * sopvop came to work, and there is no one.
21:59:52 <popl> sopvop: Really?
21:59:59 <popl> sopvop: Where do you work?
22:00:08 <popl> Er, what type of industry?
22:00:21 <sopvop> CG studio. Most people are come late 1-2 hours
22:00:31 <johnw> i hope you don't work in zombie research
22:00:45 <`nand`> do you use Haskell tools for your CG work?
22:00:50 <sopvop> I guess everyone took one doomesday off
22:01:18 <johnw> damn, i forgot everything was ending today
22:01:22 <johnw> i better push my Hackage changes up now
22:01:36 <sopvop> I use it for asset tracking backend, like restful "web-db".
22:01:55 <`nand`> johnw: yeah, good idea
22:02:03 <`nand`> in case we only suffer from a partial doomsday
22:02:31 <sopvop> partial doomsday, is when you can get a bottom?
22:02:55 <`nand`> partial doomsday is when the universe ends due to hitting a black hole
22:03:38 <sopvop> It should be reverse of that. Doomsday ends when hit undefined black hole.
22:04:13 <sopvop> does not sound right anyway :(
22:04:49 <popl> The only thing that's ending today is belief in some stupid apocalyptic idea.
22:05:47 <c_wraith> it's a solstice.  That means something else is ending
22:05:48 <elliott> at least we'll get hackage 2
22:05:56 <c_wraith> (the days shortening, in the northern hemisphere)
22:05:57 <`nand`> oh, just to be on the safe side
22:06:02 <`nand`> λ import Acme.RealWorld
22:06:03 <`nand`> λ goodOld <- getWorld
22:06:09 <`nand`> leave it to me to call putWorld if anything goes wrong
22:06:10 <statusfailed> don't do it!
22:06:33 <mzero> anyone know how to get intouch with Carlton Mills?
22:06:48 <mzero>  msg me if you do
22:07:31 <statusfailed> Who's that?
22:07:36 <`nand`> can't find him on hackage
22:08:04 <statusfailed> so he doesn't exist.
22:08:17 <sopvop> Next one comes in 2018. http://en.wikipedia.org/wiki/List_of_dates_predicted_for_apocalyptic_events
22:08:34 <statusfailed> I can't wait 6 years, let's hoax up a closer one
22:08:42 <popl> mzero: http://www.legacy.com/obituaries/godanriver/obituary.aspx?n=carlton-mills&pid=147986859&fhid=4961
22:08:46 <popl> sorry
22:08:48 <`nand`> statusfailed: agreed
22:08:59 <mzero> you guys are a great help, ya know!
22:09:01 <`nand`> just you wait till the Haskell apocalypse comes
22:09:06 <`nand`> it's lazy though, you have to force it
22:12:59 * isomorphic adds unsafePerformApocalypse to the reading list
22:13:02 <johnw> aristid: ping ping ping!
22:13:26 <johnw> i think we need a functino called just 'unsafe'.  you get to define what it means at any time
22:14:07 <popl> isomorphic: http://tuukka.iki.fi/tmp/haskell-2009-04-15.html#13:40:53
22:14:23 <johnw> haha
22:14:26 <johnw> very nice
22:14:43 <sopvop> edwardk - always first.
22:15:00 <popl> bah
22:15:01 <sopvop> lens apocalypse
22:15:31 <isomorphic> HAHA
22:15:46 <edwardk> apocalypses are great relevations, so of course there is a lens apocalypse ;)
22:15:55 <edwardk> er revelations
22:16:06 <popl> relegation
22:16:18 <popl> apocalypses are great relegations
22:16:24 <edwardk> yes, they've been relegated to relative obscurity
22:16:31 <johnw> and Haskell lets you name it unsafePerformἀποκάλυψις
22:17:07 <sopvop> There is lambda in ἀποκάλυψις. That is a sign!
22:17:09 <shachaf> But does it let you name it u̞n̐s̻a̹fͫe͓P̡e͟rͩf͓o͕rͣm͑A̹pͦo̠c̭a͇l̕y̓p̊s͟e͙
22:17:11 <isomorphic> So- and I'll caveat this by saying I suspect this is a stupid question - I've implemented a 'Row' type for the row number in a table.   The intention is that it implements natural numbers.  If I'd like to operate on it with a function that's expecting an Int type, is the right approach to make it an instance of Integral?
22:17:32 <popl> edwardk: obscurity?
22:17:51 <johnw> oh, edwardk, you're here
22:18:01 <zomg> isomorphic: if a function expects an Int it isn't going to accept something that isn't an Int
22:18:05 <edwardk> popl: there aren't nearly enough people talking about them for a topic with my current level of interest ;)
22:18:05 <johnw> can I get many anyChar to return a Text?  or do I always have to pack <$>?
22:18:23 <sopvop> {-# LANGAUGE GeneralizedNewtypeDeriving #-} newtype Row { unRow :: Int } deriving (Num, Eq)
22:18:32 <popl> edwardk: I'm not sure of apocalypses wrt all of the major religions, but I think many of them have something
22:18:37 <edwardk> johnw: you'll need to pack. in general you can use 'sliced' to get the bytestring of the source text, but thats it
22:18:43 <johnw> ok
22:18:52 <johnw> and to merge two parses, I have (++) <$>, yeah?
22:19:03 <edwardk> popl i was just pulling a larry wall and referring to the origin of the word
22:19:18 <edwardk> that'd work
22:19:24 <popl> I've never talked to the Wall.
22:19:28 <edwardk> or you can slice the whole thing
22:19:32 <popl> Although he hangs out in #perl6
22:19:49 <edwardk> popl: this was a big thing back in the perl 6 planning, he released a bunch of exegeses and apocalypses
22:20:03 <popl> exegeses is a great word
22:20:06 <sopvop> -Wall talks to me, says I'm bad boy
22:20:06 <edwardk> its admittedly a 10 year old reference, never mind ;)
22:20:13 <edwardk> sopvop++
22:20:54 <isomorphic> sopvop:  Thanks.  I originally started with the GeneralizedNewType and Num - but then thought Integral made more sense because it provides toInteger.   What about the Num typeclass leads you this way?
22:21:03 <popl> I asked a Wiccan priest what the word meant one time and he didn't know. Wiccans are dumb.
22:21:42 <popl> So when is Haskell going to get an RSA module?
22:22:23 <sopvop> isomorphic: I thought you want math stuff with Row.
22:22:41 <isomorphic> sopvop:  Thanks :)  Very much appreciated
22:23:11 <isomorphic> sopvop:  Is the un-prefix a GND thing?
22:23:41 <isomorphic> eg: unRow :: String would do it for strings?
22:23:51 <sopvop> Isomorphic: No, its just a useful way to strip wrapper.
22:24:00 <sopvop> sure, It's like record
22:24:28 <sopvop> unRow :: Row -> Int. Row :: Int -> Row
22:25:03 <ion> @check let powMod a p m | p > 0 && m /= 0 = product (zipWith (^) (powsMod a m) (digits p)) `mod` m | p == 0 && m /= 0 = 1 `mod` m; digits = unfoldr (\n -> swap (n `quotRem` 2) <$ guard (n /= 0)); powsMod a m = iterate ((`mod` m) . (^2)) (a `mod` m) in \a (QC.NonNegative p) (QC.NonZero m) -> powMod a p m == (a^p) `mod` m
22:25:04 <sopvop> you can just use newtype Row = Row Int. Same thing, record syntax gives you unwrap function for free
22:25:05 <lambdabot>   Not in scope: `myquickcheck'Not in scope: data constructor `QC.NonNegative'...
22:25:21 <elliott> popl: there are multiple RSA implementations for Haskell...
22:25:36 <popl> elliott: There are? Which one is the neatest?
22:25:39 <ion> Whoops, i left the qualified QC names there. But it won’t work anyway, @check is broken.
22:25:47 <popl> elliott: Which one do you think is the neatest?
22:25:50 <johnw> edwardk: is there a performance difference between satisfy (\c -> c == '@' || c == '!') and (char '@' <|> char '!')?
22:26:04 <johnw> (like there is for attoparsec)
22:26:32 <edwardk> the latter will be more expensive than the former in practice.
22:26:33 <ivanm> johnw: which is faster in attoparsec (and why)?
22:26:40 <ivanm> oh, <|> vs || ?
22:26:43 <johnw> the former, and beacues taht's what the docs say
22:26:47 <ivanm> heh
22:26:47 <elliott> popl: no idea, a quick search of hackage turns up several though
22:26:54 <popl> ok elliott, thank you
22:26:56 <edwardk> there is a subtle trade-off
22:27:05 <johnw> in quality of error reporting?
22:27:09 * popl eyes ion 
22:27:09 <edwardk> satisfy will parse once, but has to do full UTF-8 decoding
22:27:27 <edwardk> the latter has to decode multiple times but since the constants you give are ascii, it skips the utf-8 decoding step ;)
22:27:30 <popl> ion: whatcha doin'?
22:27:42 <edwardk> oneOf "@!" is faster than both of those
22:28:00 <edwardk> because it gets to figure out that all of them are ascii and do a single decoding and charset lookup
22:28:03 <johnw> that's what I ended up with
22:28:08 <edwardk> and my charsets are especially fast for ascii
22:28:18 <johnw> nice, ok
22:28:26 <isomorphic> sopvop:  Just to be clear, I take it I'm going to have to put the Row into an unwrap function - I can't just use it where the Int would have been?
22:29:19 <sopvop> isomorphic: you will have to unwrap it. Row != Int
22:30:24 <ion> > let powMod a p m | p > 0 && m /= 0 = product (zipWith (^) (powsMod a m) (digits p)) `mod` m | p == 0 && m /= 0 = 1 `mod` m; digits = unfoldr (\n -> swap (n `quotRem` 2) <$ guard (n /= 0)); powsMod a m = iterate ((`mod` m) . (^2)) (a `mod` m) in (powMod 42 (10^7) 1234567, 42^(10^7) `mod` 1234567)
22:30:29 <lambdabot>   (3
22:30:38 <ion> err
22:30:40 <sopvop> isomorphic: good thing though is what unwrapping is free. newtypes only exist for type checker.
22:30:42 <mysticc> Is there a function which works similar to f i g n = foldM (\a _ -> g a) i [1..n] ..
22:30:49 <ion> > let powMod a p m | p > 0 && m /= 0 = product (zipWith (^) (powsMod a m) (digits p)) `mod` m | p == 0 && m /= 0 = 1 `mod` m; digits = unfoldr (\n -> swap (n `quotRem` 2) <$ guard (n /= 0)); powsMod a m = iterate ((`mod` m) . (^2)) (a `mod` m) in (powMod 42 (10^5) 1234567, 42^(10^5) `mod` 1234567)
22:30:52 <lambdabot>   (801571,801571)
22:31:01 <ion> > let powMod a p m | p > 0 && m /= 0 = product (zipWith (^) (powsMod a m) (digits p)) `mod` m | p == 0 && m /= 0 = 1 `mod` m; digits = unfoldr (\n -> swap (n `quotRem` 2) <$ guard (n /= 0)); powsMod a m = iterate ((`mod` m) . (^2)) (a `mod` m) in powMod 42 (10^100) 1234567
22:31:04 <lambdabot>   46650
22:32:27 <ion> popl: ↑
22:33:05 <sopvop> what forall does when used in type alias?
22:34:34 <popl> ion: sexy
22:35:05 <sopvop> I know what it does with data, or ScopedTypeVariables. but why use it in type Foo a = forall a...?
22:36:19 <elliott> sopvop: then Foo a is forall a. ...
22:36:24 <elliott> foo :: Foo a; foo = ...
22:36:28 <elliott> foo :: forall a. ...; foo = ...
22:36:30 <elliott> same thing
22:36:45 <sopvop> Oh, I'm misread that
22:36:52 <sopvop> type Getter s a = forall f. Gettable f => (a -> f a) -> s -> f s
22:37:01 <sopvop> it hides `f' from type
22:37:19 <sopvop> Does it have any limitations of using Getter?
22:37:42 <elliott> if you define foo :: Getter s a
22:37:44 <elliott> then that's the same as
22:37:48 <elliott> foo :: Gettable f => (a -> f a) -> s -> f s
22:38:11 <sopvop> Like constraint alias
22:39:01 <popl> I was born on the wrong continent. :P
22:39:28 <sopvop> popl: which one?
22:39:39 <popl> sopvop: the shooty one
22:40:01 <carlocci> popl: africa?
22:40:11 <popl> carlocci++
22:40:20 <popl> carlocci: the other one
22:40:27 <statusfailed> America?
22:40:41 <popl> statusfailed: yes
22:40:46 <sopvop> South, Central, or North ?
22:40:51 <statusfailed> too many shooty places in the world
22:41:05 <popl> Really? I thought we were known for shooty.
22:41:10 * sopvop lives in corrupty place
22:42:03 <popl> I would think my words have an accent, even over IRC.
22:42:21 <popl> sopvop: California, USA, North America
22:43:19 <statusfailed> sopvop: Russia?
22:43:23 <sopvop> yes
22:44:04 <popl> Russians have cool names.
22:44:12 <sopvop> I still can't belive that law forbidding US citizens to adopt Russian kids. Worse than idiotic.
22:44:38 <popl> We have lots of stupid laws.
22:44:48 <popl> sopvop: We have a fence between Mexico and the US.
22:45:22 <popl> sopvop: The fence is too far inland in some places.
22:46:03 <popl> sopvop: http://news.yahoo.com/blogs/lookout/texas-americans-live-wrong-side-border-fence-christmas-183312787.html
22:47:32 <popl> sopvop: Were you going to be adopted?
22:48:51 <ion> popl: I dumped it to a Gist. https://gist.github.com/4351099
22:49:14 <popl> ion: I copy-pasted it to a file :)
22:49:37 <popl> Thank you for formatting it
22:50:11 <sopvop> The thing is, there are about 600k children without parents in Russia. US adopted about 44k since 1999. More than half of them had serious illness. Like downs, cerebral paralisis or hiv. Russians adopt only 10% of sick children.
22:50:22 <ivanm> popl: W...T...F...
22:50:33 <popl> ivanm: what? the article?
22:50:49 <ivanm> yup
22:50:55 <popl> Texas
22:51:30 <ivanm> seriously, the shoved a fence right down people's properties and basically told them "tough shit"?
22:51:52 <popl> eminent domain
22:52:20 <popl> My friend got kicked out of his home many years ago when the city wanted to route the freeway through his house.
22:52:20 <ivanm> @google The Castle
22:52:22 <lambdabot> http://en.wikipedia.org/wiki/The_Castle_(novel)
22:52:22 <lambdabot> Title: The Castle (novel) - Wikipedia, the free encyclopedia
22:52:26 <ivanm> that's not it...
22:52:32 <ivanm> @google The Castle Australia airport
22:52:34 <lambdabot> http://www.imdb.com/title/tt0118826/
22:52:34 <lambdabot> Title: The Castle (1997) - IMDb
22:52:38 <ivanm> ^^
22:53:24 <popl> I think it's not uncommon.
22:53:34 <popl> They have those nail houses in PRC.
22:53:50 <ivanm> well, in that movie the home-owner one :p
22:53:57 <ivanm> s/one/won/
22:54:00 <ivanm> homonym fail
22:54:08 <popl> ivanm: only in the movies
22:54:28 <ivanm> nah, this was based on a true story
22:54:29 <popl> ion: Thanks. I don't understand half of that but I will.
22:55:10 <ivanm> huh, I thought it was, but wiki doesn't say that...
22:55:40 <popl> (I mean the Haskell -- I understand how to do the math)
22:56:09 <popl> (not that it matters)
22:56:22 <popl> I should have given myself the nickname Morla
22:56:34 <popl> :P
22:58:55 <ion> popl: powsMod gives all the powers of ‘a’, mod ‘m’. digits gives all the base-2 digits of an integer starting from the LSB. digits 43 = [1,1,0,1,0,1]. The indexes of ones are equivalent for the powers of ‘a’ that, when multiplied, equal a^42. powMod zips the result of powsMod with the result of digits with (^) and computes the product of the result.
22:59:16 <ion> Hmm, i might as well write that to the Gist.
23:00:14 <aristid> johnw: when i sleep, i can't react to your pings, sorry:P (had forgotten to detach my client so i was mistakenly displayed as online, i guess)
23:00:31 <johnw> you should respond even when sleeping, if you are on the channel ;)
23:13:01 <popl> ion: What sort of degree do you have?
23:13:09 <ion> popl: None
23:13:23 <popl> neat
23:14:38 <popl> ion: You keep your code < 80 columns. I appreciate that.
23:15:09 <popl> I have a huge orange line down the side of my vim window to remind me of the 80 character limit I imposed on myself.
23:17:00 * popl quits babbling
23:17:39 <ion> popl: (Well, a vocational school, but that school wasn’t worth anything, except than the certificate of graduation that let me go to a polytechnic… which i had to drop out of after the first year due to some off-topic things.)
23:18:39 <popl> (off-topic things)--
23:19:04 <ion> @karma things)
23:19:04 <lambdabot> things) has a karma of -1
23:19:50 <popl> things)++
23:19:56 <popl> @karma things)
23:19:56 <lambdabot> things) has a karma of 0
23:20:01 <popl> :(
23:20:06 <popl> @karma popl
23:20:06 <lambdabot> You have a karma of 0
23:20:11 <popl> Oh, ok.
23:20:26 <popl> different bots, different syntax
23:21:54 <monochrom> interesting, ghc '*myfile.hs' works
23:22:06 <monochrom> err, ghci '*myfile.hs'
23:22:17 <popl> ion: Education in .fi is much different than in .us.
23:23:35 <popl> ion: I state obvious things.
23:23:58 <popl> ^ proof
23:24:07 <ion> The meta is over 9000
23:24:46 <popl> I get the reference but I don't find it amusing. I think it's interesting that you do though.
23:25:07 <popl> Not in a bad way.
23:26:07 <zomg> vocational college yeaaaahh
23:26:11 <zomg> I have a useless degree from there as well
23:26:23 <zomg> Thankfully I have so much coding experience I'm hired based on that and not based on my degree
23:26:26 <zomg> :P
23:26:58 <popl> I have virtually no experience other than what I gained at University (I also worked there).
23:27:12 <popl> I'm too old for that.
23:27:50 <zomg> I just did a lot of coding in my free time
23:28:20 <popl> FOSS?
23:28:43 <zomg> Random stuff mostly, but I did contribute a few minor things to some open source things
23:29:24 <popl> I write stuff here and there. Mostly I hang out on IRC and help people with their questions (usually in #perl or ##math).
23:30:30 <zomg> I wrote a lot of stuff to my blog about various web dev things I was working on and such too
23:30:49 <zomg> though probably not very interesting to people here since most of it is unrelated to haskell or such
23:30:54 <popl> I got so burnt out doing web development.
23:31:18 <zomg> I still do that
23:31:18 <wuttf> popl: How come?
23:31:26 <popl> wuttf: PHP
23:31:26 <wuttf> popl: Boredom?
23:31:37 <zomg> haha, PHP is what paid my bills
23:31:42 <wuttf> popl: Ahh, thats a tough one.
23:31:52 <zomg> it's not *that* bad if you have a good team and get to do things the right way rather than just making a mess
23:31:56 <wuttf> zomg: mine too =) I approx got rich doing PHP lol
23:32:03 <wuttf> Long time ago tough
23:32:05 <zomg> Got rich? I didn't :(
23:32:26 <zomg> I was working in a startup for bout two years but they went under and laid me off recently
23:32:37 <zomg> Could've made me rich if it had worked out but didn't
23:32:39 <zomg> Now I'm funemployed
23:32:40 <zomg> =)
23:33:52 <zomg> I picked up Objective-C in about two days and doing a simple iOS game with a friend doing the graphics
23:33:55 <popl> wuttf: I was hired to do web dev but ended up doing system administration too (the manager didn't know how to use OS X). He didn't have any backup system in place for the databases so I had to do that too.
23:34:03 <zomg> Might make a dollar or two with that but probably not that much
23:34:25 <wuttf> Well not permanently rich but I could afford things I couldn't dreamt abou.
23:34:28 <zomg> popl: sounds typical :P
23:34:33 <wuttf> Now crime pays better.
23:34:41 <zomg> haha yeah
23:34:49 <zomg> I guess many would consider me pretty well off too
23:34:56 <popl> I had to secure the web server (I enabled SSL -- student logins were being transmitted in plaintext before that).
23:35:04 <zomg> Many of my friends pay attention to stuff like the price of food they buy
23:35:06 <zomg> I don't
23:35:16 <popl> He had the db passwords sitting in a file in the document root
23:35:17 <zomg> but I'm not really "rich" per-se, I just have some money saved
23:35:51 <popl> I have $40.
23:35:57 <popl> Well, give or take
23:35:58 <wuttf> popl: :D
23:36:00 <zomg> heh
23:36:02 <x-SuriV> POPL: WTF?!
23:36:05 <x-SuriV> ...
23:36:06 <popl> I had to move back in with my dad.
23:36:22 <popl> I have 7 Uni classes left but I don't know if I will finish them.
23:36:24 <popl> Oh well.
23:36:37 <zomg> I don't really spend that much money on stuff like partying so I don't need to worry about money on daily stuff so much
23:36:43 <x-SuriV> 7 classes, so two semesters...your close, dont give up when you are so close to being don
23:36:44 <x-SuriV> e
23:37:17 <popl> x-SuriV: I need a calculus class that I need to take at a JC since I screwed up at Uni. It's probably not going to happen.
23:37:40 <popl> Ugh. Why am I talking about this? off-topic :P
23:37:44 <x-SuriV> oh, calculus kicking your butt?
23:38:21 <wuttf> :D I hated calculus too lol
23:38:28 <popl> I don't hate calculus.
23:38:37 <wuttf> Oh I did
23:38:52 <wuttf> That was the first shit they taught me when I went to CS bsc
23:39:01 <wuttf> I guess what did I expect
23:39:05 <zomg> I don't know if I even studied calculus \o/
23:39:20 <popl> I took mathy CS electives and did well.
23:39:24 <zomg> Looking at the wiki article for calculus it looks about as confusing as all math related wiki pages
23:39:28 <zomg> So probably didn't.
23:39:29 <zomg> =)
23:39:47 <popl> I also took some math electives (for math majors) and did well.
23:39:54 <popl> number theory and combinatorics
23:40:03 <popl> I like math.
23:40:32 <popl> I hate shit professors though and I get irrationally frustrated when I am around them.
23:40:46 <popl> It's my own fault.
23:41:00 <wuttf> This is not working for me http://rosettacode.org/wiki/Hello_world/Web_server#Haskell
23:41:07 <wuttf> (second Haskell example)
23:41:44 <wuttf> please HALP ;)
23:42:25 <popl> wuttf: What do you mean by "not working"?
23:43:02 <wuttf> popl: Minute
23:43:41 <wuttf> popl: I am so dumb. For real. (Forgot to type the portnum)
23:43:50 <zomg> Why not just use warp =)
23:44:05 <x-SuriV> is warp some kind of TCP/IP package?
23:44:08 <popl> It works great here.
23:44:12 <mikeplus64> x-SuriV: it's a web server
23:44:17 <mikeplus64> so i guess so
23:44:30 <wuttf> zomg: Is that any good?
23:44:46 <zomg> Yeah it should be pretty fast and pretty simple to use too
23:44:59 <wuttf> zomg: I do it mainly as a learning excercise
23:45:43 <zomg> Ah okay :)
23:45:44 <wuttf> Finally I made the transition from tabs to spaces just for the sake of Haskell. I feel raped.
23:46:15 <x-SuriV> wuttf It will save you alot of trouble, Haskell is a Nazi when it comes to spacing :P
23:46:16 <johnw> tabs are something from the 1970s
23:46:21 <johnw> i don't know why people use them
23:46:29 <johnw> @quote tabs
23:46:30 <lambdabot> No quotes match. There are some things that I just don't know.
23:47:08 <ofan> @quote tab
23:47:08 <lambdabot> mwc says: I'm thinking we should file a bug report and require ghc to produce executables that sound like famous classical pieces
23:47:33 <wuttf> x-SuriV: Yea haskell kept throwing errors at me and I realized it was because my indentation sucked
23:48:03 <wuttf> I like that bug report.
23:49:30 <mikeplus64> wuttf: well, so long as you see tabs as 8 spaces in your editor, everything is fine
23:49:52 <wuttf> mikeplus64: It was 4 spaces
23:51:18 <wuttf> Maybe its my machine but I tried 3 haskell web server examples, and they barely work. If I press f5 fast, every second request fails to produce respond
23:51:49 <zomg> Weird
23:52:18 <zomg> Try this: main = run 8010 (\_ -> return $ responseLBS status200 [] "Hi!")
23:52:42 <zomg> Needs Network.Wai, Network.Wai.Handler.Warp and Network.HTTP.Types
23:52:45 <zomg> and OverloadedStrings
23:53:45 <johnw> edwardk: does Trifecta have a "debug mode" where it shows me everything it's trying to do?
23:59:05 <wuttf> zomg: I run them from GHCi, may the be a problem (double click on .hs file then runnin main by hand)
23:59:17 <wuttf> may that be*
23:59:43 <zomg> Could be, try using runhaskell or compiling and see if that makes any difference
