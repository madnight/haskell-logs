00:04:58 <wuttf> zomg: Same problem
00:05:03 <wuttf> I compiled :S
00:05:12 <mikeplus64> wuttf: try with ghc -O2 -threaded
00:05:40 <mikeplus64> -rtsopts if you want more threads, and then run with ./whatever +RTS -N(number of threads you want)
00:06:58 <wuttf> Same. I am pretty sure its my machine. I start a Go hello world web server too
00:09:01 <statusfailed> wuttf: and you get the same issue?
00:09:15 <wuttf> statusfailed: Checking now
00:09:17 <wuttf> Minute
00:10:14 <wuttf> No, Go web server works as expected
00:10:22 <wuttf> Never failing to respond. Wtf.
00:10:33 <wuttf> It's not my system then I think.
00:13:42 <wuttf> I don't measured with ab or httperf but if I am tapping on f5 with approx 2Hz freq every second response is getting dropped.
00:13:54 <statusfailed> wuttf: Perhaps try using curl in a loop to get a better look at what's going on?
00:13:56 <Twisol> Given a typeclass that declares some additional monadic actions, is it possible to define a generic MonadTrans instance that automatically lifts these actions no matter what transformers are in use?
00:15:01 <wuttf> statusfailed: Naa, I wont spend more time investigating this now. I guess it is nothign which can't be solved.
00:17:26 <wuttf> BTW I think its related to HTTP headers.
00:22:08 * hackagebot direct-sqlite 2.3.1 - Low-level binding to SQLite3. Includes UTF8 and BLOB support.  http://hackage.haskell.org/package/direct-sqlite-2.3.1 (IreneKnapp)
00:22:30 <wuttf> I am on Win 7 btw, did I say? Its my dev machine, deployment will be on Ubuntu
00:38:38 <mikeplus64> wuttf: iirc ghc's windows rts lightweight threads aren't so "lightweight" as they are on linux
00:40:21 <wuttf> mikeplus64: Yes, I changed my opinion, it is most probably a sync/timing/threading or related issue. Problem is then I have to live with the drops while developing on Windows.
00:41:34 <wuttf> Most of the time the Haskell web server responds in 10-15 mics but sometimes after approx 90 ms I get 103::Connection aborted error
00:41:47 <wuttf> In chrome, Opera
00:42:50 <wuttf> mikeplus64: It is almost like the connection is closed before sending any response
00:43:01 <mikeplus64> i guess most of the performance people are sleeping atm
00:43:02 <wuttf> Does someone see any problems with this code?
00:43:03 <wuttf> http://rosettacode.org/wiki/Hello_world/Web_server#Haskell
00:43:13 <wuttf> Second example
00:43:54 <Twisol> wuttf: Are you unable to run Ubuntu in a VM?
00:44:54 <wuttf> Twisol: I am able but I don't want to :D
00:45:01 <Twisol> wuttf: fair enough!
00:45:41 <wuttf> Twisol: Should I? Is the situation that bad on Win?
00:46:58 <Twisol> wuttf: I'm not familiar with Haskell's situation on Windows, but programs - especially big ones - usually run much better on their "home platform"
00:47:20 <Twisol> wuttf: besides, you said you deploy to Ubuntu. I'd make the switch if only to bring my dev machine in line with the expected environment.
00:47:59 <ciphergoth> I thought if I did "import Data.Set as Set" I'd avoid name clashes, but I'm still getting " Ambiguous occurrence `map'"
00:48:20 <Twisol> ciphergoth: You need to use the qualified keyword
00:48:21 <elliott> "import qualified Data.Set as Set"
00:48:22 <ciphergoth> I shouldn't have to write Prelude.map everywhere should I?
00:48:24 <ciphergoth> aha!
00:48:27 <elliott> it's dumb & we're sorry
00:48:34 <elliott> "import Foo as Bar" imports Foo wholesale. but it also aliases it as Bar
00:48:53 <ciphergoth> Twisol, elliott: the wrong advice is eg at the top of this: http://cvs.haskell.org/Hugs/pages/libraries/base/Data-Set.html
00:49:07 <Twisol> that looks like an old page
00:49:09 <wuttf> Twisol: I like to excercise my code with the context switch :-D. Seriously. Any non cross platform hard coded bussiness will stand out
00:49:13 <Twisol> did you find it via google?
00:49:21 <ciphergoth> Twisol, I did
00:49:35 <ciphergoth> the cvs in the URL is a clue...
00:49:35 <Twisol> ciphergoth: you get used to Google doing that… http://hackage.haskell.org/packages/archive/containers/latest/doc/html/Data-Set.html
00:49:35 <elliott> ciphergoth: yeah, uh, don't use that page
00:49:39 <ciphergoth> OK
00:49:45 <Twisol> ciphergoth: try Hoogle next time. http://www.haskell.org/hoogle/
00:49:59 <Twisol> Google doesn't index Haskell docs very pleasantly.
00:50:09 <ciphergoth> and that has the right info, thanks!
00:50:20 <ciphergoth> Google has a problem in general with preferring old docs, I've noticed
00:50:23 <ciphergoth> not just for Haskell
00:50:33 <Twisol> Yeah. Pretty much.
00:50:44 <Twisol> Wonder if DuckDuckGo has it any better...
00:51:07 <Twisol> yes, yes it does
00:51:16 <popl> ddg is awesome
00:51:29 <popl> perl!
00:51:30 <popl> :)
00:51:59 <popl> it's my search engine of choice
00:52:01 <Twisol> playing with it, DDG seems to index the /latest URLs preferentially
00:52:08 <Twisol> so… yeah. Hoogle or DDG.
00:54:56 <ciphergoth> OK will try ddg also - thanks!
00:55:09 <edwardk> johnw: i am
00:58:04 <johnw> oh, forgot what i was going to ask you
00:58:06 <johnw> cheers
01:19:23 <johnw> now I'm having <EOF> issues
01:22:10 <wuttf> Twisol, if I remove the `finally` sClose c part from the webserver, the problem disappears. Seems like it closed the connection prematurely. Why can be that?  (code here: http://rosettacode.org/wiki/Hello_world/Web_server#Haskell  second example)
01:24:02 <Twisol> wuttf: I'm a beginner myself, but I would suspect that some error is being thrown that finally is reacting to.
01:24:07 <johnw> edwardk: does "position" not like being called at EOF?
01:24:25 * AfC is using the ghci debugger for the first time.
01:24:25 <Twisol> wuttf: although that doesn't make sense, heh, so… I don't know. :)
01:24:38 <wuttf> Twisol: I am a newbie too lol =)
01:24:47 <wuttf> As you can tell.
01:24:58 <Twisol> *shrug*
01:26:35 <Twisol> wuttf: think you can replace that finally with a bracket though
01:26:39 <edwardk> johnw: it shouldn't care but the cursor will probably be on the blank line
01:27:27 <Twisol> wuttf: can't imagine a simple refactoring would affect the problem though
01:28:15 <wuttf> Twisol: I don't know yet mate but I will figure it out no matter the cost lol.
01:30:40 <johnw> meh
01:30:55 <johnw> after restarting ghci the parser's behavior has completely changed
01:31:36 <johnw> ah, n/m
01:37:29 <Twisol> wuttf: FWIW, I get connection interrupted issues when I load the page too.
01:38:57 <wuttf> Twisol: Delete the finally close business and the problem will go away, I am trying to wrap around the problem why it works this way but ATM I cant even read Haskell properly so I struggle
01:41:06 <mm_freak_> suspen[ds][ai]ble?
01:41:14 <wisut> ls
01:41:45 <Twisol> wuttf: hard to reproduce sometimes, feels like a race condition
01:41:55 <Twisol> wuttf: wouldn't be surprised if forkIO had something to do with it as well
01:42:10 <mm_freak_> could anyone help a non-native english speaker write his package description? =)
01:42:10 <johnw> edwardk: i don't need to return (Value,Delta), I can use your stepParser logic
01:42:55 <wuttf> Twisol: Yes, well as a first introduction to Haskell IO this experience is not too pleasant :D
01:44:01 <mreh> am I being stupid? This won't compile updateUsername http://hpaste.org/79612
01:44:14 <mreh> not sure if you saw that earlier, I disconnected immediately after I typed it
01:44:41 <Twisol> mreh: looks like you cut out a section of a file but didn't change the line numbers in the error for us. :)
01:44:51 <mreh> Twisol: correct
01:45:24 <mreh> Twisol: that's more accurate
01:45:42 <Twisol> tyvm
01:46:56 <mm_freak_> > > fmap ((++ "ble") . ("suspen" ++)) . sequence $ ["ds", "ai"]
01:46:57 <lambdabot>   <hint>:1:1: parse error on input `>'
01:47:01 <mm_freak_> > fmap ((++ "ble") . ("suspen" ++)) . sequence $ ["ds", "ai"]
01:47:03 <lambdabot>   ["suspendable","suspendible","suspensable","suspensible"]
01:47:07 <mm_freak_> which one is it?
01:47:35 <edwardk> johnw: sure
01:47:42 <Twisol> mm_freak_: the first looks right to me
01:47:56 <mm_freak_> thanks
01:48:03 <edwardk> trifecta has lots of rough edges but its pretty straightforward once you get past all the scary bits
01:48:07 <Twisol> able-to-suspend
01:48:13 <johnw> i'm still in the haunted house just yet
01:48:52 <fmap> mreh: `Endo (Arguments -> Arguments)' is `(Arguments -> Arguments) -> (Arguments -> Arguments)'
01:48:53 <johnw> my stepParser result value goes into an infinite loop when I case analyze it
01:48:58 <mm_freak_> Twisol: that's actually a nice mnemonic, thanks for that
01:49:04 <Twisol> mm_freak_: No problem
01:49:17 <hpaste> johnw pasted “stepParser.hs” at http://hpaste.org/79614
01:49:19 <mm_freak_> it's funny how expressing my problem as a haskell program suddenly yields answers =)
01:49:19 <mreh> fmap: aaaah
01:49:22 <johnw> ^-- does that look about right?
01:49:34 <Twisol> :P
01:50:14 <mm_freak_> but i could have written this nicer
01:50:19 <mm_freak_> > sequence . words $ "s u s p e n ds ai b l e"
01:50:21 <lambdabot>   ["suspendable","suspendible","suspensable","suspensible"]
01:50:30 <edwardk> johnw: i only vaguely remember what trifecta looks like right now ;)
01:52:41 <hpaste> johnw pasted “lazyParser.hs” at http://hpaste.org/79615
01:52:44 <johnw> ok, i've abstracted it
01:52:57 <johnw> trying to make a "lazyParser" function for Trifecta, to turn any foo into a lazy "some foo"
01:53:10 <johnw> but it's infinite looping on the first "casE"
01:53:41 <edwardk> that sounds dangerous witht he internal CPSing
01:53:48 <edwardk> but i haven't thought that through
01:54:01 <johnw> i can't even "show" the Step a value
01:54:10 <johnw> (trying: trace (show step) step)
01:54:28 <johnw> guess i'll have to start putting debug code in trifecta itself
01:54:37 <edwardk> i have faith ;)
01:54:42 <johnw> heh
01:55:23 <Adnauseam> hax0rs
01:55:30 <Twisol> well that's foreboding
01:56:42 <x-SuriV> 2012!
01:57:44 <hpaste> mapf pasted “dual reducers” at http://hpaste.org/79617
01:57:50 <mm_freak_> why is (Ord k) => Map k not a zipping applicative functor?
01:58:21 <mapf> are reducers lack of that? or at least i can't find
01:58:21 <mm_freak_> M.intersectionWith ($)
01:58:40 <mm_freak_> ah, i know
01:58:59 <mm_freak_> forget it =)
02:00:09 <elliott> mm_freak_: you can do it if you stick on a pure
02:00:15 <elliott> representing the map of everything to x
02:00:28 <mm_freak_> elliott: yeah, but Map can't handle that
02:00:35 <mm_freak_> you would have to write a wrapper type
02:00:59 <elliott> sure
02:02:30 <hpaste> sopvop pasted “Which way of getting info from type you prefer” at http://hpaste.org/79618
02:02:48 <sopvop> So, style question ^
02:05:09 <mm_freak_> sopvop: what about Typeable?
02:05:44 <mm_freak_> > typeOf (id :: Double -> Double)
02:05:46 <lambdabot>   Double -> Double
02:06:02 <sopvop> It's not about info about Types as types, but info from type
02:06:16 <mm_freak_> what kind of info?
02:06:20 <sopvop> like table name from record or schema
02:06:52 <mm_freak_> do you want to have this information living on the type level?
02:06:58 <mreh> :i (*>)
02:07:20 <sopvop> yes, so I can get it without having a value
02:07:29 <mm_freak_> sopvop: then see the reflection library
02:09:02 <sopvop> Guess who is among authors and is maintainer of reflection...
02:09:09 <mm_freak_> sure =)
02:09:14 <mm_freak_> tableName :: (t `Reifies` String) => c t a -> String
02:09:29 <mm_freak_> 'c' could be Column, Row, …
02:09:49 <mm_freak_> to make this more type-safe:  (t `Reifies` TableName) => c t a -> String
02:09:55 <mm_freak_> newtype TableName = TableName String
02:10:50 <sopvop> what is c?
02:11:02 <mm_freak_> anything you want…  it's fully polymorphic
02:11:18 <mm_freak_> so any c that has a table name attached can produce a table name
02:11:28 <mm_freak_> Column, Row, TableInfo, …
02:11:29 <edwardk> mapf: if its missing its probably an oversight. send me a patch
02:11:48 <sopvop> Get it
02:11:51 <sopvop> that is nice
02:12:04 <mm_freak_> sopvop: as a hint, because many people get this wrong, you never write instances for the Reifies class =)
02:12:16 <mm_freak_> you use 'reify' instead
02:12:21 <edwardk> mm_freak_: well, most of the time you don't ;)
02:12:29 <edwardk> i break that rule occasionally =P
02:12:48 <mm_freak_> really?  i haven't seen a need to break it so far
02:13:10 <mm_freak_> because architecturally it makes no sense to write Reifies instances
02:13:19 <edwardk> mm_freak_: its kind of nice to be able to lift known values without quantifiers some times
02:13:51 <mm_freak_> edwardk: i get that, but then it isn't really reification anyway…  i write other classes in those cases
02:13:53 <edwardk> data Foo; instance Reifies Foo Foo where reflect _ = Foo
02:14:07 <edwardk> mm_freak_: yes, but then you can just use the same parameter for 'Foo' or somethig lifted with 'reify'
02:14:30 <edwardk> data Bar; instance Reifies Bar Bar where reflect _ = Bar
02:14:33 <edwardk> data Baz = Foo | Bar
02:14:53 <edwardk> then you can reify Foo (…)
02:15:03 <mm_freak_> edwardk: except that now you have two worlds:  the higher rank quantified world and the rank-1 world…  they aren't really related
02:15:06 <edwardk> or just work with (Blah Foo)
02:15:09 <mm_freak_> i think of type classes as something global
02:15:22 <mm_freak_> global as in world-wide
02:15:32 <sopvop> any example of reify, I still don't quite get it
02:15:35 <sopvop> ?
02:15:39 <edwardk> mm_freak_: sure. but i often have a finite subset of these that i don't need to invert my thinking to work with
02:15:58 <mm_freak_> sopvop: reify x (\(_ :: Proxy x) -> …)
02:16:15 <mm_freak_> sopvop: now the /type/ x represents the value x, and you can use 'reflect' to get it back
02:16:36 <edwardk> https://github.com/ekmett/rounded/blob/master/src/Numeric/Rounded/Precision.hs#L41 acts a lot like Reifies for precisions
02:16:41 <edwardk> it even uses it for a subset of the instances
02:17:03 <edwardk> but it can also be very useful to just say
02:17:12 <edwardk> pi :: Rounded TowardZero 512
02:17:20 <edwardk> rather than reifyPrecision 512 $ ...
02:17:28 <frerich> Hrm, I'm always having a good time when working with Yesod, at least until I realize that in order for the web page to be *somewhat* attractive/useful I have to start serving HTML/javaScript/CSS :-[
02:17:55 <edwardk> these two worlds are often very similar and sometimes i can reify a small enough universe by hand that its worth doing because it gets you out of the rigorously nested scopes that get foisted on you by reflection
02:17:59 <mikeplus64> that's always a bummer doing web dev; realising that you're doing web dev
02:18:37 <mm_freak_> frerich: people are working to make web dev more convenient…  in fact i'm doing that just right now =)
02:18:37 <t7> use some kinda latex to html thing
02:18:54 <mm_freak_> you seriously think that latex is an improvement over HTML?
02:19:18 <mikeplus64> i think so, but they do different things
02:19:44 <mm_freak_> well, for one thing latex is turing-complete, for the other it's a very ugly language
02:19:55 <frerich> t7: In my case I'd like to have some sort of convenient calendar control which lets me create "events" and drag them around and stuff, so I need to do plenty of event handling client-side. LaTeX won't really help. :-}
02:20:13 <mm_freak_> frerich: see jQuery Mobile
02:20:20 <mm_freak_> it helps a lot with this stuff
02:20:24 <frerich> t7: And this JavaScript/CSS/HTML div-and-span stuff is taking so much time. :-(
02:20:28 <mm_freak_> (and yes, it works for non-mobile devices, too) =)
02:20:48 <frerich> mm_freak: Hmm, I did look at jQuery already but let me check again (for some reason I decided not to use any of the existing calendar controls I found)
02:20:57 <mm_freak_> frerich: jQuery Mobile
02:21:29 <frerich> mm_freak_: Looking at the web page, " Its lightweight code is built with progressive enhancement". The EXCITEMENT!! :-)
02:22:00 <mm_freak_> it's a real UI framework unlike jQuery UI which just gives you a bunch of widgets
02:22:40 <mm_freak_> it's still ugly imperative, but it's an improvement over manual javascripting these things
02:22:56 <t7> i guess you could make a site as an SVG thing :)
02:22:58 <frerich> mm_freak_: hm interesting, I wasn't aware of that. Thanks for pointing it out, I always thought it's some sort of trimmed jQuery :-}
02:23:13 <mikeplus64> mm_freak_: now that you've piqued my interest, how are you working to make web dev more convenient?
02:23:38 <mm_freak_> frerich: no, it actually needs jQuery as well, so it's actually larger =)
02:23:49 <mm_freak_> "mobile" doesn't mean "smaller" anymore these days =)
02:24:05 <mm_freak_> since even the cheapest smartphones have gigahertz processors now =)
02:24:25 <mm_freak_> mikeplus64: server-side…  i'm implementing a real library based on a proof of concept code i wrote
02:24:45 <mm_freak_> mikeplus64: http://hpaste.org/79601
02:24:58 <mm_freak_> see 'main' and the example interaction on the bottom
02:25:19 <fmap> edwardk: Constraint.hs in reflection/examples is nice
02:25:43 <fmap> it's probably the first time I am more confused *after* seeing an example of something
02:25:48 <edwardk> fmap: hahahaha
02:25:55 <edwardk> fmap: its a pretty tough example =)
02:26:08 <edwardk> its lets take two scarily complicated libraries and smash them together!
02:27:08 <edwardk> i don't even remember why i needed it in the first place
02:27:14 <edwardk> but it came up in some 'real world' code of mine
02:27:24 <mikeplus64> mm_freak_: cool, is the "mainLoop" thing going to be replaced with e.g. something for a web server or what?
02:27:49 <mm_freak_> mikeplus64: exactly
02:28:04 <edwardk> fmap: anyways Constraints basically generalizes the Monoid example once and for all
02:28:09 <mm_freak_> mikeplus64: the goal is:  write one code, produce many interfaces, including command line, web, telnet, etc., if you wish
02:28:18 <mikeplus64> good idea
02:28:24 <edwardk> fmap: it lets you ball up pretty much any dictionary in a way that you can unpack it and use it in a custom type
02:28:43 <mm_freak_> mikeplus64: working on it right now…  when the library is on hackage i will write a layer on top of snap
02:29:21 <mm_freak_> no more explicit form post handling…  requesting form data from the user essentially becomes something similar to "getLine" =)
02:29:56 <edwardk> fmap: the coercion of constraints is based on what i do in Data.Constraint.Unsafe. i blogged about how that works in a couple of posts on constraint kinds
02:30:01 <mikeplus64> mm_freak_: maybe you could make like a html "console" so that you can use the command line interface online
02:30:14 <mikeplus64> i'm not sure how a "HttpApp" would look
02:30:42 <mm_freak_> mikeplus64: i can make an AJAX interface…  the command line interface in the web server is not the responsibility of this library
02:31:12 <mm_freak_> also the App in the library is going to be different…  it's a generalized version of that proof of concept App
02:31:32 <mm_freak_> newtype Continue e f m a = Continue { runContinue :: m (Either e a, f (Continue e f m a)) }
02:31:38 <mm_freak_> that's my current version
02:31:45 <mm_freak_> but it's not final
02:33:07 <mm_freak_> and yes, it's related to free monads, but not quite free =)
02:33:19 <mm_freak_> Continue is to FreeT what (,) is to Either
02:34:44 <johnw> as product is to coproduct?
02:35:14 <mm_freak_> johnw: surprisingly yes
02:35:58 <edwardk> CofreeT ?
02:36:35 <edwardk> oh with the m smashed in
02:36:42 <edwardk> neil ghani had a name for that
02:36:47 <edwardk> i forgot it
02:36:48 <mm_freak_> actually yes, except that CofreeT doesn't have the Either
02:37:02 <edwardk> oh the Either is weird
02:37:04 <edwardk> nm
02:37:14 <mm_freak_> it's weird-usful
02:37:14 <edwardk> you're on your own =)
02:37:31 <wuttf> Is there a typeOf function or something?
02:37:43 <wuttf> I know in GHCi I can type :t
02:37:43 <mm_freak_> > typeOf (sin :: Double -> Double)
02:37:44 <lambdabot>   Double -> Double
02:37:51 <mm_freak_> wuttf: Data.Typeable
02:38:06 <wuttf> mm_freak_: Ty
02:39:10 <mikeplus64> wuttf: typeOf is different to ghci's :t though -- it only works on non-polymorphic types
02:39:15 <mikeplus64> > typeOf id
02:39:16 <wuttf> If I print to console from multiple threads the content will be outputted interlaced?
02:39:17 <lambdabot>   Ambiguous type variable `a0' in the constraint:
02:39:17 <lambdabot>    (Data.Typeable.Internal....
02:39:23 <mm_freak_> wuttf: if you think you need it, there is a 99% chance that you're wrong =)
02:39:34 <mm_freak_> wuttf: not if you have a printer thread
02:39:43 <wuttf> mm_freak_: I just want to see it for learning purposes.
02:39:53 <mm_freak_> wuttf: forkIO . forever $ takeMVar msgVar >>= putStrLn
02:40:03 <mm_freak_> then use putMVar instead of putStrLn
02:40:11 <mm_freak_> putMVar msgVar that is
02:40:19 <wuttf> Thank you.
02:44:21 <mm_freak_> edwardk: i wonder if there is a categorical term for my monad transformer
02:45:02 <mm_freak_> "Continue" is pragmatic, but can be confused with Coroutine, which is essentially FreeT
02:52:11 * hackagebot spy 0.6 - A compact file system watcher for Mac OS X, Linux and Windows  http://hackage.haskell.org/package/spy-0.6 (StefanSaasen)
03:06:39 <sopvop> I still don't get that reflection thing :(
03:08:10 <wuttf> How can I parse HTTP headers?
03:08:26 <wuttf> Which is the goto package for that?
03:08:57 <johnw> http-conduit?
03:08:58 <statusfailed> wuttf: HTTP-4000 I think?
03:09:01 <statusfailed> oh
03:09:08 <johnw> or yeah, HTTP
03:09:27 <wuttf> Im checking it out.
03:11:55 <fmap> sopvop: that's not necessarily a ":("
03:17:14 <tumdum> hi, I need to be able to download revisions (every changed file) from svn using haskell - is it possible today? HsSvn (http://hackage.haskell.org/package/HsSVN) doesn't look like it can do what I need :/
03:18:06 <johnw> tumdum: can you be a bit more specific?
03:18:14 <johnw> because I have something that could help you
03:19:34 <tumdum> well, I want to get log from given time frame, and then download for each revision every file which was modified in that revision.
03:20:00 <johnw> are you familiar with Subversion dump files?
03:20:09 <johnw> because that format is almost exactly what you describe
03:20:15 <tumdum> not really
03:20:17 <johnw> and I have a Haskell library for parsing said dump files
03:20:31 <johnw> "svnadmin dump"
03:20:41 <johnw> and http://hackage.haskell.org/package/svndump
03:21:27 <tumdum> I need to connect to svn server using haskell
03:21:47 <johnw> with dump files, you do that as a separate process
03:21:49 <johnw> then read the dump file
03:21:53 <johnw> why do you need to read it from Haskell?
03:22:01 <johnw> you can also read it from Haskell as stdin
03:29:05 <johnw> edwardk: what's the difference between StepDone and StepCont?
03:29:58 <edwardk> StepDone !Rope !(Seq (Diagnostic e)) a  -- is a final answer. feeding it more rope won't change the answer
03:29:59 <AfC> tumdum: you could always import it from Subvision to Bazaar or Git and then work with it from there.
03:30:07 <johnw> ah, has to do with this It type?
03:30:17 <edwardk> StepCont !Rope (Result e a) (Rope -> Step e a)   is able to consume more rope
03:30:22 <johnw> ah
03:30:43 <edwardk> if you _don't_ have any more rope to feed it, then the Result is effectively either 'done' or 'failed' at this point
03:30:57 <johnw> i have more rope
03:31:00 <tumdum> AfC, i just want to have something like pysvn but in haskell ;)
03:31:19 <johnw> so I just feed it?
03:31:23 <edwardk> then you feed it to StepCont by concatenating it with the rope thats already there i think and feed it to the function
03:31:33 <johnw> but I don't have a StepCont
03:31:39 <edwardk> you have StepDone?
03:31:42 <johnw> yes
03:31:52 <johnw> because i'm parsing lazily, so it complese after each term
03:31:57 <edwardk> then your parser has said 'no thanks, i'm good'
03:32:03 <edwardk> and won't eat any more
03:32:05 <johnw> and I want to say, "Oh no you're not"
03:32:12 <johnw> "parse again, with this next piece"
03:32:13 <edwardk> hen you have to write your parser differently ;)
03:32:24 <johnw> ok, I have a parser that yields an a
03:32:37 <johnw> i want to write a function that yields a [a] by repeatedly parsing the input until there is no more left
03:32:47 <johnw> this is pretty easy to do with Parsec
03:32:53 <edwardk> why do you need this to be lazy?
03:33:13 <johnw> because I want to process the terms in the file as they are encountered, rather than waiting until everything has been parsed
03:33:15 <edwardk> and why doesn't 'many' just do it?
03:33:19 <edwardk> ah
03:33:42 <edwardk> i have to admit, the stock prim parser in trifecta isn't really designed for that usecase
03:33:50 <edwardk> because its going to hold the entire rope for the entire file anyways
03:33:56 <johnw> hmm
03:33:59 <edwardk> so building up the data structure off of it isn't a big difference
03:34:16 <johnw> i guess I can just fire up another parse on the rope that StepDone hands up?
03:34:17 <edwardk> this is why i wanted to add a streaming parser to trifecta
03:34:20 <johnw> hands me
03:34:27 <johnw> yeah, a conduit parser would be nice
03:34:43 <edwardk> johnw: you'd need to trim the part of the rope the first guy ate, and track the relative starting delta
03:34:59 <edwardk> otherwise you'll still hold onto all the rope
03:35:02 <edwardk> its going to be a hacky mess
03:35:14 <johnw> ok
03:37:08 <edwardk> you are well into unsupported usecase territory ;)
03:37:19 <johnw> meh!
03:37:28 <edwardk> another option might be to start working on the 0.90 master of trifecta
03:37:35 <johnw> that is what I'm doing
03:37:36 <edwardk> and see if you can write a custom parser that does streaming
03:37:44 <edwardk> it should be pretty straightforward
03:38:00 <edwardk> just don't hold onto all the rope, and don't isntantiate the trifecta class that lets you seek
03:38:06 <edwardk> don't even build a rope
03:38:06 <johnw> is that using It?
03:38:14 <edwardk> you would give up 'It'
03:38:25 <shachaf> It is a profunctor!
03:38:29 <edwardk> and work more like parsec or attoparsec
03:38:43 <edwardk> then just instantiate the right classes from 'parsers'
03:39:00 <edwardk> if you get something working, i'll pitch in and help clean it up
03:39:41 <johnw> when you said "you would give up 'It'", you meant that using It would be the right interface, yeah?
03:43:54 <johnw> well, i'm past my EOF problem and the parser is working well with just m [a]
03:43:57 <johnw> i'll add the streaming later
03:44:18 <edwardk> no, i mean that for streaming 'It' is totally the wrong interface
03:44:22 <johnw> ah, ok
03:44:25 <johnw> what is the right interface?
03:44:36 <edwardk> 'It' is for something you grow monotonically adding more and more information, its 'half an iteratee'
03:44:37 <elemir> Hem. Guys, is there any implementation of mixml modules for haskell?
03:44:57 <edwardk> you eventualy just stop feeding It and take the last answer it gave
03:45:09 <edwardk> but you always have to keep everything in the history to feed It.
03:45:15 <edwardk> because it can seek, etc.
03:45:20 <edwardk> this kinda sucks for streaming
03:45:58 <johnw> where do you recommend starting?
03:46:04 <edwardk> if you look at the code in Prim that _doesn't_ deal with It, its pretty close to what you'd need, except you just need to be able to ask some base monad for another chunk
03:46:13 <johnw> ah, ok
03:46:19 <johnw> that sounds simple enough
03:46:21 <edwardk> but unlike It you don't 'seek' to other chunks
03:46:37 <edwardk> you can just get the next one
03:46:49 <edwardk> there are some tricky backtracking cases, but its overall pretty straightforward
03:47:09 <johnw> oh, when you said before that I could just saving position information along with my data structures
03:47:16 <johnw> you meant the result of `position'?
03:47:21 <johnw> or something even more elaborate?
03:48:23 <johnw> i guess: do I want a Delta, or a Rendering?
03:48:34 <johnw> i guess I can produce a rendering later
03:48:54 <shachaf> johnw: Does one of them have kind * -> * -> *, with one covariant and one contravariant argument?
03:48:59 <shachaf> If so, you want that one.
03:49:10 <johnw> are you trolling?
03:49:41 <johnw> Rendering and Delta have kind *
03:50:22 <shachaf> I have no context.
03:50:30 <shachaf> I just like profunctors.
03:50:47 <Saizan> aww
03:50:47 <statusfailed> so it's the "is shachaf interested" test? :D
03:51:10 <shachaf> Does category theory have a "costrong monoidal functor" or something?
03:51:33 <statusfailed> is that the category theory equivalent of "does a bear shit in the woods"? because I didn't understand it at all
03:51:53 <shachaf> No, I'm wondering if it exists.
03:51:58 <shachaf> I want the covariant part to be costrong.
03:52:06 <shachaf> I don't really know what all these words mean.
03:52:10 <shachaf> I just want the answer. :-(
03:56:10 <statusfailed> shachaf: woah, I found a googlewhack- "ncatlab costrong"
03:57:09 <statusfailed> shachaf: I can't open it, but does this have anything helpful? www.math.mcgill.ca/rags/bang/bang.ps.gz
03:59:50 <hpc> statusfailed: technically two results :D
04:00:05 <statusfailed> hpc: bah! :D
04:00:28 <statusfailed> well it looks like page 15 of that document is relevant anyway
04:06:22 <edwardk> back
04:07:00 <edwardk> i sprinkle one little profunctor in the lens code and all of a sudden its profunctors all the way down
04:07:20 <edwardk> johnw: you can use position, but 'rend' is better
04:07:26 <edwardk> not sure what its called in 0.90
04:08:13 <shachaf> edwardk: You didn't sprinkle it just anywhere!
04:08:19 <shachaf> You put it in Algebraic.
04:08:22 <shachaf> What can you expect?
04:08:24 <edwardk> hahaha
04:08:39 <edwardk> it was the poison pill that seems to have killed algebraic, so its done its job ;)
04:08:51 <johnw> edwardk: rendering?
04:09:03 <johnw> rendering :: Source s => Delta -> s -> Rendering
04:09:23 <johnw> position is pretty good, since I can summon the rendering later if needed
04:10:11 <edwardk> johnw: only while you're still parsing
04:10:25 <edwardk> and only if you can _seek_
04:10:29 <edwardk> which you are giving up
04:10:45 <edwardk> rendering captures the current line fragment at that time
04:10:49 <johnw> aha
04:11:05 <edwardk> er
04:11:06 <edwardk> 'rend'
04:11:51 <Froggo> Huck tah licka chicha froggo plains
04:11:57 <Froggo> Moistie bather.  riberian schmecklef  Mulla Malee loo lup the new flood wars.  Chuddy dip, chuddy dip, chuddy microchip.  Bucka lucka loo, bucky lucky blay.  Bucka lucky blay lee.
04:11:59 <Froggo> Burpaline: The wonder world.  Salmy magoo goal greggats  Rump duh duh duh dump, duh duh duh demp doop dump, runna nuh nah  Riggity ass gaggags  i nick  Roddan raldwell  Roady carewell reggal mahole  Rup tup shmelly smelly shmebb ub.  Roady farewell rose bose mahaggal.  A pocahontas watch
04:12:02 <Froggo> Blubbity ash hoosh her mellopath.  a Maticake for my buddy andy  Oh we-heh-heh-hell I'm thinking about the greg nargs, I'm thinkin about you!  End midal too walkin' with a dolphin.  I went up that street, you went up another street, we all up the presidio.  I'm goin out with arsenio!
04:12:04 <Froggo> fuckin bone screllalidge moink.  ruggity fucker fagger. rum dum dacka lacka rum dum jay  Go out with jay, another blue jay we fixed my astercoil plather  I'm hickin' my dagger  Rum dickily toon witherspoons.  I'm a falcons baleiva work with the yake my 7'9'er forever tumchy tither
04:12:06 <Froggo> i wrote my life story on my poop pad.  one of the greatest art exhibits of 1999 was in a new york museum of art.  In it, cow poop or fecal matter was put on a copy of the painting called "The Last Supper".  This was thought to be a form of modern art.  chumpin up the rears.  Rubb blillick bath.
04:12:08 <Froggo> The shiny dot in the middle of the light blue circle or ring is glowing silver in color like steel or real silver.  Eating pings, eating pies, Snow quibbicker bather I'm a niner!  That's right I'M A NINER!  Dipoke when we dip oh blip we dip, chucka hand oh blip we dip.  yxoukcil polk jhaggel.
04:12:10 <Froggo> Whether muh luck lick whither spoons.  wups to the umpteenth hicka low daggal.  cckocket tlopres redda ropres HUCK DICKILI DOON!  Feelie wheelie whilla maluck lick.  Slimy boo beggats.  I'm saggat I'm zeggat ziggurats.  Poop is pee.  My name is Mr. Pochahantas.  I'm a cartoon or movie character.
04:12:12 <Froggo> They put me on a watch today, sometimes I pee sometimes I'm James!  Whoodas pratts my nig names chats.  Challa-hoe banchee with a proodas made.  I'm chilly I'm child ugly daves don't go wild.  My wild, ugly boss suddenly became thin  frint glint chip.  chip chip microchip.  chip chip microchip!
04:12:14 <Froggo> My little greg narg, My little greg narg, I have freedom of speech rights!  My little greg narg, my little greg narg, you wish I didn't have rights!
04:12:15 <typoclass> @where ops
04:12:15 <lambdabot> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
04:12:16 <Froggo> Nockaragathan dick slam!  Chilly chilla choe-lal-lip!  Scuh loo lathian buck seats  Moan mlutha mah-lee black mam.  rudda doo din-ump dah doo-nah-nah
04:12:16 <Froggo> Waar chawecka wipth wella jalipth  All kinds of |\|iggers and buffy-oh juice!  I'm bagging ack the hag.  Ran a plucky plunky item plains!  Bagging the nig nag.  Bagging like green grags.
04:12:19 <Froggo> How do you wreck liss me.  Those fuckin' farts.  Wonter... a cloody a millickal bath.  Slurpy slick ass lots of pep  It's like scotch pithy.  I'm thinking about ruggity greggal.  Juvenile detention centers.  Slurpy pitch pot pee.  No likes.  Wobbity willow willa whop.  Willy wallow traps.  You can combine one or more of the darameters.
04:12:21 <Froggo> I'm trhinking about the rich ass mechgeggals.  I'm thinking about the rich ass micgeggals. Cham cham chack a leek a horn teen!   Poot wardy whail wo hootin tood!  Holla hoolah hope, laser whip!
04:12:23 <Froggo> Rabby dab runna ma nay  I'm dabster deester and I'm here to say... rump tump tigga ligger rump tump tay!  Frucky duck with the wenner hoopler wheel  Cruckity puck on an ass hole  Death bones doesn't like dlo flo.
04:12:25 <Froggo> Does anyone want to yikkel up the gecko?  Chickity china the chinese chicken!  Fucking gregging lick piss ass cunt.  Haggle hilla horst worst redneck.  Buster hymin  Juvvy joof jevuv.  Reggy McJellico.  Into that pussel.  No |\|iggards.  Your ass nards turned into a POLLEN GRAIN!  Ramis blavely reese seats.
04:12:27 <Froggo> Frucky duck with one of those chin ladin traps.  Rudder smudge wellicker wheel!  Run tun ton reddal shmip foe whip woe wack.  Rump tump tigger ligger runnel scrath.  Doo nah ninnel, nih, nee nat noe.  Runt dunt dinny!  Rump tump chickin leaker ladin straps...  Bam bam glacky I'm degga damn.
04:12:29 <Froggo> Ruh hent a lilla hole lieu. The craig mattican.  BITCH IF YOU DON'T TAKE DOWN THAT WEBCAM I AM KILLIN' YOUR DAMN DOGS.  Electromotive force.  Razh ta relley lep ta mezh.  Sh Soosh shzhs, seesh seesh-sheesh shoosh shzh shshs shshs.  chicawith hedgehog.  Ram bram bellalow, brown rye rom one day jeezh cheats!
04:12:31 <Froggo> Drederick mick taid with a drederick mick taid with a .. with a... drederick mick taid!  Is anyone here the funkistard corn.  I boo basted I'm feelin' gleem.  Rujjidy jallisher squillidger.  fuck you titty suckin' two balled bitch with a fat green clit.  Rark tah hoohk tah blanky roop roop duggan.
04:12:31 <bourbaki> Are we going Frogger in here?
04:12:33 <Froggo> Rigg ass graggan  Arewenoo..  Arwenoo zee-oo zaya.  Chinna 2olombia adaa wella shrek raflood lool.  Ground rearing some groans.  I'm huff tuff reffa leffa lurf nords.  I'm just like... vanilla ice  foe davvity wheel barow  Exparly ex preggo  Is anyone out there a rig ass graggan?  lelly in mah kellar  WRESTLING'S FAKE!
04:12:34 <johnw> aha, rend, I see it now
04:12:35 <Froggo> Pargastian wildly nig nargs.  smeggalty dellets  Far foo faqqin  Digital damage.  Where wally niqqs.  It's coast to coast night.  Hoke a lup!  Free faq fornag!  Puck a leek a lup to lup round tround.  Wormser marrial niqs.  El delphin trilaxal.  Blanking bluck to the black a lickel bleck narge.
04:12:36 --- mode: ChanServ set +o johnw
04:12:37 <Froggo> Puggy muggle maggity ass riggle ma hole.  Buck a waath ess wheel wall!  Bustin' room past tin!  Buckin' room past in!  A harnaly scrary o mep.  Rons raplaisher pa noans  rebble dibby dump dimp gabble dak.  A wristafiable pluckin'  Blacking it up to the reng teng blickhole.  I kleb to the sand of the blicka rickin time.
04:12:38 --- kick: Froggo was kicked by johnw (Kicked by johnw)
04:12:56 <Phyx-> omg
04:13:08 <hpc> that was kind of awesome
04:13:14 <Phyx-> that happen often?
04:13:22 <hpc> it used to
04:13:33 <edwardk> Phyx-: once a week or so
04:13:43 <edwardk> maybe a bit less
04:14:06 <hpc> it makes me want to create ##echochamber
04:14:09 <Phyx-> edwardk: lol, seems things have gotten livelier in the time i've been away
04:14:10 <hpc> and invite all of those bots
04:14:16 <hpc> just to see if i can get them to flood each other out
04:14:39 <Phyx-> would be nice if they responded when someone talked
04:18:48 <johnw> edwardk: so, i'm using my parser on a much larger file now, and it's printing a nice error, but there is no caret
04:18:53 <johnw> is that because of the way I'm parsing?
04:19:05 <edwardk> no
04:19:07 <johnw> I'm using the "parens" combinator, and it's failing on "expected )"
04:19:10 <edwardk> its the combinator one sec
04:19:54 <Phyx-> which parsing lib are you using out of curiousity?
04:19:55 <johnw> https://github.com/jwiegley/ledger4/blob/master/ledger-parse/Ledger/Parser/Text.hs#L152
04:19:58 <johnw> Phyx-: trifecta
04:20:27 <johnw> it kind of tastes like Parsec, but the aftertaste is not the same
04:20:29 <edwardk> you probably have to explicitly draw the caret on the current rendering
04:20:36 <johnw> edwardk: whaa?
04:20:36 <edwardk> i think i discarded the combinator in 0.90
04:20:41 <edwardk> =)
04:20:43 <johnw> recard it
04:20:45 <Hafydd> I feel like I'm becoming addicted to Haskell. It seems to satisfy me in ways no other programming language can.
04:20:51 <edwardk> its a one liner
04:20:51 <johnw> Hafydd: me too
04:21:08 <tdammers> Hafydd: I think most people here do
04:21:10 <edwardk> addCaret :: Delta -> Rendering -> Rendering
04:21:10 <typoclass> Hafydd: ;-) i think we've all been there
04:21:13 <hiptobecubic> Hafydd, wait till you try COBOL
04:21:23 <edwardk> so wherever you grab rend, just grab position and draw
04:21:34 <Hafydd> Heh.
04:21:34 <johnw> edwardk: this error reporting is happening via exception handling
04:21:35 <tdammers> hiptobecubic: you mean after you've tried COBOL, Haskell will feel even better?
04:21:40 <johnw> it's not related to a rendering I've capturing
04:21:57 <hiptobecubic> tdammers, well... it will do things to you that no other language can :)
04:21:58 <edwardk> rendCaret = addCaret <$> position <*> rend
04:22:04 <Phyx-> johnw: ah, Applicative style, cool, I'll have to give it a try. I've always used uu-parsing
04:22:13 <tdammers> hiptobecubic: so will PHP
04:22:18 <johnw> edwardk: are you suggesting I call that in a catch handler?
04:22:21 <edwardk> no
04:22:25 <t7> whats the function for   f (Just x) Nothing = (Just x) ;  f Nothing (just x) = x ?
04:22:32 <edwardk> i thought you were referring to a rendering you captured not having a caret in it
04:22:36 <t7> i that monadplus ?
04:22:43 <edwardk> 0.90 might not be capturing carets by default for its errors, not sure
04:22:45 <johnw> no, this is the rendering in the error report
04:22:52 <edwardk> i think i had my custom step parser bolt carets on
04:23:13 <Phyx-> t7: would that typecheck?
04:23:35 <`ramses> > mplus Nothing (Just 3)
04:23:36 <lambdabot>   Just 3
04:23:44 <`ramses> > mplus (Just 3) Nothing
04:23:46 <lambdabot>   Just 3
04:23:53 <t7> ah super :)
04:23:56 <t7> thanks
04:24:02 <t7> is there an infix for it?
04:24:08 <edwardk> johnw: i'm going to be a pretty crappy trifecta support resource for the next 24 hours or so =P
04:24:12 <Phyx-> `mplus`
04:24:16 <fmap> @ty let f (Just x) Nothing = (Just x) ;  f Nothing (Just x) = x in f
04:24:18 <lambdabot> Maybe a -> Maybe (Maybe a) -> Maybe a
04:24:19 <johnw> edwardk: that's ok, you've helped a ton already
04:24:26 <johnw> i don't need fancy carets just yet
04:25:22 <`ramses> t7: I don't think there's an infix defined in the type class...
04:25:24 <Phyx-> @type mplus
04:25:25 <lambdabot> MonadPlus m => m a -> m a -> m a
04:25:44 <`ramses> Phyx-: it's for monads that can act like a monoid
04:25:56 <`ramses> (and some other things, I think)
04:26:16 <fmap> :t (<|>)
04:26:18 <lambdabot> Alternative f => f a -> f a -> f a
04:26:21 <Phyx-> `ramses: i'm aware of what mplus does, but his question had the type of "Maybe a -> Maybe (Maybe a) -> Maybe a"
04:26:23 <`ramses> in this case, Nothing acts like the identity
04:26:25 <Phyx-> hence my confusion
04:26:32 <Phyx-> in that case mplus wouldn't work
04:26:37 <`ramses> ah ok :)
04:27:46 <Phyx-> `ramses: but I'm guessing I took it to literal and he meant (Just x) in the return instead of x :)
04:28:02 <hiptobecubic> Has anyone written an INTERCAL interpreter in Haskell yet?
04:28:14 <`ramses> Phyx-: yes, I think so
04:28:41 <tdammers> hiptobecubic: that should be "fun"
04:28:49 <hiptobecubic> tdammers, also "useful"
04:29:08 <Hafydd> PLEASE write an INTERCAL interpreter in Haskell
04:29:14 <hiptobecubic> you forgot DO
04:29:23 <tdammers> hiptobecubic: only if it cross-compiles to Malbolge
04:29:29 <Hafydd> Good start.
04:29:40 <tdammers> PLEASE ABSTAIN FROM write an INTERCAL interpreter in Haskell
04:29:44 <Hafydd> Hahah.
04:29:49 --- mode: johnw set -o johnw
04:30:06 <hpc> INSERT INTO haskell LANGUAGE sql
04:30:23 <johnw> how come we don't have a Linq monad yet?
04:32:42 <Phyx-> /me dislikes the Linq SQL syntax personally
04:32:45 <Phyx-> err
04:32:50 <Phyx-> how did that happen
04:32:59 * randomclown lel
04:33:06 * Phyx- dislikes the Linq SQL syntax personally
04:33:08 <Phyx-> better
04:33:09 <Phyx-> heheh
04:33:38 <johnw> http://dadandburied.files.wordpress.com/2012/01/judgemental-cat-disapproves-lolcat.jpg
04:33:58 <randomclown> isnt linq technically just a series of filters with special names
04:34:12 <FireFly> Has anyone written a Haskell implementation in INTERCAL yet?
04:34:18 <typoclass> johnw: very good =) thank you
04:34:37 <`ramses> randomclown: the filtering and such should happen on the dbms, not on the client, shouldn't it?
04:35:02 <`ramses> it should construct sql (in a type safe way) to send to the dbms
04:35:08 <statusfailed> @pl let g a = (a <|>) . join
04:35:09 <lambdabot> (line 1, column 25):
04:35:09 <lambdabot> unexpected end of input
04:35:09 <lambdabot> expecting letter or digit, variable, "(", ".", "`", "!!", operator, ";" or "in"
04:35:12 <Phyx-> randomclown: well, it does more than filtering, it also has maps and folds
04:35:22 <Phyx-> randomclown: also introduced lazy and anonymous types in the language
04:35:23 <statusfailed> @pl a = (a <|>) . join
04:35:23 <lambdabot> a = fix ((. join) . (<|>))
04:35:29 <statusfailed> ... oops
04:35:40 <statusfailed> @pl (\a -> (a <|>) . join)
04:35:40 <FireFly> @pl \a -> (a <|>) . join
04:35:40 <lambdabot> (. join) . (<|>)
04:35:41 <lambdabot> (. join) . (<|>)
04:36:04 <statusfailed> oh yeah of course :|
04:36:13 <Hafydd> Linq also does not in general entail translation to SQL.
04:36:31 <Hafydd> You can use to to make a query on some local data structure implementing the right interface.
04:36:31 <tdammers> There's Linq-to-SQL
04:36:36 <randomclown> yeah you could use linq to query containers in c#
04:36:47 <Phyx-> yeah, that's "linq"
04:36:56 <Phyx-> the SQL syntax is an extension on top oc C#
04:37:00 <tdammers> linq actually has several parts
04:37:07 <randomclown> sql as an edsl
04:37:13 <`ramses> ah ok, I only knew it as a way to construct sql :) I have never used C#
04:37:15 <tdammers> one part is the regular-C#-syntax API with all sorts of accessor methods and all that
04:37:33 <tdammers> one part is the syntax extension to C# / VB.NET that allows you to write Linq calls as statements
04:37:36 <tdammers> e.g.
04:37:49 <tdammers> var f = From foobar Where predicate
04:38:10 <tdammers> and then there's various back-ends that implement a Linq interface
04:38:14 <tdammers> linq-to-sql being one
04:38:29 <tdammers> but you can also write your own, so that you can query arbitrary data sources through linq
04:39:01 <`ramses> that's pretty cool
04:46:28 <Phyx-> tdammers: yeah, I usually refer to the first part, the linq library as "Linq" and then call the rest as an extension, linq-sql, linq-xml etc. I guess calling Linq library would be better than just Linq.
04:51:18 <tdammers> I wouldn't actually mind something like linq (the syntax extension) in Haskell
04:51:38 <tdammers> something like how Heist works, only for SQL
04:51:42 <tdammers> or maybe a quasiquoter
04:51:56 <tdammers> or does something like that already exist?
04:53:09 <solidsnack9000> tdammers: Database supported Haskell
04:56:30 <johnw> edwardk: woohoo, it parses my 447k ledger file
04:56:32 <johnw> trifecta++
04:56:38 <edwardk> nice =)
04:57:07 <edwardk> how is the error reporting?
04:57:15 <johnw> just missing the caret is all
04:57:47 <johnw> here's what I see: https://gist.github.com/4352625
05:13:34 <johnw> now i just have to work on the speed
05:13:42 <johnw> 1.035 secs to parse my ledger file is really bad
05:18:24 <donri> tdammers: monad comprehensions + transform listcomp?
05:22:33 <bourbaki> Is there any package with a DSL for mathematical expressions with derivation on hackage?
05:23:26 <johnw> -O gets down to 0.826
05:23:52 <shachaf> -O2 is the only true -O
05:24:00 <johnw> makes no difference
05:24:01 <ghorn_> bourbaki: you want symbolic math and differentiation?
05:24:05 <johnw> it was .001 slower
05:24:07 <bourbaki> ghorn_: Yep
05:25:11 <bourbaki> At best also featuring vector spaces.
05:25:35 <ClaudiusMaximus> ad and simple-reflect, but no simplification (that i've found)
05:25:58 <ghorn_> there's "ad" which algorithmically differentiates in forward and reverse mode
05:26:18 <ghorn_> there is some simple symbolic data type you can put through it to see the symbols
05:26:30 <bourbaki> What is the name of the package?
05:26:42 <ghorn_> i also wrote "dvda" which will turn your expression into a graph
05:26:44 <ghorn_> "ad"
05:26:45 <bourbaki> ghorn_ ~ gildo horn btw?
05:26:55 <ghorn_> no
05:26:56 <ghorn_> http://hackage.haskell.org/package/ad
05:26:57 <bourbaki> Let me check
05:27:41 <ghorn_> i also wrote some bindings to a C++ library which does extremely efficient ad, but those bindings are unstable
05:27:55 <ClaudiusMaximus> simple-reflect is the package that lambdabot uses for symbolic expressions
05:28:09 <ClaudiusMaximus> > scanl (+) [a,b,c]
05:28:10 <lambdabot>   No instance for (GHC.Num.Num [Debug.SimpleReflect.Expr.Expr])
05:28:10 <lambdabot>    arising fr...
05:28:16 <ClaudiusMaximus> > scanl (+) 0 [a,b,c]
05:28:17 <lambdabot>   [0,0 + a,0 + a + b,0 + a + b + c]
05:28:30 <ghorn_> right, you can put those through ek's package
05:28:44 <hiptobecubic> simple reflect works with ad
05:28:48 <hiptobecubic> it's nice
05:28:55 <ClaudiusMaximus> yep, but there is no simplifier, so the results are unweildy sometimes
05:29:39 <hiptobecubic> there's reduce
05:30:03 <hiptobecubic> but it can't tell you things like x+0 == 0
05:30:10 <hiptobecubic> err, x
05:30:24 <ghorn_> dvda will do that
05:40:22 <notdan> > a
05:40:24 <lambdabot>   a
05:40:26 <notdan> > :t a
05:40:28 <lambdabot>   <hint>:1:1: parse error on input `:'
05:40:32 <notdan> :t a
05:40:33 <lambdabot> Expr
05:40:37 <ClaudiusMaximus> :t grad
05:40:39 <lambdabot> (Num a, Traversable f) => (forall (s :: * -> *). Numeric.AD.Types.Mode s => f (AD s a) -> AD s a) -> f a -> f a
05:40:58 <ClaudiusMaximus> > grad (\[x,y,z] -> (x + y) * z) [x,y,z]
05:41:00 <lambdabot>   [0 + (0 + 1 * (0 + z * 1)),0 + (0 + 1 * (0 + z * 1)),0 + (0 + (x + y) * 1)]
05:42:17 <hiptobecubic> ghorn_, your pretty printing of sin and cos is broken
05:42:26 <ghorn_> hrm
05:42:31 <hiptobecubic> ghorn_, just missing a space
05:42:36 <hiptobecubic> "sinx" instead of "sin x"
05:42:48 <hiptobecubic> Prelude Dvda> z
05:42:50 <hiptobecubic> x * y ** 2 + cosx
05:44:56 <ghorn_> the version on github works
05:45:32 <ghorn_> i made some big changes and haven't released on hackage
05:46:02 <ghorn_> https://github.com/ghorn/dvda
05:51:50 <ghorn_> *Dvda.Examples> rad (sin (x*y)) [x,y]
05:51:51 <ghorn_> [cos(x * y) * y,cos(x * y) * x]
05:52:28 <ghorn_> *Dvda.Examples> sin x
05:52:31 <ghorn_> sin(x)
05:55:26 <sopvop> wtf, why I was told about reflection package? I've spent half day trying to understand how or if at all it will help me
05:55:45 <sopvop> reflectopocalypse
05:55:49 <quicksilver> as a general rule, reflection is the answer to the wrong question
05:55:49 <mm_freak_> sopvop: it's a bridge between type and value level
05:55:51 <quicksilver> (in haskell)
05:56:12 <quicksilver> designs which pretend reflection is impossible tend to be cleaner.
05:56:18 <quicksilver> when you need it, however, it's most handy.
05:56:35 <Jafet> Have you tried the reflection package? It may help you.
05:56:45 <sopvop> How the hell will it help me say somewhere deep inside function: Oh, what table should this record go?
05:58:16 <quicksilver> since the words 'table' and 'record' have no context, I can honestly say I don't know what you're asking.
05:58:29 <Jafet> No, no, that's too fast. You're supposed to wait half a day and complain vigorously to some totally unrelated people in the channel.
05:58:44 <Jafet> Have you read the examples?
05:58:46 <ciphergoth> no hits in Hoogle for (a -> a) -> a -> Int -> [a]
05:58:47 <sopvop> http://hpaste.org/79618 original question.
05:58:50 <Jafet> https://github.com/ekmett/reflection/blob/master/examples/
05:59:06 <johnw> edwardk: any tips on making this faster: longSep = (string "  " *> pure ()) <|> (tab *> pure ())
05:59:15 <johnw> 20% of my parsing is spent there
05:59:37 <edwardk> () <$ string " " <|> () <$ tab    is the first thing
05:59:46 <edwardk> second you're using string on a single space?
05:59:52 <johnw> it's two spaces
05:59:58 <edwardk> ooh
06:00:06 <johnw> () <$ tab is different than tab *> pure ()?
06:00:11 <johnw> or just a different way of writing the same thing?
06:00:19 <edwardk> () <$ can be a little faster
06:00:36 <edwardk> :t (() <$)
06:00:37 <johnw> let's see...
06:00:38 <lambdabot> Functor f => f b -> f ()
06:00:46 <edwardk> :t (*> pure ())
06:00:48 <lambdabot> Applicative f => f a -> f ()
06:00:52 <edwardk> it also requires less
06:00:53 <ciphergoth> given f and a, I want to generate [a, f(a), f(f(a)), ...]
06:00:58 <johnw> 696.1ms before
06:01:01 <edwardk> > iterate (+1) 1
06:01:03 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
06:01:22 <Jafet> > iterate f a
06:01:24 <lambdabot>   [a,f a,f (f a),f (f (f a)),f (f (f (f a))),f (f (f (f (f a)))),f (f (f (f (...
06:01:27 <ciphergoth> wow
06:01:32 <ciphergoth> OK that's exactly it :)
06:01:45 <ciphergoth> took me a momemnt to realise it wouldn't take a length param
06:01:46 <sopvop> quicksilver. Basically, I have function like  :: (HasTableOrWhatnot a) => f a ->... (f is anything which does not allow me to use 'a' as value). And I want to get some info about a type. Like What table it is supposed to go, or what color should i print log about it. or whatether.
06:01:54 <ciphergoth> cos take exists and it's lazy
06:02:11 <johnw> edwardk: sure enough, 578.3ms
06:02:29 <edwardk> ou can probably replace the double space with
06:02:44 <quicksilver> sopvop: I'm 99% sure that reflection will *not* be the answer to that.
06:02:56 <edwardk> () <$ (try (char ' ' *> char ' ') <|> tab)
06:03:00 <quicksilver> the answer is to augment the HasTobeOrWhatnot class to provide the methods you need to find out what you need to do.
06:03:14 <quicksilver> or if that seems inappropriate, add another class which does (and add that to the constraint)
06:03:22 <quicksilver> the constraint allows you to pass information.
06:03:53 <sopvop> quicksilver: And I asked about best stype for that. Do I pass it proxy, or do I pass undefined, or have something like (infoOf :: Tagged Info a)
06:04:11 <sopvop> style
06:04:15 <quicksilver> there are some libraries which I wish didn't exist simply because well-intentioned people will then suggest they are the best way to solve problems which they really aren't :(
06:04:25 <quicksilver> I don't think it matters very much sopvop.
06:04:38 <quicksilver> undefined looks slightly ugly to me but that's irrational - it's quite reasonable really.
06:04:41 <johnw> edwardk: i think the slow thing about this parser is that the first char ' ' will fail a lot
06:04:46 <quicksilver> some of the 'Tagged' tricks look prettier
06:04:49 <quicksilver> but I don't think it's important.
06:05:21 <edwardk> you can peak at the rest of the line and do the '  ' test by hand cheaply
06:05:32 <edwardk> but its kinda silly
06:06:00 <johnw> i'm using your <$!> trick in several places
06:06:12 <johnw> but i'm wondering if i'm losing due to lack of strictness elsewhere
06:06:26 <neutrino_> quicksilver: like what libraries
06:06:28 <johnw> ah, your last tip brought it down further
06:06:31 <johnw> 497.9ms
06:06:43 <johnw> why is () <$ (try (char ' ' *> char ' ') <|> tab) that much faster?
06:07:06 <sopvop> quicksilver: I now use tagged, pretty much everything turns into constants after simplify. I'll stick to it
06:07:42 <sopvop> reflection - best tool to troll
06:08:46 <Jafet> Isn't reflection just one unsafeCoerce away from tagged?
06:09:16 * Philippa appears to be reinventing a lot of functorial/categorical stuff and giving it domain-specific names in her new lib
06:09:33 <Philippa> anything I should be poking at as the standard grab-bag? I'm mostly doing AST manipulation
06:09:49 <Philippa> edwardk: this is your chance to say "see all this stuff I wrote? Use it!" :p
06:10:00 <johnw> sync
06:10:08 <edwardk> Philippa: too busy playing with profunctors
06:10:28 <Jafet> edwardk is more subtle than that
06:11:50 <Philippa> Jafet: I'd been hoping for slightly more specific pointers :-)
06:14:36 <hpaste> sopvop pasted “How should reflection make it better?” at http://hpaste.org/79629
06:16:02 <niteria> Philippa: is your AST manipulation code available anywhere?
06:16:51 <Philippa> niteria: yeah, there's a github repo - https://github.com/flippac/two-level-constraints . It's doing two-level programming in the style of Sheard's Generic Unification functional pearl, but I'm going a lot further with it
06:17:15 <Philippa> there's no "this is how to use it" guide yet though, and the Test module's a little busted and I need to push more patches!
06:17:34 <mm_freak_> quicksilver: i see reflection as a good tool for sopvop's case
06:17:45 <Philippa> (I'm guessing edwardk, Saizan and a few others might've worked out my life derailed a bit for a couple of weeks because there's been no further talk about it)
06:17:57 <mm_freak_> you have row types and you want to attach table information to them in a sane manner
06:18:03 <mm_freak_> this calls for doing it on the type level
06:18:09 <Peaker> Philippa, what is the source of the name "OccursCheck"? I know GHC uses it too...
06:18:10 <mm_freak_> and reflection brings this to the run time
06:19:02 <Philippa> Peaker: as in the occurs check in unification? I've traced it back as far as the prolog crowd, it probably goes further
06:22:42 <Saizan> Philippa: you could take mapChildren and foldChildren out of TermLevel and add Foldable and Functor superclasses
06:24:37 <Philippa> Saizan: yeah. That's the class I 'inherit' from Sheard. I'd probably want to keep the synonyms tied to that class though - this lib's a definite "you want to know which fmap is on which functor" case
06:25:01 <Philippa> (cf Perlis' definition of low-level, as ever)
06:25:02 <Saizan> Philippa: and i guess edwardk would point you to scoped to deal with binders if he hasn't done already :)
06:25:27 <Saizan> fmap is always fmapChildren though :)
06:25:34 <sopvop> mm_freak_: can you please annotate http://hpaste.org/79629 with reflection way?
06:27:03 <Philippa> Saizan: yeah. Not that I haven't ditched Sheard's names once already, but I think I might have to again :-) Still, early days!
06:29:53 <mm_freak_> sopvop: not right now, sorry
06:30:23 <mm_freak_> is there a class that gives me [], S.empty, M.empty, etc.?
06:30:51 <sopvop> Pointed
06:31:04 <mm_freak_> no, Pointed gives me singletons
06:31:53 <Saizan> i wonder if TermLevel is strong enough to force t to be strictly positive
06:31:53 <fmap> mm_freak_: Default?
06:32:48 <mm_freak_> fmap: that could work, but i just figured i'll need unions as well
06:32:54 <mm_freak_> so i'll probably just go with Map
06:33:38 <Philippa> mm_freak_: Monoid? You get too much extra though
06:34:28 <mm_freak_> Philippa: unfortunately i can't put a Monoid constraint in a Monad instance
06:34:45 <mm_freak_> instance (Monoid (f a)) => Monad (MyMonad f)
06:36:59 <Saizan> Philippa: btw, instance MetaLevel MetaTerm t (t (MetaTerm t)) where <- that instance breaks the fundep on MetaLevel, since MetaTerm doesn't determine f, though it seems the fundep is the more likely to be wrong, or were you knowingly abusing it?
06:38:28 <Philippa> Saizan: MetaTerm determines that any f will do, so long as it's treated consistently, or have I misunderstood something?
06:38:50 <Philippa> wait, sorry, MetaTerm /is/ the f
06:39:05 <Saizan> sorry, i meant t
06:40:18 <Philippa> Saizan: yeah. My original answer, then
06:40:54 <Saizan> well, "any t will do" is kind of the opposite of what the fundep specifies
06:42:22 <Saizan> with class C a b | a -> b; you can't have instance C X b; otherwise both C X B1 and C X B2 are valid and so C is not a function from 'a's to 'b's
06:43:00 <djahandarie> I noticed that some libraries #define CALLCONV and use that instead of ccall? What else would it be aside from ccall?
06:43:13 <Philippa> *nod*. Yeah, whoops. I know what I /want/ it to mean :p Which is to say, the same thing up to instantiation
06:43:36 <Saizan> it's not going to be unsound because fundeps are merely hints to type inference, but it's still nasty :)
06:43:36 <wuttf> Can anyone show me a typical problem (or problem domain) which cannot be solved with idiomatic Haskell?
06:43:43 <Philippa> *nod*
06:44:09 <Philippa> wuttf: eh. Depends how picky we're being about 'idiomatic'. My idiom set is rather different to that of some folks here
06:44:21 <wuttf> Philippa: Go on dude, no problem
06:44:24 <Peaker> If Data.Map.singleton was named ==>, maybe it could be nice to build maps via:   mconcat [ a ==> b, c ==> d, ... ]  (closer to a literal syntax)
06:44:25 <Philippa> ("embed the language you want to work in" is idiomatic for me)
06:44:40 <Philippa> wuttf: I'm not a dude, btw
06:44:59 <Philippa> but yeah, some people are not keen on, or even outright antagonistic to, the way I work
06:46:23 <Philippa> Saizan: yeah. I suspect I think too much like a type inferrer and not enough like some poor sod trying to specify the semantics :p Or rather, like the latter having not realised that "what the inferrer does" is, in some sense, /the/ semantics
06:46:37 <rwbarton> (Saizan: with UndecidableInstances ghc will accept 'instance C X b' anyways though)
06:47:03 <Philippa> wuttf: it's fairly hard to do something like seriously low-level driver work in what most people would think of as 'idiomatic' code though
06:47:09 <wuttf> Philippa: "not a dude" PICS OR DIDNT HAPPEN
06:47:09 <Saizan> rwbarton: yeah, which is why people don't see it sooner :)
06:47:12 <Philippa> those sorts of tasks take on idioms of their own
06:47:25 <shanse> wuttf: grow up
06:47:45 <wuttf> shanse: Oh come on, have a sense...
06:47:56 <Philippa> wuttf: those gags've been deconstructed plenty, they're plain sexist by now. So they don't belong in here.
06:48:22 <Philippa> which isn't to say that pics don't exist: plenty of people in here've met me in person
06:49:21 <frerich> What do you mean, I thought we're all dogs?
06:49:39 <Saizan> Philippa: i guess the question is what unsemantic fundeps do to confluence (another is that we might want them to play nice with ~ someday)
06:50:11 <wuttf> Still :-D. How can you be so sour. Where I live (eastern yurop) people are getting imprisonated and killed for no reason, and I can still smile. Who should grow up then
06:50:36 <catsbydlo> wuttf: :-[
06:51:00 * elliott still thinks it's wuttf who should grow up.
06:52:05 <Philippa> wuttf: stuff like that actively discourages women from either being open about who we are or even participating in groups. It's tiring. So yeah, it's not one of the things that make me smile (of which, believe me, I have plenty!)
06:52:28 <wuttf> :D Whatever. I will never conform to fake zionist ideas imposed on us by people who are brainwashing us to avoid talking/thinking about important issues.
06:52:38 <shanse> what
06:52:38 <Philippa> *yawn*
06:52:43 --- mode: ChanServ set +o Philippa
06:52:44 * elliott senses a welcome being overstayed
06:52:51 <Philippa> come back later
06:53:02 --- mode: Philippa set +b *!*@gateway/web/freenode/ip.84.2.139.29
06:53:05 --- kick: wuttf was kicked by Philippa (wuttf)
06:53:23 --- mode: Philippa set -o Philippa
06:53:32 <catsbydlo> I think that's the first time I've seen "sendpix" called an important issue
06:53:53 <Philippa> I take it you're not an XKCD reader and don't read much on women in tech, then
06:54:19 <Philippa> hell, it's not all that hard to /find/ pix of me online, that's not the point
06:54:24 <frerich> So, now for the post-ban aftermath of questioning whether it was justified or not or what? :)
06:54:35 <catsbydlo> no, it was very justified
06:54:46 <catsbydlo> I've just never seen that particular "defense" before
06:54:48 * elliott thinks catsbydlo meant something different to what people are interpreting the statement as
06:54:57 * elliott will now communicate exclusively through /me
06:55:02 <Philippa> frerich: from where I'm standing it's the followups that warrant it, FWIW
06:55:31 <Philippa> it's also not going to be permanent
06:55:54 <frerich> Philippa: I was just trying to pre-empt people before they start the discussion ;-)
06:55:59 <catsbydlo> Philippa: I think we're talking past each other
06:56:39 <Philippa> catsbydlo: yeah, I re-read in light of elliott's comment, n/m
06:56:44 <typoclass> frerich: i agree with Philippa. he made a joke, it was not well received and he was told that it was offensive. the normal thing to do is "oh sorry, i didn't know" and move on. no problem so far. insisting on it and stupid defenses are where the problem begins, imho
06:57:04 <catsbydlo> bonus points for originality/antisemitism, though
06:57:17 <elliott> if this violent agreement continues much longer it might turn into a flamewar
06:57:18 <quicksilver> I've never met someone from Eastern Europe who wrote it 'eastern yurop"
06:57:27 <quicksilver> maybe I'm missing out on a subculture.
06:57:50 <catsbydlo> quicksilver: I wouldn't be surprised to see something like that on 4chan
06:58:06 <quicksilver> that's certainly a subculture I've tried hard to miss out on.
06:58:11 <quicksilver> call me closed-minded.
06:58:30 <quicksilver> mm_freak_: I don't think I agree, but clearly neither of us has time to discuss it properly now :)
06:58:31 <Philippa> catsbydlo: yeah, it does smell a lil' bit of that. Or more of 4chan wannabe
06:59:05 <quicksilver> gratutious reflection smells of wanting type-case which smells of trying to invent your own dispatch mechanism
06:59:17 <frerich> I'd just like to chip in with a little Haskell bit: does anybody know whether there's a package for doing LDAP-via-SSL with Haskell? I started using http://hackage.haskell.org/package/LDAP but only now noticed that it apparently won't let me do "ldaps".
06:59:17 <quicksilver> which is fine if you really *do* need a novel dispatch mechanism
06:59:21 <Philippa> anyway. Er. I think Saizan and I were talking about how I just did something evil with fundeps?
06:59:22 <quicksilver> but wrong if there is a simpler way.
07:00:06 <Philippa> Saizan: should I be checking whether I can implement the same thing with ~ comfortably?
07:01:07 <Saizan> Philippa: ah, yeah, i guess that'd do the same job
07:01:36 <Philippa> Saizan: this all smells of poorly-specified "equivalent up to"ness to me :-)
07:02:23 <Saizan> Philippa: i.e. remove the fundeps and rewrite the instance to instance v ~ t (MetaTerm t) => MetaLevel MetaTerm t v where
07:02:51 <elliott> (v ~ t, MetaTerm t), right?
07:03:02 <Saizan> no
07:03:24 <elliott> oh
07:03:28 <elliott> v ~ (t (MetaTerm t))
07:03:32 * elliott 's mental parser jammed
07:04:23 <erlnoob> so, I've been following LYAH tutorial.. and in ghci I have: let add a b = a + b ... why can't I do: let add1 = succ . add ? I may not be understanding (.) correctly. help?
07:05:31 <Saizan> Philippa: i don't think there can be much up-to-ness as long as we can pattern match on the structure of types, or am i misundestanding?
07:05:36 <catsbydlo> because add1 x would be succ (add x)
07:05:42 <catsbydlo> and (add x) is not a number you can succ
07:06:00 <catsbydlo> @src (.)
07:06:00 <lambdabot> (f . g) x = f (g x)
07:06:01 <lambdabot> NB: In lambdabot,  (.) = fmap
07:06:37 <mm_freak_> quicksilver: i don't think i want to discuss it at all =)
07:06:55 <b_jonas> I don't like reflection mechanisms
07:06:59 <Philippa> Saizan: Depends - if you can not only pattern match but unify then you have to ask how you're treating free type variables
07:07:11 <quicksilver> mm_freak_: well if you don't want to discuss it, why are you volunteering opinions on it? and I mean that in the nicest possible way :)
07:07:30 <Philippa> we don't /really/ have a clear statement of what they mean in GHC Haskell!
07:08:24 <mm_freak_> quicksilver: because it's useful to have multiple opinions
07:08:38 <Saizan> yeah, my problem is that the result of instantiating a meta-var is still matchable :)
07:09:06 <quicksilver> mm_freak_: yes, but in general it's much more useful if the holders of those opinions are prepared to explain them.
07:09:16 <mm_freak_> i am
07:09:34 <Philippa> Saizan: right. So it makes sense /if/ you have to pick a substitution and stick to it for the implication to hold
07:10:06 <Philippa> (now it'd break the hell out of it if it were bidirectional, no argument there!)
07:12:26 <Saizan> Philippa: ah, so you'd be ok with a global instantiation for t? so that the first use of the MetaLevel MetaTerm .. instance determines which one it is? doesn't seem very useful to me
07:14:15 <Philippa> Saizan: :p One per use site. So you're entitled to infer, any time you see one of the methods, that p = t and thus you don't know anything more than you started with, and then continue
07:16:15 <Philippa> (but you also get to infer that v = t (MetaTerm t) )
07:16:20 <erlnoob> another question: in the tutorial, a contrived example is put forth: head' = foldr1 (\x _ -> x) does haskell optimize this since the lambda always return x, therefore it's useless to actually foldr through the list?
07:16:45 <Saizan> Philippa: btw, f p -> v would make sense
07:17:00 <Saizan> Philippa: and have the same effect here
07:17:22 <catsbydlo> erlnoob: depends on what you mean by "optimize"
07:17:40 <Philippa> Saizan: yeah. I need to ask myself whether v -> f p
07:18:29 <erlnoob> catsbydlo: can you elaborate please? i meant can haskell optimize for cases like in the example?
07:18:53 <catsbydlo> erlnoob: so by "optimize" you mean ... optimize?
07:18:58 <catsbydlo> rather unhelpful
07:19:49 <tromp> the result still depends on the list
07:19:53 <Philippa> erlnoob: I'd have to crank through GHC's simplifier passes to figure it out :-) But I *think* so
07:19:57 <tromp> on whether it's finite
07:20:13 <Philippa> tromp: oh, yeah, it's the right-associative version
07:21:04 <fmap> > foldr1 const [1..]
07:21:06 <lambdabot>   1
07:21:10 <Philippa> wait, that's the right way round this time, isn't it?
07:21:11 <Philippa> yeah
07:21:18 <Philippa> erlnoob: I believe GHC can optimise that, yes
07:21:30 <erlnoob> thank you Philippa
07:21:39 <Philippa> you inline one 'roll' of foldr1, inline f and boom
07:21:41 <catsbydlo> I still think you're talking past each other
07:22:11 <tromp> ignore my comment; it's the foldl that can diverge
07:22:14 <Philippa> oh, erlnoob may be asking about laziness, sure: the optimisations I'm describing are legit /because/ laziness
07:22:15 <fmap> it's not an optimisation, just non-strict semantics though?
07:22:29 <catsbydlo> fmap: depends on what you mean by "it"
07:22:53 <fmap> catsbydlo: `foldr1 const [1..]' termination
07:23:19 <catsbydlo> ah, sure. but you're the first one to actually mention termination
07:23:24 <Philippa> fmap: I'm saying GHC should be able to optimise down to a single case on the list, realise there's only one branch... unfortunately then it has to include the implicit _ -> undefined one, so that's as far as you get - one branch is x, one is _|_
07:24:03 <Philippa> so GHC /should/ be able to turn that into the same code as head :p
07:24:15 <tromp> > foldl1 const [1..]
07:24:22 <lambdabot>   mueval: ExitFailure 1
07:24:23 <lambdabot>  mueval: Prelude.undefined
07:24:32 <Philippa> erlnoob: did I answer what you were interested in?
07:24:33 <tromp> > foldl1 (flip const) [1..]
07:24:37 <lambdabot>   mueval-core: Time limit exceeded
07:24:40 <erlnoob> so I did foldr1 (\x _ -> x) [1..100000000000000000000000000000000000] and it came up in an instance
07:24:55 <Philippa> erlnoob: right. That's not optimising though, that's just lazy evaluation
07:25:06 <catsbydlo> erlnoob: that's just what foldr1 does normally
07:25:10 <catsbydlo> @src foldr1
07:25:10 <lambdabot> foldr1 _ [x]    = x
07:25:11 <lambdabot> foldr1 f (x:xs) = f x (foldr1 f xs)
07:25:11 <lambdabot> foldr1 _ []     = undefined
07:25:19 <Philippa> erlnoob: it doesn't need to see the rest of the list, so it just has the equivalent of [2..100000000000000...] unevaluated
07:26:10 <catsbydlo> foldr1 (\x _ -> x) [1 ..]
07:26:17 <catsbydlo> foldr1 (\x _ -> x) (1 : [2 ..])
07:26:32 <catsbydlo> (\x _ -> x) 1 (foldr1 (\x _ -> x) [2 ..])
07:26:49 <Philippa> 1
07:26:50 <catsbydlo> (\_ -> 1) (foldr1 (\x _ -> x) [2 ..])
07:26:53 <catsbydlo> 1
07:28:05 <erlnoob> if it did no optimizations, it would have to apply the lambda through the whole list, which doesn't seem to be the case?
07:28:20 <Philippa> erlnoob: no, that's just lazy evaluation happening
07:28:26 <Philippa> that's not an optimisation, that's ordinary haskell
07:28:49 <latro`a> this has nothing to do with optimization; the compiler doesn't "figure out" that it can safely be lazy, it just creates lazy code every time
07:29:00 <erlnoob> but I'm doing this in ghci, since Show would require the value it would do the calculation no?
07:29:17 <latro`a> it needs the 1, it doesn't need the rest of the list
07:29:21 <latro`a> to figure out what to show
07:29:31 <latro`a> you're correct that it can't do *nothing*
07:29:37 <latro`a> because you're forcing it to print something
07:30:22 <Twernmilt> Hello, I'm trying to get get the Cairo package working with GtkHs with the intent of being able to do animation. I'm using this tutorial: http://www.muitovar.com/gtk2hs/app1.html . However, when I try to run their code, I get errors. Here are two of my attempts; each one has the code I used followed by the error message it produced. https://gist.github.com/4323331 . I should also note that the packages appear to work correctly when used separa
07:30:49 <typoclass> Twernmilt: hello, you were cut off at "used separa"
07:31:12 <Twernmilt> I should also note that the packages appear to work correctly when used  separately.
07:31:28 <Twernmilt> You didn't miss much :)
07:31:44 <typoclass> erm ok. folks inferred that anyway =)
07:32:37 <Twernmilt> I also followed the tutorial on the GtkHs site to install all of this stuff on OSX.
07:35:59 <Philippa> erlnoob: the show demands the final result. It doesn't care about intermediates, so intermediates can contain unevaluated terms
07:37:04 <foldrp> Philippa: For how long did you ban my other nick?
07:37:17 <foldrp> I like that so much better.
07:37:58 <erlnoob> I did foldr1 (\a b -> a + b) [1..100000000000000000000000000000000000] and it still hasn't finished, I'm thinking this has little to do with lazyness? does haskell optimize for identity lambdas? this seems to be the case, but I'm just still learning so enlighten me
07:38:03 <erlnoob> sorry for being a pain..
07:38:17 <shachaf> erlnoob: That function has to compute the whole sum before it can give you anything.
07:38:21 <shachaf> (+) is strict. It's how (+) is.
07:39:22 <catsbydlo> erlnoob: 'a + b' can't give you a result before it has both 'a' and 'b'. 'a' can give you a result without knowing 'b'
07:41:10 <mreh> it's a shame I can't use ghci with my hsc source files
07:42:15 <catsbydlo> can't you just hsc2hs them?
07:42:40 <typoclass> erlnoob: as far as foldr1 and (+) are concerned, that list might just as well be a ton of random numbers, numbers read from a file or from wherever. it doesn't "know" it's a special sort of list that you could more easily sum up by using that equation by gauss. so what it does is, it takes one number after the other and adds them, and that costs a lot of time because it's a huge amount of numbers
07:42:49 <mreh> ah, it's a shame that cabal doesn't leave the .hs files in the directories
07:42:59 <mreh> although that would mess up my project
07:49:17 <Phyx-> mreh: no, but they are in the dist directory if i'm not mistaken?
07:51:30 <PthariensFlame> I have a more theoretical question.
07:52:17 <PthariensFlame> If Kleisi is a -> f b and Cokleisli is g a -> b
07:52:25 <shachaf> hi PthariensFlame
07:52:29 <shachaf> Following lens development? :-)
07:52:41 <PthariensFlame> What do you call g a -> f b?  Bikleisli? :/
07:52:51 <edwardk> PthariensFlame: we threw out everything you know about lenses. sorry
07:52:58 <PthariensFlame> Yup!  :)
07:53:01 <shachaf> PthariensFlame: I called it "Dialgebroid" once, but that wasn't a great name.
07:53:15 <shachaf> I don't think it has a name in particular.
07:53:32 <shachaf> It's the profunctor composition of the UpStar and DownStar profunctors.
07:53:37 <shachaf> (Not that that helps you much.)
07:53:40 <edwardk> Diklielsi would probably be the closest
07:53:49 <typoclass> shachaf: thanks for clarifying =)
07:53:52 <shachaf> edwardk: Well, in the context of lens we don't care about Kleisli.
07:53:58 <edwardk> sure
07:54:03 <shachaf> I just used that name because it was there.
07:54:09 <edwardk> i was meaning by analogy to his kleisli/cokleisli statements
07:54:12 <shachaf> Sure.
07:54:42 <edwardk> dyads are the minimal thing that subsumes monad and comonad -- sadly they are useless. see fokkinga's paper on them
07:54:54 <PthariensFlame> Dikleisli it is then!  Thanks.
07:54:58 <edwardk> so dikliesli isn't too far off as a moniker
07:55:14 <edwardk> PthariensFlame: but we've obviated those in lens development using profunctors these days
07:55:34 <elliott> http://www.haskell.org/pipermail/haskell-cafe/2000-December/001385.html
07:55:53 <shachaf> elliott: whoa, dude. crazy
07:55:58 <edwardk> and my expectation is that almost anywhere you'd go to use that kind of arrow, you're doing something silly
07:56:00 <elliott> PthariensFlame: thankfully we don't use Cokleisli now!
07:56:19 <typoclass> elliott: hehe, nice find
07:57:23 <xplat> elliott: you dropped cokleisli again?
07:57:33 <Philippa> is there anywhere I can get hold of the Lenses, Folds and Traversals talk as a proper file including the subs/captions etc?
07:58:06 <edwardk> there is an mkv on comonad.com thats ~3gigs and i have the captions file for the first 42 minutes
07:58:15 <edwardk> (and autogenerated ones for the rest)
07:58:27 <shachaf> xplat: We're using profunctors now.
07:58:29 <shachaf> Way better.
07:58:35 <Philippa> are the autogenerated ones what I'm getting on YouTube?
07:58:57 <edwardk> if you selected 'English captioned through 42:…' thats what i hand did + youtube after
07:59:00 <xplat> i expect autogenerated captions will be amazingly bad, they won't be good for much besides giving hints on timing
07:59:04 <mreh> i'm not massively keen on having .hsc and .hs sources in my project dir just to get ghci to work when one is redundant
07:59:06 <shachaf> xplat: It *should* be (p a b -> p s t), but that's not twanvl-compatible, so we're using p a (f b) -> p s (f t)
07:59:12 <mreh> anyone think of an elegant solution
07:59:20 <mreh> otherwise I'm going to copy the directory
07:59:25 <edwardk> xplat: thats what i did with them
07:59:29 <edwardk> just ran out of energy
07:59:36 <edwardk> figured i'd pick it up again later
08:00:38 <edwardk> mreh: honestly when i put hsc in the project i just build exclusively with cabal from there out
08:00:56 <xplat> yeah, i've done this dance with youtube before, basically any jargon term whatsoever will be misunderstood, even if it's also a real word because jargon usage doesn't fit their markov models or whatever built from the everyday use
08:01:02 <edwardk> i never did get used to the :r reload dev cycle
08:01:03 <Philippa> edwardk: *nod*. FWIW I'm finding the ones you did immensely useful and I'm probably not the only one with audio and/or verbal processing issues that'd help
08:01:26 <edwardk> Philippa: i'll keep working on them and i'll put up the current caption file on comonad.com
08:01:38 <Philippa> edwardk: hah! I still need to build the interpreter that'll dump my current definition set out to a file and see how soon I start swearing at it
08:01:47 <edwardk> i realize i talk fast and its a lot of material
08:02:06 <dgpratt> I've reluctantly accepted the fact that your VS Haskell project is long dead, but I am curious to know...
08:02:12 <dgpratt> darn
08:02:15 <mreh> edwardk: me too but it's not ghci friendly :(
08:02:27 <Philippa> edwardk: thanks! And yeah. Actually I appreciate that bit or the tl;dw factor kicks in :-)
08:02:36 <dgpratt> meant that as a PM <embarrased expression>
08:02:42 <edwardk> mreh: cabal install && ghci   in ghci :cd .. and load the module ;)
08:02:47 <Philippa> (it's easier to fix too much at once via technical means than a slow talk!)
08:02:53 <hiptobecubic> dgpratt, :D
08:03:19 <hiptobecubic> dgpratt, i didn't realize what you were talking about until you said you were embarassed
08:03:22 <xplat> i tried following a suggestion from yesterday to parse things with attoparsec as chunks of text and then reparse them, but attoparsec makes it amazingly hard
08:03:35 <dgpratt> hiptobecubic: :)
08:04:26 <edwardk> Philippa: the version on comonad.com is older (i didn't interleave the audio) but http://comonad.com/haskell should have Lenses-NYC-v2.mp4
08:04:32 <xplat> one way means you get your result as an Either and if you want to use it in a bind you have to lift the either back to a parser (and lose a lot of information in the error case)
08:04:51 <edwardk> i'll have to nuke that to push up the new one for space reasons, so i'll leave that one up for a while if you want to start pulling
08:05:09 <edwardk> he new one just switches to mkv and interleaves the audio better so it can stream
08:05:47 <xplat> the other way you end up feeding the parser an incomplete stream and then marking the stream complete separately, which is silly and inefficient
08:06:17 <mreh> edwardk: sorry, I don't follow, appreciate the help though :)
08:06:32 <xplat> the third way is the 'right way', but requires using unsafeCoerce three times because attoparsec doesn't export its types
08:06:42 <mreh> install the package, drop into ghci and load what exactly?
08:07:16 <edwardk> :cd .. to get out of the dir so it doesn't try to load the file directly, then :m + Your.Hsc.Based.Module
08:07:27 <xplat> this also makes it dependent on the order of constructors in one of the types :(
08:07:27 <mreh> oooooh
08:07:43 <mreh> it's an executable :(
08:07:50 <mreh> I can change that thouh
08:07:54 <edwardk> you can avoid the first step by punting the source files to a src directory and not telling your .ghci about it
08:13:04 <Luke> edwardk: have you posted the video of the NY haskell meetup talk you gave without the ground buzz yet?
08:13:16 <edwardk> Luke: yep
08:13:17 <edwardk> one sec
08:13:23 <Luke> thanks
08:13:39 <edwardk> https://www.youtube.com/watch?v=cefnmjtAolY&hd=1
08:13:41 <Luke> oh i found the link
08:13:43 <Luke> thanks
08:13:57 <PthariensFlame> edwardk : So are you ever going to update indexed-extras?
08:14:11 <edwardk> indexed is idle until ghc 7.8
08:14:28 <edwardk> it needs usable product kinds
08:14:34 <edwardk> the ones we have now are useless
08:15:02 <hiptobecubic> are they on the roadmap for 7.8?
08:15:13 <PthariensFlame> Got it
08:16:50 <shergill> edwardk: could you elaborate on usable/useless? or point me to the change in ghc 7.8 which you're waiting for
08:17:29 <erlnoob> @src foldl1
08:17:29 <lambdabot> foldl1 f (x:xs) = foldl f x xs
08:17:30 <lambdabot> foldl1 _ []     = undefined
08:17:57 <edwardk> shergill: right now all kinds have an extra distinguishable member: Any :: k
08:18:12 <edwardk> you can write type families that dispatch on it etc. so its not a trivial thing that its there
08:18:40 <mreh> edwardk: re: nyc talk, nice
08:18:47 <edwardk> it means i can't write safehaskell code that uses product kinds, i can't ue the fact  that t :: (*,*) to infer that t ~ '(x,y), etc.
08:18:52 <edwardk> mreh: thanks =)
08:19:33 <edwardk> basically if you build any kind it has an extra distinguishable inhabitant that destroys the benefits of having those kinds in the first place mostly
08:19:56 <edwardk> e.g. type level naturals are actually naturals + an atom for Any
08:19:57 <Philippa> _|_ for kinds, and it's giving you the finger?
08:20:03 <edwardk> Philippa: yes
08:20:23 <edwardk> Philippa: in 'indexed' i work around it with 'herp' and 'derp' but they are a hack
08:20:41 <shergill> edwardk: ah gotcha
08:21:06 <mreh> nice hoodie
08:22:36 <erlnoob> ok looking at the src for foldr1 I think I finally understand. thanks Philippa  and catsbydlo :)
08:23:47 <Luke> edwardk: how did you get those lens animations in your presentation? something apple made just happen to have lenses?
08:24:12 <edwardk> no, i used keynote and put together an animation using magic move
08:24:35 <edwardk> it was a good excuse to learn keynote when i did them for my scala talk and i've borrowed the effect for two or three lens talks since ;)
08:24:44 <edwardk> mreh: =)
08:24:47 <Saizan> fundeps are weirder than i had imagined
08:25:02 <Luke> edwardk: ha nice. looks cool
08:25:04 <mreh> magnifying glass, lens.. I get it
08:25:18 <edwardk> mreh: i have the link for the custom layout somewhere
08:25:19 <eikke> I wish there was something like Keynote for Linux. Fed up with my Beamer slides :P
08:25:35 <osfameron> there's (Open|Libre)Office "Impress"
08:25:41 <osfameron> it's nothing as good as keynote
08:25:42 <edwardk> Luke: the scala one used an ambigram for the logo
08:25:47 <eikke> osfameron: doesn't come close :)
08:25:50 <osfameron> but it beats debugging beamer documents...
08:25:50 <mreh> sell you soul to apple
08:25:55 <mreh> your*
08:26:05 <Luke> edwardk: nice - i'll watch that next =)
08:26:10 <hiptobecubic> Impress is anything but
08:26:23 <osfameron> keynote does very little, but does it very well
08:26:26 <Saizan> Philippa: what do you think of this http://hpaste.org/79632 ?
08:26:47 <hiptobecubic> osfameron, s/keynote/apple
08:27:21 <osfameron> hiptobecubic: I guess.  But there are perfectly good minimalist linux apps in other areas (e.g. rhythmbox is possibly better than itunes)
08:27:33 <osfameron> sorry, shall we take this to -blah?
08:28:41 <edwardk> Luke: sadly with the title change i didn't get to use the ambigram from the first one: https://www.youtube.com/watch?v=efv0SQNde5Q&list=PLEDE5BE0C69AF6CCE&t=43s
08:28:50 <xplat> okay, my unsafeCoerce-heavy thingy doesn't work, and i can't debug it because no types.  didn't i start using haskell to avoid this situation?
08:29:05 <hiptobecubic> osfameron, nah, someone suggesting -blah is my cue that I am wasting time and should be working.
08:29:10 <osfameron> hehe
08:29:12 <Luke> edwardk: hahaha that is awesome
08:29:18 <xplat> well, i can debug it, but it has to be the old-fashioned way :(
08:29:29 <niteria> that lenses video was intense, I remeber nothing from it, but I gained some confidence that lenses will do 'the right thing'
08:29:45 <edwardk> niteria: =)
08:29:55 <mreh> you couldn't remember comonad coalgebras?!
08:30:07 <edwardk> lens.github.com has a bunch of links to tutorial stuff, the wiki, etc.
08:30:47 <niteria> actually, now the diagram makes sense
08:30:53 <edwardk> i should set up the embedding of the video on the homepage too now that i think about it
08:31:52 <xplat> @hoogle Data.Attoparsec.Types.Parser t a -> t -> Data.Attoparsec.Types.Parser t a
08:31:53 <lambdabot> Parse error:
08:31:54 <lambdabot>   Data.Attoparsec.Types.Parser t a -> t -> Data.Attoparsec.Types.Parser t a
08:31:54 <lambdabot>       ^
08:32:11 <xplat> @hoogle Parser t a -> t -> Parser t a
08:32:12 <lambdabot> Did you mean: Parser t -> t -> Parser t
08:32:13 <lambdabot> No results found
08:32:32 <xplat> @hoogle Parser a -> t -> Parser a
08:32:32 <lambdabot> No results found
08:32:58 <`nand`> edwardk: does GHC 7.8 remove Any?
08:33:05 <xplat> i find it hard to believe nobody has wanted this thing before
08:33:14 <edwardk> `nand`: they are looking to handle it differently
08:33:21 <Luke> With this definition "data Store s a = Store (s -> a) s", what is that dangling s at the end? is that even valid haskell?
08:33:31 <`nand`> any preliminary changelog to look at?
08:33:34 <edwardk> Luke: thats just a two argument constructor
08:33:38 <Luke> oh
08:33:40 <edwardk> data Foo a = Foo Int Double
08:33:42 <Luke> i see
08:33:52 <edwardk> data Foo a = Foo (a -> a) (a -> a)
08:33:54 <edwardk> data Foo a = Foo (a -> a) a
08:33:58 <Luke> i was thinking of it as part of the first arg but you're right, it's separate
08:33:59 <niteria> when I become more familiar with lenses, I'd like to do trylenses, in a fashion that tryhaskell.org works
08:34:09 <`nand`> niteria: nice :)
08:34:24 <`nand`> how long until memetic mutation turns lenses into its own programming language?
08:34:37 <edwardk> `nand`: i've been investigating a type system for them
08:34:48 <Philippa> Saizan: how so?
08:35:31 <Philippa> `nand`: not very long, you get a pure 'OO' language from them pretty quickly I suspect
08:35:56 <xplat> i see Aeson uses the version that goes via Either
08:37:08 <Luke> edwardk: do you think of Store as a noun or verb in the case of the type?
08:37:18 * hackagebot shelly 0.15.2 - shell-like (systems) programming in Haskell  http://hackage.haskell.org/package/shelly-0.15.2 (GregWeber)
08:37:29 <xplat> edwardk: i guess haskell extended with rank-2 type inference would work pretty well for lenses, except for the fact of all those extensions you use that would probably be incompatible with rank-2 inference
08:37:33 <Luke> edwardk: it's a Store because you can store an 'a' in it?
08:37:50 <shachaf> Can you pick f,g such that (g s -> f t) ~~ (s -> a, b -> t)?
08:38:00 <edwardk> i think of it as a noun
08:38:25 <xplat> edwardk: so i suppose you're thinking of something a little more specific
08:39:14 --- mode: ChanServ set +o Philippa
08:39:18 --- mode: Philippa set -b *!*@gateway/web/freenode/ip.84.2.139.29
08:39:28 --- mode: Philippa set -o Philippa
08:43:51 <Saizan> Philippa: isn't it disturbing how "test T" has a more general result type than "test" ?
08:44:13 <Saizan> Philippa: wrt http://hpaste.org/79633
08:48:31 <Philippa> Saizan: er, yeah, more than a little
08:49:40 <elliott> Saizan: nice
08:49:54 <Saizan> given constraint and inferred ones are treated pretty differently
08:50:05 <Philippa> yeah
08:50:19 <Philippa> I mean, I have a semantics in mind that makes sense /but it doesn't let you unify x and y/
08:51:17 <Philippa> (precisely because instance C T t)
08:51:30 <xplat> how is 'instance C T t' even allowed given the fd?
08:51:40 <Saizan> UndecidableInstances
08:51:45 <Saizan> so yeah, it's illegal
08:51:50 <Philippa> xplat: I suspect because UndecidableInstances turns off more checks than it needs to
08:52:32 <Philippa> also: what I have in mind is really expecting, er... yeah, not to be used in that direction. I think I should go use type families instead
08:53:05 <Saizan> but if constraints were treated uniformly you should either reject test's type singnature or not give that result for :t test, all of which are indipendent of instance C T t
08:53:10 <Philippa> xplat: we're talking about this because I have a more involved case that commits the same offence
08:53:28 <Philippa> Saizan: yep
08:54:01 <Philippa> (I vote the latter, but)
08:54:28 <Philippa> really that 'feature' wants distinguishing from ordinary fundeps, I think
08:54:34 <xplat> so test :: C a x, C a y, x ~ y => a -> (x,y) ?
08:54:40 <benmachine> hey guys, I just wrote the history section here: http://www.haskell.org/haskellwiki/Monad_Transformer_Library#History I would be grateful if someone would check it for accuracy
08:54:57 <Philippa> xplat: the point is that if that instance is legit at all, you don't have x ~ y
08:55:27 <Philippa> obv. UndecidableInstances = I am free to talk bullshit :-)
08:55:28 <xplat> Philippa: i just can't see any way at all that instance could be legit, though
08:55:39 <Philippa> if you mean something that is almost but not actually fundeps
08:56:04 <Philippa> (what I really want is /just/ an inference hint)
08:57:18 <Philippa> (which would mean you can never conclude x ~ y when neither has been instantiated - which is weird behaviour too)
08:57:19 <xplat> so basically you're abusing fundeps as an extended defaulting mechanism ...
08:57:49 <Philippa> sure, I'm happy to admit that what I'm doing is an abuse and look at what I 'should' be doing (other than giving up on my WIP as impossible to make usable)
08:58:57 <xplat> well, abuse is sometimes called for, but definitely the compiler will abuse you back sometimes
08:59:30 <Saizan> mh, i guess i shouldn't be any more surprised than getting bar :: b -> b having defined bar :: a ~ b => a -> b
09:00:22 <Saizan> (though fundeps also don't give me that x ~ y to use in the body of test, only require it)
09:00:44 <Saizan> (sort of)
09:01:15 <xplat> i still can't see the semantics where it makes sense to have that type for test T, though, precisely because x ~ y should hold whenever you instantiate test T at a specific type
09:01:43 <Philippa> because you get to instantiate it twice, separately
09:02:07 <Philippa> (as it were)
09:02:15 <xplat> even if you do, they should both be homogeneous tuples
09:02:55 <Philippa> basically, if test typechecks with that type in the first place, you're SOL
09:04:05 <Saizan> we're really just exposing the constraint solving order of ghc
09:04:20 <Philippa> or rather... well, okay, we should have C a x ^ C a y ||= x ~ y, that's what we expect of the fundep, right?
09:04:54 <Saizan> yeah, if x and y are meta-vars
09:05:04 <Philippa> (and that shows up for test, which leads to the question "WTF are those constraints 'silent' for test T?")
09:05:48 <xplat> is your intended semantics that you only get C a x ^ C a y ||= x ~ y in the special cases where 'a' is a type specific enough that x would be instantiated *specifically by the fundep on C* ?
09:06:26 <Philippa> xplat: yeah. For different values of C, I'm happy to leave the 'sensible' one around
09:06:36 <xplat> but if x is instantiated only by other stuff, no constraint?
09:06:43 <Philippa> right
09:07:09 <Philippa> alternatively: it's fine if the two constraints just never interact
09:07:19 * hackagebot profunctors 3.1 - Haskell 98 Profunctors  http://hackage.haskell.org/package/profunctors-3.1 (EdwardKmett)
09:07:21 * hackagebot profunctor-extras 3.0.1 - Profunctor extras  http://hackage.haskell.org/package/profunctor-extras-3.0.1 (EdwardKmett)
09:07:55 <Philippa> Saizan: I really ought to check if v -> f p is enough!
09:08:02 <xplat> Philippa: well, those are essentially identical cases
09:08:48 <Philippa> xplat: in my offending class, v appears in the first parms of each method
09:09:05 <Philippa> also, it's not enough because I have cases where v is entirely unconstrained, so sod that
09:09:20 <Saizan> f p -> v should help there
09:09:39 <xplat> this sort of sounds like an 'optional fundep', where the fundep holds  for some choices of v but not others
09:09:51 <Philippa> xplat: yep
09:10:03 <Saizan> or just the ~ in the context trick
09:10:13 <Philippa> having instances that can generate new constraints would be neat. And, er, I think we have that now
09:10:34 <xplat> definitely sounds like a case where you want a class with an asstype for those values of v
09:11:38 <xplat> except, of course, an instance of C would overlap :(
09:12:19 * hackagebot representable-profunctors 3.1 - Representable profunctors  http://hackage.haskell.org/package/representable-profunctors-3.1 (EdwardKmett)
09:13:03 <Philippa> Saizan: I'm starting to wonder if being polykinded is about to bite me (harder) in the arse, too
09:13:09 <Philippa> but hey
09:13:26 <Philippa> (f p determines v, but how do you know where f ends and p starts?)
09:13:38 <Philippa> (bearing in mind that f p is, in fact, all you've got?)
09:13:52 <xplat> oh, but maybe a class on v with an associated constraint?  and then class (C1 v, MyConstraint v f p) => C v f p?  would that work?
09:14:24 <Saizan> Philippa: decomposition is still easy, because f can't be a type family
09:15:04 <Philippa> xplat: would it help to show you the actual class and a relevant instance?
09:15:08 <xplat> f can't even be a type synonym, it has to be a constructor
09:15:12 <xplat> Philippa: maybe?
09:16:03 <hpaste> Philippa pasted “Worst typeclass ever” at http://hpaste.org/79634
09:16:38 <Philippa> other instances include "Fix extended with a constructor for metavariables", data Id a = Id a...
09:21:39 <xplat> and you've tried it with the f p -> v fundep and GHC couldn't infer it?
09:21:47 <Philippa> er, I honestly can't remember
09:22:13 <Philippa> (I'm not regression testing properly yet: I should be)
09:24:38 <benmachine> <Philippa> (f p determines v, but how do you know where f ends and p starts?) ← the functional dependency f p -> v doesn't mean that, does it? I thought it meant that (f, p) determined v?
09:25:46 <Saizan> benmachine: it is (f, p) but the methods always have f p
09:25:55 <Saizan> benmachine: in this case
09:26:30 <benmachine> oh I see
09:27:02 <xplat> if this wasn't polykinded (like, f :: * -> *) i don't think GHC would have any problem with the f p -> v dependency, but i'm not sure exactly how reliable the polykinded stuff is
09:27:03 <Philippa> I suspect the answer is "because you didn't turn on OverlappingInstances, right?"
09:27:16 <Philippa> xplat: I've a sneaking suspicion it was... crappy previously
09:38:59 <xplat> actually, if f -> v p works at all f p -> v should work too, since it already needs to figure out f from f p to solve f -> v p
09:41:14 <foldrp> What are thos exclamations marks there? http://benchmarksgame.alioth.debian.org/u32/program.php?test=binarytrees&lang=ghc&id=1
09:41:19 <foldrp> -s
09:41:33 <foldrp> data Tree = Nil | Node !Int !Tree !Tree
09:41:36 <Philippa> xplat: point
09:41:55 <Philippa> xplat: in other news, found an embarrassing bug!
09:42:07 <osfameron> foldrp: they tell the compiler to be excited about it!
09:42:24 <foldrp> osfameron: For real? Whoa :-D
09:42:32 <simpson> foldrp: Those are strictness annotations. Those members will be evaluated when that constructor is used.
09:42:39 <benmachine> .wc
09:42:40 <benmachine> er
09:42:44 <xplat> foldrp: strictness annotations, they mean that when you build a node you automatically evaluate the three fields like in a normal programming language :)
09:42:45 <rwbarton> f p always determines f and p, regardless of polykinds, no?
09:42:59 <watermind> we always talk about the 'right' way
09:43:12 <watermind> or approach to use monads being by means of kliseli arrows
09:43:16 <foldrp> I didn't know that haskell can do this.
09:43:24 <osfameron> xplat: surely haskell *already* evaluates them like a "normal" language? ;-)
09:43:36 <watermind> but in some cases that seems like a mistake...
09:44:41 <watermind> for instance, if we're using a non-determinism monad (e.g. lists)
09:45:07 <xplat> osfameron: high \s z -> s (s (s (s (s z))))
09:45:15 <watermind> and doing operations on lists of non deterministic stuff
09:45:35 <watermind> we really want a list of non deterministic stuff as input
09:45:40 <watermind> not the resulting sequencing
09:45:50 <watermind> otherwise we have no way of avoiding repeated work
09:46:08 <osfameron> xplat: hahahahaha
09:46:23 <xplat> watermind: the list monad indeed has no way of avoiding repeated work, short of maybe memoizing all the things you use as steps
09:46:39 <wuttf> Does purity/referential transparency mean that a sufficiently smart compiler can autoparallelize my code to any number of processors?
09:46:49 <wuttf> (In the future I mean)
09:47:16 <latro`a> depends to some extent on the dependency graph that your code sets up
09:47:24 <josephle> does anyone know what the most up-to-date FRP package is?
09:47:35 <latro`a> you should not expect n-fold speedup from n processors, by any means
09:47:36 <wuttf> latro`a: Obviously.
09:47:48 <xplat> watermind: you can avoid some repeated work with the Set monad, but in haskell terms that's only a restricted monad and requires an Ord constraint at every type you use as an intermediate step
09:48:07 <Philippa> rwbarton: with polykinds you need to know where to "cut", but non-overlapping instances sorts that for you
09:48:14 <rwbarton> I don't see it
09:48:25 <rwbarton> we are talking about the type 'f p' which is the application of f to p right
09:48:28 <watermind> xplat: well yes, but sometimes you really want list :)
09:48:28 <Philippa> you hunt for an f you have an instance for, if you have it then you know the p /from that/
09:48:37 <Philippa> rwbarton: we're talking about instantiations of it
09:48:45 <rwbarton> any type that is the application of a type to another type is uniquely so
09:48:48 <Philippa> f may itself contain applications in its spine
09:48:55 <rwbarton> that doesn't matter
09:49:08 <flebron> How is this a valid equation? "go !c 0 = c"? (c Int)
09:49:16 <Philippa> *thinks* right, I'm putting the association in the wrong place, point
09:49:18 <watermind> xplat: but even with sets, consider this
09:49:32 <Philippa> (any applications inside f are /inside/ f, and that's why)
09:49:35 <wuttf> latro`a: Are there similar plans for GHC?
09:49:42 <xplat> wuttf: it does mean that, with the proviso that our favorite compilers are not quite sufficiently smart yet
09:49:43 <Philippa> app (app ...) p
09:49:46 <rwbarton> right. x y z is not x applied to anything
09:49:51 <rwbarton> the Haskell syntax obscures this
09:49:51 <rwbarton> yeah
09:49:56 <watermind> xplat: say you have a list of non-deterministic elements, and you want to sort them, obtaining a non-deterministic list of elements
09:50:22 <latro`a> afaik GHC with all the optimizations on already does this a tiny bit
09:50:26 <watermind> xplat: it doesn't matter if the non-deterministic implementation is a list or a set
09:50:29 <Philippa> rwbarton: not the stupidest thing I've become aware I've done today :-)
09:50:32 <latro`a> @ wuttf
09:50:40 <watermind> xplat: the proper way to solve this is not to sequence the list and then sort
09:50:47 <Philippa> (wait, you mean my base case accumulating a list of stuff, er, returns an empty list instead of a singleton?...)
09:50:58 <Philippa> (would that be why I'm getting empty lists back when I shouldn't?)
09:51:08 <wuttf> latro`a: I would love to read up on that!
09:51:26 <rwbarton> watermind: yeah, sounds like you want some kind of "lazy nondeterminism" (by analogy with lazy IO)
09:51:34 <rwbarton> so you can approach this problem with a pipes-type abstraction
09:51:52 <watermind> rwbarton: let me google that :)
09:52:02 <wuttf> latro`a: I guess the problem is we have too few processors and too many task to paralellize. It is hard to predict which would bring performance improvement?
09:52:04 <rwbarton> i don't think you will find any results
09:52:18 <watermind> rwbarton: you're right
09:52:29 <watermind> rwbarton: what is that?
09:54:31 <xplat> watermind: the whole approach of sorting a list of nondetermined elements sounds like a bad idea (in general you will get a list of n! results) but if anything would help it's probably LogicT?
09:55:37 <xplat> (er, you get a list of n! different *orders* in general, you may get more or fewer results)
09:55:52 <watermind> xplat: yes but, if I'm looking at things correctly, it's easy to implement it with sharing which aleviates things a bit
09:56:39 <rwbarton> watermind: well it sounds like you want to have a non-deterministic stream producer and feed its output into something that consumes it incrementally
09:56:48 <josephle> wuttf: NESL is a research language that is based on evaluating things in parallel by default: http://www.cs.cmu.edu/~scandal/nesl.html
09:56:53 <rwbarton> and won't actually branch until the stream producer needs to branch
09:57:08 <watermind> rwbarton: yeap
09:57:19 <rwbarton> that's like what a pipe in the [] monad would give you
09:57:32 <watermind> rwbarton: I have no idea what a pipe is...
09:57:37 <rwbarton> @hackage pipes
09:57:37 <lambdabot> http://hackage.haskell.org/package/pipes
09:57:46 <watermind> thanks!
09:58:04 <wuttf> josephle: Ty for the link.
09:58:33 <rwbarton> I used something like this in one of my projects, though it was before the whole iteratees/conduits/pipes craze and I had a specialized version to []
09:58:45 <josephle> wuttf: I'm not sure if it's what you're looking for, but it's some of the stuff that influenced data parallel haskell
09:59:01 <xplat> rwbarton: seems like for this particular case you could optimize much more strongly by breaking open the lists and coming up with an overall order for all the possibilities?
09:59:05 <rwbarton> watermind: also, you may be interested in the Curry programming language
09:59:27 <watermind> rwbarton: interestingly not the first time I'm suggested that
09:59:41 <watermind> I'll really have to look at it
09:59:52 <wuttf> josephle: I will stick to haskell for sure but its interesting read
10:00:05 <xplat> not sure if that would really work though since then you have to come up with slices of the overall-ordered list that include one of each position
10:00:18 <hpaste> wm pasted “sorts” at http://hpaste.org/79635
10:00:26 <josephle> wuttf: I'd recommend sticking to haskell, as nesl is a proof of concept rather than an actual language in development
10:00:31 <watermind> just to make sure I'm thinking properly here ^
10:00:34 <rwbarton> I didn't really think about the specific case of sorting
10:00:39 <watermind> the 2nd version is supposedly much better right?
10:03:14 <rwbarton> well this particular example isn't very compelling
10:03:35 <rwbarton> I'm not sure you gain more this way than you lose by using insertion sort rather than quicksort
10:03:50 <rwbarton> a simpler example would be liftM (foldr expensiveFunction e)
10:03:57 <rwbarton> er, foldl' let's say
10:04:34 <rwbarton> let's pretend (+) is a really expensive operation
10:04:55 <rwbarton> then with the second approach you can avoid recomputing partial sums of initial segments that are shared
10:05:15 <neutrino> hello
10:05:19 <neutrino> i have a question about stm
10:05:37 <watermind> rwbarton: good point
10:05:49 <neutrino> i have noticed that the implementation of "check" in stm is different than what is described in the paper that introduces "check". why is that?
10:05:51 <xplat> so basically we're doing things like liftM (foldr f) . sequence vs foldrM (return . f)
10:05:55 <watermind> rwbarton: although the sorting example is still ok if we think space rather than time
10:06:00 <Walther> I know Haskell is lazy. Is there a way I could make a list function "break" if a condition is met, while filling the list, and not continue filling that list from that onwards?
10:06:20 <Peaker> @src takeWhile
10:06:20 <lambdabot> takeWhile _ []                 =  []
10:06:20 <lambdabot> takeWhile p (x:xs) | p x       =  x : takeWhile p xs
10:06:20 <lambdabot>                    | otherwise =  []
10:06:32 <Peaker> Walther, like that?
10:07:56 <fryguybob> neutrino: The check in the stm package matches the one in "Beautiful concurrency"
10:08:08 <neutrino> fryguybob: i know
10:08:14 <neutrino> fryguybob: but it's not explained there at all
10:08:24 <Walther> Any ways of "simplifying" that?
10:08:26 <neutrino> fryguybob: why was it not implemented there like in the stm invariants paper?
10:08:37 <Walther> making it shorter, preferably oneliner-style
10:08:38 <neutrino> Walther: there.. really isn't anything to simplify
10:08:43 <neutrino> the function is very, very simple
10:09:38 <neutrino> trying to write all your code on one line sounds like several bad ideas at once
10:09:40 <neutrino> don't do it
10:09:47 <RaminHAL9001> Wlather: you could use a case statement instead, that might "simplify" it.
10:10:02 <neutrino> fryguybob: i'm simply surprised because they're two completely different functions
10:11:12 <Walther> neutrino: No, I'm not trying to write everything on one line. I have my reasons here.
10:11:20 <Walther> don't assume too much :)
10:11:23 <neutrino> what are your reasons?
10:11:29 <c_wraith> :t \p -> foldr (\x xs -> if p x then x:xs else [])
10:11:30 <lambdabot> (a -> Bool) -> [a] -> [a] -> [a]
10:11:38 <Walther> c_wraith: thanks!
10:11:39 <c_wraith> err, oops
10:11:41 <neutrino> i'm just wondering what you're trying to do, that's all
10:11:41 <c_wraith> :t \p -> foldr (\x xs -> if p x then x:xs else []) []
10:11:43 <lambdabot> (a -> Bool) -> [a] -> [a]
10:11:48 <c_wraith> that's the actual useful form :)
10:11:50 <fryguybob> neutrino: Yeah several names changed after the papers, I susspect that some of it was that the papers came before the threaded implementation.
10:12:24 <c_wraith> Walther: note that the implementation using foldr depends critically on foldr's laziness
10:12:29 <neutrino> fryguybob: that smells fishy.
10:12:29 <Walther> neutrino: I'll post a link when I get it done :P
10:12:53 <neutrino> fryguybob: it sounds like they wanted to do the invariants paper version of check, but then they couldn't find a good way, so they abandoned it and did something lazy
10:13:03 <neutrino> Walther: ok cool :)
10:13:32 <c_wraith> Walther: if foldr wasn't lazy, that implementation would evaluate the entire list, regardless of whether the predicate ever failed
10:14:01 <c_wraith> > (\p -> foldr (\x xs -> if p x then x:xs else []) []) (<10) [1..]
10:14:02 <lambdabot>   [1,2,3,4,5,6,7,8,9]
10:15:21 <neutrino> i think what you want is foldl
10:15:41 <neutrino> foldr evaluates the list elements before it evaluates the operator
10:16:45 <c_wraith> neutrino: who is that in response to?
10:16:53 <neutrino> you c_wraith
10:17:04 <c_wraith> foldr never evaluates the elements
10:17:17 <hpaste> neutrino pasted “folds” at http://hpaste.org/79636
10:17:20 * hackagebot pretty-show 1.3.1 - Tools for working with derived Show instances.  http://hackage.haskell.org/package/pretty-show-1.3.1 (IavorDiatchki)
10:17:33 <c_wraith> > length $ foldr (:) [] [undefined, undefined, undefined]
10:17:35 <lambdabot>   3
10:17:42 <neutrino> check this out c_wraith
10:17:58 <neutrino> i guess you're right though, we're talking about different things
10:18:15 <c_wraith> I think so
10:19:54 <neutrino> check out lines 278 and 310
10:20:05 <neutrino> that's the difference i meant
10:21:58 <c_wraith> Whereas I was talking about things like...  rtrim = foldr (\x xs -> if isSpace x && null xs then "" else x:xs) []
10:22:20 <c_wraith> Which works on infinite lists...  unless it ends with infinite whitespace.
10:23:03 <DrChaos_> is it possible to make an operating system kernel almost entirely in haskell? Or maybe make GNU Mach (Hurd) servers entirely in haskell?
10:23:41 <Walther> Another thing; what is going wrong here: noModulos x = x not elem(map (`mod` 2) [2..x])
10:23:55 <neutrino> c_wraith: mhm
10:23:58 <neutrino> :t null
10:23:59 <lambdabot> [a] -> Bool
10:24:06 <neutrino> @src null
10:24:06 <lambdabot> null []     = True
10:24:07 <lambdabot> null (_:_)  = False
10:24:45 <c_wraith> but really, can you blame rtrim for taking infinite time to trim infinite whitespace?
10:26:43 <Walther> ohwait i'm thinking wrong
10:26:43 <Walther> bbl
10:28:21 <ClaudiusMaximus> DrChaos_: yes, "house", and there's "halvm" (? might have name wrong) that runs haskell as a xen vm or something
10:28:36 <ClaudiusMaximus> but i never tried them
10:28:42 <c_wraith> I believe halvm is correct
10:28:50 <DrChaos_> what is house?
10:29:07 <ClaudiusMaximus> operating system in haskell
10:31:07 <DrChaos_> oh
10:31:23 <fryguybob> neutrino: The check from the invariant paper is `checkInv` (which uses `check#`) and is used to build `always` and `alwaysSucceeds`.
10:33:02 <DrChaos_> it would be nice to work on hurd servers written in haskell
10:36:48 <bobry_> A quick conduit question: is there an easy way to slice binary stream into fixed-size chunks? I thought isolate is the function I need, but it turns out it only takes the first chunk and drops the rest.
10:38:16 <neutrino> fryguybob: ohh, ok let me try
10:38:23 <neutrino> @hoogle always
10:38:24 <lambdabot> Graphics.Rendering.OpenGL.GL.PerFragment Always :: ComparisonFunction
10:38:24 <lambdabot> GHC.Conc.Sync always :: STM Bool -> STM ()
10:38:24 <lambdabot> GHC.Conc always :: STM Bool -> STM ()
10:38:27 <neutrino> @hoogle alwaysSucceeds
10:38:27 <lambdabot> GHC.Conc.Sync alwaysSucceeds :: STM a -> STM ()
10:38:27 <lambdabot> GHC.Conc alwaysSucceeds :: STM a -> STM ()
10:38:27 <lambdabot> Control.Monad.STM alwaysSucceeds :: STM a -> STM ()
10:38:32 <neutrino> @hoogle checkInv
10:38:32 <lambdabot> No results found
10:38:40 <neutrino> @hoogle check#
10:38:40 <fryguybob> neutrino: It isn't exported.
10:38:40 <lambdabot> No results found
10:38:45 <neutrino> fryguybob: ahh
10:39:02 <neutrino> fryguybob: any idea why it isn't?
10:39:52 <fryguybob> I suppose in practice when an invariant doesn't hold you want to give an oportunity to try something else right away.  This is the behavior of `always`
10:42:30 <dgpratt> I guess I don't understand the point of fmapDefault (in Data.Traversable)
10:42:30 <[PY]> Is Haskell actually worth learning for AI?
10:42:58 <dgpratt> the doc for fmapDefault says "This function may be used as a value for fmap in a Functor instance..."
10:43:08 <neutrino> [PY]: are barrels better built with red or blue hammers?
10:43:30 <shachaf> dgpratt: Not much point to it as such. If you define an instance of Traversable for your class, you can write instance Functor Foo where fmap = fmapDefault.
10:43:32 <neutrino> fryguybob: amazing, thanks for tipping me off
10:43:40 <shachaf> It's partly there to justify the Functor superclass.
10:43:59 <wunki> anyone here have any experience with the rust language from mozilla?
10:46:35 <nicelyq> Hello. How can I write something in the point free style when the arguments in inside another application? foo (bar x y) for example
10:47:13 <dgpratt> shachaf: ooooh...for some reason I didn't consider the possibility that a Functor instance could both justify and depend upon a Traversable instance
10:47:20 <parcs> nicelyq: (foo .) . bar
10:47:37 <DrChaos_> foo $ bar x y I think
10:47:41 <Philippa> nicelyq: (n-ary) function composition
10:48:00 <Philippa> DrChaos_: that has x and y in it, so it's not pointless :-)
10:48:11 <Philippa> @pl foo (bar x y)
10:48:11 <lambdabot> foo (bar x y)
10:48:17 <bstrie> wunki: I do, a bit
10:48:22 <Philippa> d'oh
10:48:27 <Philippa> @pl \x y -> foo (bar x y)
10:48:28 <lambdabot> (foo .) . bar
10:48:36 <Walther> Could someone help me with this: funct x y = [x | x <- map (`mod` y) [3..x], 0 not elem x]
10:48:37 <nicelyq> parcs: I'm familiar with function composition, but what does it mean when it's at the end of parens like that?
10:48:45 <wunki> bstrie: what's your opinion on it?
10:49:52 <parcs> nicelyq: (foo .) is called a section. it's shorthand for (\g -> foo . g)
10:50:28 <parcs> nicelyq: you can also do (. foo), which is (\g -> g . foo). this works with any operator
10:52:56 <Jafet> :t (.:)
10:52:58 <lambdabot> (Functor g, Functor f) => (a -> b) -> f (g a) -> f (g b)
10:53:32 <Jafet> :t (.:) `asTypeOf` (.)(.)(.)
10:53:33 <lambdabot> (Functor g, Functor f) => (a -> b) -> f (g a) -> f (g b)
10:53:40 <Jafet> "Thanks"
10:53:45 <nicelyq> parcs: is that a specific syntax, separate to ., or is it just a nice way to use .?
10:53:58 <Jafet> > (1 +) 2
10:54:00 <lambdabot>   3
10:54:00 <Philippa> nicelyq: you can do it for all operators
10:54:05 <parcs> > map (`elem` [1..10]) [2,4,10,20]
10:54:06 <lambdabot>   [True,True,True,False]
10:54:28 <Philippa> I always forget about backtick sections though! I should use them more often
10:54:55 <Philippa> I mean, LHS sections are just cute for many names? RHS ones are damn useful
10:55:33 <Jafet> You just need to hate parentheses more
10:55:38 <Jafet> It comes naturally
11:03:21 <fryguybob> neutrino: Looking at the invariants paper again I think that `always` is exactly the `check` there.
11:04:52 <fryguybob> neutrino: Oops, I mean `alwaysSucceeds` is `check` from the paper.
11:07:43 <neutrino> fryguybob: http://functionalpapersupdated.wikia.com/wiki/Transactional_memory_with_data_invariants
11:07:50 <neutrino> here, i started it
11:07:59 <neutrino> now everyone put your favourite papers in here :p
11:10:12 <fryguybob> neutrino: I'm currently working on filling out the GHC commentary with regard to STM.
11:11:09 <neutrino> fryguybob: it's like almost every paper needs an update like this
11:12:18 <fryguybob> Well there isn't anything wrong with the paper, it just doesn't happen to match exactly what is in the library :P
11:12:42 <neutrino> yep
11:12:48 <neutrino> that's the reason for existance
11:13:22 <neutrino> also, another paper I was reading was the original stm one, where they talk about how multithreading is not in yet but they're working on it? that could go under "developments" i guess
11:14:32 <neutrino> fryguybob: i wonder, is there anything specific one needs to do to let others edit that wiki?
11:14:41 <neutrino> fryguybob: can you try?
11:16:02 <Jafet> ...are new sites on wikia still manually approved?
11:16:16 <neutrino> i just started this one without waiting for approval
11:16:21 <neutrino> so i guess not
11:16:27 <Jafet> Hmm
11:18:43 <fryguybob> neutrino: It seemed to be happy with my edit.
11:22:10 <neutrino> fryguybob: thanks =)
11:24:43 <Walther> I have this function: funct x y = map (`mod` y) [1..x]
11:27:04 <Walther> How can I make it so that the y can also be a list; as in, for the function to return me a list of modulo lists
11:27:07 <Walther> with different values of y
11:27:22 * hackagebot cpython 3.1.4 - Bindings for libpython  http://hackage.haskell.org/package/cpython-3.1.4 (JohnMillikin)
11:28:13 <Jafet> [ funct x y | y <- ys ]
11:29:34 <t7_> you need a map baby
11:30:09 <t7_> i guess i left my laptop on at work
11:31:31 <Walther> Jafet: uh, how do I embed that to the funct I already have
11:31:43 <Walther> sorry, a complete newbie with tons of interest in Haskell though
11:31:50 <parcs> > let x = 10; y = 20 in mod <$> [1..x] <*> y
11:31:51 <lambdabot>   No instance for (GHC.Num.Num [b0])
11:31:51 <lambdabot>    arising from a use of `e_110201'
11:31:52 <lambdabot>  Pos...
11:32:06 <parcs> > let x = 10; y = 20 in [mod] <*> [1..x] <*> y
11:32:07 <lambdabot>   No instance for (GHC.Num.Num [b0])
11:32:08 <lambdabot>    arising from a use of `e_110201'
11:32:08 <lambdabot>  Pos...
11:32:14 <parcs> fak
11:32:57 <Walther> yeah :P
11:33:12 <parcs> > let x = 10; y = [1..20] in [mod] <*> [1..x] <*> y
11:33:14 <lambdabot>   [0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,...
11:33:56 <parcs> if you want a list of modulo lists, then use map twice
11:34:27 <Walther> parcs: that looked like a long list of modulos, and had repetitiveness
11:35:30 <parcs> Walther: it's every element of [1..10] modded by every element of [1..20]
11:35:48 <Jafet> > catMaybes $ map (<|> pure "baby") [Nothing, Nothing, Nothing, Just "oh"] -- t7
11:35:50 <lambdabot>   ["baby","baby","baby","oh"]
11:36:02 <t7_> nice
11:36:17 <Walther> ohgod :D
11:36:33 <Peaker> > map (fromMaybe "baby") [Nothing, Nothing, Nothing, Just "oh"]
11:36:35 <lambdabot>   ["baby","baby","baby","oh"]
11:37:04 <t7_> @hoogle (<|>)
11:37:04 <lambdabot> Control.Applicative (<|>) :: Alternative f => f a -> f a -> f a
11:37:04 <lambdabot> Text.Parsec.Prim (<|>) :: (ParsecT s u m a) -> (ParsecT s u m a) -> (ParsecT s u m a)
11:37:04 <lambdabot> Text.ParserCombinators.Parsec.Prim (<|>) :: (ParsecT s u m a) -> (ParsecT s u m a) -> (ParsecT s u m a)
11:37:12 <t7_> what is this reverse monad
11:37:22 * hackagebot cpython 3.2.0 - Bindings for libpython  http://hackage.haskell.org/package/cpython-3.2.0 (JohnMillikin)
11:37:24 * hackagebot cpython 3.3.0 - Bindings for libpython  http://hackage.haskell.org/package/cpython-3.3.0 (JohnMillikin)
11:37:26 <Peaker> t7, Reverse monad?
11:37:39 <Jafet> fromBaby
11:38:28 <neutrino> wait, so there IS a python ffi?
11:38:33 <neutrino> how did i miss that?
11:39:05 <t7_> its like bind except it ignores errors
11:39:26 <t7_> > Just 1 `mplus` Just 2
11:39:28 <lambdabot>   Just 1
11:39:38 <t7_> > Just 1 <|> Just 2
11:39:39 <lambdabot>   Just 1
11:39:59 <t7_> ignore me
11:46:02 <Twernmilt> Hello, I'm trying to use the Cairo and GTK Haskell packages and I'm getting an assertion failure from Cairo. Can anyone point me in the right direction to fix  it? The code and error message are in this gist: https://gist.github.com/4323331 . I'm on OSX and GHC 7.4.2
11:47:09 <Twernmilt> The first document is the code from GtkHs's tutorial. The second document is my attempt to fix it.
11:49:49 <PthariensFlame> Twernmilt:  I had no problems at all on OS X once I'd installed GTK+ via macports.
11:50:44 <Twernmilt> PthariensFlame: Hrm, I'm using Homebrew
11:51:01 <Twernmilt> I have gtk+-2.24.11
11:57:23 <simon> is there a function in the standard library that permutes a list's elements according to a list of positions to be interchanged, [(Int,Int)]?
11:57:38 <simon> (or Integer, not specific.)
12:00:07 <PthariensFlame> Could be:  \xs -> map ((xs !!) . snd) . (sort `on` snd)
12:00:34 <watermind> simon: I don't think so, but that is not enough of a specification, you need to say how that list is supposed to be consumed, left to right or right to left
12:01:30 <simon> watermind, right. only single pairs of elements are permuted once.
12:02:27 <watermind> simon: [(1,2), (2,3)]    and   [(2,3),(1,2)]
12:02:39 <parcs> > let changes = [(0,1),(1,2),(2,0)]; list = [1,2,3] in map fst $ sortBy (comparing snd) (zip list (map snd (sortBy (comparing fst) changes)))
12:02:40 <lambdabot>   [3,1,2]
12:02:48 <watermind> simon: if you swap 1 and 2 first and then 2 and 3, it is different from if you do it the other way around
12:03:01 <watermind> I suppose you want left to right, but not sure
12:03:06 <eacameron> I'm sure there is a way to do this nicely, but I can't find it/figure it out: I want to take a series of steps in the Maybe monad and convert each one to a step in the (Either a) monad where each step may fail with an error message. All my functions are in the Maybe monad, but I want to compose them such that I can assign a failure message to each one and get an Either a b back.
12:03:08 <watermind> or maybe I'm missing something
12:03:47 <simon> watermind, I understand what you mean, but it won't happen in my case. e.g. [(1,2),(2,3)] won't occur, since there are no overlaps in pairs.
12:03:55 <watermind> simon: right ok then
12:03:55 <simon> PthariensFlame, thanks for the hint! :)
12:04:08 <Walther> still can't figure it out
12:04:08 <Walther> funct x y = map (`mod` map [2..y]) [2..x]
12:05:30 <Walther> i want a list of lists of modulos/remainders
12:05:40 <parcs> funct x y = map (\a -> map (\b -> a `mod` b) [2..y]) [2..x]
12:09:27 <hpaste> lispy pasted “Haskell Spoken Here -- Apologies to Warren Zevon” at http://hpaste.org/79637
12:09:33 <Walther> parcs: thanks!
12:19:00 <Walther> Is it possible to have a funct x y = (fuction stuff here) [1..z] where z = (smaller of x,y)
12:19:13 <ion> yes
12:22:44 <Peaker> Walther, smaller of x and y is an easy function to write :)
12:24:29 <Walther> derp, i'm not thinking clearly
12:24:38 <Walther> where z = min x y
12:24:57 <Walther> that's what you get for ssitting in a train for 6h straight
12:27:23 <Walther> Hmm... still having problems
12:27:42 <Walther> funct x y = map (\a -> map (\b -> a `mod` b) [1..(min x y)]) [1..x] --- this works, but it doesn't take the (min) progressively
12:27:52 <Walther> as in, I don't get a couple shorter lists first and then longer ones
12:30:13 <Twisol> Walther: what do you mean by "progressively"?
12:31:06 <Walther> Twisol: it only takes the min x y for the initial values of x,y; not the ones coming from the list
12:31:29 <Walther> ...i'm not sure if I can explain myself
12:31:53 <djahandarie> a and b are coming from the lists, x and y are constant for that entire function.
12:32:12 <Twisol> you might want (min a b) or something like that
12:32:21 <Twisol> those are the only ones changing within your maps
12:32:22 <Walther> would it work with min (a, b) ?
12:32:23 <djahandarie> b is not in scope for that list, so no.
12:32:25 <Peaker> > let f x y = mod <$> [1..min x y] <*> [1..x] in [f 5 3, f 7 2]
12:32:26 <lambdabot>   [[0,1,1,1,1,0,0,2,2,2,0,1,0,3,3],[0,1,1,1,1,1,1,0,0,2,2,2,2,2]]
12:32:26 <Walther> Ooooooh
12:32:27 <Walther> smart
12:32:58 <Twisol> (min a x) or (min a y) then
12:33:03 <Peaker> Walther, you might like list comprehension syntax
12:33:06 <djahandarie> Peaker, I think that may be a little advanced?
12:33:15 <Walther> Not in scope: `b'
12:33:17 <Peaker> djahandarie, I just wanted to look at the result he's talking about
12:33:56 <Peaker> map (\a -> expression of a) [some range]      can be written as:   [expression of a | a <- [ some range ]]
12:33:59 <Twisol> Walther: because, like djahandarie pointed out to me, b isn't in scope at the point you're using min
12:34:38 <Twisol> Walther: what is this code meant to accomplish?
12:35:00 <Walther> also, sorry, my net is lagging as hell, so my responses might come later than your replies to my previous questions
12:35:12 <Walther> i'm on a train, ping varies from 500ms to 20s
12:35:48 <djahandarie> I recommend using mosh to connect to a terminal somewhere, then connecting to IRC from there, if you're often on trains / on bad connections.
12:36:13 <Walther> Twisol: A list of modulos of number x by all 1..y, but obviously I don't want any repetitive remainders in a single list
12:37:07 <Walther> djahandarie: sure, I'm ssh'd to a server - hence you don't see any quit/joins from me ;)
12:37:21 <djahandarie> Use mosh.
12:37:51 <Twisol> Walther: You can use the nub function from Data.List to filter out duplicates after the fact
12:38:17 <Twisol> > nub [1,2,2,3,3,3,4,1,4,5,6]
12:38:20 <lambdabot>   [1,2,3,4,5,6]
12:38:38 <djahandarie> 'tis slow, though.
12:39:17 <Walther> yeah. I don't want slow for this.
12:39:35 <djahandarie> Walther, could you give an example output for a simple input?
12:39:36 <Twisol> slow is a good place to start until it works.  :)
12:39:43 <Walther> N o[B[B[B[B[BNo sense creating a big list first and then filtering, if it can be done the right way with the (min something, something else)
12:43:20 <Walther> I'll try to make this more towards my goal, will ask more questions when necessary and post a link to the code when I get it ready
12:43:50 <Walther> I'm doing this little function mainly for learning
12:45:29 <djahandarie> Okay. The right way to think about it is to think about the function as a series of transformations to your initial input.
12:51:07 <Walther> ...also, now i'm trying to accomplish the goal by making the whole thing recursive
12:51:16 <djahandarie> I'd stick with lists.
12:51:27 <Walther> might be helpful in this case, also helps me understand recursive definitions
12:51:33 <djahandarie> Lists have all the recursion that you need 'built-in' to them.
12:51:56 <djahandarie> You could do it explicitly as an exercise, but that may be more annoying.
12:52:06 <Walther> welp, i'm just trying to invent the wheel in a dozen different ways
12:52:12 <Walther> to learn Haskell
12:52:29 <hpaste> ciphergoth pasted “ No instance for (RealFrac Int) arising from a use of `floor'” at http://hpaste.org/79640
12:53:54 <c_wraith> ciphergoth: throw in a fromIntegral...  floor (sqrt (fromIntegral a))
12:54:16 <ciphergoth> c_wraith: that makes sense, but what's weird is that it works in ghci
12:54:51 <c_wraith> ciphergoth: the reason it doesn't work in ghc is the type signature on rooteBetween
12:55:04 <ciphergoth> ah
12:55:05 <c_wraith> *rootsBetween
12:55:35 <ciphergoth> I confess I am not much wiser
12:56:02 <ciphergoth> It knows how to do sqrt 2342342 but not sqrt a where a is some Int?
12:56:14 <c_wraith> numeric literals are polymorphic
12:56:28 <c_wraith> if you say to do sqrt 5, it assumes 5 is a Double
12:56:31 <ciphergoth> aha!
12:56:32 <djahandarie> @type 5
12:56:34 <lambdabot> Num a => a
12:56:45 <ciphergoth> *light dawns*
13:04:29 <Peaker> sanity test: There should be no difference between  (on Foo Bar) and (Foo `on` Bar), right?
13:04:48 <Peaker> I think I'm seeing a difference between these two in the face of rank2 types
13:05:16 <Twisol> I thought the latter was just syntactic sugar.
13:05:26 <rwbarton> sounds like the "runST $ ..." hack
13:05:31 <Peaker> exactly! very weird.. maybe GHC bug?
13:05:36 <rwbarton> not really that weird
13:05:53 <Peaker> infix gets treated differently with rank2??
13:06:04 <rwbarton> ghc's rank 2 type inference is not complete
13:06:35 <rwbarton> and there is some particular heuristic that depends on the order of terms in an expression, I believe
13:07:07 <rwbarton> > runST $ return 3
13:07:08 <lambdabot>   3
13:07:11 <rwbarton> > id runST (return 3)
13:07:13 <lambdabot>   Couldn't match expected type `forall s. GHC.ST.ST s a0'
13:07:13 <lambdabot>              with a...
13:07:29 <rwbarton> so yeah, it is more of an unfortunate but expected limitation
13:07:48 <rwbarton> you should be able to add type signatures to make (on Foo Bar) and (Foo `on` Bar) behave the same
13:07:53 <Twisol> If I have a typeclass that defines some additional actions for a monad, is it possible to automatically lift them through an arbitrarily-sized transformer stack? Right now I have to redefine it manually for every layer of my stack, and they're all just "x a b = lift $ x a b"
13:09:51 <Peaker> Twisol, that's precisely what the mtl classes do
13:10:01 <Peaker> rwbarton, ok, thanks
13:10:06 <Peaker> rwbarton, that resolves it
13:10:39 <rwbarton> though actually I'm not sure how to do it for "id runST (return 3)"
13:11:07 <Peaker> maybe define an "id" with a type sig with the explicit rank2s?
13:11:09 <Twisol> Peaker: I knew State and co. could do it, but I haven't been able to find the relevant source yet. :(
13:11:40 <Peaker> Twisol, you can instantiate your type-class for every concrete monad in existence (the O(N^2) mtl approach)
13:11:44 <shachaf> rwbarton: Remember the time when «id runST (return 3)» worked but «(id runST) (return 3)» didn't?
13:11:45 <Peaker> Twisol, then it will lift through
13:11:47 <shachaf> Those were the days.
13:11:55 <Twisol> Peaker: well, uh, that's what I'm doing now. :|
13:12:05 <rwbarton> and now what, neither works? :)
13:12:14 <shachaf> Yep.
13:12:16 <shachaf> Consistency!
13:12:22 <rwbarton> > (id runST) (return 3)
13:12:24 <lambdabot>   Couldn't match expected type `forall s. GHC.ST.ST s a0'
13:12:24 <lambdabot>              with a...
13:12:25 <Peaker> does ghc keep syntactic hints for the type-checker? or does it work on early syntactic form?
13:12:26 <Twisol> Peaker: manually creating an instance for every layer of my transformer stack
13:12:34 <Peaker> working on the pre-parens layer sounds nuts
13:13:00 <rwbarton> good question
13:13:13 <hpaste> k00mi pasted “Specialization in where binds” at http://hpaste.org/79642
13:13:29 <Peaker> Twisol, that's the mtl approach... you could possibly abuse fundeps to do it
13:13:43 <shachaf> Peaker: It's probably an "arity" thing.
13:13:55 <Twisol> well.. I just found a way, but I have to use FlexibleInstances, FlexibleContexts, and UndecidableInstances
13:13:56 <k00mi> in that example i posted, why is foo' specialized to the Bool instance of Foo and how can I avoid that?
13:14:01 <shachaf> Hmm, maybe it worked on with the parentheses.
13:14:06 <shachaf> That would make more sense.
13:14:10 <Twisol> Peaker: instance (Telnet t, MonadTrans m, Monad (m t)) => Telnet (m t) where
13:14:59 <rwbarton> I'm not sure it makes more sense, it's sort of good for the compiler to see that it is applying runST to (return 3) as quickly as possible
13:15:17 <rwbarton> maybe the paren-free version helps with that it if it sees the whole expression as a single function application? who knows
13:21:54 <beaky> hello
13:22:06 <beaky> how do I do imperative programming in HS?
13:22:21 <beaky> haskell*
13:22:46 <zomg> do-notation is sort of like that I guess
13:22:51 <beaky> ah
13:22:56 <beaky> I want to write a simple roguelike
13:23:43 <zomg> So what's the problem that you'd need to solve by using an imperative approach?
13:23:51 <beaky> lots of IO actions :D
13:23:57 <beaky> like moving entities around a grid
13:24:11 <Twisol> the only inherently IO part of that is putting the grid on the screen, just FYI
13:24:14 <beaky> oh
13:24:28 <beaky> so I need to figure out the functional way of playing Rogue? :D
13:24:29 <Twisol> not that you couldn't do it how you're suggesting!
13:24:42 <neutrino> beaky: do blocks are for imperative c-like syntax programming.
13:25:20 <beaky> http://jamiltron.com/2012/07/Code_Us_Some_Roguelike_in_Haskell.html ah
13:25:38 <beaky> do blocks, do blocks everywhere :D
13:25:40 <Nereid> neutrino: that's misleading!
13:25:59 <neutrino> Nereid: which part, "imperative" or "c-like"?
13:26:12 <Nereid> well, a bit of both.
13:26:25 <Nereid> there's nothing imperative or c-like about monads
13:26:38 <ion> He only talked about syntax, though.
13:26:45 <Twisol> I think the only c-like thing about do-notation is that you have things that look like statements each on a line
13:26:57 <Nereid> yeah, ok, if you squint.
13:27:12 <neutrino> or if simon peyton-jones squints whom i quoted there
13:27:21 <neutrino> pro squinter
13:27:30 <beaky> lol
13:27:41 <beaky> alright I will try to port my roguelike from python to haskell
13:27:55 <neutrino> that might be more difficult than you think
13:27:57 <Twisol> enjoy the experience
13:28:00 <beaky> hehe
13:28:06 <neutrino> a roguelike is not the best beginner program in haskell
13:28:09 <beaky> it was originally in C
13:28:15 <beaky> then I ported it to Python
13:28:15 <Twisol> nor, as I've learned, is a Telnet implementation
13:28:36 <beaky> now haskell is my favorite programming language, so I will port it to that :D
13:28:44 <beaky> how hard can it be?
13:28:46 <neutrino> yeah, actually python and c are better fits for this sort of thing if you want to use the basic features of a language only
13:28:48 <Twisol> famous last words
13:29:08 <strebe> a friend of mine wrote a roguelike in haskell last weekend
13:29:14 <neutrino> sure
13:29:18 <neutrino> it can be done
13:29:26 <neutrino> but it's like fib and haskell
13:29:34 <neutrino> or quicksort
13:29:37 <strebe> neutrino: a good excuse to memoize? :-)
13:29:41 <djahandarie> It can be done easily too. But that doesn't mean it'll be easy for everyone who tries to do it.
13:30:21 <strebe> beaky: you'll want to wean yourself off the dependence on imperative coding first
13:30:29 <beaky> haskell is the more elegant than C, and more efficient than Python
13:30:41 <beaky> but I just need to learn the functional way :D
13:30:44 <strebe> beaky: kind of, but "you can write fortran in any language"
13:30:54 <strebe> imperative programming is rarely an elegant way to do things in haskell
13:31:14 <beaky> some routines are inherently imperative though :(
13:31:19 <beaky> like quicksort :D
13:31:26 <Twisol> the functional way is anything but a "just" - it's a wholly different paradigm than C or Python
13:31:32 <djahandarie> beaky, "how do I do imperative programming" is not the right question to ask if you're trying to learn functional programming. ;)
13:31:35 <Twisol> beaky: I beg to differ. :D
13:31:48 <Twisol> beaky: http://www.haskell.org/haskellwiki/Introduction#Quicksort_in_Haskell
13:31:57 <strebe> beaky: you can do a pure quicksort, it's just not in-place, destructive, or quite as fast
13:32:03 <beaky> ah
13:32:03 <djahandarie> That's not quicksort, that's slowsort.
13:32:42 <strebe> and yes, some things -are- inherently imperative: but far fewer than you'd think
13:32:43 <beaky> also functional programming probably buys a roguelike many cool stuff
13:32:48 <beaky> like purely-functional data structures
13:33:04 <strebe> beaky: only if you actually do functional programming, though; using haskell imperatively doesn't grant that :-
13:33:10 <beaky> oh
13:33:34 <Twisol> plus, using Haskell imperatively isn't really using Haskell in isolation from functional idioms
13:33:41 <Twisol> so if you try to put the functional stuff to the side, you'll have a tough time
13:38:12 <hvr> m3ga: ping
13:38:37 <m3ga> hvr: hi! wanted to thank you for deepseq-th
13:39:00 <hvr> m3ga: np, but please try to use deepseq-generics
13:39:18 <hvr> m3ga: it generates almost the same code
13:39:29 <hvr> but works for more types
13:39:37 <m3ga> ok, i'll look at that too
13:40:11 <m3ga> had a program reading 75 meg of csv data using csv-conduit and doing some statistics. it was chewing up all 8G of memory and > hour to run.
13:40:47 <m3ga> a couple of derviveNFData and a couple of $!! and now it runs in 2 min and uses < 8Meg
13:41:46 <Hafydd> I hope I can stop myself from laughing when I have to pronounce "$!!" verbally.
13:42:03 <hvr> Hafydd: "dollar bang bang"? :)
13:42:10 <Hafydd> Yes.
13:42:12 <m3ga> thats the way i say it
13:42:16 <mikeplus64> hvr: what difference is there for deepseq-generics and deepseq-th? wouldn't the th one be more efficient because with generics you have to make the data "generic", then deepseq it, and then "put it back"?
13:42:58 <hvr> mikeplus64: curiously, GHC is able to optimize the code so that I didn't find many differences
13:43:27 <m3ga> hvr: i'll test it out with my example real soon
13:43:28 <mikeplus64> weird, and nice i guess, i wonder what optimizations there are specifically for generics
13:43:38 <hvr> mikeplus64: (the exception is this GHC bug: http://hackage.haskell.org/trac/ghc/ticket/7360)
13:44:26 <hvr> mikeplus64: but you'll have to try hard to come up with a benchmark where deepseq-th performs significantly better than deepseq-generics
13:45:05 <hvr> mikeplus64: `seq`s compile down to 'case'-expressions in core, for which GHC has quite a bit of optimizations
13:45:16 <mikeplus64> hvr: even with big nested data structures, it's about the same?
13:45:24 <mikeplus64> that's interesting
13:45:32 <hpc> i thought seq was primitive
13:45:57 <hvr> hpc: it's bascially core's "case" :-)
13:46:09 <hpc> ah
13:46:45 <hvr> for instance, GHC is able to optimize away redundant 'seq's
13:47:00 <hvr> such as trying to seq a strict field
13:47:10 <eacameron> is it a bad idea to manually call "fail" in a Monad?
13:47:41 <hpc> sometimes
13:47:45 <hpc> or even usually
13:47:48 <hpc> but not quite always
13:47:59 <hpc> see: Parsec, IO, ErrorT
13:49:58 <hvr> mikeplus64: btw, I was surprised myself that the code generated by the Generics based derivation was comparable to the TH-based  one
13:50:46 <m3ga> hvr: confirmed. generics just as fast as th version.
13:50:57 <m3ga> for my code example anyway.
13:51:05 <Philippa> eacameron: it's better than calling error
13:51:24 <hvr> m3ga: I've got more confidence about the deepseq-generics btw, the implementation is much simpler :-)
13:51:38 <mikeplus64> does ghc somehow inline it enough to see that you aren't really interested in converting data to/from generic representations or something?
13:51:39 <m3ga> cool. i'll use that
13:51:48 <mikeplus64> (i'll take a look at the core myself i guess)
13:52:16 <hvr> mikeplus64: something like that... I'd have to re-read the generics paper as I've forgotten the details
13:53:34 <dreixel> m3ga: good to hear that
13:53:43 <hvr> mikeplus64: after all, the Generics data-structures are known statically at compile time, so the compiler in theory knows everything it needs to optimize
13:53:46 <beaky> alright here is my go on a haskell roguelike: http://ideone.com/WvuZPh
13:53:51 <beaky> anyone willing to criticize my style? :D
13:53:58 <beaky> is it functional?
13:55:05 <mikeplus64> pleasantly surprising
13:55:25 <beaky> questions on the record syntax: can I have other functions of the same name as the field accessors in the record structures?
13:56:04 <Adeon> where's the amulet of yendor in this roguelike
13:56:17 <beaky> lol
13:56:21 <beaky> alright I will add it
13:56:27 <beaky> what symbol does an amulet look like?
13:56:31 <Adeon> "
13:56:33 <beaky> ah
13:57:08 <thoughtpolice> hpc: and FYI, the reason seq = case is because at the core level, the only distinction between lazy/strict bindings is let/case - let is lazy binding, case is a strict one (which is why sometimes at the core level you may see 'case' where there's only one possible branch)
13:57:13 <dreixel> m3ga, hvr: this is silly, I cannot access my webpage from this computer, so I can't provide you with a link. But google for "optimisation of generic programs through inlining"
13:57:31 <dreixel> and you'll get a draft paper where I explain why the performance of things such as deepseq-generics should be as good as handwritten code
13:57:45 <m3ga> nice!
13:57:54 <hvr> dreixel: now that I think of it, it's bascially constructor specialization during inlining, isn't it?
13:58:05 <m3ga> @google optimisation of generic programs through inlining
13:58:08 <lambdabot> http://dreixel.net/research/pdf/ogpi_draft.pdf
13:58:08 <lambdabot> Title: Optimisation of Generic Programs through Inlining
13:58:18 <dreixel> yes, that's it, m3ga
13:58:29 <dreixel> hvr: yes, pretty much.
13:58:30 * hvr goes reading that paper
13:58:33 <dreixel> and case-of-case, etc.
13:58:43 <startling> what's the way to write a QuickCheck Gen fora recursive structure that makes the children shrink in size?
13:59:07 <mikeplus64> dreixel: cool!
13:59:33 <dreixel> :)
13:59:38 <rtharper> dreixel is kind of a cool dude
13:59:48 <dreixel> ahah rtharper
14:00:03 <m3ga> dreixel: i know you! :-)
14:00:21 <eacameron> Philippa: how do I get the error string from a monad that failed?
14:00:37 <zhulikas> did apocalypse already start?
14:00:37 <dreixel> m3ga: oh, cool, do I know you too? :)
14:00:46 <dreixel> zhulikas: it's over, you missed it
14:00:51 <zhulikas> awww :|
14:00:53 <zhulikas> damn it.
14:01:11 <m3ga> dreixel: we met very briefly at icfp (i'm erik de castro lopo)
14:01:29 <dreixel> m3ga: ah, yes!
14:01:41 <beaky> @hoogle a -> [[a]] -> [a]
14:01:42 <lambdabot> Data.List intercalate :: [a] -> [[a]] -> [a]
14:01:42 <lambdabot> Data.List intersperse :: a -> [a] -> [a]
14:01:42 <lambdabot> Data.List insertBy :: (a -> a -> Ordering) -> a -> [a] -> [a]
14:03:13 <mikeplus64> > let interthing x xs = intercalate [x] xs in interthing 'a' (words "a b c d e")
14:03:15 <lambdabot>   "aabacadae"
14:04:01 <lightquake> > intersperse 'a' (words "a b c d e")
14:04:03 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
14:04:03 <lambdabot>              with actual type...
14:04:05 <lightquake> oh right
14:04:20 <lightquake> @type intersperse
14:04:22 <lambdabot> a -> [a] -> [a]
14:05:31 <eacameron> Philippa: Looks like fail = error :(
14:05:45 <mikeplus64> eacameron: in IO, yeah
14:06:08 <mikeplus64> > do { Just x <- Just y; fail "what" }
14:06:10 <lambdabot>   Couldn't match expected type `Debug.SimpleReflect.Expr.Expr'
14:06:10 <lambdabot>              w...
14:06:17 <mikeplus64> (what)
14:06:24 <downton> I want to see if all values in foo are less than x, so I wrote 'all (< x) foo', but does that actually mean x is less than all values in foo? I'm very confused now.
14:08:49 <Twisol> downton: you have it right - your second guess would instead be ((<) x)
14:09:36 <downton> Twisol: i don't get that, doesn't an expression in parens simply set precedence?
14:09:42 <Twisol> when you partially apply a binary operator, it fills either the first or the second operand depending on where you put the value
14:09:53 <Twisol> i.e. difference between (4 <) and (< 4)
14:10:05 <hvr> downton: http://www.haskell.org/haskellwiki/Section_of_an_infix_operator
14:10:14 <Twisol> or (++ "foo") to add a suffix to a string, ("foo"++) to add a prefix
14:10:57 <orospakr> hey, I removed ~/.cabal, but for some reason running cabal install in my project claims that the package is already installed. What other state is on my system that I should squish?
14:11:38 <downton> Twisol: so '(< x) whatever' turns into 'whatever < x'? But that contradicts what you said at 22:08 about me needed parens didn't it?
14:11:51 <Twisol> downton: You -don't- need parens
14:11:55 <geekosaur> orospakr, removing ~/.cabal doesn't do much of anything.  ~/.ghc is where packages are registered
14:11:59 <orospakr> aha
14:12:00 <orospakr> thanks!
14:12:05 <Twisol> downton: "but does that actually mean x is less than all values in foo?"
14:12:11 <Twisol> that would be (x <)
14:12:17 <Twisol> a.k.a. ((<) x)
14:12:48 <downton> Twisol: oh, when you said i had it right, you meant i had my code right already
14:12:53 <Twisol> downton: Yep.
14:12:59 <downton> Twisol: got it, thanks
14:13:02 <Twisol> Welcome!
14:15:04 <wavewave> hi!
14:15:10 <lapinferoce> hello
14:15:34 <wavewave> hoodle now has LaTeX math input support!
14:15:52 * gwern graphs potassium data like a boss
14:20:40 <gwern> 'A guy goes to a psychiatrist, and says, “Doc, my brother thinks he’s a chicken.” Psychiatrist responds, “Well, why don’t you turn him in?” Guy replies, “I would, but I need the eggs.” '
14:21:49 <lispy> hoodle?
14:21:57 <lispy> ah
14:22:02 <lispy> I don't have a device to use as input
14:22:49 <ClaudiusMaximus> wavewave: as in, you can write equations by hand and it converts to LaTeX maths?
14:22:54 <wavewave> lispy: it can be used as a pdf reader/annotator.. ;-)
14:23:36 <wavewave> ClaudiusMaximus: no, no... no handwriting recognition..
14:23:48 <ClaudiusMaximus> wavewave: aww, get coding! ;)
14:24:14 <ClaudiusMaximus> wavewave: hoodle is cool though, i tried it some time ago :)
14:24:21 <wavewave> write an equation using LaTeX, then convert to SVG, and display.
14:24:45 <ClaudiusMaximus> and still planning on ripping out its graphics tablet code and using it for other purposes
14:25:14 <beaky> how do I produce a random integer in haskell
14:25:19 <wavewave> ClaudiusMaximus: thanks. The graphics tablet code is in src/Hoodle/Device.hsc in hoodle-core package
14:25:31 <ClaudiusMaximus> :t random
14:25:33 <lambdabot> (RandomGen g, Random a) => g -> (a, g)
14:25:47 <ClaudiusMaximus> @instances-importing Random System.Random
14:25:47 <lambdabot> Couldn't find class `System.Random'. Try @instances-importing
14:25:52 <ClaudiusMaximus> @instances-importing System.Random Random
14:25:52 <lambdabot> Bool, Char, Double, Float, Int, Integer
14:26:01 <ClaudiusMaximus> wavewave: :)
14:26:14 <beaky> http://langref.org/fantom+python+haskell/numbers/random
14:26:46 <wavewave> see the latest latex input screenshot : http://ianwookim.org/hoodle/gallery.html
14:26:56 <ClaudiusMaximus> beaky: iirc the range of random numbers for Integer is arbitrarily restricted to that of Int, for uniform distribution reasons
14:27:34 <Peaker> a uniform random for Integers doesn't sound like a good idea
14:27:42 <beaky> :(
14:28:29 <wavewave> use mwc-random
14:28:44 <wavewave> its' very fast .
14:29:00 <ClaudiusMaximus> yeah, System.Random is notoriously slow
14:32:03 <Peaker> last I used it (a year or two ago) System.Random had laziness bugs too
14:32:16 <Peaker> leaked thunks
14:32:38 <beaky> how do i get rid of the IO iwhen I get a random number
14:32:47 <hiptobecubic> you don't "get rid" of it
14:33:01 <downton> Peaker: how can you define leaking thunks though? is it a fact that a thunk is needed or not? if it's not needed why isn't it gcd?
14:33:03 <hiptobecubic> you do your computation in the IO monad
14:33:25 <Ralith> or you don't use the IO form of random
14:33:31 <Ralith> that thing really shouldn't exist
14:33:36 <monochrom> please don't get rid of the IO
14:33:51 <monochrom> @quote monochrom IO.String
14:33:52 <lambdabot> monochrom says: How do you extract the IO out of IO String?
14:33:58 <hiptobecubic> beaky, do myRand <- someFuncThatGetsARandomNumber; return pureFunc myRand
14:34:02 <monochrom> please get rid of the String instead :)
14:34:20 <Peaker> downton, I don't recall the exact details, I think I opened a ticket, let me check
14:34:26 <beaky> oh
14:34:31 <hiptobecubic> return $ pureFunc myRand   i mean
14:34:44 <ion> beaky: You could run newStdGen to get a unique generator and then use that with the State monad for instance. There are also packages that do that for you.
14:35:02 <Peaker> downton, http://hackage.haskell.org/trac/ghc/ticket/4218
14:35:02 <beaky> also, how do I do integer division
14:35:04 <monochrom> yes, System.Random is also too lazy for most purposes
14:35:06 <beaky> :t div
14:35:08 <lambdabot> Integral a => a -> a -> a
14:35:11 <beaky> ah
14:36:48 <beaky> http://ideone.com/PVclr6 anyone willing to criticize my code? :D
14:36:53 <ClaudiusMaximus> wavewave: oh, i just remembered that i had to do some X input device fiddling to disconnect graphics tablet from mouse cursor, next time i try it i'll write a little howto and send it your way
14:36:53 <beaky> it's a very basic roguelike
14:37:37 <downton> Peaker: ah so this is really hard to define. it's operation is not incorrect, and it doesn't absolutely produce too many thunks, just too many based on some arbitary definition of too many
14:40:04 <wavewave> ClaudiusMaximus: thnx. please experiment ;-)
14:40:10 <Peaker> downton, if you use randomIO many times, do you expect it to take O(N) memory?
14:40:49 <downton> Peaker: i agree it's obviously wrong, but it's hard to say that it's 'incorrect'
14:41:05 <Peaker> I'm not sure there's a difference between 'wrong' and 'incorrect'
14:41:19 <downton> Peaker: i'm talking about correctness theory
14:41:27 <downton> Peaker: what is your definition of incorrect? uses more memory that you'd like it to
14:41:35 <downton> Peaker: not sure you could build a proof using that!
14:41:45 <Philippa> downton: you can if eg you specify it to use O(1)
14:41:58 <beaky> how do I use n+k patterns?
14:41:59 <downton> Philippa: yeah, and it doesn't, so it's not incorrect
14:42:08 <Nereid> beaky: you don't
14:42:32 <Philippa> or rather, it's not incorrect per what spec we have. Peaker's argument is that it's incorrect per the spec we think it *should* have
14:42:34 <plhk> beaky: you need more types in your code
14:42:46 <downton> Philippa: agreed
14:42:52 <beaky> more types?
14:42:58 <beaky> what should I do
14:43:21 <downton> beaky: can you talk us through what you need to do? what problem are you solving?
14:43:38 <beaky> I'm doing a roguelike in haskell :D
14:44:23 <downton> beaky: i mean the specifics of what you are trying to solve using n+k patterns
14:44:27 <beaky> oh
14:44:45 <downton> put some code in pastebin if you can (http://pastebin.com)
14:44:50 <beaky> showRow row = [f (row, j) | j <- [0..(y - 1)]]. maybe if I used n+k patterns I wouldn't need the (y - 1) bit
14:45:09 <beaky> and could just say [0..y]
14:45:11 <downton> beaky: there's nothing wrong with that code, and n+k patterns wouldn't simply it
14:45:14 <beaky> ah
14:45:37 <downton> beaky: there's no need to move everything into the pattern match, this code already says what you want it to
14:45:48 <beaky> I love pattern matching :D
14:46:15 <johnw> beaky: me too
14:46:42 <beaky> pattern matching is one of the things I miss most when I am using a language that isn't haskell (or doesn't have it)
14:47:10 <beaky> other things I miss are algebraic data structures, lambdas, tailcall elimination, type inference, modules...
14:47:24 <beaky> and monads :D
14:47:36 <beaky> s/monads/typeclasses
14:47:50 <downton> beaky: that's cool, but don't start to think these are somehow unique to haskell, or invented by haskell
14:47:57 <downton> except typeclasses
14:48:06 <beaky> so all that haskell invented is typeclasses?
14:48:11 <beaky> and monads?
14:48:23 <downton> beaky: there's copious research in haskell, but from your list yeah
14:48:34 <downton> beaky: monads were around long before haskell
14:48:49 <beaky> thought monads were only around for two decades
14:49:36 <downton> beaky: 60s i think
14:49:46 <beaky> ah
14:49:55 <beaky> so monads are as old as object-oriented programming :D
14:50:16 <Twisol> After months of using Javascript, it's so nice to use a language that actually has some kind of coroutine support...
14:50:22 <downton> beaky: if you research the history of languages you'll find everything is about two decades older than you thought it was
14:50:26 <beaky> what are coroutines?
14:50:35 <beaky> right
14:50:48 <Twisol> uhh, in a nutshell, functions that can be paused in the middle and resume later
14:50:52 <beaky> lol
14:51:33 <Twisol> Python and Lua also have coroutines.
14:51:59 <companion_cube> python has coroutines?
14:52:03 <mikeplus64> Twisol: do haskell lightweight threads count as coroutines?
14:52:09 <simpson> Yes. Python's generators can be used as coroutines.
14:52:29 <companion_cube> I thought it was a really limited form of coroutine
14:52:41 <Philippa> downton: I wasn't aware that Monads-in-FP were that old? Most people trace them back to Moggi's work in denotational semantics
14:52:49 <Twisol> mikeplus64: coroutines are cooperative threads (explicit yielding), so unless Haskell threads do that, perhaps not
14:52:55 <Philippa> Monads as a CT concept are older, of course, Monads-in-FP are just an application of them
14:53:49 <downton> Philippa: that's true
14:53:49 <Twisol> mikeplus64: when I say coroutine, I'm referring to something like Tekmo's pipes library
14:54:14 <Twisol> although I was able to (laboriously, as a novice) write a simple one in 20 lines
14:54:42 <beaky> :t return
14:54:43 <lambdabot> Monad m => a -> m a
14:54:47 <beaky> :(
14:54:52 <wavewave> I extensively use coroutine for developing hoodle.
14:55:15 <wavewave> coroutine is delimited continuation.
14:55:45 <wavewave> quite useful in GUI programming due to inversion of control
14:56:09 <Twisol> Coroutines are also really nice for processing streams of data. When you run out of data in one chunk, you can yield until you get another.
14:56:22 <wavewave> Twisol: indeed!
14:56:30 <Twisol> s'how I'm using them now, for a Telnet parser
14:56:37 <gseitz> I have a module that uses the CPP lanugage extension, and I start ghci with -cpp, but I always get the error "missing binary operator before token (" in: #if MIN_VERSION_base(4,6,0)
14:56:41 <gseitz> any ideas?
14:56:44 <wavewave> that's how the whole iteratee concept came out.
14:57:28 <gseitz> I just cloned the EKG library
14:59:02 <plhk> beaky: i'd start with type PlayerLoc = (Int, Int). Doesn't give you safety, but serves documenting purpose
14:59:41 <beaky> right
15:01:27 <plhk> and record syntax
15:01:41 <downton> How can I tell if I want to foldl or foldr? Is there some property of the function (it's associatity or something) that I should be looking at when I choose?
15:02:08 <simpson> downton: Here's my logic.
15:02:27 <simpson> Is it left-to-right? Do I need to be lazy? foldl. Otherwise, foldl'. Otherwise, foldr.
15:03:21 <downton> I want to take a list of function [A -> B] and apply them in turn to an initial B, resulting in a B at the end. I was thinking if I get the fold wrong they might be in the wrong order
15:03:28 <cmccann> do you ever actually want a lazy left fold?
15:03:36 <latro`a> very rarely, but it is possible
15:03:45 <latro`a> if your list has undefineds that get ignored or such
15:03:54 <cmccann> I guess so
15:04:09 <latro`a> for example, "last" becomes partial if defined using foldl'
15:04:11 <cmccann> I can't think of a non-contrived scenario where that's the obvious solution though
15:04:12 <simpson> downton: I have had exactly this situation! And yes, foldl was correct.
15:04:13 <latro`a> but is not partial if defined using foldl
15:04:42 <latro`a> (partial on nonempty input)
15:04:54 <simpson> cmccann: Say you have a number of passes that you wish to perform on an AST, and all of them are total. You don't particularly care about the strictness, and you only have a couple dozen passes at most.
15:05:18 <cmccann> simpson, it's more that a right fold seems more natural in most cases if I want laziness
15:05:22 <simpson> Instead of reversing them and using foldr, I used foldl. ...It seemed neater.
15:06:59 <beaky> :t filter (<3) . map (+ 1)
15:07:01 <lambdabot> (Num a, Ord a) => [a] -> [a]
15:11:36 <beaky> http://ideone.com/AIE65T I want to write lines 49-52 in terms of lines 32-47, but it seems I can't :(
15:11:40 <beaky> what should I do?
15:12:02 <beaky> it says I have an arity mismatch
15:16:55 <Twisol> beaky: try $ instead of (.), gut instinct
15:16:58 <applicative> beaky: lines 49-52 have to be expanded
15:17:01 <beaky> oh
15:17:31 <Twisol> nevermind the $ bit
15:17:45 <beaky> http://ideone.com/UVyYnd works :D
15:18:05 <beaky> my code breaks ideone's syntax highlighter :(
15:18:55 <Hafydd> Because ideone's syntax highlighter is shit.
15:18:58 <beaky> lol
15:19:52 <plhk> beaky: http://hpaste.org/
15:20:06 <mreh> the vim file on vim.org is so bland
15:20:10 <mreh> anyone got a better one?
15:20:12 <beaky> ah thanks
15:20:21 <beaky> I like how hpaste does an hlint too
15:20:29 <zenzike> hello all, I'm playing around with Repa, and one of the things I need (besides Repa goodness) is to index into a constant array that doesn't change after initialised. Am I better off using Data.Array, Data.Vector, or Data.Array.Repa for that?
15:20:51 <mreh> ah, vim.org does!
15:22:24 <startling> mreh: "vim file"?
15:23:10 <mreh> vim syntax file
15:23:27 <applicative> zenzike: how many dimensions are in the array
15:23:38 <zenzike> applicative: single dimension
15:23:58 <beaky> http://ideone.com/ZiRrVw lines 62-69, in line 15 I define a player input as either a Motion or a signal to quit te game. why can't it match the Motion values with the Input type?
15:24:02 <beaky> the*
15:24:02 <zenzike> applicative: I don't need repa for that particular array, but it seems silly to import more libraries if the perofrmance gap is small
15:24:04 <applicative> for that, Data.Vector
15:24:42 <applicative> Oh I see you are using more dimensions elsewhere.
15:24:54 <zenzike> applicative: is that because Repa is doing something funky in its unboxed vector represention?
15:25:04 <zenzike> applicative: yes, I'm using multidimensions elsewhere
15:25:15 <zenzike> applicative: (and some other Repa specific stuff)
15:25:48 <Twisol> Anyone care to give some feedback on my Telnet parser? I'm starting to feel pretty happy about it. <https://gist.github.com/6312145be4855daff6e7>
15:25:59 <JoeyA> Does base have a substring search function?
15:26:10 <beaky> no :(
15:26:11 <JoeyA> > (any (key `isPrefixOf`) . tails) "The quick brown fox"
15:26:13 <lambdabot>   Not in scope: `key'
15:26:13 <lambdabot>  Perhaps you meant one of these:
15:26:13 <lambdabot>    `IM.keys' (imported...
15:26:20 <JoeyA> > let key = "quick" in (any (key `isPrefixOf`) . tails) "The quick brown fox"
15:26:23 <lambdabot>   True
15:26:35 <JoeyA> > let key = "strict" in (any (key `isPrefixOf`) . tails) "The quick brown fox jumps over the lazy dog."
15:26:36 <downton> I'm still trying to apply a list of functions in order to a starting value. [a -> a] -> a -> a. I've tried folding with operators like . and $ but can't randomly find the right one. Can anyone help?
15:26:38 <lambdabot>   False
15:26:49 <Twisol> JoeyA: isInfixOf?
15:27:06 <JoeyA> Twisol: Ah, thanks
15:27:25 <Twisol> welcome. Just search for [a] -> [a] -> Bool on Hoogle
15:27:39 <JoeyA> @src isInfixOf
15:27:40 <lambdabot> isInfixOf needle haystack = any (isPrefixOf needle) (tails haystack)
15:27:40 <fmap> @ty appEndo . foldMap Endo
15:27:42 <lambdabot> Foldable t => t (a -> a) -> a -> a
15:27:45 <JoeyA> That is exactly the definition I gave
15:27:55 <beaky> hehe
15:28:03 <Twisol> ehehe.
15:28:10 <JoeyA> hehehe..
15:28:31 <Twisol> ("h" ++ prevMsg ++ ".") ? :P
15:29:29 <JoeyA> downton: Are you applying the operations in the order listed?
15:29:55 <JoeyA> > foldl' (\a f -> f a) 0 [(+1), (*2)]
15:29:57 <lambdabot>   2
15:30:06 <downton> JoeyA: yeah, and that's what i can't get my head around, if i use some fold over [f1, f2], which actaully get applies first? i need f2 $ f1 $ start
15:30:07 <JoeyA> > foldr (\f a -> f a) 0 [(+1), (*2)]
15:30:09 <lambdabot>   1
15:30:12 <downton> Which is why I was trying fold $
15:30:29 <JoeyA> Folding $ is close
15:30:37 <downton> Why did you pick foldr?
15:30:54 <JoeyA> foldr applies the functions from right to left.
15:30:57 <cmccann> Twisol, I assume you're rolling your own coroutine thingie for learning purposes?
15:30:57 <JoeyA> Which do you want?
15:31:16 <downton> Right to left, that's what I want
15:31:19 <Twisol> cmccann: Yes, and because the other(s) confuse me. I at least understand mine right now.
15:31:30 <cmccann> haha, ok.
15:31:50 <cmccann> reinventing a few wheels is a good way to understand (and appreciate) the complexity in existing implementations
15:31:56 <Twisol> Agreed
15:32:15 <JoeyA> > foldr (\f a) [] [(1:), (2:), (3:), (4:)]
15:32:17 <lambdabot>   <hint>:1:12: parse error on input `)'
15:32:25 <JoeyA> > foldr (\f a -> f a) [] [(1:), (2:), (3:), (4:)]
15:32:27 <lambdabot>   [1,2,3,4]
15:32:44 <copumpkin> > foldr (\f -> f) [] [(1:), (2:), (3:), (4:)]
15:32:45 <lambdabot>   [1,2,3,4]
15:32:52 <copumpkin> > foldr id [] [(1:), (2:), (3:), (4:)]
15:32:53 <lambdabot>   [1,2,3,4]
15:33:02 <JoeyA> > foldr ($) [] [(1:), (2:), (3:), (4:)]
15:33:04 <lambdabot>   [1,2,3,4]
15:33:21 <JoeyA> > foldr fmap [] [(1:), (2:), (3:), (4:)]
15:33:23 <lambdabot>   []
15:34:42 <fmap> > foldr fmap id [(1:), (2:), (3:), (4:)] []
15:34:43 <hpaste> Heffalump pasted “does this segfault?” at http://hpaste.org/79649
15:34:44 <lambdabot>   [1,2,3,4]
15:34:44 <applicative> zenzike: Are you having trouble doing it with  a 1D repa array? like  vec ! (Z:.3)
15:35:23 <cmccann> Twisol, also, why have a Telnet type class instead of just a single monad transformer or such? (I think I know why, but I want to hear what you think)
15:35:24 <Heffalump> anyone feel like trying the program I pasted to see if it segfaults?
15:35:47 <Heffalump> (and let me know the platform etc, either way)
15:36:27 <plhk> > foldl (flip ($)) [] [(1:), (2:), (3:), (4:)]
15:36:28 <lambdabot>   [4,3,2,1]
15:36:45 <JoeyA> Heffalump: What system?
15:36:55 <Twisol> cmccann: Well, I needed a way to interleave the handling of events with the actual parsing - so that I can interrupt on demand, like if compression is about to begin - and I didn't want to constrain the inner monad to a specific type. As long as it supports the actions onText, onCommand, onOption, it's perfectly valid.
15:37:11 <Twisol> And different applications of the Telnet protocol will want to do different things.
15:37:13 <beaky> :t 1
15:37:15 <lambdabot> Num a => a
15:37:36 <Heffalump> JoeyA: anything you can. It breaks for me on Debian with GHC 7.4.1 and 7.6.1, and (I think) on Windows
15:38:08 <plhk> Heffalump: segfaults here @ openbsd, ghc 7.4.2
15:38:11 <hpc> that's the third time someone has called telnet a protocol
15:38:14 <cmccann> Twisol, it's the purpose for not constraining the inner monad I'm curious about
15:38:21 <hpc> i thought it was explicitly a lack-of-protocol
15:38:28 <cmccann> since any actual network connection is going to involve IO
15:38:36 <Twisol> hpc: It uses byte 255 to escape the plaintext stream and invoke various commands.
15:38:42 <Heffalump> pikhq: ta
15:38:45 <hpc> huh
15:38:53 <zenzike> applicative: oh, no trouble at all. I'm just thinking about performance, and wondering if there's an obvious answer
15:38:59 <hpc> what commands?
15:39:03 <zenzike> applicative: I'm happy to benchmark if it's not clear-cut :-)
15:39:14 <cmccann> hpc, the two sides have to agree on how to set up their protocol-free communications!
15:39:16 <Twisol> hpc: Subnegotiations, primarily. The negotiation of side streams of data that aren't part of the plaintext stream.
15:39:37 <JoeyA> Heffalump: I get a segfault, too.
15:39:59 <Twisol> cmccann: Oh, I don't want to constrain it to IO because I want to keep it relatively pure. It could come from a file, from a string you happen to have handy, etc. and the act of parsing is just identifying what parts of the stream are what logical events.
15:40:30 <beaky> how do I have different types in each value constructor in an ADT?
15:40:46 <cmccann> Twisol, ok. personally I prefer a slightly different approach for that, but the type class is reasonable too.
15:41:02 <applicative> zenzike: thats what I thought at first, but something else made me think something was going wrong
15:41:08 <Twisol> cmccann: What would you have done? I'm a novice, so I'd like to hear about other possibilities.
15:41:26 <beaky> like having a `data Expression = Number | Symbol
15:41:37 <JoeyA> I really like the type class approach.  I recently suggested it on Reddit: http://www.reddit.com/r/haskell/comments/15246s/pain_point_dependency_injection_in_haskell_via/c7ipdzw
15:41:50 <Heffalump> JoeyA: ok, thanks. I guess a GHC bug report is called for.
15:42:08 <cmccann> Twisol, basically a ReaderT with a record that contains the same functions as your type class
15:42:10 <JoeyA> Perhaps it's a ByteString bug instead
15:42:17 <cmccann> it's a matter of taste, the end result is the same
15:42:24 <Heffalump> JoeyA: ByteString is only being used to write out the binary file
15:42:30 <Twisol> JoeyA: cool, glad to see I'm not off in the dark somewhere with this
15:42:47 <Heffalump> I'm pretty sure it's something to do with how GHC handles "ignore encoding errors" when reading
15:42:53 <Twisol> cmccann: Heh heh. I took that approach in my C implementation.
15:43:12 <Twisol> cmccann: Thanks!
15:43:35 <JoeyA> Twisol: Defining classes like that lets you compose dependencies nicely, and lets you separate side effects from business logic.
15:43:46 <Twisol> JoeyA: Yep, exactly.
15:44:11 <cmccann> Twisol, the reason I prefer my approach is that it generalizes to stuff that wouldn't work as a type class
15:44:13 <applicative> zenzike: I don't know if any of repa's use of Data.Vector.Unboxed will make  it different from the obvious use in 1D
15:44:28 <cmccann> since I get to explicitly construct the equivalent and pass it in
15:44:36 <JoeyA> Similar solutions are the operational monad, the prompt monad, and the free monad.
15:44:59 <Twisol> cmccann: Yeah. I don't need that amount of flexibility for this - Telnet really is very simple architecturally.
15:45:05 <cmccann> can do things like stuff a record full of IORefs to have... local global variables I guess
15:45:44 <cmccann> Twisol, right, for your purposes the type class is fine (and probably more intuitive)
15:45:50 <JoeyA> cmccann: That gets ugly fast.  When you bring concurrency and exceptions into the picture, it becomes very hard to reason about the code.
15:46:09 <zenzike> applicative: ta. I'll run a few benches to see what's up
15:46:14 <cmccann> Joey, then pass in TVars instead
15:46:42 <cmccann> the point is I can construct things outside some computation and then provide them as an immutable environment, even if they're references to mutable thingies or IO actions
15:52:26 <beaky> http://ideone.com/X6CbWy anyone willing to criticize my code? :D
15:52:56 <Twisol> the only problem with Haskell
15:53:03 <beaky> problem?
15:53:09 <Twisol> is that I now try to write Java like it's Haskell
15:53:11 <JoeyA> I guess it depends on the application.  ReaderT Env IO is very straightforward.  But if you want to encode business logic that has a lot of dependencies (e.g. global configuration, global state, database connection), the monad class approach is a good thing to have in your arsenal.
15:53:26 <Taneb> beaky, make Grid a record
15:53:26 <lambdabot> Taneb: You have 1 new message. '/msg lambdabot @messages' to read it.
15:54:49 <beaky> ah
15:55:02 <Twisol> Does it make sense to take a monad transformer stack, newtype it, and write a Monad instance for that newtype with extra semantics? (i.e. get a value from the StateT and if it's True, use the CoroutineT to yield)
15:55:07 <Taneb> That makes a whole bunch of your code easier to write
15:55:20 <beaky> it does?
15:55:29 <JoeyA> Otherwise, it gets cluttered with stuff like this: liftIO $ atomically $ RQ.write bd_emailQueue io
15:55:30 <Taneb> defaultGrid = Grid {rows = 22, cols = 79...
15:55:36 <beaky> oh
15:55:56 <beaky> I don't like record syntax :(
15:55:57 <Cale> Twisol: yes, it does make sense
15:56:16 <JoeyA> beaky: Then you don't know about RecordWildCards.
15:56:22 <beaky> oh
15:56:24 <beaky> what is that?
15:56:47 <Twisol> Cale: Cool, thanks.
15:56:48 <JoeyA> f Record{..} = do
15:56:54 <JoeyA> Brings all the record fields into scope
15:57:07 <Twisol> JoeyA: What the heck, I never knew about that
15:57:10 <JoeyA> So instead of saying (recordField rec) everywhere, you can just say recordField
15:57:23 <JoeyA> You can also use it to populate new records
15:57:29 <Cale> Twisol: Of course, you should be careful implementing the Monad instance that the monad laws are actually obeyed
15:57:47 <beaky> awesome
15:57:47 <JoeyA> e.g. globalConfig <- getConfig; globalDB <- connectDB; return Global{..}
15:57:49 <Cale> Twisol: Usually the whole benefit of using monad transformers in the first place is that you get the Monad instance for free.
15:58:40 <Cale> Twisol: But for instance, implementing the MonadState operations yourself is much less dangerous.
15:58:42 <Twisol> Cale: Yeah. I'm just in a situation where I'd like to check multiple monadic layers in the same bind.
15:58:44 <JoeyA> Twisol: People often use a newtype wrapper around a monad, and derive the instances automatically using GeneralizedNewtypeDeriving
15:59:04 <JoeyA> example: http://hackage.haskell.org/packages/archive/criterion/latest/doc/html/src/Criterion-Monad.html#Criterion
15:59:39 <Twisol> JoeyA: That doesn't do much more than translate through the newtype, though, does it?
16:00:02 <JoeyA> Right.
16:00:15 <JoeyA> If you want a different Monad instance than StateT provides, you shouldn't be using StateT.
16:00:21 <JoeyA> Doing so would be wildly misleading.
16:00:30 <Twisol> Not quite what I meant.
16:01:10 <Twisol> I have a monad stack with both StateT and (my) CoroutineT; if the state contains a certain value I want to yield the computation
16:23:19 <ion> STAHP
16:23:25 <ion> copumpkin
16:23:27 <ion> stahp
16:23:28 <Twisol> XD
16:23:36 <copumpkin> ack, sorry :)
16:23:46 <copumpkin> I had reconfigured my IRC client and I guess it was over freenode's finicky limit
16:24:05 <Skillsob> So guys, what's happening in Haskell? I'm working on a Brainfuck interpreter, and then later probably doing a MIX emulator to learn more about assembly.
16:25:45 <Skillsob> Anyone working on anything cool?
16:26:12 <Twisol> is a Telnet implementation cool?
16:26:26 <Skillsob> Sounds pretty cool.
16:30:04 <beaky> I'm writing a roguelike :D
16:31:01 <hpaste> beaky pasted “PureRogue 0.0.1” at http://hpaste.org/79650
16:31:19 <beaky> atm my roguelike keeps scrolling the terminal
16:31:33 <beaky> how do I make the display fixed
16:31:36 <beaky> like in actual roguelikes
16:31:55 <ion> ncurses
16:31:58 <Twisol> use something besides putStrLn. :/
16:32:10 <niteria> ncurses?
16:32:24 <niteria> oh, already suggested
16:32:53 <beaky> ncurses?
16:33:09 <beaky> haskell has good curses bindings?
16:33:22 <Peaker> beaky, I like vty which I find better than curses
16:33:27 <Peaker> beaky, not a curses binding
16:33:59 <niteria> I heard ncurses has arcane api
16:34:05 <beaky> yeah
16:34:10 <beaky> ncurses is a bit crufty
16:34:35 <beaky> but it's good
16:35:48 <Twisol> I'd rather send ANSI control sequences to the terminal manually. ;D
16:35:54 <beaky> lol
16:36:18 <beaky> alright I will use ansi-terminal
16:37:03 <beaky> http://hackage.haskell.org/package/ansi-terminal-0.5.5
16:37:22 <Twisol> Haha, nice. Although there's a 0.5.5.1 version.
16:37:25 <Twisol> (you used google, didn't you?)
16:37:37 <Peaker> beaky, ncurses isn't good
16:37:42 <Peaker> beaky, why not vty?
16:38:13 <beaky> ah
16:38:18 <beaky> what is vty
16:42:04 <ion> twisol: Would you carry a manually created terminal info database with the software?
16:42:36 <Twisol> ion: I'm probably going to kill the joke, but what do you mean?
16:43:03 <ion> twisol: Terminals are different. One cannot hardcode control sequences, thus a database of the properties of various terminals is needed.
16:43:35 <ion> a.k.a. terminfo
16:43:38 <Twisol> Heh. The MUD community has that covered. :/
16:44:20 <Rembane> One does not simply hardcode a terminal
16:44:21 <Twisol> ah, neat
16:46:27 <madhadron> …or consider getting a proper graphics interface. I realize that may be sacrilege for a rogue-like.
16:46:46 <madhadron> But there's no reason to fight 1970s teletype technology
16:47:20 <Rembane> madhadron: Dwarf Fortress did it
16:48:02 <madhadron> Rembane, Yes. Nethack's still doing it, too.
16:48:12 <hpc> DF did it by using a custom font in a GUI window
16:48:19 <hpc> (on windows at least)
16:48:45 <madhadron> hpc, Which strikes me as a much saner approach.
16:48:53 <hpc> yeah
16:49:05 <hpc> the way it uses bitmapped fonts is nice for themes too
16:49:16 <Rembane> madhadron: That's nice. DF uses OpenGL
16:49:40 <madhadron> Rembane, Oh, I thought you meant DF was using teletypes.
16:49:49 <Rembane> madhadron: Nah, it left teletypes
16:49:53 <madhadron> Nethack certainly is, unless you're using one of the graphical frontends.
16:49:57 <madhadron> Righto, misunderstanding.
16:50:06 <Rembane> No worries
16:54:10 <Peaker> beaky, http://hackage.haskell.org/package/vty
16:55:55 <beaky> ah
16:59:50 <beaky> how do I handle the arrow keys in haskell
17:01:52 <Twisol> beaky: you'll need some way to listen for raw keypresses rather than characters
17:03:44 <beaky> :(
17:04:08 <beaky> so my roguelike has implemented basic movements
17:04:11 <ion> Use a library that does that for you.
17:04:13 <beaky> what else should I implement?
17:04:24 <ion> Nothing, you’re about done.
17:04:30 <beaky> :D
17:05:23 <beaky> what about a character attribute system (levels, health, str/int/dex, etc), monsters and AI, random dungeon generation, a magic system, an item/inventory system, etc.
17:05:43 <beaky> player attributes is next :D
17:05:44 <ion> I’d like to see a good scifi roguelike.
17:05:54 <beaky> scifi roguelike in haskell :D
17:06:28 <Skillsob> Procedurally generated dungeons would be pretty awesome to make. Look into fractals before you make them for maximum awesomeness.
17:06:56 <beaky> purely-functional dungeons sound neat
17:07:29 <Skillsob> FUND IT.
17:07:40 <hpc> that'd be a funny roguelike gimmick
17:07:50 <hpc> when you go to a square you were previously in, the game state reverts
17:08:06 <beaky> yeah
17:08:08 <Peaker> "purely functional" -- awful marketing for Haskell :)
17:08:11 <hpc> so if you aren't careful, you can get hit by the same arrow over and over
17:08:26 <Peaker> (maybe good marketing for "avoid success at all costs")
17:08:27 <hpc> but if you are awesome, you can backtrack about as far as you want
17:08:40 <bd_> step on the upstair on level one after getting the amulet of whatever - suddenly, game reverts to turn one
17:08:55 <bd_> and they say nethack is unforgiving!
17:09:09 <Skillsob> I heard that Diablo did it by making a bunch of rooms, and then just randomising which ones appeared and where they joined.
17:09:33 <beaky> yeah
17:09:40 <beaky> that procedural generation thing is a challenge
17:09:43 <Skillsob> Rooms are monoids!
17:09:57 <hpc> bd_: you wouldn't be reverted, just the map
17:10:00 <beaky> rooms are monoids? :D
17:10:27 <Philippa> so I probably shouldn't be happy about writing foldChildren (:) [] o just so I can do a foldl over it, right?
17:10:55 <Peaker> Philippa, class Foldable is where the cool kids hang these days
17:11:16 <Philippa> Peaker: that's not exactly going to fix my problem though, is it?
17:11:18 <Skillsob> Well, if you consider a collection of joined rooms as one big room, you can transitively join rooms.
17:11:26 <Peaker> Philippa, won't it make the fold direct?
17:11:30 <Philippa> (foldChildren is, give or take, an artefact of the paper my code's adapted from)
17:11:53 <Philippa> Peaker: if I were doing foldr over the result you'd be well-placed to take the piss!
17:12:09 <Skillsob> I don't know what the zero would be, though. I guess the lack of a room? You can join the lack of a room with a room x and get x.
17:13:26 <Twisol> maybe it would be a single wall?
17:14:19 <beaky> yeah
17:14:54 <cmccann> beaky, I think the next step for a roguelike after basic movement is spending forever debugging line of sight algorithms and tweaking a random map generator
17:15:11 <Philippa> Peaker: okay, I've taken a peek at the source, I've no idea if it actually behaves more efficiently than what I've written does. In principle I could add the instances though - but for now I'm trying to avoid pulling in the dependencies
17:15:26 <beaky> lol
17:15:44 <beaky> long way to go before my haskell roguelike is ready :(
17:15:59 <beaky> never designed a roguelike before
17:16:10 <beaky> I ported this one from C to Python, and now from Python to Haskell :D
17:16:24 <cmccann> beaky, most people who try to write roguelikes haven't either
17:16:28 <cmccann> so you're in good company
17:16:31 <beaky> :D
17:16:33 <Twisol> XD
17:17:17 <cmccann> if you get the map generator and line of sight working then you're in uncharted territory I think
17:20:29 <niteria> beaky: I hope you move by hjkl in your roguelike
17:20:46 <beaky> yeah
17:20:51 <beaky> as wel as yu and bn
17:20:57 * cmccann prefers numpad
17:20:58 <beaky> for the diagonal movement
17:21:19 <niteria> I had a lot of fun playing hunt with hjkl
17:22:24 * Ralith prefers hjkl because his laptop doesn't have a numpad
17:22:25 <Skillsob> So how are you making it use keypresses instead of getChar?
17:22:39 <beaky> I'm still using getChar :P
17:22:54 <beaky> I wish haskell had ncurses bindings or something
17:23:03 <Ralith> it does
17:25:49 <Skillsob> I suggest getLine followed by head, because with getChar they can put in a million commands at once and probably fuck with the system.
17:25:50 <Peaker> beaky, for input, you can use getch iirc
17:25:53 <Peaker> @hoogle getch
17:25:53 <lambdabot> Prelude getChar :: IO Char
17:25:53 <lambdabot> System.IO getChar :: IO Char
17:25:53 <lambdabot> Control.Concurrent.Chan getChanContents :: Chan a -> IO [a]
17:26:23 <Peaker> oh getch is from curses
17:26:32 <beaky> @hoogle curses
17:26:33 <lambdabot> package hscurses
17:26:33 <lambdabot> package hscurses-fish-ex
17:26:33 <lambdabot> package nanocurses
17:26:38 <beaky> :D
17:26:51 <Peaker> beaky, http://hackage.haskell.org/packages/archive/vty/4.2.1.0/doc/html/Graphics-Vty-LLInput.html
17:26:57 <Peaker> beaky, ok, I forgot that vty could do input
17:31:59 <sw2wolf> :t (<*)
17:32:00 <lambdabot> Applicative f => f a -> f b -> f a
17:32:22 <sw2wolf> :t (*>)
17:32:23 <lambdabot> Applicative f => f a -> f b -> f b
17:32:34 <sw2wolf> :t (<*>)
17:32:35 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
17:32:46 <beaky> xlent
17:34:03 <sw2wolf> :t fmap
17:34:05 <lambdabot> Functor f => (a -> b) -> f a -> f b
17:37:27 <beaky> :t (.)
17:37:29 <lambdabot> Functor f => (a -> b) -> f a -> f b
17:37:36 <latro`a> silly lambdabot
17:37:44 <cmccann> :t (Prelude..)
17:37:45 <lambdabot> (b -> c) -> (a -> b) -> a -> c
17:38:11 <beaky> why redefine (.)?
17:38:18 <cmccann> because Cale
17:38:26 <latro`a> lol
17:38:38 <latro`a> technically it's not a redefinition
17:38:40 <latro`a> only a generalization
17:38:40 <latro`a> :p
17:38:46 <beaky> ah
17:38:59 <beaky> :t fmap (+1) (+5)
17:39:00 <lambdabot> Num b => b -> b
17:39:12 <beaky> it makes sense
17:39:45 <beaky> (Prelude..) is just fmap on functions
17:40:19 <cmccann> yep
17:40:25 <cmccann> which is the Reader monad
17:40:38 <beaky> Reader monad?
17:40:40 <beaky> what's that
17:40:45 <cmccann> but it's still confusing for people who aren't used to lambdabot's Caleskell goofiness
17:40:54 <cmccann> @src ReaderT
17:40:54 <lambdabot> Source not found. I am sorry.
17:40:57 <cmccann> pf
17:41:23 <cmccann> beaky, Reader is just the monad instance for functions, with a newtype wrapper
17:41:44 <Twisol> lets you compose, say, (x -> a -> b) -> (x -> b -> c) -> (x -> a -> c)
17:41:44 <beaky> so functions are monads?
17:41:48 <Twisol> yus
17:42:10 <beaky> what does >>= do between functions
17:42:31 <latro`a> it's easier to go via join
17:42:36 <latro`a> join f = \x -> f x x
17:42:38 <cmccann> well, think of what the type of (>>=) would work out to
17:42:46 <beaky> :t (>>=)
17:42:48 <lambdabot> Monad m => m a -> (a -> m b) -> m b
17:42:52 <beaky> ah
17:43:07 <beaky> :t (+1) >>= (+6)
17:43:09 <lambdabot>     Occurs check: cannot construct the infinite type: a0 = a0 -> b0
17:43:09 <lambdabot>     Expected type: a0 -> a0 -> b0
17:43:09 <lambdabot>       Actual type: a0 -> a0
17:43:13 <beaky> O.o
17:43:17 <latro`a> :t (+1) >>= (+)
17:43:18 <lambdabot> Num b => b -> b
17:43:28 <latro`a> > (+1) >>= (+) 2
17:43:30 <lambdabot>   Occurs check: cannot construct the infinite type: a0 = a0 -> b0
17:43:33 <latro`a> erm
17:43:40 <Twisol> >> ?
17:43:44 <latro`a> > ((+1) >>= (+)) 2
17:43:45 <lambdabot>   5
17:43:49 <latro`a> there we go
17:44:04 * beaky 's mind just exploded
17:44:10 <Twisol> Reader basically lets you pull the first argument out of a series of functions and compose them
17:44:12 <Twisol> and pass it in later.
17:44:19 <ski>   newtype ReaderT r m a = ReaderT {runReaderT :: r -> m a}  -- beaky
17:44:27 <latro`a> (r->a) -> (a -> r -> b) -> (r -> b)
17:44:38 <cmccann> in the Reader monad you have "ask" which gives you the value of the "environment"
17:44:42 <cmccann> and is basically just id
17:44:53 <Twisol> id is fun.
17:45:29 <beaky> haskell has lots of abstractions...
17:45:31 <ski>   newtype Reader r a = Reader {runReader :: r -> a}  -- was before, now it's only something equivalent (`ReaderT r Identity a', with `newtype Identity a = Identity {runIdentity :: a}')
17:45:48 <beaky> I thought that functions were the ultimate abstraction, and then I became acquainted with Monads :(
17:46:04 <cmccann> the Applicative instance for functions is similar
17:46:16 <cmccann> and lets you do things like:
17:46:23 <Twisol> beaky: try categories, too
17:46:36 <cmccann> > map ((&&) <$> (> 3) <*> (< 5)) [1..10]
17:46:37 <lambdabot>   [False,False,False,True,False,False,False,False,False,False]
17:47:04 <cmccann> > map ((||) <$> (< 2) <*> (> 8)) [1..10]
17:47:06 <lambdabot>   [True,False,False,False,False,False,False,False,True,True]
17:47:15 <beaky> so . is just >>= in the reader monad?
17:47:22 <cmccann> no, . is fmap
17:47:25 <beaky> ah
17:47:30 <Twisol> it's similar, but no
17:47:34 <Twisol> well
17:47:37 <Twisol> >=> is similar to .
17:47:37 <beaky> what is the equialent of >>= for functions?
17:47:40 <Twisol> $
17:47:45 <beaky> ah
17:47:47 <latro`a> f >>= g = \x -> g x (f x)
17:48:17 <latro`a> I have the order right, right?
17:48:21 <Twisol> looks like it
17:48:34 <cmccann> :t \f g x -> g x (f x)
17:48:36 <lambdabot> (t2 -> t1) -> (t2 -> t1 -> t) -> t2 -> t
17:48:37 <Twisol> ^ pretty explicitly shows how Reader lets you apply functions while ignoring the first argument for a while
17:48:42 <cmccann> looks more like (<*>) to me
17:48:52 <beaky> maybe my game could use the Reader monad
17:48:52 <cmccann> :t \f g x -> g (f x) x
17:48:53 <lambdabot> (t2 -> t1) -> (t1 -> t2 -> t) -> t2 -> t
17:49:15 <cmccann> that one is (>>=)
17:49:25 <latro`a> oh, OK, so I did do the order wrong
17:49:26 <latro`a> >.>
17:49:37 <ion> beaky: This may or may not be helpful: http://heh.fi/haskell/functors/#function-instance
17:50:55 <cmccann> beaky, using ReaderT is a good way to make a bunch of static data loaded at runtime available to lots of functions
17:51:25 <cmccann> more useful if you're loading sprites or such
17:51:52 <beaky> ah
17:52:08 <cmccann> but if your game has any data files it needs you could do it that way
17:54:05 <M30W> Are there any large problem sets for haskell ?
17:54:17 <M30W> I.e to help learn the language by fixing/improving code.
17:57:13 <hpaste> beaky pasted “Redundancy” at http://hpaste.org/79651
17:57:30 <beaky> any opportunities to refactor the redundancy out?
17:57:47 <beaky> I
17:57:50 <jmcarthur> i think so
17:57:52 <beaky> I'm really breaking DRY there :(
17:58:16 <beaky> and in many other places in my code...
17:58:31 <jmcarthur> i don't have enough of a grasp on what's going on to see what the actual pattern is, apart from some repitition
17:58:37 <beaky> ah
17:58:39 <jmcarthur> *repetition?
17:58:46 <jmcarthur> that looks right
17:58:48 <beaky> well, g is the game's grid
17:59:06 <beaky> and movePlayer just updates the grid
17:59:51 <jmcarthur> are ULeft and DRight supposed to mean UpLeft and DownRight?
17:59:59 <jmcarthur> as in diagonal?
18:00:13 <beaky> yeah
18:00:18 <beaky> :D
18:00:43 <jmcarthur> why does the guard only check the top and bottom of the grid and not the left or right?
18:01:31 <jmcarthur> (once i am sure i understand it, i will see if i can come up with a less redundant way to code it)
18:02:07 <jmcarthur> i'm also guess that there are many other cases in this movePlayer function than just these four
18:02:09 <jmcarthur> *guessing
18:02:28 <beaky> the guard is trying out the up/down movements first. if the grid's state has not changed (i.e. a movement was unsuccessful) then it doesn't proceed to move left/right
18:02:42 <beaky> yeah there are the up/down/left/right movements :D
18:03:16 <cmccann> so if the player tries to move UL, they can't move if blocked U, but can if blocked L?
18:03:18 <cmccann> that seems odd.
18:03:20 <jmcarthur> is the grid infinite along the x axis but finite along the y axis?
18:03:21 <beaky> right
18:03:32 <cmccann> but if that's what you want then ok.
18:03:33 <beaky> the grid is finite along both axes
18:03:46 <jmcarthur> does left and right wrap around?
18:03:56 <beaky> no wrapping
18:04:02 <beaky> it's fixed :D
18:04:11 <jmcarthur> so the player can just move off the left or right side of the grid then
18:04:17 <beaky> they could?
18:04:27 <jmcarthur> you aren't preventing it, at least
18:04:45 <beaky> the movePlayer Left and movePlayer Right ones test the bounds of the Grid
18:04:51 <beaky> so that the player doesn't fall off :D
18:04:53 <jmcarthur> but not your diagonal ones
18:05:02 <plhk> isn't this the case for maybe?
18:05:05 <jmcarthur> oh i see
18:05:11 <beaky> yeah maybe Maybe is useful here
18:05:14 <jmcarthur> but your up and down cases don't test?
18:05:23 <beaky> up and down also test for that
18:05:27 <jmcarthur> if they do test, i see not reason to include the guards in the diagonal cases
18:05:31 <jmcarthur> *no
18:05:48 <jmcarthur> unless it's just that you want to prevent *all* movement, not just the up-down movement
18:06:10 <beaky> I wanna prevent the player from moving anywhere if he tries to move diagonally along a boundary
18:06:16 <beaky> no surfing  on the grid walls :D
18:06:41 <jmcarthur> okay, then you have to check horizontally, too, not just vertically
18:06:42 <beaky> I'll look into Maybe
18:07:44 <hpaste> beaky pasted “Player Movements” at http://hpaste.org/79652
18:07:51 <beaky> that's the whole thing :D
18:08:44 <plhk> maybe grid (movePlayer) grid
18:09:18 <beaky> ah
18:10:04 <beaky> looks like I could use Maybe here
18:10:32 <ski>   movePlayer :: Motion -> Grid -> Maybe Grid
18:12:07 <tromp> > (++ "!!") . (>> "AA") $ "Hello world !"
18:12:10 <lambdabot>   "AAAAAAAAAAAAAAAAAAAAAAAAAA!!"
18:12:12 <jmcarthur> beaky: once you are using maybe, you can do this:
18:12:33 <jmcarthur> doubleMove = (<=<) `on` movePlayer; movePlayer ULeft = doubleMove Up Left; ...
18:12:53 <beaky> > (++ "!!") . (>> "AA") $ "foo"
18:12:54 <jmcarthur> err, maybe
18:12:55 <lambdabot>   "AAAAAA!!"
18:13:06 <jmcarthur> no
18:13:08 <jmcarthur> i was wrong
18:13:12 <jmcarthur> that does not type check
18:13:21 <beaky> ah :(
18:13:56 <tromp> i'm reading the silly http://uncyclopedia.wikia.com/wiki/Haskell
18:14:06 <tromp> > fix$(<$>)<$>(:)<*>((<$>((:[{- thor's mother -}])<$>))(=<<)<$>(*)<$>(*2))$1
18:14:08 <lambdabot>   [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,...
18:14:14 <beaky> basic creature movements, and we're already using monads :D
18:14:36 <Twisol> tromp: what is that ungodly thing?
18:14:45 <jmcarthur> beaky: doubleMove g = (<=<) `on` (`movePlayer` g); movePlayer ULeft g = doubleMove g Up Left   -- i think might work
18:14:46 <ion> Well, you’re very likely to use monads in any Haskell program.
18:14:46 <M30W> > (>> "a) $ "this is a string of a's"
18:14:48 <lambdabot>   <hint>:1:29: parse error on input `of'
18:14:54 <M30W> O.o
18:15:01 <M30W> > (>> 'a') $ "this is a string of a's"
18:15:02 <lambdabot>   Couldn't match expected type `m0 b0'
18:15:02 <lambdabot>              with actual type `GHC.Typ...
18:15:04 <tromp> an attempt at humor
18:15:15 <M30W> > (>> "a") $ "this is a string of a"
18:15:17 <lambdabot>   "aaaaaaaaaaaaaaaaaaaaa"
18:15:22 <Twisol> M30W: you left off the last quote the first time
18:15:26 <Twisol> "a
18:15:30 <M30W> Twisol: I noticed.
18:15:36 <Twisol> Mmk
18:15:37 <M30W> But 'a' should work too yea?
18:15:41 <beaky> :t (<=<)
18:15:43 <lambdabot> Monad m => (b -> m c) -> (a -> m b) -> a -> m c
18:15:44 <M30W> (doensn't)
18:15:45 <beaky> :t on
18:15:46 <Twisol> it's a character, where "a" is a string
18:15:47 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
18:15:56 <ion> @type (>>) `asAppliedTo` (undefined :: String)
18:15:58 <lambdabot> [Char] -> [b] -> [b]
18:16:10 <M30W> Twisol: So.. It was after a strong. And won't take a char... Okay
18:16:13 <ion> It must be a list of something.
18:16:17 <jmcarthur> beaky: i think i'm still wrong
18:16:17 <Nisstyre-laptop> :t on on
18:16:19 <lambdabot>     Occurs check: cannot construct the infinite type: b0 = b0 -> c0
18:16:19 <lambdabot>     Expected type: (b0 -> b0 -> c0)
18:16:19 <lambdabot>                    -> (b0 -> b0 -> c0) -> b0 -> b0 -> c0
18:16:23 <jmcarthur> beaky: because i suck at life
18:16:27 <M30W> > (>> 5 :: String) $ "testing"
18:16:28 <lambdabot>   <hint>:1:7: parse error on input `::'
18:16:34 <beaky> "Haskell is a dialect of COBOL, which it superficially resembles, and an embodiment of the Zeta-Calculus." heh
18:16:34 <M30W> > (>> (5 :: String)) $ "testing"
18:16:36 <lambdabot>   No instance for (GHC.Num.Num GHC.Base.String)
18:16:36 <lambdabot>    arising from the literal `...
18:16:38 <M30W> :(
18:16:41 <jmcarthur> beaky: i think i'm going to stop trying to be "helpful" tonight
18:16:43 <jmcarthur> sorry
18:16:55 <beaky> no worries
18:17:01 <M30W> let a = 5 :: String in (>> a) $ "testing"
18:17:06 <beaky> monads are hard to grok :(
18:17:09 <M30W> > let a = 5 :: String in (>> a) $ "testing"
18:17:10 <lambdabot>   No instance for (GHC.Num.Num GHC.Base.String)
18:17:10 <lambdabot>    arising from the literal `...
18:17:15 <M30W> :(
18:17:17 <Nisstyre-laptop> only use for on I've found is with compare
18:17:25 <Nisstyre-laptop> what do other people use it for?
18:17:31 * hackagebot lojbanParser 0.1.7 - lojban parser  http://hackage.haskell.org/package/lojbanParser-0.1.7 (YoshikuniJujo)
18:17:37 <M30W> How to turn an int to a string?
18:17:43 <Nisstyre-laptop> M30W: show
18:17:44 <Twisol> > show 5
18:17:46 <lambdabot>   "5"
18:17:52 <M30W> Oh sigh
18:17:55 <M30W> I knew that.
18:18:01 <Twisol> beaky: This is my favorite monad tutriorial: <http://mvanier.livejournal.com/3917.html>
18:18:06 <M30W> > (>> show 5) $ "testing"
18:18:07 <lambdabot>   "5555555"
18:18:10 <M30W> :)
18:18:21 <Nisstyre-laptop> > read (show 5) :: Int
18:18:23 <lambdabot>   5
18:18:41 <ion> twisol: The entire page doesn’t even mention functors. Without reading it i can tell it’s bad.
18:18:44 <Peaker> beaky, do you grok Functors?
18:18:49 <M30W> read, that's what I was missing!
18:18:52 <beaky> what are functors
18:18:58 <M30W> > read "t" :: Char
18:19:00 <lambdabot>   *Exception: Prelude.read: no parse
18:19:09 <M30W> > read "t" :: Character
18:19:10 <lambdabot>   Not in scope: type constructor or class `Character'
18:19:15 <M30W> Hmm
18:19:39 <Peaker> > read "'t'" :: Char
18:19:41 <lambdabot>   't'
18:20:20 <M30W> O.o
18:20:26 <Jafet> > fix $ show . (++) "\\&"
18:20:28 <lambdabot>   "\"\\\\&\\\"\\\\\\\\&\\\\\\\"\\\\\\\\\\\\\\\\&\\\\\\\\\\\\\\\"\\\\\\\\\\\\\...
18:20:42 <M30W> > read "'t''e''s''t'" :: Char
18:20:44 <lambdabot>   *Exception: Prelude.read: no parse
18:20:46 <Twisol> ion: I like it because it starts from somewhere that you probably already know pretty well, then builds it up.
18:20:48 <M30W> lol
18:20:57 <Nisstyre-laptop> M30W: no way to tell the difference between [Char] and Char if (show 'a') and (show "a") produced the same thing
18:21:10 <M30W> Nisstyre-laptop: Okay
18:21:14 <Nisstyre-laptop> remember show $ read (show a) == show a
18:21:16 <ski> > "\SO\&H\SOH"
18:21:17 <lambdabot>   "\SO\&H\SOH"
18:21:30 <ski> > length "\SO\&H\SOH"
18:21:32 <lambdabot>   3
18:21:39 <ski> hum
18:21:45 <hpc> > '\&H'
18:21:47 <lambdabot>   <hint>:1:3:
18:21:47 <ion> twisol: *Any* of the articles in the series so far don’t mention functors, and that’s a rather fundamental thing to know.
18:21:47 <lambdabot>      lexical error in string/character literal at character '&'
18:21:52 <sw2wolf> t (->)
18:21:55 <ski> > "\&"
18:21:57 <lambdabot>   ""
18:21:59 <sw2wolf> :t (->)
18:22:00 <lambdabot> parse error on input `->'
18:22:03 <hpc> > "\&H"
18:22:05 <lambdabot>   "H"
18:22:09 <Twisol> You have to know functors to grok monads?
18:22:14 <mikeplus64> :k (->)
18:22:14 <hpc> hmm
18:22:15 <lambdabot> * -> * -> *
18:22:18 <Nisstyre-laptop> Twisol: you have to know type classes...
18:22:19 <mikeplus64> sw2wolf:
18:22:19 <hpc> > "\SO\&"
18:22:21 <lambdabot>   "\SO"
18:22:27 * hpc confuses
18:22:35 <ski> "\SO" ++ "G"
18:22:41 <ski> > "\SO" ++ "G"
18:22:41 <Twisol> Nisstyre-laptop: type classes aren't that difficult to understand on their own
18:22:43 <lambdabot>   "\SOG"
18:22:44 <ski> > "\SO" ++ "H"
18:22:44 <Nisstyre-laptop> what is going on here?
18:22:46 <lambdabot>   "\SO\&H"
18:22:49 <M30W> > read '\SO' :: String
18:22:51 <lambdabot>   Couldn't match expected type `GHC.Base.String'
18:22:51 <lambdabot>              with actual typ...
18:22:51 <sw2wolf> mikeplus64: thx
18:22:53 <hpc> um, what
18:22:56 <ion> twisol: Every monad is an applicative functor and every applicative functor is a functor. (The type classes don’t have those dependencies due to historical reasons.)
18:23:03 <hpaste> plhk pasted “for beaky” at http://hpaste.org/79653
18:23:05 <Nisstyre-laptop> Twisol: type classes are easy to understand when they're explained to you, yes
18:23:07 <hpc> ooooh
18:23:12 <Nisstyre-laptop> that doesn't mean you understand all of the implications
18:23:21 <Twisol> ion: Yes, but you don't have to know that about monads just to be able to use them.
18:23:23 <hpc> show is inserting \& to separate escapes
18:23:25 <ski> > map chr [0 .. 15]
18:23:26 <lambdabot>   "\NUL\SOH\STX\ETX\EOT\ENQ\ACK\a\b\t\n\v\f\r\SO\SI"
18:23:39 <M30W> :t '\SOH'
18:23:40 <lambdabot> Char
18:23:44 <Twisol> Nisstyre-laptop: trying to teach all the implications of monads through a beginner's tutorial is a recipe for disaster...
18:23:55 <ion> @where typeclassopedia
18:23:55 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
18:23:56 <M30W> ski: That makes sense.
18:24:06 <Nisstyre-laptop> Twisol: trying to teach all of the implications of many things in a beginner's tutorial is a reciple for disaster
18:24:13 <Twisol> quite
18:24:54 <hpc> sadly, those implications are often what a beginner is looking for
18:25:04 <hpc> see also, agda's "tutorials"
18:25:17 <Twisol> My working understanding of monads is that >>= is monadic application in the same way that $ is functional application.
18:25:22 <ion> A monad tutorial might as well be a functor tutorial and an applicative functor tutorial at the same time.
18:25:52 <ski> > "\0\a\b\t\v\f\n\r\SP\DEL"
18:25:54 <lambdabot>   "\NUL\a\b\t\v\f\n\r \DEL"
18:25:54 * M30W plays Zelda on N64 emulator.
18:26:12 <ski> (M30W : Ocarina of Time or Majora's Mask ?)
18:26:31 <M30W> ski: Hmm
18:26:40 <ski> (or Master Quest ?)
18:26:41 <Nisstyre-laptop> understanding type classes, imo, is basically understanding the point of abstraction. You generalize a proof so that it applies to something, then write a whole bunch of proofs (functions that use Monad instances for example), then all you need to do for those pieces of code to work with your new type is prove it's an instance of Monad
18:26:41 <M30W> Video: Found ROM 'THE LEGEND OF ZELDA', CRC b71170ec2bd71676-45
18:26:48 <M30W> ski: IDK XD
18:27:07 <Nisstyre-laptop> of course I don't think that solves the problem of teaching type classes really
18:27:11 <Twisol> Nisstyre-laptop: my working understanding of type classes is that they're analogous to interfaces
18:27:14 <ski> M30W : perhaps a remake of an earlier game (the first one ?)
18:27:20 <Nisstyre-laptop> Twisol: that is basically the same thing for me
18:27:35 <M30W> The one with a slightly corrupted image on the first level
18:27:43 <M30W> first part
18:27:45 <Twisol> many imperative programmers are familiar with interfaces, so type classes aren't too much of a jump
18:28:09 <Nisstyre-laptop> Twisol: yeah, for my analogy to work they would need to be familiar with some modern algebra concepts I think
18:28:17 <M30W> Second time playing Zelda ^_^
18:28:32 <M30W> Navi, where art thou? come hither.... [bluesquare]
18:28:33 <M30W> lol
18:28:52 <ski> (M30W : search says it's "Ocarina of Time")
18:29:03 <cmccann> M30W, hey! listen! hey! hey! listen!
18:29:06 <M30W> Lol emulator ♥ f FAST FORWARD!
18:29:12 <M30W> cmccann: Listening?
18:29:16 <Twisol> Nisstyre-laptop: I haven't even taken any math higher level than calculus yet. (I'm doing discrete math and linear algebra next semester)
18:29:23 <ski> M30W : btw, you should probably take this off-topic talk to #haskell-blah (unless you can figure out a way to make it Haskell-related ! ;)
18:29:30 <cmccann> M30W, gues you haven't gotten very far in the game :P
18:29:43 <ski> (and by "you", i mean "you and me")
18:29:43 <M30W> ski: Lets make a N64 emulator in haskell :D
18:30:01 <M30W> ski: Yea.. What channel exacty?
18:30:05 <M30W> or is blah correct ?
18:30:06 <M30W> haha
18:30:14 <Twisol> #haskell-blah is the literal name
18:30:14 <M30W> lol yea.
18:30:19 <jackss> printHello = putStrLn "Hello"  <- how do you call printHello? action? function that takes no arguments and returns action?
18:30:20 <cmccann> it's a good name.
18:30:37 <shachaf> jackss: printHello isn't a function.
18:30:41 <shachaf> It's an action.
18:30:48 <jackss> yeah I figured
18:30:52 <Nisstyre-laptop> Twisol: I haven't really either, I am a noob at abstract algebra. I only know what I've learned online and through a book I have on the topic.
18:30:53 <ion> jackss: Yeah, an IO action. There’s no such thing in Haskell as a function that takes no arguments.
18:30:56 <jackss> so there is no way to do something similar with lambda?
18:31:09 <Nisstyre-laptop> Twisol: for discrete math check out Concrete Mathematics though.
18:31:16 <mikeplus64> jackss: (but you "call" it with just it's name)
18:31:24 <ion> jackss: You can only make functions with lambdas.
18:31:24 <ski> the type of it is `IO ()' -- since it doesn't contain a `->' (explicitly or implicitly), it can't be a function
18:31:36 <Twisol> Nisstyre-laptop: Gotcha. My point is just that you don't have to learn the theoretical underpinnings to be able to understand what monads are for.
18:31:46 <Nisstyre-laptop> Twisol: of course not
18:31:52 <ski> functions have types that looks like `... -> ...' (optionally with a `... => ' prefix)
18:32:26 <jackss> yes got it
18:32:29 <Nisstyre-laptop> but I still think my understanding of it works really well, because Haskell is pretty clearly designed in the "programs are proofs" mindset
18:32:50 <Twisol> Nisstyre-laptop: Absolutely. Er, the topic from before with ion is that I posted a tutorial that didn't mention functors, so ion said it was obviously bad.
18:33:08 <Nisstyre-laptop> Twisol: yeah, I don't know if not putting Functors in is bad or not
18:33:11 <jackss> and putStrLn is a pure function that takes a string and returns IO action? is that correct terminology?
18:33:21 <Nisstyre-laptop> certainly Functor is a good example of a type class and important to many many things
18:33:21 <ion> twisol: When you understand monads well enough to use them, you already understand everything needed to use functors and applicative functors. A “tutorial” that doesn’t tell you that sucks.
18:34:47 <Twisol> ion: Well, I disagree. That tutorial helped me solidify some monadic concepts for me, at least.
18:35:33 <Nisstyre-laptop> Twisol: I think most of the "type classes are interfaces" analogies break down pretty quickly once you get into more complex type class and instance declarations
18:35:55 <beaky> :t Maybe 3 >>= Nothing
18:35:57 <lambdabot> Not in scope: data constructor `Maybe'
18:36:00 <beaky> :(
18:36:04 <beaky> :t Just 3 >>= Nothing
18:36:04 <Nisstyre-laptop> but then again I'm not *that* familiar with how interfaces work in OOP languages
18:36:05 <lambdabot>     Couldn't match expected type `a0 -> Maybe b0'
18:36:06 <Twisol> Nisstyre-laptop: Probably, but I think it's an excellent baby step for imperative programmers to take.
18:36:06 <lambdabot>                 with actual type `Maybe a1'
18:36:06 <lambdabot>     In the second argument of `(>>=)', namely `Nothing'
18:36:11 <beaky> :t Just 3 + Nothing
18:36:13 <lambdabot> (Num a, Num (Maybe a)) => Maybe a
18:36:18 <beaky> >Just 3 + Nothing
18:36:27 <beaky> > Just 3 + Nothing
18:36:29 <Nisstyre-laptop> Twisol: fair enough
18:36:29 <Twisol> Nisstyre-laptop: I'm from heavily imperative languages originally, so it helps me to think about things like that.
18:36:29 <lambdabot>   No instance for (GHC.Num.Num (Data.Maybe.Maybe a0))
18:36:29 <lambdabot>    arising from a use o...
18:36:35 <ski> > Just 3 >> \_ -> Nothing
18:36:36 <lambdabot>   Couldn't match expected type `t0 -> t1'
18:36:37 <lambdabot>              with actual type `Data...
18:36:41 <ski> > Just 3 >>= \_ -> Nothing
18:36:42 <lambdabot>   Nothing
18:36:46 <Nisstyre-laptop> Twisol: in that case I recommend looking at Racket as well
18:36:56 <Twisol> The Scheme dialect?
18:37:01 <Nisstyre-laptop> yeah, sort of
18:37:08 <Nisstyre-laptop> I hesitate to call it a Scheme dialect
18:37:16 <Twisol> it was previously PLT Scheme or something?
18:37:20 <ski> Racket includes a scheme
18:37:21 <ski> yes
18:37:26 <Nisstyre-laptop> yeah, and then they decided it wasn't really Scheme
18:37:28 <Twisol> I played with it in the past. Wasn't drawn to it like I was Haskell for some reason.
18:37:41 <ski> Nisstyre-laptop : i thought they decided it was more than Scheme
18:37:49 <Nisstyre-laptop> ski: it's multiple languages yeah
18:37:56 <Nisstyre-laptop> it does include some Schemes
18:38:18 <Twisol> guess I figured, if I wanted to learn functional programming, I should go in all the way. :P
18:38:42 <Twisol|afk> back in a few, errands
18:40:43 <popl> Twisol|afk: Thanks for letting us know.
18:40:52 * popl informs NORAD
18:45:05 <hpaste> beaky pasted “Using the Maybe monad to handle diagonal movements” at http://hpaste.org/79654
18:45:23 <beaky> Is this use of Maybe correct? or is there a more elegant way to avoid duplication?
18:45:36 <beaky> I tested it and it works fine :D
18:47:59 <Saizan> looks like you should use lenses
18:48:06 <beaky> lenses?
18:48:09 <beaky> what's that
18:48:41 <Peaker> beaky, look at the hlint warnings first
18:48:54 <beaky> ah
18:48:59 <beaky> thanks
18:49:05 <beaky> I forgot to use hlint :(
18:49:11 <Peaker> beaky, instead of putting same val in, then comparing to yield Maybe, why not use Maybe in the first place?
18:49:39 <beaky> I'm too lazy to make the users convert to Maybe :(
18:49:46 <Peaker> beaky, lenses are meant to remove this exact kind of boilerplate :)
18:50:15 <Peaker> beaky, I'd suggest making a single "inRange" function and using that after movePlayer is done
18:50:52 <Peaker> beaky, want me to edit the code a bit to show some potential improvements?
18:51:02 <beaky> sure
18:51:47 <Peaker> weird of you to use "y" for horizontal, and "x" for vertical
18:51:52 <Peaker> counter-convention
18:51:59 <beaky> ah
18:52:14 <beaky> I thought it was the other way around
18:52:23 * beaky facepalms
18:52:35 <beaky> I didn't know the convention
18:52:59 <beaky> maybe I can fix this with just one vim command :D
18:54:27 <beaky> if I use record syntax, where do I put the bangs for strict fields
18:55:19 <Jafet> A { !b :: c }
18:57:37 <hpaste> Peaker annotated “Using the Maybe monad to handle diagonal movements” with “Using SECs” at http://hpaste.org/79654#a79655
18:57:52 <beaky> lenses to the rescue :D
18:57:59 <Peaker> beaky, here it is with SECs, which are weaker forms of lenses
18:58:02 <Peaker> (less to learn to use them)
18:58:19 <Peaker> well, not weaker forms of lenses, since they aren't lenses.. just a weaker construct than lens
18:58:27 <Peaker> but with some overlap
18:58:52 <Peaker> @where SEC
18:58:52 <lambdabot> http://conal.net/blog/posts/semantic-editor-combinators/
18:58:55 <Peaker> beaky, the SEC part is   atPlayer . atPos    and to understand that I suggest reading the above link
18:59:08 <beaky> ah thanks
18:59:12 <beaky> looks easier to understand than monads :D
18:59:22 <sw2wolf> @where xmonad-extras
18:59:22 <lambdabot> I know nothing about xmonad-extras.
18:59:39 <sw2wolf> @where xmonad-contrib
18:59:39 <lambdabot> http://xmonad.org/xmonad-docs/xmonad-contrib/
18:59:57 <hpaste> Peaker annotated “Using the Maybe monad to handle diagonal movements” with “With alignments” at http://hpaste.org/79654#a79656
19:00:20 <Peaker> beaky, did you read LYAH?
19:00:28 <Peaker> I think it introduces Functor, then Applicative, then Monad
19:00:33 <Peaker> beaky, which is a good way to learn monads
19:01:23 <beaky> ah
19:01:23 <Peaker> beaky, if you use lens -- you get the atPlayer/atPos functions for free - and much more
19:01:52 <beaky> maybe lens might help eliminate all this duplicate cruft
19:06:14 <Peaker> beaky, I already did, without lens there, look at my annotation
19:06:22 <Peaker> http://hpaste.org/79654#a79656
19:08:08 <beaky> ah
19:10:26 <Saizan> Peaker: dir doesn't typecheck like that
19:10:46 <Peaker> oops
19:10:55 <hpaste> Peaker annotated “Using the Maybe monad to handle diagonal movements” with “With alignments (annotation)” at http://hpaste.org/79654#a79658
19:11:04 <beaky> hehe
19:11:10 <Peaker> another oops there :)
19:11:18 <Peaker> beaky, if you gave buildable source I could make less type errors :)
19:11:24 <beaky> right
19:11:44 <hpaste> Peaker annotated “Using the Maybe monad to handle diagonal movements” with “With alignments (annotation) (annotation)” at http://hpaste.org/79654#a79659
19:16:45 <Peaker> My "all" should also be an "and"
19:22:04 <beaky> it works!
19:23:18 <Peaker> beaky, :)
19:23:20 <beaky> so that's what lenses are?
19:23:26 <Peaker> no :)
19:23:34 <Peaker> but it's a big step in the direction of lens
19:23:44 <Peaker> understanding it will help understanding lens
19:25:23 <Peaker> beaky, SECs as described in the link above (e.g: atPlayer, atPos) are "setters" in the terminology of the (rather new) "lens" package
19:25:40 <beaky> ah
19:25:47 <Peaker> beaky, they can only modify values inside another value, and they can change the type while doing so. They cannot, however, perform effects to change the value
19:26:02 <Peaker> beaky, they also cannot be used to read the value, or fold over values, or other interesting things
19:26:42 <Peaker> beaky, a "lens" is like a setter that can also get exactly one element. a "traversal" is like a setter that can also be used to get all the values inside
19:26:53 <beaky> why are they called lenses?
19:27:07 <johnw> because they "focus" on a substructure within a structure
19:27:11 <beaky> ah
19:27:18 <beaky> lenses sound so neat
19:27:49 <johnw> whether that substructure is 0or1 (prism), exactly1 (lens), 0ormore (fold), or 1ormore(traversal)... if I have the terminology right
19:27:55 <beaky> even those SECs could eliminate duplication
19:29:01 <ski> hm .. reminds me of determinisms `semidei',`det',`nondet',`multi' in Mercury
19:29:29 <shachaf> johnw: That's not it.
19:29:32 <ski> (um, s/dei/det/)
19:29:37 <johnw> ah, there you are
19:29:39 <johnw> please correct me
19:29:43 <shachaf> johnw: Traversals are lenses for 0-or-more items.
19:29:47 <johnw> ok
19:29:49 <johnw> and folds?
19:29:52 <shachaf> Folds are read-only traversals.
19:29:56 <johnw> ah!
19:29:59 <johnw> got it
19:30:00 <Peaker> also there are setters that can't have effects for update
19:30:02 <shachaf> Prisms aren't just traversals.
19:30:08 <Peaker> but can update 0 or more
19:30:27 <johnw> i still don't quite get why Isos are a big thing for lens
19:30:27 <shachaf> They let you work backwards -- so for example the prism for _left lets you do a -> Either a b
19:30:45 <shachaf> Isos are just the (second-) strongest thing you can say about two types.
19:30:59 <johnw> Isos are like having a functionally invertible lens?
19:31:00 <Peaker> prisms are first-class data constructors in the same sense that lens are first-class product fields
19:31:04 <shachaf> Which is that they're exactly equivalent.
19:31:33 <shachaf> (The strongest thing you can say is that they're *equal*. The next version of lens might support that too.)
19:31:44 <hpaste> beaky pasted “haskell roguelike” at http://hpaste.org/79662
19:31:58 <shachaf> (Actually there are possibly some things between isomorphism and equality. But anyway.)
19:32:19 * ski . o O ( .. retracts )
19:32:38 <johnw> shachaf: which is equivalence closer to?
19:33:11 <beaky> equivalence is like virtuality
19:33:27 <shachaf> Precisely.
19:33:30 <shachaf> johnw: (?)
19:33:39 <shachaf> What's equivalence?
19:33:49 <johnw> p ⇔ q
19:34:02 <shachaf> Oh, an arrow. I understand now. :-)
19:34:40 <shachaf> johnw: If I have an isomorphism between two types, it's like a pair of functions (f, g) such that f (g x) = x and g (f y) = y
19:34:55 <johnw> yes, that law I know well
19:35:02 <shachaf> So you can convert back and forth freely, operate on one representation and then switch to the other, and so on.
19:35:03 <johnw> and equality means f x = g x
19:35:27 <beaky> how do you escape a monad like the IO monad?
19:35:30 <shachaf> Well, Equal' s a means that s = a
19:35:35 <johnw> beaky: what do you mean by "escape"?
19:35:40 <johnw> do you mean unsafePerformIO?
19:35:59 <Saizan> johnw: he is asking :)
19:36:13 <beaky> yeah unsafePerformIO
19:36:27 <Saizan> you shouldn't though
19:36:32 <johnw> yeah, that's to be avoided
19:36:51 <plhk> too late
19:36:58 <beaky> how do you turn an IO a into an a
19:37:04 <Peaker> beaky, you're not supposed to escape IO
19:37:07 <johnw> @hoogle IO a -> a
19:37:07 <lambdabot> Foreign.Marshal unsafeLocalState :: IO a -> a
19:37:08 <lambdabot> System.IO.Unsafe unsafePerformIO :: IO a -> a
19:37:08 <lambdabot> Foreign unsafePerformIO :: IO a -> a
19:37:13 <beaky> you can use fromMaybe to turn a Maybe a into an a
19:37:14 <ski> you shouldn't use `unsafePerformIO', unless you either know that the action passed is essentially equivalent to an action `return x' for some `x'; or you really know what you're doing
19:37:24 <johnw> we should define unsafePerformIO in such a way that no one can remember i
19:37:25 <johnw> t
19:37:27 <Peaker> beaky, you can't really take a value out of IO into your function, but you can take your function into IO where it can see the value
19:37:33 <beaky> ah :(
19:37:45 <beaky> so the IO Monad essentially pollutes your types?
19:38:01 <beaky> unless you stay in the IO Monad
19:38:18 <Peaker> beaky, it pollutes the types that involve IO, it's the point :)
19:38:36 <ski> (if you don't know what you're doing, then things which you thought would happen once may not happen, or happen more than once (or what you thought would happen more than once only happens once) -- and order may be affected, and probably worse as well)
19:38:38 <Peaker> beaky, the idea is that by polluting the types that do IO -- *not* having IO in the type is telling you great things
19:38:52 <Cale> beaky: You can, inside of an IO action, run an IO action of say type IO t and take its result of type t and pass that as a parameter to a pure function.
19:39:03 <Peaker> beaky, it's less about what we learn from seeing "IO" in the type -- and more about what we learn by *not* seeing it
19:39:04 <ski> beaky : "so the IO Monad essentially pollutes your types?" -- yes, that's the point of it
19:39:18 <Cale> do x <- getLine; putStrLn (reverse x)
19:39:41 <beaky> ah
19:39:43 <Cale> in this piece of code, reverse doesn't need to know or care that its parameter came from doing IO
19:40:24 <beaky> so the IO Monad's >>= lets pure fuctions return impure stuff?
19:40:43 <beaky> s/return/work with
19:40:53 <plhk> that's what return is for
19:40:59 <beaky> oh
19:41:04 <Cale> well
19:41:22 <ski> @type do x <- getLine; return (reverse x)
19:41:24 <lambdabot> IO [Char]
19:41:28 <Cale> If v is any value, then return v is the action which does nothing, but returns v as its result.
19:41:59 <ski> (note that "action returning result ..." is very different from "expression evaluating to result ...")
19:42:05 <Cale> >>= takes an IO action, and a function from the result of that action to further actions, and combines them in the obvious way.
19:42:07 <beaky> ah
19:42:41 <Cale> i.e. x >>= f is the action which when run, will first run x, then if x's result is v, it will then run (f v)
19:42:54 <popl> Cale: Which way is obvious?
19:42:56 <Cale> returning the result of (f v) as its result
19:43:02 * popl asks an obvious question.
19:43:12 <ski> popl : the one he just explicated :)
19:43:12 <Cale> I just explained that
19:43:20 <popl> Ok.
19:43:30 <Cale> It's sort of the only thing it could do, given the type
19:44:29 <beaky> :t (>>=)
19:44:31 <lambdabot> Monad m => m a -> (a -> m b) -> m b
19:44:33 <Peaker> well, someone who doesn't yet know what Monads are is likely going to have trouble figuring out what the only way from the type is -- especially as the type involves an un-understood Monad constraint
19:44:56 <beaky> :(
19:45:19 <ski> @type (>>=) :: IO a -> (a -> IO b) -> IO b  -- no constraint here, though
19:45:21 <lambdabot> IO a -> (a -> IO b) -> IO b
19:45:33 <popl> ski: I type slow.
19:45:49 <Peaker> beaky, didn't mean it in a bad way, just that "obvious" is not usable in an explanatory context like this
19:46:19 <beaky> ah
19:46:44 <popl> ski: I have +g set. I don't like people sending me private messages uninvited. :P
19:46:46 <cmccann> clearly it was also obvious that Peaker did not mean it in a bad way.
19:46:47 <beaky> hopefully as my roguelike gets more complex I will get a better idea of what monads are :D
19:46:52 <cmccann> obviously.
19:46:57 <beaky> hehe
19:47:01 <Peaker> http://conal.net/blog/posts/fostering-creativity-by-relinquishing-the-obvious
19:47:51 <shachaf> ">>= takes a list, and a function from an element of that list to further lists, and combines them in the obvious way."
19:47:56 <Peaker> beaky, it's best to go from concrete (Maybe, IO, list, and their functions) to the abstract (Functor, Applicative, Monad).. It's hard to understand the abstract first
19:48:12 <beaky> right
19:48:38 <Peaker> http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html <-- is widely cited as the best explanation
19:48:49 <shachaf> Really? I didn't much like it.
19:48:52 <ski> popl : well, in this case i just did a `/ctcp popl version', not a `/msg popl ...'
19:49:05 <johnw> i didn't care for it much either, sorry to say
19:49:06 <beaky> they don't seem too abstract; everyday I see folks here using <$>, <*>, <=<, and &&& on lambdabot to solve problems :D
19:49:14 <cmccann> shachaf doesn't like many things.
19:49:18 <popl> ski: It's rude to do that, too. :P
19:49:25 <johnw> cmccann: :)
19:49:31 <ski> popl : if you say so
19:49:34 <Twisol|afk> Didn't really like it much myself, but it does help a little
19:49:39 <popl> I did!
19:49:56 <ski> then, by modus ponens, it is indeed rude to do that
19:50:03 <cmccann> I don't think I really paid much attention to most monad tutorials until I already had the basic idea
19:50:05 <shachaf> cmccann: I mean that it didn't help me much, back when I read it.
19:50:09 <johnw> beaky: i'll wager you use <$> often too, but you just don't recognize it yet :)
19:50:25 <cmccann> so I can't really say which if any helped me. if they did, it was only indirectly.
19:50:26 <popl> modus pwns?
19:50:27 <popl> ;P
19:50:31 * ski waits for someone to demand a use (or two) of modus ponens for the application of modus ponens
19:50:58 <Peaker> beaky, they are very useful operators... they are not just useful operations, though, which are very easy to think about (as they are concrete). They are also *generalizations* of these operations with laws stating the commonalities. That part is harder to learn and think about, at least initially
19:51:40 <beaky> ah
19:51:45 <beaky> so they are typeclasses
19:51:48 <Peaker> beaky, people come to learn Haskell, and try to learn the generalizations (e.g: Monad) before learning the specific instances.. this is bound to fail
19:52:18 <cmccann> actually, I think it was the point where I realized I'd just spent an hour reinventing the monad instance for Either that the abstraction itself finally clicked for me
19:52:53 <cmccann> so that's probably another one for the "start with the concrete examples" camp
19:52:53 <Peaker> for me it was just manually implementing the State type and figuring out its monad instance
19:52:56 <beaky> so typeclasses are like design patterns
19:52:57 <Twisol> reinvention is a really useful way to learn.
19:53:14 <beaky> you start by code duplication and reinventing stuff, then you see patterns that can be generalized
19:53:15 <cmccann> yeah, I think I reimplemented State as well but that was intentional
19:53:33 <Peaker> beaky, typeclasses capture these design patterns -- so they become code... "design patterns" usually means things we must design over and over again because we cannot capture in code
19:53:42 <Twisol> ^
19:53:45 <cmccann> I think I reinvented the automaton arrow a couple times before Arrow started to make sense
19:53:47 <Peaker> cmccann, Yeah, it was intentional for me too, just to learn
19:54:09 * flebron is finishing LYAH :)
19:54:16 <latro`a> I am always slightly thrown off by >=> in State literally being .
19:54:26 <latro`a> after constructors are removed
19:54:28 * popl gives flebron a cookie.
19:54:43 <cmccann> latro`a, need a bit of uncurrying in there too, don't you?
19:55:01 <latro`a> might
19:55:06 <latro`a> but still
19:55:08 <cmccann> but yeah, it boils down to (s, a) -> (s, a)
19:55:31 <latro`a> erm, b
19:55:33 <latro`a> for one
19:55:34 <cmccann> and if you er
19:55:34 <latro`a> but yeah
19:55:37 <cmccann> yes
19:56:05 <cmccann> anyway if you screw around so that composing things is done in a different order for the two halves of the tuple
19:56:08 <cmccann> you get the "reverse" state monad
19:56:14 <cmccann> which is hilariously bizare
19:56:19 <latro`a> yeah, I've seen that
19:56:24 <latro`a> very amusing do notation
19:56:26 <latro`a> with it
19:56:38 <latro`a> when everything's fully expanded, it's not as amusing, since it's just corecursion
19:56:44 <latro`a> but in state form it really does look like time travel
19:56:46 <cmccann> yeah
19:58:35 <Twisol> Tardis! http://hackage.haskell.org/package/tardis-0.3.0.0
19:58:40 <cmccann> then again tying the knot looks a bit like time travel too
19:58:55 <johnw> tying the knot is a real mind bender
19:58:59 <cmccann> like you're taking something from the future that later becomes the thing you take back in time
19:59:10 <cmccann> but it never has any actual origin, just an endless time loop
20:00:06 <cmccann> hm. if I ever write a haskell tutorial, someone remind me to title the section about tying the knot "all you zombies"
20:00:52 <johnw> cmccann: one question I had about tying the knot
20:01:02 <dmwit> Time loops are weird. You would expect an object to decay and break, eventually, but the objects in a time loop never do.
20:01:26 <johnw> so, cycle [0,1] is indistinguishable from a circularly linked list; but do they have different heap characteristics?
20:01:53 <dmwit> johnw: That depends on the implementation. In GHC, no.
20:02:16 <johnw> so it's the way laziness is implemented which causes the two to be functionally identical?
20:02:42 <dmwit> hm
20:02:44 <dmwit> I don't think so.
20:02:51 <dmwit> You can tie knots in OCaml, which is strict.
20:02:56 <johnw> let x = (0:y); y = (1:x) in x == cycle [0,1]?
20:02:58 <Saizan> but be careful, concat . repeat wont' produce something circular
20:03:14 <Saizan> johnw: yep
20:03:24 <dmwit> yes, but for "real" ==, not "Haskell" ==
20:03:24 <ski> s/let/let rec/
20:03:30 <cmccann> johnw, here, read this ancient reddit comment I wrote: http://www.reddit.com/r/haskell/comments/c4hnr/zhuangzi_butterfly_and_referential_transparency/c0q2wfw
20:03:48 <ski> er, i.e., if that would have been OCaml
20:03:50 <johnw> cmccann: thanks!
20:04:47 <johnw> how does one decide when to put a library in "Data" and when "Control"?
20:05:01 <cmccann> (in case it's not clear, "vacuum" is a package that shows the heap representation of data)
20:05:21 <johnw> cmccann: i'm using ghc-heap-view, is that roughly the same?
20:05:32 <dmwit> johnw: via biased coin toss
20:05:40 <dmwit> 60% Data, 40% Control
20:06:01 <cmccann> johnw, it claims to be inspired by vacuum, so probably similar
20:06:21 <johnw> i want to make an API library for a web service, is that really a Data-ish thing?
20:06:32 <johnw> i guess it's all about getting and sending data
20:06:38 <johnw> rather than changing the flow of controls of programs
20:07:06 <cmccann> basically the way it works is that people tack on whatever "top-level" modules they think sound good
20:07:10 <cmccann> sometimes they make up new ones
20:07:27 <dmwit> johnw: Perhaps Network.*
20:07:56 <Saizan> do we have much in Meta.*?
20:07:58 <johnw> that's a good idea
20:08:07 <dmwit> We have Acme.*, that's almost as good as Meta
20:08:24 <cmccann> Acme is the best module category.
20:08:32 <Saizan> i can't make jokes about emacs chords with Acme
20:08:45 <Saizan> but i don't think they'd be good anyway
20:08:49 <johnw> Saizan: Alt Meta Control Escape
20:08:54 <johnw> err
20:08:59 <dmwit> so close
20:09:11 * ski . o O ( <http://en.wikipedia.org/wiki/Acme_(text_editor)> )
20:09:12 * cmccann considers what would justify a qualified name of Control.Alt.Delete
20:09:36 <dmwit> Control.Alternative.Delete
20:10:19 <cmccann> yeah, but what would it do?
20:10:20 <cmccann> hm.
20:10:37 <cmccann> man, I hate having a great joke name but no excuse to use it.
20:11:41 <cmccann> though for incredibly silly qualified names it's hard to beat Data.Data.Data
20:12:03 <roconnor> Is that the FQN for the Data class?
20:12:22 <cmccann> yep
20:12:40 <cmccann> it's beautiful.
20:12:54 <dmwit> The frustrating thing is that it's kind of defensible.
20:13:01 <Saizan> lacks a punchline
20:13:12 * ski . o O ( `Data.M.C' )
20:13:30 <cmccann> dmwit, yes! that's the best part. it's so clearly ridiculous but what else would you do with it?
20:20:19 <beaky> http://stackoverflow.com/questions/12659951/how-does-this-piece-of-obfuscated-haskell-code-work
20:21:54 <beaky> >fix$(<$>)<$>(:)<*>((<$>((:[])<$>))(=<<)<$>(*)<$>(*2))$1
20:22:00 <beaky> > fix$(<$>)<$>(:)<*>((<$>((:[])<$>))(=<<)<$>(*)<$>(*2))$1
20:22:02 <lambdabot>   [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,...
20:23:24 <latro`a> oh dear
20:23:42 <roconnor> @unpl fix$(<$>)<$>(:)<*>((<$>((:[])<$>))(=<<)<$>(*)<$>(*2))$1
20:23:42 <lambdabot> (((fix ((<$>) <$> ((:)))) <*> ((((\ j k -> k >>= j) <$> \ b -> (\ a -> a : []) <$> b) <$> (*)) <$> \ d -> d * 2)) 1)
20:23:53 <cmccann> wow, that helped. thanks, lambdabot!
20:24:01 <beaky> wow
20:24:04 <roconnor> @unpl fix$(<$>)<$>(:)<*>((<$>((:[])<$>))(=<<)<$>(*)<$>(*2))
20:24:04 <lambdabot> ((fix ((<$>) <$> ((:)))) <*> ((((\ h i -> i >>= h) <$> \ b -> (\ a -> a : []) <$> b) <$> (*)) <$> \ d -> d * 2))
20:24:09 <roconnor> :/
20:24:16 <cmccann> dmwit's explanation on SO is pretty good.
20:24:32 <pdxleif> What does it mean to have "data Foo", that is, define a type with no constructors?
20:24:33 <johnw> hm.. I have a type with kind * -> * -> Constraint; is there any way I can use it with Control.Category?  or do I need to remove the constraint?
20:24:36 <beaky> http://www.theregister.co.uk/2012/12/21/financial_software_disasters/print.html says that haskell is evil :(
20:24:40 <pdxleif> Does that just mean an unpopulated type?
20:24:45 <cmccann> pdxleif, it means it's a type with no constructors.
20:25:00 <cmccann> it has no values other than non-termination/errors/&c
20:25:22 <pdxleif> Was reading this code: https://github.com/snoyberg/yaml/blob/master/Text/Libyaml.hs#L114
20:25:35 <cmccann> beaky, it's the register. being assholes while reporting on technology is what they do.
20:26:55 <beaky> lol
20:27:08 <cmccann> pdxleif, types like that are generally used to mark something via the type system, they have no constructors because you're not supposed to use them directly
20:27:11 <pdxleif> So here's it's just being used to give a type to structs used via a C api?
20:27:20 <cmccann> basically
20:27:30 <cmccann> it's a stand-in for the struct type
20:27:40 <cmccann> which you can't get hold of directly
20:28:23 <pdxleif> phantom types?
20:28:50 <cmccann> phantom types are type parameters that aren't used for values, e.g. "data Foo a b = Foo b"
20:29:03 <pdxleif> Oh, yeah.
20:29:15 <pdxleif> thanks!
20:29:16 <cmccann> empty data types are not quite the same thing
20:29:30 <cmccann> you can have e.g. "Maybe Foo" even if Foo has no constructors
20:29:43 <cmccann> it will either be an error or Nothing, obviously
20:30:10 <cmccann> but if you have a type that will only be used as a phantom type making it empty is sensible
20:31:51 <pdxleif> In the dependently typed idris, they have a type "so" of kind "Bool -> *", but there's only a constructor for "so True".
20:31:59 <Saizan> can be more convenient to make them singletons, actually
20:34:20 <cmccann> Saizan, sometimes, yeah
20:34:21 <kennyd> "According to a friend in academia who’s studied it, it’s [Haskell] "the Taliban version of ML,” in which it’s all but impossible to write readable code."
20:34:27 <kennyd> :)
20:34:46 <kennyd> whatever that means
20:35:45 * cmccann isn't sure either
20:36:14 <djahandarie> Is that friend Bob Harper?
20:36:15 <cmccann> clearly written by somebody who doesn't know enough about Haskell to make fun of it properly :[
20:37:42 <cmccann> compare this:
20:37:43 <cmccann> @quote kmc ints.exist
20:37:43 <lambdabot> kmc says: "Haskell is great, because Curry-Howard!  Proving things in the type system.  We can prove that, uh, Ints exist, unless they're ⊥."
20:38:06 <pdxleif> I've heard someone refer to ML as for when "you don't necessarily want to be so facist about state"
20:39:00 <pdxleif> Haskell is unreadable in that it lacks sufficient semicolons, clearly.
20:39:18 <cmccann> Haskell has plenty of semicolons!
20:39:25 <cmccann> just most of them are optional.
20:39:40 <cmccann> the report still specifies a lot of things that way, though.
20:40:48 <beaky> how do I write haskell with semicolons?
20:40:56 <beaky> haskell's a curly brace language like C?
20:41:02 <beaky> thought it was like python :(
20:41:06 <mikeplus64> it's both
20:41:13 <beaky> ah, best of both worlds
20:41:15 <kennyd> and to back this up author copy/pasted obfuscated to hell equivalent of map (^2) [1..]
20:41:17 <cmccann> beaky, the whitespace rules are specified in terms of translation to curly-braces and semicolons
20:41:25 <mikeplus64> you can do case x of { y -> z; ... }
20:41:31 <mikeplus64> or do { x; y; z; ... }
20:41:39 <mikeplus64> or let { ... } in { ... }
20:41:42 <cmccann> so technically it's C-like, but you can write it like python and the compiler adds the ugliness for you
20:42:48 <cmccann> the braces and semicolons are useful for e.g. generated code or one-liners
20:43:08 <cmccann> though now that GHCi supports multiline stuff and TH has more features those aren't as big a deal
20:45:09 <beaky> what is TH?
20:45:20 <johnw> Template Haskell
20:45:30 <beaky> ah
20:45:35 <beaky> like c++ templates?
20:45:57 <johnw> a bit more like Lisp macros
20:46:17 <johnw> c++ templates are extremely constrained
20:46:34 <Twisol> We pretty much have C++ templates just by having ADTs...
20:46:38 <beaky> what can C++ templates do that Lisp macros can?
20:46:49 <beaky> what can Lisp macros do that C++ templates can't*
20:47:00 <johnw> use the filesystem :)
20:47:08 <beaky> ah
20:47:31 <johnw> i'm not sure if TH is as complete as Lisp, but it's in that direction
20:48:39 <beaky> TH seems rarely needed as Haskell is a very expressive language
20:50:11 <pdxleif> C++ templates are kind of like Haskell itself: http://bartoszmilewski.com/2009/10/21/what-does-haskell-have-to-do-with-c/
20:50:30 <cmccann> TH is hobbled vs. lisp macros in large part by Haskell ASTs being horrendous monstrosities compared to lisp ASTs, which are largely indistinguishable from the lisp code itself
20:51:58 <pdxleif> TH is handy if you want to embed another syntax via quasiquotes.
20:55:26 <lewisx> beaky: lisp macros can use entire language and it's runtime at compile time
20:55:30 <beaky> ah
20:55:46 <beaky> sounds very powerful
20:55:51 <beaky> like C++ templates on steroids
20:56:55 <cmccann> TH is clumsy in some ways but it can also do pretty much anything
20:57:39 <beaky> haskell seems pretty hard to write a compiler for compared to lisp
20:57:57 <pdxleif> You can use your language at compile-time if it's dependently typed, but that's just for types, not for generating ASTs.
20:58:01 <cmccann> GHC seems pretty hard to have written compared to
20:58:02 <cmccann> lots of things
20:58:13 <cmccann> having looked at its code a couple times and being scared off
20:58:52 <cmccann> haskell itself minus all of GHC's extra bells and whistles isn't too bad though
20:59:15 <cmccann> once you finish desugaring all the syntax it's actually a pretty simple language
20:59:24 <cmccann> with very few things built in
21:00:18 <cmccann> a compiler for standard haskell with no extensions that generates very slow code wouldn't be that hard to write, really
21:03:10 <beaky> would probably be dog slow though :(
21:03:42 <dmwit> beaky: Out of curiosity, where did you see that link?
21:03:59 <dmwit> I've been getting a bit of SO karma the last few days for it, wondered if it popped up on some social media site or something.
21:04:06 <beaky> dmwit: http://www.reddit.com/r/programming/comments/159fjf/what_compsci_textbooks_dont_tell_you_real_world/
21:04:25 <monadicity> can every monadic program be written in terms of adjunctions?
21:04:35 <cmccann> dmwit, yeah, a link from el reg
21:05:18 <johnw> monadicity: i'm not so sure about that yet
21:05:33 <monadicity> I think the converse is true
21:05:36 <dmwit> monadicity: Somebody was telling me the other day that all monads arise from an adjunction. Whether that adjunction is expressible in Haskell is another question, I suppose.
21:05:46 <cmccann> that link got submitted to /r/haskell recently, and then removed because it was kinda stupid
21:06:07 <monochrom> heh
21:06:29 * cmccann notes that Cont arises naturally from a self-adjoint contravariant functor or some other abstract nonsense like that
21:06:30 <beaky> lol
21:06:39 <cmccann> and [] is the usual free monoid functor
21:06:41 <beaky> abstract nonsense
21:06:42 <cmccann> er, monad
21:06:54 <cmccann> in both cases the "obvious" adjunction involves a category that isn't Hask
21:07:15 <monadicity> why don't we make categories inside haskell?
21:07:22 <cmccann> @src Category
21:07:23 <lambdabot> Source not found.
21:07:24 <johnw> monadicity: Control.Category
21:07:26 <cmccann> dammit lambdabot
21:07:37 <popl> @hoogle Category
21:07:37 <lambdabot> Control.Category class Category cat
21:07:37 <lambdabot> Control.Category module Control.Category
21:07:38 <monadicity> then we can define adjunctions between categories
21:07:38 <lambdabot> package category-extras
21:07:43 <popl> cmccann: ^
21:07:45 <johnw> yes, you can
21:07:55 <cmccann> @hackage adjunctions
21:07:55 <lambdabot> http://hackage.haskell.org/package/adjunctions
21:07:57 <monadicity> how would that relate to the standard monad?
21:08:19 <johnw> monadicity: here's my definition of the State monad using adjunctions: https://github.com/jwiegley/posts/blob/master/Adjunctions%20in%20Haskell/Adjunction.hs
21:08:29 <johnw> it's shocking how simple the definition is, in those terms
21:08:45 <johnw> I had to convince myself it's really doing the job of the State monad
21:09:05 <zzo38> do { f' <- case f of { Fa -> [Fb]; Fh -> [Fg]; _ -> [pred f, succ f]; }; let { z = Square f' (pm r); } in (do { (x, _) <- maybeToList $ g z; z <$ guard (x /= w); }) ++ (do { u' <- maybeToList u; guard ((w == White && r == R5) || (w == Black && r == R4)); z <$ guard (u' == f'); )}; }    This seem messy to me, is there the better way?
21:09:05 <shachaf> Why does that file say .hs when it obviously contains Agda. :-9
21:09:08 <cmccann> you get the state monad from the currying adjunction
21:09:08 <shachaf> s/9/(/
21:09:14 <cmccann> so it's very nicely elegant to construct in Haskell
21:09:25 <johnw> shachaf: probably because I was reading about Agda that week
21:09:27 <monadicity> johnw, that is nice
21:09:44 <cmccann> also, this topic came up on Stack Overflow recently: http://stackoverflow.com/q/13937289/157360
21:09:50 <shachaf> johnw: I'm mostly just talking about the gratuitous Unicode.
21:09:50 <monadicity> it seems like adjunctions could be used for practical programming in haskell.
21:10:06 <zzo38> I think you can also get a state monad from    State x = Codensity ((->) x)
21:10:16 <cmccann> shachaf, don't make me start typing in fraktur again
21:10:19 <cmccann> I'll do it I'm crazy
21:10:22 <johnw> edwardk's formulation is nicer in that he makes use of Functor composition, rather than simply having two type parameters on the Monad type class, for example
21:10:36 <shachaf> Codensity (x ->)?
21:10:45 <johnw> 𝔰𝔥𝔞𝔠𝔥𝔞𝔣
21:10:49 <shachaf> Codensity m a = forall r. (a -> m r) -> m r, right?
21:11:03 <zzo38> shachaf: Yes. And it is a monad regardless of what m is.
21:11:25 <shachaf> State s a = forall r. (a -> (r -> s)) -> r -> s?
21:11:35 <cmccann> it's like ContT except it doesn't allow the really confusing shenanigans
21:11:36 <zzo38> No
21:11:45 <shachaf> Er.
21:11:49 <shachaf> I got the arrow backwards.
21:11:52 <zzo38> Yes
21:11:56 <shachaf> State s a = forall r. (a -> (s -> r)) -> s -> r?
21:12:03 <zzo38> Yes.
21:12:14 <zzo38> It does work you can try it.
21:12:35 * hackagebot Boolean 0.1.2 - Generalized booleans  http://hackage.haskell.org/package/Boolean-0.1.2 (ConalElliott)
21:12:40 <zzo38> It also means you can make up a state in a continuation monad in a similar way.
21:12:55 <cmccann> well, it's obviously equivalent to s -> ((s, a) -> r) -> r
21:13:08 <cmccann> which is just State with the extra CPS-y nonsense
21:13:21 <shachaf> Right.
21:13:56 <cmccann> codensity with "m r" = "r -> r" is more interesting
21:14:00 <cmccann> since that's not even a functor on its own
21:14:09 <zzo38> cmccann: Codensity Endo = []
21:14:11 <beaky> @hoogle shuffle
21:14:12 <lambdabot> package random-shuffle
21:14:20 <cmccann> yep
21:14:31 <beaky> how do you shuffle a list in a purely functional way?
21:14:45 <zzo38> It is giving in terms of the fold function.
21:14:48 <cmccann> you get "(a -> r -> r) -> r -> r" which is recognizable as foldr
21:15:11 <shachaf> @yarr -> yarr -> yarr
21:15:12 <lambdabot> Eat maggoty hardtack, ye unkempt, jenny frequentin', son of a gun.
21:15:22 <zzo38> If you use my defintions of the Plus class, you even get the MonadPlus instance for free with this!
21:15:25 <cmccann> beaky, with a PRNG and a seed value provided from somewhere
21:15:58 <monochrom> oleg has pure-functional shuffle. I forgot the url
21:16:03 <zzo38> class Plus f where { zero :: f x; plus :: f x -> f x -> f x; }
21:16:05 <cmccann> pure functions can't generate random numbers on their own, for hopefully obvious reasons
21:16:11 <monadicity> how might adjuncation based programming differ from monadic?
21:16:13 <zzo38> Where zero and plus form a monoid.
21:16:18 <cmccann> obviously obvious obvious whee
21:16:43 <monochrom> I know, but suppose someone gives you a list of random numbers
21:16:54 <ion> > let xs = "hello world"; r = state . randomR in evalState (map snd . sort <$> mapM (\a -> (,a) <$> r (0.0,1.0)) xs) (mkStdGen 42)
21:16:56 <lambdabot>   Illegal tuple section: use -XTupleSections
21:17:11 <ion> > let xs = "hello world"; r = state . randomR in evalState (map snd . sort <$> mapM (\a -> flip (,) a <$> r (0.0,1.0)) xs) (mkStdGen 42)
21:17:13 <lambdabot>   "dlrhoellow "
21:17:17 <zzo38> If the shuffle function is passed a random number generator, then it can work, is one way.
21:17:18 <beaky> wow
21:17:23 <amindfv> monochrom: http://okmij.org/ftp/Haskell/perfect-shuffle.txt
21:17:38 <shachaf> Is "instance Foo (Bar Vaz)" H98?
21:17:40 <monochrom> nice
21:17:45 <cmccann> I'm not sure beaky is ready for oleg's stuff :P
21:19:10 <zzo38> The random number generator could just be of type [Bool], in which case (Free ((->) Bool) x) to decode one value of type x from a bit-stream, which can also be used to make random values of the type, if done with the correct probabilities.
21:20:13 <zzo38> Actually, it has to be a infinite list, if you are generating random numbers, I think.
21:20:58 <beaky> oleg?
21:23:27 <zzo38> You can also just use any infinite list of the requested type, as the random number generator.
21:24:01 <EarthServer> \quit
21:24:12 <zzo38> The actual random number generator function may take a seed and return the infinite list, for example.
21:24:38 <dmwit> ?hoogle Alternative f => a -> f a -> f a
21:24:39 <lambdabot> Control.Applicative (<|>) :: Alternative f => f a -> f a -> f a
21:24:39 <lambdabot> Data.Graph.Inductive.Internal.Queue queuePut :: a -> Queue a -> Queue a
21:24:39 <lambdabot> Text.ParserCombinators.ReadP option :: a -> ReadP a -> ReadP a
21:24:43 <zzo38> Is the code I posted when accessing this channel, do you know if there is a better way?
21:25:16 <dmwit> :t \v p -> fromMaybe v <$> optional p
21:25:17 <lambdabot> Alternative f => b -> f b -> f b
21:25:27 <dmwit> Is there a better combinator than optional for me?
21:27:20 <beaky> How do I choose between data, newtype, and type?
21:28:06 <zzo38> beaky: type makes a type synonym, data and newtype makes up a new type. newtype has the same internal purpose as the type it is wrapping.
21:28:52 <beaky> ah
21:29:13 <dmwit> Prefer newtype over data unless you need more than one constructor or more than one field.
21:29:24 <beaky> so newtype is the proverbial 'extra layer of indirection' without the problem of too many layers of indirection :D
21:29:51 <dmwit> newtype makes a new type identical to the old (except in the typechecker's internals).
21:29:55 <johnw> as I understand it, newtype affects the type checker, but not runtime, whereas data does both
21:30:10 <dmwit> ?quote newtype.*imaginat
21:30:10 <lambdabot> No quotes match. I feel much better now.
21:30:11 <beaky> data is very powerful
21:30:15 <johnw> and type affects neither
21:30:27 <beaky> what is the difference between data and state?
21:30:39 <johnw> you don't mean the data keyword there, do you?
21:31:30 <cmccann> > "data" \\ "state"
21:31:31 <lambdabot>   "da"
21:31:36 <cmccann> apparently the different is "da"
21:31:42 <dmwit> State includes things you don't normally consider "data", like the stack pointer and PC, etc.
21:31:42 <johnw> as in fus ro
21:32:09 <x-SuriV> you can do that kind of low level access in Haskell?
21:32:14 <x-SuriV> accessing the SP and PC?
21:32:23 <johnw> sure, just use the C FFI :)
21:32:43 <zzo38> Even C doesn't do that, though. You need to use the assembly language.
21:32:44 <dmwit> You can change the PC by calling a function or returning from one.
21:32:56 <dmwit> You can change the SP by creating a thunk or forcing one.
21:32:56 <x-SuriV> mwit: hahahaha
21:33:23 <x-SuriV> the C FFI is pretty cool.
21:34:37 <johnw> i like the way the C FFI bridges the concepts of memory managed and unmanaged languages, and between values and pointers to memory regions
21:35:57 <shachaf> Is there a Foo such that (Foo s b -> Foo a t) ~~ (a -> b) -> (s -> t)?
21:36:06 <shachaf> (Foo's definition can mention a/b/s/t.)
21:36:27 <johnw> what does (~~) mean?
21:36:32 <shachaf> Isomorphic to.
21:36:38 <johnw> ≅
21:36:47 <johnw> i thought you had an APL keyboard
21:36:55 <shachaf> I'm afraid (~~) is much more readable.
21:37:04 <johnw> clearly not :)
21:37:59 <shachaf> In my old age my eyes don't work so well, and ≅ looks an awful lot like ≃ and ≌ and ≋ and ≊ and ≈ and ≡ and ≣ and ...
21:38:24 <popl> = looks like ...?
21:38:26 <zzo38> I figure out some thing about monad transformers some more: With any monad transformer t: t Finalize = Finalize    I do not know if it is true for all categories, though.
21:38:47 <popl> You *must* be getting old, shachaf. ;)
21:39:04 <zzo38> Do you know if this holds with all categories?
21:39:20 <shachaf> I like how Unicode has ≅ and ≌
21:40:23 <popl> shachaf: for dyslexics
21:40:36 <shachaf> Right now I'm using Foo x y = (x, a -> y)
21:41:01 <shachaf> So Foo s b -> Foo a t becomes (s, a -> b) -> (a, a -> t)
21:41:07 <shachaf> Clearly that's not good enough.
21:43:02 <cmccann> shachaf, so if you partially apply it to something of type (Foo s b), you end up with (Foo a t) being isomorphic to... what?
21:43:51 <shachaf> I'm not sure. :-(
21:45:41 <Skillsob> "isomorphic", "morphism"... I feel like to understand what's REALLY going on in Haskell I'd need to study category theory and learn what all these terms mean.
21:45:53 <shachaf> Not really.
21:46:08 <cmccann> the term isomorphic is not coming from category thoery
21:46:13 <cmccann> ...or category theory
21:46:14 <shachaf> "isomorphic" is hardly a word -- yes.
21:46:36 <cmccann> learning to type correctly is more helpful than knowing category theory, in fact.
21:46:39 <johnw> isomorphic just means "equal for all intents and purposes"
21:46:39 <cmccann> I should work on that.
21:46:53 <shachaf> johnw: ?
21:46:58 <shachaf> Isomorphism isn't equality.
21:46:59 <cmccann> "up to isomorphism" is a formalized way of saying "whatever, close enough"
21:47:01 <johnw> functionally equivalent
21:47:03 <johnw> no, not equal
21:47:22 <johnw> but equal in the sense that two things are indistinguishable in the context they're being used in
21:47:42 <johnw> it's like "ostensibly equal"
21:47:48 <johnw> meretricious equality
21:48:03 <shachaf> I'm not sure what's ostensible here.
21:48:16 <johnw> the observed properties of the two things
21:48:29 <johnw> that with respect to which they are isomorphic
21:48:45 <shachaf> cmccann: The other day I was figuring out symmetric lenses, but after I figured out that Iso s t a b = (Functor f, Functor g) (g a -> f b) -> g s -> f t, elliott started working on the file.
21:48:53 <shachaf> cmccann: So I like to say that I figured out symmetric lenses up to isomorphism.
21:49:00 <cmccann> >:[
21:49:13 <cmccann> shachaf, you've seen my email address, right?
21:49:43 <shachaf> uptoisomorphism.net or something like that.
21:49:47 <cmccann> yeah
21:51:06 <cmccann> it's kind of a pain to type unfortunately :[
21:51:24 <Skillsob> Do you guys have a great link for lenses?
21:51:34 <shachaf> edwardk's video is up now.
21:51:38 <shachaf> That might be good.
21:51:47 <shachaf> (If you like that sort of thing.)
21:51:58 <shachaf> https://www.youtube.com/watch?v=cefnmjtAolY
21:54:06 <Skillsob> Thanks. I'll watch that later.
21:54:54 <orospakr> hey, what's the best way to debug an infinite regression bug?
21:55:06 <johnw> very patiently
21:55:23 <shachaf> What's the best way to debug infinite regrets? :-(
21:55:34 <johnw> i use "trace" following a bisection pattern within the supposed execution path
21:56:23 <orospakr> oof. well, I'd like to see what the function is, at least.
21:56:34 <johnw> try +RTS -xc, and C-c
21:56:41 <orospakr> alrighty
21:56:43 <johnw> maybe it will manifest the interrupt as an exception
21:56:53 <johnw> but probably not :(
21:57:23 <shachaf> -xc can be pretty good for that sort of thing.
21:58:37 <orospakr> hm. how do I have cabal build the program with --prof?
21:58:43 <orospakr> er, -prof
21:58:58 <johnw> cabal --enable-library-profiling --enable-executable-profiling
21:59:02 <johnw> er, configure
21:59:15 <lewisx> how do you debug haskell code that is crashing due to ffi?
21:59:31 <johnw> gdb is my first stop
22:00:25 <orospakr> huh. now it won't build, claiming that it cannot find the Prelude module.
22:00:51 <orospakr> aha. what's the bet I need the ghc-prof debian package?
22:03:54 <orospakr> now getting link failures: https://gist.github.com/4357718
22:21:12 <johnw> you're going to need to rebuild all of your cabal
22:21:20 <johnw> since you don't have the profiling variants
22:26:23 <beaky> cabal install cabal-install
22:29:22 <johnw> it's more than that
22:29:29 <johnw> cabal install --reinstall world
22:29:37 <johnw> after you enable profiling in ~/.cabal/config
22:33:29 <lewisx> how to check if a ffi pointer is NULL?
22:33:54 <ion> @hoogle nullPtr
22:33:54 <lambdabot> Foreign.Ptr nullPtr :: Ptr a
22:34:38 <lewisx> thanks
22:36:45 <tim_heap> OK, I give up. Can some one help me with this?
22:37:21 <tim_heap> http://hackage.haskell.org/packages/archive/libmpd/latest/doc/html/Network-MPD.html#v:playlistInfo
22:37:49 <tim_heap> I just can not work out how to get a list of songs that I can use by calling this
22:39:33 <shachaf> Pass it an optional range?
22:39:44 <shachaf> Or is the issue with MonadMPD?
22:39:53 <tim_heap> MonadMPD
22:40:31 <shachaf> http://hackage.haskell.org/packages/archive/libmpd/latest/doc/html/Network-MPD.html#v:withMPD ?
22:40:34 <tim_heap> From what i understand I should be able to just:
22:40:42 <tim_heap> withMPD $ do
22:40:56 <lewisx> is there a reason mapM_ was named like that instead of mapM' ?  is it just old convention ?
22:40:57 <tim_heap>   playlist <- MPD.playlistInfo Nothing
22:41:28 <shachaf> lewisx: ' isn't the same as _
22:41:46 <shachaf> ' is often used in the standard library a strict version
22:41:55 <shachaf> (Or sometimes "a different version"._
22:42:11 <popl> #haskell needs a 'shachaf
22:42:31 <shachaf> mapM_ isn't really strict -- it ignores the results, and gives you m () instead of m [...]
22:44:44 <lewisx> I see. I thought ' is for different version of a function, whatever the difference may be.
22:45:04 <shachaf> _ is pretty standard for functions like mapM_
22:45:51 <johnw> yeah, since '_' often means "I don't care what goes here"
22:46:34 <plhk> aha, that's the mnemonic for it
22:46:49 <popl> ._.
22:47:13 <latro`a> it's a little bit more blatant when you actually write them
22:47:39 <latro`a> like...consider defining mapM_ in terms of mapM
22:47:59 <johnw> mapM_ = void . mapM
22:48:04 <plhk> like mapM >> return () ?
22:49:01 <latro`a> sorry, I was thinking of sequence_ which is used to define mapM_
22:49:08 <latro`a> @src sequence_
22:49:08 <lambdabot> sequence_ ms = foldr (>>) (return ()) ms
22:49:24 <latro`a> then the (>>) has a \_ -> ... in it
22:49:36 <latro`a> eh, perhaps not as distinctive as I was going for -_-
22:50:03 <latro`a> foldr (>>) (return ()) ms = foldr (\m n -> m >>= \_ -> n) (return ()) ms
22:50:19 <latro`a> there's the _ on the inside
22:53:44 <johnw> if I don't want to use makeClassy, what's the best way to refer to lens a record field?
22:57:46 <edwardk> makeLenses ?
23:00:09 <narens> can anyone tell me what is package equivalent in features to the requests module for python in Haskell? I tried the http package but it won't work for https
23:04:10 <monadicity> are representable functors used in haskal?
23:05:07 <lewisx> is it safe to free a pointer after fetching the value it points to with <- peek ?
23:06:10 <johnw`> it all depends on the library
23:06:22 <johnw> did it tell you the ownership is yours?
23:06:36 <mikeplus64> lewisx: it should be, yeah, but try it
23:06:45 <lewisx> i allocated it myself
23:06:56 <johnw> there are better ways to manage allocated memory
23:07:01 <ClaudiusMaximus> :t with
23:07:01 <johnw> but yeah, you can free it whenever you want
23:07:02 <lambdabot> Not in scope: `with'
23:07:47 <lewisx> with is exception safe?
23:08:11 <mikeplus64> there ought to be like an unsafePeek that doesn't do any copying (not that you always know if peek copies...)
23:08:38 <ClaudiusMaximus> i tend to use it often like  x <- with y $ \p -> foo p ; peek p
23:08:43 <lewisx> when wouldnt it copy?
23:09:18 <plhk> narens: Network.Curl maybe
23:09:25 <lewisx> with looks nice!
23:10:06 <mikeplus64> lewisx: if ghc can somehow see that you're only using stuff you peeked before you free the memory, it might not copy
23:10:12 <mikeplus64> i don't think it says either way
23:13:32 <lewisx> actually I dont get how to use with to replace malloc ::  IO (Ptr SomeType)
23:15:59 <johnw> let's say x :: SomeType
23:16:21 <johnw> with x -> \sptr -> do someCFunctionNeedingPtr (castStablePtrToPtr sptr)
23:16:38 <johnw> sorry, with x $ \sptr ->
23:22:00 <shachaf> So can you pick Foo such that (Foo a t -> Foo s b) ~~ (a -> b) -> s -> t ?
23:22:20 <johnw> Foo = Cat?
23:22:25 <shachaf> Cat?
23:22:31 <johnw> err, n/m
23:22:52 <johnw> got lost in my head for a second there
23:25:26 <popl> johnw: pre-senile dementia?
23:25:35 <johnw> maybe
23:26:24 <popl> johnw: I read a journal article about Alzheimer's regarding rapid onset in the educated versus the uneducated.
23:29:09 <popl> johnw: BBC article, can't find th ejournal article: http://news.bbc.co.uk/2/hi/health/4713570.stm
23:30:23 * popl melts back into obscurity
23:31:39 <johnw> shachaf: if I do this: type s = f a; type t = f b
23:31:43 <johnw> then your question is: (Foo a (f b) -> Foo (f a) b) ~~ (a -> b) -> f a -> f b
23:31:50 <johnw> which for some reason makes more sense
23:32:27 <monadicity> on my question shee the answer to question d was duality.. to e it's epimorphism and to f it's forgetful functor.. am I goingmad?
23:32:38 * hackagebot free-game 0.2.0.0 - Create graphical applications for free.  http://hackage.haskell.org/package/free-game-0.2.0.0 (FumiakiKinoshita)
23:32:53 <Jafet> 0.3%
23:33:01 <Jafet> Sounds significant
23:33:11 <shachaf> johnw: Sure, if you like.
23:33:27 <shachaf> Can you do it?
23:33:38 <johnw> now, if I write Foo and ->, I get:
23:33:50 <johnw> (a -> f b) -> f a -> b
23:34:03 <johnw> which is actually the type signature for ψ in the definition of Adjunction
23:34:21 <johnw> if the functor is adjoint to itself
23:34:24 <neutrino> hi johnw
23:34:25 <johnw> which is the case for Cont
23:34:50 <johnw> hi neutrino
23:38:49 <johnw> shachaf: so am I right in thinking that you're looking for a Functor, one of whose self-adjoint natural transformations is isomorphic to its mapping of morphisms?
23:39:02 <shachaf> I have no idea.
23:39:40 <johnw> because it _looks_ like you want ψ ≅ fmap for some functor F
23:40:18 <johnw> i bet Cale would know
23:40:20 <johnw> or Saizan
23:42:31 <johnw> you want to swap return types
23:44:26 <johnw> if Foo a b -> Foo s t ~~ (a -> b) -> s -> t, then Foo is (->) or (,); but you want a morphism between functions that swaps codomains
23:44:54 <johnw> a morphism between morphisms; is this what you're talking so much about profunctors?
23:44:59 <johnw> s/what/why
23:45:07 <lewisx> =<< cant be used for partial application. what can?
23:45:16 <johnw> why can't it?
23:45:23 <lewisx> it can?
23:45:28 <johnw> (=<< x)
23:45:41 <johnw> (f =<<)
23:45:44 <lewisx> was getting errors, must have been something else
23:45:52 <aman_> hi all. this is my first time with haskell
23:46:16 <aman_> can anyone please tell me whether this is really better than imperative languages?
23:46:58 <shachaf> You should read the FAQ!
23:46:59 <shachaf> @where faq
23:47:00 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
23:47:10 <shachaf> I think it answers general questions like that pretty well.
23:47:51 <aman_> Yeah, thanks. I'll go through it.
23:49:08 <Skillsob> Learning functional programming is like learning to program all over again. It's a completely different way of solving problems, and it has different rules and implications.
23:49:21 <Saizan> johnw: Foo is allowed to mention the other vars here, btw
23:49:29 <johnw> i was just wondering that
23:49:34 <Skillsob> I find it fascinating, and for unexplainable reasons more fun.
23:50:58 <Saizan> johnw: also, you've reordered them, but what shachaf wants is (Foo a t -> Foo s b) ~~ (a -> b) -> s -> t
23:51:15 <johnw> yeah, that's what I have in my buffer
23:51:24 <johnw> so, is this question already answered and he's just puzzle trolling?
23:51:35 <Saizan> nope
23:51:38 <x-SuriV> puzzle trolling..that's a new one
23:51:42 <x-SuriV> what's that
23:51:56 <shachaf> I think it's not possible.
23:51:56 <johnw> where you use puzzles to fire up a huge discussion that you watch and laugh at
23:52:39 <x-SuriV> johnw: Oh, so like if I went into a coder room and challenged them to solve the halting problem, then watched as a debate stirred or something>
23:52:40 <x-SuriV> ?
23:52:49 <johnw> yeah, except be subtle about it
23:53:36 <johnw> data Foo a b = forall s t. Foo s t a b { runFoo :: (a -> b) -> s -> t }
23:53:52 <shachaf> What?
23:53:56 <johnw> :)
23:54:04 <johnw> i have on idea, shachaf
23:54:06 <johnw> no
23:54:21 <johnw> can you show me how far you've gotten?
23:54:36 <shachaf> I've gotten as far as "I don't know"
23:54:44 <shachaf> What should I say?
23:54:58 <shachaf> p is like a bifunctor contravariant in both arguments.
23:55:11 <johnw> what is p?
23:55:15 <shachaf> Foo
23:55:55 <shachaf> (I mean, Foo is naturally going to be contravariant, to get the sort of types I gave.)
23:55:57 <monadicity> I thought a bifunctor has to be covariant in one and contravariant in its other argument
23:56:05 <shachaf> monadicity:: You're thinking of a profunctor.
23:56:16 <monadicity> I've never heard of that term
23:56:23 <shachaf> I should probably give up thinking about bifunctors and go back to profunctors.
23:56:37 <shachaf> Someone in this channel was just talking about how profunctors are the future.
23:57:35 <Saizan> profunctors are so pro
23:57:47 <hpaste> johnw pasted “not-a-bimap.hs” at http://hpaste.org/79667
23:58:27 <shachaf> johnw: ?
23:58:35 <johnw> so, if bimap flips the matrix along the diagonal, what you flips only the bottom row
23:58:47 <johnw> i'm looking at the association of types
23:59:13 <shachaf> What I have is contravariant in both arguments.
23:59:19 <johnw> you want: ?map :: (a -> t) -> (s -> b) -> f a b -> f s t
23:59:47 <shachaf> I don't think I want that.
