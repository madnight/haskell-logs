00:00:01 <shachaf> Have you checked your version?
00:01:18 <cizra> Yes and no. Also, I guess I should go with HTML5, I might want to use the canvas thingy.
00:01:48 <mm_freak> cizra: also you probably don't want to use blaze-html directly =)
00:02:13 <cizra> mm_freak: Er, that's what the Happstack tutorial recommends...
00:02:22 <cizra> mm_freak: What options do I have?
00:02:36 <mm_freak> for happstack you would normally use something like HSP
00:02:45 <mm_freak> i think there is also heist for happstack
00:02:52 <mm_freak> (which i prefer)
00:02:52 <shachaf> mm_freak: What if you want Blaze?
00:02:53 <stepkut> there is everything for happstack \o/
00:03:25 <mm_freak> shachaf: you use blaze in most cases
00:03:43 <mm_freak> sometimes you just don't know =)
00:03:58 <b____> are there any Haskell books including a treatment of GADTs? (I like books)
00:03:58 <edwardk> johnw: also. i'm not sure if its just me but to get cabal-dev to install on a fresh platform i have to cabal install --force-reinstalls, which is kind of funny given that its a dependency of stackage ;)
00:04:02 <stepkut> mm_freak: i recommend blaze, if you like straight-up haskell for templating, and HSP if you like voodoo magic with html-like syntax
00:05:02 <mm_freak> stepkut: i like to have my templates outside of my code, yet without magic, which is why i like heist
00:05:23 <stepkut> mm_freak: but half your template is still in code..
00:05:37 <stepkut> mm_freak: none of the xml is in the code, but all of the logic is
00:06:14 <mm_freak> stepkut: certainly the logic is in code and i need to assign placeholder values in code, but that's not the point
00:06:14 <stepkut> mm_freak: so you end up with weird things where you have to create odd tags so that you can bounce back and forth between xml-land and haskell-land to get simple things done
00:06:21 <stepkut> like mapping a template over a list
00:06:39 <b____> I like my templates to be HTML with variable substitution/placeholders and perhaps foreach loops at _most_
00:06:52 <b____> there is this awesome DSL for writing websites
00:06:58 <b____> and it's called HTML
00:07:02 <stepkut> b____: so use HSP and don't use anything except forM :)
00:07:06 <b____> =[]
00:07:09 <mm_freak> stepkut: what's your point?  that i should do /all/ my templating in code?
00:07:10 <stepkut> and <% %>
00:07:14 <b____> yeah stepkut =]
00:08:07 * edwardk looks up, see's <% %> and realizes there are operators he hasn't taken yet.
00:08:15 <johnw> lol
00:08:27 <stepkut> mm_freak: that's the path I am trying to make work best
00:08:31 <johnw> [= =]
00:08:43 <b____> if I get an ambiguous occurrence of a self-defined operator, I know I simply have to hide it from lens
00:08:53 <edwardk> b____: hah
00:09:06 <mm_freak> stepkut: the trouble starts when templating needs to be done by nonprogrammers
00:09:40 <mm_freak> and it gets worse when you have to justify that someone who changes something in the template has to recompile
00:09:44 <edwardk> it always shocks me that non-programmers still exist
00:09:52 <startling> hahaha
00:10:06 <startling> @quote edwardk it always shocks me that non-programmers still exist
00:10:06 <lambdabot> No quotes match. Just what do you think you're doing Dave?
00:10:13 <startling> er.
00:10:21 <cizra> Meh. Non-programmers should be forbidden from using computers.
00:10:21 <simpson> You want @remember IIRC.
00:10:29 <ski> @remember <mm_freak> the trouble starts when templating needs to be done by nonprogrammers  <edwardk> it always shocks me that non-programmers still exist
00:10:29 <lambdabot> Done.
00:10:32 <stepkut> mm_freak: yeah, that is part of what I am working on :)
00:10:54 <b____> edwardk, then I am guessing that you don't have a "partner", or one who is exceptionally able
00:10:55 <mm_freak> stepkut: ah, i see =)
00:11:51 <edwardk> i'm only half joking. I give a programmer a department or a task and I get it automated so he can get back to programming. I give a non-programmer a task and I get spreadsheets and filing systems.
00:12:11 <stepkut> mm_freak: HSP already has a mode where you can make the templates look like normal XML files. You can start at the very top with <html></html>, and HSP will recognize that
00:12:26 <stepkut> mm_freak: and for substitutions you can just do <% someVariable %>
00:12:40 <edwardk> Sadly, I learned this management technique by having it done to me first.
00:12:46 <stepkut> mm_freak: so, it looks pretty much like any other simple template language
00:12:46 <mm_freak> it's a preprocessor, right?
00:12:59 <stepkut> mm_freak: a preprocessor, and in darcs there is a QQ as well
00:13:12 <stepkut> mm_freak: combine with hs-plugins, you can automatically reload the templates
00:13:13 <shachaf> ski: You've forgotten the nick.
00:13:15 <mm_freak> <% %> is an unfortunate choice, though
00:13:19 <startling> I always lex "QQ" into an emoticon.
00:13:21 <ski> @quote <mm_freak>
00:13:21 <lambdabot> <mm_freak> says: the trouble starts when templating needs to be done by nonprogrammers  <edwardk> it always shocks me that non-programmers still exist
00:13:27 <ski> @quote <mm_freak>
00:13:27 <lambdabot> <mm_freak> says: the trouble starts when templating needs to be done by nonprogrammers  <edwardk> it always shocks me that non-programmers still exist
00:13:35 <stepkut> mm_freak: the <% %> comes from HSP.. what would you prefer?
00:13:37 <ski> hm, there's one more quote, at least
00:13:57 <mm_freak> ski: try "mm_freak" instead of "<mm_freak>"
00:13:58 <edwardk> accidentally included the angle brackets?
00:14:05 <shachaf> @quote <mm_freak> inimino
00:14:05 <lambdabot> <mm_freak> says: no prolog channel =/  <inimino> there's a setting that turns that off
00:14:10 <b____> @quote GADT
00:14:10 <lambdabot> ihope says: Oops, I forgot that Djinn doesn't do GADT's.
00:14:12 <shachaf> I think those are both wrong.
00:14:35 <b____> there was this command to get relevant links on a subject wasn't there?
00:14:46 <mm_freak> stepkut: i'd prefer something that doesn't piss off my editor's XML mode
00:14:47 <edwardk> b____: my wife can program when forced to, yes ;)
00:14:57 <b____> aha, see?
00:15:10 <b____> not everyone is so fortunate!
00:15:11 <mm_freak> stepkut: either plain old element syntax or something like <?blah ?>
00:15:22 <ski> shachaf : should that one be added under inimino, then ?
00:15:37 <edwardk> b____: computational linguist turned personal trainer. she doesn't do much programming these days, but at least understands the gist of my current obsession at any given moment
00:15:38 <Ralith> edwardk: ah, but does she use lenses?
00:15:58 <shachaf> ski: I suppose.
00:16:01 <ski> @where SHE
00:16:01 <lambdabot> http://personal.cis.strath.ac.uk/~conor/pub/she/
00:16:03 <shachaf> It's a bit trickier.
00:16:12 <shachaf> But at any rate it should be attributed to some nick.
00:16:19 <b____> @where GADT
00:16:19 <lambdabot> http://www.haskell.org/ghc/docs/latest/html/users_guide/data-type-extensions.html#gadt
00:16:28 <stepkut> mm_freak: why is <?  ?> better than <% %> ?
00:16:28 <edwardk> Ralith: she grok's their motivation, but isn't quite sure what all the hullabaloo is about ;)
00:16:30 <ski> @quote inimino setting
00:16:30 <lambdabot> inimino says: <mm_freak> says: no prolog channel =/  <inimino> there's a setting that turns that off
00:16:45 <mm_freak> stepkut: because that's valid XML
00:17:10 <shachaf> @quote <mm_freak>
00:17:10 <lambdabot> <mm_freak> says: no prolog channel =/  <inimino> there's a setting that turns that off
00:17:12 <stepkut> mm_freak: meh. I use HTML :p
00:17:29 <mm_freak> stepkut: i use an XML editor mode for HTML
00:17:37 <mm_freak> and i always wonder:  don't the template language inventors ever actually write templates in their language?!
00:17:52 * ski didn't remove it
00:17:57 <cizra> Hmmm, so Happstack's internal URLs & routing are not statically typed?
00:18:09 <ski> (i didn't add it)
00:18:16 <stepkut> mm_freak: i will suggest the change to Niklas. We could probably add that mode and keep the old <% %> for backward compatibility
00:18:50 <mm_freak> because heist seems to be the only template language that actually takes existing editors into account
00:18:51 <b____> edwardk, that must be nice, my girlfriend thinks what I do is total abracadabra
00:19:04 <mm_freak> stepkut: well, i'll just go with heist for now =)
00:19:05 <cizra> Do we have any web frameworks, or in general anything with type-safe URLs & routing?
00:19:07 <stepkut> cizra: right. I added static types via web-routes later and keep it general so it could be used with any web framework
00:19:31 <stepkut> cizra: happstack-foundation is setup to use type-safe urls and routing by default
00:19:39 <stepkut> cizra: it's just not built into happstack-server
00:19:51 <cizra> Sounds tasty! What's the difference between happstack-foundation and .. well, whatever this tutorial is using?
00:20:03 <cizra> happstack-server, namely
00:20:03 <stepkut> cizra: which tutorial are you looking at ? happstack-lite ?
00:20:13 <cizra> http://www.happstack.com/c/view-page-slug/9/happstack-lite and http://www.happstack.com/docs/crashcourse/HelloWorld.html#hello_world in parallel
00:20:23 <edwardk> My wife is also incredibly patient with me being up all night, and perfect and sweet and loving and did I mention she also reads IRC logs occasionally? Hi, honey.
00:20:37 <b____> hahaha
00:20:39 <mm_freak> anyway, i like the approach hamlet takes most…  if you're going to invent a new language, do it properly…  adopt the strengths, leave the weaknesses
00:20:59 * sopvop was thinking about dynamic routing stuff but with projection lens for safe link generation
00:21:21 <b____> well I guess that helps when you have a project like lens (among others) to develop
00:21:47 <edwardk> the funny thing is lens just started as a sub-project of a sub-project of a sub-project
00:21:49 <stepkut> happstack-lite is intended to be very simple to use, relying on very little magic, type classes, or other features that are scary to newbies / snap users. It is (nearly) a proper subset of happstack-server. happstack-foundation combines happstack-server with other libraries, like web-routes, to create a powerful, type-safe web framework.
00:21:55 <edwardk> i'll eventually be able to pop the stack, really ;)
00:22:43 <stepkut> cizra: while we strive to minimize unneeded template haskell, type hackery, etc, in happstack-foundation, it does ultimately require a tasteful use of the more advanced Haskell features
00:22:48 <mm_freak> i'm the only survivor of the lensocalypse
00:22:49 <shachaf> Little does edwardk know that he doesn't even have a stack.
00:22:55 <shachaf> All those sub-projects are tail calls.
00:23:07 <edwardk> stepkut: i think at this point your major issue is branding. if only had a shorter name like 'snap' or 'yesod' -- like 'happs' then it'd sound cool ;)
00:23:22 <cizra> stepkut: Interesting stuff. Does it also require understanding of said features? :-)
00:23:24 <edwardk> shachaf: i've been accused of that =)
00:23:34 <sopvop> yehappsnap
00:23:58 <stepkut> edwardk: i didn't pick the names Happstack or HAppS.. I have considered renaming the project so people who have not looked at the code in a long time would think it was something new (since it is largely new)
00:24:01 <edwardk> stepkut: can i also recommend randomly capitalizing it?
00:24:05 <mm_freak> edwardk: check out pred happstack = hAppS ;)
00:24:31 <edwardk> mm_freak: my point exactly =)
00:24:35 <stepkut> snap is definitely the best named haskell web framework
00:25:12 <edwardk> yeah 'snap' sounds like something fun to use
00:25:48 <stepkut> edwardk: yup, fun and easy
00:26:12 <edwardk> clearly you should just pull a me and grab 'webs' or 'web' or something =P
00:26:33 <shachaf> Maybe w
00:26:44 <cizra> Make it googlable
00:26:48 <startling> "framework"
00:26:49 <edwardk> ooh, i don't have any one character package names. so many opportunities
00:26:50 <stepkut> edwardk: the libraries I have named tend to have names like that, web-routes, web-plugins, etc
00:27:06 <stepkut> edwardk: I did experiment with clckwrks.. boy do people hate that !
00:27:10 <shachaf> edwardk: Not *that* many...
00:27:38 <sopvop> I could not google clckwrks, it kept "fixing" my mistakes
00:27:39 <stepkut> though.. to be fair, it was supposed to be clockworks, but all the variations were taken
00:27:49 <shachaf> Hmm, Henning should call all his modules M
00:27:50 <edwardk> i do need to push out my 'ai' package at some point though, that would up my 2-letter package count to 3.
00:27:55 <edwardk> shachaf: hahahahaha
00:28:00 <shachaf> import qualified "foo" M as Foo
00:28:13 <edwardk> @remember shachaf Henning should call all his modules M
00:28:13 <lambdabot> Done.
00:29:08 <mm_freak> call your next web framework:  simple turbo ultra professional internet development content rapid infrastructure project
00:29:44 <sopvop> just web-3.0
00:29:45 <mm_freak> s/infrastructure/auditing/
00:30:05 <mm_freak> > map head . words $ "simple turbo ultra professional internet development content rapid auditing project"
00:30:07 <lambdabot>   "stupidcrap"
00:30:25 <mm_freak> but i know what i'll call my next web framework
00:30:33 <mm_freak> too-toot ascii cat!
00:30:48 <startling> just call it web, but increase major versions constantly.
00:31:01 <startling> "we should use this thing, it's got web 12.0!"
00:31:19 <sopvop> but is it web-scale?
00:31:26 <sopvop> @faq is haskell web-scale?
00:31:26 <lambdabot> The answer is: Yes! Haskell can do that.
00:31:55 <mm_freak> haskell is web-scale…  you can connect to a haskell server from everywhere around the world!
00:36:52 * hackagebot hamlet 1.1.2 - Haml-like template files that are compile-time checked  http://hackage.haskell.org/package/hamlet-1.1.2 (MichaelSnoyman)
00:39:08 <cizra> Can I somehow get type information in Emacs haskell-mode?
00:41:10 <stepkut> my next web framework will be call 'dragon web scale'
00:41:21 <stepkut> or 'it came from planet agda'
00:42:43 <johnw> cizra: use ghc-mod
00:42:48 <cizra> Speaking of Agda.. You can import Haskell modules in Agda, right? Which means you really CAN write anything on Earth in a mixture of Agda + Haskell.
00:42:58 <johnw> cizra: then you can type C-c C-t to find the type of the expression under point
00:43:44 <cizra> johnw: Hmm, let's see..
00:44:46 <latermuse> will there ever be anything like "ruby on rails" for haskell?
00:44:55 <cizra> In which sense/
00:45:33 <johnw> i think he means "design by convention"
00:46:28 <cyphase> latermuse, http://www.haskell.org/haskellwiki/Web/Frameworks
00:49:15 <Guest57863> oy
00:50:18 <Iceland_jack> I'm sure latermuse meant a project or framework that will “popularize” Haskell
00:51:15 <Guest57863> Iceland_jack@ you are not robot ?
00:53:03 <Abso> hey, how do I hide the output of a function in the interpreter, for example if I only want to time it ?
00:53:27 <latermuse> Yeah I meant a project that will bring haskell to the forefront of web development
00:53:28 <shachaf> foo `seq` () ?
00:54:36 <statusfailed> hmm... how can I get a Word8 as a hex representation in Text without going through String?
00:54:40 <latermuse> With the html5 standardization about to be completed, and haskell compiling to JS, the timing is right for a project to come along and do what rails did for ruby.
00:55:54 <shachaf> statusfailed: Just one Word8?
00:55:59 <shachaf> You might as well go through the String.
00:56:40 <statusfailed> shachaf: nope, shitloads. It's taking up like 60% CPU time :p
00:56:52 * hackagebot hyphenation 0.2.1.6 - Configurable Knuth-Liang hyphenation  http://hackage.haskell.org/package/hyphenation-0.2.1.6 (EdwardKmett)
00:57:19 <edwardk> now with a critical doctest fix for icelandic hyphenation
00:57:19 <statusfailed> printing MAC addresses
00:57:40 <edwardk>  >>> hyphenate icelandic "vaðlaheiðavegavinnuverkfærageymsluskúr"   -- wasn't getting dealt with correctly ;)
00:58:01 <opqdonut> :D
00:58:17 <edwardk> (the code worked, the doctest failed)
00:58:27 <Abso> shachaf: how do I use that properly? It still prints the output out
00:58:32 <shachaf> statusfailed: And you're only doing single Word8s?
00:58:35 <shachaf> Abso: What output?
00:58:48 <Abso> the stuff my function returns
00:58:51 <shachaf> (You haven't actually said what you're doing, unless I missed it. :-) )
00:58:52 <statusfailed> shachaf: I have this: data MAC = MAC [Word8]
00:59:03 <Abso> oh i thought you were answering my question :P
00:59:04 <statusfailed> and I want to print it like this: AA:BB:CC:00:11:22
00:59:19 <shachaf> Abso: I was. But you haven't said what you're actually doing.
00:59:28 <shachaf> statusfailed: And this is taking 60% of your CPU time?
00:59:41 * shachaf wonders what statusfailed is doing.
00:59:56 <statusfailed> shachaf: reading pcap files, the string crap seems to be slowing it down a lot
01:00:00 <shachaf> Does using Text.Builder help?
01:00:23 <statusfailed> if there's a function :: Word8 -> Char
01:00:36 <shachaf> What would that do?
01:00:56 <Abso> I have a function which takes two arguments, a vocabulary and a text and it changes every word in the text to one in the vocabulary (if there is a permutation in it)
01:01:04 <statusfailed> shachaf: oh good point, I detrped
01:01:08 <statusfailed> derped*
01:01:13 <Abso> so now I want to try this for a vocabulary of 10.000 words and a text of 100.000
01:01:15 <shachaf> Abso: What are you typing into ghci, and what is it printing back to you?
01:01:28 <statusfailed> oh damn, it has a "hexadecimal'" function that I missed
01:01:43 <shachaf> Abso: (By the way, ghci is absolutely terrible for measuring performance. If you want to do that you should compile your code.)
01:01:49 <Abso> I'm doing :set +s to time it
01:01:53 * hackagebot tls 1.0.3 - TLS/SSL protocol native implementation (Server and Client)  http://hackage.haskell.org/package/tls-1.0.3 (VincentHanquez)
01:02:35 <Abso> and then I was just calling my function, but this obviously returns my list, taking about 7 seconds to print it out i guess
01:03:01 <statusfailed> shachaf: cheers, that works!
01:03:38 <shachaf> statusfailed: What's hexadecimal?
01:03:48 <shachaf> I see hexadecimal :: forall a. Integral a => Reader a, which is probably not what you mean.
01:03:57 <shachaf> Oh, wait, hexadecimal'
01:04:06 <shachaf> Abso: This would be much easier if you answered my question. :-)
01:04:16 <startling> shachaf, it's when you use 16 characters to encode a number rather than 10
01:04:39 <shachaf> thanks startling. thartling
01:04:44 <startling> shachaf: sort of like the different between utf-32 and that crazy 63-bit thing you wrote an implementation for.
01:05:35 <statusfailed> shachaf: Integral a => a -> Builder
01:06:03 <Abso> shachaf: myfunction <vocabulary with 10.000 words> <text with 100.000 words> and then it prints out a the text as corrected words
01:06:31 <Abso> I just want to hide that output
01:06:52 <shachaf> Abso: "myfunction <vocabulary with 10.000 words> <text with 100.000 words>" isn't valid Haskell syntax, but OK.
01:06:55 * hackagebot tls-extra 0.5.1 - TLS extra default values and helpers  http://hackage.haskell.org/package/tls-extra-0.5.1 (VincentHanquez)
01:06:57 * hackagebot tls-debug 0.2.1 - Set of programs for TLS testing and debugging  http://hackage.haskell.org/package/tls-debug-0.2.1 (VincentHanquez)
01:07:04 <shachaf> What went wrong when you did what I mentioned before?
01:07:45 <Abso> it said 0.00 sec
01:08:12 <Abso> oh
01:08:13 <shachaf> OK, so you need to evaluate the output of your function.
01:08:14 <Abso> uhm
01:08:38 <Abso> i did (myfunction) `seq` (vocab) `seq` (text)
01:08:48 <Abso> and it still printed it out
01:09:00 <shachaf> Oh.
01:09:24 <shachaf> Try (myfunction vocab text) `seq` (), which is more like what I wrote. :-)
01:09:35 <Abso> yeah i tried that first
01:09:39 <Abso> but that gives out 0.00 sec
01:09:41 <shachaf> And?
01:09:43 <Nereid> seq doesn't fully evaluate its first argument though
01:09:57 <shachaf> Yes.
01:10:07 <shachaf> Previously you were "show"ing it to force evaluation.
01:10:35 <shachaf> You could do something like: length (show (myfunction vocab text))
01:13:05 <Abso> omg that takes ages :D
01:13:56 <Abso> it takes longer than when I let it print out
01:16:55 <Abso> or maybe its my function :o
01:18:06 <cizra> Noob question. Is Text a monad where returning things inside a do-block means appending to the already existing text?
01:18:17 <shachaf> Text isn't a monad.
01:19:06 <cizra> Owait. Stupid me. It's Html, not Text.
01:19:42 <Abso> is sorting a slow operation?
01:19:49 <latermuse> Abso: can be
01:19:49 <startling> cizra, you're thinking of "Writer", but no, "return" never does anything magical
01:20:28 <Abso> is it faster to just create all permutations of a word and then check if my word is in it?
01:20:46 <shachaf> No.
01:20:47 <Abso> sounds pretty expensive to me
01:20:48 <cizra> Probably not, as there are n! permutations
01:21:18 <shachaf> That doesn't mean that sorting and comparing is the "fastest" way to check if two words have the same letters.
01:21:51 <latermuse> Abso: You can try filtering the list
01:21:54 <cizra> You could just write your own loopy thing which takes around O(max(m, n)).
01:22:08 <Abso> what I am doing right now is sort every word in my vocab, zip it with the voc itself then sort my word, and do lookup on that zipped list
01:23:54 <shachaf> Well, I bet your lookup is taking most of the time.
01:24:43 <Abso> yeah probably
01:41:44 <cizra> Hmmm. Hoogle doesn't index happstack. What's the recommended method to figure out where a given function comes from?
01:42:14 <shachaf> Hayoo
01:42:39 <Taneb> http://holumbus.fh-wedel.de/hayoo/hayoo.html
01:43:26 <cizra> Hayoo doesn't find my function... Although it says that happstack is one of its favourite modules.
01:44:14 <cizra> Ooh, filtering by packages!
01:45:45 <cizra> Hmm, no Firefox search bar option? )=
01:52:36 <fmap> cizra: you may add packages to search in hoogle with +, for example "ok +happstack-server" should work
01:53:50 <cizra> ooh, works!
01:59:06 <mapf> fukken dependencies
01:59:10 <mapf> i hate it
02:24:20 <neutrino> Cale: why does lambdabot not have -<? I thought it was a keyword in Haskell now
02:25:01 <merijn> -< is part of Arrow notation, no?
02:25:10 <merijn> You'd have to enable -XArrows, I think
02:37:53 <npl> hello, I am wondering about the 'delete' and 'difference' function at http://hackage.haskell.org/packages/archive/containers/0.2.0.1/doc/html/Data-Set.html#4 - why has 'difference' O(n+m) when 'delete' as O(log n)? Can difference not be done in o(m*log n), when you apply delete m times?
02:40:44 <fmap> isn't O(n+m) better than O(n*log m)?
02:41:23 <companion_cube> depends on m, but I don't think so, ln(m) is usually small
02:41:40 <Taneb> > 7 * ln 100
02:41:41 <lambdabot>   Not in scope: `ln'
02:41:41 <lambdabot>  Perhaps you meant one of these:
02:41:41 <lambdabot>    `n' (imported from D...
02:41:58 <Taneb> > 7 * log 100
02:41:59 <lambdabot>   32.23619130191664
02:42:07 <Taneb> > 7 + 100
02:42:08 <lambdabot>   107
02:44:29 <neutrino> companion_cube: it doesn't depend on m, it depends on n
02:46:55 * hackagebot hyphenation 0.2.1.7 - Configurable Knuth-Liang hyphenation  http://hackage.haskell.org/package/hyphenation-0.2.1.7 (EdwardKmett)
02:46:57 <npl> > 1000 * log 1000
02:46:58 <lambdabot>   6907.755278982137
02:47:08 <npl> > 1000 + 1000
02:47:09 <lambdabot>   2000
02:47:17 <romildo> Is a function similar to Text.Regex.subRegex (from regex-compat package, which is based on Posix regex) available for other regex engines in some library?
02:48:03 <npl> so I guess should write my own difference function in terms of delete, when n is small?
02:48:31 <mauke> npl: no, why?
02:49:28 <npl> mauke: i thought because for small n, m * log n is better than m + n
02:49:57 <mauke> that doesn't matter
02:50:12 <mauke> O notation is about the behavior when the numbers grow large
02:50:21 <mauke> it doesn't tell you which method is faster
02:51:37 <npl> hm ok
02:51:55 * hackagebot lens 3.6.0.2 - Lenses, Folds and Traversals  http://hackage.haskell.org/package/lens-3.6.0.2 (EdwardKmett)
02:53:11 <zhulikas> when is he sleeping
02:53:20 <zhulikas> releasing new version in the middle of a night
02:53:37 <zhulikas> well, early morning I guess
02:55:59 <edwardk_> 3.6.0.x are backports of minor doctest fixes to try to solve stackage issues
03:04:26 <quchen> Is there some standard way to redefine operators? For example, I needed (*) which only returns the last 10 digits of the result. Therefore, I defined 'a *. b = a * b `rem` (10^10)'.
03:05:07 <quchen> Is *. a suitable choice?
03:05:16 <edwardk_> quchen: that should probably be a different operator than * unless you make a newtype, *. is perfectly fine.
03:05:20 <quchen> Does it conflict with some other naming scheme? Is there a naming scheme for my purpose?
03:05:43 <edwardk_> there isn't really a standard name to give that sort of thing
03:05:57 <quchen> Alright, thanks
03:06:33 <quchen> (While you're here: in the GitHub Wiki page on examples for Lens, you're writing (%), but the code says &. The typo doesn't appear in the README though.)
03:07:19 <edwardk_> if you have the page open, feel free to edit it. (it is a wiki!) ;)
03:07:37 <quchen> Oh.
03:07:41 <edwardk_> & is the new operator. we switched from % a while back
03:07:50 <npl> is it possible to stop the execution of a function after a specific time and use the result produced so far? I want to use the function 'unfoldTree :: (b -> (a, [b])) -> b -> Tree a' from Data.Tree, but the calculated Tree sometimes gets too large adn the computation takes too long. therefore I would like unfoldTree to execute only a specific time
03:07:55 <quchen> "& = flip $"?
03:07:58 <edwardk_> yeah
03:08:01 <edwardk_> :t (&)
03:08:02 <lambdabot> a -> (a -> b) -> b
03:08:06 <quchen> :i (&)
03:08:14 <quchen> :info (&)
03:08:21 <mauke> quchen: ಠ_ಠ
03:08:21 <edwardk_> i don't think lambdabot offers that
03:08:30 <quchen> :-(
03:08:37 <quchen> Don't gimme that look
03:08:40 <edwardk_> infixl 1 &
03:08:54 <quchen> Well, I'll just ask edwardk_ then. It's defined in Lens, right?
03:09:07 <edwardk_> just tighter than ($) and its defined in lens, yes
03:09:20 <quchen> I've been redefining that operator so I can pipe stuff through just like with monads. It would make a great standard function.
03:09:30 <aheller> So in lambdabot, :ed won't spin off a vi?
03:09:32 <edwardk_> yitz tried to get it standardized, but lets just say the libraries mailing list was split on adding it ;)
03:09:48 <edwardk_> so we ultimately relented and backed off the proposal
03:10:09 <quchen> Any good reason to not include it?
03:10:46 <edwardk_> one contingent just doesn't like the 'style' that results. another objects to the name and wants (|>) but (|>) scored worse than (&) over all
03:11:02 <quchen> It's also way harder to type.
03:11:11 <quchen> Greetings from somewhere else than the US
03:11:29 <edwardk_> yeah
03:11:56 <edwardk_> aheller: =P
03:12:36 <edwardk_> aheller: i think this is the first time i ever saw you speak in here. be careful your lurker status is in jeopardy.
03:13:00 <aheller> edwardk_: I haven't lurked here in years!
03:13:14 <quchen> npl: I (as a beginner) would use concurrency for the timer.
03:13:18 <edwardk_> aheller: knowing that you are using the lib a lot: you may also be interested in #haskell-lens
03:13:38 <aheller> edwardk_: I thought this was #haskell-lens :)
03:13:44 <edwardk_> well, yes
03:14:01 <hpaste> Quchen pasted “Timer using concurrency” at http://hpaste.org/78757
03:14:05 <edwardk_> but #haskell-lens is a good place to move the rest of the haskell traffic. the name of the channel after all is 'haskell minus lens'
03:14:24 <quchen> Nifty
03:14:32 <aheller> edwardk_: has Control.Lens poached (-) now as well?
03:14:49 <npl> quchen: but how do I force 'unfoldTree' to 'stop' and produce a tree?
03:14:54 <edwardk_> aheller: i tried, but people complained.
03:15:16 <aheller> edwardk_: Well, it does add a dependency on Prelude...
03:15:57 <quchen> npl: My approach would be coding the unfold myself so it stores the intermediate accumulators in an MVar. (unfoldTreeM might do the trick)
03:16:00 <quchen> :t unfoldTreeM
03:16:01 <lambdabot> Monad m => (b -> m (a, [b])) -> b -> m (Tree a)
03:16:24 <quchen> m = IO/STM in this case
03:18:07 <npl> quchen: thanks, I will think about this
03:18:24 <quchen> I'm just a beginner, maybe ask again later and someone will give you a one-liner for this
03:26:01 <shachaf> Who's aheller?
03:32:18 <ocharles> We have compiler warnings for pattern matching on the input of a function to make sure it's exhaustive - is there anyway to do the reverse? Say I have a Foo -> Bar, and I want to ensure that there are ways to construct every type of Bar - can that be done?
03:35:22 <edwardk_> aheller = alec heller. you can hear him in a lot of the video's i record at boston haskell. he's the opinionated guy who isn't me. ;)
03:38:18 <shachaf> ocharles: You want to make sure your function is surjective?
03:38:25 * ocharles googles
03:38:36 <ocharles> yes :)
03:38:41 <shachaf> I doubt GHC has anything automatic for that.
03:39:03 <ocharles> no, but I wondered if there was some trickery where I could perhaps right Bar -> Foo and then flip it round
03:39:10 <ocharles> write*
03:39:38 <shachaf> mgsloan has that isomorphism DSL. :-)
03:40:00 <ocharles> what's that?
03:42:36 <shachaf> https://github.com/mgsloan/lenq
03:42:41 <ocharles> oh, lenq
03:42:49 <shachaf> It's not really what you're asking for, but it might do something along those lines.
03:43:07 <shachaf> It lets you define functions that work "both ways" in a syntactic way.
03:43:10 <ocharles> I wonder if I want something like boomerang
03:43:21 <chrisbuchholz> Hey can i turn [1,2,3] into 123? Is there some clean way of doing it?
03:43:26 <chrisbuchholz> how *
03:43:34 <ocharles> > concatMap show [1, 2, 3]
03:43:36 <lambdabot>   "123"
03:43:48 <ocharles> unless you meant the number 123?
03:44:08 <ocharles> > read (concatMap show [1, 2, 3]) :: Integer
03:44:10 <lambdabot>   123
03:44:11 <chrisbuchholz> ocharles: yeah, that was the unclean way. I would like to not have to go the route og list->string->int
03:44:13 <ocharles> :)
03:44:27 <chrisbuchholz> ocharles: hmm, thanks for that, will take it for a spin
03:44:32 <shachaf> > foldl' (\x y -> 10 * x + y) 0 [1,2,3]
03:44:33 <lambdabot>   123
03:44:47 <ocharles> but that wasn't my serious suggestion :)
03:44:48 <shachaf> Much nicer than read, surely.
03:45:07 <chrisbuchholz> ocharles: what was your serious suggestion then?
03:45:09 <shachaf> > scanl (\x y -> 10 * x + y) 0 [1,2,3,4,5]
03:45:11 <lambdabot>   [0,1,12,123,1234,12345]
03:45:20 <ocharles> probably shachaf's fold
03:45:48 <chrisbuchholz> ocharles, shachaf: thats a somewhat nice way of doing it, yes.
04:13:52 <tertl3> morning
04:18:44 <chrisbuchholz> what does the haskell expression "and" do? Having a hard to google it since, well, yeah, you get why.
04:19:13 <fmap> @hoogle and
04:19:13 <lambdabot> Prelude and :: [Bool] -> Bool
04:19:13 <lambdabot> Data.List and :: [Bool] -> Bool
04:19:13 <lambdabot> Data.Foldable and :: Foldable t => t Bool -> Bool
04:19:55 <fmap> chrisbuchholz: `and' folds list with `(&&)'
04:20:22 <fmap> @src and
04:20:22 <lambdabot> and   =  foldr (&&) True
04:21:14 <Botje> it's like the and of Scheme
04:21:32 <chrisbuchholz> fmap: all right, thank you very much :)
04:26:59 <cizra> Curious. Why is there no configuration option, in happstack server, for file uploads? Right now I'm getting this message: “Reached disk quota of 0 bytes.” and I can't figure out how to fix this.
04:29:17 <fmap> cizra: you may get better answers about happstack in #happs
04:31:32 <cizra> Ohh!
04:34:18 <sopvop> from the depths of digestive-functors `transform . (return .) . (return .)'
04:34:25 <sopvop> now that is pl style
04:34:43 <mauke> @unpl transform . (return .) . (return .)
04:34:43 <lambdabot> (\ e -> transform (\ k -> return (return (e k))))
04:35:16 <sopvop> not that hard now
04:36:06 <shachaf> (transform .) (((return .) .) (return .))
04:46:57 * hackagebot fb 0.13.4.1 - Bindings to Facebook's API.  http://hackage.haskell.org/package/fb-0.13.4.1 (FelipeLessa)
05:02:18 <sopvop> At how many type params you start thinking what your type is way to abstract? I now have one with 8
05:03:32 <quchen> @hoogle and
05:03:33 <lambdabot> Prelude and :: [Bool] -> Bool
05:03:33 <lambdabot> Data.List and :: [Bool] -> Bool
05:03:33 <lambdabot> Data.Foldable and :: Foldable t => t Bool -> Bool
05:10:20 <Eelis> hm, functions are normally defined as sets of (input,output) pairs, right?
05:11:50 <Eelis> wait, wrong channel
05:12:11 <quchen> Also wrong ;-)
05:12:28 <Eelis> tried to join #math and got forwarded to ##math, but Konversation didn't think it appropriate to automatically open the ##math window
05:12:52 <quchen> Wait, that might actually work
05:12:55 <quchen> Not sure about cardinals.
05:13:10 <quchen> Nevermind. Back to Haskell.
05:34:32 <kranius> > replicateM 3 ['a'..'b']
05:34:33 <lambdabot>   ["aaa","aab","aba","abb","baa","bab","bba","bbb"]
05:35:52 <kranius> :t replicateM
05:35:53 <lambdabot> Monad m => Int -> m a -> m [a]
05:38:20 <kranius> sorcery
05:39:04 <Hafydd> There's a shorter way to write ['a'..'b']
05:39:54 <osfameron> it's the clearest perhaps though
05:40:00 <npl> in Data.Foldable, maximum's definition uses foldr; but I have to traverse the whole data structure, should I therefore stick to foldl'?
05:40:10 <osfameron> especially when you compare it with ['a'..'z'] or [1..6]
05:40:26 <osfameron> Hafydd: in fact there are 2 shorter ways, at least ;-)
05:41:25 <Hafydd> So there are, and infinitely many longer ways.
05:43:34 <kranius> what is this 'action' performed by replicateM ?
05:45:37 <fmap> interesting, Data.List.maximum uses foldl1
05:48:34 <quchen> kranius: 'replicateM n' is 'sequence . replicate n'. Do you understsand 'sequence' for lists?
05:50:26 <Iceland_jack> Hey, in the chapter on Systems Programming in Real-World Haskell the authors implement pipes using functions in System.Posix like one would do in C
05:50:49 <Iceland_jack> but looking at System.Process it appears to do a similar thing
05:51:18 <Iceland_jack> I'm not too familiar with System.Process, is there a reason for not using that when implementing a shell pipeline?
05:54:58 <typoclass> Iceland_jack: this is a wild guess, but maybe S.Process wasn't yet around when RWH was written, so they had only S.Posix to go on. RWH is already a few years old
05:55:14 <typoclass> Iceland_jack: but i don't know, i'm speculating
05:55:35 <Iceland_jack> That's possible
05:56:28 <Iceland_jack> The upload date of the first version (1.0.0.0) is listed as 2007 on Hackage
05:56:41 <Iceland_jack> typoclass: Have you got any experience with System.Process?
05:58:31 <typoclass> Iceland_jack: not really, but the few times i used it, it was all pretty straightforward (to the intermediate haskeller)
05:58:33 <Iceland_jack> (the example in RWH also imports System.Process)
05:58:48 <typoclass> Iceland_jack: oh, interesting, then the speculation was wrong
05:59:04 <Iceland_jack> Well it imports it but doesn't use it to handle any of the low-level stuff
06:00:44 <chandra_> hello can anyone help me in defining union of two sets?
06:00:57 <Iceland_jack> I was just wondering if there were any obvious reasons not to prefer System.Process to System.Posix
06:01:21 <quchen> @src union
06:01:21 <lambdabot> union = unionBy (==)
06:01:28 <quchen> @src unionBy
06:01:29 <lambdabot> unionBy eq xs ys = xs ++ foldl (flip (deleteBy eq)) (nubBy eq ys) xs
06:01:41 <quchen> Alright, that's not very transparent.
06:02:14 <Hafydd> Hahah.
06:02:14 <chandra_> can it be done without using foldr?
06:02:20 <typoclass> what the ...
06:02:46 <KBme> hi
06:03:05 <KBme> does anyone know if hlint can warn on non-qualified imports?
06:03:19 <KBme> or, if not, how I could grep for unqualified imports?
06:03:37 <quchen> chandra_: A very easy implementation would be "a `union` b = nub (a ++ b)". However, that one has slightly different semantics: if an element appears twice in a, it won't appear twice in the result.
06:03:50 <KBme> I'm not sure how to negate the qualified, i.e. I want egrep "import (^qualified)…" but that doesn't work
06:04:10 <quchen> Haskell's 'union' guarantees that 'union a b' contains every single element from a, plus the elements from b that are not in a.
06:04:36 <Botje> KBme: grep ^import | grep -v qualified ?
06:04:39 <typoclass> KBme: "grep -v" inverts, i.e. lists all the lines that do *not* contain the pattern. so you could do "cat x.hs | grep '^import' | grep -v 'import qualified'"
06:04:51 <KBme> yeah, i don't want to invert
06:04:58 <quchen> KBme: There's no "doesn't match" in Regex. ^ can only be used in character classes.
06:04:59 <KBme> it would be great if one grep could do it
06:05:03 <KBme> and i'm sure it can
06:05:09 <KBme> oh
06:05:13 <KBme> really?
06:05:15 <Botje> negating a regex is quite hard.
06:05:34 <Botje> if you have ack-grep you can use ack 'import (?!qualified)'
06:05:40 <quchen> Maybe some extended backreference hackery would do the trick, such as ?!, which stands for "doesn't follow" or something like that.
06:05:50 <quchen> I have to read that up every time I have to use it though.
06:06:06 <KBme> just ack-grep?
06:06:08 <KBme> huh
06:06:19 <Botje> ?! is not nearly as scary as ?<! or ??{...}
06:06:20 <lambdabot> Maybe you meant: . ? @ v
06:06:33 <quchen> Why? It's the same horror for me
06:06:34 <Botje> KBme: it uses perl underneath, which does have the feature you're looking for.
06:06:49 <KBme> ok, perl ☹
06:06:55 <quchen> PCRE.
06:06:57 <quchen> Perl compatible.
06:07:00 <KBme> gnu grep should know pcre though
06:07:01 <quchen> Big difference to Perl.
06:07:04 <typoclass> KBme: honestly, i'd just do "grep | grep -v", it's just simpler
06:07:09 <Botje> quchen: no, ack is perl
06:07:20 <Botje> and PCRE is actually "like perl, but different"
06:07:24 <KBme> typoclass, yeah but I want the line number
06:07:36 <Botje> KBme: then use grep -l
06:07:52 <Botje> man grep could've told you this
06:08:10 <Botje> oh, it's -n
06:08:14 <typoclass> KBme: yup, you can make the first grep add line number and file name
06:08:25 <typoclass> Botje: man grep could've told you this :-) scnr
06:08:28 <chandra_> quechen it says nub in not in scope
06:08:41 <Hafydd> import Data.List
06:08:43 <KBme> all right, then complicated it is …
06:08:56 <Botje> it's one command with ack.
06:10:15 <quchen> KBme: This isn't a matter of beauty or using the right algorithm. The beautiful way is using a proper parser. What you're up to is quick regex, and for that only one thing counts: the result.
06:10:22 <KBme> well, this works fine…
06:10:45 <KBme> I should try and create hlint rules but eh
06:17:02 <sopvop> how to mix forall and class constraints?
06:17:09 <sopvop> syntax of it
06:17:51 <opqdonut> :t (+)
06:17:52 <lambdabot> Num a => a -> a -> a
06:18:17 <alpounet> sopvop, show :: forall a. Show a => a -> String
06:18:22 <opqdonut> oh, lambdabot doesn't print foralls anymore :/
06:18:56 <alpounet> opqdonut, yeah, hasn't printed them since it's been switched to a recent GHC
06:19:41 <opqdonut> right
06:21:34 <Kosta> I'm trying to split a Data.ByteString.Lazy using split :: Word8 -> ByteString -> [ByteString]
06:21:43 <Kosta> lbsLines :: B.ByteString -> [B.ByteString]
06:21:43 <Kosta> lbsLines = B.split '\n'
06:21:57 <Kosta> but GHC complains: Couldn't match expected type `Word8' with actual type `Char'
06:22:09 <quchen> :t split
06:22:09 <Kosta> So how do I convert a Char into Word8?
06:22:11 <lambdabot>     Ambiguous occurrence `split'
06:22:11 <lambdabot>     It could refer to either `System.Random.split',
06:22:11 <lambdabot>                              imported from `System.Random' at State/L.hs:51:1-20
06:22:34 <Kosta> :t Data.ByteString.Lazy.split
06:22:36 <lambdabot> Word8 -> BSLC.ByteString -> [BSLC.ByteString]
06:22:54 <quchen> :t (fromIntegral ('c' :: Char)) :: Word8
06:22:56 <mauke> Kosta: convert how?
06:22:56 <lambdabot>     No instance for (Integral Char)
06:22:56 <lambdabot>       arising from a use of `fromIntegral'
06:22:56 <lambdabot>     Possible fix: add an instance declaration for (Integral Char)
06:22:59 <geekosaur> fromIntegral . ord
06:23:24 <Kosta> :t (fromIntegral . ord '\n') :: Word8
06:23:25 <lambdabot>     Couldn't match expected type `Word8' with actual type `f0 b0'
06:23:25 <lambdabot>     In the expression: (fromIntegral . ord '\n') :: Word8
06:23:40 <quchen> :t (fromIntegral . ord $ '\n') :: Word8
06:23:41 <lambdabot> Word8
06:25:52 <Kosta> ok that works. thanks!
06:26:53 <Kosta> But the docs have this example: split '\n' "a\nb\nd\ne" == ["a","b","d","e"]
06:26:57 <Kosta> http://www.haskell.org/ghc/docs/latest/html/libraries/bytestring/Data-ByteString-Lazy.html
06:26:59 * hackagebot yesod-auth-fb 1.3.2 - Authentication backend for Yesod using Facebook.  http://hackage.haskell.org/package/yesod-auth-fb-1.3.2 (FelipeLessa)
06:27:11 <Kosta> How do they get away with using '\n'?
06:28:48 <aheller> is Data.ByteString.Char8 frowned upon?
06:29:39 <fmap> Kosta: I guess docs are copied from Data.ByteString.Lazy.split, which should work with '\n'
06:29:40 <typoclass> Kosta: \n is a regular Char that can show up in "iii\niii" or as '\n'
06:29:52 <fmap> er
06:30:04 <fmap> Data.ByteString.Lazy,Char8.split
06:30:39 <typoclass> or what was the question?
06:30:51 <mauke> typoclass: fail
06:31:31 <Kosta> fmap: ok, that would explain it
06:32:33 <fmap> I suck at typing module names without neco-ghc :[
06:33:32 <typoclass> mauke: well?
06:33:33 <wuwuwu> hello , ive got a question , while declarin and trying to run an instanced function i'm getting an error : Malformed instanced header
06:34:00 <wuwuwu> can someone show me a layout from an instance ?
06:34:14 <mauke> wuwuwu: can you show us the actual error and code?
06:34:29 <geekosaur> it's not frowned upon; in fact, it's considered slightly "safer" in that it matches the underlying ByteString, whereas the Char variant inappropriately suggests that Char is valid (Haskell Char is a Unicode codepoint; ByteStrings are backed by bytes, not charpoints, and cannot represent codepoints outside 0-255)
06:35:00 <typoclass> aheller: ^^
06:35:08 <mauke> geekosaur: the first half of your answer contradicts the second half
06:35:57 <aheller> typoclass: Just wondering why we were contorting ourselves through fromIntegral and ord...
06:36:33 <hpaste> wuwuwu pasted “smth” at http://hpaste.org/78761
06:36:57 <mauke> wuwuwu: what is that supposed to do?
06:37:40 <wuwuwu> i've just started to look at instances and type classes , it's just for testing purpose and getting used to the structere
06:38:04 <Botje> wuwuwu: you need to declare a typeclass first.
06:38:25 <typoclass> mauke: you know, instead of telling people that they're wrong and generally being irritating, it'd be more constructive if you could give some sort of reason why you think they're wrong
06:38:28 <ocharles> oh good
06:38:30 <ocharles> hackage is down
06:38:36 <ocharles> the second I finish writing tests to release a package :(
06:38:40 <geekosaur> hm, perils of answering questions on waking, somehow I read Word8 for Char in the question :(
06:38:41 <mauke> typoclass: I didn't say you're wrong
06:38:57 <geekosaur> anyway ByteString.Char is frowned upon as mixing things thta don't mix well
06:38:58 <typoclass> mauke: you did cryptically say "fail" to me, and refused to elaborate
06:39:11 <mauke> <typoclass> or what was the question?
06:39:17 <Botje> wuwuwu: for example, you could define class Test a where testout :: a -> a -> a
06:39:23 <mauke> you wrote something that had no relation to the question asked
06:39:28 <Botje> and then instance Test Int where testout = (+)
06:39:40 <typoclass> geekosaur: well, he did ask for "Char8" ... :-)
06:39:47 <wuwuwu> ok thank you very much
06:39:51 <alpounet> wuwuwu, implicit in Botje's answer, a type class must start with an upper case letter
06:39:59 <aheller> geekosaur: Yeah, I figured it would be something like that.
06:41:56 <Athas> So what's the right place to import catch from these days?  Apparently Prelude is not it.
06:42:11 <mauke> Athas: depends. which 'catch'?
06:42:15 <alpounet> Control.Exception?
06:42:20 <alpounet> @index catch
06:42:20 <lambdabot> Control.Exception, System.IO.Error, Prelude
06:43:06 <typoclass> mauke: i answered the question as i understood it, and indicated that in my opinion, it'd help if the asker clarified some more. i feel that is reasonable
06:43:34 <mauke> typoclass: that's not how it came across at all
06:43:39 <Athas> mauke: whichever one used to be in Prelude, really.  It seems that Paths_xmonad.hs expects to be able to import a catch from Prelude.
06:43:58 <Taneb> There... is one in Prelude
06:44:03 <mauke> Taneb: no, there isn't
06:44:09 <Taneb> Okay
06:44:23 <Taneb> I just got here, I shouldn't be talking yet
06:45:02 <mauke> Athas: I'd suggest System.IO.Error but hackage is down so I can't confirm my answer
06:45:23 <Athas> mauke: what's the relation between Control.Exception and System.IO.Error?
06:45:27 <elliott> that sounds like a case of outdated cabal
06:45:45 <elliott> AFAIK the old exceptions stuff is totally gone now
06:45:51 <mauke> Athas: what kind of answer are you looking for?
06:46:13 <Athas> mauke: preferably a hint as to where this stuff is documented.
06:46:25 <mauke> what
06:46:27 <Athas> Why is it exported by more than one module anyway?  There's probably a good reason and I'd like to know it.
06:46:35 <mauke> it isn't
06:46:35 <elliott> @hoogle System.IO.Error.catch
06:46:36 <lambdabot> Prelude catch :: IO a -> (IOError -> IO a) -> IO a
06:46:36 <lambdabot> System.IO.Error catch :: IO a -> (IOError -> IO a) -> IO a
06:46:36 <lambdabot> package maccatcher
06:46:37 <mauke> (anymore)
06:46:47 <elliott> does System.IO.Error.catch even exist any more
06:46:59 <mauke> yeah, that's what I would've checked hackage for
06:47:07 <elliott> answer: no
06:47:09 <elliott> as of GHC 7.6.1
06:47:14 <elliott> Athas: what does cabal --version print
06:47:17 <mauke> oh, good
06:47:33 <elliott> the Paths_ thing is an autogenerated file, it should not be importing things that don't exist
06:47:38 <Athas> elliott: yeah, I was using a bad Cabal.  I had a local bin directory before ~/.cabal/bin in my PATH.
06:47:40 <mauke> I wonder why they had to remove that
06:47:44 <elliott> so maybe you are using a cabal version from when it existed
06:48:06 <elliott> mauke: well all the old exception system code went... I guess you can implement that as a simple wrapper around Control.Exception but I think it's been deprecated for a while?
06:48:25 <elliott> Athas: well the reason there used to be a System.IO.Error.catch is that there used to be a different, less powerful exceptions mechanism that Prelude and that module exported
06:48:32 <elliott> but now there is just the extensible Control.Exception version
06:48:45 <elliott> the previous one having been kept around for a long time for backwards compatibility
06:49:03 <mauke> elliott: yes, I want the wrapper back
06:49:04 <Taneb> You know how "Read" is considered stupid and that? Is "Show" similarly to be avoided?
06:49:07 <mauke> it was useful
06:49:19 <Athas> Taneb: for anything but development, I would say yes.
06:49:21 <mauke> how is Read stupid?
06:49:42 <Athas> Standardised Show instances are OK in my opinion, though.
06:50:13 <elliott> Show is useful for debugging, Read/Show are useful for super-simple toy serialisation
06:50:30 <Taneb> Okay
06:50:47 <Athas> Using show for Int/Integer is OK as well.
06:51:06 <Athas> But even for floating-point numbers, you easily begin to run into trouble.
06:51:23 <neutrino> merijn: thanks
06:51:41 <neutrino> (for the -XArrows tip)
06:51:58 <Athas> > (show 3200000.0, show 32000000.0)
06:52:00 <lambdabot>   ("3200000.0","3.2e7")
06:52:17 <mauke> ooh, there's a catchIOError
06:52:37 <elliott> hm, so there is
06:52:45 <elliott> I wonder why that is still there
06:53:57 <Taneb> So what would I use instead? Text.Printf?
06:55:00 <alpounet> Taneb, well, what's your use case?
06:55:08 <Taneb> Just in general, really
06:55:19 <Taneb> I'm trying to learn what I should use when
06:57:54 <Athas> Taneb: you should use whatever is appropriate.  What does the consumer of the string expect?
06:58:10 <Taneb> Seriously just thinking in general temrs
06:58:12 <Taneb> *terms
06:58:20 <Athas> There's no way to make a generally useful "conversion to string" function outside of debugging (for which you should use Show).
06:58:34 <Athas> Debugging and logging.
06:58:43 <eacameron> I want to multiply (*) an Int and a Double. Why do I have to do "fromIntegral int * double"??
06:59:02 <Athas> If a program has to eventually consume the string, you need to completely specify the output format.
06:59:11 <Athas> eacameron: because both operands to (*) must have the same type.
06:59:37 <eacameron> Athas: ahh...ok that makes sense. But why?
06:59:47 <alpounet> Taneb, well, in my experience, I just tend to use Show when testing stuffs out in ghci or when prototyping (see elliott's comment about super-simple toy serialisation). the rest of the time, i generally either have to serialise the data in some format (binary or not), or display it in a more appropriate way than just: Ctor { etc }
07:00:01 <elliott> eacameron: because (*) is a member of the Num typeclass
07:00:05 <elliott> (*) :: (Num a) => a -> a -> a
07:00:19 <elliott> (arguably, it doesn't even make sense to multiply two arbitrary numbers in general)
07:00:39 <elliott> haskell doesn't have any implicit coercions: you have to do your conversions yourself
07:00:56 <eacameron> elliott: So (Num a, Num b, Num c) => a -> b -> c wouldn't make sense?
07:01:23 <eacameron> elliott: maybe one less Num constraint
07:01:36 <Athas> eacameron: it would be unclear how to carry out the conversion.
07:01:47 <mauke> Athas: or the multiplication
07:02:02 <Athas> Other languages have special-purpose type conversion rules for numbers (usually casting towards more precision); Haskell has only general rules.
07:02:09 <eacameron> Athas: So once the "a" type variable is bound to a particular Num instance, it ceases to be polymorphic through the rest of the type??
07:02:46 <Athas> eacameron: it's not "bound to a particular Num instance", it's instantiated with a specific type.
07:02:48 <elliott> eacameron: it wouldn't, no
07:03:27 <Athas> Think of it like a function application.  The type variable is given a value.  Every place a variable is used, the same value (type) is inserted.
07:03:29 * elliott wonders if there's an FAQ entry on this.
07:03:38 <elliott> Looks like no.
07:04:01 <eacameron> elliott: must not be frequent enough ;) or is it?
07:04:12 <aheller> eacameron: say rather that (*) works on values of some type 'a' which happens to be numeric, but that once you pick an 'a', there's nothing more to pick.
07:05:02 <eacameron> aheller: ok...interesting, I didn't realize that about type constraints. I thought the polymorphism applied to all a's separately
07:05:06 <elliott> eacameron: Anyway, even if there was a way to make such an overly-polymorphic type viable (there isn't, really; you need a bunch of multi-parameter typeclasses with annoying constraints and they'd mess up inference and...), I'd still prefer the type (*) has now; it's more accurate.
07:05:28 <elliott> Arguably it is less convenient, but I prefer to be explicit about what conversions I'm doing; there's plenty opportunity for error there.
07:05:41 <eacameron> elliott: yeah...whenever Haskell surprises me I usually assume I'm too dumb to know why
07:05:46 <elliott> (e.g. multiplying Double * Int: do you want the Int (floor d * i) or the Double (d * fromIntegral i)?)
07:06:16 <eacameron> elliott: got it. good example thanks
07:06:19 <neutrino> are there any cool uses for arrow notation?
07:06:22 <monadicity> hello, an adjunctions be used in haskell?
07:06:28 <neutrino> is it used commonly by any modules?
07:06:29 <elliott> also, this type makes instances of Num easier to declare, and is closer to the mathematical definition of algebraic structures (though this point is mostly a joke, since Num is so far away from any meaningful structure...)
07:07:40 <eacameron> elliott: yeah... that makes sense. otherwise you'd find yourself in a sea of possible conversions and edge cases
07:09:35 <eacameron> One more question: If I have the expression (show val) a bunch of places in my function, will GHC be smart enough to do the show once instead of 3 times or should I declare a "valStr = show val" in the where clause?
07:11:59 <DMcGill> since hackage seems to be down, where are docs from installed packages located? Are they even built by default?
07:12:14 <mauke> eacameron: how would that be "smart"?
07:12:48 <eacameron> mauke: because "val" cannot change so there's no point in recalculating the string for "val" three times
07:12:55 <alpounet> DMcGill, not by default, you can activate it in your ~/.cabal/config
07:13:22 <alpounet> uh, even http://new-hackage.haskell.org/ is down
07:13:35 <elliott> DMcGill: not by default
07:13:44 <Taneb> alpounet, not for me?
07:13:49 <Taneb> Oh wait
07:13:55 <mauke> eacameron: yes, there is: memory usage
07:14:33 <eacameron> mauke: ah...good point. so what does GHC do? how can I find out?
07:15:02 <DMcGill> I don't suppose anybody knows if netwire has some non-hackage docs somewhere, perhaps on github or darcs or something?
07:16:40 <Kosta> What is the haskell way of representing a timestamp?
07:17:09 <Taneb> Data.Time.Clock.POSIX.POSIXTime?
07:17:13 <elliott> Kosta: there is the "time" library whose docs you cannot read due to hackage being down
07:17:14 <Taneb> Depends on the format
07:17:49 <Clint> you can read your locally-installed docs though
07:18:04 <Kosta> Clint: where?
07:18:14 <Taneb> What OS are you on?
07:18:22 <TheShamanoid> guys, is there a cached copy of hackage somewhere i can access?
07:18:22 <Kosta> Taneb, elliot: Thanks, I'll read that later when hackage is back up
07:18:32 <Kosta> Taneb: osx
07:18:43 <Taneb> Ach, the one I don't know very well
07:18:53 <Kosta> somewhere in .cabal?
07:18:57 <Taneb> Yeah
07:19:01 <Clint> Kosta: well, if you haven't built and installed them, then possibly nowhere
07:19:13 <Taneb> .cabal/share/doc/index.html
07:19:28 <geekosaur> @where hackage-mirror
07:19:28 <lambdabot> remote-repo: hdiff.luite.com:http://hdiff.luite.com/packages/archive/
07:19:36 <geekosaur> still god
07:19:38 <geekosaur> er
07:19:40 <geekosaur> still good?
07:19:51 * geekosaur looks at finfers suspicously
07:20:16 <elliott> your finfers are still god
07:20:47 <Kosta> How would I read a timestamp like this: 2012-11-28 00:00:00.183 PST
07:22:00 <TheShamanoid> Kosta: parse it into useful bits?
07:22:06 <aristid> :t parseTime
07:22:06 <Taneb> Something in Data.Time.Format
07:22:07 <lambdabot> Not in scope: `parseTime'
07:22:22 <geekosaur> there's a strptime package on hackage (or its mirror, above) if all else fails
07:22:31 <Kosta> ok thanks :)
07:22:54 <Kosta> parse it to milliseconds since epoch (or similar)
07:22:56 <TheShamanoid> guys to represent an end of file, it is the character '\EOF', right?
07:23:30 <mauke> TheShamanoid: no
07:23:40 <mauke> end of file is not a character
07:23:53 <TheShamanoid> mauke: that's what i was afraid of
07:24:05 <mauke> huh?
07:24:12 <TheShamanoid> mauke: it's a string then? like this "\EOF"?
07:24:38 <mauke> what the heck
07:24:39 <elliott> > '\EOF'
07:24:41 <lambdabot>   <hint>:1:3:
07:24:41 <lambdabot>      lexical error in string/character literal at character 'E'
07:24:45 <geekosaur> TheShamanoid, there is no character representing end of file
07:25:02 <geekosaur> nor string nor other entity
07:25:02 <mauke> TheShamanoid: \EOF is not a thing
07:25:04 <nexx> end of file is just the end of a file
07:25:09 <Athas> It's communicated out-of-band.
07:25:32 <TheShamanoid> http://www.haskell.org/hoogle/?hoogle=eof
07:25:39 <geekosaur> how are you reading your file?
07:25:58 <TheShamanoid> i want to parse a section that starts with x and ends at the end of the file
07:26:13 <merijn> Athas: Ha, not in C world it isn't :p
07:26:18 <geekosaur> those references all refer to parser combinators
07:26:25 <Athas> merijn: actually, that's why char-reading returns an int, not a char.
07:26:32 <merijn> Athas: I know
07:26:59 <Kosta> great. all my docs are only licence files...
07:27:05 <Taneb> Kosta, parseTime defaultTimeLocale "%F %T%Q" gets what you want, sans time-zone
07:27:10 <TheShamanoid> alright, i presume i don't have to specify an ending boundary, i just specify the start
07:27:29 <aristid> is it just me, or is hackage down/slow?
07:27:30 <Taneb> Kosta, assuming you have Data.Time and System.Locale imported
07:27:37 <merijn> TheShamanoid: How are you parsing? I believe parsec and friends specify a "eof" parser combinator
07:27:41 <merijn> aristid: Down, it seems
07:27:43 <geekosaur> hackage is down
07:27:48 <aristid> :(
07:27:54 <Athas> Damn, and I was just reinstalling cabal!
07:27:56 <Athas> Is there a mirror?
07:28:03 <geekosaur> @where hackage-mirror
07:28:03 <lambdabot> remote-repo: hdiff.luite.com:http://hdiff.luite.com/packages/archive/
07:28:05 <TheShamanoid> merijn: pattern matching
07:28:56 <geekosaur> TheShamanoid, go back a step, how are you getting the thing you;re pattern matching against?
07:29:13 <geekosaur> by the time you get to the point of pattern matching, end of file is *probably* end of string... but we can only guess
07:29:33 <TheShamanoid> geekosaur: a structured file
07:29:34 <Mortchek> Are circular module dependencies necessarily a problem?
07:29:52 <aristid> Mortchek: you should usually avoid them.
07:29:54 <Taneb> Mortchek, strictly, no, but actually yes
07:29:58 <Taneb> GHC doesn't like them
07:30:10 <TheShamanoid> geekosaur: i have a file with clearly labeled sections, i pattern match such that i filter each section
07:30:16 <geekosaur> there is soemthing missing in the middle somewhere.  something about how you are getting the contents of that file into your haskell code...
07:31:59 <Mortchek> What are some strategies for eliminating circular dependencies?
07:32:36 <merijn> Mortchek: If by "necessarily a problem" you mean "has conceptual problems that would break things", then no. They do pose a challenging and annoying engineering problem, so afaik no compiler implements them
07:32:42 <TheShamanoid> geekosaur: nevermind, it worked. It was automatically the end of file once haskell reaches the end.
07:32:47 <merijn> Mortchek: You can use hs-boot files with GHC to get them to work
07:32:48 <TheShamanoid> geekosaur: thank you very much.
07:33:16 <merijn> Mortchek: Depends on what you're doing, usually either parameterise your data types more of define them/classes in a separate file and import them from there
07:33:21 <typoclass> Mortchek: they are a little inconvenient to work with. you'd typically do that if you can't avoid it
07:33:40 <yitz> Mortchek: usually separating types into a separate module is helpful. and anything else that is by nature "shared".
07:33:53 <typoclass> Mortchek: as for fixing circular dependencies, you could structure the modules differently? it's tough to say without more details :-)
07:34:01 <Mortchek> So, for example, keep a type and operations over it in separate modules?
07:34:33 <Mortchek> This is the project I am working on, a CYOA program: https://github.com/Mortchek/wayfarer
07:34:54 <hpaste> neutrino pasted “what is wrong with this arrow expression?” at http://hpaste.org/78762
07:34:57 <Mortchek> I need to modify Page.render so that it accepts a Session value, but the Session module relies on the Page module.
07:35:09 <neutrino> guys, I have no idea how to use them arrows.
07:35:33 <yitz> Mortchek: sometimes. operations that are closely tied to the type itself, and use nothing else outside of that type, sometimes you might put in the same module.
07:35:44 <merijn> Mortchek: The usual solution would be to make Session a "Session a" and then use "Session PageId" as type
07:35:53 <yitz> Mortchek: that sounds like separating out just the types would do it for you.
07:36:14 <Mortchek> Okay, I will try that. Thanks.
07:36:15 <merijn> Mortchek: Or define the Session and PageId types in a separate module and import both into Session.hs and Page.hs
07:36:18 <typoclass> Mortchek: which parts of Page are needed by Session? could you separate them out into a new module Common or Types or whatever?
07:36:37 <typoclass> Mortchek: ... er yeah, i basically said what merijn said :-)
07:36:42 <Mortchek> typoclass, soon I will implement a Conditional page content, which relies on information present in the Session.
07:37:01 <rwbarton> neutrino: isn't arrow notation introduced by 'proc' or something
07:37:22 <yitz> the reason ghc has trouble with circular dependencies is that it does separate compilation. with whole program compilation, it would be a lot easier.
07:37:42 <neutrino> rwbarton: proc?
07:37:46 <neutrino> rwbarton: i don't know.
07:38:08 <neutrino> let me try.
07:38:12 <typoclass> "cat *.hs > AllTheStuff.hs ; ghc AllTheStuff.hs". problem solved, ghc now has whole-program compilation
07:38:13 <rwbarton> well that is the extent of my knowledge about arrow notation
07:38:30 <merijn> rwbarton, neutrino: Yes, arrow notation requires proc like monad notation requires do
07:38:52 <yitz> typoclass: ghc doesn't allow more than one module declaration in a file.
07:39:18 <TheShamanoid> ...., another issues, is it possible to pattern match strings? for example function ("<String>":y) = y   ?
07:39:21 <yitz> typoclass: though there have been proposals about that.
07:39:24 <typoclass> yitz: yeah :-) i was just kidding, i thought it was obvious that isn't very awesome
07:40:06 <rwbarton> TheShamanoid: you can write that, but given that you are asking the question, I think it might not do what you think it does
07:40:09 <yitz> typoclass: no i think you're right it should be allowed. and it actually sounds like spj would be willing to do it if someone works out all the details carefully and completely.
07:40:56 <typoclass> TheShamanoid: you can match whole strings (f "Thing" = ..."), but you can't match prefixes or suffixes directly. you can use guards for that -- "f x | "Cat" `isPrefixOf` x = ...
07:41:10 <rwbarton> > let function ("<String>":y) = y ; function _ = ["hello"] in function ["<String>", "one", "two"]
07:41:12 <lambdabot>   ["one","two"]
07:42:16 <neutrino> > (proc a -> do { x <- (++ "a") -< (returnA "2"); returnA -< x }) "aaa"
07:42:17 <lambdabot>   Pattern syntax in expression context:
07:42:17 <lambdabot>      proc a -> do { x <- (++ "a") -< ...
07:42:20 <neutrino> that works
07:42:35 <neutrino> not on lambdabot though
07:42:38 <neutrino> :)
07:42:41 <neutrino> thanks rwbarton
07:43:00 <rwbarton> glad my extensive arrow-notation knowledge was helpful
07:43:54 <ClaudiusMaximus> l> let function ('<':'S':'t':'r':'i':'n':'g':'>':stuff) = stuff in function "<String>painfulsyntax"
07:43:57 <ClaudiusMaximus> > let function ('<':'S':'t':'r':'i':'n':'g':'>':stuff) = stuff in function "<String>painfulsyntax"
07:43:59 <lambdabot>   "painfulsyntax"
07:44:10 <neutrino> ugh
07:44:22 <typoclass> ClaudiusMaximus: er, yeah, 'painful' is the right word there :-)
07:44:29 <neutrino> hackage is down :(
07:45:05 <yitz> rwbarton: i know as much about arrow notation as google does. so it would be fastest if you just google for it yourself instead of waiting for me to do it.
07:45:13 <TheShamanoid> rwbarton: i think i know my mistake now, i am pattern matching it against a list of Strings
07:46:04 * elliott wonders if yitz really means rwbarton
07:46:11 <TheShamanoid> ClaudiusMaximus: That is exactly what i wanted, is there no possible way to make it shorter? otherwise...that's perfect
07:46:31 <yitz> elliott: < rwbarton> glad my extensive arrow-notation knowledge was helpful
07:46:48 * rwbarton is a little confused too
07:46:54 <elliott> yitz: I don't think rwbarton ever asked you a question...
07:46:59 * neutrino thinks yitz has had one arrow too many
07:47:12 <yitz> neutrino is probably right :)
07:47:13 <rwbarton> but yes, neutrino looking up arrow notation in the GHC user's guide from the start would have been fastest
07:47:23 <neutrino> i have!
07:47:30 <neutrino> i somehow missed that proc thing
07:47:36 <rwbarton> fair enough
07:48:06 <ClaudiusMaximus> TheShamanoid: not as far as I know :(  i think something like pattern matching on the result of  dropPrefix :: Eq a => [a] -> [a] -> Maybe [a]  would be preferable
07:48:36 <tibbe> http://hackage.haskell.org/ seems down.
07:48:47 <neutrino> when i use proc, the value i get from it is of e.g. type a -> whatever
07:48:53 <neutrino> how can i make it non-parametric?
07:48:56 <neutrino> i.e. constant?
07:49:03 <yitz> tibbe: yeah i saw someone reporting that on the infrastructure list
07:49:05 <neutrino> i'd look at control.arrow docs but hackage down :(
07:49:39 <typoclass> ClaudiusMaximus: (it's in the standard library under the name stripPrefix)
07:49:53 <ClaudiusMaximus> @hoogle stripPrefix
07:49:54 <lambdabot> Data.List stripPrefix :: Eq a => [a] -> [a] -> Maybe [a]
07:49:54 <lambdabot> Data.Text stripPrefix :: Text -> Text -> Maybe Text
07:49:54 <lambdabot> Data.Text.Lazy stripPrefix :: Text -> Text -> Maybe Text
07:50:01 <ClaudiusMaximus> oo, didn't know it existed
07:50:13 <elliott> huh, is that new
07:50:37 <typoclass> ClaudiusMaximus: good, pay up your €9,99 then ;-)
07:50:45 <yitz> tibbe: remote-repo: hdiff.luite.com:http://hdiff.luite.com/packages/archive
07:51:29 <tibbe> yitz: thanks
07:52:25 <neutrino> ...anyone know what's up with hackage?
07:52:34 <typoclass> neutrino: well, it's down
07:52:35 <neutrino> this crucial resource should have at least 20 nines
07:53:58 <yitz> neutrino: fortunately, luite's mirror seems to be working at the moment
07:55:27 <typoclass> elliott: stripPrefix has been there for at least 2 or so years, i'm pretty sure, but i also dimly remember that several years ago i looked and only found it in MissingH, and nothing in base. so, yeah, i kinda agree it must be new or newish
07:55:57 <typoclass> wish we had a newspaper boy that yells out these things on street corners
07:56:19 <yitz> typoclass: it's in Text. if it's also in List nowadays, it must have been backported from there.
07:56:33 <rwbarton> it was in 6.12 i think
07:56:38 <typoclass> yitz: yeah, Data.List is what i mean
07:56:47 <rwbarton> which agrees with typoclass's "at least 2 or so years"
07:57:09 <yitz> rwbarton: makes sense. isn't that not too long after Data.Text appeared?
07:57:45 <rwbarton> oh it is older actually, 6.8.2 and counting...
07:58:10 <rwbarton> new in 6.8
07:59:30 <elliott> I think 6.8 was the first ghc version I used
07:59:33 <yitz> it's in the Haskell 2010 report but not Haskell 98.
07:59:34 <elliott> so I guess I am just inattentive!
07:59:48 <elliott> Data.Text is newer than GHC 6.8 I think?
08:00:59 <yitz> elliott: i went to look it up on hackage, but...
08:01:18 <elliott> indeed
08:04:41 <snoyberg> yitz: i got your email, the reason people are appearing randomly on haskellers is because i used Math.random() on longitude and latitude ;)
08:05:10 <snoyberg> yitz: the reason is that, without some randomness, people's pins would appear on top of each other (this is apparently a well-known problem with google maps)
08:05:27 <snoyberg> yitz: i'm toning down the level of randomness by an order of magnitude, that should make it look better
08:05:41 <Athas> I wish fromJust didn't exist...
08:06:20 <Hafydd> You mean you didn't write it in Haskell?!!
08:07:40 <snoyberg> Hafydd: you mean haskellers.com? it's specifically the javascript frontend, and i wrote this long before the days of fay
08:07:58 <snoyberg> Hafydd: if i was writing it again today, no question i'd be using fay in place of raw javascript
08:08:09 <Hafydd> Oh, okay.
08:08:52 <Hafydd> So the pins are positioned randomly with each page load? How exciting.
08:10:03 <yitz> snoyberg: hi. ok :). thanks! you can tone *up* the level of randomness for the penguin haskellers.
08:10:19 <yitz> or the pirate haskellers
08:10:23 <snoyberg> Hafydd: well, the code looks like "var latitude = realLatitude + (Math.random() - 0.5) / 80"... so random, but not very random
08:11:10 <snoyberg> yitz: maybe we should have an algorithm that lets any haskellers on the ocean randomly sail around the globe, and any of them on ice can start skating
08:11:30 <yitz> haha
08:11:38 <snoyberg> yitz: but i'm not able to do anything to test claimid.com, i can't even log into their site, it keeps giving me an error message
08:12:12 <yitz> snoyberg: really? i haven't had any trouble logging in, and their main site seemed fine earlier today.
08:12:31 <yitz> snoyberg: it hasn't been possible to create a new account there for at least a year or two now.
08:12:31 <snoyberg> i've never logged in before, that could be the problem
08:12:44 <snoyberg> ahh, that's the issue then
08:13:00 <snoyberg> can you msg me your openid so i can test the SSL certificate
08:13:09 <snoyberg> the error message implies that ubuntu just doesn't trust 'em
08:14:20 <DMcGill> is there a resource (say a page on Haskell wiki) on the syntax for multi-way-if and lambdacase?
08:14:26 <yitz> snoyberg: ok msged u (although an openid url isn't supposed to be secret i think)
08:14:41 <DMcGill> or I guess I should have asked: does anybody know what it is?
08:14:56 <snoyberg> yitz: in general it should be public, but i had no idea what extra information their URLs might contain
08:15:16 <yitz> snoyberg: may be an expired root cert or something. that would make sense under the circumstances.
08:15:39 <snoyberg> yitz: do you get the error message before or after you authenticate on claimid.com?
08:15:44 <yitz> snoyberg: after
08:15:47 <`nand`> DMcGill: if | foo = bar | bat = baz | otherwise = frob
08:15:53 <snoyberg> hmm...
08:15:54 <`nand`> DMcGill: \case Nothing -> foo; Just x -> bar
08:15:56 <edwardk> whoa, snoyberg in #haskell. =)
08:15:58 <neutrino> yitz: oh, luite has a mirror? where
08:16:03 <DMcGill> thanks
08:16:09 <yitz> edwardk: just don't look for snoyberg on reddit
08:16:15 <DMcGill> what's the lambdacase extension? -XLambdaCase?
08:16:21 <snoyberg> edwardk: i'm trying to join the 21st century, i figured it was time to upgrade from usenet
08:16:23 <`nand`> I think so
08:16:43 <edwardk> heh
08:16:44 <typoclass> @where 21st century
08:16:44 <lambdabot> I know nothing about 21st.
08:16:55 <yitz> neutrino: comment out hackage in .cabal/config and add this line: remote-repo: hdiff.luite.com:http://hdiff.luite.com/packages/archive
08:17:20 <neutrino> yitz: oh i just need this for the docs. does he allow the haddocks too?
08:17:20 * edwardk looks for alt.binaries.yesod.bork.bork.bork
08:17:20 <yitz> neutrino: then reverse the comment-outedness when hackage comes back up
08:17:56 <neutrino> edwardk: it's full of chain letters.
08:18:40 <yitz> neutrino: it's so old it doesn't have any messages from nigeria
08:18:57 <neutrino> yitz: nigeria did not exist in 1980
08:19:12 <edwardk> now, the question is, does kibo grep the log of it?
08:20:13 <yitz> neutrino: no it's just for use with cabal install. no web site. sorry.
08:20:55 <yitz> neutrino: but you can use it to get the package tarball and generate the haddocks yourself if you want. or just read the source.
08:21:58 <neutrino> yeah
08:22:05 <neutrino> you're right
08:25:28 <snoyberg> yitz: could you try one more time to log into claimid? if it doesn't work, i'll manually add an email address to your account so you can log in with that via Mozilla Persona (aka browserid)
08:26:18 <DMcGill> hmm, how would I go about updating to a version of ghc that supports LambdaCase?
08:28:12 <Athas> What's the best way to figure out where a fromJust exception is being thrown?
08:29:07 <DMcGill> replace every instance of fromJust with (fromJust . trace "here1")
08:29:11 <DMcGill> iterate the number yourself
08:29:26 <Athas> This is happening in library code.
08:29:40 <Athas> I'd never use fromJust myself (for exactly this reason).
08:30:36 <DMcGill> I only every use it immediately after isJust on structures that don't support cayMaybes
08:30:42 <DMcGill> s/cay/cat
08:31:16 <Athas> Why not use a case?
08:31:36 <Taneb> fromJust is useful when you have something you know will NOT be a Nothing
08:31:39 <snoyberg> Athas: afaik, there's no way right now, simon hengel and i were working on a proposal to try and improve the situation: https://github.com/sol/rewrite-with-location
08:31:42 <`nand`> isJust could always be replaced by fromMaybe (error "name of function")
08:31:45 <Taneb> Maybe it can be Nothing on inputs you can't give it
08:31:45 <`nand`> err
08:31:47 <DMcGill> an example from my code using wires: "whenMap f = arr fromJust . when isJust . arr f "
08:31:48 <`nand`> fromJust
08:31:57 <DMcGill> 'when' is like 'filter' on wires
08:32:03 <DMcGill> (yes, it's annoying)
08:33:24 <Athas> `nand`: yes, exactly.
08:33:40 <`nand`> maybe you could replace arr fromJust . when isJust by a wire that pattern matches to inhibit on Nothing or extract the value otherwise?
08:33:42 <Athas> Partial functions such as fromJust should always be accompanied by an error message that contains an argument for why they'll never be seen.
08:33:51 <`nand`> similar to how ‘when’ is written
08:34:02 <mapf> @src when
08:34:02 <lambdabot> when p s = if p then s else return ()
08:34:09 <`nand`> wrong when
08:34:11 <DMcGill> @src Control.Wire.when
08:34:11 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
08:34:28 <DMcGill> when p =
08:34:28 <DMcGill> mkFix $ \_ x ->
08:34:28 <DMcGill>  if p x then Right x else Left mempty
08:35:07 <DMcGill> I guess that's a better solution
08:35:11 <`nand`> mkFix . const $ \case Just x -> Right x; Nothing -> Left mempty
08:36:32 <DMcGill> although I'm going to specialise it to my use, that's basically what I'm going to do
08:36:45 <ramses_> wouldn't this work as well instead of explicit pattern matching:   maybe (Left mempty) Right
08:36:57 <`nand`> oh yes, of course
08:37:00 <`nand`> much better
08:40:14 <scp_> @hoogle a -> [a]
08:40:14 <lambdabot> Prelude repeat :: a -> [a]
08:40:14 <lambdabot> Data.List repeat :: a -> [a]
08:40:14 <lambdabot> Test.QuickCheck.Arbitrary shrinkNothing :: a -> [a]
08:40:30 <scp_> is there a shorthand for
08:40:46 <scp_> > return 5 :: [a]
08:40:48 <lambdabot>   No instance for (GHC.Num.Num a1)
08:40:48 <lambdabot>    arising from the literal `5'
08:40:55 <scp_> err
08:40:59 <scp_> > return 5 :: [Int]
08:41:00 <lambdabot>   [5]
08:41:05 <`nand`> > pure 5 :: [Int] -- slightly shorter :P
08:41:06 <lambdabot>   [5]
08:41:19 <ramses_> > (:[])
08:41:21 <lambdabot>   *Exception: show: No overloading for function
08:41:21 <scp_> well, I've been using
08:41:27 <scp_> >(:[]) 5
08:41:27 <ramses_> > :t (:[])
08:41:28 <lambdabot>   <hint>:1:1: parse error on input `:'
08:41:29 <scp_> ya
08:41:33 <ocharles> yuck
08:41:35 <ocharles> use pure or return
08:41:50 <ramses_> I'm messing up here :)
08:42:02 <scp_> that gets very very verbose, and isn't really more descriptive
08:42:24 <ocharles> heck, sometimes even \x -> [x] is best
08:42:33 <`nand`> why do you need it specialized? ambiguous type errors?
08:42:34 <ocharles> scp_: (:[]) is hella cryptic
08:42:40 <ocharles> do you really want to be parsing that months lateR?
08:43:07 <ramses_> :t replicate 1
08:43:08 <scp_> ocharles: No, I agree, that's why I'm asking. But (pure 5) is also not really clear until you've internalized a bunch of haskell-isms
08:43:08 <lambdabot> a -> [a]
08:43:38 <ocharles> scp_: sure, but haskell-isms are part of reading haskell
08:44:01 <mightybyte> Anyone know how to fix the following glib build error:  `libraryConfig' is not a (visible) field of constructor `LocalBuildInfo'
08:44:03 <scp_> ocharles: true enough
08:44:17 <ocharles> that said, I do think Data.List should have singleton
08:44:24 <ocharles> (much like Data.Set)
08:45:11 <ocharles> this is sadly one of the downsides where Java beats us, with it's comprehensive set of collection interfaces
08:47:26 <aavogt> there are libraries like edison that nobody seems to use
08:47:27 <`nand`> ocharles: for example?
08:48:17 <ocharles> `nand`: http://docs.oracle.com/javase/1.5.0/docs/api/java/util/Collection.html for a start I guess?
08:48:26 <ocharles> a common interface to all sorts of collectiony like things
08:48:40 <ocharles> sure there are warts, but I still find it more pratical than what we have right now
08:48:58 <typoclass> aavogt: edison was the thing implementing all the okasaki structures, wasn't it?
08:49:03 <`nand`> surely that could be added as a typeclass straightforwardly?
08:49:09 <ocharles> sure, that's what classy-prelude is about
08:49:12 <ocharles> afaik
08:50:31 <aavogt> typoclass: yes and it has many type classes which might be set up to let you use the same definition for making singletons (and other things) of different collections
08:50:59 <typoclass> aavogt: hm interesting
08:51:43 <TheShamanoid> guys lets say i have a string "Hi How Are you?" , will this pattern match it ->  function (x:'H':'o':'w':y) = y   ?
08:52:10 <ocharles> did you try it and see?
08:52:41 <aavogt> > case "Hi How Are you" of (x:'H':_) -> x
08:52:42 <lambdabot>   *Exception: <interactive>:3:1-39: Non-exhaustive patterns in case
08:52:46 <TheShamanoid> ocharles: yes, it is giving me a non-exhaustie pattern error
08:53:21 <aavogt> x only stands for one character in your pattern
08:53:48 <TheShamanoid> aavogt: how can i make it stand for a string?
08:53:55 <`nand`> that's not how patterns work
08:53:56 <geekosaur> you can't
08:54:19 <`nand`> you're matching on the (:) constructor, which prepends a character to a string
08:54:30 <TheShamanoid> so i will need to split the function into a two part recursive one, right?
08:54:56 <aavogt> > [ x
08:54:57 <lambdabot>   <hint>:1:4: parse error (possibly incorrect indentation)
08:55:10 <Philonous> TheShamanoid:  I think you mean a different kind of pattern matching. Try a library for regular expressions
08:55:41 <typoclass> > let f x | "How" `isInfixOf` x = "yup" | otherwise = "nope" in f "Hi How Are you?" -- TheShamanoid, try a guard (|)
08:55:42 <lambdabot>   "yup"
08:55:56 <S11001001> TheShamanoid: or look in the string library for a function
08:56:12 <yitz> Philonous: you mean a parser combinator library ;). but actually i don't think TheShamanoid really needs that here.
08:57:02 <`nand`> > let f [] = "Not found!"; f ('H':'o':'w':_) = "Found!"; f (_:xs) = f xs in (f "Hi How Are you", f "Hello, world!")
08:57:04 <lambdabot>   ("Found!","Not found!")
08:57:06 <Philonous> yitz:  They are all so turing complete.
08:57:07 <aavogt> > [ x | let txt = "Hi How are you?",  (x, stripPrefix "How" -> Just {}) <- inits txt `zip` tails txt ]
08:57:09 <lambdabot>   ["Hi "]
08:57:14 <yitz> Philonous: indeed
08:57:51 <typoclass> aavogt: uh, that sure clears things up :-)
08:58:10 <Philonous> yitz:  And he basically gave a regular expression.
08:59:34 <aavogt> typoclass: a regex is likely cleaner
08:59:48 <TheShamanoid> alright, looks like i will need to use a completely different method then. Thanks for the help guys!
09:00:08 <Philonous> Does lambdabot have support for regular expressions?
09:00:33 <typoclass> > if "How" `isInfixOf` "Hello Howdya do" then "yup" else "nope" -- TheShamanoid, this is how isInfixOf works
09:00:35 <lambdabot>   "yup"
09:00:35 <aavogt> > "yes" ~= "e" :: Bool
09:00:37 <lambdabot>   Not in scope: `~='
09:00:37 <lambdabot>  Perhaps you meant one of these:
09:00:37 <lambdabot>    `/=' (imported from ...
09:00:47 <aavogt> > "yes" =~ "e" :: Bool
09:00:48 <lambdabot>   Not in scope: `=~'
09:00:48 <lambdabot>  Perhaps you meant one of these:
09:00:48 <lambdabot>    `==' (imported from ...
09:02:10 <TheShamanoid> typoclass: i understand, it is just i need it for parsing and need to extract a string from within
09:02:15 <yitz> > getFirst . mconcat . map (First . stripPrefix "How") . tails $ "How Are you?"
09:02:18 <lambdabot>   Just " Are you?"
09:02:30 <TheShamanoid> typoclass: in this case, isInfixOf isn't applicable
09:03:11 <yitz> > listToMaybe . mapMaybe (stripPrefix "How") . tails $ "How Are you?"
09:03:13 <lambdabot>   Just " Are you?"
09:04:09 <TheShamanoid> yitz: -_-
09:04:17 <typoclass> TheShamanoid: oh okay. you might want some sort of split function then, so that split "x" "abc x def" gives ["abc ", " def"]
09:04:29 <TheShamanoid> yitz: are you the messiah?
09:05:45 <TheShamanoid> yitz: that is exactly what i wanted. I will look into this function stripPrefix. Thank you very much!
09:05:49 <ocharles> :t mapMaybe
09:05:50 <lambdabot> (a -> Maybe b) -> [a] -> [b]
09:06:02 <ocharles> :t catMaybes
09:06:03 <lambdabot> [Maybe a] -> [a]
09:07:22 <`nand`> : isInfixOf
09:07:24 <`nand`> :t isInfixOf
09:07:26 <lambdabot> Eq a => [a] -> [a] -> Bool
09:08:01 <`nand`> ah
09:08:08 <TheShamanoid> typoclass: stripPrefix is a good function for this situation. Thanks.
09:08:09 <typoclass> (i could swear i've never seen mapMaybe before. in the interaction between lists and Maybe, there's quite some odd functions. listToMaybe is basically head. catMaybes is basically "justs" ...)
09:08:30 <`nand`> I think the only times I've seen listToMaybe used is to demonstrate natural transformations
09:09:04 <typoclass> `nand`: i would describe listToMaybe as a safe version of head
09:09:21 <yitz> TheShamanoid: haha actually we were just discussing that function earlier - maybe because of something you asked before
09:09:48 <`nand`> typoclass: yeah, safeHead or something would have been better
09:09:54 <`nand`> or headMaybe?
09:10:06 <typoclass> i vote for head'
09:10:17 <elliott> or "head"
09:10:36 <typoclass> elliott: yah, provided Prelude.head is removed or renamed
09:11:05 <yitz> unsafeHead
09:11:20 <elliott> head# :: [#a#] -># a
09:11:52 <rwbarton> unsafeUndefined
09:11:54 <scp_> @pl f x = f x x
09:11:55 <lambdabot> f = fix join
09:12:28 <rwbarton> unsafeFix
09:12:55 <yitz> rwbarton: good point. the unsafe prefix isn't meant for the kind of unsafeness we are discussing.
09:13:55 <yitz> @type fix join
09:13:57 <lambdabot>     Occurs check: cannot construct the infinite type: a0 = m0 a0
09:13:57 <lambdabot>     Expected type: m0 (m0 a0) -> m0 (m0 a0)
09:13:57 <lambdabot>       Actual type: m0 (m0 a0) -> m0 a0
09:15:23 <typoclass> maybe we should have some naming convention for "partial function that's likely to blow up". "unsafe" is not appropriate and too much typing, "partial" is too much typing. "bad" could be a candidate ...
09:15:59 <rwbarton> yitz: thanks. that's all I ask :)
09:16:00 <elliott> > let ☹ = fromJust; head = listToMaybe in ☹ (head [1,2,3])
09:16:00 <lambdabot>   mueval: recoverEncode: invalid argument (invalid character)
09:16:10 <elliott> boo
09:16:12 <`nand`> typoclass: I think ‘unsafe’ is good
09:16:17 <`nand`> well
09:16:30 <`nand`> admittedly, ‘unsafe’ can be reserved for things that may not just error but also blow up the assumptions of Haskell
09:16:43 <`nand`> ‘ugly’?
09:17:08 <typoclass> yeah, ugly would be good
09:17:22 <typoclass> 'omg'
09:17:31 <rwbarton> anyone who thinks head is "unsafe" should be forced to program in agda with the termination checker enabled
09:18:21 <typoclass> rwbarton: yes, head is not unsafe in the sense of ceiling cat, but it is likely to blow up your program
09:18:44 <rwbarton> so are built-in Haskell constructs like general recursion and pattern matching
09:18:46 <elliott> rwbarton: I think Idris would be a fairer comparison
09:18:52 <elliott> or does Idris have value-level general recursion? I forget.
09:18:56 <rwbarton> that sounds like a worse fate atm :P
09:19:31 <elliott> give me an Epigram 2 implementation and I'll gladly be forced to program in it
09:19:46 <typoclass> rwbarton: with pattern matching you get warnings if you forget cases, with head i don't think there's a way to get warnings
09:19:53 <sclv> preflex: @bot
09:20:48 <rwbarton> typoclass: this is a toolchain issue, not a language issue
09:21:47 <rwbarton> has there been any project on runtime contract checking for Haskell?
09:22:14 <typoclass> rwbarton: either way, it doesn't change the standard newbie advice. "you can use head, but you need to think twice about it"
09:22:41 <Saizan> head : {A : Set} -> (m : Maybe A) -> {x : A} -> m = Just x -> A -- i don't see the problem ;)
09:23:01 <hiptobecubic> what is this
09:23:25 <Saizan> rwbarton: there's been some project on compile-time contract checking through abstract evaluation
09:23:25 <u_quark> is there some survey or give me some suggestions for automatic GUI generation and (de)-serialization based on the structure of types? (SYB maybe)
09:24:55 <rwbarton> Saizan: yeah I've seen slides about that. but it seems a bit pie-in-the-sky
09:25:05 <rwbarton> but maybe it will really work some day, I don't know
09:25:13 <rwbarton> but runtime contract checking sounds easier, and still very useful
09:26:10 <u_quark> (preferably GTK)
09:28:49 <b_jonas> ST uses a trick with higher order types and phantom types to ensure some values can't effectively escape a particular scope. can such a trick be used in more generality to ease compile time error checking?
09:29:19 <ocharles> wahey, hackage is still fucked
09:29:23 <b_jonas> I think that trick is speicifc for languages with type systems as strong as Haskell though.
09:30:01 <ocharles> b_jonas: "more generally" is too general a question :)
09:30:35 <ocharles> phantom types and gadts are all there to give you richer types
09:31:20 <hpaste> Jambato pasted “number decomposition” at http://hpaste.org/78769
09:32:39 * hackagebot alpha 1.0.2 - A compiler for the Alpha language  http://hackage.haskell.org/package/alpha-1.0.2 (MarcCoiffier)
09:32:41 * hackagebot digestive-functors-aeson 1.0.2 - Run digestive-functors forms against JSON  http://hackage.haskell.org/package/digestive-functors-aeson-1.0.2 (OliverCharles)
09:32:41 <Saizan> b_jonas: it's only using higher-rank polymorphism, and you can do similar things with ML generative functors i believe
09:33:27 <Jambato> apparently the problem lies with (decomp (n - x) xs) : acc
09:33:37 <b_jonas> the point is, C++ has phantom types and higher rank types, but I believe you can't do a trick like this because it doesn't have parametric polymorphism so the C++ type system can't automatically check a higher rank type requirement in general, but only checks specific fully instantiated cases that come up.
09:34:47 <Saizan> oh, how does a higher-rank type look in C++?
09:35:02 <b_jonas> Saizan: a template type
09:35:19 <Saizan> aren't you confusing higher-rank with higher-order?
09:35:40 <hiptobecubic> what is the formal difference?
09:36:17 <Saizan> one is taking polymorphic arguments, the other is being polymorphic over type operators
09:36:26 <b_jonas> Saizan: let me think
09:36:52 <Saizan> ?type (>>=) -- the 'm' there is possible because we have higher-oder polymorphism
09:36:53 <lambdabot> Monad m => m a -> (a -> m b) -> m b
09:37:21 <Saizan> ?type runST -- an argument of type (forall s. ST s a) is possible because of higher-rank
09:37:23 <lambdabot> (forall s. ST s a) -> a
09:37:27 <b_jonas> Saizan: no, I don't think I'm confusing them. look.
09:38:19 <alpounet> Saizan, it's template template parameters then
09:38:31 <b_jonas> if I have a single value of algebraic type that has a data member that is a polymorphic function, that's higher-rank types, right?
09:38:36 <b_jonas> you can have that in C++
09:38:58 <Saizan> yep, that's fine enough
09:39:04 <b_jonas> you can pass a single value and call its function member instantiated multiple different ways
09:39:21 <b_jonas> only C++ can't verify in compile time that you could instantiate it in all possible ways
09:39:44 <b_jonas> in fact C++ specifically doesn't require that you have to be able to instantiate it
09:40:11 * elliott really doesn't think C++ has a way to express the type of runST at all.
09:40:15 <b_jonas> in particular, C++ doesn't allow that thingy when you have infinitely many types in the program
09:40:23 <b_jonas> elliott: exactly, that's my problem
09:41:15 <elliott> well, you're claiming C++ can represent higher-rank types
09:41:21 <elliott> can it even do something as simple as (forall a. a) -> ()?
09:41:56 <b_jonas> elliott: it can sort of do that. you can have a function value that you can call with any type, but you can't prove at compile time that you can indeed call it for any type
09:42:09 <b_jonas> you can call it for only a finitely many different argument types in any one program
09:42:09 <elliott> no, that is not a function that you can call with any type
09:42:16 <elliott> that would be (forall a. a -> ()), not (forall a. a) -> ()
09:42:19 <b_jonas> oh wait
09:42:22 <elliott> the former isn't higher-rank; the latter is
09:42:39 <Saizan> b_jonas: what happens if it's not actually implemented for one of the types you call it with?
09:43:16 <b_jonas> elliott: well, you can have a value of type something like ((forall a. a -> ()) -> ())
09:43:35 <b_jonas> is that enough?
09:43:59 <b_jonas> and you can have a value of type (forall a. () -> a)
09:44:40 <b_jonas> you can't really have a value of type (forall a. a) I think but that's because of an SML-like restriction where a non-function value must be monotype
09:44:42 <elliott> b_jonas: how do you represent that?
09:44:47 <elliott> ((forall a. a -> ()) -> ())
09:44:59 <Saizan> b_jonas: suppose i have the C++ version of f :: (forall a. a -> ()) -> (); f g = g 'a'
09:45:55 <Saizan> b_jonas: and pass it a function (h :: forall a. a -> ()) that's only defined for a = Int, do i get a compile-time or runtime error?
09:46:13 <b_jonas> elliott: consider a data wrapper somewhat like (data W where { f :: forall a. a -> (); };)
09:46:32 <b_jonas> elliott: you can represent something like that in C++ by a structure type that has a template function member
09:46:51 <b_jonas> like struct W { template<typename a> void f(); }
09:47:06 <elliott> hmm
09:47:47 <lilmonkey_> whois lilmonkey_
09:47:51 <elliott> so then you can express runST surely? template <typename A> struct STProg<A> { template <typename S> STAction<S,A> getAction(); };
09:47:56 <b_jonas> you can then pass a value of type W to a function, and that function can call f for two different types, or for ten different types, but only for constant many times in any full program
09:48:04 <elliott> template <typename A> A runST(STProg<A> p);
09:48:13 <mightybyte> Ugh, it looks like Cabal-1.17.0 breaks cairo, glib, etc...
09:48:19 <b_jonas> elliott: you can express runST, but the C++ compiler can't prove that you aren't misusing it
09:48:43 <elliott> how would you misuse it?
09:49:11 <b_jonas> runST will instantiate its argument for constant many times, so S can only have finitely many values
09:49:51 <b_jonas> that's not even the main problem
09:51:06 <elliott> b_jonas: in practice, runST only ever uses its argument with one single parameter
09:51:14 <b_jonas> elliott: the problem is that because of that, STArray<S, T> will be instantiated for only finitely many S (likely only one), and so you can leak one out and reuse it
09:51:14 <Saizan> b_jonas: what if runST instantiates 's' to some hidden type the user code can't reference?
09:51:27 <elliott> (RealWorld)
09:51:35 <elliott> in fact, I believe you could do runST safely even without the forall
09:51:44 <elliott> data Skolem; runST :: ST Skolem a -> a and don't export Skolem
09:51:52 <elliott> though there may be some trick you can break this with
09:52:10 <elliott> b_jonas: no. you can't reuse it even if it's only instantiated with one type in implementation... how could you?
09:52:13 <b_jonas> you can break that down in C++
09:52:18 <elliott> the Haskell implementation uses one value for "s" only
09:52:23 <b_jonas> I don't know whether that would work in haskell
09:52:34 <elliott> well, I'm talking about the quantified version, not the skolem trick, here
09:52:44 <elliott> the Skolem one fails in C++ because you can case on the type
09:53:13 <b_jonas> suppose in user code I write: template<typename S> struct Brk { static STArray<S> *m; };
09:53:43 <b_jonas> then inside an ST context, I can create an STArray<S> and assign it to Brk<S>, then later retrieve it from any ST context that uses the exact same type
09:53:59 <b_jonas> and because the implementation can use only finitely many different S types, that will eventually happen
09:54:34 <elliott> (It's not necessarily finite is it? You can represent the Peano numbers with templates.)
09:54:38 <b_jonas> I thought for some reason you can do some similar breakage in Haskell too
09:54:44 <elliott> I don't see how you'd declare Brk<S>, though.
09:54:49 <elliott> The variable of the right type, I mean.
09:55:50 <b_jonas> elliott: you just write Brk<S>::m = newSTArray(); ... STArray<S> *a = m;
09:56:08 <b_jonas> you have access to S in the template context
09:56:16 <elliott> OK. But how would you access Brk<S>::m outside the runST?
09:56:27 <elliott> Oh, hmm, I see.
09:56:29 <b_jonas> elliott: you don't: you just access it in a different runST
09:56:36 <elliott> Right, polymorphic mutable state like that is problematic.
09:56:54 <elliott> The problem isn't C++'s type system, though.
09:57:12 <b_jonas> is that single hidden type safe in Haskell though?
09:57:14 <elliott> The problem is that's the same as "foo :: forall s. STRef s Int" in Haskell, which would break things too.
09:57:32 <elliott> Well... it's more like "foo :: IORef (forall s. STRef s Int)" or something.
09:57:51 <b_jonas> er no
09:57:57 <elliott> I'm not sure this argument quite works though, because "int foo;" at the top level breaks it just as badly.
09:58:03 <b_jonas> I think you can break it even without such a global side effect
09:58:13 <b_jonas> in C++ that is
09:58:14 <b_jonas> let me think
09:58:27 <elliott> i.e. the problem is that you're twiddling with external state inside the ST action, which obviously is something that can't be prevented in C++.
09:58:48 <b_jonas> yes, your objection is valid
09:58:53 <b_jonas> let me think of a better way to break it
10:04:42 <b_jonas> elliott: I think you can break your Skolem variant in haskell too
10:05:00 <elliott> b_jonas: remember that Skolem isn't exported from the module
10:05:00 <b_jonas> even if Skolem isn't exported, you can have a type that's unified to Skolem in a local context
10:05:05 <elliott> mm
10:05:14 <elliott> probably you can break it but I don't really see a way to
10:05:32 <b_jonas> I think in that context you can call runST twice and transfer an array between them
10:05:54 <elliott> hmm
10:05:58 <elliott> I guess you can get the array out
10:06:05 <b_jonas> in fact
10:06:11 <elliott> yeah nothing stops you just runST (newSTRef blah)
10:06:17 <b_jonas> exactly
10:06:33 <elliott> there's a trick you can do at the type level that works
10:06:36 <b_jonas> if you're lucky, you don't even have to do anything, the type system will actively prove you that you can transfer an array
10:06:39 <elliott> (Class Skolem1, Class Skolem2)
10:06:49 <b_jonas> and that's why you can break it in C++ too without using global state
10:06:59 <elliott> unfortunately I don't think there's any way to express an equivalent at the value level
10:07:12 <b_jonas> what Class Skolem1 thing?
10:07:26 <b_jonas> what's that
10:07:34 <elliott> you can do, broadly, data Skolem1; data Skolem2; type Forall p = (p Skolem1, p Skolem2)
10:07:50 <elliott> see http://hackage.haskell.org/packages/archive/constraints/0.3.2/doc/html/src/Data-Constraint-Forall.html
10:09:36 <elliott> edwardk: btw, are there any plans to incorporate the http://csks.wordpress.com/2012/10/22/safe-polykinded-universally-quantified-constraints-part-1-of-3/ version in the constraints package?
10:10:31 <b_jonas> elliott: I don't think two types is enough for this.
10:11:11 <b_jonas> if you have two types, you might not be able to transfer an STArray from any ST to any other, but you can still transfer between some of them
10:12:05 <elliott> well the point is you would give it (ST Skolem1 a) and (ST Skolem2 a) *but* they'd be the same value
10:12:07 <b_jonas> that might be enough for some checking that catches some user errors, but not for guarantees you can't work around
10:12:16 <elliott> which is safe, because it can't depend on its variable
10:12:17 <elliott> but you can't express that in Haskell
10:12:39 <KBme> hi
10:12:53 <b_jonas> uh, what the hell is this Data.Constraint ?
10:13:41 * b_jonas looks at the docs
10:14:03 <b_jonas> there's not much docs
10:16:43 <gumble> for what is haskell used mainly?
10:16:47 <gumble> which kind of programs?
10:17:08 <Entroacceptor> fibnacci calculators
10:17:15 <b_jonas> and factorial
10:17:34 <b_jonas> unary factorial usually, but I've written a binary factorial once
10:17:41 <Saizan> @quote abstract.research
10:17:41 <lambdabot> Jafet says: Haskell is an abstract research language used only in academia, education, banking, stock trading, circuit design, embedded systems, cryptography, operating systems research, bioinformatic
10:17:41 <lambdabot> s, phone apps, and web services.
10:17:55 <typoclass> gumble: more or less anything. haskell is a general-purpose language
10:18:03 <b_jonas> hmm
10:18:05 <b_jonas> that reminds me
10:18:22 <gumble> so if I know java and c, should I learn haskell?
10:18:58 <typoclass> gumble: yes! :-) it's a very good language. has a steep learning curve, but it's also very rewarding
10:19:01 <typoclass> @where lyah
10:19:02 <lambdabot> http://www.learnyouahaskell.com/
10:19:10 <b_jonas> I have some code that does arithmetic (actually only addition) on zeckendorf-represented numbers (zeckendorf representation means a natural number is represented as sum of Fibonacci-numbers with some constraints)
10:19:15 <typoclass> gumble: here is a good textbook available free of charge ^^
10:19:30 <gumble> atm I am on tryhaskell.org
10:19:31 <b_jonas> I wonder if that could be turned to strongly typed haskell code
10:19:36 <gumble> its really very different
10:19:38 <TheShamanoid> guys! Is it possible to have an if-then statement without the else part? I try to use guards an an alternative but end up duplicating the condition guard and the otherwise guard
10:19:41 <b_jonas> that is, one where the type system guarantees a correct representation
10:19:43 <typoclass> gumble: ;-)
10:19:50 <b_jonas> the problem is, the addition code is ugly
10:19:54 <gumble> typoclass: thanks
10:19:58 <b_jonas> and I don't know if there's a nicer way to write it
10:20:06 <simpson> TheShamanoid: Not exactly. Is this in a monad? You might want "when".
10:20:08 <simpson> :t when
10:20:10 <lambdabot> Monad m => Bool -> m () -> m ()
10:20:42 <b_jonas> TheShamanoid: just write such a function for yourself: ifThen :: Bool -> a -> a; ifThen True x = x;
10:20:51 <b_jonas> but what that's good for I've no idea
10:21:03 <simpson> b_jonas: That's not gonna lead to happiness. :c
10:21:16 <TheShamanoid> simpson: Nope not a monad. So should i stick with   function x | condition = <code>  \n  | otherwise = <same code>
10:21:27 <typoclass> TheShamanoid: nope, 'if' always needs both, a 'then' and an 'else'. they even need to be of the same type. the reason is that the 'if' is an expression, i.e. it evaluates to a value. this value needs to be present in both cases.
10:21:32 <b_jonas> TheShamanoid: so just seq ?
10:21:41 <typoclass> TheShamanoid: put your code on hpaste, i'm sure we can come up with something :-)
10:21:43 <typoclass> @where hpaste
10:21:43 <lambdabot> http://hpaste.org/
10:23:08 <b_jonas> I think it could be possible to write the zeckendorf addition in strongly typed haskell, but it would be very ugly, unless there's some shortcut I don't see.
10:24:13 <b_jonas> I mean, here's the arithmetic with binary numbers: http://www.math.bme.hu/~ambrus/pu/Bin.hs
10:24:38 <hpaste> Shamanoid pasted “If-Then-Else” at http://hpaste.org/78772
10:24:52 <TheShamanoid> typoclass: posted.
10:26:02 <b_jonas> it's just an academic question of course, because I believe zeckendorf representation is very impractical.
10:26:26 <edwardk> elliott: i've been talking to someone about similar changes to .Forall
10:26:42 <b_jonas> hi edwardk
10:27:06 <elliott> I found the solution in the article elegant, though I've now forgotten what it is :)
10:27:13 <edwardk> currently those changes need polykinds tho
10:27:21 <elliott> ah, does constraints not use polykinds currently?
10:27:30 <edwardk> correct
10:27:37 <edwardk> it works w/ 7.4.x
10:27:57 <b_jonas> scary
10:27:59 <edwardk> i'd be loathe to give that up til the platform goes 7.6
10:28:00 <b_jonas> polykinds are scary
10:28:29 <typoclass> TheShamanoid: so this is supposed to take the stuff inside of *asterisks* and discard anything before and after?
10:29:04 <TheShamanoid> typoclass: Exactly!
10:29:14 <robbe-> http://paste.debian.net/214358/
10:29:16 <robbe-> oops
10:29:37 <robbe-> That was not intended, but hey, constructive comments welcome. :P
10:29:59 <TheShamanoid> robbe-: code is now copyright Shamanoid.Thanks.
10:30:21 <robbe-> :p
10:30:44 <robbe-> gtg
10:30:52 <robbe-> will check back later
10:31:13 <DMcGill> theshamanoid: when you get to line three
10:31:27 <DMcGill> you know some things about the argument that the function was called with:
10:31:33 <DMcGill> you know that it's not the empty list
10:31:49 <DMcGill> and you know that it's not got a '*' as the first element
10:31:54 <typoclass> TheShamanoid: i'd suggest the break function. i think it can help you simplify things
10:31:58 <typoclass> > break (== '*') "lol*cat*abc"
10:31:59 <lambdabot>   ("lol","*cat*abc")
10:32:38 <typoclass> > let (_, _:xs) = break (== '*') "lol*cat*abc" in xs
10:32:39 <DMcGill> so you don't need to test for "x /= '*'" right?
10:32:39 <lambdabot>   "cat*abc"
10:34:05 <gumble> on wikipedia it says haskell can be interpreted and compiled, does that mean you could just use the interpreter while developing and when you're finished just compile the code so it will run anywhere without a haskell interpreter?
10:34:05 <typoclass> > let f = break (== '*') ; (_, _:xs) = f "lol*cat*abc" in fst (f xs) -- TheShamanoid: so, in the end it could be something like this
10:34:07 <lambdabot>   "cat"
10:34:12 <gumble> or would you have to make changes then?
10:34:29 <DMcGill> gumble: the latter
10:34:43 <DMcGill> ghci is a REPL that you can "interpret" code in
10:34:48 <typoclass> TheShamanoid: (also, in your paste, lines 3 and 4 called the same function, so they could trivially be collapsed, but i assumed that was just a placeholder and was meant to change later :-)  )
10:35:00 <DMcGill> but ghci just calls ghc (the compiler) behind the scenes
10:35:22 <typoclass> gumble: yup, that's true, you can use ghci for developing and trying stuff out, then use ghc to compile it
10:35:31 <TheShamanoid> DMcGill: no i need to test for anything that isn't equal to * and remove it so that the pattern on the second line is eventually reached
10:35:55 <DMcGill> patten matches are done in a top-down fashion
10:35:58 <gumble> I think I'm beginning to like this
10:36:22 <DMcGill> x on line 3 can NEVER be equal to '*', if it were then line 2 would have matched and line 3 wouldn't have been reached
10:36:58 <TheShamanoid> DMcGill: that's exactly what i want
10:37:13 <DMcGill> that's how Haskell works
10:38:23 <TheShamanoid> basically, it removes everything before the * and after it matched the pattern in the second line, it should remove anything after the next *
10:38:44 <DMcGill> > (takeWhile (/= '*') . drop 1 . dropWhile (/= '*')) "123*456*789"
10:38:46 <lambdabot>   "456"
10:38:48 <merijn> gumble: In fact, I would consider anyone who doesn't continually load code in the interpreter while developing clinically insane :p
10:38:56 <TheShamanoid> i want the pattern on the second line to be matched as soon as possible
10:39:03 <DMcGill> it is
10:39:17 <DMcGill> haskell tries the first match, then if that fails trys the second and so on
10:39:26 <TheShamanoid> yeh, i know
10:39:41 <DMcGill> can you see why you don't need "x /= '*'"?
10:40:24 <DMcGill> it is certain that x isn't equal to '*' on line 3
10:40:34 <TheShamanoid> DMcGill: boss
10:40:48 <TheShamanoid> DMcGill: I've seen the light
10:41:11 <DMcGill> so merging lines 3 and 4, we have "function (x:xs) | otherwise = function xs"
10:41:14 <typoclass> > let f = break (== '*') ; (_, _:xs) = f "lol*cat*abc" in fst (f xs) -- TheShamanoid: have you also seen this? just as an alternative
10:41:16 <lambdabot>   "cat"
10:41:31 <DMcGill> but 1) the "| otherwise" is pointless and 2) we don't use 'x' so we can replace it with '_'
10:41:42 <DMcGill> giving "function (_:xs) = function xs"
10:41:44 <TheShamanoid> DMcGill: i've changed it to function (x:xs:) = function xs
10:42:05 <DMcGill> that second colon will cause an error btw
10:42:32 <DMcGill> but to be really Haskelly, like typoclass is saying it's better to use higher order functions than explicit recursion
10:43:06 <TheShamanoid> typoclass: i've seen it yes. That is perfect code. Thank you very much.
10:43:10 <citizen93> Hey, I have a small question regarding newtype in Haskell, for example if I have a newtype P s r = P {runP :: [s] -> [(r, [s])]}, how should I construct it? Because if I try P 5 6, it says not in scope :(
10:43:20 <DMcGill> either with "break" and some pattern matching or with "takeWhile" and "dropWhile"
10:43:36 <DMcGill> I prefer my takeWhile and dropWhile of course :p
10:43:52 <citizen93> Furthermore if I have a function f :: P a b, then it should be equivalent to f :: [s] -> [(r, [s])] right?
10:44:10 <TheShamanoid> DMcGill: Haah, i will give both a try. Thank you DMcGill
10:44:22 <DMcGill> citizen93: what's a little confusing are that there are two Ps
10:44:59 <DMcGill> "P 5 6" will cause an error because the constructor P only has one parameter, the function runP
10:45:57 <citizen93> ic, so if I do P 5 it should work?
10:46:04 <DMcGill> 5 isn't a function of that type
10:46:11 <DMcGill> you want something like
10:46:13 <citizen93> oh that's true
10:46:14 <citizen93> indeed
10:46:16 <citizen93> stupid me.
10:46:30 <DMcGill> unsafeHead = P $ \(x:xs) -> [(x, xs)]
10:46:45 <latd> how do I let 2 cases in a swithc go in to each other? like: switch(blah){ case 1: go into case 2... case 2: dosomething(); break; case 3: dosomeotherthing(); break; }?
10:46:59 <citizen93> yes, I see, however the problem is that it says data constructor P is not in scope :(
10:47:22 <DMcGill> that's quite odd, paste your code?
10:47:24 <DMcGill> @where hpaste
10:47:24 <lambdabot> http://hpaste.org/
10:47:44 <citizen93> uhm that's a lot of code, but I'm actually trying out the library http://hackage.haskell.org/packages/archive/uu-tc/2009.2.2/doc/html/src/ParseLib-Abstract-Core.html#Parser
10:48:03 <citizen93> and I try to construct a simple parser
10:48:06 <Hafydd> latd: are you sure you're in the right channel?
10:49:16 <DMcGill> citizen93: the Parser constructor isn't exported by that module - the author made a decision to not let people create their own parsers like that
10:49:30 <citizen93> ... :(
10:49:31 <DMcGill> if you want to play with this sort of thing, make your own module from scratch
10:49:34 <citizen93> how did you know it?
10:49:40 <Hafydd> I suppose I'd do that in Haskell by making each branch into a function, and then using the function names. Unless there's some really demented magic in GHC, that isn't directly possible.
10:49:42 <DMcGill> it's not too hard, I made a parser combinator library last year :)
10:50:03 <citizen93> oh ic, but how can you see that the author did that
10:50:04 <citizen93> ?
10:50:27 <DMcGill> line 4
10:50:40 <DMcGill> at the top, the module's exports are listed
10:50:52 <DMcGill> module ModuleName ( ... )
10:51:00 <citizen93> yes
10:51:14 <DMcGill> To export a data type, the syntax is of the form
10:51:19 <DMcGill> TypeName (Constructors)
10:51:30 <DMcGill> so Parser (Parser) would export the type and the constuctors
10:51:36 <citizen93> oh ic
10:51:48 <DMcGill> (note that Parser (..) is short hand for exporting all the constructors)
10:52:22 <citizen93> ah ic, thank you! I should make my own then =)
10:52:23 <citizen93> thanks!
10:52:33 <DMcGill> and, as in this case, Parser () exports the type but no constructors
10:52:44 <Hafydd> latd: e.g. http://ideone.com/IyB7Xt
10:53:12 <citizen93> One last question, so the author actually wants everybody to use parsercombinators?
10:53:28 <DMcGill> it seems so
10:53:28 <ParahSail1n> @hoogle popCount
10:53:29 <lambdabot> No results found
10:53:34 <citizen93> I see thanks!
10:53:40 <citizen93> then I should create my own =)
10:53:44 <DMcGill> indeed
10:53:56 <ParahSail1n> does popCount compile to the sse4.2 instruction where available?
10:54:13 <citizen93> Thanks DMcGill!
11:08:41 <ParahSail1n> looks like yes
11:11:36 <defieda> i am new to unix, could you tell me where I find stderr? I opened ghci and entered "hPutStrLn stderr "Goodbye, World!"" and the string is printed to the terminal. I thought it would appear in /dev/stderr ?
11:12:04 <Zetetic> By default both stderr and stdout go to the terminal
11:14:01 <Ua51> hello ,  can someone please explain me the differences between rem - mod and div and quot ?
11:15:57 <fmap> > (5 `mod` (-2), 5 `rem` (-2))
11:15:58 <lambdabot>   (-1,1)
11:17:06 <geekosaur> note also that /dev/stderr is a virtual reference to file descriptor 2, not a catchbasin of some kind.  (you can use it to do shell-like redirections from within a program:  writing to /dev/stderr goes to wherever standard error would be sent)
11:17:42 <rwbarton> > ((-5) `mod` 2, (-5) `rem` 2))
11:17:43 <lambdabot>   <hint>:1:29: parse error on input `)'
11:17:47 <rwbarton> > ((-5) `mod` 2, (-5) `rem` 2)
11:17:49 <lambdabot>   (1,-1)
11:18:24 <rwbarton> when n is positive, x `mod` n is always 0, 1, ..., or n-1
11:18:35 <rwbarton> which is normally what you want
11:18:49 <rwbarton> x `rem` n will be negative (or zero) when x is
11:18:58 <dsantiago> Why are the negative numbers in parentheses?
11:19:19 <rwbarton> however if you know that x will be positive, then rem is faster because it's what the hardware implements
11:20:14 <rwbarton> (well rem is always faster :) but the point is they are the same when x and n are both positive)
11:20:58 <n-dolio> dsantiago: - x `mod` y parses as - (x `mod` y).
11:21:40 <dsantiago> Ah, OK. I thought there was something about the binary - being curried. But then that didn't make sense.
11:23:54 <bzm3r> I FIGURED IT OUT! So I read LYAH or Real World Haskell and might be left with a bunch of questions (they really don't tend to answer conceptual questions too well, mainly because they use vocabulary that often means very little to a newbie), but then you can read "A Gentle Introduction To Haskell", which will give you a more rigorous treatment on things whose superficial appearance you are familiar with, and then everything begins to
11:24:09 <b_jonas> elliott: so anyway, that thing with two hidden types, I think it could be done in C++, though I'm not sure how ugly it would come out, and it would give some protection against accidental mistakes, but I think it can be broken if you want to deliberately break it, in either Haskell or C++
11:24:50 <b_jonas> hidden meaning global RealWorld-like types that are not exported
11:26:10 <elliott> well, if you could express the two-skolem-type thing in Haskell I am pretty sure it would be unbreakable, but there's no way to express it AFAIK, you can't state two "typing properties" of a single value like that
11:26:31 <elliott> I guess the closest thing would be (forall s. (C s) => ST s a) where class C a; instance C Skolem1; instance C Skolem2 and it's not exported, but that's not quite the same (and brings in rank-N types anyway)
11:27:16 <b_jonas> elliott: but there the class is not even really neeeded, is it?
11:27:30 <b_jonas> it's the foralled higher rank type that does the magic
11:27:33 <b_jonas> just like with runST
11:28:12 <elliott> well, right
11:37:43 * hackagebot test-framework-quickcheck2 0.2.12.4 - QuickCheck2 support for the test-framework package.  http://hackage.haskell.org/package/test-framework-quickcheck2-0.2.12.4 (MaxBolingbroke)
11:42:43 * hackagebot ansi-terminal 0.5.5.1 - Simple ANSI terminal support, with Windows compatibility  http://hackage.haskell.org/package/ansi-terminal-0.5.5.1 (MaxBolingbroke)
11:52:43 * hackagebot test-framework 0.6.2 - Framework for running and organising tests, with HUnit and QuickCheck support  http://hackage.haskell.org/package/test-framework-0.6.2 (MaxBolingbroke)
11:57:43 * hackagebot test-framework 0.7.0 - Framework for running and organising tests, with HUnit and QuickCheck support  http://hackage.haskell.org/package/test-framework-0.7.0 (MaxBolingbroke)
11:57:45 * hackagebot test-framework-hunit 0.3.0 - HUnit support for the test-framework package.  http://hackage.haskell.org/package/test-framework-hunit-0.3.0 (MaxBolingbroke)
11:57:48 * hackagebot test-framework-quickcheck 0.3.0 - QuickCheck support for the test-framework package.  http://hackage.haskell.org/package/test-framework-quickcheck-0.3.0 (MaxBolingbroke)
11:57:49 * hackagebot test-framework-quickcheck2 0.3.0 - QuickCheck2 support for the test-framework package.  http://hackage.haskell.org/package/test-framework-quickcheck2-0.3.0 (MaxBolingbroke)
12:14:23 <b__> I wrote down this type `data A a where R1 :: b -> A a
12:14:34 <b__> but I don't even know how that can be valid
12:14:54 <b__> how would I pattern-match against this?
12:15:08 <elliott> foo (R1 x) = ...
12:15:09 <Botje> (R1 x)
12:15:10 <defieda> Zetetic: thanks
12:15:10 <acowley> foo (R1 x) = undefined
12:15:11 <elliott> but you can't do anything with x
12:15:14 <acowley> wow
12:15:15 <elliott> since you don't know what type it is
12:15:29 <elliott> acowley: you get points for having a fully-formed declaration
12:15:48 <b__> okay, so is there a use for the type at all? (I'm just experimenting with types)
12:15:50 <acowley> elliott: You could have told me UnicodeSyntax or something allowed … for undefined :P
12:16:20 <elliott> next time I will type faster
12:16:48 <acowley> b__: Sure, when you get a value in A, you have this extra type tag that is available at compile time.
12:17:23 <shachaf> acowley: What extra type tag?
12:17:24 <acowley> Although, the fact that you don't know what b is means you'd probably end up putting a Typeable constraint on it or something, and then we'd all just cry
12:17:30 <acowley> shachaf: The a
12:17:50 <b__> I don't understand how it would be useful though
12:17:52 <shachaf> Well, A with a Typeable constraint is completely different from A
12:17:59 <shachaf> b__: That type isn't useful, really.
12:18:09 <b__> okay
12:18:12 <elliott> that type is just the same as data A a = A
12:18:15 <elliott> except it has a useless parameter
12:18:21 <elliott> *that* type is useful however, it's called Proxy
12:18:25 <b__> ah okay
12:18:30 <shachaf> elliott: Well, it's like data A a = A ()
12:18:32 <acowley> Haven't you every wanted to just put something in a box and never think about it?
12:18:53 <b__> yes my cats
12:18:59 <elliott> children
12:19:01 <b__> but no, not in haskell
12:21:15 <arbn> Hmm? Are we talking about existential types, or Dynamic?
12:21:20 <sclv> a+ to "children"
12:22:00 <elliott> arbn: The former, sort of, except not really.
12:22:04 <b__> I hope that question is not aimed at me because I have no idea
12:22:45 <shachaf> Is Dynamic particularly different from data Dynamic where Dynamic :: Typeable a => a -> Dynamic?
12:22:47 <sclv> @remember acowley: (regarding Proxy) Haven't you ever wanted to put something in a box and never think about it? elliott: children
12:22:47 <lambdabot> It is stored.
12:22:52 <shachaf> It's certaily implemented differently
12:23:24 <acowley> it was a question about existentials
12:23:33 <shachaf> @forget acowley: (regarding Proxy) Haven't you ever wanted to put something in a box and never think about it? elliott: children
12:23:33 <lambdabot> Done.
12:23:41 <c_wraith> It's not really implemented any differently from that.
12:23:46 <shachaf> @remember elliott <acowley> (regarding Proxy) Haven't you ever wanted to put something in a box and never think about it? <elliott> children
12:23:47 <lambdabot> It is forever etched in my memory.
12:23:54 <elliott> shachaf: It's "regarding existentials".
12:23:56 <acowley> I brought up Typeable because that's often the last grasp at rescuing an ill-conceived existential-based design.
12:24:29 <c_wraith> shachaf: The Typeable witness is only useful for getting you the TypeRep, so storing it isn't really any different from just storing the TypeRep
12:24:33 <elliott> shachaf: Dynamic is semantically equivalent
12:24:46 <elliott> I think it just uses the Any implementation for performance? Or to avoid extensions.
12:24:53 <c_wraith> To avoid extensions
12:25:09 <c_wraith> Storing the TypeRep directly is for performance :)
12:25:15 <shachaf> @forget elliott <acowley> (regarding Proxy) Haven't you ever wanted to put something in a box and never think about it? <elliott> children
12:25:15 <lambdabot> Done.
12:25:19 <tac> e
12:25:25 <tac> existentials are the best types
12:25:34 <shachaf> @remember elliott (regarding existentials) <acowley> Haven't you ever wanted to put something in a box and never think about it? <elliott> children
12:25:34 <lambdabot> I will remember.
12:26:13 <shachaf> c_wraith: Well, the primitive "cast" takes a Typeable type, not a TypeRep.
12:26:18 <sclv> shachaf: thanks for fixing up the quote
12:26:39 <sclv> i never seem to get the syntax right
12:26:42 <c_wraith> shachaf: it's only primitive if you don't have unsafeCoerce.  Which..  you do.
12:26:59 <hpaste> b__ pasted “Any other super basic GADT data constructors that's interesting for a noob?” at http://hpaste.org/78777
12:27:02 <b__> ^
12:27:12 <shachaf> c_wraith: Well, Dynamic does.
12:27:26 <shachaf> But one unsafeCoerce (in Typeable) is better than two unsafeCoerces.
12:27:53 <c_wraith> b__: have you seen the typed interpreter examples?
12:28:41 <b__> I think not
12:29:48 <elliott> b__: e.g. data Expr a where Number :: Int -> Expr Int; Boolean :: Bool -> Expr Bool; Add :: Expr Int -> Expr Int -> Expr Int; Or :: Expr Bool -> Expr Bool -> Expr Bool; Equals :: Expr Int -> Expr Int -> Expr Bool; If :: Expr Bool -> Expr a -> Expr a -> Expr a
12:29:53 <elliott> then you can write eval :: Expr a -> a
12:30:05 <c_wraith> yeah, that example
12:30:13 <acowley> and the magic happens in things like Add that can't be asked to add two bools
12:30:23 <elliott> yeah, your expressions are typechecked as well as your interpreter
12:30:47 <c_wraith> That was one of the primary motivating examples for GADTs
12:30:51 <acowley> Does anyone know if there's a timetable for the next release of GHC?
12:31:05 <acowley> c_wraith: That is everybody's primary motivating examples of GADTs!
12:31:09 <b__> but can't that example be done with standard types and functions?
12:31:13 <c_wraith> hopefully there's a point release soon, to fix the type checker bugs
12:31:23 <acowley> c_wraith: Yeah, that's what I'm waiting for
12:31:46 <c_wraith> acowley: well, there's a patch in the 7.6 branch for it, so..  Ask igloo if there's a release planned to get that patch out?
12:32:21 <acowley> b__: No, without GADTs you'd just have values of type Expr (rather than, say, Expr Int). Which means you could create a value, Add (Boolean True) (Boolean False).
12:32:29 <c_wraith> b__: no, it can't.  You can't correlate constructors with types without GADTs.
12:32:32 <acowley> c_wraith: It's another patch I'm waiting for
12:32:38 <elliott> and you couldn't write eval :: Expr a -> a
12:32:53 <acowley> Not the big massive unsafeCoerce bug
12:33:03 <c_wraith> ah
12:33:25 <acowley> But it was merged weeks ago, so I assume it will be included in whatever the next release is
12:34:03 <b__> acowley, yeah but why is there a need for this when we have ie. (+), (==) etc
12:34:23 <c_wraith> b__: so that fewer wrong programs will compile
12:34:31 <c_wraith> b__: it moves errors to compile time, instead of runtime
12:34:32 <acowley> b__: Because you're writing your own interpreter for your own language
12:34:43 <elliott> b__: it's not about using these directly in haskell
12:34:47 <elliott> it's about using haskell to implement another language
12:35:02 <elliott> you get assurances that your expressions are well-typed (in your language), and assurances that your interpreter produces well-typed results
12:35:06 <b__> aha okay, then it makes a lot more sense
12:35:08 <Igloo> c_wraith: Release won't be until next year
12:35:38 <b__> so this only (or mostly) makes sense for EDSL's?
12:35:44 <c_wraith> Igloo: not even a 7.6 point release?  Oh wait, it's december. Next year isn't very far away.
12:36:40 <Igloo> right
12:36:56 <acowley> b__: This is an okay example of what we've been talking about, http://hackage.haskell.org/trac/haskell-prime/wiki/GADTs
12:37:09 <acowley> next year!?
12:37:12 <acowley> oh well
12:37:15 <Igloo> and we try to avoid making releases just before we go off on holidays  :-)
12:37:21 <c_wraith> yeah.
12:37:31 <acowley> You are far too noble
12:37:35 <c_wraith> Have to consider the last two weeks of december to be non-existent, anyway
12:38:02 <acowley> It's best to unleash chaos, go on vacation, let tempers settle for a while, then ask for bug reports.
12:39:16 <c_wraith> so if I understand the trac ticket on the unsafecoerce bug, the problem was the golems were escaping? I'm pretty sure the stories about golems said they were a bad idea for a reason!
12:39:24 <b__> acowley, I think I understand, but I'm trying to figure out who needs it why/when. Who would be the users of EDSL's requiring this kind of type safety.
12:39:25 <c_wraith> Oh, wait, skolems?  Eh, same thing.
12:39:48 <elliott> it's not so much for *E*DSLs, that example
12:39:52 <elliott> though GADTs are useful for other things
12:39:58 <acowley> We call them skolems to avoid trademark disputes with the Lord of the Rings people.
12:40:24 <Philippa> b__: anyone with a problem domain they can't afford to make mistakes in
12:40:27 <b__> elliott, for less embedded DSL's then?
12:40:44 <Philippa> elliott: deep embedding is still embedding :p
12:40:54 <Philippa> (and Haskell makes an awesome macro language)
12:41:05 <acowley> b__: Think about this http://en.wikipedia.org/wiki/Greenspun's_tenth_rule
12:41:17 <acowley> b__: The Haskell version of Greenspun's 10th is typed up the wazoo :P
12:42:44 * hackagebot pcd-loader 0.2.3.1 - PCD file loader.  http://hackage.haskell.org/package/pcd-loader-0.2.3.1 (AnthonyCowley)
12:43:29 <b__> are there examples of the kind of DSL we're talking about? or are these mostly personal/proprietary?
12:51:11 <rwbarton> what are the valid characters for use in package names?
12:51:41 <c_wraith> I think A-Za-z0-9_
12:51:53 <c_wraith> I know - is definitely not allowed
12:52:12 <c_wraith> I don't know about non-ascii letters, though
12:52:19 <sipa> and .
12:52:24 <rwbarton> packages, not modules
12:52:33 <sipa> uh, ignore me
12:53:26 <shachaf> rwbarton: Are you trying to make a 'json' package now?
12:53:26 <rwbarton> I wonder if it is just "any character"
12:53:29 <rwbarton> hehe
12:53:31 <elliott> is - really not allowed??
12:53:33 <rwbarton> no, I was just curious
12:53:41 <rwbarton> something like 30% of the packages on hackage have - in their name
12:53:42 <elliott> there are tons of packages with - in the name on hackage
12:53:51 <acowley> - is allowed
12:53:57 <elliott> rwbarton: well I am fairly confident space is not allowed
12:54:00 <elliott> hope this helps
12:54:14 <acowley> hackagebot	 pcd-loader 0.2.3.1 - PCD file loader.  http://hackage.haskell.org/package/pcd-loader-0.2.3.1 (AnthonyCowley)
12:54:20 <acowley> from just a few minutes ago
12:54:35 <shachaf> rwbarton: Nope.
12:54:41 <shachaf> I know a package name can't start with a digit.
12:54:47 <rwbarton> ah
12:54:50 <shachaf> Or at least Cabal doesn't like it.
12:54:54 <c_wraith> - is definitely not allowed in package names
12:55:02 <c_wraith> because it's used as the version separator
12:55:09 <c_wraith> I've tried to put - in package names
12:55:13 <c_wraith> cabal yells at me a lot
12:55:42 <rwbarton> I could give you thousands of packages with - in their names...
12:55:50 <acowley> c_wraith: Maybe you use a different hackage
12:55:52 <rwbarton> okay maybe not thousands
12:56:11 <acowley> pseudo-thousands
12:56:15 <elliott> http://hackage.haskell.org/package/xmonad-contrib http://hackage.haskell.org/package/xml-conduit
12:56:18 <elliott> etc.
12:56:29 <c_wraith> Hmm.  Must have been _ then?
12:56:32 <acowley> elliott: We need thousands, or rwbarton will appear hyperbolic
12:57:06 <rwbarton> 2172 as of my last cabal update
12:57:15 <c_wraith> yeah, ok, I crossed _ and - mentally
12:57:16 <rwbarton> that counts as thousands I guess
12:57:20 <rwbarton> _, interesting
12:57:35 <shachaf> https://github.com/haskell/cabal/blob/master/Cabal/Distribution/Package.hs#L82
12:58:02 <rwbarton> I see
12:58:05 <rwbarton> makes sense, I guess...
12:58:12 <c_wraith> Oh, I also tried to name a package foo-1
12:58:16 <c_wraith> That blew up horribly
12:58:23 <rwbarton> that's what this code won't like, yeah
12:58:23 <c_wraith> That's why I got my wires crossed
12:58:29 <shachaf> rwbarton: Oh, I was wrong.
12:58:30 <rwbarton>         -- each component must contain an alphabetic character, to avoid
12:58:30 <rwbarton>         -- ambiguity in identifiers like foo-1 (the 1 is the version number).
12:58:31 <shachaf> It can't be entirely digits.
12:58:48 * shachaf has previously tried entirely-digit names only.
12:59:05 <rwbarton> can I name my package in French/Russian/Chinese/etc.
12:59:20 <rwbarton> guess I should just try and see
13:03:36 <rwbarton> so far it seems to work on reasonable things like French and Chinese words and fail on unreasonable things like "1" and " "
13:03:42 <rwbarton> and "a b"
13:04:08 <shachaf> That would seem to match the parser code.
13:04:35 <rwbarton> I didn't try anything beyond "cabal configure" though, so who knows what ghc's opinion is
13:04:54 <shachaf> True.
13:04:58 <shachaf> What evils are you eviling today?
13:05:07 <rwbarton> none, I swear :)
13:05:21 <rwbarton> just building my base knowledge for possible future evils
13:05:29 <rwbarton> yeah, it doesn't like _ either
13:05:37 <shachaf> > isAlphaNum '_'
13:05:38 <lambdabot>   False
13:05:51 <rwbarton> oh I missed that bit
13:05:52 <rwbarton> okay
13:06:04 <shachaf> > isAlphaNum (chr 1072)
13:06:06 <lambdabot>   True
13:08:28 <rwbarton> that seems like a pretty reasonable policy
13:09:18 <shachaf> GHC's opinion would surely be good to know.
13:16:22 <shachaf> Hmm, looks like it might use Cabal's code?
13:16:30 <rwbarton> it uses exactly that code yeah
13:16:43 <rwbarton> or ghc-pkg does, anyways, that's what I decided to check
13:17:05 <rwbarton> or actually: PackageName /= PackageIdentifier
13:17:15 <shachaf> PackageIdentifier has a version too, I think.
13:17:17 <rwbarton> so it uses the code further down a bit
13:17:56 <rwbarton> so yes, it is the same
13:18:07 <rwbarton> good!
13:18:41 * hayashi confused monadplus and monoid in an informal haskell lecture today and claimed that maybe was a monoid
13:18:44 <hayashi> fml
13:18:58 <shachaf> hayashi: (Maybe a) is a Monoid!
13:19:08 <shachaf> When a is a Monoid (or Semigroup)
13:19:11 <c_wraith> Oh, wow. Big changes to Typeable coming up.
13:19:40 <c_wraith> I wonder if it becomes auto-derived in the future, if Harper will shut up about it.  Nah, that seems impossible.
13:20:25 <hpc> c_wraith: "Typable is unsound!!1"
13:20:56 <c_wraith> No, unsafeCoerce is unsound.  Typeable is just a class with one function that can't break anything without help from unsafeCoerce. :)
13:21:12 <shachaf> GHC's type checker is unsound.
13:21:38 <hpc> logic is unsound
13:21:52 <rwbarton> so you can at least name your package foo-１
13:22:26 <c_wraith> rwbarton: You should have told me that. I'm dangerous now. :)
13:23:00 <rwbarton> foo¹
13:23:23 <c_wraith> err, *shouldn't
13:24:14 <FireFly> > chr 1234
13:24:15 <lambdabot>   '\1234'
13:24:26 <rwbarton> 33⅓, the next extensible record library
13:24:58 <c_wraith> Extensible? It can barely make it over 12"
13:32:48 <rwbarton> I am mildly amused that I can't use ಠ_ಠ as a package name, not because of the ಠ, but because of the _
13:33:46 <tac> rwbarton: can you find a non-ascii thing that looks like _?
13:33:51 <tac> it might still be doable :)
13:33:56 <rwbarton> I'm sure someone can.
13:33:59 <shachaf> The trouble isn't with it being ASCII.
13:34:05 <shachaf> It has to be alphanumeric.
13:34:59 <shachaf> ಠߺಠ
13:35:19 <shachaf> Somehow that looks wrong.
13:36:03 <Ua51> are there any easy functions where i can test , curry , uncurry  ?
13:36:34 <tac> > uncurry (+)
13:36:36 <lambdabot>   *Exception: show: No overloading for function
13:36:41 <tac> @type uncurry (+)
13:36:42 <lambdabot> Num c => (c, c) -> c
13:36:44 <shachaf> 23E4   STRAIGHTNESS     [⏤]
13:36:44 <shachaf> 23E5   FLATNESS     [⏥]
13:36:51 <tac> > uncurry (+) (1, 5)
13:36:53 <lambdabot>   6
13:37:00 <Peaker> Today I noticed a difficulty in Haskell compared with dynamically typed languages: The inability to deserialize into an "open type sum"...
13:37:54 <arcatan> ...are you decoding JSON?
13:37:54 <Peaker> I might have some value of some parameterized type:  (Binary a, Foo a) => a.   If I serialize it, there's no way to deserialize it into:  exists a. (Binary a, Foo a) => a
13:38:13 <Peaker> arcatan, no, JSON is a closed sum type
13:38:29 <acowley> I have a weird Criterion situation: When I benchmark just one variation of a function instead of two, the times are 4x worse. Anyone seen anything like that before?
13:38:29 <Peaker> the trouble is with "open sum types" (typically a bunch of types defined anywhere that are instances of whatever type-class)
13:38:52 <ParahSail1n> im trying to get ghc to emit the popcnt instruction for Data.Bits.popCount
13:39:00 <arcatan> Peaker: ah, okay
13:39:09 <Peaker> You can't deserialize a type-class instance
13:39:27 <Peaker> if instances were first-class values, and themselves had Binary instances, that could resolve the issue
13:39:57 <shachaf> Peaker: xmonad does something like data Foo = Foo deriving (Read, Show); instance Class Foo where ...
13:40:14 * shachaf doesn't really like it.
13:40:44 <Peaker> shachaf, you mean a unit-type Foo?
13:40:49 <Peaker> shachaf, or just Foo that has stuff in it?
13:42:05 <shachaf> Both.
13:44:31 <Peaker> shachaf, well, I do the same, except I use Data.Binary instead of Read/Show
13:45:21 <Peaker> shachaf, but my problem is that I want to serialize some functions, but they aren't serializable. So instead of constructing functions, I construct explicit Closure objects that are serializable and convertible to the functions I need. However, I don't want to have a single ADT defining all the possible functions in one place, as they need to be implemented in different proper modules
13:46:01 <Peaker> so I'd like to have various modules implementing Closure ADT's, all instances of some class, and being able to serialize a closure, and deserialize it back into the same closure type (without knowing which type it will be when deserializing)
13:46:23 <ParahSail1n> is it not possible to cross-compile, e.g. build environment is not sse4.2, but i want to build with sse4.2 instructions enabled?
13:49:27 <rwbarton> Peaker: have you seen how Cloud Haskell deals with this?
13:49:32 <Taneb> How do cereal and binary actually differ?
13:50:15 <donri> Taneb: not much any more; the features in cereal have mostly been ported to binary, and binary is maybe faster and is going to be platformed
13:50:33 <parcs`> does binary have a Generics support?
13:50:38 <donri> not yet
13:50:46 <parcs`> ah, well that's one aspect
13:50:52 <donri> well there's syb generics in a separate package
13:51:00 <Peaker> rwbarton, yeah, essentially the same approach, but with some TH -- they just generate a closed sum type from a single module, iiuc
13:51:23 <donri> and i think byorgey was working on adding ghc.generics to binary
13:51:38 <dreixel_> I think someone did that. I think I remember seein git.
13:51:41 <donri> (or was it bos? someone with a "b")
13:51:43 <rwbarton> well one thing they do is rewrite the closure to have the form Closure a = (Static (ByteString -> a), ByteString) before serializing it
13:51:45 <Peaker> rwbarton, I'm going to be forced to do the same thing, and throw all of the possible closures there into a single big ADT
13:52:08 <rwbarton> because Closure a = exists t. (Static (t -> a), t) is a problem for serialization
13:52:52 <Peaker> rwbarton, but to decode -- they need to have all the functions in a single map
13:52:56 <rwbarton> sure
13:53:06 <rwbarton> I didn't understand what you meant by "closure type"
13:53:13 <rwbarton> not type in the sense of Haskell I guess
13:53:37 <rwbarton> you can just use a Map String (ByteString -> a), right
13:53:52 <rwbarton> collecting that value will be a pain, yes
13:53:58 <Peaker> I have something like:  data MyFuncClosure = OneFunction FreeVarTypes | OtherFunction OtherFreeVarTypes | ...
13:54:59 <rwbarton> you can avoid the need for separate variable types, that is the trick I was talking about
13:55:14 <rwbarton> rather than serialize oneFunction and freeVar, serialize (oneFunction . decode) and (encode freeVar)
13:56:05 <Peaker> Ah, I see -- then all my FreeVars become the same type, and what's left is the tag
13:56:20 <Peaker> rwbarton, thanks!
13:56:34 <rwbarton> right. then you don't have to worry about what type to deserialize to when you unpack a closure--the function knows what to do
13:57:01 <rwbarton> as SPJ said (approximately) in the cloud haskell talk, "you can have any type of arguments, as long as they're a ByteString" :)
13:57:07 <Peaker> rwbarton, yeah, I didn't remember that cloud haskell did this. This can be very helful
13:57:21 <Peaker> hellful too, especially without good TH support :)
14:00:53 <quchen> I feel like writing a Scheme interpreter might be a good exercise for GADTs, parsing, and program structure. However, I don't know any Scheme. There's "Write yourself a Scheme", but that's a tutorial for beginners and explains everything. Is there some form of language specification that I can use as my sole ressource to implement such an interpreter? Something like Write yourself a Scheme, but without the explanations?
14:01:29 <S11001001> quchen: you mean like r5rs?
14:01:51 <shachaf> I don't think "Write Yourself a Scheme" is actually about Scheme.
14:02:16 <acowley> quchen: If you try inventing your own language that puts parentheses around prefix function application, you'll end up with a very basic Scheme-ish
14:02:21 <sonOfRa> I have written the following function twice, once using map and once using fold. Which is more desirable (performance/readability)? It is an occurs check, which checks wether a given data segment exists as a Leaf in a given Tree: http://hpaste.org/78780
14:02:26 <acowley> Scheme's beauty is its simplicity
14:02:41 <donri> @where sicp
14:02:41 <lambdabot> http://mitpress.mit.edu/sicp/ | http://swiss.csail.mit.edu/classes/6.001/abelson-sussman-lectures/ | http://www.vex.net/~trebla/haskell/sicp.xhtml | "Storage and Identification of Cabalized Packages"
14:02:43 <S11001001> quchen: you could use r5rs, r6rs, or the draft r7rs; these are versions of the semiformal scheme standard.
14:02:58 <quchen> S11001001: I've heard of R5RS for the first time 10 minutes ago. But yes, something like that.
14:03:44 <shachaf> There are also R4RS, R3RS, R2RS, RRS, and RS, presumably.
14:04:08 <S11001001> probably no rs, unless you count ieee schema
14:04:17 <S11001001> s,a$,e,
14:04:30 <quchen> I'm probably looking for the most basic revision.
14:04:38 <S11001001> quchen: then go with r5.
14:04:56 <quchen> Alright, thanks. Should I just read the specification?
14:05:14 <S11001001> quchen: it's not difficult to read
14:05:55 <quchen> So is the Haskell report. But is it also an easy read? ;-)
14:06:12 <quchen> (Just kidding.)
14:06:37 <`nand`> which version of scheme, if any, is purely functional, with no side effects or mutation?
14:07:31 <shachaf> _The Little Schemer_ Scheme.
14:07:54 <aheller> shachaf: Not if that's the same one as Seasoned Schemer
14:08:04 <aheller> quchen: R5RS is the way to go.
14:08:13 <shachaf> aheller: It's not.
14:08:38 <aheller> shachaf: fair enough.  I suppose Racket's BSL might count then, too.
14:09:14 <shachaf> aheller: It's also not the same as _The Reasoned Schemer_ Scheme
14:09:20 <quchen> What distinguishes R5RS from the others anyway? Any major features that are hard to implement otherwise?
14:09:25 <shachaf> Which is probably more like Prolog. :-)
14:09:46 <quchen> ... so if I have a fully working R5 interpreter, how hard is making it R6?
14:10:01 <S11001001> quchen: keep call-with-current-continuation in mind when designing an execution model. And, quite.
14:10:02 <rwbarton> for a language without static types like Scheme there won't be much occasion to use GADTs, will there?
14:10:03 <quchen> (Not that I'm planning on doing this right now)
14:10:04 <aheller> quchen: R5 is a real language while still being tractable to implement as a fun project.
14:10:24 <S11001001> rwbarton: for the syntactic model, sure
14:10:29 <acowley> What's the easiest way to square up a plot produced by Chart so that the axes are scaled the same?
14:10:30 <aheller> quchen: R6 is complicated-er.
14:11:10 <aheller> shachaf: _Reasoned_ has the implementation of mini-kanren in terms of syntax-case in the back...
14:11:24 <quchen> S11001001: call-with-current-continuation? Continuations are the one thing I kept running away from haha
14:11:27 <aheller> shachaf: arguably you could call that the same scheme.
14:11:43 <aheller> quchen: call/cc is part of the fun!
14:12:05 <shachaf> aheller: Well, syntax-case doesn't exist in either _Little_ or _Seasoned_
14:12:17 <aheller> shachaf: Well, it doesn't show up.....
14:12:18 <shachaf> (Or maybe it is in _Seasoned_? I don't remember.)
14:12:26 <quchen> aheller: Oh my.
14:12:39 <`nand`> S11001001: is call/cc like the Haskell callCC (sp?)?
14:12:44 <quchen> aheller: Well then #haskell - I'll be back when I've understood Cont.
14:12:49 <shachaf> quchen: You could do better than Scheme, then.
14:12:55 <quchen> See you when Haskell21 is out
14:12:58 <shachaf> Continuations are pretty important in R5RS.
14:13:18 <`nand`> I mean, can't you just map Scheme to the lambda calculus or something and implement call/cc the same way it's done in Haskell?
14:13:32 <`nand`> then implement an evaluation model for the LC?
14:13:57 <shachaf> Sure, you can translate a Scheme program to CPS.
14:14:06 <shachaf> Continuations are first-class, though, unlike in Haskell.
14:14:07 <aheller> quchen: Monads are nice and all, but it might be easier to think about what call/cc is without pushing it through the type system first.
14:14:16 <S11001001> `nand`: but that everything is implicitly lifted into Cont.
14:14:47 <rofer> I'm pretty new to Haskell and I'm having some trouble making my program exit on Ctrl-C, I'm guessing I want to use installHandler, but I don't know how to have it make my program stop.
14:14:57 <tac> Related: http://www.cs.cmu.edu/~rwh/plbook/book.pdf See chapter 29: Continuations.
14:14:59 <S11001001> quchen: r5 call/cc can be understood quite independently of Cont.
14:15:04 <Peaker> shachaf, callCC makes continuations first-class?
14:15:29 <tac> As far as I understand, adding continuations to a typed language is something like adding the law of excluded middle to the logic of the type system.
14:16:01 <shachaf> Peaker: Well, Scheme's call/cc does.
14:16:21 <Peaker> aheller, what do you mean by "pushing it through the type system"?  What you need to do to "push it through the type system" is exactly what you need to do to make it work correctly, isn't it?
14:16:23 <quchen> So Scheme's Call/CC is different from Haskell's callCC?
14:16:30 <Peaker> shachaf, and why not "callCC"?
14:16:50 <shachaf> Peaker: callCC makes you explicitly rewrite your code in CPS, for one. :-)
14:17:05 <quchen> (And while I'm at it: does anyone know a nice explanaton of Cont plus API?)
14:17:46 * hackagebot ircbot 0.5.3 - A library for writing irc bots  http://hackage.haskell.org/package/ircbot-0.5.3 (JeremyShaw)
14:17:48 * hackagebot HGamer3D-Data 0.1.9 - Windows Game Engine for the Haskell Programmer - Data Definitions  http://hackage.haskell.org/package/HGamer3D-Data-0.1.9 (PeterAlthainz)
14:17:50 * hackagebot HGamer3D-Ogre-Binding 0.1.9 - Windows Game Engine for the Haskell Programmer - Ogre Bindings  http://hackage.haskell.org/package/HGamer3D-Ogre-Binding-0.1.9 (PeterAlthainz)
14:17:56 <S11001001> quchen: yes, it's different
14:18:06 <Peaker> shachaf, I think it's possible to formulate a function that looks like:   foo <- callCC' bar  (so that it avoids the CPS)
14:18:26 <shachaf> Peaker: do-notation (or >>=) is the CPS part.
14:18:27 <shapr> @quote
14:18:27 <lambdabot> avdi says: alter ego? i'll never remember that name when i'm looking for a state machine.
14:18:49 <Peaker> shachaf, well, without do-notation, there's really no well-defined notion of "continuation" to be made first-class?
14:19:07 <shachaf> Well, there is in Scheme!
14:19:16 <shachaf> If Haskell had first-class continuations it'd expose evaluation order.
14:19:38 <Peaker> ok, I see what you mean now
14:19:39 <shachaf> So we use monads to separate execution from evaluation and all that jazz.
14:19:51 <shachaf> callCC (\k -> k 1 + k 2)
14:19:58 <shachaf> A continuation is an effect.
14:22:47 * hackagebot HGamer3D-SFML-Binding 0.1.9 - Windows Game Engine for the Haskell Programmer - SFML Bindings  http://hackage.haskell.org/package/HGamer3D-SFML-Binding-0.1.9 (PeterAlthainz)
14:27:20 <quchen> All the Cont explanations give me a good feeling, but then I look at the implementation again and that makes me feel stupid again.
14:27:42 <shachaf> The implementation as in the Monad instance?
14:27:46 <quchen> Yes.
14:27:48 * hackagebot HGamer3D-CEGUI-Binding 0.1.9 - Windows Game Engine for the Haskell Programmer - CEGUI Bindings  http://hackage.haskell.org/package/HGamer3D-CEGUI-Binding-0.1.9 (PeterAlthainz)
14:27:50 * hackagebot HGamer3D 0.1.9 - Windows Game Engine for the Haskell Programmer  http://hackage.haskell.org/package/HGamer3D-0.1.9 (PeterAlthainz)
14:27:56 <shachaf> Throw that away and rewrite it from scratch.
14:28:04 <shachaf> Starting with the types.
14:28:08 <shapr> aheller: whoa, really?
14:28:09 <shachaf> (The types make it so much easier...)
14:28:14 <tac> quchen: I feel the same way with Cont
14:28:20 <quchen> m >>= k  = Cont $ \c -> runCont m $ \a -> runCont (k a) c
14:28:32 <tac> quchen: it makes it even worse knowing that you can come up with the definition based solely on the type
14:28:36 <tac> and still have no idea what it does
14:29:03 <shachaf> tac: that's way better than coming up with the definition *without* the type.
14:29:19 <quchen> shachaf: Is there some insighe once I finish writing >>=? From what I've heard (and the way you said it) it sounds like it's the only sensible definition. That will however not necessarily teach me what it's doing, only that it's correct.
14:29:23 <shachaf> Which I did at least once, before realizing what I was writing was just Cont.
14:29:42 <shachaf> quchen: After working with CPSed code for a while you get some intuition for it.
14:30:23 <shachaf> Here's Cont in a language where the types don't help you: http://slbkbs.org/toys/callfront.txt
14:30:45 <shachaf> quchen: A good first step is understanding what (a -> r) -> r means.
14:30:59 <shachaf> The return/fmap/join/(>>=)/etc. are just natural ways of operating on ((a -> r) -> r)s.
14:31:36 <glguy> djinn ((a -> i) -> i) -> (a -> (b -> i) -> i) -> ((b -> i) -> i)
14:31:41 <quchen> shachaf: Well, that's basically a curried ($).
14:31:54 <tac> What I'd like to know is why continuations appear everywhere in the theory
14:32:09 <shachaf> quchen: ?
14:32:16 <shachaf> What does currying have to do with it?
14:32:21 <startling> shachaf, ($ someA)
14:32:43 <tac> Continuations allow you to embed classical logic in STLC, continuations allow you to spell out any monad, continuations allow you to define existential types in terms of universal types.
14:32:49 <quchen> It's a thing that takes a function and maps it to a value. A "insert X" function, so to speak.
14:33:04 <tac> I think they have something to do with the Yoneda lemma too
14:33:09 <shachaf> tac: Well, monadic style *is* very close to CPS.
14:33:10 <quchen> Where x :: a.
14:33:45 <quchen> ($ (x::a)) :: (a -> r) -> r
14:33:51 <c_wraith> ((a -> r) -> r) is morally the same as a
14:33:57 <shachaf> c_wraith: No it's not.
14:34:02 <copumpkin> so much morality in here
14:34:10 <shachaf> forall r. (a -> r) -> r is morally the same as a
14:34:23 <shachaf> But (Cont r) isn't polymorphic. There's some specific r.
14:34:37 <shachaf> (This is important. If you make r polymorphic you just end up with a fancy Identity.)
14:34:41 <c_wraith> ah.  I was interpreting it as the quantified version
14:34:49 <quchen> shachaf: Oh, I see. You have to specify what you're ultimately mapping to.
14:34:57 <rwbarton> I often find myself wanting a "quantifier" to say that things are *not* implicitly forall'd
14:35:02 <rwbarton> since people here have a way of misinterpreting
14:35:03 <rwbarton> like
14:35:08 <rwbarton> specific r. ((a -> r) -> r)
14:36:01 <shachaf> free r. ...?
14:36:07 <shachaf> Well, "free" is a bit overloaded. :-)
14:36:22 <c_wraith> yeah, it's accurate, but has the name collision problem
14:36:26 <shachaf> Hmm, you could use ImplicitParams style.
14:36:29 <rwbarton> global r. ((a -> r) -> r) -- like in python??
14:36:31 <shachaf> ((a -> ?r) -> ?r)
14:36:59 <rwbarton> that's not too terrible, but that condones the "implicitly forall everything" interpretation overly I feel
14:37:10 <shachaf> True.
14:37:20 <shachaf> It would be sort of nice if foralls were explicit.
14:37:27 <shachaf> Except for the part where you have to quantify everything.
14:37:37 <rwbarton> but if I were actually willing to commit to putting a ? before every "externally bound" type variable, it might be good
14:37:54 <c_wraith> well, if you had to quantify everything, there'd be better syntax for it.  Right?
14:38:12 <rwbarton> then we'd all have APL keyboards
14:38:21 <shachaf> Well, I mind the "naming all the variables I'm using" part more than the "forall" part.
14:38:31 <tac> Quantifying everything is the honest man's way of doing things
14:38:49 <shachaf> I can type ∀ on my regular keyboard.
14:38:53 <Saizan> just use greek for meta-vars, problem solved
14:39:17 <rwbarton> I just want to be able to say "A semigroup structure on a is a function m :: a -> a -> a satisfying ..." without someone coming in and saying "um there are only two functions a -> a -> a!"
14:39:43 <startling> ∀ ∀. forall
14:39:46 <shachaf> rwbarton: Well, you quantified a right there!
14:39:55 <shachaf> rwbarton: In that sentence the easy way out is to capitalize A
14:40:00 <startling> forall "forall" . ∀ ?
14:40:16 <tac> rwbarton: start off by saying "let a be a type"
14:40:33 <rwbarton> then someone pipes in later having not read "let a be a type". this is the problem
14:40:40 <rwbarton> ideally (IMO) "let a be a type" would be the default
14:40:50 <shachaf> rwbarton: Anyway, people don't mind class Semigroup a where (++) :: a -> a -> a
14:40:55 <shachaf> Which is exactly the same as your sentence.
14:40:56 <tac> rwbarton: Perhaps technology can offer a solution to this
14:40:58 <hpaste> rofer pasted “withMVar typing problem” at http://hpaste.org/78781
14:41:07 <rwbarton> I have tried the capitalized thing a little, maybe that will solve my problem.
14:41:13 <tac> rwbarton: We can add an IRC extension such that every statement we make is associated to a context gamma
14:41:18 <rwbarton> hehe
14:41:19 <rofer> Hey, can someone take a look at that and help me fix my types?
14:41:21 <tac> and when talking, we can just push things into gamma
14:41:26 <tac> and pop them when we lose interest
14:41:37 <rwbarton> there's already !topic-cons
14:41:44 <rwbarton> er, @topic-cons
14:41:55 <rofer> There might also be a better way to do what I'm trying to do. All I want is to have my program exit when it receives Ctrl-C
14:42:01 <tac> Speaking of which, I hae been doing a lot of math recently, and I really wish proofs in math were written with more explicit scoping
14:42:40 <startling> tac: ikr
14:42:44 <tac> ikr?
14:42:45 <glguy> rofer: withMVar runs in “IO”, not StateT
14:42:50 <rwbarton> tac: right, so I have exactly the opposite problem
14:42:52 <startling> tac: "I know, right"
14:42:56 <tac> ah
14:43:09 <rwbarton> not enough context-sensitivity and general-being-reasonable-ness
14:43:29 <rofer> glguy: I see that, but I can't just slap on an IO in front of the return type of maybeContinue, can I?
14:43:35 <startling> tac: I was reading Church's typed lambda calculus paper and I had the insight that all the seemingly unrelated rules he was giving amounted to lexical scoping. :S
14:43:42 <tac> I wish more mathematcians at least understood the notions of variable binding, variable scope, and name capture
14:43:59 <glguy> rofer: nope, you’ll have to “runStateT” your “maybeContinue” and then “lift” the application of withMVar to that
14:44:09 <tac> startling: I panic whenever I have to read anything that old :P
14:44:25 <glguy> rofer: You should probably write a lifted version of withMVar separately
14:44:29 <glguy> and then use it here
14:45:14 <startling> tac: heh. It was a couple yaks deep and all of the summaries I found were pretty terrible, and it's only like 20 pages, so.
14:45:22 <glguy> rofer: unles you don’t care if maybeContinue executes while the MVar is held
14:45:45 <glguy> rofer: if that’s the case you can always “lift (readMVar interrupted)”
14:48:22 <rofer> glguy: I think I want that latter one (I'm quite new to this). All I really want it for Ctrl-C to make my program exit.
14:50:35 <glguy> rofer: you’re calling withMVar interrupted inside of withMVar interrupted
14:50:41 <glguy> which will just cause the program to lock up
14:50:41 <tac> startling: it makes you wonder how so many lisps ended up with dynamical scoping.
14:51:57 <c_wraith> dynamic scoping is natural when you start by implementing a language, instead of thinking about semantics
14:52:19 <tac> I bet :P
14:52:32 <rofer> glguy: Ah, I see that
14:53:23 <c_wraith> "oh, hey, I can just keep local bindings in a stack that mirrors the call stack". "Oh, hey, I can just implement looking up local names as a search of bindings in the stack."
14:53:47 <c_wraith> And..  boom.  you've got dynamic scoping.
14:54:42 <c_wraith> And it won't even show up until you have some sort of closures that refer to name bindings.
14:54:44 <merijn> rofer: Do you care if your program is *nix only?
14:54:45 <tac> boom like blowing up any sensibility in reasoning about your code's execution >__<
14:55:10 <merijn> rofer: If not, your problem can be solved much easier
14:55:27 <rofer> merijn: Not really, though I guess I'd prefer to know how to solve it in a compatible way
14:56:23 <merijn> rofer: Ctrl-C just sends SIGINT to a program, you can use the System.Posix (I think?) module to install a signal handler that receives and and uses killThread or exit to quit your program
14:57:00 <merijn> rofer: Actually, that should work on windows too, but only if someone uses one of the available posix implementations on windows...
14:57:43 <cebewee> Hi. Is there a way to get from IO (a -> IO b) to IO (a -> b)?
14:57:47 * hackagebot data-category 0.5.0 - Category theory  http://hackage.haskell.org/package/data-category-0.5.0 (SjoerdVisscher)
14:57:57 <shachaf> cebewee: Yep.
14:58:04 <elliott> cebewee: no
14:58:11 <shachaf> Oh.
14:58:11 <elliott> shachaf: (what??)
14:58:20 <shachaf> Um.
14:58:28 <shachaf> Never mind, ignore what I said.
14:58:30 <shachaf> I read that backwards.
14:58:57 <cebewee> ok, I feared that.
14:59:07 <rofer> merijn: that doesn't seem to be working :/ pasting my code
14:59:07 <merijn> cebewee: The best you can do is turn it into "a -> IO b", I think
14:59:33 <ParahSail1n> should i upgrade to 7.6?
14:59:44 <hpaste> rofer pasted “killThread attempt” at http://hpaste.org/78782
14:59:50 <c_wraith> I often write things with type signatures like IO (a -> IO b).  It's really handy for closing over values that need to be created in IO
15:00:11 <merijn> ParahSail1n: It depends
15:00:24 <merijn> ParahSail1n: Why are you considering upgrading?
15:01:04 <cebewee> my goal was to take a function a -> Bool, wrap it to catch exceptions (and return False in that case) and pass it to find
15:01:06 <Heffalump> cebewee: imagine that the embedded function returns a different random number every time
15:01:11 <ParahSail1n> merijn: bandwagon?
15:01:19 <merijn> ParahSail1n: Then probably not
15:01:24 <aavogt> @hackage spoon
15:01:24 <lambdabot> http://hackage.haskell.org/package/spoon
15:01:24 <cebewee> liftM2 find, that is
15:01:32 <Heffalump> if you could get a -> b from it, that has a pure type so should return the same number each time
15:01:40 <ParahSail1n> merijn: is there anything useful i'd get from upgrade?
15:01:56 <rwbarton> you would probably learn a lot about cabal from trying to get things to install on 7.6
15:02:12 <merijn> ParahSail1n: promoted literals, but if that doesn't mean anything to you than it's probably not worth upgrading for :)
15:02:28 <fmap> and working -XDataKinds
15:02:32 <shachaf> rwbarton: I haven't had a whole lot of trouble with installing things on 7.6
15:02:33 <merijn> ParahSail1n: Oh, well I guess you also get LambdaCase and MultiWayIf
15:02:41 <aavogt> cebewee: that package could be used to write such a function.
15:02:41 <rwbarton> you already know a lot about cabal
15:02:47 <merijn> fmap: That's mostly associated with promoted literals in my head
15:02:52 <rwbarton> I suppose ParahSail1n might also
15:03:00 <ParahSail1n> merijn: is code generation better in 7.6?
15:03:07 <rofer> merijn: See anything wrong with what I pasted?
15:03:13 <cebewee> aavogt: I'll have a look
15:03:33 <beaky> hello
15:03:43 <merijn> rofer: Not really, but then again it midnight after a long work day, so unless it's something obvious I wouldn't count on me finding it :)
15:03:52 <fmap> merijn: speaking of literals, are they useful as they are now for something else than being phantom types?
15:04:15 <cebewee> my ultimate goal is getting to http://stackoverflow.com/questions/13711226/ but I need to take baby steps =)
15:04:18 <aavogt> cebewee: if you're throwing the exceptions in your own code it is probably better to avoid throwing them rather than doing bad stuff to catch them in "pure" code
15:04:32 <merijn> fmap: Yes, type level lists!
15:04:50 <ParahSail1n> are there any drawbacks to upgrade to 7.6
15:04:55 <merijn> fmap: But naturals are still a bit useless, no comparison/arithmetic yet
15:05:03 <merijn> ParahSail1n: Not all libraries support it yet
15:05:19 <fmap> merijn: yeah, that's what I noticed
15:05:36 <merijn> fmap: They'll be in 7.8, together with holes, afaik
15:06:05 <fmap> ParahSail1n: the major drawback for me so far is a habit to install things from github directly :]
15:06:20 <cebewee> aavogt: We use QuickCheck to test student's code and provide them with immediate feedback, so the expected exceptions are pattern match failures and use of undefined
15:06:49 <cebewee> (I like the spoon/teaspoon naming :))
15:07:47 * hackagebot RANSAC 0.1.0.0 - The RANSAC algorithm for parameter estimation.  http://hackage.haskell.org/package/RANSAC-0.1.0.0 (AnthonyCowley)
15:08:27 <aavogt> cebewee: it might be worth to copy what lambdabot/mueval do, so that you don't have issues with non-terminating code that is possible to write
15:09:06 <c_wraith> well.  just use mueval, rather than copy it
15:09:58 <ion> % mueval -e 'let unsafeCoerce v = z where z :: v; z = v where aux = const v in (unsafeCoerce (putStrLn "evil IO") :: () -> ()) ()'
15:10:01 <ion> evil IO
15:11:16 <c_wraith> with ghc 6.12 or ghc head. :)
15:11:38 <elliott> or typechecking with 6.12 and running with 7
15:11:40 <elliott> like lambdabot
15:12:06 <ion> My mueval is built witn GHC 7.4.2
15:12:11 <cebewee> can mueval take whole programs, or just expressions?
15:12:40 <parcs`> expressions
15:13:15 <shachaf> ion: s/const/id/
15:13:47 <ParahSail1n> im having a hard time getting ghc to emit a popcnt instruction
15:14:05 <ParahSail1n> it's supposed to be a primop now right?
15:14:54 <shachaf> Even with popCnt#?
15:14:57 <acowley> ParahSail1n: yes
15:15:04 <acowley> ParahSail1n: What's not working?
15:15:10 <cebewee> than it is not very useful for us. our current process is to compile our testsuite, importing the student's submission as a module. Nontermination of the testsuite is dealt with by killing the program after n seconds
15:15:18 <ParahSail1n> shachaf: im using Data.Bits.popCount
15:15:26 <ParahSail1n> shachaf: does that not use popCnt#?
15:15:29 <acowley> yes
15:15:51 <ParahSail1n> @hoogle popCnt#
15:15:51 <lambdabot> No results found
15:16:06 <elliott> are you compiling with -O
15:16:06 <cebewee> (we probably should be using SafeHaskell to prevent the students from doing unsafe things, but we didn't get around to it, yet)
15:16:20 <acowley> See http://www.haskell.org/ghc/docs/latest/html/libraries/base-4.6.0.0/src/Data-Bits.html and search for "instance Bits Int"
15:16:22 <shachaf> ParahSail1n: I would assume that it does, but you could try popCnt# to be sure.
15:16:53 <parcs`> not many processors support popcnt
15:17:07 <cebewee> aavogt: Is spoon reasonable safe to use?
15:17:21 <ParahSail1n> parcs`: mine does
15:18:11 <acowley> ParahSail1n: how are you testing for use of the instruction?
15:18:12 <ParahSail1n> where is popCnt# imported from?
15:18:20 <ParahSail1n> acowley: objdump -d
15:18:35 <acowley> ParahSail1n: http://www.haskell.org/ghc/docs/latest/html/libraries/ghc-prim-0.3.0.0/GHC-PrimopWrappers.html
15:19:31 <acowley> ParahSail1n: Unfortunately, you soon bottom out searching for primop definitions.
15:19:58 <acowley> That was the best pun I've said or written in days.
15:22:22 <aavogt> cebewee: it does use unsafePerformIO so could be bad. I think the objections to it were that it's bad for reasoning about the language not that it makes programs crash or have security issues
15:23:21 <aavogt> then again there's subtle stuff like ion's mueval example
15:23:45 <aavogt> that might apply to spoon
15:25:03 <ParahSail1n> acowley: how do i make something into a Word# so i can test?
15:26:17 <acowley> ParahSail1n: I'm not sure. I'd start by copying from the Bits instance for Int that I linked to above.
15:27:51 <cebewee> I must admit that I don't understand ion's example.
15:29:26 <c_wraith> ion's example uses a bug in several versions of GHC, as well as detailed knowledge of the implementation of IO in GHC, to execute IO in a type that shouldn't allow it.
15:29:47 <c_wraith> The details aren't as important as the fact that it works
15:30:03 <ion> Detailed knowledge, a.k.a. “i wonder if it works if i just make it a function”
15:30:14 <ion> cebewee: http://hackage.haskell.org/trac/ghc/ticket/7453
15:30:37 <c_wraith> What, you didn't know that IO is just a function underneath? :)
15:31:05 <elliott> well, a function whose parameter is erased at compile-time
15:32:59 <Mikicacarica> http://goo.gl/Co19W
15:35:32 <ParahSail1n> heh, very difficult to just put a random Word# in the source
15:36:47 <cebewee> c_wraith: hehe, ok
15:37:32 <ion> c_wraith: Well, both must be something the CPU can jump to at some stage, and i knew the definition of the IO type, but i have no idea of what kinds of magic the compiler does with State# RealWorld and wouldn’t have been too surprised if coercing to () -> () didn’t work.
15:38:11 <ion> Also, some actions crash in the middle.
15:38:24 <ion> I guess when GC is triggered or something.
15:38:31 <c_wraith> yeah, that'd make sense.
15:38:47 <c_wraith> I mean, the coercion isn't *correct*, and it can certainly lead to crasehs.
15:38:49 <c_wraith> *crashes
15:38:55 <c_wraith> But it's close enough
15:39:54 <cmccann> close enough, sometimes crashes--you turned Haskell into a dynamic language :D
15:47:27 <hpaste> cebewee pasted “Use spoon to catch exceptions” at http://hpaste.org/78783
15:47:43 <cebewee> this is what I went with, now
15:48:17 <TheShamanoid> fucking hell, the more and more i use this language. The faster i fall in love with it.
15:48:37 <vreg> the break-up is hell though
15:48:43 <cebewee> (evaluation of p or q might trigger a pattern match or undefined exception)
15:49:00 <TheShamanoid> vreg: i can't see a reason that could lead to a break-up
15:49:44 <scooty-puff> i was trying to come up with an implementation of references (comparable to STRef, etc., if not in performance) that could be a transformer, in particular on []
15:50:03 <scooty-puff> what i came up with was a state monad containing a HashMap and Integer count of allocated references
15:50:19 <scooty-puff> however, i had to use unsafeCoerce (for HashMap Integer Any)
15:50:37 <scooty-puff> is there another way?  I could use Typeable, but i dislike that requirement
15:50:53 <c_wraith> The traditional approach is Data.Dynamic
15:50:54 <scooty-puff> (each Ref knows its type - Ref s String, Ref s Int, etc.)
15:51:09 <shachaf> There is vault
15:51:22 <scooty-puff> this would need to handle backtracking correctly
15:51:27 <elliott> vault is cool
15:51:34 <elliott> it sounds like what you want here too
15:51:37 <cmccann> scooty-puff, way to spoil everyone's fun by preempting jokes about fixing type errors with unsafeCoerce
15:51:39 <elliott> i am totally not biased
15:51:54 <cmccann> and yeah should probably look at vault
15:52:09 <Ralith> scooty-puff: rewrite it in a dependently typed language, of course.
15:52:34 <Mikicacarica> come here for free !!! >>> http://x.co/qCxH <<<<
15:52:35 <cmccann> Ralith, good advice
15:53:12 <scooty-puff> heh - such that i could ref :: Ref s typeOfRef -> HashMap.lookup (unwrapRef ref, typeOfRef) map
15:53:20 <shachaf> Just what I'm missing in life -- URLs that I can go to for free.
15:53:25 <scooty-puff> (baring the Typeable constraint)
15:53:30 <scooty-puff> *barring
15:54:00 <elliott> scooty-puff: yeah, just use a Vault
15:54:03 <elliott> instead of HashMap
15:54:16 <elliott> or Locker
15:54:23 <elliott> well
15:54:27 <elliott> I guess Locker wouldn't work, you need Vault
15:54:30 <scooty-puff> elliott, this will be over the ListT or LogicT monad - when it backtracks, the vault would need to as well
15:54:39 <scooty-puff> o, i see
15:54:39 <scooty-puff> nm
15:54:43 <scooty-puff> makes sense now
15:54:47 <scooty-puff> guess i should read documentation..
15:55:06 * cmccann muses whether broken links where the server drops requests are free urls, in that they qualify as urls but provide no further structure or content
15:58:16 <scooty-puff> looks like Vault is a wrapper around HashMap Unique Any as well .. though somehow inferred as safe
15:58:58 <elliott> scooty-puff: well yes, you have to implement it lik ethat
15:59:00 <elliott> but the API is safe
15:59:03 <scooty-puff> k
15:59:10 <elliott> and there is a portable implementation in terms of unsafePerformIO too
15:59:34 <shachaf> How portable!
15:59:46 <donri> scooty-puff: vault on hackage was built with an older haddock that i think had a bug with safe-inference
15:59:50 <elliott> shachaf: it's in the standard
16:03:19 <donri> i want an Ord instance for HashSet, is that stupid? :(
16:15:33 <augur> can anyone explain Bob Harper's anti-monad position?
16:16:52 <cmccann> my impression was "he has a bruised ego because nobody cares about SML anymore"
16:17:07 <cmccann> that's probably not what you're looking for though
16:19:34 <tomeo> Is it possible to start GHCI in Haskell 98-mode?
16:19:35 <c_wraith> augur: did you look at the answers to that exact question on reddit?
16:20:03 <augur> c_wraith: im not sure which you're talking about
16:20:45 <c_wraith> augur: http://www.reddit.com/r/haskell/comments/1499nq/robert_harper_exceptions_are_shared_secrets_a/c7azsjg
16:21:30 * cmccann stopped trying to read anything on harper's blog a while ago
16:21:49 <cmccann> he's smart and educated enough to full well why some of what he says is basically bullshit
16:21:55 <augur> c_wraith: ill give it a look!
16:22:10 <elliott> cmccann: his blog has some interesting posts
16:22:13 <elliott> just ignore all the ones that mention haskell
16:22:23 <cmccann> yes
16:22:25 <b_jonas> ooh
16:22:31 <cmccann> but his remarks on haskell make me distrust the rest of it
16:22:52 <c_wraith> cmccann: sometimes he admits it.  He's made remarks in the past that sound like "see? sml can do everything haskell can. Pity about how bad the syntax is for this particular thing, though."
16:22:53 <cmccann> and I don't feel like investing the effort to pick through it and figure out where he's being intellectually dishonest or not
16:23:07 <tomeo> Ambiguous interface for `Prelude': it was found in multiple packages: base haskell98-2.0.0.1"
16:23:24 <c_wraith> tomeo: if you're using haskell98, you'll need to -hide-package base
16:23:25 <tomeo> I get that when I try to run ghci -package haskell98
16:23:41 <c_wraith> also, use -XHaskell98
16:23:59 <c_wraith> to disable all the extensions that default to enabled that aren't H98
16:24:08 <tomeo> c_wraith: is that on top of -package and -hide-package?
16:24:13 <c_wraith> yes
16:24:35 <tomeo> thanks c_wraith
16:27:24 <tomeo> chars 0 = return [] isn't that EQ with just chars 0 = [] or can the return have a special meaning?
16:27:39 <c_wraith> return is a function
16:27:41 <c_wraith> :t return
16:27:42 <lambdabot> Monad m => a -> m a
16:27:49 <tomeo> ah okay thanks
16:28:01 <c_wraith> it's..  not the best name, necessarily, because it can be confusing.
16:28:09 <tomeo> it got me at least :)
16:29:08 <cmccann> so, what do people use these days to turn Haskell code into horrendous javascript abominations?
16:29:13 <Peaker> cmccann, c_wraith I think Harper never really seriously tried using Haskell, never learned how to compose IO actions, monad stacks, etc, and so he has this preconception that effects in Haskell are very hard
16:29:47 <donri> cmccann: fay is probably easiest to get started with
16:29:57 <cmccann> Peaker, to be honest I really don't care what his preconceived notions are and how he got them. he should know better.
16:30:06 <donri> but ghcjs is more promising in the long term
16:30:07 <Peaker> but I do think he has a point about laziness -- I think explicit and typed suspended computations (explicit laziness) *could* possibly be better than what Haskell does now.. though without trying, I don't know for sure
16:30:20 <c_wraith> he definitely writes like someone who has never used haskell to write software.
16:30:44 <c_wraith> Not just write a program, but something to be maintained and extended over a period of months or years.
16:30:45 <Peaker> (perhaps laziness could be implicit at the value-level and explicit at the type-level, or such)
16:30:57 <Peaker> c_wraith, yeah, and lots of bitterness is sensed as well :)
16:31:03 <cmccann> to be honest he sounds like someone who's never used any functional language to write actual software
16:31:15 <c_wraith> I'm sure he used sml to write sml :)
16:31:34 <cmccann> that was my initial impression so it was kind of a wtf moment when I realized his role in SML
16:31:47 <Peaker> cmccann, nah, his excellent post about Boolean blindness and some thoughts about verifiable software via dependent types indicate he's well versed
16:31:56 <cmccann> yes, I realized that later
16:32:11 <cmccann> but that was after exhausting my patience
16:32:12 <elliott> cmccann: well SML is very far away from Haskell on the functional spectrum
16:32:14 <madjestic13> hey guys, I am having issues setting up ghc-mod for vim.  Can sombody, please, help with .vimrc configuration?
16:33:02 <cmccann> elliott, and also on the "actually used for anything" spectrum, coincidentally
16:33:26 <mm21> madjestic13: what's the problem?
16:34:12 <elliott> cmccann: Haskell proponents shouldn't make fun of other languages' popularity :P
16:35:02 <augur> c_wraith: i still dont understand :\
16:35:30 <madjestic13> mm21: I had to use cabal-dev to install it.  It compiled, but I think something is missing.  Could you check what's inside .vimrc, concerning ghcmod?
16:36:15 <madjestic13> mm21: basically I do not get any expected :GhcModType and other commands
16:37:29 <c_wraith> augur: more or less, he thinks that typed effects get in the way of doing any kind of refactoring, and that the existence of unsafePerformIO indicates that they're useless anyway.
16:37:46 <mm21> madjestic13: https://github.com/justnothing/.vim
16:38:08 <cmccann> anyway, on a more useful note... donri, I was looking at fay and it does sound pretty easy to pick up and run with
16:38:27 <mm21> madjestic13: look at the PATH and vimproc
16:38:54 <cmccann> my main concern is how inefficient the code fay generates might be, since it looks like it sticks to vaguely readable javascript output and doesn't do much optimizing, if any?
16:39:20 <cmccann> not that js is a high-performance language at the best of times anyway
16:39:35 <donri> cmccann: it's pretty limited though, but useful for basic sharing of types between js and hs and for type checking some simple jquery code and the likes
16:39:56 <startling> isn't fay made to be used with google's js optimizer, or am I thinking of something else?
16:40:18 <luite> closure compiler really cannot do much optimization
16:40:37 <cmccann> donri, I'd like something to tinker with that's neither a huge hassle to work with nor too limited to use for anything serious in the future
16:40:39 <luite> most of what it does would probably already be done by the js engine itself
16:40:49 <donri> cmccann: yea, ghcjs makes use of ghc optimizations and hoopl and stuff i think, but it's currently a pain to set up
16:40:58 <cmccann> fay seems like a nice compromise leaning to the "easy to tinker with" side
16:41:46 <c_wraith> fay still doesn't support classes, right? That seems like the biggest downside.
16:42:17 <c_wraith> Though it's still being rapidly developed
16:42:17 <donri> classes is a big'un, but since it doesn't compile from core it'll always be playing catch-up with ghc ...
16:42:39 <c_wraith> I wouldn't be surprised if Fay does support classes early next year.
16:42:53 <cmccann> I suppose another benefit of fay is that since it starts with something that's nearly Haskell it'd be easy to switch to something like ghcjs later
16:42:54 <donri> i would, since it means implementing a type checker :)
16:43:10 <c_wraith> It can't still use GHC as the type checker for classes?
16:43:11 <donri> haskell-type-exts might make it easier though
16:43:12 <luite> hm, yeah, type classes are not a nice incremental feature like most of the development :)
16:43:31 <aheller> Peaker: presuming for a minute that the code you were going to write with call/cc was typable to begin with, I really just meant it's worth playing around with an actually first-class call/cc, especially when you have implicit state, in order to get the thing into one's fingers a little better.
16:43:42 <startling> donri: why does implementing typeclasses require a typechecker?
16:43:55 <elliott> because they are about types
16:43:56 <cmccann> startling, how else would you choose instances without type annotations?
16:43:58 <luite> startling: typeclass constraints need to be converted to implicit arguments
16:44:10 <c_wraith> Hmm.  Right.
16:44:24 <aheller> shapr: had a problem with a segfault and ended up dropping by.
16:44:25 <cebewee> cmccann: there are still a very few larger projects using SML, Isabelle for instance
16:44:26 <startling> isn't that just, like, type reflection?
16:44:29 <ParahSailin> i can't get ghc to compile the simple program "main = putStrLn $ show (I# (word2Int# (popCnt# (int2Word# 12335#))))" to omit a sse4.2 popcnt instruction
16:44:32 <c_wraith> Hence the comment about working from GHC core
16:44:41 <startling> c_wraith: ah
16:44:44 <c_wraith> if it did that, it would get a lot more for free
16:44:51 <c_wraith> But that'd also be a pretty big rewrite
16:45:02 <cmccann> yeah, I was actually wondering why compiling from core isn't a thing
16:45:09 <luite> cmccann: it is!
16:45:12 <luite> well, from stg
16:45:38 <luite> but that's basically core
16:46:00 <donri> it's what ghcjs does innit
16:46:05 <cmccann> oh, is it?
16:46:36 <luite> yeah
16:47:32 <Peaker> aheller, I've never toyed with Scheme's call/cc. Just callCC
16:49:34 <shachaf> ParahSailin: Try -msse4.2
16:49:59 <ParahSailin> shachaf, that was in there
16:50:11 <shachaf> Works for me.
16:50:24 <shachaf>         popcnt %rax,%r14
16:50:25 <Fuuzetsu> worksonmymachine.png
16:50:44 <ParahSailin> shachaf, ghc version?
16:50:52 <shachaf> 7.{6,4}.1
16:51:16 <aheller> Peaker: Ah.  Apropos of SML, smlnj also has a call/cc, though I haven't ever bothered.  But it might be approximately fair to say that having a real call/cc is different from Cont the way being able to do printf debugging anywhere in your code is different from IO.
16:51:42 <shachaf> shachaf@carbon:~/ie$ echo 'import Data.Bits; main = print $ popCount (5::Int)' > ie.hs && ghc-core ie.hs -msse4.2 | grep popcnt popcnt %rax,%r14
16:51:48 <Peaker> aheller, well, Oleg wrote about how undelimited continuations are a terrible idea
16:51:53 <Peaker> aheller, and made convincing arguments
16:52:00 <aheller> Peaker: so?
16:52:11 <hpc> it was something like
16:52:22 <aheller> Peaker: Oleg's pretty powerful, but I don't know that he's figured out how to go back in time and un-write r5rs.
16:52:25 <hpc> laziness plus purity plus continuations everywhere = suddenly impure again
16:52:42 <Fuuzetsu> aheller: yet
16:52:56 <aheller> Fuuzetsu: well, obviously.
16:52:57 <Peaker> aheller, so it sounds like throwing completely free call/cc just anywhere is much like having the IO monad everywhere, a bad idea :)
16:53:38 <aheller> Peaker: And yet ever so essential to an implementation of r5.
16:54:25 <luite> btw if anyone knows what kind of stack frames GHC uses for StgLetNoEscape things please tell me :p
16:54:39 <cmccann> aheller, oleg only uses delimited time travel for more expressive modes of retrocausality
16:55:21 <aheller> cmccann: there's some kind of joke about time travel, one-shot continuations, and a grassy knoll, but I can't quite put it together right now...
16:56:42 <cmccann> aheller, so grab the current continuation and call it with the joke when you come up with it later?
16:57:01 <haskell_padawan> Hi guys, what would be the signature type for something like:  [functions] value -> [Integer]
16:57:08 <aheller> cmccann: I'm not supposed to use bad language...
16:57:14 <cmccann> heh
16:58:42 * cmccann concludes that fay is probably a good place to start for now
16:59:13 <Fuuzetsu> haskell_padawan: [(a -> Integer)] -> a -> Integer
16:59:16 <Fuuzetsu> I believe
16:59:23 <typoclass> haskell_padawan: hello. i'm not sure what you mean. [X] in haskell usually indicates a list that contains a number of X's, for example, [Int] or [String]
16:59:25 <Fuuzetsu> oops
16:59:34 <shachaf> Instead of playing mind-reader we should ask for clarification.
16:59:35 <Fuuzetsu> haskell_padawan: [(a -> Integer)] -> a -> [Integer]
16:59:40 <Taslem> haskell_padawan: Could you give an example of something with the type?
17:00:11 <haskell_padawan> i'm defining a function that will take a list of functions and a integer, then the result will be a list of  integers. I'm pretty much going to map it.
17:00:22 <shachaf> haskell_padawan: What's the type of the functions?
17:00:37 <haskell_padawan> the type of functions will be Integer
17:00:49 <Taslem> haskell_padawan: That's not a function type. Numbers aren't functions.
17:01:04 <shachaf> haskell_padawan: You should give a concrete example of something that has that type.
17:01:05 <Peaker> @type sequence [(*2), (/4)]
17:01:06 <lambdabot> Fractional a => a -> [a]
17:01:13 <haskell_padawan> well functionsn like (+2) or (*3)
17:01:27 <Taslem> haskell_padawan: Those are of type Int -> Int (or some other number type)
17:01:42 <Taslem> haskell_padawan: The (->) is important. It's the difference between a function and something else.
17:02:07 <haskell_padawan> example: mappit [(+1), (+2), (+3)] 3    will result in [4, 5, 6]
17:02:28 <Peaker> haskell_padawan, so:  mappit :: [(a -> Integer)] -> a -> [Integer]
17:02:45 <Taslem> You could be more general and replace Integer with variables, too.
17:03:03 <shachaf> One step at a time, Taslem.
17:03:12 <shachaf> First learn how types work before generalizing them. :-)
17:03:27 <haskell_padawan> well i think reals should be accepted
17:03:37 <haskell_padawan> so probably generalizing it would be good
17:03:59 <Taslem> Types can include type variables. Variables that take the place of types.
17:04:00 <haskell_padawan> however i'm not sure how to do that?
17:04:02 <shachaf> I refuse to accept the reals.
17:04:06 <Taslem> So, that's the sort of thing you can do.
17:04:14 <Taslem> mappit :: [(a -> b)] -> a -> [b]
17:04:56 <c_wraith> shachaf: sane policy.
17:05:17 <gatts> read
17:05:34 <gatts> in the site that this channel can help us with our doubts
17:06:00 <haskell_padawan> i can't seem to grasp mappit :: [(a -> b)] -> a -> [b]     does that mean the a's are the same type and the b's are the same type too?
17:06:02 <cmccann> shachaf, you don't like toRational? :]
17:06:04 <Fuuzetsu> gatts: yes
17:06:11 <c_wraith> haskell_padawan: that's exactly what it means
17:06:16 <shachaf> cmccann: Who said anything about Real?
17:06:26 <c_wraith> haskell_padawan: a and b stand for the same type throughout the type signature, but it doesn't matter what type
17:06:40 <aheller> cmccann: shachaf rejects precisely those reals about which he is clearly speaking :).
17:06:58 <Peaker> haskell_padawan, you can set: a=Integer,  b=Char,   for example
17:06:59 <gatts> if i compile the .hs file i need to define the main, but if i use GHCi i don't need to, why does it happen?
17:07:03 <c_wraith> haskell_padawan: everything that is marked with an a is the same thing as ever other a.  Everything that's marked with a b is the same as every other b
17:07:08 <Peaker> haskell_padawan, but all the a's have to be equal, and all the b's have to be equal
17:07:15 <haskell_padawan> mappit :: [(String -> Integer)] -> String -> [Integer]     <--- would that be a more "strict" signature?
17:07:28 * cmccann is fine with computable reals
17:07:30 <Peaker> haskell_padawan, less general signature, yeah
17:07:41 <augur> c_wraith: DOES it get in the way of refactoring?
17:08:37 <ParahSailin> @ty \x y -> zipWith ($) x $ repeat y
17:08:38 <lambdabot> [b -> c] -> b -> [c]
17:08:43 <Fuuzetsu> gatts: because ghci doesn't run your program
17:09:07 <Taslem> @pl f x y = map ($y) x
17:09:07 <hpc> @let flip' fs x = fmap ($ x) fs
17:09:07 <lambdabot> f = flip (map . flip id)
17:09:10 <lambdabot>  Defined.
17:09:11 <c_wraith> ParahSailin: I'd have done it with map instead - zipwith is just map with two arguments
17:09:17 <hpc> :t flip :: [b -> c] -> b -> [c]
17:09:18 <lambdabot>     Couldn't match expected type `[b -> c]'
17:09:18 <lambdabot>                 with actual type `a0 -> b0 -> c0'
17:09:18 <lambdabot>     Expected type: [b -> c] -> b -> [c]
17:09:20 <Peaker> @ty \x y -> sequence x y
17:09:22 <lambdabot> [t -> a] -> t -> [a]
17:09:25 <hpc> aw
17:09:28 <gatts> Fuuzetsu interpreter?
17:09:32 <hpc> :t flip'
17:09:33 <SingingBoyo> I want to have objects with components that respond to arbitrary messages of unknown types and ignore unknown messages.  Stuck on the type system though.  is this even possible?
17:09:34 <lambdabot> Functor f => f (a -> b) -> a -> f b
17:09:35 <Taslem> @ty flip (map . flip id)
17:09:37 <lambdabot> [a -> b] -> a -> [b]
17:09:53 <hpc> :t flip' :: [b -> c] -> b -> [c]
17:09:54 <lambdabot> [b -> c] -> b -> [c]
17:10:10 <c_wraith> augur: In some senses. You can't change your implementation to involve throwing and catching exceptions without IO getting involved, for instance. (That's apparently something people like to to in ML)
17:10:12 <Taslem> SingingBoyo: Could you give a specific example of a usage? (ie, functions, how you want to call them)
17:10:38 <ParahSailin> @src flip'
17:10:38 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
17:10:54 <gatts> Fuuzetsu could you be more specific?
17:11:05 <c_wraith> augur: but the thing is, the cases he mentions seem *really* contrived to haskell programmers. Except the ones that use ST
17:11:33 <hpc> ParahSailin: @let above
17:11:51 <SingingBoyo> something like 'handleEvent object (ChangeX byAmount)' and also 'handleEvent object (ChangeHealth amt)' where ChangeX and ChangeHealth are different types
17:12:21 <Fuuzetsu> Uhm... When you compile with GHC, you need the main function so that the program knows where to start. When you load the same file in GHCI, all you are doing is loading in the functions from it. It doesn't need main because it doesn't have to run as a standalone program.
17:12:25 <Fuuzetsu> I think.
17:12:41 <Taslem> SingingBoyo: In other words, handleEvent :: Object -> a -> Object
17:12:44 <Taslem> Yes?
17:12:51 <SingingBoyo> yeah, something like that
17:13:01 <Taslem> SingingBoyo: Do you know about typeclasses?
17:13:05 <SingingBoyo> yes
17:13:12 <Taslem> That's what you should probably use.
17:13:28 <Taslem> class EventHandler where handleEvent a :: Object -> a -> Object
17:13:57 <gatts> Fuuzetsu hmm, I got it!
17:14:05 <SingingBoyo> I'll give it a try again.  I did attempt it but the type system didn't agree with my definitions for handlers
17:15:36 <madjestic13> mm21 not exatcly following your suggestion, but I got it working
17:17:50 <gatts> Fuuzetsu one last thing, when it says that haskell have both compiled and interpreted implementations, how can i know which one i'm using? ok, i'm compiling it with ghc, but is this compilation process like c/c++ ones for instance?
17:18:15 <aheller> gatts: yes.
17:18:22 <Fuuzetsu> ^
17:19:04 <gatts> hmmm
17:23:12 <acowley> Geeze the cafe got hostile this evening.
17:24:19 <typoclass> acowley: linky link?
17:25:10 <SingingBoyo> I've tried again with the event pattern.  GHC gives me 'Couldn't match type `b' with `PositionCommand'
17:25:10 <SingingBoyo> '.  I think I need to tell it to accept all types somehow.
17:25:11 <acowley> typoclass: This thread, http://www.haskell.org/pipermail/haskell-cafe/2012-December/104987.html
17:25:47 <typoclass> acowley: thanks a lot
17:25:51 <SingingBoyo> the code I've got: http://pastebin.com/vtRT5AM0  error on line 13
17:25:54 <mauke> The paste vtRT5AM0 has been copied to http://hpaste.org/78786
17:33:34 <acowley> Does anyone have an expandable vector type build on top of Vector?
17:38:46 <lfairy> acowley: what do you intend to use it for? concat works just fine
17:44:50 <sw2wolf> [1 of 1] Compiling Main             ( Setup.hs, Setup.o )
17:44:51 <sw2wolf> Linking Setup ...  then i have to wait for a VERY long time (It is GHC-7.6 on freebsd)
17:45:39 <sw2wolf> it is running bootstrap.sh in cabal-install-1.16.0.2
17:46:04 <rwbarton> how much RAM do you have?
17:46:13 <sw2wolf> 1G
17:46:34 <c_wraith> that's not really enough for ld to link the object files ghc spits out
17:46:38 <c_wraith> You're getting a lot of swapping
17:46:45 <rwbarton> hmm, for just cabal-install I am a little surprised
17:47:06 <hpc> i vaguely remember compiling ghc 7.6.1 on this 1G laptop
17:47:12 <sw2wolf> i have to wait now :(
17:48:05 <typoclass> what is bootstrap.sh for? i thought ghc came with cabal these days?
17:48:13 <typoclass> (or am i mixing that up with the platform?)
17:48:33 <shachaf> Cabal /= cabal-install
17:48:34 <acowley> platform has cabal-install, ghc doesn't
17:48:36 <c_wraith> ghc comes with Cabal
17:48:45 <c_wraith> bootstrap.sh comes with cabal-install
17:48:48 <sw2wolf> I directly download GHC freebsd binary from haskell.org
17:50:41 <sw2wolf> it hasnot finished now ...
17:51:43 <rwbarton> I guess I haven't tried installing cabal-install specifically on any of my low-RAM VMs because they have Ubuntu with a recent haskell-platform
17:52:25 <sw2wolf> the GHC in FreeeBSD ports is too old
17:57:36 <JewZuckerberg> how to repeat holocaust?
17:57:46 <ParahSailin> rebuilt ghc, still no popcnt instruction
17:58:10 <shachaf> ParahSailin: What's the exact command you're running?
17:58:13 <JewZuckerberg> what is the instruction for holocaust
17:58:18 <shachaf> @where ops
17:58:18 <lambdabot> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
17:58:29 <JewZuckerberg> lol'd
17:58:33 --- mode: ChanServ set +o copumpkin
17:58:37 --- mode: copumpkin set +b *!~JohnMurde@119.186.244.189
17:58:37 --- kick: JewZuckerberg was kicked by copumpkin (bye)
17:58:39 --- mode: copumpkin set -o copumpkin
17:58:42 <ParahSailin> ~/ghc762/bin/ghc ie.hs -msse4.2
17:58:59 <shachaf> How are you looking at the result?
17:59:06 <ParahSailin> objdump -d
17:59:14 <shachaf> Try -ddump-asm?
18:00:02 <shachaf> Oh, wait.
18:00:15 <shachaf> You're not using optimizations. :-(
18:00:18 <shachaf> Someone asked about that before.
18:00:31 <c_wraith> all the good code is hidden in rewrite rules
18:01:14 <ParahSailin> shachaf, i just aped what you did
18:01:22 <shachaf> ParahSailin: ghc-core adds -O2 automatically.
18:01:29 <ParahSailin> what is ghc-core
18:01:47 <shachaf> A program that dumps GHC generated code into a pager.
18:01:52 <shachaf> You didn't use ghc-core, so it wasn't quite aping. :-)
18:01:57 <shachaf> With ghc you'll need -O2 or so
18:03:00 <ParahSailin> did ~/ghc762/bin/ghc ie.hs -msse4.2 -O2, still no popcnt
18:03:40 <shachaf> Did it actually compile?
18:03:47 <sw2wolf> shit "GHC linking" or shit "ld" :(
18:03:54 <shachaf> 17:58 <shachaf> Try -ddump-asm?
18:04:04 <ParahSailin> shachaf, it compiled
18:04:15 <shachaf> So you touched the file beteen runs of GHC?
18:04:23 <shachaf> Because the recompilation checker won't recompile when you just add -O2
18:04:53 <ParahSailin> i removed .o and .hi files
18:05:08 <shachaf> I guess that works.
18:05:24 <shachaf> And you used -ddump-asm?
18:05:55 <shachaf> shachaf@carbon:~/ie$ echo 'import Data.Bits; main = print $ popCount (5::Int)' > blah.hs && ghc blah.hs -O2 -msse4.2 -ddump-asm | grep popcnt
18:07:09 <dgpratt> Haskellers, if you wanted to better understand how a large-ish Haskell project works internally, what would be your approach?
18:07:13 <ParahSailin> shachaf, nada
18:07:15 <elliott> I would read the code
18:07:35 <dgpratt> elliott: I had a feeling that would be a popular answer :)
18:07:37 <cmccann> elliott, what madness is this
18:07:40 <cmccann> reading code?
18:07:41 <cmccann> D:
18:07:45 <typoclass> dgpratt: profiling? Debug.Trace and reading the logs?
18:08:09 <rwbarton> there's that thing. sourcegraph? sourcealyzer? something
18:08:12 * cmccann recommends making changes you don't understand, breaking it horribly, and then trying to fix it
18:08:20 <cmccann> by the time it works again you should understand it decently
18:08:27 <dgpratt> cmccann: :)
18:08:47 <typoclass> dgpratt: or strace, if you're concerned with things like "what files does the program look at"
18:09:50 <ParahSailin> shachaf, actually, -ddump-asm doesnt seem to generate output at all
18:10:00 <shachaf> ParahSailin: Are you sure you're actually compiling the file?
18:10:40 <ParahSailin> ok now i see a popcnt
18:10:59 * shachaf sighs.
18:11:01 <ParahSailin> why don't i see popcnt instruction in the compiled binary?
18:11:45 <edwardk> dgpratt: my way of understanding a topic or project is to take something that is central to the theory of it, and rip it out, and try to see how much of the surrounding topic can be derived in that more limited context. this forces me to work through all of the derivations in the topic or project from first principles
18:11:59 <shachaf> ParahSailin: I see it.
18:12:09 <shachaf> But I have to use objdump -D, because -d doesn't find the code as code.
18:12:13 <luite> ParahSailin: hm, dos your disassembler support these instructions?
18:12:18 <luite> does
18:12:22 <sw2wolf> What is the canconical way to share modules among haskell projects ? Suppose, there are three projects called A, B and C. The modules in C will be used in A and B. It seems there is no java CLASSPATH like thing in haskell. then Does both A and B need to import modules in C using absolue path ?
18:12:26 <shachaf> (Your clue is that the disassembly doesn't actually contain *any* code.)
18:12:35 <edwardk> this sadly winds up with me reimplementing pretty much everything i encounter though
18:12:42 <SingingBoyo> is it possible to have a function f :: TypeX -> a -> TypeX and pattern match on specific data constructors for the second parameter?  GHC says it can't match with the rigid type variable a
18:12:49 <dgpratt> edwardk: interesting idea
18:12:49 <ParahSailin> oh, objdump -D works whereas objdump -d was not
18:13:02 <shachaf> SingingBoyo: If a is polymorphic, you can't pattern match on it.
18:13:16 <edwardk> SingingBoyo: the absence of such functions is one of the features of parametricity
18:13:28 <dgpratt> edwardk: and based on how prolific you are, it must be a pretty effective technique :)
18:13:30 <edwardk> SingingBoyo: you can use a 'Data' constraint on 'a' to enable case analysis though
18:13:36 <rwbarton> the _info things are code?
18:13:46 <shachaf> Yep.
18:13:59 <shachaf> A bit of an odd name for code.
18:14:33 <rwbarton> how does objdump decide whether it should be code? some kind of symbol table entry type?
18:14:40 <sw2wolf> thanks for any suggestion , guys
18:14:47 <edwardk> SingingBoyo: the difference from, say, haskell and java in this regard is that in java any function is empowered to do typecase. in haskell you are empowered not to have to worry about arbitrary functions doing it without telling you.
18:14:56 <shachaf> "This option only disassembles those sections which are expected to contain instructions."
18:15:03 <shachaf> I'm not sure what its heuristic is.
18:15:16 <haskell_padawan> how do you apply a value to a function for example:  I have the value 3 and want apply it "square" which i defined. Is using map the only way to do it?
18:15:58 <shachaf> You apply a function to a value, not a value to a function.
18:16:09 <shachaf> And you don't need "map" -- just write them next to each other.
18:16:15 * cmccann applies directly to forehead
18:16:17 <typoclass> > pred 7 -- haskell_padawan, this applies a function 'pred' to the value 7. it's not a very interesting function, but it's just an example
18:16:19 <lambdabot>   6
18:16:34 <nushio3> flip ($) 3 sqrt
18:16:45 <nushio3> maybe this will do for you? > haskell_padawan
18:16:57 <shachaf> Thanks for clearing things up, nushio3.
18:17:25 <nushio3> welcome:)
18:17:32 <SingingBoyo> edwardk: Guess I've jumped into a scala-ism then, where you can pattern match an Object to any type.  What's the 'haskell-ish' way to have an event-handler kind of system to handle events of arbitrary types?
18:18:24 <shachaf> First figure out the behavior you want your events to have, then pass that in instead of "something of arbitrary type".
18:18:27 <hpc> SingingBoyo: define the operations on an event, then do something like
18:18:32 <hpc> data Event = Event {
18:18:39 <edwardk> SingingBoyo: there are a number of ways. you might define something like data Observer a = Observer   { (!)      :: a -> Task (), complete :: Task ()  }
18:18:45 <hpc>   refire :: IO (),
18:18:48 <edwardk> and then register the Observer with each Observable
18:18:51 <hpc>   forward :: Handler -> IO (),
18:18:52 <hpc>   ...
18:19:05 <edwardk> newtype Observable a = Observable { subscribe :: Observer a -> Task Subscription }
18:19:14 <edwardk> (where Subscription is a way to cut off listening)
18:19:20 <hpc> basically javascript-style OO instead of java-style
18:19:36 <edwardk> you can actually then show you can build a monad for Observable, etc. and do lots of interesting things
18:19:36 <hpc> (modulo inheritance and other yuck)
18:19:49 <haskell_padawan> typoclass thanksi'll try that
18:19:59 <edwardk> notice that i never had to magic up any type discrimination in that
18:20:07 <xenocons> forget who i was speaking to here the other day, but they suggested when translating C-> haskell, if you can change the C to make translating easier (i.e. remove state as much you can) it will be easier, +10 internet points to that person
18:20:14 <edwardk> (and Task is probably something IO-like)
18:20:38 <xenocons> haven't succeeded c->haskell yet, but ive done C-> Functional F#, so next step is F# -> Haskell :)
18:21:06 <hpc> xenocons: oddly, that second step could easily be harder than the first
18:21:06 <edwardk> then once you've built up your Observable, you can just subscribe to it with an event handler
18:21:18 <hpc> what with haskell not having .NET
18:21:27 <acowley> I was feeling lucky that ld wasn't slamming my system… eventually noticed I wasn't linking the executable I'd been testing the past 15 minutes.
18:21:38 <edwardk> acowley: =)
18:21:59 <acowley> I did almost the same exact thing the other day
18:22:10 <xenocons> hpc: well, hard part was removing state, im hoping that F#->Haskell will be easier, i am F# knowing, but haskell is newish to me
18:22:11 <acowley> It's when I'm testing a main in a module not named Main
18:22:18 <acowley> I forget the -main-is flag, and end up running the old exe
18:24:30 <xenocons> hpc: breaking it down into individual functions that do one thing that can be soley independant of each other was my first step
18:24:52 <xenocons> now that i have that, im going to refactor a bit more because im OCD ;) then move it to haskell
18:25:33 <SingingBoyo> edwardk: I think I understand what you mean.  My problem with that is that I want to have a general datatype that has arbitrary Observables depending on what 'components' it needs.  I can't think of a good way to access individual components or 'send' them events.
18:25:59 * lispy tries out eclipseFP again
18:26:05 <SingingBoyo> edwardk: The Observable pattern seems good, but if events have arbitrary data contained in them, I don't see how I can fit it in.
18:26:16 <lispy> It really takes a long time to build all the deps for eclipseFP
18:26:31 <acowley> edwardk: re the linear issue I opened the other day, do you want me to add the fixed-vector instances?
18:26:46 <nushio3> cast :: (Typeable a, Typeable b) => a -> Maybe b
18:26:58 <nushio3> use cast, to convert it to your favorite type?
18:27:11 <edwardk> SingingBoyo: well, my main recommendation is to avoid building a general event dispatch mechanism. you can of course build something up like it with Data, you may want to look a Control.Exception for how they do it, but again i don't recommend the technique it tends to build complicated code with ugly type errors
18:27:14 <edwardk> acowley: going to check
18:27:41 <parcs`> nushio3: you use cast to convert an existential type to a concrete type
18:27:53 <shachaf> parcs`: ?
18:28:00 <shachaf> What's existential here?
18:28:25 <nushio3> this is 'cast' from Data.Typeable.
18:29:10 <SingingBoyo> edwardk:  What would be a good way to have objects to which I can add components depending on what they actually need?  I suppose I could have data Object = Object (Maybe CompA) (Maybe compB)  etc., but that seems even worse.
18:29:11 <parcs`> shachaf: if you have an existential 'forall a. Typeable a => SomeType a' and you want to get a concrete type out of it you can use cast
18:29:22 <edwardk> i'm kinda torn on the fixed-vector addition because i really just don't like their api
18:29:31 <parcs`> shachaf: i dunno of any other use case
18:29:46 <edwardk> i'd almost as soon do it 'right' ourself or leave it to a separate package
18:30:08 <shachaf> parcs`: Instead of forall a. Typeable a => SomeType a you can just use Dynamic. Most uses of cast aren't for that, I think.
18:30:35 <edwardk> and its limited in scope to the instances they provide that are fully boxed anyways
18:30:53 <parcs`> shachaf: so what's cast for, then?
18:31:10 <nushio3> oh, I remembered correctly. What I used was fromDynamic, not cast
18:31:16 <nushio3> from Data.Dynamic
18:31:35 <nushio3> fromDynamic:: Typeable a => Dynamic -> Maybe a
18:31:35 <edwardk> SingingBoyo: i think the impedence mismatch we're having is that we're coming at this from different perspectives
18:31:38 <nushio3> i'm sorry.
18:31:40 <rwbarton> shachaf: apparently the symbol Main_main2_info is marked as a "data object" in the symbol table rather than a "function"
18:31:59 <shachaf> rwbarton: Aha.
18:32:04 <rwbarton> why that is, no idea
18:32:10 <shachaf> I guess that's a sort of bug, unless it's intentional somehow?
18:32:20 <rwbarton> objects in the text section seems odd
18:32:29 <edwardk> for me i take a bunch of individual widgets that each may offer up observable events, i wire those events together, expose some new composite events and package it up in a new data type and maybe give you access to the parts i used to compose the whole thing, and maybe not
18:32:42 <acowley> edwardk: Okay. I almost had a use for a length-typed vector the other day which is why I wrote that instance package.
18:32:43 <shachaf> rwbarton: _closure goes int he text section, right?
18:33:03 <edwardk> the data type holds a bunch of events, maybe some random fixed data, and those form its API.
18:33:06 <rwbarton> but I would be inclined to reserve judgment given that it is ghc
18:33:06 <acowley> edwardk: It was neat in that you gave a function like (v a -> b), and I used the arity of the vector to do some sampling
18:33:09 <shachaf> Or, rather, no.
18:33:12 <rwbarton> and there may well be some good reason
18:33:35 <rwbarton> I don't know what _closure is exactly but I see it is in the .data section (and also the symbol size is 0?)
18:33:47 <rwbarton> unless this unlabeled field isn't the symbol size
18:34:02 <shachaf> Oh, you're right.
18:34:16 * shachaf always skipped over the .data and .text while reading generated code.
18:34:34 <edwardk> SingingBoyo: this is done for each component though, so there isn't a huge composite 'everything must fit the same general framework' -style one-true type that everything must fit into.
18:34:47 <edwardk> the data type is just a convenience for holding onto all of the events
18:35:08 <rwbarton> objdump -d --objects-are-functions-too
18:35:33 <shachaf> objdump -D, also know as --everything-is-a-function
18:35:40 <shachaf> conal wouldn't like it.
18:35:43 <rwbarton> annoying with objdump -D you have no way to see where the code ends even though the symbol has the correct size for the code
18:35:59 <rwbarton> oh i see, this is the code for a value eh :)
18:36:09 <nushio3> [toDyn 1, toDyn "foo", toDyn 2, toDyn 2.5]
18:36:16 <shachaf> rwbarton: I usually prefer to look at the assembly before it gets assembled.
18:36:16 <nushio3> is [toDyn 1, toDyn "foo", toDyn 2, toDyn 2.5]
18:36:39 <nushio3> sorry, it shows like [<<Integer>>,<<[Char]>>,<<Integer>>,<<Double>>]
18:36:52 <nushio3> and by              catMaybes $ map fromDynamic [toDyn 1, toDyn "clickEvent", toDyn 2.5, toDyn "keyEvent"] :: [String]
18:37:01 <nushio3> you get         ["clickEvent","keyEvent"]
18:37:45 <nushio3> you can make your event datas of class Typeable , using -XDeriveDataTypeable
18:38:04 <SingingBoyo> edwardk: My problem is I don't know what all the events could be.  Or rather, don't feel like I should, since it couples everything too tightly for my liking.  so I can't wrap them into composites or into a single data type.  I suppose maybe I have to, but I'd prefer to avoid it.
18:38:21 <nushio3> so you can use the  "holding onto all of the events" container
18:38:42 <shachaf> nushio3: You're not really recommending Data.Dynamic for SingingBoyo's problem, are you?
18:38:57 <edwardk> SingingBoyo: without knowing more about your domain i can't really help much further. just remember the advice when you are neck deep in Data.Dynamic values. ;)
18:39:26 <nushio3> you can regard Dynamic from Data.Dynamic as a general , default container > SingingBoyo :)
18:40:17 <nushio3> shachaf: I'm not sure, cons- Dynamic is too generic. pros- But it's there for everyone's use, and extensive.
18:40:26 <SingingBoyo> nushio3: I decided not to use for this java/scala to avoid typecasting.  I don't think I want to jump back into it now.
18:40:41 <SingingBoyo> and Data.Dynamic is too close to it for my liking.
18:40:42 <nushio3> okay :)
18:42:03 <nushio3> By the way, may I ask for a suggestion:  any documents for instance inference in Haskell?
18:42:35 <nushio3> For example. printf in Text.Printf returns IO a, not IO () with mysterious return (error "PrintfType (IO a): result should not be used.")
18:43:04 <nushio3> This is because the instance inferencer cannot match (Monad m0 => m0 a) to (IO ()) .
18:43:42 <nushio3> I'd like to have a concrete reference and understanding for such inference mechanism, thanks.
18:45:15 <parcs`> :t printf "a" >> printf "b"
18:45:16 <lambdabot> (Monad m, PrintfType (m b), PrintfType (m a)) => m b
18:47:12 <adkron> Is an IRC server a good project for learning Haskell?
18:47:23 <nushio3> Thank you parcs, but I'm trying to design something like printf, rather than use it
18:47:47 <shachaf> If you want to figure out how printf works, you could probably just read the code.
18:47:58 <nushio3> adkron : I'm also trying to figure that out:)
18:48:14 <shachaf> It's relatively straightforward and Haskell 98 (they go to some trouble to keep it H98).
18:48:35 <parcs`> nushio3: that wasn't meant to be helpful :P printf probably returns 'IO a' because that's the only way printf can return an IO value without relying on language extensions
18:49:12 <nushio3> like that > parcs
18:49:20 <parcs`> it "should" return IO (), but that means having a 'PrintfType (IO ())' instance, which requires FlexibleInstances
18:49:23 <rwbarton> is printf Haskell 98? then that would explain it yeah
18:49:41 <shachaf> rwbarton: Yes, that's the reason for the IsChar business and all that.
18:49:49 <adkron> nushio3: I have two friends and we thought that might be a good step. We have all worked on chat servers in the past. The other two actually wrote on in Erlang.
18:50:01 <nushio3> https://github.com/nushio3/practice/tree/master/free-objects I did some code-reading and reproduction, then I realized that I need some concrete background...
18:50:03 <rwbarton> why can't it do IsUnit then
18:50:10 <rwbarton> or is the point that that is useless
18:50:47 <nushio3> PrintfType (IO ())  is surprisingly, useless, because you can't use that in IO monad. You can't instantiate that...
18:50:48 <shachaf> Hmm, I suppose it could do that.
18:50:55 <shachaf> There's not much point.
18:51:06 <akahn> I want to have a 'helper' function defined in a where block, but I want it to be available to all of the patterns of my function. is there a way to achieve that?
18:51:06 <nushio3> That was not language extention's fault.
18:51:30 <shachaf> akahn: Not really.
18:51:43 <shachaf> You can use case in your function, or define a second helper.
18:52:28 <akahn> thank you
18:53:06 <parcs`> > let
18:53:08 <lambdabot>   not an expression: `let'
18:53:15 <nushio3> Seems like Haskell 98 (or 2010) was after all what I was looking for. Thank you!
18:55:35 <shachaf> > 2 * 3 + 4
18:55:37 <lambdabot>   10
18:55:38 <shachaf> > 2 * do 3 + 4
18:55:39 <lambdabot>   14
18:55:42 <shachaf> Innovative!
18:55:44 <rwbarton> shachaf: handy
18:56:01 <rwbarton> for when you want $ but you have an operator
18:56:31 <shachaf> > (:[]) $ do 5 :: Int
18:56:32 <lambdabot>   [5]
18:56:39 <otters> that's handy
18:56:45 <otters> haskell golf?
18:56:46 <rwbarton> whoa
18:56:58 <nushio3> what monad is do 3+4?
18:57:07 <shachaf> No monad. It's just another way of saying 3 + 4
18:57:08 <otters> it's not
18:57:09 <rwbarton> @type ?f ?x :: Int
18:57:10 <lambdabot> (?f::t -> Int, ?x::t) => Int
18:57:14 <rwbarton> @type ?f $ do ?x :: Int
18:57:15 <lambdabot> (?f::Int -> t, ?x::Int) => t
18:57:33 <rwbarton> oh yeah I think I remember this.
18:57:43 <rwbarton> @type ?g $ do ?f $ do ?x :: Int :: String
18:57:44 <lambdabot> (?g::String -> t, ?f::Int -> String, ?x::Int) => t
18:57:51 <otters> > do do 3 + 4
18:57:52 <parcs`> nushio3: do 3+4 gets desugared to 3+4
18:57:52 <lambdabot>   7
18:57:54 <otters> :o
18:57:54 <shachaf> Oh, that's similar to cmccann's thing.
18:58:10 <rwbarton> mixing \ and ::?
18:58:16 <parcs`> nushio3: the Monad constraint comes naturally from the desugaring of do
18:58:17 <shachaf> > (\x -> \y -> x + y :: Int :: Int -> Int :: Int -> Int -> Int) 2 3
18:58:18 <rwbarton> I think that's what I'm remembering
18:58:19 <lambdabot>   5
18:58:29 <cmccann> shachaf, hahaha
18:58:38 <rwbarton> the "f $ do x :: t" thing is too tempting
18:58:50 <otters> I seriously have to do it now
18:58:54 <otters> I'm going to go back to my code and fix it
18:59:21 <cmccann> @quote cmccann (Int -> Int)
18:59:21 <lambdabot> cmccann says: :t \f -> \x -> f x :: Int :: (Int -> Int) :: (Int -> Int) -> Int -> Int
18:59:31 <nushio3> ha, unless there's newline in do notation, no (>>=) nor (>>) gets inserted, am I right? > parcs`
19:00:15 <nushio3> that's why  do 3+4 gets desugared to 3+4
19:00:54 <shachaf> Hmm, if "f do x" was valid syntax, we could dispose of $
19:01:20 <cmccann> shachaf, go suggest that as a GHC extension
19:01:23 <parcs`> nushio3: unless there's more than one statement in a do block
19:01:24 <cmccann> it will surely be well-received
19:01:50 <shachaf> cmccann: Why if "f case ..." and so on illegal, anyway?
19:01:58 <shachaf> s/if/is/
19:02:09 <cmccann> dunno. there might be a reason.
19:02:30 <rwbarton> it looks weird
19:02:30 <cmccann> the sort of thing that's not obvious until you try writing a parser
19:02:41 <cmccann> or maybe it's just illegal because it is!
19:02:41 <rwbarton> but maybe that is because i am used to the way it is now
19:03:33 <cmccann> rwbarton, it's not all that different from how if then else separate expressions
19:03:40 <rwbarton> hmm
19:03:49 <cmccann> on the other hand that also looks weird without syntax highlighting, to my eye
19:04:16 <cmccann> if I see alphanumeric tokens separated by whitespace I expect function application
19:04:18 <rwbarton> well I think it is sort of different, because here you have a function application which is normally (just about) the tightest-binding thing
19:04:35 <rwbarton> and then suddenly you allow this huge case or do expression to be its argument
19:05:15 <elliott> f Foo { ... } -- this is weird too
19:05:24 <nushio3> parcs`: Thank you for making it clear :)
19:05:26 <rwbarton> yeah
19:07:07 <hpaste> “C. McCann” pasted “this does look weird” at http://hpaste.org/78788
19:07:23 <cmccann> my brain does not like parsing that
19:07:33 <shachaf> cmccann: But with keywords it'll extend all the way to the right.
19:07:49 <shachaf> You know that keywords are special anyway. You have to treat them as such anywhere else.
19:07:52 <cmccann> shrug. would get used to it.
19:08:43 <cmccann> but I'm not a fan of syntax like that in general, including if/then/else as they are now
19:10:36 <parcs`> that's a cool idea
19:11:05 <shachaf> cmccann: The weirdest thing about that paste is the ∀x. x ⊢
19:11:22 <cmccann> hey, I like my GHCi prompt.
19:11:59 <parcs`> maybe just 'do' could get the special treatment, so that you can do 'f do x', 'f do case x of ...', 'f do if x then ..'
19:12:22 <shachaf> No, that's terrible.
19:12:33 <parcs`> more terribel than $?
19:14:37 <Peaker> I never understood why "do", "case", "if", etc are fine after infix ops but not as prefix args
19:14:37 <rwbarton> well ($) isn't a special case in the language spec (due to not being part of the language spec at all)
19:15:03 <Peaker> I think it's annoying to have to explain "$" to beginners just to use anonymous "do" blocks
19:15:24 <sw2wolf> rwbarton: ($) just make us use few (), right ?
19:15:45 <parcs`> ($) has problems of its own, like requiring a special case in order to typecheck runST $ return ... and such. also, ($) is visually noisy
19:15:46 <Peaker> sw2wolf, also allows use of keyword constructs as arguments to functions
19:16:23 <sw2wolf> Peaker: show us code ?
19:16:57 <Peaker> logger = forever do { msg <- getMVar msgs ; putStrLn msg }
19:17:01 <Peaker> is not allowed
19:17:04 <Peaker> logger = forever $ do { msg <- getMVar msgs ; putStrLn msg }
19:17:07 <sw2wolf> f1 (f2 ...) => f1 $ f2
19:17:08 <Peaker> is allowed
19:17:22 <Peaker> same with other keywords
19:17:48 <sw2wolf> Peaker: thx
19:17:54 <rwbarton> well the first looks like (forever do) {- stuff -}
19:18:08 <rwbarton> I guess this is where what cmccann said about if/then/else comes in
19:18:16 <cmccann> also, recall record syntax
19:18:20 <parcs`> i just checked and allowing 'f do' introduces no extra ambiguities to the grammar
19:18:22 <Peaker> rwbarton, that's nonsensical anyway...  and funnily, you can do:   foo bar { ... }    for record updates, and that looks like (foo bar) { ... }
19:18:26 <cmccann> where a { } block binds tighter than function application
19:18:37 <rwbarton> yes, and it's ugly/hard to read/counterintuitive
19:18:45 <cmccann> agreed
19:19:27 <parcs`> $ is pretty ugly, and i can't remember whether it's hard to read at first
19:19:32 <Peaker> rwbarton, it's fine if    forever do {  ... doesn't work.   But the indent rule could insert parens around the do block anyway
19:19:35 <rwbarton> I usually omit the space in record update to try to make it read a bit better
19:19:35 <cmccann> but allowing vaguely convenient, ugly and counterintuitive syntax with do &c. would be consistent with existing ugliness
19:20:14 <Peaker> rwbarton, I want:  forever do \n    indented stuff here          to work without the $
19:21:37 <rwbarton> cmccann, I think it's that if you have a string of "words"   foo bar baz ...   currently you only need to read the first to see if it is a keyword
19:22:06 <cmccann> true
19:22:26 <hpaste> lpvb pasted “struts not avoided” at http://hpaste.org/78789
19:22:27 <rwbarton> if I'm reading along foo bar baz and then suddenly do
19:22:31 <rwbarton> that's a bit different
19:22:37 <Peaker> rwbarton, we all read colored code though?
19:22:41 <cmccann> but personally I find that if expressions are painful to read without syntax highlighting and/or helpful whitespace
19:22:42 <lpvb> ^ anyone know whats wrong with my xmonad not avoiding struts?
19:22:42 <rwbarton> at least $ stands out visually
19:22:47 <Peaker> rwbarton, "do" is highlighted visually with color
19:22:49 <lpvb> it used to, and now it doesnt
19:22:57 <cmccann> and under similar circumstances, the use of do would also be readable or not
19:22:59 <rwbarton> Peaker: well write your editor that shows the parenless version for all I care :P
19:23:02 <Peaker> rwbarton, also, if it's based on parens-from-indent rule, then it's always the last word anyway
19:23:04 <Fuuzetsu> lpvb: ask in #xmonad ?
19:23:15 <Peaker> rwbarton, already on it :)
19:23:21 <lpvb> they take a while to respond :(  but okay
19:23:24 <Peaker> rwbarton, now doing nice UI for type variables :)
19:23:40 <akahn> how might I translate this type of memoization to haskell? https://github.com/akahn/duraflame/blob/master/lib/duraflame/user_lookup.rb#L9-L11 at first I thought I needed the state monad, but then reader was suggested, and then I realized there are tools specific for memoization. any direction would be appreciated
19:23:48 <rwbarton> often I put something on the same line as the do
19:24:04 <cmccann> Peaker, you should add support for using unicode fraktur letters!
19:24:04 <rwbarton> I don't know how common that is, don't really pay attention but I would guess pretty common?
19:24:26 <Peaker> akahn, do you want the memoization to happen behind the scenes (with unsafePerformIO?) or expose the statefulness?
19:24:57 <Peaker> cmccann, already have support for unicode names, though I will also support giving alternative names in various languages so I can use ascii and avoid people's unicode :)
19:25:01 <akahn> Peaker: I don't really know how to answer that question. whichever is better for a newcomer learning, I guess.
19:25:45 <cmccann> Peaker, but that's half the fun of unicode :[
19:25:45 <JoeyA> Is it okay to call a FunPtr from C code in a different thread on the non-threaded RTS?
19:25:50 <Peaker> akahn, what memoization happens in your example?
19:26:01 <Peaker> akahn, oh ||= ?
19:26:31 <akahn> Peaker: yes. each http request happens once per ID. on subsequent calls, the previously computed value is returned
19:26:47 <Peaker> akahn, well, you can write the (||=) operator for Map's
19:27:47 <Fuuzetsu> :t (||=)
19:27:48 <lambdabot> MonadState s m => SimpleSetting s Bool -> Bool -> m ()
19:27:56 <Peaker> akahn, (||=) :: Map k v -> f v -> f (Map k v)
19:28:17 <Peaker> akahn, (||=) :: Functor f => Map k v -> f v -> f (Map k v, v)
19:28:19 <parcs`> ah, but 'forever do do \n    block' doesn't parse, reporting 'Empty 'do' block'. it gets parsed as 'forever (do { do { } }) threadDelay 1000000'
19:28:57 <Peaker> akahn, or, you could make it nicer with StateT:   (||=) :: Functor f => f v -> StateT (Map k v) f v
19:31:11 <AlexBB> Hello there
19:31:32 <akahn> Peaker: StateT would have the advantage of not having to explicitly pass the map around all over the place?
19:31:37 <otters> > typeOf do 3 :: Int
19:31:39 <lambdabot>   <hint>:1:8: parse error on input `do'
19:33:05 <Peaker> akahn, yeah, but the users will still have to also use StateT to ut it
19:33:07 * hackagebot elf 0.27 - Parser for ELF object format.  http://hackage.haskell.org/package/elf-0.27 (ErikCharlebois)
19:33:09 <Peaker> akahn, to use it, that is
19:33:28 <akahn> I'm the only user in this case
19:34:06 <akahn> I guess I should start by making a function that takes a map and a user_id, makes the http request, and returns the map with the new user added
19:34:22 <Peaker> akahn, I think you can directly write that StateT combinator
19:34:27 <Peaker> akahn, no need to break it up
19:34:42 <akahn> not sure I follow -- no need to break what up?
19:34:50 <Peaker> the operator I mentioned above
19:34:57 <akahn> ah
19:35:17 <Peaker> though I did forget the key in there :)
19:37:03 <Peaker> foo act k = maybe (storeInMap =<< act) return . Map.lookup k =<< State.get   where   storeInMap res = res <$ State.modify (Map.insert k res)
19:39:18 <Peaker> actually: foo act k = maybe (storeInMap =<< lift act) return . Map.lookup k =<< State.get   where   storeInMap res = res <$ State.modify (Map.insert k res)
19:39:31 <Peaker> foo :: (Monad m, Functor m, Ord k) => m b -> k -> StateT (Map k b) m b
19:39:49 <shachaf> @ty \x -> maybe x return
19:39:50 <lambdabot> Monad m => m a -> Maybe a -> m a
19:40:20 <Peaker> akahn, so your (Map k b) is the memo.  "m b" is the action to take if not in memo.  "k" is the key for this lookup/action.
19:41:11 <akahn> I don't think I'm able to understand this code yet
19:43:40 <Peaker> akahn, let me write it in a more beginner-friendly way
19:46:43 <hpaste> Peaker pasted “Memo map`” at http://hpaste.org/78792
19:46:54 <Peaker> akahn, tell me if that's better
19:48:07 <hpaste> Shamanoid pasted “Remove Dot” at http://hpaste.org/78793
19:48:39 <TheShamanoid> guys, why won't a function like that work? It is giving me couldn't match type error
19:48:50 <Peaker> @type (:)
19:48:51 <lambdabot> a -> [a] -> [a]
19:49:06 <Peaker> TheShamanoid, you're using (:) but you're not giving it [a] as a second argument
19:49:12 <akahn> Peaker: yes, thank you. can you show me an example of calling this function?
19:49:18 <TheShamanoid> alright so the charaacter has to be to the left
19:50:23 <TheShamanoid> Peaker: do i still have to remove the xs part?
19:51:29 <TheShamanoid> i should just use a takeWhile then :S
19:55:12 <hpaste> Peaker pasted “Memo map with example” at http://hpaste.org/78794
19:55:18 <Peaker> akahn, here ^^
19:55:41 <Peaker> TheShamanoid, what does removeDot do?
19:55:50 <Peaker> TheShamanoid, ideally?
19:56:29 <akahn> thank you Peaker
19:57:08 <TheShamanoid> Peaker: it looks for a dot such that it drops everything after the dot while preserving everything before
19:57:17 <Peaker> akahn, my example is silly because print always returns ()
19:57:26 <TheShamanoid> Peaker: my strings end with dots so no need for the drop after bit
19:57:34 <Peaker> akahn, but it will work with any "b" as evident by the type
19:57:44 <TheShamanoid> Peaker: but i implemented it with a takeWhile, much better. Thanks.
19:57:53 <akahn> Peaker: I think I get the gist nonetheless. I will study this and try to shoehorn it into my code :)
19:58:09 <Peaker> akahn, great :)
19:58:46 <akahn> and I can save truly understanding it for a little later
20:04:19 <akahn> Peaker: what are the imports for all of those
20:04:31 <akahn> oh, they're right there. copy/paste fail
20:05:36 <slack1256> Robert Harper did participate on haskell develoment or is in Planet because his apport to type system research?
20:05:54 <slack1256> * did Robert Harper, My engrish is showing
20:21:45 <askdajsd> rawr
20:26:31 <sw2wolf{away}> How to remove the "away" when coming back?
20:28:46 <slack1256> type /away again
20:29:40 <sw2wolf> slack1256: thx
20:31:04 <slack1256> this is the hour when haskell changes of continent
20:31:11 <slack1256> you can tell by all the outs and ins
20:31:18 <slack1256> is quite... beautiful
20:31:59 <dented42> slack1256: o.o
20:32:56 <slack1256> dented42: sorry, end of semester + lack of sleep = my poetic self arises
20:33:08 * hackagebot haskheap 0.1.2 - Haskell bindings to refheap.  http://hackage.haskell.org/package/haskheap-0.1.2 (AnthonyGrimes)
20:34:50 <dented42> slack1256: don't apologize, I'm just trying to figure out what you meant. I can't parse your initial sentence.
20:35:52 <cozachk> to which continent does it go?
20:37:03 <slack1256> dented42: maybe its my enGRish. I said that for all the logout and the join on the channel which I suspect is for the time
20:37:22 <dented42> oh!
20:37:28 <dented42> you mean the channel, not the language
20:37:41 <slack1256> I should meant #haskell insteadç
20:56:01 <dented42> slack1256: you're right
20:56:06 <dented42> it is rather… beautiful
20:57:36 <slack1256> heh
20:59:24 <TheShamanoid> guys i want to write a function that takes a list of strings where each string is made of two componenets, it then assigns one component to the key of a map and the second componenet to the value of the map.
20:59:48 <TheShamanoid> Should the type of the function be [String] -> <MapDataBasenamehere> ?
21:00:38 <dented42> TheShamanoid: pretty much
21:00:47 <TheShamanoid> also another question is, what could be a suitable base case for such a function?
21:00:57 <dented42> base case?
21:01:04 <slack1256> as is recursive base case?
21:01:07 <dented42> oh
21:01:08 <TheShamanoid> yup
21:01:18 <dented42> you want to define it recursively?
21:01:22 <TheShamanoid> function [[]] =   ?
21:01:35 <slack1256> mmm if you wanted to do your recursive definition I would say the empty string []
21:01:37 <bogner> TheShamanoid: Why not write a function that splits the strings into key value pairs and just use fromList?
21:01:42 <dented42> function [] = []
21:01:44 <slack1256> exactly
21:01:57 <dented42> TheShamanoid: might I ask why you want to define it recursively?
21:02:00 <sw2wolf> TheShamanoid: fromList [("a",123),("b",456)] ?
21:02:18 <TheShamanoid> bogner: i don't know why, but i excessivly implement everything as a recursion :(
21:02:51 <TheShamanoid> i thought recursion is one of haskell's strongest features
21:02:59 <TheShamanoid> or the way haskell handles recursion that is
21:03:20 <slack1256> TheShamanoid: that's not efficient (programmer time wise) but is not bad (performant not safely)
21:03:28 <bogner> It is, but you can probably just write "fromList . map splitTheStringIntoAKeyAndValue"
21:03:44 <dented42> TheShamanoid: yes, but generally it's considered a good idea to abstract away from recursion and define things in terms of higher order functions.
21:05:11 <TheShamanoid> .....i see. When is recursion a necessity though? Or in other words, when is it preferable over higher order functions?
21:05:35 <dented42> I suppose it depends on which form better expression what your intent is.
21:05:53 <dented42> s/expression/expresses/
21:05:55 <shapr> aheller: Good to see you again, years later :-)
21:06:20 <slack1256> TheShamanoid: usually is cleared (for the reader) to use higher-order functions, he will think (mmm I don't know what he is doing but he is using a map, so i got one thing less to understand)
21:07:05 <slack1256> also GHC is super good at optimizing when using higher-order functions, have you heard of deforestation?, well that applies there
21:07:35 <TheShamanoid> alright. I will try my best to use higher order functions more often now.
21:07:41 <TheShamanoid> Thanks fr the valuable advice guys.
21:21:49 <astropirate> Did github remove its PM feature?
21:22:01 <astropirate> Need to get in touch with lib author but no contact info!
21:23:08 <SingingBoyo> astropirate:  I'm not sure, but you're probably better off asking on #github
21:23:09 * hackagebot persistent-postgresql 1.0.3 - Backend for the persistent library using postgresql.  http://hackage.haskell.org/package/persistent-postgresql-1.0.3 (MichaelSnoyman)
21:23:24 <astropirate> SingingBoyo, ohh thanks didnt know they had a channel :D
21:28:09 * hackagebot persistent-postgresql 1.1.1 - Backend for the persistent library using postgresql.  http://hackage.haskell.org/package/persistent-postgresql-1.1.1 (MichaelSnoyman)
21:28:11 * hackagebot http-conduit 1.8.5 - HTTP client package with conduit interface and HTTPS support.  http://hackage.haskell.org/package/http-conduit-1.8.5 (MichaelSnoyman)
21:31:03 <hpaste> Shamanoid pasted “What is wrong?” at http://hpaste.org/78798
21:31:40 <TheShamanoid> I keep getting a parse error, i am feeling skeptical about this list comprehension being write.
21:31:48 <TheShamanoid> right*
21:32:02 <shachaf> TheShamanoid: You should paste your error in the future, rather than making people guess it.
21:32:17 <shachaf> (In fact, you should do that now.)
21:32:21 <beaky> hello
21:32:28 <rwbarton> also in the past
21:32:34 <TheShamanoid> Main.hs:52:85: parse error on input `<-'
21:32:46 <shachaf> Great!
21:32:53 <shachaf> That's not a list comprehension because it has no |
21:32:54 <TheShamanoid> no problem ;)
21:33:40 <TheShamanoid> what the hell was i thinking when i typed a comma instead?
21:34:05 <TheShamanoid> shachaf: Thanks@
21:42:31 <beaky> http://ideone.com/9f5VqM I'm trying to implement the game of tic-tac-toe in haskell :D anyone willing to criticize my code?
21:46:50 <shapr> SHAZAM!
21:46:54 <beaky> :D
21:47:03 * shapr bops cheerfully
21:47:55 <djahandarie> All of a sudden, Richard Eisenberg out of nowhere. Looks like a smart guy. (Just saw https://typesandkinds.wordpress.com/2012/12/03/a-formalization-of-ghcs-core-language/ )
21:48:10 * hackagebot refh 0.1.0 - A command-line tool for pasting to https://www.refheap.com  http://hackage.haskell.org/package/refh-0.1.0 (AnthonyGrimes)
21:57:30 <djdx> what is the appropriate venue for asking novice/semi-novice haskell questions?
21:57:37 <elliott> #haskell
21:58:02 <djdx> ah
21:59:48 <djdx> i was fooling around with a trie data structure, and i run into stack overflow errors when i add enough words to my trie.  i can't really tell if it's because my recursion is inherently flawed, or if there is a pileup of thunks that could be avoided somehow
22:00:52 <shachaf> @paste your code (preferably a complete program), I suppose
22:00:52 <lambdabot> Haskell pastebin: http://hpaste.org/
22:01:02 <djdx> ok will do
22:03:10 * hackagebot base64-conduit 0.5.0 - Base64-encode and decode streams of bytes.  http://hackage.haskell.org/package/base64-conduit-0.5.0 (MichaelSnoyman)
22:04:18 <dented42> oh dear
22:04:23 <dented42> did djdx wander off?
22:04:27 <djdx> still here
22:04:32 <dented42> oh
22:04:35 <djdx> i am prepping the code for paste
22:04:39 <dented42> oh
22:05:06 <dented42> spell checking the comments and such? ;)
22:06:46 <Raynes> Any idea why I would get "Building the text-0.11.2.3 package failed" while trying to build the haskell platform on Linux?
22:07:03 <dented42> Raynes: could you be more specific?
22:07:06 <shachaf> Probably because building the package text-0.11.2.3 failed.
22:07:15 <shachaf> Try -v or -v3 or something.
22:07:17 <dented42> what he said
22:07:18 <Raynes> dented42: Not really. That's all the information it gave me.
22:07:26 <Raynes> Sure.
22:07:33 <sw2wolf> GHC should use other linker instead of ld which is too slow.
22:07:41 <dented42> that's very odd
22:07:56 <hpaste> djdx pasted “Trie” at http://hpaste.org/78802
22:08:10 * hackagebot project-template 0.1.1 - Specify Haskell project templates and generate files  http://hackage.haskell.org/package/project-template-0.1.1 (MichaelSnoyman)
22:08:25 <dented42> oh goodie
22:09:10 <slack1256> sw2wolf: wasn't gold(GNU) going to solve those problems?
22:09:28 <slack1256> also I knew something about a patch to make ld not freak out when compiling with ghc
22:09:39 <sw2wolf> slack1256: i first heard of gold
22:09:55 <sw2wolf> slack1256: can GHC use gold ?
22:10:50 <sw2wolf> slack1256: where is the patch ?
22:11:24 <slack1256> sw2wolf: I head or recall something about a patch. But I don't have a reference
22:11:40 <slack1256> but about gold, seems promising
22:11:43 <sw2wolf> slack1256: i will ask google
22:11:50 <sw2wolf> slack1256: thx
22:11:56 <slack1256> gold - A new, faster, ELF only linker, still in beta test.
22:12:51 <sw2wolf> ELF only mean it cannot run on FreeBSD :(
22:13:16 <slack1256> what does FreeBSD uses?
22:13:29 <dented42> djdx: can you get a stack trace at the point where it crashes?
22:13:35 <slack1256> I though all *nix except OSX used ELF
22:13:44 <sw2wolf> gcc ld , maybe clang in the future
22:13:57 <shachaf> djdx: By adding two !s to your program I make it not stack-overflow.
22:14:25 <Raynes> shachaf: Is -v supposed to be a verbose option?
22:14:33 <shachaf> Raynes: Yes.
22:14:37 <slack1256> dented42: wasn't difficult to get stack traces of a lazy program?
22:14:39 <Raynes> shachaf: For make?
22:14:46 <Raynes> It appears to be a version option.
22:14:50 <shachaf> Raynes: Oh.
22:15:02 <shachaf> I thought it was cabal-install
22:15:10 <shachaf> Well, uh, figure out what the verbose option is, and then use it.
22:15:12 <shachaf> djdx: "data TrieNode = TrieNode !(Map TrieEdge TrieNode)" and "let !trie' = insertWord word trie"
22:15:16 <sw2wolf> slack1256: have you tasted gold ?
22:15:19 <dented42> well not necessarily a stack trace, just some indication of what it was trying to do when it crashed
22:15:25 <shachaf> djdx: (The latter requires BangPatterns -- you can get away with using `seq` instead.)
22:15:37 <shachaf> djdx: I haven't actually read your code, mind you. :-)
22:16:13 <djdx> i figured that appropriate insertion of strictness modifiers might fix the problem...
22:16:25 <slack1256> sw2wolf: I once tasted a ring of my grandma. But on running this linker it doesn't seem difficult
22:16:25 <djdx> dented42: how do i get the stack trace?
22:16:32 <slack1256> http://hackage.haskell.org/trac/ghc/ticket/4862
22:16:37 <dented42> djdx: I haven't a clue :P
22:16:40 <slack1256> this guys got luck
22:16:51 <shachaf> @where rts-xc
22:16:51 <lambdabot> ghc -prof -fprof-auto -rtsopts -osuf .p_o foo.hs && ./foo +RTS -xc # print stack traces on unhandled exceptions
22:16:56 <shachaf> djdx: Like that.
22:17:03 <dented42> lambdabot: <3
22:17:31 <dented42> huh, ELF goes all the way back to System V?
22:18:40 <djdx> oh wow
22:18:50 <djdx> that is super useful
22:18:50 <dented42> oh
22:18:53 <dented42> release 4
22:18:54 <shachaf> By the way, you can derive Eq and Ord instances.
22:19:14 <slack1256> dented42: really? the wiki page says something about a commite and the 90's
22:19:47 <dented42> slack1256: that's when it was officially chosen as the standard, but not when it originated
22:20:19 <slack1256> dented42: oh. neat
22:20:33 <dented42> assuming of course, that http://wiki.osdev.org/ELF can be trusted
22:21:03 <hpaste> djdx pasted “Trie -- stack trace” at http://hpaste.org/78803
22:21:25 <shachaf> djdx: Did what I said not solve your problem?
22:21:26 <shachaf> It does for me.
22:22:26 <djdx> trying now
22:25:52 <djdx> yes it works... i guess the fact that i couldn't get a stack trace was the real stumbling block for me.  if i could have seen that i at least would have known what was happening
22:26:11 <djdx> thank you both, dented42 and shachaf
22:26:14 <Raynes> I'm nearly convinced that make doesn't have a verbose option.
22:26:33 <shachaf> strace: Nature's verbose option.
22:26:37 <dented42> I helped? sweet!
22:26:43 <elliott> I'm convinced you haven't read make --help? or is this some other make
22:28:15 <mauke> make defaults to verbose
22:28:18 <Raynes> elliott: I've looked through it four times. Not sure what more you want me to do.
22:28:36 <elliott> well if -d doesn't do what you want then I don't know what you mean by verbose
22:30:17 <djdx> shachaf: what is the recommended way to derive Ord, Eq instances?
22:30:29 <shachaf> data ... = ... deriving (Eq, Ord)
22:30:42 <shachaf> You can also do Show to get a default Show instance and so on.
22:31:05 <djdx> oh, right.
22:31:11 <k0001> Raynes: aren't you getting a “killed by signal 9” or similar message? It happened to me today that I didn't have enough memory and that was the error I was getting, besides “building ... package failed” of course.
22:31:38 <Raynes> Nope. But it seems to have randomly passed the step it was failing at before this time, so I'd bet that is the answer.
22:32:01 <Raynes> Sorry for not providing enough information, guys. I can only work with what I'm given.
22:32:42 <Raynes> k0001: I didn't even consider that. I'm building it on a VPS running a number of other things (like 4clojure.com).
22:34:18 <k0001> Raynes: well, keep it in mind in case it happens again :)
22:34:46 <Raynes> Yeah, I think that was it. Otherwise it probably wouldn't randomly work all of a sudden.
22:34:48 <Raynes> :)
22:40:06 <Raynes> Yay! Haskell platform built and installed.
22:40:56 <Raynes> Thanks for the help and the amusing smart remarks. Now I know what I sound like to newbies in #clojure. ;)
22:42:32 <djdx> thanks, ttyl
22:53:11 * hackagebot hspec 1.4.2.3 - Behavior-Driven Development for Haskell  http://hackage.haskell.org/package/hspec-1.4.2.3 (SimonHengel)
23:00:58 <Raynes> https://www.refheap.com/paste/7303 What can I do to fix this scary thing that just happened?
23:02:11 <Raynes> wat. 'cabal install haskheap' says it's already installed, yet it is trying to build. Methinks I blew something up installing the new haskell-platform over the old one or something.
23:33:13 <sw2wolf> congratulation ! it takes 5 hours to install cabal-install successfully
23:33:39 <statusfailed> woah, really?
23:33:40 <shachaf> Whom are you congratulating?
23:34:03 <sw2wolf> now i can use cabal in ghc 7.6
23:34:04 <statusfailed> shachaf: everyone- we all win the prize!
23:34:18 <shachaf> cabal-install from ghc 7.4 works fine with ghc 7.6
23:34:52 <sw2wolf> shachaf: i am from ghc 7.0.3
23:35:17 <shachaf> I think that should work fine too.
23:35:40 <sw2wolf> i donot know. i reinstall every thing
23:37:53 <sw2wolf> The whole installing process makes me feel that "ld" is VERY bad used with GHC
23:38:08 <sopvop> @ty id
23:38:10 <lambdabot> a -> a
23:38:18 <sopvop> How can that be misused?
23:38:32 <sopvop> Oh, ld
23:38:49 <sopvop> bad fonts
23:38:59 <sw2wolf> i never used such a bad linker in other language
23:39:18 <mauke> what
23:39:23 <mauke> you've never used C or C++?
23:39:54 <sw2wolf> ld works VERY well using C
23:40:09 <mauke> yes, but it's the same ld
23:40:12 <sw2wolf> i donot ever use C++
23:40:26 <mauke> so you have in fact used this "bad linker" in another language
23:40:47 <sw2wolf> mauke: so i donot understand why ld doesnot cooperate with GHC ?
23:40:56 <mauke> cooperate how?
23:41:25 <elliott> I suspect you don't really understand GHC's compilation and linking process well enough to criticise it
23:41:31 <elliott> (from a technical pov)
23:41:45 <sw2wolf> elliott: in fact it is
23:42:05 <sw2wolf> elliott: but ld behaves bad in GHC
23:42:26 * elliott stands by his position
23:43:28 <mauke> "in" GHC?
23:44:18 <sw2wolf> are there many many things needed to link in GHC ?
23:44:58 <sw2wolf> compared with other language using ld
23:49:13 <sw2wolf> no matter what i complained, haskell is a great language worthy studying. it is a bit hard but i will do it.
23:50:04 <sw2wolf> sorry to disturb all of you. hope get your help in the future. bye
23:50:12 <zhulikas> bye
23:58:13 * hackagebot Bookshelf 0.1.6 - A simple document organizer with some wiki functionality  http://hackage.haskell.org/package/Bookshelf-0.1.6 (EmilAxelsson)
