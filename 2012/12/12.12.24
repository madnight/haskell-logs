00:01:40 <alpounet> system64, what's the error?
00:01:59 <system64> alpounet: "The build-tool has reset ENV. --lame-env required."
00:02:55 <system64> not an error, but the interactive shell doesn't show.
00:03:23 <alpounet> uh
00:20:14 <beaky> haskell has very good syntax
00:20:24 <beaky> it makes even complex, abstract stuff look simple
00:20:50 <beaky> or rather, it lets you get a good feel of what you're actually doing
00:20:59 <shachaf> and it has monoids
00:21:00 <beaky> something like that
00:21:00 <shachaf> they are so easy
00:21:10 <beaky> typeclasses :D
00:21:18 <shachaf> roguelikes :D
00:21:34 <beaky> how many haskell roguelikes are there? :D
00:21:53 <shachaf> recursion :D
00:22:24 <beaky> good haskell code hides the recursion
00:22:32 <beaky> using folds
00:22:42 <shachaf> folds and monoids :D
00:22:53 <beaky> monoids are foldable?
00:23:04 <shachaf> @ty foldMap
00:23:05 <lambdabot> (Foldable t, Monoid m) => (a -> m) -> t a -> m
00:23:19 <beaky> ah
00:23:51 * hackagebot mathgenealogy 1.1.1 - Discover your (academic) ancestors!  http://hackage.haskell.org/package/mathgenealogy-1.1.1 (PeterRobinson)
00:25:57 <beaky> I wonder if all monoids are foldable
00:26:28 <shachaf> monoids are so easy :D
00:27:20 <beaky> hmm
00:27:47 <beaky> aha
00:27:57 <beaky> monoids are the only foldable things!
00:29:25 <beaky> or maybe not
00:29:55 * popl folds beaky 
00:30:22 <simpson> beaky: You can fold things that could parts of multiple monoids.
00:30:28 <beaky> ah
00:34:20 <latermuse> monads are monoids, correct?
00:34:26 <latermuse> and functors are also monoids?
00:35:09 <startling> latermuse: no
00:35:23 <startling> latermuse: a monad with a monoid on it is a MonadPlus
00:35:32 <startling> latermuse: functors don't have to be monoids at all
00:35:50 <beaky> yeah
00:35:58 <beaky> a tree is not a monoid
00:36:06 <startling> beaky: some are, but yeah.
00:38:26 <startling> I wonder if Const could be a monoid.
00:38:55 <startling> eh, trivially if the first type argument is also a monoid.
00:42:49 <Jafet> Insert Wadler quote here
01:17:31 <latermuse> startling: but some functors are monoids, correct?
01:19:45 <ciaranm> all functors can be monoids, in a certain sense
01:20:01 <shachaf> Which sense?
01:20:57 <ciaranm> a sensible sense
01:21:06 <Jafet> I sense it is the kind error sense
01:21:20 <startling> latermuse: sure. some fruits can be paperweights too
01:22:04 <ciaranm> but there's not a standard process for turning a fruit into a paperweight
01:22:51 <shachaf> How do you turn a functor into a monoid?
01:22:54 <shachaf> @quote unsafe.*kind
01:22:54 <lambdabot> int-e says: What, unsafeCoerce# is kind-preserving? how boring :/
01:23:07 <startling> hahaha
01:23:30 <startling> ciaranm: I take it that you're not talking about Functor and Monoid, the standard Haskell typeclasses?
01:23:44 <Jafet> unkindCoerce
01:23:55 <ciaranm> you can turn anything into a monoid! for free!
01:24:06 <ciaranm> it's not necessarily very useful, of course
01:24:21 <startling> how?
01:24:40 <ciaranm> by free monoiding it
01:25:10 <ciaranm> I'VE GOT A LITTLE LIST
01:25:18 <shachaf> So you're saying that for any functor f, [f a] is a monoid?
01:25:26 <shachaf> (For any a.)
01:25:32 <latermuse> ciaranm: can you provide a small example?
01:25:34 <shachaf> That seems like a pretty useless thing to say.
01:25:59 <startling> yeah.
01:26:38 <apriori|> hey guys.. can you recommend a lenses implementation or something similiar?
01:26:51 <elliott> apriori|: lens
01:26:55 <latermuse> try the 'lens' package
01:26:59 <elliott> http://lens.github.com/, hackage.haskell.org/package/lens
01:27:00 <latermuse> or 'lenses' if you want something less powerful
01:27:09 <elliott> ew, not lenses. its representation is absolutely terrible
01:27:09 <shachaf> If you want something less powerful you should use data-lens
01:27:17 <elliott> data-lens if you want the boring kind with less useful operations :p
01:27:23 <latermuse> er and by 'lenses' i mean 'data-lens'
01:27:24 <latermuse> my bad
01:27:32 <edwardk> latermuse: lenses is definitely _not_ the package you want
01:27:40 <Jafet> A common typo
01:27:45 <latermuse> edwardk: yeah, i made a mistake, sorry
01:27:47 <edwardk> Jafet: sadly
01:27:53 <latermuse> edwardk: by the way, im watching this https://www.youtube.com/watch?v=cefnmjtAolY, and its awesome!
01:27:59 <edwardk> thanks =)
01:28:00 <popl> $THEKEYSARERIGHTNEXTTOEACHOTHER
01:28:11 <elliott> I was about to say we should get some kind of "crappy & unmaintained" warning on lenses
01:28:14 <elliott> but apparently
01:28:15 <elliott> it's still maintained???
01:28:28 <popl> that was strangely satisfying to look at.
01:28:38 <Jafet> There is such a warning. Well, it's not distributed with the lenses package.
01:29:06 <edwardk> Jafet: oh?
01:29:12 <apriori|> elliott, latermuse, well, from what I read so far, syntaxwise pretty much all lenses are awful.. but I am a total noob on haskell, so I might be missing something
01:29:29 <Nereid> use lens
01:29:30 <Nereid> ;)
01:29:36 <elliott> lens has nice syntax IMO
01:29:42 <popl> "I'm new at this but I can tell it totally sucks."
01:29:47 <latermuse> different syntax doesnt mean its awful
01:30:01 <edwardk> apriori|: watch https://www.youtube.com/watch?v=cefnmjtAolY&hd=1
01:30:01 <Jafet> I think edwardk wrote a warning to this effect on a stack overflow thread
01:30:14 <latermuse> africans look different than me, they must be awful /s
01:30:19 <edwardk> apriori|: that goes a long way towards addressing the usability and syntactic woes
01:30:22 <popl> https? :O
01:30:28 <apriori|> edwardk: ok, thank you
01:30:55 <edwardk> apriori|: there are also a bunch of resources on lens.github.com and github.com/ekmett/lens/wiki
01:31:18 <apriori|> edwardk: ok, thank you.. will look into it
01:31:20 <elliott> apriori|: http://vimeo.com/56063074 has a scaled one that you might find easier to see the slides with if you don't have the connection/processor for the HD
01:31:25 <popl> edwardk: Who is introducing you?
01:31:30 <edwardk> popl: sclv
01:31:30 <elliott> s/one/version of the video/
01:31:35 <edwardk> popl: gershom bazerman
01:31:40 <popl> Thank you.
01:31:47 <popl> He says "um" a lot. :)
01:31:57 <edwardk> he works with me at S&P Capital IQ and is one of the organizers of New York Haskell
01:32:05 <`nand`> @tell roconnor I'm not sure about BT.601
01:32:05 <lambdabot> Consider it noted.
01:32:13 <popl> Does this count as networking?
01:32:21 * popl rubs edwardk's elbows.
01:32:28 <edwardk> popl: he's also ridiculously smart ;)
01:32:52 <popl> edwardk: I have little doubts if he works with you.
01:33:15 <popl> um++
01:33:32 <`nand`> lens has the kind of syntax that you recoil from at first but learn to embrace later
01:33:37 <popl> That's three so far!
01:33:45 <popl> :)
01:33:52 <startling> `nand`: just like haskell!
01:34:04 <popl> Didn't you guys have to take a public speaking class too? I had to.
01:34:08 <edwardk> popl: i have a ton of um's in my part too ;)
01:34:12 <`nand`> silly startling, you don't recoil from haskell syntax ;)
01:34:14 <popl> edwardk: I know!
01:34:19 <edwardk> i just edited the transcription to remove them ;)
01:34:23 <latermuse> isnt lens designed to have similar syntax to english language?
01:34:32 <`nand`> latermuse: all idiomatic haskell is, arguably ;)
01:34:34 <elliott> um... not really?
01:34:37 <elliott> I don't know what you mean by that
01:34:44 <`nand`> but yeah, it doesn't really work that well in most cases
01:34:49 <`nand`> just occasionally
01:35:06 <edwardk> latermuse: i wanted a 'vocabulary' for lenses. its mostly that i tried to grab prepositions, gerundives, past tenses, etc. it worked out to something that has a nice 'mouth feel' to it and reads fairly idiomatically
01:35:24 <`nand`> ‘Getting a s t a b’
01:35:39 <edwardk> > sumOf (folding words.to read) "1 2 3 4 5"
01:35:42 <lambdabot>   15
01:35:49 <latermuse> wow！！
01:35:54 <edwardk> stuff like that is kind of cute
01:36:17 <latermuse> absolutely awesome
01:36:58 <shachaf> Should there be something :: Read a => Fold String a?
01:37:28 <shachaf> I suppose you can implement it with (to readMaybe.traverse), but...
01:37:39 <edwardk> shachaf: readMaybe was only exposed recently, no?
01:37:44 <elliott> shachaf: surely it should give all the reads results
01:37:50 <shachaf> edwardk: Yep, it's new in 7.6
01:37:51 <elliott> then (^?) will get just one
01:37:59 <edwardk> shachaf: that works for you, but not the 7.0 guys
01:38:01 <elliott> also can it be a traversal? I guess not
01:38:04 <shachaf> elliott: That doesn't help for edwardk's one-liner.
01:38:07 <shachaf> edwardk: Right.
01:38:14 <edwardk> come up with a 7.0 compatibility shim and i'd be okay with adding something
01:38:28 <shachaf> I,I foo :: (Read a, Show a) => Traversal' String a
01:38:33 <shachaf> (Let's not.)
01:38:37 <edwardk> reading or something it should be past tense but thats 'read'
01:38:45 <elliott> readed
01:38:48 <edwardk> ooh, that even defaults correctly
01:38:49 <`nand`> _read
01:38:55 <elliott> wait, that defaults properly?
01:39:00 <edwardk> yeah because Show
01:39:02 <elliott> but it doesn't obey traversal laws does it
01:39:16 <edwardk> it obeys them if read and show aren't broken for the type
01:39:16 <elliott> also it sucks if you have a type that's just Show, but then I guess "to show" works just as well
01:39:21 <shachaf> Not unless you have a really strict read/show
01:39:33 <`nand`> (Read a, Show a) => Iso' String a
01:39:34 <shachaf> edwardk: read accepts whitespace and things like that, doesn't it?
01:39:42 <elliott> edwardk: well if put in (Foo 123) and get out "Foo 123" and you feed in "QQQQQ"
01:39:44 <`nand`> oh
01:39:46 <elliott> what happens
01:39:47 <`nand`> not an iso
01:39:50 <`nand`> a prism maybe?
01:39:52 <shachaf> There's a guarantee that read (show a) == a, maybe, but not the other way around.
01:40:00 <edwardk> shachaf: its only one side of the adjunction. there is probably a prism
01:40:13 * elliott really doesn't quite see how this obeys the laws
01:40:25 <popl> is category theory approachable as an undergraduate?
01:40:25 <edwardk> and if we formalize improper prisms we can capture the normalization behavior
01:40:33 <edwardk> its an improper prism of the second kind
01:40:46 <edwardk> to use the vocabulary i developed last week
01:40:56 <elliott> edwardk: You have to be able to put back values into a Traversal...
01:40:57 <Nereid> popl: sure. it helps to already know some examples of categories.
01:41:08 <elliott> Oh, hmm
01:41:16 <elliott> edwardk: right, doesn't shachaf's objection apply?
01:41:19 <elliott> you feed in "Foo     123"
01:41:22 <elliott> get back (Foo 123)
01:41:29 <edwardk> hence improper prism
01:41:29 <elliott> feed in (Foo 123)
01:41:30 <ciaranm> someone should write a book on all this
01:41:31 <elliott> that's "Foo 123"
01:41:37 <johnw> ciaranm: on what?
01:41:42 <edwardk> because once it roundtrips it stays constant
01:41:52 <elliott> well, OK
01:41:57 <elliott> I thought you meant it was a valid traversal but invalid prism
01:41:58 <shachaf> We should figure out improper prisms.
01:42:02 <edwardk> yes
01:42:03 <ciaranm> johnw: all the cool stuff that's not in LYAH
01:42:05 <shachaf> But Enigmagic's case was a particularly hard one.
01:42:13 <edwardk> they are on my checklist of things to describe and document more fully
01:42:14 <johnw> ciaranm: hmm.. big book, that
01:42:14 <`nand`> _read :: (Read a, Show a) Prism' String a; _read = prism show (\t -> maybe (Left t) Right (readMaybe t))
01:42:15 <Nereid> sounds like a galois connection.
01:42:17 <`nand`> does this obey prism laws?
01:42:20 <shachaf> Well, it was hard from a lens perspective. Maybe not from a prism perspective?
01:42:26 <edwardk> `nand`: not quite
01:42:44 <Nereid> except without the ordering.
01:42:56 <elliott> it doesn't obey the Haskell laws
01:42:58 <edwardk> `nand`: read . show = id but not necessarily    show . read
01:42:58 <elliott> where's your => :P
01:43:04 <elliott> `nand`: btw you can use prism'
01:43:09 <elliott> prism' show readMaybe
01:43:14 <edwardk> elliott: only in head
01:43:20 <`nand`> oh, prism' is nice
01:43:32 <shachaf> I bet there's something even nicer than prism'
01:43:42 <shachaf> A combinator thing dual to twan lenses.
01:43:44 <popl> so a set is a category and a mapping of one set to another is an arrow between those two sets?
01:43:52 * hackagebot hmatrix-quadprogpp 0.1.0.0 - Bindings to QuadProg++  http://hackage.haskell.org/package/hmatrix-quadprogpp-0.1.0.0 (AkioTakano)
01:43:56 <popl> this should be in ##math probably
01:44:00 <`nand`> how about building a prism from an affine traversal and a getter?
01:44:01 <shachaf> Where you have to Just <$> over some "f b", so you can always extract one direction.
01:44:18 <popl> Nereid: thanks
01:44:33 <Nereid> popl: well, in the category of sets, it's the class of all sets that forms (the objects of) the category.
01:44:59 <edwardk> `nand`: that turns out to be tricky to ensure its not 'too big'
01:45:01 <Nereid> and arrows go between objects.
01:45:05 <edwardk> thats what we used to do
01:45:10 <edwardk> the new prisms are much much nicer
01:45:17 <`nand`> (we don't even have proper affine traversals yet, do we?)
01:45:56 <edwardk> `nand`: we may never get affine traversals. since the existence of 'First' as a canonical monoid makes them boring, but relevant traversals would be nice to have
01:46:01 <popl> Nereid: thank you
01:46:08 <Nereid> what was this affine/relevant stuff?
01:46:16 <elliott> affine = zero or one traversal
01:46:21 <elliott> relevant = one plus (nonempty) traversal
01:46:25 <edwardk> Nereid; an affine traversal visits 0 or 1 elements, relevant 1 or more
01:46:26 <Nereid> oh.
01:46:26 <elliott> affine traversal also = partial lens
01:46:36 <Nereid> I don't get the names.
01:46:43 <edwardk> elliott: i went with 'affine traversal' because 'partial lens' is overloaded
01:46:46 <elliott> you get used to them
01:46:51 <edwardk> Nereid: affine and relevant come up in substructural logic
01:46:56 <elliott> edwardk: yeah but it's a useful analogy to someone who already understands how you do those with traversals I think
01:47:04 <elliott> to udnerstand why the 0-or-1ness can be relevant
01:47:06 <Nereid> I don't know what that is.
01:47:09 <Nereid> but ok.
01:47:52 <shachaf> Lens, Affine = Lens?, Relevant = Lens+, Traversal = Lens*
01:47:53 <edwardk> in a setting that had them, the (a -o f b) morphism that we're using could capture affine or relevant variables in its environment depending on which you have
01:48:08 <edwardk> and then affine + relevant = linear  gives you that a lens is a linear traversal
01:48:30 <edwardk> in the linear logic sense
01:49:05 * elliott thinks this will clear up all of Nereid's confusion!
01:49:10 <Nereid> totally.
01:49:12 <Nereid> :p
01:49:32 <edwardk> Nereid: read the first chapter in advanced topics in types and programming languages, edited by benjamin pierce
01:49:38 <`nand`> I just remember the names as ‘meaningless labels’ and associate them with their meaning in a lens-context
01:49:43 <edwardk> Nereid: the article was written by david walker and covers this nicely
01:49:59 <edwardk> well, not for lenses, but from a type system perspective
01:50:12 <`nand`> you should totally write a book or two on lenses
01:50:17 <`nand`> from a theoretical perspective
01:50:36 <edwardk> there is also the lambda_refURAL stuff by amed, fluet, and greg morrisett
01:50:43 <`nand`> once you've given them a nice type system and programming language to go with it, that is
01:50:48 <edwardk> they explicitly use the unrestricted/relevant/affine/linear hierarchy
01:51:03 <edwardk> my second thesis spent a lot of time refining it to add uniqueness typing, etc.
01:51:16 <edwardk> and then i promptly never used it again
01:51:28 <Nereid> lol
01:51:43 <`nand`> A case of premature generalization?
01:52:08 <edwardk> i had a base case of 'second system syndrome' in that i took everything i wanted and threw it into a blender
01:52:11 <Nereid> I better get to bed.
01:52:14 <edwardk> i was fortunate enough not to be successful ;)
01:52:25 <edwardk> otherwise i'd still be working on it
01:52:58 <`nand`> that reminds me
01:53:24 <`nand`> how do I convince you that nothing is more important in life than writing efficient video decoding and playback libraries in pure Haskell?
01:54:24 <`nand`> (or ‘pure’ by some low common denominator like opengl for interfacing with the graphics card)
02:13:55 <beaky> how does pattern matching work
02:15:48 <latermuse> > let meow = [(123,"meow"),(456,"woof")]
02:15:50 <lambdabot>   not an expression: `let meow = [(123,"meow"),(456,"woof")]'
02:16:07 <simpson> > let meow = [(123,"meow"),(456,"woof")] in meow
02:16:09 <lambdabot>   [(123,"meow"),(456,"woof")]
02:16:12 <johnw> beaky: hint: it happens at runtime
02:16:14 <latermuse> thanks ;)
02:16:17 <beaky> ah
02:16:26 <beaky> so it uses a jump table?
02:16:46 <alpounet> beaky, the  runtime "tags" which constructor was used
02:16:50 <johnw> if you've ever written a struct containing a bunch of unions and a "kind" member, and then did a switch on the kind, you've implemented pattern matching of a kind
02:17:00 <latermuse> > let meow = [(123,"meow"),(456,"woof")] in meow % _2 .~ "bark"
02:17:02 <lambdabot>   Not in scope: `%'
02:17:02 <lambdabot>  Perhaps you meant `R.%' (imported from Data.Ratio)
02:17:11 <`nand`> > [(123,"meow"),(456,"woof")] & biplate.bits %~ not
02:17:16 <lambdabot>   mueval-core: Time limit exceeded
02:17:32 <`nand`> > [(123 :: Int,"meow"),(456 :: Int,"woof")] & biplate.bits %~ not
02:17:36 <beaky> ah
02:17:36 <lambdabot>   mueval-core: Time limit exceeded
02:17:38 <`nand`> bah
02:17:45 <popl> % looks like a gnat in my font
02:17:56 <popl> :D
02:18:03 <beaky> %_%
02:18:18 <beaky> so pattern matching is very fast
02:18:23 <popl> two gnats carrying some toast
02:18:27 <beaky> what about deconstructing?
02:18:31 <popl> (it's a small bit of toast)
02:18:40 <beaky> like (x:xs) pstterns
02:18:48 <`nand`> @tell roconnor BT.601 uses the same encoding function as BT.709, conceptually λ≈0.45
02:18:49 <lambdabot> Consider it noted.
02:19:02 <`nand`> @tell roconnor it's actually a 2-part function, as described in the pdf
02:19:02 <lambdabot> Consider it noted.
02:19:49 <popl> `nand`: did you use your compose key to type ≈ ?
02:19:55 <`nand`> popl: no
02:19:57 <elliott> beaky: that is pattern matching
02:20:02 <beaky> oh
02:20:03 <`nand`> I just.. pressed it
02:20:24 <popl> `nand`: What sort of keyboard and keyboard layout are you using?
02:21:01 <`nand`> keyboard is a Filco Majestouch 2 in the european/ISO layout; keyboard layout is https://raw.github.com/nandykins/gentoo-conf/master/.Xmodmap
02:21:11 <popl> thanks!
02:21:12 <`nand`> keycode  20 = minus underscore plusminus approxeq
02:21:59 <popl> because who uses a fscking 10-key anyways?
02:22:20 <`nand`> the four values are, in order, ‘no combinator’, ‘shift’, ‘mode switch’ and ‘mode switch + shift’
02:22:27 <`nand`> (mode switch is Alt Gr for me)
02:22:52 <popl> Gr?
02:23:05 <`nand`> https://en.wikipedia.org/wiki/Alt_Gr
02:23:13 <popl> thanks
02:23:26 <popl> OH!
02:23:28 <popl> Ok
02:23:33 * shachaf vaguely wonders whether popl has ever said anything in this channel that had anything to do with Haskell.
02:23:36 <shachaf> popl: What brings you here?
02:23:45 <popl> shachaf: I said stuff earlier.
02:24:16 <beaky> hehe
02:24:18 <johnw> i swear i've seen popl say Haskelly stuff
02:24:32 <johnw> I'm wondering when shachaf will talk about anything other than lenses and profunctors
02:24:50 <edwardk> johnw: don't break the streak. its useful
02:24:55 <`nand`> I'm wondering what's wrong with talking about lenses and profunctors
02:24:58 <beaky> lenses are a great thing
02:25:07 <johnw> edwardk: he could always talk about that AND other stuf :)
02:25:22 <johnw> i love the lens and profunctor talk, don't mind me
02:25:35 <shachaf> johnw: Sometimes I talk about bifunctors.
02:25:42 <johnw> you do have a point there
02:26:19 <johnw> did you ever find your mysteries Foo type?
02:26:20 <edwardk> i like keeping him focused. ;)
02:26:39 <`nand`> a better use of energy than being grumpy in #haskell all day ;)
02:26:44 <shachaf> johnw: What Foo type?
02:26:45 <beaky> lol
02:26:46 <edwardk> at least until we get the current wave of profunctor generalizations in ;)
02:26:48 <latermuse> > [(123,"bark"), (456,"meow")] >>= (\x -> return $ x % _2 .~ "bark")
02:26:50 <lambdabot>   Not in scope: `%'
02:26:50 <lambdabot>  Perhaps you meant `R.%' (imported from Data.Ratio)
02:27:09 <latermuse> I guess im using an old version of lens
02:27:10 <johnw> Foo a b -> Foo s t ~~ (a -> t) -> (s -> b)
02:27:13 <`nand`> (%) is (&) now
02:27:22 <latermuse> thanks
02:27:29 <latermuse> > [(123,"bark"), (456,"meow")] >>= (\x -> return $ x & _2 .~ "bark")
02:27:32 <lambdabot>   [(123,"bark"),(456,"bark")]
02:27:33 <`nand`> > [(123,"bark"), (456,"meow")] & mapped._2 .~ "bark"
02:27:36 <lambdabot>   [(123,"bark"),(456,"bark")]
02:27:51 <elliott> foo >>= (\x -> return $ ...) === fmap (\x -> ...) foo
02:27:54 <popl> shachaf: I barely know any Haskell. I would like to understand the mathematical underpinnings before I get too far into it and conflate the Haskell implementation of things with the mathematical concepts (if there are direct mappings between the two things).
02:27:55 <elliott> or with lens, foo <&> \x -> ...
02:28:12 <popl> So I am taking my time with Haskell. Some of it is pretty obvious.
02:28:21 <popl> I don't want to miss anything though.
02:28:33 <latermuse> awesome elliott, thanks!
02:28:35 <popl> I also want to hang out with smart people.
02:28:42 <`nand`> I think it's much easier to learn haskell first and then familiarize oneself with the mathematical underpinnings than doing it in reverse
02:28:52 <johnw> popl: i recommend learning haskell and the math stuffs in parallel
02:28:52 <edwardk> popl: my advice is to just learn haskell as haskell and then pick up the math post hoc
02:29:04 <popl> ok
02:29:18 <johnw> yeah, haskell as haskell has its merits
02:29:19 <edwardk> then when you get to the math you have a nice exemplar of all of these ideas. Hask works like a constructive version of 'Set'
02:29:28 <`ramses> popl: I guess that way you could get stuck learning mathematics forever and never come to the part where you would learn haskell
02:29:39 <popl> that could be bad
02:29:41 <popl> could be
02:29:42 <`nand`> it's like trying to learn what lenses are by staring at profunctors and SECs rather than looking at data Lens a b = Lens { view :: a -> b, set :: a -> b -> a }
02:29:44 <elliott> edwardk: that's the most optimistic description of Hask I've ever heard
02:29:55 <edwardk> and thats a really rich category, so it has lots of structure, and you can try out all those ideas as you find them in math in hask, but only if you know haskell well enoiugh to see where they apply
02:30:04 <latermuse> > fmap (\x -> x % _2 .~ "bark") [(123,"cat"),(456,"dog")]
02:30:06 <lambdabot>   Not in scope: `%'
02:30:06 <lambdabot>  Perhaps you meant `R.%' (imported from Data.Ratio)
02:30:14 <latermuse> > fmap (\x -> x & _2 .~ "bark") [(123,"cat"),(456,"dog")]
02:30:16 <latermuse> my bad
02:30:16 <edwardk> elliott: its got its warts, but it _is_ a nice category
02:30:16 <lambdabot>   [(123,"bark"),(456,"bark")]
02:30:21 <popl> Thank you all for your input.
02:30:21 <latermuse> this is neat though :)
02:30:25 <ciaranm> Hask is Set this week? i thought it was some kind of CPO
02:30:28 <johnw> edwardk has a great point there.  knowing Haskell first helps you know how to apply math to haskell, but knowing math first does not really tell you how to apply it to Haskell
02:30:35 * elliott isn't sure `nand`'s traditional lens representation is actually the best one to learn from.
02:30:43 <elliott> It's quite a leap from that to lens
02:30:58 <shachaf> s -> (a, b -> t) is pretty good.
02:31:16 <`nand`> yeah, fair point; but it's the easiest for showing what a ‘Lens’ is; rather than familiarizing oneself with the working of the ‘lens’ library (which is really more about traversals)
02:31:18 <edwardk> you can see how all the pieces fit in that representation as a starting point
02:32:04 <edwardk> the lens library now is pretty nicely symmetric about working with lenses and prisms now which is great, because we can do things like define prisms for all of the exception types, etc.
02:32:08 <edwardk> and you can say things like
02:32:20 <edwardk> catching nonTermination (…) $ ...
02:32:35 <`nand`> popl: a viable strategy for familiarizing oneself with some arcane mathematical construct is thinking about what it means in Haskell terms ;)
02:32:35 <edwardk> handling stackOverflow … ...
02:33:40 <`nand`> edwardk: that's pretty awesome
02:33:49 <edwardk> `nand`: that just went in the other day
02:33:57 <edwardk> i'm pretty happy with it
02:34:03 <`nand`> is there a ‘throw stackOverflow’ too?
02:34:10 * elliott likes edwardk's mixing of … and ...
02:34:14 <edwardk> http://ekmett.github.com/lens/Control-Exception-Lens.html
02:34:23 <edwardk> elliott: those are two separate arguments ;)
02:34:34 <neutrino> edwardk: what's the difference between a lens and a prism?
02:34:45 <`nand`> Endo (Maybe a) ?
02:35:08 <edwardk> neutrino: a lens splits your object into a target (b,  and 'everything else' c)   and then lets you edit b and recombine
02:35:17 <neutrino> go on
02:35:25 <`nand`> neutrino: they're duals
02:35:36 <neutrino> `nand`: that tells me nothing, sorry..
02:35:43 <edwardk> a prism lets you match a target b + other stuff, and reconstruct the whole from just b.
02:35:56 <edwardk> so lenses work with 'products' and prisms work with 'sums'
02:35:58 <neutrino> how do you "reconstruct the whole"?
02:36:05 <edwardk> > 5^.remit _left
02:36:08 <lambdabot>   Left 5
02:36:16 <johnw> so a lens is a product and a prism is a coproduct?
02:36:20 <edwardk> that's injecting 5 into Either using the _left prism
02:36:39 <shachaf> johnw: A lens isn't a product, but it's related to products in the same way a prism is related to sums.
02:36:41 <edwardk> johnw: its not a product per se, but more of a factoring of its target into a product or coproduct
02:36:42 <neutrino> edwardk: right, so basically a prism is like a stencil, and you fill out the holes?
02:36:57 <johnw> shachaf: i mean a product in the sense that (a,b) is a product
02:37:04 <edwardk> neutrino: think of lenses like smart field accessors, prisms like smart constructors
02:37:13 <neutrino> right
02:37:14 <shachaf> johnw: Yes.
02:37:24 <neutrino> why not just call it a "template"?
02:37:30 <shachaf> johnw: A lens is related to a product in the same way that a prism is related to a sum.
02:37:38 <johnw> perfect, thanks
02:37:41 <`nand`> I'm not sure what you mean by ‘like a stencil, and you fill out the holes’
02:37:47 <shachaf> It isn't a product itself, unless you mean that (s -> a, s -> b t) is a product of two functions.
02:37:48 <edwardk> > Just 4 ^.. _just
02:37:50 <lambdabot>   [4]
02:37:50 <johnw> nice use of terminology
02:37:57 <shachaf> (But then a prism is also a product of two functions.)
02:38:03 <johnw> a lenses focuses light, a prism scatters it, so they are natural duals
02:38:12 <`nand`> I think the most logical explanation of prisms is still “an affine traversal together with a (reversed) getter”
02:38:22 <`nand`> well, of what prisms /are/
02:38:25 <`nand`> not of what they represent
02:38:31 <edwardk> `nand`: that intuition doesn't guide you to most of its actual combinators though
02:38:36 <johnw> `nand`: I guess logical is orthogonal to clear :)
02:38:49 <edwardk> :t outside
02:38:52 <lambdabot> Functor f => APrism s t a b -> ((b -> r) -> f (a -> r)) -> (t -> r) -> f (s -> r)
02:39:07 <edwardk> would be pretty hard to figure out given `nand`'s version
02:39:14 <neutrino> light is scattered by lenses.. prisms take it apart into components by using refraction
02:39:24 <shachaf>   APrism s t a b -> Lens (t -> r) (s -> r) (b -> r) (a -> r)
02:39:29 <neutrino> but that's immaterial
02:39:31 <edwardk> APrism s t a b -> Lens (t -> r) (s -> r) (b -> r) (a -> r)
02:39:36 <johnw> a lens scatters light?
02:39:49 <latermuse> i thought lens focus light
02:39:50 <edwardk> anyways the prism analogy is imperfect
02:39:55 <edwardk> lenses can focus or scatter
02:39:59 <edwardk> they bend it
02:39:59 <latermuse> really?
02:40:03 <latermuse> oh doh
02:40:03 <edwardk> they can be concave of convex
02:40:07 <latermuse> yeah thats right
02:40:09 <edwardk> er or
02:40:11 <latermuse> (highschool physics)
02:40:13 <johnw> and doesn't a prism work by diffraction?
02:40:16 <popl> light is immaterial neutrino
02:40:18 <neutrino> concave ones can scatter and focus too
02:40:26 <edwardk> in theory we could call the existing lenses convex lenses and use concave ones for prisms
02:40:31 <edwardk> but the names kinda suck
02:40:33 <neutrino> and then it depends on how far your screen is from the focal point
02:40:35 <neutrino> and so on
02:40:36 <edwardk> neutrino: sure
02:40:36 <neutrino> ;)
02:40:38 <latermuse> focus is just a state in the scatter
02:40:50 <`nand`> personally, I see ‘lenses’ as closer to what prisms are; they split a sum (white) into its components
02:40:51 <neutrino> edwardk: just for the benefit of latermuse
02:41:02 <`nand`> err
02:41:09 <neutrino> `nand`: i've had the same thought just now :)
02:41:09 <`nand`> by sum I mean product
02:41:25 <edwardk> anyways we get lots of analogies, the names are mostly just there to hang the structures on ;)
02:41:30 <neutrino> edwardk: so i heard the types in lens are getting simpler?
02:41:38 <edwardk> neutrino: they have
02:41:40 <`nand`> yes, more profunctors
02:42:06 <popl> ok, thank you for the conversation.
02:42:07 <edwardk> type Iso s t a b = forall p f. (Profunctor p, Functor f) => p a (f b) -> p s (f t)
02:42:08 <`nand`> (of course we've established simple does not necessarily mean clear)
02:42:16 <johnw> edwardk: soon the lens library's unsafeCoerce count will become massive enough that we'll get gravity lenses as a byproduct
02:42:22 <neutrino> edwardk: can lenses provide reversible getters?
02:42:40 <johnw> neutrino: prisms do that
02:42:41 <`nand`> neutrino: iso..
02:42:44 <edwardk> what is a reversible getter, an iso?
02:42:50 <`nand`> a getter is just a function
02:43:02 <`nand`> and a reversible function is an isomorphism (for some meaning of ‘reversible’)
02:43:07 <edwardk> > [1,2,3,4,5,6] & upon last .~ 100
02:43:07 <johnw> actually, i don't quite know what he means
02:43:09 <lambdabot>   [1,2,3,4,5,100]
02:43:13 <edwardk> sure ;)
02:43:18 <neutrino> well what i mean is, let's say you have a complicated data structure (type S) and a function f :: S -> Int
02:43:21 <edwardk> > [1,2,3,4,5,6] & upon (!!3) .~ 100
02:43:23 <lambdabot>   [1,2,3,100,5,6]
02:43:24 <`nand`> :t upon
02:43:26 <lambdabot> (Data.Data.Data a, Data.Data.Data s, Applicative f, Indexable [Int] k) => (s -> a) -> k (a -> f a) (s -> f s)
02:43:29 <`nand`> oh god, it's that magic combinator, isn't it?
02:43:32 <neutrino> and there's a one to one correspondence between S and Int
02:43:34 <edwardk> upon is magic
02:43:45 <`nand`> I forgot how it works
02:43:47 <`nand`> oh
02:43:47 <edwardk> neutrino: we can't magically inspect the function to figure out the mapping
02:43:56 <`nand`> replaces each element of the structure by a unique exception
02:43:58 <edwardk> upon is as close to magic as we get
02:44:00 <`nand`> then catches them with unsafePerformIO
02:44:03 <`nand`> or something
02:44:04 <edwardk> `nand`: yeah
02:44:05 <`nand`> right?
02:44:08 <neutrino> can you make a piece of code that defines going from S to Int as well as from Int to S?
02:44:10 <edwardk> and then works its way down
02:44:30 <edwardk> neutrino: figure out how to write it in haskell. i can't do magic
02:44:34 <neutrino> edwardk: sure, you can't do this for everything.. but i was wondering if there's a technique for instructing haskell how to
02:45:01 <johnw> neutrino: you mean, how to automatically provide an inversion for any function?
02:45:05 <`nand`> iso (foo :: S -> Int) (bar :: Int -> S) -- ?
02:45:09 <neutrino> not "any"
02:45:21 <`nand`> would give you an Iso' S Int
02:45:26 <neutrino> how to write a function which can be automatically inverted
02:45:40 <`nand`> then you can either use that directly, or invert it with ’from’
02:45:42 <neutrino> ^that is what i mena johnw
02:45:50 <`nand`> oh, you can't actually use it directly anymore, right?
02:46:03 <`nand`> but you could make your own version of the old Isomorphic if you want invertible functions
02:46:04 <neutrino> `nand`: not sure what you mean. i've never used iso?
02:46:17 <shachaf> If you just have simple isomorphisms (s a instead of s t a b), there's a pretty nice way to represent them with invariant functors
02:46:27 <shachaf> type Iso s a = forall f. Invariant f => f a -> f s
02:46:37 <edwardk> neutrino: read the work by janis voightlaender on this topic. its not possible in general, but he goes pretty far
02:46:51 <`nand`> Invariant?
02:46:57 <neutrino> edwardk: i'm 100% sure it's not possible in general. that's what we have brains for though :)
02:46:58 <edwardk> we've also been working on a DSL for it, which mgsloan calls lenq.
02:47:19 <neutrino> edwardk: dsl for janis voightländer's work?
02:47:23 <edwardk> neutrino: the dsl lets you at least get simple lenses automatically from TH
02:47:44 <edwardk> for automatic lens reversal of simple functions
02:47:49 <edwardk> you write something like
02:48:12 <edwardk> $(lense [e| \(x,y,z) -> (x,y) |])   and itll construct the setter
02:48:26 <edwardk> but it only works for very stylized use of case analysis, etc.
02:48:48 <edwardk> its in mgsloan's fork of lens
02:52:04 <hpaste> “`nand`” pasted “Isomorphic” at http://hpaste.org/79743
02:52:15 <`nand`> neutrino: by ‘function which can be inverted’ do you mean this? ^
02:53:25 <latermuse> [1,2,3,4,5,6] & upon first .~ 3
02:53:35 <latermuse> > [1,2,3,4,5,6] & upon first .~ 3
02:53:37 <lambdabot>   Couldn't match expected type `[t0]' with actual type `a0 b0 c0'
02:53:44 <`nand`> :t first
02:53:46 <lambdabot> Arrow a => a b c -> a (b, d) (c, d)
02:53:49 <latermuse> doh
02:54:19 <latermuse> is there a 'first' that can be used like the last in this example? [1,2,3,4,5,6] & upon last .~ 100
02:54:24 <`nand`> yeah
02:54:29 <`nand`> > [1..6] & upon head .~ 3
02:54:31 <lambdabot>   [3,2,3,4,5,6]
02:54:34 <aninhumer> I'm not sure why this template haskell doesn't compile? http://hpaste.org/79745
02:54:42 <`nand`> :t (head, last)
02:54:44 <lambdabot> ([a] -> a, [a1] -> a1)
02:55:05 <latermuse> you can do that...
02:55:09 <aninhumer> I did something similar with a function definition, but when I try to define a class data family it doesn't seem to work
02:55:10 <latermuse> put functions into a tuple
02:55:43 <`nand`> aninhumer: from the error message, seems like it inlines each use of $t into a different unique variable?
02:55:43 <latermuse> im like the perpetual haskell newb; im learning new stuff every single day
02:56:01 <`nand`> then again, shouldn't $t be a type name?
02:56:14 <`nand`> I don't know; I've always had issues with TH quote syntax personally so I just construct the ADTs manually
02:56:27 <`nand`> which gets tiring but seems to be reliable
02:57:10 <aninhumer> `nand`: I may end up doing that, but Haskell has made me so reluctant to use messy code :P
02:57:31 <`nand`> yeah, it can get ugly fast
02:57:38 <aninhumer> I found the th-build library which looks like it might help
02:58:00 <`nand`> http://hub.darcs.net/nand/units/browse/src/Units/TH.hs#77 <- horrendously ugly
02:58:10 <latermuse> When can is it possible to use two functions in a tuple? For instance let meow = (head, init) in meow [1..5] doesnt work
02:58:14 <aninhumer> It might be nicer if the structres were records as well
02:58:58 <`nand`> always fun to see a library that starts with ‘class Convertible a b where convert :: a -> b’
02:59:25 <`nand`> aninhumer: that library looks useful though
02:59:40 <`nand`> I'm tired or writing crap like AppT (AppT (AppT (AppT ...) (AppT (... ...
02:59:43 <`nand`> s/or/of/
03:00:05 <aninhumer> I'm not sure if it actually fixes that, although I did see something on a mailing list for that
03:00:15 <`nand`> the example in the package description suggest it does
03:00:28 <`nand`> oh
03:00:32 <`nand`> maybe it doesn't
03:00:57 <`ramses> > let meow = liftA2 (,) head init in meow [1..5] -- latermuse
03:00:59 <lambdabot>   (1,[1,2,3,4])
03:01:17 <`ramses> latermuse: something like that?
03:01:20 <`nand`> appsE' ['not, 'True] -- it seems to provide this though
03:01:44 <`nand`> latermuse: because tuples are not functions; you can't apply them
03:01:48 <neutrino> edwardk: thanks
03:01:56 <`nand`> > let meow = (head, init) in fst meow [1..5]
03:01:58 <lambdabot>   1
03:02:10 <`nand`> :t fst
03:02:12 <lambdabot> (a, b) -> a
03:02:17 <`nand`> :t fst `asAppliedTo` (head, init)
03:02:18 <lambdabot> ([a] -> a, [a1] -> [a1]) -> [a] -> a
03:02:27 <aninhumer> `nand`: Oh I didn't see that, neat (mostly because those functions were all so formulaic)
03:03:04 <aninhumer> `nand`: In fact they're generated with a script based on the TH library source
03:04:07 <neutrino> `nand`: i can't make sense of it. how do you define the function? and then how do you invert it?
03:04:08 <`nand`> aninhumer: still, it would be awesome to figure out how to use quotes like that correctly
03:04:23 <`nand`> neutrino: you define it with ‘iso’, and invert it with ‘from’
03:04:42 <`nand`> neutrino: I define one in line 23; and invert it in line 29
03:05:05 <`nand`> that example could probably be cleaned up with liberal use of syntax sugar
03:05:42 <aninhumer> Oh I see why I didn't see it, I was looking for appsT', I might add one actually
03:06:01 <latermuse> interesting, cool example `ramses
03:06:04 <hpaste> “`nand`” annotated “Isomorphic” with “Isomorphic (prettier operator)” at http://hpaste.org/79743#a79746
03:10:19 <`nand`> edwardk: handling l = flip (catching l) ?
03:11:25 <edwardk> `nand`: yeah, like handle and catch
03:11:43 <edwardk> ou can also use throwing and throwingTo, throwingIO, etc.
03:11:58 <RoboTeddy> is there a good reason why "[2,4..] !! 1000000000" is slow? I'm totally new to haskell, and just curious -- it seems like there's a simple shortcut the compiler could take
03:12:06 <edwardk> this lets you deal with the hierarchical exception system directly as a bonus
03:12:26 <edwardk> throwing underflow ()    builds an arithException directly
03:12:28 <`nand`> RoboTeddy: because you generate 1000000000 elements of a list then discard the first 999999999
03:12:36 <edwardk> throwing arithException Underflow works too
03:12:52 <RoboTeddy> `nand`: right, but why's it actually bother generating the unused elements?
03:12:53 <`nand`> RoboTeddy: the compiler isn't smart enough to know that it can be done in constant time
03:12:59 <Moggle> RoboTeddy: a list isn't an array is why
03:13:12 <`nand`> RoboTeddy: the compiler just sees the definition of (!!), it doesn't know any of its properties
03:13:19 <`nand`> and (!!) is defined on lists in a recursive way
03:13:31 <RoboTeddy> OK
03:13:35 <RoboTeddy> thanks
03:13:36 <edwardk> i'll be adding Control.Monad.Error.Lens with similar tricks for doing catching, etc. in any MonadError
03:13:52 <shachaf> Moggle: An array would be even worse.
03:14:36 <`nand`> you could overload the notion of ‘sequencies’ and indexing and have EnumFromThen as some sort of static representation of ‘enumeration sequences’, with given laws associated with indexing them
03:14:40 <`nand`> s/sequences/
03:15:01 <`nand`> (forgot the first half of that s///, never mind)
03:15:05 <neutrino> `nand`: right, i see now
03:15:18 <neutrino> `nand`: but here, you have to write code that transforms code in both directions
03:15:25 <neutrino> i only want to have to define one direction, and not the other
03:15:33 <`nand`> oh
03:15:49 <`nand`> right, so you want to automatically generate an inverse just by looking at the definition of the function?
03:16:02 <neutrino> i mean it's easy to write a pair of functions, it's more difficult to do that
03:16:03 <neutrino> yes
03:16:20 <`nand`> yeah I have no idea how that'd be possible in general, or even how to determine /if/ it's possible for a given function
03:16:54 <edwardk> neutrino: http://www.iai.uni-bonn.de/~jv/ssgip-bidirectional-final.pdf is the best approach i know so far
03:16:59 <edwardk> they even have a website you can play with
03:17:14 <edwardk> they don't generate legal lenses though, just improper lenses of the second kind
03:17:43 <neutrino> `nand`: we've been over this already. it's 100% certainly not possible in general.
03:17:55 <neutrino> `nand`: the idea is to find a technique of defining functions with which it is possible.
03:17:59 <neutrino> edwardk: looking
03:19:46 <edwardk> i had a close encounter with an improper lens of the third kind once, but i quickly ran away
03:20:41 <`nand`> as long as it wasn't an indecent lens
03:20:56 <edwardk> well, it was _quite_ improper, i'll just say that ;)
03:21:14 <`nand`> and now we know why edwardk is so obsessed with lenses
03:21:36 <shachaf> Lens Int Char Bool Float
03:21:57 <shachaf> We need Lens# for unboxed lenses
03:22:16 <edwardk> shachaf: using the unsafeCoerced lens again i see
03:22:40 <`nand`> module Unsafe.Coerce.Lens where ..?
03:22:50 <elliott> shachaf: Come on, all those types even have the same kind.
03:22:52 <edwardk> its been a running joke that elliott wanted to add it
03:22:56 <elliott> you're not trying hard enough!
03:24:05 <aninhumer> Oh, turns out appsE was in the TH lib anyway, I guess I'll submit a request for appsT
03:24:08 <neutrino> edwardk: i've considered the residue approach. it's not viable if you want to accept external input which does not contain the residue.
03:24:25 <neutrino> edwardk: it's a pretty good idea if carry the residue around anyways
03:24:39 <edwardk> aninhumer: great then all my lens code will break ;) (we define it locally)
03:24:47 <neutrino> automatic computation of the residue is useless though, you have to do it by hand
03:24:56 <neutrino> otherwise you might as well be writing prolog
03:25:03 <edwardk> neutrino: hence why i just let you write isomorphisms and compose them =P
03:25:09 <`nand`> edwardk? complaining about code breaking due to API changes?
03:25:13 <`nand`> what madness is this
03:25:22 <ciaranm> THIS. IS. HASKELL.
03:26:11 <edwardk> its mostly that the one i have locally is nicer and less partial than the craptastic one they'll implement =P
03:26:34 <aninhumer> edwardk: Submit a patch?
03:26:58 <edwardk> aninhumer: doesn't help, i change the API. and i support TH back to ~2.4 or so so i have to deal with all the permutations anyways
03:27:24 <neutrino> edwardk: yeah, i am guessing if you have some simple isomorphisms to use as building blocks then you could compose your code in blissful ignorance of that fact
03:27:31 <edwardk> all it would do is break my ability to use the ones they do have
03:27:38 <LucasCampos> Hello there. I've written a small benchmark, using fourth order Runge-Kutta. Haskell's version is around 60x slower than C++ version. Is that an expected result?
03:27:42 <edwardk> neutrino: thats kind of what lens is all about
03:27:44 <neutrino> of the fact that the basic building blocks are defined by duplicate code
03:28:02 <neutrino> edwardk: can you explain?
03:29:03 <hpaste> LucasCampos pasted “RK.hs” at http://hpaste.org/79747
03:29:15 <edwardk> i mean that lens provides you with lots of composable bits of slightly directional code. a prism can be read from and you can chain ti with a lens with a getter, etc. each of those imposes some constraint on the result. but you can try to stick to isomorphisms and get something that is fully reversible, slip in a prism and only get one way, etc, slip in a lens and only get the other
03:29:27 <aninhumer> Honestly TH seems like a pretty experimental thing to offer support for in the core lens?
03:29:34 <startling> LucasCampos, maybe. You're probably not doing things as efficiently as you could
03:29:36 <aninhumer> *lens library
03:29:42 <edwardk> TH has been around in the haskell community longer than I have
03:29:43 <`nand`> LucasCampos: you could try using a proper vector library for starters
03:29:58 <edwardk> and makeLenses is a large part of how lenses are made usable
03:30:20 <aninhumer> edwardk: Oh sure, I just meant TH.Lens
03:30:33 <edwardk> I use Language.Haskell.TH.Lens internally in Lens.
03:30:39 <aninhumer> heh
03:30:43 <edwardk> the combinators there are the reusable bits others might want
03:30:57 <edwardk> e.g. for traversing all of the free variables in a type
03:31:13 <elliott> aninhumer: well lens provides TH stuff to generate lenses
03:31:20 <elliott> so it makes sense it should support TH in general
03:31:44 <startling> edwardk: that's neat
03:31:44 <edwardk> in general the goal is lens is to come batteries included for the platform and whatever lens uses internally
03:31:56 <edwardk> since those types can't be instantiated by anyone else without orphans
03:32:02 <startling> edwardk: like a more general DeriveFunctor, but for traversals?
03:32:09 <aninhumer> Hmm, maybe I should just use TH.Lens instead of complaining about TH... :P
03:32:19 <edwardk> startling: makeLenses will build a traversal
03:32:31 <edwardk> aninhumer: you need to use both together, the TH.Lens stuff just supplements
03:32:37 <startling> edwardk: sure. I'm asking about <edwardk> e.g. for traversing all of the free variables in a type
03:33:10 <LucasCampos> `nand` and startling: I'll give the 'default' one a try. Thanks. But for future references, what order of slowness am I to expect when comparing Haskell to C++?
03:33:34 <`nand`> not possible to find a general figure like that
03:33:38 <neutrino> edwardk: yeah, that sounds like what i'm after
03:33:42 <aninhumer> Although if I can work out how quoting works, it would be even nicer
03:33:42 <startling> LucasCampos: 'default'?
03:33:47 <`nand`> both Haskell and C++ code can come in more or less efficient varieties
03:33:56 <edwardk> startling: i mean i literally have typeVars :: HasTypeVars t => Traversal' t Name
03:34:00 <`nand`> well-optimized Haskell can be in the same order of magnitude as well-optimized C++ though
03:34:05 <neutrino> edwardk: i think being able to write reversible FRP code could be an answer
03:34:07 <LucasCampos> startiling: The one downloadable from Cabal, according to http://www.haskell.org/haskellwiki/Numeric_Haskell:_A_Vector_Tutorial
03:34:09 <`nand`> or even faster
03:34:13 <startling> edwardk: right, very cool
03:34:15 <edwardk> startling: with instances for Type, Pred, Con, Name, etc.
03:34:33 <`nand`> it depends way too much on the specifics involved
03:34:34 <startling> LucasCampos: I wouldn't call it "default", but okay
03:35:05 <edwardk> neutrino: i've pretty much given up on FRP and started playing with the functional hybrid modeling approach. different goals, entirely more tractable and a much nicer story for how to deal with the fiddly continuous bits
03:35:11 <`nand`> but a slowdown of 60x can definitely be improved upon
03:36:03 <`nand`> functional hybrid modelling?
03:36:25 <bourbaki> Half functional half christmas elf.
03:36:53 <edwardk> @google functional hybrid modeling
03:36:57 <lambdabot> http://www.cs.nott.ac.uk/~nhn/Publications/padl2003.pdf
03:36:57 <lambdabot> Title: Functional Hybrid Modeling
03:37:21 <edwardk> `nand`: it fits with the system of DAE solvers that i've been working on
03:37:54 <edwardk> @hpaste
03:37:54 <lambdabot> Haskell pastebin: http://hpaste.org/
03:38:08 <hpaste> edwardk pasted “monadic fhm” at http://hpaste.org/79748
03:38:18 <edwardk> `nand`: see the paste for a sample
03:38:19 <LucasCampos> `nand`: Thanks
03:38:59 <edwardk> :=, Signal and der are defined by the modeling framework
03:39:50 <`nand`> I'd probably be more capable of comprehending that paste if I knew the slightest thing about electronics
03:40:21 <edwardk> well, the idea is that you build up a system of differential agebraic equations by stating equalities between them,
03:40:32 <edwardk> so 'cap' introduces a new variable (or set of variables)
03:40:43 <edwardk> cup says all of its arguments are equal
03:40:52 <edwardk> and you cn use := to introduce additional equalities
03:41:10 <`nand`> and ‘der’ for derivative?
03:41:12 <edwardk> so there i make up the notion of a 'Pin' which has a 'voltage' and 'current' on it. and you can great a pin with 'cap'
03:41:14 <edwardk> `nand`: yeah
03:41:24 <edwardk> der takes a derivative with respect to time
03:41:34 <Peaker> why does Fay use imperative setters for stuff like "setSrc"?
03:42:07 <edwardk> so to make a twoPin model basically i'm choosing to take one pin as an argument (its symmetric, i could flip the whole thing over), using cap to make up the other pin, saying that the sum of their currents is 0 is a constraint on the system
03:43:14 <edwardk> and then giving you back the new pin, and the delta voltage. you can use delta voltage in your equations for the two pin system. basically i'm saying given one pin i'll give you another pin and an abstract quantity that represents the voltage drop between them.
03:43:20 <edwardk> then you can use things like
03:43:23 <Peaker> edwardk, btw, I transliterated a little toy from Python to Haskell for fun and showing off, and due to the unimportance of it all, allowed myself to import everything unqualified. I had collisions with Lens names :P
03:43:32 <edwardk> resistor r p = basic p $ \u -> r * p^._i := u
03:44:04 <edwardk> which says that a resistor causes a voltage drop equal to the resistance * the current
03:44:09 <beaky> hello
03:44:35 <edwardk> which is acausal and non-directional. you can let current flow across the resistor in either direction
03:44:40 <`nand`> right
03:44:41 <edwardk> you can't inspect a signal directly
03:44:51 <edwardk> you can specify triggers for when a signal crosses another signal, etc.
03:44:57 <edwardk> and i can root find for whe that happens
03:45:08 <edwardk> and on events you can trigger new equations to come into effect
03:45:19 <edwardk> but this means that the 'continuous' portion of the code is really continuous
03:46:34 <edwardk> this also lets you write some pretty neat combinators like transpose :: (Connector a, Connector b) => (a -> Model b) -> b -> Model a
03:47:27 <edwardk> transpose amb b = do a <- cap; b' <- amb a; cup [b,b']; return a
03:47:28 <neutrino> edwardk: what is functional hybrid modeling?
03:47:40 <edwardk> neutrino: everything i've said for the last 40 lines ;)
03:47:53 <neutrino> ok looking
03:47:57 <neutrino> i'm still in the scrollback
03:48:05 <bourbaki> I do not think that this really models physical systems though.
03:48:17 <bourbaki> It is like with that Watts thingy.
03:48:25 <bourbaki> You can not model this.
03:49:41 <edwardk> bourbaki: i have a stochastic variant that i'm exploring for other purposes. i'm using the DAEs mostly for convenience and compositionality. stochastic DAEs arise in finance, since you can (fairly naively) model stocks as an ito process, and then any function of them is an ito process, which is a stochastic process that fits the framework, etc.
03:50:09 <edwardk> so if you wanted to add johnson noise to the resistor you'd need to use a stochastic version of model.
03:50:30 <edwardk> where you can add johnson noise as brownian motion
03:50:45 <HugoDaniel> so many people here
03:50:58 <edwardk> but then i can't do strict simulation for many models
03:51:05 <bourbaki> Aye
03:51:07 <edwardk> and can only do weak evaluation
03:51:13 <edwardk> which is fine for my purposes
03:51:38 <bourbaki> No real solutions in simulation :(
03:52:12 <edwardk> i'm mostly interested in getting something that works 'pretty well' across a number of domains and lets me mix stochastic DAEs with a nice bayesian network, using a generalization of girolami and calderhead's: http://www.dcs.gla.ac.uk/publications/PAPERS/8980/GP_Inference_NIPS2008_FINAL.pdf
03:52:57 <edwardk> that lets me avoid solving the differential equations directly, punting the problem to part of the metropolis hastings sampler.
03:53:23 <edwardk> which makes all of this much more tractable for non-linear ODEs, non-linear DAEs, and my final goal non-linear stochastic DAEs
03:53:33 <edwardk> sadly lens has taken all my time up in the last couple of months
03:53:38 <edwardk> so the DAE project is stalled a bit ;)
03:53:46 <bourbaki> :)
03:54:53 <edwardk> anyways i'm not really interested in simulation per se so much as describing a model that happens to have a bunch of differential algebraic components in it, and then applying that to real data to test for fit, draw bayesian posterior estimates from, etc.
03:55:02 <neutrino> edwardk: what is amb?
03:55:14 <edwardk> amb is a crime against nature
03:55:23 <neutrino> huh?
03:55:33 <edwardk> its a combinator for 'racing' two computations that comes up in FRP.
03:55:39 <edwardk> oh
03:55:42 <edwardk> wait, thats unamb
03:55:44 <edwardk> nm
03:55:49 <edwardk> amb is perfectly cromulent ;)
03:55:57 <neutrino> i meant the amb parameter in "transpose"
03:56:01 <edwardk> oh
03:56:01 <neutrino> what is it?
03:56:03 <edwardk> haha
03:56:09 <edwardk> thats just the function from (a -> Model b)
03:56:23 <edwardk> a m b  a -> model b
03:56:40 <edwardk> its a bad hungarianish notation i use in my head
03:57:02 <edwardk> which is hilarious given how much i hate hungarian notation
03:57:23 <neutrino> yeah i'll make you some lecho or something
03:57:30 <shachaf> edwardk only hates good Hungarian notation.
03:57:34 <shachaf> Hungarian notation and UML diagrams. What's next?
03:59:25 <bourbaki> edwardk: Who was that again with the arrow graphs?
03:59:26 <tdammers> shachaf: XML, probably
03:59:36 <edwardk> augur
03:59:43 <bourbaki> augur: There :)?
03:59:58 <`nand`> {-# LANGUAGE PostfixOperators #-} (++) :: (Num a, MonadState s m) => ASetter' s a -> m ()
04:00:10 <`nand`> or Enum a, whatever
04:00:26 <edwardk> `nand`: if those were happier about being naked on a line with layout syntax around, i'd be all about it ;)
04:00:59 <edwardk> but we don't really have all the pieces in the parser for good prefix and postfix operators
04:01:00 <bourbaki> Will Haskell eventually get thiese mixfixes from Agda?
04:01:10 <bourbaki> these
04:01:12 <bitonic> `nand`: {-# LANGUAGE MixfixOperators #-} _++_ ...
04:01:18 <bitonic> well well bourbaki
04:01:28 <edwardk> (its funny because we have prefix/postfix in the compiler we use here, but we gave up sections to get them)
04:01:37 <edwardk> bourbaki: unlikely
04:01:45 <bourbaki> Meh
04:02:32 <edwardk> mixfix parsing can be pretty slow actually
04:04:23 <mvj4_> why aren't functions such as 'length' polymorphic in the return type? (usage of Int is wide spread)
04:04:47 <bitonic> mvj4_: ease of usage and historical reasons
04:04:51 <Jafet> :t genericLength
04:04:52 <lambdabot> Num i => [b] -> i
04:05:08 <mvj4_> ah, sweet. any particular package for these generics?
04:05:10 <edwardk> mvj4_: because length is an order of magnitude faster than genericLength
04:05:11 <elliott> and efficiency (partially outdated)
04:05:28 <mvj4_> I see.
04:05:31 <Jafet> genericLength' = fromIntegral . length
04:05:44 <bitonic> edwardk: you can simply SPECIALISE `genericLength'
04:05:51 <edwardk> Jafet: when i hand you a 5 billion item list, then that can suck ;)
04:06:12 <`ramses> mvj4_: they're in Data.List
04:06:28 <edwardk> bitonic: i tend not to rely on SPECIALIZE pragmas firing, its a bit of a mess
04:06:42 <bitonic> edwardk: fair point
04:07:08 <Jafet> > maxBound :: Int
04:07:10 <lambdabot>   9223372036854775807
04:07:23 <edwardk> i tend to just write on own ToFloat, ToDouble classes rather than rely on the abomination that is the semantics change RULES pragma on realToFrac, etc.
04:07:24 <latermuse> > (head &&& tail) [1..10]
04:07:26 <lambdabot>   (1,[2,3,4,5,6,7,8,9,10])
04:07:33 <latermuse> neat :)
04:07:41 <edwardk> if i can avoid needing a RULE and get what i want with inlining i'm much happier
04:07:58 <edwardk> even worker wrapper transforms are fairly fragile
04:08:08 <edwardk> since when they _don't_ happen your performance tanks
04:08:40 <edwardk> with lens we spend a disturbing amount of time looking at core for some a high level library
04:08:56 <elliott> by "we" edwardk means "shachaf and then me"
04:09:04 <elliott> (whereby "me" I mean me)
04:09:08 <edwardk> me too, less so now that you are here ;)
04:10:12 <edwardk> Jafet: the maxBound assumption there assumes you're on a 64 bit platform
04:10:17 <aninhumer> Hmm TH seems to be turning my type splice into a type variable, perhaps I'm misunderstanding how the renamer works? http://hpaste.org/79745 (annotation)
04:10:59 <shachaf> edwardk: Inlining also doesn't always happen.
04:11:09 * shachaf is seeing concrete cases of that right now. :-(
04:11:20 <edwardk> aninhumer: i'd tend to switch tt to just use 'T rather than a splice for sanity
04:11:42 <edwardk> shachaf: yeah, but its more reliable than RULES at least
04:12:06 <edwardk> clearly we need to import the inline function and sprinkle it more liberally
04:12:22 <Ghoul_> (head . tail)[1..10]
04:12:28 <Ghoul_> > (head . tail)[1..10]
04:12:30 <lambdabot>   2
04:12:45 <Ghoul_> What, I don't even.
04:12:56 <Ghoul_> Oh actually, it makes sense.
04:12:59 <Ghoul_> The head of the tail
04:13:02 <edwardk> > head (tail [1..10]
04:13:02 <aninhumer> edwardk: I'm using this more generally to try and work out how it works
04:13:04 <lambdabot>   <hint>:1:19: parse error (possibly incorrect indentation)
04:13:04 <edwardk> > head (tail [1..10])
04:13:07 <lambdabot>   2
04:13:18 <Ghoul_> Hehe, thanks edward.
04:13:28 <Ghoul_> Daily dose of haskell over, back  to learning dvorak
04:13:40 <aninhumer> edwardk: In my actual use case t is a passed argument, so I don't have a 'T
04:14:03 <edwardk> aninhumer: honestly i just don't use splices for much TH code generation
04:14:25 <aninhumer> indeed, that seems to be the general opinion...
04:14:28 <edwardk> i find it almost always just screwed up in funny places like instance heads, etc.
04:15:03 <edwardk> and there are some places where no decision it could make are right, etc.
04:15:30 <edwardk> so i just hand roll the syntax tree using the combinators. its noisy, its ugly, but it works reliably
04:15:39 <aninhumer> Back to picking apart structures manually then I guess...
04:16:00 <aninhumer> I'll look at what TH.Lens can do anyway
04:17:12 <bourbaki> Is there any manga or anime on FP btw :) ?
04:25:40 <neutrino> edwardk: hey.. so why did you give up on FRP?
04:26:33 <edwardk> neutrino: because i find that it is an inherently leaky abstraction. the monadic frp formulation is nice to look at but leaks, and the arrow/applicative based ones make me want to claw my eyes out
04:27:07 <edwardk> almost everyone i know who works on FRP gets stuck at some point, and they aren't dumb people
04:27:35 <neutrino> maybe you need someone who's dumb
04:27:41 <neutrino> like me
04:27:42 <neutrino> :D
04:27:47 <edwardk> ipwn hired Cale for chrissakes, and while they seem to think they have the issue licked, they still didn't ship a product =P
04:28:19 <edwardk> anyways the pain seems to indicate to me that its just subtly the wrong abstraction
04:28:42 <edwardk> i'm curious to see what the right abstraction is, but it doesn't make me want to get up out of bed in the morning and code all day
04:28:45 <neutrino> edwardk: i'm thinking FRP is a unidirectional thing.. if there were a bidirectional version of FRP that would fit my needs exactly.
04:28:46 <edwardk> i work on the stuff that does
04:29:05 <edwardk> reversible FRP is basically FHM =P
04:29:24 <neutrino> yeah, but not really
04:29:33 <edwardk> anyways, the FHM problems strike me as tractable
04:29:42 <edwardk> it doesn't need magic
04:29:49 <edwardk> and it fits inside of haskell's semantics
04:29:55 <shachaf>   indexed   :: p a b -> i -> a -> b
04:29:56 <shachaf> Er.
04:30:03 <neutrino> FHM is an equation solver, FRP is a stochastic system
04:30:18 <neutrino> so inside they're fairly different, aren't they
04:30:24 <neutrino> also in what they can really do
04:30:36 <edwardk> and i've got toys for adding brownian motion and bayesian inference to FHM
04:30:46 <edwardk> FRP is a mishmash of fake continuity and real discrete events
04:31:03 <edwardk> FHM is at least honest about the continuous parts
04:31:37 <edwardk> they aren't comparable directly, but out of that 'tree of technologies' the FHM branch is the one that strikes me as more likely to bear fruit.
04:31:37 <neutrino> i'm not really looking for a continuous domain
04:32:12 <neutrino> right
04:32:18 <edwardk> for discrete domains i have machines, conduits, etc.
04:32:22 <Cale> Arrow as it is in the libraries isn't the right abstraction, but something close to it is quite good.
04:32:29 <zomg> Oh I just thought about the dumbest joke ever regarding... "brownian motion"
04:32:36 <Cale> (for FRP)
04:32:37 <zomg> I think I'll save it for some other day
04:32:38 <zomg> lol
04:32:38 <neutrino> Cale: what is that close thing?
04:33:22 <edwardk> zomg: in that light continuous brownian motion also takes on a whole new meaning
04:33:29 <zomg> lol
04:33:30 <Cale> Well, throw in all the stuff which is required of a symmetric monoidal category, for one.
04:34:02 <neutrino> what else?
04:34:32 <Cale> Add a law that says (f >>> g) *** (h >>> k) = (f *** h) >>> (g *** k)
04:34:55 <Cale> (which is actually included in what I said before ;)
04:35:02 <neutrino> are you going to release something like this at some point?
04:35:10 <romildo> ghc-mod with GNU Emacs 24.2.1 on gentoo linux is giving the error with C-c C-t : ghc-show-type: Wrong type argument: listp, Dummy:0:0:Error:Could
04:35:13 <romildo> Any clues?
04:35:46 <Cale> Yeah, at some point we should hack out a decent fragment of our library for this and release it
04:36:00 <neutrino> that sounds pretty cool.
04:36:09 <Cale> We have a custom preprocessor for proc/do notation which uses the extra widgets
04:36:10 <neutrino> what do you think about my general problem? invertible transformations?
04:36:57 <neutrino> i guess i should summarize it to you
04:37:40 <Cale> Basically, the thing which makes Arrow the wrong thing for most applications is the fact that the main reason you'd want to use Arrow over Monad, say, is that both parameters to (>>>) are of a type which you define (and so have some chance of being able to inspect), while (>>=)'s right parameter is a function which is essentially a black box.
04:38:09 <Cale> But the fact that you're almost forced to stick 'arr' in between every pair of computations ruins this
04:38:26 <neutrino> the idea is that you have a complex type (say S), and a simple type (say T, for example Int), and you write a function f :: S -> T which is 1-1. I want to be able to write f in such a way, and with such tools, that you can instantly get g :: T -> S such that f . g = g . f = id.
04:38:31 <Cale> because the function parameters to arr are black boxes again
04:40:12 <neutrino> Cale, OK
04:40:22 <Cale> So if you add in some more stuff to explicitly wire things around (swapping and reassociating pairs, introducing and eliminating units), and make the preprocessor use it, you can rescue your ability to do analysis. In fact, you probably don't even need to completely remove arr, just reducing how much it gets used goes a long way.
04:40:44 <neutrino> Cale that makes sense, being able to inspect things. but i must say i've never written monadic code that was complex enough that i couldn't inspect it.
04:40:59 <neutrino> so maybe i cannot appreciate the issue in depth
04:41:16 <Cale> neutrino: I'm talking about the 'run' function for the computations being able to inspect and simplify them before it executes them
04:41:24 <shachaf> class (Profunctor p, Prismatic p, Lenticular p, ArrowLoop p, ArrowChoice p, RepresentableProfunctor p, CorepresentableProfunctor p) => Indexable i p where
04:41:24 <Cale> Not by-hand inspection
04:41:26 <neutrino> hmm
04:41:28 <neutrino> ah
04:41:29 <shachaf> (Don't worry, that class isn't here to stay.)
04:41:39 <Ghoul_> someone should spend days writing fusion declarations
04:41:44 <Ghoul_> for the sake of optimization
04:42:35 <neutrino> Cale: yes, that makes sense indeed
04:42:40 <Cale> neutrino: an implementation of x >>= f typically just has to execute x before it can know anything about what f's result will be, and if that turns out to be something which means that the work done in computing the result of x was not required, then too bad.
04:43:07 <neutrino> Cale: i can see how STM, and in general any monad with expensive operations, could become much better
04:43:15 <Ghoul_> unless, someone introduced submonads
04:43:17 <Ghoul_> ;D
04:43:23 <Cale> Well, I haven't thought about STM, but yeah, maybe :)
04:44:03 <neutrino> Cale: am i on the right track with the objective being "optimizing away expensive operations" as far as understanding your comment on "being able to inspect things" goes?
04:44:12 <Cale> yeah
04:44:16 <neutrino> or *one* objective
04:44:20 <edwardk> shachaf: that is a placeholder =P
04:44:29 <neutrino> you could possibly use this also to make things more powerful, right?
04:44:39 <neutrino> notice parts of the system that can be generalized
04:44:41 <edwardk> the class is there to stay, the superclasses are temporary visitors while i figure out the right abstraction
04:44:57 <Ghoul_> So uh, hows the performance of ghc atm
04:45:02 <shachaf> I know. I just enjoy that combination of words.
04:45:08 <Ghoul_> have we beaten java yet
04:45:18 <Cale> neutrino: Basically, with a better version of Arrow, you can extract a typed heterogeneous code graph expressing your entire computation before it runs, and manipulate it and simplify it.
04:45:29 <hiptobecubic> Ghoul_, that question is too ambiguous
04:45:36 <Cale> neutrino: It does require some heroism, but it's at least possible :)
04:45:36 <bourbaki> Cale: Graphs of arrows?
04:45:39 <shachaf> Cale: Wouldn't a better version of Arrow be great?
04:45:56 <shachaf> It turns out that lenses are related to a lot of arrow operations, by the way.
04:46:12 <neutrino> Cale: that sounds like a pursuit very worth following
04:46:43 <neutrino> Cale: what do you think, is my problem that i described above a good fit for FRP/Arrow?
04:46:46 <bourbaki> Is there any way to restore the missing files here  ? http://www.haskell.org/haskellwiki/Graph_processing_and_representation_(Graep)
04:47:21 <Ghoul_> tbh just kick LLVM up the ass
04:47:28 <Ghoul_> and theres your grandious performance boost
04:47:40 <Cale> Ghoul_: ?
04:47:47 <Ghoul_> or anyhow, find a better way to express haskell to LLVM
04:47:56 <edwardk> bourbaki: Does it come in Graep? or are there other flavors
04:48:04 <neutrino> bourbaki: uhh, try archive.org?
04:48:05 <edwardk> er does it only come
04:48:19 <bourbaki> edwardk: pardon?
04:48:22 <Cale> Ghoul_: What would you recommend we do to the existing LLVM backend?
04:48:24 <Ghoul_> because last I heard the reason we're having so much performance issues with llvm versus the classic backend is, despite llvm being great at what it does, it's hard to express haskell in a llvm style.
04:48:46 <Ghoul_> often meaning the classic ghc backend has a much easier time optimizing than LLVM
04:48:49 <edwardk> "pardon? has to be the most effective rebuttal to any attempted pun ever.
04:49:02 <Ghoul_> that'd change if the LLVM IR were to become something purely functional, which imo, wont happen.
04:49:04 * Ghoul_ sad
04:49:42 <bourbaki> edwardk: :) I am pun proof.
04:49:42 <Cale> The LLVM backend is okay, but the new code generator sounds much cooler.
04:50:02 <hiptobecubic> there's another new code generator?
04:50:13 <Ghoul_> ^
04:50:14 <Ghoul_> what he said
04:50:16 <Ghoul_> I had no idea.
04:50:20 * neutrino pokes Cale because his question was more honest than Ghoul_'s :P
04:50:29 <Cale> I mean the Hoopl stuff.
04:50:36 <Ghoul_> wheres the thesis on this
04:50:38 <Ghoul_> I wanna read.
04:50:52 <Cale> neutrino: You could do that with just Category.
04:51:07 <neutrino> how would i do that with Category, Cale?
04:51:10 <Cale> neutrino: You'll have to specify all the parts that things are made of.
04:51:30 <neutrino> Cale: go on
04:51:37 <Cale> data Bijection a b = B (a -> b) (b -> a)
04:51:45 <Cale> ^^ do that, define composition and identity
04:52:20 <neutrino> well that still requires me writing the a -> b part separately from the b -> a part
04:52:20 <shachaf> Cale: Did you hear the "cool new way" to define bijections?
04:52:21 <neutrino> right?
04:52:34 <Cale> shachaf: Yes, I know about lens.
04:52:47 <shachaf> Well, you don't need to use lens, just profunctors!
04:52:51 <shachaf> Or invariant functors.
04:52:54 <edwardk> Cale: bah, you should use type Iso s a = forall p. Profunctor p a a -> p s s
04:53:04 <edwardk> for you bijection type. no category
04:53:25 <shachaf> That lets you compose bijections with (.)!
04:53:54 <shachaf> (Invariant f => f a -> f b also lets you do that.)
04:54:07 <edwardk> Cale: or type Iso s a = forall p f. (Profunctor p, Functor f) => p a (f a) -> p s (f s)    which makes them the same as Lens's new rep
04:55:11 <edwardk> under the pure profunctor representation though, 'iso' = 'dimap'
04:55:12 <Cale> I'm not sure this helps neutrino
04:55:15 <edwardk> which is pretty awesome ;)
04:55:43 <edwardk> true
04:55:45 <Ghoul_> Are there any proven performance benefits
04:55:47 <Ghoul_> on using hoopl
04:55:50 <edwardk> i'll shut up and let you help neutrino
04:56:17 <shachaf> In my experience, neutrino doesn't care to be helped.
04:56:25 <Ghoul_> bijections?
04:56:56 <Taneb> Ghoul_, not relevant to your question, I think
04:57:31 <neutrino> Cale: the idea is to only have to write one piece of code, which works "in both directions". you can't do that with the Category approach you mentioned, right?
04:57:40 <neutrino> i'm not really sure..
04:59:37 <Ghoul_> Oh, I know it wasnt relevant
04:59:52 <Cale> neutrino: Well, once you have enough building blocks...
05:00:45 <neutrino> Cale: right, but i'm thinking, there has to be a way to define even those building blocks in a syntax that would "compile down" to the two directions being separate
05:00:58 <neutrino> for example, something like     a <-> b + 1
05:01:11 <johnw> neutrino: if you wrote a function a->b for which you wanted to auto-generate the inverse b->a, how would you even go about determining that a->b is bijective?  For example, the function "const 10" is not invertible
05:01:57 <neutrino> f :: A -> B; f a = a-1; g :: B -> A ; g b = b + 1
05:02:22 <neutrino> johnw: i wouldn't, i would just write it in such a way that i know it is.
05:02:37 <johnw> say you represent your domain and codomain as finite bijective sets, then inversion is just a swap operation on the two sets
05:02:47 <neutrino> johnw: besides, the idea doesn't seem to be able to *invert* functions, the idea is to be able to define functions in both directions at once
05:02:57 <neutrino> look at the two code snippets i just gave as an example
05:03:41 <`ramses> neutrino: I kinda compare this with the problem of inverting an index, given a huge search tree ordered on keys (the input to the function in one direction) you can lookup the value (the output of that function). But I don't think you can go the other way without just scanning the tree
05:03:44 <johnw> so what you want is an DSL for total bijective functions that makes it easy to define the isomorphism in by only defining "one half"?
05:04:29 <neutrino> `ramses: a search approach is not viable
05:04:35 <`ramses> except if you can use algebra to invert your first function
05:04:37 <neutrino> johnw: something like that, yes
05:04:48 <`ramses> neutrino: no, that's what I thought :)
05:05:06 <`ramses> but is that what you want to do?
05:05:31 <neutrino> `ramses: is a search what i want to do? no.
05:06:00 <`ramses> no, but is that the problem, that given such an index (a function in this case) you want to invert it?
05:07:08 <neutrino> yes
05:07:56 <johnw> neutrino: i suppose if you create your definitions only by composing known invertible "building block" functions, then the composition should be invertible
05:08:27 <johnw> but you'll have to lay the groundwork by creating that set of operations
05:08:30 <`ramses> I don't think that's possible without doing a search for general functions
05:08:42 <neutrino> yeah
05:09:10 <`ramses> and a search is not an option either if the domain and codomain are uncountable (maybe not even aceptable if they are countable infinite)
05:09:49 <`ramses> except indeed when you can do symbolic manipulations on algebraic expressions
05:09:55 <neutrino> `ramses: the idea isn't to do this for general functions. the idea is to write functions in such a way that this is possible.
05:11:01 <`ramses> like provide a set of functions that may be used (and for which you implement the inversion) and composition to chain them?
05:11:23 <johnw> `ramses: yeah, that's what I suggested too
05:11:36 <neutrino> yes, that was my original idea
05:11:54 <neutrino> the question is how to provide as few such functions as possible, i guess
05:12:10 <johnw> well, that's actually the easy part
05:12:56 <`ramses> I think the possibilities would remain fairly limited though, unless you allowed for something like lambda's as well, but those are not necessarily invertible...
05:12:56 <johnw> use a category based on Cale's idea of an Iso
05:12:59 <neutrino> how do you mean?
05:13:05 <johnw> that way, you can only compose isomorphic functions
05:13:24 <johnw> then whenever you run into something you can't do, you need to create a new instance
05:13:29 <johnw> but wait, this is just how things work today! :)
05:13:30 <neutrino> i think you mean only compose isomorphisms that form a chain
05:13:48 <johnw> yes
05:13:53 <neutrino> hmm yeah
05:14:00 <johnw> the composition of Isos must be an Iso, by definition
05:14:12 <neutrino> why is using Cale's category a better idea than just using simple types?
05:14:38 <johnw> because the Category let's you take advantage of all the other category theoretical machinery
05:14:49 <neutrino> like what?
05:14:53 <neutrino> i've never worked with those.
05:14:57 <johnw> one could imagine you designing Functors over these morphisms, and then Monads from them, etc.
05:15:25 <johnw> by basing your logic on the Category type class, you gain several abstractions "for free"
05:15:38 <johnw> if you base it on simple type, you'll have to re-work out all that stuff fro yourself
05:16:16 <johnw> or rather, you don't gain abstractions, but you gain sanity checking on the more complex abstractions you'll build on top of them in future
05:16:40 <johnw> you're really defining a sub-category of Hask in which every arrow is an instance of Iso
05:16:54 <johnw> a whole invertible world
05:17:03 <johnw> let's call it HaskInv
05:17:09 <johnw> or IsoHask
05:17:54 <johnw> it would be interesting to see what kinds of algebras are possible in that sub-category
05:18:22 <johnw> like, the Endo monoid would be invertible too
05:18:41 <johnw> and the Cont monad would be a strange thing as well
05:19:21 <neutrino> hmm
05:19:22 <johnw> for the State monad, if it were possible, knowing any state and value you'd be able to recover the previous state
05:19:38 <neutrino> let's call it HasksaH
05:19:40 <neutrino> ;)
05:19:45 <johnw> lol
05:19:51 <johnw> i don't think the State monad is invertable
05:20:01 <johnw> s-> (s, a) gains structure
05:20:12 <neutrino> well, yes and no
05:20:38 <johnw> unless you define the inversion such that a is irrelevant?
05:21:01 <neutrino> you are confused because you're going from a simple type (s) to a more complex type with redundant information (a)
05:21:29 <neutrino> here's one such example: Integral a, Integral s => a = 2 * s
05:21:57 <neutrino> you can't invert this function because what will you do for a = 3?
05:22:21 <johnw> also, in HasksaH I think there would be a natural transformation from any covariant functors to the corresponding contravariant functor
05:23:00 <johnw> anyway, it's a need idea, neutrino
05:23:07 <johnw> i'd start banging it out in code at this point, if I were you
05:23:11 <neutrino> so the idea is to create null domains. you go Integral a, Integral s, Integral n, Null n => a ~ 2 * s | 2 * n + 1
05:23:43 <neutrino> and you're told, if you end up going from a to a null then you've messed up and should get an exception
05:23:59 <`nand`> edwardk: so what's the state of the MonadicTraversal / Action stuff? How limited are they, and is anything planned for their future?
05:24:15 <`nand`> edwardk: for example, I wonder if it would be possible to, right now, define monadic traversals/folds for libmpd
05:24:22 <`nand`> like a traversal over all songs
05:24:28 <`nand`> or traversals into folders into songs
05:24:35 <edwardk> you can fold but not traverse
05:24:47 <edwardk> that isn't likely to get better barring a breakthrough
05:24:48 <`nand`> yeah a fold would work I guess
05:25:03 <shachaf> What would a monadic traversal look like?
05:25:13 <shachaf> I mean, if it didn't need to fit into the twanvl framework
05:25:47 <neutrino> johnw, Cale, & co thanks for the feedback
05:26:19 <edwardk> shachaf: thats the problem it doesn't fit most sensible variants of the framework. maybe separate getters and setters with monadic effects
05:26:36 <edwardk> but then you're back to something fclabels-ish and can't reason about them very well
05:26:37 <neutrino> ohh, this looks even better: a ~ interleave s n
05:26:46 <neutrino> yep, definitely
05:27:34 <shachaf> What's an example of a monadic traversal you'd want?
05:29:09 <elliott> shachaf: That tables stuff but on a real db?
05:29:14 <elliott> Sort of.
05:29:34 <edwardk> shachaf: A monadic lens for an IORef value
05:29:41 <edwardk> then compose that with a traversal of a list of IORefs
05:30:29 <shachaf> Hmm.
05:31:05 <shachaf> Does that let you do an IO computation to change the type or just a pure function?
05:31:36 <edwardk> It probably should permit IO actions
05:31:51 <`nand`> edwardk: would it be possible to store a Tape based on some criteria other than index numbers?
05:32:09 <edwardk> `nand`: hrmm. quite possible
05:32:26 <edwardk> `nand`: we could in theory use the index for the traversal and let you walk any indexed traversal
05:32:35 <edwardk> we'd have to shake up the internal representation quite a bit
05:32:38 <edwardk> but it makes sense
05:33:07 <elliott> won't that make the core even worse? :P
05:33:35 <edwardk> probably within would take a traversal used indexing on it, and then iwithin would give you an indexed traversal
05:33:39 <edwardk> elliott: not too much worse
05:34:24 <elliott> hmm, would this let you zip into a map and go to specific keys?
05:34:28 <neutrino> btw, does anyone know if threads that retry forever get GC'd?
05:34:28 <elliott> in a nice way
05:34:30 <elliott> that would be pretty cool
05:34:48 <neutrino> you know, like even ones defined as: forkIO $ atomically retry
05:34:49 <shachaf> elliott; You can already do that, can't you?
05:35:10 <shachaf> Are you talking about moving left and right in a map and remembering the index?
05:36:37 <`nand`> edwardk: I'll detail the use case: imagine some directory hierarchy where the user is in charge of navigating to the ‘correct’ directory via leftward/rightward as well as ‘entering’ directories via ‘within’. Now imagine having to refresh this directory structure, potentially replacing anything. The intended behavior for here is to record the directory breadcrumbs of where the user was (eg.
05:36:39 <`nand`> foo/bar/bat/baz) and then ‘replay’ that in the new environment as far as possible, simply halting on failure
05:37:28 <shachaf> `nand`: What happens if you do left/right after you've descended into a directory "directly"?
05:37:29 <`nand`> if it's assumed that directory names are unique, their name could also be their index
05:37:51 <`nand`> shachaf: not sure what you mean; during replaying or just normally?
05:38:06 <edwardk> shachaf: i'd want two things, the ability to jump to particular keys in an indexed traversal, and the ability to make it so when you restore a tape you go to the appropriate key, not ordinal position
05:38:25 <shachaf> edwardk: Ah, so left/right wouldn't work at all?
05:38:34 <edwardk> left/right would work
05:38:38 <edwardk> they'd move ordinally
05:38:46 <`nand`> edwardk: yeah that should work for my purposes
05:38:49 <edwardk> to the next thing left or right of you in the indexed traversal
05:39:09 <shachaf> But how do you know what the thing left or right of you is without traversing all the way up to that point?
05:39:13 <shachaf> Well, I suppose you could still do that.
05:39:24 <shachaf> I guess you'd have to.
05:39:38 <edwardk> i'm basically saying use an indexed traversal and smash the index in there with the a in the list zipper
05:39:41 <shachaf> So the point is that the structure could change slightly but you could still go to the same index.
05:39:55 <edwardk> [(i,a)] i a [(i,a)]
05:39:58 <edwardk> yeah
05:40:17 <shachaf> How do you know whether to go left or right when you "jump" to an index?
05:41:11 <edwardk> also i'm somewhat curious if i can make a nicer representation that doesn't linearize by describing the 'path' down into the series of mappended values
05:41:31 <`nand`> conceptually, my directory structure is ~ newtype Dirs v = Dirs (Map String (Either v (Dirs v)))
05:41:34 <edwardk> shachaf: that could be a linear scan from the start, and/or smart combinators for working with sorted indexes
05:41:45 <`nand`> or, more simply, Map String (Map String (Map String ...
05:41:54 <`nand`> so traversing into each value while remembering the key would be enough
05:42:15 <edwardk> we could go so far as to make a subtype of Indexed for OrderedIndexed
05:42:24 <edwardk> and then make the maps etc return that
05:42:32 <shachaf> Yay, subtyping.
05:42:37 <edwardk> yep
05:42:45 <edwardk> its what lens is good at
05:42:52 <shachaf> FSVO "good"
05:42:55 <edwardk> we break our brains so the user doesn't have to
05:43:09 <shachaf> Except for the whole rank-2 types everywhere thing. :-(
05:43:59 * hackagebot fay 0.11.0.0 - A compiler for Fay, a Haskell subset that compiles to JavaScript.  http://hackage.haskell.org/package/fay-0.11.0.0 (ChrisDone)
05:45:15 <shachaf> edwardk: Ugh, thinking about setters for IORefs doesn't make me happy.
05:47:30 <edwardk> shachaf: yeah it particularly annoying, but if done right then foo .= 12 could chain through IORefs, etc.
05:48:56 <shachaf> IORef a -> a -> IO () is nothing like s -> a -> s
05:49:28 <augur> edwardk, hey sup
05:49:57 <edwardk> augur: bourbaki was going on at length about the kind of categorical graph reduction mumbo jumbo that you like so much
05:50:01 <edwardk> so i referred him to you ;)
05:50:18 <augur> edwardk: what
05:50:23 <augur> the kind of what
05:50:46 <edwardk> all of your composable theory stuff and theory transformations, etc.
05:51:15 <augur> edwardk: ok. whats that got to do with categorical graph reduction??
05:51:35 <edwardk> you just had lots of graph-related problems and a very similar way of encoding it to what he was talking about
05:51:41 <edwardk> and i punted him your way =P
05:52:14 <nunquam> suppose I have a function: plus1 = map(\x -> x+1)
05:52:30 <augur> edwardk: i had graph related problems? ok
05:52:41 <nunquam> result: plus1 [1,2,3] = [2,3,4]
05:52:52 <edwardk> > map (+1) [1,2,3]
05:52:52 <nunquam> I dont understand why this works
05:52:54 <lambdabot>   [2,3,4]
05:52:59 <nunquam> I would write it like this:
05:53:00 <edwardk> :t map
05:53:01 <lambdabot> (a -> b) -> [a] -> [b]
05:53:17 <nunquam> plus1 list = map(\x -> x+1) list
05:53:23 <edwardk> map takes 1 argument function and then gives you back a function from [a] -> [b]
05:53:26 <shachaf> nunquam: map is a function that takes a function and gives you back a function
05:53:38 <edwardk> read that as (a -> b) -> ([a] -> [b])
05:53:42 <nunquam> yes I know how map works
05:53:55 <edwardk> a -> b -> c -> d -> e   = a -> (b -> (c -> (d -> e)))
05:53:56 <elliott> it's not about how map works, really
05:54:00 <elliott> it's about how passing arguments works in general
05:54:03 <nunquam> yes!
05:54:09 <edwardk> what i'm saying is that you can always under apply the function arguments
05:54:14 <edwardk> and get a function for the remaining args
05:54:16 <nunquam> I am used to always write arguments in my function clauses
05:54:20 <edwardk> plus1 is doing just that
05:54:25 <elliott> "plus1 list = ..." is the same as "plus1 = \list -> ...", if that helps.
05:54:32 <elliott> There's nothing special about defining a value that happens to be a function.
05:54:46 <elliott> So since "map (\x -> x+1)" is a function, it's perfectly OK to say "plus1 = map (\x -> x+1)"
05:55:03 <edwardk> there are good reasons not to bother plumbing the extra arguments in terms of lowering cognitive overhead, implementation efficiency, etc.
05:55:17 <Jello_Raptor> nunquam: I think it's called autocurrying, but (+1) and (\x -> x+1) are the same, you're applying '+' to one argument, so '(\ a b -> a + b) 1' becomes '(\ b -> 1 + b)'
05:55:18 <shachaf> nunquam: In general Haskell has the nice rule that if you have "x = y", and you see an x somewhere, you can replace it with a y and your program will work the same way.
05:55:29 <shachaf> So, plus1 = map (\x -> x + 1)
05:55:37 <shachaf> (plus1) [1,2,3]
05:55:41 <nunquam> aha
05:55:43 <shachaf> (map (\x -> x + 1)) [1,2,3]
05:55:48 <shachaf> It's just substitution.
05:55:54 <Jello_Raptor> (sidenote: how the hell do the rest of you type so bloody fast?)
05:55:56 <nunquam> there's autocurrying everywhereeee
05:56:00 <augur> i feel elliott's explanation is cleaner
05:56:07 <augur> nunquam: its not about autocurrying, its about eta-equivalence
05:56:22 <augur> f x = y   is the same as   f = \x -> y   (more or less)
05:56:32 <augur> \x -> f x   is the same as   f   (more or less)
05:56:34 <edwardk> augur: sadly as we've been finding more and more with lens \x -> f x   and f aren't _quite_ the same ;)
05:56:36 <elliott> I feel shachaf's explanation is cleaner :P
05:56:51 <augur> edwardk: hence why i said more or less!
05:56:56 <augur> :)
05:57:00 <nunquam> thanks for massive input anyways ;)
05:57:05 <augur> you and your lenses
05:57:11 <nunquam> shachaf I find easiest to understand too
05:57:22 <edwardk> augur: did you see the video?
05:57:52 <augur> edwardk: your recent one? part of it. the slides were too small to read so i had to stop like 10 minutes in
05:58:10 <edwardk> augur: there is a link to a PDF for the slides in the description
05:58:21 <augur> oh, ill check it out again then
05:59:04 <edwardk> you can read the slides if you crank it to 1080p as well, but the separate slides are probably saner
06:00:29 <shachaf> augur: You can look at the video in full-screen
06:00:35 <shachaf> It was pretty readable, mostly.
06:00:47 <augur> ill give that a try too
06:02:31 <nunquam> is there anyway to see in GHCI how functions are implementend?
06:02:41 <nunquam> I know you can see the type with ":t filter" e.g.
06:03:15 <elliott> augur: http://vimeo.com/56063074 is zoomed in
06:03:19 <edwardk> if you use hoogle or something to search and find the haddocks there is usually a source link
06:03:20 <elliott> so you might have an easier time seeing the slides
06:03:35 <edwardk> elliott: the trade off there is the loss of the closed captioning
06:03:49 <edwardk> the captions for the first 50 minutes or so are pretty handy
06:04:01 <edwardk> in case you find my mumbling hard to follow
06:06:08 <elliott> yeah
06:06:20 <elliott> I should get round to actually watching the whole thing, I've only seen a few minutes of it :)
06:13:30 <bitonic> nunquam: no
06:13:36 <erlnoob> hi i noticed that the not equal operator is /= any reason/history/relation to this and why != was not chosen? seems peculiar to me :/
06:13:44 <elliott> ≠
06:13:57 <erlnoob> oh ok
06:14:25 <elliott> I don't think there's any particular reason it's not (!=) other than (/=) being closer to the mathematical notation
06:14:31 <elliott> just one of the quirks of the language
06:14:36 <ciaranm> ! isn't negation
06:14:46 <Jafet> @let (!=) = (/=)
06:14:48 <lambdabot>  Defined.
06:15:02 <elliott> ciaranm: and / is division
06:15:02 <erlnoob> sure, makes sense if one would just cross their eyes, /= will eventually be ≠
06:15:51 <augur>  /= is a test of commitment!
06:16:21 <Jafet> =\ =/ =|
06:16:30 <bartavelle> isn't there a function somewhere with type "ThreadId -> IO()" that waits for a thread to complete ?
06:17:22 <bartavelle> this seems quite useful, and it doesn't seem to belong in Control.Concurrent
06:18:45 <nunquam> Can someone tell me how "foldr (\x y -> (x+y)/2) 2 [1,2]" works?
06:19:12 <elliott> > foldr (\x y -> (x+y)/2) a [b,c]
06:19:14 <lambdabot>   (b + (c + a) / 2) / 2
06:19:15 <nunquam> ((2+1)/2 + 2)/2
06:19:18 <nunquam> ?
06:19:19 <elliott> > foldr (\x y -> (x+y)/2) a [b,c,d,e]
06:19:21 <lambdabot>   (b + (c + (d + (e + a) / 2) / 2) / 2) / 2
06:19:41 <elliott> > foldr (\x y -> (x+y)/2) 2 [1,2] :: Expr
06:19:43 <augur> nunquam: the general structure of a foldr is like so:
06:19:43 <lambdabot>   (1 + (2 + 2) / 2) / 2
06:20:05 <augur> foldr f z xs   replaces the [] in xs with z, and replaces all :'s with f
06:20:09 <nunquam> wow seems like I totally don't get it yet
06:20:19 <elliott> > foldr f z [a,b,c,d]
06:20:21 <lambdabot>   f a (f b (f c (f d z)))
06:20:26 <elliott> nunquam: That might help a bit.
06:20:40 <Jafet> http://foldr.com
06:20:55 <augur> nunquam: since [1,2] is really (1:(2:[])) underlyingly, or just  (:) 1 ((:) 2 []) using prefix notation
06:21:02 <augur> replace [] with z, and (:) with f
06:21:09 <augur> foldr f z [1,2] = f 1 (f 2 z)
06:22:17 <nunquam> mmm ok
06:22:27 <augur> nunquam: think of it this way
06:22:28 <nunquam> gonna practice it :p
06:22:40 <augur> (:) and [] are the two constructors for lists
06:22:47 <nunquam> yes
06:23:01 <augur> the type is, say, a -> [a] -> [a] and [a] respectively
06:23:21 <augur> what foldr does is generalize this so that it doesnt HAVE to be [a] there.
06:23:23 <augur> it can be anything
06:23:29 <augur> a -> b -> b and b respectively
06:23:59 <augur> so its giving you the "equivalent" of a list using alternative "constructors"
06:24:24 <nunquam> ok thanks absorbing it :p
06:24:31 <augur> its not quite equivalent, of course, nor are they necessarily constructors
06:25:10 <augur> also keep in mind: folding over the constructors gives you the list back out for obvious reasons
06:25:22 <augur> foldr (:) [] xs == xs because you replace [] with [] and (:) with (:)
06:25:40 <augur> nunquam: it might also help to consider folds for other structures too, like trees:
06:26:06 <augur> data Tree a = Leaf a | Branch a (Tree a) (Tree a)
06:26:26 <augur> foldTree :: (a -> b -> b -> b) -> b -> Tree a -> b
06:26:35 <augur> er
06:26:41 <augur> that should be (a -> b) for the second arg
06:26:46 <augur> foldTree f z (Leaf a) = z a
06:27:11 <augur> foldTree f z (Branch a l r) = f a (foldTree f z l) (foldTree f z r)
06:27:35 <augur> notice how here we're replacing Leaf with z, and Branch with f
06:27:48 <augur> so Branch 1 (Leaf 2) (Leaf 3) becomes f 1 (z 2) (z 3)
06:28:16 <Jello_Raptor> how can I make this more efficient? (ideally in a way that'll actually change the complexity by more than a constant factor, I plan to implement wheels and stuff that'll optimize by a constant factor later)
06:28:19 <hpaste> “Rohit Ramesh” pasted “prime sieve” at http://hpaste.org/79753
06:28:38 <Jello_Raptor> ^ that's what i'm looking to optimize
06:29:14 <augur> nunquam: does that make sense?
06:30:01 <nunquam> it is starting to make some yes :)
06:31:12 <augur> nunquam: perhaps a good way to get used to the idea would be to implement a number of functions using just folds
06:32:23 <augur> nunquam: try doing filter and map with foldr for lists, maybe some sort of node count with the tree fold, and maybe try implementing a toy language for simple mathematical expressions, writing the evaluator with a fold
06:33:39 <augur> you'l notice that there are some clear connections to the case-analysis versions of these functions. for example, the b arguments are the recursively computed values, so in place of a recursive call, you have the b argument
06:33:51 <augur> because the fold itself does the recursion
06:34:51 <augur> thats really what folds are, you see: structural recursion combinators. any function that can be defined by recursing on the structure of the data is a fold, iinm
06:35:55 <system64> Need help installing ghc via brew on OSX. Not able to get the REPL working :(
06:42:15 <nunquam> what is a function between quotes?
06:42:24 <nunquam> `f`
06:42:40 <ciaranm> > 3 `elem` [1, 3, 5]
06:42:40 <Jello_Raptor> nunquam: it's infix
06:42:41 <lambdabot>   True
06:42:52 <ciaranm> > (+) 2 3
06:42:54 <lambdabot>   5
06:43:01 <Jello_Raptor> so 'mod 2 3' => '2 `mod` 3'
06:43:06 <nunquam> oh
06:43:08 <nunquam> th
06:43:11 <nunquam> anks
06:43:30 <augur>  it'd be nice if you could infix arbitrary expressions :(
06:43:51 <Jello_Raptor> nunquam: also they're not quotes, they're that tick mark thing under the tilda
06:44:04 <augur> oh, nunquam, you might also want to read some of the algebra paper by gibbons
06:44:16 <Jello_Raptor> (it took me bloody forever to debug that when I was leaning haskell)
06:44:17 <ciaranm> ` isn't under ~!
06:44:28 <augur> nunquam: all of this fold stuff makes a lot more sense if you understand how algebraic datatypes are _algebraic_
06:44:58 <Jello_Raptor> ciaranm: on US keyboards they're on the same key, '`' is without shift, and '~' is with the shift
06:46:34 <nunquam> got that :)
06:47:05 <nunquam> foldr (\x y -> (x+y)/2) 0 [1,2,3]
06:47:26 <nunquam> = (1 lambda (2 lambda (3 lambda 0)))?
06:48:16 <nunquam> lambda = (\x y -> (x+y)/2)
06:49:06 <beaky> hello
06:53:01 <neutrino_> you can type ` by typinc compose ' '
06:53:05 <neutrino_> typing
06:53:48 <augur> nunquam: no i dont know what that means
06:54:01 <augur> oh i see
06:54:14 <augur> well, 1 `lambda` (2 `lambda` (3 `lambda` 0))
06:54:26 <augur> you need to use `-` if you want to write it infixly
06:55:20 <neutrino_> oh no, sorry, compose '' gives you the right tick: ´
06:59:39 <fmap> is there something like HashMap in ST?
06:59:57 <tromp> > 175354*1.18
07:00:00 <lambdabot>   206917.72
07:00:17 <Jafet> unsafeIOToST
07:00:48 <elliott> fmap: http://hackage.haskell.org/package/hashtables
07:01:43 <fmap> elliott: oh, nice, thanks
07:17:31 <lsdafjklsd> If I want to start hacking around in haskell, but have no reason, what is a good task to do?
07:17:46 <lsdafjklsd> I've always programmed in the web domain too
07:18:25 <ciaranm> write a compiler
07:18:32 <ciaranm> write a constraint solver
07:19:45 <pnielsen> lsdafjklsd: http://projecteuler.net/
07:19:52 <johnw> i was going to recommend euler too
07:20:03 <pnielsen> and http://www.haskell.org/haskellwiki/H-99:_Ninety-Nine_Haskell_Problems
07:20:06 <lsdafjklsd> thanks guys, had to google 'constraint solver'
07:20:47 <beaky> write a roguelike
07:21:05 <fmap> with monoids
07:21:11 <beaky> and lenses
07:21:18 <companion_cube> and constraint solvers
07:21:29 <ciaranm> in fact forget about the monoids and the lenses
07:21:35 <johnw> and burritos wrapped in monads wrapped in spacesuits
07:21:47 <edwardk> iw as going to say i helped someone out with a roguelike the other day, and then realized it was beaky
07:22:17 <lsdafjklsd> haha johnw
07:22:17 <johnw> edwardk: did you not sleep last night?
07:22:30 <johnw> i seem to recall seeing you constantly throughout the entire evening
07:23:05 <edwardk> pretty much
07:24:00 <edwardk> trying to make more stuff 'just work' with indexed lenses, traversals, etc.
07:33:48 <M30W> Merry christmas world!!
07:33:49 <M30W> Tue Dec 25 02:33:31 EST 2012
07:34:24 <hiptobecubic> which EST is that?
07:34:50 <johnw`> yeah, interesting
07:35:11 <ciaranm> extra santa time
07:43:11 <neutrino_> has anyone here used reflection for program configuration?
07:43:51 <johnw`> i've sometimes pondered on how to best configure my programs, yes
07:45:45 <neutrino_> johnw`: http://www.cs.rutgers.edu/~ccshan/prepose/prepose.pdf
07:45:51 <neutrino_> i mean this here
07:45:59 <johnw`> i've seen that, but haven't read it yet
07:48:39 <neutrino_> johnw`: i'm sort of having trouble visualizing what a minimal piece of code involving several configuration values would look like
07:49:25 <johnw`> code that uses AWS which needs a bucket, access key and secret key?
07:50:00 <neutrino_> johnw`: what?
07:50:21 <johnw`> that's a minimal piec eof code that involving several configuration values
07:50:34 <johnw`> or, i don't know what you mean
07:50:37 <system64> How to install ghc on OSX? cant get it working via brew.
07:50:44 <johnw`> system64: what happens?
07:51:01 <johnw`> system64: you can download the binaries and just ./configure --prefix and make install
07:51:01 <neutrino_> johnw`: i mean using the reflection method from the paper
07:51:12 <shanse> system64: get the haskell platform
07:51:24 <system64> REPL isn't working.
07:52:35 <johnw`> you mean, ghci?
07:52:47 <system64> yes
07:53:01 <johnw`> ok, now you get to define "isn't working"
07:53:43 <system64> Lost the exact message, I just uninstalled it. Posted it in the morning here
07:54:02 * hackagebot parallel-io 0.3.3 - Combinators for executing IO actions in parallel on a thread pool.  http://hackage.haskell.org/package/parallel-io-0.3.3 (MaxBolingbroke)
07:54:25 <johnw`> i saw your message at 8:35, but i never saw a link
07:56:04 <system64> Sorry, you want me to paste the whole message?
07:56:21 <johnw`> use hpaste.org
07:57:53 <system64> I actually uninstalled it now. But that was the line that told something going wrong.
07:58:05 <johnw`> i still didn't see a link
07:58:13 <johnw`> did anyone else?
07:59:37 <system64> "The build-tool has reset ENV. --lame-env required."
07:59:49 <johnw`> hmm, doesn't ring a bell
08:00:12 <neutrino_> system64 i think you have a problem with pasting links
08:00:53 <system64> Im reluctant to install it again via brew, takes sometime downloading with my net speed :(
08:01:06 <napping> did you try the platform release?
08:01:26 <johnw`> system64: download this: http://www.haskell.org/ghc/dist/7.4.2/ghc-7.4.2-x86_64-apple-darwin.tar.bz2
08:01:28 <johnw`> untar it
08:01:40 <johnw`> cd into it, run: ./configure --prefix=/usr/local/Cellar/ghc/7.4.2 && make install
08:01:43 <johnw`> then: brew link ghc
08:01:44 <johnw`> done
08:02:20 <neutrino_> ohh i think i finally understand what's going on here
08:02:21 <neutrino_> http://hackage.haskell.org/packages/archive/reflection/1.1.6/doc/html/Data-Reflection.html
08:02:28 <neutrino_> check this out johnw`
08:02:31 <neutrino_> looks fairly simple
08:02:40 <johnw`> actually, the brew recipe has a binary method for doing just what I said
08:03:08 <system64> johnw`: downloading
08:03:41 <EarlGray> hello. I am trying to write a FFI example: interfaces for libdl functions + IO calls
08:03:51 <EarlGray> Is there a way to run a FunPtr ?
08:03:57 <johnw`> you mean, call it?
08:04:34 <johnw`> you need to create a dynamic improt
08:04:35 <napping> yeah, check Foreign.Ptr
08:04:44 <johnw`> look here: http://hackage.haskell.org/packages/archive/base/latest/doc/html/Foreign-Ptr.html#t:FunPtr
08:04:55 <johnw`> it's the third example under "Function pointers"
08:05:07 * zhulikas today mastered State \o/
08:05:17 <zhulikas> implemented a simple Map in terms of State
08:08:22 <latermuse> zhulikas: congrats
08:08:42 <zhulikas> than ks!
08:08:48 <zhulikas> that definitely is a big achievement :D
08:08:58 <latermuse> yeah, state is important
08:10:07 <roconnor> `nand`: thanks
08:25:31 <lolcathost> Not exactly a Haskell language question, but, does anyone here use haskell-mode in Emacs? I am having the following problem - when I use C-c C-b to open GHCi, it opens in a new window below (as if split with C-x 2) instead of a new window to the right (as if split with C-x 3). Has anyone had this problem before? How have you fixed it?
08:25:33 <mreh> my CPP seems to be being ignored in .hsc files when I compile with cabal
08:25:54 <mreh> i've enabled the CPP extension
08:26:22 <mreh> and set cpp-options: -DXXX in my cabal file
08:26:25 <mreh> strange
08:26:28 <napping> lolcathost: there's some emacs variable that controls the threshold for deciding when to split horizontally or vertically
08:27:21 <lolcathost> napping: Yeah, I could set that to nil, but that would mess up with Proof General, which needs to open *two* windows to the right.
08:27:48 <lolcathost> Anyway, I guess I should ask in #emacs.
08:27:49 <lolcathost> ty!
08:28:00 <napping> I actually found that variable trying to fix proof general wanting to split horizontally rather than vertically
08:28:18 <lolcathost> Oh.
08:28:31 <napping> except I've since got a new laptop with a wider screen, and didn't copy over that part of the .emacs, so I don't remember the details
08:30:22 <napping> ah, split-width-threshold, set to something a bit lower than 160
08:30:36 <lolcathost> I will try that.
08:30:45 <lolcathost> ty
08:35:09 <lolcathost> napping: Were you the one who was helping me?
08:35:27 <lolcathost> napping: I just wanted to say it worked like a charm, ty.
08:35:51 <napping> nice
08:43:24 <flebron> Hi, question. Say I'm making a binary search tree. There's no way to make this an instance of Functor, since I'd need the restriction (Ord a, Ord b) in fmap :: (a -> b) -> f a -> f b, right?
08:43:27 <mreh> conditional compilation with cabal seems pretty temperamental, it seems to need a clean before it works
08:43:54 <mreh> that's rubbish actually, I can't even get it to work
08:44:04 <mreh> but CPP options seem to not work without doing a clean build
08:44:16 <shachaf> flebron: If you want to keep the invariant that it's sorted, then there isn't.
08:44:24 <shachaf> flebron: fmap has to allow any type.
08:44:40 <flebron> right, but binary search trees only make sense for Ord types :( how unfortunate.
08:46:52 <neutrino_> :t (<>)
08:46:53 <lambdabot> Monoid m => m -> m -> m
08:47:04 <neutrino_> > [] <> "abc"
08:47:05 <shachaf> flebron: You can still define a mapping function, you just can't call it fmap.
08:47:06 <lambdabot>   "abc"
08:47:12 <neutrino_> > "def" <> "abc"
08:47:13 <lambdabot>   "defabc"
08:48:48 <`nand`> who cares about functors? Just write an appropriately restricted Setter :)
08:51:41 <napping> what does it take to use ConstraintKinds? I get "Not in scope: type constructor or class `Constraint'"
08:51:58 <shachaf> napping: You probably need to import a module that exports it.
08:52:00 <napping> with for example type family Constr (f :: * -> *) (a :: *) :: Constraint
08:52:18 <napping> (after setting ConstraintKinds and XTypeFamilies)
08:52:38 <shachaf> You still need to import it.
08:54:44 <mreh> the difference between h2 and h3 on this page is so tiny http://www.haskell.org/cabal/users-guide/installing-packages.html#controlling-flag-assignments
08:55:01 <mreh> I just spent 20 minutes trying to specify flags in the build phase
08:55:03 <mreh> :)
08:55:44 <hpaste> napping pasted “constrained functor” at http://hpaste.org/79756
08:56:17 <napping> flebron: if you've got enough around, you might try something like that
08:57:48 <napping> or more uniformly with Ctx f :: * -> Constraint
08:57:59 <neutrino_> edwardk: hey, you around? :)
08:58:12 <edwardk> kinda busy, whats up?
08:58:37 <neutrino_> edwardk: i was wondering if you could help me figure out how to use reflection
08:58:43 <neutrino_> edwardk: but if you're busy..
09:03:45 <beaky> hello
09:04:41 <FUT> hi
09:05:14 <beaky> why do modules start with Data. or System. or Control.?
09:05:29 <beaky> and should I use the same convention for all my own modules?
09:06:03 <mreh> beaky, I would consult the report for an explanation
09:06:18 <beaky> ah
09:06:19 <mreh> language report
09:06:28 <beaky> @google haskell98 report
09:06:31 <lambdabot> http://www.haskell.org/onlinereport/
09:06:31 <lambdabot> Title: The Haskell 98 Language Report
09:06:49 <mreh> 2010 is the latest I thought
09:07:02 <byorgey> beaky: it's just convention.  Many modules do not start with Data, System, or Control.
09:07:12 <mreh> http://www.haskell.org/onlinereport/haskell2010/
09:07:40 <byorgey> beaky: generally Data is for data structures, System is for... well, system stuff, and Control is for control structures or abstractions of computation
09:07:52 <byorgey> if your modules fit into one of those, then use the appropriate prefix.  If not, don't.
09:08:10 <mreh> my modules are rarely ever that general :)
09:08:38 <beaky> ah
09:08:48 <beaky> my roguelike has really speciic stuff
09:09:03 <beaky> maybe I can have a Data.GameWorld or Data.Monster
09:09:04 <pnielsen> beaky: a roguelike could be Game.YourGameName.<module1/module2>
09:09:10 <beaky> ah
09:09:10 <monadicity> just how abstract is haskell compared to other languages?
09:09:18 <beaky> what if someone else has the same module on hackage?
09:09:32 <pnielsen> beaky: they won't if your game's name is unique
09:09:50 <beaky> oh
09:09:52 <mreh> monadicity, can you be more specific?
09:10:06 <beaky> my game is called PureRogue
09:10:24 <beaky> doesn't seem taken :D
09:10:34 <pnielsen> monadicity: it CAN be a lot more abstract than most languages, but you don't have to make use of that to use the language
09:10:36 <napping> it's probably best to put everything under a common prefix
09:10:46 <mreh> beaky, I wouldn't worry about it so much, it wont matter unless your package say becomes very popular
09:10:57 <mreh> cf. mtl
09:11:01 <beaky> can I use java-style namespaces like com.beaky.foo?
09:11:14 <beaky> ah guess I shouldn't worry :D
09:11:16 <napping> or rather, anything general enough you might consider putting it under Data could be split as a separate package
09:11:20 <ceii_> beaky: actually when you're writing an application (not a library) it's common to simply use your app name as a prefix, or even no prefix at all
09:11:51 <byorgey> beaky: please don't use com.beaky.foo =P
09:11:51 <mreh> I would prefix a function if you don't expect the user to import the module qualified with some alias
09:12:08 <mreh> import Data.Bytestring qualified as B
09:12:23 <mreh> for example
09:14:04 * hackagebot latex 0.1.0.2 - Parse, format and process LaTeX files  http://hackage.haskell.org/package/latex-0.1.0.2 (HenningThielemann)
09:14:06 * hackagebot bibtex 0.1.0.1 - Parse, format and processing BibTeX files  http://hackage.haskell.org/package/bibtex-0.1.0.1 (HenningThielemann)
09:15:08 <`nand`> monadicity: abstract from what?
09:15:11 <`nand`> monadicity: the hardware?
09:17:34 <`nand`> pnielsen: if your roguelike is an application, rather then a framework, then I would put everything either into the top level; or inside GameName.
09:20:07 <pnielsen> `nand`: you mean beaky?
09:20:58 <`nand`> well, you suggested Game.YourGameName.<module1/module2>
09:21:03 <pnielsen> but yeah, in my particular experience I've had games that were applications, but contained many different libraries related to the game that I imported from other applications. It wouldn't matter much if it were Game.Foo or Foo, but the category existed, so
09:21:14 <neutrino_> does anyone at all know how to use the reflection package?
09:21:23 <neutrino_> i'm completely lost on it
09:21:23 <`nand`> neutrino_: yeah
09:21:28 <`nand`> what part?
09:21:39 <pnielsen> `nand`: so Game.Foonia.Database, Game.Foonia.Levels, Game.Foonia.Environment...
09:21:41 <neutrino_> `nand`: well, let me post some simple code that i'd like to parametrize
09:21:42 <`nand`> there's only two functions
09:21:45 <`nand`> reify and reflect :P
09:22:07 <`nand`> pnielsen: gets a bit tiring to type all that though :)
09:22:16 <`nand`> pnielsen: might just do Database, Levels, Environment if you have a lot
09:22:48 <pnielsen> `nand`: hence why I prefixed it when accessing it from other applications. The module sources became quite ambiguous
09:22:56 <pnielsen> at the very least I would call them Foonia.Environment, etc.
09:24:37 <hpaste> neutrino pasted “reflection problem” at http://hpaste.org/79757
09:24:49 <neutrino_> `nand`: ^
09:29:04 * hackagebot shelly 0.15.3 - shell-like (systems) programming in Haskell  http://hackage.haskell.org/package/shelly-0.15.3 (GregWeber)
09:32:24 <mreh> I'm getting a parse error on input `1', where there isn't even an `1' on that line!
09:34:04 * hackagebot shelly 0.15.3.1 - shell-like (systems) programming in Haskell  http://hackage.haskell.org/package/shelly-0.15.3.1 (GregWeber)
09:35:18 <mreh> if you begin a module name with "Debug" ghc won't compile any file with an import to that module
09:36:10 <mreh> should this be reported?
09:36:37 <dmwit> Wow, really?
09:36:39 * dmwit tests
09:37:02 <mreh> on my system
09:37:09 <mreh> get parser error
09:37:14 <dmwit> works for me
09:37:23 <dmwit> Can you give me slightly more precise instructions?
09:37:47 <dmwit> Also, ghc --version?
09:38:13 <mreh> one second
09:38:46 <hpaste> “`nand`” annotated “reflection problem” with “reflection problem (annotation)” at http://hpaste.org/79757#a79758
09:39:09 <`nand`> neutrino_: ^ this is probably the simplest way to do what you wanted; the downside being that you still have to pass around a proxy
09:39:24 <`nand`> of course, it still escapes these proxies from escaping the usage of ‘reify’
09:39:27 <`nand`> so it's a net win
09:39:33 <`nand`> whoa, newlines broke there
09:40:20 <neutrino_> what about without having to pass around a proxy parameter?
09:40:37 <mreh> dmwit, it works okay when I just write a very simple file
09:40:52 <mreh> which would probably imply i'm doing something wrong :)
09:40:59 <mreh> ghc is 7.4.1
09:41:14 <neutrino_> `nand`: i ask because i've seen the paper mention a way of doing this with phantom type variables..
09:41:19 <`nand`> neutrino_: https://github.com/ekmett/reflection/blob/master/examples/Constraints.hs#L33 <- I uh.. huh
09:42:24 <neutrino_> `nand`: i've looked at Constraints.hs for a longer while, but couldn't make heads or tails of it
09:43:45 <`nand`> I don't know anything about Data.Constraint, unfortunately
09:43:48 <`nand`> it seems to rely on that quite a bit
09:43:58 <mreh> dmwit: I get parse error on `1' on an import declaration all the same
09:44:05 <mreh> want to see the source file?
09:44:17 <neutrino_> `nand`: check the original paper..
09:44:25 <neutrino_> maybe you can understand what's going on?
09:44:32 <`nand`> neutrino_: I have it open, which part are you referring to?
09:44:42 <neutrino_> 5.1
09:44:47 <neutrino_> this paper http://www.cs.rutgers.edu/~ccshan/prepose/prepose.pdf
09:46:12 <neutrino_> `nand`: it looks like they're implementing implicit parameters (promoted to types) by using phantom type variables
09:46:20 <neutrino_> but i have no idea at all how to apply that
09:46:24 <`nand`> oh, right; that works because it's all being pulled into ‘M’; which gets its own Num instance
09:46:34 <neutrino_> something like that yes
09:47:00 <neutrino_> are you able to change your code to use this style?
09:47:26 <`nand`> let me try
09:53:25 <neutrino_> `nand`: thanks. that's really nice of you.
09:57:45 <akegalj> hl
09:59:32 <napping> quit
09:59:33 <dmj> hi, was wondering if someone could answer my question on applicative functors
10:00:06 <dmj> (\x y z -> [x,y,z]) <$> (+3) <*> (*2) <*> (/2) $ 5 == [8.0,10.0,2.5]
10:00:12 <dmj> from lyah
10:00:47 <dmj> it says "The 5 gets fed to each of the three functions and then \x y z -> [x, y, z] gets called with those results."
10:01:31 <flebron> yep
10:01:42 <pmk> that sounds backwards to me
10:01:56 <flebron> well i guess you can see it both ways
10:02:14 <dmj> If the five gets fed first, then the results get evaluated and we have: (\x y z -> [x,y,z]) <$> (8.0) <*> (10.0) <*> (2.5) $ 5
10:02:16 <flebron> i read it as "make this list of 3 functions, and apply 5 to all"
10:02:25 <pmk> that's correct
10:02:57 <dmj> these values are no longer applicatives (Ints aren't applicatives) so it will not work...
10:03:18 <dmj> there is no minimal context to pull them out of
10:03:34 <Botje> dmj: ... <$> ... <*> ... <*> ... constructs a function
10:03:42 <flebron> i read that as first creating "(\x y z -> [x,y,z]) <$> (+3) <*> (*2) <*> (/2)", then applying 5 to that
10:03:46 <pmk> :t (\x y z -> [x,y,z]) <$> (+3) <*> (*2) <*> (/2)
10:03:48 <lambdabot> Fractional t => t -> [t]
10:03:50 <flebron> (or that to 5, idk how "apply" is read :))
10:05:03 <pmk> :t ((\x y z -> [x,y,z]) <$>)
10:05:04 <lambdabot> Functor f => f t -> f (t -> t -> [t])
10:06:04 <dmj> :flebron the "The 5 gets fed to each of the three functions and then \x y z -> [x, y, z] gets called with those results."... The "gets called with those results makes it sound like the 5 gets applied first"
10:06:23 <flebron> yeah i wouldn't say that
10:06:34 <Botje> dmj: that sentence is missing a fragment, i think.
10:06:53 <Botje> when (...<$> ... <*> ... <*> ...) is applied to 5, the 5 gets fed ...
10:07:00 <dmj> :Botje yes, It should read. The "gets called
10:08:00 <dmj> :Botje Yes, "gets called with those results" makes it sound like the 5 gets applied first, is what I meant
10:08:39 <dmj> the ($) ensures that the 5 gets evaluated last though correct?
10:09:22 <Botje> that doesn't matter.
10:09:26 <beaky> hello
10:09:31 <Botje> it's just to save you  from writing parentheses.
10:09:42 <beaky> what kins of things can haskell compilers prove
10:10:06 <prophile> only yesterday ghc demonstrated to me that there was no god
10:10:29 <beaky> lol how
10:10:41 <dmj> I think it solved fermat's last theorem, the way fermat did it.
10:10:53 <fragamus> haha
10:10:57 <fragamus> he didnt
10:11:15 <lispy> beaky: haskell is pretty 'weak' as a logic because _|_ inhabits all the types
10:11:27 <beaky> oh
10:11:33 <fragamus> fermat was a lying liar from livonia
10:11:38 <dmj> :fragmus How do you know? Let me ask ghc and double check.
10:11:43 <beaky> so laziness is a barrier?
10:12:08 <lispy> beaky: no, general recursion
10:12:20 <lispy> :t fix
10:12:22 <lambdabot> (a -> a) -> a
10:12:47 <lispy> :t forever
10:12:48 <lambdabot> Monad m => m a -> m b
10:12:58 <pmk> challenge: write f such that f 'a' == 'b' && f ['a']==['b'] && f [[[[['a']]]]]==[[[[['b']]]]]   -- for any depth of []'s
10:13:01 <lispy> beaky: partiality is also a problem
10:13:03 <plat0> Do church encoded lists have bad performance for particular operations?
10:13:10 <lispy> beaky: take for example, head.
10:13:14 <beaky> ah
10:13:51 <lispy> beaky: undefined is also a problem for logical strength
10:14:13 <beaky> ghc is pretty smart as far as compilers go ^^
10:14:23 <prophile> pmk: that's pretty simple with type classes, no?
10:14:31 <pmk> go for it
10:15:20 <fragamus> hey I found a haskell translation of the old basic game Hamurabi    I am having trouble compiling it with GHC     can anyone tell me how
10:15:22 <cmccann> @quote kmc ints.exist
10:15:23 <lambdabot> kmc says: "Haskell is great, because Curry-Howard!  Proving things in the type system.  We can prove that, uh, Ints exist, unless they're ⊥."
10:15:36 <cmccann> proving things with haskell! :D
10:15:40 <pmk> i made ghc consume all my mac's memory yesterday trying to type-check an equation
10:15:42 <lispy> beaky: and I suppose that if you could show that your code avoids things that weaken the logic then you could prove things with Haskell. There was a paper about this. The loose and fast paper about morally correct programs
10:16:39 <cmccann> lispy, the type system at least ensures your program doesn't prove the wrong thing
10:16:55 <cmccann> either it proves what it claims to, or it proves nothing at all because it never terminates
10:16:55 <prophile> pmk: ah, got it
10:17:34 <`nand`> neutrino_: it seems to hinge on ‘unsafeCoerceConstraint’; so far I still have absolutely no clue how it works, but I have the feeling I'm getting closer
10:17:37 <cmccann> (well, unless you use unsafeCoerce, then all bets are off)
10:17:39 <prophile> pmk: f = const ()
10:17:46 <beaky> haskells type system feels so easy compared to C++
10:17:47 <beaky> why?
10:17:49 <fragamus> hamurabi imports:   Char   Random     IO    Text.Printf
10:18:02 <prophile> pmk: ah, no, misread that
10:18:03 <simpson> beaky: Probably because C++ is stupidly hard.
10:18:09 <prophile> as you were
10:18:13 <beaky> ah
10:18:13 <pmk> heh
10:18:14 <Botje> beaky: you can read it left to right, for one
10:18:37 <fragamus> Could not find module `IO'
10:18:37 <fragamus>     It is a member of the hidden package `haskell98-2.0.0.1'.
10:18:55 <beaky> when i make a type error in haskell, hlint/ghc gets to the point. A C++ template error...
10:19:06 <parcs> that's mostly a compiler problem
10:19:14 <neutrino_> `nand`: mhm ok
10:19:29 <cmccann> I can generate errors from GHC that are as bad as the old C++ template errors.
10:19:37 <cmccann> at least, I used to be able to.
10:19:48 <beaky> ah
10:19:55 <`nand`> neutrino_: I have an idea though
10:20:00 <hpaste> fragamus pasted “hamurabi.hs” at http://hpaste.org/79760
10:20:01 <otters> so why do all C++ compilers have the same problem
10:20:05 <otters> :D
10:20:10 <`nand`> what's happening is that eg. Num (M a s) is unsafely coerced to Num a
10:20:12 <cmccann> barfing up a search stack from exceeding recursion depth in type class instance resolution resulted in pretty hideous error messages
10:20:26 <neutrino_> `nand`: i think you basically do something like unsafeCoerceConstraint :: (fromtype :- totype)
10:20:30 <`nand`> but since M is a newtype, coercing it should have no effect since all of the wrapping/unwrapping gets optimized out, theoretically
10:20:31 <hamid> otters, what?
10:20:32 <pmk> C++ depresses me but hey that's what they pay me to use
10:20:40 <otters> hamid: of convoluted error messages
10:20:44 <neutrino_> right
10:20:45 <neutrino_> go on
10:20:52 <fragamus> need help compiling that hpaste ^^
10:21:00 <hamid> otters, haha. i can say kinda clang is fine.
10:21:10 <`nand`> I'm just still confused about what happens to the mappend_ (reflect a) in the Monoid (M a s) dictionary; in terms of what it does after coercion
10:21:19 <Botje> fragamus: you are compiling with ghc --make, right?
10:21:26 <fragamus> no
10:21:30 <cmccann> pmk, btw with your nested list thing that's easy if the inner-most type is concrete
10:21:43 <cmccann> but awkward otherwise
10:21:49 <pmk> agreed
10:22:03 <zhulikas> can you suggest me some good implementations for State monad?
10:22:16 <hamid> otters, at least most of the time it just point to problem at first error beside generating covoluted error messages.
10:22:18 <pmk> keep State distinct from Church
10:22:21 <zhulikas> like - what could be used for
10:22:28 <cmccann> pmk, it's straightforward with overlapping instances but those are fragile in the presence of polymorphic types
10:23:24 <neutrino_> `nand`: well mappend_ is defined with mappend
10:23:30 <neutrino_> er, the other way around.
10:23:57 <neutrino_> mappend is defined with mappend_, but mappend_ comes from Monoid
10:24:03 <neutrino_> it's a renamed mappend
10:24:06 <cmccann> pmk, (forall r. s -> (a -> s -> r) -> r)  = the theocracy monad?
10:24:15 <neutrino_>   data Def Monoid a = Monoid { mappend_ :: a -> a -> a, mempty_ :: a }
10:24:30 <prophile> pmk: https://gist.github.com/815935a665e80285db39
10:24:36 <lispy> beaky: heh, yeah, someone the other day asked me (about C++ template error messages in gcc), so when does the compiler realize that another hundred lines of output won't help me fix the error?
10:24:42 <`nand`> oh, no, wait; I figured it out
10:24:53 <neutrino_> i think ReifiableConstraint is just a layer of dispatch before you get to Monoid
10:25:03 <neutrino_> `nand`: ok go on
10:25:06 <`nand`> the Reifies s (Def Monoid a) :- Monoid (Lift Monoid a s) isn't being coerced
10:25:10 <`nand`> so that code changes as it is
10:25:32 <`nand`> what's being coerced is just Monoid a <-> Monoid (Lift Monoid a s)
10:25:44 <fragamus> --make does not help
10:25:49 <`nand`> in other words, the code just behave as if it were inside a newtype wrapper all the time
10:25:58 <`nand`> which you can safely coerce because they have no runtime significance
10:26:22 <zhulikas> @src (->) a
10:26:22 <lambdabot> Source not found. :(
10:26:30 <zhulikas> where can I read about (->) ?
10:26:37 <neutrino_> not exactly following there `nand`
10:26:48 <`nand`> hang on, let me try to demonstrate
10:26:51 <neutrino_> but maybe if you manage to make that simple example work it'd be simpler
10:26:56 <neutrino_> exactly
10:27:02 <simpson> zhulikas: Imagine data (->) a b = a -> b
10:27:18 <fragamus> : |
10:27:25 <simpson> zhulikas: AFAIK there's not actually any code backing it; it's just there.
10:27:29 <zhulikas> what about Monad instance for it? :)
10:27:53 <simpson> zhulikas: Well, if you think about it as a type, it seems obvious that you can make a Functor from it, and so forth.
10:28:07 <ciaranm> the monad is worth working out for yourself
10:28:11 <ciaranm> (do it in terms of join)
10:28:15 <simpson> fmap :: (a -> b) -> (e -> a) -> e -> b
10:28:32 <zhulikas> > do { a <- (+5); b <- (+4); return $ a + b) } 5
10:28:34 <lambdabot>   <hint>:1:42: parse error on input `)'
10:28:39 <prophile> zhulikas: return = const, h >>= f = \w -> f (h w) w
10:28:40 <zhulikas> again, I gave this example yesterday
10:28:47 <zhulikas> > do { a <- (+5); b <- (+4); return $ a + b } 5
10:28:48 <lambdabot>   <hint>:1:45: parse error on input `5'
10:28:51 <zhulikas> damn it.
10:28:55 <fragamus> utterly frustrated
10:29:04 <fragamus> nothing works
10:29:08 <zhulikas> :D
10:29:19 <pmk> prophile:  well done!
10:29:46 <zhulikas> > do { a <- (+5); b <- (+4); return (a, b) } 5
10:29:47 <flebron> zhulikas
10:29:47 <lambdabot>   <hint>:1:44: parse error on input `5'
10:29:51 <flebron> > do { a <- (+5); b <- (+4); return $ a + b } $ 5
10:29:51 <zhulikas> FFFUUUUU
10:29:53 <lambdabot>   19
10:29:55 <zhulikas> YES
10:29:57 <zhulikas> THAT
10:29:58 <zhulikas> :|
10:30:18 <flebron> function application can be a bitch
10:30:21 <zhulikas> so I believe this works because of (->) being a monad
10:30:25 <prophile> indeed
10:30:38 <flebron> (->) r is
10:30:41 <zhulikas> yes.
10:30:43 <flebron> ("the reader monad")
10:30:56 <zhulikas> Now let's say a (+5) is Num a => a -> a
10:31:02 <zhulikas> :t (+5)
10:31:03 <lambdabot> Num a => a -> a
10:31:05 <zhulikas> ok.
10:31:07 <flebron> "i'm expecting a value, and as soon as you give me that value, i'll input it to all of my internal functions, and give you a result"
10:31:27 <fragamus> can anyone tell me how to compile that thing
10:31:45 <Botje> fragamus: import System.IO instead of IO, import Random instead of System.Random
10:31:57 <Botje> uh
10:31:58 <zhulikas> flebron, I am not following you
10:32:00 <fragamus> awesome ill try that
10:32:02 <Botje> System.Random instead of Random.
10:32:02 <flebron> i.e. compose a bunch of functions that are expecting one last parameter, as if that parameter already existed. sort of currying for a program
10:32:17 <cmccann> zhulikas, did the SO post I showed you the other day help at all?
10:32:27 <flebron> (->) r is the reader monad because (r -> a) is the type of "i'm waiting for an r, and as soon as you give me an r, i'll give you an a"
10:32:30 <zhulikas> not at all. But I figured out State monad
10:32:41 <zhulikas> and implemented Map in terms of State
10:32:46 <flebron> so you can combine a bunch of functions that are expecting an r, into a single function that expects an r
10:32:51 <zhulikas> but this is a bit trickier magic
10:33:36 <flebron> that is, if f:r->a, and g:r->b, and h:a->b->c, you can "call" h (f _) (g _), and just wait for that r to appear
10:33:44 <zhulikas> <flebron> > do { a <- (+5); b <- (+4); return $ a + b } $ 5
10:33:45 <zhulikas> so
10:33:52 <zhulikas> return $ a + b means...
10:33:53 <flebron> in this way h (f _) (g _) is also a computation that is waiting for an r, and as soon as you give it an r, it can run
10:34:00 <zhulikas> that returned function expects a parameter of the same type
10:34:01 <flebron> const (a+b)
10:34:05 <zhulikas> which is accepted by both a and b
10:34:21 <zhulikas> and when the parameter is given to functions, results will be added
10:34:28 <zhulikas> this sort of makes sense
10:34:36 <flebron> return $ a + b is a function that, when you give it that r, will give you a + b, regardless of the r you passed
10:34:42 <flebron> hence it's const $ a + b
10:34:58 <zhulikas> ( (+5) r + (+4) r)
10:35:01 <zhulikas> sort of like this
10:35:06 <flebron> at that point in the do notation, you've bound a and b from the previous expressions
10:35:11 <flebron> sure, yes
10:35:13 <simpson> Part of the glory of Reader is that every action gets to look at r, and nobody can change it.
10:35:24 <simpson> That's why r is usually called e, and is the *environment*.
10:35:32 <hpaste> “`nand`” annotated “reflection problem” with “reflection problem (annotation) (annotation)” at http://hpaste.org/79757#a79763
10:35:34 <zhulikas> whoa, don't push it :D
10:35:35 <`nand`> neutrino_: ^
10:35:43 <neutrino_> `nand`: looking
10:35:49 <flebron> so if you have (+5) and (+4)
10:35:54 <`nand`> neutrino_: the limitation seems to be that the ‘result variable’ (t a) needs to mention ‘a’
10:35:57 <flebron> these are both "almost values, except you are waiting for an r"
10:36:14 <flebron> as soon as you give them an r, they become values, and you can work with them as if they were values
10:36:26 <zhulikas> what about (+) ?
10:36:26 <flebron> so return $ a + b, which is waiting for that a and b from above, now actually has a and b
10:36:30 <`nand`> neutrino_: so you can't just return arbitrary results with that context, but only ones that mention ‘a’ as last variable
10:36:31 <zhulikas> it takes two arguments
10:36:31 <neutrino_> `nand`: in your version, is a the type of the proxy?
10:36:38 <fragamus> thanks
10:36:44 <`nand`> neutrino_: no, that's ‘s’
10:36:44 <flebron> (+) would be a function
10:36:49 <`nand`> ‘a’ is the concrete type, eg. Integer
10:36:53 <`nand`> the one you're reflecting
10:36:54 <flebron> whereas, as far as you care, (+4) is a value
10:37:01 <neutrino_> `nand`: a is the type of the thing carried by the proxy?
10:37:06 <`nand`> right
10:37:11 <`nand`> ‘a’ is the type of what you ‘reify’
10:37:20 <flebron> (because the things in your monad are things (->) r, so those things are values, and (+4) is of type (->) r)
10:37:40 <`nand`> I probably should have flipped the usage of ‘v’ and ‘a’ in usingT
10:37:43 <`nand`> for clarity
10:38:04 <zhulikas> @djinn (+4) + (+5)
10:38:04 <lambdabot> Cannot parse command
10:38:20 <zhulikas> so this is function composition
10:38:33 <neutrino_> `nand`: ok now what if i wanted to have addTwo return a String?
10:38:34 <zhulikas> somehow this return $ a + b gets transformed into a single function which accepts the argument
10:38:37 <lispy> > (+4) + (+5) $ 2
10:38:38 <lambdabot>   No instance for (GHC.Num.Num (a0 -> a0))
10:38:39 <lambdabot>    arising from a use of `e_1452'
10:38:39 <lambdabot> ...
10:38:41 <neutrino_> `nand`: are you saying it wouldn't work?
10:38:57 <`nand`> neutrino_: not very easily, I think
10:39:01 <flebron> zhulikas, return $ a + b is literally \_ -> a + b
10:39:04 <zhulikas> so how does the transformed function look like? and how is the transfomration made?
10:39:06 <`nand`> let me try
10:39:06 <neutrino_> `nand`: why?
10:39:17 <neutrino_> `nand`: cool :)
10:39:19 <`nand`> neutrino_: because ‘String’ doesn't mention ‘a’
10:39:22 <dmwit> mreh: yeah
10:39:26 <dmwit> (sorry, got disconnected)
10:39:29 <zhulikas> flebron, but it's not...
10:39:33 <dmwit> (...and distracted)
10:39:40 <zhulikas> it's \x -> a x + b x
10:39:47 <neutrino_> `nand`: what if we did getVal :: ( ... ) => m a String?
10:39:54 <flebron> zhulikas, nah
10:39:56 <mreh> dmwit, it only seemed to occur when I had CPP in the file regardless of what I called it
10:40:03 <flebron> well, perhaps haha, i consider it to be const
10:40:05 <mreh> really odd
10:40:19 <mreh> CPP in the file being imported that is
10:40:27 <mreh> not the source file where the parse error was occuring
10:40:46 <lispy> mreh: what was the error? CPP has different tokenization rules than Haskell and you can get syntax errors when combining them
10:40:48 <flebron> zhulikas, return x is \_ -> x
10:40:50 <flebron> i.e. const x
10:40:58 <zhulikas> also, as return $ a + b -- is 'plus' sign working on functions or restricting function argument types to be numeric?
10:41:06 <flebron> it's just the usual + between Nums
10:41:16 <flebron> remember that in do notation, ; means >>=
10:41:28 <mreh> lispy, error on input `1'
10:41:32 <zhulikas> ok....
10:41:47 <zhulikas> <flebron> > do { a <- (+5); b <- (+4); return $ a + b } $ 5
10:41:51 <zhulikas> let's try to rewrite it
10:41:51 <flebron> yes
10:42:06 <mreh> lispy pointing to the first letter of the module name in the import
10:42:19 <lispy> mreh: do you use a haskell identifier containing a single quote (') on the same line as a CPP macro? For example, #define foo(x) ...; foo(something) bar'
10:42:22 <zhulikas> (+5) >>= \a -> (+4) >>= \b -> return a + b
10:42:51 <lispy> mreh: I know the single quote thing confuses CPP, but I don't know if there are other cases
10:42:57 <zhulikas> it's time to look at your given >>= implementation for (->) r
10:43:08 <zhulikas> <prophile> zhulikas: return = const, h >>= f = \w -> f (h w) w
10:43:33 <mreh> lispy, hmm no
10:43:55 <hpaste> “`nand`” annotated “reflection problem” with “reflection problem (annotation) (annotation) (annotation)” at http://hpaste.org/79757#a79764
10:43:57 <`nand`> neutrino_: ^
10:44:01 <`nand`> neutrino_: not very pretty at that point
10:44:02 <flebron> zhulikas, indeed
10:44:15 <zhulikas> ahh, it all fits together
10:44:17 <flebron> a and b are values
10:44:19 <`nand`> but you can certainly propagate the ‘a’ through your entire code by wrapping/unwrapping like that
10:44:20 <lispy> mreh: does the module start with a ghc pragma that has the same name as a CPP define?
10:44:25 <flebron> and will only exist once you give the context to (+4)
10:44:35 <`nand`> neutrino_: but at that point; you might as well just use a proxy
10:44:35 <mreh> lispy, yes :)
10:44:43 <`nand`> neutrino_: actually, this can be simplified
10:44:44 <mreh> ghc pragma?
10:44:44 <flebron> > do { a <- (+5); op <- (+); return $ op a } $ 7 -- zhulikas
10:44:45 <`nand`> let me try
10:44:46 <lambdabot>   19
10:44:54 <mreh> it starts with Debug, which is the name of CPP define
10:44:57 <flebron> do you understand that zhulikas?
10:44:58 <zhulikas> (+5) >>= (+4)     = \x -> (+4) ( (+5) x) x
10:45:00 <lispy> mreh: like {-# LANGUAGE BangPatterns #-}
10:45:13 <flebron> indeed
10:45:15 <mreh> is Debug a GHC pragma?
10:45:24 <mreh> oh I see what you mean
10:45:24 <flebron> the first parameter of +4 is also some value, by induction if you want
10:45:30 <mreh> lispy, no pragmas
10:45:35 <lispy> mreh: not that I know of, but there is a Debug.Trace as a module name
10:45:36 <flebron> because the reader monad promised a value when you gave it an x, and you did, you gave x to (+5)
10:45:41 <zhulikas> <- in do-notation is the same as >>= ?
10:45:44 <mreh> lispy, yeah
10:45:45 <flebron> yes
10:46:23 <zhulikas> ok, things start to make sense
10:46:33 <flebron> the whole do notation is syntactic sugar for >>= and \x ->
10:46:59 <flebron> x <- f  is f >>= \x -> ...
10:47:32 <zhulikas> hmmm
10:47:37 <zhulikas> I should think in terms of >>= here
10:47:49 <zhulikas> x <- f looks a bit weird
10:47:53 <flebron> f >>= \x -> means "run f, and feed its value to the function \x -> ..."
10:48:09 <flebron> this feeding is controlled by the monad
10:48:16 <zhulikas> run f...
10:48:31 <flebron> so sometimes the feeding causes nondeterminism, sometimes it causes failure, sometimes IO, sometimes whatever
10:48:49 <flebron> one way of thinking about the type "m a", with m a monad, is "a monadic computation which returns a value of type a"
10:48:57 <neutrino_> `nand`: looking
10:49:00 <flebron> or "computation within a context"
10:49:43 <flebron> so something like "str <- getLine", means "run getLine, and with the result, call it str and do something with it"
10:49:51 <flebron> in other words, getLine >>= \str -> ...
10:50:02 <zhulikas> :t (do { a <- (+4); b <- (+5); return $ a + b })
10:50:04 <lambdabot> Num b => b -> b
10:50:19 <flebron> that's a value of type m b, with m being (->) b
10:50:24 <zhulikas> :t (do { a <- (+4); b <- (+); return $ a + b })
10:50:25 <lambdabot>     Occurs check: cannot construct the infinite type: b0 = b0 -> b0
10:50:26 <lambdabot>     In the second argument of `(+)', namely `b'
10:50:26 <lambdabot>     In the second argument of `($)', namely `a + b'
10:50:30 <zhulikas> :t (do { a <- (+4); b <- (+); return $ a b })
10:50:32 <lambdabot>     Occurs check: cannot construct the infinite type:
10:50:32 <lambdabot>       t0 = (t0 -> b0) -> t0 -> b0
10:50:32 <lambdabot>     In the first argument of `a', namely `b'
10:50:35 <zhulikas> :t (do { a <- (+4); b <- (+); return $ b a })
10:50:36 <zhulikas> sorry.
10:50:36 <lambdabot> Num b => b -> b
10:51:01 <flebron> indeed
10:51:05 <zhulikas> let me think for a second on how this gets rewritten
10:53:58 <flebron> sorry, got dc'd
10:54:10 <neutrino_> `nand`: :)
10:55:17 <mantovani> hi
10:55:18 <mantovani> http://paste.scsys.co.uk/220302
10:55:31 <mantovani> I'm have a problem to get "words" from the terminal and cast it to numbers
10:55:49 <mantovani> http://paste.scsys.co.uk/220302?ln=on&submit=Format+it%21
10:55:50 <mantovani> line 7
10:55:55 * flebron will brb
10:56:11 <mantovani> "wakeHour sleepHour" are char how I cast it to Num ?
10:58:08 <hpaste> “`nand`” annotated “reflection problem” with “reflection problem (annotation) (annotation) (annotation) (annotation)” at http://hpaste.org/79757#a79765
10:58:08 <otters> reads
10:58:13 <`nand`> neutrino_: here, a nice Monad-inspired interface
10:58:22 <zhulikas> hmmm, interesting constrain
10:58:22 <otters> :t reads -- mantovani
10:58:23 <`nand`> I dropped your ‘m’ but you could add it again (with a nested do-block)
10:58:24 <lambdabot> Read a => ReadS a
10:58:34 <zhulikas> h >>= f = \w -> f (h w) w
10:58:41 <`nand`> ..
10:58:52 <`nand`> neutrino_: it just occured to me that I've essentially reimplemented the Reader monad
10:58:56 <`nand`> except in a very complicated manner
10:58:57 <zhulikas> f has to be of type a -> b -> c or whatever
10:58:57 * `nand` facepalms
10:59:07 <zhulikas> it can't be a -> b
10:59:29 <`nand`> neutrino_: actually, that gives me a great idea
10:59:38 <`nand`> neutrino_: pass the phantom proxy around in a reader
11:00:30 <mantovani> how I use reads otters ?
11:01:20 <otters> does anybody happen to know why ReadS is [(a, String)] instead of Maybe (a, String)
11:01:35 <popl> :t ReadS
11:01:36 <lambdabot> Not in scope: data constructor `ReadS'
11:01:40 <otters> :i ReadS
11:01:40 <ion> otters: The former supports ambiguous parses.
11:01:52 <zhulikas> flebron, thanks for help
11:01:57 <zhulikas> I'll dig into reader monad now :)
11:02:58 <neutrino_> `nand`: looking
11:03:01 <crclark> mantovani: you're forgetting to read on line 6. map  read $ words line
11:03:50 <neutrino_> `nand`: i think the idea is to have the configuration in the type, so that you can't mix things that are configured differently
11:03:59 <neutrino_> `nand`: but a reader will allow this, right?
11:04:33 <mantovani> crclark: thanks
11:04:53 <`nand`> even with a reader you can't escape the quantification in ‘reify’
11:04:58 <crclark> :)
11:04:59 <`nand`> so it prevents mixing configurations
11:06:20 <mantovani> crclark: exsatly how I did to "sum" before line 6.
11:08:18 <crclark> mantovani: you might want to use a let statement so that you aren't doing that twice. Makes things a bit easier to read once your  code gets more complicated.
11:08:32 <lispy> is a crclark similar to a stack canary?
11:09:21 <mantovani> crclark: you are right, I'm just learning after that I optimize
11:09:26 <mantovani> u are right!!
11:09:28 <mantovani> thanks crclark !
11:11:19 <flebron> zhulikas, right, it has to be of that type
11:11:53 <flebron> because if you read "x >>= f", and f is a monadic computation, and in this case being monadic means "it still requires a value"
11:12:02 <flebron> what you get is that "f still requires a value _in order to be a computation_"
11:12:25 <flebron> that is, when you give f a context, THEN it will be a function a -> b
11:15:39 <hpaste> “`nand`” annotated “reflection problem” with “reflection problem (annotation) (annotation) (annotation) (annotation) (annotation)” at http://hpaste.org/79757#a79767
11:15:41 <`nand`> neutrino_: ^
11:15:46 <`nand`> reader-based version
11:16:15 <`nand`> oh, change ‘v <- it’ in line 30 to ‘v <- getEnv’
11:17:11 <`nand`> though you might as well just make a new monad while you're at it, and free up the existing Reader
11:17:16 <lispy> > blowup "bang!"
11:17:17 <lambdabot>   "baannngggg!!!!!"
11:17:27 <lispy> > blowup "This is a test"
11:17:29 <lambdabot>   "Thhiiissss     iiiiiisssssss        aaaaaaaaa          ttttttttttteeeeeeee...
11:17:37 <flebron> :src blowup
11:17:38 <neutrino_> `nand`: hmm
11:17:46 <`nand`> let me go do that
11:17:46 <flebron> @src blowup
11:17:47 <lambdabot> Source not found. Where did you learn to type?
11:17:47 <lispy> blowup xs = go 0 xs; go n [] = []; go n (x:xs) = x : replicate n x ++ go (n+1) xs
11:17:49 <flebron> :((((
11:18:23 <lispy> blowup xs = go 1 xs; go n [] = []; go n (x:xs) = replicate n x ++ go (n+1) xs
11:18:32 <lispy> that version is slighty simpler I suppose
11:19:08 <neutrino_> `nand`: oh that's actually a pretty neat one
11:19:24 <neutrino_> `nand`: don't you think it reduced quite well?
11:22:19 <neutrino_> `nand`: i mean that looks pretty good, and actually it's the only version where i know what's going on :)))
11:23:22 <neutrino_> `nand`: i'm not sure why one would make a new monad though. can you expand on the idea?
11:26:25 <lispy> neutrino_: making a new monad in this case is similar to making a new data type (data Vec2 a = V2 a a, instead of using (a,a)), it helps to express your intent
11:28:18 <siracusa> lispy: blowup = concat . zipWith replicate [1..]
11:29:03 <hpaste> “`nand`” annotated “reflection problem” with “ReifyT” at http://hpaste.org/79757#a79770
11:29:05 <`nand`> neutrino_: &
11:29:07 <`nand`> ^*
11:29:16 <`nand`> the ‘Boring cruft’ would be moved to some library
11:30:30 <`nand`> neutrino_: basically, so you free up Reader for non-reflectory uses
11:30:46 <`nand`> in particular, ReifyT always has to be at ‘the top’ of a stack
11:30:57 <`nand`> when you want to use it with ‘using’
11:31:12 <`nand`> and this way you don't have to concern yourself with the Data.Proxy either as an end-user
11:31:16 <flebron> siracusa: nice
11:34:31 <neutrino_> lispy: ah
11:34:42 <neutrino_> `nand`: mhm
11:34:46 <`nand`> blowup = concat . itraverse replicate
11:34:52 <neutrino_> `nand`: can't i have two readers?
11:34:53 <`nand`> oh, perhaps not
11:35:05 <`nand`> neutrino_: not if you want access to MonadReader niceness
11:35:09 <neutrino_> `nand`: i thought there wasn't an issue with having multiple Reader's in your stack?
11:35:13 <neutrino_> oh ok
11:35:15 <neutrino_> yeah
11:35:20 <`nand`> there isn't, but you have to ‘lift.lift.lift.lift’ manually
11:35:29 <`nand`> also, intent
11:35:41 <neutrino_> haha
11:35:44 <neutrino_> hmm yeah i guess
11:35:46 <`nand`> > concat (itraverse replicate "bang!")
11:35:48 <lambdabot>   ""
11:35:54 <`nand`> well that didn't go as expected
11:36:14 <neutrino_> `nand`: i wonder why oleg didn't do it like this in his paper?
11:36:40 <`nand`> > "bang!"^..indices
11:36:41 <lambdabot>   Ambiguous occurrence `indices'
11:36:41 <lambdabot>  It could refer to either `GHC.Arr.indices',...
11:36:45 <`nand`> yuck, Cale!
11:39:01 <mantovani> I finished!!!
11:39:02 <mantovani> http://paste.scsys.co.uk/220323?ln=on&hl=on&submit=Format+it%21
11:39:04 <mantovani> uhul!
11:39:13 <mantovani> my first computer science olympic problem solved in haskell
11:39:56 <`nand`> oh
11:40:02 <`nand`> > concat (imap replicate "bang!")
11:40:04 <lambdabot>   "annggg!!!!"
11:40:14 <`nand`> starts with 0 instead of 1 :(
11:43:59 <neutrino_> `nand`: that's really weird tbh, that they didn't show such a simple approach
11:44:32 <`nand`> because for his domain, the ‘usual’ approach works
11:44:40 <`nand`> this is just for when you want results that can't live in M
11:45:06 <byorgey> > concat (imap (replicate.succ) "bang!")
11:45:07 <lambdabot>   "baannngggg!!!!!"
11:45:18 <mantovani> dudes
11:45:24 <mantovani> is not working in the SPOJ website
11:45:28 <mantovani> can you help me ?
11:45:33 <mantovani> "compilation error"
11:45:36 <mantovani> but here is fine
11:45:43 <`nand`> byorgey: but at that point, it's probably uglier than zipWith replicate [1..]
11:45:50 <mantovani> they use haskell 6.10.4
11:46:04 <byorgey> `nand`: yes, probably =)
11:46:13 <mantovani> http://paste.scsys.co.uk/220325
11:46:15 <mantovani> look
11:46:22 <`nand`> > ("imap (replicate.succ)", "zipWith replicate [1..]") & both %~ length
11:46:22 <byorgey> mantovani: try indenting 'then' and 'else' more than 'if', perhaps?
11:46:23 <lambdabot>   (21,23)
11:46:29 <byorgey> mantovani: you have weird indentation
11:46:33 <neutrino_> `nand`: what is his domain?
11:46:35 <`nand`> it's 23 if you don't omit the spaces around (.)
11:46:43 <`nand`> neutrino_: numbers with some modulo
11:46:54 <mantovani> but here is working byorgey
11:47:03 <mantovani> byorgey: what should I do ?
11:47:04 <byorgey> mantovani: what version of GHC do you have?
11:47:10 <neutrino_> `nand`: right, but that was merely an example
11:47:25 <neutrino_> not like the be all end all of applications, at least i guess
11:47:31 <mantovani> The Glorious Glasgow Haskell Compilation System, version 7.4.1
11:47:31 <byorgey> mantovani: do they actually tell you what the error is, or does it just say "compilation error"?
11:47:38 <mantovani> they don't say this idiots
11:47:38 <`nand`> ask him? Maybe we're just both missing something incredibly obvious
11:47:47 <byorgey> mantovani: some aspects of indentation changed between 6.10 and 7.4
11:47:47 <mantovani> byorgey: I'm trying submit my code to SPOJ website
11:47:49 <`nand`> show him or edwardk your example, I guess
11:48:00 <mantovani> this mothefuckers don't they the error
11:48:07 <mantovani> here work fine :'(
11:48:15 <mantovani> don't say the error*
11:49:16 <mantovani> byorgey: https://www.evernote.com/shard/s166/sh/2700d9de-22a0-4492-a99e-4064879adfa5/7a306c16acf4f03220835c0128c69cfe
11:49:22 <mantovani> "Compilation error"
11:49:31 <neutrino_> `nand`: yeah, i was going to ask ed about it later
11:50:21 <byorgey> mantovani: well, did you try what I suggested?
11:50:31 <mantovani> identation ?
11:50:38 <mantovani> I don't have ideia how ident it in correct way
11:50:44 <byorgey> yes, make sure 'then' and 'else' are indented more than 'if'
11:50:49 <byorgey> instead of being in the same column
11:50:49 <mantovani> ok
11:50:53 <mantovani> one sec
11:50:55 <mantovani> like
11:50:59 <mantovani> "  if "
11:51:03 <mantovani>               "theb"
11:51:06 <mantovani> then*
11:51:06 <mantovani> ok
11:51:25 <zhulikas> flebron, later I found out that I was actually wrong
11:51:30 <zhulikas> about the type of f in >>
11:51:31 <zhulikas> =
11:51:45 <flebron> i don't think you were
11:51:53 <flebron> >>= has type m a -> (a -> m b) -> m b
11:51:54 <zhulikas> ahh
11:51:58 <flebron> m in this case is (->) r
11:52:01 <zhulikas> I was playing around with more complex functions
11:52:08 <mantovani> byorgey: problem keeps http://paste.scsys.co.uk/220326
11:52:16 <zhulikas> @type ((+) >>= (+))
11:52:17 <lambdabot>     Occurs check: cannot construct the infinite type: a0 = a0 -> a0
11:52:18 <flebron> so >>= is of type (r -> a) -> (a -> r -> b) -> r -> b
11:52:18 <lambdabot>     Expected type: (a0 -> a0) -> a0 -> a0 -> a0
11:52:18 <lambdabot>       Actual type: (a0 -> a0) -> (a0 -> a0) -> a0 -> a0
11:52:19 <zhulikas> so what I figured
11:52:29 <zhulikas> it has to be number of parameters for the left side + 1
11:52:34 <zhulikas> @type ((+) >>= (+) (+5))
11:52:35 <lambdabot> (Num (b -> b), Num b) => b -> b
11:52:37 <flebron> from the type you can deduce what can possibly be going on
11:52:42 <zhulikas> and every time it will be resolved to a -> a
11:52:42 <flebron> (r -> a) -> (a -> r -> b) -> r -> b
11:52:47 <flebron> you're given 3 things:
11:52:54 <flebron> 1) f: r -> a
11:53:02 <flebron> 2) x : a -> r -> b
11:53:05 <zhulikas> @type ((+) (-) >>= (+5) (-) (+))
11:53:05 <flebron> 3) v : r
11:53:06 <lambdabot>     Occurs check: cannot construct the infinite type:
11:53:06 <lambdabot>       a0 = a0 -> a0 -> a0
11:53:06 <lambdabot>     Expected type: (a0 -> a0 -> a0)
11:53:17 <zhulikas> @type ((+) (-) >>= (+) (-) (+5))
11:53:18 <lambdabot>     Occurs check: cannot construct the infinite type: a0 = a0 -> a0
11:53:18 <flebron> so what you'll do is you'll give r to f
11:53:18 <lambdabot>     Expected type: (a0 -> a0 -> a0)
11:53:18 <lambdabot>                    -> (a0 -> a0 -> a0) -> a0 -> a0 -> a0
11:53:20 <zhulikas> shit.
11:53:20 <mantovani> ion: ping
11:53:21 <zhulikas> I was wrong
11:53:24 <flebron> stop the nooooise
11:53:28 <zhulikas> ok sorry :D
11:53:34 <flebron> if you want to test lambdabot you can /query him
11:53:39 <zhulikas> I know :|
11:53:39 <flebron> anyway
11:53:43 <ion> mantovani: Was?
11:53:47 <flebron> you give v to r, producing an a
11:53:59 <mantovani> ion: help me run my code in haskell 6.10 ?
11:53:59 <flebron> you give that a, _and that same value v, of type r_, to x
11:54:04 <flebron> this produces a b, which you return
11:54:14 <mantovani> ion: I submit my code to SPOJ but I get compilation error because the version...
11:54:18 <mantovani> my is 7
11:54:25 <mantovani> look
11:54:33 <mantovani> http://paste.scsys.co.uk/220327
11:54:34 <ion> mantovani: Have you asked them to upgrade?
11:54:35 <mantovani> here work fine
11:54:35 <flebron> so what has to be happening, purely by type deduction, is (>>=) f x v = x (f v) v
11:54:44 <mantovani> to much burocracy
11:54:51 <mantovani> I really want submit it now :'(
11:55:26 <flebron> and so (>>=) f x, by itself, is a function that, when you give it a v of type r, it returns a value of type b (or whatever x returns)
11:55:50 <mantovani> ion: what should I do ?
11:55:54 <zhulikas> makes sense
11:55:56 <flebron> so f >>= x is of type r -> b, and so is a m b, with m = (->) r
11:56:16 <mantovani> ion: my code is very simple
11:56:24 <ion> mantovani: You should give us the error message.
11:56:44 <mantovani> they don't give it to me
11:56:55 <mantovani> ion: https://www.evernote.com/shard/s166/sh/2700d9de-22a0-4492-a99e-4064879adfa5/7a306c16acf4f03220835c0128c69cfe
11:57:17 <mantovani> this idiots...
11:57:20 <ion> mantovani: Oh. Indent “then” more than the “if”. I would do that anyway even though it works in GHC nowadays.
11:57:39 <ion> mantovani: Indent “else” at the same level as “then”, both more than the “if”.
11:58:09 <mantovani> I did ion http://paste.scsys.co.uk/220328
11:58:11 <mantovani> same error
11:58:26 <mantovani> byorgey tell me to do that and keep it
11:58:38 <ion> mantovani: Btw, “when foo bar” is equivalent to “if foo then bar else return ()”
11:58:58 <`nand`> wasn't there some ugly workaround for ‘then’?
11:59:33 <mantovani> ion: thanks
12:00:38 <neutrino_> `nand`: thanks a lot for your help. that's really cool how that works with this new monad.
12:01:29 <ion> mantovani: I would use guards instead of the nested ifs in minuteCount, and “when” in main. Guards: http://learnyouahaskell.com/syntax-in-functions
12:02:16 <ion> mantovani: I recommend using http://hpaste.org/ for Haskell pasting.
12:02:47 <mantovani> thanks
12:03:22 <hpaste> mantovani pasted “retrcompatbility” at http://hpaste.org/79771
12:03:41 <mantovani> http://hpaste.org/79771
12:03:44 <mantovani> line 4
12:03:47 <mantovani> use when..
12:05:40 <mantovani> workkkks
12:05:43 <mantovani> ion++
12:05:46 <mantovani> UHUL!
12:06:52 <chreekat> I'd like to do some quickcheck-ing with lines of text representing prose, that specifically has paragraph breaks defined as blank lines. What should I go read to get started?
12:07:05 <mantovani> ion: http://br.spoj.com/status/ALADES,mantovani/
12:07:08 <mantovani> faster than Perl
12:07:09 <chreekat> i.e. I'm looking to make an instance of Arbitrary
12:07:54 <ion> chreekat: Reading the source of existing Arbitrary instances is enlightening.
12:08:28 <chreekat> ion: k
12:08:56 <chreekat> related question: what is a 'shrink'? It's one of the first terms one runs into when looking at QuickCheck on hackage, and I have no idea what it could mean
12:09:25 <`nand`> shrinking means simplifying a test case
12:09:37 <chreekat> (though I guess I should just keep reading the examples and reverse engineer the meaning)
12:09:43 <`nand`> in particular, it's used to try and find the minimal example of a failure
12:09:47 <chreekat> ahh
12:10:00 <chreekat> `nand`: awesome, thanks
12:10:15 <`nand`> @check \x -> (x :: Int) > 0
12:10:17 <lambdabot>   Not in scope: `myquickcheck'
12:10:19 <`nand`> blah
12:10:50 <chreekat> Thanks for the tips, gotta go for now
12:12:23 <Skillsob> Simon PJ is the hero computing needs.
12:14:49 <mantovani> ion: now I'll use guards
12:19:23 <neutrino_> `nand`: i'm trying to understand your code.. it's a bit difficult for me to follow but i think i'll manage ;)
12:19:35 <mantovani> ion: how I will use guards in my code ? because I just call a function
12:19:36 <mantovani> ?
12:20:10 <ion> mantovani: Look at the LYAH page i linked.
12:20:28 <mantovani> I saw
12:20:30 <mantovani> I'm reading it
12:20:34 <mantovani> I'm just thinkin how to use it
12:21:00 <neutrino_> `nand`: hey, btw. I noticed something that doesn't exactly work 100%. want to have a look?
12:21:13 <`nand`> neutrino_: hrm?
12:21:31 <mantovani> ion: because I call function don't set a value
12:21:59 <hpaste> neutrino pasted “could not deduce reification” at http://hpaste.org/79773
12:22:30 <neutrino_> `nand`: I tried reifying a function. it works, but i have to add a less polymorphic type annotation.
12:23:09 <`nand`> yeah, because you're using it as a function in line 65
12:23:18 <`nand`> so making that function polymorphic will clearly fail
12:23:38 <`nand`> makes sense, no?
12:24:36 <`nand`> s/that function/addTwo/
12:25:24 <neutrino_> `nand`: makes no sense. why will it fail?
12:25:58 <neutrino_> `nand`: notice that the same function is polymorphic in getEnv
12:26:14 <`nand`> getEnv doesn't use it anywhere
12:26:21 <`nand`> compare the following:
12:26:35 <neutrino_> go on
12:26:45 <`nand`> (\f -> show (f 3)) :: (Int -> Int) -> String
12:26:51 <`nand`> (\f -> show (f 3)) :: a -> String
12:26:54 <`nand`> the latter is a type error
12:26:58 <`nand`> that's what's happening here
12:27:08 <`nand`> getEnv would be akin to :: a -> a
12:27:16 <`nand`> which can obviously also be (Int -> Int) -> (Int -> Int)
12:29:03 <neutrino_> `nand`: why is it a type error?
12:29:17 <`nand`> :t (\f -> show (f 3)) :: a -> String
12:29:18 <lambdabot>     Couldn't match type `a1' with `Integer -> ()'
12:29:18 <lambdabot>       `a1' is a rigid type variable bound by
12:29:18 <lambdabot>            an expression type signature: a1 -> String at <interactive>:1:1
12:30:20 <neutrino_> `nand`: sure, there's an error..
12:30:24 <neutrino_> but why is there an error?
12:30:28 <neutrino_> i don't get it really
12:30:39 <`nand`> :t 3 :: a
12:30:41 <lambdabot>     No instance for (Num a1)
12:30:41 <lambdabot>       arising from the literal `3'
12:30:41 <lambdabot>     In the expression: 3 :: a
12:30:53 <`nand`> or
12:30:55 <`nand`> :t () :: a
12:30:57 <lambdabot>     Couldn't match type `a1' with `()'
12:30:57 <lambdabot>       `a1' is a rigid type variable bound by
12:30:57 <lambdabot>            an expression type signature: a1 at <interactive>:1:1
12:31:11 <`nand`> you can't magically make something polymorphic when it isn't
12:31:13 <`nand`> it makes no sense
12:31:26 <`nand`> remember, :: a means :: forall a. a
12:31:30 <`nand`> meaning the user gets to choose the type
12:31:58 <Fuuzetsu> Is there any recommended reading material after LYAH?
12:32:04 <`nand`> neutrino_: think about it this way
12:32:18 <`nand`> neutrino_: what would happen if I ran your ‘addTwo’ with ‘using ()’ ?
12:32:19 <monochrom> I recommend the Gentle Introduction to Haskell after LYAH
12:32:32 <`nand`> it wouldn't be a type error
12:32:40 <Fuuzetsu> I'll give it a read, thanks.
12:32:43 <`nand`> (if addTwo were polymorphic)
12:32:50 <neutrino_> hmm
12:32:58 <rizlah> o/
12:33:01 <rizlah> harro.
12:34:01 <neutrino_> `nand`: that's sort of getting to me, but i still need some convincing. why can't the compiler figure out, from another constraint, that there are additional constraints on a other than that 'it should fit all a'?
12:34:21 <`nand`> neutrino_: I don't understand that question
12:34:31 <monochrom> @type (\f -> show (f 3))
12:34:33 <lambdabot> (Num a1, Show a) => (a1 -> a) -> String
12:34:36 <neutrino_> i expected the compiler to end up in a state where it knows "this could fit all a" && "the a should be of type Int -> Int"
12:34:41 <monochrom> that's what the compiler figures out
12:35:04 <`nand`> neutrino_: the compiler /can/ figure it out, if you leave away the type signature of addTwo
12:35:12 <`nand`> it gets inferred as Reifies s (Int -> Int) => ReifyT s IO String
12:35:14 <`nand`> as it should
12:35:16 <monochrom> it's a bit more general that Int but less than unconstraint "a"
12:36:02 <`nand`> neutrino_: when you use ‘getEnv’ in line 64; its type gets refined to getEnv :: Reifies s (Int -> Int) => Example s (Int -> Int)
12:36:15 <`nand`> the constraints are the same
12:36:25 <neutrino_> `nand`: no, if i leave out the type sig of addTwo, i get errors
12:36:38 <neutrino_> fairly ugly ones too
12:37:00 <`nand`> neutrino_: don't forget NoMonomorphismRestriction
12:37:11 <neutrino_> should i add that? ok
12:37:13 <`nand`> (shame on me, I had that on by default, so I didn't notice it)
12:37:36 <neutrino_> yeah works
12:37:43 <neutrino_> hmm
12:41:00 <neutrino_> so why does a function which does not need the a ok with it being specified as "a", whereas if it uses it, it needs (n -> n)?
12:41:09 <neutrino_> that seems a little arbitrary to me
12:42:48 <`nand`> because that's the way Haskell's type system works
12:43:26 <neutrino_> i'm probably being thick
12:43:44 <neutrino_> i don't know much about how the type system works tbh
12:43:54 <neutrino_> maybe i should read up on that some time..
12:44:03 <neutrino_> i think it's a fairly big weakness
12:44:15 <neutrino_> in my understanding of the code that is
12:44:31 <`nand`> I never read up on how the type system ‘works’ either; I rely on intuition and experience
12:48:24 <neutrino_> heh yeah, i guess i'm missing all of those ;)
12:48:32 <neutrino_> learnt a lot today though
12:48:33 <neutrino_> :)
12:51:22 <Saizan> free variables in type signatures are implicitly universally quantified
12:52:14 <Saizan> so the function has to work forall possibile alternatives the caller might pick
12:54:46 <napping> Is there a version of this with well-formed code? : http://logicaltypes.blogspot.com/2012/11/coreader-x-costate-silver-bullet.html
12:58:51 <neutrino_> Saizan: mhm..
13:04:20 <`nand`> A ComonadApply w is a strong lax symmetric semi-monoidal comonad on the category Hask of Haskell types.
13:04:22 <`nand`> That it to say that w is a strong lax symmetric semi-monoidal functor on Hask, where both extract and duplicate are symmetric monoidal natural transformations.
13:04:25 <`nand`> ah yes, that last line clears it up perfectly
13:04:27 <`nand`> thanks, edwardk
13:04:39 <edwardk> no problem
13:04:46 <edwardk> thats my new penchant for docs speaking ;)
13:05:17 <edwardk> strong lax is boring. strong comes for free in haskell
13:05:41 <edwardk> lax just means 'you have to use a function to witness the equivalence'
13:05:46 <edwardk> symmetric is the key part
13:06:06 <`nand`> semi-monoidal?
13:06:15 <edwardk> given any two values in a comonad, say a comonadic term:  w a    and another comonadic term: w b
13:06:26 <edwardk> i can always extract my 'w a' to get an 'a'
13:06:43 <edwardk> and then use the 'strength' of every functor to lift that a up and smash it into every b in w
13:06:48 <edwardk> thats boring though
13:06:52 <edwardk> i can also go the other way
13:06:56 <edwardk> these are asymmetric.
13:07:22 <edwardk> if my comonad was, say     data Pair a = Pair a a   -- i didn't get to 'line up' my individual values
13:07:27 <edwardk> i only got to pick one
13:07:47 <edwardk> so the relationship between those two potential 'semimonads' is unsatisfying
13:08:03 <edwardk> we want a symmetric relationship, that describes how we zip or take a cross product, etc.
13:08:17 <edwardk> thats what ComonadApply is about
13:08:37 <edwardk> say you have 2 non-empty lists, zipping them up would be a valid comonadapply instance
13:09:12 <edwardk> just taking the head of one and smashing it into all the values in the other on the other hand, would not
13:10:01 <`nand`> makes sense
13:11:54 <trzrtdzh> ihr schwänze
13:12:05 <trzrtdzh> suck my cock bitches
13:12:09 <`nand`> @where ops
13:12:09 <lambdabot> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
13:12:22 <trzrtdzh> im gonna fuck your momma
13:13:02 <trzrtdzh> i rape your grandma at night
13:14:09 <trzrtdzh> vljgflbkjdkrjblkrjtlkbd
13:14:18 <trzrtdzh> drbrdiotbjdrtbdrtbdrtbdrtbdrtbdrtbdrtzhijrtsroidgjljkrshdksjvhlkjsgh
13:14:20 <trzrtdzh> +
13:14:51 <Nereid> ????
13:15:01 <simpson> Heh. Starved him out.
13:15:13 <beaky> looks like his brain exploded
13:15:15 <pnielsen> somebody who didn't understand monads
13:15:48 <beaky> or maybe he understood them too well and has gone mad
13:16:06 <pnielsen> maybe that's what happens when you understand all of the typeclassopedia
13:16:36 <`nand`> the typeclassopedia only barely touches the surface of the rabbit hole
13:16:45 <`nand`> it doesn't even mention profunctors
13:16:51 <`nand`> and those are, like, essential
13:18:06 <neutrino_> edwardk: hey, have you seen `nand`'s reflection quest earlier on? :)
13:18:07 <pnielsen> yes, I believe "ihr schwänze" is german for profunctors
13:19:48 <mreh> :t satisfy
13:19:50 <lambdabot> Not in scope: `satisfy'
13:20:18 <mreh> how can > many 1 (satisfy (not . isSpace)) consume spaces?
13:20:22 <mreh> many1*
13:21:15 <mreh> it has to be something else, but I'm just looking for reassurance
13:21:30 <dolio> It cannot.
13:21:48 <napping> what parser?
13:21:52 <neutrino_> mreh, you can reach any goal you set.
13:22:28 <mreh> a Text.Parsec.String.Parser
13:23:54 * sm notes the alternate spelling noneOf " "
13:24:20 <Nereid> sm: there are things that satisfy isSpace other than ' '
13:25:19 <sm> ah, my bad
13:28:02 <mreh> haha, oh, I know what is going on, I used getArgs, but that splits all the arguments at spaces
13:28:07 <mreh> so there are no spaces in my input
13:28:31 <mreh> :t intercalate
13:28:32 <lambdabot> [a] -> [[a]] -> [a]
13:30:22 <Nereid> mreh: well, if you quote the arguments then you'll get spaces.
13:30:47 <mreh> Nereid: I wasn't :), it was a program error, not user error
13:31:01 <Nereid> ok
13:31:09 <mreh> but yes, that would have worked
13:31:22 <k0ral> hello there
13:31:43 <Nereid> > intercalate " " ["hello","world"]
13:31:43 <mreh> hello
13:31:45 <lambdabot>   "hello world"
13:31:52 <mreh> :t intersperse
13:31:53 <lambdabot> a -> [a] -> [a]
13:32:51 <k0ral> I'm looking for a tree library that would implent trees as follows: Tree a b = Leaf a | Map b a
13:33:22 <`nand`> make your own
13:33:22 <k0ral> I'm surprised to see that the "standard" Data.Tree isn't that rich
13:33:34 <`nand`> the trees are numerous and varied
13:33:42 <mreh> k0ral, that isn't a tree btw :)
13:33:42 <`nand`> there's never really been a common denominator for these sorts of things
13:34:10 <k0ral> mreh: to me, that's a tree where edges are indexed by a type
13:34:19 <Nereid> I'd swap the type arguments.
13:34:39 <Nereid> then Tree b could be a Functor and friends.
13:34:41 <`nand`> (did you really mean ‘| Map b a’?)
13:34:48 <mreh> I don't think so
13:34:59 <`nand`> since that's ~ (a, Maybe b)
13:35:09 <mreh> Map b (Tree a b)?
13:35:12 <k0ral> `nand`: I'm surprised, even something like (Traversable b) => Tree a b = Leaf a | b a seems more generic/useful than the currently provided Data.Tree
13:35:19 <Nereid> heh
13:35:33 <Nereid> eww, data type contexts.
13:35:49 <`nand`> mreh: Node (Map b (Tree a b)), rather
13:35:56 <`nand`> mreh: the former is still defining ‘Map’ as a constructor
13:36:03 <k0ral> mreh: oh yeah, sorry for the mistake
13:36:13 <mreh> `nand` good call :)
13:36:20 <k0ral> (Traversable b) => Tree a b = Leaf a | b (Tree a b)
13:37:21 <mreh> I can't see I often use trees
13:37:24 <mreh> say*
13:37:29 <roconnor> k0ral: looks like Traverable b => Free b
13:37:30 <mreh> I do indirectly
13:37:50 <`nand`> roconnor: good catch
13:37:51 <k0ral> I figure that's a good way to manage key bindings
13:38:12 <Nereid> but yes, that is a free monad.
13:38:13 <mreh> roconnor, what is that from again, Free sounds familiar
13:38:21 <`nand`> mreh: Control.Monad.Free
13:38:24 <roconnor> mreh: Free monad from somewhere
13:38:34 <`nand`> from monad-free or something
13:38:45 <mreh> is that something to do with zippers?
13:38:53 <`nand`> not to my knowledge
13:39:03 <mreh> I went to a tutorial about free and it didn't stick
13:39:11 <mreh> actually I was late
13:39:35 <`nand`> http://www.haskellforall.com/2012/06/you-could-have-invented-free-monads.html
13:39:39 <roconnor> mreh: a free monad is a tree whose branching is given by a functor
13:40:02 <roconnor> trees make for good examples of monads
13:40:14 <`nand`> http://comonad.com/reader/2011/free-monads-for-less/
13:41:01 <`nand`> oh, that last link probably isn't very helpful
13:41:43 * roconnor has started to notice that what we call a monoid, general programmer seem to call "mergable"
13:41:56 <roconnor> perhaps mergable is a semigroup
13:41:58 <`nand`> I would associate ‘mergable’ with semigroups
13:42:00 <mvj4_> @pl f g (a,b) = (g a, g b)
13:42:00 <lambdabot> f = (`ap` snd) . (. fst) . (flip =<< (((.) . (,)) .))
13:42:10 <`nand`> perhaps even magmas :)
13:42:34 <roconnor> `nand`: It would be better if "they" used precise terminology
13:42:35 <mreh> what other languages have formalised definitions of monoids for their data types?
13:42:49 <`nand`> any that add them
13:42:51 <jozefg> :t (***)
13:42:52 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
13:42:53 <mreh> Haskell seems to be fairly unique in that regard
13:43:03 <`nand`> Haskell doesn't have a ‘formalised’ definition of monoids
13:43:14 <`nand`> just an informally specified typeclass with laws in comments
13:43:30 <`nand`> you can do that in many languages
13:43:43 <mreh> agreed upon then :)
13:43:48 <mvj4_> how does (***) relate to mapPair? it seems to expect two functions applied separetely.
13:43:53 <napping> but what languages do?
13:44:18 <mreh> I've never heard "mergable" before
13:44:18 <`nand`> I'm quite sure a number of languages do, but call it differently
13:44:25 <jozefg> I've seen Moniod references in Go and OCaml
13:44:34 <`nand`> for example the ones aimed at supercomputing are often based on monoid homomorphisms
13:44:37 <roconnor> mvj4_: I believe mapPair is (***) instantiated at the (->) arrow
13:44:57 <`nand`> :t mapPair
13:44:58 <lambdabot>     Not in scope: `mapPair'
13:44:58 <lambdabot>     Perhaps you meant `parPair' (imported from Control.Parallel.Strategies)
13:45:08 <roconnor> @free snd
13:45:10 <lambdabot> g . snd = snd . $map_Pair f g
13:45:44 <`nand`> so (***) then
13:45:58 <Taneb> I have a feeling my code is going to be rather inefficient
13:46:25 <mvj4_> roconnor: ah, I'm looking for something that works over a single function.
13:46:28 <mreh> Taneb: don't be put off by those feelings :) get a working version before you even worry about optimisation
13:46:32 <`nand`> :t join (***)
13:46:34 <lambdabot> Arrow a => a b c -> a (b, b) (c, c)
13:46:38 <`nand`> :t over both
13:46:39 <lambdabot> (a -> b) -> (a, a) -> (b, b)
13:46:41 <k0ral> does makeClassy from Control.Lens work with parameterized data types ?
13:46:46 <`nand`> k0ral: should
13:46:46 <mvj4_> thanks.
13:46:51 <`nand`> k0ral: but try it
13:46:54 <mreh> inefficient solutions are ofen far easier to understand
13:46:57 <Taneb> mreh, it's a huge (by my standards, so quite small actually) project, that's gonna be a while
13:47:14 <ion> > ("foo", "barbaz") & both %~ length
13:47:16 <lambdabot>   (3,6)
13:47:18 <ion> > over both length ("foo", "barbaz")
13:47:19 <mreh> Taneb, premature optimisation and all that
13:47:20 <lambdabot>   (3,6)
13:47:39 <k0ral> I'm getting an error "naked expression at top level"
13:47:41 <jozefg> :t over
13:47:42 <lambdabot> Setting s t a b -> (a -> b) -> s -> t
13:47:43 <Fuuzetsu> @pl (***)
13:47:44 <lambdabot> (***)
13:47:51 <`nand`> k0ral: {-# LANGUAGE TemplateHaskell #-}
13:47:57 <Fuuzetsu> @pl (***) a b c d e
13:47:57 <lambdabot> (a *** b) c d e
13:47:59 <k0ral> oh right, my bad
13:48:01 <ion> > over each length ("foo", "barbaz")  -- I suppose lambdabot doesn't have a new enough version of lens to have each
13:48:02 <roconnor> mvj4_: like first?
13:48:03 <lambdabot>   Not in scope: `each'
13:48:12 <`nand`> ion: nope, it's on 3.7 or something still
13:48:14 <jozefg> We're putting lambdabot through it's paces today
13:48:15 <`nand`> maybe older
13:48:18 <`nand`> blame Cale
13:48:37 <mvj4_> roconnor: yeah, join (***) did it.
13:48:38 <ion> nand: I think there’s probably no release of lens with “each” anyway.
13:48:42 <Fuuzetsu> @pl f a b = b a
13:48:42 <lambdabot> f = flip id
13:48:47 <Fuuzetsu> tsk
13:48:57 <roconnor> @ tell Cale lambdabot's lens library is 6 minutes out of date
13:49:18 <ion> But i wasn’t sure of that, so i checked with lambdabot.
13:49:40 <mreh> lambdabot runs on Caleskell and the compiler is quite slow
13:49:40 <`nand`> ion: 3.8
13:49:48 <`nand`> oh, release
13:49:51 <`nand`> well, whatever
13:49:53 <`nand`> Cale can build from git
13:50:21 <ion> Yes, because git versions never let one e.g. define unsafeCoerce with exported values or anything.
13:51:28 <roconnor> mvj4_: you can also use the nifty lens library to do what you want ... but perhaps that is something for you to consider later.
13:52:27 <Taneb> ion, you can define unsafeCoerce with Data.Typeable and one extension which I forget which but it's generally considered safe
13:52:42 <Taneb> ScopedTypeVariables
13:52:45 <Taneb> I think
13:52:59 <c_wraith> ScopedTypeVariables is safe.
13:53:15 <Heffalump> Taneb: is that just because Data.Typeable is a wrapper around unsafeCoerce?
13:53:17 <c_wraith> It doesn't allow any functionality that haskell98 doesn't provide - just a cleaner way to access some of it
13:53:26 <Taneb> Heffalump, yes
13:53:28 <Taneb> Yes it is
13:53:58 <roconnor> c_wraith: I haven't seen a proof of that claim, ... but yes, ScopedTypeVariables is quite safe.
13:54:07 <latima> Offtopic: Why do we call the mark between the integral and fraction part of numbers a "decimal" point? What does it have to do with decimals? It's not exclusive to the decimal number system is it?
13:54:46 <parcs> wikipedia probably knows the answer for that
13:54:55 <latima> parcs: doesn't seem to!
13:55:30 <c_wraith> roconnor: you can construct a type signature for const that will do anything you can do with ScopedTypeVariables
13:55:49 <`nand`> perhaps an overloaded meaning of ‘decimal’? eg. ‘deci’ the SI prefix means 1/10th
13:56:01 <monochrom> in general you say "radix point"
13:56:05 <Taneb> newtype Nasty a b
13:56:18 <`nand`> monochrom: I just came across that as well while consulting wiktionary :)
13:56:26 <Taneb> instance Typeable a => Typeable (Nasty a b) where typeOf _ = typeOf (undefined :: a)
13:56:33 <hiptobecubic> > map toUpper . join . sequence . words $ "ho ho ho"
13:56:35 <lambdabot>   "HHHHHOHOHHOOOHHOHOOOHOOO"
13:56:46 <latima> Other fun fact - decimated does not mean destroyed, it just means divided into ten!
13:56:52 <`nand`> I somehow read ‘OH NO’
13:57:01 <hiptobecubic> > map toUpper . join . sequence . words $ "ho ho ho no"
13:57:03 <lambdabot>   "HHHNHHHOHHONHHOOHOHNHOHOHOONHOOOOHHNOHHOOHONOHOOOOHNOOHOOOONOOOO"
13:57:20 <Taneb> coerce :: a -> b; coerce x = fromJust $ cast (Nasty x :: Nasty b a)
13:57:20 <`nand`> found it, near the end
13:57:32 <beaky> santa's grunting is a monoid!
13:57:50 <hiptobecubic> all the best things are
14:00:20 <hiptobecubic> @let scream = map toUpper . join . sequence . words
14:00:23 <lambdabot>  Defined.
14:02:15 <ion> > scream "s c r e a m !!!!!!!!"
14:02:17 <lambdabot>   "SCREAM!SCREAM!SCREAM!SCREAM!SCREAM!SCREAM!SCREAM!SCREAM!"
14:02:23 <mreh> hehe
14:02:27 <mreh> that's cheating
14:02:29 <neutrino_> hey guys
14:02:38 <neutrino_> is there ever a downside to NoMonomorphismRestriction?
14:03:05 <Heffalump> things that you thought would be values aren't
14:03:50 <Heffalump> and code that was previously relying on the interaction of the MR and defaulting stops working
14:04:10 <hiptobecubic> and Woozles
14:04:42 <`nand`> neutrino_: I remember running into some
14:04:46 <mreh> > scream "not woozles"
14:04:48 <lambdabot>   "NWNONONZNLNENSOWOOOOOZOLOEOSTWTOTOTZTLTETS"
14:05:03 <signalsea> hi all, question about the formalized definition of substitution in untyped lambda calculus. i'm a little confused by the text i'm reading... here's an image http://i.imgur.com/4eiIw.png
14:05:11 <`nand`> neutrino_: I can't for the life of me remember what it was though
14:05:27 <sclv> the intensional transformation -- hmm: http://www.softlab.ntua.gr/~gfour/dftoic/dftoic.pdf
14:05:31 <`nand`> neutrino_: in the context of defining a class instance, in that, if I added the pragma I got a compile error, but it worked fine without
14:05:38 <`nand`> type ambiguities
14:07:18 <napping> signalsea: that's a syntactic comparison, of variables by name
14:08:54 <signalsea> napping: so it's saying "if 'y' inside the term t has the same label as x in the substitution"?
14:11:54 <`nand`> yes
14:12:28 <`nand`> for example, (\x -> x (\x -> x)) 3 is 3 (\x -> x), and not 3 (\x -> 3)
14:15:56 <k0ral> by the way, parameterized data types used in makeClassy require MultiParamTypeClasses
14:16:21 <k0ral> how bad is it ?
14:17:16 <`nand`> what? the extension?
14:18:16 <k0ral> yes
14:19:00 <k0ral> and FunctionalDependencies
14:19:20 <`nand`> well it's actually pretty commonplace eg. with mtl; and with FunctionalDependencies there's basically no problem with them
14:19:31 <`nand`> the problems mainly arise when you get ambiguous type errors
14:19:41 <`nand`> but fundeps usually remove those
14:20:01 <k0ral> hmmm, now it asks for flexible instances
14:21:57 <c_wraith> so give it flexible instances
14:22:18 <`nand`> what's next, undecidable instances? :)
14:22:25 <`nand`> flexible contexts?
14:24:11 * hackagebot optparse-applicative 0.5.2.1 - Utilities and combinators for parsing command line options  http://hackage.haskell.org/package/optparse-applicative-0.5.2.1 (PaoloCapriotti)
14:24:12 <k0ral> flaxible contexts is already everywhere in my code
14:25:43 <geekosaur> there is some justification for the standard not allowing flexible contexts, but mostly you can think of it as training wheels...
14:26:51 <c_wraith> I was under the impression that flexible contexts and flexible instances were non-standard because when the spec was written, people weren't sure how hard they'd be to implement.
14:30:01 <merijn> k0ral: I mostly agree with don's answer here about which extensions are bad: http://stackoverflow.com/questions/10845179/which-haskell-ghc-extensions-should-users-use-avoid
14:31:50 <merijn> k0ral: Although I would personally (tentatively) qualify incoherent/overlapping instances as bad too. (Undecidable can result in an infinite loop during compilation, but if you're careful that's not a problem. At least it won't affect code correctness)
14:32:46 <Skillsob> Merry Gravmas, Haskellers!
14:32:47 <c_wraith> and the compiler has a built-in recursion limit that will keep the infinite loop from actually freezing it.
14:32:57 <Skillsob> I personally celebrate Festivus, but that has passed.
14:32:59 <merijn> k0ral: MPTC, FlexibleContexts and FlexibleInstances are completely obvious and thus warrant no worrying at all
14:33:23 <pnielsen> and a good jul to you
14:33:26 <c_wraith> So if you mess up with undecidable instances, the compiler will still tell you
14:33:38 <zhulikas> @src Monad IO
14:33:38 <lambdabot> Source not found. Do you think like you type?
14:33:44 <zhulikas> how is IO a monad?
14:33:53 <zhulikas> what's the implementation for >>= ?
14:33:59 <c_wraith> bindIO
14:34:04 <zhulikas> ok
14:34:18 <merijn> zhulikas: It's built-in in either the compiler or the runtime system (I forget which)
14:34:19 <c_wraith> If you want better details than that, read the lazy state threads paper
14:34:35 <Skillsob> zhulikas, I think the idea is that if you TREAT IO like a monad, you can reason with IO in a functional way.
14:34:46 <cmccann> c_wraith, it is entirely possible to make GHC diverge without the instance selection stack overflowing
14:34:58 <c_wraith> http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.144.2237
14:35:05 <zhulikas> so it only looks like a monad
14:35:20 <c_wraith> How does looking like a monad differ from being a monad?
14:35:27 <merijn> zhulikas: Well, it meets the 3 monad laws, so it acts like one too
14:35:51 <c_wraith> monads are not a deep concept.  If something looks like a monad, it is one.
14:36:00 <cmccann> but personally I don't see undecidableinstances as a big deal. these days compile-time nontermination seems less problematic than run-time nontermination
14:36:29 <merijn> cmccann: Sure, it's not a big deal, but it's not an extension newcomers should enable willy-nilly
14:37:00 <cmccann> true, it's not an extension you should enable unless you know why it's necessary for what you're trying to do
14:37:05 <merijn> cmccann: As opposed to MPTC, and FlexibleContexts/Instances which are completely obvious and can be turned by anyone with a basic grasp of typeclasses with no problem
14:37:35 <cmccann> MPTCs are actually very confusing to newcomers, heh
14:37:46 <c_wraith> the interaction between MPTC and UndecideableInstances actually is kind of a big deal
14:37:46 <cmccann> without fundeps they don't do what many people expect them to do
14:37:55 <merijn> Well, I thought they were obvious when I came across them :p
14:38:24 <c_wraith> instance Foo (Bar a) b where ...  -- requires UndecideableInstances in a way that's not totally obvious
14:38:33 <c_wraith> Well, it is, but it isn't
14:38:58 <c_wraith> Tough to see when the concepts are new to you.  Obvious when the concepts aren't new
14:39:07 <aninhumer> So far I've found Inpredicative types usually means I'm doing something wrong
14:39:18 <aninhumer> *ImpredicativeTypes
14:39:27 <aninhumer> or was it instances? I forget
14:39:44 <c_wraith> Impredicative types are awesome in theory - but basically impossible to actually work with
14:40:13 <c_wraith> So I've gone to the dark side on that extension, saying "Just use a newtype wrapper with RankNTypes instead".
14:40:28 <c_wraith> It's more verbose, but at least the type errors when it messes up make sense.
14:41:01 <cmccann> yeah
14:41:45 <cmccann> the only thing that annoys me is if I want to uncurry a function with a polymorphic argument for some reason
14:41:56 <cmccann> because putting it into a tuple would require impredicative types :T
14:42:08 <c_wraith> or use any of the standard combinators and preserve a polymorphic type
14:42:19 <nade> Hey all, I've been trying to get learn Haskell recently, and I have been running up against a problem probably due to a limited understanding of monads. I'm simply trying to generate a random string using parameters provided by the user through commandline arguments. Here is the code: http://codepad.org/g3RC9QDP . I'm thinking that the issue is somehow related to improper use of the do construct. Any help would be greatly appreciated, thanks
14:42:36 <merijn> I seem to want ImpredicativeTypes for Chan, but I'm not sure that actually makes sense...
14:42:48 <merijn> i.e. I want to set "forall a . Foo a" through a channel
14:42:53 <c_wraith> I wish there was a way to sanely get impredicative instantiation of type variables that are explicitly polymorphic.
14:43:03 <cmccann> a lot of stuff involving quantified types is awkward because the baseline state of affairs expects quantification to be implicit
14:43:04 <sclv> merijn: that's where newtype wrappers are just fine
14:43:44 <merijn> sclv: Right now my code just has a GADT wrapper around it to hide the a
14:43:52 <sclv> sure.
14:43:55 <cmccann> and explicit quantifiers everywhere would be ugly anyway
14:44:03 <merijn> But it'd be prettier without it
14:44:15 <merijn> 'cause now I had to write a useless wrapper type
14:44:25 <sclv> the actual algos for working with impredicative types are scaray
14:44:37 <cmccann> but GHC does a lot of stuff behind the scenes with quantifiers and constraints that can occasionally get in the way of wanting to use those explicitly
14:44:41 <k0ral> merijn: thank you
14:44:50 <sclv> scary even. and also hard to reason about.
14:45:08 <plhk> :t chr
14:45:09 <lambdabot> Int -> Char
14:45:27 <cmccann> e.g. "forall a.  a -> forall b. b -> a" is not exactly the same as "forall a b.  a -> b -> a" but GHC doesn't like to recognize the difference there
14:45:43 <plhk> nade: ( chr num ) : ( genString ( sl - 1 ) al ) ?
14:45:51 <aninhumer> nade: First, here's a fixed version (I think)
14:46:15 <aninhumer> nade: The error is just that the codepad.org evaluator doesn't pass any cmdline args
14:46:27 <aninhumer> nade: http://codepad.org/FU9Sz2am
14:46:38 <merijn> k0ral: Although, as someone else mentioned you should try to understand why exactly you need to enable a specific extension X/Y (even if that reason is "because the writers of the report were very conservative in what they accept" like it is for FlexibleContexts/FlexibleInstances)
14:47:34 <Skillsob> Can anyone tell me exactly what "combinator" means in a programming context?
14:48:01 <merijn> Skillsob: It's a rather vague term, it usually just means "something that combines multiple things into one"
14:48:04 <aninhumer> nade: Firstly, if your function performs IO (including accessing random data, it needs to return IO something)
14:48:11 <cmccann> in practice is usually means a function that's higher-order in some sense that mucks with other function-y things
14:48:14 <merijn> Skillsob: i.e. "(.)" is a combinator that combines two functions into one
14:48:28 <nade> aninhumer: Ah okay. I was under the impression that the return statement didn't actually "return" as it does in imperative languages. Its doesn't right? Why do you use it here?
14:48:30 <merijn> Skillsob: map is a combinator that combines a function and a list, etc.
14:48:50 <merijn> Skillsob: The less you think about a precise definition, the more the word becomes obvious
14:48:53 * cmccann would say that map is a combinator that turns a function on single values into a function on lists :]
14:49:23 <owst> I thought a combinator was just any lambda/function with no free (term) varialbes
14:49:28 <merijn> nade: return doesn't return, BUT your genString function uses a do block
14:49:33 <cmccann> owst, that's the formal definition
14:49:43 <merijn> nade: Which means the end result of your function should be in a monad of some kind
14:49:45 <cmccann> but it's not a very useful definition in practice
14:49:56 <merijn> nade: Specifically, IO (because you use randomIO)
14:49:59 <nabilhassein> hello all, i'm a newbie writing myself a scheme (http://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours/Parsing), and as part of the 5th exercise in the parsing chapter i'm looking for a parsec function analogous to oneOf, but that finds a string in a list of strings, rather than a character in a list of characters. i can't find anything like that, does it exist? or if you're familiar with the exercise, is there a be
14:50:02 <nade> aninhumer: Yeah, I was thinking that while I wrote it, but I wasn't aware of the proper type to use. Also, am I mistaken in thinking that random number generation must take place within a do block?
14:50:10 <merijn> nade: But you try to return [Char], which is not in IO
14:50:26 <owst> cmccann: ah, good. Yeah, not so useful for intuition about what it *means*
14:50:59 <merijn> nade: If you return "IO [Char]", then it should work, which is exactly what return does. It takes an "a" and puts it into an arbitrary monad m (for instance, IO)
14:51:07 <cmccann> owst, depending on which hairs you split regarding what counts as a "free variable" it might be useful
14:51:14 <merijn> Hence it's type "return :: Monad m => a -> m a"
14:51:27 <nade> Okay
14:51:30 <merijn> nade: Lemme know if I lost you somewhere :)
14:51:56 <aninhumer> nade: merijn: The recursive call to genString also needed to be taken into the do block, since it's type IO [Char]
14:52:14 <owst> cmccann: I didn't know there were many hairs to split? :-)
14:52:20 <cmccann> e.g. is (+ 1) a combinator? that depends on whether you consider (+) and 1 to be free or bound.
14:52:31 <nade> merijn: Hey thanks a lot! I was a bit hesitant to come here and ask, but I was having a lot of trouble debugging the problem myself.
14:52:51 <cmccann> it could mean different things depending on what Num instances are in scope, so in a sense it has free variables... somewhere
14:52:56 <merijn> aninhumer: Ah, yeah. I read over that, to be fair I'm not 100% sober anymore, so I wouldn't rely on my proofreading accuracy ;)
14:53:00 <owst> right, I see what you mean
14:53:16 <cmccann> but you can also read the Num constraint as an implicit argument taking a Num dictionary
14:53:21 <cmccann> which means everything is bound!
14:53:26 <Eelis> hm, i like to think of combinators not as things that combine things, but as things that are combined with other combinators
14:53:30 <merijn> nade: Personally I advocate not using do notation until you really understand >>= and >> (although some people disagree)
14:53:31 <Eelis> because they usually come in sets
14:53:35 <nade> aninhumer: you mean by binding it?
14:53:59 <nade> instead of simply calling it as I previously had?
14:54:04 <cmccann> and is the literal "1" free? If you think of it as "fromInteger 1" then where is Integer coming from? it's not a bound identifier.
14:54:50 <aninhumer> nade: yeah, since ++ doesn't work with IO [Char] directly
14:54:56 <cmccann> but since integer literals are desugared using functions from Num applied to natural numbers, we could say that 1 is just a notation meaning the church numeral 1
14:54:58 <nade> Ah I see
14:55:17 <cmccann> in which case 1 is not free, and the Num dictionary is bound, and we have a combinator
14:55:30 <cmccann> owst, there are indeed a lot of hairs to split here
14:55:36 <Hafydd> Your compiled code contains sections of the form "succ succ succ succ succ ..."
14:55:44 <owst> cmccann: it would appear that way!
14:56:00 <Eelis> i think splitting hairs over what "combinator" means is pretty dumb
14:56:06 <hpaste> merijn pasted “genString do notation” at http://hpaste.org/79774
14:56:10 <owst> cmccann: can you explain this further? "integer literals are desugared using functions from Num applied to natural numbers"
14:56:16 <cmccann> Eelis, which is why nobody tries to apply the formal definition in practice, yes
14:56:30 <hpaste> merijn annotated “genString do notation” with “genString do notation (annotation)” at http://hpaste.org/79774#a79775
14:56:35 <Eelis> cmccann: i think it's dumb to even pretend there's an authoritative formal definition
14:56:46 <merijn> nade: eh, ignore the first paste. the second has the type right
14:57:02 <cmccann> owst, an integer literal means fromInteger applied to the Integer value corresponding to the number. negative literals use the negate function.
14:57:03 <aninhumer> merijn: I already fixed it ;)
14:57:23 <cmccann> owst, so (- 11) means "negate (fromInteger (11::Integer))"
14:57:47 <cmccann> Eelis, why? the formal definition predates the idea of programming languages.
14:58:00 <nade> aninhumer merijn: so when you pattern match in genString, the return keyword ensures that it is returning an IO [Char]?
14:58:26 <hpaste> merijn annotated “genString do notation” with “genString no do-notation” at http://hpaste.org/79774#a79776
14:58:26 <Eelis> cmccann: because the definition you refer to has no authority
14:58:28 <owst> cmccann: yes, of course, I was mis-reading, thanks.
14:58:41 <merijn> :t return
14:58:42 <lambdabot> Monad m => a -> m a
14:58:44 <nade> or the fact that it is being returned from the do block ensures this?
14:58:46 <nade> yeah
14:58:46 <cmccann> Eelis, how do you figure?
14:58:52 <nade> oh
14:58:54 <nade> ok
14:59:23 <aninhumer> nade: Sometimes the last thing in your do block is IO something already, and then you don't need return
14:59:24 <merijn> nade: Basically, return takes any value and puts it into any random monad. In this case (since you're working in IO), the type checker infers that you meant the IO monad and turns return into "a -> IO a"
14:59:44 <Eelis> cmccann: it's just what some dude came up with ages ago, the term has since evolved
15:00:40 <merijn> nade: The last line in an do block *must* always be a value in the monad you were working with. If the last line was "putStrLn" you wouldn't need to use return, as putStrLn already returns an IO value
15:01:03 <merijn> nade: But since (:) is just a constructor returning a pure list, you have to make sure that list is put inside IO again
15:01:07 <cmccann> Eelis, that's not a very useful way to look at it.
15:01:20 <Eelis> cmccann: i think of your way in the same way
15:01:26 <nade> Ah okay. So thats why I cant bind the last statement or use let etc
15:01:29 <cmccann> unless you want to get into humpty dumpty territory of "words mean what I intend them to mean"
15:01:36 <merijn> nade: Yeah
15:01:49 <merijn> nade: Because your really just writing one big expression
15:02:02 <cmccann> the purpose of terminology is to communicate well-defined ideas
15:02:10 <merijn> nade: Take a look at my second annotation, which is the same thing as the do notation, but using lambda's and >>= instead
15:02:31 <merijn> nade: If you check the type of >>= and the other functions in ghci it should make sense what is going on
15:02:32 <cmccann> if you throw out the only clear definition of a word then there's nothing left
15:02:39 <nade> merijn: this one? http://hpaste.org/79774#a79776
15:02:52 <Eelis> cmccann: language evolves. too bad :)
15:02:56 <merijn> nade: (Be warned what I wrote might not actually be correct, I didn't check :p)
15:02:59 <mantovani> http://hpaste.org/79777
15:03:05 <mantovani> how can I let this code faster?
15:03:06 <merijn> nade: Yeah, that one
15:03:11 <mantovani> can you see some optimization ?
15:03:12 <cmccann> jargon and terminology are not the same as language
15:03:19 <mantovani> humm
15:03:21 * mantovani find one
15:03:30 <merijn> oh, bah. I lowercased the IO in the type >.>
15:03:31 <aninhumer> merijn: hpaste seems happy, or rather, it gives the same warnings :P
15:03:59 <merijn> nade: the second annotation is pretty much exactly what GHC translates the do version into
15:04:13 <cmccann> Eelis, anyway, the formal definition is what it is, and the informal use is anchored to that with a bit of handwaving
15:04:26 <cmccann> if you want to discard the term entirely then have fun
15:04:27 <Eelis> cmccann: i disagree
15:04:33 <Eelis> nope, i don't want to discard the term
15:04:37 <cmccann> Eelis, then you are incorrect
15:04:38 <cmccann> sorry
15:04:39 <Eelis> i want to use it in the nice fuzzy sense we use it today
15:04:48 <Eelis> and your "the" formal definition is irrelevant
15:04:48 <merijn> nade: To make it slightly less confusing by adding parenthesis: "randomRIO (65, al) >>= \num -> genString (sl -1) al >>= \rest -> return (chr num : rest)
15:04:54 <cmccann> then you're not using it in a way that means anything
15:04:58 <merijn> Doh, stupid copy paste...
15:05:01 <cmccann> but whatever
15:05:04 <Eelis> indeed, whatever
15:05:08 <cmccann> not my problem
15:05:15 <Eelis> nor mine
15:05:17 <cmccann> just please try not to confuse other people
15:05:23 <Eelis> cmccann: i would say the same to you
15:05:37 <DrChaos> @src []
15:05:37 <lambdabot> data [] a = [] | a : [a]
15:05:41 <merijn> nade: retry: "randomRIO (65, al) >>= (\num -> (genString (sl -1) al >>= (\rest -> return (chr num : rest))))"
15:05:47 <DrChaos> NICE
15:05:54 <nade> merijn: Okay. Unfortunately, I haven't introduced myself to well with the lambda notation heh.  Iet me read up on it so can get a better handle
15:06:24 <DrChaos> so lists are not really built into the language but instead defined in the Prelude, right?
15:06:28 <merijn> nade: It's simple "\<variables here> -> <expression using variables here>"
15:06:56 <Nereid> DrChaos: there is special support for list syntax but otherwise yes
15:06:58 <JoeyA> Does data-default, or a similar package, support deriving Default?
15:06:59 <nade> Ah okay. So what is ">>=" then?
15:07:09 <nade> ok
15:07:10 <nade> oh
15:07:15 <aninhumer> :t (>>=)
15:07:16 <nade> is it the "do"
15:07:16 <nade> ?
15:07:17 <lambdabot> Monad m => m a -> (a -> m b) -> m b
15:07:18 <nade> yeah
15:07:35 <merijn> DrChaos: The syntax for lists is special (i.e. being able to write "[Int]" instead of "[] Int"), but lists themselves could be defined in normal, haskell yeah
15:07:38 <JoeyA> I.e. by setting all fields to each's default.
15:07:53 <DrChaos> merijn -> perfect answer
15:08:10 <fengshaun> is it possible to define other special syntax like [a]?
15:08:22 <fengshaun> e.g. {a} or something
15:09:14 <merijn> nade: >>= (in terms of IO) basically means "given an action that produces an a" and "a function that uses an 'a' to give an action that produces a 'b'" it returns an action that produces a 'b'
15:09:33 <aninhumer> fengshaun: Unfortunately not (or fortunately depending on who you are :P)
15:09:43 <fengshaun> lol, thanks!
15:10:23 <merijn> nade: i.e. "getLine" is an action that produces a String, "putStrLn" is an action that prints a String, "getLine >>= putStrLn" is "combine an action that reads a String and a function that returns an action to print a String into an action that reads a String and prints it"
15:10:57 <DrChaos> I can see that you can create your own list type and use it almost like the built in list type
15:11:06 <merijn> nade: Note that I say "return an action", the actual action is not actually performed!
15:11:09 <merijn> DrChaos: Correct
15:11:32 <merijn> DrChaos: For example "data List a = Cons a (List a) | Nil" is pretty much identical to the built in list
15:11:35 <fengshaun> aninhumer, not even with template haskell?
15:11:39 <nade> merijn: what do you mean by "combine". I'm hesitant to think that it is similar to the pipe operator
15:11:46 <fengshaun> I don't know anything about TH, just guessing
15:11:47 <DrChaos> and even make your own list type from a value that is of the built in list type, as the two different types are isomorphic and have the same shape
15:11:50 <merijn> DrChaos: Where Cons == (:) and Nil == []
15:12:20 <aninhumer> fengshaun: Well you can, but you have to wrap it in $([something| |])
15:12:28 <merijn> nade: The pipe operator is actually an *excellent* analogy for >>= (inside the IO monad! For maybe/list not so much)
15:12:32 <aninhumer> So you need a pretty compelling reason for new syntax
15:12:32 <DrChaos> merijn -> yes
15:12:38 <fengshaun> aninhumer, oh man!
15:12:41 <fengshaun> thanks
15:12:50 <fengshaun> my compelling reason was fun!
15:13:24 <merijn> @quote shachaf getLine
15:13:25 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
15:13:56 <merijn> nade: That quote + your pipe analogy for IO are perfectly sensible (but only for IO, as I said)
15:14:38 <aninhumer> fengshaun: You can also use RebindableSyntax to override some sugar, for example the if-then-else syntax
15:14:52 <aninhumer> Although not lists for some reason iifc
15:14:52 <fengshaun> Ahh cool
15:14:55 <aninhumer> *iirc
15:14:58 <fengshaun> I'll look it up
15:15:16 <merijn> nade: Which is also why "getLine >>= putStrLn" is still pure, it doesn't read a line and print it. It's a function that takes two actions and combines them into a bigger action (which is pure, because "getLine >>= putStrLn" always returns the same action, no matter where you do it)
15:16:05 <merijn> nade: As a relatively simple illustration, try running "map print [1..10] !! 3" in ghci
15:17:34 <nade> merijn: To be honest, that is unexpected
15:17:35 <merijn> nade: print takes something showable and returns an action that prints that thing to stdout. "map print" returns a list of "actions that print thing to stdout", only when you actually evaluate one (i.e. you select it using !! and then evaluate it by for example using it as "main") does it actually run and print something
15:17:43 <merijn> :t map print
15:17:45 <lambdabot> Show a => [a] -> [IO ()]
15:17:52 <merijn> :t map print [1..3]
15:17:54 <lambdabot> [IO ()]
15:18:17 <merijn> nade: It's a list of print actions, *not* actually printing things :)
15:18:43 <merijn> Things only get printed once you *evaluate* the resulting actions (which can only be done by the runtime, not inside haskell)
15:19:09 <merijn> It's an important, but sometimes confusing and unclear distinction for newcomers :)
15:19:15 <janua> How do you know when something runs an action
15:20:08 <nade> merijn: and I should think of this as something fundamentally different from partial application or something right?
15:20:21 <aninhumer> janua: Only the main action is run in a compiled program
15:20:23 <merijn> janua, nade: No haskell code ever does. It's not allowed, it'd break the purity. There is only one action that ever gets run, and that's main, which is run by the runtime system.
15:20:53 <merijn> nade: It's different, but similar at the same time
15:21:08 <janua> Oh!! That makes a good bit of sense
15:21:43 <merijn> nade: You are basically constructing a program (the "main :: IO ()") by piecing smaller "programs" i.e. getLine and putStrLn together
15:22:41 <merijn> nade: It's just that purity gives you a way to manipulate program pieces without actually running them. Do you know any other language like C, Java, Python or Ruby?
15:22:52 <merijn> janua: :)
15:23:36 <merijn> janua: You're basically meta programming an impure program in pure haskell by combining smaller impure programs together, if that makes sense :)
15:24:02 <janua> merijn: Thats actually good to know when you don't already know that, because now ill think differently about what i write now...
15:24:57 <merijn> janua: Yes, since I finally understood this I realised why the whole "haskell is my favorite imperative language" joke actually makes sense and is totally true :)
15:25:05 <DrChaos> hello, I try to load this source file in ghci and it says that on line 9 the data constructor `List' is not in scope: http://vpaste.net/niDnR
15:25:06 <nade> merijn: Yeah I know Python, C, Javascript. I'm trying my best to approach haskell without bringing over concepts from imperative languages
15:25:34 <janua> merijn: Hehe :)
15:25:41 <fengshaun> nade, it's hard though, if you work with IO a lot
15:26:02 <merijn> nade: Think of trying to implement "&&" or "||" as a function inside C/Python, you can't, right? Because they wouldn't short circuit if you implement them as a function
15:26:56 <quchen> DrChaos: "List" is your data constructor, but you're pattern matching against value constructors. In your case, leave the "List" away in the pattern matching and it'll work.
15:27:27 <DrChaos> OH
15:27:32 <DrChaos> Cons is the value constructor
15:28:00 <quchen> What you have right now is the same as writing "toList (a : [as])"
15:28:13 <merijn> nade: In haskell you could write "and :: IO Bool -> IO Bool -> IO Bool" and implement it like this: "and x y = do { first <- x; if first then y else (return False) }", short-circuiting && as a function :) It runs the "x" program, but only "runs" y if x is true.
15:28:17 <merijn> DrChaos: Yes
15:28:42 <DrChaos> quchen -> that won't work
15:29:13 <merijn> DrChaos: That's exactly his point ;)
15:29:40 <DrChaos> I wouldn't know how to write it as toList (a : as)
15:30:24 <merijn> DrChaos: Lemme rewrite your example using GADT syntax and see if you understand what's wrong then :)
15:30:38 <quchen> What you currently have - "Cons a (List as)" - is the same as writing (a : [as]) in a pattern. What you want is (a:as), in your case "Cons a as".
15:30:48 <`nand`> quchen: (a : [as]) would work and is the same as matching (a : as : [])
15:30:51 <`nand`> or [a, as]
15:31:03 <DrChaos> GADT? What's that?
15:31:12 <quchen> `nand`: It would work, but not for what he's trying to accomplish
15:31:17 <`nand`> right
15:31:36 <hpaste> merijn pasted “List example” at http://hpaste.org/79779
15:31:52 <merijn> DrChaos: Ignore the term, looke at the code, see if it makes sense :)
15:32:00 <mantovani> http://hpaste.org/79780
15:32:05 <mantovani> I need let this code faster
15:32:08 <mantovani> :'(
15:32:28 <mantovani> no ideia what do
15:32:36 <merijn> "merijn, what did you do all week?" 'Got drunk and taught people Haskell!'
15:32:42 <nade> merijn: Im afraid i don't follow. Why not " def and ( a, b ):
15:32:46 <merijn> Actually, this sounds like a promising carreer :p
15:32:55 <mantovani> given two hours I have to calculate the difference in minutes of then
15:33:08 <merijn> nade: Well, you could do that too if you wanted. No realy difference
15:34:27 <lian_> hey guys... anyone knows how could I construct a function to iterate over a data type deriving Enum, in a way that if it gets to the last element ir returns to the first and so on ?
15:34:46 <merijn> On a related note, if you pay for drinks (and travel/stay, if you're more than a couple of hundred kilometers from the Netherlands) I will totally provide free haskell coaching ;)
15:35:05 <cmccann> lian_, you probably need Bounded as well in order to know what the first element is
15:35:20 <lian_> it is Bounded too
15:35:21 <lian_> hehehe
15:35:25 <merijn> lian_: If you have Bounded and Eq that should be easy
15:35:29 <`nand`> :t cycle [minBound .. maxBound]
15:35:31 <lambdabot> (Bounded a, Enum a) => [a]
15:35:47 <merijn> Oh, I guess even Eq is redundant
15:36:05 <`nand`> > cycle [minBound .. maxBound] :: [Ordering]
15:36:06 <lambdabot>   [LT,EQ,GT,LT,EQ,GT,LT,EQ,GT,LT,EQ,GT,LT,EQ,GT,LT,EQ,GT,LT,EQ,GT,LT,EQ,GT,LT...
15:36:32 <merijn> > cycle [minBound .. maxBound] :: [Bool]
15:36:33 * cmccann likes to define "enumerate = [minBound .. maxBound]"
15:36:34 <lambdabot>   [False,True,False,True,False,True,False,True,False,True,False,True,False,Tr...
15:36:39 <merijn> > cycle [minBound .. maxBound] :: [Int]
15:36:40 <lambdabot>   [-9223372036854775808,-9223372036854775807,-9223372036854775806,-9223372036...
15:37:08 <shachaf> I like the part where Bounded and Enum have nothign to do with each other. :-(
15:37:09 <lian_> wow... a lot of information, let me try some of then...
15:37:15 <lian_> *them
15:37:22 <`nand`> shachaf: they do! it's all informally specified in the comments of Enum
15:37:32 <cmccann> shachaf, I like the part where Enum has nothing to do with much of anything other than desugaring ill-defined notation
15:37:38 <cmccann> "like"
15:37:53 * cmccann grumbles and mutters something about floating point values
15:38:02 <shachaf> Bounded and Ord, too, for that matter.
15:38:22 <cmccann> the hilarious part is that floats aren't even an instance of Bounded
15:38:34 <cmccann> even though they have clearly and explicitly defined minimum and maximum values
15:38:47 <shachaf> > [(-1/0)..(1/0)]
15:38:49 <lambdabot>   [-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Inf...
15:38:51 <cmccann> yet they're an instance of Enum despite that making no sense whatsoever
15:38:51 <`nand`> Infinity, -Infinity? ;)
15:38:52 <merijn> cmccann: Yes, but those are minus and plus infinity >.>
15:39:03 <cmccann> so? they're still bounds.
15:39:12 <cmccann> it's the Enum part that's nonsense :P
15:39:17 * merijn can tell cmccann is a mathematician at heart
15:39:47 <`nand`> > 10^100 < 1/0
15:39:49 <lambdabot>   True
15:39:49 <cmccann> merijn, you may have observed that I meticulously avoid ever calling floating point values "numbers"
15:39:57 <shachaf> cmccann: Did you figure out the traverse business?
15:40:01 <`nand`> > 1/0 < 1/0
15:40:03 <lambdabot>   False
15:40:04 <Nereid> > 10^100 < (-1)/0
15:40:06 <lambdabot>   False
15:40:12 <Nereid> > 1/(-0)
15:40:14 <lambdabot>   -Infinity
15:40:17 <Nereid> > -0
15:40:19 <lambdabot>   0
15:40:22 <Nereid> great.
15:40:27 <Nereid> > -0 :: Double
15:40:29 <lambdabot>   -0.0
15:40:31 <Nereid> oh ok.
15:40:35 <lian_> ok, I manage the cycle thing.. but if the number is huge it seems stupid to cycle through it a gazillion times
15:40:43 <cmccann> shachaf, I tinkered with it a bit more and I think I'm starting to understand it better, as well as how to ditch the uniplate stuff I was using
15:40:44 <Nereid> > 0 == (-0 :: Double)
15:40:46 <lambdabot>   True
15:40:47 <merijn> lian_: Remember laziness
15:41:01 <merijn> lian_: It doesn't actually have to cycle through it a billian times
15:41:30 <cmccann> Nereid, the Eq instance on floats is very special
15:41:35 <lian_> my goal is something like, iterateOver element number_of_iterations
15:41:41 <Nereid> cmccann: floats suck
15:41:44 <Nereid> :p
15:41:48 <shachaf> cmccann: As special as the one on CReal?
15:41:55 <Nereid> > 0 == (-0 :: CReal)
15:41:56 <merijn> Nereid: It just follows IEEE754
15:41:57 <lambdabot>   True
15:42:08 <cmccann> shachaf, not familiar with that one
15:42:16 <merijn> Nereid: Which is really the only sensible thing you can expect from floats
15:42:28 <Nereid> > (1 :: CReal) == log (exp 1)
15:42:29 <lambdabot>   True
15:42:33 <Nereid> oh
15:42:38 <lian_> like, in A | B | C | D , iterateOver B 3 should give me A
15:42:40 <Nereid> what's a harder one.
15:42:59 <shachaf> cmccann: I think it compares up to 40 decimal digits after the . or something.
15:43:05 <shachaf> So that (==) always terminates.
15:43:12 <Nereid> ah that explains things.
15:43:17 <lian_> if its iterateOver B 20093 it shouldnt cycle this much time
15:43:24 <cmccann> shachaf, ahahahaha that's terrible :[
15:43:40 <cmccann> @quote cmccann stick.to.category.theory
15:43:40 <lambdabot> cmccann says: programming is a lot easier if you avoid working with dates/times, text, or numbers. I say stick to category theory, it's simpler
15:43:48 <Nereid> > (1 :: CReal) = (1 + 10^-100)
15:43:50 <lambdabot>   <hint>:1:14: parse error on input `='
15:43:50 <Nereid> > (1 :: CReal) == (1 + 10^-100)
15:43:52 <lambdabot>   Not in scope: `^-'
15:43:52 <lambdabot>  Perhaps you meant one of these:
15:43:52 <lambdabot>    `-' (imported from P...
15:43:57 <Nereid> > (1 :: CReal) == (1 + 10^(-100))
15:43:58 <lambdabot>   *Exception: Negative exponent
15:43:59 <cmccann> that quote explains my feelings about unicode and floats
15:44:02 <Nereid> er
15:44:07 <Nereid> > (1 :: CReal) == (1 + 1/10^100)
15:44:09 <lambdabot>   True
15:44:11 <Nereid> cool.
15:44:18 <shachaf> cmccann: But floats aren't numbers...
15:44:28 <`nand`> > 10^^(-100)
15:44:29 <lambdabot>   9.999999999999998e-101
15:44:56 <Nereid> > head (dropWhile (\n -> (1 :: CReal) /= (1 + 1/2^n))) [1..]
15:44:57 <cmccann> shachaf, I think that quote is from before I started being careful with terminology there
15:44:57 <lambdabot>   Couldn't match expected type `[t0 -> t1]'
15:44:58 <lambdabot>              with actual type `[a...
15:45:15 <Nereid> uh
15:45:30 <lian_> merijn what I need is not an actual cycler, but something like a pointer, where it knows when to start over...
15:45:35 <Nereid> > head . dropWhile (\n -> (1 :: CReal) /= (1 + 1/2^n)) $ [1..]
15:45:37 <lambdabot>   138
15:45:58 <Nereid> > head . dropWhile (\n -> (1 :: CReal) /= (1 + 1/10^n)) $ [1..]
15:46:00 <lambdabot>   42
15:46:19 <merijn> lian_: That's pretty much what laziness results in
15:48:00 <`nand`> CReal compares to 40 digits
15:48:20 <`nand`> of course, you could make your own
15:48:42 <lian_> merijn well, if I search for the nth value, then it will iterate only until n ?
15:48:57 <`nand`> at least, you could, if CReal exported anything
15:48:57 <Nereid> `nand`: but it thinks 1 == 1 + 1/10^41.
15:49:22 <`nand`> Nereid: that's correct for comparing to 40 digits, no?
15:49:32 <Nereid> er
15:49:33 <merijn> lian_: Cycle will just reuse the original list once it hits the end, rather than duplicating the list
15:49:35 <Nereid> it *doesn't* think that
15:49:42 <`nand`> maybe some off by one
15:49:45 <Nereid> > (1 :: CReal) == (1 + 1/10^41)
15:49:47 <Nereid> :p
15:49:47 <lambdabot>   False
15:49:50 <`nand`> but the source code says ‘40’
15:50:05 <Nereid> @src cycle
15:50:06 <lambdabot> cycle [] = undefined
15:50:06 <lambdabot> cycle xs = xs' where xs' = xs ++ xs'
15:50:14 <parcs> > 1 + 1/10^41
15:50:16 <lambdabot>   1.0
15:50:18 <parcs> > 1 + 1/10^41 :: CReal
15:50:20 <lambdabot>   1.0
15:50:25 <`nand`> > ceiling (40 * logBase 2 10 :: Double) + 4
15:50:27 <parcs> > 1 + 1/10^40 :: CReal
15:50:27 <lambdabot>   137
15:50:28 <lambdabot>   1.0000000000000000000000000000000000000001
15:50:36 <`nand`> yeah, it checks 137 bits
15:50:43 <`nand`> > logBase 10 (2^137)
15:50:45 <lambdabot>   41.24110940596542
15:50:52 <Nereid> ok, I'd believe that.
15:51:26 <Nereid> > (1 + 1/10^42) ^ (10^42)
15:51:28 <lambdabot>   1.0
15:51:30 <Nereid> > (1 + 1/10^42) ^ (10^42) :: CReal
15:51:35 <lambdabot>   mueval-core: Time limit exceeded
15:51:37 <Nereid> damn
15:51:38 <Nereid> :p
15:51:41 <Nereid> > (1 + 1/10^42) ** (10^42) :: CReal
15:51:43 <lambdabot>   2.7182818284590452353602874713526624977572
15:51:47 <Nereid> cool.
15:51:51 <Nereid> > exp 1 :: CReal
15:51:52 <lambdabot>   2.7182818284590452353602874713526624977572
15:52:02 <ion> nice
15:52:25 <Nereid> I bet ** is written with exp and log anyway
15:53:09 <`nand`>     x ** y              =  exp (log x * y)
15:53:13 <Hafydd> > (-1) ** 2
15:53:13 <Nereid> > (1 + 1/10^42) ** (10^42) - exp 1 :: CReal
15:53:14 <`nand`> that's the default definition in Floating
15:53:15 <lambdabot>   1.0
15:53:15 <lambdabot>   can't find file: L.hs
15:53:17 <`nand`> and CReal doesn't overwrite it
15:53:22 <Nereid> > (1 + 1/10^42) ** (10^42) - exp 1 :: CReal
15:53:23 <lambdabot>   0.0
15:53:30 <Nereid> ergh
15:53:34 <Nereid> > log ((1 + 1/10^42) ** (10^42) - exp 1) :: CReal
15:53:37 <lambdabot>   *Exception: log of negative number
15:53:42 <Nereid> of course.
15:53:50 <Nereid> > log (exp 1 (1 + 1/10^42) ** (10^42)) :: CReal
15:53:52 <lambdabot>   No instance for (GHC.Float.Floating
15:53:52 <lambdabot>                     (a0 -> Data.Number....
15:53:52 <Nereid> > log (exp 1 - (1 + 1/10^42) ** (10^42)) :: CReal
15:53:55 <lambdabot>   -96.4017210863098640381728732182014732873218
15:54:06 <Nereid> > logBase 10 (exp 1 - (1 + 1/10^42) ** (10^42)) :: CReal
15:54:08 <lambdabot>   -41.8667355137607293675626099758078879444738
15:54:24 <`nand`> :)
15:54:35 <Hafydd> > (-1) ** 0.5
15:54:36 <lambdabot>   NaN
15:54:42 <Nereid> > (-1) ** 0.5 :: CReal
15:54:44 <lambdabot>   *Exception: log of negative number
15:54:51 <`nand`> > (-1) ** 0.5 :: Complex CReal
15:54:52 <lambdabot>   0.0 :+ 1.0
15:54:59 <Nereid> cool.
15:55:27 <Nereid> @let epsilon = 1/10^100
15:55:30 <lambdabot>  Defined.
15:55:36 <Nereid> :t epsilon
15:55:38 <lambdabot> Fractional a => a
15:55:40 <Nereid> ok.
15:56:05 <Nereid> > (1 :+ epsilon) ** (2*pi/epsilon) :: Complex CReal
15:56:09 <lambdabot>   mueval-core: Time limit exceeded
15:56:13 <Nereid> ergh
15:56:28 <Nereid> > (1 :+ 1/10^42) ** (2*pi*10^42) :: Complex CReal
15:56:31 <lambdabot>   1.0 :+ 0.0
15:56:43 <`nand`> > (1 :+ epsilon) ** (2*pi/epsilon) :: Complex Double
15:56:45 <lambdabot>   1.0 :+ (-2.4492935982947064e-16)
15:56:57 <`nand`> darn Double
15:57:03 <Nereid> that's pretty close I guess
15:58:43 <lian_> merijn given an element, which function will give me the order of that element IN THE DATA DEFINITION ?
15:59:02 <lian_> *index
16:02:45 <DrChaos> hello
16:03:33 <Nereid> lian_: if the Enum instance is nice, fromEnum will do it.
16:03:35 <Nereid> :t fromEnum
16:03:36 <lambdabot> Enum a => a -> Int
16:03:40 <DrChaos> would somebody please help me with my parse error? http://vpaste.net/st6A7
16:04:01 <Nereid> DrChaos: please also paste the error.
16:05:32 <DrChaos> http://vpaste.net/oU4pE
16:05:34 <DrChaos> done
16:06:10 <lian_> wow! thanx Nereid
16:06:30 <Nereid> urgh
16:06:35 <Nereid> DrChaos: you have unbalanced parentheses
16:09:15 <DrChaos> Got it  fixed, thanks Nereid
16:13:13 <zugz> Would some generous soul mind having a look at a ghc overloading resolution problem I can't understand: http://pastebin.com/gV6j2QNB ?
16:16:44 <Nereid> zugz: x <+> y has type g, while you need to return a PHS g
16:17:11 <Nereid> so wrap it with a PHS. also, you probably need a Action g g constraint as well.
16:17:33 <Nereid> or Monoid g
16:18:10 <zugz> Nereid: oh dear yes... just blindness, then! Thanks alot
16:18:40 <zugz> Nereid: works after I wrap it with a PHS
16:18:49 <Nereid> :)
16:21:16 <cmccann> edwardk, you around?
16:22:24 <shachaf> cmccann: Probably sleeping.
16:23:04 <cmccann> he sleeps?
16:23:09 <cmccann> hunh.
16:24:32 <cmccann> had an idea about getting some of the same flexible inference that fundeps offer using type families instead
16:25:02 <cmccann> with a bit less namespace pollution
16:25:14 <cmccann> vs. what you'd need to do it in the obvious way with tfs
16:42:38 <lian_> what to do when ghci do not find a module?  should I compile it manually ?
16:43:10 <timemage> lian_, tried cabal?
16:43:59 <lian_> im trying to use  "import Test.Framework.Providers.HUnit", I've already installed it for another program... it installs just locally ?
16:45:20 <cmccann> lian_, don't think GHCi will see modules from packages you install while it's running
16:45:38 <cmccann> if you just installed it that could be why?
16:47:52 <lian_> cmccann no... I've installed it this morning when playing with koans and stuff, now I want to use it in another program but GHCI cant find it...
16:48:45 <cmccann> did you install it with cabal?
16:50:35 <lian_> cmccann yes, actually it was with cabal-dev
16:51:31 <cmccann> cabal-dev keeps separate environments for things, doesn't it? if you're outside the environment you installed it in then yeah it's not there
16:52:20 <dalkire-npr> Hi, I'm trying to connect to a remote host using Network.Socket but I'm having trouble. How can I point to a hostname? I'm looking at connect and SockAddr but SockAddrInet takes PortNumber and HostAddress. HostAddress is type Word32 and not String as I was hoping.
16:53:40 <shachaf> @google haskell tcp client
16:53:42 <lambdabot> http://sequence.complete.org/node/257
16:53:42 <lambdabot> Title: A simple TCP client | The Haskell Sequence
16:53:53 <shachaf> It looks like connectTo might do what you want?
16:54:26 <lian_> yeah, nice, Ill try to install it globally
16:56:34 <dalkire-npr> shachaf: thanks. i'll take a look
17:05:06 <shachaf> roconnor: For "notches" on http://r6.ca/blog/20121209T182914Z.html , what was your rank-2 solution?
17:06:00 <lian_> cmccann well, it does not install... cabal does not find the package, I'm confused now
17:06:18 <shachaf> Peaker was asking about a similar issue (Traversable f => (a -> b) -> f a -> f (Context a b (f b)), I think), and doing it without any partiality seems annoyingly difficult
17:07:26 <cmccann> lian_, I've not used cabal-dev so I'm not really sure why it would work there but not otherwise...
17:09:50 <sorressean> someone mind explaining this to me? main :: IO ()
17:09:50 <sorressean> main = getArgs >>= print . haqify . head
17:10:09 <lian_> cmccann worked... I was using the wronk name of the package! Huehauehauea, stupid mistake! Thanks!
17:10:10 <sorressean> I seen it on the wiki, but I've never seen code like it. what's up with the IO and the >>=?
17:10:17 <Peaker> sorressean, it might be slightly easier to read as:   main = print . haqify . head =<< getArgs
17:10:57 <Peaker> sorressean, the "IO ()" means that "main is an IO action with a result type of ()" -- i.e nothing interesting as a final result, the main interest is the IO effects
17:11:46 <Peaker> sorressean, getArgs >>= function    means: "Make an IO action that first executes the effects of getArgs, takes those results, hands them to function, and then executes the action that resulted from function"
17:11:58 <sorressean> o. gotcha, thanks. guess I haven't hit actions yet.
17:12:11 <sorressean> I just wanted tostart playing with code and I can't drop the example code in ghci.
17:12:24 <Peaker> sorressean, i.e: the >>= operator takes an IO action and a function that generates another IO action, and builds a "composite" action that executes both, in order, while also chaining the result from the first to the latter
17:12:35 <Peaker> sorressean, you should be able to drop this into ghci
17:12:54 <sorressean> Peaker:  nods. there was some other code from learn you a haskell I couldn't drop in ghci.
17:13:10 <Peaker> sorressean, ghci is not exactly like a Haskell file.. it is more like you're stuck inside a "do" block
17:13:20 <Peaker> sorressean, so if you want: foo = 1,   you need to use:  let foo = 1
17:13:27 <sorressean> ah.
17:13:30 <sorressean> makes sense.
17:13:31 <Peaker> sorressean, if you want to define a multi-line construct, you need to do
17:13:34 <Peaker> :{
17:13:37 <Peaker> my multiline here
17:13:38 <Peaker> :}
17:14:00 <sorressean> Peaker:  is that common for functions that are longer?
17:14:06 <sorressean> with guards and such?
17:14:15 <Peaker> sorressean, typically you just edit an .hs file, and use :load from ghci
17:14:37 <Peaker> sorressean, but if you don't want the file, just a quick test, then :{ :} is useful. A bit cumbersome, though
17:14:56 * sorressean nods. thanks
17:24:33 <lian_> cmccann shit... it installed, but ghci still cannot find the module
17:25:25 <cmccann> lian_, I'm out of ideas, sorry, maybe someone else can think of something D:
17:26:17 <lian_> cmccann solved... the freaking module had a separate package for itself...
17:26:28 <lian_> hehehe, thanks again!
17:26:29 <cmccann> haha, ok
17:26:43 <sorressean> hrm. I was trying to play with filter. I have filter (/2) [1..100]. so it filters out all numbers that aren't divisible by 2, but it returns an error with fractional bools. is there a way to do that?
17:28:57 <Peaker> sorressean, you need to give filter a function that returns a boolean, and numbers aren't booleans in Haskell
17:29:14 <sorressean> ah. so I can't inline that code?
17:29:23 <Peaker> also, you want the modulus, and not the division?
17:29:31 <Peaker> filter (\x -> x `mod` 2 == 0) ....
17:29:42 <sorressean> ah nods. thanks.
17:29:48 <Peaker> or, if you feel comfortable with sections and function composition, then:  filter ((== 0) . (`mod` 2)) ...
17:30:07 <shachaf> Or even:
17:30:09 <sorressean> not ever seen the \x -> x...
17:30:10 <shachaf> filter even [1..100]
17:30:27 <shachaf> (I guess that doesn't help you much, though.)
17:30:52 <sorressean> naw, I just wanted to learn how to do that.
17:31:13 <Peaker> sorressean, it defines an anonymous function, which can also use variables from the surrounding scopes in its body
17:31:29 <sorressean> ah, lambda.
17:31:47 <sorressean> so you bind the left side of `mod` to the lambda.
17:31:49 <Peaker> yeah \ is the ascii symbol that most resembles the greek lambda
17:32:01 <sorressean> o!
17:32:24 <Peaker> sorressean, well, \x -> ((x `mod` 2) == 0)   is how it is parsed
17:32:46 <sorressean> meh. if my CS courses would cover something like haskell... they'd hold my attention!
17:33:01 <sorressean> o. so it just creates an anonymous function as the func to be passed in.
17:33:07 * sorressean nods.
17:33:45 <Peaker> sorressean, yeah, and when you write:  f x = ... x ...    it is (almost) equivalent to writing: f = \x -> ... x ...
17:34:10 <Peaker> sorressean, also: f x y z = \x y z -> ..    and \x y z -> ..  is the same as:  \x -> \y -> \z -> ...
17:34:19 * sorressean nods.
17:34:21 <Peaker> oops
17:34:22 <sorressean> higher order funcs?
17:34:27 <Peaker> f x y z = ... is like: f = \x y z -> ..
17:34:31 <sorressean> ur not higher order funcs, but they end up breaking apart.
17:35:06 <Peaker> sorressean, well, in Haskell functions of multiple arguments are generally "curried", that means that they take an argument, return a function to take the next argument, which will again return a function to take the next argument, and so on
17:35:17 * sorressean nods.
17:35:25 <sorressean> was trying to remember the name from the chapter I just read.
17:35:25 <Peaker> sorressean, so every function of more than 1 argument in Haskell is actually "higher order" simply because it returns a function
17:35:35 <sorressean> haha. that's sweet.
17:36:06 <Peaker> so that makes the conventional "higher order" definition useless in Haskell :) so in Haskell context, "higher order" usually means taking function arguments, rather than returning function results
17:36:48 * sorressean nods.
17:38:46 <Peaker> sorressean, are you going through LYAH?
17:39:24 <sorressean> Peaker:  yep!
17:39:46 <Peaker> sorressean, cool, I haven't read a lot of it, but everyone says it's great
17:40:05 <sorressean> Peaker:  I like it so far. sometimes you have to rearead sections, but that's not so bad. I'm hoping some of my questions get answered.
17:43:04 <hpaste> nabilhassein pasted “parseCharacter” at http://hpaste.org/79782
17:43:26 <nabilhassein> hello all, i just pasted a solution from "write yourself a scheme" that i find unsatisfactory
17:44:13 <nabilhassein> i don't like the way "space" and "newline" are hardcoded into the function, especially as the scheme standard specifies many other long character names, so i want to factor it out
17:44:57 <nabilhassein> i'd like to write a "tryAll" function that does try on each String from a [String] in turn and returns the first one that matches, if there is one
17:45:16 <nabilhassein> but i don't understand monad transformers so the parsec types are meaningless to me
17:45:27 <nabilhassein> does anyone know how to do what i'm attempting?
17:45:37 <DrChaos> ok, there is this exercise in the real world haskell book that says to turn a list into a palindrome so that it reads the same forwards and backwards
17:45:55 <DrChaos> to do this I need a way to reverse a list so that it reads backwards
17:46:27 <DrChaos> my first try is: reverse' (x:xs) = reverse' (xs ++ x)
17:47:02 <DrChaos> > reverse' (x:xs) = reverse' (xs ++ x)
17:47:03 <lambdabot>   <hint>:1:17: parse error on input `='
17:47:12 <nabilhassein> drchaos: try reverse' (x:xs) = (reverse' xs) ++ [x]
17:47:29 <nabilhassein> x will have type a, but xs will have type [a]
17:47:46 <nabilhassein> (++) has type [a] -> [a] -> [a] so you can't pass x as a parameter to it
17:48:43 <DrChaos> your solution seems kind of obvious now that I look at it
17:49:07 <nabilhassein> drchaos: yeah, it's naive and probably grossly inefficient, but it works
17:50:55 <DrChaos> @src reverse
17:50:55 <lambdabot> reverse = foldl (flip (:)) []
17:51:01 <DrChaos> wtf
17:51:12 <DrChaos> what does flip cons do?
17:51:16 <DrChaos> @src flip
17:51:17 <lambdabot> flip f x y = f y x
17:51:29 <DrChaos> oh haha, that's amazing
17:51:47 <DrChaos>  4 palindrome (x:xs) = (x:xs) ++ (reverse' (x:xs))
17:52:18 <DrChaos> that does the trick, turning a list into a palindrome in 3 lines of code
17:52:33 <nabilhassein> drchaos: in palindrome i think it would be nicer to just call the variable xs instead of (x:xs) since there's no reason to disallow the empty list
17:53:16 <int-e> > ap (++) reverse [1,2,3] -- scnr
17:53:19 <lambdabot>   [1,2,3,3,2,1]
17:53:32 <sw2wolf> :t ap
17:53:33 <lambdabot> Monad m => m (a -> b) -> m a -> m b
17:53:54 <DrChaos> > isPalindrome (x:xs) = (x:xs) == reverse (x:xs)
17:53:56 <lambdabot>   <hint>:1:21: parse error on input `='
17:54:06 <int-e> :t \f g x -> f x (g x)
17:54:08 <lambdabot> (t2 -> t1 -> t) -> (t2 -> t1) -> t2 -> t
17:55:10 <int-e> sw2wolf: that function - the S combinator - is a particular instance of ap.
17:55:43 <sw2wolf> yep
17:56:43 <Jafet> > text $ ap (++) show "> text $ ap (++) show "
17:56:45 <lambdabot>   > text $ ap (++) show "> text $ ap (++) show "
17:56:57 <shachaf> Jafet: You forgot the space before the >
17:57:49 <Jafet>   > text $ ap (++) show "  > text $ ap (++) show "
17:58:07 <shachaf>  
17:58:19 <shachaf> Hmm.
17:58:26 <shachaf> I guess that's not quite a quine.
17:58:44 <shachaf>  
17:59:08 <lambdabot> ​
17:59:18 <shachaf> There.
17:59:20 <Eduard_Munteanu> lolwut
18:00:13 <Jafet> You forgot the space.
18:00:22 <shachaf> I tried. :-(
18:01:08 <catsbydlo> :t (
18:01:09 <lambdabot> parse error (possibly incorrect indentation)
18:02:09 <Jafet> > <hint>:1:1: parse error on input `<'
18:02:11 <lambdabot>   <hint>:1:1: parse error on input `<'
18:03:20 <Eduard_Munteanu> >   <hint>:1:1: parse error on input `<'
18:03:21 <lambdabot>   <hint>:1:1: parse error on input `<'
18:03:26 <Eduard_Munteanu> There.
18:04:41 <Jafet> Why is the column still 1
18:05:05 <Eduard_Munteanu> Oh... hm. Why indeed...
18:06:00 <catsbydlo> :t :t
18:06:01 <lambdabot> parse error on input `:'
18:06:05 <sw2wolf>  > ap (++) (\_->"abc") "123"
18:06:22 <sw2wolf> > ap (++) (\_->"abc") "123"
18:06:24 <lambdabot>   "123abc"
18:08:07 <catsbydlo> > (++) (fix (\_->"abc")) "123"
18:08:09 <lambdabot>   "abc123"
18:08:40 <Peaker> @check liftA2 (==) (fix . const) const
18:08:42 <lambdabot>   Not in scope: `myquickcheck'
18:12:39 <MaybeCallMe> Is there Either a b c ?
18:13:09 <catsbydlo> no
18:13:15 <MaybeCallMe> :( ok
18:13:24 <catsbydlo> why?
18:13:45 <MaybeCallMe> gotta write it then. data Either a b c = Left a | Center b | Right c
18:14:12 <Peaker> MaybeCallMe, Either a (Either b c) ?
18:14:30 <MaybeCallMe> Peaker: hmm that ccould help too
18:14:32 <Peaker> MaybeCallMe, if you've got a particular case of 3 options, it is better to just define a specific ADT
18:14:53 <Peaker> MaybeCallMe, i.e:  data Missiles = InSilo | Launching | Launched
18:15:06 * Eduard_Munteanu ponders lifted Either, analogous to lifted tuples.
18:15:17 <Mortchek> Type-level lists would be neat
18:15:25 <Mortchek> So you could have an arbitrary number of options
18:15:28 <MaybeCallMe> Peaker: it just keeps appearing again and again.. and the logic for the 3 cases are similar too. that is why i thought i want to abstract it away
18:15:36 <Mortchek> Eduard_Munteanu, what do you mean by lifted?
18:16:02 <Eduard_Munteanu> Mortchek: (a, b, c) as opposed to (a, (b, c)) or ((a, b), c)
18:16:09 <Mortchek> Ah, I see
18:16:26 <Peaker> MaybeCallMe, do you have various types of 3s?
18:16:33 <MaybeCallMe> yes
18:19:16 * hackagebot shelly 0.15.3.2 - shell-like (systems) programming in Haskell  http://hackage.haskell.org/package/shelly-0.15.3.2 (GregWeber)
18:22:27 <Jello_Raptor> http://hpaste.org/79783 :P
18:22:44 <Jello_Raptor> project euler and haskell, the temptation for oneliners is far too high
18:23:13 <Rembane> But it's awesome! :D
18:23:18 <Jello_Raptor> (link is proj Euler prob 5 spoiler)
18:24:04 <Peaker> Jello_Raptor, map f . map g = map (f . g)
18:24:13 <Peaker> concat . map f = concatMap f
18:24:14 <Jello_Raptor> oh <_< d'oy
18:24:22 <Peaker> foldl (*) 1 = product
18:24:28 <Jello_Raptor> >_>
18:24:34 * Jello_Raptor is a relative haskell noob
18:26:48 <hpaste> Peaker annotated “Project euler 5 ” with “Hopefully got it right” at http://hpaste.org/79783#a79784
18:28:24 <hpaste> “Rohit Ramesh” annotated “Project euler 5 ” with “Hopefully got it right (annotation)” at http://hpaste.org/79783#a79785
18:28:36 <Jello_Raptor> did slihgtly better :P
18:28:51 <Jello_Raptor> (3 characters better ... '>_> )
18:29:15 <Peaker> nice
18:29:50 <Jello_Raptor> btw primes is an infinite list of primes, and smallestmultiple n should give the smallest number that evenly divides all of [1..n]
18:31:39 <lolcathost> > iterate (\(a,b) -> (lcm a b, b - 1)) (1,20) !! 21
18:31:40 <lambdabot>   (0,-1)
18:32:08 <Jello_Raptor> > pl \ x -> (x ^ c) < n
18:32:09 <lambdabot>   <hint>:1:4: parse error on input `\'
18:32:14 <lolcathost> Oh, dumb me.
18:32:24 <lolcathost> > iterate (\(a,b) -> (lcm a b, b - 1)) (1,20) !! 20
18:32:26 <lambdabot>   (232792560,0)
18:32:44 <lolcathost> Jello_Raptor: Is that the correct answer?
18:33:27 <Jello_Raptor> lolcathost: yup, hmm, didn't know prelude had an lcm function
18:33:38 <lolcathost> Hehe.
18:33:43 <byorgey> > foldr lcm 1 [1..20]
18:33:45 <lambdabot>   232792560
18:33:53 <Jello_Raptor> damn you all ...
18:33:57 <Jello_Raptor> :P
18:34:13 <lolcathost> byorgey: Duh... I did not take the last obvious step to use a fold.
18:34:18 <byorgey> =)
18:35:22 <Jello_Raptor> byorgey: well, you beat me by a whole lot, well done
18:35:45 <newsham> foldr?  i barely knowr!
18:35:46 * cmccann is probably going to hell for the IsString instance he just wrote
18:36:22 <shachaf> cmccann: That's what made a difference, eh?
18:36:25 <newsham> is hell a monad?
18:36:28 <shachaf> Out of everything?
18:36:35 <cmccann> shachaf, yes absolutely
18:36:40 <cmccann> though actually
18:36:40 <ion> cmccann: What is the IsString instance you just wrote?
18:36:48 <cmccann> it's probably not really that bad
18:36:48 <shachaf> hion
18:36:53 <ion> hachaf
18:37:00 <cmccann> ion, instance (IsString a, Stream s m Char) => IsString (ParsecT s u m a)
18:37:07 <cmccann> that should tell you everything you need to know about what it's doing
18:37:23 <shachaf> Eh, could be worse.
18:37:29 <newsham> ?djinn instance (IsString a, Stream s m Char) => IsString (ParsecT s u m a)
18:37:29 <lambdabot> Cannot parse command
18:37:31 <ion> cmccann: fromString = string?
18:37:46 <cmccann> ion, almost
18:37:47 <lolcathost> Is there any library for conveniently reading files that allows the programmer to use fseeks?
18:38:23 <lolcathost> I mean... I love how convenient it is to read files using something like conduit, but if I want to read the file in a non-sequential manner, I am out of luck.
18:38:25 <shachaf> cmccann: Can you write a function :: Traversable t => (a -> b) -> t a -> t (a, b -> t b)?
18:38:31 <ion> lolcathost: As in, hSeek?
18:38:36 <cmccann> ion, it also eats whitespace and does a few other things to handle keywords vs. identifiers
18:38:41 <lolcathost> ion: What's that?
18:38:47 <ion> @hoogle hSeek
18:38:48 <lambdabot> System.IO hSeek :: Handle -> SeekMode -> Integer -> IO ()
18:38:48 <lambdabot> GHC.IO.Handle hSeek :: Handle -> SeekMode -> Integer -> IO ()
18:38:56 <shachaf> Might as well put the evil energy to good use, right?
18:39:01 <cmccann> basically a string = match a terminal symbol in the grammar
18:39:22 <shachaf> Oh, wait, that function is easy.
18:39:26 <lolcathost> ion: Yeah, but I would rather not touch anything directly involving handles.
18:39:27 <shachaf> (Or is it?)
18:40:17 <cmccann> shachaf, I'm not sure what that function would be doing to be honest
18:40:22 <ion> shachaf: Btw, if you have random crap you’d like to dump to the lens repository, “scripts” is the official place for that.
18:40:27 <shachaf> ion: I saw.
18:40:30 <Nereid> lolcathost: so you're looking for some abstraction to handles that allows seeking?
18:40:48 <lolcathost> Nereid: Exactly!
18:40:52 <Nereid> hmm
18:42:02 <shachaf> Wait, maybe it's not easy. :-(
18:42:32 <Nereid> how many non-filehandle things allow seeking, anyway?
18:42:38 <shachaf> cmccann: It would replace each value in the container with a pair of the old value and a function that can give you the same container with the new value.
18:43:00 <shachaf> cmccann: Since the type of the new container is different, you also give it a boring f function to map over all the other values.
18:43:42 <cmccann> shachaf, ah ok hm
18:44:05 <shachaf> cmccann: Without changing the types you might write foo :: Traversable t => t a -> t (a, a -> t a)
18:47:26 <shachaf> cmccann: I think you might be able to do something clever with continuations.
18:47:46 <cmccann> you can always do something clever with continuations
18:48:15 <shachaf> (It's a trickier problem than it looks like.)
18:48:33 <shachaf> (It's easy-ish to do if you're OK with some partial functions here and there.)
18:56:23 <neutrino_> `nand`: ah, thanks
19:09:33 <neutrino_> is there a way of specifying a type as e.g. a -> String, without the "forall a" in front? that is, "figure out the left type, because I can't be bothered"?
19:12:31 <Nereid> if only.
19:12:55 <Nereid> type holes would let us do that though.
19:14:16 <Rembane> You dig a hole and find a type?
19:14:32 <Jafet> http://okmij.org/ftp/Haskell/types.html#partial-sigs
19:24:20 <Nereid> oh, so -XTypeHoles isn't that.
19:24:23 <Nereid> misleading name.
19:25:11 <cmccann> shachaf, you figure out your function yet?
19:26:26 <Nereid> TypeHoles is just holes.
19:26:59 <Nereid> in expressions.
19:27:01 <Nereid> not types.
19:27:21 <shachaf> cmccann: Nope.
19:27:27 <shachaf> cmccann: Did you?
19:27:54 <cmccann> maybe, not sure if it'll work.
19:29:42 <shachaf> cmccann: (Using partial functions doesn't count.)
19:31:12 <shachaf> It's not hard to write a function :: Traversable f => (a -> b) -> f a -> [(a, b -> t)]
19:31:23 <shachaf> And then you can traverse over the structure and distribute the list back into it.
19:31:31 <shachaf> But doing it safely is harder. :-(
19:31:49 <shachaf> Hmm...
19:31:56 <shachaf> Maybe it's just a matter of zipping Bazaars.
19:32:26 <shachaf> Oh, not really.
19:34:13 <neutrino_> Jafet: that's not what i'm looking for though.
19:35:00 <neutrino_> Jafet: notice that he's only able to make the specification of constraints, and the right hand side of => in the type, separate
19:35:17 <neutrino_> Jafet: what i want is to be able to separately specify parts of the right hand side of =>
19:36:09 <neutrino_> it's still a pretty good trick though
19:36:14 <neutrino_> just not applicable in my case
19:36:21 <neutrino_> i'll make note of it
19:36:37 <roconnor> shachaf: that type is wrong
19:36:57 <roconnor> Traversable f => (a -> b) -> f a -> ([a], [b] -> t) is more correctish
19:37:23 <shachaf> roconnor: The type I gave is a sort of generalized holesOf
19:37:39 <roconnor> er
19:37:48 <shachaf> homesOf :: (a -> b) -> ATraversal s t a b -> s -> [Context a b t]; homesOf f l s = go (toListOf (cloneTraversal l) s) (wOuts l s) where { go [] _ = []; go (x:xs) g = Context (g . (:map f xs)) x : go xs (g . (f x:)) }
19:37:49 <roconnor> Traversable f => (a -> b) -> f a -> ([a], [b] -> f b) is more correctish
19:38:01 <roconnor> shachaf: you cannot generalize holesOf
19:38:17 <shachaf> roconnor: What's wrong with the function I just pasted?
19:38:32 <shachaf> Other than using wOuts, which is partial. :-(
19:38:36 <roconnor> Traversable f => (a -> a) -> f a -> [(a, a -> f a)] is maybe what you mean
19:38:47 <shachaf> (But the function as a whole is guaranteed safe.)
19:38:49 <roconnor> but you cannot change the type parameter
19:38:55 <roconnor> of a single element
19:39:04 <shachaf> No, it's changing the whole Traversable.
19:39:12 <shachaf> It's applying the (a -> b) to the rest of the elements.
19:39:18 <shachaf> And putting your new b in for the one at the hole.
19:39:24 <roconnor> b -> f b  changes only one element
19:39:44 <roconnor> oh
19:39:50 <roconnor> ah sorry
19:39:51 <roconnor> my bad
19:40:22 <shachaf> Peaker needed something along the lines of bar :: Traversable f => (a -> b) -> f a -> f (Context a b (f b)) the other day.
19:40:58 <neutrino_> hmm
19:41:11 <shachaf> Which is very related to your notches puzzle.
19:41:19 <shachaf> (I didn't know about the notches puzzle at the time.)
19:41:51 <neutrino_> what if i said something like: fooSig = undefined :: String, and then: foo | False = fooSig ?
19:44:02 <neutrino_> > let fooSig = (undefined :: String) in foo | False = fooSig
19:44:03 <lambdabot>   <hint>:1:43: parse error on input `|'
19:44:11 <neutrino_> why is lambdabot having problems with this?
19:44:42 <Saizan> foo is not in the let
19:46:38 <shachaf> @ty let hmm f = go [] where go acc [] = []; go acc (x:xs) = (x, \b -> reverse acc ++ b : map f xs) go (f x:acc) xs in hmm
19:46:39 <lambdabot>     The function `(x, \ b -> reverse acc ++ b : map f xs)'
19:46:39 <lambdabot>     is applied to three arguments,
19:46:40 <lambdabot>     but its type `(a1, a0 -> [a0])' has none
19:46:48 <shachaf> @ty let hmm f = go [] where go acc [] = []; go acc (x:xs) = (x, \b -> reverse acc ++ b : map f xs) : go (f x:acc) xs in hmm
19:46:50 <lambdabot> (a1 -> a) -> [a1] -> [(a1, a -> [a])]
19:46:58 <shachaf> Even specialized to lists this is really awkward.
19:47:36 <shachaf> > let hmm f = go [] where go acc [] = []; go acc (x:xs) = (x, \b -> reverse acc ++ b : map f xs) : go (f x:acc) xs in map (($ "x") . snd) $ hmm show [1,2,3,4]
19:47:38 <lambdabot>   [["x","2","3","4"],["1","x","3","4"],["1","2","x","4"],["1","2","3","x"]]
19:48:17 <shachaf> Oh, but you can simplify that.
19:49:15 <neutrino_> Saizan: i'm not sure what that means. can you explain this a little differently?
19:49:26 <Nereid> neutrino_: I'm having problems with it.
19:49:34 <Nereid> what are you trying to do?
19:49:51 <Saizan> > let fooSig = undefined :: String; foo | False = fooSig in foo
19:49:52 <lambdabot>   "*Exception: <interactive>:3:35-54: Non-exhaustive patterns in function foo
19:50:00 <Nereid> oh
19:51:11 <Saizan> neutrino_: not sure if that's what you meant, but it's close to what you wrote :)
19:51:37 <neutrino_> yes, it is Saizan
19:51:39 <Nereid> it wouldn't ever think about evaluating fooSig, since the guard never matches anyway.
19:51:40 <neutrino_> now i see what you meant
19:51:51 <neutrino_> yes Nereid
19:52:45 <Nereid> > let False | False = True; False | True = False in True
19:52:47 <lambdabot>   True
19:52:54 <Nereid> I don't know what the point of that was.
19:52:59 <neutrino_> @type let fooSig = undefined :: String; foo x | False = fooSig in foo
19:53:00 <lambdabot> t -> String
19:53:13 <Nereid> @type let foo | False = 5 in foo
19:53:15 <lambdabot> Num a => a
19:53:20 <dolio> More lines = better.
19:53:25 <neutrino_> i have specified the return type without specifying the type of x.
19:53:31 <dolio> I wrap all my code in that.
19:53:47 <Nereid> if you wanted more lines you'd be using java.
19:53:49 <neutrino_> more dolio >>= betterer
19:53:58 <Nisstyre-laptop> Can someone point to a good explanation of the difference between generic and non-generic type variables?
19:54:12 <Nereid> what's a generic type variable?
19:54:32 <Nisstyre-laptop> Nereid: apparently one where a type variable is "shared"
19:54:40 <Nisstyre-laptop> hold on
19:54:41 <Nereid> hmm?
19:55:02 <dolio> Where did you see the distinction?
19:55:07 <Nereid> I'm not sure what you mean, but maybe things would be clearer for you if you put explicit quantifiers everywhere.
19:55:36 <neutrino_> forall type-variable. apparently one where a type-variable is "shared"
19:55:53 <shachaf> Are you thinking of ScopedTypeVariables?
19:55:56 <Nisstyre-laptop> dolio: in a paper on type checking
19:56:06 <shachaf> Oh.
19:56:19 <neutrino_> Nisstyre-laptop: oh good, that only leaves all haskell papers ever written.
19:56:34 <Nisstyre-laptop> neutrino_: I'm getting the link
19:56:48 <neutrino_> :)
19:57:20 <Nisstyre-laptop> neutrino_: https://docs.google.com/open?id=1ehb9FukUo1BnWlZ7JtdWEOi9rvEGZIJn49q4F5cqX1TODVWhCJPpsNzU714U
19:57:41 <Nisstyre-laptop> neutrino_: and I'll write out the two examples it gives in Haskell
19:57:42 <Nisstyre-laptop> one sec
19:57:54 <cmccann> shachaf, urgh I think I'm going to give up on this
19:58:02 <cmccann> I have a rough notion of how it could work
19:58:14 <cmccann> but figuring it out sounds like too much effort
19:58:48 <shachaf> cmccann: What's your rough notion?
19:59:03 <cmccann> something clever with continuations
19:59:14 <cmccann> to capture the intermediate states of the traversal
19:59:22 <shachaf> Right, that was my rough notion too.
19:59:42 <dolio> Nisstyre-laptop: My guess would be that 'generic' type variables are ones that are supposed to be quantified, and 'non-generic' are unification variables that exist during type inference.
19:59:58 <Nisstyre-laptop> dolio: I think that's right, I was just looking for some clarification
19:59:59 <cmccann> right now I have something that doesn't completely preserve the original structure
20:00:24 <shachaf> How?
20:00:28 <Nisstyre-laptop> dolio: http://ideone.com/nSruro
20:00:37 <cmccann> shachaf, (Traversable t) => (a -> b) -> t a -> t (a, b -> [b])
20:00:45 <shachaf> Oh.
20:00:55 <cmccann> where the list is the order the traversal sees elements in obviously
20:00:59 <Nisstyre-laptop> er, I forgot to apply f to True there
20:01:00 <shachaf> Sure, and then you can use State (partially) to distribute the [b] back over the t a
20:01:20 <shachaf> And given that the list is guaranteed to stay the same length, it'd work.
20:01:21 <Nisstyre-laptop> but you get the idea
20:01:31 <cmccann> hm, yeah
20:01:37 <shachaf> But the clever continuationy bit is doing it without that.
20:01:55 <Nisstyre-laptop> dolio: So a type inference algorithm would try to infer the type of "f" in the commented out one
20:01:56 <cmccann> yeah, I wasn't even really considering doing two traversals
20:01:57 <Nisstyre-laptop> and it would fail
20:02:08 <dolio> Yeah.
20:02:17 <Nisstyre-laptop> because it would try and unify the two constraints that 3 and True impose
20:02:25 <dolio> Yep.
20:02:33 <Nisstyre-laptop> so that's what it means by "shared", right?
20:02:38 <shachaf> cmccann: What about a simpler f a -> f (a -> f a)?
20:02:44 <dolio> I guess.
20:02:48 <shachaf> @ty let foo [] = []; foo (x:xs) = (:xs) : map ((x:) .) (foo xs) in foo
20:02:49 <lambdabot> [a] -> [a -> [a]]
20:02:52 <shachaf> A generalization of that.
20:03:40 <Nisstyre-laptop> dolio: cool, I'm just trying to write my own inference engine. Hard to find material geared towards people without a lot of knowledge of the field.
20:03:47 <dolio> Nisstyre-laptop: It might mean that all uses of f in the first one share a single, particular 'a'.
20:03:53 <Nisstyre-laptop> dolio: yeah
20:03:54 <dolio> And thus have to all be unified.
20:03:57 <Nisstyre-laptop> so they don't copy it
20:04:05 <Nisstyre-laptop> er, or they do?
20:04:05 <cmccann> shachaf, generalizing from lists is already what I'm doing
20:04:14 <dolio> Whereas with the let binding, you instantiate it separately each time.
20:04:25 <cmccann> shachaf, I started from an explicitly recursive version using only lists, which was obviously simple
20:04:25 <Nisstyre-laptop> dolio: ah ok
20:04:43 <Nisstyre-laptop> dolio: so, one instance of the type of 'f' in the first, two instances in the second
20:04:53 <dolio> Yeah.
20:04:54 <Nisstyre-laptop> I guess it has to do with the fact that f is a parameter in the first one
20:05:03 <dolio> This becomes a little clearer when you put quantifiers in.
20:05:29 <cmccann> shachaf, then I generalized it to work for any traversal, but what I was originally thinking didn't work for putting the "t b" part back together
20:05:30 <Nisstyre-laptop> dolio: makes sense
20:05:31 <dolio> Inside g, f has type alpha -> alpha, where alpha is a unification variable.
20:05:51 <shachaf> cmccann: Well, I can't think of a better way of doing it than what I said.
20:05:56 <shachaf> And what I said is pretty bad. :-(
20:06:04 <dolio> But, the let definition gives f :: forall a. a -> a, and then when it gets used, you instantiate the quantifier with a new unification variable each time.
20:06:07 <shachaf> cmccann: (It's what we do in lens, though, in various places.)
20:06:17 <sclv> anyone gotten llvm bindings working on "os x"?
20:06:23 <sclv> any particular steps to take?
20:06:52 <sclv> i guess when i have dev tools i already have all the llvm binaries i need?
20:06:54 <Nisstyre-laptop> dolio: it makes sense now, thanks
20:07:27 <shachaf> sclv: Is it failing?
20:07:30 <dolio> Nisstyre-laptop: That's how the fancier type system extensions do things, and then you can take an argument f :: forall a. a -> a to g.
20:07:45 <dolio> Except you can't generally do inference for that.
20:07:49 <dolio> Without some help.
20:07:49 <Nisstyre-laptop> yeah
20:07:49 <shachaf> Oh, the bindings, not GHC.
20:07:54 <dmwit> > (case id of (id -> id) -> id) "id"
20:07:56 <lambdabot>   "id"
20:07:56 <neutrino_> @type let { fooSig x = undefined :: Int -> String; foo y z | False = fooSig z } in foo
20:07:57 <lambdabot> t -> t1 -> Int -> String
20:08:06 <dmwit> > (case id of id -> id -> id) "id"
20:08:06 <neutrino_> why does this type have 3 arguments? i only specify 2
20:08:07 <lambdabot>   Pattern syntax in expression context: case id of { id -> id } -> id
20:08:13 <sclv> actually, yeah, it just said "failed to find llvm bindings" so i guess i need something installed beyond just apple dev tools
20:09:24 <dmwit> neutrino_: fooSig has two arguments.
20:09:34 <neutrino_> right
20:09:39 <dmwit> neutrino_: Perhaps you meant fooSig = undefined :: Int -> String
20:10:33 <neutrino_> yeah i think i have
20:10:34 <neutrino_> thank you
20:11:09 <dmwit> Meta-question: how was I able to tell that he wanted to drop the 'x' argument, but not the 'y' one?
20:11:34 <dmwit> Like, if I wanted a Sufficiently Smart Compiler, what rule would I write down?
20:11:40 <neutrino_> you read what i was doing before.
20:12:07 <neutrino_> which was to try and find a way of specifying part of a type signature.
20:12:25 <Jafet> GHC should ship with a crystal ball attachment.
20:12:53 <neutrino_> or, you know that functions that are = undefined :: type usually don't have arguments
20:13:38 <lolcathost> neutrino_: Then they aren't functions. :-|
20:14:09 <dmwit> I didn't read any context, though I guess the latter (undefined) was a pretty good tip.
20:14:17 <neutrino_> : -|
20:14:25 <neutrino_> dmwit: yeah.
20:14:56 <shachaf> I think the context is Oleg.
20:14:59 <neutrino_> dmwit: i didn't know about that one. and i'll probably forget it at least once in the future. but it's a good thing to remember
20:16:31 <Nisstyre-laptop> dolio: one more question, when I'm generating new type variables, should I just assign ids to them sequentially to keep track of them?
20:16:53 <dolio> What kind of variable?
20:17:04 <Nisstyre-laptop> dolio: just uninstantiated type variables
20:17:34 <cmccann> shachaf, ok yeah doing it the horrible way "works"
20:17:35 <Nisstyre-laptop> I'm doing this in Racket, and I have a bunch of structs for types and whatnot
20:17:47 <dolio> That's one way to do it.
20:17:49 <shachaf> cmccann: Yep.
20:18:17 <shachaf> > unsafeParts traverse .~ "hello" $ "world"
20:18:19 <lambdabot>   Not in scope: `unsafeParts'
20:18:19 <lambdabot>  Perhaps you meant one of these:
20:18:19 <lambdabot>    `unsafePart...
20:18:23 <shachaf> > unsafePartsOf traverse .~ "hello" $ "world"
20:18:25 <lambdabot>   "hello"
20:18:32 <shachaf> > unsafePartsOf traverse .~ [1,2,3,4,5] $ "world"
20:18:35 <lambdabot>   [1,2,3,4,5]
20:18:37 <shachaf> > unsafePartsOf traverse .~ [1,2,3,4] $ "world"
20:18:40 <lambdabot>   [1,2,3,4,*Exception: unsafePartsOf: not enough elements were supplied
20:18:57 <dolio> One of the popular ways to do unification is via mutable variables that you assign to.
20:19:05 <dolio> Which, if you're using racket, is probably easy.
20:19:21 <neutrino_> so i wonder
20:19:22 <neutrino_> http://okmij.org/ftp/Haskell/partial-signatures.lhs
20:19:31 <neutrino_> why does oleg's mail go through navy.mil?
20:19:47 <neutrino_> is he implementing launchRockets
20:19:55 <cmccann> shachaf, seems like I ought to be able to shove a ContT in here and capture a continuation for each point in the traversal somehow
20:19:57 <Nisstyre-laptop> dolio: hmm, yeah, so I'd just do (set! tvar instantiated-tvar) or whatever
20:20:05 <shachaf> cmccann: Yep.
20:20:25 <dolio> Something like that. After a check to make sure it isn't already instantiated.
20:20:28 <cmccann> but otherwise my current version works, for any Traversable
20:20:42 <Nisstyre-laptop> dolio: yup, I've got that logic written pretty much
20:20:58 <shachaf> cmccann: Using State [b]?
20:21:15 <dolio> neutrino_: Oleg works for the navy, I think. Analyzing the weather or something.
20:21:19 <cmccann> shachaf, sort of
20:21:52 <cmccann> using a state monad to collect the list of elements is the basic idea though
20:22:03 <cmccann> seemed the most obvious place to start
20:22:24 <shachaf> Right.
20:22:30 <shachaf> That's what unsafePartsOf does.
20:22:49 <neutrino_> dolio: really?
20:22:59 <shachaf> (partsOf is the same thing except it reuses old elements instead of ⊥s.)
20:23:04 <dolio> Yeah.
20:23:13 <shachaf> > partsOf .~ "UGH" $ "hello world"
20:23:14 <lambdabot>   Couldn't match expected type `Control.Lens.Internal.Mutator b0'
20:23:15 <lambdabot>            ...
20:23:19 <shachaf> > partsOf traverse .~ "UGH" $ "hello world"
20:23:21 <lambdabot>   "UGHlo world"
20:23:37 <cmccann> shachaf, in this case it seems a reasonable assumption that the traversals will see the same number of elements
20:23:47 <shachaf> > partsOf (both.traverse) %~ reverse $ ("hello","world")
20:23:49 <lambdabot>  Terminated
20:23:57 <shachaf> cmccann: Yep, you get it from the Traversable laws.
20:23:59 <shachaf> > partsOf (both.traverse) %~ reverse $ ("hello","world")
20:24:01 <lambdabot>   ("dlrow","olleh")
20:24:27 <dmwit> Hooray, I finally had a reason to use module Foo (module Foo) where!
20:24:35 <Nereid> D:
20:24:38 <shachaf> cmccann: But I'd still like to see the clever version.
20:24:43 <neutrino_> dolio: how does weather ~ Haskell?
20:24:53 <cmccann> shachaf, yeah, but I think I'm done messing with this for now
20:25:03 <Nereid> dmwit: what is it?
20:25:17 <cmccann> you can have my state-ish implementation if you want, unless you have your own version by now
20:25:26 <dmwit> Nereid: Well, it's actually module Foo (module Foo, module Control.Monad.RWS, module Control.Monad.Error) where
20:25:47 <dmwit> So it exports all the things Foo defines, and also the convenience functions asks and throwError, etc.
20:25:51 <rwbarton> I thought maybe you were importing another module as Foo
20:25:56 <rwbarton> (what would that do?)
20:26:03 <dmwit> It's an error, I think.
20:26:18 <rwbarton> that's not very fun
20:26:29 <shachaf> cmccann: I have a version of it that uses lens functions.
20:26:36 <dmwit> It's probably a lot less surprising than any other choice you could possibly make. =P
20:26:42 <shachaf> cmccann: It's not particularly complicated, but not particularly nice either.
20:26:49 <Nereid> dmwit: hmm, ok
20:27:08 <dmwit> Nereid: (The point being that I don't have to list the 30 things that are defined manually.)
20:27:40 <rwbarton> inside module Foo can I refer to x as Foo.x?
20:28:40 <cmccann> shachaf, or hm wait I think I might have a non-continuation-based way of reusing the traversal
20:28:58 <dmwit> Yes, and you may have to.
20:29:33 <shachaf> cmccann: Oh?
20:29:39 <dmwit> e.g. if Foo defines asks, then Foo.asks and Control.Monad.RWS.asks are the correct way to disambiguate
20:29:41 <cmccann> lemme try this
20:29:47 <rwbarton> ugh
20:30:10 <dmwit> module systems lol
20:30:13 <rwbarton> or if i shadowed a top-level binding x, can i still refer to it with Foo.x?
20:30:17 <dolio> neutrino_: According to edwardk, the weather stuff is fairly boring, but maybe not time consuming, and gives oleg lots of opportunity to do random other stuff, like delimited continuations and whatnot.
20:31:15 <dmwit> rwbarton: er, hm
20:32:01 <dmwit> rwbarton: seems so
20:32:17 <rwbarton> nice(?)
20:32:51 <dmwit> That's not really scalable, though. You can only reach into the top-level namespace, not choose a namespace somewhere between you and the top...
20:32:54 <dmwit> "scalable"
20:33:34 <dmwit> Also, apologies for any typos. Thanks to a huge lag between the computer I'm using and the computer running irssi, I'm basically typing blind.
20:33:45 <cmccann> shachaf, nah, screw it, not gonna work. I think doing something oleg-ish to capture each step of the traversal in a zipper-like manner is the only "elegant" way to do this
20:34:13 <rwbarton> dmwit:  http://mosh.mit.edu/
20:34:37 <neutrino_> dolio: i am surprised there is no embedding of dynamic weather systems in the type system ?!?!
20:34:55 <cmccann> shachaf, how did you end up writing it, anyway?
20:35:36 <shachaf> cmccann: One moment, let me take out the lensy bits.
20:36:13 <cmccann> there are non-lensy bits?
20:36:14 <cmccann> I'm shocked.
20:36:34 <neutrino_> dolio: there's this though: http://okmij.org/ftp/Venus.html
20:38:02 <otters> @pl \x -> x . show
20:38:03 <lambdabot> (. show)
20:38:10 <dolio> Oh man, it's ported to BeOS.
20:38:14 <neutrino_> dolio: i get it.. oleg has access to "weather baloons".. that's how we get advances in Haskell. he's just ripping off aliens.
20:38:17 <otters> @pl \k -> k . \c -> [c]
20:38:17 <lambdabot> (. return)
20:38:30 <neutrino_> (is Haskell a front for a government conspiracy?)
20:38:41 <ion> dmwit: Another vote for mosh.
20:39:31 <neutrino_> dmwit: don't use mosh, just use local echoing
20:39:44 <shachaf> cmcHomesOf f s = go (Fol.toList s) (cmcOuts s) where { go [] _ = []; go (x:xs) g = (x, g . (:map f xs)) : go xs (g . (f x:)) }
20:39:48 <shachaf> cmcOuts = State.evalState . traverse (\_ -> State.state (\(x:xs) -> (x,xs)))
20:39:52 <shachaf> cmcFoo f s = cmcOuts s (cmcHomesOf f s)
20:39:58 <neutrino_> dmwit: your edit line becomes local and you can freely edit it. it is sent when you press enter.
20:40:15 <Nereid> :t uncons
20:40:17 <lambdabot>     Not in scope: `uncons'
20:40:17 <lambdabot>     Perhaps you meant one of these:
20:40:17 <lambdabot>       `BS.uncons' (imported from Data.ByteString),
20:40:21 <Nereid> aw
20:40:33 <shachaf> Nereid: The actual code uses unconsWithDefault (error ...)
20:40:41 <Nereid> mhm
20:40:48 <ion> dmwit: Ignore what he said. ;-)
20:40:48 <neutrino_> dmwit: mosh can't do anything about high ping times. it can only help with intermittently unreliable connections.
20:41:08 <shachaf> cmccann: So that's using the traversal three times, but, y'know, like, who cares, right?
20:41:13 <ion> dmwit: mosh adds intelligent local echoing on top of ssh (among a couple of other things).
20:41:16 <cmccann> shachaf, oh, did you just turn everything into lists and then reconstruct it?
20:41:27 <shachaf> Yep.
20:41:29 <cmccann> pf.
20:41:35 <cmccann> at least I have an honest traversal.
20:41:43 <shachaf> What do you have?
20:41:56 <neutrino_> ion: sure, but then why use the sporknive if a spoon is good enough?l
20:42:19 <dmwit> rwbarton, ion, neutrino_: thanks for the tips!
20:42:25 <dmwit> I'm looking into it now.
20:44:01 * Nereid is looking into mosh too.
20:44:15 <cmccann> shachaf, just a moment, making tea
20:44:56 <neutrino_> dmwit: you can enable local echo by first logging onto your remote host, and then issuing the command line: printf '\e[12l'; stty -echo
20:45:23 <dmwit> WTF
20:45:30 <dmwit> no, lol
20:45:33 <dmwit> I'll just use mosh
20:45:44 <neutrino_> ok :)
20:46:39 <dmwit> Well, I mean, I could reasonably make an alias for that, and then my one objection to it is completely null. So sorry for my reaction.
20:47:15 <neutrino_> i can never forgive you
20:48:09 <neutrino_> hmm. well, i guess i can forgive you after all this time.
20:48:26 <Clint> it's a christmas miracle
20:49:47 <neutrino_> i thought that was when ghc emitted errors in human language
20:52:43 <cmccann> shachaf, ok the code is obviously much longer than it needs to be because I was being needlessly convoluted
20:53:24 <hpaste> “C. McCann” pasted “traversal junk” at http://hpaste.org/79787
20:53:46 <cmccann> minus some tedious details
20:58:46 <jozefg> Hmm Does anyone here run a site in Yesod or Happstack?
20:59:08 <stepkut> jozefg: I run several happstack based sites
20:59:20 <jozefg> stepkut: what do you use for hosting?
20:59:54 <stepkut> jozefg: prgmr.com
21:02:14 <jozefg> Ok great thanks
21:05:04 <shachaf> cmccann: Slide?
21:05:15 <cmccann> shachaf, a modified state monad
21:06:02 <cmccann> one state value holds the elements seen previously, the other holds elements not seen yet
21:06:35 <shachaf> You're still doing two traversals. :-(
21:07:08 <shachaf> cmccann: By the way, a clever version might be asymptotically better than you can do by flattening to a list.
21:07:43 <shachaf> Because for example you can get the last element of the traversal of a tree in log(n) steps.
21:07:59 <shachaf> You should be able to do the same for a tree after you decorate it.
21:08:33 <Nereid> so "flatten" to a tree.
21:09:04 <Nereid> I don't know.
21:09:06 <shachaf> You can do that, and an invalid monoid or something.
21:09:34 <shachaf> But I feel like there ought to be a really nice version.
21:09:34 <Nereid> that's called a magma.
21:09:48 <Nereid> and binary trees are free magmas.
21:09:48 <shachaf> Yep.
21:10:30 <shachaf> Well, a magma with an identity, possibly.
21:15:58 <Nereid> shachaf: I'd rather have a magma with a distinguished element that's not an identity.
21:16:11 <shachaf> True.
21:16:28 <shachaf> In fact that's the type I used in the past for this.
21:17:54 <Nereid> and a free such thing is probably Tree (Maybe a).
21:18:08 <bytes> hey, i just started learning haskell from learnyouahaskell, and i'm wondering how to actually run a function from main
21:18:18 <Nereid> run what function?
21:18:20 <bytes> i guess i just haven't gotten to the part yet in learnyouahaskell
21:18:47 <bytes> if i had something like doubleMe x = x+x
21:18:55 <bytes> how do i print it out in the command line
21:19:01 <Nereid> well, first you need an x.
21:19:06 <bytes> main = prtLn doubleMe 9?
21:19:14 <Nereid> print (doubleMe 9), say
21:19:20 <Nereid> :t print
21:19:22 <lambdabot> Show a => a -> IO ()
21:19:38 <Nereid> (print is exactly what ghci uses)
21:19:43 <bytes> oh ok
21:20:15 <bytes> how would i call multiple functions in the main function, would i just enter and type the next thing it shoudl do
21:20:17 <bytes> should*
21:20:34 <Mortchek> bytes, read up on do notation.
21:20:41 <Nereid> well, for that you need a way of stringing IO actions together. which can be done with do notation
21:20:54 <Nereid> so if you haven't covered that yet, just keep reading :)
21:20:59 <bytes> alright
21:21:23 <bytes> haskell is pretty tough, i didn't want to go with something which was easy to learn over christmas break since uni is out
21:21:29 <dmwit> main = print (doubleMe 9) >> print (doubleMe 34.5) >> print (doubleMe 21)
21:21:58 <bytes> i come from a java background, and i can gladly say, haskell is very hard to learn, but quite amazing to use and faster and smaller code-wise
21:22:06 <bytes> thank you dmwit!
21:22:06 <Nereid> haskell is wonderful. :)
21:22:20 <Nereid> alternatively: (forgive the multiple lines)
21:22:21 <bytes> what applications that are popular use it?
21:22:25 <Mortchek> Haskell is the most expressive/beautiful language I know.
21:22:30 <Nereid> main = do
21:22:30 <Nereid>   print (doubleMe 1)
21:22:31 <Nereid>   print (doubleMe 2)
21:22:42 <bytes> so far, mathematically, its outstanding, but i don't see it being used in something such as a file transfer utility
21:22:52 <Clint> then you don't know about git-annex
21:24:26 <Nereid> I should have a look at git-annex at some point.
21:24:43 <jozefg> I absolutely love it for parsing and AST manipulation
21:25:20 <Nereid> I love it because it has lens. ;)
21:25:57 <bytes> will learnyouahaskell be a good resource to learn haskell off of or do you guys have a better recommendation?
21:26:18 <Nereid> it is frequently recommended around here.
21:26:25 <Nereid> Real World Haskell is another one.
21:26:27 <Nereid> @where rwh
21:26:27 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
21:26:58 <bytes> i'm thinking about porting over a notepad application i have done in java over to haskell at some point, is there a viable method of producing a gui with haskell or with some sort of library in combination with it
21:27:04 <sm> bytes: darcs, pandoc, xmonad, git-annex, haddock, ghc, cabal
21:27:42 <Nereid> bytes: there are a few bindings for gui toolkits, like gtk and wxwidgets
21:28:02 <Jafet> File transfer utility: import Data.ByteString.Lazy as B; main = do [src, dest] <- getArgs; B.readFile src >>= B.writeFile dest
21:28:19 <Nereid> poor man's cp
21:28:39 <Jafet> (ok, dest should be unlinked first.)
21:30:11 <bytes> Jafet, can you explain what that function you wrote just did?
21:31:30 <Nereid> he puts the command line arguments in src and dest, reads the file named by src, and gives its result to a function that writes to the file named by dest.
21:31:31 <Clint> it's the non-conduit version of runResourceT $ sourceFile src $$ sinkFile dest
21:32:13 <Nereid> bytes: but because of lazy IO, it never stores the entire input file in memory.
21:33:03 <bytes> alright
21:33:16 <bytes> so whatever you just said, i will learn that while progressing through learnyouahaskell right? lol
21:33:43 <Nereid> I don't remember what lyah covers.
21:34:12 <Nereid> oh I guess it does talk about lazy IO and ByteString.
21:35:05 <Jafet> I just give dumb answers to dumb questions
21:35:10 <Nereid> lol
21:36:58 <Nereid> bytes: lazy IO is cute (it works nicely in that example) but has some pitfalls (it's not easy to reason about its resource usage and it's easy to accidentally make it less lazy than you want)
21:37:10 <Nereid> which is why Clint mentioned conduits
21:37:33 <Nereid> which give more control over resource usage but are still reasonably compositional
21:37:54 <Jafet> Nah, conduits are just trendy
21:37:58 <Nereid> and they're trendy.
21:38:23 <Clint> unlike lens, which is timeless
21:38:32 <Nereid> totally.
21:38:48 <Nereid> it's only 5 months old but will be around forever. ;)
21:40:09 <bytes> is there a way to pause the cmd when running a haskell program
21:40:21 <Nereid> what, like ctrl-Z?
21:41:08 <bytes> like if i run a program
21:41:11 <bytes> and use the .exe
21:41:14 <bytes> the terminal opens
21:41:17 <bytes> and closes immediatley
21:41:21 <Nereid> oh, windows?
21:41:24 <bytes> is there something like system("PAUSE");
21:41:25 <bytes> yes
21:41:32 <Nereid> uh, why not write a .bat wrapper.
21:41:41 <bytes> hmm, good idea
21:41:50 <Nereid> or just have a long-running terminal
21:45:53 <Nereid> bytes: but if you really wanted to, you could have getLine at the end of the program to wait for input
21:46:01 <Nereid> :t void getLine
21:46:03 <lambdabot> IO ()
21:46:10 <Jafet> Why not use a system with a real terminal
21:46:13 <Nereid> true.
21:46:24 <Nereid> I did suggest just using a terminal to run the program.
21:46:33 <Nereid> which windows does just fine.
21:54:22 <bytes> i actually program in a fedora environment as well, its just that i'm trying to send a program to a friend running windows and for her the window kept closing
21:54:27 <bytes> i sent her the bat file so its all good
21:56:57 <Nereid> :)
21:58:06 <Nereid> @hoogle system
21:58:07 <lambdabot> System.Process system :: String -> IO ExitCode
21:58:07 <lambdabot> System.Cmd system :: String -> IO ExitCode
21:58:07 <lambdabot> package system-argv0
21:58:12 <Nereid> ok
22:47:06 <zakyr> Hello
