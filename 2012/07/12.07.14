00:00:44 <kallisti> haskell-mode is horrible with quasiquotes
00:10:14 <randomclown> is there a "lookup" function that uses the 2nd parameter as the key?
00:11:17 <abernstein> flip lookup
00:19:33 <Axman6> @hoogle threadDelay
00:19:33 <lambdabot> Control.Concurrent threadDelay :: Int -> IO ()
00:19:34 <lambdabot> GHC.Conc.IO threadDelay :: Int -> IO ()
00:19:34 <lambdabot> GHC.Conc threadDelay :: Int -> IO ()
00:20:01 <shachaf> randomclown: There's M.!, except it's evil.
00:20:46 <randomclown> shachaf: why?
00:20:58 <shachaf> Because it's partial, and gives you useless error messages when it fails.
00:20:59 <MostAwesomeDude> :t flip M.lookup
00:21:00 <lambdabot> forall k a. (Ord k) => M.Map k a -> k -> Maybe a
00:21:11 <shachaf> There's also (`M.lookup` m) k
00:37:04 <portnov> hi all
00:37:31 <portnov> Q: how do I terminate on threads in Haskell program?
00:37:44 <portnov> System.Exit.exitWith kills only current thread.
00:37:52 <shachaf> killThread will throw an asynchronous kill exception to the thread.
00:37:57 <shachaf> Oh, from inside the thread?
00:38:08 <portnov> I want terminate all threads
00:38:15 <shachaf> You want to terminate your program?
00:38:19 <portnov> yes.
00:38:22 <shachaf> Well, returning from main should do it.
00:38:36 <shachaf> exitWith *should* exit the entire program, I'm pretty sure...
00:38:44 <portnov> nope.
00:39:23 <portnov> >> Note: in GHC, exitWith should be called from the main program  thread in order to exit the process.  When called from another  thread, exitWith will throw an ExitException as normal, but the  exception will not cause the process itself to exit.
00:39:35 <shachaf> portnov: OK, so call it from the main thread. :-)
00:39:44 <shachaf> Good to know!
00:39:59 <portnov> I need to terminate program from signal handler
00:40:22 <shachaf> OK, so have the signal handler tell the main thread to terminate?
00:40:32 <portnov> yes.
00:40:56 <shachaf> main = do { v <- newEmptyMVar; forkIO (myThread v); takeMVar v >>= exitWith }
00:40:59 <shachaf> Something like that.
00:41:28 <portnov> signal handler is called is separate thread, as far as I see
00:41:33 <portnov> *in
00:41:40 <shachaf> Right.
00:41:51 <shachaf> Hence <shachaf> OK, so have the signal handler tell the main thread to terminate?
00:41:54 <portnov> so, calling exitWith in it simply terminates signal handler
00:42:02 <shachaf> OK, so don't call exitWith in it.
00:42:45 <portnov> hm
00:42:51 <portnov> and what should I call?
00:43:07 <shachaf> 00:40 <shachaf> main = do { v <- newEmptyMVar; forkIO (myThread v); takeMVar v >>= exitWith }
00:43:25 <shachaf> Then when anything wants to exit, it can just putMVar someExitCode v
00:44:31 <portnov> hm. will'not it break with <locked on MVar> ? :/
00:44:50 <shachaf> Why would it?
00:44:57 <shachaf> The whole point of MVars is to block. :-)
00:48:06 <mikeplus64> http://hpaste.org/71451 is there a monad that could be used to clean code like this up? (if so, how)
00:48:51 <shachaf> mikeplus64: Other than a monad, there's just "make a nicer API than that Cish one".
00:48:54 <mikeplus64> i thought maybe the (-> a) monad but i'm not sure
00:48:59 <shachaf> Things like returning Maybe instead of nullptr.
00:49:13 <mikeplus64> that does return a maybe actually :)
00:49:25 <shachaf> renderOneColor does, but not render. :-)
00:49:40 <shachaf> Oh, you mean the foo a $ \x -> bar b $ \y -> ... thing?
00:49:44 <mikeplus64> yeah
00:49:54 <shachaf> Hmm.
00:50:03 <shachaf> Well, ContT will surely do it...
00:52:25 <shachaf> I wonder if there's something less general.
00:52:54 <sp3ctum> do hunit and quickcheck address the same problem space? i'm thinking "which should i use"
00:53:14 <shachaf> sp3ctum: Not really.
00:53:32 <shachaf> HUnit is for unit tests -- "this input should map to this output"
00:53:33 <Axman6> portnov: ICFP contest?
00:53:53 <shachaf> QuickCheck generates random input and checks predicates on it.
00:54:01 <portnov> Axman6: yep :)
00:54:13 <sp3ctum> shachaf, is it common to use both?
00:54:15 <Axman6> portnov: what shachaf suggested is exactly what we're doing
00:54:26 <shachaf> Axman6: I suggested something?
00:54:32 <Axman6> the MVar thing
00:54:36 <shachaf> Oh.
00:54:56 <shachaf> Well, sure. It's the most obvious thing to do given GHC's primitives.
00:55:13 <Axman6> you just need: installHandler sigINT (CatchOnce (putMVar v ()) Nothing
00:55:34 <Axman6> (though, we're being a little bit more sneaky about it in ours)
00:57:12 <shachaf> Maybe Codensity is what you want.
00:57:16 <shachaf> If only edwardk was here.
00:57:40 <copumpkin> Codensity is always what you want
00:58:24 <shachaf> copumpkin: In this case what's wanted is something to make pseudo-CPS code like "withForeignPtr x $ \p -> withBlahBlah $ \q -> ..." nicer.
00:58:40 <copumpkin> why not just use Cont?
00:59:04 <shachaf> Cont was the first thing that came to mind.
00:59:11 <alhazred_> Greetings. Can anyone help me or maybe point me to some place where i can be helped with installing eclipse + the fp extension with haskell-platform on debian? Somehow it work run properly.
00:59:12 <shachaf> I'm actually hoping for something *less* general than Cont. :-)
01:00:33 <Enigmagic> portnov: i think you can use killThread on the main threadId, else use ffi to invoke _exit(int)?
01:00:58 <shachaf> Enigmagic: Both of those arae kind of horrible. :-(
01:01:28 <Enigmagic> shachaf: so you want to tear down the process quickly in a nice way, by having the main thread throw an exception that is uncaught instead of a different thread?
01:01:56 <Enigmagic> if the process is going down, _exit(int) is pretty quick.
01:02:33 <shachaf> I guess it'll work...
01:03:18 <Enigmagic> it's not supposed to be glamorous.
01:03:42 <Enigmagic> all software really should be safe against rude aborts anyways
01:07:01 <alhazred_> I cant install scion-browser and buildwrapper on debian stable with cabal... and in eclipse the fp plugin is not able to open the project wizard. Has either of you experienced a similar problem?
01:07:36 <Enigmagic> i worked on a project once that was long running and used a lot of memory. after being up for a few months, most of the app image and a fair bit of the working set would be swapped out. shutting down the daemon took 10-20 minutes sometimes just to swap around enough pages to close handles and free memory.
01:07:37 <alhazred_> Maybe because debian stable has an old ghc version?
01:07:53 <mroman> Define "can't install"
01:08:02 <Enigmagic> solution? call _exit instead. shutdown time went from 10-20 minutes to about a second.
01:08:47 <alhazred_> mroman: sec
01:08:54 <shachaf> Enigmagic: Or just kill -9 the process.
01:09:07 <Enigmagic> shachaf: same thing.
01:09:14 <shachaf> Yep.
01:09:23 <alhazred_> mroman: http://nopaste.info/704e3d7f2a.html
01:09:28 <shachaf> Except you don't need to implement the ugly _exit call in the program itself. :-)
01:09:42 <Enigmagic> shachaf: yeah, you do it in a script that is shipped with the app :P
01:09:50 <alhazred_> I guess ill have to update my debian to unstable
01:18:11 <donri> filepath provides System.Filepath and system-filepath provides Filepath. \o/
01:18:54 <donri> oh, Filesystem.Path actually
01:35:47 <Williamst> can you learn haskell without any prior knowledge of programming?
01:35:52 <shachaf> Yes.
01:36:07 <Williamst> Ok thanks.
01:36:52 <lambdaphi> harder though
01:36:57 <shachaf> Or easier.
01:37:16 <lambdaphi> [citation needed]
01:40:03 <triyo> I remember reading in one of the books that the type constraint is not a good idea in particular place. Is it at data type definition level?
01:40:12 <Nereid> yes
01:40:29 <shachaf> triyo: It's not "level", it's a particular place.
01:40:36 <triyo> Is this because it makes the data type definition inflexible
01:40:45 <shachaf> data Foo a => Bar a = Baz a | Bam
01:40:53 <shachaf> It's because it gives you nothing.
01:40:58 <mgsloan> and you need to duplicate the constraint on every instance you use
01:41:05 <shachaf> It's deprecated and not in newer versions of Haskell anyway.
01:41:05 <mgsloan> s/use/define/
01:41:20 <Nereid> shachaf: that's good to know.
01:41:27 <triyo> shachaf: understood, bad phrasing on my part
01:42:44 <mgsloan> triyo: you're right too.  Not only does it give you nothing, but it makes your ADT inflexible
01:43:24 <mgsloan> ohh, you meant the "level" phrasing
01:44:00 <triyo> yes, thats what I meant.
01:44:20 <triyo> Referring to my initial phrasing of the question.
01:45:54 <osa1> what was the parameter for enabling warnings for non-exhaustive pattern matchs?
01:46:30 <shachaf> -Wall
01:47:09 <osa1> shachaf: well, it also gives warnings about variable shadowing and some other stuff I don't want to see
01:47:20 <shachaf> osa1: So turn -Wall on and then turn individual ones off.
01:48:14 <fmap> -fwarn-incomplete-patterns
01:50:04 <osa1> thanks
01:50:33 <shachaf> osa1: I recommend that you take my advice and turn warnings *off* instead of on.
01:51:29 <osa1> shachaf: I have some "-fno-warn-"s in my files, but -Wall still overrides them
01:51:46 <shachaf> osa1: Put them after the -Wall
01:55:56 <nand`> does anybody actually code with -Wall (without any warnings disabled), in a style that generates no warnings?
01:56:15 <nand`> eg. I do variable shadowing all the time, is it bad practice?
01:56:28 <shachaf> It's kind of bad.
01:56:39 <shachaf> However, it's better for GHC to have too many warnings than too few.
01:56:53 <shachaf> So I don't see anything wrong with disabling warnings as long as you're sure they're not relevant for you.
01:57:02 <shachaf> But they probably are relevant for you. :-)
01:57:15 <solrize> better to disable warnings at specific sites if there's a way to do that
01:57:47 <solrize>   let n = k*3 {-# PRAGMA no-warn-shadow "n" #-}   or sth like
01:58:02 <nand`> I think that would just get annoying, personally
01:58:11 <nand`> and detract from the simplicity and beauty of code
01:58:13 <solrize> yeah for something like that, perhaps
01:58:47 <nand`> can't it already be done file-wide with some GHC options pragma?
01:58:55 <solrize> for something like overlapping instances, i'd rather write a pragma at the specific instance that overlaps, than turn off the error everywhere
01:58:57 <shachaf> It's funny how there are GHC extensions whose entire purpose is to shadow.
02:00:59 <fmap> nand`: i don't think -Wall is usable without -fno-warn-unused-do-bind
02:01:25 <Ralith> What's the easiest way to identify the location in which a program is looping?
02:01:28 <nand`> what does that one do again (I remember enabling it in projects before), warn if you don't use _ <- ?
02:01:34 <fmap> yeah
02:01:43 <fmap> or `void $'
02:03:38 <Ralith> I basically just want a stack trace when I hit ^C; how can I do that?
02:03:55 <shachaf> Ralith: Stack traces are tricky business.
02:04:04 <shachaf> You might be able to get something if you compile with profiling support.
02:04:17 <Ralith> I'd be happy with anything right now
02:04:32 <nand`> I usually use Debug.Trace
02:04:33 <shachaf> @where rts-xc
02:04:33 <lambdabot> ghc --make -prof -auto-all -rtsopts -osuf .p_o foo.hs && ./foo +RTS -xc
02:04:38 <shachaf> Try that?
02:04:47 <Ralith> kk
02:04:48 <shachaf> nand`: Debug.Trace is nice but has nothing to do with stack traces.
02:05:07 <bitonic> shachaf: is he going to get a stack trace on ^C with that?
02:05:19 <nand`> shachaf: well, his question was about figuring out where his functions were looping
02:05:30 <shachaf> bitonic: No, I don't think so.
02:05:34 <bitonic> yeah
02:05:34 <Ralith> shachaf: uh, I guess I need to manually point ghc at my cabal install?
02:05:42 <shachaf> Ralith: Do you?
02:05:50 <shachaf> You need all your libraries compiled with profiling support.
02:05:53 <Ralith> oh dear.
02:05:58 <bitonic> good luck.
02:06:00 <shachaf> You should have library-profiling: True in your .cabal/config
02:06:14 <shachaf> For future reference. :-)
02:06:27 <bitonic> however there are libraries that are tricky
02:06:43 <bitonic> so you might be unlucky
02:06:45 <shachaf> -xc
02:06:46 <Ralith> blah.
02:06:46 <shachaf> (Only available when the program is compiled for profiling.) When an exception is raised in the program, this option causes a stack trace to be dumped to stderr.
02:07:01 <bitonic> yeah, I don't think it'll help him.
02:08:14 * Ralith will just do this the tedious way
02:08:15 <Ralith> thanks
02:08:53 <bitonic> Ralith: haskell is no erlang/lisp, sadly. you can't jump in and debug
02:09:00 * Ralith nod
02:09:12 <shachaf> Well, GHC isn't.
02:09:21 <bitonic> right.
02:10:22 <bitonic> however static types and lazyness do make that process trickier
02:14:39 <solrize> why would static types make that tricker?  laziness, i can see it.
02:14:49 <solrize> CPS transformations too
02:15:07 <shachaf> A lot less information at runtime.
02:15:35 <solrize> ehh? just keep the info around
02:16:03 <solrize> like debugging stuff for C or Java
02:21:13 <bitonic> solrize: yeah "just keep the info around" would mean that you do that only for debugging
02:21:20 <bitonic> Java keeps info around already
02:21:45 <bitonic> also, with static types doing code changes while the code is running is trickier
02:22:18 <shachaf> bitonic: A lot of C compilers keep *some* "info around".
02:22:32 <shachaf> Anyway, the really tricky thing about stack traces in GHC is that GHC doesn't actually have a stack.
02:22:55 <bitonic> shachaf: you mean putting debug symbols?
02:23:37 <shachaf> Those have no real runtime cost, at least.
02:23:46 <solrize> bitonic, debugging /= changing code while it is running
02:23:58 <solrize> gdb injects code into c programs to evaluate expressions but that's pretty limited
02:24:11 <solrize> i wasn't suggesting erlang-ish hot patching
02:24:17 <bitonic> solrize: changing the code while aids debugging tremendously
02:24:24 <bitonic> *while running
02:24:37 <solrize> hmm i generally haven't felt the need for that
02:24:54 <solrize> being able to evaluate expressions while debugging is very helpful
02:25:33 <solrize> but actually patching the code, hmm, i guess i've used lisps that can do that
02:25:41 <solrize> but haven't used the ability much
02:25:54 <bitonic> solrize: it's great
02:26:00 <bitonic> because you already have the dataset that caused the problems in the first place
02:27:23 <solrize> yeah i guess my test suites are set up so it's enough to be able to breakpoint when a test is going wrong, and poke around inside to see what has happened
02:27:50 <solrize> i'd think static types would be a help for hot patching since it gives the patch better chance of not messing stuff up worse
02:28:14 <solrize> i've never used ocaml or sml but want to try them sometime
02:28:22 <bitonic> solrize: nothing easier than just not having types
02:28:57 <solrize> typeless is certainly simpler
02:29:05 <solrize> more stuff goes wrong though, the programs are too squishy
02:29:05 <Twey> solrize: It's more about *how* Haskell compliers handle types
02:29:06 <bitonic> I mean in haskell you have user defined data types, how would you deal with the fact that you "deleted" some of them?
02:29:23 <bitonic> what do you do with the old ones still in memory?
02:29:26 <Twey> They tend to compile the types out, but they rely on their size & interpretations to compile other parts of the program
02:29:56 <bitonic> I mean Haskell is victim of the fact that GHC is very good at compiling Haskell efficiently here
02:29:58 <Twey> Whereas untyped languages tend to pass everything around as some generic data-structure & decipher them at runtime, which is less efficient but lends itself better to hotplugging
02:30:02 <Twey> Yeah, basically
02:30:23 <bitonic> with Erlang it's just an interpreter, even in production
02:30:29 <bitonic> and you can jump in whenever you want
02:30:49 <solrize> well, c++ debuggers work ok, and that compiles the types out too
02:30:51 <bitonic> well actually you can compile modules, but then you can jump in anyway :P
02:30:57 <solrize> i haven't used erlang but i do a lot of python
02:31:10 <bitonic> solrize: they're not nearly as powerful as Erlang debugging capabilities
02:31:21 <bitonic> like the scope of thing that you can do is different
02:31:30 <solrize> interesting
02:31:44 <bitonic> with erlang if some production thing is eating all the CPU, you jump in, start etop and see what function is eating the CPU
02:32:06 <bitonic> and then you can set up something that tells you what are the arguments of that function each time it is called
02:32:22 <bitonic> or get a stacktrace each time it is called, or whatever
02:32:28 <solrize> yeah i've thought of trying to hack debugging ports (socket listener letting you poke around) into some pytho progs
02:32:43 <solrize> i want to try erlang, it's got a really cool runtime, too bad the language is so ugly
02:32:46 <Twey> solrize: C++ *doesn't* compile the types out when compiled with debugging information turned on
02:32:59 <solrize> well the types are written in those separate .stabs things
02:32:59 <Twey> solrize: Yeah, that's exactly what I think of Erlang too :þ
02:33:20 <solrize> i want to use riak for some stuff.  it's supposed to be better than mongo/cassandra/etc
02:33:23 <bitonic> the syntax is ugly but ok
02:33:32 <bitonic> it's basically prolog
02:33:38 <solrize> i can't believe that node.js is supposed to be the typeless wave of the future :(
02:33:51 <bitonic> the scoping rules are a bit off imho
02:33:55 <solrize> i've heard erlang isn't really suited for functional style
02:34:02 <solrize> e.g. you can't write a local function that recurses
02:34:48 <bitonic> yeah
02:34:59 <bitonic> but it is very functional
02:35:05 <bitonic> in the sense that values don't change
02:35:15 <bitonic> it doesn't even have mutable references, nothing
02:35:20 <bitonic> no arrays
02:35:38 <donri> meh, syntax you get used to
02:35:48 <donri> i used to think haskell syntax was ugly :)
02:36:24 <Twey> It's impure though, and typeless
02:36:28 <donri> yea
02:36:32 <Twey> A string is a list of ints (argh!)
02:36:36 <donri> :)
02:36:50 <solrize> haskell syntax seemed fine to me, it's why i picked haskell over both erlang and ocaml when i got interested in functional programming
02:36:53 <solrize> but i was used to python
02:37:06 <Twey> The runtime does magic to detect whether it's supposed to print [97, 98, 99] or "abc"
02:37:36 <donri> Twey: kind of like haskell stuff do magic to figure out if you want [a] or String? :)
02:37:38 <bitonic> Twey: ?
02:37:41 <bitonic> ah
02:37:45 <bitonic> the strings
02:37:45 <bitonic> yeah.
02:37:52 <Twey> donri: [Char] is *always* a string in Haskell, though.
02:37:58 <Twey> The lack of types is probably the worst thing (well, the impurity is, but that's a symptom)
02:38:03 <donri> yea, but it's still a bit ugly
02:38:11 <shachaf> Lack of types is a symptom of impurity?
02:38:12 <donri> and we have text/bytestring but i think erlang has such things too?
02:38:23 <Twey> shachaf: No, impurity is a symptom of lack of types
02:38:24 <shachaf> I think the two are pretty orthogonal.
02:38:29 <bitonic> Twey: how is impurity a symptom of lacking types?
02:38:37 <shachaf> Twey: You can have purity and a lack of types.
02:38:39 <solrize> i've used a pure lisp
02:38:41 <Twey> bitonic: Because if you have types you can tag pure/impure functions
02:38:45 <solrize> well mostly pure
02:38:49 <shachaf> Twey: Haskell doesn't do that.
02:38:57 <bitonic> Twey: what? if a language is pure, all functions are pure :P
02:38:59 <bitonic> that's the point
02:39:03 <shachaf> Haskell has no impure functions, only pure functions.
02:39:06 <bitonic> yeah
02:39:12 <Twey> shachaf: I didn't say it did :þ
02:39:15 <shachaf> IO is not a "tag", and you could do it just as well in a dynamically-typed language.
02:39:32 <Twey> Instead, what Erlang does is have a set of core ‘built-in functions’ (BIFs) that are known to be pure and assume that everything else is impure
02:39:34 <shachaf> OK, so what's your point?
02:40:08 <Twey> shachaf: That Erlang would greatly benefit from some way of distinguishing pure from impure code, be it a tag, a type, or whatever
02:40:16 <bitonic> Twey: I doubt it.
02:40:18 <Twey> (well, a tag would be a type)
02:40:41 <bitonic> Erlang has grown with the needs of the Erlang community. They'd hate that
02:41:13 <Twey> bitonic: In Erlang, you can't use custom functions in a guard, because they're not known-pure and therefore might be unsafe.
02:41:15 <bitonic> but yeah, not being able to use arbitrary functions in guards is annoying :P
02:41:18 <bitonic> yeah, I know
02:41:22 <Twey> Yeah
02:41:54 <Twey> It introduces an arbitrary closed set that even the most basic of typing would fix
02:42:06 <Twey> In fact the analysis could probably be done entirely statically
02:42:09 <bitonic> I think that the erlang solution to that problem could be to do some really dumb check
02:42:14 <bitonic> on the function
02:42:15 <Twey> Yeah
02:42:19 <Twey> That's all that's needed
02:42:21 <bitonic> more than "tagging" or whatever
02:42:36 <Twey> bitonic: Tagging is the dumb check :þ
02:42:45 <Twey> You have some BIFs that are marked pure, and some that are marked impure
02:42:53 <Twey> If a function uses an impure function then it is impure
02:42:56 <Twey> Otherwise, it is pure
02:43:17 <Twey> There's no user involvement required.
02:43:20 <bitonic> Twey: OK, call it tagging then :P
02:45:34 <bitonic> as long as it's used only for guards, that would be a nice thing
02:48:48 <bitonic> the problem is that to do that, the compiler would have to know something about the function used in the guard
02:48:54 <bitonic> which is not the case with erlang
02:49:13 <bitonic> erlang just blindly compiles to bytecode, and does not care if the function is undefined
02:49:47 <bitonic> so an implementation with nice behaviour would probably necessitate big changes => not going to happen
02:55:29 <solrize> i've never used prolog and never understood it
02:55:55 <solrize> so i wonder if erlang's prolog-ishness is more than just surface syntax
02:57:58 <bitonic> solrize: well unification is there in some sense - you can use existing variables in pattern matches
02:58:18 <bitonic> but no backtracking, so...
02:58:43 <bitonic> I mean Erlang programming has nothing to do with prolog programming.
02:59:52 <solrize> does prolog unification do anything clever in terms of search strategy
02:59:57 <solrize> or is it just exponential backtracking?
03:01:52 <opqdonut> yep
03:10:47 <herpladee> hey what's the best templating library to use with happstack?
03:11:08 <herpladee> hsx/hsp looks pretty good
03:15:32 <bitonic> herpladee: that depends on you really, hsp, heist, blazehtml and the yesod one are all pretty mature
03:25:20 <akamaus> hi
03:25:47 <akamaus> how to terminate a program from a signal handler? Looks like it runs in a separate thread so exitWith doesn't work
03:26:11 <shachaf> akamaus: Hah.
03:26:20 <shachaf> akamaus: We've had at least two other people in here talking about it.
03:26:24 <akamaus> :))
03:26:29 <shachaf> ICFP?
03:26:36 <akamaus> indeed :)
03:26:54 <akamaus> the best days to study haskell )
03:27:12 <shachaf> This is one thing that'll work:
03:27:13 <shachaf> 00:42 <shachaf> 00:40 <shachaf> main = do { v <- newEmptyMVar; forkIO (myThread v); takeMVar v >>= exitWith }
03:27:31 <shachaf> You can also just send the main thread a signal, or just call _exit() directly, which will just end your process.
03:32:12 <akamaus> shachaf, sending a signal with killThread works indeed )
03:32:44 <akamaus> can I somehow return 0 exit code?
03:33:08 <akamaus> now it says 'thread killed' and returns 1
03:37:18 <mikeplus64> other than blocking IO when empty (and IORefs can't be empty), do MVars have advantages over IORefs?
03:47:13 <nand`> > map (sin $ pi * (/2)) [1..4 :: CReal]
03:47:15 <lambdabot>   [1.0,0.0,-1.0,0.0]
03:47:32 * nand` loves Num b => Num (a -> b)
03:50:52 <maybefbi> I import Control.Monad.State but I still don't have State monad. I can only access StateT monad transformer.
03:50:59 <maybefbi> why is this so?
03:55:27 <fmap> maybefbi: State s ≡ StateT s Identity
03:57:03 <fmap> maybefbi: you may want to use `state' function to embed some `s → (a, s)' in State computation
03:58:35 <nand`> thing is, Control.Monad.State should have the ‘State’ alias
03:59:26 <dmwit> maybefbi: What makes you say "I still don't have State monad."? What do you try to do? What do you expect to happen? What happens instead?
04:02:19 <maybefbi> dmwit, I am writing factorial function which returns a State monad. Seems like there is no State monad defined in any namespace. I will have to create the State monad using the StateT and Identity
04:03:02 <nand`> :t return 3 :: State a Int
04:03:03 <lambdabot> forall a. State a Int
04:03:59 <maybefbi> where is that State defined inside the lambdabot?
04:04:17 <nand`> Control.Monad.State from package mtl
04:04:25 <nand`> (I think)
04:05:00 <maybefbi> nand`, if I import  Control.Monad.State from mtl, there is no more State in it. only StateT
04:05:02 <nand`> come to think of it, if State is a type alias, shouldn't the output of :t be “forall a. StateT a Identity Int” ?
04:05:57 <fmap> maybefbi: can you paste the code and the error?
04:05:58 <dmwit> nand`: Can you show some code that doesn't work?
04:06:02 <dmwit> uh
04:06:10 <dmwit> maybefbi: Can you show some code that doesn't work?
04:06:22 <donri> :i State
04:06:25 <nand`> maybefbi: this works for me http://bpaste.net/show/34970/
04:07:38 * hackagebot notcpp 0.2 - Avoiding the C preprocessor via cunning use of Template Haskell (BenMillwood)
04:08:43 <hpaste> maybefbi pasted “No State monad in namespace” at http://hpaste.org/71456
04:08:59 <akamaus> I want to limit a memory usage of my program, I found +RTS -M option. Now the question is can I make some cleanup actions if RTS desides to kill the process?
04:09:19 <nand`> maybefbi: ‘State’ is not a value
04:09:59 <benmachine> I want to talk to haskell-cafe about something, but I can't handle the throughput
04:10:04 <benmachine> I am not very good at skimreading :P
04:10:13 <benmachine> would it be impolite to post to a mailing list that I don't read?
04:10:23 <benmachine> or heck, I could just talk to you guys instead
04:10:38 <benmachine> I'm wondering about the package versioning policy and how it relates to deprecation
04:11:04 <benmachine> currently the haskellwiki page on the PVP states that deprecation should be considered as a removal, because of -Werror
04:11:08 <maybefbi> nand`, but I want to return a function State (s -> (a, s))
04:11:14 <benmachine> but presumably removal of deprecated entities is ALSO a removal
04:11:20 <benmachine> that's kind of... unpleasasnt
04:11:29 <nand`> maybefbi: as fmap said earlier, the function you want is ‘state’
04:11:30 <nand`> :t state
04:11:32 <lambdabot> forall s a. (s -> (a, s)) -> State s a
04:11:58 <nand`> wait no
04:12:01 <nand`> you don't want state either
04:12:06 <nand`> you want ‘get’
04:12:26 <nand`> oh, scratch that
04:12:31 <nand`> I thought your code was in do notation for a second
04:12:33 <nand`> yeah, ‘state’ seems right
04:13:36 <benmachine> you're still going to run into problems with the recursive call to factorial'' though
04:13:45 <nand`> yeah, you'll need to add a runState ... s
04:13:53 <fmap> eh, rwh still has examples with `State $'
04:14:13 <nand`> but at that point the ‘state’ wrapper is just extra overhead
04:14:16 <benmachine> nand`: at that point the fact that you're using State at all is kind of redundant :P
04:14:19 <nand`> exactly
04:14:20 <benmachine> yeah
04:14:32 <nand`> they way one usually uses State is with get / return
04:14:35 <nand`> or put
04:14:42 <benmachine> get/put/modify
04:15:24 <phao> Hi, a curiosity... is there a word that can be used in the place of \
04:15:29 <phao> maybe fn, fun, lambda, ...
04:15:30 <phao> ?
04:15:50 <mcstar> 955?
04:16:16 <benmachine> phao: why would you want one?
04:16:29 <phao> benmachine, I find sort of annoying typing this \ character
04:17:25 <fmap> i wish one cound use λ in place of \ :(
04:18:01 <mcstar> afaik you can
04:18:02 <benmachine> phao: I don't think you can avoid it from within Haskell, you might be able to configure your editor though
04:18:06 <amatsu> Unicode syntax?
04:18:17 <benmachine> mcstar: I think that's a emacs thing that just writes \ to the file
04:18:18 <phao> ok
04:19:05 <mcstar> http://www.haskell.org/haskellwiki/Unicode-symbols
04:19:41 <hpaste> nand` annotated “No State monad in namespace” with “No State monad in namespace (annotation)” at http://hpaste.org/71456#a71457
04:20:02 <nand`> this is how I would implement factorial “Statefully”
04:20:41 <mcstar> anyway, \ is the best lambda
04:20:58 <mcstar> fun/function/lambda all suck compared to \
04:22:26 <hpaste> maybefbi annotated “No State monad in namespace” with “No State monad in namespace (annotation) (maybefbi's annotation)” at http://hpaste.org/71456#a71458
04:22:31 <mcstar> there can possibly be another lambda, in which you dont have to name the parameters explicitely
04:22:37 <mcstar> like in mathematica
04:22:51 <mcstar> ## all arguments, #1 1st argument, ...
04:23:01 <mcstar> i did a macro in CL to mimic that
04:23:03 <maybefbi> nand`, that is how i implemented it. fmap, nand`, benmachine, why is it that when I use do notation I don't need the state function?
04:23:36 <benmachine> maybefbi: things like 'return' and 'put' and 'get' produce State things for you
04:24:04 <benmachine> maybefbi: essentially, they all call 'state' for you when necessary
04:24:14 <maybefbi> benmachine, i see
04:24:51 <benmachine> mcstar: "all arguments" probably doesn't type very well
04:25:12 <mcstar> benmachine: in mathematica there are no types
04:25:31 <mcstar> like in haskell, or strictly typed  languaegs
04:25:48 <maybefbi> benmachine, why cant i use State $ ... instead of state function in my implementation?
04:26:16 <hpaste> nand` annotated “No State monad in namespace” with “No State monad in namespace (annotation) (maybefbi's annotation) (annotation)” at http://hpaste.org/71456#a71459
04:26:17 <benmachine> maybefbi: State doesn't exist anymore
04:26:22 <nand`> maybefbi: this is what it would look like using do notation
04:26:23 <mcstar> benmachine: it could be a tuple though, not that i would find it useful
04:26:46 <mcstar> benmachine: in the CL macro, i didnt bother with it, though it would have been a simple list
04:26:49 <benmachine> maybefbi: uh, that is, the State type is just a type alias for a certain sort of transformer
04:27:05 <benmachine> mcstar: yeah, it could be a tuple, but that wouldn't be so useful
04:27:54 <maybefbi> you know I am going to get rid of these advances in mtl libraries one of these days, and come up with my own simpler mtl for newbies
04:28:17 <maybefbi> if they keep making things more abstract how will newbies learn anything
04:28:44 <fmap> i thought mtl is transformers for newbies
04:28:45 <nand`> mtl is a pretty specific library: for monad transformers
04:28:47 <mcstar> lets abstract newbies away into a monad
04:29:00 <nand`> you want to remove monad transformers from the monad transformers library?
04:29:11 <maybefbi> yes
04:29:13 <maybefbi> for newbies
04:29:39 <maybefbi> there is no State constructor in mtl
04:29:44 <maybefbi> why the hell
04:29:52 <nand`> because ‘state’ does the same thing
04:29:57 <nand`> it's one letter you have to change
04:30:04 <maybefbi> yeah
04:30:18 <mroman> state can be accomplished by explicitly passing it through functions.
04:30:33 <mcstar> there is no IO constructor
04:30:42 <mcstar> and people dont argue about that
04:30:55 <maybefbi> mcstar, yeah true
04:30:56 <nand`> besides, I don't think ‘state’ is all that useful. I barely never use it, only when wrapping some other function that just so happens to have the right type
04:31:28 <mcstar> 'barely ever', innit?
04:31:37 <nand`> when constructing your own stateful computations, the whole point about the state monad is that, well, it's a monad - you can use monad functions (>>=, return) and their abstractions (do notation)
04:31:43 <nand`> mcstar: yes
04:32:31 <nand`> if you're using the state monad by wrapping your own functions with State and runState, you don't need the State in the first place
04:32:34 <maybefbi> nand`, but before using bind, get, put, return, i need to see the basic way of doing things
04:32:37 <nand`> since you can just define your functions that way directly
04:32:47 <maybefbi> nand`, yes
04:33:01 <nand`> well, the ‘basic way of doing things’ would be without the state monad
04:33:26 <maybefbi> nand`, I am gradually moving to the world with State monad
04:33:26 <nand`> then you begin defining your own helpers to make sequencing ‘stateful’ functions easier
04:33:56 <nand`> and rewrite your functions in terms of those helpers; only to realize that they're just return, >>=, get, put etc.
04:34:16 <nand`> (of course this is just the academic idealist way of ‘learning State’)
04:34:50 <nand`> but my point is that even when teaching, I don't think much emphasis should be placed on ‘state’, especially since it can be implemented in terms of the other primitives
04:35:18 <watermind> one 'problem' with defining local values/functions (in a where or let clause) is that you can't test them, so sometimes I'd just end up pulling them outside using implicit values... Couldn't the compiler do this for us? Or are there instances where this wouldn't work?
04:35:21 <nand`> maybefbi: also when learning about these things don't you usually define the monad yourself either way?
04:36:07 <nand`> watermind: I run into a similar problem constantly: I want to use :t on local values when debugging
04:36:12 <nand`> it would be great to have a way to do that easily
04:36:26 <maybefbi> nand`, yeah i should
04:36:57 <watermind> seems like it should be possible to simply have the compiler/interpreter creating  the equivalent function/value with implicit values
04:37:50 <nand`> watermind: that sounds plausible
04:37:54 <watermind> and of course I mean implicit parameters
04:38:34 <nand`> hmm, I don't think that works if said implicit parameters are polymorphic, would it?
04:38:39 <dmwit> Don't really seem like the compiler's job. Though perhaps an IDE could do it using the compiler API.
04:38:49 <nand`> what dmwit said
04:38:55 <nand`> this should be an IDE job
04:39:42 <amatsu> Are there actually any IDEs for Haskell? I know of Yi..
04:40:00 <watermind> I honestly don't know about polymorphic implicit values... I might have never used them, I'm not completely certain about the semantics
04:40:10 <nand`> yeah, implicit parameter types can't be inferred for polymorphic parameters, since it would be akin to inferring rank ≥2 types
04:40:30 <nand`> :t (?f 3, ?f 4)
04:40:32 <lambdabot> forall t t1. (Num t1, ?f::t1 -> t) => (t, t)
04:40:39 <nand`> uh
04:40:40 <nand`> :t (?f 3, ?f 'a')
04:40:42 <lambdabot>     No instance for (Num Char)
04:40:42 <lambdabot>       arising from the literal `3' at <interactive>:1:4
04:40:42 <lambdabot>     Possible fix: add an instance declaration for (Num Char)
04:40:47 <nand`> suppose f = id in this context
04:43:18 <qnikst> hello; is it possible to check if DList is empty in O(1) time?
04:43:22 <watermind> and isn't there the same problem when you do that in a local declaration?
04:43:30 <qnikst> I mean Data.DList
04:44:11 <nand`> > let f = id; g = (f 3, f 'a') in ()
04:44:13 <lambdabot>   ()
04:44:40 <nand`> but if you try to determine the type of ‘g’ by replacing free variables by implicit params it fails with the error above
04:46:43 <watermind> well I see... as it stands now we do get an error because in general you can not inferr rank >=2 types I get it
04:47:07 <watermind> in a local declaration you know the type of that f already
04:47:16 <watermind> so you're not really inferring it
04:48:16 <watermind> so in theory there wouldn't be a problem creating those terms with implicit parameters either, since you could infer their type from the local declaration their being constructed from
04:48:31 <nand`> yeah, it could probably work if the compiler uses some deeper knowledge to predetermine the type of ‘f’, which could possibly work for the case of the outer function being rank ≥2 (and that polymorphic parameter being referenced) too; but I can't help but feel there will be some problem related to type contexts
04:48:38 <Nereid> qnikst: of course
04:48:52 <osa1> I'm getting stack overflow when I use haskell derived eq typeclass's (==) function, any ideas why?
04:48:58 <watermind> possibly there will :P
04:49:10 <Nereid> osa1: code please
04:49:17 <watermind> that doesn't seem like it should be one though, I think
04:49:17 <osa1> ok
04:49:22 <qnikst> Nereid: toList and pattern match it?
04:49:22 <nand`> well, doesn't the type checker check the type of ‘g’ in the first place? It would probably be simple to just spit out that inferred type
04:49:35 <Nereid> qnikst: why don't you give it a try
04:49:36 <Nereid> :)
04:50:12 * qnikst doesn't know how to verify that it will be evaluated lazily =)
04:50:28 <Nereid> everything is evaluated lazily
04:50:39 <osa1> Nereid: full code is a bit long but if you want to see here are types: https://github.com/osa1/toylisp/blob/gadts/Types.hs and this is eq instance https://github.com/osa1/toylisp/blob/gadts/Eq.hs . I'm trying to run == on TVal type (I didn't try other types yet)
04:50:39 <Nereid> also you can look at the definition of DList
04:51:03 <watermind> as for it being
04:51:05 <watermind> opss
04:51:11 <watermind> got to go
04:51:21 <nand`> watermind: the only problem I'm seeing is that if the outer context is polymorphic, types within the local definition could refer to that outer, polymorphic type too. It would probably be a notational issue, since you'd have to distinguish between types that are “variable, but from the outer context” and types that are “locally polymorphic”
04:51:24 <nand`> blah
04:52:05 <Saizan> osa1: instance Eq TVal doesn't create a derived instance, it just uses the default method definitions, which have (==) and (/=) circularly defined
04:52:06 <qnikst> Nereid: it can't agree
04:52:20 <osa1> oh
04:52:32 <osa1> Saizan: then how can I derive it?
04:52:44 <Saizan> osa1: put "    deriving (Eq)" at the end of the definition of TVal
04:52:55 <osa1> right. let me try
05:02:25 * mcstar wonders if its possible to write into the opengl framebuffer directly
05:09:26 <Peaker> Saizan, I saw that bite newbies already..
05:09:34 <Peaker> Saizan, (empty Eq instance)
05:10:17 <Peaker> or at least there should be a way to verify an instance declaration is complete
05:11:25 <mcstar> Peaker: hey, just the man i need
05:11:43 <Peaker> mcstar, hey
05:12:14 <mcstar> Peaker: if i have direct redering with X, is it true, that all opengl operations will use dri?
05:12:31 <Peaker> mcstar, I tried installing panopti, missing gtk-toy-diagrams
05:12:38 <benmachine> Peaker: I sometimes think we should remove default definitions altogether
05:12:56 <Peaker> benmachine, yeah, Ord could have just (<) but then compare might be a little inefficient
05:12:57 <benmachine> Peaker: and just supply them as ordinary functions in a library so that people just go (/=) = defaultNE
05:13:19 <Peaker> benmachine, might as well only have (==) and (<) in Eq and Ord probably
05:13:31 * benmachine shrug
05:13:38 <benmachine> I'd put compare in Ord, I think
05:14:01 <Peaker> benmachine, yeah, I guess it's more canonical, and you could always do: compareFromLT $ \x y -> ...
05:14:10 <benmachine> yes
05:14:15 <Peaker> mcstar, I don't know the low-level details of OpenGL, sorry
05:14:30 <mcstar> :( ok
05:14:32 <benmachine> also I want to upset whoever has to write instance Ord Float :P
05:14:42 <Peaker> benmachine, hehe
05:14:49 <Peaker> benmachine, the Eq should always upset them?
05:14:53 <DrSyzygy> Ord has to be a total order?
05:14:56 <benmachine> :)
05:15:29 <benmachine> DrSyzygy: there are no formal rules for the Ord class
05:15:40 <benmachine> (as in, the doc specifies none)
05:15:55 <benmachine> well
05:16:00 <benmachine> it says "The Ord class is used for totally ordered datatypes."
05:16:07 <DrSyzygy> there's a rule. :-)
05:16:19 <DrSyzygy> So, yeah, Float is difficult for Ord.
05:16:35 <benmachine> to me, "is used" is different from "must only be used"
05:16:37 <benmachine> but yeah sure
05:16:48 <benmachine> my personal opinion is that we should define a non-IEEE total ordering on Float
05:17:02 <DrSyzygy> benmachine: It _does_ howveer mean that anyone else who sees an Ord Float instance will expect it to be a total ordering.
05:17:05 <benmachine> that agrees with the IEEE ordering on all finite numbers
05:17:10 <benmachine> DrSyzygy: that's true
05:17:35 <benmachine> and then for people who *really* want IEEE we make that available via a module or whatever
05:17:58 <DrSyzygy> Because that would NEVAH lead to conflicts or weird compilation hacks?
05:18:25 <benmachine> what sort of conflicts?
05:18:41 <DrSyzygy> If you provide ANY default Ord Float, you'll have to explicitly hide it to change it.
05:19:05 <DrSyzygy> The problem with multiple type class implementations is exactly why we have all these wrapper Monoid types.
05:19:05 <benmachine> oh
05:19:06 <benmachine> well
05:19:23 <benmachine> *shrug*
05:19:28 <benmachine> no I mean
05:19:35 <benmachine> the module wouldn't contain an alternative Ord instance
05:19:38 <DrSyzygy> Ok. Airport time.
05:19:40 <benmachine> it would contain other functions
05:19:53 <benmachine> that would do the job of the Ord functions, only without guaranteeing totality
05:20:09 <benmachine> (or reflexivity, etc.)
05:46:01 <mcstar> cat /dev/urandom > /dev/fb0
05:46:04 <Peaker> hmm.. could be nice if FFI bindings could specify in their .cabal file:  "Ubuntu 12.4: <package names>" and such fields for various distros, and then "cabal install" could do a "sudo apt-get" on them
05:46:43 <hpc> you don't want to be mixing cabal and apt
05:47:48 <Peaker> hpc, why not?
05:48:07 <Peaker> hpc, cabal could call   apt-get install   for the C libraries and their "-dev" packages, not Haskell ones
05:48:08 <hpc> it breaks things in ways i really don't know enough to explain
05:48:21 <Peaker> hpc, only if you use apt-get to install haskell packages
05:48:41 <Peaker> cabal can't install the c libs anyway, so you always end up using apt-get for those anyway
05:48:44 <hpc> oh
05:48:45 <benmachine> Peaker: ahh, you're talking about non-haskell dependencies
05:48:49 <Peaker> benmachine, yeah
05:48:52 <hpc> yeah, that would be nice
05:48:53 <benmachine> that wasn't clear at all from your initial comment :P
05:49:05 <Peaker> Ah, ok :)
05:49:13 <benmachine> the major drawback I see is that there are about twenty billion package systems
05:49:18 <Peaker> then the .cabal file could have rules for OS X, Debian, Ubuntu, Redhat, Arch, etc.
05:49:32 <benmachine> OS X has at least two package managers :P
05:49:41 <benmachine> and neither of them are commonly available
05:50:05 <Peaker> benmachine, well, lack of rules for a system would regress to what we have now
05:50:34 <benmachine> Peaker: sure, but once you have the rules you have pressure on package maintainers to include them
05:51:05 <Peaker> benmachine, I guess just like version deps, it would be much nicer if the rules are specified after-the-fact
05:51:17 <Peaker> benmachine, by anyone, adding to some web-accessible database
05:51:28 <Peaker> (sort of a wiki?)
05:51:40 <benmachine> mm
05:52:42 <hpc> perhaps have cabal search for debian/whatever-specific files
05:52:57 <hpc> that apt/yum add on their own as part of database whatevers
05:53:10 <hpc> or as a "cabal-depends" package
05:54:22 <hpc> this is getting overly complicated :P
05:55:02 <Peaker> cabal update could just download dep specs that are not in the .cabal file
05:55:09 <Peaker> dep specs should not be in the .cabal file anyway
06:00:01 <Peaker> @ask mgsloan gtk-toy-diagrams tries to import Graphics.UI.Toy.Gtk whereas gtk-toy has always exported Graphics.UI.Gtk.Toy, how come?
06:00:02 <lambdabot> Consider it noted.
06:01:23 <dmwit> really pretty
06:02:07 <dmwit> 1-element: mean 567.0911ns; 1000-element: mean 537.5890us; 1000000-element: mean 535.9572ms
06:02:18 <dmwit> Dunno what I was expecting other than that, I guess. =P
06:04:29 <mgsloan> Peaker: Is your copy of gtk-toy up to date?
06:04:30 <lambdabot> mgsloan: You have 2 new messages. '/msg lambdabot @messages' to read them.
06:05:04 <Peaker> mgsloan, I have the one from hackage
06:05:31 <Peaker> mgsloan, git clone'ing now
06:06:08 <mgsloan> ahh, yeah, I unified them under one namespace.  Sorry, that's probably my fault for not versioning the repository one properly.
06:06:42 <mgsloan> (unified under Graphics.UI.Toy in anticipation of one day supporting multiple interactive backends)
06:07:33 <mgsloan> you taking a look at it? Cool! :D
06:07:45 <Peaker> mgsloan, Module `Diagrams.Prelude' does not export `trace' ?
06:08:26 <Peaker> mgsloan, do you have a fork of the diagrams-lib too?
06:08:28 <mgsloan> that's due to it re-exporting diagrams
06:08:30 <mgsloan> augh I hate that
06:08:43 <mgsloan> hiding declarations should _not_ break imports
06:09:11 <mgsloan> that's just the head versions of diagrams
06:09:39 <Peaker> I just qualified-import
06:09:47 <Peaker> or close the list of unqualified imports
06:10:02 <mgsloan> there're instructions here https://github.com/mgsloan/gtk-toy-diagrams/blob/master/INSTALL.md
06:10:09 <mgsloan> yeah, I should do that
06:10:35 <Peaker> src/Graphics/UI/Toy/Text.hs:161:22: Couldn't match expected type `a -> a' with actual type `Style R2' In the return type of a call of `drawStateStyle'
06:10:58 <Peaker> wow, lots of deps :)
06:11:30 <Peaker> mgsloan, while bottle is in development, we put all the stuff in one big package
06:11:36 <Peaker> mgsloan, so it's easier to try it out
06:11:54 <Peaker> mgsloan, I originally split it into ~4 packages, but then unified it for ease until it becomes realistically useful
06:11:57 <Peaker> then it may be split again
06:12:05 <saml> how can  I  import Maybe?
06:12:21 <saml>    Could not find module `Maybe'     It is a member of the hidden package `haskell98-2.0.0.1'.
06:12:29 <Peaker> saml, use "Data.Maybe"
06:12:37 <saml> thanks Peaker
06:12:39 <Peaker> saml, Haskell98 did not have hierarchial module names
06:12:42 <mgsloan> woops, looks like I didn't update those directions to mention toy-interface
06:13:05 <Peaker> saml, so it was called "Maybe".   for backwards compatibility, you can install the "haskell98" package which re-exports stuff at their old h98 names
06:13:13 <Peaker> saml, but it is better to avoid the h98 package
06:13:21 <mgsloan> It is a shame how much user overhead a single package causes
06:13:48 <saml> ugh this also does import List
06:13:49 <mgsloan> Maybe the way to go is to stick multiple packages in a single repository, and have a build script?
06:13:55 <saml> is raincat updated?
06:14:22 <mgsloan> Peaker: do you have the most recent diagrams versions?
06:16:21 <mgsloan> Peaker: you can comment text out, it's not really very important
06:16:49 <mgsloan> or very correct, for that matter.
06:17:38 <saml> what did import IO become?
06:17:41 <mgsloan> (was trying to solve a lot more problems than just text - marking with styling, using these marks for cursors, having high level operations in terms of an algebra on marks for performing edits etc etc)
06:18:32 <saml> import GHC.IO
06:18:37 <Peaker> mgsloan, that's one possibility, there was also the yackage thing or such from snoyman?
06:18:50 <Peaker> saml, Don't import GHC.* modules directly if you can
06:18:56 <Peaker> saml, System.IO probably?
06:19:47 <saml> thanks
06:19:50 <saml> now Random
06:20:05 <saml> can't find  .Random  here http://www.haskell.org/ghc/docs/latest/html/libraries/
06:20:08 <mgsloan> Peaker: interesting!  It'd be cool if hackage could support trunk builds
06:20:44 <mgsloan> cabal already has repository urls afterall
06:21:30 <saml> actually, found a better source here. it's cabalized. might compile: https://github.com/styx/Raincat
06:21:31 <Peaker> mgsloan, btw, Diagrams isn't supposed to be real-time, is it?
06:21:42 <Peaker> saml, System.Random
06:21:52 <mgsloan> there is no fundamental reason why it can't be
06:22:20 <Peaker> saml, it doesn't index all the basic packages there, apparently
06:22:25 <mgsloan> and the monoidal caches actually could provide some good realtime speedups if the effort was put into using them that way
06:22:26 <Peaker> mgsloan, well, it seems it's not a package goal
06:22:53 <mgsloan> no, but plenty of realtime things use something akin to a cairo canvas and recalculate every frame
06:23:11 <mgsloan> byorgey's got some animation stuff too
06:23:28 <saml> oh i have to `cabal install random`
06:23:32 <mgsloan> I think the principle is that prioritizing realtime is premature optimization - better to get the API right 'n such
06:23:48 <mgsloan> of course, API choices can drastically effect realtime-ization
06:24:14 <Peaker> mgsloan, I wonder what the deep differences between diagrams and graphics-drawingcombinators are
06:24:18 <Peaker> They seem to have similar goals
06:24:25 <Peaker> (except drawing combinators wants to be real-time)
06:24:34 <mgsloan> Yeah, they are very similar
06:25:24 <Peaker> both even have the same bug regarding color tinting and opacity
06:25:25 <mgsloan> diagrams is much bigger, but drawing combinators has gl
06:25:39 <Peaker> a pretty hard to solve one
06:26:16 <mgsloan> Peaker: have you looked into different gl blend modes?
06:26:39 <Peaker> mgsloan, a bit
06:27:01 <mgsloan> cairo also has different modes: http://cairographics.org/operators/
06:27:12 <Peaker> mgsloan, OpenGL is so unreliably supported across modern machines.. I run it on friends' PC's and it is sometimes very slow (Can't rely on hw accel at all apparently)
06:27:43 <mietek> How do I exit my program from an interrupt handler?
06:27:54 <mgsloan> yeah, particularly under linux unfortunately...
06:28:03 <benmachine> saml: random package, System.Random
06:28:04 <mietek> I tried using System.Exit exitSuccess
06:28:07 <benmachine> ah
06:28:14 <mgsloan> it is probably possible for them to have acceleration, but they might have to muck around a while to get it
06:28:15 <benmachine> saml: ignore me, I was scrolled down
06:28:17 <mietek> But I only get a message printed to the shell, "foo: ExitSuccess"
06:28:18 <benmachine> or up
06:28:19 <benmachine> or whatever
06:28:33 <Peaker> mietek, what do you mean by "interrupt handler"?
06:28:49 <mietek> Peaker: System.Posix.Signals installHandler for sigINT
06:29:12 <Peaker> mietek, the default sigint handler exits.. you want to do more stuff and then exit?
06:29:16 <mietek> Yes
06:29:22 <benmachine> mietek: it sounds like you're running the handler in a thread
06:29:38 <benmachine> so exitSuccess is failing to work because it just throws an exception, which just kills that thread
06:29:39 <mietek> http://pastie.textmate.org/private/zkjpfzgzokmdtenawtn5mq
06:29:46 <benmachine> that's probably at least a doc bug
06:29:46 <mietek> I'm not using threads explicitly
06:29:57 <mietek> So is there a better way to exit?
06:30:06 <Peaker> mgsloan, cabal: can't find source for ActiveHs/Simple in src, dist/build/autogen
06:30:12 <Peaker> mgsloan, did you forget to add some files?
06:30:27 <benmachine> mietek: well, you could at least test my hypothesis by using the Control.Concurrent functions myThreadId and killThread
06:30:30 <benmachine> to kill the main thread
06:31:01 <mgsloan> Peaker: is that for diagrams-ghci?
06:32:17 <Peaker> mgsloan, for panopti
06:32:40 <Peaker> mgsloan, the Other-Modules section in the .cabal mentions it
06:32:43 <mietek> benmachine: this works, thanks.
06:32:57 <Peaker> mgsloan, but there's nothing there
06:33:09 <benmachine> mietek: interesting
06:33:20 <Peaker> mgsloan, Annotations doesn't exist either
06:33:28 <mietek> http://pastie.textmate.org/private/damzvrgam6edtcutkwqpwa
06:33:36 <mgsloan> Peaker: yeah, panopti's awfully broken :/
06:33:44 <Peaker> mgsloan, you seem to have pushed a tiny subset of the files?
06:34:02 <mgsloan> especially now that you have newer versions of gtk-toy-diagrams
06:34:08 <Peaker> mgsloan, btw, I think it'd be better to use LANGUAGE pragmas on a per-file basis than enable the extensions globally in .cabal
06:34:35 <Peaker> mgsloan, so can't run panopti?
06:34:55 <benmachine> mietek: the docs for unix do actually mention that the handler is invoked in a new thread
06:34:59 <benmachine> kinda weird, though
06:34:59 <mgsloan> Peaker: unfortunately not.  Once I've wrapped up instance templates I'll get back to type diagrams
06:35:23 <Peaker> instance templates?
06:35:54 <mgsloan> https://github.com/mgsloan/instance-templates
06:36:25 <mgsloan> my proposed solution to the brittleness of typeclasses, and proliferation of boilerplate instances
06:36:47 <mgsloan> this code works: https://github.com/mgsloan/instance-templates/blob/master/tests/monads/Test.hs
06:37:12 <mgsloan> (ignore the first half with Applicative - that's kinda boring)
06:38:24 <mgsloan> actually, refresh that file
06:38:33 <mgsloan> now it's the top half that's interesting
06:38:58 <Peaker> mgsloan, why define the redundant methods (>>) and (<*) and friends?
06:39:13 <mgsloan> because I haven't implemented default methods yet
06:39:40 <mgsloan> it shouldn't be too bad, but I've got more pressing (and cooler!) features to add, like type families and such
06:39:50 <Peaker> so you write a funky-syntax instance of Monad and get Applicative/Functor for free?
06:39:57 <mgsloan> bingo
06:40:09 <mgsloan> ideally it'd be a normal instance declaration
06:40:21 <mgsloan> but this is still TH, and not an actual extension (like I'm hoping it will be)
06:40:27 <Peaker> does it weaken the constraints correctly?
06:40:49 <Peaker> if you have an instance Monad for a transformer, for example, you might have a Monad constraint on the inner monad
06:41:00 <Peaker> but for an Applicative instance, you only need an Applicative constraint
06:41:36 <Peaker> if it doesn't, then could simply have something that pastes this template:  instance Applicative <typename> where pure = return ; (<*>) = ap   ?
06:42:57 <mgsloan> If you want constraint weakening, then it's clearly not deriving the implementations of Functor / Applicative from the monad operations
06:43:05 <Peaker> mgsloan, I see
06:43:16 <Peaker> mgsloan, but then, why not just paste the Applicative/Functor boilerplate instances?
06:43:21 <Peaker> mgsloan, I mean, via a macro or such?
06:43:37 <Peaker> pure=return; (<*>) = ap; fmap = liftM
06:43:38 <mgsloan> because noone does that, because it's very hacky
06:44:03 <mgsloan> well, they'll write them, but they won't use CPP for it orso
06:44:15 <Peaker> yeah, it's not worth a one-off macro
06:44:29 <mgsloan> but yes, effectively it's template substitution with some semantics for overlap and generation of a constraint synonym
06:44:30 <Peaker> but if there was a standard macro like: ApplicativeFromMonad ''MyType
06:44:54 <mgsloan> right.  That's exactly the sort of code this generates.
06:45:02 <mgsloan> https://github.com/mgsloan/instance-templates/blob/master/tests/monads/Templates.hs
06:45:31 <mgsloan> These instantiations pretty much create that
06:45:38 <Peaker> "(>>=) = (>>=)" must have some funky scoping rules :)
06:45:55 <Peaker> mgsloan, why do you implement <*> directly instead of using "ap"?
06:46:35 <mgsloan> Peaker: because I defined a new set of classes, and didn't copy in ap
06:46:41 <mgsloan> https://github.com/mgsloan/instance-templates/blob/master/tests/monads/Classes.hs
06:46:43 <Peaker> ah
06:46:59 <Peaker> in bottle we have an ugly:  class Applicative m => MonadF m where {}
06:47:37 <mgsloan> You should take a look at the readme file / other *.md files in that repo
06:48:35 <mgsloan> more of the effort has gone into thinking about / writing about it than the TH implementation (though that's been more the focus lately)
06:49:41 <mgsloan> these are pretty much module functors (from ML), but applied to typeclasses.  They bring the referentially transparent power of functions to the realm of instance declarations
07:02:48 * hackagebot unfoldable 0.6.1 - Class of data structures that can be unfolded. (SjoerdVisscher)
07:03:04 <mroman> Is there an array package that let's me treat data like real arrays?
07:03:22 <mroman> Don't care if mutable or immutable.
07:03:38 <eikke> mroman: explain 'treat data like real arrays'?
07:03:47 <mroman> Well
07:04:01 <mroman> There is a package that wraps stuff in a tuple as index
07:04:12 <mroman> like ((1,2),data)
07:04:55 <mauke> where?
07:05:00 <gspr> With Network.FastCGI, how can I run my program as a standalone one, communicating with the web server via a socket?
07:05:17 <gspr> It seems the default is to have the web server spawn the program.
07:05:30 <eikke> mroman: checked 'vector' already?
07:05:32 <mroman> or at least that's what I remember.
07:05:39 <mroman> Ix is not really what I'm looking for.
07:05:41 <mauke> mroman: I've never seen anything like that
07:06:40 <Axman6> mroman: Data.Array is a real array
07:07:25 <Axman6> it may _display_ as ((x,y),data) when you print it, but that is not how it's represented. that said, look at Vector
07:07:49 * hackagebot egison 2.2.0 - An Interpreter for the Programming Language Egison (SatoshiEgi)
07:09:54 <mroman> Is there a specialisation for 2D Arrays?
07:10:26 <mroman> > snoc (empty) 5
07:10:28 <lambdabot>   Not in scope: `snoc'Ambiguous occurrence `empty'
07:10:28 <lambdabot>  It could refer to either ...
07:11:07 <nand`> Has anybody tried overloading list-y things the way number-y and string-y things are? eg. sticking “fromList” into some typeclass “Listy a b where fromList :: [a] -> b”
07:11:34 <nand`> instance Listy (k, v) (Map k v) ...
07:12:19 <nand`> (and typing [a,b,c] would automatically desugar into fromList [a,b,c])
07:12:56 <nand`> but I suppose this wouldn't really be worth it
07:13:08 <nand`> since using Set.fromList or Map.fromList isn't that much overhead for the few times you tend to use it
07:13:13 <nand`> it might be neat for Sets though
07:13:22 <nand`> especially in combination with overloaded comprehensions
07:13:30 <mroman> I need to slice rows and columns out of a 2D Array
07:13:57 <mroman> I could do that with lists, but there are no guarantees
07:14:06 <mroman> that the list has the right dimension (at the type level)
07:14:20 <mroman> like
07:14:39 <mroman> [[1,2],[1,2,3]] is valid, but it's not a valid array.
07:15:44 <dmwit> Listy a where type Source a; fromList :: [Source a] -> a
07:16:00 <dmwit> instance Listy (Map k v) where type Source (Map k v) = (k,v)
07:17:25 <dmwit> mroman: The plain old array interface is perfectly capable of that.
07:17:44 <dmwit> http://hackage.haskell.org/packages/archive/array/latest/doc/html/Data-Array-IArray.html#v:ixmap
07:18:18 <dmwit> I'm sure Vector has something analogous, if they're your bent.
07:21:49 <dmwit> e.g. \arr y -> let ((xlo, ylo), (xhi, yhi)) = bounds arr in ixmap (xlo, xhi) (\x -> (x,y)) arr will slice out row y; slicing columns is similar
07:21:58 <mroman> @hoogle for
07:21:58 <lambdabot> Data.Traversable for :: (Traversable t, Applicative f) => t a -> (a -> f b) -> f (t b)
07:21:59 <lambdabot> Data.Foldable for_ :: (Foldable t, Applicative f) => t a -> (a -> f b) -> f ()
07:21:59 <lambdabot> Foreign module Foreign
07:29:18 <mroman> in what package was delimBy again?
07:29:22 <mroman> or was it splitBy?
07:29:38 <obiwahn> how do i triggerlamdabot or get a list of commands?
07:29:54 <obiwahn> i have a copy but forgot how to use it...
07:32:58 <mroman> ah
07:33:01 <mroman> Data.List.Split
07:38:52 <hape01> anybody here who can give me a hint why in EclipseFP the windows Functions, Cross References, Types, Modules - all are empty and there is no life in them at all? (editor, outline, hoogle window work perfectly), i have all helpers installed and referenced. (buildwrapper,scion-browser,hoogle,hlint)
07:43:51 <zachk> hape01: maybe try something other EFP? :0
07:44:25 <hape01> I tried Emacs, leksah already :)
07:44:38 <hape01> zachk: what is your editor of choice?
07:45:10 <bitonic> hape01: you haven't tried emacs hard enough
07:45:53 <hape01> next time i try emacs i search for an virtual image which i can run in a player, with preconfigured toolset........... :)
07:45:59 <mcstar> emacs <3
07:46:04 <zachk> I use vim, sometimes leksah (it is hard to get working on install) I wouldn't mind learning emacs
07:46:17 <zachk> vim ++ ghci ++ hoogle with .ghci integration and a web browser
07:46:31 <zachk> and use :browse and :t in ghci
07:50:58 <raichoo> vim + neocomplcache + ghc-mod + lushtags = <3
07:53:16 <sunfun> notepad <3
07:53:24 <herpladee> hey what's the := operator do?
07:53:26 <sunfun> joke
07:54:19 <hape01> herpladee: it which context did you see  :=
07:54:38 <eviltwin_b> herpladee: there is no standard operator by tht name.  I think wxhaskell uses it for setting attributes; other packages might define one as werll
07:55:20 <herpladee> uh it's in the happstack crash course, looks like they're using it to set attributes as well
07:57:11 * mcstar just wrote his first fortran program
07:58:20 <obiwahn> where does cabal build?
07:58:43 <eviltwin_b> default is a working directory under ~/.cabal
07:58:53 <obiwahn> http://paste.debian.net/179047/
07:59:12 <eviltwin_b> actually that dependon version, IO thinkt he latest used my $TMPDIR instead
07:59:34 <Taneb> Are there any tutorials on combining Haskell web frameworks in crazy ways?
07:59:39 <eviltwin_b> (this eyboard gotta die, ugh)
08:01:06 <mroman> Is there a better way for
08:01:19 <mroman> foo <- someIOStuff >>= return . someNonIOStuff
08:01:19 <mroman> ?
08:01:31 <mauke> >>= return . is liftM
08:02:01 <Taneb> mroman, fmap?
08:02:02 <brisbin> foo < fmap someNonIOStuff someIOStuff
08:02:05 <brisbin> <-*
08:02:28 <mroman> Ah.
08:02:33 <mroman> Good old mighty fmap. Thanks.
08:03:22 <mroman> he
08:03:41 <mcstar> foo <- someIOStuff someNonIOStuff
08:04:29 <mroman> d <- someIO >>= return.SomeNoneIO ; putStrLn $ d
08:04:37 <mroman> d <- someIO >>= return.SomeNoneIO ; putStrLn $ bar d
08:04:40 <mroman> ->
08:04:54 <mroman> fmap (bar . someNoneIo) >>= putStrLn
08:04:56 <mroman> cool.
08:05:15 <mcstar> someIO someNonIO >>= bar
08:05:28 <Taneb> Always use the least powerful thing you need?
08:05:30 <mietek> I have a problem with linking a static library into my Haskell binary
08:06:15 <mietek> ...and by mentioning it, I have solved it.
08:06:23 <mietek> Case-insensitive file system, thank you.
08:06:30 <Taneb> :)
08:06:58 <mroman> mcstar: Does not work in my case.
08:07:06 <mroman> someIO could be readFile "foo"
08:08:51 <obiwahn> somebody around who knows how to compile lamdabot?
08:10:08 <mcstar> mroman: (id . intersperse '\n' ) <$> getLine >>= putStrLn
08:15:26 <gspr> With Network.FastCGI, how can I run my program as a standalone one, communicating with the web server via a socket?
08:15:29 <gspr> It seems the default is to have the web server spawn the program.
08:15:42 <mcstar> mroman: this is better: getLine >>= putStrLn . (id . intersperse '\n')
08:16:01 <mauke> id .? what
08:16:12 <mcstar> mauke: another pure function
08:16:20 <mcstar> replace with whatever you want
08:16:51 <mcstar> and ofc, forget the parens
08:16:57 <hpc> gspr: the simplest way would just be to configure the standalone CGI to run without a thread limit
08:17:06 <hpc> start httpd
08:17:14 <hpc> first request, server runs CGI
08:17:24 <hpc> subsequent requests for the rest of time communicate with the same process
08:17:58 <dmwit> obiwahn:
08:17:58 <hpc> i have no idea how to go about actually doing that, as i don't particularly like the APIs for fastcgi in general
08:17:59 <dmwit> ?list
08:17:59 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
08:18:05 <hpc> so never bothered to learn
08:19:30 <gspr> hpc: Yeah, I guess, but I'd prefer to run the Haskell program as a standalone process executed independetly of the web server (it ties nicely into how other webapps on the server is run, and avoids the need for the usual hacks to have the web server execute the process as a different user)
08:21:41 <shirt> gspr: FastCGI can do this
08:22:20 <gspr> shirt: I know :)   I just haven't figured out how I do this with Network.FastCGI
08:22:38 <gspr> Do you know?
08:24:27 <shirt> gspr: nope, never used FastCGI in Haskell. Another option is to have your Haskell program be a regular HTTP server, and have the main web server reverse proxy to it
08:24:58 <gspr> shirt: Yeah, but it feels like a needless complexity. Thanks for the suggestion, though :)
08:25:16 <dmwit> gspr: acceptLoop already makes a socket to listen on...?
08:25:48 <gspr> dmwit: acceptLoop? Something tells me I'm looking at the wrong modules or something...
08:26:03 <dmwit> http://hackage.haskell.org/packages/archive/direct-fastcgi/1.0.3/doc/html/src/Network-FastCGI.html#acceptLoop
08:26:23 <gspr> oooh, this is not the same fastcgi module as the one I'm using
08:26:25 <gspr> thanks!
08:26:38 <gspr> Been using http://hackage.haskell.org/packages/archive/fastcgi/3001.0.2.3/doc/html/Network-FastCGI.html
08:26:59 <dmwit> ah
08:28:33 <gspr> dmwit: direct-fastcgi looks nice, though
08:28:36 <gspr> thanks!
08:28:51 <dmwit> \o/
08:29:23 <obiwahn> http://code.haskell.org/HSP/haskell-src-exts where did they move to?
08:30:21 <obiwahn> got them
08:33:36 <aetoxx> +RTS --help doesn't show how to let ghc use multiple OS threads. Do I need to compile things in a special way, if I want that?
08:33:56 <dmwit> aetoxx: Yes, you must link with -rtsopts.
08:34:12 <Saizan> -threaded
08:34:17 <dmwit> uh
08:34:17 <dmwit> yes
08:34:29 <dmwit> Wow, that was a really, really bad mistake.
08:34:55 <obiwahn> compileing lambdabot is no fun for the haskell beginner
08:35:04 <obiwahn> compiling
08:35:11 <dmwit> I think it's no fun even for a Haskell expert.
08:35:46 <obiwahn> i am luck that i just had to reinstall mueval
08:35:59 <aetoxx> If I want to compile with -O<very much> what do I need?
08:35:59 <obiwahn> the bot itself will not compile on the machine anymore
08:36:27 <dmwit> aetoxx: -O2 is the highest level supported by GHC.
08:36:46 <dmwit> aetoxx: You can also turn individual optimizations on and off, I think, but I don't have as much experience with that.
08:38:15 <aetoxx> If I run Yesod with 4 cores, it doesn't seem to use them :/
08:38:34 <dmwit> Are you forking anywhere?
08:38:41 <aetoxx> It's also slower than without the threaded RTS.
08:38:58 <dmwit> Yes, the nonthreaded RTS is slightly faster for some things than the threaded RTS.
08:39:09 <aetoxx> dmwit, no, but I would expect it to share the load.
08:39:18 <dmwit> aetoxx: How? Just... by magic?
08:39:22 <aetoxx> dmwit, that apparently doesn't happen.
08:40:03 <aetoxx> dmwit, other question: do you know how I can reproduce their 86000 requests/second?
08:40:21 <aetoxx> dmwit, I got to around 33000 req/sec.
08:40:25 <dmwit> I mean, if you're not calling any of the concurrent haskell primitives or any of the parallel haskell primitives... what did you expect to happen? =P
08:40:35 <dmwit> aetoxx: I haven't got the faintest idea.
08:40:41 <aetoxx> dmwit, I expect the webserver to handle those things.
08:40:53 <aetoxx> dmwit, i.e. Yesod.
08:41:59 <however> aetoxx: so compiling with -threaded and running with +RTS -N4 doesn't work?
08:42:21 <however> obiwahn: not sure what you're going for, but you can use lambdabot in private chat windows with no problems
08:42:33 <aetoxx> however, it doesn't increase performance.
08:42:33 <dmwit> aetoxx: I thought warp was the web server.
08:42:52 <aetoxx> dmwit, yesod uses warp.
08:43:07 * dmwit nods agreeably
08:43:49 <dmwit> Oh, the other thing to point out is that even after everything is said and done only one Haskell thread can be doing IO at a time.
08:43:53 <aetoxx> however, non-threaded gets me 33000, threaded just under 9000.
08:44:31 <aetoxx> dmwit, does the OS also impose that limitation?
08:44:51 <dmwit> There was an article in a recent (Monad Reader? or the other one?) about this problem and what to do about it.
08:44:52 <obiwahn> > cake
08:44:54 <dmwit> aetoxx: no
08:44:54 <lambdabot>   ["One 18.25 ounce package chocolate cake mix.","One can prepared coconut pe...
08:45:22 <however> dmwit: are you sure? i thought ghc > 7 had that spiffy io manager
08:45:23 <obiwahn> wanted to add some fun stuff myself
08:45:25 <aetoxx> dmwit, why did someone thought it was a good idea to add such limitations to a run-time system then?
08:45:33 <aetoxx> er think
08:45:37 <dmwit> however: The IO manager is exactly what makes that guarantee. =)
08:45:43 <zachk> > head . tail . reverse $ cake
08:45:47 <lambdabot>   "And it contains proven preservatives, deep penetration agents, and gas and...
08:46:46 <dmwit> aetoxx: It's the price you pay (currently) to have (forkIO {- something that waits on a socket -}) Just Work.
08:46:58 <dmwit> Perhaps in the future something else will be possible.
08:47:18 <dmwit> If you have ideas about how to make it happen, I'm sure GHC HQ is open to patches.
08:47:52 * hackagebot srcloc 0.2.0 - Data types for managing source code locations. (GeoffreyMainland)
08:48:25 <mauke> preflex: ? who:AndresLöh
08:48:25 <preflex>  kosmikus
08:48:55 <however> aetoxx: anyway, if the yesod people published a number of X requests per second, folks should be able to get comparable numbers on comparable hardware. you should ask them how they did it. post the exact command lines you used
08:49:32 <aetoxx> however, I asked.
08:49:35 <aetoxx> however, nobody responds.
08:49:55 <aetoxx> however, ghc --make -O2 Main and the same with -threaded
08:50:01 <zachk> aetoxx: most haskell channels over then #haskell, take a bit to get a response from
08:50:08 <zachk> other then
08:50:14 <mauke> other than
08:50:21 <zachk> ty mauke :D
08:50:33 <mcstar> cesc: hi
08:50:50 <zachk> hey mcstar
08:51:06 <mcstar> wtf
08:51:26 <mcstar> you have that highlighter configured wrong
08:51:32 <however> aetoxx: as i said, i guess that +RTS -N is necessary, but i'm not sure. when in doubt, try asking on the yesod mailing list
08:55:04 <siracusa> mauke: Where does preflex take the "who:" information from?
08:55:20 <mcstar> facebook
08:55:32 <mauke> disk
08:55:55 <monyama> mpi-haskell defines mpiWorld/mpi-functions, which encapsulates a mpi-driven function. sig: mpiWorld :: (Int → Rank → IO ∅) → IO ∅. is there any reason to not return a value? restrictions due to unsafe-stuff?
08:55:59 <however> face recognition via webcams
08:56:09 <LambdaDusk> can I put IO expressions into Template haskell stuff and if yes, how?
08:56:32 <dmwit> Absolutely, and via lift(IO).
08:56:58 <siracusa> mauke: And it came to said disk because you entered it manually for each nick you know or you took the information from a common source? (If the latter which one?)
08:57:11 <mauke> siracusa: the former
08:57:24 <siracusa> okay
08:57:37 <mauke> it works like @where
08:58:06 <dmwit> ...maybe qRunIO, actually. Not sure how many instances Q has.
08:58:06 <siracusa> I see, thanks
08:59:28 <LambdaDusk> qRunIO, because Q is not a MonadIO
08:59:31 <LambdaDusk> thanks, dmwit
08:59:46 <tdammers> I have this happstack application that I'd like to deploy to a toy server
09:00:08 <tdammers> problem is, the server is debian-i386, and I can't afford to install the entire haskell platform on it
09:00:11 <tdammers> way too heavy
09:00:14 <dmwit> LambdaDusk: Probably Q is not a MonadIO for dependency reasons, not fundamental ones.
09:00:28 <tdammers> other machines are amd64 though, so I'm wondering how I can get this thing deployed
09:00:29 <dmwit> LambdaDusk: Feel free to write instance MonadIO Q where liftIO = qRunIO if you want.
09:00:52 <LambdaDusk> dmwit: Wonder why it is not done yet
09:00:58 <dmwit> "for dependency reasons"
09:01:13 <dmwit> i.e. so that template-haskell doesn't depend on mtl
09:01:18 <LambdaDusk> oh
09:01:29 <LambdaDusk> MonadIO should be base, anyway
09:01:45 <dmwit> I don't think it is.
09:01:51 <tdammers> dmwit: the instance declaration could have been put in a dedicated package, right?
09:01:53 <LambdaDusk> there's also runIO :: IO a -> Q a
09:02:01 <dmwit> tdammers: Of course.
09:02:10 <obiwahn> are there more places than .cabal where cabal stores information?
09:02:25 <dmwit> obiwahn: No, but there are more places than .cabal where GHC stores information.
09:02:45 <dmwit> (And cabal queries whatever compiler you choose for many operations.)
09:02:48 <LambdaDusk> obiwahn: the .ghci file, for example
09:03:32 <obiwahn> ah so that is why it could build in a clean home and not itn the old?
09:04:56 <dmwit> That question certainly does not have enough information to answer.
09:05:21 <obiwahn> dmwit: mueval fails to build in the old home
09:06:10 <obiwahn> i copied the dir to my normal user to pull from trime t time and see if it builds
09:07:24 <obiwahn> it is strange that it build in /home/user2 but not in /home/user1
09:07:41 <obiwahn> all i have used is cabal clean and cabal install
09:08:17 <LambdaDusk> dmwit: Now I strangely have a type "Q a", how can I make it "a"?
09:09:10 <dmwit> That's a bit like asking "How do I get the 'a' out of 'IO a'?".
09:09:17 <eviltwin_b> isn't it only useful in the context of either the compiler or the AST and therefore must always be in Q anyway?
09:09:23 <Taneb> How is (<*>) pronounced?
09:09:24 <dmwit> If all you wanted was the 'a' in the first place, why are you using Template Haskell?
09:09:50 <dmwit> And finally: runQ.
09:09:51 <monyama> (for future reference regarding mpi-haskell; I wrote my own entry function, with imports from MPI.Base)
09:10:03 <dmwit> I think that covers all the answers I wanted to give you.
09:10:10 <mauke> @quote .pronounce
09:10:11 <lambdabot> uncyclopedia says: Calculations which are undefined are denoted by the _|_ symbol, pronounced Bottom, which the documentation explains as the compiler giving you the finger.
09:10:16 <dmwit> Taneb: "ap", I think
09:10:17 <mauke> @quote .pronounce
09:10:17 <lambdabot> monochrom says: <$> is pronounced Jacquelin von Brionée
09:10:21 <monochrom> hehe
09:10:22 <Taneb> dmwit, thanks
09:10:32 <dmwit> :t (<*>)
09:10:35 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
09:10:36 <LambdaDusk> dmwit: Because I have a file with data and I want it compiled into my program
09:10:44 <monochrom> don't try to "Q a -> a". but do tell what Q is
09:10:48 <mauke> preflex: quote monochrom pronounce
09:10:48 <preflex>  <monochrom> Do not try to pronounce haskell code. You are not a modem.
09:11:05 <dmwit> LambdaDusk: Okay, I'm with you so far. Why does that scream "Q a -> a" to you?
09:11:39 <however> monochrom: he's working with TH
09:11:46 <beefcube> I'm thinking about writing a small haskell program to generate quickcheck testcases and files, and further, update a test-suite from a source directory, what is the most newbie approachable way to parse and generate haskell in haskell :P?
09:12:16 <eviltwin_b> LambdaDusk: if it's an a it's not going to be part of the program.  it has to be in Q to become part of the program, because the compiler is in Q and the compiler is where your program is
09:12:17 <LambdaDusk> dmwit: I made a function "loadData s = [|runIO $ load s|]" and then called "$(loadData "file.txt")"
09:12:28 <monochrom> @quote Katamoto
09:12:28 <lambdabot> No quotes match. Just try something else.
09:12:36 <monochrom> preflex: quote monochrom Katamoto
09:12:37 <preflex>  no quotes found for monochrom
09:13:03 <c_wraith> beefcube: parse using the haskell-src-exts library. generate code - uh..  possibly with template haskell
09:13:11 <monochrom> I had one that also says "<*> is Kuso Katamoto". also "~> is Chen Zhong-Quieh"
09:13:20 <c_wraith> LambdaDusk: too many Qs.  loadData s = runIO $ load s
09:13:37 <beefcube> c_wraith: thanks
09:14:06 <mauke> which one is Oktavia von Seckendorff?
09:14:21 <monochrom> I haven't done that one
09:14:26 <cesc> mcstar, hey!
09:15:06 <cesc> mcstar, just got back from the lab and I'm ready for another epic session with "learn you a haskell" :))
09:15:13 <c_wraith> LambdaDusk: except not really..  loadData s = do { d <- runIO $ load s ; [| d |] }
09:15:23 <mroman> epic? *g*
09:15:44 <gspr> dmwit: I'm a little bit confused by direct-fastcgi... do you know of any examples (tiny or otherwise) that may help me get off the ground?
09:15:49 <c_wraith> LambdaDusk: the important part is that you quote the expression you want to generate - not the code you're using to calculate that expression
09:17:09 <dmwit> gspr: I've never done fast CGI before at all. Sorry.
09:17:19 <dmwit> I just read the docs. =P
09:17:42 <LambdaDusk> c_wraith: Now it complains about a missing instance of "Lift"
09:18:07 <c_wraith> LambdaDusk: ok, that means things are moving in the right direction
09:18:39 <LambdaDusk> c_wraith: I don't think I can make this type liftable...
09:18:41 <c_wraith> LambdaDusk: the Lift class in template haskell is for converting values to template haskell ASTs.  what's the return type of load
09:18:58 <LambdaDusk> it's a ForeignPtr, kinda
09:19:06 <gspr> dmwit: Alright. Thanks anyway
09:19:31 <c_wraith> ooh.   that's problematic.   Though sometimes you can work around it
09:20:06 <c_wraith> like, ByteString is sort of a pointer type internally - and you can work around it by creating an expression that calls pack an a list of the word8s in it
09:20:34 <cesc> mroman, yes, epic :D
09:20:39 <LambdaDusk> c_wraith: I don't know if it's worth it... perhaps I just do runtime loading
09:21:04 <LambdaDusk> was a quick idea but since it's not the main focus of the application, I don't think I should bother with it further
09:21:13 <c_wraith> LambdaDusk: that's also a good approach
09:21:16 <LambdaDusk> thanks for the help, c_wraith, dmwit
09:23:48 <ninegrid> i've tried to cabal install lambdabot, but it errors with ExitFailure 1 saying it can't find libncurses.so, but it is there in the path it specified... any ideas how to proceed?
09:24:00 <ozataman> anyone know of a good library for timing things for production instrumentation purposes? something efficient in IO is fine, but if it can force/measure pure expressions, even better.
09:25:11 <otters> ninegrid: what OS?
09:25:49 <ninegrid> archlinux
09:25:50 <however> ozataman: i take it you're aware of ghc's profiling?
09:25:56 <opqdonut> ozataman: criterion?
09:26:14 <otters> ninegrid: what's the output from cabal install?
09:26:24 <ozataman> opqdonut: isn't criterion for benchmarking - I'm looking for something I can use continuously in a production app
09:26:45 <ninegrid> otters: Loading package readline-1.0.1.0 ... <command line>: can't load .so/.DLL for: /usr/lib/gcc/i686-pc-linux-gnu/4.7.0/../../../libncurses.so (-lncursesw: cannot open shared object file: No such file or directory)
09:26:47 <EmilyS> any suggested editors for mac? I'm looking at TextMate & Sublime
09:26:53 <nand`> EmilyS: vim
09:26:55 <ozataman> however: forgot about that, let me see if I can use that
09:26:55 <ninegrid> otters: ExitFailure  1
09:27:08 <ozataman> however: well, not profiling of course, but the runtime stats system that was recently added
09:27:13 <EmilyS> ^q^c^x
09:27:14 <ninegrid> otters: -rw-r--r-- 1 root root 18 Feb  8 01:08 /usr/lib/gcc/i686-pc-linux-gnu/4.7.0/../../../libncurses.so
09:27:34 <otters> ninegrid: yeah, lambdabot is an absolute nightmare to install
09:27:37 <otters> hmmm
09:27:42 <mauke> ninegrid: file /usr/lib/gcc/i686-pc-linux-gnu/4.7.0/../../../libncurses.so
09:27:42 <ninegrid> otters: excellent :/
09:27:50 <otters> mauke: he just did that
09:27:58 <mauke> otters: what were the results?
09:27:58 <otters> I think...
09:28:04 <otters> ^
09:28:08 <mauke> what
09:28:09 <otters> oh wait, no, that's just ls output
09:28:11 <ninegrid> otters: heh, it says ASCII Text
09:28:18 <otters> o_o
09:28:20 <mauke> ninegrid: cat /usr/lib/gcc/i686-pc-linux-gnu/4.7.0/../../../libncurses.so
09:28:40 <monochrom> yes, some *.so files are shell scripts
09:28:47 <mauke> ... shell?
09:28:53 <monochrom> nevermind
09:29:00 <benmachine> linker scripts
09:29:04 <ninegrid> ok
09:29:06 <ninegrid> otters:  INPUT(-lncursesw)
09:29:24 <dmwit> Why do you keep telling otters? mauke is the one asking.
09:29:28 <otters> oh, oh, crap I used to know how to fix that
09:29:30 <mauke> ninegrid: so the error message says: the library -lncursesw required by /usr/lib/gcc/i686-pc-linux-gnu/4.7.0/../../../libncurses.so was not found
09:30:23 <ninegrid> mauke: interesting, i'll have to lookup where to get that library
09:31:21 <benmachine> mauke: is it? I thought it was just that ghc can't read linker scripts
09:31:39 <benmachine> oh but the error message does mention -lncursesw
09:32:14 <dmwit> ghc doesn't try to read linker scripts.
09:32:39 <dmwit> It lets ld do that.
09:32:54 * hackagebot graph-rewriting 0.7.2 - Monadic graph rewriting of hypergraphs with ports and multiedges (JanRochel)
09:32:55 * hackagebot language-c-quote 0.4.0 - C/CUDA/OpenCL quasiquoting library. (GeoffreyMainland)
09:32:57 <dmwit> I actually don't know this for sure, but I have a hard time imagining it working any other way.
09:32:57 * hackagebot graph-rewriting-ww 0.2 - Interactive reduction of lambda-calculus with explicit sharing (JanRochel)
09:32:59 <Tukeke> https://fbcdn-sphotos-a.akamaihd.net/hphotos-ak-ash3/s720x720/531653_472005976145822_677518032_n.jpg
09:32:59 * hackagebot mainland-pretty 0.2.0 - Pretty printing designed for printing source code. (GeoffreyMainland)
09:34:18 <obiwahn> mueval: Using large values for -N is not allowed by default. Link with -rts.. how can i do that?
09:34:22 <benmachine> dmwit: I'm fairly sure there have been problems in the past with linker scripts that were fixed by replacing them with equivalent symlinks
09:34:54 <ninegrid> mauke: thanks, i was able to fix the error
09:35:25 <ninegrid> now i have a new error
09:35:28 <eviltwin_b> the problem is that the linker script ues the shorthand -lncursesw instead of the full pathname.  use the full pathname, or replace the linker script with a symlink to the correct library
09:37:09 <ninegrid> eviltwin_b: i used the full pathname
09:37:54 * hackagebot graph-rewriting-ski 0.6.1 - Two implementations of the SKI combinators as interactive graph rewrite systems (JanRochel)
09:38:03 <copumpkin> omg it's ski
09:38:10 <dmwit> benmachine: I believe that.
09:39:31 <ninegrid> what i have now is that in Plugin/Activity.hs:18:10:  Illegal instance declaration for `Module ActivityModule \n ActivityState' (all instance types must be of the form (T a1 ... an) ...
09:40:10 <ninegrid> i put the newline in there myself, but in the wrong place
09:40:27 <dmwit> The error probably has a sentence telling you exactly how to fix that problem.
09:41:17 <ninegrid> it says use -XFlexibleInstances if i want to disable this, but i'm not sure how I go about passing that flag to cabal install
09:42:49 <ninegrid> i think i got it, trying
09:43:53 <ninegrid> ok
09:44:03 <ninegrid> dmwit: thanks, i got it to build successfully
09:45:11 <Tukeke> http://www.fakt.pl/m/Repozytorium.Obiekt.aspx/-650/-550/faktonline/634380440531123482.jpg
09:45:18 <obiwahn> ninegrid: did you install lamdabot as well?
09:45:29 <dmwit> ?where ops
09:45:29 <lambdabot> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
09:45:32 <however> tukeke: will you please stop posting that
09:45:44 --- mode: ChanServ set +o copumpkin
09:45:52 <Tukeke> sorry
09:45:54 <Tukeke> :x
09:46:03 <Tukeke> :$
09:46:20 <copumpkin> Tukeke: do you have any interest in haskell?
09:46:26 <Tukeke> yes
09:47:20 <copumpkin> then ask some questions or talk about haskell. Random pictures are off-topic
09:47:23 <copumpkin> :P
09:47:27 --- mode: copumpkin set -o copumpkin
09:47:54 * hackagebot graph-rewriting-ww 0.3 - Interactive reduction of lambda-calculus with explicit sharing (JanRochel)
09:48:25 <Tukeke> hehe
09:48:45 <obiwahn> ?list
09:48:45 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
09:49:02 <obiwahn> dice
09:49:11 <obiwahn> ?dice
09:49:11 <lambdabot> unexpected end of input: expecting number
09:49:34 <mcstar> should have made it into a gif, showing a flower, and suddenly....
09:49:35 <ManateeLazyCat> How about OCaml? I want to try it.
09:50:09 <obiwahn> thank god!!! it is working:)
09:50:52 <ninegrid> obiwahn: yes, it is working
09:51:15 <obiwahn> i have wasted an hour or so on it:p
09:51:34 <otters> christ I don't know anything about configure scripts
09:51:37 <otters> do people write these manually??
09:51:43 <obiwahn> but it is a nice bot:)
09:52:00 <ninegrid> speaking of configure scripts, i need to know how to configure it to connect to my local ircd
09:52:23 <obiwahn> thank you however, dmwit!!
09:52:30 <ninegrid> i see lambdabot -e 'rc online.rc' but not sure where i put online.rc or what to put in it
09:53:01 <obiwahn> ninegrid: put it in some extra dir like.lamdabot
09:53:06 <obiwahn> .lamdabot
09:53:20 <eviltwin_b> otters: generally one uses autoconf.  but, well, prepare to meet the horror that is m4
09:53:20 <benmachine> otters: I've never written one, but I understand autoconf is often involved
09:53:32 <otters> I don't think anybody would manually write this monstrosity
09:53:32 <obiwahn> ill poste you mine
09:53:52 <otters> I'm just trying to modify readline so that it'll build on OSX without all the incantations and sacrifices required
09:57:40 <otters> but to be perfectly honest
09:57:41 <otters> http://i1.kym-cdn.com/photos/images/original/000/234/739/fa5.jpg
09:57:49 <danielsmw> otters: I installed it a few weeks ago, but it did cost me a pretty weird homebrew setup and a few sacrificed rabbits.
09:57:57 <otters> yeah
09:58:08 <otters> I had to brew install readline and then link with that readline
09:58:26 <otters> I think the readline bundled with OSX is actually libedit so it doesn't have undo capability
10:27:47 <obewon> How would I define the type of this function? monthOffset month = ((3.4 + (month - 3)) `mod` (12 * 2.6)) `mod` 7
10:27:57 <obewon> I tried monthOffset :: (Integer a, Float b) => a -> b
10:28:17 <scopedTV> mod neads Integral iirc
10:28:21 <scopedTV> Integer is not a type class
10:28:24 <scopedTV> Float neither
10:28:42 <scopedTV> in any case, doing `mod` on floating point values is unlikely to be a success
10:29:21 <obewon> What type would I use to successfully use `mod`?
10:29:28 <scopedTV> Integer, for exmaple
10:29:39 <however> :t mod
10:29:41 <lambdabot> forall a. (Integral a) => a -> a -> a
10:30:01 <scopedTV> > mod 42 37
10:30:03 <lambdabot>   5
10:30:14 <however> obewon: ^^ this means "a" needs to be something that has an Integral instances
10:30:17 <however> @instances Integral
10:30:19 <monochrom> scale up your whole formula by 10, then you can use integers
10:30:19 <lambdabot> Int, Integer
10:30:23 <however> ^^ there ya go
10:30:52 <eviltwin_b> also Word* and a few others of that ilk that are in scope with the appropriate module(s)
10:31:29 <eviltwin_b> @instances-importing Integral Foreign.C.Types Data.Bits
10:31:30 <lambdabot> Couldn't find class `Data.Bits'. Try @instances-importing
10:31:42 <eviltwin_b> backwards args, naturally
10:31:49 <eviltwin_b> @help instances-importing
10:31:50 <lambdabot> instances-importing [<module> [<module> [<module...]]] <typeclass>. Fetch the instances of a typeclass, importing specified modules first.
10:32:09 <eviltwin_b> @instances-importing Foreign.C.Types Data.Bits Integral
10:32:09 <lambdabot> CChar, CInt, CIntMax, CIntPtr, CLLong, CLong, CPtrdiff, CSChar, CShort, CSigAtomic, CSize, CUChar, CUInt, CUIntMax, CUIntPtr, CULLong, CULong, CUShort, CWchar, Int, Integer
10:32:21 <eviltwin_b> @instances-importing Foreign.C.Types Data.Word Integral
10:32:22 <lambdabot> CChar, CInt, CIntMax, CIntPtr, CLLong, CLong, CPtrdiff, CSChar, CShort, CSigAtomic, CSize, CUChar, CUInt, CUIntMax, CUIntPtr, CULLong, CULong, CUShort, CWchar, Int, Integer, Word, Word16, Word32,
10:32:22 <lambdabot> Word64, Word8
10:32:31 <eviltwin_b> there we g...
10:37:25 <obewon> Would 'Fractional Int' be considered a part of Integral?
10:38:04 <benmachine> obewon: do you possibly mean Ratio Int?
10:38:39 <obewon> Well, I'm getting an error 'No instance for (Fractional Int) arising from the literal `3.4''
10:38:52 <obewon> This is the function again monthOffset month = ((3.4 + (month - 3)) `mod` (12 * 2.6)) `mod` 7
10:39:05 <benmachine> obewon: ah, that's because you're trying to use 3.4 in a context that demands it is an Int
10:39:05 <obewon> Type Int -> Int
10:39:28 <benmachine> because `mod` returns the same output type as its input, and the same goes for + and -
10:39:40 <benmachine> so if the result is Int, all the numbers must be
10:39:46 <benmachine> but that doesn't work, because 3.4 isn't
10:39:50 <benmachine> hence your problem
10:40:02 <eviltwin_b> obewon, it's telling you that you';re using a Fractional where an Int is required.  Int is not Fractional (hence no instance)
10:41:06 <eviltwin_b> if you want floating/fractional, you can't use mod.  if you want Int/Integer then you need to use one of ceiling, floor, round, or trunc to generate an Int/Integer from the floating value
10:41:14 <eviltwin_b> er, truncate
10:41:43 <obewon> :t truncate
10:41:44 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
10:42:31 <obewon> Ah, ok I see
10:42:43 <obewon> I think I'll have to restructure the formula
10:43:03 <eviltwin_b> (ceiling rounds up, floor round down, truncaterounds toward 0, round is 5/9 rounding)
10:43:45 <eviltwin_b> and if you want floating modulus then there is no predefined one but it's easy enough to do yourself
10:43:52 <ClaudiusMaximus> :t mod'
10:43:54 <lambdabot> forall a. (Real a) => a -> a -> a
10:54:09 <c_wraith> @hoogle mod'
10:54:10 <lambdabot> Data.Fixed mod' :: Real a => a -> a -> a
10:54:10 <lambdabot> Data.Fixed divMod' :: (Real a, Integral b) => a -> a -> (b, a)
10:54:41 <hpaste> joeyh_ pasted “ghc -threaded hang testcase” at http://hpaste.org/71467
10:55:12 <joeyh_> the above paste reliably hangs, rather than running forever for me.. can anyone verify?
10:55:43 <joeyh_> only when built with -threaded, mind you
10:59:21 <User9eB1> It seems to run forever for me
10:59:26 <User9eB1> How long does it take to hang?
11:00:10 <eviltwin_b> hClose is not meaningful on a handle that you've hGetContents-ed (although it shouldn't cause an error)
11:00:54 <joeyh_> User9eB1: less than 1 minute here
11:01:09 <joeyh_> on linux, with ghc 7.4.2
11:01:31 <User9eB1> I am on Mac OS X with GHC 7.4.1
11:01:32 <joeyh_> however, it is fairly a fragile test case.. when I remove *any* of the prints, it doesn't hang
11:01:43 <hpaste> qrt pasted “dice game” at http://hpaste.org/71469
11:01:51 <joeyh_> even the in/out ones, which should have no effect
11:02:31 <eviltwin_b> joeyh_: I'm notsurprised it's fragile, that code is doing several things that might be safe in this particular case but in the general case *will* hang
11:02:32 <User9eB1> It's been running several minutes now, so it probably doesn't hang.
11:03:13 <joeyh_> eviltwin_b, hmm, what?
11:03:26 <eviltwin_b> your echo produces less than _PIPE_BUF data
11:04:41 <chrisdone> ello ello, then
11:04:57 <eviltwin_b> hm, actually, wait, not sure.  but potential race condition between output and waitpid(), plus questions of buffering
11:04:57 <benmachine> good evening
11:05:20 <eviltwin_b> you are doing things that are somewhat poorly defined in the absence of a forkIO thread to do the read from the pipe
11:05:46 <chrisdone> benmachine: i just spent an hour trying to think of a project name
11:06:01 <chrisdone> productive day is productive
11:06:41 <gwern> there. I think I just finished with the last of the 300+ spammers on hawiki
11:06:48 <benmachine> gwern: neat!
11:06:54 <gwern> no, not neat. this took hours and hours
11:07:01 <benmachine> gwern: well, useful then
11:07:03 <gwern> something has to be done, and ashley is AWOL
11:07:07 <benmachine> oh, I see
11:07:32 <benmachine> chrisdone: put the code through a markov-chain tool and pick something vaguely pronouncible from the output
11:08:45 <benmachine> gwern: on a largely unrelated note, I once heard some discussion of an idea to move from mediawiki to something haskellier, like gitit, do you have a view on that?
11:08:54 <however> chrisdone: what's the project about?
11:09:08 <gwern> benmachine: yes, what I say everytime: it's a bad idea, and it's gotten even worse since john lost interest in gitit
11:10:07 <benmachine> gwern: hmm. I did not know that had happened
11:10:36 <chrisdone> however: it's a language. a haskell subset that compiles to js. maybe ‘Danny Dyer's Chocolate Homunculus’
11:11:14 <benmachine> chrisdone: seems like a lot of people are making languages that compile to JS nowadays :P
11:11:32 <chrisdone> benmachine: yeah, it's like Roy and Elm. both are great names
11:12:20 <however> chrisdone: hijinks (contains H, J and S)
11:15:43 <Qrt> i want to execute a function N times and store the result in a var and then do var / N (this is probability). is that some sort of fold?
11:16:15 <saml> Qrt, recursion?
11:16:25 <saml> f n param1 param2 param3
11:17:20 <slack1256> Qrt: how many parameters take the function?
11:21:25 <Qrt> i used foldl
11:21:45 <eviltwin_b> Qrt, you need to describe hat you want a bit better
11:23:17 <mcstar> lol
11:23:29 <mcstar> im trying out a gsl random number generator in haskell
11:23:36 <mcstar> guess what i get: Bus error
11:26:07 <ClaudiusMaximus> mcstar: i got that with some hmatrix gsl things in ghci once, can't remember what i did to workaround it, if anything - maybe -fno-ghci-sandbox would help (not sure, worth a try?)?
11:26:48 <hpaste> typeproblem pasted “qrt” at http://hpaste.org/71470
11:26:50 <mcstar> ClaudiusMaximus: tried to query a function on a qrng generator(supposed to give back its runlength), it segfaults
11:27:07 <mcstar> ClaudiusMaximus: ill try that
11:27:24 <Qrt> ^^ pasted with a haskell problem :)
11:27:36 <mcstar> ClaudiusMaximus: im trying this in ghci, cause the compiled program produced 0s only
11:27:50 <saml> how do I get Int from Num a?
11:28:01 <mcstar> depends
11:28:29 <mcstar> ClaudiusMaximus: same
11:28:40 <eviltwin_b> you don't typically have a Num a /per se/.  what's the actual problem?
11:28:47 <ClaudiusMaximus> mcstar: ah, doesn't help with gsl minimize either - just got a Bus error too
11:28:54 <mcstar> haha
11:29:13 <Qrt> noone likes problabliblity?
11:29:14 <mcstar> insurrection of the fast numerical libraries just started
11:29:26 <saml> I have DiffTime. I want Int
11:29:49 <eviltwin_b> maybe there's some initialization function that should be called first?  (although that would be a poorly designed API)
11:30:24 <ClaudiusMaximus> saml: you probably want one of  round, truncate, floor, ceiling
11:30:54 <Qrt> No instance for (Num (IO a0))
11:31:12 <Qrt> hmm, what do i do about that?
11:31:24 <eviltwin_b> saml:  actually I think it's just fromEnum
11:31:53 <adnap> Chart-0.15 depends on cairo-0.12.3 which failed to install.
11:31:53 <adnap> cairo-0.12.3 failed during the configure step. The exception was:
11:31:54 <ClaudiusMaximus> Qrt: you probably want to use replicateM
11:31:54 <adnap> ExitFailure 1
11:32:05 <saml> eviltwin_b, thanks. also ClaudiusMaximus
11:33:20 <Qrt> @type replicateM
11:33:21 <ClaudiusMaximus> adnap: did you install gtk2hs-buildtools first?  and the gtk development headers for your system?
11:33:22 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
11:33:26 <eviltwin_b> looks like you get picoseconds in that case, though.  but it is instance Fractional so ClaudiusMaximus is correct to get seconds
11:33:28 <Qrt> hmm
11:33:31 * eviltwin_b jus poked at source
11:34:55 <Qrt> yes i want replicateM but that doesnt solve my problöem
11:35:02 <Qrt> i have type problemns with IO Int NUm
11:35:04 <Qrt> ill repaste
11:35:29 <hpaste> typeproblem pasted “qrt” at http://hpaste.org/71471
11:35:58 <adnap> ClaudiusMaximus: no (doing it now)
11:36:19 <hpaste> qrt annotated “qrt” with “qrt (annotation)” at http://hpaste.org/71471#a71472
11:36:21 <ClaudiusMaximus> adnap: you also need alex and happy to build gtk2hs-buildtools iirc
11:37:21 <ClaudiusMaximus> Qrt: ah - i see
11:37:33 <ClaudiusMaximus> Qrt: http://hpaste.org/71471#line18 this '1' is the problem
11:38:02 <ClaudiusMaximus> Qrt: and the 0 after it
11:38:59 <saml> how can I get random Int  from values 1,2,3 ?
11:39:17 <Qrt> ah return
11:39:50 <ClaudiusMaximus> Qrt: yes
11:39:50 <Qrt> rand123 = R.randomRIO (1::Int, 3) -- i hope where R is System.Random
11:41:51 <adnap> ClaudiusMaximus: i installed gtk2hs-buildtools and Chart still fails to install with the same error
11:42:59 * hackagebot wai-extra 1.2.0.6 - Provides some basic WAI handlers and middleware. (MichaelSnoyman)
11:43:16 <eviltwin_b> could also be looking for gtk or cairo development libraries (*-dev packages on most linuxes)
11:47:18 <Qrt> @hoogle Int -> String
11:47:19 <lambdabot> Test.QuickCheck.Text number :: Int -> String -> String
11:47:19 <lambdabot> Test.QuickCheck.Text short :: Int -> String -> String
11:47:19 <lambdabot> Data.Generics.Text gshow :: Data a => a -> String
11:47:27 <Qrt> @type show7
11:47:28 <lambdabot> Not in scope: `show7'
11:47:29 <Qrt> @type show
11:47:30 <lambdabot> forall a. (Show a) => a -> String
11:47:38 <Qrt> @src show
11:47:38 <lambdabot> show x = shows x ""
11:47:47 <Qrt> @src shows
11:47:47 <lambdabot> Source not found. Sorry.
11:48:23 <mroman> > show 5 "."
11:48:25 <lambdabot>   Couldn't match expected type `[GHC.Types.Char] -> t'
11:48:26 <lambdabot>         against inferr...
11:48:46 <mroman> > shows 5 "."
11:48:48 <lambdabot>   "5."
11:49:03 <mroman> > show 5++"."
11:49:05 <lambdabot>   "5."
11:49:28 <Qrt> is Random really slow?
11:49:28 <mroman> Using shows is a nice and rare golfing trick ;)
11:49:38 <dmwit> Is there an English word for the (++) operation?
11:49:45 <mroman> concatenate?
11:49:47 <mroman> append?
11:49:49 <eviltwin_b> or append
11:50:00 <dmwit> append works, I guess
11:50:02 <mcstar> Qrt: very slow
11:50:02 <mauke> concat
11:50:10 <dmwit> I would think of append as being (++[x])
11:50:14 <mcstar> im benchmarking rngs atm
11:50:21 <dmwit> But okay.
11:50:33 <mroman> Generalle when using strings it's concatenation.
11:50:40 <mroman> I guess who can extend that to lists too
11:50:43 <mroman> *you
11:50:46 <mcstar> 63 secs for System.Random vs. 1.6 secs for System.Random.Mersenne
11:50:55 <Taneb> I'm doing the thing that every bored haskeller does one day and rewriting Prelude
11:51:00 <mroman> mcstar: It takes time to init the random seed probably?
11:51:08 <mcstar> mroman: ??
11:51:13 <eviltwin_b> it's just slow in general
11:51:20 <mroman> if randomRIO reeds from /dev/random it's going to be very slow ;)
11:51:25 <mroman> or randomIO
11:51:26 <however> @remember Taneb I'm doing the thing that every bored haskeller does one day and rewriting Prelude
11:51:26 <lambdabot> Done.
11:51:34 <eviltwin_b> no, it's not using /dev/random
11:51:40 <mcstar> it doesnt use /dev/random
11:51:43 <mroman> ok, than I go hide :)
11:51:49 <mroman> *then
11:51:50 <mcstar> /dev/random is just for initialization anyway
11:51:54 <dmwit> Taneb: If you're bored, do the ICFPPC. =)
11:52:47 <Taneb> ICFPPC?
11:52:59 <mroman> Yeah, he still has one day left :)
11:53:22 <dmwit> http://icfpcontest2012.wordpress.com/
11:53:28 <eviltwin_b> think it's a bit late to try to get into the ICFP programming contest
11:53:34 <dmwit> probably
11:53:47 <dmwit> But you don't have to enter the contest just because you're working on it.
11:54:03 <dmwit> If you're bored, playing with it is probably better than rewriting the Prelude. =)
11:55:59 <mcstar> dont fix what aint broken
11:56:10 <byorgey> if you're bored you could even just try to match the high scores here: http://icfp.stbuehler.de/icfp2012/
11:56:22 <Taneb> I'm just doing this for fun and practise
11:56:35 <hpaste> qrt pasted “simplify this please” at http://hpaste.org/71473
11:57:23 <hpaste> qrt annotated “simplify this please” with “simplify this please (annotation)” at http://hpaste.org/71473#a71474
11:57:53 <mcstar> Qrt: you can get an infinite list with random numbers
11:58:00 <mcstar> no need to write the game logic in IO
11:58:06 <mroman> Too much if then else if you aske me.
11:58:36 <mcstar> and remove that python looking code
11:58:38 <mcstar> ghc will complain
12:01:56 <however> byorgey: what a stupid game. someone should write a program to automate it
12:02:03 <however> ;)
12:03:42 <mcstar> i think you can simplify the logic with Either as a monad
12:05:01 <Qrt> mroman: yes i want to get rid ofthat but how?
12:05:14 <mcstar> > (if False then Left 1 else Right 2) >> (if False then Left 3 else Right 4)
12:05:15 <lambdabot>   Right 4
12:05:29 <mcstar> just concatenate the conditions smartly
12:05:48 <mcstar> if a Left is encountered, it terminates early
12:05:53 <mcstar> just like a return
12:06:42 <dmwit> ?src liftA23
12:06:43 <lambdabot> Source not found. Wrong!  You cheating scum!
12:06:45 <dmwit> ?src liftA3
12:06:45 <lambdabot> Source not found. You speak an infinite deal of nothing
12:08:13 <Qrt> can anyone tell me why the python program returns 0.86 and the haskell one 0.56 i think it is the same code...
12:08:23 <Qrt> RandomRIO is uniform right?
12:08:36 <mcstar> yes
12:08:44 <mroman> What does uniform mean?
12:09:16 <teaurchin> what is the idiomatic way to search and fold a mutable Vector? should I freeze it first? is that slow?
12:09:19 <mcstar> the clothes that armymen, policmen, and firemen wear
12:09:25 <mroman> Yeah.
12:09:31 <mroman> I know uniform in that context.
12:09:32 <hpaste> qrt pasted “simplifty_this” at http://hpaste.org/71475
12:10:07 <mroman> I've just never heard it in the context of "random"
12:10:09 <Qrt> mroman: doesnt it mean normal distributed. i could bw rong
12:10:21 <mroman> Ah
12:10:23 <mroman> Ok.
12:11:00 <mcstar> aaaaa
12:11:07 <mcstar> uniform /= normal
12:11:09 <mcstar> come on
12:11:30 <Qrt> not normal distributed?
12:11:34 <mcstar> noooo
12:11:37 <mroman> It probably means, that every number in the range should actually occure as a result?
12:11:37 <mcstar> thats gaussian
12:11:42 <Qrt> true
12:11:53 <mcstar> uniform means, with equal probability for the range of the generator
12:12:02 <Qrt> my mistake but uniform means ll values have equal probability
12:12:13 <Qrt> which isnt normal distributed, my mistake
12:12:14 <mcstar> ??
12:12:26 <mcstar> "equal values have equal probability" < wtf
12:12:37 * mcstar stop ranting!
12:12:43 <mcstar> sry
12:12:46 <Qrt> uniform [1,2,3]  means 1 and 2 and 3 are all equally likely
12:13:03 <Qrt> what is RandomRIO?
12:13:13 <mroman> random range i/o?
12:13:17 <Qrt> how can i get rid of the if else if else...
12:13:44 <mroman> It uses a seed from the outter world ;)?
12:16:01 <teaurchin> what is the idiomatic way to search and fold a mutable Vector? should I freeze it first? is that slow?
12:17:25 <dmwit> Qrt: If I add print("whoops") after the last "if" in your Python, your program prints whoops a lot.
12:17:30 <dmwit> Qrt: Just thought you should know.
12:18:04 <dmwit> um
12:18:11 <dmwit> Which pretty much tells you the bug, too. =)
12:18:16 <Qrt> i dont get how to get rid of the if-then-else-if-then...
12:18:17 <dmwit> Or at least, it tells me the bug.
12:18:23 <dmwit> Qrt: Oh, that part's easy.
12:18:44 <dmwit> case (player, dice) of (Player1, 1) -> return 1; (Player2, 6) -> return 0; _ -> playGame (pnot player)
12:18:53 <dmwit> pnot Player1 = Player2; pnot Player2 = Player1
12:19:07 <dmwit> Qrt: So, did you spot the bug in your Python code yet? =)
12:19:23 <dmwit> (Hint: what happens if player 1 rolls a 6?)
12:19:38 <dmwit> (What about a 5?)
12:21:03 <Qrt> ah oops
12:21:14 <aetoxx> mcstar, seems random.
12:21:26 <mcstar> hm?
12:21:37 <mcstar> what does seem random?
12:21:47 <aetoxx> mcstar, responding to something you said a long time ago.
12:21:56 <aetoxx> mcstar, not really applicable.
12:22:18 <mcstar> aetoxx: long time, as in weeks?
12:22:43 <aetoxx> Does anyone know of a music player which doesn't crash, has features and a GUI?
12:22:49 <teaurchin> dmwit: have you used Data.Vector much? I'm struggling here :P
12:22:51 <aetoxx> mcstar, no, likely hours.
12:22:51 <Qrt> now the haskell and python code returns the same, 0.54
12:23:08 <Qrt> can anyone explain to me how to calculate it and not simulate it?
12:23:37 <however> aetoxx: i've been fairly happy with quodlibet. it's not the greatest thing ever, but might be worth a shot
12:23:47 <aetoxx> (Amarok, Rhyhmbox, Clementine, Audacious don't match my expectations. )
12:23:56 <mauke> aetoxx: why not?
12:23:57 <aetoxx> Oh, and Banshee.
12:24:36 <aetoxx> Amarok crashes, Rhythmbox has some crazy import bug, Clementine couldn't be automated in some way, Audacious doesn't support FLAC.
12:24:42 <shapr> Are there any music players written in Haskell?
12:24:54 <aetoxx> Banshee just crashes when it feels like it.
12:24:58 <shapr> I know David Brown at texas.edu was working on a symbolic playlist builder.
12:25:07 <augur> hmm
12:25:09 <mauke> haven't had amarok crash on me but now I'm on rhythmbox
12:25:19 <shapr> I know some music players have python scripting, but do they have HASKELL scripting?
12:25:25 <augur> are there any good haskell libraries for doing simple 3D graphics?
12:25:26 <shapr> That would be awesome :-)
12:25:26 <arcatan> shapr: hmp3? :)
12:25:26 <however> shapr, what is a symbolic playlist builder?
12:25:33 <mauke> amarok used to
12:25:34 <ment> why would anyone want scriptable music player?
12:25:50 <talamon> hmp3 is broken
12:26:00 <mauke> ment: to display the current song / status in the status bar
12:26:12 <shapr> however: It's where you can have a playlist that says "Artist: ABC" and each time the playlist is loaded, all tracks by that artist are loaded.
12:26:13 <Qrt> {-# LANGUAGE BangPatterns #-} <- what is that i had it in an old problem
12:26:18 <ment> mauke: x11amp had a plugin that did that
12:26:19 <Qrt> program
12:26:26 <dmwit> > (1/6) / (1 - 5/6 * 5/6)
12:26:28 <lambdabot>   0.5454545454545455
12:26:30 <mauke> ment: how?
12:26:33 <dmwit> Qrt: That is how you calculate it.
12:26:41 <shapr> however: That is, the playlist does not have a static list of tracks, but instead symbolic representations of which tracks are to be loaded, and the resulting list is recalculated each time.
12:26:43 <mauke> Qrt: a pragma
12:26:56 <however> right, i see
12:27:09 <ment> mauke: on-screen-display library
12:27:27 <mauke> ment: how will that transfer the data into my status bar?
12:27:50 <dmwit> augur: fieldtrip?
12:27:56 <ment> mauke: CORBA? dbus?
12:28:17 <augur> dmwit: ill check it out
12:28:17 <Qrt> dmwit: thanks a lot, but why is the formula like that? P(player1 rolls a 1) / (1 - ? * ?)
12:28:19 <mauke> o_O
12:29:37 <dmwit> Qrt: Let x be the probability of winning. x = P(win right away) + P(tied right away) * P(win at some later time)
12:29:55 <dmwit> So x = P(win right away) + P(tied right away) * x
12:30:01 <however> qrt: the short descriptions are here http://hackage.haskell.org/packages/archive/Cabal/1.10.1.0/doc/html/Language-Haskell-Extension.html they mention the chapters of the user guide where you can get extensive information http://www.haskell.org/ghc/docs/latest/html/users_guide/index.html
12:30:15 <dmwit> That is, x = P(win right away) / (1 - P(tied right away)).
12:31:00 <aetoxx> however, I don't like the concept of a queue; I just want my playlist to play sequentially.
12:31:09 <aetoxx> however, is there a way to turn that off?
12:31:17 <aetoxx> however, otherwise quodlibet seems perfect.
12:32:16 <schlicht> is there an easy way to see how long a function needs to run? to see where the bottle neck is?
12:32:28 <hpaste> qrt pasted “can_this_be_improved?” at http://hpaste.org/71476
12:32:39 <Qrt> i think it is pretty simple and clear now
12:32:39 <however> aetoxx: you don't have to put stuff in the queue. you can just play one track, and i think it will then advance to the next one (according to whatever order)
12:33:56 <cesc> I just compiled a stupid program with ghc:   main = putStrLn "Hello world".    The binary is 849 Kb .  WTF??
12:34:10 <mauke> what about it?
12:34:15 <cesc> are haskell programs so bulky?
12:34:31 <mauke> there's a constant overhead for the RTS and stuff
12:34:54 <however> cesc: haskell has a pretty advanced runtime
12:35:04 <mauke> cesc: does stripping help?
12:35:05 <aetoxx> however, uhm, wth is this? quodlibet@lists.sacredchao.net
12:35:22 <cesc> mauke, I have no idea, I'm still with LYAH :)
12:35:25 <aetoxx> however, it is recording what I play and sending it do this e-mail address?
12:35:29 <aetoxx> this
12:35:39 <aetoxx> to this e-mail address
12:36:11 <Adeon> 849 Kb is not bulky
12:36:18 <however> aetoxx: sorry, i'm not an expert on quodlibet, i just use it every now and then ...
12:36:23 <cesc> Adeon, same with fortran is 5.9 Kb
12:36:35 <mauke> cesc: it's 709K here. after 'strip hello' it's at 455K.
12:36:38 <Adeon> are you targetting an embedded system
12:36:59 <cesc> ah! after strip it took 586 K
12:37:04 <Adeon> if I take a clozure common lisp and ask it to make a hello world program the binary will be tens of megabytes in size
12:37:07 <cesc> still a factor 100 larger than the little fortran thing
12:37:07 <Philippa> Adeon: it's huge for a console Hello World app
12:37:26 <mroman> strip + upx usually does the job.
12:37:31 <mauke> cesc: again, the overhead is constant
12:37:36 <shirt> is there a tutorial for doing dynamic programming in haskell? how do you keep the table of intermediate results?
12:37:46 <mauke> cesc: the factors look better if your programs are bigger
12:37:51 <Philippa> Adeon: many of us remember working on systems that just didn't have that much RAM!
12:37:56 <cesc> mauke, ok. Thx for the tip.
12:38:00 <mauke> shirt: for simple stuff I just use an array
12:38:28 <shapr> cesc: I could offer you a free copy of the Java Runtime Enviroment for extra perspective :-)
12:38:51 <shapr> Might take awhile to download the J2EE version of "Hello World" :-)
12:38:55 <cesc> shapr, please don't :D  I am actually running away from java =D
12:39:08 <shapr> I can understand that.
12:39:13 <Qrt> http://www-users.aston.ac.uk/~konecnym/students/JanDuracz2010-thesis-spark-fp.pdf  //anyone read that?
12:39:21 <cesc> that and trying to understand my xmonad.hs file is the main reason I'm playing a bit with haskell :D
12:39:26 <Philippa> shapr: FWIW, some of my binary sizes bug me rather. My Pandoc-based Wordpress toolchain, say
12:39:32 <Philippa> OTOH, we can do dynamic linking these days too
12:40:32 <aetoxx> ECL compiles hello world to 8KB.
12:41:00 <Adeon> well, figures. it's for embedded
12:41:02 <aetoxx> Suggesting large overhead is not a problem doesn't make it go away.
12:41:03 <shirt> mauke: a regular immutable array?
12:41:25 <mauke> shirt: yes
12:41:35 <aetoxx> Adeon, how is embedded different from e.g. server programming?
12:41:35 <mauke> Philippa: oh, nice
12:41:36 <Adeon> doesn't ECL still have a runtime as a .so
12:41:49 <mauke> dynamic linking got it town to 15K (9.6K after stripping)
12:41:59 <cesc> aetoxx, certainly. But OK, 1 Mb is probably assumable these days (even if it's an overkill for simple programs)
12:42:04 <Adeon> servers have huge amounts of memories and advanced memory systems in general
12:42:08 <Adeon> embedded are small things
12:42:35 <hpaste> mcstar pasted “for qrt, though its faulty” at http://hpaste.org/71477
12:42:48 <aetoxx> Adeon, memory is still quite expensive on servers.
12:43:04 <Adeon> let me revise myself a bit
12:43:04 <aetoxx> Adeon, not the hardware, but the privilege of using it.
12:43:23 <aetoxx> Adeon, you pay by RAM mostly.
12:43:27 <Adeon> servers run on a PC architecture that has a rather advanced memory systems, having caches and virtual memory
12:43:36 <Adeon> many embedded systems don't have such luxuries
12:44:14 <mcstar> the fuck
12:44:27 <mcstar> he times out when i paste something
12:47:15 <shapr> mcstar: what?
12:47:18 <cesc> mcstar, nice lil MC!
12:47:33 <mcstar> shapr: hi, what what?
12:47:45 <cesc> :t what
12:47:47 <lambdabot> Not in scope: `what'
12:47:49 <cesc> :)
12:47:56 <shapr> mcstar: Just wondering what you were swearing about.
12:48:01 <shapr> mcstar: Ah, I see now.
12:48:04 <mcstar> ok
12:49:40 <shapr> aetoxx: Have you tried to run GHC-produced binaries on machines with smaller amounts of memory?
12:51:11 <shapr> I wonder what amount of memory starts to cause consistent swap thrashing?
12:52:20 <zzing_> Does the linking process remove dead code?
12:52:33 <dmwit> shapr: Roughly the amount of RAM in your machine...?
12:52:41 <shapr> dmwit: haha!
12:52:53 <shirt> has anyone ever managed to compile GHC for Xbox 360?
12:53:12 <monochrom> telling me about large executables doesn't make them go away, either
12:53:13 <shapr> I've not heard of that, but I've not looked.
12:53:27 <monochrom> but I heard that jhc produces small executables
12:53:31 <shirt> would be cool do try doing some Xbox 360 Haskell programming
12:53:38 <however> shapr: i'd imagine if you have 1 gb of ram and 2 processes of 501 mb each, you might already get constant thrashing if the processes pathologically keep accessing all their ram for some reason
12:53:43 <monochrom> and hugs produces 0-byte executables
12:54:07 <mcstar> dmwit: can you look at the code i pasted for Qrt? it always gives back 1., though, from the looks of it, i thread the random list correctly
12:54:26 <shapr> however: That's a good point. I was just thinking about how I Want to try GHC on my Raspberry Pi with 256mb of memory, and wondering how well that would work.
12:55:25 <however> shapr: so the raspberry thingy needs to compile code?
12:55:52 <dmwit> mcstar: `mod` 6 is not the right computation.
12:56:05 <mcstar> why?
12:56:05 <dmwit> mcstar: Just use randomRs, it's easier.
12:56:06 <shapr> however: No, I could easily cross-compile from a VM on my desktop, I'm more wondering if GHC binary size will cause problems.
12:56:13 <dmwit> mcstar: Because that results in numbers from 0 to 5. =)
12:56:23 <saep> shapr, in my experience ghc uses a lot more memory than 256mb for larger projects
12:56:33 <mcstar> dmwit: ofc it does
12:56:42 <mcstar> dmwit: i didnt notice the 6
12:56:47 <mcstar> dmwit: omg
12:56:50 <dmwit> mcstar: It's also subtly wrong: it's slightly less uniform than randomRs (0,5).
12:57:00 <mcstar> dmwit: well, Int is really big
12:57:08 <mcstar> so, it doesnt matter much
12:57:15 <dmwit> hm =)
12:58:06 <mcstar> ./qrt
12:58:08 <mcstar> Games played: 100000
12:58:10 <mcstar> Results: 0.54464
12:58:12 <mcstar> better
13:03:12 <zzing_> On the wiki there is aline that says "(There is a switch to make GHC spit out a separate object file for each individual function in a module."   what is this option?
13:04:06 <Qrt> RandomRIO is wrong?
13:04:10 <monochrom> if you really hate ghc large executables, you should use ocaml
13:04:16 <dmwit> Qrt: randomRIO is fine.
13:04:34 <heatsink> -split-objs
13:04:48 <heatsink> zzing_, -split-objs
13:05:17 <hpaste> mcstar annotated “for qrt, though its faulty” with “looks better, Qrt” at http://hpaste.org/71477#a71478
13:05:42 <mcstar> Qrt: look at the annotated version, it starts to look managable
13:06:06 <Qrt> i was disconnected
13:06:06 <Qrt> what is the difference betweeen Int and Integr? Integer and long?
13:06:06 <Qrt> dmwit: not perfectly uniform?
13:06:33 <dmwit> Qrt: I was talking about mcstar's broken answer.
13:07:18 <dmwit> Also I think his suggested "improvement" looks horrible compared to what could be done.
13:07:21 <dmwit> =P
13:07:24 <nus> @src Int
13:07:25 <lambdabot> data Int = I# Int#
13:07:27 <nus> @src Integer
13:07:27 <lambdabot> data Integer = S# Int#
13:07:27 <lambdabot>              | J# Int# ByteArray#
13:07:55 <hpaste> qrt pasted “can_this_be_improved?” at http://hpaste.org/71479
13:07:58 <Qrt> i think that looks pretty good
13:08:11 <mcstar> dmwit: im listening
13:08:25 <Qrt> short and clear
13:09:38 <heatsink> raaar!  Plural noun incorrectly used in place of singular noun!
13:09:44 * heatsink has a pet peeve
13:10:19 <heatsink> The variable name should be "die"
13:10:51 <dmwit> mcstar: play p = randomRIO (1,6) >>= \die -> case (p, die) of (Player1, 1) -> return 1; (Player2, 6) -> return 0; _ -> play (notp p)
13:10:52 <mcstar> idk, both ok
13:10:57 <dmwit> mcstar: as I suggested above =)
13:11:05 <mcstar> ill study it
13:11:38 <Qrt> one die, several dice? not one dice several dices?
13:12:27 <heatsink> Qrt, "die" is singular, "dice" is plural.
13:12:43 <adimit> similar to mouse and mice
13:12:53 <mcstar> mie and mice
13:13:00 <mauke> meeces
13:13:02 <frerich_> :-)
13:13:22 <mcstar> in the dict im looking at, dice can be singular
13:13:37 <mcstar> but, im not a native american, so i can be stupid
13:13:44 <mcstar> (pun intended)
13:14:23 <frerich_> I also thought it's die (p)/dice(s) but according to http://www.merriam-webster.com/dictionary/dice dice can be singular, too...
13:14:54 <heatsink> My dictionary has this usage note: Historically, dice is the plural of die, but in modern standard English, dice is both the singular and the plural
13:15:35 <heatsink> "one dice" sounds wrong to me, regardless
13:15:42 <mcstar> dice is good, cause you cant make the mistake of thinking of an ink
13:16:11 <mcstar> also, do you like diced meat?
13:16:25 <frerich_> I could die for diced meat!
13:16:47 <saml> dice  and dices
13:17:17 * nand` learned ‘die’ and ‘dice’ and that's what seems natural
13:17:32 <mroman> Yes.
13:17:41 <mauke> lie and lice
13:17:55 <mauke> trie and trice
13:17:55 <heatsink> rye and rice
13:17:57 <mroman> Because it's natural to go to a casino and scream "die!" all around with the security guards in the back ;)
13:18:19 <Qrt> mauke: at least when you pronounce it is corrrect :)
13:19:25 <zzing_> mroman, just go into a casino and scream "Hello Everybody, I love you all!" in Arabic.
13:19:27 <mcstar> die Wurfel is a clear mistake though
13:19:55 <mauke> yeah. it should be Würfel
13:20:06 <mroman> Can I substitue arabic with japanese?
13:20:07 <mcstar> der
13:20:12 <mroman> *substitute.
13:20:15 <however> de Würfels
13:20:37 <mcstar> mroman: wont taste the same
13:20:40 <mcstar> i'd rather not
13:20:41 <nand`> mroman: only if you use ‘kisama’, beacuse that's the most awesome sounding pronoun
13:21:38 <mroman> I wouldn't know any pronoun 'kisama'
13:21:49 <mroman> There certainly is 'sama'.
13:22:05 <saml> I and Ice
13:22:19 <heatsink> Ine.
13:22:47 <heatsink> http://en.wiktionary.org/wiki/eyne
13:22:52 <mcstar> who is a cool japanese hacker?
13:22:59 <mcstar> i give a hint: Ishikawa
13:23:38 <nand`> mroman: that's a honorific, not a pronoun and see https://en.wikipedia.org/wiki/Japanese_pronouns for “kisama” (and others)
13:23:56 <mroman> Yeah, I found it in the dictionary under 貴様
13:23:57 <mauke> mcstar: the laughing man
13:25:33 <mcstar> damn
13:25:40 <mcstar> i cant remember the end of the quote
13:26:07 <aetoxx> shapr, I think GHC does not work well for large data structures.
13:26:09 <mcstar> you know, what was found on the locker door in the institute
13:26:15 <shapr> aetoxx: How so?
13:26:30 <aetoxx> shapr, large being >0.5GB for a single data structure or so.
13:26:50 <shapr> aetoxx: I disagree, I've had much larger mbox files loaded into memory for searching.
13:27:08 <aetoxx> shapr, that's not a data structure.
13:27:09 <mauke> mcstar: "or should I?"?
13:27:12 <aetoxx> shapr, that's just data.
13:27:15 <mcstar> ahhh
13:27:18 <mcstar> mauke: thats it
13:27:36 <shapr> aetoxx: It was when I split into an internal mbox datatype, but I would be interested in seeing profiling data or something.
13:27:38 <mcstar> i thought what id do was id pretend, i was one of those deaf mutes.... or should i
13:27:58 <shapr> aetoxx: Have you had problems with 500mb or larger data structures?
13:28:01 <aetoxx> shapr, 90% of the time was spent in GC or so.
13:28:03 <solrize> aetox i've had data.maps that big?
13:28:21 <shapr> aetoxx: That sounds interesting, do you have the source code handy?
13:28:36 <Qrt> how large is large?
13:28:37 <Philippa> it's not impossible if you're careless with boxing etc to think a structure should be 500MB and find out it's the wrong side of 4GB
13:28:59 <shapr> aetoxx: I just read tibbe's optimization tutorial slides and I wonder if they might help?
13:29:03 <aetoxx> shapr, when you work close to your physical memory limit, GC suddently needs no traverse the heap the whole time.
13:29:08 <Qrt> http://www-users.aston.ac.uk/~konecnym/students/JanDuracz2010-thesis-spark-fp.pdf  //anyone read that?
13:29:13 <solrize> the access pattern could also be pretty bad wrt caching
13:29:18 <aetoxx> shapr, needs to*
13:29:34 <aetoxx> shapr, the whole generational garbage collection theory goes right to hell.
13:29:36 <monochrom> I commend tibbe's presentation
13:29:38 <shapr> aetoxx: Have you seen http://johantibell.com/files/haskell-performance-patterns.html#%281%29 ?
13:29:57 <aetoxx> shapr, are those percentage signs part of it?
13:30:13 <monochrom> of course, for merely the asymptotic story, I commend my own http://www.vex.net/~trebla/haskell/lazy.xhtml :)
13:30:19 <shapr> aetoxx: Yes, those are url encoded parentheses.
13:30:33 <Philippa> aetoxx: have you played with the RTS configuration parameters? You might find some of them useful
13:30:54 <Philippa> they're configurable per-run, too
13:31:21 <shapr> aetoxx: It's been my experience that every approach to memory management has downsides, and small changes in source code can often make GHC binaries handle GC much more easily.
13:31:41 <shapr> As Johan's presentation shows.
13:32:02 <aetoxx> Philippa, yes, I did.
13:32:07 <mcstar> dmwit: it really looks better
13:32:30 <aetoxx> shapr, it's not so much GHC specifically as it is garbage collection in general.
13:33:02 <aetoxx> shapr, you have to imagine that the assumptions for a major-minor heap system don't always hold.
13:33:07 <shapr> aetoxx: How so?
13:33:16 <mcstar> dmwit: what if, i wanted to remove IO, and use a list like i did before
13:33:45 <aetoxx> shapr, because you might simply be needing a lot of memory and only delete a small subset of the data all the time.
13:33:49 <mcstar> dmwit: nvm, i could rewrite mine to be closer to yours
13:34:04 <shapr> aetoxx: Sure, like I said.. every approach to memory management has downsides.
13:34:04 <Philippa> aetoxx: that's /exactly/ what that system is intended for
13:34:56 <aetoxx> shapr, So, let's say you have some data structure X which takes 95% of memory already. Then you need to add a few more percent, but then the GC finds it doesn't have enough memory, so it traverses some massive structure to discover it can free just enough, and repeat that.
13:34:58 <Philippa> the small subset/new data goes in the nursery and gets cleared up in minor
13:35:05 <shapr> aetoxx: If you have some code that doesn't deal well with GC, it would be interesting to apply Johan Tibbell's optimizations to the source and see if things improve.
13:35:39 <Philippa> what you might need to do, though, is rearrange the data structures a bit so that it's clearer what's dying
13:35:45 <aetoxx> shapr, adding more memory would likely help, but in the end you kill productivity.
13:35:58 <aetoxx> shapr, productivity as in the CPU doing something useful.
13:36:31 <Philippa> terrible secret of GCed languages: you can always find ways to manage manually if you're that desperate
13:37:03 <Taneb> I like baseless-assertion 0.1
13:37:03 <aetoxx> Philippa, well, the GC has all kinds of assumptions that don't hold anymore for mutable code.
13:37:14 <aetoxx> Philippa, so, little secret: it's not that simple.
13:37:27 <Philippa> true. Would they hold if you used a zipper, or if you made use of weak references?
13:37:32 <aetoxx> Philippa, the only way to be sure is to completely remove all allocations in some piece of code.
13:37:54 <Philippa> as I said: you can always find ways to manage manually if you're that desperate
13:38:13 <aetoxx> Philippa, at that point using Haskell is not an advantage anymore.
13:38:20 <zzing_> Is there a reason why -rtsopts -with-rtsopts=-N  would slow down a webserver by 20 times? (0.4 ms/req to 10ms/req)
13:38:34 <however> taneb: *giggle* that's nice
13:38:48 <Philippa> aetoxx: YMMV, myself I don't find GC to be the only advantage Haskell brings over C
13:38:50 <Taneb> oh dear he's laughing at me
13:38:52 <Taneb> aaah
13:39:07 <aetoxx> Philippa, GHC is good for stream algorithms.
13:39:18 <aetoxx> Philippa, there you have these short lived allocations.
13:39:19 <hpaste> mcstar annotated “for qrt, though its faulty” with “qrt dmwit” at http://hpaste.org/71477#a71480
13:39:29 <zzing_> Why would somebody want GC in something like C?
13:39:31 <Philippa> aetoxx: you know what a spine is, right?
13:39:39 <aetoxx> Philippa, which is a slightly larger set of computations than what GPUs do.
13:39:43 <aetoxx> Philippa, yes
13:40:00 <Philippa> so: why can't you keep the spine in the "short-lived" category, as would happen with eg a zipper?
13:40:21 <aetoxx> Philippa, because it doesn't live shortly.
13:40:29 <Philippa> it does if you're changing anything
13:40:29 <aetoxx> Philippa, it lives on for hours.
13:40:55 <however> zzing_: i'm not sure what -N does on its own. i thought you had to give it the number of cpu cores or something. i could be wrong, though
13:41:01 <aetoxx> Philippa, with no way to statically know in advance whether any individual piece will be there the next few ms.
13:41:06 <Philippa> you're complaining that working mutably is costing you piles in GC time, right?
13:41:07 <monochrom> I would want GC in something like C. here is why: I actually don't want something like C. :)
13:41:20 <Philippa> so work immutably. Then you're only paying a log cost on updates
13:41:27 <mcstar> C has half a GC already
13:41:33 <mcstar> not much work to add the other half
13:41:42 <aetoxx> Philippa, I am saying that both alternatives are not good.
13:41:48 <aetoxx> Philippa, which is why ATS was invented.
13:42:07 <aetoxx> Philippa, or perhaps that wasn't the reason, but it is certainly a solution.
13:42:12 <Philippa> you might be saying that now, you've taken a long time getting there
13:42:17 <mcstar> ats features some really terrible shootout programs
13:42:19 <shapr> aetoxx: If you have problems with the behavior of source code that would let us have a more specific discussion.
13:42:27 <mcstar> the guy went to the extreme to compete with c
13:42:30 <Philippa> yes, sometimes you really do care about sufficiently manual memory management and sometimes that suggests another language
13:42:35 <shapr> As in, something specific rather than hand-waving generalities.
13:42:43 <zzing_> however, it looks like number of cpu cores, or automatic
13:42:56 <aetoxx> shapr, I think anyone knowing anything about GC would understand the problem and the nature of their assumptions.
13:43:05 <shapr> aetoxx: But I do agree that every approach to memory management has downsides.
13:43:07 <Philippa> you appear to not have understood the interaction between zippers and the GC, however
13:43:18 <aetoxx> Philippa, I don't see how zippers are relevant.
13:43:19 <zzing_> mcstar, what kind of GC do you mean? I love the way C++ handles the problem
13:43:25 <Philippa> aetoxx: that's what I just said, yes
13:43:30 <aetoxx> Philippa, because in particular not every program uses zippers.
13:43:39 <aetoxx> Philippa, nor are they applicable everywhere.
13:43:43 <mcstar> zzing_: C has the C from GC, got it?
13:43:47 <aetoxx> Philippa, have you ever implemented zippers?
13:43:54 <Philippa> aetoxx: yep
13:43:55 <aetoxx> Philippa, I have.
13:43:58 <monochrom> hahaha now i get it :)
13:44:01 <zzing_> mcstar, … so bad
13:44:07 <frerich_> mcstar: ouch...
13:44:16 <mcstar> sorry guys
13:44:16 <Philippa> got anything to add to that beyond an attempted argument from authority?
13:44:33 <monochrom> no, mcstar, it's ok, I like it!
13:44:37 <merijn> monochrom: That's why people invented Go, right? (i.e. they wanted C, but didn't want C :p)
13:44:42 <aetoxx> Philippa, like I said: it is completely irrelevant.
13:44:51 <Philippa> aetoxx: [citation needed]
13:44:56 <monochrom> yeah I think so
13:45:03 <shapr> aetoxx: It sounds to me like your point is that garbage collection has some downsides, is that correct?
13:45:14 <Philippa> any, *any* mutable problem can be encoded with zippers, at logarithmic cost
13:45:43 <zzing_> eek go
13:45:43 <aetoxx> Philippa, there are ways to do it even cheaper than that.
13:45:55 <merijn> monochrom: In fact, despite people in here yelling at me I rather like Go as "C that isn't C"
13:46:07 <aetoxx> Philippa, you aren't really telling anything new.
13:46:11 <Philippa> aetoxx: like with mutation, yes. You've still not shown irrelevance, given that we're discussing GC behaviour
13:46:20 <aetoxx> Philippa, in fact, you are about 40 years behind the state of the art.
13:46:22 <zzing_> merijn, my objcetion to go - it forces { on the same line instead of allowing it where ever the hell you want :P
13:46:27 <shapr> aetoxx: Be nice dude.
13:46:34 <aetoxx> Philippa, but you are free to read the research on that yourself.
13:46:41 <monochrom> I think the complaint about Go is that it doesn't go the full Algol60 way
13:46:42 <merijn> zzing_: That's a feature, 1TBS!
13:46:42 <zzing_> By the way speaking of zippers, is that the same as the zip functions and if so where can I learn more about this, I cannot even think what they are used for
13:46:44 <carter> aetoxx: Philippa : strictly speaking, anything that lacks the software logarithmic cost still has has it in the hardware :)
13:47:01 <Philippa> aetoxx: *shockface* yeah, sorry, I suspect you have no idea what I do and don't know about the current state of the art
13:47:04 <aetoxx> carter, that's unfortunately not how it works.
13:47:04 <carter> its just "constant"
13:47:05 <zzing_> merijn, that is what they keep saying, but it is just one more thing in a long line of wierd shit
13:47:11 <zzing_> C++ does it all better anyways
13:47:15 <carter> aetoxx link please
13:47:18 <shapr> Philippa: C'mon, ad hominen isn't going to help.
13:47:23 <merijn> zzing_: No, zippers aren't (as far as I can tell) related to zip, other than that both are associated with the working of a physical zipper
13:47:27 <Philippa> (also, zippers for arbitrary algebraic datatypes are not 40 years old)
13:47:36 <zzing_> ok, I need to learn about the zip stuff then
13:48:00 <Philippa> shapr: you mean like someone saying I'm 40 years behind the state of the art without actually knowing the contents of my mind? You're right, it doesn't
13:48:02 <merijn> zzing_: They're pretty nifty, they allow (for example) forward and backward traversal of lists/trees, that sorta thing
13:48:11 <shapr> Philippa: Yes, exactly that.. thus my warning to aetoxx
13:48:21 <aetoxx> Philippa, shocker, data structure design doesn't care about the language features of certain programming languages.
13:48:33 <shapr> Philippa: But I was also requesting that you do not descend to using the same tactigs.
13:48:49 <shapr> tactics*
13:48:56 <aetoxx> Philippa, please read the original zipper paper.
13:49:12 <aetoxx> Philippa, it says specifically that it is 'part of the folklore'.
13:49:19 <shapr> aetoxx: I don't think you're listening, and I don't think you've made a coherent point either.
13:49:21 <Philippa> yes, as applied to lists
13:49:35 <aetoxx> Philippa, no, not only as applied to lists.
13:49:50 <Philippa> the recipe for general zippers? That's comparatively modern
13:50:02 <aetoxx> No, it isn't.
13:50:02 <Philippa> that *wasn't* folklore when McBride published it
13:50:04 <shapr> Happily, I have some actual Haskell code to write!
13:50:08 * shapr boings cheerfully
13:50:12 <aetoxx> Philippa, lol
13:50:37 <shapr> So I don't have to discuss whether generational GC is worthwhile or not, I can demonstrate by writing useful code that uses it.
13:50:40 <Philippa> but hey, perhaps you'd like to show me some further evidence?
13:50:43 <aetoxx> Philippa, anyway, good luck believing that functional programming people have ever contributed anything to datastructure design.
13:50:59 <mauke> lol wut
13:50:59 <Philippa> aetoxx: Chris Okasaki would like a word with you
13:51:02 <however> aetoxx: insulting people will not help whatever point you're making. people will get pissed off and just write off what you said entirely
13:51:10 <aetoxx> Philippa, and he would tell me I am right.
13:51:23 <shapr> aetoxx: insulting people can lead to you being banned from this channel.
13:51:39 <Philippa> that's most interesting: has he voiced that anywhere I could see it?
13:51:51 <aetoxx> shapr, in that case good bye for now.
13:52:07 * shapr shrugs
13:52:30 <And[y]> well that was ... funny xD
13:52:37 <mcstar> he had a point
13:52:37 <shapr> I still don't understand his point... was it that FP never did anything for data structure design, or was is that generational GC is a bad thing?
13:52:39 <Philippa> whether generational GC is useful at all was never subject of discussion to start with, shapr
13:52:42 <mcstar> i think i switch to llvm
13:52:45 <shapr> mcstar: What was his point? I missed it :-(
13:52:51 <shapr> Philippa: Ok, what was it?
13:53:14 <shapr> That's what I get for trying to write code and have a conversation at the same time.
13:53:23 <mcstar> shapr: and you guys failed to mention, how functional data structures can exploit multiple cores
13:53:24 <Philippa> it was mostly "look at me, I had a bad experience doing something I know is stupid anyway" coupled with "and there are other languages in which I have access to better memory management". Big deal
13:53:26 <monochrom> Philippa, the advantage of claiming "it's folklore" is that, by definition, no citation is required as evidence. (I don't know what kind of evidence is required, then.)
13:53:40 <Philippa> monochrom: heh, that depends what field you're in
13:53:50 <shapr> mcstar: I still didn't see his actual point.
13:53:58 <mauke> how do you define "functional programming people"?
13:54:06 <Philippa> in the humanities, you'd be expected to find a shred of evidence of it lying around somewhere - a mailing list post here, for example
13:54:23 * shapr shrugs
13:54:33 <Philippa> it just wouldn't have to be academically publishable
13:54:35 <monochrom> true
13:54:39 <carter> mauke: if i have my way, every small sophisticated tech company  in nyc will have haskell in their code base by the end of next spring :)
13:54:52 <shapr> So... does anyone know if hlint could be extended to suggest strictifying data types?
13:55:04 <shapr> carter: Sounds awesome! What are you doing?
13:55:12 <carter> hrmm
13:55:37 <frerich_> shapr: It seemed to me that having hlint detect incorrect singular/plural forms of nouns in identifiers is an even more popular feature request. :-)
13:56:37 <however> Philippa: i'm with you. i wouldn't put too much weight on what that aetoxx guy says. when he was on a few days ago, he was even more abrasive and difficult
13:56:51 <Philippa> oh, I'm not exactly worried about it
13:57:04 <Philippa> I'm just inclined to deal with anything remotely resembling technical merit in someone's arguments
13:57:10 <carter> shapr : check your message window
13:57:21 <mcstar> ohh, thats the aetoxxx
13:57:26 <mcstar> the same *
13:57:28 <Philippa> as I said, using zippers instead of raw mutability changes GC behaviour
13:57:54 <carter> Philippa what was the original GC thing about with zippers?
13:58:04 <carter> i came into the flame / etc bit a tad late
13:58:30 <Philippa> the whole spat was nominally about generational GC and datasets close to your max heap size
13:58:37 <carter> ahh
13:58:53 <carter> and what was original bit about?
13:58:55 <carter> wrt that
13:58:57 <however> carter: really, he didn't seem to have any coherent point. he had some unspecified problem with gc not performing adequately, possibly under ram-almost-full conditions
13:59:27 <Philippa> carter: if you write carelessly, GC behaves badly in those circumstances. Which is a well-known general problem
13:59:30 <Saizan> if you have a large unchanging e.g. Data.Map (or more likely something more compact), it will still be scanned every major GC though, right?
13:59:36 <carter> got it
13:59:40 <however> carter: the rest seemed to be fluff and eventually descended into a rant, after which he imploded
13:59:46 <carter> yeah
13:59:49 <carter> i could see that end bit
13:59:58 <carter> high memory pressue is generally problematic
14:02:15 <chris_> bye
14:02:25 <shapr> chris_: leaving us so soon?
14:03:49 <zxspectrum> @djinn Monad m => (a -> (b -> m c) -> m c) -> [a] -> ([b] -> m c) -> m c
14:03:49 <lambdabot> Error: Undefined type []
14:04:26 <zxspectrum> any ideas? it looks like a fold to me
14:05:57 <augur> zxspectrum: what?
14:06:00 <augur> what are you trying to do now
14:06:15 <zxspectrum> I'm trying to find that function
14:06:24 <augur> er
14:06:37 <augur> well the first argument is supposed to be a wrapped up function a -> b
14:06:45 <augur> namely, given f :: a -> b
14:07:10 <augur> \a g -> g (f a) : a -> (b -> m c) -> m c
14:07:45 <augur> the second one is mostly the same but uses map instead of straight application
14:07:54 <augur> hmm.
14:07:56 <zxspectrum> I have a function of type a -> (b -> m c) -> m c and I want to apply it to a list of values with a function that accepts a list
14:08:15 <augur> im surprised djinn didnt work
14:08:19 <augur> whats up with djinn there
14:08:28 <augur> @djinn (a -> b) -> [a] -> [b]
14:08:28 <lambdabot> Error: Undefined type []
14:08:41 <augur> @djinn a -> a
14:08:41 <lambdabot> f a = a
14:08:42 <nand`> djinn doesn't know about []
14:08:43 <augur> hmm
14:08:47 <monochrom> djinn doesn't do any recursive type
14:08:48 <augur> who fucked up djinn
14:08:57 <mcstar> @djinn (a -> b) -> f a -> f b
14:08:57 <lambdabot> -- f cannot be realized.
14:08:57 <monochrom> decidability did
14:09:07 <augur> monochrom: hm.
14:09:17 <augur> zxspectrum: lets try to work this out by hand!
14:09:24 <zxspectrum> the djinn examples online use []
14:09:33 <EmilyS> hmm, just starting out learning haskell but I think I am doing something a little inefficient here
14:09:54 <mcstar> EmilyS: it is always efficient to ask here
14:10:13 <EmilyS> I want a list of all possible prime candidates, so [x | x<- [3..], x `mod` 2 > 0] etc
14:10:23 <EmilyS> however, you can define the candidates better
14:10:50 <monochrom> the most efficient ways begin by giving up on div and mod
14:10:58 <EmilyS> yup
14:11:38 <monochrom> at the entry level, you go back to mutable array and do the sieving
14:12:00 <monochrom> at the advanced level, you replace the mutable array by a pure functional data structure
14:13:36 <EmilyS> if x is 3, then [x,x+4,x+4,x+2] will be the next candidates, and you can keep going up like that easily
14:13:39 <zxspectrum> augur, the best I have is h g (x:xs) f ys = g $ h xs . (:ys).      h _ [] f ys = f ys
14:13:50 <EmilyS> but I dont have the vocabulary to write that
14:14:02 <monochrom> http://hackage.haskell.org/package/NumberSieves/ has the complete advanced story
14:14:07 <zxspectrum> with an extra parameter (ys :: [b])
14:14:42 <monochrom> another one is http://hackage.haskell.org/package/primes
14:14:55 <EmilyS> I'm trying to learn :)
14:14:58 <duckdouche> wut else hav u guys tryd doin with haskel
14:15:34 <zxspectrum> I forgot an arg in there... h g (x:xs) f ys = g $ h g xs . (:ys)
14:16:20 <augur> hmm
14:16:52 <augur> zxspectrum: where is this from?
14:17:18 <zxspectrum> which part?
14:17:21 <augur> the type
14:18:34 <zxspectrum> I have a library function of type a -> (b -> m c) -> m c that I am trying to apply to a list of a with an action that takes a list of b
14:18:59 <augur> no i mean
14:19:02 <augur> whats the bigger picture
14:20:07 <zxspectrum> I'm not sure what you're asking
14:20:15 <augur> you're not just doing this for shits and giggles
14:20:17 <augur> its for a purpose
14:20:31 <augur> whats this supposed to do, whats the bigger picture
14:21:50 <zxspectrum> the function is specifically to allocate a color from a name
14:22:27 <augur> er.. ok.
14:22:48 <augur> i cant really see how that has anything to do with this type, but ok.
14:22:54 <nand`> uhm
14:23:06 <nand`> EmilyS: x `mod` 2 > 0 -- is only true for odd integers, yes?
14:23:35 <zxspectrum> but it only handles one color. I want to do a list of them at once instead of writing it out 10 times
14:23:36 <nand`> if so, since the distance between them is constant, you can just use [3,5..]
14:23:54 <nand`> to replace your entire list comprehension
14:23:57 <augur> zxspectrum: ok. and why do you think thats the right type for this thing
14:25:12 <nand`> zxspectrum: the best I've managed to match your type is with [m c] at the end, alternatively m [c] if you use sequence
14:25:34 <augur> thats why im wondering why he thinks this is the right type
14:25:53 <zxspectrum> withColor ... (\c1 -> withColor ... (\c2 -> withColor (\c3 -> f [c1:c2:c3]))) really sucks
14:25:53 <zxspectrum> that's the only type it can be as far as I can tell
14:26:12 <zxspectrum> oh, I didn't even notice that
14:26:15 <ninegrid> can you use `where' in a lambda?
14:26:29 <augur> zxspectrum: what is the surrounding program
14:26:35 <augur> post something on hpaste
14:26:42 <augur> because i cant see what it is you're trying to do
14:27:20 <zxspectrum> I can't paste atm, I'm on a phone :/
14:27:50 <zxspectrum> m [c] looks like the right one
14:28:22 <gensymv> hello, i am trying to understand the way haskell arrays play together with higher order functions like fold: assume I have an array a = [(i, 0) | i <- [0..n]], I make a call of the kind "foldl (\y x -> y//[(x, y!x +1]) a xs", which should count the number of occurences of each element in the list and write it on a. foldl does the thing it is supposed to do however, the values are not written in a (which puzzles me, because that is the d
14:28:22 <gensymv> efault behaviour in SML). Is a new array being initialized at every iteration of foldl?
14:28:30 <augur> zxspectrum: dont judge based on looks
14:28:34 <nand`> :t \f x g -> sequence . map ($ (g . return)) $ map f x
14:28:36 <gensymv> *recursion not iteration
14:28:36 <lambdabot> forall (m :: * -> *) a b a1 (m1 :: * -> *) a2. (Monad m, Monad m1) => (a2 -> (a1 -> b) -> m a) -> [a2] -> (m1 a1 -> b) -> m [a]
14:28:37 <augur> zxspectrum: figure out what you need
14:29:39 <zxspectrum> actually, no, it's a bit strange
14:31:45 <byorgey> gensymv: it works for me.
14:31:54 <byorgey> gensymv: note that a itself will not be modified.
14:31:54 <gensymv> byorgey: with side effects?
14:32:03 <byorgey> gensymv: Haskell does not have side effects.
14:32:45 <zxspectrum> I think I made a type association that doesn't make sense
14:32:48 <gensymv> byorgey: hm, this means that the array is being initialized new at every recursion ?
14:33:52 <obiwahn> how do i load modules for lamdabot like seen?
14:35:43 <however> gensymv: the original list is not changed (in other words, haskell doesn't have side-effects). a new list is built, and foldl in the end gives you that new list
14:37:12 <byorgey> gensymv: yes, it is.
14:37:30 <byorgey> gensymv: what you have written is not a very idiomatic way to accumulate things into an array.
14:37:53 <byorgey> gensymv: try using something like the  accumArray function instead.
14:38:03 <gensymv> thanks.
14:38:40 <byorgey> see http://hackage.haskell.org/packages/archive/array/latest/doc/html/Data-Array-IArray.html
14:38:58 <obiwahn> ?help tell
14:38:58 <lambdabot> tell <nick> <message>. When <nick> shows activity, tell them <message>.
14:39:12 <byorgey> gensymv: you may also find the documentation for (//) interesting.
14:39:42 <however> gensymv: be advised that arrays are available in haskell, but used much less than (say) in c or java. what haskell uses very much is lists, which have convenient built-in synax
14:39:46 <however> *syntax
14:39:54 <obiwahn> ?babel de en rucksack
14:39:54 <lambdabot> Plugin `babel' failed with: Prelude.head: empty list
14:39:54 <gensymv> byorgev: Thanks.
14:40:26 <however> obiwahn: backpack :) and lambdabot is also available in private chats
14:40:40 <Qrt> say youre writing a game, like an old school 2d space shooter. you have an airplane and you want stuff like life=100, ammo=60, etc. youd use a record for that? like data Aeroplane = Aeroplane {life ::Int, ammo::Int } ?
14:41:05 <gensymv> however: I was trying to implement counting sort, where I need O(1) access for efficiency, I don't think that could be implemented with lists.
14:41:12 <Qrt> what is the preferred webapp-package for haskell?
14:41:22 <gensymv> One more question: Does Haskell support references  like ML does?
14:42:04 <gensymv> nvm. Just found it.
14:42:08 <tdammers> Qrt: the most popular ones seem to be yesod, snap, and happstack
14:42:16 <however> gensymv: ok that's fine if you considered lists and deliberately rejected them :) just wanted you to be aware
14:42:29 <tdammers> there's also a bunch of more low-level HTTP and networking libraries
14:43:12 <obiwahn> ?seen mic
14:43:13 <lambdabot> Unknown command, try @list
14:43:23 <obiwahn> sorry wrong channel
14:44:00 <gensymv> however: thanks anyways! I am amazed how helpful the Haskell community is.
14:45:12 <zxspectrum> nand/augur, thanks, I've obviously got something else going on here
14:45:40 <faidoc> Hi, anyone knows a good Haskell  book  for beginners to recommend?
14:45:49 <Qrt> tdammers: which one do you think is better?
14:46:22 <tdammers> Qrt: they all look pretty damn good. Matter of taste, really.
14:46:24 <however> gensymv: we're friendly because that means more people come in here, and we a lot of them for ritual sacrifice :)
14:46:40 <however> faidoc: welcome to haskell. check out this book, which is available free of charge
14:46:43 <however> @where lyah
14:46:44 <lambdabot> http://www.learnyouahaskell.com/
14:46:45 <tdammers> Yesod is pretty heavy, but also the most feature-rich, I think
14:47:15 <SoupEvil> i start with yesod too, recently
14:47:26 <SoupEvil> really nice framework
14:47:41 <tdammers> personally, I like happstack best
14:48:09 <tdammers> yesod, for my taste, comes with too much of a philosophy, but that's just me
14:48:17 <tdammers> it's a great piece of software otherwise
14:48:52 <shapr> tdammers: I'm using scotty so far, it does less but is easier for getting started.
14:49:09 <SoupEvil> didnt try happstack and snap, i had to focus on one framework :/
14:49:41 <tdammers> I tried those three; happstack just felt the most natural
14:50:03 <faidoc> however: thanks
14:50:09 <SoupEvil> i like the handler and restful style in yesod
14:50:12 <shapr> I've tried snap, yesod, happstack and scotty. I like them all, but I ended up using scotty.
14:50:20 <tdammers> I might look into scotty
14:51:33 <SoupEvil> maybe i will tryout these other frameworks soon, got some sparetime... and to much on my wish list
14:51:46 <Qrt> is there a SOAP lib in haskell?
14:51:56 <shapr> There's also #haskell-web, and #yesod and #happstack irc channels...
14:52:03 <shapr> I don't know if snap has its own irc channel or not.
14:52:19 <Qrt> how big is hackage-package-list?
14:52:37 <shapr> Do you mean, how many packages are on hackage?
14:53:02 <Taneb> Snap does not appear to have its own channel?
14:53:06 <Qrt> the download of cabal update, how big is it(im on mobile limited internet)
14:53:08 <shapr> Taneb: I don't know?
14:53:25 <Taneb> That was a question mark of wavering uncertainty
14:53:28 <Taneb> :(
14:53:33 <Azel> I don't know perfectly hackage, but I don't think there is a SOAP library
14:53:33 <Qrt> happstack is only qrt, yesod is a lot of people
14:53:54 <however> qrt: i think cabal update downloads mainly that file "00-index.tar.gz". it's somewhere in ~/.cabal/ . have a look how big it is
14:56:49 <SoupEvil> http://holumbus.fh-wedel.de/hayoo/hayoo.html#0:soap
14:56:55 <SoupEvil> not much :/
14:58:11 <zxspectrum> I have a working function with one extra parameter for storing the built-up argument list, but it matches the original type signature that didn't seem to make sense
14:59:20 <zxspectrum> h :: forall t c a. (t -> (a -> c) -> c) -> [t] -> ([a] -> c) -> [a] -> c
15:00:32 <zxspectrum> h g (x:xs) f ys = g x $ h g xs f . (:ys)             h g [] f ys = f ys
15:01:08 <zxspectrum> and that makes the original function: soln g xs f = h g xs f []
15:02:39 <obiwahn> how do i teach vixen stuff i can not read it from the code:(
15:03:05 <zxspectrum> does that make sense augur?
15:03:53 <shapr> obiwahn: You need to come up with new regular expressions to match with results.
15:04:17 <obiwahn> shapr: could you give me an example
15:04:27 <shapr> Hm, I haven't looked at the code recently....
15:08:33 <carlos> Need some help.
15:08:37 <donri> guys it's #snapframework FWIW
15:09:00 <mauke> carlos: with getting out of this dessert? </bad-joke>
15:09:36 <Qrt> to get from hackage it is cabal install <package> right?
15:09:46 <donri> Qrt: plenty of people using happstack. just more of them taking it for granted; yesod is the "hot new thing"
15:09:49 <mauke> Qrt: yes
15:10:00 <carlos> Does anyone know how to access a https server e get the html file?
15:10:31 <saml> in haskell?
15:10:36 <carlos> yes
15:10:50 <donri> perhaps http-conduit
15:11:02 <donri> there's also curl, but it tends to segfault
15:11:12 <carlos> Just could not get the way.
15:11:30 <carlos> Can anyone tell about some tutorial?
15:12:14 <carlos> Some examples of how to use conduit?
15:12:18 <saml> maybe this?  http://hackage.haskell.org/package/tls
15:13:14 <carlos> Reading...
15:14:01 <donri> http://hackage.haskell.org/packages/archive/http-conduit/1.5.0.3/doc/html/Network-HTTP-Conduit.html  not good enough?
15:14:22 <shapr> donri: No, snap is the hot new thing, er, I mean.. Scotty is the hot new thing! Oh wait, I think I heard about a new one five minutes ago...
15:14:24 <Qrt> damn we should rewrite emacs in haskell
15:14:52 <ClaudiusMaximus> > let with f = do{ (x:xs) <- get ; put xs ; tell ">" ; r <- f x ; tell "<" ; put (x:xs) ; return r } ; withs 0 f = f [] ; withs n f = with $ \x -> withs (n - 1) $ \xs -> f (x : xs)   in   runWriterT $ flip evalStateT ['A'..] $ withs 26 $ return
15:14:54 <lambdabot>   No instance for (GHC.Show.Show
15:14:54 <lambdabot>                     (m ([GHC.Types.Char], [G...
15:14:56 <ClaudiusMaximus> ("ABCDEFGHIJKLMNOPQRSTUVWXYZ",">>>>>>>>>>>>>>>>>>>>>>>>>><<<<<<<<<<<<<<<<<<<<<<<<<<")
15:14:59 <ClaudiusMaximus> oops
15:15:04 <donri> shapr: it was in response to <Qrt> happstack is only qrt, yesod is a lot of people
15:15:13 <shapr> donri: I was attempting to be humorous :-)
15:15:17 <donri> :)
15:15:23 <donri> Qrt: the channel for happstack is #happs btw
15:15:29 <ClaudiusMaximus> zxspectrum already left :/
15:15:48 <donri> @where web
15:15:48 <lambdabot> http://happstack.com/ http://snapframework.com/ http://yesodweb.com/
15:15:52 <carlos> Nah! But its MY fault... I thing that's something I should know before using this... The problem is I don't even know what is this thing I should know...
15:16:39 <shapr> Qrt: there's a project to rewrite emacs in haskell, it's called yi
15:16:41 <shapr> it's pretty neat
15:16:51 <donri> @where+ web   #happs : http://happstack.com/ -- #snapframework : http://snapframework.com/ -- #yesod : http://yesodweb.com/
15:16:51 <lambdabot> Good to know.
15:16:54 <carlos> What is this knowledge I lack that keeps me from understanding the conduit docs...? Some indication?
15:17:53 <donri> carlos: maybe you're assuming there's more to it than there is. the examples in the docs i linked is enough code to download google.com into google.html
15:19:06 <aristid> carlos: also, you don't need to use conduits to use http-conduit. it has a simple ByteString-only interface, too
15:19:12 <carlos> Ok. But how to wrap it in the ssl? What about the certificate?
15:19:25 <aristid> http-conduit takes care of that automatically
15:19:36 <aristid> if you want to change the behavior, there's a configuration record
15:20:57 <however> carlos: i don't know if you need to understand conduits to download a file with conduits. if you do need an explanation of conduits: http://www.yesodweb.com/book/conduits ... and yes, the docs are often difficult to make sense of. i usually google or ask in here if there's any tutorial
15:21:01 <carlos> Thanks
15:33:22 <LambdaDusk> so uh, let's say I wanna make an application with graphics that would work on both, windows and linux, which graphics lib is recommended? GLUT, GLFW, SDL?
15:33:51 <hpaste> cesc pasted “Why does this eat up memory?” at http://hpaste.org/71493
15:35:00 <cesc> hey, I'm having a hard time understanding why this little code http://hpaste.org/71493  produces a stack space overflow. What is it allocating?  Isn't this euqilvanet to a fortran  DO I =1,N    sum=sum+1 ENDDO    block?
15:35:16 <LambdaDusk> cesc it does beccause of lazy
15:35:30 <cesc> can one bypass this somehow?
15:35:44 <LambdaDusk> no wait
15:35:54 <LambdaDusk> csc: it is because your recursion never ends
15:35:59 <cesc> ah!
15:36:00 <LambdaDusk> *cesc
15:36:07 <cesc> f*cking hell, what did I do
15:36:14 <LambdaDusk> you don't decrease "n"
15:36:15 <eviltwin_b> no termination check
15:36:23 <cesc> I'm an idiot!!!!!!!!!!!!!!!!!
15:36:25 <Qrt> cabal: cannot configure shoap-0.2. It requires base >=2 && <4
15:36:25 <Qrt> For the dependency on base >=2 && <4 there are these packages: base-3.0.3.1
15:36:25 <Qrt> and base-3.0.3.2. However none of them are available.
15:36:25 <Qrt> base-3.0.3.1 was excluded because of the top level dependency base -any
15:36:25 <Qrt> base-3.0.3.2 was excluded because of the top level dependency base -any
15:36:26 <LambdaDusk> replace it by (n-1) or something
15:36:28 <cesc> I should go sleep :D
15:36:45 <Qrt> what do i ahve to do?
15:36:46 <cesc> no wait
15:36:56 <cesc> it does throw the exception also with n-1
15:36:59 <eviltwin_b> Qrt, the package youa re trying toi install is not compatible with your ghc
15:36:59 <cesc> errr the error
15:37:09 <cesc> LambdaDusk, jupp, just did it. same thing
15:37:22 <eviltwin_b> base <4 it says.  if you have any recent ghc yoru base is between 4.0 and 4.5
15:37:28 <LambdaDusk> cesc then try a de-lazy
15:37:46 <cesc> LambdaDusk, how does one do that?  (I'm barely going over LYAH)
15:38:04 <however> qrt: probably that package hasn't been updated in a while. (soap seems to have fallen out of fashion ...)
15:38:22 <hpaste> cesc annotated “Why does this eat up memory?” with “Why does this eat up memory? (annotation)” at http://hpaste.org/71493#a71494
15:38:52 <Qrt> so is there a rest package?
15:39:13 <LambdaDusk> cesc: I can't reproduce the error, can you post the new source with the (n-1)?
15:39:23 <cesc> I just annotated it
15:39:30 <cesc> wait
15:39:33 <cesc> n must be 100000
15:39:59 <hpaste> cesc annotated “Why does this eat up memory?” with “Why does this eat up memory? (annotation) (annotation)” at http://hpaste.org/71493#a71495
15:40:05 <cesc> LambdaDusk, there you go
15:40:19 <cesc> all the way at the bottom of the page
15:41:07 <SoupEvil> Qrt: rest for what? yesod is rest, you can define paths and components of paths can be used as params for the handlers
15:41:26 <LambdaDusk> cesc: Very weird, it works fine for me... run it from GHCi?
15:41:31 <SoupEvil> Qrt: http://www.yesodweb.com/book/restful-content
15:41:52 <cesc> LambdaDusk, strange... could you try it with a really large n?
15:41:53 <monochrom> my http://www.vex.net/~trebla/haskell/lazy.xhtml explains stack overflow. look for the section on foldl
15:42:05 <cesc> LambdaDusk, no, I  do   ghc --make sum.hs   and run it as ./sum
15:43:26 <cesc> LambdaDusk, ah! when I just load the function in GHCI it does compute (slow as hell though)
15:43:31 <LambdaDusk> cesc: It takes a while but runs fine.
15:44:01 <cesc> such a speed is not acceptable, though.  Adding a million integers should be instantaneous
15:44:30 <LambdaDusk> cesc: Wehn I compile, I get it to... one moment
15:45:27 <LambdaDusk> cesc: Yep, laziness problem
15:45:54 <cesc> LambdaDusk, oh :(  can one improve this?
15:46:00 <LambdaDusk> cesc: http://pastie.org/4257770
15:46:14 <LambdaDusk> you know the $ operator?
15:47:14 <monochrom> the $ operator is just as lazy
15:47:19 <monochrom> try $!
15:47:23 <LambdaDusk> which I did
15:47:35 <LambdaDusk> I just wanted to explain it to a beginner ^^
15:47:39 <monochrom> of course, try at the right place
15:47:52 <monochrom> my url already explained it
15:48:06 <cesc> LambdaDusk, yes,  I didn't know the $! operator, though
15:48:20 <cesc> indeed,  $  was just as slow,   $!  sped things up a bit
15:48:25 <cesc> SHOW ME, MASTER!! =))))
15:48:30 <mauke> @src ($!)
15:48:30 <lambdabot> f $! x = x `seq` f x
15:48:32 <monochrom> and it has pictures, so it is bound to be clearer than anything you can say on irc
15:49:00 <cesc> so $!  means evaluate "now"?
15:49:13 <LambdaDusk> cesc: Basically, yes
15:49:27 <cesc> LambdaDusk, sweet. Faith in haskell: RESTORED
15:50:08 <LambdaDusk> cesc: It is one of the way to unlazy simple computations and recommended when you do a load of simple operations (like one million incs)
15:50:11 <monochrom> do not forget that, by default, you're doing multi-precision integers
15:50:31 <mauke> cesc: more like "make sure the argument is evaluated before the function is called" except I think that's actually wrong
15:50:31 <cesc> LambdaDusk, thanks a lot for the tip.
15:50:42 <mauke> wouldn't you need pseq for that?
15:50:49 <cesc> monochrom, ah! I should restrict that function to   Int -> Int -> Int
15:51:03 <cesc> oho
15:51:05 <eviltwin_b> @src $!
15:51:05 <lambdabot> f $! x = x `seq` f x
15:51:18 <monochrom> still wrong with pseq
15:51:39 <monochrom> pseq is "make sure the argument is evaluated before the function body is evaluated"
15:52:12 <mauke> hahargh
15:52:21 <mauke> (x `seq` f) x?
15:53:02 <shachaf> mauke: What's wrong with that?
15:53:23 <mauke> shachaf: seq doesn't tell you which side is evaluated first
15:53:27 <monochrom> (x `seq` f) x, or (x `pseq` f) x, is interesting
15:53:31 <mauke> it just makes sure both sides get evaluated eventually
15:53:44 <shachaf> Oh, you're comparing to pseq.
15:55:14 <cesc> LambdaDusk, still the performance is "meh"... to add up 10^7 in the haskell code needs about 1s. The fortran code is "instantaneous". I'm not complaining though, it's just an observation. Wanted to compare things with what I already have
15:55:43 <monochrom> turn on -O or -O2
15:55:54 <cesc> already did
15:56:17 <cesc> and compared with the non-optimized fotran
16:01:45 <slack1256> ls
16:01:52 <slack1256> sorry my mistake
16:01:54 <monochrom> file not found
16:02:00 <solrize> > foldr (\x y -> x`seq`(x+y)) 0 [0..10^7]
16:02:02 <lambdabot>   *Exception: stack overflow
16:02:12 <solrize> > foldr (\x y -> y`seq`(x+y)) 0 [0..10^7]
16:02:14 <lambdabot>   *Exception: stack overflow
16:02:33 <solrize> > foldr (\x y -> x`seq`y`seq`(x+y)) 0 [0..10^7]
16:02:35 <lambdabot>   *Exception: stack overflow
16:02:58 <obiwahn> @quote arrr
16:02:58 <lambdabot> mrd says: pirate logic is linearrr
16:03:00 <solrize> > foldl1' (+) [0..10^7]
16:03:02 <lambdabot>   50000005000000
16:03:30 <solrize> cesc what does your benchmark look like?  the haskell runtime takes a while to start up
16:03:33 <solrize> try using criterion
16:03:50 <hpaste> monochrom annotated “Why does this eat up memory?” with “machine code” at http://hpaste.org/71493#a71498
16:05:41 <monochrom> cesc: that is the machine code corresponding to mysum. it already does very native and tight things. I am inclined to attribute slowness to simply huge executable, huge RTS to init and tear down
16:06:08 <solrize> monochrom that's kind of crazy looking code
16:06:10 <monochrom> unless, of course, you consider that a few jumps there are unnecessary
16:06:34 <cesc> uhu   oO
16:06:36 <cesc> brb
16:07:56 <monochrom> oh, wait, it probably is not as tight as possible. movl %eax,0(%ebp) and then only to movl 0(%ebp),%eax is a bit silly, right?
16:08:19 <monochrom> eax is being used as the down-counter here, i.e., parameter n
16:08:44 <Peaker> LambdaDusk, I recommend GLFW
16:08:49 <Peaker> LambdaDusk, or rather, GLFW-b
16:08:50 <monochrom> 4(%ebp) is acc. keeping it in memory hurts too
16:09:06 <hpaste> cesc pasted “Simple dice, inspired by mcstar's example” at http://hpaste.org/71499
16:09:12 <cesc> LambdaDusk, this is the snippet
16:09:27 <Peaker> LambdaDusk, GLFW is old, GLFW-b is the new binding. GLUT is rather crappy (Does not pass keyboard inputs properly), and SDL uses ugly preprocessor tricks making it very hard to build for OS X
16:09:31 <monochrom> ok, I agree that this machine code can be much slower than good fortran code
16:10:05 <cesc> it's from mcstar's example, just simplified so I could understand it a bit better. It should generate n trials of the throw of a die and compute the average value (which I think I'm doing wrong, but I'm concerned about speed now: it's so slow). Let's see if the $! magic helps
16:11:46 <monochrom> ghc on x64 (64-bit) may do better. it may have more registers to use
16:12:01 <cesc> oho
16:12:15 <cesc> well anyway, I'm barely starting with haskell
16:12:50 <monochrom> silver: this kind of ghc-generated code is already the sane kind. try something that actually manipulates algebraic data types :)
16:13:58 <Peaker> Qrt, shoap fails to build because of the PVP
16:14:09 <Peaker> Qrt, you can do "cabal unpack shoap" and edit the shoap.cabal file in there
16:14:23 <Peaker> Qrt,  change version 0.2 to 0.2.1  and change "base < 4" to "base < 100"
16:14:49 <Peaker> Qrt, then "cabal install" in there should work
16:16:30 <nand`> is there anything like showBase :: (Num n, Show n) => Int -> n -> String
16:16:43 <mauke> :t showIntAtBase
16:16:44 <lambdabot> forall a. (Integral a) => a -> (Int -> Char) -> a -> String -> String
16:17:07 <nand`> mauke: thanks
16:17:20 <shachaf> > (`showHex`"") 123
16:17:21 <lambdabot>   "7b"
16:17:36 <mauke> > showIntAtBase 3 intToDigit 1024 ""
16:17:37 <lambdabot>   "1101221"
16:19:25 <Peaker> > showIntAtBase (-2) intToDigit 1024
16:19:26 <lambdabot>   Overlapping instances for GHC.Show.Show
16:19:27 <lambdabot>                              (GHC.B...
16:19:40 <Peaker> > showIntAtBase (-2) intToDigit 1024 ""
16:19:41 <lambdabot>   "*Exception: Numeric.showIntAtBase: applied to unsupported base -2
16:19:44 <eviltwin_b> trailing "" was importabnt
16:19:51 <eviltwin_b> ... slow me
16:28:53 <Qrt> @type replace
16:28:54 <lambdabot> Not in scope: `replace'
16:29:09 <Qrt> is there a replace-string-with-string function?
16:29:44 <Qrt> @hoogle String -> String -> String -> String
16:29:45 <lambdabot> System.Process readProcess :: FilePath -> [String] -> String -> IO String
16:29:45 <lambdabot> Network.CGI.Protocol replace :: Eq a => a -> a -> [a] -> [a]
16:29:45 <lambdabot> Prelude zipWith3 :: (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]
16:33:03 <EmilyS> in the REPL, can I lookup documentation on a function?
16:34:40 <applicative> EmilyS: you can query types with :t and get other info with :i  but not much else
16:36:28 <applicative> EmilyS: you probably have the haddocks for the main libraries like on hackage.
16:36:46 <eviltwin_b> EmilyS: not in stock ghci.  there are some extensions available (goa?)
16:36:58 <EmilyS> when I read Num a => a -> a -> a, that means it takes two parameters in a curry fashion?
16:37:10 <mauke> yes
16:37:22 <applicative> yes an 'a' and an 'a'
16:37:38 <EmilyS> is there another way of defining it without the curry? or is that done implicitly by the compiler?
16:37:48 <applicative> with the 'constraint' that a is a Num type
16:37:54 <mauke> EmilyS: (a, a) -> a
16:37:57 <applicative> (a,a)  -> a
16:37:57 <mauke> now it's a tuple
16:37:59 <pqmodn> :t uncurry
16:38:01 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
16:38:07 <applicative> > uncurry (+) (2,3)
16:38:08 <lambdabot>   5
16:38:10 <Qrt> if i do: a <- x; something a; how do i do it with >>= or =<< ?
16:38:16 <shachaf> EmilyS: No matter what you do, functions only ever take one argument. :-)
16:38:19 <shachaf> x >>= something
16:38:24 <mauke> @undo do { a <- x; something a }
16:38:24 <lambdabot> x >>= \ a -> something a
16:39:30 <EmilyS> ok, currying is awesome, just curious as to what else to expect
16:39:39 <EmilyS> only just started learning today :)
16:40:27 <EmilyS> just currious >.>
16:40:37 <shachaf> You'll find out!
16:41:26 <mauke> learning haskell is like the exponentially escalating power levels in DBZ
16:41:39 <mauke> there's always so much more to wrap your head around
16:41:53 <Eduard_Munteanu> DBZ?
16:42:10 <mauke> @google DBZ
16:42:11 <lambdabot> http://www.dragonballz.com/
16:42:11 <lambdabot> Title: Dragon Ball Z
16:42:16 <Eduard_Munteanu> Ah.
16:42:27 <atrika> is haskell a good tool for big projects ?
16:43:26 <Qrt> so is there replace str str str -> str?
16:43:33 <Peaker> atrika, I think so :) I don't know if there are many very big projects using Haskell to have a real study over it though. I have a ~7000-line project in Haskell and it's been a huge help. In other languages the code would be larger and changing stuff would have been harder
16:43:51 <Qrt> replace "projectName" projectName "filetext" -> newFileText
16:44:12 <Qrt> Peaker: what is the project?
16:44:39 <Peaker> Qrt, github.com/Peaker/bottle
16:44:47 <Peaker> Qrt, still preliminary, not ready for real use
16:45:10 <Peaker> Qrt, but already we have to change fundamental things so we get to experience the significant helpfulness of Haskell's deep type-checking
16:45:14 <applicative> the  ghc is huge, atrika ; I realize this is a somewhat odd example
16:45:45 <EmilyS> compiler theory, eek!
16:45:52 <pqmodn> Qrt: the closest i can find is Data.Text.replace, which operates on Text (not String)
16:46:01 <Qrt> what is it?
16:46:12 <mauke> kosmikus++  # for the talks at HaL7
16:46:14 <pqmodn> http://hackage.haskell.org/packages/archive/text/latest/doc/html/Data-Text.html#v:replace
16:47:10 <Peaker> Qrt, what is bottle or what is Data.Text.replace?
16:47:31 <hayashi> what sort of weird goings-on can cause GHC to complain about overlapping instances where the matched instances are two instances that are exactly from the same code point?
16:47:33 <Qrt> @hoogle Char -> Char -> String -> String
16:47:34 <lambdabot> Network.CGI.Protocol replace :: Eq a => a -> a -> [a] -> [a]
16:47:34 <lambdabot> Prelude enumFromThenTo :: Enum a => a -> a -> a -> [a]
16:47:34 <lambdabot> System.Process readProcess :: FilePath -> [String] -> String -> IO String
16:47:52 <applicative> Qrt try, e.g. Data.List.Split.splitAt and company
16:47:53 <mauke> hayashi: what do you mean?
16:48:15 <monochrom> I would love to see a reproduction of that, yes
16:48:56 <Qrt> @hoogle Char->Char->String->String
16:48:56 <lambdabot> Network.CGI.Protocol replace :: Eq a => a -> a -> [a] -> [a]
16:48:56 <lambdabot> Prelude enumFromThenTo :: Enum a => a -> a -> a -> [a]
16:48:56 <lambdabot> System.Process readProcess :: FilePath -> [String] -> String -> IO String
16:49:50 <hayashi> in trying to make a class for GHC.Generics using the pointers at http://www.haskell.org/ghc/docs/7.4.1/html/users_guide/generic-programming.html, I've ended up with GHC claiming that there are overlapping instances for the backend generic class (GToDSV a)... but the two overlapping instances are both instance [safe] GToDSV a => GToDSV (M1 i c a) defined at the same column and line number of the same module
16:50:29 <applicative> Qrt: intersperse new . splitOn old
16:50:48 <hayashi> I could hpaste the module if it'd help, just didn't know if this was some sort of nooby thing that comes up frequently~
16:51:13 <Qrt> @hoogle intersperse
16:51:14 <lambdabot> Data.List intersperse :: a -> [a] -> [a]
16:51:14 <lambdabot> Data.ByteString.Char8 intersperse :: Char -> ByteString -> ByteString
16:51:14 <lambdabot> Data.ByteString.Lazy.Char8 intersperse :: Char -> ByteString -> ByteString
16:51:20 <mauke> hayashi: what is "this"?
16:51:29 <Qrt> @hoogle splitOn
16:51:29 <lambdabot> Data.Text splitOn :: Text -> Text -> [Text]
16:51:30 <lambdabot> Data.Text.Lazy splitOn :: Text -> Text -> [Text]
16:51:30 <EmilyS> :t (:)
16:51:32 <lambdabot> forall a. a -> [a] -> [a]
16:51:33 <EmilyS> wat?!
16:51:50 <monochrom> that's the correct type
16:51:53 <EmilyS> I am having a hard time grocking it
16:51:56 <applicative> :t (:[])
16:51:57 <lambdabot> forall a. a -> [a]
16:51:58 <eviltwin_b> hayashi, both the code and the actual complete error message would be helpful
16:52:03 <mauke> EmilyS: you can ignore everything before "."
16:52:32 <pqmodn> :t ('x':)
16:52:34 <lambdabot> [Char] -> [Char]
16:52:36 <EmilyS> I am not sure I understand what the : operator is supposed to do
16:52:37 <monochrom> consider "2 : [3,4]". 2::Int, [3,4]::[Int], use a=Int, all types match
16:52:44 <mauke> EmilyS: prepend an element to a list
16:52:57 <EmilyS> ah
16:53:00 <applicative> x : xs is xs with x glued on front ...
16:53:07 <mauke> > 'E' : "milyS"
16:53:08 <lambdabot>   "EmilyS"
16:53:16 <mauke> > 5 : [4, 2, 1]
16:53:17 <lambdabot>   [5,4,2,1]
16:53:19 <monochrom> moreover, [3,4] is syntax sugar for 3:(4:[])
16:53:30 <mauke> > () : []
16:53:31 <lambdabot>   [()]
16:53:33 <shachaf> > 'm' : "аukе"
16:53:34 <lambdabot>   "m\1072uk\1077"
16:54:03 <nand`> what happened to that a/e?
16:54:05 <hpaste> hayashi pasted “broken generics” at http://hpaste.org/71501
16:54:06 <applicative> Qrt: see hackage.haskell.org/package/split
16:54:11 <mauke> U+0430 (d0 b0): CYRILLIC SMALL LETTER A [а]; U+0435 (d0 b5): CYRILLIC SMALL LETTER IE [е]
16:54:17 <hayashi> well, that's the code, and the error message is~
16:54:32 <nand`> they render no different from ‘a’ and ‘e’ for me
16:54:47 <mauke> GHC.Generics? that's definitely not common noob material :-D
16:54:56 <intrigue> nand`: same here - i was slightly confused
16:55:03 <hpaste> hayashi pasted “generics overlap error” at http://hpaste.org/71502
16:55:06 <hayashi> that one.
16:55:08 <Qrt> @type Text
16:55:10 <lambdabot> Not in scope: data constructor `Text'
16:55:46 <mauke> hayashi: sanity check. do you get the same error if you put the type and instance in a .hs file and load it into ghci?
16:55:48 <Qrt> what is Text?
16:56:07 <hayashi> well, for all I know I might be trying to bite off far more than I can chew and completely forgetting about how to use classes sensibly
16:56:09 <hayashi> I'll check
16:56:17 <nand`> Qrt: a type for storing unicode text efficiently
16:56:23 <monochrom> Text is from the "text" package, module Data.Text
16:56:53 <applicative> Qrt it's like String, but not a list, it is more closely packed and has fancy optimizations
16:56:56 <optimight> For .hs file creation and editing I am currently using gedit on Ubuntu 12.04 LTS. Which is the most prefered editor for .hs file and haskell project?
16:57:08 <applicative> nano
16:57:10 <nand`> optimight: vim, or emacs; depending on who you listen to
16:57:37 <intrigue> github.com/amix/vimrc is a nice vim/gvim config
16:57:51 <nand`> optimight: there are also a few experimental and non-experimental haskell-specific editors but I've never enjoyed using them
16:57:58 <hayashi> mauke: nope, same error =P
16:58:30 <monochrom> your most preferred editor for anything is the most preferred editor for haskell
16:58:34 <applicative> nano is lambdabot's favorite editor
16:58:36 <optimight> nand`: ok, Is there any stark difference between vim and emacs?
16:58:43 <nand`> yes
16:58:49 <nand`> one is sane, the other is rubbish. Which one is which depends on who you ask
16:58:50 <hayashi> I thought "ooh, this actually looks a lot easier than I expected it to be" with the whole generics stuff, and I guess I'm being punished for getting ahead of myself!
16:58:58 <dreixel> hayashi: I
16:59:03 <optimight> nand`:  What are they?
16:59:03 <dreixel> hayashi: I'd need to see the whole code
16:59:07 <Peaker> nand`, or "one is rubbish, and one is total rubbish" :)
16:59:17 <nand`> ah yeah
16:59:23 <nand`> then there's Peaker, who will tell you about the glory that is bottle
16:59:48 <hiptobecubic> Someone with some expertise should adopt and expand this: http://en.labs.wikimedia.org/wiki/Haskell/Understanding_monads
16:59:51 <intrigue> optimight: you should check out a primer on both
16:59:59 <hiptobecubic> I think it's pretty nice
17:00:04 <Peaker> nand`, that bottle *will be* :)
17:00:08 <nand`> optimight: one's a modal editor
17:00:09 <intrigue> optimight: vim is modal, emacs involves many simultaneous keypresses - both are great editors
17:00:16 <nand`> the other I can't really describe
17:00:18 <dreixel> hayashi: but I really should go to bed now. Can you perhaps email? generics@haskell.org, or libraries@haskell.org, or even just dreixel@gmail.com
17:00:23 <monochrom> and the same answer for generally all bikeshed-colour-hair-splitting questions such as "should I indent by 2.4 spaces or 2.55555 spaces"
17:00:27 <optimight> intrigue: I will
17:00:35 <hiptobecubic> Has some exercises. Doesn't mention any nasty spaceships or anything. etc
17:00:35 <Qrt> can you run ghci in vim?
17:00:42 <applicative> and the both give you a strong impression of the 70's and 80's
17:01:06 <intrigue> Qrt: there's a plugin for it
17:01:06 <nand`> Qrt: yes. :!ghci
17:01:12 <hiptobecubic> Qrt, I think there's a wrapper plugin
17:01:16 <nand`> runs ghci and takes you back to vim when it exits :P
17:01:24 <zzing_> Is heist the only templating solution that does not require templates to be transformed into haskell?
17:01:26 <optimight> applicative: yes
17:01:45 <monochrom> in vim, :!ghci. in ghci, :!vim. etc
17:01:54 <nand`> vimception
17:02:04 <Peaker> hiptobecubic,  I think http://en.labs.wikimedia.org/wiki/Haskell/Understanding_monads 's Introduction is going to fly over the head of anyone who doesn't understand Monads already
17:03:14 <mauke> how do I extract Understanding from Monad Understanding?
17:03:33 <hayashi> well, that basically is the full code, the generics stuff doesn't have any dependencies on anything other than GHC.Generics as far as I can tell
17:03:36 <nand`> Comonad Understanding
17:03:45 <hiptobecubic> mauke, fromMonad
17:03:46 <monochrom> hahaha
17:03:55 <dreixel> hayashi: what about URY.Common.Filter?
17:04:02 <monochrom> I would extract Monad instead...
17:04:05 <mauke> dreixel: http://hpaste.org/71501
17:04:11 <hayashi> dreixel: well, that was in,,, yeah
17:04:35 <nand`> UnderstandingT
17:04:46 <Peaker> I like this explanation of Monads by Erik Lippert: http://stackoverflow.com/a/2704795/153269
17:04:46 <dreixel> oh, I didn't see that one
17:04:54 <hiptobecubic> Peaker, well I still don't get how to properly build and use them myself and I think it's doing a job for that. There are ten million blog posts to tell someone "Monads are boxes" or "Monads model a particular kind of computation" or what have you, but there don't seem to be so many that are practically useful.
17:05:04 <hayashi> basically I've no idea what's gone wrong there, because I tried to copy and paste from the GHC manual, with the only difference being the second parameter to the class's method
17:05:13 <hayashi> *conscious difference
17:05:24 <Peaker> hiptobecubic, to use them you just need to satisfy the type signatures, most of the time?
17:05:36 <nand`> Peaker: and axioms
17:05:45 <Peaker> nand`, use, not build
17:05:47 <EmilyS> how would I define a function which takes three numbers and returns a touple of two maybe numbers?
17:05:48 <nand`> oh
17:05:48 <hiptobecubic> Peaker, sure, but that's not the same as knowing why you're doing it and when you'd want to
17:05:55 <nand`> how do you use anything *without* satisfying the type signatures?
17:06:04 <mauke> EmilyS: foo _ _ _ = (Just 1, Just 2)
17:06:11 <Peaker> hiptobecubic, do you understand Functor, Applicative? I think they're probably easier to understand thoroughly than Monad
17:06:21 <monochrom> I have disagreements with that idea of amplifier of types. I don't mean the name. I mean its meaning. "IO Int" adds capabilities to Int? don't kid me
17:06:24 <nand`> foo _ _ _ = (Nothing, Nothing)
17:06:40 <Peaker> nand`, I mean you don't have to understand much more to use monads, whereas to do other things you also have to understand more deeply, or satisfy axioms
17:07:06 <Peaker> monochrom, "It makes more sense to me to say it augments types rather than amplifies them.  Gabe"
17:07:20 <mauke> monochrom: it's like walling yourself in, then defining yourself to be the "outside"
17:07:33 <nand`> Peaker: there's a difference between using something and using something effectively, though; I think you have to understand how a monad works / what it models to be able to use it to solve problems (at least on your own)
17:08:09 <hiptobecubic> Peaker, well I've never written anything in the applicative style. I'm not sure I see the difference between functors and traversable things.
17:08:37 <Peaker> hiptobecubic, forget Traversable for a moment, talking about Functor,Applicative specifically :)
17:08:43 <dreixel> hayashi: I can't immediately see what's going wrong. I'll check again tomorrow..
17:08:52 <hayashi> Ok, cheers
17:08:57 <monochrom> I have "newtype US_ecomony money = Ctor (money -> US_economy)". is that an attenuator type now? it takes capability away from money...
17:09:00 <Peaker> hiptobecubic, Do you understand what power Applicative adds over "fmap"? And what power Monad adds over Applicative?
17:09:22 <hiptobecubic> Peaker, i didn't say Traversable. I said traversable things, in the common every day usage of the word.
17:09:35 <Peaker> hiptobecubic, oh, I don't know if that's a good way to describe Applicative though
17:09:50 <hiptobecubic> Peaker, I really don't know, because I have never used them to solve anything.
17:10:06 <monochrom> and last but not least, "data X a = X" is a monad and amplifies nothing
17:10:10 <nand`> I gain my monad intuition in terms of ‘join’, personally
17:10:11 <hiptobecubic> Peaker, in theory, i do know. In practice, i imagine that i do not.
17:10:35 <Peaker> hiptobecubic, "fmap" is a useful generalization, right? So we can write nice functions/operators for all sorts of (*->*) type constructors
17:10:53 <nand`> I consider bind to be a fancy helper, but not the underlying concept
17:11:10 <gwern> more spammers!
17:11:32 <Peaker> hiptobecubic, so fmap lets you apply functions on the "a" of "f a".  But what happens when you want to combine together "f a" and "f b" (two "wrapped values")?
17:11:37 <nand`> (of course having >>= in the typeclass is all fine and dandy because usually you'll care more about optimizing it instead of join due to do notation)
17:11:50 <shachaf> Peaker: "wrapped values" :-(
17:12:09 <Peaker> shachaf, what's wrong with that? It's sufficiently vague :)
17:12:17 <monochrom> "newtype US_ecomony money = Ctor (money -> US_economy money)" wraps money
17:12:20 <shachaf> Peaker: It implies that "f a" contains "a".
17:12:36 <monochrom> "data X a = X" wraps a
17:13:02 <shachaf> monochrom: Sure, but that's "wrapping" a type, not a value.
17:13:24 <hiptobecubic> Peaker, combine how?
17:14:01 <monochrom> I agree with you. it's my point.
17:14:08 <Peaker> hiptobecubic, for example, adding 1 inside a functor is easy:  fmap (+1) :: (Functor f, Num a) => f a -> f a.  What happens if you want to add together two values:   (Functor f, Num a) => (f a, f a) ?
17:14:15 <shachaf> monochrom: Ah.
17:14:20 <Peaker> yeah, I agree "wrapped values" is problematic
17:15:04 <monochrom> "Parser Int" does not wrap or contain a number
17:15:07 <intrigue> Peaker, isnt that what applicative functions are for
17:15:07 <Peaker> unfortunately the terminology is pretty lacking... What term would you use for a value whose type is "f a" for some (f :: * -> *)?
17:15:11 <intrigue> *functors
17:15:15 <shachaf> monochrom: Nor does id :: Int -> Int
17:15:15 <Peaker> intrigue, it is, that's what I'm getting to
17:15:20 <intrigue> ah
17:15:57 <hayashi> ok, that's intriguing
17:16:01 <monochrom> if f is a monad, I say "action" for a value of type "f Int"
17:16:03 <nand`> Peaker: I use “lifted types”
17:16:24 <Peaker> monochrom, it's a Functor that by the end of the explanation should turn to Applicative (or if there's time, to Monad)
17:16:39 <hiptobecubic> Well
17:16:44 <hayashi> if I move the offending data type into the module proper
17:16:46 <hayashi> everything works.
17:17:32 <hiptobecubic> Without using the word applicative, I guess you want some kind of generalized zipWith?
17:17:33 <Peaker> hiptobecubic, if you try:   fmap (+) x     you get back:  (Functor f, Num a) => f (a -> a)    and then it's really hard to take   f (a -> a)    and combine it with   f a   to finish up the addition
17:17:53 <Peaker> hiptobecubic, yeah, pretty much
17:17:57 <monochrom> I am not convinced that terminology adds any value, although I acknowledge that many people religiously believes so
17:18:08 <Peaker> monochrom, language is hard without words :)
17:18:37 <hiptobecubic> I understand that things of type F a are not "a's in an F".
17:19:20 * monochrom recalls the Feynman example. "consider this in textbooks. 'when you let go of a ball, it falls down. this is called gravity.' this tells you nothing."
17:19:39 <Peaker> hiptobecubic, so the idea behind "Functor" is that we can make a whole lot of types be instances of Functor ("covariance" has to do with this, but it's less important now)
17:20:04 <Peaker> hiptobecubic, the idea behind "Applicative" is adding that "zipWith"-like operation, so that we can compose two Functor values together
17:21:14 <monochrom> well, of course, you could say, it's more convenient to give a name, and then go on to explore it. Feynman's point is that the textbooks stop at giving a name, totally do not go on to explore anything.
17:21:33 <Peaker> hiptobecubic, the interesting operation: (<*>) :: Applicative f => f (a -> b) -> f a -> f b         can be viewed as doing 2 things at the same time.   It fuses together the two "f"s from its two args, to form an "f" that contains all the information from both.  It also applies the (a->b) to the "a" to form a "b"
17:22:34 <hiptobecubic> Peaker, but what is the purpose of the first f
17:22:49 <Peaker> hiptobecubic, without it we get "fmap" again
17:22:58 <Peaker> hiptobecubic, and "fmap" doesn't let us combine two "f a" values
17:23:25 <Peaker> hiptobecubic, (<*>) lets us combine 2 values together into one, and thus we can combine N values into 1 (every (<*>) application removes 1 of the N at a time)
17:24:14 <hiptobecubic> I guess I don't see how this does either, then. We stick our operator into the functor and then apply it ?
17:24:28 <Peaker> hiptobecubic, yeah, pretty much:
17:24:35 <Peaker> fmap (+) x  -- yields    f (a -> a)
17:24:44 <Peaker> fmap (+) x <*> y    -- yields the result: f a
17:25:21 <Peaker> if instead of (+) you used a function of 5 args, you could do:    fmap funcOf5 a <*> b <*> c <*> d <*> e
17:25:50 <zzing_> How does throw :: Exception e => e -> a   work within pure code?
17:26:06 <Peaker> hiptobecubic, and this expression forms one big "f a" where the "f" part contains all of the information/effects from all of the "f"s we combined together.  And the "a" part contains the result of the fully applied function
17:26:06 <shachaf> zzing_: It's evil. Don't use it.
17:26:12 <hiptobecubic> zzing_, by raping it and killing everyone in the room
17:26:21 <zzing_> I suspected
17:26:33 <shachaf> hiptobecubic: Come on...
17:27:07 * hiptobecubic retracts his comment.
17:27:09 <zzing_> There is this other one, throw :: (MonadIO m, Exception e) => e -> m a   that says it is a generalized throwIO - but it doesn't look like you can use it in IO
17:27:10 <Peaker> hiptobecubic, for example, for f=IO,  the result   IO a    will have the effects of a,b,c,d,e one after another (left-to-right),  and the "a" will have the result of funcOf5 applied to the IO action results of a,b,c,d,e
17:27:19 <dmwit> :t foldM
17:27:21 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
17:27:28 <Peaker> zzing, IO is an instance of MonadIO
17:27:46 <zzing_> oh it was defined elsewhere, didn't see it
17:29:18 <hiptobecubic> Peaker, by "the a", you mean a new "a", yes?
17:29:26 <hiptobecubic> whatever the output of funcOf5 is
17:29:35 <Peaker> hiptobecubic, oops, yeah, I meant the result type "a", not the arg "a", sorry
17:29:40 <hiptobecubic> ok
17:30:03 <Peaker> hiptobecubic, so Applicative sounds like it solves the Functor problem of not being able to compose "f a"s together.. so why do we need any more?
17:30:27 <hiptobecubic> Something about dependencies between them, i think it was?  :)
17:30:32 <Peaker> yeah :)
17:31:02 <hiptobecubic> Looking at this page i pasted earlier, it's building the State monad and using RNGs as a motivation
17:31:18 <Peaker> hiptobecubic, Applicative requires us to know all of the stuff we're going to combine together before we see any result.  (<*>) cannot decide which "f a" to combine with which based on the "content" (the values "inside")
17:31:33 <hiptobecubic> Peaker, why not
17:31:57 <Peaker> hiptobecubic, for example, let's say you have:  f True = xa ; f False = xb
17:32:32 <hiptobecubic> what are xa and xb here?
17:32:34 <Peaker> hiptobecubic, now let's try to use fmap and (<*>) to combine (x :: Applicative g => g Bool) with (f x)
17:32:55 <zzing_> Is there something that will run function (IO a), and in the case of an exception it will run B (e -> IO ()), otherwise will run C (IO ())?
17:33:10 <MostAwesomeDude> zzing_: catch or bracket might be close?
17:33:14 <MostAwesomeDude> :t bracket
17:33:15 <lambdabot> Not in scope: `bracket'
17:33:16 <Peaker> hiptobecubic, I better craft a more realistic example to make it clearer
17:33:26 <MostAwesomeDude> @hoogle bracket
17:33:27 <lambdabot> Control.Exception.Base bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
17:33:27 <lambdabot> Control.Exception bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
17:33:27 <lambdabot> Control.OldException bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
17:33:52 <zzing_> hmm, actually I need to <- the action first
17:34:14 <Peaker> hiptobecubic, let's say you want to add the Int in "x :: f Int"  with  "y :: f Int" if the Int in x is even,  or with "z :: f Int" if the Int in x is odd
17:34:53 <Peaker> hiptobecubic, This is something you could actually do with Applicative, but it would require you to combine the "effects" of all of x,y,z
17:35:20 <Peaker> hiptobecubic, it would be a good exercise to write it down, though
17:35:32 <hiptobecubic> fmap (+) x <*> (if fmap even x then y else z)  ?
17:35:47 <Peaker> fmap even x   does not result in a Bool
17:35:53 <hiptobecubic> ah right
17:36:40 <Peaker> hint: fmap myFunc x <*> ...
17:36:52 <hiptobecubic> fmap \x->... was just starting to :)
17:36:57 <Peaker> :)
17:37:06 <hiptobecubic> but this is going to be hideous i think
17:37:07 <zzing_> MostAwesomeDude, bracket is more about resources
17:37:31 <MostAwesomeDude> zzing_: Well, I'm not good with exceptions, so.
17:39:07 <zzing_> I will try it after a break
17:39:33 <hiptobecubic> Peaker, you could fmap over (fmap even x), but then I don't see how to pluck the right parts of y and z as necessary. Say for example these were lists
17:39:59 <hayashi> woo, the aforementioned generics code works (except in ghci, for some reason)
17:40:03 <gwern> there. my ultimatum is sent.
17:40:23 <Peaker> hiptobecubic, if you write:   fmap foo x <*> y <*> z    then "foo" gets to look at all the values and decide what to do
17:40:43 <Peaker> hiptobecubic, however, it will get all the "effects" of "y" and "z" even if it ends up using just "y" or just "z"
17:41:20 <Peaker> hiptobecubic, try to write the definition of "foo"
17:41:52 <gwern> http://www.haskell.org/pipermail/haskell/2012-July/023420.html
17:45:06 <hiptobecubic> hmm
17:45:41 <gwern> well well. refreshing RC every minute is increasing my autoblock hits. maybe I'm actually annoying the spammer
17:46:15 <Qrt> there is no installled version of base. is that becausei dont have base in the cabal file? because i have compiled with cabal before successfully with base as dep
17:48:39 <Peaker> hiptobecubic, anyway, I need to go to sleep soon, so I'll skip this part to the last one: if you replace the "even/odd" distinction over y/z and change it to an arbitrary function:  (Int -> f Int) that chooses which "f Int" to add to, then the problem becomes unsolvable with (<*>) alone. Then you need more power, the power of join
17:49:02 <hiptobecubic> I'll have to think about it
17:49:43 <Peaker> hiptobecubic, The reason is that:  (Int -> f Int)  applied with fmap or (<*>) is going to end up with    "f (f Int)" there.. and an "f Int" value at the inside of an "f" cannot be combined with the outer "f" value in any way with just fmap, (<*>) (or "pure")
17:50:05 <hiptobecubic> Peaker, that makes sense at least.
17:50:32 <hiptobecubic> ah yes
17:50:37 <Peaker> hiptobecubic, so if you add:  join :: f (f a) -> f a       that "fuses" the two "f"s into one (again, with all the "effects" of both in one value
17:50:38 <hiptobecubic> i can see from the type of fmap
17:51:18 <Peaker> hiptobecubic, ) then you make it possible to choose which effects to combine as a result of previous "effects"  -- I grew loose with language here :)
17:51:27 <hiptobecubic> sure
17:51:55 <hiptobecubic> so we're trying to control which effects we want to use, not just which values?
17:52:02 <hiptobecubic> so to speak
17:52:24 <Peaker> hiptobecubic, Applicative/Monad are basically about composition of "effects" and "values" simultaneously
17:52:59 <Peaker> hiptobecubic, and yeah, it's very important which "effects" are chosen. For example, if f=IO, then any "f a" could hide within it "launch the missiles"
17:54:21 <hiptobecubic> but when we combine things with >> we still 'do' them both no?
17:54:26 <hiptobecubic> In the case of IO for example
17:54:41 <Peaker> hiptobecubic, Yeah, because (>>) basically combines the "effects" of both while throwing away the value of the left-arg
17:55:17 <hiptobecubic> Peaker, so at what point can you avoid launching the missiles?
17:55:27 <hiptobecubic> That's the last quetsion before I fall asleep.
17:56:39 <JoeyA> One way to nuke your ability to easily reason about code is to require it to be async exception safe.
17:56:54 <Peaker> In the odd/even example, you can avoid it if you choose y,z  based on the evenness "inside" x  and then when you get a value like:  f (f Int), you "join" it
17:57:14 <hiptobecubic> ah ok
17:57:36 <Peaker> join (fmap foo x) where foo xv = if even xv then y else z
17:57:50 <hiptobecubic> right
17:58:12 <Peaker> the "join" will only perform the effects of y OR z and not both, unlike the Applicative-only solution which performs all
17:58:42 <Peaker> just because we have to pre-determine all the values we'll compose together with <*>
17:58:56 <hiptobecubic> That sounds reasonable
17:59:01 <hiptobecubic> But maybe i'm just tired.
17:59:09 <hiptobecubic> Peaker, anyway, thanks. It's been informative
17:59:45 <Peaker> hiptobecubic, sure, it always helps clearing up concepts/terms to explain stuff..
17:59:53 <Peaker> hiptobecubic, (for the explainer, I mean)
18:11:24 <Qrt> is there no split on several different strings like
18:11:54 <Qrt> splitOn [" ", "\n", ".hs"] text
18:15:15 <dmwit> Qrt: There are regex packages.
18:17:49 <shachaf> foldr (>=>) return . map splitOn
18:18:37 <shachaf> @ty (foldr (>=>) return . map ?splitOn) [" ", "\n", ".hs"] "blah blah .hs\n hello.hs blah"
18:18:38 <lambdabot> forall (m :: * -> *). (Monad m, ?splitOn::[Char] -> [Char] -> m [Char]) => m [Char]
18:18:50 <dmwit> ...I don't think that really does what he's looking for.
18:19:07 <shachaf> dmwit: What is he looking for?
18:19:30 <shachaf> Something efficient? :-)
18:19:40 <dmwit> Oh, I just misread, actually.
18:20:14 <dmwit> That actually seems pretty reasonable, provided you have the nice property that his happened to regarding infix-free-ness.
18:20:15 <shachaf> @ty foldr (>=>) return -- Does this have a shorter name?
18:20:16 <lambdabot> forall (m :: * -> *) c. (Monad m) => [c -> m c] -> c -> m c
18:21:27 <shachaf> foldr ((>=>).splitOn) return
18:21:39 <shachaf> That's short but I don't know if I like it as far as readability goes. :-)
18:22:22 <Qrt> >=> what does this mea and why have a symbol fir it instead of a word that describes the function?
18:22:31 <Qrt> @type (=<<)
18:22:33 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
18:22:37 <Qrt> @type (>>=)
18:22:38 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
18:23:56 <Cale> Qrt: >=> and <=< are analogous to composition, but monadic
18:24:01 <Cale> :t (<=<)
18:24:02 <lambdabot> forall b (m :: * -> *) c a. (Monad m) => (b -> m c) -> (a -> m b) -> a -> m c
18:24:18 <Cale> Compare that with (.) :: (b -> c) -> (a -> b) -> a -> c
18:24:46 <Cale> =<< and >>= are called 'bind' and are analogous to function application
18:24:56 <Cale> :t (=<<)
18:24:58 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
18:25:05 <shachaf> I gues foldr (<=<) return would work too.
18:25:11 <Cale> compare to ($) :: (a -> b) -> a -> b
18:26:58 <pqmodn> or (<*>) :: f (a -> b) -> f a -> f b
18:27:17 <Cale> Yeah, that's analogous in a different way :)
18:27:52 <Nereid> the hard part is figuring out how to split by certain substrings, I'd say.
18:28:40 <shachaf> Or to (>$$*-#>$*) :: f (f (f a -> f b) -> f a -> f b)
18:30:54 <pqmodn> is (<*>) not analogous to function application? how is it usually thought of?
18:35:07 <Nereid> pqmodn: it's generalized function application, I guess.
18:39:05 <EvanR1> i just thought of something
18:39:25 <EvanR1> lets say you have an expression which you expect to take a friggin long time to evaluate
18:39:31 <EvanR1> so you want a progress bar
18:39:36 <EvanR1> now what
18:39:39 <EvanR1> progress bar monad?
18:39:57 <peterjoel> Qrt, which splitOn are you using? I can only find splitOn::Text->Text->[Text] whereas it looked like you were talking about String...
18:40:05 <shachaf> peterjoel: Data.List.Split
18:40:39 <peterjoel> ok - it's not on hoogle!
18:40:53 <dmwit> ?hoogle splitOn +split
18:40:54 <lambdabot> Could not find some databases: split
18:40:54 <lambdabot> Searching in:
18:40:54 <lambdabot>   .
18:41:01 <shachaf> It's on Google, though. :-)
18:41:13 <dmwit> peterjoel: Try that search on the web interface. =)
18:41:42 <shachaf> dmwit: If you have to specify where splitOn comes from, it kind of defeats the purpose.
18:41:49 * dmwit nods agreement
18:47:06 <EvanR1> lets say you load a bytestring from a file and want to convert it to some other structure with a pure function, but its going to take a while, how to instrument that with a progress bar?
18:48:39 <dmwit> The normal way is to build up your pure function out of several steps. Execute the steps in order manually, and print a message or whatever as each step completes.
18:49:06 <dmwit> (Here by "normal" I mean "normal in other languages". I don't know if there's a normal way in Haskell, but the same approach seems worth trying.)
18:49:11 <otters> You can't pass ghc options to cabal install, can you?
18:49:38 <EvanR1> mkay
18:50:23 <EvanR1> dmwit: heh in other languages you put a 'incrment progress' call in the middle of the conversion code xD
18:51:01 <levi> Incrementing progress is a side effect, so a function that does so is by definition not pure.
18:51:14 <EvanR1> yeah
18:52:00 <peterjoel> problem is that you would still need "steps" inside your conversion code, which would need to be in some monad
18:52:10 <levi> If you process the data explicitly a chunk at a time via a pure function, however, you can use monadic plumbing to have side-effects happen on a per-chunk basis.
18:52:30 <peterjoel> if you are artificially introducing a monad into a pure calculation, it's not much different than incrementing the progress
18:53:04 <levi> The Enumerator/Iteratee stuff is designed to do that sort of thing.
18:53:40 <peterjoel> ok so it works if the calculation naturally falls into chunks
18:54:03 <levi> You can't read a file with a pure function anyway, so there's going to be a monad involved no matter what.
18:55:26 <peterjoel> yes, but my point was that your calculation function should have to have a monad in its type
18:56:41 <peterjoel> *should not
18:58:06 <EvanR1> levi: my description was, you load a bytestring from a file then apply a pure function
18:58:21 <EvanR1> fmap f readFile
18:58:48 <peterjoel> then you have to use another thread :)
18:58:49 <EvanR1> progress bar or any report is clearly not doable
18:59:06 <levi> Your question was nonsense, though. It was equivalent to "How can I do a side-effect with a pure function?"
18:59:19 <EvanR1> alright levi
18:59:46 <peterjoel> so it can't be done generically, as originally stated
19:00:01 <peterjoel> the calculation needs to somehow know that it must report its progress
19:00:06 <EvanR1> the question was how do i change f or the whole expression to do a progress
19:00:07 <levi> I was just trying to be helpful by providing some alternatives to your original request.
19:00:52 <EvanR1> progress monad maybe
19:01:19 <peterjoel> Basically it's a state monad
19:01:31 <peterjoel> with a numeric state
19:01:41 <levi> http://www.mail-archive.com/haskell-cafe@haskell.org/msg88727.html
19:02:00 <EvanR1> how would the running of that state look
19:02:09 <EvanR1> running a state gives you a final state
19:02:14 <EvanR1> which is 100%
19:02:33 <EvanR1> this monad only updates, never reads
19:03:00 <peterjoel> ok then it's a Writer, even simpler :)
19:03:08 <EvanR1> yeah writer
19:03:27 <EvanR1> still running a writer gives you 100%
19:05:03 <EvanR1> would need a runPartial and do that over and over, and output the progress in between
19:05:27 <EvanR1> coroutine monad?
19:05:28 <ClaudiusMaximus> EvanR1: i had this problem too, i didn't find a 100% satisfactory solution yet
19:05:31 <levi> You should read the mailing list thread I posted.
19:06:05 <EvanR1> ok
19:07:23 <levi> It is actually exactly about printing progress dots while processing a bytestring.
19:07:48 <EvanR1> it could be a state that stores the state of the parser
19:08:31 <EvanR1> could be a generic wrapper for attoparsec parser
19:09:16 <EvanR1> but only works if your function is a parser
19:09:20 <EvanR1> from that lib
19:09:22 <EvanR1> meh
19:09:28 <otters> did anybody answer my question? I left
19:09:31 <ClaudiusMaximus> levi: hm, my problem was more that i had pure algorithms that i absolutely couldn't let run in the main thread as they'd block the gtk gui
19:10:17 <EvanR1> ClaudiusMaximus: yeah thats the more generic situation, but im thinking of compiling large deserialized data
19:10:27 <EvanR1> into a form that allows fast processing later
19:17:36 <levi> If you can process a chunk at a time, you can just chunk your data and have the algorithm run until it's finished with the chunk and return its continuation or something.
19:25:19 <cads> is there a haskell implementation of the awk language?
19:25:25 <cads> hawk?
19:28:05 <Digit> this is how i feel when trying to learn haskell. http://www.davidshrigley.com/draw_htmpgs/blanket_of_filth/2_formulea.html
19:30:40 <JoeyA> Let m∈ℕ and n∈ℕ be two coprime numbers.  And I guess we'll go watch a movie or something.
19:31:43 <cads> http://www.davidshrigley.com/draw_htmpgs/centre_parting/2_buddah.html
19:41:58 <Anpheus_> I am doing some HTML parsing and replacing using HXT but script tags are screwing up my parsing
19:57:50 <tertl6> what is the de facto compiler for scheme?
20:01:35 * hackagebot archiver 0.6.1 - Archive supplied URLs in WebCite & Internet Archive (GwernBranwen)
20:01:41 <zachk> tertl6: does not exist :-/
20:03:01 <tertl6> hrmm
20:04:14 <pt> hello, can someone please tell me how to print a list without the square brackets and the commas between items
20:05:05 <pqmodn> > concat $ map show [1,2,3,4]
20:05:06 <lambdabot>   "1234"
20:06:11 <zzing_> f :: (Brawndo b) => b -> b       It has what functions crave.
20:09:38 <pt> mapM_ print [[Int]]
20:10:04 <pt> @pqmodn how does it work with this code?
20:10:04 <lambdabot> Unknown command, try @list
20:10:32 <pqmodn> :t mapM_
20:10:34 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
20:10:39 <pqmodn> :t print
20:10:42 <lambdabot> forall a. (Show a) => a -> IO ()
20:11:16 <pt> [1,2,3]
20:11:16 <pt> [4,5,6]
20:11:27 <pt> current i get the above
20:11:28 <pt> i want
20:11:33 <pt> 123
20:11:33 <pt> 456
20:17:15 <zachk> > let number =    600851475143  in  foldr max 0 . filter ((0 == ) . (mod number)) $ [2..(1+).ceiling.sqrt.fromIntegral $ number]
20:17:18 <lambdabot>   486847
20:17:59 <JoeyA> Wrong answer.
20:23:29 <chidy> :t par
20:23:32 <lambdabot> forall a b. a -> b -> b
20:33:16 <zachk> joeyA really?
20:34:06 <zachk> do
20:34:09 <zachk> dooo not a prime
21:13:41 <solrize> http://harmful.cat-v.org/software/OO_programming/why_oo_sucks
21:16:54 <shachaf> I didn't think it was a particularly great argument.
21:24:05 <solrize> that site seems to be a big rant collection
21:42:50 <zzing_> :t ($!)
21:42:51 <lambdabot> forall a b. (a -> b) -> a -> b
21:43:01 <zzing_> @src ($!)
21:43:01 <lambdabot> f $! x = x `seq` f x
21:55:16 <tmiw> is it me, or does forall seem like a more explicit way of expressing the default haskell behavior?
21:55:24 <ninegrid> how does one go about bailing out of an unfold
21:56:05 <zachk> there is no bail, well not anything like break or return or exit in general
21:56:29 <ninegrid> i understand, what should i use instead?
21:56:41 <ninegrid> here let me show you what i've got... http://codepad.org/fiGcKzJb
21:56:58 <ninegrid> you see im going through knuth's art of computer programming and tryin to get a grip on haskell through that
21:57:18 <ninegrid> so, unfold is clearly a poor choice here because the result would be an infinite list of omega discriminants
21:58:13 <ninegrid> i just want a list of the computational states from I (m,n) through all the steps of Q and ending with an omega
21:59:03 <ninegrid> apologies for the name of the function too.. i understand there is existing convention when naming things that start with underscore, but i wanted to keep something recognizable to the numbered items in the book
21:59:31 <pqmodn> tmiw: yes, by default all types are quantified at the outer level. see the RankNTypes extension documentation for cases where you'd want to explicity write forall elsewhere
22:11:30 <zzing_> if I have a function a -> b  that I previously am doing an <- on an m a, is there a way to combine two requests so that the function a -> b takes does an m a -> m b?
22:13:10 <ClaudiusMaximus> :t fmap
22:13:12 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
22:14:24 <zzing_> Is that also <$>?
22:14:25 <zzing_> :t (<$>)
22:14:26 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
22:15:09 <ClaudiusMaximus> ninegrid: your code doesn't typecheck (infinite type error here in ghci) - but if it did, i'd try to restructure it so that  f (Omega n) = Nothing
22:17:02 <ninegrid> ClaudiusMaximus: thats odd... i can run it here
22:17:37 <ClaudiusMaximus> ninegrid: is your (%) from Data.Ratio or something you defined?
22:18:00 <ninegrid> ah something i defined
22:18:02 <ninegrid> for mod
22:18:07 <ClaudiusMaximus> :t (%)
22:18:08 <lambdabot> forall a. (Integral a) => a -> a -> Ratio a
22:18:20 <ninegrid> it is aliased to mod
22:18:23 <ClaudiusMaximus> ok
22:18:30 <ninegrid> probably shouldnt do that...
22:18:41 <ninegrid> i am making the switch from ML
22:19:05 <ninegrid> also, if i make that case of f return Nothing, isn't that invalid since f only returns ComputationalMethod
22:21:25 <ClaudiusMaximus> yeah, fixing the other cases to add a Just would be necessary too - using Maybe to encode "is there a 'next step', and what is it; or are we done"
22:22:17 <zzing_> Is there anything in emacs that would allow me to go from something in my code to the documentation for that component?
22:22:35 <zzing_> :t (<*>)
22:22:37 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
22:23:40 <ClaudiusMaximus> ninegrid: your data definitions are somewhat unidiomatic, btw - usually you'd write  data X a b = A a | AB a b | B b   without additional tuples
22:24:04 <ninegrid> ClaudiusMaximus: alright
22:26:17 <ClaudiusMaximus> the code forces m ~n , n ~ r  (where ~ is type equality), so unless you need the data structure in a different algorithm without that constraint i'd just use one variable
22:29:38 <ClaudiusMaximus> the 'call' variable taking values 1 2 3  could probably be its own algebraic type so the compiler can be sure that 4 doesn't ever occur and the code reader knows what it really means
22:31:32 <ninegrid> ClaudiusMaximus: the structure would be used for lots of different algorithms
22:32:18 <ClaudiusMaximus> ninegrid: ok
22:32:20 <ninegrid> ClaudiusMaximus: it seems that after modifying everything to use Maybe, i had to add the f Nothing case to make the match exaughstive but when i run it, unfoldr doesnt seem to care
22:33:28 <ninegrid> ClaudiusMaximus: although I don't know which... after giving it a second thought I don't know how general it actually is... i might have to make some edits to it
22:33:37 <ninegrid> its strait from knuth's AoCP chapter 1
22:33:38 <levi> zzing: http://www.haskell.org/haskellwiki/Haskell_mode_for_Emacs
22:33:54 <zzing_> Is this the proper way to do this? It does checkout for the final type I want: T.unpack <$> TE.decodeUtf8 <$> rqURI <$> getRequest
22:34:16 <ninegrid> ClaudiusMaximus: unfoldr doesnt seem to care -- meaning it is just spitting out infinite Nothing when it reaches omega
22:35:17 <ninegrid> ClaudiusMaximus: maybe i didn't understand you correctly http://codepad.org/wXv8gkHq
22:36:44 <ninegrid> ClaudiusMaximus: i also removed the unicode character since it was causing my ghci to throw an exception when printing it
22:38:06 <ninegrid> oh my... i understand now
22:38:41 <ninegrid> unfold is wrapping the Maybe values of f in its own Maybe values.... so thats not going to work
22:39:34 <hpaste> ClaudiusMaximus pasted “for ninegrid” at http://hpaste.org/71515
22:43:12 <ninegrid> ClaudiusMaximus: that is quite a bit more elegant
22:43:24 <ninegrid> now its time to study the fmap again
22:43:25 <ninegrid> heh
22:45:47 <ClaudiusMaximus> :t let pair x = (x, x) in \m -> fmap pair (m `asTypeOf` Just "hello")
22:45:48 <lambdabot> Maybe [Char] -> Maybe ([Char], [Char])
22:46:57 <otters> haskell is just about the most concise language I have ever seen
22:47:20 <ninegrid> otters: agreed
22:47:43 <pqmodn> otters: take a look at J or APL
22:47:50 <otters> sorry
22:47:57 <otters> haskell is just about the most concise readable language I have ever seen
22:47:58 <ninegrid> i had written this code about a year ago in F#, which looks a lot like OCaml.. you can see the difference: http://codepad.org/SRAOQL63
22:48:01 <pqmodn> hehe
22:49:00 <ninegrid> J meets half the criteria for the definition of concise
22:49:13 <otters> I've worked with J a bit
22:49:15 <ninegrid> i believe haskell meets both criteria, clear and breif
22:49:15 <otters> I had to memorize everything
22:49:25 <ninegrid> ive only played with it
22:50:05 <zzing_> If I have a case … of     and then _ -> blah  can I replace _ with a variable name to be able to use the value without changing the way it is matched?
22:50:19 <pqmodn> yes
22:50:31 <pqmodn> > case 3 of x -> x + 1
22:50:33 <lambdabot>   4
22:51:05 <otters> > case True of 1 == 1 -> 1; 2 == 2 -> 2
22:51:07 <lambdabot>   <no location info>: Parse error in pattern
22:51:15 <otters> > case True of { 1 == 1 -> 1; 2 == 2 -> 2 }
22:51:17 <lambdabot>   <no location info>: Parse error in pattern
22:51:20 <otters> dammit
22:51:24 <zzing_> χϡεετ!
22:51:26 <otters> haha wait
22:51:28 <otters> I'm a moron
22:52:41 <zzing_> hmm, Ambiguous module name `Control.Monad.CatchIO':  MonadCatchIO-transformers-0.3.0.0 MonadCatchIO-mtl-0.3.0.4
22:56:45 * hackagebot conduit 0.5.2.1 - Streaming data processing library. (MichaelSnoyman)
22:57:19 <zzing_> Q: I have an error related to constraints, but I am not sure how to solve it. Error is on line 46, and full ghc output at the end.  It suggests a type signature, but I am not sure really how to do that in this case.   http://hpaste.org/71516
22:59:53 <ClaudiusMaximus> zzing_: (defaultHeistState :: HeistState IO) is what i'd try, but i've never used it
23:01:28 <zzing_> Apparently that does work
23:01:53 <zzing_> I shall ask the mighty one for clarification
23:02:59 <isomorphic> I'm building a package with cabal.  It depends on something that I have installed already.  I get given an error for one of the dependencies of the thing that is already installed.  Why should cabal care about dependencies for something that's already installed?
23:03:50 <ClaudiusMaximus> zzing_: you could also fix 'm' here, perhaps http://hpaste.org/71516#line54
23:04:28 <dmwit> isomorphic: Perhaps it's installing a new version of the thing you already installed, or the same version but with different versions in the dependencies, to satisfy constraints of the new top-level thing you're trying to install.
23:04:51 <zzing_> Ok, I shall make note of both solutions
23:05:12 <dmwit> isomorphic: You can use --dry-run to ask what its plan is; -vvv to ask why it picked its plan; and --constraint to nudge the plan.
23:05:23 <isomorphic> dmwit: Thanks :)
23:06:00 <dmwit> (in particular, the "foo installed" constraint is often useful -- not because it's what you want in the end, but because it tells you why it's reinstalling something =)
23:30:47 <dada_cetacean> I tried to copypasta Learn You A Haskell For Great Good!'s implementation of quicksort, but it gives me a parse error when I try to load the source file
23:31:03 <zzing_> dada_cetacean, link?
23:31:21 <dada_cetacean> http://pastebin.com/6TF1DGKR
23:31:23 <mauke> The paste 6TF1DGKR has been copied to http://hpaste.org/71517
23:31:43 <dada_cetacean> "parse error on "=" " is that ghci is giving me
23:31:47 <otters> that ain't no quicksort
23:31:47 <dada_cetacean> what*
23:32:32 <dada_cetacean> Miran Lipovaca says it is :c
23:33:36 <zzing_> otters, looks like quick sort to me
23:33:46 <RebelBunny> http://www.haskell.org/haskellwiki/Introduction#Quicksort_in_Haskell I'm really amazed at how concise this is
23:33:47 <RebelBunny> wow
23:34:00 <mikeplus64> dada_cetacean: the problem is that the first character of 'larger' on line 5 isn't in alignment with the first character of smallerOrEqual
23:34:12 <zzing_> dada_cetacean, put it in a haskell file
23:34:15 <otters> the quicksort algorithm requires a mutable data structure
23:34:20 <zzing_> you are trying to find a function in ghci
23:34:28 <mikeplus64> dada_cetacean: so the solution is to simply press backspace a few times on the whitespace before "larger"
23:34:46 <RebelBunny> otters: Oh
23:35:37 <dada_cetacean> I tried that and it still gives the same error, maybe its because I'm using notepad?
23:35:44 <mikeplus64> it works for me
23:35:46 <zzing_> otters, don't think so: http://en.wikipedia.org/wiki/Quicksort#Simple_version
23:36:16 <otters> oh, huh, you're not kidding
23:36:20 <mikeplus64> dada_cetacean: make sure it's using spaces and not tabs, notepad might have different ideas of what a tab is than ghc (so it might look right in notepad, but wrong to ghc)
23:36:22 <otters> I never knew that
23:36:34 <dada_cetacean> oh, I get it, Haskell interprets alignment by counting characters
23:36:40 <otters> yes sir
23:36:45 <mikeplus64> yeah
23:36:50 <dada_cetacean> works now, thanks!
23:36:53 <mikeplus64> np
23:37:07 <otters> part of what makes it so concise and readable
23:37:30 <isomorphic> If I have a function with the signature f :: a -> (b -> c) -> d,  how would you recommend I think about the argument (b -> c) ?
23:37:48 <mikeplus64> isomorphic: as a function
23:37:54 <isomorphic> ie:  As a function that gets passed into to be called by f?
23:38:20 <RebelBunny> otters: I'm just amazed at how concise that is... it takes so few lines to write quicksort in hs
23:38:40 <Anpheus_> Greetings, folks! I'm doing some HTML editing using HXT and it's choking on <script> tags, specifically, it's seeing javascript inside with other tags in quotes, matching on those and barfing up garbage afterward. Is there any way to fix this?
23:38:51 <mikeplus64> isomorphic: i'd just think of it as an argument of f that happens to be a function
23:39:33 <otters> @pl qs (x:xs) = qs (filter (< x) xs) ++ [x] ++ qs (filter (>= x) xs)
23:39:35 <lambdabot> qs = fix ((`ap` tail) . (. head) . ap (ap . (liftM2 (++) .) . (. (filter . flip (<))) . (.)) (liftM2 (.) (:) . (. (filter . flip (>=))) . (.)))
23:39:38 <otters> oh, dear
23:40:31 <zzing_> @src (System.FilePath.</>)
23:40:31 <lambdabot> Source not found. Are you on drugs?
23:40:37 <zzing_> :t (</>)
23:40:40 <lambdabot> Not in scope: `</>'
23:45:28 <shachaf> otters: That's not quicksort.
23:45:48 <ClaudiusMaximus> Anpheus_: which html version?  personally when i write xhtml with embedded scripts and css, i wrap the interior with  /* <![CDATA[ */ ...realstuffhere... /* ]]> */  so i don't have to worry about any breakage
23:45:50 <otters> schlumpi: that's what I just told them, and they said I was wrong
23:45:57 <shachaf> s/otters/RebelBunny/, I guess.
23:45:58 <otters> shachaf: ^
23:46:01 <otters> my bad schlumpi
23:46:05 <obiwahn> how can i dump vixen's state plain text to disk so that i can add more REs
23:46:35 <shachaf> obiwahn: You shouldn't.
23:46:53 <obiwahn> shachaf: but how do i add stuff?
23:49:11 <shachaf> obiwahn: You shouldn't.
23:49:23 <obiwahn> why?
23:50:40 <Anpheus_> Are there any HTML5 compliant parsers for Haskell?
23:52:10 <mikeplus64> Anpheus_: for actually parsing html there is tagsoup and a few others (search html on hoogle)
23:52:38 <mikeplus64> i don't know whether it's html5 compliant
23:52:48 <Anpheus_> If I want to generate a new document from the original by modifying it via something like HXT
23:52:52 <Anpheus_> Is that possible?
23:53:35 <SoupEvil> oh hxt isn html5 rdy? :(
23:53:49 <Anpheus_> no.
23:54:04 <Anpheus_> <script> var x = "<ruinyourday>" </script>
23:54:20 <SoupEvil> i will guide it to my prof, he is the father of this api
23:54:41 <Anpheus_> AFAIK, that makes it not even XHTML ready, or HTML 4 ready
23:54:42 <SoupEvil> maybe he can call out some student labor
23:54:48 <Anpheus_> that would be fantastic
23:55:15 <mikeplus64> Anpheus_: one way or another it's possible to do it, i'm not sure of the most convenient though
23:55:17 <Anpheus_> I think script is the only html element whose contents can contain unescaped XML-like elements that won't be parsed
23:56:54 <shachaf> Anpheus_: I think that's invalid XHTML.
23:57:30 <Anpheus_> ah, you're right
23:57:58 <obiwahn> shachaf: would you explain it to me?
23:58:45 <otters> that's why you put inline javascript in CDATA tags
23:59:02 <dada_cetacean> is this correct? "let" is where I define a bunch of nested local variables and then "in" is where I use them all in the function definition
23:59:33 <kam> curious: how's the library support for haskell?
23:59:52 <shachaf> dada_cetacean: It's vague, but more or less.
23:59:57 <shachaf> Except let has nothing to do with functions.
