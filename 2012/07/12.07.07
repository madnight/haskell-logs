00:25:47 <Nereid> since when did Num not have Eq/Show as superclasses?
00:26:46 <shachaf> Since GHC something.something broke the spec.
00:51:06 <wubino> any good reads on creating a pastebin like service?
00:51:26 <Nereid> why do we need another one?
00:51:46 <WraithM> @pl flip x y
00:51:47 <lambdabot> flip x y
00:52:10 <wubino> We don't, but I would like to learn the language by creating my own via haskell.
00:52:33 <Nereid> ok.
00:53:43 <m3ga> wubino: look at either yesod or snap.
00:53:54 <m3ga> @where yesod tutorial
00:53:55 <lambdabot> I know nothing about yesod.
00:54:10 <m3ga> @google yesod tutorial
00:54:11 <lambdabot> http://yannesposito.com/Scratch/en/blog/Yesod-tutorial-for-newbies/
00:54:11 <lambdabot> Title: Haskell web programming
00:54:19 <m3ga> wubino: ^^^^^^
00:54:43 <Kuraitou> What do you call it when you have one type preceeding another (not separated by ->) in a type signature?
00:55:37 <Kuraitou> such as in: fmap :: (a -> b) -> f a -> f b
00:55:42 <Kuraitou> the f a and f b parts
00:55:43 <dmwit> Type application.
00:56:13 <Kuraitou> Does it mean that type 'f' needs one type to be applied to it to become concrete?
00:56:20 <dmwit> yes
00:56:29 <Kuraitou> Alright thanks :)
00:56:34 <shachaf> Kuraitou: "concrete" isn't the standard word for it.
00:56:39 <dmwit> There's a little mini type system for types called "kinds".
00:56:42 <Kuraitou> What is the correct term?
00:56:49 <shachaf> Hmm, what *is* the correct term?
00:56:54 <dmwit> f :: * -> *; a :: *; therefore, f a :: *
00:56:56 <shachaf> You might say "of kind *"
00:57:24 <Kuraitou> Concrete kind, then? Or just drop 'concrete' entirely?
00:58:04 <dmwit> You could call "f a" a saturated type.
00:58:18 <dmwit> And say "f" needs one argument to be saturated.
01:00:16 <silver> can we say "polymorphic type"?
01:00:16 <dmwit> If you say "concrete type", I think most people will take that to mean both of kind * and monomorphic.
01:00:25 <silver> (for f)
01:00:49 <Nereid> that doesn't mean what you want it to.
01:00:54 <Nereid> a is a polymorphic type.
01:00:55 <dmwit> Sure, f is polymorphic. All type variables are.
01:01:05 <shachaf> Nereid: No, "forall a. a" is a polymorphic type. :-)
01:01:16 <Nereid> the "forall a" is implicit
01:01:35 <shachaf> It's implicit as part of a ::, not as part of an "a".
01:01:49 * shachaf wonders if anyone would call "exists a. a" polymorphic.
01:02:18 <Nereid> can it be specialized?
01:02:47 <ski> shachaf : any context using it must be polymorphic ..
01:03:08 <Nereid> it's copolymorphic. :-)
01:03:41 <ski> shachaf : i think "concrete (type)" is a common term
01:04:22 <shachaf> ski: Yes, but it typically means "monomorphic", doesn't it?
01:04:24 <dmwit> "import Data.Complex -- for complex examples" lol
01:04:46 <edsko> how long does an upload to hackage usually take?
01:04:49 <dmwit> As I said above, I would expect a concrete type to be both monomorphic and saturated.
01:04:54 <edsko> cabal upload <<new package>>
01:04:58 <edsko> -- wait.. wait.. wait..
01:05:08 <edsko> oh, wait. "500 Internal server error"
01:05:08 <dmwit> edsko: size of tarball / your Internet connection speed
01:05:28 <edsko> tarball: 6.5 kb. connection speed: 3 MB up, 30 down. should be fast :)
01:05:28 <ski> (also, `forall a. a' isn't a polymorphic type. `reverse' is a polymorphic function (since it has universal type); a polmorphic type could be e.g. a type `Flip' with kind `forall k0 k1. (k1 -> k0 -> *) -> k0 -> k1 -> *')
01:05:39 <dmwit> edsko: agreed
01:05:48 <edsko> something wrong with hackage?
01:06:03 <adnap> in the haskell ffi, is a ".h" file expected in "foreign import ccall "foo.h foo". i have an example that compiles with this syntax, but when i rename foo.h and foo.c to foo.hpp and foo.cpp respectively, i get an "undefined reference to `foo'" error
01:06:26 <ski> shachaf : "it typically means \"monomorphic\", doesn't it?" -- not to my knowledge
01:06:50 <dmwit> adnap: GHC ignores headers, and g++ uses extension to decide how to compile a file.
01:07:20 <dmwit> adnap: Look up C++ name mangling, and you have all the pieces.
01:08:24 * hackagebot network-transport 0.2.0 - Network abstraction layer  http://hackage.haskell.org/package/network-transport-0.2.0 (EdskoDeVries)
01:13:24 * hackagebot network-transport-tcp 0.2.0 - TCP instantation of Network.Transport  http://hackage.haskell.org/package/network-transport-tcp-0.2.0 (EdskoDeVries)
01:14:53 <walt0r> Is there any document talking about type confer ? for example how to confer concatMap .  replicate to get Int -> [b] -> [b] ?
01:15:14 <sipa> confer?
01:15:27 <sipa> :t concatMap . replicate
01:15:29 <lambdabot> forall b. Int -> [b] -> [b]
01:16:27 <walt0r> I just want to know the ghci infer steps
01:17:59 <silver> types?
01:18:13 <walt0r> sipa: yes, types
01:18:26 * hackagebot distributed-process 0.2.0 - Cloud Haskell: Erlang-style concurrency in Haskell  http://hackage.haskell.org/package/distributed-process-0.2.0 (EdskoDeVries)
01:18:28 * hackagebot distributed-process-simplelocalnet 0.2.0 - Simple zero-configuration backend for Cloud Haskell  http://hackage.haskell.org/package/distributed-process-simplelocalnet-0.2.0 (EdskoDeVries)
01:18:31 <silver> walt0r, http://en.wikipedia.org/wiki/Hindley%E2%80%93Milner
01:18:35 <silver> (I guess)
01:19:16 <walt0r> silver: thx, seems complicated
01:19:51 <sipa> walt0r: you mean type inference?
01:20:05 <walt0r> sipa: yes, exactly
01:20:31 <sipa> haskell uses hindley-milner with some extensions for that, afaik
01:21:17 <walt0r> sipa: Hindley–Milner, I see. thx
01:21:21 <edsko> "some extensions"? hah :)
01:21:36 <edsko> walt0r: http://research.microsoft.com/en-us/um/people/simonpj/papers/higher-rank/index.htm is a nice paper about it
01:22:40 <dmwit> walt0r: Actually, you can get the type of concatMap . replicate with much less sophisticated machinery than full Hindley Milner.
01:22:55 <dmwit> You should be able to get away with just plain old unification for that snippet.
01:23:06 <dmwit> And unification is useful and easy to understand, so I encourage you to learn a bit about it!
01:23:12 <dmwit> =)
01:23:20 <walt0r> dmwit: great! thx
01:23:22 <ski> walt0r : see "Polymorphic Type Inference" by Michael I. Schwartzbach in 1995-03 at <http://cs.au.dk/~mis/typeinf.pdf>
01:23:26 * hackagebot tskiplist 0.1.1 - A Skip List Implementation in STM  http://hackage.haskell.org/package/tskiplist-0.1.1 (PeterRobinson)
01:26:30 <walt0r> edsko: yes it is a nice paper
01:27:07 <walt0r> ski: this is the shortest ones, I like it.
01:27:17 * edsko could probably recite that paper in its entirely during his PhD -- studied it extensively :)
01:28:06 <dmwit> :t Const
01:28:07 <lambdabot> forall a b. a -> Const a b
01:28:15 <dmwit> > fmap (+1) (Const 3)
01:28:17 <lambdabot>   No instance for (GHC.Show.Show (Control.Applicative.Const t a))
01:28:17 <lambdabot>    arising ...
01:28:26 <dmwit> > getConst (fmap (+1) (Const 3))
01:28:27 <lambdabot>   3
01:28:44 <dmwit> Why doesn't Const have a Show instance? That's weird.
01:31:01 <fmap> same for ZipList
01:31:43 <ion> > Sum 42
01:31:44 <lambdabot>   Sum {getSum = 42}
01:31:48 <ion> > Identity 42
01:31:50 <lambdabot>   No instance for (GHC.Show.Show (Data.Functor.Identity.Identity t))
01:31:50 <lambdabot>    arisi...
01:32:16 <dmwit> really strange
01:32:39 <noor__> Hello and greetings, I have been messing around with the idea of haskell for a couple of years now and now am ready to look through the prelude to see if I can finally understand the IO monad. I am on OS 10.7 and have installed the latest versions of the haskell platform and xcode. I have looked through every library on my system and searched for "haskell" "GHC" and "prelude" and have been able to locate no Haskell source. Where would one
01:32:39 <noor__> find The Prelude in such a situation? THANK YOU.
01:32:46 <dmwit> Maybe so some transformers over Identity can have a Show instance that skips the Identity bit...??
01:33:07 <dmwit> noor__: It's specified in the Report.
01:33:09 <dmwit> ?where report
01:33:10 <lambdabot> http://www.haskell.org/onlinereport/haskell2010/ (more: http://www.haskell.org/haskellwiki/Definition)
01:33:19 <dmwit> But you won't learn IO by reading the Prelude.
01:33:21 <noor__> I want to see the actual thing. The source
01:33:33 <dmwit> In that case, look on Hackage at the "base" package.
01:33:36 <dmwit> ?hackage base
01:33:36 <lambdabot> http://hackage.haskell.org/package/base
01:34:01 <noor__> where should one install this so GHC is happy?
01:34:18 <noor__> and also shouldn't that already be on my system?
01:34:22 <dmwit> huh, Hackage doesn't have it
01:34:23 <ion> It’s already installed if GHC is happy.
01:34:34 <dmwit> noor__: GHC comes with a pre-compiled Prelude.
01:34:41 <dmwit> If you can read assembly, be my guest.
01:34:53 <dmwit> But you won't like it unless you're already an STG-machine expert.
01:34:58 <noor__> AH PRECOMPILED where does Cabal put things?
01:35:45 <dmwit> Here we go: http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/src/Prelude.html
01:35:45 <ion> ~/.cabal
01:35:52 <noor__> is there a good cabal command to get that through the terminal?
01:35:58 <edsko> noor__: you will need to install the ghc source distribution
01:36:02 <edsko> that will have all the sources
01:36:04 <dmwit> noor__: I suspect that asking where Cabal puts things is the wrong question, given the thread so far.
01:36:10 <edsko> but it's very unlikely to enlighten you
01:36:18 <dmwit> noor__: If you want to find out where GHC keeps the precompiled library, you can ask via "ghc-pkg describe base".
01:36:44 <noor__> no no, I want to use Cabal to get the base package.
01:36:50 <dmwit> You can't.
01:36:52 <dmwit> Sorry.
01:36:56 <noor__> ??
01:37:06 <noor__> I thought that was its purpose????
01:37:10 <noor__> I DID
01:37:29 <ion> (cabal unpack base does work.)
01:38:45 <dmwit> You're right. I stand corrected.
01:38:47 <noor__> Oh man cabal put it in ~/ thats no good...
01:39:07 <noor__> how do I fix that?
01:39:15 <ion> Move it somewhere else
01:39:27 <noor__> NO SO LIKE WHEN I COMPILE AND STUFF IT JUST KNOWS!
01:39:31 <ion> To be more accurate, it unpacked the source in .
01:39:49 <noor__> what do you mean unpacked?
01:39:49 <dmwit> noor__: GHC comes with base. You don't need to install it separately.
01:39:55 <noor__> didn't it download it?
01:40:14 <noor__> so wait it DECOMPILED the base???
01:40:18 <ion> …
01:40:20 <silver> no
01:40:23 <dmwit> wut
01:40:36 <noor__> where was it before that cabal command?
01:40:37 <ion> You wanted to look at the source. The command you ran unpacked it for you to inspect.
01:40:47 <noor__> yes but where was it?
01:40:57 <ion> On haskell.org
01:41:05 <noor__> THATS WHAT I SAID UUUHG
01:41:35 <dmwit> noor__: Look, it's like this. There's source, and there's the compiled library. GHC comes with a compiled library; the source is also available on Hackage. When you use the "cabal" command, you are transferring source from Hackage to your computer; however, that's not a prerequisite for using the already-installed, pre-compiled library.
01:41:56 <dmwit> You can use "ghc-pkg describe base" to find out where on your hard disk the pre-compiled library lives.
01:42:02 <noor__> perfect :) ok thank you all
01:42:06 <noor__> bye bye
01:42:11 <dmwit> You can use "cabal unpack base" to unpack a tarball from Hackage to inspect the source.
01:42:16 <silver> BYE!!!!
01:42:24 <sipa> KTHXBYE
01:42:36 <ion> BYE BYE UUUUH???!
01:42:44 <silver> :D
01:43:29 <noor__> wait what language is that??
01:43:37 <ion> English
01:43:52 <noor__> good, next?
01:43:58 <Enigmagic> olde trollish
01:44:03 <sipa> what language is what?
01:44:21 <noor__> http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/src/Prelude.html
01:44:24 <silver> say waht again
01:44:24 <roconnor_> do type signatures need to preceed the function definition?
01:44:36 <dmwit> noor__: That's Haskell.
01:44:47 <ion> > {- roconnor -} let foo = 42; foo :: Integer in foo
01:44:48 <lambdabot>   42
01:44:55 <dmwit> With a touch of C pre-processor. =/
01:44:56 <roconnor_> :)
01:45:06 <noor__> tell me more..
01:45:18 <sipa> noor__: or if you're really pedantic, it is HTML
01:45:19 <dmwit> noor__: You need to say what more you want to know.
01:45:31 <dmwit> If you just want a Haskell tutorial, I recommend
01:45:33 <dmwit> ?where lyah
01:45:34 <lambdabot> http://www.learnyouahaskell.com/
01:45:35 <dmwit> ?where rwh
01:45:35 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
01:45:39 <noor__> I WANT KNOW THINGS FOR DO HASKEL GOOD
01:45:44 <dmwit> Because I don't think you're patient enough for
01:45:46 <dmwit> ?where gentle
01:45:47 <lambdabot> http://www.haskell.org/tutorial/
01:46:14 <ion> I wonder if anyone has written a Haskell tutorial for trolls?
01:46:15 <noor__> Look, I'm trying to understand the damn language. I know all the other places to look
01:46:35 <noor__> what is this bit about C preprocessor?
01:46:45 <Enigmagic> noor__: have you tried google?
01:46:53 <noor__> maybe..
01:46:56 <noor__> once
01:46:59 <noor__> a long time ago
01:47:13 <sipa> noor__: if you're starting from scratch, the best way is reading a tutorial, and if after that you still have questions, start googling, ask around, ask here
01:47:14 <chu> In a galaxy far far away
01:47:15 <dmwit> The C preprocessor is used in the page you linked to choose different implementations of the Prelude depending on which compiler is being used.
01:47:20 <Enigmagic> since you know all the other places to look..
01:47:31 <dmwit> The lines that start with # are CPP commands.
01:47:32 <sipa> noor__: you can't expect us to explain the whole language to you
01:47:42 <dmwit> It should be relatively clear what they do given this information and a working knowledge of English.
01:47:54 <ion> chu++
01:49:29 <raek> noor__: on Hoogle there are source links for the entries
01:49:44 <noor__> I thought I didn't see them
01:50:29 <raek> for example, docs: http://hackage.haskell.org/packages/archive/base/latest/doc/html/Prelude.html#v:map
01:50:38 <raek> source: http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/GHC-Base.html#map
01:50:39 <dmwit> By the way, you won't endear yourself to Haskell enthusiasts by swearing at the language. We're happy to help, but please be civil.
01:51:04 <noor__> huh??
01:51:46 <noor__> k dimwit is a bot written clearly in lolcode
01:52:41 <sipa> which would be quite imptessive, actually...
01:52:45 <sipa> impressive
01:52:55 <ion> Everyone, let’s stop feeding the troll, it’ll get bored and go away.
01:53:36 <roconnor_> cabal install template-haskell-2.7.0.0  fails for me
01:53:50 <roconnor_> Language/Haskell/TH/PprLib.hs:55:10:
01:53:51 <roconnor_>     Illegal instance declaration for `Show Doc'
01:53:53 <roconnor_>       (All instance types must be of the form (T t1 ... tn)
01:54:09 <dmwit> ghc --version?
01:54:21 <dmwit> It seems like it must have worked at some time in the past for me, since I have it installed.
01:54:24 <dmwit> on 7.4.1
01:54:26 <hpaste> WraithM pasted “Passing around generators” at http://hpaste.org/71038
01:54:33 <roconnor_> The Glorious Glasgow Haskell Compilation System, version 7.0.4
01:54:52 <WraithM> So, I know I'm doing this wrong... I'm not thinking about random number generation right.
01:55:12 <dmwit> Okay, I only have TH-2.4 and 2.5 on 7.0, let's see if I can reproduce this. =)
01:55:16 <ion> roconnor: Upgrading GHC most likely helps.
01:55:44 <roconnor_> ion: usually upgrading software makes things worse
01:56:32 <dmwit> Oh, boy.
01:56:45 <dmwit> That error is easy to fix, but the next one is harder. =)
01:57:11 <dmwit> WraithM: Uh, "g" is a StdGen.
01:57:15 <WraithM> Yeah
01:57:17 <dmwit> Why are you trying to get a "new" one?
01:57:21 <WraithM> Oh, ignore those errors
01:57:23 <WraithM> I fixed those
01:57:34 <nand`> roconnor_: my experiences with Haskell have been the opposite, probably since most maintainers update right away
01:57:43 <roconnor_> nand`: oh
01:57:49 <WraithM> Because randlrs doesn't spit out a generator, it spits out an infinite list.
01:58:01 <WraithM> I need a generator for the next infinite list
01:58:20 <dmwit> Well, there's the "split" function.
01:58:24 <nand`> roconnor_: but some old / unmaintained things might not compile with newer GHC versions; people usually keep around older installations in separate paths for rare cases like that
01:58:27 <WraithM> Oh?
01:58:28 <dmwit> ?hoogle StdGen -> (StdGen, StdGen)
01:58:29 <lambdabot> System.Random split :: RandomGen g => g -> (g, g)
01:58:29 <lambdabot> Network.BufferType buf_span :: BufferOp a -> (Char -> Bool) -> a -> (a, a)
01:58:29 <lambdabot> Network.BufferType buf_splitAt :: BufferOp a -> Int -> a -> (a, a)
01:58:42 <nand`> WraithM: is this about getting a list of random lists?
01:58:43 <roconnor_> nand`: ya, that is easy to do in nix
01:58:53 <WraithM> nand`: Nope. I can do that actually.
01:59:12 <roconnor_> although nix and cabal-install don't play so well together :/
01:59:23 <WraithM> I guess I need to split. That's clearly what I need to do.
02:00:07 <dmwit> roconnor_: So, yeah, you'll need to upgrade GHC to use TH-2.7, or implement showMultiLineString yourself.
02:00:10 <WraithM> Thanks!
02:00:40 <roconnor_> dmwit: or ... change the constraing on lens-family-th to allow TH-2.5
02:00:57 <dmwit> Right, or use an older TH.
02:01:55 <hpaste> WraithM annotated “Passing around generators” with “Passing around generators (annotation)” at http://hpaste.org/71038#a71039
02:02:02 <WraithM> There we are
02:02:04 <WraithM> I think I fixed it
02:02:20 <dmwit> nooo
02:02:28 <dmwit> You must use both the outputs of split.
02:02:30 <dmwit> And not use its input.
02:02:47 <WraithM> Oh
02:02:54 <dmwit> (...(randlrs g'), g'') where (g', g'') = split g
02:03:01 <WraithM> I see
02:03:18 <WraithM> Thank you!
02:03:32 <WraithM> Perfect
02:04:09 <WraithM> Yeah, I haven't gotten quite used to throwing around random numbers yet.
02:04:56 <kallisti> I'm apparently missing profiling libs for base?
02:05:36 <kallisti> got a "missing Prelude" error in Codec.Binary.UTF8
02:05:48 <kallisti> and suggested that profiling may not be enabled for base.
02:08:10 <kallisti> ah I need ghc-prof
02:09:04 <noor__> http://imageshack.us/photo/my-images/411/screenshot20120707at204.png/
02:09:15 <noor__> how does do know to put the result in the list monad?
02:09:15 <nand`> WraithM: are you sure you don't want (g1, g2) = split g; and randlrs g1 ?
02:09:50 <noor__> type signature?
02:09:57 <noor__> is it required in this instance?
02:10:05 <merijn> noor__: Type inference (including the signature, for example)
02:10:26 <nand`> WraithM: though I'll admit I don't exactly know what rules “split” is meant to adhere to, ie. if g is distinct from snd (split g) in a secure way
02:10:47 <noor__> alls I'm saying is that code blew my mind a little.
02:11:08 <merijn> noor__: Do you know the desugaring rules for do syntax? That might help, I think
02:11:16 <noor__> nope
02:11:23 <noor__> well kinda
02:11:40 <dmwit> nand`: Already covered that bug.
02:11:51 <nand`> it knows the result is in the list monad because of the line “i <- [1..n]” which binds i from a list
02:11:52 <noor__> its just that I mean like the monad is holding state information… TELL ME WHEN I'M OUT OF LINE....
02:12:01 <nand`> dmwit: oh, did not see. my bad
02:12:10 <merijn> @undo do { i <- [i..n]; j <- [(i+1)..n]; return (i,j) }
02:12:10 <lambdabot> [i .. n] >>= \ i -> [(i + 1) .. n] >>= \ j -> return (i, j)
02:12:26 <dmwit> noor__: You're out of line.
02:12:35 <dmwit> The list monad doesn't hold any state.
02:12:54 <merijn> Do notation just translates "x <- a; f x" into "a >>= \x -> f x"
02:12:56 <noor__> sorry I just don't understand how you take a list out of the list monad
02:13:10 <dmwit> ?
02:13:16 <merijn> The type of ">>=" is
02:13:19 <merijn> :t (>>=)
02:13:20 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
02:13:23 <dmwit> I don't even know what "take a list out of the list monad" could mean.
02:13:32 <dmwit> Lists are a data type.
02:13:33 <WraithM> nand`: What you suggested is what I ended up doing. I posted a goof.
02:13:41 <merijn> Whcih in the case of lists specialises to "[a] -> (a -> [b]) -> [b]"
02:13:56 <dmwit> The list monad is an English phrase that packages up the list type and two operations on list into a compact word.
02:14:47 <merijn> The list monad is no a thing separate from a list, it's just that lists happen to implement the monad typeclass
02:14:48 <raek> noor__: (for lists) you use the >>= operator to stitch together operations of type a -> [a]. you can't use ordinary function composition here since the in and out types are not the same.
02:15:20 <dmwit> That was a bit fast, though roughly accurate.
02:15:32 <\rs> any good papers on introducting recursion schemes like catamorphism? (http://comonad.com/haskell/catamorphisms.html seems to be abstruse)
02:15:36 <dmwit> Expanding on that a bit: suppose you have two functions of types "a -> [b]" and "b -> [a]". How do you combine them?
02:15:48 <noor__> heres what I'm thinking, and I did not examine the very important stuff that came before: x <- (IO a) returns an a, so what does x <- (List a) return??
02:15:54 <dmwit> err, I meant, and "b -> [c]", of course.
02:16:03 <merijn> noor__: an a
02:16:14 <dmwit> You can't immediately feed the output of the first function to the second, because the output of the first is a list, and the second doesn't know what to do with lists.
02:16:15 <raek> (ah, yes. of course it doesn't need to be "a" in both the input and output)
02:16:40 <dmwit> noor__: IO a isn't a value that you can bind. Neither is List a.
02:16:48 <merijn> noor_: Did you see a bit earlier when I said that "x <- a; f x" is just sugar for "a >>= \x -> f x"?
02:16:53 <noor__> but then it just kind of know that its in a double loop and that it should be a list again…… how??
02:16:57 <raek> noor__: <- is not a real operator. it's just a piece of the do syntax.
02:17:10 <noor__> go away dmwit
02:17:28 <raek> that is, (<-) is not an expression that you can reson about the type of
02:17:30 <sipa> noor__: type inference makes sure types always work about
02:17:41 <merijn> Now the type of ">>=" is "m a -> (a -> m b) -> m b", which for lists happens to be "[a] -> (a -> [b]) -> [b]"
02:17:59 <dmwit> Wow. That was really, really rude.
02:18:20 <sipa> @where ops
02:18:20 <lambdabot> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
02:18:40 <noor__> k gonna think for a bit be back maybe
02:18:42 <merijn> noor__: If we start with "do { i <- [i..n]; j <- [(i+1)..n]; return (i,j) }" that translates to "[i..n] >>= \i -> do { j <- [(i+1)..n]; return (i.j) }"
02:19:19 <NoICE> =-o
02:19:36 <noor__> can you iterate that again and get rid of the second do?
02:19:36 <merijn> Which in turn becomes "[i..n] >>= \i -> ([(i+1)..n] >>= \j -> do { return (i,j) })"
02:20:11 <sipa> NoICE: is that two hands holding a cooking pan?
02:20:15 <noor__> ah makes perfect sense thank you
02:20:25 <merijn> Eventually resulting in "[i..n] >>= \i -> ([(i+1)..n] >>= \j -> (i,j))"
02:20:35 <NoICE> sipa: Maybe.
02:20:41 <dmwit> \j -> [(i,j)], I guess
02:20:45 <merijn> oh
02:20:47 <merijn> Yeah
02:20:47 <noor__> just decided that I don't like dos
02:20:49 <merijn> Fail on me
02:21:03 <dmwit> I thought it was a good explanation.
02:21:24 <merijn> noor__: It depends for Maybe it can be very nice for example
02:21:42 <merijn> Because one Nothing will short-circuit the entire do block to Nothing
02:21:46 <noor__> I'll take your word
02:22:04 <merijn> So you avoid having to constantly check the return value
02:23:25 <merijn> In other news, how do I impact where cabal/ghc look for C libraries when linking?
02:23:38 <merijn> DYLD_LIBRARY_PATH/LD_LIBRARY_PATH?
02:23:59 <dmwit> eh, just pass linker flags?
02:24:47 <dmwit> -L and friends?
02:24:56 <merijn> dmwit: Just the -L flag you mean?
02:24:58 <dmwit> yes
02:25:24 <merijn> dmwit: Not sure that'll work in the case where it by default seems to be linking/finding the wrong library...
02:26:27 <favonia> merijn: if they are using pkg-config, PKG_CONFIG_PATH might be the answer
02:26:50 <merijn> \o/
02:26:52 <dmwit> "Directories specified on the command line are searched before the default directories."
02:26:52 <merijn> -L works
02:27:10 <dmwit> from man ld
02:27:21 <noor__> OK, let me just ask the twenty billion dollar question: lets say I want to do some kind of new IO that hasn't even been invented yet. Where do I put the code to tell it to talk to real resources and what language do I need to write that in?
02:27:50 <dmwit> The FFI spec covers interfacing with C.
02:28:02 <noor__> so C is the only way?
02:28:10 <dmwit> For a question this vague, yes.
02:28:11 <noor__> what if I want to write it in assembly?
02:28:21 <dmwit> You interface with assembly from C.
02:28:47 <noor__> so I call haskell to run c to run assembly. efficient
02:29:35 <dmwit> You are silently assuming that language boundaries are inefficient.
02:29:49 <barrucadu> If you want great efficiency, Haskell probably isn't really the language of choice
02:30:05 <noor__> well that solves that I pronounce dimwit to be the most helpful and knowledgeable personage in #haskell
02:30:42 <nand`> The C interface doesn't actually require C, does it? It just requires the C ABI
02:30:48 <favonia> noor__: as long as you obey the same calling and naming convension, there's no difference between using assembly or c
02:31:28 <noor__> what type of extension does the "c" file need and does it get compiled into the final binary?
02:31:29 <nand`> barrucadu: why?
02:31:36 <merijn> @tell Peaker Bottle compiles on OSX \o/ But the interface looks completely broken in ways which are hard to describe...I'll send you a screenshot when I run into you online
02:31:36 <lambdabot> Consider it noted.
02:32:09 <barrucadu> nand`: Ah, I suspected that was a bad thing to say... I admit I haven't looked into it, but I thought the conventional wisdom was that functional languages have something of an overhead
02:32:47 <favonia> noor__: if you just want to call c functions from Haskell, usually you can keep the c files intact
02:32:48 <merijn> barrucadu: Yes, but haskell is probably still more efficient than most languages in use
02:33:12 <merijn> barrucadu: If I had to name faster languages in semi-common use I could come up with maybe C/C++ and ocaml?
02:33:29 <noor__> I think thunks give a small space inefficiency but I don't think its murderous, I think really language paradigm barriers  and bad programming practice are the real killers as far as I know
02:33:51 <merijn> Pretty sure Java, Go and friends are roughly in the same ballpark as Haskell and python, javascript, ruby and languages like those are orders of magnitude slower
02:33:54 <nand`> the concept of a “fast language” I think is irrelevant. You're talking about language implementations, and also how they behave when exposed to different algorithms (with identical semantics)
02:34:07 <dmwit> The rule of thumb five years ago was that idiomatic Haskell would run about half as fast as idiomatic C. But since then it's gotten much easier to write fast, idiomatic code thanks to the introduction of some magical libraries.
02:35:32 <merijn> @tell Peaker The magical solution to the problem would be to pass '--ghc-options="-L/usr/lib/"' to cabal install so that it is guaranteed to find the system libiconv first.
02:35:32 <lambdabot> Consider it noted.
02:35:38 <noor__> OOH OHH I have a question: is type checking done at compile or run time??
02:35:46 <merijn> noor__: Compile time, of course
02:35:49 <dmwit> merijn: Why not use cabal's extra-lib-dirs?
02:35:55 <nand`> but note that pure languages (ones that preserve referential transparency) have inherent advantages when it comes to multicore optimization, since you don't need to worry about side effects racing
02:36:08 <noor__> can haskell receive code at runtime????
02:36:09 <dmwit> merijn: Let cabal work out what GHC options to use to make it work. =)
02:36:13 <nand`> so I imagine as compilers get more and more sophisticated and environments get more and more parallel that functional languages will start pulling ahead
02:36:20 <merijn> dmwit: I tried that (I think?)
02:36:33 <noor__> I mean if you really try to break things?
02:36:39 <dmwit> merijn: At the very least use ld-options instead of ghc-options.
02:36:44 <merijn> dmwit: The problem is that it was finding libiconv, but the wrong version (i.e. from macports) breaking base
02:37:19 <dmwit> What command does cabal -vvv say it's using? Surely extra-lib-dirs just translates to a -L anyway...
02:37:20 <nand`> (also since Haskell guys know about nice things like list/tree homomorphisms that make multicore optimization much easier)
02:37:26 <merijn> noor__: There is a GHC library which can compile code at runtime and then load it. Which is kinda but not exactly what you asked
02:37:46 <noor__> no its better
02:38:13 <merijn> dmwit: It could be, I haven't really tried this was the first thing that happened to work. I can play around with getting a "good" or "neat" solution later
02:38:14 <noor__> can someone link me to a resource that will tell me how to call C functions such that they end up in the final binary?
02:38:23 * dmwit nods supportively
02:38:32 <dmwit> ?where ffi
02:38:33 <lambdabot> http://www.haskell.org/onlinereport/haskell2010/haskellch8.html
02:38:37 <dmwit> noor__: ^^
02:38:39 <merijn> noor__: Just google for "haskell ffi"? (Foreign Function Interface)
02:38:46 <merijn> Or that link, I guess :p
02:39:20 <favonia> noor__: actually thunks are just a common way to implement Haskell. if that really bothers you, pick an ML-family language like ocaml or standard ml. btw GHC amazingly removes lots of unnecessary creation of thunks
02:39:38 <noor__> why do you really need to go to C to do proper IO, this seems like a language flaw to me...
02:40:12 <noor__> No thunks don't bother me I LIKE laziness :))
02:40:31 <nand`> noor__: what's improper about ‘IO’?
02:40:55 <sipa> noor__: give me an example of a language that doesn't need to go to C for custom low-level stuff?
02:41:04 <noor__> That you don't seem to have a way to point to arbitrary systems resources
02:41:15 <mroman> :t (&&&))
02:41:16 <raek> noor__: can't you just implement your own IO thingy in terms of the existent IO type?
02:41:17 <lambdabot> parse error on input `)'
02:41:20 <mroman> :t (&&&)
02:41:23 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
02:41:29 <sipa> noor__: can you give an example?
02:41:30 <noor__> I DONT KNOW maybe i can??
02:41:38 <noor__> Lets say hmmm..
02:41:47 <noor__> didn't come prepared.....
02:42:13 <sipa> typically you use the FFI to interface with some library that already is in C
02:42:37 <mroman> @hoogle (t1 -> t2 -> t) -> (t1, t2) -> t
02:42:37 <lambdabot> Prelude uncurry :: (a -> b -> c) -> ((a, b) -> c)
02:42:37 <sipa> but many interesting libraries already have bindings in the form of hackage packages
02:42:37 <lambdabot> Data.Tuple uncurry :: (a -> b -> c) -> ((a, b) -> c)
02:42:37 <lambdabot> Data.IntMap fromAscListWith :: (a -> a -> a) -> [(Key, a)] -> IntMap a
02:42:53 <mroman> Isn't there an arrow function similiar to this?
02:43:28 <noor__> (I AM NOT A CS MAJOR) so um ok an arrow points to.. (ram??)
02:43:45 <merijn> noor__: The only way to do IO/system calls without C is by generating the assembly produced by the C library yourself (since the OS is written in C)
02:43:55 <noor__> is an arrow bound by the allocated memory provided by the OS?
02:44:02 <sipa> noor__: first understand functors, then monads, then arrows
02:44:11 <sipa> noor__: arrows have nothing to do with pointers
02:44:15 <merijn> noor__: Generating your own system call assembly is as efficient as just calling the assembly produced by the C compiler
02:44:35 <merijn> And the latter is a lot less work
02:44:49 <mroman> ah. &&& is the opposite of what I were looking for.
02:44:50 <noor__> can you give me a sentence on arrows?
02:45:17 <sipa> http://www.haskell.org/arrows/
02:45:21 <merijn> I don't know of a single language that doesn't use the C's system calls to interface with the OS
02:45:33 <pauldoo> I'm having problems getting (<$>) to appear in ghci..  It comes from Data.Functor, fmap is already in scope, but this infix operator isn't…  How do I make it available in ghci ?
02:45:50 <merijn> pauldoo: fmap is exported by the Prelude
02:46:01 <merijn> Did you explicitly import Data.Functor?
02:46:09 <blackdog> pauldoo: try :m +Data.Functor
02:46:16 <pauldoo> merijn:  :m +Data.Functor gives an error
02:46:35 <pauldoo> "Could not find module `Data.Functor'"
02:46:35 <merijn> And this error says...
02:46:36 <blackdog> pauldoo: what error? works here.
02:46:39 <merijn> huh
02:46:51 <merijn> That is...odd
02:46:56 <noor__> in the link what is (a b c) exactly??
02:47:09 <pauldoo> merijn: but that's interesting, perhaps I missed some important packages when I installed ghc..  It's nice to know I was trying the correct haskell code :)
02:47:20 <sipa> noor__: please, follow a haskell tutorial first
02:47:28 <noor__> I did, mostly
02:47:41 <noor__> a b c does not seem well typed
02:47:55 <Nereid> a is an arrow
02:48:03 <noor__> ah
02:48:14 <noor__> so why isn't it Arrow b c?
02:48:18 <Nereid> you would know this if you read the very first line of code on the page
02:48:22 <merijn> pauldoo: So you installed GHC and not Haskell Platform? (I think it should be shipped with GHC, but for all I know it's just in platform)
02:48:23 <dani912> ciao
02:48:25 <Nereid> and knew something about typeclasses
02:48:26 <dani912> !list
02:49:00 <pauldoo> merijn: I installed "ghc" package using MacPorts.  there's perhaps another package for the platform that I missed
02:49:33 <noor__> wait there is no Arrow => a something is wrong.......
02:49:50 <sipa> noor__: look at (>>=)'s type
02:49:54 <sipa> :t (>>=)
02:49:55 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
02:50:21 <sipa> the monad is m here, as its type can be anything for which a monad instance exists
02:50:29 <sipa> similarly, the arrow is a there
02:50:57 <noor__> yes I know in that definition there is no (Arrow a) => a in that deffinion a b c makes no sense in that context
02:51:10 <Nereid> noor__: yes it is, learn how one defines a typeclass
02:51:23 <merijn> pauldoo: I usually just grab the binary Haskell Platform download of OSX
02:51:23 <Nereid> it's "inside" the "class Arrow a where ..."
02:51:27 <merijn> @where platform
02:51:27 <lambdabot> http://hackage.haskell.org/platform/
02:51:31 <sipa> noor__: see "class Arrow a where" on top; that mean's we inside the definition of Arrow itself
02:51:34 <noor__> oh missed the class definition oops
02:51:39 <sipa> so it implies a "Arrow a =>"
02:51:42 <Nereid> as I said, the first line of code on the page.
02:51:44 <noor__> I never read headers :embarrassed:
02:52:05 <sipa> i really need to learn to type
02:52:29 <noor__> is the thunk made of arrows?
02:52:42 <sipa> no
02:52:47 <noor__> then what?
02:52:54 <noor__> nevermind
02:52:55 <noor__> ok
02:53:01 <Nereid> it is made of arrows as much as it is made of monads
02:53:43 <noor__> I don't understand how a monad can hold an IO instruction can someone explain?
02:53:56 <sipa> noor__: first of all, forget that it is a monad
02:54:02 <noor__> done!
02:54:16 <sipa> noor__: that is irrelevant here; your question is how can you have a value that represents a computation
02:54:19 <sipa> right?
02:54:26 <noor__> more or less
02:54:41 <noor__> and also WHERE THE FUCK IS IT but yeah also that
02:54:51 <Nereid> easy. if you're familiar with C, you may know about function pointers.
02:54:57 <noor__> indeed
02:55:06 <noor__> more or less anyway
02:55:44 <noor__> I don't know much about their conventions in assembly but I know what they are and what they do, not how to use them or anything but some idea yes
02:56:24 <Nereid> well the idea is that a function pointer is a value (in this case, an address in memory), which you can execute (run the code that resides at that location)
02:56:56 <mroman> Yes. A function pointer is like any other pointer just an address.
02:57:01 <Nereid> IO values in haskell are a bit more sophisticated than that, but the idea is similar
02:57:02 <noor__> so a type of IO x is hiding a function pointer that agrees to return an x?
02:57:07 <mroman> They have a specific type so the compiler knows how to clean up the stack
02:57:08 <Nereid> something like that
02:57:15 <mroman> and how many arguments to pass and such.
02:57:53 <noor__> I mean the language seem to hide the ability to add a function pointer to the IO monad in any sort of way
02:58:04 <sipa> noor__: the FFI allows you to do that
02:58:08 <noor__> (I don't know the FFI stuff)
02:58:09 <Nereid> if you want to interface with C functions, that's what the ffi is for
02:58:20 <noor__> well there you (me) go
02:58:21 <sipa> noor__: and again, the fact that IO is a monad here is completely irrelevant
02:58:49 <Nereid> IO being a monad just means you can string IO actions together to make new ones.
02:58:51 <Nereid> or something like that
02:58:53 <noor__> I mean in the definition of the type IO, where is it stated that it has a function pointer?
02:58:55 <sipa> basically, yes
02:59:07 <dmwit> IO is not a function pointer.
02:59:12 <mroman> I'm not sure if haskell has the 'concept' of function pointers.
02:59:24 <noor__> …but it contatains a function pointer?
02:59:28 <Nereid> I didn't say IO values were function pointers, just that the idea is similar.
02:59:29 <favonia> noor__: maybe this will help too: imagine that you're trying to simulate some CPU, and IO a just holds the machine codes that can be run on that CPU
02:59:31 <dmwit> No.
02:59:38 <Nereid> I don't know what IO contains. I've never opened up that black box.
03:00:06 <Nereid> and most people shouldn't need to, I imagine.
03:00:34 <sipa> Nereid: it's not defined either; afaik implementation choose how to implement IO
03:00:38 <noor__> I'm saying that type IO may or may not contain instructions in some for to run code that accesses resources, where it that bit defined?
03:00:42 <Nereid> sipa: yes, that is true
03:01:16 <noor__> I guess its not really that important. i can't imagine there is anything that can't be done from a C library.
03:01:17 <mroman> @src IO
03:01:18 <lambdabot> Source not found. Do you think like you type?
03:01:23 <Nereid> noor__: IO is a magical thing that is given to you by God (the compiler).
03:01:26 <XexonixXexillion> noor__: RealWorld is deeply magical
03:01:43 <sipa> noor__: you can even call back to Haskell code from C code, if you need to
03:01:48 <dmwit> Magic is overrated. IO primitives are implemented in the runtime.
03:01:58 <Nereid> to me it's magic.
03:01:59 <noor__> keep going back to it, and lyah and a SUPER magical SECRET book
03:02:07 <dmwit> If you want to read the source code for IO, open up the source of GHC and start diving.
03:02:14 <noor__> if thats even what you were talking about.....
03:02:15 <sipa> any technology sufficiently advanced is indistinguishable from magic
03:02:26 <dmwit> Read the GHC Commentary if you want a guided tour.
03:02:50 <nand`> noor__: http://www.haskell.org/onlinereport/haskell2010/haskellch41.html#x49-32000041
03:03:03 <nand`> sounds like you want to read through this
03:03:07 <noor__> unfortunately my time vacillates between a million different unrelated things and I only go to haskell when particularly inspired
03:03:25 <Nereid> noor__: you should probably just sit down and write some code.
03:03:43 <noor__> I had an idea, but all the clues were too well hidden
03:03:52 <dmwit> You want to understand how it works, but you don't want to spend the time it takes to understand how it works. Color me unimpressed.
03:03:56 <noor__> and the eggs are long rotten I imagine
03:04:09 <noor__> I wanted to make a visual MP3 editor :P
03:04:39 <nand`> why not make a visual PCM editor instead
03:04:41 <nand`> much more useful
03:04:50 <noor__> non compressed
03:04:53 <noor__> non interesting
03:05:05 <mroman> noor__: newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #))
03:05:09 <noor__> mp3 is really just a sparse fft
03:05:09 <mroman> If you were looking for this?
03:05:24 <sipa> noor__: why would the ability to edit music visually be at all related to how the music is stored on disk?
03:05:27 <noor__> YES INDEED thank yo
03:05:37 <nand`> noor__: that's not how IO is defined though
03:05:43 <nand`> noor__: so it isn't what you were asking
03:05:44 <nand`> is it?
03:05:45 <noor__> a visual representation of its bits
03:05:57 <sipa> noor__: a hex editor?
03:06:06 <Nereid> :o)
03:06:15 <noor__> no bytes to pixels
03:06:16 <dmwit> ?google tackling the awkward squad simon peyton jones
03:06:18 <lambdabot> http://research.microsoft.com/~simonpj/papers/marktoberdorf/mark.pdf.gz
03:06:23 <nand`> sipa: why not a binary editor? or a base-256 (ASCII) editor?
03:06:27 <mcstar> what a disappointement of a conversation
03:06:46 <sipa> nand`: idea!
03:07:05 <noor__> I just thought it would be interesting, basically compress the thing to fuck and then draw in the spectrum sounded fun
03:07:13 <merijn> mcstar: Well, they can't all be brilliant in here
03:08:38 <mroman> Some like me don't even have academic credentials :)
03:08:55 <noor__> anyway the mp3 format is far too arcane for me to muster
03:09:08 <sipa> what other programming languages do you know?
03:09:13 <noor__> not a one
03:09:19 <pauldoo> merijn: I've installed the haskell platform (from MacPorts admittedly), and there's a whole host of new modules available to me, but still no Data.Functor.  Do you know which version of the platform first added Data.Functor?  perhaps the MacPorts package is too old
03:09:32 <sipa> in that case, i think you should start with something less challenging first
03:09:42 <nand`> sipa: like Haskell?
03:09:51 <nand`> or do you mean a less challenging task
03:10:01 <noor__> @mroman: where did "newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #))" come from?
03:10:02 <lambdabot> Unknown command, try @list
03:10:18 <pauldoo> merijn: I have platform 2009.2.0.2
03:10:20 <dmwit> You shouldn't need the Platform for Data.Functor, it's in base.
03:10:48 <programm1r> hi
03:10:54 <dmwit> It seems it's been there since base-4.2.0.0
03:10:56 <pauldoo> dmwit: which means it comes with ghc already?
03:10:59 <dmwit> yes
03:11:36 <pauldoo> dmwit: ok, I have ghc 6.10.4, but in ghci ":m +Data.Functor" fails with "Could not find module `Data.Functor'"
03:11:48 <mroman> noor__: http://www.haskell.org/ghc/docs/7.4.1/html/libraries/ghc-prim-0.2.0.0/src/GHC-Types.html#IO
03:11:51 <dmwit> Upgrade. GHC 6.10i s ages old.
03:12:04 <nand`> pauldoo: looks like it was first introduced in 4.2.0-- ah screw you dmwit
03:12:06 <dmwit> Three years old by now.
03:12:16 <noor__> thanks, and now I have things to be doing, Goodby all, I may link :)
03:12:16 <dmwit> nand`: =)
03:12:21 <noor__> lurk*
03:12:31 <pauldoo> dmwit: which version of base does ghc 6.10.4 come with?  (older than 4.2 ?)
03:12:43 <dmwit> pauldoo: I only have installs back to 6.12, so I don't know, but you can ask with ghc-pkg list base.
03:12:51 <Nereid> noor__: you will learn much much more about haskell just by writing some code that does some small things
03:12:55 <pauldoo> dmwit: thanks :)
03:13:04 <Nereid> than asking random questions
03:13:05 <dmwit> (6.12 comes with base-3.0 and base-4.2)
03:13:10 <mroman> I guess you can think of it as a state monad passing around an imaginary RealWorld if you must.
03:13:21 <nand`> mroman: what about concurrency?
03:13:30 <pauldoo> dmwit: yep - I see base 3.0.3.1  damn
03:13:55 <mroman> nand`: I have no idea how haskell handles IO stuff.
03:13:55 <pauldoo> dmwit: looks like the MacPorts package is just too old then..  I'll go get something more recent..  Thanks :)
03:14:00 <nand`> mroman: I don't either, admittedly
03:14:00 <mroman> And I don't need to know actually.
03:14:18 <mroman> I know how to do stuff using IO, and that was always enough :)
03:14:54 <nand`> but then you'll never become a wizard like edwardk that can transform a 100-line library into two lines that perform much faster as well and use at least three unsafe* tricks
03:15:44 <mroman> I'm not sure if using unsafe* is intended in the spirit of haskell.
03:15:59 <Nereid> ~performance~
03:16:24 <mroman> I think of unsafe* 'breaking every rule'.
03:16:54 <nand`> I'll admit, I do too; but I can appreciate its usefulness when interfacing with foreign code that is referentially transparent (modulo errors)
03:17:36 <mroman> hm
03:17:38 <noor__> LAST QUESTION are scheduling for par and seq done at compile time or run time and are they badly gimped at the moment?
03:17:40 <mroman> @hoogle unsafePerformIO
03:17:40 <lambdabot> System.IO.Unsafe unsafePerformIO :: IO a -> a
03:17:41 <lambdabot> Foreign unsafePerformIO :: IO a -> a
03:17:55 <mroman> > unsafePerformIO $ randomRIO (1,10)
03:17:56 <lambdabot>   Not in scope: `unsafePerformIO'
03:18:14 <nand`> nice try :)
03:18:31 <Nereid> > unsafePerformIO launchMissiles
03:18:32 <lambdabot>   Not in scope: `unsafePerformIO'Not in scope: `launchMissiles'
03:18:39 <mroman> esentially that should break referential transparenty.
03:18:44 <mroman> +s
03:18:44 <noor__> I think the bit of chat I was really interested in got scrolled out of history :((
03:19:45 <mroman> How does ghc/haskell handle that anyhow?
03:19:56 <nand`> mroman: handle what? unsafePerformIO?
03:19:59 <mroman> yes.
03:20:08 <nand`> it's a GHC primitive as far as I'm aware
03:20:21 <nand`> since I imagine it involves heavy coordination with the RTS
03:20:29 <nand`> not something you can do from within Haskell
03:20:45 <mroman> RT tells me that I can replace unsafePerformIO $ randomRIO (1,10) once evaluated everywhere with it's result if I feel like doing that.
03:21:03 <nand`> mroman: and you're right, it does break referential transparency
03:21:05 <nand`> that's why it's unsafe
03:21:11 <nand`> (it also breaks type safety)
03:23:26 <NoICE> hi guys, one quick question.. I use Network.DNS package and it produces Maybe [RDATA]. I've parsed the domain string from RDATA, but its type is Domain (which is ByteString). I need to supply that to SockAddr type which requires HostName .. so I need to convert Domain to HostName (both are strings). If I do show domain .. it escapes it like this: "\"smtp.gmail.com.\"" … Is there any other approach?
03:24:16 <nand`> you want to convert ByteString to String?
03:25:39 <mroman> :t unsafeCoerce
03:25:40 <lambdabot> Not in scope: `unsafeCoerce'
03:25:53 <nand`> mroman: unsafeCoerce :: a -> b
03:25:55 <NoICE> nand`: HostName is String, so I assume yes..
03:26:10 <nand`> NoICE: there are many (sensible) ways to convert from ByteString to String (and vice versa)
03:26:11 <mroman> That's what other languages call 'casts' iirc?
03:26:17 <Nereid> @hoogle ByteString -> String
03:26:17 <lambdabot> Data.ByteString.Char8 unpack :: ByteString -> [Char]
03:26:17 <NoICE> I don't quite get why show escapes it..
03:26:17 <lambdabot> Data.ByteString.Lazy.Char8 unpack :: ByteString -> [Char]
03:26:17 <lambdabot> Data.ByteString.Char8 head :: ByteString -> Char
03:26:18 <nand`> mroman: yes
03:26:19 <shachaf> No, it's not a cast.
03:26:28 <shachaf> And it's not "unpack", either.
03:26:37 <nand`> shachaf: I don't think mroman was replying to NoICE
03:26:40 <shachaf> That function looks right but it's broken.
03:26:47 <shachaf> Oh.
03:26:51 <shachaf> Well,
03:26:54 <shachaf> Er.
03:27:01 <shachaf> "cast" is a pretty vague word.
03:27:01 <mroman> I was referring to unsafeCoerce
03:27:12 <nand`> NoICE: ‘show’ is usually meant to produce ‘valid Haskell source code’, which is indeed valid source code for a ByteString with -XOverloadedStrings
03:27:32 <NoICE> oh
03:27:33 <NoICE> I see
03:27:35 <nand`> NoICE: ‘show’ is not the right function to use here, you want something like decodeUtf8 :: ByteString -> String
03:27:52 <nand`> note that like I said, there are many different sensible ways to convert between the two. UTF-8 is one of them
03:27:55 <mroman> Oh. I we are at that topic.
03:27:56 <AfC> I wish show would just be straight output and not escaped.
03:27:59 <flixil> Hello. Can someone tell me an example of what to use a scan for? (I can find multiples examples of fold but none of scan). Thanks
03:28:02 <mroman> Is there a library that detects encodings?
03:28:04 <nand`> the difference being that ByteString is base-256 and String is base-unicode
03:28:21 <mroman> And converts bytes to string.
03:28:21 <Nereid> AfC: then do something like: print $ show stuff
03:28:30 <shachaf> mroman: Instead of detecting encodings, you should just use UTF-8. :-)
03:28:41 <mroman> Well... not anybody uses that.
03:28:48 <Nereid> AfC: the result of show is not escaped
03:28:50 <NoICE> and I can use something which converts ByteString to String on Domain ?
03:28:53 <nand`> Nereid: you mean print $ stuff
03:28:55 <mroman> I would prefer 'utf-8' with fallback to latin1.
03:29:05 <nand`> Nereid: print = putStrLn . show
03:29:17 <Nereid> nand`: oops I meant putStrLn $ show stuff.
03:29:22 <NoICE> Domain is defined here: http://hackage.haskell.org/packages/archive/dns/0.3.3/doc/html/Network-DNS-Types.html#t:Domain
03:29:25 <nand`> Isn't UTF-8 basically backwards compatible with latin1 or something?
03:29:28 <nand`> I'm not exactly sure how it works
03:29:28 <NoICE> and HostName here: http://hackage.haskell.org/packages/archive/network/2.3.0.14/doc/html/src/Network-Socket.html#HostName
03:29:31 <shachaf> I hate this channel.
03:29:37 <Nereid> nand`: it is with ASCII.
03:29:49 <shachaf> nand`: No, it's backwards-compatible with ASCII.
03:29:58 <nand`> I see
03:30:13 <shachaf> The first 256 codepoints of Unicode happen to match ISO-8859-1.
03:30:33 <NoICE> nand`: UTF8 "ascii" == ASCII "ascii" .. but UTF8 "králík" /= ASCII "kralik"
03:30:41 <nand`> right, backwards compatibility with latin1 (that's just extended ASCII right?) would be a bit hard since UTF-8 obviously must have some way of encoding multi-byte characters which would be ambiguous with the latin1 chain
03:31:09 <shachaf> nand`: "just extended ASCII"?
03:31:13 <shachaf> Most things are extended ASCII.
03:31:18 <nand`> shachaf: I'm referring to ISO-8859-1
03:31:31 <shachaf> ISO-8859-8 is also "extended ASCII"
03:31:44 <shachaf> So is UTF-8 (sort of)
03:31:47 <NoICE> so.. can I convert something that's type-labeled with name "Domain" to something which is type-labeled "HostName" without show?
03:31:58 <shachaf> NoICE: Yes, you want something like "encodeUtf8"
03:32:10 <shachaf> I mean "decodeUtf8"
03:32:13 <nand`> shachaf: I see your point, I was just under the assumption that the term “extended ASCII” refers to a particular code page, and not literally any extended version of the ASCII code page
03:32:16 <NoICE> types will not be in the way?
03:32:26 <NoICE> will not stand*
03:33:08 <nand`> @hoogle decodeUtf8
03:33:09 <lambdabot> Data.Text.Encoding decodeUtf8 :: ByteString -> Text
03:33:09 <lambdabot> Data.Text.Lazy.Encoding decodeUtf8 :: ByteString -> Text
03:33:09 <lambdabot> Data.Text.Encoding decodeUtf8' :: ByteString -> Either UnicodeException Text
03:34:15 <nand`> hmm, wait; was there another decodeUtf8-like function :: ByteString -> String somewhere or is Text.unpack . decodeUtf8 the way to go?
03:34:40 <Nereid> isn't unpack :: ByteString -> String ok if you know it's all ASCII?
03:34:59 <NoICE> and how can I extract String from Domain? or it doesn't matter if I supply Domain to some method which expects String? ...
03:35:12 <Nereid> NoICE: Domain, as you said, is ByteString.
03:35:17 <Nereid> which is different from String.
03:35:24 <Nereid> so you need some function that turns a ByteString into a String.
03:35:28 <NoICE> ok ok s/String/ByteString
03:35:49 <NoICE> and then I can supply Domain to that func. which requires ByteString and type checker will not complain?
03:36:09 <nand`> Nereid: only if the encoding is compatible that way; BSC.unpack maps (chr :: Word8 -> Char) so theoretical multi-byte ASCII encodings would still fail
03:36:42 <Nereid> obviously.
03:37:05 <nand`> NoICE: if ‘Domain’ is a type synonym yes
03:37:21 <Nereid> we have type Domain = ByteString, and type HostName = String.
03:37:23 <nand`> NoICE: type synonyms are exact equivalents as far as the type checker is concerned. newtypes, however, are not
03:37:47 <NoICE> ahaaa
03:37:50 <NoICE> thanks!
03:37:59 <Nereid> you still need to turn the ByteString into a String though.
03:38:45 <NoICE> it should be valid ascii (since it is a domain name, which are ascii-restricted, right?) so I can use whatever function hoogle gives me?
03:39:04 <Nereid> yes, domain names can only contain letters/digits/hyphen per RFC1035
03:39:05 <NoICE> I think DNS package returns ByteString just for speed..
03:39:14 <nand`> if it's UTF-8 and you know it all to be ASCII, then you can just use BSC.unpack; yeah
03:39:38 <shachaf> :-(
03:40:12 <Nereid> why the sad face
03:40:24 <mcstar> face of disappointment
03:42:16 <mcstar> can i share an 'aha' moment?
03:43:00 <Nereid> why not
03:43:01 <NoICE> it worked!
03:43:16 <NoICE> so now I can send spam to google. :)
03:43:20 <nand`> Nereid: don't international domain names allow far more these days?
03:43:29 <Nereid> nand`: those are still encoded with ASCII
03:43:39 <sipa> @google punycode
03:43:40 <lambdabot> http://en.wikipedia.org/wiki/Punycode
03:43:40 <lambdabot> Title: Punycode - Wikipedia, the free encyclopedia
03:43:43 <Nereid> ^
03:44:37 <mcstar> well, it was when i realized that the World parameter in IO was a totally dummy parameter, for some time, i thought it might really change during the evaluation process, but after reading something it became clear, that it is only there to provide a data dependency for the compiler, to actully sequence IO actions
03:44:39 <NoICE> btw do you guys know any package which produces proper strings for smtp communication? I use currently package SMTPClient, but it seems it does not provide functions for escaping SMTP communication...
03:44:44 <NoICE> like double-dot replace
03:45:41 <nand`> mcstar: interesting
03:46:41 <Nereid> mcstar: sec. 2.8 of that paper talks about this
03:46:57 <mcstar> Nereid: what paper?
03:47:02 <Nereid> uh, that one.
03:47:11 <Nereid> that got linked a while ago.
03:47:19 <mcstar> today?
03:47:39 <Nereid> http://research.microsoft.com/~simonpj/papers/marktoberdorf/mark.pdf.gz
03:48:34 <mcstar> ah awkward squad, famous one, though i never read it
03:49:00 <mcstar> Nereid: my revelation happend whil reading a haskell wiki article 'IO inside' i guess
03:49:28 <mcstar> actually, it is spelled out in detail, so there was no brain-work on my part XD
03:49:31 <pauldoo> thanks merijn, dmwit: getting the official haskell platform (instead of the macports one) has fixed my problem. :D
03:50:31 <mcstar> nand`: http://www.haskell.org/haskellwiki/IO_inside
03:54:32 <pauldoo> when I use 'import' to reference a module, I can use "as Foo" at the end.  Is the same possible in ghci with ":m +Some.Module as Foo"  (this syntax doesn't work)
03:54:59 <mcstar> you can use the exact same syntax as in files
03:55:21 <pauldoo> mcstar: oh, I thought I had to use :m, does import work too?
03:55:27 <mcstar> yes
03:55:40 <mcstar> provided your ghci is recent enough
03:55:50 <pauldoo> mcstar: huh, cool :)  so :m is just the old-way of doing it I guess?
03:56:22 <NoICE> pauldoo: I think that :m provides "-" .. but "unimport" does not exist
03:56:26 <nand`> it's valid since 7.4.1 I think
03:56:26 <mcstar> im not sure if it provides something import cant do
03:57:23 <pauldoo> mcstar: :m will recompile the module if needed (assuming it's a local .hs file), perhaps import does not ?
03:57:42 <mcstar> recompile?
03:57:48 <mcstar> byte compile, right?
03:57:56 <pauldoo> mcstar: yeh
03:58:32 * hackagebot cipher-aes 0.1.0 - Fast AES cipher implementation with advanced mode of operations  http://hackage.haskell.org/package/cipher-aes-0.1.0 (VincentHanquez)
03:58:50 <mcstar> it would make sense, im not certain
03:58:57 <mcstar> guys?
04:05:21 <mcstar> oh
04:05:49 <mcstar> so ghci can detect if im typing a multi-line input?
04:06:00 <mcstar> i was using :{ :}
04:07:13 <mcstar> :S doesnt work well with my current prompt
04:08:47 <mcstar> i believe i cant set the secondary prompt, is that so?
04:09:18 <mcstar> lets patch ghci...
04:11:32 <mcstar> if i were to build ghc myself, all my packages would break, correct?
04:14:06 <nand`> oh wow, the secondary prompt is hideous
04:14:21 <nand`> probably because my .ghci is enormous
04:14:50 <mcstar> nand` :set prompt "▼/%s\\\n" try this
04:14:58 <mcstar> similar to my bash prompt
04:15:11 <nand`> I use :set prompt "λ "
04:15:21 <mcstar> just try mine :)
04:15:30 <mcstar> ofc, put lambda in if you like
04:15:42 <nand`> still huge :P
04:16:04 <mcstar> nand`: but at least the line start from the left side
04:16:07 <mcstar> starts*
04:16:08 <nand`> http://bpaste.net/show/33805/
04:16:45 <nand`> after no less than 12 lines of imported packages :)
04:16:57 <mcstar> nand`: thats ... huge, ive never seen anyone has that long a prompt
04:16:58 <nand`> (in an 80col term)
04:17:18 <nand`> mcstar: I got fed up with constantly having to reimport stuff and just copied (and slightly modified L.hs) for my .ghci one day
04:17:42 <nand`> (though I left out certain things like (.) as fmap just for type sanity)
04:18:12 <nand`> (ditto for NumInstances or SimpleReflect)
04:19:47 <XexonixXexillion> how different would the performance be between "fib 0 = 0; fib 1 = 1; fib n = fib (n-1) + fib (n-2)" and "fib = runIdentity fib' where fib' 0 = return 0; fib' 1 = return 1; fib' n = (+) <$> (fib' (n-1)) <*> (fib' (n-2))"?
04:20:13 <nand`> I wouldn't be surprised if they compiled to the same thing
04:20:22 <nand`> though you probably meant fib = runIdentity . fib'
04:21:01 <Saizan> maybe you should pick something that's not exponential to make such comparisons
04:21:41 <mcstar> but if it would be iterative, then you would measure mostly gmp performance
04:21:57 <b0fh_ua> Hi all! Can somebody please help me in resolving this issue: https://gist.github.com/dac48396276c8be76a32
04:22:18 <b0fh_ua> both ByteString and SQLFile have instances for LogParser
04:22:57 <Peaker> merijn, ah, weird -- sounds like a bug in whatever package requires the iconv?
04:23:00 <XexonixXexillion> So there's no performance reason why I couldn't just lift all my functions to being for some arbitrary monad?
04:23:15 <Saizan> b0fh_ua: with a type like that it's the caller of goWithFile which gets to decide what 'a' should be, not the implementation
04:23:38 <b0fh_ua> Saizan: not sure that I do understand
04:23:46 <nand`> XexonixXexillion: I wouldn't say “arbitrary”, but I'd be surprised if there's a noticeable performance difference for the Identity monad
04:24:37 <roconnor> XexonixXexillion: for a given pure function there is more than one way of lifting it to an arbitrary monad.
04:25:27 <b0fh_ua> Saizan: I have 2 different sources of data and 2 different parsers for the data, parser is defined like "parse :: a -> [Entry]", now depending of filenames I need to create list of items for same typeclass
04:25:29 <XexonixXexillion> nand`: but what if fib' were a separate function with the type fib' :: (Monad m, Applicative m, Functor m) => Int -> m Int
04:25:43 <Saizan> b0fh_ua: when you implement goWithFile you can't assume anything about the type 'a' except that it's an instance of LogParser (i.e. you can't assume it's a specific instance like you are doing there)
04:26:04 <Saizan> b0fh_ua: because the user could be using it in a context which is expecting a different instance
04:26:16 <roconnor> XexonixXexillion: consider treeMap :: (a -> b) -> Tree a -> Tree b  where  data Tree a = Leaf | Branch (Tree a) a (Tree a)
04:26:39 <b0fh_ua> Saizan: okay, so in general I can not create anything inside such function.
04:26:57 <Saizan> b0fh_ua: that depends on the methods on LogParser
04:27:26 <b0fh_ua> LogParser declares sigle method "parse :: a -> [Entry]"
04:27:39 <nand`> XexonixXexillion: (not related to your question but why not just use Applicative m and change ‘return’ to ‘pure’?)
04:27:48 <Saizan> b0fh_ua: why not just have IO [[Entry]] as result then?
04:28:31 <roconnor> there are somewhere between 3 and 6 ways of lifting treeMap to treeMapM
04:28:58 <b0fh_ua> so in goWithFile do invoke "parse"?
04:29:18 <b0fh_ua> perhaps it's good idea, thanks!
04:29:29 <nand`> XexonixXexillion: also, I'm sure it's possible to define an arbitrary copointed applicative which has a very high performance overhead on <*>, even if all you're using is pure and fmap
04:29:40 <nand`> XexonixXexillion: so that should disprove it in the general case. in practice, I don't know. Try it?
04:30:29 <XexonixXexillion> nand`: My question is will the polymorphism itself cause much overhead
04:31:18 <nand`> XexonixXexillion: I'm not sure, I'd guess it gets specialized at compile time if the function is inlinable, otherwise you might have to add SPECIALIZE pragmas
04:34:09 <XexonixXexillion> and my other related question; is using fix going to be noticeably slower than simply having the function call itself?
04:37:07 <mcstar> can i make ghci wo making ghc?
04:38:46 <hpc> mcstar: yes, but only in the sense that it is not impossible to do
04:39:02 <hpc> you probably don't want to try
04:39:14 <JuanDaugherty> but hey there are no stupid questions
04:39:43 <hpc> heh, it's a good question :P
04:40:14 * JuanDaugherty frowns at hpc.
04:40:47 <mcstar> hpc: i want to do exactly that, but probably just build both
04:40:56 <mcstar> why the hell would it be impossible?
04:41:09 <mcstar> i have the same ghc on my system that i dont want to build
04:41:29 <hpc> mcstar: so you have ghc already, but not ghci?
04:41:39 <mcstar> hpc: i patched ghci to accept a secodary parameterized prompt
04:41:45 <mcstar> hpc: i have both...
04:41:48 <hpc> oh nifty
04:41:51 <mcstar> but i need to rebuild ghci
04:41:58 <hpc> uh
04:42:09 <dmwit> Sometimes I wish people would give more negative examples.
04:42:30 <dmwit> e.g. "X, Y, and Z are strong monads; V and W are *not* strong <- this part"
04:43:05 <hpc> i don't have a ghc tarball handy, but i would guess you can start by doing a configure of ghc/ghci
04:43:14 <dmwit> mcstar: "make" should only build the bits that changed...
04:43:15 <hpc> then rip and shred the makefile
04:43:39 <hpc> or what dmwit said, if you still have the original build directory around
04:44:05 <dmwit> I can't say I recommend ripping and shredding the Makefile.
04:44:25 <dmwit> There's more Make code in GHC than there is Haskell code in all of my projects combined.
04:44:48 <hpc> wow, never mind then :P
04:45:18 <mcstar> no, arch has binary package management, so i didnt build ghc from sources
04:45:48 <mcstar> anyway, i'll just build both
04:45:51 <bitonic> dmwit: I just checked, 2231 lines of makefiles
04:46:10 <dmwit> yeah
04:46:13 <dmwit> kind of crazy, really
04:46:22 <hpc> mcstar: depending on how you use cabal and arch lib packages, you might want to uninstall arch ghc first
04:46:25 <dmwit> And that number has been decreasing for years...
04:46:36 <hpc> possibly
04:46:41 <mcstar> hpc: why?
04:46:50 <dmwit> That is usually not necessary.
04:47:02 <dmwit> pacman installs to not-/usr, GHC by default installs to /usr
04:47:24 <hpc> oh, k
04:47:25 <dmwit> err, s;/usr;/usr/local;g
04:47:41 <mcstar> im building from the PKGBUILD
04:47:43 <hpc> debian installs to one of /usr, /usr/local
04:48:00 <hpc> and if it surprises you with an upgrade you will have a hell of a time figuring out how to fix it
04:48:10 <bitonic> dmwit: the umbrella repo of RabbitMQ has 3000k+ lines of make! take that, GHC!
04:48:30 <dmwit> I'm pretty sure Makefile line counts are scored like golf...
04:49:16 <bitonic> but it's kinda cheating because it includes a lot of different stuff to do the same thing (e.g. distro packages)
04:49:52 <dmwit> shake is the future
04:50:11 <bitonic> dmwit: no, recursive makefiles!
04:50:41 <gienah> yeah the ghc devs seem to think the best feature of make is it supports recursion :-)
04:50:51 <dmwit> Make is a terrible language.
04:51:41 <dmwit> Although I will admit that using Haskell to define the build system for your Haskell compiler is a bit worrisome in a "really, really hard to bootstrap" way.
04:52:36 <mcstar> dmwit: you dont have >2k lines of haskell code in your projects?
04:52:49 <bitonic> mcstar: I think he meant lines of make
04:52:59 <mcstar> oh
04:53:46 <dmwit> I guess I do have >2k lines of Haskell code.
04:54:06 <dmwit> The sgf package seems to be about 1800 lines by itself.
04:54:38 <bitonic> dmwit: oh you meant that? then you haven't written much haskell code :)
04:55:47 <dmwit> That's all too true, I'm afraid.
04:55:50 <mcstar> but its all in template haskell, and expands to 100K of pure haskell....
04:55:51 <dmwit> I'm a total poser.
04:58:08 <mcstar> it takes a long time to build, im running with the powersave governor
04:58:36 <mcstar> yesterday i built something on 2 cores, temperature went up to 125C, and soem time after my computer halted
04:58:55 <dmwit> 125 seems a bit hot, yeah
04:59:02 <bitonic> 125C? what?
04:59:23 <mcstar> what?
04:59:30 <mcstar> it worked for a while
04:59:31 <bitonic> I'd have expected it to turn off way before that
04:59:43 <bitonic> like around 100, maximum
04:59:47 <mroman> yes.
04:59:51 <sipa> it should turn off at 70C or so
04:59:52 <bitonic> what laptop is it?
04:59:56 <unnali> mine powers off around 100 ;-)
04:59:57 <mcstar> desktop
04:59:59 <bitonic> sipa: not with modern laptops
04:59:59 <mroman> My linux kernel crashes with "temperature critical" at about 100C.
05:00:04 <mroman> or... aborts.
05:00:06 <mroman> Not really crashes.
05:00:10 <dmwit> sipa: No way, 70 is way too cool.
05:00:12 <mcstar> amd x2
05:00:15 <bitonic> mcstar: what the hell? something is wrong. I wouldn't expect a desktop to reach that
05:00:18 <unnali> mroman: "gives up"?
05:00:24 <sipa> dmwit: depends where it is measured i guess
05:00:25 <dmwit> My GPU idles at 70.
05:00:35 <sipa> eh, what?
05:00:44 <mroman> I'm not sure if the OS shuts the computer down to prevent damage
05:00:49 <mroman> or the CPU shuts the OS down.
05:00:50 <dmwit> I said: "My GPU idles at 70."
05:00:55 <mcstar> dmwit: my nvidia 7300 silent used to do that
05:00:59 <sipa> :)
05:01:01 <mcstar> ~70
05:01:06 <sipa> dmwit: that sounds excessive
05:01:26 <sipa> but i'm not too familiar with that (anymore), so i'll believe you
05:01:32 <bitonic> laptops are made to be hot nowadays
05:01:42 <mcstar> i not attracted to them
05:01:49 <dmwit> I think it's normal; according to various forum posts, people don't get excited until this particular card reaches 105-110.
05:02:03 <bitonic> it's a conspiracy to render us sterile after using them on our laps
05:02:24 <mcstar> bitonic: no, nerdness itself is the contraceptive
05:03:24 <bitonic> mcstar: you're implying that only nerds use laptops
05:03:41 <mcstar> well, not?
05:03:48 <bitonic> uhm... no.
05:03:56 <mcstar> all these other people buy tablet pcs these days
05:13:34 * hackagebot cipher-aes 0.1.1 - Fast AES cipher implementation with advanced mode of operations  http://hackage.haskell.org/package/cipher-aes-0.1.1 (VincentHanquez)
05:38:24 <miden> hello ppl!
05:38:30 <miden> does anyone know coq ?
05:38:58 <homie> me a lil bit
05:39:12 <miden> i have a prob :)
05:39:12 <homie> didn't use it much.....
05:39:16 <miden> Fixpoint groupBy (n : nat) (l : list nat):=   match l with   | [] => []   | xs => take n xs :: groupBy n (drop n xs)   end.
05:39:24 <homie> just run it for an example ....
05:39:30 <miden> it yelds Error: Cannot guess decreasing argument of fix.
05:39:35 <hpc> ask #coq
05:39:43 <miden> and i cannot find a way to "fix" it
05:39:56 <miden> sorry didn't know that there is a channel
05:40:02 <hpc> np
05:42:11 <daniel_-> when doing a System.Process.CreateProcess you get a ProcessHandle datatype returned which is defined as `newtype ProcessHandle = ProcessHandle (MVar ProcessHandle__)` in the source, what can i do with it?
05:43:48 <daniel_-> cant find any documentation what the processhandle is actually for
05:44:43 <daniel_-> except for maybe getting status
05:49:06 <mcstar> what do you want to do?
05:49:29 <mcstar> if you want to execute some command/binary use createProcess
05:49:57 <mcstar> you dont have to touch CreateProcess
05:50:26 <sipa> waitForProcess :: ProcessHandle -> IO ExitCode
05:50:35 <sipa> terminateProcess :: ProcessHandle -> IO ()
05:51:22 <daniel_-> im mostly having troubles with coming up with a way to do the following:
05:52:08 <daniel_-> i want to create processes which will read from stdout and if something matches in the process output it should either do something or just respond to the process stdin
05:52:58 <mcstar> wcreateProcess returns (mb_stdin_hdl, mb_stdout_hdl, mb_stderr_hdl, p), where
05:53:19 <mcstar> just match on the return of createProcess, and use its the stdout/stdin accordingly
05:53:27 <mcstar> -the
05:53:43 <voodster> hello, [0..]!!999999999999 raises *** Exception: Prelude.(!!): negative index ;but with much index number all ok
05:53:45 <daniel_-> yep but how will i do it with unblocking IO?
05:53:55 <voodster> ghc(7.0.3)
05:53:59 <hpc> voodster: you overflowed Int
05:54:07 <morel> > 999999999999 :: Int -- voodster
05:54:08 <lambdabot>   999999999999
05:54:10 <mcstar> daniel_-: i dont understand
05:54:11 <daniel_-> when i built this in python i used Select() and Queue() to handle everything
05:54:14 <morel> erm… oO
05:54:18 <mcstar> daniel_-: you set up a loop or something
05:54:26 <hpc> > 999999999999 :: Int32 -- you have a 32-bit cpu
05:54:28 <lambdabot>   -727379969
05:55:09 <voodster> haha, yes, it's funny
05:55:18 <morel> hpc: is there a (!!) :: Integral i => [a] -> i -> a ? like genericLength etc?
05:55:29 <hpc> @hoogle Integral i => [a] -> i -> a
05:55:30 <lambdabot> Data.List genericIndex :: Integral a => [b] -> a -> b
05:55:30 <lambdabot> Data.List genericDrop :: Integral i => i -> [a] -> [a]
05:55:31 <lambdabot> Data.List genericTake :: Integral i => i -> [a] -> [a]
05:55:34 <hpc> aha!
05:55:37 <morel> :)
05:55:46 <morel> voodster: use genericIndex :)
05:56:38 <voodster> morel: I just playing with range, nothing important =)
05:56:46 <morel> voodster: okay :)
05:57:05 <morel> > maxBound :: Int32 -- that's the maximum, voodster
05:57:06 <lambdabot>   2147483647
05:57:37 <morel> is there (actually meanwhile already) an extension which makes "case of" a synonym for "\x -> case x of"?
06:01:56 <hpc> morel: no, but several proposals
06:02:02 <hpc> i am a fan of "case of ..."
06:07:51 <morel> hpc: me, too. and i really want that proposal be implemented…
06:08:21 <hpc> i can't imagine it being particularly hard to implement either
06:09:24 <morel> btw, am i the only one for whom runhaskell and runghc are broken? (i get "/usr/local/bin/runghc: 10: exec: /usr/local/lib/ghc-7.4.1/runghc: not found" on debian unstable.)
06:17:49 <nand`> morel: the script says /usr/lib64/ghc-7.4.2/runghc for me, which exists
06:20:20 <morel> nand`: well, it's not a big issue for me actually as i don't mind that much… i just use /usr/bin/runghc, which works =)
06:20:38 <nand`> morel: I guess debian's packages are broken (big surprise)
06:21:54 <favonia> morel: does /usr/local/bin/runghc belong to the deb package?
06:23:44 <Lamen> Hi, everyone, I am seeking for some help.
06:23:58 <Lamen> I now understand what (const id) does
06:24:18 <Lamen> but I don't quite understand what (const . id) is...
06:24:35 <Ptival> :t (const . id)
06:24:37 <lambdabot> forall a b. a -> b -> a
06:24:50 <morel> lambdabot: (const . id) is the same as (const).
06:25:04 <favonia> @unpl const . id
06:25:04 <lambdabot> (\ e _ -> e)
06:25:39 <Lamen> That's what I got locally:
06:25:41 <Lamen> λ :t const . id
06:25:41 <Lamen> const . id :: b -> b1 -> b
06:25:44 <shirt> since the 'id' function doesn't do anything, when you compose it with any other function you simply get back the other function unchanged
06:26:00 <Lamen> When I run const . id 1 2
06:26:11 <Ptival> f = const . id   implies   f x = const . id $ x = const x   and   f x = const x    implies   f = const
06:26:27 <Lamen> It printed No instance for (Num (a1 -> a0 -> b0)) out...
06:27:00 <morel> Lamen: you try to apply "id" on two arguments.
06:27:12 <morel> > (const . id) 1 2
06:27:15 <lambdabot>   1
06:27:21 <morel> Lamen: see?
06:27:40 <morel> favonia: i don't know.
06:27:49 <Lamen> Ah! Now I see why...
06:28:29 <shirt> Lamen: in haskell, function application has the highest precedence
06:29:36 <mcstar> > id . id undefined undefined $ undefined
06:29:39 <lambdabot>   *Exception: Prelude.undefined
06:29:55 <mcstar> so, thats not strictly true, that id 1 2 is incorrect
06:30:44 <shirt> can anyone recommend a Standard ML tutorial for someone who already knows Haskell?
06:32:40 <morel> i want a syntax for defining record-fields referring to other fields of the same record. i explained it here:
06:32:41 <hpaste> morel pasted “C++'s "this" for Haskell's records?” at http://hpaste.org/71041
06:32:47 <morel> any ideas?
06:33:10 <morel> oh my god.
06:33:15 <morel> i know how to do that!
06:33:35 <hpaste> morel annotated “C++'s "this" for Haskell's records?” with “like this!” at http://hpaste.org/71041#a71042
06:33:36 <Oejet> shirt: Tips for Computer Scientists Standard ML (Revised) (http://www.itu.dk/~tofte/publ/tips.pdf)
06:33:53 <morel> thanks anyway :D
06:34:14 <Lamen> Thanks guys, you're really helpful. :)
06:34:40 <favonia> shirt: How about this one? I didn't finish it though. http://www.cs.cmu.edu/~rwh/smlbook/book.pdf
06:35:40 <Oejet> shirt: There's a friendly channel for further questions: #sml
06:36:04 <shirt> Oejet: thanks, that looks really good. i'll check out the channel as well
06:36:06 <eikke> got my storable-vectors-with-alignment working ^_^
06:36:41 <shirt> favonia: i saw that one, it's quite long, but i'll give it an overview
06:36:59 <mcstar> > let fun a b = \x -> a ++ x ++ b in fun "12" "34" "56"
06:37:01 <lambdabot>   "125634"
06:37:03 <mcstar> morel: ^^
06:37:22 <mcstar> you can apply fun seemingly to 3 arguments, even if it takes 2
06:37:44 <favonia> shirt: I think you're able to skip most of them. my impression is that it's very rigorous and well-explained
06:38:21 <morel> mcstar: i know. what do you want to say?
06:38:37 <favonia> shirt: signatures, modules and functors will be new for Haskellers. also because of side effects there's an extra restriction on polymorphism
06:39:09 <eikke> favonia: talking about ocaml?
06:39:29 <favonia> shirt: but I feel that's all (?) the things you have to learn
06:39:44 <favonia> eikke: standard ml. but they're very similar anyway.
06:39:56 <favonia> will ocaml minus the oo part
06:39:59 <favonia> well ocaml minus the oo part
06:40:08 <eikke> i see :) (/me codes ocaml at daytime, haskell at night)
06:40:34 <morel> @time eikke
06:40:35 <lambdabot> Local time for eikke is Sat Jul  7 15:40:13 2012
06:40:37 <mcstar> morel: you told Lamen that id takes 1 argument
06:40:44 <mcstar> but the error wasnt caused by that
06:40:48 <Oejet> eikke: Nice!
06:40:50 <morel> so eikke is coding ocaml atm… :D
06:40:52 <eikke> morel: lol :D
06:42:09 <favonia> mcstar: for some reason there's an instance Num a => Num (a -> b) in lambdabot I think...
06:42:13 <favonia> > 1 10
06:42:15 <lambdabot>   1
06:42:16 <shirt> favonia: thanks. right now i'm interested in only learning the basics(mostly the syntax), not the entire language
06:42:44 <mcstar> favonia: to manipulate functions:
06:42:48 <mcstar> > (sin + cos) 1
06:42:50 <lambdabot>   1.3817732906760363
06:43:00 <alech> I'm trying to create a mail using Network.Mail.Mime, but it wants a Data.ByteString.Lazy.Internal.ByteString for partContent from me - how do I get one from a String?
06:43:04 <ion> > (sin^2 + cos^2) 42
06:43:06 <lambdabot>   1.0
06:43:16 <morel> mcstar: well. he wrote "id 1 2". which is the same as "1 2" which doesn't work because (Num t => t -> a) is not an instance of Num or so.
06:43:17 <mcstar> ion: that was my very first example
06:43:44 <mcstar> morel: ok, but not because in the whole context id 1 2 was invalid
06:43:56 <morel> mcstar: yup
06:44:00 <eikke> alech: Data.ByteString.Lazy.Char8.pack
06:44:28 <eikke> alech: but you most likely want to use bytesting throughout your own code as well, not using String, which is rather unefficient
06:45:21 <morel> mcstar: but hey, i didn't say that applying id to two arguments cause the problem/error! :P
06:45:27 <alech> eikke: thanks. I'll look into it.
06:45:58 <favonia> shirt: modules are an importart part of the ml families. you can't ignore them :) perhaps you can postpone the functor part but not modules. that's something Haskell is weak at
06:46:54 <eikke> shirt, favonia: I tend to think about functors as modules which take a module as an argument and return a module
06:47:49 <Lajla> eikke, on pala koiraa silmäkuopassani , apua.
06:48:09 <Lajla> En voi näke
06:48:28 <eikke> shirt, favonia: you might be interested in this presentation me and a colleague gave to some students of an FP class, using Haskell, including an introduction to OCaml @ http://blog.incubaid.com/2011/12/15/guest-lecture-real-world-functional-programming-incubaid/
06:48:43 <eikke> Lajla: que? you're not speaking my language :)
06:48:51 <Lajla> Lajla, oh, I thought you were Finnish.
06:48:55 <Lajla> Well, tough luck.
06:49:03 <favonia> eikke: that's basically right. by the way functors in standard ml is generative (different from ocaml), so they're not strictly speaking a function in my opinion...
06:49:26 <eikke> favonia: never worked with sml :)
06:49:28 <shirt> is the syntax of ocaml the same as sml?
06:49:50 <eikke> shirt: http://adam.chlipala.net/mlcomp/
06:50:01 <favonia> there shold be a rosetta stone somewhere
06:52:10 <ski> shirt : also see rossberg's <http://www.mpi-sws.org/~rossberg/sml-vs-ocaml.html>
06:55:43 <CSWookie> I'm having difficulty indenting my program correctly.  If I paste it, would someone correct it for me?  It's only 3 lines long.
06:56:12 <rwbarton> @where hpaste
06:56:13 <lambdabot> http://hpaste.org/
06:57:02 <hpaste> CSWookie pasted “euler1.hs” at http://hpaste.org/71044
06:57:55 <mcstar> bit too much parens there
06:58:25 <rwbarton> you can't just write an expression at the top level of a .hs file, assign it to a name or write "main = print $ sum ..."
06:58:38 <ion> That looks like lisp.
06:58:45 <ppilate> hah
06:59:04 <morel> CSWookie: you're mixing up filter and takeWhile, i think.
06:59:20 <morel> > filter even [1..10]
06:59:21 <favonia> eikke, shirt: by the way I really dislike the uncurried std lib in ML... Haskell's curried std lib is cuter :D
06:59:21 <lambdabot>   [2,4,6,8,10]
06:59:27 <morel> > takeWhile even [1..10]
06:59:28 <lambdabot>   []
06:59:45 <mcstar> no, takewhile is ok
06:59:56 <morel> mcstar: oh.
06:59:58 <mroman> takeWhile stops after the first element not satisfying the predicate.
07:00:02 <DMcGill> :t enumFromTo
07:00:04 <lambdabot> forall a. (Enum a) => a -> a -> [a]
07:00:19 <morel> mroman: yea, i thought that's the wrong behaviour…
07:00:36 <DMcGill> are there instance for enumFromTo for non-list storage types? Does the [1..3] syntax work with them?
07:01:04 <mroman> > enomFromTo 65 97 :: [Char]
07:01:06 <lambdabot>   Not in scope: `enomFromTo'
07:01:07 <mroman> > enumFromTo 65 97 :: [Char]
07:01:09 <lambdabot>   No instance for (GHC.Num.Num GHC.Types.Char)
07:01:09 <lambdabot>    arising from the literal `6...
07:01:12 <morel> DMcGill: works for types which are an instance of Enum.
07:01:18 <mroman> > (enumFromTo 65 97) :: [Char]
07:01:20 <lambdabot>   No instance for (GHC.Num.Num GHC.Types.Char)
07:01:20 <lambdabot>    arising from the literal `6...
07:02:26 <mcstar> > sum [n | n <- [1..999] , mod n 3 == 0 || mod n 5 == 0]
07:02:28 <lambdabot>   233168
07:02:31 <mroman> > enumFromTo 'a' 'z'
07:02:32 <lambdabot>   "abcdefghijklmnopqrstuvwxyz"
07:02:34 <mroman> ah.
07:02:36 <mroman> that way
07:02:37 <CSWookie> morel: I wanted the first 1000 elements of the list.  That's takeWhile, right
07:02:46 <mcstar> CSWookie: ^^
07:03:00 <rwbarton> CSWookie's program is also fine
07:03:04 <morel> mcstar: then it's fine.
07:03:26 <DMcGill> I mean the storage type, for example enumFromTo :: Storage s => a -> a -> s a
07:03:26 <mcstar> semantically it is
07:03:29 <rwbarton> not as efficient I suppose
07:03:36 <DMcGill> so enumFromTo 3 5 :: Set Int
07:03:38 * hackagebot haxr 3000.9 - XML-RPC client and server library.  http://hackage.haskell.org/package/haxr-3000.9 (BrentYorgey)
07:03:40 * hackagebot haxr 3000.9.0.1 - XML-RPC client and server library.  http://hackage.haskell.org/package/haxr-3000.9.0.1 (BrentYorgey)
07:03:40 <DMcGill> for example
07:04:07 <mroman> Ah.
07:04:14 <mroman> enumFromTo with other types instead of just lists.
07:04:16 <DMcGill> although I suppose these types usually have a fromList function
07:04:25 <DMcGill> so you'd just end up doing fromList [x..]
07:04:46 <CSWookie> mcstar: I like that better, but in future problems I'll be doing much larger sets.  Would modulo slow things down?
07:05:59 <mcstar> union would slow things down
07:06:23 <mcstar> and why travel the same numbers twice, when you can do it in one pass?
07:06:46 <mcstar> (well, not same numbers.. but you get the idea)
07:07:32 <fmap> CSWookie: you can use `rem' instead of `mod' if you don't need sign checks
07:07:38 <fmap> > sum [n | n <- [1..999] , n `rem` 3 == 0 || n `rem` 5 == 0]
07:07:39 <lambdabot>   233168
07:08:12 <CSWookie> Well, under the covers, a mod does lots of division.
07:08:20 <mcstar> CSWookie: if you really need to do union on large lists of numbers, which might be unsorted, you should use a set based on trees
07:09:03 <CSWookie> So I figured the map would be faster.  I imagine the compiler optimises its operators, though.
07:11:13 <mcstar> > sum $ nub ([3,6..999] ++ [5,10..999])
07:11:16 <lambdabot>   233168
07:13:06 <morel> fmap: is rem faster than mod?
07:13:20 <sipa> @src rem
07:13:20 <lambdabot> Source not found. I am sorry.
07:14:06 <allsystemsarego> Hi, can I define a function f via a pattern that looks like this? f [x] = x f [x,y] = max x y f [x,y,z] = something else
07:14:36 <sipa> yes
07:15:03 <sipa> @let {f [x] = x; f [x,y] = max x y; f [x,y,z] = 0}
07:15:03 <lambdabot>  <local>:1:0: parse error on input `{'
07:15:07 <sipa> @let f [x] = x; f [x,y] = max x y; f [x,y,z] = 0
07:15:08 <lambdabot>  Defined.
07:15:14 <sipa> > f 4
07:15:15 <lambdabot>   Ambiguous occurrence `f'
07:15:15 <lambdabot>  It could refer to either `L.f', defined at <local...
07:15:16 <sipa> > f [4]
07:15:17 <lambdabot>   Ambiguous occurrence `f'
07:15:17 <allsystemsarego> sipa, I seem to be getting the error: f [x] = x f [x,y] = max x y f [x,y,z] = something else
07:15:18 <lambdabot>  It could refer to either `L.f', defined at <local...
07:15:29 <allsystemsarego> wait
07:15:41 <allsystemsarego> the error is Multiple declarations of `f'
07:15:46 <sipa> hpaste.org
07:15:50 <sipa> paste your code
07:15:54 <allsystemsarego> ok, wait
07:17:01 <hpaste> zz pasted “zz” at http://hpaste.org/71046
07:17:58 <hpaste> mroman annotated “zz” with “zz (annotation)” at http://hpaste.org/71046#a71047
07:18:08 <rwbarton> pattern match lines for the same function have to be contiguous
07:18:12 <mcstar> CSWookie: probably this is the most efficient:
07:18:16 <mcstar> > let f [] ys = ys; f xs [] = xs; f (x:xs) (y:ys) = if x==y then x : f xs ys else if x<y then x : f xs (y:ys) else y : f (x:xs) ys in sum $ f [3,6..999] [5,10..999]
07:18:18 <lambdabot>   233168
07:18:55 <mcstar> > let f [] ys = ys; f xs [] = xs; f xs'@(x:xs) ys'@(y:ys) = if x==y then x : f xs ys else if x<y then x : f xs ys' else y : f xs' ys in sum $ f [3,6..999] [5,10..999]
07:18:57 <lambdabot>   233168
07:19:08 <mcstar> to prevent some unncesesary destructuring
07:19:18 <allsystemsarego> ok, let me try this and come back
07:19:21 <mcstar> unnecessary that is
07:20:45 <mroman> allsystemsarego: but...
07:20:47 <mroman> :t max
07:20:48 <lambdabot> forall a. (Ord a) => a -> a -> a
07:20:59 <mroman> :t (+)
07:21:01 <lambdabot> forall a. (Num a) => a -> a -> a
07:21:15 <mroman> Just Ord a won't do it.
07:21:57 <raymank26> hi all. I trying to use gtk2hs with glade and I faced with a problem as in the thread http://comments.gmane.org/gmane.comp.lang.haskell.gtk2hs/1081 But my packages are up to date. What can I do to fix this?
07:22:27 <allsystemsarego> I'm still struggling to understand the type system, I probably won't know how to fix that
07:22:41 <allsystemsarego> but thanks
07:23:13 <morel> allsystemsarego: you could just remove the type signature, load it in ghci and then display the type.
07:23:40 <hpaste> morel annotated “zz” with “zz with Num” at http://hpaste.org/71046#a71048
07:25:25 <allsystemsarego> morel, mroman - thanks, that works
07:25:38 <CSWookie> Sorry about that, folks.  My computer pooped out.
07:26:11 <mcstar> CSWookie: what was the last thing you saw?
07:26:56 <CSWookie> Something involving ++
07:27:16 <mcstar> CSWookie: shall i paste it again?
07:27:24 <CSWookie> Please.
07:29:02 <hpaste> mcstar pasted “PE1” at http://hpaste.org/71049
07:29:25 <CSWookie> I'm getting errors like: No instance for (Integral (IO a))
07:29:26 <mcstar> CSWookie: probably the last one is the most efficient
07:32:41 <CSWookie> Can you walk me through what's going on there?
07:33:16 <CSWookie> I've got tutorials, even a book, but all the ys's and xs's get me turned around
07:33:29 <CSWookie> I'm used to longer variable names.
07:33:38 <mcstar> CSWookie: since the input lists are sorted in increasing order, i take the minimum of the heads of the two lists
07:33:42 <rwbarton> f at least should have a real name like merge
07:34:10 <mcstar> if they are the same, i.e. both are a multiple of 3 and 5 i only add it once to the resulting list
07:34:30 <mcstar> rwbarton: thanks for your input
07:34:52 <mcstar> f stands for function, and it is quite real
07:35:51 <mcstar> CSWookie: ofc, it is not necessary to construct a list, you could sum the numbers from the function 'f'
07:36:29 <dmwit> if | -- ?
07:36:52 <mcstar> dmwit: copied from weechat
07:37:07 <CSWookie> Man, these operators have me at a loss.
07:37:17 <mcstar> (the panel with the nicks are separated by | characters)
07:37:47 <CSWookie> Is there a list of operators and what they do?
07:37:52 <hpaste> mcstar annotated “PE1” with “PE1 (annotation)” at http://hpaste.org/71049#a71050
07:37:59 <dmwit> Can f just be map head . group . sort?
07:38:24 <mcstar> dmwit: i didnt want to use sort, since the lists are sorted
07:38:27 <dmwit> That would be nice, since then the whole function is just sum . map head . group . sort, which is a one-liner, and pretty readable, too.
07:38:40 <dmwit> They're not sorted after you concatenate them. =)
07:39:06 <mcstar> dmwit: i dont concatenate them
07:39:10 <hpc> or somewhat shorter, sum . nub . sort
07:39:15 <hpaste> b52 annotated “PE1” with “PE1 (annotation)” at http://hpaste.org/71049#a71051
07:39:19 <b52> gni hi :D
07:39:20 <hpc> > nub [1,1,2,3,2]
07:39:22 <lambdabot>   [1,2,3]
07:39:31 <dmwit> hpc: Well, nub is clearly less efficient. O(n^2) is much worse than O(n). (But O(n log n) is not.)
07:39:32 <hpc> ...except nub is slow
07:39:34 <hpc> so nvm
07:39:40 <morel> b52: hehe nice :D
07:39:46 <hpc> yeah, i thought nub was just map head . group
07:40:25 <dmwit> It's sort of a shame that Data.List doesn't expose a general merge.
07:40:29 <dmwit> I've written it half a dozen times.
07:40:58 <mcstar> dmwit: and a function that inserts a given element in every possible position of a given list
07:41:14 <mcstar> dmwit: writing the permutation function with that is extremely good
07:41:42 <dmwit> Depending on whether you're into that kind of thing, I guess http://hackage.haskell.org/packages/archive/data-ordlist/0.4.5/doc/html/Data-List-Ordered.html counts.
07:42:28 <dmwit> Which offers both merge and union. So that's nice.
07:42:32 <Franciman> hey guys, behind ST monad there is C code or is it all haskell?
07:42:52 <mcstar> @hoogle a -> [a] -> [[a]]
07:42:53 <lambdabot> Data.List intersperse :: a -> [a] -> [a]
07:42:53 <lambdabot> Data.List insertBy :: (a -> a -> Ordering) -> a -> [a] -> [a]
07:42:53 <lambdabot> Data.List deleteBy :: (a -> a -> Bool) -> a -> [a] -> [a]
07:43:03 <Franciman> I mean how does for example STArray change its values?
07:43:04 <merijn> Franciman: ST is all haskell
07:43:04 <dmwit> CSWookie: ?hoogle will tell you the type of an operator; the online version of Hoogle will also link to documentation and source.
07:43:13 <merijn> Franciman: As far as I know, anyway
07:43:29 <mcstar> dmwit: i dont see a function in Data.List.Ordered with the above signature
07:43:33 <CSWookie> ?hoogle '
07:43:34 <lambdabot> Parse error:
07:43:34 <lambdabot>   '
07:43:34 <lambdabot>   ^
07:43:40 <CSWookie> ?hoogle @
07:43:40 <lambdabot> keyword
07:43:40 <lambdabot> Test.HUnit.Base (
07:43:41 <lambdabot> Test.HUnit.Base (
07:43:55 <dmwit> mcstar: What is the function supposed to do? That's a weird type.
07:44:03 <MostAwesomeDude> Franciman: Well, ST is directly built on IO. You can go read the code but it's not very enlightening.
07:44:22 <dmwit> mcstar: Oh, yeah, Data.List.Ordered of course doesn't offer that. What does that have to do with ordered lists?
07:44:32 <sipa> MostAwesomeDude: isn't it the other way really, implementation-wise?
07:44:34 <mcstar> f 1 [2,3,4] => [[1,2,3,4], [2,1,3,4], [2,3,1,4]...
07:44:36 <Franciman> MostAwesomeDude, and in turn, is IO all the way haskell?
07:44:41 <MostAwesomeDude> Franciman: It's all written in Haskell; a couple sections have to be filled in by the compiler, but hopefully your compiler's largely written in Haskell.
07:44:50 <mcstar> dmwit: idk, you recommended that to me
07:45:07 <dmwit> mcstar: I recommended it to you for merge and union.
07:45:14 <merijn> Franciman: Depends? Part of the haskell runtime is implemented in C, part of IO comes from the runtime, part from the compiler
07:45:20 <XexonixXexillion> > let (threes, fives, fifteens) = (999 `div` 3, 999 `div` 5, 999 `div` 15) in let sigma mult x = mult * x*(x+1) `div` 2 in sigma 3 threes + sigma 5 fives - sigma 15 fifteens
07:45:21 <lambdabot>   233168
07:45:27 <mcstar> dmwit: for that id use set
07:45:33 <MostAwesomeDude> sipa: The GHC version that I read through last week had them tightly bolted together, so maybe it's technically the other way around?
07:45:45 <merijn> Franciman: Maybe if you can tell why you want to know we can provide better answers?
07:45:54 <dmwit> mcstar: uh... you *just* posted code that implements union without using Set.
07:46:05 <mcstar> omg
07:46:13 <Franciman> merijn, just curious, nothing more. I think the best way is to read source code then
07:46:20 <mcstar> dmwit: the lists are sorted
07:46:22 <merijn> Franciman: Probably
07:46:29 <dmwit> mcstar: Yes. Hence Data.List.*Ordered*
07:46:48 <mcstar> dmwit: i dont think it would have much of a pedagogical impact on cswcookie
07:46:53 <merijn> Franciman: That should be educational regardless of what you want to know :)
07:47:05 * dmwit shrugs
07:47:06 <Franciman> definitely
07:47:32 <b52> XexonixXexillion: :D
07:48:00 <alech> is there an easy way to build 32-bit binaries from a 64-bit machine with ghc or do I need a 32bit ghc for that?
07:49:08 <dmwit> You need a 32-bit GHC.
07:49:11 <HugoDaniel> <3 λ
07:49:20 <alech> dmwit: ok, thanks, time to set up a vm, then ;)
07:49:46 <dmwit> You can run 32-bit GHC's directly on 64-bit hardware, of course. The only reason to run a VM is if you want to have both a 32-bit and a 64-bit copy of the same version of GHC.
07:49:55 <merijn> HugoDaniel: Lambdas for the the Lambda God! Types for the Type Throne!
07:50:01 <dmwit> I think there's some work to make GHC become a cross-compiler, but it's not there yet.
07:50:13 <alech> dmwit: i see
07:50:24 <hpc> you still need 32-bit C libs as well
07:50:33 <hpc> which makes things a bit trickier
07:50:48 <dmwit> yes, that's very true
07:51:04 <alech> hpc: yes, I guess a VM is the cleanest solution then. And easy with vagrant.
07:54:51 <maybefbi> can I have a two dimensional array of a variable number of columns and different type for each column? each type although different are an instance of Eq and Ord
07:55:47 <daniel_-> i seem to get no output written what so ever from hPutStr or hPutStrLn
07:55:49 <daniel_-> GAH
07:55:58 <daniel_-> when trying to write to a pipe
07:56:14 <XexonixXexillion> daniel_-: It's probably block buffered
07:56:29 <morel> maybefbi: maybe use a list of tuples (where the list is the columns and the tuple is the rows) ?
07:57:00 <daniel_-> isn't it just buffered if i do hPutStr? and not hputStrLn
07:57:32 <dmwit> maybefbi: I guess you could probably hobble something together with existential types. But probably you ought to rethink things a bit.
07:57:40 <merijn> daniel_-: It's still buffered with the latter, but the buffer is flushed when it encounters a newline to a terminal
07:57:48 <XexonixXexillion> daniel_-: stdout is line buffered, but I think most other things are block buffered instead
07:57:53 <merijn> daniel_-: Pipes don't behave the same as terminals without regard to buffered
07:57:58 <merijn> err
07:58:01 <merijn> s/without/with
07:58:25 <maybefbi> dmwit, morel, how about data Column = Int | Char | String | Double | Float and then do a :: [[Column]]
07:58:32 <merijn> daniel_-: Try explicitly setting the buffering to unbuffered or flushing the handle?
07:58:39 <daniel_-> cause i do hPutStrLn (stdin process) "HELLO\r\n"
07:59:00 <daniel_-> yeah will try to explicitly flush
07:59:03 <XexonixXexillion> daniel_-: hSetBuffering <yourhandle> LineBuffering should make it act like stdout
07:59:05 <merijn> daniel_-: Try a "hFlush (stdin process)"
07:59:09 <merijn> or hSetBuffering
07:59:20 <dmwit> maybefbi: Yes, if the collection of types is short, that works, too.
07:59:25 <applicative> maybefbi: how  many columns are you wanting?
07:59:48 <dmwit> maybefbi: If the collection of types is long, you can view Dynamic as a shorthand for that.
07:59:50 <maybefbi> number of columns are arbitrary but i can limit them to a finite number of types
08:00:04 <maybefbi> Dynamic. hmm i will check it out
08:00:04 <morel> maybefbi: should it be possible that there are 5 Doubles but 10 Strings?
08:00:13 <maybefbi> morel, yes
08:00:19 <morel> maybefbi: ah! okay.
08:00:56 <dmwit> maybefbi: Oh, wait, I just reread your description. When you say "a different type for each column", is that precise?
08:01:13 <maybefbi> dmwit, not precise. that is the worst case
08:01:14 <dmwit> Will you ever have two columns that have the same type?
08:01:27 <maybefbi> dmwit, yes but they could be different too
08:01:40 <dmwit> Too bad.
08:01:52 <maybefbi> dmwit, think of a spreadsheet with two date columns and one double column
08:04:02 <maybefbi> applicative, the number of columns are arbitrary but the number of types are finite
08:06:02 <shreyash> hey there
08:06:06 <shreyash> i'm shreyash from india
08:06:10 <shreyash> i'm new to haskell
08:06:14 <XexonixXexillion> greetings
08:06:22 <shreyash> can anyone tell me something about it?
08:06:46 <shreyash> i could google it :P but it would be great to discuss it with somebdy
08:06:49 <maybefbi> shreyash, it is a functional, pure and lazy language
08:06:59 <dmwit> haskell.org has a great deal of information on Haskell.
08:07:02 <mroman> > [2,2..10]
08:07:03 <lambdabot>   [2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,...
08:07:04 <dmwit> If you have more specific questions, let us know.
08:07:04 <shreyash> lazy? :P
08:07:16 <mroman> Why isn't that [2,2,3,4,5,6]?
08:07:24 <maybefbi> shreyash, lazy means arguments to a function is not evaluated until needed
08:07:34 <dmwit> mroman: Because 2-2 = 0, so the step is 0 on each element.
08:07:38 <XexonixXexillion> > take 10 [1..]
08:07:38 <dmwit> > [2,4..10]
08:07:39 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
08:07:40 <lambdabot>   [2,4,6,8,10]
08:07:54 <mroman> i see.
08:07:56 <dmwit> > enumFromThen 2 2
08:07:58 <lambdabot>   [2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,...
08:07:59 <shreyash> ohk thanks :-)
08:08:00 <mroman> thx.
08:08:00 <dmwit> > enumFromThen 2 4
08:08:01 <lambdabot>   [2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,...
08:08:05 <CSWookie> Alright guys.  I can't even get :load euler1.hs to load when all it says is 'main = 6'
08:08:16 <mroman> CSWookie: 6 is not IO
08:08:18 <dmwit> CSWookie: 6 is not an IO action.
08:08:21 <DMcGill> is the IO monad strict?
08:08:25 <dmwit> CSWookie: Perhaps you might like main = print 6
08:08:25 <mroman> No.
08:08:38 <dmwit> DMcGill: Tricky question.
08:08:43 <DMcGill> I'm getting an error "cannot delete file, in use"
08:08:48 <DMcGill> in the code I read a file and then try to delete it
08:08:54 <dmwit> DMcGill: An IO a action is not strict in the a part.
08:08:58 <CSWookie> Husah!
08:09:00 <mcstar> have you closed it?
08:09:01 <mroman> DMcGill: Then lazyness kicks your ass ;)
08:09:02 <dmwit> DMcGill: Perhaps you forgot to close the handle after you read from the file.
08:09:04 <XexonixXexillion> DMcGill: did you use getContents or something similar?
08:09:05 <mroman> lazy reading a file locks it.
08:09:06 <DMcGill> would forcing the result of that evaluation before deleting it help?
08:09:12 <maybefbi> shreyash, in non-lazy languages if you try to implement if as a function, it will always evaluate both arguments to the function
08:09:19 <dmwit> DMcGill: Also, get a real operating system. ;-)
08:09:25 <DMcGill> I wasn't using handles, I guess I have to start?
08:09:30 <mcstar> shreyash: you will love haskell, give it a try!
08:09:34 <mroman> There is System.IO.Strict
08:09:39 <mroman> which has a strict version of readFile.
08:09:43 <dmwit> DMcGill: You can use the "strict" package
08:09:45 <dmwit> ?hackage strict
08:09:45 <danr> but it must surely be enough to read to eof
08:09:45 <lambdabot> http://hackage.haskell.org/package/strict
08:09:53 <CSWookie> Yay!
08:10:03 <dmwit> danr: Yes, but "readFile" doesn't immediately read all the way to eof.
08:10:13 <dmwit> (for example)
08:10:58 <danr> dmwit: no of course not
08:11:31 <danr> but I would presume that this works: xs <- readFile; length xs `seq` rest_of_the_program
08:11:35 <CSWookie> Now I have understanding of digital watches!k
08:11:46 <dmwit> danr: That's not totally obvious, actually.
08:11:57 <dmwit> I wouldn't be surprised if the file stayed open until the next garbage collection or something like that.
08:12:27 <\rs> dmwit: would you like to share your config?
08:12:31 <dmwit> And this is definitely a GHC thing, not a Haskell thing.
08:12:33 <danr> oh, I wouldn't have thought of GC... but I'm also getting worried that I might need to evaluate the elements as well
08:12:33 <mcstar> length xs `seq` rest_of_the_program << wth is that?
08:12:45 <DMcGill> so to reiterate: just using seq won't be enough?
08:12:49 <rwbarton> I think the unsafeInterleaveIO'd action that is feeding you characters will close the file before returning []
08:13:01 <dmwit> \rs: huh?
08:13:04 <rwbarton> so you aren't relying on garbage collection
08:13:07 <dmwit> rwbarton: Oh, that's nice.
08:13:19 <CSWookie> mcstar: Does 'n | n <- [1..999]' mean 'n = n for the range from 1 to 999'?
08:13:38 <mcstar> CSWookie: yes
08:13:57 <mcstar> the 2 ns are the same
08:14:08 <CSWookie> So, this is a list comprehension?
08:14:11 <mcstar> yes
08:14:16 <CSWookie> OK.
08:14:48 <CSWookie> I know about those from Python
08:14:57 <mcstar> think of it as the part after | introduces a binding, that bind n for all of the list comprehension
08:15:22 <dmwit> Yes, Python stole them wholesale from Haskell. =)
08:15:45 <mroman> but python is weird
08:15:56 <CSWookie> dmwit: I know.  That's why the knowledge translates so nicely.
08:16:07 <CSWookie> mroman: how so?
08:16:34 <mroman> [x for x in [1,2,3]] looks weird.
08:16:36 <mcstar> CSWookie: i think dmwit was joking
08:16:42 <mroman> but that's it :)
08:17:51 <mcstar> dont expect to get much knowledge translated from python, maybe just your problem solving experience...
08:17:57 <merijn> mcstar: Well, no. Python's list comprehensions were copied from haskell
08:18:18 <mcstar> merijn: i see, haskell's still better
08:18:21 <MostAwesomeDude> Python also copied itertools.
08:18:28 <mroman> [x*y|x<-[1,2,3],y<-[1,2,3]] can't be written directly with pythons list comprehensions afaik.
08:18:40 <mcstar> mroman: double for
08:18:49 <MostAwesomeDude> mroman: [x * y for x in xs for y in ys]
08:19:04 <mroman> oh.
08:19:05 <mroman> thanks.
08:19:07 <mroman> Did not know that.
08:19:40 <merijn> mroman: Sure it can
08:19:46 <merijn> oh, I'm late >.>
08:19:54 <mroman> Yes, too late ;)
08:20:08 <merijn> You can even have guards
08:20:46 <mcstar> but since haskell is lazy, you can do much more with ist comprehension
08:21:19 <MostAwesomeDude> (I suppose this would be a bad time to mention that Python has a fully lazy comprehension with the same syntax as LCs?)
08:21:35 <mcstar> [] -> ()
08:21:43 <MostAwesomeDude> Yep.
08:21:59 <mcstar> but can you recursively reference the list?
08:22:38 <MostAwesomeDude> Well, generator objects can only be fired once, so kinda? Gimme a sec.
08:23:24 <MostAwesomeDude> No, no, you can't do it the same way that you can in Haskell.
08:23:39 <MostAwesomeDude> There's no CAF or other way to have a genexp look at itself while running.
08:23:41 * hackagebot largeword 1.0.2 - Provides Word128, Word192 and Word256 and a way of producing other large words if required.  http://hackage.haskell.org/package/largeword-1.0.2 (DominicSteinitz)
08:24:01 <mcstar> i thought so, haskell is badass
08:24:04 <monochrom> they haven't embraced mfix :)
08:25:05 <mcstar> though, i found useful python on more than one occasions, so, it has its place
08:25:07 <\rs> will there be overloaded list comprehension? (dict/set/list comprehension) i do not know whether they can be normalized to monad comprehension
08:25:10 <MostAwesomeDude> And you haven't embraced objects. :3
08:25:21 <nand`> [y:x | x <- xs, y <- x] -- [... for y in x for x in xs] ?
08:25:51 <MostAwesomeDude> nand`: IIRC yes. Or the fors might be the other way around.
08:25:56 <abbasba> http://www.nasrtv.com/uploads/video/flv/nasr_video_4ff7e820e007c.flv.flv
08:26:14 <monochrom> smart spammer
08:26:23 <MostAwesomeDude> \rs: The general structure of monads in Python is imperative; it wouldn't make sense, at least for the Python monads I use.
08:26:56 <\rs> MostAwesomeDude: i mean whether there will be overloaded list comprehension in haskell
08:27:03 <nand`> there is
08:27:14 <MostAwesomeDude> \rs: Oh, sure. There's a language extension, MonadComprehensions.
08:27:44 <mcstar> hah, so how does that look?
08:27:51 <nand`> pretty much all concepts of list comprehensions (including guards and parallel comprehension) can be extended to (some) monads
08:27:56 <mcstar> list comprehension syntax for what?
08:28:13 <\rs> MostAwesomeDude: whether dist/set/list comprehensions can all be unified to the single monad comprehension
08:28:16 <nand`> > [x+y | x <- Just 3, y <- Nothing]
08:28:18 <lambdabot>   Couldn't match expected type `[t]'
08:28:18 <lambdabot>         against inferred type `Data.Mayb...
08:28:23 <nand`> ah, lambdabot doesn't have it set
08:28:30 <mcstar> i see
08:28:36 <mcstar> nand`: with IO?
08:28:39 <MostAwesomeDude> mcstar: http://hackage.haskell.org/trac/ghc/wiki/MonadComprehensions
08:29:09 <nand`> (The above pretty much desugars to: do { x <- Just 3; y <- Nothing; return (x+y) }
08:29:16 <\rs> MostAwesomeDude: generalized map on a Map may change its shape
08:29:35 <rwbarton> nand`: the python "for ... for ..." is the other way, though I agree the version you wrote makes more sense as English
08:30:12 <\rs> MostAwesomeDude: there seemed to be a discussion about the package set-monad on the mailing list, but i could not catch on it
08:30:43 <nand`> rwbarton: then I would consider that extremely counter-intuitive
08:31:12 <nand`> good thing I don't program python
08:31:16 <mcstar> MostAwesomeDude: lol, i remember once i read that page, forgot about it totally
08:31:25 <\rs> Python always express an anti-functional pattern to me, Ruby is much better
08:31:28 <mcstar> MostAwesomeDude: at that time i didnt know what moands were..
08:31:32 <rwbarton> a better syntax would be something like "... for x in xs and y in ys"
08:31:40 <MostAwesomeDude> nand`: It's the same order as it is in Haskell, isn't it?
08:32:05 <mcstar> rwbarton: that would imply parallal traversal
08:32:05 <rwbarton> MostAwesomeDude: yes, but as an english phrase it makes no sense
08:32:06 <nand`> MostAwesomeDude: yes but the haskell version doesn't use “for ... in ...”
08:32:14 <rwbarton> you can't parse it in a sensible way
08:32:42 <MostAwesomeDude> rwbarton, nand` : There's a less-obvious rule here, which is that if code is unreadable, maybe you should rewrite it to be readable. :3
08:32:50 <MostAwesomeDude> I don't see these in production very often.
08:32:54 <nand`> also, the Haskell version uses commas to separate the comprehensions clearly; making it more obvious that they're sequenced from left to right
08:33:30 <nand`> ’for x in xs; for y in x’ would make more sense
08:33:49 <mcstar> dmwit: ah, why didnt you tell me theres no separa ghci binary, but its ghc that provides an interactive mode?
08:34:04 * applicative thinks, or else separated by | to make it clear they're not sequenced
08:34:56 <mcstar> or did hpc tell me i cant have ghci wo ghc?
08:35:16 <hpc> i think you can ignore what i said :P
08:35:23 <dmwit> I didn't tell you that because I didn't know it. =P
08:35:39 <mcstar> this is ghci: exec "/usr/bin/ghc-7.4.2" --interactive ${1+"$@"}
08:35:53 <\rs> using less sigils are a bit abused i think, especially the or= operator in coffeescript
08:36:29 <\rs> cannot understand why they think less sigils make clearer code
08:36:57 <dmwit> ${1+"$@"} -- what the heck
08:37:34 <roconnor_> dmwit: splice 1 plus the program name interpreted as an integer into a string
08:37:46 <roconnor_> dmwit: am I right?
08:38:19 <MostAwesomeDude> It's an adorable trick for re-quoting all of the args correctly.
08:38:21 <dmwit> $@ is all the arguments.
08:38:35 <rwbarton> what's the difference to just "$@"
08:38:38 <dmwit> I thought "$@" was already a sufficient trick...
08:38:44 <dmwit> Yeah, I'm with rwbarton.
08:38:49 <rwbarton> does that fail if there are 0 arguments or something
08:38:53 <dmwit> no
08:39:07 <dmwit> I use "$@" in my local cgoban3 script and call it with 0 arguments all the time.
08:39:16 <\rs> perhaps will with ancient Bourne shell
08:40:39 <MostAwesomeDude> It fails with escaped\ spaces\ on certain shells.
08:41:06 <rwbarton> man sh doesn't even document ${x+y}...?
08:41:54 <dmwit> I can't get my test program (main = getArgs >>= print) to show anything different when run with ${1+"$@"} or "$@".
08:42:34 <\rs> ${x+y} is beyond posix
08:42:37 <rwbarton> where's geekosaur when we need him
08:42:42 <dmwit> The "Advanced Bash Scripting Guide" doesn't mention "${" anywhere. =P
08:43:36 * dmwit is reading 
08:43:36 <dmwit> flag smaller_base description: Build with the even smaller base.
08:43:38 <dmwit> um
08:43:42 * hackagebot hedis 0.5.1 - Client library for the Redis datastore: supports full command set,  pipelining.  http://hackage.haskell.org/package/hedis-0.5.1 (FalkoPeters)
08:43:44 <dmwit> http://www.gnu.org/software/bash/manual/bashref.html#Shell-Parameter-Expansion
08:44:35 <rwbarton> apparently ${x+y} checks for emptyness of x while ${x:+y} checks for unsetness of x
08:44:38 <mcstar> ${} has to do with bash arrays
08:44:43 <rwbarton> or did I do that backwards
08:44:44 <mcstar> i used it once, but forgot about it
08:45:01 <rwbarton> oh wait
08:45:27 <dmwit> mcstar: ${} seems to be the generic "start doing something interesting" string in Bash.
08:45:31 <rwbarton> yes, i have that backwards
08:45:32 <dmwit> Arrays are just one interesting thing.
08:45:54 <rwbarton> ${x} is just $x, but you can put interesting stuff after the x to do a wide variety of tricks
08:46:28 <rwbarton> so ${1+"$@"} apparently means 'if $1 is unset, then nothing, otherwise "$@"'
08:46:39 <mcstar> dmwit: ok, well one application is accessing an array by element
08:46:46 <nand`> rwbarton: seems like it
08:46:52 <nand`> rwbarton: I wonder how that meaningfully differs from "$@"
08:47:11 <dmwit> rwbarton: How is that different from "$@"?
08:47:23 <rwbarton> probably only in some ancient shell like \rs suggested
08:47:30 <nand`> maybe "$@" for empty $@ expands to "" which still gets counted as *one* argument, this argument being empty?
08:47:31 <nand`> I don't know
08:47:37 <dmwit> nand`: No, I tested that.
08:47:44 <mcstar> isnt shell scripting great?
08:47:49 <mcstar> like solvng shodoku
08:47:57 <mcstar> but you need a team to succeed
08:47:58 <dmwit> runhaskell test.hs "$@" prints [] as appropriate
08:47:59 <nand`> shelldoku
08:48:18 <dmwit> test.hs is import System.Environment; main = getArgs >>= print
08:48:37 <\rs> set -- "x  y" " " z
08:49:15 <mcstar> i always have trouble with string quoting in bash(when it has spaces, and i want to execute it later..)
08:49:20 <\rs> $@ will incur a word-splitting phrase
08:49:34 <monochrom> quoting and escaping suck
08:49:42 <rwbarton> that's what "$@" is for, it's magic
08:49:57 <nand`> this is what we need a type-safe shell for
08:50:17 <monochrom> the main solution is algebraic data type
08:50:29 <mcstar> eval set -- $VAR
08:52:18 <Lajla> So, the proper terminology for Haskell definitions is actually 'variable'?
08:52:29 <Lajla> Like, if you have let foo = 3 in foo then foo is a variable?
08:52:30 <mcstar> they dont vary much
08:52:36 <mcstar> label?
08:52:39 <twanvl> something like json for command line arguments would be a huge improvement
08:52:40 <mcstar> CAF?
08:52:40 <nand`> ‘name’
08:52:53 <Saizan> we do call them variables
08:53:03 <nand`> Lajla: the second ‘foo’ there I would call “variable”, since it's free in that expression
08:53:03 <mcstar> binding?
08:53:13 <applicative> Lajla: 'foo' is bound to 3
08:53:17 <Lajla> Ehh, it's bound right?
08:53:17 <nand`> but the left one is a definition, or bound variable
08:53:27 <Lajla> Ohhh
08:53:34 <Lajla> No, the 'then' is no longer aprt of haskell code.
08:53:36 <Lajla> THat is English
08:53:53 <rwbarton> "if you have let foo = 3 in foo then foo is a variable else return ()"
08:54:19 <rwbarton> Sadly not actually syntactically valid
08:54:23 <nand`> Lajla: by “second” I meant the “in foo”, if you were replying to me
08:54:58 <gwern> @quote emission
08:54:58 <lambdabot> jamesbritt says: Writing Haskell, for example, involves an hour of meditation followed by the emission of a fold expression.
08:55:19 <MostAwesomeDude> It's so true.
08:55:21 <twanvl> rwbarton: yes it is, since you put it in quotes :)
08:55:27 <nand`> if you have (let foo = 3 in foo) then foo is a variable else return () -- should be valid
08:55:42 <applicative> awesome quote
08:56:23 <mcstar> why would we call foo a variable?
08:56:27 <nand`> mcstar: \x -> x -- x does vary quite a bit
08:56:43 <mcstar> no
08:56:50 <mcstar> once it is bound it doesnt vary
08:56:59 * applicative cant find anything varying in id
08:57:37 <dmwit> We call foo a variable even though it doesn't vary.
08:57:38 * applicative is finding it to be unusually 'constant', even
08:57:39 <dolio> Because programmers have been misusing the term 'variable' for decades, and things don't have to be mutable to be variables.
08:57:45 <nand`> x is variable because I can substitute anything (with the right type) for it
08:57:48 <dmwit> We call apartments apartments even though they're not very far apart.
08:58:03 <dmwit> We drive on the parkway and park in the driveway.
08:58:07 <applicative> Frege went to war on the word variable in the 1880's but it seems never to have caught on
08:58:07 <dmwit> It's weird, but it's what we do.
08:58:29 <mcstar> applicative: what was the alternative?
08:58:47 <applicative> he just called them 'letters'
08:58:56 <mcstar> thats lame :)
08:59:05 <nand`> what if my variables are not letters?
08:59:12 <applicative> but that was in the context of his symbolism
08:59:30 <dmwit> Yeah, I can't say I think "letters" is much of an improvement.
08:59:31 <mcstar> i find name or label more preferable
09:00:01 <rwbarton> identifier
09:00:01 <applicative> there is an excellent rant in Tarski's  Intro to Logic circa page 1, if I remember.  Also fruitless
09:00:12 <nand`> I see no problem with “variable”, at least in the context of free variables - they make perfect sense to me. Bound names (ie. in a lambda abstraction) I would approach a bit more cautiously
09:00:17 <rwbarton> I guess identifiers can include things other than variables though
09:00:43 <applicative> whatever variables are..
09:00:49 <nand`> it's not the values that are variable; it's the fact that the name can refer to different values in different contexts
09:00:58 <rwbarton> Just isn't a variable, right?
09:01:18 <mcstar> since it starts with uppercase
09:01:42 <nand`> Just isn't a valid name for a variable, no
09:01:48 <rwbarton> but it is an identifier, and it would be a "letter" if ... it was a single letter
09:02:10 <rwbarton> so I think letter is not a replacement for variable in Haskell anyways
09:02:24 <mcstar> but Just is called a data constructor already
09:03:06 <rwbarton> right, but if we were to replace the term "variable" we wouldn't want to change the meaning
09:05:00 <nand`> maybe by explicitly clarifying their role in different usages; to disambiguate the term: ‘freevar’ for free variables in an expression, ‘absname’ for abstraction names or so
09:06:45 * applicative suddenly remembers that Russell called 'bound variables' 'apparent variables'; 'free variables' 'real variables'...
09:07:16 <mcstar> makes some sense
09:07:21 <dmwit> nand`: Why not just "free name" and "bound name", and "name" when you don't want to specify...?
09:08:04 <nand`> applicative: “real variable” <- I'd have no idea what to expect from that name, it's not very intuitive
09:08:17 <mcstar> it is a hard real variable
09:08:24 <nand`> admittedly, “free variable” isn't very obvious either. “unbound variable” would be more apparent
09:08:29 <mcstar> that truly not controlled by the binding
09:08:33 <mcstar> free
09:08:44 <applicative> well, it was because he (re-) discovered that other thing, the apparent (i.e. bound) variable
09:08:47 <nand`> or “unknown variable”, “out-of-scope variable”
09:08:58 <mcstar> it cant be out of scope
09:08:58 <nand`> nvm that last one
09:09:19 <applicative> I wonder who introduced 'free' vs 'bound'? maybe Tarski
09:09:41 <mcstar> anyway, in haskell an identifier can only change its value, if you shadow it, or recursively rebind it
09:09:46 <mcstar> so if you look at a piece of code
09:09:49 <mcstar> you see a state
09:09:58 <mcstar> and nothing varies, truly nothing
09:10:20 <dolio> Unlike math, where the variables vary all the time.
09:10:22 <nand`> “recursively rebind” ? <- you mean for tail call recursion?
09:10:35 <nand`> I'd say the only way to change the value of a name is to shadow it
09:10:36 <mcstar> nand`: general recursion
09:10:57 <mcstar> nand`: shadowing is introducing a new scope, that uses the same label, but it is static
09:11:05 <mcstar> you can see it in the static code
09:11:33 <mcstar> dolio: as opposed to other, usually imperative languages
09:12:12 <DMcGill> To the people that helped me earlier: thanks, forcing the length closed the handle and it all worked :)
09:12:26 <nand`> foo 0 = return (); foo x = do { tell [x]; foo (x-1); tell [x] } -- x still doesn't change its value anywhere, I'd say it only gets shadowed for the inner call
09:12:32 <dolio> Yes, the languages that coopted the term variable from mathematics to refer to something new.
09:13:25 <applicative> i think the use of 'variable' in programming languages is due to von Neumann, and was based on the use in physics
09:13:29 <Cale> variables vary in Haskell
09:13:41 <Cale> think about  map (\x -> x^2) [1..10]
09:13:44 <ssbr__> CS does that all the time. See also, "total function" :(
09:13:44 <Cale> x varies
09:13:48 <applicative> which makes for an unfortunately rather exalted pedigree
09:13:51 <shapr> Cale: goodp oint
09:14:20 <b52> map (^2) [1..10]
09:14:35 <mcstar> Cale: \x -> x^2 'x' doesnt vary in the body of the lambda, once it is bound
09:14:50 <Cale> mcstar: right
09:17:45 <nand`> Cale: that's how I see it too. In the body of \x -> x^2 can vary, depending on context
09:18:06 <nand`> s/can vary/x can vary/
09:18:18 * applicative if he were a machine, would make due with de Bruijn indices and have done with this nonsense
09:19:08 <nand`> variables are clearly nonsensical, we should switch to abstraction-free combinatorial calculi
09:19:27 * applicative was thinking of going over to S K and three others
09:19:48 <nand`> how about iot
09:19:56 <nand`> jot, rather
09:20:13 <applicative> what does jot do?
09:20:18 <nand`> http://esolangs.org/wiki/Jot
09:20:27 <nand`> it's a language with just one combinator
09:21:11 <nand`> (or rather, iota is)
09:21:14 <nand`> (jot is based on it)
09:21:22 <applicative> I like it that all program texts are valid....
09:21:56 <nand`> yes
09:22:10 <nand`> and it's isomorphic to all binary sequences
09:22:33 <dolio> Except the 'one combinator' doesn't satisfy the strict definition of combinators unless other combinators precede it. :)
09:23:07 <rwbarton> combinator meaning basically you can write it with a single outer \ ?
09:23:43 <rwbarton> \x1 ... xn -> [expression just involving applications among x1 ... xn]
09:23:53 <rwbarton> is that the strict definition?
09:23:54 <dolio> Basically. You give rules of the form "C<vs> = <expression in vs and other combinators>".
09:24:06 <dolio> To define the combinator C.
09:24:10 <nand`> dolio: U = λf.((fS)K); now I=UU, K = (U(U(UU)), S=(U(U(U(UU)))
09:24:48 <dolio> nand`: That definition of U refers to S and K which must already be defined.
09:25:29 <shapr> Aw, I missed johnw
09:25:36 <applicative> the definition is for mortals who can't grasp U directly
09:26:02 <azynheira> Hi All
09:26:12 * applicative is trying to grasp U directly, without success
09:26:22 <applicative> hi azynheira
09:26:56 <mcstar> once im dont with CH ill deal with tag systems
09:27:02 <mcstar> done*
09:28:33 <azynheira> I have a question ...
09:29:04 <dmwit> I have an answer!
09:29:06 <azynheira> is there any framework in Haskell that alows Elang type concurrency?
09:29:17 <azynheira> Erlang
09:29:25 <dmwit> We have Chan, yup.
09:29:39 <azynheira> is the approach similar?
09:29:49 <dmwit> Haskell actually beats Erlang on the shootout's concurrency test.
09:29:51 <dmwit> =)
09:30:16 <azynheira> nice,  is there a nice scheduler or is the OS doing it?
09:30:33 <dmwit> GHC has an m-to-n thread scheduler.
09:30:40 <shapr> State, ST, STRef,  IORef, MVar, TMVar... is there a single document describing the circumstances that lead to the use of any one of those over the others?
09:30:59 <mcstar> and f# beats haskell for 3:1
09:31:14 <mcstar> well, im not sure if its the same test
09:31:25 <azynheira> but the runnable units (meaning executables) run standalone ...
09:31:28 <Nafai> shapr: How's the GSOC going?
09:31:37 <azynheira> not insde GHCI correct?
09:31:39 <shapr> Nafai: Slowly, but I continue to make progress.
09:31:54 <shapr> Nafai: Got any code flowing in your summer?
09:32:13 <dmwit> azynheira: http://community.haskell.org/~simonmar/slides/cadarache2012/ are really good
09:32:25 <dmwit> shapr: You should look there too.
09:32:28 <azynheira> so all the schduling is done by Haskell RT and not the OS
09:32:32 <dmwit> It discusses when to use each of those, and IVar, too.
09:32:40 <azynheira> Thanks
09:32:42 <azynheira> :)
09:32:55 <shapr> dmwit: Oh really?!
09:33:06 <dmwit> azynheira: That's partly true. The OS does get a bit of a say.
09:33:06 <azynheira> Is is production quality already?
09:33:14 <dmwit> azynheira: Hence the "to-n" part of "m-to-n".
09:33:22 <azynheira> correct
09:33:35 <azynheira> In Erlang I believe its the same crap ...
09:33:37 <dmwit> shapr: yarly
09:33:57 <rwbarton> is there a one-combinator basis where the combinator does not involve other combinators in its definition?
09:34:11 <dmwit> shapr: Hm, actually, not quite, I guess. It only discusses the differences between the parallel ones: MVar, TVar, TMVar, IVar, IORef
09:34:55 <rwbarton> it's not clear to me what kind of constraint being able to be defined as a single \x1 ... xn -> [expression just involving applications among x1 ... xn] puts on a term
09:36:14 <Nafai> shapr: not recently, unfortunately, been fighting to stay healthy
09:36:21 <shapr> Nafai: Ah, I hope that works out.
09:36:33 <BMeph> It's good news/bad news: Haskell's been "production quality" for years (good news!); however, (bad news) MS, among others, have lowered the bar for what qualifies as "production quality". :/
09:36:48 <rwbarton> according to the internet: the answer is no
09:37:30 <dmwit> rwbarton: X = \a b c d -> c d (a (\x. d)), according to
09:37:34 <dmwit> http://www.staff.science.uu.nl/~fokke101/article/combinat/index.html
09:37:58 <rwbarton> I want one with no nested lambdas like that (\x. d), though
09:38:39 <dmwit> ah
09:38:50 * BMeph wonders what happens to the 'b'...
09:39:07 <dmwit> BMeph: Nothing. =)
09:39:27 <rwbarton> P. Bellot,   "A New Proof for Craig's Theorem" supposedly has a proof that the answer is no
09:43:15 <hpaste> “Mihai Maruseac” pasted “Three versions of same problem (maximum sum of non-repeating elements)” at http://hpaste.org/71054
09:43:28 <mm|swarm> hello
09:43:43 <mm|swarm> do you have some suggestions for http://hpaste.org/71054
09:43:44 <mm|swarm> ?
09:44:03 <mm|swarm> any suggestion: coding style, explanations (I'm teaching someone), other solutions
09:44:10 <mm|swarm> basic
09:44:43 <mm|swarm> the problem was to return the maximum sum of a sub-sequence containing non-consecutive elements from a given list
09:45:00 * BMeph has a suggestion: More cowbell! ;)
09:45:14 <mm|swarm> for example for input [1,2,3,4] the code must return 6 (2 + 4)
09:46:40 <mcstar> any subsequence?
09:46:47 <dmwit> Looks inefficient.
09:46:58 <dmwit> You might be interested in the Google search term "dynamic programming".
09:47:54 <mm|swarm> dmwit: of course :)
09:48:02 <mm|swarm> but the student didn't learn about it
09:48:07 <mm|swarm> it is the second step
09:48:15 <mm|swarm> (dynamic programming that is)
09:48:51 <mm|swarm> mcstar: any subsequence as long as two elements which are next to one another in the original list are not in the sum
09:49:44 <dmwit> Also the quickcheck properties don't pass here, so that's a bad sign.
09:50:01 <dmwit> propSameOriginalSecond falsifiable: [2,1,1,2]
09:50:26 <dmwit> The original seems to get that wrong.
09:50:31 <BMeph> mm|swarm: Just me, but instead of 'filterM (const [True, False])' you could just use 'subsequences' - it "says what it means". :)
09:50:46 <mm|swarm> that's true, original is student work, first is with some patterns removed but the same thing and second is a brute force solution per-se
09:50:49 <dmwit> Yes, excludeHead [x,y,z] = y -- this is just wrong
09:51:04 <mm|swarm> BMeph: ah, oops, I forgot that subsequences exists :">
09:51:22 <dmwit> Generally speaking, I would say base cases which extend beyond, say, singleton lists make me squint and worry.
09:53:42 <mm|swarm> thanks :D
09:55:09 <rwbarton> > subsequences [1,2,3]
09:55:10 <lambdabot>   [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]
09:55:19 <rwbarton> oh huh
09:55:52 <mm|swarm> when you have a hammer...:)
09:56:31 <twanvl_> > let maxSkipSum = uncurry max . foldr f (0,0) where f x (a,b) = (max 0 x + b, max a b)  in maxSkipSum [1,2,3,4]
09:56:34 <lambdabot>   6
09:57:16 <mm|swarm> let maxSkipSum = uncurry max . foldr f (0,0) where f x (a,b) = (max 0 x + b, max a b)  in maxSkipSum [1,2,3,4]
09:57:23 <mm|swarm> let maxSkipSum = uncurry max . foldr f (0,0) where f x (a,b) = (max 0 x + b, max a b)  in maxSkipSum [1,3, 1, 1, 2]
09:57:31 <hpaste> dmwit pasted “dynamic programming version” at http://hpaste.org/71055
09:57:32 <mm|swarm> > let maxSkipSum = uncurry max . foldr f (0,0) where f x (a,b) = (max 0 x + b, max a b)  in maxSkipSum [1,3, 1, 1, 2]
09:57:35 <lambdabot>   5
09:57:47 <mm|swarm> twanvl_: cool :D
09:57:48 <mm|swarm> thanks
09:57:48 <dmwit> Right, that's basically the same.
09:58:10 <mm|swarm> dmwit: thanks
09:58:10 <mm|swarm> :D
09:58:29 <dmwit> twanvl_ was faster. =)
09:58:57 <mroman> hm.
09:59:30 <mroman> Possible subsequences of [1,3,1,1,2] are [1,1,2] and [3,1] ?
09:59:33 <dmwit> By the way, in your quick-check test, you might like to use "map abs xs" to enforce positive lists instead of checking.
09:59:41 <dmwit> You'll get a lot more tests out of each run that way.
10:00:03 <twanvl> dmwit: our solutions are surprisingly similar
10:00:26 <dmwit> checkFunctions f f' xs = f (map abs xs) == f' (map abs xs); propSameOriginalFirst = checkFunctions f f'; propSameOriginalSecond = checkFunctions f f''; propSameFirstSecond = checkFunctions f' f''
10:00:27 <mm|swarm> mroman: yes
10:00:29 <twanvl> or you can use a quickcheck generator that only generates positive numbers
10:00:33 <mroman> [1,1,2],[3,1],[3,2]
10:00:40 <mm|swarm> dmwit: cool, thanks
10:00:41 <mroman> and 3,2 is the 5.
10:00:57 <dmwit> twanvl: Basically identical, except that yours uses the thinking-man's version (foldr instead of explicit recursion). =)
10:01:28 <twanvl> I also started with explicit recursion, and then realized that foldr would work
10:03:23 <twanvl> checkFunctions f f' xs = f (map getNonNegative xs) == f' (map getNonNegative xs) -- to make quickcheck generate non-negative numbers only, though it just uses abs under the hood
10:03:52 <mm|swarm> thanks, its better now :D
10:04:55 <dmwit> In fact, f' and f'' aren't the same, either.
10:05:08 <mm|swarm> f and f'
10:05:19 <mm|swarm> only them should be the same
10:05:33 <mm|swarm> for positive numbers that is
10:05:43 <dmwit> f and f' are not the same
10:05:50 <dmwit> [1,0,0,1] distinguishes them.
10:06:08 <mm|swarm> hmm, you're right
10:06:10 <mm|swarm> my bad
10:08:41 <quince> > let startswith x = flip isPrefixOf x did what I expected, but let startswith = flip isPrefix of gives me a function startswith :: [()] -> [()] -> Bool.  Where do the empty tuples come from?
10:08:43 <lambdabot>   <no location info>: parse error on input `,'
10:09:20 <quince> s/of gives/ gives/
10:09:21 <Taneb> Is there a module for getting info from Hackage
10:09:50 <quince> oops, let's try that again:  > let startswith x = flip isPrefixOf x did what I expected, but let startswith = flip isPrefixOf gives me a function startswith :: [()] -> [()] -> Bool.  Where do the empty tuples come from?
10:10:38 <rwbarton> the monomorphism restriction
10:11:34 <rwbarton> variable bindings (i.e. ones without arguments) can't be polymorphic in a type class unless you give an explicit type signature (or turn off the monomorphism restriction)
10:13:13 <monochrom> ghci prompt has more type defaulting than loading code from file
10:13:25 <Tomsik> What is the performance difference between lenses and records currently?
10:14:11 <Tomsik> Is it something that has a run-time penalty? Or is it mostly compile time thing?
10:14:36 <Tomsik> Because for example compiler can know statically the size of the record or something
10:14:58 <dmwit> Store-based lenses are pretty cheap.
10:15:05 <MostAwesomeDude> I could have sworn that records were merely sugar.
10:15:12 <hpc> they are
10:15:14 <monochrom> I haven't tried but I would either benchmark or look at generated code to find out
10:15:19 <dmwit> Probably not 0-cost, but I would be very surprised if that's the bottleneck in any sane code.
10:16:50 <mcstar> ah, working great
10:16:52 <Tomsik> I'm wondering if they would be useful for writing for example a game
10:17:04 <Tomsik> Or if they would slow it down a lot, with many updates or something
10:17:29 <Tomsik> I mean, in a sane design it's probably this vs ST/IO
10:19:09 * MostAwesomeDude tries a thing
10:20:53 <hpaste> mcstar pasted “too late” at http://hpaste.org/71056
10:21:19 <mcstar> ^^ thats my version of the subsequence thing
10:21:29 <mcstar> dmwit: you were very fast
10:21:44 <mcstar> dmwit: do you have the AC on?
10:21:49 <quince> rwbarton: why does ghci not reject the definition?
10:22:14 <dmwit> quince: Because it's well-typed.
10:22:22 <rwbarton> it defaults the type instead
10:22:29 <rwbarton> that's where () comes from
10:22:54 <quince> why is that a good thing?
10:23:20 <rwbarton> the purpose of the monomorphism restriction is to avoid unexpected recomputation of what look like constants
10:23:48 <monochrom> furthermore, the ghci prompt cannot access the future
10:23:56 <rwbarton> if I write "x = 2 + 2" at top level, and then use x multiple times, without the monomorphism restriction x will be recomputed each time it is uesd
10:24:02 <dmwit> quince: Typeclass polymorphic values are implemented as functions from typeclass dictionaries to values. This can be confusing, since the type doesn't look like a function.
10:24:16 <dmwit> Making it monomorphic prevents this confusion, since neither the type nor the implementation will be a function.
10:24:21 <rwbarton> yes, normally the compiler has the rest of your program with which to make an informed choice of the type
10:25:42 <dmwit> NoMR for Haskell2012!
10:25:57 <dmwit> Also infixl $
10:26:12 <dmwit> mcstar: I... yes, but not in this room?
10:26:49 <dmwit> And I wasn't that fast. twanvl was faster and dealt with lists with negatives in them, too. =P
10:27:05 <dmwit> But he didn't write a quickcheck test, I bet. haha
10:27:38 <quince> So there are other uses of this feature that are considered useful, and that involve type variables?
10:27:55 <dmwit> I don't think so.
10:27:59 <dmwit> Basically everybody hates it.
10:28:08 <monochrom> I don't understand the question
10:28:29 <dmwit> I think "this feature" is the monomorphism restriction.
10:28:48 <dmwit> quince: There are times when you want to take an otherwise polymorphic value and make it monomorphic.
10:28:48 <quince> right
10:29:01 <dmwit> But the monomorphism restriction is pretty clearly the wrong heuristic for deciding when to do that.
10:29:06 <rwbarton> the "use" is that without it your program may run much slower than you expect
10:29:14 <dmwit> It's too often along one axis and not often enough along another.
10:29:17 <monochrom> that's the thing. when you take advantage of the monomorphism restriction, you do not involve type variables.
10:29:40 <quince> if it rejected my program, it wouldn't run slowly
10:29:54 <rwbarton> right
10:30:09 <quince> but it doesn't reject it :-(
10:30:12 <dmwit> Rejecting programs also seems to me to be the wrong choice.
10:30:14 <rwbarton> it still doesn't run slowly
10:30:33 <rwbarton> (also, in your case we are talking about "recomputing" flip isPrefixOf)
10:30:54 <rwbarton> with the MR, the only way to get your program to run slowly is to write an explicit type signature that says "I don't care about recomputing this value"
10:31:11 <dmwit> ...or use *any* type class that isn't in the Prelude...
10:31:15 <rwbarton> what?
10:31:28 <rwbarton> MR doesn't care about that
10:31:42 <dmwit> agh, right, defaulting /= MR
10:31:43 <rwbarton> normally defaulting does not come into play either
10:32:01 <rwbarton> because the type is constrained elsewhere
10:33:20 <monochrom> the product of monomorphism and defaulting is more than the sum
10:33:27 <quince> I don't know anything about how haskell is implemented, so I don't understand all this.  But it seems intuitively obvious that deciding to reject more programs as invalid will not cause a performance problem.
10:34:03 <azynheira> bye ... thanks all
10:34:08 <monochrom> different people have opposing intuitions
10:34:10 <rwbarton> right, the MR is basically rejecting some programs that otherwise would/might run slowly
10:34:35 <rwbarton> those in which you make a variable binding and use it at several types
10:34:51 <quince> I was surprised that there is not some additional restriction rather than "guessing" a type
10:35:17 <dmwit> quince: Yes, you're right. And you may be getting confused by me, because I said some incorrect things above.
10:35:22 <dmwit> The MR rejects some programs.
10:35:38 <dmwit> But defaulting re-accepts some when it can come up with a plan to make your program work without causing performance problems.
10:35:54 <rwbarton> e.g. "x = 3; main = do print x; print x"
10:36:12 <dmwit> In ghci, this can be ever-so-slightly not the right thing to do, because it may have to make some of those decisions before it has seen the whole program.
10:36:23 <quince> defaulting = selecting type ()?
10:36:36 <dmwit> So defaulting might re-accept some programs with a different type than it would re-accept them if it had the rest of the program to look at.
10:36:40 <rwbarton> there is a list of types it tries in order, that you can configure
10:36:42 <dmwit> quince: Yes, defaulting here is selecting type ().
10:36:42 <mcstar> dmwit: im such a noob, yours work on 10k elements faster than mine on 20
10:36:54 * eikke having fun with 'vector' and SSE/SIMD
10:36:59 <eikke> with good results: http://linode2.nicolast.be/files/vector-simd-xor1.html
10:37:23 <dmwit> eikke: Oh, great! Did you have to compile a branch of GHC yourself, or was I just flat wrong the other day?
10:37:39 * mcstar goes, and buries himself
10:37:49 <eikke> dmwit: that's using plain C for the SSE stuff, not using the new SIMD primops
10:37:58 <dmwit> mcstar: That's what dynamic programming will do for you. =)
10:38:01 <eikke> dmwit: and a custom Vector type with alignment tracking (as I discussed in the mail)
10:38:09 <monochrom> put "startswith = flip isPrefixOf" in a file. load it. you get rejection. I hope you're happy now
10:38:20 <dmwit> eikke: aha
10:38:35 <rwbarton> or here is an example
10:38:37 <eikke> and finally using ISPC-generated assembler for the actual hot loop
10:38:39 <monochrom> ghci prompt is not equivalent to loading or compiling file code
10:38:45 * hackagebot BlogLiterately 0.5 - A tool for posting Haskelly articles to blogs  http://hackage.haskell.org/package/BlogLiterately-0.5 (BrentYorgey)
10:38:48 <mcstar> dmwit: is it like the recursive (naive) version made iterative?
10:39:10 <rwbarton> in ghci "let x = 3" and then "print $ sin x" will fail
10:39:11 <dmwit> mcstar: I'm not sure what the naive version is.
10:39:18 <rwbarton> but in a .hs file "x = 3; main = print $ sin x" will work
10:39:22 <dmwit> mcstar: But probably not. I don't think iteratively any more.
10:40:40 <rwbarton> in the latter case, the compiler sees that x is a variable binding with type (Num a, Floating a, Show a) => a (Num is redundant); the MR forces the type to be monomorphic and it defaults the choice to Double
10:42:03 <quince> monochrom: ah, I hadn't realised that
10:42:25 <rwbarton> that part is because ghci has different rules for when to default
10:43:43 <quince> where are these default lists of types defined?
10:46:19 <dmwit> http://www.haskell.org/onlinereport/decls.html#overloading 4.3.4, I guess
10:46:25 <rwbarton> yeah
10:46:33 <rwbarton> and ghci adds () to the front: http://www.haskell.org/ghc/docs/latest/html/users_guide/interactive-evaluation.html#extended-default-rules
10:47:29 <dmwit> http://www.haskell.org/onlinereport/haskell2010/haskellch4.html#x10-790004.3.4 if you prefer the H2010 spec ;-)
10:48:14 <quince> rwbarton: ah I see - I was searching for "tuple" on that haskell report page and couldn't find it, that explains why
10:49:34 <monochrom> it is ironic. every deviation of ghci prompt is justified by saying why it ought to make your life easier. but every deviation, by definition, makes your life harder, i.e., you can't reproduce the behaviour with file code
10:50:05 <mroman> > data Foo b deriving Show; Foo 3;
10:50:07 <quince> I can't disagree with you so far!
10:50:07 <lambdabot>   <no location info>: parse error on input `data'
10:50:42 <dmwit> mroman: lambdabot doesn't do that, and you probably meant data Foo b = Foo b anyway
10:50:47 <monochrom> when you go multi-threading, ghci has yet another trap for you
10:51:11 <quince> thanks everyone.  So far haskell has been surprisingly unsurprising overall.
10:51:19 <quince> in a good way :-)
10:52:47 <quince> I wonder if there is an alternative to ghci that has fewer differences from the regular "file code" behaviour?
10:53:29 <dmwit> There's not really much you can do.
10:53:41 <dmwit> Since the "file" doesn't really "end".
10:53:43 <monochrom> to a large extent, ":load blah.hs" at the ghci prompt eliminates a lot of the deviations
10:54:04 <dmwit> yes
10:54:16 <hpc> or even simpler, ":r"
10:54:29 <dmwit> To avoid the differences from loading files, don't do anything but load files. =)
10:55:05 <hpc> really, ghci is there for you to interact with files
10:55:10 <hpc> not for you to write them in it
10:57:52 <otters> so I've been using data-lens for accessors on a pretty complex datatype defined with record syntax
10:58:07 <otters> and my question is, in what case would you use the lens getter instead of the getter function that's automatically created by the data declaration?
10:58:20 <donri> data-lens? no one uses that anymore! it's all lens-family these days! ;)
10:58:27 <monochrom> hehe
10:58:31 <otters> but but but but
10:59:03 <monochrom> I haven't used either. I can't answer. but go with your heart
10:59:22 <otters> it just seems like it's more work
10:59:23 <favonia> quince: you can also check :e, which will launch your favorite editor and reload the file after you finish
10:59:25 <donri> yes, use whatever most clearly communicates your intentions
10:59:30 <parcs`> otters: get field vs _field is identical
10:59:37 <otters> yeah, that's what I'm saying
10:59:42 <otters> just with some extra overhead
10:59:59 <donri> with lens-family you can easily make any function a read-only lens so it integrates more easily with things that aren't naturally lenses
11:00:12 <otters> I see
11:00:33 <rwbarton> so then "get field" is possibly more future-proof
11:00:54 <donri> well, if you're only "getting", it doesn't really matter either way
11:00:55 <otters> I don't see how that would be unless they change the implementation of record syntax
11:01:01 <otters> no, I'm doing setting mostly
11:01:25 <rwbarton> for example you may later rearrange your datatype so that _field is no longer a direct field of the record but a field of a subrecord
11:01:30 <dmwit> otters: You use "get" when you're actually exploiting the first-class-ness of lenses.
11:01:34 <donri> though, if you're going to be composing, it might matter which you're going to have more of, lenses or normal functions
11:01:38 <dmwit> otters: That is, when somebody else is handing you a lens.
11:01:42 <otters> oh, okay
11:02:10 <donri> otters: record field getters suck for setting, so, in that case stick with lenses
11:02:26 <otters> yeah, I love the setting capability
11:02:48 <otters> before I discovered lenses I just defined a bunch of helper functions a la onField f x = x { field = f (field x) }
11:03:07 <donri> personally i hide the _fields from being exported (and write the Show instances manually to look less like records)
11:03:13 <b52> im curious, are there any libraries designed for haskell but written in c?
11:03:24 <otters> actually, that may be a better idea
11:03:52 <otters> but the datatype is defined in a Types module and then the implementation details are in a different module
11:04:03 <otters> so the implementation module would have to know the fields
11:04:08 <donri> although i should find a better way to do that because my way you get no docs for fields or lenses other than the types :/
11:04:18 <otters> programming is hard
11:04:41 <donri> otters: i do export the lenses, that's the point
11:05:04 <quince> Talking of ghci, does anybody know how to get similar behaviour in ghci to bash's M-. or M-_ (yank-last-arg)?  I'm forever typing :t foo, and then foo ... on the next line
11:05:13 <otters> donri: can you automatically derive them with data-lens?
11:05:19 <otters> I don't think it has that feature
11:05:23 <otters> I know one of the lens libraries did
11:05:27 <GuidovanPossum> I just learn enough of a language until it gets hard and then switch, which brings me here
11:05:32 <raek> what are the most common free software / open source licenses for Haskell projects?
11:05:34 <dmwit> quince: man readline, I think
11:05:34 <donri> otters: data-lens-template?
11:05:48 <otters> oh yeah
11:06:06 <otters> neat! that'll do it
11:06:10 <parcs`> raek: bsd3 i think
11:06:28 <quince> dmwit: googling seemed to suggest it uses haskelline
11:06:34 <dmwit> quince: yes
11:06:47 <donri> hm can you parse/generate comments with th
11:06:48 <rwbarton> b52: perhaps http://hackage.haskell.org/package/cipher-aes qualifies? just posted today
11:07:19 <nand`> dolio: but S and K can be defined in terms of the lambda calculus, so as a result U itself can be completely defined by the lambda calculus: U = λf.(f (λx.λy.λz.xz(yz)))(λx.λy.x)
11:07:34 <donri> doesn't look like it :/ would have to make it a preproc
11:07:43 <donri> maybe sugarhaskell to the rescue in the future
11:07:43 <nand`> (sorry for the extremely delayed response)
11:11:08 <otters> huh
11:11:28 <otters> what's the best way to access the same object from multiple lenses in one statement?
11:11:31 <otters> if there is such a thing
11:12:00 <otters> until now I was using something like (a,b) <- gets (field1 &&& field2)
11:12:52 <nand`> a <- gets field1; b <- gets fields2 -- is how I would do it
11:12:58 <nand`> doesn't answer your question though
11:14:03 <parcs`> otters: you can't
11:14:11 <donri> (a,b) <- (,) <$> access lens1 <*> access lens2  -- not really better than yours :p
11:14:27 <raek> parcs`: ok. do you know if any copyleft ones (like GPL or LGPL) are common?
11:14:29 <otters> damn
11:14:35 <otters> well, that's probably for the best anyway
11:14:48 <dmwit> Lenses only have a tensor product, not a true categorical product. This is the restriction you are running into right now.
11:15:23 <donri> well you can get the getters and &&& those
11:15:31 <dmwit> Imagine for a moment trying to combine the id lens with itself (so you get two copies of the object), and ask yourself what should happen when you write two different copies back.
11:15:41 <otters> I can't even imagine
11:16:11 <dmwit> donri: Yes, read-only "lenses" (that is, plain old functions) do have this operation.
11:16:28 <parcs`> raek: gpl is somewhat common, i'm not sure about lgpl
11:16:41 <donri> otters: btw "access" is a thing, data-lens-fd
11:17:49 <raek> parcs`: ok, thanks!
11:18:09 <otters> donri: thanks, will look at that
11:18:34 <donri> otters: usually you'll want to use one of the setting operators instead, though
11:19:56 <otters> I don't think I can use data-lens-fd
11:20:07 <donri> otters: also lens-family does all of the above and is easy to convert to from data-lens code
11:20:20 <donri> oh?
11:20:33 <quince> dmwit: it seems haskeline does not support the yank-last-arg behaviour, unfortunately.  Only key sequences.  However, this ~/.haskeline works for the :t use case: bind: meta-. ctrl-p ctrl-a ctrl-d ctrl-d ctrl-d ctrl-e
11:20:42 <otters> yeah, I sort of had to write my own helper functions even though I'm using StateT
11:20:43 <donri> i assumed from your "gets" you're working with MonadState instance
11:20:52 <otters> because the state is in an MVar
11:20:56 <parcs`> wait
11:21:10 <parcs`> otters: you can do gets (getL field1 &&& getL field2)
11:21:11 <raek> in cabal projects, do you put the source of the Foo.Bar module in ProjectRoot/Foo/Bar.hs or in ProjectRoot/src/Foo/Bar.hs?
11:21:24 <donri> uh, you have mutable state inside a functional state? :D
11:21:24 <otters> so I defined some functions that fetch the MVar from the state, then return the value inside the MVar
11:21:31 <otters> it's the only way!
11:21:52 <otters> oh no, it's not an MVar
11:21:54 <otters> it's a TVar
11:22:03 <donri> you could probably whip something together using runState that wraps all that for you
11:22:07 <dmwit> quince: ouch
11:22:15 <otters> donri: that's what I'm trying to solve
11:22:37 <otters> StateT (TVar Foo) IO
11:22:56 <donri> but why do you have StateT at all there
11:22:59 <dmwit> raek: Your choice. You just have to tell which it is in your .cabal file.
11:23:02 <donri> don't you want ReaderT?
11:23:20 <otters> huh
11:23:21 <otters> do I?
11:23:31 <dmwit> raek: Nothing special is needed for the former; a "hs-source-dirs: src" is needed for the latter.
11:23:34 <otters> that might be it
11:23:58 <otters> using MonadState backed by a ReaderT with a TVar
11:24:00 <donri> well the TVar itself is mutable, so you normally don't want to replace it but rather just mutate it in place
11:24:05 <otters> so get, put, modify etc. operate on the TVar
11:24:06 <raek> dmwit: neat. thanks!
11:24:14 <donri> sure, you could do that in deed
11:24:29 <otters> donri: I tried that a couple weeks ago and just how to do it completely escaped me
11:24:31 <otters> but I'll give it another shot
11:25:17 <donri> although if it's a TVar you might want finer control over atomic?
11:25:36 <donri> rather than having get and put separately atomic
11:25:36 <otters> for the moment I was just having all operations be atomic
11:25:46 <otters> although modify is a single operation
11:25:49 <donri> well, then you don't fully benefit from stm i don't think
11:26:05 <otters> I rarely if ever use put, just modify
11:26:29 <donri> but modify is defined in terms of get+put
11:26:41 <otters> yeah but my helper was defined in terms of modifyTVar
11:27:04 <donri> but data-lens-fd won't be using your helper
11:27:33 <otters> doesn't it internally use modify?
11:27:46 <otters> if I define modify to use modifyTVar, it should work
11:27:47 <donri> yes, the one from mtl, not yours
11:27:54 <donri> modify isn't part of the MonadState class
11:28:24 <otters> oh it's part of Control.Monad.State
11:29:23 <otters> huh
11:29:28 <donri> so what i'm proposing is some helper that runs a state computation atomically
11:29:47 <donri> as a whole
11:29:51 <otters> oh
11:30:00 <raek> what is the convention for cabal project names? words separated by hyphens? what about case?
11:30:15 <rwbarton> all lowercase with hyphens is the most common
11:30:21 <raek> ok, thanks
11:30:38 <raek> all US-ASCII, I presume...
11:30:53 <donri> like, doit (bla += 1) translates to, atomically $ do mvar <- readMVar; putMVar (runState ... mvar)
11:30:55 <donri> or whatever
11:30:55 <donri> bbl
11:31:04 <otters> oh okay
11:31:08 <donri> (+= is from data-lens-fd)
11:31:12 <otters> right
11:31:21 <otters> okay, let me see
11:32:05 <dolio> nand`: The definitions in a combinator calculus aren't allowed to use lambda expressions, by the traditional definition. That's the point.
11:32:21 <dolio> The combinator calculus doesn't have lambda expressions.
11:33:21 <nand`> dolio: really? which definition is this going by?
11:34:26 <nand`> oh, the ones from combinatory logic
11:37:32 <mkramer> I'm sure this is quite simple once I get the hang of it, but I'm running in this problem when I try to create a new abstract type.  http://hpaste.org/71057
11:38:20 <mkramer> I have a data Row = Blocks [Int]  declaration, and I want to convert a function from (Int -> [[Int]]) to (Int -> [Row])
11:38:29 <mkramer> but there doesn't seem to a simple mechanical translation
11:38:54 <mkramer> I have to take the [Int] out of the Row in order to call some functions that know how to do stuff to a [Int] but not to a Row
11:39:16 <parcs`> if f is your function, then 'map Row . f'
11:39:50 <mkramer> it would be map Blocks . f, but that's not the problem
11:39:59 <mkramer> I want to redefine f so that f :: Int -> [Row]
11:41:04 <mkramer> oh, ok, I could do it to rhelper
11:41:46 <ClaudiusMaximus> what you could do mechanically is change the type signature, see where the compiler complains, fix that, retry
11:41:47 <tippenein> I get this warning when installing haskell packages: {PACKAGE}: Warning: haddock-interfaces: /usr/share/doc/{PACKAGE}/html/{PACKAGE}.haddock doesn't exist or isn't a file
11:43:13 <MostAwesomeDude> Tomsik: BTW, I tested a simple get and set operation with records vs. lenses, and they behave the same at -O1.
11:45:52 <otters> dammit
11:49:55 <ronwalf> Anyone build GHC HEAD on mac?  'configure' is complaining about a lack of 'objdump', which isn't a common tool on macs ('otool' has the same functionality)
11:51:24 <alpounet> ronwalf, you may want to ask on ghc-users/haskell-cafe and #ghc for IRC
11:51:39 <ronwalf> alpounet: Thanks
11:52:04 <alpounet> (the first two are mailing lists, just in case you haven't heard about them, which is unlikely but just saying anyway)
11:52:34 <hpaste> otters pasted “execStateAtomic” at http://hpaste.org/71058
11:52:37 <otters> donri: ^
11:57:56 <spree> didnt someone do something in haskell that had to do with x window?
11:58:56 <MostAwesomeDude> You mean, xmonad? :3
12:00:02 <hpaste> mkramer pasted “Does "stacksWith" automatically memoize?” at http://hpaste.org/71059
12:00:30 <mkramer> This is an old interview problem that I originally solved in Ruby and then again in C
12:00:41 <mkramer> translated to Haskell as an exercise to learn Haskell
12:00:45 <mkramer> but…it's taking too long
12:01:19 <mkramer> I suspect that the reason is that stacksWith is recomputing the answer for identical rows
12:01:29 <mkramer> is that possible?
12:10:07 <mkramer> Doesn't Haskell automatically memoize expressions?  Isn't that one of the major advantages of side-effect free semantics?
12:10:30 <mkramer> why would you ever compute f(3) more than once, except to save space?
12:10:34 <copumpkin> no
12:10:40 <ronwalf> Saving space is good!
12:10:42 <copumpkin> precisely that
12:10:47 <copumpkin> you could use arbitrarily much space
12:10:55 <copumpkin> we have a lot more time than we have memory
12:11:09 <MostAwesomeDude> GHC memoizes CAFs IIRC.
12:11:15 <copumpkin> not even that
12:11:24 <MostAwesomeDude> Really?
12:11:41 <copumpkin> they're not special
12:11:45 <copumpkin> they just tend to be harder to release
12:12:14 <spree> so does haskell memoize or not?
12:12:39 <copumpkin> the only form of "memoization" it does is to not evaluate a given thunk more than once, roughly
12:13:17 <mkramer> But f(3) is "a given thunk"...right?
12:13:27 <copumpkin> yeah, but who wholds onto that?
12:13:34 <copumpkin> -w
12:13:39 <copumpkin> if I say
12:13:45 <copumpkin> let x = f 3 in … x … x
12:13:56 <copumpkin> then x is bound to that thunk
12:13:59 <copumpkin> and won't get evaluated more than once
12:14:07 <copumpkin> calling f 3 again will give you a different thunk
12:14:25 <eviltwin_b> there is no automatic memorization.  there are some cases where sharing gives the appearance of memoization, most especially when computation of a value shares with a previous iteration of the function in question (recursive definitions such as fibonacci)
12:14:39 <eviltwin_b> if you want memnoization there are packages on hackage which will do it in variosu ways
12:15:16 <copumpkin> you _can_ write memoization combinators purely, using that thunk evaluation behavior
12:15:23 <copumpkin> but you need to write things slightly differently to make that happen
12:15:39 <copumpkin> so it's not like to write memoized functions, you need to drop down to IORefs and unsafePerformIO
12:16:11 <mkramer> Ok, cool, let me play with that
12:16:26 <mkramer> thanks :)
12:16:27 <copumpkin> mkramer: try http://hackage.haskell.org/package/data-memocombinators/
12:16:42 <copumpkin> if you understand the evaluation model clearly, that should make sense
12:16:47 <copumpkin> it's kind of clever
12:32:01 <gwern> good grief http://www.haskell.org/haskellwiki/Special:Ipblocklist
12:41:37 <chazor> Has anybody used Haskell to write Chrome NaCl applications?
12:41:58 <shapr> gwern: much spam?
12:42:08 <gwern> no kidding
12:42:19 <Taneb> gwern, well done
12:42:45 <shapr> chazor: I don't know anything about NaCl apps, what does it require?
12:42:58 <Taneb> I used to admin a wiki, it ended with the owner stopping the creation of all new user accounts without admin permission
12:43:09 <mcstar> http://i.imgur.com/mK6F9.png
12:43:26 <shapr> mcstar: Hey that's cool! Did you write it yourself?
12:43:33 <mcstar> yes
12:43:42 <shapr> mcstar: Have you submitted it to the simons?
12:43:51 <mcstar> no, but its no big deal
12:44:02 <mcstar> i hope you know the multi line input is there already
12:44:04 <chazor> shapr: Has a C and a C++ sdk/api so I'm imagining an FFI, then compile to c as an intermediary, then compile the NaCl
12:45:00 <shapr> chazor: worth trying, definitely.
12:46:06 <chazor> shapr: cool, thanks for the positive direction.
12:46:19 <shapr> chazor: Tell us whether it works out :-)
12:47:19 <mcstar> shapr: i have no idea how to submit a patch
12:47:25 <chazor> shapr: will do.
12:47:29 <mcstar> i can provide the file...
12:47:39 <nand`> mcstar: yes, that's a huge improvement
12:48:39 <otters> uh oh, I have a problem
12:55:55 <donri> otters: well, i was thinking you'd have the tvar in a reader and have execstateatomic read from that, but yea. did you get it working?
12:59:55 <mcstar> eh
13:00:02 <mcstar> ghc devs use git?
13:00:16 <silver> and darcs?
13:00:28 <mcstar> GHC uses  git for revision control.
13:00:48 <silver> I remember there was process of transition from darcs to git
13:01:00 <silver> not sure if they finished it
13:01:09 <parcs`> mcstar: what does that image show, exactly?
13:01:40 <mcstar> parcs`: it shows, that you can set the secondary prompt to a custom one
13:01:47 <mcstar> to match with your primary one
13:02:13 <mcstar> lets imagine, i set the primary one, to break line after showing the loaded modules
13:02:27 <mcstar> but now, if i use multi line input
13:02:34 <mcstar> the secondary prompt wil be much indented
13:02:41 <mcstar> and it will contain the imported modules
13:02:49 <mcstar> which is totally unncesessary
13:02:59 <mcstar> and break the flow of the code
13:03:00 <mcstar> s
13:04:09 <mcstar> i dont mind not bothering with a patch, im happy with my setup
13:04:23 <mcstar> in time the developers will add it eventually
13:13:28 <raek> how can I run a ghci repl in a cabal project?
13:13:53 * hackagebot optparse-applicative 0.1.0 - Utilities and combinators for parsing command line options  http://hackage.haskell.org/package/optparse-applicative-0.1.0 (PaoloCapriotti)
13:14:50 <sykora> raek: do you want to run ghci with the modules of a cabal project loaded?
13:15:23 <parcs`> what's a primary and secondary prompt?
13:16:32 <Tomsik> MostAwesomeDude, that sounds good. If only there was a GHC extension so you wouldn't have to rely on TH and grabbing obscure-looking operators
13:17:19 <sykora> parcs`: primary prompt is the normal prompt, secondary prompt is shown while in the middle of a multiline command
13:18:16 <raek> sykora: well, I'm not exactly sure what I want. I want ghci to be able to use the dependencies I specified in the .cabal file. I would like to be able to load (and reload) the source files of the project too
13:18:44 <sykora> raek: well, if you've installed the dependencies, they're already available, so nothing more to be done.
13:19:15 <sykora> raek: if you want to load the the source files of the project, use `ghci -isrc` (or whatever the source tree is), and do `:load M.A.B.C` etc.
13:19:25 <raek> ok, so dependencies are installed globally (rather than on a per project basis)?
13:19:51 <sykora> raek: unless you've set it up otherwise, yes. you can use a tool like hsenv to manage per-project dependencies.
13:20:05 <sykora> or cabal-dev, for that matter
13:21:10 <raek> sykora: ack.
13:28:43 <nand`> has anybody ever ranted about how all over the place the names for various algebraic structures are?
13:29:09 <nand`> like “magma, unital, loop, semigroup, monoid”
13:29:33 <eviltwin_b> probably
13:29:53 <monochrom> the law of large numbers implies it
13:33:22 <kylcarte> Is it possible to pass ghci an expression to evaluate from the command line? Similar to "ghc -e ...", but ending up in an interactive environment, rather than exiting?
13:35:02 <nand`> kylcarte: you could probably do something like this:
13:35:10 <nand`> echo 'foo' | cat - /dev/tty | ghci
13:35:31 <nand`> use with caution
13:36:09 <kylcarte> nand`: yikes, that's quite a hack
13:36:38 <eviltwin_b> you could also possibly embed it in a .ghci,
13:38:32 <mewalz> I have three functions: f :: IO [a], g :: [a] -> IO [b], h [b] -> IO () , f is outputting a "stream", f >>= g >>= h does nothing until f is finished. I think this means I need to use enumerator, but any idea?
13:38:34 <otters> donri: not exactly
13:39:14 <otters> donri: I've got two threads that are going to be operating on the object at the same time, so modify needs to perform the update as soon as it's executed
13:40:01 <otters> donri: also I do need to use some kind of transformer because I'm working with IO
13:40:12 <kylcarte> eviltwin_b: not sure that will be what I need, since it's loaded before whatever modules are specified
13:40:13 <otters> but execStateT takes a state computation and returns Monad m => s -> m s
13:40:19 <otters> whereas modifyTVar needs an s -> s
13:40:31 <otters> so I'm still stuck
13:40:31 <nand`> kylcarte: you can load modules in .ghci
13:40:36 <nand`> kylcarte: if that helps
13:43:35 <WraithM> kylcarte: You could automate nand`'s hack with a script: echo $@ | cat - /dev/tty | gchi
13:44:06 <WraithM> Maybe that's useless information
13:45:06 <nand`> two immediate downsides to the hack, mind: 1. the input isn't shown in ghci, but the prefix before it is nonetheless. so you get your usual Prelude> before the output of whatever expression was input, 2. quitting GHCi (:q) doesn't terminate the line, you have to hit ^D to break out of cat as well
13:45:28 <eviltwin_b> alos writable as { echo "$@"; cat } | ghci # possibly with some ;s depending on the shell and version; see also rlwrap instead of cat
13:45:55 <eviltwin_b> (you will lose line editing with cat)
13:46:37 <nand`> oh, indeed you do
13:46:40 <nand`> that's unfortunate
13:46:57 <eviltwin_b> hence rlwrap :)
13:47:24 <WraithM> true
13:48:06 <mcstar> haskell-mode must communicate with ghci
13:48:19 <mewalz> how much overhead is associated w/ the enumerator library? I am expecting it to be running in 300-400 threads/server
13:48:40 <kylcarte> hm. a ghci script might be the way to go, although ghc doesn't like the -ghci-script flag. It should be a non-default .ghci file
13:48:51 <eviltwin_b> it does; it sends literal strings, it doesn't expect things like history and such to work (rather, emacs does them for it)
13:49:03 <mcstar> make-comint
13:49:36 <donri> otters: you can't have IO inside an STM
13:50:00 <donri> otters: better pass things in to scope from the outside
13:50:07 <otters> well shit
13:50:21 <nand`> does anybody else think that a command in GHCi that would invoke $EDITOR on a unique file and run its contents after $EDITOR exits would be useful?
13:50:59 <nand`> so you can easily and quickly input multi-line statements into GHCi
13:51:04 <donri> nand`: wouldn't it be better to implement a scratchpad kinda thing in the editor itself
13:51:20 <sipa> let's add EDLIN functionality
13:51:22 <otters> donri: I don't really understand
13:51:27 <nand`> donri: I don't think it would; wouldn't that be reinventing the wheel?
13:51:39 <nand`> (with all of the associated disadvantages)
13:52:02 <mcstar> hm, comint-run also works
13:52:03 <eviltwin_b> nand`: I think you can do that with its existing macro capabilitty
13:52:30 <donri> otters: well for instance you can't read a file inside an STM action, but you can pass in a already read file's contents; do c <- readFile; atomically $ do putTVAR .. c
13:52:31 <eviltwin_b> that is, someone would have to write it but it can be done without code changes, just with soem stuff in .ghci
13:52:49 <otters> donri: I don't think that's going to be possible in my project
13:53:03 <nand`> it should be rather easy even with source changes as GHCi already supports multi-line commands via { \n ... \n }
13:53:06 <donri> otters: then you're trying to do something stm was specifically designed against
13:53:14 <kylcarte> I'd really like to avoid hacking it in bash. It seems .ghci files are the standard way, but I'm getting mixed messages on how to specify a .ghci file
13:53:17 <otters> donri: right
13:53:17 <nand`> err :{ :}
13:53:39 <otters> donri: this is a proxy between IRC and another chat protocol, designed for an IRC client to connect, so I have two threads, one reading from the server and one from the IRC client
13:53:47 <otters> and an object that stores state for the client
13:53:58 <otters> and based on what data I get from either the client or the server I need to update the state
13:54:39 <donri> reimplementing bitlbee are we
13:54:45 <eviltwin_b> kylcarte: what mixed messages?
13:54:55 <otters> sort of
13:55:01 <otters> bitlbee doesn't support it so
13:55:11 <otters> and it's not very complicated, it just maps rooms to IRC channels and so forth
13:55:40 <otters> the question is what to use if STM is not correct
13:55:43 <kylcarte> eviltwin_b: manpages say -ghci-script can be used to specify additional .ghci files, ghc v7.4 says -ghci-script is an unrecognized flag
13:55:59 <b52> u dont need to use threads
13:56:04 <donri> honestly i'm not exactly an expert on concurrency or stm, others might be able to help you better
13:56:09 <eviltwin_b> hm.  I cannot test readily, I think
13:56:14 <otters> b52: what do I do?
13:56:16 <b52> you could use an event driven setup
13:56:26 <mauke> b52: how?
13:56:26 <donri> b52: events only complicate things
13:56:33 <b52> donri: not really, no
13:56:36 <otters> I tried an event based system first
13:56:51 <otters> but it needs a select() function and the only one I could find depended on posix
13:57:17 <b52> @hoogle epoll
13:57:18 <lambdabot> package epoll
13:57:18 <lambdabot> package hack-handler-epoll
13:57:30 <otters> linux specific
13:57:32 <otters> non
13:57:33 <donri> why epoll manually when ghc does it for you
13:57:34 <otters> portable
13:58:01 <otters> if someone can find me a platform-independent version of select/epoll, implemented in haskell, then hell yeah I'll use that
13:58:08 <otters> but I've tried
13:58:11 <mauke> otters: threads are that
13:58:13 <mauke> more or less
13:58:14 <donri> otters: the platform-independent version is forkIO :)
13:58:20 <otters> I'm using forkIO
13:58:24 <donri> exactly
13:58:27 <otters> and we're back to where we started
13:58:49 <otters> the question is how to operate on a shared mutable state from threads
13:58:50 <otters> in haskell
13:58:54 <b52> what are you trying to accomplish btw?
13:58:54 * hackagebot errors 1.0.0 - Simplified error-handling  http://hackage.haskell.org/package/errors-1.0.0 (GabrielGonzalez)
13:59:01 <nand`> otters: I did this using an IORef, last time I tried
13:59:08 <donri> well i don't really see the problem
13:59:08 <otters> b52: read up
13:59:09 <mauke> that's what you get for listening to suggestions containing "u"
13:59:13 <otters> yeah
13:59:13 <nand`> sorry, MVar
13:59:15 <otters> fair point
13:59:15 <nand`> not IORef
13:59:26 <MostAwesomeDude> otters: Hm. Okay, so you want to build a proxy?
13:59:31 <otters> MostAwesomeDude: yessir
13:59:41 <mauke> I don't see the problem either
13:59:43 <nand`> otters: http://hpaste.org/67768 <- might be able to provide some ideas
13:59:46 <MostAwesomeDude> I'm using conduits right now and they're alright for this. Not the best, but whatever.
14:00:04 <nand`> but I'm not sure if this is a good implementation strategy
14:00:16 <otters> nand`: I'll look at that
14:00:33 <MostAwesomeDude> You probably want to fully encapsulate the client within the server, for each thread, and not worry about having each of the server threads talk to each other. (Do they need to?)
14:00:40 <otters> MostAwesomeDude: they don't
14:00:47 <otters> each client/server connection pair is independent
14:00:54 <nand`> if the client threads are completely independent then what do you need shared state for?
14:01:10 <otters> well, the state is shared between the thread talking to the server and the one talking to the client
14:01:12 <otters> within each pair
14:01:18 <nand`> oh
14:01:25 <mauke> makes sense
14:01:38 <otters> and it functions the way I've written it
14:02:02 <otters> I was just hoping to be able to write a MonadState instance, or something, so that I can transparently operate on a state that's contained in a TVar
14:02:13 <otters> I've defined a bunch of helpers that are basically
14:02:38 <otters> get_ = get >>= liftIO . readTVarIO
14:02:39 <mauke> that is possible
14:02:40 <otters> etc.
14:02:41 <donri> thing is you only get MVar functionality then
14:02:49 <mauke> donri: ?
14:03:10 <donri> mauke: if you run each get and put operation atomically, separately
14:03:18 <otters> BUT that way, I can define modify_ f = get >>= \contents -> io . atomically $ modifyTVar contents f
14:03:41 <otters> but it still seems hacky
14:03:46 <MostAwesomeDude> Hmm, oh, this is a little interesting.
14:03:49 <mauke> why hacky?
14:03:55 <mauke> that seems like the obvious way
14:03:59 <otters> yeah
14:04:05 <MostAwesomeDude> How *would* you have a simultaneous recv on two different sockets without two IO threads?
14:04:06 <otters> I just don't like suffixing my function names with underscores :P
14:04:14 <MostAwesomeDude> I don't think you can; there's no tryRecv.
14:04:16 <otters> MostAwesomeDude: select/epoll/kqueue whatever
14:04:18 <mauke> otters: import qualified :-)
14:04:24 <otters> bah
14:04:33 <MostAwesomeDude> otters: I'm not talking about the low-level of it, I'm thinking of the actual Haskell interfact.
14:04:36 <MostAwesomeDude> *interface, even.
14:04:42 <otters> of course, the hilarious thing is that all my helpers are defined in a State monad and the only operation I'm using is get
14:04:46 <otters> I just realized that
14:04:53 <mauke> MostAwesomeDude: foreign import select, then call recv on the ones that are ready
14:04:57 <otters> so I can at least fix that part
14:05:04 <mauke> Reader!
14:05:08 <otters> yeah
14:05:30 <donri> like i told you hours ago ;)
14:05:36 <MostAwesomeDude> mauke: Ugh, really? There's *really* not a better way? :c
14:05:42 <nand`> otters: if the only operation you're using is get then it sounds like you'd do fine with a reader instead
14:05:43 <otters> donri: you told me for a completely different reason :P
14:05:43 <mauke> MostAwesomeDude: better how?
14:05:52 <donri> nope
14:06:01 <MostAwesomeDude> mauke: I still wish there was an event-driven networking library for Haskell.
14:06:08 <nand`> otters: if you're only using the state to share an MVar/TVar/whatever between the server-thread and the client-thread, then a Reader would be perfect
14:06:09 <otters> I wish TextMate had jump to definition
14:06:18 <otters> nand`: that's what I'm doing now
14:06:27 <mauke> MostAwesomeDude: you could implement a simplified select on top of forkIO
14:06:46 <MostAwesomeDude> mauke: Don't tempt me. :3
14:06:50 <mcstar> nand`: why is that command "echo 'foo' | cat - /dev/tty | ghci necessary?  cat | ghci | cat works, input/output redirected
14:07:09 <mauke> MostAwesomeDude: I've got a hacked up prototype somewhere
14:07:14 <otters> @hoogle monad m => m a -> m ()
14:07:15 <lambdabot> Did you mean: Monad m => m a -> m ()
14:07:15 <lambdabot> Control.Monad void :: Functor f => f a -> f ()
14:07:15 <lambdabot> Foreign.Marshal.Error void :: IO a -> IO ()
14:07:24 <otters> there we go
14:07:40 <nand`> mcstar: I don't follow, example?
14:07:41 <kylcarte> mcstar: without the 'cat - /dev/tty', it exits upon completion
14:08:08 <mcstar> nand`: you gave that example 1-2 pages above
14:08:13 <mcstar> kylcarte: exits when?
14:08:27 <kylcarte> mcstar: after foo is evaluated
14:08:46 <nand`> mcstar: I meant for the latter. how do I get the “echo 'foo'“ in there?
14:09:02 <mcstar> it exits when the pipe is boken
14:09:04 <mcstar> r
14:09:17 <mauke> .oO( when the piper is boken )
14:09:31 <mcstar> if you wish
14:10:01 * Clint sniggers.
14:10:11 <donri> otters: exec st = do mvar <- ask; liftIO $ atomically $ do val <- readTVar mvar; writeTVar mvar $ runState st val
14:11:03 <mcstar> nand`: so you want to both send it something, an after the evaluation stay in interative mode?
14:11:14 <nand`> mcstar: yes
14:11:15 <mcstar> if so, i get it
14:11:25 <donri> assuming something like, ReaderT (Tvar a) IO
14:11:28 <kylcarte> mcstar, precisely
14:13:03 <donri> heh, i managed to name the TVar "mvar"
14:13:05 <donri> win.
14:14:17 <otters> I did that once
14:14:23 <otters> the fuck
14:16:10 <mcstar> o.O
14:16:27 <otters> I hate type errors that don't make any sense
14:16:41 <otters> bracket_ is requiring a StateT s IO a
14:17:04 <otters> even though all of its arguments are type ReaderT (TVar Kevin) IO a
14:17:32 <otters> and ReaderT is a MonadCatchIO instance
14:17:34 <donri> paste code and error
14:17:37 <otters> yes
14:18:27 <otters> hang on
14:18:55 * hackagebot fclabels 1.0.5 - First class accessor labels.  http://hackage.haskell.org/package/fclabels-1.0.5 (SebastiaanVisser)
14:20:44 <hpaste> nand` pasted “MonadState instance for TVar/IO” at http://hpaste.org/71062
14:21:20 <nand`> this isn't relevant is it?
14:21:25 <donri> hpaste: as i've been saying, don't do that :)
14:21:32 <donri> otters: * lol
14:21:33 <otters> oooo
14:22:01 <donri> just use the "exec" helper so you can make sure things are kept atomic
14:22:51 <donri> like, do normalStuff; exec $ do someLens += 1; otherLens %= (prepend:)
14:23:28 <donri> if you manage to make your reader a MonadState, those two lens operations will not run atomically as one
14:23:48 <donri> thus side-stepping much of the point of stm
14:23:52 <otters> yeah
14:24:01 <otters> wow, this is depressing
14:24:21 <donri> if you really want an MVar instead, you're free to use it of course :)
14:24:55 <barrucadu> Is there a built-in function that will apply a function to a value until a fixed-point is reached?
14:25:01 <otters> fix?
14:25:18 <barrucadu> Ah, that was obvious
14:25:27 <barrucadu> Thanks :P
14:25:33 <otters> Socket is disconnecting and error handlers are not executing.
14:26:57 <bjchambers> exit
14:27:06 <nand`> hmm
14:28:09 <nand`> barrucadu: I'm not sure if ‘fix’ is the function you want
14:28:22 <nand`> you want something like :: Eq a => (a -> a) -> a -> a -- yes?
14:28:27 <barrucadu> nand`: Possibly not, it doesn't seem suitable
14:28:28 <barrucadu> Yes
14:29:43 <mauke> ap zip tail + iterate
14:30:12 <EvanR-7> why does haskell platform say 'install ghc first' and ghc 7.4.1 says 'install haskell platform instead'
14:30:42 <mauke> where does the platform say "install ghc first"?
14:30:53 <eviltwin_b> haskell platform should only say that for source builds
14:30:57 <EvanR-7> under linux, build from source
14:30:59 <b0fh_ua> Hi all! I need some help with resolving issue about encoding in SQLite. https://gist.github.com/dae92b6bf26c5e6c559a - the code listed here doesn't write UTF8 strings into text file. I checked main.db file - and it there are UTF-8 strings. Am I missing something there?
14:31:01 <eviltwin_b> the binary package includes ghc
14:31:08 <EvanR-7> 'the binary package' ?
14:31:31 <EvanR-7> where can i get that for linux
14:31:33 <aristid> EvanR-7: why not 7.4.2 instead of 7.4.1?
14:31:35 <mauke> EvanR-7: why are you trying to build it from source?!
14:31:48 <eviltwin_b> the haskell platform is primarily a bitteries-included binary duistribution.  for linux this is usually distribution packages of some kind
14:31:48 <mauke> that kinda defeats the point
14:31:55 <EvanR-7> both of you: thats why i found when i went to the nice looking hasklel platform site and clicked linux
14:32:04 <EvanR-7> thats what*
14:32:33 <mauke> EvanR-7: "Build from source" is the last section on that page
14:33:03 <EvanR-7> i dont have any of those distributions
14:33:18 <mauke> what do you have?
14:33:31 <EvanR-7> slackware, and i dont see a slackbuild
14:33:42 <mauke> "Complete instructions for installing from source are available."
14:33:45 <mauke> I'd try that link
14:33:54 <EvanR-7> heh
14:34:12 <EvanR-7> i already know how to do that, install ghc, then build everything from source
14:34:19 <EvanR-7> i was just confused by the two way directions
14:34:37 <EvanR-7> basically i guess i just need to ignore haskell platform entirely
14:34:42 <EvanR-7> for slackware
14:34:48 <mauke> the page linked to includes: "Beware that the website will say “Stop! Go get Haskell Platform instead.” Ignore it and go ahead to find a binary tarball."
14:34:50 <aristid> EvanR-7: i don't think that'd be a big problem
14:35:02 <aristid> EvanR-7: just use cabal for everything other than cabal :)
14:35:11 <EvanR-7> aristid: eh?
14:35:14 <EvanR-7> oh
14:35:28 <otters> aw man, tls is failing
14:35:32 * nand` ignored the haskell platform entirely
14:35:35 <otters> again
14:40:55 <b0fh_ua> anybody here has experience with SQLIte?
14:41:04 <fmap> nand`: isn't `fix' enough for `:: Eq a => (a -> a) -> a -> a'?
14:41:31 <fmap> :t fix (\f g a -> if g a == a then a else f g (g a))
14:41:33 <lambdabot> forall a. (Eq a) => (a -> a) -> a -> a
14:41:46 <nand`> fmap: well yeah, since you can define an arbitrary recursive function using fix
14:41:53 <nand`> fmap: but I meant the function itself is not directly what he's looking for
14:42:37 <nand`> and if you're doing that you might as well define your combinator directly: fixAp f x | x == x' = x | otherwise = fixAp f x' where x' = f x
14:45:18 <fmap> `fixAp' seems too readable :(
14:46:17 <EvanR-7> i think i liked haskell platform because it installed cabal for me
14:48:18 <EvanR-7> whats the difference between transforms and mtl
14:48:43 <aristid> EvanR-7: mtl provides the typeclasses on top
14:48:50 <aristid> EvanR-7: maybe some other things, dunno :)
14:49:39 <donri> with transformers, you have to lift explicitly, with mtl, it'll usually do the right thing via functional dependencies
14:50:24 <donri> but if you have a weird transformer stack, there could be ambiguity that mtl solves incorrectly, I'd guess
14:50:36 <aristid> isn't the divide because historically it wasn't clear whether to use type families or functional dependencies?
14:51:13 <donri> not sure type families would be enough for mtl
14:51:29 <donri> don't take my word for it though
14:53:00 <EvanR-7> interesting so haskell environment is dependent on itself, like C 'environment'
14:53:04 <donri> also mtl is a superset of transformers, you can still lift explicitly
14:53:07 <byorgey> EvanR-7: see http://article.gmane.org/gmane.comp.lang.haskell.libraries/17139
14:54:19 <byorgey> fun fact: mtl isn't quite a superset of transformers
14:54:25 <byorgey> because it doesn't re-export MaybeT
14:55:01 <byorgey> also transformers has stuff like Data.Functor.Compose
14:55:48 <donri> oh duh of course type families can do it, (looking at monads-tf), what was i thinking :)
14:57:20 <kallisti> byorgey: I noticed that as well (about mtl)
14:59:05 <kallisti> which is why webdriver depends on both mtl and transformers.
14:59:16 <kallisti> it uses transformers so it can define MaybeT instances.
14:59:42 <aristid> is there a reason for mtl not to add MaybeT re-exports?
14:59:44 <donri> if you have mtl you have transformers anyway
15:00:08 <kallisti> right. of course you still have to please cabal.
15:00:19 <eviltwin_b> aristid: backward compatibility, I think
15:00:38 <bjchambers> Cabal question:  if I try to use haskell2010, some things complain because they need GHC.Exts (I think I ran into this with Parsec, and definitely with Alex/Happy) which is in base.  If you add base, then Cabal gets mad because it conflicts with haskell2010.  Is there a smaller package (other than base) that should be used for GHC.Exts?
15:01:18 <eviltwin_b> bjchambers: as far as I know, GHC.Exits is not part of either standard so cannot be used with either one
15:01:25 <eviltwin_b> er, GHC.Exts
15:01:41 <eviltwin_b> you should specify neither, then you get base as the foundation
15:02:20 <bjchambers> eviltwin_b: I see... so basically, if you use a library such as Alex that depends on GHC.Exts, you're forced to use base?
15:02:28 <eviltwin_b> yes
15:02:57 <eviltwin_b> think of it this way:  the standards are, largely, a matter of pedanticism.  mos practical programs use base, not h98 or h2010
15:02:58 <kallisti> will depending on haskell2010 ever cause conflicts with other packages that depend on base?
15:03:14 <eviltwin_b> it will always do so as of ghc 7.2
15:03:34 <eviltwin_b> this is why you should reserve use of the standard for pedanticism
15:04:08 <kallisti> I ask because I have a package that probably doesn't need to depend on base, technically.
15:04:12 <kallisti> http://hackage.haskell.org/package/cond-0.4.0.1
15:04:15 <donri> huh, but haskell2010 depends on base, what's the conflict?
15:04:19 <eviltwin_b> (I'm not happy about it, but base is incompatible with both standards --- the next haskell standard should agree with base on the incompatibilities, but as things are base is not compatible with the standrads)
15:04:30 <bjchambers> eviltwin_b: hmm... I see... and base is a strict superset of h2010?
15:04:52 <bjchambers> donri: for instance, both base and haskell2010 define Prelude, so cabal gets unhappy when you have both
15:04:53 <eviltwin_b> h'2010 gets much stuff from base.  the primary incompatibility ios that the next standard, and therefore current base, bno longer have Show or Eq as prerequisites for Num
15:04:56 <donri> oh you mean because the shared module names
15:04:58 <eviltwin_b> (as specified by h98 and h2010)
15:05:28 <kallisti> ah okay.
15:05:37 <donri> is that really a problem though with indirect dependencies?
15:05:47 <donri> doesn't package hiding solve that
15:06:37 <donri> oh, that makes more sense (re Num context)
15:07:01 <kallisti> shouldn't it be base that depends on haskell2010?
15:07:36 <bjchambers> package hiding?  isn't that just hiding definitions from an imported module?
15:07:45 <eviltwin_b> the way things are architected, base *is* the base; h98 and h2010 are modifications of it, but base is what provides all of the actual base packages of the compiler suite
15:08:04 <bjchambers> eviltwin_b: hmm... it sounds like I may as well just use base :D
15:08:14 <eviltwin_b> and base is very tioghtly tied to ghc's internals
15:08:28 <eviltwin_b> so rearraning things to make h2010 the base would be ... painful at best
15:08:44 <kallisti> eviltwin_b: ideally that's how it should work though.
15:08:52 <donri> i mean, if you depend on two packages that use base and haskell2010 respectively, shouldn't cabal build those in "isolation", as long as no package depends on both itself
15:09:50 <bjchambers> donri: ah, yeah... I think it did that.  the specific conflict was that I was using haskell2010, then improted something that caused cabal to suggest I add a dependency on base, at which point my package dependend on both, and made things unhappy
15:09:50 <donri> but yea if they define similar but distinct things (like Num with different constraints) you could "leak" that
15:10:07 <eviltwin_b> donri9, all notions of sisolation break down once you drag in tyopeclasses; instances are global
15:10:16 <donri> in deed
15:10:19 <eviltwin_b> now go look at the Num thing again...
15:10:24 <donri> yes, got it
15:10:36 * eviltwin_b hates this keyboard...
15:11:13 <kallisti> why not have base depend conditionally on a number of different "standards" packages?
15:11:34 <kallisti> so you could have it depend on either haskell2010 or haskell-prime, which carries all the changes for the next standard.
15:11:41 <eviltwin_b> kallisti, I was quite serious when I said that rewiring things would be paunful
15:11:55 <eviltwin_b> it's been tried in various ways and people have always given up
15:12:07 <eviltwin_b> I think, if you truuly believe this must happen, it's up to you to do it
15:12:50 <eviltwin_b> because ghc hq has flailed at the whole base mess enopugh times they're not really willing to do it again
15:13:46 <kallisti> I just think, as it currently stands, haskell2010 serves no purpose, when it could be used with packages that are truly portable across all compilers.
15:16:11 <eviltwin_b> kallisti: at this point I don't think any of it can be separated from ghc to be shared between compilers.  there are still occasional fossils of when nhc98 shared base with ghc, but ghc's relationshuo with base has gotten a lot more tangled since then
15:16:54 <kallisti> that's a shame, considering that UHC has a fairly complete JS backend that more packages could attempt to target.
15:17:20 <kallisti> (or does UHC use base?)
15:17:58 <EvanR-7> javascript backend?
15:18:12 <kallisti> yes.
15:18:21 <kallisti> with a working FFI
15:19:03 <kallisti> https://github.com/norm2782/uhc-jscript/blob/master/uhc-jscript/src/Language/UHC/JScript/JQuery/Ajax.hs
15:19:09 <kallisti> for example, here's JQuery bindings.
15:20:49 <EvanR-7> was acidstate superceeded by another project
15:21:41 <ronwalf> Does anyone have a GHC 7.0 or 7.2 installation laying around?  I want to test out http://hackage.haskell.org/trac/ghc/ticket/7057  (It compiles just fine in 6.12.3)
15:22:01 <ronwalf> Just have your finger on the ctrl-C key before it eats all your ram
15:22:22 <donri> EvanR-7: nope
15:22:39 <ronwalf> Doh, that almost qualifies as a DOS.
15:23:18 <donri> EvanR-7: acid-state itself is a rewrite and decoupling of happstack-state (in turn a fork from HAppS-State)
15:23:46 <EvanR-7> im starting another mud project, using acidstate
15:24:03 <kallisti> EvanR-7: imagine how yesod would look if, instead of interpolating Haskell variables into Javascript, you interpolate Glasgow Haskell variables into Utrecht Haskell
15:24:19 <Tomsik> EvanR-7, do you have content for it? :P
15:24:29 <EvanR-7> Tomsik: nope
15:24:40 <EvanR-7> any ideas?
15:24:43 <bjchambers> has anyone seen "Undefined symbols for architecture x86_64" errors?  I only see it when I have my tests enabled, so I suspect its something with how I setup the cabal test target.  the missing symbols seem to suggest they're either from Alex, or from the library defined in my cabal file that the test suite depends on...
15:25:09 <Tomsik> Not really, just asking out of cursiosity, having played a mud or two some time ago.
15:25:09 <kallisti> so you could share a common pool of functions for both serverside and clientside, and your server can seamlessly inject data into clientside code in a typesafe manner.
15:25:16 <ben> ronwalf: I have 7.0.4 installed on a remote machine for some reason and ghc does hang at >80/90% CPU there, and slowly worked its way up to 500M of memory before I killed it
15:25:37 <ronwalf> ben: Thank you!
15:25:46 <ronwalf> Ok, so it's a post 6.12 bug
15:26:00 <ben> "*** Simplifier SimplMode {Phase = 2 [main], inline, rules, eta-expand, case-of-case} max-iterations=4:" was the last output before ^C
15:27:06 <ben> I found a 7.0.3 installation too with the same behavior :D
15:27:31 <EvanR-7> kallisti: are you still talking about UHC
15:27:34 <EvanR-7> or muds
15:27:58 <kallisti> I'm talking about targeting JS as a backend, in general.
15:28:28 <EvanR-7> oh
15:28:59 <eikke> <3 haskell-cafe
15:31:53 <takhiarel> hi
15:34:08 <tertl6> hello
15:34:35 <tertl6> what is haskell cafe?
15:34:46 <eikke> tertl6: a mailing list
15:34:53 <tertl6> oh
15:35:05 <tertl6> is it for beginners or advanced?
15:36:07 <eikke> tertl6: pff... I consider myself a beginner, but hard to say... sometimes it goes deep, sometimes it's more basic
15:36:29 <eikke> tertl6: it's at least very useful to learn, or discover things you might want to learn
15:36:38 <tertl6> i see
15:36:57 <tertl6> you know what would be fun
15:37:15 <tertl6> to make a linux distro in honor of Haskell
15:37:57 <tertl6> it comes with all functional languages and haskell similar langauges
15:38:14 <tertl6> :P
15:38:32 <tertl6> eikke have you ever written a compieler?
15:38:40 <eikke> not for haskell
15:39:00 <jmcarthur> tertl6: it must use nix as its package manager, too, since it's often called "purely functional"
15:39:30 <tertl6> jmcarthur yeah that too,
15:39:39 <tertl6> i didnt know that jmcarthur
16:02:45 <roconnor_> you know this new lens library of mine.
16:02:54 <roconnor_> I think I didn't test anything at all before releasing it
16:03:16 <roconnor_> I don't think I've executed a single line of its code
16:03:34 <sipa> you did try to compile it, did you?
16:03:36 <roconnor_> though I did do some typechecking of compound expressions.
16:03:46 <roconnor_> sipa: yes I compiled many times
16:04:29 <roconnor_> I suspect it is close to impossible to implent these types incorrectly.
16:05:38 <sipa> would be nice if you could prove that there is only one possible non-trivial implementation for it, and then get away with "tested by compiling"
16:06:52 <roconnor_> sipa: in particular the implementation of the focus function I didn't really understand
16:07:09 <roconnor_> I just put all the pieces together in the obvious way
16:08:03 <roconnor_> it's just some glorified indentity function anyways :D
16:08:51 <roconnor_> focus l m = StateT $ unwrapMonad . getCompose . l (Compose . WrapMonad . (runStateT m))
16:09:04 <roconnor_> all of those functions are just newType wrappers or unwrappers.
16:09:10 <roconnor_> so how could it be wrong?!
16:12:38 <applicative> @pl focus l m = StateT $ unwrapMonad . getCompose . l (Compose . WrapMonad . (runStateT m))
16:12:38 <lambdabot> focus = ((StateT . ((unwrapMonad . getCompose) .)) .) . (. (((Compose . WrapMonad) .) . runStateT))
16:13:24 <eikke> in GHC.ForeignPtr, PlainPtr is not exported. Is there any way to work around this?
16:14:13 <eviltwin_b> I think any case involving uneported ForeignPtr stuff is by definition doing it wrong
16:15:10 <mwcampbell> Does anyone know which of the several FRP libraries for Haskell is the most mature?
16:21:59 <bitonic> mwcampbell: probably reactive-banana
16:23:06 * applicative suspects mwcampbell 's question is ill posed, but isn't sure how to reformulate it
16:24:42 <Mossmoth> .
16:26:25 <applicative> mwcampbell: http://hackage.haskell.org/package/sodium https://github.com/kentuckyfriedtakahe/sodium
16:30:15 <bitonic> applicative: didn't that get released 3 months ago or so?
16:30:29 <mdmarek_> Hello, anyone know how I can use a library installed with cabal install --prefix=/opt/ghc-lib
16:30:59 <spree> anyone tried go? what is it about, google making their own language?
16:31:21 <bitonic> spree: nothing new about Go
16:31:53 <mikeplus64> just backwards function syntax (or was that rust)
16:32:10 <roconnor__> wake me when Go has sum types
16:32:39 <mdmarek_> I have tried passing options -l<dir> and -i<dir> but still does not find the limbs
16:32:43 <johnw> bitonic: does it need to be new?  does it do any old stuff better?
16:33:01 <mdmarek_> s/limbs/libs/
16:33:09 <bitonic> johnw: he asked for mature. reactive-banana is well established
16:33:45 <johnw> i like the logo at least
16:33:46 <mikeplus64> mdmarek_: maybe ask in #ghc, but one "solution" i suppose would be to symlink /opt/ghc-lib to ~/.ghc
16:34:34 <applicative> bitonic: yes, 'maturity'  has to be the wrong question though
16:34:37 <mdmarek_> I will try the symlink first, is easy enough...
16:34:44 <bitonic> applicative: why? it is a measure of something
16:34:53 <johnw> bitonic: it's mature at 0.5.0?
16:35:06 <bitonic> johnw: *that* does not mean anything :P
16:35:09 <johnw> sometimes i wish people would just start at 1.0
16:35:20 <bitonic> then HTTP is the most mature of all
16:35:24 <bitonic> 4000!
16:36:07 <applicative> the more 'mature' the frp library, the more likely it is to suffer one the traditional difficulties, no?
16:36:24 <bitonic> applicative: what?
16:37:02 <applicative> in any case http://hackage.haskell.org/package/elerea beats reactive banana on the measures in question no... http://hackage.haskell.org/package/elerea
16:37:33 * applicative was hoping to produce a philosophical war amongst frp enthusiasts....
16:37:50 <bitonic> applicative: you have to throw arrows into the mix to have that
16:38:09 <otters> literally
16:38:40 <applicative> aha, bitonic reveals underlying philosophical prejudice
16:39:00 <applicative> uh oh
16:44:52 <sunfun> would it have sense to build a small expert system shell in haskell?
17:10:12 <ClaudiusMaximus> anyone tried hxournal ?  i'm having trouble building it with ghc-7.4, some weird problem at this GADTs-using code:  https://github.com/wavewave/hxournal/blob/master/lib/Application/HXournal/Type/PageArrangement.hs#L218
17:11:09 <Veinor> is there a way to break out of an IO action early?
17:11:27 <zachk> Veinor: break out and do what?
17:11:35 <Veinor> in other words; i want do { a; b; break; c} to be equivalent to do { a; b; return () }
17:11:53 <zachk> you can branch with an if then in it or a case statement
17:12:28 <Veinor> yeah but if i keep doing that i don't want to have to nest a bunch
17:12:57 <eviltwin_b> ContT IO?
17:13:19 <eviltwin_b> (which avoids the nesting, but you may have to guive up on understanding your code :)
17:13:31 <Veinor> haha
17:13:42 <Veinor> i think MaybeT IO will work
17:15:00 <shirt> you can also throw an exception
17:15:14 <Veinor> true
17:15:23 <hpaste> ClaudiusMaximus pasted “hxournal ghc-7.4 problems” at http://hpaste.org/71069
17:15:23 <zachk> Veinor: you could fail with an Either or a Maybe
17:16:11 <Veinor> break = throw BreakException, then wrap it in a catch ( const $ return ())
17:16:27 <Veinor> well, catch (\(e :: BreakException) -> return ())
17:18:42 <zachk> Veinor: (Am nowhere close to masterful of haskell yet) what you are trying to do, might actually be one of the reasons monads are good pattern for you, you can do some complex things with them :)
17:19:36 <Veinor> i dunno, i was just curious
17:19:40 <Veinor> i think MaybeT IO will DWIW
17:36:33 <HugoDaniel> i
17:36:35 <HugoDaniel> hi
17:39:05 * hackagebot hledger-lib 0.18.2 - Core data types, parsers and utilities for the hledger accounting tool.  http://hackage.haskell.org/package/hledger-lib-0.18.2 (SimonMichael)
17:39:07 * hackagebot hledger 0.18.2 - The main command-line interface for the hledger accounting tool.  http://hackage.haskell.org/package/hledger-0.18.2 (SimonMichael)
17:40:09 <hpaste> ClaudiusMaximus annotated “hxournal ghc-7.4 problems” with “hoodle ghc-7.4 problems” at http://hpaste.org/71069#a71071
17:40:49 <ClaudiusMaximus> maybe i should install a ghc-7.0 just to check that it does compile with that...
17:44:09 * hackagebot hledger-web 0.18.2 - A web interface for the hledger accounting tool.  http://hackage.haskell.org/package/hledger-web-0.18.2 (SimonMichael)
17:51:30 <JoeyA> Consider the following two types:
17:51:31 <JoeyA> data Foo = FooA A | FooB B | FooC C
17:51:34 <JoeyA> newtype Foo' = Foo' (forall r. (A -> r) -> (B -> r) -> (C -> r) -> r)
17:51:49 <JoeyA> (note that the forall here is *universal* quantification, not existential quanitification)
17:52:11 <ClaudiusMaximus> i give up trying hxournal/hoodle for today.  ghc-7.0.4 won't build with ghc-7.4.2
17:52:32 <JoeyA> Foo and Foo' encode essentially the same thing, no?
17:52:56 <JoeyA> Also, is it true that Foo called "data", while Foo' is called "codata" ?
17:54:04 <JoeyA> Err, no, Foo and Foo' encode two different things, unless all but one of the functions is partial.
17:54:30 <JoeyA> With Foo', the consumer gets to choose the type, while with Foo, the consumer only gets a single type.
17:54:51 <arbn> When I get an error like "Could not deduce (a ~ ())", what does the ~ mean there?
17:54:59 <mauke> equals
17:55:01 <JoeyA> Type equality
17:55:08 <arbn> OK. Thanks.
17:55:31 <JoeyA> So I guess the appropriate Foo would be: data Foo = Foo (A, B, C)
17:58:32 <Nereid> JoeyA: in your original example, there's an obvious function Foo -> Foo'
17:58:46 <Nereid> not so with your new Foo
17:58:54 <tgeeky> anyone have any links to code using GHC >= 7.4 ?
17:59:03 <tgeeky> oops *kind*
17:59:09 <JoeyA> Nereid: Thanks.  I'll try to write it.
17:59:09 <tgeeky> typed list using kinds, etc
18:00:04 <Nereid> JoeyA: and also one Foo' -> Foo
18:00:24 <JoeyA> Nereid: Wait a sec, won't Foo -> Foo' require bottom values to implement?
18:00:30 <Nereid> nope
18:00:55 <JoeyA> e.g. fooToFoo' (FooA x) = Foo' $ \fa fb fc -> fa x
18:00:58 <JoeyA> oh, you're right
18:01:01 <JoeyA> I don't have to call fb.
18:05:13 <hpaste> “Joey Adams” pasted “Is this called codata?” at http://hpaste.org/71073
18:07:59 <c_wraith> you have no types in there that can be true codata
18:08:12 <c_wraith> because you have no recursive types
18:09:07 <JoeyA> Thanks.
18:09:08 <c_wraith> It's a CPS encoding of Foo, though
18:09:09 * hackagebot PrimitiveArray 0.2.2.0 - Efficient multidimensional arrays  http://hackage.haskell.org/package/PrimitiveArray-0.2.2.0 (ChristianHoener)
18:09:14 <c_wraith> which might be what you're thinking of
18:09:25 <JoeyA> I'm reading http://blog.sigfpe.com/2007/07/data-and-codata.html , and the attached PDF.
18:09:37 <sm> 1
18:09:51 <scottradcliff> Ruby guy here. Reading through http://learnyouahaskell.com/starting-out and I get all the functions that have names and are called by passing in variables, but the inline functions in the GHCI have me a little confused. Where are the values coming from? Like x in this [x*2 | x <- [1..10]] -- Are these functions practical or just for learning?
18:10:14 <Nereid> codata is coinductively defined types, I guess
18:10:17 <Nereid> like streams
18:10:21 <c_wraith> Nereid: that's correct
18:10:41 <JoeyA> s/attached/linked/
18:12:00 <JoeyA> scottradcliff: That's a list comprehension.  The x is drawn from the list [1..10].
18:14:08 <Nereid> there's more to be said about list comprehension but it probably shouldn't be said quite yet.
18:14:09 * hackagebot BiobaseXNA 0.6.2.5 - Efficient RNA/DNA representations  http://hackage.haskell.org/package/BiobaseXNA-0.6.2.5 (ChristianHoener)
18:14:15 <zachk> > do { x <- [1..10] ; return (2*x) }
18:14:16 <lambdabot>   [2,4,6,8,10,12,14,16,18,20]
18:14:19 <Nereid> like that.
18:14:25 <zachk> it is synatic sugar for that
18:14:36 <zachk> which is synatic sugar for: 00 hope I get this right...
18:14:37 <Nereid> only with MonadComprehensions.
18:14:45 <scottradcliff> Thanks JoeyA that makes sense. What is the '<-'?
18:14:55 <Nereid> scottradcliff: it's part of the syntax of list comprehensions.
18:15:14 <zachk> >  [1..10] >>= (\x->return (2*X))
18:15:15 <lambdabot>   Not in scope: data constructor `X'
18:15:21 <Nereid> zachk: correct.
18:15:23 <Nereid> modulo case.
18:15:34 <zachk> > [1..10] >>= (\x -> return (2*x))
18:15:35 <lambdabot>   [2,4,6,8,10,12,14,16,18,20]
18:15:46 <zachk> which could just be said as: --crosses fingers again
18:15:55 <parcs`> zachk: which is syntactic sugar for.. ;)
18:16:14 <zachk> > [1..10] >>= (return . (2*))
18:16:16 <lambdabot>   [2,4,6,8,10,12,14,16,18,20]
18:16:27 <Nereid> > map (2*) [1..10]
18:16:28 <lambdabot>   [2,4,6,8,10,12,14,16,18,20]
18:16:30 <Nereid> or fmap
18:16:38 <zachk> > fmap (*2) [1..10]
18:16:39 <lambdabot>   [2,4,6,8,10,12,14,16,18,20]
18:16:45 <Nereid> or liftM
18:16:49 <fmap> > enumFromTo 1 10 >>= return . (2*)
18:16:50 <scottradcliff> Alright Nereid thanks. Is it an assignment operator?
18:16:52 <lambdabot>   [2,4,6,8,10,12,14,16,18,20]
18:17:12 <zachk> > fmap (2*) . enumFromTo 1 $ (sum [1..4])
18:17:13 <Nereid> scottradcliff: it might help if you think of it that way.
18:17:15 <lambdabot>   [2,4,6,8,10,12,14,16,18,20]
18:17:15 <c_wraith> it's a name-binding operator ... sort of like assignment, but with different connotations
18:17:21 <Nereid> sure.
18:18:02 <Nereid> but the <- only makes sense inside list comprehensions or do blocks
18:19:09 * hackagebot ADPfusion 0.0.1.2 - Efficient, high-level dynamic programming.  http://hackage.haskell.org/package/ADPfusion-0.0.1.2 (ChristianHoener)
18:19:11 * hackagebot BiobaseTurner 0.2.2.4 - Import Turner RNA parameters  http://hackage.haskell.org/package/BiobaseTurner-0.2.2.4 (ChristianHoener)
18:19:16 <fmap> or pattern guards
18:19:25 <scottradcliff> Ahh, I get it. It's for iteration. For each item in the list, store it as x.
18:19:31 <Nereid> sure.
18:19:55 <Nereid> oh, I guess you wouldn't have encountered pattern matching yet.
18:20:19 <Nereid> but more generally you can put a pattern there.
18:20:32 <Nereid> > [x + y | (x,y) <- [(1,2), (3,5), (8,10)]]
18:20:34 <lambdabot>   [3,8,18]
18:21:16 <scottradcliff> I see. This makes way more sense now.
18:21:33 <donri> hm hxt-curl throws segmentation fault :/
18:21:50 <c_wraith> curl often does that.
18:22:01 <c_wraith> or at least, the haskell curl bindings do
18:22:28 <donri> :(
18:22:38 <donri> known workarounds?
18:23:10 <JoeyA> http-conduit?
18:23:12 <c_wraith> don't use curl
18:23:37 <donri> well there's hxt-http, but curl seductively supports more protocols including https ;)
18:23:49 <donri> which i don't *really* need, but *omg features!*
18:23:56 <Nereid> http-conduit also supports https
18:24:05 <JoeyA> http-conduit is webscale
18:24:12 <Nereid> I think?
18:24:14 <donri> but it doesn't support hxt?
18:24:30 <JoeyA> Nereid: Yes, it supports https.
18:24:32 <c_wraith> does it need to?
18:24:36 <Nereid> ah yes, it says so in the synopsis.
18:24:42 <c_wraith> hxt is a parser. http-conduit is a fetcher
18:24:50 <c_wraith> seems trivial to attach one to the other
18:27:25 <optimight> > 1 + 2
18:27:26 <lambdabot>   3
18:27:55 <optimight> I just understood fuctioning of lambdabot
18:28:51 <aib> > Just 3 >>= (\x -> return (x+1))
18:28:52 <optimight> Trying to understand hackagebot <-
18:28:52 <lambdabot>   Just 4
18:29:09 * hackagebot BiobaseVienna 0.2.2.5 - Import Vienna energy parameters  http://hackage.haskell.org/package/BiobaseVienna-0.2.2.5 (ChristianHoener)
18:34:10 * hackagebot RNAFold 1.99.1.3 - RNA secondary structure prediction  http://hackage.haskell.org/package/RNAFold-1.99.1.3 (ChristianHoener)
18:39:10 * hackagebot kevin 0.1.3.1 - a dAmn  IRC proxy  http://hackage.haskell.org/package/kevin-0.1.3.1 (JoelTaylor)
18:39:12 * hackagebot Nussinov78 0.0.1.3 - Nussinov78 using the ADPfusion library.  http://hackage.haskell.org/package/Nussinov78-0.0.1.3 (ChristianHoener)
18:39:50 <donri> so uhm, there's old-locale but not locale, although old-locale suggests it?
19:18:13 <startling> has anyone used (or attempted to use) hakyll with heist?
19:21:29 <startling> also, is hakyll well-regarded? Some of the design choices seem a little iffy to me, but it could be because I don't grok the whole thing
19:22:15 <donri> people seem to use it, personally i have some issues with it too
19:29:40 <hpaste> bryanvick pasted “Newbie w/ type declaration problems” at http://hpaste.org/71074
19:30:01 <bryanvick> I'm missing something simple, anybody care to look?
19:33:09 <applicative> bryanvick: it must be Int
19:33:18 <applicative> @type (!!)
19:33:20 <lambdabot> forall a. [a] -> Int -> a
19:33:52 <bryanvick> I tried that, and I get: `Int' is applied to too many type arguments
19:34:02 <applicative> indeed
19:34:13 <applicative> you dont want they class, just  the type
19:34:20 <hpaste> ClaudiusMaximus annotated “hxournal ghc-7.4 problems” with “hoodle ghc-7.4 problems (a solution)” at http://hpaste.org/71069#a71075
19:34:47 <deckeraa> elementAt1
19:34:55 <applicative> bryanvick: you want the same signature (!!) has, since you are renumbering it so to say
19:35:00 <applicative> @type (!!)
19:35:01 <lambdabot> forall a. [a] -> Int -> a
19:35:21 <bryanvick> applicative: OK, thanks a bunch.
19:35:29 <applicative> this is different from Integral b => [a] -> b -> a
19:35:35 <ClaudiusMaximus> is my paste in any way reasonbale?  or should GADTs have worked like the original source (which apparently worked with ghc-7.0)?
19:36:08 <applicative> Integral b => means (sort of): where b is either Int or Integer, [a] -> b -> a
19:36:19 <ClaudiusMaximus> (i'm a n00b at GADTs, just tinkering to get it to compile and run, which it did)
19:37:09 <bryanvick> applicative: I was hoping I could accept either Int *or* Integer.  How could I write that?
19:37:18 <applicative> bryanvick: you can get what you want with fromIntegral.
19:37:39 <bryanvick> applicative: OK, I've seen that somewhere, I'll look it up.
19:39:21 <applicative> @type let elementAt1 xs n = xs !! (fromIntegral n - 1) in elementAt1
19:39:23 <lambdabot> forall a a1. (Integral a1) => [a] -> a1 -> a
19:39:47 <aristid> :t fromIntegral
19:39:49 <lambdabot> forall a b. (Integral a, Num b) => a -> b
19:40:13 <applicative> I think that's the signature you want
19:40:20 <ClaudiusMaximus> the data definition is here https://github.com/wavewave/hoodle-core/blob/master/lib/Hoodle/Type/PageArrangement.hs#L116
19:40:22 <ion> @type generalIndex
19:40:24 <lambdabot> Not in scope: `generalIndex'
19:40:27 <ion> @type Data.List.generalIndex
19:40:29 <lambdabot> Not in scope: `Data.List.generalIndex'
19:40:35 <ion> uhh, brainfart
19:40:37 <ion> @type genericIndex
19:40:38 <lambdabot> forall b a. (Integral a) => [b] -> a -> b
19:41:15 <applicative> bryanvick: the above definition still gives !! an Int but you can feed it n of any 'Integral' type
19:41:24 <donri> optimight: hackagebot only reports new packages on hackage, nothing more
19:41:35 <applicative> Ah ion has it, bryanvick
19:41:46 <optimight> donri: thanks
19:43:01 <applicative> @type let let elementAt1 xs n = genericIndex xs (n-1) in elementAt1
19:43:02 <lambdabot> parse error (possibly incorrect indentation)
19:43:09 <optimight> donri:  I am progressing through learn you a haskell for good and few other material
19:43:10 <applicative> @type let elementAt1 xs n = genericIndex xs (n-1) in elementAt1
19:43:11 <lambdabot> forall b a. (Integral a) => [b] -> a -> b
19:44:00 <applicative> ^^^ bryanvick so that's sort of what you were thinking at first, Data.List.genericIndex indexes with any Integral type
19:46:38 <startling> is there anything nicer than heist for making html from templates? I like it a lot, but the API is a bit unwieldy
19:47:10 <donri> define nicer :)
19:47:26 <bryanvick> applicative: I think I need to read a bit more Haskell chapters before I can grok this.  I haven't even encountered Data.List.* yet.  Thanks for the help
19:47:33 <donri> hamlet has a simple api i think, but it's not simply html syntax
19:47:54 <applicative> bryanvick: it's just some additional defined terms
19:48:04 <mikeplus64> startling: you could make your own little html dsl (i did, very easy)
19:48:12 <mikeplus64> i'll boot up my laptop and find the code
19:48:40 <startling> mikeplus64, hm, interesting idea
19:48:49 <bryanvick> applicative: are "terms" analogous to "types" in other languages?
19:49:14 <startling> what libraries are nice for building html?
19:49:25 <donri> blaze-html, xhtml-combinators
19:49:27 <mikeplus64> hamlet, heist, blaze
19:49:36 <optimight> I am trying to use irssi this gives me this error : 08:15 -!- Irssi: Looking up chat
19:49:36 <optimight> 08:15 -!- Irssi: Unable to connect server chat port 6667 [Name or service not
19:49:37 <optimight>           known]
19:49:45 <applicative> bryanvick: no, by 'terms' I  just meant defined expressions, like your elementAt1
19:49:52 <startling> thanks! I'll check them out
19:49:53 <donri> hsx is nice for power and complex needs
19:50:00 <bryanvick> applicative: ok, so Data.* is a sort of namespace?
19:50:12 <applicative> bryanvick: exactly
19:50:17 <applicative> its a module
19:50:21 <donri> but if heist's api scares you, hsx will have you screaming
19:51:00 <applicative> bryanvick: its just like anything you would write http://www.haskell.org/ghc/docs/latest/html/libraries/base/src/Data-List.html
19:51:37 <applicative> a little more complicated since it's  supposed to be okay for diverse haskell implementations
19:51:57 <kulin> I am working on a haskell program that has custom icons and I am not sure how to setup the project, cabal file, or relative paths in the code. Where is a good starting point for this?
19:53:06 <zzo38> data X :: (* -> *) -> (* -> *) -> * -> * where { X :: y z -> X x y (x z); };   What would it be called instead of "X"?
19:54:41 <zzo38> And what are some of the possible uses?
19:54:47 <donri> kulin: http://www.haskell.org/cabal/users-guide/developing-packages.html#accessing-data-files-from-package-code
19:56:48 <kulin> donrr: thanks
20:02:56 <adnauseam> is haskell a Total Functional Programming language?
20:03:41 <ion> no
20:03:54 <ion> Haskell can have functions that are not total.
20:04:31 <ion> Although that’s discouraged (and often caught and warned about by the compiler).
20:04:41 <meiji11> what does it mean for a function to be total?
20:05:17 <Veinor> defined over all values
20:05:30 <Veinor> for example, head isn't total because head [] is an error
20:05:32 <adnauseam> yeah i was wondering that because i noticed that the compiler does warn about infinite types
20:05:45 <adnauseam> or [1..]
20:05:56 <Cale> adnauseam: hm?
20:05:58 <ion> There’s nothing wrong with [1..]
20:06:01 <adnauseam> isn't it ?
20:06:06 <Cale> adnauseam: What doesn't warn about infinite types?
20:06:12 <adnauseam> i meant that [1..] isn;t total
20:06:21 <Cale> [1..] is totally defined
20:06:22 <ion> [1..] isn’t a function.
20:06:26 <Cale> > [1..]
20:06:27 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
20:06:43 <adnauseam> Cale: it [GHC] /does/ warn about infinite types :p
20:06:48 <adnauseam> oh :o
20:06:59 <Cale> Yeah, I just got here, I'm not sure what you're talking about :)
20:07:02 <Veinor> infinite types? those are a compiler error, not a warning
20:07:10 <Cale> yeah
20:07:21 * adnauseam needs toget his terminology straight 
20:07:31 <Cale> > (\x -> x x) (\x -> x x)
20:07:33 <lambdabot>   Occurs check: cannot construct the infinite type: t = t -> t1
20:10:36 <kulin> Package names are suppose to be lower case, correct?
20:11:33 <ion> @hackage QuickCheck
20:11:34 <lambdabot> http://hackage.haskell.org/package/QuickCheck
20:14:17 <applicative> kulin I think people tend to make them lower case now, maybe because cabal ignores case?
20:14:52 <applicative> kulin therefore you should brazenly name your package with all caps
20:15:11 <JoeyA> MOAR-MONAD-TRANSFORMERS
20:15:21 <favonia> adnauseam: almost all PLs mean "partial functions" by "functions"... except ones used for proving theorems, like agda, coq, etc. perhaps you're asking about "(co?)values in Haskell"---if you really care about denotational semantics.
20:15:40 * applicative types cabal install moar-monad-transformers
20:18:10 <startling> cabal: There is no package named 'moar-monad-transformers'
20:18:36 <startling> cabal: perhaps you mean 'MOAR-MONAD-TRANSFORMERS'?
20:29:03 <edwardk> preflex: xseen dmwit
20:29:03 <preflex>  dmwit was last seen on freenode/#haskell-blah 7 hours, 43 minutes and 46 seconds ago, saying: huh
20:33:06 <hpaste> mikeplus64 pasted “html dsl” at http://hpaste.org/71076
20:33:14 <mikeplus64> startling:
20:33:27 <mikeplus64> sorry it took a while i couldn't mount my usb properly
20:34:26 <BMeph> mikeplus64: Your doctor should be able to prescribe a pill for that... ;)
20:39:01 <kulin> what are my options if i dont want to use cabal to control the data files for my application, if i want it to be a stand alone application i can release as binary w/ data files
20:40:26 <kulin> or am i just misunderstanding cabal install, i would want the result to be that it creates a self contained folder, rather than that it throws everything into the cabal folder
20:41:44 <ClaudiusMaximus> kulin: i wrote binembed (but it's probably bitrotten / and never really worked on anything other than my systems because of assembler syntax differences, etc) to overcome my perceived shortcomings in the alternatives
20:42:09 <Cale> Presumably you can still use cabal to build your project and then distribute the binaries that it generates?
20:42:23 <ClaudiusMaximus> kulin: the alternatives used things like template-haskell to read a file and stuff it into a huge literal which ghc took an age to compile
20:43:29 <ClaudiusMaximus> kulin: or am i misunderstanding - i interpreted you as wanting to have everything in one .exe or whatever
20:43:42 <kulin> cale, when i use cabal build, it does not place the data files in the dist directory, and when i use cabal install it installs the program into cabal/bin and cabal/program-version
20:44:11 <kulin> what i want is cabal to just create dist/build/program/program & dist/build/program/data/*.png
20:45:24 <Cale> There's probably a way to do that, but I'm unsure what it is. However, can't you just place the files into the distributed package yourself?
20:45:38 <Cale> I mean, if you're not distributing the thing as source anyway...
20:45:44 <kulin> i can, but it seems like it would be the default, rather than the exception
20:46:02 <ClaudiusMaximus> you might end up with the much-discussed-on-mailing-lists problem of "how do i get the path to the program in a portable way"
20:46:03 <kulin> i'd distribute the source, its not about it being closed source
20:47:37 <kulin> so theres nothing in cabal that says "also copy the data files to the same directory as the binary"
20:47:52 <kulin> ill have to make a bash script, and run that when i build to also add the files?
20:48:39 <Cale> At worst, you can use a custom Setup.hs
20:48:55 <Cale> but I suspect there's a better way, I'm just looking in the Cabal documentation
20:50:28 * Cale wonders if dcoutts is around, he'd probably know how to do this
20:51:44 <ClaudiusMaximus> cabal sdist wants you to list everything explicitly, with minimal wildcards (oft complained about) http://www.haskell.org/cabal/users-guide/developing-packages.html#package-properties "data-files" provides a rationale
20:52:12 <startling> is there something that takes "whatever/*" and its ilk as input and returns a [FilePath] depending on which exist?
20:52:40 <ClaudiusMaximus> @hoogle glob
20:52:40 <startling> I'm thinking like the python module "glob"
20:52:40 <lambdabot> package Glob
20:52:40 <lambdabot> Language.Haskell.TH.Lib global :: Name -> ExpQ
20:52:41 <lambdabot> Language.Haskell.TH global :: Name -> ExpQ
20:53:21 <Cale> http://hackage.haskell.org/package/Glob-0.7.1
20:54:02 <startling> Cale: thanks!
20:54:17 <Cale> there's also http://hackage.haskell.org/package/filemanip
20:54:18 <startling> ClaudiusMaximus: you too!
20:55:14 <Eduard_Munteanu> adnauseam: if you want something like Haskell, but total, check out Agda and #agda ;)
20:55:33 <ClaudiusMaximus> hooray!  was starting to worry i was invisible (no one replied to my previous GADTs stuff an hour and a half ago, maybe someone has ideas now?  http://hpaste.org/71069#a71075 )
20:55:47 <Eduard_Munteanu> But don't expect it to be much of a programming language, only if you're inclined to write proofs :)
20:57:14 <ClaudiusMaximus> apparently the original code compiled with ghc-7.0, but i had to add some classes for ghc-7.4 to stop complaining
20:57:19 <Eduard_Munteanu> (also, lotsa dependent types :D)
20:57:46 <Eduard_Munteanu> Or Idris, but I haven't tried it myself.
20:58:51 <edwardk> kulin: you're using extra-data-files and they aren't going where you want?
20:59:27 <kulin> edwardk: im using data-files, i didnt know extra-data-files was a think, ill try that now
20:59:48 <edwardk> kulin: you can reference Paths_yourpackage and get the path to them
21:00:06 <edwardk> kulin: check out my 'hyphenation' package which installed like 100 files that way ;)
21:00:10 <kulin> edwardk oh i am using that, but thats not what i want, that still puts things all over the hard drive, i want everything in one place
21:00:18 <edwardk> oh
21:00:39 <edwardk> you're largely out of luck, you can probably hack up the setup.hs to change the data file path manually
21:01:03 <kulin> maybe i am just thinking about this the wrong way or something, why is this case the fringe case?
21:01:04 <edwardk> it should be in the set of parameters you can manipulate/hook into
21:01:38 <edwardk> kulin: its just the way we install stuff by default, this way the data-files live in a sort of well known canonical location per package
21:02:48 <ion> For a binary distribution outside of cabal, you could create a tarball with a script and have your code look for the data files under cabal’s path *and* somewhere relative to the path of the executable.
21:03:33 <edwardk> yeah, you can use Paths_foo to get access to the cabal location and check the local directory first, before falling back on that path
21:03:36 <startling> how can I have MyModule be a haskell module and also have submodules?
21:03:56 <startling> can I have both MyModule.hs and MyModule/OtherStuff?
21:04:15 <edwardk> just make a module MyModule.OtherStuff in MyModule/OtherStuff.hs
21:04:17 * hackagebot bound 0.3.2 - Haskell 98/2010 Locally-Nameless Generalized de Bruijn Terms  http://hackage.haskell.org/package/bound-0.3.2 (EdwardKmett)
21:12:50 <ClaudiusMaximus> kulin: cabal has options for this in cabal install --help ; for example: ( PKG=prof2pretty ; cabal install -O2 --solver=modular --avoid-reinstalls --one-shot --bindir=${HOME}/tmp/${PKG}/ --datadir=${HOME}/tmp/${PKG}/ --datasubdir=data/ --disable-documentation ${PKG} ; ls -R )
21:13:18 <ClaudiusMaximus> (oops, i ran that from within ~/tmp/${PKG}/
21:15:18 <kulin> ClaudiusMaximus, awesome! thanks
21:15:42 <ClaudiusMaximus> but note that it's not relocatable (the full path is baked in - gonna try relative paths now..)
21:18:41 <ClaudiusMaximus> hm, relative paths seem to break completely (maybe cabal install changes its working directory..)
21:20:09 <startling> what's the best way to replace a suffix (in this case, the suffix of a filename)?
21:20:22 <ClaudiusMaximus> @hoogle replaceExtension
21:20:22 <lambdabot> System.FilePath.Windows replaceExtension :: FilePath -> String -> FilePath
21:20:22 <lambdabot> System.FilePath.Posix replaceExtension :: FilePath -> String -> FilePath
21:20:30 <startling> oh nice
21:20:32 <startling> ClaudiusMaximus: thanks!
21:20:44 <ClaudiusMaximus> System.FilePath re-exports the correct one for you
21:20:48 <startling> yep
21:23:08 <kulin> well i have to duck out claudius, but i will look more into this later, it looks promising
21:23:13 <kulin> thanks
21:23:37 <ClaudiusMaximus> cool, g'luck
21:23:37 <edwardk> kulin: those options can be set from within the Setup.hs directly if you mine enough documentation to figure out how
21:24:16 <edwardk> kulin: so if you really want to customize the Setup.hs of your cabal project you should be able to get your desired behavior.
21:24:37 <kulin> edwardk i will def do that if i can get the location independance to work out
21:26:09 <cads> can someone recommend a tutorial for working with computable reals?
21:26:26 <cads> really I only need algebraic numbers
21:27:41 <cads> I'd like to compute billiard ball trajectories inside a plane polygon.
21:28:59 <cads> and really I've already got a means to classify and enumerate them. I'd like to be able to render them using the Diagrams library
21:29:18 * hackagebot xml-conduit 1.0.1.1 - Pure-Haskell utilities for dealing with XML with the conduit package.  http://hackage.haskell.org/package/xml-conduit-1.0.1.1 (MichaelSnoyman)
21:30:53 <ClaudiusMaximus> hm, numeric-prelude seems to have something, but the documentation is unreadable
21:31:20 <ClaudiusMaximus> http://hackage.haskell.org/packages/archive/numeric-prelude/latest/doc/html/Algebra-Algebraic.html
21:34:29 <ClaudiusMaximus> cads: there's also some specific extended rational field here http://hackage.haskell.org/packages/archive/diagrams-contrib/0.1.1.1/doc/html/Diagrams-TwoD-Tilings.html
21:35:17 <ClaudiusMaximus> i remember discussing this kind of stuff a long time ago, let me see if i can find logs...
21:43:35 <cads> Hmm, I think I could get pretty far with that basic sqrt(2), sqrt(3) ring
21:44:09 <ClaudiusMaximus> cads: http://tunes.org/~nef/logs/haskell/11.05.24 06:07:48
21:45:42 <ClaudiusMaximus> it didn't get written, because http://tunes.org/~nef/logs/haskell/11.11.07 19:53:06
21:47:04 <ClaudiusMaximus> i think i started writing it, then got worried about coprimality testing for type level numerals, then wandered off
21:49:19 * hackagebot js-good-parts 0.0.6 - Javascript: The Good Parts -- AST & Pretty Printer  http://hackage.haskell.org/package/js-good-parts-0.0.6 (SeanSeefried)
21:50:25 <cads> thanks claudius
21:51:16 <Veinor> is there a way to run a Q [Dec] in ghci?
21:53:06 <ClaudiusMaximus> @hoogle Q a -> IO b
21:53:06 <lambdabot> Language.Haskell.TH.Syntax runQ :: Quasi m => Q a -> m a
21:53:07 <lambdabot> Language.Haskell.TH runQ :: Quasi m => Q a -> m a
21:53:07 <lambdabot> Control.Exception.Base evaluate :: a -> IO a
21:54:13 <hpaste> tgeeky pasted “anybody want to fill in the '...'? I'll pay 8 karma per second” at http://hpaste.org/71079
21:58:17 <ClaudiusMaximus> tgeeky: try a sodoku solver
21:59:17 <Eduard_Munteanu> What is that thing?
21:59:47 <tgeeky> probably invalid and unusable
21:59:50 <ClaudiusMaximus> looks like some colour space thing if RGB / CMYK are anything to take seriously
21:59:51 <cads> jebus crist
21:59:51 <hpaste> applicative annotated “anybody want to fill in the '...'? I'll pay 8 karma per second” with “anybody want to fill in the '...'? I'll pay 8 karma per second (annotation)” at http://hpaste.org/71079#a71080
22:00:03 <tgeeky> if one of you assholes just wrote undefined
22:00:23 <tgeeky> well, that's not so bad
22:00:34 <tgeeky> not helpful, though
22:00:55 * applicative just wanted to  see if ghc would tolerate this kind signature
22:01:38 <hpaste> tgeeky annotated “anybody want to fill in the '...'? I'll pay 8 karma per second” with “anybody want to fill in the '...'? I'll pay 8 karma per second (annotation) (annotation)” at http://hpaste.org/71079#a71081
22:01:50 <cads> tgeeky, what in hodor's name is that?
22:02:14 <tgeeky> cads: an attempt to write a additive/subtractive color space homomorphism
22:02:15 <Eduard_Munteanu> I really don't get this.
22:02:34 <tgeeky> k is defined wrongly (it should have no def for the right three)
22:02:53 <Eduard_Munteanu> And how are Either and Int valid there?
22:03:12 <tgeeky> Int has a max and minbound, so it can be split
22:03:31 <tgeeky> so you can use it for both the key (1) and the zero points
22:03:32 <Eduard_Munteanu> I mean, how did you stick an Either in a kind? :/
22:03:44 <Eduard_Munteanu> Also, a list.
22:03:57 <tgeeky> Eduard_Munteanu: GHC HEAD and byorgey et al's awesomeness
22:04:08 <tgeeky> this also works:
22:04:13 <Eduard_Munteanu> Hrm... what extension is that?
22:04:18 <tgeeky> kind poly
22:04:19 <tgeeky> data KList   :: ( k -> * ) -> [k] -> * where
22:04:19 <tgeeky>      KNil    :: KList f '[]
22:04:19 <tgeeky>      (:|:)   :: f t -> KList f ts -> KList f (t ': ts)
22:04:29 <Eduard_Munteanu> Looks fun.
22:04:39 * applicative is not finding any types of kind (z -> [( * , * , * ,Int, * , * , * )]) coming to mind
22:04:50 <tgeeky> applicative: hehe
22:05:25 <Veinor> i'm trying to get this example from the TH docs to work:  let v = mkName "T" in [| data $v = $v |]
22:05:40 <tgeeky> Eduard_Munteanu: what do you suppose the type of: exlist =       Id (3)  :|: Id (\x -> x)  :|: Id False  :|: KNil
22:05:43 <tgeeky> is?
22:05:45 <Veinor> i replaced [| with [d|, since it's a declaration, but it's giving me the error parse error in constructor in data/newtype declaration: $v
22:06:33 <tgeeky> Eduard_Munteanu: exlist :: KList Id '[Int, Int -> Int, Bool]
22:07:00 <Eduard_Munteanu> tgeeky: hm, yeah. I'm unsure what that Id / f does, though.
22:07:16 <tgeeky> Eduard_Munteanu: it's the identity newtype
22:07:17 <tgeeky> newtype Id         a = Id {unId :: a  } deriving (Read, Show)
22:07:51 <Eduard_Munteanu> I mean, why does KList take that parameter?
22:08:32 <tgeeky> hm. I don't know. I'm implementing code from a paper
22:08:39 <tgeeky> I mean, you don't have to use Id
22:08:39 <tgeeky> ex2list ::  KList (K Int) [Int, Int, Int]
22:08:45 <tgeeky> ex2list = K 1 :|: K 2 :|: K 3 :|: KNil
22:08:51 <tgeeky> newtype K       b a = K {unK :: b  } deriving (Read, Show)  -- "the" constant type constructor
22:09:05 <Eduard_Munteanu> Hm, yeah.
22:09:41 <tgeeky> I presume you could do other clever things. The paper I'm working from (Abstract Syntax Graphs for DSLs -- doesn't used the stuff from GHC 7.5.x, and does it with "*-abuse"
22:10:09 <Eduard_Munteanu> What is the sort of that Int, * etc. by the way?
22:10:24 <Eduard_Munteanu> Presumably it extends the kind system one level up, no?
22:11:05 <hpaste> tgeeky annotated “anybody want to fill in the '...'? I'll pay 8 karma per second” with “anybody want to fill in the '...'? I'll pay 8 karma per second (annotation)” at http://hpaste.org/71079#a71082
22:11:09 <tgeeky> Eduard_Munteanu: you mean that ^?
22:11:09 <Eduard_Munteanu> (or do you get an infinitely high hierarchy?)
22:11:20 <tgeeky> Eduard_Munteanu: no, I think you just get the one?
22:11:33 <Eduard_Munteanu> Ah.
22:11:40 <tgeeky> Eduard_Munteanu: every "data ..." must end with -> *
22:11:45 <tgeeky> i don't know if that's even related
22:12:15 <Eduard_Munteanu> Well, * is like Agda's Set I guess.
22:12:48 <Eduard_Munteanu> So you can't make members of other kinds.
22:13:09 <tgeeky> well, you can't promote something that has been promoted before
22:13:23 <tgeeky> -- ^
22:13:23 <tgeeky> -- >>> :k KNil
22:13:23 <tgeeky> <interactive>:1:1:
22:13:23 <tgeeky>     `KNil' of type `forall (k0 :: BOX) (f :: k0 -> *).
22:13:23 <tgeeky>                     KList k0 f ('[] k0)' is not promotable
22:13:53 <Eduard_Munteanu> Mm... KNil isn't a type though.
22:14:09 <tgeeky> -- >>> :t KNil
22:14:09 <tgeeky> KNil :: KList k0 f ('[] k0)
22:14:46 <Eduard_Munteanu> tgeeky: I guess you can't ask for BOX's type/kind, no?
22:15:00 <tgeeky> nope, I don't think so
22:15:32 <rj_> anyone from singapore?
22:15:34 <Eduard_Munteanu> Anyway, it is quite neat, this should get arbitrarily more levels and universe polymorphism now :)
22:16:35 <Eduard_Munteanu> Then #agda might go like Detroit :P
22:17:12 <Veinor> hmm, yeah
22:17:18 <Veinor> mkDecl name = [d|data Foo = $(normalC name [])|]  still gives me a compiler error :/
22:17:18 <tgeeky> hehe
22:18:45 <ion> Are there other functors than Const and Identity that are useful with van Laarhoven lenses?
22:19:27 <tgeeky> Product?
22:21:13 <applicative> rj_ I see someone on the map of professionals http://www.haskellers.com/
22:21:27 <applicative> ah
22:23:09 * applicative notes a couple of haskellers in Antarctica
22:26:45 <ion> The (a ->) functor might be used instead of Identity for modification and setting, i think.
22:27:39 <ion> > let fstL f (a,b) = flip (,) b <$> f a in fstL (flip const) ("foo","bar") 42
22:27:42 <lambdabot>   (42,"bar")
22:28:16 <ion> > let fstL f (a,b) = flip (,) b <$> f a in fstL (flip id) ("foo","bar") reverse
22:28:18 <lambdabot>   ("oof","bar")
22:39:23 <ion> edwardk: Thoughts?
22:39:33 <edwardk> ?
22:40:18 <edwardk> ion: for other functors, the Store comonad is a useful one
22:40:44 <edwardk> and there is a 'Focusing' functor that roconnor uses in lens-family for the 'focus' operation on State
22:40:59 <ion> Thanks, i’ll check them out.
22:41:30 <edwardk> i like the use of the (->) a functor there, nice touch
22:42:14 <edwardk> of course thats just the identity functor in disguise as you are ignoring the argument
22:42:31 <ion> yeah
22:47:06 <ion> Hmm, okay…
22:47:08 <ion> λ> let fstL f (a,b) = (,b) <$> f a in (first ($ "quux") . runStore . fstL (store P.length)) ("foo","bar")
22:47:09 <ion> ((4,"bar"),"foo")
22:47:21 <ion> A bit contrived. :-)
22:48:20 <Nisstyre> So how does Template Haskell differ from lisp macros? Is template haskell "hygienic" ? Or does that somehow not apply to this style of macro expansion?
23:05:16 <edwardk> Nisstyre: TH is uhygienic, but more strongly typed
23:08:47 <edwardk> ion: instantiating an indexed store IxStore c d a = IxStore (d -> a) c can let you characterize the lens. (c -> IxStore c d d) -> a -> IxStore c d b     -- since you can pass 'IxStore id' as the argument.
23:09:05 <edwardk> and you get out a polymorphic 'indexed store comonad coalgebra'
23:09:22 * hackagebot iteratee-compress 0.3.1.0 - An enumerators for compressing and decompressing streams  http://hackage.haskell.org/package/iteratee-compress-0.3.1.0 (MaciejPiechotka)
23:10:19 <edwardk> ion: this is used for 'clone', to let you use a monomorphically typed lens family in multiple contexts
23:12:34 * kallisti prefers coindexed costore monad algebras.
23:18:22 <optimight> > 2 + 2
23:18:23 <lambdabot>   4
23:32:48 <archeyDevil> Does cycle have any limit?
23:32:54 <archeyDevil> or just infinite?
23:33:21 <ion> @src cycle
23:33:21 <lambdabot> cycle [] = undefined
23:33:22 <lambdabot> cycle xs = xs' where xs' = xs ++ xs'
23:33:27 <archeyDevil> length (cycle "test") Looks like infinite.
23:34:01 <archeyDevil> So infinite. :)
23:34:09 <jbe> There is replicate.
23:35:09 <archeyDevil> jbe: Thanks.
23:35:36 <dmwit> edwardk: I haven't grokked clone yet.
23:35:50 <dmwit> You say roconnor suggested it; was that just on IRC, or was there a blog post, too...?
23:35:57 <edwardk> irc
23:36:07 <dmwit> Also, I couldn't help but laugh at the </interactive> at the end of each error message in your blog post. ^_^
23:36:23 <archeyDevil> [x*2 | x <- [0..10]], thats substitution right?
23:36:30 <edwardk> i have </interactive> all overthe place?
23:37:00 <edwardk> hahaha
23:37:08 <edwardk> that was automatically inserted by my blog =)
23:37:16 <dmwit> I figured.
23:37:24 <edwardk> i didn't catch that at all =)
23:37:26 <dmwit> clbuttic
23:37:35 <ion> :-D
23:38:06 <edwardk> dmwit: so what is it about clone you are having trouble grokking?
23:38:21 <edwardk> clone makes an indexed store based lens out of a van laarhoven lens
23:38:25 <edwardk> that fully characterizes the lens
23:38:32 <ion> What package defines clone?
23:38:34 <edwardk> then it takes it back apart into something polymorphic
23:38:36 <ion> @hoogle clone
23:38:37 <lambdabot> No results found
23:38:50 <edwardk> clone l f a = case l (Store id) a of Store g c -> fmap g (f c)
23:38:50 <edwardk>  
23:38:57 <archeyDevil> how to order an array? (by num)
23:39:08 <ion> archeyDevil: If you mean a list, sort.
23:39:42 <archeyDevil> ion: Yea. sort.. Doesn't exist?
23:39:43 <dmwit> Well, clone's type signature mentions all the types passed to LensFamily earlier in the type signature.
23:39:51 <archeyDevil>     Not in scope: `sort'
23:39:52 <ion> @hoogle sort
23:39:52 <lambdabot> Data.List sort :: Ord a => [a] -> [a]
23:39:52 <lambdabot> Data.List sortBy :: (a -> a -> Ordering) -> [a] -> [a]
23:39:52 <lambdabot> Data.ByteString sort :: ByteString -> ByteString
23:39:52 <dmwit> So how can we get something more polymorphic out of it than what we passed in?
23:39:58 <archeyDevil> Thanks
23:40:08 <archeyDevil> :)
23:40:14 <edwardk> ((c -> Store c d d) -> (a -> Store c d b)) -> LensFamily a b c d -- ?
23:40:20 <dmwit> ion: http://comonad.com/reader/2012/mirrored-lenses/
23:40:25 <ion> dmwit: Thanks
23:40:32 <edwardk> dmwit: look at dlens and plens in my post
23:40:36 <edwardk> dmwit: then compose them
23:40:43 <dmwit> edwardk: Right, a, b, c, and d are already mentioned in the arguments. So how does the result suddenly become more polymorphic?
23:40:49 <edwardk> and when you get done interleaving their definitions you get clone
23:40:51 <dmwit> No, no, I grok the implementation.
23:41:10 <edwardk> what its doing is building something that knows how to walk into another functor
23:41:13 <dmwit> What I'm asking is how this trick makes it past the type system.
23:41:21 <jnoah1984> Hello, I am new to Haskell. Going through the wikibooks Haskell book. I came across an exercise that I am stuck on. http://pastebin.com/KHAa9csj  How are these different?
23:41:23 <mauke> The paste KHAa9csj has been copied to http://hpaste.org/71085
23:41:28 <dmwit> edwardk: ah!
23:41:41 <edwardk> the trick is fmap
23:41:41 <edwardk> ;)
23:42:14 <edwardk> its much more obvious with an isomorphism lens
23:42:23 <ClaudiusMaximus> any cute way to find a conservative approximation to a desired accuracy of the boundary of the immediate basin of convergence under newton's method to a specific root of a complex polynomial?
23:42:51 <edwardk> a <-> (b,c)     -- so we take b -> f b, and then use the strength of every functor to distribute the (,c) and use the isomorphism to come back
23:42:52 <ClaudiusMaximus> by conservative i mean no point within the approximation is outside the true region
23:43:30 <dmwit> edwardk: Wait, then I'm really confused what we gained. The return type is a LensFamily, and the definition of LensFamily needs rank-2 types...?
23:43:32 <edwardk> here the isomorphism is implicit
23:43:55 <edwardk> dmwit: you can remove the LensFamily signature
23:44:02 <edwardk> if you just put the body in you get
23:44:15 <dmwit> I see.
23:44:17 <dmwit> Yes, I see.
23:44:21 <edwardk> clone :: Functor f => ((c -> Store c d d) -> (a -> Store c d b)) -> (c -> f d) -> a -> f b
23:44:39 <edwardk> i wrote it that way for expository purposes
23:44:39 <dmwit> Yes, okay. So we might write something like
23:44:50 <edwardk> \l y -> clone l ^= y ^. clone l + 1 $ y
23:44:51 <dmwit> clone :: LensFamily f blah blah -> LensFamily g blah blah
23:45:00 <ion> @check let pts :: Int -> Int; pts 1 = 10; pts 2 = 6; pts 3 = 4; pts 4 = 3; pts 5 = 2; pts 6 = 1; pts _ = 0; pts' :: Int -> Int; pts' 1 = 10; pts' 2 = 6; pts' x | x <= 6 = 7 - x | otherwise = 0 in \x -> pts x == pts' x
23:45:01 <lambdabot>   "Falsifiable, after 0 tests:\n-2\n"
23:45:08 <dmwit> edwardk: right?
23:45:19 <dmwit> where here f and g are different functors
23:45:35 <edwardk> well, it still has to take (Store c d) as the first 'f'
23:45:46 <ClaudiusMaximus> (something like an approximation the boundary of one of the largest contiguous regions here http://en.wikipedia.org/wiki/File:Newtroot_1_0_0_m1.png )
23:45:46 <edwardk> but it can choose any other functor for the second
23:45:56 <edwardk> using the lens-family-core types you'd have something like
23:46:17 <edwardk> clone :: Functor f => LensFamily (Store c d) a b c d -> LensFamily f a b c d
23:46:22 <dmwit> ah
23:46:31 <dmwit> Okay, so I'll try again.
23:46:38 <dmwit> For now, allowing rank-2 types, you could write
23:46:56 <jbe> jnoah1984: You could run those functions inside ghci and start throwing Ints at them until you find the difference.
23:47:07 <dmwit> clone :: (forall f. Functor f => LensFamily f a b c d) -> Functor g => LensFamily g a b c d
23:47:21 <dmwit> and then the cute observation is that the first one doesn't have to work for all functors, but only for Store c d.
23:47:31 <edwardk> sure, but the first argument doesn't need to be polymorphic, yep
23:47:53 <dmwit> (Since inside the body we specialize it to use Store c d anyway.)
23:47:58 <dmwit> okay
23:48:02 <dmwit> Okay, great!
23:48:17 <edwardk> so basically what clone does is characterize the lens by converting it to and from an 'indexed store' lens
23:48:52 <edwardk> which lets you pass in a lens constrained monomorphically to store, and use it as any kind of van laarhoven lens family you want
23:52:07 <archeyDevil> What is the reason to why functions can't start with capital letters?
23:52:48 <dmwit> archeyDevil: It makes it easier to parse pattern matches.
23:52:54 <edwardk> archeyDevil: Foo a = … is a destructuring pattern match on a constructor Foo
23:53:17 <edwardk> destructuring assignment is very useful
23:53:39 <archeyDevil> Okay
23:53:40 <edwardk> i'd rather have that than uppercase function names ;)
23:54:02 <ion> > let Sum a = foo; foo = Sum 42 in a
23:54:03 <lambdabot>   42
23:54:27 <dmwit> It's probably feasible to have both with today's parsing technology. But it would be tricky, and twenty years ago when the language was forming it probably was too much to ask for.
23:54:27 * hackagebot control-monad-loop 0.1 - Simple monad transformer for imperative-style loops  http://hackage.haskell.org/package/control-monad-loop-0.1 (JoeyAdams)
23:54:56 <dmwit> Having a context-free grammar is nice.
23:54:58 <ion> dmwit: It also might make the code harder to reason about.
23:55:27 <dmwit> I'm not sure I understand that point.
23:55:57 <ion> Random line of code you’re reading:
23:55:59 <dmwit> You mean that people's wetware parsers would have to be correspondingly more complex, too? If so, then yes, of course.
23:56:03 <ion> f baz = …
23:56:26 <ion> Is baz a data constructor or will it match and bind anything?
23:56:34 <dmwit> Right, you can't read random lines if your grammar is context-sensitive. =)
23:56:42 <dmwit> You need the context. =)
23:56:47 <edwardk> dmwit: well, its possible, agda does it, but it is highly undesirable to have code changes in another module start changing whether or not code in your current module parses things in binders as variables or constructors
23:57:01 <dmwit> edwardk: Oh, yes, separate compilation is a nice feature too.
23:57:04 <dmwit> yes yes
23:57:35 <edwardk> well, compilation remains separable, but the semantics of your code drastically change when someone makes a new constructor
23:57:55 <edwardk> data a = a -- would affect anyone who imported your module
23:58:05 <edwardk> and turn all of the 'a' variable bindings into pattern matches
23:58:15 <ion> edwardk: Do they have a convention of using capitalized names for constructors and non-capitalized names for other values?
23:58:49 <edwardk> ion: agda is surprisingly light on syntactic conventions other than 'use unicode to confuse and obfuscate wherever possible' ;)
23:58:57 <ion> heh
23:59:28 * hackagebot palindromes 0.3.2 - Finding palindromes in strings  http://hackage.haskell.org/package/palindromes-0.3.2 (JohanJeuring)
