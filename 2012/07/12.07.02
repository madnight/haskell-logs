00:13:51 * hackagebot js-good-parts 0.0.5 - Javascript: The Good Parts -- AST & Pretty Printer  http://hackage.haskell.org/package/js-good-parts-0.0.5 (SeanSeefried)
00:44:05 <Nensha> darcsden or patch-tag for darks ?
00:46:02 <Nensha> How does they https://github.com/ghc sync darcs with git?
00:48:52 * hackagebot subtitleParser 0.2 - A parser for .srt and .sub files  http://hackage.haskell.org/package/subtitleParser-0.2 (RubenAstudillo)
01:03:49 <solrize> http://hpaste.org/70704   ok, first i wrote that with "sum" instead of foldl' (+)
01:04:35 <solrize> it stack overflowed with unoptimized ghc and ran in 0.16 sec with ghc -O2
01:04:45 <solrize> strictness analyzer did its thing
01:05:00 <solrize> so i switched it to foldl' and that made the unoptimized version work
01:05:10 <solrize> but it slowed down the -O2 version a fair amount
01:05:14 <solrize> :(
01:05:25 <solrize> like to around 0.25 sec iirc
01:05:45 <solrize> 0.276s
01:07:37 <Ralith> do you need it to be 0.1s faster?
01:10:20 <solrize> erm i'm just saying that the slowdown is not a good thing
01:12:52 <MostAwesomeDude> solrize: -O2 is unsafe like that; does -O1 work alright?
01:17:17 <solrize> MostAwesomeDude, hmm, lemme try
01:18:36 <solrize> hmm -O1 is even faster than -O2 with sum
01:19:15 <solrize> well barely
01:20:35 <solrize> using  logBase 10  is slower than log x / log 10
01:22:20 <shachaf> With -Owhat?
01:23:46 <shachaf> The implementation of logBase x y is just log y / log x, so it's probably typeclass overhead or something.
01:24:07 <shachaf> Er, or something. I don't know.
01:24:16 <shachaf> But I'd expect GHC to turn it into the exact same thing with -O2.
01:24:44 <sipa> log x / log y will have less precision than what is possible
01:25:14 <solrize> what does logBase do differently?
01:25:17 <sipa> so maybe logBase has a more accurate but slower implementation
01:25:18 <solrize> it was slower with both O1 and O2
01:25:37 <shachaf> sipa: Not according to GHC/Float.hs, as far as I can see.
01:25:42 <shachaf> How are you measuring it?
01:25:45 <solrize> @src logBase
01:25:45 <lambdabot> Source not found. Just try something else.
01:25:57 <solrize> just timing it from shell
01:27:04 <sipa> shachaf: ok, it was just a guess
01:27:31 <shachaf> Hmm, yes, I see.
01:28:23 <solrize> logbase x y may be recomputing log x on each call?
01:30:36 <Peaker> why isn't sortOn, groupOn, etc in Data.List, like sortBy, groupBy, etc? Almost always sortOn/groupOn are more useful than sortBy/groupBy/etc
01:31:20 <solrize> @where sortOn
01:31:20 <lambdabot> I know nothing about sorton.
01:31:48 <shachaf> Peaker: I guess there's sortBy (compare `on`).
01:32:06 <Peaker> yeah and: sortBy . comparing
01:32:08 <Peaker> but more imports
01:32:28 <Peaker> groupBy ((==) `on`) has no easier alternative though
01:33:24 <shachaf> solrize, sipa: This looks like typeclass overhead somehow.
01:34:57 <solrize> hmm yeah
01:35:00 <shachaf> Hmm, interesting, maybe not.
01:35:09 <shachaf> Or, rather, it looks like it only comes up in certain contexts.
01:35:28 <shachaf> If I write my own function logb :: Double -> Double -> Double; logb x y = log y / log x, it's fast.
01:35:42 <shachaf> If I put that function in a type class with a Double instance, it's slow.
01:36:04 <shachaf> If I make the same typeclass but use the implementation logb x = let lx = log x in \y -> log y / lx, it's fast.
01:36:23 <LambdaDusk> hi can anyone help me resolving this: https://gist.github.com/58c30cbceca0b84140ba
01:36:54 <shachaf> Maybe #yesod would know.
01:37:22 <solrize> shachaf, adding log10 :: Double->Double   didn't change timing
01:37:57 <LambdaDusk> shachaf: They seem to be asleep
01:37:58 <shachaf> solrize: Right.
01:38:52 * hackagebot hlatex 0.3 - A library to build valid LaTeX files  http://hackage.haskell.org/package/hlatex-0.3 (NicolasPouillard)
01:41:28 <Ralith> shachaf: are you asking why that is?
01:42:01 <shachaf> Ralith: Why what is?
01:42:28 <Ralith> the performance difference
01:42:35 <shachaf> Well, solrize was asking.
01:42:40 <Ralith> ah.
01:42:40 <shachaf> Now I want to know too. :-)
01:42:45 <Ralith> aah.
01:42:46 <Peaker> old-time had a Sunday..Saturday enumeration.. new time doesn't appear to?
01:43:06 <Ralith> my understanding is that it is because functions in typeclasses get passed in the instance to use at runtime.
01:43:07 <Peaker> oh there's CalendarTime with it inside (as Ints, yuck)
01:43:14 <Ralith> so it gets converted into a higher-order function
01:43:35 <Peaker> oh oops I was looking at old-time still
01:43:55 <shachaf> Ralith: Yes, but GHC ought to be able to optimize that.
01:44:02 <shachaf> And I thought it did.
01:44:03 <Ralith> it is!
01:44:08 <Ralith> I think you have to opt-in
01:44:20 <Ralith> I forget the pragma for it, though :/
01:44:32 <shachaf> I think I did opt-in by adding log10 :: Double -> Double.
01:44:35 <Ralith> :P
01:44:42 <shachaf> You're thinking of SPECIALISE, probably, but that's not relevant here, I think.
01:44:53 <Ralith> that sounds right
01:44:54 <Ralith> why not?
01:45:04 <shachaf> Because I added Double -> Double
01:45:08 <shachaf> Which is even more SPECIALISEd.
01:45:21 <Ralith> I am confused
01:45:21 <shachaf> And anyway, as I mentioned, I can make a class myself that reproduces this behavior.
01:45:37 <Ralith> somewhere along the line I lost track of what exactly you are doing
01:45:38 <shachaf> And then when I use my alternate implementation of logb -- inside the class, still -- it becomes fast.
01:46:04 <shachaf> Let me @paste
01:47:05 <solrize> http://hpaste.org/70704 is fast
01:48:20 <Peaker> @hoogle (a,b,c)->c
01:48:20 <lambdabot> Data.Typeable typeOf3 :: Typeable3 t => t a b c -> TypeRep
01:48:20 <lambdabot> Data.Typeable typeOf2Default :: (Typeable3 t, Typeable a) => t a b c -> TypeRep
01:48:53 <hpaste> shachaf annotated ‚Äúlog10 (1e6!)‚Äù with ‚Äúlog10 (1e6!) (hmm...)‚Äù at http://hpaste.org/70704#a70706
01:49:31 <shachaf> Ralith: See?
01:50:00 <shachaf> Oh, I missed one.
01:51:14 <hpaste> shachaf annotated ‚Äúlog10 (1e6!)‚Äù with ‚Äúlog10 (1e6!) (missed one)‚Äù at http://hpaste.org/70704#a70707
01:52:06 <shachaf> So it looks like some sort of interaction between specialization and inlining or something.
01:53:32 <Ralith> shachaf: ah, so you expect that ghc should partially evaluate the definition of log10?
01:54:13 <shachaf> Ralith: I would *hope* that the type class definition would turn into the same thing as the other definition when the type is explicitly specified like that.
01:55:05 <Ralith> it would be useful!
01:55:19 <Ralith> having tried to implement that kind of transform in the past, though, it's no surprise if it doesn't Just Work
01:55:55 <shachaf> Maybe it's a monomorphism-restriction style thing?
01:56:12 <shachaf> I mean, not the actual MR but something similar with "log 10" being too polymorphic.
01:56:31 <shachaf> I guess if that's all it was, it would apply just as much to the let lx = ... case.
01:56:54 <shachaf> solrize: You should ask on stackoverflow.com!
01:59:07 <solrize> shachaf, i don't have an account there, it's annoying that they make you create one since it's not needed on mathoverflow or stackexchange
01:59:20 <Peaker> @tell conal Why does total-map lack a Monoid instance (the one that functions have)?
01:59:21 <lambdabot> Consider it noted.
01:59:33 <shachaf> solrize: What? Are you sure those work differently?
02:00:00 <shachaf> As far as I know it's all OpenID.
02:00:47 <solrize> yeah i've posted to mathoverflow
02:01:00 <solrize> i don't think i've posted to stackexchange but it says on the page that you don't need an account
02:01:20 <shachaf> Oh, I see.
02:01:23 <solrize> http://cstheory.stackexchange.com/
02:01:30 <solrize> "It's 100% free, no registration required."
02:01:31 <shachaf> You can just use any OpenID account.
02:03:07 <shachaf> I can post it for you if you want. :-)
02:03:20 <osfameron> even gmail?  gmail's alleged openid identity never works for me in the real world
02:03:30 <shachaf> osfameron: I use it with Google's OpenID.
02:03:35 <osfameron> cool
02:10:23 <shachaf> solrize: Should I post it?
02:11:00 <solrize> on stackoverflow?  hmm, dunno if it's worth it
02:11:12 <shachaf> Well, I want to know what's going on. :-)
02:11:13 <solrize> but if you do want to post something i'd be interested in that memoization test
02:11:29 <shachaf> In what test?
02:11:39 <solrize> shachaf, if you want to post it, go ahead
02:11:40 <shachaf> I'm curious about this thing in particular. :-)
02:12:04 <solrize> http://hpaste.org/70413
02:12:10 <solrize> scroll down to last annotation
02:12:36 <solrize> i use hpaste for source control since i don't have a github account either :)
02:12:52 <shachaf> You don't need a GitHub account to use git.
02:13:01 <shachaf> It's a little-known fact that git has nothing to do with GitHub.
02:13:15 <solrize> heh
02:13:22 <shachaf> That @paste is much longer. :-(
02:13:50 <solrize> what i want to know is why STArray2 is 2x slower than STArray
02:14:03 <osfameron> another little known fact - github accounts are free
02:14:08 <solrize> only thing i could think of is comparison of bignums to 0 slowing down as the numbers get bigger
02:14:16 <shachaf> osfameron: GitHub accounts are only free if your time is worthless.
02:14:18 <solrize> but i wrote similar program in c++ and didn't see the slowdown
02:14:35 <solrize> i don't like any website with "social" in it
02:15:26 <osfameron> shachaf: hmm? more accurately, they're only free if your code is non-private.  But managing a github repo takes barely any time for me
02:15:47 <shachaf> Yes, but making an account takes time.
02:15:53 <shachaf> So does complaining on IRC, of course.
02:16:02 <osfameron> heh, ok
02:17:34 <solrize> http://hpaste.org/70506 is last annotation
02:26:15 <mm_freak> does anyone know why the STG language by SPJ from 1992 is so complicated?  for example in a lambda form the free variables are mentioned explicitly‚Ä¶  as far as i see this isn't necessary
02:28:00 <shachaf> Isn't that the point?
02:28:30 <mm_freak> what?
02:28:56 <mm_freak> i mean i can extract the free variables from the expression‚Ä¶  it doesn't seem necessary to mention them in the lambda form
02:33:37 <shachaf> I think the idea is to make all the arguments to the closure explicit.
02:35:38 <osfameron> I once wrote a preprocessor to allow closures in VBScript ;-)  you had to mention which variables you wanted to close over explicitly (made it *much* easier to implement)
02:36:21 <shachaf> Yes, I think the idea is that it's a simpler language.
02:36:33 <shachaf> I mean, it's just an intermediate language, and GHC already knows which variables are free anyway.
02:36:38 <shachaf> Why do the work twice?
02:36:51 <shachaf> (Well, not GHC.)
02:41:40 <mm_freak> so there is no fundamental reason
02:42:16 <mm_freak> i'll go without the redundancy, because when compiling there will be a scope anyway
02:42:37 <shachaf> Well, it *is* a lambda that takes both sets of arguments.
02:42:59 <Peaker> I implemented a pretty standard hash table with a hard-coded size (large enough to have no collisions) on top of a file, and I'm getting horrible performance (10000 set-keys take about 1 sec!
02:43:21 <shachaf> You can think of it the other way around -- there is no scope, and instead of writing (\x -> ...x...) x, they write (\{x} -> ...x...), where {x} means it's taken implicitly.
02:43:54 * hackagebot keyvaluehash 0.2.0.0 - Pure Haskell key/value store implementation  http://hackage.haskell.org/package/keyvaluehash-0.2.0.0 (EyalLotem)
02:44:44 <Peaker> I guess I could try to mmap to avoid lots and lots of system calls..
02:45:02 <shachaf> Peaker: What part is slow?
02:46:14 <Peaker> shachaf, Haven't profiled yet, but 0.4 system time, 0.6 user time, both sound real bad :)
02:46:17 <shachaf> Do you have a simple thing to benchmark it?
02:46:23 <Peaker> Yeah, I do
02:46:36 <shachaf> Is it uploaded?
02:46:40 <Peaker> just a tight loop of set calls
02:46:41 <Peaker> yeah
02:46:53 <shachaf> example.hs?
02:47:30 <Peaker> yeah
02:48:05 <shachaf> Wait, what did I just do?
02:48:10 <shachaf> $ cabal build
02:48:13 <shachaf> ...
02:48:18 <shachaf> Registering keyvaluehash-0.2.0.0...
02:48:20 <shachaf> :-(
02:48:25 <Peaker> ghc-pkg unregister?
02:48:29 <shachaf> I'm pretty sure "build" isn't supposed to do that.
02:48:42 <Enigmagic> cabal build always says that and that's just the local build registration
02:48:54 <Enigmagic> = misleading
02:49:05 <Peaker> oh, I didn't do anything special w.r.t cabal
02:49:14 <Peaker> except shunning the PVP maybe :)
02:49:17 <shachaf> Enigmagic: Oh, so there's nothing in ~/.ghc?
02:49:22 <Enigmagic> shachaf: nope
02:49:34 <shachaf> OK.
02:49:39 <shachaf> Misleading indeed.
02:49:44 <Enigmagic> shachaf: it says that when it produces the package reigistration scripts in ./dist or ./build
02:52:55 <shachaf> Peaker: It's doing >700000 system calls for example.hs
02:53:17 <Peaker> shachaf, wow, ~700 system calls for each writeKey?
02:53:25 <Peaker> oops, ~70?
02:53:45 <shachaf> About 40% of them are fstat calls.
02:54:06 <Peaker> I'm guessing hSeek is doing all that
02:54:12 <shachaf> Another 40% are seeks.
02:55:12 <shachaf> Maybe just using something like pread() would help?
02:56:11 <shachaf> I would be worried about mmap() because I expect it won't play nicely with GHC's threading.
02:56:35 <ion> In what way?
02:57:43 <shachaf> ion: Well, trying to read unmapped memory would cause the OS thread to block.
02:58:05 <ion> Ah, good point.
02:58:13 <shachaf> Maybe if you always did it through the FFI or something like that it would be OK, but otherwise I don't see how it could work well.
02:58:33 <solrize> forkOS ?
02:58:38 <solrize> or use AIO somehow?
02:59:00 <solrize> aio may be better than mmap
02:59:04 <shachaf> Sure, but you lose the benefit of either mmap or GHC's threads at that point.
02:59:06 <solrize> i dunno of a wrapper for it
02:59:47 <shachaf> AIO in Linux is also severely restricted.
02:59:58 <Peaker> shachaf, what did you say earlier? Missed due to netsplit
02:59:59 <shachaf> Last time I looked it was basically not useful unless you were using O_DIRECT.
03:00:11 <shachaf> Peaker: What was the last thing you saw?
03:00:29 <Peaker> <shachaf> Maybe just using something like pread() would help?
03:00:51 <Peaker> I guess I could switch to file descriptors and preads, to improve significantly
03:00:56 <Peaker> but will file descriptors work on Windows?
03:01:03 <shachaf> 02:55 <shachaf> I would be worried about mmap() because I expect it won't play nicely with GHC's threading.
03:01:58 <shachaf> Not much else until the netsplit ended.
03:02:00 <Peaker> well, page faults block even when they are from swap/virtual memory
03:02:09 <shachaf> Right.
03:02:20 <shachaf> Windows has its own way of doing I/O.
03:02:27 <shachaf> I don't know much about it and about how GHC interacts with it.
03:02:47 <Peaker> pread is worth a try, are there bindings?
03:03:09 <shachaf> Yes, System.Posix.IO.ByteString
03:03:14 <shachaf> But they use Fd, not Handle.
03:03:23 <shachaf> Not sure if there are Handle bindings.
03:04:05 <Peaker> http://hackage.haskell.org/packages/archive/unix/2.5.1.1/doc/html/System-Posix-IO-ByteString.html#g:4 -- I don't see "pread" in there?
03:04:24 <Peaker> no offset argument, that is
03:04:38 <shachaf> Hmm, odd.
03:04:49 <shachaf> Oh, it's in unix-bytestring.
03:04:59 <shachaf> http://hackage.haskell.org/packages/archive/unix-bytestring/latest/doc/html/src/System-Posix-IO-ByteString.html
03:06:22 <shachaf> ...Which apparently conflicts on module name with "unix". :-(
03:07:24 <Peaker> I doubt unix-bytestring is available in Windows, though?
03:08:19 <shachaf> So do I. :-)
03:08:45 <Peaker> well, I can live with horrible key/value performance for the next... months probably :)
03:09:00 <Peaker> At least it should avoid the dependency hell involving BerkeleyDB
03:09:06 <shachaf> Looks like the normal ReadFile() function does it in Windows.
03:09:48 <shachaf> Where are all the stat()s actually coming from, though?
03:10:08 <Peaker> I am guessing the absolute seek uses stat first to see it's not out of range or such
03:10:36 <shachaf> I can't find it in the GHC/* code.
03:10:40 <shachaf> Maybe I missed it.
03:10:43 <Peaker> I do a getFileSize when appending a value, but I don't really append many values in that benchmark
03:11:07 <shachaf> Anyway that would be silly because lseek() reports that anyway.
03:11:16 <shachaf> And also it sounds like a race condition.
03:11:53 <Peaker> Can add a print before and after the seek to see if it is indeed it
03:12:11 <Peaker> Maybe bytestring uses a stat to see if hGet should fail?
03:12:42 <shachaf> Hmm, it's doing multiple seeks and stats per read.
03:13:04 <shachaf> 12202 fstat(4, {st_mode=S_IFREG|0644, st_size=162, ...}) = 0; 12202 fstat(4, {st_mode=S_IFREG|0644, st_size=162, ...}) = 0; 12202 lseek(4, -5, SEEK_CUR)            = 157; 12202 lseek(4, 136, SEEK_SET)           = 136; 12202 fstat(3, {st_mode=S_IFREG|0644, st_size=131072, ...}) = 0; 12202 fstat(3, {st_mode=S_IFREG|0644, st_size=131072, ...}) = 0; 12202 lseek(3, -8088, SEEK_CUR)         = 110096; 12202 lseek(3, 110128, SEEK_SET)        = 110128; 12202
03:13:17 <shachaf> Seems kind of excessive. :-)
03:14:11 <shachaf> Hmm, wait, 3 /= 4.
03:14:20 <Peaker> who's doing the SEEK_CUR's?
03:14:23 <Peaker> I only do absolute seeks
03:15:00 <shachaf> Oh, 3 is keys, 4 is values?
03:15:15 <Peaker> yeah
03:15:26 * shachaf hasn't actually looked at the code.
03:15:33 <Peaker> or rather, 3 is statically-sized hash table, 4 is key/value-pair growing file
03:16:25 <Peaker> 3 is an array mapping hashes to ptrs into the values file.  the values file has dynamically-sized values appended to it. Each value has a header with (next value ptr [for collisions], alloc size, key size, value size, <dynamic key>, <dynamic value>)
03:17:09 <Peaker> alloc size   starts as key_size+value_size but in case of in-place value updates, it can be larger than the sum
03:17:51 <Peaker> I never free the space of deleted/stale values (yet), can be garbage collected later by regenerating the hash table
03:18:17 * shachaf thinks writing a key-value store is a serious rat-hole to go into. :-)
03:18:55 <shachaf> You can spend years on that (I did!).
03:19:31 * mauke used sqlite
03:20:03 <Peaker> shachaf, where is the one you wrote?
03:20:11 <Peaker> shachaf, I spent a few hours examining all that was on hackage
03:20:15 <shachaf> Peaker: It's not in Haskell. :-)
03:20:22 <Peaker> oh, what did you write it in?
03:20:48 <shachaf> I mean that I worked at a company that was writing it. It was/is a bunch of people working on it.
03:20:59 <shachaf> Of course it was rather more complicated than what you're aiming for here. :-)
03:21:35 <Peaker> shachaf, ah.. competitor to redis or such?
03:21:55 <Peaker> shachaf, I'm assuming the complications were from extra features beyond the basic (readKey, writeKey, deleteKey) API?
03:22:14 <Peaker> (implementing that API well seems like it would be some work, but not that much work.. :)
03:22:25 <shachaf> Peaker: rethinkdb.com
03:23:43 <Peaker> shachaf, ah, looks good
03:39:59 <Penetrator> @pl h xs = sum (take 6 xs) : h (drop 6 xs)
03:39:59 <lambdabot> h = fix (ap ((:) . sum . take 6) . (. drop 6))
03:40:27 <Penetrator> @pl h n xs  = sum (take n xs) : h n (drop n xs)
03:40:27 <lambdabot> h = fix (ap (ap . (((:) . sum) .) . take) . (`ap` drop) . ((.) .))
03:41:59 <shachaf> @ty splitAt
03:42:00 <lambdabot> forall a. Int -> [a] -> ([a], [a])
03:44:02 * hackagebot curry-base 0.2.9 - Functions for manipulating Curry programs  http://hackage.haskell.org/package/curry-base-0.2.9 (BjoernPeemoeller)
03:54:03 * hackagebot OpenCL 1.0.3.1 - Haskell high-level wrapper for OpenCL  http://hackage.haskell.org/package/OpenCL-1.0.3.1 (LuisCabellos)
04:04:03 * hackagebot language-puppet 0.1.4 - Tools to parse and evaluate the Puppet DSL.  http://hackage.haskell.org/package/language-puppet-0.1.4 (SimonMarechal)
04:09:05 * hackagebot snaplet-i18n 0.0.2.1 - snaplet-i18n  http://hackage.haskell.org/package/snaplet-i18n-0.0.2.1 (HaishengWu)
04:18:26 <TheRedMood> Hey
04:18:40 <TheRedMood> Um, i found something a bit odd about the tryhaskell.org site
04:18:49 <TheRedMood> phew
04:18:52 <TheRedMood> It is fixed now :D
04:18:59 <shachaf> Glad to be of service.
04:19:16 <TheRedMood> It was giving totaly wrong results
04:19:47 <TheRedMood> Trying haskell for the first time
04:23:30 <TheRedMood> wow
04:23:52 <TheRedMood> Really liking it so far. The let x = 4 in x * x
04:24:01 <TheRedMood> is something i've nevere seen before :o
04:26:36 <Franciman> hi all
04:26:50 <Franciman> guys I am trying to use uu-parselib
04:26:52 <Botje> never played with lisp or scheme?
04:26:55 <Botje> you're in for a ride :)
04:27:20 <Franciman> and I've read that when given alternatives, the parser doesn't try all
04:27:29 <TheRedMood> Ohh
04:27:33 <TheRedMood> I've played with lisp
04:27:37 <TheRedMood> but after a while
04:27:40 <Franciman> does this mean, that it takes the decision in O(1) ?
04:27:42 <TheRedMood> ((((((((this))))))))))
04:27:45 <Franciman> lol
04:27:49 <merijn> This is the part where we blow TheRedMood's mind with one line fibonacci and prima functions, right? :p
04:28:04 <TheRedMood> became to hard for me
04:28:18 <TheRedMood> Well if you could give me a book, which goes from basic matematics to really hard
04:28:18 <merijn> > let ones = 1 : ones
04:28:20 <lambdabot>   not an expression: `let ones = 1 : ones'
04:28:25 <merijn> > let ones = 1 : ones in ones
04:28:27 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
04:28:36 <TheRedMood> Then i would really be glad
04:28:40 <TheRedMood> because i really need to study some of that
04:28:46 <TheRedMood> :)
04:29:16 <merijn> Nah, the fibonacci and prime examples are not that interesting and a bit useless, but everyone seems to like them
04:29:52 <TheRedMood> No, I just want to know some more mathematics
04:29:57 <TheRedMood> because i will need it later
04:30:14 <TheRedMood> Also if I wanted to work with AI what areas should i start to study?
04:32:38 <TheRedMood> Im going to combine learning haskell
04:32:42 <TheRedMood> with installing xmonad
04:32:51 <TheRedMood> and try out stuff in that :D
04:33:57 <solrize> TheRedMood, are you reading LYAH?
04:34:35 <solrize> @lyah
04:34:35 <lambdabot> Unknown command, try @list
04:34:38 <solrize> @where lyah
04:34:38 <lambdabot> http://www.learnyouahaskell.com/
04:34:51 <solrize> @where sicp
04:34:51 <lambdabot> The Wizard book : "Structure and Interpretation of Computer Programs" at <http://mitpress.mit.edu/sicp/> by Hal Abelson,Gerald Jay Sussman with Julie Sussman, videos at <http://swiss.csail.mit.edu/
04:34:51 <lambdabot> classes/6.001/abelson-sussman-lectures/>
04:35:33 <TheRedMood> solrize: What is thata?
04:35:45 <TheRedMood> No
04:35:49 <TheRedMood> I have not
04:35:57 <solrize> that's a good intro haskell book
04:35:57 <TheRedMood> Is it a good read?
04:36:06 <solrize> yes
04:36:08 <TheRedMood> Thanks i will look into that :)
04:36:54 <TheRedMood> WOW
04:37:01 <TheRedMood> I LIKE THE COVER OF THAT BOOK <3
04:39:04 * hackagebot curry-frontend 0.2.12 - Compile the functional logic language Curry to several  intermediate formats  http://hackage.haskell.org/package/curry-frontend-0.2.12 (BjoernPeemoeller)
04:40:33 <TheRedMood> sa
04:42:44 <solrize> @src Cont
04:42:44 <lambdabot> newtype Cont r a = Cont { runCont :: (a -> r) -> r }
04:43:15 <lillis> Hi. Complete Haskell noob here. I'm going through implementing some of the basic functions myself (filter, map, sum etc). I'm trying to do a take implementation but I'm missing something. Pointers would be appreciated. http://hpaste.org/70710
04:43:42 <mauke> lillis: spacing doesn't affect precedence
04:43:43 <solrize> say (n-1) instead of n-1
04:43:50 <mauke> 1+2 * 3 is still 7
04:44:07 <solrize> take' n  binds more tightly than the -1
04:44:13 <solrize> lillis
04:44:27 <lillis> I was sure I tried with parentheses, but apparently I didnt because that helped ofc :)
04:44:39 <Axman6> which means you've actually written (take n) - (1 xs)
04:44:52 <hpaste> solrize annotated ‚Äúcustom take‚Äù with ‚Äúcustom take (annotation)‚Äù at http://hpaste.org/70710#a70711
04:45:04 <JerMenKoO> hello
04:45:19 <lillis> mauke, solrize, Axman6: thanks!
04:45:31 <Axman6> no worries
04:45:33 <JerMenKoO> could anyone help me? I'm trying to sum a tuple with 3 Integers (2, 3, 5) for example
04:45:45 <solrize> i think it's 10
04:45:50 <lillis> :))
04:45:58 <Axman6> JerMenKoO: what have you tried?
04:46:05 <JerMenKoO> solrize: hah
04:48:24 <Axman6> JerMenKoO: ?
04:48:31 <JerMenKoO> sec, got a idea
04:53:22 <Nereid> JerMenKoO: if I gave you (x, y, z) what would you do?
04:58:55 <JerMenKoO> Axman6
04:59:02 <Axman6> yes?
04:59:22 <sipa> 13:52:52 -!- JerMenKoO [~pi@pat-ip-195-91-111-193.flarion.as5628.telecom.sk] has quit [Ping timeout: 248 seconds]
04:59:25 <sipa> 13:53:01 < Nereid> JerMenKoO: if I gave you (x, y, z) what would you do?
04:59:29 <JerMenKoO> st = foldl (+) 0 . map(\(x, y, z) -> x +y + z)
04:59:33 <JerMenKoO> what do you think?
05:00:03 <Axman6> well, it does something. does it do what you want? it doesn't do what you originally asked for...
05:00:13 <JerMenKoO> sum of tuple
05:00:19 <JerMenKoO> well this way it has to be in a list
05:00:19 <Axman6> what
05:00:24 <Axman6> what's the fold for?
05:00:35 <brisingr> @type foldl (+) 0 . map(\(x, y, z) -> x+y+z)
05:00:36 <sipa> this will sum the values in a list of 3-tuples
05:00:37 <lambdabot> forall a. (Num a) => [(a, a, a)] -> a
05:00:55 <Axman6> you never mentioned any lists
05:01:03 <sipa> > (foldl (+) 0 . map(\(x, y, z) -> x +y + z)) [(1,2,3),(4,5,6)]
05:01:03 <mauke> :t sum . map (\(x, y, z) -> x + y + z)
05:01:05 <lambdabot> forall a. (Num a) => [(a, a, a)] -> a
05:01:06 <lambdabot>   21
05:01:06 <Axman6> so I'm confused why you're using foldl and map
05:07:04 <JerMenKoO> Axman6: it "works"
05:07:07 <lillis> JerMenKoO: is this ONLY for triples, or tuples of any size?
05:07:15 <JerMenKoO> meant for triples
05:07:31 <lillis> triplesum (a,b,c) = a+b+c
05:07:34 <Axman6> JerMenKoO: does it actually do what you want? it seems to do something you didn't specify
05:07:41 <lillis> shouldn't that work?
05:07:50 <Axman6> yes
05:07:59 <JerMenKoO> --'
05:08:03 <JerMenKoO> I am ashamed
05:08:19 <lillis> I just missed a pair of parentheses and asked for help here, so I know the feeling ;)
05:08:25 <Axman6> JerMenKoO: we can help you heaps, if only you give us some information
05:08:48 <lillis> I have no idea how one would create a function that would sum any n-tuple though, as i dont really know much about handling tuples
05:09:00 <lillis> or convert a tuple into a list if that is even possible (or useful)
05:09:08 <Axman6> you can't without a typeclass
05:09:12 <mauke> lillis: there is no generic tuple type
05:09:21 <brisingr> > unsafeCoerce (1, 2, 3) :: [Int]
05:09:23 <lambdabot>   Not in scope: `unsafeCoerce'
05:09:23 <lillis> indeed, that's why i have no idea how to do it :)
05:09:25 <mauke> (a,b) and (a,b,c) are unrelated types
05:09:27 <Axman6> (,) is completely separate from (,,)
05:10:10 <lillis> but i have a feeling that tuples are treated more like containers of random data (like an ad-hoc class for a object oriented programmer)
05:10:13 <lillis> than just "immutable list"
05:10:16 <lillis> since all lists are immutable..
05:10:23 <Ayatollaah> @type foldl (\(x,y,z) a -> x + y + z + a) 0
05:10:26 <lambdabot>     Occurs check: cannot construct the infinite type: b = (b, b, b)
05:10:26 <lambdabot>       Expected type: (b, b, b)
05:10:26 <lambdabot>       Inferred type: b
05:10:42 <Ayatollaah> Hmm
05:11:06 <Axman6> class Num b => Sumable a b | a -> b where summ :: a -> b; instance Num b => Summable (a,a,a) a where summ (a,b,c0 = a + b + c -- horrible >_>
05:11:07 <ilya_s> Ayatollaah, change order of parameters in lambda
05:11:14 <mauke> lillis: yes, tuples are records
05:11:17 <Ayatollaah> Ohhh
05:11:20 <Ayatollaah> foldr
05:11:28 <Ayatollaah> @type foldr (\(x,y,z) a -> x + y + z + a) 0
05:11:30 <lambdabot> forall b. (Num b) => [(b, b, b)] -> b
05:11:33 <lillis> mauke: not really meant to be recursed over right?
05:11:33 <Ayatollaah> Schweet
05:11:39 <mauke> lillis: right
05:11:44 <lillis> my only brush with tuples before is in python where they can just be for'd
05:11:49 <mauke> every tuple has a fixed size and no recursive structure
05:11:53 <lillis> i started looking at haskell yesterday so i feel pretty lost
05:12:04 <lillis> but it's very interesting and thoughtbending for an OO programmer
05:12:16 <ilya_s> Ayatollaah, or foldr, right :)
05:12:19 <Ayatollaah> I started looking 2 years back and I'm still lost.
05:12:21 <Axman6> don't worry, you can recover from OOP
05:12:29 <lillis> Ayatollaah: sounds comforting
05:12:29 <Ayatollaah> ilya_s, I never know which is which
05:12:40 <lillis> Axman6: So I hope... ;)
05:12:59 <Ayatollaah> I should add that I'm about as stupid as your average anencephalic highly differentiated cancerous growth though
05:13:04 <ilya_s> Ayatollaah, it always confuses me, why foldl and foldr have different orders of arguments
05:13:15 <Ayatollaah> ilya_s, because they fold in the other direction
05:13:16 <lillis> the reason i started looking at haskell was the fact that the functionally inspired (...) parts of C#, e.g. linq, is the best parts of it
05:13:26 <lillis> so i figured there was more goodies down the rabbit hole
05:13:31 <Ayatollaah> They actually don'ty have a different order, they just fold in the other direction
05:13:48 <Ayatollaah> But I never really know which is which, is r or l the tail recursive one?
05:13:55 <Axman6> l
05:13:59 <ilya_s> foldr
05:14:03 <Axman6> no
05:14:05 <mauke> foldl
05:14:06 <Axman6> foldl
05:14:10 <Ayatollaah> /popcorn
05:14:11 <ilya_s> yes, no, sorry :)
05:14:18 <lillis> i like you guys already
05:14:19 <Axman6> > foldl f x [a,b,c]
05:14:20 <lillis> back to work o/
05:14:20 <lambdabot>   f (f (f x a) b) c
05:14:23 <Axman6> > foldr f x [a,b,c]
05:14:24 <lambdabot>   f a (f b (f c x))
05:14:27 <Ayatollaah> No, don't let it be so easy, fight to the death, the one that survives is right.
05:14:57 <Ayatollaah> Oh, it even shows you the reduction?
05:15:05 <mauke> no, the result
05:15:05 <Ayatollaah> CAn you say how many reduction steps you want?
05:15:29 <Axman6> eh?
05:21:35 <mel-> hi
05:22:09 <brisingr> hi, mel-
05:28:59 <Penetrator> @pl s xs = m xs id
05:28:59 <lambdabot> s = flip m id
05:36:50 <JerMenKoO> hello
05:37:08 <JerMenKoO> is there any way how to use more than 1 guard in list comprehension?
05:37:45 <fmap> > [x | x <- [1..10], x > 2, x < 8]
05:37:46 <lambdabot>   [3,4,5,6,7]
05:38:44 <hc>  > do {x <- [1..10]; True <- (x > 2); True <- (x < 8); return x}
05:39:01 <hc> > do {x <- [1..10]; True <- (x > 2); True <- (x < 8); return x}
05:39:02 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
05:39:02 <lambdabot>         against inferred type ...
05:40:02 <fmap> > do {x <- [1..10]; guard (x > 2); guard (x < 8); return x}
05:40:04 <lambdabot>   [3,4,5,6,7]
05:40:24 <hc> > do {x <- [1..10]; True <- return (x > 2); True <- return (x < 8); return x}
05:40:26 <lambdabot>   [3,4,5,6,7]
05:40:30 <Ayatollaah> fmap, and with a disjunctive logic?
05:41:24 <Ayatollaah> [x | x <- [1..10], x < 2 || x > 8]
05:41:31 <Ayatollaah> > [x | x <- [1..10], x < 2 || x > 8]
05:41:33 <lambdabot>   [1,9,10]
05:41:34 <Ayatollaah> Meep meep
05:42:41 <mel-> > 1 + 2
05:42:42 <lambdabot>   3
05:42:46 <mel-> hihi
05:42:53 * mel- smiles
05:43:19 <JerMenKoO> oh
05:55:22 <flixil> Has anyone here used haskell DSL (like atom) to program an arm uC?
05:56:30 <ciaranm> which container do i want to store a rather large adjacency matrix which never changes once it's built, and where i want to do intersections on entire rows at a time, and where i'll be accessing the matrix a few trillion times?
05:57:07 <opqdonut> array of intsets?
05:57:14 <opqdonut> as a first guess
05:57:19 <ciaranm> sloooooooooooooooooow
05:57:47 <ciaranm> afaics IntSet is sort of expecting sparse data
05:58:29 <opqdonut> not really
05:58:59 <ciaranm> well, it's using trees, which is a lot of overhead
05:59:02 <ciaranm> i want a big bunch of bits
05:59:10 <opqdonut> right
05:59:40 <opqdonut> how about some sort of unpacked array/vector then?
05:59:54 <ciaranm> probably
06:00:10 <opqdonut> if the data is not that sparse, O(size of domain) intersection isn't that bad
06:00:36 <ciaranm> O() isn't the issue. speed is.
06:01:05 <ciaranm> the overall problem is 3^(n/3) anyway
06:01:52 <ciaranm> n isn't going to be over a thousand, so it's more about fitting the whole thing in cache than it is about scaling
06:01:56 <jaxtr> ahh it's a wonderful day!
06:12:19 <bgamari> flixil: I haven't but this is something that's I've been interested in trying
06:12:50 <bgamari> flixil: The problem is you effectively have to reimplement/wrap an abstraction layer for whatever hardware you are one
06:12:53 <bgamari> on*
06:13:01 <Tomsik> 3^300 sounds like a lot
06:15:10 <Egbert9e9> is there a way to use ghc as i use matlab? easy matrix operations etc
06:15:28 <vraid> Tomsik: that depends on the O factor
06:16:08 <Tomsik> I guess n is size of the input. Having input this big is a problem.
06:16:11 <flixil> bgamari: For scheme I found a project called armpit which looks promising, but i haven't found anything similar in haskell
06:16:50 <ciaranm> Tomsik: well, the good news is most instances aren't actually that difficult
06:17:04 <ciaranm> the interesting question is where the difficult instances are
06:17:24 <Tomsik> What are you doing? Optimizing circuits?
06:17:42 <ciaranm> graph stuff, but it can translate to some kind of SAT
06:18:05 <Tomsik> Well, I'd bet my chances on an preexisting solver if it's possible
06:18:07 <ciaranm> and the hard instances under the graph algorithms mostly remain hard under reduction to SAT
06:18:22 <ciaranm> naah, the dedicated algorithms are a factor of ten faster than SAT solvers
06:18:40 <nand`> quickCheck is awesome for disproving things (as long as it fails. if it passes all checks, you're in for more work)
06:18:53 <Tomsik> Well, if you're using anything other than C your factor of ten might just as well fly away
06:19:23 <ciaranm> you might be surprised
06:19:31 <Tomsik> Probably :)
06:20:00 <ciaranm> anyway, the factor of ten isn't really the point. the point is finding stuff that looks hard that becomes easy when reduced to something else.
06:20:08 <ciaranm> or the other way around
06:20:13 <Tomsik> If it's sparse, perhaps you could use some sort of hash maps
06:20:21 <ciaranm> sparse is nearly always easy
06:20:48 <Axman6> ciaranm: you might want to check out Repa. no guarantees it can do what you're after though
06:21:02 <Tomsik> There's this static two-layer hash scheme which is linear and collision-less
06:21:06 <Axman6> it might give you automatic parallelisation if you're doing the right sort of workloads though
06:21:07 <ciaranm> ryanair european pilots' association?
06:21:24 <ciaranm> i'm saving parallelisation for my PhD :P
06:24:34 <flixil> bgamari: did you took a look at atom package?
06:29:05 <morel> preflex: seen bgamari
06:29:06 <preflex>  bgamari was last seen on #haskell 16 minutes and 12 seconds ago, saying: on*
06:29:22 <morel> -.- what was bgamari's question? oO
06:33:52 <flixil> morel: It was my question actually, asking if someone tried haskell on an arm uC
06:34:08 * hackagebot CMQ 0.0.12 - cwmwl udp message queue  http://hackage.haskell.org/package/CMQ-0.0.12 (JoergFritsch)
06:37:43 <Taneb> There seems to be quite some rivalry between pipes and conduit
06:40:01 <Axman6> i wish there wasn't, I'm getting annoyed with all the "conduit is wrong and I can prove it, except I don't care about performance, one of the main goals of conduit"
06:40:33 <Taneb> I've never used either, so I'm not going to say much more than commenting on the existence of a rivalry
06:40:46 <Taneb> Contrasting this, Snap, Yesod, and Happstack all seem pretty cool with eachother
06:40:49 <weexplat> it seems like a friendly rivalry from a technical perspective, and to some extent a social one, but very bitter from an intellectual one
06:43:09 <sipa> Tomsik: cuckoo hashing?
06:43:20 <weexplat> and i have to say snoyman is being really cool about incorporating pipes ideas when they are proven to work well
06:44:08 * hackagebot KiCS 0.9.3 - A compiler from Curry to Haskell  http://hackage.haskell.org/package/KiCS-0.9.3 (BjoernPeemoeller)
06:44:22 <weexplat> including reworking the entire core of the library to a more pipes-inspired approach
06:45:06 <Tomsik> sipa, no, something like the thing done here: http://www.cs.cmu.edu/afs/cs/academic/class/15451-s07/www/lecture_notes/lect0215.pdf
06:45:21 <Tomsik> I'm not sure what its name is, but it's some three-names thing
06:46:04 <Axman6> weexplat: yeah, that is a good thing. I just that the pipes author wasn't soÖ such a dick about it I guess. that's always how his blog posts read to me
06:46:08 <weexplat> so i think eventually pipes will probably fall back into obscurity, but conduits will meanwhile have been remade into a highly-optimized version of wherever pipes ended up
06:47:35 <Axman6> yep, agreed
06:51:50 <Tomsik> Couldn't they just bro-down and crush some code together? :P
06:54:02 <Axman6> hmm, is you wanted a key value store, which stored things in key order (so it can be used a queue to pull things with the smallest key off the front frequently), and new keys were almost always the greatest key, what would you use?
06:55:04 <Axman6> I'm thinking of something that orders messages by time and pulls them out in time order. but you might not be able to guarantee that times come into say the thread holding this structure in order
06:56:10 <weexplat> Axman6: does it need to be real-time efficient?  what is the queue size typically?  are there far-future outliers or only 'earlies'?
06:57:28 <Axman6> well, I'm just thinking about how one might do it, I don't have a real world example, just curious. imagine you're log gin events from many threads, so values that come into the logging thread come in, the time values should be fairly close
06:57:38 <Axman6> logging*
06:57:52 <Axman6> english fail
06:58:25 <weexplat> also: if i were thinking straight i'd use a generic priority queue for v0.5 and see if it's a bottleneck before i go all algorithmics-crazy (although i like algorithm and data structure design so i don't always think straight)
06:58:46 <Axman6> me too =)
06:59:06 <Axman6> I was thinking something like a finger tree might be good, if I can rememner what they are correctly
06:59:16 <Axman6> Data.Sequence is a finger tree right?
06:59:58 <weexplat> iirc it is, but there's already a finger priority queue
07:00:07 <weexplat> on hackage
07:00:29 <weexplat> actually i think there were 2
07:01:13 <weexplat> a splay tree might also be good for this
07:01:56 <weexplat> depending if you pull from the queue in chunks
07:02:16 <Axman6> probably would be one thing at a time
07:02:55 <weexplat> then i'd say the ideal structure asymptotically might be something like a finger tree with an extra splay finger in the middle
07:04:15 <weexplat> you would use that finger for inserts and the ordinary left finger for min-queries
07:06:30 <weexplat> but it would probably be too complex to perform well in practice unless you were maybe logging individual memory accesses in a multicore processor simulation or some other ridiculously dense stream
07:10:28 <Tomsik> If almost always messages are in the right order, why not insert sort?
07:11:10 <Tomsik> or perhaps a skip-list
07:11:34 <Axman6> Tomsik: well, the inserts and removals are happening at opposite ends of the queue
07:11:52 <Tomsik> mm, right.
07:12:18 <Axman6> and it'd be nice to have at most O(log n) for both insert and remove-min
07:12:45 <Tomsik> well, there are plenty of heap kinds
07:13:56 <weexplat> O(log n) is easy, any real heap will do it and many will do it worst-case/realtime
07:14:58 <Axman6> a doubly linked list would be ideal actually, but not in Haskell
07:16:10 <weexplat> the hope is to beat it in terms of processing n items (insert and delete) in O(n + some measure of how much they get out of order)
07:19:40 <weexplat> a doubly-linked list might do well enough in practice but i don't think it gets very nice worst-case guarantees without really tight constraints on the mostly-in-orderness
07:22:00 * ski . o O ( `mostly-out-of-order' )
07:24:29 <mcstar> why does the curry howard correspondence pertain to intuitionistic logic, rather than classical logic?
07:24:44 <mcstar> im just looking for a one sentence insight...
07:25:50 <saml> hello i am bored
07:26:13 <mcstar> is it because proofs that can be expressed in the type system, are always constructive?
07:26:17 <saml> can you build search tree on things that don't derive Eq and Ord ?
07:26:21 <Peaker> mcstar, I think because the law of the excluded middle is missing in curry-howard
07:26:38 <Peaker> mcstar, but I think if you add it as an axiom, you get back classical logic (I'm not sure)
07:26:55 <Peaker> mcstar, but yeah, it's because all proofs are constructive (without excluded middle)
07:27:02 <ski> mcstar : because intuitionistic logic is about what can actually be performed in finite time, with finite memory ?
07:27:13 <mcstar> ski: makes sense
07:27:17 <mcstar> no infinities
07:27:32 <mcstar> Peaker: ski thx
07:27:51 <merijn> ski: Now I feel stupid for not realising that earlier...
07:28:18 <mcstar> Peaker: did you see my questions?
07:28:21 <ski> the idea being that if we prove "there exists an integer `n', such that ...", we should actually have given a methods which will compute such an `n' (given enough (finite) memory and time)
07:28:22 <mcstar> the other day
07:28:47 <mcstar> Peaker: maybe it was just one question, did you write the opengl gui, or did you use some library?
07:28:58 <ski> Peaker : yeah, you get back classical logic
07:29:45 <ski> (though if you want classical logic, it's nicer to use a multiple-conclusion sequent calculus system, like Gentzen's LK <http://en.wikipedia.org/wiki/Sequent_calculus#The_system_LK>)
07:30:06 <EvanR> saml: yes
07:30:17 <EvanR> derive is only one way to define Eq and Ord instances
07:30:38 <ski> mcstar : actually, intuitionistic logic can reason about infinite sets, and also about infinite data -- it's just that the operations employed must be finitistic
07:30:41 <saml> EvanR, how?  you have things that can't be ordered.. how would you build tree for efficient search?
07:31:00 <EvanR> saml: you said deriving
07:31:11 <EvanR> maybe you meant 'without an Ord instance'
07:31:15 <saml> or let's say comparing objects x and y  is chaotic
07:31:21 <saml> yah i'm wrong
07:31:33 <ski> mcstar : e.g. there is no problem defining a function that takes two infinite sequences of numbers, and generate a new infinite sequence, whose every element is the sum of the two corresponding elements of the input sequences
07:31:37 <EvanR> without an ord instances, you can provide a comparison function like in other systems
07:31:45 <Peaker> mcstar, wrote the UI from scratch
07:31:51 <mcstar> ski: i understand
07:32:01 <ski> mcstar : the important point here is that to compute any particular element of the output sequence, you only need to look at finitely many elements of the input sequences
07:32:42 <ski> iow, it not possible here to construct a function which gives `0' if all the integer elements of the input sequence is zero, and gives `1' otherwise
07:33:23 <mcstar> that would require to traverse the elements wich would never terminate
07:33:26 <EvanR> isInfinite :: [a] -> Bool
07:33:33 <lillis> Hi once again. Trying to implement a custom elem function just to learn. If I do it with an if statement it all works fine, but if i try to do it with guards, somehow it messes up. Any pointers? http://hpaste.org/70734
07:33:51 <lillis> Note that if i do elem y xs and use head/tail on xs it also works
07:34:01 <ski> mcstar : people who don't even like this sort of benign infinities are called "finitists" -- they insist on every object being encodable in a natural number, and every predicate being decidable
07:34:05 <hpaste> tgeeky pasted ‚Äúone of the many times I love GHC‚Äù at http://hpaste.org/70735
07:34:08 <ski> mcstar : yep
07:34:19 <ksf> haddock markup sucks.
07:34:39 <fmap> lillis: you've forgot elem' y [] case
07:35:09 <lillis> fmap: oh - i thought null xs would catch that as well
07:35:16 <lillis> like it was _ []
07:35:25 <fmap> no
07:35:26 <mcstar> Peaker: was there a specific reason to do so? did you not find existing libraries suitable? or haskell lacks them?
07:35:27 <ksf> primarily, lack of working escaping (it's documented, but doesn't work), and lack of nesting.
07:35:36 <fmap> null xs catches [x] case
07:35:42 <Peaker> mcstar, I don't think I ever saw a PC GUI that I liked very much :) So lack of libraries
07:35:45 <fmap> ah
07:35:47 <ksf> we have pandoc, can decent markup be that hard?
07:35:54 <fmap> no, null xs is never true
07:36:13 <ksf> @src null
07:36:13 <lambdabot> null []     = True
07:36:13 <lambdabot> null (_:_)  = False
07:36:17 <Peaker> mcstar, The animation business is an example of what's missing in pretty much all GUIs in existence
07:36:38 <mcstar> Peaker: it sort of looks like some toy program so far, you should make it less intrusive(hope it makes sense), but there is potential there!
07:37:03 <Peaker> mcstar, Well, stuff is kinda messed up, not aligned, etc. Of course it's currently a toy :)
07:37:09 <Peaker> it's missing lots and lots of work
07:37:20 <flux> peaker, btw, have you taken a look at Qt and its QtQuick? it seems pretty bleeding-edge to me.
07:37:46 <flux> something like that but properly typed would be nice :)
07:37:53 <Peaker> flux, Qt, of course but years ago. Haven't heard of Qt Quick
07:37:55 <fmap> lillis: when you pattern match `xs@(_:_)' xs can not be [], so `null xs` is never true
07:38:01 <Peaker> flux, I doubt someone finally made a good GUI :)
07:38:20 <Peaker> flux, But I'll take a look, thanks
07:38:22 <mcstar> the problem with qt is that heavily OO
07:38:40 <lillis> fmap: ahhh. Thanks :)
07:38:48 <flux> peaker, there are some introductory vides on QtQuick, they should give a decent overview on its capabilities
07:38:50 <mauke> > case [] of xs@ ~(_:_) | null xs -> ()
07:38:51 <mcstar> the qt quick stuff is some declarative language right?
07:38:51 <lambdabot>   ()
07:39:07 <fmap> mauke: that's unfair
07:39:13 <mcstar> flux: but how would you interface with haskell?
07:39:25 <flux> mcstar, oh, I was thinking in the context of creating a new qui toolkit
07:39:43 <flux> basically QtQuick is its own javascript dialect, it only interfaces with the Qt library
07:39:56 <flux> so I think 'normal' qt bindings for haskell would do the trick, if that's what you want
07:40:07 <mcstar> flux: so you would need to make a c-wrapper for haskell right?
07:40:11 <flux> yes
07:40:24 <flux> of course, you could write your own EDSL for generating those QtQuick fragments ;)
07:41:02 <ski> Peaker : why "PC" in "PC GUI" ?
07:41:06 <ksf> http://www.haskell.org/pipermail/haskell-cafe/2009-January/054421.html
07:41:11 <ksf> (before I rant here)
07:41:13 <mcstar> Peaker: did you look at clutter?
07:42:28 <joeyh> seems that getDirectoryContents can throw an untrappable exception, which occurs when the thunk is forced
07:42:47 <mcstar> ksf: isnt FRP the solution?
07:43:00 <ksf> yes. but not on its own.
07:43:10 <mcstar> i read it works with wxwidgets
07:43:14 <ksf> well, some kind of frp
07:43:14 <joeyh> I'll bet it's using unsafeInterLeaveIO
07:43:19 <ksf> THAT"S MY VERY POINT
07:43:28 <ksf> WXWIDGETS IS A FOREIGN LIBRARY
07:43:37 <ksf> therefore, the haskell interface sucks.
07:43:40 <mcstar> ksf: you didnt say what was your point
07:43:44 <tgeeky> simmmmmmmaaaa down now
07:43:55 <ksf> no matter how much frp you use to wrap it up.
07:44:01 <ksf> it's gonna stay tailored to C.
07:44:10 * hackagebot CSPM-Frontend 0.9.0.6 - A CSP-M parser compatible with FDR-2.91  http://hackage.haskell.org/package/CSPM-Frontend-0.9.0.6 (MarcFontaine)
07:44:34 <flux> ksf, well, most everything you do in haskell will interface with a library written for C.
07:44:45 <ksf> on the contrary.
07:44:57 <EvanR> flux: god i hope not
07:44:58 <Peaker> ski, Because some GUIs on tablets I did like...
07:45:03 <Peaker> (/ phones)
07:45:04 <ski> ksf : ty
07:45:07 <EvanR> flux: i really hate it when my haskell program segfaults
07:45:08 <Peaker> mcstar, nope, what is it?
07:45:12 <flux> well, you do a web server? you interface with bsd sockets. you do a game? you interface with opengl. you do an X client? OK, you can implement your own X protocol implementation.
07:45:26 <EvanR> flux: sockets is part of the ghc runtime
07:45:29 <MostAwesomeDude> flux: Well, first off, there *is* an XCB for Haskell.
07:45:35 <mcstar> Peaker: afaik, its an opengl gui library, the new gnome ui is written in it for example
07:45:39 <ksf> you don't want to use it, though.
07:45:44 <flux> evanr, so it uses the kernel directly? or libc?
07:45:52 <EvanR> flux: ghc is written in haskell
07:45:53 <ksf> (I wouldn't be writing a replacement if it were great)
07:46:06 <MostAwesomeDude> flux: We *could* do a Haskell OS. In fact, a couple have already been done. If we had a full one, that'd be pretty darn nifty.
07:46:17 <flux> mostawesomedude, and pretty huge task as well
07:46:29 <flux> it's just pragmatic to interface with C, because the C libraries are already there.
07:46:29 <EvanR> a garbage collected OS
07:46:31 <ksf> ...there's a difference in interfacing to primitive vs. high-level libraries.
07:46:45 <mcstar> ksf: talking about clutter?
07:46:47 <ksf> binding gtk isn't good, but you're free to use X to draw your own tk stuff.
07:46:50 <MostAwesomeDude> flux: It's also pragmatic to use closed-source code and Windows machines. :3
07:46:51 <EvanR> yeah the idea is that the stuff in the runtime system is more reliable
07:46:54 <nand`> all of the programs I compile with GHC link against some (non-Haskell, usually C) libraries dynamically either way
07:46:55 <ksf> clutter is rather high level.
07:47:09 <ksf> cairo should be the maximum.
07:47:11 <Peaker> mcstar, ah. Well we're pretty pleased with the GUI we have made
07:47:14 <nand`> but that's not directly related to any of the code I write
07:47:17 <nand`> just GHC stuff
07:47:23 <Peaker> mcstar, so we'll probably not switch to an existing solution
07:47:24 <MostAwesomeDude> flux: But you gotta keep in mind that, in a lot of ways, people in this community aren't afraid of this concept.
07:47:26 <ksf> ...only slightly higher than, say, xrender or opengl.
07:47:48 <MostAwesomeDude> I actually talked to fijal (from PyPy) about this a couple months ago. His response was "Well, we aren't doing PyPy as an OS. Yet, anyway."
07:47:51 <Peaker> ksf, graphics-drawingcombinators is much nicer than cairo IMO
07:47:52 <nand`> I'm pretty afraid of interfacing with C, I'll be honest with you
07:48:00 <merijn> nand`: Why?
07:48:05 <mcstar> Peaker: well, happy future hacking then, let it rule the world
07:48:14 <nand`> merijn: so many ways things can go horribly wrong and segfault my program
07:48:19 <ksf> Peaker, iirc last time I tried it it didn't have proper font support. at least not realtime.
07:48:23 <flux> mostawesomedude, that is correct, but it is another thing to start a project than to finish it. xmonad has fared excellently, but how about yi, another probably more ambitious project?
07:48:26 <ski> (Peaker : .. there might still be useful ideas and concepts to cannibalize)
07:48:34 <nand`> also dealing with all of those scary type signatures involving pointers to pointers and whatnot
07:48:58 <MostAwesomeDude> flux: vim, cold dead hands, etc.
07:49:12 * hackagebot CSPM-CoreLanguage 0.3.0.1 - Definition of a FDR-compatible CSP core-language.  http://hackage.haskell.org/package/CSPM-CoreLanguage-0.3.0.1 (MarcFontaine)
07:49:14 * hackagebot CSPM-FiringRules 0.4.1.2 - Firing rules semantic of CSPM  http://hackage.haskell.org/package/CSPM-FiringRules-0.4.1.2 (MarcFontaine)
07:49:16 * hackagebot CSPM-Interpreter 0.6.0.3 - An interpreter for CSPM  http://hackage.haskell.org/package/CSPM-Interpreter-0.6.0.3 (MarcFontaine)
07:49:18 * hackagebot CSPM-ToProlog 0.5.0.0 - some modules specific for the ProB tool  http://hackage.haskell.org/package/CSPM-ToProlog-0.5.0.0 (MarcFontaine)
07:49:20 * hackagebot CSPM-cspm 0.6.0.4 - cspm command line tool for analyzing CSPM specifications.  http://hackage.haskell.org/package/CSPM-cspm-0.6.0.4 (MarcFontaine)
07:50:00 <Peaker> mcstar, thanks :)
07:50:10 <flux> mostawesomedude, so you're saying people got disinterested because their current tools were good enough compareed to the effort. well, guess what, there is linux ;-)
07:50:20 <Peaker> ksf, I changed it to used texture fonts, I use it with 60fps smooth animations (real time)
07:50:29 <lillis> Is it possible to compare values in pattern matching? Let's say I'm running through my recursive elem' and I want return True when the value searched for is equal to the current head of the list im searching
07:50:35 <lillis> Would something like this be possible to check for it? elem y (y:xs) = True
07:50:49 <lillis> Pattern matching is just so elegant, but it seems in this case I have to use guards or an if statement, is this correct?
07:51:00 <ksf> Peaker, can you still scale them? that is, is the texture usage transparent?
07:51:15 <MostAwesomeDude> flux: Indeed, the arguments must be somewhat convincing.
07:51:22 <ksf> (also, does it run over the internet?)
07:52:01 <Peaker> ksf, I think so.. what do you mean over the internet?
07:52:18 <ksf> sending X commands over the internet.
07:52:37 <Peaker> ksf, oh.. that's an OpenGL thing more than a drawingcombinators thing?
07:52:42 <Peaker> ksf, I kind of doubt it?
07:52:50 <ksf> ...instead of drawing on the client and then sending the finished bitmap over.
07:53:05 <ksf> opengl should run on the server. at least it's possible to do so.
07:53:51 <ksf> well, once I'm done with the X bindings you can port it to xrender :)
07:54:11 <Peaker> ksf, it's not a focus for now
07:54:25 <Doom99> X over the net can be a frustrating adventure at least as an end user
07:54:48 <ksf> It's still far away from being useable, anyway.
08:05:07 <jfischoff> What package is a good package for manipulating matrices of Integers?
08:05:13 <fmap> lillis: patterns can mention each variable only once, so yes, you need guards
08:05:16 <ksf> dph, repa
08:06:03 <ksf> vector, too, depending on what you want.
08:06:39 <fmap> lillis: iirc `elem y (y:xs)'-kind of pattern matching is possible in prolog
08:06:59 <jfischoff> I want easy of use. I need to be able to build matrices from other matrices (blocks) and multiply them
08:07:08 <jfischoff> s /easy/ease
08:07:26 <ksf> then you probably want dph
08:08:06 <ksf> http://www.haskell.org/haskellwiki/GHC/Data_Parallel_Haskell
08:08:44 <Cale> dph sounds lower level than what jfischoff is asking for... maybe
08:08:55 <ksf> repa is lower-level.
08:08:57 <jfischoff> yes. I don't need performance
08:08:59 <ksf> vector, too.
08:09:04 <nand`> http://hackage.haskell.org/packages/archive/NumInstances/1.0/doc/html/src/Data-NumInstances.html <- I noticed the Num b => Num (a -> b) instance is only defined in terms of Applicative operations (replacing fmap by liftA at least), so why is it not (Applicative f, Num b) => Num (f b) ?
08:09:12 <ksf> dph has *nested* data parallelism, that's the high-level part.
08:09:16 <Cale> hmatrix is probably more along the lines of what you're looking for
08:09:20 <kallisti> does anyone know of a HTML -> Hamlet  converter?
08:09:30 <Cale> ksf: but dph doesn't do linear algebra on its own
08:09:57 <ksf> well, so far jfischoff only mentioned multiplications and construction.
08:09:59 <jfischoff> matrix would work, but it only handles doubles, floats due to using BLAS, or whatever its binding to
08:10:05 <jfischoff> s /matrix/hmatrix
08:10:18 <Cale> nand`: because instances which overlap with half of everything are annoying
08:10:56 <Cale> nand`: Remember that instance selection takes place independently from checking the constraints on the left of the =>
08:11:10 <nand`> oh
08:11:19 <nand`> yes, I can see how that can be annoying
08:11:53 <Cale> (so that just looks like  Num (f b)  with no constraints to the instance selection process)
08:13:03 <jfischoff> It's too bad there is not a pure haskell version of hmatrix
08:16:02 <Axman6> jfischoff: looked at Repa?
08:16:29 <Axman6> takes some getting used to, but it can be quite powerful, and parallel pretty much for free
08:17:12 <jfischoff> Axman6: yeah this looks like a good base
08:17:16 <jfischoff> reps that is
08:17:57 <Axman6> i believe it supports partitioned arrays
08:18:25 <ksf> ...dph pretty much rules array shapes.
08:18:29 <ksf> repa is faster, though.
08:18:49 <Axman6> and it works, unlike DPH at the moment.
08:19:00 <mcstar> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/Vec
08:19:06 <Axman6> well, does what it says it will. there's still; lots of problems at the moment I think
08:32:19 <bgamari> flixil: I did
08:32:26 <bgamari> Briefly
08:32:30 <flixil> you did what?
08:32:34 <ciaranm> it!
08:32:35 <bgamari> Looked at atom
08:32:49 <bgamari> and got some code running on an Arduino
08:32:52 <bgamari> but never got to ARM
08:33:33 <bgamari> but perhaps once things stabilize on my favorite small ARM board (http://mchck.org/) I'll take another look
08:34:12 <Axman6> bgamari: why would ARM be any different? it's all just C
08:39:13 <flixil> bgamari: i just learned about copilot http://leepike.wordpress.com/2010/12/18/haskell-and-hardware-for-the-holidays/
08:41:29 <c_wraith> Axman6: the RTS code needs to be rewritten - it's highly platform-specific C
08:45:57 <bgamari> Axman6: Booting an ARM device can be non-trivial
08:46:29 <bgamari> Axman6: Whereas the bootloader takes care of this in the Arduino case
09:03:27 <younder> I want to write a assembler in Haskell. So is there any support for generating: ELF (64) file format and / or  DWARF (debug info)
09:04:47 <nand`> http://hackage.haskell.org/packages/archive/elf/0.26/doc/html/Data-Elf.html <- might help
09:05:06 <nand`> it seems to be the reverse of what you want though
09:05:13 <nand`> maybe you can make use of it
09:05:48 <younder> well I's a start. Thanks.
09:06:12 <nand`> there's also http://hackage.haskell.org/package/dwarf incidentally
09:07:23 * kallisti could see a "shakespeare-sass" package being useful.
09:08:59 <kallisti> take a combined dialect of lucius and sass (maybe cassius too?) and compile it to lucius (or cassius).
09:09:42 <DMcGill> is there a library for "ghc-pkg" or will I have to call it from the command line?
09:10:00 <younder> nand' Well I am a happy man. You probably save me a week..
09:10:47 <nand`> younder: I shan't take credit, 'twas hoogle which found those packages
09:12:38 <younder> nand' Yeas I know. Lat night I found the dbus interface using search methods. Guess I just got lonely )
09:13:54 <mcstar> younder: i googled this for you http://www.okcupid.com/
09:14:03 <bgamari> DMcGill: I don't believe there's a library interface unfortunately
09:15:49 <however> DMcGill: check this http://www.haskell.org/ghc/docs/latest/html/libraries/ghc/PackageConfig.html not sure if it can help you, i haven't used it. just came across it while reading around
09:16:00 <younder> Well I am all for being antisocial just now.. Just started the actual development of my programming language Formula.
09:16:02 <however> (also read http://www.haskell.org/haskellwiki/GHC/As_a_library of course)
09:18:09 <younder> Well I have a client in C++ and a server in Haskell and also a compiler in Haskell to work out.. Communication would be nice so I chose DBus for client-server.
09:21:05 <ski> kallisti : "sass" ?
09:21:25 <kallisti> ski: it's another fairly common dialect of CSS.
09:22:43 <kallisti> it even has an indented syntax and a CSS-superset syntax
09:22:49 <kallisti> analogous to cassius and lucius.
09:26:05 <ptrf> @unmtl MaybeT (State s) a
09:26:05 <lambdabot> s -> (Maybe a, s)
09:26:08 <ptrf> oh neat
09:28:17 <fragamus> hey guys I'm working with Data.Map but I have big data. What do I do when I run out of memory? What are the alternatives?
09:31:28 <fmap> fragamus: why do you think you are running out of memory because of `Data.Map'?
09:32:06 <fragamus> I am not, but I anticipate that I will. I have a lot of data.
09:32:23 <hiptobecubic> Does the data fit into memory at all?
09:32:29 <bgamari> fragamus: If you can't fit your data in memory, you're stuck
09:32:38 <bgamari> Same as any other language
09:32:41 <fragamus> yeah
09:32:51 <hiptobecubic> fragamus, hadoop :) ?
09:32:54 <fragamus> is there a persistent Data.Map
09:32:55 <DMcGill> either that or you have to be very careful about strictness
09:33:11 <bgamari> You could possibly write a cache interface to pull things into memory from non-volatile storage when necessary
09:33:11 <fragamus> I'm stuck
09:33:17 <DMcGill> for example, you can sum over a list in O(n) time and O(1) memory
09:34:34 <jfischoff> A lot of data stores try to solve this problem. Its really a question of how much you want to write yourself
09:34:58 <mcstar> also consider the sizeof(tree)/sizeof(data) ratio, maybe not the tree is the best, or you dont need to keep the data in memory at once
09:36:36 <mcstar> jfischoff: did you look at the Vec package?
09:37:06 <jfischoff> It is for low dimensional stuff right?
09:37:23 <dmwit> There seems to be some very strange advice floating around here.
09:37:33 <mcstar> low dimensional means couple of indices in this case
09:37:36 <mcstar> not few elements
09:38:18 <mcstar> no that i used it, but from the package description it seemed to be applicable to your case
09:38:44 <jfischoff> mcstar: according to the doc it is meant for 2-4 dimensional problems
09:39:00 <jfischoff> which is not general enough for what I was doing
09:39:10 <jfischoff> but it doesn't matter right now
09:39:39 <jfischoff> I'm able to use hmatrix to test stuff out
09:43:08 <mcstar> jfischoff: youre right, it uses dimension in the mathematical sense
09:43:45 <jfischoff> yeah, good for graphics stuff
09:49:09 <fragamus> here's a newb question: In my monad, I do an action (generating a random number).  I do not use the result. Is the state of my random number generator affected or not?
09:49:58 <kallisti> I see now why yesod recommends that you build it with cabal-dev
09:50:06 <parcs`> fragamus: of course
09:50:14 <kallisti> if you install yesod in your default .cabal directory then nothing else will ever build. :P
09:50:48 <jfischoff> kallisti; because of strict dependencies?
09:50:51 <kallisti> yes.
09:50:53 <fragamus> oh so no lazy thingy happens
09:51:00 * kallisti nuked his cabal directory again, and built yesod completely within a cabal-dev sandbox, and now all of his dependency hell is fix.
09:51:07 <kallisti> *fixed
09:51:11 <kallisti> can't type today.
09:51:46 * ski . o O ( "fscked" )
09:52:19 <kallisti> fragamus: depends on how >>= is defined actually, but most likely.
09:52:53 <kallisti> for IO, definitely. all IO is strict (except when it's not).
09:53:04 <mcstar> with IO, id expect that my getLine runs whether i use the result or not, would be a pretty useless IO monad then
09:53:20 <kallisti> mcstar: there are various "lazy IO" monads on hackage.
09:53:29 <mcstar> ouch, didnt know
09:53:40 <c_wraith> there's also unsafeInterleaveIO, for making your own IO actions effect-lazy!
09:53:48 <mcstar> but you know what you are doing when using that
09:53:49 <kallisti> also unsafeInterleaveIO can be used for great good.
09:53:49 <kallisti> yes.
09:55:33 <kallisti> here's a fun application of unsafeInterleaveIO http://hackage.haskell.org/packages/archive/unsafe-promises/0.0.1.3/doc/html/Control-Concurrent-Promise-Unsafe.html
09:55:39 <monochrom> don't forget to nuke your .ghc
09:55:44 <kallisti> I didn't
09:55:47 <kallisti> (forget)
09:57:51 <jfischoff> kallisti: Conceptually I like the idea of futures, but it seems very few people use them in practice. Do you know why that is? Or are the used more then I realized?
09:58:07 <Taneb> Is there a way to bulk update everything installed
09:58:09 <kallisti> I don't think people use them often. I write that library I don't even use it often. :P
09:58:26 <kallisti> conceptually it's very nice, but I suspect in many cases people need or want more fine-grained control.
09:58:49 <jfischoff> I guess it is hard control performance
09:59:22 <kallisti> well it doesn't scale in any real sense. it's great for simple concurrency though.
09:59:39 <monochrom> to some extent, laziness is already enough
09:59:48 <kallisti> "compute this time consuming thing while I do something else, and then I'll wait for the result"
09:59:59 <mm_freak> how do i export an associated type?
10:00:04 <mm_freak> reexport i mean
10:00:20 <kallisti> in the export list for the typeclass?
10:00:24 <kallisti> I don't actually know, just my guess.
10:00:31 <mm_freak> "module X (MyClass(MyAT, func1, func2))" doesn't work
10:00:38 <monochrom> oh, I think the GHC user guide has the detailed special syntax for that
10:01:40 <kallisti> jfischoff: I've been toying with the idea of a general-purpose concurrency abstraction, but I haven't made much progress yet.
10:01:48 <monochrom> are you doing "data family" or "type family"?
10:02:05 <mm_freak> got it
10:02:13 <mm_freak> it's:  module X (MyClass(type MyAT, func1, func2))
10:02:21 <mm_freak> weird syntax (it's a data family)
10:02:22 <jfischoff> kallisti: what is it like?
10:03:28 <kallisti> jfischoff: it's pretty ephemeral at the moment. I need to look into existing solutions. But the idea is that instead of manually defining channels and qsems you would declaratively specify connections between processes with parametric input and output types
10:04:44 <kallisti> perhaps an inner monad parameter as well.
10:05:18 <jfischoff> kallisti: cool
10:07:15 <kallisti> I was also considering having a thread pool, but I don't know how necessary that is in light of GHC's runtime, which already does thread pools for you.
10:07:44 <xrl> say you're using a fairly standard looking recursive data type (Tree a = Tip | Node a (Tree a) (Tree a)). when you're building the tree are the intermediate trees in memory? how does the runtime guess whether to copy a value or reuse an existing value?
10:09:49 <twanvl_> xrl: it doesn't reuse previously constructed values, except that there will just be a single Tip, since it doesn't have any arguments
10:10:21 <monochrom> intermediate trees are in memory. "x=y" reuses y. "case t of Node n l r -> Node (n+1) l Tip" reuses l
10:11:16 <monochrom> perhaps I should plug my shameless plug http://www.vex.net/~trebla/haskell/lazy.xhtml
10:11:30 <kallisti> plugception
10:13:10 <monochrom> it's an immutable language. if you write "Node ..." it builds a new record. if not, it builds nothing. copying is for mutable languages.
10:14:12 <xrl> monochrom: you only have immutable data in Haskell. But Haskell may be able to mutate things if it's 'safe'?
10:15:04 <dcoutts> xrl: in theory yes, in practice only a little bit, like function args in tail-calls
10:15:22 <monochrom> yes but so far I have only seen primitive-type parameters being mutated by GHC in very very special circumstances
10:15:54 <dcoutts> there's a paper by some of the clean chaps on a uniqueness-style type analysis to be used to infer cases where reuse would be safe
10:16:17 <dcoutts> ie intended as a transparent optimisation by the compiler
10:16:24 <monochrom> "f 0 = 0; f n = f (n-1); f :: Int -> Int" gets you a mutable register for the Int parameter and return value
10:16:31 <monochrom> and that is all
10:19:09 <otters> > let f 0 = 0; f n = f (n - 1); f :: Int -> Int in f (negate 1)
10:19:13 <lambdabot>   mueval-core: Time limit exceeded
10:22:24 <kallisti> > let f :: Word -> Word; f 0 = 0; f n = f (n - 1) in f (negate 1)
10:22:28 <lambdabot>   mueval-core: Time limit exceeded
10:22:33 <kallisti> > negate 1 :: Word
10:22:34 <lambdabot>   18446744073709551615
10:23:10 <jfischoff> anyone using Shake?
10:23:44 <jfischoff> I am planning on taking a look, was wondering if there is anything I should watch out for
10:23:48 <ClaudiusMaximus> jfischoff: i have a project that uses it, but i haven't touched it for a few weeks
10:24:05 <jfischoff> what's your impression?
10:24:33 <ClaudiusMaximus> jfischoff: good stuff in general, and a responsive maintainer (i had a bizarre use case that exposed some bugs)
10:24:46 <jfischoff> great!
10:24:50 <mcstar> let f :: Word8 -> Word8; f 0 = 0; f n = f (n - 1) in f (negate 1)
10:24:53 <mcstar> > let f :: Word8 -> Word8; f 0 = 0; f n = f (n - 1) in f (negate 1)
10:24:55 <lambdabot>   0
10:25:47 <ClaudiusMaximus> jfischoff: one thing to note, there's no "dry run" support, if you need that then you have to build it yourself..
10:29:21 * hackagebot gl-capture 0.1.0.0 - simple image capture from OpenGL  http://hackage.haskell.org/package/gl-capture-0.1.0.0 (ClaudeHeilandAllen)
10:29:23 * hackagebot snowglobe 2 - randomized fractal snowflakes demo  http://hackage.haskell.org/package/snowglobe-2 (ClaudeHeilandAllen)
10:29:26 * hackagebot BlogLiterately 0.4 - A tool for posting Haskelly articles to blogs  http://hackage.haskell.org/package/BlogLiterately-0.4 (BrentYorgey)
10:41:46 <mewalz> Is there a simple way of parsing keywords using parsec. e.g. I have 50 words and each word performs a certain action.
10:43:00 <kallisti> mewalz: do all of these actions have the same type signature? :D
10:44:12 <mewalz> kallisti: Yes, I am looking for something faster than matching strings
10:45:13 <kallisti> you're going to have to match strings no matter what you do. unless you're talking about "development time fast" over "performance fast"
10:45:32 <kallisti> mewalz: if each action has the same result, then you can construct a Map or HashMap from keyword -> function
10:45:55 <DMcGill> could a trie be used here?
10:46:00 <kallisti> then your keyword parser just takes the keyword, looks it up in the map, and returns that function (or does whatever else with it)
10:46:12 <kallisti> sure you could use a trie.
10:47:32 <mewalz> a trie would do the job, does anything exist?
10:48:03 <jfischoff> what is easy to get the dependencies for a cabal package?
10:48:59 <jfischoff> from a .cabal file that is
10:49:18 <mcstar> or what?
11:17:52 <dylukes> So, for an arbitrary typeclass RValue a, why can I not do:
11:18:02 <dylukes> instance Num a => RValue a where ...
11:18:06 <dylukes> It complains that "Constraint is no smaller than the instance head"
11:18:56 <parcs`> because you can introduce nontermination that way
11:19:07 <Cale> dylukes: Well, that's not advisable because as far as instance selection is concerned, that's the same as  instance RValue a where
11:19:28 <dylukes> How exactly does that work?
11:19:53 <Cale> The constraints on instances only get checked after the instance is selected.
11:20:19 <Cale> The compiler can never be certain that there *won't* be an instance of any particular class, until it's done compiling all the future modules.
11:20:47 <Cale> So it can't select an instance based on presence/absence of other instances, only on the structure of the type involved.
11:20:50 <Relikahm> wait, guys, how can i write a for loop, i tried for (x) { }
11:20:58 <Cale> Relikahm: In what language?
11:21:02 <Relikahm> but it didn't work :'(
11:21:08 <Relikahm> haskell
11:21:12 <jfischoff> no loops in haskell
11:21:23 <Cale> Yeah, there's no built-in for loop in Haskell. There's a library function forM
11:21:31 <Relikahm> why not? that is stupid. can i get a plugin for that
11:21:42 <jfischoff> its not stupid
11:21:43 <Cale> Because we don't need one.
11:21:53 <Relikahm> how does it work without one
11:21:57 <Cale> What are you trying to do?
11:21:57 <Relikahm> it doesn't make sense
11:21:59 <jfischoff> very well :)
11:22:00 <saep> troll alert *cough*
11:22:10 <Cale> What are you trying to compute?
11:22:18 <c_wraith> except for the "if .. then .. else .." expression, haskell is pretty good at keeping unnecessary redundant control-flow out of the language.
11:22:27 <Relikahm> i am trying to iterate through an array and find themean value
11:22:34 <c_wraith> for loops are unnecessary and redundant in haskell
11:22:48 <Relikahm> i miss java :'(
11:22:53 <Cale> Relikahm: An array or a list?
11:23:01 <Relikahm> a list
11:23:09 <mcstar> it is interchangable in his mind probably
11:23:15 <Cale> Relikahm: in any case, you can compute the sum of a list using 'sum' which is written in terms of foldl
11:23:19 <Relikahm> wait, guys, there is a difference
11:23:22 <Cale> yes
11:23:25 <Cale> big difference
11:23:35 <jfischoff> if your new to haskell don't worry about array
11:23:38 <Relikahm> what? how do i make a list
11:23:47 <Cale> [1,2,3] is a list
11:23:48 <Relikahm> in java
11:23:51 <LegendaryQ> bad troll is bad
11:23:56 <Cale> Use the LinkedList class
11:24:03 <mcstar> java has built in lists, you dont need to make one
11:24:08 <younder> sum(array)/lenghth(array)
11:24:10 <Relikahm> i know what a linkedlist is, i just want a list
11:24:19 <Cale> Though what you'll get in Java won't really be equivalent to Haskell lists, because it's not lazy.
11:24:36 <Cale> Haskell lists can be infinite
11:24:38 <Cale> for example
11:24:43 <Cale> > [1..]
11:24:43 <Relikahm> don't make fun of the great james goslin
11:24:44 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
11:24:48 <Relikahm> gosling
11:24:56 <Relikahm> thanks guys, im going to fix that
11:25:06 <Iceland_jack> ‚Ä¶
11:25:07 <younder> You used an array AGAIN.. Wasn't the STRING experience enough?
11:25:08 <Cale> okay...
11:25:15 <mcstar> come on, feed it a little bit
11:25:47 <mcstar> "i tried for (x) { }" that was great
11:25:52 <mcstar> i lol'd
11:26:42 <mjrosenb> how do I get cabal-install to list packages that I can update / re-installing will cause a new version to get installed?
11:27:15 <jfischoff> I don't see a troll but I try to use Hanlon's razor whenever possible
11:27:53 <mjrosenb> jfischoff: hanlon's razor?
11:27:57 <mcstar> jfischoff: hah, or arrogance
11:28:08 <jfischoff> ignorance is probably better
11:28:10 <jfischoff> though
11:28:14 <Cale> #haskell, feeding trolls until they explode since 2001
11:29:29 * hackagebot clientsession 0.8.0 - Securely store session data in a client-side cookie.  http://hackage.haskell.org/package/clientsession-0.8.0 (MichaelSnoyman)
11:30:47 <saep> mjrosenb: for i in $(ls .ghc/x86_64-linux-7.4.1/package.conf.d/) ; do cabal install ${i%\-*-*} ; done
11:31:35 <mjrosenb> saep: that sounds like it could be made easier with a cabal command :(
11:43:20 <fmap> didn't cabal upgrade do precisely that?
11:43:55 <monochrom> cabal upgrade is passe
11:44:07 <dcoutts> saep: don't do that, if you want to upgrade them all, you almost certainly want to upgrade them simultaneously, not sequentially
11:44:08 <monochrom> but yes, it did
11:44:33 <dcoutts> monochrom, fmap: you can still do the same with cabal install --upgrade-dependencies
11:44:46 <dcoutts> and it has exactly the same issues as cabal upgrade did
11:44:48 <mcstar> it is not clear what the OP wants, but he might want --dry-run
11:45:20 <mjrosenb> saep: presumably package.cache should be ignored
11:46:03 <monochrom> a major problem with "cabal upgrade" was that it couldn't tell comes-with-GHC from user-added. you almost always want to touch user-added only.
11:46:41 <flixil> Anyone tried haskell for uC?
11:47:02 <monochrom> and so I suppose some kind of "cabal install $(ls .ghc/x86_64-linux-7.4.1/package.conf.d/)" is not too problematic
11:47:29 <dcoutts> monochrom: aye
11:50:11 <eikke> I'm seeing something strange: I have a very simple function which xor's 2 bytestrings pairwise (\a b -> BS.pack $ BS.zipWith xor a b)
11:50:37 <eikke> according to the BS docs, this zipWith should be replaced with zipWith' using a rule
11:50:45 <apfelmus> ping edwardk
11:51:14 <eikke> that seems to work for the normal function, but when checking the core output, the inlined version of the function is *not* rewritten using zipWith' and first creates a list, then packs it, which is... rather inefficient
11:51:35 <eikke> so I'm wondering why this (important) difference between 'normal' and 'inlined' version occurs
11:59:59 <shachaf> eikke: I see a rule for unpack (zipWith ...)
12:00:11 <shachaf> Er, unpack (zipWith' ...)
12:00:44 <shachaf> Are you sure there's one for pack (zipWith ...)?
12:01:03 <rwbarton> I think it's supposed to turn zipWith into unpack (zipWith' ...), and then presumably something else should turn pack (unpack ...) into ...
12:01:25 <rwbarton> but I didn't see that latter rule, maybe it's in an internal module
12:02:15 <rwbarton> and I don't have any theory about why inlining your function would make a difference to the rules
12:02:20 <eikke> shachaf: well, I didnt see the rule myself
12:02:31 <eikke> saw the one you point at, but documentation says it should work as expecred
12:02:38 <eikke> and core seems to indicate it does work
12:02:44 <shachaf> Oh, I didn't see the comment.
12:02:49 * shachaf wonders where the RULE comes from.
12:04:18 <eikke> thinking about switching from bytestring to repa anyway
12:08:26 <joe9> any thoughts on what I am missing: http://codepad.org/488EFxWh  http://codepad.org/ZRT1V6nm
12:08:34 <joe9> {-# LANGUAGE TypeSynonymInstances, FlexibleInstances #-}
12:08:51 <joe9> isn't the line the same as adding -XFlexibleInstances?
12:09:08 <joe9> the error is with Extra-1.42
12:09:57 <joe9> don't bother. wrong package.
12:26:23 <unlink> What's a better way to say this:  groupBy ((==) `on` (takeExtension . fst)) . sortBy (compare `on` (takeExtension . fst))
12:27:36 <Botje> convert your elements into (x, takeExtension x) first
12:29:17 <hrickards> With Firefox, I'm occasionally seeing the window freeze. Waiting for 3 or 4 seconds or switching to another window/workspace fixes this.
12:29:47 <hrickards> This only seems to happen with Firefox, and isn't a problem on Openbox. I have plenty of free RAM, and htop reports peak CPU usage at around 30%.
12:29:59 <hrickards> Anyone got any ideas? Thanks
12:30:00 <geekosaur> hrickards, perhaps you wanted #xmonad instead of #haskell?
12:30:05 <hrickards> Crap
12:30:19 <hrickards> Sorry!
12:30:40 <geekosaur> that said, make sure you have XMonad.Hooks.EwmhDesktops configured (and beyond that there have been some reports but nobody has managed to reporduce it in testing)
12:31:08 <hrickards> Ok, thanks for the advice
12:32:48 <geekosaur> mind, if you can help us reporduce it, it'd be helpful
12:45:38 <flixil> anyone programmed embedded with haskel?
12:47:44 <Philippa> I know it's been done, though I'm drawing a blank on who's done it. What kind of embedded are you interested in? It covers a worryingly wide range of scales these days
12:48:13 <mel-> good evening :)
12:48:39 <flixil> I'm thinking of an Arm cortex M3 Philippa
12:50:46 <Eduard_Munteanu> flixil: you might want to look into http://hackage.haskell.org/package/atom/
12:50:58 <flixil> I found some DSL like Atom, but it looks like meta-programming
12:51:46 <flixil> I was wondering if the VM could also be embedded like has been done with python
12:51:50 <ThePro> > read "4"
12:51:51 <lambdabot>   *Exception: Prelude.read: no parse
12:51:56 <ThePro> > read "4" :: [Int]
12:51:57 <lambdabot>   *Exception: Prelude.read: no parse
12:51:59 <ThePro> :(
12:52:02 <Eduard_Munteanu> Yeah, it compiles to C, then target code, or something like that. I'm not sure of the state of ARM for GHC.
12:52:42 <ThePro> > read "4" :: Int
12:52:43 <Eduard_Munteanu> > read "[4]" :: [Int]
12:52:44 <lambdabot>   4
12:52:44 <lambdabot>   can't find file: L.hs
12:52:53 <flixil> Eduard_Munteanu: but you have to write with the language defined with Atom grammar which feels like imperative anyway
12:53:10 <ThePro> wtf L.hs?
12:53:22 <ThePro> > read "[5] :: [float]
12:53:24 <lambdabot>   <no location info>:
12:53:24 <lambdabot>      lexical error in string/character literal at end o...
12:53:27 <ThePro> > read "[5]" :: [float]
12:53:29 <lambdabot>   Could not deduce (GHC.Read.Read float) from the context ()
12:53:29 <lambdabot>    arising from ...
12:53:48 <Eduard_Munteanu> ThePro: that's the same thing as read "[5]" :: [a]
12:54:01 <Eduard_Munteanu> > read "[5]" :: [Float]
12:54:02 <lambdabot>   [5.0]
12:54:46 <c_wraith> in short, capitalization matters
12:56:13 <ThePro> ah right
12:56:29 <ThePro> variables cant start with a capital letter right?
12:56:38 <ThePro> > let Lol = 3
12:56:39 <lambdabot>   not an expression: `let Lol = 3'
12:56:43 <ThePro> > let lol = 3
12:56:44 <lambdabot>   not an expression: `let lol = 3'
12:56:48 <eVanR> > let Lol = 3 in Lol
12:56:50 <lambdabot>   Not in scope: data constructor `Lol'Not in scope: data constructor `Lol'
12:56:54 <ThePro> ah right in
12:57:08 <ThePro> > let lol = 3 in lol
12:57:10 <lambdabot>   3
12:57:12 <ThePro> k
12:57:20 <Eduard_Munteanu> ThePro: in fact that's how it distinguishes variables from concrete types / constructors
12:59:36 * hackagebot xml-picklers 0.2 - XML picklers based on xml-types, ported from hexpat-pickle  http://hackage.haskell.org/package/xml-picklers-0.2 (PhilippBalzarek)
12:59:55 <edwardk> apfelmus: pong
13:00:20 * ksf thinks he wants datatype context.
13:00:22 <ksf> *s
13:01:09 <ksf> I mean I *can* leave the datatype fully polymorphic, but that's throwing away half a metric ton of documentation.
13:02:26 <ksf> the other documentated possibility is to use an either type instead of a typeclass to handle passing a different type of parameter (the list of possibilities is closed), but that's awkward.
13:04:08 <ksf> the third option, making all my data types into functions is against the whole spirit of xcb.
13:06:11 <ksf> I could generate *even moar* data types.
13:06:39 <kallisti> looks like html2hamlet is in need of an update.
13:06:44 <ksf> ...the only problem there is naming the things.
13:08:10 <kallisti> yes even with cabal-dev I can't compile html2hamlet
13:08:15 <kallisti> because it uses an old version of base.
13:10:16 <mm_freak>     Warning: RULE left-hand side too complicated to desugar
13:10:22 <mm_freak> anyone know what can cause this?
13:10:31 <kallisti> what is the left-hand side of the rule?
13:10:54 <hpaste> ‚ÄúErtugrul S√∂ylemez‚Äù pasted ‚ÄúSPECIALIZE not working‚Äù at http://hpaste.org/70750
13:11:02 <mm_freak> see paste
13:11:16 <mm_freak> where Session is an AT of SessionState
13:13:26 <mm_freak> i have the impression that it's related to the AT
13:14:03 <mm_freak> without the AT it works, but then it doesn't make a difference
13:14:11 <mcstar>  @undef
13:14:16 <mcstar> @undef
13:14:23 <mcstar> > read "[4]" :: [Int]
13:14:25 <lambdabot>   [4]
13:14:28 <mm_freak> i.e. this one works:
13:14:28 <mm_freak> {-# SPECIALIZE testWire :: (SessionState s) => Int -> IO a -> s -> Wire () (Session s) (->) a String -> IO b #-}
13:14:42 <mm_freak> where i leave 's' polymorphic
13:17:07 <ThePro> > succ ()
13:17:09 <lambdabot>   *Exception: Prelude.Enum.().succ: bad argument
13:17:12 <dylukes> Is there any way to set up a "default" build path for a cabal package?
13:17:17 <ThePro> > succ 1
13:17:19 <lambdabot>   2
13:17:22 <dylukes> without adding a makefile :P?
13:17:35 <bmm> Hi. I'm a beginner and not sure what is happening here: let a=[["asdf"]]; let [h:t]=a. Now h is "asdf" and not, as I would expect ["asdf"]. However, t is an empty list ([]) as expected. What is going on?
13:17:49 <dylukes> I should write a zsh plugin to simplify things a bit maybe.
13:18:03 <dylukes> atm I do stuff like `cabal configure --enable-tests && cabal build && cabal test && cabal haddock`
13:18:06 <mm_freak> bmm: note that (:) takes different types of arguments
13:18:17 <mm_freak> (x:xs) where xs is a list and x is an element
13:18:22 <Botje> bmm: [["asdf"]] = [("asdf":[])]
13:18:32 <mcstar> [["asdf"]] === ("asdf" : []) : []
13:18:37 <mm_freak> if (x:xs) = [[x]], then the head element is [x], because it's the head element of [[x]]
13:18:38 <bmm> Botje: Oooooh... () not []. DOH!
13:18:46 <shachaf> bmm: let a = (("asdf":[]):[]); let ((h:t):[]) = a
13:18:53 <mm_freak> uh, that was really bad code
13:19:02 <mm_freak> if (x:xs) = [[y]], then the head element is [y], because it's the head element of [[y]]
13:19:07 <mm_freak> there you go =)
13:19:12 <mcstar> everyone is proficient in lists, so it seems
13:19:43 <bmm> Thanks everybody for the quick response!
13:20:13 <mm_freak> dylukes: i always have a makefile‚Ä¶  nothing wrong with that
13:20:57 <hpaste> ‚ÄúErtugrul S√∂ylemez‚Äù pasted ‚ÄúMakefile for Cabal packages‚Äù at http://hpaste.org/70751
13:21:03 <mm_freak> dylukes: see the paste
13:21:08 <hpaste> bana pasted ‚ÄúProfiling report‚Äù at http://hpaste.org/70752
13:21:14 <mm_freak> you can add cabal test and cabal haddock, if you wish
13:21:19 <mm_freak> add it to the first rule
13:22:01 <hpaste> bana pasted ‚ÄúHaskell Bioinformatics Filter‚Äù at http://hpaste.org/70753
13:22:03 <mcstar> mm_freak: whats .PHONY for?
13:22:14 <mm_freak> mcstar: 'all' is always built
13:22:29 <mm_freak> even if dist/setup-config didn't actually change
13:22:38 <mcstar> ah
13:22:42 <mcstar> so no -B ?
13:22:42 <hpaste> bana pasted ‚ÄúPython Bioinformatics Filter‚Äù at http://hpaste.org/70754
13:22:48 <mm_freak> yeah
13:23:16 <geekosaur> mcstar, .PHONY is a fake target; dependents are known not to have files associated, so even if you accidentally have a file with the same name it won't suddenly switch to timestamp based checking
13:23:19 <hpaste> obk pasted ‚ÄúMysterious required type annotation‚Äù at http://hpaste.org/70755
13:23:31 <geekosaur> 7nd3HeQa
13:23:33 <hpaste> bana pasted ‚ÄúExample Data‚Äù at http://hpaste.org/70756
13:24:00 <geekosaur> ...
13:24:10 <obk> Any hints on why GHC requires that type annotation would be appreciated.
13:24:17 <Peaker> anyone used criterion? Is there a way to benchmark an IO action that's stuffed between a setup/teardown that are not benchmarked?
13:25:04 <bana_> I'm trying to do some bioinformatics data processing and I can't get my Haskell code any faster than half as fast as my python version. -> http://hpaste.org/70753 http://hpaste.org/70754 http://hpaste.org/70752 http://hpaste.org/70756
13:25:14 <bana_> There is the haskell, python, profiling, and example data
13:25:27 <mm_freak> obk: because otherwise it can't decide which type to use‚Ä¶  this is sometimes required in the presence of type classes
13:25:35 <obk> edwardk: Did you consider generalizing ^. to support (a -> b) as well as Lens a b ?
13:25:48 <Peaker> obk, your "magic" type is polymorphic enough that it could be anything..  GHC works with an open world assumption regarding instances
13:26:17 <obk> mm_freak: Is there a way I can help it short of an explicit type annotation? It seems like giving it an (a -> b) should have been enough to figure out what "a" and "b" were...
13:26:21 <shachaf> obk: Sounds like you want a functional dependency/associated type?
13:26:26 <mm_freak> obk: in fact if you write "print 0", then it infers (Num a, Show a) => a for the '0'‚Ä¶  it's only through a mechanism of default instances that this works and is defaulted to Integer
13:26:28 <bana_> I'm using bytestring, and the python isn't spending much time in C libraries. I've warmed up the cache too, so I'm not sure why the Python is still twice as fast
13:26:39 <shachaf> As in class Magic c a b | c -> a b or something.
13:26:48 <mm_freak> obk: for your class there is no such mechanism‚Ä¶  it's only available for certain base classes like Num
13:27:00 <obk> Hmmm.
13:27:15 <Peaker> @type \f -> catMaybes . map f
13:27:17 <lambdabot> forall a a1. (a1 -> Maybe a) -> [a1] -> [a]
13:27:22 <Peaker> @type mapMaybe
13:27:22 <mm_freak> obk: there are nicer ways to write the type annotation though
13:27:24 <lambdabot> forall a b. (a -> Maybe b) -> [a] -> [b]
13:27:43 <mm_freak> nested = magic record _foo :: Nested
13:27:55 <obk> mm_freak: Sure, but I'm trying to avoid them altogether.
13:28:01 <mm_freak> or:  magic (nested :: Nested) _bar
13:28:25 <obk> I don;t suppose using type families could help here?
13:28:30 <bana_> timings are: http://hpaste.org/70757
13:28:46 <shachaf> obk: If you make the class Magic c a b | c -> a b, it works without the annotation.
13:28:51 <mm_freak> obk: well, type inference in haskell is smart, but in this century you won't be able to tell it:  "do what i mean" =)
13:28:58 <shachaf> Maybe associated types would be nicer here.
13:29:25 <obk> Ah, the famous {-# LANGUAGE DWIM #-} extension :-)
13:29:27 <Peaker> bana_, Python doesn't need the \'s at end of line if ( is open
13:29:34 <bana_> I thought about writing a stackoverflow question but thought I'd try my luck here to see if I was missing anything obvious first.
13:29:39 <obk> shachaf: Now you are telling me :-)
13:29:45 <bana_> Peaker: Good to know, thanks :)
13:29:45 <mm_freak> yes, fundeps and ATs can help in this specific case, but they can't help in general
13:30:04 <mm_freak> obk: the proper way is not to overspecify types in the first place =)
13:30:05 <avpx> obk: Interestingly, that extension is actually going to be in the next release of GHC
13:30:05 <lambdabot> avpx: You have 1 new message. '/msg lambdabot @messages' to read it.
13:30:26 <Botje> bana_: my first thought would be to use strict ByteStrings and read line per line explicitly
13:31:06 <shachaf> obk: This also works: class Magic c where { type Src c; type Dst c; magic :: Src c -> c -> Dst c }; instance Magic (a -> b) where { type Src (a -> b) = a; type Dst (a -> b) = b; magic a f = f a }; ...
13:31:06 <mcstar> theres a lot of pack there
13:31:09 <obk> What do you know, using fundeps worked.
13:31:22 <Peaker> bana_, maybe you can add  -auto-all -caf-all to your profiling options?
13:31:25 <bana_> Botje: I tried strict bytestrings, but I am working with 11GB files, so I'm not sure if that would work
13:31:27 <obk> Thanks a bundle guys.
13:31:36 <mcstar> bana_: the haskell code looks considerably more complex than the python one
13:31:39 <bana_> Peaker: okay I'll get that on hpaste
13:31:42 <mcstar> im sure you can do better
13:31:51 <Botje> bana_: strict per line, right
13:32:13 <Peaker> bana_, lazy I/O is my usual suspect :)
13:32:37 <Botje> I'm also wary of the C.unlines.
13:33:04 <hpaste> bana_ pasted ‚Äúmore detailed profiling‚Äù at http://hpaste.org/70758
13:33:07 <mcstar> Botje: and how about the many .packs?
13:33:22 <Botje> mcstar: hopefully compiler hoists them out as constant
13:33:56 <mcstar> the python version is straightforward, i dont think i could understand the algorithm from the haskell one
13:34:10 <bana_> Botje: So convert each line to a strict bytestring, operate on that, and then convert back to a lazy for writeout?
13:34:36 <bana_> mcstar: Yes, I was disappointed in the Haskell version too, I'm not sure how to make it more elegant though.
13:35:01 <Peaker> bana_, why do you use "$!" there?
13:35:19 <Botje> bana_: might as well write it out explicitly, if you're reading explicitly
13:35:20 <bana_> oh, I was trying to add some strictness for the profiling (to better see where the actual time was being used)
13:35:25 <bana_> but it didn't make a difference
13:35:39 <Peaker> bana_, you could transliterate the Python one to Haskell as-is, though "!!" is ugly :)
13:36:02 <chris2> i want to left factor an attoparsec grammar rule that looks like  Foo <$> bar <*> ... <|> bar  into  bar ... (Foo ... <|> ...). which operators do i need?
13:36:05 <bana_> Botje: I'll try the strict line convesion real quick
13:36:24 <bana_> Peaker: I could do that, but I doubt that would be any faster than the pattern matching though right?
13:37:17 <Peaker> it's weird that interact is so expensive
13:37:27 <Peaker> why is main's self-time 39%?
13:37:41 <bana_> Peaker: I think that is because of laziness
13:37:48 <Peaker> bana_, I hate lazy I/O, I would use conduits for this
13:38:00 <Peaker> let me try to convert it to conduits
13:38:04 <bana_> Peaker, yes that is one thing I had considered. I guess it is the next step
13:38:08 <bana_> ooo that would be great
13:38:32 <kallisti> Peaker: since you're using interact I'm guessing the code is pretty simple?
13:38:37 <kallisti> if so I would use strict bytestrings.
13:38:41 <kallisti> likely simpler than conduits.
13:38:47 <Peaker> bana_, also, use OverloadedStrings
13:39:00 <bana_> kallisti: the text files are 11GB+
13:39:00 <Peaker> kallisti, read up the discussion, he's handling 11GB of data
13:39:12 <kallisti> ah
13:39:16 <kallisti> try lazy bytestring then?
13:39:17 <bana_> so strict bytestrings maybe aren't the best solution (although I do have the RAM for it?)
13:39:23 <bana_> thats what I have:
13:39:31 <bana_> I'm trying to do some bioinformatics data processing and I can't get my Haskell code any faster than half as fast as my python version. -> http://hpaste.org/70753 http://hpaste.org/70754 http://hpaste.org/70752 http://hpaste.org/70756
13:39:34 <kallisti> ah. nevermind. don't pay attention to me. I'll be over in the corner.
13:39:39 <bana_> kallisti: ^^
13:39:44 <bana_> no problem :)
13:43:20 <kallisti> I suspect pare is not being as efficient as it could be.
13:44:49 <bana_> kallisti: Yes, if I replace everything after the Just with a C.pack "hey" then the runtime drops from 0.7 to 0.2 seconds
13:45:10 <bana_> but I don't see any smoking bullets within pare
13:45:24 <hpaste> Peaker annotated ‚ÄúHaskell Bioinformatics Filter‚Äù with ‚ÄúHaskell Bioinformatics Filter (annotation)‚Äù at http://hpaste.org/70753#a70759
13:46:31 <bana_> Peaker: ahh yes the overloaded strings are a nice touch :)
13:47:00 <Peaker> bana_, and a bunch of subjective style "fixes" :)
13:47:12 <bana_> yes I like those too :)
13:47:20 <kallisti> blaze-builder would reduce the overhead from bytestring concatenations.
13:47:23 <hpaste> Peaker annotated ‚ÄúHaskell Bioinformatics Filter‚Äù with ‚Äúhlint police‚Äù at http://hpaste.org/70753#a70760
13:48:26 <jfischoff> what is the best way to managed a bunch of cabal projects so I can get parallel builds?
13:48:48 <bana_> kallisti: thats true... let me look into that
13:49:29 <kallisti> bana_: dlist as well reduces list concatenation to O(1)
13:50:51 <kallisti> bana_: efficient Haskell code rests on the shoulders of some highly optimized libraries.
13:51:31 <jfischoff> it might be interesting to see what you can get if you just set scoreFilter = C.unlines . C.lines
13:51:36 <bana_> kallisti: indeed, I guess Bytestring alone wasn't quite tall enough for my purposes in this case
13:52:11 <kallisti> lazy Bytestrings handle concatenations a bit better than strict, but there's still a lot of copying going on.
13:52:53 <kallisti> a lazy bytestring is just a sequence of strict bytestring chunks, essentially.
13:53:00 <bana_> jfischoff: real: 0m0.061s from 0.7
13:53:20 <jfischoff> well that's a good sign :)
13:53:22 <kallisti> so concatenating them will copy the spine of the list.
13:53:29 <edwardk> obk: how?
13:54:05 <kallisti> bana_: another approach would be to switch strictly to IO. so instead of building up a single lazy bytestring you do a series of putStr calls.
13:54:25 <bana_> kallisti: so switch to imperative style?
13:54:26 <jfischoff> anyone know how I would go about using the cabal install parallel build fanciness with cabal-dev?
13:54:47 <kallisti> bana_: not necessarily. you could for example return a sequence of bytestrings in the filter function
13:55:01 <kallisti> then mapM putStrLn
13:55:04 <kallisti> *mapM_
13:55:14 <bana_> ahhh
13:55:20 <bana_> lets see
13:56:08 <kallisti> but yes I suspect a lot of overhead is happening because of unlines and intercalate calls.
13:56:16 <ThePro> > let lucky 7 = "LUCKY NUMBER SEVEN!"; lucky x = "Sorry, you're out of lucl, pal!" in lucky 7
13:56:17 <lambdabot>   "LUCKY NUMBER SEVEN!"
13:56:21 <ThePro> > let lucky 7 = "LUCKY NUMBER SEVEN!"; lucky x = "Sorry, you're out of lucl, pal!" in lucky 10
13:56:22 <lambdabot>   "Sorry, you're out of lucl, pal!"
13:56:26 <parcs`> jfischoff: cabal in HEAD can do parallel builds at the package level
13:56:37 <jfischoff> parcs`: yeah I'
13:56:38 <jfischoff> m
13:56:47 <jfischoff> not exactly sure how to utilize it though
13:57:21 <parcs`> jfischoff: -j NUM
13:57:29 <parcs`> you can pass that in via cabal-dewv
13:57:49 <parcs`> not tested, but it should work, maybe :)
13:57:59 <jfischoff> what I'm unsure of is how to have it pick up on the packages that need to be reinstalled
13:58:15 <jfischoff> these are local packages I'm editing
13:59:21 <parcs`> you can point to a package via the directory it's residing in
13:59:31 <parcs`> so cabal install ../my-local-package1/ ../my-local-package2/
14:00:23 <jfischoff> hmm so I would tell it recompile all of my packages and it would only do the ones that it needs to?
14:00:30 <parcs`> yeah
14:00:38 <jfischoff> sounds easy enough
14:01:07 <edwardk> preflex: xseen luite
14:01:07 <preflex>  luite was last seen on freenode/#haskell-blah 10 hours, 14 minutes and 56 seconds ago, saying: oh cool, i'll try bottle again soon then
14:03:19 <hpaste> Peaker pasted ‚ÄúWith conduits and strict IO‚Äù at http://hpaste.org/70762
14:03:25 <bana_> you can pass that in via cabal-dewv
14:03:37 <Peaker> bana_, Try that -- hopefully I didn't break anything --
14:03:41 <Peaker> bana_, I didn't actually check performance
14:03:47 <bana_> okay let me try...
14:06:04 <bana_> Peaker, is this against conduit 0.5?
14:07:30 <Peaker> bana_, yeah
14:07:39 <Peaker> not sure if I rely on anything from 0.5
14:07:59 <bana_> may the heavens smile down on me today, I am mixing cabal packages with ubuntu's haskell-platform
14:08:43 <bana_> okay it worked
14:08:56 <bana_> Peaker: nice! 0.395 sec
14:09:04 <roconnor_> @hoogle set
14:09:05 <lambdabot> Data.Bits setBit :: Bits a => a -> Int -> a
14:09:05 <lambdabot> Control.OldException setUncaughtExceptionHandler :: (Exception -> IO ()) -> IO ()
14:09:05 <lambdabot> Data.Set module Data.Set
14:09:08 <roconnor_> @hoogle get
14:09:08 <lambdabot> Prelude getChar :: IO Char
14:09:09 <lambdabot> System.IO getChar :: IO Char
14:09:09 <lambdabot> Prelude getContents :: IO String
14:09:23 <Peaker> bana_, does it work, I mean, give correct result?
14:09:26 <Peaker> bana_, I may have messed it up
14:09:34 * obk pings edwardk 
14:09:42 <edwardk> pong
14:09:53 <edwardk> re ^., what was your proposal?
14:10:24 <obk> Well, I found it very useful to be able to apply ^. to (a -> b) as well as Lens a b.
14:10:35 <obk> Well, not only for ^.
14:10:39 <edwardk> obk: using what machinery?
14:10:49 <edwardk> obk: e.g. what is the signature of ^. then?
14:10:49 <Peaker> bana_, maybe it's fast because it doesn't do what it should? :) Also 0.395 compared with that?
14:11:01 <obk> Ah, that's what I was working on.
14:11:09 <bana_> the other times are:
14:11:14 <obk> I started with http://hpaste.org/70755
14:11:21 <hpaste> d-snp pasted ‚ÄúUsing =<<‚Äù at http://hpaste.org/70763
14:11:30 <obk> But as people pointed out, this needs to be beefed up with fundeps.
14:11:40 <edwardk> obk: your instances will overlap in undispatchable ways if you want the van laarhoven lenses
14:11:46 <d-snp> I'm trying to be cool and do some IO without do-notation
14:11:53 <d-snp> does that look alright?
14:11:54 <edwardk> obk: you can make it work with data-lens enses
14:12:06 <obk> How so?
14:12:14 <Peaker> d-snp, the hlint warnings are worth fixing :)
14:12:25 <edwardk> obk: but the point of the van laarhoven lens writeup was that you can make a simple function to lift a -> b into a fake lens that works with ^
14:12:27 <obk> Can I make (a -> b) become Lens a b somehow?
14:12:28 <edwardk> er ^.
14:12:32 <bana_> 0m0.633s for putStrLn like kallisti was saying, 0m0.708s for the original, 0m0.439s for the Python, and 0m0.373s for PyPy
14:12:45 <obk> Is there a URL I could look at for this?
14:12:50 <edwardk> (1 :+ 2, 3) ^. fstLens . getting magnitude
14:12:52 <edwardk> sure
14:12:59 <Peaker> bana_, so we're still not beating PyPy :)
14:13:02 <edwardk> that will use magnitude even though its just a function
14:13:04 <obk> Ah, found a PDF
14:13:06 <Peaker> bana_, but does it give the correct result?
14:13:18 <edwardk> http://comonad.com/reader/2012/mirrored-lenses/
14:13:18 <bana_> the output looks correct, but diff is showing a difference
14:13:19 <Peaker> bana_, you are compiling with -O2, right?
14:13:22 <bana_> Peaker: yes
14:13:37 <Peaker> bana_, a difference means it is incorrect, doesn't it?
14:13:48 <edwardk> obk: that covers polymorphic lenses, getters, setters, and 'modifiers' in a framework where you can compose them with (.) and id from Prelude, not a Category
14:14:09 <hpaste> bana_ pasted ‚Äúdiff for Peaker‚Äù at http://hpaste.org/70764
14:14:16 <bana_> I'm... not sure what to make of this
14:14:23 <edwardk> obk: 'getting' is the key for lifting a function into a Gatter
14:14:24 <obk> Hmmm - I also planned on heavy use of the monadic versions. Is this covered as well?
14:14:26 <edwardk> er Getter
14:14:42 <edwardk> my honest answer is that the monadic versions just don't make sense
14:14:47 <d-snp> Peaker: I'm so scared it gets my brackets wrong I put brackets everywhere >_>
14:14:54 <edwardk> i don't comprehend the laws when they are extended to monadic lenses
14:15:03 <edwardk> nobody really does
14:15:22 <Peaker> bana_, the diff'd lines seem identical. Must be some whitespace issue?
14:15:37 <edwardk> the modifiers i talk about there are how i work around the lack of monadic lenses, they let you do a lot of the crap you can do with 'multilenses' or partial lenses
14:15:43 <jfischoff> edwardk: you mean like partial lenses or more generally?
14:15:43 <edwardk> but they compose cleanly
14:15:44 <bana_> Peaker: agreed, so good enough for me (maybe a tab at the end)
14:16:00 <edwardk> jfischoff: partial lenses are pretty much the only one i do comprehend from a law perspective
14:16:15 <Peaker> bana_, maybe blaze-builder or such can speed up the inner function now..
14:16:17 <edwardk> they are (Store b :+: Identity) coalgebras
14:16:25 <Peaker> bana_, I am speculating a profile will show that "main" no longer takes much time
14:16:38 <Peaker> bana_, and I think this program proves that my "lazy I/O is usually the culprit" thing :)
14:16:46 <Peaker> (is right again)
14:16:49 <obk> I have a more practical point of view right now; I have a bunch of monadic code using a state which contains nested records, with fields that need to be modified, and I want to do it "cleanly" syntax-wise.
14:16:58 <Peaker> d-snp, the type system means that if you mess up parens, you'll get a type error, so it's ok :)
14:17:18 <Peaker> d-snp, also, prefix sticks stronger than infix, that's one really easy rule to remember
14:17:19 <edwardk> erm, there isn't a problem accessing nested records in state with lenses
14:17:53 <kallisti> bana_: yeah I recommend blaze builder for this
14:17:59 <edwardk> that is kind of their raison d'√™tre
14:18:01 <kallisti> or possibly conduits like Peaker said
14:18:12 <Peaker> kallisti, yeah I wrote a conduits one and it sped things up a lot
14:18:34 <edwardk> so if you mean the lens code for accessing parts of state, that can work this this approach
14:18:36 <Peaker> kallisti, but the inner processing function remains the same, and can probably be sped up with the blaze-builder thing
14:18:58 <edwardk> preflex: xseen twanvl
14:18:58 <preflex>  twanvl was last seen on freenode/#haskell 3 days, 1 hour, 23 minutes and 38 seconds ago, saying: IMO it's a bug that intToDigit doesn't work up to 36
14:19:07 <hpaste> bana_ pasted ‚Äúnew timings for Peaker‚Äù at http://hpaste.org/70765
14:19:13 <bana_> Peaker: Yes I believe you are right, thanks for all the help! Here are some timings using a million lines
14:19:27 <mcstar> i started to rewrite too
14:19:57 <twanvl> edwardk: you rang?
14:20:01 <roconnor_> edwardk: it works even better with state monadoids.
14:20:14 <edwardk> oh just rambling about 'van laarhoven lenses' again ;)
14:20:18 <edwardk> roconnor_: =)
14:20:36 <obk> edwardk: Maybe I'm missing something... So far it seems to me I need to do something like "value <- focus topRecordField $ focus nestedRecordField $ access FinalField", for example.,
14:20:41 <bana_> mcstar: what approach are you taking?
14:20:57 <edwardk> focus and access can still be written for the van laarhoven lenses i talked about there
14:21:03 <obk> Instead of "value <- topRecordField ?? nestedRecordField ?? finalField"
14:21:07 <mcstar> bana_: the simpler the better, but i think i suck at it
14:21:09 <edwardk> those aren't the 'monadic' lenses i was complaining about
14:21:11 <obk> FSWO "??"
14:21:14 <kallisti> Peaker: can I get a link to the conduit version?
14:21:16 <obk> Ok...
14:21:24 <Peaker> kallisti,  http://hpaste.org/70762
14:21:29 <roconnor_> obk: value <- access $ topRecordField . nestedRecordField . FinalField
14:21:42 * obk smacks head
14:21:45 <edwardk> and what roconor said
14:21:53 <kallisti> bana_: what's up with all the ignored list fields?
14:21:56 <obk> Ok, what about modifications?
14:22:09 <edwardk> you can modify then composed with . too =P
14:22:10 <bana_> kallisti: They aren't necessary (nor available) for the downstream analysis
14:22:28 <bana_> kallisti: but are in there to maintain compatibility with the standard file format
14:22:28 <obk> That is, topField %= (+1) would work, what would be the equivalent for a nested one?
14:22:34 <roconnor_> topRecordField . nestedRecordField . FinalField ~= 7
14:22:40 <edwardk> topField . nextField . barField %= (+1)
14:22:51 <obk> That's oh so obvious in retrospect :-)
14:23:11 <obk> I wasn't rearing my thinking hat, was I ;-)
14:23:12 <roconnor_> obk: it's okay; functional programming with lenses seems to be in its infancy.
14:23:14 <bana_> kallisti: oh the *ignored* ones, those are just extra data that we don't need :) quality scores etc..
14:23:24 <kallisti> ah okay
14:23:59 <obk> Well, this seems to cover what I need, I think...
14:24:00 <jfischoff> parks`: thanks that was what I was looking for
14:24:21 <jfischoff> parcs`: got parallel builds going
14:24:21 <mcstar> bana_: how should i test it?
14:24:28 <roconnor_> obk: in general focus is used when calling a "subroutine"
14:24:34 <edwardk> roconnor_: re the family code you sent me, i have to admit the names seem a little 'noisy', i presume its because you are trying to avoid the rank 2 types?
14:24:37 <obk> Yes, that makes more sense
14:24:49 <obk> It all does, now that you explained it
14:24:57 <bana_> you an put it on hpaste and I can run it, or you could copy and paste these sample lines a few thousand times: http://hpaste.org/70756
14:25:08 <roconnor_> edwardk: ya, I just added a rank2 module ... presumably I want a separate packages for Haskell 98 and Haskell+
14:25:10 <obk> However the associativity of ^. is still wrong ;-)
14:25:17 <parcs`> jfischoff: nice, glad to hear it works
14:25:20 <edwardk> what if we just give up and make it rank 2
14:25:26 <edwardk> its not that big of a loss
14:25:37 <jfischoff> parcs`: don't know if it actually faster, but I bet it is
14:25:37 <edwardk> and it greatly increases legibility
14:25:38 <obk> edwardk: Many thanks!
14:25:50 <edwardk> then the th module can live separately
14:25:52 <roconnor_> obk: the associativity of ^. was fixed in 2.9.0
14:26:01 <obk> Really? Awesome!
14:26:38 <roconnor_> edwardk: well, I don't think having the two packages is so bad ... yet.  I'm still trying it out.
14:26:50 <obk> I can get rid of my data-lens-utils module, then.
14:26:52 <edwardk> well, its 3 if you want to push th into another
14:27:11 <mcstar> bana_: that data hangs the python version
14:27:13 <edwardk> rank 2 is a lot more common than TH support
14:27:18 <roconnor_> edwardk: One thing I'm torn about is whether or not to provide specialized versions of function for Lens signatures in addition to the general LensFamily signatures.
14:27:29 <mcstar> bana_:  IndexError: list index out of range
14:27:36 <bana_> mcstar: try killing the last line, I may not have grabbed it entirely
14:27:37 <roconnor_> edwardk: I was planning on 3 packages.
14:27:37 <edwardk> i'd just provide the lens family functions
14:27:40 <edwardk> since they work on lenses
14:28:00 <roconnor_> hmm
14:28:03 <edwardk> and then the only thing a lens is is something using the more restricted type aliases
14:28:15 <roconnor_> sounds reasonably
14:28:25 <roconnor_> I'll remove the specialized versions on my next pass
14:28:26 <edwardk> that was why in my write up i just provided the general combinators
14:28:46 <mcstar> bana_: i think theres an extra \n after each line
14:29:17 <bana_> mcstar, ohh my terminal wrapped the lines I bet
14:29:57 <edwardk> so its lens-family lens-family-extras? and lens-family-th?
14:30:20 <edwardk> or lens-families?
14:30:42 <roconnor_> lens-family-core; lens-family (the rank2 stuff) and lens-family-th
14:30:56 <edwardk> sounds good
14:31:08 <hpaste> bana pasted ‚ÄúExample Data‚Äù at http://hpaste.org/70766
14:31:18 <bana_> mcstar: okay try that one
14:31:22 <edwardk> now all we need to do is get rank 2 types added to haskell 2013 or so ;)
14:31:51 <roconnor_> edwardk: they will once GHC moves to using lens-family in it's source code.
14:32:01 <edwardk> =)
14:32:17 <edwardk> i already use lenses in my compilers, they are behind the times ;)
14:32:18 <roconnor_> I wonder when the depencency between lens-family and containers will be reversed!
14:32:53 <roconnor_> edwardk: I'm still bewildered that lenses were not popularized 15 years ago.
14:33:01 <edwardk> yeah
14:33:06 <roconnor_> edwardk: I saw papers on Mutators in Haskell back then.
14:33:13 <roconnor_> that were lenes
14:33:14 <edwardk> hrmm
14:33:17 <roconnor_> before B.Peirce named them lenes
14:33:21 <roconnor_> *lenses
14:33:27 <roconnor_> er
14:33:35 <roconnor_> I saw last year papers back then
14:33:43 <roconnor_> I didn't know Haskell existed in 1995
14:34:15 <edwardk> hah in 1995 i started my quest to write a programming language ;)
14:34:41 <edwardk> well, pierce borrowed the lens name
14:35:03 <roconnor_> Kagawa, K. Compositional references for stateful functional programming, ICFP '97
14:35:34 <roconnor_> not even the earliest, but possibly the earliest that was most clearly applicable to functional programming.
14:36:22 <jfischoff> digestion is a slow process
14:37:38 <hpaste> mcstar pasted ‚Äúbiosomething‚Äù at http://hpaste.org/70767
14:37:51 <kallisti> bana_: what's the purpose of (: []) ?
14:38:07 <kallisti> why an empty list or a singleton list?
14:38:16 <mcstar> bana_: i couldnt test it, the python fails with the new data set too
14:38:21 <bana_> Peaker, I'm not sure that was Peaker's doing
14:38:36 <bana_> mcstar: let me try
14:38:44 <hpaste> obk pasted ‚Äúdata lens access of nested state fields‚Äù at http://hpaste.org/70768
14:39:22 <Peaker> kallisti, bana_: I replaced the Maybe with [] so I could use concatMap
14:39:28 <obk> edwardk: Sorry for being dense, I must be missing something - access $ top . nested doesn't seem to work
14:39:29 <Peaker> I didn't see a Conduit version of mapMaybe
14:39:43 <Peaker> kallisti, bana_: So I just concatMap'd and used (:[]) and [] in place of Just and Nothing
14:39:49 <monochrom> I started learning haskell in the early 200x
14:40:52 <bana_> mcstar: do you know an easy way to get a file on a pastbin?
14:41:08 <shachaf> obk: Wrong (.)?
14:41:11 <mcstar> bana_: i use sprunge for cleartext
14:41:14 <roconnor_> obk: I think you need to import Prelude hiding ((.))  and import Control.Category
14:41:32 <obk> Oh...
14:41:41 <shachaf> obk: import Prelude hiding ((.),id); import Control.Category ((.),id)
14:41:43 <roconnor_> obk: the nice thing about the lens-family library is that it will actually use the Prelude's (.)
14:41:55 <roconnor_> what shachaf said is better
14:42:41 <obk> Yes, that worked.
14:42:47 <shachaf> Your composition order is still backwards.
14:43:14 <shachaf> You can use (Control.Category.>>>) to do composition the other way, I guess.
14:43:33 <bana_> mcstar: http://sprunge.us/YCMc
14:44:50 <obk> shachaf: So it was.
14:45:10 <bana_> mcstar: the first 70 lines work, and then it gives another index out of range (I'm not sure why...)
14:45:12 <obk> Yes, it works now. But I'd hate to have to do all these imports in every module...
14:45:15 <roconnor_> shachaf: is it really backwards?
14:45:20 <mcstar> bana_: yes
14:45:39 <shachaf> roconnor_: (mid . bot . int)? Looks like it.
14:45:42 <shachaf> "int" is the innermost field.
14:46:34 <kallisti> bana_: the strings passed to pare are relatively small right?
14:46:38 <roconnor_> shachaf: so r ^. a ^. b === r ^. (b . a) ?
14:47:02 <bana_> yes, less than 300 chars
14:47:03 <obk> I guess I could import the Category (.) and re-export it as some other operator that works in the reverse order - say, (^:), so I could write them in a natural order and also avoid having to mess with the Prelude imports every time.
14:47:17 <obk> (Inside some utility module, that is)
14:47:26 <roconnor_> @type (<<<)
14:47:28 <lambdabot> forall (cat :: * -> * -> *) b c a. (Control.Category.Category cat) => cat b c -> cat a b -> cat a c
14:47:31 <shachaf> obk: Control.Category already has (>>>).
14:47:36 <roconnor_> obk: use (>>>)
14:48:03 <roconnor_> edwardk: is the order of operations for composition backwards with van laarhoven lenses?
14:49:03 <roconnor_> OMG it is
14:49:14 <shachaf> roconnor_: Yep.
14:49:22 <roconnor_> this is going to be a little confusing ...
14:49:31 <roconnor_> :(
14:50:15 <obk> You can say that again :-) BTW, >>> failed to compile -  Expected type: State Top Int       Actual type: Lens Top Int
14:50:44 <edwardk> roconnor_: yes
14:50:51 <edwardk> roconnor_: its actually pretty good
14:51:01 <edwardk> foo^.bar.baz.quux means what an oop developer expects
14:51:01 <roconnor_> edwardk: well it works nicely with ^.
14:51:04 <shachaf> obk: Maybe an infixity thing? Does it still happen if you add parentheses?
14:51:16 <roconnor_> edwardk: maybe it means all the other lens libraries are backwards
14:51:20 <edwardk> roconnor_: did you adopt my infixl 8 version for ^. and ^$ i didn't check
14:51:25 <roconnor_> edwardk: yep
14:51:32 <roconnor_> even changed my blog post
14:51:43 <edwardk> sweet =)
14:52:16 <roconnor_> but I kept the parenthesis in the post for pedagocial purposes
14:52:27 <obk> Yes, it was the relative precedence with %=
14:52:37 <edwardk> the main thing i like is that
14:52:38 <roconnor_> obk: shit
14:52:42 <edwardk> foo^.bar.baz.quux works right
14:52:44 <edwardk> and that
14:52:56 <edwardk> foo.bar.baz %= quux $ quaffle
14:52:59 <edwardk> works
14:53:19 <edwardk> so i can code paren free even with the functional versions
14:53:26 <obk> With the category (.) and with the reverse order, yes?
14:53:50 <obk> edwardk: The prec problem was when using >>> to get the "right" field order.
14:54:01 <roconnor_> infixr 1 >>>, <<<
14:54:04 <obk> It worked fine with the Category (.)
14:54:06 <edwardk> obk: well, a twanvl lens is Functor f => (b -> f b) -> a -> f a -- so they compose 'backwards'
14:54:13 <obk> (except the order was reversed)
14:54:34 <shachaf> twanvlens
14:54:35 <obk> Well, "backwards" though it may be, it makes for readable code :-)
14:54:40 <roconnor_> obk: the order for compostion will be reversed with the lens-family library that I'm working on ... just to make your life hellish
14:54:40 <edwardk> this makes ^.'d chains of . mean what an oop developer expects
14:54:53 <obk> Exatly
14:54:56 <edwardk> and it isn't clear how to flip it, so i like it ;)
14:55:14 <roconnor_> I guess OOP got one thing right after all
14:55:15 <Phlogistique> if fmap always equivalent to (flip (<<<)) when types match up?
14:55:22 <Peaker> bana_, I replaced the intercalate and concat with blaze
14:55:25 <Peaker> bana_, wanna try?
14:55:26 <edwardk> i wish get/set weren't so overloaded or i'd make getting and setting use those names instead of the gerunds
14:55:41 <roconnor_> edwardk: I just removed get and set from my library. :/
14:55:51 <obk> Well, I could define (^:) to be (flip (.)) and give it the right precedence ;-)
14:55:57 <hpaste> mcstar pasted ‚Äúbiostuff‚Äù at http://hpaste.org/70769
14:56:04 <bana_> Peaker, yes please :)
14:56:07 <edwardk> roconnor_: doesn't matter so much, the State monad like to use the get name and i don't like making people mix those qualified
14:56:08 <obk> That would be hack-ish though
14:56:28 <nand`> the way I intuitize the ‚Äúreversed order‚Äù for van laarhoven lenses is by considering, say, ‚Äòa‚Äô a projection from your field to the inner product, and ‚Äòb‚Äô a projection from the inner product to the outer product, then ‚Äòb.a‚Äô is a projection from the field to the outer product
14:56:31 <roconnor_> edwardk: I'm hoping people prefer the operators
14:56:32 <mcstar> bana_: could you try that? it only differs in \t i think
14:56:32 <Peaker> mcstar, that's unlikely to perform well, the lazy I/O bit is really really slow
14:56:41 <Peaker> mcstar, (when compared with conduits)
14:56:50 <mcstar> idk what conduits are
14:56:51 <nand`> but I'm not sure how accurate this is
14:56:55 <Peaker> mcstar, at least, that's what happened earlier when I merely switched the lazy I/O to conduits
14:56:56 <edwardk> roconnor_: well i know that the snap guys were why we added the named versions in the first place
14:57:05 <edwardk> roconnor_: so i wouldn't bank on it
14:57:05 <obk> rconnor: I certainly do, that's the main attraction for me
14:57:05 <roconnor_> oh
14:57:11 <Peaker> mcstar, it's a library to handle data streaming instead of the horrible hack of lazy I/O
14:57:19 <edwardk> i'd originally been operator-only in data-lens
14:57:41 <jfischoff> Peaker: did you see how fast it went with just unlines . lines?
14:57:42 <edwardk> with lens-family do you have the state combinators yet?
14:57:46 <roconnor_> well if the snap guys want to use lens-families they can define their own named versions themselves :D
14:57:54 <Peaker> jfischoff, doesn't a rewrite rule get rid of that?
14:57:54 <jfischoff> Peaker: not sure if lazy IO is the issue
14:57:56 <edwardk> =P
14:57:58 <roconnor_> edwardk: nope; state combinatores are next on my list
14:58:08 <roconnor_> I just finished the stock lenses
14:58:12 <obk> roconnor: How far is lens-family from being usable?
14:58:15 <edwardk> sweet, once those are in i'll start switching my code over
14:58:26 <roconnor_> obk: It needs state monad code
14:58:35 <edwardk> obk: probably a day worth of coding
14:58:39 <hpaste> Peaker pasted ‚ÄúWith blaze concat‚Äù at http://hpaste.org/70770
14:58:40 <jfischoff> Peaker: maybe ‚Ä¶ but would you not see the raw performance of lazy IO that way?
14:58:55 <roconnor_> edwardk: I'm thinking of putting StateT stuff in -core and MonadState in the rank2 lib
14:59:00 <edwardk> roconnor_: if i can get you to put it on github i can contribute much more easily ;)
14:59:06 <obk> Is it in hackage?
14:59:19 <roconnor_> edwardk: hmm, I guess there is that whole fd vs tf issue :/
14:59:32 <edwardk> roconnor_: go fundeps
14:59:33 <roconnor_> obk: nope, but it is in darcs
14:59:35 <edwardk> monads-tf is dead
14:59:37 <Peaker> jfischoff, Maybe, but in an uninterestingly simple case (identity function on the lazy chunks)
14:59:38 <kallisti> bana_: http://sprunge.us/hOYC?haskell  try this out
14:59:41 <edwardk> mtl is the future =P
14:59:45 * hackagebot schedyield 0.1 - Exposes standard POSIX function sched_yield.  http://hackage.haskell.org/package/schedyield-0.1 (MichalGajda)
14:59:48 <Peaker> jfischoff, his profile showed that main/interact was taking 40% of the runtime
14:59:58 <edwardk> that was part of the judgment when we killed monads-tf and made monads-fd into mtl
15:00:01 <Peaker> jfischoff, I'm pretty sure that's a lazy I/O thing, otherwise I can't explain it
15:00:14 <roconnor_> edwardk: well, I guess that solves that issue
15:00:33 <obk> Well, I have ~10k LOC using data-lens right now...
15:00:33 <roconnor_> obk: if you want to see my development: darcs get http://r6.ca/lens-family
15:00:46 <roconnor_> obk: but it is seriously under development
15:00:49 <roconnor_> undocumented
15:00:50 <obk> And I do need the state monad variants :-)
15:01:00 <roconnor_> and I'm moving stuff around as it grows
15:01:22 <roconnor_> but if you want to experiment to see what is coming, that would be reasonable.
15:01:25 <obk> Is lens-family a sign of conversion of best practices for lenses, or is it a sign of increasing fragmentation? just asking ;-)
15:01:40 <obk> I don't mind switching my code.. once :-)
15:01:40 <Peaker> bana_, http://hpaste.org/70770 -- did you try that?
15:01:41 <edwardk> obk: we honetly think its a better design than data-lens
15:01:54 <roconnor_> obk: I wouldn't use it unless you have a need for polymorphic updates.
15:02:00 <roconnor_> (yet)
15:02:09 <obk> makes sense.
15:02:19 <edwardk> the main thing it brings to the table is easier mixing of non-lens getters with lenses
15:02:31 <edwardk> and a slightly easier way to define lenses
15:02:36 <roconnor_> edwardk: I'm pretty sure the main thing is polymorphic updates :D
15:02:36 <obk> I think for now I will work around the reversed (.) problem by defining my own (^<something>), and will wait for lens-families to be done, then switch.
15:02:37 <alpounet> edwardk, i guess it uses the design you exposed in your latest post?
15:02:43 <bana_> I'm working on all 3, just a sec
15:02:44 <edwardk> alpounet: yeah
15:02:59 <Peaker> I hate this Haskell feature:  data Rec a = Rec { .. multiple uses of "a" here .. }    "Rec" should be a type synonym for a structural/anonymous record which is free to change any field type
15:03:05 <edwardk> polymorphic updates work regardless. we could change data-lens to support polymorphic update, the problem is then it ceases to be a Category
15:03:12 <kallisti> Peaker: the extra list isn't really needed. you can just return mempty on the empty cases.
15:03:26 <Peaker> kallisti, good idea
15:04:10 <hpaste> Peaker pasted ‚ÄúWith kallisti's tip‚Äù at http://hpaste.org/70772
15:04:18 <edwardk> what i like about the lens-family design is that getters/setters/modifiers/lenses all compose with (.) and id and do the right thing, and the api is easy to implement in a haskell 98 library
15:04:36 <roconnor_> edwardk: except for the cloning thing
15:04:40 <Peaker> bana_, your example input doesn't work for me, btw (on any code sample)
15:04:46 <mcstar> Peaker: you are wasting electronic paper
15:04:49 <obk> Anyway, it is 01:00 here, and I have a working day tomorrow (that is, today). Working on the ultimate HW simulator in Haskell, no less. Either it will be done by the end of the month or I'll have some explaining to do. Thanks for all the help!
15:04:55 <edwardk> well, cloning is only necessary if you want to use the lenses in haskell 98 code
15:05:17 <bana_> Peaker, yes I went through this with mcstar, I have one on sprunge that works for the first 70 lines:
15:05:21 <edwardk> often i want to supply lenses into my types in 98, but use them in an executable where anything goes.
15:05:24 <bana_> Peaker: http://sprunge.us/YCMc
15:06:00 <ocharles> edwardk: you say "(.) and id" do the right thing, meaning that lens-family meets category laws?
15:06:02 <edwardk> and cloning enables the guy who needs to supply a complex lens from his haskell 98 code to be able to do so
15:06:10 <mcstar> bana_: my solution doesnt look sophisticated(bc. it isnt) but id still love to know how badly it fares
15:06:17 <hpaste> bana_ annotated ‚Äúnew timings for Peaker‚Äù with ‚Äúnew timings for Peaker (annotation)‚Äù at http://hpaste.org/70765#a70773
15:06:26 <edwardk> ocharles: lens-family meets the category laws, but also that they are composed using (.) and id from Prelude, not even Control.Category
15:06:36 <ocharles> oh, yummy
15:06:48 <edwardk> ocharles: which makes it extra easy to use
15:06:58 * ocharles nods
15:07:05 <bana_> mcstar: its about 12.2 seconds
15:07:14 <bana_> see the paste above  for the other timings (3-4 secs)
15:07:15 <parcs`> how does updating multiple fields look like with lens-family?
15:07:15 <edwardk> ((0,1:+2),3)^.fstLens.sndLens.getting magnitude
15:07:34 <edwardk> parcs`: same as before
15:07:37 <bana_> kallisti: yours has: kallisti: kallisti.hs:(29,1)-(31,57): Non-exhaustive patterns in function intercalate'
15:07:42 <mcstar> bana_: the bigger the number the better, right? XD
15:07:45 * obk waves
15:08:08 <kallisti> yes ignore me.
15:08:11 * kallisti sits in corner.
15:08:28 <edwardk> parcs`: updating nested fields works with just fstLens . sndLens ^= 2 $ ((1,()),3)
15:08:30 <Peaker> mcstar, The lazy I/O is a performance killer
15:08:32 <bana_> Peaker, so the blaze builder is actually slower than plain conduit
15:08:59 <Peaker> bana_, ah, it's the first time I ever use blaze builder :)
15:09:14 <bana_> heheh, well it was a good attempt, not that much slower
15:09:17 <Peaker> bana_, I guess just converting from bytestrings to blaze just for the concat is not a good idea :)
15:09:18 <parcs`> edwardk: is a function like (&&&) possible, to combine two lenses into one?
15:09:20 <kallisti> most likely the input is too small for blaze to really be effective.
15:09:22 <edwardk> parcs`: but multiple fields still requires separate accessor uses, due to the lens laws not allowing arbitrary tensoring
15:09:32 <edwardk> parcs`: same problem is as data-lens. its just not legal
15:09:41 <kallisti> I suggested blaze before conduit was being used. if you wanted to build the entire lazy bytestring for output you would want to use builder.
15:09:48 <edwardk> consider fstLens &&& fstLens
15:09:55 <parcs`> doesn't fclabels get away with it? (its lens type is an Arrow)
15:10:06 <edwardk> they lie through their teeth and claim it
15:10:10 <parcs`> boo
15:10:16 <edwardk> its just a lie though
15:10:16 <roconnor_> edwardk: btw, twanvl was right; defining (***) is a pain
15:10:25 <mcstar> Peaker: so you think by omitting Lazy from the bytestring import it would be significantly faster?
15:10:27 <edwardk> roconnor_: =)
15:10:31 <bana_> Peaker, I wonder how awk would fare here, I'd have to learn it first, but it seems like a good 'fit'
15:10:38 <roconnor_> edwardk: I just wrote a definition w
15:10:49 <roconnor_> edwardk: I just wrote a definition that was correct; I'll worry about efficent later
15:10:57 <edwardk> oh yeah you have that tensor type in there
15:11:25 <edwardk> did you put in modifying?
15:11:32 <hpaste> Peaker pasted ‚Äúup-to-date without blaze‚Äù at http://hpaste.org/70774
15:11:39 <edwardk> 'modifying map' is pretty handy
15:11:59 <roconnor_> what is modifying?
15:12:03 <bbrittain> "(!!): index too large" Is there a way to tell which statement that is happeneng at?
15:12:15 <edwardk> its in the mirrored lenses post
15:12:16 <Peaker> mcstar, Well, it would not work because the input size is 11GB
15:12:16 <ocharles> bbrittain: with ghci you can break on exception, iirc
15:12:34 <Peaker> mcstar, what do you mean by wasting electronic paper?
15:12:51 <mcstar> Peaker: noway that it transforms 11GB in 2-4 seconds
15:12:55 <roconnor_> edwardk: oh no I didn't
15:12:57 <Peaker> mcstar, why?
15:13:06 <roconnor_> edwardk: you really think write-only lenses are useful?
15:13:06 <edwardk> modifying (`Map.adjust` "hello") ^= 12 $ Map.fromList [("hello",10),("goodbye",12)]
15:13:08 <bana_> mcstar: it's all cached in memory
15:13:14 <edwardk> roconnor_: modifying is quite useful
15:13:17 <edwardk> Setters are not
15:13:22 <edwardk> i'd include modifying
15:13:27 <edwardk> maybe renamed to setting
15:13:30 <mcstar> bana_: oh
15:13:31 <roconnor_> ok
15:13:32 <bana_> mcstar: having 96GB of RAM is sometimes useful :)
15:13:32 <kallisti> Peaker: while you're at it try builderToByteStringWith reuseBufferStrategy
15:13:51 <mcstar> bana_: is there some technique to keep it in memory between runs?
15:14:04 <bana_> mcstar: the kernel does it automagically
15:14:08 <edwardk> modifying map is useful because it lets you dodge most of the crap uses for multilenses
15:14:20 <mcstar> bana_: linux?
15:14:26 <bana_> mcstar, yes.
15:14:26 * monochrom barely had 96MB of RAM just 10 years ago
15:14:39 <Peaker> kallisti, ah, I gave up on the blazer, all I use it for is replacing the intercalate, which is probably optimized anyway
15:14:54 <edwardk> setting map . fstLens %= (+1) $ [(1,"hi"),(2,"there)]
15:14:59 <Peaker> kallisti, and perhaps chunking up the output lines, which is probably optimized too
15:15:07 <mcstar> Peaker: that was just a remark, that you made a new paste from a little modification....
15:15:09 <edwardk> for instance
15:15:12 <bana_> Peaker, is your new one any different than the old conduit?
15:15:16 <edwardk> (using the renamed modifying)
15:15:24 <Peaker> mcstar, oh, not sure how to avoid that
15:15:29 <roconnor_> ok
15:15:33 <Peaker> bana_, It uses mempty instead of the extra list wrapper
15:15:34 <edwardk> roconnor_: that is something you can't write otherwise
15:15:42 <mcstar> Peaker: on the other hand, if he has 96GB than he might be able to use strict bytestrings
15:15:43 <Peaker> bana_,  I doubt it makes much of a difference, but maybe slight
15:15:55 <Peaker> mcstar, Sure, but that's not a scalable approach
15:16:02 <roconnor_> interesting
15:16:03 <mcstar> Peaker: you can annotate the pastes
15:16:04 <edwardk> roconnor_: since you can't write a setter that takes a list since it may have the wrong length
15:16:08 <roconnor_> this library is awesome :D
15:16:11 <edwardk> =)
15:16:59 <edwardk> did you use Identity/Const or a renamed newtype?
15:17:06 <kallisti> bana_: try replacing builderToByteString with builderToByteStringWith reuseBufferStrategy  in one of the conduit + blaze versions
15:17:28 <roconnor_> the thing about lenses, the whole idea of reusing names for fields still kinda goes out the window when you can pass them around as parameters to functions.
15:17:42 <roconnor_> edwardk: I made my own newtypes
15:17:46 <edwardk> k
15:17:47 <bana_> Peaker, the new one  with mappend and mempty is maybe a tiny bit slower (3.72 vs 3.70)
15:17:47 <edwardk> good
15:17:50 <bana_> kallisti, okay
15:17:58 <roconnor_> edwardk: I did consider making type aliases for Const and Identity
15:18:02 <roconnor_> I'm not sure what is best
15:18:05 <jaredc> can anyone point me to a good document that describes the haskell execution model. i want to understand how time and space complexity can be determined, how to avoid space leaks, etc. for example, i understand how a c/c++ compiler generates assembly and i think this gives me insights into time and performance.
15:18:14 <edwardk> i prefer the newtyped versions
15:18:17 <edwardk> just because its clearer
15:18:25 <jaredc> i've got some links to something called stg. is that in the right direction?
15:18:26 <Peaker> bana_, you could try benchmarking with criterion to get more accurate results
15:18:30 <edwardk> otoh, it means that the user needs to depend on the library to provide lenses
15:18:42 <roconnor_> edwardk: ya, they are almost sort of internal to the library
15:18:44 <edwardk> while with Identity/Const they can provide getters/setters without depending on the library at all
15:18:51 <kallisti> bana_: I'm tempted to try unsafeBuilderToBytestring, but I'm uncertain if our use case makes it usable.
15:18:52 <edwardk> well
15:19:03 <edwardk> they have to depend on the library to provide limited 'getters' and 'setters'
15:19:10 <roconnor_> Perhaps I shouldn't export the constructors/destructors
15:19:10 <edwardk> which perhaps isn't bad
15:19:16 <geekosaur> jaredc, it's not exact (things have evolved since the original STG) but it's a start
15:19:34 <edwardk> well, if you supply 'getting' and 'setting' then you can do so easily
15:19:52 <bana_> Peaker, that's true but it'd be hard to include Python in that as well...
15:19:59 <edwardk> since that and composition is the only way you need to construct them really
15:20:11 <edwardk> i could live with them being completely opaque
15:20:13 <jaredc> geekosaur, thanks
15:20:48 <mcstar> Peaker: isnt it possible, that somehow python's C io is more efficient than haskell's? im talking about low level stuff
15:21:05 <roconnor_> edwardk: yes, I would provid getting and setting ... though at the moment I call getting, "projector"
15:21:12 <edwardk> ick
15:21:20 <roconnor_> I'll reconsider getting
15:22:04 <mcstar> bana_: could you try not transforming the text, and just measure IO?
15:22:12 <edwardk> ideally getting/setting would be get/set but that collides with everyone
15:22:16 <Peaker> mcstar, possible, but I think conduit IO is very optimized
15:22:34 <roconnor_> edwardk: Right now I'm also defining type Projector a a' b b' = LensFamily Getter a a' b b'
15:22:38 <Peaker> edwardk, Punish open importers :)
15:22:43 <Peaker> edwardk, design for qualified imports?
15:22:51 <Peaker> Lens.get ...
15:22:51 <edwardk> but as getting setting, then they at least sit linguistically where 'get/set' go in oop code. foo^.getBar    vs. foo^.getting bar . getting baz
15:22:54 <edwardk> Peaker: no
15:23:04 <bana_> mcstar, I tried doing that earlier with just a unlines . lines and it was something like 0.2 seconds.
15:23:11 <edwardk> roconnor_: hrmm, there isn't a point in fully indexing a getter though
15:23:27 <Peaker> There's the Data.IORef approach, to put the name in every exported symbol, instead of designing for qualified import
15:23:27 <mcstar> bana_: for haskell and python both?
15:23:28 <roconnor_> fully indexing?
15:23:29 <edwardk> you can get away with just the two parameters
15:23:43 <edwardk> type Getter a b = LensFamily Getter a a b b
15:23:46 <bana_> kallisti, I need to alloca a buffer somewhere... I can do that from within a conduit correct?
15:23:47 <edwardk> er
15:23:50 <jfischoff> bana_: I thought it was .06 secs?
15:23:59 <edwardk> type Getter a b = LensFamily Getting a a b b
15:24:12 <bana_> jfischoff, mcstar, You're right. I was being conservative because I didn't remember exactly
15:24:16 <edwardk> (this was also why i named the newtypes Getting and Setting)
15:24:19 <edwardk> rather than Getter and Setter
15:24:27 <bana_> mcstar, that was only haskell, I'll try python
15:24:36 <Peaker> bana_, lines . unlines might be optimized to nothing
15:24:36 <edwardk> since Getter and Setter are more useful names for the user to see, and Getting/Setting are only used internally
15:24:50 <edwardk> and it then complains that getting isn't equal to setting ;)
15:24:51 <kallisti> bana_: just pass allocBuffer to the function
15:25:03 <edwardk> which makes a better nominalization in the error message ;)
15:25:05 <jfischoff> I'm getting a linker error in a executable. Its missing the definitions that are in the associated library. I'm pretty sure this working before, any ideas?
15:25:12 <jfischoff> using cabal
15:25:14 <roconnor_> edwardk: ok
15:25:25 <mcstar> Peaker: i see, conduit totally replaces standard IO
15:25:54 <bbrittain> ocharles, that was extremelly helpful, thanks!
15:25:56 <bana_> mcstar, now with a million lines, haskell (Just lazy io) is 0.57 seconds
15:26:14 <Peaker> bana_, lines . unlines?
15:26:34 <Peaker> mcstar, I think it probably re-uses existing IO when that is optimized.. snoyman put effort into optimizing conduit stuff
15:26:41 <edwardk> roconnor_: i dont mean to bikeshed so many thngs, i just want to be able to use the library =)
15:26:46 <kallisti> bana_: so builderToByteStringWith (reuseBufferStrategy allocBuffer)
15:26:50 <bana_> Peaker, yes
15:27:04 <bana_> mcstar, pypy io is 1.0 seconds for 1M lines io
15:27:09 <roconnor_> edwardk: Should I have the order of the parameters the same order as lenes or the order they actually occur in?
15:27:16 <edwardk> and since you beat me to packaging it, i'm stuck manipulating it by proxy ;)
15:27:41 <edwardk> i kept them consistent throughout all the aliases in my writeup
15:28:15 <bana_> kallisti, my bad :) okay running
15:28:15 <roconnor_> type Setter a d b = (() -> Setting d) -> a -> Setting b -- not consistent
15:28:26 <edwardk> the a b c d in mind are (outer original)  (outer revised) (inner original) (inner revised)
15:28:40 <edwardk> oh yeah forgot about that one
15:28:42 <edwardk> i hated Setter
15:28:45 <roconnor_> :)
15:28:50 <kallisti> bana_: I doubt it will help. :(
15:28:53 <edwardk> kill it with fire
15:28:59 <edwardk> and just name Modifier Setter ;)
15:29:10 <Peaker> maybe "a b c d" -> "or of ir if" (outer record, outer field, ...) ?
15:29:18 <bana_> kallisti, my bad :) okay running
15:29:27 <edwardk> i don't like Setter because it breaks the family structure as well
15:29:40 <bana_> kallisti, 4.93 seconds :(
15:29:55 <rwbarton> how many bytes are in these million lines
15:30:07 <kallisti> bana_: yeah conduit can probably use builders better than I can. can you pass me the conduit only version? I have a possible improvement to try.
15:30:22 <edwardk> rwbarton: at least a million ;)
15:30:47 <kallisti> bana_: basically to use conduit more and bytestring concatenation less.
15:31:07 <mcstar> bana_: so, whats your purpose btw? you want to scale to terrabytes?
15:31:17 <bana_> kallisti: Peaker's most recent conduit only version is: http://hpaste.org/70774
15:31:19 <mcstar> i mean, you already have a killer python version
15:31:49 <bana_> mcstar, you're right of course. I just wanted to see how much faster we could go.
15:32:36 <Peaker> bana_, how about trying to get rid of the linked list + pattern matching?
15:33:04 <bana_> mcstar, my lower bound at cat <file> | cut -f 19 > /dev/null is 0.8 seconds
15:33:28 <mcstar> so haskell is cheating
15:33:51 <bana_> Peaker, I think the only way to do that (which is maybe worth a try) is a tail recursiv/imperative method
15:34:05 <bana_> mcstare, cheating?
15:34:25 <mcstar> bana_: you said haskell finishes in 0.57 secs
15:34:26 <Peaker> bana_, could try Array.fromList on the output of split and hope it fuses
15:34:30 <jfischoff> I wonder what the memory allocation looks like
15:34:52 * roconnor_ =>> sleep
15:34:56 <bana_> mcstar, that is with no processing, the cut is actually parsing the fields and selecting one
15:35:01 <kallisti> bana_: what version of conduit is this?
15:35:15 <bana_> kallisti, 0.5
15:35:22 <edwardk> roconnor_: night man
15:35:25 <mcstar> bana_: maybe you could try a cat | wc -l ?
15:35:35 <rwbarton> why are you using an extra "cat"
15:35:47 <mcstar> bad habit
15:36:07 <rwbarton> I wonder how much slower it makes it
15:36:11 <bana_> head -n 1000000 file | wc -l is 0.22
15:36:41 <rwbarton> how many bytes is head -n 1000000 file ?
15:36:41 <bana_> quite an informative number it spits out too :P
15:36:47 <mcstar> bana_: so this is the same as the haskell 0.57? then clearly haskell IO is 2 times slower
15:36:53 <Peaker> what's the simplest instance of IArray?
15:37:05 <bana_> rwbarton, 155471046
15:37:12 <rwbarton> oh okay
15:37:33 <bana_> mcstar, yes that is true
15:38:43 <parcs`> doesn't conduit have performance problems?
15:38:43 <mcstar> so i suspect that the difference between python and haskell is indeed caused by IO slowness
15:39:13 <bana_> mcstar, but the python is even slower at 1.0 seconds
15:39:14 <bana_> (pypy)
15:39:32 <bana_> 0.5 seconds cpython
15:39:36 <mcstar> bana_: for 1M lines? i thought that was for the whole 11GB
15:39:45 <bana_> just 1M lines
15:39:51 <bana_> sorry
15:39:55 <rwbarton> can you even cat an 11 GB file to /dev/null in 1 second?
15:40:17 <rwbarton> I guess maybe
15:40:18 <mcstar> hes got a shitload of memory XD
15:40:32 <rwbarton> still have to copy the file into the cat process right
15:40:38 <bana_> rwbarton, 2.0 seconds :)
15:40:42 <rwbarton> yeah
15:40:47 <rwbarton> okay
15:40:52 <rwbarton> these times seem more real-world to me now :)
15:41:12 <shachaf> Can't cat use vmsplice() or something like that?
15:41:30 <Nereid> 11000000000 bytes (11 GB) copied, 0.860396 s, 12.8 GB/s
15:41:30 <Nereid> ;>
15:41:38 <mcstar> bana_: isnt perl widespread in bioinformatics?
15:42:43 <bana_> whole file io: cpython 28 secs, haskell 37 seconds
15:43:05 <bana_> mcstar, actually the original version of this script is in perl written by someone else, I haven't even tried to benchmark it
15:43:05 <kallisti> @hoogle sequence
15:43:05 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
15:43:05 <lambdabot> Control.Monad sequence :: Monad m => [m a] -> m [a]
15:43:06 <lambdabot> Prelude sequence_ :: Monad m => [m a] -> m ()
15:43:09 <mcstar> 11811160064 bytes (12 GB) copied, 6.73511 s, 1.8 GB/s
15:43:13 <bana_> Nereid, how'd you manage that?
15:45:03 <mcstar> i seriously need to upgrade my rig..
15:45:12 <bana_> 11000000000 bytes (11 GB) copied, 1.22335 s, 9.0 GB/s
15:45:17 <Nereid> bana_: dd /dev/zero to /dev/null
15:45:27 <Nereid> ;>
15:45:37 <parcs`> might wanna play with the block size
15:45:44 <Nereid> with a large block size yes
15:45:53 <mcstar> 1GB
15:45:57 <Nereid> not that large
15:46:15 <kallisti> I could have sworn that sequence was a function in conduit.
15:46:18 <kallisti> it must have vanished.
15:46:37 <Nereid> oh wow, 100k block size is faster, 0.70s. :P
15:46:38 <rwbarton> I get 0.9 seconds with a 1M block size and 8 seconds with a 10M block size
15:46:45 <rwbarton> cache effects I guess
15:46:48 <sipa> $ dd if=/dev/zero bs=2097152 of=/dev/null count=2048
15:46:53 <sipa> 4294967296 bytes (4.3 GB) copied, 0.249147 s, 17.2 GB/s
15:47:09 <kallisti> Peaker: instead of constructing bytestrings you could attempt to use conduit's yield function
15:47:41 <mcstar> lets try 64K, thats my L1 cache size
15:47:47 <Eduard_Munteanu> shachaf: I guess it could though splice isn't implemented for all filesystems
15:48:03 <mcstar> 13107200000 bytes (13 GB) copied, 1.83791 s, 7.1 GB/s
15:49:33 <bana_> I can't get over around 9GB/s
15:49:50 <mcstar> lets try memory bandwidth
15:50:00 <mcstar> thats what i measure first, basically
15:50:02 <mcstar> d
15:50:30 <Peaker> kallisti, There's the intercalate there
15:50:47 <Peaker> kallisti, don't think yield is any different to map there
15:51:06 <kallisti> Peaker: I mean instead of intercalate just yield each piece one at a time.
15:52:18 <mcstar> bana_: why dont you put the + '\n' inside the .join()?
15:53:03 <bana_> mcstar, no need, plus the original file has the newline right up against the last field too, so I figured I'd be consistent
15:53:42 <Peaker> kallisti, probably much slower, esp. since I'd need to yield the "\t"s too
15:53:51 <mcstar> bana_: i mean wouldnt it be faster?
15:54:09 <bana_> I'm going to step out for a bit, thank you all very much for your help! I'll still skulk around in case anyone has any other things they want me to try before bed.
15:54:40 <bana_> mcstar, how so?
15:55:35 <mcstar> well, you create a vector with the strings, then concatenate to a string, and append a "\n|
15:55:43 <mcstar> but i think it needs to copy the string
15:55:57 <mcstar> id add the "\n" inside the vector
15:56:49 <Peaker> bana_, I use criterion so I can get feedback on my changes here
15:56:56 <Peaker> bana_, I get 920 micro for the 70 lines you gave
15:57:13 <Peaker> (with just conduits). arrays make it slightly slower
15:57:24 <mcstar> isnt this fields[10][:-3][3:] equaivalent to fields[10][3:-3]?
15:57:49 <Peaker> bana_, at this point I guess one would dive into the assembly to see how it looks like
15:57:58 <Peaker> bana_, (and the core)
15:58:00 <kallisti> Peaker: more silly ideas:  you could intersperse the "\t"  and then instead of concat convert to LBS.
15:58:09 <Peaker> bana_, what were the final numbers w.r.t the diff from Python and PyPy?
15:58:22 <Peaker> kallisti, I don't think Conduits handles LBS
15:59:06 <Peaker> kallisti, also, the overhead of intercalate is probably smaller than the overhead of lots of little bytestrings output from the pipe?
16:05:57 <kallisti> Peaker: makes sense.
16:08:17 <bana_> Peaker, the final numbers are here: http://hpaste.org/70765
16:08:33 <bana_> I'll add normal python too
16:09:40 <hpaste> bana_ annotated ‚Äúnew timings for Peaker‚Äù with ‚Äúnew timings for Peaker (annotation) (annotation)‚Äù at http://hpaste.org/70765#a70775
16:10:08 <bana_> So we caught up to Python, but not to Pypy
16:11:05 <bana_> mcstar, doh! you're right about the slicing, silly me
16:11:35 <Peaker> bana_, a bit sad that conduits perform as badly as CPython, and PyPy beats it by a large margin
16:12:11 <bana_> Peaker, I'm thinking about trying R17 and Awk next to see how they compare
16:12:20 <mcstar> bana_: try julia too
16:12:35 <bana_> mcstar, good idea
16:13:09 <bana_> hahah I love this irc chat, so many people like me :)
16:14:10 <kallisti> bana_: which python version btw
16:14:30 <bana_> 2.7.3
16:14:44 <kallisti> Python 3.x would be significantly slower.
16:15:12 <bana_> really? is that from the unicode handling? or something else?
16:15:58 <Peaker> kallisti, there's no excuse to losing to Python on performance :)
16:16:19 <Peaker> kallisti, I am guessing that if there was less glue and more processing, Haskell would have an edge, but this result is pretty horrible...
16:16:22 <mcstar> Peaker: at least the haskell code is correct and succint
16:16:26 <bana_> Peaker, hahah
16:16:47 <kallisti> bana_: I don't actually know why.
16:16:59 <kallisti> it's just significantly slower in all respects.
16:17:08 <kallisti> sources: the internet
16:17:16 <Peaker> mcstar, Python and Haskell are usually roughly as succint.. Python sometimes wins because of easier meta-programming, and Haskell sometimes wins because of more abstraction, but I don't think one is more succint than the other. In this example the Python is no less concise
16:18:03 * kallisti wonders what the results with Text would look like.
16:18:10 <parcs`> wait, ghc is losing to cpython? :O
16:18:12 <Peaker> If Haskell had Python's performance, and Python's conciseness, it would still be a nicer choice than Python IMO because type safety is so important, but Python's performance is generally horrible
16:18:17 <kallisti> most likely slower because of encoding
16:18:31 <Peaker> parcs`, in this particular example, CPython and GHC with conduits have same performance, and PyPy is winning both by a large margin
16:19:04 <parcs`> what's the example?
16:19:13 <Peaker> parcs`, http://hpaste.org/70774  vs.  http://hpaste.org/70754
16:19:13 <kallisti> well this task lends itself well to Python's builtin functions, which are all C code.
16:22:06 <mcstar> Peaker: id only use haskell for this kind of task if i wanted to learn it, i.e. as an exercise, as long as performance is not an issue, i dont see a reason to switch from python, when writing these disposable snippets
16:23:22 <bana_> mcstar, the typesafety and purity is nice however when the little disposables start growing and mutating
16:23:25 <bana_> as they often do
16:23:38 <Peaker> mcstar, you might want to scale the example up into a larger program later. Python makes larger programs a pain
16:24:04 <Peaker> mcstar, large programs usually start as tiny ones where compile-time = run-time so type safety doesn't matter that much
16:24:08 <mcstar> probably im not there yet on the learning curve as you guys
16:24:45 <bana_> you just need a little more koolaid
16:24:54 * bana_ hands mcstar a nice cool glass
16:25:08 <mcstar> glu glu glu
16:25:13 <Peaker> also, when you're practiced -- writing Haskell and writing Python takes roughly the same time initially, but maintaining Haskell is easier, and usually (modulus today's ordeal) performs far better
16:26:00 <mcstar> Peaker: from my performance testng its ~2-3 of naive c++'s performance
16:26:39 <mcstar> (thats a good speed)
16:27:09 <kallisti> this problem is mostly IO bound, which is why Python performs so well
16:27:26 <kallisti> given a CPU-bound problems the results would change quickly.
16:30:50 <ThePro> > let sum' [] = 0; sum' (_:xs) = sum' xs in sum [10, 20, 30]
16:30:52 <lambdabot>   60
16:31:01 * kallisti would be interested to see what happens when you throw parallelism into the mix.
16:31:29 <kallisti> ThePro: wrong sum
16:31:45 <ThePro> kallisti: why wrong?
16:31:51 <kallisti> sum' vs. sum
16:31:52 <ThePro> 10 + 20 + 30 = 60
16:31:54 <kallisti> unless you meant to do that.
16:31:57 <ThePro> oh
16:32:04 <ThePro> > let sum' [] = 0; sum' (_:xs) = sum' xs in sum' [10, 20, 30]
16:32:05 <lambdabot>   0
16:32:08 <ThePro> :(
16:32:30 <ThePro> > let sum' [] = 0; sum' (_:xs) = 1 + sum' xs in sum' [10, 20, 30]
16:32:31 <lambdabot>   3
16:32:43 <kallisti> the function is called length
16:32:45 <kallisti> @src length
16:32:46 <lambdabot> Source not found. Where did you learn to type?
16:32:57 <ThePro> > let sum' [] = 0; sum' (x:_) = x + sum' xs in sum' [10, 20, 30]
16:32:58 <lambdabot>   Not in scope: `xs'
16:33:02 <ThePro> > let sum' [] = 0; sum' (x:xs) = x + sum' xs in sum' [10, 20, 30]
16:33:04 <lambdabot>   60
16:33:06 <ThePro> !
16:33:27 <ThePro> i'm going to understand haskell
16:33:39 <ThePro> the penny is falling
16:34:09 <mcstar> > sum []
16:34:10 <lambdabot>   0
16:34:18 <mcstar> ^^ this is weird
16:34:29 <kallisti> > product []
16:34:30 <lambdabot>   1
16:34:44 <ThePro> why
16:34:56 <ThePro> the empty list is the edge condition for the recursion
16:35:08 <mcstar> im not talking about your case
16:35:13 <mcstar> in general
16:35:16 <Cale> mcstar: what's weird?
16:35:19 <ThePro> also in general
16:35:34 <ThePro> sum is implemented in exaclty that why i did with sum'
16:35:54 <ThePro> *way not why
16:35:55 <mcstar> "the empty list is the edge condition for the recursion" has nothing to do with this
16:36:03 <Cale> sum = foldl (+) 0
16:36:38 <mcstar> 0 is the identity element of addition that way, but if i want to add 0 things...
16:36:49 <mcstar> thats why*
16:37:00 <mcstar> so late
16:37:20 <kallisti> but then what's zero added to 5 things?
16:37:26 <kallisti> er
16:37:30 <kallisti> zero things added to 5 things
16:37:34 <Cale> ... I can't follow this conversation.
16:37:38 <kallisti> undefined behavior?
16:37:46 <rwbarton> I figure it'll sort itself out.
16:37:48 <conal> mcstar: adding n+m things is like adding n things and m things and then adding. right? now let n==0.
16:37:49 <lambdabot> conal: You have 1 new message. '/msg lambdabot @messages' to read it.
16:37:54 <Cale> sum [] = 0 because that's just what the sum of an empty list is.
16:38:04 <Cale> I don't understand how it's weird
16:38:06 <Nereid> we like to have sum (xs ++ ys) = sum xs + sum ys
16:38:09 <Cale> yeah
16:38:51 <conal> and sum of an empty list is somewhat arbitrary, so we choose to define it so that laws work out without exceptions. just like n^0 = 0 (for n /= 0). it's a convenient choice, not a fact.
16:38:52 <Cale> It's practically a definition of what 0 means.
16:39:14 <mcstar> but then there is minimum and maximum
16:39:19 <Cale> It's a convenient choice that we've made into a fact by definition :)
16:39:20 <mcstar> which explode on []
16:39:41 <shachaf> IN AN ALTERNATE UNIVERSE: 0 = sum []
16:39:44 <kallisti> that's because min and max have no identity element.
16:39:58 <kallisti> whereas (+) does
16:40:05 <kallisti> ...or well, should.
16:40:06 <mcstar> you could always test for an empty input list, before passing the list to a recursive auxiliary function
16:40:08 <Nereid> yes they do - maxBound and minBound
16:40:08 <Nereid> ;)
16:40:12 <mcstar> and not having sum [] = 0
16:40:41 <kallisti> Nereid: max doesn't know what that is for any Ord instance, but yes.
16:40:58 <Nereid> and (+) doesn't know what 0 is for any Num instance.
16:41:01 <kallisti> max [] = minBound would be interesting.
16:41:07 <Peaker> conal, got the question about Monoid for TMap?
16:41:08 <pizzaplane> fromInteger 0
16:41:20 <Nereid> I mean the identity for addition.
16:41:26 <kallisti> Nereid: right, but it /should/ be an identity.
16:41:27 <Peaker> conal, I recall "insert" and the Monoid instance from your TCM paper, but I think it's not in the uploaded package
16:41:30 <Nereid> obviously.
16:41:36 <kallisti> Nereid: but no one is forcing it to be, no.
16:42:46 <conal> Peaker: i was just about to reply. I *do* see a monoid instance in my total-map code, but not on hackage. investigating ...
16:43:07 <daniel_-> may i ask what "Portability: non-portable (requires concurrency)" refers to?
16:43:28 <kallisti> probably that it needs Concurrent Haskell (which is a GHC extension)
16:43:48 <daniel_-> so it's not portable between different compilers?
16:43:53 <kallisti> right.
16:44:02 <daniel_-> allrigh
16:44:08 <kallisti> and possibly operating systems without concurrency.
16:44:11 <kallisti> but... who uses those?
16:44:43 <Enigmagic> i maintain the FreeDOS port of GHC
16:44:53 <mcstar> XD
16:44:55 <geekosaur> someone was asking about embedded programming earlier :p
16:44:57 <Peaker> anyone know if conduit can do some preparation IO prior to each benchmark?
16:45:02 <kallisti> geekosaur: I was about to say...
16:45:07 <mcstar> Enigmagic: joke, right?
16:45:17 <kallisti> but do any Haskell compilers target embedded platforms?
16:45:28 <Enigmagic> Peaker: sure? liftIO someAction >> conduit
16:45:39 <geekosaur> nhc98 used to; jhc probably can
16:45:46 <shachaf> It's not about operating systems with concurrency, it's about Haskell environments with concurrency.
16:45:54 <shachaf> Which are probably mostly unrelated things. :-)
16:46:48 <kallisti> hm, yeah. I suppose there's no requirement for an OS to support multithreading.
16:47:02 <Peaker> Enigmagic, oh man, I must be tired. I wrote conduit when I meant criterion :)
16:47:06 <kallisti> GHC could just use one OS "thread.
16:47:18 <Peaker> d'oh!  fixed question "anyone know if criterion can do some preparation IO prior to each benchmark?"
16:47:40 <conal> Peaker: oops. i forgot to commit & release. funny. in the works now.
16:47:53 <Enigmagic> Peaker: it runs them in order so you could add a dummy benchmark between stages
16:48:05 <Peaker> conal, great!  I already hit one example where I wanted to show off elegance of Haskell but Data.Map wasn't very nice
16:48:18 <Peaker> conal, TMap could have probably helped there, but then I saw it missed those
16:48:23 <conal> Peaker: sweet :)
16:48:35 <conal> Peaker: on hackage now.
16:48:49 <Peaker> conal, great, thanks!
16:49:00 <conal> Peaker: thank you, too.
16:49:14 <Peaker> Enigmagic, well, each benchmark of mine does key/value store operations -- so I want to randomize keys/values for the benchmark, but don't care about their costs
16:49:17 <conal> Peaker: i gave a standard monoid-via-applicative instance.
16:49:57 * hackagebot total-map 0.0.3 - Finitely represented /total/ maps  http://hackage.haskell.org/package/total-map-0.0.3 (ConalElliott)
16:50:10 <conal> thanks, hackagebot !
16:50:23 <shachaf> thackagebot
16:50:30 <Peaker> that joke never dies :)
16:51:00 <Peaker> a wise man once said "There is no unfunny joke, there's only a joke that wasn't repeated enough"
16:52:33 <Peaker> conal, btw, is "insert" deprecated in favor of "tabulate" and mappend?
16:52:40 <conal> Peaker: another very minor release in the works now. added a "Data" category. i'd left it blank and hadn't noticed.
16:53:26 <conal> Peaker: hm.
16:53:49 <conal> Peaker: could we define insert via tabulate & mappend, considering that total maps are total?
16:54:57 * hackagebot total-map 0.0.4 - Finitely represented /total/ maps  http://hackage.haskell.org/package/total-map-0.0.4 (ConalElliott)
16:55:18 <Peaker> conal, I'm not sure
16:55:36 <conal> Peaker: me too.
16:58:40 <hpaste> Peaker pasted ‚ÄúYucky insert via fromJust‚Äù at http://hpaste.org/70778
16:59:06 <Peaker> conal, Yucky due to fromJust, but I think that works?
16:59:23 * conal looks
17:00:14 <Peaker> oh wait, that won't work
17:00:28 <Peaker> left-side will be Just on the entire domain and mask the right-side completely
17:00:47 <Peaker> oh it will, damn I need to think more before I write at 3 AM :)
17:01:07 <Peaker> conal, ignore my last comments :)
17:01:13 <conal> Peaker: k
17:02:20 <hpaste> int80_h pasted ‚Äútype are fun‚Äù at http://hpaste.org/70779
17:02:50 <hpaste> Peaker annotated ‚ÄúYucky insert via fromJust‚Äù with ‚ÄúYucky insert via fromJust (annotation)‚Äù at http://hpaste.org/70778#a70780
17:02:53 <Peaker> had a type-error there
17:07:13 <hpaste> Peaker annotated ‚ÄúYucky insert via fromJust‚Äù with ‚ÄúYucky insert via fromJust (Works)‚Äù at http://hpaste.org/70778#a70781
17:07:23 <Peaker> conal, this seems to work -- but it would be nice to get rid of the fromJust
17:07:39 <conal> Peaker: yeah.
17:08:58 <conal> Peaker: maybe combine a TMap (Maybe a) with a TMap a.
17:09:22 <Peaker> I guess the combination needs to be applicative rather than Monoid
17:09:27 <parcs`> bana_: are you able to share a portion of your test input?
17:09:52 <conal> Peaker: yeah. (and Monoid is via applicative in this case)
17:10:15 <conal> Peaker: liftA2 fromMaybe is my guess
17:10:31 <shachaf> TMap still doesn't support iteration, does it? :-(
17:10:53 <conal> shachaf: do you mean the implementation?
17:10:54 <djahandarie> Does ByteString.hPutStr block if it's putting to a really slow handle?
17:11:04 <shachaf> I mean the interface.
17:11:15 <shachaf> (Not that I know a particularly reasonable way to do it. But still.)
17:11:16 <conal> shachaf: no. would be an abstraction leak.
17:11:22 <shachaf> I know. :-(
17:11:22 <bana_> mcstar, Peaker, kallisti, parcs`: We have a new lower bound: 2.0 seconds from R17: sequencer@sequenceanalyze:~/data-kt/lab/solexa_public/Zhou/120515_WIGTC-HISEQA_D0WRBACXX/Eland_Result_Extended$ time r17 try.r17 > /dev/null
17:11:26 <bana_> real    0m2.098s
17:11:26 <shachaf> djahandarie: Block what?
17:11:29 <bana_> user    0m4.656s
17:11:35 <djahandarie> shachaf, the thread
17:11:36 <bana_> oops, my bad wrong window
17:11:42 <shachaf> djahandarie: GHC thread or OS thread?
17:11:45 <djahandarie> GHC thread
17:11:54 <shachaf> By definition, sort of, no?
17:11:56 <hpaste> bana_ pasted ‚ÄúR17, new lower bound‚Äù at http://hpaste.org/70782
17:11:59 <shachaf> It shouldn't block the OS thread.
17:12:09 <conal> shachaf: i.e., interfaces can't expose info outside of semantic models (without abstraction leaking).
17:12:19 <Drakeson> Hello. I am using GHCi and I need some help getting comfortable with Haskell ... ;  Here it goes: 1. How do I get the documentation for a function and for a module?  2. How do I get the source code for a function? (:list function often gives me "cannot list source code for ...")  3. How can I search for a module or a function to import, e.g., given part of its name?  4. How can I find out what modules a package (installed by cabal)
17:12:19 <Drakeson> exposes?
17:12:35 <djahandarie> shachaf, well, I'm just having a hard time figuring out when it hands it off to the OS, and what the OS needs to tell GHC for it to think that everything is ready to go
17:12:44 <shachaf> Drakeson: Hoogle is good for all four.
17:12:46 <shachaf> @where hoogle
17:12:47 <lambdabot> http://haskell.org/hoogle
17:13:08 <shachaf> djahandarie: What do you mean?
17:13:47 <Peaker> conal, this works: insert k v m = tabulate id (Set.fromList [k]) ((const . const) v) <*> m
17:14:00 <djahandarie> shachaf, in this case the Handle is a wrapper around a Socket, which is a TCP connection. Trying to figure out exactly when the hPutStr will allow execution of the Haskell thread to continue
17:14:29 <conal> shachaf: if you have a use of iteration, we can investigate whether there's an alternative that *doesn't* lead to abstraction leak
17:14:38 <Peaker> bana_, if it's doing parallelization (visible via real < user) then it's unfair - you can/should add parallelization to the Haskell solution
17:14:40 <shachaf> djahandarie: If you're doing do { hPuStr handle longThing; ... }, ... will only run when the whole thing is written to the socket.
17:14:50 <daniel_-> is it actually a option to say `two times less than x` instead of `half of x` or `x / 2` (im not a English native speaker, and sorry for OT)
17:15:00 <shachaf> djahandarie: Or are you asking about "is it guaranteed that the other host has received it" or something like that?
17:15:19 <bana_> parcs` I'm not sure why, but I was having problems uploading test cases, here are 70 lines that work though: http://sprunge.us/YCMc
17:15:25 <djahandarie> shachaf, I'm doing hPutStr handle shortThing, but the question is what happens when the TCP connection is really shitty
17:15:45 <shachaf> djahandarie: Ah, so it's a TCP question, not a Haskell question?
17:15:54 <bana_> hahah, yes its true it is doing it in parallel (4.6 sec CPU, 2.0 user)
17:15:55 <djahandarie> shachaf, I don't know, is it?
17:16:01 <Peaker> conal, I might have a use-case -- I have "EventMap"s that map possible input events to responses, and it is a partial mapping (not all possible input events are covered).. I want to be able to generate documentation for the event map (which events are handled and which aren't)
17:16:11 <shachaf> djahandarie: I'm not sure!
17:16:34 <djahandarie> Because I'm pretty sure I have a Socket that is indefinitely blocking right now, and it "killed" my process. So just trying to find what could cause that. No doubt it's some sort of question that involves understanding all parts of the stack.
17:17:09 <shachaf> djahandarie: What you know is that by the time "..." is run, GHC will have done a write() call to the socket, and the OS will have returned "success" for it.
17:17:16 <shachaf> djahandarie: Oh, the issue is that ... is never running.
17:18:02 <shachaf> You have multiple GHC threads and one of them writes to a socket and prevents the others from running at all?
17:18:22 <djahandarie> I have a very simple     forever $ do { (hand, _, _) <- Network.accept sock; B.hPutStr hand (some junk); hClose hand }
17:18:48 <djahandarie> Somehow, that got stuck on a single socket. The thread is still alive, however.
17:18:52 <Peaker> djahandarie, you should bracket that?
17:18:52 <djahandarie> I mean, on a single handle.
17:19:09 <shachaf> djahandarie: Shouldn't you be forkIOing if you want multiple threads?
17:19:34 <djahandarie> The forkIO is elsewhere. This is pretty much the only thing running in the thread
17:20:03 <c_wraith> djahandarie: writing to a TCP socket can block
17:20:04 <shachaf> Wait, shouldn't the forkIO happen *after* the accept?
17:20:27 <c_wraith> and yes, the typical pattern is fork after accept
17:20:29 <djahandarie> c_wraith, right. Do you know how long it can block, and what causes it to block?
17:20:41 <shachaf> It can block forever, presumably.
17:20:47 <shachaf> Or until some timeout happens.
17:20:54 <c_wraith> close enough.  I think TCP timeouts are on the order of 5 minutes
17:20:58 <shachaf> I mean, that's networks for you.
17:20:59 <c_wraith> that might as well be forever
17:21:24 <Drakeson> shachaf: Thanks.  Installing Hoogle ...
17:21:35 <shachaf> Drakeson: You don't really need to install it -- it's online.
17:21:41 <shachaf> (But you can if you want to.)
17:22:03 <Drakeson> shachaf: I would rather read documentation in ghci than in a browser.
17:22:53 <rangergord> sup
17:22:57 <shachaf> Drakeson: Can't really do that.
17:23:04 <shachaf> Well, you can install a ghci macro that'll run commands.
17:23:16 <shachaf> Which I guess is something.
17:24:13 <MostAwesomeDude> Hm. If I'm dealing with forkIO'd threads, but I can't actually get the ThreadIds 'cause they're inside a library, what's the best way to get all the threads to talk to each other?
17:24:43 <parcs`> bana_: try this http://paste.debian.net/177485/
17:24:47 <shachaf> MostAwesomeDude: Pass arguments to the threads?
17:24:50 <c_wraith> having their ids doesn't make it easier to talk to each other
17:24:53 <shachaf> With MVars or something.
17:24:59 <shachaf> ==c_wraith
17:25:05 <rangergord> Not a Haskell person, just curious a bit. I just tried googling for Haskell Qt Examples to see how one would use Qt in Haskell, had no luck finding anything. I'm already familiar with Qt, and it relies on an event loop that various objects pass messages through. How does something like Haskell use that? Anyone have an example of code?
17:25:10 <MostAwesomeDude> Hm.
17:25:40 <MostAwesomeDude> So I'd have some higher-up or easier-to-see MVar, and after each thread comes into being, it'd use the MVar to announce itself?
17:26:28 <parcs`> bana_: it should be more efficient than the conduit one because a bytestring is not concatenated per line. also, iirc enumerators are faster than conduits
17:27:18 <Drakeson> shachaf: Not trying to swim upstream, I should have a browser for hoogle, an editor and a ghci in a terminal (or perhaps in the editor); Does that sound about right?
17:27:21 <kallisti> MostAwesomeDude: threads are only aware of things within their closure. it only has access to the mutable references you provide to it via function arguments or free variables.
17:27:34 <shachaf> Drakeson: You can also use Hoogle locally.
17:27:38 <shachaf> Or through lambdabot!
17:27:41 <MostAwesomeDude> kallisti: This is network-conduit.
17:27:55 <shachaf> rangergord: That's somewhat of a high-level question to ask. I don't know if there are any bindings for Qt.
17:28:07 <MostAwesomeDude> kallisti: http://hackage.haskell.org/packages/archive/network-conduit/0.3.0/doc/html/Data-Conduit-Network.html
17:28:10 <parcs`> bana_: also it makes stdin/stdout operate in binary mode
17:28:20 <MostAwesomeDude> i
17:28:40 <MostAwesomeDude> Erg. In runTCPServer, there's a forkIO that runs things, and part of what it runs is some of my code that's been lifted into there.
17:29:37 <kallisti> MostAwesomeDude: okay. same general principle applies here.
17:30:13 <MostAwesomeDude> kallisti: Okay. So would my inner code (which is still in a MonadIO) just arrange to MVar into a list of threads?
17:30:31 <shachaf> MostAwesomeDude: It depends on how you want them to communicate.
17:30:34 <kallisti> I don't know what that means.
17:30:39 <kallisti> and yes.
17:30:44 <kallisti> it depends on that.
17:30:54 <MostAwesomeDude> Well, I want them to all be aware of each other and to share a couple data structures.
17:31:09 <MostAwesomeDude> Any thread has to let its client know about the existence of the other threads.
17:31:18 <kallisti> MostAwesomeDude: so it's not a queue?
17:31:30 <MostAwesomeDude> kallisti: No, these connections are pretty persistent.
17:31:54 <kallisti> being persistent and using a queue to communicate are not mutually exclusive.
17:31:56 <bana_> parcs`, for some reason, that one was 13.5 seconds compared to cpython 3.6 seconds
17:32:10 <bana_> (compiled with -O2, both on 1M lines)
17:32:18 <MostAwesomeDude> kallisti: Well, they don't really have any messages that they need to send to each other. It's a broadcast-only situation.
17:32:31 <kallisti> MostAwesomeDude: is there more than one message to be sent?
17:32:35 <shachaf> MostAwesomeDude: Well, just make a broadcast channel and pass it to them!
17:32:49 <dgvncsz0f> es
17:32:55 <kallisti> MostAwesomeDude: if so, then you want a single channel.
17:33:01 <kallisti> with many listeners
17:33:49 <MostAwesomeDude> Okay. So I'd make TChan then.
17:33:55 <shachaf> Or a Chan.
17:34:06 <MostAwesomeDude> Well, no, wait, how would I pop a single message off? I'd need a TChan for each listener.
17:34:17 <kallisti> use dupChan
17:34:18 <MostAwesomeDude> Okay, so this isn't any different than most other languages.
17:34:34 <shachaf> Well, what were you hoping for?
17:34:51 <MostAwesomeDude> Not necessarily "hoping," but trying to use patterns that people already use in Haskell.
17:34:56 <shachaf> In some cases you might be able to just pass a lazy list to all the threads. :-)
17:35:13 <MostAwesomeDude> My first draft actually did that! It was hilarious iteratee hax.
17:35:13 <kallisti> @hoogle unsafe-promises
17:35:14 <lambdabot> No results found
17:35:28 <kallisti> @hackage unsafe-promises
17:35:28 <lambdabot> http://hackage.haskell.org/package/unsafe-promises
17:35:30 * kallisti shameless plug.
17:35:51 <shachaf> That looks evil.
17:36:05 <kallisti> I bet it would look less evil if I had used less "unsafe"
17:36:46 <shachaf> If you had *used* less "unsafe", maybe.
17:36:52 <kallisti> MostAwesomeDude: but yes dupChan will create multiple copies of a channel, such that writing data to either channel will make it available to the other.
17:36:55 <shachaf> If you had just *said* less "unsafe", probably not.
17:37:45 <kallisti> shachaf: I don't see how it's so evil.
17:57:11 <ski> kallisti : i don't think it's any more evil than `unsafeInterleaveIO' itself (which i don't think is unsafe in the sense of `unsafePerformIO')
17:59:12 <jmcarthur> it can be pretty unsafe considering that you can in theory trigger *any* kind of side effect in pure code with it
17:59:45 <kallisti> not really
17:59:56 <kallisti> the side-effect occurs immediate as a result of spawning the thread.
18:00:07 <kallisti> the result is always pure.
18:00:52 <kallisti> the main issue is that the thread might not terminate, or produce a meaningful result. In that sense, it's as unsafe as bottom. :P
18:01:11 <jmcarthur> thread? i'm talking about unsafeInterleaveIO
18:01:23 <kallisti> oh nevermind.
18:01:24 <jmcarthur> i didn't mean whatever you came up with :)
18:01:45 * jmcarthur only just got here
18:38:05 * shapr is here too
18:40:24 <sinelaw> aloha!
18:41:18 <Peaker> sinelaw, hey!
18:41:26 <Peaker> sinelaw, I'm exactly going to sleep, quite late :)
18:41:44 <sinelaw> Peaker, hey!
18:55:03 * hackagebot egison 2.1.0 - An Interpreter for the Programming Language Egison  http://hackage.haskell.org/package/egison-2.1.0 (SatoshiEgi)
18:55:05 * hackagebot egison 2.1.1 - An Interpreter for the Programming Language Egison  http://hackage.haskell.org/package/egison-2.1.1 (SatoshiEgi)
19:01:48 <gurrag> Where are lambdabot's @src listings drawn from?
19:02:29 <ion> A text file in lambdabot‚Äôs source.
19:10:04 * hackagebot pnm 0.1.0.0 - PNM image format header parsing and pretty printing  http://hackage.haskell.org/package/pnm-0.1.0.0 (ClaudeHeilandAllen)
19:54:43 <cl1> howdy folks
19:54:58 <cl1> i had to get a new computer, which room is for off topic again?
19:56:47 <parcs`> #haskell-blah
19:57:37 <cl1> ah yes, thanks parcs
20:09:54 <tertl4> for me Haskell works great on windows
20:10:08 <tertl4> is it bad for others/
20:10:11 <tertl4> ?
20:11:25 <cl1> tertl4, i've never had problems with it
20:11:46 <tertl4> some people "you can't do this and that on windows"
20:12:13 <tertl4> but i think GHC is workin pretty good on windows
20:12:25 <tertl4> is there a Haskell add on for VS?
20:12:46 <cl1> didn't the guy in charge of GHC work for microsoft on c# or something for a while?
20:12:54 <cl1> tertl4, no :(
20:13:22 <tertl4> not even syntax highlighting?
20:15:33 <tertl4> well wclipse does
20:19:44 <dmwit> tertl4: GHC works well on Windows. Most people who have trouble with Windows are trying to compile FFI bindings to some library or other.
20:19:51 <dmwit> That can sometimes be a real pain on Windows.
20:20:05 <tertl4> what is FFI library?
20:20:30 <dmwit> FFI bindings are Haskell bindings to C libraries.
20:20:30 <coppro> foreign function interface
20:21:39 <dmwit> Since *nix are built on the idea of building things from source, it has a very robust toolchain for finding and linking libraries; Windows doesn't have this culture, and its toolchain is correspondingly more finicky.
20:34:11 <tertl4> i see dmwit
20:45:09 * hackagebot egison 2.1.2 - An Interpreter for the Programming Language Egison  http://hackage.haskell.org/package/egison-2.1.2 (SatoshiEgi)
21:04:30 <Mortchek> When compiling a short program with ghc (6.12.1), I get "unknown package: haskell98". What causes this? This is the program: main = catch echoLoop (const (return ())); echoLoop = getLine >>= putStrLn >> echoLoop
21:05:53 <Mortchek> It runs fine with ghci and runhaskell.
21:07:59 <tertl4> are you doing C on windows?
21:10:05 <Mortchek> No. I gave the complete Haskell program above. I'm running it on a Debian Squeeze box.
21:11:23 <dmwit> Are you building with cabal?
21:11:39 <dmwit> The haskell98 package isn't really "there" before the GHC's that supported Haskell2010.
21:11:51 <Mortchek> No I'm not. Is there a good reason to do so?
21:12:08 <dmwit> Yes, but not until we've solved this problem.
21:12:12 <dmwit> How are you compiling it?
21:12:14 <Mortchek> I also just discovered that the catch I'm using is apparently deprecated.
21:12:29 <Mortchek> `ghc cat.hs`, where cat.hs is a file containing the above program.
21:13:08 <dmwit> Strange, you don't seem to be asking for the haskell98 package in that command.
21:13:24 <dmwit> Bugger, I don't have a 6.12 install lying around.
21:14:23 <Mortchek> It actually works, albeit with a warning, on my main system, which is running a more recent version of GHC. Perhaps using Control.Exception.catch instead will help.
21:19:20 <Mortchek> No joy. Same error message.
21:19:46 <jfischoff> I'm getting error where I have two packages both with the same module path/name, and there interfaces files (.hi) are being over written.
21:20:07 <jfischoff> is there a workaround?
21:21:16 <dmwit> Mortchek: I can't reproduce your error (just installed GHC 6.12.3).
21:21:37 <dmwit> ghc-6.12.3 test.hs Just Works
21:22:00 <Mortchek> I'll fiddle with it some more.
21:22:02 <dmwit> Mortchek: Maybe you should ghc-pkg check?
21:22:05 <conan> sorry I know this isn't a haskell question, one more about functional programming with OO. I hear that some functional/OO hyrbid languages allow mutation of OO properties, but the change is localised - basically copies the obect and mutates the value, the original object is unchanged. What languages do this, and what's the technique called?
21:22:22 <Mortchek> dmwit, literally run `ghc-pkg check`?
21:22:24 <dmwit> yes
21:22:28 <Mortchek> No output.
21:22:39 <dmwit> That's a good sign.
21:22:44 <dmwit> What does ghc-pkg list haskell98 say?
21:23:26 <dmwit> conan: That doesn't sound like mutation to me. =)
21:23:50 <dmwit> conan: It's called immutability, and many many languages do it. Haskell and OCaml at least offer this.
21:24:12 <hpaste> Mortchek pasted ‚Äúghc-pkg output‚Äù at http://hpaste.org/70784
21:24:22 <conan> dmwit: I'm looking for an example of this done with Objects, so need a functional/object hybrid language.
21:24:32 <dmwit> Mortchek: That looks good, too.
21:24:36 <conan> dmwit: I know haskell has monads, but that's not quite hte same thing.
21:24:41 <dmwit> Mortchek: I must say, I'm a bit stumped.
21:24:44 <AfC> :q
21:24:48 <AfC> oops
21:24:54 <conan> well it's the same thing, just not working at an Object level.
21:25:01 <dmwit> conan: I'm not sure where monads entered the conversation.
21:25:10 * hackagebot wai-middleware-route 0.7.0 - Wai dispatch middleware  http://hackage.haskell.org/package/wai-middleware-route-0.7.0 (AlexanderDorofeev)
21:25:20 <dmwit> I don't see they have anything to do with what I'm talking about.
21:25:25 <MostAwesomeDude> conan: I'm not sure what you mean by "object." I mean, you can build this in Python, but I don't think it's exactly what you're thinking of.
21:25:35 <conan> something like shadowing or overlays. frustrating me, as I can't find the original article i read.
21:25:42 <dmwit> > Sum { getSum = 3 }
21:25:43 <lambdabot>   Sum {getSum = 3}
21:25:47 <dmwit> > Sum { getSum = 3 } { getSum = 4 }
21:25:49 <lambdabot>   Sum {getSum = 4}
21:26:06 <dmwit> Haskell offers the same thing for all record types, not just one with only one value underneath.
21:26:13 <dmwit> Ah, Tree is a good example.
21:26:28 <dmwit> > let x = Tree 3 [Tree 4 [], Tree 5 []] in x
21:26:29 <lambdabot>   Not in scope: data constructor `Tree'Not in scope: data constructor `Tree'N...
21:26:43 <dmwit> > let x = Data.Tree.Tree 3 [Data.Tree.Tree 4 [], Data.Tree.Tree 5 []] in x
21:26:44 <lambdabot>   Not in scope: data constructor `Data.Tree.Tree'Not in scope: data construct...
21:26:46 <dmwit> bleh
21:26:50 <Mortchek> All right, thanks for your help. I'll see if I can eliminate some possibilities.
21:27:13 <dmwit> Anyway, you can write let x = ... in x { nodeLabel = 6 } to get Tree 6 [Tree 4 [], Tree 5 []], for example.
21:27:19 <dmwit> Again, no monads involved.
21:32:26 <Mortchek> Oh, woops. I thought I had made sure that error didn't happen in all programs (that defined main), but apparently it is happening regardless.
21:32:45 <dmwit> Are all polylogarithmic functions sublinear?
21:33:32 <copumpkin> yeah
21:33:55 <copumpkin> according to wikipedia, anyway :)
21:34:30 <dmwit> that seems nice
21:34:30 <Mortchek> I want to start my Haskell packages from scratch, since I have nothing important installed, to see if that helps. How would I do that?
21:34:45 <dmwit> rm ~/.ghc
21:35:10 <dmwit> worst-case scenario you'll have to reinstall GHC (in case you've installed some packages globally)
21:35:31 <Mortchek> I'm doing that also.
21:35:46 <Mortchek> Well there we go. It magically works now.
21:35:46 <dmwit> But if ghc-pkg check doesn't complain, you *should* be in pretty good shape...
21:35:53 <dmwit> Huh, wow!
21:36:10 <ski> conan : i think it's often called "functional update" (though the "functional" part is a misnomer ..) -- e.g. in O'Caml <http://caml.inria.fr/pub/docs/manual-ocaml/manual005.html#toc30>
21:36:19 <Mortchek> It might have been a good idea to inspect the packages I had installed before removing them, since I have a feeling one of those was to blame, but oh well.
21:36:24 <Mortchek> If this happens again I'll do it then.
21:36:32 <Mortchek> Thanks.
21:36:55 <conan> ski: thanks, looking.
21:37:04 <ski> > let x = Node 3 [Node 4 [], Node 5 []] in x
21:37:05 <lambdabot>   Node {rootLabel = 3, subForest = [Node {rootLabel = 4, subForest = []},Node...
21:37:19 <conan> ski: I'm currently researching how to improve functional programming in the Drools rule engine language.
21:37:29 <dmwit> ski: Oh, for crying out loud
21:37:45 <dylukes> oh, not to mention pipes-network is built on a broken lib...
21:37:49 <dylukes> (network-bytestring)
21:37:56 <dylukes> Paolo Capriotti you are beginning to irritate me :<.
21:38:00 <dmwit> dylukes: You're mixing your channels!
21:38:17 <dylukes> Sorry, my inner shachaf subconciously made me come here.
21:38:19 <conan> ski: it's a nice research topic - how to combine production rules, prolog rules and functional programming :)
21:38:20 <dmwit> pcapriotti: Oh, snap, are you just gonna stand there and take that?? ;-)
21:40:14 <ski> conan : also see the notation `{ expr with ¬†field[1] = ¬†expr[1] ; ‚Ä¶ ; ¬†field[n] = ¬†expr[n] }' at <http://caml.inria.fr/pub/docs/manual-ocaml/expr.html>
21:41:17 <conan> ski: thanks, this stuff is great. exactly what I was trying to get. So the setter always clones and returns, with the field's value changed form the previous version. Is there a name for this techqniue?
21:42:00 <ski> conan : for the Haskell record update notation, see <http://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-540003.15.3>
21:42:19 <dmwit> "immutability" in general; "record update" in Haskell; "functional update" in OCaml; probably other things in other languages
21:42:28 <ski> dmwit ?
21:42:54 <dmwit> ski: As far as I can tell, he's just looking for a name.
21:43:00 <dmwit> I don't think there *is* a standardized name.
21:43:54 <dmwit> maybe "deep copy" in C++/Java...?
21:43:59 <dmwit> Though that's not quite the same.
21:44:02 <ski> conan : if you''re doing relational programming, it might be nice to have some syntax saying that `R0' and `R1' are basically the same record, except for fields `a',`b' where values in `R0' are `A0',`B0' and values in `R1' are `A1',`B1'
21:44:38 <ski> conan : also, in any case if you're doing this, please make nested update (records inside records) nice
21:45:48 <ski> dmwit : i'm not sure there is one, either ..
21:45:48 <conan> ski: don't know how much of relational stuff you know. But currently exploring this idea. http://pastebin.com/w02Vuwcr. line 1 and 2 are reactive patterns, where the data flows from the working memory. same for A and B.
21:45:50 <mauke> The paste w02Vuwcr has been copied to http://hpaste.org/70785
21:46:32 <ski> conan : we'll, i suppose you'll have to say i'm a ##prolog regular :)
21:46:38 <conan> ski: so when the Person() object is inserted. it'll select and join with the Cashflow objects. For each Cashflow object, it'll join with all A inserted objects, whre the value is actuallun amount + 1.
21:47:07 <conan> ski: cool :) I'm production rules really, but have merged the two. So now I have reactive prolog rules :)
21:47:29 <ski> forward-chaining ?
21:47:56 <conan> ski: it allows you to leave a derivation tree open and receive incremental updates - in a reactive manner.
21:48:13 <conan> ski: yes, so it facilitates forward-chaining between derivation trees.
21:48:45 <conan> ski: so I can execute a classic graph transitive closure, and even if the resulit is empty, if it becomes true later I get a notification.
21:49:08 <ski> conan : i don't think i can decipher the syntax in that paste
21:50:09 <conan> ski: Person is a reactive pattern, against a ground term Person. each inserted Person will flow through it. Chashflow is another pattern.
21:50:17 <conan> the .{......} is a mutation block.
21:50:26 <conan> so it's saying select all the Cashflows and modify
21:50:50 <conan> line 4. is saying "select the $c instance and modify it"
21:51:33 <conan> line 3 is saying select all the A's where they match all the $c  - but due to the mutation block in line 2. it's acctualy the Cashflow's amount + 1
21:51:40 <conan> ski: am I making any sense yet?
21:52:43 <conan> ski: if not, I'm sorry :( As Drools origin's in production rules. it's pattern oriented. https://hudson.jboss.org/hudson/job/drools/lastSuccessfulBuild/artifact/drools-docs/drools-expert-docs/target/docbook/publish/en-US/html_single/index.html
21:53:47 <conan> if you look at the query section, it shows how we merge production rules and prolog-like queries. https://hudson.jboss.org/hudson/job/drools/lastSuccessfulBuild/artifact/drools-docs/drools-expert-docs/target/docbook/publish/en-US/html_single/index.html#d0e7559
21:54:44 <ski> conan : it's not clear whether `$c' has changed after `$c.{ amount = $c.amount + 1 }'
21:55:28 <ski> also, i'm not sure if those lines are meant to be interpreted as commands, or as some kind of declarative statements
21:55:29 <conan> ski: the original instance never changes. in essence $c.{ amount = $c.amount + 1} will clone $c and update it's amount field.
21:55:37 <ski> (i suppose those two questions are related)
21:55:48 <jfischoff> ClaudiusMaximus: can you make a none file based "rule" with shake that always runs if you pass the name of a rule as an argument?
21:56:05 <ski> yes, but will that make `$c' (As used later) refer to a different object than if ther had been no `$c.{ amount = $c.amount + 1 }' ?
21:57:07 <conan> ski: yes, will be a different object. but remember, I'm just flirting with ideas here, very on-concrete, and this functional aspect is fairly new to me.
21:58:12 <conan> ski: any modfications redeclared the variable, and any join uses the last redeclaration of the variable in the join.
21:58:43 <conan> ski: in essence each join is a nested loop. Each re-declaration (i.e. mutation) will shadow the outer variable.
22:01:39 <dylukes> Why would this need ScopedTypeVariables?
22:01:39 <dylukes> printer :: (Show b) => Frame Void IO (M b) C r
22:02:10 <ski> conan : yes, and the `$c.{ amount = $c.amount + 1 }' doesn't mutate any object in the DB, only the temporary one referenced by `$c' in this computation, yes ?
22:02:42 <conan> ski: yes exactly. the underlying working memory instance has not been mutated. and actually the outer joins will not see the mutations of the inner joins.
22:02:45 <ski> dylukes : with defining equation(s) ?
22:02:53 <dylukes> Nevermind... it went away...
22:02:59 <dylukes> pretty sure it was a bug... I'll look into it more.
22:05:30 <conan> ski: only mutations in the consequence, the action block, are applied to the working memory store. Although we coudl probably do something like just update($c) which would some how apply allow local mutations that were done during the joins, to the real object instance in the WM store.
22:09:30 <ski> hm ECLiPSEe also have some kind of record update <http://eclipseclp.org/doc/userman/umsroot022.html>, but will less sugar than i str
22:12:30 <hpaste> irene-knapp pasted ‚ÄúBut alas‚Äù at http://hpaste.org/70786
22:13:54 <ski> conan : hm, in your example code, iiuc, it's basically saying that "for every object/record/tuple/fact `$p' in `Person', and for every object/.. `$c' in `Cashflow', and for every object/.. in `A' and every object in `B', where (some relating conditions hold, which can be thought of as a join), ---"
22:14:25 <ski> conan : where the idea is that this will be "edge-triggered", i.e. only execute whenever at least one of those relations get another tuple added to them
22:14:28 <conan> ski: yes.
22:14:44 <ski> conan : however, i'm not sure what the "---" will stand for -- what's the end effect ?
22:14:45 <conan> ski: that's how production rules work. each join is reactive, rather than passive like prolog.
22:14:56 <ski> inserting some new tuples into other relations ?
22:15:02 <ski> executing some action ?
22:15:24 <ski> (perhaps actions are executed by "inserting tuples" into special primitive "relations" ?)
22:15:25 <conan> ski: you lost me "---" I did three dashes?
22:15:26 <mewalz> Is it safe to use the standard handles from System.IO (e.g. stdin). I am getting inconsistant results between terminals
22:15:49 <conan> ski: if you want to discuss further, try #drools. as I'm spamming this # too much now on OT stuff :)
22:15:55 <ski> conan : no, but it's not clear to me what to *do* will all these joined tuples ?
22:16:30 <ski> mewalz : should be, afaiui ..
22:17:54 <conan> ski: http://pastebin.com/piUnS5ve
22:17:56 <mauke> The paste piUnS5ve has been copied to http://hpaste.org/70787
22:18:53 <ski> in the latter case, each `$c' resulting from the join is reinserted into `Cashflow' ?
22:19:39 <conan> ski: would be like a table update in a database. which would actually cause recursion ofcourse, the rule would refire. and thus cashflow would keep increasing by units of 2, on each recursion.
22:20:41 <conan> ski: bear in mind I only started thinking about this a few hours ago, none of this exists or has been thought out thorougly. :)
22:21:15 <conan> ski: currently we do not support mutation on the LHS, if you do it (and it is possible) you'll screw things up badly.
22:23:01 <mewalz> hmm--my program only works in emacs
22:27:21 <ski> hm, in Prolog/Datalog terms, it's more or less `cashflow(C2) :- person(P),cashflow(C0),C0:account = P:id,C0 { amount : A0 { A1 = A0 + 1 } A1 } C1,a(A),a:value = C1:amount,C1 { amount : A0 { A1 = A0 + 1 } A1 } C2,b(B),B:value = C2:amount.'
22:27:27 <ski> (using invented notation for records, and record update)
22:27:42 <ski> (using something like Mercury's state variable notation, it might become `cashflow(!:C) :- person(P),cashflow(!.C),!.C:account = P:id,!C { amount : !A { succ(!A) } },a(A),a:value = !.C:amount,!C { amount : !A { succ(!A) } },b(B),B:value = !.C:amount.')
22:28:25 <ski> conan : "the rule would refire. and thus cashflow would keep increasing by units of 2, on each recursion." -- hm, ok so i suppose the rule isn't idempotent, then ..
22:29:30 <ski> conan : iow, can the rule updating `Cashflow' trigger another round of itself ?
22:29:31 <conan> ski: it's forward chaining.
22:29:54 <ski> (yes, i know it's forward chaining -- as is Datalog)
22:30:08 <conan> ski: yes, it recurses. because you've changed Cashflow, it reacts and updates all the child joins too.
22:30:41 <ski> but would it eventually stabilize ?
22:30:58 <conan> ski: with the rule that I wrote, no. not unless there was no matching A or B.
22:31:10 <ski> (and is this the intended effect of writing that rule ?)
22:31:28 <conan> ski as A and B don't change, I assume in that, very poor example I wrote, it would eventually increase to values that have no join satisfication. and thus it would stablise.
22:31:34 <ski> ok, so that rule is then just a silly example showing the idea ?
22:31:40 <conan> ski: it's a very bad example of a rule :)
22:31:46 <conan> ski: yes
22:31:48 <ski> ok
22:32:11 <ski> as long as it doesn't arbitrarily stop unless the "user" inserts a new tuple, i'm happy :)
22:41:30 <ski> (hm, that was to be parsed as "as long as it doesn't (arbitrarily stop unless the "user" inserts a new tuple)", in case it was unclear)
22:43:48 <dylukes> Hey ski,
22:43:53 <dylukes> do you think you could help me grok this?
22:43:54 <dylukes> http://hackage.haskell.org/packages/archive/index-core/1.0.0/doc/html/Control-IMonad-Restrict.html
22:44:37 <dylukes> My confusion starts with "(a := i) represents a locked value of type a that you can only access at the index i."
22:51:51 <AfC> I wish we could convince Haskell to dump a stack trace from the site where an Exception is thrown and/or print that trace having caught that Exception.
22:51:56 <AfC> Seems like we're so close, but...
22:53:47 <Cale> Apart from the fact that there's no stack to trace
22:54:14 <dylukes> I will approach these restricted monads tomorrow...
22:54:16 <Cale> (there's a stack, but it's not a call stack)
22:54:25 <dylukes> I will try to follow the McBride paper and do something with them so they make sense.
22:54:47 <ski> dylukes : hm, `(a := i) j' sounds isomorphic to `(a,Equal i j)'
22:54:48 <dylukes> It doesn't help that pipes uses free indexed monad transformers... way to make things complicated...
22:55:03 <dylukes> := is read "at key"
22:55:18 <ski> dylukes : i'm not yet sure why one'd want to use `\j -> (a,Equal i j)', though
22:55:19 <dylukes> Bind for restricted indexed monads is
22:55:19 <dylukes> (!>=) :: IMonad m => m (a := j) i -> (a -> m (b := k) j) -> m (b := k) i
22:55:22 <dylukes> so...
22:55:41 <dylukes> for an action in imonad m with initial index i and final index a at key j...
22:56:05 <dylukes> and a function taking an a and producing an action with initial index j and final index b at k...
22:56:17 <dylukes> you get an action with initial index i... and final index b, at k.
22:56:30 <dylukes> It makes sense somewhat if I use the analogy of a graph.
22:57:25 <dylukes> It's like the second action being composed can get at `a' because `a' is at index j, which is the initial index of the second action.
22:57:26 <ski> yes, but it doesn't explain why not use `IMonad m => m i j a -> (a -> m j k b) -> m i k b' ..
22:57:40 <dylukes> You can, that's ?>=
22:57:45 <dylukes> !>= is the restricted version.
22:57:49 <ski> we can see the kind of `m' is different
22:57:54 <dylukes> (?>=) :: IMonad m => m a i -> (a :-> m b) -> m b i
22:58:03 <AfC> Cale: (with -prof and call sites etc enabled, Debug.Trace does a fairly decent job {shrug})
22:58:13 <dylukes> (where type :-> a b = forall i. a i -> b i )
22:58:23 <ski> no, that's different from what i said
22:58:43 <dylukes> There is a type R m i j a = m (a := j) i
22:59:01 <dylukes> So I guess you could write
22:59:14 <dylukes> IMonad m => R m i j a -> (a -> R m j k b) -> m i k b
22:59:19 <dylukes> IMonad m => R m i j a -> (a -> R m j k b) -> R m i k b
23:00:05 <dylukes> to me it seems like you've basically got these i and j type indices, and the additional constraint is that they have to match up.
23:00:13 * hackagebot schedyield 1.0 - Exposes standard POSIX function sched_yield.  http://hackage.haskell.org/package/schedyield-1.0 (MichalGajda)
23:00:30 <dylukes> So it's essentially giving you a mechanism for restricting actions based on type level flags.
23:01:48 <dylukes> `Frame r m i j a`
23:02:56 <dylukes> Now what confuses me is the irony that each composed frame must have initial index (M a) and final index C...
23:03:20 <dylukes> and the easiest way to go from C C to (M a) C is to compose close at the beginning.
23:03:33 <dylukes> close for some reason having type (M a) C?
23:04:00 <ski> "I deviate from Conor's terminology, referring to his monads on indexed types as \"indexed monads\" and referring to his indexed monads as \"restricted monads\"." -- ooh, this partly explains my confusion
23:04:49 <dylukes> I saw his terminology before Conor's.
23:05:13 * hackagebot egison 2.1.3 - An Interpreter for the Programming Language Egison  http://hackage.haskell.org/package/egison-2.1.3 (SatoshiEgi)
23:06:09 <dylukes> Oh wait.. I think I see...
23:06:18 <dylukes> so if my producers go from indices C -> C
23:06:33 <dylukes> then that means there MUST be a close before them (M a -> C)
23:06:48 <dylukes> Because you have to start the whole chain with (M a), and end with C.
23:07:20 <dylukes> Kind of clever how much you can enforce at the type level.
23:07:32 <ski> by "indexed monads" i mean `class IndexedMonad m where ireturn :: a -> m i i a; iextend :: (a -> m j k b) -> (m i j a -> m i k b); ijoin :: m i j (m j k a) -> m i k a; ijoin = iextend id'
23:07:40 <hpaste> obk pasted ‚ÄúLimits of functional dependencies‚Äù at http://hpaste.org/70790
23:07:56 <dylukes> Yeah, that is (!>=) :: IMonad m => m (a := j) i -> (a -> m (b := k) j) -> m (b := k) i
23:08:04 <dylukes> if you rewrite with R m i j a = m (a := j) i
23:09:39 <dylukes> They're written with the := thing because IMonad is usually like (m a i)
23:10:05 <dylukes> sort of like your "IndexedMonad" with j left unspecified. So the index is just... there.
23:10:11 <dylukes> There's no restriction based on it going on.
23:10:26 <ski> dylukes : you can get an indexed monad in my sense, by applying `R'; but can you go in the other direction ?
23:11:28 <dylukes> Gonzalez says they're a bit more generalized then the "common definition" which aligns with yours.
23:12:06 <ski> his "indexed monads", or his "restricted monads" ?
23:12:17 <dylukes> Well the "indexed monads" are pretty simple.
23:12:32 <dylukes> It's just monad rewritten almost verbatim to allow for types which carry around a type level index.
23:12:50 <dylukes> his "restricted monads" restrict on the indices and force them to match up.
23:13:44 <ski> i suppose i might have called `IMonad' a functor-monad (a monad over functors)
23:13:56 <dylukes> How so?
23:14:23 <ski> (well, except that we don't even require functorality, so possibly somewhat weaker (i'm not sure if it makes a different in this case))
23:14:50 <dylukes> It's just a monad over types carrying an index. The index doesn't really do anything on its own though. :P.
23:14:52 <ski> well, if you look at `returnI :: a :-> m a', here `a :: * -> *' and `m a :: * -> *'
23:15:11 <dylukes> Yeah, true.
23:15:21 <ski> and `returnI' is a natural transformation (by parametricity) from `a' to `m a'
23:15:57 <dylukes> I don't quite know what "natural transformation (by parametricity)" means.
23:16:04 <ski> iow, it's a morphism in the category of endofunctors over `*' (glossing over the fact that we don't actually require functorality for `a' and `m a')
23:17:06 <ski> iow, in categorial notation, `returnI_a :: a >---> m a', where `m' is an endofunctor over *this* category (the (sortof)endofunctor category over `*')
23:17:11 <dylukes> what constitutes functorality?
23:17:33 <dylukes> (also, iow?)
23:18:32 <MostAwesomeDude> In Other Words
23:18:57 <dylukes> mm, so I think it's clicking.
23:18:58 <ski> and since this is polymorphic in `a' (so by parametricity ought to satisfy the naturality condition) this is a natural transformation, `returnI : forall (a : * >---> *). a >---> m a', or `returnI : id_{*} >---> m'
23:19:15 <dylukes> parametricity? naturality condition? natural transformation?
23:19:36 <ski> (hm, that `id_{*}' should be `id_{* >---> *}')
23:19:52 * dylukes hasn't finished his Conceptual Mathematics book yet.
23:19:53 <ski> dylukes : this is CT terminology
23:20:13 <dylukes> Yeah, I haven't quite finished the book yet. I was trying to grok epimorphisms and monomorphisms on a 12 hour car ride.
23:20:22 <dylukes> I need to sit down with some paper so I can actually do some proofs/exercises...
23:20:33 <dylukes> by "haven't quite finished" I mean I'm in the first or second chapter.
23:21:39 <lillis> fmap: I'm in Swedish time here, so sorry for the late answer - but thanks. :)
23:22:43 <ski> dylukes : functorality for a `f : C >---> D' means that (a) for every object `A' in `C', `map_f id_A = id_{f A}'; and (b) for every three objects `A_0',`A_1',`A_2' in `C', and for every two morphisms `m : A_0 >---> A_1',`n : A_1 >---> A2' in `C', `map_f (n . m) = map_f n . map_f m'
23:23:32 <ski> in terms of Haskell, `f' satisfies the `Functor' laws (though `Functor' in Haskell is restricted to the case where both `C' and `D' are the category `*'/`Hask')
23:23:34 <dylukes> okay
23:24:04 <dylukes> I wonder if that kind of falls apart with Constraint Kinds.
23:24:16 <ski> "that" being ?
23:24:23 <dylukes> The definition of Functor.
23:24:35 <dylukes> You're not really just talking about * anymore. You could reasonably be working with other kinds.
23:24:37 <ski> i'm not sure why it should
23:24:49 <dylukes> * just includes all of the other ones.
23:24:58 <ski> yes, `Functor' could well prove inadequate
23:25:05 <maybefbi> what is the difference between Text.Parsec and Text.ParserCombinators.Parsec
23:25:08 <ski> (which isn't the same as "falling apart")
23:25:13 * hackagebot tls 0.9.6 - TLS/SSL protocol native implementation (Server and Client)  http://hackage.haskell.org/package/tls-0.9.6 (VincentHanquez)
23:25:15 <dylukes> right, sorry.
23:25:41 <dylukes> But then to generalize it we'd need to be able to parameterize Functor by its source and target kinds.
23:25:46 <ski> in fact, people have already previously wanted functors from `* -> *' to `*', as well as from `* -> *' to `* -> *'
23:25:48 <dylukes> And I don't even know how you'd manage that :\.
23:26:11 <dylukes> The latter is IMonad, no?
23:26:44 <dylukes> I can't think of any way to parameterize by Kind though... :\
23:26:55 <ski> e.g. consider `newtype List f a = MkList {unList :: f (ListCell f a)}; data ListCell f a = Nil | Cons a (List f a)'
23:27:16 <ski> here we want to say that `List' is a functor from `* -> *' to `* -> *', so that we can map over the `f' part
23:27:23 <dylukes> Its a free functor right?
23:27:49 <dylukes> sorry its 2:30AM and it kind of looks like one.
23:27:50 <dylukes> Ignore me.
23:28:20 <dylukes> What exactly is "f" here?
23:28:22 <ski> something like `class FunctorFunctor t where tmap :: (Functor f,Functor g) => (forall a. f a -> g a) -> (forall a. t f a -> t g a)'
23:28:27 <dylukes> what would it ostensibly represent?
23:28:53 <ski> where the type could be written like `(Functor f,Functor g) => (f :-> g) -> (t f :-> t g)'
23:29:27 <dylukes> It's too early for this ;__;.
23:29:34 <dylukes> I should probably sleep and approach you again tomorrow.
23:29:34 <ski> dylukes : consider `List Identity a',`List IORef a',`List MVar a',`List Hash a'
23:29:57 <ski> `List IORef a' is like a list, but each cell is in a mutable `IORef'
23:30:12 <dylukes> Ah okay I see.
23:30:43 <ski> you could also have `List LogVar a', where `LogVar' is a unifiable logic variable (as in Prolog)
23:30:45 <dylukes> just a random thought, but then you could have something like
23:30:55 <ski> (in fact i've done that one)
23:31:13 <dylukes> class CellType a; instance CellType IORef; ... and then have
23:31:20 <dylukes> Lift f a :: CellType -> * -> *
23:31:37 <dylukes> Lift f a :: (* -> *) -> * -> * anyhow
23:31:44 <dylukes> List*
23:32:02 <dylukes> I'm not familiar with unifiable logic variables... something for another day.
23:32:06 <dylukes> I need to sleep for today.
23:32:17 <ski> ok
23:32:19 <dylukes> Thanks for your help ski. I will be back tomorrow with more awake questions.
23:32:54 <ski> good dreaming
23:35:16 * hackagebot egison 2.1.4 - An Interpreter for the Programming Language Egison  http://hackage.haskell.org/package/egison-2.1.4 (SatoshiEgi)
23:42:06 <yitz> mauke: ping
23:45:16 * hackagebot egison 2.1.5 - An Interpreter for the Programming Language Egison  http://hackage.haskell.org/package/egison-2.1.5 (SatoshiEgi)
23:49:07 <b0fh_ua> Hi all! I need some help - http://hpaste.org/70791 - can somebody please convert this Darcs patch to regular one? I can not install Darcs now due to some weird issues with GHC on FreeBSD
