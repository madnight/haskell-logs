00:00:11 <edwardk> sok, i'm not sure where partial lenses want to be used, so we're even ;)
00:00:23 <edwardk> in practice i think multilenses give you a lot of ammunition
00:00:38 <edwardk> the main thing a partial lens gives you is a hold in hell of satisfying the get/put laws ;)
00:00:56 <edwardk> whereas with a multilens the ability to reason that way is basically shot
00:00:57 <roconnor> edwardk: partial lenses misses one law
00:01:29 <roconnor> well one of the standard laws
00:01:34 <roconnor> the non-standard laws are all fine
00:02:52 <frerich> I just tried to read that Haskell line which newsham posted, but I'm not sure I understand it - "\xs -> let f = Product.(2^^).getSum; ss = fmap Sum xs in (f . mconcat) ss == (mconcat . map f) ss" is a function which maps some 'xs' to 'ss == (mconcat . map f) ss' with 'f = Product.(2^^).getSum' and 'ss = fmap Sum xs', did I get that right?
00:03:48 * frerich had to read that very very carefully to come up with this explanation...
00:03:49 <newsham> frerich: xs will be a list of some number type like Int.  ss will be a list of (Sum Int)
00:04:43 <newsham> ?type Product.(2^^).getSum
00:04:44 <lambdabot>     Ambiguous occurrence `getSum'
00:04:44 <lambdabot>     It could refer to either `Control.Monad.RWS.getSum', imported from Control.Monad.RWS
00:04:44 <lambdabot>                           or `Data.VectorSpace.getSum', imported from Data.VectorSpace
00:04:50 <newsham> boo :(
00:05:08 <newsham> ?type Product.(2^^). Control.Monad.RWS.getSum
00:05:10 <lambdabot> forall a a1. (Fractional a, Integral a1) => Control.Monad.RWS.Sum a1 -> Product a
00:05:53 <newsham> was just trying to check that 2^ maps Sum to Product
00:05:56 <edwardk_> back
00:05:58 <edwardk_> https://github.com/ekmett/lens/blob/master/src/Control/Lens.hs#L77
00:06:17 <edwardk_> basically we can treat a multilens as if it was an index to make something 'traversable-like'
00:06:28 <edwardk_> so all the traversable combinators port to multilenses
00:06:34 <edwardk> and all the foldable ones port to multigetters
00:06:49 <edwardk> hence the foldMapOf
00:06:51 <edwardk> etc
00:07:30 <edwardk> since you can pass a lens or getter in for any of those positions, this means you can use these combinators on an awful lot of things
00:08:55 <edwardk> i still have a number of combinators to port from foldable/traversable, e.g. productOf, sumOf, etc.
00:17:48 <roconnor> edwardk: I think you are wrong about constML's signature
00:17:59 <edwardk> ?
00:18:13 <roconnor> I think you still want polymorphic updates even on null lenses
00:18:36 <edwardk> the signature you gave is more general but anything that used the generality would fail to be a family
00:18:38 <roconnor> but I'm not sure
00:18:54 <roconnor> well I'm quite sure that you are wrong that it fails to be a family
00:19:04 <edwardk> remember we have the outer x and inner x families
00:19:15 <roconnor> I know
00:19:20 <edwardk> hrmm
00:19:32 <edwardk> you might be right
00:19:35 <edwardk> one sec
00:19:39 <edwardk> i think i have an example =)
00:19:47 <edwardk> but it uses Data and GADTs ;)
00:20:11 <edwardk> k
00:20:14 <edwardk> i'm convinced
00:20:16 <roconnor> I admit what I was vaguely thinking of uses existential types
00:20:21 <edwardk> yeah
00:20:26 <roconnor> I was trying to think of something more compelling
00:20:35 <edwardk> pretty much all the examples require something existential
00:20:50 <edwardk> i'm okay with it
00:20:52 <roconnor> maybe with phantom types somehow
00:21:17 <edwardk> aha
00:21:19 <edwardk> there you go
00:21:37 <edwardk> make a 'backwards' lens to Const m from m
00:21:40 <MostAwesomeDude> I still don't get Void. Or Free.
00:21:43 <edwardk> er Const m a from m
00:21:49 <MostAwesomeDude> Why you make all these types? :T
00:22:06 <roconnor> MostAwesomeDude: Void as in the empty type?
00:22:12 <MostAwesomeDude> roconnor: As in Data.Void.
00:22:12 <edwardk> void is just a data type that shouldn't be inhabited
00:22:39 <MostAwesomeDude> But then you've got absurd :: Void -> a -- and I don't get what you'd use it for.
00:22:41 <edwardk> free is a way to wrap a functor around itself over and over with some decorations at the leaves so you can make a monad out of this thing
00:22:57 <edwardk> if you have a [Void] you know you have the empty list
00:22:57 <roconnor> MostAwesomeDude: Void is probably most useful as a parameter to other types such as Maybe Void or [Void]
00:23:14 <edwardk> if you fmap absurd over it you can get a list of a's for any a
00:23:18 <edwardk> because the list is empty!
00:23:38 <roconnor> MostAwesomeDude: Void kill's the slots of a container
00:23:39 <MostAwesomeDude> What.
00:24:12 <edwardk> :t traverse (const Nothing)
00:24:13 <lambdabot> Not in scope: `traverse'
00:24:20 <MostAwesomeDude> Hmm.
00:24:25 <edwardk> > Data.Traversable (const Nothing)
00:24:26 <lambdabot>   Not in scope: data constructor `Data.Traversable'
00:24:29 <roconnor> MostAwesomeDude: this might be a bit of a stretch, but do you understand callCC?  There is a void-like value there
00:24:33 <edwardk> > Data.Traversable.traverse (const Nothing)
00:24:34 <lambdabot>   Overlapping instances for GHC.Show.Show
00:24:34 <lambdabot>                              (t a -...
00:24:38 <MostAwesomeDude> At least I get Free. I mean, I don't know *when* to use it, but I understand it.
00:24:47 <edwardk> :t Data.Traversable.traverse (const Nothing)
00:24:48 <MostAwesomeDude> roconnor: I understand the Scheme flavor.
00:24:48 <lambdabot> forall a a1 (t :: * -> *). (Data.Traversable.Traversable t) => t a1 -> Maybe (t a)
00:24:51 <edwardk> there
00:25:19 <edwardk> now, traverse (const Nothing) -- will take your type and walk into it searching for 'a's, if it finds any it gives you Nothing
00:25:37 <edwardk> if it doesn't it gives you Just (t b)  --  for _any_ type b you want.
00:26:06 <edwardk> now you can pass around your new (forall b. t b)   -- but this requires a rank 2 type to keep the 'hey there are no b's in this thing!' hint alive
00:26:25 <edwardk> or you can just choose b = Void, and pass around a t Void   -- and fmap absurd over it when you need to use it as some other b
00:26:26 * roconnor isn't sure if edwardk is talking to him or to MostAwesomeDude
00:26:33 <edwardk> MostAwesomeDude
00:26:58 <edwardk> roconnor: did you look at the foldMapOf combinators in lens?
00:27:38 <MostAwesomeDude> edwardk: Hm. But no matter what, there's not actually any data in there?
00:27:46 <roconnor> edwardk: 'cause traverse (const Nothing) is the compostion of the traverse mutlilens with the ConstML for a getter
00:28:17 <edwardk> MostAwesomeDude: in the absence of evil things like infinite loops, etc.
00:28:36 <edwardk> roconnor: cute =)
00:28:42 <hpaste> tgeeky pasted “yes, haskell can has numberwang” at http://hpaste.org/72133
00:28:52 <MostAwesomeDude> edwardk: Curious.
00:33:32 <edwardk> roconnor: interestingly i may wind up replacing generators with multilenses
00:33:47 <roconnor> what are generators
00:33:54 <roconnor> I knew deep down you'd like multilenses
00:34:46 <edwardk> =P
00:34:58 <roconnor> what are generators?
00:35:27 <edwardk> http://hackage.haskell.org/packages/archive/reducers/3.0/doc/html/Data-Generator.html
00:36:00 <edwardk> notably: http://hackage.haskell.org/packages/archive/reducers/3.0/doc/html/Data-Generator-Combinators.html
00:36:19 <edwardk> now, i can just make a multilens for the bytes in a bytestring and rebuild those combinators =P
00:36:23 <edwardk> etc
00:37:07 <edwardk> basically a generator is a monomorphic Foldable
00:37:27 <roconnor> why would mutlilenses be efficent?
00:37:29 <edwardk> which turns into more or less a multigetter in this framework
00:37:47 <roconnor> hmm
00:38:19 <edwardk> i may lose some of the biasing gains i had with reducers
00:38:28 <edwardk> i'll have to see if i can get them back
00:40:55 <donri> edwardk: kudos for actually documenting this new package ;)
00:41:03 <edwardk> thanks =)
00:41:07 <edwardk> its been killing me =)
00:41:18 <roconnor> -- | > foldMapOf :: Monoid m => MultiGetter a b -> (b -> m) -> a -> m
00:41:29 <roconnor> :P
00:41:55 <donri> yea ok not all great docs :D
00:42:51 <roconnor> edwardk: this Focus class is great
00:42:57 <edwardk> =)
00:42:58 <roconnor> especially the Reader instance
00:43:05 <roconnor> that will make at least one person very happy
00:43:09 <edwardk> yeah
00:43:17 <roconnor> I will definitely be stealing that
00:43:23 <edwardk> i figured =)
00:43:50 <edwardk> now all i have to do is get lens stable enough that i can lure away the snap framework guys when i see them at hac phi ;)
00:44:19 <donri> roconnor: are you thinking of me re: reader?
00:44:21 <edwardk> you can _almost_ do a writer instance as well
00:44:57 <edwardk> but it needs the monoid
00:45:11 <roconnor> donri: possibly.  I'm not very good at remembering names
00:45:36 <roconnor> edwardk: next step is for you to figure out Alternative Lenses
00:45:36 <donri> i've started doing things like, asks (^.lens), and combining that with <$>, which so far covers the use cases i suggested new functions for
00:45:44 <roconnor> edwardk: which are like superpositions of multilenses
00:45:58 <roconnor> edwardk: and where get returns a semiring
00:46:06 <edwardk> they should relate to right seminearrings
00:46:20 <edwardk> not quite a full semiring
00:46:25 <edwardk> so you'll find them in parsers
00:46:36 <roconnor> edwardk: make it so
00:47:05 <edwardk> right now i just want to get the representability stuff finished up and the rest of these pseudo-generators ;)
00:48:12 <edwardk> also the fact that you have two competing semantics for alternatives/monadplus, makes it hard to develop a sound metatheory for alternative lenses
00:51:44 <sopvop> Will we get some real world examples also? :)
01:02:50 <edwardk> ok. i have all the traversable/foldable combinators in
01:02:59 <edwardk> sopvop: yes
01:03:26 <edwardk> sopvop: i have a talk to give on another library today, so it may take me a couple days
01:15:12 <mroman> Is there a empty char in Haskell?
01:15:38 <shachaf> No.
01:15:47 <shachaf> There's an empty escape sequence, though: \&
01:15:57 <Enigmagic> :t Nothing :: Maybe Char
01:15:58 <lambdabot> Maybe Char
01:16:01 <frerich> mroman: You could approximate it as Maybe Char
01:16:04 <Enigmagic> looks like there is.
01:16:13 <edwardk> Enigmagic: =P
01:16:21 <Enigmagic> :)
01:16:54 <shachaf> @ty Left (Just ()) :: Either (Maybe ()) Char
01:16:55 <lambdabot> Either (Maybe ()) Char
01:16:59 <shachaf> Looks like there are several!
01:17:06 <Enigmagic> damn!
01:17:23 <alpounet> edwardk, have you given a talk on 'ad' yet?
01:17:43 <edwardk> not recently
01:17:48 <edwardk> i did on a long time back
01:17:52 <edwardk> er one
01:18:09 <alpounet> edwardk, i guess it wasn't recorded
01:18:13 <mroman> > ''
01:18:14 <lambdabot>   <no location info>:
01:18:15 <lambdabot>      lexical error in string/character literal at chara...
01:18:52 <edwardk> tonight assuming i can drag my behind 4 blocks to give the talk with the way i'm feeling, i'm giving a talk
01:18:58 <edwardk> but not on 'ad' =)
01:19:11 <shachaf> edwardk: Sleep might help!
01:19:17 <edwardk> perhaps =)
01:19:28 <shachaf> I guess we'll never know.
01:19:41 <edwardk> i'm awake though partly because of sinuses, etc.
01:19:41 <Enigmagic> i remember back when i used to sleep
01:19:55 <nand`> I still try to sleep
01:19:57 <edwardk> wife got sick at work the other day and tried to avoid giving it to me
01:20:00 <nand`> it doesn't work these days :(
01:20:47 <Enigmagic> nand`: you should take up sleep walking
01:20:55 <Enigmagic> that way you can sleep and excercise at the same time
01:21:05 <alpounet> edwardk, yeah, about 'bound' right? well, much less catchy for me, sorry :P
01:23:05 <edwardk> fair nuff
01:23:21 <alpounet> i'm not (yet) on the language implementer side
01:24:06 <nand`> Enigmagic: I just need to learn to control my dreams, so I can do something useful in the time
01:24:26 <nand`> like visualizing algorithms
01:24:28 <edwardk> i'm going to be using bound in some ai stuff soon
01:24:35 <edwardk> admittedly its 'game ai' so its lame ;)
01:24:40 <alpounet> edwardk, uh?
01:25:11 <edwardk> moving that to #haskell-arcade =)
01:25:14 <alpounet> yeah
01:50:40 <amatsu> @pl foldl (\x y -> y : x) []
01:50:40 <lambdabot> foldl (flip (:)) []
02:00:39 <donri> edwardk: makeLenses generates code that produces warnings for missing type signatures with -Wall
02:01:10 <edwardk> donri: in lens?
02:01:11 <edwardk> yeah
02:01:16 <donri> yep
02:01:22 <edwardk> unfortunately it kind of has to, or i have to write an entire typechecker =(
02:01:39 <donri> also i ported my app from lens-family to lens without issues (in turn ported from data-lens to lens-family ;))
02:01:49 <edwardk> donri: =)
02:02:00 <edwardk> the warnings should be the same you get with lens-family
02:02:08 <donri> yea i had them there too
02:02:12 <donri> and there's a bug filed for it
02:02:16 <edwardk> *nods*
02:02:26 <donri> i thought you could just set some standard type synonym for a Lens or somesuch?
02:02:58 <edwardk> doesn't help. you have a problem because you want it to autogenerate lens families when the lens can change the type of the struct entirely
02:02:59 <edwardk> consider
02:03:19 <edwardk> data Snaplet a = Snaplet { _snapletConfig :: SnapletConfig, _snapletValue :: a }
02:03:38 <edwardk> you want snapletConfig :: Lens (Snaplet a) SnapletConfig
02:03:40 <edwardk> but you want
02:03:57 <edwardk> snapletValue :: LensFamily (Snaplet a) (Snaplet b) a b
02:04:21 <edwardk> right now it infers a type that does the right thing for both, but it can't write the type signature for it
02:05:09 <DanBurton> fclabels uses some TH magic to generate type signatures, couldn't we do the same for lens families? or is there an added difficulty that makes it harder in our case?
02:05:14 <donri> hm the inferred type i'm getting looks pretty much like a mechanical translation from the record definition... but ok :)
02:05:58 <DanBurton> I for one am willing to stoop to the level of just loading it into ghci and asking for its :type if that's what it takes ;)
02:06:45 <donri> heh, i think i'd rather write the lenses manually or silence the warning per-file then
02:07:21 <DanBurton> or perhaps makeLenses could accept some type hints
02:07:29 <donri> also how are you going to load = compile a module as part of compiling it? :P
02:08:12 <DanBurton> um...Template Haskell black magic? xD I'm never quite sure what dark secrets TH has access to
02:08:43 <DanBurton> Maybe it could write a separate file, compile and load it, and then discard it after discovering the type
02:08:46 <DanBurton> although that's quite roundabout
02:09:27 <DanBurton> The record system is smart enough to figure out the type, so that means we can do it too, it's just a pain to do
02:13:50 <donri> DanBurton: uhm, types are explicit in record definitions?
02:25:19 <donri> i wish haskell would accept type signatures without requiring the definitions to follow immediately
02:25:39 <donri> then we could write the type signatures before makeLenses
02:25:50 <donri> and docs
02:29:06 <edwardk> *nods*
02:29:30 <edwardk> DanBurton: it works for fclabels becase they don't have the more general signatures available to them
02:29:41 <edwardk> DanBurton: LensFamily doesn't admit the same hack
02:29:44 <edwardk> Lens does
02:29:54 <edwardk> but the Lens type signature sucks by comparison
02:30:44 <edwardk> with a lens family i could probably go hunt for other occurrences of any variables that appear inside this field in other fields
02:30:52 <edwardk> and then instantiate those separately
02:30:57 <edwardk> but yeow that'll be fun
02:52:23 <EvanR> can i use a list of guards without any meaningful left side expression
02:52:30 <EvanR> case () of
02:52:35 <EvanR>   () | foo ->
02:52:40 <EvanR>     | bar ->
02:52:44 <EvanR> you get the idea
02:53:45 <mekeor> EvanR: so you wouldn't need nested if-expressions, right?
02:53:49 <EvanR> yes
02:53:59 <EvanR> like a switch statement or something
02:54:04 <mekeor> EvanR: why shouldn't it be possible?
02:54:16 <EvanR> i mean is there a more idomatic and 'wtfy' way
02:54:21 <EvanR> less wtfy
02:54:43 <EvanR> also i was making sure i can use lexical variables in there
02:54:52 <EvanR> rather than just whats in the case expr and constants
02:55:05 <ksf> @pl map (\(x,y) -> (x, fromJust y))
02:55:05 <lambdabot> map (second fromJust)
02:55:08 <ksf> duh.
02:59:31 <mekeor> EvanR: whatsoever. it should work. try it out.
03:01:38 <hpaste> EvanR pasted “get line buffer” at http://hpaste.org/72135
03:02:09 <EvanR> bufSize 10 is for testing
03:02:26 <EvanR> now im just wonder about blocking behavior...
03:38:25 <Taneb> (a, b) is kinda like Cofree (Const a) b
03:38:47 <Taneb> 3 :< Const 'a' <=> ('a', 3)
03:40:52 <hpaste> fumieval pasted “primes” at http://hpaste.org/72136
03:41:23 <Taneb> That's a fairly inefficient sieve
03:41:34 <Taneb> Simple, though
03:42:28 <Nereid> calling it main isn't a great idea though ;)
04:04:26 <Saizan> it does, actually
04:04:43 <Saizan> sorry, i was scrolled back
04:23:34 <confusing> suppose i want something like 'error', but which shows the source file and line number, and ideally a stack trace. any chance?
04:23:47 <nand`> “Let's look at how some of these operations relate to real life concepts” -> goes on to show their uses working with complex numbers, euclidean geometry and quaternions
04:24:04 <confusing> 'assert' btw does show the line number, so that's a step in the right direction
04:24:20 <nand`> some mathematicians are apparently so abstract they think college algebra is the real life
04:24:39 <hpc> hah
04:25:52 <Saizan> so you've never seen the CT books where the concrete examples are from abstract algebra, i guess :)
04:26:10 <nand`> Saizan: heh, I have; but they haven't been called “real life examples”
04:26:32 <nand`> “to help understand, here's a familiar example from abstract algebra”
04:28:34 <confusing> nand`: math lecture -- "er, professor, could you please calculate that stuff step by step with some actual numbers, as an example?" -- "ok. suppose an arbitrary 'n', which we plug in here ..." -- "sorry, we meant actual numbers, not 'n'" -- "huh? ok, suppose an arbitrary fixed 'a', which i plug in like this ..." -- "..."
04:28:46 <nand`> confusing: hehe
04:32:06 <donri> confusing: yes "assert", also package "file-location" and +RTS -xc
04:33:16 <confusing> donri: oh thank you, checking out the package. -xc is the fairly recent thingy that requires stuff to be built profiledly, right?
04:34:27 <donri> yep
04:34:36 <donri> -prof -rtsopts
04:34:38 <hpc> my favorite math lecture is one by my linear algebra prof
04:34:51 <donri> although better use cabal for -prof
04:34:57 <hpc> he didn't write a single formula, and half the terms he mentioned were ones he made up himself
04:35:00 <donri> --enable-bla-profiling
04:35:11 <hpc> they don't appear on google unless you get ultra-specific and search for his papers
04:37:00 <Kuraitou> If I distribute an application written in Haskell do I have to include the BSD-style license for the base libraries?
04:37:09 <hpc> you don't have to
04:37:12 <hpc> but it's encouraged
04:37:23 <confusing> donri: right, we've met before. "cabal -p" and me. it wasn't pleasant, but i've since acquired more convincing threats and a larger crowbar
04:37:58 <donri> what about it is unpleasant?
04:39:12 <Kuraitou> Alright, thanks.
04:39:14 <confusing> er, it's just that i had everything installed without profiling
04:39:49 <donri> ah :)
04:39:50 <hpc> Kuraitou: specifically, you want to either be non-free, or BSD-like
04:40:00 <hpc> GPL in particular makes it impossible to static link
04:40:13 <donri> i tend to write a makefile for development that does things like cabal-dev install --enable-lots-of-things
04:41:00 <confusing> donri: right, cabal-dev was what i ended up with
04:41:00 <donri> you can also configure such things in ~/.cabal/config
04:41:28 <hpc> that reminds me, i don't have cabal-dev installed...
04:41:31 <confusing> yeah, it just didn't occur to me at the beginning
04:41:48 <Kuraitou> hpc, I mean for the base libraries that I make use of, not my application
04:42:31 <donri> Kuraitou: basically you only need to worry about that if you're distributing binaries
04:42:34 <hpc> uh oh
04:42:40 <hpc> cabal-dev is reinstalling network
04:43:13 <Kuraitou> donri, assuming I am, do I need to include the license information on this page? http://www.haskell.org/ghc/docs/latest/html/libraries/base/LICENSE
04:44:12 <donri> Kuraitou: yes. read the license ;)
04:44:58 <Kuraitou> That's fine, I just wanted to double check.
04:45:18 <Kuraitou> It just seems odd because most languages don't have a license placed on the standard library.
04:45:30 <donri> uh of course they do
04:45:50 <donri> anything that isn't licensed defaults to all rights reserved
04:46:28 <Kuraitou> I guess I should read up on that then, because I've never distributed anything like that before with binaries.
04:54:09 <Philonous> Is there a way to check how may (haskell) threads exist / whether an application is leaking threads?
04:56:04 <donri> Philonous: maybe threadscope / -eventlog? not sure if those are relevant to concurrency or just parallelism
04:59:03 <Philonous> donri:  I was thinking about something like (numThreadsRunning :: IO Int), but threadscope might do the trick
05:10:03 <frerich> Hm - is there really no Haskell library for speaking CalDAV? Maybe my hackage-fu is not strong enough, but I couldn't find anything...
05:10:10 <frerich> OTOH, maybe my chance to give something back! :-)
05:11:36 <frerich> Ah, there's a parser for iCalendar, that's close...
05:28:33 <xkb> What's the current state of Haskell on heroku?
05:28:48 <xkb> are there any stable buildpacks?
05:32:20 <DanBurton> I don't believe anyone has made a "buildpack" for Haskell
05:33:16 <marcot> Hi.  I've created a file with only one character (á) in utf-8 encoding.  If I call od -t u1 in it, I get 195 161. But when I try to read it in ghci with readFile, I get "\225".
05:33:30 <DanBurton> This is the only Haskell-on-Heroku guide I am aware of: https://github.com/yesodweb/yesod/wiki/Deploying-Yesod-Apps-to-Heroku
05:33:38 <marcot> Does ghc convert strings to iso-8859-1 automatically?
05:34:05 <marcot> 225 is á on iso-8859-1
05:34:56 <mauke> marcot: I'm tempted to look up a famous babbage quote
05:35:25 <mauke> you have a file with one character in it. readFile gives you one character.
05:35:44 <Botje> marcot: U+00E1 is á
05:37:52 <tew88> http://hpaste.org/72139
05:38:08 <DanBurton> > 15 * 16 + 1
05:38:09 <lambdabot>   241
05:38:11 <tew88> Is that the standard way to handle exceptions in that scenario? It feels a little clumsy, repeating the function's type signtaure
05:38:18 <DanBurton> > 14 * 16 + 1
05:38:19 <lambdabot>   225
05:38:27 <marcot> mauke: What quote?
05:39:20 <mauke> "I am not able rightly to apprehend the kind of confusion of ideas that could provoke such a question."
05:40:15 <mauke> "On two occasions I have been asked [by members of parliament], - "Pray, Mr. Babbage, if you put into the machine wrong figures, will the right answers come out?" I am not able rightly to apprehend the kind of confusion of ideas that could provoke such a question."
05:40:15 <DanBurton> tew88: exceptions are, by definition, exceptional, so it's hard to talk about a "standard" way to handle them ;)
05:41:30 <Botje> pokemon exception handling!
05:41:36 <hughfdjackson> :p
05:41:41 <mauke> tew88: I'd probably define a handleIO or catchIO function for dealing with IOExceptions only
05:41:43 <DanBurton> I'd just go with ScopedTypeVariables personally
05:41:45 <sopvop> Zoidberg might say: Exceptions are bad, and you should feel bad!
05:42:06 <roconnor> The writer monad is simply the constant monad times the identity monad?
05:42:07 <alexandrus> hmm xD is it helping? xD
05:42:23 <mauke> tew88: maybeIO = handleIO def . liftM Just
05:42:31 <DanBurton> roconnor: sounds about right
05:42:38 <xkb> DanBurton:  I found a few build packs on github
05:42:49 <xkb> DanBurton: don't know about their status though
05:43:00 <DanBurton> xkb: Haskell build packs? got links?
05:43:04 <roconnor> I'm surpised monad products are not used more often.
05:43:24 <marcot> Ok, so the problem is, when I try to get this file via simpleHTTP, I get "\195\161"
05:43:41 <ski> > length `graph` "\x00e1"
05:43:42 <marcot> The ugly code is: rspBody <$> head <$> rights <$> (: []) <$> simpleHTTP (getRequest "http://marcot.eti.br/a")
05:43:43 <lambdabot>   ("\225",1)
05:43:46 <xkb> DanBurton: sure, this is one for example: https://github.com/mbbx6spp/cabal-heroku-buildpack
05:43:53 <Botje> did the response header say it returns utf8 ?
05:44:07 <roconnor>  rspBody . head . rights . (: []) <$> simpleHTTP (getRequest "http://marcot.eti.br/a")
05:44:54 <Botje> so rspBody is just bytes, then.
05:44:54 <marcot> Botje: Yes, as you can see by removing rspBody from the line.
05:44:57 <mauke> marcot: could be a bug in simpleHTTP
05:45:13 <marcot> roconnor: Why do . tend to be preferred over $ or <$>?
05:45:14 <confusing> marcot: i think that readFile automatically utf8-decodes the file, while simplehttp maybe doesn't, or does that only when the web server is configured correctly
05:45:21 <DanBurton> that's what I was thinking: perhaps simpleHTTP is too simple for your needs?
05:45:26 <mauke> Content-Type: text/plain; charset=UTF-8
05:45:31 <mauke> the webserver is fine
05:45:50 <tew88> ty, mauke ;)
05:45:52 <mauke> if simpleHTTP loads arbitrary data into Strings, it's not "too simple", it's broken
05:46:05 <confusing> mauke++
05:46:23 <rtharper> =p
05:46:35 <roconnor> mauke: because . is associative, more bits are "subexpressions"
05:46:51 <mauke> marcot: ^
05:46:57 <roconnor> er sorry
05:47:01 <roconnor> sorry mauke
05:47:17 <marcot> So, "\195\161" when decoded to utf-8 becomes "\225"?
05:47:28 <mauke> marcot: no :-(
05:47:50 <mauke> marcot: the bytes [195, 161] are utf-8. when decoded to characters they become "\225"
05:48:17 <marcot> mauke: I think I'm missing the basics on utf-8.  I'll try to read about it.
05:48:36 <mauke> utf-8 is an encoding. it describes how characters map to bytes
05:48:42 <ski> `Char's are already in unicode. whether it's UTF-8 or not is a question of representation
05:49:14 <mekeor> is (Arrow a => a b) a functor? or could it be?
05:49:15 <ski> (iow, it only matters when we're converting between `Char's and some other (usually external) format)
05:49:28 <ski> mekeor : yes
05:49:30 <marcot> Ok, so \225 is not a byte, it's a character, and when encoded via utf-8 it's represented as [195, 161].
05:49:39 <mauke> marcot: yes
05:49:46 <mekeor> ski: "yes" for the first or second question? =)
05:49:59 <marcot> mauke: Ok, I didn't knew this, thanks.
05:50:10 <ski> mekeor : for the first, mathematically. and the second, practically
05:50:22 <Botje> marcot: it helps to keep a mental barrier between unicode characters (U+00E1) and bytes (195, 161)
05:50:51 <ski> > '\x00e1'
05:50:52 <lambdabot>   '\225'
05:51:16 <mekeor> ski: so, is there a module in the base-package which makes (Arrow a => a b) an instance of functor? if yes, which?
05:51:29 <confusing> marcot: the problem is that in haskell those bytes (195 161) should not be in a String, ever, only in a list of Word8's or similar. if simpleHTTP is giving you a String like that, it's a bug in simpleHTTP
05:51:36 <DanBurton> mekeor: if you want to define `instance Arrow a => Functor (a b)' then you need some ugly extensions to write that generally.
05:51:38 * mekeor makes things complicated.
05:51:48 <mekeor> DanBurton: oh, okay, i see.
05:51:52 <ski> mekeor : i think there was a paper which related compared arrows, applicative functors, and monads
05:52:06 <mekeor> DanBurton: well, i don't see why that extension'd be ugly though…
05:52:11 <ski> mekeor : not sure whether there's a package
05:52:22 <marcot> confusing: Ok, I'll look into that.
05:52:24 <marcot> Thanks everyone.
05:52:36 <DanBurton> it's because "Arrow a => a b" overlaps with everything, because ghc is sort of stupid about constraints
05:53:15 <ski> donri : "i wish haskell would accept type signatures without requiring the definitions to follow immediately" -- huh ? i thought we always could do this
05:53:20 <DanBurton> suppose you also wanted to write instance Monad m => Functor m
05:53:30 <DanBurton> this would also overlap with everything
05:53:44 <mekeor> ski: is there a nice way to define only one function called "map" instead of "map" and "mapM" (using pure-haskell or haskell+extensions)?
05:53:54 <DanBurton> and if you ovlrlap everything too many times, you get great pain and suffering
05:54:32 <ski> mekeor : if you're asking for a way to derive `mapM' from `map', i think the answer is no
05:54:33 <mekeor> DanBurton: oh, oh. okay, i think i got it.
05:54:39 <confusing> DanBurton: i can live with pain and suffering. what i can't live with is the incomprehensible error messages :)
05:54:51 <ski> mekeor : you could use `mapM' with `Identity', to get basically `map', though
05:55:09 <DanBurton> confusing error messages are indeed irritating
05:55:10 <mekeor> ski: yeah, that's nice.
05:55:20 <mekeor> well, no, actually, it's not nice.
05:55:29 <DanBurton> @google sinkM haskell
05:55:31 <lambdabot> http://www.haskell.org/pipermail/haskell-cafe/2012-March/099895.html
05:55:31 <lambdabot> Title: [Haskell-cafe] Conduit Sink fork
05:55:42 <DanBurton> doh ignore that I'll go google it myself..
05:56:51 <DanBurton> @let sinkM hof f = runIdentity . hof (return . f)
05:56:52 <lambdabot>  Defined.
05:56:59 <DanBurton> :t sinkM mapM
05:57:00 <lambdabot> forall a a1. (a -> a1) -> [a] -> [a1]
05:57:04 <DanBurton> :t sinkM filterM
05:57:05 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
05:57:07 <mekeor> oO cool
05:57:32 <ski> mekeor : see my "repaste of PoorManDebug" at <http://hpaste.org/10060> for an example of doing something like that
05:57:41 <DanBurton> wrote that a while ago: http://stackoverflow.com/a/7735551/208257
05:58:21 <mekeor> DanBurton: i like that! coool. thanks!
05:58:51 <DanBurton> mekeor: :) it only works for higher-order functions that have a certain format
05:59:08 <DanBurton> :t sinkM
05:59:09 <lambdabot> forall (f :: * -> *) (m :: * -> *) a1 (f1 :: * -> *) a. (Monad m, Functor f, Functor f1) => (f (m a1) -> f1 (Identity a)) -> f a1 -> f1 a
05:59:09 <mekeor> oh :D okay :)
05:59:39 <DanBurton> i have no idea what that mega generalized type signature means, but there you go
05:59:50 <mekeor> hehe
06:01:36 <ski> @type let infixr 9 .; (.) = (Prelude..); sinkM hof f = runIdentity . hof (return . f) in sinkM
06:01:37 <lambdabot> forall a (m :: * -> *) b a1 a2. (Monad m) => ((a -> m b) -> a1 -> Identity a2) -> (a -> b) -> a1 -> a2
06:02:04 <int-e> @type \f -> fmap runIdentity . f . fmap return
06:02:05 <lambdabot> forall a (f :: * -> *) a1 (m :: * -> *) (f1 :: * -> *). (Functor f, Monad m, Functor f1) => (f1 (m a1) -> f (Identity a)) -> f1 a1 -> f a
06:02:18 <ski> @type let infixr 9 .; (.) = (Prelude..); sinkM hof f = runIdentity . hof (Identity . f) in sinkM
06:02:19 <lambdabot> forall a b a1 a2. ((a -> Identity b) -> a1 -> Identity a2) -> (a -> b) -> a1 -> a2
06:02:49 <DanBurton> @pl \f -> fmap runIdentity . f . fmap return
06:02:49 <lambdabot> (fmap runIdentity .) . (. fmap return)
06:03:09 <int-e> I find that unreadable :)
06:03:12 <DanBurton> there's an interesting idiom
06:03:21 * ski would probably say `Identity' instead of `return' in there, for symmetry
06:03:33 <DanBurton> (foo .) . (. bar) means "wedge the input function in the middle"
06:03:46 <int-e> ski: that would make a different function
06:03:53 <int-e> ski: the point is that 'f' changes the monad
06:04:30 <ski> int-e : it would still work in the application DanBurton had
06:04:36 <int-e> (Hmm, context: I was starting from the type signature of sinkM above)
06:05:06 <DanBurton> yeah, for my purposes it can stay entirely in Identity land
06:05:22 <DanBurton> I'm not really sure what it is doing outside of Identity land
06:06:05 <int-e> DanBurton: well, you could encapsulate various pure run* functions for monads. (Like State or Reader)
06:06:22 <int-e> (I guess Reader is the only one that really makes sense)
06:07:37 <confusing> bah, why has the http package tabs and spaces mixed unscrupulously
06:07:46 <marcot> mauke: http://www.haskell.org/pipermail/haskell-cafe/2010-October/085068.html
06:08:06 <marcot> mauke: It seems that it is a known issue, not considered a bug.
06:08:41 <mauke> a "known issue" is a bug
06:09:39 <mauke> "It would be entirely possible to write an HTTP library that does this automatically, but it would be inherently limited to a single encoding type." <- this makes no sense
06:09:41 <confusing> s/broken grammar/valid grammar/
06:09:57 <mroman> Is there a risk involved with deleting /usr/local/lib/ghc-7.0.3?
06:10:07 <mroman> I upgraded to ghc 7.4.1
06:10:10 <confusing> mauke: yup. was wondering about the same
06:10:11 <mroman> but no my disk is full :(
06:10:14 <mroman> *now
06:10:21 <jhance> mroman: Probably not.
06:10:27 <marcot> mauke: Well, it would be limited to a set of encodings, right?
06:10:35 <jhance> mroman: Your package manager really should have deleted the old version...
06:10:35 <int-e> mroman: you won't be able to use ghc-7.0.3 anymore afterwards :)
06:10:41 <confusing> i think the correct way is: if the server tells you the encoding, use that to decode
06:10:42 <mauke> marcot: yes
06:10:47 <mauke> marcot: maybe even the set of all encodings
06:10:47 <mroman> jhance: I built them from source.
06:11:10 <jhance> mroman: Oh. /usr/local. My bad. Yeah you can delete the old version fine
06:11:14 <int-e> mroman: other than that I don't think there's any risk. it would not hurt to take a peek inside to be sure.
06:11:41 <int-e> (it's just a file name. the contents could be anything!)
06:13:13 <mroman> With my 10GB space available I must be picky :)
06:13:45 <confusing> marcot: the other day, someone was advocating http-conduit as an alternative to the "http" package. maybe that does a better job. "http" seems to be clearly broken
06:13:55 <mroman> and ghc is around 400MB. So it's huge.
06:14:18 <jhance> confusing: http-conduit supports HTTPS and http doesn't, as well... Its an all-around improvement :)
06:24:58 <quicksilver> flem: I would guess you haven't installed some (non-haskell) dependency of wxc
06:25:03 <quicksilver> cabal only automatically tracks the haskell libraries
06:25:13 <quicksilver> it doesn't warn you that you need wxwidgets installed, or whatever.
06:25:23 <Taneb> Thinking of making a playing-with-functors library
06:26:44 <marcot> confusing: I'll take a look.
06:27:33 <bitonic> how are safe FFI calls implemented?  do they spawn a new OS thread?  if not, how can they reliably preempt C code?
06:33:40 <quicksilver> bitonic: yes, tehre is an extra thread per (active) FFI call
06:34:54 <quicksilver> bitonic: (and they don't count towards your normal count of "capabilities")
06:35:21 <quicksilver> flem: I think you're right, yes.
06:38:14 --- mode: ChanServ set +o copumpkin
06:38:16 --- mode: copumpkin set -q $~a
06:38:19 --- mode: copumpkin set -o copumpkin
06:39:36 <nart> ah, i'm on osx lion , xcode 4.3
06:41:12 <bitonic> quicksilver: thanks
06:43:53 <confusing> ... man, that 'http' package issue that the guy asked about is disappointing
06:45:16 <marcot> confusing: Why?
06:47:56 <marcot> confusing: http-conduit solves the problem by only returning ByteString, and not String.  I simple fix to HTTP would be to remove the String instance.
06:48:29 <confusing> marcot: it's a major package, but it's not really well-written :( then somebody on -cafe describes something that's pretty clearly a bug, and is told things like "http libraries will always be locked to one encoding", which misunderstands the http protocol afaict
06:48:42 <mauke> returning ByteString doesn't solve the problem, it just avoids it
06:48:59 <confusing> also claiming "there's nothing wrong with putting raw bytes in a String, you just have to remember what it contains". i don't think that's how String is supposed to be used. and nobody objected to the reply. and the package mixes tabs and spaces :(
06:49:00 <jhance> If you return ByteString, now the user has to decode it...
06:49:14 <confusing> i mean, i like haskell, but that particular episode i found disappointing
06:49:18 <marcot> mauke: Yes, but it's still better than returning broken Strings.
06:49:21 <nart> what does even mean "parse error on input `CALLCONV'" ?
06:49:24 <mauke> marcot: yes :-(
06:49:26 <confusing> marcot: agreed
06:49:35 <mauke> real solution: use perl
06:49:56 <mauke> use LWP::Simple; my $data = get $url;  # done.
06:49:57 <rtharper> that is never a solution
06:50:00 <confusing> real solution: make the hackage libraries more solid
06:50:11 <mauke> confusing: that's harder than just using LWP
06:50:44 <marcot> Well, the most simple solution is to keep using HTTP but getting it as a bytestring and the convert it according to the http header.
06:50:56 <marcot> I think that's what I'll do for now.
06:51:07 <marcot> https://github.com/haskell/HTTP/issues
06:51:13 <confusing> mauke: yeah ... but with a dynamic language, you tend to chase bugs for the following months (or years) which ghc would have caught rightaway
06:51:19 <marcot> A bug can be reported on this page.
06:51:41 <confusing> marcot: right, thanks for making a bug report
06:51:45 <mauke> confusing: where "dynamic language" is everything except Haskell?
06:51:54 <marcot> confusing: Well, I haven't (yet)
06:51:56 <confusing> mauke: yup :)
06:52:13 <jhance> Quote from an issue on HTTP: "HTTP doesn't have any really active developers, I'm afraid. I'm happy to accept patches (after review/discussion), or to discuss handing over maintainership if someone with more time for the package than me comes along.
06:52:24 <mauke> Perl has working libraries. that is its big advantage.
06:53:25 <quicksilver> perl also has lots of broken libraries.
06:53:30 <marcot> jhance: Thanks for pointing.  I think an open bug will be good as a reminder for the next maintainer still.
06:53:34 <quicksilver> and lots of popular libraries with idiosyncracies.
06:53:34 <mauke> quicksilver: true
06:53:46 <quicksilver> but mostly, it just has lots. and lots. If you know which are the good ones it's great :)
06:54:00 <confusing> jhance: is the http-conduit thing a complete replacement of http? maybe the right thing would be to mark http as deprecated, if it has no active developers
06:54:08 <donri> mauke: well it's as easy as lwp with http-conduit it looks like?
06:54:25 <jhance> confusing: Technically no, because as far as I can tell theres no real connection between the developers. But its the replacement in my mind
06:54:37 <mauke> donri: how do you do it with http-conduit?
06:54:56 <donri> data <- simpleHttp url
06:55:19 <donri> data is a lazy bytestring
06:55:43 <mauke> donri: yes, that's exactly not what the perl code does
06:55:49 <donri> oh, it handles encoding
06:55:51 <marcot> I would implement it if I had knowledge about a good way to do it.  I'm doing it on my program using Data.Text.Encoding.encodeUtf8 and Codec.Text.IConv.convertFuzzy.
06:55:51 <donri> ok
06:55:53 <mauke> which is the whole point
06:56:12 <jhance> I don't know much about HTTP itself... is there a header that specifies encoding?
06:56:18 <sclv> HTTP is a very old library
06:56:27 <sclv> there are many newer libraries that are much better
06:56:31 <mauke> jhance: yes, Content-Type
06:56:37 <confusing> i guess in an ideal world, 'http' would be deprecated and http-conduit would be patched to handle encoding
06:56:39 <marcot> sclv: Which one besides http-conduit?
06:56:49 <donri> someone should write pipes-http and use text-icu or something ^_^
06:57:06 <quicksilver> what data type should it return?
06:57:16 <quicksilver> bear in mind that a URL may or may not reference text.
06:57:28 <donri> Either ByteString Text
06:57:38 <quicksilver> bytestring is a simple thing to return - all URLs do ultimately reference zero or more bytes.
06:57:55 <quicksilver> but sometimes you need metadata (like a content-disposition header)
06:57:56 <jhance> You can get the encoding then from http-conduit and then use a conduit that converts bytestring to text, but thats a lot of work for the user... that needs to be patched in
06:58:05 <mauke> quicksilver: you always need metadata
06:58:26 <quicksilver> mauke: indeed
06:58:54 <jhance> Really it would just be nice to have a function decodeConduit :: ResponseHeaders -> Conduit ByteString m Text
06:58:55 <confusing> quicksilver: the user of http-conduit still has to fetch the http encoding header, look at it, and decode appropriately. that seems like a standard step that's always required. it seems to make sense that this should be done by the library once, not 1000x by every user of the library
06:58:56 <sclv> the most feature-complete being bindings to high-powered C libs like curl
06:59:07 <sclv> mracot : ^^
06:59:27 <marcot> sclv: Ok.
06:59:37 <donri> jhance: what of unsupported encodings?
06:59:43 <jhance> donri: Burn in flames
06:59:55 <sclv> shpider is also quite nice (it has its own curl bindings inside it)
07:00:20 <jhance> donri: It could also return a Maybe (Conduit ...)
07:00:44 <quicksilver> confusing: I understand your need. I don't understand how you expect to achieve it.
07:00:51 <sclv> marcot: also see dons' download and download-curl packages
07:01:00 <quicksilver> confusing: what is the correct data-type?
07:01:09 <donri> sclv: then why does it depend on curl?
07:01:38 <confusing> donri: even if the library only manages to decode latin1 and utf8 and error's on anything else, that's still better than the http package's "latin1 only" policy
07:01:39 <quicksilver> confusing: a URL might reference a binary format (like a JPEG); you almost certainly want the mime-type; it might reference text; for which you need to understand the encoding.
07:02:09 <donri> confusing: oh, i'm just saying you should represent the possibility of that failure in the types, perhaps
07:02:10 <MostAwesomeDude> What I still don't get is how I'm supposed to have things on timers in conduits.
07:02:24 <confusing> quicksilver: yes sure. if the server says "Content-Type: text/plain; charset=UTF-8", or html, decode it. don't do it for jpeg and stuff
07:02:42 <sclv> donri: what?
07:02:49 <donri> sclv: shpider
07:02:53 <donri> depends on the curl package
07:03:01 <donri> you said it has its own bindings?
07:03:03 <sclv> oh, right
07:03:05 <sclv> it used to
07:03:10 <mauke> confusing: for text/html you need to look at the body to see if it contains a <meta> directive with encoding information
07:03:16 <sclv> i guess the newer version moved to use curl proper
07:03:17 <donri> because the curl package apparently tends to segfault
07:03:18 <quicksilver> confusing: WHAT DATA TYPE.
07:03:25 <quicksilver> confusing: is the quesiton I'm asking.
07:03:30 <sclv> curl is a good package
07:03:37 <sclv> you just have to use it carefully
07:03:45 <sclv> which the new shpider does, and download-curl does
07:03:48 <donri> duno, i only used it via hxt-curl and it segfaulted for me
07:04:10 <jhance> decoding should be up for the user... they should know whether they are downloading a jpeg or if they are downloading html. But there should be a function to do it for them when they want to do it.
07:04:12 <sclv> i don't know how well hxt-curl uses it...
07:04:20 <mauke> jhance: wrong
07:04:24 <donri> apparently not very well :)
07:04:39 <confusing> quicksilver: well, the http server if correctly configured sends headers. one of the headers is "Content-Type". it contains a string like "text/plain; charset=UTF-8", which tells you mime type and encoding. what do you mean by "data type"?
07:04:40 <jhance> mauke: And then the function that converts can return a Maybe for the case that the user needs to decide if they need to decode or not
07:04:55 <mauke> confusing: do you know Haskell?
07:04:59 <jhance> mauke: So the actual function that does the download does not decode but defers it to a conduit to do it for them
07:05:00 <quicksilver> confusing: In haskell. What data type will your function return.
07:05:00 <sclv> bindings can always be a bit tricky, but i've used the curl package to good effect and various wrappers for it. it would be a massive effort to duplicate all the functionality it has in haskell
07:05:10 <sclv> and afaik none of the alternatives come close
07:05:21 <quicksilver> confusing: (I am very, very familiar with the HTTP standard, fwiw, you don't need to explain it to me)
07:06:31 <sclv> i mean even HTTP is fine for simple stuff (I just am not fond of the API) but once things get tricky and you're interacting with various oddly configured servers being "clever" you start to need lots of the little oddities that curl handles
07:06:32 <donri> ...and for XML you need to look at the <?xml encoding?>... although, if it is XHTML, i wonder if meta wins?
07:06:42 <quicksilver> as donri said quite a while back you could use Either Bytestring Text
07:06:50 <donri> TLDR decoding is non-trivial
07:06:50 <quicksilver> but that feels quite weird in many respects
07:07:09 <quicksilver> and it does lose you other interesting metadata (mime type etc)
07:07:15 <quicksilver> which, in general, you do want.
07:07:17 <jhance> quicksilver: Thats why I think having "Response a -> Maybe (Conduit ByteString Text)
07:07:21 <jhance> is the right way to go
07:07:35 <mauke> don't open this link: http://mauke.hopto.org/exe/nph-lock
07:07:36 <donri> well this would probably be a utility function and not the sole interface
07:08:11 <donri> oh god i so want to open that link now
07:08:53 <mauke> it's nothing interesting. I just want to see who here is running broken scripts
07:09:55 <confusing> quicksilver: ok i see what you mean. i have to think about that. (when you said data type, i did misunderstand it as mime type. but by repeating your question in capital letters, you don't make yourself any clearer. if you keep asking the same thing, i'll just explain the same thing more slowly and carefully. no worries, anyway.)
07:11:20 <mauke> .oO( by repeating your answer slowlier and more carefully, you don't make yourself any clearer. if you keep giving the same answer, I'll just ask the same question LOUDER )
07:11:39 <confusing> mauke: that's a joke, right?
07:12:10 <nand`> I don't really know what this is about but for a HTTP implementation I'd expect something like -> (MimeType, ByteString); the decoding would be handled by eg. a HTML library or a JPEG library or libraries that exist solely to multiplex MIME-types onto different decoders
07:13:02 <jhance> nand`: It needs to give access to all the headers, though, not just the mime type
07:13:18 <nand`> jhance: well, Content-Encoding as well. What other headers would you need?
07:13:26 * hackagebot network-metrics 0.2.0 - Send metrics to Ganglia, Graphite, and statsd. (BrendanHay)
07:13:50 <jhance> nand`: Well, for example when you use the github api it gives you a Link rel="next" in the headers that you need to find the next json array
07:14:06 <nand`> ah
07:14:14 <jhance> nand`: Obscure cases like that make having access to all of the headers somewhat necessary even though they don't occur often
07:14:34 <nand`> yeah, I don't know how to solve that elegantly
07:15:17 <jhance> nand`: Ideally we would just return ResponseHeaders and have functions for getting mime type, etc, from ResponseHeaders
07:16:00 <nand`> I meant for eg. decoding JSON lazily from a response like that
07:16:18 <nand`> I imagine the best I could come up with is some horrible unsafe* hackery
07:16:32 <valentin> why do I get parse error on input `=' entering doubleMe x = x + x  ?
07:16:54 <MostAwesomeDude> > let doubleMe x = x + x in doubleMe 14
07:16:55 <lambdabot>   28
07:16:55 <Botje> valentin: if you're typing that into GHCi, put a 'let' keyword in front of it
07:17:06 <weexplat> nand`: well, the Link header is kind of outside the json parsing there
07:17:19 <nand`> hmm, maybe a function specifically for APIs like that which returns an IO Lazy.ByteString; which is then passed to a pure ByteString -> JSON function
07:17:20 <jhance> nand`: It wasn't too bad, I just used http-conduit, aeson, and attoparsec-enumerator
07:17:58 <weexplat> > let doubleMint x = (x, x) in doubleMint "gum"
07:17:59 <lambdabot>   ("gum","gum")
07:18:34 <Cale> I wonder if GHCi could do without 'let' for pattern and function bindings now. The old story was that GHCi wanted expressions rather than declarations, but now that picture of things is clouded, since it allows data and even class declarations
07:18:49 <hape01-> when I have a haskell coding fragment with many imports ... when I want to compile this in a cabal environment, it takes a lot of time to find all relevant modules. how do you handle this case?
07:18:49 <nand`> Cale: I would like that
07:19:06 <nand`> Cale: the whole ‘let’ thing is a bit awkward to explain to newcomers
07:19:23 <marcot> If the content-type says utf-8, i can convert it to string using: Data.Text.unpack . Data.Text.Encoding.decodeUtf8
07:19:33 <weexplat> Cale: i bet it wouldn't be ambiguous
07:19:35 <jhance> hape01-: Let cabal tell me what hidden library the module is from when I error on compile
07:19:50 <weexplat> Cale: but it might be annoying to parse anyway
07:20:03 <nand`> every time I forget ‘let’ in GHCi I get some error like ‘Unexpected =’. It shouldn't be awfully ambiguous
07:20:07 <jhance> marcot: No, use the conduit version of decode (assuming http-conduit instead of HTTP)
07:20:20 <Philonous> Cale:  Is let without in even a valid expression?
07:20:26 <nand`> Philonous: it isn't
07:20:27 <hape01-> jhance: super, thank you for the hint, I go searching the cabal option to show ...
07:20:46 <Cale> Philonous: Inside a do block it is
07:20:52 <Cale> and that's what GHCi is sort of simulating
07:20:52 <jhance> hape01-: I don't know if there is one... I just do cabal build and it tells me "Module ... is part of hidden package ..."
07:20:53 <donri> but then it's not an expression ;)
07:20:59 <Cale> (the inside of a top-level do-block)
07:21:02 <weexplat> jhance: btw does this mean you're putting/have put a binding to the github api on hackage?
07:21:06 <Cale> Note that you can write things like:
07:21:09 <Cale> x <- getLine
07:21:20 <nand`> Cale: oh, I never realized that. I always did let x = it
07:21:27 <jhance> weexplat: Yes but its not nearly complete yet... I've implemented Gists and some of the git objects. Also theres already one there but its read-only
07:21:54 <Philonous> Cale:  Well, it's still not a valid expression.
07:21:56 <donri> isn't "it" still an IO?
07:22:06 <nand`> donri: nope
07:22:08 <Cale> nand`: I didn't realise that executing IO actions would set 'it'
07:22:13 <Cale> (to their results)
07:22:14 <donri> oic
07:22:27 <Cale> interesting
07:22:36 <weexplat> jhance i would love to just have a nice command-line tool where i could write 'git hub publish' and *boom*
07:22:43 <Cale> I would have expected that 'it' would be set to the IO action that you executed
07:22:51 <donri> yea same
07:22:56 <nand`> Cale: it works for non-IO values too, eg. typing ‘it + 1’ will increase the previous result twice
07:23:02 <nand`> oh
07:23:05 <nand`> that's what you meant
07:23:05 <Cale> yes, I know that much :)
07:23:09 <donri> weexplat: publish?
07:23:14 <donri> weexplat: there are plenty github clis
07:23:26 * hackagebot network-metrics 0.2.1 - Send metrics to Ganglia, Graphite, and statsd. (BrendanHay)
07:23:27 <Cale> I would have expected that 'it' is set to the value of the last expression entered by the user.
07:23:33 <nand`> Cale: maybe it's a newer change, but I think it was around in 6.x, definitely in 7.0
07:23:36 <Cale> regardless of the type of that expression
07:23:49 <donri> yea, the point is "it" is special-cased for IO
07:24:00 <nand`> GHCi specialcases IO one way or the other
07:24:12 <Cale> Another thing which has weirded me out about GHCi ever since it was introduced is how GHCi now prints the result of IO actions
07:24:26 <weexplat> donri: examples?  i couldn't find one with a function like that when i looked around casually ...
07:24:42 <Cale> So that x behaves like x >>= print
07:24:44 <nand`> Cale: yeah, except for (); more special-casing
07:24:47 <donri> Cale: and then you have things like Show Text which looks like a string literal ;)
07:24:47 <Cale> yeah
07:25:08 <Cale> ghci used to have really straightforward behaviour
07:25:16 <donri> T.readFile f :: String  --??
07:25:24 <Cale> but it's become kinda complicated to explain
07:25:32 <nand`> Cale: I don't think that's bad though; if I'm executing an action I see it as a value with side effects, GHCi performs those side effects then prints the result as usual
07:25:51 <Cale> nand`: But the point is you shouldn't see it that way because you're a Haskell programmer ;)
07:26:12 <donri> > readFile "/etc/passwd"
07:26:14 <lambdabot>   <IO [Char]>
07:26:18 <Cale> getLine isn't a String with side effects :P
07:26:28 <veldskoen> hi, does anyone know why I can't do the following (I don't want to "curry" my function)
07:26:33 <Philonous> instance Show (IO a) where show  x = unsafePerformIO ( x >>= print)
07:26:36 <weexplat> getLine is a side effect with strings!
07:26:37 <veldskoen> numUniq :: (Eq a) => [a] -> Int
07:26:37 <veldskoen> numUniq x = length . nub x
07:26:49 <weexplat> (er, with string)
07:26:54 <Cale> veldskoen: length . nub $ x
07:26:58 <Cale> or (length . nub) x
07:27:09 <veldskoen> aaahhh sigh thanks
07:27:17 <Cale> veldskoen: What you wrote was equivalent to   length . (nub x)
07:27:27 <veldskoen> sorry for interupting Philonous
07:27:36 <Cale> Function application binds tighter than any infix operator
07:27:49 <nand`> Cale: but the resulting String is most certainly a value; which is what I wanted GHCi to show for me :(
07:28:06 <Cale> nand`: *maybe*
07:28:11 <veldskoen> thanks Cale
07:28:25 <Cale> nand`: Usually I'd be of the opinion that if I wanted the string to be printed, I would have written >>= print at the end
07:28:40 <nand`> veldskoen: I'm not sure how you'd curry that function :)
07:28:45 <Cale> Sometimes it's convenient to not have to do that, but in other cases, it's obnoxious
07:28:48 <Philonous> veldskoen:  Huh? You are free to speak whenever you want to.
07:29:31 <veldskoen> just joined and accidentally hit enter before i finished typing and i thought you guys were talking about something else
07:29:45 <merijn> veldskoen: Alternatively, you could also write "numUniq = length . nub"
07:30:37 <gspr> Is there an overview somewhere with a list of "typical things" to trip up loop fusion for vectors from the vector package?
07:30:57 <gspr> s/to trip up/that trip up/
07:31:12 <Philonous> veldskoen:  So what, this is IRC. There's always multiple conversations going on at the same time
07:31:55 <veldskoen> ha ha new to haskell and irc...
07:32:05 <nand`> Cale: or perhaps just typing ‘it’ afterwards
07:32:44 <donri> print =<< it  -- ;)
07:32:45 <marcot> What about if it is iso-8859-1?  Should I simply do something like: map (toEnum . fromEnum) . Data.ByteString.upack or is it unsafe?
07:33:14 <marcot> jhance: I was using download-curl as suggested by sclv, but it conduit has something as decode, I may try it.
07:33:56 <donri> marcot: see text-icu for lots of encodings
07:33:56 <jhance> marcot: It has a decoding conduit but it does not detect the actual decoding for you. It has to be specified as a parameter
07:34:42 <gspr> woops
07:35:01 <marcot> jhance: Ok, I assumed it.
07:35:03 <weexplat> marcot: i'll take this chance to randomly discourage you from using curl
07:35:04 <donri> marcot: http://hackage.haskell.org/packages/archive/conduit/0.5.2.2/doc/html/Data-Conduit-Text.html
07:35:29 <marcot> donri: Thanks, I was looking at it.
07:35:43 <marcot> weexplat: Why?
07:36:00 <weexplat> http-conduit has bugs and infelicities too, but curl's cause segfaults and i found them surprisingly easy to run into
07:36:27 <donri> someone claimed those don't happen with download-curl
07:36:32 <merijn> veldskoen: In general there will be between 0 and 10 conversations going on at any time. Hence why people tend to prefix names in responses, so clients can highlight whatever is addressed to you
07:37:32 <weexplat> donri: do you remember any particular github clis that expose the ability to create a repo?
07:38:29 <donri> weexplat: https://github.com/defunkt/hub
07:38:47 <weexplat> donri: thanks
07:39:55 <veldskoen> merijn: oh... thanks
07:41:05 <krey_> o/ for a type A and two functors F, G are the types (A -> (forall B. F B -> G B)) and (forall B . A -> (F B -> G B)) isomorphic?
07:41:37 <jhance> donri: Ugh, it looks like it completely hacks into git instead of providing a separate interface.
07:43:19 <astory> I'm looking for a logging library.  Has anyone used http://hackage.haskell.org/packages/archive/hslogger/1.2.0/doc/html/System-Log-Logger.html ?  Is it sane?
07:44:29 <weexplat> one thing i have to give curl credit for ... it does support proxies well, including both http and socks proxies, and it provides a library interface
07:44:38 <weexplat> wget does neither
07:44:50 <byorgey> astory: I've never used it personally, but I've heard good things about it, and judging by the number of packages that use it ( http://packdeps.haskellers.com/reverse/hslogger ) I'd say it's a safe bet
07:45:13 <astory> byorgey: that site rocks, thanks.  I feel better using it now
07:45:39 <astory> on a more theoretical note, I have a bit of a programming problem:
07:46:30 <astory> (for this particular A), I have a function that gets me an IO A, and I'd like to create an infinite lazy IO [A] from them, but everything I do winds up trying to evaluate the entire list.
07:46:42 <astory> is this even possible?
07:47:01 <marcot> weexplat: You mean wget command?
07:47:54 <krey_> surely someone can help me out with these types :P
07:48:29 <marcot> byorgey: Thanks for the packdeps link.  It's really awesome.
07:49:29 <c_wraith> astory: only with unsafeInterleaveIO
07:49:50 <c_wraith> astory: and that is labeled "unsafe" for a reason.  Namely, that the effects happen at unpredictable times
07:50:22 <astory> c_wraith: I'm OK with the effects taking place at weird times.  All that happens is that a counter gets incremented and a channel gets created (and I'm not doing threading)
07:50:42 <astory> I suppose it makes sense that I have to have that behavior
07:51:05 <Philonous> astory: lazily f = liftM2 (:) f (unsafeInterleaveIO $ lazily f)
07:53:02 <hpaste> astory pasted “attempt at lazy infinite IO list” at http://hpaste.org/72147
07:53:26 <astory> (before seeing Philonous's comment, this was my attempt, but it seems to still be non-lazy)
07:53:49 <c_wraith> that's the same thing
07:53:56 <c_wraith> it should be lazy
07:54:42 <astory> huh, I must not have saved or something.  It's working now
07:54:44 <Axman6> :t let uIIO = undefined :: IO a -> a; lazily f = liftM2 (:) f (uIIO $ lazily f) in lazily
07:54:46 <lambdabot>     Couldn't match expected type `IO [a1]' against inferred type `[a1]'
07:54:46 <lambdabot>       Expected type: IO (IO [a1])
07:54:46 <lambdabot>       Inferred type: IO [a1]
07:55:25 <c_wraith> Axman6: unsafeInterleaveIO is IO a -> IO a
07:55:26 <Philonous> Axman6:  uIIO :: IO a -> IO a
07:55:33 <Axman6> ah
07:55:38 <Axman6> :t let uIIO = undefined :: IO a -> IO a; lazily f = liftM2 (:) f (uIIO $ lazily f) in lazily
07:55:40 <lambdabot> forall a1. IO a1 -> IO [a1]
07:55:57 <astory> thanks for the help!  My test suite is easier to write now
08:00:41 <valentin> why let addStuff = do a <- (*2) b <- (+10) return (a+b)  fails with parse error on input `<-'?
08:01:14 <astory> valentin: oneliner do statements use semicolons instead of line breaks
08:01:31 <quicksilver> Cale: you also have the issue of function definitions involving more than one equation.
08:01:32 <Philonous> valentin:  let addStuff = do {a <- (*2); b <- (+10); return (a+b}
08:01:45 <astory> (er, and also braces >.<)
08:02:01 <quicksilver> Cale: ...if you think GHC should move towards emulating "top-level of a module" which is an idea I am broadly in agreement with.
08:02:02 <gspr> I asked a similar question on SO not long ago, but then it was phrased in terms of "what can the profiler do for me in this case?". I'll try again here and instead ask for your gut feeling, or what you would do: Suppose you've written lots of polymorphic code, but that the actual end use functions only use the polymorphic ones for a handful of concrete types. How would you go about gauging the performance cost of the polymorphism, and how would
08:02:48 <Philonous> gspr:  Your where truncated after ", and how would"
08:02:54 <gspr> Philonous: Typical me :)
08:03:03 <gspr> ", and how would you approach adding specializations?
08:03:08 <gspr> (the end)
08:04:25 <quicksilver> gspr: (1) benchmark. (2) {-# SPECIALIZE #-}
08:05:22 <gspr> quicksilver: Right. That's been my approach so far, and I've gained (or, as someone pointed out on SO, "recovered") quite a bit of performance that way.
08:06:00 <covi> I have a start monadic value, and a monadic computation. I need to chain the computations for a few times, and filter the intermediate results based on their corresponding output. How can I achieve that? Somehow have the intermediate steps of a possibility be in a tuple/list?
08:06:22 <gspr> I'm still very confused with regards to how polymorphism trips up vector loop fusion btw... do you know anything about that, quicksilver?
08:06:35 <gspr> "how" should be "how and if"
08:07:38 <quicksilver> not really.
08:07:44 <gspr> OK, thanks anyway
08:07:52 <quicksilver> RULES should fire even for polymorphic code
08:08:03 <quicksilver> unless they are deliberately restricted to particular types.
08:08:18 <quicksilver> however, the unboxed stuff has heavy instance magic - it's not true polymorphism
08:08:27 <quicksilver> weren't you using the unboxed ones?
08:08:31 <gspr> yes
08:08:54 <gspr> the polymorphic code is Unbox a... in reality it's all Double in the end :)
08:09:19 <gspr> I'll keep reducing my code and see if I can narrow it down to an example where I can actually tell for sure if the polymorphism trips up fusion
08:10:09 <quicksilver> I think maybe parametric polymorphism is quite fine for rules but adhoc polymorphism is a problem. However, I'm not confident in that thought.
08:10:27 <EvanR> how do i make a Functor instance using preexisting Monad instance
08:11:01 <EvanR> @src liftM
08:11:01 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
08:11:06 <EvanR> ah
08:11:07 <gspr> quicksilver: I have lots and lots and lots of ad-hoc poly
08:11:43 <covi> EvanR: What do you mean? Aren't monads functors?
08:12:12 <geekosaur> mathematically yes.  but for historcal reasons Monad does not imply Functor in Haskell
08:12:26 <weexplat> with ad-hoc polymorphism sometimes you get situations where rules are type-restricted, or else where rules fire but something else doesn't happen down the line (like inlining) that's needed to get the effect
08:12:31 <gspr> I know I'm probably chasing a pipe dream here... I realize polymorphism can be a performance problem, but I sorta always dreamed that "well, if you write all your code as polymorphic as possible you'll still be fine if you can use concrete types in the end of it all, and surely one can force lots of automatic specializations" :)
08:12:35 <EvanR> covi: fmap doesnt work by default, you have to write a Functor instance
08:12:40 <EvanR> and i think it is
08:12:44 <jacobian> http://paste.lisp.org/display/130693#1
08:12:47 <gspr> weexplat: I think that that's what's happening to a large degree
08:12:50 <quicksilver> gspr: it's reasonable to feel that.
08:12:53 <EvanR> fmap f m1 = m1 >>= f
08:12:54 <EvanR> ?
08:13:01 <quicksilver> gspr: it's a little hard for the compiler writers to get it right.
08:13:02 <jacobian> This code used to build but no longer does, anyone know what might have changed that would cause it, and the easiest fix?
08:13:08 <gspr> weexplat: Am I corect in believing that such things should be less of (not at all?) a problem if everything is in the same module?
08:13:24 <EvanR> oh nevermind
08:13:28 <gspr> quicksilver: Oh I can certainly imagine that! :)
08:13:30 <quicksilver> gspr: but it's also chicken and egg - we didn't have such extensive code specialising as Unboxed Vectors until (relatively) recently; now we do, the compiler authors have something to target.
08:13:31 <weexplat> gspr: i'm not sure
08:13:46 <covi> EvanR: f has to return a monadic value right?
08:13:51 <gspr> quicksilver: I understand
08:14:32 <gspr> weexplat: Because if so, a quick and dirty measure of "how polymorphically impaired are you?" could be to have a script re-name and dump everything into a single module and compare performance
08:14:42 <EvanR> covi: no fmap :: (a -> b) -> f a -> f b
08:14:43 <Saizan> jacobian: sounds like you're mixing different versions of transformers, you are not building with cabal, right?
08:14:44 <EvanR> so
08:14:53 <EvanR> fmap f m1 = m1 >>= return . f
08:15:03 <geekosaur> jacobian, the fact that one of the types has a transformers package version embedded in it suggests that you have mutiple versions of the transformers package installed
08:15:17 <weexplat> basically you can write all your code as super-polymorphic as long as you don't mind the cost of potentially rewriting it if the compiler writers you've outsourced optimization to aren't keeping up with your performance demands
08:15:43 <jacobian> Saizan: Correct, I'm not building with cabal since pisigma no longer seems to build from cabal.
08:15:44 <quicksilver> gspr: tehre is a reason that soem of the more ambitious haskell compiler projects have been whole-program compilers.
08:15:53 <weexplat> because that's basically what you're doing
08:15:59 <quicksilver> gspr: (equally there is a reason that GHC is *not* a whole-program compiler).
08:15:59 <covi> EvanR: Functor wrapped in monad, hah?
08:16:22 <mjga> how long should I wait for a package author to respond, before uploading a new version to Hackage?
08:16:23 <covi> EvanR: what about  fmap f m1 = m1 >>= mconcat . return . f
08:16:28 <merijn> EvanR: I think there's actually an "instance (Monad f) => Functor f" like that, yes
08:16:28 <jacobian> geekosaur, ok, so I probably need to the correct version of monad tranformers package.
08:16:39 <weexplat> EvanR: instance Functor YourMonad where fmap = liftM
08:16:46 <jacobian> Can I create a new user and use cabal install to get the *right* versions?
08:16:56 <jacobian> I think my versions are too recent to build gainst.
08:17:06 <geekosaur> more correctly, yoy need to make sure all your dependencies are al using the same version of the transformers package; right now, something is pulling in different versions
08:17:08 <mjga> And is there any discussion group for Hackage package dependencies and maintenance?
08:17:25 <gspr> quicksilver: But as a crude measure of "polymorphic penalty", do you think it would be feasible to merge every module into a single one (with the neccessary renamings of course)?
08:17:30 <geekosaur> often we recommend using cabal-dev to help keep this stuff straight
08:17:45 <gspr> quicksilver: Also, do you have a layman's explanation of why GHC doesn't take the whole-program view?
08:17:47 <weexplat> heh, that gives me an interesting idea
08:18:04 <gspr> by layman's explanation I mean "explanation in layman's term", not to imply that you're a layman :p
08:18:08 <gspr> *terms
08:18:19 <mjga> gspr: because GHC is slow enough, and it handles too large programs for it to make a general sense
08:18:28 <weexplat> a tool using haskell-src-exts to do whole-program compilation with ghc (by pulling all your source into one module)
08:18:33 <gspr> mjga: Ah, OK. Thanks :)
08:18:40 <gspr> weexplat: Yep! Would be interesting
08:18:55 <geekosaur> didn't someone play with doing whole program via a plugin at some point?
08:19:03 <Saizan> weexplat: i thought there was one already
08:19:13 <weexplat> Saizan: i wouldn't be surprised
08:19:45 <weexplat> Saizan: what did you think it was called?
08:20:46 <jacobian> geekosaur, Does cabal-dev have more features for managing versions?
08:21:10 <hpaste> EvanR pasted “Dialog monad” at http://hpaste.org/72154
08:21:15 <Saizan> weexplat: i don't remember
08:22:33 <geekosaur> jacobian, sort of.  it's a sandbox, where you can install specific versions of packages for particular sandboxes
08:22:51 <jacobian> annoyingly the package 'unix' no longer builds at the version I need.
08:23:12 <gspr> weexplat: I guess such a tool would be useful for performance analysis... it'd answer (crudely) how much performance is lost simply because of suboptimal optimzation (suboptimization? :) )
08:23:13 <geekosaur> it helps avoid this kind of situation, but doesnt prevent it.  (you may also want to install a newer cabal-install, which I think requires you to explicitly upgrade because the new version is blocked)
08:23:17 <jacobian> geekosaur, that sounds useful
08:24:00 <jacobian> I have cabal install 0.14.0
08:24:46 <geekosaur> interesting.  it should have noticed the conflict.  or did you say this is without cabal?
08:25:08 <geekosaur> (older cabal-install didn't do a good job of preventing this, but at least tried.  current version tries harder)
08:26:26 <weexplat> gspr: even in a single module though inlining away polymorphism isn't unlimited though
08:26:41 <gspr> weexplat: Hmm, OK
08:26:56 <gspr> :(
08:27:06 <weexplat> gspr: it is a lot more, though, i think
08:27:07 <gspr> I guess I want to have my cake and eat it too
08:29:24 <gspr> Gotta run. Thanks for teaching me stuff quicksilver, weexplat, mjga :)
08:33:37 <jacobian> geekosaur, I just started a new user to do a fresh install and the unix package required dies during build.
08:33:54 <jacobian> I downloaded the source for pisigma because I couldn't get it to build in cabal.
08:34:00 <jacobian> but that didn't help either :)
08:34:09 <EvanR> :t interact
08:34:10 <lambdabot> (String -> String) -> IO ()
08:34:13 <EvanR> so
08:34:26 <EvanR> how does that work?
08:34:38 <copumpkin> awesomely
08:34:38 <EvanR> it just prints out f of your input?
08:34:40 <geekosaur> @src interact
08:34:41 <lambdabot> interact f = do s <- getContents; putStr (f s)
08:34:48 <copumpkin> you get stdin as input to your funciton
08:34:53 <bitrust> Anyway here got ThreadScope working on OS X?
08:34:53 <copumpkin> and the output is considered as stdout
08:34:56 <EvanR> ok
08:35:01 <EvanR> so memoryless
08:35:02 <copumpkin> EvanR: lazily :P
08:35:11 <copumpkin> so you can actually write real interactive programs with it
08:35:13 <bitrust> s/way/one
08:35:15 <copumpkin> if you're sneaky
08:35:26 <EvanR> i was trying to
08:35:34 <EvanR> did you see my dialog monad?
08:35:42 <DMcGill> it's important to note that stdIn and stdOut are by default line buffered
08:36:00 <copumpkin> oh yeah
08:36:03 <jacobian> I think I'm going to have to port the code to newer versions...
08:36:04 <DMcGill> so that String isn't one input - it's the entire session
08:36:05 <copumpkin> that'll probably confuse the issue
08:36:14 <copumpkin> EvanR: nope
08:36:24 <EvanR> http://hpaste.org/72154
08:36:50 <copumpkin> nice
08:37:09 <copumpkin> (\z -> cont z >>= f)
08:37:11 <copumpkin> cont >=> f
08:37:12 <EvanR> i dont think i can do a :: Dialog a -> (String -> String) to work in interact though
08:37:12 <copumpkin> :)
08:37:28 <copumpkin> EvanR: you can if you assume newlines separate interactions
08:37:37 <copumpkin> then you just want to run lines on the input
08:37:40 <copumpkin> (and turn off buffering)
08:37:54 <EvanR> lines are find
08:37:56 <EvanR> fine*
08:38:02 <EvanR> i still dont get it...
08:38:12 <copumpkin> EvanR: just think how awesome you'd be if you used kleisli composition there
08:38:20 <copumpkin> you'd be the ultimate badass
08:38:24 <copumpkin> bitcoinhaskeller
08:38:26 <DMcGill> am I missing something? How does line 18 compile? Doesn't Answer have type a -> Dialog a?
08:38:30 <EvanR> yeah i would have written something in haskell i dont even understand again
08:38:30 <EvanR> lol
08:38:47 <DMcGill> oooh
08:38:51 <DMcGill> now I feel stupid
08:39:03 <DMcGill> sorry
08:39:03 <copumpkin> DMcGill: we still love you, don't worry
08:39:07 <EvanR> heh
08:39:22 <EvanR> im confusing people in #haskell, that means i gained a level of badassery
08:40:03 <DMcGill> just because I'm always hanging around here doesn't mean I'm a pro!
08:40:03 <mcstar> give him a lambda badge already!
08:40:14 <dBuchmann> Hi all. Does the 2012.2.0.0 version of the platform work on OS Mountain Lion?
08:41:06 <mcstar> EvanR: take good care of this: (λ)
08:41:18 <EvanR> lol (?)
08:41:51 <mcstar> its a badge, made from solid lambda alloy
08:42:01 <mcstar> the parens represent the circlular shape
08:42:02 <EvanR> it doesnt show up through screen :(
08:42:34 <mcstar> EvanR: oh, you dont have unicode?
08:42:44 <EvanR> iterm works but screen isnt
08:43:10 <EvanR> encoding problem
08:43:13 <suprdewd> EvanR: too bad, the badge is really badass
08:43:23 <mcstar> XD
08:43:29 <EvanR> shut up
08:43:36 <EvanR> youre supposed to be encouraging
08:44:04 <EvanR> what package is kleisli in
08:44:36 <DMcGill> Control.Monad
08:44:42 <DMcGill> Control.Arrow
08:44:44 <DMcGill> I mean
08:45:19 <EvanR> i dont see (>=>) in Control.Arrow
08:45:20 <DMcGill> the trouble with interact is that you can't get your answer back. Something like runDialog :: Dialog a -> IO a might be better
08:45:28 <DMcGill> @hoogle (>=>)
08:45:28 <lambdabot> Control.Monad (>=>) :: Monad m => (a -> m b) -> (b -> m c) -> (a -> m c)
08:45:37 <DMcGill> @hoogle Kleisli
08:45:37 <lambdabot> Control.Arrow Kleisli :: (a -> m b) -> Kleisli m a b
08:45:38 <lambdabot> Control.Arrow newtype Kleisli m a b
08:45:38 <lambdabot> package Kleislify
08:45:38 <EvanR> oh monad
08:45:50 <suprdewd> EvanR: http://latex.codecogs.com/gif.latex?(\lambda)
08:45:56 <suprdewd> There you are.
08:46:19 <EvanR> that is so awesome suprdewd
08:47:54 <mjga> is there any rfc/code of conduct/ritual with regards to non-maintainer updates on Hackage? Or any helpful hand for reviewing quality of Hackage packages?
08:48:03 <hpaste> DMcGill annotated “Dialog monad” with “Dialog monad (annotation)” at http://hpaste.org/72154#a72156
08:48:38 <jhance> mjga: Umm, don't update someone elses package without their permission is a good default for managing non-maintainer updates
08:48:53 <hpaste> EvanR pasted “Dialog Monad with kleisli” at http://hpaste.org/72157
08:48:55 <DanBurton> mjga: the general idea is, first, try to contact the maintainer. failing that, talk it out on #haskell and maybe also the mailing lists
08:49:06 <mjga> jhance: I know, the question is what to do when maintainer doesn't respond
08:49:40 <mjga> DanBurton: which mailing lists would you suggest? for example for Dyre
08:49:41 <DMcGill> fmap = (<$>) would be better
08:49:56 <DanBurton> @hackage Dyre
08:49:56 <lambdabot> http://hackage.haskell.org/package/Dyre
08:49:59 <DMcGill> also I import Control.Applicative ((<$>)) in pretty much everything I do
08:50:02 <DanBurton> um
08:50:03 <EvanR> DMcGill: meh i dont like <$> in non applicative
08:50:10 <DanBurton> not sure what that is
08:50:11 <DMcGill> it's the same as liftM and fmap for monads
08:50:36 <DanBurton> I like how <$> looks like $
08:50:46 <DanBurton> its much more annoying to write `liftM` or `fmap`
08:50:49 <DMcGill> actually that's a stupid idea as fmap = <$>
08:50:55 <DMcGill> so in this case you'd need to use liftM
08:51:10 <EvanR> i love typing fmap
08:51:11 <donri> @hackage dyre
08:51:12 <lambdabot> http://hackage.haskell.org/package/dyre
08:51:15 <DMcGill> did you see my runDialog annotation?
08:51:16 <mjga> There are a few pull requests from other guys, and a nice functionality that I tried to add, but no response for some time...
08:51:21 <EvanR> DMcGill: reading now
08:51:32 <DMcGill> there's not a lot to it
08:52:12 <mjga> ok, thanks. Looks like someone quietly pulled :-)
08:53:18 <DanBurton> mjga: regarding mailing lists, when in doubt try Haskell Cafe and go from there
08:54:20 <mjga> DanBurton: thx a lot. I will subscribe again. Obviously there are quite often some package interdependencies that need to be fixed together. :-)
08:54:28 * mjga happy
08:54:49 <srhb> I'm a bit confused about the concurrent server demos. They all tend to go like loop socket = do handle <- accept sock; forkIO (something handle `finally` hClose handle); loop socket -- but does the forkIO actually help anything? Does that handle not block the loop from actually resuming anything? Mustn't it be closed before we can go again?
08:54:50 <Philonous> I wish the prelude contained for = flip map (analogous to mapM => forM)
08:54:52 <hpaste> EvanR annotated “Dialog monad” with “Dialog monad (annotation) (annotation)” at http://hpaste.org/72154#a72158
08:55:07 <EvanR> DMcGill: ok i fixed it and did some alpha conversion
08:55:33 <dBuchmann> Can anybody report if 2012.2.0.0 works on OS X 10.8 (Mountain Lion)?
08:55:42 <EvanR> srhb: forkIO does not block
08:55:53 <EvanR> finally is an exception handler
08:55:56 <DanBurton> I wish so badly that Haskell had better built-in self-serve sugar mechanisms.
08:55:58 <fmap> i wish prelude contained `reject f = filter (not . f)' :(
08:56:01 <srhb> EvanR: No, but I mean the handle.. Until it is closed, can we actually get a new handle with accept sock?
08:56:26 <EvanR> srhb: yes, in the bsd sockets paradigm, the accepting socket can produce infinite normal sockets
08:56:37 <srhb> EvanR: Oh! Excellent! That explains a lot. :-)
08:56:48 <DanBurton> fmap: in this chat channel, doesn't it get tiresome to use that particular nick?
08:56:57 <DanBurton> what with all the callouts
08:57:03 <S11001001> fmap: reject for the smalltalky confusion that filter is present instead of select?
08:57:05 <srhb> So this is actually the most barebones example of what every concurrent server will look like in Haskell?
08:57:08 <EvanR> :t fmap fmap fmap
08:57:09 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
08:57:24 <DMcGill> EvanR: we'll indoctrinate you into using applicative style yet ;)
08:57:30 <EvanR> srhb: concurrent server like this is really the only way to do it
08:57:39 <srhb> EvanR: Neat. :-)
08:57:40 <EvanR> and it beats the hell out of the C style without threads
08:57:43 <srhb> Right.
08:58:00 <EvanR> srhb: check out my networking code for my project
08:58:06 <srhb> EvanR: Which one is that?
08:58:08 <EvanR> its probably got too much already
08:58:53 <hpaste> EvanR pasted “networkin” at http://hpaste.org/72160
08:59:03 <srhb> EvanR: Thanks :)
08:59:23 <EvanR> its not complete, and might be more complex than necessary
08:59:58 <EvanR> masterSpawn produces the stuff the main thread needs, which will be ignorant of all networking
08:59:59 <DMcGill> one of these days when I've got nothing better to do I'll write a networked multiplayer game with HOpenGL and so on
09:00:02 <fmap> S11001001: what would be more suitable? cofilter?
09:00:12 <DMcGill> perhaps I could get away with doing it as my 4th year dissertation?
09:00:12 <fmap> DanBurton: sometimes :[
09:01:05 <DMcGill> that's a though: apart from HOpenGl which I've heard is too low level, what other ways of doing 2D or 3D graphics are there? Can reactive-banana do more than GUIs?
09:06:53 <srhb> I tried writing a simple connect/print/disconnect loop to see how fast I can open and close connections, but it seems to freeze for a few seconds every few hundred connections. Any obvious suspect?
09:07:24 <srhb> I'm basically doing connectTo host port >>= hClose >> print counter
09:07:55 <srhb> Oh, actually I'm seeing broken pipes on the server side. Hmm.
09:08:34 <geekosaur> srhb, are you running out of sockets on one side or the other?  (google "socket TIME_WAIT")
09:08:44 <srhb> geekosaur: Thanks, checking
09:08:56 <monochrom> nothing GHC-specific should cause freeze for more than 1 second
09:09:04 <Saizan> could also be I/O buffering of the prints, if that's how you're experiencing the freezes
09:09:14 <monochrom> I mean, even if you try to blame GC, not going to be that long
09:09:23 <srhb> I bet it's not GHC related.
09:09:29 <geekosaur> recently closed sockets hang around for a bit in case there are additional packets in flight due to network anomalies
09:09:32 <S11001001> fmap: remove
09:10:03 <monochrom> I would first blame DNS if it's a few seconds long
09:10:54 <srhb> randomserver: <socket: 6>: hPutChar: resource vanished (Broken pipe)
09:11:04 <monochrom> actually, wifi packet drops, too, but I don't know that you're on wifi
09:11:14 <srhb> both server and client is on localhost
09:11:47 <monochrom> if you have "broken pipe" left right and centre, you have a programming error
09:11:59 <srhb> Alright.
09:12:09 <monochrom> like closing too early or not closing
09:12:40 <covi> Is mapM_ only typically useful for printing?
09:12:42 <srhb> Can I expect hPutStr handle string `finally` hClose handle to not close too early nor not close at all?
09:12:57 <hape01> The _ says: do discard the results of the actions
09:13:02 <hape01> covi: The _ says: do discard the results of the actions
09:13:23 <monochrom> no no, you misunderstand. if the writer gets broken pipe, it means the reader closes too early
09:13:34 <srhb> monochrom: Ah, okay.
09:13:37 <covi> hape01: yep, that's why i ask the question
09:13:55 <byorgey> covi: no, it can be used for all sorts of things.  Any time you want to map over a list and generated monadic actions, where you only care about the "side effects" of the actions
09:13:57 <srhb> monochrom: I have hGetContents handle >> hClose handle on that end -- might that be the culprit?
09:14:11 <weexplat> DMcGill: i've heard good things about drawingcombinators (or is it drawing-combinators?) at least for 2D
09:14:11 <byorgey> covi: for example, maybe you want to map each element of a list to an update to the state in a State monad
09:14:11 <hape01> covi: if you are not interested in the results, you might print, save, send, ... and so on?
09:14:26 <monochrom> yes
09:14:51 <EvanR> graphics-drawingcombinators
09:14:52 <monochrom> (it's already 2012, why do people still do hGetConents and immediately hClose?)
09:14:56 <byorgey> covi: or maybe you just want to check each element of the list for some sort of "validity", and fail (in the Maybe monad) if any of them are invalid
09:15:01 <covi> byorgey: what happens when  mapM putStrLn [String]?
09:15:06 <weexplat> srhb: that will close the handle right away
09:15:19 <byorgey> covi: you get a result like  [(),(),(),()]
09:15:30 <srhb> monochrom: Huh?
09:15:35 <covi> while things get printed out?
09:15:40 <byorgey> covi: which you can figure out just by looking at the type
09:15:45 <monochrom> even without considering inter-process communication... it guarantees that you will read nothing
09:15:53 <byorgey> @type mapM putStrLn ["a","b","c"]
09:15:54 <lambdabot> IO [()]
09:16:07 <monochrom> s <- hGetContents h; hClose h;  this guarantees that s is empty.
09:16:15 <srhb> monochrom: Really, why?
09:16:22 <weexplat> srhb: getContents delays reading until you actually look at the data
09:16:22 <srhb> That doesn't seem very intuitive.
09:16:24 <covi> > mapM putStrLn ["a"]
09:16:25 <lambdabot>   <IO [()]>
09:16:25 <monochrom> because the reading hasn't even started
09:16:26 <srhb> Ah, doh
09:16:27 <srhb> Laziness.
09:16:35 <byorgey> covi: "while things get printed out" is meaningless.  You get an action of type  IO [()].  When executed, that action will print some strings to the screen, and return as its result a list of units
09:16:36 <srhb> Lazy IO kills me. ._.
09:16:36 <covi> > mapM_ putStrLn ["a"]
09:16:37 <lambdabot>   <IO ()>
09:17:06 <weexplat> srhb: you could always use pipes or conduits
09:17:10 <covi> byorgey: I see, my mistake.
09:17:21 <jhance> Lazy IO isn't intuitive which is why we have pipes & conduits
09:17:22 <covi> byorgey: Why isn't lambdabot performing the action?
09:17:26 <monochrom> the other day on haskell-cafe another person was doing exactly that and could not see why s was empty
09:17:33 <srhb> weexplat: System.IO.Strict seems to do the trick.
09:17:44 <byorgey> > readFile "/etc/passwd" >>= putStrLn   -- covi, that's why
09:17:45 <lambdabot>   <IO ()>
09:17:55 <srhb> monochrom: Well, I realized it once you said it, but yeah, it is not intuitive once you start mixing state and laziness.
09:18:02 <byorgey> lambdabot does not execute any IO actions for security
09:18:13 <weexplat> srhb: that's another way, but it means you buffer the entire input before you process any
09:18:38 <srhb> OK, now it runs to about 10k connections before starting to stutter.
09:18:47 <srhb> weexplat: It's very small input :-)
09:18:55 <covi> byorgey: okay, thanks
09:19:19 <jhance> byorgey: But wouldn't lambabot have to be root for that to actually work, anyway?
09:19:23 <weexplat> srhb: if you're trying to handle 10k connections i assume it's on an open network?
09:19:43 <byorgey> jhance: well, OK, that was a bad example.  But you can come up with all sorts of other examples that would do bad things.
09:19:50 <monochrom> I think srhb is currently just measuring speed
09:19:52 <srhb> weexplat: No, not 10k concurrently, I was just opening and closing connections to see how fast it goes.
09:20:03 <srhb> And then I was wondering why that stutter was occurring.
09:20:08 <weexplat> oh
09:20:17 <byorgey> like deleting all the files in the current directory.
09:20:57 <weexplat> jhance: anyone can read /etc/passwd, it's /etc/shadow you need root for ...
09:21:27 <quicksilver> if georgi had been invented when lambdabot was conceived perhaps we could have let it do IO.
09:21:36 <jhance> weexplat: Oh, my bad
09:21:40 <weexplat> (/etc/passwd doesn't have any passwords on modern unix systems, its name is a historical curiosity)
09:22:43 <quicksilver> weexplat: "modern" : since SVR3.2 in 1988 and BSD4.3 in 1990 :)
09:22:46 <c_wraith> heck. it doesn't even have *hashes* on modern systems.
09:22:55 <c_wraith> /etc/shadow has the hashes
09:23:05 <weexplat> c_wraith: i count those as passwords for these purposes
09:23:39 <byorgey> ok, ok, it was a bad example =)
09:24:25 <hape01> @src (+)
09:24:26 <lambdabot> Source not found. Where did you learn to type?
09:24:35 <hape01> @explain me this
09:24:35 <lambdabot> Unknown command, try @list
09:24:49 <monochrom> it was a good example if we're talking about linkedin :)
09:25:12 <c_wraith> @src (+) Int
09:25:12 <lambdabot> Source not found. I am sorry.
09:25:19 <hape01> hehe
09:25:22 <c_wraith> I never remember the syntax
09:25:24 <Axman6> the Int comes first
09:25:28 <c_wraith> @src Int (+)
09:25:29 <lambdabot> Source not found. I feel much better now.
09:25:30 <hape01> for what is @src good for?
09:25:31 <Axman6> @src [] (>>=)
09:25:32 <lambdabot> xs >>= f     = concatMap f xs
09:25:34 <c_wraith> ah, good
09:25:39 <Axman6> @src map
09:25:39 <lambdabot> map _ []     = []
09:25:40 <lambdabot> map f (x:xs) = f x : map f xs
09:25:42 <Axman6> @src Maybe
09:25:43 <lambdabot> data Maybe a = Nothing | Just a
09:25:47 <hape01> why not @src (+)?
09:25:49 <Axman6> it's goof for heaps of stuff
09:25:54 <Cale> hape01: it looks up bits of source in a big text file
09:25:56 <Axman6> hape01: what do you want it to tell you?
09:26:06 <Cale> Axman6 pls
09:26:06 <Axman6> it's also different for every Num instance
09:26:08 <c_wraith> hape01: because (+) doesn't have one implementation - it has an implementation for every different type
09:26:12 <hape01> Axman6: i am seeking for the implementation of (+)
09:26:16 <Cale> :)
09:26:33 <hape01> interesting...
09:26:34 <Axman6> for Int, it's probably plusInt, which calls plusInt# on the unboxed Ints
09:26:34 <bitonic> hape01: for which type?  (+) is a class value
09:26:46 <Axman6> @instances Num
09:26:47 <lambdabot> Double, Float, Int, Integer
09:27:03 <Axman6> (+) for Double is completely different to Integer's
09:27:08 <monochrom> (+) is implemented by recursively calling (+)
09:27:14 <hape01> bitonic: but there are haskell sources for that?
09:27:16 <bitonic> those are all built-in, in GHC
09:27:25 <hape01> bitonic: thanks now I see
09:27:39 <hape01>  at src is not good for built-ins
09:27:52 <bitonic> hape01: no, there are no sources (apart from Integer).  there are circuits.
09:27:57 <quicksilver> at src is not good for anything.
09:28:04 <hape01> :-)
09:28:12 <quicksilver> if you want source of things, use the library docs
09:28:17 <quicksilver> which have the (GHC) source of everything.
09:28:39 <Cale> Well, often the code which @src gives is easier to read than the actual GHC source.
09:28:58 <Cale> But it's also less accurate like that :)
09:29:07 <c_wraith> @src sort
09:29:07 <lambdabot> sort = sortBy compare
09:29:16 <c_wraith> @src sortBy
09:29:16 <lambdabot> sortBy cmp = foldr (insertBy cmp) []
09:29:26 <bitonic> insertion sort!
09:29:27 <c_wraith> hehe.  Yes, that's not *quite* the library implementation
09:30:08 <weexplat> it's almost the same.  they both sort lists!
09:30:12 <bitonic> the GHC sort is not even that complicated
09:30:34 <c_wraith> It always amazes me how many people don't know bottom-up mergesort, though
09:30:35 <quicksilver> Cale: and in the past it has been wrong in a few places (although that may not be true now) as it's manually maintained; and the syntax is annoying (w.r.t. classes and instances)
09:30:46 <quicksilver> Cale: and it only covers certain modules.
09:30:47 <LostPW> helllo
09:30:57 <quicksilver> which are all reasons why I recommend the library doc/sources
09:31:00 <hpaste> dzhus pasted “Ambiguity with MultiParamTypeClasses problem” at http://hpaste.org/72161
09:31:02 <quicksilver> (or a local haddock setup)
09:31:06 <LostPW> is there anybody who can help me parsers
09:31:24 <bitonic> the thing that annoys me is that there is no way to instruct cabal to generate the sources links
09:31:30 <dzhus> Am I trying to do something really broken? http://hpaste.org/72161
09:31:35 <quicksilver> dzhus: yes.
09:31:43 <c_wraith> dzhus: yeah..  that's not really going to work
09:31:51 <c_wraith> dzhus: at least not without type annotations everywhere
09:31:59 <quicksilver> dzhus: every method needs to mention all the type variables (unless fundeps mean some can be deduced from others)
09:32:03 <hpaste> LostPW pasted “Parser-kram” at http://hpaste.org/72162
09:32:05 <quicksilver> c_wraith: not *even* with type annotations.
09:32:18 <quicksilver> there is no annotation you can give to 'bar' which will fix the type of 'b'.
09:32:28 <c_wraith> oh, that's true
09:32:35 <LostPW> i dont understand the twochars exemple
09:32:50 <LostPW> with the lampdas
09:32:56 <weexplat> i didn't even notice the code because i was blinded by the username
09:33:11 <c_wraith> dzhus: ghc needs to know *both* types to pick the instance.  the functions in that class don't give any way for ghc to determine what both types are
09:37:23 <Cale> LostPW: If x is a parser, and f is a function, then  x >>= f  is a parser which runs the parser x, and applies the function f to its result(s) to get another parser, and then runs that one on whatever is left of the input
09:37:33 <hape01> Now I found the quasi "source code" (class values, instances, ...) for (+). It is is module GHC.Num
09:37:38 <Cale> ...
09:37:41 <Cale> he left
09:38:20 <c_wraith> hape01: you'll quickly discover those aren't very useful, though.  They just refer to primitive ops provided by the runtime
09:38:54 <mjga> hape01: or you can download ghc source distribution and look into the directory "libraries/" or "rts/" to check source even for functions that are defined in C. Not sure about compilation primitives though.
09:40:55 <hape01> c_wraith, mjga: I found the haskell coding here - for me it is good to understand what is happening. would like lambdabot would show me the link to this, when i search for src (+):    hackage.haskell.org/packages/archive/base/3.0.3.2/doc/html/src/GHC-Num.html
09:41:57 <c_wraith> hape01: but that's not the source for (+).  That's just the source for plus for a couple types.
09:42:03 <c_wraith> @src Num
09:42:03 <lambdabot> class  (Eq a, Show a) => Num a  where
09:42:04 <lambdabot>     (+), (-), (*)           :: a -> a -> a
09:42:04 <lambdabot>     negate, abs, signum     :: a -> a
09:42:04 <lambdabot>     fromInteger             :: Integer -> a
09:42:18 <mcstar> (+)    = plusInt
09:42:19 <c_wraith> *that* is the only thing you can accurately call the source for (+)
09:42:32 <mcstar> pretty useless
09:42:38 <c_wraith> because everything else is a specific instance
09:43:00 <mcstar> friend of mine, i taught haskell was one day asking me similar questions
09:43:13 <mcstar> i was surprised where do these questions come from..
09:43:17 <hape01> ah I see the difference.... for me the instance information is the thing i search for... ok I understand the different meanings now, thank you a lot for explaining.
09:44:12 <hape01> intuitivly I search the coding where I can have a look on to geht details about (+) - not intersted in the plusInt thing...
09:45:19 <mcstar> http://hackage.haskell.org/packages/archive/base/3.0.3.2/doc/html/GHC-Num.html
09:45:24 <mcstar> wo 'src'
09:45:38 <mcstar> no need to look at the source
09:45:44 <mcstar> it will blind you
09:45:51 <hape01> mcstar :-)
09:47:02 <weexplat> ˣ_ˣ -- MY EYES
09:47:26 <srhb> Yes, it is furiously ugly.
09:48:42 <jhance> This is a very old version... base 3.x...
09:48:49 <edwardk> wait, we're still missing an instance of traversable for Either?
09:48:55 <edwardk> whoa
09:48:58 <weexplat> still?
09:49:15 <edwardk> it came up on a mailing list proposal a couple years ago, i guess it just never went in =(
09:49:21 <weexplat> why does Either always get the short end of the instance stick?
09:49:49 <edwardk> this one there isn't an excuse for the Monad at least was an instance for a class defined in a the Prelude for a type defined in the Prelude
09:49:56 <edwardk> but the lack of Foldable/Traversable is just stupid
09:50:48 <c_wraith> just sneak onto a maintainers computer and submit the patch to base
09:52:21 <edwardk> heh
09:52:51 <Igloo> FWIW, I don't think being in the Prelude is relevant
09:53:09 <edwardk> Igloo: well, it was the original motivation for Control.Monad.Instances
09:53:23 <edwardk> which we talked about in a libraries request at some point about eliminating
09:53:34 <edwardk> and pushing the instances into haskell'
09:53:44 <edwardk> but i'm not sure whatever happened there
09:53:46 <Igloo> That module is empty nowadays
09:53:50 <edwardk> score
09:53:54 <edwardk> one down =)
09:54:06 <Igloo> "FWIW, I don't think being in the Prelude is relevant any more" if you prefer  :-)
09:54:10 <edwardk> yeah
09:54:21 <edwardk> i was just explaining why Either got shafted before ;)
09:54:30 <tgeeky> only insofar as the things in the prelude steal your damn syntax!
09:54:35 <edwardk> tgeeky: =P
09:54:45 <Igloo> I have a feeling that a recent discussion decided that there shouldn't be a Monad instance for Either, though
09:54:53 <edwardk> fuck
09:54:55 <tgeeky> haha
09:54:59 <Igloo> I vaguely recall that an Error or ErrorT type was created instead
09:55:13 <tgeeky> yeah, I think that's in transformers?
09:55:26 <edwardk> transformers has ErrorT, but ErrorT has the constraint
09:55:33 <edwardk> which is annoyingly named Error
09:55:47 <edwardk> which prevents Error from being the name for the simpler Error monad =/
09:55:59 <tgeeky> i haven't yet used either part of an Either to mean an error
09:56:25 <edwardk> so basically by killing the instance of Monad for Either, EitherT dies, and about 30 packages of mine will stop compiling
09:56:34 <Cale> Either should just be made a Monad with fail = undefined
09:56:38 <edwardk> it is
09:56:51 <edwardk> that was done a couple years ago
09:56:55 <edwardk> and it was a resounding success
09:57:00 <tgeeky> hehe
09:57:05 <xkb> Anyone here using a mac having troubles after upgrading to mountain lion wrt ghc?
09:57:25 <Igloo> Oh, Either is still a Monad, so I must be misremembering
09:57:29 <edwardk> whew
09:57:33 <edwardk> you scared the crap out of me
09:58:06 <Cale> Where is the instance? Are we talking about the one in Control.Monad.Error?
09:58:21 <edwardk> the instance doesn't live in control.monad.error its in base now
09:58:26 <Igloo> Maybe it was changing it to take an Error e constraint that was rejected
09:58:26 <tgeeky> general question .. when you specify a function has INLINE, how can you see if it's firing? and how can I run a compiled (and inlined) module with ghci?
09:58:32 <edwardk> it was in Control.Monad.Instances but it got factored down to wherever Either lives
09:58:32 <Cale> In what module in base?
09:58:34 <Cale> oh
09:58:35 <edwardk> yes
09:58:40 <Igloo> Data.Either
09:58:49 <Cale> right, yeah
09:59:14 <c_wraith> tgeeky: for the first, looking at the core.
09:59:26 <EmilyS> blargh
09:59:36 <edwardk> during the initial proposal i actually somewhat cheekily suggested fail = Left . error -- which would address the pattern matching folks concerns, but in practice it doesn't look like the instance has been an issue
09:59:36 <c_wraith> tgeeky: for the second, ghci will prefer compiled modules if one exists in the current directory
09:59:56 <tgeeky> c_wraith: so ghc -c -O2 or ghc --make?
09:59:58 <tgeeky> ir neither?
10:00:13 <edwardk> that would give folks who want to do silly things like [ … | Right a <- [Left 1, Right 2] ]
10:00:26 <edwardk> the ability to use the sugar
10:00:36 <tgeeky> c_wraith: and, is it possible to ghci to load a compiled module that's installed through the cabal package?
10:00:40 <c_wraith> edwardk: that already works, though, because it's using []'s fail
10:00:45 <weexplat> hah, i think fail = Left . error might actually be the closest thing to actually correct
10:00:54 <edwardk> oh yeah that one worked
10:01:01 <Cale> tgeeky: -ddump-simpl is the flag you want, I think
10:01:17 <edwardk> something more complicated falls through the cracks =)
10:01:17 <edwardk> oh yeah, when its not Left 1
10:01:20 <edwardk> but fail "foo"
10:01:21 <c_wraith> tgeeky: any code that's in a package is loaded from the compiled package, not as source. heck, source for packages isn't even kept around
10:01:23 <Cale> The closest thing to actually correct is removing fail from the Monad class
10:01:27 <Cale> because it doesn't belong there
10:01:29 <jhance> Apparently all of my haddock files for the core ghc libraries are of the wrong version... how do I rebuild them? Do I need to reinstall ghc?
10:01:38 <edwardk> cale: i'd be on board but good luck convincing the masses =P
10:01:54 <c_wraith> bring back MonadZero!!!
10:02:00 <weexplat> Cale: well, i meant the closest thing to correct given the current definition of Monad
10:02:01 <Cale> c_wraith: agree!
10:02:29 <Cale> weexplat: Usually I just pretend that fail doesn't exist.
10:02:30 <sclv> i thought there was wide agreement that fail should go, but not enough sentiment to bite the bullet and cause breakages to clean things up
10:02:46 <Cale> sclv: But now we're allowing breakages with things like Num
10:02:48 <c_wraith> maybe we could fix that at the same time we make Monad depend on Applicative
10:03:11 <tgeeky> Cale: ok. I am pretty sure everything is as I expected, but I am asking because I am not sure. So I have a package, and I open ghci (*not* in the base directory of the package), and do :m + Some.Module.Here ;  functionFromModule
10:03:24 <tgeeky> and I see "Loading package < package > ... linking ... done." x 15
10:03:26 <tgeeky> then a result.
10:03:35 <tgeeky> So I assume the lack of the word "interpreted" there means that's compiled
10:03:37 <sclv> well, Num is hardly as fundamental as Monad :-P
10:04:00 <Cale> interpreted means that GHCi is doing bytecode compilation rather than loading an already compiled .o
10:04:07 <sclv> its vastly more complicated and obscure :-)
10:04:18 <EmilyS> I am trying to lean some haskell, and I want to implement a quadratic equation. To do that you need to store intermediate results, and I am somehow messing this up entierly. Could I get a hint?
10:04:20 <EmilyS> https://github.com/Noia/haskellexperiments/blob/master/quad/quad.hs
10:04:49 <Cale> EmilyS: first thing: configure your text editor not to produce tab characters
10:05:09 <Cale> EmilyS: the alignment is all off, and you'll get errors from that code just for that.
10:05:18 <tgeeky> Cale: well, namely, this is the difference between :m + Data.Complex.Cyclotomic  returning nothing, and :l src\Data\Complex\Cyclotomic.hs  loading: [1 of 1] Compiling Data.Complex.CZ  ( src\Data\Complex\Cyclotomic.hs, interpreted )
10:05:20 <sclv> your syntax for let is also wront
10:05:28 <tgeeky> Cale: so seems clear enough
10:05:34 <sclv> or, rather you shouldn't be in a monad at all
10:05:39 <jfischoff> tgeeky: watch out Cyclotomic is super slow
10:05:50 <EmilyS> Cale: ah
10:05:56 <sclv> so its just "let x = foo; y = bar; in (Just x, Just y)"
10:06:00 <tgeeky> jfischoff: I haven't found that to be the case
10:06:08 <sclv> (for semicolons read newlines or whatever)
10:06:39 <sclv> indermediate results you give names to will be shared and only computed once
10:06:39 <Cale> EmilyS: Secondly, you don't want do-notation, because you're not composing a monadic action of any sort here (perhaps you could use the Maybe monad effectively, but it's not required)
10:06:51 <tgeeky> jfischoff: I've been hacking on it for the last day or two
10:06:55 <Cale> EmilyS: let <declarations> in <expression>
10:07:07 <jfischoff> tgeeky: I'm using it for a dft, I had to modify it to only use integers in the range of 0 to 6 and lists under 20
10:07:19 <tgeeky> jfischoff: oh, well let's work on it
10:07:25 <tgeeky> since I explicitly need a foruier transform
10:07:31 <tgeeky> #pee?
10:07:38 <Cale> EmilyS: you will probably want to compute the discriminant of the quadratic (i.e. b^2 - 4 a c) and based on whether it is positive, negative, or zero, produce a different result
10:07:58 <EmilyS> Cale: the idea is to return a touple with Maybe Number
10:08:05 <EmilyS> since, you can get illegal roots
10:08:09 <Cale> right
10:08:29 <EmilyS> must figure out how to configure sublime
10:08:29 <Cale> But in this case, if you just wrote   let <the definitions you made> in (Just p, Just q)
10:08:48 <Cale> then that will never let either of the roots be Nothing
10:09:13 <EmilyS> Yea, I'm not finished
10:09:15 <Cale> Also, your class context is really weird
10:09:30 <EmilyS> probably, I have no clue what I'm doing!
10:10:13 <Cale> If you really want it to be polymorphic, I recommend starting with  quad :: (Floating a) => a -> a -> a -> (Maybe a, Maybe a)
10:10:24 <Cale> :t sqrt
10:10:25 <lambdabot> forall a. (Floating a) => a -> a
10:10:54 <Cale> But you could also just pick a concrete type like Double if that's confusing
10:11:08 <Cale> quad :: Double -> Double -> Double -> (Maybe Double, Maybe Double)
10:12:07 <Cale> btw, it is perfectly valid to use - as prefix
10:12:08 <c_wraith> wouldn't you really want Maybe (Double, Double) ?
10:12:16 <Cale> You can write (-b) rather than (0-b) if you prefer
10:12:17 <ssbr-> What is the "forall" in lambdabot's output? Just making the type signature more explicit?
10:12:26 <Cale> c_wraith: there may be just one root
10:12:34 <Cale> ssbr-: yeah
10:12:42 <weexplat> if you're content to count a double root as 2 roots you can keep the Maybe outside the tuple
10:12:44 <c_wraith> yes, but expressing it as a pair with one Nothing and one Just is awkward
10:12:53 <c_wraith> Much simpler to just make it a double root
10:13:01 <Cale> That's true
10:13:24 <c_wraith> might be simpler yet to return a list of roots
10:13:32 * hackagebot lens 0.3 - Lenses and Lens Families (EdwardKmett)
10:13:55 <c_wraith> edwardk: I see you've finally gone down to the simplest possible package name
10:14:00 <edwardk> c_wraith: =)
10:14:09 <edwardk> c_wraith: its actually a pretty nice package
10:14:20 <Eduard_Munteanu> Wait till you get lens-extras :P
10:14:35 <edwardk> nah, lens already includes TemplateHaskell and RankNTypes
10:14:55 <edwardk> you don't need to use the lens package to actually define lenses for it, so i felt free to actually use a couple extensions
10:14:59 <c_wraith> But no IncoherentInstances?  You're not really trying. :)
10:15:09 <edwardk> and the lenses are compatible with lens-family-core which is haskell 98
10:15:15 <EmilyS> Cale: something more like this? https://github.com/Noia/haskellexperiments/blob/master/quad/quad.hs
10:15:27 <edwardk> it just is entirely self-contained
10:15:33 <Cale> EmilyS: replace 'return' with 'in'
10:15:56 <Cale> The usual indentation is something like:
10:16:02 <Cale> let foo = 1
10:16:06 <Cale>     bar = 2
10:16:09 <Cale> in foo + bar
10:16:26 <EmilyS> ok
10:16:33 <EmilyS> also, Maybe is not in scope?
10:16:34 <Cale> i.e. you line up the definitions inside the 'let' part, and you line up the 'let' and 'in'
10:16:42 <Cale> Maybe isn't a data constructor
10:16:45 <Cale> only a type constructor
10:16:48 <edwardk> and offers a lot of additional functionality that lens-family-* doesn't yet, for using values with a MultiGetter as if they are a 'Foldable' container, or using something with a multilens almost like a Traversable.
10:16:53 <Cale> Its data constructors are called Nothing and Just
10:16:58 <srhb> EmilyS: data Maybe a = Nothing | Just a
10:16:58 <Cale> :t Nothing
10:16:59 <lambdabot> forall a. Maybe a
10:17:01 <Cale> :t Just
10:17:03 <lambdabot> forall a. a -> Maybe a
10:17:12 <Cale> :t Just "hello"
10:17:13 <lambdabot> Maybe [Char]
10:17:25 <EmilyS> ah
10:18:00 <edwardk> the other thing that lens includes is a rank-n version of my representable-functor machinery, rather than requiring a huge pile of packages
10:18:54 <edwardk> baically it uses forall x. Lens (f x) x   as the representation for representable functors, which lets me make a lot of very easy vector spaces, etc. without a huge pile of dependencies
10:19:16 <c_wraith> so is it incompatible with the huge pile of packages, then?
10:19:20 <srhb> EmilyS: Which means you're going to have to use some logic (perhaps if-then-else) to decide whether to have a Just result or a Nothing in each spot. :)
10:23:12 <EmilyS> yup!
10:23:53 <edwardk> c_wraith: no, actually it just works. if you use it or lens-family-* then either version can use each others's lenses, the module is in a different location from the other lens libraries (Control.Lens rather than Data.Lens) so you can import both simultaneously etc.
10:24:20 <edwardk> i'll probably eventually kill representable-functors and just move the dependencies on it to use 'lens'
10:24:29 <c_wraith> ah, nice
10:24:34 <edwardk> it'll also vastly simplify representable-tries
10:24:42 <edwardk> since you'll use the lenses into the tries as the representation
10:25:23 <c_wraith> sounds like progress
10:25:40 <edwardk> but for now Control.Lens.Rep and Data.Functor.Representable don't conflict
10:26:17 <edwardk> my goal is to get lens cleaned up before hac phi so i can make a case to the snap guys to switch ;)
10:27:00 <edwardk> mostly it'll make it so the snap packages lose a lot of dependencies
10:27:03 <c_wraith> I'd be convinced - but that's not my part of snap. :)
10:27:25 <c_wraith> My contributions are mostly limited to the dynamic loader, and associated machinery.
10:28:07 <c_wraith> I should take another pass at that. I feel like I could improve its performance a bit.
10:30:35 <edwardk> the main thing snap would win is that things like the lens for snapletValue can become polymorphic, etc.
10:31:06 <edwardk> and it'd be nice to drop 2-3 dependencies from most packages
10:31:14 <edwardk> since those dependencies bring in a dozen more
10:31:29 <c_wraith> I'm not sure that the polymorphic lenses are a big deal.  But fewer dependencies, on the other hand..
10:31:33 <edwardk> yeah
10:31:43 <edwardk> the polymorphic lenses are more of a nice to have
10:32:24 <edwardk> you also get multilenses which are nice for manipulating maps, etc.
10:32:56 <edwardk> i went out of my way to write honest to goodness documentation, even ;)
10:34:13 <c_wraith> heh.  That's not something you always do.
10:34:27 * c_wraith recalls looking at Trifecta
10:34:33 <edwardk> trying to get better at it moving forward
10:34:38 <edwardk> the new trifecta is a lot smaller
10:34:44 <edwardk> i haven't pushed it out yet though
10:34:48 <edwardk> it needs a few more combinators
10:34:51 <edwardk> mostly for diagnostics
10:34:59 <edwardk> but it went from 72 modules to ~12
10:35:28 <edwardk> and a lot of stuff was consolidated in the move
10:35:42 <edwardk> (i moved the actual parsing combinators to 'parsers')
10:36:15 <c_wraith> 72 modules?
10:36:21 <c_wraith> I don't think I saw it in that period
10:36:31 <hape01> You discussed this a hour ago:let interact f = do s <- getContents; putStr (f s) in interact reverse
10:36:43 <hape01> why do i get   hGetContents: illegal operation (handle is closed)
10:38:03 <srhb> hape01: Have you closed stdin in some manner?
10:38:16 <hape01> srhb: i am not aware of - i am in GHCI console
10:38:29 <srhb> hape01: Ah, the first time you used getContents in ghci you closed stdin
10:38:39 <srhb> Er.. wait, is that correct
10:38:42 <ski> c_wraith,Cale : imo `MonadZero' should contain (only) `mzero', `MonadFail' could be separate class
10:39:02 <Cale> ski: agreed
10:39:08 <mcstar> srhb: yes
10:39:13 <srhb> hape01: Yes, indeed. You can't really expect to use stdin in that manner several times in a ghci session, after the first time it will be closed
10:39:19 <mcstar> he shouldnt do that in ghci
10:39:22 <Cale> ski: I'd also accept just dropping support for fail on the floor :P
10:39:23 <hape01> srhb: I confirm
10:39:30 <edwardk> http://hackage.haskell.org/package/trifecta has it with closer to 50 something
10:39:32 <Cale> ski: Though I guess that would be a bit cruel :)
10:39:34 <ski> (not sure if `MonadFail' could be a subclass of `MonadZero', or just directly of `Monad' -- i suspect the latter is better)
10:40:01 <hape01> there are so many pitfalls....
10:40:43 <ski> consider `instance MonadFail (Either e)' -- if this would require `instance MonadZero (Either e)', that would be awkward with something like `instance Pointed e => MonadZero (Either e)'
10:41:05 <srhb> hape01: ghci does have some, but this one is not a particularity of ghci or haskell, but stdin as such.
10:42:01 <hape01> srhb: thanks
10:42:56 <ski> Cale : anyway, ideally i'd like pattern matches in `do' (and arrow `do', and list^Wmonad comprehensions) which could fail to bring in a dependency on `MonadZero' (/ `ArrowZero') .. not sure where this'd leave `MonadFail' (/ `ArrowFail')
10:43:53 <srhb> hape01: You could possibly get away with using getLine instead if you want to play around in ghci. :)
10:44:15 <hape01> srhb: I'll have a look on it
10:45:24 <Cale> ski: yeah
10:45:34 <hape01> srhb: works fine in GHCI as an getContents replacement...
10:45:37 <hape01> types are the same.
10:45:40 <Cale> ski: Like it was in Haskell 1.4, basically :P
10:45:58 <ski> and by "pattern matches ... which could fail" i exclude irrefutable patterns `~ <pat>', variables `<var>', wildcard `_', as-patterns `<var> @ <pat>' where `<pat>' can't fail, view-patterns `<expr> -> <pat>' where `<pat>' can't fail and matches on `newtype' constructors and *tuple* patterns (but *not* matches on a `data' with only one constructor, for consistency with later adding a constructor)
10:46:13 <srhb> hape01: Right, getLine reads one line and then returns that IO String, getContents reads until stdin is closed and returns that String.
10:46:30 <Cale> ski: Haskell 1.4 had a concept of failable patterns which was basically exactly what you just described
10:46:35 <ski> (this not not quote the same as the general definition of "irrefutable pattern" in the report, since that doesn't include tuple patterns)
10:46:41 <Cale> ski: right
10:46:58 <ski> Cale : yeah, but i want matches on tuples to not invoke `MonadZero'
10:47:06 <Cale> ski: They never did
10:47:14 <ski> Cale : while those patterns can hang, they can't yield pattern-match failure
10:47:19 <Cale> ski: Pattern matches against types with a single constructor aren't failable
10:47:32 <Cale> (in Haskell 1.4)
10:48:24 <weexplat> Cale: it'd be nice to have the kind of diagnostic support fail gives you while still really just using mzero somehow, but i'm not sure how that would work
10:48:35 <Cale> oh, it was called "failure-free" actually
10:48:39 <Cale> http://www.mat.uc.pt/~pedro/cientificos/funcional/haskell-report-1.4-html/exps.html#do-expressions
10:48:56 <Cale> A failure-free pattern is one that can only be refuted by _|_. Failure-free patterns are defined as follows:
10:48:56 <Cale> All irrefutable patterns are failure-free (irrefutable patterns are described in Section 3.17.1).
10:48:56 <Cale> If C is the only constructor in its type, then C p1 ... pn is failure-free when each of the pi is failure free.
10:48:56 <Cale> If pattern p is failure-free, then the pattern v@p is failure-free.
10:49:16 <weexplat> but having code actually make decisions by inspecting the string that fail gets is just a Really Bad Idea and i'd rather code were just unable to do that
10:52:54 <ski>   "It is sometimes helpful to distinguish two kinds of patterns. Matching an irrefutable pattern is non-strict: the pattern matches even if the value to be matched is `⊥'. Matching a refutable pattern is strict: if the value to be matched is `⊥' the match diverges."
10:53:00 <weexplat> also, you could go either way with having pattern-matches on data with one constructor be failure-free, but i'd rather they were because i wouldn't want to make tuples more magical
10:53:05 <astory> Data.Map.fromSet is on hackage, but my ghc can't seem to find it.  What can I do to diagnose?
10:53:07 <ski>   "The irrefutable patterns are as follows: a variable, a wildcard, `N apat' where `N' is a constructor defined by newtype and `apat' is irrefutable (see Section 4.2.3), `var@apat' where `apat' is irrefutable, or of the form `~apat' (whether or not `apat' is irrefutable). All other patterns are refutable."
10:53:13 <ski>   "Haskell 2010 Language Report - 3 Expressions - 3.17.2 Informal Semantics of Pattern Matching" <http://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-580003.17>
10:53:14 <MagneticDuck> is there any function that can define a list given a list of values and positions?
10:53:27 <MagneticDuck> all I'm looking for now is a 1 dimensional list
10:53:53 <MagneticDuck> my real problem is I want to add 1 to one index, and subtract 1 from another
10:53:57 <ski> Cale : ok, nice, i wasn't aware of the definition of "failure-free" in the 1.4 report
10:54:29 <astory> MagneticDuck: doing that with lists is going to require rebuilding much of the list for each edit - is that what you want?  Maybe a different data structure is more appropriate
10:54:31 <MagneticDuck> @hoogle [(Int, a)] -> [a]
10:54:32 <lambdabot> Prelude snd :: (a, b) -> b
10:54:32 <lambdabot> Data.Tuple snd :: (a, b) -> b
10:54:32 <lambdabot> System.Random randomRs :: (Random a, RandomGen g) => (a, a) -> g -> [a]
10:54:34 <weexplat> MagneticDuck: you could make an array out of your input and then turn the array back into a list.  likewise a map
10:54:45 <noteventime> MagneticDuck: Do you mean add 1 to the value at some index or increase the index of some value?
10:54:45 <ski> weexplat : it would be acceptable to have store the string in a datatype that could can only extract the string from in `IO'
10:54:46 <MagneticDuck> hm, I just want something simple
10:55:12 <astory> A map from indexes to values sounds more reasonable
10:55:12 <MagneticDuck> the problem I have above that is, I just want to make a random list of Ints whose sum is some constant number
10:55:21 <MagneticDuck> that's what I was thinking of, astory
10:55:36 <astory> MagneticDuck: does it have to be a list, or can it be a bag?
10:55:45 <MagneticDuck> well...
10:55:47 <noteventime> MagneticDuck: Generating random partitions?
10:55:52 <MagneticDuck> for my problem, eventually it has to end up as a list
10:55:57 <astory> sure, but does order matter?
10:56:01 <ski> s/have store/store/,s/that could can/that could then/
10:56:10 <MagneticDuck> in the end result it does
10:56:23 <MagneticDuck> It has to end up as a list
10:56:33 <MagneticDuck> although just for the problem, no
10:56:48 <astory> great, then the map will work, using arbitrary indexes as the keys
10:56:49 <MagneticDuck> order doesn't matter coming out of this random function that returns a series of numbers whose sum is defined
10:56:53 <noteventime> Map.elems . Map.fromList $ zip [1..] yourlist
10:56:53 <noteventime> ?
10:57:07 <MagneticDuck> okay, I haven't had any experience with maps
10:57:22 <noteventime> Err, and obviously put the transformation you want to do in between :P
10:57:35 <ski> Cale : re the "If C is the only constructor in its type, then C p1 ... pn is failure-free when each of the pi is failure free." clause, i'm ambivalent -- if this is a type which conceptually could have more constructors (in the sense that it would be ok to later add one), then it would be annoying for the user of that type to suddently get `MonadZero' invoked on code which is already written
10:58:06 <noteventime> MagneticDuck: fromList creates a map from an assoc list (key-value pair list)
10:58:26 <astory> any idea about Data.Map.fromSet?
10:58:27 <MagneticDuck> okay
10:58:41 <MagneticDuck> then to transform a value at a certain index, what do I use?
10:58:47 <MagneticDuck> s/transform/set
10:58:53 <astory> MagneticDuck: look on hackage, Data.Map.Lazy
10:58:58 <noteventime> MagneticDuck: elems gives you the list of values in the map in (I think) increasing (by key) order
10:58:58 <MagneticDuck> Okay
10:59:24 <astory> adjust (+ 1) index map should increment the value with key index
10:59:40 <MagneticDuck> okay
10:59:58 <MagneticDuck> @type Data.Map.fromList
10:59:59 <lambdabot> forall k a. (Ord k) => [(k, a)] -> M.Map k a
11:00:20 <MagneticDuck> mm okay
11:00:22 <ski> Cale : i assume they include tuple patterns in "If C is the only constructor in its type, then `C p[1] ... p[n]' is failure-free when each of the `p[i]' is failure free." -- also they don't seem to mention record patterns
11:05:24 <Qtr> Hard question to answer but how many lines of code would it take to write a decent haskell compiler?
11:05:40 <srhb> Qtr: Depends on the language?
11:05:51 <MostAwesomeDude> Depends on the target, too.
11:05:54 <hpaste> keseldude pasted “Idea” at http://hpaste.org/72166
11:05:55 <srhb> That,t oo
11:06:02 <Qtr> How hard is writing a compiler? Is it normal to take a compiler class in uni cs? What would be a good first compiler to write? A c compiler in Haskell?
11:06:11 <srhb> Qtr: Yes, very normal
11:06:16 <Qtr> srhb: Haskell in Haskell
11:06:16 <Botje> Qtr: I wrote two of them.
11:06:21 <ski> (iow, maybe it would make sense to have a third way of making a new datatype : one which requires exactly one constructor, but which may have multiple arguments (tuples would belong to this kind) -- i suppose this is what *real* record types would be, if we had them)
11:06:24 <srhb> Qtr: I thought functional languages were a bit easier to write in compilers class
11:06:28 <weexplat> ski: record patterns desugar to plain constructor patterns
11:06:36 <srhb> Qtr: If you get to use a functional language, that is. :-)
11:06:49 <weexplat> ski: also, agda has that kind of record
11:07:02 <ski> weexplat : yes, i was just wondering whether they explicitly say that in the report (so that that desugaring is in "scope" in that definition))
11:07:05 <hape01> I like it :-)      flip (!) 2 $ fromList [(1,"Eins"), (2,"Zwei")]
11:07:07 <weexplat> ski: (that you were just talking about)
11:07:16 <Qtr> Botje: which lamguage in which language and how many LOC?
11:07:19 <ski> weexplat : yes, several languages have :)
11:07:39 <ski> weexplat : i was just trying to justify having yet another way of making a new data type in Haskell :)
11:08:01 <Botje> Qtr: one was ML to C, 2kLOC
11:08:18 <Botje> Qtr: the other was a scheme dialect to C, 3kLOC
11:08:32 <MostAwesomeDude> Qtr: Forth to assembly ahead-of-time, in Python: 500 LoC.
11:08:44 <MostAwesomeDude> That's probably your lower bound.
11:08:52 <weexplat> ski: well, things like C and Pascal don't really make good examples, Agda does
11:08:56 <Qtr> Hmm lets say you want a compiler for an embedded system, how would you do? What would you bootstrap?
11:09:18 <ski> weexplat : i wasn't thinking about those :) i was thinking about the MLs :)
11:09:25 <Qtr> ML to C? ML code translated to C code, not binary?
11:09:52 <ski> the MLs being SML (Standard ML), O'Caml (Objective Caml), F#, Alice ML
11:10:00 <Botje> Qtr: assembly was too much of a hassle.
11:10:19 * ski notes Qtr was actually talking about something else
11:10:25 <Botje> Qtr: since there's zero cleverness in that last stage
11:11:17 <ski> weexplat : also thinking about Charity and Cayenne (sortof predecessor of Agda1)
11:11:58 <MostAwesomeDude> Qtr: You would need a GC.
11:12:11 <Qtr> gc?
11:12:17 <Qtr> garbage collector?
11:12:26 <weexplat> Botje: register allocation?  instruction scheduling?
11:13:01 <weexplat> optimizing away unneeded frame pointers?
11:13:24 <mcstar> http://norvig.com/lispy.html lispy, 90 loc, written in python
11:13:39 <c_wraith> Qtr: you might be amused by atom, a haskell package
11:13:56 <c_wraith> Qtr: it gives you an embedded DSL for generating C optimized for embedded systems.
11:14:18 <mcstar> http://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours also, you can look at this
11:15:32 <Cale> Someone should write a C compiler which emits Haskell code, just to turn the tables. :)
11:16:13 <c_wraith> that'd result in really terrible haskell code
11:16:19 <sipa> that shouldn't be THAT hard i suppose
11:16:24 <c_wraith> everything is IORefs!
11:16:24 <ski> weexplat : but, having said that, records in Pascal and Ada are relatively ok, and variant records / records with a variant part in them are also relatively ok
11:16:26 <sipa> if it can all be IO
11:17:59 <ski> obligatory link : "loop in C , recursion in haskell" by Simon Marlow in 2004-03-24 at <http://www.haskell.org/pipermail/haskell-cafe/2004-March/005939.html>
11:18:55 <Qtr> But since I will get into embedded systems. If you have a new system and you need a c compiler for it, then youd have to write it in ASM right?
11:18:58 <Cale> That is one of the greatest posts to the Haskell-cafe mailing list of all time.
11:19:17 <weexplat> if i were writing a random compiler i'd probably write it in haskell with the llvm bindings
11:19:33 <Qtr> COuld you bootstrap a haskell compiler written in ASM and then program a C compiler in haskell?
11:19:53 <merijn> Qtr: I wrote a compiler for a simple C like language at university. Most useful course I ever took, because it made me realise writing compilers is actually pretty easy and a feasible solution for many problems
11:20:36 <ski> Qtr : .. just fyi, the original Mercury compiler was written in Mercury
11:20:46 <DMcGill> yeah, I really liked my compilers course
11:21:10 <merijn> Qtr: btw, you could just cross compile. i.e., change the existing x86 compiler to generate code for the new system
11:21:19 <merijn> No reason to bootstrap from asm on the target platform
11:21:53 <Qtr> ski: hmm?
11:22:13 <Qtr> it was written in simple-mercury perhaps?
11:22:16 <ski> Qtr : i just saw you were talking about bootstrapping ..
11:22:29 <Qtr> meijn: what kind of problems?
11:22:36 <ski> Qtr : it was written in the intersection of Mercury, NU-Prolog, and Quintus Prolog, iirc
11:22:51 <ski> (thus, it was written in Mercury)
11:23:12 <merijn> Qtr: If you find yourself writing a lot of boiler plate, just invent your own language with a special construct for that boiler plate and have the compiler generate it for you
11:23:26 <weexplat> also, if you have an interpreter you can use it to bootstrap a compiler
11:23:28 <Philonous> ski:  All they had to do then is to apply the the fix-point combinator in the calculus of compilers and they were done.
11:23:31 <merijn> If your target language is something fairly high level you can do neat things
11:23:40 <ski> Philonous : hehe :)
11:23:50 <merijn> i.e. compile something haskell-like to actual haskell and then turn that into an actual binary
11:24:19 <ski> weexplat : are you thinking about second Futamura projection ?
11:24:24 <merijn> Basically, ghetto Lisp macro's :p
11:24:40 <weexplat> ski: not necessarily, but that's one particular case
11:25:37 <ski> merijn : i'd like better support for that kind of thing in the Lisps
11:26:14 <merijn> ski: I'm a fake PLT person, I haven't actually learned lisp yet :p
11:26:21 <ski> Racket has some of it, but not (easily) all the features i want
11:26:23 <Philonous> merijn:  So, your point is, we need liskell?
11:26:37 <merijn> Philonous: Or Hasp? :p
11:26:46 <Qtr> merijn: in lisp->defmacro
11:26:55 <merijn> I would like to have more meta programming, yes
11:26:57 <Philonous> merijn:  Is hasp a thing?
11:26:57 <Eduard_Munteanu> Hathp :P
11:27:01 <Qtr> in haskell could you use template haskell to invent new syntax?
11:27:23 <Philonous> merijn:  You know that Liskell actually exists?
11:27:24 <Eduard_Munteanu> You're pronounthing ith the wrong way. :P
11:27:40 <Qtr> Maybe I should write a C-compiler in Haskell, how many LOC for a simple one if anyone have done one?
11:27:44 <merijn> Eduard_Munteanu: I made a similar joke about implementing lisp in python and calling it Lithp. (It's funny, because snakes have lisps)
11:28:14 <merijn> Qtr: Depends, an actual C compiler, almost impossible to write alone. Something C-like that compiles to ASM? Probably 2k LOC max
11:28:15 <ski> merijn : basically, we need to be able to have separate name-spaces for different languages (i suspect you can do this in Racket, but i'm not sure); *obviously* we need (per-default) hygienic macros (like in Scheme, but not Common Lisp nor Emacs Lisp); and i also think we need some kind of static "typing" for macros (to be able to have call-by-value (or something close) expansion of them, instead of call-by-name)
11:28:17 <Eduard_Munteanu> Heh, yeah, I remember the uncyclopedia page on Lithp.
11:28:55 <ski> merijn : if you want to learn a lisp, i recommend starting with Scheme first (so that you don't get too many bad habits)
11:29:12 <merijn> Qtr: The problem is that C has many annoying corners and ugly things you need to care about. If you just wanna compile something C-like to ASM yourself (for educational value), then it is easy to get something cool quickly
11:29:23 <merijn> ski: I was planning on Racket
11:29:54 <merijn> Because I wanna belong with the cool pretentious people on LtU ;)
11:29:55 <Philonous> ski:  I bet you _love_ loop!
11:30:05 <ski> merijn : also, if you're interested in Template Haskell ior Lispy macros, you ought to take a look at MetaML / MetaOCaml, to see a typed variant (which is in some ways better than TH and common lisp macro systems)
11:31:38 <noteventime> Has anyone done a typed lambda calculus with named arguments (i.e. beta-reduction becomes, essentially, a type safe version of pure substitution)?
11:33:03 <noteventime> actually, type and "capture safe"
11:33:40 <DanBurton> "named arguments"? as opposed to anonymous arguments? o_O
11:33:42 <c_wraith> yeah, Oleg has done a lot of work in this area
11:34:24 <Saizan> noteventime: that's a typical homework assignment
11:34:35 <ski> Philonous : i don't really like Common Lisps `loop', no :) i much prefer Riastradh's "foof-loop" at <http://mumble.net/~campbell/scheme/foof-loop.txt> tyvm :)
11:34:46 <ski> Philonous : you should also take a look at "Yow! LOOP macros are LOOPY!" by foof (aka Alex Shinn) in 2006-09-06 at <http://groups.google.com/group/comp.lang.scheme/msg/60dcac5ea812398> and "The Anatomy of a Loop: A story of scope and control" by Olin Shivers in 2005 at <http://www.ccs.neu.edu/home/shivers/papers/loop.pdf>,<http://lambda-the-ultimate.org/node/1014>
11:34:47 <Qtr> PLT?
11:34:55 <Qtr> PLT?
11:34:56 <Qtr> Maybe I should write a C-compiler in Haskell, how many LOC for a simple one if anyone have done one?
11:35:08 <ski> (note that Riastradh's version is called "foof-loop", while foof's version is called "loopy-loop")
11:35:24 <ski> merijn : yeah, Racket is fine
11:35:46 <noteventime> DanBurton: Rather than (\x. y) x' == y[x/x'], you'd have something like y (x := x') == y[x/x']
11:36:03 <noteventime> Saizan: Really? What is it called?
11:36:16 <srhb> Qtr: What will you be generating code for?
11:36:22 <Saizan> oh, you meant keyword arguments
11:36:55 <weexplat> there are various versions of lambda calculus with named arguments
11:36:59 <ski>   "In call-by-value functional languages such as ML or Scheme, we typically write loops using tail-recursive function calls. This is actually a terrible way to express program iteration, and it's not hard to see why. As was popularised by Steele, a tail call is essentially a \"goto that passes arguments.\" So writing loops with tail calls is just writing them with `goto's."
11:37:01 <weexplat> ait-kaci et al did one
11:37:04 <ski>   "Yet, it has long been accepted in the programming-language community that goto is a low-level and obfuscatory control operator, a position stated by Dijkstra's \"`Goto' considered harmful\" letter."  -- from the Shivers' paper
11:37:09 <noteventime> Possibly, I might have gotten my terminology wrong here (I haven't used them in a while)
11:37:20 <Saizan> i understood named arguments to mean "named variables" as opposed to e.g. de bruijn indexes
11:37:21 <ski> weexplat : heh, i recall that name for the WAM paper :)
11:37:23 <srhb> Qtr: All the way up until the AST will probably only be a few hundred lines of code for a fairly complete C
11:37:26 <DanBurton> Qtr: a C compiler? sounds painful, C has a lot of little features.
11:37:32 <srhb> Qtr: The code generation will probably be quite painful.
11:37:59 <ski> DanBurton : s/anonymous arguments/positional arguments/ ?
11:38:44 * hackagebot postgresql-simple 0.2.2.0 - Mid-Level PostgreSQL client library (LeonSmith)
11:38:50 <noteventime> weexplat: "The typed polymorphic label-selective λ-calculus"?
11:39:08 <noteventime> Looks like it, cute
11:40:49 <weexplat> noteventime: yeah, that was the one i meant
11:41:47 <DanBurton> ski: ahh I see. one might call the "named arguments" feature "keyword arguments"
11:42:12 <saml> what happened to that HTTP load testing program?
11:43:05 <ski> DanBurton : i suppose if we normally use curried-functions (instead of (argument-)tupled ones, or ones with "real multiple arguments"), the "positional argument" phrase is slightly less sensible, in theory at least
11:44:33 <ski> DanBurton : anyway, i think of tuple types as "positional(-indexed) product types" and record types as "name-index product types" -- and i've several times wanted "positional sum/variant types" in Haskell :)
11:45:50 <DanBurton> positional sum/variant types? how do you pull that off? if it is a variant type, then when you supply one of the variants, what is its position relative to?
11:46:19 <ski> e.g. something like `( x | )' could have type `( a | b )', and `( | y )' have type `( a | b )', with `x :: a' resp. `y :: b'
11:46:55 <DanBurton> interesting
11:47:23 <ski> maybe it'd be something like `( x | ~ )' and `( ~ | y )' instead, (using `~' as "empty"-marker here), so that we could get `( | ~ ) :: a -> ( a | b )' and `( ~ | ) :: b -> ( a | b )'
11:47:26 <noteventime> ski: Just the that that you'd have a nicer type notation for nested Either's would be worth it :)
11:47:48 <noteventime> the fact that*
11:47:59 <DanBurton> we could do something like that if we had prefix and postfix unary operators
11:48:02 <ski> noteventime : well, it would (of course !) also work for more variants than two (so we can skip the `Either (Either a b) c' nonsense)
11:48:20 <DanBurton> x |~  and  ~| y
11:48:25 <noteventime> Yes, that's what I meant
11:48:54 <DanBurton> mixfix operators? ;)
11:48:56 <ski> (note that i don't want to use `_' instead of `~' -- `_' represents "anything", while `~' in this use here would represent "nothing")
11:49:31 <ski> DanBurton : a variant (pun unintended) of this is *named* (light-weight) variant types
11:49:35 <DanBurton> I'm also reminded of the Perl "whatever" operator
11:49:46 <ski> DanBurton : which is basically the same, except that we apply names to the alternatives
11:50:45 <MagneticDuck> what exactly does GHC refer to by "syntatic negatation"?
11:51:04 <ski> DanBurton : this would be useful for cases where you want to return one of a few possible answers from a function, but you're (almost) always going to unwrap it immediately after the call, so that it seems heavy-weight to have to define a new type (or trying to fudge an old type) for it
11:51:10 <EvanR> negatation
11:51:23 <ski> MagneticDuck : itym `- <expr>' ?
11:51:28 <MagneticDuck> EvanR: Numeric negation?
11:51:37 <MagneticDuck> ski: hm?
11:51:37 <gert0> is there a chat history somewhere to check if i got a answer?
11:51:38 <ski> > let x = -9 in - x;
11:51:39 <lambdabot>   <no location info>: parse error on input `;'
11:51:41 <ski> > let x = -9 in - x
11:51:42 <lambdabot>   9
11:51:57 <MagneticDuck> ..you can do that?
11:52:04 <ski> gert0 : maybe you want <http://tunes.org/~nef/logs/haskell> ?
11:52:04 <MagneticDuck> woah
11:52:07 <MagneticDuck> > -True
11:52:08 <lambdabot>   No instance for (GHC.Num.Num GHC.Bool.Bool)
11:52:08 <lambdabot>    arising from a use of syntac...
11:52:12 <MagneticDuck> > - True
11:52:14 <lambdabot>   No instance for (GHC.Num.Num GHC.Bool.Bool)
11:52:14 <lambdabot>    arising from a use of syntac...
11:52:21 <MagneticDuck> weird!
11:52:25 <ski> MagneticDuck : `- <expr>' expands to `Prelude.negate <expr>'
11:52:40 <MagneticDuck> is that some compile-time magic?
11:52:47 <MostAwesomeDude> MagneticDuck: "Syntactic negation" means that there is a wart in the syntax to negate numeric literals.
11:52:52 <ski> it's a hack in the language, to allow prefix negation
11:52:57 <gert0> ski: thx
11:53:11 <MagneticDuck> @type Prelude.negate
11:53:13 <lambdabot> forall a. (Num a) => a -> a
11:53:16 <MagneticDuck> aw
11:53:17 <ski> @src Num
11:53:17 <lambdabot> class  (Eq a, Show a) => Num a  where
11:53:17 <lambdabot>     (+), (-), (*)           :: a -> a -> a
11:53:17 <lambdabot>     negate, abs, signum     :: a -> a
11:53:17 <lambdabot>     fromInteger             :: Integer -> a
11:53:25 <MagneticDuck> yeah
11:54:15 <ski> MagneticDuck : note that integral literals `<integer literal>' like `42' e.g., get's translated to `fromInteger <integer literal>' (where that in turn doesn't get expanded, of course :)
11:54:45 <flem> Does anyone use the wxwidgets bindings? I get errors when building wxc-0.90.0.3 and wxc-0.90.0.4
11:54:58 <MagneticDuck> I'm getting an error when I say "adjust (+ 1) 1"
11:55:06 <MagneticDuck> @type (+ 1)
11:55:08 <lambdabot> forall a. (Num a) => a -> a
11:55:10 <MagneticDuck> lol okay
11:55:13 <flem> I install the latest wxwidgets 2.9
11:55:15 <ski> MagneticDuck : likewise, `<decimal literal>' like `3.142857' gets translated to `fromRational <decimal literal>'
11:55:19 <Cale> What's the type of adjust here?
11:55:27 <MostAwesomeDude> @ty adjust
11:55:29 <lambdabot> Not in scope: `adjust'
11:55:57 <MagneticDuck> the map is a map constructed with (fromList $ zip [1..] xs)
11:56:01 <MagneticDuck> where xs :: [Int[
11:56:09 <MagneticDuck> *[Int]
11:56:28 <MagneticDuck> it's a compile-time error
11:56:29 <Philonous> MagneticDuck:  (+ 1) is the same as (\x -> x + 1)
11:56:31 <MagneticDuck> the key 1 exists
11:56:44 <MagneticDuck> well
11:57:00 <MagneticDuck> actually "adjust (- 1) 1"
11:57:05 <MagneticDuck> Philonous: I know that
11:57:12 <MagneticDuck> urm..
11:57:14 <MagneticDuck> ahah
11:57:18 <MagneticDuck> @type (- 1)
11:57:19 <lambdabot> forall a. (Num a) => a
11:57:20 <Cale> MagneticDuck: (-1) means negative one
11:57:24 <MagneticDuck> yeah
11:57:28 <Cale> not the function (subtract 1)
11:57:30 <Philonous> MagneticDuck:  Never mind then, you just seemed surprised about the type.
11:57:32 <MagneticDuck> okay, so ((-) 1)?
11:57:39 <Cale> That's (1 -)
11:57:48 <MagneticDuck> no
11:57:48 <Eduard_Munteanu> @let adjust = flip ($) in adjust (+1) 1   -- ? :)
11:57:49 <lambdabot>   Parse error: in
11:57:49 <Philonous> (`subtract` 1)
11:57:50 <Cale> you may want (+(-1))
11:57:53 <Eduard_Munteanu> > let adjust = flip ($) in adjust (+1) 1   -- ? :)
11:57:54 <ski> Cale : i don't recall whether e.g. `-1' expands to a call to `negate' or (just) to `fromInteger'
11:57:55 <lambdabot>   1
11:58:01 <MagneticDuck> yes, that too
11:58:05 <MagneticDuck> @type ((-) 1)
11:58:06 <lambdabot> forall t. (Num t) => t -> t
11:58:07 <MagneticDuck> works too
11:58:11 <MagneticDuck> alright
11:58:13 <Cale> It "works"
11:58:19 <Eduard_Munteanu> Erm.
11:58:20 <Cale> > ((-) 1) 5
11:58:21 <ski> > map ((-) 1) [0,1,2,3]
11:58:21 <lambdabot>   -4
11:58:22 <lambdabot>   can't find file: L.hs
11:58:25 <ski> > map ((-) 1) [0,1,2,3]
11:58:26 <lambdabot>   [1,0,-1,-2]
11:58:29 <Eduard_Munteanu> > let adjust = ($) in adjust (+1) 1
11:58:30 <lambdabot>   2
11:58:30 <MagneticDuck> L.hs??!!?
11:58:31 <ski> > map (subtract 1) [0,1,2,3]
11:58:32 <lambdabot>   [-1,0,1,2]
11:58:40 <ski> MagneticDuck : race condition in lambdabot
11:58:54 <Philonous> > map (`subtract` 1) [0..4]
11:58:55 <lambdabot>   [1,0,-1,-2,-3]
11:59:05 <MagneticDuck> okay then
11:59:16 <Philonous> err
11:59:23 <hpaste> “Gert Cuykens” pasted “how do i make type m Text into Text?” at http://hpaste.org/72167
11:59:56 <weexplat> i remember reading some old math books that had used ¯ instead of - for unary negation
12:00:14 <Cale> Who here, if anyone, is Gert Cuykens? :)
12:00:19 <weexplat> as in 'x - y = x + ¯y'
12:00:26 <gert0> me gert0
12:00:30 <ski> weexplat : SML uses (prefix) `~' for unary negation
12:00:37 <MagneticDuck> use your nick when you paste
12:00:54 <ski> gert0 : the general answer is : you don't
12:01:13 <Cale> gert0: It looks like url is an action of some type which you could run to produce a result of type Text
12:01:14 <ski> gert0 : to be more helpful, we need to know more about the context of this (such as e.g. the code which generates that error)
12:01:26 <flem> I wanted to experiment with reactive-banana, but the examples use wxwidgets, which seems broken at the moment. Is there a reactive gui framework that is generally recommended?
12:01:35 <ski> gert0 : please "annotate" that paste with more information :)
12:01:36 <Cale> gert0: but yes, we need to see more code to understand what to do to fix this.
12:01:48 <weexplat> wxwidgets is always broken ;)
12:01:52 <jkff> It just occured to me that I'd sacrifice a thunk or two to watch a showdown between Oleg and ekmett.
12:02:21 <edwardk> depends on the forum, we're each better at very different things ;)
12:02:28 <dmwit> You don't get an "a" out of an "m a". You put an "a -> b" into an "m a -> m b".
12:02:33 <weexplat> a showdown?  who can produce the fastest quicksort in the type system?
12:02:37 <gert0> ok going to take a while to prepare the example code i will come back to you if ready
12:02:57 <jkff> Well, maybe who can write a type the other one can't check, or something
12:03:08 <edwardk> oh, then oleg will win hands down
12:03:17 <Cale> gert0: Is the code you're working on protected by some legal agreements or something? You could just paste the whole thing. :)
12:03:30 <weexplat> how about who can write a value the other one can't typecheck?
12:03:32 <edwardk> he can write types that rely on scarily specific issues inside the type checker ;)
12:03:34 <weexplat> that would be more fair
12:03:44 <applicative>  gert0 it looks like it would be url >>= \url_text -> WS.sendTextData ("Facebook login" `mappend` url_text :: Text)
12:03:54 <applicative> gert0: maybe...
12:03:58 <edwardk> he was somewhat amused by the new version of reflection though =)
12:04:03 <ski> weexplat : fyi, SML actually overloads `+',`-',`*',`~' on both `int' and `real'; while O'Caml uses `+.',`-.',`*.',`/.' for `float'
12:04:03 <weexplat> slightly more fair anyway
12:04:31 <weexplat> edwardk: you're both some of the few people i know who can think in continuation-passing style
12:04:31 <jkff> But can Oleg withstand a zygohistoprepromorphism?
12:04:38 <edwardk> i figure i win on the 'actually getting code distributed' end of the spectrum, he wins on actually getting published =)
12:04:47 <ski> (which is sortof strange since otherwise SML seems to make less concessions to "practicality" than O'Caml (you can't define any overloading yourself in SML nor in O'Caml))
12:05:21 <edwardk> i got good at it mostly because it made me mad that the only person who seemed to have a glib understanding of it in the community was oleg =P
12:06:05 <ski> edwardk : why amused ?
12:06:31 <Qtr> srhb: arch linux maybe? or windows
12:06:43 <edwardk> mostly tuned out writing slides, didn't quite follow that
12:06:58 <Qtr> srhb: arch linux maybe? or windows (haskell c compiler that is9
12:07:51 <jkff> The thing that sparkled my curiosity about the showdown was this http://comonad.com/reader/2011/what-constraints-entail-part-1/
12:09:48 <Qtr> Any good link to writing a compiler in Haskell?`
12:10:18 <schovi> hello guys. Can someone explain me, how to exactly use `read` on this simple example? https://gist.github.com/3183859 or if is there another way, how to convert string to number
12:10:19 <EvanR> Qtr: write yourself a scheme is 24 hours
12:10:20 <schovi> thanks
12:10:54 <schovi> ignore how it is writen (using where). It is just clear example :)
12:11:34 <flem> Is there a reason that several reactive libraries have food names?
12:11:38 <ozataman> is there a nice tuple library for working with 3 and 4 element tuples? I'm just tired of creating throwaway records for named fields
12:11:57 <EvanR> you have a lot of 4 tuples?
12:12:34 <EvanR> most libs have support for like 6 or 7 tuples
12:12:38 <flem> Having failed to get reactive-banana running, what reactive framework should I try next?
12:13:22 <mikeg> schovi: You need to specify what you want b to be in foo :: [String] -> [b]. foo arr :: [Int] or foo arr ::[Float] or whatever type
12:14:37 <Qtr> evanr: want to write C compiler but maybe i should start with scheme¨
12:15:53 <flem> Qtr: you're aware of this, right? http://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours
12:17:32 <schovi> mikeg: i see. It is simple in there. But i am writing program, where i have read in middle of function and it is confusing for me, how to use type there. Try something, or post another gist with real program. Thanks for now :)
12:17:52 <hpaste> gert0 annotated “how do i make type m Text into Text?” with “how do i make type m Text into Text? (annotation)” at http://hpaste.org/72167#a72168
12:19:36 <gert0> Cale: anotation done
12:20:50 <mm_freak> > (0 :+ 1) ^ 0
12:20:51 <lambdabot>   1.0 :+ 0.0
12:20:52 <mm_freak> > (0 :+ 1) ^ 4
12:20:54 <lambdabot>   1.0 :+ (-0.0)
12:21:06 <Qtr> Any good link to writing a compiler in Haskell?
12:21:06 <mm_freak> > (0 :+ 1) ^ 0 == (0 :+ 1) ^ 4
12:21:07 <lambdabot>   True
12:21:16 <mm_freak> Qtr: for what type of language?
12:21:18 <schovi> mikeg: still fighting with it https://gist.github.com/3183859
12:21:37 <schovi> mikeg: how to add type declaration in this function for that read? Thank
12:21:52 <merijn> gert0: How can mappend return something of type Text?
12:21:55 <merijn> :t mappend
12:21:56 <lambdabot> forall a. (Monoid a) => a -> a -> a
12:21:56 <gert0> can you anotate the answer pleas mother is calling me :) bye
12:21:59 <merijn> Waut
12:22:02 <Cale> gert0: Okay, so you've defined  fbUrl  as an action, but you still need to run that action to get a value of type Text.
12:22:03 <merijn> Invm
12:22:15 <Cale> gert0: I'm pretty sure that your comment on fbUrl's type isn't quite right
12:22:19 <mikeg> I would avoid shadowing variable names like that. It looks like tableId is recursive in itself
12:22:43 <Cale> gert0: What does ghci say the type of fbUrl is when you load Login.hs and :t fbUrl ?
12:23:24 <ski> schovi : add `tableId :: Integer' (if that's what you want), on a line above `tableId = ...'
12:23:51 <flem> Qtr: did you see the link I gave?
12:23:55 <Cale> It probably at least has a  MonadIO m  constraint
12:24:17 <Cale> (because that's required by withManager)
12:24:25 <ski> schovi : oh, you also need to name your `Integer'(?) `tableId' somethine else than your `String' `tableId' !
12:24:35 <Cale> ...
12:24:39 <ski> schovi : i'll assume you rename the string to `tableIdStr'
12:24:52 <ski> schovi : an alternative is saying `tableId = read tableIdStr :: Integer'
12:25:17 <b0fh_ua> Hi all! Can somebody please explain me, how do I convert darcs dpatch file into regular patch?
12:25:18 <ski> schovi : but really, it would probably be better to catch parse errors, by using e.g `reads' instead
12:26:39 <schovi> ski: lot of hints. Gonna try them
12:27:00 <Cale> b0fh_ua: Probably by applying it using darcs and then using diff
12:27:00 <EvanR> if i execute putStr (a ++ b ++ c ++ d) will ghc put a then b then c then d, or compute a new string first
12:27:02 <ski> schovi : something like `case (reads :: ReadS Integer) of [(1,"")] -> "yes"; [(_,"")] -> "oh no"; _ -> "parse error"'
12:27:22 <ski> schovi : er, should be `case (reads :: ReadS Integer) tableIdStr of [(1,"")] -> "yes"; [(_,"")] -> "oh no"; _ -> "parse error"'
12:27:26 <b0fh_ua> Cale: I don't have darcs (and can not install it now - my portages are broken)
12:27:57 <b0fh_ua> perhaps somebody could apply the dpatch to xmonad and send me patch version?
12:28:26 <Cale> b0fh_ua: you could also just look at it and apply it by hand, if it's not too big
12:29:01 <Cale> (iirc, it's just a text file describing the changes)
12:29:54 <b0fh_ua> Cale: 14Kb
12:30:22 <veldskoen> hello, does anyone know why this doesn't work:
12:30:25 <veldskoen> ceasar :: Char -> Char
12:30:27 <veldskoen> ceasar x = chr ((ord x) + 2)
12:30:27 <veldskoen> -- split' :: String -> [Char]
12:30:27 <veldskoen> cipher' (x:[]) = (ceasar x):[]
12:30:27 <veldskoen> cipher' (x:xs) = (ceasar x):(cipher' xs)
12:31:22 <ski> schovi : if you want to, you could define `readMP :: (MonadPlus m,Read a) => String -> m a; readMP s = foldr (mplus . return) mzero [a | (a,"") <- reads s]'
12:31:36 <schovi> ski: simple tableId :: Integer   ;tableId = read tableIdStr works fine for me now. The second example too, but it is little complicated for me now :D
12:31:38 <Cale> veldskoen: It does work
12:31:46 <Cale> veldskoen: Did you import Data.Char?
12:31:46 <b0fh_ua> veldskoen: map (\x -> chr ((ord x) + 2)
12:32:07 <ski> schovi : then you could just say `case readMP tableIdStr :: Maybe Integer of Just 1 -> "yes"; Just _ -> "oh no"; Nothing -> "parse error"'
12:32:20 <Cale> veldskoen: it does have a bug -- cipher' doesn't work when applied to an empty list
12:32:37 <Cale> veldskoen: (and it doesn't need a special case for a one-element list)
12:32:48 <ski> schovi : the gain with using `reads' (or `readMP' above), is that you can (easily) catch parse errors -- if you're sure there won't be any parse errors, it doesn't matter
12:33:50 <schovi> ski: should be. It is official updates from goverment to location database :)
12:33:53 <veldskoen> Cale: ah okay thanks!
12:34:26 <ski>   readLexMP :: (MonadPlus m,Read a) => String -> m a
12:34:36 <veldskoen> b0fh_ua: ha ha yeah thats what the book says :) Tried it before I saw the better solution
12:34:40 <veldskoen> but thanks
12:34:42 <ski>   readLexMP s0 = foldr (mplus . return) mzero [a | (a,s1) <- reads s0 , ("","") <- lex s1]
12:35:03 <ski>   -- is a variant that will allow white-space after the thing being parsed
12:35:04 <flem> reactive and reactive-banana both fail to install -- is there a reactive framework that is commonly used? Do these difficulties suggest that FRP is not very popular?
12:35:13 <schovi> ski: great thanks for exhausting explanation. Saving last example with monad for latest learning!
12:36:06 <ski> schovi : and if you find yourself wanting to read multiple things after each other (where you want "all or nothing"), it's probably better to chain them, using a single call to `reads' (or `readMP'/`readLexMP') -- or use a parser monad
12:36:14 <Cale> veldskoen: Yeah, an advantage to using map is that it becomes impossible to have that off-by-one error :)
12:36:46 <merijn> flem: reactive is a bit out of date, I heard. But I thought reactive-banana was supposed to be recent
12:37:09 <merijn> flem: Which compiler version/haskell platform version/whatever are you using?
12:37:23 <ski> @let readMP :: (MonadPlus m,Read a) => String -> m a; readMP s = foldr (mplus . return) mzero [a | (a,"") <- reads s]
12:37:25 <lambdabot>  Defined.
12:37:28 <ski> @let readLexMP :: (MonadPlus m,Read a) => String -> m a; readLexMP s0 = foldr (mplus . return) mzero [a | (a,s1) <- reads s0 , ("","") <- lex s1]
12:37:29 <lambdabot>  Defined.
12:37:31 <flem> merijn: ghc 7.4.1 on linux
12:37:42 <ski> > readMP "0123" :: Maybe Integer
12:37:45 <lambdabot>   Just 123
12:37:46 <ski> > readMP "0123 " :: Maybe Integer
12:37:48 <lambdabot>   Nothing
12:37:49 <merijn> flem: I would say that the idea of FRP is pretty popular, but it is still unclear how to most efficiently implement it
12:37:53 <ski> > readLexMP "0123" :: Maybe Integer
12:37:55 <lambdabot>   Just 123
12:37:56 <ski> > readLexMP "0123 " :: Maybe Integer
12:37:57 <lambdabot>   Just 123
12:38:13 <killy9999> what is a partial list?
12:38:19 <flem> reactive-banana fails due to wxwidgets compile error. the gtk version doesn't appear to be in cabal, maybe I can hunt down a gtk version
12:38:19 <ski> schovi : that ^ shows the difference between `readMP' and `readLexMP'
12:38:30 <killy9999> I found the information that it's a list that has bottom as a basic case, instead of []
12:38:50 <ski> killy9999 : a list which is not infinite, but still "ends in" a bottom
12:39:00 <schovi> ski: i see
12:40:41 <ski> schovi : for hand-writing `Read' (or `Show') instances (or even defining useful operations using `ShowS' ior `ReadS'), looking at basic instances of those classes in the Hugs prelude is nice (there's also info in the report, of course)
12:41:37 <ski> schovi : i'm thinking about stuff like : "what's the `Int' argument to `readsPrec' and `showsPrec' good for ?", "what's the deal with `readParen' and `showParen'", or even very basic stuff about how to write code using `ShowS' and `ReadS'
12:41:46 <killy9999> ski: hm... what do you mean by "still"?
12:41:57 <ski>   type ShowS = String -> String
12:41:57 <ski>   type ReadS a = String -> [(a,String)]
12:42:24 <ski> killy9999 : hm, i suppose that was somewhat confusing/overkill, yeah
12:42:34 <killy9999> ski: ah, ok
12:42:53 <ski> killy9999 : first i was thinking about saying : any list that's not built from just `[]' and `:' on its "spine"
12:43:21 <killy9999> but how is it possible to define a list that ends with a bottom in haskell?
12:43:26 <ski> killy9999 : but that excludes the infinite lists, so i endeavored to make sure that infinite lists are not considered partial
12:43:36 <ski> > 1 : error "bottom !"
12:43:37 <lambdabot>   [1*Exception: bottom !
12:43:47 <ski> > 1 : let x = 1 + x in x
12:43:48 <lambdabot>   No instance for (GHC.Num.Num [t])
12:43:48 <lambdabot>    arising from a use of `e_111' at <inte...
12:43:55 <weexplat> flem: netwire maybe?  (not exactly an expert, but nobody else said much)
12:43:58 <ski> > 1 : let x = 1 + x in [x]  -- er, rather this
12:44:02 <Eduard_Munteanu> > fix (1:)
12:44:02 <lambdabot>   mueval-core: Time limit exceeded
12:44:02 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
12:44:22 <ski> hm, no, that's a list with two elements, one of them partial
12:44:39 <ski> > 1 : let xs = reverse xs in xs
12:44:42 <ski> is a better example
12:44:43 <lambdabot>   mueval-core: Time limit exceeded
12:45:11 <MagneticDuck> yo, a little question...
12:45:15 <MagneticDuck> say I have a simple IO program
12:45:19 <Eduard_Munteanu> Ah, literally ends with a bottom.
12:45:19 * killy9999 thinks why does this cause an infinite loop
12:45:26 <MagneticDuck> that takes a stream of text and outputs a stream of text
12:45:36 <weexplat> > 1 : undefined -- a list that ends in bottom
12:45:37 <lambdabot>   [1*Exception: Prelude.undefined
12:45:38 <MagneticDuck> how can I call that program from inside haskell?
12:45:46 <ski> killy9999 : so, any time each cell in the "spine" of the list doesn't (eventually) evaluates either to `[]' (terminating the list), or `<some element> : <rest of the list>' (continuing the list)
12:45:46 <MagneticDuck> I've had no experience with this stuff yet
12:46:15 <weexplat> > [1, undefined] -- a list that has a bottom, but not on the spine
12:46:16 <lambdabot>   [1,*Exception: Prelude.undefined
12:46:19 <killy9999> ski: o, that's a very good explanation
12:46:26 <weexplat> you can tell the difference by how they print
12:46:27 <MagneticDuck> how would I pass a string as input to a program and retreive its output as a string, from within haskell?
12:46:30 <killy9999> cause the error or undefined examples were rather made-up
12:46:41 <weexplat> if it ends in bottom, there is no final ,
12:47:07 <ski> killy9999 : well, there are multiple solutions to the equation `xs = reverse xs' -- `xs = []' is one, `xs = [undefined]' is another one, `xs = [undefined,False,undefined]' is a third (assuming we're talking about a list of `Bool's)
12:47:30 <ski> killy9999 : but there's no *least* solution (wrt the definedness ordering, not wrt list length)
12:47:40 <weexplat> any palindromic list solves x = reverse xs
12:48:00 <killy9999> why does this needs to be solved?
12:48:01 <killy9999> I mean
12:48:03 <MagneticDuck> my question is a simple one... I just have never done this stuff before
12:48:04 <flem> maybe this has been discussed to death, but have people considered moving cabal to a snapshot system like debian/ubuntu? That way there is always a baseline that works.
12:48:06 <weexplat> there is no structure whatsoever that all palindromic lists have in common
12:48:16 <flem> quicklisp does the same thing
12:48:25 <flem> meaning you always have something that works
12:48:30 <weexplat> even [] and [undefined] don't have anything in common (one is nil, one is a cons)
12:48:31 <killy9999> does this mean that if I write "let xs" then "xs" is in scope of the rhs of the binding?
12:48:36 <geekosaur> MagneticDuck, http://www.haskell.org/ghc/docs/7.4.1/html/libraries/process-1.1.0.1/System-Process.html --- beware that you really want to run whatever writes to/reads from the subprocess in a separate thread, because if it blocks on input/output while you're blocked in waitForProcess the only way out is killing it
12:48:44 <Cale> ski: of course there is a least solution! There's always a least defined solution :)
12:48:53 <weexplat> killy9999: yes it does
12:48:58 <Cale> just happens to be _|_ in this case :)
12:49:03 <ski> Cale : yeah, i really meant, *apart* from the undefined one :)
12:49:07 <ski> killy9999 ^
12:49:07 <Cale> yeah
12:49:29 <ski> (i.e. attempting to answer "* killy9999 thinks why does this cause an infinite loop")
12:49:29 <killy9999> wow, I'm a bit surprised
12:49:36 <Cale> reverse _|_ = _|_
12:49:42 <Cale> and _|_ is the least defined thing of all
12:49:49 <killy9999> perhaps because let bindings work differently in Scheme
12:49:51 <Cale> So that's what fix reverse is going to give you
12:50:01 <flem> I bring it up because I am somewhat amazed at the number of broken packages in cabal
12:50:08 <flem> (no offense)
12:50:20 <weexplat> it so happens that the semantics of haskell is such that those let bindings give variables values that solve the equations in the 'let'
12:50:25 <flem> a snapshot system can solve that
12:50:33 <ski> killy9999 : the point of the example was that there's many solutions to the equation `xs = reverse xs', and all of them have different length -- therefore the least solution can't commit to *any* specific length, therefore it's just `_|_'
12:50:35 <flem> stable and unstable branches
12:50:36 <Cale> > let evens = 0 : map (+1) odds; odds = map (+1) evens in (take 5 evens, take 5 odds)
12:50:38 <lambdabot>   ([0,2,4,6,8],[1,3,5,7,9])
12:50:41 <Cale> ^^ killy9999
12:50:53 <Cale> you can even write mutually recursive let bindings
12:51:09 <Cale> (which are all lazy, at that!)
12:51:26 <ski> @wiki Tying the Knot
12:51:26 <lambdabot> http://www.haskell.org/haskellwiki/Tying_the_Knot
12:51:27 <weexplat> but haskell won't (can't) invent information to choose a fully defined solution to the equation
12:51:55 <ski> killy9999 : i'm not sure what you mean by "why does this needs to be solved?"
12:51:59 <weexplat> the solution it chooses is always the 'least informative' one with all the parts that not all solutions have in common 'blurred out'
12:52:05 <dysoco> hey, I'm learning haskell and... I don't understand this, pretty basic so excuse me:
12:52:10 <killy9999> ski: ok, I see now. the let binding thing was a side note to my original question
12:52:11 <dysoco> let x = 4 in x * x
12:52:17 <Cale> ski: I think because killy9999 didn't expect xs = reverse xs to be an equation
12:52:21 <dysoco> what's the difference between "let x = 4*4" ?
12:52:23 <ski> killy9999 : "does this mean that if I write \"let xs\" then \"xs\" is in scope of the rhs of the binding?" -- yes, `let'- (and `where'-) bindings are recursive in Haskell
12:52:24 <weexplat> if you look at a 'blurred out' part of the solution, your program will loop
12:52:36 <Cale> ski: or, didn't expect both of the xs's to be the same thing :)
12:52:54 <weexplat> so:
12:53:14 <Cale> dysoco:  let x = 4 * 4 in x  and  let x = 4 in x * x  compute the same result
12:53:23 <Cale> dysoco: namely, they're both ways to write 16
12:53:25 <dysoco> but why do I ned the "in x"
12:53:29 <dysoco> need*
12:53:32 <killy9999> Cale: I expected neither ;)
12:53:38 <Cale> The syntax is   let <declarations> in <expression>
12:53:44 <dysoco> ah OK
12:53:46 <dysoco> so it's syntax,
12:53:49 <weexplat> > let xs = 1:reverse (tail xs) in head xs
12:53:49 <dysoco> OK then, thanks
12:53:50 <lambdabot>   1
12:53:52 <Cale> It's a way to make various declarations in a local scope
12:54:14 <ski> weexplat : isn't it closer to the "\"most informative\" one, under the constraint of not being any more informative/defined than any \"actual concrete solution\"" ?
12:54:16 <Cale> the declarations may be (mutually) recursive, and they aren't evaluated immediately
12:54:23 <Cale> (only if the expression really needs them)
12:54:57 <ski> weexplat : i mean `xs = 1 : xs' gives you an infinite list, and surely `xs' being computed to be `_|_' is less informative than that :)
12:55:08 <scooty-puff> how horrible would it be to provide some extra modules or instances only if another module was also required?  i am thinking about hashable and hashset/hashmap - i have no requirement of either hashable or unordered-containers, but could provide useful hashable instances, and useful key/elem instances (defined in this package)
12:55:11 <killy9999> Hasell is mind bending...
12:55:17 <weexplat> ski: hm, you have a point :)
12:55:58 <MagneticDuck> urm, just a question, I probably understand the concept... what does _|_ mean?
12:56:00 <weexplat> actually, now that i think of it, haskell chooses the most defined/informative solution that doesn't conflict with any other solution
12:56:27 <ski> weexplat : i'm not sure whether it's *actually* the most defined one which is still at most as defined as all the actual concrete solutions -- there might be some strangeness with strictness (`seq') and such
12:56:29 <jamiltron> MagneticDuck: It's bottom - http://www.haskell.org/haskellwiki/Bottom
12:56:37 <weexplat> (including with other solutions that are not fully defined)
12:56:48 <merijn> MagneticDuck: _|_ means bottom (it looks like the mathematical symbol for bottom), which means contradiction, false, etc.
12:56:49 <killy9999> MagneticDuck: _|_ iis read bottom
12:56:49 <weexplat> ski: i'm ignoring seq, this is hard enough
12:57:02 <killy9999> I'd say it means something that cannot be calculated
12:57:10 <MagneticDuck> yes okay
12:57:14 <ski> weexplat : but normally it'd be near (i.e. "below") and commonly exactly that, i think
12:57:15 <merijn> MagneticDuck: In context of haskell _|_ means a non-terminating computation (e.g., infinite loop or crash)
12:57:19 <MagneticDuck> ty
12:57:37 <MagneticDuck> wasn't familiar with the symbol :P
12:57:46 <merijn> For example, the stereotypical _|_ in haskell is
12:57:48 <merijn> > undefined
12:57:49 <lambdabot>   *Exception: Prelude.undefined
12:58:01 <ski> MagneticDuck : note that "crash" here means "detected problem" (such as pattern-match failure), it doesn't mean the undefined-behavioury crash that you get in e.g. C :)
12:58:41 <MagneticDuck> yeah
12:58:46 <MagneticDuck> > let x = x in x
12:58:50 <lambdabot>   mueval-core: Time limit exceeded
12:58:51 <weexplat> sometimes a crash in haskell is nondeterministic, but there are always things it can't do
12:58:58 <weexplat> no nasal demons
12:59:16 <ski> `_|_' is an ascii-rendering of `⊥'
12:59:52 <ski> weexplat : unless you (ab)use the FFI, or `unsafeX' stuff :)
12:59:59 <ski> (not including `unsafeInterleaveIO')
13:00:19 <killy9999> OK,now something completely different
13:00:46 <killy9999> what was your the most influencal book about functional programming?
13:01:33 <ski> the book i read which made me get into FP was "Haskell: The Craft of Functional Programming"
13:01:46 <ski> but if you're talking generally, which is the most influencial book on FP, i don't know
13:02:17 <killy9999> no, I don't mean generally
13:02:30 <killy9999> I'm asking about your personal opinions ;)
13:02:39 <ski> e.g. "Purely Functional Data Structures" by Chris Okasaki is an important book -- but i'd probably not claim it to be the most influencial FP book
13:03:08 <ski> @where TaPL
13:03:09 <lambdabot> http://www.cis.upenn.edu/~bcpierce/tapl/
13:03:28 <jamiltron> TaPL is probably my favorite
13:03:37 <killy9999> I'm thinkinghat some languag aboy reading Bird's "Pearls of Functional Programming"
13:04:00 <ski> is "Types and Programming Languages" by Benjamin C. Pierce, but it's more about type systems (good book for that !), than FP
13:04:46 <ski> killy9999 : SICP might perhaps be one of the most influencial book on (mostly) FP programming
13:04:56 <ski> @where SICP
13:04:56 <lambdabot> The Wizard book : "Structure and Interpretation of Computer Programs" at <http://mitpress.mit.edu/sicp/> by Hal Abelson,Gerald Jay Sussman with Julie Sussman, videos at <http://swiss.csail.mit.edu/
13:04:56 <lambdabot> classes/6.001/abelson-sussman-lectures/>
13:04:56 <jamiltron> TaPL's exercises got me thinking more about the "cost" of mutability than probably any other book.
13:05:24 <EvanR> SICP is great, general computer programming book
13:05:30 <EvanR> emphasis in the right place
13:05:31 <ski> jamiltron : "cost" as in reasoning/refactorability/maintainability cost, or as in efficiency cost ?
13:05:44 <killy9999> yeah, I wisk I had time to read SICP one day
13:05:51 <ski> if you liked SICP, you might also like CTM
13:05:53 <ski> @where CTM
13:05:54 <lambdabot> "Concepts, Techniques, and Models of Computer Programming", by Peter Van Roy,Seif Haridi, at <http://www.info.ucl.ac.be/~pvr/book.html>
13:05:59 <merijn> Time is something you make :p
13:06:05 <ski> which is more generally about different programming paradigms
13:06:06 <jamiltron> ski: The first. How introducing mutability into a language causes a great deal of complications in regards to reasoning.
13:06:24 <EvanR> jamiltron: and implementation
13:06:49 <merijn> ski: How advanced is that book? I read a paper by Van Roy on differt programming paradigms, it was interesting but not very practical in actual knowledge obtained
13:07:14 <EvanR> i rarely mutate stuff in php, javascript, ruby except at the top level
13:07:25 <EvanR> makes things a lot easier to write
13:08:26 <ski> HtDP, "How to Design Programs: An Introduction to Programming and Computing" by Matthias Felleisen,Robert Bruce Findler,Matthew Flatt,Shriram Krishnamurthi at <http://www.htdp.org/> is considered by some as a "better version" of SICP
13:09:15 <merijn> What makes it better?
13:09:16 <ski> (they claim that it is better attuned to teaching programming concepts not only to smartkids, but also the more general public who wants to learn programming)
13:09:47 <ski> .. while others swear by SICP
13:09:51 <jamiltron> merijn: The learning curve is WAY simplier in HtDP, in my opinion - although I may not say that it is "better"
13:09:53 <killy9999> NOt a book and not about FP, but I found a paper "The role of study of programming languages in the education of a programmer" by Friedman an interesting read
13:10:41 <merijn> jamiltron: Ah, I'll just stick with SICP then
13:10:56 <mapreduce> SICP is great, I'd like to find something that covered typed programming as simply and 'magically' as SICP.
13:11:22 <jamiltron> merijn: I think HtDP has merit for some people, but I think SICP is the superior book.
13:11:29 <xvilka> btw, i've seen somewhere on github redesigned version of sicp - on tex and svg images
13:11:40 <killy9999> how many edition of SICP were published?
13:11:55 <merijn> xvilka: Yeah, it's very slick
13:12:05 <merijn> killy9999: Just two I believe
13:12:11 <xvilka> see http://github.com/sarabander/sicp-pdf
13:12:52 <killy9999> my library has exactly one copy of SICP. It's borrowed and should have been returned in 2005...
13:13:21 <jamiltron> I purchased the soft-bound copy because I loved it so much.
13:13:37 <singpolyma> Is there a common library for doing simple (no regex) string replacement in String or Text ?
13:15:01 <mapreduce> :t map
13:15:02 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
13:15:39 <mapreduce> > map (\c -> if c == 'l' then 'r' else c) "hello"
13:15:40 <lambdabot>   "herro"
13:15:45 <mapreduce> singpolyma: Howzat?
13:15:52 <singpolyma> mapreduce: sure, I mean multi-character replace
13:15:55 <tew88> I remember reading somewhere (reddit?) about a tool to tidy your Haskell source-code -- can anyone jog my memory?
13:16:08 <singpolyma> ie:   replace "that" with "this"
13:16:31 <jamiltron> singpolyma: There's a lot of functions in Data.List that help when working with sublists
13:16:37 <mm_freak> tew88: that tool is sitting about half a meter from the monitor
13:16:44 <ski> killy9999 : then there's stuff like EOPL,TLS,&c. -- see <http://paste.lisp.org/display/124945> for mbishop's "List of popular programming book acronyms"
13:16:56 <jamiltron> mm_freak: You can tidy code with a coffee mug?
13:17:06 <killy9999> tew88: https://github.com/jaspervdj/stylish-haskell
13:17:16 <tew88> mm_freak: Zzzzz
13:17:20 <tew88> killy9999: Thanks :)
13:17:55 <killy9999> ski: thanks
13:18:06 <mm_freak> well, since there is no coding standard in haskell, i doubt that any beautifier can really produce good code
13:18:06 <killy9999> TLS is great
13:18:13 <singpolyma> jamiltron: yeah, but I don't see one for this.  There's a list replace function in MissingH, but I really don't like depending on that
13:18:15 <mm_freak> beautiful code depends a lot on context in haskell
13:18:19 <killy9999> I'm yet to read the sequel
13:18:58 <ski> killy9999 : there's also some other book (other than the great "Purely Functional Data Structures") about algorithms in FP, which someone mentioned the other day -- can't recall the title of it, though
13:19:00 * hackagebot Vec 1.0.1 - Fixed-length lists and low-dimensional linear algebra. (ScottDillard)
13:19:27 <killy9999> hm...
13:19:36 <jamiltron> singpolyma: What are you trying to do exactly? Just replace a sequence of characters in a string?
13:19:42 <killy9999> I mentioned "Pearls of Functional Algorithm Design"
13:19:47 <ski> killy9999 : iiuc, EoPL is about writing interpreters (and possibly simple compilers as well ?) -- i've only browsed them a little
13:20:15 <killy9999> and I guess that's the only thing tha comes to my mind
13:20:21 <singpolyma> jamiltron: yes, with a nother not-the-same-length sequence
13:20:51 <Cale> Data.Text has a replace function
13:21:15 <singpolyma> Cale: oh? I just looked but didn't see it.  I will look again
13:21:22 <Cale> It's just called replace
13:21:33 <tew88> mm_freak: I seem to recall reading positive reviews about it tidying (and adding some consistency) to otherwise 'messy' imports -- I'm interested to see how it performs and what it does =)
13:21:47 <Cale> http://hackage.haskell.org/packages/archive/text/0.11.2.2/doc/html/Data-Text.html#v:replace
13:21:56 <xvilka> btw, anyone know some libs/programs on haskell about decompilation or file format recognition - mostly reverse engineering stuff?
13:22:02 <singpolyma> ah, there it is.  weird that I didn't see it last time
13:22:03 <singpolyma> thanks@
13:22:04 <singpolyma> :)
13:22:54 <jamiltron> tew88: Yeah, I've had some code where it makes the imports look silly, but otherwise I kind of like it.
13:23:42 <ski> killy9999 : yeah, it might have been "Pearls of Functional Algorithm Design" by Richard Bird in 2010 that i was thinking about, not sure
13:25:04 <killy9999> ski: it looks very interesting, I'm just not sure if I should go for it providing that I'm still reading RWH
13:25:16 <c_wraith> ...  I wonder where my copy of that book went.
13:25:18 <ski> killy9999 : "and I guess that's the only thing tha comes to my mind" -- apart from "Purely Functional Data Structures" by Chris Okasaki in 1998 :)
13:25:38 <tew88> jamiltron: Cool.  Good to know it doesn't perform well in all situations: I'll run some tests
13:25:41 <hape01> let xs = 1 : xs in xs   is an infinite list but is not bottom?   if it is bottom   let xs = 1 : xs in take 20 xs    is not?
13:25:44 <killy9999> ski: naturally :)
13:25:46 <jamiltron> Okasaki book + the Bird book really complement each other.
13:25:50 <luite> killy9999: it's quite a good read even if you're still reading RWH
13:26:08 <Cale> hape01: Right, it's not bottom
13:26:14 <hape01> Thanks, Cale
13:26:16 <jamiltron> Both are good books to pick up and put down without needing to work through from front to back.
13:26:21 <mapreduce> > let replace hay needle by = if forall (\(x, y) -> x == y) (zipWith replace hay) then needle ++ replace (drop (length hay)) needle by else head needle :: replace (tail hay) needle by in replace "I want a dog" "dog" "cat"
13:26:22 <lambdabot>   Not in scope: `forall'
13:26:42 <mapreduce> Bah, gave me a different error in /msg
13:27:02 <Cale> perhaps you wanted 'all' instead of forall
13:29:57 <mgq1> join #c++
13:30:18 <Cale> > let replace xs ys zs | Just zs' <- stripPrefix xs zs = ys ++ replace xs ys zs'; replace xs ys (z:zs) = z : replace xs ys zs; replace xs ys [] = [] in replace "dog" "cat" "I want a dog"
13:30:20 <lambdabot>   "I want a cat"
13:30:46 * killy9999 goes to sleep
13:31:36 <ski> (c_wraith : .. the pearls one ?)
13:31:52 <c_wraith> yeah
13:34:42 <keseldude> Cale: do you think this is a good idea? http://hpaste.org/72166
13:35:33 <ceti331> does haskell ever compile to something that recycles memory - e.g. performing calculations in-place where possible rather than copying (and waiting for GC to free unreferenced data)
13:35:40 <keseldude> where you can implement all the classes that the class depends on
13:35:47 <Qtr> Any good link to writing a compiler in Haskell?
13:35:57 <Qtr> Maybe I should write a C-compiler in Haskell, how many LOC for a simple one if anyone have done one?
13:36:00 <srhb> Qtr: Didn't you see the write you a scheme in 48 hours link earlier?
13:36:14 <srhb> Qtr: And we already answered that question like five times today. :-)
13:37:58 <hpaste> keseldude annotated “Idea” with “Idea (annotation)” at http://hpaste.org/72166#a72172
13:39:19 <geekosaur> ceti331, there's quite a lot of effort in both ghc and jhc, at least, spent optimizing the code that way
13:39:39 <Botje> ceti331: if the strictness analyzer is happy enough
13:39:51 <Botje> Qtr: five million.
13:39:54 <Botje> Qtr: or 5000
13:39:58 <Botje> Qtr: or 500.
13:40:07 <Botje> Qtr: depends on how far you want to go.
13:40:36 <Botje> Qtr: as for good links .. I liked "compiling with continuations" by Appel.
13:40:58 <Botje> Qtr: and you proabbly want to use a member of the parsec family to process your source code
13:41:06 <Botje> Qtr: or that C language thing on hackage
13:42:00 <mapreduce> Cale: There was a lot more wrong with it than all/forall :)
13:42:12 <mapreduce> > let replace hay needle by = if hay == [] then [] else if all (\(x, y) -> x == y) (zip hay needle) then by ++ replace (drop (length needle) hay) needle by else head hay : replace (tail hay) needle by in replace "I want a dog for Christmas" "dog" "cat"
13:42:14 <lambdabot>   "I want a cat for Christmas"
13:42:47 <tromp_> in C, is it possible to define a type fun which is a pointer to a function which has one fun argument and returns a fun?
13:43:08 <ben> C doesn't have type funs
13:43:20 <tromp_> fun is just a name for my type
13:43:20 <c_wraith> it has type sadness
13:43:34 <shachaf> tromp_: You mean infinite types?
13:43:49 <c_wraith> it is an infinite type, yes
13:43:56 <tromp_> yes
13:44:09 <c_wraith> newtype Inf = Inf (Inf -> Inf)
13:44:24 <shachaf> tromp_: No.
13:44:44 <n00by> hello
13:44:48 <quicksilver> you can if you do it via a struct, I think
13:44:49 <shachaf> typedef in C is like "type" in Haskell, and neither does equirecursive types.
13:45:00 <c_wraith> yeah, I think you can do it with a struct
13:45:02 <shachaf> But you can probably do it by making an actual new type, the way quicksilver said.
13:45:09 <tromp_> i'll have to fudge it then with void pointers and casting:(
13:45:21 <quicksilver> that's how you do everything in C.
13:45:29 <shachaf> tromp_: Or by using a struct!
13:45:40 <shachaf> structs aren't so bad. You can get a surprising amount of "type safety" in C.
13:46:27 <n00by> i can trun my computer on and wtf-honey / wtf-noob showed me how
13:48:34 <Botje> n00by: great!
13:48:48 <n00by> thanks
13:49:07 <bluej774> In a case where using both $ and . makes sense, what's the preferred choice and why?
13:49:32 <ben> . because it's less visually noisy
13:49:44 <Botje> . is better for the environment because there's less pixels.
13:49:57 <Botje> also, you can cut out a piece of your pipeline and stick it in another function
13:50:33 <hpc> depending on your imports, (.) is more polymorphic
13:51:52 <EvanR> :t (.)
13:51:53 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
13:52:12 <EvanR> :t (<$>)
13:52:13 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
13:52:37 <dzhus> should I specify inline pragma in class declaration or in instance definitions?
13:52:46 <EvanR> > (+1) <$> (div 9) <$> (subtract 2) $ 99
13:52:47 <lambdabot>   1
13:52:53 <EvanR> > (+1) <$> (div 9) <$> (subtract 2) $ 96
13:52:54 <lambdabot>   1
13:53:12 <EvanR> > (+1) <$> (div 9) <$> (subtract 2) $ 5
13:53:13 <lambdabot>   4
13:53:23 <bluej774> So, I'm hearing "whichever one uses fewer characters"
13:54:04 <bluej774> i.e. isJust $ location x could also be (isJust . location) x but that's two more characters.
13:54:29 <Botje> well, isJust . location $ x
13:54:33 <dzhus> i feel more comfortable with dollars
13:54:41 <bluej774> dzhus: Don't we all!
13:54:53 <bluej774> dzhus: Bazinga!
13:55:04 <dzhus> dots left me a bit... empty...
13:55:09 <dzhus> *leave
13:55:19 <bluej774> Botje: That's still 1 extra character.
13:55:23 <EvanR> (a . b . c . d) e isnt that bad
13:55:37 <EvanR> more intuitive than a . b . c . d $ e
13:55:46 <bluej774> true
13:56:12 <EvanR> for two functions like isJust (foo bar) whatever
13:56:33 <bluej774> What I'm hearing now is "Whatever seems to make the most sense at the time". ;)
13:59:37 <Cale> The cool thing about (.) is that it's associative
13:59:47 <Cale> If you write something like  f $ g $ h $ x
13:59:52 <Cale> then g $ h is meaningless
14:00:00 <startling> Hi, I'm getting a pretty confusing error while trying to apply a trifecta parser to a Gen from quickcheck. Anyone care to take a look? https://gist.github.com/7bb8a3e61aca5c297be9
14:00:01 <Cale> but if you write  f . g . h $ x
14:00:01 <ion> There’s absolutely nothing implicitly wrong with two more characters.
14:00:07 <Cale> then g . h is actually a meaningful thing
14:01:10 <bluej774> Cale: Good point.  Could benefit from memoization, theoretically.
14:01:41 <ion> I’m not sure how memoization is relevant.
14:02:16 <jamiltron> ion: relevant to what?
14:02:16 <bluej774> f . g can be chunked.
14:02:28 <jamiltron> Oh I see sorry missed that
14:02:34 <valentin> I do not understand how IO wrapping helps to maintain the function purity. It is said to prevent the side effects. But returned IO operation will return another value anyway, when asked
14:03:01 <bluej774> I said theoretically because I don't know if anything memoizes like that or not.
14:03:06 <c_wraith> valentin: the idea isn't to prevent effects. It's to make it obvious where they happen.
14:03:07 <bluej774> But it could, is the point.
14:03:20 <hpc> valentin: perhaps an example
14:03:23 <merijn> valentin: The key point to see is that an IO operation is an operation. The runtime executes an operation (main) when you start your program
14:03:23 * hpc hpastes...
14:03:33 <mikeplus64> c_wraith: very zen
14:03:35 <c_wraith> valentin: effects happen when you execute an IO action.  Not when you evaluate any non-IO expression.
14:03:52 <merijn> valentin: You create the main operation by composing smaller IO operations into bigger ones
14:03:57 <ion> c_wraith: or an IO expression
14:04:35 <valentin> any imputer funciton is executed when I start the program and composing IO operations does not make them pure.
14:04:53 <valentin> Any input from real world is impure
14:05:03 <merijn> valentin: The point is that your program cannot run operations, only the runtime can
14:05:07 <startling> valentin, the *operations* are pure
14:05:14 <c_wraith> valentin: sure. but the operation on the input can be pure.
14:05:16 <startling> valentin, the *results* of the operations aren't
14:05:24 <merijn> valentin: You are (in effect) writing a pure program that builds a big oepration out of smaller operations
14:05:25 <hpc> valentin: an IO action isn't an impure value, it's a computation that produces a value at runtime
14:05:42 <hpc> if you do "let foo = getLine"
14:05:51 <hpc> foo is an action, and it isn't executed
14:06:13 <hpc> if you wanted a similar effect from C, it would be something like
14:06:15 <merijn> > map readFile ["a", "b", "c"]
14:06:17 <lambdabot>   [<IO [Char]>,<IO [Char]>,<IO [Char]>]
14:06:19 <valentin> But it has to be executed ultimately!
14:06:22 <hpc> voo = &scanf;
14:06:25 <hpc> *foo
14:06:27 <merijn> valentin: Not necessarily
14:06:35 <startling> valentin: well, some stuff is executed at runtime
14:06:41 <c_wraith> valentin: yes, your program is ultimately an IO action.  so what?  that's not the point.
14:06:52 <c_wraith> valentin: the point is that *parts* of your program don't use IO.
14:06:56 <bluej774> What if the input is always the same?  Is it pure then? ;)
14:07:07 <merijn> valentin: Look at my example, I create three IO actions in a list. My program can pass the values around without even knowing they're IO actions (or in this example, which file they read)
14:07:09 <ion> valentin: You can put ten print statements into a list, pick one and have it executed. The values in the list are pure themselves, they’re just recipes for the runtime.
14:07:09 <c_wraith> valentin: and that means you have the ability to reason much more clearly about those parts
14:07:29 <ion> valentin: main = [ print "foo", print "bar", print "baz" ] !! 2
14:08:09 <hpc> valentin: have you ever used function pointers before in an imperative language?
14:08:15 <ion> valentin: IO actions are as impure as the string "Would you mind printing baz to standard output? Thanks."
14:08:57 <larks> is http://www.haskell.org/haskellwiki/Introduction_to_Haskell_IO/Actions outdated?
14:09:04 <valentin> Your program will take the IO action, ask its value and act based on this. IO action = impure function, it returns a different value every time. This is impurity. I do not see how action save you from impurity.
14:09:12 <startling> valentin, anyway, a nice thing is that (barring magic), pure functions *can't* execute IO monads
14:09:32 <merijn> valentin: No, it is not an impure function, because it doesn't return anything
14:09:52 <merijn> print is not a function that takes a string and prints it
14:09:52 <ion> startling: There’s only one IO monad.
14:09:58 <valentin> If it does not return anything, then it is useless
14:10:07 <merijn> Print is a function that takes a string and returns an action that will print it when executed
14:10:16 <merijn> > print 1
14:10:17 <lambdabot>   <IO ()>
14:10:24 <startling> ion: s'true, my mistake
14:10:46 <valentin> You know that print 1 will print "1". But getChar is impure
14:10:53 <startling> valentin, no you don't
14:10:55 <merijn> valentin: No
14:11:00 <startling> valentin, what if you don't have a stdout open?
14:11:13 <hpc> valentin: do you know what a function pointer is?
14:11:15 <merijn> valentin: getChar is an action that will return a char. It's not a function at all
14:11:26 <ion> startling: That’s not helpful. :-P
14:11:34 <startling> ion: heh
14:11:45 <merijn> valentin: Have you ever done eventloop/asynchronous programming?
14:12:00 <valentin> yes, I udnerstand what it means
14:12:51 <valentin> but have no clues how it is related to functional purity
14:13:11 <merijn> valentin: "do {x <- getChar; foo x}" is not "read a character and use it with function foo" it is more like "create a hook for getChar that will execute foo on its result"
14:13:12 <jacobian> hmmm, it's a bit annoying that a package a year old is already so obsolete that I can't even hand build it's dependencies without extreme pain.
14:14:23 <startling> jacobian: yeah. :/
14:14:40 <jamiltron> jacobian: It's not Haskell if you can't obsolete packages within weeks of release.
14:14:45 <jacobian> haha
14:15:07 <valentin> But getChar is still impure? Its result is different every call!
14:15:15 <gentleben> valentin: think about it as marking where someone other than you can throw an exception
14:15:16 <merijn> valentin: But you can't call getChar
14:15:21 <latro`a> it's not a function at all, it's an instruction
14:15:21 <hpc> good haskell code lasts forever - the best haskell code is obsolete as soon as it is released
14:15:36 <jamiltron> hpc: I like that
14:15:37 <jacobian> I suppose that nobody wants to keep cruft.
14:15:42 <startling> valentin, only the runtime can call getChar
14:15:45 <startling> valentin: via main
14:15:47 <hpc> valentin: stop thinking in terms of function calls
14:15:49 <jacobian> But cruft at least stays put.  Moving targets are harder to code around.
14:15:50 <merijn> valentin: You can only tell the runtime to make a new action that does something with getChar's result when that new action is run
14:15:53 <hpc> and think in terms of values
14:16:00 <gentleben> valentin: I think I know what you are getting at. It was very hard for me when I first started
14:16:02 <hpc> the value of getChar is an ACTION
14:16:11 <copumpkin> getChar isn't a function
14:16:15 <copumpkin> you don't call it
14:16:26 <startling> valentin: anyway, if you don't understand it yet, it'll come eventually
14:17:04 <startling> valentin, having impure "functions" marked is a handy thing; surely you can appreciate that?
14:17:24 * larks has been ignored
14:17:35 <gentleben> valentin: have you used something like java's nio or .net async or something similar?
14:17:44 <latro`a> I think the first time I saw the downsides of having to mark it was when I realized I'd need something I was using globally to come from the IO monad
14:17:48 <hpc> larks: oh, you asked about http://www.haskell.org/haskellwiki/Introduction_to_Haskell_IO/Actions?
14:17:53 <valentin> I did async input in WIndows
14:17:54 <latro`a> (ofc, the real problem was that I was using something globally)
14:17:58 <startling> larks: hehe. Doesn't look like it.
14:18:06 <gentleben> think about it the same way
14:18:14 <gentleben> but without all the glue code
14:18:23 <hpc> larks: it's not outdated, but there's probably better explanations out there
14:18:48 <ion> valentin: An IO action is a thin wrapper over a string that contains a Perl script that upon execution does the requested things. The RTS unwraps whatever Perl script is assigned to main and runs it via the Perl interpreter. (This may be untrue in most Haskell implementations.)
14:18:54 <gentleben> all IO works effectively like this in haskell
14:18:54 <larks> because when I try to run those I get stuff like "Enter a line: And another: you said: 1 and 2" which seems... sort of wrong
14:19:27 <gentleben> don't worry about the action part because its not that important right now
14:19:40 <startling> ion: haha
14:20:01 <startling> ion, so what do the pugs people do?
14:20:10 <gentleben> imagine you can do all async IO without having to manage completion ports, wire all the callbacks yourself, etc...
14:20:13 <valentin> ion: How calling through Perl makes impure function pure?
14:20:32 <gentleben> valentin: did you ever see the f# async monad?
14:20:47 <ion> valentin: What the RTS does is absolutely impure. But you can work with the values themselves in Haskell as with any other pure values.
14:20:53 <startling> valentin, moands aren't functions
14:20:56 <gentleben> or not monad, just the async {} blocks
14:21:01 <startling> valentin, they're data structures
14:21:19 <gentleben> thats not going to be useful to him right now
14:21:32 <hpc> larks: nothing on that page will behave oddly
14:21:43 <startling> gentleben: yeah, you're probably right
14:21:44 <hpc> except one section which will not compile (on purpose)
14:21:46 <valentin> what asynchronity and monads have to do with purity?
14:21:59 <startling> larks, what code do you have right now? what's the result? what result do you expect?
14:22:55 <hpc> valentin: strictly speaking, nothing; IO coincidentally has a monadic interface, but that's not important or even unique to monads
14:22:58 <larks> the one which promptLine, has a typo in it but I fixed that
14:23:39 <startling> larks, please paste the actual code you're using into http://hpaste.org/new/haskell
14:23:43 <larks> input is "1\n2\n" and the output is "Enter a line: And another: you said: 1 and 2"
14:23:45 <gentleben> valentin: pure functions only touch things inside of your process. So for instance getting the length of a list. If you wanted to get the contents of a directory it must call outside itself to the OS.
14:24:22 <gentleben> valentin: Now say there was a disk failure while enumerating a directories contents. The OS may return you an error
14:25:05 <gentleben> valentin: with your in memory list, save cosmic rays twiddling bits, we can be reasonably sure that we can complete without errors
14:25:22 <hpaste> larks pasted “right, wrong?” at http://hpaste.org/72175
14:25:23 <EvanR> pure functions only touch their first spouses only
14:26:26 <startling> larks: weird
14:26:29 <valentin> gentleben: and making IO asynchronous does not purify it. Purity means result depends on arguments. Input by definition is independent on arguments. If we cannot complete without errors then pure functional computation is not possible at all. I do not understand how IO action wrapping helps there.
14:26:50 <hpc> larks: that's buffering
14:27:06 <hpc> do "ghci test.hs", then run main
14:27:11 <gentleben> valentin: it marks side effects
14:27:13 <EvanR> Monad CosmicRay
14:27:18 <latro`a> lol
14:27:18 <hpc> or do a few imports and hSetBuffering stdin LineBuffered
14:27:40 <EvanR> did default buffering get set to block buffering at some point?
14:27:49 <larks> works with ghci, why doesn't it work with with the compiled version?
14:27:57 <gentleben> valentin: so a pure function can be run 1 or more times. does that make sense? Insofar as the runtime is free to run things when it needs to
14:28:12 <startling> valentin, you're *not* constructing an impure value. you're constructing a sequence of actions that can be sequenced with other actions
14:28:14 <hpc> larks: when it's compiled, it uses block buffering
14:28:28 <hpc> getLine doesn't flush stdout, and a block hasn't been filled yet
14:28:30 <EvanR> dont run functions, apply functions
14:28:39 <EvanR> to arguments
14:28:42 <hpc> so even though there's buffered lines to prompt, they don't appear
14:29:05 <larks> hpc: is there a way to get it to display properly?
14:29:06 <hpc> so what happens is
14:29:17 <hpc> hSetBuffering stdout LineBuffering
14:29:20 <hpc> or something like that
14:29:36 <hpc> you need an import and i forget what it is
14:29:40 <hpc> @where hoogle
14:29:41 <lambdabot> http://haskell.org/hoogle
14:29:54 <gentleben> valentin: and we don't want to purify it. that is one of the great things. we simply want to let the compiler know, this thing here has a side effect or can fail
14:30:25 <larks> okay, at least I know where to start looking, if I have any more problems I'll ask
14:31:58 <valentin> ok, reading about functional programming I started to think that it does not support impure functions and IO actions somehow resolve this. But if you say that they just mark it then it makes more sense.
14:32:44 <EvanR> valentin: haskell doesnt have impure functions*
14:32:51 <gentleben> valentin: we are just marking things for the compiler and the runtime. don't worry about actions and things like that. it will make more sense later
14:32:52 <hpc> valentin: exactly; it's not IO that's important, but the fact that you can't have real-world effects outside of it
14:32:58 <EvanR> *unsafePerformIO
14:33:43 <ski> tromp_ : "in C, is it possible to define a type fun which is a pointer to a function which has one fun argument and returns a fun?" -- heh, i was first thinking you meant stuff like `void (*signal(int signum, void (*handler)(int)))(int);' (from `signal.h') :)
14:33:49 <ski> preflex: cdecl void (*signal(int signum, void (*handler)(int)))(int);
14:33:49 <preflex>  signal: function(signum: int, handler: pointer to function(int) returning void) returning pointer to function(int) returning void
14:33:54 <ski> preflex: help nickr
14:33:54 <preflex>  nickr NICK - increment NICK
14:33:59 <ski> preflex: help nickometer
14:34:00 <preflex>  nickometer NICK - calculate a nick's lameness score
14:34:14 <hpc> preflex: nickr hpc
14:34:15 <preflex>  hpc_
14:34:21 <hpc> preflex: nickr hpc_
14:34:22 <preflex>  hp_c
14:34:22 <ski> preflex: help karma
14:34:23 <preflex>  karma NICK - print a user's karma
14:34:24 <hpc> wat
14:34:36 <tromp_> ski: close  but no cigar:(
14:35:02 <ski> tromp_ : yeah, i realized :/ -- i'd probably go the `struct' way
14:35:22 <ski> (for some semblance of type checking)
14:35:22 <tromp_> yeah; i'll try that
14:35:48 <ski> (i suppose one could use `union' instead, if there's just one field -- but it's probably less confusing with `struct')
14:36:04 <ski> valentin : "I do not understand how IO wrapping helps to maintain the function purity. It is said to prevent the side effects. But returned IO operation will return another value anyway, when asked" -- *evaluating* an `IO'-action (expression) again will always give the same value (which is an `IO'-action), *executing* it is what can cause *effects* (not *side*-effects), to happen
14:36:14 <ski> valentin : the point of "tagging/annotating" operations which can do I/O-effects with `IO' is to turn *side*-effects into plain *effects* -- instead of the effects happening on the *side* of the computation, they're explicitly declared in the interface (the type signature)
14:36:22 <ski> valentin : e.g. in `putStr :: String -> IO ()', the effects is *part* of the return value (which is an `IO'-action, of type `IO ()'), therefore it's not a *side*-effect anymore
14:36:28 <ski> valentin : hence "Your program will take the IO action, ask its value and act based on this. IO action = impure function, it returns a different value every time. This is impurity. I do not see how action save you from impurity." is not correct
14:36:38 <ski> startling : note that having an operation use `IO' doesn't make it any less pure (e.g. `getChar :: IO Char' is *not* impure, it's pure)
14:36:42 <ski> "How calling through Perl makes impure function pure?" :
14:36:46 <ski> @quote /bin/ls
14:36:46 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
14:36:56 <ski> valentin : "Purity means result depends on arguments." -- no, "Purity means result doesn't depend on anything *else* than arguments." is closer
14:36:59 <larks> hpc: "import System.IO" and "hSetBuffering stdout NoBuffering" FYI =]
14:37:26 <startling> ski, yes, I know?
14:37:35 <ski> valentin : part of the point of modelling effects with monads (instead of having them as side-effects, as in imperative programming) is to know in which parts of the code you're *not* using them
14:37:44 <hpc> larks: in lieu of no buffering, you might want strategically located hFlush calls
14:38:03 <hpc> (in the future, when it matters for performance)
14:38:05 <EvanR> valentin is now frightened ;)
14:38:08 <ski> startling : that was re "having impure "functions" marked is a handy thing; surely you can appreciate that?"
14:38:29 <EvanR> i think we need to stop talking about marking functions
14:38:31 <valentin> no, it is intriguing now
14:38:37 <startling> ski, oh. yeah, i was just trying to point out that you don't really need to understand it at first
14:38:56 <startling> ski, looking back, that was a little misleading. oops
14:39:20 <ski> valentin : and i suppose that when i say *side*-effect, i mean roughly : anything that happens when you execute a "function", *apart* from computing the result value depending only on the argument values
14:39:27 <larks> hpc, noted. I'm just getting started so performance isn't key right now, I'll keep that in mind though
14:40:24 <ski> valentin : and part of the point here is that side-effects are usually *undeclared* in function/method prototypes/signatures  -- i.e. you can't know for sure when some effect is *not* happening, without checking the source of the function/method (and everything called by it)
14:43:11 <gentleben> valentin: one thing this enable is STM, which IMHO may be one of haskells greatest features
14:43:14 <ski> valentin : examples of side-effects include : changing some mutable state outside of the function, *reading* some *mutable* state outside the function, adding some stuff to a log (external to the function), raising an exception, using stuff like `setjmp' and `longjmp' to jump between function activation frames, using continuations in languages which support them
14:45:07 <ski> valentin : you can also see it from this angle : most languages come with a pre-defined set of effects (rendered as side-effects), fixed in the language spec. however if you use monads (which you obviously can do even in C++) you get the ability to program your *own* effects, like e.g. a parser monad, or a cooperative threads monad
14:45:41 <dysoco> I'm learning some haskell via tryhaskell.org and I was thinking in coming up with a loop that shows the exponents of 2 (2,4,8,16,32,etc.) how would you do it ? I tried with filter (so I can filter even numbers) and map but it's not working :S
14:45:56 <ski> (to get preemptive threads, you also need a timer which can interrupt what's currently executing -- this is e.g. how SML/NJ implements threads in its CML (Concurrent ML) library)
14:45:56 <mauke> dysoco: iterate (* 2) 1
14:46:29 <ski> > iterate (2 *) 1
14:46:30 <lambdabot>   [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,...
14:46:30 <dysoco> duh, magic
14:46:32 <dysoco> how does that work ?
14:46:34 <ski> @src iterate
14:46:35 <lambdabot> iterate f x =  x : iterate f (f x)
14:47:30 <shachaf> Do you know "map"?
14:47:46 <dysoco> map ? a bit
14:47:55 <shachaf> > let t2s = 1 : map (*2) t2s in t2s
14:47:56 <lambdabot>   [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,...
14:47:59 <dysoco> map (*2) [1..10] for example ?
14:48:01 <mauke> > map (^ 2) [0 ..]
14:48:03 <lambdabot>   [0,1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,...
14:48:06 <ski> valentin : still, if you use monads in e.g. C++, you still miss out on one of the nice point of monads in Haskell, being that you know when effects are *not* happening, by inspecting the type signature and seeing what monads are not there
14:48:13 <mauke> > map (2 ^) [0 ..]
14:48:15 <lambdabot>   [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,...
14:48:23 <dysoco> ah I see
14:48:29 <dysoco> I did
14:48:38 <dysoco> > map (^2) [0..10]
14:48:39 <ski> valentin : knowing what effects are *not* happening is very important to be able to understand, refactor, write and generally maintain code
14:48:40 <lambdabot>   [0,1,4,9,16,25,36,49,64,81,100]
14:48:49 <dysoco> but that obviously didn't work
14:48:57 <dysoco> yes, that's what I was trying to do mauke
14:49:01 <shachaf> (^2) x = (x^2)
14:49:03 <mauke> it worked fine, you just didn't like the results
14:49:07 <ski> valentin : i think i'm probably done here. if anything was unclear or you have other questions, just ask :)
14:49:26 <MostAwesomeDude> > iterate (\x -> if odd x then 3 * x + 1 else x `div` 2) 10983
14:49:27 <lambdabot>   [10983,32950,16475,49426,24713,74140,37070,18535,55606,27803,83410,41705,12...
14:49:40 <MostAwesomeDude> Hmm, too good of a seed.
14:49:43 <MostAwesomeDude> > iterate (\x -> if odd x then 3 * x + 1 else x `div` 2) 12345
14:49:43 <valentin> ski, you just explained why isolation of side effects in good for source code but not for the execution
14:49:44 <lambdabot>   [12345,37036,18518,9259,27778,13889,41668,20834,10417,31252,15626,7813,2344...
14:49:49 <MostAwesomeDude> Dammit.
14:49:52 <MostAwesomeDude> > iterate (\x -> if odd x then 3 * x + 1 else x `div` 2) 123
14:49:53 <lambdabot>   [123,370,185,556,278,139,418,209,628,314,157,472,236,118,59,178,89,268,134,...
14:50:01 <MostAwesomeDude> > iterate (\x -> if odd x then 3 * x + 1 else x `div` 2) 5
14:50:02 <lambdabot>   [5,16,8,4,2,1,4,2,1,4,2,1,4,2,1,4,2,1,4,2,1,4,2,1,4,2,1,4,2,1,4,2,1,4,2,1,4...
14:50:20 <startling> sort of unfortunate that (++) isn't mappend
14:50:22 <ReinH> I feel like I'm saying the same thing twice here, is there any way to make it more succinct? https://gist.github.com/4120b533e0976edacab1
14:50:30 <ski> valentin : i'm not sure what you mean by "isolation of side effects is ... not [good] for the execution" ?
14:50:54 <valentin> ski, afaik you say that IO actions isolate the impurities
14:51:04 <valentin> as far as I could understand
14:51:07 <shachaf> ReinH: You could make some data structure like a Map and look values up in it.
14:51:17 <startling> ReinH, yeah, I'd use a map
14:51:21 <ReinH> Map it is
14:51:28 <ski> valentin : implementation-wise, an action of type `IO Char' probably amounts to roughly a function pointer of type `char (*)(void)' in C
14:51:31 <ReinH> thanks
14:51:44 <ski> valentin : yeah, i'm even saying more : that they *remove* the impurities
14:52:01 <ski> valentin : note that whether something is impure or not depends on the level of abstraction you're looking at it
14:52:15 <startling> ReinH: and then readPiece k = lookup k mymap
14:52:44 <ReinH> startling: would need an inverse lookup for showPiece then but I'm sure I can find it
14:53:00 <ski> valentin : obviously, to implement lists, at some level implementations mutate memory to initialize the head and the tail of the list -- and call-by-need evaluation is usually implemented by thunks which replace (mutate) themselves with the computed value, when done
14:53:24 <ski> valentin : however, at the level of the Haskell *source* code, i'm claiming there are no impurities nor side-effects
14:53:26 <ReinH> startling: I wouldn't expect Map to be efficient in reverse though, so is there an advantage over a plain association list?
14:53:45 <shachaf> ReinH: Well, you only need to construct the inverse Map once. :-)
14:53:51 <ReinH> fair
14:53:58 <shachaf> I don't know if there's a function for doing that but you could do it yourself easily enough.
14:54:01 <startling> ReinH, you could have an association list and use that to make both maps
14:54:09 <valentin> ski, thanks, this is something
14:54:19 <shachaf> I think there's a package on hackage for bidirectional maps.
14:54:28 <shachaf> @hackage bimap
14:54:28 <lambdabot> http://hackage.haskell.org/package/bimap
14:54:41 <ski> valentin : and the consequences of this is that code is much easier to reason about -- e.g. `let foo = putStr "foo" in do foo; foo' really *is* (behaviourally/observationally) equivalent to `do putStr "foo"; putStr "foo"'
14:54:42 <shachaf> The implementation is just (Map a b, Map b a)
14:55:40 <ski> valentin : unlike the similar-looking `foo = puts("foo"); foo; foo;' vs. `puts("foo"); puts("foo");' in C
14:56:47 <ski> valentin : in the former case, we *know* `foo' is equal to `putStr "foo"' inside that expression, so we can "replace equals for equals", and this *always* holds in Haskell, regardless of whether there's any `IO' in the types or not
14:57:33 <ski> valentin : and it is *precisely* by "marking" I/O in the types with `IO', thereby *distinguishing* expressions of type `IO Foo' from ones of type `Foo' which *enables* this "replace equals for equals"
14:59:10 <chidy> hi guys
14:59:20 <ski> valentin : an alternative might be to add an annotation to functions types, to either be "pure" or "impure", and have "impure" be contagious
15:00:14 <ski> valentin : however, that hides the distinction in the types *solely* as distinguished from the monads solution, which also makes sure that the code itself also looks different
15:00:57 <ski> valentin : so, with that "pure"/"impure" annotation idea, it'd be easier to overlook that some subexpression called an "impure" function, when you're refactoring what you thought was a pure part of an impure function
15:01:36 <ski> valentin : i hope this is helpful in better understanding what monads are good for ..
15:02:07 <teneen> how to express "match any bunch of characters and then match the string "xxx" and then match any bunch of characters" idiomatically with parsec?
15:02:21 <ski> hello chidy
15:03:13 <startling> teneen, the main problem is that "any bunch of characters" already matches "xxx"
15:03:58 <hpaste> Chidy pasted “Lambda bot install error” at http://hpaste.org/72177
15:03:59 <startling> teneen, so you can exclude that string explicitly in the first "any bunch of characters"
15:04:00 * ski thinks teneen's problem is a real and (afaik) unsolved problem
15:04:39 <teneen> startling: yes, I want to use it as if I'm pattern-matching (destructing) the list from any part
15:04:47 <chidy> I've been trying to install lambdabot on OS X for two days now but get the above error in hpaste
15:04:55 <chidy> anyone has any ideas please?
15:05:18 <geekosaur> chidy, did you install a real readline library from somewhere?
15:05:38 <chidy> yes, I used brew to install it
15:05:39 <geekosaur> Apple ships a libreadline that the Haskell bindings will accept and then later fail on because it's not actually readline, it's BSD editline
15:05:45 <teneen> startling: I think it would require backtracking
15:06:05 <geekosaur> then you may need to rebuild the haskell binding with some change to make it look under /usr/local instead of using the system one
15:06:06 <startling> teneen, backtracking is the easiest way
15:06:39 <startling> teneen, the other thing you could do is keep some state that says "was the last thing x or xx or xxx?"
15:07:25 <teneen> startling: the main point is I want the code to be readable. I want it to reflect clearly the statement I mentioned
15:07:26 <chidy> geeosaur I tried cabal install readline-1.0.1.0 --configure-option=--with-readline-libraries="/usr/local/Cellar/readline/6.2.4/lib" --configure-option=--with-readline-includes="/usr/local/Cellar/readline/6.2.4/include" --reinstall
15:07:35 <chidy> with no luck
15:07:37 <teneen> startling: like it would in logic programming for example
15:07:46 <chidy> *geekosaur
15:08:03 <startling> teneen: (try (symbol "xxx") <|> anythingElse)
15:08:31 <startling> I don't even remember if parsec has `symbol`. pretty sure it has `try` though
15:08:42 <hpc> it has try
15:08:59 <hpc> symbol would be something that requires more lexing rules
15:09:04 <chidy> the deadline installs fine but the lambdabot installation still fails with the same reason
15:09:12 <hpc> should just be many, notFollowedBy
15:09:13 <geekosaur> so its still finding the system libreadline.dylib for some reason.  I can't really help at the moment unfortunately
15:09:54 <startling> oh, monad is strong than applicative, isn't it?
15:09:57 <startling> *stronger
15:10:18 <chidy> no worries, thanks geekosaur
15:10:46 <ski> teneen : hm, maybe (i'm not sure) `Parsek' would work in your situation ?
15:10:50 <ski> @hackage cake
15:10:50 <lambdabot> http://hackage.haskell.org/package/cake
15:10:52 <ski> @hackage Encode
15:10:52 <lambdabot> http://hackage.haskell.org/package/Encode
15:11:04 <ski> both appears to contain `Parsek'
15:11:50 <ski> note that `Parsek' does not have a need of a `try' combinator (it has one which is `id' for compatibility with `Parsec'), it doesn't prematurely commit to a branch in the way that `Parsec' does
15:12:56 <startling> oh, is parsec not-PEG?
15:13:01 <startling> err, *parsek
15:13:11 <ski> (but you should not use `munch' nor `munch1' in `Parsek' then, since those appear to commit still)
15:13:35 <ski> startling : not sure (not sure what PEG-parsers amounts to)
15:13:59 <startling> ski, PEG parsers pick the first succeeding branch
15:14:13 <startling> ski, in PEG, (<|>) is ordered by precedence
15:14:17 <edwardk> can someone skim through http://www.slideshare.net/ekmett/bound-making-de-bruijn-succ-less and look for obvious errors?
15:14:24 <ski> `Parsek' does a more or less "parallel" search, not exploring just one branch at a time
15:14:39 <teneen> ski: I didn't hear about Parsek before
15:15:09 <teneen> ski: I'll check it out
15:15:31 <startling> ski, yep, sounds like it uses CFGs
15:16:46 <ski> startling : it has stuff like `shortestResult',`longestResult',`longestResults',`allResultsStaged',`allResults',&c.
15:17:11 <ski> (used when doing the top-level call on `parse' on a given parser)
15:18:02 <startling> so, I have a map-like Tree a b. Looking up from it takes an [a]. Is there something like bifunctor where I could use that?
15:18:32 <startling> that is, supply a ([a] -> [c]) and a (b -> d), rather than an (a -> c) and (b -> d)
15:19:42 <teneen> ski: I can't find Parsek on Hoogle
15:19:42 * hackagebot fay 0.1.1.0 - A compiler for Fay, a Haskell subset that compiles to JavaScript. (ChrisDone)
15:19:42 <startling> also, is there something like bifunctor that takes an (a -> b -> (c, d))?
15:19:42 <teneen> ski: what's the name of the package?
15:19:42 <ski> teneen : i mentioned them above
15:19:43 <ski> `cake' and `Encode'
15:20:13 <edwardk> startling: the question is if you have any constraint on the shape of the tree
15:20:27 <ski> startling : for the former, you need a category where a morphism from `a' to `b' is a function of type `[a] -> [b]'
15:20:28 <edwardk> otherwise you might be able to shoehorn a profunctor in there, but i'm not sure and lack time to check =)
15:21:04 <startling> edwardk, it's basically a rose tree with maps rather than lists
15:21:15 <edwardk> oh then you're hosed
15:21:17 <startling> haha
15:21:18 <teneen> ski: It's quite annoying that its not in a separate package though
15:21:18 <ski> startling : for the latter, what would it return ?
15:21:35 <ski> teneen : yes
15:21:48 <edwardk> startling: btw- that is just Cofree a (Map k)  =)
15:21:57 <edwardk> startling: you can get a comonad for it =)
15:22:00 <startling> edwardk: o rly. interesting
15:22:28 <Saizan> edwardk: slide 17, s/Lam (Scope a)/Lam (Scope Exp a)/
15:22:34 <edwardk> thanks
15:22:49 <startling> ski, hm
15:23:22 <ion> edwardk: Is the “Just” on page 21 intentional?
15:23:42 <edwardk> nope
15:23:43 <edwardk> i swapped from Maybe to Incr as i was writing these
15:23:51 <ion> Yeah, so i figured.
15:24:05 <edwardk> which makes the pun at the top of the page a little less good
15:24:13 * ski . o O ( `Coffee a (Map k)' -- what you get when you have a lack of space on your "table" (foldable chair) when you're out hiking in the wilderness )
15:24:31 <startling> ski: ha
15:24:42 <startling> is bifunctor no longer in category-extras? googling for api docs is hell
15:24:44 <edwardk> I need to install a cofree table in my living room
15:24:51 <edwardk> startling: bifunctors
15:24:55 <startling> edwardk: thanks
15:26:14 <EvanR> is there comonad syntax
15:26:24 <ski> nay, good sir
15:26:24 <edwardk> EvanR: dominic orchard put some together
15:26:44 <edwardk> EvanR: but nothing in the main compiler at this time
15:26:49 <ski> (in the language, i.e. -- with TH one can probably make some)
15:26:59 <EvanR> still trying to grok comonads
15:28:00 <EvanR> WHAT ARE THEY REALLY
15:28:00 * ski though suspects that TH isn't enough to get a good syntax for comonads (in the sense of what you can express in the ADT, not in terms of how ugly the concrete syntax looks)
15:28:17 <ski> they are really the dual concept to the concept of monads
15:28:21 <ski> happy ? :)
15:28:58 <EvanR> so coparsers, colistcombinations, cowriter
15:29:04 <ski> no
15:29:28 <ski> you can take the dual of the concept of monads, you can't take the dual of specific instances of that concept
15:29:50 <startling> so, &&& takes an (a -> c) and a (b -> d) and makes an (a, b) -> (c, d). is there anything that makes an (a -> b -> (c, d))?
15:30:12 <mauke> curry
15:30:44 <ski> @type curry
15:30:45 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
15:30:46 <ski> @type uncurry
15:30:47 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
15:30:49 <startling> oh, right
15:30:50 <ski> @type app
15:30:51 <lambdabot> forall (a :: * -> * -> *) b c. (ArrowApply a) => a (a b c, b) c
15:30:53 <startling> forgot about them
15:30:55 <ski> @type curry app
15:30:55 <lambdabot> forall b c. (b -> c) -> b -> c
15:31:09 <ski> @type app . uncurry
15:31:10 <lambdabot>     Couldn't match expected type `(b -> b1, b)'
15:31:10 <lambdabot>            against inferred type `(a, b2) -> c'
15:31:10 <lambdabot>     Probable cause: `uncurry' is applied to too few arguments
15:31:12 <ski> hm
15:31:17 <hpc> :t app .: uncurry
15:31:19 <lambdabot> forall b b1 a b2. (a -> b2 -> (b -> b1, b)) -> (a, b2) -> b1
15:31:28 <c_wraith> @type curry (?f &&& ?g)
15:31:29 <lambdabot> forall a b c c'. (?g::(a, b) -> c', ?f::(a, b) -> c) => a -> b -> (c, c')
15:31:53 <startling> oh, bleh, i don't even have a bifunctor instance
15:31:58 <edwardk> saizan: otherwise reasonably coherent?
15:32:04 <c_wraith> @type curry .: (&&&)
15:32:05 <lambdabot> forall a b c c'. ((a, b) -> c) -> ((a, b) -> c') -> a -> b -> (c, c')
15:32:08 <edwardk> er ion as well =)
15:32:09 <ski> hm, i suppose it was `curry app' i was thinking about -- it just looked "too simple" to me :)
15:32:21 <c_wraith> I'm bad at removing multiple arguments at once
15:32:40 <startling> :t curry . (&&&)
15:32:41 <lambdabot>     No instance for (Arrow (,))
15:32:41 <lambdabot>       arising from a use of `&&&' at <interactive>:1:8-12
15:32:41 <lambdabot>     Possible fix: add an instance declaration for (Arrow (,))
15:32:53 <startling> :t curry $ (&&&)
15:32:54 <lambdabot>     No instance for (Arrow (,))
15:32:55 <lambdabot>       arising from a use of `&&&' at <interactive>:1:8-12
15:32:55 <lambdabot>     Possible fix: add an instance declaration for (Arrow (,))
15:33:03 <c_wraith> well
15:33:09 <ski> startling : that's the same as just `curry (&&&)'
15:33:13 <c_wraith> start in the right spot..
15:33:21 <ion> edwardk: I only skimmed through it, but seems good.
15:33:22 <startling> ski, yeah, not sure why I stuck the $ in there
15:33:29 <c_wraith> :t \f g -> curry (f && g)
15:33:30 <lambdabot>     Couldn't match expected type `(a, b) -> c'
15:33:30 <lambdabot>            against inferred type `Bool'
15:33:30 <lambdabot>     In the first argument of `curry', namely `(f && g)'
15:33:36 <c_wraith> :t \f g -> curry (f &&& g)
15:33:37 <edwardk> ion: thanks =)
15:33:37 <lambdabot> forall a b c c'. ((a, b) -> c) -> ((a, b) -> c') -> a -> b -> (c, c')
15:33:51 <startling> where did it get Bool from?
15:33:55 <startling> oh, &&. heh
15:33:56 <ion> edwardk: Will there be a video of the presentation? I’d like to see it.
15:34:07 <edwardk> ion: i've grabbed my camera. i'm hunting for my tripod
15:34:12 <Saizan> edwardk: yeah, seems good, but recheck the Cylon quote
15:34:32 <edwardk> so it mostly comes down to if i can find it, and if i can figure out where i put the video cable ;)
15:34:45 <edwardk> Saizan: did i typo something there
15:35:17 <Saizan> edwardk: "the better to recongnize .." looks odd to me
15:35:25 <edwardk> its conor ;)
15:35:32 <ski> startling : i mostly use `$' only in a few circumstances : (a) when i want to write a lambda after, so `foo x $ \y -> ..y..' since for some stupid reason `foo x \y -> ..y..' doesn't work; (b) similar cases like `foo x $ do ...' and `foo x $ let ... in ...' and `foo x $ if ... then ... else' and `foo x $ case ... of ...'
15:35:35 <edwardk> interesting
15:35:38 <edwardk> yeah
15:35:39 <edwardk> its wrong
15:35:41 <edwardk> good catch
15:35:56 <edwardk> odd it shows as recognize here
15:36:11 <Saizan> no, the extra n is my typo
15:36:24 <ski> startling : and also in *some* cases when i'd otherwise add a closing bracket several rows after the opening brackets -- if they both fit on the same row, i generally don't use `$'
15:36:27 <Saizan> i meant the construction of the phrase, but it could be conor :)
15:36:33 <startling> ski: it's good for `do`, too
15:36:34 <edwardk> its from http://www.e-pig.org/epilogue/?p=773
15:36:37 <ReinH> shachaf, startling: I'm happy with readPiece now but I feel like showPiece is awkward https://gist.github.com/d8975e56a7f6fe35fbbd
15:36:50 <ReinH> (ignoring for now that I'm using ALs instead of Maps: I'll convert soon)
15:36:51 <ski> (i might make an excpetion for "noise" words like `return'/`pure')
15:37:07 <hpc> ski: i find that i use ($) most often in
15:37:13 <ski> startling : well, i mentioned `do' -- did you mean in any other sense than that
15:37:18 <hpc> forM (expr) $ \elem -> do
15:37:19 <Saizan> edwardk: i see
15:37:28 <ski> hpc : yeah `($ ...)' is also an exception
15:37:29 <startling> ski: oh wow, completely missed that
15:37:37 <startling> ski: just go ahead and disregard everything I say.
15:37:40 <ski> hpc : yeah, i mentioned that case above :)
15:37:59 <startling> ReinH, why does ShowPiece take a Maybe?
15:38:00 <hpc> ($...) is pretty much standard practice in Cont-heavy code
15:38:18 <ReinH> startling: because my board is: type Board = Array Int (Maybe Piece)
15:38:24 <ski> hpc : heh, i don't find myself using it much in CPSy code :)
15:38:24 <ReinH> so showBoard = elems . fmap showPiece
15:38:30 <ski> different habits, i suppose
15:38:40 <hpc> flip ($) = Cont's return
15:38:52 * ski nods
15:39:04 <ski>   return a = Cont (\k -> k a)  -- is how i'd write it
15:39:06 <hpc> except "unwrapped"
15:39:23 <hpc> so you can use it in foo = Cont $ blah . blah . ($ ...)
15:39:28 <ReinH> startling: is there a better way?
15:39:49 <startling> ReinH: ah. anyway, it might simplify things if showPiece were just Piece -> Char and then use that for Maybe Piece -> Char
15:39:56 <ski> hpc : heh, i think i get confused by code like that, and have to read and think about it carefully :)
15:40:05 <ReinH> startling: ok
15:40:15 <hpc> same, and not just because it's Cont :D
15:40:34 <edwardk> i tend to write all my cps code in a fairly stylized manner to avoid getting turned inside out ;)
15:40:55 <edwardk> or rather i suppose turned 'right side out' would make more sense it being cps and all
15:42:09 <ski>   ma >>= amb = Cont (\kb -> runCont ma (\a -> runCont (amb a) kb))  -- i suppose how i would write it
15:42:15 <ski> or really, i'd like to write it as
15:42:34 <ski>   runCont (ma >>= amb) kb = runCont ma (\a -> runCont (amb a) kb)
15:42:59 <ski> but i unfortunately can't (i hear you can do that in Agda2 now)
15:43:39 <ski> (possibly i'd use `$' in those, to avoid the brackets piling up at the end, at least if i was splitting it over multiple lines)
15:43:47 <ski> similarly with `State' :
15:46:05 <ReinH> startling: so let's say that it is just Piece -> Char
15:46:14 <ReinH> startling: I'm still not sure how to make it simpler than: showPiece p = maybe '' id (lookup p pieceToChar)
15:46:18 <ski>   ma >>= amb = State $ \s0 -> let
15:46:24 <ski>   (a,s1) = runState   ma    s0
15:46:25 <ski>         in runState (amb a) s1
15:46:29 <ski> is a bit ugly
15:46:45 <startling> ReinH: fromJust (lookup p pieceToChar)
15:46:46 <c_wraith> ReinH: maybe x id = fromMaybe x
15:46:49 <ski>   runState (ma >>= amb) s0 = let
15:46:53 <ski>     (a,s1) = runState   ma    s0
15:46:55 <ski>           in runState (amb a) s1
15:46:58 <ReinH> oh ofc, sorry
15:46:59 <ski> would be a bit nicer
15:47:13 <ski> (alternatively using `where' instead, though that gets the ordering wrong)
15:48:03 <startling> is there a way I can have list of type [(k, Either a [(k, Either a [(k,...)])])]? I have a data type that corresponds to this; this is for my fromList function
15:48:16 <ski> startling : define a new type
15:48:31 <startling> ski, ah
15:48:41 <ski>   newtype MyList k a = MkMyList [(k,Either a (MyList k a))]
15:48:53 <startling> I can't do it with `type`?
15:49:05 <ski>   newtype MyList k a = MkMyList {unMyList :: [(k,Either a (MyList k a))]}  -- if you want a selector
15:49:09 <ski> startling : correct
15:49:17 <ski> you can't make cycles with `type'
15:49:23 <startling> darn
15:49:32 <ski> every cycle has to be indirected either through a `newtype' or a `data'
15:49:50 <startling> what if I just write the function and try and get ghc to infer it?
15:49:58 <ski> (cf. how you can't make cycles with `typedef' in C, only with `struct' or with `union')
15:50:15 <ski> startling : you'll get an error "infinite/cyclic types"
15:50:18 <startling> ah
15:50:33 <ski> startling : in `ocaml -rectypes' you'll get away with it -- the problem isn't that it's hard to type-check
15:51:05 <ski> startling : the problem is that enabling this means that lots of things which would normally be type errors now become well-typed things with strange cyclic types
15:51:38 <startling> I guess I should ask the question that led to this: what's a nice way to have people define a "data Tree l c = Branch (Map l (Tree l c)) | Leaf c"?
15:52:18 <ski> (and the reason it's in `ocaml -rectypes' is because they need it to build cyclic object types (for "clone"-type and "binary method"-type methods) -- without `-rectypes' it must at least be indirected through an object type (which you *don't* have to declare, it can be inferred))
15:53:09 <ski> startling : not sure what you're asking ? just define that type if you want it ?
15:53:47 <startling> oh, i mean "what's api to write values of this type?"
15:53:51 <ski> startling : also, it looks like `FreeMonad (Map l) c'
15:53:54 <startling> *a nice api
15:55:50 <startling> ski, um, not really sure what that means
15:56:30 <ski>   data FreeMonad f a = Return a | JoinIncl (f (FreeMonad f a))
15:57:24 <startling> oh, weiiird
15:57:40 <startling> ski, should I just newtype that, then?
15:58:46 <ski>   instance Functor f => Monad (FreeMonad f)
15:58:50 <ski>   where
15:58:54 <aristid> what's a good name fo a zip function that does NOT cut off after there are no elements on both sides?
15:59:06 <ski>     return = Return
15:59:15 <EvanR> heh
15:59:26 <ski>     Return a     >>= amb = amb a
15:59:26 <EvanR> this comment sums up a lot of what i feel about haskell blogs
15:59:30 <EvanR> I’m sure the solution is quite elegant, and someday I hope to understand your post! Learning haskell has been great fun, but it can really make one feel quite illiterate. My head actually hurts from reading this post (no kidding)!
15:59:48 <ski>     JoinIncl fma >>= amb = JoinIncl (fmap (>>= amb) fma)
15:59:59 <startling> ski, is there a standard definition of FreeMonad in a package somewhere?
16:00:22 <aristid> @hoogle Free
16:00:23 <lambdabot> Foreign.Marshal.Alloc free :: Ptr a -> IO ()
16:00:23 <lambdabot> Foreign.Ptr freeHaskellFunPtr :: FunPtr a -> IO ()
16:00:23 <lambdabot> Foreign.Marshal.Pool freePool :: Pool -> IO ()
16:00:29 <aristid> lambdabot: no no, not that
16:00:32 <ski> startling : i think edwardk probably has it somewhere -- i don't recall if he named it exactly `FreeMonad', but it ought to have `Free' in its name, at least, i think
16:00:37 <aristid> lambdabot: no cookie for you!
16:00:50 <aristid> @hoogle Control.Monad.Free
16:00:50 <lambdabot> package free
16:00:51 <lambdabot> package free-theorems
16:00:51 <lambdabot> package free-theorems-counterexamples
16:01:03 <aristid> startling: maybe try those?
16:01:16 <ski> startling : anyway, consider the monad `data Expr var = Var var | LitInt Integer | Add (Expr var) (Expr var) | Mult (Expr var) (Expr var)' (yes, this is a monad !)
16:01:17 <startling> thanks!
16:01:51 <aristid> turns out the free package is from edwardk!
16:01:53 <ski> startling : then `Expr var' is basically the same as `FreeMonad ExprF var' with `data ExprF var self = LitInt Integer | Add self self | Mult self self'
16:02:01 <startling> ski, you're saying "Free" would be a better use for that, because it has Var var?
16:02:07 <startling> *better to use
16:02:32 <startling> weiird
16:02:38 <startling> is this related to fix somehow?
16:03:44 <ski> startling : well, sometimes you'd define `ExprF' anyway (e.g. when you want to annotate each "level" in the expression with some extra information), so defining the "main" type as just `FreeMonad ExprF' is then good
16:04:13 <ski> @where DecoratingStructures
16:04:13 <lambdabot> <http://web.archive.org/web/20051126143527/http://haskell.org/hawiki/DecoratingStructures>
16:04:14 <ski> @where IndirectComposite
16:04:15 <lambdabot> <http://web.archive.org/web/20051126141834/http://haskell.org/hawiki/IndirectComposite>
16:04:42 <ski> startling : "related to fix" is hard to answer -- it's probably related in some way :)
16:07:05 <ski> startling : in any case, it's related to defining `type ClosedExpr = Fix ExprF' (an expression with no variables), given `newtype Fix f = In {out :: f (Fix f)} :)
16:07:05 <ski> (that `Fix' is sometimes called `Mu' or `Nu', to emphasize the least-fixed-point or greatest-fixed-point idea)
16:07:05 <ski> > fix (In . Just)
16:07:07 <lambdabot>   In (Just (In (Just (In (Just (In (Just (In (Just (In (Just (In (Just (In (J...
16:07:15 <ski> @type fix (In . Just)
16:07:16 <lambdabot> Mu Maybe
16:07:22 <ski> @src Mu
16:07:22 <lambdabot> newtype Mu f = In { out :: f (Mu f) }
16:07:29 <startling> ski: woah
16:08:53 <ski> > let inJust = In . Just in (inJust . inJust . inJust . inJust) (In Nothing)
16:08:55 <lambdabot>   In (Just (In (Just (In (Just (In (Just (In Nothing))))))))
16:08:57 <ski> @type let inJust = In . Just in (inJust . inJust . inJust . inJust) (In Nothing)
16:08:58 <lambdabot> Mu Maybe
16:09:27 <mapreduce> :t apply
16:09:28 <lambdabot> Not in scope: `apply'
16:09:32 <MostAwesomeDude> @src Free
16:09:32 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
16:09:34 <MostAwesomeDude> Heh.
16:10:15 <startling> MostAwesomeDude: http://hackage.haskell.org/packages/archive/free/3.0/doc/html/Control-Monad-Free.html
16:10:48 <MostAwesomeDude> startling: Yeah, I just wanted to see the difference between Free and Mu.
16:11:30 <ski> `Free' has the `Return'/`Pure'/`Var' constructor
16:14:03 <MostAwesomeDude> Right.
16:14:04 <startling> ski, this is very cool. thanks for introducing me
16:14:56 <startling> do I get some class instances for free out of this?
16:15:18 <startling> I feel like I should but I don't see them in the `free` package.
16:17:26 <ski> given `newtype (g :. f) a = MkComp (g (f a))', `Mu (Maybe :. ((,) a))' is basically the same as `[a]'
16:17:26 <ski> startling : for "expression monads" like `Expr' above, `subst :: Monad m => (var -> m var) -> (m var -> m anyVar)' defined by `subst env expr = do var <- expr; subst env (env var)' can be useful
16:17:26 <ski> startling : in such a monad, `var <- expr' means : (nondeterministically, like with `[]') navigate to each variable `var' in `expr', splicing the rest of the `do'-expression in place of that `var' in the `expr'
16:17:26 <ski> so `subst env expr' means : repeatedly substitute all the variables in the expression `expr' using the environment `env', until there are no variables left
16:18:31 <EvanR> ski: ive always been confused why this is called non deterministic
16:19:18 <ski> startling : edwardk's package `free' has `instance Functor f => MonadFree f (Free f)', and also some other ones for `Free'
16:57:26 <ski> EvanR : stand by, having connection troubles
16:59:06 <gertc> http://hpaste.org/72167
17:02:39 <hpaste> gertc annotated “how do i make type m Text into Text?” with “how do i make type m Text into Text? (annotation) (annotation)” at http://hpaste.org/72167#a72178
17:04:56 <hpc> gertc: short answer is, you don't
17:05:28 <gertc> whats the long answer :)
17:05:30 <hpc> long answer is, you look for the thing that's expecting a plain old Text, and you use (>>=) or liftIO to make it able to accept an (m Text)
17:05:54 <startling> fmap
17:05:59 <hpc> or that
17:06:14 <startling> wow, there were supposed to be more words there
17:06:25 <twanvl_> In this case, I would use   do { theUrl <- url; stuff (x `mappend` url) }
17:06:39 <hpc> if you know anyone here who really hates you, they would probably say "unsafePerformIO"
17:07:14 <startling> @hoogle (:+)
17:07:14 <lambdabot> Data.Complex (:+) :: a -> a -> Complex a
17:07:33 <startling> anyone know of an unused operator with + in it?
17:07:50 <hpc> @hoogle (+++)
17:07:50 <lambdabot> Text.ParserCombinators.ReadP (+++) :: ReadP a -> ReadP a -> ReadP a
17:07:50 <lambdabot> Text.ParserCombinators.ReadPrec (+++) :: ReadPrec a -> ReadPrec a -> ReadPrec a
17:07:50 <lambdabot> Control.Arrow (+++) :: ArrowChoice a => a b c -> a b' c' -> a (Either b b') (Either c c')
17:07:52 <geekosaur> you can define your own operators
17:08:09 <twanvl_> +!#$%!$#^!#@%!
17:08:19 <hpc> also, (:+) is "uppercase" because it starts with ':'
17:08:21 <startling> geekosaur, I know. I don't want to use an already-common one, though
17:08:25 <hpc> so you likely wouldn't want it anyway
17:08:38 <hpc> startling: use either (+++) or (<+>)
17:09:02 <hpc> let others deal with the collisions if they use your stuff with parsec or ArrowPlus or whatever
17:09:09 <gertc> url >>= \turl -> WS.sendTextData ("Facebook login" `mappend` turl :: Text)
17:10:05 <gertc> gives me no instances for (control....monadThrow)
17:10:10 <startling> hpc: alright, sounds good
17:10:32 <hpc> startling: generally with operators, you pick one that looks like what your thing does
17:10:39 <hpc> regardless of collisions
17:11:19 <startling> yeah
17:12:03 <hpc> gertc: oh, you are using monad-control; restrict everything to use IO instead of MonadIO, MonadControl, MonadBelgianWaffles, ...
17:12:26 <hpc> you'll have much more managable types, and monad-control is a questionable library anyway
17:12:34 <hpc> so better semantics too
17:12:35 <startling> hm, I have a tree-like structure that's basically a labelled rose tree : type Tree k a = Free (Map k) a . it'd probably be bad to make it a monoid, wouldn't it?
17:13:03 <startling> since I wouldn't be able to mappend two Pure values
17:13:03 <hpc> startling: trees can be monoids just fine
17:13:12 <hpc> oh, hmm
17:13:24 <startling> or I *could*, but there wouldn't be an identity
17:13:40 <hpc> @src Free
17:13:41 <lambdabot> Source not found. Do you think like you type?
17:14:13 <mm_freak> @hackage control-monad-free
17:14:14 <lambdabot> http://hackage.haskell.org/package/control-monad-free
17:14:22 <hpc> yeah, don't think you can make that a monoid
17:14:26 <twanvl_> startling: without an identity you have a semigroup instead of a monoid
17:14:40 <startling> twanvl_, but I do have an identity for the case where I'm adding two Frees
17:14:47 <hpc> it makes a MonadPlus though, if you can change (Map k) to something else
17:14:59 <startling> hpc, like what?
17:15:05 <hpc> no clue :P
17:15:10 <startling> haha, alright
17:15:19 <hpaste> gertc annotated “how do i make type m Text into Text?” with “how do i make type m Text into Text? (annotation)” at http://hpaste.org/72167#a72181
17:16:19 <startling> if the Free thing is confusing ya'll, it's basically "data Tree k a = Node a | Branch (Map k (Tree k a))
17:17:30 <hpc> oh, i think you can make that a monoid
17:17:38 <hpc> with mempty = Branch emptyMap
17:17:42 <twanvl> you could make this into a monoid if a is one itself
17:17:56 <startling> hpc, what do you do for (Node x) `mappend` (Node y)?
17:18:00 <startling> twanvl_: ahhhh
17:18:05 <twanvl> although, you steel need to figure out how to combine branches with nodes
17:18:14 <startling> oh, right
17:18:16 <startling> hm
17:18:26 <hpc> oh, or that way
17:18:35 * hpc doesn't fully grok tree monoids
17:18:58 <startling> hpc: yeah, mempty = Branch emptyMap is what i'd like to do
17:19:04 <twanvl> what is the application of this type? that might give some clues
17:19:29 <startling> twanvl_, I want to make a tree of functions to apply to a file hierarchy
17:19:50 <twanvl> Maybe there should also be values at the nodes, and not just at the leaves?
17:20:14 <startling> twanvl_, how does that make sense for a file hierarchy?
17:20:31 <twanvl> you apply those functions to a directory?
17:20:38 <startling> oh, hm
17:20:44 <twanvl> depending on what the functions are of course
17:20:50 <startling> "apply to everything in the directory", you mean?
17:21:07 <twanvl> depends on what you want to do
17:21:51 <twanvl> do you really need the hierarchy if you are only interested in the leaves?
17:22:24 <startling> twanvl, I'm not only interested in the leaves, though
17:22:35 <startling> their places in the hierarchy are important
17:23:12 <gertc> can you give me the liftio solution ?
17:23:51 <startling> gertc, I'd recommend doing (someFunction <$> myMText)
17:24:05 <startling> gertc: you coud also (liftM someFunction) myMText
17:25:17 <gertc> a wait this seem to do somthing
17:25:27 <dzhus> why there's no lift2 for really thick buritos?
17:25:35 <gertc> do url <- liftIO fbUrl WS.sendTextData ("Facebook login" `mappend` url :: Text)
17:26:51 <startling> is it reasonable to not provide implementations for (Node x) `mappend` (Branch y) and vice-versa?
17:27:13 <c_wraith> startling: no, mappend is expected to be total
17:27:20 <startling> darn
17:27:21 <twanvl> that usually suggests something is wrong
17:27:23 <carharttjimmy> so what does lazy evaluation really mean? I am reading learn2haskell and it keeps using it... but i dont get it.
17:27:39 <startling> carharttjimmy, nothing really happens until it needs to
17:27:51 <carharttjimmy> ahh, so its like me on a saturday ?
17:27:53 <startling> carharttjimmy, i.e., until main calls it
17:28:00 <startling> carharttjimmy: exactly!
17:28:02 <carharttjimmy> If I dont have to do it, then I wont do it ?
17:28:12 <startling> hence "lazy"
17:28:17 <carharttjimmy> ahh thank you startling
17:28:33 <carharttjimmy> I am just learning how to mess with tuples
17:29:40 <startling> carharttjimmy, so, fst (a, b) = a
17:29:45 <twanvl> startling: I would try  data Tree k a = Node a (Map k (Tree k a))
17:29:58 <carharttjimmy> I am going over zip right now.
17:30:05 <startling> carharttjimmy: if I do fst (0, 1 + 10), 1 + 10 never happens
17:30:22 <carharttjimmy> because fst only takes the first part of the pair
17:30:25 <carharttjimmy> :D
17:30:25 <startling> yep
17:30:30 <startling> and you never use the second part
17:30:46 <carharttjimmy> thats snd job
17:31:05 <carharttjimmy> so if you do snd (0, 1+10) you would get 11 ?
17:31:10 <startling> right
17:31:25 <carharttjimmy> this is easier than learning c++
17:31:33 <startling> in most languages, 1 + 10 would be immediately evaluated
17:31:38 <startling> carharttjimmy: I'd say so.
17:31:47 <startling> it's a bit of a mindfuck though tbh
17:31:48 <carharttjimmy> yes but since haskell is lazy, it wont do it.
17:32:00 <carharttjimmy> unless you tell it to
17:32:10 <carharttjimmy> thats why zip [1..] ["apple","orange", "cherry", "mango"]
17:32:16 <carharttjimmy> doesnt go on forever
17:32:24 <carharttjimmy> it stops after 4 for mango
17:32:35 <startling> well, not really
17:32:41 <startling> zip is defined to do that.
17:32:59 <carharttjimmy> well yeah.. but you get the point
17:33:05 <singpolyma> I'm using the SDL-mixer package.  When I build with cabal configure && cabal build using: http://pastie.org/4339674 it works, but when I run the same code using runhaskell I get no sound output.  What could be up with that?
17:33:08 <carharttjimmy> zip is written in haskell
17:33:12 <startling> that's why take 5 [1..] doesn't kill the program; it's not going through all of [1..] because it doesn't need it
17:33:13 <carharttjimmy> :/
17:33:34 <c_wraith> startling: it's the same thing, though
17:33:39 <carharttjimmy> and since haskell is lazy, that makes is lazy
17:33:41 <startling> singpolyma, sdl has some problems with runhaskell and ghci iirc
17:33:43 <c_wraith> it's why the [1..] part doesn't run forever
17:33:55 <MostAwesomeDude> > error "Oh noes!"
17:33:56 <lambdabot>   *Exception: Oh noes!
17:34:04 <MostAwesomeDude> fst (1, error "Oh noes!")
17:34:06 <startling> oh! i thought he meant "that's why the resulting list isn't infinite"
17:34:07 <MostAwesomeDude> > fst (1, error "Oh noes!")
17:34:08 <lambdabot>   1
17:34:10 <startling> now I understand
17:34:18 <singpolyma> startling: when I just do   ghc blah.hs   and run the result I also get no sound
17:34:20 <startling> carharttjimmy: yeah, you're right
17:34:30 <startling> singpolyma: odd
17:34:47 <startling> singpolyma, maybe ghc isn't finding your libs correctly?
17:35:40 <carharttjimmy> MostAwesomeDude: fst can work on triples ?
17:35:40 <singpolyma> startling: maybe... and yet cabal is?
17:35:54 <startling> singpolyma: yeah, it's definitely weird
17:36:20 <carharttjimmy> wait MostAwesomeDude fst only works on pairs, and what you have is a triple
17:36:30 <startling> carharttjimmy: nah, it's a function call
17:36:31 <startling> carharttjimmy: no comma
17:36:33 <gertc>             where
17:36:33 <gertc>                 prefix = "Facebook code"
17:36:45 <carharttjimmy> ahh i see startling
17:36:59 <carharttjimmy> i missed the comma
17:37:54 <MostAwesomeDude> Or, perhaps more curiously...
17:38:05 <MostAwesomeDude> > [1, error "Two!", 3] !! 2
17:38:06 <lambdabot>   3
17:38:36 <startling> > fst (3, putStrLn "hello, world!")
17:38:37 <lambdabot>   3
17:38:40 <startling> :S
17:39:08 <gertc> can you do liftio in a where?
17:39:30 <startling> gertc, why not
17:39:57 <gertc> client = (fbEmail (T.drop (T.length prefix) msg), sink)
17:39:59 <singpolyma> hmm... now, trying to get it to play sound from arbitrary points in my program, it also gives me no output.  something messed up is happening
17:40:18 <ski> EvanR : there's two kinds of nondeterminism : (a) angelic / all-solutions nondeterminism, as in Prolog,Icon,SQL,Datalog,list monad,John McCarthy's nondeterministic choice operator `amb' ; (b) demonic / committed-choice nondeterminsm, as you get by randomness, (non-declarative) concurrency (due to race conditions), partial specification of library or language operations
17:40:28 <ski> EvanR : (for info on `amb' see <http://icem-www.folkwang-hochschule.de/~finnendahl/cm_kurse/doc/t-y-scheme/t-y-scheme-Z-H-15.html>,<http://mitpress.mit.edu/sicp/full-text/sicp/book/node88.html>,<http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.141.7869>,<http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.55.8479>,<http://www-formal.stanford.edu/jmc/basis1/basis1.html>,<http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.89.8752
17:41:09 <singpolyma> if I play and threadDelay 1000000  at the top of main, it plays fine and then the program goes, but putting it in other places I sometimes get partial playback, or no playback
17:41:46 <ski> EvanR : in the angelic kind (which is related to the Hoare powerdomain preorder), the system will try generating solutions until you're satisfied, it has to assume you could be after any of them, and you get to pick and choose
17:41:48 <monochrom> yes, if the main thread ends, everything else is stopped too
17:42:34 <ski> EvanR : in the demonic kind (which is related to the Smyth powerdomain preorder), the system will arbitrarily pick any one solution, and you have to be prepared for any of them
17:43:03 <mm_freak> singpolyma: do you compile with -threaded?
17:43:07 <mm_freak> (assuming GHC)
17:43:14 <singpolyma> mm_freak: not right now
17:43:19 <mm_freak> you should
17:43:40 <monochrom> depending on actual code
17:43:53 <mm_freak> the concurrency stuff works fine in the single-threaded RTS, until you start to communicate with the outer world, especially through FFI
17:43:59 <monochrom> but -threaded should be a very safe bet
17:44:15 <singpolyma> hmmm, I'll try it
17:44:26 <singpolyma> how do I tell cabal to use -threaded?
17:44:37 <mm_freak> GHC-Options: -threaded
17:44:41 <mm_freak> perhaps also add -W
17:44:53 <mm_freak> for a healthy set of warnings
17:46:01 <mm_freak> note that only programs require -threaded…  it has no effect on libraries
17:46:23 <mm_freak> if you are like me, every program is actually mostly a library and a small executable =)
17:47:27 <startling> why isn't there a general LookupAble class again?
17:47:41 <monochrom> what is LookupAble?
17:48:15 <monochrom> (perhaps that answers your question)
17:48:16 <singpolyma> behavouir of the version built with cabal is still different than the one with   ghc -threaded  (cabal set to also pass -threaded now) and playback seems to work differently based on where in the code it goes.  I'll play with it some more
17:48:17 <rekahsoft> whats the difference between the "transformers package" (http://hackage.haskell.org/package/transformers/) and "mtl" (http://hackage.haskell.org/package/mtl-2.1.2)? from taking a look at the mtl source i noticed that its State and StateT monad were from the transformers package? is this correct?
17:48:24 <startling> something one could use lookup on, naturally
17:48:35 <startling> association lists, maps, etc
17:48:42 <monochrom> there are already Ord and Hashable
17:49:14 <startling> lookup :: LookupAble l => l k a -> k -> Maybe a
17:49:35 <monochrom> oh, the Edison library had that, I think.
17:49:50 <rekahsoft> i see that the mtl package requires functional dependancies but what is the design here?
17:49:50 <monochrom> so the real question is, why didn't it fly and why didn't people care?
17:50:14 <monochrom> "MonadState s m | m -> s"
17:50:45 <monochrom> so that from "StateT Int Blah" the computer already reads off "ah s = Int"
17:50:47 <startling> monochrom, right. it seems like tons of data structures have a "lookup" function; odd that they all do that rather than following a nice interface
17:50:51 <singpolyma> when building with cabal it looks like playback will work from the places I care about, so maybe that'll have to do for now
17:52:01 <monochrom> startling, you should try one of the following two experiments, or both, and see how it pans out for real:
17:53:12 <startling> and it seems odd to restrict my types to Map when for all I care it could be a Trie or infinite list or whatever
17:53:28 <monochrom> 1. write that interface yourself, start using in your projects henceforth
17:54:14 <singpolyma> it's still a bit not working quite right, but I guess I don't really get any options.  that's what I get for using a library that hasn't been updated since 2010
17:55:06 <monochrom> 2. recall that Num, Integral, etc are a "nice" "interface" for number types and already available. in your projects henceforth, begin every file with "default ()", then enjoy the full generality of those interfaces
17:55:24 <startling> monochrom, default () ?
17:55:31 <monochrom> yes, look it up
17:56:30 <startling> k
17:57:11 <monochrom> in short, your generality utopia is dystopia, but you won't be convinced until you practice it
17:57:33 <startling> haha
17:57:47 <mm_freak> well, there is one sensible definition of Lookupable
17:57:57 <mm_freak> the class is called Comonad
17:58:29 <mm_freak> extract :: (Comonad w) => w a -> a
17:59:08 <mm_freak> and then there is a little class, you may call it Seekable…  that one provides, well, 'seek'
17:59:36 <mm_freak> you can define 'lookup' in terms of those two
17:59:48 <startling> huh, interesting
17:59:52 <mm_freak> but monochrom's point remains true
17:59:57 <twanvl> there is a Lookup class in the keys package
18:00:00 <mm_freak> because Comonad requires a * -> *
18:00:23 <mm_freak> and there is really no sensible way to unify every idea of 'lookup'
18:00:23 <startling> mm_freak: looks like Comonad and Seekable both apply to my structure, though
18:01:06 <mm_freak> startling: also lenses form a very interesting generic abstraction of lookup (and update)
18:01:19 <mm_freak> the one from data-lens is actually based on a comonad
18:02:39 <mm_freak> the great thing about this approach is that you get the soundness of category theory, which you may lack with an ad hoc custom solution
18:02:55 <monochrom> on the bright side, Array and UArray use the same class, IOArray, STArray, IOUArray, and STUArray use the same class.
18:03:29 <monochrom> but see http://www.vex.net/~trebla/haskell/annote-STArray.xhtml for the price you pay
18:03:52 <startling> mm_freak, yeah, I've used lenses before. I don't think they work in my case
18:04:12 <startling> I was just thinking I could generalize my "type Tree k a = Free (Map k) a" even further. :)
18:04:41 <mm_freak> certainly
18:04:44 <mm_freak> see Data.Data =)
18:05:20 <mm_freak> your definition is an instance of Data
18:06:12 <mm_freak> but now you're entering the realm of generic programming…  i don't like it much, but it can certainly be useful
18:06:23 <startling> heh
18:06:29 <twanvl> we just need generalized defaulting
18:06:43 <startling> well, since I'm only using lookup on that contained map, I thought there might be something
18:06:46 <startling> ah well
18:06:48 <jfischoff> twanvl: what's that?
18:07:35 <twanvl> the idea is that you declare "default IArray STArray, IArray IOArray"
18:07:58 <jfischoff> and then you can override them?
18:08:07 <twanvl> these are not instances
18:08:12 <startling> mm_freak, so where do I get a Seekable?
18:08:14 <jfischoff> oh
18:08:43 <twanvl> this is a declaration to tell the compiler that when it can't resolve a typeclass constraint, it should try the specified defaults
18:09:02 <twanvl> Haskell already has defaults, but only for a few classes, most importantly for Num
18:09:16 <monochrom> yes, over-generalize your types to classes, so that you use over-generalized defaulting to specialize classes back to types. job security for SPJ or something!
18:09:24 <startling> ha
18:12:13 <Saizan> monochrom: "it requires a compiler flag that .." should be amended since there's ScopedTypeVariables now :)
18:13:42 <monochrom> oh! yeah the old flag was -fglasgow-exts-yes-I-want-them-all
18:14:04 <monochrom> now we have {-# LANGUAGE Awesome #-}
18:14:59 <mm_freak> startling: you find one way to define it in comonad-fd
18:15:09 <mm_freak> @hackage comonad-fd
18:15:09 <lambdabot> http://hackage.haskell.org/package/comonad-fd
18:15:53 <mm_freak> {-# LANGUAGE Agda #-}
18:16:38 <otters> {-# LANGUAGE QuantumAlgorithms #-}
18:20:26 <EvanR> {-# AllowHypercomputation #-}
18:20:34 <EvanR>   ^ LANGUAGE
18:22:06 <mm_freak> what's hypercomputation?
18:23:59 <startling> {-# LANGUAGE Overclock #-}
18:26:51 <EvanR> compute infinite stuff in finite time
18:28:52 <mm_freak> haskell can do that actually
18:28:59 <quintessence> or more accurately, compute non-Turing-computable things
18:28:59 <startling> {-# LANGUAGE Pointers #-}
18:29:01 <mm_freak> and i'm not talking about laziness
18:29:25 <EvanR> ive heard
18:29:26 <mm_freak> startling: import Foreign.Ptr
18:30:20 <pqmodn> mm_freak: i'm curious, do tell!
18:30:25 <startling> ^ me too
18:30:36 <startling> @hoogle (#>)
18:30:36 <lambdabot> No results found
18:30:37 <EvanR> its gonna be a link to a paper or blog ;)
18:30:45 <EvanR> that will make your head explode
18:30:48 <mm_freak> pqmodn: i was just joking of course, but i were referring to the searchable infinite sets stuff
18:30:49 <startling> wow, first unused operator I've ever found
18:31:10 <EvanR> heres another one $!^&&@$
18:31:13 <mm_freak> the reverse state monad is related to this
18:31:25 <mm_freak> startling: (!!!!!!!!!!!!!)
18:31:26 <startling> @hoogle ($!^&&@$)
18:31:26 <lambdabot> No results found
18:31:34 <startling> mm_freak: >:(
18:31:40 <startling> I didn't say I look a lot, okay
18:32:06 <mm_freak> well, since there are only finitely many operators defined, i can come up with infinitely many unused operators =)
18:32:20 <mm_freak> just append another '!'
18:33:01 <ski> EvanR : did you catch my messages to you above ?
18:34:08 <ski> @where impossible
18:34:08 <lambdabot> <http://math.andrej.com/2007/09/28/seemingly-impossible-functional-programs/>,<http://math.andrej.com/2008/11/21/a-haskell-monad-for-infinite-search-in-finite-time/>
18:34:28 <ski> pqmodn,startling : mm_freak might have been thinking about those ^
18:34:34 <pqmodn> thanks :)
18:34:37 <mm_freak> yeah, indeed
18:34:47 <ski> @where topology
18:34:47 <lambdabot> "topology in Haskell" <http://www.haskell.org/pipermail/haskell/2004-June/014134.html> and "Synthetic topology of data types and classical spaces" <http://www.cs.bham.ac.uk/~mhe/papers/entcs87.(pdf|
18:34:47 <lambdabot> dvi|ps)> by Martn Escard
18:34:51 <EvanR> ski: i just read it
18:35:02 <ski> ^ is the "link to a paper or blog","that will make your head explode"
18:38:58 <EvanR> <interactive>: bind: resource busy (Address already in use)
18:39:19 <EvanR> bastard, the doc says it uses to SO_REUSEADDR or something
18:39:23 <EvanR> listenOn
18:41:39 <monochrom> does that mean you're in ghci? maybe re-start ghci?
18:41:50 <EvanR> tried
18:42:11 <EvanR> the shit, its already running in another xterm
18:42:18 <EvanR> did not see it in netstat -t
18:42:41 <monochrom> netstat -t doesn't list the listening ones
18:42:55 <EvanR> oh
18:43:25 <monochrom> netstat -t -l
18:45:15 <monochrom> netstat -t -l -p -n :)
18:46:49 <mm_freak> if you're german, "netstat -tulpen" is easy to remember =)
18:46:56 <mm_freak> but i prefer:  netstat --inet --inet6 -anp
18:47:08 <parcs`> EvanR: are you doing this http://hackage.haskell.org/packages/archive/network/2.3.0.14/doc/html/Network.html#g:10
18:49:54 <carharttjimmy> can you define your own typeclass ?
18:50:04 <startling> carharttjimmy: of course
18:50:12 <monochrom> yes
18:50:39 <carharttjimmy> I am still reading but I am going over typeclasses and that question came across my mind, but the text didnt answer it.
18:50:43 <carharttjimmy> thank you startling
18:50:47 <startling> did you think all these crazy typeclasses came buil-in? ;)
18:51:00 <carharttjimmy> maybe ?
18:51:06 <carharttjimmy> To be honest, I did.
18:51:35 <startling> well, things like Functor and Monoid and Applicative are
18:52:08 <carharttjimmy> ahh
18:52:44 <quintessence> startling: in standard libraries /= built in
18:52:50 <startling> quintessence: true
18:53:05 <carharttjimmy> my head hurts a bit getting my mind wrapped around seperating typeclasses from classes.
18:53:24 <startling> carharttjimmy, classes aren't a thing in haskell
18:53:37 <dgpratt> carharttjimmy: I thought the same thing when I first encountered Haskell; after all, 'primitive' operations like equality, addition, etc, are usually 'built in' in mainstream languages
18:53:37 <startling> carharttjimmy, and typeclasses are much simpler. :)
18:53:47 <carharttjimmy> yet but the book confused me
18:53:57 <carharttjimmy> it said to not think about it and I did...
18:54:00 <startling> haha
18:54:12 <carharttjimmy> stupid book telling me what not to do, will make me think about it.
18:54:44 <carharttjimmy> dgpratt: ofc thats why I thought it was all built in. From my limited programming experience that is.
18:55:01 <mm_freak> carharttjimmy: although it's useful to understand how to define type classes, in practice you rarely do so
18:55:29 <mm_freak> if you come from an OOP background you will feel compelled to define some type classes eventually, and most of the time it will be a mistake =)
18:55:40 <dgpratt> carharttjimmy: I think this is because most languages lack the expressiveness to implement such things well in terms of the language itself
18:55:45 <carharttjimmy> ahh alright mm_freak thank you and I will try to avoid that.
18:55:57 <mm_freak> carharttjimmy: no, by all means, do define classes!
18:56:11 <carharttjimmy> yeah, that makes sense dgpratt
18:56:44 <mm_freak> carharttjimmy: i'm just saying that the more advanced you get in haskell, the less type classes you will define
18:56:51 <carharttjimmy> why should I define a typeclass if I might mess up ?
18:57:26 * carharttjimmy is a bit lost
18:57:35 <mm_freak> you're not going to mess up, but (as a former OOP programmer at least) most of the time you will find that a type class probably wasn't the solution
18:57:55 <carharttjimmy> but.. you just said!
18:58:05 <carharttjimmy> ohh
18:58:07 <carharttjimmy> I misread
18:58:28 <carharttjimmy> you said it would be a mistake
18:58:51 <mm_freak> most of the time in your beginning hours (or weeks in the case of haskell) =)
18:59:19 <carharttjimmy> ahh, well, I am catching on a lot. It seems easier to learn than C++ was
18:59:36 <mm_freak> sure…  the language itself is pretty simple
18:59:50 * hackagebot dropbox-sdk 0.3.0 - A library to access the Dropbox HTTP API. (KannanGoundan)
18:59:54 <carharttjimmy> everyone is different, so maybe I just like it.
19:00:32 <startling> carharttjimmy: well, the thing about c++ is that it's freaking huge
19:00:42 <startling> haskell is much smaller language-wise
19:00:58 <startling> there's some weird stuff to wrap your head around, though
19:01:03 <mm_freak> but really, don't feel discouraged by my words…  if you're compelled to write a type class, do so
19:01:11 <beekor> hey i'm in ghci and trying to use liftM, which hoogle says is in 'base', which loads when i start ghci.  i'm just trying to   :t liftM    to test it, and it's not in scope.  does that make sense ?
19:01:13 <mm_freak> sometimes it's a good idea, but most often you're limiting yourself
19:01:31 <mm_freak> beekor: import Control.Monad
19:01:38 <carharttjimmy> I see mm_freak, I want to make at least one sometime, and yeah you are correct startling
19:01:40 <startling> beekor: base is the base package
19:01:46 <startling> beekor: e.g, what comes with ghc
19:02:01 <startling> beekor: Prelude is the stuff that doesn't need to be imported
19:02:03 <beekor> yeah, so i figured i'd not have to import anything.   okay mm_, i'll try.
19:02:03 <carharttjimmy> I am not discouraged mm_freak, I am actually glad that someone was upfront with me.
19:02:43 <beekor> oh oh i get it.
19:02:59 <mm_freak> beekor: you can use hoogle to find a function
19:03:00 <beekor> thanks.
19:03:02 <mm_freak> @hoogle liftM
19:03:03 <lambdabot> Control.Monad liftM :: Monad m => (a1 -> r) -> m a1 -> m r
19:03:03 <lambdabot> Control.Monad liftM2 :: Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
19:03:03 <lambdabot> Control.Monad liftM3 :: Monad m => (a1 -> a2 -> a3 -> r) -> m a1 -> m a2 -> m a3 -> m r
19:03:07 <beekor> i see it on the hoogle page now.
19:03:27 <mm_freak> in haskell mostly you're not searching for names, but types, and hoogle supports that
19:03:41 <mm_freak> @hoogle (a -> b) -> IO a -> IO b
19:03:41 <lambdabot> Control.Applicative liftA :: Applicative f => (a -> b) -> f a -> f b
19:03:41 <lambdabot> Prelude fmap :: Functor f => (a -> b) -> f a -> f b
19:03:41 <lambdabot> Data.Functor fmap :: Functor f => (a -> b) -> f a -> f b
19:03:57 <shachaf> liftA! Just the thing I thought of.
19:04:20 <beekor> im still really basic in my type interpretation.  eventually i'll have to sit down and read that chunk of it all again and study a bit.
19:04:39 <mm_freak> uh, i didn't know liftA exists…  yet another function to pollute the ugly world
19:04:53 <startling> mm_freak: haha
19:04:58 <shachaf> pollunction
19:05:04 <startling> it does seem kind of weird when we already have fmap
19:05:19 <mm_freak> startling: it's weird, because Functor is a superclass of Applicative
19:05:27 <mm_freak> liftM makes sense, but liftA really doesn't
19:05:32 <copumpkin> homogeneity
19:05:57 <startling> mm_freak, yep
19:07:24 <shachaf> mm_freak: What if you want to instance Functor f where fmap = liftA?
19:08:25 <shachaf> s/\b\f\b/F/
19:10:47 <monochrom> we need elevateA, elevateF, and elevateM :)
19:11:30 <startling> dropM
19:12:12 <carharttjimmy> pattern matching is cool, could you use pattern matching to comb through intense data ?
19:12:25 <monochrom> what is intense data?
19:12:44 <carharttjimmy> like data from inside a tornado
19:12:52 <EvanR> its data that is both topless and bottomless
19:13:29 <startling> oh, i've been meaning to ask: is pattern matching O(n), or are there clever optimizations?
19:13:49 <mm_freak> shachaf: i don't understand the question
19:13:52 <colock> what's n?
19:14:01 <EvanR> f A =
19:14:02 <EvanR> f B =
19:14:04 <EvanR> f C =
19:14:08 <mm_freak> colock: a variable
19:14:09 <mm_freak> =)
19:14:10 <EvanR> it will check for A then B then C
19:14:11 <colock> mm_freak: :]
19:14:12 <ski> startling,mm_freak : `liftA' is so you can say `instance Functor Foo where fmap = liftA', when you've given `instance Applicative Foo where ...'
19:14:21 <shachaf> mm_freak: Presumably liftA f x = pure f <*> x
19:14:23 <startling> colock, the number of matches
19:14:29 <mm_freak> ah, ok
19:14:29 <colock> startling: makes no sense
19:14:31 <mm_freak> efficiency
19:14:36 <colock> well, only partially
19:14:44 <shachaf> mm_freak: Right, what ski said.
19:14:44 <startling> colock, sure it does
19:14:55 <mm_freak> carharttjimmy: on some level haskell has /only/ pattern matching to walk through data
19:15:00 <EvanR> pattern matching is where pure code spends all its time right
19:15:06 <mm_freak> pattern matching is not a feature, but a concept
19:15:08 <startling> oh, I guess "the number of alternatives" would be a better way to say it
19:15:36 <colock> startling: one alternative can also contain more matches
19:15:44 <ski> startling : not counting the time it takes to force thunks (and not counting view patterns), pattern-matching is `O(n)' where `n' is the size of the pattern
19:15:55 <carharttjimmy> ahh I see mm_freak
19:15:57 <colock> i.e. (a,3) and bind a to fst
19:15:58 <mm_freak> but that concept is also one of the most powerful features of haskell =)
19:16:10 <carharttjimmy> hmm
19:16:17 <mm_freak> pattern matching alone can ruin you for most other programming languages
19:16:20 <carharttjimmy> I see, I like it as I read more and more into the book.
19:16:23 <ski> hm, by "the time it takes to force thunks", i mean thunks in the value which you're matching with the pattern(s)
19:16:29 <carharttjimmy> Why is that mm_freak  ?
19:16:41 <colock> I try to avoid pattern-matching on ad-hoc data
19:16:42 <mm_freak> carharttjimmy: clear, concise code to do whatever you want to do
19:17:01 <EvanR> whats adhoc data
19:17:03 <colock> especially if the data is not definitive
19:17:11 <carharttjimmy> no how does it ruin me, I am still a bit unclear on what you mean mm_freak
19:17:17 <colock> EvanR: nothing mathematic-related
19:17:25 <ski> carharttjimmy : because you get very annoyed that not many other languages have pattern-matching, so you'll have to uglify code with `if'-`then'-`else' trees, or weak `switch'-like things
19:17:29 <colock> EvanR: part of the program's domain
19:17:29 <EvanR> Data.Data.Data?
19:17:43 <colock> EvanR: data Person = ... for instance
19:17:50 <monochrom> in scheme, you write "is the list empty? if yes, blah; if no, ... head s ... tail s ..." all the time. it's more verbose than pattern matching
19:18:00 <colock> if you change the data, you should update all the pattern matches on it
19:18:01 <mm_freak> carharttjimmy: "to be ruined for PHP" = "to hate PHP (because of)"
19:18:04 <monochrom> and all other languages are even more verbose than scheme
19:18:16 <EvanR> colock: luckily the compiler will tell you to
19:18:23 <colock> of course
19:18:27 <colock> but it's still tedious
19:18:38 <EvanR> well you have to do that in any language
19:18:39 <colock> prefer to use accessor functions whenever possible
19:18:49 <mm_freak> carharttjimmy: as a haskell programmer it's really depressing to have to write code in most other languages
19:18:55 <colock> mm_freak: :]
19:18:56 <EvanR> find all the places where you used that accessor
19:18:59 <carharttjimmy> ahh I see mm_freak :)
19:19:09 <mm_freak> carharttjimmy: http://lukeplant.me.uk/blog/posts/why-learning-haskell-python-makes-you-a-worse-programmer/
19:19:10 <carharttjimmy> I hate convoluted if then else...
19:19:14 <colock> EvanR: well, firstname p will not change if I add an address to Person, right?
19:19:22 <monochrom> accessor is fine if you really have just a record type
19:19:24 <EvanR> colock: you said 'change'
19:19:28 <shachaf> In other languages I miss pattern-matching, but I tend to miss sum types even more.
19:19:33 <colock> EvanR: you're right :)
19:19:35 <shachaf> They go together naturally, of course.
19:19:44 <colock> sum types!!
19:19:48 <mm_freak> i miss product types as well
19:19:50 <EvanR> colock: if you are just adding fields to a record, then you wouldnt want nameless fields anyway
19:19:52 <mm_freak> actually i miss types
19:20:00 <EvanR> F _ _ _ x _ _
19:20:05 <shachaf> mm_freak: Product types are pretty commonly available.
19:20:07 <EvanR> now THATS tedious
19:20:14 <colock> yeah
19:20:18 <mm_freak> shachaf: the cost is too high, though
19:20:22 <shachaf> mm_freak: Not really.
19:20:28 <mm_freak> haskell: data X = Y | Z
19:20:28 <monochrom> but notice that in other languages, you encode a sum type as a record type. so you don't notice that you have a fake record, not a real record
19:20:40 <shachaf> mm_freak: That's a sum. :-)
19:20:46 <mm_freak> uh, of course
19:20:48 <mm_freak> lol
19:20:54 <carharttjimmy> haha mm_freak, hmm, well, I still like haskell over others. Its already nicer than C++
19:21:05 <carharttjimmy> and dont get me started on java
19:21:05 <shachaf> struct foo { t1 x; t2 y; }; etc. is pretty painless.
19:21:08 <EvanR> haskell is polar opposite to c++
19:21:09 <carharttjimmy> :)
19:21:24 <mm_freak> shachaf: still more painful than haskell
19:21:37 <EvanR> shachaf: yeah but you cant do sum types
19:21:39 <monochrom> the sum is greater than the product
19:21:59 <mm_freak> especially when you didn't define it yourself…  in C you have a lot of functions starting with "get_" or "set_", and they make me throw up
19:22:21 <shachaf> mm_freak: I would say less painful than Haskell records, in a lot of ways. :-)
19:22:41 <mm_freak> EvanR: i think it's more like the opposite of PHP:  well designed, concise, easy to read, typed, type-safe, etc.
19:22:59 <EvanR> you described the opposite of c++ too
19:23:03 <EvanR> besides typed
19:23:05 <mm_freak> shachaf: yeah…  do you remember getters and setters from OOP? ;)
19:23:07 <EvanR> which im still skeptical of
19:23:21 <shachaf> mm_freak: Who said anything about OOP?
19:23:39 <mm_freak> shachaf: nobody, i'm just bringing it in
19:23:44 <monochrom> OOP
19:23:45 <EvanR> please dont
19:23:48 <shachaf> Or, for that matter, getters and setters? Getters and setters are kind of anti-OOP.
19:23:50 <monochrom> ok sorry!
19:24:03 <mm_freak> shachaf: de facto OOP
19:24:12 <monochrom> GOP: getter-oriented programming!
19:24:42 <mm_freak> JP:  java programming
19:24:48 <EvanR> in a basic mutable oop paradigm you have x.y.z and x.y = z
19:24:55 <startling> we call hem lenses here
19:24:57 <startling> *them
19:25:07 <mm_freak> startling: lenses are much more than just getters and setters
19:25:11 <shachaf> EvanR: No, in a basic OOP -- ugh, let's not argue about what "OOP" is. :-(
19:25:27 <EvanR> shachaf: i said 'a' not 'the'
19:25:33 <startling> mm_freak: yeah, I know. similar idea, though
19:25:33 <mm_freak> startling: or, well, getters and setters on a different level
19:26:13 <EvanR> you can have oop that looks nothing like java, or ruby, or go or whatever
19:26:20 <EvanR> obviously not c++
19:26:31 <carharttjimmy> > factorial :: (Integral a) => a -> a
19:26:32 <lambdabot>   Not in scope: `factorial'
19:26:35 <carharttjimmy> hmm
19:26:49 <mm_freak> i think "OOP" has become something different over time…  it's fine to call it OOP, it's just not the traditional OOP
19:27:08 <shachaf> "OOP" means basically nothing. That's why there's no point to arguing about it.
19:27:17 <mm_freak> true
19:27:23 <EvanR> concurrent communicating processes in haskell seems pretty oop
19:27:42 <EvanR> 'message passing'
19:28:25 <mm_freak> well, it kinda does…  OOP as vaguely as you can define it:  imperative programming with poor modularity abstractions to make the highly effectful coding style slightly more maintainable
19:29:30 <mm_freak> EvanR: that's rather actor-based concurrency (even though actors are just one abstraction)
19:30:06 <mm_freak> carharttjimmy: lambdabot evaluates expressions or figures out types for you (along with a lot of other features, which you can discover later)
19:30:09 <mm_freak> > 1 + 2
19:30:10 <lambdabot>   3
19:30:12 <mm_freak> :t 1 + 2
19:30:13 <lambdabot> forall t. (Num t) => t
19:30:16 <ski> @where object-oriented
19:30:16 <lambdabot> http://community.schemewiki.org/?object-oriented-programming
19:30:24 <carharttjimmy> ahh alright mm_freak
19:30:48 <carharttjimmy> I fixed my problem, I had declared factorial before with a different type so I just commented out the prior
19:30:52 <mm_freak> carharttjimmy: if you're engaging in a heavy flirt with lambdabot you may want to talk to her in private =)
19:31:00 <carharttjimmy> ahh alright
19:31:05 <carharttjimmy> thank you mm_freak
19:31:14 <mm_freak> she's turing-complete, so she can potentially make your dreams come true
19:31:19 <carharttjimmy> I will try not to break her...
19:31:28 <carharttjimmy> take that as you will.
19:31:36 <aristid> carharttjimmy: we will make sure to blame you when she goes down
19:32:04 <monochrom> she is not turing-complete. she has a severe time limit
19:32:16 <carharttjimmy> haha, they blame me for phrik in #archlinux-offtopic when he breaks so its just another thing to be blamed for.
19:32:58 <mm_freak> don't worry, she's haskellian…  she's not as easy to break =)
19:33:19 <carharttjimmy> it appears that haskell driven programs are indeed hard to break
19:33:29 <carharttjimmy> or written in haskell..
19:33:52 <mm_freak> poorly programmed haskell programs can be told to eat up your memory, but that's basically the way they can fail in most cases
19:34:24 <carharttjimmy> hmm, I will try to make my programs not so poorly programmed but as a beginner that will happen.
19:34:58 <mm_freak> difference to C:  getLine won't overflow your buffer, but can take your machine down instead…  but there are easy ways to make it only kill your program instead of the whole machine =)
19:35:13 <carharttjimmy> ahh alright
19:35:23 <carharttjimmy> sounds deadly yet cool
19:35:36 <mm_freak> to be safe, put this in your .whatevershellrc:  export GHCRTS="-M512m"
19:35:45 <mm_freak> where 512m could be half of your RAM
19:37:18 <carharttjimmy> thank you mm_freak I put it at 1 gig, but thats 1/3 of my usuable ram so I should be good
19:37:28 <carharttjimmy> arch linux runs on very little ram as is
19:38:01 <startling> how does getLine do that?
19:39:13 <mm_freak> startling: getLine doesn't, but when reading from a socket, a malicious peer might
19:39:23 <mm_freak> try getLine on /dev/zero
19:39:26 <mm_freak> no, don't
19:39:29 <mm_freak> =)
19:39:36 <monochrom> getLine allocates more memory as it reads and still sees no end
19:39:37 <startling> oh, understood
19:40:07 <monochrom> you don't get buffer overrun, you just get dos
19:40:14 <startling> right
19:48:48 <mm_freak> carharttjimmy: also note that GHCRTS is only supported by younger GHC versions…  if you have 7.4 you should be safe
19:50:19 <Veinor> GHCRTS was added in 7.0.1
19:50:19 <carharttjimmy> ah alright mm_freak
19:50:24 <Veinor> or so
19:50:50 <mm_freak> oh, really?
19:51:01 <Veinor> http://www.haskell.org/ghc/docs/7.0.1/html/users_guide/runtime-control.html
19:51:09 <mm_freak> though even 7.0 is still young
19:51:29 <Veinor> imo most people should at least use 7.0
19:51:43 <carharttjimmy> how do I check the version ?
19:51:48 <Veinor> ghc --version
19:51:55 <mm_freak> you forget the bulk of debian users
19:52:08 <Veinor> oh, true
19:52:16 <carharttjimmy> I have The Glorious Glasgow Haskell Compilation System, version 7.4.2
19:52:26 <carharttjimmy> arch linux and the bleeding edge ftw
19:52:27 <mm_freak> carharttjimmy: with arch linux you're safe =)
19:52:43 <carharttjimmy> thank you mm_freak , if it was ubuntu I would be in trouble...lol
19:53:01 <mm_freak> probably
19:53:14 <mm_freak> but you always have the option to install the haskell platform, if you distribution sucks
19:53:28 <mm_freak> /if your/
19:53:53 <carharttjimmy> yeah but "suck" is a relative term, its relative to the fact that if its not arch, it sucks.
19:54:28 <jmcarthur> i wouldn't go that far. arch is pretty nice though
19:54:38 <mm_freak> carharttjimmy: there are nice alternatives to arch
19:54:44 <jmcarthur> (my favorite... and has basically the best haskell support ever)
19:54:46 <mm_freak> if you like haskell, chances are you also like NixOS
19:55:00 <startling> NixOS is too weird for me
19:55:01 <carharttjimmy> hmm
19:55:14 <jmcarthur> when you install arch from the cd, haskell is one of the *categories* of packages to choose from
19:55:44 <carharttjimmy> well jmcarthur, no more AIF. But this is more for an offtopic channel dont you think ?
19:55:55 <jmcarthur> i'm keeping it relevant to haskell :)
19:56:21 <Veinor> i remember in 6.12 there was no way to disable runtime passing of RTS options
19:56:25 <jmcarthur> oh wow, no more aif indeed. so my claim is null and void, now
19:56:26 <aristid> jmcarthur: does Perl have a category too?
19:56:35 <jmcarthur> aristid: i don't recall
19:56:39 <Veinor> which meant that setuid root ghc-compiled binaries could scribble over anything if you passed them the right options...
19:56:57 <carharttjimmy> aristid: yes it does, its part of the base applications
19:57:13 <startling> Veinor: ouch
19:57:13 <parcs`> i don't think arch has exceptional haskell support
19:57:16 <aristid> carharttjimmy: that's not the question
19:57:19 <carharttjimmy> jmcarthur: it uses simple scripts now. But, haskell I beleive is still able to be chosen.
19:57:21 <startling> Veinor, did they think this php or something?
19:57:42 <mm_freak> also it took arch a long time to finally switch from 7.0 to 7.4
19:57:46 <Veinor> startling: and that's why RTS options are disabled by default in 7.0!
19:57:48 <parcs`> debian and its derivatives have better support for haskell imo
19:58:03 <aristid> mm_freak: well waiting for the platform kinda-sorta makes sense
19:58:04 <jmcarthur> that is true. it saddened me
19:58:05 <carharttjimmy> I guess, i shouldnt have started the distro war
19:58:16 <mm_freak> aristid: kinda sorta
19:58:22 <startling> does someone have a library up that uses QuickCheck? I'm not sure where to stick my test files
19:58:25 <mm_freak> carharttjimmy: oh, it's not a war =)
19:58:30 <jmcarthur> the platform does not make much sense to me
19:58:37 <mm_freak> carharttjimmy: it's very difficult to troll #haskell =)
19:58:43 <aristid> mm_freak: even nix had 7.0 as the default until the platform was released
19:58:54 <parcs`> it took arch a couple of months to upgrade from ghc 6 to ghc 7 too
19:58:59 <carharttjimmy> I didnt mean too mm_freak
19:59:22 <mm_freak> aristid: huh?  NixOS switched to 7.2 while arch was sitting on 7.0 for a long time
19:59:29 <startling> mm_freak: does haskell have tco???
19:59:36 <aristid> mm_freak: nix might have made it available
19:59:44 <jmcarthur> startling: that's a difficult question to answer properly
19:59:46 <aristid> mm_freak: but the default was 7.0 until very recently
19:59:47 <mm_freak> startling: technically no, because you don't need TCO in haskell
19:59:57 <jmcarthur> mm_freak: not quite true. strict functions need it
19:59:58 * startling whistles
20:00:12 <jmcarthur> or, well...
20:00:15 <wollw> Is it possible to do a partial import of a module using setImports in Language.Haskell.Interpreter?
20:00:17 <jmcarthur> the equivalent for the runtime
20:00:26 <mm_freak> jmcarthur: in haskell "TCO" is not really on "O"
20:00:28 <jmcarthur> i don't recall ghc's calling convention
20:00:29 <mm_freak> an
20:01:00 <wollw> Like this but this doesn't work: setImports ["Prelude ((+))"]
20:01:04 <mm_freak> the calling convention is the STG machine, where tail-calls are naturally jumps
20:01:18 * ski pasted "`map' without vs. with `match'" at <http://paste.lisp.org/display/130706>
20:01:22 <startling> that was in response to "it's very difficult to troll #haskell", fwiw
20:01:32 <jmcarthur> well, i knew that property of the stg, but wasn't sure whether ghc has evolved in that sense since the paper
20:01:37 <jmcarthur> startling: haha
20:01:38 <ski> carharttjimmy,monochrom : with and without pattern-matching in Scheme ^
20:01:45 <jmcarthur> startling: it's easy to *confuse* #haskell, though :)
20:01:50 <carharttjimmy> ahh ski
20:02:05 <Cale> It's hard to talk about tail call optimisation when you don't have a call stack
20:02:08 <mm_freak> startling: i know, and i wanted to prove my point =)
20:03:03 <pqmodn> startling: i've used some of the projects at https://github.com/bos as a reference about how to setup tests
20:03:11 <jmcarthur> we calmly talk trolls to death
20:03:18 <mm_freak> lol
20:03:51 <ski> carharttjimmy : you can see having separate `cond' and `let' (for `head' and `tail') is a bit awkward -- and it only gets worse with more complicated patterns
20:04:00 <mm_freak> @remember jmcarthur we calmly talk trolls to death
20:04:00 <lambdabot> Nice!
20:04:20 <carharttjimmy> how worse does it get ski ?
20:04:31 <ski> @quote troll
20:04:31 <lambdabot> Plugin `quote' failed with: getRandItem: empty list
20:04:48 <jmcarthur> :o
20:05:01 <parcs`> somebody should fix that
20:05:12 <jmcarthur> @quote fugue
20:05:12 <lambdabot> monochrom says: Welcome to #haskell, where your questions are answered in contrapuntal fugues.
20:05:15 <mm_freak> huh?  how did that happen?  off by one?
20:05:15 <ski> carharttjimmy : more or less as in other languages : deeply nested trees of `if's / `cond's which are hard to write (correctly) and hard to read (and refactor)
20:05:23 <mm_freak> @quote troll
20:05:24 <lambdabot> Plugin `quote' failed with: getRandItem: empty list
20:05:26 <jmcarthur> i think if it fails to find such a quote it does that
20:05:30 <carharttjimmy> ahh I see ski
20:05:35 <ski> hm
20:05:41 <ski> @quote troll.
20:05:41 <lambdabot> Dickie says: It's been a long troll. I bet you're all tuckered out.
20:05:58 <jmcarthur> woah, i know dickie. when the hell was he here?
20:06:00 <ski> @quote feed.trolls
20:06:00 <lambdabot> Cale says: Here [#haskell], we feed trolls until they explode.
20:06:06 <ski> was the quote i was thinking about :)
20:06:12 <pqmodn> @seen Dickie
20:06:12 <lambdabot> Unknown command, try @list
20:06:16 <pqmodn> @last Dickie
20:06:17 <lambdabot> No module "Dickie" loaded
20:06:28 <ski> preflex: xseen Dickie
20:06:28 <preflex>  Sorry, I haven't seen Dickie
20:06:30 <jmcarthur> preflex: seen Dickie
20:06:30 <preflex>  Sorry, I haven't seen Dickie
20:07:56 <mm_freak> @quote jmcarthur
20:07:57 <lambdabot> jmcarthur says: what good is a state monad if your state is basically "i have no idea what the hell my state is"?
20:08:11 <mm_freak> @quote mm_freak
20:08:11 <lambdabot> mm_freak says: ICANN HAS .cheeseburger?
20:08:22 <mm_freak> uh?  who told lambdabot about that one?
20:08:46 <pqmodn> he's like a little child, always learning
20:09:59 <aristid> @quote preflex
20:10:00 <lambdabot> preflex says: god was last seen on ##c++ 96 days, 6 hours, 19 minutes and 16 seconds ago, saying: I don't really know either actually
20:11:10 <carharttjimmy> when you said that pqmodn it made me remember about the IBM commercial with the little child
20:11:12 <mm_freak> i love the description of multiplate
20:11:22 <mm_freak> "Multiplate is an alternative extension of the Uniplate/Compos core library to support mutally recursive datatypes in a way that is as powerful as Compos, as easy to use as Biplate, and more portable than both of them. Multiplate does not require GADTs and does not require multi-parameter type classes. *** It only requires rank 3 polymorphism. ***"
20:12:41 <mm_freak> btw, i remember someone saying that type inference for rank <= 2 types is decidable…  is that true?
20:12:54 <mm_freak> because i can see no way how type inference can work /at all/ here
20:13:15 <pqmodn> well, yes it can be as long as other features don't interfere
20:13:26 <aristid> mm_freak: you highlighted the part where it "only" requires rank 3 polymorphism, but what seems even more remarkable to me is that the description fails to describe what it does without relying on the assumption that the reader knows uniplate, compos and biplate
20:14:15 <pqmodn> i don't have TAPL handy, but there's a reference to the proof about rank-2 inference being decideable
20:14:24 <mm_freak> pqmodn: f g x = g x
20:14:29 <mm_freak> what type would you infer for that?
20:14:56 <pqmodn> is it a trick? :)
20:15:05 <mm_freak> yes
20:15:14 <mm_freak> well, ok, type inference would come to a conclusion
20:15:19 <mm_freak> so it's probably decidable
20:15:36 <pqmodn> yeah, it might not be general enough
20:16:04 <aristid> :t \g x -> g x
20:16:06 <lambdabot> forall t t1. (t -> t1) -> t -> t1
20:16:18 <aristid> what would be the "fully general" type instead?
20:16:33 <mm_freak> aristid: that's the most general type, but it's rank 1
20:16:38 <pqmodn> you might have wanted (forall a. (forall b. a -> b) -> a -> b) i think
20:16:50 <mm_freak> i don't see how type inference could ever come to the conclusion that a higher rank type is needed
20:17:23 <mm_freak> except perhaps in this case:  f g x y = g (x :: Int) + g (y :: Integer)
20:17:38 <aristid> mm_freak: are higher-ranked types ever necessary if you have GADTs?
20:17:59 <mm_freak> aristid: yes
20:18:01 <aristid> :t \g x y -> g (x :: Int) + g (y :: Integer)
20:18:02 <lambdabot>     Couldn't match expected type `Integer' against inferred type `Int'
20:18:03 <lambdabot>       Expected type: Integer -> a
20:18:03 <lambdabot>       Inferred type: Int -> a
20:18:17 <mm_freak> aristid: either higher rank types or existential types
20:18:39 <mm_freak> they are the stuff that turns unsafe (IO/ADT) into safe (GADT)
20:18:48 <aristid> mm_freak: i thought GADTs can represent existential types?
20:19:05 <mm_freak> ok, if you view it that way, but you still need an extra type
20:19:32 <shachaf> Inferring existential types doesn't make much sense.
20:19:37 <shachaf> (To me.)
20:19:40 <mm_freak> that's my point
20:19:59 <mm_freak> aristid: either this:  getLine :: (forall n. Vec n Char -> IO b) -> IO b
20:20:13 <mm_freak> or this:  getLine :: IO (VecE Char)
20:20:21 <mm_freak> where VecE is an existential wrapper
20:20:32 <ski> shachaf : it might make sense to sometimes infer them in contravariant position, maybe
20:20:41 <shachaf> Wait, if you have an existential wrapper, that's different.
20:20:52 <shachaf> You have to use the wrapper explicitly in the definition.
20:21:03 <ski> shachaf : so that you get `length :: (exists a. [a]) -> Int', instead of `length :: forall a. [a] -> Int'
20:21:14 <mm_freak> shachaf: you're sounding like there is an alternative
20:21:27 * shachaf doesn't know what the context of this conversation is.
20:21:39 <shachaf> ski: I suppose, if you know how they're being used...
20:21:49 <mm_freak> shachaf: types =)
20:22:06 <carharttjimmy> http://users.cms.caltech.edu/~mvanier/hacking/rants/cars.html
20:22:08 <ski> shachaf : well, the idea here would be to just move the quantifier as much inward as possible
20:22:13 <carharttjimmy> read the haskell part
20:22:14 <carharttjimmy> lol
20:22:47 <shachaf> ski: I guess maybe existential-contravariant is a sensible combination in the same way universal-covariant is?
20:23:07 <ski> @type length *** length
20:23:08 <lambdabot> forall a a1. ([a], [a1]) -> (Int, Int)
20:23:08 <ski> @type join (***) length
20:23:09 <lambdabot> forall a. ([a], [a]) -> (Int, Int)
20:23:39 <shachaf> Because existential-covariant -- e.g. inferring an existential type of a top-level definition -- seems pretty strange to me.
20:23:56 <ski> shachaf : with `length :: (exists a. [a]) -> Int', i suspect the latter `join (***) length' could also get the former type `forall a b. ([a], [b]) -> (Int, Int)' (being equivalent to `(exists a. [a], exists b. [b]) -> (Int, Int)')
20:24:22 <shachaf> ski: Hmm...
20:24:33 <shachaf> That would certainly be nice.
20:25:20 <ski> shachaf : "Because existential-covariant -- e.g. inferring an existential type of a top-level definition -- seems pretty strange to me." -- yes, still it would be nice to be able to explicitly declare type signatures with `exists' occuring covariantly, and then not have to add any extra ascriptions to code in the body of the definition clause(s)
20:25:37 <shachaf> Right.
20:26:36 <shachaf> With an explicit signature you can specify e.g. which typeclasses you're including, which of course you can't infer.
20:26:45 * ski nods
20:27:54 <fuchsto> Can anyone (dmwit, you copy?) tell me what's the best way to implement a visual editor similar to dia in gtk(2hs)?
20:28:22 <ski> Mercury allows existential quantification covariantly in type signatures <http://www.mercurylang.org/information/doc-latest/mercury_ref/Existentially-typed-predicates-and-functions.html>
20:28:27 <fuchsto> I want to implement a visual editor for systems (connecting system inputs with system outputs etc.)
20:29:13 <fuchsto> I would ask in #gtk, but this channel is deserted.
20:29:17 <shachaf> fuchsto: Similarly to how Dia is implemented?
20:29:43 <fuchsto> shachaf: Quite. A visual system editor looks quite like a UML class diagram editor.
20:30:21 <shachaf> fuchsto: I mean, presumably the way you would implement a visual editor similar to dia would be similar to the way dia is implemented.
20:30:29 <shachaf> What with dia also being a GTK program.
20:30:31 <ski> this is e.g. used in `:- some [S] pred store.init(store(S)::uo) is det.' at <http://www.mercurylang.org/information/doc-latest/mercury_library/store.html> (being an analogue to `Control.Monad.ST' in Haskell) -- that signature translates more or less to `Store.init :: exists s. Store s' in Haskell terms
20:31:29 <fuchsto> shachaf: Dia is GTK, yes, but not really pretty. I'd use cairo (i don't know how dia is doing it)
20:31:39 <ski> where we can think of `ST' as being defined as `newtype ST s a = MkST (Store s -> (# a , Store s #))' (except that we need uniqueness types or modes (which Mercury has), to avoid copying the store)
20:35:21 <carharttjimmy> what could haskell be used for that puts it at least over c++ and java ?
20:38:50 <startling> carharttjimmy, parallelism
20:38:58 <carharttjimmy> hmm
20:39:07 <carharttjimmy> such as ?
20:39:32 <startling> carharttjimmy: stm is a great example: http://www.haskell.org/haskellwiki/Software_transactional_memory
20:39:54 <mm_freak> hmm…  the haskell car?  it's actually a car, but inside it you don't see the road…  to drive somewhere you create a parallel universe, where you travel on foot to the destination, take a picture and send it back to the primary universe…  the car then drives to that location and you can see yourself holding the camera
20:40:07 <mm_freak> (of course this is a reference to fix/mfix)
20:40:30 <carharttjimmy> the monadic version made me laugh
21:05:03 * hackagebot LDAP 0.6.7 - Haskell binding for C LDAP API (EdwardYang)
21:58:37 <mietek> I have a fresh HP 2012.2 installation on OS X 10.8, and a fresh cabal
21:58:51 <mietek> After installing yesod-platform, I see the yesod binary in /Users/mietek/Library/Haskell/ghc-7.4.1/lib/yesod-1.0.1.6/bin
21:59:01 <mietek> Any ideas why it's not linked to /Useres/mietek/Library/Haskell/bin ?
22:00:42 <carharttjimmy> well your first problem is that its OS X... anyways. Maybe thats how mac treats haskell ?
22:00:49 <carharttjimmy> well  ghc
22:00:51 <srhb> It shouldn't be.
22:01:40 <srhb> But the Haskell Platform tends to be very confused about whether to save things in ~/Library/Haskell or ~/.cabal on Mac
22:01:48 <srhb> mietek: Have you checked ~/.cabal ?
22:02:01 <mietek> srhb: yes, there's no ~/.cabal/bin any more
22:02:21 <mietek> Recently it's been using ~/Library/Haskell/bin, which is what I have in $PATH
22:02:37 <mietek> Does anyone else have yesod-platform installed?
22:02:42 <srhb> mietek: Awesome, well, I think this is what you get from being an early adopter, and I can offer no further insights. :P
22:02:43 <srhb> Yes.
22:03:09 <mietek> Well, I'm really not sure why would an incremental OS upgrade prevent a ln -s
22:03:12 <mietek> :)
22:03:18 <srhb> Me neither.
22:03:45 <srhb> But here we are.. :P
22:03:59 <mietek> So it did automatically link for you?
22:04:11 <srhb> Yes, it's in /.cabal/bin for me.
22:06:36 <mietek> OK
22:06:47 <mietek> Another thing: does cabal-dev work with HP 2012.2?
22:08:31 <srhb> mietek: I haven't tested it.
22:10:19 <carharttjimmy> there is one way to find out mietek test it
22:11:08 <mietek> $ cabal install cabal-dev
22:11:08 <mietek> HTTP-4000.2.3 (reinstall) changes: mtl-2.1.1 -> 2.0.1.0, network-2.3.0.13 -> 2.3.0.14, parsec-3.1.2 -> 3.1.3
22:11:11 <mietek> cabal: The following packages are likely to be broken by the reinstalls: haskell-platform-2012.2.0.0
22:11:25 <srhb> Fun fun.
22:13:48 <mietek> Ah, so it's just silly requirements on part of cabal-dev
22:13:49 <mietek> https://github.com/creswick/cabal-dev/pull/55/files
22:30:36 <edwardk> preflex: xseen roconnor
22:30:37 <preflex>  roconnor was last seen on freenode/#haskell 16 hours, 43 minutes and 36 seconds ago, saying: sorry mauke
22:31:27 <carharttjimmy> preflex: xseen vodik
22:31:28 <preflex>  vodik was last seen on freenode/#haskell 2 days, 3 hours, 5 minutes and 40 seconds ago, saying: what is the best way to convert a BinaryString to a Word of possibly differing size? I'm trying to parse some input, i get a length field (typically 32 or 1) denoting the length of following number. I can split this string into multiple ByteStrings but i'm at a loss on how to turn it into a number
22:33:27 <vodik> carharttjimmy: hi
22:34:38 <carharttjimmy> oh hi there, I never met you  before vodik. WHo are you ? ;)
22:35:00 <vodik> heh
22:35:11 <vodik> im nobody. carry on
22:35:23 <carharttjimmy> Haha, vodik why do you like haskell ?
22:35:36 * carharttjimmy knows vodik pretyy well btw
22:35:58 <edwardk> bah, there is no traverseByteString
22:36:07 <ski> Carry on people, nothing to see here.
22:36:22 <edwardk> i wanted the multilens to just be there out of the box
22:36:25 <ddarius> edwardk: USRP is working.
22:36:30 <edwardk> then i could avoid a dependency
22:36:35 <edwardk> score =)
22:37:23 <edwardk> i'm tempted to rename MultiLens to Traversal -- they seem more like the latter than the former
22:37:46 <edwardk> then MultiGetter would be a Fold
22:38:12 <ion> The similarity between “Traversal” and “Traverse” might be confusing. But yeah, something like Traversal does sound a bit better than MultiLens.
22:38:46 <edwardk> well, i've actually named all my multilenses traverseFoo ;)
22:38:47 <liyang> You should call it Trevor.
22:39:14 <carharttjimmy> you should call it Lars
22:39:15 <ion> edwardk: Sorry, i meant Traversal and Traversable
22:39:21 <edwardk> traverseLeft can be called and it works just like traverse on 'Either' but it works on the left hand side
22:39:26 <edwardk> yes, but i want that relationship
22:39:40 <edwardk> foldMapOf traverseLeft   -- is a foldMap over the left argument of an Either
22:40:08 <edwardk> foldMapOf (traverse . traverseTail)   etc.
22:40:16 <ion> Alright
22:40:19 <edwardk> er (traverseTail . traverse)
22:40:34 <edwardk> a Traversable is something with a default traverse ;)
22:41:03 <ion> Yeah, the name makes sense with them being related like that.
22:41:08 <edwardk> and traverse :: Traversable f => Traversal (f a) (f b) a b
22:42:23 <edwardk> i need to figure out if that should be a Traversal or a TraversalFamily though
22:42:28 <edwardk> the latter is uglier
22:42:35 <edwardk> but more consistent
22:43:12 <edwardk> traverseByteString :: Traversal ByteString Word8  -- would use the shorter name if TraversalFamily was introduced
22:43:36 <edwardk> and then you can use the combinators from Control.Lens to do things like
22:43:55 <edwardk> anyOf traverseByteString (=='c')
22:44:21 <edwardk> and it remains haskell 98 even though its a monomorphic container
22:44:47 <edwardk> well, its 98 + rank n, right now but thats the lens package, a lens98 package can be done that has the nice properties
22:44:59 <edwardk> of staying 98 while remaining compatible with lens, lens-family, etc.
22:45:54 <covi> :t anyOf
22:45:56 <lambdabot> Not in scope: `anyOf'
22:46:13 <liyang> (Not to be confused with Travis.)
22:46:32 <edwardk> covianyOf :: ((c -> Const Any d) -> a -> Const Any b) -> (c -> Bool) -> a -> Bool
22:46:42 <edwardk> anyOf l f = getAny . foldMapOf l (Any . f)
22:46:54 <edwardk> using
22:46:58 <edwardk> foldMapOf :: Monoid m => ((c -> Const m d) -> a -> Const m b) -> (c -> m) -> a -> m; foldMapOf l f = getConst . l (Const . f)
22:47:59 <edwardk> foldMapOf can walk into things that can only spit out those Const m's for some Monoid m, which correspond to Foldable things in general
22:50:12 <covi> edwardk: my brain explodes.
22:50:34 <edwardk> covi: =) its all about how the combinators fit together, the particular combinators are kinda odd looking
23:10:34 <ddarius> Attempting to listen to FM barely works (i.e. it essentially doesn't work) but then the antenna is meant for 850MHz - 6.5GHz and is directional, so anything at all is more than I should expect.
23:15:13 <ddarius> edwardk: The bandwidth possible seems to be 250MHz albeit the network can't handle that much data, so it would need to be preprocessed on the USRP to something more manageable.
23:15:27 <edwardk> hence the fpga i'd presume
23:15:41 <ddarius> Yes.
23:16:08 <ddarius> They also have plans for 10GBit ethernet models.
23:29:14 <mietek> Has anyone experienced their yesod site crashing with a SIGSEGV?
23:34:36 <covi> byorgey: any clue on your editorial for issue 19?
23:43:33 <plat0> How can I make a mirror of everything available through "cabal install"?  I don't want to actually serve the files to anyone else, just have a local copy on my machine.  Is hackage-mirror from the hackage-server package the way to go?
23:45:29 <donri> plat0: http://hackage.haskell.org/cgi-bin/hackage-scripts/archive.tar is a 250 mb archive of the latest sdists of all packages
23:46:02 <shachaf> "latest" /= «everything available through "cabal install"»
23:47:10 <plat0> 250 mb?  That seems rather small!
23:47:31 <plat0> I suppose I am looking for the latest version of everything.
23:47:42 <plat0> Anyway, I don't want to get caught short should Hackage be down.
23:47:51 <shachaf> plat0: I wouldn't be surprised if "the latest version of everything" isn't even sufficient to install everything.
23:47:58 <shachaf> Probably some latest-versions depend on older versions of other things.
23:48:04 <donri> yep
23:48:05 <shachaf> Does the .tar account for that?
23:48:07 <plat0> Hmm ok
23:48:16 <plat0> Well then
23:48:25 <plat0> I want *everything*!
23:48:33 <latro`a> that's...interesting, makes me think that if you really needed a LOT of packages you could easily get dependency hell
23:48:35 <plat0> Do people generally have their own local mirrors?
23:48:49 <donri> http://hdiff.luite.com/ tends to be up when hackage is down and i think mirrors everything or at least more than just latest
23:49:46 <plat0> How can I mirror everything myself?
23:50:14 <shachaf> plat0: You're not the first person to ask this.
23:50:22 <shachaf> I don't know that there was ever a really nice answer, though.
23:51:34 <plat0> Hmm that's a shame
23:51:36 <plat0> and surprising
23:52:17 <plat0> Surely the commercial companies that use Haskell do not depend on Hackage being up all the time
23:52:47 <shachaf> Last time Hackage was down someone inquired about making their own public mirror, for instance.
23:52:59 <srhb> Wasn't hackage2 supposed to have great mirroring support?
23:53:07 <srhb> Also, someone did host a mirror last time. PErhaps you can ask that person.
23:53:25 <plat0> Any ideas who?
23:54:19 <srhb> Trying to remember.
23:54:22 <TEttinger> I'm getting an odd error trying to build a (possibly outdated) Haskell program.
23:54:29 <TEttinger> Could not find module `Monad'
23:54:53 <latro`a> just...Monad?
23:54:56 <latro`a> not Control.Monad?
23:54:59 <shachaf> TEttinger: `Monad' was a module once?
23:55:03 <shachaf> TEttinger: Try Control.Monad, yes.
23:55:04 <TEttinger> ah ok
23:55:09 <TEttinger> and I get the same for IO
23:55:14 <latro`a> System.IO
23:55:14 <shachaf> Try System.IO
23:55:15 <TEttinger> is it Text.IO now?
23:55:17 <TEttinger> ok
23:55:23 <shachaf> TEttinger: By the way, you should give the full error message.
23:55:38 <shachaf> For example, if it says something like "It is a member of the hidden package `haskell98-2.0.0.1'.", that would be good to know. :-)
23:55:44 <TEttinger> shachaf, I didn't want to make someone go through pastebin, I figured it was a simple problem
23:55:55 <TEttinger> shachaf, yeah it did say that, ues
23:57:59 <edwardk> ok, i like the new lens names
23:58:09 <edwardk> traverse._2._1 :: (Applicative f, Traversable t) => (a -> f b) -> t (c, (a, c1)) -> f (t (c, (b, c1)))
23:58:32 <shachaf> _ prefix? :-(
23:58:40 <edwardk> yeah fstL and sndL were pretty awful
23:58:42 <ion> tettinger: How old is that program anyway?
23:58:54 <edwardk> i only did that to _1 and _2
23:59:00 <shachaf> edwardk: Maybe you should find a Unicode prefix for "lens".
23:59:12 <TEttinger> ion: it is the Write a Scheme in 48 Hours wikibook
23:59:13 <ion> edwardk: ITYM _0 and _1 ;-)
23:59:25 <edwardk> ion: i took the member names from scala =)
23:59:27 <shachaf> ⬭1
23:59:28 <TEttinger> http://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours/Building_a_REPL
23:59:40 <shachaf> ○1?
23:59:56 <shachaf> TEttinger: Ah. Someone should probably update that...
