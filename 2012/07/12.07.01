00:00:39 <zzing> solrize, would you be interested in taking a look at my final module once I put it together tomorrow?
00:00:59 <solrize> if i'm around
00:01:03 <napping> Has anyone used git packages?
00:01:22 <solrize> maximum [ft,fc]    =>     max ft fc
00:01:55 <solrize> i originally tried to do something a little too cute with listToMaybe or something
00:02:16 <mewalz> napping: I am very fond of git-data, but it is missing quite a bit of features
00:03:20 <napping> where is that?
00:03:30 <napping> I see git-object and git-date on hackage
00:03:59 <mewalz> its git-object, sorry
00:04:03 <zzing> Where does haddock put things it generates?
00:06:37 <mewalz> the source code to git-object is pretty; but it doesn't do much.
00:06:40 <zzing> oh nice, figured it out
00:06:46 <napping> do you know if it lets you create blobs and trees a low level, while benefiting from stuff like packs and deltas?
00:07:49 <napping> hmm, actually I expect to benefit most just from deduplicating blobs, can let git sweep them together later
00:08:44 <zzing> Is safehaskell something interesting or useful?
00:09:22 <solrize> the theory is it gives a java-like sandbox
00:10:09 <mewalz> napping: I doubt it
00:10:43 <napping> I think writing a fast-import producer is actually enough for me
00:10:59 <mewalz> check out the hit module
00:13:14 <napping> thanks, that might be useful
00:15:06 <startling> napping: "datastore"is very nice
00:15:08 <mewalz> Is it a bad idea to use maps when the worst-case scenario is 7 elements?
00:15:19 <mewalz> By maps I mean Data.Map
00:15:38 <startling> mewalz, what kinds of things are the keys?
00:15:52 <solrize> mewalz the conventional wisdom is get it to work first, then worry about optimization :)
00:15:57 <mewalz> calculating poker hands
00:18:18 <cads> hey guys,  a function  f ::  forall b. (a -> b) -> b  is for example,  f g = g a1, where a1 is a value in a. It uses a universal quantifier to represent a function that is apparently able to "do the right thing" with a large variety of types of functions.
00:18:34 <cads> though I'm not sure if it's valid haskell
00:18:53 <cads> the question is, what does it mean when we have an existential quantifier instead
00:19:22 <cads> I have http://hackage.haskell.org/trac/haskell-prime/wiki/ExistentialQuantifier
00:20:01 <cads> in that case, why wouldn't you just use the universal quantifier?\
00:21:53 <cads> hmm, apparently that example _can_ be translated to foralls, because the existential appears in 'contravariant' position
00:22:22 <cads> but this is not true when it appears in a covariant position
00:26:31 <cads> existential quantification seems like a way of saying "there's some type that will make the function work. But that's up to you to discover" :)
00:27:12 <shachaf> cads: No, you can't "discover" it.
00:27:33 <shachaf> You can't say "hmm, can I use Int here?" and be told "Yep! Here you go, now you can use this value".
00:28:32 <cads> indeed, so that's how it would work?
00:29:05 <napping> It would mean you could only use the result in code with the right foralls to say it doesn't depend on exactly what the type is - inside that code you might have a name like "a" for the type, which you might count as "discovering", but either way is almost always as close as you can get
00:37:54 <napping> shachaf: you could probably make an existential package that lets you ask after the type using GADTs or something
00:38:41 <shachaf> nappin: Or you can do something like Dynamic.
00:39:20 <napping> yeah, if all you want to do is box up a thing of unknown type, that's exactly Dynamic
00:42:44 <dmwit> ?where faq
00:42:44 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
00:44:31 <shachaf> dmwit: I'm not saying you should use Dynamic!
00:45:11 <dmwit> sorry, what
00:45:42 <dmwit> Oh, that query had nothing to do with the forgoing discussion.
00:46:16 <dmwit> I just thought the FAQ had an answer to http://stackoverflow.com/questions/11280294/pure-haskell-applications-free-and-available-for-download-or-websites on it, which I was going to link in the comments.
00:46:25 <dmwit> (It doesn't, though maybe it should.)
00:46:26 <shachaf> Ah.
00:46:37 <shachaf> And looking up "haskell faq" on Google doesn't find it. :-(
00:46:51 <dmwit> Right, that was my first attempt, too. =)
01:00:43 <tester> test
01:00:48 <tester> It's working!
01:01:07 <startling> tester: I'm not convinced
01:01:25 <ion> Your testing methods may not be sufficient.
01:02:05 <auastro> Hi all, I'm in a pickle, I'm trying to debug a segfaulting program with strange behaviour. It doesn't happen on linux, it only happens on mac os x with ghc 7.4.2 and only when using runghc. Also, icing on the cake is that it doesn't happen in the debugger and valgrind reports no invalid memory access.
01:02:30 <auastro> I'm at my whit's end on how to actually debug the darn thing
01:02:38 <napping> does valgrind actually report the segfault?
01:02:52 <yitz> @check (== "It's working!")
01:02:53 <lambdabot>   "Falsifiable, after 0 tests:\n\"\\678955\"\n"
01:03:07 <auastro> napping: no, but the process exits with status 11
01:03:07 <ion> Steve wants it to segfault.
01:03:14 <napping> also, what happens in ghci?
01:03:16 <startling> auastro: oh hai
01:03:31 <startling> auastro: are you using 64-bit on snow leopard or earlier?
01:03:32 <Axman6> solrize: it's definitely less tedious once you figure it out, the problem is figuring out the types. it's much more painful than it should be to work with signed/unsigned numbers and access ranger of bits
01:03:41 <auastro> startling: hello!
01:03:45 <napping> I've heard there are some wierd linker issues on OS X
01:03:53 <auastro> startling: on 64-bit lion
01:03:58 <startling> auastro: oh hm
01:04:18 <yitz> auastro: where is your ghc from?
01:04:22 <auastro> startling: I noe right!
01:04:44 <startling> auastro, how did you install it?
01:04:48 <auastro> yitz: new macports package for 7.4.2
01:05:17 <auastro> startling: yitz: so compiled from source linked against macports libs
01:05:19 <yitz> auastro: not sure how well maintained the macports package is these days
01:05:33 <shachaf> @check \x -> ((==)1 .1) x
01:05:36 <lambdabot>   "OK, passed 500 tests."
01:05:44 <yitz> auastro: though if there's a "new" one, as you say, that is actually a good sign that things are improving
01:05:49 <auastro> yitz: I am the maintainer
01:05:59 <yitz> auastro: ahh. well, that's great news!
01:06:11 <yitz> auastro: is this a 64-bit build of ghc?
01:06:20 <auastro> yitz: well I will be, trying to iron out the last few weirdnesses
01:06:20 <yitz> preflex: xseen mzero
01:06:20 <preflex>  mzero was last seen on freenode/#haskell 6 days, 7 hours, 19 minutes and 44 seconds ago, saying: if you turn on -Wall when you compile, then GHC will helpfully tell you when you've missed a case
01:06:49 <startling> auastro, homebrew's recipe seems to work flawlessly. maybe you could crib some details from there?
01:07:26 <yitz> auastro: i'm a macports user. truth is, i'm pretty much sold on using the haskell platform installer, but it would be great if there were a working macports build.
01:07:42 <yitz> startling: pretty sure that's a 32-bit build.
01:07:49 <startling> yitz: not by default
01:08:03 <startling> yitz: i know for sure, since I had problems until I switched to 32-bit. :)
01:08:05 <yitz> auastro: mzero is the expert on mac builds, you should definitely be in contact with him if you are doing this.
01:08:12 <startling> (on snow leopard)
01:08:13 <auastro> startling: thanks, I'll have a look, but this problem I'm trying to debug I know happened on the homebrew release as well
01:08:36 <startling> auastro: ouch
01:08:55 <auastro> startling: it's in yesod
01:09:15 <yitz> auastro: yesod? what does that have to do with this?
01:09:22 <auastro> startling: the scaffold project just segfaults, which is sad, because it is the package I really want to use right now
01:09:55 <auastro> yitz: thanks heaps, I definitely will try and get in contact with mzero, I'll need all the help I can get.
01:11:27 <yitz> auastro: scaffold project?
01:11:47 <auastro> yitz: the one that gets created when you run yesod init
01:11:54 <yitz> oh
01:12:13 <auastro> startling, yitz: If you have the opportunity could you please test the new macports ghc package https://trac.macports.org/ticket/25558
01:12:33 <auastro> startling, yitz: your feedback is greatly appreciated
01:12:34 <greg> when i run ghc im getting cannot find the module Prelude ,but ghci works fine, any ideas?
01:13:10 <yitz> auastro: yesod has a giant boatload of dependencies. there are so many moving parts that can break, even when you are using a tried and true ghc build. so it would be a good idea to try to narrow down exactly what is breaking.
01:13:20 <auastro> greg: I guess make sure you don't have any NoImplicitPrelude activated anywhere
01:13:42 <greg> how do i do that?
01:14:07 <yitz> auastro: warning: like startling, i'm also on snow leopard. still useful for you?
01:14:13 <hpaste> austro pasted “Yesod segfault” at http://hpaste.org/70666
01:14:18 <auastro> yitz: I have narrowed it down to this small program.
01:14:49 <auastro> greg: there are lots of ways ghc extensions can be activated, one way is through your cabal file.
01:15:16 <greg> cool will research, thanks
01:15:30 <auastro> yitz, startling: especially so, I would love to know that the package also builds for snow leopard users
01:15:44 <yitz> auastro: that's still using a lot of machinery. can you get it to segfault without using TH?
01:15:47 <auastro> greg: hope that helps
01:16:16 <greg> me too :), thanks
01:18:09 <auastro> yitz: hmm, it's possible, I'll look into it
01:18:34 <auastro> yitz: I think most of those are necessary for yesod to work
01:19:10 <auastro> sorry guys will have to go, when is a good time to catch mzero
01:20:30 <yitz> auastro: yes. that's why a yesod crash isn't very useful for tracking down a problem with a ghc build until you drill down to a specific component of yesod.
01:21:07 <yitz> auastro: mzero works at google in mtn view, california. sometimes seen working late at night on his clock though.
01:21:51 <auastro> yitz: I don't even know if the bug is in GHC or Yesod
01:21:55 <yitz> right
01:22:29 <auastro> sorry really have to go, will talk soon hopefully
01:22:35 <yitz> auastro: so maybe also post to the web-devel list, or try #yesod, maybe they can help figure that out
01:32:42 * hackagebot keter 0.1.0.1 - Web application deployment manager, focusing on Haskell web frameworks  http://hackage.haskell.org/package/keter-0.1.0.1 (MichaelSnoyman)
01:32:44 * hackagebot dtd 0.6.0 - Parse and render DTD files  http://hackage.haskell.org/package/dtd-0.6.0 (MichaelSnoyman)
01:37:46 * hackagebot stylish-haskell 0.3.1.0 - Haskell code prettifier  http://hackage.haskell.org/package/stylish-haskell-0.3.1.0 (JasperVanDerJeugt)
01:37:48 * hackagebot html-conduit 0.1.0 - Parse HTML documents using xml-conduit datatypes.  http://hackage.haskell.org/package/html-conduit-0.1.0 (MichaelSnoyman)
01:37:50 * hackagebot uri-conduit 0.5.0 - Read and write URIs  http://hackage.haskell.org/package/uri-conduit-0.5.0 (MichaelSnoyman)
01:37:52 * hackagebot xml-catalog 0.8.0 - Parse XML catalog files  http://hackage.haskell.org/package/xml-catalog-0.8.0 (MichaelSnoyman)
01:37:54 * hackagebot xml-conduit 1.0.0 - Pure-Haskell utilities for dealing with XML with the conduit package.  http://hackage.haskell.org/package/xml-conduit-1.0.0 (MichaelSnoyman)
01:42:56 * hackagebot xml-hamlet 0.4.0 - Hamlet-style quasiquoter for XML content  http://hackage.haskell.org/package/xml-hamlet-0.4.0 (MichaelSnoyman)
02:09:21 <MostAwesomeDude> Huh, he's been busy.
02:17:44 * hackagebot xml-conduit 1.0.1 - Pure-Haskell utilities for dealing with XML with the conduit package.  http://hackage.haskell.org/package/xml-conduit-1.0.1 (MichaelSnoyman)
02:44:58 <DexterLB> how do I convert [IO a] to (IO [a])?
02:45:19 <mekeor> DexterLB: sequence, i think
02:45:23 <mekeor> :t sequence
02:45:25 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
02:45:31 <mekeor> hah! i'm good!
02:45:42 <DexterLB> yes you are :)
02:45:43 <DexterLB> ty
02:45:51 <mekeor> yw :)
02:46:22 <fmap> @type Data.Traversable.sequenceA
02:46:24 <lambdabot> forall (t :: * -> *) (f :: * -> *) a. (Data.Traversable.Traversable t, Applicative f) => t (f a) -> f (t a)
02:47:14 <shirt> is the future cabal-dev or virthualenv?
02:51:32 <dncr> @pl \ (a1, b1) (a2, b2) -> (mplus a1 a2, mplus b1 b2)
02:51:33 <lambdabot> uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . (. mplus) . flip . (((.) . (,)) .) . mplus)
02:52:02 <barrucadu> o.O
02:53:05 <mekeor> dncr: just for your information, by the way, you can also write lambdabot a private message like "/msg lambdabot @pl …" ;) :) =)
02:53:29 <barrucadu> Sometimes pl finds nice little combinators that are nicer than the original pointful function. I find this doesn't happen often…
02:54:02 <dncr> mekeor: i already ran it locally.  i ran it here to see if anyone would have a good idea about a better way to do it
02:54:36 <fmap> > (1,2) + (3,4)
02:54:37 <lambdabot>   (4,6)
02:54:52 <mekeor> dncr: ah. an explicit question would have been appreciated then ;) :) =) :D =D
02:55:47 <shachaf> @ty join (***) mplus
02:55:49 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => (m a, m a) -> (m a -> m a, m a -> m a)
02:55:59 <shachaf> Hmm, not that.
02:56:07 <shachaf> Oh, right, it's this annoying thing.
02:57:38 <dncr> that works for unary
02:58:28 <shachaf> Right.
03:01:28 <dncr> mekeor: we speak in code because we think in dreams :)
03:05:50 <mekeor> dncr: oO
03:07:31 <jellybaby1> @pl c v fv = ins v $ fv 7
03:07:32 <lambdabot> c = (. ($ 7)) . ins
03:09:26 <DexterLB> is it any good to use Data.Text for a Data.Map key, or should I use String instead?
03:09:57 <shirt> DexterLB: it's good
03:09:58 <opqdonut> should be ok
03:11:24 <shachaf> If you're doing it for efficiency, keep in mind that Strings are sometimes more efficient than Texts when they're small.
03:15:52 <MostAwesomeDude> I'm doing networking with conduits. I need to have all connected clients all grab into a central pool of state somehow. What's the best pattern for this?
03:16:25 <MostAwesomeDude> I was planning on just having them all frob a single MVar which a central thread is watching. Upon frob, the threads see each other and grab references, and then they can communicate.
03:16:59 <MostAwesomeDude> Or are STM channels a better tool for this?
03:18:59 <ski> dncr : do you need the two `mplus' calls to (possibly) operate on two different types ?
03:19:12 <dncr> ski: i do not
03:19:23 <MostAwesomeDude> Oh, TArray is a thing. Maybe that's what I want.
03:21:35 <nand`> “05     rwbarton │ nand?” <- were you talking to me, or referencing the logical NAND?
03:21:35 <nand`> I'm guessing the latter but it's not entirely clear from context
03:22:39 <hc_> any way to do [7 .. 0] and not get an empty list?
03:22:45 <nand`> [7, 6, .. 0]
03:22:49 <hc> thanks
03:22:54 <MostAwesomeDude> > [7, 6..0]
03:22:55 <lambdabot>   [7,6,5,4,3,2,1,0]
03:23:40 <nand`> > succ maxBound :: Int
03:23:41 <lambdabot>   *Exception: Prelude.Enum.succ{Int}: tried to take `succ' of maxBound
03:23:50 <ski> dncr : i think you could define `newtype DoubleT f a = MkDT {runDT :: (f a,f a)}' with `instance Monad m => Monad (DoubleT m)',`instance MonadPlus m => MonadPlus (DoubleT m)',`instance MonadTrans DoubleT'
03:24:28 <ski> dncr : possibly `instance Applicative i => Applicative (DoubleT i)',`instance Alternative i => Alternative (DoubleT i)' would be nicer in your case, though ..
03:24:41 <dncr> mm
03:25:21 <dncr> so this is a different way of making (,) a Monad eh?
03:26:04 <DexterLB> hmm, I'm trying to use Data.ConfigFile, but using readfile as described in the docs throws an exception that there is no instance for Control.Monad.Error.Class.MonadError CPError m0
03:26:42 <DexterLB> I'm just doing this: c <- readfile emptyCP "foo.conf"
03:26:56 <nand`> dncr: different? as opposed to?
03:27:04 <nand`> you mean Monoid i => (,) i ?
03:27:41 <shachaf> dncr: That's not really making (,) a monad.
03:27:43 <dncr> oh
03:28:14 <dncr> i thought (,) had an instance.  nm
03:28:21 <nand`> (,) itself can't have an instance
03:28:24 <nand`> wrong kind
03:28:47 <nand`> hmm
03:29:38 <nand`> newtype Join g a = Join { runJoin :: g a a }
03:30:03 <nand`> type DoubleT f a = Join (,) (f a)
03:30:25 <nand`> though a type synonym would probably not be the best thing to use here
03:33:16 <dncr> ok i learned a lot here, thanks
03:35:11 <yitz> > maxBound + 1 :: Int -- interesting nand`, i never noticed that difference
03:35:12 <lambdabot>   -9223372036854775808
03:38:21 <ksf> Int is the least-defined type in Haskell.
03:38:39 <ksf> it's a field of 31-infinity bits.
03:44:12 <dncr> and it's signed
03:44:48 <dncr> why didn't they go w/ >= _32_ bits?
03:46:24 <shachaf> Isn't it 29?
03:46:28 <shachaf> To allow for the possibility of a tag bits, presumably.
03:46:48 <shachaf> "The finite-precision integer type Int covers at least the range [-2^29, 2^29 - 1]."
03:47:52 <dncr> ok so it's >= 30 bits.  2 tag bits
03:48:24 <shachaf> But not in GHC.
04:06:17 <hpaste> mekeor pasted “why do type synonyms in GADT-syntax as return set not work?” at http://hpaste.org/70669
04:06:40 <mekeor> i get "Data constructor `WithYear' returns type `With t Year WithYear' instead of an instance of its parent type `WithYear'" with that code.
04:07:26 <mekeor> why?
04:14:03 <DexterLB> how do I make an infinite list with identical elements?
04:14:28 <mekeor> repeat
04:14:31 <mekeor> > repeat 5
04:14:33 <lambdabot>   [5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,...
04:14:38 <DexterLB> sweet
04:14:39 <mekeor> DexterLB: i'm good!
04:14:45 <mekeor> yay! :)
04:15:15 <Bynbo7> > replicate maxBound 1 == repeat 1
04:15:19 <lambdabot>   mueval-core: Time limit exceeded
04:16:48 <mekeor> (replicate maxBound 1 == repeat 1) is False. Just like this:
04:16:58 <mekeor> > [1,1,1] == repeat 1
04:16:59 <lambdabot>   False
04:17:28 <Axman6> mekeor: sure, I was curious whether it would fir in the time limit or not =)
04:17:29 <shachaf> What are the Bounded laws?
04:17:55 * hackagebot protocol-buffers 2.0.10 - Parse Google Protocol Buffer specifications  http://hackage.haskell.org/package/protocol-buffers-2.0.10 (ChrisKuklewicz)
04:17:57 * hackagebot protocol-buffers-descriptor 2.0.10 - Text.DescriptorProto.Options and code generated from the Google Protocol Buffer specification  http://hackage.haskell.org/package/protocol-buffers-descriptor-2.0.10 (ChrisKuklewicz)
04:17:59 * hackagebot hprotoc 2.0.10 - Parse Google Protocol Buffer specifications  http://hackage.haskell.org/package/hprotoc-2.0.10 (ChrisKuklewicz)
04:19:42 <fmap> > [5,5..]
04:19:44 <lambdabot>   [5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,...
04:20:06 <mcstar> can i ask someone one question on formal logic?
04:20:23 <Axman6> don't ask to ask, just ask
04:20:39 <mcstar> yeah, but its not haskell thats why i asked
04:20:43 <DexterLB> Axman6: you got that line on a macro don't you
04:20:57 <Axman6> no, just typed it many many times =)
04:20:59 <shachaf> mcstar: Better to ask it anyway.
04:21:12 <shachaf> mcstar: Otherwise it's *double* the trouble, because people have to respond to you at any rate.
04:21:32 <mcstar> im reading a paper written by John Harrison for the AMS
04:22:08 <mcstar> he is into formal verification and automated proofing
04:22:18 <mcstar> and theres an example i dont understand
04:22:34 <mcstar> it supposed to be a 'mechanical transformation' of a logical statement intoa another
04:22:39 <mcstar> let me write it up
04:22:54 <shirt> let f = id (unsafePerformIO (putStrLn "hello" >> return 1))
04:23:07 <shirt> f only prints "hello" the first time. how do i get it to always print "hello" ?
04:24:00 <mcstar> (E x . P(x)) => q transforms to (A x.(P(x) => q))
04:24:12 <mcstar> E exists, A forall
04:24:46 <shachaf> shirt: Generally you don't.
04:25:18 <mcstar> so i dont understand why this would be the case, if i change E to A in the first statement, id make sense to me
04:27:08 <shachaf> mcstar: If "there exists a llama that is red" implies "I speak Norwegian", then for all llamas L, if L is red, I speak Norwegian.
04:28:03 <Axman6> shirt: maybe not the answer you're after, but look at Debut.Trace.trace for the standard way to do what you're doing
04:28:38 <mcstar> shachaf: makes sense
04:29:27 <mcstar> it is my lack of experience with these statements that led me astray
04:29:42 <mcstar> for all X, when P(x) is true also q
04:29:50 <shirt> shacha, Axman6: I'm curious how the compiler knows how to do this. if i add a dummy argument to f, then "hello" is printed every time
04:30:13 <shachaf> shirt: Read about "graph reduction".
04:31:07 <shachaf> (Or "lazy evaluation", as contrasted with "non-strict semantics".)
04:31:30 <mcstar> shachaf: (E x . P(x)) this seems to me, that it would always be true
04:31:56 <shachaf> mcstar: "there exists a llama such that that llama is red" is always true?
04:32:08 <mcstar> when you put it that way..
04:32:10 <mcstar> no
04:32:15 <Axman6> Otherwise known as the llama lemma
04:32:23 <Axman6> >_>
04:32:54 <mcstar> if exists x such that P(x) is true, so is q
04:36:22 <mcstar> so every expression that is not constant/atomic can have any truth value
04:36:32 <mcstar> it makes sense just needs getting used t
04:36:35 <mcstar> o
04:36:40 <mcstar> shachaf: thanks
04:48:44 <Penetrator> @pl \y -> \z -> return y:z
04:48:45 <lambdabot> (:) . return
04:48:55 <Penetrator> @pl \z -> return y:z
04:48:55 <lambdabot> (return y :)
04:51:27 <Penetrator> @pl m (x:xs) f = b (\y -> b (u y:) (m xs f)) (x f)
04:51:28 <lambdabot> m = fix ((`ap` tail) . (. head) . flip . (liftM2 (b . flip (b . (:) . u)) .))
04:51:40 <Penetrator> whoa
04:53:07 <shachaf> @ty let m (x:xs) f = b (\y -> b (u y:) (m xs f)) (x f) in m
04:53:09 <lambdabot>     Couldn't match expected type `t -> a' against inferred type `Expr'
04:53:09 <lambdabot>     In the first argument of `(:)', namely `u y'
04:53:09 <lambdabot>     In the first argument of `b', namely `(u y :)'
04:58:56 <DexterLB> is there a way to make read for my type be case-insensitive without explicitly defining a Read instance and all the functions in it?
05:00:17 <mcstar> shachaf: (a => b) is true, when a=false, b=true; but why would the implication be true, imho we can only say that 'b' can be true even if 'a' is false, why does this have relevance to implication?
05:05:43 <shachaf> This probably indeed isn't the channel for an extended introduction to logic. :-)
05:05:46 <shachaf> Think of it as a promise, though.
05:05:49 <shachaf> "I promise that if X, then Y"
05:05:51 <shachaf> If X is true and Y is true, I didn't break my promise. If X is true and Y is false, I did break my promise.
05:05:55 <shachaf> If X is false, though, then no matter what happens, I didn't break my promise.
05:07:55 <Penetrator> @pl \z -> u (y:z)
05:07:55 <lambdabot> u . (y :)
05:08:12 <mcstar> shachaf: interesting angle, thanks
05:25:19 <ski> <ski> dncr : maybe using `MkDT' and `runDT' would be too much of syntactic noise in your case, i dunno
05:25:25 <ski> <ski> hehe, i was just thinking about `newtype Double a = MkD {unD :: (a,a)}',`type DoubleT = Compose Double'
05:25:29 <ski> > succ ()
05:25:30 <lambdabot>   *Exception: Prelude.Enum.().succ: bad argument
05:25:42 <ski> <ski> mcstar : also compare with anaphora like "If there exists a llama that is red, then I feed it."
05:26:18 <ski> @tell dncr "<dncr> so this is a different way of making (,) a Monad eh?" -- no. the existing one is `forall w. Monoid w => Monad (w,)', the basic idea we're talking about here is essentially `Monad (\a -> (a,a))', though we made it into a transformer : `forall m. Monad m => Monad (\a -> (m a,m a))', where `\a -> (m a,m a)' was spelled `DoubleT m'
05:26:19 <lambdabot> Consider it noted.
05:26:26 <ski> mcstar : also add "If Y is true, though, then no matter what happens to X, I didn't break my promise."
05:26:30 <ski> DexterLB : don't make `Read' case-insensitive. better to define your own reader/parser
05:28:40 <mcstar> anaphora: it refers to the llama, i had to look it up
05:29:12 <toki78> hi
05:29:19 <ski>    lo
05:29:23 <mcstar> ski: thanks for the input
05:29:34 <ski> yw
05:29:35 <mcstar> but i'd really love to exchange lama for llama
05:29:46 <mcstar> :)
05:29:51 <ski> what !?
05:29:51 <toki78> I created a video of a Reinforment Learning agent with a neural net. Wanna see it ?
05:30:05 <mcstar> a lama still can be red, and fed, cant it?
05:30:23 <mcstar> and easier to say it in my mind
05:31:45 <mcstar> ah, they are pronounced the same way :(
05:34:31 <toki78> http://www.youtube.com/watch?v=-3aap4H1gnw
05:37:35 <mcstar> that ball moves too fast, i cant follow it
05:40:12 <toki78> you must wait for 2 minutes. it is in training mode before
05:42:34 <mcstar> probably written in java ^^
05:44:21 <mcstar> shachaf: am i correct to draw an analogy between forall and lambda?
05:44:50 <mcstar> they can both be interpreted as introducing bound variables?
05:46:13 <hiptobecubic> Distribution.Simple.Command  or  System.Console.ParseArgs ?
05:48:35 <nand`> Is there a Haskell interface to WolfamAlpha (eg. like the OEIS interface)?
05:48:37 <mcstar> thats an xor right?
05:49:08 <hiptobecubic> nand`, does WA even allow that?
05:49:10 <shachaf> chee1: There's some analogy there, yes.
05:49:18 <shachaf> Er, mcstar:
05:49:25 <shachaf> @google mainisusuallyafunction forall
05:49:27 <lambdabot> http://mainisusuallyafunction.blogspot.com/2010/10/quantification-in-haskell.html
05:49:52 <mcstar> k
05:50:40 <mcstar> WA offers its services as pay per use, so there must be some api
05:53:20 <nand`> hiptobecubic: not sure if you got me earlier message, but I think WolframAlpha allows you to do so as long as you send less than 2000 requests per month; above that, it you have to pay
05:53:42 <hiptobecubic> ah
05:55:00 <hiptobecubic> nand`, well i'll guess "no"
05:55:38 <nand`> hiptobecubic: my earlier message was “I'm not sure, but I've seen some bots provide WolframAlpha interfaces before. I was interested in maybe adding one to lambdabot”
06:00:17 <nand`> hiptobecubic: and I'm not sure if you got the message I sent just now. I'll give up on trying to communicate for now, my connection is dropping every 30 seconds or so
06:03:16 <ski> mcstar : fyi : <http://www.zimmers.net/anonftp/pub/cbm/c64/games/Llamasoft/index.html>,<http://en.wikipedia.org/wiki/Jeff_Minter>,<http://www.lemon64.com/games/list.php?type=publisher&name=Llamasoft>
06:05:30 <mcstar> sick joke
06:07:10 <ski> nand` : "am i correct to draw an analogy between forall and lambda?","they can both be interpreted as introducing bound variables?" -- yes, though generally speaking many other things could bind variables (such as existential quantifier, sum & product & integral notation, Leibniz derivative notation)
06:09:03 <mcstar> those last ones arent considered fundamental afaik
06:10:15 <bitonic> nand`: lambda is a special case of `forall' in Type Theory, in type signatures
06:10:23 <mcstar> and the existential quantifier sort of selects something, from many, a bit disparate from lambda, doesnt it?
06:11:11 <bitonic> nand`: if you mean lambda to actually write the function body, then that lambda and the `forall' in the type signature work on different levels
06:11:13 <mcstar> and pls, stop abusing poor nand`
06:12:28 <mcstar> bitonic: i understand that, the forall we were discussing is not the type level forall, but the general, formal logic one
06:13:07 <bitonic> mcstar: well but nand` was talking about `lambda', which is not present in classical logic
06:14:00 <mcstar> yes ok, but i dont think you mean me
06:14:01 <ski> nand` : however, in System F, a value of type e.g. `forall a :: *. a -> a' could be `/\(a :: *) -> \(x :: a) -> x', and an application of such a value (call it `id') could be `id [Bool] False', where `id [Bool]' denotes "type application", passing a type as an argument to a term
06:14:06 <mcstar> damn
06:14:11 <mcstar> i think you mean me
06:14:14 <mcstar> not nand
06:14:18 <ski> er, so i do
06:14:32 <ski> hm, no, i meant to send it to nand`
06:14:42 <ksf> does mapM need a Monad, strictly, or does an applicative functor always suffice?
06:15:14 <mcstar> :t mapM
06:15:16 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
06:15:20 <ski> bitonic : "lambda is a special case of `forall' in Type Theory" -- incorrect
06:15:46 <fmap> @type Data.Traversable.mapM
06:15:48 <lambdabot> forall a (m :: * -> *) b (t :: * -> *). (Data.Traversable.Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)
06:16:09 <ksf> ...I ask because my categorical Traversable (in the spirit of control.categorical.functor) works exactly the same for both.
06:16:14 <ksf> same definitions, same everything.
06:16:21 <bitonic> ski: how so?
06:16:29 <ski> @type Data.Traversable.traverse  -- ksf
06:16:30 <lambdabot> forall a (f :: * -> *) b (t :: * -> *). (Data.Traversable.Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
06:16:32 <bitonic> @where TTFP
06:16:33 <lambdabot> http://www.cs.kent.ac.uk/people/staff/sjt/TTFP/
06:16:53 <ksf> ski, looks the same, doesn't it?
06:17:07 <ski> ksf : except s/Monad/Applicative/
06:17:22 <Peaker> I dislike Foldable, and Traversable wants Foldable :(
06:18:00 <ski> bitonic : in types, `(forall a. List a -> List a) :: *', while `(\a -> (List a -> List a)) :: * -> *'
06:18:21 <teneen> I'm in the process of writing my first haskell package. How should I compile all the modules in the appropriate folders together?
06:18:35 <ski> bitonic : a value of the former type could be `/\a -> \(xs :: List a) -> id [List a] xs'
06:18:51 <ksf> well, another hint is that mapM's default implementation just threads the monad through an applicative newtype.
06:19:05 <Clint> teneen: cabal build
06:20:02 <ski> bitonic : maybe what you were thinking of is that `forall a. ..a..' can be encoded as `Pi (\a -> ..a..)' (with `Pi :: (* -> *) -> *') ?
06:20:31 <bitonic> ski: yes, with "universal quantification in TT" I was talking about Pi
06:20:59 <bitonic> and in TTFP he defines `lambda' in types as sugar for that
06:21:02 <bitonic> anyway, gotta go
06:21:45 <ski> bitonic : in any case, the type `forall a. ..a..' and the type `\a -> ..a..' are very different. the former is a concrete type (the type of a polymorphic value; in System F, the type of a type-accepting function) , the latter a type function (not the type of a function or the type of a polymorphic value)
06:23:22 <ski> bitonic : maybe TTFP defines `lambda a. ..a..' in types as shorthand for `Pi (\a -> ..a..)', but i still would think that is misleading (it bars us from using the real lambda in types, using that notation)
06:23:28 <teneen> What should the contents of Setup.hs be?
06:33:07 <DexterLB> can I pattern match against Text?
06:37:03 <Axman6> i don't believe so
06:38:44 <ClaudiusMaximus> teneen: tried cabal init?
06:40:28 <DexterLB> is there a better way to count the number of particular elements in a list than using length and filter?
06:43:24 <Peaker> DexterLB, I don't think anyone defined count p = length . filter p
06:43:53 <ClaudiusMaximus> length and filter is fine  (unless you need to do other things with the list and want to do them all in one pass over it)
06:44:51 <mcstar> ClaudiusMaximus: the fractal you uploaded was different from the gif
06:45:00 <DexterLB> I came up with count p = sum . map (fromEnum (== p))
06:45:27 <mcstar> length . filter p us much better
06:45:32 <mcstar> us->is
06:45:39 <Peaker> yeah
06:46:10 <mcstar> ClaudiusMaximus: thought i cant remember it now, but looked good
06:46:15 <mcstar> though*
06:46:27 <ClaudiusMaximus> mcstar: yeah, i get impatient/bored easily - i remember the gif, but i don't remember the one i sent
06:46:34 <mcstar> :)
06:46:37 <ClaudiusMaximus> :)
06:50:01 <dgpratt> I'm guessing that the odds of getting the BerkeleyDB package to build on my machine are somewhere between slim and none, but I'm not quite ready to give up, yet
06:51:54 <dgpratt> the first thing I determined was that the package was looking for just 'db' (or some variation) when it appeared that it needed to look for 'db48'
06:52:43 <dgpratt> but having fixed that, I'm still getting a build error
06:52:57 <dgpratt> build error: http://hpaste.org/70672
06:53:10 <dgpratt> conflicting types for 'ssize_t'
06:53:30 <dgpratt> a C programmer I am not, so I'm not sure where to go with this
06:53:37 <dgpratt> ideas?
06:53:37 <mcstar> DexterLB: anyway, (fromEnum (== p)) needs to be (fromEnum . (== p))
06:54:42 <Peaker> dgpratt, what are you building bdb for?
06:54:51 <dgpratt> also, I have a notion that this error may have something to do with the fact that I am building this on a Windows 7 64-bit machine
06:55:07 <Peaker> dgpratt, The BerkeleyDB package needs the C lib version 4.7 or 4.8 and not newer, iirc
06:55:55 <dgpratt> Peaker: strictly 4.8 or older? i.e. 4.8.3 not acceptable?
06:56:39 <mcstar> 4.8.X is ok, from the site i think, for example it is needed for that structural editor
06:56:50 <mcstar> it was mentioned some time ago
06:57:20 <dgpratt> mcstar: yep, that was where I started
06:57:22 <Peaker> mcstar, yeah, my bottle project :)
06:57:31 <Peaker> (mine and yairchu's that is)
06:57:47 <dgpratt> Peaker: oh, that was yours! heh, yeah, that
06:57:49 <nand`> ski: bitonic: wait what, what's this about ‘forall’, ‘lambda’ ‘System F’? What was this a reply to?
06:58:12 <mcstar> nand`: they were talking to me, but for some reason kept using your nick
06:58:25 <nand`> I see
06:59:35 <dgpratt> well, as you can see from the error message, I have 4.8.3 installed, but it doesn't work (modulo the possibility that I configured something incorrectly)
07:00:11 <Peaker> I guess someone ought to modernize the BerkeleyDB bindings
07:00:18 <Peaker> or I ought to find a different key/value store
07:00:40 <ski> nand` : sorry, i got the nicks confused in all the reconnects
07:00:55 <nand`> ski: I see
07:00:56 <dgpratt> Peaker: although that is probably true, I don't think the bindings are the only issue in this case
07:01:15 <nand`> ski: my network should be stable now, I hope. I haven't gotten disconnected for the past 5 minutes
07:01:23 * ski neither
07:01:24 <teneen> ClaudiusMaximus: What does cabal init do?
07:01:49 <teneen> How can I interpret some files in a cabal project using ghci? it always complains about wrong imports?
07:02:12 <dgpratt> Peaker: there appears to be some sort of conflict between the mingw environment and the berkeleydb headers
07:03:17 * hackagebot palindromes 0.3 - Finding palindromes in strings  http://hackage.haskell.org/package/palindromes-0.3 (JohanJeuring)
07:04:29 <Peaker> redis requires a separate daemon, right?
07:06:12 <cesip> is anyone familiar with thompson's book or working through it at the moment=
07:06:13 <cesip> ?
07:08:18 <Peaker> HongoDB seems like a temporary alternative I could use
07:09:14 <ClaudiusMaximus> teneen: it creates a .cabal file, LICENSE and Setup.hs by asking you some questions and looking at your sources
07:09:57 <Peaker> ooh, KyotoCabinet seems nice
07:11:55 <Peaker> doh, kyotocabinet depends on a C lib that's not even available in the Ubuntu repos
07:12:36 <teneen> ClaudiusMaximus: thanks :)
07:13:22 <teneen> In cabal does a module X.Y.Z have to be in foldr X/Y, or is it just a convention?
07:15:15 <Peaker> teneen, in GHC it's required, Haskell report doesn't say much about it
07:20:45 <Peaker> oh, cute! http://hackage.haskell.org/packages/archive/htrace/0.1/doc/html/Debug-HTrace.html
07:21:33 <haskellguy> hi there guys. can you give me advice, how do I earn money with haskell
07:22:03 <Peaker> haskellguy, start a startup company solving some problem with Haskell, or find an existing company that uses Haskell and willing to hire?
07:22:05 <mcstar> excellent question
07:22:36 <haskellguy> i don't find any jobs relating with haskell
07:22:41 <osfameron> haskellguy: set up a pyramid scheme selling monad tutorials
07:22:45 <osfameron> I've written a talk on this
07:22:50 <osfameron> the rewards are infinite!
07:22:56 <osfameron> but they may also take infinitely long to collect...
07:23:41 <haskellguy> maybe rather to use clojure because it's pretty simplified than haskell?
07:23:48 <mcstar> shachaf: im reading a linux kernel exploit presentation from the blog you linked, it is leaving a bad taste in my mouth!
07:23:58 <nand`> osfameron: set up a pyramid scheme collecting the results
07:24:54 <haskellguy> what do you think about clojure? It's really easy to learn and use than haskell?
07:25:10 <osfameron> haskellguy: there is a theory that learning haskell will make you a better programmer.  Assuming that being a better programmer will make you money, it's still worth while, even if you don't actaully end up programming in Haskell
07:25:37 <osfameron> clojure looks cool too.  though it's kinda offtopic here ;-)
07:26:09 <mcstar> osfameron: and theres a theory, that being exposed once to a superior language, you will feel real bad when forced to use an inferior one, ingnorance is bliss
07:27:01 <osfameron> mcstar: I guess.  I still enjoy writing in Javascript and Perl (and can bend them to my will much more successfully than I can Haskell as I know them better) but I've learnt a lot from haskell too
07:27:50 * osfameron considers doing next project in haskell...
07:29:14 <haskellguy> I'm asking because now i use java (java ee) and it's really boring. I'm finding something else that improve my programming skills and brings new concepts.
07:29:36 <nand`> Learning Haskell will make you a better Haskell programmer. It may or may not make you a better non-Haskell programmer, but it sure will make you a grumpy one.
07:29:41 <dgpratt> how can I tell what version of mingw is packaged with the Haskell platform?
07:32:23 <mroman> Some people use esolang because regular languages are boring.
07:32:33 <mroman> (as a side note)
07:33:48 <hiptobecubic> Parsing arguments seems to require a lot of 'obvious' code.
07:34:45 <mcstar> its a sin to use your excess brainpower on useless things
07:36:51 <cesip> can i use operator secitons in case expressions thus? = case (f x) of (>1) -> something something
07:37:18 <mcstar> you can pattern match against data constructors
07:37:58 <hiptobecubic> Something like the Option type from System.Console.CmdArgs.GetOpt  should be just about everything you need to make 99% of what most programs use
07:38:27 <hiptobecubic> and that could be cleaner too really.
07:42:29 <mroman> mcstar: How so?
07:42:59 <mcstar> mroman: how so what?
07:43:08 <mroman> Oh. That was not directed to me?
07:43:15 <mcstar> to cesip
07:43:31 <mcstar> mroman: oh, the brainpower?
07:43:35 <mroman> Yes ;)
07:44:08 <mcstar> mroman: just a personal remark, do something useful instead of messing with esoteric languages
07:45:20 <mroman> Easier said than done.
07:46:02 <rwbarton> haskell syntax quiz! when can you not replace "f = \x -> x + 1" by "f x = x + 1"?
07:46:19 <mroman> Let's just say that if there were any chance I could do something more useful I'd already done it.
07:46:29 <mroman> But there ain't.
07:46:32 <Peaker> Hmm. BerkeleyDB builds ok here with berkeleydb 5.1 c libs
07:46:44 <Peaker> rwbarton, MonomorphismRestriction :(
07:46:58 <Peaker> when f is instantiated with two different types
07:47:11 <rwbarton> good try, but I mean syntactically
07:47:20 <Peaker> in record field values
07:47:27 <rwbarton> correct!
07:47:31 <Peaker> yeah, it's annoying
07:47:42 <rwbarton> are there any other cases? i couldn't think of any
07:48:10 <Peaker> I don't think there are any more cases
07:48:22 <mroman> Knowing how to program itself is utterly useless.
07:48:50 <Peaker> but   f = \Pattern -> ...    and    f Pattern = ...    are somewhat different (if more pattern matches exist, or if more patterns exist w.r.t warnings)
07:49:03 <mroman> Without knowledge in other fields you hardly can do anything useful with just that.
07:49:03 <mcstar> cesip: case id 3 of ((> 1) -> True) -> "yay"; _ -> "doh"
07:49:13 <mcstar> you can do this with ViewPatterns
07:50:22 <mcstar> in ocaml, you can combine a pattern match with a boolean test, thats somewhat better
07:50:33 <Peaker> mcstar, that's what guards do?
07:50:42 <mcstar> he wanted case
07:50:49 <Peaker> guards work in case
07:51:00 <mcstar> i didnt know
07:51:08 <mcstar> ill try
07:51:29 <Peaker> > case True of True | True -> 1 | otherwise -> 0 ; False -> 2
07:51:30 <lambdabot>   1
07:51:41 <ClaudiusMaximus> dgpratt: your paste mentions "mingw32" and you said you're on 64bit - perhaps you need a 32bit version of berkleydb?  (just a guess - not a windows user here)
07:52:43 <Peaker> I wonder how I'd go about implementing an efficient key/value store in a file.  A growing hash table? I don't like the idea of amortizing here, O(N) after N queries in a while is not acceptable (shuffling gigs of data)
07:54:05 <Peaker> I guess you could grow the hash table lazily.. when out of space, make a new, bigger hash table. use the smaller one as fallback. migrate smaller one into larger one in background
07:55:12 <dmwit> rwbarton: Well, there are not so many places where '=' signs can go.
07:55:35 <dmwit> let, where, and records -- that's it
07:55:51 <olsner> Peaker: maybe something like a log-structured merge-tree could work?
07:55:58 <dmwit> let and where you can certainly make that replacement (up to the monomorphism restriction, as Peaker said)
07:56:36 <Peaker> olsner, I believe a hash table would be better than a tree in practice.. every IO could be expensive, at least if the db is on a hard disk
07:56:57 <Peaker> (so I think a good hash can have lower than O(logN) IOs per read in practice)
07:58:12 <mcstar> > case id 3 of x | x > 1 -> '>1' | otherwise -> '<=1'
07:58:13 <lambdabot>   <no location info>:
07:58:14 <lambdabot>      lexical error in string/character literal at chara...
07:58:27 <Peaker> > '>1'
07:58:27 <mcstar> > case id 3 of x | x > 1 -> ">1" | otherwise -> "<=1"
07:58:28 <lambdabot>   <no location info>:
07:58:28 <lambdabot>      lexical error in string/character literal at chara...
07:58:28 <lambdabot>   can't find file: L.hs
07:59:06 <mcstar> anyway, that supposed to work
07:59:49 <mcstar> cesip: ^^ that should do it
08:00:00 <jmcarthur> Peaker: one of the b-tree variants
08:00:03 <however> @undef
08:00:12 <however> > case id 3 of x | x > 1 -> ">1" | otherwise -> "<=1"
08:00:14 <lambdabot>   ">1"
08:00:59 <mcstar> however: can you explain?
08:01:05 <mcstar> what was 'defined'?
08:02:12 <Peaker> jmcarthur, I'm going to try and implement a hash-table file store, see how it goes...
08:02:12 <however> mcstar: i don't know exactly. possibly some prankster defined "id" to be funky. i got suspicious when your exact same line worked correctly in a private lambdabot window
08:04:56 <nand`> err, no
08:05:05 <nand`> “Can't find file: L.hs” is just an occasional bug lambdabot has
08:05:19 <nand`> I think it's a race condition involved with multiple people running stuff at the same time
08:05:41 <Taneb> What's the fixity of (:)?
08:05:50 <mcstar> :i (:)
08:05:51 <rwbarton> > '\&a'
08:05:52 <lambdabot>   <no location info>:
08:05:52 <lambdabot>      lexical error in string/character literal at chara...
08:05:55 <Iceland_jack> 5
08:05:57 <rwbarton> > '\     \a'
08:05:58 <lambdabot>   <no location info>:
08:05:58 <lambdabot>      lexical error in string/character literal at chara...
08:06:11 <Taneb> > 1 : [2,3,4] <|> [5,6,7]
08:06:12 <lambdabot>   [1,2,3,4,5,6,7]
08:06:23 <Taneb> Okay, that works, all is good
08:06:36 <rwbarton> that would work either way
08:06:48 <mroman> :t (<|>)
08:06:49 <lambdabot> forall (f :: * -> *) a. (Alternative f) => f a -> f a -> f a
08:08:49 <Taneb> extend (const ()) []
08:09:21 <Axman6> :t extend
08:09:22 <lambdabot> Not in scope: `extend'
08:12:17 <ThePro> :t 5
08:12:19 <lambdabot> forall t. (Num t) => t
08:12:21 <ThePro> lol
08:12:34 <ThePro> :t "foo"
08:12:36 <lambdabot> [Char]
08:12:38 <ThePro> funny
08:13:06 <mcstar> why?
08:13:17 <ThePro> irc haskell prompt
08:13:34 <ThePro> let a = 5
08:13:39 <ThePro> let b = 10
08:13:44 <ThePro> a + b
08:13:47 <mcstar> 15
08:13:49 <ThePro> :(
08:14:07 <rwbarton> @botsnack
08:14:08 <lambdabot> :)
08:14:33 <k00mi> > let a = 5; b = 10 in a + b
08:14:34 <lambdabot>   15
08:14:37 <k00mi> ;)
08:14:38 <ThePro> ah
08:14:45 <ThePro> > a + b
08:14:47 <lambdabot>   a + b
08:14:52 <kallisti> any recommendations for an HTML parser?
08:14:54 <ThePro> > let a = 15
08:14:56 <lambdabot>   not an expression: `let a = 15'
08:15:00 <ThePro> woot
08:15:01 <Peaker> (Ptr a) can be used via the mutable-array unboxed interface, as if it were an array of 'a's, just like in C?
08:15:08 <Philonous> Is stream-fusion dead?
08:15:09 <Peaker> seems cool
08:15:14 <ThePro> let is an expression
08:15:15 <Iceland_jack> > let (a, b) = (5, 10) in a + b
08:15:16 <lambdabot>   15
08:15:16 <Peaker> Philonous, the stream packages don't work?
08:15:19 <kallisti> ThePro: let must have a corresponding "in" clause.
08:15:26 <kallisti> otherwise it's not an expression
08:15:28 <mcstar> ThePro: you need to understand haskell to understand haskell
08:15:57 <ThePro> hm ok
08:16:50 <Philonous> Philonous:  The package "stream-fusion" was last updated more than a year ago and doesn't build on GHC after 7.0. I was wondering is it deprecated / superseded by something else
08:17:20 <ThePro> > take 5 [1,2..]
08:17:21 <lambdabot>   [1,2,3,4,5]
08:17:27 <ThePro> hm :)
08:17:28 <Philonous> Peaker, rather
08:17:32 <ThePro> > [1,2..]
08:17:34 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
08:17:42 <ThePro> smart guy
08:18:00 <ThePro> doesent flood that chat
08:18:07 <Peaker> Philonous, oh, I don't know
08:18:19 <Peaker> Philonous, maybe the problematic compilation flag can safely be discarded?
08:18:35 <Philonous> ThePro:  More importently, it doesn't descend into an infinite loop.
08:19:01 <Axman6> Philonous: the Vector package might be a good place to look
08:19:47 <ThePro> > 100000000000000000 ^ 10000000000000000000000000000000000000
08:19:52 <lambdabot>   mueval: ExitFailure 1
08:19:52 <lambdabot>  mueval: Prelude.undefined
08:20:18 <mcstar> ThePro: are you on a personal computer?
08:20:37 <ThePro> mcstar: ?
08:20:46 <ThePro> mcstar: on a laptop
08:21:01 <mcstar> you could install haskell then
08:21:15 <ThePro> ye
08:21:21 <nand`> ThePro: you mean “smart girl” :P
08:22:04 <Taneb> Whoever said it doesn't matter: it does if (<|>) is defined explicitly using (:)
08:22:12 <Taneb> I think
08:22:58 <ThePro> the bot is a girl? ok
08:23:35 <rwbarton> isn't (<|>) on lists (++) and isn't (a : b) ++ c the same as a : (b ++ c)
08:24:21 <Taneb> rwbarton, the backstory is I got bored and decided to make a base replacementy thing
08:24:35 <Taneb> defining (<|>) for lists as:
08:24:41 <Taneb> [] <|> ys = ys
08:24:42 <mcstar> Taneb: isnt every list operation defined with (:) ?
08:24:45 <nand`> rwbarton: yes, because (++) is defined recursively in terms of (:)
08:24:54 <nand`> (but I'm sure you know that)
08:24:57 <Taneb> (x : xs) <|> ys = x : xs <|> ys
08:25:13 <Taneb> mcstar, yes, but not directly
08:25:20 <Taneb> I was wondering if I needed brackets for that
08:25:34 <rwbarton> oh you mean on the LHS of a definition!
08:25:43 <MrFenix> hi.. any hint on which lib to use for 3d matrix/vector computations?
08:25:47 <Taneb> Do I?
08:25:48 <nand`> rwbarton: no, I don't think that's what he means
08:25:53 <rwbarton> well i give up then
08:25:56 <nand`> rwbarton: he means that (x : xs) <|> ys would spring into an infinite loop
08:26:01 <mcstar> (:) is associative
08:26:06 <nand`> but x : (xs <|> ys) will eventually reach the base case of xs = []
08:26:09 <MrFenix> (combined with dph)
08:26:15 <rwbarton> oh, well
08:26:19 <Philonous> Axman6:  I'm just trying to build a package that depends on it (stringprep), so It would take a nontrivial amount of work to switch to vector
08:26:19 <rwbarton> i assumed you meant the actual (<|>)
08:26:32 <rwbarton> not some hypothetical new one that you're in the middle of defining
08:26:34 <nand`> I did too
08:26:39 <nand`> but he did mention he was defining (<|>)
08:27:11 <rwbarton> < Taneb> What's the fixity of (:)? < Taneb> > 1 : [2,3,4] <|> [5,6,7] -- this is the original context I saw
08:27:34 <Taneb> Sorry for not explaining myself very well
08:27:43 <MrFenix> rwbarton: Prelude> :info (:)
08:27:43 <MrFenix> data [] a = ... | a : [a] 	-- Defined in `GHC.Types'
08:27:45 <MrFenix> infixr 5 :
08:27:47 <rwbarton> i was just pointing out that that lambdabot query didn't actually tell you anything
08:28:01 <rwbarton> it would have the same result regardless of the relative precedence of (:) and (<|>)
08:28:16 <nand`> oh yes, you are right
08:28:18 <Taneb> Yeah, I realised that when you said so
08:28:24 <nand`> the lambdabot query was indeed fruitless
08:28:25 <MrFenix> <|> has infixl 3
08:28:49 <nand`> then that should be bad for Taneb
08:28:51 <Taneb> :(
08:28:52 <rwbarton> and ++ is infixr 5
08:28:59 <Taneb> Okay
08:29:20 <kallisti> oh no, you might have to use -dundundun- parentheses!
08:29:26 <rwbarton> I would be sort of inclined to say <|> should be the same as ++
08:29:40 <MrFenix> rwbarton: yes
08:29:42 <Taneb> kallisti, but I don't know Lisp!
08:29:49 <MrFenix> ++ has infixl 5
08:29:52 <MrFenix> ahh
08:29:57 <MrFenix> infixr 5
08:32:45 <nand`> if it helps soothe your lisp sores you can use the less parenthesisy (:) x $ y <|> z
08:33:03 <rwbarton> look on the bright side, that means you don't need to write (x : xs) <|> ys on the left hand side :)
08:33:10 <Taneb> nand`, but I don't know Perl!
08:33:17 <Taneb> :P
08:33:26 <rwbarton> in parsec <|> is infixr 1
08:33:30 <mcstar> (:) x ((<|>) y z)
08:34:06 <nand`> Taneb: shield your eyes
08:34:14 <nand`> (((:) x) (((<|>) y) z))
08:34:35 <mcstar> nand`: killed by parentheses
08:36:52 <MrFenix> any status on numeric prelude?
08:36:53 <Taneb> nand`, I'm okay with pretty much any style
08:37:17 <Taneb> I have the dubious honour of having written the most controversial Haskell program on Uncyclopedia
08:37:24 <Taneb> (it's on the talk page for the language)
08:37:55 <Rotsor> Can I implement runLazyST :: (forall s.(ST s (init s), init s -> ST s a)) -> [a]?
08:39:28 <mcstar> “Haskell is compiled from .hs-files which means HOMO SEXUAL”
08:39:42 <mcstar> Taneb: that made my day
08:40:14 <kallisti> yes Uncyclopedia is well known as a multi-faceted, high-brow comedy goldmine.
08:41:41 <Peaker> Is there a better way to do: ceiling . logBase 2  ?
08:41:57 <Taneb> Peaker, Data.Bits.sizeOf?
08:42:00 <Taneb> :t sizeOf
08:42:01 <lambdabot> Not in scope: `sizeOf'
08:42:06 <Taneb> No, that wouldn't work
08:42:08 <Taneb> Nevermind
08:42:15 <kallisti> Peaker: not that I know of.
08:42:41 <kallisti> I believe there are various integer logarithm algorithms in the numoi package but that involve flooring.
08:42:48 <kallisti> *involves
08:43:02 <kallisti> Peaker: and the code itself is already pretty straightforward, so -shrug-
08:43:19 <Peaker> well, I'm worried whenever I use floating point
08:43:26 <Peaker> That there's some edge case that won't work correctly
08:43:28 <Philonous> Peaker:  \x -> exponent x + 1 ?
08:43:48 <kallisti> Peaker: are you performing any floating point computations before that point>
08:44:08 <Peaker> kallisti, no
08:44:36 <kallisti> should have minimal rounding error then.
08:44:56 <ClaudiusMaximus> :t floatRadix -- Philonous, might not always be 2 (but i do have code that relies on it being 2 without checking)
08:44:58 <lambdabot> forall a. (RealFloat a) => a -> Integer
08:45:21 <jmcarthur> Taneb: not sure what you mean by "the talk page for the language". which page is that?
08:45:35 <Taneb> uncyclopedia.wikia.com/wiki/Talk:Haskell
08:46:00 <jmcarthur> i see
08:46:16 <Peaker> kallisti, If it gives an incorrect bit count, it'll be bad
08:46:37 <Rotsor> Peaker, I think integer log2 may be even faster
08:46:40 <ClaudiusMaximus> Peaker: http://www.haskell.org/ghc/docs/7.4.1/html/libraries/integer-gmp-0.4.0.0/GHC-Integer-Logarithms.html
08:47:03 <Enigmagic> integer log2 is 1 cycle on most processors
08:47:12 <mcstar> > let ilogbase2 x = let xp2 = x `div` 2 in if xp2 > 1 then 1 + ilogbase2 xp2 else 1 in ilogbase2 2048
08:47:14 <lambdabot>   11
08:47:48 <Enigmagic> turns out there is an x86 instruction that calculates it
08:48:03 <mcstar> cant be more efficient than the above ^^
08:48:09 <mcstar> XD
08:48:14 <bitonic`> Enigmagic: integer log2 is a shift
08:48:35 <Enigmagic> bitonic`: bit-scan-reverse also calculates it, which is not a shift.
08:49:11 <Peaker> you can also compute it with a pop-count instruction (count enabled bits) and some trickery
08:49:35 <Enigmagic> Peaker: bsr <register> = log2i <register>
08:49:42 <Enigmagic> no trickery required
08:49:55 <bitonic`> Enigmagic: I don't know what that is, but ok :)
08:49:56 <mcstar> useless for bignums
08:50:19 <Peaker> Enigmagic, Sometimes there's the popcount instruction available and not log2i
08:50:31 <Enigmagic> Peaker: popcount is more recent than bsr
08:51:12 <Peaker> Enigmagic, well, at work we've had to use popcount because bsr was unavailable (or at least, so gcc builtins told us by failing to generate that instruction)
08:52:04 <Enigmagic> Peaker: uhm weird, since bsr has been there since 386 and popcount was in the nehalem i believe?
08:53:13 <b__> oh man that uncyclopedia page is good
08:54:29 <kallisti> it would appear that HXT is lacking a lot of documentation
08:56:22 <Taneb> Why is Eclipse saying "class Arrow (~>) => ArrowChoice (~>)" is a malformed context and I should use XFlexibleContexts
08:57:26 <kallisti> Taneb: does it compile otherwise?
08:57:45 <kallisti> or is this GHC saying that through Eclipse?
08:57:46 <Taneb> If I remove that class, yes
08:58:04 <Taneb> Oh, it works now
08:58:11 <kallisti> ~ might have some special meaning. I know it's used with constraint equality.
08:58:15 <Taneb> How odd
09:03:13 <ksf> no haddock comments for unnamed members of an AST?
09:03:40 <mcstar> System.IO.Unsafe.Really.IMeanIt.reallyReallyAbsurdlyUnsafePerformIOShameOnYou
09:04:46 <Peaker> is there a way to openFile ReadWrite mode without having it create the file if it does not exist?
09:04:53 <Peaker> (i.e: throw an error?)
09:06:52 <kallisti> any help navigating the behemoth that is HXT would be appreciated.
09:07:02 <kallisti> I'm trying to figure out how to do simple queries on the DOM structure.
09:07:38 <mcstar> Peaker: try opening it to see if it exists?
09:07:40 <Enigmagic> kallisti: do you need xpath and other things that hxt supports? it might be easier to use xml-conduit or something else if not
09:08:12 <kallisti> I just need to extract specific elements. not necessarily by xpath.
09:08:38 <Peaker> mcstar, that's non-atomic
09:08:44 <Enigmagic> kallisti: take a look at http://hackage.haskell.org/packages/archive/xml-conduit/1.0.1/doc/html/Text-XML-Cursor.html
09:10:08 <Peaker> I hate haskell-mode's flymake'ing me even when flymake is disabled
09:10:13 <Peaker> no way to turn it off :(
09:10:31 <kallisti> I just did M-x flymake-mode
09:10:34 <kallisti> and it turned off.
09:10:45 <Enigmagic> punishment for using emacs :P
09:10:57 <Peaker> kallisti, here it turns off, and 0.5 sec later, I get red again, despite no flymake-mode
09:11:09 <Peaker> Enigmagic, Yes, I am punished all the time for that.. unfortunately my emacs alternative is far from ready
09:11:48 <Enigmagic> Peaker: vim works ;)
09:11:58 <Peaker> Enigmagic, I hate emacs and vim both
09:12:05 <Peaker> (and I hate other text editors even more..)
09:12:38 <Enigmagic> Peaker: it'd be nice if something like lighttable actually came out
09:12:53 <Peaker> Enigmagic, I'm working on something nicer than LightTable :) But it'll be a while...
09:13:21 * hackagebot libexpect 0.3.1 - Library for interacting with console applications via pseudoterminals.  http://hackage.haskell.org/package/libexpect-0.3.1 (StephenRoantree)
09:13:32 <Philonous> Peaker:  Structural haskell editing?
09:13:39 <Enigmagic> Peaker: does 'a while' mean 'never'?
09:13:44 <Peaker> Philonous, yeah
09:13:49 <Enigmagic> that seems to be the case with most haskell editors :(
09:13:50 <Philonous> "real soon now"
09:13:52 <Peaker> Enigmagic, no, we've got a nice demo up and making great progress
09:14:08 <Peaker> I'm now trying to mock up a little key/value store of my own to replace bdb which is so painful for everyone to build
09:14:15 <Philonous> Peaker:  Will it be able to run elisp?
09:14:20 <Peaker> (and has problematic licensing too)
09:14:25 <Peaker> Philonous, no
09:14:33 <kallisti> Enigmagic: ah, very similar to xpath.
09:14:34 <Peaker> one of my mottos is: "Legacy is overrated" :-)
09:14:51 <Philonous> Peaker:  What good is it, then? ;)
09:14:57 <Peaker> I think various successful projects repeatedly prove that (e.g: iPhone)
09:15:31 <Enigmagic> Peaker: i just need vi or vim key bindings
09:15:46 <Peaker> Enigmagic, I did make hjkl navigation work :)
09:15:49 <Philonous> Peaker:  More seriously: Will it be programmable?
09:15:58 <Enigmagic> Peaker: that's almost enough :)
09:16:01 <Peaker> Philonous, we do plan on it, and self-hosting
09:17:00 <Taslem> How do you query lambdabot for point-free form?
09:17:05 <Philonous> Peaker: What does self-hosting mean for an editor?
09:17:10 <Enigmagic> Taslem: @pl
09:17:13 <mcstar> Peaker: System.Posix.IO.openFd
09:17:17 <Taslem> @pl p [] = [[]];p l = foldr (++) [] [ map (x :) $ p ((\la ll -> [x | x <- ll, x /= la) x l) | x <- l ]
09:17:17 <lambdabot> (line 1, column 6):
09:17:17 <lambdabot> unexpected "="
09:17:18 <lambdabot> expecting variable, "(", operator or end of input
09:17:42 <Enigmagic> i don't think it works with list comprehensions
09:17:50 <Peaker> Philonous, that you can edit the editor's code in the editor, and see the result in the same instance
09:17:56 <Taslem> @pl p [] = [[]]; p l = foldr (++) [] [ map (x :) $ p ((\la ll -> [x | x <- ll, x /= la]) x l) | x <- l ]
09:17:57 <lambdabot> (line 1, column 6):
09:17:57 <lambdabot> unexpected "="
09:17:57 <lambdabot> expecting variable, "(", operator or end of input
09:17:59 <Peaker> mcstar, ah, thanks
09:18:17 <Taslem> Yeah, looks like it doesn't like some apsect of it.
09:18:18 <Taslem> Oh well.
09:18:56 <Taslem> @pl p l = if null l then [[]] else foldr (++) [] [ map (x :) $ p ((\la ll -> [x | x <- ll, x /= la]) x l) | x <- l ]
09:18:57 <lambdabot> p = fix (ap (flip if' [[]] . null) . (foldr (++) [] .) . flip flip [] . (((:) . map (x :)) .) . join . ((<-) .) . flip flip x . ((|) .) . (. ((: [x /= x]) . ((x | x) <-))))
09:19:04 <Taslem> Thar we go!
09:19:07 <Taslem> Wow. That is completely unreadable.
09:19:21 <kallisti> I can read it just fine.
09:19:25 <kallisti> can't understand it though.
09:19:27 <kallisti> :)
09:19:35 <Peaker> Taslem, sometimes there's a readable points-free notation when @pl throws garbage out
09:19:35 <Taslem> Haha.
09:19:41 <Rotsor> wtf is ((x | x) <-) lol
09:19:49 <Taslem> Yeah.
09:19:51 <kallisti> pl being dumb.
09:19:52 <Peaker> Taslem, (i.e: @pl generating garbage shouldn't discredit points-free in general)
09:19:56 <kallisti> it doesn't read list comprehensions.
09:20:01 <kallisti> it thinks they're infix operators.
09:20:05 <Taslem> Ah, that could be problematic.
09:20:13 <Taslem> I know points-free is good in a lot of cases.
09:20:26 <Taslem> I just wanted to see if you could get a decent one for this problem.
09:20:32 <Philonous> Peaker:  What is the name of you project / is it hosted somewhere publicly? (github?)
09:20:38 <mcstar> Taslem: are you going for permutations?
09:20:45 <Taslem> Yeah, that's what it does.
09:20:46 <kallisti> Taslem: you can replace a lot of your list comprehensions with filters and maps it would seem.
09:20:59 <Taslem> I agree. Just easier to write at the time.
09:20:59 <mcstar> thats particularly ugly
09:21:08 <kallisti> [x | x <- ll, x /= la]  is just filter (/= la) ll
09:21:29 <kallisti> no sure what the (\la ll -> ...)  lambda is all about
09:21:41 <c_wraith> :t Data.List.permutations
09:21:42 <lambdabot> forall a. [a] -> [[a]]
09:21:44 <hpaste> mcstar pasted “permutations” at http://hpaste.org/70682
09:21:51 <c_wraith> personally, I'd just use that
09:22:29 <mcstar> my version is much better than a succint list comprehension
09:22:31 <Peaker> Philonous, http://github.com/Peaker/bottle
09:22:41 <Taslem> Originally a separate function, I inlined it because I didn't think lambdabot would work with it.
09:23:05 <kallisti> Taslem: using lambdas to rename variables makes me cry. :_(
09:23:33 <Taslem> Like I said, I inlined another function. The bad lambda was a byproduct.
09:23:49 <Taslem> Because I did it poorly.
09:24:00 <kallisti> let f x l = ...  in ...
09:24:05 <Philonous> Peaker:  thanks
09:24:43 <Taslem> Oh, dur.
09:24:58 <Peaker> Philonous, one of the annoyances of building it is berkeleydb, giving everyone trouble.. so I'm trying to write a little key/value store in a day :)
09:25:08 <kallisti> Taslem: let also supports mulltiple bindings.
09:25:14 <kallisti> > let x = 2; y = 3 in x + y
09:25:15 <lambdabot>   5
09:25:17 <kallisti> (in case you didn't know)
09:25:43 <Taslem> Oh, I know.
09:25:49 <Taslem> It just slipped my mind to use in in this case.
09:25:52 <kallisti> but yes adjusting normal Haskell to "lambdabot Haskell" is a skill that takes practice.
09:25:57 <hpaste> mcstar annotated “permutations” with “permutations (annotation)” at http://hpaste.org/70682#a70683
09:25:59 <Taslem> permute' l = if null l then [[]] else foldr (++) [] $ map (\x -> map (x :) $ permute' ((/=x) `filter` l)) l
09:26:01 <Taslem> Better?
09:26:05 <Taslem> @pl permute' l = if null l then [[]] else foldr (++) [] $ map (\x -> map (x :) $ permute' ((/=x) `filter` l)) l
09:26:06 <lambdabot> permute' = fix (ap (flip if' [[]] . null) . (foldr (++) [] .) . join . ((map . liftM2 map (:)) .) . (. flip (filter . (/=))) . (.))
09:26:12 <mcstar> Taslem: look at my paste
09:26:14 <Taslem> That may possibly be better.
09:27:18 <kallisti> permute' [] = [[]]; permute' l = ...
09:27:24 <kallisti> removes the if.
09:27:36 <kallisti> @src concat
09:27:36 <lambdabot> concat = foldr (++) []
09:28:18 <kallisti> infix filter is weird but whatever. :D
09:28:58 <kallisti> alternative to filter and map would be to just mapMaybe from Data.Maybe
09:29:02 <kallisti> it acts as both a map and filter
09:29:12 <kallisti> s/just/use/
09:29:24 <kallisti> :t mapMaybe
09:29:25 <lambdabot> forall a b. (a -> Maybe b) -> [a] -> [b]
09:31:06 <mcstar> was nice talking to you
09:38:31 <Franciman> hey guys what's the most functional way to write a lexical analyser?
09:38:59 <noteventime> Most functional?
09:39:15 <Franciman> lol
09:39:33 <Franciman> the most elegant way in functional programming
09:39:47 <Franciman> but yet efficient
09:40:24 <osfameron> kallisti: concatMap is also an alternative to filter+map
09:40:47 <Azel> Is there a way to have every call to Debug.Trace's functions (i.e. trace, traceShow & co) disappear in the generated code ? For example a ghc flag ?
09:41:10 <Franciman> Azel, maybe you can achieve this by using the C preprocessor
09:41:15 <noteventime> Azel: You could use CPP
09:42:09 <noteventime> ifdef protect the import and add a nop function when you're not compiling for debug
09:44:51 <Franciman> guys no idea about lexer? :S
09:45:10 <noteventime> Franciman: I'm guessing you've taken a look at Alex?
09:45:49 <noteventime> Also, there's some lexer stuff in Parsec if I remember correctly
09:46:18 <kallisti> osfameron: yeah it's a generalization. mapMaybe is a bit closer to being strictly a filter and map
09:46:24 <Franciman> noteventime I wanted to do it by hand
09:47:14 <noteventime> Franciman: What's wrong with just a parser generator like Parsec? (they're pretty easy to write and as far as I can see they're just as useful for writing lexers as they are for writing parsers)
09:47:26 <noteventime> I won't pretend I know a lot about parsing though :)
09:47:36 <noteventime> err, parser combinator*
09:49:15 <`Jake`> I'm on Windows 7 64-bit atm, os and arch from System.Info give me mingw32 and i386. Does that mean if I compile a file it will work on 32-bit machines?
09:49:53 <Eduard_Munteanu> `Jake`: I guess so
09:50:01 <`Jake`> ok, thanks
09:50:28 <however> azel: you could do "trace = id". possibly even put it a module "Debug.Trace.Off" or something, then you could turn things on and off by just adding ".Off" to the import line ...
09:50:58 <Eduard_Munteanu> trace = flip const   rather?
09:51:00 <however> i could have sworn that Debug.Trace can be turned off via some compiler flag, but it turns out i was thinking of assertions (-fignore-asserts)
09:51:19 <MrFenix> I just fixed a dependency problem of a cabal package  that is on hackage but not on github.. what is the best way to commit my change?
09:51:31 <however> Eduard_Munteanu: uh right :)
09:51:32 <Eduard_Munteanu> @hoogle trace
09:51:32 <lambdabot> Debug.Trace module Debug.Trace
09:51:32 <lambdabot> Debug.Trace trace :: String -> a -> a
09:51:33 <lambdabot> Debug.Trace traceShow :: Show a => a -> b -> b
09:51:43 <however> trace _ x = x
09:53:00 <Eduard_Munteanu> Or employ CPP to disable it based on a preprocessor flag.
09:53:09 <Eduard_Munteanu> *And/or
09:53:44 <MrFenix> contact the author directly or is there some trick with darcs to push the package and he will see it?
09:54:14 <osfameron> kallisti: oic, concatMap is to [] as mapMaybe is to Maybe ?
09:55:52 <however> MrFenix: if you don't get any better ideas, put the patch in an email
09:55:56 <kallisti> osfameron: sort of.
09:56:27 <kallisti> osfameron: concatMap is equivalent to (>>=) for lists, which is different to (>>=) for Maybe
09:56:35 <MrFenix> however: it is nothing fancy.. just a simple version bump in the cabal file
09:57:06 <kallisti> osfameron: I think it has more to do with Maybe being a subset of the possible values of [].
09:57:16 <kallisti> Maybe is a "one or zero" element list.
09:57:30 <kallisti> [] is "zero or many"
09:57:33 <osfameron> true
09:58:23 * hackagebot lambdacube-engine 0.2.4 - 3D rendering engine written entirely in Haskell  http://hackage.haskell.org/package/lambdacube-engine-0.2.4 (GergelyPatai)
10:02:41 <byorgey> anyone who can help with tracking down errors involving Network.HTTP, TCP, XML-RPC, etc? l [~perspecti@35.158.broadband4.iol.cz] has quit [Ping timeout: 244 seconds]
10:02:51 <byorgey> blargh, sorry
10:02:56 <Taneb> What's the categoric dual of Applicative?
10:02:59 <byorgey> I meant to paste this: http://stackoverflow.com/questions/11277788/errorclosed-exception-from-network-http-simplehttp-trying-to-upload-images-vi
10:03:19 * Taneb doesn't quite know what a categoric dual is, but thinks they're pretty cool
10:03:36 <byorgey> this has been really frustrating, I thought this code would take an hour or so to write and it's now eaten an entire day
10:03:55 <MrFenix> Taneb: applicative is sort of coalgebraic (a -> F a) + morphisms
10:04:11 <ski> Taslem : `p [] = [[]]; p l = concatMap (\x -> map (x :) (p (filter (/= x) l))) l', though i suspect that you'd rather want `p [] = [[]]; p l = do (x,l) <- select l; liftM (x :) (p l)', with `select [] = empty; select (a:as) = pure (a,as) <|> liftA (fmap (a:)) (select as)' (or with `mzero',`return',`mplus',`liftM' instead of `empty',`pure',`(<|>)',`liftA')
10:04:33 <Taneb> MrFenix, it's answers like that that make me realize how much I have left to learn
10:04:34 <MrFenix> Taneb: so Co-Applicative should be F a -> a + morphisms which is an algebra
10:05:19 <Saizan> Taneb: http://sneezy.cs.nott.ac.uk/fplunch/weblog/?p=69
10:05:40 <MrFenix> this comes without waranty; it is kind of hard to translate haskell to category theory, as you only get special cases
10:07:33 <ski> .. what Saizan link says
10:09:40 <rwbarton> you can also keep the monoidal category (Hask, (,)) fixed and ask for a lax comonoidal functor (f () -> (), f (a, b) -> (f a, f b)), but that's boring because any functor has that structure in a unique way
10:12:08 <Taneb> Interesting
10:12:34 <ski> well, you could attempt switching to a "tensorial" monoidal category (over `AbGroup' or `Vect_K', say)
10:12:41 <jmcarthur> Taneb: http://sneezy.cs.nott.ac.uk/fplunch/weblog/?p=69
10:13:05 <Taneb> jmcarthur, that link has just occured, and it was to that I was saying "interesting"
10:13:23 <irene-knapp> oh interesting!
10:13:41 <jmcarthur> bah
10:13:47 <jmcarthur> i had been looking for it and i missed it being here
10:14:10 <jmcarthur> i never have the right keywords to google for
10:15:48 <avpx> Hello everyone. I wrote an implementation of the Miller-Rabin primality test in the (RandomGen g) => (State g) monad. There is a function responsible for generating an infinite list of primes by using the primality test on [3..]. This part works fine sequentially, but when I try to evaluate this list of primes in parallel using the (parTraversable rseq) strategy, the program hangs and I get a stack overflow.
10:16:16 <jmcarthur> Taneb: see also this discussion http://ja.reddit.com/r/haskell/comments/qsrmq/coapplicative_functor/
10:16:32 <avpx> I'm guessing that this has to do with how the random number generator is being passed around in the state monad. Here is the code that hangs: https://github.com/nvanderw/NumberTheory/blob/parallel/NumberTheory/MillerRabin.hs
10:16:37 <jmcarthur> or perhaps without the "ja." :)
10:16:47 <ski> re `branch :: Decisive f => (f a0 -> b) -> (f a1 -> b) -> (f (Either a0 a1) -> b)' cf. `eitherA :: ApplicativeChoice i => i (a0 -> b) -> i (a1 -> b) -> i (Either a0 a1 -> b)'
10:18:10 <cesip> hmmmm
10:18:13 <avpx> I'm generally wondering how one goes about doing something like parallel Monty Carlo in State g with Haskell's Control.Parallel.Strategies
10:18:14 <cesip> what the hell
10:18:20 <cesip> i am defining:
10:18:33 <Taneb> Hmm
10:18:43 <Taneb> How can (<*>) be defined in terms of zip?
10:19:11 <cesip> two lines:
10:19:20 <c_wraith> avpx: well, a PRNG is a linear state dependency. To parallelize, you would need multiple generators
10:19:21 <Taneb> fmap (\(a, b) -> a b) . zip
10:19:23 <cesip> makeLine :: [(Int,Int)] -> String
10:19:23 <cesip> makeLine :: [(Int,Int)] -> String
10:19:23 <cesip> makeLine :: [(Int,Int)] -> String
10:19:39 <jmcarthur> :t \f xs ys -> map f $ zip xs ys
10:19:39 <cesip> makeLine n = concat . map makeChunk . filter (==n) . map snd
10:19:39 <cesip> whoops sorry about the flood
10:19:40 <lambdabot> forall b a b1. ((a, b1) -> b) -> [a] -> [b1] -> [b]
10:19:51 <jmcarthur> :t \f xs ys -> map (uncurry f) $ zip xs ys
10:19:52 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
10:19:56 <rwbarton> avpx, I would think that stateful algorithms are intrinsically non-parallelizable (unless you can reformulate them to avoid the state)
10:19:59 <c_wraith> cesip: there's concatMap, to slightly simplify that
10:20:00 <jmcarthur> there's liftA2, at least
10:20:16 <rwbarton> or unless you can parallelize the computations between state changes
10:20:17 <cesip> c_wraith thanks! but by problem is ghci throws an error at that
10:20:23 <jmcarthur> :t \xs ys -> map (uncurry ($)) $ zip xs ys
10:20:25 <lambdabot> forall b b1. [b -> b1] -> [b] -> [b1]
10:20:42 <cesip> and it already has some stomach ache at map snd
10:20:54 <c_wraith> cesip: a type error, probably?  What's the type of makeChunk?
10:21:15 <cesip> Int -> String
10:21:22 <c_wraith> cesip: also, you have the wrong number of args.
10:21:35 <c_wraith> makeLine :: Int -> [(Int, Int)] -> String
10:21:41 <avpx> rwbarton: I agree. Generally RandomGen is used with the State monad in this (sequential) way, and I'm wondering if there is an alternative that allows multiple parallel threads to get random numbers
10:21:44 <c_wraith> cesip: at least by the definition you gave
10:22:08 <monochrom> "(x,y) <- get; let {x1 = f x; y1 = g y} in put ((x1 `par` y1) `pseq` (x1, y1))" is possible
10:22:11 <rwbarton> you can use 'split', but... I don't think the randomness properties of split generators are very good
10:22:26 <kallisti> what librar should I use to download an HTML web page with all of its static content?
10:22:35 <kallisti> a libcurl binding, perhaps?
10:22:41 <ski> avpx,c_wraith : "To parallelize, you would need multiple generators" -- or maybe `split :: RandomGen g => g -> (g,g)' ? (i suppose there might be some determinism problems still)
10:22:42 <cesip> c_wraith, that was it. i am a noob at higher-order functions, and still mix stuff up. thanks!
10:22:43 <rwbarton> at least not the ones produced by System.Random
10:23:19 <c_wraith> cesip: you'll get it.  Just takes some practice.
10:24:41 <ski> avpx : with `split' (it's not obvious you have an efficient or good (in PRNG sense) implementation of it), you can decouple sub-computations from each other, but it's still imposing a specific dependency ordering statically (only this ordering is no longer a total order)
10:25:52 <ski> avpx : you could cheat by storing the PRNG state in a mutable cell, and access it at each use (using `unsafePerformIO') (then you'd not need `split') -- however this throws determinacy out the window, so you no longer get repeatable results :(
10:26:59 <noteventime> Has there been any work on using Conduit/Pipes(-core)/Iteratee e.t.c. in a concurrent setting? i.e. be able to do something like multiplexTChan :: Pipe (TChan b) b ...
10:27:06 <avpx> ski: That's the sort of solution I was looking at. GHC is being "too deterministic" I guess, in that it really wants my get / put actions in the State monad to happen in the order I've written (when in fact I'd like them to be reordered for parallelism)
10:27:55 <rwbarton> this thread about splitting random number generators is interesting: http://haskell.1045720.n5.nabble.com/Splittable-random-numbers-td3250495.html
10:28:03 <ski> hm, maybe there's a way to use oracles (in the sense of Fudgets) somehow (to reinstate determinacy but still allowing scheduler to schedule as it pleases, not introducing any auxilary dependencies than the proper data ones (not counting PRNG state)), i'm not sure ..
10:28:21 <avpx> It would be a shame to have to use the IO monad here :-\
10:28:23 * hackagebot egison 2.0.0 - An Interpreter for the Programming Language Egison  http://hackage.haskell.org/package/egison-2.0.0 (SatoshiEgi)
10:28:25 * hackagebot egison 2.0.1 - An Interpreter for the Programming Language Egison  http://hackage.haskell.org/package/egison-2.0.1 (SatoshiEgi)
10:28:32 <avpx> rwbarton: I will check that out
10:28:34 <ski> avpx : "too deterministic" is just it being pure
10:28:40 <avpx> ski: Exactly
10:28:48 <avpx> I mean, it's doing everything I ask it to, sure...
10:29:38 <however> byorgey: don't really know, but any chance the web server has some kind of upload size limit configured, or is running a firewall? i noticed the failed upload ends in some packets with flag R (reset). the successful upload ends with flag F (FIN). maybe try uploading the same file but not via your program, to see if that produces a different tcpdump
10:29:52 <however> also, wireshark might be easier to use than tcpdump ...
10:30:14 <avpx> rwbarton, ski: I have to go, but thanks for your help and suggestions. I may come back and discuss this type of thing more
10:31:38 <byorgey> however: hmm, good suggestion, I'll try that
10:32:14 <byorgey> I'm not sure what you mean by "easier to use" because I have no idea what the output means anyway =P
10:34:01 <however> well wireshark is a gui tool :) you just hit the capture button and it gives colorful clicky menuy output
10:37:30 <avpx> rwbarton: This Cafe post seems pretty close to what I want to do, considering they're using it for Monte Carlo simulations. Thanks.
10:38:43 <mdmkolbe> What is a good (small) collection of Haskell 98 source files that I can use for benchmarking the parser I just wrote?
10:39:50 <Peaker> what module import brings the IsString instance of Data.ByteString?
10:39:50 <Peaker> Oh, UTF8/Char8/etc
10:40:10 <ski> avpx,c_wraith : re oracles, see "20 -- Implementing stream processors" in "Purely Functional Processes with applications to Graphical User Interfaces" (Ph.D. thesis) by Magnus Carlsson,Thomas Hallgren in 1998 : <http://www.cse.chalmers.se/~hallgren/Thesis/streamprocimpls.html>
10:40:15 <parcs`> mdmkolbe: http://hackage.haskell.org/package/haskell98 ?
10:41:11 <parcs`> never mind, that package just re exports stuff from base
10:43:41 <mdmkolbe> parcs`: I might try base though (or at least the files that are H98)
10:45:33 <parcs`> i'm pretty sure most modules in base are covered in CPP
10:46:27 <mdmkolbe> parcs`: I can pre-process the files to remove the CPP
10:48:24 * hackagebot egison 2.0.2 - An Interpreter for the Programming Language Egison  http://hackage.haskell.org/package/egison-2.0.2 (SatoshiEgi)
10:50:28 <ptrf> copumpkin: again, thank you for the help yesterday :-) at the end of it, just before looking in the source of control.monad.free, I realized that I probably had to just 'pass' g in through each of the wraps of Free f a's, but I didn't think off using >>= partially applied :)
10:58:24 * hackagebot egison 2.0.3 - An Interpreter for the Programming Language Egison  http://hackage.haskell.org/package/egison-2.0.3 (SatoshiEgi)
11:01:02 <Peaker> Yay, my key/value store on-top-of-file seems to work (not too tested)
11:01:57 <Peaker> And pretty limited yet (append-only, constant hash size) :)
11:01:58 <ski> "on-top-of-file" ?
11:01:58 <Peaker> but for bottle, it's probably good enough for now, and can remove the BDB annoyances
11:03:32 <Taneb> What's that flag where it replaces syntax things with their locally defined alternatives?
11:04:01 <Taneb> So you can define your own (>>=) and use it for do's
11:05:25 <rwbarton> RebindableSyntax, or I think NoImpliciPrelude in older versions
11:05:42 <Taneb> Thanks
11:06:04 <rwbarton> (NoImplicitPrelude of course, typo)
11:21:45 <Peaker> whoever wanted to try bottle out but couldn't because of berkeley db trouble, I uploaded a new version that depends on my own little pure-Haskell key/value store now
11:23:25 * hackagebot keyvaluehash 0.1.0.0 - Pure Haskell key/value store implementation  http://hackage.haskell.org/package/keyvaluehash-0.1.0.0 (EyalLotem)
11:29:42 <mcstar> Peaker: ill try
11:29:53 <mcstar> could you provide a link again?
11:30:17 <Philonous> mcstar:  https://github.com/Peaker/bottle
11:30:58 <mcstar> ah, i had it, git pull'd it
11:31:41 <Peaker> you also need to "cabal update" to get the new package it depends on in place of berkeleydb
11:31:57 <Philonous> Peaker:  Maybe add it as a git submodule?
11:32:29 <Peaker> git submodules are quite clunky though, and "cabal install" is easier, isn't it?
11:32:35 <Peaker> (it's uploaded to hackage)
11:33:42 <Philonous> Well, yes, I like to make changes to sub-libraries without necessarily pushing a new version to hackage. I find submodules quite nice for that.
11:34:43 <mcstar> Peaker: cabal list bottle doesnt list it
11:34:50 <Peaker> mcstar, no, not bottle is upploaded
11:34:54 <Peaker> keyvaluehash is uploaded
11:35:00 <mcstar> oh
11:35:02 <Peaker> and bottle now depends on that instead of BerkeleyDB
11:35:02 <mcstar> right
11:35:13 <mcstar> i thought it was on hackage too :)
11:36:07 <ski> Peaker : mayhaps edwardk ?
11:36:13 <edwardk> wut?
11:36:16 * edwardk reads
11:36:34 <ski> <Peaker> whoever wanted to try bottle out but couldn't because of berkeley db trouble, I uploaded a new version that depends on my own little pure-Haskell key/value store now
11:36:39 <mcstar> no
11:36:43 <mcstar> some other guy
11:36:46 <edwardk> ah good
11:36:49 <edwardk> i'll give it a shot then
11:36:53 <mcstar> dgprat
11:37:03 <mcstar> dgpratt
11:38:15 <ski> (Peaker : i suppose you could `@tell' or `/msg MemoServ send' to dgpratt ..)
11:38:35 <Philonous> Peaker:  I get loads of "FTGL warning: NULL pointer in _ftglRenderFont"
11:38:36 <mcstar> Peaker: it says i should run configure, but it aint there
11:38:57 <Philonous> mcstar:  cabal-dev configure
11:38:57 <mcstar> or is that some cabal instruction?
11:39:01 <mcstar> oh
11:39:10 <mcstar> i dont even have cabal-dev
11:39:10 <Philonous> or cabal configure
11:39:29 <Peaker> Philonous, oh, maybe you have a bad ~/.fonts config file or such?
11:39:56 <Peaker> mcstar, what command are you running?
11:40:04 <mcstar> it ok now
11:40:05 <Peaker> mcstar, you could run "cabal install", or "cabal configure && cabal build"
11:40:05 <mcstar> s
11:40:27 <Peaker> Philonous, I don't really know why FTGL may fail to render stuff.. Maybe the font file I specify is bad or doesn't exist?
11:40:49 <mcstar> Peaker: the makefile has cabal build, you should consider adding the configure to it also
11:41:04 <Peaker> oh, bad font path doesn't throw exception, it just gets that error
11:41:19 <Peaker> mcstar, the Makefile is a hack for sublime text edit to allow buildin
11:41:26 <Peaker> I guess we should just make it a private file
11:42:50 <mcstar> package directory-1.1.0.2 requires filepath-1.2.0.1
11:42:52 <mcstar> package process-1.1.0.1 requires filepath-1.3.0.0
11:43:09 <Peaker> mcstar, what's that?
11:43:17 <Peaker> oh the ftgl binding don't do a null check
11:43:33 <mcstar> when i try installing keyvaluehash ^^
11:44:03 <Peaker> Philonous, fix defaultFont in Main.hs (hacky, we need to sort that out)
11:44:56 <tertl4> main :: IO ()
11:44:56 <tertl4> main = do args <- getArgs
11:44:56 <tertl4>           print ( (read $ args!!0) + (read $ args!!1))
11:45:03 <tertl4> shuold this compile?
11:45:12 <tertl4> I am having issues in windows with it
11:45:13 <Philonous> Peaker:  Yes, I'm already on it
11:45:24 <tertl4> oops
11:45:30 <tertl4> main :: IO ()
11:45:30 <tertl4> main = do args <- getArgs
11:45:30 <tertl4>           putStrLn ( "Hello , " ++ args!!0 ++ " " ++ args!!1)
11:45:41 <tertl4> should that compile?
11:46:02 <mauke> tertl4: ask ghc
11:46:17 <however> tertl4: please use hpaste.org for anything more than one line. include the compiler error you're getting, because folks will then be able to help you better
11:46:23 <Philonous> Peaker:  There we go!
11:46:55 <Bytter> Has there been any evolution on interactive rewriting systems since HERA?
11:47:50 <tertl4> http://hpaste.org/new
11:48:05 <tertl4> would this compile in linux ir is it a typo?
11:48:13 <mcstar> heh
11:48:16 <mcstar> try again
11:48:34 <Peaker> Are there standard exception types (instances of Exception class) defined somewhere, like "FileNotFound", etc?
11:49:13 <however> tertl4: i think you forgot to hit the submit button ;)
11:49:27 <tertl4> however k thaks
11:49:51 <mcstar> the code looks ok though
11:49:58 <mauke> @hoogle IOError
11:49:58 <tertl4> http://hpaste.org/70686
11:49:58 <lambdabot> Prelude type IOError = IOException
11:49:59 <lambdabot> System.IO.Error type IOError = IOException
11:49:59 <lambdabot> Prelude ioError :: IOError -> IO a
11:50:23 <mauke> " " args
11:50:53 <mcstar> tertl4: thats not what you pasted
11:50:57 <mcstar> here i mean
11:51:11 <mcstar> the one here is ok
11:51:26 <however> yes, there's a crucial difference that causes the error. check it closely
11:53:04 <Philonous> Peaker:  "File not found" should be an IOException as defined in http://www.haskell.org/ghc/docs/7.4.2/html/libraries/base-4.5.1.0/Control-Exception-Base.html
11:55:05 <tertl4> however whats the error?
11:55:27 <mauke> that you're trying to call " "
11:56:00 <mcstar> no, the error is, how could you have pasted the correct code here?
11:56:55 <tertl4> http://hpaste.org/70687
11:57:03 <tertl4> this is directly from the web tut
11:57:41 <kallisti> why is the latest version of cabal so strict about dependencies?
11:57:48 <kallisti> I can't figure out what it's complaining about.
11:58:01 <kallisti> (by "latest" I actually mean 1.14)
11:58:30 <mcstar> tertl4: pay attention to formatting
11:58:43 <daniel_->             rs <- getLine
11:58:43 <daniel_->             cMode ans hs' new
11:58:43 <daniel_->                 where pts = count rs
11:58:43 <daniel_->                       new = next hs ns
11:58:43 <daniel_->                       hs' = (new, pts):hs
11:58:51 <daniel_-> i get rs not in scope on the where pts = count rs
11:59:03 <kallisti> the where clause applies to the function binding
11:59:07 <however> kallisti: try increasing -v. the reason is usually buried somewhere in the middle of that. if you get stuck, hpaste the -v output
11:59:15 <kallisti> at which point rs is not in scope.
11:59:37 <kallisti> daniel_-: you liking want to use a let
11:59:44 <Philonous> daniel_-:  Use let. like in do{x <- foo; let bar = x + 1; bargl bar}
11:59:48 <however> tertl4: i think the code and the error message don't match up in http://hpaste.org/70687 . that code runs fine for me (no error)
11:59:49 <mcstar> tertl4: your last paste(notwithstanding formatting) is correct and  compiles
12:00:02 <kallisti> daniel_-: oh, also, don't spam the channel with code, use hpaste.
12:00:04 <kallisti> @hpaste
12:00:04 <lambdabot> Haskell pastebin: http://hpaste.org/
12:00:17 <Philonous> tertl4:  The error message complains about a missing (++), but the code does contain it.
12:00:25 <tertl4> mcstar what is the formatting error?
12:00:40 <kallisti> however: looks like the same output as before with -v
12:00:43 <mcstar> dont indent the import and the type declaration
12:00:59 <however> Philonous: yes, the error message belongs to the earlier hpaste link
12:01:13 <Philonous> tertl4:  Note that (" " x) means 'Apply the value " " to the value x" which doesn't make sense since strings aren't functions.
12:02:18 <kallisti> rejecting: shakespeare-1.0.0.2/installed-27d... (conflict: process==1.1.0.1,
12:02:18 <kallisti> shakespeare => process==1.1.0.1/installed-18d...)
12:02:33 <mcstar> i found my error
12:02:35 <kallisti> those are the same versions of process...
12:02:46 <mcstar> 'directory' is installed systemwide and userwide
12:06:18 <mcstar> so, im trying to unregister a conflicting package with ghc-pkg
12:06:32 <mcstar> but it says 'cannot find package'
12:06:44 <mcstar> it doesnt use contraction! soo annoying
12:07:37 <tertl4> thanks guys, I found it,  :\  feel like a newb now
12:08:01 <MostAwesomeDude> tertl4: No worries.
12:08:11 <kallisti> rejecting: yesod-platform-1.0.2, 1.0.1, 1.0.0 (conflict: webdriver =>
12:08:13 <kallisti> attoparsec==0.10.2.0/installed-6b9..., yesod-platform => attoparsec==0.10.1.1)
12:08:16 <kallisti> what is this trying to tell me.
12:08:33 <mcstar> so how do i remove a package with a certain id hash?
12:08:53 <kallisti> mcstar: did you try removing it by version?
12:09:05 <mcstar> the version is the exact same
12:09:15 <mcstar> i need to differentiate by hash
12:10:01 <mcstar> i think esp is playing ita
12:10:04 <mcstar> bb
12:10:08 <shachaf> mcstar: What's wrong with the kernel exploit presentation?
12:10:15 <mcstar> shachaf: nothing
12:10:27 <mcstar> it was long ago i last looked at such things
12:10:34 <mcstar> but it made me worried
12:10:37 <mcstar> and nervous
12:10:42 <however> mcstar: have you tried "ghc-pkg list -v", then pasting the part in parens?
12:11:10 <mcstar> however: thats what i tried, yes
12:15:26 <tertl4> what about this one guys? http://hpaste.org/70688
12:16:10 <shachaf> tertl4: (print (read (args!!0))) + (read (args!!1))
12:16:19 <Peaker> Philonous, https://github.com/Peaker/FTGL <-- if you use this instead of FTGL you'll get a FontLoadFailure in place of NULL dereferences
12:16:31 <shachaf> Just remember the rule for precedence of function application.
12:16:40 <however> mcstar: weird :( i could have sworn this worked, but you're right, it doesn't. ghc-pkg unregister spoon-0.3-322ddac4... => package not found
12:17:20 <ClaudiusMaximus> Peaker: cool, could be useful to me too
12:17:58 <tertl4> shachaf http://hpaste.org/70689
12:18:15 <tertl4> oopas
12:18:34 <shachaf> tertl4: I'm telling you what your program got parsed as.
12:18:50 <shachaf> (Except for $ which I eliminated for clarity.)
12:19:07 <shachaf> You'll have to look at it and figure out what to do. :-).
12:19:09 <shachaf> s/.$//
12:19:30 <however> a good band name, btw. "eliminated for clarity".
12:20:08 <Philonous> Peaker:  Wouldn't it have been easier to test for the existence of the file instead of cloning the entire library? ;)
12:20:31 <Peaker> Philonous, Don't ask what your library can do for you, ask what you can do for your library :) This seemed more correct
12:20:34 <Peaker> Philonous, also, it is racy
12:21:47 <ClaudiusMaximus> Peaker: btw, 1.4 < 1.333
12:22:22 <Peaker> ClaudiusMaximus, oh :)
12:22:54 <Philonous> ClaudiusMaximus:  In p-adic numbers?
12:22:56 <tertl4> shachaf i cant get it to work?
12:23:11 <Peaker> ClaudiusMaximus, fixed
12:23:40 <ClaudiusMaximus> cool
12:23:50 <ClaudiusMaximus> Philonous: in version strings
12:23:51 <Philonous> Peaker:  I've never thought about that. So trying to open the file and catching the exception is actually "more correct" than checking for the existence.
12:25:04 <ClaudiusMaximus> so many things to check, and they could all change in between checking and opening - so just do it and catch any exceptions later
12:26:17 <Philonous> Yeah. It's obvious if you think about it like that.
12:26:20 <however> tertl4: indentation is important in haskell. i suggest you write "main = do", then start a new line "    args ..." and another line "    print ...". note the indentation is exactly the same (4 spaces)
12:27:30 <tertl4> ahh ok
12:27:43 <tertl4> i see indentation is very important indeed
12:28:22 <tertl4> that was the problem
12:28:38 <tertl4> ok moving on :)
12:30:27 <nart> hi :)
12:31:14 <nart> is there a library capable of handling any sort of audio files ?
12:31:19 <Clint> yes
12:32:18 <nart> Clint: what's its name ?
12:32:52 <nart> Clint: i'm searching through haddock with no luck
12:32:57 <Clint> nart: which audio files would you like to handle and how?
12:33:26 <nart> Clint: mp3/wav/flac/ogg etc...
12:33:47 <nart> Clint: read raw data
12:33:55 <Clint> http://hackage.haskell.org/package/WAVE
12:34:19 <Peaker> edwardk, so now that BerkeleyDB is not a dependency, does it install cleanly?
12:34:37 <daniel_-> just finished with writing my first haskell program, anyone care to take a look if there is anything i should be doing different? https://github.com/danielX/mastermind-haskell/blob/master/Main.hs
12:37:00 <nart> Clint: thanks, but that one handles only wave files, i was thinking more about a lib that provide the same interface for every kind of audio formats
12:37:18 <edwardk> installing
12:37:22 <Clint> ah, then no, i don't think there's one of those
12:37:25 <Phlogistique> @src nub
12:37:26 <lambdabot> nub = nubBy (==)
12:37:32 <Phlogistique> @src nubBy
12:37:33 <lambdabot> nubBy eq []             =  []
12:37:33 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
12:38:11 <pooya72> daniel_-: congrats! as a haskell noob I know what a learning curve it's been!
12:38:20 <however> Phlogistique: i was thinking the same :) i guess nub doesn't change anything for a list that has only unique elements
12:38:37 <ski> daniel_- : instead of `div' and `rem', use `div' and `mod' (or `divMod'), or `quot' and `rem' (or `quotRem')
12:38:46 <daniel_-> thanks pooya72 but i haven't dared touch any of the monads except for the IO monad
12:38:51 <daniel_-> yet
12:39:01 <pooya72> daniel_-: same here!
12:39:13 <ski> s/(points a n) == b/points a n == b/
12:40:23 <ski>   check hs n = all (\(a, b) -> points a n == b) hs
12:40:36 <Peaker> daniel_-, if you use hlint (or paste in hpaste) you'll get some style hints about your code
12:40:38 <ski>   check hs n = (`all` hs) $ \(a, b) -> points a n == b  -- alternate version
12:41:06 <ski> (`flip' could also be used there, instead of the right section)
12:41:22 <daniel_-> ok, i just wanted a easy way to terminate the recursion instantly on false :)
12:41:23 <Eduard_Munteanu> daniel_-: you might want to use a Set instead of lists and nub
12:41:37 <Eduard_Munteanu> @hoogle Set
12:41:38 <lambdabot> Data.Bits setBit :: Bits a => a -> Int -> a
12:41:38 <lambdabot> Control.OldException setUncaughtExceptionHandler :: (Exception -> IO ()) -> IO ()
12:41:38 <lambdabot> Data.Set module Data.Set
12:41:51 <ski> s/(read n') > 9876/read n' > 9876/
12:41:58 <daniel_-> have only heard about that it exists something called a Set, no idea what it is though
12:42:01 <ski> also, better declare the magic constant `9876' with a name ?
12:42:04 <however> daniel_-: nice work :) in function count, the definitions of rs and fs differ only in a single Char. you could make a function "f c = length $ elemIndices c str", so that the main equation becomes (f 'R') * 10 + (f 'F')
12:42:14 <Peaker> daniel_-, instead of:   not $ ... == ...   use: /=
12:42:34 <mcstar> however: i deleted the .conf from .ghc manually, recached the user packages, and problem solved
12:42:48 <ski> s/(read new) > 9876/read new > 9876/
12:42:52 <mcstar> in the meantime, ita got 2 goals, im not sure if they can recover
12:42:56 <daniel_-> however, thats true, thanks
12:42:59 <Peaker> daniel_-, instead of mkRand as a func of Bool, why not make two different functions?
12:43:15 <Eduard_Munteanu> daniel_-: see http://www.haskell.org/ghc/docs/6.12.3/html/libraries/containers-0.3.0.0/Data-Set.html for example. They're like math sets: you can add stuff to it and check membership
12:43:23 <Eduard_Munteanu> More efficiently, that is.
12:43:38 <Peaker> daniel_-, instead of:   if not ... then a else b         just reverse the conditions:   if ... then b else a
12:44:08 <Eduard_Munteanu> Also, see IntSet if you're only dealing with Ints.
12:44:13 <Eduard_Munteanu> That's even more efficient.
12:44:14 <mcstar> Peaker: its compiling
12:44:33 <ski> instead of `"...\"" ++ repr ++ "\"..."' you could consider whether you'd want `"..." ++ show repr ++ "..."' instead
12:44:35 <Peaker> mcstar, what's compiling?
12:44:39 <mcstar> bottle
12:44:46 <Peaker> mcstar, ah, it didn't compile before?
12:44:54 <mcstar> i had package problems
12:44:59 <ski> also, in the end of `uMode' you don't even wrap in quotes -- why the inconsistency ?
12:45:46 <edwardk> peaker: bottle has almost as many deps as trifecta. still installing ;)
12:46:05 <daniel_-> wrap in quotes?
12:46:07 <however> daniel_-: "f x y = if cond then ..." can also be written with guards as "f x y | cond = ...". that's a matter of taste it guess. it doesn't really shorten things very much
12:46:54 <ski> daniel_- : `"\tGives you ->\t\"" ++ repr ++ "\""' vs. `"\tGives you ->\t" ++ repr  ++ "\nCongratulations, you won!"'
12:46:54 <daniel_-> oh
12:47:01 <daniel_-> yea
12:47:17 <daniel_-> added it
12:47:22 <mcstar> those 'where's are indented way way in
12:47:27 <daniel_-> i first added it to Gives you ->
12:47:38 <daniel_-> because when it was just empty it looked strange
12:47:44 <daniel_-> instead of Gives you -> ""
12:47:49 <edwardk> bottle-0.1 depends on FTGL-1.333 which failed to install. graphics-drawingcombinators-1.4.3 depends on FTGL-1.333 which failed to install.
12:47:50 <Peaker> edwardk, hehe
12:48:00 <edwardk> so after all that, no bottle for me
12:48:01 <mcstar> Peaker: isntalled
12:48:17 <shachaf> edwardk: Oh, getting bottle set up?
12:48:21 <Peaker> edwardk, how did it fail?
12:48:21 <shachaf> I managed to do that once.
12:48:25 <shachaf> It was an adventure.
12:48:26 <Peaker> edwardk, probably just missing ftgl c lib?
12:48:27 <edwardk> brew installing ftgl
12:48:35 <edwardk> yeah
12:48:43 <Peaker> shachaf, I made it much easier today, wrote a little key/value store hash-on-file to replace BerkeleyDB
12:48:51 <ski> > text $ let repr = "hello\tthere" in "begin ->\t" ++ repr ++ "\t<- end"
12:48:53 <lambdabot>   begin ->        hello        there        <- end
12:48:57 <ski> > text $ let repr = "hello\tthere\"" in "begin ->\t" ++ repr ++ "\"\t<- end"
12:48:58 <daniel_-> and where i can reverse the conditions and not use a "not" i just felt that it would look better with the flow instead of having them in the else clauses
12:48:59 <Peaker> mcstar, you can run dist/build/Editor/Editor
12:49:00 <lambdabot>   begin ->        hello        there""        <- end
12:49:05 <ski> > text $ let repr = "hello\tthere" in "begin ->\t" ++ show repr ++ "\t<- end"
12:49:07 <lambdabot>   begin ->        "hello\tthere"        <- end
12:49:36 <ski> daniel_- : compare those variants above ^
12:49:42 <ThePro> > repeat "LOL "
12:49:44 <ski> sorry, the missle one should be
12:49:44 <lambdabot>   ["LOL ","LOL ","LOL ","LOL ","LOL ","LOL ","LOL ","LOL ","LOL ","LOL ","LOL...
12:49:52 <shachaf> Peaker: What's wrong with BerkeleyDB?
12:49:52 <ski> > text $ let repr = "hello\tthere" in "begin ->\t\"" ++ repr ++ "\"\t<- end"
12:49:54 <lambdabot>   begin ->        "hello        there"        <- end
12:50:05 <ski> shachaf : extra dep, iiuc
12:50:11 <however> daniel_-: if the "if not" is a conscious decision, then it's fine. it's just that you shouldn't write that by accident
12:50:14 <byorgey> ThePro: there is also 'cycle'
12:50:15 <Peaker> shachaf, it's really hard for people to install.. most problems were from that dep
12:50:17 <byorgey> > cycle "LOL "
12:50:18 <lambdabot>   "LOL LOL LOL LOL LOL LOL LOL LOL LOL LOL LOL LOL LOL LOL LOL LOL LOL LOL LO...
12:50:33 <shachaf> Writing a key-value store so that people don't have to install a package seems kind of excessive...
12:50:33 <ski> s/(read n) + 1/read n + 1/
12:50:40 <ThePro> byorgey: ah, good to know
12:50:41 <Peaker> shachaf, took a few hours :)
12:51:00 <ThePro> byorgey: whats the difference between repeat and cycle?
12:51:06 <ski> daniel_- : btw, all i've said above has been directed to you
12:51:11 <Peaker> shachaf, it's a tiny one -- it doesn't do GC (so old key/value pairs are not freed up), and it doesn't grow the hash table..
12:51:12 <shachaf> I guess you're not using a whole lot BDB's features.
12:51:14 <daniel_-> im just a bit confused
12:51:18 <daniel_-> trying to understand
12:51:25 <byorgey> ThePro: you can see the difference from the above examples, though the fact that Strings have special notation is perhaps confusing the issue.
12:51:29 <byorgey> ThePro: here's another example:
12:51:33 <byorgey> > repeat [1,2,3]
12:51:34 <lambdabot>   [[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1...
12:51:37 <Peaker> shachaf, nope. I tried using transactional updates but it was very slow..
12:51:38 <byorgey> > cycle [1,2,3]
12:51:39 <lambdabot>   [1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,...
12:51:53 <byorgey> also, look at their types
12:51:55 <byorgey> @type repeat
12:51:56 <lambdabot> forall a. a -> [a]
12:51:57 <byorgey> @type cycle
12:51:59 <lambdabot> forall a. [a] -> [a]
12:52:02 <Peaker> shachaf, also, I'm not sure why bdb wants the "Env" stuff
12:52:04 <ThePro> byorgey: ah, so repeat will just make new lists
12:52:22 <ski> daniel_- : finally, i'd personally replace all uses of `$' there by brackets (and perhaps also `.' in some cases) (for my `all' suggestion, i'd keep the `$')
12:52:30 <ThePro> byorgey: and cycle makes one list
12:52:38 <byorgey> repeat creates a list with an infinite number of copies of a single element.
12:52:48 <byorgey> cycle takes a list and repeats it end-to-end
12:52:57 <daniel_-> yeah, the all one seems better than recursive IF, ELSE
12:53:00 <shachaf> repeat a = cycle [a]
12:53:00 <mcstar> Peaker: it eats my cpu and doesnt look good, and im flooded with FTGL warning: NULL pointer in _ftglRenderFont
12:53:11 <hpaste> fragamus pasted “concatenated list thingy” at http://hpaste.org/70691
12:53:18 <edwardk> i get a blue cursor on the eft that flits from the top to thebottom of the screen when i cursor up and down and thats about it
12:53:24 <ski> daniel_- : others are more lenient re `$'s -- i think mostly they add ugliness, commonly for little gain
12:53:28 <byorgey> and cycle xs = concat (repeat xs)
12:53:35 <fragamus> can this be simplified?
12:53:42 <edwardk> its like the bastard child of an editor and pong
12:53:55 <daniel_-> just that im better at using the $ than the (.)
12:54:08 <Peaker> mcstar, hmm.. then there are two problems
12:54:17 <ski> edwardk : .. sounds like a plan :)
12:54:19 <daniel_-> i often tend to fail while writing functions with .
12:54:25 <Peaker> mcstar, A) It relies on sync-to-vblank for CPU use throttling, and it's probably disabled
12:54:36 <byorgey> fragamus: can what be simplified?
12:54:37 <Peaker> mcstar, B) You're using FTGL from hackage which I just fixed -- it lacks error checking on FTGL lib calls
12:54:52 <fragamus> http://hpaste.org/70691
12:54:54 <Peaker> mcstar, B is caused by a bad font file name, take a look at "defaultFont" in Main.hs
12:55:06 <fragamus> I just feel like I'm not doing it right
12:55:09 <edwardk> i'm getting the same thing
12:55:11 <Peaker> I wonder how programs are supposed to figure out a font filename
12:55:26 <ski> fragamus : replace `if <condition> then [<element>] else []' with `[<element> | <condition>]'
12:55:38 <edwardk> i get no text, just the flood of FTGL warning: NULL pointer in _ftglRenderFont
12:55:38 <Peaker> edwardk, We're currently hard-coding a font file name and it's probably wrong
12:55:39 <fragamus> oh cool
12:55:49 <Peaker> edwardk, and the FTGL lib from hackage doesn't do error-checking
12:56:07 <Peaker> edwardk, can you edit defaultFont in Main.hs?  I wonder how to get a non-hard-coded font file name
12:56:11 <ski> (that's a guard-only list comprehension -- there is no requirement of having any generator)
12:56:20 <however> fragamus: also, check hlint. hpaste runs it automatically for you (see the link you sent)
12:56:23 <edwardk> to what?
12:56:32 <ski> > [() | ]  -- doesn't work, though :(
12:56:34 <lambdabot>   <no location info>: parse error on input `]'
12:56:35 <Peaker> edwardk, any TTF you could use instead
12:57:10 <kallisti> is there a full references for persistent TH syntax?
12:57:15 <edwardk> trying that
12:57:20 <Peaker> edwardk, you are on OS X, right? do you have any TTF files in /Library/Fonts ?
12:57:29 <edwardk> yeah i swapped to a different Arial
12:57:45 <Peaker> I wonder how a program is supposed to find fonts in the general case
12:58:08 <mcstar> Peaker: how can i rebuild the source with cabal?
12:58:19 <Peaker> mcstar, cabal build -- will regenerate dist/build/Editor/Editor
12:59:00 <mcstar> ah ok
12:59:00 <edwardk> swapping from Arial.ttf to Arial Unicode.ttf did the trick
12:59:05 <mcstar> i thought it just relinked the binary
12:59:10 <mcstar> yeah
12:59:15 <mcstar> there is text!
12:59:36 <mcstar> Peaker: there is a diagonal line on your color textures
12:59:47 <Peaker> mcstar, where? Can you screenshot?
13:00:44 <mcstar> Peaker: http://i.imgur.com/rYi5Z.png
13:01:05 <Peaker> edwardk, there's no pattern-matching yet.. you can try to write factorial via "if". Press enter on stuff to see the type. type variables have to be instantiated explicitly (for now)
13:01:28 <Peaker> mcstar, weird!
13:01:39 <edwardk> i'll be honest its pretty clunky moving from hole to hole and trying to navigate
13:01:43 <Peaker> mcstar, oh, it's probably an artifact of OpenGL on your machine?
13:01:53 <zzing> When I have something like f x y = z  and then I want to put a where clause on the next line, which element does where have to line up with? (x, y, or =?)
13:01:53 <ski> Peaker : hm, re structural editor, did i mention Alfa to you yet ?
13:02:03 <Peaker> edwardk, if you want to move far away, you can try Ctrl+Shift+direction key
13:02:04 <irene-knapp> Alfalfa?
13:02:22 <Peaker> edwardk, We want to improve navigation, yeah, at the very least align the stuff up
13:02:29 <Peaker> ski, I vaguely recall that
13:02:53 <mcstar> it feels a bit like ktouch, when i learned touch typing, the sliding text...
13:03:03 <ski> @where Alfa
13:03:03 <lambdabot> Proof editor, using Agda1 proof engine/checker, at <http://www.cse.chalmers.se/~hallgren/Alfa/>,(broken) <http://www.cs.chalmers.se/~hallgren/untested>,<http://ogi.altocumulus.org/~hallgren/untested>
13:03:03 <lambdabot> ,<http://ogi.altocumulus.org/~hallgren/untested/for_Linux/alfa-041029-bin-i386-Linux-RedHat9.tar.gz>,<http://ogi.altocumulus.org/~hallgren/untested/Source_code/alfa-050126.src.tar.gz>. Also see `
13:03:03 <lambdabot> Agda',`Fudgets',`GF'
13:03:08 <ski> irene-knapp ^
13:03:28 <Peaker> edwardk, we've got lots of visual noise in there yet (e.g: probably too many inferred types) and it's not yet aligned nicely
13:04:23 <irene-knapp> ah I see
13:04:26 <Peaker> edwardk, mcstar: You can create branches with Ctrl+S and checkout the branches by navigating
13:04:27 <edwardk> i guess i had an easier time since i wasn't inferring types, just dealing with syntax and grammar highlighting
13:04:53 <Peaker> edwardk, what GUI toolkit did you use?
13:04:56 <edwardk> i'll show this to one of the structured editing guys at work
13:05:01 <edwardk> xul/mathml/html
13:05:03 <byorgey> Peaker: is there a video up somewhere demonstrating bottle?
13:05:16 <edwardk> that way i didn't have to build some random pile of libs
13:05:17 <Peaker> edwardk, oh, right, I forgot. Yeah, we also wrote our own GUI toolkit here, so it took a while, and structural revision control
13:05:20 <byorgey> just curious since I'm not willing to put in the effort to get it built just yet =)
13:05:36 <Peaker> byorgey, not yet, we feel it's not yet passed the necessary awesomeness threshold.. too preliminary
13:05:39 <edwardk> yeah a video would be a lot more useful than me flailing around
13:05:40 <mcstar> Peaker: i feel a bit like Chris Pirillo's dad must have felt when he put his dad in front of an Ubuntu system, and made his old man suffer
13:05:43 <byorgey> sure, fair enough
13:06:03 <edwardk> even a quick 'why you should care about bottle video' with just a few examples
13:06:03 <Peaker> edwardk, heh, ok, maybe it's too preliminary to show yet
13:06:33 <edwardk> right now the presentation makes it awkward enough to dig into that it is hard to get past the 'give a shit' threshold ;)
13:07:27 <Peaker> edwardk, well, I was hoping some of the non-inherent awkwardness would be easy to ignore, but from multiple examples, it is apparently not very easy :)
13:09:50 <Luke> is anyone else having problems with latest stylish-haskell + emacs haskell-mode?
13:10:00 <Luke> i'm getting "no haskell-session defined" when i try to run it
13:10:26 <ThePro> is here anyone hwo is learning for non university reasons? :p
13:10:27 <Luke> let: Symbol's value as variable is void: haskell-session -- to be precise
13:10:35 <ThePro> *learning haskell
13:10:36 <edwardk> many of us did
13:10:48 <adimit> ThePro: me :-)
13:10:55 <adimit> and I guess many many other people.
13:10:59 <xarch> yes
13:11:01 <however> thepro: yes. xmonad was the gateway drug for me
13:11:02 <Yarou> is there any reason not to learn for non-university reasons is a better question
13:11:07 <Peaker> edwardk, though I think the UI toolkit is already cute and much nicer (e.g: the animations when you switch branches)
13:11:12 <adimit> however: as it was for me!
13:11:23 <adimit> Yarou: you might not have the time.
13:11:26 <Peaker> edwardk, and the flynav (ctrl+shift navigation) is fun :)
13:11:52 <edwardk> i look forward to the video ;)
13:11:55 <edwardk> bbiab
13:12:15 <byorgey> Luke: I think you need to load it first with C-c C-l
13:12:24 <ThePro> i'm asking because i have to learn it for university
13:12:34 <ThePro> and it is the craziest language i ever seen
13:12:50 <Peaker> oops, I fixed a major bug w.r.t deleting params now (pushed)
13:12:54 <Luke> byorgey: same problem after loading
13:13:20 <adimit> ThePro: you clearly don't know Piet, brainfuck or whitespace.
13:13:39 <ThePro> adimit: i heard of it
13:13:56 <ThePro> adimit: but that are not serious languages
13:13:59 <ThePro> like haskell
13:14:05 <ThePro> haskell IS serious
13:14:09 <adimit> mighty serious.
13:14:10 <ThePro> and still crazy :D
13:14:23 <byorgey> Luke: hmm, dunno then, sorry
13:14:28 <Luke> np
13:14:42 <jmcarthur> i think most non-haskell languages are way crazier than haskell is
13:17:31 <however> ThePro: haskell is crazy, but it is ultimately very rewarding. i've more or less lost interest in all mainstream languages (python, perl, java ...). just don't get intimidated by the math jargon (monoids and categories and whatnot). maybe it helps to view them as random silly names
13:18:15 <Peaker> ThePro, when you say "crazy", do you mean "awesome" ? :)
13:18:54 <Peaker> ThePro, Almost all of Haskell makes good sense, so in that sense it isn't "crazy". It makes other languages seem "crazy" in that they lack much of that sense :)
13:20:26 <Luke> anyone else successfully using haskell-mode + stylish-haskell?
13:21:02 <ThePro> Peaker: i mean, i could never imagine creating a GUI program with haskell
13:21:23 <ThePro> Peaker: how can this be possible on a nonimperative way?
13:21:55 <Luke> ThePro: give it a try and see what you get stuck on
13:22:10 <Luke> ThePro: check out functional reactive programming (FRP)
13:22:15 <ThePro> Peaker: i mean, i need things like a message loop for the gui, since haskell only knows recursion the stack will blow up sooner or later
13:22:39 <Luke> ThePro: haskell has tail call optimization
13:22:46 <c_wraith> ThePro: that's an odd assertion that does not reflect reality
13:23:01 <ciaranm> uh oh, Luke's about to get shouted at
13:23:10 <c_wraith> why?  that's certainly true
13:23:12 <Luke> ?
13:23:45 <c_wraith> lack of tail-call optimization in scala and clojure is a bug due to being implemented on the JVM.  every other real functional language has it.
13:23:47 <jmcarthur> ThePro: haskell is just fine at imperative programming
13:24:02 <jmcarthur> it's just that imperative programming is crazy, so we prefer to avoid it if we can
13:24:06 <jmcarthur> :)
13:24:10 <MostAwesomeDude> ThePro: Imagine that somebody else wrote the event loop, and you only write code that responds to events.
13:24:17 <Peaker> ThePro, I'm working on a non-imperative GUI in Haskell
13:24:20 <MostAwesomeDude> ThePro: And imagine that that somebody else already thought of your complaints. :3
13:24:34 <Peaker> ThePro, tail-recursions don't blow up, and we've got loops in Haskell that are implemented on top of recursion
13:24:50 <Peaker> ThePro, and I do have an imperative main-loop, but most of the code is non-imperative
13:25:09 <jmcarthur> tail recursion can blow up if it's insufficiently strict
13:25:35 <optimight> Can FRP based (pure haskell) GUI can be very attractive and beautiful to attract mass of people?
13:25:44 <jmcarthur> i think the potential is there
13:26:55 <however> i don't think being imperative is automatically a flaw and inferior to being functional. however being impure is much more dangerous
13:27:21 <however> optimight: yes, if you studied it and got used to it for several years, it seems attractive :-)
13:27:32 <optimight> Any haskell based GUI application  for ready refeence?
13:27:42 <jmcarthur> i think of impurity and imperativeness as being roughly the same thing
13:27:53 <zzing> @src maximum
13:27:54 <lambdabot> maximum [] = undefined
13:27:54 <lambdabot> maximum xs = foldl1 max xs
13:27:58 <zzing> @src max
13:27:58 <ThePro> hm
13:27:59 <lambdabot> max x y = if x <= y then y else x
13:28:13 <ThePro> i will just continue learning
13:28:47 <ThePro> haskell is a bit hard to understand if you are used to imperative languages
13:28:53 <jmcarthur> this is true
13:28:56 <MostAwesomeDude> You get used to it.
13:29:06 <optimight> @however : It means , until and unless someone used to it , it will not be seem attractive , right?
13:29:07 <lambdabot> Unknown command, try @list
13:29:15 <zzing> A few stabs at it over the last few years has helped me in that regard
13:29:55 <however> optimight: yes, that was the joke i was going for ...
13:30:12 <jmcarthur> some advise to think of functional programs as nothing more than mathematical functions, but unfortunately the operational semantics is still important. this, i think, is what makes it so hard
13:30:20 <parcs`> > 52*177
13:30:21 <lambdabot>   9204
13:30:24 <jmcarthur> because in some sense you still have to think imperatively, but it's hard to know where to draw the line
13:30:42 <jmcarthur> even without laziness, this can be hard
13:30:49 <optimight> @however, Can haskell be integrated with GWT or flex for GUI?
13:30:50 <lambdabot> Unknown command, try @list
13:33:29 * hackagebot index-core 1.0.0 - Indexed Types  http://hackage.haskell.org/package/index-core-1.0.0 (GabrielGonzalez)
13:33:37 <however> optimight: i'm not sure, i haven't worked with gui stuff much in haskell. there are some haskell gtk bindings however. not sure how good they are
13:33:38 <optimight> How can we achieve GUI for a haskell application which can impress common mass of people?
13:35:09 <zzing> If I have an IO String and I want to convert that into an IO Maybe String is there a method of doing this without introducing a do block or something similar? The approximate that I want to do is this: return $ Just $ readCachedFile cache filename        it is just that readCachedFile returns an IO String.
13:35:31 <Botje> zzing: fmap or liftM
13:35:44 <zzing> :t liftM
13:35:45 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
13:36:03 <zzing> @src liftM
13:36:04 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
13:36:18 <Botje> so Just `liftM` readCachedFile ...
13:37:06 <however> zzing: you can also write "Just <$> readCachedFile" (alias for fmap)
13:38:29 <zzing> oh I like that, what magic is this!
13:39:42 <zzing> :t <$>
13:39:44 <lambdabot> parse error on input `<$>'
13:39:48 <zzing> :t (<$>)
13:39:50 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
13:40:06 <zzing> :t Just
13:40:08 <lambdabot> forall a. a -> Maybe a
13:40:38 <MostAwesomeDude> :t just
13:40:39 <lambdabot> Not in scope: `just'
13:40:46 <MostAwesomeDude> Oh, I guess that wart was removed?
13:40:53 <zzing> what wart?
13:41:08 <MostAwesomeDude> Could have sworn there was just = Just -- somewhere in the Prelude-ish.
13:41:15 <MostAwesomeDude> Or maybe it's in Data.Maybe.
13:41:18 * ski can't recall any such
13:41:45 <MostAwesomeDude> Hm, nope. Am I thinking of another language? :T
13:41:49 <MostAwesomeDude> Now this is gonna bug me.
13:42:23 <however> zzing: you can think of <$> as "unwrap, apply function, wrap". so it's basically "x <- readCached ; return $ Just x".
13:42:42 <ski> zzing : for more confusing(?) code :  return <$> readCachedFile cache filename
13:43:14 <however> oh, Maybe monad? yeah that's perfectly unconfused ... ;-)
13:43:27 <zzing> however, I was just working on the types here on paper…    Just <$> readCachedFile cache filename   becomes   <$> :: (a -> Maybe a) -> IO String -> IO Maybe a     (not sure where the a will come from )
13:45:04 <zzing> @src (<$>)
13:45:05 <lambdabot> f <$> a = fmap f a
13:45:12 <zzing> @src fmap
13:45:12 <however> zzing, in this case "a" will be String. you have this function a -> Maybe a (i.e. String -> Maybe String), and then "inside" the IO you apply it to the String, giving an IO (Maybe String)
13:45:12 <lambdabot> Source not found. Are you on drugs?
13:45:53 <MostAwesomeDude> zzing: fmap is a type class function; its source varies for each Functor.
13:46:31 <zzing> however, oh yes, I missed where a was used in the second parameter so I forgot to put it in the all instances
13:46:32 <MostAwesomeDude> zzing: For Maybe: fmap f Nothing = Nothing; fmap f (Just x) = Just (f x)
13:46:32 <however> zzing: it's like how map applies a function "inside" a list (to each thing in the list. the IO of course has only one thing in it)
13:46:38 <ski> ThePro : learning a new programming paradigms will feel a bit like learning to program all over again (and you will have to unlearn stuff) -- you should also try learning Logic Programming :)
13:47:09 <zzing> Prolog is awesome
13:48:11 <zzing> How might I expand my knowledge in this area, it is obviously extremely useful yet it is very mysterious :-)
13:48:24 <mcstar> Peaker: a video tutorial would be a good next step, im not sure what im supposed to do :S
13:48:35 <ski> @type (<$>) `asTypeIn` \(<$>) -> Just <$> getContents
13:48:36 <lambdabot> (String -> Maybe String) -> IO String -> IO (Maybe String)
13:49:21 <ThePro> ski: true, i am feeling like i have never programmed before
13:50:19 <zzing> ThePro, ever done anything with C++ and STL?
13:51:15 <ThePro> zzing: yep, that predicate stuff is very similar to haskell
13:51:21 <ski> ThePro : however, when you've learned one FPL (like Haskell, e.g.), you will be able to learn other FPLs (like e.g. Scheme, Clean, Erlang, SML, O'Caml, F#) than otherwise
13:51:22 <mcstar> Peaker: did you do the opengl 'widgets' or used a library
13:51:39 <zzing> ThePro, the whole STL is built around functional programming concepts
13:51:48 <zzing> <functional> gives that way :-)
13:51:53 <zzing> *away
13:51:57 <ThePro> ah
13:52:02 <ThePro> now i understand
13:52:10 <zzing> It was actually designed by a mathematician
13:52:18 <mcstar> stl is build around templates and iterators
13:52:29 <MostAwesomeDude> std::accumulate
13:52:38 <ski> ThePro : well, the recursion, the pattern-matching and the immutable variables are similar between Haskell and Prolog -- however Prolog has full unification with logic variables and backtracking
13:52:47 <zzing> I don't like the names they chose, like MostAwesomeDude 's example
13:53:02 <MostAwesomeDude> zzing: std::remove_if
13:53:02 <zzing> template metaprogramming is actually a purely functional programming language in itself
13:53:03 <ski> zzing : maybe get a prolog book ? (did you check out the tutorial "Learn Prolog Now!" yet ?)
13:53:18 <mcstar> zzing: that doesnt mean much in practice
13:53:31 <zzing> ski, yes looked at that
13:53:34 <zzing> didn't go too far in yet
13:53:56 <ski> there's also ##prolog here on freenode ..
13:55:10 <zzing> mcstar, I have two friends (and at one time my professors) doing graduate level work creating functional programming stuff (like monads) using C++11 and heavily using metaprograming templates. The stuff they are doing is amazing.
13:55:39 <mcstar> why would anyone want to do that?
13:55:44 <mcstar> besides wasting time
13:56:15 <ski> possibly using non-primitive monadic effects ?
13:57:07 <mcstar> at best, they are badly copying/implementing already known techniques
13:57:31 <ski> imperative languages can basically be seen as having implicit monadic effects from a single monad (which is a combination of various effects like state and exception, often concurrency, sometimes continuations)
13:57:34 <however> mcstar, once c++ is infected with monaditis, it will get a reputation of being incomprehensible and mathy and esoteric. people will stop using it, which makes the world better
13:57:50 <zzing> mcstar, I am not the one to defend their work, but if it didn't have merit, then they woulnd't be doing it
13:58:01 <ski> using explicit monads (as Haskell is doing) allows you to program your own effects (like parsing, e.g.)
13:58:03 <mcstar> zzing: not necessarily true
13:58:03 <avpx> however: C++ being incomprehensible? Why I never.
13:58:03 <lambdabot> avpx: You have 1 new message. '/msg lambdabot @messages' to read it.
13:58:26 <zzing> mcstar, knowing them personally, I would promote that feeling.
13:58:29 <MostAwesomeDude> mcstar: You're not really familiar with academia? :3
13:58:41 <mcstar> the opposite
13:58:42 <avpx> C# has some interesting monadic features
13:58:45 <avpx> (that is to say, LINQ)
14:00:40 <ski> in case the language has composable continuations (like Scheme or SML/NJ,Mlton), one can actually make such explicitly-programmed monadic effects be used implicitly, see the papers "Representing Monads" (1994-01) and "Representing Layered Monads" (1999-01) by Andrzej Filinski at <http://www.diku.dk/~andrzej/papers/>
14:01:20 <ski> (i.e. that allows one to add any explicitly programmed monad as an *implicit* *side*-effect to the language)
14:03:22 <Philonous> Now we only need to add shift/reset to java.
14:03:56 <ski> well, i suppose proper tail recursion is also a pre-requisite
14:04:59 <zzing> Back to the description of <$> as 'unwrap, apply function, and wrap' would it be more specific to say in 'a <$> b' to unwrap b, 'a b', wrap result
14:05:28 <Philonous> Right. I still wonder how Clojure/Scala cope with the lack of that
14:06:10 <mcstar> Philonous: clojure has recur or something iirc
14:06:19 <mcstar> you cant put it anywhere except tail position
14:06:38 <mcstar> (thats from my brief excursion to clojure land months ago)
14:06:52 <however> zzing: yeah, that's what i meant. you can also think of fmap/<$> as applying a function inside the container, replacing the contained thing
14:06:57 <ThePro> > let qsortOneLine s = case s of{[]->[];(x:xs)->qsortOneLine [y | y<-xs, y<x] ++ x : qsortOneLine [y | y<-xs, y>=x]} in qsortOneLine [5,1,3,4,6,9,12,11,19]
14:07:00 <lambdabot>   [1,3,4,5,6,9,11,12,19]
14:07:04 <ThePro> lol
14:07:18 <avpx> I don't totally like thinking of fmap as unwrapping, applying, and rewrapping
14:07:21 <MostAwesomeDude> > sort [5,1,3,4,6,9,12,11,19]
14:07:22 <lambdabot>   [1,3,4,5,6,9,11,12,19]
14:07:26 <zzing> however, I think I can understand that intuitively now. I thank you.
14:07:26 <avpx> It assumes that the contained type *can* be unwrapped
14:08:01 <zzing> avpx, how else would you term it so it was still intuitive?
14:08:03 <Philonous> ThePro:  NB, that's not quicksort
14:08:06 <however> zzing, you're welcome :) for a more organzied discussion of it, check out typeclassopedia
14:08:11 <however> @where typeclasso
14:08:12 <lambdabot> I know nothing about typeclasso.
14:08:14 <however> @where typeclassopedia
14:08:15 <avpx> zzing: I think it's fair to call it a generalized map
14:08:15 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
14:09:05 <avpx> zzing: It's a function that allows you to apply things to the type contained in your Functor, and which can be composed sensibly
14:09:07 <zzing> avpx, I get the generalized map, but not linking it with monads - this is one of the spots that is dark for me
14:09:31 <avpx> zzing: I think a good exercise in learning monads is to take a break from thinking of them as return and bind (>>=)
14:09:37 <ThePro> Philonous: sort != quicksort?
14:09:43 <avpx> zzing: And think about them in terms of fmap, return, and join
14:10:15 <zzing> What being join?
14:10:17 <avpx> zzing: Remember that every Monad is a Functor, though that's not really how it's written in the type system (a bit of a shortcoming of the Haskell standard library)
14:10:32 <Philonous> ThePro:  The "qsortOneLine" you just gave is not quicksort.
14:10:47 <avpx> zzing: And a Functor is just something you can sensibly do fmap to, that is, you can apply functions inside of it and you can compose these functions so that fmap f . fmap g = fmap (f . g)
14:10:56 <ThePro> Philonous: hm, i just copied it from here: http://en.literateprograms.org/Quicksort_%28Haskell%29
14:11:32 <avpx> zzing: A Monad is a functor endowed with return, which lets you take the contained type and put it inside the container, and join, which lets you flatten a level of monadic structure
14:11:55 <Philonous> Yes, the site is wrong. This is not quicksort.
14:11:56 <avpx> zzing: For instance, join for lists is just concatenation. For Maybes it's pretty intuitive too.
14:12:15 <avpx> zzing: Just Just x goes to Just x. Nothing goes to Nothing. Just (Nothing) goes to Nothing.
14:12:20 <mcstar> http://augustss.blogspot.hu/2007/08/quicksort-in-haskell-quicksort-is.html
14:13:44 <Philonous> ThePro:  Quicksort is necessarily in-place.
14:13:59 <mauke> depends on your definition of "quicksort"
14:14:01 <avpx> zzing: http://cdsmith.wordpress.com/2012/04/18/why-do-monads-matter/
14:14:15 <avpx> That's a good reference. Anyway, later folks.
14:14:17 <zzing> Very timely
14:14:21 <zzing> thank you avpx
14:14:27 <Philonous> mauke:  I mean the thing Hoare invented
14:14:31 * zzing watches as avpx flies off
14:14:44 <mauke> Philonous: you mean the thing that didn't use recursion?
14:15:09 <mcstar> i dont think you get the same complexity with a mutable version
14:15:22 <mcstar> damn, immutable
14:15:50 <mauke> you do
14:16:03 <k00mi> zzing: you could read the typeclassopedia: http://www.haskell.org/haskellwiki/Typeclassopedia
14:16:09 <mcstar> but not with the naive one, thats for sure
14:16:27 <zzing> I am going to have to now
14:16:33 <mauke> mcstar: why not?
14:16:35 <zzing> I cannot escape theory and still use haskell
14:17:36 <k00mi> indeed :)
14:17:57 <mcstar> mauke: the filter traverses the whole list for example
14:18:06 <mcstar> on both sides
14:18:18 <mauke> ok, so that's O(2 * N)
14:19:04 <mcstar> theres a lot of concatenation
14:19:25 <mcstar> this is probably better in haskell than in unpure functinal languages
14:19:32 <mauke> ok, so that's O(3 * N)
14:19:33 <MostAwesomeDude> What's the cost of a concat?
14:19:34 <mcstar> inpure*
14:19:47 <MostAwesomeDude> *strict, really; lazy lists help.
14:20:16 <Philonous> MostAwesomeDude:  O(size of the left list)
14:20:23 <mcstar> mauke: ill sketch this for myself
14:20:30 <mcstar> interrogate me after XD
14:20:51 <MostAwesomeDude> So, here's the practical answer. Feel free to get angry at me for this.
14:20:59 <MostAwesomeDude> The computation's dominated by the cost of comparisons.
14:21:31 <MostAwesomeDude> The number of comparisions is pretty obviously a log n situation, if you consider how the lists are constantly subdivided.
14:21:38 <Philonous> mcstar:  It's not about asymptotic complexity. There are many n * log n-algorithms.
14:21:53 <MostAwesomeDude> I think you guys are getting too worked up about this because "short and simple can't possibly be fast."
14:24:59 <spree> http://www.haskell.org/haskellwiki/Haskell_for_multicores
14:25:16 <spree>  $ ghc -O2 -threaded --make fib.hs --doesnt work for me
14:25:28 <spree> -02 isnt recognized and neither is -threaded
14:25:58 <mauke> spree: -O2 is not -02
14:26:05 <however> spree: note that it's capital letter O (for Optimize), not zero
14:26:10 <spree> tried boh
14:26:23 <strager> Are you sure you're running the correct executable?
14:26:39 <strager> What does 'isnt recognized' mean?  Does GHC complain that it's an unknown flag?
14:26:46 <spree> yes
14:26:51 <spree> not an internal command
14:27:03 <spree> external command, program or command file
14:27:03 <however> spree: post the error message you're getting (use hpaste if it's >1 line). also check "where ghc" and "ghc --version"
14:27:11 <Jeanne-Kamikaze> is fib.hs the one line version ?
14:27:21 <spree> yes
14:27:22 <Jeanne-Kamikaze> because it runs as fast as C
14:27:28 <spree> my prompt is in swedish
14:27:28 <Jeanne-Kamikaze> in fact I just trolled a blog post a few days ago
14:27:57 <strager> spree: That means ghc isn't found
14:28:07 <strager> spree: Are you on Linux?  Install the Haskell Platform.
14:28:40 <spree> if i do ghc then i get "no input files" so ghc is found
14:28:46 <spree> win7
14:28:56 <mcstar> mauke: well, it seems to have the same complexity as a mutable quicksort, in that the algorithm has a similar tree structure, but the mutable one moves a minimal number of elements, while the concise/immutable one conses a lot, and recreates the list many times
14:29:17 <mauke> spree: post your command and error message
14:29:30 <however> spree: check "ghc --version"
14:29:34 <mcstar> in a strict language this would be hugely inefficient, in haskell, you can maybe live with it
14:29:53 <Jeanne-Kamikaze> oh, I just realised there are multiple conversations running here
14:30:50 <spree> The Glorious Glasgow Haskell Compilation System, version 7.0.4
14:30:51 <mcstar> like in a multiplexed deep sea cable
14:30:58 <mauke> spree: post your command and error message
14:31:28 <mcstar> MostAwesomeDude: "The computation's dominated by the cost of comparisons." wrt quicksort example?
14:31:42 <Jeanne-Kamikaze> it gets even more fun if you read the chat log backwards
14:31:45 <ski> @tell avpx maybe a better phrase than "unwrap" is something like "step inside" -- with the understanding that what's done at the "contents inside" might actually be done for many sub-values (or none), as with `map' over lists,&c.
14:31:45 <lambdabot> Consider it noted.
14:31:46 <mcstar> i think the consing dominates the time
14:31:46 <MostAwesomeDude> mcstar: WRT sorting, at least in nearly every other language I work in.
14:32:02 <however> spree: on windows, it possibly is "/" instead of "-" (/O2 /threaded)
14:32:03 <MostAwesomeDude> mcstar: It might, for ints at least.
14:32:35 <mcstar> thats weird to hear
14:34:00 <spree> ok now it works i changed from emacs prompt to cmd prompt
14:34:05 <spree> first didnt work then worked...
14:35:03 <Jeanne-Kamikaze> sounds like windows
14:38:16 <spree> both versions are equally fast though...
14:38:30 <spree> oops forgot
14:38:47 <spree> how do i run with +RTS Nx ?
14:39:49 <MostAwesomeDude> @pl t2 x y = 0.5 - (x^2) - (y^2)
14:39:49 <lambdabot> t2 = (. (^ 2)) . (-) . (-) (0 . 5) . (^ 2)
14:39:54 <MostAwesomeDude> Pfft.
14:40:23 <Lemon> is the kind of (forall a. a) really just *?
14:41:06 <Lemon> like there is no distinction between monotypes and polytypes
14:41:26 <spree> how do i link with rtsopts?
14:41:33 <mcstar> --rtsopts
14:42:02 <shachaf> @google how do i link with rtsopts?
14:42:03 <lambdabot> http://www.haskell.org/pipermail/haskell-cafe/2010-December/087070.html
14:42:03 <lambdabot> Title: [Haskell-cafe] GHC 7.0.1 developer challenges
14:44:04 <mcstar> i dont understand why dome start with - instead of --
14:44:13 <mcstar> only 1 letter options supposed to start with -
14:44:29 <mcstar> dome -> do some
14:45:55 <kallisti> I think the problem I'm having with cabal is that it appears to interpret a lack of constraints as "the latest version"
14:46:01 <kallisti> when I want it to mean "no preference"
14:46:23 <kallisti> defalt to the latest version if there's no other constraints.
14:46:27 <kallisti> is that not sensible?
14:47:16 <kallisti> for rapid development, I don't want to sort out constraints in my cabal file. I should just be able to list dependencies and build.
14:49:23 <kallisti> rejecting: persistent-0.9.0.4/installed-a07... (conflict: aeson==0.6.0.2,
14:49:23 <kallisti> persistent => aeson==0.6.0.2/installed-311...)
14:49:42 <spree> cool, it was almost twice as fast on 2 cores!
14:49:59 <kallisti> can someone parse this line?  it looks to me like it's saying "sorry, the version of aeson wanted by persistent conflicts with the same version that's already installed"
14:50:02 <kallisti> which makes no sense.
14:50:32 <kosmikus> kallisti: no, the first one is an uninstalled version
14:50:44 <spree> so how can ghc know what can run on several cores?
14:50:57 <kosmikus> it means it's picked aeson to be 0.6.0.2 from Hackage before
14:51:13 <kallisti> kosmikus: but the version numbers are the same...
14:51:15 <kallisti> why does it matter?
14:51:36 <kosmikus> because of dependencies?
14:51:54 <kallisti> I thought it was showing me the dependencies.
14:51:58 <kallisti> that would be convenient.
14:52:03 <kosmikus> ?
14:52:29 <kallisti> I can't answer that question.
14:52:39 <kosmikus> I don't understand your statement
14:52:55 <kallisti> is it not listing a dependency that conflicts with an installed version?
14:53:11 <kosmikus> it lists you a conflict that explains the rejection
14:53:31 <kallisti> so, yes.
14:53:34 <kosmikus> it says it can't pick the installed version of persistent-0.9.0.4
14:53:46 <kosmikus> because that one depends on the installed version of aeson-0.6.0.2
14:53:52 <kallisti> ah I see.
14:53:59 <kosmikus> but it has already picked aeson to be 0.6.0.2 from Hackage
14:54:08 <kosmikus> why it has picked that one before, I can't tell you
14:54:16 <kosmikus> but that's probably visible someone further up
14:55:29 <kosmikus> i.e., it most likely has explicitly rejected aeson==0.6.0.2/installed-311... further up
14:55:38 <kosmikus> do you have a complete trace?
14:55:40 <kallisti> not explicitly.
14:55:42 <kallisti> one sec
14:55:55 <kallisti> http://sprunge.us/GfIK
14:56:27 <kallisti> kosmikus: was cabal's constraint solver changed to be extremely strict?
14:56:54 <kosmikus> ok, this is a bit strange
14:57:11 <kallisti> I have --upgrade-dependencies enabled if it means anything
14:57:26 <mcstar> kallisti: you have 2 installed versions of aeson
14:57:33 <kosmikus> uh, that might explain it, because I haven't tested it as well
14:57:33 <mcstar> remove one and problem solved
14:57:58 <kallisti> from cabal info aeson:      Versions installed: 0.6.0.2
14:58:20 <kosmikus> kallisti: could you paste -v3 output, too, please?
14:58:31 <kallisti> should I remove --upgrade-dependencies?
14:58:52 <kallisti> well, let's try with it on
14:58:58 <kallisti> so you can get some debug info.
14:59:24 <kallisti> http://sprunge.us/ELLM
14:59:46 <kosmikus> kallisti: thanks. have you tried with --max-backjumps=-1 ?
14:59:52 <kallisti> nope.
15:00:25 <gienah> yesod-platform has lots of == constraints
15:00:34 <kosmikus> ok, so this is an error message bug
15:00:48 <kosmikus> you should report it :)
15:01:16 <kallisti> and then how would I go about fixing my immediate problem?
15:01:24 <kallisti> also what other info would be good for a debug report.
15:01:30 <kallisti> I don't really know what the bug is or how to describe it.
15:01:44 <gienah> yesod-platform has aeson == 0.6.0.2
15:01:49 <kosmikus> -v3 shows in the line labeled _70 why aeson-0.6.0.2/installed-311 was rejected
15:02:02 <kosmikus> that should be included in the error message, too
15:02:42 <kallisti> I can't unregister time or else a lot of things will break.
15:03:20 * kallisti doesn't really understand why another version of time can't be used because an existing one is already installed.
15:03:25 <kosmikus> you could try if --constraint="time installed" helps
15:03:40 <kosmikus> it's not because it's already installed
15:04:06 <zzing> "Conversely, anyone ignorant of the types in their code is doomed to eternal uncertainty."  => Is eternal uncertainty Haskell's equivalent to eternal damnation?
15:04:37 <shachaf> Eternal uncertainty is a fact of life.
15:05:07 <MostAwesomeDude> Ugh, number tree will not stop biting me in the ass.
15:05:50 <kallisti> kosmikus: can you explain what the problem is?
15:06:28 <kallisti> http://sprunge.us/NYfO  also here's with --constraint='time installed'  --upgrade-dependencies -v
15:07:03 <kosmikus> kallisti: the --upgrade-dependencies is almost certainly an extremely bad idea if you depend on yesod-platform
15:07:15 <kallisti> the lack of --upgrade-dependencies doesn't seem to produce different error output now.
15:07:18 <kallisti> before it did
15:07:22 <kosmikus> ok
15:08:16 <kallisti> ah here we go.
15:08:42 <kosmikus> success?
15:09:03 <kallisti> no.
15:09:34 <kallisti> how do I tell it to upgrade the webdriver dependency on attoparsec to the one that yesod-platform wants?
15:10:34 <kosmikus> try adding --constraint="attoparsec == 0.10.1.1"
15:11:00 <kallisti> the constraint on webdriver is 0.10.*
15:11:05 <kallisti> so I don't understand these conflicts.
15:11:21 <roconnor_> do I declare Rank2Types in my .cabal file?
15:12:06 <kosmikus> kallisti: sorry, I don't understand that remark about the constraint on webdriver
15:12:28 <parcs`> roconnor_: extensions: Rank2Types
15:12:49 <kallisti> if I'm reading the error correctly:   webdriver is using the attoparsec-0.10.2.0 version that's installed, but yesod-platform wants 0.10.1.1
15:12:51 <roconnor_> parcs`: Is that depricated?
15:13:09 <kallisti> but the constraint in webdriver's cabal file is attoparsec == 0.10.*
15:13:21 <kallisti> so why is it a conflict?
15:13:32 <kosmikus> because they're different
15:13:44 <kallisti> what is "they"?
15:13:49 <parcs`> roconnor_: i don't think so. if it is 'cabal check' will tell you
15:13:55 <kosmikus> the two versions of attoparsec
15:14:10 <kallisti> but webdriver's constraint allows for yesod-platform's attoparsec dependency.
15:14:18 <kallisti> why must it use the installed version?
15:14:36 <kosmikus> roconnor_: it's not officially deprecated, no. at one point in the future, it might be that RankNTypes will prevail.
15:14:59 <roconnor_> kosmikus: I mean is using extensions in .cabal file deprecated
15:15:13 <kallisti> maybe I should be using cabal dev.
15:15:17 <kosmikus> roconnor_: no, it isn't deprecated.
15:15:55 <kosmikus> kallisti: webdriver can use yesod-platform's version, yes. but the installed version of webdriver doesn't.
15:16:10 <kallisti> right, so it just needs to be reinstalled.
15:16:24 <kosmikus> yes
15:16:34 <kosmikus> that might work
15:16:38 <kallisti> any reason why that can't "just happen"?
15:17:06 <kosmikus> have you tried --max-backjumps=-1 ?
15:17:33 <kallisti> ah, no.
15:17:36 <kallisti> I misread it as =1
15:17:51 <Shou> http://hpaste.org/70693 What's a good way to resolve this? I can change the types of `title' and `write' to end with `IO ()' instead, but is there a better way?
15:18:03 <kallisti> kosmikus: I'm guessing that has the possibility of nontermination?
15:18:16 <kosmikus> yes, or eating all your memory
15:18:35 <kallisti> that's what's happening right now. :P
15:18:40 <kosmikus> ok
15:18:47 <kosmikus> that's a bug that's fixed in the HEAD
15:19:07 <kosmikus> but even so, if you don't get a solution soon, it's unlikely it'll find one
15:19:44 <kosmikus> does installing yesod-platform alone work?
15:20:17 <MostAwesomeDude> Shou: IRC bot? :3
15:20:19 <kallisti> $ cabal install --reinstall webdriver --constraint='attoparsec==0.10.1.1' |& sprunge | xclip
15:20:23 <Botje> Shou: you can alwask ask >>= runReaderT ...
15:20:24 <kallisti> http://sprunge.us/GhJT
15:20:58 <Shou> MostAwesomeDude: Yeah
15:21:06 <kallisti> kosmikus: just "cabal install yesod-platform"  makes a big list of things that will break.
15:22:07 <nobdraisentone> Could it be rewritten (l. 4-9)? http://hpaste.org/70694
15:22:11 <kallisti> so it looks like my webdriver change will only break the currently installed yesod stuff.
15:22:12 <MostAwesomeDude> Shou: I'm not exactly sure what's going on here, but "ask" might really help.
15:22:20 <kallisti> so should I just go through with the change and then fix those packages?
15:22:30 <nobdraisentone> I see some pattern, but it's hard to collapse that routine
15:22:54 <kosmikus> kallisti: I can't fully judge which version of the yesod-platform you want installed in the end
15:23:05 <kosmikus> you apparently have one installed already
15:23:08 <kosmikus> ?
15:23:17 <kallisti> yes, to use the yesod command line utility
15:23:23 <kallisti> which then creates a cabal file with a yesod constraint.
15:23:28 <kallisti> a number of constraints.
15:23:31 <Shou> Doesn't `ask' just grab MetaConfig? I just want to fork the title fetching code so it doesn't block.
15:24:24 <MostAwesomeDude> And then do something when it comes back, right?
15:24:32 <MostAwesomeDude> (Why can't there be a Deferred monad?)
15:24:36 <kallisti> kosmikus: looks like doing a reinstall of webdriver with that attoparsec constraint and all the stuff that was listed to break.
15:24:39 <kallisti> is working.
15:24:42 <kallisti> or at least all of it is being reinstalled.
15:24:49 <kallisti> we'll see if that fixes my problem.
15:25:55 <kosmikus> kallisti: good luck
15:26:23 * kallisti can't help but feel that he shouldn't be having this problem in the first place.
15:27:05 <Shou> MostAwesomeDude: Yeah, what you see in the paste. It just writes the title to the handle. I only need it that time. Could I, say, liftIO it and then lift `title' and `write' into the IO Monad, or maybe just lift `forkIO' itself into Memory?
15:27:32 <kosmikus> kallisti: it's not an easy problem to fix, but we're trying to improve the situation in various ways.
15:27:55 <kallisti> kosmikus: I wouldn't mind helping, but I somehow doubt I would be able to do very much.
15:29:34 <kosmikus> thanks for the offer, but there isn't a direct shortage of hackers in this area. you can help by being patient :)
15:29:38 <kallisti> based on this experience, it seems like the constraint solver is too sensitive to previously installed packages. maybe there could be an option that automatically reinstalls packages with constraints that conflict because of previously installed packages.  (not sure if I'm explaining what I mean well)
15:30:10 <kosmikus> the problem is that the solver has to be sensitive to previously installed packages right now
15:30:24 <kosmikus> because reinstalling in general is causing people to destroy their systems, too
15:30:32 <MostAwesomeDude> Shou: There is no reason why you cannot lift forkIO, sure.
15:31:06 <kosmikus> the best option for now is to use a lot of sandboxing via cabal-dev etc.
15:31:28 <kosmikus> sandboxing will become more convenient, that's one GSoC project
15:31:41 <kosmikus> reinstalling will become less dangerous, that's another
15:31:41 <kallisti> kosmikus: hm, perhaps something like cabal-dev could be used automatically by cabal-install when those sorts of conflicts arise?
15:31:54 <kosmikus> assuming these two succeed, we're on a good track
15:32:05 <kallisti> for example, in my situation, build a new webdriver in a sandbox for this install.
15:32:24 <kallisti> that's time consuming though.
15:32:30 <kosmikus> as I said, sandboxing will be offered by cabal itself
15:32:39 <kosmikus> so it'll become easier and more direct to use
15:33:13 <kosmikus> and yes, even with both improvements, not all problems will completely disappear
15:33:29 <kosmikus> the root of the problem is not Cabal, it's that GHC is so picky about dependencies in the first place
15:34:20 <kallisti> I don't mean to sound impatient or angry or whatever. I'm genuinely interested in what the current situation is like and what solutions exist.
15:34:23 <however> nobdraisentone: you could make a function "let f xs y = xs `intersect` ctpcTo y \\ [y]". i'm not really sure what you're shooting for with the "b <- blist" lines. somebody probably can simplify those too
15:35:03 <kallisti> Thanks for the time, words, and help. I appreciate it.
15:35:12 <kosmikus> kallisti: bedtime for me now. I can explain another time if you like.
15:35:30 <kallisti> Sounds good.
15:35:35 <kosmikus> kallisti: thanks for the constructive criticism :)
15:43:23 <nobdraisentone> however: here `<-` is for list monad, so b <- list getting value from list
15:44:15 <however> nobdraisentone: yeah ... it kind of gets all the values :)
15:44:16 <however> > do b <- [1..3]; return (succ b)
15:44:18 <lambdabot>   [2,3,4]
15:44:33 <however> (it doesn't pull just one value)
15:45:29 <nobdraisentone> however: exactly
15:45:37 <Eduard_Munteanu> > [1..3] >>= succ
15:45:39 <lambdabot>   No instances for (GHC.Num.Num [b], GHC.Enum.Enum [b])
15:45:39 <lambdabot>    arising from a use...
15:45:47 <gaze__> Hey, what's the deal with wxhaskell and threads?
15:45:51 <Eduard_Munteanu> > [1..3] >>= return . succ
15:45:54 <lambdabot>   [2,3,4]
15:47:10 <jmcarthur> gaze__: most UI libraries do not play particularly awesome with threads. i no nothing about wxhaskell specifically, but i imagine it's just the same story
15:47:21 <jmcarthur> *i know nothing
15:49:05 <nobdraisentone> Wait, `b' in `b ← blist' is just one element of blist
15:49:13 <sipa> > succ <$> [1,2,3]
15:49:14 <lambdabot>   [2,3,4]
15:51:00 <nobdraisentone> > do { x <- [1,2]; y <- [3,4]; return $ (x,y)}
15:51:02 <lambdabot>   [(1,3),(1,4),(2,3),(2,4)]
15:51:26 <kallisti> nobdraisentone: b is just one element but it's used to refer to /all/ of them.
15:51:32 <nobdraisentone> Yes
15:51:32 <kallisti> it has the type of one element.
15:52:52 <roconnor_> note to self: to use clone one must eta-expand the where clause due to the monomorphism restriction. :/
15:53:00 <however> anyway, i'm not sure what's going on, but you're in the list monad and at the end you do "head" on the result. so perhaps this could be written in a simpler way
15:53:11 <Eduard_Munteanu> nobdraisentone: see how that desugars.
15:53:19 <Eduard_Munteanu> @undo do b <- [1..3]; return (succ b)
15:53:19 <lambdabot> [1 .. 3] >>= \ b -> return (succ b)
15:53:32 * hackagebot pipes 2.1.0 - Compositional pipelines  http://hackage.haskell.org/package/pipes-2.1.0 (GabrielGonzalez)
15:58:11 <nobdraisentone> Eduard_Munteanu: okay, so now there is a problem with `return $ sum [a,b,c,d,e]'
16:00:01 <dmwit> gaze__: The best practice with Gtk is to link with -threaded and run all Gtk actions from the main thread; gtk2hs provides a function to throw actions from any thread to the main one. I suspect the answer to your question about wx is similar.
16:01:54 <zzing> In typeclassopedia, it mentions instances of functor such as ((,) e) and ((->) e) but I can't really understand what they are talking about.
16:02:27 <ThePro> hm
16:02:32 <rwbarton> the type of a tuple (a,b) can also be written (,) a b
16:02:44 <zzing> In the former it talks about it being a container which holds an annotation of type e along with the actual value it holds
16:02:44 <rwbarton> similarly a -> b can be written a -> b
16:02:45 <rwbarton> um
16:02:47 <ThePro> can i do a typedefinition to a function using ghci?
16:02:48 <rwbarton> and also (->) a b
16:02:57 <shachaf> You can also write it a -> b
16:03:08 <mauke> or ((->) a) b
16:03:26 <shachaf> (((->) (a)) (b))
16:03:44 <ThePro> > let factorial :: Integer -> Integer
16:03:45 <lambdabot>   not an expression: `let factorial :: Integer -> Integer'
16:04:03 <shachaf> ThePro: Yes, with semicolons.
16:04:06 <zzing> So the annotation is just saying filling in the first part of a tuple and leaving the second part for whatever the real value is?
16:04:20 <shachaf> zzing: Do you understand instance Functor (Either e) where ...?
16:04:22 <byorgey> zzing: exactly
16:04:37 <ThePro> > let factorial :: Integer -> Integer; factorial n = product [1..n]
16:04:38 <lambdabot>   not an expression: `let factorial :: Integer -> Integer; factorial n = prod...
16:04:39 <zzing> shachaf, I believe so
16:04:56 <shachaf> OK, so it was just a syntactic thing.
16:04:58 <zzing> after that you implement fmap for that type
16:05:19 <shachaf> (->) and (,) are the "prefix" form of the infix operators -> and ,
16:05:46 <zzing> I get that part, it is just thinking about what it means to be a partial perhaps
16:05:59 <ThePro> weird, in ghci it works
16:06:10 <ThePro> > let factorial :: Integer -> Integer; factorial n = product [1..n]
16:06:11 <lambdabot>   not an expression: `let factorial :: Integer -> Integer; factorial n = prod...
16:06:14 <shachaf> lambdabot isn't ghci
16:06:21 <ThePro> ah k
16:06:33 <ThePro> no ghc at all?
16:06:37 <zzing> When it talks about ((,) e) representing a container, is it really talking about the set of all tuples with type e as the first element?
16:06:54 <rwbarton> zzing: probably it helps to start by writing out the type of fmap for (,) e, figuring out what that function is and then trying to understand what it all means for (,) e to be a Functor
16:07:02 <rwbarton> maybe you've done that already though
16:07:27 <zzing> rwbarton, haven't exactly yet, but I have fmap written down
16:07:34 <zzing> :t ((,) e)
16:07:36 <lambdabot> forall b. b -> (Expr, b)
16:09:27 <zzing> Would it be correct to say fmap :: (a -> b) -> ((,)e) a -> ((,)e) b
16:09:38 <shachaf> Yep.
16:09:48 <shachaf> But that's not the standard way of writing that type.
16:09:50 <rwbarton> you may want to rewrite that to a more familiar form, though
16:09:55 <zzing> And thus by extension  fmap :: (a -> b) -> (e,a) -> (e,b)
16:10:45 <shachaf> zzing: Now try (->)!
16:11:02 <zzing> fmap :: (a -> b) -> (e -> a) -> (e -> b)
16:11:14 <byorgey> \o/
16:11:23 <byorgey> now implement it.
16:11:32 <zzing> You had to ask that… :-)
16:11:56 <zzing> I will do the exercises that include those and come back for feedback
16:12:02 <byorgey> ok =)
16:12:21 <Eduard_Munteanu> nobdraisentone: what do you mean?
16:13:08 <nobdraisentone> Eduard_Munteanu: sorry, I'm kinda confused
16:17:09 <dmwit> ThePro: With lambdabot, you should use let ... in ... or ?let
16:17:40 <ThePro> > let factorial :: Integer -> Integer in factorial n = product [1..n]
16:17:41 <lambdabot>   <no location info>: parse error on input `='
16:18:19 <dmwit> > let factorial :: Integer -> Integer; factorial n = product [1..n] in factorial 5
16:18:20 <lambdabot>   120
16:18:44 <dmwit> After all, why bother defining a thing if you don't plan to use it? =)
16:18:46 <ThePro> ah
16:18:57 <ThePro> ye right lol
16:19:25 <ThePro> > let factorial :: Integer -> Integer; factorial n = product [1..n] in factorial 10
16:19:26 <lambdabot>   3628800
16:19:29 <ThePro> > let factorial :: Integer -> Integer; factorial n = product [1..n] in factorial 1000
16:19:30 <lambdabot>   402387260077093773543702433923003985719374864210714632543799910429938512398...
16:19:35 <byorgey> dmwit: you know, just in case?
16:24:23 <dmwit> > case 3 of { 3 -> 3 where { 3 = 3 }; 4 -> 4 where { 4 = 4 } }
16:24:25 <lambdabot>   3
16:24:29 <dmwit> huh
16:24:47 <dmwit> So, when I write f x = case x of ... where ...
16:24:59 <dmwit> does the where attach to the last -> or the = ?
16:25:22 <mauke> :t let fmap -> f = negate in f
16:25:24 <lambdabot> parse error on input `->'
16:25:31 <mauke> :t let (fmap -> f) = negate in f
16:25:33 <lambdabot>     Illegal view pattern:  (fmap -> f)
16:25:33 <lambdabot>     Use -XViewPatterns to enable view patterns
16:25:43 <mauke> > let (fmap -> f) = negate in f
16:25:45 <lambdabot>   Overlapping instances for GHC.Show.Show (f a -> f a)
16:25:45 <lambdabot>    arising from a use ...
16:25:48 <mauke> good enough
16:26:42 <dmwit> Ah, I see.
16:26:49 <dmwit> Layout decides which thing the "where" is attached to.
16:27:22 <dmwit> ...and this is why you can't "fix" the "bug" that a parse error ends a block.
16:27:28 <dmwit> interesting
16:27:42 <parcs`> > let x = case 3 of 3 -> a; 4 -> 4 where a = 3 in x
16:27:43 <lambdabot>   a
16:27:49 <rwbarton> It is?
16:27:57 <rwbarton> can you give an exapmle?
16:28:05 <dmwit> Well, yes, you can't just let "where" end a block, for example. =)
16:28:35 <Eduard_Munteanu> > let in 3
16:28:37 <lambdabot>   3
16:29:00 <Eduard_Munteanu> > 3 where
16:29:00 <mauke> let (forever -> loop) = step
16:29:01 <lambdabot>   <no location info>: parse error on input `where'
16:29:17 <ThePro> > x where x = 3
16:29:19 <lambdabot>   <no location info>: parse error on input `where'
16:29:30 <mauke> > let where in 3
16:29:31 <lambdabot>   <no location info>: parse error on input `where'
16:29:35 <hpaste> dmwit pasted “whitespace sensitivity” at http://hpaste.org/70695
16:30:01 <ThePro> > x | where x = 3
16:30:03 <lambdabot>   <no location info>: parse error on input `|'
16:30:35 <dmwit> eh, I guess I should have just included the results in the paste
16:30:47 <dmwit> The first one is fine, the second is a scoping error.
16:30:53 <parcs`> "...and this is why you can't "fix" the "bug" that a parse error ends a block." what does that mean
16:31:14 <dmwit> parcs`: Parse errors end blocks, according to the Report, as I learned yesterday.
16:31:29 <dmwit> I thought this was weird, but now it seems to me to be a somewhat elegant way of summarizing all the different ways a block can end.
16:32:03 <parcs`> well parse errors end parsing, so i'm not sure why that a parse error ending a block is important
16:32:16 <dmwit> (According to the Report, "do a == b == c" has one correct parse: "(do { a == b }) == b".)
16:32:19 <mauke> it doesn't end parsing
16:32:22 <Eduard_Munteanu> Mm, so the report defines how illegal Haskell is handled?
16:32:23 <mauke> just that block
16:32:41 <dmwit> (Even though "a == b == c" doesn't parse on its own -- in fact, *because* "a == b == c" doesn't parse on its own.)
16:32:51 <dmwit> Eduard_Munteanu: Hm? No.
16:33:02 <parcs`> > do True == False == False
16:33:04 <lambdabot>   Precedence parsing error
16:33:04 <lambdabot>      cannot mix `GHC.Classes.==' [infix 4] and `GH...
16:33:15 <dmwit> parcs`: GHC does not implement this feature of the Report. =)
16:34:29 <parcs`> so ghc keeps parsing after a parse error? then why does it only report one parse error at a time
16:35:00 <dmwit> I think you're confused.
16:35:03 <parcs`> yes
16:35:18 <dmwit> Also, I used English, which is always a mistake.
16:36:17 <dmwit> http://www.haskell.org/onlinereport/syntax-iso.html#sect9.3
16:36:36 <dmwit> Note 5 is the load-bearing bit.
16:36:38 <rwbarton> okay, I get your example, but why couldn't we just unindent line 6 a little
16:36:59 <rwbarton> then the block would be closed by layout for sure
16:37:30 <rwbarton> I mean, f = x where x = 3 is valid too so where can't close a block in general
16:37:36 <rwbarton> do you have a case where it should?
16:37:48 <dmwit> rwbarton: Suppose I indented lines 4 and 5 by exactly one space (instead of one tab which can be broken into eight spaces by another bug in the Report.)
16:37:58 <rwbarton> okay
16:38:26 <rwbarton> wait, you mean one total
16:38:28 <rwbarton> not one more
16:38:30 <dmwit> yes
16:38:39 <dmwit> (I'm not sure whether you consider this a convincing "suppose". =P)
16:38:52 <rwbarton> I guess that would be a problem
16:39:01 <rwbarton> possibly could be filed under "poor planning" though
16:39:09 <parcs`> okay so what you're describing is some kind of fallback mechanism of the tokenizer
16:39:11 <dmwit> yeah
16:39:28 <dmwit> parcs`: Hm. I think it happens after tokenizing.
16:39:43 <parcs`> well the layout desugarer
16:39:51 <rwbarton> technically it sort of happens during tokenizing since ; is a token
16:40:15 <rwbarton> as well as { }
16:40:39 <dmwit> Oh, you're right. Sorry.
16:40:43 <dmwit> I mixed up lexing and tokenizing.
16:42:40 <parcs`> so without that rule then the first program in your paste would be fail to parse?
16:42:46 <parcs`> -be
16:43:20 <dmwit> I think so, yes.
16:43:51 <rwbarton> right, i think it would be main = case () of { () -> foo; () -> foo; where { foo = return () } }
16:44:07 * dmwit == rwbarton
16:44:19 <dmwit> ...for once. Which means I have half a chance of being right this time.
16:44:53 * kallisti wonders when we'll see the "cabal nuke" feature.
16:45:03 <kallisti> would save me a lot of time.
16:45:12 <parcs`> what would it do?
16:45:22 <kallisti> blank slate. nothing installed.
16:46:14 <parcs`> you can just 'rm -r ~/.ghc' to acheive that
16:47:38 <ssbr> Haskell's let is actually letrec, right?
16:47:49 <kallisti> yes
16:48:04 <kallisti> all bindings can potentially be recursive.
16:48:11 <kallisti> > let x = x in x
16:48:13 * ssbr was momentarily thrown off by "data Foo = Foo Foo; let a = Foo a"
16:48:14 <lambdabot>   mueval-core: Time limit exceeded
16:48:25 <parcs`> @src fix
16:48:26 <lambdabot> fix f = let x = f x in x
16:48:46 <kallisti> yes that could be written as fix Foo
16:49:08 <ssbr> Welp, at least this means I can write cyclic datastructures then
16:49:33 <parcs`> haskell eats cyclic data structures for breakfast
16:49:40 <ssbr> think it's worth it to define DFA as a cyclic datastructure that I can pattern match when I navigate?
16:49:45 <dmwit> > repeat 1 -- is cyclic in GHC
16:49:46 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
16:49:55 <kallisti> ssbr: what is a dfa?
16:50:02 <ssbr> kallisti: deterministic finite automaton
16:50:02 <dmwit> ssbr: If you never want to modify them, then yes, that can work nicely.
16:50:35 <kallisti> oh. as opposed to what?  (instead of using cyclic data structures and pattern matching)
16:50:50 <ssbr> right, so re modification -- during construction it'd be easier to represent them in the mathematical sense, as a tuple (or record) of states and mappings from state * input to state ?
16:51:02 <dmwit> kallisti: The usual alternative is to emulate a heap using an IntMap or some such thing.
16:51:20 <dmwit> (and build observable cycles instead of implicit cycles)
16:51:52 <dmwit> ssbr: Yes, many operations are more convenient if you make your cycles observable in that way.
16:52:29 <ssbr> Alright. This is important to me. The whole reason I was like "yay haskell for DFA" is pattern matching on DFA nodes :P
16:52:36 <ssbr> it ain't fun without that, man
16:57:51 <maloi>  /quit .
16:59:00 <zzing> :t (.)
16:59:01 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
16:59:19 <zzing> :t fmap
16:59:20 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
16:59:27 <zzing> ...
16:59:50 <zzing> @src (.)
16:59:51 <lambdabot> (f . g) x = f (g x)
16:59:51 <lambdabot> NB: In lambdabot,  (.) = fmap
16:59:59 <kallisti> :t (Prelude..)
17:00:00 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
17:00:05 <kallisti> sanity restored.
17:00:42 <zzing> kallisti, what did you just do?
17:01:00 <kallisti> qualified the symbol
17:01:07 <kallisti> lambdabot is using a different (.) that it defines
17:01:15 <kallisti> (Prelude..) is the normal one
17:01:47 <kallisti> :t Prelude.(.)
17:01:48 <lambdabot> Not in scope: data constructor `Prelude'
17:01:52 <zzing> I am asked to implement fmap for ((->) e) and it struck me as just being composition, which is why I did that above
17:02:01 <kallisti> it is.
17:02:03 <dmwit> zzing++ for enlightenment
17:02:29 <kallisti> :t fmap `asTypeOf` (.)
17:02:30 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
17:02:35 <kallisti> heh
17:02:52 <zzing> is this correct? fmap for Either e is    fmap f (Left e) = Left e  ; fmap f (Right a) = Right $ f a
17:03:04 <kallisti> yes.
17:03:15 <dmwit> zzing: perfect!
17:03:22 <zzing> I wouldn't want to be fmap today…
17:03:30 <zzing> next exercise
17:03:52 <kallisti> yesod's default package constraints are way too strict...
17:04:02 * kallisti had to include a bunch of --constraint options to finally get it to build.
17:04:28 <dmwit> Wait, --constraint overrides constraints? I thought it intersected with the existing constraints.
17:04:33 <kallisti> it does.
17:04:37 <kallisti> but something weird is happening with cabal
17:05:17 <kallisti> it seems to be interpreting constraints such as 'package = 0.1.*'  as "oh you must want the latest version that matches this constraint AND NOTHING ELSE"
17:05:38 <kallisti> at least that's the way it surfaces in the error trace
17:06:21 * kallisti wonders if he's dealing with a bug of some kind.
17:07:00 <zzing> Second set, fmap for ((,) e) => fmap f (e,a) = (e, f a)
17:07:11 <kallisti> yep.
17:07:22 <kallisti> zzing: are you familiar with Writer?
17:07:26 <zzing> no
17:07:32 <kallisti> ah, well, nevermind then. :P
17:07:34 <zzing> and for data Pair a = Pair a a =>   fmap :: (a->b) -> Pair a -> Pair b ;  fmap f (Pair a b) = Pair (f a) (f b)
17:07:34 <however> kallisti: what is this odyssey you are on? you have been wrestling all day with cabal
17:07:40 <mauke> (you are now)
17:07:40 <kallisti> yes.
17:08:01 <kallisti> getting the default yesod stuff to compile with my own dependencies.
17:08:08 <kallisti> (default yesod stuff = yesod init)
17:08:09 <however> oh :-/
17:08:17 <dmwit> zzing: Pair a ~= Bool -> a; do the instances line up? =)
17:08:30 <kallisti> I'm beginning to think there's a bug in this version of cabal-install, based on the way it's handling constraints.
17:08:45 <kallisti> or maybe I need to adjust max-backjumps
17:08:48 <zzing> dmwit, can you ask that a little bit more elaborately?
17:08:56 <dmwit> zzing: Yes, certainly.
17:09:15 <dmwit> There's an isomorphism between the types Pair a and Bool -> a. It's given by
17:09:17 <Nereid> zzing: you should also check that it satisfies the functor laws
17:09:26 <dmwit> to f = Pair (f False) (f True)
17:09:37 <dmwit> fro (Pair a b) False = a; fro (Pair a b) True = b
17:10:05 <zzing> Nereid, laws are next in the exercise
17:10:07 <dmwit> You can check that to . fro = id and fro . to = id pretty quickly, I hope.
17:10:22 <mauke> "a pair is like an array of two elements, which is like an array indexed by booleans"
17:10:32 <Nereid> e.g. why wouldn't fmap f (Pair a b) = Pair (f b) (f a) make a good functor?
17:10:33 <kallisti> what seems to be happening is that it'll try the immediately newest version that matches my cabal files constraints, and then if those fail it won't try older ones that still match those constraints.
17:10:34 <dmwit> So, the next question is, do the fmap implementations for ((->) Bool) and Pair line up the way they ought to?
17:10:35 <zzing> Can you define isomorphism
17:10:39 <mauke> oh, and functions are like maps with implicit lookup
17:10:47 * kallisti completely nuked all packages before doing this.
17:10:57 <dmwit> zzing: An isomorphism is a pair of functions to and fro with to . fro = id and fro . to = id. =)
17:11:18 <dmwit> If two types are "isomorphic", then they sort of "contain the same data" in a sense.
17:11:25 <dmwit> Since you can convert one to the other losslessly.
17:11:25 <however> kallisti: you're probably already aware of it, but cabal-dev is handy and easy to use
17:11:55 <kallisti> I'm not familiar with how I'm supposed to use cabal-dev, but when I try to use it as though it were cabal I would get similar errors. -_-
17:12:23 <zzing> dmwit, so are you asking me to run through ((->) Bool) and Pair with the to and fro?
17:13:01 <dmwit> zzing: To check that the two instances line up, you'd want to check that: fmap f . to = to . fmap f and fmap f . fro = fro . fmap f
17:13:24 <Nereid> (it suffices to check one of those)
17:14:24 <dmwit> ...yes it does. Neat!
17:14:44 <Nereid> or, with a bit of fiddling, you could *define* fmap for Pairs by
17:14:53 <however> kallisti: cabal-dev might help with the "nuking". it lets you mess around without interfering with the packages you might have in ~/.cabal. it just lets you make a new directory, and downloads the packages you specified into it, with all their dependencies and stuff
17:14:56 <Nereid> uh
17:14:59 <however> just a random suggestion :)
17:15:25 <Nereid> fmap f = to . fmap f . fro
17:15:45 <dmwit> Right.
17:16:30 <kallisti> however: right, cabal-dev was giving me the same errors.
17:16:45 <zzing> ok, I am not sure I can go through this to prove. I am assuming I have to use previous definitions to arrive at the goal
17:17:01 <dmwit> Yep, you'll want to substitute in definitions first.
17:17:06 <Nereid> well, you have definitions of fmap for Pair and ((->) Bool)
17:17:12 <dmwit> You can do a case analysis if you think that would be helpful (I do).
17:17:28 <Nereid> so you just check if they satisfy those equations
17:17:31 <kallisti> Nereid: not sure if anyone answered your question, but it doesn't type
17:17:39 <kallisti> Nereid: it would only type for (a, a)
17:17:41 <however> kallisti: sure, it's just cabal with a little bit of configuration to put everything in the extra directory
17:17:42 <kallisti> but not (a, b)
17:17:50 <Nereid> kallisti: check again
17:17:53 <dmwit> To be clear what I mean by case analysis: functions are equal when they're equal for all arguments, so the "arguments" are the cases.
17:18:16 <jaxtr> ahh it's a wonderful day
17:18:40 <kallisti> Nereid: ah
17:18:47 <Nereid> ;)
17:19:08 * kallisti should probably wear his glasses when he needs to use his eyes. :P
17:19:13 <Nereid> the question was an exercise for zzing anyway
17:19:45 <zzing> Can I start off with fmap f.to  = fmap f.(Pair (f False (f True)) ? I some how doubt it that all fs are all the same
17:20:04 <dmwit> Unfortunately no, all the f's are not the same.
17:20:10 <dmwit> I apologize for that horrible pun.
17:20:11 <Nereid> they aren't?
17:20:23 <Nereid> what
17:20:24 <dmwit> Nereid: The "f" in to/fro is not the same as the "f" in "fmap f".
17:20:31 <Nereid> oh right.
17:20:39 <zzing> dmwit, I don't think that I can go through this with my present knowledge.
17:20:47 <dmwit> I have confidence in you!
17:20:49 <zzing> I have done some similar things in miranda
17:20:58 <dmwit> Just pick a different name than "f" for the definitions of "to" and "fro".
17:21:07 <dmwit> We could work on it together, if you wanted.
17:21:11 <zzing> ok, I will try it over again and insert types
17:21:50 <zzing> dmwit, please. #haskell-in-depth might be an appropriate place
17:21:52 <Nereid> (part 2 of the exercise: there are two other possible (total) definitions of fmap for Pair; check that they don't work either)
17:22:26 <Nereid> (after you read about the functor law...)
17:22:35 <Nereid> laws
17:22:37 <Nereid> axioms
17:22:52 <kallisti> guidelines?  :P
17:23:13 * kallisti speaks of heresy.
17:25:53 <kallisti> is it possible to use quickcheck to automatically verify that instances obey a particular set of laws?
17:26:03 <kallisti> in a way that isn't too obstructive?
17:26:35 <kallisti> (I use the word "verify" loosely)
17:27:04 <augur_> edwardk: it seems that the oleg-shan relationship is well known in the comp-semantics community o.o;
17:27:22 * edwardk shrugs.
17:27:35 <augur_> like, to the point where shan apparently blogged about it a few years ago
17:27:43 <augur_> how weird. =
17:29:29 <kallisti> http://haskell.spreadshirt.com/oleg-already-did-it-A6499531
17:30:06 <augur_> that should say "in haskell's type system"
17:30:30 <augur_> otherwise its sort of .. half the joke!
17:31:05 <enkomax> is there some kind of os web/blog/nuke project written in haskell?
17:31:35 <augur_> anything written using snap, surely
17:31:43 <kallisti> all the yesod website stuff uses yesod as a backend, of course.
17:32:41 <kallisti> which also includes a blog
17:32:49 <kallisti> but no OSes or nukes, sorry.
17:32:57 <enkomax> gotcha
17:33:12 <enkomax> thank you
17:33:33 <NemesisD> anyone ever use safecopy/acid-state? i'm getting a very unhelpful "Can't derive safecopy instance" error
17:33:35 <augur_> i wonder if oleg's site runs in the haskell type system
17:33:52 * kallisti is realizing that creating a working set of bindings to GraphicsMagick that isn't completely broken like hsmagick is more difficult that originally thought.
17:43:49 <kallisti> UHC has a pretty complete javascript backend.
17:44:12 <kallisti> maybe I should start porting some of my libraries to UHC.
17:44:28 <jmcarthur> there is nothing new under the sun. every original idea i have ends up already being covered in some obscure paper
17:44:55 <kallisti> original ideas are more often than not a synthesis of existing ideas.
17:45:25 <jmcarthur> that's true, but often even just the combination of separate ideas ends up already being done
17:46:17 <jmcarthur> on the plus side, it's fun to find how many authors think their own ideas are original only to find them explained in detail in even older papers
17:46:39 <jmcarthur> it makes me feel better, at least
17:46:47 <coppro> it's hard to search for ideas
17:46:50 <kallisti> actually I'd imagine cond already compiles on UHC.
17:46:54 <however> "no no dude, it's not original" ... Academia -- The Original Hipsters
17:46:59 <dylukes> Looks like I can't use test-framework-quickcheck due to its dependencies...
17:47:08 <coppro> but independent discovery is a form of verification
17:47:12 <coppro> always useful in academia
17:47:16 <dylukes> It depends on an older version of deepseq.
17:47:23 <jmcarthur> that's true i gess
17:47:53 <dylukes> Oh, there's a qc2 package. heh.
17:48:06 * kallisti would like to see a mature javascript backend for a Haskell compiler.
17:48:11 <jmcarthur> i am at least the third to independently discover this, although that should probably be an even larger number since people don't usually make papers for every little thing
17:48:18 <kallisti> then web app frameworks could start integrating client-side libraries. :D
17:48:31 <jmcarthur> so, point being, i guess it probably has merit at least :)
17:50:31 <harrison> conal? was that THE conal of implicit animation fame?
17:52:09 <jmcarthur> harrison: fran, frp, tangible values, etc.
17:52:20 <kallisti> yes. that's him. he's Haskell famous. :P
17:53:06 <however> he's definitely had major side-effects, hurr hurr
17:53:11 <jmcarthur> although i have no idea what implicit animation is. it sounds like his kind of thing, though
17:53:29 <jmcarthur> i'm only finding stuff about iOS
17:54:08 <jmcarthur> i find no connection of it to him. i guess you are confused about something?
17:54:20 <kallisti> I can't seem to find a complete reference to the persistent TH syntax.
17:54:41 <kallisti> Google knows all. admit your mistakes, mere human.
17:57:05 <NemesisD> anyone have experience with safecopy? this is the first time i've tried to use safecopy but i can't derive the instance
17:58:20 <kallisti> is it supposed to be derived?
17:58:45 <NemesisD> kallisti: yeah, you do something like $(deriveSafeCopy 0 'base ''TheTypeName)
17:58:59 <kallisti> ah TH.
17:59:03 <kallisti> what sort of issues are you having?
17:59:44 <hpaste> NemesisD pasted “deriveSafeCopy” at http://hpaste.org/70696
18:00:43 <NemesisD> all the other instances derive fine. the only thing i can see different is that BucketDict is a type synonym
18:01:08 <NemesisD> but there's no way for me to use "deriving" with type synonyms right? i get a syntax error when i do
18:01:24 <noteventime> Is it just me, or does pipes-core lack something like "Monad m => (a -> m b) -> Pipe a b m ()"?
18:02:32 <kallisti> NemesisD: the problem is that '' is a constructor reference
18:02:36 <kallisti> BucketDict is not a constructor.
18:03:16 <NemesisD> kallisti: oh, so i need to refer to it by the the type it aliases?
18:03:26 <kallisti> oh wait, nevermind.
18:03:47 <rwbarton> can't you just delete that line?
18:03:53 <kallisti> '' is for types, actually.
18:04:01 <kallisti> but yes it looks like it can't derive for type synonyms
18:04:10 <kallisti> they use a different TH structure.
18:04:24 <parcs`> noteventime: what about forP . fmap lift
18:04:28 <NemesisD> rwbarton: hmm so what should i do? i'd prefer to not use a newtype
18:04:40 <rwbarton> what happens if you try
18:04:41 <rwbarton> ?
18:04:48 <rwbarton> is there a SafeCopy instance for HashMap?
18:04:53 <NemesisD> rwbarton: if i try removing the line?
18:05:02 <rwbarton> or try making it a newtype
18:05:27 <NemesisD> rwbarton: no, there is no safecopy instance, unordered-containers knows nothing of safecopy and vice versa
18:05:50 <NemesisD> i could use a newtype but i'd prefer to avoid if i could, i'd have to do a lot more unwrapping in my code in that case
18:06:00 <rwbarton> well i suspect that even if you try making it a newtype it will still not work
18:07:14 <noteventime> parcs`: Well, I said it was trivial to implement, but it still seems like it'd be such a common operation that you'd give it a name
18:07:47 <rwbarton> you need to get a SafeCopy instance for HashMap somehow
18:10:38 <NemesisD> ugh
18:10:59 <bitonic> you can get SafeCopy instances for those thing through toList
18:11:02 <bitonic> or similar
18:11:22 <bitonic> safecopy is the serialisation thing no?
18:11:28 <kallisti> those TH derive functions should probably take Type arguments instead of Names
18:11:38 <kallisti> but that requires you to use [t| Type ]  instead of ''Type
18:11:40 <bitonic> ah no it's the versioning.
18:11:42 * bitonic hides
18:11:50 <rwbarton> it looks like it's both
18:12:20 <bitonic> rwbarton: nah the serialising is cereal
18:12:22 <rwbarton> you don't want to write an instance for (HashMap (Consumer, Feature) Bucket) anyways though
18:12:45 <kallisti> right.
18:13:18 <JuanDaugherty> there doesn't seem to be anything current for Haskell and the Parma Polyhedra Lib, am I missing something?
18:13:19 <rwbarton> I know cereal is a serialization library but the SafeCopy I'm looking at really looks like it is involved with serialization as well
18:13:25 <kallisti> NemesisD: just take a look at the source code for the Map instance
18:13:30 <kallisti> and repurpose it for HashMap
18:13:38 <kallisti> the code should be almost identical.
18:14:22 <rwbarton> btw type BucketDict = (HashMap (Consumer, Feature) Bucket) -- you don't need these outer ()s; they threw me off
18:16:33 <kallisti> NemesisD: while you're at it suggest it as a patch to SafeCopy, that way you can avoid an orphan instance.
18:17:27 <NemesisD> kallisti: that doesn't really scale though
18:17:58 <kallisti> well, no, but HashMap is a pretty common container type. I'm not saying every type ever needs an instance in the library.
18:18:03 <NemesisD> the library would then have to keep writing instances for a bunch of 3rd party libraries that it doesn't depend on in that case
18:18:09 <kallisti> it's not all or nothing. ;)
18:19:19 <zzing> When I have an f :: a -> a    are the as different , unless you do  f :: forall a. a -> a?
18:19:28 <kallisti> they're the same.
18:19:35 <kallisti> the forall a.  is implicit.
18:19:41 <kallisti> if there's no forall that already binds that variable
18:19:47 <kallisti> it's implied to be on the outside of the entire expression.
18:19:58 <zzing> So why do some people put forall?
18:20:14 <kallisti> most people don't if it's implied
18:20:20 <kallisti> there are cases where you want to use it explicitly.
18:20:56 <zzing> Now if I have to :: (Bool -> a) -> Pair a  && fmap :: (a -> b) -> (Bool a) -> (Bool b),  would (to . fmap f) :: (Bool -> a) -> Pair b?
18:21:04 <kallisti> (forall a. a -> a) -> FilePath -> IO (Tree FilePath)
18:21:08 <kallisti> is a different type from:
18:21:12 <kallisti> (a -> a) -> FilePath -> IO (Tree FilePath)
18:21:59 <zzing> How different?
18:22:06 <kallisti> the difference being at what point the polymorphic "a" is resolved.
18:22:11 <kallisti> so for example
18:22:20 <kallisti> (:2)  would satisfy (a -> a)
18:22:30 <kallisti> a resolves to Num n => [n]
18:22:49 <kallisti> but it wouldn't satisfy (forall a. a -> a)
18:22:53 <zzing> :t (:2)
18:22:55 <lambdabot> forall a. (Num [a]) => a -> [a]
18:23:01 <kallisti> er...
18:23:06 <kallisti> :t (2:)
18:23:07 <lambdabot> forall t. (Num t) => [t] -> [t]
18:23:40 <dylukes> When did we get implicit arguments ;__;?
18:23:43 <dylukes> When did GHC get so fancy?
18:23:56 <kallisti> you mean implicit parameters?
18:24:02 <kallisti> those have been around.
18:24:10 <zzing> How does (:2) even work? I thought it should be  a -> [a] -> [a]
18:24:15 <zzing> (for :)
18:24:27 <kallisti> zzing: it only works if you have an instance Num [a]
18:24:35 <kallisti> since 2 is overloaded on all Num instances.
18:24:48 <kallisti> > 2 + 2 :: Expr
18:24:49 <lambdabot>   2 + 2
18:25:56 <kallisti> :t 2
18:25:57 <lambdabot> forall t. (Num t) => t
18:26:19 <kallisti> zzing: so the literal 2  is like writing fromInteger (2 :: Integer)
18:26:22 <kallisti> :t fromInteger
18:26:23 <lambdabot> forall a. (Num a) => Integer -> a
18:26:40 <zzing> So what you would have to do in Agda?
18:26:45 <kallisti> no clue.
18:26:58 <kallisti> but literal overloading saves you a lot of headaches when dealing with numeric types.
18:27:06 <kallisti> it also confuses newbies.
18:27:16 <kallisti> and can be abused and used for greatness.
18:27:20 <kallisti> Expr for example
18:27:30 <kallisti> > foldr (+) 0 [1..10]
18:27:31 <lambdabot>   55
18:27:36 <kallisti> > foldr (+) 0 [1..10] :: Expr
18:27:37 <lambdabot>   1 + (2 + (3 + (4 + (5 + (6 + (7 + (8 + (9 + (10 + 0)))))))))
18:27:45 <zzing> I like that
18:28:01 <zzing> > foldr (+) 0 [1..] :: Expr
18:28:02 <lambdabot>   1 + (2 + (3 + (4 + (5 + (6 + (7 + (8 + (9 + (10 + (11 + (12 + (13 + (14 + (...
18:28:24 <zzing> > map (!) [1..] :: Expr
18:28:25 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr'
18:28:25 <lambdabot>         against inferred ...
18:28:43 <zzing> > map fact [1..] :: Expr
18:28:44 <kallisti> zzing: Expr is an instance of Num
18:28:45 <lambdabot>   Not in scope: `fact'
18:28:58 <kallisti> :t (!)
18:28:59 <lambdabot> forall i e. (Ix i) => Array i e -> i -> e
18:29:03 <kallisti> but it's not an Array.
18:29:10 <kallisti> there's no black magic that can make Expr an Array.
18:29:16 <sipa> > (1:2)
18:29:18 <lambdabot>   No instance for (GHC.Num.Num [t])
18:29:18 <lambdabot>    arising from a use of `e_112' at <inte...
18:29:25 <zzing> kallisti, I am thinking something else :-)
18:29:52 <kallisti> what did you have in mind?
18:30:12 <zzing> > map fact [1..] :: Expr; where { fact 0 = 1; fact n = n * (fact (n - 1)) }
18:30:13 <lambdabot>   <no location info>: parse error on input `;'
18:30:32 <zzing> I am not so good with this specific stuff :-)
18:30:36 <kallisti> where is a syntactic construct.
18:30:44 <dylukes> kallisti: http://www.haskell.org/ghc/docs/7.4.1/html/users_guide/other-type-extensions.html#implicit-parameters
18:31:11 <kallisti> that can be attached to definitions (top-level bindings, let bindings, instance method bindings, where bindings, etc)
18:31:18 <kallisti> it can also be attached to cases in a case expression
18:31:24 <kallisti> but it's not an expression itself. just some syntax sugar.
18:31:32 <kallisti> > let f x = y where y = 2 in f 4
18:31:33 <lambdabot>   2
18:32:28 <kallisti> > let { f x = y where { y = 2 } } in f 4
18:32:29 <lambdabot>   2
18:33:29 <kallisti> > let { f x = 1+y where { y = 2+z where z = 3 } } in f 4
18:33:30 <lambdabot>   6
18:33:40 <kallisti> nested where.
18:56:33 <Gurrag> Are there any great Haskell videos on YouTube besides the GoogleTechTalks "Haskell Amuse-Bouche" that anyone could recommend?
18:58:10 <tgeeky_> Gurrag: anything by Conal Elliot
18:58:23 <tgeeky_> Gurrag: anything by Simon Peyton Jones, if it's on there. The one(s) about XMonad.
19:00:47 <kallisti> Pulse/Types.hs:12:28: Not in scope: type constructor or class `Eq'
19:00:50 <kallisti> all of my what
19:03:28 <kallisti> why on earth is NoImplicitPrelude used by default in yesod's scaffolded site.
19:03:42 <kallisti> it's in the cabal file.
19:04:30 <Rung> gotta newb question about LYAH
19:05:10 <Rung> trying to load my first haskell module and the compiler spits errors
19:09:28 <Rung> lol, this always happens to me... I figured it out
19:09:47 <Rung> everytime I ask for help, I end up figuring it out after I post
19:09:49 <Rung> sigh
19:12:40 <Gurrag> Rung: would you mind sharing your problem / solution?
19:12:57 <Rung> soitenly
19:13:33 <Rung> So I kept loading the doubleMe.hs module as per the 'Baby's First Function' chapter in LYAH
19:13:48 <Rung> and at first it was returning the indent error
19:14:20 <Rung> couldn't figure it out, I supposed it was due to the fact I was using a newer ghc than the author
19:14:34 <Rung> like an idiot
19:14:56 <Rung> as it turns out, I typed my func on the second line instead of the first
19:15:16 <Rung> for whatever reason, ghci didnt recognize the func by name
19:15:32 <Rung> until I moved the declaration to the first line
19:15:37 <Rung> works fine now
19:15:52 <Rung> like this: doubleMe x = x + x
19:16:10 <Rung> I see that ghci is very sensitive to emptyspace
19:17:09 <Rung> or emptylines in this case...
19:17:15 <kallisti> to define that in ghci it should looke like:  doubleMe x = x + x
19:17:22 <kallisti> er:  let doubleMe x = x + x
19:18:06 <Rung> now that you mention it, I've notices he doesn't use let in that chapter's declaration
19:18:16 <kallisti> if it's in a file that's why.
19:18:29 <kallisti> ghci and Haskell programs are different things.
19:18:37 <Rung> I see
19:18:45 <kallisti> your indent error was probably because there was a space
19:18:50 <kallisti>   doubleMe x = x + x
19:18:51 <kallisti> instead of
19:18:54 <kallisti> doubleMe x = x + x
19:18:57 <kallisti> or something similar.
19:19:18 <Rung> so the empty line had nothing to do with it?
19:19:26 <kallisti> I would imagine not.
19:19:30 <kallisti> since empty lines are ignored.
19:19:37 <Rung> ok
19:19:39 <Rung> cool
19:19:41 <Rung> thx
19:20:58 <Rung> another question if you have the time
19:21:10 <kallisti> sure
19:21:16 <Rung> I'm trying to create a very simple conditional statement in Haskell
19:21:38 <shachaf> Haskell doesn't really have "conditional statements".
19:21:39 <ski> (.. in Haskell, it'd be a conditional *expression*)
19:21:48 <Rung> ok
19:21:48 <ski> but continue ..
19:22:23 <Rung> so, something really basic like 'if windowOpen = True then "it's open"
19:22:57 <ski> what if `windowOpen' is not `True' ?
19:23:33 * shachaf isn't sure what that even means.
19:23:33 <ski> (every `if' must have both an `then'-branch and an `else'-branch)
19:23:35 <Rung> hmm then putLine "not open"
19:23:42 <Rung> ok
19:23:54 <ski> where does `windowOpen' come from ?
19:23:57 <shachaf> if windowOpen then putStrLn "it's open" else putStrLn "not open"
19:24:01 <ski> is it just a global variable, for now ?
19:24:06 <Rung> just an arbitraty Bool I create
19:24:10 <shachaf> Or putStrLn (if windowOpen then "it's open" else "not open")
19:24:30 <Rung> ya
19:24:30 <Rung> no funcs declared
19:24:30 <ski>   putStrLn (if windowOpen then "it's open" else "not open")  -- alternative version
19:24:59 <ski> in a Haskell file, you'd need to declare this as part of some definition
19:25:05 <ski> like e.g.
19:25:13 <ski>   main = do
19:25:15 <ski>      putStrLn (if windowOpen then "it's open" else "not open")
19:25:19 <kallisti> Rung: what languages are you familiar with?
19:25:33 <Rung> just intro Python and C++
19:25:49 <Rung> I couldn't help but try Haskell
19:25:55 <Rung> it seems so elegant
19:25:58 <kallisti> ah, well. a Haskell module is a collection of top-level declarations, similar to C++.
19:26:09 <kallisti> so you can't just have expressions on the top-level, like you can in Python.
19:26:28 <kallisti> it has to be in some function or constant.
19:26:44 <Rung> I see
19:27:12 <Rung> well this question comes from a certain mentality of mine
19:27:36 <Rung> I'm trying to write a How to for basic basic programming in multiple languages
19:27:45 <Rung> and then steady where they diverge
19:28:03 <Rung> Haskell is so different
19:28:28 <Rung> but every programmer needs conditionals
19:28:33 <Rung> variables
19:28:36 <kallisti> Haskell will diverge in the first example (or the second if the first is Hello, World!)
19:28:39 <Rung> lists or sets or whatever
19:28:47 <Rung> etc
19:28:59 <kallisti> > if 2 == 2 then "hello" else "goodbye"
19:29:00 <lambdabot>   "hello"
19:29:04 <kallisti> > if 2 == 2 then "hello"
19:29:05 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
19:30:03 <kallisti> what's the GHC option that lets me see the TH output?
19:30:18 <daniel_-> @src (@)
19:30:18 <lambdabot> Source not found. I've seen penguins that can type better than that.
19:30:40 * ski . o O ( <http://augustss.blogspot.se/search/label/BASIC> )
19:30:56 <daniel_-> whats the [at] called in (x:ys@(y:_))
19:31:08 <tgeeky> daniel_-: "as pattern"
19:31:31 <ski> daniel_- : `@' is special syntax in patterns : when matching the pattern `<var> @ <pat>' with a value, `<var>' is bound to the value and `<pat>' is matched with the value
19:31:32 <kallisti> it's not an operator.
19:32:00 <daniel_-> i thought it was possible to do (x:y:ys)
19:32:06 <tgeeky> it basically just gives you an opportunity to get the "whole" of what you're matching against, instead of just the parts
19:33:07 <ski> daniel_- : if you had written `x:ys@(y:zs)', then `ys' would be the same as `y:zs' (so `ys' is basically a shorthand) -- also using this is a hint to the implementation that we'd like to reuse the same allocated structure `y:zs' when saying `ys' instead of allocating a new one
19:33:22 <kallisti> daniel_-: it is possible to do that.
19:34:02 <ski> Rung : yes, Haskell as conditionals, variables, lists, sets
19:34:11 <daniel_-> so (x:ys@(y:_)) == (x:y:ys)
19:34:33 <ski> Rung : .. however, note that "variables" doesn't necessarily mean "mutable variables" ;)
19:34:36 <kallisti> daniel_-: no
19:34:53 <Rung> right
19:35:02 <kallisti> daniel_-: ys@(y:_)   binds ys to the entire list, and y to the head of the list, and the tail is ignored.
19:35:08 <kallisti> that's not what y:ys  means
19:35:19 <daniel_-> ahhhhhhhhhhhhhhh
19:35:25 <daniel_-> ok, makes sense
19:35:34 <ski> daniel_- : in `x:ys@(y:_)', `x' is the head (element number `0'), `ys' is the tail, `y' is the head of the tail (element number `1')
19:36:23 <ski> daniel_- : in `x:y:zs', `x' is the head (element number `0'), `y' is the head of the tail (element number `1'), `zs' is the tail of the tail (elements numbered from `2' onwards)
19:36:42 <daniel_-> yes, thank you
19:36:43 <pqmodn> @quickcheck let test list = (not . null) list ==> let whole@(x:xs) = list in whole == (x:xs)
19:36:43 <lambdabot> Unknown command, try @list
19:36:49 <pqmodn> @qc let test list = (not . null) list ==> let whole@(x:xs) = list in whole == (x:xs)
19:36:50 <lambdabot> Not enough privileges
19:36:57 <Rung> my idea being, that you can do a lot with very basic programming tools like :stdI/O, Input capture/binding,arithmatic,conditionals,functions,file I/O,event handling
19:37:33 <Rung> instead of going deep into the driving principles, let beginner's learn basic programming on multiples languages at once
19:37:33 <ski> Rung : yes
19:38:03 <Rung> then, as the languages diverge, you cover the advanced material in the logical sequence
19:38:17 <gaze__> hey guys, is there a postGUIAsync/postGUISync equivalent for wxhaskell?
19:38:29 <gaze__> something that lets me inject some IO action into the main loop
19:38:30 <Rung> or better yet, let the student decide what theory he needs to know in order to accomplish a task
19:39:07 <Rung> a task oriented guide to programming instead of a holistic CS approach
19:39:30 <ski> Rung : well, there's still some common principles that one needs to understand when learning to program : e.g. that the computer does what you tell it to, not what you intended; that you must (generally) spell things exactly right; that you must break down the problem into pieces small enough for the computer to handle them ("spell things out")
19:39:49 <Rung> right
19:40:12 <ski> Rung : and for imperative languages, one needs to develop a basic understanding of *mutable* variables
19:40:24 <Rung> right
19:41:00 <ski> Rung : while for functional languages, one instead needs to have a better understanding for iteration-via-recursion, and for common idioms like accumulator-passing-style
19:41:45 <ski> Rung : one could possibly add a few more important "driving principles" here ..
19:41:52 <Rung> I suppose I'm just to stuck in imperative thinking right now
19:42:50 <ski> Rung : my point is that to someone who has only seen imperative programming, that person might not realize these basic theory things which are taken for granted in imperative programming languages ..
19:43:21 <Rung> ya that would definitely be a problem
19:44:19 <ski> (i recall reading somewhere that one of the most common stumbling blocks for beginning programmers (learning in an imperative language) is mutable variables/state and assignment)
19:45:16 <Rung> ya, when i realized the diff between aliasing and cloning in Python, it was like "why didn't I know that from the beginning?"
19:45:22 <ski> (and pointers/references (including aliasing) add another level of difficulty to that)
19:46:01 <Rung> so , this would be an immediate point of divergence for Haskell?
19:46:20 <ski> yes, because Haskell doesn't have mutable variables
19:46:22 <kallisti> there is no distinction between a copy of someting and an alias of something.
19:46:35 <Rung> cuz neither change
19:46:46 <ski> (it has mutable state cells, but they aren't that commonly used, and definitely not something a beginner would use)
19:47:16 <Rung> hmmm, still this contrast might be a good thing for people to learn from the get-go
19:48:06 <ski> (Rung : some other languages with immutable variables : Erlang,O'Caml,SML,Clean,Prolog,Mercury)
19:48:11 <Rung> it would reinforce the difference between a program doing what you tell it to and doing what you want
19:48:41 <ski> Rung : yes, as long as you're aware that they'd need to (at least get the option of) learn(ing) about these basic concepts, if they're not familiar with them beforehand
19:49:37 <Rung> right, well my idea here being to teach them both early on
19:49:55 <ski> that sounds ok
19:50:00 <Rung> I come from a classical (non-CS) logic background
19:50:17 <Rung> so, I was introduced to imperative programming
19:50:41 <Rung> and I had many occasions where I though "they are making x task way too difficult"
19:50:57 <kallisti> no, classical logic makes it too easy. :P
19:51:02 <Rung> lol
19:52:01 <ski> ("logic background" meaning ? you've studied digital logic ? logic as in truth-tables and proofs ? logic programming ?)
19:52:16 <Rung> ? logic as in truth-tables and proofs ?
19:52:21 <Rung> sorry
19:52:35 <Rung> yes , logic as in truth-tables and proofs
19:52:49 <Rung> western philosophy
19:53:04 <ski> (ooc) both propositional and predicate logic ?
19:53:11 <Rung> Aristotly on to Heigl
19:53:17 <Rung> yes
19:53:35 <ski> only classical logic ? also modal logics ? intuitionistic/constructive logics ? type theory ?
19:53:46 <Rung> *hegel
19:54:22 <Rung> Not yet, this is my personal life path, I fell in love with logic and changed majors
19:54:39 <Rung> so, still alot left to learn -- im an undergrad
19:54:50 <ski> (ok, so no Fregean Begriffsschrift yet, then ? :)
19:55:11 <ski> Rung : you might be interested in the channel ##logic
19:55:24 <Rung> oh I'm sure I would
19:55:53 <Rung> thanks for all the help ski and kallisti
19:55:55 <kallisti> > (`replicateM` "01") =<< [0..]
19:55:57 <lambdabot>   ["","0","1","00","01","10","11","000","001","010","011","100","101","110","...
19:55:57 <ski> (also, if you like logic, then you might like Logic Programming (programming basic on logic and relations/predicates), as in Prolog (see ##prolog))
19:56:34 <Rung> ya, Prolog keeps coming up at these early stages of inquiry
19:57:21 <ski> a lot of programming ideas, styles and idioms carry over from Haskell to Prolog (and vice versa)
19:57:36 <ski> (or more generally, carries over between FP and LP)
19:58:59 <ski> (s/basic/based/)
20:01:00 <kallisti> Rung: apparently philosophy professors program in Haskell.
20:01:19 --- mode: holmes.freenode.net set +o ChanServ
20:01:21 <Rung> lol, I suppose when they DO program, they do
20:01:34 <kallisti> I had to email a philosophy professor at Berkeley to convince him to change his ZIP library from GPL to BSD licensing.
20:01:46 <kallisti> so I could use it in a BSD licensed library.
20:01:49 <Rung> they spend alot of time following their intuition and fighting old debates ad infinitum
20:01:55 <Luke> hey guys, I have 2 functions of type (m (Maybe Int)) and I want to use the <|> alternative but I'm in the 'm' monad. How can I correctly lift the Maybe alternative instance?
20:01:59 <Clint> kallisti: why didn't he change it to a good license instead?
20:02:21 <kallisti> I'm pretty sure he didn't care, he just went with what I suggested.
20:02:29 <Clint> why didn't you suggest a good license instead?
20:02:46 <ssbr> Clint: why isn't BSD good?
20:02:48 <kallisti> BSD is a good license.
20:02:53 <ssbr> and what's a good license, to you?
20:03:29 <ski> Luke : possibly `MaybeT' ?
20:03:48 <Luke> in this case the Maybe is the inner monad
20:04:14 <Luke> oh wait I see
20:04:17 <Luke> yeah i'll try that - thanks
20:04:20 <ski> yes, but you can go between `m (Maybe a)' and `MaybeT m a' -- that's the point of `MaybeT'
20:04:28 <Clint> ssbr: mostly the vagueness introduced by having to replace the regents of uc throughout the license, also the advertising and name bits
20:04:40 <Clint> ssbr: if you want a permissive license i would go with mit or isc
20:04:57 <ski> Luke : you might also try `liftM2 (<|>)' -- not sure if that's the same as the `MaybeT' alternative
20:05:00 <ssbr> Clint: names bit is 4-clause BSD, which nobody uses anymore
20:05:08 <Clint> ssbr: no, advertising is 4-clause
20:05:16 <ssbr> mmm, soryr, right
20:05:23 <ssbr> anyway the other one is 3-clause, which is going out of style
20:05:28 <Clint> it is?
20:05:35 <ssbr> Slowly but surely.
20:05:40 * kallisti uses 3-clause.
20:06:22 <ski> Luke : hm, i suppose `liftM2 (<|>)' would always execute both `m'-actions, while `(<|>)' for `MaybeT m' might omit executing the right one if the left one doesn't fail (i.e. doesn't give `Nothing')
20:06:51 <ssbr> Clint: as for "vagueness", normally the template doesn't include "regents of uc": http://www.opensource.org/licenses/BSD-2-Clause
20:06:51 <Luke> yeah so I want MaybeT
20:07:17 <Luke> ski: is there a way to do it without converting (m (Maybe a)) to a (MaybeT m a)?
20:07:30 * ski . o O ( "regents of uc" ? )
20:08:13 <ssbr> ski: the original BSD license was written by the university of california and used its name in the license text
20:08:28 <ssbr> AFAICT Clint is complaining that you have to replace their name with yours in the license text, if you get it from some places
20:08:42 <Clint> yes, and people do silly things when they search&replace
20:08:45 <ski> Luke : maybe some operation in `newtype' ..
20:08:47 <ski> @hackage newtype
20:08:47 <lambdabot> http://hackage.haskell.org/package/newtype
20:08:48 <Clint> leading to potential legal problems
20:09:01 <ssbr> Clint: sure, but I've never seen such a template
20:09:24 <Clint> i suppose i am remembering the days before templates
20:09:32 <Clint> when you would just cargo-cult someone else's license
20:09:55 <ssbr> but then that'd apply to MIT too
20:10:25 <Clint> er?
20:10:43 <ssbr> Clint: if you cargo-cult someone's MIT license, you have to replace their name with yours
20:10:57 <kallisti> at least. I hope you do.
20:11:02 <Clint> no, unless you're including the copyright notice
20:11:05 <Clint> in "license"
20:12:02 <Clint> or perhaps you mean MIT/X11
20:12:28 <ssbr> no, MIT/X11 uses "the above copyright holders" in the body
20:12:34 <ssbr> I meant the copyright notice because I was dumb
20:13:01 <Clint> heh
20:16:40 <ski> @quote Extreme.Anger
20:16:40 <lambdabot> byorgey says: Extreme Anger Programming: you are paired with a really dumb partner and after twenty minutes of agony you rip the keyboard from their hands, delete everything they typed, and do it
20:16:40 <lambdabot> yourself
20:17:13 <ssbr> oh so thaaaat's why they always do that
20:17:36 <XexonixXexillion> is there any equivalent of a let clause for type signatures? i.e let d = a -> b -> c in d -> d -> a -> b -> d
20:18:03 <ski> sorry, nope
20:18:26 <ski> (O'Caml has sortof this)
20:18:30 <ssbr> next you're gonna want functions from types to types!
20:18:48 <ski> then best you can do is use a type synonym (passing all the free type variables as parameters to it)
20:20:03 <ski> i.e. you could say `type D a b c = a -> b -> c' and then use `D a b c -> D a b c -> D a b (D a b c)'
20:20:23 <ski> (not sure if that is better)
20:20:36 <parcs`> what about type equality constraints?
20:20:55 <parcs`> :t undefined :: (d ~ a -> b -> c) => d -> d -> a -> b -> d
20:20:56 <lambdabot> parse error on input `->'
20:20:56 <ski> hm .. could possibly work
20:21:06 <parcs`> :t undefined :: (d ~ (a -> b -> c)) => d -> d -> a -> b -> d
20:21:08 <lambdabot> forall c a b. (a -> b -> c) -> (a -> b -> c) -> a -> b -> a -> b -> c
20:23:25 <Cale> XexonixXexillion: If you turn on extensions, you can use a type equality constraint, I guess...
20:24:04 <Cale> ah parcs` already mentioned that :)
20:24:38 <XexonixXexillion> Cale: I just did that, it makes it so much more readable
20:30:18 <Eduard_Munteanu> :t undefined :: (d ~ (a -> b)) => d -> d -> a -> b -> d
20:30:20 <lambdabot> forall a b. (a -> b) -> (a -> b) -> a -> b -> a -> b
20:31:37 <Eduard_Munteanu> The quantification seems a bit arbitrary.
20:31:58 <Eduard_Munteanu> For the one containing 'c'.
20:36:22 <parcs`> :t undefined :: (d ~ (forall c. a -> b -> c)) => d -> d -> a -> b -> d
20:36:24 <lambdabot>     Illegal polymorphic or qualified type: forall c. a -> b -> c
20:36:24 <lambdabot>     In an expression type signature:
20:36:24 <lambdabot>       (d ~ (forall c. a -> b -> c)) => d -> d -> a -> b -> d
20:39:27 <parcs`> i wonder if it's yet possible to dynamically link the ghc binary
20:58:43 * hackagebot js-good-parts 0.0.4 - Javascript: The Good Parts -- AST & Pretty Printer  http://hackage.haskell.org/package/js-good-parts-0.0.4 (SeanSeefried)
21:24:55 <Levine> Hey guys, began to learn Prolog and i am trying use the .lsp file on my Command Center...when i click it it says that there is no program and search the web
21:25:00 <Levine> but i already installed
21:25:11 <Levine> somebody know how can i fixed ?
21:26:02 <Ralith> I think you're in the wrong channel.
21:27:18 <Levine> Ralith: i saw here before , the guys were talkin about Prolog :D
21:28:19 <Ralith> I once saw someone talking about food here.
21:28:23 <Ralith> I don't come here for culinary advice.
21:29:27 <zzing> ##prolog?
21:31:14 <Levine> Ralith: you re so nice my friend...dont talk if you dontt to help
21:31:18 <Levine> zzing: yes
21:31:45 <zzing> I was one who mentioned prolog earlier
21:32:10 <Levine> zzing: Should i maybe add a path for using Prolog ?
21:32:55 <shachaf> Levine: This is indeed not the channel for asking about installing Prolog environments.
21:33:29 <copumpkin> we might mention prolog occasionally from a PL interest standpoint and how it (and other logic languages) relates to parts of haskell's type system
21:33:48 <copumpkin> but this channel is really not interested in the mundane details of installation of prolog environments :)
21:34:00 <Levine> well yeah ok , thx guys
21:43:41 <zzing> :t lift
21:43:42 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (MonadTrans t, Monad m) => m a -> t m a
21:45:06 <zzing> :t (<*>)
21:45:08 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
21:45:10 <zzing> :t ($)
21:45:11 <lambdabot> forall a b. (a -> b) -> a -> b
21:46:42 <zzing> Why is <*> not <$> if it is a similar thing?
21:47:02 <shachaf> Because it's a similar thing, not an identical thing.
21:47:09 <shachaf> "similar" is similar to "identical", but it is not identical.
21:48:06 <conal> shachaf: :)
21:48:21 <conal> zzing: <$> is a specialization of <*> via 'pure'
21:48:41 <zzing> :t <$>
21:48:43 <lambdabot> parse error on input `<$>'
21:48:47 <zzing> :t (<$>)
21:48:48 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
21:50:26 <zzing> ok, I remember it from before now
21:51:03 <zzing> So basically is pure to inject, and <*> to operate over?
22:06:12 <Nensha> Hello I need some help with Haskell basics
22:06:32 <Nensha> There is: [ (pkgName . sourcePackageId) p | (p:_) <- allPackagesByName pix ]
22:06:42 <Nensha> How does it work?
22:07:43 <mkscrg> what's the defacto standard package for working with regexes these days?
22:13:30 <Axman6> Nensha: what don't you understand? there's quite a lot going on there
22:13:56 <Nensha> Axman6: so what is | here :D
22:14:11 <Axman6> > [ x + 3 | x <- [1,2,3]]
22:14:12 <lambdabot>   [4,5,6]
22:14:31 <Axman6> > [ x + y | x <- [1,2,3], y <- [10,20,30]]
22:14:32 <lambdabot>   [11,21,31,12,22,32,13,23,33]
22:14:38 <Axman6> > [ (x,y) | x <- [1,2,3], y <- [10,20,30]]
22:14:39 <lambdabot>   [(1,10),(1,20),(1,30),(2,10),(2,20),(2,30),(3,10),(3,20),(3,30)]
22:14:42 <Eduard_Munteanu> Nensha: look up list comprehensions, it's part of their syntax.
22:14:43 <zzing> gotta love list comprehension
22:14:46 <Axman6> this is a list comprehension
22:15:29 <Cale> > [(x,y) | x <- [1..10], y <- [1..10], x^2 < y]
22:15:31 <lambdabot>   [(1,2),(1,3),(1,4),(1,5),(1,6),(1,7),(1,8),(1,9),(1,10),(2,5),(2,6),(2,7),(...
22:16:10 <zzing> :t ap
22:16:11 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
22:17:41 <zzing> Can I make assign a name of a function to a constructor? Such as   pure = Just
22:18:27 <Cale> [ (pkgName . sourcePackageId) p | (p:_) <- allPackagesByName pix ] means  "the list of package names of the source package IDs of packages p which are the first elements of lists in the list of all packages grouped by name in the package index pix"
22:18:57 <Nensha> Axman6: I see
22:19:21 <XexonixXexillion> zzing: yes
22:19:36 <Nensha> Axman6: what means (p:_) ?
22:20:00 <zzing> head of a list
22:20:05 <zzing> doesn't care what the rest of it is
22:20:27 <Cale> Nensha: It's a pattern which matches a nonempty list
22:20:29 <Axman6> > [(x,y) | [x <- [1..100], y <- [1..x], x*x <= y && (x+1)*(x+1) > y]
22:20:30 <lambdabot>   <no location info>: parse error on input `<-'
22:20:42 <Cale> and names the head of that list p, and discards the rest of the list
22:20:48 <Axman6> > let f (x:xs) = (x,xs) in [1,2,3]
22:20:49 <lambdabot>   [1,2,3]
22:20:53 <Axman6> > let f (x:xs) = (x,xs) in f [1,2,3]
22:20:54 <lambdabot>   (1,[2,3])
22:20:59 <Cale> the reason that this is done in this case, is that we only care about package names apparently
22:21:29 <Axman6> > [(x,y) | x <- [1..100], y <- [1..x], x*x <= y && (x+1)*(x+1) > y]
22:21:30 <lambdabot>   [(1,1)]
22:21:34 <Cale> and allPackagesByName produces a list of lists of packages, grouped so that all the packages with the same name are together in the same list
22:21:36 <zzing> Is a valid definition of Applicative Maybe a:  pure :: a -> Maybe a ; pure = Just.     (<*>) :: Maybe (a -> b) -> Maybe a -> Maybe b ;  (<*>) (Just g) (Just x) = Just $ g x ; (<*>) Nothing _ = Nothing ; (<*>) _ Nothing = Nothing.   I have gone through the law fmap g x = pure g <*> x   and it seems to satisfy this.  The definition in the source code just points to return and ap.
22:21:49 <Axman6> > [(x,y) | y <- [1..100], x <- [1..y], x*x <= y && (x+1)*(x+1) > y]
22:21:51 <lambdabot>   [(1,1),(1,2),(1,3),(2,4),(2,5),(2,6),(2,7),(2,8),(3,9),(3,10),(3,11),(3,12)...
22:21:54 <Cale> (so looking at the first package of each list is sufficient)
22:22:42 <Cale> zzing: Yes, that's valid
22:22:59 <Cale> zzing: It's equivalent to the instance you get from Monad using return and ap
22:23:06 <Axman6> zzing: looks good, though you can just make <*>: (Just f) <*> (Just x) = Just (f x); _ <*> _ = Nothing
22:23:28 <zzing> ok, a litle simpler
22:24:04 <zzing> Where does 'ap' come from? I am going through Typeclassopedia, and just finished Applicative
22:24:21 <Cale> ap is defined in terms of the Monad operations
22:24:38 <Axman6> :t ap
22:24:39 <Nensha> Axman6: I see, thank you.
22:24:39 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
22:24:51 <zzing> It just looks like <*> directly
22:24:56 <zzing> Just more restrictive
22:25:02 <Axman6> > [(x,y) | x <- [1..100], y <- [1..x], y*y <= x && (y+1)*(y+1) > x]
22:25:03 <lambdabot>   [(1,1),(2,1),(3,1),(4,2),(5,2),(6,2),(7,2),(8,2),(9,3),(10,3),(11,3),(12,3)...
22:25:38 <Cale> zzing: It should always be equivalent to (<*>)
22:25:49 <Cale> in the case that there's an instance of both Monad and Applicative
22:26:01 <zzing> ok
22:26:41 <Cale> ap fs xs = do f <- fs; x <- xs; return (f x)
22:26:44 <Cale> or:
22:26:57 <Cale> ap fs xs = fs >>= \f -> xs >>= \x -> return (f x)
22:28:02 <zzing> @src liftM2
22:28:02 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
22:28:14 <zzing> @src liftM1
22:28:15 <lambdabot> Source not found. Take a stress pill and think things over.
22:28:21 <Cale> @src liftM
22:28:21 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
22:29:07 <Cale> liftM is the same as fmap, but implemented in terms of return and (>>=)
22:29:21 <Cale> So it can always be used to define an instance of Functor for a monad
22:29:53 <Cale> :t liftM2 id
22:29:54 <lambdabot> forall a2 r (m :: * -> *). (Monad m) => m (a2 -> r) -> m a2 -> m r
22:30:02 <Cale> ^^ another way to write ap
22:30:29 <zzing> So many similar things for dealing with slight variations
22:30:37 <Axman6> hmm, do the Monad laws ensure that defining Functor in terms of liftM maintains the laws of Functor?
22:30:48 <shachaf> Axman6: Yes.
22:31:09 <Nensha> Axman6: if (p:_) is template for allPackagesByName :: PackageIndex -> [[InstalledPackageInfo]]
22:31:38 <Nensha> Axman6: then for allPackagesByName :: PackageIndex -> [(PackageName, [InstalledPackageInfo])] it will be (_,(p:_)) ?
22:31:57 <Axman6> Nensha: the pattern (x:_) just extracts the first element of the list passed to it, and calls it x (or p in your case)
22:32:34 <Nensha> Axman6: I see, but is my second template correct
22:32:48 <Cale> allPackagesByName pix :: [[InstalledPackageInfo]], and then p :: InstalledPackageInfo will be bound to the first element of each of the list of lists in turn
22:33:35 <zzing> Now I recall people talking about using liftA2 instead of liftM2
22:34:06 <Nensha> Cale: then for [(PackageName, [InstalledPackageInfo])] it should be (_,(p:_)) ?
22:34:14 <Cale> yeah
22:34:23 <Cale> assuming that you want to ignore that PackageName
22:34:38 <Cale> however, if your goal is to pull out the package names...
22:35:13 <Cale> then you might just want to use [p | (p,_) <- ...]
22:35:43 <Nensha> Cale: I just need to save the same functional at first
22:36:06 <Nensha> Cale: I'm trying to port util according cabal updates
22:36:18 <shachaf> Axman6: Hah, it uses all three monad laws, actually.
22:39:42 * Axman6 is a failed Haskeller; can't remember the monad laws off the top of his head
22:40:01 <shachaf> Axman6: They're just like the monoid laws. :-)
22:40:15 <dmwit> (>=>) is associative and return is its unit
22:40:16 <Cale> Axman6: The easiest way to remember them is in terms of the Kleisli fish
22:40:17 <dmwit> those are the laws
22:40:29 * shachaf doesn't like (>=>), though.
22:40:29 <zzing> Can IO be done in terms of Applicative instead of Monads?
22:40:34 <Eduard_Munteanu> Fish?
22:40:50 <Cale> Eduard_Munteanu: It's a joke about how <=< looks a bit like a fish
22:40:53 <Eduard_Munteanu> Oh.
22:40:53 <Eduard_Munteanu> :)
22:41:06 <kfish> kleisli fish is awesome!
22:41:16 <Cale> zzing: Yes, but Applicative is a weaker interface, so you can't express some things.
22:41:21 <Eduard_Munteanu> kfish: hah, is that what your nick stands for?
22:41:43 <kfish> Eduard_Munteanu, sure, for today :)
22:42:13 <shachaf> Axman6: Anyway, http://www.haskell.org/haskellwiki/Monad_Laws
22:43:58 <zzing> Why do they call pure pure? Its use reminds me more of 'inject' like injecting its parameter into the context.
22:44:03 <Axman6> hmm, the fish laws make it much easier to remeber
22:44:28 <liyang> In particular, with Applicative, you can't inspect the result of one computation and use it to decide what the next ought to be. The structure (or path, if you like) of the computation is fixed.
22:44:30 <zzing> Axman6, fish laws?
22:44:40 <XexonixXexillion> zzing: Try coming up with a function to echo a line without using bind (>>=) if you want to see the limitations of applicative
22:44:41 <shachaf> zzing: See above.
22:44:44 <Axman6> see the end of shachaf's link
22:45:01 <shachaf> Are the join laws easy to remember?
22:45:04 <zzing> ok
22:45:58 <zzing> Is there any way to be evil and have a function to go from IO a -> a
22:46:11 <Axman6> :t unsafePerformIO
22:46:12 <lambdabot> Not in scope: `unsafePerformIO'
22:46:16 <Axman6> @hoogle unsafePerformIO
22:46:16 <lambdabot> System.IO.Unsafe unsafePerformIO :: IO a -> a
22:46:17 <lambdabot> Foreign unsafePerformIO :: IO a -> a
22:46:24 <shachaf> zzing: You shouldn't know about it at this point.
22:46:26 <shachaf> Please don't use it.
22:46:41 <zzing> shachaf, I ignore everything that says unsafe in the name :-)
22:47:32 <shachaf> So which join laws do you need?
22:47:48 <shachaf> join . join = join . fmap join is one.
22:48:04 <zzing> What exactly is a left identity and right identity?
22:48:20 <Axman6> > 0 + 1
22:48:21 <lambdabot>   1
22:48:23 <shachaf> @google What exactly is a left identity and right identity
22:48:24 <Axman6> > 1 + 0
22:48:24 <lambdabot> http://en.wikipedia.org/wiki/Identity_element
22:48:25 <lambdabot> Title: Identity element - Wikipedia, the free encyclopedia
22:48:26 <lambdabot>   1
22:48:36 <Axman6> 0 is both a left and right identity for (+)
22:48:45 <shachaf> I guess join . fmap return = join . return = id
22:49:22 <shachaf> Is that it?
22:49:59 <shachaf> Some places list more laws.
22:50:57 <XexonixXexillion> The mention of unsafePeformIO reminded me of this; is there a "pure" way to pack a CString into a bytestring, or am I stuck using unsafePerformIO?
22:51:45 <Axman6> can't you turn a CString into a Ptr, and turn that into a bytestring?
22:52:07 <zzing> By what reckoning is a law a law and not just a nice thing to have?
22:52:21 <zzing> Or just by definition?
22:52:23 <shachaf> zzing: It's the definition of an API.
22:52:42 <zzing> Given this is all math, I have to accept 'by definition' :-)
22:52:42 <Axman6> well, they're laws because you need to obey them or things break. they can be broken, and toy probably want to avoid that
22:53:11 <shachaf> Axman6: Sure, but that's because people rely on the definitions.
22:53:25 <shachaf> It's just like any other API.
22:53:32 <Axman6> right, and we rely on people not stabbing us because it's illegal
22:53:34 <XexonixXexillion> Axman6: A CString is a Ptr, but there is no "pure" version
22:53:41 <chu> Bob?!
22:53:50 <shachaf> If I define Read and Show and Eq such that read (show x) == x, that's a Read/Show/Eq law.
22:54:01 <Axman6> XexonixXexillion: also, how were you marks this semester?
22:54:06 <shachaf> Maybe I don't want to define it that way, though.
22:54:23 <chu> Axman6: Same to you, how did your project fare?
22:54:38 <dmwit> A type that offers operations with the types of (>>=) and return is a fine structure, it's just not a monad.
22:55:06 <shachaf> dmwit: Well, unless it obeys the monad laws. :-)
22:55:07 <Axman6> chu: well, I got a distinction in managing software development, so I can now graduate =) my honours project got dropped several months though, it wasn't working out
22:55:19 <zzing> "Of course, the IO constructor is famously a Monad, but its implementation is somewhat magical"  … Magicae odio.
22:55:28 <chu> Axman6: Aww :(
22:55:30 <XexonixXexillion> Axman6: I failed discovering engineering. They really didn't like my group's work. Otherwise it went alright.
22:55:39 <zzing> wb dmwit
22:56:17 <Axman6> chu: how about you? how'd you go?
22:56:38 <chu> Axman6: Meh.
22:57:21 <chu> Good to see Bob on IRC again though
22:57:51 <Axman6> he's not dedicated, he disconnects sometime
22:58:47 <zzing> Are there computer science programs out there that actually use haskell and not java on everything? :-(
22:58:55 <chu> Some.
22:59:09 <Axman6> ANU's does, yay
22:59:24 <Axman6> for at least three courses
22:59:24 <chu> Both XexonixXexillion and Axman6 were tutors for one such course.
22:59:38 <zzing> Apparently Sun invested a bit of  money ten years ago
22:59:43 <edwardk> zzing: io doesn't have to be magical, you can define reasonable semantics for it without anything scary
22:59:57 <shachaf> edwardk: You can?
22:59:58 <chu> Axman6: What's the third?
23:00:13 <Axman6> 1100, programming languages and 2600
23:00:15 <shachaf> edwardk: I think "magical" is just used as a word for "primitive".
23:00:23 <edwardk> shachaf: http://comonad.com/reader/2011/free-monads-for-less-3/
23:00:41 <chu> Axman6: Oh, can't *really* count 2600. I know when Ben took the multi-core course he did some in Haskell.
23:00:46 <edwardk> the io monad in that is still perfectly pure, its just a shift of perspective to allow the runtime system to interrogate a pure computation engine
23:00:46 <zzing> Where is the dividing line between undergraduate and graduate level stuff here?
23:00:53 <MostAwesomeDude> I wish there were people in here that did conduits. :c
23:00:57 <Axman6> multi-core course?
23:01:14 <edwardk> MostAwesomeDude: you just need to lurk in #yesod
23:01:15 <Axman6> zzing: this is all undergrad
23:01:20 <chu> Axman6: The graduate "Multi-core Computing" course, usually taken by Strazdins.
23:01:25 <shachaf> edwardk: Sure, but it's still "magic" in that you rely on the RTS.
23:01:29 <MostAwesomeDude> edwardk: Yeah, but they don't care about what I'm doing, which is building non-Web networking stuff.
23:01:30 <shachaf> I thought that was what whoever-said-that meant.
23:01:33 <chu> (It's *really* hard though, apparently)
23:01:40 <Axman6> chu: ah yes, I was sad to find out I'd missed out on it last year
23:01:55 <edwardk> shachaf: yes and no. compared to the real world passing nonsense, there is no optimization that spontaneously becomes unsound
23:01:57 <zzing> I am considering graduate level at some point, have about three years to build up to that
23:02:00 <shachaf> Also conal would probably argue about the meaningfulness of you "semantics". :-)
23:02:08 <edwardk> shachaf: yes he has =)
23:02:10 <XexonixXexillion> Axman6: I think it was almost all C last year though. I don't think Strazdins likes Haskell
23:02:23 <shachaf> Oh, I agree that the State thing is silly as far as trying to explain IO.
23:02:26 <Axman6> well, I like C too, so that's fine =)
23:02:45 <chu> XexonixXexillion: Of ccourse he doesn't, though 2310 in Java is a bit WTF-worthy.
23:02:48 <edwardk> while i'm quite pleased with the jiujitsu move that throws the evil parts to someplace where they don't muck up my beautiful pure language
23:03:06 <shachaf> This is similar to roconnor's article about the same thing.
23:03:12 <XexonixXexillion> chu: You should have seen Uwe's reaction to that
23:03:13 <shachaf> (And a bunch of other places, I guess.)
23:03:14 <Axman6> chu: yeah I'm really upset about that. it makes no fucking sense. Ada was _the_ language for that course for a reason
23:03:21 <edwardk> the language is pure, IO is just being pushed on it by a convention of how you interrogate the pure system
23:03:27 <chu> XexonixXexillion: Would have been priceless...
23:03:46 <edwardk> i don't know that i ever saw russell's article
23:03:47 <chu> when Alistair took it, he did it in C.
23:03:53 <shachaf> @google r6.ca free monad io
23:03:55 <lambdabot> http://r6.ca/blog/20110520T220201Z.html
23:04:06 <Axman6> chu: not really
23:04:20 <Axman6> I did it when Alistair took it, and there was plenty of Ada
23:04:22 <chu> Axman6: Yeah, he lumped some Ada in for the second assignment.
23:04:31 <Axman6> hmm, did we do it the same year?
23:04:39 <chu> Yes.
23:04:49 <Axman6> maybe my mind;s a bit rusty
23:05:01 <XexonixXexillion> Axman6: We should get them to do 2310 in Haskell. STM is your friend
23:05:08 <shachaf> My favorite way to introduce IO to people is a simplified non-monad datatype like "data IO = Exit | PutChar Char a | GetChar (Char -> a)"
23:05:16 <chu> But the emphasis was on C, he just used Uwe's slides for the Ada portion anyway.
23:05:22 <shachaf> It's easy to write an interpreter for that type in Haskell that translates it to "real IO".
23:05:40 <chu> XexonixXexillion: I wonder if Uwe would be willing to consider that now?
23:05:52 <Axman6> shachaf: that definition looks kinda broken :\
23:05:57 <shachaf> Er.
23:06:01 <chu> XexonixXexillion: (Also, with your bindings in tow, of course)
23:06:03 <shachaf> My favorite way to introduce IO to people is a simplified non-monad datatype like "data IO = Exit | PutChar Char IO | GetChar (Char -> IO)"
23:06:08 <shachaf> Better? :-)
23:06:11 <Axman6> better
23:06:30 <edwardk> shachaf: apparently russell's article was born out of the same set of discussions that led to my article and the yoneda'd free monad
23:07:08 <edwardk> but he implemented it with the crappy version of the free monad ;)
23:07:33 <shachaf> By which you mean "handwritten" or what?
23:08:33 <zzing> :t (>>=)
23:08:34 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
23:09:14 <zzing> Can somebody describe what (>>=) :: [a] -> (a -> [b]) -> [b]  is exactly supposed to do without giving away the implementation?
23:09:30 <zzing> It looks close to map.
23:09:35 <XexonixXexillion> chu: He wouldn't do it in Haskell. It's a lot easier for the students to learn ada for the course than it would be to learn haskell, even though they've already done a semester of it
23:09:38 <shachaf> zzing: There's only one implementation that follows the monad laws.
23:10:04 <shachaf> And no, not really -- the implementation *is* "what it's supposed to do". :-)
23:10:08 <chu> XexonixXexillion: It certainly would be challenging, but you'd actually get *heaps* out of it, I imagine.
23:10:09 <zzing> shachaf, I haven't gotten to laws yet
23:10:23 <chu> XexonixXexillion: I guess this just serves the argument about "degree mill" really...
23:10:36 <zzing> It says to follow the types, but I don't see it
23:10:43 <shachaf> zzing: You're close.
23:10:49 <shachaf> It's like map, except...
23:11:37 <chu> XexonixXexillion: If you remember, his Ada slides are titled "Ada Refresher", so maybe he forsees failures ;p (Though, in reality, I imagine it's because he uses the same slides for real-time/embedded systems).
23:11:39 <zzing> Well, map generally deals with a function  a -> b, and I can't see this doing a map on [a] to produce many many more of [b]
23:12:06 <zzing> :t fmap
23:12:07 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
23:14:13 <zzing> I will then look at the monad laws
23:14:27 <zzing> and do I need to implement a 'fail'?
23:14:31 <shachaf> No.
23:15:12 <shachaf> zzing: This will probably do more to confuse you than to help, but "do { x <- [1,2,3]; ... }" "non-deterministically chooses" each element of [1,2,3] as x.
23:15:22 <shachaf> So x will become all three of them.
23:15:31 <XexonixXexillion> chu: It would be very interesing to see the course in Haskell, but it's a huge change that somewhat detaches it from the underlying theory without much benefit
23:15:40 <shachaf> Then it'll give you the combined result for each of those choices at the end.
23:15:49 <shachaf> zzing: Maybe this'll be more helpful: It's just like list comprehensions.
23:16:11 <zzing> shachaf, it isn't just like it, it is list comprehensions. The other syntax is just special for this
23:16:27 <shachaf> If a is b, then a is just like b.
23:16:33 <shachaf> Also, that's not what the Report says.
23:17:04 <shachaf> And if you already know that it's just like list comprehensions, why are you asking? You should be able to figure it out. :-)
23:17:59 <zzing> I don't always think in terms of everything else I know ;-)
23:18:20 <shachaf> That's why I said "be able to figure it out" rather than "know".
23:19:33 <chu> XexonixXexillion: Are you taking 3300 next semester by any chance? (It's the "Operating Systems" course)
23:20:21 <XexonixXexillion> chu: Probably
23:20:56 <chu> XexonixXexillion: Excellent.
23:21:06 <zzing> shachaf, my previous statement that I couldn't see it doing, it is doing it, it carries each element over and produces permutations just like in list comprehensions
23:22:08 <zzing> I must tackle this thing tomorrow.
23:22:20 <zzing> Thank you all for your support in this journey.
23:23:49 * hackagebot hlatex 0.2 - A library to build valid LaTeX files  http://hackage.haskell.org/package/hlatex-0.2 (NicolasPouillard)
23:29:56 <Axman6> chu: how'd you like 1100 this semester anyway?
23:30:45 <shachaf> I thought 1380 was pretty good, but 6298 was horrible.
23:31:17 <chu> Axman6: Admittedly, I stopped attending, but I did like it. The only feedback *I* got about it was from a student with no CS background who kind of slumped out part way through, I imagine he thought it was going to be a breeze and didn't commit to anything though.
23:31:58 <chu> Axman6: I never did it with Clem, so no idea how it was in comparison to that, though.
23:33:08 <chu> (I don't think people enjoy our random musings in here though, should we start an ANU channel on freenode? :p)
23:34:38 <Axman6> bah :P
23:35:08 <XexonixXexillion> chu: ANU does Haskell, therefore Haskell related... <_<
23:35:38 <chu> (I have just created ##anu if you're bored >.>)
23:37:22 <XexonixXexillion> chu: When you stopped turning up to lectures, your friend stopped turing up to lectures
23:38:05 <chu> XexonixXexillion: Yeah, he actually *really* disappointed me... By the time the second assignment came out, he still couldn't wrap his head around recursion ...
23:39:23 <XexonixXexillion> chu: He could use list comprehensions, and that was it as far as I could see
23:40:14 <chu> Except for the fact that it was Rachael who could use list comprehensions, if she didn't take the course along-side him, flat out fail.
23:43:20 <XexonixXexillion> chu: We're thinking of having actual tutorials as well as labs next year. Does that sound like a good idea to you?
23:45:33 <chu> Yeah definitely, it's a bit weird though because I found half of the class were doing it fine while the others were not getting any of the material, I imagine the onees who weren't getting the material were just not practicing, and I don't know if they'll go to the tutorials.
23:46:09 <dmwit> It is a somewhat well-known phenomenon that introductory CS classes enjoy a bimodal grade distribution.
23:46:19 <dmwit> One big hump near the top, one big hump near the bottom.
23:46:39 <dmwit> The cause is hotly debated.
23:46:52 <chu> Yeah, I can definitely see that, but it just appeared to me the ones who were not "getting" it, were really not trying.
23:47:45 <shachaf> I wonder where that use of "enjoy" originated.
23:48:25 <chu> I mean, Jay (the aforementioned friend) is actually a genuinely smart guy, he just didn't commit himself at all, but still expected to somehow (magically) work out what was going on.
23:49:26 <dmwit> shachaf: from sarcasm
23:49:45 <shachaf> dmwit: I mean in general.
23:50:02 <shachaf> To say that some nonsentient object "enjoys" something.
23:50:03 <edwardk> shachaf: no, not that its handwritten, but rather than it is asymptotically terrible
23:50:26 <edwardk> er rather that
23:50:32 <XexonixXexillion> chu: Some students were trying hard and just didn't get it. Do you remember Aidan (the student that thought *you* liked My Little Pony)?
23:50:54 <edwardk> shachaf: work out the asymptotics of doing repeated >>='s in left or right associated position on that monad
23:50:59 <shachaf> edwardk: I think his goals were clarity. :-)
23:51:03 <edwardk> sure
23:51:52 <shachaf> Much better to CPS everything edwardk-style!
23:52:16 <edwardk> well, i like running n steps in O(n) ;)
23:52:39 <chu> XexonixXexillion: I do remeber Aidan, but I still think they were slightly different cases. Jay was not a first-year student per se, he had done John's logic4fun stuff (though again, he didn't actually commit to that and it was really me who did the work for him there), he (apparently) has a grasp of logic (up to and including modal logics).
23:52:48 <edwardk> for some reason when my parsers or IO subsystem slows down polynomially as my program runs it bothers me ;)
23:52:58 <shachaf> edwardk: Well, it's a fact that your implementation runs n steps in O(n^3)!
23:53:00 <shachaf> So there.
23:53:25 * shachaf ought to go to sleep.
23:53:33 <edwardk> =P
23:53:50 * hackagebot egison 2.0.4 - An Interpreter for the Programming Language Egison  http://hackage.haskell.org/package/egison-2.0.4 (SatoshiEgi)
23:54:34 <chu> XexonixXexillion: Also, have you found anything "odd" about Church yet?
23:56:50 <XexonixXexillion> chu: I think we'll just have to accept that he was a normal person
23:57:20 <chu> XexonixXexillion: I don't think we can, he did *far* too much...
