00:05:02 <Ralith> dmwit: juicypixels looks perfect, thanks
00:21:24 <teaurchin> why can't hashUnique from Data.Unique be implemented as follows: hashUnique (Unique i) = i  ?
00:37:44 <augur> ski: right weakening introduces oddness if you try to give a CHC for the sequent calculus
00:38:17 <augur> ski: trying to un-sequentize it into string diagrams is fine, but the diagrams dont correspond to lambda terms in any nice way
00:40:05 <augur> ski: for example, if you say:   (x : P |- x : P   ===RW   x : P |- WK : Q , x : P)   ===\x   |- (\x.WK : P -> Q) , x : P
00:40:17 <augur> obviously this is undesirable because x is unbound now
00:40:30 <augur> but i suspect that a translation into lambda-mu works
00:45:15 <fmap> teaurchin: because that's a type error
00:50:11 <juhp> "user error", hmm
01:03:12 <teaurchin> fmap: okay...then why not provide another function with type Unique -> Integer?
01:08:25 <t7> microsoft made its first loss! Crack open the champagne :D
01:10:15 <fmap> teaurchin: no idea
01:11:46 * hackagebot egison 2.3.2 - An Interpreter for the Programming Language Egison (SatoshiEgi)
01:14:36 <t7> Satoshi....
01:16:47 * hackagebot egison 2.3.3 - An Interpreter for the Programming Language Egison (SatoshiEgi)
01:31:48 * hackagebot hamlet 1.1.0 - Haml-like template files that are compile-time checked (MichaelSnoyman)
01:31:50 * hackagebot servius 1.1.0 - Serve Shakespearean templates via Warp (MichaelSnoyman)
01:31:52 * hackagebot mega-sdist 0.2.0.1 - Handles uploading to Hackage from mega repos (MichaelSnoyman)
01:33:37 <augur> ski: according to that sörensen and urzyczyn book, cut = explicit substitution
01:33:47 <augur> in the term language
01:36:54 * hackagebot shakespeare 1.0.1 - A toolkit for making compile-time interpolated templates (MichaelSnoyman)
01:36:56 * hackagebot shakespeare-css 1.0.1.3 - Stick your haskell variables into css at compile time. (MichaelSnoyman)
01:36:58 * hackagebot shakespeare-js 1.0.0.4 - Stick your haskell variables into javascript/coffeescript at compile time. (MichaelSnoyman)
01:37:00 * hackagebot shakespeare-text 1.0.0.3 - Interpolation with quasi-quotation: put variables strings (MichaelSnoyman)
01:37:02 * hackagebot network-metrics 0.1.7 - Send metrics to Ganglia, Graphite, and statsd. (BrendanHay)
01:47:19 <ksf> gnargh. syntax.
01:47:37 <ksf> why is class (Foo (a)) where not allowed?
01:49:03 <bitonic> ksf: why would you ever need parens there?
01:49:16 <ksf> because I'm generating code.
01:49:29 <bitonic> ksf: why aren't you generating code via haskell-src-exts?
01:49:39 <ksf> because it doesn't deal with comments.
01:50:10 <ksf> ...and my own ad-hoc generator is too dumb to care about minimal parenthesis
01:50:13 <bitonic> ksf: mhm. I'd rater hack that to handle comments then re-write it.
01:51:01 <ksf> I'm not rewriting it, my ast can't do anything but print stuff.
01:51:30 <ksf> and it's geared -- by iterative evolution through using -- towards generating.
01:51:34 <bitonic> ksf: a pretty printer for haskell syntax is a fair amount of work on its own.
01:51:41 <bitonic> but anyway, your choice :)
01:51:44 <ksf> I don't need all of haskell.
01:51:56 <ksf> so far I don't have infix declarations, for example.
01:52:12 <quicksilver> I thought there was a haskell pretty printer whichdid comments and roundtripping
01:52:32 <ksf> well, yes.
01:52:46 <ksf> but you don't put comments in the ast, the only way to put comments in is by round-tripping.
01:53:00 <quicksilver> oh
01:53:48 <hpaste> ksf pasted “not pretty, but it works.” at http://hpaste.org/71810
01:54:50 <bitonic> ksf: there's also the question: why do you need comments in generated code?
01:54:55 <ksf> haddock
01:55:37 <bitonic> mhm, right. I'm surprised that there is no way to do that in haskell-src-exts.
01:55:47 <bitonic> there ought to be a way to add haddock comments
01:56:18 <ksf> feel free to add it.
01:56:29 <ksf> we still don't have the one AST to rule them all.
01:56:38 <ksf> compilers, code generators, refactorers.
01:56:55 <bitonic> ksf: well, when it came to generating haskell that package has served me very well
01:58:01 <timthelion> Does GHC use haskell-src-exts?
01:58:06 <ksf> nope
01:58:18 <ksf> it has a happy parser.
01:58:21 <ksf> or at least alex.
01:58:47 <timthelion> why are there two?
01:58:56 <ksf> histerical raisisn.
01:58:58 <ksf> *raisins
01:59:48 <ksf> ghc's parser and AST is older than TH, which is iirc older than haskell-src which is older than haskell-src-exts
02:00:28 <timthelion> you mean that the raisins were moldly, or that raisins are actually inteligent enough now to go mad?
02:00:28 <merijn> Isn't there an variant of findWithDefault that will insert the missing value into a Map/IntMap?
02:00:52 <ksf> hare switched from programmatica, which I dare you to build, to haskell-src-exts, after adding roundtripping.
02:01:24 <ksf> timthelion, nope, they were tasty.
02:01:33 <ksf> hence eaten fast, without a thought of tomorrow.
02:02:20 <timthelion> ksf: I'm to chicken to build anything, I gave up on building xmonad-extras when it failed
02:02:55 <ksf> well... programmatica. imagine a heap of non-hierarchical modules arranged in hirachical directories.
02:03:24 * timthelion is alleric to all but the most hippy, organic, sulfide free, rasins...
02:03:30 <ksf> sometimes using hierarchical imports of base stuff.
02:04:09 <ksf> I don't think I've ever seen sulfidised raisins in my whole life. some other dried fruit, yes, but not raisins.
02:04:46 <timthelion> all the raisins where I live arr
02:04:48 <timthelion> e
02:05:31 <timthelion> when I eat them I get a migrane and see double
02:09:41 <timthelion> or as a marketing team might put it, I gain asynchronous dynamic vision capabilities with proprietary light correction technologies, and real time application of specific motion and blur effects
02:11:54 <ketil> What's J#?  Something to do with GMP?
02:11:54 <rchatsiri> I'm finding Haskell design patterns.
02:12:03 <ketil> (doing memory profiling over here)
02:13:05 <merijn> I feel there should be a cleaner way then doing isJust + fromJust, but I don't see it? http://hpaste.org/71811
02:13:06 <timthelion> ketil: isn't J# Microsoft's .Net Java rip off?
02:13:55 <merijn> timthelion: I thought that's what C# was...
02:14:24 <timthelion> merijn: case stream of Just x -> ... ; Nothing -> .. ;
02:15:16 <timthelion> merijn: there was also a J# or J++ or something like that
02:16:08 <ketil> timthelion, oh, darn, I knew the Empire had some evil plan when they started funding GHC.  Now they fill up my heap with .net stuff!
02:16:50 * hackagebot parsec1 1.0.0.5 - Portable monadic parser combinators (ChristianMaeder)
02:16:56 <quicksilver> merijn: as timthelion says, this is exactly the great thing about case + pattern matching = you don't need to fromJust, because you already have a name for the value inside the Just.
02:18:57 <timthelion> ketil: if they do, then the project will have to fork, as I cannot exactly go installing mono here
02:19:09 <ksf> there's also
02:19:11 <ksf> :t fromMaybe
02:19:13 <lambdabot> forall a. a -> Maybe a -> a
02:19:13 <ksf> and
02:19:16 <ksf> :t maybe
02:19:17 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
02:19:30 <ksf> ...because pattern matching on maybe is lame.
02:19:38 <quicksilver> merijn: in this case, since you writeStream in both cases, consider moving that outside. I will annotate.
02:19:48 <ksf> see it as a control structure, not a data structure.
02:20:38 <timthelion> ksf: each unto their own...
02:20:48 <ksf> > maybe "bzzt" (++ " there") $ Just "Am I"
02:20:50 <lambdabot>   "Am I there"
02:21:15 <timthelion> > maybe "bzzt" (++ " there") $ Nothing
02:21:17 <lambdabot>   "bzzt"
02:21:36 <merijn> ksf: fromMaybe doesn't work in this scenario, because the initial a is in the IO monad
02:22:00 <ksf> 'a' can be 'IO a"
02:22:21 <ksf> > maybe (return ()) (putStrLn) $ Just "printme"
02:22:23 <lambdabot>   <IO ()>
02:22:31 <ksf> ...try it at home.
02:23:18 <merijn> I was using maybe initially, but I felt the if/then/else was more readable
02:23:39 <quicksilver> marienz:
02:23:43 <timthelion> merijn: and the case?
02:23:48 <quicksilver> merijn: annotation added
02:23:57 <ksf> I think if maybe isn't readable it's usually because there's not enough named functions.
02:24:18 <quicksilver> it's also a question of habit, ksf
02:24:47 <quicksilver> if you're used to maybe it's readable enough; on the other hand I don't see anything wrong with an explicit case for a well-known concrete data type.
02:26:00 <merijn> ksf: Yeah, but introducing named functions for no reason and one-of use cases is not really convenient
02:26:24 <ksf> the names are documentation.
02:26:43 <merijn> quicksilver: Ah, yeah. I think that's probably the best way
02:26:47 <timthelion> merijn: where and let are your friends there
02:27:13 <merijn> timthelion: I'd have to come up with names :p
02:27:23 <quicksilver> merijn: alternative, you make a primitive for the operation of "lookup stream by index and create if it doesn't exist"
02:27:40 <quicksilver> which would make sense if this is something you do in several places
02:28:15 <quicksilver> and it's one small step from there to wishing you were working in StateT (IntMap Stream) IO
02:28:15 <merijn> On semi-related note, I'm still not really happy with the way it looks when you have "<-" followed by a multi-line block. Somehow it feels like everything should be indented to be left of the arrow, but then your code marches off the screen
02:28:47 <timthelion> merijn: useCurrentStreamMap and createNewStreamMapAndInsertI...
02:28:47 <quicksilver> (because then you wouldn't have to faff around with explicitly threading the IntMap Stream)
02:29:13 <merijn> quicksilver: Yeah, but I only do this in one particular location and in general the amount of state I'm using is very small
02:29:18 <quicksilver> IntMap Stream -> Output -> IO (IntMap Stream) ~~~ Output -> MyMonad ()
02:29:30 <quicksilver> where MyMonad = StateT (IntMap Stream) IO
02:30:33 <merijn> I considered that (still slightly considering it), for now I didn't feel it was necessary
02:32:35 <merijn> Right now I'm essentially passing that function as a lambda to my loop combinator "stateLoop :: s -> Stream -> (s -> Output -> IO s) -> IO s"
02:37:49 <ketil> hah, found it:    | J# Int# ByteArray#   -- large integers
02:38:07 <ketil> Now I need to work out why my program is slinging around a bunch of large integers...
02:39:18 <ketil> "Unboxed tuples aren't really exported by GHC.Exts, they're available by default with -fglasgow-exts. An unboxed tuple looks like this:"
02:39:29 <ketil> -fglasgow-exts, really?  Is this still necessary?
02:39:38 <ketil> http://www.haskell.org/ghc/docs/7.2.1/html/users_guide/primitives.html
02:41:20 <t7> how to i pass C header and lib directory to cabal install/
02:42:38 <Digit> cycle "∞"
02:51:51 * hackagebot Craft3e 0.1.0.4 - Code for Haskell: the Craft of Functional Programming, 3rd ed. (SimonThompson)
03:39:42 <kuribas> Hi, I am trying to compile curry on linux mint (ghc 7.4.1), but configure fails with "checking whether ghc supports Haskell 98... no".  It worked on ubuntu (ghc 7.0)
03:41:24 <kuribas> Has something changed in ghc with the later release?
03:47:37 <tomboy64> kuribas: can you provide the full output please?
03:47:44 <tomboy64> kuribas: in a pastebin
03:49:17 <kuribas> conftest.hs:1:8: Could not find module `Char'  It is a member of the hidden package `haskell98-2.0.0.1'.
03:49:31 <kuribas> (from config.log)
03:51:44 <hpaste> kuribas pasted “autoconf curry” at http://hpaste.org/71815
03:52:11 * hackagebot HUnit 1.2.5.1 - A unit testing framework for Haskell (RichardGiraud)
03:52:23 <bitonic> kuribas: yeah, I remember that. You have to use the haskell98 package.
03:52:48 <kuribas> how?
03:54:05 <bitonic> kuribas: well, I'm not sure about that. You should try `-package haskell98' but you have to disable `base' in some way.
03:55:58 <bitonic> hiding base might work. might.
03:56:20 <kuribas> I can change the test in aclocal.m4, but I'll also have to change the build files, right?
03:56:28 <bitonic> e.g. using `ghc -package haskell98 -hide-package base'
03:56:47 <bitonic> kuribas: You can probably set the Haskell compiler somewhere
03:57:17 <Igloo> I'm not familiar with curry, but you're almost certainly better off making it use base instead
03:57:43 <kuribas> And change Char to Data.Char everwhere?
03:57:48 <Igloo> yes
03:57:54 <bitonic> kuribas: and other things.
03:58:05 <bitonic> I personally would try to make it work with haskell98.
03:58:14 <Igloo> Why?
03:58:39 <bitonic> Igloo: because it's most likely to be the least-hassle option
03:59:20 <kuribas> So is haskell98 obsolete?  I thought it was the newer system.
03:59:37 <bitonic> kuribas: newer compared to what?
03:59:44 <merijn> What's the difference between strict and lazy StateT? i.e. what exactly is strict as opposed to lazy?
04:00:09 <kuribas> bitonic: normal haskell?
04:00:19 <bitonic> kuribas: what's normal haskell?
04:00:21 <hpc> merijn: willItBlend = do
04:00:23 <mroman> merijn: Well
04:00:24 <hpc>   put undefined
04:00:29 <hpc>   modify (+ 2)
04:00:33 <hpc>   return "yes"
04:00:35 <kuribas> I thought haskell98 was a set of extensions of the base haskell language?
04:00:41 <mroman> [print 5,print 6] !! 0 <- if this prints 5 and 6 it's strict.
04:00:46 <mroman> else it's lazy.
04:01:14 <hpc> mroman: maybe if you put some unsafePerformIO in there
04:01:15 <bitonic> kuribas: I don't get what the "base haskell language" is. haskell98 is a standardisation of the language and some library, but haskell2010 is newer
04:01:41 <mroman> hpc: Hm?
04:01:45 <mroman> Why should I?
04:01:49 <hpc> > print 5
04:01:50 <lambdabot>   <IO ()>
04:01:57 <mroman> main=[print 5, print 6]!!0 works perfectly as it should
04:02:29 <merijn> hpc: So strict will force the state before executing the rest?
04:02:42 <mroman> > [reverse [1..],9]!!1
04:02:43 <lambdabot>   No instance for (GHC.Num.Num [t])
04:02:43 <lambdabot>    arising from a use of `e_1191' at <int...
04:02:50 <mroman> > [reverse [1..],[9]]!!1
04:02:52 <lambdabot>   [9]
04:03:00 <bitonic> kuribas: btw, iirc Curry runs on Prolog
04:03:03 <kuribas> bitonic: I see, so haskel2010 is the newest standard.
04:03:10 <hpc> merijn: i think with strict, you can put undefined just fine, but then the modify happens and you error out
04:03:14 <bitonic> kuribas: yes
04:03:15 <hpc> but i don't know for sure
04:03:28 <kuribas> bitonic: There are several implementations.  I am trying to compile the MCC (munster curry compiler).
04:03:35 <hpc> it's a good thing to test with
04:03:36 <quicksilver> mroman: what you say is not true.
04:03:42 <quicksilver> [print 5,print 6] !! 0 <- if this prints 5 and 6 it's strict.
04:03:52 <quicksilver> this is not what strictness means.
04:04:01 <quicksilver> if that prints 5 and 6 then it's *broken*
04:04:03 <quicksilver> impure.
04:04:09 <bitonic> kuribas: mhm. It looks pretty dead.
04:04:10 <quicksilver> which is orthogonal to strict.
04:05:06 <kuribas> bitonic: Yes, but there is an experimental branch with type classes, whereas PACKS runs on a propietary prolog.
04:05:29 <mroman> If it prints 5 and 6 it executed the print 6 even though it is not required.
04:05:38 <bitonic> kuribas: is says it runs on SWI, which is open source
04:06:24 <byorgey> mroman: right, and laziness has to do with whether or not things are *evaluated*, not whether they are *executed*.
04:06:54 <quicksilver> evaluating "print 6" does not execute it
04:07:01 <quicksilver> > print 6 `seq` "boo"
04:07:02 <lambdabot>   "boo"
04:07:23 <mroman> I'm aware of that.
04:07:59 <bitonic> mroman: so even if haskell was strict executing `[print 5, print 6] !! 0' would have the same result
04:08:23 <mroman> Due to how IO is handled, yes.
04:09:01 <bitonic> mroman: right. So that behaviour does not tell you much about how things are evaluated
04:09:11 <bitonic> well
04:09:35 <bitonic> it's more deep than "due to how IO is handled"
04:10:04 <bitonic> it really could not be any other way in Haskell
04:12:01 <kuribas> bitonic: I'll try kics2: "The first benchmarks indicate that Curry programs without non-determinism are executed as fast as Haskell programs and the efficiency of non-deterministic programs can compete with or outperforms other existing implementations of Curry."
04:12:35 <bitonic> kuribas: that looks alive, by the same author as PACKS
04:12:43 <bitonic> (I still don't get what's wrong about PACKS :P)
04:13:44 <mroman> But what's impurity got to do with lazy/strict?
04:15:04 <bitonic> mroman: being lazy while being impure is generally a bad idea
04:15:24 <kuribas> bitonic: "SWI-Prolog (if you do not have SICStus-Prolog, but then the execution is less efficient)."
04:15:40 <bitonic> kuribas: you're developing an high-performance application in curry?
04:15:47 <kuribas> bitonic: not yet :)
04:16:10 <bitonic> kuribas: I guessed so :). So I'd go with the more mature implementation without caring about that
04:16:36 <kuribas> bitonic: It just seemed like a hassle to install, but I'll try it too :)
04:16:43 <mroman> bitonic: I can't follow that.
04:16:47 <bitonic> kuribas: it really wasn't, when I tried
04:17:07 <bitonic> but I had sicstus. but I doubt that makes a difference
04:17:20 <mroman> Why would that be such a bad idea?
04:18:12 <kuribas> bitonic: Ok, I'll give it a try.
04:18:37 <bitonic> mroman: because if you have values that side-effect when evaluated, you usually want the side effects to happen immediately
04:19:09 <bitonic> in general you want to know when some effect is going to take place. with laziness that's not clear
04:19:16 <bitonic> well, with laziness + impurity
04:20:35 <mroman> Doesn't haskell have the exact same issue?
04:21:28 <bitonic> mroman: ...no, because you don't have side effects.
04:21:57 <mroman> Actually any haskell program should do nothing until main returns
04:22:09 <srhb> mroman: The whole trick of the IO Monad is that Haskell remains pure.
04:22:26 <mroman> As main is the only "gate" to the real word and that takes IO t
04:22:47 <ion> ಠ_ಠ
04:23:05 <ion> You should write an IO monad tutorial.
04:23:18 <srhb> <<
04:23:27 <bitonic> mroman: I think you are a bit confused about the execution model of Haskell
04:24:22 <mroman> Probably.
04:24:47 <mroman> My understanding is, that in the front everything remains pure because all is a big lie and behind the back it does impure stuff like all the time ;)
04:25:20 <bitonic> mroman: Haskell is a pure language. that's no lie.
04:25:43 <srhb> This took me a while to accept as well. :-)
04:25:47 <bitonic> what you do is manipulate IO actions, that are then converted to an executable/interpreted/whatever
04:26:12 <mroman> which is what I meant with behind the back.
04:26:24 <mroman> I'm aware of the concept of chaining/manipulating IO actions
04:26:28 <quicksilver> "behind the back it does impure stuff" is meaningless.
04:26:36 <ion> Well, impure stuff obviously happens. Memory allocations etc. But you only work with pure values in Haskell.
04:26:38 <quicksilver> purity is a property of the language, not the implementation.
04:27:03 <quicksilver> you could implement Haskell in Haskell and then you'd have two layers to get through before you saw any true impurity
04:27:09 <mikeplus64> mroman: haskell is pure, an IO action is clearly marked as such, there isn't any abstraction that you can add without making it ugly or convoluted to use as far as i know
04:27:53 <mikeplus64> unless you use unsafePerformIO in which case you have won the foot shooting race
04:28:19 <mroman> Yes. unsafePeformIO doesn't exactly fit into the whole "pure" picture
04:28:38 <quicksilver> unsafePerformIO isn't part of the haskell language, certainly
04:28:56 <quicksilver> it's an extension which removes the purity property
04:29:05 <mroman> but defined solely in terms of haskell?
04:29:17 <ion> It couldn’t.
04:29:18 <bitonic> mroman: no
04:29:19 <quicksilver> no, it can't be defined in haskell
04:29:26 <quicksilver> you can't write an impure construct in a pure language
04:30:10 <Philippa> it can: if you're willing to go to all the effort of implementing GHC(i) or equivalent
04:30:11 <mroman> If you simplify IO to data IO a = IO a (which probably is wrong
04:30:12 <mroman> but
04:30:19 <mroman> then unsafePerformIO (IO a) = a
04:30:29 <mroman> which looks pretty pure to me.
04:30:43 <ion> That’s not IO, that’s Identity.
04:30:43 <Philippa> it is. You just don't have the means to /execute/ that a
04:30:55 <ion> IO doesn’t contain the result value.
04:30:57 <Philippa> execution is the impure thing
04:31:17 <Philippa> (also, the point ion is making re typing, but still)
04:31:29 <Philippa> you aren't starting with an impure language then removing the impure bits
04:32:06 <mikeplus64> mroman: a way to implement it is case (let (IO x)) = io_action_goes_here in x) realWorld# of (# _, a #) -> a, but this requires a language extension, and the GHC base libraries to define things that can't be defined in Haskell terms (ie realWorld#, where the actual magic happens)
04:33:29 <quicksilver> mikeplus64: and that's not haskell.
04:33:31 <ion> mroman: People don’t just use unsafePerformIO for shits and giggles. It’s used with things like FFI when you know for sure what you’re calling doesn’t have side-effects apart from e.g. memory allocation.
04:33:33 <quicksilver> which is the important point.
04:33:49 <quicksilver> what mikeplus64 wrote is an impure language - which has no name - call it 'GHC' if you like.
04:34:04 <quicksilver> the fact that the syntax of that language is so like Haskell leads to this kind of confusion I think.
04:34:05 <mikeplus64> i like to call it peter :(
04:36:35 <trem> hi. i have a raytracer with a custom scene description format, which i'm reading with parsec. i'd like to extend that file format with some basic scripting capabilities like defining objects for later (re-) use, for loops and the like
04:36:58 <ion> trem: Haskell EDSL!
04:37:16 <trem> i think i'll have to add a map to my parser state to carry along the user-defined stuff, and to something with "typeable"
04:37:27 <doonod> i'm using cabal for the first time. can anyone tell me why I need a Setup.hs? the cabal command seems to do everything itself without need for it
04:37:34 <trem> ion, could you explain some more?
04:38:26 <mroman> Maybe the problem is describing IO as a State Monad containing RealWorld :)
04:38:42 <quicksilver> that is a terrible problem, certainly, mroman
04:38:48 <quicksilver> because IO is not that.
04:38:51 <ben> doonod: afaik the cabal command hooks into Setup.hs
04:40:01 <ion> trem: http://paulspontifications.blogspot.fi/2008/01/why-haskell-is-good-for-embedded-domain.html
04:40:56 <mroman> and all the other tutorials just usually say, that somewhere somehow something executes the IO actions.
04:41:16 <mroman> before the program is actually fully evaluated.
04:41:35 <quicksilver> just like C tutorials don't explain "how" printf actually makes characters appear on the terminal
04:41:42 <mroman> (by which I mean "main"-returned)
04:41:48 <quicksilver> it's convenient to explain up to an abstraction boundary.
04:42:20 <mroman> Well.
04:42:25 <ben> quicksilver: Learning C did throw me for a loop until I heard about syscalls :)
04:42:28 <mroman> printf - prints to stdout
04:42:31 <mroman> is enough.
04:42:43 <mroman> but in haskell printf - prints to stdout ultimatevely leads to the question
04:42:50 <mroman> why it does that in a pure context.
04:43:03 <trem> ion, this means i'm basically writing my scenes in haskell, right?
04:43:07 <Dtgr> printf does a lot more than just print out characters...
04:43:08 <mroman> (the other question is the type magic behind printf :D)
04:43:33 <ion> mroman: IO contains a hairy sh script representing the actions and the RTS runs the script assigned to main via /bin/sh. :-P
04:43:44 <mroman> Dtgr: Yes, but that doesn't really have to concern you as a user of printf.
04:44:07 <ben> ion: Would having that shellscript as a toy IO implementation make the whole monads things more approachable for newbies?
04:44:24 <Dtgr> mroman: as a user yes :)
04:44:38 <mikeplus64> ion: any link or something to this hairy sh script?
04:44:43 <mikeplus64> (curious)
04:45:10 <ion> trem: Yeah, you’d get all the looping etc. for free.
04:45:18 <quicksilver> mikeplus64: an IO value is a representation of a side-effectful action; the rules of the haskell RTS say that the 'main' IO action gets executed by the RTS.
04:45:21 <mikeplus64> trem: usually, although you could write a QuasiQuoter
04:45:23 <ion> mikeplus64: Alas, that implementation of IO is still vaporware. :-P
04:45:30 <quicksilver> mroman: ^^ oops that was for you.
04:45:46 <quicksilver> all other evaluation of your code is just driven by demand.
04:46:01 <trem> ion, but it requires the scenes to be compiled in the classic sense, requiring GHC, doesn't it?
04:46:04 <mroman> Yes.
04:46:33 <mikeplus64> ion: oh, i just came back from afk to read "IO contains a hairy sh script" which sounded horrible to me as a user of IO myself (lol) but also intriguing
04:46:51 <mroman> Which I translate to "behind the back the RTS does impure things" in my head.
04:47:21 <mroman> And I trust it doing the right thing at the right time.
04:47:35 <quicksilver> mroman: that feels like an ill-formed translation.
04:47:44 <ion> mroman: Behind the back the CPU modifies the state of the universe impurely.
04:47:57 <quicksilver> "pure" is an adjective which applies to evaluation.
04:47:58 <quicksilver> and nothing else.
04:48:08 <quicksilver> what the RTS is doing here isn't doing evaluation
04:48:18 <quicksilver> so it's illformed to discuss if it's "pure" or "impure"
04:48:28 <mroman> agreed
04:48:51 <quicksilver> suppose you have a robot which can read a very simple kind of ticker tape and run around the room baking cakes
04:49:04 <quicksilver> then your pure haskell program just produces a ticker tape
04:49:11 <quicksilver> which is a mathematically pure operation
04:49:24 <quicksilver> then the robot (RTS) runs the tape
04:49:34 <quicksilver> and bakes yummy cake.
04:50:33 <ion> unsafePerformIO would be nice in that system.
04:50:52 <mroman> And what does unsafePerformIO do in that analogy?
04:50:56 <ion> cake :: Cake; cake = unsafePerformIO bakeCake
04:51:01 <mroman> or why can't I extend that analogy to C?
04:51:11 <srhb> magically produces cake without the robot -- maybe.
04:51:25 <ion> You’d have a cake before the robot has received the instruction tape.
04:51:27 <mroman> I *could* define as printf doing stuff to the ticker tape too
04:51:49 <merijn> blah, when will haskell copy Habit's "case<- x of" and "if<- x then else"? :p
04:52:13 <mroman> hopefully never.
04:52:17 <mroman> That looks weird :P
04:52:20 <srhb> merijn: What? :p
04:52:25 <ben> we're getting x >>= \case, aren't we
04:52:25 <Botje> merijn: they accepted case lambdas for 7.6.x
04:52:25 <mikeplus64> merijn: well we have lambda case now
04:52:30 <srhb> ben: yes
04:52:34 <mikeplus64> haha
04:52:45 <merijn> Botje: How do those work?
04:53:00 <Botje> \case of { Foo -> ...; Bar -> ... }
04:53:01 <ion> merijn: As ben said.
04:53:11 <mroman> Maybe I need a link to a description of how IO works which doesn't lie and actually says how it is done in GHC RTS
04:53:12 <ben> Oh, is the of still there
04:53:16 <mikeplus64> merijn: so it's now \case ... =<< x
04:53:23 <srhb> No, it isn't
04:53:52 <srhb> \case { Pat -> Foo; ... }
04:53:55 <merijn> hmm, that might okay I guess
04:54:13 <mroman> Some say in the first two sentences "the following story about IO is incorrect"
04:54:16 <srhb> I certainly foresee a lot of map (\case ...)
04:54:22 <ion> I dislike the \ in front of it, but that’s better than nothing.
04:54:48 <merijn> Although I'm not sure I like the fact that you'd end up with "val <- get >>= \case {}"
04:55:06 <ben> Nothing stopping me from doing #define caseOf \case
04:55:11 <quicksilver> mroman: I don't think you do.
04:55:24 <quicksilver> mroman: I mean, I will not attempt to stop you being interested in how GHC implements it.
04:55:28 <quicksilver> that *is* interesting.
04:55:42 <merijn> On the other hand, this probably isn't better anyway "val <- case<- get of"
04:55:43 <quicksilver> but how GHC implements it is not the best way to understand how it is defined to work.
04:55:50 <srhb> I never understood case of.. Clearly it should be "match among"
04:55:56 <srhb> :-)
04:56:23 <quicksilver> GHC's implementation is a language which looks like haskell, but isn't haskell, has a bunch of impure primitives which behave in surprising ways, and some hideous hacks to prevent the optimiser breaking these primitives because they break the very rules the optimise likes to use.
04:56:48 <mroman> so
04:56:54 <mroman> Does *Haskell* even have IO?
04:56:58 <trem> ion, I get to like the haskell edsl approach, thanks for the hint! :-)
04:57:07 <ben> mroman: Yes, but it doesn't tell you how it works
04:57:19 <merijn> But since I have no 7.6 yet, is there a nicer way to write "val1 <- get; val2 <- case val1 of {}"?
04:57:30 <ben> The downside is that Haskell is an abstract concept and doesn't execute your .hs files
04:58:02 <ben> merijn: Not much nicer than val 1 <- get >>= \x -> case x of {}
04:58:14 <mikeplus64> > \x -> case x of{ _ -> True } $ 3
04:58:15 <lambdabot>   Couldn't match expected type `a -> b'
04:58:15 <lambdabot>         against inferred type `GHC.Bo...
04:58:18 <ben> though you could hide \x -> case x of in a C preprocessor macro :)
04:58:26 <mikeplus64> what is ghc parsing that as?
04:58:34 <mikeplus64> oh
04:58:39 <mikeplus64> neverind
04:58:41 <mikeplus64> lol
05:08:46 <McManiaC> how can I access C constants with the FFI? I tried the CPP extension with #include <...> but then I get "#error this file needs to be ported to your compiler"
05:09:20 <quicksilver> you can't.
05:09:32 <quicksilver> the FFI is an interface to the ABI of C object files
05:09:40 <quicksilver> so it is all about functions, for the most part.
05:10:09 <quicksilver> if you want constants you need a (presumably automatically generated) interface file
05:10:14 <quicksilver> there are tools for this kind of thing.
05:10:25 <McManiaC> ok, so either write my own wrapper C functions that return those values or simply copy & paste the C values by hand?
05:10:54 <McManiaC> toos like..?
05:12:16 <quicksilver> McManiaC: c2hs hsc2hs greencard
05:12:22 <quicksilver> I think greencard is obsolete though.
05:12:54 <merijn> hmm, is there a way I can write type signatures for local functions when a type variable from the top level function would appear in its type?
05:12:59 <McManiaC> okay, will have a look, thanks
05:13:03 <quicksilver> McManiaC: http://blog.ezyang.com/2010/06/the-haskell-preprocessor-hierarchy/
05:13:06 <srhb>  merijn: Not without an extension
05:13:18 <quicksilver> merijn: they used to call this -XScopedTypeVariables
05:13:25 <quicksilver> an eminently sensible extension
05:13:30 <quicksilver> but I think it's been bundled in with something else now
05:13:41 <optimight> Is there any cheet sheet for writng data-types and type classes? -   Which can describe all possible manner - e.g. data {-type-} = {-constructor-} {-type-} ... {-type-}
05:13:44 <merijn> Would you recommend enabling the extension or just leaving the types out?
05:13:47 <srhb> Scoped type variables should be in the standard..
05:13:51 <quicksilver> definitely
05:13:59 <quicksilver> it's a very sensible extension don't feel shy about using it.
05:14:15 <merijn> optimight: I had a haskell syntax cheat sheet (well, still have) lemme throw it online for you somewhere
05:15:08 <optimight> merijn:  thanks , it will help me a lot ...will save great deal of my time..
05:16:12 <McManiaC> quicksilver: looks good :)
05:16:28 <merijn> optimight: ah, bah. My university webhost seems down, if you msg me your e-mail I'll just mail it to you
05:17:05 <optimight> merijn: superobjects@gmail.com
05:17:10 <t7> _Control_.Monad , _Data_.Function ... why?
05:17:14 <t7> Functor*
05:19:53 <merijn> optimight: Sent
05:20:23 <t7> thank heavens for do notation
05:20:51 <merijn> quicksilver: Yeah, ScopedTypeVariables doesn't seem to work and so far I haven't found the correct new one :\
05:21:23 <quicksilver> did you add the 'forall' as the docs tell you to, merijn ?
05:21:44 <Manoel> anybody here develop in java
05:21:59 <srhb> Manoel: Did.. :(
05:22:01 <loopei> Hello all! I have a function "foo a b = bar $ baz a b", i'm sure I can rewrite that point-free, but I'm not sure! any ideas?
05:22:22 <srhb> @pl foo a b = bar $ baz a b
05:22:22 <lambdabot> foo = (bar .) . baz
05:22:28 <srhb> loopei: There you go
05:22:34 <Botje> loopei: you can eta-reduce it once as foo a = bar . baz a
05:22:37 <merijn> quicksilver: Ha! Optimistically assuming I read documentation :p
05:22:43 <merijn> quicksilver: But no, I did not :p
05:22:48 <merijn> (works now)
05:23:05 <Botje> loopei: to get to the second step, you have to realize that you're now applying the function (bar .) to baz
05:23:05 <loopei> srhb: wow! thanks. what's that lambda bot command do?
05:23:15 <srhb> loopei: Makes pointfree, obviously. :-)
05:23:43 <merijn> loopei: Rewrite code to be pointfree, with (frequently) disastrously unreadable code as a result :p
05:23:51 <Manoel>  anybody here develop in java
05:24:01 <srhb> Manoel: Already said I did, what's your question?
05:24:37 <merijn> Bah, with forall I need to start linewrapping my type signatures >.>
05:25:07 <nand`> merijn: ∀
05:25:31 <merijn> I still haven't found a comfortable way of type math unicode from my keyboard
05:25:33 <amatsu> nand`: would that require UnicodeSyntax?
05:25:37 <nand`> amatsu: yes
05:25:44 <nand`> merijn: Alt Gr + ` is ∀ for me
05:27:01 <merijn> Here it just results in the compose char for stuff like à
05:28:08 <nand`> merijn: it's keycode 49 in case you want to remap it using xmodmap
05:29:14 <merijn> Pretty sure xmodmap doesn't do much usefull stuff outside of X :p
05:29:44 <nand`> indeed, I think similar keycodes apply for whatever underlying keyboard system linux uses which I still haven't quite figured out
05:29:51 <nand`> but since I spend all my time in X, xmodmap's fine
05:30:55 <merijn> Your fundamental assumption of which OS people use is flawed :)
05:31:22 <nand`> :(
05:31:33 <nand`> BSD?
05:32:15 * hackagebot distributed-process 0.2.1.3 - Cloud Haskell: Erlang-style concurrency in Haskell (EdskoDeVries)
05:34:25 <merijn> nand`: Naah, I switched to OSX years ago because I got tired of having to constantly administer my machine
05:34:42 <t7> can i say "X exists in context" or do i have to say "... the Context"
05:34:46 <nand`> like adapting the keyboard layout? :P
05:35:40 <Dtgr> i switched from osx to linux because steve jobs makes developing software hard
05:36:07 <merijn> nand`: Pretty sure it's possible, but couldn't be arsed so far. I'd much rather have an input method (like I see my chinese colleagues use) that accepts LaTeX and converts to unicode
05:36:22 <srhb> merijn: Emacs supports that, if you can stick to it. :)
05:36:35 <nand`> but then you'd need to do everything in emacs!
05:36:39 <nand`> preposterous.... wait
05:36:52 <merijn> srhb: Never! Vim fo' life, yo!
05:37:04 <merijn> Dtgr: Pretty odd claim to make
05:37:08 <srhb> merijn: Emacs + Evil = Vim with extensibility. :P
05:37:18 <Dtgr> it was a joke :)
05:37:53 <merijn> srhb: If only
05:37:54 <Dtgr> even though it's odd how lion still only supports opengl 3.0 which was released 2008
05:37:57 <srhb> Dtgr: Actually I'm in the same process. These last few versions of OS X has had constant undocumented breakage of various build tools and paths, and I'm sick of it.
05:38:05 <nand`> Dtgr: at least it supports opengl 3.0
05:38:06 <srhb> merijn: :)
05:38:12 <nand`> Dtgr: my free graphics card drivers can't even say that
05:38:34 <Dtgr> :)
05:38:36 <luite> snow lion upgrades the opengl version again, doesn't it?
05:38:39 <merijn> nand`: That's what you run Windows 7 for, no?
05:38:47 * merijn ducks
05:39:15 <nand`> merijn: heh; not quite that bad, it just means I have to use the proprietary drivers (yuck)
05:39:25 <loopei> luite: snow lion? it's mountain lion
05:39:39 <luite> yeah that's what i mean, stupid apple names :p
05:40:02 <merijn> luite: To be fair, they're not nearly as stupid as the Ubuntu/Debian names
05:40:05 <loopei> luite: i'm not sure why you think it's a "stupid" name. there's an engineering name if you prefer, 10.8
05:40:22 <srhb> merijn: At least the Ubuntu ones have a system you can follow with the letters :P
05:40:58 <nand`> the ubuntu names make me chuckle
05:41:12 <srhb> They are quite silly. But they are also less stupid / meaningless. :-)
05:41:26 * nand` prefers rolling release systems without named versions, or versions at all
05:41:30 <luite> merijn: dunno, at least ubuntu names are clearly different and follow a pattern (first letter), apple names are getting more confusing now with leopard, snow leopard, lion, mountain lion, and they seem to have run out of big cats now
05:42:08 <nand`> luite: at least it's not microsoft-style ‘numbers with no clear pattern’
05:43:46 <merijn> luite: There's the version numbering when you need a clear distinction. It's not like there's that many names to begin with
05:44:14 <luite> 9 so far i guess?
05:45:16 <optimight> merijn: Thank you. Received the Haskell Cheat Sheet and reading it.
05:45:23 <merijn> 8, but I don't even know the first four or five, because they're so old no one uses them
05:45:59 <luite> merijn: 10.0 was cheetah
05:46:00 <merijn> optimight: np
05:47:39 <luite> merijn: which interestlingly was released in the same year as Windows XP...
05:52:20 <t7> @hoogle [[a]] -> [a]
05:52:20 <lambdabot> Prelude concat :: [[a]] -> [a]
05:52:21 <lambdabot> Data.List concat :: [[a]] -> [a]
05:52:21 <lambdabot> Data.List intercalate :: [a] -> [[a]] -> [a]
05:53:22 <simukis> How can I convert number to string, or rather how can I join string with a number? ("mystring"++123)?
05:53:38 <nlogax> > show 123
05:53:40 <lambdabot>   "123"
05:54:01 <simukis> nlogax: Thanks. Never tought of that
05:54:16 <nlogax> simukis: :)
05:55:56 <Nereid> @hoogle join
05:55:57 <lambdabot> Control.Monad join :: Monad m => m (m a) -> m a
05:55:57 <lambdabot> package join
05:55:57 <lambdabot> System.FilePath.Windows joinDrive :: FilePath -> FilePath -> FilePath
05:58:45 <nand`> hmm
05:58:51 <nand`> should -XUnicodeSyntax allow ≅ for ~ in type signatures?
05:59:25 <tomboy64> i want to modify my xmonad configuration and need additional keysymbols that aren't in Graphics.X11.Xlib.Types but in Graphics.X11.ExtraTypes.XorgDefault
05:59:35 <tomboy64> is it sufficient to import Graphics.X11.ExtraTypes.XorgDefault?
06:01:04 <tomboy64> HAHA!
06:01:05 <tomboy64> it is!
06:01:07 <applicative> it should be
06:01:13 * tomboy64 roxorz
06:01:15 <mikeplus64> > let x ≅ y = \f -> f x == f x in (1.0 ≅ 1.1) floor
06:01:17 <lambdabot>   True
06:01:34 <applicative> in the even of classes there are various expedients, tomboy64
06:01:42 <applicative> clashes rather
06:01:56 <tomboy64> applicative: pardon, expedients?
06:02:29 <applicative> if there are name clashs, you can e.g. import qualified  Graphics.X11.ExtraTypes.XorgDefault as Default
06:02:36 <srhb> Is it possible to write a deepJoin that collapses an arbitrary amount of, say, Maybes down to a single one, or is there a type issue here?
06:02:44 <applicative> tomboy64: then us Default.mykeybinding
06:03:02 <applicative> use rather
06:03:10 * applicative looks for other keyboard....
06:03:30 <Saizan> you can with some typeclass hackery, but it won't work so well with types containing type variables
06:03:40 <srhb> Indeed, okay..
06:03:50 <Saizan> oleg has a deep-fmap if you want to see
06:04:01 <srhb> Thanks, I'll search for that
06:04:08 <applicative> srhb this comes up a lot ... google  deepflat
06:04:28 <Saizan> (can probably made a little cleaner with ~ from type variables now, though)
06:04:30 <srhb> applicative: Ah, I've been lurking a lot and never actually heard talk of it in this channel. :)
06:04:32 <applicative> @google oleg deepflat
06:04:35 <lambdabot> http://www.haskell.org/pipermail/haskell-cafe/2010-December/087883.html
06:04:35 <lambdabot> Title: [Haskell-cafe] Deep concatenation [Was: Incorrectly inferring type [t]]
06:04:47 <applicative> oleg uses ~ in that email I think
06:06:00 <applicative> he is talking about lists but as Saizan it looks like it could be done for anything like that
06:06:11 <applicative> as Saizan says
06:06:14 <srhb> applicative: Sure. It doesn't even look that bad or hackish.
06:06:30 <applicative> it's OverlappingInstances I guess thats doubtful.
06:06:41 <hirsch_> I have a problem compiling my project on Travis-CI, I got this error but I don't know why: $ cabal install --enable-tests
06:06:41 <hirsch_> Resolving dependencies... cabal: Couldn't read cabal file "HUnit/1.2.5.0/HUnit.cabal"
06:06:55 <applicative> maybe this example is controlled enough not to be a problem
06:07:00 <hirsch_> any clues?
06:07:19 <applicative> is that a really old or really new HUnit, the format has changed some
06:08:03 <tomboy64> applicative: can i also only import the keybindings i definitely need?
06:08:06 <hirsch_> it is a new one
06:08:28 <hirsch_> oh, I'll try in #travis
06:08:32 <applicative> tomboy yes,  import Whatever.Module (binding1,binding2)
06:08:42 <tomboy64> cool
06:08:43 <applicative> tomboy64: rather ^^
06:08:53 <tomboy64> got it the wroung way round
06:09:37 <applicative> tomboy64: with operators you need the extra parentheses import Plus.Plus.Plus ((++++))
06:10:06 <applicative> hirsch_: what version of cabal -V ?
06:10:28 <hirsch_> applicative: http://travis-ci.org/#!/hirschenberger/RollingDirectory/builds/1913552
06:10:29 <byorgey> hirsch_: that's a known problem with cabal, let me find you a link to the mailing list discussion
06:10:56 <hirsch_> Hmm, that means the Travis installation is broken?
06:11:25 <tomboy64> applicative: good to know, thanks
06:11:32 <byorgey> hirsch_: http://thread.gmane.org/gmane.comp.lang.haskell.cafe/99414
06:11:33 <applicative> ah byorgey knows
06:11:56 <byorgey> hirsch_: hopefully it will be resolved soon, but at the moment it looks like there's not much you can do
06:14:18 <hirsch_>  comment from #travis: <antares_> hirsch_: yes, that is driving us to completely rewrite all haskell recipes and provision GHC and Platform from source
06:14:18 <hirsch_> <hirsch_> argh
06:14:18 <hirsch_> <antares_> it is almost ready. But the lack of hackage maintainers reaction is really annoying.
06:15:32 <dgpratt> ok, I'm probably just tired, but...what's going on here: where Import.T{pack, dropWhile} = def
06:15:59 <dgpratt> context: https://github.com/DanBurton/modular-prelude/blob/master/Example.hs
06:16:01 <applicative> dgpratt it's no different from
06:16:09 <applicative> where (x,y) = (2,3)
06:16:23 <applicative> well, a little different
06:17:38 <quicksilver> danburton-- # toxic record puns
06:17:46 <applicative> > let (x,y) = (2,3) in x + y
06:17:47 <lambdabot>   5
06:18:02 <quicksilver> dgpratt: that binds the local variable 'pack' to the pack field fo def, and 'dropWhile' to the dropWhile field of def
06:18:43 <applicative> the pun is fairly intelligible; I remember the first time I saw this, with the use of Parsec.Token or whatever, it was the use of records that way that freaked me out.
06:18:47 <dgpratt> applicative: yeah, I thought it might be that sort of construction, but...still not fully comprehending
06:19:15 <quicksilver> applicative: intelligible, but toxic.
06:19:16 * dgpratt is processing quicksilver's explanation...
06:19:27 <quicksilver> I don't like shadowing at different types.
06:20:51 <Saizan> srhb: in the past one needed an intermediary class like IsNextedMonad/DeepJoin' here http://okmij.org/ftp/Haskell/deep-monadic-join.hs which made it more hacky looking, but i guess now UndecidableInstances lifts the fundep check that required that encoding
06:21:53 <applicative> quicksilver: is it really that bad, I have been trying to think through the consequences.
06:23:35 <quicksilver> applicative: just cognitive dissonance.
06:23:53 <quicksilver> applicative: I'm not suggesting it makes the world end, but confusing an identifier of type A -> B with one of type B annoys me.
06:23:54 <dgpratt> so...do import statements define a record of imported functions? has this always been the case?
06:24:02 <quicksilver> dgpratt: no.
06:24:04 <tromp_> > 30 * log 6 / log 2
06:24:05 <lambdabot>   77.54887502163469
06:24:16 <dgpratt> quicksilver: to the first question, I assume?
06:24:18 <quicksilver> dgpratt: "T" is a record of functions, presumable.
06:24:31 <quicksilver> exported by the module 'Import'
06:24:32 <Saizan> srhb: the actual shortcomings are the same though :)
06:24:32 <tromp_> > 30 * log 5 / log 2
06:24:33 <lambdabot>   69.65784284662087
06:24:35 <applicative> not the capital on Import
06:24:39 <applicative> note rather
06:24:43 <dgpratt> quicksilver: ah...I think
06:25:04 <quicksilver> applicative: also I think it fuels the misapprehensions about what haskell's record notaiton is / isn't.
06:25:16 <quicksilver> applicative: everything seems clearer if you identify field names as record selectors.
06:25:22 <quicksilver> (not as fields themselves)
06:25:25 <Saizan> quicksilver: that's what i'm saying all the time wrt random variables in probability theory :)
06:25:40 <quicksilver> Saizan: yes, well mathematicians do this kind of abuse of notation *all* the time.
06:28:09 <applicative> quicksilver: so it is this local varying that bugs you.  What Parsec does, where you do -- I cant remember how it goes -- something like  LanguageDef {..} = haskelldef at the top of the file... is this bad too?
06:31:40 <quicksilver> applicative: if you are consistent - if you *never* use them as record selectors, and you only use them for this bulk-rename trick
06:31:45 <quicksilver> then that is understandable
06:31:50 <quicksilver> certainly I can see why it's an attractive shortcut.
06:32:02 <hpaste> nomemory pasted “sort list by the length of sublists” at http://hpaste.org/71818
06:32:05 <quicksilver> it's when you mix and match the use as selectors with the punned use it seems tricky
06:32:32 <applicative> I guess the intended parsec plan is safe that way.
06:32:56 <nomemory> hi guys, is there a performance difference between the two implementations ? in http://hpaste.org/71818
06:33:04 <t7> :t \x -> \y -> x
06:33:05 <lambdabot> forall t t1. t -> t1 -> t
06:33:18 <t7> i proved some law which i forget the na,
06:33:21 <t7> name*
06:33:39 <ocharles> nomemory: find out! I suggest the 'criterion' package for benchmarking
06:33:57 <srhb> nomemory: But the second version would be more idiomatic with sortBy (comparing length)
06:34:06 <srhb> @index comparing
06:34:06 <lambdabot> bzzt
06:34:10 <srhb> @hoogle comparing
06:34:11 <lambdabot> Data.Ord comparing :: Ord a => (b -> a) -> b -> b -> Ordering
06:35:10 <jartur> Hello, I'm sorry to be sp blunt and spontaneous but could anybody please help a beginner to understand where I have memory problems in my little piece of code that I have tried my best to simplify. https://gist.github.com/3150711
06:35:18 <merijn> Hmm, is there a neater way of doing "m a -> Maybe a -> m a" in State, other than "new <- get >>= maybe foo return"?
06:36:16 <merijn> jartur: How big are those files?
06:36:29 <jartur> merijin: Pretty big
06:36:41 <merijn> Lazy IO does't really play well with big files
06:37:06 <ocharles> merijn: that doesn't look bad to me
06:37:13 <jartur> merijin: So what should I try to do first?
06:37:24 <ocharles> merijn: you could move the 'maybe foo' bit to something like 'onNothing'
06:37:39 <ocharles> merijn: giving new <- get `onNothing` foo
06:37:47 <ocharles> or something
06:37:57 <merijn> hmm, that might work
06:38:49 <Qtr> so literate haskell, how do you comment functions to autogenerate docks?
06:38:55 <Qtr> using haddock?
06:40:21 <merijn> jartur: hmm, I'm not even sure that is the problem here. You could try profiling your code and seeing what's taking up all the space?
06:40:50 <jartur> merijn: I will try, but for now profiling info looks like magic to me =)
06:41:09 <merijn> jartur: Did you read the RWH chapter on it? http://book.realworldhaskell.org/read/profiling-and-optimization.html
06:41:27 <merijn> jartur: Also, if you pastebin the profiling output someone here can probably help you interpret it
06:41:47 <jartur> merijn: Yeah, I will again. Maybe I will gain more insight. Thanks.
06:42:32 <statusfailed> If I'm using a module with records containing unexported fields, how can I serialize those records without losing the "hidden" field?
06:49:58 <edsko> any suggestions for a cute way to search an infinite, but ordered, list? (:: Ord a => a -> [a] -> Bool)
06:50:30 <statusfailed> edsko: as opposed to a binary search, right? :)
06:50:44 <edsko> binary search on an infinite list? :)
06:50:50 <statusfailed> right :P
06:50:51 <jartur> edsko: some incremental skipping?
06:50:53 <dunsten> are there any libraries of STM data structures for haskell? i've found one SPJ paper that shows how you could implement a queue. are there libraries for things like dequeues, maps and so on that use TVars?
06:50:55 <edsko> don't care about efficiency, as long as it works :)
06:51:08 <jartur> edsko: linear search?
06:51:13 <edsko> "cute" as in short, not "cute" as in high performance
06:51:17 <statusfailed> oh
06:51:21 <statusfailed> ^ linear
06:51:40 <edsko> linear search is perfectly fine with me, jst don't want the explicit recursion
06:51:41 <merijn> If I have an infinitely looping IO action in a forkIO that needs to exit at some point I may as well just throw an IO exception that kills the thread, right?
06:51:59 <jartur> edsko: dropWhile?
06:52:05 <statusfailed> dammit, i'm too slow today
06:52:12 <edsko> ah
06:52:17 <merijn> dunsten: queues and channels and some other things have already been implemented in Control.Concurrent.STM
06:52:37 <merijn> dunsten: http://hackage.haskell.org/packages/archive/stm/latest/doc/html/Control-Concurrent-STM.html
06:52:59 <merijn> There might be (probably are) more
06:53:07 <hpaste> nand` pasted “Image center of mass calculation” at http://hpaste.org/71824
06:53:29 <edsko> jartur: perfect, ta :)
06:53:35 <dunsten> merijn: that's what I was after, thanks, didn't find it as it's 2.4 and the latest platform is 2.3. assumed the haskell platform would be up to date!
06:53:37 * edsko should have thought of that
06:54:43 <merijn> dunsten: To be fair 2.4 seems to have been uploaded on July 4
06:57:48 <merijn> Actually, I guess that "killThread myThreadId" would be even better for terminating a forkIO infinite loop?
06:58:56 <quicksilver> merijn: only if every point is a safe point
06:59:19 <quicksilver> otherwise it's much better to make the thread itself check for a exit request at each safe point (typically once through the loop)
07:00:40 <merijn> quicksilver: What do you mean "if every point is a safe point"?
07:02:19 * hackagebot chan-split 0.4.0 - Concurrent Chans as read/write pairs. Also provides generic  Chan pair class. (BrandonSimmons)
07:03:01 <merijn> I have a graph of threads and channels and one type of thread (single input, single output) that becomes the identity after some computation, so it forwards its input Chan to the next thread after which it should just stop. The way the code is currently structured makes it really inconvenient to stop the loop at the point where this happens
07:03:28 <applicative> jartur: here's a crude Text variant? https://gist.github.com/3150893
07:04:11 <quicksilver> merijn: "safe" means "not violating the invariants of your program"
07:04:19 <Qtr> what is more idiomatic, pattern guards of if-then-else?
07:04:21 <quicksilver> so, not having read something from one variable and failed to write it in another
07:04:26 <quicksilver> or opening a file without closing it
07:04:28 <quicksilver> or whatever.
07:04:49 <Qtr> why is haskell poor for big-data processing?
07:04:56 <jartur> applicative: Hmm, Stack space overflow: current size 8388608 bytes.
07:05:11 <merijn> quicksilver: Aside from reading/writing chan's it doesn't really have any non-pure behaviour, so once I forward the channel I'm safe
07:05:23 <merijn> Qtr: I prefer guards
07:05:27 <simukis> Is it spossible somehow spoof User-Agent with Network.HTTP?
07:05:45 <Qtr> me to but im not sure why, maybe more inline with haskell in general?
07:06:02 <bitonic> simukis: User-Agent is just an header
07:06:25 <bitonic> Qtr: btw, I don't see the overlap between *pattern* guards and if-then-else
07:06:38 <bitonic> I see the overlap with simple guards
07:06:42 <simukis> bitonic: Oh, just now noticed Network.HTTP.Headers.
07:06:45 <Qtr> fromList xs | length xs == 9 = Just $ TicTacToeBoard xs
07:06:45 <Qtr>             | otherwise      = Nothing
07:06:49 <Qtr> or use if then else?
07:06:54 <applicative> jartur: I suppose Lazy wont help  https://gist.github.com/3150893  It maybe you need a sophisticated form of io
07:07:03 <Qtr> isnt that a pattern guard?
07:07:09 <bitonic> Qtr: that's a simple guard
07:07:26 <bitonic> foo | Just x <- y = "foo"
07:07:32 <bitonic>     | otherwise = "bar"
07:07:34 <jartur> applicative: Probably I do, unfortunately I don't know a lot about that. Maybe there are some pointers where I should look?
07:07:40 <bitonic> Qtr: that's a pattern guard
07:08:04 <applicative> jartur how big are the files, just wondering
07:08:24 <jartur> applicative: just 15MB
07:08:28 <Qtr> oh i see
07:08:43 <jartur> applicative: Actually it also eats up to 500MB of memory before crashing
07:09:14 <applicative> it will eat what it can
07:09:22 <jartur> applicative: I used to have other code there, it was more complicated but somehow didn't throw StackOverflow. I used it to parse java exceptions from a huge huge file.
07:09:46 <Qtr> there is no point in deriving Ord ijust because right? what does it mean tod erive ord for a TicTacToeBoard { board :: [Mark] } where Mark is data = X|O|E ?
07:09:46 <jartur> applicative: And it used about 8GB of my mem and worked for a very long time
07:09:59 <jartur> applicative: Althoug file was only about 400MB
07:10:32 <jartur> applicative: I tried to look at profiling output but it only showed char lists as memory hogs
07:10:45 <srhb> Qtr: If you don't need less than or greater than etc., there's no sense in deriving Ord, no.
07:12:33 <srhb> Qtr: And if it's unclear whether your type really has a real ordering, there's even less reason to derive Ord, since it will actually be misleading and ill defined.
07:13:44 <jartur> applicative: I think maybe it didn't throw StackOverflow because it had never got to some reduction phase only growing all the time
07:14:37 <jartur> applicative: Still, I would like to understand what is wrong here because it is such a simple task and yet I can't make it work. It's something basic but doesn't work. Makes me sad.
07:15:22 <applicative> oh wait the dreaded foldl staring usin the face jartur
07:15:35 <applicative> jartur: try foldl'
07:15:58 <applicative> wait, that probably wont help the seed is a Map
07:16:34 <applicative> jartur: try it though
07:16:49 <jartur> applicative: I think fold here is only working on very short sequences of words. But okay.
07:17:34 <applicative> jartur: I'm just warming up.  :)
07:18:04 <jartur> applicative: Still stack overflow
07:18:40 <applicative> jartur: I  think there is something irrational in the way the big Map is built
07:18:49 <nand`> mathematical assumptions are like win/win scenarios: the moment it comes crashing down on your head, you've found your counterexample
07:19:15 <jartur> applicative: Maybe, but the thing is -- the text is very repetitious, so the map is actually small
07:19:25 <jartur> applicative: It only has about 20 different keys
07:20:41 <Qtr> can you fold and abort? like foldr until true?
07:20:54 <Qtr> i could write such a func...
07:20:55 <srhb> Qtr: Sure.
07:20:58 <Qtr> but is there one?`
07:21:23 <srhb> Qtr: Not one I know, but yes, you could write it. :)
07:21:40 <srhb> Actually you could.. probably do it with foldr.
07:24:19 <srhb> Actually no, I can't think of such a way
07:24:51 <ocharles> http://narf-archive.com/pix/49518cf17ceab781214c47faeea9b8584675e830.jpg :)
07:25:03 <MHD> Can you write all possible programs using only Applicative IO, or is Monad neccesary for some of them?
07:26:28 <ocharles> MHD: Monad is necessary for a lot of stuff
07:26:38 <MHD> okay
07:26:59 <ocharles> monad's give you the choice of what to do based on previous values.
07:27:07 <ocharles> i may have explained that awful, no doubt people here will shout if I have
07:27:10 <ocharles> awfully*
07:27:12 <mcstar> magneto hydro dynamics?
07:31:12 <Qtr> if i have a function f :: a -> b -> c -> d can i then somehow uncurry and flip if i want to use partial application and pass like foldl (f b a)?
07:32:21 <mcstar> f' = \a b c d -> f b a c d
07:32:42 <fmap> :t flip
07:32:43 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
07:33:04 <fmap> flip f should be enough
07:33:50 <fmap> @pl  \a b c d -> f b a c d
07:33:50 <lambdabot> flip f
07:33:54 <BMeph_> Qtr: Yes; why wouldn't you? For that matter, you could also not uncurry and flip it. ;)
07:34:26 <mcstar> fmap: thats illuminating, i thought flip would flip the last 2 arguments
07:34:30 <mcstar> dont know why...
07:34:54 <mcstar> in this functorial context the opposite makes much sense
07:36:17 <BMeph_> mcstar: "opposite" here meaning the first two, not the last? :)
07:36:34 <mcstar> yes
07:36:44 <mcstar> like it does in reality
07:38:10 <BMeph_> mcstar: tbh, it's a lot easier to spot the first two arguments, than the last two. ;)
07:38:54 <fmap> flipping last 2 arguments in arbitrary function seems interesting problem
07:38:55 <mcstar> what does Data's cat have anything to do with flip?
07:39:06 <Qtr> im gonna play around with digital filtering(nothing hardcore so dont need C speed, just basic filtering). what array lib do i use?
07:39:14 <Qtr> i also need difference equations
07:40:49 <mcstar> choices are abundant
07:43:29 <Qtr> > [0..1]
07:43:30 <lambdabot>   [0,1]
07:43:33 <Qtr> > [0..1,0.1]
07:43:34 <lambdabot>   <no location info>: parse error on input `,'
07:43:44 <Qtr> > [0,0.1..1]
07:43:45 <lambdabot>   [0.0,0.1,0.2,0.30000000000000004,0.4000000000000001,0.5000000000000001,0.60...
07:47:41 <hpaste> simukis pasted “Binary downloader” at http://hpaste.org/71831
07:47:45 <simukis> a problem. Resource on internet is binary data. I try to download it with Network.HTTP and write to file with writeFile. However doing it like this goes wrong (probably because data is converted to a string?)
07:47:51 <applicative> jartur: for illustration here is https://gist.github.com/3150893 which works fine on 4mb here
07:48:24 <simukis> Any ideas how I could "fix" this behaviour?
07:48:34 <applicative> jartur: i scrapped the use of IO for 'mainLoop' which though potentially necessary, is a distraction when youre thinking where the problem is
07:49:50 <jartur> applicative: 15633852 Stack space overflow: current size 8388608 bytes.
07:50:18 <McManiaC> haskell bindings for igraph! http://npaste.de/hQ/
07:50:18 <McManiaC> :D
07:50:20 <applicative> hm
07:50:42 <t7> cool
07:54:28 <applicative> jartur: a strict left fold? https://gist.github.com/3150893
07:55:34 <jartur> applicative: Nope, didn't help =)
07:57:04 <applicative> hm, need a bigger file to test.  how big is yours again?
08:00:59 <merijn> simukis: Are you using http-conduit? If not, you probably should
08:01:20 <jartur> applicative: Actully this did it: https://gist.github.com/3151176
08:01:40 <merijn> simukis: In my experience http-conduit is much robuster and nicer to work with than Network.HTTP
08:03:12 <jartur> applicative: It incremented counter in map after all the words were read
08:03:25 <merijn> simukis: Especially since you can then nicely connect it to xml-conduit to convert the fetched page to a usable representation for (for example for webscraping) or one of the file conduits for writing to disk
08:03:29 <jartur> applicative: Keeping all numbers in thunks it seems
08:05:26 <jartur> applicative: Now it works even for 100MB file
08:05:33 <jartur> applicative: Without eating up the mem
08:05:51 <jartur> applicative: I discovered it by randomly adding bangs everywhere
08:05:52 <simukis> merijn: I don't really need to parse whole page, but at least I see `ByteString` in type signatures. Will try it out and report back.
08:06:01 <simukis> merijn: thanks.
08:08:36 <jartur> applicative: Thanks for you effort! But it's sad that it is not really obvious even in this simple example =(
08:08:51 <Kaidelong> I cannot get sdl-image to build on windows
08:09:05 <Kaidelong> even after looking at the blog post supposedly explaining how to
08:09:56 <Kaidelong> haskell foreign bindings on windows are very discouraging in general
08:10:02 <merijn> simukis: As I said, there are file conduits for writing to disk to, so that should help too
08:13:53 <EvanR> ($$) = uncurry (***)
08:14:51 <scooty-puff> :t uncurry (***)
08:14:52 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => (a b c, a b' c') -> a (b, b') (c, c')
08:15:58 <applicative> jartur: are you doing this line by line for a reason?
08:16:03 <otters> can you make a top-level type declaration with TH?
08:17:02 <EvanR> > let ($$) = uncurry (***) in (map (+1), (<2)) $$ ([5,3,1], 90)
08:17:03 <lambdabot>   ([6,4,2],False)
08:17:24 <otters> oh, SigD
08:17:26 <otters> heheh
08:29:15 <merijn> StateT question: If I have two separate pieces of State I use (one much less frequently than the other) do I just put them in a tuple in State or is there a sensible way to nest State so that I don't have to grab the right part of the tuple whenever I access the frequently needed state
08:32:26 <EvanR> merijn: no just use a tuple
08:32:31 <EvanR> gets fst
08:32:34 <EvanR> gets snd
08:32:35 <merijn> aww :(
08:32:43 <pqmodn> can you use lift?
08:32:48 <EvanR> i mean what you want isnt necessary
08:33:58 <merijn> EvanR: Yeah, but the problem I have with that is that everything becomes so cryptic with "gets fst"
08:34:14 <colock> merijn: make it a function
08:34:23 <pqmodn> or use a record type for your state
08:34:47 <merijn> Right now I actually only have the frequently used one in State, the rest is passed along as an argument in my recursive calls. Was just considering whether I wanted to keep it that way
08:35:00 <confusing> merijn: if you stack two StateT's, i'd expect you could make one accessor ("get'" or whatever) which can fetch either of the pieces through type inference :) not sure if that makes things more readable
08:35:03 <pqmodn> i think you can also use lift to nest monads, but that might be less readable
08:35:12 <EvanR> merijn: rename it
08:35:20 <EvanR> getCool = gets fst
08:35:23 <EvanR> getSuck = gets snd
08:35:38 <EvanR> or a record which is the same thing
08:35:52 <merijn> EvanR: Yeah, I think I'll just go with that
08:35:54 <EvanR> S {getCool :: ?, getSuck :: !}
08:36:20 <confusing> merijn: you know, implicit params aren't half bad either
08:36:51 <confusing> (for the use case "i don't want to schlep around all those arguments to all those functions")
08:38:00 <otters> so I've made a new name a <- newName "a"
08:38:10 <otters> and I want to put it into a type signature quotation
08:38:16 <otters> [t|Int -> Int -> a|] says that "a" is not in scope
08:38:20 <otters> what do I need to do?
08:39:21 <otters> To be fair I don't know if interpolation like that is possible
08:40:19 <c_wraith> otters: you're not telling it a is a splice
08:40:31 <otters> okay how do I do that
08:40:43 <Qtr> whats better for updateBoard to return ? it is for tictactoe where it can succeed if the spot is empty but fail otherwise, Maybe TictacToeBoard or (Bool, TicTacToeBoard)?
08:40:58 <Qtr> maybe is clearer perhaps
08:41:05 <confusing> otters: so you're using TH to create a new type? a new data or something?
08:41:06 <otters> Qtr: Either String TicTacToeBoard
08:41:14 <otters> confusing: I'm just trying to learn TH so I'm creating a new class
08:41:24 <otters> class Foo a where doStuff :: Int -> Int -> a
08:41:25 <hsyl20> otters: something like [t|Int -> Int -> $(return $ VarT a)|]
08:41:30 <otters> oh, gross
08:41:38 <c_wraith> well
08:41:42 <srhb> Qtr: Maybe seems to be sufficient in that case
08:41:43 <c_wraith> $(varT a)
08:41:55 <c_wraith> as varT = return . VarT
08:42:00 <srhb> Qtr: Unless you specifically want to extract the error and put it in Left.
08:42:09 <otters> oh neat
08:42:12 <hsyl20> c_wraith: good to know :)
08:42:15 <otters> oh but I'm passing that to sigD
08:42:18 <confusing> otters: so the class is fixed and you use TH to create the instances? sounds reasonable then
08:42:24 <otters> which wants a [Dec], not a Q [Dec]
08:42:26 <otters> confusing: yeah
08:43:06 <otters> oh I'm fundamentally misunderstanding how quotation works here
08:48:30 <Qtr> B.updateBoard2 1 mark board >>= \b -> case b of (Just brd) -> return brd
08:48:48 <Qtr> isnt that correct if updateBoard2 returns Maybe Board ?
08:49:40 <merijn> Qtr: No
08:49:53 <mauke> look at the type of >>=
08:50:02 <merijn> Qtr: If updateBoard2 returns Maybe Board then the b in your lambda will have type Board
08:50:20 <merijn> :t (>>=)
08:50:21 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
08:50:35 <merijn> Note how the input of the second argument is a, not m a
08:50:50 <Qtr> @type (>>)
08:50:51 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
08:51:54 <Qtr> but whats wrong with the syntax?
08:52:12 <Qtr> so if b is Nothing then what happens?
08:52:19 <nand`> > Nothing >>= undefined
08:52:21 <lambdabot>   Nothing
08:52:32 <merijn> Qtr: b can't be Nothing
08:52:47 <Qtr> > Just 5 >>= undefined
08:52:48 <lambdabot>   *Exception: Prelude.undefined
08:53:01 <Qtr> > Just 5 >>= print 5
08:53:02 <lambdabot>   Couldn't match expected type `t -> Data.Maybe.Maybe b'
08:53:03 <lambdabot>         against infe...
08:53:06 <merijn> > Just 5 >>= return . (+1)
08:53:08 <lambdabot>   Just 6
08:53:14 <merijn> > Nothing >>= return . (+1)
08:53:16 <lambdabot>   Nothing
08:53:24 <srhb> Qtr: Qtr The right hand side must be a value in the same Monad as the left hand side.
08:53:39 <merijn> Qtr: The entire reason to use (>>=) is that it stops you from having to check whether b is Nothing
08:53:43 <Qtr> if i want to do diff things depending on if it is Just or Nothing I use (>>) ?
08:53:46 <confusing> qtr: so as merijn's example shows, the (+1) is not being done if you're putting Nothing into it
08:53:49 <nand`> Qtr: no
08:53:51 <srhb> Qtr: no, then you just use case
08:53:52 <nand`> Qtr: you just apply the function
08:53:54 <merijn> Qtr: No, then you use maybe
08:53:57 <merijn> :t maybe
08:53:58 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
08:53:59 <srhb> or maybe.
08:54:01 <merijn> :t fromMaybe
08:54:02 <lambdabot> forall a. a -> Maybe a -> a
08:54:57 <confusing> qtr: the basic thing to do is to use "case ... of Just ... -> ... ; Nothing -> ...". there are some shortcuts available, like the function "maybe" and the function "fromMaybe"
08:55:24 <srhb> Here it would be.. case B.updateBoard2 1 mark board of ...
09:00:52 <mtg> hello #haskellers
09:01:03 <srhb> mtg: Hi
09:01:20 <mtg> i am trying to use http-conduit to pull a webpage and then scrape it using tagsoup
09:01:43 <mtg> i'm using httpLbs to get a (lazy) ByteString
09:02:03 <mtg> which i then pass into tagsoup's parseTags
09:02:17 <Qtr> if module X imports module Board as qualified B why cant if i load X into ghci i do B.f but i can do test = do {print $ B.f B.makeBoard }
09:02:30 <mtg> but, the tags returned are truncated @ (I guess) 8192 bytes
09:02:51 <mtg> my question is, how do I get tagsoup to parse the entire response?
09:03:29 <mtg> or do I need to use the base http in http-conduit to get a Source and then write a conduit thing for Tagsoup?
09:03:59 <merijn> mtg: Use html-conduit
09:04:16 <merijn> mtg: It's surprisingly easy to use and slots right into http-conduit
09:04:59 <mtg> wow, i never heard of that one
09:05:02 <mtg> that looks good
09:05:44 <merijn> I found it fairly easy to use too
09:06:02 <mtg> will it handle potentially dubious HTML?
09:06:07 <arbeinka> hey
09:06:11 <mtg> ie not necessarily well formed XML
09:06:25 <mtg> i'm gonna have a go wth it now
09:07:07 <merijn> mtg: I believe its supposed to (unlike xml-conduit), the description says " It automatically balances mismatched tags", so it is at least somewhat robust
09:07:36 <mtg> cool
09:07:39 <mtg> thank you!
09:08:36 <merijn> The end result is that you can get a cursor to manipulate by just running "fromDocument . parseLBS <$> simpleHttp url", less of a headache than tagsoup was for me :p
09:12:24 <scooty-puff> what is the difference between class MapKey k where type Map k and class Map m where type Key m
09:12:44 <scooty-puff> well, i guess other than one is k -> m, and the other is m -> k
09:13:26 <scooty-puff> or even better: is one preferred over the other?
09:14:08 <mauke> MapKey k feels weird
09:15:01 <arbeinka> http://i1243.photobucket.com/albums/gg551/Asaf_Kasher/items/DT11688.jpg
09:15:05 <arbeinka> This just arrived today.
09:15:11 <arbeinka> New addition to our collection.
09:15:20 <mauke> arbeinka: ?
09:15:39 <singpolyma> Is there a good source of documentation / descriptions of GHC extensions?  (I'm currently looking for some description of what RecordWildCards is for)
09:16:07 <arbeinka> mauke its the Ushbati of Akhenaten.
09:16:13 <scooty-puff> very timely - reddit.com/r/haskell currently has a lot of posts making use of RecordWildCards
09:16:17 <mtg> merijn: this works - body $$+- sinkDoc >>= return
09:16:25 <mauke> arbeinka: this is #haskell
09:16:28 <arbeinka> this is from new kingdom, amarna period
09:16:36 <mauke> singpolyma: http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#record-wildcards
09:16:37 <mtg> but the document is still truncated?
09:16:41 <arbeinka> around 1353-1336 B.C
09:17:00 <mauke> arbeinka: what does this have to do with Haskell?
09:17:12 <geekosaur> singpolyma, http://www.haskell.org/ghc/docs/latest/html/users_guide/ghc-language-features.html is the official documentation for extensions; some of them are better described in the ghc wiki but I don't think there's a good cross reference available
09:18:11 <confusing> singpolyma: the user guide is generally very good. http://www.haskell.org/ghc/docs/latest/html/libraries/Cabal/Language-Haskell-Extension.html has a list of all the extensions and the corresponding chapters in the guide
09:18:29 <singpolyma> cool, thanks all :)
09:18:32 <confusing> (ideally that'd be hyperlinked, but it's better than nothing ...)
09:21:02 * geekosaur ispoking at the ghc wiki but not finding anything about record wild cards in all the other record extension verbiage
09:24:39 <applicative> ah singpolyma vanished.
09:25:17 <merijn> hmm, do I normally want foldl or foldr?
09:25:35 <applicative> foldr or foldl' never foldl is the crude wisdom
09:25:48 <merijn> Yeah, I know
09:26:01 <merijn> But that still leaves foldl' or foldr as question
09:26:12 <mauke> do you want it to work on infinite lists?
09:26:19 <applicative> foldl' when you are strictly accumulating something sensible like an Int
09:26:33 <applicative> and of course when it's finite....
09:26:35 <nand`> foldl' for accumulation, foldr for recursion
09:26:43 <applicative> like nand` says.
09:26:50 <merijn> I basically want to do map + a count
09:26:57 <confusing> honestly, the ghc user guide is excellent, but the one thing i'd want is that they mention the actual {-# LANGUAGE #-} line you need for the features under discussion
09:26:59 <applicative> you just need to be sure youre really accumulating...
09:27:16 <merijn> I have a function that will update some list entries but not other and keep track of how many end up being updated
09:27:22 <nand`> the best way to figure out whether you want foldl or foldr is to look at the source code of foldl and foldr and see which one more closely matches what you are trying to replace it by
09:27:41 <applicative> confusing: what do you mean, do they say -XExtension?
09:27:48 <applicative> or just Extension
09:28:05 <applicative> confusing: you can also compile with -XExtension or put them in your cabal file.
09:28:06 <geekosaur> applicative, the documentation for extensions often but not always says what the extension name is.
09:28:33 * applicative demands -fglasgow-exts
09:28:41 <geekosaur> it'd also be nice if they crosslinked back to the options section (which I think also usually links forward to the extensions --- but not always)
09:29:58 <applicative> nand`: well, then you might as well write it explicitly...
09:31:25 <merijn> nand`, mauke: Looks like I really just wanted Data.List.mapAccum*
09:31:34 <confusing> applicative: erm, i've now looked at a few chapters of the ghc user guide, and they dutifully always say "the -XSomething flag enables the stuff discussed in this section". i don't know what alternate universe i was misremembering there :-/
09:31:36 <nand`> :)
09:32:19 <nand`> :t mapM
09:32:20 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
09:32:24 <nand`> this should do it too, with the state monad
09:32:27 <applicative> confusing: yeah you use -XFoo for the command line, or :set -XFoo inside ghci; but just Foo for a language pragma
09:32:30 <geekosaur> I recall them being missing too.  maybe newer user guides have fixed most of it
09:32:38 <ski> augur : "CHC" ?
09:32:39 <ski> augur : yes, `let x0 = e0 in e1' is a kind of cut
09:32:58 <confusing> geekosaur: we seem to be remembering the same thing :)
09:33:14 <ski> augur : re "(x : P |- x : P   ===RW   x : P |- WK : Q , x : P)   ===\x   |- (\x.WK : P -> Q) , x : P", this is juse a different notion of scope
09:34:17 <applicative> Is everyone gone wild with wacky record extensions  today?
09:34:59 <confusing> applicative: sure. didn't you hear? the WHO declared today to be International Wacky Record Extensions Day
09:36:03 <ski> augur : consider
09:36:07 <ski>   augur :   foo :: {a -o {},() -o a}
09:36:08 <ski>   augur :   foo = {\a. {},\(). a}
09:38:07 <Skola> what's the right way to read and concat a bunch of files?
09:38:25 <applicative> Its clear that augustss is behind this. See the local use of 'RecordWildCards' in http://augustss.blogspot.com/2009/06/more-llvm-recently-someone-asked-me-on.html
09:38:48 <merijn> @pl \(a,b) -> put a >> return b
09:38:48 <lambdabot> uncurry ((. return) . (>>) . put)
09:38:53 <merijn> hmmm
09:38:58 <merijn> Not really helpful :p
09:39:46 <ski> augur : hm, i'm not sure what the `[_]' thing you're talking about is ..
09:40:10 <merijn> @pl \a b -> put a >> return b
09:40:11 <lambdabot> (. return) . (>>) . put
09:40:29 <nand`> :t (>>) <$> put <*> return
09:40:30 <lambdabot> forall (m :: * -> *) b. (MonadState b m) => b -> m b
09:40:41 <nand`> oh
09:40:48 <nand`> that's the joined version
09:40:50 <nand`> nvm
09:43:11 <ski> augur : elaborate on that "string diagrams" thing you did ?
09:43:48 <ski> augur : "obviously this is undesirable because x is unbound now" -- i would say `x' is bound
09:44:06 <Qtr> hmm i see now why !! is bad, but i omnly use it when i can GUARANTEE error cant happen
09:45:13 <confusing> qtr: yes right. the idea is that anytime you use !!, you need to think twice that your index is safe
09:45:23 <confusing> (and don't over-use it)
09:48:50 <Qtr> hmm kind of s**ks you cant add print statements in haskell code but ig uess lesson is dont use !!
09:49:02 * applicative_ avoids !! for the less exalted reason that he's always off by one anyway
09:49:29 <applicative_> Qtr you can add print statements for testing with Debug.Trace.trace
09:49:38 <otters> so mkName creates an *existing* type/variable/whatever name from a string?
09:49:40 <applicative_> @quote chromatic
09:49:40 <lambdabot> chromatic says: My productivity increased when Autrijus told me about Haskell's trace function. He called it a refreshing desert in the oasis of referential transparency.
09:49:51 <d-old> Qtr: you can add print statements
09:49:55 <d-old> oh
09:51:29 <ski> preflex: xseen augustss
09:51:29 <preflex>  augustss was last seen on freenode/#haskell 254 days, 16 hours, 19 minutes and 22 seconds ago, saying: > div (-1) 2
09:52:00 <applicative_> augustss please come explain the wacky record extensions to us
09:52:23 <confusing> applicative_: what extension is so wacky?
09:52:24 <otters> god I wish GHC wouldn't keep freaking out because of the "impossible" happening
09:52:34 <nand`> what are my chances of grasping BONUS in here, mind?
09:52:43 <ski> applicative_ : hm, which record extensions ?
09:52:47 <nand`> otters: “My brain just exploded”
09:52:51 <ski> @ghc
09:52:52 <lambdabot> ghc says: No parameters for class
09:52:53 <otters> nand`: it happens a lot!
09:52:56 <otters> I think it's TH's fault
09:53:00 <Philippa> heh
09:53:00 <otters> it just makes stuff real hard to debug
09:53:04 <ski> preflex: xseen BONUS
09:53:04 <preflex>  BONUS was last seen on freenode/#haskell 1 year, 81 days, 21 hours, 25 minutes and 6 seconds ago, saying: yeah i think that's better as well
09:53:05 <confusing> otters: i think you should report those as compiler bugs :-(
09:53:07 <Philippa> *nod*
09:53:10 <otters> confusing: I guess ;_;
09:53:27 <applicative_> confusing just kidding, he clearly uses them in the sorts of ways people are talking about it, since he has intervened a couple of times saying 'you morons what did you think RecordWildCards' was for...
09:53:30 <Philippa> yeah, if only in terms of "why is the message not nicer?"
09:53:32 <nand`> sometimes you don't want to file a compiler bug because the generating code is so horrible that it makes you feel ashamed
09:53:40 <otters> yeah
09:53:46 <otters> or because I don't want to do it wrong
09:53:50 <applicative_> but i figure he has advanced knowledge of the ins and outs, confusing
09:53:55 <matthiasgorgens> nand`, use QuickCheck's reduce to make the code smaller. :o)
09:54:00 <hpaste> 321 pasted “123” at http://hpaste.org/71833
09:54:08 <ski> applicative_ : what's so confusing about that ?
09:54:27 <applicative_> nand`: maybe that's the real reason people write simplified minimal cases ...
09:54:37 <nand`> applicative_: exactly :)
09:54:46 <nand`> matthiasgorgens: I wish..
09:55:00 <otters> oh come oooonnn
09:55:22 <nand`> or you can obfuscate it so hard that only the poor sod in charge of fixing your bug has to/can decipher it, keeping damage somewhat in check
09:55:49 <nand`> because while horrible code is bad, obfuscated horrible code is elegant
09:56:15 <matthiasgorgens> nand`: not a good strategy, if you want your bug fixed.
09:56:35 <nand`> matthiasgorgens: alas
09:58:08 <otters> ugh it died AGAIN
09:59:19 <BMeph_> Simplifying your bug-showing code helps devs find it; it's done, though, more for coder vanity than dev sanity. :/
10:03:38 <monochrom> the scientific method. your experiment should admit at most one explanation, not many competing possible explanations.
10:04:13 <monochrom> how to achieve that? one way is to have a simple experiment, so simple that all other explanations are clearly impossible
10:05:15 <otters> YESS
10:05:16 <otters> I did it
10:05:28 <otters> I needed to add a ForallT, and when I realized that I realized that I didn't need a polymorphic function at all
10:05:43 <monochrom> if your code is just "main = putChar 'x'", people will not say "maybe the bug is with getLine". you aren't even getting remotely close to getLine
10:06:44 <monochrom> but if your code is not minimal, if it calls putChar and getLine and unsafePerformIO and... then you have an uphill battle first proving that the bug is not with getLine, unsafePerformIO...
10:07:02 <otters> right, that's why I simplified it
10:07:09 <otters> which allowed me to discover the problem myself
10:07:30 <monochrom> controlled experiment
10:07:44 <HairyDude> is Read incompatible with GADTs?
10:08:25 <monochrom> it is a pity that most programmers do not know or embrace the scientific method
10:08:41 <monochrom> (yes, some of them know it and reject it)
10:08:59 <ski> monochrom : yes, Jaynes makes this point in his "Probability Theory: The Logic of Science"
10:09:03 <otters> awwww
10:09:08 <otters> can you put a class constraint in SigD?
10:09:44 <geekosaur> HairyDude, Read /per se/ is not incompatible but automatic deriving largely is
10:09:51 <jfischoff> ski: great book
10:10:14 <ski> you need to pull down, in the minds of skeptical third parties, the plausibility of other causes for the observed results below that of your hypothesis
10:10:34 <ski> jfischoff : yeah, i should (re)borrow it and try to read it some more :)
10:11:05 <Saizan> $(lift . show =<< [d| x :: Show a => a -> String; x = show |]) should print the TH AST for that
10:11:21 <HairyDude> geekosaur: right. It seems the way GHC derives it is by building a list of alternatives for "choose", but that list's elements have different types.
10:12:39 <jfischoff> ski: I made a facebook page for him awhile ago :)
10:12:48 <geekosaur> there used to be some support for automatic deriving but it was shown to be unsound (i.e. generated code that could expose things not intended to be exposed)
10:13:20 <HairyDude> I see
10:13:24 <otters> why is [d| foo $(LitP (StringL "test")) = 1 |] a parse error?
10:13:48 <otters> can you not have splices in a declaration quotation?
10:14:08 <HairyDude> should there be a space after the [| ?
10:14:23 <otters> same result
10:14:25 <otters> I don't think it matters
10:14:38 <otters> btw, the parse error is in $(LitP (StringL "test"))
10:14:43 <quuuux> hi, http://pastebin.com/fp93at7R cabal configure is dropping empty files with (consistent) garbage names in the working directory. This is using the distro packages from ubuntu 12.04, so GHC 7.4.1 and Cabal 1.14
10:14:44 <mauke> The paste fp93at7R has been copied to http://hpaste.org/71834
10:14:45 <otters> so I guess you can't have splices in d-quotations
10:14:47 <otters> which is kind of distressing
10:14:50 <Saizan> otters: i think the problem is that you're trying to splice in a pattern
10:14:57 <Saizan> rather than d-quotations
10:15:04 <otters> what's wrong with splicing in a pattern
10:15:14 <Saizan> that it's not supported :)
10:15:17 <otters> oh
10:15:19 <otters> :|
10:15:27 <otters> so do I have to write the whole function in AST format?
10:15:32 <ski> HairyDude : do you have a particular GADT you want `Read' for ?
10:15:54 <HairyDude> ski: it's basically an enumeration with phantom types
10:15:58 <Saizan> you have to understand that TemplateHaskell's implementation has not received all the love it needed
10:16:04 <Saizan> yet, at least
10:17:09 <otters> well, until worst comes to worst, I can just look at the AST using runQ
10:17:53 <ski> HairyDude : paste it ?
10:18:05 <HairyDude> trying to distil it
10:19:42 <otters> so can you put class constraints in SigD?
10:19:58 <quuuux> oh, never mind, nothing to do with cabal. Had a junk binary purporting to be cpphs in my path that was causing mischief
10:20:15 <Saizan> otters: you put them in the type, it's the second field of ForallT iiuc
10:20:26 <otters> oh okay
10:20:29 <otters> oh right
10:21:56 <hpaste> HairyDude pasted “deriving Read fails for GADTs” at http://hpaste.org/71835
10:24:04 <ski> HairyDude : and all your constructors are non-functions ?
10:24:10 <HairyDude> ski: yes
10:24:21 <HairyDude> ski: all nullary constructors
10:25:56 <HairyDude> http://hackage.haskell.org/trac/ghc/ticket/4528
10:27:35 * applicative_ exercises a rare downvote on the obnoxiously entitled http://stackoverflow.com/questions/11583028/boobs-operator-in-c-c-code-is-it-possible
10:28:05 <c_wraith> I merely have refused to read that one
10:28:29 <applicative_> oh wait maybe I can vote to close it hmm
10:29:20 <applicative_> no, new title
10:29:47 <applicative_> c_wraith I rendered it 'boring'
10:30:11 <c_wraith> oh, a new title? then it might be reasonable.
10:30:26 <c_wraith> The title suggested, beyond the stupidity, a reasonable question.
10:32:04 <applicative_> yes  but his purpose is a mere joke I guess.  I added  an 'inappropriate in our community' flag.  I don't know if my feeble credential permits something more.
10:32:59 <hpaste> HairyDude annotated “deriving Read fails for GADTs” with “deriving Read fails for GADTs (annotation)” at http://hpaste.org/71835#a71837
10:34:13 <HairyDude> hm, I guess it doesn't particularly make sense to Read such a value.
10:34:34 <HairyDude> maybe if it was wrapped in an existential, but not like this.
10:36:23 <quuuux> HairyDude: I haven't been following the chatter, but defining instance Read (Test Integer) and instance Read (Test Bool) should work? If the deriving mechanism isn't clever enough to do that, that's another matter
10:36:34 <HairyDude> mmm
10:38:45 <HairyDude> well, it was an interesting experiment, but I don't think I want a GADT here after all.
10:38:55 <applicative_> It permits in this sort of case
10:39:47 <applicative_> whoops http://hpaste.org/71838
10:40:27 <applicative_> but for if I make the cases A:: Int -> A Int; B :: a -> A a  I don't see how to do it.
10:43:15 <cads> has anyone played with physical units and dimensional analysis in haskell?
10:43:44 <nand`> I've played with the idea of using types for physical units before
10:43:58 <cads> this seems to be relevant
10:43:59 <nand`> (and sum types to represent alternative but equivalent formulations of the same unit)
10:44:00 <cads> http://www.haskell.org/haskellwiki/Physical_units
10:44:04 <nand`> alas only in my mind
10:44:12 <cads> looking into the implementation
10:44:14 <cads> (s)
10:44:59 <geekosaur> @hackage dimensional
10:45:00 <lambdabot> http://hackage.haskell.org/package/dimensional
10:46:46 <b__> how do I ensure (on Mac OSX) that cabal installs binaries into ~/.cabal/bin ?
10:47:07 <cads> I wonder if dimensional lets me say something like  speed_1 :: L / T ;   speed_1 = 10 mph   ;   distance :: L ; distance = 100 mi;  trip_time :: T ;  trip_time = distance / speed_1
10:47:29 <cads> and also what would the type of such a  (/) operation be :)
10:48:46 <cads> and also how would the / and * 'dimensional type constructors' work :  for example,   (a / b) * (b / d) would have to be isomorphic to a / d
10:49:01 <applicative_> oh excellent some C++ types closed the obnoxious question
10:49:18 <geekosaur> b__, you can set the bin path in ~/.cabal/config (which is what redirects everything to ~/Library/Haskell by default on OS X)
10:49:56 <geekosaur> the one that gets created on first use is pretty easy to see what needs to be changed
10:50:39 <b__> ah thank you!
10:59:38 <whittle> I’m trying to understand the construction in which a `data` declaration is followed by a `where` clause. Is there a name for it so that I can look it up?
10:59:45 <shachaf> GADT
10:59:55 <shachaf> @google generalized algebraic data type
10:59:56 <lambdabot> http://en.wikipedia.org/wiki/Generalized_algebraic_data_type
10:59:56 <lambdabot> Title: Generalized algebraic data type - Wikipedia, the free encyclopedia
11:00:58 <whittle> shachaf: Thanks! I had thought GADTs were something completely different, so that actually clears up two things for me.
11:01:39 <ppilate_> Hi
11:01:52 <shachaf> whittle: An easy way to find out would be to type a "data ... where ..." declaration into a file and compile it without extensions. :-)
11:02:22 <nand`> shachaf: I think that would just give a parse error
11:02:36 * hackagebot tamarin-prover-utils 0.8.0.0 - Utility library for the tamarin prover. (SimonMeier)
11:02:38 * hackagebot tamarin-prover-term 0.8.0.0 - Term manipulation library for the tamarin prover. (SimonMeier)
11:02:40 * hackagebot tamarin-prover 0.8.0.0 - The Tamarin prover for security protocol analysis. (SimonMeier)
11:03:04 <shachaf>     Illegal generalised algebraic data declaration for `Foo'
11:03:04 <shachaf>       (Use -XGADTs to allow GADTs)
11:04:49 <quuuux> learning by error message isn't a bad idea, but it doesn't work in every case. Template Haskell and type families leap to mind as extensions that don't usually give helpful reminders that they're turned off
11:06:12 <quuuux> also, strictly speaking, data declarations using 'where' come separately from full-blown GADTs as -XGADTSyntax, but there's no added power from doing that
11:08:02 <HairyDude> I think the compiler can warn you only if the extension doesn't steal the syntax you're trying to use.
11:08:22 <HairyDude> e.g. $(foo) is valid normal Haskell, it just interprets the $ as ($)
11:08:32 <applicative_> I was going to say, GADTs are independent of where syntax or 'constructors as functions' syntax or whatever
11:09:02 <HairyDude> whereas "data Foo where..." isn't valid without -XGADTs
11:09:56 <nand`> shachaf: oh, I noticed my mistake
11:10:26 * applicative_ dimly remembers a ghc that accepted gadt syntax on condition that it  was a 'haskell98' type. the warning was 'hey you need -XGADTs this isnt a haskell98 type' but maybe this is wrong
11:13:25 <whittle> @type $(True)
11:13:27 <lambdabot> parse error on input `$'
11:13:48 <applicative_> damn this stupid question was closed, but the author can still edit the title; as soon as he did the +votes began to pile up again.  I removed the haskell tag, maybe it will go away
11:21:16 <otters> I want to make a [Name
11:21:18 <otters> ]
11:21:20 <otters> [Name], there we go
11:22:21 <joeyh>  I'm struggling with when it makes sense to use safe and unsafe in FFI code
11:22:48 <otters> that is, I want to declare a variable of type [Name] and also define it in TH
11:22:53 <otters> but it is non-obvious how to do that
11:23:07 <joeyh> the docs say safe is only needed if the C code calls back into haskell.. is that the whole story though?
11:23:31 <joeyh> I had a FFI function marked unsafe, and it was locking up threads while running.. marking safe fixed that
11:24:55 <geekosaur> which docs?  the original ffi spec said that, later ones incorporated the additional use of safe/unsafe with threads
11:25:12 <geekosaur> (concurrent haskell didnt exist when the h98 FFI addendum was written)
11:25:59 <joeyh> the wiki, and real world haskell
11:26:25 <geekosaur> hm.  rwh should know better than that
11:26:27 <Clint> in my experience, marking things safe just causes segfaults
11:26:27 <joeyh> ok, I should probably re-read the actual ffi spec, it's been a while, and I've started writing lots of ffi code since I last read it :)
11:26:33 <joeyh> well, rwh is old..
11:26:45 <joeyh> Clint: oh joy. Well, thread lock vs segfault, hmm
11:26:46 <otters> urgh, why can't reify be run in the IO monad
11:26:50 <otters> I want to see what it returns
11:27:01 <geekosaur> http://community.haskell.org/~simonmar/papers/conc-ffi.pdf
11:27:16 <geekosaur> yes, but it came after the concurrency changes to the ffi
11:28:27 <joeyh> ah, thanks, reading
11:28:37 <byorgey> otters: use runQ to run a Q computation in IO
11:28:38 <quuuux> otters: qRunIO . print <=< reify?
11:29:39 <byorgey> oh, wait, sorry otters, I know what you mean now
11:29:45 <otters> yeah
11:30:45 <otters> quuuux: I'm not sure how I'm supposed to use that, I can't get it to typecheck
11:30:47 <byorgey> I now remember running into this myself.  I had to go to some contortions to use reify, convert the results to a String, and then embed it as a constant in the generated code, then load that into ghci
11:31:01 <byorgey> super annoying though
11:31:05 <otters> super!
11:31:24 <byorgey> but at least you can see what reify is giving you
11:32:36 <quuuux> otters: oh, oops. Should just be runIO, not qRunIO. It's just reifying the argument, then writing it to stdout
11:33:21 <joeyh> geekosaur: ok, so safe ffi can only block the calling thread; unsafe can block the whole program.
11:33:45 <joeyh> and my ffi call is a kqueue thing, it's entirely intended to block
11:33:49 <byorgey> quuuux: the problem is that the implementation of the 'reify' method for the IO instance of Quasi basically consists of a call to error
11:34:35 <joeyh> interesting that it only blocks the whole program when using the threaded runtime. Aha, I'll bet the non-threaded RTS wakes up other threads via its alarm
11:42:38 * hackagebot tamarin-prover-utils 0.8.0.1 - Utility library for the tamarin prover. (SimonMeier)
12:01:21 <realitygrill> hey, if I do 'import IO' why do i get 'Could not find module `IO'
12:01:21 <realitygrill>     It is a member of the hidden package `haskell98-2.0.0.1'.'?
12:05:15 <latro`a> realitygrill, pretty sure you're thinking of System.IO?
12:05:40 <latro`a> that has the main extra IO utilities that the Prelude doesn't export
12:07:54 <applicative_> realitygrill: IO is split up into a few modules now, most of it is System.IO
12:08:46 <Qtr> wee tic tac toe is getting there
12:09:08 <Qtr> anyone know a guy called Duracz from KTH?
12:09:30 * mekeor doesn't even know KTH… oO
12:09:34 <astory> is there a way to get hunit to not eat stdout?  I'm having a hard time debugging...
12:19:20 <Qtr> hmm, my programs beats me :)
12:20:07 <frerich_> Qtr: Soon it will tell you that the only winning move is not to play.
12:21:35 <Qtr> hmm, i can define my own show right? like oif ghc cant derive it? instance Show perhaps?
12:23:10 <frerich_> Qtr: Yes, you can
12:24:06 <frerich_> Qtr: However, 'Show' (and 'Read') tend to be used mostly for 'debugging' representations'. If you want to render something, a 'render :: MyType -> String' function would be nicer.
12:28:40 <Qtr> anyone know where i can host a webapp quickly?
12:28:49 <Qtr> fre of charge
12:29:05 <shachaf> localhost
12:29:12 <Qtr> ¨for others to see...
12:30:02 <jfischoff> heroku
12:41:19 <hpaste> qrt pasted “happstack attributes” at http://hpaste.org/71840
12:42:42 <Qtr> anyone good with happstack and blaze ^^ ? need to set the border of my table but cant get how
12:43:27 <int80_h> hmm
12:43:35 <mroman> Qtr: Using ! style?
12:43:43 <int80_h> I just posted to hpaste but nothing happened here
12:43:58 <int80_h> http://hpaste.org/71841
12:44:53 <parcs`> Qtr: table ! border (toValue "1") $ do ....
12:44:55 <mroman> table ! style "border: your stuff"
12:45:08 <jfischoff> int80_h: depends on the use case. What are you trying to do?
12:45:32 <Cale> int80_h: Usually just to constrain the uses
12:45:52 <augur> ski: hey
12:45:59 <Cale> int80_h: So constrain a to be a member of your class in the functions and other definitions where that fact is actually needed
12:46:07 <matthiasgorgens> monochrom: there's nothing like `the' scientific method.  I think they invented that term for US science fairs.
12:46:23 <matthiasgorgens> oops, that's way too late.
12:46:43 <augur> ski: i'd have to draw some pictures for the string diagram stuff. gimme a bit
12:47:41 <Cale> matthiasgorgens: hm? Do you mean in the sense of a strict sequence of steps? In that case I might agree with you.
12:47:41 * hackagebot cyclotomic 0.1 - A subfield of the complex numbers for exact calculation (ScottWalck)
12:47:57 <jfischoff> ^ woah that's possible?
12:48:17 <Cale> Why not?
12:49:13 <Cale> You can do exact computations on all algebraic numbers as well.
12:49:22 <jfischoff> I was hoping it was.
12:49:25 <Cale> Though it's probably trickier
12:49:51 <jfischoff> I read somewhere that there was not a finite analog to complex numbers
12:50:17 <jfischoff> but even if that is true, doesn't mean exact computation is possible
12:50:25 <jfischoff> good to know
12:50:34 <Cale> There's also the computable reals
12:50:45 <jfischoff> yeah
12:50:48 <Cale> (and the computable complex numbers)
12:51:08 <Cale> which contain all algebraics, but also a good handful of transcendentals
12:51:51 <monochrom> I either read the term "scientific method" from good books on science or invented the term myself to summarize what I read there.
12:51:58 <jfischoff> I don't know how all this stuff fits togetther, but I would love to be able to doing a dft that uses exact complex numbers.
12:52:06 <jfischoff> *do
12:53:17 <jfischoff> you just need a ring to do a dft, but I think need something like the complex numbers to get an "understable" frequency.
12:53:48 <monochrom> independently reproducible experiments. experiments so simple that the observation can only have one explanation (and so strong confirmation of the explanation).
12:54:23 <Qtr> lets say i am running a happstack webapp from the cmd prompt but i cant kill it with Ctrl-C. Can i somehow thread my program so i can check for input and kill the app via command line?
12:54:41 <stepcut> Qtr: Are you on windows?
12:55:53 <stepcut> Qtr: you can do, do tid <- forkIO $ simpleHTTP nullConf routers ; waitForTermination ; killThread tid
12:56:15 <stepcut> Qtr: on linux, waitForTermination looks for ^C, but on windows it looks for e<return>
12:58:20 <monochrom> a non-trivial example of my scientific method: http://article.gmane.org/gmane.comp.lang.haskell.cafe/83692/
13:07:02 <tvynr> Hi all.  I'm trying to debug an infinite loop.  I've followed the steps at http://www.haskell.org/ghc/docs/7.2.2/html/users_guide/ghci-debugger.html and have a history, but it only goes back 50 levels.  The problem is that the infinite loop is continually invoking a complex routine which easily fills up the 50 history lines.  Does anyone have any suggestions?
13:07:20 <monochrom> and a simple example of my scientific method, so simple you can see for yourself easily, and the code so short that you have nowhere else to point fingers: http://article.gmane.org/gmane.comp.lang.haskell.cafe/88120/
13:07:57 <applicative_> tvynr: is the source too big to paste?
13:09:02 <tvynr> The routine that's hiding my loop stack frames runs through a few different modules.  The loop itself is pretty much just somewhere in the project source base.  Without a deeper history, I'm having trouble narrowing it down any further than that.
13:09:09 <applicative_> wow the RecordWildCards business has brought out the ML trolls.
13:09:21 <monochrom> haha, where?
13:10:17 <applicative_> just the reddit discussion.  there have been several posts  about clever uses I was trying to follow
13:10:33 <int80_h> Cale: I was over-complicating things in my head. My research led me to believe I was going to have to use Existential Types, when in fact all I have to do is apply class constraints to functions using this type.
13:11:00 <applicative_> they're much better behaved than harrop, e.g. calling themselves 'we haskell programmers' ... etc.
13:11:19 <ski> Qtr : what do you want to `Show' ?
13:11:37 <jfischoff> int80_h: Existential Types are rarely the answer.
13:11:38 <int80_h> applicative_ : talking about the freemonads article?
13:11:57 <Cale> int80_h: You may also want to factor the type a little differently. Having a bunch of cases with identical fields can be a little more cumbersome than one enumeration along with a single case having that enumeration as a field.
13:12:03 <monochrom> existential types are a sometimes snack
13:12:03 <hpaste> “Clifford Beshers” annotated “happstack attributes” with “happstack attributes (annotation)” at http://hpaste.org/71840#a71843
13:12:33 <int80_h> Cale: Yeah it's been awhile since I thought about it. Revisiting it now makes me think it looks silly and it needs only one constructor.
13:13:13 <ski> int80_h : depending on what you want, using a GADT might be the answer
13:13:24 <quuuux> tvynr: stepping through strategically placed breakpoints can narrow it down, but you'd have to do that manually, and it's tiresome at high granularity
13:13:33 <otters> @pl \(x,y) -> [x,y
13:13:33 <lambdabot> (line 1, column 11):
13:13:33 <lambdabot> unexpected "["
13:13:33 <lambdabot> expecting lambda abstraction or expression
13:13:35 <otters> @pl \(x,y) -> [x,y]
13:13:35 <lambdabot> uncurry ((. return) . (:))
13:13:50 <applicative_> int80_h: no, the records posts, some also involving the clever Tekmo.
13:15:12 <applicative_> int80_h: e.g. dont use Agda use Coq, it's so much more advanced
13:15:28 <applicative_> never mind that program like this:  intros!  auto!  ...
13:15:44 <applicative_> that is to say, you bark orders and call it a proof
13:16:03 <Dashkal> Can someone suggest a paper discussing memory management algorithms for lazy evaluation/immutable computation in very limited memory?  Context is I'm thinking of writing a language for a couple fictional CPUs (DCPU-16 and 65el02)
13:16:08 <int80_h> oders huh, sounds imperitive.
13:16:08 <ski> augur : yeh
13:16:11 <int80_h> orders
13:16:42 <applicative_> yes, the user writes imperatives.  in the end there also an unreadable lambda term ....
13:16:45 <Targen> What’s the nicest way to pass structured/typed data reliably over a socket with minimal effort for serialization and such?
13:17:01 <ski> applicative_ : what reddit discussion ?
13:17:29 <applicative_> I was thinking of http://www.reddit.com/r/haskell/comments/wtx32/first_class_modules_without_defaults/ ski
13:17:31 <Cale> Targen: libraries like cereal and binary are nice in that regard. You could also use read/show instances if you were even lazier
13:17:35 <ski> ty
13:17:40 <matthiasgorgens> Targen: haskell to haskell?  if you just want it to work, you could use the standard show and read.
13:17:52 <Targen> Indeed, Haskell to Haskell.
13:18:17 <applicative_> what coq has to do with first class modules in particular I don't know.
13:18:18 <matthiasgorgens> Targen: though I think that the standard read isn't all that fast.  I'm not sure, though.
13:18:32 <Targen> Hm.
13:18:37 <Cale> Well, String isn't all that fast
13:18:55 <ski> Targen : note that it'll not work for functions, `IO'/`ST s'/`STM'-actions, `IORef a',`STRef s a',`IOArray i e',`MVar a', &c,
13:19:19 <ski> @quote stark
13:19:19 <lambdabot> AlanPerlis says: The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
13:19:31 <Targen> ski: Indeed.  Is there anything that can handle such things?
13:19:36 <Cale> Well, none of that stuff is very serialisable
13:20:41 <ski> Targen : O'Caml supports the marshalling of functions, in case you marshall between two processes running the same program compiled for the same platform with the same compiler version (but possibly different processes and different machines)
13:21:31 <ski> Targen : Alice ML also supports marshalling of functions (you can even have them communicate with the original machine over the network) -- i'm not sure about the constraints here
13:22:17 <EvanR> both of those are strict lagnuages
13:22:24 <ski> (apart from communicating back over the network, stuff like `IORef a' are inherently non-marshallable)
13:22:27 <Targen> ski: Anything of the sort in Haskell?  I read a bit about distributed-process and it seems promising, but the examples I’ve found seem rather limited, and I’m not quite sure how well it handles passing closures around.
13:22:48 <ski> EvanR : Alice ML supports laziness (without using a specific type like `susp' or `Lazy.t')
13:23:18 <ski> (s/using/having to use/, i suppose)
13:23:18 <shachaf> "Native Haskell TLS and SSL protocol implementation for server and client"
13:23:19 <shachaf> :-(
13:23:33 <Targen> I’m really looking for Erlang-style distribution with support for passing closures around, but I’d settle for comfortable, transparent serialization of data. :)
13:23:49 <ski> (yes, Erlang as well)
13:24:03 <int80_h> Is it possible to have this Map a Foo where a is a member of class Bar?
13:24:26 <int80_h> or do the keys in a Map all have to be the same type?
13:24:27 <ski> Targen : afaik, there's no work on marshalling closures in a Haskell implementation
13:24:32 <statusfailed> Is there a way to strip all the "literate" bits from a lhs file? I just want source :P
13:24:47 <ski> int80_h : the latter, yes
13:24:59 <Targen> Ah.
13:25:12 <slack1256> statusfailed: if you are in linux you can use a sed script
13:25:18 <ski> int80_h : i suppose you can do `Map (exists a. Bar a *> a) Foo'
13:25:39 <statusfailed> slack1256: I was wondering if there was a preprocessor somewhere, but yeah, i'll just sed it
13:25:43 <statusfailed> good call
13:25:51 <statusfailed> well, regex anyway :)
13:26:04 <slack1256> statusfailed : cat file.lhs | egrep '^\>' | sed 's/\>//'
13:26:09 <slack1256> will work ;)
13:27:38 <Targen> slack1256: That wouldn’t quite handle TeX-style blocks, though.
13:27:59 <statusfailed> slack1256: I did :%s/^[^>].*//g in vim, but now I have to delete blank lines, I will use yours :P
13:28:13 <geekosaur> isn't there a preprocessor included in ghc?  somewhere in an internal directory
13:28:15 <geekosaur> unlit
13:29:11 <slack1256> Targen: you are right, for some reason when I think in .lhs always is bird-style
13:31:19 <latro`a> probably silly question
13:31:20 <applicative_> hah, unlit is  unlit.c
13:31:21 <hpaste> latro`a pasted “IO ()/() mixup?” at http://hpaste.org/71844
13:31:27 <latro`a> ^why doesn't that typecheck
13:31:44 <latro`a> ah sorry
13:31:46 <latro`a> forgot one thing
13:31:56 <hpaste> “ghc crowd” pasted “unlit.c” at http://hpaste.org/71845
13:32:03 <hpaste> latro`a pasted “IO ()/() mixup?” at http://hpaste.org/71846
13:32:11 <latro`a> now why doesn't it typecheck
13:32:14 <latro`a> agh
13:32:16 <latro`a> did it wrong again
13:32:21 <hpaste> latro`a pasted “IO ()/() mixup?” at http://hpaste.org/71847
13:32:26 <latro`a> there we go
13:33:00 <Clint> schroedinbug: what?
13:33:00 <quuuux> latro'a: fmap (x :: a -> IO b) (y :: IO a) :: IO (IO b)
13:33:02 <Clint> er
13:33:32 <latro`a> hrm
13:33:51 <latro`a> oh I see
13:33:55 <latro`a> there's no return
13:34:01 <latro`a> when I put it in the form it was in before
13:34:02 <Targen> statusfailed: main = do [f] <- System.Environment.getArgs; putStrLn =<< Language.Preprocessor.Unlit.unlit f <$> readFile f
13:34:03 <latro`a> right
13:34:05 <latro`a> thanks
13:34:34 <latro`a> I was like, can't I just join the IO (IO b)
13:34:41 <Targen> I thought unlit was an actual executable.  Heh.
13:34:43 <latro`a> then "oh right that's the same thing"
13:35:13 <geekosaur> there was a separate unlit executable at one point
13:35:18 <applicative_> unlit.c makes an executable ; of course it is extremely fast
13:36:07 <geekosaur> oh look, it still is.  /Library/Frameworks/GHC.framework/Versions/7.4.1-x86_64/usr/lib/ghc-7.4.1/unlit: Mach-O 64-bit executable x86_64
13:37:14 <Dashkal> Apologies if someone replied to my earlier question re memory management in small systems.  Network issues.
13:38:27 * applicative_ aliases /Library/Frameworks/GHC.framework/Versions/7.4.1-x86_64/usr/lib/ghc-7.4.1/unlit
13:38:38 <shapr> Dashkal: I'd certainly like to be able to build haskell-platform in 192mb of ram on my Raspberry Pi, but a research paper won't help.
13:39:18 <Dashkal> shapr: Well, what I want is to be able to write for the DCPU-16 or the 65el02 in a haskell-like language.  Re the rpi, I'm going to go with the cross-compilier route.
13:39:40 <shapr> Yah, but it makes me sad :-(
13:39:48 * ski . o O ( DCPO-16 )
13:40:16 <shapr> aetoxx was saying that Haskell's generational memory management just doesn't work for memory-constrained systems. He's right as long as we're talking less than 256mb of ram.
13:40:37 <shapr> preflex: seen aetoxx
13:40:38 <preflex>  aetoxx was last seen on #haskell 5 days, 23 hours, 48 minutes and 47 seconds ago, saying: shapr, in that case good bye for now.
13:40:44 <shapr> I guess I upset him.
13:41:12 <Dashkal> ski: Fictional CPU used in Notch's upcoming space sim game.
13:42:17 <ski> Dashkal : yeah, pondering how to connect it to directed continuous partial orders
13:43:36 <slack1256> shapr: how is that about not using haskell in constrained system (<256Mb) ?
13:43:51 <slack1256> don't tell me that when I ordered 20 raspberry pi's
13:44:31 <jfredett> wtf, haskell won't work on raspberry pi? haskell's jumped the shark, everyone use F# now! </silly>
13:44:33 <geekosaur> time to bring nhc98 back!  :p
13:47:02 <slack1256> or maybe you are refering that you can't bootstrap ghc in the Pi?
13:47:36 <c_wraith> jhc should work fine on a raspberry pi
13:47:40 <shapr> slack1256: I'm referring to the fact that I can't compile HOpenGL in the Pi
13:48:09 <Dashkal> I wasn't planning on attempting to get ghci and co wokring on the rpi itself.  I'm perfectly content to just target it :P
13:48:30 <shapr> Actually, they work fine on the Pi, there's just not much memory available.
13:48:42 <Dashkal> *nods* that's why I'm content to just target it.
13:48:45 <shapr> Are there some magical ghc options I can add to reduce memory usage when compiling?
13:49:08 <Dashkal> Though I do need to get around to ordering one of those lcd panels so I have something to actually play with from haskell.
13:50:47 <hpaste> int80_h pasted “constraints problem” at http://hpaste.org/71849
13:51:57 <Peaker> int80_h, what's (*>) in the type operator namespace?
13:52:24 <Peaker> int80_h, if "class Foo" only has (a->String) in it, then why not use String instead?
13:53:57 <int80_h> Peaker: I was trying to make a toy example.
13:54:05 <osa1> is there a way to pattern match a list to get elements except last and last element?
13:54:13 <int80_h> Peaker: The type is not reflective of what I'm doing in my real code.
13:54:29 <int80_h> Peaker: I don't know what *> means, ski suggested I use it.
13:54:47 <int80_h> In hindsight, I should have asked.
13:55:13 <Peaker> osa1, last and last element?
13:55:20 <beefcube> this is so annoying, I've seen " * -> *" in GADTs and i think regular functions, what is its name/meaning?
13:55:23 <quuuux> int80_h: if this is the same as earlier, why not use an existential box for the key?
13:55:42 <Peaker> int80_h, instead of an existential+type-class, use a record, see http://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/
13:55:49 <osa1> Peaker: I want to split the list to two parts, first: a list with all elements except the last one, and second: the last element. sorry for my english
13:55:50 <int80_h> quuuux: sure. What does that lok slike?
13:55:51 <quuuux> int80_h: which is what ski's thingy is, except spelled in a way I don't understand properly
13:56:18 <Peaker> beefcube, it's a type constructor, it's a type "function" that takes a simple type of values as an argument and returns a simple type of values
13:56:31 <Peaker> beefcube, for example, "Int" and "String" are *, and "Maybe" and "[]" and "IO" are *->*
13:57:02 <Peaker> osa1, you could use:  case reverse xs of (lastElem : rest) -> ... reverse rest ...
13:57:04 <int80_h> quuuux: so how do I do that then?
13:57:23 <applicative_> beefcube: and Either is * -> * -> *
13:57:30 <hpaste> quuuux annotated “constraints problem” with “constraints problem (annotation)” at http://hpaste.org/71849#a71850
13:57:32 <Peaker> int80_h, most uses of existentials are superfluous IME.. they're useful mainly for performance reasons
13:57:38 <Dashkal> meh, looks like GC is absolutely required.  How to fit mark+sweep into 64K now.
13:58:17 <applicative_> beefcube: you can query kinds in ghci with :k
13:58:22 <MHD> In the Lattice of Types from Top to Bottom, what corresponds to Join and Meet operations?
13:58:42 <hpaste> Peaker annotated “constraints problem” with “constraints problem (annotation) (annotation)” at http://hpaste.org/71849#a71851
13:58:44 <quuuux> uh. I may or may not have mangled the syntax, I can't remember. Correct usage is in the GHC manual, or you can google for it, there are some decent enough explanations
13:58:45 <c_wraith> haskell types don't form a lattice
13:59:01 <MHD> types form a lattice in general
13:59:31 <beefcube> Peaker: ah,  thanks, I'm curious as to why one would prefer that over something like a -> b
13:59:45 <latro`a> brainfart: is StateT with the last parameter () equivalent to ReaderT or WriterT
14:00:02 <byorgey> MHD: what is the "less than" relation?
14:00:06 <byorgey> subtyping?
14:00:09 <applicative_> beefcube: it is like a -> b.   * is the name of the kind of ordinary types
14:00:24 <otters> this whole "must be imported, not defined locally" thing is really not making my job any easier
14:00:36 <MHD> byorgey: So far as I can tell. Everything is sub of Top, Bottom is sup of everything
14:00:45 <byorgey> MHD: right. Haskell does not have subtyping.
14:01:01 <Peaker> beefcube, we're talking about the "type level", which is not as powerful as the value level
14:01:01 <applicative_> which  "must be imported, not defined locally" thing ?
14:01:57 <Peaker> latro`a, s -> m (s, ())  could be like:   r -> m a  (Reader), if you consider the new state to be the "result", but probably otherwise not
14:02:12 <applicative_> beefcube: there are other basic kinds , e.g.  #
14:02:28 <applicative_> and still more if you turn on wacky extensions....
14:02:55 <byorgey> MHD: but in general join and meet would correspond to intersection and union types.
14:03:11 <byorgey> MHD: this is covered in chapter 15 of "Types and Programming Languages"
14:03:30 <MHD> byorgey: so, product and sum types in other words?
14:03:43 <quicksilver> no.
14:03:50 <quuuux> MHD: untagged. Haskell only does tagged
14:03:58 <quicksilver> although sum types and union types feel rather similar
14:04:15 <quicksilver> a union type actuall *is* the union of two types
14:04:25 <MHD> so it does both
14:04:26 <quicksilver> a sum type is a fresh type with canonical injections
14:04:33 <byorgey> no, e.g. the intersection of types T1 and T2 would be the type whose values consist of all those values which have *both* types T1 and T2.
14:04:45 * applicative_ praise the excellent judgment of 'Haskell'
14:04:51 <byorgey> (this doesn't exist in Haskell)
14:04:53 <applicative_> praises, even
14:04:56 <quicksilver> for example "Int + Int" is Either Int Int, but "Int u Int" is just Int
14:04:56 <MHD> so the intersection of an integer and a rational is integer
14:04:59 <augur> ski: http://wellnowwhat.net/Programming/SeqCalcNotes.pdf
14:05:03 <augur> nothing major  yet, obviously
14:05:03 <quicksilver> yes, MHD.
14:05:06 <augur> just a single little picture :p
14:05:17 <MHD> and int union rational is rational
14:05:25 <MHD> thanks
14:06:30 * dmwit ponders: are integers rationals?
14:06:31 <MHD> so, we strike lattice type system from features in pet programming language
14:06:37 <latro`a> Peaker: that doesn't really fix it, because the point is to hide the state parameter; I guess I'm just gonna have StateT with some ugliness
14:06:45 <MHD> dmwit: yes, 1/1 = 1, 2/1 = 2
14:06:55 <MHD> dmwit: and so forth
14:06:57 <dmwit> MHD: There's a canonical injection from integers to rationals, sure.
14:07:07 <augur> ski: but theres a nice way of getting from sequent definitions to these diagrams in a way that essentially just gives you the syntax
14:07:08 <Peaker> latro`a, if you don't need the last type param of StateT, why StateT?
14:07:22 <dmwit> MHD: But that's different. =)
14:07:25 <MHD> dmwit: think arithmetic fields, not datatypes
14:07:27 <Peaker> latro`a, why not (a -> m b) functions?
14:07:58 <latro`a> lemme do a schematic hpaste
14:08:01 <latro`a> of what I have now
14:08:17 <byorgey> integers aren't rationals even if you forget about data types.  e.g. they are encoded differently in set theory, etc.
14:08:23 <monochrom> you can freely choose "integers are rationals" or "integers are not rationals". either way can be made to work
14:08:27 <dmwit> MHD: Wikipedia defines the set of rationals as the set of pairs of integers. =)
14:08:38 <byorgey> but the canonical injection is SO familiar that most mathematicians don't even bother making the distinction.
14:08:40 <applicative_> @kind StateT
14:08:41 <dmwit> Well, quotiented by divisibility, of course.
14:08:41 <lambdabot> * -> (* -> *) -> * -> *
14:08:45 <augur> also, ski, im considering making use of different notation for hypotheses in my CH tutorial. i think i want undischarged hyps to have no bar above them.
14:08:54 <MHD> dmwit: The set of rationals is a proper superset of integers
14:09:06 <jfischoff> dmwit: you might find this interesting https://profiles.google.com/114134834346472219368/buzz/RarPutThCJv
14:09:06 * applicative_ maps 1 to 0.999etc
14:09:09 <hpaste> latro`a pasted “schematic” at http://hpaste.org/71853
14:09:20 <MHD> dmwit: If all integers are not rationals, present an integer that has no rational representation
14:09:33 <dmwit> Having a rational representation is not the same as being a rational. =)
14:09:33 <MHD> That is provably impossible
14:09:38 <MHD> yes it is
14:09:45 <MHD> Because that is how math works
14:10:04 <monochrom> no, being fuzzy is how math works
14:10:04 <hpaste> applicative annotated “schematic” with “schematic (annotation)” at http://hpaste.org/71853#a71854
14:10:08 <latro`a> not really; you're talking about isomorphism rather than equality
14:10:18 <jfischoff> MHD: you might want to read the link I posted too
14:10:19 <monochrom> I mean: how most mathematicians work
14:10:37 <latro`a> indeed, applicative, thanks
14:10:56 <latro`a> (was skimming over the details, but skimmed over an important one)
14:11:06 <monochrom> but I should not get into this bikeshed-colouring. so, if you disagree, I agree to disagree
14:11:34 <MHD> jfischoff: I live in abstract algebra land, arithmetic with soved numbers isn't the issue
14:11:53 <MHD> But interesting article
14:12:06 <monochrom> (I live in abstract category land. what is "number"? :) )
14:12:10 <latro`a> MHD: isomorphism isn't equality, it's just that mathematicians, or at least algebraists, don't care about the difference
14:12:16 <quuuux> mathematicians are very fuzzy. I believe it's an adaptation for warmth in the winter months
14:12:23 <monochrom> actually, is "soved" a typo?
14:12:36 <copumpkin> latro`a: depends which mathematicians
14:12:40 <latro`a> true
14:12:53 <copumpkin> and some people explicitly think they are the same thing :)
14:13:03 <MHD> latro`a: I am very used to thinking in terms of quantum-equality and the like for real-world problems, that might bleed over
14:13:07 <latro`a> also true, though that is a philosophical issue
14:13:15 <latro`a> and more controversial
14:13:22 <copumpkin> well, in the homotopy type theory land, it's an explicit design decision
14:13:39 * applicative_ decides in favor 
14:13:42 <monochrom> it doesn't have to be philosophical. I'll continue in -blah
14:13:42 <latro`a> Peaker: any thoughts on my schematic?
14:13:47 <hpc> isomorphism is the "looks like a duck and talks like a duck" of equality relationships
14:14:02 <MHD> Okay, so everything you can do with integers, you can do with rationals, so you can just specify that you are using a subset of rationals for your math and then not bother about integers
14:14:13 <latro`a> I'm trying to make these functions live in a state-like monad so I don't have to pass the board around everywhere
14:14:21 <Qtr> so how broken is axiomatic set theory with the AOC? can it ever be made a good foundation? what are the alternatives? category theory? probability?
14:14:24 <MHD> hpc: I can construct a duck from this bitstream
14:14:41 <latro`a> but simply State Board (IO ()) doesn't work, because I have to do the IO in the middle
14:15:01 <MHD> Qtr: just jump to the metal directly and read Principia Mathematica by Russel and Co.
14:15:44 <MHD> Qtr: Many consider Category theory to be an alternative
14:15:55 <applicative_> latro`a: what are you trying to add to 'schematic'; you are 'updating the state of the board' in IO just find
14:15:56 <Qtr> problabliblity?
14:16:09 <MHD> Qtr: Bayesian Probability theory is a complete system, so there is no inconsistencies, also it is good for only one thing
14:16:23 <MHD> Which is probabilistic inference
14:16:26 <Qtr> which is?
14:16:30 <latro`a> I'd rather not have board as an explicit parameter
14:16:34 <latro`a> if I can avoid it
14:16:48 <latro`a> what I have works, but I feel like there's a monadic version that is a little cleaner
14:17:23 <bnitka> @pl \x y -> y x
14:17:23 <lambdabot> flip id
14:17:25 <applicative_> oh okay.  So you want everthing in State Board a or StateT Board m a
14:17:32 <latro`a> yeah
14:17:38 <MHD> What is the # of the populated computer science channel around here?
14:17:52 <tromp_> my go program has board in state monad
14:18:13 <latro`a> just State seems problematic to me
14:18:20 <latro`a> because you only get the "a" at the end, no?
14:18:20 <tromp_> actually the state is list of all previous positions, so it can detect superko
14:18:38 <MHD> tromp_: I suggest looking at what abstract algebra thingies apply to go
14:19:06 <applicative_> well somethings you will put in (forall m.) StateT Board m x others in StateT Board IO x
14:19:15 <MHD> WHere can I read in-depth about Kinds?
14:19:35 <int80_h> quuuux:  Unsupported extension: ExistentialTypes
14:19:36 <applicative_> MHD the agda users manual?
14:19:49 <MHD> thanks
14:20:19 <dmwit> tromp_: What does your go program do?
14:20:23 <Cale> MHD: do you mean the kinds available in Haskell 98, or the new ones supported by GHC extensions, or just in general?
14:20:40 <MHD> Just in general
14:20:43 <tromp_> nothing much. just play out a recorded game
14:21:02 <latro`a> that's rather different
14:21:04 <quuuux> int80_h: oh. ExistentialQuantification. Peaker's solution is probably better, if you're designing from the ground up, though
14:21:09 <latro`a> than letting the user play a game
14:21:11 <dmwit> Huh, why do you need to detect superko for that?
14:21:18 <MHD> Cale: Trying to build a strong mental framework for thinking about computation and programs, so I need the abstracts of say, kinds.
14:21:25 <tromp_> as i mention on www.cwi.nl/~tromp/go.html, it's just the rules expressed in Haskell
14:21:44 <tromp_> because superko is a rule:)
14:21:55 <Cale> MHD: Well, in general kinds are just what we call the types of type-level things.
14:22:08 <MHD> Okay
14:22:16 <MHD> What about Classes, where do they fit
14:22:32 <Cale> Typeclasses are type-level things
14:22:32 <MHD> do classes have kinds?
14:22:46 <latro`a> yes
14:22:47 <MHD> I know what they do and how cool they are
14:22:48 <applicative_> MHD i think there isn;t much to know   http://hackage.haskell.org/trac/ghc/wiki/IntermediateTypes#KindsareTypes has a chart
14:22:57 <Cale> They didn't formally have kinds in Haskell 98, but they now are more first class and do with GHC extensions.
14:23:09 <tromp_> classes have arity
14:23:23 <tromp_> but cannot be partially applied
14:23:24 <Cale> In Haskell 98, the parameters to a class had kinds
14:23:24 <MHD> which is?
14:23:33 <Cale> but the classes themselves didn't
14:23:33 <latro`a> ah true you can't partially apply
14:23:51 <applicative_> MHD  if you ask :k Monad in your ghc what happens?
14:24:14 <Cale> Now with the Constraint kind extension, we have things like  Eq :: * -> Constraint
14:24:23 <Cale> and  Functor :: (* -> *) -> Constraint
14:24:30 <MHD> yeah
14:24:33 <MHD> that
14:24:39 <MHD> hm
14:25:00 <latro`a> anyway, @ Peaker, applicative_, I guess the main thing I'm trying to do is use a Board -> (IO (),Board) and then bind the IO () that I get to the IO () from the next call
14:25:01 <MHD> I am just trying to build a really minimal functional language that still does things on par with haskell
14:25:09 <latro`a> which just State won't let me do, as far as I know
14:25:12 <otters> wow, there are a lot of GHC bugs
14:25:15 <latro`a> at least not without ugly nesting
14:25:28 <Cale> otters: yes
14:25:32 <tromp_> MHD, the lambda calculus would do that
14:25:36 <applicative_> latro`a surely you want StateT Board IO ()
14:25:51 <MHD> tromp_: It isn't much more TBH
14:25:54 <latro`a> that's what I thought, but was not sure how to write it
14:25:56 <otters> I've gotten like four separate ones today
14:26:00 <Cale> otters: There have been a lot of major changes and expansions to GHC recently, without much time to solidify things yet.
14:26:04 <latro`a> (this will be my first actual program with transformers)
14:26:05 <applicative_> @unmtl StateT Int IO ()
14:26:06 <lambdabot> Int -> IO ((), Int)
14:26:07 <otters> I see
14:26:10 <MHD> Is C++-style type overloading unitable with hindley milner and polymorphic type inference?
14:26:14 <otters> well, better report some
14:26:22 <otters> as soon as I can simplify my bug which involves four separate files
14:26:50 <applicative_> @unmtl StateT Board IO ()
14:26:50 <lambdabot> Board -> IO ((), Board)
14:27:15 <fitzoh> Anyone care to help a noob out with a type/tuple issue? Getting compiler issues with expected types http://pastebin.com/RJqJjhvR
14:27:18 <mauke> The paste RJqJjhvR has been copied to http://hpaste.org/71855
14:27:40 <otters> oh, but it works fine with just plain ghci
14:27:42 <otters> without using cabal-dev
14:27:57 <latro`a> alright, knowing I'm using the right type should help, thanks applicative_
14:28:37 <Cale> fitzoh: instead of defining first, second, and third like that, and then only applying them to one 3-tuple, why not just pattern match that 3-tuple?
14:28:59 <geekosaur> fitzoh, at a first look, you are trying to use an ADT as a tuple?  doesn't work.  Bin a b c is not the same type as (a,b,c)
14:29:30 <Cale> yeah, that too
14:29:45 <Cale> Bin x y z and (x,y,z) are two different thinsg
14:29:46 <fitzoh> Cale: attempted that on first at first, couldn't get it working right, tried the verbose/exlicit approach
14:29:51 <Cale> things*
14:30:01 <fitzoh> Geekosaur... oops
14:30:23 <geekosaur> first (Bin a _ _) = a -- and similar for the others
14:30:24 <otters> oh, this is upsetting
14:30:34 <Cale> But don't do that
14:30:39 <hpaste> applicative annotated “pastebin.com/RJqJjhvR” with “pastebin.com/RJqJjhvR (annotation)” at http://hpaste.org/71855#a71856
14:30:54 <Cale> just pattern match the Bin on the left hand side of the definition where you're currently defining unmod
14:31:27 <geekosaur> yeh
14:31:33 <applicative_> fitzoh: like so ^^^. The main mistake is simple, but it is probably harder to articulate than to see
14:32:02 <Cale> don't define first/second/third like that if you're only going to use them once
14:32:16 <otters> oh wow
14:32:21 <otters> ghci has been messing with me, hasn't it?
14:32:25 <otters> you can define splices wherever you want
14:32:32 <applicative_> fitzoh (x,y,z) is the same as ((,,) x y z) but you want to match on (Bin x y z)
14:32:33 <otters> but you can't do that in actual files
14:34:20 <applicative_> fitzoh: though it is distributed throughout ("hi",6,True), (,,) is just another constructor, but not the one you want which is your Bin
14:37:25 <fitzoh> still not quite sure what pattern I want to drop in the unmod line
14:37:30 <fitzoh> and thanks for the help btw
14:38:02 <Cale> fitzoh: something like  Bin x y z = bins !! bin
14:38:09 <fitzoh> oh, ok
14:38:10 <Cale> maybe with better names for x, y, z
14:38:32 <Cale> !! is evil, but there's not much you can do about that without changing the type of this function
14:38:42 <hpaste> latro`a pasted “another schematic” at http://hpaste.org/71857
14:38:51 <latro`a> ^I think this is the gist of what I'm thinking of?
14:38:59 <fitzoh> ha I'll keep that in mind
14:39:22 <latro`a> and I guess that can be encoded in StateT, but I feel like StateT has more structure than this that I'd have to work around
14:39:46 <latro`a> err
14:39:50 <latro`a> woops
14:40:12 <fitzoh> Why exactly is it evil? performance, readability, style, all of the above?
14:40:24 <hpaste> latro`a annotated “another schematic” with “another schematic (annotation)” at http://hpaste.org/71857#a71858
14:40:29 <latro`a> that's what I meant
14:41:13 <Cale> All of the above, plus it can kill your program if passed an invalid index
14:41:29 <latro`a> (then sometimes f has an exitSuccess in it, basically)
14:41:30 <Cale> xs !! n takes O(n) time to compute (it has to walk down the list)
14:42:00 <Cale> and if the index is too large or negative, an exception which can't easily be caught is thrown
14:42:32 <Cale> and usually you want to do uniform operations on lists, rather than thinking about things in an elementwise fashion
14:42:58 <shapr> slack__: What will you be doing with 20 RPis?
14:43:39 <fitzoh> So what would the preferred method be for incrementing a hashed table?
14:43:43 <Cale> Modifying one element of a list at a time is either an indication that you're not making the most of the list library, or just that lists are not the right datastructure.
14:44:21 <Cale> If you need random access to various elements, use Data.Map, usually
14:44:40 <Cale> Or Data.Sequence, if having things be contiguous is important
14:45:08 <Cale> Or possibly one of the array libraries, if you're not doing updates so often.
14:46:35 <fitzoh> thanks, I'll have to read up on those
14:46:38 <Cale> You should think of lists as being like loops which haven't happened yet
14:47:08 <Cale> If your intention isn't to iterate over the elements of the list in the order that they occur in it, then using lists is going to be awkward.
14:47:34 <Cale> However, if it is, then lists are perfect
14:47:52 <Cale> Lists are common in Haskell programming for the same reason that loops are common in imperative programming.
14:48:01 <Cale> basically
14:49:26 <McManiaC> hmmmm so I'm currently working with the FFI, and all the previous functions were always accepting a pointer to a struct, and everything worked just fine. but now this function wants the actual struct as argument, and not a pointer, and everything goes to hell – what do?
14:49:49 <slack__> shapr: give some to "un techo para chile", some for some friend in college. and my uber project. "THE OVERLORD"
14:50:37 <fitzoh> So what's the easiest way to do Function a -> b -> a on [a] [b] for every permutation of a and b?
14:52:17 <slack__> shapr: which is just a bag in a aerostatic balloon with a gps integrated so I can ask from my cell phone to bring me my wallet from home to college when I forget it.
14:53:07 <ski> augur : i might perhaps write a single `Gamma' on the top of each dashed line, instead of labeling them with it
14:53:24 <ski> augur : "i want undischarged hyps to have no bar above them" -- ok, back to `[A]^x', then ?
14:53:43 <augur> ski: i want to label them with it because the gammas are just collections (possibly empty) of lines labeled with propositions
14:53:58 <tromp_> :t  \f  a b -> do { x<-a; y<-b; return f a b }
14:53:59 <lambdabot> forall (m :: * -> *) t b t1. (Monad m) => (m t1 -> m b) -> m t -> m t1 -> m b
14:54:08 <augur> ski: also, i decided to leave hyps as is
14:54:14 <tromp_> :t  \f  a b -> do { x<-a; y<-b; return $ f a b }
14:54:15 <lambdabot> forall t t1 a (m :: * -> *). (Monad m) => (m t -> m t1 -> a) -> m t -> m t1 -> m a
14:54:55 <shapr> slack__: sounds neat
14:54:59 <tromp_> :t  \f  a b -> [f x y | x<- a, y <- b]
14:55:00 <lambdabot> forall t t1 t2. (t -> t1 -> t2) -> [t] -> [t1] -> [t2]
14:55:12 <hpaste> applicative annotated “another schematic” with “another schematic (annotation)” at http://hpaste.org/71857#a71860
14:55:33 <applicative_> latro`a: sorry, wandered off , you want something like this  ^^^
14:57:34 <hpaste> qrt pasted “haddock ” at http://hpaste.org/71861
14:58:09 <Qtr> so why cant haddock parse add5?
14:58:17 <ski> augur : so you have dashed lines labeled with collections of lines labeled with propositions ?
14:58:22 <Qtr> also is it supposed to autogen html for me?
14:58:35 <augur> ski: XP
14:58:47 <augur> ski: no, obviously the gammas label the dashed lines that stand for the collections of lines
14:59:03 <augur> but i take your point
14:59:15 <ski> augur : and what, if anything, is on the top of the dashed / non-dashed lines here ?
14:59:25 <augur> i just dont like the idea of using them as nodes because then it implies that they represent things that exist as proofs
14:59:27 <ski> (i.e. on the top end)
14:59:57 <ski> augur : ok, i suppose i was assuming that `Gamma' stood for a collection of propositions (labelled with names)
14:59:59 <augur> ski: well, this is a proof rule, but in an actual proof you'd just draw a box around it with the lines connecting to the top and bottom
15:00:09 <augur> ski: this represents the context on the left, and the conclusions on the right
15:00:53 <augur> ski: basically the idea is just like this: take your normal ND proof trees and make the propositions into nodes
15:01:38 <augur> ski: and make interences into (possibly branching) lines with solid dots or bars in the middle, joining the premises and conclusions. label it with the name of the rule
15:02:01 <augur> ski: now take the poincare dual of that: make the nodes into lines, and the (multi)-lines into nodes
15:02:20 <augur> so if you have a proof that just has P at the top, it turns into just a line
15:03:00 <Qtr> > let (%) = mod in 117 % 2
15:03:01 <lambdabot>   1
15:04:17 <hpaste> applicative annotated “another schematic” with “latro`a” at http://hpaste.org/71857#a71862
15:04:44 <ski> augur : i might perhaps add an arc connecting the lines in a multi-line (it's common notation)
15:05:17 <hpaste> qrt pasted “error when wrong arg?” at http://hpaste.org/71863
15:05:25 <augur> ski: well, i dont use the multi-line notation, i was just suggesting it as an intermediate step to make it conceptually clear how these string diagrams relate to the ND proofs
15:05:25 <Qtr> can error be caught?
15:06:47 <nand`> Qtr: only in the IO monad
15:06:55 <ski> augur : anyway, these diagrams reminds me of the book "Multiple-Conclusion Logic" by D. J. Shoesmith & T. J. Smiley in 1978
15:07:04 <jfischoff> Qtr: usually it is better to have your function return a Maybe or an Either
15:07:18 <ski> augur : they consider proofs (very) abstractly as being these kinds of graphs
15:07:23 <augur> ski: well, they're really just diagrammatic representations of things like G |- D
15:07:39 <Qtr> jfischoff: yes usually, but here?
15:07:42 <augur> ski: i mean, if you think of the relationship between ND proof trees and things of the form G |- p : P, right
15:07:58 <ski> augur : yes
15:08:02 <Qtr> Also, can you get a trace of the error and not just a message?
15:08:05 <jfischoff> Qtr: sure
15:08:20 <augur> ski: p is just the proof tree, which is usually represented in LC notation but could just as well be represented in ND tree notation
15:08:40 <augur> ski: well ok, but how do you handle G |- D when D is not just one thing?
15:09:00 <ski> augur : i think taking a look at that book might be interesting to you. they're not only talking about the ordinary connectives, but about all possible ones, and about all possible inference rules
15:09:05 <augur> ski: and now do you translate from sequents into these new representations?
15:09:15 <ski> (including "inconsistent" ones)
15:09:23 <MagneticDuck> yo, I have a very general problem...
15:09:31 <MagneticDuck> I have a place in my program where I execute:
15:09:38 <augur> ski: well, i can give you an algorithm for translating sequents into string diagrams, if we want string diagrams as the notation :)
15:09:38 <MagneticDuck> appendFile filename value
15:09:49 <augur> ski: ill definitely give it a look
15:09:53 <MagneticDuck> and after the program finishes, the file isn't changed
15:10:00 <MagneticDuck> any general ideas why that could be happening?
15:10:07 <augur> ski: right now im adding color and semantics to my tutorial
15:10:08 <startling> how does haskell's garbage collection work? it seems like it could do some neat things like static analysis of values' lifetimes
15:10:09 <MagneticDuck> perhaps I'm understating the problem
15:10:12 <augur> semantics as in semantic latex
15:10:23 <nqpz> Anyone, if you have time: If I have the code data = A | B | C deriving (Enum), is there some way I can make succ C == A?
15:10:24 <ski> augur : `G_0 , ... , G_{m-1} |- D_0 , ... , D_{n-1}' is represented as a graph with `m' "enter" nodes, and `n' "exit" nodes
15:10:45 <MagneticDuck> nqpz: No, because you're already deriving Enum
15:10:54 <MagneticDuck> you have to either derive the whole thing, or do it manually
15:10:56 <nqpz> Is there some other typeclass that can do the job?
15:11:01 <MagneticDuck> err..
15:11:05 <MagneticDuck> succ?
15:11:06 <augur> ski: yeah, i decided it was more elegant to not use nodes for propositions, but that version with nodes is the intermediate "multiline" thing i described
15:11:09 <MagneticDuck> succ is a function of enum
15:11:11 <MagneticDuck> no
15:11:20 <nqpz> No, something else than Enum
15:11:26 <MagneticDuck> not really...
15:11:29 <ski> augur : i'm not sure the book talks any about harmony, but otherwise i think it's interesting (though a bit dry)
15:11:33 <nqpz> ok
15:11:57 <MagneticDuck> npqz: even if there was, it wouldnt' be of any value, because all the prelude functions are made with enum
15:12:17 <MagneticDuck> prelude and on that is..
15:12:18 <McManiaC> how do I deal with C structs in the haskell FFI if the C function does not expect a pointer to a struct but the "real thing"?
15:12:35 <MagneticDuck> yoyo, about my question?
15:12:43 <MagneticDuck> gosh, lots of them going on right now
15:12:51 <McManiaC> I can only find stuff that uses Ptr to refer to structs
15:13:09 <geekosaur> McManiaC, I think you need to write a wrapper in that case
15:13:11 <ski> startling : the GC is a run-time thing. but yes, there are some opportunities for compile-time GC (i'm not sure if GHC does any, i know the Mercury compiler does some)
15:13:35 <augur> ski: dry is ok. better than wet. 0.0
15:13:51 <MagneticDuck> is there any reason why a call to appendFile wouldn't actually change the file?
15:14:17 <MagneticDuck> I guess not?
15:14:26 <McManiaC> geekosaur: is it possible to do this in general or do I have to do it for EVERY function?
15:14:29 <startling> ski: interesting
15:14:38 <povman> MagneticDuck: hFlush?
15:14:44 <MagneticDuck> oh, I'll try that
15:14:52 <MagneticDuck> but wat
15:14:53 <MagneticDuck> wait
15:15:02 <ocharles> i would imagine that flush is still called on application exit when all open file handles are closed
15:15:05 <MagneticDuck> appendFile does all the handling inside of the function
15:15:09 <geekosaur> appendFile doesn't... that
15:15:10 <MagneticDuck> ..yeah
15:15:21 <ski> startling : <http://hackage.haskell.org/trac/ghc/wiki/Commentary/Rts/Storage/HeapObjects#Selectorthunks> might be interesting. you could also check out <http://en.wikipedia.org/wiki/Region-based_memory_management>
15:15:22 <geekosaur> afaict it should succeed or throw an exception, not silently fail
15:15:28 <MagneticDuck> okay
15:15:33 <povman> MagneticDuck: ..yeah
15:16:00 <MagneticDuck> ?
15:16:21 <povman> MagneticDuck: does it change the file after it has exited though? or is it just not doing anything
15:16:25 <ski> startling : also, not only Mercury, but also Clean can reuse uniquely-referenced objects when creating a new one (often in terms of the old), discarding the old one
15:16:30 <MagneticDuck> no, it just does that one thing
15:16:50 <startling> ski, oh, nice
15:17:06 <geekosaur> McManiaC, it's possible that c2hs can help with it, but in general sane APIs do not passs structs directly (there are significant historical reasons plus they're just difficult to deal with in general, although C compilers have the complexity hidden inside them)
15:17:06 <thetallguy> I see that Pointed has been deprecated
15:17:10 <quuuux> MagneticDuck: can you reproduce this in a tiny example or is your test-case large?
15:17:16 <ski> augur : yeah, the book uses graphs with two kinds of nodes, proposition-nodes, and rule-nodes
15:17:44 <thetallguy> anyone know if the is a class that guarantees a single identifiable value?
15:17:50 <MagneticDuck> quuuux: unfortunately, it's inside of the program, nicely nested away in a data type
15:17:51 <thetallguy> other than Maybe.
15:17:54 <MagneticDuck> and a function
15:18:00 <augur> ski: yeah. i liked lines better for proposition nodes. it makes them clearly string diagrams. :)
15:18:03 <MagneticDuck> requiring a few non-readable parameters
15:18:32 <augur> ski: but i might use proposition nodes if you think it'd be better.
15:18:43 <MagneticDuck> I think I know what's causing it now, and it's not appendFile
15:18:59 <povman> MagneticDuck: what?
15:19:28 <MagneticDuck> povman: yes?
15:19:53 <Qtr> randomBoard = Mo.replicateM 9 randomMark >>= \marks -> return $ TicTacToeBoard marks
15:19:58 <Qtr> can that be done differently?
15:20:05 <Qtr> (simpler)
15:20:29 <povman> MagneticDuck: what's causing it?
15:20:39 <povman> map B.length xs
15:20:59 <MagneticDuck> povman: A silent return () triggered by some Maybe value being Nothing
15:21:07 <povman> oh right
15:21:13 <MagneticDuck> the predicate for its nothingness is screwy
15:21:29 <geekosaur> TicTacToeBoard `fmap` Mo.replicateM 9 randomMark -- ?
15:22:08 <MagneticDuck> (\a -> return (f a)) is always fmap f
15:22:16 <MagneticDuck> that's a law of monads or something right?
15:22:18 <ocharles> or (f <$>)
15:22:19 <MagneticDuck> lol I'm mixed up
15:22:21 <MagneticDuck> yeah
15:22:32 <MagneticDuck> I wish that thing was built into the prelude!
15:22:35 <MagneticDuck> it's so useful
15:22:46 <MagneticDuck> I mean, one line of code isn't much
15:22:56 <MagneticDuck> but in ghci, you get all that many more characters on the prompt
15:22:58 <MagneticDuck> :P
15:23:01 <povman> map ByteString.length xs seems to be allocating 104 bytes per element of xs. that is bad because xs has 1969257 elements.
15:23:03 <ocharles> The law of monads just means that the equivalence fmap f a == a >>= \b -> return (f b) always holds
15:23:15 <ocharles> along with functor laws
15:23:27 <ocharles> but it's not a law in itself
15:23:40 <MagneticDuck> okay, but it's derived from the laws
15:24:22 <MagneticDuck> btw I meant to say:
15:24:25 <ocharles> i'm not sure i'd say derived 'from' the laws. the laws just state essential properties of those functions
15:24:29 <MagneticDuck> >>= (\a -> return (f a)) is always fmap f
15:24:36 <MagneticDuck> okay
15:24:46 <MagneticDuck> it's.. a true statement
15:25:12 <MagneticDuck> under those laws of monads holding true
15:25:31 <ocharles> and functors*, but yes, that's correct
15:25:43 <MagneticDuck> we can't have any ambiguity here on #haskell can we now?
15:25:45 <MagneticDuck> >:|
15:25:58 <AeroNotix> so i heard that Javascript's type system greatly influenced Haskell's
15:26:07 <ocharles> well if we went around saying "that's basically correct" we wouldn't get anywhere now, would we?
15:26:08 <MagneticDuck> hrm...
15:26:09 <ocharles> :)
15:26:13 <MagneticDuck> AeroNotix: You mean java
15:26:15 <Nereid> AeroNotix: I heard haskell is older than javascript
15:26:15 <MagneticDuck> I believe
15:26:17 <Nereid> and java
15:26:25 <MagneticDuck> and I doubt that it was a real influence
15:26:32 <MagneticDuck> I mean, they do some things the same
15:26:35 <Nereid> I doubt it to considering they were newer than haskell
15:26:36 <AeroNotix> hahahaa
15:26:37 <Nereid> too*
15:26:42 <povman> i heard haskell was just a thin layer over asm
15:26:47 <MagneticDuck> ll yeah
15:26:50 <AeroNotix> ohhh that was an easy troll
15:26:54 <MagneticDuck> heh
15:26:59 <MagneticDuck> lol povman
15:27:15 <Nereid> AeroNotix: I'd hardly call it successful.
15:27:19 <MagneticDuck> ..that WAS a joke right?
15:27:20 <MagneticDuck> :O
15:27:21 <c_wraith> you mean haskell isn't assembly?
15:27:23 <AeroNotix> It was a joke but ok
15:27:27 <quuuux> @faq Can Haskell act as assembly?
15:27:28 <lambdabot> The answer is: Yes! Haskell can do that.
15:27:29 <c_wraith> my teachers all lied to me!
15:27:35 <ciaranm> ...over lambda calculus, not asm. try harder!
15:27:38 <povman> c_wraith: i mean on haskell computers
15:27:44 * geekosaur just managed to imagine a haskelly Mix-oid
15:27:53 <MagneticDuck> @faq can haskell make coffee?
15:27:53 <lambdabot> The answer is: Yes! Haskell can do that.
15:27:57 <MagneticDuck> -_-
15:28:00 <MagneticDuck> troll faq
15:28:11 <MagneticDuck> @faq can you dig the panama canal with haskell?
15:28:11 <lambdabot> The answer is: Yes! Haskell can do that.
15:28:16 <AeroNotix> I want to properly use Haskell but I cannot get out of the "This is cool, I guess" stage with it. Where are the enterprisey CRUD apps written in Haskell that I can justify using it for work purposes?
15:28:16 <c_wraith> @faq can haskell solve the Post correspondence problem?
15:28:17 <lambdabot> The answer is: Yes! Haskell can do that.
15:28:27 <ocharles> @faq can haskell solve the halting problem?
15:28:27 <lambdabot> The answer is: Yes! Haskell can do that.
15:28:34 <ocharles> wow. what a language!
15:28:44 <MagneticDuck> @faq can haskell solve a p versus np problem?
15:28:45 <lambdabot> The answer is: Yes! Haskell can do that.
15:28:45 <AeroNotix> @faq can Haskell
15:28:46 <lambdabot> The answer is: Yes! Haskell can do that.
15:28:51 <MagneticDuck> WE'LL SEE ABOUT THAT WON'T WE??
15:28:52 <quintessence> @faq can you write haskell code without using haskell?
15:28:53 <lambdabot> The answer is: Yes! Haskell can do that.
15:29:03 <MagneticDuck> @faq can you kill a man using haskell?
15:29:03 <lambdabot> The answer is: Yes! Haskell can do that.
15:29:06 <MagneticDuck> woah
15:29:09 <MagneticDuck> this is getting scary
15:29:10 <c_wraith> @faq can haskell co-exist with anti-haskell?
15:29:11 <lambdabot> The answer is: Yes! Haskell can do that.
15:29:17 <MagneticDuck> omg
15:29:23 <MagneticDuck> @faq WHAT CAN'T HASKELL DO??
15:29:24 <lambdabot> The answer is: Yes! Haskell can do that.
15:29:26 <MagneticDuck> urm
15:29:27 <ciaranm> didn't you see all the references to launchMissiles in the haskell docs?
15:29:28 <Qtr> is f <$> applicative and what is applicative?
15:29:39 <MagneticDuck> ciaranm: true true
15:29:43 <ocharles> Qtr: 'an applicative' is an applicative functor
15:29:49 <MagneticDuck> unfortunately, they have no aiming parameter
15:29:51 <ski> startling : for Mercury, see <http://www.mercurylang.org/information/doc-latest/mercury_ref/Unique-modes.html>, and the papers by Nancy Mazur, et al. (e.g. her thesis) at <http://www.mercurylang.org/information/papers.html> (i think there's some paper where which describes unique modes in more detail, Mazur's thesis mentions them in 3.3.3)
15:29:54 <ciaranm> Qtr: Applicative is a typeclass. <$> is a function that works with applicatives.
15:29:59 <ocharles> <$> is a convenience function for working with <*>
15:30:00 <AeroNotix> I want to properly use Haskell but I cannot get out of the "This is cool, I guess" stage with it. Where are the enterprisey CRUD apps written in Haskell that I can justify using it for work purposes?
15:30:07 <Nereid> (<$>) = fmap
15:30:12 <MagneticDuck> ciaranm: hm, don't you mean <*>?
15:30:21 <Nereid> fmap works with applicatives too
15:30:31 <jfischoff> AeroNotix: There aren't that many
15:30:37 <ocharles> Qtr: I recommend learn you a haskell's section on applicative, along with original paper
15:30:43 <ciaranm> MagneticDuck: not really. Qtr asked about <$>.
15:30:58 <ocharles> Qtr: the original paper can be a little daunting if you don't read many papers, but if you give it a bit of patience it's certainly approachable
15:31:14 <ocharles> Qtr: Essentially you can think of <$> and <*> as ($), but with effects
15:31:23 <Nereid> I think of <$> as fmap.
15:31:23 <overscore> how can i link against a dll using ghc?   I tried  "ghc Curs.hs -l pdcurses"  but it says not found
15:31:26 <povman> AeroNotix: Tell them that your own personal installation of darcs will speed up your work flow
15:31:37 <jfischoff> ocharles: you need to be pretty fluent in haskell to read that paper (atleas that was the case for me personally)
15:31:41 <ocharles> Nereid: that's probably because it *is* fmap? :)
15:31:46 <Nereid> ocharles: indeed.
15:31:56 <Qtr> how could you possibly justify writing an app you believe in in haskell when you if it gets big you want to hire and you can hardly find anyone with experience of haskell...python on the other hand...i guess if you do find aomeone they prob hvae a phd and dont have much job offers so cheap great workforce :)
15:32:00 <Nereid> overscore: well yes, you need some way to glue haskell to that, which is what the FFI is for.
15:32:02 <ocharles> jfischoff: a bit, yes. but if you don't gravitate on specifics, you can pick up the general idea
15:32:16 <ocharles> jfischoff: of course actually using it takes a bit more haskell-fu
15:32:17 <startling> ocharles: "you can think of <$> and <*> as ($), but with effects" <- what do you mean by this?
15:32:19 <overscore> Nereid: well, ghci works fine on the program. it's just ghc that's missing now
15:32:27 <Nereid> eh
15:32:32 <MagneticDuck> @faq can you defeat chuck norris with haskell?
15:32:32 <lambdabot> The answer is: Yes! Haskell can do that.
15:32:39 <MagneticDuck> okay back to useful things
15:32:40 <jfischoff> ocharles: *nods*
15:32:50 <startling> ocharles, I'm assuming you mean beyond "they're all infix operators"?
15:32:56 <ocharles> startling: so we have a function "plus2" that takes an integer and adds 2 to it. if we have 4 we can write: plus2 $ 4
15:33:20 <MagneticDuck> $ : <$> :: <$> : <*>
15:33:20 <ocharles> but what if we have something like getInt :: IO Int? we can't just do plus2 $ getInt
15:33:22 <MagneticDuck> ..kinda
15:33:29 <frerich_> Qtr: When it comes to commercial projects, the most sophisticated language isn't necessarily the best one (as you noticed).
15:33:33 <ocharles> however, if we use <$>, we can: plus2 <$> getInt
15:33:42 <ocharles> that's what I meant by function application with side effects
15:33:46 <startling> ocharles, oh, I see what you mean I guess
15:33:51 <MagneticDuck> side effects?
15:33:53 <startling> the ($) part threw me off
15:33:55 <ski> quuuux : <http://www.haskell.org/pipermail/haskell-cafe/2004-March/005939.html>
15:33:55 <MagneticDuck> well not necessarily...
15:34:06 <MagneticDuck> howabout application in a context?
15:34:08 <ski> augur : not sure if nodes for propositions are better. try both ?
15:34:17 <startling> ocharles: I think "fmap" is a much more intuitive description. :)
15:34:27 <ocharles> startling: only if you know what fmap does
15:34:35 <MagneticDuck> <$> works fine for me
15:34:36 <quuuux> ski: I knew as soon as I said it that that'd be brought up. At least no-one's mentioned the BASIC monad yet (oops!)
15:34:40 <ocharles> i actually found it much more enlightening to realise it's a parallel to normal function application
15:34:44 <startling> ocharles: that's true.
15:34:46 <ocharles> ymmv
15:34:49 <ski> quuuux : .. i was thinking about that one :)
15:35:02 <startling> ocharles: fmap over (->) is pretty cool and fits better with your explanation
15:35:15 <ocharles> startling: especially when you have functions with more arity. like (+) <$> getInt <*> getInt
15:35:28 <ocharles> if we excuse the noise, this is basically: (+) getInt getInt
15:35:28 <startling> ocharles: right
15:35:39 <ocharles> knowing 'its like fmap' doesn't quite convey that, for me
15:36:01 <startling> maybe "application over a level of abstraction"?
15:36:09 <povman> I think ByteString.concat has a defect
15:36:43 <augur> ski: ill do up some diagrams and show you
15:36:46 <povman> in that it is too lazy in calculating the total length
15:37:12 <startling> anyway, i wish I had known about (<$>) when I was learning functors
15:37:19 <startling> rather than when I was learning applicative
15:37:24 <startling> it's much neater than fmap imo
15:37:25 <ocharles> startling: again, there are various ways to explain it. I am of the camp that I need things explained in a tangible example, and then I go back and learn the ins-and-outs
15:37:41 <startling> ocharles: anyway, thanks for the added perspective
15:37:45 <ocharles> np!
15:41:30 <Qtr> how can i easily find out what version my packages are?
15:42:01 <Qtr> do i need to givr build-depends things like Data.Maybe and Control.Monad?
15:42:17 <quuuux> Qtr: ghc-pkg list
15:42:32 <Nereid> don't confuse modules with packages
15:44:06 <Qtr> <$> and fmap has exact same type but are not the same?
15:44:27 <avpx> <$> is an infix operator.
15:44:31 <jfischoff> @src (<$>)
15:44:32 <lambdabot> f <$> a = fmap f a
15:44:57 <povman> can anybody confirm that (sum . map ByteString.length $ xs) is slower than (List.foldl' (\a b -> a + ByteString.length b) 0 xs)
15:45:01 <avpx> > succ <$> [1..]
15:45:02 <lambdabot>   [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,2...
15:45:20 <geekosaur> povman, under what circumstances?
15:45:40 <geekosaur> is this compiled code, or ghci/runghc?  if compiled, what optimization level?
15:45:46 <povman> geekosaur: i mean in terms of heap usage, with a very large list of xs
15:45:46 <Qtr> why not givre things like <$> and <*> names? what are they? using weirdo syntax doesnt help anyone
15:46:05 <geekosaur> heap usage?  slower?  erm?
15:46:24 <geekosaur> one of them has a name (fmap)
15:46:34 <jfischoff> Qtr: the rational comes from the paper "Applicative Programming with Effect"
15:46:40 <jfischoff> rationale
15:46:42 <povman> geekosaur: sorry i mean to say memory allocations are slowing down the function
15:46:43 <geekosaur> but the problem with alphanumeric names is that you can;t use them as operators (without wrapping in ``)
15:46:44 <c_wraith> Qtr: they are abstract concepts, where the meaning depends on context. And making them infix operators makes them easy to use
15:47:01 <geekosaur> povman, that makes me think something is not fusing.  which goes back to the optimization question
15:47:13 <avpx> So you can use `fmap` as an infix operator or (<$>) as basically fmap.
15:47:25 <povman> geekosaur: well map and sum are lazy
15:47:28 <pjw> Question from a cabal-dev newbie. When cabal-dev tells me it might break a package by reinstalling and demands that I use --force--reinstall, it is actually claiming it might break something in the cabal-dev folder not at the global level right?
15:47:29 <geekosaur> bytecode doesn;t get optimized; I don't know if -O1 fuses
15:47:40 <avpx> <$> is supposed to be like $ generalized to the functor.
15:47:48 <povman> geekosaur: foldl' is strict
15:48:21 <povman> geekosaur: sorry i missed that; it's optimised compiled code
15:49:25 <geekosaur> and, note that they may be lazy but if ghc can infer strictness it may not treat them as lazy.  but determining this involves poking at core
15:49:56 <geekosaur> (speaking of, wonder if I can install the ghc-core pckage without having the full dev system online on the air...)
15:50:08 <povman> geekosaur: I didn't know ghc could infer strictness
15:50:45 <povman> geekosaur: profiling the two versions shows that the 'slow' one allocates 200M of memory, while the 'fast' one allocates 16 bytes
15:51:24 <geekosaur> it can under some circumstances.  which will change how it does things and may enable or disable some optimizations (in particular fold/build, although if you foldl you broke that one yourself I think)
15:51:57 <jfischoff> Qtr: <*> is like function application which is usually just a space. Conor McBride thought you could have this context or idiom [ g $ f x y ] where function application does some else . But you can't make idiom brackets with Haskell so the made <$> and <*> because it looks the closest to want they wanted.
15:52:15 <povman> geekosaur: What do you mean? should i just use fold and not foldl?
15:53:14 <geekosaur> the specific thing I was talking about is foldr/build, which is one of the ways that ghc implemnts streaming (which lets it get rid of intermediate allocations)
15:53:37 <geekosaur> I won;t say that's your porblem but it is one optimization you may be preventing from firing
15:54:08 <geekosaur> you might be able to inspect the core generated by ghc (install the ghc-core package) to see what's going on
15:55:16 <geekosaur> (core is a sort of austere haskell with various implicit things made explicit, including strictness and typeclass dictionaries; clean, simple core usually produces the fastest code with the fewest waste allocations)
15:55:58 <povman> geekosaur: I'll have a look. The code i'm looking at specifically is ByteString.concat, which uses the 'slow' length calculation
15:57:05 <geekosaur> there may be some spots in ByteString that are manually optimized for older ghc versions, I don't know its current status
15:57:40 <geekosaur> bytestring *drove* a lot of the fancy stream fusion stuff in modern ghc, but the code that did it "by hand" could well be a pessimization these days in some cases
16:01:22 <Qtr> @src replicate
16:01:23 <lambdabot> replicate n x = take n (repeat x)
16:01:25 <Qtr> @src replicateM
16:01:25 <lambdabot> replicateM n x = sequence (replicate n x)
16:01:39 <Qtr> @src sequence
16:01:40 <lambdabot> sequence []     = return []
16:01:40 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
16:01:40 <lambdabot> -- OR: sequence = foldr (liftM2 (:)) (return [])
16:01:45 <Qtr> @type sequence
16:01:46 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
16:02:34 <donri> Qtr: sequence [a,b,c] == a >> b >> c == do a; b; c
16:02:46 <donri> well, sequence_
16:03:34 <Qtr> can you do runtime type checking in haskell?
16:03:54 <donri> in ghc 7.6 or somesuch yes, -fdefer-type-errors
16:04:02 <c_wraith> that doesn't check at compile time
16:04:04 <augur> ski: http://wellnowwhat.net/Programming/Curry-Howard.pdf
16:04:06 <augur> ski: now with colors
16:04:11 <augur> what do you think of the color scheme?
16:04:13 <c_wraith> that just replaces broken code with code to print the type error
16:04:53 <c_wraith> ghc's compilation technique removes type information, except as needed for passing around instance dictionaries
16:05:14 <donri> if what you want is dynamic typing where you check the type of things conditionally, maybe Typeable
16:05:27 <Qtr> can i use QuichChecks Arbitrary instance, use the arbitrary function to generate a random instance? like arbitrary :: Board or something(well that doesnt work but)?
16:05:32 <donri> (but, you probably don't want that)
16:06:55 <jfischoff> Qtr: there is the arbs and gens functions of the checkers package that do that
16:07:10 <pjw> Question form a cabal-dev newbie.  When cabal-dev says it might break packages when forcing an install where are packages broken at the cabal-dev folder or at the globabl level?
16:07:15 <jfischoff> Qtr: Their in IO for some reason, not sure if that is a requirement
16:07:16 <donri> i think Qtr wants this not for tests but app code
16:07:38 <jfischoff> donri: you can use those for app code
16:07:41 <geekosaur> pjw, if you did it right it should not be capable of breaking the top leve
16:07:48 <donri> sure, but might not be optimal
16:07:58 <jfischoff> true
16:08:06 <Qtr> t is for testing
16:08:17 <Qtr> just things that i cannt qucikcheck test
16:08:36 <pjw> geekosaur: That is what I thought too. I did not have a cabal-dev folder yet so I did not understand where it could possible break anything however.
16:08:37 <geekosaur> pjw, it does not *prevent* you from using --global to install stuff, although usually simply doing installs as nonroot should prevent that
16:08:40 <Qtr> i wrote a function randomBoard, just wondering if i could just use something form quickcheck instead
16:09:10 <donri> maybe, but you might as well use the random package and the Random class
16:09:42 <pjw> geekosaur: Thanks for the second opinion.
16:10:14 <donri> Qtr: why can't you quickcheck the code?
16:11:07 <geekosaur> donri, I think the point is Qtr wants to borrow the random generation part of QC, not do weird testing
16:11:35 <Qtr> ic ant fmap on IO SomeType
16:11:50 <geekosaur> hrm?
16:11:57 <donri> i thought so too, but ey said it's for testing
16:12:36 <Qtr> or i have to think more about how to quickcheck test TicTacToe
16:12:54 <donri> do firstArg <- fmap head getArgs -- etc, works fine?
16:13:42 <donri> quickcheck is good for testing properties that are "universally true" about something but not covered by the type system
16:15:08 <donri> so if you have a function to have the computer calculate a move, you could test that against a random board and check things like, the computer doesn't make its move on a place already taken in the board
16:15:28 <donri> ...for one example.
16:16:21 <donri> there's also HUnit for more traditional testing
16:19:17 <Qtr> do haskell people think that haskells type system + property based testings takes away like 99.9% of all bugs?
16:19:36 <Dashkal> I try not to think in generalities like that...
16:19:56 <ocharles> we feel they prevent bugs that may be missed in other languages
16:20:03 <ocharles> i would never put a number as high as 99.9% on it thuogh
16:20:16 <merijn> Personally I like the type system more as guide while coding than as a bug prevention thing
16:20:19 <ocharles> they do help remove classes of commonly occuring bugs though
16:20:35 <povman> merijn: +1
16:21:08 <merijn> My current code consists of 50% 'foo :: <some type signature>; foo = error "not implemented yet' :p
16:21:11 <povman> the advantage of having actual types is mainly in the documentation
16:21:12 <quuuux> personally, I feel that the type system is a way to come across new, exciting types of bugs
16:21:29 <quuuux> how many C++ programmers have had the joy of trying to fix kind errors?
16:21:57 <povman> quuuux: templates?
16:22:03 <donri> Qtr: there are classes of bugs that neither of those prevent
16:22:37 <Axman6> Qtr: no, but it sure does help. unit testing can only go so far. if you could write perfect tests, your programs wouldn
16:22:39 <donri> but they certainly help to prevent a lot of bugs
16:22:42 <Axman6> wouldn't have bugs anyway
16:22:52 <donri> mainly, though, strong types prevent runtime exceptions
16:23:02 <Axman6> you'd understand the code so well that there wouldn't really need to be tests
16:23:02 * hackagebot optparse-applicative 0.1.1 - Utilities and combinators for parsing command line options (PaoloCapriotti)
16:23:26 <Axman6> donri: except if you're using exceptions =)
16:23:34 <Axman6> or error
16:23:57 <donri> sure
16:24:23 <donri> but you can often use a more "typed" approach to avoid those
16:29:12 <povman> types are probably the main reason why factor sucks so hard
16:29:25 <povman> (lack-or)
16:29:30 <povman> of
16:32:33 <donri> hm i guess you could say that static types prevent runtime exceptions, strong types prevent bugs. dynamic, strongly typed languages similarly prevent bugs but by throwing errors at runtime. weakly typed languages try to guess what you meant instead of throwing errors, resulting in real bugs.
16:34:46 <ocharles> optparse-applicative looks sweet
16:34:58 <donri> (uncaught exceptions could be said to be a kind of bugs, but not the kind that launches missiles)
16:35:08 <donri> ocharles: it is sweet!
16:35:27 <ocharles> i wonder where it uses data-lens
16:35:31 <donri> internally
16:35:46 <ocharles> obviously
16:35:49 <ocharles> i just wondered how
16:35:53 <ocharles> pcapriotti: great work!
16:36:29 <ocharles> ah, to provide the functions for (&) combinators, it seems
16:36:46 <donri> & is just >>>
16:37:07 <donri> i just use . myself, duno if ordering matters for something but works for me
16:37:18 * ocharles nods
16:37:30 <ocharles> & is a little nicer to read as combining properties
16:37:41 <ocharles> more edslish
16:37:46 <donri> well i have . shown as cute unicode in vim
16:37:58 <ocharles> :)
16:39:40 <ocharles> grumble. haddock, y u no syntax highlight?
16:40:04 <pcapriotti> ocharles: I use it mostly internally, and to make those Builder combinators easier to write
16:40:33 <pcapriotti> and thanks :)
16:40:50 <startling> donri, I assume ◦?
16:42:15 <donri> startling: ∘
16:42:26 <donri> .u ∘
16:42:45 <donri> too many bots ^_^
16:42:57 <startling> heh
16:43:29 <donri> https://github.com/dag/vim2hs if you want it yourself
16:44:40 <startling> has anyone written a less-ncursesy console interface library for haskell?
16:45:06 <donri> define less-ncursesy
16:45:31 <monochrom> does vty count?
16:46:22 <parcs`> there's ansi-terminal for simple things
16:50:26 <startling> defining color pairs for 256-color terminals is a huge pain
16:51:00 <startling> (because you don't need to for most 256-color terminals, but ncurses makes you)
16:51:31 <startling> also, taking colors as r-g-b triplets where each is 0-1000 is ridiculous
16:52:10 <startling> the keyhandling has always been annoying, too, though maybe hscurses fixes that
16:52:40 <startling> meh, I can just emit escapes myself I guess.
16:53:03 <startling> monochrom: vty looks nice, actually. thanks
16:55:53 <luke__> I have sort of flame question.. :) I'm writing webapp which is very db centric. Since it's my own project I can choose whatever techology I want, so now I have to choose web framework and I'm considering happstack, yesod, snap. As I mentioned the app will be very db centric and I need NoSQL store  like MongoDB. I've read that Snap has nice MongoDB support but I noticed that Happstack offers it's own called "acid-state". Any comments ho
16:55:53 <luke__> w it comapres to MongoDB and well, if I want to migrate my data from acid-state, how hard it would be?
16:57:09 <stepcut> luke__: migrating away from acid state is both easy and hard. The easy part is that you have all your data accessible as a Haskell data type.. so you just have to write it into the new DB. But, you also have to modify all your code to switch to the new db instead of using acid-state as well..
16:57:20 <monochrom> I tend to think that db-centric means YesSQL
16:57:50 <donri> luke__: acid-state is faster than mongodb and won't crap on your data :)
16:57:58 * donri baseless-assertion.jpg
16:58:40 <stepcut> luke__: how big is your data set?
16:58:47 <luke__> stepcut, I have my data now described as Haskell data types...
16:59:08 <luke__> monochrom, not quite, this type of data is really nosql
16:59:12 <stepcut> luke__: that should make it easy to put into acid-state then
16:59:36 <stepcut> luke__: you just need derive some SafeCopy instances.
17:00:09 <luke__> stepcut, it's not that big, maximum 10^6 entities but at app start it'll be about 10k I think
17:00:10 <mightybyte> luke__: I've read a lot of concerning reports about mongoDB recently
17:00:37 <luke__> so there'll be time to switch if something fails :)
17:00:47 <luke__> mightybyte, like what? link or sth pls :)
17:01:12 <stepcut> luke__: the biggest concern with acid-state is that it is going to store everything in RAM (for the time being anyway), so you need to have some idea of you are going to have enough RAM or not. A good place to start learning about acid-state is here, http://www.happstack.com/docs/crashcourse/AcidState.html#acid_state
17:02:30 <mightybyte> http://blog.engineering.kiip.me/post/20988881092/a-year-with-mongodb
17:02:38 <luke__> stepcut, thanks a lot.. storing data in RAM is quite good in my case because I need to process data quickly... but I'll have to calculate max size :)
17:02:39 <mightybyte> http://schmichael.com/files/schmongodb/Scaling%20with%20MongoDB%20(with%20notes).pdf
17:02:45 <mightybyte> http://www.zopyx.de/blog/goodbye-mongodb
17:03:30 <mightybyte> Snap also probably has the best acid-state support right now.
17:03:34 <stepcut> luke__: yeah.. the nice thing about acid-state is that it works natively with Haskell types, and your update/query functions are pure Haskell code. So.. you get all the power of Haskell in your types and query language
17:03:59 <stepcut> mightybyte: go on
17:04:06 <luke__> mightybyte, oh I thought that Happstack
17:04:13 <mightybyte> We have an acid-state snaplet.
17:04:25 <mightybyte> Drop-dead simple integration.
17:05:00 <stepcut> mightybyte: acid-state doesn't exactly require much integration in the first place..
17:05:25 <mightybyte> Ahh, that sounds a lot like an argument I recently made that you rebutted. :)
17:05:39 <stepcut> mightybyte: no. similar but different.
17:05:55 <mightybyte> I didn't say the same
17:06:18 <stepcut> mightybyte: i guess
17:06:38 <mightybyte> s/no/yes/ doesn't change your statement :P
17:06:59 <stepcut> whateve
17:07:30 <luke__> to be honest when I looked through available web frameworks, Snap happened to be the most interesting to me, but I must have missed the acid-state feature...
17:07:32 <mightybyte> Anyway, I'd stay away from mongo
17:07:37 <stepcut> luke__: acid-state came from Happstack and we still maintain it. Snap does have a little bit of glue code that makes it easier for people to use acid-state with the snaplets system.
17:08:01 <startling> I want to use the RawIO methods in GHC.IO.Device. where in the world do I get an FD?
17:08:07 <luke__> mightybyte, thanks that's valueable remark :)
17:08:33 <mightybyte> luke__: stepcut and the happstack guys advocate acid-state more, but I thought it was interesting enough to write a snaplet for it.
17:09:39 <startling> @hoogle FD
17:09:40 <lambdabot> System.Posix.Types Fd :: CInt -> Fd
17:09:40 <lambdabot> System.Posix.Types newtype Fd
17:09:40 <lambdabot> System.Event data FdKey
17:09:51 <startling> ^ are all the wrong thing, apparently
17:11:21 <luke__> so I'll have to investigate more into happstack and snap :)
17:12:57 <stepcut> luke__: I recommend the Happstack Crash Course, http://www.happstack.com/docs/crashcourse/index.html, for more investigation
17:13:19 <luke__> stepcut, thanks!
17:14:24 <luke__> anyway, that's a big relief that I can easily use my already coded haskell datatypes :)
17:17:18 <donri> pcapriotti: hope you don't mind my idea-dumping for optparse-applicative ;P
17:18:01 <pcapriotti> donri: of course not, keep them coming :)
17:19:08 <pcapriotti> I should look at CmdTheLine
17:20:57 <donri> i find your library more elegant, although cmdtheline does have some nice features
17:43:44 <test> lo?
17:44:02 <Axman6> 'lo
17:44:27 <test> How are you? Do you program for a living?
17:44:50 <Axman6> good, no
17:44:59 <Axman6> do you have any questions about haskell?
17:45:58 <test> What do you think is the most unique thing about Haskell?
17:46:14 <test> As opposed to Java or Python or something?
17:46:44 <Axman6> well, it's nothing at all like java or python...
17:47:21 <test> Yeah, kind of lame examples. Sorry.
17:47:30 <mauke> laziness + referential transparency
17:48:01 <raichoo> type system
17:48:29 <Axman6> buh bye...
17:55:57 <otters> @pl \(x,y) -> [x,y]
17:55:57 <lambdabot> uncurry ((. return) . (:))
17:58:18 <latro`a> @pl \(x,y,z) -> [x,y,z]
17:58:18 <lambdabot> (line 1, column 6):
17:58:18 <lambdabot> unexpected ","
17:58:18 <lambdabot> expecting letter or digit, operator or ")"
17:58:18 <lambdabot> ambiguous use of a non associative operator
17:58:27 <latro`a> um
17:58:28 <latro`a> what
17:58:36 <bytter> @pl \x y z -> [x, y, z]
17:58:37 <lambdabot> (. ((. return) . (:))) . (.) . (:)
17:58:47 <latro`a> that's not what I meant
17:58:48 <bytter> latro`a: you were using a tuple
17:58:53 <latro`a> I know
17:58:56 <latro`a> and you should be able to
17:59:01 <latro`a> you can pattern match against tuples
17:59:09 <bytter> :t (1, 2)
17:59:11 <lambdabot> forall t t1. (Num t, Num t1) => (t, t1)
17:59:13 <latro`a> as otters just did
17:59:15 <bytter> :t (1, 2, 3)
17:59:16 <lambdabot> forall t t1 t2. (Num t, Num t1, Num t2) => (t, t1, t2)
17:59:34 <bytter> :t \(x,y,z) -> [x,y,z]
17:59:36 <lambdabot> forall t. (t, t, t) -> [t]
17:59:57 <latro`a> so why won't it @pl
18:00:00 <latro`a> if it will :t
18:00:10 <bytter> prolly a bug :-\
18:00:22 <bytter> @pl (\(x,y,z) -> [x,y,z])
18:00:23 <lambdabot> (line 1, column 7):
18:00:23 <lambdabot> unexpected ","
18:00:23 <lambdabot> expecting letter or digit, operator or ")"
18:00:23 <lambdabot> ambiguous use of a non associative operator
18:00:24 <mauke> latro`a: because @pl doesn't know about triples
18:00:29 <latro`a> ah
18:00:36 <latro`a> ki'e
18:00:40 <mauke> what did you expect it to do anyway?
18:00:42 <latro`a> er
18:00:44 <latro`a> woops
18:00:55 <latro`a> meant to say thank you
18:01:00 <latro`a> and I didn't know
18:01:06 <latro`a> that was why I asked :p
18:01:16 <bnitka> @pl \x y z -> (x,y,z)
18:01:17 <lambdabot> (,,)
18:01:19 <bnitka> ^^
18:01:29 <mauke> patterns are essential
18:01:34 <latro`a> maybe it doesn't know about pattern matching against triples
18:01:46 <latro`a> @pl \((,,) x y z) -> [x,y,z]
18:01:46 <lambdabot> (line 1, column 4):
18:01:46 <lambdabot> unexpected ","
18:01:46 <lambdabot> expecting pattern
18:01:50 <latro`a> nope
18:01:54 <bnitka> @unpl (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,)
18:01:54 <latro`a> oh wait nvm
18:01:54 <lambdabot> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,)
18:01:55 <latro`a> derp
18:02:03 <latro`a> O.o
18:02:04 <latro`a> weird
18:02:09 <bnitka> @unpl (,,)
18:02:09 <lambdabot> (,,)
18:02:32 <bnitka> that's incorrectish
18:02:43 <mauke> pl doesn't do pattern matching
18:02:53 <bnitka> :t (,,,)
18:02:55 <lambdabot> forall a b c d. a -> b -> c -> d -> (a, b, c, d)
18:02:58 <bnitka> :t (,,,,,,,,,,,,,,,,,,,,,)
18:02:59 <lambdabot> forall a b c d e f g h i j k l m n o p q r s t u v. a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> (a, b, c, d, e, f, g, h, i, j, k, l,
18:02:59 <lambdabot> m, n, o, p, q, r, s, t, u, v)
18:03:01 <bnitka> fun
18:03:08 <bnitka> :t (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,)
18:03:10 <lambdabot> forall a b c d e f g h i j k l m n o p q r s t u v w x y z t28 t29 t30 t31 t32 t33 t34 t35 t36 t37 t38 t39 t40 t41 t42 t43 t44 t45 t46 t47 t48 t49 t50 t51 t52 t53 t54 t55 t56 t57 t58 t59 t60. a -> b
18:03:10 <lambdabot> -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> t28 -> t29 -> t30 -> t31 -> t32 -> t33 -> t34 -> t35 -> t36 -> t37 -> t38 ->
18:03:10 <lambdabot>  t39 -> t40 -> t41 -> t42 -> t43 -> t44 -> t45 -> t46 -> t47 -> t48 -> t49 -> t50 -> t51 -> t52 -> t53 -> t54 -> t55 -> t56 -> t57 -> t58 -> t59 -> t60 -> (a, b, c, d, e, f, g, h, i, j, k, l, m, n,
18:03:10 <lambdabot> o, p, q, r, s, t, u, v, w, x, y, z, t28, t29, t30, t31, t32, t33, t34, t35, t36, t37, t38, t39, t40, t41, t42, t43, t44, t45, t46, t47, t48, t49, t50, t51, t52, t53, t54, t55, t56, t57, t58, t59,
18:03:10 <lambdabot> t60)
18:03:13 <bnitka> sry
18:21:58 <latro`a> hm, what happened to t27
18:23:06 <ski> latro`a : i think that's `z'
18:24:24 <latro`a> um
18:24:25 <latro`a> no?
18:24:30 <latro`a> the alphabet has 26 letters
18:25:37 <shachaf> latro`a: That doesn't contradict what ski said.
18:25:49 <shachaf> (You might sk "what happened to t1".)
18:27:55 <patzo> i've been going around in circles trying to find out what package i'm missing for importing Data.String.Utils  (to use the startswith function)
18:27:58 <otters> man, you can't really forward declare functions in Haskell, can you?
18:28:37 <patzo> what's the general way to find what package contains the module i'm after?
18:28:43 <acowley> otters: why would you want to?
18:28:49 <acowley> patzo: hayoo
18:29:05 <otters> acowley: at first, it was because I wanted to remove a warning I was getting using TH, but then I realized I can generate the signature itself with TH too
18:30:48 <ski> latro`a : i dunno ..
18:31:42 <latro`a> you're right, any of the first 27 could be missing
18:31:44 <latro`a> but one of them is
18:34:04 <latro`a> does a where outside a do block have the scope of the variables in the do block?
18:34:16 <ski> no
18:34:19 <latro`a> damn
18:34:23 <ski> use `let'
18:34:27 <latro`a> didn't think so, but figured I'd make sure
18:34:32 <ski> or pass the variables of interest as parameters
18:34:47 <ski> (or use implicit parameters, i guess)
18:35:13 <latro`a> probably cleaner to just use a lambda here
18:35:34 <ski> could be .. what's your situation ?
18:36:48 <ski> (if it's `mapM_' or `mapM', then yes a `forM_' or a `forM' with a lambda is often nicer)
18:40:10 <latro`a> ec
18:40:11 <latro`a> *sec
18:42:35 <hpaste> latro`a pasted “continue” at http://hpaste.org/71869
18:42:53 <latro`a> actually, sec
18:43:02 <hpaste> latro`a annotated “continue” with “continue (annotation)” at http://hpaste.org/71869#a71870
18:43:06 <latro`a> better
18:43:52 <ski>   continue board = either printAndRetry handler . makeMove board =<< getMove
18:43:54 <latro`a> I'm converting some code that uses CPS-state to code that uses StateT
18:43:59 <ski> ^ may or may not be nicer
18:44:06 <latro`a> yeah I considered that
18:44:12 <latro`a> am on the fence about which I prefer
18:45:22 * ski would probably not use `$' here
18:45:51 <latro`a> might be clearer, yeah
18:45:55 <latro`a> but still
18:46:03 <latro`a> I don't think there's a better way to deal with the lambda in the last line
18:46:05 <latro`a> in StateT
18:46:24 <latro`a> I am also considering not doing this, because this is getting ugly pretty fast :/
18:47:42 <latro`a> the CPS code that I have now does work, I just expected it to be cleaner with State
18:48:05 <ski> i'm not sure where CPS comes into this
18:48:24 <ski> also, i would probably consider writing a plain `case' on the `Either'
18:49:02 <latro`a> I did that at one point, which would probably be cleaner in the StateT+either case
18:49:13 <ski> (perhaps not worth it in this case, but in more complicated cases it can be clearer than `either')
18:49:16 <latro`a> and the way I've been doing state is basically with continuation passing style
18:49:28 <latro`a> I have a few Board -> IO () functions
18:49:33 <ski> hm, are you sure you don't mean accumulator/state -passing-style ?
18:49:57 <latro`a> might be that, but I think this is technically still CPS
18:50:06 <lgandras>  /msg NickServ VERIFY REGISTER lgandras jgoaagblbatt
18:50:07 <latro`a> it just doesn't tend to get called that because there's no callCC
18:50:13 <latro`a> well that sucks lgandras
18:50:23 <lgandras> really
18:51:18 <latro`a> eh, I guess I'll hpaste what I have, though it calls a bunch of other stuff
18:51:23 <ski> lgandras : if qwebirc has some kind of server window/tab, you could make a habit of always writing password-related stuff in that
18:52:47 <lgandras> yes, sorry. totally newbie in this stuff. i think i got it.
18:53:58 <ski> latro`a : well, passing around a state in an argument is different from passing around a continuation in an argument
18:53:58 <ski> (though the latter can be seen as an instance of the former)
18:53:58 <ski> (hence we can talk about the "control state" of a computation)
18:55:48 <latro`a> eh, I may be abusing terminology, but when almost every function ends with a call to another with the output, iirc that's technically CPS
18:55:50 <latro`a> anyway
18:55:51 <latro`a> that's semantics
18:55:58 <latro`a> http://pastebin.com/yfeUixHF
18:56:00 <mauke> The paste yfeUixHF has been copied to http://hpaste.org/71871
18:56:00 <latro`a> is what I have now
18:56:14 <latro`a> I should probably annotate the types of some of the other functions, but eh
18:56:52 <latro`a> askyn and askyn' may be overkill, also
18:58:37 <latro`a> gah the bind version of continue got reverted
18:59:11 <hpaste> latro`a annotated “pastebin.com/yfeUixHF” with “continue no-do” at http://hpaste.org/71871#a71872
19:00:50 <latro`a> I dunno, maybe just leave this as it is
19:00:55 <latro`a> ?
19:05:11 <startling> hi, any idea where I can find an instance of IODevice? These docs: http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/GHC-IO-Device.html say FD (from System.Posix.Internals I guess?) is one, but I can get No instance for (IODevice FD)
19:05:44 <latro`a> ski?
19:06:56 <monochrom> FD is probably not exposed at all
19:07:50 <startling> so, how am I supposed to use the GHC.IO.Device methods? I *really* want setRaw
19:08:00 <geekosaur> this sounds a lot like you are trying to use stuff that you can't use without hacking source to internal modules (which may mean building a custom ghc with a custom runtime)
19:08:16 <monochrom> I am not thinking that you are supposed to use it
19:08:34 <otters> > maxBound :: Int8
19:08:35 <lambdabot>   127
19:08:39 <startling> well, I'd like to put a terminal in raw mode
19:09:06 <geekosaur> System.Posix.Terminal
19:09:39 <ski> latro`a : hm, was looking at "A review of the 1977 Turing Award Lecture by John Backus" by Edsger Wybe Dijkstra at <http://www.cs.utexas.edu/~EWD/transcriptions/EWD06xx/EWD692.html> ..
19:10:13 <geekosaur> note that "raw mode" has not actually existed for many years and what ghc may mean by it is therefore not necessarily what you mean by it
19:10:26 <ski> latro`a : no continuations in sight there
19:10:40 <latro`a> hm, k
19:10:45 <latro`a> maybe I misunderstand the term then
19:10:54 <latro`a> but still, do you think it's worth it to StateT-ify this?
19:11:03 <nalssi> Is there a haskell-platform binary for netbsd amd64?
19:11:07 <startling> geekosaur, alright
19:11:54 <geekosaur> so you want the routines in S.P.Terminal which let you specify exactly what you want instead ofg whatever settings ghc hq thought appropriate for ghci, or whatever
19:12:14 <ski> latro`a : hm, afaics, you're only passing `Board' onwards, never returning it
19:12:22 <startling> geekosaur: ctrl-f raw doesn't seem to find anything?
19:12:28 <latro`a> that is correct, ski
19:12:31 <geekosaur> (if indeed they did; not sure raw mode exists, now that it uses haskeline)
19:12:39 <latro`a> which is why I was thinking of this as CPS
19:12:48 <geekosaur> <geekosaur> note that "raw mode" has not actually existed for many years and what ghc may mean by it is therefore not necessarily what you mean by it
19:12:52 <latro`a> I can modify this to not do that
19:12:59 <ski> meaning that either `StateT Board IO' or `ReaderT Board IO' would work
19:13:07 <geekosaur> yes, I know I';m talking to myself when I make useless niuses like that
19:13:14 <geekosaur> that can't possibly apply to you
19:13:18 <latro`a> um
19:13:21 <startling> geekosaur:  k
19:13:22 <startling> so, how do I make it so a terminal immediately makes keypresses available to me?
19:13:24 <latro`a> the Board does get changed, ski
19:13:37 <latro`a> but maybe I misunderstand how Reader would work here
19:13:44 <parcs`> > let id -> x = 5 in x
19:13:45 <lambdabot>   <no location info>: parse error on input `->'
19:13:48 <startling> I'm doing what would normally be done with a curses module but emitting console escapes myself
19:14:06 <mauke> isn't that what ghc does automatically when you disable buffering on stdin?
19:14:10 <parcs`> > let { id -> x = 5 } in x
19:14:11 <lambdabot>   <no location info>: parse error on input `->'
19:14:21 <startling> mauke: is it? thanks
19:14:29 <geekosaur> startling, find a description of the unix / posix terminal model.  get current stetings, probably clear icanon, set vmin = 1, vtime = 0, set new settings.  save the original settigs and set them back before exit
19:14:46 <mauke> but try hSetBuffering first
19:14:57 <geekosaur> mauke, there are two kinds of buffers in play.  hSetBuffering is not the tty buffer
19:15:05 <mauke> geekosaur: [citation needed]
19:15:06 <geekosaur> it is the filehandle buffer
19:15:35 <geekosaur> mauke: ... oh dear, you need a citation for the difference between a filehandle and a tty driver?  I suggest any basic unix text
19:15:45 <mauke> geekosaur: no, I need a citation on what the ghc runtime does
19:15:54 <mauke> we're not in kansas anymore
19:16:04 <mauke> the bets are now: off
19:16:04 <geekosaur> I sincerely hope they did not conflate them
19:16:20 <mauke> @hoogle hSetEcho
19:16:20 <lambdabot> System.IO hSetEcho :: Handle -> Bool -> IO ()
19:16:21 <lambdabot> GHC.IO.Handle hSetEcho :: Handle -> Bool -> IO ()
19:16:25 <mauke> yeah, good luck with that
19:17:17 <geekosaur> never mind, then; mauke apparently believes ghc hq likes to do things that needlessly complicate things for everyoe
19:17:18 <ski> latro`a : there is `local' for locally changing an environment -- since you never return the board, it doesn't matter that it's only a local change
19:17:29 <geekosaur> so now yu get to go study ghc's runtime to see what it does
19:17:30 <latro`a> ah
19:18:14 <ski> latro`a : anyway, i'm not claiming that `ReaderT' would necessarily be nicer than `StateT' here (i don't know, haven't tried. though i suspect that either it's about the same, or `StateT' is nicer), only that it's *possible*
19:18:17 <geekosaur> (note that if that;s te case it's hard to see what point System.Posix.Terminal has, among other things, but I guess we assume it's largely pointless by design)
19:18:24 <latro`a> ah ok
19:18:49 <latro`a> I was gonna say StateT seemed natural, since it's not hard to convert this to Board -> (IO (),Board) with an "undoing" function that resembles StateT's >>=
19:18:55 <latro`a> (ish)
19:19:07 <latro`a> er, "untupling"
19:19:25 <ski> latro`a : in any case, i think this is near the border of `StateT' (or `ReaderT' as the case may be) being nicer than plain explicit accumulator passing as you're currently doing
19:20:05 <latro`a> as you saw earlier I started translating a little to StateT and had a lot of lift
19:20:17 <latro`a> as in, more functions than not wound up lifted
19:20:38 <ski> (whether the border is <- way or -> way is up to individual judgement and taste, i think)
19:20:43 <latro`a> right
19:20:59 <succ-quuux> latro`a: MonadIO?
19:21:41 <latro`a> which instance of it...?
19:22:01 <ski> latro`a : well, i think you meant `Board -> IO ((),Board)' (or better `Board -> IO Board' or `StateT Board IO ()') rather than `Board -> (IO (),Board)'
19:22:08 <ski> @unmtl StateT Board IO ()
19:22:09 <lambdabot> Board -> IO ((), Board)
19:22:20 <latro`a> no, I used the word resemble on purpose
19:22:28 <latro`a> getting to IO ((),Board) actually takes a little bit of work
19:22:35 <latro`a> from here
19:23:09 <ski> quuuux : `MonadIO' would only change `lift' to `liftIO' here
19:23:39 <ski> latro`a : hm, ok
19:24:00 <ski> well in `Board -> (IO (),Board)', the resulting `Board' can't depend on user input
19:24:15 <latro`a> oh right, duh
19:24:21 <latro`a> nvm
19:24:27 <latro`a> yeah that won't work
19:25:16 <latro`a> I'm a little surprised that neither of ReaderT and WriterT are isomorphic to StateT s m ()
19:25:22 <latro`a> not sure why that surprises me
19:25:40 <latro`a> but I just thought of StateT as combining their features, and then StateT s m () takes one away
19:29:41 <ski> latro`a : well, all three are different things
19:30:26 <ski> (environment and output can be simulated using state, though, as is commonly done in imperative programming)
19:31:15 <latro`a> at some point I thought I saw something that said that in a categorical sense State is formed from the adjunction between Reader and Writer, or something similar
19:31:38 <ski> @let repeatM :: Monad m => m a -> m [a]; repeatM act = liftM2 (:) act (repeatM act)
19:31:39 <lambdabot>  Defined.
19:32:42 <ski> > execWriter (repeatM (tell ["error"]))
19:32:45 <lambdabot>  Terminated
19:32:56 <ski> er
19:32:57 <ski> > execWriter (repeatM (tell ["error"]))
19:32:59 <lambdabot>   ["error","error","error","error","error","error","error","error","error","e...
19:33:22 <latro`a> why were those different
19:33:46 <ski> probably someone was running something at the same time in lambdabot, and the time ran out
19:33:46 <quuuux> lambdabot can sporadically solve the halting problem. The first time, it was able to see that it would fail to terminate
19:33:49 <ski> @help run
19:33:50 <lambdabot> run <expr>. You have Haskell, 3 seconds and no IO. Go nuts!
19:33:54 <geekosaur> heh
19:33:55 <ski> > (`execState` []) (repeatM (modify (++ ["error"])))
19:34:00 <lambdabot>   mueval-core: Time limit exceeded
19:34:00 <lambdabot>  mueval: ExitFailure 1
19:34:00 <lambdabot>  mueval: Prelude.un...
19:34:09 <ski> > (`execState` []) (repeatM (modify (["error"] ++)))  -- adding to the front instead of the back
19:34:13 <lambdabot>   mueval-core: Time limit exceeded
19:34:34 <ski> > execWriter (replicateM 4 (tell ["error"]))
19:34:35 <lambdabot>   ["error","error","error","error"]
19:34:44 <ski> > (`execState` []) (replicateM (modify (++ ["error"])))
19:34:46 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
19:34:46 <lambdabot>         against inferred type ...
19:34:50 <ski> > (`execState` []) (replicateM 4 (modify (++ ["error"])))
19:34:52 <lambdabot>   ["error","error","error","error"]
19:35:25 <ski> latro`a : the above examples were meant to show that, while output can be simulated by state, in the case of an infinite computation, the simulation breaks down
19:35:58 <latro`a> ah
19:36:28 <ski> the `execWriter (...)' case can present the outputs/logs from the first actions even though it hasn't seen the end of all the actions yet
19:37:09 <ski> in the state example, it has to execute it 'til the end before it can inspect the final state (including all the log messages)
19:38:05 <ski> of course, if we used, say, `hPutStrLn logFileHandle' instead, in `IO', it could produce partial results (iow be incremental instead of bulky)
19:38:52 <ski> but the point is that with general state, previous "outputs" could always be retracted later, which is why it has to wait 'til the end
19:39:16 <bartek> Am I missing something or is $ basically syntax sugar?
19:39:19 <ski> so, a more powerful/expressive model here means the implementation can't be as efficient
19:39:31 <ski> bartek : it is mostly used as syntax sugar, yes
19:39:39 <ski> it is an oardinary infix operator, though
19:39:41 <ski> @src $
19:39:41 <lambdabot> f $ x = f x
19:39:55 <ski>   infixr 0 $
19:40:08 <ski> (some people argue it ought to be `infixl' instead)
19:40:24 <shachaf> Let's make it "infix" as a compromise!
19:40:39 <quuuux> the infixl version is €
19:40:46 <quuuux> as for £, who knows?
19:41:43 <bartek> ski: interesting, thanks
19:43:01 <quuuux> bartek: on a serious note, you need a way to spell application to do something like, say, map ($ 3) [(+ 2), negate]. It's definitely mostly used as a way of not writing brackets though
19:43:57 * ski mostly uses it in the form `... $ \.. -> ...', because apparently it needs an operator there to parse
19:44:32 <ski> (why, i don't know)
19:44:52 <latro`a> blah indecisive about whether I want to do this....I mainly want to try it because I think I'll understand transformers better if I make use of them, but from what I saw starting, I was just doing board <- get every time anyway
19:44:55 <elliott__> (f \x -> y) parses sort of weird
19:45:28 <quuuux> I think that just looks weird because we're not used to it
19:49:20 <YayMe> Attoparsec
19:49:28 <YayMe> help?
19:49:37 <YayMe> Samples?
19:50:13 <YayMe> I can't find any, and this takeWhile function is killin' me just looking at it, it takes a predicate but it doesn't take any value to apply that predicate too
19:50:30 <YayMe> and it returns a value, not a function to return the predicate to
19:50:44 <elliott__> it filters the parser input through the predicate
19:50:47 <otters> yeah, it creates a parser action
19:50:55 <YayMe> it creates a parser action?
19:50:57 <elliott__> i.e. it creates a parser that takes from the input while the predicate holds
19:50:59 <YayMe> It looks like it creates a value
19:51:05 <elliott__> yes, actions are values.
19:51:12 <elliott__> (IO ()) is a value, (Parser String) is a value, etc.
19:51:16 <YayMe> I know that
19:51:20 <YayMe> but it returns Parser Text
19:51:25 <otters> right
19:51:28 <YayMe> how do I give Parser Text input?
19:51:30 <otters> a parser that filters through that predicate
19:51:40 <elliott__> YayMe: by using the functions in the attoparsec module
19:51:49 <elliott__> http://hackage.haskell.org/packages/archive/attoparsec/0.10.2.0/doc/html/Data-Attoparsec-Text.html#g:5
19:51:58 <elliott__> but you would only want to do that at the end of the parsing process.
19:52:02 <ski> you'll need to use some kind of function similar to `parse :: Parser a -> String -> Either ParseError a'
19:52:13 <elliott__> that is to say, you won't want to apply those directly to (takeWhile p).
19:52:21 <ski> and what elliott__ says
19:52:22 <elliott__> you'll want to build a larger parser out of smaller components like that, and then use parse on it
19:52:40 <ski>   parse :: Parser a -> Text -> Result a  -- in this case, apparently
19:52:58 <elliott__> parseOnly probably more relevant for the simpler usecase
19:53:03 <elliott__> but yes
19:53:06 <tswett> Whelp, I just discovered that Django doesn't have a good way to prevent threads from interfering with each other.  This makes me wonder what Haskell has to offer in the way of web frameworks.
19:53:13 <YayMe> ok, parseOnly, how do I give parseOnly input?
19:53:39 <elliott__> parseOnly :: Parser a -> Text -> Either String a
19:53:52 <YayMe> Ohh
19:53:53 <YayMe> I see
19:53:54 <YayMe> soo
19:54:09 <elliott__> tswett: the main ones are Yesod, Snap and Happstack (permute this list in random order mentally).
19:54:17 <elliott__> (though I wonder what "prevent threads from interfering with each other" means.)
19:54:32 <otters> tswett: I'm making a web framework too :P
19:54:37 <elliott__> http://happstack.com/ http://www.yesodweb.com/ http://snapframework.com/
19:54:41 <donri> @where web
19:54:41 <lambdabot> http://happstack.com/ http://snapframework.com/ http://yesodweb.com/
19:54:43 <ski> YayMe : so, have you already built your complete parser, or are you wondering how to best to that ?
19:54:47 <YayMe> parseOnly (takeWhile1 ((==)'f') (ByteString.fromString "foo")
19:54:56 <donri> aww lambdabot y u no persist @where+ changes
19:55:05 <elliott__> YayMe: if you are only doing that, why bother using attoparsec?
19:55:11 <elliott__> you don't need it for such a simple text processing task.
19:55:21 <YayMe> ski: I am merely trying to learn how to use attoparsec, I see parsing as a large value in anything I'm trying to do in haskell
19:55:24 <donri> @where+ web #happs : http://happstack.com/ | #snapframework : http://snapframework.com/ | #yesod : http://yesodweb.com/
19:55:24 <lambdabot> Okay.
19:55:24 <ski> donri ?
19:55:31 <elliott__> for instance, see http://hackage.haskell.org/packages/archive/text/0.11.2.2/doc/html/Data-Text.html#v:takeWhile
19:55:35 <donri> i made that edit some days ago
19:55:40 <tswett> elliott__: suppose a guy attempts to make two purchases simultaneously.  What the code does is "check to see if the guy has enough money to pay for it; if so, debit his account and record the purchase".
19:55:47 <YayMe> elliott__: will my example work? does it make sense
19:55:57 <tswett> It's possible that both threads will check to see if the guy has enough money, and then both threads will debit his account.
19:56:01 <elliott__> it looks reasonable, except that you are passing a ByteString, not Text.
19:56:12 <YayMe> would it return Left String?
19:56:13 <elliott__> ByteString is a sequence of bytes, Text is a sequence of Unicode codepoints, not the same thing, but Text has functions to go from a String
19:56:27 <tswett> If that happens, and he has $15 in his account, he might end up buying two $10 items, ending up with $-5 in his account.
19:56:33 <YayMe> elliott__: Right, I meant to use pack, I keep getting the libraries mixed up
19:56:40 <tswett> (Or is that -$5?  Darn currency symbols.)
19:57:50 <Cale> It makes no sense that we write the $ before the number when we pronounce it after.
19:57:58 <elliott__> tswett: that doesn't seem like anything to do with django, really, so much as database transactions and so on or, at least, general thread synchronisation which would be more of a python issue than django ... buuut this is off-topic and I'll hardly discourage using Haskell anyway
19:58:08 <YayMe> I'm so proud of myself, I learned the Y combinator yesterday, and while I highly doubt my ability to implement it in a strict fashion, I get the point, yay me :)
19:58:44 <Cale> :t InR
19:58:46 <lambdabot> forall a. (Rec a -> a) -> Rec a
19:58:48 <elliott__> tswett: (but, of course, the python party line, if such an issue really has no solution (which I doubt) would be that you shouldn't be using threads in the first place... they're not exactly fun in python. or most languages, really)
19:58:49 <Cale> :t outR
19:58:51 <lambdabot> forall a. Rec a -> Rec a -> a
19:58:57 <shachaf> @src Rec
19:58:58 <lambdabot> newtype Rec a = InR { outR :: Rec a -> a }
19:59:07 <YayMe> Now to learn attoparsec... Then I can write a parser that does something fun, I'm thinking about as a project writing a super simple scheme REPL in haskell to kill 2 birds with one stone; learn scheme and attoparsec.
19:59:15 <YayMe> Would that be an appropriate use of attoparsec?
19:59:21 <YayMe> Granted it would be a fake repl
19:59:30 <tswett> elliott__: yeah, that sounds true.  The problem is, Django is nicest when you write everything in Python, but it seems it's not really possible to write transactional stuff in pure Python; you have to bring SQL in.
20:00:36 <donri> tswett: zodb!
20:00:39 <YayMe> tswett: Can't use ws-atomic transactions?
20:00:57 <elliott__> well, the leaky abstraction of an ORM is never going to work for everything, and I hear Django's is not the most powerful... but I still might expect it to have some solution to a scenario as simple as this. anyway, still as off-topic, so I'll quiet :)
20:01:18 <ski> Cale : oughtn't that be named `Santa' or `Loeb' ?
20:01:35 <tswett> donri: hm.  ZODB looks pretty sexy.
20:01:52 <Cale> > let y = \f -> (\x -> f (outR x x)) (InR (\x -> f (outR x x))) in y (\fac n -> if n == 0 then 1 else n * fac (n-1)) 10
20:01:54 <lambdabot>   3628800
20:02:01 <tswett> Can I *do* Django with ZODB?
20:02:25 <donri> there's some django-zodb or something, duno how well it integrates
20:02:33 <tswett> Hm.  I can use Zope with ZODB.
20:02:36 <donri> probably doesn't work with the admin etc
20:02:47 <tswett> (I'd *better* be able to use Zope with ZODB.)
20:02:58 <donri> you don't really want zope though, probably pyramid instead
20:03:20 <donri> or my flask-zodb (and please take over maintainership of it as i don't do python anymore ;))
20:03:39 <tswett> Pyramid looks like it could be sexy.
20:04:00 <donri> for python, it is
20:04:17 <donri> traversal might be the closest thing to type-safe routing you can get in python
20:04:19 <elliott__> durus is quite neat, it is an object database + STM
20:04:20 <YayMe> tswett: the IPC would hurt your performance metrics, but python should be able to do pure transactions with it
20:04:23 <elliott__> too bad it's in python
20:29:29 <jollyrancher> hi guys
20:30:19 <jollyrancher> i've been breaking my head over recursive functions in pattern matches: ie:
20:30:22 <tswett> So what does Yesod use for data storage?
20:30:29 <tswett> Hi, jollyrancher.
20:30:56 <shachaf> tswett: Whatever you want it to.
20:31:47 <jollyrancher> reverse' [] = []          reverse' (x:xs) = reverse' xs ++ [x]
20:32:24 <jollyrancher> the thing that I don't undertand is where  its concatenating the discarded list in order to return it in reverse order :S
20:32:34 <shachaf> "discarded list"?
20:33:13 <tswett> jollyrancher: well, I think you'd agree that reverse [1,2,3,4] = [4,3,2,1], and reverse [1,2,3] = [3,2,1].
20:33:15 <jollyrancher> yes,  I was told that when you do x:xs it discards the list one element at a time
20:33:30 <jollyrancher> yes
20:33:36 <tswett> Uh, and that reverse [2,3,4] = [4,3,2].
20:33:42 <jollyrancher> right
20:33:52 <shachaf> jollyrancher: It's not really "discard"ing.
20:34:02 <tswett> So it happens that reverse [1,2,3,4] = reverse [4,3,2] ++ [1].  Right?
20:34:06 <tswett> Erm.
20:34:18 <tswett> That reverse [1,2,3,4] = reverse [2,3,4] ++ [1].
20:34:52 <tswett> So the definition seems to work, at least in this case.
20:35:18 <Axman6> jollyrancher: it's giving names to the first element of the list, and the tail of the list. in the recursive call, if the tail was also a non-empty list, then the recursive call's x will be the second element of the list etc.
20:35:19 <shachaf> jollyrancher: Do you know that [1,2,3,4] is another way of writing 1:[2,3,4]?
20:35:32 <Axman6> > let f (x:xs) = (x,xs) in  f [1,2,3]
20:35:34 <lambdabot>   (1,[2,3])
20:36:05 <jollyrancher> shachaf, yes
20:39:04 <jollyrancher> hmm, i'm trying to visualize how that function does it in steps,  maybe this is an imperative programming habit
20:41:52 <quuuux> jollyrancher: are you comfortable with other recursive definitions? Like, say, sum [] = 0; sum (x:xs) = x + sum xs
20:42:07 <tswett> jollyrancher: there's a web page out there somewhere that shows you exactly how a Haskell expression is evaluated.
20:42:19 <tswett> I don't remember where it is, though.  Let me try to find it.
20:44:25 <slack1256> jollyrancher: are you sure you don't want to load a function in ghci and use the ':step' command?
20:44:25 <tswett> jollyrancher: give this a try: http://bm380.user.srcf.net/cgi-bin/stepeval.cgi
20:44:42 <jollyrancher> quuuux, i guess so, that one will add the head to the tail recursively until ?? hey? if nothing gets discarded why are []'s used?
20:44:53 <jollyrancher> an empty list means it got emptied right?
20:45:07 <tswett> Wait, maybe the :step command is better than what I linked?
20:45:28 <tswett> jollyrancher: type "let reverse' [] = []; reverse' (x:xs) = reverse' xs ++ [x] in reverse' [1,2,3,4]" into the thing I linked you.
20:46:03 <slack1256> tswett: well to me the brute aproach of ':step' in ghci revealed some thing
20:46:18 <tswett> slack1256: I'm not familiar with :step; how did you invoke it?
20:46:19 <slack1256> but if you want real information you need to put the break points yourself
20:46:36 <slack1256> let me put it in a hpaste, wait a sec
20:46:56 <jollyrancher> tswett! wow! this is exactly what i neeed, thanks!
20:47:06 <tswett> You're welcome.
20:47:15 <Cale> Defining reverse like tswett just did is really inefficient though, because (xs ++ ys) takes O(length xs) steps to reduce
20:47:38 <tswett> Yeah, you can tell that by the confusing useless stuff from step 10 on.
20:48:24 <quuuux> CGI web applications: the next frontier for profiling Haskell code
20:49:26 <tswett> Mmkay.  I'm trying to install yesod-platform using cabal-install 0.10.2, but it says, 'cabal: Couldn't read cabal file "HUnit/1.2.5.0/HUnit.cabal"'
20:50:48 <jollyrancher> slack1256, I think I will try :step now
20:50:57 <slack1256> tswett: well GHC-manual has a better example that the one I could provide
20:50:59 <slack1256> http://www.haskell.org/ghc/docs/7.2.2/html/users_guide/ghci-debugger.html
20:51:38 <slack1256> the idea is to set 'break lines' and inspect the variables in that moment
20:52:26 <slack1256> although isn't as good as that eval.cgi, that let's you workout as if it were algebra.
20:54:37 <tswett> This one mailing list post says that upgrading to Cabal-1.10.2.0 should fix the problem.  How do I do that?
20:55:11 <slack1256> tswett: in which platform are you?
20:55:32 <tswett> My operating system is OS X.
20:57:24 <slack1256> mm in archlinux the cabal version installed is 1.14.0. I guess that you already tried do a 'cabal install cabal'
20:57:41 <tswett> That just gives me the same error.
20:57:47 <slack1256> although I don't think is a good idea to install a different cabal that the one that came with the haskell-plataform
20:57:57 <luite> cabal install cabal-install-0.14.0 is what you can try
20:58:17 <luite> tswett: do you have the 32 or 64 bit platform?
21:00:19 <tswett> luite: that command still gives me the same error.
21:00:40 <tswett> And, I'm not sure.  I'm guessing the 64-bit one, since this is a 64-bit machine, but I don't actually remember how I installed the platform.
21:00:56 <luite> hmm, the 64 bit platform will give you problems with foreign libs in ghci
21:01:28 <luite> and since yesod devel depends on ghci (actually runhaskell), it will likely crash if you use a database
21:02:07 <tswett> I see.
21:02:48 <jollyrancher> http://bm380.user.srcf.net/cgi-bin/stepeval.cgi?expr=let+reverse%27+[]+%3D+[]%3B+reverse%27+%28x%3Axs%29+%3D+reverse%27+xs+%2B%2B+[x]+in+reverse%27+[1%2C2%2C3] i'm looking at that and i'm scratching my head,  why so many steps? is that really how haskell evaluates that function or is there redundant info?
21:03:25 <tswett> Well, the interpreter or compiler is probably going to take a lot of shortcuts.
21:04:32 <luite> tswett: try removing ~/.cabal/packages/hackage.haskell.org
21:04:36 <luite> and then cabal update again
21:05:35 <tswett> luite: ~/.cabal/packages doesn't exist.
21:06:07 <tswett> jollyrancher: now, are you talking about the stuff before step 8, or the stuff after step 8?
21:06:33 <luite> tswett: hm, that's interesting, perhaps it was in a different dir before 0.14?
21:06:52 <tswett> ~/.cabal only contains two files, config and config.platform.
21:07:22 <luite> hmm, if you run cabal update, where does it write its stuff?
21:08:29 <tswett> ~/Library/Haskell/repo-cache/hackage.haskell.org might be what I'm looking for.
21:09:39 <jollyrancher> tswett, why does it show the full declarations on 1-7 and not after 7?
21:10:47 <solrize> zzzz
21:10:54 <solrize> oops
21:11:45 <tswett> jollyrancher: well, from step 8 on, the expression no longer contains reverse', so it's no longer necessary to show its definition.
21:11:56 <tswett> luite: should I try deleting the directory I mentioned?
21:13:11 <jollyrancher> hmm, this is confusing
21:13:33 <jollyrancher> but i'm too tired right now, i'll have another go at it when my mind is fresh
21:13:41 <jollyrancher> thanks for your help guys :)
21:13:48 <tswett> You're welcome.  :)
21:13:51 <tswett> I'm pretty sleepy myself.
21:15:34 <jollyrancher> just one question before i sleep
21:15:55 <jollyrancher> ah nm
21:16:03 <jollyrancher> will just continue tomorrow
21:16:19 <mzero> well, that left us hangin'
21:16:41 <tswett> Yup.  Stay tuned, I guess.
21:18:09 <YayMe> Does anyone know which combinator this is? I'm using it but don't know what to call it.
21:18:17 <YayMe> bla x y z = x (y z)
21:18:37 <YayMe> just causes simple right associativity
21:18:50 <tswett> YayMe: looks like that's called the B combinator.  http://en.wikipedia.org/wiki/B,C,K,W_system
21:18:56 <YayMe> ok, thanks
21:19:02 <tswett> Or, in Haskell, (.)
21:19:21 <YayMe> Is . really the same? I wasn't certain.
21:19:31 <startling> YayMe: not *really*
21:19:43 <startling> it's the composition operator
21:19:50 <YayMe> right, I know what it is
21:19:58 <startling> haskell's precedence rules just mean they're equivalent, i think
21:20:00 <YayMe> but it feels a little more strict than for my purpose
21:20:21 <dolio> @src (.)
21:20:22 <lambdabot> (f . g) x = f (g x)
21:20:22 <lambdabot> NB: In lambdabot,  (.) = fmap
21:20:24 <YayMe> maybe I've just tried using it too many times where I couldn't because I wasn't paying attention to the precedence
21:21:14 <YayMe> fmap? really?
21:21:41 <YayMe> I keep confusing these basic parts of haskell as I stopped playing with it for a few weeks..
21:22:52 <tswett> It turns out that fmap can be used as a replacement for (.).
21:23:55 <startling> YayMe, fmap on functions is (.)
21:24:09 <startling> don't worry about it if you don't understand yet
21:24:10 <YayMe> @src (fmap)
21:24:10 <lambdabot> Source not found. Sorry.
21:24:14 <YayMe> @src fmap
21:24:15 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
21:24:19 <startling> @src Functor
21:24:20 <lambdabot> class  Functor f  where
21:24:20 <lambdabot>     fmap        :: (a -> b) -> f a -> f b
21:24:39 <startling> @info Functor
21:24:40 <lambdabot> Functor
21:25:43 <YayMe> startling: I did read through the whole functors and applicatives chapters of learn you a haskell a couple times, they actually helped me finally and completely understand the rules of SKI, but that was like a month ago and I forgot since heh
21:26:23 <YayMe> I remember reading and making sense of the fmap and <$> <*> functions and such.. I so wish I could practice Haskell at work
21:26:48 <YayMe> Stupid boring .NET CRUD apps stealing my life
21:27:42 <startling> YayMe: heh
21:27:59 <startling> well, the idea is that Functors allow you to map over some value that may or may not exist yet
21:28:14 <startling> when you fmap over a function, you're fmapping over that function's result
21:28:29 <YayMe> ah
21:28:32 <startling> er, you're *applying* to that function's result
21:28:38 <YayMe> so that's how fmap is different than map
21:28:49 <startling> nope!
21:28:52 <startling> map *is* fmap
21:28:53 <YayMe> balls
21:28:56 <startling> @src map
21:28:57 <lambdabot> map _ []     = []
21:28:57 <lambdabot> map f (x:xs) = f x : map f xs
21:29:00 <startling> oh ugh
21:29:13 <startling> YayMe, fmap on lists is the same as map
21:29:21 <YayMe> right
21:29:44 <YayMe> but fmap follows the old credo, how's it go again
21:29:45 <startling> YayMe, someone made a questionable decision to make them separate for newbie-friendliness, I've heard
21:30:11 <YayMe> be generous in what you accept but strict in what you return, that is so far off but that's the crux of it
21:31:05 <YayMe> startling: How is fmap less user friendly? It allows infinitely more inputs than map, I would think that would make it easier for a newbie to poke and play with
21:32:00 <mzero> Postel's Law, poorly applied, has been the downfall of many a system ---- fortunately Haskell doesn't encourage it
21:32:16 <startling> YayMe: because you get errors with big words in them!
21:32:19 <startling> namely "Functor"
21:32:37 <mzero> it is less newbie friendly as you may have to supply type signatures where with map you wouldn't
21:32:51 <YayMe> mzero: I thought Postal's law was hide on the roof until a crowd shows up, then rain terror down
21:32:55 <startling> oh, that's true
21:33:17 <mzero> funny thing those vowels....
21:33:18 <YayMe> mzero: Good point, type inference is far more difficult I guess
21:33:37 <YayMe> mzero: What's postel's law? Is that what I was referring to but can't currently remember?
21:33:39 <mzero> well, not more difficult, but in admitting more types, there are cases where it won't be able to decide
21:33:45 <augur> ski: i think im done: http://wellnowwhat.net/Programming/Curry-Howard.pdf
21:33:46 <mzero> yes
21:33:59 <startling> we should just tell new people to use NoMonomorphismRestriction until they understand what it means
21:34:23 <mzero> "be conservative in what you do, be liberal in what you accept from others" -- from Postel's RFC for TCP
21:36:56 <YayMe> Thankyou
21:37:11 <slack1256> startling: we should tell people to write type signatures and avoid all together that debate
21:37:16 <YayMe> I always guff that one up, for some reason the big words conservative and liberal always escape me
21:37:57 <YayMe> slack1256: Type signature's really did help me learn how this stuff works to begin with, but now they're getting in my way because they're getting complex enough I'm not certain what the sig would be
21:38:14 <YayMe> or rather, I would miss something typing it
21:38:51 <slack1256> Yayme: "be strict in what you, be lazy in what you accept from other" but I think it won't be popular in this channel :-)
21:39:03 <slack1256> *in waht you do
21:39:08 <slack1256> *what
21:39:09 <startling> slack1256: sometimes it's helpful to run something through ghci and :t it
21:40:07 <slack1256> startling: specially when is an API that you didn't design.
21:40:19 <mzero> if you are not certain what the type sig should be - it is an indication that you are not certain what the function should do .... but yes, I remember when I felt like I was guessing when writing type signatures
21:40:53 <slack1256> but writing type signatures (even in the most complexs one) helps you to carry a mental model on how to simplify thing
21:41:24 <startling> oh, agreed
21:41:41 <slack1256> Data.Traversable is an enormous tool which is only useful if you understand correctly your type, using it instead of developing you own solution will save you days
21:41:45 <startling> just saying it's not always the easiest thing when you're learning the language
21:43:08 <slack1256> oh yeah if you are a beginner it's almost as a language on top of haskell.
21:43:35 <copumpkin> koninkje_away: you around?
21:43:40 <slack1256> startling: if you could give an advice to future book writers of haskell about this. what should you tell them?
21:43:57 <slack1256> *s/should/would/
21:46:10 <startling> use NoMonomorphismRestriction until you can infer types better than ghc
21:48:03 <slack1256> xD
21:48:35 <YayMe> Is this right? Maybe 3 <*> +4 = Maybe 7
21:48:41 <YayMe> or is it <$> ?
21:48:56 <YayMe> Or am I doing it all wrong? :)
21:49:04 <startling> YayMe, you're confused on a couple of things
21:49:15 <startling> YayMe: Possible you mean Just 3, not Maybe 3?
21:49:20 <YayMe> oh yes
21:49:34 <startling> > (+4) <$> Just 3
21:49:36 <lambdabot>   Just 7
21:49:43 <YayMe> ok
21:49:49 <startling> > Just (+ 4) <*> Just 3
21:49:50 <lambdabot>   Just 7
21:50:14 <YayMe> > Just 3 <$> +3
21:50:15 <lambdabot>   <no location info>: parse error on input `+'
21:50:24 <YayMe> > Just 3 <$> (+3)
21:50:26 <lambdabot>   Couldn't match expected type `a -> b'
21:50:26 <lambdabot>         against inferred type `Data.M...
21:50:34 <YayMe> so the just has to be on the right side?
21:50:41 <slack1256> @type (<$>)
21:50:42 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
21:50:46 <startling> YayMe, it's infix fmap
21:50:49 <slack1256> @type (<*>)
21:50:50 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
21:50:56 <startling> > Just 3 `fmap` (+ 3)
21:50:58 <lambdabot>   Couldn't match expected type `a -> b'
21:50:58 <lambdabot>         against inferred type `Data.M...
21:51:08 <startling> > (+ 3) `fmap` Just 3
21:51:10 <lambdabot>   Just 6
21:51:17 <YayMe> ah
21:51:24 <slack1256> well in the left size needs to be a "lifted function", on the right it need to be an argument of that function
21:51:32 <slack1256> *s/size/side/
21:51:38 <startling> ^ for <*>
21:51:46 <startling> for <$>, it's function <$> functor
21:51:47 <YayMe> makes sense
21:51:54 <slack1256> @type (<*>)
21:51:55 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
21:52:29 <slack1256> you get that 'f b' at the end which is (Just 7)
21:52:59 <slack1256> can we load modules (attoparsec) in lambdabot?
21:54:12 <slack1256> :m Data.Attoparsec.Text
21:54:31 <startling> slack1256: I don't think so
21:56:52 <YayMe> I'm playing with SKI and if I have a parameter to a function that may be s or k, and I want to apply it to s, I'm running into trouble, it's complaining about infinite type
21:57:11 <YayMe> I think that's because it doesn't know what the type of the function coming in might be
21:57:56 <startling> YayMe, what's your code?
21:58:43 <startling> YayMe: it may be because S can apply to S can apply to S etc etc etc
21:59:37 <YayMe> I figure so startling, however I should be able to hide the function away in an algebraic type
22:00:21 <YayMe> No, that won't work, because as soon as I apply either of them the output no longer conforms to the type
22:00:33 <startling> right
22:02:14 <blackdog> i'm sure i've seen this before - is there a way to tell cabal where to install executables?
22:02:48 <slack1256> yes ~/.cabal/config should have an option
22:03:21 <latro`a> the full SKI doesn't work in a typed system iirc
22:03:31 <slack1256> blackdog: bindir should do the trick
22:03:53 <hpaste> YayMe pasted “ski parse cosntructor” at http://hpaste.org/71873
22:03:54 <slack1256> although is more safe and easy to just add .cabal/bin to your path.
22:03:57 <blackdog> slack1256: can you do it on a install-by-install basis?
22:04:12 <blackdog> (this is for heroku, so i don't have a home directory afaik...)
22:04:30 <YayMe> my code doesn't work and I'm trying to do it all wrong
22:04:34 <YayMe> :)
22:05:02 <slack1256> blackdog: I don't have experience with heroku. let me check out some options in cabal to tell if works
22:06:22 <blackdog> suppose i could just move it after
22:06:40 <YayMe> startling: Tips on what I'm doing wrong or how I should go about what I'm trying to do in that paste?
22:07:07 <YayMe> I realize, the problem is it's a static language and the function's accumulator is going to be a constantly changing type in my implementation so that won't work
22:07:25 <startling> YayMe, yeah, I'm not sure how you could do it
22:07:44 <startling> you could have an object that wraps them and only carries information on how to organize them
22:08:11 <YayMe> perhaps
22:08:24 <YayMe> in a foldl the accumulator can't change types can it?
22:09:10 <startling> YayMe: I don't think so
22:09:45 <YayMe> I can't have an array like: [Bool -> Char, Char -> Bool -> Char] can I/
22:09:58 <startling> nope
22:10:20 <slack1256> although you could define a new datatype called
22:10:55 <slack1256> data CharBool = C Bool -> Char | B Char -> Bool -> Char
22:11:06 <slack1256> now you can make an array of type CharBool
22:11:29 <slack1256> but why complicate things right?
22:11:58 <YayMe> slack1256: It was a more generic question regarding the semantics of arrays
22:12:13 <YayMe> I would need a dynamic data type to actually have a hardened data type for it
22:12:26 <YayMe> sorry, lists not arrays heh
22:12:40 <startling> YayMe: yep. tuples do what you want, though
22:13:43 <YayMe> startling: Yeah, I was pondering that too.. there are simple ways to continually concatenate tuples without increasing their depth, no?
22:14:29 <YayMe> I'm racking my brain for the example I read in a book a month ago..
22:14:35 <startling> YayMe: nope!
22:14:56 <YayMe> startling: No? perhaps the example I'm trying to remember was an example of what you can't do heh
22:15:22 <YayMe> There's a simple way to flatten a tuple?
22:15:31 <startling> YayMe, how do you mean "flatten"?
22:15:42 <slack1256> blackdog: you can't alternate in configurations with cabal. the best you can get is a shell script that on demand change the config file.
22:15:55 <YayMe> (a,(b,(c,d))) -> (a,b,c,d)
22:16:37 <startling> YayMe: I can't think of a simple way, no
22:17:24 <blackdog> slack1256: righto. i'll just mv it.
22:23:17 <YayMe> I'm retarded, why is this
22:23:26 <YayMe> > fst (1,(2,3),4)
22:23:27 <lambdabot>   Couldn't match expected type `(a, b)'
22:23:27 <lambdabot>         against inferred type `(t, (t...
22:24:32 <slack1256> @type fst
22:24:33 <lambdabot> forall a b. (a, b) -> a
22:24:43 <slack1256> you are passing it a '(a,b,c)'
22:24:45 <YayMe> oh
22:24:50 <YayMe> right
22:25:06 <slack1256> do patter matching ;)
22:25:13 <YayMe> aye, thanks
22:25:16 <slack1256> *pattern
22:25:52 <tertl9> hello
22:26:56 <slack1256> hello tertl9
22:27:05 <YayMe> If anybody has ideas about how to solve what my hpaste has correctly, do annotate it or something. I'm curious how to work through that issue.
22:27:28 <YayMe> Or rather, what a more correct approach would be
22:27:33 <YayMe> night folks..
22:28:41 <tertl3> is haskell best for writing other languages>?
22:29:45 <slack1256> it's a meme that haskell/Ocaml/SML are good language to write compiler
22:29:51 <blackdog> tertl3: haskell's pretty good for general computation, but yes, it does tend to shine with symbol manipulation problems like writing parsers, compilers etc
22:29:55 <slack1256> I haven't experienced that but it seem to be true.
22:30:27 <startling> @faq can you implement other languages in haskell?
22:30:28 <lambdabot> The answer is: Yes! Haskell can do that.
22:30:31 <tertl3> i am in the process of doing the haskell scheme parser
22:30:47 <startling> tertl3, haskell is pretty good for that kind of thing
22:30:58 <startling> it's type system + pattern matching add a lot
22:31:21 <tertl3> does anyone know is that article is still updated to work with new haskell versions?
22:32:19 <tertl3> http://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours
22:32:27 <startling> tertl3: not a lot has changed in haskell for a long time
22:32:43 <startling> barring some internal differences and extensions and libraries
22:32:46 <tertl3> since 98?
22:33:25 <tertl3> oh the source is available for download, I didnt see that
22:33:31 <tertl3> i can try it in full
22:33:46 <slack1256> tert13: looking at the wikibook history in  july seems to have had some addition
22:33:49 <startling> tertl3, haskell prime makes a few small differences
22:34:02 <slack1256> it should be good enough
22:34:13 <startling> tertl3: I remember doing it a few years ago, fwiw
22:35:35 <tertl3> oh thats this mi nth
22:35:38 <startling> tertl3: any specific problems you're having?
22:35:45 <tertl3> no I am just wondering
22:36:00 <tertl3> trying to plan out my activites b/c i get distracted too much
22:36:13 <tertl3> and just wondering what to expect if I actually finish this
22:36:36 <startling> tertl3: a working scheme implementation!
22:39:40 <tertl3> welp I got an error
22:40:27 <startling> let's see
22:41:19 <otters> so wai wants a ResourceT IO Response
22:41:25 <otters> but I don't know what functions return a ResourceT
22:41:46 <hpaste> povman pasted “manual SCCs” at http://hpaste.org/71875
22:42:16 <povman> I'm having trouble using ghc profiling to discover the source of memory allocation. that paste is SCC'd up as much as i can think of, but profiler still puts all the allocations on 'go'
22:42:53 <Nereid> otters: ResourceT has to do with conduits
22:43:03 <otters> so I see
22:43:16 <otters> ho boy
22:45:57 <otters> does wai went me to define my own resource manager here
22:48:06 <startling> is there a nice type for two-dimensional arrays somewhere?
22:48:17 <startling> Array (Int, Int) Whatever feels a bit like a cludge
22:49:35 <otters> the problem is that I don't understand where I'm supposed to send the response *to*
22:50:03 <povman> startling: What qualities are you looking for?
22:50:38 <startling> povman, easy rows/columns
22:50:54 <startling> and implicit nonnegative indices
22:51:13 <Ralith> so use a nonnegative number type
22:51:35 <spirity> otters: there's nothing in particular tying ResourceT to conduits. it's just a way to allocate/free scarce resources.
22:51:54 <spirity> otters: you can use liftIO to transform an IO computation into
22:51:57 <spirity> ResourceT
22:52:21 <povman> startling: Doesn't Array do that?
22:53:33 <otters> :where liftIO
22:53:37 <otters> @where liftIO
22:53:37 <lambdabot> I know nothing about liftio.
22:53:40 <otters> @index liftIO
22:53:40 <lambdabot> Control.Monad.Trans, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
22:54:45 <spirity> otters: Control.Monad.IO.Class
22:57:10 <tertl3> startling http://hpaste.org/71876
22:58:24 * hackagebot HsOpenSSL 0.10.3.2 - (Incomplete) OpenSSL binding for Haskell (MasatakeDaimon)
22:59:59 <startling> povman: nope!
23:02:19 <tertl3> seem that his compiler is either newer or older than mine
23:02:39 <tertl3> fglasgow is depecated to what?
23:03:00 <tertl3> fglasgow-ext*
23:10:33 <geekosaur> tertl3, you specify the exact extensions you want, not a global sledgehamer
23:11:23 <geekosaur> (while I don't *gthink we have such an issue right now, potentially some extensions could conflict with each other, so a global all-extensions-on flag is a bad idea)
23:12:38 <tertl3> which one do you thing I need?
23:12:58 <tertl3> http://jonathan.tang.name/files/scheme_in_48/code/listing5.hs
23:13:08 <tertl3> no sry
23:13:20 <tertl3> this one -----> http://jonathan.tang.name/files/scheme_in_48/code/listing10.hs
23:13:21 <geekosaur> ghc should generally tell yoy that in its error messages
23:13:38 <tertl3> it says IO error, but what flag is that?
23:14:10 <geekosaur> full error message please (to a pastebin)
23:14:37 <geekosaur> I will note that you need to swith to all hierarchical imports:  Monad is Control.Monad, IO is System.IO
23:15:13 <tertl3> http://hpaste.org/71876
23:15:47 <geekosaur> come to think of it, that *is* an example of a conflicting change.  you get non-hierarchical imports with -XHaskell98 but then you have a different definition of the Num typeclass...
23:16:10 <geekosaur> ok I just answered that
23:16:22 <shachaf> geekosaur: Those aren't actually "hierarchical imports"...
23:17:17 <geekosaur> sigh, substutute whatever pontless pedanticism yoy require shachaf, at 0200 insomniac I am not playing the game
23:17:37 <tertl3> ok
23:17:47 <tertl3> new error
23:17:51 <shachaf> geekosaur: I was actually rather confused when I read the last thing you said.
23:18:05 <shachaf> Then again, getting confused for not having any context is pretty normal, I guess.
23:18:17 <geekosaur> it is hierarchical because in GHC the . maps to a / in the filesystem.  this is enough for mere humans
23:18:19 <tertl3> http://hpaste.org/71877
23:18:25 * hackagebot yi 0.6.6.0 - The Haskell-Scriptable Editor (CoreyOConnor)
23:19:49 <geekosaur> ...wow.  how old is this code that it thinks try is there?
23:20:16 <tertl3> thats why Im asking
23:20:25 <geekosaur> remove the "hiding (try)" on line 7; "try" has not been there for a long time
23:20:34 <tertl3> ok
23:20:44 <geekosaur> this is not an extension, strictly speaking, and -fglasgow-exts would not have helped with either of these
23:21:14 <geekosaur> the libraries are different, not the language
23:22:14 <Kaide> http://www.thebricktestament.com/king_david/god_kills_70000_israelites/2s24_25b.html
23:23:06 <geekosaur> @where ops
23:23:06 <lambdabot> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
23:23:25 * hackagebot yi-contrib 0.6.6.0 - Add-ons to Yi, the Haskell-Scriptable Editor (CoreyOConnor)
23:23:40 --- mode: ChanServ set +o glguy
23:23:42 <copumpkin> Kaide: seriously?
23:23:45 <copumpkin> can you avoid that?
23:23:53 <Kaide> wrong channel sorry
23:24:09 <Kaide> wrong network, for that matter
23:24:12 <Kaide> sorry copumpkin
23:25:12 --- mode: glguy set -o glguy
23:29:58 <tertl3> its working thanks guys for arguing about stuff so i understand it :)
23:30:50 <tertl3> but wth did he name the book on scheme and then call the interpreter Lisp>>> in the implememtation?
23:31:07 <tertl3> just wondering
23:31:14 <shachaf> Well, it's not really Scheme.
23:31:19 <shachaf> But "Lisp" is a very vague word.
23:31:24 <tertl3> oh I see
23:31:30 <tertl3> my bad
23:31:41 <tertl3> well, now I can put this in my todo list
23:31:49 <tertl3> let me try the lib too
23:36:11 <tertl3> yes it all works
23:36:15 <tertl3> .me rejoice
