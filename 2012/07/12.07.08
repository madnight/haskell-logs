00:00:42 <ion> Why strings and not arbitrary lists?
00:08:07 <dmwit> ion: because efficiency lol
00:08:46 <avpx> ...
00:09:00 <dmwit> All the types are like a -> b -> ByteString -> String
00:09:25 <archeyDevil> Hmm. haskell likes infinite.. [0..] cycle etc.. Why is there a limit in the double type?
00:09:36 <dmwit> archeyDevil: Use Rational or CReal.
00:09:37 <avpx> Ah, perhaps that makes a bit of sense. Unfortunately I cannot view the documentation now.
00:09:39 <dmwit> > pi :: CReal
00:09:40 <lambdabot>   3.1415926535897932384626433832795028841972
00:09:57 <dmwit> avpx: Look at version 0.3.1, that's what I'm doing.
00:09:57 <avpx> archeyDevil: You should understand that any computer program that tells you it can implement the Reals is lying to you
00:10:10 <dmwit> CReal isn't the reals, it's the computable reals.
00:10:19 <dmwit> That's not a lie, it even has "computable" in its name (if abbreviated).
00:10:33 <dmwit> Of course, you can't do things like equality testing.
00:10:34 <shachaf> Just like CInt is the computable integers!
00:10:41 <dmwit> haha
00:10:46 <Enigmagic> :x
00:10:55 <avpx> I meant it is a lie in the sense that a computer with finite memory cannot represent an infinite set
00:11:03 <dmwit> ?remember shachaf <dmwit> CReal is the computable reals. <shachaf> Just like CInt is the computable integers!
00:11:04 <lambdabot> Okay.
00:11:04 <avpx> Certainly not an *uncountable* set in any reasonable sense
00:11:30 <avpx> The problem with floats is that we treat them as numbers when they are in fact lies. And CReals are probably only slightly better.
00:11:57 <shachaf> avpx: The semantics of the type are a rather different thing from how much memory your computer has.
00:12:02 <dmwit> CReal is significantly better than IEEE754 in many respects (and significantly worse in others).
00:12:12 <avpx> Is it at least a field?
00:12:21 <avpx> Because floats don't even form an additive group.
00:12:31 <dmwit> yes
00:12:43 <avpx> That's helpful.
00:12:46 <dmwit> Though again that question is a bit tricky, since you have to talk about equality from outside of Haskell. =P
00:13:19 <dmwit> (==) isn't implemented correctly.
00:13:19 * avpx will stop being cynical about number representations
00:13:49 <dmwit> Rational is my go-to numeric type, though.
00:13:54 <dmwit> I mean, who needs square roots??
00:14:08 <ion> dmwit: Ah, so ‚ÄúFinding palindromes in ByteStrings‚Äù
00:14:16 <avpx> Rational makes sense in the same way that arbitrary-precision integers make sense.
00:14:42 <dmwit> CReal makes sense in the same sense.
00:15:00 <avpx> Fair. I will look into CReals as a type.
00:15:05 <dmwit> type CReal = Integer -> Integer -- approximately; with the input being "how precise an answer do you want"
00:15:18 <shachaf> In what units?
00:15:18 <dmwit> "how many digits of the answer do you want"
00:15:21 <shachaf> Oh.
00:15:32 <shachaf> Why not CReal = Natural -> Integer -- "which digit do you want"? :-)
00:15:33 <dmwit> Actually, more like "how many bigits", but... yeah.
00:15:43 <avpx> I see.
00:15:48 <avpx> That's fairly reasonable, at least.
00:15:51 <dmwit> shachaf: Because addition.
00:16:17 <shachaf> dmwit: Pft.
00:16:24 <avpx> It's sort of like fixed-point arithmetic with numbers which can be computed to arbitrary precision.
00:16:29 <shachaf> Is a bigit like a bit?
00:16:34 <avpx> And fixed-point arithmetic actually works.
00:16:36 <dmwit> very like =)
00:16:52 <avpx> I am content.
00:17:06 <shachaf> Fixed-point arithmetic works?
00:17:21 <dmwit> shachaf: It's not quite the same, because if you hand it 0, it's going to hand you more than 0 bits -- it's going to hand you as many bits as it takes to represent the whole-number part of the number.
00:17:27 <shachaf> Well, for the most part, I guess.
00:18:01 <avpx> Fixed-point arithmetic at least forms a reasonable algebraic structure.
00:18:06 <dmwit> I think you can probably hand it negative numbers to get the "even-number" part of the number, etc., too.
00:18:13 <avpx> You can, for instance, do "cancellation"
00:19:17 <ion> The output of the CReal type is the exact value of the expression scaled by 2^input and rounded to an integer IIRC.
00:21:15 <archeyDevil> Is there any kernel written in haskell?? ;) SO DAMN POWERFUL!! :D
00:21:28 <dmwit> There's House and the follow-up projects.
00:21:40 <dmwit> lighthouse, ...and others, but I can't remember the names
00:21:40 <archeyDevil> HaskellOS sounds perfect. :)
00:22:16 <avpx> dmwit: Just to be clear, are you talking about Data.Number.CReal? Because this is actually a pretty neat idea.
00:22:42 <dmwit> ?hackage numbers
00:22:42 <lambdabot> http://hackage.haskell.org/package/numbers
00:22:48 <dmwit> yes
00:23:13 <avpx> dmwit: It's an interesting and elegant use of Haskell's laziness. I am impressed.
00:23:23 <dmwit> It's not really laziness.
00:23:24 <ion> I don‚Äôt think it has anything to do with laziness.
00:23:30 <dmwit> The same implementation can be done in a strict language.
00:23:33 <avpx> Hmm, on further reflection I suppose not.
00:23:36 <dmwit> So long as you have higher-order functions.
00:24:05 <archeyDevil> Awesome!
00:24:09 <ion> But it demonstrates how nicely you can implement arbitrary number types in Haskell well. :-)
00:24:18 <avpx> Yeah, I guess I was thinking about it the wrong way.
00:24:34 <archeyDevil> http://programatica.cs.pdx.edu/House/I/screendump-oct2005.png -- Thought it would have XMonad. Heh. :P
00:24:45 <avpx> I was almost thinking that you could implement a type like this as an infinite list of numbers.
00:24:46 <dmwit> House predates xmonad, I think.
00:24:57 <dmwit> Also, I very doubt that House can run X.
00:25:19 <dmwit> avpx: Yeah, that's an alternate implementation.
00:25:25 <avpx> Rather than ask for the precision, you would just take as many digits as you wanted. And if you wanted to find the representation of a number, you would have to find an infinite list of all of its digits.
00:26:48 <dmwit> avpx: The thing is that using a list means you have to pick a relatively arbitrary point to "start" from.
00:27:09 <dmwit> e.g. you have to "start" from the ones digit, or the 2s digit, or the 4s digit, or the 8s digit... or the halves digit, etc.
00:27:23 <dmwit> I wouldn't relish writing addition or multiplication with that representation, either.
00:28:03 <shachaf> dmwit: Start from the decimal point, yield pairs of digits in both directions!
00:28:19 <ion> A zipper!
00:28:28 <dmwit> shachaf: Yeah, but then you have the CReal problem (don't know how deep the computation actually goes) in *both* directions!
00:28:29 <avpx> I see an implementation where showCReal is essentially (\n -> take n . getDigitsCReal), where getDigitsCReal :: CReal -> [Int] is an infinite digit representation of the number.
00:28:38 <shachaf> dmwit: Or you could just have (Integer,[Bit]) pairs or something.
00:28:42 <dmwit> e.g. you never know if you've gotten enough bigger and bigger digits that you've reached the last 1 digit. =)
00:29:08 <dmwit> shachaf: Yeah, but the arbitrary choice to represent everything above the 1s digit in an Integer is what makes me uncomfortable. It's just weird!
00:29:22 <avpx> Ah, I see, you'd have to store magnitude information somehow.
00:29:28 <shachaf> That doesn't seem that arbitrary to me.
00:29:56 <dmwit> Why are whole numbers so much more special than even numbers? Why are they so much more special than halves?
00:30:19 <avpx> I guess you could store the numbers as ([Int']
00:30:28 <dmwit> If I'm doing astronomy, I don't care about all those piddling ones, I just want to know the 2^60 digit and above...
00:30:29 <avpx> Erm, ([Int], Int)
00:30:36 <avpx> Where the latter represents the magnitude of the number.
00:32:42 <avpx> The issue is that you'd need to know the magnitude to do any computation with these numbers, but really, I don't believe that seems to be the issue with these sorts of number implementations.
00:33:16 <shachaf> dmwit: How do you usually construct the reals?
00:33:23 <dmwit> good question
00:33:33 <shachaf> I think the standard path is N -> Z -> Q -> R or something like that.
00:33:40 <shachaf> So that's why integers are more special. :-)
00:34:03 <newsham> computable reals?
00:34:04 <dmwit> Even integers aren't special there.
00:34:12 <archeyDevil> House is fast. :)
00:34:28 * hackagebot kevin 0.1.4 - a dAmn î IRC proxy  http://hackage.haskell.org/package/kevin-0.1.4 (JoelTaylor)
00:34:46 <newsham> type Real = Rational -> Rational
00:34:50 <newsham> ?
00:35:07 <avpx> newsham: Eh? How so?
00:35:08 <shachaf> dmwit: Right, which is why I didn't take even integers as the left part of my tuple, but all integers. :-)
00:35:15 <shachaf> newsham: Why Rational -> Rational?
00:35:23 <dmwit> shachaf: Seems the standard construction of the computable reals is via Turing Machine.
00:35:34 <newsham> avpx: give a delta and get back a number whose error is less than that delta?
00:35:54 <avpx> Still, with regards to CReals, it seems more idiomatic to have an infinite digit string, one way or another.
00:36:09 <avpx> There must be a way to do it and ensure that it is clear exactly which number is represented.
00:36:17 <newsham> ie:  1/1000 -> 31416/1000 ?
00:36:22 <startling> does pandoc not have a thing for recognizing markup language from a file's extension?
00:37:03 <shachaf> newsham: Ah, makes sense.
00:37:15 <avpx> Yeah, definitely.
00:37:35 <shachaf> dmwit: The only reason CReal is CReal instead of Real is that all Haskell programs have to be computable. :-(
00:37:35 <dmwit> Also, I think you're joking, and appreciate the joke, but as soon as you pass from Z -> Q the integers stop being special. =)
00:37:35 <avpx> That actually seems like a very good way to do it.
00:38:11 <avpx> Thus the arbitrary precision is already baked into the representation.
00:38:12 <dmwit> avpx: That is essentially what the actual implementation does; except it constraints inputs to rationals of the form 1/2^n.
00:38:51 <shachaf> dmwit: OK, 0 and 1 are special, and they're both integers.
00:38:54 <newsham> dmwit: Nat -> Rational   where Nat gives a number of bits past the decimal point?
00:39:11 <shachaf> Even numbers doesn't let you represent 1, and halves lets you represent too much. :-)
00:39:17 <newsham> got created Z, the rest is the work of man.
00:39:36 <dmwit> newsham: Integer -> Integer, where Integer gives a number of bits (possibly negative) past the decimal point, and the result is the actual number times 2^input.
00:39:37 * shachaf thinks dmwit is the one who's joking here.
00:39:47 <newsham> dmwit: ahh
00:40:22 <dmwit> shachaf: I don't really view 0 and 1 as being special.
00:40:23 <newsham> dmwit: so  0 -> 3  for pi?
00:40:28 <shachaf> dmwit: 2^-input?
00:40:37 <shachaf> Oh, no, I read that backwards.
00:40:46 <dmwit> In this particular case.
00:41:08 * dmwit is not joking
00:41:15 <shachaf> data CReal = CR (Int -> Integer)
00:41:16 * shachaf gasps
00:41:25 * dmwit too
00:41:42 <newsham> hrmm.. so you can only ask for maxbound :: Int bits?
00:41:43 <dmwit> http://math.ucr.edu/home/baez/torsors.html
00:41:44 <newsham> boo :(
00:42:05 <dmwit> I guess at least in GHC you can't represent an answer with more than maxBound :: Int + 1 bits anyway. =P
00:42:14 <shachaf> 2^63 bits isn't *nearly* enough for me!
00:42:16 <dmwit> eh, maxBound * 2, I guess
00:43:01 <newsham> is that a limitation of Integer?
00:43:08 <dmwit> It's a limitation of address spaces.
00:43:24 <dmwit> You can't access more memory than a machine word can address.
00:43:25 <newsham> oh, you need a factor of 8 in there somewhere surely
00:43:32 <archeyDevil> Is there any quick download link for learnyouahaskell?
00:43:39 <archeyDevil> Or just wget it all?
00:43:44 <newsham> > maxbound :: Int
00:43:46 <lambdabot>   Not in scope: `maxbound'
00:43:49 <newsham> > maxBound :: Int
00:43:51 <lambdabot>   9223372036854775807
00:44:04 <dmwit> > 2^63 :: Integer
00:44:05 <lambdabot>   9223372036854775808
00:44:15 <archeyDevil> > :t maxBound
00:44:16 <lambdabot>   <no location info>: parse error on input `:'
00:44:20 <dmwit> :t maxBound
00:44:21 <lambdabot> forall a. (Bounded a) => a
00:44:21 <archeyDevil> o.O
00:44:24 <archeyDevil> ohh.
00:44:26 <newsham> so you can have 2 * maxBound * 8 bits in your address space
00:44:52 <archeyDevil> > 2 * maxBound * 8
00:44:54 <lambdabot>   Ambiguous type variable `a' in the constraints:
00:44:54 <lambdabot>    `GHC.Enum.Bounded a'
00:44:54 <lambdabot>    ...
00:44:57 <dmwit> newsham: right
00:44:58 <archeyDevil> :(
00:45:09 <dmwit> archeyDevil: That's never going to work: you're asking for a number bigger than maxBound.
00:45:11 <archeyDevil> > maxBound 5
00:45:12 <lambdabot>   No instance for (GHC.Enum.Bounded (t -> a))
00:45:12 <lambdabot>    arising from a use of `e_15'...
00:45:18 <dmwit> You can't get a number bigger than maxBound. =)
00:45:26 <dmwit> > 2 * fromIntegral (maxBound :: Int) * 8
00:45:28 <shachaf> > 2 * fromIntegral (maxBound :: Int) * 8
00:45:28 <lambdabot>   147573952589676412912
00:45:30 <lambdabot>   147573952589676412912
00:45:31 <newsham> > (maxBound :: Integer) + 1
00:45:32 <lambdabot>   No instance for (GHC.Enum.Bounded GHC.Integer.Type.Integer)
00:45:32 <lambdabot>    arising from...
00:45:38 <newsham> > (maxBound :: Inte) + 1
00:45:40 <lambdabot>   Not in scope: type constructor or class `Inte'
00:45:40 <newsham> > (maxBound :: Int) + 1
00:45:42 <lambdabot>   -9223372036854775808
00:45:50 <archeyDevil> lol
00:45:54 <newsham> > (maxBound :: Int) * 4
00:45:55 <lambdabot>   -4
00:46:08 <archeyDevil> One way to get negatives :P
00:46:10 <shachaf> I'm pretty sure that's undefined.
00:46:18 <archeyDevil> > (maxBound :: Int) * pi
00:46:19 <lambdabot>   No instance for (GHC.Float.Floating GHC.Types.Int)
00:46:20 <lambdabot>    arising from a use of...
00:46:22 <newsham> i'm pretty sure its not undefined
00:46:24 <archeyDevil> :(
00:46:29 <newsham> cause like i'm pretty sure lambdabot just told us the answer
00:46:30 <newsham> ;-)
00:46:39 <archeyDevil> :t pi
00:46:41 <lambdabot> forall a. (Floating a) => a
00:47:07 <dmwit> shachaf: pft, maybe in C
00:47:10 <newsham> anyway we're getting sidetracked from reals and computable reals and haskell and creal
00:47:19 <shachaf> dmwit: It's undefined in Haskell too!
00:47:30 <shachaf> "Undefined behavior? In *my* Haskell?"
00:47:37 <newsham> > undefined == (maxBount :: Int) * 4
00:47:39 <lambdabot>   Not in scope: `maxBount'
00:47:43 <newsham> > undefined == (maxBound :: Int) * 4
00:47:44 <lambdabot>   *Exception: Prelude.undefined
00:47:55 <newsham> shachaf: nope, doesnt look like it
00:48:02 <archeyDevil> > (maxBound :: Int) * 4
00:48:03 <lambdabot>   -4
00:48:07 <archeyDevil> orly?
00:48:09 <shachaf> newsham: "* Exception: Prelude.undefined"
00:48:15 <shachaf> Looks like it was undefined to me!
00:48:22 <archeyDevil> > (maxBound :: Int) * pi
00:48:23 <lambdabot>   No instance for (GHC.Float.Floating GHC.Types.Int)
00:48:24 <lambdabot>    arising from a use of...
00:48:27 <archeyDevil> :(
00:48:29 <newsham> shachaf: it didnt say it was equal
00:48:30 <archeyDevil> > (maxBound :: Int) * (pi)
00:48:31 <lambdabot>   No instance for (GHC.Float.Floating GHC.Types.Int)
00:48:31 <lambdabot>    arising from a use of...
00:48:41 <ion> > fromIntegral (maxBound :: Int) * pi
00:48:42 <lambdabot>   2.897607783230849e19
00:48:43 <newsham> archery: you gotta convert the Int to a float
00:48:50 <archeyDevil> :)
00:48:54 <archeyDevil> e19! :D
00:49:06 <dmwit> "The results of exceptional conditions (such as overflow or underflow) on the fixed-precision numeric types are undefined." -- =(
00:49:07 <ion> > fromIntegral (maxBound :: Int) * pi :: CReal
00:49:08 <lambdabot>   28976077832308491366.3957115743506463113814659329497299241877
00:49:14 <archeyDevil> :)
00:49:35 <archeyDevil> > 1024^0124
00:49:36 <lambdabot>   189319183749183122598428605258306298103257399766638715033315972512420704509...
00:49:36 <shachaf> Hmm, I guess hexadecimal floating points are a problem.
00:49:38 <archeyDevil> > 1024^1024
00:49:39 <lambdabot>   352497141210838265713481483980028154643914213439664710603913826057310702768...
00:49:44 <archeyDevil> > 1024^1024 :: CReal
00:49:46 <lambdabot>   352497141210838265713481483980028154643914213439664710603913826057310702768...
00:49:46 <shachaf> 0x123abcde19
00:49:49 <archeyDevil> D:
00:50:00 <newsham> creal is too sugary these days
00:50:01 <archeyDevil> *wants this gigantic number
00:50:06 <dmwit> > 1024 * logBase 10 1024
00:50:07 <lambdabot>   3082.547155599167
00:50:07 <archeyDevil> > 2^20
00:50:08 <lambdabot>   1048576
00:50:13 <dmwit> archeyDevil: Just type it into ghci.
00:50:19 <archeyDevil> Yea. ima do that
00:50:31 <dmwit> Personally, I'm glad that lambdabot doesn't try to send a 3kb message to this IRC channel.
00:50:36 <dmwit> in one-line chunks of 80 chars each
00:51:13 <archeyDevil> Gotta love ghci for calc :D
00:51:20 <newsham> dont gotta
00:52:28 <archeyDevil> I do.
00:53:10 <archeyDevil> Hmm...
00:53:15 <archeyDevil> 1024^1024^1024
00:53:19 <archeyDevil> > 1024^1024^1024
00:53:23 <archeyDevil> :(
00:53:25 <lambdabot>   mueval: ExitFailure 1
00:53:25 <lambdabot>  mueval: Prelude.undefined
00:53:32 <archeyDevil> lol
00:53:39 <newsham> > 1024^1024^1024 == (1024^1024)^1024
00:53:44 <lambdabot>   mueval: ExitFailure 1
00:53:44 <lambdabot>  mueval: Prelude.undefined
00:53:56 <archeyDevil> > (1024^1024)^1024
00:53:56 <newsham> > 10^10^10 == (10^10)^10
00:53:57 <lambdabot>   can't find file: L.hs
00:53:58 <lambdabot>   193790974871326974793082930382153168096992053690277864836684225358830449480...
00:54:02 <archeyDevil> CPU:100% atm :P
00:55:04 <dmwit> > (1024^1024) * logBase 2 1024
00:55:05 <lambdabot>   Infinity
00:55:09 <avpx> I wonder how efficient Prelude's exponentiation is when the exponents are integer types.
00:55:16 <dmwit> I don't think you have enough bits to finish that calculation.
00:55:30 <dmwit> avpx: very
00:55:32 <archeyDevil> Can you do (1024^1024)^1024 from the console? i.e I wanna run it though time.
00:55:40 <dmwit> avpx: That's why we have three different exponentiation operators.
00:55:41 <avpx> dmwit: Exponentiation by squaring, I'd guess?
00:55:45 <dmwit> ?src (^)
00:55:45 <lambdabot> x ^ 0            =  1
00:55:45 <lambdabot> x ^ n | n > 0    =  f x (n-1) x
00:55:46 <lambdabot>   where f _ 0 y = y
00:55:46 <lambdabot>         f x n y = g x n
00:55:46 <lambdabot>           where g x n | even n  = g (x*x) (n `quot` 2)
00:55:47 <lambdabot>                       | otherwise = f x (n-1) (x*y)
00:55:49 <lambdabot> _ ^ _            = error "Prelude.^: negative exponent"
00:55:57 <archeyDevil> lol
00:56:10 <dmwit> archeyDevil: ghc -e?
00:56:11 <archeyDevil> ?src ghci
00:56:11 <lambdabot> Source not found.
00:56:12 <archeyDevil> :P
00:56:43 <archeyDevil> Thanks
00:56:49 <archeyDevil> cpu: 100% :)
00:57:36 <newsham> (2^10)^(2^10)^(2^10)
00:58:02 <newsham> (2^10)^(2^100)
00:58:15 <newsham> 2^(10*2^100)
00:58:49 <avpx> newsham: You have to prefix expressions to let lambdabot know you want the result.
00:58:53 <archeyDevil> let a=(1024^1024)^1024; how to asign it's value to a?
00:59:08 <avpx> > let s (x:xs) = x:s [n | n <- xs, (n `mod` x) > 0] in s [2..]
00:59:09 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
00:59:20 <dmwit> newsham: uh, x^y^z = x^(y*z), so wouldn't that be (2^10)^(2^20), not 100?
00:59:23 <newsham> does lambdabot have a symbolic number type?
00:59:31 <dmwit> > 2^10 :: Expr
00:59:32 <lambdabot>   2 * 2 * (2 * 2) * (2 * 2 * (2 * 2)) * (2 * 2)
00:59:35 <dmwit> sort of =)
00:59:43 <archeyDevil> Interesting.
00:59:51 <newsham> dmwit:  x^(y^z) != x^(y*z)
01:00:07 <dmwit> (x^y)^z ?= x^(y*z)
01:00:17 <avpx> I have heard rumors that Expr is a hack.
01:00:26 <newsham> > 3^(3^3)
01:00:28 <lambdabot>   7625597484987
01:00:29 <newsham> > 3^3^3
01:00:31 <lambdabot>   7625597484987
01:00:35 <archeyDevil> Is there any haskell linear equations program? :D
01:00:36 <dmwit> oh right
01:00:38 <newsham> > (3^3)^3
01:00:40 <lambdabot>   19683
01:00:47 <archeyDevil> as in, draws a graph from the values?
01:01:06 <archeyDevil> Wow. easy in haskell to do such.. :)
01:01:24 <dmwit> newsham: then (2^10)^(2^10) ?= 2^(10*2^10)
01:01:38 <dmwit> ...not 2^100?
01:01:47 <dmwit> agh
01:01:49 <dmwit> same mistake again
01:01:51 <newsham> oops did i botch the first step?
01:01:56 <newsham> heh
01:02:00 <newsham> i did indeed.. awesome
01:02:14 <shachaf> > 2^2^2
01:02:15 <dmwit> Oh no, I got it right this time.
01:02:15 <lambdabot>   16
01:02:16 <shachaf> > (2^2)^2
01:02:17 <lambdabot>   16
01:02:18 <shachaf> QED
01:03:16 <mm|swarm> shouldn't it be the otherway round?
01:03:21 <mm|swarm> > 2 ^ (2 ^ 2)
01:03:23 <lambdabot>   16
01:03:32 <mm|swarm> > 4 ^ (4 ^ 4)
01:03:34 <lambdabot>   134078079299425970995740249982058461274793658205923933777235614437217640300...
01:03:35 <mm|swarm> > 4 ^ 4 ^ 4
01:03:36 <lambdabot>   134078079299425970995740249982058461274793658205923933777235614437217640300...
01:03:40 <mm|swarm> > (4 ^ 4) ^ 4
01:03:42 <lambdabot>   4294967296
01:03:46 <mm|swarm> ah, it's good
01:03:54 <mm|swarm> exactly how it was supposed to work
01:03:58 <mm|swarm> coming from Math
01:04:01 <shachaf> What part of "QED" didn't you understand?
01:04:39 <archeyDevil> @hackage CReal
01:04:39 <lambdabot> http://hackage.haskell.org/package/CReal
01:04:45 <archeyDevil> @hoogle CReal
01:04:46 <lambdabot> No results found
01:04:47 <dmwit> newsham: How'd I do? (2^10)^(2^10)^(2^10) = (2^10)^(10*2^10) = ((2^10)^(2^10))^10 = (2^(10*2^10))^10 = 2^(100*2^10)
01:04:52 <archeyDevil> What to import?
01:05:04 <dmwit> badly, I suspect
01:05:16 <dmwit> Since 100*2^10 looks a bit small
01:05:17 <shachaf> You're making life hard with all those 2s and 10s.
01:05:25 <avpx> archeyDevil: Data.Number.CReal in the numbers package.
01:05:59 <mm|swarm> sorry, I didn't read above :">
01:06:31 <shachaf> (2^10)^(2^10) /= (10*2^10)
01:06:49 <dmwit> shachaf: (2^10)^(2^10) ?= 2^(10*2^10)
01:06:56 <dmwit> oh, yes
01:06:58 <avpx> !=
01:07:17 <dmwit> Good, that explains why it was so small at the end. =)
01:10:27 <newsham> 2^(10 * (2^(10 * 2^10))) ?
01:11:13 <shachaf> That would be for the opposite parenthesization.
01:11:53 <newsham> (2^10) ^ ((2^10) ^ (2^10)) -> (2^10) ^ (2^(10 * 2^10)) ?
01:12:45 <newsham> didnt i get the association right?
01:13:48 <archeyDevil> > 2^20 == 1024*1024
01:13:49 <lambdabot>   True
01:14:06 <archeyDevil> Can I invite lambdabot into my own channel???? :-)
01:14:34 <shachaf> Just /msg lambdabot
01:14:37 <newsham> > 1024^1024 == 2^(10 * 2^10)
01:14:38 <lambdabot>   True
01:14:57 <shachaf> I think she might be mildly allergic to question marks, though, so be careful.
01:15:25 <archeyDevil> > 1024^2 == 1048576 -- Did that in my head
01:15:27 <lambdabot>   True
01:15:33 <archeyDevil> :-)
01:16:24 <archeyDevil> ?
01:16:35 <archeyDevil> Spamming me in query xD
01:16:39 <newsham> > True -- did that in my head
01:16:40 <lambdabot>   True
01:16:49 <archeyDevil> newsham: lol
01:17:07 <newsham> ?check True
01:17:08 <lambdabot>   "OK, passed 500 tests."
01:17:46 <newsham> ?check \a b c -> (a^b)^c = a ^ (b*c)
01:17:46 <lambdabot>   Parse error at "=" (column 19)
01:17:51 <newsham> ?check \a b c -> (a^b)^c == a ^ (b*c)
01:17:52 <lambdabot>   "*Exception: Negative exponent
01:18:13 <newsham> ?check \a b c -> b > 0 && c > 0 ==> (a^b)^c == a ^ (b*c)
01:18:15 <lambdabot>   Not in scope: `==>'Precedence parsing error
01:18:15 <lambdabot>      cannot mix `GHC.Classes.>'...
01:18:16 <archeyDevil> what does the \a mean?
01:18:30 <newsham> > (\a b c -> a + b * c) 1 2 3
01:18:31 <shachaf> ASCII character BEL
01:18:32 <lambdabot>   7
01:18:42 <fmap> @check \a b c -> a < 0 || b < 0 || c < 0 || (a^b)^c == a ^ (b*c)
01:18:44 <lambdabot>   "OK, passed 500 tests."
01:18:48 <archeyDevil> shachaf: I mean, in that context  lol
01:18:56 <shachaf> archeyDevil: It's a lambda.
01:19:16 <shachaf> You might want to read an introduction to Haskell syntax before saying operating systems ought to be written in Haskell. :-)
01:19:37 <newsham> shachaf: didnt we talk earlier about internet arguments?
01:19:39 <archeyDevil> I didn't say that. Said it'd be awesome. (Been using XMonad for ages)
01:20:17 <shachaf> newsham: True.
01:20:20 <shachaf> (I did that in my head!)
01:20:27 <newsham> :)
01:21:18 <newsham> the hour of sleep is upon me.  cheers
01:21:33 <arbn> Hmm. Is there any sort of general strategy if I have an instance of ReaderT and want to pass that to a function that requires something of type IO ()?
01:21:47 <shachaf> @localtime newsham
01:21:49 <lambdabot> Local time for newsham is Sat Jul  7 22:20:56 2012
01:22:25 <shachaf> ReaderT r IO ()?
01:24:30 * hackagebot http-conduit 1.5.0.2 - HTTP client package with conduit interface and HTTPS support.  http://hackage.haskell.org/package/http-conduit-1.5.0.2 (MichaelSnoyman)
01:25:51 <archeyDevil> > length (1024^1024)
01:25:53 <lambdabot>   No instance for (GHC.Num.Num [a])
01:25:54 <lambdabot>    arising from the literal `1024' at <in...
01:26:07 * archeyDevil wants the length of (1024^1024)^1024 -- How??
01:26:49 <mm|swarm> > length . show $ (1024 ^ 1024) ^ 1024
01:26:53 <lambdabot>   mueval-core: Time limit exceeded
01:27:18 <mm|swarm> 3156529
01:27:33 <mm|swarm> on my own ghci instance :)
01:28:06 <mm|swarm> but you could compute this in other way
01:28:35 <mm|swarm> (1024 ^ 1024) ^ 1024 is 1024 ^ (1024 * 1024)
01:28:45 <mm|swarm> that is 1024 ^ (2 ^ 20)
01:28:55 <mm|swarm> that is (2 ^ 10) ^ (2 ^ 20)
01:29:07 <mm|swarm> that is 2 ^ (10 * 2 ^ 20)
01:29:19 <mm|swarm> now, we take lg
01:29:49 <mm|swarm> and get to lg((1024 ^ 1024) ^ 1024) = 10*2^20*lg(2)
01:30:52 <mm|swarm> > 10 * 2 ^20 * lg(2)
01:30:53 <lambdabot>   Not in scope: `lg'
01:30:59 <mm|swarm> > 10 * 2 ^20 * log10(2)
01:31:00 <lambdabot>   Not in scope: `log10'
01:31:37 <mm|swarm> > 10 * 2 ^20 * logBase 10 2
01:31:38 <lambdabot>   3156528.287333547
01:31:57 <mm|swarm> thus, the result has 315629 digits
01:32:13 <mm|swarm> > ceiling $ 10 * 2 ^20 * logBase 10 2
01:32:15 <lambdabot>   3156529
01:32:40 <mm|swarm> archeyDevil: ^
01:34:25 <archeyDevil> Awesome. :)
01:34:51 <mm|swarm> if you need the lenght in other base what you need to do is to change the first arg of logBase
01:35:00 <mm|swarm> > e
01:35:01 <lambdabot>   e
01:35:09 <mm|swarm> for example in base e (the optimal base)
01:35:13 <mm|swarm> > ceiling $ 10 * 2 ^20 * logBase e 2
01:35:15 <lambdabot>   No instance for (GHC.Real.RealFrac SimpleReflect.Expr)
01:35:15 <lambdabot>    arising from a us...
01:35:51 <mm|swarm> > ceiling $ 10 * 2 ^20 * logBase 2.71828183 2
01:35:52 <lambdabot>   7268175
01:35:53 <archeyDevil> mm|swarm: How would a number be of decimal length? o.O
01:36:01 <cbarrett> anyone know much about the FFI?
01:36:04 <archeyDevil> > 10 * 2 ^20 * logBase 10 2
01:36:05 <lambdabot>   3156528.287333547
01:36:16 <mm|swarm> archeyDevil: this is the logarithm
01:36:28 <cbarrett> I'm binding to a C API and it's got an object (ptr to opaque data) with some accessor & mutator methods
01:36:29 <mm|swarm> to get the length you have to take the ceiling
01:36:45 <archeyDevil> which basicly just rounds up
01:36:48 <cbarrett> I get that the mutators need to be in the IO monad, but do the accesors?
01:36:50 <mm|swarm> exactly
01:37:09 <mm|swarm> the logarithm of a number n in base b gives the exponent e such that b ^ e == n
01:37:20 <archeyDevil> Still confused from the decimal part comes from?
01:37:34 <archeyDevil> Ahh.
01:37:35 <archeyDevil> I see
01:37:54 <mm|swarm> ? check \b n -> b ^ (logBase b n) == n
01:37:57 <mm|swarm> ?check \b n -> b ^ (logBase b n) == n
01:37:58 <lambdabot>   Add a type signature
01:38:00 <archeyDevil> > 10 * 2 ^20 * logBase
01:38:01 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a -> a)
01:38:01 <lambdabot>    arising from a use...
01:38:10 <archeyDevil> > 10 * 2 ^20 * logBase 10
01:38:12 <lambdabot>   Overlapping instances for GHC.Show.Show (t -> t)
01:38:12 <lambdabot>    arising from a use of `...
01:38:12 <mm|swarm> > logBase 2 4
01:38:13 <lambdabot>   2.0
01:38:18 <mm|swarm> but
01:38:18 <archeyDevil> > 10 * 2 ^20 * logBase 10 2
01:38:19 <lambdabot>   3156528.287333547
01:38:21 <mm|swarm> > logBase 2 5
01:38:22 <lambdabot>   2.321928094887362
01:38:26 <archeyDevil> > 10 * 2 ^20 * logBase 2 10
01:38:27 <lambdabot>   3.483294074024611e7
01:38:46 <mm|swarm> because there is no integer power of 2 which can get you 5
01:39:01 <archeyDevil> I see.
01:39:08 <archeyDevil> > 5/2
01:39:09 <lambdabot>   2.5
01:39:14 <mm|swarm> archeyDevil: the last output shows that your computation needs 3.48e7 binary digits :)
01:39:38 <mm|swarm> > ceiling $ 10 * 2 ^20 * logBase 2 10
01:39:39 <lambdabot>   34832941
01:40:07 <mm|swarm> 34832941 binary digits are needed for 10 ^ (10 * 2 ^ 20)
01:40:22 <archeyDevil> mm|swarm: I know. I've memorized it from years ago from playing with wolfram alpha :P
01:40:37 <mm|swarm> :D
01:40:43 <archeyDevil> 3.48e7 that is.
01:41:12 <archeyDevil> > 3.6e5
01:41:14 <lambdabot>   360000.0
01:41:23 <archeyDevil> Yay, it knows e :)
01:41:27 <archeyDevil> > 3.48e7
01:41:28 <lambdabot>   3.48e7
01:41:33 <archeyDevil> fail.
01:41:41 <archeyDevil> > 3.48e7 :: CReal
01:41:42 <lambdabot>   34800000.0
01:41:46 <archeyDevil> > 3.48e7 :: Int
01:41:47 <archeyDevil> lol
01:41:47 <lambdabot>   No instance for (GHC.Real.Fractional GHC.Types.Int)
01:41:47 <lambdabot>    arising from the lit...
01:41:52 <archeyDevil> :(
01:42:09 <archeyDevil> ?check  3.48e7
01:42:10 <lambdabot>   Add a type signature
01:42:26 <archeyDevil> > 3.48e7 :: Expr
01:42:27 <lambdabot>   3.48e7
01:42:32 <archeyDevil> >.<
01:42:57 <archeyDevil> > 2^80 :: Expr
01:42:59 <lambdabot>   2 * 2 * (2 * 2) * (2 * 2 * (2 * 2)) * (2 * 2 * (2 * 2) * (2 * 2 * (2 * 2)))...
01:43:07 <archeyDevil> :)
01:43:28 <archeyDevil> :t e
01:43:29 <lambdabot> Expr
01:43:36 <archeyDevil> o.O
01:43:56 <mm|swarm> > pi
01:43:57 <archeyDevil> > 3.48e17 :: Expr
01:43:57 <lambdabot>   3.141592653589793
01:43:58 <lambdabot>   3.48e17
01:44:09 <archeyDevil> > pi :: Expr
01:44:10 <lambdabot>   pi
01:44:14 <archeyDevil> :(
01:44:30 <archeyDevil> Whats the expression to get pi? :P
01:44:32 <mm|swarm> it is not an algebraic number
01:45:18 <archeyDevil> > 7/3
01:45:19 <lambdabot>   2.3333333333333335
01:45:30 <mm|swarm> have a look at http://en.wikipedia.org/wiki/Approximations_of_%CF%80
01:45:34 <archeyDevil> > 22/7
01:45:36 <mm|swarm> multiple aproximations for pi
01:45:36 <lambdabot>   3.142857142857143
01:45:49 <ClaudiusMaximus> > toRational pi
01:45:50 <lambdabot>   884279719003555 % 281474976710656
01:45:57 <mm|swarm> > exp 1
01:45:58 <lambdabot>   2.718281828459045
01:46:20 <mm|swarm> > toRational $ exp 1
01:46:21 <lambdabot>   6121026514868073 % 2251799813685248
01:46:40 <archeyDevil> > 1e50
01:46:41 <lambdabot>   1.0e50
01:46:47 <archeyDevil> > 1e5
01:46:48 <lambdabot>   100000.0
01:47:02 <shachaf> archeyDevil: You might want to /msg lambdabot at this point. :-)
01:47:02 <archeyDevil> How to force it to expand?
01:47:11 <avpx> Or install ghci?
01:47:17 * archeyDevil has ghci :P
01:47:17 <shachaf> Expand what?
01:47:32 <archeyDevil> 3.48e7 -- expand.
01:47:51 <archeyDevil> 3.483294074024611e7 **
01:48:13 <archeyDevil> pi e 5
01:48:16 <archeyDevil> > pi e 5
01:48:17 <lambdabot>   3.141592653589793
01:48:32 <archeyDevil> > pi e 0.5
01:48:33 <lambdabot>   3.141592653589793
01:48:37 <archeyDevil> lol
01:48:47 * archeyDevil halts failing and shuhes
01:49:06 <archeyDevil> > pi `e` 5
01:49:07 <lambdabot>   Couldn't match expected type `a -> t1 -> t'
01:49:08 <lambdabot>         against inferred type `...
01:49:14 <archeyDevil> Okay..
02:13:17 <nand`> archeyDevil: you might be interested in the CReal Floating instance's pi definition:
02:13:18 <nand`> pi = 16 * atan (fromRational (1 % 5))
02:13:20 <nand`>                 - 4 * atan (fromRational (1 % 239))
02:14:17 <nand`> though there are a number of curious aspects about that definitin that I don't quite follow
02:14:32 <nand`> for example why fromRational (1 % 5) instead of 1 / 5  (which is what its fromRational expands to either way)
02:17:52 <mcstar> color in ghci http://imgur.com/n4Da1
02:18:36 <nand`> and by ‚Äúa number of‚Äù I really mean just that one. the other one I was confused about was not pi
02:18:57 <danbst> @pl \a b -> xor a b
02:18:57 <lambdabot> xor
02:19:10 * archeyDevil is offline.
02:19:19 <danbst> @pl \a b ->chr $ xor (ord a) (ord b)
02:19:19 <lambdabot> (chr .) . (. ord) . xor . ord
02:19:37 <nand`> :t chr .: xor <$> ord <*> ord
02:19:38 <lambdabot> Char -> Char
02:20:02 <mcstar> :t (chr . xor) `on` ord
02:20:04 <lambdabot>     Couldn't match expected type `b -> c' against inferred type `Char'
02:20:04 <lambdabot>     In the first argument of `(.)', namely `chr'
02:20:04 <lambdabot>     In the first argument of `on', namely `(chr . xor)'
02:20:08 <nand`> hmm, no, not quite correct
02:20:14 <mroman> whenever there is a (.foo) it's probably not the best thing to use ;)
02:20:27 <nand`> :t (chr .: xor) `on` ord
02:20:29 <lambdabot> Char -> Char -> Char
02:20:37 <danbst> maybe `fmap fmap fmap` can help? =)
02:20:52 <mcstar> :t (.:)
02:20:53 <danbst> oh
02:20:53 <lambdabot> forall a b (f :: * -> *) (g :: * -> *). (Functor f, Functor g) => (a -> b) -> f (g a) -> f (g b)
02:20:57 <XexonixXexillion> :t chr . (liftM2 xor ord ord)
02:20:58 <lambdabot> Char -> Char
02:21:27 <mcstar> nand`: im confused, why the .:?
02:21:45 <nand`> :t xor
02:21:47 <lambdabot> forall a. (Bits a) => a -> a -> a
02:21:50 <nand`> :t (Prelude..)
02:21:51 <danbst> where are .: and `on` defined?
02:21:51 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
02:22:04 <startling> @src (.:)
02:22:04 <lambdabot> Source not found. You untyped fool!
02:22:05 <mcstar> danbst: on is in Data.Function
02:22:37 <shachaf> (.:) = (.) . (.)
02:22:40 <shachaf> It's not a real function.
02:22:50 <raymank26> hi all. Can I use a pattern-matching with Data.Vector?
02:22:59 <shachaf> Alternatively, f .: g = \x y -> f (g x y)
02:23:02 <raymank26> Like lists (:) for example
02:23:07 <nand`> mcstar: xor is a -> (a -> a); where (a -> a) corresponds to b in the type of (.). So to put something like chr after it, it would have to have type (a -> a) -> b; which it doesn't have. This is where (.:) comes in handy, it lifts ‚Äòtwo‚Äô parameters to the other side before sequencing ‚Äòchr‚Äô after it
02:23:14 <shachaf> raymank26: Not like (:) for lists.
02:23:20 <shachaf> raymank26: But see "view patterns".
02:23:38 <raymank26> ok. thanks
02:23:38 * shachaf wonders what the word "lift" means these days.
02:23:43 <danbst> thanks, works!
02:23:45 <pharaun> hello - data Rec = Rec { hi :: Integer, field2 :: Int } works but data Foo = Foo { FooTotal :: Int } does not.... am i missing something here ?
02:23:53 <mcstar> nand`: oh, right, (.) composes single argument functions, silly me
02:24:01 <nand`> shachaf: would ‚Äòmove‚Äô have been better? ‚Äòcarry‚Äô ?
02:24:29 <XexonixXexillion> pharaun: labels can't be uppercase, it should be fooTotal
02:25:31 <pharaun> XexonixXexillion: oh >_< thanks
02:25:44 <pharaun> XexonixXexillion: thanks!
02:25:53 <pharaun> totally could have used a better error message for that one
02:37:44 <XexonixXexillion> :t (.).(.)
02:37:45 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
02:39:56 <raek> is there an existing name for "liftM2 (,)" ?
02:46:34 <shachaf> No name shorter than "liftM2 (,)"
02:47:23 <ion> liftA2 (,) :-P
02:49:46 <shachaf> @let zipC = zipWith (\a b r -> r a b)
02:49:48 <lambdabot>  Defined.
02:49:57 <shachaf> @ty \xs ys -> map ($(,)) (zipC xs ys)
02:49:58 <lambdabot> forall a b. [a] -> [b] -> [(a, b)]
02:50:11 <shachaf> Obviously that's the best zip primitive!
03:00:36 <raymank26> shachaf: view patterns are great!
03:00:47 <raek> shachaf: some kind of CPS zip?
03:01:30 <shachaf> raek: Something like that.
03:02:10 <shachaf> It's like zipWith, except instead of one function you can use a different function for every element!
03:02:24 <shachaf> Hmm, maybe it should be more polymorphic.
03:02:41 <shachaf> As in [a] -> [b] -> [forall t. (a -> b -> t) -> t]
03:07:49 <eikke> > let a = Nothing
03:07:51 <lambdabot>   not an expression: `let a = Nothing'
03:07:59 <eikke> > a = Nothing
03:08:00 <lambdabot>   <no location info>: parse error on input `='
03:08:15 <ion> > let a = Nothing in a
03:08:17 <lambdabot>   Nothing
03:08:34 <eikke> ion: won't help because I see different behaviour that way in ghci :)
03:08:54 <shachaf> lambdabot is not ghci, not claims to be.
03:09:03 <eikke> Prelude Data.Maybe> let a = Nothing
03:09:03 <eikke> Prelude Data.Maybe> let (Just a') = a
03:09:03 <eikke> Prelude Data.Maybe> :t a'
03:09:04 <eikke> a' :: GHC.Prim.Any
03:09:38 <eikke> whilst when trying those in a line of lets I get a pattern match failure
03:09:45 <eikke> (as somewhat expected)
03:09:58 <shachaf> ?
03:10:06 <shachaf> :t shouldn't ever give you a pattern-match failure.
03:10:07 <ion> @type let a = Nothing; Just a' = a in a'
03:10:08 <lambdabot> parse error (possibly incorrect indentation)
03:10:09 <lambdabot> forall t. t
03:10:42 <eikke> shachaf: aha
03:12:15 <mroman> I wish haskell would enforce "all-matching-patterns".
03:12:35 <dmwit> mroman: -fwarn-incomplete-patterns -Werror
03:13:00 <mroman> That should be by default at least a warning.
03:13:33 <dmwit> I like the name of -fwarn-dodgy-exports
03:13:49 <arcatan> -fwarn-dodgy-experts
03:14:07 <dmwit> It's very British.
03:14:21 <dmwit> "Oy, that looks a bit dodgy!"
03:14:40 <ion> mroman: ghc-options: -Werror -Wall
03:14:54 <dmwit> Hackage won't accept a package with that line.
03:15:04 <ion> Huh
03:15:08 <ion> Why?
03:15:16 <dmwit> It's too fragile. GHC often adds new warnings.
03:15:22 <shachaf> Hmm, how does ¬´show Nothing¬ª work?
03:15:29 <shachaf> Does Nothing default to a type?
03:15:39 <ion> @type show `asAppliedTo` Nothing
03:15:40 <lambdabot> forall a. (Show a) => Maybe a -> String
03:15:43 <dmwit> shachaf: Yes, it gets defaulted.
03:16:02 <shachaf> Oh, this is a ghci thing.
03:16:03 <ion> @type (show `asAppliedTo` Nothing) (Just ?x)
03:16:04 <lambdabot> forall a. (Show a, ?x::a) => String
03:16:12 * shachaf should learn not to trust ghci.
03:16:26 <mroman> -fwarn-tabs
03:16:36 <dmwit> -fwarn-inconsistent-tabs
03:16:50 <dmwit> when you use tabs in a way that depends on them being comparable to some number of spaces
03:16:54 <mroman> Can you specify warnings that should be treated as errors?
03:17:01 <ion> > typeOf (undefined `asTypeIn` \x -> (show `asAppliedTo` Nothing) (Just x))
03:17:03 <lambdabot>   ()
03:17:11 <shachaf> dmwit on his crusade.
03:17:12 <dmwit> mroman: -Werror, like I said in my very first suggestion to you. =)
03:17:27 <shachaf> dmwit: "warnings that" vs. "that warnings"
03:17:27 <dmwit> I actually have a bug in my bug tracker to implement some such warning.
03:17:31 <shachaf> "Ah, English." :-)
03:17:31 <mroman> dmwit: That's not the same.
03:17:38 <mroman> -Werror treats all warnings as errors.
03:17:38 <dmwit> ah
03:17:39 <dmwit> English
03:17:43 <mroman> Not just 'some warnings'.
03:17:45 <dmwit> No, there's currently no way to do that.
03:18:15 <mroman> like gccs -Werror=
03:18:31 <dmwit> There's also currently no way to turn off warnings temporarily in a file, either.
03:24:15 <mroman> I want more patterns!
03:24:22 <mroman> for lists.
03:25:38 <mroman> like (xs:x) instead of (x:xs)
03:26:00 <shachaf> let xs:x = [1..] in x
03:26:20 <mroman> > let xs:x = [1,2,3] in x
03:26:22 <lambdabot>   [2,3]
03:26:23 <ion> mroman: See Data.Sequence
03:26:34 <mroman> I want x to be last :)
03:27:47 <ion> > let (xs Seq.:> x) = Seq.viewR (Seq.fromList [1,2,3]) in x
03:27:47 <mroman> ion: That does not extend pattern syntax?
03:27:48 <lambdabot>   Not in scope: `Seq.viewR'
03:27:53 <ion> > let (xs Seq.:> x) = Seq.viewr (Seq.fromList [1,2,3]) in x
03:27:54 <lambdabot>   3
03:28:05 <mroman> Interesting.
03:28:38 <shachaf> > let (Seq.viewr -> xs Seq.:> x) = Seq.fromList [1,2,3] in x
03:28:39 <lambdabot>   3
03:28:45 <mroman> :t (Seq.:>)
03:28:46 <lambdabot> forall a. Seq.Seq a -> a -> Seq.ViewR a
03:29:02 <mroman> You can actually write operators for patterns?
03:29:17 <shachaf> :> is a constructor.
03:29:30 <mroman> I see.
03:29:38 <mroman> Still, not usable for golfing that way ;)
03:34:43 <mroman> http://codepad.org/ReGGoynu
03:34:55 <mroman> Haskell just keeps getting moere awesome.
03:35:01 <mroman> *more
03:37:02 <dmwit> > 100/7
03:37:03 <lambdabot>   14.285714285714286
03:38:16 <ppilate> mroman: is that another hack of yours?
03:39:02 <mroman> ppilate: What do you mean by that?
03:40:08 <aristid> mroman: so what impresses you there is the possibility of infix constructors? :)
03:41:23 <mroman> aristid: I thought constructors had to be like
03:41:31 <mroman> Uppercase + text
03:41:54 <shachaf> whoa, dude
03:41:57 <shachaf> Impressive.
03:42:27 <aristid> mroman: : counts as uppercase
03:42:39 <mekeor> mroman: (:) is a constructor‚Ä¶ (:+) is constructor‚Ä¶ so‚Ä¶ nothing surprising‚Ä¶
03:42:49 <mroman> Yes.
03:42:52 <aristid> shachaf: are you mocking mroman? :P
03:42:55 <mroman> It's just a infix constructor.
03:42:58 <mroman> I know.
03:43:19 <shachaf> aristid: I'm mocking no one.
03:43:27 <shachaf> Sum types are pretty impressive!
03:43:32 <shachaf> Most languages don't support them.
03:43:35 <shachaf> It's crazy.
03:43:49 <mcstar> heatstroke
03:43:54 <aristid> shachaf: hmm. yeah, sum types are the shit
03:44:20 <aristid> shachaf: even the crazy C++ people recognize that, so they created it with templates
03:44:31 <shachaf> They did?
03:44:36 <aristid> boost::variant
03:44:43 <mcstar> tagged unions?
03:44:46 <aristid> it's only discriminated with numbers, but still
03:45:28 <shachaf> Oh, well, that's a pretty special-case awkward thing. But yes.
03:45:45 <shachaf> I think there's also some "OO design pattern" which is an awkward way to simulate sum types.
03:46:11 <aristid> oh actually they can also be discriminated by type
03:46:33 <aristid> shachaf: right, the visitor pattern or so? that's _extra_-awkward tho
03:47:27 <shachaf> aristid: To be fair, OO-style objects can be somewhat awkward in Haskell too. :-)
03:47:36 <mcstar> i simple root-leafes class hierarchy can be interpreted as a sum type too
03:47:48 <mcstar> i->a
03:47:55 <ppilate> mroman: is this your modifed version of GHC?
03:48:12 <aristid> shachaf: you mean like... SomeException? :>
03:48:27 <shachaf> Ew, SomeException.
03:48:29 <mroman> ppilate: What?
03:48:46 <ppilate> mroman: sorry, nvm
03:48:55 <shachaf> SomeException is actually giving up on the whole thing and just using Data.Dynamic.
03:48:57 <mcstar> ppilate: thats down to earth haskell
03:49:02 <mroman> I have no idea what your angle is.
03:49:05 <ppilate> I didn't know one could specify infix constructors
03:49:17 <aristid> shachaf: oh? in ghc 7.6?
03:49:25 <shachaf> Er.
03:49:27 * shachaf must have misspoken.
03:49:55 <shachaf> No, I was thinking of something else.
03:50:12 <aristid> oh well
03:50:22 <shachaf> It doesn't actually use Data.Dynamic.
03:50:30 <shachaf> Anyway it's a hack.
03:50:31 <aristid> no it doesn't as of this date :)
03:51:28 <shachaf> It's an equivalent of Data.Dynamic, though.
03:52:20 <shachaf> class (Typeable e, Show e) => Exception e where toException :: e -> SomeException; toException = SomeException; fromException :: SomeException -> Maybe e; fromException (SomeException e) = cast e
03:57:04 <mcstar> it'd be great to have lambda classes in OO languages
03:57:09 <aristid> shachaf: yes, just limited to the Exception hierarchy. which might be considered a good thing
03:57:32 <shachaf> Sure.
03:57:45 <shachaf> But SomeException as a whole is still evil. :-(
03:58:18 <mcstar> like, in haskell you can change a record, rec{a=x}, in a lambda class, you could easily subclass a class with some similar syntax...
03:58:55 <mekeor> mcstar: what is a lambda class?
03:58:58 <mcstar> obviously i havent worked out the details
03:59:02 <shachaf> What does that have to do with lambdas?
03:59:03 <mcstar> mekeor: unnamed class
03:59:34 <mcstar> that mirrors the use of lambda functions
03:59:35 <mekeor> mcstar: (can you gimme an) example?
03:59:53 <mcstar> mekeor: not really, its just a notion
04:00:11 <shachaf> :-(
04:00:27 * mekeor looks around‚Ä¶
04:00:31 <dmwit> Java has unnamed classes...
04:00:58 <mcstar> for example, i need to subclass some class, but i know i only want to change one thing
04:01:03 <mcstar> override some method, idk
04:01:12 <mcstar> and dont want to give it a name
04:01:19 <mcstar> and write the whole boilerplate
04:01:21 <dmwit> http://docstore.mik.ua/orelly/java-ent/jnut/ch03_12.htm
04:01:39 <mcstar> so, i'd just do it on the fly, with some nice syntax, and pass it to something
04:01:47 <mcstar> and be done with it
04:02:00 <dmwit> You use them all the time, e.g. their version of forkIO is easiest to use by making an anonymous class to hold your closure.
04:02:25 <mcstar> i havent used java except a toy-loop
04:02:58 <mcstar> dmwit: thanks for the link, good to know it exists
04:03:26 <mekeor> mcstar: ah, got it.
04:06:57 <mcstar> does ML have records?
04:07:09 <companion_cube> ocaml does
04:07:13 <mcstar> SML?
04:07:31 <mcstar> cause, when you compare ocaml and haskell
04:07:36 <mcstar> theres a big difference
04:07:44 <mcstar> ocaml records dont use a constructor like haskell
04:07:53 <mcstar> i find it really weird
04:08:06 <mcstar> a record is identified by the accesors
04:08:16 <mcstar> or fields
04:10:51 <mcstar> maybe im the only one that finds this weird
04:11:48 <dmwit> It's very different, yes.
04:11:53 <augur> mcstar: what are you talking about
04:12:15 <mcstar> dmwit: did you work with both?
04:12:32 <dmwit> I haven't used OCaml much.
04:12:49 <dmwit> But I'm vaguely familiar with various record system proposals.
04:14:14 <mcstar> augur: type oRecord = {x : Type1; y : Type 2} vs. data RecType = RecConstructor {x :: Type1, y :: Type2}
04:14:32 <augur> ah
04:14:56 <augur> agda is similar
04:15:21 <dmwit> You typically want some ability to do type-level programming with that style.
04:15:41 <dmwit> Maybe not complicated programming; I've seen some passable systems that get away with just some kind of "disjoint" predicate.
04:16:17 <augur> agda does it like   record RecType : Set where field x : Foo ; y : Bar
04:16:27 <augur> and you construct either by adding a custom constructor
04:16:39 <augur> or by doing record { x = foo ; y = bar }
04:18:03 <JamesVagabond> Hello there.
04:18:16 <shachaf> JamesVagabond!
04:18:18 <mekeor> Hi =)
04:18:18 <shachaf> G'day.
04:18:38 <mcstar> shachaf: aussie?
04:18:54 <antihero> I wonder if it would be feasible to get Haskell working with Light Table when it comes out
04:19:15 <mekeor> that'd be cool.
04:20:00 <antihero> To do this I'd have to 1. Learn haskell, 2. wait 'till Light Table comes out, 3. learn whatever lighttable is written in and 4. extend it somehow
04:20:02 <antihero> ugh
04:20:36 <mekeor> hehe :D
04:22:15 <antihero> I kinda want to start doing FP, I've whittled the choices down to Haskell or Clojure
04:22:28 * oish waves
04:23:14 <antihero> Learn You A Haskell looks nice
04:23:23 <mcstar> reads better
04:23:37 <antihero> :)
04:23:47 <ethercrow> you can patch yi until it's better than light table
04:23:53 <JamesVagabond> Ah, so I'm not the only one who's just starting to learn the language, huh?
04:24:26 <shachaf> JamesVagabond: There are 800 people in this channel.
04:24:33 <shachaf> You're probably not the only one who anything.
04:24:37 <mcstar> JamesVagabond: you have to worry, there are only a few dozens downloads of GHC left..
04:24:48 <antihero> I'm using ST2 atm
04:24:52 <mcstar> worry->hurry
04:24:54 <mcstar> omg
04:25:07 <JamesVagabond> Oh. I didn't even notice that there are so many people here.
04:25:17 <shachaf> You have to keep in mind that half the people in this channel don't know what they're talking about and can't be trusted about Haskell.
04:25:22 <shachaf> (Does that half include me? Who Knows?!)
04:26:06 <hiptobecubic> Half is pretty generous i think
04:26:11 <mcstar> at least with a language its easy, you try it out, if it doesnt work, you recieved bad advice
04:26:36 <hiptobecubic> I think most of the people here haven't said anything at all in the last year
04:26:42 * chu has no idea what Haskell even is, just lurks because I love Haskell Curry
04:26:49 <antihero> What's a good datastore to pair with haskell?
04:26:56 <antihero> Redis?
04:27:31 <shachaf> What's a good datastore to pair with C?
04:27:36 <hiptobecubic> antihero, too many free variables.
04:27:38 <ion> shachaf: Mnesia
04:27:48 <hiptobecubic> flat files + sed
04:27:55 <antihero> IE one with a mature library, low latency, etc?
04:28:04 <dmwit> I think there are Hackage packages for most of the common stores. redis, half a dozen variations on SQL, plus we have some of our own pure-Haskell stores
04:28:14 <antihero> cool
04:28:33 <antihero> right I need to stop asking dumb questions and read the book
04:39:50 <antihero> does haskell have an equivalent to virtualenv?
04:41:22 <eikke> antihero: cabal-dev
04:41:42 <eikke> (at least if that's what you're looking for wrt features)
04:42:00 <eikke> there's something like virtualhenv or something as well, but never used it myseld
04:45:06 <mekeor> i want/need something like cabal/hackage but for a private project.
04:46:42 <mekeor> what do/can you suggest (for that (pupose))?
04:50:34 <fmap> why hackage is not suitable for private project?
04:52:34 <mekeor> is it? can i have private projects there? or are all projects public?
04:52:38 <mekeor> fmap?
04:54:38 <fmap> mekeor: well, if by "private" you mean "closed source" then hackage is apparently not suitable, yes
05:03:47 <ksf> zomg I need help with an error
05:03:51 <ksf> http://hpaste.org/71089
05:04:24 <mm|swarm> should I use warp with nginx/apache or warp alone will suffice?
05:04:33 <ksf> depends.
05:04:52 <mm|swarm> assume the worst
05:04:57 <ksf> for most deployments, warp should suffice.
05:05:12 <ksf> but there's a reason people chain web servers, eg. to load balance.
05:05:12 <mauke> ksf: what are the types of gVisualId, gVisualClass, gWord8?
05:05:20 <dmwit> ksf: Probably one of the other functions in that line has not been applied to enough arguments.
05:05:22 <shachaf> ksf: I don't think that has enough information to help.
05:05:25 <shachaf> Like the type of gWord8.
05:05:29 <mm|swarm> right now I want to serve some static pages and a piece of dynamic content which will not be visited too often
05:05:30 <ksf> gWord8 is Get Word8
05:05:38 <ksf> cereal's getWord8
05:05:41 <mauke> er, right. that was actually in the paste
05:05:49 <mm|swarm> ksf: thanks
05:05:54 <dmwit> ksf: gVisualId, gVisualClass, and getPadding are the prime suspects.
05:05:54 <mm|swarm> then I'll chain them
05:06:04 <ksf> gVisualId is generated just like gVisualType
05:06:11 <mauke> but what is its type?
05:06:13 <ksf> getPadding is undefined.
05:06:25 <ksf> well, I hoped ghc would infer it.
05:06:33 <mauke> as what?
05:06:35 <ksf> it should be Get VisualId
05:06:40 <mauke> well, is it?
05:07:01 <ksf> bugger.
05:07:05 <ksf> gVisualId (xhb___match___k) = (return (VisualId (xhb___match___k)))
05:07:06 <ksf> \
05:07:12 * dmwit wins the prize
05:07:12 <ksf> so much about generating code.
05:07:29 <antihero> does haskell follow bodmas
05:07:34 <mauke> let me guess, xhb___match___k :: Word32
05:07:51 <dmwit> antihero: yes
05:07:54 <antihero> taq
05:07:56 <antihero> *ta
05:08:01 <ksf> VisualId is a Word32 newtype, yes.
05:08:49 <ksf> gragh. somewhere my mind bailed out when writing the enum code. it's accepting an argument instead of matching on a getted thing.
05:09:21 <ksf> thx all
05:11:07 <ksf> how does cereal's applicative instance work? unlimited lookahead?
05:14:24 <dmwit> lookahead?
05:14:41 <dmwit> f <*> g = parse f, then parse g, then apply?
05:14:56 <ksf> erm, alternative
05:15:17 <ksf> f <|> g = try f, don't try g because f has already consumed everything?
05:15:46 <dmwit> I think there's a comment in the documentation about this.
05:16:48 <dmwit> Hm, I must be remembering something weird.
05:17:09 <ksf> well, if push comes to shove, I'll switch over to attoparsec.
05:17:22 <dmwit> Yes, it seems to be unlimited lookahead.
05:17:23 <ksf> I really wish there was a regular-only parser
05:18:06 <dmwit> The failure continuation it passes re-appends any consumed bytes to the bytestring to be parsed.
05:18:26 <dmwit> http://hackage.haskell.org/packages/archive/cereal/0.3.5.2/doc/html/src/Data-Serialize-Get.html <- grep for instance MonadPlus Get here
05:18:30 <k0ral> hi, using "try" from Control.Exception, I'm getting "Ambiguous type variable `a0' in the constraint:  (Exception a0) arising from a use of `try'"
05:18:31 <ksf> as that's the only way to do constant-time and space lookahead... by refactoring the grammar.
05:18:52 <k0ral> but I surely don't want to mention the Exception type for each "try" line
05:18:52 <ksf> k0ral, ghc doesn't know which exception you want to catch.
05:19:01 <ksf> you have to give a type annotation, or hint it otherwise.
05:19:03 <mauke> k0ral: why not?
05:19:23 <ksf> most likely you don't want to catch all, do you?
05:19:35 <ksf> (and then there's always "SomeException"
05:19:44 * hackagebot xml-conduit 1.0.2 - Pure-Haskell utilities for dealing with XML with the conduit package.  http://hackage.haskell.org/package/xml-conduit-1.0.2 (MichaelSnoyman)
05:21:33 <k0ral> ksf: is there a way to give ghc a hint without writing down the type ?
05:21:53 <dmwit> k0ral: Yes, use the exception in a way that fixes its type.
05:21:57 <dmwit> e.g. pattern match on it
05:22:05 <ksf> if you e.g. often catch one exception, you can write a function for it and use that.
05:22:14 <ksf> (the function having an explicit type and thus fixing it)
05:22:15 <k0ral> mauke, ksf: I have a bunch of "try" lines, I really don't want to write the explicit type, it's tedious, boilerplate and ugly
05:22:28 <ksf> ghc doesn't care where the type comes from, but it has to have it.
05:22:36 <mauke> k0ral: how is ghc supposed to know the type then?
05:23:35 <k0ral> it's an IOError btw
05:24:23 <mauke> import System.IO.Error (try)
05:25:05 <k0ral> mauke: I used to do that, but I'm getting a warning according to which it is deprecated
05:25:11 <mauke> blargh
05:26:08 <mauke> try :: IO a -> IO (Either IOError a); try = Control.Exception.try
05:39:03 <oish> anyone know an efficient way to get last but one of a list. I am using last $ init xs but it is slow on large lists bcs it must transverse the whole thing...
05:39:04 <k0ral> I sorted it out by using ioeGetErrorString later on the code, so that ghc inferred the type
05:39:11 <osa1> how can I install a specific version of a library with cabal?
05:39:24 <hpaste> Expez pasted ‚ÄúWhat does ghc mean?‚Äù at http://hpaste.org/71090
05:40:02 <twanvl> Expez-: you can't take the sqrt of an Int
05:40:12 <twanvl> ?type sqrt
05:40:14 <lambdabot> forall a. (Floating a) => a -> a
05:40:19 <k0ral> oish: first . tail . reverse
05:40:49 <dmwit> oish: Don't use a list.
05:41:07 <dmwit> With linked lists, you have no choice but to traverse the whole list if you want to get to the end.
05:41:12 <fmap> oish: the efficient way to get last but one is to not use list
05:41:22 <oish> k0ral,dmwit: kk thx
05:41:24 <mauke> oish: lastButOne (x : _ :  []) = x; lastButOne (_ : xs) = lastButOne xs
05:41:33 <roconnor> my confession: http://r6.ca/blog/20120708T122219Z.html
05:41:45 <dmwit> lastButOne = (!!1) . reverse
05:42:07 <oish> fmap: sure
05:42:08 <Expez-> twanvl: and ceiling only works on 'RealFrac's? I have to use some function to cast the parameters I'm passing to these functions?
05:42:13 <oish> mauke: clever
05:42:27 <mauke> I think it's the opposite of clever
05:42:54 <twanvl> Expez-: ceiling of an integer makes little sense, because it is already an integer
05:43:18 <edwardk> roconnor: hah
05:43:25 <twanvl> Expez-: the problem is actually with sqrt, the argument should be a floating point number, not an integer
05:43:28 <roconnor> edwardk: :D
05:43:49 <twanvl> Expez-: you can convert an Int to a Double with realToFrac
05:43:52 <edwardk> roconnor: i'm slowly getting better about actually testing my code ;)
05:44:17 <edwardk> twanvl must be reasonably happy about all this hullabaloo wabout van laarhoven lenses ;)
05:44:27 <mauke> > realToFrac (1 :: Int)
05:44:29 <lambdabot>   1.0
05:44:35 <mauke> > fromIntegral (1 :: Int)
05:44:37 <lambdabot>   1
05:44:37 * twanvl is :)
05:45:27 <Expez-> twanvl: This worked fine in ghci. Why? Does autocast happen sometimes, but not always?
05:45:52 <mauke> Expez-: there are no casts
05:45:53 <roconnor> it only took 3 years from twanvl's blog post to turn into a library.
05:48:17 <edwardk> Expez-: there is no casting going on. the literals have a more liberal type than you'd expect
05:48:55 <edwardk> when you write 2 in haskell what you are actually saying is 'fromIntegral 2' so any instance of Num can be converted to from an Integer
05:49:02 <dmwit> Casts are just functions with a funny looking name and a convenient compiler optimization.
05:49:03 <mauke> *'fromInteger 2'
05:49:09 <edwardk> er fromInteger
05:49:32 <dmwit> Haskell has casts, too, but the names aren't funny looking and if you want the optimization you have to ask for it.
05:50:06 <edwardk> Expez-: similarly when you use 1.0 you are actually saying fromRational (the nearest rational to 1.0 written as foo % bar)
05:50:10 <dmwit> And most of the time, you don't even have to ask for it.
05:50:48 <Expez-> edwardk: So my mistake was that I'm saying :: Int -> Bool where as it should be something less specific than Int?
05:51:06 <edwardk> Expez-: i missed your mistake, i joined the channel after you raised your issue
05:51:14 <edwardk> i'm just speaking in general about the numeric types
05:51:36 <twanvl> Expez-: the best solution is to add an explicit cast to the argument of sqrt
05:51:54 <mauke> "explicit cast" :-[
05:52:05 <dmwit> There's not many types that you can call both sqrt and mod on.
05:52:18 <edwardk> hah true
05:52:20 <twanvl> Expez-: write (sqrt (realToFrac n)) instead of (sqrt n)
05:52:31 <edwardk> or fromIntegral
05:52:34 <mauke> sqrt (fromIntegral n)
05:52:36 <dmwit> :t realToFrac
05:52:37 <lambdabot> forall a b. (Real a, Fractional b) => a -> b
05:52:40 <twanvl> by "cast" I mean "function to convert from one type to another"
05:52:43 <dmwit> I think realToFrac is not okay here.
05:52:44 <edwardk> you probably can't realToFrac there
05:52:53 <Expez-> realToFrac worked
05:52:54 <dmwit> > realToFrac (1 :: Int)
05:52:55 <lambdabot>   1.0
05:52:56 <nand`> does anybody else find Haskell's numeric typeclasses extremely confusing? in particular Fractional, Real, Floating, RealFrac, RealFloat
05:52:58 <dmwit> How about that.
05:53:00 <edwardk> oh yeah
05:53:01 <nand`> I can never figure out which one is which
05:53:01 <edwardk> its Real
05:53:11 <twanvl> edwardk: are you saying that Ints aren't Real?
05:53:12 <edwardk> @info Real
05:53:13 <lambdabot> Real
05:53:18 <edwardk> @src Real
05:53:18 <lambdabot> class  (Num a, Ord a) => Real a  where
05:53:18 <lambdabot>     toRational      ::  a -> Rational
05:53:21 <dmwit> nand`: Yes. Whenever I need to know something I have to review them all over again.
05:53:22 <mauke> there never has been an @info command
05:53:51 <edwardk> mauke: bad habit from another project
05:54:32 <twanvl> that typeclass has a very strange name for the functionality it provides :)
05:54:38 <edwardk> yeah
05:54:40 <nand`> another thing that confuses me: why does Real have toRational :: Real a => a -> Rational -- ? ‚Ñö ‚äÇ ‚Ñù, so how does this work?
05:54:41 <Expez-> Is there a reason sqrt only works on floating?
05:54:51 <mauke> nand`: there is no ‚Ñù
05:55:01 <edwardk> expez: yes, because otherwise it isn't really a sqrt, ;)
05:55:07 <mauke> it's called Real because it's not Complex
05:55:23 <dmwit> Almost all of the reals aren't computable.
05:55:26 <twanvl> Expez-: sqrt has type a -> a, so the output has the same type as the input
05:55:29 <nand`> mauke: oh
05:55:29 <edwardk> x = sqrt x * sqrt x is a nice property to have hold
05:55:46 <dmwit> ?check \x -> x == sqrt x ^ 2
05:55:47 <lambdabot>   "Falsifiable, after 3 tests:\n-0.33333333333333337\n"
05:56:02 <dmwit> oh, fine
05:56:05 <edwardk> hah
05:56:09 <dmwit> ?check \x -> abs x == sqrt (abs x) ^ 2
05:56:10 <lambdabot>   "Falsifiable, after 0 tests:\n2.0\n"
05:56:15 <dmwit> love it
05:56:19 <dmwit> > sqrt 2 ^ 2
05:56:21 <lambdabot>   2.0000000000000004
05:56:24 <edwardk> heh
05:56:33 <edwardk> up to floating point stupidity ;)
05:56:53 <nand`> ?check \x -> x == (x :: CReal)
05:56:54 <dmwit> Well, you could write an isqrt for which isqrt x ^ 2 = x up to integer stupidity. ;-)
05:56:54 <lambdabot>   No instance for (Test.QuickCheck.Arbitrary Data.Number.CReal.CReal)
05:56:54 <lambdabot>    aris...
05:57:22 <dmwit> > 1e-100 == (1e-100 :: CReal)
05:57:23 <lambdabot>   True
05:57:29 <dmwit> > 1e-100 == (0 :: CReal)
05:57:30 <lambdabot>   True
05:57:33 <dmwit> ;-(
05:57:55 <nand`> CReal's (==) has a limited precision :(
05:58:15 <nand`> > (sqrt 2) ^ 2 == (2 :: CReal)
05:58:17 <lambdabot>   True
05:58:20 <dmwit> It really shouldn't implement the Eq type class, I think.
05:58:27 <mauke> > 1e-100 > (0 :: CReal)
05:58:29 <lambdabot>   False
05:58:45 <dmwit> Nor Ord neither if that can't be done computably.
05:58:46 <nand`> well, it's inherited from Ord; which is all limited precision
05:59:07 <dmwit> s/neither//
05:59:20 <nand`> doesn't Num have this silly Eq super-class constraint on it though
05:59:26 <Expez-> edwardk: That property can hold with integers on the LHS and floating points numbers on the RHS though, right?
05:59:27 <dmwit> Not any more. =)
05:59:51 <dmwit> Expez-: In Haskell, (==) happens to only take two arguments of the same type.
05:59:55 <dmwit> :t (==)
05:59:56 <lambdabot> forall a. (Eq a) => a -> a -> Bool
05:59:59 <edwardk> expez: give me an integer x such that 5 == x*x ;)
06:00:11 <dmwit> edwardk: read again
06:00:18 <edwardk> oh
06:00:27 <edwardk> :t sqrt
06:00:30 <lambdabot> forall a. (Floating a) => a -> a
06:00:35 <edwardk> notice the types have to match
06:00:41 <mauke> > sqrt 2 === length "two"
06:00:45 <lambdabot>   False
06:00:47 <edwardk> there are a number of reasons for this
06:00:51 <dmwit> :t (===)
06:00:53 <nand`> > fromIntegral 5 == (sqrt 5) * (sqrt 5)
06:00:53 <lambdabot> forall a b. (Typeable a, Typeable b, Eq b) => a -> b -> Bool
06:00:55 <lambdabot>   False
06:01:00 <edwardk> hah
06:01:16 <edwardk> @let a ==== b = show a == show b
06:01:18 <lambdabot>  Defined.
06:01:23 <nand`> ..
06:01:33 <dmwit> love it
06:01:34 <edwardk> :t (====)
06:01:36 <lambdabot> forall a a1. (Show a, Show a1) => a -> a1 -> Bool
06:01:40 <mauke> > (1 :: Int) ==== (1 :: Double)
06:01:41 <nand`> > 5 ==== 5.0
06:01:42 <lambdabot>   False
06:01:44 <lambdabot>   False
06:01:59 <mauke> > M.empty ==== S.empty
06:02:01 <lambdabot>   True
06:02:02 <roconnor> feels like PHP
06:02:08 <mauke> > M.empty === S.empty
06:02:10 <lambdabot>   Ambiguous type variable `k' in the constraint:
06:02:10 <lambdabot>    `Data.Typeable.Typeable k...
06:02:21 <edwardk> clearly we need to use Read and Show on each side and compare them using the other's type
06:02:23 <nand`> type PHP = String
06:02:28 <mauke> > (M.empty :: M.Map String Int) === S.empty
06:02:31 <lambdabot>   False
06:02:46 <edwardk> @let a ===== b = read (show a) == b && a == read (show b)
06:02:48 <lambdabot>  Defined.
06:02:51 <edwardk> :t (=====)
06:02:53 <lambdabot> forall a a1. (Show a, Read a1, Eq a1, Show a1, Read a, Eq a) => a -> a1 -> Bool
06:03:05 <nand`> < 5 ===== 5.0
06:03:07 <nand`> > 5 ===== 5.0
06:03:08 <edwardk> that still won't get 5 ===== 5.0 though
06:03:10 <lambdabot>   *Exception: Prelude.read: no parse
06:03:17 <mauke> edwardk: you should use reads and return True if any match
06:03:29 <edwardk> fair nuff
06:03:40 <edwardk> @let a ===== b = read (show a) == b || a == read (show b)
06:03:42 <lambdabot>  <local>:6:0:
06:03:42 <lambdabot>      Warning: Pattern match(es) are overlapped
06:03:42 <lambdabot>               In...
06:03:59 <edwardk> @let a ====== b = read (show a) == b || a == read (show b)
06:04:01 <lambdabot>  Defined.
06:04:01 <dmwit> ?let reallyEqual a b = reads (show a) == [(b,"")] || reads (show b) == [(a,"")]
06:04:03 <lambdabot>  Defined.
06:04:09 <dmwit> oh
06:04:10 <mauke> dmwit++
06:04:19 <dmwit> > reallyEqual 5 5.0
06:04:21 <lambdabot>   True
06:04:23 <edwardk> better =)
06:04:42 <mauke> > M.empty `reallyEqual` S.empty
06:04:45 <lambdabot>   True
06:05:08 <dmwit> > M.singleton 5 "hey" `reallyEqual` S.singleton (5.0, "hey")
06:05:08 <mauke> > reallyEqual 1 (1%1)
06:05:10 <lambdabot>   True
06:05:11 <lambdabot>   False
06:05:33 <nand`> > let foo d a b = (let a' = read (show a); b' = read (show b); _ = [d, a', b'] in a' == b') in foo (undefined :: Double) 5 5.0
06:05:35 <lambdabot>   *Exception: Prelude.read: no parse
06:05:37 <nand`> :(
06:06:10 <edwardk> nand`: see dmwit's reads hack
06:06:42 <dmwit> mauke: Being inconsistent about which numeric types you can compare this way is PHP style.
06:07:08 <mekeor> :t reallyEqual
06:07:09 <lambdabot> forall a a1. (Show a, Read a1, Eq a1, Show a1, Read a, Eq a) => a -> a1 -> Bool
06:07:14 <mauke> > "PHP" === "good"
06:07:20 <lambdabot>   False
06:07:25 <mekeor> :t (===)
06:07:27 <lambdabot> forall a b. (Typeable a, Typeable b, Eq b) => a -> b -> Bool
06:08:45 <twanvl> > read "1" :: Rational -- :(
06:08:47 <lambdabot>   *Exception: Prelude.read: no parse
06:09:08 <mauke> > read "4% 4" :: Rational
06:09:09 <lambdabot>   1 % 1
06:09:30 <dmwit> > read "1.0 % 1" :: Rational
06:09:32 <lambdabot>   *Exception: Prelude.read: no parse
06:09:33 <mroman> How would one implement a term rewriting system in Haskell?
06:09:39 <mroman> using patterns is a no go.
06:10:24 <nand`> > let foo d a b = (let [_,a',b'] = [d, read (show a), read (show b)] in a' == b') in foo (undefined :: Double) 5 5.0
06:10:27 <lambdabot>   True
06:10:30 <dmwit> I'm not sure it would be significantly different from writing a term rewriting system in any other language.
06:10:43 <dmwit> Define a data type for terms and some functions for finding rewritable subterms and off you go.
06:10:47 <nand`> > let foo d a b = (let [_,a',b'] = [d, read (show a), read (show b)] in a' == b') in foo (undefined :: Rational) 5 5.0
06:10:48 <lambdabot>   *Exception: Prelude.read: no parse
06:10:57 <dmwit> If you happen to know it can be compiled to a more efficient machine, you do that instead.
06:11:21 <Tomsik> data Term = Term { tag :: String, [Term] :: args }
06:11:32 <dmwit> type Term = Tree String
06:11:36 <Tomsik> Unless you know something more about Terms
06:12:26 <nand`> Tomsik: you flipped the type and name :P
06:12:30 <mekeor> lol :D
06:15:52 <Tomsik> Watching a starcraft tournament, sorry :P
06:16:13 <Tomsik> and been writing too much Erlang recently
06:20:22 <mel-> I want to map a function which returns IO String over a list of values. But... how do I make the return value of that map (i.e. [IO String]) into a IO action?
06:20:32 <dmwit> :t sequence
06:20:34 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
06:20:41 <dmwit> ?src mapM
06:20:41 <lambdabot> mapM f as = sequence (map f as)
06:20:43 <dmwit> There's also
06:20:46 <dmwit> :t sequence_
06:20:47 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m ()
06:20:50 <dmwit> ?src mapM_
06:20:50 <lambdabot> mapM_ f as = sequence_ (map f as)
06:21:30 <mroman> If one pattern matches, every other also matching pattern is left behind.
06:21:30 <mel-> aaah
06:21:31 <mel-> thanks
06:21:41 <dmwit> mroman: lern2listmonad
06:22:44 <mroman> Either I define for every rule a function
06:22:57 <mroman> and put them in a big list.
06:23:19 <peteretep> I'm probably having Google issues here, but what's the easiest way to convert a list in to a list of lists, two items big each?
06:23:30 <peteretep> Essentially I want the equivalent to perl's natatime
06:23:31 <dmwit> ?hackage split
06:23:31 <lambdabot> http://hackage.haskell.org/package/split
06:23:38 <dmwit> chunk :: Int -> [e] -> [[e]]
06:23:51 <peteretep> dmwit: Thanks
06:24:15 <aristid> > iterate (drop 2) [1..10]
06:24:17 <lambdabot>   [[1,2,3,4,5,6,7,8,9,10],[3,4,5,6,7,8,9,10],[5,6,7,8,9,10],[7,8,9,10],[9,10]...
06:24:27 <aristid> > map (take 2) . iterate (drop 2) $ [1..10]
06:24:28 <dmwit> :t (+++)
06:24:30 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (ArrowChoice a) => a b c -> a b' c' -> a (Either b b') (Either c c')
06:24:30 <lambdabot>   [[1,2],[3,4],[5,6],[7,8],[9,10],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[...
06:24:54 <dmwit> ?hoogle (a -> [b]) -> (a -> [b]) -> (a -> [b])
06:24:55 <lambdabot> Control.Monad (>=>) :: Monad m => (a -> m b) -> (b -> m c) -> (a -> m c)
06:24:55 <lambdabot> Control.Monad (<=<) :: Monad m => (b -> m c) -> (a -> m b) -> (a -> m c)
06:24:55 <lambdabot> Data.Generics.Aliases extMp :: (MonadPlus m, Typeable a, Typeable b) => (a -> m a) -> (b -> m b) -> a -> m a
06:24:57 <aristid> > map (take 2) . takeWhile (not . null) . iterate (drop 2) $ [1..10]
06:24:59 <lambdabot>   [[1,2],[3,4],[5,6],[7,8],[9,10]]
06:25:18 <dmwit> oh, liftM2 (++) derp
06:26:22 <dmwit> > transpose . (\(x,y) -> [x,y]) . partition odd $ [1..10]
06:26:24 <lambdabot>   [[1,2],[3,4],[5,6],[7,8],[9,10]]
06:26:26 <dmwit> ;-)
06:29:24 <mekeor> if [,] was (\x y -> [x,y]), (\(x,y) -> [x,y]) would be (uncurry [,]).
06:30:52 <dmwit> ?pl \(x,y) -> [x,y]
06:30:52 <lambdabot> uncurry ((. return) . (:))
06:31:02 <dmwit> readable
06:34:34 <twanvl> ?type uncurry (++) . (return *** return)
06:34:36 <lambdabot> forall b (m :: * -> *). (Monoid (m b), Monad m) => (b, b) -> m b
06:35:18 <peteretep> I have a data type: data RGB = RGB Red Blue Green deriving (Show)
06:35:30 <peteretep> And I have a list containing these
06:35:36 <peteretep> How do I create the RGB type from a list?
06:35:56 <nand`> \[r,g,b] -> RGB r g b -- ?
06:36:00 <twanvl> ?type uncurry ((++) `on` return)
06:36:01 <lambdabot> forall a (m :: * -> *). (Monoid (m a), Monad m) => (a, a) -> m a
06:36:18 <peteretep> nand`: OK, thanks, let me play with that
06:36:36 <hpc> peteretep: if Red, Green, Blue are all different types, it's not possible to get them all in the same list
06:36:45 <hpc> if they're aliases for 'Int' or something, what nand` said
06:37:08 <peteretep> They're aliases for int
06:37:10 <peteretep> Int, even
06:38:19 <dmwit> See also
06:38:21 <dmwit> ?hackage colour
06:38:21 <lambdabot> http://hackage.haskell.org/package/colour
06:38:35 <dmwit> If you want something written by somebody who actually knows what they're doing... ;-)
06:38:45 <dmwit> (Probably not for beginners, though.)
06:38:52 <peteretep> I don't, I want to write it myself
06:39:49 <nand`> dmwit: oh good, a colour package written by somebody that at least knows the difference between color spaces :P
06:40:09 <ion> ITYM colour spaces
06:40:43 <mekeor> oh, it's by roconnor !
06:40:55 <ion> Someone should upload a package named color that re-exports everything from colour renamed in American English.
06:41:05 <dmwit> rhoconnor, the Greekest of all the connors
06:41:18 <dmwit> colour offers American names already
06:41:32 <ion> It‚Äôs still Data.Colour!
06:41:33 <dmwit> Oh, well, I guess the module names are Britishized. =P
06:41:39 <yitz> dmwit: oh i'd say pigworker is also pretty greek
06:42:04 <dmwit> but he's a gworker, not a connor
06:42:20 <aristid> dmwit: he's a conor
06:42:22 <nand`> ‚ÄúInternally we store the colour in linear ITU-R BT.709 RGB colour space‚Äù
06:42:24 * nand` cringes
06:42:26 <nand`> I've been meaning to write a CMS package one of these days
06:42:28 <nand`> if anybody'd be interested
06:42:49 <dmwit> oh
06:42:56 <ion> nand: What‚Äôs wrong with that color space?
06:43:01 <harrisonpartch> eos rhodoconnoros
06:43:45 <dmwit> yitz++ for a joke so good I didn't even get it
06:43:51 <yitz> heh
06:44:59 <yitz> nand`: will you store pantone internally in yours?
06:45:07 <mel-> i created a three-line 'ls' program in haskell. but it takes almost twice the time to tun than /bin/ls. when i use ghc -dynamic it takes about 5 times the time compared to /bin/ls. i wonder if there ware other possibilities for optimization
06:45:43 <nand`> ion: well, it's fairly difficult to work with, questining its usefulness as an intermediate/internal representation
06:46:03 <nand`> yitz: probably XYZ or Yxy
06:46:06 <dmwit> With a program as short as that, you're probably comparing startup times.
06:46:20 <ion> nand: ok
06:46:27 <dmwit> Also, -dynamic is a space optimization, not a time optimization. As you observed.
06:46:34 <yitz> mel-: ls is very fast C, deeply intertwined with the OS. if you can achieve x2 in haskell, you are doing great.
06:47:13 <mel-> yitz: what do you mean with 'deeply intertwined'?
06:47:22 <hpaste> peteretep pasted ‚ÄúAm I doing anything particularly stupid here?‚Äù at http://hpaste.org/71093
06:47:24 <nand`> ion: for example if I want to do color management I'm usually working with XYZ, L*ab or derivatives of those two (Yxy, L*Ch, etc.), since the calculations are simple matrix multiplications in those color spaces. with RGB I'd have to convert back and forth between BT.709's primaries and whatever calculation space I'm using for every single operation
06:47:28 <dmwit> Yeah, I'm not sure what that's supposed to mean either.
06:47:29 <roconnor> nand`: AFAIU all linear colour spaces are roughtly the same.  The largest issue is rounding of floating point values.
06:47:43 <peteretep> I'd love any feedback on how I could improve the above ^^
06:47:46 <dmwit> peteretep: pretty stupid, yeah
06:48:02 <dmwit> peteretep: chunk 2 is going to make length-2 lists, which you're then pattern matching against a pattern for length-3 lists
06:48:06 <ion> nand: alright
06:48:20 <yitz> maybe i'm wrong, but i always assumed that /bin/ls is more than just a thin wrapper for the usual API for listing files.
06:48:34 <peteretep> dmwit: What do you mean?
06:48:39 <dmwit> peteretep: As for intFromHexString, you should just import Numeric and use readIntAtBase
06:49:03 <ion> > readIntAtBase 36 "ohai"
06:49:04 <dmwit> Oh, actually, Numeric even exports a readHex.
06:49:05 <lambdabot>   Not in scope: `readIntAtBase'
06:49:08 <ion> > Numeric.readIntAtBase 36 "ohai"
06:49:10 <lambdabot>   Not in scope: `Numeric.readIntAtBase'
06:49:23 <dmwit> ?hoogle readIntAtBase
06:49:24 <lambdabot> No results found
06:49:31 <dmwit> ?hoogle readInt
06:49:31 <lambdabot> Numeric readInt :: Num a => a -> (Char -> Bool) -> (Char -> Int) -> ReadS a
06:49:31 <lambdabot> Text.Read.Lex readIntP :: Num a => a -> (Char -> Bool) -> (Char -> Int) -> ReadP a
06:49:32 <lambdabot> Data.ByteString.Char8 readInt :: ByteString -> Maybe (Int, ByteString)
06:49:32 <mel-> yitz: i would expect it be a exactly that. a small program using the libc interface for reading directory entries
06:49:49 <nand`> roconnor: really? I'd have expected floating point imprecision to be a fairly small issue, 8 bits of precision are more than enough for companded BT.709, with 16 bits of precision adequate for linear (absolute) spaces; 32 or 64 bit IEEE floats should handle these with ease
06:50:11 <peteretep> dmwit: Could you explain your comment about chunk?
06:50:11 <dmwit> peteretep: I see, I misunderstood what you were doing. My mistake.
06:50:14 <yitz> mel-: oh well if so scratch my previous comment
06:50:15 <roconnor> nand`: Inded I expect it to be a fairly small issue.  It is simply the largest issue that I'm aware of :D
06:50:21 <roconnor> *Indeed
06:50:32 <nand`> I see :P
06:50:33 <peteretep> What tool is hpaste using to give stylistic comments?
06:50:39 <peteretep> Some kind of lint?
06:50:53 <dmwit> hlint
06:50:59 <roconnor> nand`: the conversion from XYZ to Colour is itself just a matrix multiplicaton:  http://hackage.haskell.org/packages/archive/colour/2.3.3/doc/html/src/Data-Colour-CIE.html#cieXYZ
06:51:51 <roconnor> nand`: but, yes, I agree that I haven't put much effort in optimising conversions between colour spaces. ... I don't think
06:51:51 <dmwit> peteretep: The only other thing to mention is that you almost never want foldl. foldr if you want lazy or foldl' if you want strict
06:52:27 <peteretep> OK
06:52:30 * peteretep goes to read up about that
06:52:49 <nand`> roconnor: do you have any logic for gamut conversion / proofing yet? (eg. white point adaptation, bounds checking / chromatic clamping, etc.)
06:52:58 * peteretep finds http://stackoverflow.com/questions/3429634/haskell-foldl-vs-foldr-question
06:53:08 <roconnor> nand`: nope
06:53:24 <yitz> roconnor, nand`: isn't ITU a strictly smaller space than CIE? and isn't there a non-linear component for low saturation levels?
06:53:42 <yitz> ITU RGB that is
06:53:52 <nand`> roconnor: I'd just personally use XYZ or Yxy or another ‚Äòcommon‚Äô absolute space as intermediate, and convert to/from whatever gamuts the end user requires at the final step
06:54:02 <roconnor> yitz: it isn't smaller if you allow negative coeffiencets and coeffecents greater than 1.
06:54:16 <nand`> yitz: what roconnor said
06:54:20 <yitz> ok
06:54:35 <nand`> yitz: ‚Äúnon-linear component for low saturation levels‚Äù <- are you sure you aren't thinking of sRGB's gamma curve or something?
06:54:47 <yitz> maybe
06:55:05 <nand`> (maybe take this to -blah)
07:01:28 <stepkut> imagine you have an led matrix (for example, http://tinyurl.com/cgyzmuu) and you want to create a little language for programming it. (Something that gets compiled to a simple bytecode that gets run by an interpreter on the controller). What might that language look like? FRP?
07:02:35 <hpc> the LED matrix has data input, i take it?
07:03:00 <stepkut> hpc: well, in this case, the led matrix will be hand wired and controlled by an arduino.. so yes..
07:03:19 <stepkut> it could reactive to music or other inputs
07:03:35 <twanvl> stepkut: something that looks like Diagrams might be convenient for layout, though using pixel coordinates wouldn't be that bad
07:04:11 * stepkut notes that googling diagrams is pretty tricky
07:04:23 <twanvl> it's on hackage
07:04:36 <stepkut> k
07:04:40 <HugoDaniel> hi
07:04:49 <stepkut> thanks
07:05:05 <stepkut> I'll read about reactive bananas and diagrams and see what new thoughts I think
07:07:10 <stepkut> looks like diagrams has some primitive animation support
07:11:15 <mroman> http://codepad.org/NC2Z2nnz
07:11:24 <mroman> That would have been my naive attempt @rewrite
07:14:27 <mroman> If the list rewrites returns contains ETrue it is a tautology, if it contains EFalse it is a contradiction.
07:14:41 <mroman> Else it just suggests possible alternatives.
07:15:07 <Feuerbach> What is the equivalent of the "default" declaration in GHCi? (GHCi 7.4.1. doesn't seem to accept "default" declarations)
07:18:10 <hpc> Feuerbach: lazy answer is "do it in a file"
07:18:16 <hpc> less lazy answer is "i don't know"
07:19:30 <Feuerbach> hpc: tried that, doesn't seem to work either. Did it work for you?
07:19:30 <hpc> it might not be possible
07:20:01 <hpc> ghci's :help says nothing useful
07:20:28 <hpc> Feuerbach: what i mean is, define some "foo" in a file with all the defaults you want, then evaluate that
07:20:33 <hpc> with ":r" between each edit
07:21:17 <Feuerbach> ah, no :) I need defaulting to work for expressions I type into ghci
07:24:01 <ksf> ...the best bugs are those that fix themselves while refactoring to enable debug output.
07:24:23 <hpc> ksf: the best bugs are those that SOMEONE ELSE fixes
07:24:25 <ksf> and no warning could've catched that one. I was using not-redefined variables instead of redefined ones.
07:30:52 <dmwit> ?hoogle Alternative f => [f a] -> f a
07:30:53 <lambdabot> Data.Foldable asum :: (Foldable t, Alternative f) => t (f a) -> f a
07:30:53 <lambdabot> Control.Monad msum :: MonadPlus m => [m a] -> m a
07:30:53 <lambdabot> Control.Applicative (<|>) :: Alternative f => f a -> f a -> f a
07:36:10 <mroman> although this yields to hundreds of rules
07:36:23 <mroman> as every rule a -> b has a corresponding rule b -> a
07:44:23 <hpaste> dmwit pasted ‚Äúterm rewriting‚Äù at http://hpaste.org/71095
07:44:35 <dmwit> mroman: Another possible approach.
07:47:37 <hpaste> mbuf pasted ‚ÄúHow to test permute function‚Äù at http://hpaste.org/71096
07:47:57 <dmwit> The do-blocks are a bit more verbose than I was hoping, actually.
07:48:05 <dmwit> But you can certainly write yourself some sugar to cover that up.
07:50:09 <mbuf> if I use ghci> permute [1,2] :: Integer, it gives me Couldn't match expected type `Integer' with actual type `m0 [a0]'
07:50:38 <mekeor> mbuf: what's the type of permute?
07:50:51 <mekeor> oh, ah.
07:50:53 <mbuf> mekeor: permute :: MonadPlus m => [a] -> m [a]
07:50:54 <mbuf>  
07:50:58 <mbuf> mekeor: what is m here?
07:51:07 <ion> Integer certainly doesn‚Äôt match m [a]
07:51:25 <mekeor> mbuf: btw, you should generally write more type signatures. those make your code much easier to understand.
07:51:46 <mbuf> mekeor: it is not my code; just trying examples
07:51:51 <mekeor> ah, okay.
07:51:57 <mauke> > permute [1,2]
07:51:58 <mbuf> mekeor: sure will follow it in practice
07:51:59 <lambdabot>   Not in scope: `permute'
07:52:10 <mekeor> mbuf: yea, did you try "permute [1,2]" ?
07:52:32 <mbuf> mekeor: it just returns the string back
07:52:41 <mauke> ... string?
07:52:46 <mekeor> ... string?
07:52:53 <mbuf> "permute [1,2]"
07:52:56 <mekeor> ah
07:53:01 <mauke> ‡≤†_‡≤†
07:53:47 <mbuf> or how do I test the
07:53:51 <mbuf> 'to' function
07:58:02 <mekeor> it would be cool if modules were somehow like functions, so that they can get arguments‚Ä¶
07:58:31 <mekeor> mbuf: i'm not good at that kind of stuff. but‚Ä¶ did you try just typing "to"? or "to :: IO Int"?
07:59:00 <mekeor> oh, wait.
07:59:07 <mekeor> IO is not in MonadPlus‚Ä¶
08:02:03 <dmwit> ReaderT [] doesn't seem like the right abstraction, actually.
08:05:55 <mbuf> to :: MonadPlus m => m Int, what does 'm' here stand for?
08:05:56 <dmwit> ?unmtl StateT s [] a
08:05:56 <lambdabot> s -> [(a, s)]
08:06:20 <ion> Any type constructor that is an instance of MonadPlus
08:06:52 <mekeor> mbuf: m is a type (constructor) which is an instance of the type-class MonadPlus. e.g. it could be a list.
08:07:05 <sipa> do you call "StateT IO" a type constructor?
08:07:11 <sipa> i'd call it a type expression
08:07:46 <sipa> eh, rather "State Int" or "StateT Int IO"
08:08:33 <mbuf> mekeor: okay
08:09:23 <ozataman> anyone have any idea why "file://localhost/Users/ozataman/Library/Haskell/doc/index.html" would not update with newer versions of a library?
08:09:41 <mekeor> ozataman: fail. look at that link.
08:09:56 <ozataman> ?
08:10:06 <mekeor> mekeor: fail. he didn't want to paste an internet url.
08:10:09 <mekeor> i'm very sorry.
08:10:22 <mekeor> omg.
08:10:35 <ozataman> mekeor: :)
08:11:42 <gwern> haha http://r6.ca/blog/20120708T122219Z.html
08:12:53 <ion> hah
08:13:53 <hiptobecubic> I think i'll start a blog. "Haskell for retards that want to impress their colleagues."
08:14:09 <hiptobecubic> Then I don't have to be embarrassed about not knowing the best way to do anything
08:15:52 <mekeor> yet another question on code layout: how would you align and order these imports? http://hpaste.org/71099
08:16:20 <hiptobecubic> mekeor, what's wront with how they are? looks like stylish-haskell to me
08:16:59 <mekeor> dunno‚Ä¶ i just don't like it intuitively‚Ä¶
08:19:41 <antihero> Did the Haskell LLVM thing ever happen?
08:20:45 <ion> ghc -fllvm
08:21:24 <daniel_-> just got a ghc panic when i misstyped deriving (show) -- no capital S
08:21:38 <mekeor> nice
08:21:40 <daniel_-> and it suggested i report it as a bug, but i guess i probably shouldn't?
08:21:52 <daniel_-> or should i?
08:21:55 <hpc> report it
08:21:59 <hpc> ghc should never panic
08:22:19 <daniel_-> okay
08:22:28 <hpc> unless maybe you decide to do FFI IO inside template haskell
08:22:38 <hpc> which is terrifying and you should feel bad if you try that :P
08:23:47 <ion> 012-03-23 13:06:53 +0200 <Philonous> Has anyone else have the line "data Foo = Foo deriving (show)" generate a GHC panic (in 7.4.1) ?
08:23:48 <dmwit> mekeor: FWIW I use alphabetical ordering these days.
08:24:11 <mekeor> ah
08:24:26 <hpc> i get the same thing
08:24:30 <ion> deriving ((?)) crashes it, too.
08:24:45 <dmwit> Any type variable name works fine there.
08:25:15 <daniel_-> maybe theres already a ticket for it
08:27:26 <daniel_-> http://hackage.haskell.org/trac/ghc/ticket/6141
08:29:34 <mm_freak> it panics for everything that doesn't look like a type class
08:30:02 <mm_freak> it works for X and (:->) with the expected error message, but panics for x and (~>)
08:30:10 <daniel_-> "Trying to derive a classname starting with a lower case letter and wrapped in parenthesis will lead to a ghc panic instead of generating an error"
08:30:11 <mm_freak> this is GHC 7.4.2 here and i
08:30:16 <mm_freak> this is GHC 7.4.2 here and i'm testing in GHCi
08:31:36 <dmwit> That's bug-fixing speed!
08:31:42 <dmwit> Fixed 4 months before you even noticed it.
08:36:55 <daniel_-> what if i want to search for functions which takes a Handle and does something with it (e.g. ->) but dont know what comes after -> (searching on hoogle)
08:37:17 <hpc> @hoogle (Handle ->)
08:37:17 <lambdabot> Parse error:
08:37:17 <lambdabot>   (Handle ->)
08:37:18 <lambdabot>             ^
08:37:19 <eviltwin_b> @hoole Handle -> a
08:37:19 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
08:37:19 <lambdabot> Prelude id :: a -> a
08:37:20 <lambdabot> Data.Function id :: a -> a
08:37:26 <hpc> @hoogle Handle ->
08:37:26 <lambdabot> Parse error:
08:37:26 <lambdabot>   Handle ->
08:37:26 <lambdabot>            ^
08:37:29 <hpc> damn
08:37:35 <eviltwin_b> aside from the fact that I can't type...
08:38:26 <daniel_-> so i guess there is no catch all symbol for hoogle?
08:38:27 <dmwit> The results for Handle -> a are really pretty bad.
08:38:28 <hpc> daniel_-: narrow it down by package, i think
08:38:36 <dmwit> Handle -> IO a is much better.
08:38:56 <dmwit> But that does require you to know a bit about how Handles are used, unfortunately.
08:39:06 <daniel_-> yup
08:39:34 <daniel_-> i mostly wanted to know if there was any function that takes a Handle or ProcessHandle or Fd and returns a process id
08:40:00 <dmwit> The results for Handle -> a on Hayoo don't suck.
08:40:16 <dmwit> What are you hoping that function would do?
08:40:45 <daniel_-> well i've created a subprocess with System.Process.createProcess
08:40:52 <daniel_-> and id like to know the PID of that process
08:41:10 <daniel_-> the function returns -> IO (Handle, Handle, Handle, ProcessHandle)
08:41:39 <daniel_-> and in the docs for runInteractiveProcess it seems to infer that ProcessHandle is pid(?) (inp,out,err,pid) <- runInteractiveProcess "..."
08:41:58 <dmwit> what
08:41:59 <dmwit> no
08:42:01 <nobdraisentone> Is there some web frontend for darcs projects? Like there is a github for git.
08:42:06 <dmwit> It's naming the ProcessHandle pid.
08:42:10 <danr> nobdraisentone: darcsden
08:42:19 <gwern> 'Various versions of Shake have been used at Standard Chartered for the past three years (¬ß6). The build system creates over 30,000 build objects, with more than a million lines of source code and a million lines of generated code, in many programming languages. We originally implemented this build system using make, but the result was slow to run, hard to maintain, and frequently caused spurious compile failures. Switching to Shake made our build ...
08:42:25 <gwern> ... system ten times shorter, made builds run twice as fast, and has solved our build system problems. '
08:42:26 <daniel_-> yeah, just made me think about process id
08:42:28 <gwern> danr: patchtag is still up
08:42:35 <danr> oh right
08:42:39 <dmwit> daniel_-: pid is a process ID, yes
08:42:47 <dmwit> specifically, it's a ProcessHandle
08:43:03 <dmwit> Note that the type ProcessHandle is completely unrelated to the type Handle.
08:43:14 <daniel_-> yup
08:43:35 <dmwit> So I'm a little confused still about what problem we're trying to solve here.
08:43:53 <daniel_-> but im just trying to find out how to find the process id for the process i created :]
08:44:09 <dmwit> That's part of the value returned from the creation process.
08:45:07 <daniel_-> but it only returns "IO (Handle, Handle, Handle, ProcessHandle)"
08:45:34 <dmwit> Maybe this is another way to ask the question: what are you going to do with the process ID once you have it?
08:46:20 <daniel_-> since im creating and managing long running processes with my "dispatcher program" id like to know the id's so i can get some statistics from the OS regarding cpu usage and mem use
08:46:47 <nobdraisentone> danr: nice
08:46:53 <daniel_-> and keep them as identifiers
08:46:59 <daniel_-> for logging purposes
08:47:01 <dmwit> I don't think that can be done in a platform-portable way.
08:47:06 <dmwit> Perhaps you want the "unix" package?
08:47:31 <daniel_-> i dont want it for portable, linux will suffice :)
08:47:48 <Minoru> hey guys, I'm wondering why Data.List.genericLength has a type of Num i => [a] -> i. Why Num and not Integral? Does the author really expected to use lists with non-integral length someday? Or is it because type constraints should be written depending on the operators used - Num is enough because it defines (+)?
08:47:54 <dmwit> ?hackage unix
08:47:54 <lambdabot> http://hackage.haskell.org/package/unix
08:48:23 <dmwit> Minoru: You could write Integral i => [a] -> i, but why restrict yourself in that way?
08:48:43 <dmwit> > genericLength [1..10] / 3
08:48:44 <lambdabot>   3.3333333333333335
08:48:55 <dmwit> > (genericLength :: Integral i => [a] -> i) [1..10] / 3
08:48:56 <lambdabot>   Ambiguous type variable `i' in the constraints:
08:48:56 <lambdabot>    `GHC.Real.Integral i'
08:48:56 <lambdabot>   ...
08:50:10 <daniel_-> dmwit as far as i can see unix package process creating doesnt support piping stdout,err,in
08:50:36 <Minoru> dmwit: I just thought it would be nice to keep types as constrained as possible. I thought tricks like the one you showed should also contain fromIntegral
08:50:57 <dmwit> daniel_-: You just have to set up the fds yourself ahead of time.
08:50:59 <danr> @hoogel getProcessID
08:51:00 <lambdabot> Maybe you meant: hoogle hoogle+
08:51:03 <danr> @hoogle getProcessID
08:51:03 <lambdabot> System.Posix.Process getProcessID :: IO ProcessID
08:51:05 <dmwit> Just like you do in C.
08:51:16 <danr> ^ maybe you can use that daniel_-
08:51:37 <fmap> it'd be odd if `genericLength' wasn't generic i think
08:51:56 <dmwit> Minoru: If you're going to use fromIntegral anyway, you can just use the normal length function. The point of genericLength is you don't have to call fromIntegral.
08:52:33 <dmwit> Minoru: The complaint about length is that it's too monomorphic. It would be odd to replace it with *another* thing that was more monomorphic than it had to be.
08:53:15 <Minoru> yeah, I get it now. Thanks, dmwit!
08:55:50 <b52> http://r6.ca/blog/20120708T122219Z.html
08:59:51 <antihero> is there something like Python's "Decimal" module that allows you to represent irrational numbers?
09:00:44 <dmwit> Rational
09:00:50 <dmwit> Oh, irrationals, lolo.
09:00:53 <dmwit> CReal, then.
09:00:55 <dmwit> > pi :: CReal
09:00:57 <lambdabot>   3.1415926535897932384626433832795028841972
09:01:07 <dmwit> There's also half a dozen fixed-point arithmetic modules available on Hackage.
09:01:12 <dmwit> ?hackage numbers for CReal
09:01:12 <lambdabot> http://hackage.haskell.org/package/numbers for CReal
09:01:54 <dmwit> Oh, heck, same package even has fixed-point numbers. =D
09:03:27 <daniel_-> could someone please clarify what ProcessHandle is actually used/useful for? http://hackage.haskell.org/packages/archive/process/latest/doc/html/System-Process.html#t:ProcessHandle
09:03:57 <dmwit> daniel_-: It's useful as an argument to waitForProcess/getProcessExitCode/terminateProcess/interruptProcessGroupOf
09:04:36 <applicative> @quote snippets
09:04:36 <lambdabot> sigfpe says: Haskell is so strict about type safety that randomly generated snippets of code that successfully typecheck are likely to do something useful, even if you've no idea what that useful
09:04:36 <lambdabot> thing is.
09:06:59 <dmwit> daniel_-: "process" contains platform-portable operations only; the "unix" and "Win32" packages provide platform-specific ones
09:07:08 <daniel_-> yea
09:07:50 <c_wraith> roconnor: I am very amused by http://r6.ca/blog/20120708T122219Z.html
09:08:15 <b52> is there a mathematical notation to convert a real number to an int?
09:08:23 <hpc> b52: rounding
09:08:27 <daniel_-> only that im not really that good or understand fully how i would connect a process created with executeFile with pipes for stdin,err,out
09:08:46 <luite> b52: there are floor and ceiling brackets, and sometimes [] is used for nearest integer
09:08:48 <hpc> strictly speaking, the set of reals is "larger" than the set of integers
09:08:59 <dmwit> b52: |_ x _| for floor, and upside down for ceiling
09:09:07 <monochrom> therefore, there are like 4 notations for the conversions
09:09:14 <hpc> oh, "notation" /= "notion"
09:09:20 <dmwit> b52: (It's a bit tough to do in ASCII; if you've seen it before, that should be enough. Otherwise let me know and I'll try to draw better.)
09:09:31 <ksf> the longer I hack on xcb, the more I want to redo the protocol descriptions completely.
09:09:34 <b52> is there a latex command?
09:09:44 <monochrom> well, 4 notions implies at least 4 notations :)
09:09:50 <hpc> \bfloor or something like that
09:09:52 <dmwit> b52: detexify says \lfloor and \rfloor
09:09:59 <hpc> or that
09:10:33 <roconnor> c_wraith: me too
09:10:50 <b52> dmwit: thanks :=
09:10:51 <dmwit> I sat down to think of every rounding method I could think of. There's more than four.
09:13:50 <dmwit> toward -\infty, +\infty, or 0; toward nearest, with ties broken toward -\infty, +\infty, 0, even numbers, or odd numbers
09:14:01 <obk> How come ' ' Type (that is, a Name) can be used in expressions but not in patterns?
09:14:17 <dmwit> Oh yeah, and away from 0 in both lists
09:16:51 <daniel_-> thank you for the help dmwit i think i know how to implement this now!
09:17:00 <daniel_-> :))))
09:17:26 <dmwit> \o/
09:18:03 <hpaste> mkramer pasted ‚Äúmemorization fix point combinator: I don't get it!‚Äù at http://hpaste.org/71101
09:18:44 <mkramer> how does "let mf = ‚Ä¶ in mf" work at all?
09:19:02 <applicative> roconnor: I'm shocked, *shocked*, by this confession
09:19:04 <dmwit> by recursion?
09:19:25 <hpc> mkramer: let's start with a totally unmemoized function
09:19:31 <hpc> f x = x + 1
09:19:57 <mkramer> ok :)
09:20:01 <hpc> memoF = memoize f -- memoizing is very simple for non-recursive functions, and you should be used to it
09:20:17 <hpc> fact 0 = 1
09:20:27 <hpc> fact n = n * fact (n - 1)
09:20:44 <hpc> we can still do memoFib = memoize fib, but...
09:20:51 <hpc> fact 500 -- takes a long time
09:20:54 <hpc> er
09:21:09 <hpc> pretend "fib" was "fact" there
09:21:18 <hpc> fact 5000 -- takes comparatively long
09:21:39 <hpc> er, memoFact 5000 -- do it again and it's quicker
09:21:53 <hpc> memoFact 4999 -- uh oh, it didn't memoize everything before it
09:22:12 <hpc> memoFact 5001 -- and our memoizing function can't take advantage of memoFact 5000
09:22:37 <mkramer> so in our recursive definition, we have to call the memoizing version internally to memoize all the intermediate states
09:22:43 <hpc> yeah
09:22:53 <ski> mkramer : nitpick, s/memorization/memoization/
09:23:03 <mkramer> typo, sorry
09:23:04 <hpc> and the trick to doing that is to do a CPS transformation on the function
09:23:06 <mkramer> it was bugging me too
09:23:07 <ski> np
09:23:15 <mkramer> CPS?
09:23:18 <hpc> read: instead of calling itself again, have it take an additional "do this next" parameter
09:23:24 <mkramer> oh
09:23:28 <mkramer> continuation passing style
09:23:32 <hpc> yeah
09:23:34 <ski> no, this is not CPS
09:23:44 <hpc> it's similar
09:23:48 <ski> no
09:24:10 <ski> not any more similar than it is to accumulator-passing style
09:24:41 <hpc> ah
09:25:05 <hpc> well anyhoo, the way that memoFix function works is
09:25:12 <ski> mkramer : let's change to `fib' to make the memoization more motivated
09:25:20 <hpc> mf is the memoized version of f, with the final type you want, (a -> b)
09:25:40 <hpc> you pass it to f before memoizing it, so recursive calls are also memoized
09:25:59 <hpc> and that gives you what you see on the screen
09:26:14 <ski>   fib 0 = 0
09:26:17 <ski>   fib 1 = 1
09:26:17 <ski>   fib n = fib (n - 1) + fib (n - 2)
09:26:32 <hpaste> obk pasted ‚Äú''Type in patterns‚Äù at http://hpaste.org/71102
09:26:40 <hpc> memoFact 5001 = memoize (5001 * memoFact 5000) -- nice and quick
09:26:52 <hpc> or something like that
09:27:38 <obk> What is with http://hpaste.org/71102 ?  Adding {-# LANGUAGE TemplateHaskell #-} doesn't make a difference.
09:27:41 <ski> mkramer : now, the problem with `memoize fib' is that this will "only memoize the whole function", it won't detect the recursive calls, and check if those have already been computed
09:28:46 <hpc> obk: http://hackage.haskell.org/packages/archive/template-haskell/latest/doc/html/Language-Haskell-TH-Syntax.html#t:Name
09:29:02 <ski> mkramer : to make this possible, we need to somehow make the recursive calls "visible" to the memoizing, so that we can in effect "insert" a `memoize' call around each recursive call
09:29:08 <hpc> you need to match on the Name constructor, not ''Name
09:29:13 <ski> mkramer : does what i'm saying so far make any sense ?
09:29:26 <hpc> er
09:29:26 <mkramer> yes
09:29:28 <hpc> you need to match on the Name constructor, not ''Foo
09:29:36 <obk> I see...
09:29:38 <ski> so, let's rewrite `fib' above to
09:30:04 <ski>   fibWith fib 0 = 0
09:30:07 <ski>   fibWith fib 1 = 1
09:30:17 <ski>   fibWith fib 1 = fib (n - 1) + fib (n - 2)
09:30:32 <mkramer> s/1/n/
09:30:45 <ski> note how we pass `fib', which is meant to be the "final function" as an *argument* to `fibWith', which is the "incomplete function"
09:30:51 <ski> yes, sorry
09:31:06 <ski> now, we can easily recover the original `fib', by saying
09:31:06 <obk> hpc: I don't suppose there's an easy syntax for that?
09:31:18 <hpc> dunno
09:31:20 <ski>   fib = fibWith fib
09:31:24 <ski> or, alternatively
09:31:26 <hpc> i try to keep TH to a minimum in my projects
09:31:26 <ski>   fib = fix fibWith
09:31:33 <obk> hpc: I see. Thanks!
09:31:40 <ski> of course, we haven't added any memoizing yet
09:31:43 <ski> mkramer : ok ?
09:32:22 <mkramer> one second...
09:32:22 <ksf> basically, the xcb specs define the wire format and a way to check the validity of some fields, the latter rather incomplete (but getting better). It doesn't care a bit about the API side of things.
09:33:35 <ski> mkramer : the point with `fibWith' is that it's *not* recursive ! we've untangled the recursion from it, instead passing its "final self" as an argument to it, and it calls that instead of calling recursively
09:34:23 <mkramer> fibWith :: (a -> b) -> (a -> b) ?
09:34:26 <hpc> yes
09:34:35 <ski> well, really
09:34:44 <hpc> with a, b = Int or something
09:35:03 <ski>   fibWith :: (Integral i,Num n) => (i -> n) -> (i -> n)  -- i think
09:35:41 <ski> @type let fibWith fib 0 = 0; fibWith fib 1 = 1; fibWith fib n = fib (n - 2) + fib (n - 1) in fibWith
09:35:42 <lambdabot> forall t a. (Num a, Num t) => (t -> a) -> t -> a
09:35:43 <hpc> ski: (i -> i) -> i -> i
09:35:48 <ski> ok, `Num' for both
09:35:50 <hpc> you pass the result to the input again
09:35:57 <ski> i don't
09:36:03 <hpc> er
09:36:04 <hpc> oh
09:36:14 <mkramer> Alright‚Ä¶I see that
09:36:14 <hpc> i keep forgetting it's not actually recursive
09:36:19 <hpc> even though i know it isn't
09:36:23 <mkramer> fibWith is a non-recursive definition of fib
09:36:45 <ski> mkramer : now, we can simply replace
09:36:49 <ski>   fib = fix fibWith
09:36:50 <ski> by
09:36:50 <ski>   memoedFib = memoFix fibWith
09:37:02 <ski> to get the memoized version of `fib' :)
09:37:58 <ski> note that `memoFix' "inserts" a call to `memoize' "around" each recursive call -- or actually, it calls `memoize' once, and inserts the result of that as the recursive calls
09:39:50 <mkramer> eh, I think I got lost because "fix fibWith" is not something you showed in your explanation up to this point
09:40:26 <ski> ok, let's show the definition of `fix'
09:40:30 <ski>   fix f = x
09:40:32 <ski>     where
09:40:34 <ski>     x = f x
09:40:36 <kallisti> I just got here.  the fix stuff is simple enough. but I missed the part out memoization.
09:40:48 <ski> consider the simple example
09:40:51 <mkramer> oh‚Ä¶ fix is something that's defined in the Prelude?
09:40:57 <kallisti> Data.Function
09:40:58 <ski>   ones = fix (1 :)
09:40:59 <ski> mkramer : yes
09:41:08 <kallisti> @hoogle fix
09:41:08 <lambdabot> Control.Monad.Fix module Control.Monad.Fix
09:41:09 <lambdabot> Data.Fixed module Data.Fixed
09:41:09 <lambdabot> Data.Function fix :: (a -> a) -> a
09:41:12 <ski> well, yes, not in `Prelude' itself, but in libs
09:41:17 <mkramer> AHH!!!
09:41:19 <mkramer> damnit!
09:41:32 <ski> now, the definition
09:41:34 <ski>   ones = fix (1 :)
09:41:41 <ski> can be simplified to
09:41:45 <ski>   ones = x
09:41:47 <ski>     where
09:41:52 <ski>     x = (1 :) x
09:41:53 <kallisti> > fix (\f n -> if n > 1 then n*f(n-1) else 1) 5
09:41:54 <lambdabot>   120
09:41:54 <ski> or
09:41:59 <kallisti> factorial defined with fix.
09:42:00 <dmwit> fibWith is a function that takes an approximation of the fibonaccis and returns a better approximation; fix is a function that takes approximation-improvers and turns them into the actual value
09:42:02 <ski>   ones = 1 : ones
09:43:35 <kallisti> mkramer: basically, in "fix f", the function f is applied to fix f.
09:43:46 <kallisti> (except it's written differently to make it more efficient)
09:43:59 <ski> mkramer : iow, `fix' is a function that takes : a function that wants the "finished version of itself" as an argument, and returns the "finished version of itself" -- and then `fix' connects the output here back to the input, and returns the cyclic value
09:44:23 <ski> mkramer : note that `ones = 1 : ones' defines a cyclic/recursive value, but recursive functions are also cyclic values
09:44:53 <ski> mkramer : does that make any sense ?
09:44:58 <deech> Besides typeclasses is there a way of getting different datatypes to share common functions.
09:45:12 <mkramer> not yet, I might need a few minutes to wrestle with that
09:45:26 <ski> deech : abstract over the differing parts, possibly
09:45:35 <ski> mkramer : sure, take your time
09:45:44 <nand`> deech: polymorphism does that in general. Type class constraints are just a part of polymorphism
09:46:05 <ski> mkramer : when you want, i have a few more examples, and ways to do memoization with another operation than `memoize'
09:47:22 <deech> ski, nand`: The reason I ask is that I was showing a friend of mine how records can't have common fields and told them that typeclasses are the only mechanism available for something like that. Just wanted to make sure.
09:47:38 <nand`> records can have common fields
09:47:41 <nand`> as long as they're the same data type
09:48:13 <deech> nand`: Right, I'm thinking different data types.
09:49:13 <ski> you can define "common" functions which are named differently, or defined with (possibly) same name in different modules
09:49:38 <deech> ski: Is that considered good practice though?
09:49:43 <kallisti> yes
09:50:49 <dmwit> I don't think it's fair to claim that the argument to fix expects a finished version of itself as an argument.
09:51:08 <kallisti> unlike how most OO languages are used, typeclasses are not our primary means of abstraction and reusability.
09:51:08 <dmwit> Any good argument to fix will make an improved approximation out of any stupid old thing of the right type.
09:51:09 <Athas> nand`: are you sure about that?
09:51:44 <Athas> Perhaps I misunderstood you, but what would be the type of the accessor function if several record types shared fields?
09:51:45 <dmwit> Athas: Yes. Try data Foo = Foo { a :: Int } | Bar { a :: Int }
09:51:56 <Athas> Oh, right, same type.
09:52:25 <kallisti> deech: a common beginner mistake, in my opinion, is to focus on typeclasses too much,  in the same way that they would focus on defining classes or interfaces first in an OO language.
09:52:41 <CSWookie> What's the Haskell analog to Python's generators?
09:52:47 <kallisti> everything
09:53:10 <kallisti> I guess conduits/pipes function similarly.
09:53:24 <ski> dmwit : yes, it was only meant as a rough sketch of how to think
09:53:44 <nand`> kallisti speaks wise words, all too often do you see people using type classes where data types would have been entirely appropriate
09:54:00 <dmwit> CSWookie: [a]
09:54:07 <ski> dmwit : in fact, often, if we don't look "too early" at the argument, it will be(come) exactly what we want it to be, when the knot is tied, but if we "look at it too early", things will fail
09:54:09 <nand`> the difference being that haskell has sum types; a concept very remote to OO programmers
09:54:10 <CSWookie> I'm wanting to make a thing that I can use to return the next prime number.  So call it once it returns 1, the second time 2, and so on.
09:54:25 <mroman> @hoogle delay
09:54:26 <lambdabot> Control.Concurrent threadDelay :: Int -> IO ()
09:54:26 <lambdabot> GHC.Conc.IO threadDelay :: Int -> IO ()
09:54:26 <lambdabot> GHC.Conc threadDelay :: Int -> IO ()
09:54:30 <dmwit> CSWookie: write primes :: [Integer]
09:54:57 <kallisti> CSWookie: why not just generate an infinite list of prime numbers?
09:55:15 <Athas> And in my experience, in many cases where you might use typeclasses do do pseudo-OO, using explicit dictionaries (pretty much just desugared typeclasses) is better.
09:55:16 <kallisti> when you meant "generators" I thought you were referring to the coroutine-like aspects.
09:55:18 <dmwit> Yes. Lists (infinite or otherwise) are Haskell's equivalent of Python's generators.
09:55:19 <nobdraisentone> CSWookie: take a look at list monad and `‚Üê' operator
09:55:25 <kallisti> but if you're just iterating through values in sequence, that's preceisely what linked lists do.
09:55:33 <dmwit> kallisti: [a] is like a coroutine, yes
09:55:39 <kallisti> dmwit: not entirely.
09:55:55 <kallisti> I think something like [a -> b]  would be a coroutine.
09:56:01 <kallisti> er, no.
09:56:16 <ski> CSWookie : note that `1' is not a prime number
09:56:28 <dmwit> kallisti: Can you say why you don't like [a] as a coroutine?
09:56:50 <tertl6> is there a haskell cheat sheet with all typeclasses on it?
09:56:56 <kallisti> dmwit: how are you inputting values?
09:57:27 <CSWookie> ski: Yeah... it's the unit.
09:57:33 <applicative> tertl6: no, what kind of type class do you mean, like Num, Eq, or like Monad, Functor
09:57:37 <dmwit> kallisti: What are you talking about?
09:57:40 <CSWookie> But piss on that.
09:57:46 <tertl6> Ord
09:57:52 <tertl6> ord is order?
09:57:59 <Athas> Ordered, yes.
09:58:02 <tertl6> ahh ok
09:58:03 <dmwit> kallisti: Perhaps you'd like a coroutine parameterized by something, in which case a -> [b] looks sane.
09:59:08 <kallisti> dmwit: the idea is that you produce a value, at which point the computations suspends until a new value is supplied.
09:59:12 <kallisti> you need a continuation.
09:59:34 <CSWookie> kallisti: I've no reason not to use a list of primes.  I'm a noob, though, so my first impulse will probably always be a kluge.
09:59:53 <ski> kallisti : for an interesting example of coroutines, try defining `zipWith' (or `zip'), using only a single call to `foldr' for each input list to traverse and match on it, using no other recursion
09:59:57 <dmwit> kallisti: Oh, I see. "coroutine" is actually not a synonym for "generator"
10:00:12 <kallisti> dmwit: well, in python terminology it is.
10:00:19 <applicative> http://nix-tips.blogspot.com/2010/07/hierarchy-of-numeric-typeclasses-in.html  -- tert16 this is not a good  one, i'm looking for another
10:00:49 <dmwit> kallisti: Python generators don't take additional arguments at each iteration step.
10:00:54 <kallisti> dmwit: yes they do.
10:01:02 <kallisti> perhaps you've been away from python too long.
10:01:20 <dmwit> Perhaps. But from the page I'm looking at, generators are essentially functions from values to iterators.
10:01:39 <dmwit> e.g. xrange() has an initial argument, but no subsequent arguments.
10:01:42 <kallisti> that's how it worked at one point, but now the yield statement is an expression that evaluates to the value that's sent to the generator object.
10:01:56 <kallisti> .next() is just .send(None)
10:02:00 <dmwit> I see.
10:02:18 <kallisti> so when he said "generator" I thought he was talking about coroutines in general
10:02:30 <kallisti> for an "iterator", yes a linked list is equivalent
10:03:48 <applicative> tertl6: in that picture, the important thing is the difference between the ones in grey boxes, the real concrete types, and all the superordinate 'classes' which support the functions listed
10:04:11 <optimight> famp: What makes you believe hackage is not suitable for private project?
10:04:36 <optimight> fmap: What makes you believe hackage is not suitable for private project?
10:04:54 <tertl6> hmm
10:05:01 <tertl6> i dont really see any grey
10:05:12 <tertl6> lemme try anopther browser
10:05:46 <applicative> so if a type, e.g. Integer is in Eq you get == and /==, if it's in Enum you get succ pred and the [a..z] notation etc
10:06:02 <kallisti> dmwit: I think something like data Gen a b = Next b (a -> Next a b) | Done  would be similar to the way a generator works in Python.
10:06:13 <kallisti> b is the type of intermediate values, a is the input type.
10:06:23 * dmwit nods
10:06:39 <applicative> tertl6: there are three thin grey rectangles around some regular ones; the difference ought to be emphasized differently, I'd think
10:06:50 <Athas> kallisti: I've always wondered why there isn't a "stream reader" monad that encapsulates that concept.
10:07:00 <tertl6> yeah, a better picture is in order for that
10:07:03 <Athas> That is, a Reader where reading has side effects.
10:07:26 <Athas> (Well, I've wondered why there isn't such a monad in the standard libraries.  I've written several myself, of course.)
10:07:43 <kallisti> well, conduits are very similar to coroutines.
10:07:51 <applicative> any it gives the  idea, tertl6 .  There should be an arrow from  Ord to Eq
10:08:56 <ski> kallisti : .. any idea how to define `zipWith' in that way ?
10:09:11 <kallisti> ski: oh, sorry. I'll scroll up.
10:10:22 <dmwit> Dang.
10:11:03 <dmwit> I vaguely remember watching a video of a talk about defining the denotational space of FRP activities via functions from lists to lists with a couple restrictions...
10:11:12 <dmwit> That talk was very relevant to this coroutine stuff.
10:11:14 <dmwit> But now I can't find it.
10:11:21 <tertl6> thank you applicative
10:11:24 <dmwit> It was just on a whiteboard.
10:11:26 <ski> kallisti : so, you're not allowed to match yourself on the two lists, and you're not allowed to use stuff like `foldr (\a _ -> Just a) Nothing' either :) -- and no explicit recursion (only via `foldr')
10:11:36 <applicative> tertl6: here this looks better http://www.bucephalus.org/text/Haskell98numbers/Haskell98numbers.pdf
10:11:40 <kallisti> ski: right
10:13:17 <ski> kallisti : i'll let you think about it, if you think it's interesting -- at least i thought it was interesting and eye-opening when i did it :)
10:13:56 <kallisti> ski: may I humbly request 2 foldrs?
10:14:18 <applicative> tertl6: that one too fails to make the difference between the typeclasses and the concrete types as clear as it could be. the double arrows are class subordination, single arrows  take you to a real type
10:14:28 <ski> kallisti : yes, you're allowed one `foldr' per input list
10:15:31 <ski> (and it doesn't matter if you do `zip' or `zipWith' -- do whichever you prefer)
10:15:58 <applicative> tertl6: there's something messy going on with Ratio and Complex in that representation, but it corresponds to an additional complexity.
10:16:09 <tertl6> ah ok
10:16:58 <mkramer> ok, I'm starting to grok fix
10:17:07 <fmap> optimight: what?
10:17:08 <fmap> ah
10:17:18 <mkramer> I think my conceptual gap was that I didn't / don't understand fix, which is a prerequisite to understanding memoFix
10:17:23 <ski> mkramer : yes
10:17:25 <applicative> tertl6: do you know that in ghci if you type e.g. :info RealFrac or :i RealFrac it will tell you what the 'methods' are and so on
10:17:45 <mkramer> fix is a way of lifting recursion out
10:17:45 <tertl6> oh really
10:17:57 <fmap> optimight: i don't think it's possible to hide sources on hackage somehow
10:17:57 <kallisti> ski: zipWith f as bs = foldr (\a ls -> f a : ls) [] as   -- incomplete, am I going in the right direction?
10:18:10 <applicative> tertl6: this frequently helps when you get an opaque type error involving a type class :)
10:18:23 <tertl6> thank you very much
10:18:25 <ski> > fix (\fact n -> if n == 0 then 1 else n * fact (n - 1)) 5  -- mkramer you should understand this, e.g.
10:18:26 <lambdabot>   120
10:18:34 <ski> > fix (\fact n -> if n == 0 then 1 else n * fact (n - 1)) 5 :: Expr
10:18:35 <lambdabot>   5 * ((5 - 1) * ((5 - 1 - 1) * ((5 - 1 - 1 - 1) * ((5 - 1 - 1 - 1 - 1) * 1))))
10:19:08 <ski> mkramer : yes, `fix' is a way of "doing recursion" without (explicit) recursion
10:19:17 <optimight> fmap: I think you believe that hackage is not suitable for private project but do not know the reasons behind it. I am curious to know that hackage is suitable for private project or not?
10:19:24 <applicative> tertl6: it also works with data types like :i Either will tell you the definition of Either, and the classes it instances (for the classes in scope)
10:19:45 <ski> kallisti : it's hard to say
10:20:00 <tertl6> applicative cool
10:20:17 <kallisti> ski: I think I need to pass each foldr something from the other.
10:20:19 <kallisti> not sure what though
10:20:23 <CSWookie> I'm getting a parse error at = in the interactive interpreter when I do something like: froor = 6
10:20:26 <ski> kallisti : you're right
10:20:30 <CSWookie> Why?
10:20:51 <eviltwin_b> CSWookie: because it is not a toplevel.  use let
10:21:01 <ski> (kallisti : there's a reason i mentioned this in response to the talk about coroutines here)
10:21:33 <optimight> fmap: I am new to haskell , just a beginner but I have read somewhere about code competiotion which was suggesting that the haskell code can be obfuscated
10:22:22 <kallisti> any language can be obfuscated.
10:22:26 <roconnor> for some reason some people argue that idomatic Haskell code is already obfuscated.
10:22:31 <kallisti> assuming it's suitably powerful.
10:22:34 <dmwit> ski: Hm. I've got a version with one foldr and no other recursion, but somehow it must not be what you mean.
10:22:35 <ski> CSWookie : the interactor is mainly for *evaluating expresions*, while your module file is mainly for defining things
10:22:52 <ski> CSWookie : as eviltwin_b said, you can use `let froor = 6' in the interactor, though
10:23:13 <dmwit> > let zip' = foldr (\x f ys -> case ys of { [] -> []; (y:ys) -> (x, y) : f ys }) (\ys -> []) in zip' [1..5] [10..]
10:23:14 <lambdabot>   [(1,10),(2,11),(3,12),(4,13),(5,14)]
10:23:30 <ski> dmwit : that fails the "no matching on lists, except via `foldr'" part
10:23:37 <dmwit> Oh, well.
10:24:18 <ski> kallisti : i'll let you mull over it as long as you like, then :)
10:24:28 <ski> (and anybody else who is interested ..)
10:24:31 <optimight> kallisti: I do agree that any langauage can be obfuscated ... Here the attempt is to safeguard the interest of the private project and to hide the code
10:27:12 <optimight> kallisti: I believe obfuscation can help not in full but to some extent that the haskell code can be made (obfuscated) in a way that it protects the interest of the private project
10:27:32 <kallisti> well, you can create a barrier of entry to understand it, sure.
10:27:55 <kallisti> people use obfuscation for the same purposes in many languages. I'm not sure what makes Haskell special here.
10:28:38 <daniel_-> hmmm i remember reading in LYAH that "_ <- blabla" could be written in some other way?
10:28:46 <hpc> "blabla"
10:28:48 <daniel_-> but cant find the chapter
10:28:51 <daniel_-> oh
10:29:12 <kallisti> _ <- blabla  is typically used to suppress warnings.
10:29:14 <eviltwin_b> although that should elicit a warning in recent ghc versios
10:29:17 <kallisti> about discarded result types.
10:29:25 <hpc> only if you turn on that warning
10:29:33 <kallisti> of course.
10:29:40 <hpc> i think _ <- is visual noise
10:29:43 <dmwit> ?let patternMatchOnLists nil cons = fst . foldr (\a (b, rest) -> (cons a rest, a:rest)) (nil, [])
10:29:44 <lambdabot>  Defined.
10:30:03 <dmwit> > let zip' = foldr (\x f -> patternMatchOnLists [] (\y ys -> (x, y) : f ys)) in zip' [1..5] [10..]
10:30:05 <lambdabot>   Couldn't match expected type `[a1] -> [(a, a1)]'
10:30:05 <lambdabot>         against inferred t...
10:30:14 <optimight> kallisti:  Is it possible to completely hide the haskell code or not?   I think there is a feature that you put your code in other package so it becomes hidden, is this correct or I am wrong?
10:31:12 <mcstar> http://www.reddit.com/r/haskell/comments/vi425/what_are_everyones_favorite_aha_moments_in/c557qcu
10:31:31 <dmwit> Oh, even after I fix it that's not a zip.
10:32:38 <dmwit> ?undefine
10:32:53 <dmwit> ?botsnack
10:32:54 <lambdabot> :)
10:32:55 <mcstar> @
10:32:58 <dmwit> ?undefine
10:33:07 <dmwit> ?help eval
10:33:07 <lambdabot> eval. Do nothing (perversely)
10:33:24 <dmwit> ?list
10:33:24 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
10:33:45 <dmwit> > patternMatchOnLists -- is this still defined?
10:33:46 <lambdabot>   Not in scope: `patternMatchOnLists'
10:33:54 <dmwit> ?let patternMatchOnLists nil cons = fst . foldr (\a ~(b, rest) -> (cons a rest, a:rest)) (nil, [])
10:33:55 <lambdabot>  Defined.
10:34:12 <dmwit> > let zip' = foldr (\x f -> patternMatchOnLists [] (\y ys -> (x, y) : f ys)) (\ys -> []) in zip' [1..5] [10..]
10:34:14 <lambdabot>   [(1,10),(2,11),(3,12),(4,13),(5,14)]
10:34:22 <dmwit> ski: The trivial fix to your previous complaint...
10:35:43 <dmwit> Still, I don't think it's in the spirit of the question.
10:35:50 * dmwit continues thinking
10:35:57 <mroman> http://codepad.org/dePhdw5g o_O
10:37:27 <mcstar> mroman: cool, is it automatic?
10:37:35 <mroman> mcstar: yes.
10:39:16 <mroman> mcstar: http://codepad.org/mrkhi5MU
10:39:20 <mroman> ^- Source Code.
10:40:00 <mcstar> mroman: what drives the simplification?
10:41:03 <mcstar> mroman: have you read this? http://www.thenewsh.com/~newsham/formal/curryhoward/
10:41:14 <mroman> It tries to apply every rule
10:41:21 <mroman> filters out the ones that did not change anything
10:41:38 <mroman> and repeats this until no rule produce a new unknown term.
10:41:45 <mroman> *produces
10:41:49 <mcstar> how fast is it?
10:42:17 <mcstar> i.e. how many rewrites did that proof need?
10:42:54 <mroman> 118
10:43:08 <mcstar> no
10:43:09 <mroman> it generates every possible rewrite
10:43:20 <mcstar> ok, so how many was that?
10:43:56 <mroman> The output is 119 lines.
10:44:03 <mcstar> i can see that
10:44:10 <mroman> But every rule is applied
10:44:14 <mroman> so it's a very huge amount ;)
10:44:14 <mcstar> that however does not answer my question
10:44:19 <mcstar> yes, huge
10:44:28 <mroman> it's very slow, yes.
10:44:34 <mroman> takes 0.5seconds on my cpu.
10:45:12 <kallisti> optimight: modules allow explicit export lists
10:45:27 <kallisti> in addition the cabal build tool has exposted-modules and other-modules.  other-modules are hidden.
10:45:30 <mroman> mcstar: And my knowledge is not enough to understand the curry-howard correspondence.
10:45:50 <kallisti> optimight: so other-modules can contain internal modules that need to be used by exposed modules.
10:45:56 <mcstar> mroman: im not a CS major, and it was a good read
10:45:59 <kallisti> and exposed modules can explicitly hide utilities and helper functions.
10:46:22 <mroman> Yes.
10:46:37 <mroman> And I fix broken office installations.
10:46:37 <kallisti> optimight: but yes, modules are the basic unit of code organization.
10:46:40 <mroman> that's all I do.
10:46:53 <mroman> So my lack of knowledge is huge.
10:47:28 <mcstar> mroman: erm, you write haskell code, so cant be too stupid, give credit for yourself
10:47:45 <mcstar> btw, that particular equation can be solved in 1 line
10:48:02 <mroman> I can solve it in my head in three steps.
10:48:21 <mcstar> depends on how you count, but yeah
10:48:49 <mroman> de morgan on the left part
10:49:05 <mroman> !p ==q -> !(p == q)
10:49:09 <kallisti> optimight: essentially, where code organization/hiding/abstraction is centered on objects/data in OO; Haskell uses modules for organization/hiding, and functions for abstraction.
10:49:10 <mroman> !true = false
10:49:54 * hackagebot haskell-updater 1.2.0.6 - Rebuild Haskell dependencies in Gentoo  http://hackage.haskell.org/package/haskell-updater-1.2.0.6 (SergeiTrofimovich)
10:50:50 <nand`> how to simplify foldr f x . unfoldr g -- what about foldl ?
10:51:17 <mroman> mcstar: But only because I can see which rules I should try to apply first.
10:51:29 <mroman> but my haskell program doesn't do guess work :(
10:52:56 <optimight> kallisti: In short, can we say that the haskell code can be hidden and not visible and not possible for external persons/tools to read it, so haskell code can be used in private project?
10:54:03 <kallisti> optimight: well, if you have access to the source code, you can view all the things that are "hidden."  hiding in this case is a tool for interface design, not to conceal a "trade secret" of some kind.
10:54:18 <kallisti> if you only have the compiled binary, then yes, you can't read the source code.
10:54:46 <dmwit> nand`: The analogue to foldr in the "other direction" is buildr, not unfoldr.
10:54:58 <dmwit> ?google foldr buildr fusion
10:55:00 <lambdabot> http://www.haskell.org/haskellwiki/Correctness_of_short_cut_fusion
10:55:00 <lambdabot> Title: Correctness of short cut fusion - HaskellWiki
10:55:41 <dmwit> Alternately, the analogue to unfoldr in the "other direction" is destroy, not foldr. =)
10:56:54 <optimight> kallisti: okay..  someone develops the code with some trade secret. Converts it to binary. And then distributes the binary to users. Then his/her trade secrets will be secured and not accesible by the users. Only someone who has access to source code can go through the trade secret, right?
10:57:07 <pv2b> wrong.
10:57:28 <kallisti> optimight: well you could attempt to disassemble the binary.
10:57:33 <kallisti> this isn't anything specific to Haskell
10:58:42 <kallisti> any language with a compiler operates in a similar fashion.
10:59:04 <optimight> What is the difficutly level to disassemble (reverse enginner) the binary of haskell code ?
10:59:07 <pv2b> compiling stuff doesn't magically make it impossible to reverse-engineer. it just makes it harder. how hard depends on the specific compiler in use. for stuff like Java for example, there exist free tools out there that will practically give you the original source code (sans comments of course)
10:59:13 <dmwit> DRM is the constant battle between people who wish it were possible to keep secrets and show the user secrets at the same time and people who know it isn't.
10:59:46 <optimight> Or How to protect trade secret written in haskell code?
10:59:50 <kallisti> optimight: pretty difficult compared to C or similar languages.
11:00:02 <dmwit> optimight: The only way to protect your trade secret is to keep the program to yourself.
11:00:22 <dmwit> You might consider putting a web front-end on your trade secret, so that people can use the program but not inspect it.
11:00:25 <pv2b> in the end, distributing a program is all about telling a computer how to do things. you can't fundamentally tell a computer to do things and not tell users. unless you do what a lot of companies do and don't give your users a copy of the software, instead let them send the input to you, and get the output back
11:00:44 <mroman> mcstar: And mine does not work if it requires expansion.
11:00:49 <nand`> dmwit: or given adequate law enforcement you can put a horrible license on it; while this does not keep secrets it prevents people from using them
11:00:53 <mroman> like p || (p && q) == p
11:00:57 <dmwit> People will still be able to garner input/output pairs, but it's much harder to intuit trade secrets from those than from an intensional view of the function used to turn inputs to outputs.
11:01:05 <mroman> which would require an expansion from p to (p || p)
11:01:34 <mroman> so that (p || p) && (p || q) == p -> p && (p || q) == p -> true
11:01:55 <mcstar> mroman: well, i just enumerate the possible truth values of the subexpressions
11:02:07 <mroman> expansion does not work because p -> (p || p) also yields to
11:02:15 <mroman> (p || p) -> (p || p) || (p || p)
11:02:19 <dmwit> optimight: Alternately, you can do what banks do, and measure your trade secret's secrecy in "time to discern" rather than "is it discernible or not".
11:02:20 <mroman> and I'd run into an endless loop.
11:02:28 <mcstar> for example, p=T, trivially true, p=F, will be false, cause p is in an &&
11:02:36 <dmwit> (I really think CS security theory needs to move in this direction.)
11:02:51 <mroman> brute forcing every possible value?
11:03:01 <mcstar> not necessarily
11:03:07 <mroman> that'd be the easiest way to do it.
11:03:12 <mcstar> but its a small space
11:03:17 <mroman> except that it's not really rewriting anymore.
11:03:18 <dmwit> Perhaps you feel, for example, that developing a system that makes the time to discern higher than the time it took you to develop the trade secret is sufficient.
11:03:28 <dmwit> Then you have to ask how much time you're willing to spend trying to develop such a system.
11:03:35 <kallisti> optimight: there's definitely more indirection in a Haskell binary when compared to a C binary for an approximately equivalent program.
11:03:45 <mcstar> mroman: no, ofc, but easier to prove the equality :)
11:04:36 <kallisti> optimight: but using these facts in an argument that "Haskell makes it easy to protect intellectual property" is silly.
11:04:57 <optimight> kallisti: yes
11:05:15 <mcstar> it is very easy to protect haskell code
11:05:43 <optimight> dmwit: your is valid that measure your trade secret's secrecy in "time to discern" rather than "is it discernible or not"
11:07:11 <osfameron> you should be able to rely on copyright law (and patents if you really must) to protect your nontrivial IP discoveries
11:08:02 <optimight> dmwit: I also agree with your suggestion - "You might consider putting a web front-end on your trade secret, so that people can use the program but not inspect it".
11:08:26 <mcstar> (i was thinking of the same thing: put it i nthe cloud, and offer it as a service)
11:09:27 <dmwit> osfameron: copyright law is slimy
11:09:51 <pv2b> be careful when taking the step out in the cloud though.
11:09:55 <pv2b> you might fall through.
11:10:41 <nand`> cloud computing is impractical until we have general purpose homomorphic encryption algorithms
11:11:03 <optimight> pv2b: Can you explain further? - " be careful when taking the step out in the cloud though.
11:11:03 <optimight> 23:39 <pv2b> you might fall through."
11:11:16 <pv2b> the cloud is not something you can walk on.
11:11:24 <pv2b> it's kinda... gassy.
11:11:39 <osfameron> dmwit: all IP is slimy
11:11:51 <dmwit> yes
11:11:56 <cjay> pv2b: pegasus ponies can
11:12:00 <dmwit> Information wants to be free.
11:12:11 <mcstar> and i want free information
11:12:22 <dmwit> The third prime is 5.
11:12:23 <dmwit> no charge
11:12:34 * mcstar thanks
11:12:37 <monochrom> @quote anthropol
11:12:37 <lambdabot> No quotes match. :(
11:13:35 <osfameron> optimight: this isn't really a haskell question/answer.  Your best bet, from a "not going crazy" point of view is to either a) get a bloody good legal team, b) embrace open source where applicable, and common sense where not, and don't worry about it too much
11:13:53 <mcstar> just improve on your product constantly, with the best team, and best technologies
11:14:01 <mcstar> and always stay one step ahead of the competition
11:15:10 <dmwit> c) realize that probably nobody cares about your trade secret after all
11:15:23 <osfameron> c is really part of b
11:15:25 <optimight> osfameron: I just wanted to learn the technical aspects
11:15:40 <osfameron> optimight: oh?  carry on then, soldier
11:15:48 <osfameron> it's a problem that doesn't interest me that much these days ;-)
11:15:59 <osfameron> I did worry about it briefly when I first started programming, to be fair
11:16:40 <nand`> why is proprietary software always about ‚Äústaying one step ahead‚Äù? What ever happened to ‚Äúimplement what the consumer wants, not what you think the consumer might want‚Äù?
11:17:18 <osfameron> ahead of the competition, not of the consumer
11:17:21 <mcstar> nand`: nono, what i said(or wanted to say) dont worry about technology leaking, just do the best job possible
11:17:33 <mcstar> that possibly includes considering customer requirements
11:17:35 <monochrom> what consumer wants changed. stay one step ahead in tracking that change!
11:17:36 <osfameron> though the latter is part of good design too
11:17:41 <monochrom> err, type
11:17:47 <monochrom> what consumer wants changes. stay one step ahead in tracking that change!
11:18:26 <z3no> hello everyone
11:18:30 <optimight> If somebody discerns the code and makes better product from there onwards no problem...  only thing people with less skill should not discern it and should not propagate bad versions for their commercial interests
11:20:01 <hlp> Hello, I am new to Linux and Vim. I want to use "ghc-mod" for Haskell (https://github.com/eagletmt/ghcmod-vim) for syntax highlighting and so on. I did "cabal install ghc-mod" and it installed well. How do I now put the ghc-mode in Vim on?
11:20:08 <mcstar> a monopolic situation is desirable, because you dont worry about ppl satisfying their need from somewhere else, and and you can keep the price high
11:20:20 <mcstar> though, in the long run, you will lose on this
11:21:07 <z3no> I'm new to functional programming, new to #haskell, and have a question about recursion, is this the place to ask?,
11:21:19 <dmwit> yep
11:21:32 <mcstar> hlp: if you are new to vim, have you considered going with emacs instead?
11:21:42 <nand`> Is that new to #haskell or new to Haskell?
11:22:18 <z3no> both actually
11:22:38 <dmwit> hlp: cabal install ghc-mod doesn't install the files necessary for Vim, you must use the github link you pasted for that.
11:22:45 <dmwit> At least according to the hackage page.
11:22:46 <z3no> being new to Haskell led me to seek #haskell...
11:22:47 <osfameron> mcstar: tut tut ;-)
11:23:20 <hlp> mcstar: I read an article explaining the advantages of both, and Vim seemed to fit more to me (though I have now I idea, I havent really started using it)
11:23:30 <z3no> I have a function that accepts a seed value, for each seed value it generates 3 alternatives. Each alternative can then generate 3 more, and so on
11:24:00 <z3no> I need to filter out the generated values on some criteria and then make a list of all the values that match
11:24:05 <z3no> and I'm stuck...
11:24:40 <jnoah1984> are actions in haskell essentially non-pure functions?
11:24:47 <dmwit> :t \f pred -> fix (>>= filter pred . f)
11:24:48 <lambdabot> forall b. (b -> [b]) -> (b -> Bool) -> [b]
11:24:51 <ion> jnoah: Not at all.
11:25:03 <mcstar> dmwit: lol
11:25:10 <jnoah1984> ion: then what are they?
11:25:12 <hlp> dmwit: do you mean I have to install "vimproc" (listed in the requirements chapter on the github site)?
11:25:43 <aristid> jnoah1984: if you refer to IO actions, they are instructions to the runtime environment to do something, basically
11:25:44 <ion> jnoah: They are descriptions of IO actions that you can choose to have executed.
11:25:47 <dmwit> hlp: I have no idea. All I know is what I read from the documentation on Hackage, which didn't say much more than what I just told you.
11:25:57 <hlp> ok, thanks
11:26:00 <ion> jnoah: A function is something with -> in its type.
11:26:12 <fmap> hlp: yes, you need vimproc
11:26:18 <dmwit> z3no: What have you tried?
11:26:38 <ion> jnoah: They are not more impure than the string "create a new file named foo"
11:26:50 <ion> IO actions, that is.
11:26:58 <z3no> I tried to have a recursive function that uses and accumulator to collect the items, but on recursion I end up with many duplicates
11:27:28 <fmap> hlp: and to use ghc-mod completion you will need neocomplicache and neco-ghc too
11:28:02 <dmwit> z3no: You can use nub or the more efficient map head . group . sort to eliminate duplicates from a list.
11:28:21 <dmwit> Or, you might consider using a Set instead of a list.
11:28:45 <hlp> fmap: urrg, thanks, I look how to get these installed, the install instructions don't seem to be as easy as typing "cabal install ghc-mod" ... at least for a linux newbie :)
11:28:47 <jnoah1984> aristid, ion thanks
11:28:49 <z3no> didn't know about sets... I was looking at Data.Map also
11:29:18 <dmwit> Sure. Set v is essentially a very slightly optimized version of Map v ()
11:30:18 <z3no> but is there a bit performance hit to construct that incrementally? I was trying to use fromList, and have my function  generate a list...
11:30:51 <z3no> bit=big
11:31:13 <Enigmagic> hlp: you can look at this https://github.com/NathanHowell/dotfiles ... to install vimproc run "make -f make_unix.mak" in the vimproc directory
11:31:47 <dmwit> z3no: For all n, log n < 30.
11:32:20 <z3no> dmwit: thank you for all the help, I'll go try it out now... :)
11:32:26 <dmwit> Good luck!
11:32:32 <dmwit> Let us know any time you get stuck.
11:32:35 <kallisti> nand`: homomorphic encryption algorithms? So you can operate on the data without knowing what it is?
11:32:36 <copumpkin> dmwit: logBase 1.0001
11:32:44 <z3no> many thanks
11:32:45 <z3no> l8tr
11:32:49 <nand`> kallisti: precisely
11:33:20 <dmwit> copumpkin: good thing I didn't say forall m n, logBase m n < 30, eh? ;-)
11:33:27 <copumpkin> :)
11:33:34 <hlp> Enigmagic: this may be a dumb questions .. do I have a vimproc directory? I mean, I haven't installed it yet
11:33:49 <nand`> kallisti: instead of sending your (perhaps private) photos-to-be-enlarged, you send an encrypted copy to the cloud; and the cloud lifts the ‚Äòenlarge‚Äô function to ‚Äòenlarge an encrypted image‚Äô, and sends you back the result, which you decrypt to enjoy your large private photos
11:34:08 <kallisti> interesting
11:34:11 <Enigmagic> hlp: you'll need to clone it. i use pathogen to deal with vim plugins.
11:34:24 <nand`> that way, you can outsource resources without fear of being spied on
11:34:35 <dmwit> Currently, homomorphic encryption is much too inefficient for that scheme to be workable.
11:34:42 <Enigmagic> hlp: you can look through my vim setup in the previous link or just look at pathogen's docs and go from there.
11:34:52 <nand`> yes. best attempts work by constructing another encryption layer inside the encryption layer or something, repeatedly
11:35:02 <dmwit> If you say "my scheme will use secure multiparty computation to do X", everybody already knows X is never going to happen.
11:35:09 <hlp> enigmagic: ok, thanks :)
11:35:28 <dmwit> Which I will admit is not an identical statement to the previous one.
11:35:35 <nand`> that's precisely why I want an efficient general purpose homomorphic encryption algorithm :P
11:35:53 <nand`> have the existing ones been implemented in Haskell, mind?
11:35:56 <nand`> (or at all?)
11:36:06 <Enigmagic> hlp: i'd definitely recommend using pathogen or something similar to manage bundles and git for versioning.
11:36:07 <mcstar> sounds like science fiction, much like isolinear chips
11:36:11 <mcstar> or positronic brains
11:36:14 <dmwit> Also, most of the existing ones support either addition or multiplication (of bits), but not both...
11:36:24 <dmwit> makes it hard to do any interesting computation
11:36:50 <nand`> dmwit: yeah, those are partially homomorphic, but I'm talking fully homomorphic
11:37:19 * dmwit aspirates
11:37:24 <dmwit> You'll be waiting a while, I think. =)
11:37:32 <nand`> At the rump session of Eurocrypt 2010, Craig Gentry and Shai Halevi presented a working implementation of fully homomorphic encryption (i.e. the entire bootstrapping procedure) together with performance numbers.[14]
11:37:47 <nand`> I want to see these ‚Äúperformance numbers‚Äù :P
11:39:28 <mcstar> i can imagine this, as having a trapdoor function for every requested operation
11:39:31 <EvanR-7> mmm homomorphic encryption
11:39:48 <nand`> heh. ‚ÄúDimension 32768: KeyGen 2 hours, PK size 2.3 GByte, Re-Crypt: 30 min‚Äù
11:39:50 <companion_cube> let performance_number = 42 in performance_number
11:40:00 <nand`> admittedly I have no idea what ‚ÄòDimension‚Äô refers to
11:40:11 <mcstar> how long the stream
11:40:17 <mcstar> no?
11:40:25 <nand`> ah
11:40:26 <dmwit> 2 gigabyte private key
11:40:28 <dmwit> lovely
11:40:29 <nand`> 13,000,000-bit integers
11:40:29 <mcstar> lol, the key is gigantic
11:40:52 <nand`> for dimension 512 (200,000 bit integers) keygen is 2.4 sec, PK size is 17 MB and re-crypt is 6s
11:40:58 <dmwit> > logBase 10 (2^32768)
11:40:58 <nand`> I could just link the darn thing
11:40:59 <lambdabot>   Infinity
11:41:00 <nand`> http://eurocrypt2010rump.cr.yp.to/9854ad3cab48983f7c2c5a2258e27717.pdf
11:41:15 <mcstar> nand`: that was smart
11:41:30 <companion_cube> "here is my public key, on this blue-ray"
11:41:54 <nand`> companion_cube: where we're headed that might as well be feasible
11:42:04 <mcstar> it will get better, when they'll use elliptic curves..
11:42:17 <dmwit> "here is my public key, on this blu-ray, will you please enlarge by 2kb JPG with it?"
11:42:34 <serialhex> erm.... wah???
11:42:36 <companion_cube> s/enlarge/sign/, you mean?
11:42:55 <dmwit> Yeah, that was not what I meant.
11:43:01 <eviltwin_b> stegangrph?
11:43:19 <eviltwin_b> +o+a
11:43:21 <serialhex> ahh...  makes | | much more sense
11:43:36 <mcstar> dmwit: i think the image enlargement is particluarly bad example
11:43:38 <dmwit> nand`: I'm not sure I understand what these numbers mean.
11:44:02 <noteventime> Has someone tried making a QuickCheck/pipes-core package (given some Gen its easy to create a Gen for Pipes)?
11:44:03 <nand`> one thing that confuses me about homomorphic encryption: say I pass an encrypted complex number, and want the cloud to render me a mandelbrot set approximation for those coordinates. Would they be able to monitor how much computational cost the operation had to know whereabouts the coordinates may have been?
11:44:10 <nand`> dmwit: ditto
11:44:12 <nand`> dmwit: but they sound funny
11:44:15 <dmwit> nand`: Does "re-crypt time" mean how long it takes to do one arithmetic operation on a whatever-bit encrypted number?
11:44:55 <dmwit> nand`: Typically these schemes come along with a language in which all programs take the same amount of time to handle this kind of issue.
11:45:03 <dmwit> nand`: ...which work by taking both branches every time.
11:45:20 <dmwit> s/all programs/all inputs/
11:45:34 <zzo38> Why do I get error "parse error on input `newtype'" when trying to write a Haddock annotation?
11:45:39 <mcstar> dimension means the generated/tested instances
11:45:39 <dmwit> Dunno if the homomorphic encryption stuff is similar or not.
11:45:40 <mcstar> so
11:45:51 <mcstar> thats the numebr how many keys they picked from the keyspace
11:46:05 <nand`> dmwit: I'm not sure, but maybe it has something to do with the way the scheme works; ie. by constructing another homomorphic scheme inside the somewhat homomorphic one
11:46:22 <nand`> dmwit: and yeah, I figured it might work something like that - ie. the computational cost being just as expensive for both variants
11:46:43 <serialhex> nand`: that sounds pretty interesting... though it'd be a julia set, not mandelbrodt (the mmdlbrt just gives all the 'cool' julia sets)
11:46:50 <mcstar> it needs to be, otherwise wouldnt be secure
11:47:40 <nand`> serialhex: you lost a few vowels
11:47:59 <serialhex> yes, i know mdlbrt is easier to type than mandelbrodt
11:51:35 <b0fh_ua> Hi, can you please help me in resolving the problem with installing Sqlite bindings on Windows? http://hpaste.org/71104
11:51:44 <ski> mcstar : (re reddit link) hehe
11:51:47 <ski> dmwit : aye, that goes against "and you're not allowed to use stuff like `foldr (\a _ -> Just a) Nothing'" :)
11:51:48 <b0fh_ua> I'm not sure what has to be done - should I hide some package?
11:53:48 <mcstar> b0fh_ua: you shouldnt have 2 versions of the same package afaik
11:54:16 <b0fh_ua> mcstar: okay, I don't want it either - so what should I do?
11:54:23 <monochrom> you probably have a --user installation of Win32 and you should get rid of it and never allow it to appear again
11:54:51 <mcstar> you could check in ghc-pkg list for duplicates
11:56:31 <monochrom> my http://www.vex.net/~trebla/haskell/sicp.xhtml#pigeon is good reading. in fact, the whole thing is good reading
11:56:45 * applicative agrees
11:57:20 <applicative> ouch, b0fh_ua something is wrong
11:58:49 <monochrom> cabal-install version 0.14 now avoids the pigeon con problem. however, it only avoids the problem if you haven't got it yet. if you have already got the problem, it stays.
11:59:13 <mcstar> monochrom: did you update that page recently?
11:59:20 <monochrom> no
11:59:38 <mcstar> then, my memory is bad as it used to be
11:59:41 <monochrom> but the only update needed is "cabal-install 0.14 now avoids this problem"
12:00:22 <monochrom> and a story for file locations in windows. and macs.
12:01:07 <zzo38> I found out the problem; it is ticket #12
12:01:37 <applicative> b0fh_ua any curiosities with 'ghc-pkg.exe list' and 'ghc-pkg.exe check'
12:07:41 <dmwit> ?src [] (<*>)
12:07:41 <lambdabot> (<*>) = ap
12:07:53 <dmwit> :t (<*>)
12:07:54 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
12:08:11 <dmwit> Oh, I asked the wrong question.
12:08:14 <dmwit> ?src ZipList (<*>)
12:08:14 <lambdabot> Source not found.
12:09:03 <dmwit> pfft, implemented with zipWith, that's cheating
12:09:12 <ion> How is that cheating?
12:09:16 <dmwit> ski: I feel stuck. Have you got any good hints?
12:09:32 <ion> They should implement the ZipList (<*>) with ZipLists or what?
12:09:51 <dmwit> ion: I was hoping it was implemented with foldr. Then I could cheat and copy what they did. =)
12:10:34 <ion> foldr only traverses a single list.
12:10:57 <dmwit> neat, TIL
12:11:51 <b0fh_ua> applicative: a lot of
12:12:03 <copumpkin> dmwit: what's ski's challenge?
12:12:04 <b0fh_ua> in fact looks like there is complete mess in libraries on Windows
12:12:26 <dmwit> copumpkin: Write zip with two foldrs and no funny business.
12:12:31 <copumpkin> oh
12:12:37 <dmwit> e.g. implementing pattern matches with foldr is Right Out
12:12:39 <copumpkin> yeah, that's kind of tricky
12:12:51 <copumpkin> you need your foldr to return a function
12:13:04 <copumpkin> if you wanted a useless hint :)
12:13:15 <dmwit> Well, I managed to invent the solution suggested here on my own: http://stackoverflow.com/questions/235148/implement-zip-using-foldr
12:13:20 <applicative> b0fh_ua: somehow the 'missing recursive dependencies' error is always a really bad sign in my experience, for what my experience is worth
12:13:35 <dmwit> Is that the solution you're thinking of?
12:13:50 <dmwit> If so, that's got funny business (pattern matching on the second list in step).
12:13:56 <copumpkin> I don't think that's the one
12:14:03 <copumpkin> you should be able to do it without explicit pattern matching
12:14:04 <dmwit> alright, well, that's good then
12:15:00 <dmwit> And yeah, "return a function" isn't much of a hint. =)
12:15:15 <b0fh_ua> applicative: well, I'm trying to do it from scratch
12:15:30 <copumpkin> dmwit: let me see if I can figure it out again before I mislead you
12:16:14 <ski> <kallisti> ski: I think I need to pass each foldr something from the other.
12:16:16 <ski> <kallisti> not sure what though
12:16:20 <ski> <ski> kallisti : you're right
12:16:33 <ski> dmwit ^
12:16:38 <dmwit> Oh, that's quite a hint, actually.
12:16:40 <ski> not sure how much you think it helps
12:16:59 <ski> (i'll wait with the next hint, then :(
12:17:07 <ski> (s/:\(/:\)/)
12:17:08 <applicative> b0fh_ua: yeah  I suspect you should get rid of all the locally installed packages to see if the platform libraries are sound.
12:18:09 <b0fh_ua> is there any way to tell cabal not install libraries into C:\program files\Haskell\ ?
12:18:32 <monochrom> yes. "--user", which is cabal-install's default
12:18:42 <serialhex> ski: you know, it took me 30+ secs to figure that out...  :-/
12:18:48 <monochrom> which is not Setup.hs's default, by the way
12:26:49 <applicative> b0fh_ua: I see. It is easy to overwrite Platform libraries if things are being installed  globally.  This is one of the things that can yield 'missing recursive dependencies' nonsense
12:26:57 <dmwit> hum
12:27:41 <b0fh_ua> does anybody use sqlite3 on Windows with Haskell?
12:27:49 <mcstar> make zip with fodlr?
12:28:22 <copumpkin> whoops, I accidentally wrote liftA2 with foldr
12:28:43 <dmwit> Yeah, liftA2 is a bit easier, I think.
12:31:16 <dmwit> You can probably get there just by substitution definitions and foldr/foldr fusion...
12:31:34 <dmwit> foldr/map, I mean
12:31:37 <tertl6> why doesnt this work? http://hpaste.org/71106
12:31:50 <copumpkin> yeah, except I was trying to write zipWith :)
12:32:04 <dmwit> tertl6: Lines 5 and 6 are transposed, and line 11 has a malformed context.
12:32:20 <copumpkin> I think I just recurse a little too much in this definition
12:32:33 <plat0> It seems like "toList :: Foldable t => t a -> [a]" determines foldMap, and hence a Foldable is just something that can be flattened to a list.  Am I right?
12:32:42 <dmwit> tertl6: You probably meant bmiTell :: (Num a) => a -> String
12:33:20 <tertl6> they are Floats
12:33:46 <dmwit> plat0: Roughly. Foldable things may provide more efficient versions of the folds than what you'd get by flattening and folding a list, though.
12:33:50 <balor> What does "import Foo (Bar#)" mean?  Where '#' is not a typo.
12:34:02 <Tomsik> magic hash
12:34:16 <dmwit> balor: It means you're using GHC, have the MagicHash extension turned on, and module Foo exports a name Bar#
12:34:20 <hpaste> applicative annotated ‚Äúhi‚Äù with ‚Äúhi (annotation)‚Äù at http://hpaste.org/71106#a71107
12:34:38 <balor> Tomsik, dmwit; thnks both
12:34:44 <eviltwin_b> # usually tags internal implementation stuff
12:34:47 <tertl6> help me dmwit
12:34:56 <dmwit> tertl6: Fix the other thing I suggested.
12:35:11 <tertl6> I tried
12:35:15 <dmwit> tertl6: Then you'll be on to the type errors instead of the syntax errors.
12:35:33 <dmwit> Oh, you fixed the type errors. That's nice.
12:35:35 <eviltwin_b> you tried?  to swap two lines?
12:35:58 <tertl6> i sawpped em
12:36:02 <tertl6> and added Num a
12:36:06 <dmwit> Oh, no, applicative fixed the type errors.
12:36:40 <dmwit> tertl6: Use line 9 from applicative's correction.
12:36:43 <dmwit> :t 18.5
12:36:44 <lambdabot> forall t. (Fractional t) => t
12:36:55 <dmwit> tertl6: Also, apparently, instead of Num, you have to use Fractional. My bad.
12:36:56 * applicative couldn't help it, it was a type error
12:37:11 <dmwit> :t readLn
12:37:12 <lambdabot> forall a. (Read a) => IO a
12:37:46 <applicative> tertl6: or do  bmi <- fmap read getLine  -- so that it gives you the number not the string
12:37:57 <b0fh_ua> Can somebody please help me with the error: http://hpaste.org/71109
12:38:01 <applicative> oh or like dmwit says use readLn
12:38:05 <b0fh_ua> sqlite was installed properly
12:38:23 <b0fh_ua> but when linking with application it gives this weird link error
12:38:39 <tertl6> thanks you guys
12:39:54 <tertl6> i feel retarded
12:41:13 <applicative> tertl6: dont worry you are moving quickly...
12:41:22 <tertl6> sometimes even newbs need to compile things :)
12:41:49 <tertl6> ok thank you
12:42:25 <tertl6> now to learn that category theory :\
12:42:36 <Tomsik> Pierce
12:42:37 <tertl6> univ of reddit has a class now
12:42:47 <b0fh_ua> how to override installation folder of libraries under windows for cabal? I don't want it to store libs under c:\documents and settings\application data\etc
12:43:15 <Tomsik> http://www.amazon.com/Category-Computer-Scientists-Foundations-Computing/dp/0262660717 IIRC
12:43:48 <mcstar> > let zip' l1 l2 = foldr (\f e -> f e) (foldr (\e s -> (\n -> (e,n)):s) [] l1) l2 in zip [1..10] [100..110]
12:43:49 <lambdabot>   [(1,100),(2,101),(3,102),(4,103),(5,104),(6,105),(7,106),(8,107),(9,108),(1...
12:43:54 <mcstar> dmwit: ^^
12:44:02 <mcstar> were you talking about this?
12:44:04 <dmwit> b0fh_ua: Change ~/.cabal/config
12:44:31 <mcstar> btw, i made a mistake, called zip instead of zip'
12:44:36 <mcstar> > let zip' l1 l2 = foldr (\f e -> f e) (foldr (\e s -> (\n -> (e,n)):s) [] l1) l2 in zip' [1..10] [100..110]
12:44:38 <lambdabot>   No instances for (GHC.Num.Num [t -> (t1, t)],
12:44:38 <lambdabot>                    GHC.Enum.E...
12:44:51 <dmwit> mcstar: Looks like not. ^_^
12:45:09 <mcstar> dmwit: yeah, but is this the problem?
12:45:29 <dmwit> Um. I guess?
12:45:38 <dmwit> The problem is to write zip using foldr.
12:46:05 <mcstar> ok
12:47:02 <dmwit> ski: (or copumpkin:) Alright, I'd like another hint, if you've got one ready.
12:47:14 * dmwit is weak
12:48:51 <dmwit> I feel like this is the kind of thing I ought to be able to just bang out.
12:49:46 * monochrom thinks he has a spoiler for "write zip by foldr" at http://www.vex.net/~trebla/haskell/natprim.xhtml : "write equality by nat's foldr"
12:51:01 <b0fh_ua> dmwit: I did  - but it still installs libraries to c:\documents and settings\...
12:51:32 <dmwit> ?hpaste your config maybe
12:51:32 <lambdabot> Haskell pastebin: http://hpaste.org/
12:51:37 <ski> <ski> (kallisti : there's a reason i mentioned this in response to the talk about coroutines here)
12:51:40 <ski> dmwit ^
12:52:23 <ski> i'm not sure that helps much more, but it is what i was going to repeat before, before you said "that's quite a hint"
12:52:35 <mkramer> My brain is still exploding from fix, but I understand it far better now.  if x = f(x), then by substitution, x = f(f(x)), etc, etc, turtles all the way
12:52:36 * dmwit nods appreciatively
12:52:50 <eikke> is it a good idea to use type-level naturals when dealing with rather 'big' naturals (big = N * 1000)
12:53:48 <mkramer> and I understand that rewriting our function with "what to do next" lifted out into an explicit parameter is what allows us to apply combinators to that explicit parameter, including the one I'm interested now, a memoization combinator
12:54:40 <monochrom> mkramer, IMO my http://www.vex.net/~trebla/haskell/fix.xhtml is a much more direct, unmagical, disillusioning explanation
12:55:27 <monochrom> although, yes, "open recursion" is more interesting and powerful
12:57:54 <b0fh_ua> is it possible to see the complete linked output when cabal is doing linkage?
12:58:22 <monochrom> I think -v3 does that. may be -v or -v2 too
12:58:29 <monochrom> -v3 may be way too much
12:59:22 <ski> monochrom : except that you don't have exactly one call to `prim' for each natural number argument to `equal' :)
12:59:45 <copumpkin> tie moar knots
12:59:46 <monochrom> I have 3 prim's
13:00:16 <ski> dmwit : you can think it over as long as you like. if you get some idea, you can mention it. or if you more or less give up, i can show the solution
13:00:22 <b0fh_ua> weird
13:00:25 <monochrom> prim also proves to be a bit more powerful that foldr
13:00:48 <ski> dmwit : thinking about it for some while is probably more fun and interesting than having to ask for a solution, though. it's up to you :)
13:00:59 <mkramer> ski: I believe I'm caught up to where you were trying to take me earlier, wrt to "memoFix" substituted for "fix"
13:01:21 <mkramer> and the definition of memoFix given in the article follows straightforwardly from the definition of fix which I just finally grokked
13:01:45 <ski> dmwit : however, i would probably say that the (or a) solution isn't *very* obvious -- at least not if you haven't seen this kind thing before (and this is more or less the point of the exercise : to learn an interesting new possibility)
13:01:57 <mkramer> now I need to define a memoize combinator for a function f :: Int -> [Row] -> Row -> PTree
13:02:01 <dmwit> ski: I cheated. I looked at monochrom's link, and now trying to generalize it without referring back to it.
13:02:06 <mkramer> which nothing off the shelf will give me
13:02:42 <dmwit> But I think his link feels a lot more natural after beating my head against the wall for a while than it would have if I'd looked at it straight away, so the exercise is appreciated nonetheless. =)
13:02:53 <dmwit> Plus it's a really cool exercise.
13:03:17 <mkramer> one more general problem related to memoization: I don't want the program hanging on to a big memo tree after I call my recursively memoizing function.  I just want the memo table to be built up during that call and then released afterwards
13:04:00 <yitz> eikke: it might depend on how you define your type-level naturals
13:04:23 <yitz> eikke: if you use a binary representation, for example, that should be just fine.
13:04:25 <monochrom> my http://www.vex.net/~trebla/haskell/scanl.xhtml follows the same style "just mechanically rewrite" and explains a lot of cool uses of scanl :)
13:04:48 <ski> dmwit : i would not say monochrom's link is a solution to what i'm after. it fails the "one `foldr' per input list" requirement
13:04:57 <eikke> yitz: good idea
13:05:24 <ski> (but i'm not claiming monochrom's link is bad in any way, it could possibly help your thinking. just saying that it's not what i'm after in this exercise)
13:05:42 <eikke> yitz: actually, a decimal one might work as well :-D
13:05:58 <monochrom> yeah I used 3 prim's, not 2, and prim is more powerful than foldr. but the main idea "just rewriting for the pattern" is powerful
13:06:14 <yitz> eikke: also, with ghc 7.4, you have data kinds, so you can treat an Int as a type
13:06:22 <yitz> (and above)
13:06:38 <monochrom> you're looking at: suppose f [] = c, f (x:xs) = o x (f xs); then f = foldr o c
13:06:43 <yitz> eikke: yeah decimal would be fine
13:07:03 <eikke> I'll play around a bit
13:07:13 <monochrom> although, I haven't succeeded in treating zip either
13:07:32 <yitz> eikke: truth is, if it's only up do a few thousand, could be regular peano integers could work too. i don't know.
13:07:38 <yitz> *to
13:07:45 <monochrom> but my scanl article is so cool!
13:08:08 <ski> monochrom : yeah, the extra power of `prim' over `foldNat' doesn't really matter here
13:08:24 <ski> monochrom : will take a look at it, then
13:08:39 <eikke> yitz: sure. yet those are hard to define ;)
13:10:02 <yitz> > cycle "Succ ("
13:10:04 <lambdabot>   "Succ (Succ (Succ (Succ (Succ (Succ (Succ (Succ (Succ (Succ (Succ (Succ (Su...
13:10:25 <eikke> yitz: using TH, sure
13:10:30 <secki> hi all, I wonder if the following is possible: I have an expression like a + 2 where a is free, I can bind that with let a = ... in a + 2.
13:11:03 <secki> Now I want to template that, i.e., I want to have something like $(template) a + 2
13:11:18 <secki> returning: let a = 2 in a + 2
13:11:42 <secki> so the variable is properly bound after the template inserts its "magic"
13:20:34 <aristid> > fix (\s -> "Succ (" ++ s ++ ")")
13:20:37 <lambdabot>   "Succ (Succ (Succ (Succ (Succ (Succ (Succ (Succ (Succ (Succ (Succ (Succ (Su...
13:20:41 <yitz> secki: not sure what you are trying to do. are you talking about template haskell?
13:21:00 <aristid> yitz: your version made me uncomfortable, due to not closing the parens after the infinite :D
13:21:09 <secki> um, yeah, I tried to solve it with that
13:21:16 <secki> let me rephrase what I want
13:21:25 <secki> I have an expression like a + 2
13:21:36 <secki> where a is not bound
13:21:43 <yitz> aristid: yes agreed. but it will take a very long time before you get those closing brackets. :)
13:22:09 <secki> then I want to programatically let the binding of some named free variables happen
13:22:18 <secki> so that a is bound to a value, like 2
13:22:22 <aristid> yitz: patience pays ;)
13:22:26 <yitz> haha
13:23:13 <secki> a step back, I have a map/record with many fields - and I want without implementing my own mini langugage to be as concise as possible
13:23:28 <yitz> > (cycle "Succ (", repeat ')')
13:23:30 <lambdabot>   ("Succ (Succ (Succ (Succ (Succ (Succ (Succ (Succ (Succ (Succ (Succ (Succ (S...
13:23:51 <aristid> yitz: ok, there it is much easier to get to the closing parens
13:24:08 <yitz> as many as you'd like
13:24:42 <secki> so instead of writing something like (getMe alt mapWithA) I want to write alt and have that bound to let a = getMe alt mapWithA in a
13:25:12 <secki> so, I am trying to have specific syntatic sugar and not reinvent the wheel
13:25:50 <dmwit> monochrom: Hm, I can't seem to adapt that trick to zip.
13:26:24 * dmwit turns to dinner
13:26:27 * hackagebot shelly 0.13 - shell-like (systems) programming in Haskell (GregWeber)
13:26:29 * hackagebot shelly 0.13.0.1 - shell-like (systems) programming in Haskell (GregWeber)
13:32:13 <yitz> secki: so it sounds like you might like lenses.
13:33:42 <secki> ok, anymore pointers to an introduction?
13:33:51 <secki> or just google haskell lenses?
13:35:01 <hiptobecubic> secki, lenses are pretty fashionable right now. You can certainly find some good explanations
13:35:27 <hpc> a lense is just a pair of getter and setter, plus functions to pass one or the other to the structures it applies to
13:35:40 <yitz> here's a good introduction. it's just slides, unfortunately, i don't think the talk is available. but a lot of it is quite understandable from the slides: http://twanvl.nl/blog/news/2011-05-19-lenses-talk
13:36:48 <antihero> I can't import CReal
13:36:57 <antihero> I tried import Data.Number.CReal?
13:36:57 <yitz> secki: there are a number of different packages with slightly different approaches on lenses. i think the most popular are data-lens and fclabels
13:37:51 <secki> thanks, I will look at the slides and then packages
13:38:14 <antihero> ghci says it's not a module
13:38:21 <yitz> secki: here are some more links:
13:38:25 <yitz> @where lenses
13:38:26 <lambdabot> <http://twanvl.nl/blog/haskell/overloading-functional-references>,<http://cdsmith.wordpress.com/2011/04/26/composing-state-with-functions-and-lenses/>,<http://patternsinfp.wordpress.com/2011/01/31/
13:38:26 <lambdabot> lenses-are-the-coalgebras-for-the-costate-comonad/>,<http://stackoverflow.com/questions/5767129/lenses-fclabels-data-accessor-which-library-for-structure-access-and-mutation>
13:38:44 <yitz> google haskell lenses gives even more
13:39:05 <secki> thanks
13:39:34 <adimit> lenses seem to be like the new cool thing it haskell land. everybody seems to be talking about them.
13:39:36 <yitz> secki: that ought to keep you busy for a while. unless you quickly discover that lenses wasn't what you meant. in which case, we'll see you back here soon.
13:40:33 <yitz> adimit: twanvl_ edwardk and roconnor have been doing a lot of great work on them lately.
13:41:19 <yitz> adimit: it's always been understood that they are something important, if we could only settle on the right abstraction and syntax.
13:41:25 <antihero> Ah I had to cabal install numbers
13:44:41 <ski> > fix (In . Just)
13:44:43 <lambdabot>   In (Just (In (Just (In (Just (In (Just (In (Just (In (Just (In (Just (In (J...
13:45:45 <tertl6> what does haskell compile to on windows?
13:46:13 <mauke> ¬Ø\(¬∞_o)/¬Ø
13:46:56 <tertl6> ha
13:47:02 <tertl6> what about on nix?
13:47:53 <mauke> "I am not able rightly to apprehend the kind of confusion of ideas that could provoke such a question."
13:49:02 <eviltwin_b> it produces native object files on both platformas
13:50:52 <adimit> yitz: yeah, I'm sure they're great. I haven't bene able to peer into them yet since i've been busy; it's just i've been hearing the name 'lens' for the past weeks all the time :-)
13:53:27 <roconnor> @check \x y -> (fromIntegral x <= y) = (x <= floor y)
13:53:27 <lambdabot>   Parse error at "=" (column 31)
13:53:31 <roconnor> @check \x y -> (fromIntegral x <= y) == (x <= floor y)
13:53:33 <lambdabot>   "OK, passed 500 tests."
13:55:23 <roconnor> @check \x -> (fromIntegral x <= (y :: Rational)) == ((x :: Integer) <= floor y)
13:55:25 <lambdabot>   Couldn't match expected type `GHC.Real.Rational'
13:55:27 <merijn> adimit: Lenses *are* pretty neat
13:55:31 <roconnor> @check \x -> (fromIntegral x <= (y :: Ratio Integer)) == ((x :: Integer) <= floor y)
13:55:33 <lambdabot>   Couldn't match expected type `GHC.Real.Ratio
13:55:51 <adimit> merijn: they're on my todo list for when I have more time :-)
13:55:55 <merijn> tertl6: It just compiles to binary on each platform
13:56:09 <tertl6> merijn ah ok
13:56:12 <dmwit> monochrom: Aha. prim has access to both the smaller number and the result of the recursive call on the smaller number; foldr doesn't have this property
13:56:15 <merijn> adimit: Even witht the complete lack of documentation data-lens is still pretty easy to figure out from the types
13:56:20 <monochrom> right
13:56:27 <dmwit> monochrom: (It doesn't have access to both the tail of the list and the result of the recursive call on the tail of the list.)
13:56:57 <dmwit> Just getting that into English has made me feel a bit better about not being able to make this work. =P
13:58:00 <yitz> @check \x y z -> (fromIntegral x + z <= y) == (x <= floor (y - z))
13:58:02 <lambdabot>   "OK, passed 500 tests."
13:59:09 <monochrom> in fact, (fromIntegral x == y) == (x <= floor y) is the defining property of floor. and you can see the adjunction.
13:59:37 <monochrom> err, typo. (fromIntegral x <= y) == (x <= floor y)
14:00:29 <yitz> @check \x y -> (fromIntegral x <= (y :: Rational)) == ((x :: Integer) <= floor y)
14:00:32 <lambdabot>   "OK, passed 500 tests."
14:00:46 <daniel_-> meh i feel hesitant about >>=, just tried to only use them in my 76 line code and got it down to 33 lines >_> but it feels like they would make it harder to maintain things and implement changes
14:01:25 <merijn> daniel_-: Just use whatever feels more readable
14:01:39 <yitz> daniel_-: sometimes >>= is clearer, sometimes do notation is clearer. and sometimes it's a matter of style.
14:01:44 <monochrom> you also grew from 20 columns to 40 columns
14:02:04 <daniel_-> yeeeee
14:03:20 <dmwit> phew
14:04:40 <yitz> @check \x y z -> z == 0 || (fromIntegral x * abs z <= y) == (x <= floor (y / abs z))
14:04:42 <lambdabot>   "OK, passed 500 tests."
14:05:45 <ptrf> daniel_-: you might consider reading http://www.haskell.org/haskellwiki/Do_notation_considered_harmful
14:06:40 <bitonic> ptrf: I haven't read that, but I know it's going to be stupid
14:06:48 <ptrf> well
14:07:10 <ptrf> actually, I think it gave some food for thought
14:07:17 <bitonic> do is very convenient. any feature can be misused.
14:07:27 <ptrf> right
14:07:39 <ptrf> that is exactly what the article points out
14:07:51 <monochrom> before the do-notation, people wrote like this for real:
14:07:59 <monochrom> getLine >>= \line ->
14:08:01 <bitonic> so it's not harmful in the same sense that goto is.
14:08:16 <bitonic> which is what "considered harmful" refers to
14:08:23 <monochrom> putStrLn ("you have entered: " ++ line) >>= \_ ->
14:08:24 <dmwit> ?let enhancedfoldr f z = snd . foldr (\a (as, b) -> (a:as, f a as b)) ([], z)
14:08:26 <lambdabot>  Defined.
14:08:27 <monochrom> more stuff...
14:08:36 <ptrf> no, obviously there's a word play in the title
14:08:36 <bitonic> monochrom: why no >>?
14:08:48 <bitonic> ptrf: what word play?
14:09:05 <dmwit> > let zip' = enhancedfoldr (\x xs recurse -> enhancedfoldr (\y ys _ -> (x,y):recurse ys) []) (const []) in zip' [1..5] [10..]
14:09:05 <yitz> bitonic: goto is especially harmful in haskell, because haskell has no labels.
14:09:07 <lambdabot>   *Exception: stack overflow
14:09:13 <ptrf> refering to dijkstra's original article on goto considered harmful
14:09:13 <monochrom> and there was no "action >>= \x ->newline considered harmful"
14:09:21 <bitonic> ptrf: that's no wordplay, but ok :P
14:09:34 <dmwit> ?undefine
14:09:36 <ptrf> scratch word then
14:09:41 <dmwit> ?let enhancedfoldr f z = snd . foldr (\a ~(as, b) -> (a:as, f a as b)) ([], z)
14:09:43 <lambdabot>  Defined.
14:09:44 <bitonic> yitz: luckily more modern languages such as C# have labels & gotos
14:09:46 <dmwit> > let zip' = enhancedfoldr (\x xs recurse -> enhancedfoldr (\y ys _ -> (x,y):recurse ys) []) (const []) in zip' [1..5] [10..]
14:09:48 <lambdabot>   [(1,10),(2,11),(3,12),(4,13),(5,14)]
14:09:53 <dmwit> ski: How'd I do?
14:09:58 <merijn> bitonic: goto is only considered harmful by people who don't know what they're doing :p
14:10:11 <monochrom> anyway, when there was no do-notation, people mimicked do-notation, and there was no "harmful" article against it
14:10:15 <bitonic> ptrf: yeah and I think it's stupid, because goto and do notation are on different levels
14:10:19 <hpc> merijn: like dijkstra?
14:10:42 <ptrf> bitonic: aside from the title of the wiki page, i dont think there's any reason to dismiss it
14:10:59 <monochrom> "___ considered harmful" is just a meme
14:11:08 <bitonic> ptrf: the title implies that you should not use `do' unless in some rare cases, which is absolutely wrong
14:11:10 <merijn> hpc: His point was that people should use apropriate language constructs, and sometimes there's just no language construct more appropriate than goto's
14:11:21 <bitonic> ptrf: pointed monadic code is often much more readable
14:11:22 <hpc> merijn: i know, just being an ass :D
14:11:49 * merijn is the proud introducer of at least 4 goto's in his current codebase
14:11:53 <bitonic> ptrf: so I was just criticising that. I haven't read the article
14:12:32 <monochrom> at least my supervisor was a bit more creative in following the meme. "do considered od". here, "do" refers to Dijkstra's loop construct
14:13:03 <ptrf> bitonic: ok, i will admit to the title being misleading, but again, it's a play (no, not a word play, just a play) on the original article. it gave me some insight some weeks ago, while reading the typeclassopedia, and regarding the contents, I dont think you should just outright dismiss it, even though you're right in your criticism
14:13:33 <bitonic> ptrf: I don't like misleading things :P. I'd much rather have an article that explains do notation well.
14:13:36 <ptrf> article title of dijsktra... ugh, dont drink beer and irc :)
14:13:40 <bitonic> there's no need for that kind of thing
14:14:05 <monochrom> you should know both do-notation and >>=. there is no question about it. but it doesn't warrant saying "harmful"
14:14:48 <ptrf> great, it seems we agree
14:14:51 <ptrf> :)
14:15:23 <monochrom> also, "you should know both do-notation and >>=" is 1000x more efficient than writing or reading that article
14:15:38 <dmwit> That's not fair.
14:15:48 <dmwit> Presumably the article also has some sentences saying why.
14:16:12 <monochrom> it is self-evident why. there is no need to explain further
14:16:39 <bitonic> as I said the most useful article would be something that explains what do notation does. and there are plenty of those.
14:18:33 <dmwit> Hm.
14:18:34 <ski> yitz : well, tail-calls to and through around (possibly mutually-recursive) functions can be considered similar to COBOL sections
14:18:59 <dmwit> Now that I've opened the page, I see why people are complaining a bit more clearly.
14:19:08 <bitonic> if you write `bar = do foo' or `baz = x <- foo; return x', you are simply ignorant about monads. it has nothing to do with do notation.
14:19:21 <bitonic> the second statement is missing a do
14:19:26 <ski> dmwit : it's quite clever, but i'm sad to say it's not near what i had in mind. (i'm sorry that it's hard to articulate what i'm after (without showing a solution))
14:19:50 <dmwit> =/
14:20:00 <ski> dmwit : one symptom of it not being what i'm after is you using `:' for anything else than consing the `(x,y)' pair to the result
14:20:17 <hpc> i write single-statement do-notation when i want to nest something, or if i know i want to expand it later
14:20:26 <hpc> forM [0..100] $ do
14:20:28 <hpc>   blah
14:20:46 <hpc> (pretend that typechecked)
14:20:57 <ski> dmwit : you should not feel so sad for "not getting it" -- (unfortunately) i've been a bit unclear (i'm not sure how to be more clear) -- and i think the idea really isn't so obvious
14:21:19 <ski> dmwit : however, the "coroutine idea" is the way i originally came up with it
14:21:47 <ski> dmwit : and the fact that use use `_' inside the inner `enhancedFoldr' call is a sure sign that you're *not* doing anything like coroutines here
14:22:10 <ski> (the `const' in the base case is ok, since if one list is empty, we want to ignore the rest of the other one)
14:22:30 * ski pretends `blah' is a function
14:22:32 <dmwit> ski: I've got to run, but another time I'd be interested in hearing an explanation of your idea. =) (Or just say it now and I'll read the scrollback later.)
14:22:42 <hpc> ski: :P
14:22:57 <ski> dmwit : well, i can point you to two links, if you want some code to stare at :)
14:23:01 <dmwit> perfect
14:23:13 <ski> (which is basically the solution (or solutions))
14:24:19 <ski> dmwit : <http://hpaste.org/47814>,<http://okmij.org/ftp/Algorithms.html#zip-folds> (note that i only found the later *after* figuring out the former)
14:24:20 <tertl6> merijn
14:24:29 <tertl6> merijn hi
14:24:38 <dmwit> ski: Thanks, I'll take a look tomorrow.
14:24:46 <dmwit> In any case thanks for the fun exercise.
14:24:48 <ski> yw :)
14:28:00 <monochrom> I got to zipWith2
14:29:35 <danr> ski what about this:
14:29:40 <danr> > foldr (\x mk acc -> case acc of { (y:ys) -> (x,y):mk ys ; [] -> [] } ) (\ _ -> []) "hello" [1..]
14:29:41 <lambdabot>   [('h',1),('e',2),('l',3),('l',4),('o',5)]
14:29:48 <danr> did you have something like that in your mind?
14:31:06 <ski> danr : fails the "may not pattern-match apart from using `foldr'" part
14:31:12 <Saizan> > foldr (\x mk acc -> case acc of { (y:ys) -> (x,y):mk ys ; [] -> [] } ) (\ _ -> []) "hello" [1..]
14:31:13 <lambdabot>   [('h',1),('e',2),('l',3),('l',4),('o',5)]
14:31:26 <Saizan> > foldr (\x mk acc -> case acc of { (y:ys) -> (x,y):mk ys ; [] -> [] } ) (\ _ -> []) [1..] "hello"
14:31:28 <lambdabot>   [(1,'h'),(2,'e'),(3,'l'),(4,'l'),(5,'o')]
14:31:32 <ski> danr : sorry, s/pattern-match/pattern-match on the lists/
14:31:38 <danr> ski: ah I missed that point
14:31:53 <ski> danr : also, using something like `foldr (\a _ -> Just a) Nothing' to simulate a pattern-match is not ok
14:32:11 <danr> you're making up tricky rules ;)
14:33:06 <ski> (your `foldr' calls should not have `_' in the first argument which ignores the rest of the recursion inside `foldr')
14:33:21 <ski> danr : yeah, because it's hard to specify what i want, without giving the solution away
14:33:42 <ski> i want one `foldr' to traverse one list, and one `foldr' to traverse the other list
14:33:57 <ski> there should be no other traversals of the lists, and no other recursion
14:34:24 <ski> basically, this is a test of the dogma "every list-function can be written as a `foldr'"
14:34:56 <ski> (well, list-*consuming*-function)
14:34:59 <danr> (or two)
14:35:10 <ski> yes, one for each list we want to traverse
14:37:11 <ski> monochrom : the idea is that in `zipWith3', the two original calls act like coroutines, which then pass their current state forward and back between them
14:38:42 <HugoDaniel> hi
14:41:41 <n3hima> is there a bot in here which evaluates haskell one-liners?
14:41:51 <mkramer> ski: earlier you mentioned that you have some more to teach about memoization, specifically, ways to do it with another operation other than "memoize"
14:41:53 <ski> > "Yes, n3hima"
14:41:54 <lambdabot>   "Yes, n3hima"
14:42:07 <n3hima> and if so, is it FOSS?
14:42:12 <mkramer> I'm ready to hear that if you have the time :)
14:42:18 <eviltwin_b> @version
14:42:18 <lambdabot> lambdabot 4.2.2.1
14:42:18 <lambdabot> darcs get http://code.haskell.org/lambdabot
14:42:20 <ski> yeah, right
14:42:22 <n3hima> thanks
14:42:45 <ski> so, we had gotten to
14:42:46 <sm> nice: "Switching to Shake made our build system
14:42:46 <sm> ten times shorter, made builds run twice as fast, and has solved our
14:42:52 <ski>   fibWith fib 0 = 0
14:42:53 <sm> build system problems."
14:42:54 <ski>   fibWith fib 1 = 1
14:43:06 <ski>   fibWith fib n = fib (n - 2) + fib (n - 1)
14:43:09 <ski> with
14:43:18 <ski>   fib = fix fibWith
14:43:22 <ski> and
14:43:31 <ski>   memoedFib = memoFix fibWith
14:43:40 <mkramer> yep
14:44:00 <ski> the basic problem with `fib' here is that it repeatedly recomputes results for recursive calls
14:44:08 <ski>      fib 5
14:44:13 <ski>   =  fib 3 + fib 4
14:44:13 <mkramer> and we hadn't discussed an implementation of memoFix, but the one on the wiki page is straightforward, given that there is a "memoize" function
14:44:14 <Eduard_Munteanu> n3hima: it also answers private messages
14:44:23 <Eduard_Munteanu> s/it/she/ :)
14:44:31 <ski>   =  (fib 1 + fib 2) + (fib 2 + fib 3)
14:44:54 <ski>   =  (1 + (fib 0 + fib 1)) + ((fib 0 + fib 1) + (fib 1 + fib 2))
14:45:15 <ski>   =  (1 + (1 + 1)) + ((1 + 1) + (1 + (fib 0 + fib 1)))
14:45:26 <ski> er, sorry
14:45:35 <n3hima> Eduard_Munteanu: thanks ;)
14:45:36 <ski>   =  (1 + (0 + 1)) + ((0 + 1) + (1 + (fib 0 + fib 1)))
14:45:44 <ski>   =  (1 + (0 + 1)) + ((0 + 1) + (1 + (0 + 1)))
14:45:56 <ski>   =  (1 + 1) + (1 + (1 + 1))
14:46:02 <ski>   =  2 + (1 + 2)
14:46:05 <ski>   =  2 + 3
14:46:07 <ski>   =  5
14:46:33 <ski> mkramer : and you can begin to see here that `fib 2' was recomputed from scratch thrice here
14:46:47 <ski> and, as we try larger inputs, the problem will only get worse
14:46:57 <mkramer> it shouldn't be if we used memoedFib
14:47:09 <ski> (taking exponential time, instead of the expected linear time)
14:47:13 <ski> mkramer : right
14:47:30 <aepokh> there's an algorithm in SICP for computing fibonacci terms in logarithmic time
14:47:39 <ski> now, `memoFix' uses `memoize' which is a simple general way to memoize a function
14:48:00 <ski> it basically does something like pointer-comparision (iirc), to check if it's already seen an argument or not
14:48:24 <ski> but, of course two arguments can be semantically the same, even if the pointers in the implementation are different
14:48:43 <ski> so, the check that it uses, while simple and generic, is only a *conservative* check
14:49:10 <ski> in the worst case, it may recompute the result anyway, if the argument is semantically the same, but the pointer in the implementation is not the same
14:49:39 <ski> so, it can be good to know about alternate versions of `memoFix', which doesn't use `memoize'
14:49:39 <mkramer> Yeah‚Ä¶ perfect example I'm dealing with now is a function I want to memoize has the property that f a b = f b a
14:49:45 <mkramer> so if either is computed I should memoize both
14:49:54 <ski> yeah. that's another example
14:50:30 <ski> @let fibWith fib 0 = 0; fibWith fib 1 = 1; fibWith fib n = fib (n - 2) + fib (n - 1)
14:50:32 <lambdabot>  Defined.
14:51:18 <ski> now, one common way to do memoizing is to use an intermediate data-structure, to store computed results in
14:51:39 <sm> what causes "unrecognized option `--disable-benchmarks'" error during cabal install ? I'm installing eg hashed-storage in a virthualenv based on GHC 7.0.4
14:52:08 <ski> let's start with defining a helper function
14:52:34 <ski> @let tabulate :: Ix i => (i,i) -> (i -> e) -> Array i e; tabulate ix body = array ix [(i,body i) | i <- range ix]
14:52:36 <lambdabot>  Defined.
14:52:53 <ski> > tabulate (0,20) (\i -> i^2)
14:52:55 <lambdabot>   array (0,20) [(0,0),(1,1),(2,4),(3,9),(4,16),(5,25),(6,36),(7,49),(8,64),(9...
14:53:06 <ski> > tabulate (0,7) (\i -> i^2)
14:53:08 <lambdabot>   array (0,7) [(0,0),(1,1),(2,4),(3,9),(4,16),(5,25),(6,36),(7,49)]
14:53:43 <ski> this constructs an array of elements indexed by integers from `0' to `7', where the value in each cell is the square of the index of the cell
14:53:52 <ski> mkramer : following, so far ?
14:54:14 <mkramer> what's the Ix typeclass?
14:54:22 <ski> it's the typeclass of array indices
14:54:30 <mkramer> ok, I'm following
14:54:30 <ski> (you can have multi-dimensional arrays)
14:54:49 <ski> now, we can define
14:57:06 <ski> @let arrayMemoFix :: Ix i => (i,i) -> ((i -> e) -> (i -> e)) -> (i -> e); arrayMemoFix ix fooWith = foo where foo = (tabulate ix (fooWith foo) !)
14:57:07 <lambdabot>  Defined.
14:57:14 <ski> and evaluate e.g.
14:57:32 <ski> > arrayMemoFix (0,12) fibWith 12
14:57:34 <lambdabot>   144
14:58:28 <ski> this will construct an array, indexed from `0' to `12', and define each elements in terms of `fooWith', where when `fooWith' calls `foo' ("recursing"), it will actually look up a result in the array
14:58:37 <ski> note that here
14:58:49 <ski>   (!) :: Ix i => Array i e -> (i -> e)
14:59:22 <ski> so, the `tabulate' call above constructs the intermediate array, and then we immediately partially apply `!' on it, to get the indexing function from that array
14:59:36 <ski> we could have been more verbose and defined `arrayMemoFix' like
14:59:41 <ski>   arrayMemoFix :: Ix i => (i,i) -> ((i -> e) -> (i -> e)) -> (i -> e)
14:59:47 <ski>   arrayMemoFix ix fooWith = foo
14:59:50 <ski>     where
14:59:59 <ski>     foo i = arr = i
15:00:02 <ski> er
15:00:04 <ski>     foo i = arr ! i
15:00:12 <ski>     arr = tabulate ix (fooWith foo)
15:00:33 <ski> so, you can see i build a (single) array `arr' here, and then i define `foo' to index into this array
15:00:59 <ski> but i also define the array `arr' to have its elements populated by `fooWith foo'
15:01:05 <ski> you could replace the last line with
15:01:13 <ski>     arr = tabulate ix \i ->
15:01:20 <ski>       fooWith foo i
15:01:26 <ski> if you want to be more explicit
15:01:31 * hackagebot hakyll-contrib 0.1.0.1 - Extra modules for the hakyll website compiler (JasperVanDerJeugt)
15:01:37 <ski> (well, add an `$' before the `\')
15:01:50 <ski> mkramer : are you sufficently confused yet ?
15:01:57 <mkramer> yes
15:02:05 <mcstar> :S i cant write the function to make zip work
15:02:06 <mkramer> I'm pasting this out into my editor
15:02:21 <ski> i build an array, for each index i pass it to `fooWith foo' (in our case `fibWith foo')
15:02:21 <mkramer> I'm also reading up the Array typeclass
15:02:51 <ski> mkramer : you can ignore the `Array' *typeclass* here -- i'm only using the basic `Array' *type* (not the same)
15:03:35 <ski> (well, the classes are named `IArray' and `MArray', `Array' itself is a plain type)
15:13:26 <ski> mkramer : btw, you should note that with this approach, you have to know a bound for how large elements you need to compute :
15:13:56 <ski> > map (arrayMemoFix (0,12) fibWith) [0 .. 12]
15:13:59 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144]
15:14:35 <ski> is fine, will compute each result exactly once (because the intermediate results are stored in the array, and later "recursive calls" will just look up the already computed value, thanks to laziness)
15:14:42 <ski> > map (arrayMemoFix (0,12) fibWith) [0 .. 13]
15:14:44 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,*Exception: Ix{Integer}.index: Index (13)...
15:15:10 <ski> trying to compute the result for `13' doesn't work, if we don't make a large enough array
15:15:19 <ski> > map (arrayMemoFix (1,12) fibWith) [0 .. 12]
15:15:22 <lambdabot>   [*Exception: Ix{Integer}.index: Index (0) out of range ((1,12))
15:15:46 <ski> if we don't include all the cases which will (potentially) appear, then we can't compute any value
15:16:12 <ski> mkramer : btw, do you know about "dynamic programming" ?
15:16:51 <ski> > arrayMemoFix (1,12) fibWith 12
15:16:53 <lambdabot>   *Exception: Ix{Integer}.index: Index (0) out of range ((1,12))
15:17:11 <mkramer> well, if by that you mean memoizing recursive functions, then yes
15:17:38 <ski> i mean the traditional algorithms concept, which is usually taught in the context of imperative programming
15:17:53 <mkramer> recursive functions = breaking problems down to smaller subproblems, when you memoize the answer to the sub problems, you're doing dynamic programming
15:18:14 <mkramer> Sure, I suppose the answer is yes
15:19:35 <ski> well, say you're doing some kind of traditional string matching problem e.g.
15:19:46 <ski> you have a pattern string, and some long source string
15:19:59 <ski> and we want to find places in the source string where the pattern string occurs
15:20:31 <ski> except that you allow yourself to remove an element from the pattern string, or add one, or swap two neighbouring elements -- so that the matching is not exact
15:20:53 <aepokh> okay, i just started learning haskell, but
15:20:55 <ski> however, the more such fixes you need to do, the less exact is the matching, and you'd prefer to find the most exact matching
15:20:56 <aepokh> > (+2) 3
15:20:58 <lambdabot>   5
15:21:03 <aepokh> the syntax doesn't really make sense to me
15:21:18 <mcstar> omg
15:21:21 <mcstar> im soo stupid
15:21:30 <aepokh> the 2 is basically the second parameter to +, yes?
15:21:31 <mkramer> > 2 + 3
15:21:32 <lambdabot>   5
15:21:34 <ski> mkramer : anyway, i'm not going through the details now, but it is possible to express this as a dynamic programming problem
15:21:44 <aepokh> but there's no such thing as a second parameter?
15:21:50 <aepokh> it's all just curried
15:22:05 <ski> mkramer : what we do is make a two dimensional array, one side as long as the pattern, the other as long as the source string
15:22:26 <ski> mkramer : and we find a way to measure the exactness (`0' is best), and we put this into the array cells
15:22:26 <mkramer> > :t (+2)
15:22:28 <lambdabot>   <no location info>: parse error on input `:'
15:22:41 <Mortchek> aepokh, even though functions are automatically curried, you're still allowed to think of it as the second parameter.
15:22:54 <Mortchek> aepokh, (+2) 3 is the same as (+) 3 2
15:23:01 <ski> mkramer : each array cell looks at the cell above, the cell to the left, and the cell to the left above, and then decides which value it'll have itself
15:23:03 <aepokh> i get that, but
15:23:17 <aepokh> it doesn't make sense with everything being curried to me
15:23:30 <aepokh> how can 2 be applied before + is curried with 3?
15:23:44 <ski> mkramer : the traditional imperative solution is then to write a nested loop, which initializes cell after cell, row after row, in terms of previously computed cells
15:23:58 <Eduard_Munteanu> aepokh: that's just \x -> x + 2
15:24:02 <mcstar> > let zip' l1 l2 = fst $ foldl (\(out,x:xs) e-> ((e,x):out, xs)) ([], l1) l2 in zip' [1..5] [11..15]
15:24:03 <lambdabot>   [(15,5),(14,4),(13,3),(12,2),(11,1)]
15:24:08 <mcstar> dmwit: ^^
15:24:19 <ski> mkramer : however, using lazy arrays in Haskell, we can just define a single *recursively defined* array, where the contents of the cells are defined in terms of each other !
15:24:20 <copumpkin> mcstar: that doesn't really count
15:24:25 <Eduard_Munteanu> :t (+2)
15:24:27 <lambdabot> forall a. (Num a) => a -> a
15:24:31 <mcstar> copumpkin: :(, why?
15:24:39 <copumpkin> mcstar: especially since it's backwards :) but you're pattern matching, too
15:24:41 <aepokh> oh, that must be how you write a lambda in haskell
15:24:48 <copumpkin> and you're pairing things up
15:24:50 <aepokh> yeah i just started reading learnyouahaskell like, yesterday
15:24:53 <ski> mkramer : so, when you're extracting the final answer (by checking the rightmost, bottommost cell), this means that not every cell will actually have to be computed
15:25:14 <Eduard_Munteanu> aepokh: ah, yeah, I didn't know you weren't familiar with that
15:25:15 <copumpkin> mcstar: and you should be using foldr!
15:25:19 <Mortchek> aepokh, lambdabot's output there was a type expression (if I'm not mistaken)
15:25:33 <mcstar> copumpkin: can i use reverse?
15:25:41 <copumpkin> nope
15:25:42 <ski> mkramer : iow, intead of a bottom-up dynamic programming solution (which may involve needles computation in some cases), we get a top-down, demand-driven, dynamic programming solutions (and *without* assignment, even :)
15:25:42 <Mortchek> aepokh, lambdas look something like this: \a b -> foo a b
15:25:54 <mcstar> copumpkin: what about auxiliary functions?
15:25:58 <ski> mkramer : do you think you get the picture ?
15:26:04 <Mortchek> (Not a very useful lambda there, but just for the sake of example)
15:26:13 <aepokh> yeah
15:26:13 <copumpkin> mcstar: nope
15:26:38 <mkramer> Nope :)
15:26:48 <aepokh> easier to type than (lambda (a b) (foo a b))
15:27:03 <Mortchek> aepokh, you a Lisper? What dialect?
15:27:08 <mkramer> You're too far ahead of me  - I'm still working through tabulate
15:27:13 <mkramer> I'll get there though :)
15:27:20 <aepokh> a couple chapters of SICP is all i've done
15:27:22 <ski> mkramer : ok, np :)  my main point here is just that defining an array (e.g.) recursively in this way may be a nice way to compute things efficiently
15:27:32 <aepokh> still to imperative-minded to do anything useful in lisp
15:27:33 <Mortchek> Ah, I see
15:27:48 <ski> mkramer : imo, `tabulate' is a function which ought to be in the array library
15:28:36 <mcstar> copumpkin: i had an idea: process 1 of the lists with a foldr, make some kind of nested function from it, that takes an argument, and return a similar function, that takes an argument.... this function in closure would store the elements of the first list, and after that, with another foldr i coult successively apply this function to the elements of the other list
15:28:38 * ski prefers Scheme to Common Lisp ..
15:28:49 <mcstar> copumpkin: but i wasnt able to typecheck that function....
15:29:12 <copumpkin> mcstar: it's pretty hard! the idea is to make your primitive be foldr rather than pattern matching
15:29:18 <copumpkin> so if you're using pattern matching, you've lost that
15:29:32 <mcstar> copumpkin: but that also means, i cant use head
15:29:36 <ski> mkramer : .. there was one other example i wanted to make, where instead of an array, we use a list, as the data structure holding the intermediate results .. but i can wait with it
15:29:38 <copumpkin> mcstar: yep
15:30:11 <Mortchek> aepokh, section 3.2.1 might be helpful to you: http://www.haskell.org/tutorial/functions.html
15:30:53 <mkramer> ski: you're alluding to dna sequence alignment, aren't you?
15:31:05 <mkramer> trying to find the alignment with the smallest edit distance
15:31:06 <aepokh> Mortchek: thanks
15:31:33 <ski> mkramer : hm, possibly :)
15:34:03 <ski> mcstar : your "process 1 of the lists with a foldr, make some kind of nested function from it, ..." sounds like it could be a working idea
15:34:17 <BluePeppers> I have a lot of code that looks like this: `f (g x) (g y) (g z)`. is there any way to kind of compose f and g to make it more concise?
15:34:22 <ski> (the hard part is being able to express it)
15:34:39 <weexplat> got this message when trying to install git-annex: ‚Äòcabal: Couldn't read cabal file "bloomfilter/1.2.6.10/bloomfilter.cabal"‚Äô
15:34:42 <mcstar> ski: ive been trying that for ~ an hour
15:34:50 <mcstar> now ill go outside
15:34:51 <ski> BluePeppers : hm, maybe use a list ?
15:35:23 <BluePeppers> ski, not worth it, just trying to simply some ffi stuff :)
15:35:50 <ski> hm
15:36:04 <BMeph> BluePeppers: Why not write it out explicitly? :)
15:36:11 <copumpkin> ski: you wouldn't need the auxiliary types if you allowed infinite types, right?
15:36:34 <copumpkin> or had an untyped calculus
15:36:56 <BMeph> BluePeppers: I.e., "bpFunc f g x y z = f (g x) (g y) (g z)"
15:36:58 <ski>   (f <$> ($ x) <*> ($ y) <*> ($ z)) g  - maybe
15:37:22 <ski> copumpkin : yes
15:37:23 <BluePeppers> BMeph, considering that.
15:38:12 <ski> copumpkin : note that the recursion is positive, though not strictly positive
15:38:17 <copumpkin> yeah
15:38:40 <ski> part of the point is getting people thinking about the possibility of using these kind of things
15:40:50 <rwbarton> looks like a sort of "on3"
15:44:44 <Peaker> wow, the little "pointed" package depends on a LOT of stuff
15:45:28 <Peaker> comonad-1.1.1.6, contravariant-0.2.0.2, distributive-0.2.2, semigroupoids-1.3.4, comonad-transformers-2.1.2, stm-2.3 ===> pointed-2.1.0.2
15:46:02 <Peaker> I wonder how, I wonder why
15:47:22 <merijn> Peaker: As I told you over lambdabot message I got Bottle working under OSX (well compiling succesfully), but the GUI looks messed up
15:47:34 <Peaker> merijn, what kind of messed up?
15:47:44 <merijn> Lemme see if I can make a screenshot
15:47:59 <merijn> (2 years and I still don't remember on OSX >.>)
15:48:40 <Peaker> merijn, my codeveloper uses OS X
15:51:32 <merijn> Peaker: Well, I'm assuming this is not the intended look: http://fau5tln.home.xs4all.nl/screenshot.png
15:51:51 <Peaker> merijn, no, that's messed up :)
15:52:09 <Peaker> merijn, very weird
15:52:25 <merijn> I can try upgrading all the dependencies I guess, although most of them were installed in the last week or so
15:53:50 <eviltwin_b> I feel like I've seen that recently.  gtk+ using quartz?
15:54:07 <Peaker> merijn, can you try running the graphics-drawingcombinators example?
15:54:20 <Peaker> eviltwin_b, it's opengl+ftgl
15:54:22 * eviltwin_b punted back to gtk+ x11 after recent updates to gtk+ quartz started doing something rather like that
15:54:27 <eviltwin_b> ah
15:54:59 <Peaker> might be a font size computation issue or such?
15:55:21 <Peaker> but the text items do seem to be located correctly relative to each other, so it may rule that out
15:55:29 <Peaker> maybe the window size is reported incorrectly as 0 or such
15:55:35 <Peaker> merijn, try resizing the window?
15:55:45 <Peaker> merijn, does it move stuff around?
15:56:05 <merijn> In full screen it looks the same, arrows seem to move things around
15:56:21 <merijn> Where can I find the example of graphics-drawingcombinators?
15:56:31 <Peaker> cabal unpack graphics-drawingcombinators
15:56:49 <Peaker> cd graphics-draw* && ghc example && ./example <name of ttf file>
15:56:57 <Peaker> (may need a name of png file too, depending on version)
15:59:02 <Peaker> merijn, if you resize gradually, what happens?
16:03:10 <merijn> It stays the same, the example from graphics-drawingcombinators results in an error "example: user error (IO error: does not exist)", but I might have an old version? Lemme check and upgrade that
16:03:33 <Peaker> merijn, did you give a valid filename?
16:03:49 <merijn> ls claims it's valid
16:04:22 <Peaker> Haskell lacks stack traces :( It would be useful to get one for such an IO Error
16:04:36 <merijn> Yeah, even when I copy it to the local folder it errors out
16:05:13 <Peaker> merijn, hmm.. can you strace it to see what open is failing?
16:06:34 <Peaker> merijn, it does seem like the size of the window is computed to be much smaller than it is...
16:07:07 <merijn> There's no strace for OSX (at least not by default), so I have to check for some quick way of doing that. My dtrace skills aren't up to par yet
16:07:21 <eviltwin_b> merijn: dtruss
16:07:50 <antihero> is haskell's list evaluation essentially quite similar to python's generators?
16:07:52 <eviltwin_b> ...may have to use sudo because of annoying permissions stuff
16:08:30 <merijn> antihero: kinda, maybe, for some restricted values of that statement
16:11:48 <merijn> Peaker: Seems to crash on the .png argument not existing
16:12:06 <Peaker> merijn, doesn't it say that with a format message?
16:12:23 <merijn> touch'ing the png argument results in:example: user error (Image not of any known type, or corrupt)
16:12:38 <Peaker> merijn, oh, so you did give non-existing files as args?
16:12:52 <merijn> I gave an existing font, not png
16:13:10 <merijn> Ah
16:13:15 <Peaker> didn't it print out: "Usage: drawingcombinators-example some_font.ttf some_image.[png|jpg|...]"
16:13:49 <merijn> Yeah, but it wasn't clear what kind of png to pass :p
16:14:07 <merijn> With an image I get four circles and hello world's spinning around
16:14:46 <merijn> It doesn't seem to resize, though
16:14:52 <Peaker> yeah it doesn't handle resize
16:14:58 <merijn> Not sure whether it's supposed to
16:16:24 <merijn> In any case, the example seems to work
16:16:49 <hpaste> Peaker pasted ‚ÄúCan you run this GLFW test?‚Äù at http://hpaste.org/71110
16:17:33 <Peaker> merijn, can you run that?
16:17:59 <merijn> (640,480)
16:19:13 <merijn> Seems to be right for the screenshot I made
16:25:52 <stepkut> donri: tekmo is working on some sort of parser for pipes, so I am going to see what that looks like first
16:27:33 <Peaker> merijn, hmm.. all the basic things seem covered, weird
16:28:03 <kallisti> so if I understand lens-family correctly:  you can take a GetterFamily and SetterFamily and the composition is a read-write lens?
16:29:26 <mcstar> ski: hm, the type of my proposed function looks a lot like a list
16:29:48 <mcstar> ski: also, i think it could be useful for the solution, if the cons operator's parameters were reversed
16:30:01 <mcstar> flipped, in haskell parlance
16:30:43 <Peaker> merijn, Any chance of more elaborate debugging, adding trace calls in EventMapDoc.hs (which draws the brown background help thing)?
16:33:12 <weexplat> kallisti: it's more like a lens is a GetterFamily that is also a SetterFamily
16:33:33 <merijn> Peaker: Sure, but not right now. I'm starting to head to bed and I'll be on vacation for the next week. I can PM you my email address and if you tell me which info you'd need/want traced I'll look into it when I get back
16:33:47 <kallisti> weexplat: er... is that also similar to what I just said? :P
16:33:54 <weexplat> well, a LensFamily is
16:34:22 <weexplat> kallisti: you can't take a separate GetterFamily and SetterFamily and put them together to get a lens
16:34:27 <Peaker> merijn, ok, thanks
16:34:44 <merijn> And with that, good night to all of you :)
16:35:37 <kallisti> I'm not seeing a way to produce LensFamilies aside from the functions in .Unchecked
16:36:01 <weexplat> GetterFamily and SetterFamily, in other words, are not parts of a lens, they are different ways of being Almost A Lens
16:36:34 <xplat> @hackage lens-family-core
16:36:35 <lambdabot> http://hackage.haskell.org/package/lens-family-core
16:37:03 <shachaf> Careful, I hear that code is untested!
16:38:12 <kallisti> oh I see, so you're actually intended to use .Unchecked
16:39:02 <xplat> yes, it's intended so that when you build lenses from scratch you remember to check the lens laws yourself
16:39:34 <xplat> (at least that's what i assume the reason is)
16:40:30 <kallisti> xplat: is anyone already working on a TH lib for lens-family
16:40:32 <kallisti> because I might do that.
16:40:59 <kallisti> ...don't know why I'm asking you.
16:41:09 <xplat> @hackage lens-family-th
16:41:10 <lambdabot> http://hackage.haskell.org/package/lens-family-th
16:41:42 <alexi_> in emacs haskell IDE is defaulting to using hugs... how can I change to ghci?
16:41:46 <kallisti> xplat: ah, no.
16:41:52 <kallisti> I was thinking quasiquotes.
16:42:08 <kallisti> no ugly underscores. just parse a slightly modified record syntax.
16:43:29 <xplat> i could be wrong, but i don't think anybody else is working on that
16:43:57 <xplat> you might call it lens-family-qq or something
16:44:21 <kallisti> well it could just go in -th
16:44:27 <kallisti> but yes.
16:50:56 <Kiryx> Hi
16:51:14 <m3ga> Kiryx: hi
16:52:25 <ski> Kiryx : if you have any Haskell-related question, just ask :)
16:52:48 <ski> mcstar : mhm ..
16:53:03 <ski> mcstar : .. mayhaps you'd want to elaborate ?
16:53:19 <Kiryx> I got thought I'd learn some purely functional language, I'm currently giving haskell a try :)
16:53:31 <ski> you're welcome :)
16:53:32 <Kiryx> s/got/just/
16:53:45 <ski> have you found any book or tutorial to start looking at, yet ?
16:53:57 <Kiryx> I'm doing the website tutorial
16:54:04 <ski> @where LYAH
16:54:05 <lambdabot> http://www.learnyouahaskell.com/
16:54:06 <ski> that one ?
16:54:13 <ski> @where TryHaskell
16:54:13 <lambdabot> http://tryhaskell.org/
16:54:17 <ski> or maybe that one ?
16:54:21 <Kiryx> tryhaskell.org
16:54:22 <Kiryx> yes
16:54:24 <ski> ok
16:54:30 <ski> that's fine to start with
16:54:32 <Kiryx> pretty nice tool I must say :)
16:54:52 <ski> if you want to continue after it, LYAH above seems to be popular
16:54:55 <ski> there's also
16:54:56 <ski> @RWH
16:54:57 <lambdabot> Unknown command, try @list
16:54:58 <ski> er
16:55:00 <ski> @where RWH
16:55:01 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
16:55:09 <ski> if you want something more "real-worldy"
16:55:34 <Kiryx> yeah, I was gonna ask about that :)
16:55:46 <Kiryx> thanks, You're really helpful for newcomers :)
16:55:51 <ski> Kiryx : also, fyi, this channel likes to (try to) answer newbie-questions, so if you wonder about anything when you're reading and testing things, don't hesitate to ask here :)
16:56:32 <ski> (and if you want to, you're also welcome to stay and lurk a bit, seeing what other people talk about, maybe learn something)
16:57:17 <ski> sometimes we discuss abstract theoetial things here, sometimes utterly practical things. sometimes beginner things, sometimes more advanced things
16:57:26 <ski> (sometimes several of those at the same time)
16:57:47 <ski> so, don't be intimidated if you can't follow everything at once ;)
16:58:17 <ski> at the moment, the channel seems pretty slow, but at other times, there's lots of action happening in here
16:58:48 <ski> Kiryx : ok, i suppose that's the welcome-speech -- lastly, don't forget to have fun !
16:59:10 <Kiryx> I'm curious about this: Let's say I'm fluent in Python's lambdas, is there much more in haskell to surprise me ?
16:59:22 <mcstar> :)
16:59:25 <mel-> Kiryx: yes
16:59:53 <Kiryx> probably a stupid question :)
17:00:17 <mel-> (1) python allows you an imperative style of programing (2) haskell has much more fancy concepts, like e.g. monads/functors
17:00:28 <mel-> concepts which are not easy to grasp
17:00:30 <mauke>  > implying python has lambdas
17:00:31 * ski isn't very familiar with Python, but has heard that their lambdas doesn't do lexical scoping correctly in all cases
17:00:45 <BluePeppers> python lambdas are one of the worst features of the language
17:00:55 <mel-> BluePeppers: why?
17:00:57 <mauke> ski: their lambdas are limited to a single expression
17:01:09 <BluePeppers> single expression, no keywords
17:01:14 <Kiryx> I think that's true what mauke says
17:01:14 <ski> Kiryx : you'll also note that lambdas in Python can't contain commands, while in Haskell we express commands though expressions (and in practice, this will turn out to be important and useful)
17:01:17 <BluePeppers> can't do lambda x: print x
17:01:22 <mauke> ski: scoping is generally sucky but that's unrelated to lambda
17:01:26 <theorbtwo> That seems *awful* limiting.
17:01:31 <m3ga> i learned python a decade ago, then haskell and then started paid work in python. python is just horrid!
17:01:36 <ski> mauke : ok, so scoping of lambdas is right, then ?
17:01:57 <mel-> But in haskell functions are also just one expression, no?
17:02:02 <mauke> ski: yes (or at least not wronger than the rest of the language)
17:02:12 <ski> Kiryx : you will probably also see more advanced (but useful) examples of lambda in Haskell
17:02:18 <ski> mauke : ic, ty
17:03:16 <Kiryx> m3ga: haha, I was actually worried that I'd find python horrible after I learn haskell
17:03:21 <ski> (mauke : "implying python has lambdas" -- they can abstract over expressions, but not over commands. still seems to me it's lambdas)
17:03:26 <Kiryx> and there aren't that many paid gigs in haskell
17:03:35 <ski> (note that Haskell can't abstract over declarations/modules, while the MLs can)
17:03:50 <Kiryx> I'm worried whether I should learn it for my own sake :)
17:04:04 <ski> Kiryx : i'd say yes :)
17:04:07 <mel-> Kiryx: give it a try
17:04:10 <mcstar> it is not too late to bail out
17:04:15 <ski> hehe
17:04:15 <m3ga> Kiryx: you have no idea how bad python is once you know haskell. however the paid haskell gigs out there are often better paid than most python ones.
17:04:26 <BluePeppers> m3ga, bullshit
17:04:41 <BluePeppers> m3ga, python's a fine language, if you don't try to make it into haskell
17:04:42 <m3ga> BlastHardcheese: bullshit on what?
17:05:09 <mauke> BluePeppers: I disagree, of course
17:05:16 <ski> Kiryx : learning Haskell will teach you new and different ways to think in, which you can then pick and choose from as you see fit, even in other languages
17:05:24 <m3ga> BlastHardcheese: its really hard to write bad haskell. its stunningly easy to write bad python (i'd inherited 23k lines of crap).
17:05:26 <Peaker> ski, Python's lexical scoping is weird.. lambda/named-func are the same w.r.t scoping.  The rule is: stuff comes from outer scope unless there's an assignment statement in the func-def (only named can have assignments though).. the assignment's existence is checked syntactically, not dynamically
17:05:39 <mauke> m3ga: fail
17:05:42 <m3ga> sorru BlastHardcheese that was for BluePeppers
17:05:53 <Peaker> assignment into a variable makes it local to the function that contains the assignment
17:06:06 <theorbtwo> Of course, the techniques Haskell will teach you will fit better into some languages then others.
17:06:15 <ski> Kiryx : also, beware that if you've only done imperative programming before, then learning a functional programming language like Haskell will feel a bit like learning to program all over again (many things carry over, but many things don't) -- you'll have to unlearn some things
17:06:34 <Kiryx> ski: that's the main reason I want to learn something new, I started off with brilliant 6.001 SICP and lisp but figured haskell community may be more active atm
17:06:41 <Peaker> def f(): ..x... ; if False: x=1     in Python "x" is now local to "f", and will have an error trying to read its value.  Whereas:  def f(): .. x....      will read "x" from outer scope
17:06:56 <theorbtwo> C doesn't have lambdas at all.  Perl's lambdas are very lambda-ish, python's are somewhere in the middle.
17:06:56 <BluePeppers> m3ga, they both do stuff well, and they both do stuff badly. people who think functional programming is the only way are just as deluded as people who think imperative programming is the only way
17:07:06 <Peaker> Kiryx, I think Haskell has more interesting/deep stuff going on than Lisp, too :)
17:07:27 <ski> mel- : "But in haskell functions are also just one expression, no?" -- yes, but libraries don't expect you to do as many things through commands in Haskell, so it doesn't matter much
17:07:33 <mcstar> keep in mind, that haskell pureness and lazyness differs from most functional languages...
17:07:48 <m3ga> BluePeppers: eg OO code that doesn't obey Liskov substitutablity. deeply nested inheritance, including multiple inheritance. tests as a complete afterthought.
17:08:07 <m3ga> stuff that broken is really hard to do in haskell
17:08:17 <BluePeppers> m3ga, the good stuff in python is excellent, and I really enjoy writing it. The good stuff in haskell is good also. but haskell isn't perfect, and there is some stuff i really miss from python
17:08:47 <ski> Peaker : ok -- it's good that "the assignment's existence is checked syntactically, not dynamically", though
17:08:52 <m3ga> BluePeppers: i agree, it is possible to write good python code.
17:08:54 <BluePeppers> m3ga, aaah so your complaints are purely theoretical? and what do you mean by "tests as a complete afterthought"? Would you have the testing system built into the language?
17:09:07 <Peaker> ski, yeah, it would be better to just have explicit scopers
17:09:16 <mauke> m3ga, BluePeppers: #haskell-blah
17:09:18 <Peaker> BluePeppers, Haskell is great at functional and imperative programming. Python is only OK at imperative programming
17:10:06 <ski> Kiryx : SICP is probably good too (some will disagree), if you like it (and it's good to learn a Lisp to understand macros properly (i'd recommend Scheme over Common Lisp, here, to get *hygienic* macros))
17:10:20 <Peaker> BluePeppers, I used to love Python, the dynamic typing was fun, because static typing was such a chore. Then I discovered static typing doesn't have to suck, if done well... I don't really miss any of Python's dynamicness.  I really get annoyed when I crash in Python over silly bugs that would be caught at compile-time (the majority of them!)
17:10:50 <enjoylife> Question: there are alot of http related packages. . . I'm looking for a currently actively developed one.  HTTP seems to be pop up in alot of dependencies. Any experince with it??
17:11:22 <ski> mcstar : yeah. i think the most comparable languages are Clean, which is lazy and pure (no monads, but uniqueness typing), and Mercury, which is strict and pure (and which has support for both logic programming, and functional programming)
17:11:27 <Kiryx> ski: I actually used Scheme through the sicp course
17:11:56 <Peaker> BluePeppers, in Haskell, the stuff from Python I miss is: Sane stack traces, people import closed rather than * all the time, and the interpreter is everywhere so I can ship small text scripts rather than large executables
17:11:58 <BluePeppers> Peaker, really? You don't miss anything? I know I miss decorators to register functions. And as for type errors, meh, I don't get them. Though i'd prefer not to argue over static vs dynamic :)
17:11:59 <ski> Kiryx : yeah, but i don't recall whether SICP into (hygienic) macros at all
17:12:36 <mcstar> ski: what is it that gensym cant provide?
17:12:38 <BluePeppers> Peaker, I actually now prefer having executable, rather than having to deal with different python versions
17:12:46 <Peaker> BluePeppers, You still have the function register stuff via TH if you want, though I don't mind the extra explicit func-table violating DRY because I get warnings if functions aren't used via it
17:13:10 <Peaker> BluePeppers, it's nice to have an executable in some circumstances.. nice to be able to send a little text file over a "cat" session over a modem though, too
17:13:26 <ski> mcstar : say you have a module which defines a function `foo' and a macro `bar'
17:13:52 <ski> mcstar : the macro `bar', when invoked, expands to some piece of code which calls `foo'
17:13:52 <xplat> so i have this mysterious cabal error, and #hackage is asleep
17:13:57 <BluePeppers> Peaker, that's one thing I miss from python. The lack of language extensions. Though you are correct, but it does feel like overkill
17:13:58 <mcstar> ski: ah, redifining built -ins?
17:14:01 <Peaker> BluePeppers, When you maintain a large Python program, do you not get runtime Python exceptions?  Almost all of those are compile-time errors in Haskell
17:14:04 <xplat> cabal: Couldn't read cabal file "bloomfilter/1.2.6.10/bloomfilter.cabal"
17:14:07 <kallisti> is there anywhere where I can read about setting up a cabal repo?
17:14:08 <ski> mcstar : now, `foo' is not exported from the module, but `bar' *is*
17:14:08 <mcstar> ski: im sorry, i always forget that case..
17:14:15 <Peaker> BluePeppers, what do you mean by language extensions?
17:14:16 <xplat> when trying to install bloomfilter or anything depending on it
17:14:25 <aristid> enjoylife: http-conduit is good.
17:14:32 <ski> mcstar : so, whenever `bar' is invoked, it'll expand to code which calls `foo', even though `foo' isn't exported (it's private)
17:14:58 <Peaker> xplat, try to "cabal unpack bloomfilter" and "cabal install" in the unpacked dir?
17:15:00 <BluePeppers> Peaker, anything enabled via {-# LANGUAGE <something> #-}
17:15:16 <Peaker> BluePeppers, oh, you meant the one thing you miss "in python" rather than "from python" there?
17:15:50 <d-snp> hi am I doing this primes function right? https://github.com/d-snp/euler/blob/master/3.hs
17:16:00 <d-snp> I'm trying the third euler project problem
17:16:08 <d-snp> and this takes too long to execute
17:16:12 <Peaker> BluePeppers, anyway, I used to go back to Python for simple scripts, and APIs I knew.. it's becoming more and more rare, and now I do all of the one-off stuff in Haskell too.. golfing skills/conciseness comes in handy for quick&dirty stuff
17:16:23 <d-snp> not sure what I'm doing wrong, probably the primes function being too slow
17:16:24 <avpx> d-snp: One problem is that 1 isn't a prime number
17:16:29 <mcstar> ski: i see, but even if you dont have hygienic macros, that 'foo' would live in its home package/namespace, so the user cannot rebind it, or can he?
17:16:37 <Peaker> BluePeppers, now I open python just because ghci misses "hex()" and shifts by default, and needs more imports to get anything done
17:16:39 <d-snp> eh oh
17:16:45 <BluePeppers> Peaker, I don't get TypeErrors in general. I mean, the last few big errors I've come across wouldn't really have been solved by using haskell. The kind of stuff that gets caught by the compiler in haskell is often caught on the first debug run in python, or the refactoring after that
17:17:06 <Peaker> BluePeppers, "TypeError" in Python is far from the only thing Haskell compile-time catches
17:17:09 <ski> mcstar : a similar problem is if someone locally shadows `lambda' or `set!' or any such thing -- the macro expansion still ought to expand to the syntax which was in scope at the macro-definition site, but in typical low-level macro-systems like in Common Lisp, it'll catch the local definition instead (similar to dynamic scoping, instead of static/lexical scoping))
17:17:20 <Peaker> BluePeppers, "NoneType has no attribute '...'" is a particularly common Python error
17:17:22 <d-snp> avpx: still sleems to be slow thoug
17:17:23 <d-snp> h
17:17:29 <d-snp> (after removing the 1)
17:17:35 <avpx> Well yeah, I didn't expect it to get any faster from that
17:17:37 <Peaker> BluePeppers, ValueError for unpack of wrong size. Various other exception types
17:17:40 <BluePeppers> Peaker, Seriously? that's a type error.
17:17:53 <Peaker> BluePeppers, that's an AttributeError, actually
17:18:10 <ski> mcstar : the other part is that it's a PITA (imho) to have to recall to call `gensym' all the time, and also the code is more ugly -- but these are lesser points than the above points
17:18:16 <enjoylife> aristid: my only concern is the dependency list seems enormous. Any experince with it?
17:18:35 <Peaker> BluePeppers, IME, almost all Python runtime errors (except IO errors, mostly) become compile-time errors in Haskell
17:18:56 <Peaker> BluePeppers, and some Python code has no way of running fast, even for a single debug run (e.g: testing scripts that set up large slow environments)
17:19:10 <Peaker> BluePeppers, so I really appreciate not loading the script for 1 minute at a time to discover typos and silly type errors
17:19:13 <mcstar> ski: thanks for the explanation, re. the foldr problem, im still trying, but its extremely late now, ill check back tomorrow
17:19:23 <ski> mcstar : basically, aiui, the package-specific symbols is a workaround to avoid the worst consequences of lack of hygiene
17:20:12 <ski> mcstar : still, unhygienic macros don't compose well, it's hard to use macros to define new macros is the right way, without something breaking unexpectedly some time later
17:20:17 <Peaker> BluePeppers, Anyway, after years of doing Python, and then years of doing Haskell, I can't find any serious advantage to Python for practical work anymore, except the smaller learning curve and appealing to a wider audience of programmers
17:20:19 <ski> (when you've forgot about it)
17:20:54 <enjoylife> artistid: I like that it has a choice in it's level of api, though
17:21:27 <xplat> Peaker: now i get cabal: bloomfilter.cabal:38: The 'type' field is required for test suites. The
17:21:28 <BluePeppers> Peaker, No comment. We obviously write different python code, so it's hard for me to relate. I honestly can't remember the last time I got a runtime error that was a TypeError, AttributeError, NoneError etc that was a typo.
17:21:34 <xplat> available test types are: exitcode-stdio-1.0
17:21:58 <BluePeppers> s/was/wasn't/g
17:21:58 <Peaker> xplat, maybe you can just comment out the test suite part of the .cabal file?  it seems like you have a weird version of Cabal or cabal-install?
17:22:06 <xplat> Peaker: i guess this means latest bloomfilter is broken-as-uploaded :(
17:22:15 <Peaker> BluePeppers, What size projects are you working on?
17:22:43 <BluePeppers> Peaker, not massive. 10k~
17:22:50 <kallisti> BluePeppers: GHC catches some typos too! :D
17:23:04 <Peaker> xplat, 1.2.6.10 installed ok here (Cabal-1.14.0, cabal-install 0.14.0)
17:23:05 <BluePeppers> kallisti, Indeed it does. BUT AT WHAT COST?
17:23:14 <kallisti> BluePeppers: at the cost of...
17:23:20 <kallisti> uh...
17:23:25 <BluePeppers> kallisti, at the cost of using haskell :P
17:23:31 <kallisti> yes.
17:23:43 <Peaker> BluePeppers, So you edit a few dozen lines in your Python project, and it always runs correctly the first time? How many tests do you maintain?
17:24:22 <Peaker> xplat, What cabal/Cabal versions do you have (cabal --version ?)
17:24:50 <Peaker> BluePeppers, that cost is an O(1) cost of learning&getting used to the Haskell way of doing things :)
17:25:07 <Peaker> BluePeppers, then your O(N) programming experience becomes easier, you have to maintain less tests, and you get far more assurances after type-checking
17:25:42 <BluePeppers> Peaker, I feel like this conversation has deviated from the origin which was "hur durr python is awefull, haskell is great"
17:25:48 <BluePeppers> Peaker, yes I have to maintain more tests
17:26:41 <xplat> Peaker: got 0.10.2 with 1.10.1.0 library ... seems like it doesn't have the right cabal version requirements in the .cabal file then ...
17:26:55 <Peaker> BluePeppers, I did not feel that way when I felt I started "getting Haskell" but was still not fully comfortable with it. But I definitely feel that way now (that Python is pretty awful.. the benefit of the extra dynamic stuff is negligible if any, and the downsides are *huge*)
17:27:20 <BluePeppers> Peaker, and dealing with haskell isn't really O(1). I mean, I was looking for a simple web "microframework", similar to Flask in python. I spent the day reading up the various dependencies of some random web framework etc.
17:28:09 <Peaker> BluePeppers, stuff having lots of dependencies is a product of modularity.. when it is successful, it means stuff is broken up into lots of little packages that get composed
17:28:13 <theadmin> BluePeppers: You don't have to care about dependencies... Cabal does that for you.
17:28:18 <blackdog> BluePeppers: i found scotty quite nice for that
17:28:35 <BluePeppers> Peaker, it may seem wierd, but having a small learning curve is actually a good thing in a lot of cases. some parts of haskell have a real case of "You know nothing untill you know it all"
17:28:42 <BluePeppers> blackdog, thanks, will look it up
17:29:13 <BluePeppers> theadmin, not when their types are exposed etc. click a link in the documentation of one package, and you end up in another, and so on and so forth :)
17:29:46 <theadmin> BluePeppers: Oh, that...
17:30:01 <Peaker> BluePeppers, clearly, I mentioned this as the main benefit of Python over Haskell. It is great for hobbyists. But why does a career programmer care about the few months required to learn the best tools of the trade?
17:30:17 <enjoylife> Down the spiral hole of dependencies we must go
17:30:20 <blackdog> offtopic: anyone here made it all the way through "Let over Lambda"?
17:30:43 <theadmin> Bweh. Why the hell do names in Data.ByteString modules clash with those in Prelude anyway? Why is that even allowed? :/ I mean, sure, I can do a qualified import but still annoying as hell.
17:30:47 <BluePeppers> Peaker, it may be a product of modularlity, but it can lead to tight linking between libraries, making the overall system hard to grasp
17:30:51 <blackdog> provocative quote: "Haskell is an enormous success: it has proved static typing is a failure"
17:31:06 <Peaker> theadmin, because unqualified open imports are a *horrible* practice and you should feel ashamed for using them :)
17:31:40 <theadmin> Peaker: All modules implicitly import Prelude unqualified. How's that :P
17:31:45 <BluePeppers> Even I can agree with that
17:31:47 <Peaker> BluePeppers, if the components are independent, you never have to understand the whole system, just the individual components (each in terms of underlying components)
17:32:18 <xplat> that's why i always write this line: ‚Äòimport Control.Applicative -- i am a bad programmer and i feel bad :(‚Äô
17:32:22 <Peaker> theadmin, a trade-off.. it's bad, but the Report makes the name list explicit, and it won't be extended to collide with your own names in the future
17:32:30 <Peaker> xplat, hah :-)
17:33:08 <Peaker> theadmin, whereas most other modules (not in the Report) will be extended with new names in the future, selected carefully to collide with the names you choose :)
17:33:29 <Peaker> (or rather, that's a healthy way to think about it)
17:34:08 <theadmin> Peaker: Well, that I understand.
17:34:20 <Peaker> xplat, if you actually wrote that, it'd be a great incentive to add the typical (Applicative(..), (<$)) or such list there
17:34:26 <ski> blackdog : i thought i saw someone in #scheme or #lisp or #emacs saying how "LoL" shows *not* to do things ..
17:34:26 <Peaker> (instead of the apology)
17:35:55 <xplat> indeed
17:36:10 <ski> (sorry, s/shows/shows how/)
17:36:51 <Peaker> theadmin, import qualified Data.ByteString as SBS ; import qualified Data.ByteString.Lazy as LBS    makes it clear what kind of byte string you are using, too
17:36:54 <xplat> it'd be ideal if the infrastructure was there to support versioned imports, though
17:37:09 <Peaker> theadmin, SBS.ByteString vs LBS.ByteString and their respective operations  (too bad there's no good type-class for that)
17:37:23 <xplat> then you could have the convenience of open imports with the safety of closed ones
17:37:41 <xplat> (could easily get the same convenience from an IDE, though)
17:37:53 <Peaker> xplat, you want the export list from the old version, but the semantics of the new version?
17:38:03 <theadmin> Peaker: Yeah, that's what I do basically, though what's "SBS" supposed to mean?
17:38:05 <xplat> Peaker: yes
17:38:11 <Peaker> theadmin, Strict-Byte-String
17:38:16 <Peaker> theadmin, vs. Lazy-Byte-String
17:38:23 <theadmin> Peaker: Ah, okay then. Yeah, understood the second one
17:38:43 <Peaker> xplat, well, closed aren't just for safety, it's also nice for the reader (until we have good IDEs that make it easy to figure out a symbol's source)
17:39:24 <xplat> yes, and it is easier for a module writer to use an IDE than to get everyone who reads the module to use an IDE
17:39:25 <theadmin> Bah... I feel bad when I write a function that has an IO whatever in the type signature :/
17:39:31 <Peaker> theadmin, qualified imports are good... consider how it'd be nicer if you could: IORef.new/read/write, instead of newIORef, readIORef, etc, and pollute the namespace with unknown set of symbols: import Data.IORef
17:42:02 <xplat> i sometimes do miss decorators and similar metaprogramming stuff when i've been using python for a while and i switch to something else
17:43:12 <xplat> i don't like the lack of conceptual separation between data and metadata, but i do like that it cuts repetitiveness and makes it easier to track the connection between metadata and the data it describes
17:43:15 <BluePeppers> xplat, TH will theoretically do that for you.
17:43:32 <BluePeppers> xplat, though it's more natural in python
17:43:45 <theadmin> Bweh, Python. I hate Python and I don't even remember why anymore.
17:44:13 <xplat> theadmin: download the ibus-tables source if you'd like to be reminded ‚ò∫
17:44:21 <Clint> must be the significant whitespace and the list comprehensions
17:45:14 <Kiryx> I'm off to sleep
17:45:15 <xplat> Clint: nah, gotta be the operator overloading
17:45:20 <Kiryx> Thanks for an introduction
17:46:00 <xplat> (actually, it might be the operator overloading, what with the ad-hoc __opnames__ you have to remember)
17:46:20 <xplat> (and the left bias)
17:46:38 <theadmin> Maybe it's just the hamsterness of Python. Dunno.
17:47:03 <xplat> ... hamsterness?
17:48:28 <theadmin> Well, I'm not sure how to explain that... sorry, my own term >.<
17:49:14 <theadmin> Oh, I know why.
17:49:29 * ski . o O ( <http://i.imgur.com/1gF1j.jpg> (yes, it's an oldie) )
17:49:42 <theadmin> It's the C coders migrating to Python that I had to help. One specific one, actually, who kept defining main() and then running it at the end of his code, made it fuck-ugly.
17:50:06 <Nereid> isn't that how you're supposed to do it?
17:50:41 <BluePeppers> theadmin, well function scope is semantically different to global scope, and it's generally considered best practise to do that.
17:50:42 <Nereid> well, after testing to see if it's not imported as a module
17:50:42 <Peaker> why do Haskellers consider Lispers to be Darwin?
17:50:43 <unnali> ^that is how you're supposed to do it.
17:50:51 <kallisti> lack of sensible sensible lambda syntax. lack of tail-call elimation. lack of proper garbage collection. lack of any concept of variable declaration. bizzare scoping rules as a result of lack of any concept of variable declaration. any proper library uses type annotations in docs, thus giving you all the tedium of statc typing without any of the benefits.
17:50:58 <unnali> if __name__ == '__main__': main() # Pythonic.
17:51:33 <theadmin> Oh... Wow. Guess I'm not into Python.
17:51:39 <kallisti> lack of efficient concurrency due to interpreter locking.
17:51:42 * theadmin spent most of her time with Perl before Haskell.
17:52:06 <xplat> hah, me too
17:52:56 <Peaker> kallisti, but the imports are closed! :)
17:53:12 <BluePeppers> kallisti, really, the GIL? worst argument ever. they tried removing it, but fine grained locking was slower. multiprocessing is mostly used now though, which just works around it. and if you still really care, then you should be using PyPy which doesn't have the problem iirc
17:53:34 <kallisti> Peaker: lack of any handling of ambiguous names. so you're stuck with obnoxious.qualifiers.on.everything or possibly clashing names.
17:53:36 <Peaker> BluePeppers, if it was designed from the ground up for the GIL, changing it and gaining performance won't be easy
17:54:07 <xplat> i think the main problem with python is not so much that testing is preferred to types (though that is a problem) as the fact that there's no reasonable way to enforce that sufficient testing is done
17:54:20 <Peaker> kallisti, Same problem in Haskell, except the culture in Haskell is to use open imports and actually get errors later when versions update
17:54:35 <kallisti> Peaker: except that Haskell compilers report ambiguous names.
17:54:35 <xplat> python won't complain at you for not having enough tests, thus there is no floor on code quality
17:54:46 <Peaker> kallisti, yes, and then you can't get what you need installed
17:54:48 <xplat> perl at least has 'use strict'
17:54:57 <Peaker> kallisti, instead of a closed/qualified import which continues to work with new versions
17:55:00 <shachaf> xplat: There is no floor on Haskell code quality either.
17:55:10 <shapr> I had lots of trouble running Zope on SMP systems because of the GIL, but processor affinity mostly fixed that problem.
17:55:10 <BluePeppers> xplat, perl has a culture of testing, python does not, true. but not many languages do
17:55:14 <blackdog> ski: hm, that's interesting
17:55:23 <shapr> g'day blackdog!
17:55:24 <blackdog> (that LoL is a bad example)
17:55:25 * kallisti thinks Haskell libraries could use /more/ testing. :P
17:55:32 <shachaf> hlackdog
17:55:34 <ski> blackdog : sorry, i don't recall details of that
17:55:40 <xplat> shachaf: not technically, but in practice there sort of is
17:55:40 <theadmin> xplat: Well, "use strict" means "I don't know enough about how Perl works so I want the compiler to make me do stuff the long way".
17:55:40 <blackdog> shapr: what up, dude
17:55:47 * ski hasn't looked at the book
17:55:48 <shapr> kallisti: Maybe if QuickCheck tests were much easier to write, everybody would write them?
17:56:01 <Nereid> I thought qualified imports were the usual thing to do in haskell?
17:56:06 <xplat> shachaf: it takes a very special kind of person to get nontrivial and really bad code to even run in haskell
17:56:13 <blackdog> ski: but you mentioned the #schemers weren't impressed?
17:56:15 <shapr> Nereid: Not as much as I would ike :-)
17:56:24 <kallisti> theadmin: that's a very inaccurate way to describe use strict. use strict is recommended by basically any serious perl programmer.
17:56:24 <Nereid> true
17:56:31 <shachaf> xplat: You haven't been watching the @paste stream in here, have you? :-)
17:56:36 <blackdog> xplat: i feel a bit mean posting, but here: https://github.com/egonSchiele/robot-fruit-hunt
17:56:50 <theadmin> kallisti: For quick stuff, it's unnecessary. For serious programs/modules, sure.
17:56:53 <shapr> alexi_: If you're in a Haskell buffer, try M-x customize-mode
17:57:02 <shapr> alexi_: Are you still having problems with emacs haskell-mode?
17:57:02 <xplat> shachaf: those were all like 1-page messes
17:57:24 <ski> blackdog : i don't recall where exactly, but it was a lispy channel
17:57:24 <ski> blackdog : i suspect it was either #lisp or #emacs. might have been #scheme
17:57:29 <theadmin> kallisti: Using unitialized variables is fun! *grin*
17:57:34 <kallisti> theadmin: depends on how quick it is. I rarely enable use strict when I'm using perl on command line, but the "use strict; use warning" line vomits from my keyboard as soon as I open a new .pl file.
17:57:43 <blackdog> ski: he also blasts emacs in the appendix :)
17:57:46 <shachaf> xplat: But Haskell is so expressive that it can express in one page what other languages would take dozens of pages to mess up that badly!!
17:58:14 <Nereid> haha
17:58:28 <xplat> shachaf: you don't often get a 'working' piece of code like ibus-tables that internally looks like it was generated by a blender and runs about as well as you'd expect from that once you start stressing the code a little bit
17:58:29 <ski> blackdog : well, emacs *does* have a lot of problems -- but despite that, i (currently at least) prefer it to other environments
17:58:59 <ski> blackdog : at least emacs has gotten lexical scoping now ..
17:59:00 <BluePeppers> xplat, as if there is no bad haskell code in ther world? there is no such thing as a silver bulet
17:59:25 <kallisti> xplat: I can point you to bad Haskell code if you'd like. ;)
17:59:59 <Peaker> BluePeppers, why are people so convinced there are no/will be no "silver bullets"?
18:00:07 <Peaker> BluePeppers, we had several silver bullets in the past already
18:00:38 <ski> partial ones, yes
18:01:00 <Peaker> Compare productivity now with the productivity in the punch-card era
18:01:19 <Peaker> or when everything was written in assembly..
18:01:21 <BluePeppers> and?
18:01:31 <xplat> theadmin: imo 'use strict' means 'i don't want typos to crash my scripts or subtly corrupt my data midway through a long operation'
18:01:37 <Peaker> and you'll find orders of magnitude difference in productivity -- i.e: multiple silver bullets
18:01:42 <BluePeppers> C wasn't a silver bullet.. neither was the next step up. everything has been incremental
18:01:49 <xplat> theadmin: aren't you thinking of 'use warnings "all"'?
18:02:11 <Peaker> BluePeppers, just a few incremental changes (C and some tooling) can easily be a "silver bullet" (as compared with asm without those tools)
18:02:28 <Peaker> BluePeppers, I read "silver bullet" defined as an order of magnitude boost in productivity
18:02:41 <theadmin> xplat: No no, that's not what I mean, also you DO realize you don't have to take "all" in quotes, right?
18:02:45 <shachaf> Peaker: When you already have a silver bullet, another one won't do you any good. You need a bullet made from a harder metal, like gold.
18:02:54 <Peaker> oh, right :)
18:03:03 <BluePeppers> lead has a higher density
18:03:25 <Peaker> anyway, I think the "no silver bullet" paper is basically a nice way out of having to be imaginative about what tooling can do for us in the future
18:03:41 <Peaker> It's a good excuse for being able to just easily say: "There's nothing left to improve"
18:05:35 <hayashi> Anyone know how one finds out whether a file at a given path (that may be in a directory that doesn't exist, etc) exists?
18:05:41 <theadmin> Does GHC use all my processors by default? I have a quad-core processor and it'd be bad if it used just one core.
18:06:08 <blackdog> theadmin: you need to pass an argument to the runtime system
18:06:10 <hayashi> I assume one way would be to catch file not found exceptions whilst trying openFile, but that seems a bit of a hack
18:06:12 <MostAwesomeDude> theadmin: Are your calculations being done in parallel?
18:06:16 <shachaf> theadmin: You mean the compiler?
18:06:17 <zygoloid> @hoogle doesFileExist
18:06:17 <lambdabot> System.Directory doesFileExist :: FilePath -> IO Bool
18:06:21 <zygoloid> hayashi: ^^
18:06:27 <blackdog> theadmin: something /ike +RTS -N, i think
18:06:30 <hayashi> yay
18:06:44 <zygoloid> hayashi: it returns False if it's a directory
18:06:54 <theadmin> I just mean for the compilation, not for running.
18:07:10 <hayashi> I'll give that a go =D
18:07:15 <theadmin> I'm not into Haskell enough to do parallel computations yet %)
18:07:20 <MostAwesomeDude> Ah.
18:07:24 <shachaf> theadmin: Nope, pretty much not.
18:07:25 <xplat> BluePeppers: i'm not saying that it's impossible to write bad haskell code, or that nobody does it ever (obviously these things would be wrong).  i'm saying that programming languages have features that affect the typical quality of code created in them, and python chose a particularly bad set for this purpose
18:07:52 <blackdog> theadmin: it doesn't take much. statelessness is a big win there :)
18:08:36 <BluePeppers> xplat, but you are arguing that point using what seems to be the worst python code you can find (i presume). It'd be better if you chose an example closer to the median in code quality.
18:08:39 <xplat> compared to haskell, or even perl, it feels actively hard to write good code in python.  it takes more willpower and discipline, because the computer is happy to let you walk around with a loaded gun stuffed in your waistband
18:08:43 <shachaf> blackdog: If it doesn't take much then how come GHC hasn't done it yet, huh?!
18:09:21 <aristid> xplat: compared to perl? isn't perl equally willing to walk around with a loaded gun?
18:09:22 <zygoloid> because GHC is still too imperative :)
18:09:40 <theadmin> Well, people sometimes like to write bad code. Or unreadable.
18:10:07 <theadmin> I think I saw a program where all variable names consisted only of underscores somewhere (but that was in C, not that it matters)
18:10:25 <xplat> theadmin: i prefer to use string literals in quotes in perl except when golfing, when hash-indexing, when in qw or before =>, so that i don't get unexpectedly bitten by namespace issues turning it into a function call
18:10:50 <Peaker> xplat, how do you feel about Perl's type-coercions?
18:11:01 <Peaker> (I'm not sure what remains of them with "use strict;")
18:11:29 <geekosaur> funny, I just brought up http://calculist.blogspot.com/2006/02/nancy-typing.html ehsewhere...
18:12:17 <theadmin> Perl has no types, Peaker. Well, it does, but there are only 3, scalar, array, and hash... Well... And even those are very unstable, you can easily use an array as a scalar for instance :/ Bites sometimes.
18:12:22 <xplat> hayashi: with posix semantics there is no way to eliminate the possibility that a file won't be there when you try to open it (race condition), so it's usually best just to catch the exception and not to fool yourself that you've taken care of it with a check
18:14:02 <hayashi> *nods*
18:14:02 <Peaker> theadmin, that's more terrible than Python's worst stuff, IMO
18:14:25 <xplat> aristid: perl at least has some automatic code quality checks, even if you need to turn them on.  what's more, (mainstream) perl doesn't make a religion out of not wanting to check anything before a script starts running
18:14:29 <theadmin> Peaker: Heh, not really, long as you use the right functions/operators in the right place...
18:14:50 <Peaker> theadmin, having different operators for different kinds of equality sounds like a bad idea
18:15:02 <Peaker> (I mean: numeric equality vs. string equality)
18:15:06 <theadmin> Peaker: True that, eq is annoying.
18:15:17 <xplat> Peaker: i dislike the type coercions in perl, but at least it avoids the worst ones like '1' + 1 => '11'
18:15:26 <Peaker> Does Perl not keep any metadata regarding the difference between "1" and 1 internally?
18:15:39 <BluePeppers> xplat, where does python make a religion out of not checking stuff before the script runs?
18:15:40 <aristid> xplat: oh, i didn't know that python was more extreme than the average dynamic language about this
18:15:41 <theadmin> That I wouldn't know... The internals of Perl are beyond me.
18:16:03 <Peaker> xplat, Python does check syntactic correctness before the script runs (but not scoping)
18:16:24 <shachaf> Python doesn't allow '1' + 1.
18:16:28 <Peaker> xplat, "1" and 1 being equivalent is pretty bad stuff, compared with Python's quirks, I believe
18:18:12 <theadmin> Peaker: They're not *exactly* equivalent in Perl. To prove it, try: perl -M"feature say" -e 'say "0x15"; say 0x15' # But yes. Most of the time they can be used interchangeably.
18:18:38 <Peaker> theadmin, so they must be differentiated? how?  Is "say" a special form?
18:19:08 <shachaf> Peaker: It's not that Perl conflates the two, it's that most operators implicitly convert their arguments.
18:19:09 <Peaker> or does "" just inhibit some numeric parsing?
18:19:12 <theadmin> Peaker: say can be defined as: print "$_\n" for (@_);
18:19:40 <shachaf> Peaker: There's "numeric equality" and "string equality", for example, and if you do numeric equality on two strings, it'll convert them to numbers first.
18:20:03 <Peaker> xplat, Perl's not providing bulit-in function signatures, and doing all the conversions, and throwing in regexp syntax (making it a kitchen sink when other hammers would be better) I think encourage bad code more than Python's bad scoping rules, bad lambda syntax, etc.
18:20:27 <Peaker> shachaf, but if everything converts before the operation, then the "actual" unconverted type is not observable?
18:20:51 <shachaf> Peaker: Not everything does, just a lot of things.
18:20:52 <Peaker> (i.e: there is no type beyond scalar?)
18:21:00 <Peaker> oh, some things expose it?
18:21:13 <Nereid> Peaker: you can recover it up to isomorphism by yoneda :o)
18:21:38 <mauke> Peaker: you're assuming a single "original type"
18:22:03 <xplat> BluePeppers: if it wasn't a religion then python would at least check for accesses of things that couldn't possibly be in scope and die before running the script; but no, because maybe you know about the broken code path and you know it's not being invoked and it would be horrible if you had to do something about it before running the script because what if there are nuclear missiles coming toward you and you need your script to launch ABMs!?!?!
18:22:34 <shachaf> xplat: Like, eval, man.
18:22:38 <shachaf> Y'know?
18:22:41 <BluePeppers> what he said
18:22:46 <BluePeppers> it's a dynamic language. live with it
18:23:18 <xplat> Peaker: perl does keep metadata regarding the difference between '1' and 1, but in most cases rather than using that metadata it relies on using different operators, which i mostly approve of, even if it did cause the 'Nancy bug' referred to above
18:23:32 <theadmin> Python doesn't evaluate the script completely before running it -- it's like Bash, it executes a sequence of statements. Perl actually compiles something somewhere.
18:23:51 <MostAwesomeDude> Uh.
18:23:52 <mauke> python is not like bash
18:23:59 <theadmin> ...Well, I mean in this sense.
18:24:02 <mauke> stop being wrong on the internet
18:24:12 <BluePeppers> theadmin, no. python compiles to bytecode, which is then executed
18:24:22 <shachaf> Python is like tcsh and Perl is like ksh.
18:24:25 <shachaf> I hope that clarifies things.
18:24:29 <mauke> hah
18:24:42 <theadmin> ...Not that I know any of those 2, so no, doesn't clarify anything
18:24:52 * theadmin uses zsh most of the time.
18:25:30 <theadmin> BluePeppers: Okay, I see... So same as Perl in that sense then. Huh. Wonder how the interactive "python" thingo works then
18:25:44 <theadmin> Oh, a read-eval-print loop, doh
18:25:48 <BluePeppers> yeah :)
18:25:52 <mauke> like the interactive perl thing
18:26:03 <theadmin> mauke: Perl doesn't have one.
18:26:03 <shachaf> How do I get the interactive Perl thing?
18:26:04 <BluePeppers> theadmin, you can disassemble python using the dis module. it's quite good fun :)
18:26:06 <xplat> Peaker: also, my experience with python code is that not having regexp syntax in a particular language doesn't do much to reduce overreliance on regexes, it just makes regex-reliant code slower to read.  (but maybe eliminating it from several languages would have a larger effect?)
18:26:06 <mauke> theadmin: hahahaha
18:26:09 <mauke> theadmin: wrong
18:26:29 <mauke> shachaf: for quick and dirty stuff, perl -de 0
18:27:08 <mauke> shachaf: alternatively use re.pl (comes with Devel::REPL)
18:27:19 <theadmin> mauke: Unless you mean "perl -de42", then yeah, but it's not as great as "python" or irb or even ghci.
18:27:37 <Eduard_Munteanu> I wonder, how many dynamic languages actually do static checks (at least when they can do them)?
18:27:44 <Peaker> xplat, the nancy bug is exactly the kind of bad code Perl encourages and Python discourages, though
18:27:48 <chu> mauke: Someone is *WRONG* on the Internet?! Where, lemme at him.
18:27:49 <ski> Eduard_Munteanu : Schemes often do
18:27:58 <Peaker> xplat, it'd be nice to have counter-examples of bugs Python encourages over Perl
18:28:03 <Eduard_Munteanu> Hm, nice.
18:28:14 <xplat> shachaf: the perl debugger lets you evaluate perl code interactively
18:28:28 <mauke> shachaf: or tinyrepl
18:28:31 <Eduard_Munteanu> I guess one could design a statically-checkable language core then add optional stuff that defers checking to runtime.
18:28:41 <Peaker> does Perl have anything like Python's RPyC?
18:29:05 <Eduard_Munteanu> But going for full-dynamic strikes me as odd and a bit oblivious of the type-theory out there.
18:29:08 <ski> Eduard_Munteanu : e.g. many schemes tries to separate the conceptually distinct stages that arise due to having staged programming in the form of macros
18:29:32 <xplat> Peaker: indeed, i didn't say it was perfect.  i think perl encourages slightly higher code quality on average than python, but not to an overwhelming extent, and not in every case/aspect
18:30:06 <BluePeppers> Eduard_Munteanu, I've been thinking of trying to use cython to compile the static subset of python to c, and then just fall back to the standard python implementation when dynamic features are used
18:30:38 <Peaker> xplat, I have met very few Perlists in real life, everyone in the niches I'm in have long abandoned Perl for Python or other languages, and all the Perl code I had tried to understand wasn't very nice - but I admit I never dove too deep into Perl
18:30:59 <Eduard_Munteanu> Well, I was mainly concerned about catching errors at compile-time, dunno if Cython ever does that.
18:31:00 <Peaker> xplat, I disliked the bits I already saw, though, which prevented further diving
18:31:33 <BluePeppers> Eduard_Munteanu, ah, I was going more for speed. safety would be harder
18:32:22 <Eduard_Munteanu> Hm, I guess that's one other reason to go for static checking: if you can do erasure, you might save time.
18:35:36 <crutcher> Hey hey. I've been away from haskell for about a year and a half, and I'm trying to bootstrap back into it with some neural networking exercises.
18:35:58 <crutcher> So, I'm trying to work out which of the many options available I should use for matricies
18:36:08 <xplat> Peaker: an antipattern that i see a lot in python code is a try: catch: with the exception unspecified but which assumes it knows what happened and doesn't rethrow
18:36:41 <crutcher> if I want to work with strict non-sparse unboxed double matrices ‚Ä¶ where should I be looking in the libs?
18:37:13 <c_wraith> crutcher: probably a binding to one of the existing matrix libraries.
18:37:31 <xplat> or which throws a different error so you can't tell what actually happened when debugging
18:37:36 <JoeyA> Well, there's the array package, but that doesn't provide functions like matrix multiplication.
18:38:13 <xplat> and even when the exception is specified, it can often catch other errors than the one intended
18:38:16 <crutcher> is it worth my time to poke about in the data parallel haskell stuff?
18:38:33 <favonia> Eduard_Munteanu: I think in general the runtime checking and the static checking are fundamentally different. for example `(if false then () else "hello ") ++ "world"` is actually "fine". It becomes undecidable if 'false' is replaced by a fancy function. as an approximation Haskell requires every branch to be of the same type.
18:38:49 <crutcher> c_wraith: such as which?
18:38:51 <cesip> hmm.. guys, beginner question - what is wrong with the redefinition (/=) = not . (==) ?
18:38:53 <zachk> you have a few cores and want to crunch an algorithim that is parrellelizable?
18:39:03 <ski> cesip : it takes two arguments
18:39:09 <ski> @type not .: (==)
18:39:11 <lambdabot> forall a. (Eq a) => a -> a -> Bool
18:39:24 <ski> cesip : alternatively `(not .) . (==)'
18:39:32 <favonia> Eduard_Munteanu: I mean, I feel either your language becomes too restricted that runtime checking won't detect, or too permissive that static checking is undecidable
18:39:44 <c_wraith> crutcher: like http://hackage.haskell.org/package/jalla or http://hackage.haskell.org/package/blas
18:39:45 <zachk> @pl \a b -> not . (==) a (b)
18:39:45 <lambdabot> ((not .) .) . (==)
18:39:51 <zachk> that should work in its place
18:40:07 <zachk> @pl \a -b -> not (a == b)
18:40:08 <lambdabot> (line 1, column 4):
18:40:08 <lambdabot> unexpected "b"
18:40:08 <lambdabot> expecting "->"
18:40:21 * zachk goes huh
18:40:25 <xplat> (perl is not much better on this issue and in some ways worse; however the fact that a lot of stuff returns error codes instead of raising exceptions actually works in perl's favor here slightly, bizarrely enough)
18:40:36 <ski> zachk : one more try :)
18:41:05 <cesip> mmm okay i see
18:41:07 <zachk> @pl \a b -> not . (a == b)
18:41:07 <lambdabot> ((not .) .) . (==)
18:41:20 <zachk> same thing
18:41:20 <crutcher> c_wraith:
18:41:23 <crutcher> c_wraith: thanks
18:41:34 <ski> @pl \a b -> not (a == b)
18:41:34 <lambdabot> (/=)
18:41:36 * zachk remembers something a bit better but can not remmeber it 
18:41:37 <ski> hehe
18:41:37 <crutcher> wait, when did (.).(.) stop parsing?
18:41:48 <ski> crutcher ?
18:41:52 <xplat> :t (.).(.)
18:41:53 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
18:41:57 <Nereid> cesip: we have not :: Bool -> Bool, and (==) :: Eq a => a -> (a -> Bool)
18:42:03 <xplat> ... seems to parse fine?
18:42:17 <favonia> @pl \ a b -> not ((==) a b)
18:42:17 <lambdabot> (/=)
18:42:20 <ski> @pl \a b -> myNot (a == b)
18:42:20 <lambdabot> (myNot .) . (==)
18:42:21 <crutcher> I'm an idiot, was using "type", not ":type"
18:42:21 <Nereid> cesip: and a -> Bool does not match Bool, so you can't compose them
18:42:30 <cesip> so (==) actually returns a -> Bool then
18:42:37 <ski> yes
18:42:45 <ski> all haskell functions take a single argument
18:42:46 <Nereid> when given one argument, yes
18:43:26 <zachk> @pl \a -> (not . (== a))
18:43:27 <lambdabot> (/=)
18:43:29 <zachk> ha
18:43:32 <zachk> :-/
18:43:45 <kallisti> I wonder if I can repurpose haskell-src-exts for a modified record syntax.
18:43:48 <xplat> all haskell functions take a single argument.  then they might or might not take another.
18:44:08 <zachk> @type 5
18:44:09 <lambdabot> forall t. (Num t) => t
18:44:18 <zachk> what argument does that one take? ;)
18:44:18 <xplat> kallisti: quasiquoters are a large part of what it's there for, i think
18:44:42 <xplat> zachk: trick question; it's not a function
18:44:42 <mauke> zachk: depends on whether 5 is a function
18:44:56 <kallisti> xplat: for the most part I need custom parsing though
18:44:59 <kallisti> for some small things.
18:44:59 <xplat> (or rather, might or might not be a function)
18:45:11 <crutcher> zachk: it takes ()
18:45:11 <zachk> isn't five a function?
18:45:16 <kallisti> but things like type expressions I could delegate to an existing parser.
18:45:22 <mauke> zachk: usually no
18:45:23 <Eduard_Munteanu> Not normally.
18:45:31 <zachk> well what about @type x where x = 5
18:45:34 <xplat> kallisti: what's wrong with the existing syntax, other than not creating lenses?
18:45:40 <mauke> zachk: syntax error
18:45:41 <favonia> xplat: actually it can be a function in lambdabot's evaluator...
18:45:48 <kallisti> xplat: that's what I'm hacking in via quasiquotes. ;)
18:45:48 <Nereid> @type x where x = 45
18:45:50 <lambdabot> parse error on input `where'
18:45:50 <ski> > 5 4 3 2 1 0
18:45:51 <lambdabot>   5
18:46:03 <Nereid> caleskell
18:46:04 <Nereid> :v
18:46:05 <xplat> favonia: don't read only the highlighted lines :)
18:46:34 <ski> @type 5
18:46:35 <lambdabot> forall t. (Num t) => t
18:46:37 <zachk> is there any way I can run caleskell locally? is there a cabal or anything of it?
18:46:39 <ski> @type let x = 5 in x
18:46:41 <lambdabot> forall t. (Num t) => t
18:46:52 <mauke> zachk: there is no "caleskell"
18:47:02 <ski> @where L.hs
18:47:02 <lambdabot> What lambdabot has in scope is at <http://code.haskell.org/lambdabot/State/L.hs>
18:47:29 <crutcher> zachk: well ‚Ä¶ the theory says it takes (), but in implementation Haskell can distinguish between f :: () -> Int and f :: Int
18:48:34 <ski> crutcher : they have different types, so the question whether they can be distinguished or not isn't type-correct !
18:48:48 <favonia> xplat: the moral is that don't irc while working on some project reports... :(
18:49:23 <rwbarton> if a theory says () -> Int and Int are "the same", that's all well and good but the theory does not describe Haskell well
18:49:40 <crutcher> ski: that's my point. the category theory would hold that they were the same, that f :: Int was merely a point in the Int object, so a function from () -> Int
18:49:41 <Nereid> the theory says that they're isomorphic, not equal
18:49:49 <kallisti> xplat: I guess I can roll my own parser based on the lexer in haskell-src, and then collect pieces of the syntax for haskell-src-exts to parse.
18:49:53 <kallisti> in particular type expressions.
18:49:55 <crutcher> ski: but haskell's type system distinguishes between them
18:49:55 <Nereid> (modulo issues relating to bottom)
18:50:18 <xplat> Nereid: if it's homotopy type theory then isomorphic and equal are the same ...
18:50:36 <Nereid> but it's haskell
18:50:42 <ski> crutcher : an element of a set isn't the same as a morphism from the terminal object -- they're merely isomorphic
18:51:21 <crutcher> ski: that depends entirely on what you choose to mean by "same"
18:51:58 <Nereid> the question was about haskell
18:52:03 <ski> crutcher : the problem is that isomorphisms needn't be unique
18:52:06 <theadmin> When creating a new type using "data" or "newtype", are any typeclasses derived automatically?
18:52:12 <favonia> xplat: well they're still not _definitionally_ equal. there are at least two kinds of equality in ITT and HTT.
18:52:13 <Nereid> theadmin: no
18:52:17 <Nereid> theadmin: you must specify "deriving"
18:52:24 <theadmin> Nereid: Good, thanks. Thought so.
18:52:26 <crutcher> ski: isormorphisms from () must be unique
18:52:31 <xplat> Utility/StatFS.hsc:54:8:
18:52:31 <xplat>     Could not find module `GHC.Foreign':
18:52:31 <xplat>       Use -v to see a list of the files searched for.
18:52:44 <Nereid> crutcher: the type in question isn't ()
18:53:00 <Nereid> not that that's relevant
18:53:06 <Eduard_Munteanu> theadmin: you can't do that for 'data' generally (for all typeclasses), although certain extensions let you derive additional stuff.
18:53:16 <xplat> favonia: definitional equality is in the metatheory, not the theory, though
18:53:16 <Eduard_Munteanu> You can do it for newtypes though.
18:53:18 <crutcher> Nereid: seeing as that's the one I started talking about, yeah, I think it is
18:53:25 <Nereid> Eduard_Munteanu: given -XGeneralizedNewtypeDeriving
18:53:31 <Eduard_Munteanu> Yeah ^^
18:53:32 <xplat> well, halfway in the metatheory anyway
18:53:40 <Nereid> crutcher: no, the discussion was about Int and () -> Int
18:53:52 <xplat> i suppose you could also say it's syntactic, not semantic
18:54:18 <theadmin> Eduard_Munteanu: That's not what I asked. I meant if I do something like data RGB = RGB Int Int Int, would, say, Show, Read and such general stuff be automatically there? But Nereid answered already. Thanks anyway.
18:54:20 <zachk> > (++) "..." . fmap toUpper .  drop  .  reverse (cake)
18:54:21 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
18:54:21 <lambdabot>         against inferred ty...
18:54:47 <zachk> > drop . reverse (cake)
18:54:48 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
18:54:48 <lambdabot>         against inferred type ...
18:54:54 <zachk> ack
18:55:01 <theadmin> zachk: What ARE you doing?
18:55:03 <zachk> > tail . reverse (cake)
18:55:06 <lambdabot>   ["hat will deodorize and preserve putrid tissue.","nd it contains proven pr...
18:55:07 <ski> zachk : syn
18:55:21 * zachk drop none drop none....
18:55:24 <theadmin> ...wtf? What's that "cake"...
18:55:29 <Nereid> > cake
18:55:31 <lambdabot>   ["One 18.25 ounce package chocolate cake mix.","One can prepared coconut pe...
18:55:35 <zachk> > cake !! 12
18:55:38 <theadmin> Bwahahah.
18:55:38 <lambdabot>   "Fish shaped dirt."
18:55:53 <theadmin> TIL lambdabot is GLaDOS' memory sphere.
18:55:56 <mauke> tootoot
18:55:59 <crutcher> Nereid: morphisms from () are unique; there's a strong reason to say that, in an object A, the type A and the type () -> A can be treated as equivalent. Haskell's type system does not do this. I don't know enough about it to know why this choice was made, and I'm not challenging it. But it is interesting that A and () -> A aren't type alisases
18:56:01 <shachaf> > reverse . take 12 . reverse . map head $ cake
18:56:03 <lambdabot>   "TOOTASCIICAT"
18:56:11 <Nereid> crutcher: not in haskell they aren't, () has two values
18:56:18 <shachaf> I guess I meant 8.
18:56:26 <JoeyA> > map head cake
18:56:28 <lambdabot>   "OOTFOTOTDFFFFFPFCOAUFANTOATTOOTOOTASCIICAT"
18:56:30 <zachk> > (++) "..." . take 1 . drop 1 . reverse ( cake )
18:56:33 <lambdabot>   ["...h","...n","...r","...n","...n","...o","...l","...d","...w","...n","......
18:56:48 <zachk> ummm
18:56:57 <Nereid> zachk: (.) = fmap
18:57:21 <geekosaur> lambdabot doesn't quite speak normal haskell
18:57:29 <Nereid> > take 1 . drop 1 . reverse ( cake )
18:57:31 <lambdabot>   ["h","n","r","n","n","o","l","d","w","n","n","h","n","n","w","w","n","n","w...
18:57:32 <Nereid> > take 1 . drop 1 . reverse $ cake
18:57:35 <lambdabot>   ["And it contains proven preservatives, deep penetration agents, and gas an...
18:57:40 <favonia> xplat: ahhh this is something i am working on but i cannot keep irc-ing. need focusing X(
18:57:46 <zachk> > (++) "..." . head . drop 1 . reverse (cake)
18:57:47 <xplat> Peaker: thanks for the help, i still can't seem to get git-annex installed, there's some mysterious error for old versions and newer ones want me to upgrade base (i.e. they don't like my GHC install)
18:57:47 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
18:57:47 <lambdabot>         against inferred ty...
18:57:52 * zachk gives up 
18:57:58 <Nereid> > (++) "..." . head . drop 1 . reverse $ cake
18:58:00 <lambdabot>   "...And it contains proven preservatives, deep penetration agents, and gas ...
18:58:27 <crutcher> Nereid: yes, it has bottom. Are there any types in haskell that exclude bottom?
18:58:36 <Nereid> crutcher: strict ones
18:58:39 <kallisti> zachk: juxtaposition of 2 terms has higher precedence than any operator
18:58:55 <kallisti> zachk: so f x ++ f y    is always (f x) ++ (f y)
18:59:02 <kallisti> regardless of whatever operator "++" is
18:59:27 <Nereid> crutcher: but because of bottom, () -> () contains 3 values, so is clearly not isomorphic to ()
18:59:35 <gwern> @wn parlous
18:59:36 <lambdabot> *** "parlous" wn "WordNet (r) 3.0 (2006)"
18:59:36 <lambdabot> parlous
18:59:36 <lambdabot>     adj 1: fraught with danger; "dangerous waters"; "a parlous
18:59:36 <lambdabot>            journey on stormy seas"; "a perilous voyage across the
18:59:36 <lambdabot>            Atlantic in a small boat"; "the precarious life of an
18:59:38 <lambdabot> [3 @more lines]
18:59:57 <crutcher> Nereid: is strictness visible at the type layer?
19:00:03 <kallisti> zachk: so you wrote  ((++) "...") . (head) . (drop 1) . (reverse cake)
19:00:13 <crutcher> Nereid: I thought it was a storage/evaluation strategy
19:00:21 <Nereid> that's laziness, not strictness
19:00:27 <kallisti> zachk: but you meant ((++) "..." . head . drop 1 . reverse) cake
19:00:42 <theadmin> > ((++) "..." . head . drop 1 . reverse) cake
19:00:45 <lambdabot>   "...And it contains proven preservatives, deep penetration agents, and gas ...
19:00:50 <xplat> crutcher: some kinds of strictness are visible at the type layer in that some strict types have kinds other than *
19:01:10 <Nereid> namely, #
19:01:29 <xplat> @kind Int#
19:01:31 <lambdabot> Not in scope: type constructor or class `Int#'
19:01:54 <xplat> hrm
19:02:02 <geekosaur> I think that;s no longer entirely true
19:02:19 <geekosaur> got rejiggered when ConstraintKinds came in
19:02:19 <xplat> what kind of GHC has base 4.5 again?
19:02:29 <donri> 7.4
19:02:29 <Eduard_Munteanu> @src Int
19:02:30 <lambdabot> data Int = I# Int#
19:02:58 <Eduard_Munteanu> @kind I#
19:03:00 <lambdabot> Not in scope: type constructor or class `I#'
19:03:01 <xplat> wow, that's a pretty strict constraint, wonder what git-annex uses that's only in 7.4 ...
19:03:27 <xplat> :t I#
19:03:29 <lambdabot> Not in scope: data constructor `I#'
19:03:31 <Nereid> crutcher: so, given that bottom exists, the terminal ( = initial) type in haskell is the void type
19:04:10 <xplat> iow CPO has a zero object, and it ain't ()
19:04:17 <crutcher> ok then
19:04:49 <crutcher> there's a lot of things happening in the haskell type system I still don't understand
19:04:59 <xplat> but see also 'fast-and-loose reasoning is morally correct'
19:05:13 <donri> xplat: there seems to be a branch for ghc7.0
19:05:19 <donri> e.g. http://git-annex.branchable.com/install/Fedora/
19:07:32 <Nereid> crutcher: things might be a little more familiar if you restrict to the subcategory of flat domains
19:07:37 <crutcher> xplat: :) that's a cute paper
19:07:39 <Nereid> = sets/partial functions = pointed sets
19:08:13 <Nereid> (types like () and Int are in there)
19:08:46 <crutcher> Nereid: maybe, probably not. My abstract algebra interest was driven by Haskell, they feed on each other. But only when I have time.
19:09:13 <crutcher> Nereid: there's a lot I still don't know, and lacking a framework to follow, I'm chunking through several books in parallel
19:09:17 <crutcher> Nereid: again, when I have time
19:09:21 <Nereid> mm
19:10:07 <xplat> hm, i wonder what the debian squeeze backport is built with
19:11:41 * hackagebot lens-family-th 0.2.0.0 - Generate lens-family style lenses (DanBurton)
19:12:29 <theadmin> Hm, RWH says that GHC operates by the Haskell 98 standard by default, is that so?
19:12:53 <crutcher> Nereid: I've generally decided to build something large that I'm interested in as a side project
19:13:07 <monochrom> flat domains are a bit boring :)
19:15:28 <JoeyA> theadmin: Haskell 2010 these days... well, sort of.
19:16:04 <theadmin> JoeyA: "sort of"?
19:16:17 <JoeyA> One example of "sort of" is base 4.5's Num class, which does not have Eq and Show constraints
19:17:51 <JoeyA> Hmm, where is Prelude in the Haskell 2010 standard?
19:18:13 <c_wraith> I believe it's the same as H98
19:18:23 <monochrom> chapter 9
19:18:24 <JoeyA> http://www.haskell.org/onlinereport/haskell2010/
19:18:34 <JoeyA> monochrom: Thanks
19:18:56 <JoeyA> Quoth the Haskell 2010 standard: "class  (Eq a, Show a) => Num a  where"
19:19:06 <monochrom> some chapter numbers got bumped up because FFI is inserted as chapter 8
19:19:31 <JoeyA> I bet that made a lot of people mad.
19:20:05 <monochrom> oh, that one, haskell 2010 is being superceded there by the latest decision on the library mailing list :)
19:20:36 <JoeyA> (it was a joke, referring to the chapter numbers being bumped up)
19:20:49 <monochrom> oh hahaha
19:23:06 <theadmin> Oooh, that. I should read the standard someday.
19:23:19 <JoeyA> What's the polite way to announce a new Hackage library these days?  http://www.haskell.org/haskellwiki/How_to_write_a_Haskell_program#Publicity recommends announcing to haskell@haskell.org, but that seems a little extreme.
19:24:00 <JoeyA> Some people (e.g. myself) don't have a filter on haskell@haskell.org, but do have a filter on haskell-cafe@haskell.org
19:25:11 <theadmin> JoeyA: What's the point of "announcing" a library exactly?...
19:25:54 <monochrom> I have seen announcing on haskell alone, on haskell-cafe alone, and on both. no one seems to complain at any one
19:26:19 <JoeyA> theadmin: So the library won't go unnoticed, and to discuss similar libraries and possible improvements.
19:26:25 <monochrom> however, announcing on reddit is sure to offend no one :)
19:26:54 * theadmin just discovered logBase -_-
19:27:08 <theadmin> I really should read the standard...
19:27:31 <monochrom> http://thread.gmane.org/gmane.comp.lang.haskell.glasgow.user/21065/focus=21075 on Num not inheriting Show
19:27:44 <otters> hahaha
19:27:49 <otters> the guy who wrote lens-family never executed any of the code
19:28:57 <theadmin> ...Uploading to hackage without executing sounds at least weird
19:29:10 <otters> yeah
19:29:14 <otters> agreed
19:29:20 <zachk> did he quickcheck it or something?
19:29:29 <xplat> no
19:29:30 <otters> no, just made sure it compiled
19:29:45 <theadmin> ...
19:29:47 <JoeyA> 1) Write a library 2) Upload to Hackage without executing it 3) Announce on reddit 4) ??? 5) Link karma
19:29:50 <xplat> well, he made sure that some unit tests compiled too
19:29:55 <xplat> but he didn't run them either
19:29:56 <otters> oh okay
19:29:56 <Nereid> lol
19:30:23 <monochrom> that depends on the actual code. you know how some code doesn't need further test than type-checking
19:31:36 <theadmin> Oh well I'm off to sleep, see you guys.
19:54:07 <coppro> woohoo
19:56:35 <crutcher> with Data.Array, is there anyway to find the bound after construction?
19:56:49 <crutcher> not being able to do that seems very strange
19:56:53 <c_wraith> yeah, you can
19:57:27 <c_wraith> I don't remember the function offhand
19:57:33 <monochrom> even better, you get the lower and upper bounds. "bounds"
19:57:37 <crutcher> aaaaand there it can
19:57:40 <crutcher> there it is
19:57:48 <crutcher> class method
19:57:50 <crutcher> doh
19:58:09 <monochrom> if you like, "indices" gives you the complete list of valid indexes
20:01:17 <juhp> is there a standard name for:  \ x y -> x ++ " " ++ y  ?
20:01:29 <juhp> maybe +-+ or +_+ ?
20:01:29 <shachaf> Not really.
20:01:32 <shachaf> unwords [x,y]
20:01:39 <mauke> printf "%s %s"
20:01:47 <juhp> hmm ok
20:01:53 <shachaf> Ugh, printf.
20:02:00 <mauke> $(printf "%s %s")
20:02:11 <shachaf> Better.
20:02:17 <juhp> maybe I will just go with one of mine there :)
20:02:25 <juhp> s/there/then/
20:02:29 <shachaf> Will that give you a String or IO () or a magic value which is either or what?
20:02:57 <Eduard_Munteanu> :t $(printf "%s %s")
20:02:58 <mauke> I don't remember
20:02:58 <lambdabot> parse error on input `$'
20:03:00 <mauke> probably a string
20:03:16 <Eduard_Munteanu> :t ($(printf "%s %s"))
20:03:18 <lambdabot> forall a b. (PrintfType a) => (a -> b) -> b
20:04:06 <shachaf> Eduard_Munteanu: I don't think that's what mauke was referring to. :-)
20:04:13 <Eduard_Munteanu> :P
20:04:27 * Eduard_Munteanu isn't really sure what though
20:04:34 <mauke> TH
20:05:01 <Eduard_Munteanu> mauke: hm, does that give you some typesafe printf?
20:05:06 <mauke> yes
20:05:12 <Eduard_Munteanu> Neat.
20:06:52 <juhp> hmm +_+ looks a bit too much like a Japanese emoticon to me ;o)
20:07:09 <mauke> it's not a valid operator
20:07:15 <juhp> ah
20:07:17 <juhp> slap
20:07:25 <coppro> Hey all
20:07:26 <mauke> +¬∑+
20:07:32 <coppro> Is there a good guide to making hackage packages somewhere?
20:08:00 <juhp> guess makes it easy for me to choose +-+ then
20:08:06 <shachaf> > let (+Ôºø+) = 5 in (+Ôºø+)
20:08:08 <lambdabot>   5
20:08:22 <gww>  /)/)
20:08:26 <gww> (-.-)
20:08:37 <mauke> +‚éµ+
20:08:44 <shachaf> mauke++
20:08:53 * shachaf was trying to remember what that character was called.
20:09:01 <mauke> U+23B5 (e2 8e b5): BOTTOM SQUARE BRACKET [‚éµ]
20:09:02 <Eduard_Munteanu> (:[]) is pretty close :P
20:09:02 <shachaf> BOTTOM SQUARE BRACKET
20:09:04 <shachaf> Great.
20:09:05 <juhp> yeah but I am lazy :)
20:09:13 <Eduard_Munteanu> (robot monkey :P)
20:09:19 <mauke> but I actually copied it from my .vimrc
20:09:34 <shachaf> listchars=trail:‚éµ?
20:09:37 <archeyDevil> ?src succ
20:09:37 <lambdabot> Source not found. You speak an infinite deal of nothing
20:09:37 <mauke> set lcs=tab:¬ª¬≠,trail:¬∑,eol:¬∂,nbsp:‚éµ,precedes:‚Üê,extends:‚Üí sbr=‚Ü™
20:09:43 <shachaf> Ah, nbsp
20:09:47 <archeyDevil> o.O
20:10:02 <juhp> cool
20:10:10 <mauke> @src Enum
20:10:11 <lambdabot> class  Enum a   where
20:10:11 <lambdabot>     succ                     :: a -> a
20:10:11 <lambdabot>     pred                     :: a -> a
20:10:11 <lambdabot>     toEnum                   :: Int -> a
20:10:11 <lambdabot>     fromEnum                 :: a -> Int
20:10:13 <lambdabot> [3 @more lines]
20:12:12 <juhp> (I remember I used +-+ in the past...)
20:12:29 <applicative> coppro: http://www.haskell.org/cabal/users-guide/
20:12:50 <shachaf> ¬±-
20:12:55 <shachaf> +‚àì
20:13:03 <shachaf> ¬±‚àì
20:13:30 <applicative> coppro: if it is set up more or less like other packages, try cabal init in the main directory
20:15:12 <coppro> applicative: it isn't
20:15:20 <coppro> applicative: I keep all my code in a single directory
20:15:28 <coppro> I'll need to pull off a package
20:17:19 <crutcher> do I actually have to install lapack for jalla on osx?
20:17:39 <crutcher> the docs seam to suggest that Xcode 4.3 has it built in
20:17:44 <crutcher> but cabal isn't having it
20:17:46 <applicative> coppro: I'm not sure there's any good guide to 'heirarchicalizing' modules, so to speak.  hmmm.
20:17:47 <ski> Nereid : "but because of bottom, () -> () contains 3 values, so is clearly not isomorphic to ()", if you count `seq', yes
20:18:03 <coppro> applicative: oh, my modules are hierarchical
20:18:06 <coppro> just all in the same root
20:18:21 <Nereid> ski: \() -> () and const () are different
20:18:25 <Nereid> right?
20:18:39 <mauke> > (\() -> ()) undefined
20:18:40 <lambdabot>   *Exception: Prelude.undefined
20:18:49 <shachaf> Nereid: The question is whether undefined and const undefined are different, I think.
20:19:35 <Nereid> I thought about that
20:19:58 <Nereid> why should they be different?
20:20:14 <applicative> coppro: I'm not following, they're all named e.g. Control.X.Y Control.X.Z and so one?
20:20:37 <Nereid> > (undefined :: () -> ()) `seq` ()
20:20:38 <lambdabot>   *Exception: Prelude.undefined
20:20:40 <Nereid> > (const undefined :: () -> ()) `seq` ()
20:20:42 <lambdabot>   ()
20:20:54 <Nereid> I guess.
20:21:01 <Nereid> but why?
20:21:20 <shachaf> Why what? Why is there a primitive that can tell them apart?
20:21:26 <Nereid> no no
20:21:30 <Nereid> then what is () -> ()?
20:21:41 <shachaf> A type?
20:21:44 <Nereid> sure.
20:22:18 <Nereid> in any case I was still right when I said it contains 3 values, if that's interpreted to mean "at least 3".
20:22:21 <Nereid> :P
20:22:39 <Nereid> but I mean
20:22:42 <shachaf> I think it contains exactly 3?
20:22:54 <shachaf> But _|_ is the devil.
20:22:59 <shachaf> So really it only contains one.
20:23:05 <Nereid> well it cleary contains at least 4 now, undefined, const undefined, const (), and \() -> ()
20:23:26 <shachaf> Oh, yes.
20:24:03 <mauke> \() -> undefined
20:24:12 <shachaf> That's const undefined
20:24:13 <Nereid> how is that different from const undefined
20:24:16 <ski> > fix (\ ~() -> ())
20:24:17 <ski> > fix (\() -> ())
20:24:17 <lambdabot>   ()
20:24:20 <lambdabot>   mueval-core: Time limit exceeded
20:24:21 <mauke> \() -> error "hello world"
20:24:29 <shachaf> That's also const undefined.
20:24:40 <ski> the two functions given to `fix' differs only in how they behave when passed `_|_'
20:24:44 <mauke> different _|_
20:25:32 <applicative> > (\() -> ())  undefined
20:25:34 <lambdabot>   *Exception: Prelude.undefined
20:26:06 <applicative> > const () undefined
20:26:07 <lambdabot>   ()
20:28:14 <applicative> Is it just polymorphism that lets const get away with this?
20:28:26 <shachaf> Polymorphism?
20:28:39 <shachaf> That doesn't have to do with anything.
20:28:50 <applicative> well I was thinking if i define konst () = () it doesnt work
20:28:57 <shachaf> konst _ = ()
20:29:11 <shachaf> konst :: () -> () -> (); konst _ = ()
20:29:17 <shachaf> Er.
20:29:23 <applicative> wait no, I'm in a typical muddle
20:29:25 <shachaf> konst :: () -> () -> (); konst x _ = x
20:29:58 <applicative> id is to be distinguished from const ...
20:30:28 <applicative> they're so abstract it can be hard to keep them  apart...
20:30:45 <shachaf> The problem is that you're dealing with a value with only a single inhabitant. :-)
20:30:49 <shachaf> Try Bool -> Bool.
20:31:10 <shachaf> How many values :: Bool -> Bool are there in Haskell?
20:31:40 <applicative> 4 plus ugliness
20:31:53 <Nereid> lol
20:31:58 <mauke> my guess: at least 10
20:32:37 <coppro> applicative: yes, but I have myhaskelldir/Foo/Bar which I would like to package
20:32:45 <coppro> I would not like to package myhaskelldir/Foo/Baz
20:33:16 <applicative> and the modules in Bar, like Baz.hs are called e.g. modules Foo.Bar.Baz?
20:33:19 <shachaf> mauke: I can't think of more than 8 off-hand.
20:33:29 <shachaf> Oh, wait.
20:33:37 <shachaf> Yes, there are a lot. :-)
20:33:38 <Nereid> shachaf: True and False can map to any of {_|_, True, False}, so that's at least 8.
20:33:43 <Nereid> then there are also const True and const False.
20:33:53 <coppro> applicative: yes
20:33:58 <applicative> coppro, rather and the modules in Bar, like Baz.hs begin e.g. module Foo.Bar.Baz where?
20:34:11 <coppro> applicative: yeah
20:34:26 <coppro> applicative: so that I can compile everything from myhaskelldir/
20:34:28 <coppro> or run ghci from there
20:34:33 <applicative> then do cd myhaskelldir then cabal init
20:34:41 <coppro> but I don't want to package everything
20:34:46 <coppro> and I may want multiple packages out of my source
20:35:12 <shachaf> OK, so 12?
20:36:21 <HugoDaniel> i need a function that does something like: [a] -> [b] -> [c] ... -> [z] -> [(a,b,c,d,e,f,g...,z)]
20:36:26 <HugoDaniel> is there zomething like that ?
20:36:36 <HugoDaniel> zzzomething
20:36:37 <applicative> coppro: I see your problem is becoming a little clearer.
20:36:59 <coppro> :)
20:37:01 <applicative> HugoDaniel: (,,,,,,,,,,,) <$> ... for starters
20:37:04 <HugoDaniel> it could also be -> [MyData]
20:37:32 <HugoDaniel> oh
20:37:33 <HugoDaniel> so
20:37:37 <applicative> @type zip5
20:37:38 <lambdabot> forall a b c d e. [a] -> [b] -> [c] -> [d] -> [e] -> [(a, b, c, d, e)]
20:37:53 <HugoDaniel> MyData <$> lstA <*> lstB <*> lstC ... <*> lstZ
20:37:55 <applicative> @type zip7
20:37:55 <HugoDaniel> would work ?
20:37:56 <lambdabot> forall a b c d e f g. [a] -> [b] -> [c] -> [d] -> [e] -> [f] -> [g] -> [(a, b, c, d, e, f, g)]
20:38:07 <applicative> HugoDaniel: yes
20:38:25 <HugoDaniel> oh ok
20:38:26 <HugoDaniel> nice
20:38:31 <ski> HugoDaniel : zipping or cartesian-producting ?
20:38:37 <applicative> or zipWith17 MyData if you can find it :)
20:39:11 <applicative> zipping surely!
20:39:54 <HugoDaniel> i dont know :/
20:40:03 <HugoDaniel> i have a butload of mapM's that give me lists
20:40:10 <HugoDaniel> of the same size
20:40:21 <coppro> applicative: I mean, I can just move my stuff off into library directories
20:40:23 <HugoDaniel> now i need to return these lists in a wrapper
20:40:29 <HugoDaniel> zipping or a new dataype
20:40:30 <coppro> applicative: but what's the usual way to run GHC then so it knows to access all my libraries?
20:40:31 <applicative> that is [MyData a b c ... z | a <- as | ... | z <- zs] or  [MyData a b c ... z | a <- as , ... , z <- zs]
20:40:37 <HugoDaniel> witchever works
20:40:41 <coppro> is there some config or something?
20:42:54 <applicative> HugoDaniel: ski meant, do you want all possibilities, or everything in  as bs ... zs in succession
20:42:58 <monochrom> are you serious about the 26-tuple?!
20:43:18 <danharaj> what symbol would you guys use for the operator that adds a vector to a point in an affine space
20:43:32 <danharaj> also the operator that takes the difference vector between two points.
20:43:36 <applicative> what is the upper limit?
20:43:43 <monochrom> hmm, vector and point... how about .+ or +. ?
20:43:48 <danharaj> good enough
20:43:51 <danharaj> no one else is going to see this anyway
20:43:57 <monochrom> hehe
20:44:02 <danharaj> I like puns too
20:44:04 <danharaj> visual puns!
20:44:23 <monochrom> all I can do is puns
20:44:25 <HugoDaniel> my haskell code is pure sh*t
20:44:28 <applicative> .-.
20:44:59 <applicative> HugoDaniel: if you have a 26 field type, it can't be all bad
20:45:19 <danharaj> apparently .- is not valid
20:45:23 <danharaj> I kind of like it more than -.
20:45:33 <HugoDaniel> i don't actually code haskell, i code a variant i made called SH(askell)IT
20:45:53 <applicative> -.-
20:45:55 <HugoDaniel> it compiles to haskell
20:46:00 <danharaj> wow neither of them are valid operators
20:46:03 <danharaj> monochrom: too bad :3
20:46:08 <monochrom> yikes
20:46:15 <newsham> icfp contest starts friday noon utc.
20:46:18 <newsham> woot
20:46:40 <applicative> newsham: I'll join you team
20:46:41 <danharaj> oh wait nevermind
20:46:45 <danharaj> man I haven't coded in so long.
20:46:49 <newsham> app: i dont have a team
20:47:29 <monochrom> hehe, they're valid :)
20:47:33 <danharaj> yeah
20:47:39 <newsham> i think i might be out next sat.. but i'll prob goof with it a little on fri and sunday at least
20:47:45 <danharaj> I never interpret ghc parse errors correctly.
20:47:48 <danharaj> This is a rule.
20:48:01 <newsham> danh: you need to work on your parse error parser
20:48:29 <newsham> danh: clearly you're not getting enough practice.  write more bad code!
20:50:12 <applicative> i dont want to submit a statically linked binary compiled for Debian 6.0 for x86 to the icfp, whats wrong with my .hs modules?
20:52:07 <Eduard_Munteanu> Are they seriously considering running arbitrary executables? :/
20:52:45 <applicative> frankly, this seems like an incredibly tiresome constraint for a programming competition.  i would rather instruct them how to install the compilers with debian
20:53:08 <irene-knapp> wait, ICFPC has released preparatory information?
20:53:24 <newsham> ed: are you gonna write a program to detect which VM it is, and do a VM escape?
20:53:34 <HugoDaniel> i wanted to try the icfp competition
20:53:35 <applicative> Eduard_Munteanu: http://icfpcontest2012.wordpress.com/ The judges‚Äô environment will be a Virtual Machine running Debian 6.0 ‚Äúsqueeze‚Äù for i386. The VM will have 1 single core CPU, 1 Gb of RAM and 30Gb virtual disk space. There will be no network connection available for submitted programs at runtime.
20:53:48 <newsham> ed: do you think in previous years they read all the code to identify any malcode before running it?
20:54:16 <irene-knapp> ahahahaha "An example of a good reason [for not submitting a binary] would be: 'I only have access to a Raspberry Pi'."
20:54:26 <applicative> does that exclude ghc-made binaries already?  :)
20:54:37 <newsham> app: need more ram?
20:54:46 <applicative> irene-knapp: I was going to say "I'm not really sure I know how"
20:55:10 <irene-knapp> heh, okay
20:55:38 <monochrom> invoke "I only have an Apple II"
20:56:03 <applicative> its true that i only have access to a macbook
20:57:08 <applicative> but i can tell them how to install the haskell platform with debian squeeze
20:58:09 <coppro> applicative: is there a way to make my GHC automatically treat myhaskelldirectory/*/ as library directories?
20:58:22 <newsham> app: your ibook can run virtualbox running squeeze
20:58:22 <coppro> then I could just move things to myhaskelldir/lib-1/ myhaskelldir/lib-2/ etc.
20:58:46 <monochrom> I'm pretty sure there are enough haskell entries that the judges will have ghc
20:59:20 <newsham> the instructions clearly say that you can tell them which packages to install
20:59:26 <applicative> monochrom: there's still the question of the excuse, which is explicitly demanded.  maybe i can get one from my doctor
20:59:28 <newsham> and there's a squeeze package for the whole haskell platform
20:59:39 <irene-knapp> also, one of the co-chairs is a Haskeller, so yes.
20:59:49 <monochrom> invoke "haskell is an interpreted language" :)
20:59:58 <coppro> applicative: oh wait, huh.
21:00:02 <newsham> "my code will only run on http://dmitry.co/index.php?p=./04.Thoughts/07.%20Linux%20on%208bit"
21:00:03 <coppro> applicative: I suppose I could use local cabal installs?
21:00:07 <applicative> maybe the binary I will send will begin main = system "apt get..."
21:00:11 <coppro> still feels a tad inferior :(
21:00:21 <newsham> app: no network
21:00:59 <applicative> coppro: the only think I have done is to cabalize each, lib1 lib2 but i agree it makes it harder to just fiddle with them simultaneously
21:01:21 <applicative> newsham: yes i noticed that.  i was making a protest binary
21:01:47 <applicative> the one last year was a turkey too if I remember
21:02:27 <irene-knapp> I still loved the sand-computer year
21:02:30 <irene-knapp> and the ants year
21:02:33 <newsham> this year they require you to use eventbrite :(
21:02:46 <monochrom> you can use .ghci and put a lot of "-i myhaskelldir/lib-1" in it. note: this is include directories, not library directories. there is no library directories
21:03:43 <applicative> eventbrite?
21:04:34 <applicative> "We recommend preparing a Virtual Machine in advance. Don‚Äôt worry, it‚Äôs easier than you think, I (Edwin Brady) managed to install and prepare a Debian VM on Mac OS X in around an hour, despite only just having heard of VirtualBox when I started‚Ä¶ "
21:04:40 <monochrom> awakening #1: ghc does not "scan /usr/local/lib for libraries". see my http://www.vex.net/~trebla/haskell/sicp.xhtml#ident for how ghc looks for libraries
21:05:10 <monochrom> in fact, see the whole article for a complete awakening
21:05:18 * applicative wishes Prof Brady had written a short tutorial on his experience.  Somehow I think compiler-writers are more likely to get things right...
21:05:57 <irene-knapp> @seen edwardk
21:05:57 <lambdabot> Unknown command, try @list
21:06:02 <irene-knapp> @last edwardk
21:06:02 <lambdabot> No module "edwardk" loaded
21:06:05 <irene-knapp> lol
21:06:17 <newsham> applicative: its really easy.
21:06:48 <monochrom> a short tutorial on setting up virtualbox: ("click next")* :)
21:07:17 <newsham> 1) download the net-install CD or the install DVD.  2) install virtual machine if you dont have one yet (ie. virtualbox), 3) make virtual machine boot the CD or DVD, 4) follow the install program steps on screen
21:07:42 <monochrom> to be fair, I think a screencast is more efficient and effective than a verbal tutorial, for both writers and readers
21:07:49 <newsham> 5) when done, type "sudo apt-get install haskell-platform"   (ok, that step is non-obvious)
21:08:25 <applicative> I would feel more confident if it read, "Dont worry, it's easier than you think. A friend of mine (Conor McBride) managed to install  and prepare a Debian  VM on  Mac OS X in under a week"
21:08:51 <applicative> Then I would actually do it.
21:09:19 <newsham> mcbride formalized a system for lifting arbitrary packages into Linux in under a week
21:09:32 <applicative> newsham: the last step is familiar to me
21:09:36 <irene-knapp> newsham: lol
21:09:38 <CSWookie> I'd like to test if every number in a list is a factor of a particular number.  I think 'all' is my friend here, but I'm not seeing how it should be used.
21:09:47 <CSWookie> Can someone give me an example?
21:09:58 <CSWookie> Wait.
21:10:03 <monochrom> von Neumann says: proceed with transfinite induction. don't worry, it's easier than you think, I (von Neumann) learned it in 5 minutes when I was 12
21:10:09 <CSWookie> I thought I was in haskell land
21:10:18 <applicative> @google moolibiconv
21:10:19 <lambdabot> http://www.haskell.org/pipermail/haskell-cafe/2009-December/071137.html
21:10:19 <lambdabot> Title: [Haskell-cafe] GHC 6.12 on OS X 10.5
21:10:21 <irene-knapp> > all (\n -> rem 6 n == 0) [1, 2, 3]
21:10:22 <newsham> > all (\x -> x % 10 == 0) [10,20,30,0,50]
21:10:23 <lambdabot>   True
21:10:25 <lambdabot>   False
21:10:49 <applicative> ^^^ when I first was  trying to install ghc this appeared
21:11:00 <newsham> > map (%10) [10,20,30,0,50]
21:11:01 <lambdabot>   [1 % 1,2 % 1,3 % 1,0 % 1,5 % 1]
21:11:10 <newsham> oops
21:11:16 <newsham> rem :)
21:11:28 <monochrom> haha you C junkie or something
21:11:33 <applicative> "I renamed the latter to opt/local/lib/moolibiconv.dylib, and   > suddenly, > GHC became capable of linking stuff. "
21:11:40 <applicative> "Did I break anything"
21:11:45 <newsham> mono: also java, python, etc..
21:12:04 <CSWookie> Maybe I am.
21:12:10 <irene-knapp> this is a problem which I solve by not using fink/macports
21:12:28 <applicative> irene-knapp: it was the olden days
21:12:41 <irene-knapp> hm?
21:12:49 <irene-knapp> I'm not aware of any days that were so old that compiling by hand wasn't an option
21:13:56 <Eduard_Munteanu> newsham: yeah, I suppose you're right about the security implications.
21:14:15 <applicative> irene-knapp: i did that too, not actually knowing what a compiler was at the time.
21:14:33 <irene-knapp> haha okay, fair enough :D
21:14:44 <applicative> is there an alarming security implication?
21:15:23 <newsham> app: my point wsa that running arbitrary binaries is prob no worse than running arbitrary src code entries.
21:15:35 <newsham> since they're not going to scrutinize all the src anyway
21:16:09 <monochrom> they use a virtual machine for your executable. it may be pretty safe for them. start looking for virtualbox loopholes though :)
21:16:22 <applicative> yes
21:16:23 <newsham> mono: a virtual machine is not a security boundary
21:16:37 <newsham> it was not written as a security boundary and probably hasnt withstood scrutiny as a security boundary
21:16:52 * applicative is downloading virtual box  . Now he needs to get debian whatever
21:16:58 <coppro> newsham: VMs are supposed to be security boundaries
21:17:03 <coppro> on most modern machines
21:17:03 <newsham> coppro: nope.
21:17:22 <irene-knapp> in principle they can be, but they aren't yet
21:17:22 <coppro> newsham: [citation needed]
21:17:28 <newsham> i take that back -- originally "nope", now they are starting to be marketted as such
21:17:35 <newsham> so.. retroactive security.. the most secure kind
21:17:51 <applicative> Robert Atkey is another of the judges.  My confidence is coming back...
21:18:44 <monochrom> I don't know what is "supposed". I'm talking about pragmatics. if you know of loopholes in practice, you can say it.
21:19:21 <coppro> newsham, irene-knapp: Most VM systems nowadays consider breakouts to be bugs.
21:19:36 <irene-knapp> glad to hear, but google on virtualbox exploit has many hits :)
21:19:45 <coppro> yeah, they definitely still exist (and sometimes they're in hardware, which can present a problem) but they are not supposed to
21:19:54 <monochrom> the same way I don't talk about what telephone answering machines are "supposed" to be used. some people say it is "supposed" to take messages. some other people ignore that and use for screening incoming calls
21:20:00 <newsham> coppro: right, but the programmers who wrote the code did not originally consider the code running in the VM as potentially hostile.
21:20:16 <newsham> think about internal assumptions and the code you've written in any large project
21:20:25 <newsham> and extrapolate based on your experiences..
21:20:46 <parcs`> a functional programming contest that's restricted to a single core? pfft
21:21:20 <newsham> how easy is it to change major assumptions in a large program and then go back and carefully trackdown and fix all the subtle assumptions that resulted from it
21:21:26 <coppro> newsham: heh :)
21:21:39 <coppro> newsham: There are certainly many holes in VMs that make them not equivalent to physical separation
21:21:43 * applicative realizes, he already has virtualbox on this ancient mac
21:21:49 <coppro> newsham: But they aren't all necessarily fatal to the notion of VMing
21:22:09 <newsham> also another tact: there is a long history of VM breaks.
21:22:11 <coppro> newsham: Breakouts are the only ones you really have to watch out for, and those are thankfully fixed quickly if discovered (and not in hardware)
21:22:45 <coppro> a lot of the literature I find seems to mention network attacks... but those aren't unique to VMs
21:22:59 <monochrom> perhaps the judges lie about using virtualbox, afterall
21:23:03 <newsham> i'm not talking about network attacks.
21:23:16 <newsham> i'm talking about code running in the vm breaking out
21:23:29 <newsham> for example by interacting with a buggy device emulation
21:23:53 <newsham> or by using an extra virtual machine feature such as special file sharing hooks to the native guest
21:24:11 * Eduard_Munteanu ponders SELinux + VM
21:24:22 <Eduard_Munteanu> That might be reasonable to lock down.
21:26:05 <Eduard_Munteanu> (and easier than sandboxing arbitrary apps in SELinux, though that's already been done)
21:26:31 <Eduard_Munteanu> e.g. Fedora's sandbox -X
21:28:23 * archeyDevil just set a namedscratchpad for ghci :)
21:37:39 <applicative> hah, I see one of the commentors at the icfp site actually is worried that SBCL  binaries wont fit on their vm
21:44:48 * applicative has virtual box and debian 6.0.5 i386 .  He is moving faster than Prof Brady, but will end in ruin
21:51:16 <HugoDaniel> applicative: u there ?
21:51:35 <applicative> yes, for what it's worth
21:51:39 <HugoDaniel> :)
21:51:45 <HugoDaniel> back to the 26 tuple
21:52:01 <HugoDaniel> so MyData <$> lstA <*> lstB <*> lst C ...
21:52:11 <HugoDaniel> gives me all the combinations
21:52:43 <HugoDaniel> but, what if i just want like the 26 possible values ?
21:52:59 <applicative> yes, that was why ski wondered if it was what you wanted
21:53:01 <HugoDaniel> MyData (lstA !! 0) (lstB !! 0) ...
21:53:10 <HugoDaniel> then 1, then 2...
21:53:12 <HugoDaniel> ah yes
21:53:24 <applicative> you want to zip, right.
21:53:33 <HugoDaniel> well, maybe
21:53:39 <HugoDaniel> i think using a data type might be better
21:53:50 <HugoDaniel> to access only a given property in the future
21:53:57 <sajith> People, has anyone tried building C sources in a haskell package with an alternate compiler?  Such as ICC on Linux?
21:54:01 <applicative> getZipList $ MyData <$> ZipList lstA <*>...
21:54:05 <applicative> not as romantic
21:54:32 <HugoDaniel> ZipList lstA <*> ZipList lstB <*> ...
21:54:35 <HugoDaniel> hmmm
21:54:37 <applicative> HugoDaniel: sorry, I meant you want to zipWith26 MyData
21:55:02 <applicative> in which case you need the other applicative instance, to continue with that approach
21:55:09 <HugoDaniel> oh
21:55:10 <HugoDaniel> :/
21:55:12 <HugoDaniel> argh
21:55:54 <applicative> @type getZipList
21:55:55 <lambdabot> forall a. ZipList a -> [a]
21:56:19 <HugoDaniel> so...
21:56:40 <HugoDaniel> ZipList lstA would procude [[a]]
21:56:47 <HugoDaniel> produce
21:57:01 <applicative> > getZipList $ (,,) <$> ZipList [1..10] <*> ZipList "alphabet soup" <*> ZipList (repeat True)
21:57:02 <lambdabot>   [(1,'a',True),(2,'l',True),(3,'p',True),(4,'h',True),(5,'a',True),(6,'b',Tr...
21:57:15 <mm_freak> how about changing lstA and lstB to lst A and lst B?  then you can use 'sequence'
21:57:30 <applicative> but you can put your constructor in place of (,,..,)
21:57:30 <mm_freak> lst a and lst b that is
21:58:34 <mm_freak> (of course that only works if the result types are all equal‚Ä¶  see, that's why haskell really should get at least some primitive form of dependent types some day)
21:58:51 <HugoDaniel> hmm
21:59:16 <HugoDaniel> i like the zipList approach
21:59:20 <HugoDaniel> i didn't knew about these :)
21:59:28 <applicative> > [(x,y,z) | x <- [1..10] | y <- "alphabet soup" | z <- repeat True]
21:59:29 <lambdabot>   [(1,'a',True),(2,'l',True),(3,'p',True),(4,'h',True),(5,'a',True),(6,'b',Tr...
21:59:30 <HugoDaniel> i feel my SH(askell)IT is improving
22:00:08 <mm_freak> > sequence (replicate 26 ['a'..'z'])
22:00:10 <lambdabot>   ["aaaaaaaaaaaaaaaaaaaaaaaaaa","aaaaaaaaaaaaaaaaaaaaaaaaab","aaaaaaaaaaaaaaa...
22:00:37 <HugoDaniel> :)
22:00:40 <mm_freak> > sequenceA (replicate 26 (ZipList ['a'..'z']))
22:00:42 <lambdabot>   Not in scope: `sequenceA'
22:01:00 <mm_freak> > T.sequenceA (replicate 26 (ZipList ['a'..'z']))
22:01:02 <lambdabot>   Not in scope: `T.sequenceA'
22:01:09 <mm_freak> > Data.Traversable.sequenceA (replicate 26 (ZipList ['a'..'z']))
22:01:11 <lambdabot>   No instance for (GHC.Show.Show
22:01:11 <lambdabot>                     (Control.Applicative.Zip...
22:01:20 <mm_freak> > getZipList $ Data.Traversable.sequenceA (replicate 26 (ZipList ['a'..'z']))
22:01:21 <lambdabot>   ["aaaaaaaaaaaaaaaaaaaaaaaaaa","bbbbbbbbbbbbbbbbbbbbbbbbbb","ccccccccccccccc...
22:03:00 <mm_freak> it's also a bit disturbing that ZipList still has no Show instance =)
22:03:27 <mm_freak> after all it's just two words in the source code to add it
22:03:45 <applicative> mm_freak: HugoDaniel wants something like [a] -> [b] -> [c] ... -> [z] -> [(a,b,c,d,e,f,g...,z)]
22:04:13 <mm_freak> applicative: yeah, i got that‚Ä¶  see my remark about dependent types
22:04:38 <applicative> Ah I see
22:05:28 <mikeplus64> is it possible to use TH to "load" FFI stuff?
22:06:16 <mikeplus64> (wondering how you might go about implementing a C quasiquoter that actually makes a function from the FFI)
22:09:31 <mikeplus64> (or another language like python or something)
22:11:59 <Axman6> mikeplus64: i think as long as its accessible from the AST you create with TH, it should be possible
22:12:43 <mikeplus64> yeah, that's the thing (i don't know if it is possible, time to waltz around TH haddock docs again)
22:14:15 <mikeplus64> oh, it is
22:14:39 <mikeplus64> time to hack something *horrible* up
22:16:47 * hackagebot oi 0.2.1.0 - Library for purely functional lazy interactions with the outer world. (NobuoYamashita)
22:22:21 * applicative wonders if he should install a graphical desktop for his icfp debian vm
22:24:35 * applicative accidentally pressed yes; what a disaster
22:32:55 <HugoDaniel> :)
22:34:49 <archeyDevil> Are ghc & it's libs written in full or pointfree style? (when suitable)
22:44:52 <archeyDevil> Prelude> [x/2 | x <- [0..]] !! (maxBound :: Int)
22:45:00 * archeyDevil wonders if that'll ever return :P
22:45:42 <aavogt> mikeplus64: what you're suggesting is pretty similar to this I did a while ago: http://hpaste.org/50837 , there may have been some issues with the actual F2Hs.hs which doesn't seem to be posted
22:49:37 <zzing_> When I have a type [1] Handler b v a   and my type is Handler App App ()  where App is a simple data structure, is there anything that can be said about the purposes of b, v, and a? The documentation doesn't really help me or lead me correctly.  ([1]: http://hackage.haskell.org/packages/archive/snap/0.9.0.1/doc/html/Snap-Snaplet.html#g:8 )
22:57:46 <applicative> mikeplus64: surely what you really want is http://www.eecs.harvard.edu/~mainland/projects/metahaskell/
22:59:37 <mikeplus64> applicative: yes, that seems to be what i /want/ but ghc doesn't support it
23:09:03 <crutcher> I've just spent a rather long time trying to "cabal install dph-examples" on OSX 10.7.4 machine with the latest haskell platform release
23:09:20 <crutcher> it's blowing up on trying to find out what version of LLVM is installed
23:10:55 <crutcher> and ghc in the haskell platform release blows up on the -fdph-par flag
23:14:22 <zzing_> :t liftIO
23:14:24 <lambdabot> forall a (m :: * -> *). (MonadIO m) => IO a -> m a
23:23:36 <applicative> crutcher which is blowing up looking for llvm dph-examples?
23:24:17 <crutcher> Preprocessing executable 'dph-spectral-smvm' for dph-examples-0.6.1.3...
23:24:17 <crutcher> [1 of 3] Compiling Vectorised       ( examples/spectral/SMVM/dph/Vectorised.hs, dist/build/dph-spectral-smvm/dph-spectral-smvm-tmp/Vectorised.o )
23:24:19 <crutcher> exprType TYPE ghc-prim:GHC.Types.Double{(w) tc 3u}
23:24:20 <crutcher> exprType TYPE ghc-prim:GHC.Types.Double{(w) tc 3u}
23:24:22 <crutcher> exprType TYPE ghc-prim:GHC.Types.Double{(w) tc 3u}
23:24:23 <crutcher> exprType TYPE ghc-prim:GHC.Types.Double{(w) tc 3u}
23:24:25 <crutcher> exprType TYPE ghc-prim:GHC.Types.Double{(w) tc 3u}
23:24:26 <crutcher> exprType
23:24:28 <crutcher>     TYPE (ghc-prim:GHC.Types.Int{(w) tc 3J},
23:24:29 <crutcher>           ghc-prim:GHC.Types.Double{(w) tc 3u})
23:24:31 <crutcher> Warning: Couldn't figure out LLVM version!
23:24:32 <crutcher>          Make sure you have installed LLVM
23:24:34 <crutcher> ghc: could not execute: opt
23:24:35 <crutcher> cabal: Error: some packages failed to install:
23:24:36 <crutcher> dph-examples-0.6.1.3 failed during the building phase. The exception was:
23:24:37 <crutcher> ExitFailure 1
23:25:14 <BMeph> crutcher: Next time, hpaste. ;)
23:26:21 <crutcher> I'm trying to workout a stable solution for matrix work, but getting pretty annoyed
23:26:32 <crutcher> i've got the latest osx and haskell platform
23:26:43 <crutcher> doh won't install cleanly from the examples given
23:26:48 <applicative> hm,  does it hook up with llvm in a different way from the way ghc does with -flllvm
23:27:35 <crutcher> s/doh/dph/; stupid autospellcheck
23:27:38 <applicative> i do have a homebrew llvm, for some other reason, but it all seems to be compiling
23:28:18 <crutcher> applicative: llvm is part of Xcode, and I've also got it installed via macports. doesn't work with or without the macports paths attached
23:28:50 <crutcher> I tried getting jalla working earlier, but it blew up with lapack (which is ALSO part of Xcode)
23:28:57 <applicative> yeah just a sec, I will see if mine is working before speculating why it might be :)
23:29:15 <crutcher> not sure if I'm supposed to install yet another copy of lapack for that
23:29:34 <crutcher> oh, and my installed ghc has no idea what the -fdph-par flag means
23:29:44 <crutcher> and it came from the haskell platform release
23:30:20 <crutcher> also, side note : how the hell do I get ghc to dump all the flags it knows about?
23:31:36 <crutcher> that introspection-fail really threw me. How does a 20yo compiler not have a dump-flags mechanism?
23:31:55 <blackdog> so, i'm trying to write an API wrapper. one function takes three URLs. is it good practice to tag them, so i'd call the function as 'foo (Barlink "http://blah.org/") (Bazlink "http://baz.org") (QuuxLink "http://quux.org") ?
23:32:48 <blackdog> (initially i was just using records, and it's a bit more obvious there, but then you get all the horrible namespace collisions and i gave it up as a bad idea)
23:32:59 <HugoDaniel> i wish ghc could be faster in compiling :(
23:33:04 <HugoDaniel> its so slooowww
23:33:59 <fuchsto> I have a rather long list and i need random access on it (think of iterating in z-order). I known that lists are bad for random access, as they are single linked lists. What would be a good data structure to do that?
23:34:29 <crutcher> fuchsto: an Array?
23:34:52 <applicative> crutcher well I am viewing a swank barnes hut nbody show via gloss
23:35:09 <HugoDaniel> :)
23:35:20 <HugoDaniel> im viewing ghc compiling for 2hrs
23:35:28 <blackdog> fuchsto: are you going to update them, or is it a static table?
23:35:32 <HugoDaniel> ok, 1h35m to be honest
23:35:35 <crutcher> applicative: osx + haskell platform?
23:35:51 <crutcher> applicative: or did you install it yourself?
23:36:00 <fuchsto> blackdog: It's static, and the values are boxed, it's OpenGL vertices.
23:36:08 <crutcher> applicative: I'm leaning towards a bug in HP's config
23:36:22 <blackdog> fuchsto: yeah, use Array or Vector, i'd say
23:36:33 <crutcher> applicative: it's just frustrating, because the docs _say_ that this works
23:36:45 <fuchsto> blackdog: Like IOArray?
23:38:01 <applicative> crutcher: yes, os x + latest haskell platform, I'm trying to think what question to ask next
23:38:44 <crutcher> applicative: hmm, it's possible I'm misreading http://www.haskell.org/haskellwiki/GHC/Data_Parallel_Haskell#Where_to_get_it
23:38:54 <HugoDaniel> i love it when ghc outputs pages and pages of warnings for my modules :D
23:39:40 <crutcher> is it possible that you've got a local install of ghc that overlaid the HP install?
23:39:54 <crutcher> maybe the HP one doesn't support doh?
23:39:59 <blackdog> fuchsto: you should be able to use just a standard Array. where are you getting the long list in the first place?
23:39:59 <crutcher> dph
23:40:08 <LK4D4> hi, help me with parsec pls. i have file with quotes, separated by '%', and i want list of quotes. my code here: http://bpaste.net/show/34088/. why i have all text in one element of list?
23:40:34 <crutcher> I wish there was a way to ask ghc flags in knew
23:40:41 <crutcher> or even better, it's compile options
23:40:46 <fuchsto> blackdog: I have a buffer of signals. Every new signal is transformed into a list of vertices. Then i am generating a list of indices (the order these vertices should be rendered in)
23:41:11 <fuchsto> blackdog: Then finally i have to iterate the indices (similar to z-order)
23:41:40 <blackdog> so you need to pull out the indices in a certain order, not necessarily the order you put them in?
23:41:47 <blackdog> sounds more like a heap...
23:41:52 <HugoDaniel> Loading object (dynamic) thr ... done
23:41:55 <HugoDaniel> and halts
23:42:36 <fuchsto> blackdog: the indices are something like [0,1,10,2,11,3,13,...] and the elements are in a matrix.
23:43:05 <fuchsto> blackdog: And i'm doing something like   map ( \i -> renderVertex $ vertices !! i ) indices
23:43:30 <fuchsto> blackdog: i need random access for the vertices, not the indices.
23:44:18 <applicative> crutcher: the only difference I can think of is that I am not using Lion?
23:44:38 <applicative> I'm wrong I don't have any but the house llvm.
23:44:43 <blackdog> fuchsto: this may not be optimal, but you could replay that with (Data.Array.IArray listArray (lo,hi) indices) and use ! rather than !!
23:44:48 <blackdog> *replace
23:45:05 <crutcher> is there a build farm used before pushing out a release?
23:45:21 <blackdog> fuchsto: i assume you've built with profiling and verified that this is your bottleneck?:)
23:45:42 <fuchsto> blackdog: Not with profiling, but i verified it, yes
23:45:44 <fmap> LK4D4: because `many anyChar' never fails
23:46:17 <LK4D4> oh, what i should use instead?
23:46:37 <fuchsto> blackdog: Rendering them using   mapM (\v -> renderVertex v) vertices is fine, rendering in the correct order using !! almost freezes
23:46:59 <blackdog> yeah, fair enough. try with listArray.
23:47:09 <fuchsto> blackdog: I was about to use Data.Array. What's the difference to IArray?
23:47:32 <crutcher> omg. I just want matrices in haskell. this is driving me nuts. I can't get anything to install, nor find docs on why it won't
23:48:03 <fuchsto> blackdog: ah, immutable, got it.
23:49:21 <blackdog> fuchsto: i think Data.Array.IArray defines a more general interface. Data.Array is still immutable.
23:49:57 <blackdog> fuchsto: http://www.haskell.org/haskellwiki/Arrays has more gory details than anyone could possibly want.
23:53:28 <fuchsto> blackdog: Ah, thank you. On another note, how can i use if..else in a do-block?
23:53:52 <fuchsto> blackdog:  do; if size > 0 then doFoo else doBar   doesn't seem to work?
23:53:53 <blackdog> fuchsto: nothing special
23:54:06 <blackdog> you're probably missing indentation
23:54:18 <applicative> do {if True then print 1 else return ()}
23:55:14 <fuchsto> blackdog: GHC tells me i 'perhaps meant to use -XDoAndIfThenElse' O_o
23:56:17 <blackdog> fuchsto: easier if you hpaste your code
23:56:25 <blackdog> it might just be that you don't need the 'do' at all
23:57:39 <applicative> crutcher: does -fllvm work if you compile say main = putChar 'a'?  I'm wondering whats up with the llvm bit
23:59:01 <crutcher> applicative: yup, same blowup
23:59:09 <applicative> crutcher: in the .cabal file all of the examples are compiled with -fllvm
23:59:30 <applicative> this has to do with the ghc install, it is prior to the dph nonsense
23:59:45 <applicative> you used the regular haskell platform installer?
