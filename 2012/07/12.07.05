00:00:50 <gatlin> shachaf: I'm going to ask in both places. Since C works, I know I have emscripten and such working correctly. It might still be their issue though
00:02:37 <favonia> fryguybob: the mailing list is also down...
00:03:04 <shachaf> Oh. Well, good to know that C works! :-)
00:04:34 <gatlin> :-) #haskell's good humor is why I keep coming back
00:09:20 <yitz> preflex: xseen rwbarton
00:09:20 <preflex>  rwbarton was last seen on freenode/#haskell 9 hours, 8 minutes and 31 seconds ago, saying: well i didn't think this was a serious suggestion because... Haskell is sort of known for the fact that it rejects many programs?
00:17:20 <startling> @hoogle Fractional a => a -> Integer
00:17:21 <lambdabot> Prelude floatRadix :: RealFloat a => a -> Integer
00:17:21 <lambdabot> Prelude toInteger :: Integral a => a -> Integer
00:17:21 <lambdabot> Prelude recip :: Fractional a => a -> a
00:21:15 <optimight> hello
00:21:46 <aleator_> Just a quick idea. Would it be feasible to use __cxa_demangle in c2hs to automagically create wrappers for c++ calls (using gcc)?
00:22:18 <aleator_> or rather hsc2hs=
00:22:29 <lillis> optimight: hello
00:22:30 <shachaf> Sounds like somehow something will go terribly wrong.
00:23:15 * aleator_ is not happy that opencv 2.4 doesn't come with a plain c interface.
00:23:30 <lillis> I'm having irritating problems setting up a ghci conf file, and it seems to stem from the fact that my windows user name has international letters in it. Are there any guides/tutorials/threads regarding this?
00:23:40 <optimight> lillis: thanks for responding ...      Actually, I was struggling to get my nick optimight from optimight_
00:24:05 <lillis> Could I just point the ghci to use some other conf file instead?
00:24:22 <lillis> optimight: ah :)
00:26:50 <optimight> I am waiting for www.haskell.org to become working
00:27:44 <buulj> At about what programming skill level is writing a resolution theorem prover using superposition calculus?
00:28:59 <lillis> buulj: americans are sleeping, europeans just got to work..
00:29:08 <lillis> hence: *tumbleweed*
00:30:07 <startling> lillis: not yet!
00:30:13 <startling> (sleeping, I mean)
00:30:13 * hackagebot free 2.2 - Monads for free  http://hackage.haskell.org/package/free-2.2 (EdwardKmett)
00:30:15 * hackagebot keys 2.2 - Keyed functors and containers  http://hackage.haskell.org/package/keys-2.2 (EdwardKmett)
00:31:55 <dmwit> buulj: I'd say medium-rare to rare.
00:33:31 <buulj> dmwit: I'm... not sure what that means in the context of programming
00:33:56 <buulj> Programming is just like meat!
00:33:58 <buulj> wait no it isn't
00:34:54 <lillis> Well done (beginner) -> medium -> medium-rare -> rare (expert)
00:35:17 * hackagebot representable-functors 2.5 - Representable functors  http://hackage.haskell.org/package/representable-functors-2.5 (EdwardKmett)
00:35:19 * hackagebot adjunctions 2.5 - Adjunctions  http://hackage.haskell.org/package/adjunctions-2.5 (EdwardKmett)
00:35:22 * hackagebot kan-extensions 2.7 - Kan extensions, the Yoneda lemma, and (co)density (co)monads  http://hackage.haskell.org/package/kan-extensions-2.7 (EdwardKmett)
00:35:24 * hackagebot representable-tries 2.5 - Tries from representations of polynomial functors  http://hackage.haskell.org/package/representable-tries-2.5 (EdwardKmett)
00:35:35 <buulj> lillis: thanks
00:35:54 <shachaf> edwardk: What happen?
00:36:03 <tim-m89> Promming is like meat? In that you sometimes have to beat it?
00:36:04 <lillis> shachaf: we get signal?
00:36:25 <edwardk> shachaf: nothing big. this batch is me switching to van laarhoven lenses to reduce dependencies
00:36:29 <lillis> tim-m89: It's bloody, tasty and if you manage to make something yummy out of it, you feel really satisfied.
00:36:36 <edwardk> the next wave will be me switching to the simplified Comonad class
00:37:00 <edwardk> that'll probaby bump most to 3.0
00:37:05 <shachaf> Ah.
00:37:11 <shachaf> What's the simplified Comonad class?
00:39:12 <bcw> lillis, all your haskell.org server are belong to us :>
00:39:21 <yitz> lillis: sounds like you're getting ready to write a monad tutorial
00:39:23 <edwardk> removing Extend as a superclass, and making an explicit ComonadApply rather than use Apply with implied laws about it being a strong lax symmetric semimonoidal comonad
00:39:39 <edwardk> this moves Extend into semigroupoids
00:40:10 <edwardk> its the 'simplified' branch in github.com/ekmett/comonad
00:40:10 <lleksah> hey guys, haskell.org is down today?
00:40:16 <edwardk> lleksah: apparently
00:40:44 <lleksah> edwardk: any news regarding this or it is just random downtime?
00:40:55 <edwardk> i haven't heard anything. i just saw it mentioned
00:41:04 <lleksah> ok, thanks
00:42:34 <bcw> lleksah, not really sure where to look for this kind of news, but there was nothing on google news.
00:43:36 <bcw> but it's been down for at least 7 hours now (that i know of)
00:44:20 <MostAwesomeDude> At least 12 from my view.
00:45:15 * hackagebot vector-instances 2.1 - Orphan Instances for 'Data.Vector'  http://hackage.haskell.org/package/vector-instances-2.1 (EdwardKmett)
00:45:39 <ion> This added example is very helpful. https://github.com/ekmett/comonad/commit/fe0775aba24a1895579866dc604fd36a5ed9e75e
00:47:06 <edwardk> hah, https://github.com/ekmett/comonad/blob/master/examples/History.hs wasn't there in one of the branches
00:47:38 <edwardk> when i shuffled things around the merged commit was rather boring ;)
00:48:45 <ion> I’d just have removed the commit with rebase -i, or changed the message to something like “tweak whitespace”. :-)
00:49:32 <Veinor> <3 rebase -i
00:50:18 * hackagebot recursion-schemes 2.1 - Generalized bananas, lenses and barbed wire  http://hackage.haskell.org/package/recursion-schemes-2.1 (EdwardKmett)
00:50:19 * hackagebot comonad 3.0 - Haskell 98 compatible comonads  http://hackage.haskell.org/package/comonad-3.0 (EdwardKmett)
00:50:22 <Veinor> it always reminds me of the ducktales theme: "You might solve a mystery... or rewrite history!"
00:53:34 <raichoo> rebase uhuuuuuhu
00:57:20 <edwardk> ion: i suck at git ;)
00:58:11 <edwardk> my overwhelming concern is to not lose a useful commit, so i tend to not get fancy with rebasing ;)
01:00:59 <ion> You can always undo. :-)
01:01:13 <shachaf> edwardk: Do you know about git reflog?
01:01:32 <ion> But anyway, with rebase -i, if the line corresponding to the commit is still there the commit won’t be deleted.
01:01:45 <edwardk> not offhand, i'm pretty pathetic when it comes to git ;)
01:02:04 <shachaf> git reflog is a log of all the previous states your repository was in.
01:02:10 <edwardk> ah
01:02:17 <shachaf> So pretty much no matter what you do, you can always go to the reflog and get your old state back.
01:02:30 <shachaf> (Unless it's something that was never committed at all.)
01:02:31 <edwardk> this might go a long way towards making me less gunshy with git
01:03:11 <shachaf> Old states get GCed after something like 90 days.
01:03:11 <edwardk> i've just blown away lots of useful code and spent hours recommitting and rewriting stuff in the past, so i've been sticking to very stylized ways of interacting with git since
01:03:16 <raichoo> edwardk: what's your main VCS then? darcs?
01:03:42 <edwardk> raichoo: it was for a while. i was pretty good with darcs
01:03:57 <edwardk> go far enough back and it was just a series of tarballs ;)
01:04:01 <shachaf> Main VCS: $ cd ..; cp -a free-2.1.1.1 free-2.2; cd free-2.2
01:04:37 <shachaf> edwardk: git is just a big purely functional data structure. Nothing to be afraid of. :-)
01:04:38 <edwardk> switched from that to rcs, cvs, subversion, then darcs, and finally git (and hg when forced)
01:04:40 <raichoo> Next level: ZFS or HAMMERfs :D
01:05:05 <edwardk> the main reason i left darcs was because of github
01:05:15 <alnix> No information for haskell.org?
01:05:24 <edwardk> a.) it doesn't eat repos and b.) i get about 10x the number of user supplied patches
01:05:37 <raichoo> edwardk: darcsden does not cut it?
01:06:06 <shachaf> alnix: Given that Galois people are in the US, probably nothing in the next 12 hours.
01:07:01 <alnix> ok
01:07:02 <edwardk> nope. it was just starting when i defected from patchtag, and github has a pretty solid feature set with the ability to see the whole 'network' of your project, with cross-repository browsing. those things make life a lot easier
01:07:04 <raichoo> haskell.org has been down for approx 12 hours now… or did it come back temporary
01:08:08 <alnix> There is no mirroring ?
01:08:23 <edwardk> alnix: nope
01:15:18 * hackagebot semigroupoids 3.0 - Haskell 98 semigroupoids: Category sans id  http://hackage.haskell.org/package/semigroupoids-3.0 (EdwardKmett)
01:17:53 <hpaste> lillis pasted “filtersplit” at http://hpaste.org/70923
01:18:03 <lillis> I think there's a built in function like this - what is it called?
01:19:05 <lillis> (if one such function actually exists)
01:21:24 <merijn> lillis: I remember something similar yes, did you try browsing the functions in Data.List?
01:21:46 <lillis> merijn: I'm still in a very early stage of finding my way around the std libraries
01:21:50 <fmap> > partition (>5) [1..10]
01:21:51 <lambdabot>   ([6,7,8,9,10],[1,2,3,4,5])
01:21:58 <lillis> so far i feel like its easier to just make up the functions on my own
01:22:02 <lillis> which says a lot about haskell :)))
01:22:11 <lillis> fmap: ah, thanks!
01:24:07 <startling> > toInteger (255 :: Word8)
01:24:09 <lambdabot>   255
01:24:15 <t7> why is haskell.org down?
01:25:28 <osfameron> because Haskell isn't web scale!
01:25:29 * osfameron ducks
01:25:47 <t7> should have used node.js
01:25:59 <lillis> and ravendb
01:26:01 <raichoo> Doesn't haskell.org run on PHP? :/
01:26:05 <osfameron> yeah, all those rockstar programmers can't be wrong
01:27:02 <startling> what's the operator that divides to Ints into a fractional or whatever?
01:27:30 <merijn> :t (/)
01:27:31 <lambdabot> forall a. (Fractional a) => a -> a -> a
01:27:56 <bcw> startling, do you mean properFraction?
01:28:03 <merijn> Oh wait, no
01:28:13 <bcw> :t properFraction
01:28:14 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> (b, a)
01:28:16 <merijn> You probably want fromIntegral sprinkled through your code
01:28:26 <bcw> oops
01:28:39 <merijn> @quote fromIntegral
01:28:39 <lambdabot> monochrom says: You've got an Int / But you want Double / Who do you call? / "fromIntegral!"
01:28:44 <danr> > 4 % 2 -- is this what you need?
01:28:45 <lambdabot>   2 % 1
01:28:51 <merijn> :t (%)
01:28:52 <lambdabot> forall a. (Integral a) => a -> a -> Ratio a
01:29:52 <lillis> "forall a." <- this is just math syntax that's been adopted by lambdabot right?
01:30:01 <lillis> i.e. its implied when im writing an actual function definition
01:30:13 <merijn> lillis: No, it is haskell, but in "normal" haskell it's implied
01:30:20 * hackagebot comonad-transformers 3.0 - Comonad transformers  http://hackage.haskell.org/package/comonad-transformers-3.0 (EdwardKmett)
01:30:32 <merijn> [a] == forall a. [a]
01:30:45 <merijn> Which is not the same as [forall a. a]
01:31:18 <bgamari> Why is it that all of the functions in http://hackage.haskell.org/packages/archive/unix/2.5.1.1/doc/html/System-Posix-IO-ByteString.html still appear to use plain old Strings?
01:31:29 <bgamari> Surely this is a bug, yes?
01:36:51 <merijn> hmm
01:37:32 <merijn> I'm trying to install BerkeleyDB bindings on OSX, but they fail due to a missing C library db, but I have 3 installed implementations of bdb...
01:38:03 <merijn> (At least one of which is supported by BerkeleyDB according to the cabal file)
01:38:27 <startling> has anyone written an rgb -> xterm color thing in haskell?
01:38:48 <solrize> preflex: xseen dons
01:38:49 <preflex>  dons was last seen on freenode/#ghc 15 hours, 20 minutes and 30 seconds ago, saying: i don't recall a time that the hetzner's been down before
01:40:21 * hackagebot comonads-fd 3.0 - Comonad transformers using functional dependencies  http://hackage.haskell.org/package/comonads-fd-3.0 (EdwardKmett)
01:44:30 <startling> @hoogle Fractional a => a -> Integer
01:44:31 <lambdabot> Prelude floatRadix :: RealFloat a => a -> Integer
01:44:31 <lambdabot> Prelude toInteger :: Integral a => a -> Integer
01:44:31 <lambdabot> Prelude recip :: Fractional a => a -> a
01:45:52 <Penetrator> hmmm... how to patern match a type that encapsulates a function? eg.  newtype State s a = State (s -> (a,s))
01:46:15 <Botje> (State f)
01:46:28 <Penetrator> and f is a function?
01:46:35 <Botje> yes
01:47:06 <Penetrator> ah... so I can then use (f x) in a pattern
01:47:11 <Penetrator> thanks!
01:47:20 <solrize> um Penetrator what are you trying to do?
01:47:34 <solrize> (f x) doesn't have a data constructor you can match on
01:47:39 <solrize> State is a data constructor
01:47:42 <solrize> in that example
01:47:51 <solrize> (and also a type constructor)
01:47:57 <Penetrator> solarize: i want implement fmap for State s a
01:48:23 <solrize> um i don't think State is a functor
01:48:26 <ski> @instances-importing Control.Monad.State Functor
01:48:26 <lambdabot> ((,) a), ((->) r), ContT r m, Either a, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, ST s, StateT s m, WriterT w m, []
01:48:47 <ski> `State s' is `StateT s Identity', so it's already in `Functor'
01:49:00 <ski> (unless you're defining your own `State', i.e.)
01:49:26 <solrize> hmm you're right
01:49:30 <solrize> now i gotta wonder what the fmap does?
01:49:52 <edwardk> ski: i presume he meant for his hand-rolled State type
01:49:54 <solrize> act on the state value to make a new state?
01:50:07 <Nereid> solrize: monads are always functors
01:50:11 <solrize> yeah, Penetrator you want a functor instance if you're writing an fmap
01:50:13 <edwardk> solrize: State is a functor
01:50:13 <ski> (of course it's `instance Functor m => Functor (StateT s m)' .. the above didn't show the constraint `Functor m', but we already know `Functor Identity' so it works out anyway)
01:50:22 <Nereid> if you know the monad operations, you know fmap
01:50:22 * hackagebot egison 2.1.10 - An Interpreter for the Programming Language Egison  http://hackage.haskell.org/package/egison-2.1.10 (SatoshiEgi)
01:50:24 * hackagebot comonad-extras 3.0 - Comonad transformers requiring extensions to Haskell 98  http://hackage.haskell.org/package/comonad-extras-3.0 (EdwardKmett)
01:50:25 <solrize> nereid yes of course, hmm
01:50:30 <solrize> i'm sleepy
01:50:42 <Penetrator> Solarize: its exercisee 19 of  " 20 intermediate haskel problems".. I dont want the answer, just dont know how to begin
01:51:05 <solrize> Penetrator, ok, do you know that all monads are functors?   (something i forgot til a minute ago...)
01:51:11 <ski> edwardk : hm, yea realized that too late
01:51:48 <osa1> is haskell documentation still down or am I having a connection problem?
01:51:57 <ski> (all monads are functors, but unfortunately in Haskell (due to hysterical raisins), not all `Monad's are actually declared as `Functor's)
01:52:01 <merijn> osa1: haskell.org is down, I believe
01:52:05 <edwardk> osa1: haskell.org is down, hackage.haskell.org is still up
01:52:21 <oscarvarto> haskell.org is down
01:52:40 <t7> :(
01:53:21 <osa1> wow. it was down about 10 hours ago. I was hoping to look at some standard library documentations. do we have another resources for that?
01:53:55 <merijn> osa1: Which platform? I know windows and OSX install the docs by default
01:54:00 <ski> merijn : "[a] == forall a. [a]" -- i'd rather say that `foo :: [a]' is the same as `foo :: forall a. [a]' (unless you have `ScopedTypeVariables' with `a' in scope, or `a' is a class parameter and you're writing a signature inside the class)
01:54:07 <osa1> merijn: linux
01:54:27 <merijn> osa1: Then it depends on the way you installed and which linux, I guess.
01:55:05 <fmap> osa1: if hackage is up then documentations should be up too
01:55:05 <edwardk> osa1: guessing its because the galois folks are all out for the 4th of july
01:55:21 <Penetrator> solrize:  yeah, I know they are functors, I just didnt want to implement >>= and return first :P
01:55:23 * hackagebot free 3.0 - Monads for free  http://hackage.haskell.org/package/free-3.0 (EdwardKmett)
01:55:25 * hackagebot keys 3.0 - Keyed functors and containers  http://hackage.haskell.org/package/keys-3.0 (EdwardKmett)
01:55:54 <solrize> Penetrator, do you know how >>= and return work for the regular state monad?  i guess the exercise is to figure that out
01:55:56 <osa1> fmap: this looks down http://www.haskell.org/ghc/docs/latest/html/libraries/
01:56:37 <solrize> do you know how liftM works?
01:57:10 <osa1> edwardk: what happened at 4th july ?
01:57:24 <edwardk> osa1: american holiday, independence day
01:57:58 <solrize> "Today, on July 4, Europe celebrates a day of independence from American special interests."  (someone writing about ACTA defeat in EU parliament)
01:58:24 <mjrosenb> edwardk: you mean the rest of the world doesn't celebrate today with  tons of fireworks?
01:58:41 <edwardk> mjrosenb: =)
01:59:45 <Penetrator> solrize: i have an idea... but see, >>= and return are exercise 20, which implies i can define fmap for a handrolled state monad with using them
02:00:19 <Penetrator> solrize: er without using them
02:00:19 <lleksah> osa1: http://press.web.cern.ch/press/PressReleases/Releases2012/PR17.12E.html
02:00:23 * hackagebot pointed 3.0 - Haskell 98 pointed and copointed data  http://hackage.haskell.org/package/pointed-3.0 (EdwardKmett)
02:00:24 <solrize> ok do you know how to -use- State, i.e. with get and put?
02:00:47 <edwardk> solrize: he can figure out fmap without any of those things. in fact its a lot easier if he doesn't think about those yet =)
02:01:31 <edwardk> he just needs to figure out how to get 'in' to the 'a' in the function inside State to change it to a 'b'
02:03:22 <solrize> hmm ok
02:03:49 <solrize> i better zzz i'm not thinking clearly...  nite all
02:03:49 <Penetrator> edwardk:  yeah... i kinda thought i'd pattern match with a lamdba in the pattern, but you cant do that it seems :P
02:03:58 <edwardk> Penetrator; I'll give you a tip
02:04:08 <edwardk> fmap f (State g) = State $ \s -> ...
02:04:26 <edwardk> you need to go something with f and g inside the ...
02:04:48 <Penetrator> edwardk: yeah I kinda figured that out from solrize's first answer!
02:04:53 <edwardk> fair nuff =)
02:05:28 <edwardk> then the next tip wouldbe that to get at the pair that contains the 'a' you 'll need to apply 'g s' and do something with the answer
02:06:02 <Penetrator> i was wondering what to do with the g
02:06:02 <edwardk> fmap f (State g) = State $ \s -> case g s of …        - or fmap f (State g) = State $ \s -> let … = g s in ...
02:06:14 <Penetrator> dont spoil it for me!
02:06:23 <edwardk> you still have work to do after that =)
02:06:30 <Penetrator> but I had though of using case
02:06:54 <edwardk> and if you get one of those to work you can also try the other to make sure you can see the equivalence
02:07:32 <Penetrator> thanks!.  The left hand side of the equals had me stumped
02:07:55 <startling> what stringish data type should I use for making one out of a two-dimensional array?
02:07:57 <edwardk> as an aside
02:08:00 <edwardk> you can use
02:08:06 <startling> basically I want cheap concatenating
02:08:10 <edwardk> newtype State s a = State { runState :: s -> (a, s) }
02:08:17 <edwardk> and then you could have used
02:08:30 <edwardk> fmap f m = State $ \s -> case runState m s of ...
02:08:31 <Nereid> startling: difference lists are good for cheap concatenating
02:08:47 <Penetrator> edwardk: Aha!!! yes
02:09:07 <edwardk> Penetrator: that will be really useful later when you go to play with the monad for State
02:09:26 <Penetrator> edwardk: I had thought of runState before, but I didnt know how to use it... until the case
02:10:24 * hackagebot reducers 3.0 - Semigroups, specialized containers and a general map/reduce framework  http://hackage.haskell.org/package/reducers-3.0 (EdwardKmett)
02:15:25 * hackagebot compressed 3.0 - Compressed containers and reducers  http://hackage.haskell.org/package/compressed-3.0 (EdwardKmett)
02:16:20 <Penetrator> edwardk:  Got it!  I never would have figured it out on my own, as I was kinda of unfamiliar with the "case" construct
02:16:29 <Penetrator> so thannks
02:16:43 <edwardk> Penetrator: no problem. i kind of figured that would be a stumbling block
02:17:03 <edwardk> you can rewrite it from a case to a let as well
02:17:15 <Penetrator> i'll try that
02:20:26 * hackagebot charset 0.3.2.1 - Fast unicode character sets based on complemented PATRICIA tries  http://hackage.haskell.org/package/charset-0.3.2.1 (EdwardKmett)
02:25:26 * hackagebot either 3.0 - Haskell 98 either monad transformer  http://hackage.haskell.org/package/either-3.0 (EdwardKmett)
02:25:28 * hackagebot vector-instances 3.0 - Orphan Instances for 'Data.Vector'  http://hackage.haskell.org/package/vector-instances-3.0 (EdwardKmett)
02:26:50 <edsko> is there any way to have quotes in haddock docs?
02:26:51 <Penetrator> edwark:  I've got it working three ways now: "fmap f m = State $ \s -> case runState m s of ..." , "fmap f m =  let (s, x) = runState m s in ...",   and "fmap f (State g) = let (s,x) = g s in..."
02:27:01 <edwardk> watch out
02:27:10 <edwardk> let (s,x) = runState m s in -- is dangerous ;)
02:27:17 <edwardk> that 's' isn't the one you get from the lambda!
02:27:24 <Penetrator> yes well I can see there's 2 s's
02:27:27 <edwardk> the one from the let binds more tightly
02:27:38 <dmwit> That's a subtle bug.
02:27:40 <edwardk> so you need to give one a different name or you'll create an infinite loop
02:27:43 <Penetrator> perphaps i shall call it s'
02:27:45 <edwardk> yeah
02:28:00 <dmwit> (Possibly a terminating infinite loop, depending on what the State computation does, exactly.)
02:28:15 <edwardk> when you call it s' you'll see you need to do that inside the lambda
02:28:29 <Penetrator> yes
02:28:56 <edwardk> when you get around to programming the actual state monad you'll find there is an obvious way and a 'backwards' way to plumb the states through that as well
02:29:10 <edwardk> the backwards state monad has some interesting properties
02:30:49 <dmwit> Which should I learn first, the backwards state monad or the Cont monad?
02:32:53 <edwardk> cont
02:32:57 <ski> dmwit : i'd say `Cont o', since i think it's probably more useful to know
02:34:04 <ski> dmwit : of course, you should also learn about CPS and tail calls
02:34:37 <ski> knowing `call-with-current-continuation' / `callCC' in Scheme / SML/NJ is a bonus
02:35:23 <edwardk> @djinn Functor g => ((c -> g d) -> a -> g b) -> ((e -> c) -> g (e -> d)) -> (e -> a) -> g (e -> b)
02:35:24 <lambdabot> Error: Class not found: Functor
02:35:28 <edwardk> er duh
02:35:51 <ski> (and if you want to know more, also look up "delimited/composable continuations" : `shift' and `reset' in Scheme -- also the papers "Representing Monads" and "Representing Layered Monads" by Andrzej Filinski relates composable continuations to monads)
02:36:08 <edwardk> someone want to take a whack at that?
02:36:09 <ski> @djinn-add class Functor f where fmap :: (a -> b) -> (f a -> f b)
02:36:26 <edwardk> is djinn smart enough to actually use that?
02:36:34 <edwardk> @djinn Functor g => ((c -> g d) -> a -> g b) -> ((e -> c) -> g (e -> d)) -> (e -> a) -> g (e -> b)
02:36:35 <lambdabot> -- f cannot be realized.
02:36:53 <sipa> djinn doesnt know functor, afaik
02:36:54 <edwardk> i didn't think djinn would actually use classes to speak of
02:37:19 <edwardk> i don't have agda installed or i'd whip through that
02:38:16 <edwardk> that should be the basic version of lifting a lens into a representable functor
02:38:19 <ski> @djinn Functor f => (a -> b) -> (f a -> f b)
02:38:19 <lambdabot> f = fmap
02:38:26 <ski> @djinn Functor f => (b -> a) -> (f b -> f a)
02:38:26 <lambdabot> -- f cannot be realized.
02:38:33 <edwardk> nice
02:38:36 <Nereid> lol
02:38:39 <sipa> haha
02:38:50 <ski> `djinn' is too stupid to understand methods which are polymorphic (except in the class parameters)
02:39:33 <edwardk> hrmm maybe this can't be defined
02:39:40 <edwardk> (not with djinn, but in general)
02:39:44 <ski> (it basically amounts to `PolymorpicComponents'm, which is a special case of `Rank2', which it doesn' understand)
02:40:53 <ski> @djinn (Eq a,Eq b) => a -> b -> a -> b -> Bool
02:40:54 <lambdabot> f a b _ c =
02:40:54 <lambdabot>     case a == a of
02:40:54 <lambdabot>     False -> False
02:40:54 <lambdabot>     True -> b == c
02:43:46 <csabahruska> hi
02:48:17 <ski> edwardk : i suspect it's not possible, unless you either know more about `g', or modify the type signature to some higher-ranked monster ..
02:48:28 <edwardk> yeah
02:48:30 <ski> hello csabahruska
02:48:33 <edwardk> i can know more about g
02:49:27 <edwardk> i can make g x = (c, d -> x)  -- using the c and d from that
02:50:18 <edwardk> i have a version for another lens rep, i'm curious a.) if it generalizes to an indexed lens, and b. what the more direct implementation here is
02:50:26 <mel-> hi
02:50:39 <edwardk> i had hoped it worked with an arbitrary g
02:50:47 <edwardk> but oh well
02:53:12 <strager> Nice djinn there...
02:56:21 <lillis> I'm not sure I can grasp the difference between foldl and foldr - in Real World Haskell it seems foldr is given a higher value (as in "more advanced") than foldl. I had assumed that the only difference was the order in which the folding is done (i.e. what side of a list to start from).
02:56:27 <lillis> Am I missing something?
02:57:00 <edwardk> lillis: the direction the folding is done can make a big difference when the list is infinite
02:57:41 <edwardk> if you try to foldl you have to 'get over' an infinite number of ('s to get down to what you're doing), but foldr can make progress regardless
02:58:11 <edwardk> > foldl f z [a,b,c,d,e]
02:58:12 <lambdabot>   f (f (f (f (f z a) b) c) d) e
02:58:16 <lillis> Hmm - the view I have of foldr is one where it couldn't be applied to an infinite list
02:58:24 <edwardk> > foldr f z [a,b,c,d,e]
02:58:25 <lambdabot>   f a (f b (f c (f d (f e z))))
02:58:26 <lillis> because the "last" value of the list is where foldr starts
02:58:33 <edwardk> yes, but remember we're lazy
02:58:43 <edwardk> so if f doesn't use its second argument..
02:59:03 <edwardk> or produces something with it productively then you're fine
02:59:12 <edwardk> > foldr (:) [] [1..]
02:59:13 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
02:59:53 <edwardk> > foldl (flip (:)) [] [1..]
02:59:57 <lambdabot>   mueval-core: Time limit exceeded
03:00:05 <lillis> > foldl (.) [] [1..]
03:00:06 <lambdabot>   Couldn't match expected type `a -> b' against inferred type `[a1]'
03:00:13 <lillis> > foldl (:) [] [1..]
03:00:14 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
03:00:16 <Penetrator> > foldl (swap (:)) [] [1..]
03:00:17 <lambdabot>   Not in scope: `swap'
03:00:26 <Penetrator> > foldl (flip (:)) [] [1..]
03:00:27 <edwardk> thats flip you want
03:00:29 * hackagebot representable-functors 3.0 - Representable functors  http://hackage.haskell.org/package/representable-functors-3.0 (EdwardKmett)
03:00:30 <lambdabot>   mueval-core: Time limit exceeded
03:00:31 <lillis> Okay, i absolutely do *not* get foldr, I'm sure of it now, so thanks... ;)
03:00:31 * hackagebot groupoids 3.0 - Haskell 98 Groupoids  http://hackage.haskell.org/package/groupoids-3.0 (EdwardKmett)
03:00:33 * hackagebot xml-picklers 0.2.2 - XML picklers based on xml-types, ported from hexpat-pickle  http://hackage.haskell.org/package/xml-picklers-0.2.2 (PhilippBalzarek)
03:00:38 <lillis> Will go back and reread
03:00:56 <edwardk> lillis: take a look at the list as a bunch of applications of : and []
03:01:02 <edwardk> 1 : 2 : 3 : 4 : []
03:01:05 <lillis> y
03:01:10 <edwardk> replace the :'s with f and the [] with z
03:01:25 <edwardk> 1 `f` 2 `f` 3 `f` 4 `f` z
03:01:32 * lillis nods
03:01:59 <edwardk> foldr keeps the same parenthesization as the original list
03:02:05 <edwardk> 1 `f` (2 `f` (...
03:02:18 <lillis> so the rightmost value gets evaluated first
03:02:28 <edwardk> 'kinda'
03:02:30 <edwardk> but not really
03:02:34 <edwardk> remember, we only evaluate on demand
03:02:41 <edwardk> so the thing that f produces gets evaluated
03:02:56 <edwardk> so when you look at the outermost constructor of the result it does something
03:02:59 <edwardk> but nothing happens until then
03:03:13 <edwardk> so as long as f is 'productive' foldr f is 'productive'
03:03:46 <edwardk> but foldl craps out on an infinite list regardless of productivity ;)
03:03:46 <Penetrator> that only works for "const" and (:)
03:03:57 <edwardk> no, there are plenty of other productive functions
03:04:10 <Penetrator> foldr const 3 [1..]
03:04:14 <Penetrator> > foldr const 3 [1..]
03:04:15 <lambdabot>   1
03:04:45 <Penetrator> @hoogle a->b->a
03:04:46 <lambdabot> Prelude const :: a -> b -> a
03:04:47 <lambdabot> Data.Function const :: a -> b -> a
03:04:47 <lambdabot> Prelude seq :: a -> b -> b
03:04:59 <edwardk> Penetrator: you can write a lot of them =P
03:05:31 <Philonous> > foldr ((:) . (+1)) [] [1..]
03:05:34 <lambdabot>   [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,2...
03:05:35 <Penetrator> @hoogle a->m a-> m a
03:05:35 <lambdabot> Data.Graph.Inductive.Internal.Queue queuePut :: a -> Queue a -> Queue a
03:05:35 <lambdabot> Text.ParserCombinators.ReadP option :: a -> ReadP a -> ReadP a
03:05:36 <lambdabot> Data.Sequence (<|) :: a -> Seq a -> Seq a
03:05:54 <yitz> preflex: xseen rwbarton
03:05:54 <preflex>  rwbarton was last seen on freenode/#haskell 12 hours, 5 minutes and 6 seconds ago, saying: well i didn't think this was a serious suggestion because... Haskell is sort of known for the fact that it rejects many programs?
03:06:56 <edwardk> > fromJust $ foldr (\a m -> Just a <|> m) Nothing [1..]
03:06:58 <lambdabot>   1
03:07:24 <Philonous> Every "map f" is a productive "foldr"
03:07:27 <edwardk> as an interesting exercise you can write foldl in terms of foldr
03:07:38 <edwardk> but good luck going the other way ;)
03:07:41 <Penetrator> > fromJust $ foldr (\a m -> Just a <|> m) (Just 0) [1..]
03:07:42 <lillis> edwardk: I'm still not 100% sure. But from looking at the parens for foldl and foldr I get that in order to peek into a foldl-folded list I have to evaluate the last value of the list?
03:07:42 <lambdabot>   1
03:07:54 <yitz> @tell rwbarton turns out my attoparsec IsString instance problem was related to GHC no longer generalizing types in where bindings. thanks for your help!
03:07:55 <lambdabot> Consider it noted.
03:08:06 <yitz> preflex: xseen bos
03:08:07 <preflex>  bos was last seen on freenode/#ghc 16 hours, 37 minutes and 14 seconds ago, saying: bah, removing catch from Prelude messes with my code
03:08:18 <ski> > foldr (\n currentSum_to_initialSums currentSum -> let nextSum = currentSum + n in nextSum : currentSum_to_initialSums nextSum) (\currentSum -> []) [2,3,5] 0
03:08:20 <lambdabot>   [2,5,10]
03:08:23 <edwardk> in order to produce a foldl folded infinite list you have to foldl the infinite list that is everything but its last element then do something else
03:08:26 <ski> > foldr (\n currentSum_to_initialSums currentSum -> let nextSum = currentSum + n in nextSum : currentSum_to_initialSums nextSum) (\currentSum -> []) [2,3,5] 0 :: [Expr]
03:08:28 <lambdabot>   [0 + 2,0 + 2 + 3,0 + 2 + 3 + 5]
03:08:41 <ski> > foldr (\n currentSum_to_initialSums currentSum -> let nextSum = currentSum + n in nextSum : currentSum_to_initialSums nextSum) (\currentSum -> error "never reached") [0 ..] 0
03:08:42 <lambdabot>   [0,1,3,6,10,15,21,28,36,45,55,66,78,91,105,120,136,153,171,190,210,231,253,...
03:08:43 <edwardk> notice the infinite recursion before you actually _do_ anything?
03:08:46 <ski> > foldr (\n currentSum_to_initialSums currentSum -> let nextSum = currentSum + n in nextSum : currentSum_to_initialSums nextSum) (\currentSum -> error "never reached") [0 ..] 0 :: [Expr]
03:08:47 <lambdabot>   [0 + 0,0 + 0 + 1,0 + 0 + 1 + 2,0 + 0 + 1 + 2 + 3,0 + 0 + 1 + 2 + 3 + 4,0 + ...
03:08:57 <yitz> @tell bos turns out my attoparsec IsString problem was related to GHC no longer generalizing types in where bindings. thanks for your help!
03:08:58 <lambdabot> Consider it noted.
03:08:58 <ski> lillis : take a look at those ^
03:09:17 <lillis> ski: *cries*
03:10:32 * hackagebot monad-products 3.0 - Haskell 98 monad products  http://hackage.haskell.org/package/monad-products-3.0 (EdwardKmett)
03:11:07 <ski> lillis : the only difference in those, except finite vs. infinite list, is that i replaced the base case `\currentSum -> []' with `\currentSum -> error "never reached"', to show that the base case is never reached, for the infinite list
03:11:28 <ski> lillis : hm, a simpler example is :
03:12:19 <ski> > foldr (++) (error "never reached") (map ((' ' :) . show) [0 ..])
03:12:22 <lambdabot>   " 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27...
03:12:25 <ski> note that
03:12:30 <ski> > map ((' ' :) . show) [0 ..]
03:12:33 <lambdabot>   [" 0"," 1"," 2"," 3"," 4"," 5"," 6"," 7"," 8"," 9"," 10"," 11"," 12"," 13",...
03:13:00 <ski> lillis : that is concatenating all the (finite) lists in an (infinite) list of lists
03:13:13 <lillis> it doesnt evaluate the accumulator?
03:13:36 <ski> there is no accumulator (in the ordinary sense) with `foldr'
03:13:58 <ski> let's trace this a bit
03:14:31 <ski>      foldr (++) (error "never reached") [" 0"," 1"," 2"," 3"," 4",.....]
03:14:49 <ski>   =  (++) " 0" foldr (++) (error "never reached") [" 1"," 2"," 3"," 4",.....]
03:15:02 <ski>   =  " 0" ++ foldr (++) (error "never reached") [" 1"," 2"," 3"," 4",.....]
03:15:16 <ski>   =  ' ' : '0' : foldr (++) (error "never reached") [" 1"," 2"," 3"," 4",.....]
03:15:23 <lillis> with you so far
03:15:33 * hackagebot multipass 0.1 - Folding data with multiple named passes  http://hackage.haskell.org/package/multipass-0.1 (EdwardKmett)
03:15:34 <ski>   =  ' ' : '0' : (++) " 1" (foldr (++) (error "never reached") [" 2"," 3"," 4",.....])
03:15:37 <lillis> but like somebody said above, this wouldnt work on [1..] with (+) as step, right?
03:15:41 <ski>   =  ' ' : '0' : " 1" ++ foldr (++) (error "never reached") [" 2"," 3"," 4",.....]
03:15:46 <lillis> I couldn't get any value back from that without going to the end, could i?
03:15:50 <ski>   =  ' ' : '0' : ' ' : '1' : foldr (++) (error "never reached") [" 2"," 3"," 4",.....]
03:15:59 <edwardk> illisus: correct, but that's not foldr's fault ;)
03:16:03 <ski>   =  ' ' : '0' : ' ' : '1' : (++) " 2" (foldr (++) (error "never reached") [" 3"," 4",.....])
03:16:11 <ski>   =  ' ' : '0' : ' ' : '1' : " 2" ++ foldr (++) (error "never reached") [" 3"," 4",.....]
03:16:19 <edwardk> lillis: with a lazy enough numeric type, it might though
03:16:21 <ski>   =  ' ' : '0' : ' ' : '1' : ' ' : '2' : foldr (++) (error "never reached") [" 3"," 4",.....]
03:16:24 <ski> &c.
03:16:28 <bourbaki> is there any eta when the haskell servers are online again?
03:16:33 <lillis> ski: following and getting
03:16:36 <lillis> so far
03:16:37 <edwardk> data Nat = Z | S Nat  -- can have a (+) that is lazy enough to allow you to use foldr
03:16:52 <edwardk> and get a lazily generated natural
03:16:54 <ski> lillis : now, it only computes as many `someCharacter : ...' as you ask for
03:17:16 <ski> lillis : e.g., say that we had wrapped the whole in `take 5 (...)'
03:17:18 <ski> so
03:17:30 <ski>      take 5 (' ' : '0' : ' ' : '1' : ' ' : '2' : foldr (++) (error "never reached") [" 3"," 4",.....])
03:17:32 <lillis> yeah i just tried take x on it and it worked as i expected
03:17:33 <t7> hmm i cant download the platform until the website is back
03:17:40 <ski>   =  ' ' : take 4 ('0' : ' ' : '1' : ' ' : '2' : foldr (++) (error "never reached") [" 3"," 4",.....])
03:17:43 <t7> anyone know a mirror with windows release?
03:17:47 <ski>   =  ' ' : '0' : take 3 (' ' : '1' : ' ' : '2' : foldr (++) (error "never reached") [" 3"," 4",.....])
03:17:55 <ski>   =  ' ' : '0' : ' ' : take 2 ('1' : ' ' : '2' : foldr (++) (error "never reached") [" 3"," 4",.....])
03:18:04 <ski>   =  ' ' : '0' : ' ' : '1' : take 1 (' ' : '2' : foldr (++) (error "never reached") [" 3"," 4",.....])
03:18:11 <ski>   =  ' ' : '0' : ' ' : '1' : ' ' : take 0 ('2' : foldr (++) (error "never reached") [" 3"," 4",.....])
03:18:17 <ski>   =  ' ' : '0' : ' ' : '1' : ' ' : []
03:18:23 <ski> which is the same as
03:18:36 <ski>   [' ','0',' ','1',' ']
03:18:37 <ski> which is the same as
03:18:41 <ski>   " 0 1 "
03:18:46 <ski> @src take
03:18:46 <lambdabot> take n _      | n <= 0 =  []
03:18:47 <lambdabot> take _ []              =  []
03:18:47 <lambdabot> take n (x:xs)          =  x : take (n-1) xs
03:18:48 <lillis> this is all crystal clear to me
03:19:03 <ski> note that `take 0 as = []', regardless of what `as' is
03:19:23 <ski> so it never gets around to computing the rest of the `foldr ....' part
03:19:41 <ski> because you only ask for some finite number of characters from the string
03:20:07 <lillis> ski: i get what the laziness implies with foldr
03:20:15 <lillis> and i get why it doesnt work with foldl now
03:20:17 <ski> lillis : now, you may note that i above first reduced `foldr' a few steps, then `take' a few steps
03:20:55 <ski> lillis : in practice, these will be interleaved : `foldr' will do one step, then `take' one step, then `foldr' one step again, until `take' reaches `0' and the rest of the `foldr' is forgotten
03:21:06 <ski> lillis : great :)
03:21:52 * ski often finds the above kind of simplistic "hand-tracing" useful for explaining the (more or less) global behaviour of recursive functions ..
03:22:01 <ski> also see
03:22:05 <ski> @where stepeval
03:22:05 <lambdabot> http://www.srcf.ucam.org/~bm380/cgi-bin/stepeval.cgi
03:22:16 <lillis> ski: I think the main problem here is wording that like "foldr folds from the right of a list" makes me think it starts with the last value of the list, whereas foldl starts with the first value
03:22:21 <ski> (doesn't support all libraries)
03:22:31 <lillis> i.e. foldr (+) 0 [1..10] would become 10 + (9 + ...)
03:22:40 <Penetrator> ski:  foldr with infinite lists seems mostly useful for building data structures, not evaluating numbers :P
03:23:00 <ski> lillis : yes, the "from the right" shouldn't be interpreted as computation order, only as "association order", i.e. "which way around you place the parenthesis"
03:23:26 <ski> as in `(((a + b) + c) + d) + e' vs. `a + (b + (c + (d + e)))'
03:23:53 <lillis> aye
03:24:03 <lillis> ski: tack! ;)
03:24:27 <lillis> all this folding has made me hungry, time for lunch.
03:24:47 <lillis> edwardk: thanks for helping
03:24:52 <edwardk> np
03:24:59 <Nereid> foldr f z replaces (:) with f and [] with z
03:25:01 <ski> Penetrator : yes,  foldr  is mostly useful with building large, lazy structures which you might not want to actually evaluate fully, while  foldl  (or  foldl'  ) is better for summarizing a large (but finite) structure down to some "non-lazy" value (like an `Int' e.g.)
03:25:11 <ski> lillis : varsågod :)
03:25:22 <Nereid> foldr (+) 0 [1,2,3] = foldr (+) 0 (1:(2:(3:[]))) = (1+(2+(3+0)))
03:25:55 <Nereid> where was that picture
03:26:03 <ski> > foldr (+) 0 [1,2,3] :: Expr
03:26:04 <lambdabot>   1 + (2 + (3 + 0))
03:26:28 <Philonous> ski:  Might one say, foldl' is good for recursion, foldr for corecursion?
03:26:43 <ciaranm> one might say that
03:27:00 <ciaranm> one might be somewhat mistaken when doing so
03:27:19 <Nereid> oh, it's probably on haskell.org :s
03:33:32 <ski> Nereid : <http://upload.wikimedia.org/wikipedia/en/3/3f/Fold-diagrams.svg>
03:33:44 <Nereid> there they are.
03:34:09 <ski> lillis ^
03:34:45 <ski> (it's made by Cale)
03:35:35 * hackagebot semigroupoid-extras 3.0 - Semigroupoids requiring Haskell extensions  http://hackage.haskell.org/package/semigroupoid-extras-3.0 (EdwardKmett)
03:35:57 <HugoDaniel> semigroupoid
03:36:24 <edwardk> HugoDaniel: its about as weak of a structure as you could ask for ;)
03:36:25 <profmakx> gotta love those
03:36:37 <HugoDaniel> :)
03:36:49 <profmakx> semigroup theory is already full of surprises in every corner
03:37:10 <edwardk> semigroupoids are just categories that don't necessarily have identity arrows
03:37:30 <edwardk> categories then become just the semigroupoids for which the yoneda lemma holds
03:37:31 <profmakx> me coming from groups and thinking "yeah that should work" and then realising every time "no it doesn't"
03:37:50 <profmakx> edwardk is it as as "painless" just adding them as it is in semigroups?
03:38:03 <edwardk> hah, yeah
03:38:39 <edwardk> but you get a lot of the same results you get with semigroups, where lots of things that are unique because of the units, cease to be unique
03:39:02 <edwardk> so there are a lot more semiadjunctions, etc.
03:39:06 <ski> edwardk : next up, semi-moufang-loopoids, please !
03:39:17 <edwardk> ski: find me a practical application ;)
03:39:29 <ski> (hm, i'm not sure if the "semi-" there actually means something ..)
03:39:36 <edwardk> the main reason i added semigroupoids is that they appear _everywhere_ in haskell
03:39:56 <edwardk> and without the new DataKinds you couldn't define an instance of Category for a product category
03:40:02 <edwardk> but you _can_ make it a Semigroupoid
03:40:49 <ski> edwardk : because of type pairs, i take it
03:40:54 <edwardk> yeah
03:41:16 <profmakx> non associativity
03:41:23 <profmakx> floating point comes to mind
03:41:25 <profmakx> at least sortof
03:41:56 <ski> <http://en.wikipedia.org/wiki/Moufang_loop>
03:42:19 <lillis> ski: nice diagram, makes it even clearer
03:42:20 <aleator_> hac
03:43:48 <aib> looks like the cross product 3D vectors
03:45:37 * hackagebot kan-extensions 3.0 - Kan extensions, the Yoneda lemma, and (co)density (co)monads  http://hackage.haskell.org/package/kan-extensions-3.0 (EdwardKmett)
03:45:51 <lillis> ski: so when should foldl be used over foldr?
03:46:13 <lillis> I just read "we will never use foldl in practice" in real world haskell
03:46:14 <edwardk> lillis: in general it shouldn't. if you want a foldl, you _probably_ want a foldl'
03:46:48 <lillis> foldl' being something other than a real foldl?
03:46:50 <edwardk> foldl' (+) 0
03:47:16 <edwardk> can be more strict than the foldr (+) 0
03:47:34 <edwardk> foldl' is foldl 'with strict application'
03:47:44 <ski> <http://www.valdostamuseum.org/hamsmith/loopoids.html#mfloops> might be fun on moufang loops
03:47:48 <fmap> > foldr (+) 0 [1..1000000]
03:47:51 <lambdabot>   *Exception: stack overflow
03:47:52 <fmap> > foldl' (+) 0 [1..1000000]
03:47:54 <lillis> so it doesnt save up the evaluations for later?
03:47:54 <lambdabot>   500000500000
03:47:57 <edwardk> yeah
03:48:33 <SimonJF> Hi all, a question if I may?
03:48:33 <lambdabot> SimonJF: You have 1 new message. '/msg lambdabot @messages' to read it.
03:49:08 <alnix> hey haskell.org is up !
03:49:15 <ppilate> sweet
03:49:54 <SimonJF> I have 2 Maybe values inside a function, and the second one depends on the first being a Just
03:50:02 <lillis> raichoo: you were right, it does run on php...
03:50:29 <SimonJF> best way to handle this without resorting to nested case statements?
03:50:38 * hackagebot profunctors 3.0 - Haskell 98 Profunctors  http://hackage.haskell.org/package/profunctors-3.0 (EdwardKmett)
03:50:40 * hackagebot profunctor-extras 3.0 - Profunctor extras  http://hackage.haskell.org/package/profunctor-extras-3.0 (EdwardKmett)
03:50:53 <lillis> depend as in if a is Nothing then B will always be a Nothing?
03:51:00 <lillis> b*
03:51:18 <ppilate> you can do the usual patter matching, I guess?
03:51:36 <SimonJF> a is a data structure, and b is a field of said data structure
03:51:47 <SimonJF> (but also happens to be a maybe)
03:52:13 <lillis> Shouldn't (Just a (Just b)) work?
03:52:38 <lillis> no, that's stupid, sorry :)
03:52:58 <lillis> basically - pattern match on the data structure not being nothing?
03:53:26 <fmap> SimonJF: sounds like you want (>>=), can you paste the code?
03:53:38 <SimonJF> sure
03:54:31 <SimonJF> one sec, sorry, just tidying it up :P
03:54:48 <lillis> yes, remove all those naughty variable names
03:54:59 <SimonJF> ahaha :P
03:55:38 * hackagebot wl-pprint-extras 3.0 - A free monad based on the Wadler/Leijen pretty printer  http://hackage.haskell.org/package/wl-pprint-extras-3.0 (EdwardKmett)
03:56:41 <hpaste> SimonJF pasted “nested case problem” at http://hpaste.org/70926
03:56:51 <SimonJF> wow, that's pretty cool
03:57:02 <lillis> it's all connected now
03:57:03 <lillis> internet man
03:57:05 <lillis> ;)
03:57:07 <SimonJF> :P
03:58:36 <SimonJF> so anyway, parent_term is Maybe Term, and Term contains termHoles
03:58:44 <Nereid> SimonJF: that pattern begs for use of Maybe as a monad
03:59:09 <SimonJF> right, my guess was Applicative but I wasn't sure how to go about it
03:59:15 <Nereid> or Applicative
04:01:05 <SimonJF> actually, thinking about it, using it as a Monad would make a lot of sense
04:01:18 <hpaste> fmap annotated “nested case problem” with “nested case problem (annotation)” at http://hpaste.org/70926#a70927
04:01:39 <fmap> something like that probably
04:01:54 <jagoons> Hi all... need someone whos got good hack tools....
04:02:03 <SimonJF> that's great, thanks a lot
04:02:26 <lillis> I'm sorry to hijack your question SimonJF, but I'm not sure why this can't be solved with simple pattern matching?
04:02:35 <fmap> i'm not sure how to use applicative here since next computation depend on previous one
04:02:35 <lillis> Note that I'm positively oblivious to some obvious fact here.
04:02:55 <Nereid> lillis: he already has done it with pattern matching.
04:03:25 <lillis> :t (>>=)
04:03:27 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
04:03:58 <SimonJF> I'm currently pattern matching with case statements
04:04:26 <lillis> Sorry, what I meant is: f (Just (Just (id,id2)))  = do { stuff }
04:04:47 <lillis> aren't you just checking for the existence of a maybe inside a maybe?
04:04:50 <Nereid> no
04:05:01 <SimonJF> And I need to extract something from a HashTable inside my State Monad
04:05:38 * lillis slowly edges backwards
04:05:39 * hackagebot wl-pprint-terminfo 3.0 - A color pretty printer with terminfo support  http://hackage.haskell.org/package/wl-pprint-terminfo-3.0 (EdwardKmett)
04:05:41 * hackagebot bifunctors 3.0 - Haskell 98 bifunctors  http://hackage.haskell.org/package/bifunctors-3.0 (EdwardKmett)
04:05:54 <Nereid> lillis: he has some getTerm parent_tid :: Maybe x
04:06:18 <Nereid> and then, given parent_term :: x, he has termHoles parent_term !! hole :: Maybe y
04:06:26 <robstewartuk1> I'm trying to split the entire range of sha1 digests into 4 equal parts. I'm using `sha1' from http://goo.gl/cIUGb to generate Digests. As a digest has an Ord instance, I was hoping to split the 160bit range equally.
04:06:28 <robstewartuk1> is this possible ?
04:06:49 <Nereid> in other words, the function \parent_term' -> termHoles parent_term' !! hole :: x -> Maybe y
04:06:52 <Nereid> look, monads!
04:07:15 * osfameron covers his eyes
04:07:18 <lillis> x -> Maybe y ... im glad i actually reacted to this, makes me realise im already getting indoctrinated
04:07:26 <lillis> as in "that looks like sin!"
04:07:58 <hpaste> Philonous annotated “nested case problem” with “nested case problem (annotation)” at http://hpaste.org/70926#a70928
04:08:18 <Nereid> I probably should have said X and Y instead of x and y.
04:08:54 <lillis> I'll go back to reading and banging head for now
04:09:05 <SimonJF> thanks so much for your help
04:09:26 <Philonous> SimonJF:  Using the Monad only works when the patterns are all in the same monad. If you have e.g. an Either inside a Maybe that pattern breaks down.
04:10:22 <SimonJF> And then I'd have to either write a function to generalise the Either to a Maybe, for example?
04:10:36 <SimonJF> or, alternatively, go back to nested case blocks
04:10:40 <Philonous> SimonJF:  Well, you could. I would use pattern guards.
04:10:59 <mstrlu> Or perhaps use lenses? (not sure)
04:11:07 <Philonous> SimonJF:  As in my annotation to your paste
04:11:43 <SimonJF> Ooh, I'm sorry, I missed that - I'll have a look
04:11:57 <Philonous> SimonJF:  OTOH that's a language extension. So you may or may not want to use that.
04:12:18 <SimonJF> A very useful one at that, by the looks of it!
04:14:19 <Philonous> SimonJF:  You can also add Boolean expressions to the mix. If they evaluate to False the match will fail. Nice for sanity checks etc.
04:15:42 * hackagebot paragon 0.1.23 - Paragon  http://hackage.haskell.org/package/paragon-0.1.23 (NiklasBroberg)
04:15:50 <Philonous> SimonJF:  Err, the pattern in line 5 should of course read "Just (termID, old_ss)", I'm sorry
04:17:43 <SimonJF> That's definitely something to keep in mind
04:18:08 <nand`> why does \x -> x `asTypeOf` id  typecheck but \x -> (x :: a -> a)  errors?
04:22:03 <Botje> random guess: the a is differently scoped than the one in id?
04:23:13 <nand`> hmm
04:23:18 <nand`> this one type checks, with -XRank2Types
04:23:29 <nand`> (\x -> x :: a -> a) :: (forall a. a -> a) -> b -> b
04:23:36 <nand`> I'm guessing that's the issue
04:23:54 <Philonous> nand`:  ghc can't infer rank-N-types
04:23:55 <nand`> the inner ‘a’ being implicitly quantified by the :: a -> a signature
04:24:17 <Philonous> nand`:  And the asTypeOf thing is only rank 1
04:25:43 * hackagebot trifecta 0.53 - A modern parser combinator library with convenient diagnostics  http://hackage.haskell.org/package/trifecta-0.53 (EdwardKmett)
04:25:45 * hackagebot ad 3.0 - Automatic Differentiation  http://hackage.haskell.org/package/ad-3.0 (EdwardKmett)
04:25:49 <nand`> asTypeOf just tries to unify the two types; so writing (`asTypeOf` id) doesn't require the first argument to be polymorphic as well, yes?
04:26:07 <Philonous> nand`:  My understanding is that asTypeOf only ever restricts the type, never generalizes is. So you don't get into trouble there since
04:26:29 <Philonous> since \x -> x is rank 1 to begin with
04:27:13 <nand`> hmm
04:27:43 <Saizan> nand`: are you familiar with System F syntax?
04:27:43 <nand`> Is there any distinction between the rank 2 type :: forall b. (forall a. a -> a) -> b -> b  and the rank 1 type :: forall a. (a -> a) -> a -> a ?
04:27:54 <nand`> Saizan: no
04:28:09 <Philonous> > (\x -> let f = x `asTypeOf` id in (f True, f 'a')) id
04:28:11 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
04:28:11 <lambdabot>         against inferred type ...
04:28:30 <sarfraz> hi, so I have code that compile but doesn't work. I am trying to tls handshake google. Any advice? Here is the code:
04:28:33 <hpaste> sarfraz pasted “tls handshake” at http://hpaste.org/70929
04:28:42 <sarfraz> http://hpaste.org/70929
04:28:59 <Philonous> nand`:  x will be monomorphic once you use it on a value
04:29:19 <edwardk> nand`: if you replace th quantified b in the former with a concrete type b, then yes
04:29:38 <Saizan> x is monomorphic no matter what, unless you add a type annotation
04:29:47 <edwardk> you could apply the function you are passed at multiple different types, while in the latter its monomorphic
04:29:54 <nand`> :t (\x -> let f = x `asTypeOf` id in (f True, f 'a')) :: (forall a. a -> a) -> (Bool, Char)
04:29:56 <lambdabot> (forall a. a -> a) -> (Bool, Char)
04:30:08 <Saizan> the type can be undetermined, but it can't be a polymorphic one
04:30:57 <nand`> edwardk: ah, right
04:31:35 <Saizan> the fun part is that x `asTypeOf` id there is unifying the type of x and id as applied to some type variable
04:31:47 <Saizan> it's not comparing their polymorphic types
04:32:05 <Saizan> but f is still polymorphic because of let generalization
04:33:29 <Saizan> knowing how this stuff desugars to System F is quite handy when you try to understand rank-n types
04:33:32 <nand`> oh, another distinction: I can pass a monomorphic function to the latter type and get a monomorphic function back, while in the former the argument must be polymorphic, and I always get a polymorphic type back
04:34:09 <Peaker> yay, with mmap'd storage, the file-backed key/value store has acceptable performance
04:34:57 <edwardk> Peaker: now all you need is a transaction log so when your editor crashes they don't lose everything ;)
04:35:27 <Peaker> edwardk, heh, I'll probably use a real db for that, much later :) Until it has realistic needs, I just want no dependency hell
04:35:44 <edwardk> *nods*
04:35:59 <Peaker> though I might, for fun, actually make the key/value store worthy :)
04:36:24 <Peaker> an interesting little project, and I couldn't find any file-backed key/value store in Haskell
04:36:59 <edwardk> there might be something built on MACID or something
04:37:08 <Peaker> acid-state/etc require it all to fit in ram or be swapped, which may not work well with large data sets
04:37:31 <Peaker> MACID?
04:37:41 <edwardk> if you can't fit your source file into memory .. ;)
04:37:47 <edwardk> the acid-state stuff
04:37:57 <Peaker> it's not a source file, though, the db is supposed to have the entire eco-system + it's revision control
04:38:03 <edwardk> old name from happs
04:38:07 <edwardk> ah
04:38:42 <Peaker> it would be nice to finally have single-definition-granularity code-sharing
04:40:43 * hackagebot representable-tries 3.0 - Tries from representations of polynomial functors  http://hackage.haskell.org/package/representable-tries-3.0 (EdwardKmett)
04:40:46 * hackagebot keyvaluehash 0.3.0.0 - Pure Haskell key/value store implementation  http://hackage.haskell.org/package/keyvaluehash-0.3.0.0 (EyalLotem)
04:40:47 * hackagebot algebra 3.0 - Constructive abstract algebra  http://hackage.haskell.org/package/algebra-3.0 (EdwardKmett)
04:41:12 <edwardk> yay i can sleep now
04:41:33 <edwardk> everything that was broken by the comonad 3.0 update is fixed
04:41:39 <ion> whee
04:41:55 <edwardk> and now i don't have any data-lens dependencies left
04:42:27 <edwardk> everything uses van laarhoven lenses which means i don't actually have any dependency on a lens library in the code that just supplies the lenses
04:42:43 <ion> nice
04:43:51 <nand`> van laarhoven lenses are awesome, since you can define one mapping operation and you get the getter/setter/modifier for free
04:45:44 * hackagebot paragon 0.1.24 - Paragon  http://hackage.haskell.org/package/paragon-0.1.24 (NiklasBroberg)
04:46:23 <ion> A great package description.
04:46:47 <nand`> ion: I looked at the full description. ‘Paragon suite’
04:47:05 <nand`> oh, it's that thing. I read a paper about it a while ago, I had no idea it was implemented in Haskell
04:47:20 <ion> http://www.paragonsuite.co.uk/
04:47:31 <nand`> I.. don't think that's relevant
04:47:50 <lillis> I just waited for a "... written in Haskell" on that site
04:47:51 <lillis> :C
04:48:25 <nand`> http://www.eurekalert.org/pub_releases/2011-11/uog-npl112211.php
04:48:26 <ion> We are pleased to welcome you to the Paragon Suite, a purpose built Private Patient Unit written in Haskell at Wexham Park Hospital.
04:50:12 <fmap> looks like new level of no documentation
04:50:21 <nand`> let me see if I can dig up the paper
05:02:22 <nand`> fmap: http://nbroberg.se/paragonsida/
05:02:24 <nand`> fmap: yes, it does
05:03:07 <lillis> silly swedes!
05:03:23 <nand`> ion: here's the paper https://gupea.ub.gu.se/handle/2077/26534
05:03:58 <ion> Thanks
05:05:07 <lillis> that's actually a PHD thesis..
05:07:29 <nand`> sorry, I do not know the distinction between these terms
05:08:15 <lillis> me neither to be quite honest, but i know there is one ;)
05:08:38 * lillis comes from a humanities background
05:08:38 <Nereid> one of them is published in a journal
05:08:53 <nand`> I'll just use the word ‘PDF’ to ambiguate
05:09:04 <lillis> what if its in PS format?
05:09:07 <lillis> I say "document"
05:09:11 <lillis> or "information container"
05:09:13 <b52> any idea how to refactor the following
05:09:13 <b52> > until (\(x,y,s) -> x > 4000000 || y > 4000000) (\(x,y,s) -> (x + 2*y, 2*x + 3*y, s + x + y)) (1,1,0)
05:09:13 <Nereid> "article" is fine
05:09:15 <lambdabot>   (5702887,9227465,4613732)
05:09:15 <nand`> lillis: good idea
05:09:16 <lillis> or "bucket of bits"
05:09:25 <nand`> ‘document’ sounds fairly ambiguous
05:09:34 <Nereid> prefer "article"
05:10:40 <Nereid> or "publication"
05:10:49 <lillis> ah - publication! that's a good one
05:10:57 <nand`> but what if it's not public?
05:11:21 <lillis> b52: what do you awnt to refactor?
05:11:28 <lillis> b52: or what do you want to accomplish rather
05:11:36 <b52> are there neater haskell ways to do the same
05:11:37 <nand`> getting rid of points, naturally!
05:11:39 <Nereid> nand`: there's still "article" and "document" ;)
05:11:55 <liyang> PS is a programming language, so I'd say ‘source file’.
05:12:37 <nand`> well, I'm not necessarily referencing the source file. I'm representing the evaluation result it represents
05:12:40 <nand`> I'm referencing*
05:12:41 <Nereid> I would only say "source file" if the PS file was written by hand.
05:12:50 <Nereid> or similar.
05:13:14 <liyang> Don't discriminate against compilers.
05:13:33 <nand`> (which should honestly be distinct from the format in the first place, so my suggestion of PDF was a bad one)
05:14:18 <nand`> From now on I will refer to such things as [Either Text Image]
05:15:32 <Nereid> why not just "file"
05:15:57 <nand`> it could be a printout
05:16:02 <hpaste> lillis pasted “until refactor” at http://hpaste.org/70930
05:16:09 <Nereid> "document" then (・∀・)
05:16:10 <lillis> b52: something like that?
05:16:26 <lillis> b52: not sure what the application is so i made it like a named function but I think you get the point
05:17:21 <hpaste> lillis annotated “until refactor” with “until refactor (annotation)” at http://hpaste.org/70930#a70931
05:17:40 <hpaste> nand` annotated “until refactor” with “until refactor (annotation)” at http://hpaste.org/70930#a70932
05:18:13 <nand`> uh
05:18:14 <jonkri> what does it mean that a channel is unbounded?
05:18:15 <nand`> error in mine
05:18:18 <nand`> should be f (x + ...)
05:18:33 <Nereid> nand`: well, I'm more concerned about whether it would give something that terminates
05:18:51 <Nereid> oh
05:18:52 <Nereid> oh.
05:19:17 <nand`> it does
05:19:21 <nand`> and should be (x,y,s) too
05:19:24 <nand`> in line 2
05:19:26 <Nereid> yes, I misunderstood it.
05:19:30 <Nereid> probably because of the missing f.
05:19:32 <nand`> first haskell code of the day and already two errors :(
05:19:34 * nand` feels bad
05:19:51 <hpaste> nand` annotated “until refactor” with “until refactor (annotation) (annotation)” at http://hpaste.org/70930#a70933
05:19:52 <Nereid> possible solution: never write code
05:19:55 <lillis> nand`: but a clean solution :)=
05:20:14 <nand`> let's just pretend paste #70932 never existed
05:20:36 <nand`> yes, I think it expresses the point most clearly
05:20:41 <nand`> and is the easiest to understand at a quick glance
05:21:00 <Nereid> and doesn't require the reader to think about what "until" is
05:21:05 <nand`> but it's more “primitive” than ‘until’
05:21:18 <lillis> you say that like it's a bad thing.. :)
05:21:23 <nand`> I do
05:21:38 <nand`> because it can be reinventing the wheel
05:21:43 <nand`> when higher order functions exist
05:21:47 <Nereid> the one thing that I find unfortunate is how you reiterate (x,y,z)
05:21:50 <Nereid> er (x,y,s)
05:22:21 <nand`> Nereid: matter of taste, I think it less of a crime to reiterate (x,y,s) than writing, say, t@(x,y,s)
05:22:26 <nand`> since I don't like the way @ looks.
05:22:36 <Nereid> I don't particularly like that either.
05:22:40 <Nereid> oh well.
05:22:52 <nand`> OTOH, I only pattern match once
05:23:06 <nand`> so there's a plus
05:23:24 <lillis> but really the until version i made seems a lot more complex - can your version be generalised though?
05:23:40 <Nereid> oops I stayed up late again.
05:23:41 <bartavelle> t@(MyComplicatedRecord with tons of fields in it)
05:24:01 <nand`> bartavelle: yes, I still do that for large or complex pattern matches
05:24:07 <nand`> especially ones with nested constructors
05:24:11 <bartavelle> oh yes
05:24:21 <mstrlu> nand` tied the test and the generator in together a single function.. that's not as composable as lillis solution, no?
05:24:39 <bartavelle> it only discovered a month ago i could do "blah { field = xxx}" ...
05:24:45 <mstrlu> (sorry about the bad sentence)
05:25:30 <nand`> mstrlu: I'm not sure I understand what you're asking/saying; but if it's about re-using the function, the test/iterator are hidden inside the body of ‘f’ in lillis' version too
05:26:12 <hpaste> fmap annotated “until refactor” with “until refactor (annotation)” at http://hpaste.org/70930#a70934
05:26:37 <nand`> lillis: my version boils down to a simple tail call recursion with one exit condition; which is the exact pattern ‘until’ is a generalization of
05:27:01 <lillis> nand`: you're right, mine isn't really composable either
05:27:01 <nand`> lillis: the problem here is just that the tuple-fu makes the ‘until’ version require explicit pattern matching / lambdas
05:27:09 <fmap> ah, well, not quite correct
05:27:46 <nand`> fmap: I think that's needlessly complex and harder to understand than the version with guards, not worth the line :P
05:27:55 <lillis> i think b52's original question really was about "i dont want to use ugly lambdas" though
05:27:58 <nand`> but a nice way to demonstrate view patterns
05:27:58 <lillis> now that i look at it again
05:28:32 <nand`> you could avoid the “ugly lambdas” with even uglier applicative point-free code :P
05:28:36 <t7> im gonna invent a language with no lambdas
05:28:43 <t7> like stack based
05:28:51 <lillis> named "lambad" ?
05:28:53 <nand`> (||) <$> (>4000000) . fst3 <*> (>40000) . snd3 -- or whatever
05:28:53 <sipa> Forth?
05:29:01 <t7> actually it will be fully stack based with type inference
05:29:31 <nand`> I lost two 0s somewhere
05:30:09 <Peaker> t7, Haskell without lambda? :)
05:30:12 <Nafai> t7: Have you looked at Cat?
05:30:41 <t7> is there a linux distro that uses no gnu stuff? then when rms is like "its called GNU plus linux" i will be like no its called "linux" etc etc
05:30:50 <koala_man> t7: android
05:31:06 <nand`> Is there a generalization of toroids to the fourth dimension? (so that the “surface” is a cyclic three dimensional space)
05:31:21 <bartavelle> t7, do it the other way, say you use X.org/Gnome/KDE/.../GNU Linux
05:31:32 <koala_man> I disagree with stallman. It shouldn't be called GNU+Linux, it should just be called GNU.
05:31:37 <nand`> s/a generalization/an analog/
05:31:43 <koala_man> linux is a marginally small part of it
05:32:05 <nand`> I call my system “Gentoo”, because that's what it is
05:32:35 <t7> i call mine GNU plus windows
05:32:45 <nand`> t7: GnuWin32? MinGW? cygwin?
05:32:53 <t7> mingw
05:32:54 <nand`> Interix?
05:32:56 <nand`> oh
05:33:05 <nand`> s/MinGW/MinGW+MSYS/ rather
05:33:30 <Nafai> t7: Cat is a functional type-inferred concatenative language: http://www.cat-language.com/
05:33:53 <t7> ah i remember this
05:34:02 <t7> i thought the standard lib was a bit silly
05:34:07 <t7> i should write my own :)
05:34:24 <lillis> and insist it's called t7+Cat
05:35:37 <b52> @hoogle (a,b,c) -> c
05:35:38 <lambdabot> Data.Typeable typeOf3 :: Typeable3 t => t a b c -> TypeRep
05:35:38 <lambdabot> Data.Typeable typeOf2Default :: (Typeable3 t, Typeable a) => t a b c -> TypeRep
05:36:13 <tdammers> I call mine 'debian'
05:36:30 <jaxtr> ahh it's a wonderful day
05:36:31 <tdammers> if people want to know more precisely, 'debian wheezy amd64'
05:37:08 <tdammers> interesting side note, there are debian versions without linux in them
05:37:21 <tdammers> (kfreebsd, netbsd, hurd)
05:37:32 <lillis> Hmm. Am I correct in assuming that in general building my own (explicitly) recursive functions usually shouldn't be necessary?
05:37:42 <Botje> quite.
05:37:45 <lillis> With all the built in functions + folds
05:38:04 <Botje> after three years of haskell I find it hard to come up with tail recursive functions as first idea
05:38:24 <Botje> 'oh, this is just fold map zip split and that's an fmap unfoldr'
05:38:46 <tdammers> occasionally I run into situations where just building the recursion explicitly is easier than composing the desired result using folds and maps and whatnot
05:38:58 <bitonic> tdammers: then do it that way
05:39:00 <tdammers> but those situations are very rare
05:39:18 <nand`> How does one pronounce ‘fmap’? f-map as a single word?
05:39:31 <nand`> or as*
05:39:51 <lillis> Botje: "fold map zip split" :))
05:39:51 <tdammers> one example would be in my sheet music processor, where it maps over a stream of events, and under some conditions, combines several events into one
05:40:02 <tdammers> but the rest is left intact
05:42:13 <hpaste> b52 annotated “until refactor” with “until refactor (annotation) (annotation)” at http://hpaste.org/70930#a70935
05:45:01 <lillis> b52: why not euler002 = 4613732 instead? :)
05:45:12 <b52> :x
05:46:04 <lillis> don't you want to be able to feed it the 1 1 0 args?
05:46:24 <b52> nop
05:48:00 <lillis> b52: well then you have defined a (relatively) computationally heavy constant ;)
05:49:01 <nand`> hmm; would it makes sense to add some kind of GHC pragma that can be added to the definition of monomorphic non-function constants that evaluates them fully at compile time?
05:49:01 <b52> its computationally not heavy at all
05:49:20 <nand`> for example euler002; the difference being that this way you keep the generating code in the source
05:49:35 <nand`> so people see what the number represents rather than a “useless” constant
05:49:47 <lillis> b52: pretty sure it's heavier than just "euler002 = 4613732", is what I mean
05:49:54 <b52> yeah
05:50:03 <b52> but i want to illustrate the idea behind the constant
05:51:03 <lillis> ah
05:53:21 <fmap> > let fibs = 0 : 1 : zipWith (+) (tail fibs) fibs in sum $ filter even $ takeWhile (< 4000000) fibs
05:53:22 <lambdabot>   4613732
05:54:39 <nand`> (I imagine my suggestion could also be extended slightly to provide integer/rational-style constants for things that can be inferred to “compatible” types (eg. Integral i => i))
05:54:57 <nand`> so you can have a fixed constant of a polymorphic type that way
05:56:43 <fmap> i like the ability to translate from english to haskell almost directly
05:57:10 <nand`> it can work very elegantly sometimes, yes
05:57:33 <nand`> though ‘$’ and ‘.’ can sometimes be hard to translate (for a non-Haskell programmer)
06:01:03 <Nafai> Peaker: Do you have a screencast or something on how to use bottle?
06:01:57 <sammyk> Hello. I'm using record syntax for the first time. I find it very hard to name my fields. For example, if I have Student and Teacher, both have a name, but they conflict so I end up with studentName and teacherName, but then it looks like I'm doing it wrong somehow, with each field prefixed with the type name. What's the idiomatic approach here?
06:02:29 <bitonic> sammyk: prefix it with the datatype name as you said. that's the only sane way
06:03:06 <sammyk> bitonic: ok, that's a shame though, it feels redundant (the compiler knows which type I'm using) and very verbose
06:03:09 <nand`> you might be able to get away with a “class HasName a where name :: a -> String” but that can be just as ugly
06:03:39 <bitonic> sammyk: the compiler doesn't always know which type you're using
06:03:51 <bitonic> Haskell infers types automatically
06:03:56 <Saizan> sammyk: you could define them in different modules and then use the module system to disambiguate
06:04:22 <sammyk> Sizan: but then I still have to prefix with the module name don't i? or rename them on import
06:04:52 <bitonic> sammyk: yes you have to prefix them with the module name. I personally think that the manual prefixes are much saner
06:04:53 <nand`> prefixing with the module name is the ‘sane’ solution here
06:04:58 <nand`> Teacher.name and Student.name
06:05:01 <Saizan> sammyk: yeah, when you have both in scope
06:05:18 <nand`> but the fields themselves are still named ‘name’ for their respective types, which is good
06:05:23 <Saizan> using the module rather than backing in the prefix seems much cleaner to me
06:05:50 <nand`> note that if the two record constructors are of the same type the same ‘name’ can work for both
06:05:50 <bitonic> nand`, Saizan: it's extremely impractical in my experience. remember that Haskell does not really have recursive modules. What if Theacher has to contain Students, and vice-versa?
06:06:04 <sammyk> well, whatever, as long as I'm not missing an obvious solution i'm happy
06:07:52 <Saizan> bitonic: in that case it wouldn't work
06:08:47 <rwbarton> you can also factor out the common bits of Student and Teacher like data Person a = Person { name :: String, other :: a }; type Student = Person StudentData; type Teacher = Person TeacherData; ...
06:08:47 <lambdabot> rwbarton: You have 1 new message. '/msg lambdabot @messages' to read it.
06:09:05 <bitonic> Saizan: yeah, and since we want to be consistent, I think that the manual prefixes are much better
06:10:04 <Saizan> rwbarton's suggestion + lenses is probably what one should do, actually
06:10:35 <rwbarton> I've never actually tried this but it sounds logical, especially in conjunction with lenses yes
06:11:49 <nand`> rwbarton: reminds me of OOP-style inheritence
06:12:28 <rwbarton> yes, one can imagine Person (Teacher (MathTeacher ...))
06:12:32 <rwbarton> maybe HList-like
06:12:47 <bitonic> the problem it that in the end there's always a case in which prefixing is the only option. And then you've got one prefixed node things are even uglier
06:13:22 <parcs`> data Student; data Teacher; data Person a where Student :: { name :: String } -> Person Student; Teacher :: { name :: String } -> Person Teacher
06:13:25 <nand`> thing is, OOP-style inheritence / abstractions is exactly what type classes are useful for, which is why I'd go with “class Person a where name :: a -> String” again
06:13:33 <parcs`> that's more like inheritance :P
06:13:59 <nand`> (or replace ’name’ by a Van Laarhoven Lens or wahtever)
06:14:16 <tdammers> type classes are similar to implementing OOP interfaces, they are nothing like inheritance
06:15:42 <nand`> as far as I see it the only distinction is where the functions are actually implemented
06:16:16 <hpaste> b52 pasted “cabal install criterion” at http://hpaste.org/70937
06:16:23 <b52> any idea how to get it?
06:18:37 <t7> welcome to cabal :)
06:18:54 <t7> enjoy your package conflicts
06:27:07 <b52> hm
06:28:17 <b52> so what should i do?
06:30:00 <rwbarton> are you using GHC 7.4?
06:30:53 <b52> 7.0.4
06:31:22 <b52> i use haskell platform
06:31:25 <rwbarton> oh
06:31:26 <rwbarton> odd
06:31:28 <HugoDaniel> from now on im going to start all my sentences by "i happen to"
06:31:34 <b52> is it possible to upgrade all installed packages?
06:32:00 <HugoDaniel> i happen to love the (,,,,) operator
06:32:43 <HugoDaniel> i happen to don't know how to properly specify operators that grow, like (,,) (,,,) (,,,,)
06:33:23 <navaati> define "specify" and "grow" :)
06:33:39 <HugoDaniel> i happen to smile: :D
06:34:02 <Botje> (,,) kind of looks like a metroid.
06:34:28 <HugoDaniel> i happen to wonder if there is a metal operator: \,,/
06:34:56 <zomg> HugoDaniel: try the boob operator ((.)(.)) or something along those lines
06:35:00 <navaati> (your metal operator looks more like a saucepan on the fire to me)
06:35:07 <sipa> :t ((.)(.))
06:35:08 <navaati> :t ((.)(.))
06:35:09 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f, Functor f1) => f1 (a -> b) -> f1 (f a -> f b)
06:35:10 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f, Functor f1) => f1 (a -> b) -> f1 (f a -> f b)
06:35:12 <HugoDaniel> ahahah
06:35:16 <navaati> hahaha, great :D
06:35:25 <HugoDaniel> so much awesome
06:35:31 <zomg> It took me a while to make something that used it
06:35:39 <zomg> And I still haven't been able to think of any real reason to use it..
06:35:39 <zomg> :D
06:35:49 <DMcGill> there's a page on haskellwiki about these things
06:35:55 <DMcGill> there's also an owl operator
06:36:03 <zomg> haha what does that look like? :D
06:36:10 <HugoDaniel> how can i setup a haskell.org mirror ?
06:36:11 <DMcGill> :t ((.)$(.))
06:36:13 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => f (a -> b) -> f (f1 a -> f1 b)
06:36:17 <HugoDaniel> yesterday was down
06:36:27 <HugoDaniel> i can setup a mirror here in my univ.
06:36:31 <DMcGill> that's the same as ((.)(.)) actually
06:36:46 <talamon>  net-misc/pavuk
06:36:46 <b52> ah ok my haskell platform isnt up2date
06:36:57 <DMcGill> I do use (.).(.) all the time though
06:36:58 <talamon> http://www.pavuk.org/
06:37:48 <navaati> damn caleskell… real type of boobs is "((.)(.)) :: (a -> b -> c) -> a -> (a1 -> b) -> a1 -> c"
06:38:14 <zomg> navaati: yeah that's what I thought as well
06:38:27 <zomg> why does :t produce that different type signature?
06:38:40 <navaati> (.) = fmap in lambdabot
06:38:49 <zomg> Oh
06:39:43 <navaati> and some other strange things
06:40:00 <Penetrator> > foldr (+) 0 [9,8,7..0] :: Expr
06:40:01 <lambdabot>   <no location info>: parse error on input `..'
06:40:22 <sipa> :t ((.).(.))
06:40:24 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
06:40:27 <Cale> tbh, (.) = fmap makes things like that easier to think about
06:40:28 <lambdabot> Cale: You have 1 new message. '/msg lambdabot @messages' to read it.
06:40:29 <navaati> that can be useful when you're an advanced haskeller, but that are not good when you want to show things to beginners
06:41:36 <deech> In a function such as "a = let x = 2\ y = 2\ in x + y" are x and y shared?
06:41:49 <Botje> no.
06:41:59 <Cale> deech: Shared between what?
06:42:09 <Cale> each other? No.
06:43:39 <deech> Cale: Yes, each other. Is there any reason why they don't? For the simple case with constants I would assume GHC could figure out that they are equivalent.
06:43:58 <Botje> deech: in this case GHC would probably constant-fold.
06:44:07 <Cale> Botje: really?
06:44:24 <Cale> well, perhaps :)
06:46:19 <Cale> yeah, it does actually
06:47:02 <deech> Cale: How did you verify that? Trying to see if I can figure these things out for myself.
06:47:11 <favonia> deech: GHC would probably propagate the contant-fold even further as a = 4
06:47:12 <Cale> -O2 -ddump-simpl
06:47:13 <navaati> constant-fold = compute at build time ?
06:47:18 <Cale> yeah
06:48:14 <Saizan> Cale, Botje, deech: http://www.haskell.org/haskellwiki/GHC:FAQ#Does_GHC_do_common_subexpression_elimination.3F
06:48:31 <dmwit> ...but 2+2 not necessarily = 4...
06:48:50 <Cale> dmwit: Yeah, but on Integer it does
06:49:00 <dmwit> oh, MR
06:49:25 <Saizan> (see the part about opportunistic CSE)
06:49:32 <Cale> also, it's smart enough to specialise in the case that a is polymorphic and you use it on Integer, apparently.
06:52:04 <Cale> (at least, in the same module)
06:57:07 <\rs> is there a library providing popen (man popen) with ByteString as the argument
06:59:08 <Peaker> Nafai, not yet -- we feel we need about 1-2 more months of development to get it where we want it to be before we screencast
06:59:42 <Peaker> Nafai, we want stuff to be properly aligned (it's currently a mess), type-driven development (most structural edits currently don't make any sense w.r.t types), type-based holes/completions
07:01:32 <Peaker> Nafai, I think if you can spare 5-10 minutes, then trial and error should be possible :)
07:01:35 <astry> hi guys
07:01:38 <Peaker> Nafai, (with the legend saying all keys to try out)
07:01:48 <Peaker> hi astry
07:01:48 <astry> what is the function to get a value's type as a string?
07:01:59 <mauke> :t show . typeOf
07:02:00 <lambdabot> forall a. (Typeable a) => a -> String
07:02:01 <astry> thanks
07:02:08 <astry> :t typeOf
07:02:09 <lambdabot> forall a. (Typeable a) => a -> TypeRep
07:02:22 <astry> there was also another thing i forgot.. some function to print in any context
07:02:29 <astry> without using IO
07:02:30 <HugoDaniel> how can i know the 10 most read haskellwiki articles ?
07:02:31 <mauke> :t trace
07:02:32 <lambdabot> Not in scope: `trace'
07:02:35 <astry> hmm
07:02:39 <mauke> @hoogle trace
07:02:39 <lambdabot> Debug.Trace module Debug.Trace
07:02:39 <astry> no, i don't think trace
07:02:39 <lambdabot> Debug.Trace trace :: String -> a -> a
07:02:39 <lambdabot> Debug.Trace traceShow :: Show a => a -> b -> b
07:02:43 <astry> oh righ
07:02:44 <astry> t
07:02:51 <astry> thank you
07:02:56 <astry> @hoogle typeOf
07:02:56 <lambdabot> Data.Typeable typeOf :: Typeable a => a -> TypeRep
07:02:57 <lambdabot> Data.Typeable typeOf1 :: Typeable1 t => t a -> TypeRep
07:02:57 <lambdabot> Data.Typeable typeOf1Default :: (Typeable2 t, Typeable a) => t a b -> TypeRep
07:03:37 <mauke> @let a === b = cast a == Just b
07:03:38 <lambdabot>  Defined.
07:03:53 <barrucadu> :t cast
07:03:55 <lambdabot> forall a b. (Typeable a, Typeable b) => a -> Maybe b
07:04:41 <mauke> > "hi" === ()
07:04:43 <lambdabot>   False
07:05:49 <aristid> > "mauke" === "hi"
07:05:51 <lambdabot>   False
07:05:55 <aristid> > "mauke" === "mauke"
07:05:57 <lambdabot>   True
07:06:24 <aristid> mauke: that conclusively proves that you are yourself and not the string "hi"
07:06:43 <Adeon> this is revolutionary
07:06:45 <coppro> aristid: No it doesn't; Haskell admits bottom.
07:06:55 <navaati1> > "mauke" === "bot"
07:06:58 <lambdabot>   False
07:07:05 <navaati> oh ? strange :p
07:07:22 <aristid> > "mauke" === undefined
07:07:25 <lambdabot>   False
07:07:34 <aristid> heh.
07:08:38 <favonia> HugoDaniel: I think the most effective way to get the support you want is to contact committee@haskell.org :) they are in charge of the servers, policies etc
07:09:44 <mauke> > length (cycle "asdf") === undefined
07:09:47 <lambdabot>   False
07:10:12 <Penetrator> @hoogle fromList
07:10:12 <lambdabot> Data.HashTable fromList :: Eq key => (key -> Int32) -> [(key, val)] -> IO (HashTable key val)
07:10:12 <lambdabot> Data.IntMap fromList :: [(Key, a)] -> IntMap a
07:10:12 <lambdabot> Data.IntSet fromList :: [Int] -> IntSet
07:10:19 <Penetrator> @hoogle fromMap
07:10:20 <lambdabot> No results found
07:10:25 <Penetrator> @hoogle toList
07:10:25 <lambdabot> Data.HashTable toList :: HashTable key val -> IO [(key, val)]
07:10:26 <lambdabot> Data.Foldable toList :: Foldable t => t a -> [a]
07:10:26 <lambdabot> Data.Text.Array toList :: Array -> Int -> Int -> [Word16]
07:10:42 <Penetrator> @hoogle flatten
07:10:42 <lambdabot> Data.Tree flatten :: Tree a -> [a]
07:10:42 <lambdabot> Data.Graph flattenSCC :: SCC vertex -> [vertex]
07:10:42 <lambdabot> Data.Graph flattenSCCs :: [SCC a] -> [a]
07:11:14 <however> Penetrator: lambdabot is also available in private chat
07:11:32 <tomboy64> how do i test whether a [] is empty? xs == null results in a type error :$
07:11:51 <jfischoff> is it code smell to have a type class like: class To a where to :: a -> SomeType?
07:11:58 <Cale> HugoDaniel: perhaps http://www.haskell.org/haskellwiki/Special:Popularpages will answer the question?
07:12:39 <Cale> jfischoff: I don't really see why it would be
07:12:48 <Bynbo7> tomboy64: null:
07:12:55 <Bynbo7> > null [1,2,3]
07:12:55 <however> > null [] -- tomboy64
07:12:57 <lambdabot>   True
07:12:57 <lambdabot>   can't find file: L.hs
07:12:59 <Bynbo7> > null []
07:13:01 <lambdabot>   True
07:13:13 <jfischoff> Cale: cool
07:13:20 <Cale> jfischoff: In a way, Integral is like that.
07:13:26 <tomboy64> ahhh, ok
07:13:27 <however> bynbo7, our demonstration was less convincing than i hoped =)
07:13:28 <favonia> jfischoff: we already have Show a where show :: a -> String
07:13:34 <Cale> and Show, yeah
07:13:41 <Penetrator> however: ah ok, thanks, and sorry for the spam
07:13:42 <jfischoff> ToJSON too
07:13:48 <however> :t null -- tomboy64
07:13:49 <lambdabot> forall a. [a] -> Bool
07:13:57 <Axman6> @hoogle [a] -> Bool
07:13:58 <lambdabot> Prelude null :: [a] -> Bool
07:13:58 <lambdabot> Data.List null :: [a] -> Bool
07:13:59 <lambdabot> Prelude all :: (a -> Bool) -> [a] -> Bool
07:14:42 <jfischoff> Sometimes when I dig deeper I find that its not a -> SomeClass I want, but the function I will ultimately use on SomeClass.
07:15:06 <however> you can ignore the "forall a." part for now. "[a] -> Bool" means it's a function that expects a list of "a"s (i.e. a list of any type) and gives a Bool. calling a function is done by writing the function name (null), a space, and then the argument(s) the function expects
07:15:06 <jfischoff> but I guess it can be valid
07:15:36 <Cale> jfischoff: However, in some cases, it can be more flexible just to do the standard functional programming thing and work directly with functions a -> SomeType
07:15:58 <Cale> It's just in the case where you expect there should only ever be one canonical one.
07:16:15 <jfischoff> Cale: good point
07:16:18 <Cale> (that the typeclass solution makes sense)
07:17:19 <however> jfischoff: maybe i'm misunderstanding, but your class might be better off with the name "From". i think the way you wrote it, a "To Bool" would be an instance that can convert _from_ a Bool into YourType
07:17:55 <jfischoff> however: your right
07:18:08 <jfischoff> err
07:18:14 <Guest29832> you gotta fight
07:18:27 <Guest29832> for your right
07:19:16 <jfischoff> however: toJSON :: a -> Value I think
07:21:19 <however> jfischoff: i'm not familiar with the json libraries ... but seems plausible. takes anything, gives a json Value
07:21:50 <Peaker> you gotta fight for your right toJSON?
07:21:50 <jfischoff> right which what I was doing too, so I think "to" is a better name
07:22:16 <jfischoff> Peaker: no, no, no toJSOOOOOOOOOON!
07:22:19 <maybefbi> How can I implement this trivial Java class in Haskell? http://pastebin.com/FYUBFD5Y I don't think State monad is enough. The class stores a mutable state which gets incrementally improved when updating method is called.
07:22:25 <mauke> The paste FYUBFD5Y has been copied to http://hpaste.org/70938
07:23:32 <mauke> argh, null abuse
07:23:41 <raymank26> hi all. I have some list comprehension http://pastebin.com/ShBtLZBs But can i make a list comprehension where number of vars(i,j,k,l) are equal n(some input number)?
07:23:43 <mauke> The paste ShBtLZBs has been copied to http://hpaste.org/70939
07:24:30 <byorgey> maybefbi: don't think of it as a class.  Implement it as a function taking a list of values and returning a list of moving averages.
07:25:02 <maybefbi> byorgey, so i store old values in a list?
07:25:14 <jfischoff> raymank26: try writing the type for the function first
07:25:36 <mauke> > replicateM 4 [1..10]
07:25:38 <lambdabot>   [[1,1,1,1],[1,1,1,2],[1,1,1,3],[1,1,1,4],[1,1,1,5],[1,1,1,6],[1,1,1,7],[1,1...
07:25:52 <raymank26> wow
07:26:01 <Peaker> a more direct translation is:  newtype ExpMovingAvg = ExpMovingAvg { Double -> (Double, ExpMovingAvg }    and   mkExpMovingAvg :: Double -> ExpMovingAvg
07:26:12 <dmwit> ?faq can i make a list comprehension where number of vars(i,j,k,l) are equal n(some input number)?
07:26:13 <lambdabot> The answer is: Yes! Haskell can do that.
07:26:21 <raymank26> =)
07:26:21 <maybefbi> Peaker, hmm
07:26:26 <dmwit> =)
07:26:43 <raymank26> why replicateM works?
07:26:54 <merijn> :t replicateM
07:26:56 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
07:27:19 <dmwit> Can you say why you don't expect it to work?
07:27:20 <raymank26> replicateM :: Monad m => Int -> m a -> m [a]
07:27:21 <merijn> Because list is a monad? If you specialise the type it becomes: "Int -> [a] -> [[a]]"
07:28:10 <raymank26> hm
07:28:34 <merijn> @src replicateM
07:28:34 <lambdabot> replicateM n x = sequence (replicate n x)
07:28:45 <merijn> @src replicate
07:28:45 <lambdabot> replicate n x = take n (repeat x)
07:29:06 <Nereid> @src sequence
07:29:06 <lambdabot> sequence []     = return []
07:29:07 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
07:29:07 <lambdabot> -- OR: sequence = foldr (liftM2 (:)) (return [])
07:29:37 <favonia> maybefbi: perhaps you can get some inspirations from scanl or scanl1
07:29:48 <maybefbi> favonia, will check it out
07:30:22 <hpaste> Peaker annotated “pastebin.com/FYUBFD5Y” with “pastebin.com/FYUBFD5Y (annotation)” at http://hpaste.org/70938#a70940
07:30:30 <favonia> > scanl (*) 1 [1..7]
07:30:31 <Peaker> maybefbi, ^^
07:30:32 <lambdabot>   [1,1,2,6,24,120,720,5040]
07:31:03 <dmwit> > scanl1 (*) [1..]
07:31:04 <lambdabot>   [1,2,6,24,120,720,5040,40320,362880,3628800,39916800,479001600,6227020800,8...
07:32:23 <favonia> maybefbi: your "average" is actually a binary operator on the new value and the old average, parametrized by "alpha"
07:32:32 <maybefbi> Peaker, wow thanks. It is a bit weird to think like that.
07:32:49 <Peaker> maybefbi, I'm now writing a very direct translating using State, hang on
07:33:04 <maybefbi> favonia, yeah
07:34:52 <maybefbi> Peaker, so I have to keep making new ExpMovingAvg everytime I have a update
07:35:09 <maybefbi> *an update
07:35:18 <Peaker> maybefbi, that basically represents the assignment to the "oldValue" instance variable -- instead of destructive assignment, you just make a new class instance
07:35:31 <maybefbi> Peaker, elegant
07:35:52 <maybefbi> Peaker, hopefully it won't slow things down if I make so many new values of a type
07:36:04 <hpaste> Peaker annotated “pastebin.com/FYUBFD5Y” with “Direct translation to State” at http://hpaste.org/70938#a70941
07:36:25 <Peaker> maybefbi, at first you asked about using State to implement it -- so this uses State
07:36:31 <Peaker> (and I tried to keep it 1-to-1 to the original Java code)
07:36:49 <favonia> maybefbi: here you see that scanl takes the function (*) as that binary operator. you can put some proper binary operator in the place of (*) to get what you want. The initial value sent to scan, or the difference between scan and scan1, has something to do with your null detection.
07:37:17 <however> peaker, maybefbi: that translation is pretty 1-to-1, but comes at the price of being pretty unhaskelly awkward
07:37:18 <raymank26> ok. I understand that replicateM is not a analog of my code sample =(
07:38:10 <Peaker> however, unidiomatic, yeah, and less elegant than possible -- but I think it's important to know that the Java/etc idioms people are familiar with can be relatively easily translated as they are - so a transition can be more gradual
07:38:18 <raymank26> replicateM 4 [1..10] returns 1000, but my code returns 715. Any suggestions?
07:38:41 <mauke> what?
07:38:44 <Peaker> however, also, sometimes these idioms might actually have some advantage, so it is nice to know that they are usable as is in Haskell
07:38:55 <Peaker> > replicateM 4 [1..10]
07:38:57 <lambdabot>   [[1,1,1,1],[1,1,1,2],[1,1,1,3],[1,1,1,4],[1,1,1,5],[1,1,1,6],[1,1,1,7],[1,1...
07:39:14 <Peaker> raymank26, what do you mean it 1000 or 715?
07:39:17 <raymank26> replicateM 2 [1..10]
07:39:19 <Peaker> s/it/by
07:39:25 <mauke> > [(i, j, k, l) | i <- [1..10], j <- [i..10], k <-[j..10], l <- [k..10]]
07:39:26 <lambdabot>   [(1,1,1,1),(1,1,1,2),(1,1,1,3),(1,1,1,4),(1,1,1,5),(1,1,1,6),(1,1,1,7),(1,1...
07:39:31 <mauke> > length [(i, j, k, l) | i <- [1..10], j <- [i..10], k <-[j..10], l <- [k..10]]
07:39:32 <lambdabot>   715
07:39:51 <Peaker> ah
07:40:18 <raymank26> how can i run the code here?)
07:40:29 <merijn> raymank26: Prefix with a >
07:40:36 <merijn> (and a space!)
07:40:37 <raymank26> thank you!
07:40:45 <raymank26> a > [1..10]
07:40:47 <raymank26> hm..
07:40:50 <however> Peaker: right, i agree with everything you say :) just thought that to someone coming from java, it should be pointed out that solution is supposed to feel awkward
07:40:55 <merijn> > [1..10]
07:40:56 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
07:41:02 <maybefbi> favonia, I agree. but it seems like scan* requires non-incremental calculation of the average.
07:41:07 <raymank26> oh
07:41:10 <however> raymank26: lambdabot is also available in private windows
07:41:20 <Peaker> however, I like how even the awkward solution encoded into Haskell as-is is less than half the size :)
07:41:20 <raymank26> ok =)
07:41:34 <Peaker> however, (the mid one replacing the destructive updates)
07:41:44 <raymank26> > lenght $ replicateM 2 [1..10]
07:41:46 <lambdabot>   Not in scope: `lenght'
07:41:55 <raymank26> > length $ replicateM 2 [1..10]
07:41:56 <lambdabot>   100
07:42:18 <raymank26> > length $ [(i,j) | i<- [1..10], j <- [i..10]]
07:42:20 <lambdabot>   55
07:42:21 <favonia> raymank26: check this: http://www.haskell.org/haskellwiki/Lambdabot ">" is a shortcut for "@run"
07:42:29 <raymank26> this is a difference
07:42:35 <maybefbi> Peaker, if I use the State translation, wouldn't I have to have a list of all values and everytime I need the latest value of the average I will have to start from the beginning. ?
07:43:14 <raymank26> favonia, thank you!
07:43:16 <DMcGill> woah, why was that last one 55?
07:43:19 <Peaker> maybefbi, no? it's the same as in your Java code
07:43:21 <maybefbi> Peaker, wouldnt I have to pass in all the inputs in order to get the latest output
07:43:36 <DMcGill> > sum [1|i <- [1..10],j<-[1..10]]
07:43:37 <lambdabot>   100
07:43:41 <jfischoff> DMcGill: j's don't start at 1
07:43:44 <dmwit> > let run = go 1; go m 0 = return []; go m n = do { i <- [m..10]; is <- go i (n-1); return (i:is) } in run 2
07:43:46 <lambdabot>   [[1,1],[1,2],[1,3],[1,4],[1,5],[1,6],[1,7],[1,8],[1,9],[1,10],[2,2],[2,3],[...
07:43:46 <DMcGill> ah, my mistake
07:43:48 <Peaker> maybefbi, just like in your Java code, you feed it a number, you get back a number, and an updated state("oldValue")
07:43:52 <dmwit> > let run = go 1; go m 0 = return []; go m n = do { i <- [m..10]; is <- go i (n-1); return (i:is) } in length (run 2)
07:43:54 <lambdabot>   55
07:44:10 <maybefbi> Peaker, and where do I store that updated state?
07:44:12 <Axman6> DMcGill: [i..10], not [1..10]
07:44:17 <dmwit> raymank26: You're right, we didn't read carefully enough, but the answer is still yes.
07:44:25 <Axman6> blah, scrolled up, too late >_<
07:44:25 <Peaker> maybefbi, it's already stored in the State value
07:44:29 <dmwit> As you can see above. =)
07:44:29 <favonia> maybefbi: due to laziness of Haskell (at least the GHC implementation), usually you can largely ignore that issue.
07:44:32 <raymank26> but how can i do this?
07:44:37 <dmwit> raymank26: I showed how above.
07:44:50 <fmap> > length $ replicateM 4 [1..10] >>= \xs -> guard (and $ zipWith (<=) xs (tail xs))
07:44:51 <lambdabot>   715
07:45:00 <raymank26> oh, thank you. I try it
07:45:08 <dmwit> fmap's way works, too, but is very inefficient in comparison. =)
07:45:22 <dmwit> s/very//
07:45:43 <Peaker> maybefbi, The "oldValue" instance variable is the State's state, accessible via get/modify/put in the State computation, or via "runState"
07:46:08 <Peaker> maybefbi, are you basically asking whether you are trapped in the State monad in order to use this?
07:46:22 <favonia> maybefbi: it's almost incremental everywhere. it's more problematic in Haskell if you insist computing something right away.
07:46:26 <dmwit> > let run = go 1; go m 0 = return []; go m n = do { i <- [m..10]; is <- go i (n-1); return (i:is) } in length (run 4)
07:46:28 <lambdabot>   715
07:46:31 <maybefbi> Peaker, yes do I have to do everything inside a state monad?
07:46:53 <dmwit> :t foldM
07:46:55 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
07:47:00 <maybefbi> favonia, hmm
07:47:00 <Axman6> maybefbi: only things that need access to the state need to be in the state moned
07:47:10 <Peaker> maybefbi, you could manually thread around the state if you wanted, or you could use StateT, or you could avoid the State solution altogether
07:47:28 <Peaker> maybefbi, once you "runState", you get back not only the result, but the internal state which you can feed to later "runState" again
07:47:34 <maybefbi> Axman6, my entire program needs that average everywhere
07:47:36 <Peaker> maybefbi, so you can keep that around if you wanted
07:47:47 <dmwit> :t foldr (>=>)
07:47:49 <lambdabot> forall a (m :: * -> *) c. (Monad m) => (a -> m c) -> [a -> m a] -> a -> m c
07:48:09 <Peaker> maybefbi, it might make sense to have a StateT in a monad stack for this, in your application
07:48:13 <Peaker> maybefbi, what is your application?
07:48:42 <dmwit> :t \n f -> foldr1 (>=>) (replicate n f)
07:48:44 <lambdabot> forall (m :: * -> *) b. (Monad m) => Int -> (b -> m b) -> b -> m b
07:48:58 <maybefbi> Peaker, i already have the app in Java. It takes average values from different scales and put them in a decision tree, and trades with it
07:49:22 <maybefbi> *different alphas
07:49:58 <dmwit> > let funnyReplicateM n f = foldr1 (>=>) (replicate n f); run n = funnyReplicateM n (\x -> [x..10]) in run 2
07:49:59 <lambdabot>   Overlapping instances for GHC.Show.Show (b -> [b])
07:49:59 <lambdabot>    arising from a use of...
07:50:01 <maybefbi> Peaker, I am trying to translate it to Haskell so as to learn haskell.
07:50:04 <dmwit> > let funnyReplicateM n f = foldr1 (>=>) (replicate n f); run n = funnyReplicateM n (\x -> [x..10]) in run 2 1
07:50:05 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,2,3,4,5,6,7,8,9,10,3,4,5,6,7,8,9,10,4,5,6,7,8,9,10,5,...
07:50:15 <dmwit> Oh, not quite right. =)
07:50:49 <maybefbi> Peaker, so every function in my program has to have a State monad around it?
07:51:13 <maybefbi> Peaker, i mean a State monad in the type signature?
07:51:17 <navaati> maybefbi: not every function, only every function that manipulates state
07:51:25 <maybefbi> navaati, ok
07:52:10 <Peaker> maybefbi, functions that want access to the average just need it as a parameter. Functions that want access to the average and to modify it need to have it as a parameter and an output - and State wraps this idea as convenience
07:52:12 <dmwit> :t fix $ \g (f:fs) v -> do { x <- f v; xs <- g fs v; return (x:xs) }
07:52:14 <lambdabot> forall t (m :: * -> *) t1. (Monad m) => [t -> m t1] -> t -> m [t1]
07:52:15 <favonia> maybefbi: Peaker is correct, and as a side note, the Haskell-ish way is to make states *explicit* and pass states (the old average) around. To mimic the Java-ish way you might want to put everything in the ST or IO monad and use references, or State(T) and manipulate the state inside.
07:52:34 <dmwit> :t fix $ \g (f:fs) v -> do { x <- f v; xs <- g fs x; return (x:xs) }
07:52:36 <lambdabot> forall (m :: * -> *) t. (Monad m) => [t -> m t] -> t -> m [t]
07:52:47 <astry> hi guys
07:53:08 <maybefbi> Peaker, favonia, that is tedious
07:53:30 <astry> i have a list, [a], and a value, b, and a function f: a -> b -> b. I want to transform my initial b by every a in the list [a]. how can i do this?
07:53:38 <astry> i feel it's sort of like a fold, but not really.
07:53:42 <maybefbi> favonia, I dont know about references yet
07:53:50 <maybefbi> favonia, I will have to learn them
07:54:13 <Peaker> maybefbi, well, there is a trade-off between freedom of functions to do stuff not "tediously" described by their types and the ability to compose things together safely and reason about them
07:54:22 <bartavelle> ok I am totally stumped here, I know there is no such thing as a stack trace with ghc, but I want something like that anyway, and I can't really use the ghci debugger (problem is in a large lib used by my program)
07:54:24 <maybefbi> Peaker, true
07:54:31 <dmwit> > let feedForward [] v = return []; feedForward (f:fs) v = do { x <- f v; xs <- feedForward fs x; return (x:xs) }; funnyReplicateM n f = feedForward (replicate n f) in funnyReplicateM 2 (\x -> [x..4]) 1
07:54:32 <lambdabot>   [[1,1],[1,2],[1,3],[1,4],[2,2],[2,3],[2,4],[3,3],[3,4],[4,4]]
07:54:33 <navaati> astry: it's a bit like a zip and a fold at the same time
07:54:33 <bartavelle> is there something I could add to the lib to help ?
07:54:42 <dmwit> yaaay
07:54:45 <jfischoff> bartavelle: profiling?
07:54:47 <astry> yes navaati, it is.
07:54:53 <Peaker> maybefbi, Haskell leans towards safety, so you more "tediously" have types that describe the actual effects/things done by functions, which need to "tediously" be updated if anything changes. But for this you get lots of benefits
07:54:58 <bartavelle> jfischoff, what do you mean ?
07:55:14 <fmap> @type foldr
07:55:15 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
07:55:26 <Peaker> maybefbi, Note that this tediousness is not really tedious in practice, if you consider that code in Haskell is significantly shorter/more-concise than Java :)
07:55:42 <jfischoff> bartavelle: you can get a semblance of a stack trace if you enable all cost centers with profiling I think
07:55:44 <maybefbi> Peaker, I guess I need to get used to Haskell more
07:56:16 <bartavelle> jfischoff, what I want to know is the path that led to a throwError, how do I relate this to profiling ?
07:56:19 <however> bartavelle: recent ghc versions have stack traces. but you need to compile with profiling enabled. there was something in the "new in ghc" notes for 7.4 or 7.2 i think
07:56:33 <bartavelle> however, i'll check right now
07:56:35 <dmwit> astry: Sounds exactly like a fold.
07:56:37 <maybefbi> Peaker, thanks a lot for the examples
07:56:42 <Peaker> maybefbi, btw, you could view this as more extreme "static typing".  Dynamic typing is all about changing all compile-time types to "can-be-anything-here".. Java is somewhere in the middle with "can-be-null-or-type-specified-and-by-the-way-any-effect-can-happen!" and Haskell is "only-the-type-or-bottom-is-possible"
07:56:48 <astry> a fold isn't really correct because for my function i have a -> f a init_b
07:56:58 <maybefbi> Peaker, yeah true
07:57:11 <astry> so fold a [] = a but i want fold2 a [] = f a init_b
07:57:23 <astry> or f init_b a, or whatever
07:57:33 <dmwit> astry: So pass f a init b as the base case...?
07:57:43 <maybefbi> Peaker, Haskell is forcing me to think a lot
07:57:48 <astry> dmwit: what is the "base case"?
07:58:03 <dmwit> The second argument to foldr.
07:58:08 <however> @remember maybefbi Haskell is forcing me to think a lot
07:58:08 <lambdabot> It is stored.
07:58:14 <however> good quote ...
07:58:23 <dmwit> :t foldr
07:58:24 <maybefbi> however, lol
07:58:25 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
07:58:42 <Peaker> maybefbi, yeah, I think much of it is because it removes all the silly parts of the code where you just churn out boilerplate :)
07:58:44 <dmwit> :t var
07:58:45 <lambdabot> forall a. String -> Sym a
07:58:46 <astry> i don't see how that would work dmwit
07:58:47 <dmwit> :t x
07:58:49 <lambdabot> Expr
07:58:54 <dmwit> :t expr
07:58:54 <Peaker> maybefbi, and you remain with just the interesting parts you need to think about..
07:58:56 <lambdabot> Expr -> Expr
07:59:08 <dmwit> astry: Perhaps I haven't understood your question yet.
07:59:13 <Peaker> (I'm exaggerating a bit, but compared to Java it's pretty close to the truth)
08:00:04 <dmwit> astry: We have f :: a -> b -> b; we have b :: b; and we have three lists [] :: [a], [a] :: [a], and [a, a'] :: [a]. What should the output of your function be for these three lists?
08:00:16 <maybefbi> Peaker, hmm interesting
08:00:41 <tomboy64> meinen? :-o
08:00:43 <bitonic> Peaker: wait are you implying that static types = less boilerplate?
08:00:46 <astry> so far i have this:
08:00:46 <astry> accFold acc act [] = acc
08:00:47 <astry> accFold acc act (x:xs) = accFold (act acc x) xs
08:00:50 <astry> i'm going to try it now
08:01:05 <tomboy64> wow
08:01:15 <tomboy64> ghc's doc-creation sure gets my machine burning
08:01:33 <favonia> maybefbi: oops I'd like to take something back. State(T) can be thought of some construction that passes state for you. It's still very Haskell-ish (as it's clear that you are manipulating some states) and is used in many places.
08:01:38 <t7> > maxBound :: Int
08:01:39 <lambdabot>   9223372036854775807
08:01:46 <dmwit> ?src foldr
08:01:46 <lambdabot> foldr f z []     = z
08:01:47 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
08:01:47 <Taneb> Where's the place to moan about EclipseFP?
08:01:54 <astry> there's an "act" missing in the second line.
08:01:54 <dmwit> ?src foldl
08:01:55 <lambdabot> foldl f z []     = z
08:01:55 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
08:02:19 <dmwit> astry: Does the source of foldl look familiar?
08:02:29 <Peaker> bitonic, nope, but I can imply that too :)  return-type-polymorphism is possible only with static types, and it does reduce boilerplate :)
08:03:07 <bitonic> Peaker: what's return-type polymorphism?
08:03:21 <bitonic> `maxBound :: Bounded a => a'?
08:03:51 <Peaker> or:  return :: Monad m => a -> m a
08:04:03 <Peaker> yeah
08:04:11 <dmwit> bitonic: maxBound and read are both good examples.
08:04:33 <bitonic> Peaker: well, that's about type classes, not static types.
08:04:40 <dmwit> return isn't an amazing example, because the input type determines the output type.
08:04:45 <Taneb> ...is here the place to moan about EclipseFP?
08:04:46 <bitonic> and with dynamic types it doesn't really matter.
08:04:58 <Peaker> > read "5" * 10
08:04:59 <lambdabot>   50
08:05:05 <Peaker> bitonic, how do you write that with dynamic types?
08:05:34 <Peaker> dmwit, with "return", the "m" is determined by use of the result value
08:05:39 <Peaker> dmwit, not by the input type
08:05:57 <Peaker> it's why the Monad generalization is so hard to implement in dynamically typed languages
08:05:59 <homie> why do you let your monad out on the highway!
08:06:04 <bitonic> Peaker: it's about type classes, not static types. You could argue that you need static types to have type classes, but it depends how loose your definition of type class is
08:06:48 <dmwit> Peaker: Ah, good point.
08:06:55 <astry> dmwit: yes
08:06:59 <astry> dmwit: thanks
08:07:04 <dmwit> =)
08:07:16 <Taneb> I'm annoyed about how EclipseFP seems to obsess over packages not being in the cabal package.
08:07:28 <Taneb> It even goes back to that error when it doesn't have anything to say
08:07:30 <t7> whats this law: a == b == c   ->  a == c
08:07:36 * dmwit commiserates with Taneb
08:07:48 <dmwit> t7: transitivity
08:07:50 <byorgey> "packages not being in the cabal package"?
08:07:57 <byorgey> Taneb: what do you mean?
08:08:02 <dmwit> byorgey: maybe "modules not being in the cabal package"
08:08:17 <byorgey> modules not being listed in the .cabal file?
08:08:30 * dmwit awaits Taneb's answer
08:08:34 <Taneb> byorgey, yeah
08:08:47 <dmwit> It probably really is a bug if you haven't got the file listed *anywhere* in your cabal file, though.
08:08:55 <dmwit> Even internal modules have to be in there somewhere.
08:09:06 <byorgey> you really should have all modules listed in your .cabal file.  Either in exposed-modules (if you want to export it) or in extra-modules.
08:09:13 <however> taneb, you mean it wants you to explicitly list all the packages you depend on? cabal does that too ... you're gonna have to do it sooner or later
08:09:16 * barrucadu doesn't understand that 
08:09:20 <byorgey> if you don't, people will get linker errors later.
08:09:22 <Taneb> byorgey, hidden packages, I mean
08:09:26 <barrucadu> Why should purely internal modules be in the cabal file?
08:09:37 <Taneb> It complains even after they've been added
08:09:44 <byorgey> barrucadu: because they still need to be linked in when compiling the package
08:09:47 <dmwit> barrucadu: So it knows what to include when you make a tar file. =)
08:09:53 <byorgey> that too
08:10:13 <t7> also anyone heard of anything i can generate a (single direction) graph from a set of (subset) constraints
08:10:16 <dmwit> Also your nick is really messing with my head.
08:10:22 <byorgey> Taneb: oh, well that's strange then
08:10:59 <Taneb> Yeah
08:11:00 <t7> like there was this question that asked you to draw the dependency graph from a list of true and false constraints
08:11:01 <merijn> dmwit: Because the transposition of u and a? :p
08:11:05 <however> taneb, a random .hs file fed to runhaskell or ghc has all your installed packages visible by default as a convenience. but if you build via cabal, you need to do it properly. all packages are hidden and you need to explicitly list them
08:11:08 <Taneb> Anyone else getting that?
08:11:26 <Taneb> however, this is after they've been added to the cabal file
08:11:27 <dmwit> merijn: Yes, but that's not even all that's wrong. =)
08:11:36 <dmwit> merijn: So it's messing with your head, too. =)
08:11:47 <merijn> Ah, u at the end too
08:12:30 <favonia> byorgey: I'm confused. did you mean other-modules by extra-modules?
08:12:40 <merijn> dmwit: Well, my own nick seems to be quite sufficient at messing with people's heads :p The number of times I see it butchered to "merjin" by native english speakers is surprising :p
08:12:53 <however> Taneb: i see. maybe it's an issue of reloading the .cabal file or something. try to get at some logs or at eclipse's stderr. does "cabal build" give the same errors as eclipsefp?
08:13:56 <byorgey> favonia: sorry, yes
08:13:59 <Taneb> however, any idea where the log file will be?
08:14:04 <byorgey> I gont confused with extra-source-files
08:14:09 <byorgey> *got
08:14:22 <however> Taneb: sorry, no clue :) never used eclipsefp
08:14:48 <bitonic> Peaker: anyway, I'd dispute that static types = less boilerplate. I can't see a reason while that would be true and I have no evidence (I work a lot with both worlds). I'd argue that the language with less boilerplate is Lisp, simply because macros are the best thing to eliminate boiler plate. And runtime macros are not really feasible in a static type system
08:15:45 <byorgey> merijn: hehe, yeah, j never comes before another consonant in English
08:16:03 <Taneb> What's weird is that it doesn't mark imports after the module is put in the .cabal as an error, even when it does others
08:16:08 <however> bitonic: i feel the static/dynamic trade-off is usually "save a minute writing boilerplate, spend an hour debugging" ... my 2 cents
08:16:08 <homie> juice!
08:16:20 <homie> jupiter, joke, jewels...
08:16:27 <Taneb> So I've got import Data.Map (Map) as fine, but import qualified Data.Map as M is not...
08:16:27 <bitonic> however: that's another discussion. Peaker was talking about boilerplate specifically
08:16:32 <homie> jpl
08:16:35 <homie> hrmmmmmm
08:16:53 <Taneb> No wait
08:16:53 <however> byorgey: except in the alphabet, dude
08:16:58 <Taneb> That's an error too
08:17:50 <however> Taneb: when running "cabal configure && cabal build" in your directory, do the same errors appear?
08:18:43 <Taneb> however, no
08:21:46 <Peaker> bitonic, I don't understand how you could implement type-classes with return-type polymorphism support without static typing
08:21:59 <Peaker> bitonic, unless you add manual dictionary passing, in which case you've reintroduced the boilerplate
08:22:38 <bitonic> Peaker: behaviours and modules
08:22:43 <Peaker> bitonic, and I don't think lisp-macros are a good tool to reduce the conceptual repetition (boilerplate) because syntactic transformations are not as composable as their semantic counterparts
08:22:55 <astry> is there something like filter but f :: (a -> Bool) -> [a] -> ([a], [a]) ? it would split a list to things which passed the filter and which did not
08:23:03 <Peaker> bitonic, how do you implement     read "5" * 5    without static typing?
08:23:14 <bitonic> Peaker: int:read("5") * 5
08:23:20 <Peaker> bitonic, That "int" is boilerplate :)
08:23:20 <merijn> :t partition
08:23:22 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
08:23:32 <astry> @hoogle accFold acc act [] = acc
08:23:32 <astry> accFold acc act (x:xs) = accFold (act acc x) act xs
08:23:32 <lambdabot> Parse error:
08:23:32 <lambdabot>   accFold acc act [] = acc
08:23:32 <lambdabot>                      ^
08:23:35 <merijn> astry: Something like that? :p
08:23:36 <astry> sorry
08:23:36 <bitonic> Peaker: that is completely irrelevant. The annoying boilerplate is elsewhere.
08:23:45 <astry> merijn: might be, thanks, let me try
08:23:53 <Peaker> bitonic, what I mean to say is that static typing reduces some boilerplate that dynamic typing cannot
08:24:12 <bitonic> Peaker: I would not even call that boilerplate. Then in languages where you have to prefix every function with the module, it that boilerplate? I would not say so
08:24:21 <Peaker> bitonic, dynamic typing reduces some boilerplate that some static types systems cannot, too, but I don't think that in the general case, all static type systems will not be able to
08:24:56 <bitonic> Peaker: well, I think that if you compare them, static types are at least not clear winner
08:25:19 <bitonic> and I agree that functions are better than macros, but macros do wonders when you have to eliminate boilerplate
08:25:39 <bitonic> I think that that far outweights typeclasses
08:25:50 <bitonic> (in terms of reducing boilerplate)
08:28:49 <hpaste> dmwit pasted “another thing infixl ($) can do” at http://hpaste.org/70945
08:29:05 <Peaker> bitonic, I don't consider typeclasses "boilerplate eliminators", they're just a nice feature that demonstrates static types can shorten code rather than make it longer
08:29:06 <dmwit> I have discovered a truly marvelous use of infixl $.
08:29:40 <dmwit> Cale: (Which, if you hadn't seen it before, you might be interested in, for when it comes time to argue for it. =)
08:30:02 <rwbarton> i have discovered a truly marvelous use of 'where'
08:30:20 <dmwit> rwbarton: Then you have to name things!
08:30:26 <bitonic> Peaker: sure. I just thought that the claim that statically typed langs are better at reducing boilerplate was a bit far-fetched.
08:30:30 <dmwit> \ teaches us that naming should be avoided when it's unnecessary. ;-)
08:30:38 <however> i have discovered a truly marvelous use of margins, but this margin is too small to hold it
08:31:05 <Taneb> GHC was originally funded by the UK government!?
08:31:29 <Taneb> I'm glad my ancestors' tax-money went to good use :)
08:31:49 <however> taneb: i thought it came out of glasgow university. i guess you could call that "uk government" in the broadest sense
08:31:55 <Peaker> bitonic, I think in the general case that's probably true, but we're still improving on type systems
08:32:04 <Taneb> however, I'm looking at http://www.aosabook.org/en/ghc.html
08:32:31 <bitonic> Peaker: what's true? That static types are better at boilerplate or that your claim was far-fetched?
08:33:01 <however> Taneb: nice link, thanks
08:33:16 <SimonJF> Ah, I'm reading the same - it was tweeted, right?
08:33:19 <Peaker> bitonic, the former (but we're not there yet)
08:33:34 <Peaker> bitonic, because the more knowledge the language/compiler has about your program, the more it can help with it
08:34:02 <Peaker> bitonic, so as a general principle, we can expect languages that increase the amount of knowledge of the compiler about properties of the program to reduce boilerplate
08:34:11 <Peaker> (and conceptual repetition in general)
08:34:43 <Axman6> SimonJF: how does it feel to be a future Haskell god? You were blessed with the holy name!
08:34:44 <Tinned_Tuna> @src return :: [a]
08:34:45 <lambdabot> Source not found.
08:34:49 <Tinned_Tuna> @src return
08:34:49 <lambdabot> Source not found.
08:34:52 <bitonic> Peaker: I disagree, the compiler will be good at optimisations and stuff like that, but not at generating code - which is what boilerplate removal is mostly about. But yes we are advancing, GHC.Generics is the nicest example maybe
08:34:55 <Axman6> @src [] return
08:34:55 <lambdabot> return x    = [x]
08:35:39 <Peaker> bitonic, boilerplate removal isn't really "generating code"
08:35:50 <Peaker> bitonic, it's just having better ways to express the computation
08:35:54 <SimonJF> Axman6: Haha, I have a way to go yet :P
08:36:47 <bitonic> Peaker: well it's usually about letting humans express some computation in a more concise way. That often translates in adding forms to your language
08:37:12 <bitonic> Peaker: e.g. look at the wild success of TH, despite how incredibly ugly it is
08:37:17 <Peaker> bitonic, adding either syntactic or semantic constructs. I believe the latter are better at reducing repetition because they compose
08:37:28 <Peaker> bitonic, that's because of Haskell deficiencies
08:37:42 <navaati> haskell is remarkably good at becoming very powerful without adding much to the language
08:38:11 <bitonic> Peaker: yeah but those deficiencies hare very hardly removed. I don't know any language that can even remotely match the power of macros through other ways. Haskell is the language that comes closer, btw.
08:38:25 <bitonic> *very hard to remove
08:43:24 <astry> @hoogle partition
08:43:24 <lambdabot> Data.List partition :: (a -> Bool) -> [a] -> ([a], [a])
08:43:24 <lambdabot> Data.Either partitionEithers :: [Either a b] -> ([a], [b])
08:43:24 <lambdabot> Data.Text partition :: (Char -> Bool) -> Text -> (Text, Text)
08:55:43 <Peaker> bitonic, there was a nice presentation about Agda's dependent types for meta-programming (rather than proofs/etc)
08:56:03 <Peaker> bitonic, once types are first-class values you can manipulate, you can reduce lots of boilerplate that in Haskell you need TH for
08:56:18 <bitonic> Peaker: and still, agda has the `syntax' thing
08:56:41 <bitonic> Peaker: also, I must have missed that presentation, link?
08:57:35 <SimonJF> I got told a few weeks back that I'd have to learn dependent types; I need to get this visualiser working for Idris as well
08:57:49 <Peaker> bitonic, I read about it long ago, I'll try to find it
09:00:51 <Cale> dmwit: absolutely :)
09:01:11 <Cale> dmwit: infixl $ is great when you have more than one parameter which is long
09:01:23 <dmwit> right
09:01:51 <dmwit> Ah, yes. I see. The convenience actually has nothing to do with the fact that you can end a block.
09:01:57 <dmwit> good point =)
09:11:32 <Taneb> Well, now I just need to write the interface for this
09:11:36 <Taneb> Heh, "just"
09:14:16 <astry_> totally using haskell for data recovery
09:15:59 <astry_> Cale: sorry, how are you using infixl $?
09:16:02 <astry_> :t infixl
09:16:03 <lambdabot> parse error on input `infixl'
09:16:10 <astry_> :t (infixl)
09:16:11 <lambdabot> parse error on input `infixl'
09:16:16 <astry_> what does infixl do ?
09:16:16 <monochrom> infixl is a reserved word
09:16:29 <astry_> interesting, i didn't know that.
09:16:36 <astry_> @src (infixl $)
09:16:36 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
09:16:45 <astry_> @pl (infixl $)
09:16:45 <lambdabot> infixl
09:16:48 <Taneb> @info $
09:16:48 <lambdabot> ($)
09:16:49 <Cale> astry_: infixl is a keyword, it's for declaring an infix operator as left-associating
09:16:58 <Cale> (and setting the precedence)
09:17:02 <astry_> what does "infixl $" do?
09:17:10 <astry_> does it just mean flip $?
09:17:25 <Cale> astry_: it would mean that  f $ x $ y  means  f x y
09:17:36 <Taneb> Rather than f (x y)
09:17:50 <monochrom> see http://www.hck.sk/users/peter/HaskellEx.htm for haskell grammar, has hyperlinks
09:17:52 <Cale> that is, (f $ x) $ y, it's been associated to the left
09:18:17 <astry_> whereas if i do <> = flip $ then i could do y <> f x
09:18:39 <astry_> interesting
09:18:45 <Taneb> I think # is the convention for flip ($)
09:18:46 <astry_> is there a name for infixl $?
09:18:55 <Taneb> $, I think
09:19:02 <astry_> $, ?
09:19:10 <astry_> that's a bit.. weird :)
09:19:11 <Taneb> infixr $ is different
09:19:13 <Cale> astry_: no, it's just that $ is declared infixr in the prelude
09:19:16 <jonkri> what was -fno-method-sharing, and why was it removed?
09:19:19 <Taneb> Is it?
09:19:22 <astry_> i'd have called it l$
09:19:22 <Axman6> astry_: infix declarations say whether things are left or right associative, and their binding power (?). so infix ($) means that x $ y $ z === ((x $ y) $ z) and infix ($) means (x $ (y $ z))
09:19:23 <Cale> and some of us think infixl would have been much better
09:19:25 <astry_> or something easy
09:19:34 <Cale> l$ isn't a valid identifier name
09:19:38 <singpolyma> RE example code http://pastie.org/4205105 -- I'm looking for tips on: rewriting to not use do notation for the b value, the b and c values, and/or all three values
09:19:42 <Cale> (it's two symbols)
09:19:45 <astry_> Axman6: i think you missed some "l" and "r" there
09:19:59 <Axman6> urgh, no, they got autocorrected
09:19:59 <astry_> Cale: why is it bad that it's two symbols?
09:20:24 <Axman6> infixl is the first one, infixr is the second
09:21:38 <yitz> i think we should call it !&/=+
09:22:12 <Axman6> singpolyma: it can be done, it's a bit ugly though: (\a -> doit <$> thing1 a <*> thing2 a) <$> input
09:22:13 <yitz> oh wait: $!7/=+
09:22:17 <Axman6> hmm, no that isn't right is it
09:23:01 <geekosaur> ...wat.  pastie is blocked as a malware site here.
09:23:07 <monochrom> haha
09:23:44 <Cale> astry_: Well, you can't define something called l$
09:23:54 <Cale> astry_: The Haskell syntax doesn't allow it
09:24:06 <rwbarton> just like you can't define something called + 1, or humpty dumpty
09:24:31 <monochrom> input >>= \a -> doit a <*> thing1 a <*> thing2 a
09:24:42 <yitz> that's the reason it's better for $ to be infixr. it's very hard to spell "right" in leet using only valid operator characters.
09:25:12 <astry_> Cale: but is it wrong to have two chars?
09:25:16 <rwbarton> monochrom, i don't think that's right
09:25:23 <astry_> btw, guys, is there an ** which works inside Integer?
09:25:34 <astry_> ie returns Integer
09:25:41 <rwbarton> astry_: ^
09:25:47 <astry_> oh thanks
09:25:53 <monochrom> that is not right either
09:26:20 <parcs`> astry_: ^
09:26:22 <yitz> rwbarton: thanks for the help yesterday. i found the problem.
09:26:25 <parcs`> oh :(
09:26:35 <rwbarton> monochrom, wouldn't it need to be input >>= \a -> join (doit a <$> thing1 a <*> thing2 a)
09:26:52 <rwbarton> yitz: yeah, I got your message
09:26:55 <monochrom> yes
09:27:16 <parcs`> maybe # should be infixl $, because who uses flip ($) anyway
09:27:30 <rwbarton> plus # is to the left of $ :)
09:27:34 <parcs`> exactly
09:28:12 <Cale> astry_: It can be two characters, but they have to both be symbol characters
09:28:54 <singpolyma> (input >>= \a -> doit a <*> thing1 a <*> thing2 a)    gives me a type error
09:29:23 <singpolyma> so does putting a join inside the lambda
09:29:44 <parcs`> singpolyma: don't you want doit a <$> ...
09:29:46 <however> singpolyma: i'd find it clearest to do something like "do a <- input ; doit a <$> thing1 a <*> thing2 a". also, it's often best if a few functions as possible are IO. if you paste some more code, folks will probably be able to help you concentrate IO a little more
09:30:19 <monochrom> I would stick with do-notation
09:30:26 <rwbarton> however's also needs an additional join
09:30:28 <however> (in other words, be as pure as you can, then have a small amount of IO to tie it together)
09:31:08 <astry_> Cale: ah, so it's either symbols only or non-symbols only? i didn't know that. why is it like this?
09:31:15 <singpolyma> (input >>= \a -> join (doit a <$> thing1 a <*> thing2 a))   seems to work
09:31:36 <rwbarton> I think the original do notation is best too. mixing join and <*> is ugly imo
09:32:37 <rwbarton> I have seen people confused why their program did not print anything when they left out a join in a situation like this
09:32:50 <yitz> rwbarton: why? Monad really should be a subclass of Applicative. it only isn't due to historical accident.
09:33:13 <rwbarton> just a matter of taste I guess
09:33:21 <astry_> parcs, flip $ is great for when you have a lot of functions of the form a -> a
09:34:06 <singpolyma> (do a <- input ; doit a <$> thing1 a <*> thing2 a)   also gives me a type error.  I have to put join around the last expression
09:34:56 <dispy> Hi
09:35:01 <dispy> http://pastebin.com/ZB2iTtWS << any suggestions?
09:35:03 <mauke> The paste ZB2iTtWS has been copied to http://hpaste.org/70951
09:35:13 <singpolyma> I was originally trying to solve thing with something like liftM2, but that's for a different case
09:35:26 <singpolyma> I guess this case is really what applicative style is good at
09:35:39 <rwbarton> liftM2 f a b is f <$> a <*> b
09:35:55 <yitz> astry_: one reason is so that you can write things like a+b without spaces
09:35:56 <rwbarton> so you can also write join (liftM2 (doit a) (thing1 a) (thing2 a))
09:36:28 <dmwit> You shouldn't need liftM2 if you're doing a join.
09:36:29 <singpolyma> oh, true.  I guess it did not occur to me to use join
09:37:14 <bartavelle> dispy, there are problems with your paste
09:37:38 <bartavelle> why not just use read ?
09:37:43 <singpolyma> dmwit: that's normally how I would feel, but in this case I'm not sure what else I would do (other than join and applicative, which is equivalent)
09:37:56 <dispy> @bartavelle: I can only use what my book introduced
09:37:56 <lambdabot> Unknown command, try @list
09:38:04 <dmwit> singpolyma: Maybe something like, input >>= \a -> thing1 a >>= \b -> doit a b (thing2 a) -- ?
09:38:10 <dispy> where are the problems indeed?
09:38:23 <singpolyma> dmwit: that's just do notation
09:38:33 <dmwit> singpolyma: Yes... so?
09:38:42 <dmwit> Did I miss a constraint somewhere?
09:38:46 <bartavelle> dispy, digitToInt works with hexa
09:38:49 <monochrom> cti ('-':str) = (-1) * cti str
09:38:52 <dmwit> I mean, you're already using input >>= \a -> ..., which is do notation.
09:38:56 <monochrom> cti str = foldl f 0 str
09:38:58 <bartavelle> dispy, so it will parse "aaaaaaa"
09:39:04 <singpolyma> My original question was how to do http://pastie.org/4205105 with less do notation
09:39:40 <singpolyma> I figured I'd have to use it for the    (a <- input) bit, because that's shared across the whole thing, so that makes sense
09:39:44 <dispy> oh thank you monochrom
09:39:58 <singpolyma> but the other two values are only used in the call to doit, so do notation feels weird to me in that case
09:40:21 <dispy> @bartavelle: how to avoid that=?
09:40:22 <lambdabot> Unknown command, try @list
09:40:27 <monochrom> feelings are weird
09:40:53 <rwbarton> (dispy, don't start lines with @)
09:40:59 <singpolyma> anyway, it seems the choices are do notation or join, so that's at least good to know :)
09:41:03 <bartavelle> dispy, depends if you want to avoid this or not. If you do you should probably add guards in the "f" function
09:41:25 <dispy> guards so that it's a partial function?
09:41:31 <dispy> or should I use error instead?
09:42:19 <bartavelle> IDK what a partial function is, I mean the thing that looks like that :   f acc char | (char < '0' || char > '9') = error "blah"   \n   otherwise | ...
09:42:47 <bartavelle> it might look better with an if as there are only two cases
09:42:56 <singpolyma> Thanks all! :)
09:43:27 <dispy> http://pastebin.com/kcnPSa6x << better one?
09:43:29 <mauke> The paste kcnPSa6x has been copied to http://hpaste.org/70952
09:43:51 <astry_> yitz: i hate that. i wish i could have identifiers-with-hyphens!!
09:43:55 <dispy> oh. own haskell pastebin o.O
09:44:39 <bartavelle> idk, isNumber doesn't do what you want according to this : http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-Char.html
09:44:49 <yitz> astry_: underscore and apostrophe are letter characters, if that helps
09:45:02 <astry_> nope! hyphens or nothing!
09:45:57 <dispy> ok i'll use isDigit instead
09:46:04 <dispy> that only accepts 0 to 9
09:46:09 <serialhex> +1 hyphens - they are easier to type (no messy shift-key to press!)))
09:46:23 <astry_> yes!
09:46:32 <yitz> serialhex: apostrophe is unshifted on my keyboard
09:46:42 <serialhex> did i seriously just do that???  type 3 close parens instead of !'s????
09:46:43 <dmwit> singpolyma: func input = input >>= \a -> liftM2 (,) (thing1 a) (thing2 a) >>= uncurry (doit a)
09:46:44 <astry_> but doing names`with`hypens looks stupid
09:47:19 <monochrom> I like hyphens too
09:47:21 <serialhex> yitz: you have a special keyboard then... dvorak programmer?  (or something else??)
09:47:39 <astry_> us qwerty
09:47:43 <rwbarton> apostrophe is unshifted on the standard US keyboard layout
09:47:54 <serialhex> 'yep
09:48:00 <serialhex> -yep
09:48:04 <serialhex> _nep
09:48:19 <yitz> serialhex: no a US qwerty. unshifted apostrophe is standard.
09:48:24 <monochrom> > let a'b = 0 in a'b
09:48:25 <lambdabot>   0
09:49:12 <monochrom> don't bother second-guessing keyboard layout. just specify U+0027 and let the user worry about how to generate it
09:49:43 <yitz> > "\x27"
09:49:44 <lambdabot>   "'"
09:49:46 <serialhex> i've always wondered how to get unicode chars easily...
09:50:01 <serialhex> most txt editors wont let you do that
09:50:09 <codolio> Just memorize them all.
09:50:14 <serialhex> (at least, the ones i've used)
09:50:17 <serialhex> -_-
09:50:26 <monochrom> some unicode chars can be got easily. for example U+0061. you just typed in a few copies of it
09:50:39 <rwbarton> emacs has M-x ucs-insert
09:50:58 <yitz> serialhex: in emacs use ^X 8 Enter then start type the name of Unicode char, hit space for autocompletion
09:51:04 <serialhex> no, i'm talking about special ones... like lambda or other greek letters...
09:51:06 <yitz> *typing
09:51:08 <codolio> Emacs also has quail mode (I think that's right) for typing in exotic characters more easily.
09:51:26 <codolio> You can set it up to use LaTeX-like names, for instance.
09:51:50 <monochrom> not the responsibility of editors. look up "input methods" or "IME"
09:51:51 <clsmith> a language that does not allow U+1F4A9 in identifiers is not worth using
09:52:02 <codolio> There's also scim and ibus on Linux/maybe others for system-wide input in that manner.
09:52:12 <monochrom> the responsibility is with the OS or its GUI framework
09:52:35 <monochrom> it is clearly unscalable to expect every editor to implement every input method
09:52:37 <serialhex> monochrom: true, but i dont know how to get them *at all*
09:53:06 <however> serialhex: if you're on something unixy, you may want to google for some info on the xcompose file. the default file that distros come with isn't half-bad, and people have posted some pretty cool additional maps
09:53:44 <serialhex> i *like* the unix phil: one tool does one thing awesomely!  i just havnt a clue how to get the chars in the first place (after that, copy-paste isn't hard)
09:53:45 <yitz> monochrom: theoretically true, but it's convenient that i can enter any unicode character easily the same way on any platform in emacs
09:53:54 <clsmith> i set up a little thing with dmenu once that lets me look up and paste unicode chars by typing, say, "lambda"... which was nice.
09:53:58 <dispy> how can I convert a char into an Integer instead of an Int?
09:54:36 <monochrom> first to Int, then use toInteger
09:55:38 <dispy> thanks
09:56:39 <however> dispy: also, fromIntegral is a function to "convert anything to anything"
09:57:00 <dispy> thx for the hint
09:57:44 <monochrom> yitz, I don't know about theoretically, but in practice, once upon a time a lot of text editors and word processors sprung up just for the differentiation by "this one lets you enter Chinese", "that one lets you enter Japanese"... and they have long disappeared. apart from emacs, no editor or word processor has built-in input methods now, it's all upon the OS
09:58:14 <dispy> another question: the author uses types with several value constructors to denote non-critical errors. Is this what is also done in the real haskell? I'm coming from the regular programming langauges with their exceptions and I can'T imagine that haskell has made one step back ^
10:00:19 <however> dispy: exceptions are also available in haskell
10:01:49 <S11001001> dispy: but exceptions happen to be a step back for safety so tend not to be used
10:01:57 <monochrom> if you are outside IO, you would want several value constructors to denote several errors
10:02:42 <rwbarton> exceptions are nondeterministic when evaluation order is unspecified
10:02:43 <monochrom> if you are inside IO, exceptions are good. other languages are perpetually inside IO, so they pervasively use exceptions
10:03:16 <S11001001> dispy: instead, use HOFs to lift success-only code into success-or-failure contexts
10:03:44 <dispy> HOFs ?
10:04:23 <monochrom> see also my http://www.vex.net/~trebla/haskell/exception.xhtml
10:05:57 * hackagebot snaplet-mongodb-minimalistic 0.0.6.5 - Minimalistic MongoDB Snaplet.  http://hackage.haskell.org/package/snaplet-mongodb-minimalistic-0.0.6.5 (PetrPilar)
10:06:07 <monochrom> which precisely compares exceptions with "use HOFs to lift ..."
10:06:43 <mkscrg> is there a regex package that deals with Text?
10:07:03 <S11001001> > pred <$> (Nothing *> Just 42) -- failed to produce an int, lifted pred to the success case
10:07:03 <however> disply: HOF = higher-order functions, a function that takes other functions. and no, i don't really know what he means either :-/
10:07:04 <lambdabot>   Nothing
10:07:04 <yitz> monochrom: yes agreed. all true, and that's how it's usually done. but personally i find it's faster to just type it in emacs than to figure out how to get some weird characters typed on whatever platform.
10:07:09 <S11001001> > pred <$> Just 42
10:07:10 <lambdabot>   Just 41
10:08:55 <however> dispy: i feel exceptions are a step up compared to the c-style "return -1 or 0 or NULL and hope the programmer has read the docs, if there are any, and didn't forget the same 4 lines of boilerplate, every last damn time". but for that case, haskell has better ways anyway (as you've mentioned)
10:08:56 <monochrom> he means for example if'left in my page, which is an euphemism for "catch"
10:09:36 <however> monochrom: oh thanks
10:09:39 <S11001001> > liftA3 (\x y z -> x + y * z) (Just 2) (Just 3) (Just 5) -- lifts a function into 3 potential failures, all of which succeed here
10:09:40 <lambdabot>   Just 17
10:09:49 <matthiasgorgens> does anyone know how to consume two input streams at the same time (i.e. zipped) with Data.Enumerator?
10:10:06 <tazjin> > (and [], or [])
10:10:07 <however> S11001001: thanks, that's clear now
10:10:08 <lambdabot>   (True,False)
10:10:20 <monochrom> in fact, also ">>=" which is implicit in both versions
10:10:22 <tazjin> ^ why is and [] True?
10:10:31 <dispy> ok. So I have got get used to the new variation of error-handling
10:10:46 <DMcGill> @src and
10:10:46 <Cale> tazjin: because that's the identity element for and of course
10:10:47 <lambdabot> and   =  foldr (&&) True
10:10:49 <DMcGill> @src or
10:10:50 <lambdabot> or    =  foldr (||) False
10:10:54 <dispy> frankly, I'm most agnostic :)
10:10:54 <rwbarton> "and xs" is True if every element of xs is True
10:11:05 <DMcGill> `and' is true by default and `or' is false by default
10:11:16 <Cale> tazjin: It makes it true that and (xs ++ ys) = and xs && and ys
10:11:16 <tazjin> Hmm, somehow I would have expected both to be false by default
10:11:17 <DMcGill> or did you mean why should it be?
10:11:21 <rwbarton> or another way to say it is if there are no False elements in xs
10:11:59 <monochrom> my http://www.vex.net/~trebla/homework/empty.html explains why "and [] = True". but it's what Cale says
10:12:11 <however> dispy: don't worry, it's basically like a c function which returns -1 for failure, any positive int for success. only the -1 is lifted out of that for extra clarity, as in "Failure | Whatever Int"
10:12:27 <monochrom> but mine has the added benefit of covering "product []" too :)
10:12:27 <Cale> i.e. 'and' is a monoid homomorphism from ([a], ++, []) to (Bool, &&, True)
10:13:30 <Cale> Num a => product is a monoid homomorphism from ([a], ++, []) to (a, *, 1)
10:13:47 <tazjin> Hm, alright
10:13:53 <yitz> tazjin: another way to look at it: and is just a fold. and = foldr (&&) default. to make this work, you take default = True.
10:14:14 <yitz> tazjin: similarly for or.
10:14:23 <yitz> @src and
10:14:24 <lambdabot> and   =  foldr (&&) True
10:14:29 <yitz> @src or
10:14:29 <lambdabot> or    =  foldr (||) False
10:14:48 <Cale> Yeah, if it were False, then the recursive case for 'and' would be broken
10:15:00 <dispy> thx however
10:16:42 <serialhex> yitz: would that shortcut though?  say you have 10 mil items in your list, would that go through all 10 mil no matter what?
10:16:56 <dmwit> It shortcuts when it can.
10:16:57 <kallisti> it would short circuit
10:17:07 <Cale> serialhex: consider:
10:17:08 <mkscrg> anybody? regexes with Text? is there a reason Text is not handled by regex-base or has it just not been implemented?
10:17:12 <kallisti> serialhex: this is possible because Haskell is lazily evaluated.
10:17:19 <dmwit> mkscrg: text-icu handles regexen
10:17:19 <Cale> foldr (&&) True [False,...]
10:17:20 <serialhex> ok, cool... i figured but wanted to be sure
10:17:33 <Cale> -> False && (foldr (&&) True [...])
10:17:34 <dmwit> mkscrg: ...as is mentioned in the landing page for the "text" package, I might add.
10:17:35 <Cale> -> False
10:17:43 <yitz> dmwit: text-icu is a problem on the mac
10:17:47 <Cale> evaluation is outermost first, so it just works :)
10:18:02 <Cale> @src foldr
10:18:03 <lambdabot> foldr f z []     = z
10:18:03 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
10:18:04 <serialhex> ahh, ok, thx Cale
10:18:06 <Cale> @src (&&)
10:18:07 <lambdabot> True  && x = x
10:18:07 <lambdabot> False && _ = False
10:18:29 <mkscrg> dmwit: thanks. blatant oversight on my part!
10:18:30 <serialhex> ahhhh  :D
10:18:42 <kallisti> Cale: hm, that's weird. I would consider it "innermost"
10:18:48 <kallisti> but I guess syntactically it's the outermost expression
10:18:56 <Cale> It's a combination of the fact that foldr f z produces an application of f as its result (allowing f to be applied immediately), and the fact that (&&) doesn't pattern match its second parameter when the first is False
10:19:21 <serialhex> dmwit: just fyi - i havnt given up, i've been *very* busy, and wrapping my mind around haskell is hard :D
10:19:28 <Cale> kallisti: Well, what's innermost about it?
10:19:41 <yitz> > True && error "ouch"
10:19:43 <lambdabot>   *Exception: ouch
10:19:49 <dmwit> serialhex: Ah, okay!
10:19:53 <yitz> um
10:20:41 <yitz> > False && error "ouch"
10:20:43 <lambdabot>   False
10:20:43 <serialhex> dmwit: yeah, i've got the sequence' function working on a pair, but i need to figure out how to make it work on a list of any length
10:21:03 <dmwit> serialhex: Yes, that's a tricky jump to make.
10:21:05 <serialhex> list?  array?  one of the 2...
10:21:10 <dmwit> list
10:21:14 <serialhex> ok
10:21:25 <dmwit> serialhex: You could try making it work on triples and quadruples first.
10:21:29 <dmwit> It might make the pattern more obvious.
10:21:38 <kallisti> Cale: I guess nothing, actually.
10:21:40 <serialhex> hmm... ok
10:21:46 <dmwit> I'm not 100% sure that's helpful, really, but maybe. =)
10:22:20 <Cale> kallisti: In strict evaluation, foldr kinda "starts combining at the end of the list", but under lazy evaluation it's backwards :)
10:22:23 <dmwit> Ah, I know what will be helpful.
10:22:46 <DMcGill> @pl f x = g (h x) (i x)
10:22:46 <lambdabot> f = liftM2 g h i
10:22:49 <serialhex> well, we'll see what i come up with!  :D  and again, thank you for your help!
10:22:51 <dmwit> serialhex: Have you ever considered representing pairs like "(a,(b,()))" instead of "(a,b)"?
10:23:01 <serialhex> umm... no
10:23:12 <kallisti> Cale: I was thinking of it like this:  ignoring recursion, you can think of a simple expression as its syntax tree, where values/functions additionally point to their reduced expressions.
10:23:15 <dmwit> serialhex: Well, what's nice about that representation is that it "scales" a bit more cleanly.
10:23:30 <DMcGill> @pl f = g (h x) (i x)
10:23:31 <lambdabot> f = g (h x) (i x)
10:23:43 <dmwit> serialhex: e.g. you can use "(a,(b,(c,()))", and that's like "(a,{- a pair of b and c here -})".
10:24:04 <serialhex> hmm...
10:24:08 <dmwit> serialhex: and quadruples "(a,(b,(c,(d,()))))" are like "(a,{- a triple of b, c, and d here -})".
10:24:11 <DMcGill> I've seen it done that way for type safe stacks
10:24:21 <dmwit> serialhex: So, here are two exercises that should help you:
10:24:34 <kallisti> Cale: in that case it's a sort of postfix traversal along the evaluation/reduction edges. I don't know if that makes any sense.
10:24:44 <dmwit> serialhex: 1. rework your 2-ary combiner into one that returns one of these funny nested pairs
10:24:56 <astry_> hello
10:25:04 <dmwit> serialhex: 2. write something that returns a funny nested triple, and calls your new funny nested pair function as a subroutine somewhere
10:25:10 <astry_> haskell is surprisingly helpful in data recovery tasks
10:25:17 <astry_> i would just like to point this out
10:25:54 <dmwit> serialhex: (optional 3. write something that returns a funny nested quadruple, and calls your new funny nested triple function as a subroutine somewhere; how does it look compared to the answer to (2)?)
10:26:07 <serialhex> dmwit: hmm, i'll have to try that
10:26:21 <yitz> astry_: especially in the part where you replace your code with something safer that won't trash your data next time
10:26:49 <dmwit> serialhex: Once you've done those, you should start to see a pattern that you could write recursively... if only tuples were a bit more recursive. And just your luck, lists are like recursive tuples of this form!
10:27:16 <serialhex> hmm... okay
10:27:51 <dmwit> (I hope you can see how (1,(2,(3,(4,())))) is a bit like 1:2:3:4:[].)
10:28:01 <serialhex> yes
10:28:21 <astry_> yitz: i wasn't thinking of that
10:28:29 <astry_> but yeah, that could work.
10:29:19 <serialhex> mostly i get errors dealing with that list recursion...  and how it cant match type `d` with type `[d]`...
10:29:28 <serialhex> but i think that will help
10:29:38 <DMcGill> oh man, I hate that infinite type error
10:29:58 <DMcGill> at that point I just put everything in a where clause so I can explicitly state the type of every single thing
10:29:59 <kallisti> I'm guessing you tried to embed a list as an element of another list?
10:30:20 <kallisti> DMcGill: just get accustomed to knowing the types of expressions as you write them.
10:30:26 <serialhex> DMcGill: wait... youcan specify types of things in a where clause!?!?
10:30:32 <kallisti> yes
10:30:37 <serialhex> since when?
10:30:38 <DMcGill> well obviously one would like to know what's going on
10:30:41 <kallisti> since always
10:30:44 <mcstar> DMcGill: i dont think every such error is a 'cant create recursive type bla bla..'
10:30:46 <DMcGill> but if you get really confused, that's my fallback
10:30:46 <serialhex> and why didnt anyone tell me this!?!??!?!?!
10:30:49 <kallisti> > let f :: Int -> Int; f x = x + 2 in f 3
10:30:51 <lambdabot>   5
10:31:01 <kallisti> any place where you can bind names
10:31:05 <kallisti> you can annotate types.
10:31:08 <kallisti> or specify fixity
10:31:29 <serialhex> hmm.... ok cool
10:31:42 <kallisti> > let infixr + 1; (+) = (Prelude.+) in 2 + 4*4
10:31:43 <lambdabot>   <no location info>: parse error on input `1'
10:31:46 <serialhex> i didnt know / think you could do that
10:31:48 <mcstar> with an extension, you can inline annotate anything with types
10:31:49 <kallisti> > let infixr 1 +; (+) = (Prelude.+) in 2 + 4*4
10:31:50 <lambdabot>   18
10:32:25 <kallisti> > let infixr 9 +; (+) = (Prelude.+) in 2 + 4*4
10:32:26 <lambdabot>   24
10:33:19 <kallisti> this is what someone with a parentheses phobia does
10:33:27 <kallisti> just redefine the fixities of all the operators
10:34:04 <DMcGill> I was just on the haskellWiki obfustication page today!
10:34:08 <serialhex> -_-
10:34:18 <DMcGill> imagine code where there is only one name called
10:34:27 <mcstar> let
10:34:28 <DMcGill> and it just gets defined with a let
10:34:35 <DMcGill> between any two statements
10:34:35 <kallisti> :t fmap fmap fmap fmap fmap fmap
10:34:37 <lambdabot> forall a (f :: * -> *) a1 b (f1 :: * -> *). (Functor f, Functor f1) => (a -> a1 -> b) -> f a -> f (f1 a1 -> f1 b)
10:35:11 <serialhex> kallisti: that.... what is that!?!?!?
10:35:40 <DMcGill> serialhex: read typeopedia to find out
10:35:43 <DMcGill> :where typeopedia
10:35:48 <DMcGill> oops, I mean
10:35:51 <kallisti> fmap = (.)  for ((->) a)
10:35:53 <DMcGill> @where typeclassopedia
10:35:53 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
10:35:56 <kallisti> so fmap fmap fmap
10:36:03 <kallisti> is the same thing as (.) fmap fmap
10:37:25 <serialhex> ok...  i think thats a bit much for me right now...
10:37:36 <kallisti> serialhex: are you familiar with Functor?
10:38:21 <serialhex> kallisti: short answer: no
10:38:27 <kallisti> ah okay.
10:38:27 <serialhex> :D
10:38:45 <serialhex> typeclassopedia intro - pooint 4 :P
10:39:00 <serialhex> point
10:39:25 <serialhex> yeah, i'm still trying to figure all this stuff out
10:39:39 <kallisti> Functor is pretty simple
10:39:47 <dmwit> kallisti: He's currently working his way through an implementation of the probability monad; his first monad, I think. He's implemented fmap, bind, and a few others. But he's still learning. =)
10:40:48 <dmwit> It's hard to see a generalization before you've seen a few specializations, though, I think.
10:40:54 <serialhex> yes, what dmwit said :D
10:42:02 <serialhex> (though the fact that i'm learning *any* monad is news to me... news that i heard before but i still dont fully grok...  all in time i imagine)
10:45:06 <monochrom> Piaget's theory. concrete before abstract.
10:46:58 <deech> Hi all, is there a reference that shows why injecting a value into a monad is called "return". Thought it might have some category theory connection but Google didn't help.
10:47:34 <dmwit> It was named that to ease imperative programmers into the world of monads.
10:47:35 <DMcGill> to confuse people coming from C-like languages
10:47:50 <deech> dmwit: seriously?
10:47:52 <dmwit> It turns out that it's more confusing than easing, but hey...
10:48:01 <dmwit> 100% serious
10:48:08 <monochrom> in category theory texts, it has a Greek name
10:48:50 <DMcGill> of course, in many cases you could use `pure' instead
10:49:01 <dmwit> It appears most often as the last line in a do-block. So that looks sort of like what imperative programmers do, doesn't it?
10:49:05 <dmwit> That was the reasoning, anyway.
10:49:08 <monochrom> "myaction = do ... return (x+1)" looked familiar for a while.
10:49:34 <spree> a quine please
10:49:41 <spree> @quine
10:49:42 <spree> @faq quine
10:49:42 <lambdabot> Maybe you meant: quit quote
10:49:42 <lambdabot> The answer is: Yes! Haskell can do that.
10:49:49 <spree> faq quine
10:49:57 <monochrom> that is, until "do ... ; if x>0 then return () else ... ; more_actions"
10:49:58 <DMcGill> http://www.iis.sinica.edu.tw/~scm/2007/a-haskell-quine/
10:50:00 <dmwit> ?where quine
10:50:01 <lambdabot> ap (++) show "ap (++) show "
10:50:09 <dmwit> > ap (++) show "ap (++) show "
10:50:11 <lambdabot>   "ap (++) show \"ap (++) show \""
10:50:47 <deech> dmwit: until you see code like "do { ... ; x <- return 1; ...; return x + y}. Yeah it should have been a "let", but just sayin'. I'm giving a small talk on how things in Haskell that confound beginners by masquerading as familiar. Record syntax is on the list too.
10:51:17 <deech> Not sure why confound is being bolded.
10:51:39 <dmwit> > let f s = s ++ show s in f "let f s = s ++ show s in f "
10:51:41 <lambdabot>   "let f s = s ++ show s in f \"let f s = s ++ show s in f \""
10:51:48 <monochrom> in any case, "η x is an action that returns x without any effect, so let's rename η to return" sounds really nice
10:51:48 <spree> dmwit what do i write ina file to make that quine work?
10:52:01 <spree> and what is ap?
10:52:16 <DMcGill> http://porg.es/blog/a-quine-in-haskell
10:52:18 <mcstar> did monads exist in haskell before haskell had monadic IO?
10:52:22 <DMcGill> that's one that works from a file
10:52:26 <DMcGill> and doesn't use `ap'
10:52:37 <dmwit> mcstar: Probably not.
10:52:40 <DMcGill> the first comment on that site
10:52:47 <monochrom> no, there was very old haskell that didn't have IO, only the "interact" function
10:52:54 <dmwit> I don't think monads existed in any language as a thing, really, before Haskell had monadic IO.
10:53:43 <spree> except that it does use ap
10:54:06 <dmwit> spree: ap is the S combinator, if you're familiar with that.
10:54:08 <dmwit> otherwise,
10:54:09 <dmwit> ?src ap
10:54:10 <lambdabot> ap = liftM2 id
10:54:42 <dmwit> Sometimes, types are more enlightening than implementations; if you feel that way about this, then you may also like
10:54:45 <dmwit> :t ap
10:54:46 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
10:55:00 <artem-art> +i
10:55:18 <DMcGill> spree: the comment on that site has a version that doesn't use ap
10:55:29 <dmwit> However, you can see above my expanded quine, which inlines the definition of ap (the "let f s = s ++ show s" bit).
10:55:47 <spree> yeah i saw it
10:57:01 <Axman6> > let f s = s ++ show s in text $ f "let f s = s ++ show s in text $ f "
10:57:03 <lambdabot>   let f s = s ++ show s in text $ f "let f s = s ++ show s in text $ f "
10:57:08 <Axman6> =)
10:57:16 <Axman6> that worked even better than expected
10:57:18 <favonia> > Just (+1) `ap` Just 1
10:57:19 <lambdabot>   Just 2
11:00:52 <favonia> mcstar, dmwit: not sure about the history of monad. it probably wasn't spelled out back then, but i guess the idea or the theoretical construct already existed.
11:08:57 <astry_> apparently it has something to do with dyads.
11:09:03 <astry_> no idea what, though.
11:15:03 <monochrom> there are 3 unrelated "monad"s
11:15:32 <monochrom> 1st monad: a philosophical idea of Leibneiz
11:16:24 <monochrom> 2nd monad: 1-ary, and dyad is 2-ary. example: "monadic 2nd order logic" refers to something being 1-ary there
11:16:37 <monochrom> 3rd monad: return, >>=, join, ...
11:19:47 <spobat> Leibniz?
11:19:56 <monochrom> yeah
11:20:03 <spobat> okey
11:24:30 <dmwit> favonia: Of course. But the existence of a theoretical term does not imply that it is used in any programming language.
11:25:00 <dmwit> I didn't mean to imply that Haskell folks invented monads. I was only asking the exact question "were monads used in Haskell (and by extension other languages) before monadic IO?".
11:26:18 <Cale> dmwit: yes I think, just a little
11:26:43 <dmwit> s/asking/answering/
11:27:21 <harrison>  there are reports that 100 grams of higgs matter has be seized by glasgow police in a raid on a flat
11:27:36 <harrison>  a zero point weapon needs only 1.5 grams or so
11:29:05 <BlairA> join #java
11:29:15 <Clint> no
11:29:20 <Peaker> BlairA, why would a Haskeller do that?
11:29:22 <monochrom> great, now the glasgow police has its own zero-point weapons and can go on to conquer the world
11:29:34 <BlairA> Because his "/" broke?
11:29:35 <zomg> Peaker: masochism
11:29:51 <monochrom> or humour
11:30:13 <Peaker> something magically enables flymake-mode in my haskell-mode buffers even when it is explicitly disabled
11:30:14 <BlairA> Also i'm still a haskell newbie!
11:30:20 <Peaker> I don't want half of my lines to be red in a big refactoring
11:30:32 <monochrom> haha
11:30:33 <Peaker> BlairA, You are thus permitted to use Java then. :-)
11:31:00 <iulian> No, he's not.
11:31:03 <iulian> Don't listen to him. :)
11:31:20 <BlairA> After reading a few things on Haskell I definately like how its going
11:31:51 <harrison> monochrom, you don't know the glasgow police
11:31:51 <Peaker> After using Haskell, it becomes very very hard to use Java
11:32:05 <harrison> Even before it isn't easy.
11:32:34 <BlairA> This is true - I am fairly big on OOP though
11:32:43 <BlairA> (for now)
11:34:26 <earthy> OOPs? :)
11:34:50 <BlairA> Object-Orientated Programming
11:34:57 <however> Peaker: s/Java/any mainstream language, and particularly anything dynamic/
11:35:32 <BlairA> I'm not a huge fan of dynamic languages - I like to have a type system to fall back on
11:35:42 <harrison> SECOND
11:35:46 <earthy> HIRD
11:35:49 <earthy> THIRD even
11:35:52 <mcstar> dynamic languages have a type system
11:36:00 <earthy> mcstar: *some* do
11:36:05 <harrison> may i make a little confession?
11:36:15 <Peaker> BlairA, do you take OOP as: A) Encapsulation B) Inheritance C) Polymorphism, or something else?
11:36:21 <mcstar> earthy: i bet, the one he has in mind has
11:36:24 <Peaker> BlairA, (I mean, as these 3 principles)
11:36:38 <harrison> i wrote a realtime raytracer .... in a certain language ...
11:36:50 <mcstar> john harrison ?
11:37:06 <Peaker> BlairA, A is great, and modules/records do that..  B and C are pretty awful though, and have much better alternatives in Haskell/FP
11:37:20 <harrison> mcstar are you thinking of GNU/harrison?
11:37:26 <BlairA> I take it as Abstraction, Polymorphism , Encapsulation and inheritance combined
11:37:30 <Cale> mcstar: It depends on how you define "type system" :)
11:37:45 <mcstar> harrison: no, the Intel one, the theorem prover, hol light..
11:37:47 <Cale> "dynamic types" aren't really types by some definitions
11:37:50 <earthy> harrison: methinks he's thinking of the HOLlight Harrison. :)
11:37:52 <Peaker> BlairA, "Abstraction" is more the goal than the method, I think
11:38:06 <earthy> (who is a cool cat)
11:38:15 <BlairA> Peaker, I guess your right
11:38:20 <harrison> no this here harrison is named from the second life "harrison partch"
11:38:42 <BlairA> Does anyone know any fairly readable haskell projects I can have a look at and try and learn how proper applications are made functionaly?
11:38:47 <Peaker> BlairA, polymorphism in OOP is really really badly done... after parameteric polymorphism + type-classes,   OOP/inheritance-based polymorphism does not seem like polymorphism at all
11:38:54 <tomboy64> i got myself a few simple exercises, namely http://www.cis.upenn.edu/~matuszek/cis554-2010/Assignments/haskell-01-exercises.html --- i solved them but i'm curious if you guys would be able to hack up a faster solution for #2 than i did: http://bpaste.net/show/33584/
11:38:56 <harrison> BlairA, what kind of app?
11:39:21 <earthy> peaker: you do know about generics in e.g. C# and Java, right?
11:40:02 <BlairA> I don't mind too much - Desktop application over web application though
11:40:09 <Cale> "A type system is a tractable syntactic method for proving the absence of certain program behaviours by classifying phrases according to the types of values they compute."
11:41:23 <jfischoff> BlairA: GUI or cmd line?
11:41:42 <Cale> By that description, dynamically typed programming languages don't have a type system, or at least, are not using whatever type system might apply to them.
11:41:45 <however> tomboy64: if you need tlaux only in this one place in tl, you can add "where" after tl and move tlaux there
11:42:07 <however> (i.e. map tlaux xs ys) zs where tlaux (x:xs) ...)
11:42:10 <Peaker> earthy, yes, but they also suck, because they don't interact well with inheritance/subtyping (covariance/contravariance of all methods in the object almost always combine to invariance)
11:42:42 <Peaker> earthy, and because they don't have type-classes, and interface inheritance is unworkable for very simple things (e.g, you can't do:  instance Show a => Show (Maybe a) where ...   in C# style generics, either you inherit from IShow, or you don't)
11:42:52 <BlairA> Either or - just something that will show me how a functional program fits together on the bigger scale
11:42:59 <jfischoff> Peaker: Could you go into more detail on ovariance/contravariance is?
11:43:12 <tomboy64> however: is it possible to give it a type definition and to define multiple auxiliary functions with where?
11:43:49 <Peaker> jfischoff, if you have:  class List<A> { ... methods here ... }  then the "A" is going to appear in covariant/contravariant positions in various methods.  Since List<A> can be considered a product/tuple of all these methods, that necessarily means List is invariant on the A.  That means if A<B, List<A> cannot be < List <B>
11:44:07 <Cale> tomboy64: yes, you can put as many type declarations and definitions in a where clause as you'd like
11:44:17 <tomboy64> cool
11:44:20 <tomboy64> thanks :)
11:44:36 <Peaker> jfischoff, for example, if you have: List<IAnimal>  it is somewhat useless, because  List<Cat> cannot be used as a List<IAnimal>  (because then what if someone adds a Dog using the base class interface?)
11:44:54 <however> tomboy64: they just all need to be indented the same amount. and here's a suggestion
11:44:56 <however> http://bpaste.net/show/33585/
11:45:26 <Peaker> jfischoff, so you can't convert List<Dog> to List<IAnimal> safely
11:45:39 <Peaker> jfischoff, (you could copy the list to a new list, of course)
11:45:50 <Peaker> but you don't have the usual sub-typing relation
11:46:56 <hpaste> DMcGill pasted “to tomboy64” at http://hpaste.org/70957
11:47:10 <jfischoff> Peaker: I'm still confused. I have a List<IAnimal> which is actually a List<Dog>. Why is not safe to call a IAnimal method on the elements? Or are you saying something else...
11:47:21 <DMcGill> s/maybe x/maybe z
11:47:37 <favonia> Cale: most "dynamically-typed" PLs do have one (and only one) type *Dynamic*! ;-) you can say their type system is extremely weak, but they indeed have one.
11:47:42 <Peaker> jfischoff, say the compiler allowed you to do:  List <IAnimal> l = myDogList;   why would it reject:  l.add(evilCat)
11:47:56 <Peaker> jfischoff, List <IAnimal> :: add    takes an IAnimal, so surely it should accept a Cat?
11:48:04 <jfischoff> yes
11:48:14 <Peaker> jfischoff, so now your List<Dog> has kittens in it.. and dogs and cats don't always get along
11:48:21 <jfischoff> write
11:48:23 <jfischoff> right hehe
11:48:27 <jfischoff> I see
11:48:30 <jfischoff> interesting
11:48:48 <Peaker> so the compiler must reject the subtype-relation/conversion from List<Dog> to List<IAnimal>
11:49:32 <favonia> jfischoff: Java unfortunately made the premitive arrays co-varient w.r.t. the element type. :(
11:49:34 <monochrom> @quote monochrom substitution
11:49:34 <lambdabot> No quotes match.
11:49:40 <Peaker> List has stuff in it that is contravariant and stuff that is covariant on the type variable. so if A<B   --/-->  List<A> < List<B>
11:49:41 <Cale> favonia: Well, sure, you can apply the trivial type system to them, but that doesn't prevent any behaviours.
11:49:41 <monochrom> @quote monochrom dilbert
11:49:41 <lambdabot> monochrom says: Dilbert's substitutability principle.  A subclass's programmer should work as a drop-in replacement of his/her predecessor.
11:49:43 <DMcGill> tomboy64: although if this is an actual exercise, using maybe and elemIndex might be a giveaway that you didn't write it
11:50:01 <Cale> favonia: I guess you can allow that degenerate sense of the term :)
11:50:05 <tomboy64> eh wat? ^^
11:50:30 <tomboy64> DMcGill: i only started learning haskell this week and i dragged this exercise off the web?
11:50:49 <DMcGill> ha, I meant that if it were an actual university exercise
11:50:49 <Cale> tomboy64: He's thinking that maybe you're in a course
11:51:21 <tomboy64> yeah. but the course was apparently due last november :p
11:51:30 <monochrom> "80% of the code is written by 20% of the programmers" etc :)
11:52:24 <jfischoff> thus 80% of the bugs
11:52:49 <tomboy64> ok. maybe and elemIndex.
11:52:57 <Cale> Peaker: I think typed OO people are way too caught up on subtype polymorphism. It probably has something to do with the fact that most of the typed OO languages tie type definitions and method implementations together, so that you absolutely need to use subtype polymorphism in order to have more than one implementation of anything.
11:53:33 <Cale> (almost)
11:53:52 <DMcGill> tomboy64: do you know of hoogle? It's a haskell search engine for functions
11:54:11 <tomboy64> i've heard and read of it - but never used it
11:54:25 <Peaker> Cale, Yeah, one big mistake that really makes it impossible to have a good type system
11:54:36 <DMcGill> you can also call it in here, (although please don't spam it)
11:54:38 <DMcGill> @hoogle elemIndex
11:54:39 <lambdabot> Data.List elemIndex :: Eq a => a -> [a] -> Maybe Int
11:54:39 <lambdabot> Data.ByteString.Char8 elemIndex :: Char -> ByteString -> Maybe Int
11:54:39 <lambdabot> Data.ByteString.Lazy.Char8 elemIndex :: Char -> ByteString -> Maybe Int64
11:56:08 <dmwit> tomboy64: What's that "if (null xs)" check doing there?
11:56:11 <dmwit> That looks like a bug to me.
11:56:23 <tomboy64> thanks. just looked it up in google ^^
11:56:24 <aib> monochrom: do you have a reference for the dilbert thing?
11:56:53 <monochrom> no. I created it.
11:57:10 <dmwit> tomboy64: e.g. I would expect that you would find your implementation to have tl "a" "A" "a" = "a" rather than tl "a" "A" "a" = "A", as it ought to be.
11:57:25 <tomboy64> dmwit: i pattern-match for x:xs, then recurse over that. when it looped through all the xs, only [] is left. that's what null xs checks for.
11:57:34 <tomboy64> @null []
11:57:35 <lambdabot> Maybe you meant: tell url
11:57:39 <tomboy64> -.-
11:57:41 <aib> good one :)
11:57:45 <tomboy64> how do i execute code?
11:57:58 <Cale> tomboy64: What happens if you call tlaux "" "foo" 'a'
11:57:59 <dmwit> > null []
11:58:01 <lambdabot>   True
11:58:07 <dmwit> Cale: The instructions say not to worry about that.
11:58:12 <Cale> ah
11:58:36 <dmwit> tomboy64: But, compare this:
11:58:46 <dmwit> > let x:xs = "a" in (null "a", null xs)
11:58:47 <lambdabot>   (False,True)
11:59:21 <dmwit> tomboy64: As for how I would do it, well, you might like the "zip" and "lookup" functions. =)
11:59:24 <dmwit> :t lookup
11:59:26 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
11:59:29 <Cale> tomboy64: ghci myFile.hs
11:59:42 <Cale> tomboy64: and then type an expression and press enter :)
12:00:22 <Cale> tomboy64: or do you mean something else?
12:00:41 <tomboy64> Cale: i meant in here - what dmwit did with >
12:00:43 <rwbarton> this looks like a case of "an argument to my function is a list, better write (x:xs)"
12:00:45 <Cale> oh
12:00:51 <tomboy64> > null {[
12:00:52 <lambdabot>   <no location info>: parse error on input `['
12:00:57 <tomboy64> > null []
12:00:58 <lambdabot>   True
12:01:09 <dmwit> rwbarton: yeah =)
12:01:42 <tomboy64> @hoogle lookup
12:01:42 <lambdabot> Prelude lookup :: Eq a => a -> [(a, b)] -> Maybe b
12:01:42 <lambdabot> Data.List lookup :: Eq a => a -> [(a, b)] -> Maybe b
12:01:42 <lambdabot> Data.HashTable lookup :: HashTable key val -> key -> IO (Maybe val)
12:04:10 <Cale> tomboy64: in any case, you could write: http://bpaste.net/show/6cJrjvrIXfuJ5OpCIVXL/
12:04:14 <tomboy64> however: i know what the pattern-matching thingy does. but what stands _ for in tlaux (x:[]) _ z = z ?
12:04:43 <Cale> _ is a wildcard which matches anything and does not bind a variable
12:04:45 <however> tomboy64: it just means "i won't use this parameter"
12:05:02 <however> just to make visually stand out which of the parameters are important
12:05:09 <tomboy64> ohhh
12:05:11 <Cale> note also that [x] and x:[] are the same thing
12:05:24 <tomboy64> yeah
12:05:27 <tomboy64> that is clear
12:05:42 <dmwit> Wait, why are we writing more code that has the same bug in it?
12:05:55 <Cale> I'm not sure what this function is meant to compute
12:06:03 <Cale> So I didn't change its semantics
12:06:17 <rwbarton> it's apparently supposed to be tr///
12:06:20 <dmwit> It's supposed to be a Haskell version of the tr command.
12:06:24 <dmwit> roughly
12:06:31 <Cale> ah, okay
12:06:33 <copumpkin> Cale: you going to hac phi?
12:06:45 <dmwit> copumpkin: Look on the public attendees list. =)
12:07:11 <copumpkin> it's hard to know whether that's up to date
12:07:31 <dmwit> I keep it up-to-date.
12:07:35 <copumpkin> sweet
12:08:16 <Cale> Probably not? I dunno, I could probably afford to go now :P
12:08:33 <tomboy64> grrr
12:08:46 <tomboy64> when i did "import" in ghci - how do i get rid of the module again?
12:08:54 <dmwit> :m - ModuleName
12:08:54 <acowley> :m -Foo
12:08:59 <tomboy64> !
12:09:01 <tomboy64> thanks
12:09:10 <acowley> I guess it depends if your module is called "ModuleName" or "Foo"
12:09:21 <Cale> heh
12:09:41 <dmwit> Cale: You should totally come. It's fun, there's lots of Haskell folks there to exchange ideas with, plus there's free food and shirts and stuff maybe.
12:09:41 <Cale> copumpkin: In any case, this is the first I've heard of it, so I had no specific plan
12:09:49 <rwbarton> I believe ModuleName is in the package-name package
12:09:54 <copumpkin> Cale: you know you want to
12:09:57 <acowley> I'll be there!
12:10:01 <Cale> It's in the US and I still don't have a passport.
12:10:07 <dmwit> Cale: See? All the cool people will be...
12:10:07 <Cale> lol
12:10:14 <dmwit> aw, not in the US
12:10:20 <copumpkin> Cale: well, that's going to have to change eventually anyway!
12:10:29 <copumpkin> so you might as well accelerate the passport acquisition
12:11:07 <Cale> copumpkin: Not if I succeed in my 5 year plan of becoming a brain floating in a jar with electrodes hooked up to it.
12:11:12 <copumpkin> lol
12:12:00 <jfischoff> Cale: where are you?
12:12:07 <tomboy64> :t null
12:12:08 <Cale> jfischoff: Brantford, Ontario
12:12:08 <lambdabot> forall a. [a] -> Bool
12:12:31 <jfischoff> aye
12:13:28 <dmwit> Canada is close, and has really good relations with the US.
12:13:32 <dmwit> It should be a snap to get here.
12:13:49 <dmwit> Though a month is a bit short timing for burocratic things like passports.
12:13:57 <dmwit> Also, screw the French and their spelling.
12:14:02 <DMcGill> tomboy64: hoogle's website is better than calling it from irc
12:14:03 <copumpkin> you can get one in a day if you try hard enough
12:14:05 <DMcGill> @where hoogle
12:14:05 <lambdabot> http://haskell.org/hoogle
12:14:38 <dmwit> bureaucratic
12:14:46 <BlairA> Anyone in the UK?
12:14:47 <T_X> hm, I have a function with a type signature like: 'foofunc :: (RandomGen g) => g -> Integer -> Integer -> Integer -> Integer -> Integer -> Integer -> (Integer, Integer, Integer)'. I would like to have something like: 'foofunc :: (RandomGen g, i :: Integer) => g -> i -> i -> i -> i -> i -> i -> (i, i, i)', but that doesn't work
12:14:56 <T_X> how do you guys usually shorten such signatures?
12:15:10 <herzogharker> type i = Integer
12:15:11 <dmwit> You can write (RandomGen g, i ~ Integer) =>
12:15:14 <Cale> T_X: you could write i ~ Integer
12:15:19 <dmwit> ore type I = Integer, yep
12:15:20 <Cale> T_X: with extensions
12:15:35 <dmwit> But even better than that is to make your type be less sucky. ;-)
12:15:48 <Cale> T_X: but it really looks like you need to define some data structures, yeah
12:15:53 <herzogharker> indeed.
12:15:55 <dmwit> data Arguments = Arguments { omg, real, names, what, are, those :: Integer }
12:15:57 <T_X> dmwit: hehe, I expected that answer ;)
12:16:10 <monochrom> a month for passport is enough if you pay more money. in canada.
12:16:30 <dmwit> Hey, that's even the right number of arguments by accident!
12:16:44 <however> T_X: if you have a function with 38 arguments, you probably forgot a few
12:16:56 <rwbarton> type Spam = Integer
12:17:04 <dmwit> I would also like to point out that any function which takes a random generator and doesn't return one is a bit suspect.
12:17:34 <monochrom> unless it returns an infinite stream of random numbers
12:17:40 <T_X> but I thought that in this special case it might actually be more readable as it's closer to the algorithm definition then (socialist millionaire protocol, as defined on wikepedia or in the OTR draft)
12:17:59 <Cale> ah, okay
12:18:24 <Cale> Well, if you're trying to produce a document which follows along with some pre-existing description, then do whatever you like :)
12:18:39 <dmwit> Did that sentence just turn kata halfway through?
12:19:20 <dmwit> Ah, I can parse it if I don't autocorrect "then" to "than".
12:19:23 <SegFaultAX> What does ~ mean in a type constraint? Is it the same thing as in pattern match? (eg lazy evaluation of the constraint)
12:19:34 <dmwit> SegFaultAX: It is an assertion of equality.
12:20:05 <monochrom> "a ~ Int" in a type constraint means "a equals Int"
12:20:10 <SegFaultAX> dmwit: Ah, so like saying i ~ Integer must be exactly of type Integer?
12:20:47 <Cale> SegFaultAX: It means that i must be the type Integer
12:20:51 <dmwit> i ~ Integer means the type variable i must be exactly the type Integer, yes.
12:21:10 <dmwit> I can't tell whether that's what you said in your question or not, though. =P
12:21:16 <SegFaultAX> So the (Int i) format is for typeclasses only?
12:21:25 <monochrom> yes
12:21:29 <Cale> Since i is itself a type, it doesn't have a type as such, but it has a kind, which in this case is *
12:21:33 <DMcGill> why would you want to constrain equality on types when you could just use the same variable?
12:21:48 <dmwit> DMcGill: Usually you aren't equating two variables.
12:22:02 <T_X> hm, how evil is it to use type extensions - is it more or less evil than introducing a global 'type I = Integer'?
12:22:04 <dmwit> e.g. you might equate Foo a and Bar b, where Foo and Bar are type functions.
12:22:08 <monochrom> "a ~ Int" is just a dumb example
12:22:25 <however> T_X: a type I seems very benign to me
12:22:32 <dmwit> T_X: I think I would prefer type I = Integer, if this was the only thing requiring an extension.
12:22:39 <Cale> T_X: That's up to you to decide. If you care about being able to use your program in Hugs or JHC or something, then it might matter to you.
12:23:02 <monochrom> type extensions are not evil
12:23:35 <Cale> type extensions are delicious candy
12:24:03 <Alegend45> I may be new to Haskell, but at least I have experience with Common Lisp.
12:24:10 <SegFaultAX> What's a type extension (was that covered in LYAH, I can't remember)?
12:24:43 <Cale> SegFaultAX: Extensions to the type system made by GHC (and other implementations of Haskell) which are not in the standard.
12:25:01 <herzogharker> SegFaultAX: not covered in LYAH, no
12:25:09 <T_X> how evil are type extensions in the case of FLOSS? (then I guess you'd want Hugs and JHC compatibility - or maybe not because ghc can be used by anyone anyway?) ok - but maybe this is getting unnecessarily "philosophical" now and I should just pick one :D
12:25:36 <Peaker> I think GHC's commonly used extensions should probably be "the standard". The Haskell report is not really an important document in practice, afaiu
12:25:51 <monochrom> the reason is non-trivial, though. all type extensions went through both theoretical scrutiny and practical scrutiny, that's why. not your usual "PEP process of resolution by very loud arguments"
12:26:18 <Cale> T_X: Pretty much every serious project is using GHC, but obviously, if you can have more compatibility without much effort, it might be worth trying to avoid using extensions to the language.
12:26:23 <SegFaultAX> What would a simple example of a type extension be?
12:26:34 <Peaker> NoMonomorphismRestriction :)
12:26:35 <Cale> T_X: However, there are a lot of really good extensions in GHC which can save you a lot of trouble.
12:26:37 <monochrom> RankNTypes
12:26:45 <Peaker> ScopedTypeVariables
12:26:52 <T_X> hm, ok. thanks!
12:26:54 <Cale> TypeFamilies
12:26:59 <Cale> GADTs
12:27:07 <Peaker> he said simple
12:27:22 <Cale> ghc --supported-languages  will give a list of extensions
12:27:33 <monochrom> "simple" is subjective
12:27:39 <Cale> What, TypeFamilies aren't simple enough? ;)
12:28:08 <monochrom> but RankNTypes has the benefit of being the 2nd shortest name in the names mentioned
12:28:38 <Cale> PolyKinds
12:28:49 <Peaker> monochrom, But unfortunately it starts with 'R' which is pretty far into the alphabet
12:28:51 <Cale> now it's 3rd
12:30:50 <SegFaultAX> Someone should update the /topic, haskell.org seems to be back.
12:31:21 --- mode: ChanServ set +o monochrom
12:31:28 <dmwit> ?topic-tail
12:31:28 <lambdabot> Plugin `topic' failed with: Prelude.last: empty list
12:31:31 --- topic: set to '["Haskell Platform 2012.2: http://bit.ly/Clv5r ","Paste code/errors: http://hpaste.org/new/haskell ","GHC 7.4.2: http://is.gd/EllZnn ","Haskell News: http://reddit.com/r/haskell ","The Haskell programming language http://haskell.org ","Logs: http://bit.ly/5mwtRQ ","admin/spam issues: #haskell-ops "]' by monochrom
12:31:46 --- mode: monochrom set -o monochrom
12:32:12 <SegFaultAX> That's an awesome way to manage the chan topic.
12:32:39 <Cale> if only it worked :P
12:32:46 <dmwit> Nobody uses it, though, and even if I had typed the command correctly I probably don't have permissions. =P
12:32:55 <dmwit> ?topic-tail #haskell
12:33:02 <dmwit> right
12:33:08 <monochrom> not so awesome when you want to update the 6th item there.
12:33:29 <Peaker> it should be: ?topic (nth 6) tail
12:33:30 <dmwit> Better than a stick in the eye.
12:33:32 <nand`> how about ?topic-modify <expression>; which evaluates it using mueval
12:33:39 <monochrom> "hi, how do I update the 6th item in a list?" is a common newbie question with the common answer "just don't"
12:33:49 <nand`> (and assumes expression has type :: [String] -> [String])
12:33:54 <serialhex> dmwit: most things are better than a stick in the eye...
12:34:16 <dmwit> map (if i == 6 then (++"dmwit rocks lulz"))
12:34:27 <dmwit> gaiz my codez don`t work
12:34:52 <nand`> the way I'd update the 6th item in a list: define a van laarhoven lens for for different indices, using splitAt
12:35:08 <MostAwesomeDude> Hey, is there something somewhere in base that does roughly the same thing as \x -> let s = "Fixed-length predictable string" in s !! (x `mod` length s)
12:35:25 <MostAwesomeDude> I'm munging text and would like one of these.
12:35:58 <nand`> then (ix 6 ^= "foo, bar") mylist
12:36:10 <monochrom> speaking of the devil and !!
12:36:13 <nand`> or ix 5
12:36:39 <dmwit> > cycle "Fixed-length predictable string" !! 356
12:36:40 <lambdabot>   'e'
12:36:45 <dmwit> efficiency is for suckers
12:36:52 <monochrom> heh
12:37:00 <nand`> dmwit: :)
12:37:34 <Alegend45> Exactly what a C programmer would smirk about at Common Lisp.
12:37:47 <Alegend45> Weirdly, I happen to know both.
12:37:50 <MostAwesomeDude> Well, I wrote mine based on how I would do it in Python.
12:37:55 <MostAwesomeDude> I suppose I would do the same thing in C.
12:38:06 <nand`> in C I would first implement common lisp
12:38:12 <Alegend45> I was talking about dmwit's comment.
12:38:23 <Alegend45> Or C++.
12:38:26 <serialhex> haskell takes a very different mindset (i'm currently learning this mindset)
12:38:39 <BlairA> This mind set hurts my brain :(
12:38:46 <nand`> I'd say “imperative languages take a very different (and strange) mindset”
12:38:50 <monochrom> C programmers can smirk at their stupid strcat(strcpy(x,y), z) as far as I'm concerned
12:38:51 <Alegend45> Hurts mine too.
12:39:04 <Taneb> Hey
12:39:04 <serialhex> monochrom: that hurts my brain!
12:39:06 <SegFaultAX> nand`: That's kind of a "to bake an apple pie, you must first invent the universe" kind of approach, no?
12:39:13 <MostAwesomeDude> I'm glad that I *can* do it in Haskell, but I'd like something with a lower running time.
12:39:17 <Taneb> I've got a Map (Int, Int) Char, and I want to print it in a grid
12:39:18 <nand`> SegFaultAX: was that re: inventing common lisp?
12:39:19 <Alegend45> With C++ Strings, that would be y + z.
12:39:28 <MostAwesomeDude> Preferably something in O(length of list) and not O(x).
12:39:29 <SegFaultAX> nand`: Yes. :)
12:39:31 <BlairA> Decided to try a sudoku solver - I can't even read in the data the way I want it
12:39:37 <nand`> SegFaultAX: I was just making a joke, based on https://en.wikipedia.org/wiki/Greenspun%27s_Tenth_Rule
12:39:48 <dmwit> Taneb: Use ncurses, it's the only way.
12:39:53 <DMcGill> BlairA: have you seen Hutton's? He just uses [[Int]]
12:39:58 <SegFaultAX> nand`: I know.
12:40:07 <nand`> MostAwesomeDude: do you want O(1) indexing?
12:40:09 <BlairA> Where can I find that?
12:40:16 <Cale> I learned Common Lisp after Haskell, and it seemed oddly painful to do functional programming in it, which I found kinda surprising.
12:40:25 <BlairA> Its my first program I guess I'm allowed to be confused
12:40:32 <SegFaultAX> nand`: It just made me think of: http://www.youtube.com/watch?v=zSgiXGELjbc
12:40:51 <nand`> I learned half of scheme before Haskell. I never bothered with the other half.
12:41:05 <serialhex> i heard a quote somewhere - that any sufficently long-running project eventually invents a usually poor copy of a lisp interpreter....  or something like that <- poor misquote :'(
12:41:08 <Taneb> dmwit, EVEN BETTER IDEA
12:41:09 <Nimatek> nand`: You never bother with the closing brackets?
12:41:10 <nand`> that should about sum up my stance on those languages
12:41:13 <DMcGill> http://cs.nott.ac.uk/~gmh/sudoku.lhs
12:41:14 <monochrom> I learned lisp first (i.e., before other functional languages), and I was already disappointed at its functional programming lackings
12:41:14 <Taneb> (they're inherently bounded)
12:41:17 <MostAwesomeDude> nand`: Meh. I'll settle for not taking hundreds of iterations to index into a 16-char string.
12:41:20 <nand`> Nimatek: no. All of my scheme programs were unbounded
12:41:31 <Nimatek> nand`: Awesome!
12:41:56 <nand`> Nimatek: who needs closing brackets either way? After all, every function can only have one argument, it should be obvious where to terminate an expression
12:42:04 <monochrom> I forgot the detailed reason but it had something to do with "map f xs" requiring special incantations for f
12:42:16 <raek> serialhex: http://c2.com/cgi/wiki?GreenspunsTenthRuleOfProgramming
12:42:41 <serialhex> THATS IT!!!  :D
12:42:45 * nand` feels ignored
12:42:54 <serialhex> thx raek
12:42:55 <rwbarton> yes, even clisp
12:42:57 <monochrom> in retrospect, it seems lisp designers were more interested in list processing than functional programming
12:43:08 <SegFaultAX> monochrom: Weird.
12:43:28 <nand`> monochrom: heretics, all of them
12:43:50 <BlairA> DMcGill : Thanks
12:44:16 <Alegend45> I once partially wrote a CAS in Lisp.
12:44:23 <Alegend45> Wrote a better one in C++.
12:44:34 <monochrom> I also didn't like "oh, f has a value binding and a function binding, they are distinct". this was probably ahead of its time. now perl and javascript are full of that.
12:45:18 <jfischoff> Alegend45: Computer Algebra System?
12:45:28 <dmwit> ?remember monochrom in retrospect, it seems lisp designers were more interested in list processing than functional programming
12:45:29 <lambdabot> It is stored.
12:45:30 <nand`> Alegend45: then you ported it to the haskell type system
12:45:58 <Cale> monochrom: Yeah, that's exactly the sort of thing I mean.
12:46:18 <monochrom> functions are not quite first-class in lisp
12:46:35 <dmwit> This joke is impossible to explain to someone who hasn't been exposed to programming very much.
12:46:55 <monochrom> err, what joke? :)
12:47:00 <nand`> monochrom's?
12:47:04 <dmwit> Was that not a joke?
12:47:15 <dmwit> I thought it was rather funny, considering "lisp" stands for "list processing". =)
12:47:19 <nand`> I did too
12:47:28 <nand`> but the best jokes are the ones with a hint of truth in them
12:47:28 <monochrom> I was not joking. but you're free to interpret it :)
12:47:55 <monochrom> but yes I did make it pun on "lisp" and "list processing"
12:48:21 <nand`> it's more funny in a “well, that was so painfully obvious all along” way
12:48:57 <monochrom> yeah, the joke should be on me, why did I even expect functional programming in lisp? :)
12:49:04 <dmwit> right =)
12:49:26 <clsmith> it is weird, 'functional programming' seems to now have two completely unrelated meanings
12:49:34 <nand`> lisp is a relic of the functional stone age in which side effects were implicit
12:50:08 <monochrom> I think I was not expecting functional programming even. I was expecting uniformity, orthogonality, etc.
12:50:16 <nand`> “elegance”?
12:51:03 <monochrom> if I have done (setq x 1), then I expect (+ x 2) to mean (+ 1 2). substituting equal for equal, no?
12:51:28 <tazjin> Is there something like a -fno-warn-orphan-instances flag? I can't get rid of those instances but the warnings are annoying me
12:51:29 <monochrom> so if I have done (setq f <some function here>), I expect (map f xs) to work too.
12:51:46 <nand`> tazjin: -fno-warn-orphans ?
12:51:55 <tazjin> nand`: Ah great, thanks
12:51:59 <nand`> tazjin: tab completion to the rescue
12:52:23 <tazjin> :)
12:52:34 <monochrom> or maybe it does. I forgot what failed
12:52:54 <raek> monochrom: different lisps treat that differently. in Scheme and Clojure (map f xs) works as you expect
12:53:06 <clsmith> monochrom: meh, no, it's full of that sort of thing. and how you can't map f if f is a macro, and things. unpleasant.
12:53:30 <raek> (Common Lisp and Emacs Lisp have two namespaces for some reason, though)
12:53:54 <Sunnyday> http://i.imgur.com/9iOd6.jpg HELP ME PLEASE
12:54:19 <shapr> Sunnyday: I think you're on the wrong channel.
12:54:32 <monochrom> not going to view a stranger's url
12:54:42 <nand`> it's fairly harmless
12:54:55 <Sunnyday> Its my attempt at using google sketch to draw a 3d gear
12:55:01 <clsmith> i kinda feel like lazy evaluation renders macros pretty much irrelevant anyway
12:55:05 <Sunnyday> And I'm really bad at drawing 3d
12:55:07 <ion> in Haskell?
12:55:09 <Sunnyday> can u help me?
12:55:19 <Sunnyday> I want to draw it "algorithmically"
12:55:21 <clsmith> lol
12:55:22 <shapr> Sunnyday: Not unless you're using ImplicitCad
12:55:27 <Cale> Sunnyday: What made you think to ask #haskell?
12:55:37 <Sunnyday> Because you are all FUCKING GENIUSES!!!!
12:55:38 <ion> sunnyday: Sure. What’s the type of your function? What’s the error from GHC?
12:55:45 <shapr> Here's algorithmic drawing: https://github.com/colah/ImplicitCAD
12:55:46 <nand`> ?faq Can Haskell draw 3D gears?
12:55:46 <lambdabot> The answer is: Yes! Haskell can do that.
12:55:54 <shapr> @hackage ImplicitCAD
12:55:54 <lambdabot> http://hackage.haskell.org/package/ImplicitCAD
12:56:06 <Sunnyday> GHC?
12:56:22 <monochrom> I guess all of you are bored
12:56:26 <Sunnyday> How do I get a GHC opening program?
12:56:36 <SegFaultAX> clsmith: What makes you say that? Those seem to be mostly unrelated concepts.
12:57:04 <tazjin> Sunnyday: GHC is written in Haskell, so it should be able to open (i.e. compile) itself
12:57:21 <shachaf> GHC is written in GHCskell.
12:57:35 <shachaf> I doubt there's anything else that can compile GHC right now.
12:57:55 <serialhex> GHCskell?? :P
12:58:04 <tazjin> ?faq Can Haskell algorithmically generate programs that can compile GHC?
12:58:04 <lambdabot> The answer is: Yes! Haskell can do that.
12:58:05 <Cale> Usually you don't want to compile GHC yourself. Just get the appropriate binary for your platform (which you will need in order to compile it in any case)
12:58:06 <nand`> Haskell + GHC extensions?
12:58:24 <nand`> tazjin: easy, program a GHC quine
12:58:31 <nand`> should be trivial
12:58:32 <shachaf> Cale: But I want to -fomit-loops!
12:58:43 <shapr> I always read that as "vomit loops".
12:58:58 <tazjin> nand`: Hmm, I wonder what Google would do if you submitted that as a GSoC project
12:59:04 <nand`> I want to compile GHC with -O3
12:59:16 <Sunnyday>  OK how do I make a 45 degree bevel gear that meshes with smaller 45 degree bevel gears and have the same rate of tapering so they all mesh perfectly involute?
12:59:40 <nand`> tazjin: “One small step for Haskell, one giant leap for compilers”
12:59:54 <nand`> “Next-generation compilers: Compilers that can generate themselves”
13:00:01 <ion> sunnyday: Have you tried turning it off and on again?
13:00:05 <shapr> ion: ouch
13:00:07 <nand`> Of course I would keep the fact that it's just a quine hidden
13:00:21 <shapr> Sunnyday: You're asking the wrong channel, #haskell doesn't specialize in 3D design.
13:00:23 <tazjin> nand`: That makes it sound awfully like "One step away from Skynet"
13:00:40 <ion> Skynet is a quine?
13:00:41 <shapr> Sunnyday: ImplicitCad is the most useful Haskell tool for your purposes, but I don't think it will solve all your problems.
13:00:53 <nand`> is ImplicitCAD programmable in Haskell?
13:00:58 <ion> nand: yes
13:01:22 <tazjin> ion: No, but the "generate itself" part has a certain AI'ish ring to it
13:01:33 <shapr> nand`: Yah, check it out: http://christopherolah.wordpress.com/2012/02/06/implicitcad-0-0-1-release/
13:01:55 <nand`> “Super-quine: A program that can output an improved copy of itself”
13:01:55 <shapr> So Sunnyday could do what he wants with ImplicitCAD, but first he'd need to know how to do 3D design of gears :-)
13:02:14 <monochrom> I saw Christopher Olah last night. Toronto Haskell meeting
13:02:41 <nand`> “The first release was 0.0.0 because 0 is the true first ordinal.” :)
13:02:45 <Taneb> nand`: main = putStrLn (let x = x in x) will eventually output a version of itself that outputs itself in finite time!
13:02:46 <monochrom> everyone should come to Toronto haskell meetings!
13:02:48 <shapr> Sunnyday: If you want a short cut, try finding 3D design files for lego gears, they use an angle close to 45 degrees.
13:03:21 <serialhex> monochrom: excellent!  now i just need to find a cheap flight from florida to toronto!  :P
13:03:21 <Alegend45> I should really create an emotional AI in haskell.
13:03:25 <nand`> Taneb: for some meaning of the word “eventually”
13:03:34 <Taneb> :P
13:03:43 <nand`> Alegend45: @vixen !
13:03:44 <serialhex> Alegend45: and how would one accomplish this feat??
13:03:45 <ion> nand: 0.0.0 > 0
13:04:08 <nand`> ion: I look forward to release ω
13:04:16 <Alegend45> I dunno.
13:04:26 <monochrom> he has demoed ImplicitCAD several times (in several Toronto haskell meetings)
13:04:32 <Alegend45> Either that, or make a C compiler.
13:04:44 <serialhex> a C ompiler in haskell??  :P
13:05:03 <Alegend45> I know, it's kinda weird.
13:05:04 <monochrom> pretty nice EDSL he has
13:05:23 <Alegend45> At least the language is better for the task.
13:05:31 <serialhex> i've actually wondered why there isn't a C-interpreter - like GHCi for C (besides the fact that it'd probably be *stupidly* painful)
13:05:55 <monochrom> I saw a casio calculator that could do C. that would be an interpreter.
13:05:56 <parcs`> @google c repl
13:05:57 <lambdabot> http://neugierig.org/software/c-repl/
13:05:57 <lambdabot> Title: c-repl
13:06:03 * hackagebot web-routes-boomerang 0.27.0 - Library for maintaining correctness and composability of URLs within an application.  http://hackage.haskell.org/package/web-routes-boomerang-0.27.0 (JeremyShaw)
13:06:22 <serialhex> parcs`: showoff  -_-  :P
13:06:41 <parcs`> lambdabot's the showoff!
13:07:16 <Alegend45> I REALLY don't want to manually lex and parse C code in C++ again... O_O
13:07:21 <nand`> https://github.com/martine/c-repl <- it's even written in Haskell! (not sure if that's the one lambdabot linked)
13:07:50 <serialhex> yeah, lambdabot is pretty damn cool!
13:08:08 <nand`> except for the race conditions. those can be annoying
13:08:32 <serialhex> nand`: thats not the link it gave, but it's the soft it links to :P
13:09:31 <mcstar> if you need a repl just pick common lisp or scheme and forget curly braces
13:09:47 <nand`> if you need a repl just pick haskell and forget parentheses
13:10:12 <mcstar> in time, maybe
13:10:32 <mcstar> haskell is supposed to run whole-program compiled
13:11:03 <monochrom> hugs doesn't
13:11:43 <mcstar> yeah, i read it supported incremental development better, but i dont think it can compete with CL in this regards
13:11:46 <mcstar> -s
13:11:46 <monochrom> I think there is a hackage package for C parsing?
13:11:57 <parcs`> language-c
13:12:02 <nand`> eh? I do development in GHCi pretty much all the time
13:12:13 <nand`> between :l and local tests it goes a long way
13:12:41 <Sunnyday> Better: http://i.imgur.com/Wfz7a.png
13:13:12 <monochrom> incremental or not, if you need to enter 10 lines as one unit, you need an editor, not a repl
13:13:56 <serialhex> i really like having a repl... though it'd be even better to have something like pry for ruby: http://pry.github.com/
13:14:00 <mcstar> id love to see ghci compiling code on the file, and load it up, function by function
13:14:04 <jfischoff> there is also language-c-quote
13:14:09 <tazjin> monochrom: What about something like the Light Table concept?
13:14:15 <jfischoff> and there is c interpreter
13:14:19 <monochrom> I don't know
13:14:20 <hpaste> identity pasted “fclabels stuff” at http://hpaste.org/70960
13:14:26 <serialhex> tazjin: that just looks awesome!
13:14:41 <identity> Would someone care to take a look at my question in that link?
13:14:41 <mcstar> but this kind of static typing, that haskell supports, doesnt fit well the common lisp approack
13:16:18 <mcstar> someone has Paint-fu
13:16:31 <monochrom> light table should be good
13:17:04 <mcstar> now thats again, different
13:17:16 <mcstar> basically, it evaluates the code after each modification
13:17:24 <mcstar> i find it a bit weird
13:17:38 <tazjin> I think Leksah does that as well
13:17:55 <mcstar> and initially it seems like a good idea, that you can try your snippets on many inputs, but i guess it will become annoying and distracting
13:18:01 <mcstar> but thats inho
13:18:17 <mcstar> imho*
13:18:34 <identity> Any takers? "fclabels stuff" at http://hpaste.org/70960
13:18:35 <tazjin> I'll stay with Sublime + SublimeHaskell and the occasional vim for now
13:18:59 <tazjin> SublimeHaskell runs cabal build on each save to a source file
13:19:08 <serialhex> i like the idea of having the code of the function you are working with readily available - even if it is something you just wrote (esp even!)
13:20:34 <Sunnyday> http://i.imgur.com/VEzcG.jpg
13:20:56 <shapr> Sunnyday: At this point, you're just spamming links. Be nice, or else.
13:21:03 --- mode: ChanServ set +o shapr
13:21:08 <tazjin> Sunnyday: Why am I looking at that.
13:21:27 <shapr> Sunnyday: If you post another completely irrelevant link, I will remove you from the discussion.
13:21:45 <shapr> hoi doaitse, hoe gaat het met jou?
13:22:16 <mcstar> > reverse "hoi doaitse, hoe gaat het met jou?"
13:22:18 <lambdabot>   "?uoj tem teh taag eoh ,estiaod ioh"
13:22:26 <mcstar> no, doesnt make sense
13:22:33 <shachaf> Dutch makes more sense forwards than backwards.
13:22:34 <shapr> mcstar: It's Dutch :-)
13:22:41 <shachaf> Unlike certain other languages.
13:23:01 <thoughtpolice> shachaf: which languages are those?
13:23:07 <tazjin> Dutch is basically somebody trying to speak Swedish/German, but with a terribly sore throat
13:23:12 <nand`> notably Hsilgne
13:26:41 <DMcGill> my favourite quote about languages is that to speak Danish, you need to know English and German and then get drunk
13:27:22 <nand`> reminds me of http://youtu.be/s-mOy8VUEBk
13:27:45 <serialhex> DMcGill: ooh!  3 languages for the price of 2! (and some beer!!)
13:27:54 <DMcGill> nand` has it
13:28:22 <DMcGill> http://youtu.be/BZXcRqFmFa8 is pretty interesting to
13:30:29 <shapr> DMcGill: I do know that German was much easier to understand after I learned Swedish.
13:35:23 <shapr> But, does point free golfing of Haskell make Perl easier to understand?
13:38:30 * shapr hugs dylukes 
13:38:56 <shapr> It's funny how #haskell gets really quite sometimes, but usually when there's lots more Haskell discussion on other channels.
13:39:20 <nand`> shapr: no (re: perl)
13:39:47 <nand`> point free haskell is incomprehensible but logical. perl is just incomprehensible
13:40:11 <dylukes> ohey
13:40:29 <serialhex> nand`: +1  - alsp php
13:41:02 <mel-> shapr: where are these discussions? :)
13:42:01 <shapr> mel-: Oh, various other channels including the canonical non-Haskell channel, #haskell-blah
13:42:02 <monochrom> the centre of the storm is quiet
13:42:11 <shapr> monochrom: Because it's full of CODE!
13:42:21 <shapr> Though at the moment my code is mostly javascript.
13:42:25 <shapr> mel-: Hi, are you learning Haskell?
13:42:26 <shachaf> Canon-haskellical.
13:42:54 <shachaf> I recommend not having any Haskell discussion in #-blah.
13:43:38 <mel-> shapr: yes
13:49:13 <shapr> mel-: Have you already seen the standard tutorials and free online books?
13:53:16 <mkscrg> does #haskell-blah still exist? can't find it
13:53:24 <shapr> mkscrg: It does still exist.
13:53:45 <mel-> shapr: yes. a subset of the available resources I think. I enjoy the fact there's excellent documentation freely available.
13:53:59 <mel-> shapr: but please don't ask me if i understood monads yet. :-P
13:54:07 * mkscrg found it
13:54:30 <shapr> Heh, that's okay. I think monads are much like objects, being able to use them is enough for awhile.
13:55:31 <mel-> shapr: if i understood something during my math courses it's basically this: don't worry if you don't understand something at first. just try to USE it. understanding it will come afterwards. i have a slight hope that's is similar here. :)
13:56:18 <shapr> mel-: I agree, I think that works.
13:56:43 <ion> It’s very likely not a good idea to try to understand monads before using a bunch of them.
13:56:49 <ion> in the context of Haskell
13:57:27 <ion> It’s probably best to see how a bunch of individual functors, applicative functors and monads are done and sooner or later you’ll get it.
13:57:43 <mel-> and when i got it, i will write a TUTORIAL on monads!!11
13:57:44 <mel-> ;-)
13:58:17 <ion> Also:
13:58:19 <ion> @where typeclassopedia
13:58:20 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
13:58:49 <mel-> thanks
13:59:29 <shapr> mel-: Hah, I think that's a rite of passage in the Haskell world, write your own monad tutorial!
13:59:42 <mel-> shapr: :)
13:59:57 <mel-> i wonder if other languages have something similar.
14:01:52 <nand`> there's also “write the fibonacci function”
14:01:52 <mcstar> shapr: still planning on kicking someone?
14:02:03 * shapr looks at Sunnyday
14:02:11 <nand`> not exactly a rite of passage
14:02:15 <nand`> but still a canonical landmark
14:02:17 --- mode: shapr set -o shapr
14:02:21 <mdmkolbe> Using the Criterion package, I'm getting 3 outliers (out of 1000 samples) that are severely inflating the variance/std deviation.  Is there a way to get criterion to omit those outliers?
14:02:35 * ski has never written any monad tutorial ..
14:02:40 <ski> .. am i ill ?
14:02:46 <nand`> me neither, I figure it's for the best
14:02:51 <osa1> can anyone recommend me any other resources than "essentials of programming languages" to learn more about continuation-passing interpreters? I have an interpreter written in haskell and I'm working on adding continuations, and then I'll add exceptions and threads.
14:03:06 <mcstar> helping ppl on irc makes up for a tutorial
14:03:47 <ski> mcstar : oh, so you're suggesting i should quit helping ? -- sorry, no can do :)
14:04:03 <mcstar> ski: no no, you are too valuable!
14:04:38 <ski> well, i mean; given that monad tutorials tend to have negative value ..
14:05:36 <nand`> @quote lemonads
14:05:37 <lambdabot> xplat says: when life gives you lemons, make lemonads
14:05:45 <nand`> that's how I imagine monads now
14:06:06 <mcstar> make lemonad*
14:06:07 * hackagebot hOpenPGP 0.3.1 - native Haskell implementation of OpenPGP (RFC4880)  http://hackage.haskell.org/package/hOpenPGP-0.3.1 (ClintAdams)
14:06:11 <mcstar> or lemonade
14:06:47 <mcstar> nand`: ok, i see it now
14:06:53 <mcstar> le-monad s
14:07:03 <mcstar> witty
14:08:24 <mcstar> is reactive banana with wxhaskell used for some non-trivial gui?
14:08:55 <mcstar> maybe some real application, or with some highly customized widget?
14:09:48 <mcstar> and, id like to know, what is the catch? if its so great, why isnt it used more?
14:12:17 <hpc> mcstar: see the examples for why it isn't used more
14:12:36 <mcstar> hpc: im looking at them
14:12:58 <mcstar> hpc: im not sure what you  imply
14:13:05 <teaurchin> is there a better way of using the Identity monad without dragging in all of mtl as a dependency than just copy and pasting the code?
14:13:23 <parcs`> teaurchin: the transformers package
14:15:18 <teaurchin> parcs`: that's a bigger dependency than mtl :P
14:16:06 <parcs`> no it's not
14:16:15 <monochrom> mtl depends on transformer
14:16:25 <mcstar> hpc: well, could you explain it? im really interested
14:16:55 <ski> osa1 : hm, maybe too heavy ior advanced paper, but your question got me thinking about this one : "Continuation-Based Partial Evaluation" by Julia L. Lawall,Olivier Danvy in 1995-02 at <http://www.diku.dk/~julia/lawall-danvy-lfp94-extended.ps.gz>
14:17:23 <teaurchin> oh oops, you're right. I misread the depends list
14:17:24 <ski> (imho this is a quite cool paper)
14:18:25 <osa1> ski: thanks. looks a little advanced for me, but I'll give it a shot.
14:19:08 <bschup> :q
14:22:33 <ski> osa1 : it defines partial evaluation (which can be seen as a kind of interpretation), both in direct style, and in continuation-passing style
14:24:44 <osa1> ski: actually all I was looking for was a way to implement `eval` for if-then-else and function-call expressions in continuation-passing style. I also want to give users a special form like call/cc
14:26:10 <ski> ah, so you want control operators, nice
14:26:27 <ski> osa1 : presumably you want something like `evalCPS :: Expr -> (Val -> Answer) -> Answer'
14:26:37 <ski> where `Answer' might be just `Val'
14:26:57 <ski> (add environment as needed)
14:27:02 <hpc> mcstar: oh, i might be thinking of a different FRP lib
14:27:49 <hpc> that particular lib had a horrible example that was less readable than the worst perl code i have ever seen
14:27:56 <sral> @src (>>=)
14:27:56 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
14:27:58 <ski> you could possibly replace `Val -> Answer' by `Kont', that being a data-type variant (possibly more or less a stack)
14:28:10 <hpc> thanks to poor choice of infix operators and lots of nested lambdas
14:28:18 <mcstar> hpc: http://www.haskell.org/haskellwiki/Reactive-banana/Examples i was talking about this
14:28:22 <osa1> yea. the problem in function-call expressions is that they involve multiple calls to eval, so I need to write some continuations to evaluate function, and then parameters, and then apply the function to parameters ..
14:29:15 <ski> osa1 : well, i'm not sure i see the problem yet ..
14:29:36 <sral> @pl \(x, y) -> (y, x)
14:29:36 <lambdabot> uncurry (flip (,))
14:30:32 <sral> @pl \(a, b, c, d) -> (c, b, d, a)
14:30:32 <lambdabot> (line 1, column 7):
14:30:32 <lambdabot> unexpected ","
14:30:32 <lambdabot> expecting letter or digit, operator or ")"
14:30:32 <lambdabot> ambiguous use of a non associative operator
14:30:38 <sral> @pl \(a, b, c, d) -> (c, b, d, a)
14:30:38 <lambdabot> (line 1, column 7):
14:30:38 <lambdabot> unexpected ","
14:30:39 <lambdabot> expecting letter or digit, operator or ")"
14:30:39 <lambdabot> ambiguous use of a non associative operator
14:30:54 <sral> @pl \(x, y) -> (y, x)
14:30:55 <lambdabot> uncurry (flip (,))
14:31:12 <sral> @pl \a b c d -> (d,b, c, a)
14:31:12 <lambdabot> flip (flip . (flip .) . flip . flip (,,,))
14:32:24 <ski> osa1 : something like `evalCPS (App e e0) k1 = evalCPS e $ \(Clos v0_k1_ans) -> evalCPS e0 $ \v0 -> v0_k1_ans v0 k1' ?
14:32:40 <sral> @src map
14:32:40 <lambdabot> map _ []     = []
14:32:41 <lambdabot> map f (x:xs) = f x : map f xs
14:32:47 <DMcGill> sral: you can /msg lambdabot
14:33:30 <mcstar> better to /query her
14:34:03 <mcstar> hpc: were you talking about the same thing?
14:34:19 <mcstar> if not, id still like to know what was that
14:35:09 <Cale> sral: lambdabot doesn't support the full Haskell syntax, and in particular doesn't handle tuples larger than pairs (there are basically no Prelude functions for working with those anyway)
14:35:35 <osa1> ski: hmm.. what if e0 is a list?
14:36:12 <hpc> mcstar: different, and too lazy to look it up ;)
14:36:39 <mcstar> np
14:38:21 <ski> osa1 : yes, so you'll need to process down it -- e.g. using a helper function `evalList :: [Expr] -> ([Val] -> Answer) -> Answer'
14:43:02 <osa1> right. thanks.
14:58:23 <nobdraisentone> How can I get first Just value from a `[Maybe a]' and return Nothing if there is no such?
14:59:24 <hpc> listToMaybe . catMaybes
14:59:26 <copumpkin> > msum [Just 5, Just 6, Nothing]
14:59:28 <lambdabot>   Just 5
14:59:30 <nobdraisentone> Exactly
14:59:31 <copumpkin> > msum [Nothing]
14:59:33 <lambdabot>   Nothing
14:59:34 <nobdraisentone> hpc: thanks
14:59:34 <hpc> or msum
14:59:36 <copumpkin> > msum [] :: Maybe Int
14:59:38 <lambdabot>   Nothing
14:59:38 <hpc> or find isJust
14:59:51 <nobdraisentone> find isJust return Just (Just .)
15:02:18 <nobdraisentone> Msum is awesome
15:03:17 <enjoylife> @hoogle Fractional a => a -> Integer
15:03:18 <lambdabot> Prelude floatRadix :: RealFloat a => a -> Integer
15:03:18 <lambdabot> Prelude toInteger :: Integral a => a -> Integer
15:03:18 <lambdabot> Prelude recip :: Fractional a => a -> a
15:07:30 <mel-> I get this 'ambigious module name' error when I try to import Control.Monad.State in ghc. I know how to hide packages. But what is _real_ solution?
15:07:33 <mel-> +the
15:09:29 <shapr> mel-: If you build a package with cabal, you can explicitly specify which hackages are in scope.
15:11:23 <mel-> shapr: well, but shouldn't these name clashes be avoided in general? and the authors of the packages in question (mtl, monads-fd) should decide who gets the name? :)
15:11:47 <shapr> Not necessarily, different implementations have different advantages.
15:12:13 <mel-> hmm
15:12:18 <parcs`> monads-fd shouldn't exist in your package index
15:12:52 <mel-> parcs`: why?
15:13:03 <geekosaur> mel-, I believe mtl2 *is* monads-fd; if you have one, you should not have the other
15:14:25 <mel-> ah
15:14:31 <mel-> _that's_ good then.
15:15:00 <mel-> i wouldn't like the fact that 'import' can fail with other errors than 'not found'
15:16:11 * hackagebot symbol 0.1.2 - A 'Symbol' type for fast symbol comparison.  http://hackage.haskell.org/package/symbol-0.1.2 (GeoffreyMainland)
15:19:33 <mel-> wtf... i am reading cabal --help. why is there no deinstallation command?
15:19:52 <Clint> because it's not a package manager
15:20:01 <mel-> ah, found the faq :)
15:23:58 <enjoylife> fairly ease to grep the desired folders to remove
15:26:11 * hackagebot mainland-pretty 0.1.3.0 - Pretty printing designed for printing source code.  http://hackage.haskell.org/package/mainland-pretty-0.1.3.0 (GeoffreyMainland)
15:26:24 <monochrom> see my http://www.vex.net/~trebla/haskell/sicp.xhtml#remove for how to deinstall
15:26:45 <monochrom> see the whole article anyway
15:31:40 <teaurchin> @hoogle (a -> b) -> Either a c -> Either b c
15:31:41 <lambdabot> Data.Graph.Inductive.Graph nmap :: DynGraph gr => (a -> c) -> gr a b -> gr c b
15:31:41 <lambdabot> Control.Arrow (^>>) :: Arrow a => (b -> c) -> a c d -> a b d
15:31:41 <lambdabot> Data.Graph.Inductive.Basic elfilter :: DynGraph gr => (b -> Bool) -> gr a b -> gr a b
15:33:25 <teaurchin> is there anything like that in the standard libs?
15:33:59 <geekosaur> teaurchin, sounds like fmap to me
15:34:08 <geekosaur> :t fmap
15:34:10 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
15:34:25 <geekosaur> wait, no, Eitger has that pesky extra argument
15:34:29 <teaurchin> geekosaur: the Functor instance of Either applies to the Right
15:34:31 <geekosaur> so it;s swapped Either
15:34:56 <geekosaur> nothing standard I think; Either has this annoying tendency to be Right-biased
15:35:00 <fmap> @type left
15:35:02 <lambdabot> forall (a :: * -> * -> *) b c d. (ArrowChoice a) => a b c -> a (Either b d) (Either c d)
15:35:53 <fmap> > left succ (Left 1)
15:35:54 <lambdabot>   Left 2
15:35:57 <fmap> > left succ (Right 1)
15:35:58 <lambdabot>   Right 1
15:36:08 <teaurchin> excellent; thanks
15:36:11 * hackagebot language-c-quote 0.3.2 - C/CUDA/OpenCL quasiquoting library.  http://hackage.haskell.org/package/language-c-quote-0.3.2 (GeoffreyMainland)
15:36:31 <djanatyn> ...I know this probably might not be the best place to say it, but I'm so excited.
15:36:34 <djanatyn> Guys! List is a monad!
15:36:47 <djanatyn> I finaly got that concept, and I'm so happy about it. :)
15:36:57 <djanatyn> Or, at least, I'm beginning to get it.
15:38:30 <tomboy64> meh
15:38:59 <tomboy64> i found intToDigit - but how do i convert a big number into a string?
15:39:24 <Veinor> > show 20985919823147850756715
15:39:24 <tomboy64> map intToDigit 12345 won't work ...
15:39:26 <lambdabot>   "20985919823147850756715"
15:39:30 <tomboy64> eh
15:39:33 <tomboy64> that simple?
15:39:39 <tomboy64> thanks
15:42:32 <mikeplus64> > "potato tomato" >> "i am the great conhalio djanatyn"
15:42:33 <lambdabot>   "i am the great conhalio djanatyni am the great conhalio djanatyni am the g...
15:44:38 <mikeplus64> > "abcdefg" >> "hello "
15:44:39 <lambdabot>   "hello hello hello hello hello hello hello "
15:45:00 <JuanDaugherty> I wonder why HAIFA stopped?
15:45:24 <mikeplus64> > "abcdefg" >>= \x -> x:" hello "
15:45:26 <lambdabot>   "a hello b hello c hello d hello e hello f hello g hello "
15:47:19 <ion> Slightly relevant: http://codepad.org/fo7UPWvL
15:49:04 <shachaf> ion: You're missing "mn".
15:52:12 <keseldude> hey, what's the point of the arr function if (->) is an Arrow instance?
15:53:01 <shachaf> keseldude: The point is when you're using any other arrow.
15:53:17 <shachaf> That's a bit like saying "what's the point of the id function when I can just type x instead of id x"? :-)
15:53:39 <keseldude> oh, lol, I get it. thank you
15:53:59 <matthiasgorgens> shachaf: or return.
15:54:02 <matthiasgorgens> and const.
15:54:14 <shachaf> Or many other examples.
15:56:12 * hackagebot dpkg 0.0.3 - libdpkg bindings  http://hackage.haskell.org/package/dpkg-0.0.3 (ClintAdams)
16:11:16 * hackagebot srcloc 0.1.2 - Data types for managing source code locations.  http://hackage.haskell.org/package/srcloc-0.1.2 (GeoffreyMainland)
16:17:02 <ion> shachaf: Yeah, and capital letters. I posted that a bit too hastily.
16:22:39 <mikeplus64> http://www.reddit.com/r/learnprogramming/comments/w30ze/is_functional_programming_useful_in_systems_which/ to help this guy out: what is the most idiomatic way to describe a mess of nodes like that pictured?
16:23:11 <mikeplus64> i thought just a tree of functions, but that is over simplified, and in such a node based thing you're not really going to want "sources" to always be the same type
16:24:31 <hpc> you would use prototype OO
16:24:59 <hpc> where objects are hashes or similar, and foo.bar(baz) is sugar for bar(foo, baz)
16:25:11 <hpc> member functions are just lambdas inside the hash
16:25:25 <hpc> private state is implemented with closures
16:25:32 <hpc> public state is just more members of the hash
16:26:11 <hpc> to extend a class, you take an object of that class and add stuff to it
16:26:47 <hpc> so in essence, instead of constructors you have functions that take a hash and add members to it
16:27:01 <hpc> and to make a new object from scratch, start with the empty object with no members at all
16:27:41 <hpc> (most of that explanation was for javascript, but tuples work just as well)
16:30:31 <hpc> oh, and if you want to be really evil, mention FRP as well as the fact that you can fork a thread for each node and use Chans to pass messages
16:31:49 <mikeplus64> i'm hoping that someone in #haskell will smash down the door and post something meaningful on the reddit post there
16:32:17 <mikeplus64> because i don't know much about frp at all
16:35:06 <henux> recommend a haskell programming book for someone coming from C/C++ world?
16:35:15 <hpc> @where lyah
16:35:16 <lambdabot> http://www.learnyouahaskell.com/
16:35:19 <henux> a book i can buy
16:35:41 <irene-knapp> you can buy that book
16:35:57 <henux> great
16:37:08 <henux> christ its 45 dollars
16:37:17 <irene-knapp> it's also free, on the web
16:37:27 <irene-knapp> so, you know, you either want a book you can buy or you don't :)
16:37:33 <irene-knapp> also $45 is cheap for a tech book
16:37:35 <henux> yeah
16:37:54 <henux> well i want it yeah
16:38:49 <hpc> it's an awesome tech book
16:38:50 <parcs`> i payed $30 for mine, i think. and i got stickers!
16:38:55 <hpc> mine was free
16:39:04 <hpc> i wrote the first amazon review and BONUS shipped it to me :D
16:40:50 <parcs`> which happened first?
16:41:15 <hpc> both
16:41:26 * hackagebot http-types 0.7.0 - Generic HTTP types for Haskell (for both client and server code).  http://hackage.haskell.org/package/http-types-0.7.0 (AristidBreitkreuz)
16:43:18 <matthiasgorgens> How can I do IO in Haskell/ghc without getting an `invalid byte sequence' exception?
16:43:22 <matthiasgorgens> e.g.:
16:43:23 <matthiasgorgens> withFile "testOut" WriteMode $ \o -> withFile "testIn" ReadMode $ \h -> hPutStr o =<< hGetContents h
16:43:29 <matthiasgorgens> *** Exception: testIn: hGetContents: invalid argument (invalid byte sequence)
16:45:10 <matthiasgorgens> found it: I have to use withBinaryFile.
16:45:42 <ion> Use ByteString instead.
16:46:05 <ion> String is for text characters, ByteString is for arbitrary bytes.
16:47:35 <tomboy64> i want a function to print "stuff" and return True
16:48:02 <tomboy64> now ghc complains: Expected type: m0 a0 -> m0 b0 -> Bool
16:48:04 <tomboy64>       Actual type: m0 a0 -> m0 b0 -> m0 b0
16:48:06 <ion> You’ll want an IO action instead of a function. True <$ print "stuff"
16:48:26 <tomboy64> what does the <$ do?
16:49:09 <ion> “a <$ b” is “const a <$> b”, which (for all types that implement Monad) is equivalent to “do b; return a”
16:49:41 <tomboy64> eh ... ok
16:49:51 <tomboy64> i've heard Monad before
16:49:59 <tomboy64> and i understand your last statement :-D
16:50:20 <tomboy64> not ideal, but i guess it'll do for now. thanks. will read up on that :$
16:50:41 <ion> Please tell how it’s not ideal. We don’t have all the information about what you actually want.
16:51:09 <tomboy64> it's not ideal in that i don't yet comprehend monads and functors
16:51:22 <ion> You don’t need to.
16:51:23 <tomboy64> i believe it does exactly what i want to do
16:51:27 * hackagebot symbol 0.1.2.1 - A 'Symbol' type for fast symbol comparison.  http://hackage.haskell.org/package/symbol-0.1.2.1 (GeoffreyMainland)
16:51:40 <jfischoff> its also ok to use monads without understanding them
16:51:45 <ion> The understanding of the larger concepts comes on its own later, just imagine that’s a special interface for IO only for now.
16:52:32 <tomboy64> ok
16:52:46 <parcs`> > () <$ [1..10]
16:52:47 <lambdabot>   [(),(),(),(),(),(),(),(),(),()]
16:53:04 <parcs`> > () <$ Just "hi"
16:53:05 <lambdabot>   Just ()
16:53:14 <ion> “a <$ b” means “b, but changing the result value to a”. “f <$> b” means “b, but applying f to the result value and resulting in that instead”.
16:53:58 <shachaf> What does $><*<* mean?
16:54:38 <mikeplus64>  :t ($><*<*)
16:54:47 <mikeplus64> :t ($><*<*)
16:54:49 <lambdabot> Not in scope: `$><*<*'
16:55:02 <mikeplus64> it means you've got a very dead fish
16:55:12 <tomboy64> :-D
16:55:30 <tomboy64> harumm
16:55:39 <tomboy64> i'm still doing something wrong
16:56:09 <tomboy64> the actual function is like function a = True <$ print a
16:56:34 <tomboy64> it must return a boolean but should still print value a
16:56:44 <mikeplus64> tomboy64: lets look at the type for (<$)
16:56:46 <mikeplus64> :t (<$)
16:56:48 <lambdabot> forall a (f :: * -> *) b. (Functor f) => a -> f b -> f a
16:56:54 <ion> @type let function a = True <$ print a in function
16:56:56 <lambdabot> forall a. (Show a) => a -> IO Bool
16:57:39 <mikeplus64> oh i have confused <$ for another apparently, carry on
16:57:51 <ion> To be precise, it returns the action of type IO Bool, which upon execution prints something and *results* in a Bool.
16:58:14 <ion> Feel free to do something like “do print a; return True” if that feels more familiar.
16:58:53 <tomboy64> well, that feels more familiar, but i'd like to understand it nevertheless.
16:59:07 <mikeplus64> @src (<$)
16:59:08 <lambdabot> (<$) = (<$>) . const
16:59:10 <ion> Why is everyone named something64?
16:59:21 <mikeplus64> 64 is a nice number
16:59:26 <mikeplus64> @src (<$>)
16:59:27 <lambdabot> f <$> a = fmap f a
16:59:28 <serialhex> because 64 is cooler than 32
16:59:29 <tomboy64> so, the action of type IO Bool means it prints something out (e.g. a boolean)
16:59:35 <tomboy64> correct?
16:59:41 <favonia> ion: soon it will be 128
16:59:48 <ion> Granted, 64 is a pretty, round number.
16:59:54 <serialhex> :P
17:00:02 <tomboy64> (back in the days when amd64 was new and shiny i was tired of telling everyone i was running 64bit, not 32bit linux)
17:00:10 <mikeplus64> @src (fmap :: (a -> b) -> IO a -> IO b)
17:00:11 <lambdabot> Source not found. My brain just exploded
17:00:17 <mikeplus64> bother
17:00:23 <ion> No, it just means it can do some IO upon execution, and that it results in a Bool.
17:00:31 <serialhex> lambdabots brain just exploded???
17:00:44 <ion> What the actual action is can’t be seen from the type.
17:01:07 <tomboy64> what's the difference then between Bool and IO Bool result?
17:01:47 <mikeplus64> one is a Bool, no questions asked, the other is a IO action returning a Bool
17:02:09 <ion> resulting in a Bool
17:02:40 <Cale> tomboy64: You can think of an IO Bool as a description of some stuff which could be done to produce a Bool (and possibly arbitrary real world effects)
17:02:43 <ion> The function “return” is named in a bit confusing manner.
17:02:47 <sipa> one is either true or false, the other is a descriptiom of an imperative program that - when executed - results in either true or false
17:02:58 <Cale> It's maybe confusing, but also makes a lot of sense
17:03:09 <mm_freak> tomboy64: read "IO" as "RecipeFor" =)
17:03:11 <Cale> return True  is the IO action which does nothing, but returns True every time.
17:03:37 <mm_freak> getLine :: IO String
17:03:45 <mm_freak> getLine is a recipe for producing a string
17:03:51 <Cale> (it is not something which has any control flow properties like calling the current continuation of the enclosing definition or anything fancy like that)
17:04:25 <ion> I’d make the distinction that something of type “a -> b” *returns* a “b” and something of type “IO b” *results in* a “b”.
17:04:42 <Cale> ion: Usually I'd say those the other way around
17:05:18 <tomboy64> -.-
17:05:19 <ion> Oh, there isn’t even a consensus about that? Hehe
17:05:40 * tomboy64 joins lambdabot in asploding brainses
17:06:36 <Cale> tomboy64: Note that if you say that x :: Bool, it means that x will be the same Bool value the entire time that it remains in scope.
17:06:53 <tomboy64> yes
17:07:07 <hpc> i am becoming a big fan of happstack
17:07:14 <Cale> If you say x :: IO Bool, then x will be the same IO action the entire time it remains in scope, but running that action more than once can produce different values each time.
17:07:38 <favonia> serialhex: don't worry. lambdabot is a Haskell robot. even if its brain exploded it's still well typed (tm).
17:07:51 <tomboy64> but i don't want the io thingy to have any influence on my program.
17:07:56 <ion> hpc: I might want to do some HTTP server-side stuff some day. What makes you prefer it to the alternatives?
17:08:07 <tomboy64> i just want it to print a variable to stdout and carry on computing
17:08:10 <hpc> ion: it works the way i think
17:08:21 <Cale> Are you just debugging?
17:08:21 <hpc> with respect to how it does path routing
17:08:31 <Cale> You might like to try Debug.Trace.trace
17:08:49 <hpc> ion: im not using this for a general web server, it's worth noting
17:09:08 <hpc> more of a really wonky server-client game that happens to run in a browser
17:09:28 <Cale> (but that's really only suitable for emitting debugging messages, because there are not so many guarantees about when and how many times the messages will be printed)
17:10:04 <hpc> i wouldn't recommend it for general websites because upgrading acid-state types is a bitch
17:10:11 <Cale> They'll be printed when the values you're wrapping up get evaluated, but that's something that the compiler has control over, and can be affected by optimisations.
17:10:29 <ion> hpc: ok
17:14:45 <favonia> tomboy64: my 2 cents are that, as a methodology, you probably want to test each module intensively instead of running the whole program and looking at the trace
17:15:17 <tomboy64> favonia: test how?
17:17:14 <favonia> tomboy64: for example test a particular top-level function. this can be done nicely with QuickCheck or other unit-test frameworks.
17:18:03 <tomboy64> well, i'm still occupied understanding haskell's basics
17:18:05 <ion> I’ve been using test-framework with QuickCheck for almost everything and HUnit for the few test cases where random input isn’t useful.
17:18:48 <tomboy64> and the program i'm working on now does not take any input, it's completely deterministically computing one value.
17:18:57 <tomboy64> so i just need to follow certain variables.
17:19:40 <shergill> copumpkin: curious, but have you tried out coq?
17:19:52 <copumpkin> shergill: a little bit, but not very seriously
17:19:53 <copumpkin> why?
17:20:27 <favonia> tomboy64: you lost precise control of computation order mainly because of the laziness (at least in GHC). traces are sensitive to the computation order so it's not really suitable for Haskell
17:20:39 <ski> tomboy64 : often just testing operations in modules using GHCi goes a large part of the way to make sure things are appearing to work correctly
17:21:18 <shergill> copumpkin: i remember seeing you doing some clever stuff with agda, and was wondering why you weren't using coq. since from the brief look i'd taken it seemed coq's tactics would make the proofs much simpler
17:21:38 <shergill> i was reminded of that post of yours on google+, as i was going over some of my own coq stuff
17:22:07 <copumpkin> shergill: it's a bit of a philosophical thing, I think. Coq isn't imperative, but its tactics kind of are
17:22:14 <favonia> tomboy64: well perhaps you'd like to break down the function into small pieces so that each one can be easily tested, individually.
17:22:19 <copumpkin> they're completely unreadable after you've written them
17:22:25 <copumpkin> because you need to keep the proof state in mind
17:22:34 <copumpkin> which is getting mutated by each tactic you run
17:22:37 <favonia> copumpkin: +1 for unreadability :(
17:22:56 <shergill> copumpkin: yeah, the coqide is pretty useful with that
17:23:04 <shergill> though i'm trying to get proofgeneral to work atm
17:23:46 <ski> shergill : how sensitive are the tactics to the particular version version of Coq ?
17:24:05 <ski> s/version version/version/
17:24:50 <shergill> ski: i'm no expert, so i can't really comment. but i haven't seen them vary a lot in my experience of using it here and there over the last 2-3 years
17:28:18 <favonia> ski: I've heard that some of the tactic script just failed in newer versions.
17:28:59 <ski> shergill : ideally, there should be some relatively clear specification of how the tactics change the proof state, that stay mostly the same even if underlying implementations of tactics change (sortof similar to "stack effect" declarations for words in Forth, in a way -- if you can keep track of what's currently at the stack in which order, you can follow the words)
17:29:23 <favonia> ski: (heard from my colleagues)
17:29:31 <ski> but maybe what i'm asking for isn't that reasonable, i don't know (i don't know very much about how the tactics work)
17:30:14 <djanatyn> I made inbred sheep with bind
17:30:17 <djanatyn> http://hpaste.org/70964
17:34:21 <ski> (e.g. can one use Coq tactics to do automatic simplification (and perhaps unification, possibly restricted in some cases) of e.g. ring expressions -- or things like Tarski-Seidenberg elimination of quantifiers to decide formulae as in <http://xorshammer.com/2009/05/14/a-suite-of-cool-logic-programs/> ?)
17:34:35 <ski> favonia : ok
17:35:37 <matthiasgorgens> I'm building a replacement for fdupes in Haskell.  fdupes is a program that, essentially, takes a directory, and looks for duplicate files.
17:36:17 <matthiasgorgens> the original fdupes does some stupid things, which I am trying to avoid.  Anyway, my goal for the program is to become IO bound.
17:36:30 <matthiasgorgens> at the moment my replacement seems to be CPU bound.
17:36:35 <blackdog> matthiasgorgens: so recursive search + md5sum?
17:36:47 <matthiasgorgens> blackdog: that's what fdupes is doing.
17:36:54 <matthiasgorgens> I want to avoid the md5sum.
17:36:59 <matthiasgorgens> it doesn't buy you anything.
17:37:06 <coppro> yes it does
17:37:08 <matthiasgorgens> nope.
17:37:16 <matthiasgorgens> there's only a small number of files with the same length.
17:37:21 <shergill> ski: ime the tactics have become more powerful and i haven't run into an instance where a tactic used in a previous version succeeded in the proof but a newer version didn't
17:37:22 <coppro> ah, I suppose
17:37:24 <matthiasgorgens> you can get the length in O(1) with the stat system call.
17:37:36 <shergill> but like i said, i'm hardly a power user
17:37:41 <Clint> git-annex detects dupes as a side effect
17:37:44 <matthiasgorgens> and to get the md5sum you have to read the whole file.
17:37:45 <favonia> matthiasgorgens: cool
17:37:52 <matthiasgorgens> so why not compare the few files directly?
17:37:59 <matthiasgorgens> if you have to read them anyway.
17:38:20 <matthiasgorgens> (fdupes is reading duplicate files twice, because it doesn't trust the md5sum.)
17:38:24 * geekosaur notes that relying on length is ... fragile
17:38:47 <matthiasgorgens> geekosaur: we only rely on length to separate files.
17:39:02 <matthiasgorgens> geekosaur: i.e. two files with different length are different.
17:39:11 <matthiasgorgens> only files with the same length are considered for further inspection.
17:39:19 <kfish> so use SHA-256 or something
17:39:22 <matthiasgorgens> (inode number + device works the opposite way:
17:39:23 <kfish> what do you do if 3 files have the same length?
17:39:25 <matthiasgorgens> )
17:39:35 <matthiasgorgens> kfish: you compare all three byte for byte.
17:39:43 <matthiasgorgens> you only ever have to have three bytes in memory.
17:39:48 <matthiasgorgens> (one from each file.
17:39:56 <parcs`> @hoogle Num a => Bool -> a
17:39:57 <lambdabot> Foreign.Marshal.Utils fromBool :: Num a => Bool -> a
17:39:57 <lambdabot> Control.Exception.Base assert :: Bool -> a -> a
17:39:57 <lambdabot> Control.Exception assert :: Bool -> a -> a
17:40:15 <matthiasgorgens> of course buffering makes more sense, but still that's memory in O(number of files of equal length)
17:40:18 <matthiasgorgens> not O(file length)
17:40:33 <kfish> do you think it is more efficient to have 1 byte per file rather than, say, 4096 bytes per file, in memory at once?
17:40:45 <matthiasgorgens> kfish: of course buffering is better.
17:41:01 <matthiasgorgens> kfish: but conceptionally we only need a constant memory per file we are comparing.
17:41:06 <shergill> ski: also, the coq reference manual does provide a specification of sorts for the tactics
17:41:12 <matthiasgorgens> basically, what we do for two files is:
17:41:21 <kfish> i'm not suggesting you have a choice, the data is already buffered anyway
17:41:22 <matthiasgorgens> zip fileContents1 fileContents2
17:41:27 <matthiasgorgens> and look for the first difference.
17:41:36 <matthiasgorgens> kfish: yes.
17:41:42 <kfish> when you say "zip" do you mean Data.List.zip ?
17:41:58 <matthiasgorgens> kfish: yes.  but that just describes the semantics.  I don't use lists.
17:42:08 <matthiasgorgens> kfish: i.e. no Data.List.zip.
17:42:09 <blackdog> matthiasgorgens: even if you use length to bucket files, you'd still want to use some hashing algorithm to avoid pathological cases... although i suppose if you're smart about it, you'll only do a linear number of comparisons on equal-length files rather than quadratic
17:42:33 <matthiasgorgens> blackdog: it's n log n to be precise.
17:42:48 <matthiasgorgens> i.e. look at first byte / chunk.
17:43:01 <matthiasgorgens> sort the files by that chunk in n log n.
17:43:10 <matthiasgorgens> if they are equal, look at the next chunk, etc.
17:43:23 <matthiasgorgens> if they partition in a number of cases,
17:43:41 <matthiasgorgens> only compare the files that are still similar.
17:43:53 <matthiasgorgens> we traverse something like a prefix tree.
17:44:00 <matthiasgorgens> (even though that tree is never explicitely in memory.)
17:44:28 <matthiasgorgens> blackdog: a hash would help at all.
17:44:36 <matthiasgorgens> blackdog: not even in pathological cases.
17:44:46 <matthiasgorgens> blackdog: hashing means you have to read the whole file.
17:45:06 <matthiasgorgens> blackdog: the other approach only reads the whole file, to prove that files are equal.
17:45:18 <kfish> unless you only hash the first page for your 2nd stage comparison
17:45:29 <matthiasgorgens> kfish: yes, but why do that?
17:45:36 <matthiasgorgens> might as well compare the pages directly.
17:46:06 <matthiasgorgens> if you have a gazillion number of pages, compare them using merge sort with external `tapes'.
17:46:19 <kfish> to compare n hashes rather than n*m bytes
17:46:19 <matthiasgorgens> see https://en.wikipedia.org/wiki/External_sorting
17:46:38 <Enigmagic> no merge sort is required if you're doing equality checks
17:46:56 <matthiasgorgens> Enigmagic: was there a comma after `no'?
17:46:59 <blackdog> matthiasgorgens: you can do chunking with hashes just as easily. that's orthogonal.
17:47:01 <Enigmagic> but hashing on larger blocks can be faster if you have a slow disk and the file is mostly contiguous
17:47:12 <matthiasgorgens> blackdog: sure, but hashes don't give you anything.
17:47:17 <matthiasgorgens> blackdog: they just use CPU.
17:47:49 <blackdog> matthiasgorgens: can you explain how your algorithm works on a filesystem with ten million copies of the same file?
17:47:55 <matthiasgorgens> Enigmagic: hashes might help if the buffer size you have to use to get the benefits of linear reads is so big, that it doesn't fit into memory.
17:49:00 <kfish> it sounds like you've been burned by a previous implementation
17:49:04 <matthiasgorgens> blackdog: that's basically the worst case.  but that's no different to fdupes,
17:49:18 <matthiasgorgens> which still does the byte for byte check, if the hashes are equal.
17:49:18 <blackdog> matthiasgorgens: in that case, an md5 algorithm will read every file once
17:49:36 <matthiasgorgens> blackdog: only, if it trust the md5sum absolutely.
17:49:38 <Enigmagic> matthiasgorgens: thats what i was saying. last time i was concerned about read throughput the optimal read size on a spinning disk (7200 rpm 1tb drives) was about 1MB
17:49:57 <matthiasgorgens> kfish: oh, i was just a bit annoyed that fdupes was cpu bound, when it shouldn't be, and also only used one core.
17:50:00 <blackdog> if you're comparing file by file, i think you end up doing at least twice as many reads
17:50:17 <favonia> blackdog: I think both matthiasgorgens and fdupes don't trust md5 at all :)
17:50:33 <matthiasgorgens> Enigmagic: the common case (for me) is only at most a handfull of files of the same size, so that would fit well into memory.
17:50:44 <blackdog> matthiasgorgens: yeah, if you're looking for a non-probabilistic solution md5 isn't your friend
17:50:48 <matthiasgorgens> blackdog: why do you do more reads?
17:51:03 <blackdog> assume you're comparing file by file
17:51:03 <matthiasgorgens> blackdog: also for the common case, you don't need a hash at all.
17:51:14 <blackdog> you compare the first two, they're equal, so you put them in a bucket
17:51:30 <blackdog> that's two reads
17:51:38 <matthiasgorgens> (by the way, my benchmark is my collection of mp3/ogg's that I won't too weed off duplicates.)
17:51:47 <blackdog> you compare the next file with one of the ones from the bucket, that's another two reads
17:51:48 <matthiasgorgens> blackdog: ok, so far.
17:51:54 <matthiasgorgens> blackdog: no, I don't do that.
17:52:00 <blackdog> so how do you compare?
17:52:03 <matthiasgorgens> I read a chunk from every file under consideration.
17:52:16 <matthiasgorgens> blackdog: then put sort those chunks in memory.
17:52:21 <matthiasgorgens> i.e. put them in the buckets.
17:52:45 <matthiasgorgens> keeping them in memory should be cheaper than reading again.
17:52:59 <blackdog> ah, ok. you're limited by memory size then - you need number-of-files * chunksize
17:53:05 <matthiasgorgens> after I did all the comparisons on the first chunk that I need, I can forget about them.
17:53:13 <matthiasgorgens> blackdog: yes, but that's not a problem.
17:53:15 <blackdog> which could be very large on a big filesystem.
17:53:26 <matthiasgorgens> blackdog: number of files of the same size.
17:53:30 <Eduard_Munteanu> matthiasgorgens: what if you rely on the page cache?
17:53:39 <matthiasgorgens> Eduard_Munteanu: I have tried just mmapping.
17:53:46 <blackdog> it's a pathological case, sure, but if you're worrying about md5sum giving you collisions, you're already worried about pathological cases
17:53:54 <matthiasgorgens> but that just lead to using too much heap.
17:54:05 <kfish> mmap uses too much heap?
17:54:16 <matthiasgorgens> blackdog: that's actually not why I don't trust md5.
17:54:24 <matthiasgorgens> blackdog: fdupes worries about md5 for that reason.
17:54:25 <Eduard_Munteanu> mmap doesn't use the heap AFAIK
17:54:36 <matthiasgorgens> I just see md5 as a make-work scheme for the CPU in that case.
17:54:49 <matthiasgorgens> Eduard_Munteanu: I mean, I just ran out of memory doing that.
17:55:24 <matthiasgorgens> Eduard_Munteanu: the gc isn't smart enough for what I did.
17:55:44 <matthiasgorgens> Eduard_Munteanu: if you can figure out how to do it, please write up a solution.
17:55:54 <blackdog> matthiasgorgens: if you're concerned about the usual case, what you're doing is probably fine. in the best traditions of quicksort taking quadratic worst-case time etc.
17:56:29 <matthiasgorgens> anyway, even though I don't do any hashing, the program is still cpu bound.
17:56:48 <matthiasgorgens> when it should---based on what it's actually doing---be IO bound.
17:57:27 <blackdog> matthiasgorgens: oh, also - you'd want to be careful about not keeping all the equal files open at once, you'll run out of filedescriptors
17:57:38 <blackdog> matthiasgorgens: are you running with profiling?
17:57:50 <matthiasgorgens> blackdog: no, I'll do that next.
17:57:55 <Eduard_Munteanu> matthiasgorgens: how did you mmap it?
17:58:02 <matthiasgorgens> Eduard_Munteanu: cabal install mmap
17:58:17 <Eduard_Munteanu> matthiasgorgens: yeah, but which mmap function?
17:58:30 <matthiasgorgens> the one that gives a lazy ByteString.
17:58:35 <ski> shurick : ok
17:58:38 <ski> er ..
17:58:42 <ski> shergill : ok
17:58:47 <Eduard_Munteanu> matthiasgorgens: sounds like an issue if you're copying that bytestring
17:58:56 <matthiasgorgens> Eduard_Munteanu: didn't copy.
17:59:27 <Eduard_Munteanu> You probably want something that's explicitly mutable
17:59:34 <matthiasgorgens> why?
17:59:41 <matthiasgorgens> I
17:59:51 <matthiasgorgens> I thought of just coding up the comparison in C. ;o)
18:00:10 <kfish> you could just benchmark against "git init && git add . && git ls-tree -r HEAD | cut -c 13- | sort | uniq -D -w 40"
18:00:12 <Eduard_Munteanu> So you don't end up copying the map's contents.
18:00:32 <icheishvili> on this page (http://www.haskell.org/haskellwiki/Introduction), at the very bottom, it says that a lot of the content is based on a paper by Simon Peyton Jones—anyone know what paper that would happen to be?
18:01:21 <blackdog> kfish: isn't that going to behave funkily if you have git repos on your disk?
18:01:25 <copumpkin> are there any iteratee-like libraries that have a good mmap producer?
18:01:47 <blackdog> probably ok for mp3s, which appear to be the leading reason for duplication detection :)
18:03:04 <matthiasgorgens> kfish, interesting benchmark.  I guess you should clean up afterwards.
18:03:06 <joeyh> are there any interesting gotchas with using QSemN?
18:04:23 <Nereid> oh yeah I should practice this non
18:04:26 <Nereid> oops wrong spell
18:04:29 <Nereid> channel
18:04:30 <Nereid> drggfsdh
18:04:30 <Nereid> t
18:04:30 <Nereid> hj
18:04:32 <Nereid> erg
18:04:33 <Nereid> hi
18:04:41 <ion> ok
18:04:45 <Nereid> ok
18:04:51 <kfish> blackdog, nah, git will stop descending when it finds a new .git dir, so it would just ignore files in git repos lower down
18:05:55 <matthiasgorgens> kfish: that's still funny behaviour.
18:06:00 <kfish> joeyh: yes http://haskell.1045720.n5.nabble.com/Proposal-Remove-Control-Concurrent-QSem-QSemN-SampleVar-mergeIO-nmergeIO-from-base-td5711428.html
18:06:26 <matthiasgorgens> anyway, it should be `easy' to beat git.
18:06:34 <matthiasgorgens> after all, git does way more work than necessary.
18:06:46 <blackdog> matthiasgorgens: good lower bound, then
18:06:58 <matthiasgorgens> blackdog: the original fdupes is another lower bound.
18:07:33 <matthiasgorgens> (hmm, runnig my program and git at the same time is probably not going to give any reasonable numbers..)
18:25:41 <ClaudiusMaximus> wow, i recompiled a library adding 1x {-# SPECIALIZE ... #-} pragma and my program that used it completed 7x faster
18:29:22 <shachaf> That's a big x.
18:36:30 <ClaudiusMaximus> though, it's still "only" 3.4x faster than the original code using ]
18:36:33 <ClaudiusMaximus> oops
18:36:54 <ClaudiusMaximus> though, it's still "only" 3.4x faster than the original code using [Double] (new code uses Data.Vec.Packed.Vec2D)
18:39:12 <ClaudiusMaximus> i imagine without the SPECIALIZE, ghc doesn't recognize that Vec2D can be unpacked/unrolled - so it's like [] but without all the []-fusion
18:44:16 <mk12> when splitting a line around an operator, in haskell style would you typically put the operator at the end of the first line or the start of the second line?
18:44:35 <monochrom> I do both
18:45:26 <mk12> arbitrarily, or depending on which operator it is?
18:46:00 <monochrom> depends on mood
18:46:32 * hackagebot sifflet-lib 2.0.0.0 - Library of modules shared by sifflet and its  tests and its exporters.  http://hackage.haskell.org/package/sifflet-lib-2.0.0.0 (GregoryWeber)
18:47:42 <ClaudiusMaximus> and it sped up another 10x when i rebuilt without -prof and ran without +RTS -p
18:56:32 * hackagebot husk-scheme 3.5.6 - R5RS Scheme interpreter, compiler, and library.  http://hackage.haskell.org/package/husk-scheme-3.5.6 (JustinEthier)
18:56:35 * hackagebot sifflet 2.0.0.0 - A simple, visual, functional programming language.  http://hackage.haskell.org/package/sifflet-2.0.0.0 (GregoryWeber)
19:09:33 <parcs`> does the unix package have a way to set the locale of a program?
19:09:37 <parcs`> @hoogle locale
19:09:38 <lambdabot> System.IO localeEncoding :: TextEncoding
19:09:38 <lambdabot> GHC.IO.Encoding localeEncoding :: TextEncoding
19:09:38 <lambdabot> System.Locale module System.Locale
19:21:53 <favonia256> @hoogle TextEncoding -> IO ()
19:21:54 <lambdabot> System.IO hSetEncoding :: Handle -> TextEncoding -> IO ()
19:21:54 <lambdabot> GHC.IO.Handle hSetEncoding :: Handle -> TextEncoding -> IO ()
19:21:54 <lambdabot> Prelude print :: Show a => a -> IO ()
19:22:35 <favonia256> @hoogle setLocaleEncoding
19:22:35 <lambdabot> No results found
19:24:06 <mzero> are you trying to set the locale globally?
19:24:32 <zeroseven> I was wondering if anyone has extensive experience with FFI and a few minutes to talk?
19:24:46 <favonia256> strange. there's indeed a function called setLocaleEncoding
19:26:08 <mzero> curious - and it is in GHI.IO.Encoding -  I wonder if Hoogle is excluding that module for some reason
19:26:33 <mzero> ah - it is marked internal, whereas GHC.IO.Handle is not
19:26:37 * hackagebot yesod-json 1.0.1.0 - Generate content for Yesod using the aeson package.  http://hackage.haskell.org/package/yesod-json-1.0.1.0 (FelipeLessa)
19:28:03 <fryguybob> zeroseven: What qualifies as extensive experience is fairly subjective.  If you ask your question, you are more likely to get answers :D.
19:28:39 <favonia256> mzero: then how did it find GHC.IO.Encoding.localeEncoding?
19:29:15 <mzero> @hoogle localeEncoding
19:29:15 <lambdabot> System.IO localeEncoding :: TextEncoding
19:29:15 <lambdabot> GHC.IO.Encoding localeEncoding :: TextEncoding
19:29:29 <mzero> becuase it is re-exported by System.IO
19:30:00 <mpwd> Kind of a theoretical question, but does anyone know of a more efficient embedding algorithm for embedding partial orders than this algorithm by Krall et al? http://www.springerlink.com/content/k91632147642w046/
19:30:34 <mzero> oh wait, ew - it isn't! those are different
19:30:36 <mzero> yikes!
19:30:56 <ion> mzero: Hah, nice
19:31:25 <zeroseven> fryguybob, thanks, I would like to incorporate pocketsphinx into my application. Reading through the FFI information on haskell.org and I'm still a bit confused as to things I need and how best to implement them. I'm sure this may be more of a mailing list question, but I was hoping maybe someone could just talk with me a bit.
19:31:45 <mzero> now I'm really confiused, my GHC.IO.Encoding doesn't export localeEncoding
19:31:48 <mzero> or even have one
19:33:16 <matthiasgorgens> blackdog, kfish, Eduard_Munteanu, I just tried my fdupes replacement with a mmap (from bytestring-mmap this time), and now it seems to be IO bound.
19:33:28 <ion> lambdabot’s @run has an ancient version of GHC, could that affect @hoogle?
19:34:47 <blackdog> matthiasgorgens: goodo :)
19:35:31 <monochrom> GHC 7.0: localeEncoding is defined in GHC.IO.Encoding, re-exported by System.IO. GHC 7.4: localeEncoding is defined in System.IO
19:38:22 <monochrom> setLocaleEncoding is not in GHC 7.0
20:39:24 <kkyqqp> is there any difference between pure and return, really?
20:41:27 <shachaf> Yes, the typeclass.
20:41:29 <danharaj> if applicative and monad instances are given for the same type constructor and they are compatible then they should be equivalent, yes.
20:43:59 <kkyqqp> hmm, OK
21:03:07 <copumpkin> so do any of the iteratee packages have an memory-mapped file source?
21:03:24 <copumpkin> I guess I could get away without doing the memory mapping
21:06:37 <jnoah1984> =>-><-->->>>=
21:08:53 <shachaf> copumpkin: Doesn't memory mapping work pretty badly with GHC's threading?
21:09:11 <copumpkin> how so?
21:09:25 <shachaf> Well, a page fault will block the entire OS thread.
21:09:32 <shachaf> Until it's loaded from disk.
21:09:48 <copumpkin> not much to do about that though
21:10:39 <shachaf> Well, if you were using read()/write(), the OS thread could be free to run other GHC threads in the meanwhile.
21:10:46 <shachaf> (Or if you had asynchronous page faults of some kind.)
21:12:45 <shachaf> It seems like you lose the benefits of GHC's I/O manager by doing it. Which might be significant.
21:13:01 <shachaf> I think Peaker was doing something with memory mapping, though?
21:13:21 <edwardk> shachaf: he was using it for his keyvalue store or whatnot
21:13:38 <shachaf> Ah, right.
21:15:40 <Eduard_Munteanu> shachaf: I guess if you used nonblocking read()/write()
21:15:58 <shachaf> Eduard_Munteanu: Right, or blocking calls in a separate thread.
21:17:07 <Eduard_Munteanu> Yeah, that'd work with page faults too.
21:17:32 <shachaf> Not really.
21:17:50 <Eduard_Munteanu> Why?
21:17:56 <shachaf> Page faults are kind of transparent and blocking by design. :-)
21:18:21 <shachaf> You can't say "go load this page in a different thread", and even if you could say that, it could easily get unloaded later.
21:18:23 <Eduard_Munteanu> But if the I/O thread was on a dedicated OS thread, then it wouldn't block other threads.
21:18:36 <shachaf> Sure, but you're *using* the memory from your own thread.
21:18:46 <copumpkin> Eduard_Munteanu: what do you suppose the guy who just tried to read memory is going to do while he waits?
21:18:55 <Eduard_Munteanu> Ah, sure, you'd need to copy stuff I think.
21:18:58 <shachaf> Unless you always copy from the mmapped region to your own address space in a separate thread.
21:19:02 <shachaf> Which is a lot like read.
21:19:14 <nalssi> How do you write a type class if you want something like "maxList :: (Num, Ord a) => [a] -> a"
21:19:15 <shachaf> I guess it could be a bit better in some cases.
21:19:25 <shachaf> nalssi: YOu mean the constraint?
21:19:25 <Eduard_Munteanu> Or perhaps you could splice to some pipe?
21:19:31 <shachaf> (Num a, Ord a) => [a] -> a
21:19:34 <shachaf> @ty maximum
21:19:36 <lambdabot> forall a. (Ord a) => [a] -> a
21:19:39 <Eduard_Munteanu> Then you could do nonblocking reads in another threa.d
21:19:43 <shachaf> No need for Num, though. :-)
21:19:47 <nalssi> shachaf : Thank you
21:20:47 <nalssi> Does Ord contain Num?
21:20:54 <shachaf> No.
21:21:08 <shachaf> But you don't need something to be a number to compute its maximum.
21:21:14 <shachaf> You just need to be able to compare two things.
21:21:23 <shachaf> > maximum "hello nalssi"
21:21:24 <lambdabot>   's'
21:21:28 <Eduard_Munteanu> Since splicing might be more efficient and lets the kernel play some tricks behind the scenes.
21:21:34 <nalssi> shachaf : I see
21:21:36 <shachaf> Eduard_Munteanu: Splice what?
21:21:40 <Eduard_Munteanu> (Though you lose random access.)
21:21:51 <xplat> in my imaginary 'threadless OS' a page fault will toss you back to your process-level scheduler
21:21:53 <Eduard_Munteanu> shachaf: say, vmsplice from a mmaped region to a pipe
21:22:16 <xplat> but in an existing OS you're hosed
21:22:19 <shachaf> xplat: My imaginary Linux syscall did that too. :-(
21:22:27 <shachaf> Apparently some microkernels do asynchronous page faults.
21:22:40 <shachaf> And I think Xen or KVM or something in Linux  has some facility for it?
21:22:55 <shachaf> Eduard_Munteanu: What's the point?
21:22:56 <Eduard_Munteanu> How so? Aren't page faults supposed to be totally transparent?
21:23:16 <Eduard_Munteanu> shachaf: yeah, I guess there isn't much point since you lose the semantics of a mmap
21:23:22 <gardnan> I thought the linux kernel did attempt to schedule on page faults
21:23:28 <shachaf> Eduard_Munteanu: Well, yes, but in this case they managed to get it by somehow.
21:23:38 <shachaf> gardnan: Sure, it schedules OS threads, but not user-level threads.
21:24:12 <xplat> gardnan: that's kernel-level scheduling (heavyweight, still blocks your process if there is not another os-level thread in it)
21:24:13 <Eduard_Munteanu> Unless you can somehow notify the thread the pagefault occured, like "don't read from this just yet until I tell you to"
21:24:22 <shachaf> Right.
21:24:24 <shachaf> http://lwn.net/Articles/359842/
21:24:57 <shachaf> It's used for virtualization, where a guest can fault and the virtualizer can then switch to another thread.
21:25:02 <shachaf> Not a general mechanism. :-(
21:25:50 <shachaf> Anyway what ends up happening is that people who really care about avoiding the overhead of OS threads write their own page cache and use direct I/O, or something like that. :-)
21:26:21 <shachaf> (Why aren't we in #-blah?)
21:26:38 <Eduard_Munteanu> Yeah, let's go there.
21:33:14 <copumpkin> so I have a Data.Binary.Get binary parser that parses "records" and want to run it over a massive file
21:33:29 <copumpkin> what's my best option to be able to do this in a memory-efficient manner?
21:33:46 <copumpkin> I don't need seeking
21:33:52 <copumpkin> just sequential parsing
21:34:21 <copumpkin> I basically need pipes/conduit -binary
21:34:43 <copumpkin> something that abstracts over the chunking but otherwise lets me pretend I'm getting a sequence of parsed things
21:36:38 <copumpkin> there's something like that for attoparsec
21:39:15 <copumpkin> I guess there's one for cereal
21:41:29 <dfc> i installed xmobar with cabal install from a checkout of the upstream git repo. why does xmobar not show up when i do a ghc-pkg list?
21:41:53 <shachaf> dfc: I guess because it's an executable, not a library?
21:42:02 <edwardk> copumpkin: clearly you should write a whole parser for trifecta that is capable of dealing with your streams ;)
21:42:06 <copumpkin> lol
21:42:11 <copumpkin> well, it's binary
21:42:14 <edwardk> not one for your usecase, a whole parser implementation
21:42:19 <copumpkin> oh okay
21:42:26 <copumpkin> I'll get right on that!
21:42:38 <dfc> shachaf: xmonad is a binary
21:42:48 <shachaf> dfc: xmobar isn't.
21:42:54 <shachaf> (Or is it?)
21:43:17 <shachaf> Doesn't look like it.
21:43:25 <dfc> shachaf: im new to haskell package management and its doing a number on me. im not sure if you are joking or being rude.
21:44:11 <dfc> xmonad and xmobar are both executables/binaries/programs a user runs. xmonad shows up in ghc-pkg list, xmobar does not
21:44:56 <shachaf> dfc: That's because xmoand is a -- oh.
21:45:03 <shachaf> I thought you said "xmonad is a library".
21:45:09 <shachaf> xmonad *is* a library as well as a binary.
21:45:12 <shachaf> xmobar is just a binary.
21:45:38 <nalssi> ghc understands (-1) as a number not a function that subtracts 1. How do I get it done?
21:45:47 <shachaf> (subtract 1)
21:45:47 <dfc> so the housekeeping things that "ghc-pkg check" does do not take into consideration xmobar's needs?
21:45:57 <shachaf> I'm not sure what you mean.
21:46:00 <nalssi> shachaf: Thank you
21:46:02 <shachaf> But ghc-pkg is only for libraries.
21:46:09 <dfc> ok
22:17:12 <dylukes> naissi: or use pred...
22:19:35 <bcw> dylukes, nalssi already left.  but good recommendation, assuming it's really subtracting one that s/he wants
22:20:44 <dylukes> iterate pred x !! n
22:20:45 <dylukes> :P?
22:21:00 <bcw> hehe
22:24:12 <Axman6> dylukes: warning about pred to subtract 1, it always does a check to see if it's going to underflow, so there's quite a bit of overhead. (subtract 1) is usually a lot faster
22:24:30 <dylukes> That's probably desired behavior.
22:24:35 <dylukes> Premature optimization is bad :P.
22:26:23 <bcw> even tho it does check, it just gives an error on failure. probably not desired
22:26:28 <dylukes> Yo dawg I herd you like lazy evaluation... so we put thunks in your thunks so you can lock up while you evaluate the results of long folds.
22:26:45 <dylukes> bcw: At least there's an indication instead of a silent failure.
22:26:46 <gardnan> dylukes: +1
22:33:11 <dmwit> dylukes++ since gardnan seems not to know how to do this ;-)
22:33:50 <dylukes> In here when someone is helpful, we just succ them.
22:34:03 <gardnan> ok
22:34:09 <dylukes> Wait whoops, this isn't #blah... *covers mouth*
22:39:12 <hpaste> beefcube pasted “simple parsec symbol use-case” at http://hpaste.org/70969
22:39:18 <beefcube> the posted is an example from the parsec manual that won't compile, clue please?
22:40:25 <beefcube> parsec 3.1.3
22:46:39 <zzing_> Within snap, how can a function defined as getConf = commandLineConfig defaultConfig   be given a type of IO (Config Snap AppConfig) when commandLineConfig is Config m a -> IO (Config m a)  and defaultConfig is Config m a.  The part I am not seeing is where Snap and AppConfig come into being.  (specific source code is here: http://hpaste.org/70970 )
22:46:48 <mgsloan> and so the war on anti-intellectualism in /r/programming continues: http://www.reddit.com/user/mgsloan
22:46:53 <mgsloan> ;P
22:49:30 <dylukes> beefcube: symbol is a member of a record.
22:49:37 <dylukes> (GenTokenParser specifically)
22:49:54 <dylukes> `symbol tokparser string'
22:50:12 <dylukes> `symbol tokparser' resolves to the (String -> ParsecT ...) function in the record,
22:50:20 <zzing_> mgsloan, can you explain exactly what you are trying to say here?
22:50:20 <dylukes> then that's applied to the string...
22:51:06 <beefcube> dylukes: ah, yes, thanks, skipped the part in the manual of creating a lexer first
22:51:58 <mgsloan> zzing_: Nothing, just that while /r/programming is overall reasonable, there are certain trolls that ignorantly criticize anything related to functional programming, and I've been wasting time fighting them.  And, notifying people that there's been a particular spark-up on /r/programming of OOP vs functional debates
22:52:12 <mgsloan> s/Nothing//
22:53:00 <zzing_> Fair enough.  I have experienced as well that any thing said or perceived against Haskell to be a downvote instant :-). I suspect it is in spirts.
22:53:42 <mgsloan> but I got inspired, and I think I've written down some pretty persuasive things
22:53:55 <mgsloan> maybe I'll bloggify them at some point to further fan the flames ;)
22:56:33 <mgsloan> Once we've decided to stop avoiding success (maybe that's already happened - though I actually quite like the idea of maintaining language agility until we're certain of things), someone should write a handbook of proselytization
22:57:05 <mgsloan> it's certainly an art, and persuading someone to devote months of their time to something is a huge challange
22:59:58 * mgsloan imagines pairs of haskellers going office to office..
23:04:02 <liyang> I'm cool with that as long as there's some equivalent of ‘please give blood’ stickers I can put on the door to tell them I'm not interested.
23:12:13 <zzing_> mgsloan, the thought is about as pleasing to me as door to door atheists in salt lake city
23:17:11 <maybefbi> Can haskell automatically derive a Monad/Functor instance?
23:17:28 <MostAwesomeDude> GHC can derive Functors, but not Monads.
23:17:30 <shachaf> GHC can derive Functor, I think.
23:17:42 <zzing_> How can it derive how a function maps over a container?
23:17:46 <shachaf> Are monad instances unique?
23:18:00 <shachaf> zzing_: How can you?
23:18:31 <rwbarton> (was that a rhetorical question?) they are not, e.g. think Writer
23:18:55 <maybefbi> shachaf, ah yeah there can be more than one Monad instance for any type. depends on what the programmer wants
23:19:17 <MostAwesomeDude> Functor instances are unique though.
23:19:20 <zzing_> shachaf, not easily :-)
23:19:33 <rwbarton> or particularly Writer W for some specific concrete type W
23:21:19 <mgsloan> maybefbi:  I'm working on a haskell extension proposal that would allow deriving functor / applicative from a monad instance
23:26:58 <maybefbi> mgsloan, thanks. Has any library already derived a Monad instance of Either. I am in the midst of coding it.
23:27:06 <maybefbi> I mean Either t
23:27:15 <mgsloan> Control.Monad.Either does
23:27:21 <maybefbi> oo cool
23:27:22 <maybefbi> thanks
23:27:27 <maybefbi> i will just import it
23:27:28 <shachaf> Control.Monad.Instances
23:27:47 <shachaf> (Which is part of the standard library -- I don't think the other one is.)
23:28:09 <maybefbi> sorry for these silly questions. I am still new to haskell
23:28:19 <dmwit> 'scool
23:32:11 <maybefbi> I keep getting a "No instance for (Monad (Either Error))". I have imported Control.Monad and it has a monad instance for Either e
23:32:32 <shachaf> I don't think Control.Monad has that instance.
23:32:50 <maybefbi> isn't Either e same as Either Error ?
23:32:51 <rwbarton> maybe in an older version it did
23:32:57 <maybefbi> oh ok
23:33:07 <shachaf> Control.Monad.Instances has it.
23:35:09 <bcw> maybefbi, no. "Either e" can have any type substituted for the type variable e, while "Either Error" only works with the type "Error"
23:36:01 <maybefbi> bcw, yeah. i got it working now because i imported Control.Monad.Instances which has an instance for Either e
23:36:15 <bcw> but that may not be important right now, esp. if you don't know what a type variable is yet
23:37:05 <rwbarton> the answer to the question maybefbi should have asked is yes anyways
23:37:17 <shachaf> "same as" is pretty close to "unifies with"
23:37:24 <shachaf> (In some ways.)
23:37:34 <maybefbi> yeah i meant "unify"
23:38:39 <bcw> ok, just wouldn't want maybefbi to try using an instance for something like "Either SomeErrorType" and wonder why it won't unify with "Either Error"
23:39:27 <maybefbi> true
23:41:41 <Axman6> is Error an actual type?
23:41:47 <Axman6> @hoogle Error
23:41:48 <lambdabot> Prelude error :: [Char] -> a
23:41:48 <lambdabot> Control.Exception.Base ErrorCall :: String -> ErrorCall
23:41:48 <lambdabot> Control.Exception ErrorCall :: String -> ErrorCall
23:42:00 <maybefbi> Axman6, i made Error
23:42:06 <Axman6> ah
23:54:26 <osa1> do we have any extensions to have ocaml style pattern matching, ie in ocaml you can have same body for multiple patterns ?
23:56:16 <liyang> How does it work if each pattern binds a different set of names?
23:57:52 <Axman6> osa1: make that same body a function. Abstraction++!
23:58:35 <osa1> liyang: then it doesn't work
23:58:48 <osa1> Axman6: it's still repetition
23:59:02 <dmwit> No, there's no such extension.
23:59:07 <Axman6> yes, but it's also well typed
23:59:07 <osa1> dmwit: thanks
23:59:18 <Axman6> where as the alternative may not be
23:59:34 <dmwit> Axman6: What are you on about?
23:59:56 <Axman6> i guess it could be well typed
