00:00:19 <Axman6> :t maybe (Left "Damn") Right
00:00:20 <lambdabot> forall b. Maybe b -> Either [Char] b
00:00:23 <latro`a> here we go
00:00:28 <latro`a> http://hackage.haskell.org/packages/archive/errors/latest/doc/html/Control-Error-Util.html#v:hush
00:00:28 <startling> latro`a: ah http://hackage.haskell.org/packages/archive/errors/1.2.1/doc/html/Control-Error-Util.html
00:00:31 <startling> jinx
00:00:32 <startling> ha
00:00:36 <Axman6> :t \d -> maybe (Left d) Right
00:00:37 <lambdabot> forall a b. a -> Maybe b -> Either a b
00:01:38 <startling> wow, ghc must have some pretty sophisticated recommendation engine
00:01:48 <startling> I asked for Control.Error, it thinks I want Control.Arrow
00:01:55 <edwardk> "danharaj :P. one other thing. I feel like the Lens type signatures are really clean when you restrict to type constructors / data families instead of the general lens families. Have you found a useful instance where you need more?" -- restrict to type constructors as in Simple Lens (t a) a ?
00:02:08 <edwardk> er as in
00:03:12 <Ralith> startling: what did you actually want?
00:03:34 <danharaj> Just guaranteeing i :: * -> * and o :: * -> * are injective in the section on lens families in the post.
00:03:36 <latro`a> Control.Error; presumably (s)he doesn't have errors installed
00:03:44 <startling> ^ that
00:04:22 <edwardk> traverseDynamic :: (Typeable a, Typeable b, Functor f) => (a -> f b) -> Dynamic -> Dynamic
00:04:30 <edwardk> same with traverseException
00:04:36 <edwardk> notice the inner indices change
00:04:37 <startling> I suppose the assonance is probably a coincidence, and it saw the orr, but still pretty cool
00:04:54 <edwardk> traverseDynamic :: (Typeable a, Typeable b) => Lens Dynamic Dynamic a b
00:05:12 <danharaj> cool.
00:05:39 <edwardk> traverseException is actually kinda useful
00:07:52 <danharaj> eww, how do I get ghc to print out prettied lens names instead of the full function signature?
00:11:58 <startling> hmm, Eithers are kind of annoying to deal with
00:12:08 <latro`a> how so?
00:14:00 <edwardk> danharaj: sadly you often can't
00:14:10 <edwardk> danharaj: so you get good at reading them after a while ;)
00:14:22 <danharaj> hehe
00:14:47 <danharaj> well I just figured out the shape of the error for composing lenses the wrong way. BTW, the only downside to using these lenses over the other ones.
00:16:15 <startling> latro`a, I have a tree-recursive function that returns an Either; is there a better way to deal with that than constant pattern matching?
00:16:42 <danharaj> use monadic style to thread through code that uses a lot of Eithers.
00:17:02 <startling> danharaj, I don't think Either is a monad?
00:17:13 <danharaj> It certainly is.
00:17:28 <startling> oh what. didn't see it here: http://www.haskell.org/ghc/docs/6.12.2/html/libraries/base-4.2.0.1/Data-Either.html
00:17:28 <danharaj> You must fix the Left value though.
00:18:37 <danharaj> The instance is listed in Control.Monad
00:18:59 <danharaj> figuring out the monad instance for Either e is good practice.
00:21:13 <danharaj> edwardk: one more downside is the monomorphism restriction apparently.
00:21:22 * hackagebot rpc-framework 0.1.0.0 - a remote procedure call framework (MatthewMirman)
00:21:36 <edwardk> danharaj: yeah, thats why clone exists
00:21:46 <edwardk> danharaj: but it doens't work on all the types
00:22:05 <edwardk> if you want to take a lens and use it multiple times put a signature on it
00:22:22 <danharaj> mm, not too painful.
00:22:29 <danharaj> So I just finished porting my stuff to lens.
00:22:39 <danharaj> All in all not very painful. The differences were minor.
00:22:56 <danharaj> and now I have a lot more machinery to work with... once I figure out what it does!
00:23:30 <danharaj> Now that I know there's more to lenses than painless record manipulation, I ponder their potential.
00:24:24 <edwardk> ghci>  5000^.from modifiedJulianDay.julianYearAndDay.from julianYearAndDay.gregorian.from gregorian.weekDate.from weekDate.ordinalDate.year   ==> 1872
00:24:25 <edwardk> whee
00:24:31 <danharaj> nice.
00:25:21 <edwardk> changing as many of the lenses as i can over to Iso
00:25:37 <edwardk> being able to construct a value from whole cloth is nice
00:26:02 <edwardk> x^.from foo  works pretty well
00:26:31 <edwardk> when i was using 'as' and 'was' it was also kinda cute
00:26:45 <edwardk> mytime^.as posix
00:26:51 <edwardk> and mytime^.was posix
00:27:44 <edwardk> now its just mytime^.posix and mytime^.from posix
00:27:57 <edwardk> i might swap from back to was, but it doesn't read as well in all situations
00:29:14 <startling> edwardk, is Trifecta's Result designed to be used for other parts of language implementation, too?
00:29:26 <danharaj> I could see iso lenses being nice for a serialization scheme
00:29:28 <edwardk> i hadn't really planned on it being used as such
00:29:30 <edwardk> yeah
00:30:02 <danharaj> also keeping track of coordinate systems when you're doing geometric code.
00:30:07 <danharaj> I've crashed enough from that :[
00:30:26 <startling> edwardk, which message is to whom?
00:30:31 <edwardk> =)
00:30:46 <danharaj> a superposition of both.
00:31:00 <startling> heh
00:31:00 <edwardk> startling: i hadn't intended it to be used in a very general capacity was to you and yeah it'd make a nice serialization tool to dan
00:31:09 <startling> edwardk: alright, thanks!
00:33:24 <quintessence> "was" as a function sounds like something Connor McBride would write, and his code uniformly turns my brain to goo
00:33:42 <quintessence> though I think the worst offenders are using interrogatives as function argument names
00:34:05 <edwardk> quintessence: =)
00:34:08 <danharaj> I shouldn't release my code then :[
00:34:17 <edwardk> i was admittedly channeling my inner conor with that ;)
00:36:08 * quintessence is working on a toy language with "preposition" in the grammar, and may have nonstandard taste in such things.
00:37:58 <startling> quintessence: do you have an example?
00:38:58 <quintessence> maybe (lookup name in env) else: error "not found"
00:39:10 <quintessence> which is a call to maybe/else
00:39:41 <quintessence> (and you can partially apply to prepositional arguments, so "(lookup in env) name" is a thing)
00:40:33 <lamefun> hello
00:40:58 <startling> quintessence: huh
00:41:02 <lamefun> is data X = X { getValue :: Real } just a shortcut to data X = X Real    getValue :: X -> Real ?
00:41:13 <startling> lamefun: yep
00:41:48 <lamefun> startling: and I can hold X opaque but export getValue like any normal function?
00:42:24 <startling> lamefun, I think so.
00:42:30 <amosr> hello.. any issues building ghc-head at the moment? md5.c and CmmSpillReload.hs missing?
00:42:31 <Axman6> lamefun: also gives you the ability to do x :: X, x { getValue = newValue } and it will give you a new X with all the original values of x intact, but getValue updated
00:42:47 <Axman6> amosr: #ghc would be a better place to ask
00:43:06 <amosr> Axman6: cool, will try
00:58:10 <slack1256> I've been reading about codata, sometimes is told that you need a specific keyword for 'codata'
00:58:35 <slack1256> but that with lazy-evaluation you could implement a type of codata without the keyword
00:58:44 <slack1256> am I misunderstanding?
01:04:03 <edsko> slack1256: in Haskell data == codata
01:04:27 <edsko> (least and greatest fixpoints coincide)
01:06:10 <slack1256> some people aren't happy about that definition (on blogs comments), but to me seems to be right
01:06:46 <edsko> ?
01:07:02 <slack1256> edsko: do we lost anything because our data is codata?
01:07:25 <slack1256> i read something about not being able to use induction proof on some blogpost of SML
01:07:53 <edsko> yes, that's true
01:08:23 <edsko> people often pretend that their data truly is inductive (finite) and do idnuction proofs
01:08:26 <edsko> but really it's not justified
01:10:43 <edsko> slack1256: or rather, proofs would be valid for finite inputs only
01:11:14 <slack1256> edsko: Any idea why haskell didn't choose to use 2 different keyword for data and codata?
01:11:26 <slack1256> edsko: not that i don't love their choice btw.
01:11:27 <edsko> heh. because it's very convenient :)
01:11:48 <edsko> if you truly want to make the disctinction, it's not just a matter of having two keywords
01:11:57 <slack1256> heh. that works.
01:12:02 <edsko> you need to enforce that they are used properly too
01:12:12 <edsko> for inductive definitions (data) you need to enforce termination
01:12:21 <edsko> for coinductive definitions you need to enforce productivity
01:12:39 <edsko> try writing some serious code in Coq or Agda and you will see what i mean by 'convenient' :)
01:13:04 <slack1256> Oh. okay that will be a good exercise.
01:13:34 <slack1256> mmm to me seems that a good portion of higher order function would be lost by that distinction on codata and data
01:13:37 <edsko> slack1256: 'filter' is a classical example of something that's not definable on codata, for instance
01:13:48 <slack1256> map would operate in CoList
01:14:02 <edsko> well you'd have a map for list and a map for CoList
01:14:02 <slack1256> yeah. that was I thinking.
01:14:23 <slack1256> right.
01:14:26 <edsko> (CoList usually known as stream)
01:14:40 <edsko> but at least map is easy to define
01:14:55 <slack1256> yes.
01:15:57 <slack1256> edsko: thanks a lot. you answered a lot of my doubts.
01:16:10 <edsko> slack1256: try agda, you'll learn a lot :)
01:16:18 <edsko> and it has a nice tutorial
01:16:34 <slack1256> definitely.
01:17:04 <liyang> (There's an #agda , btw.)
01:17:39 * slack1256 oh freenode, what would i do without you?
01:34:46 <obiwahn> > let fibs list = fibs list:(last list)+(last . init $ list) in fibs [1,1]
01:34:47 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
01:35:24 <nobdraisentone> Is there a function to convert lazy ByteString to strict ByteString?
01:35:45 <edsko> nobdraisentone: concat . toChunks
01:35:55 <edsko> but you should avoid doing that if possible
01:44:24 <int-e> obiwahn:  fibs list = fibs list ++ [last list + last (init list)]  would work, but it's more efficient and almost as easy to generate all Fibonacci numbers at once: let fibs = 0 : 1 : zipWith (+) (tail fibs) (tail (tail fibs)) in take 10 fibs
01:45:53 <obiwahn> thanks you int-e :)
01:45:57 <merijn> int-e: Why not drop one tail from both sides there? Actually, I think the result is not even right with two tails
01:46:44 <merijn> > let fibs = 0 : 1 : zipWith (+) (tail fibs) (tail (tail fibs)) in fibs
01:46:48 <lambdabot>   mueval-core: Time limit exceeded
01:46:55 <int-e> merijn: because I'm stupid and didn't test the code.
01:46:59 <obiwahn> were is the error in my try i try to identify what went wrong
01:47:03 <merijn> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs
01:47:04 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
01:47:16 <int-e> merijn: nor think enough about it :)
01:48:13 <int-e> merijn: my excuse is that I usually use  fibs = fix ((0:) . scanl (+) 1)
01:48:18 <merijn> I thought it was mandatory to know how to do 1 line fibonacci in Haskell :p
01:49:11 <merijn> :t last
01:49:13 <lambdabot> forall a. [a] -> a
01:49:15 <merijn> :t init
01:49:16 <lambdabot> forall a. [a] -> [a]
01:49:29 <nobdraisentone> Or maybe there is a way to make aeson encode/decode methods to strict ByteString?
01:49:33 <frerich> I think it's amazing how helpful this channel is - about 50% of my questions get answered just by typing the question in my IRC client without actually sending it.
01:49:39 <merijn> obiwahn: Oh, I see the problem
01:49:41 <mmaruseacph2> > take 10 $ fix ((0:) . scanl (+) 1)
01:49:43 <lambdabot>   [0,1,1,2,3,5,8,13,21,34]
01:49:56 <quicksilver> nobdraisentone: why do you want a strict bytestring in the first place?
01:50:20 <merijn> obiwahn: You're doing "list:foo" but list is type [Int], so you're trying to use (:) as type "[a] -> [a] -> [a]", but its type is "a -> [a] -> [a]"
01:50:43 <mmaruseacph2> now, I'm thinking why the fix version works
01:50:53 <merijn> mmaruseacph2: Brainfuckery and voodoo :)
01:51:01 <mmaruseacph2> :t fix
01:51:02 <lambdabot> forall a. (a -> a) -> a
01:51:33 <quicksilver> fix is just a way of writing  recursive definition.
01:51:39 <mmaruseacph2> of course :)
01:51:58 <mmaruseacph2> fix f = f (fix f) or something like that
01:52:18 <nobdraisentone> quicksilver: I wanna send these BS over network (write by hPutStrLn, read by hGetLine)
01:52:52 <quicksilver> nobdraisentone: you can hPutStr lazy bytestrings just as well as strict.
01:53:01 <nobdraisentone> quicksilver: what about read?
01:53:07 <quicksilver> yes, that too.
01:53:12 <quicksilver> they'd be pretty useless if you couldn't.
01:53:45 <mmaruseacph2> found it, I feel enlightened
01:53:57 <nobdraisentone> Reading lazy BS is kinda wierd process
01:54:00 <merijn> mmaruseacph2: The trick is that the (0:) at the start will always make any result start with 0 and then scanl does the rest
01:54:44 <mmaruseacph2> > take 10 $ fix ((1:) . scanl (+) 1)
01:54:46 <lambdabot>   [1,1,2,3,5,8,13,21,34,55]
01:54:50 <mmaruseacph2> yup
01:54:56 <mmaruseacph2> :t scanl
01:54:57 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
01:54:58 <quicksilver> fix ((0:) . scanl (+) 1) = fix (\a -> 0 : (scanl (+) 1 a))
01:55:05 <quicksilver> and that is the same as
01:55:13 <quicksilver> let a = a : scanl (+) 1 a in a
01:55:17 <mmaruseacph2> thanks :)
01:55:23 <quicksilver> erm that shoul dbe a 0 before the :
01:55:28 <quicksilver> let a = 0 : scanl (+) 1 a in a
01:55:35 <mmaruseacph2> obvious :)
01:55:55 <obiwahn> let fibs list = fibs (list ++ [ last list + last (init list) ]) in take 10 $ fibs [1,1]
01:56:01 <obiwahn> mh still not working:(
01:56:09 <mmaruseacph2> let fibs list = fibs (list ++ [ last list + last (init list) ]) in take 10 $ fibs [1,1]
01:56:12 <mmaruseacph2> > let fibs list = fibs (list ++ [ last list + last (init list) ]) in take 10 $ fibs [1,1]
01:56:18 <lambdabot>   mueval: ExitFailure 1
01:56:18 <lambdabot>  mueval: Prelude.undefined
01:56:22 <mmaruseacph2> you forgot the `>`
01:57:41 <merijn> obiwahn: Oh, I see why. Because you immediately recurse into fibs without returning any initial results take 10 can't lazily return the start
01:58:17 <obiwahn> though i see all the other nice solutions and found even more at the wiki - ah
01:58:43 <merijn> obiwahn: Calculating "fibs [1,1]" immediately calls "fibs ([1,1] ++ [2])", which in turn immediately calls "fibs ([1,1,2] ++ [3])"
01:58:47 <Jafet> > take 10 . map length $ fix (([]:).([()]:).(zipWith(++)<*>tail))
01:58:48 <quicksilver> productive infinite recursion needs to yield a constructor (like (:)) before it recurses infinitely.
01:58:49 <lambdabot>   [0,1,1,2,3,5,8,13,21,34]
01:59:16 <merijn> obiwahn: The reason why the zipWith example works is that laziness lets it return the 0 and 1 before trying to recursively evaluate the rest
02:00:02 <obiwahn> let fibs = 1:1 ++ [ (last fibs + last (init list) ] in fibs
02:00:04 <obiwahn> > let fibs = 1:1 ++ [ (last fibs + last (init list) ] in fibs
02:00:05 <lambdabot>   <no location info>: parse error on input `]'
02:00:09 <merijn> obiwahn: The constructor essentially lets the runtime look at the head of the list and treat the tail as "something I'll compute later" whereas your code forces it to compute both in one go
02:00:59 <obiwahn> > let fibs = 1:1 ++ [ (last fibs) + last (init list) ] in fibs
02:01:01 <lambdabot>   Not in scope: `list'
02:01:08 <obiwahn> > let fibs = 1:1 ++ [ (last fibs) + last (init fibs) ] in fibs
02:01:09 <lambdabot>   No instance for (GHC.Num.Num [a])
02:01:09 <lambdabot>    arising from a use of `e_111' at <inte...
02:01:26 * hackagebot hastache 0.4.2 - Haskell implementation of Mustache templates (SergeyLymar)
02:01:28 * hackagebot stm-sbchan 0.1 - Bounded channel for STM where item sizes can vary (JoeyAdams)
02:02:25 <Jafet> @where stepeval
02:02:25 <lambdabot> http://www.srcf.ucam.org/~bm380/cgi-bin/stepeval.cgi
02:02:59 <obiwahn> > let fibs = 1:1 : ((last fibs) + last (init fibs)) in fibs
02:03:00 <lambdabot>   Occurs check: cannot construct the infinite type: t = [t]
02:03:23 <obiwahn> back to my intal error:P
02:04:12 <Jafet> > let fibs = 1:1:[last fibs + last (init fibs)] in fibs
02:04:16 <lambdabot>   mueval-core: Time limit exceeded
02:04:37 <ion> last will try to find the end of the list, won’t it?
02:04:41 <ion> s/find/reach/
02:04:54 <Jafet> Well, that's not a problem here
02:05:07 <Jafet> The funny bit is when (+) tries to get the value of last fibs
02:05:54 <Jafet> > let fibs = [a,b,c] where a = 1; b = 1; c = c + b in fibs
02:05:57 <lambdabot>   mueval-core: Time limit exceeded
02:11:03 <Jafet> :t let init [x] = []; init (x:xs@(:){}) = x:init xs in init
02:11:05 <lambdabot> forall a. [a] -> [a]
02:11:51 <Jafet> Sadly this construct doesn't usually save any strokes
02:12:01 <Jafet> I like it though
02:12:13 <merijn> Jafet: Initially he had fibs as a function taking an extra argument
02:13:12 <Jafet> Oh
02:13:22 <Jafet> And int-e answered with a bottom
02:14:17 <merijn> > let fibs list = list : drop (length list) (fibs (list ++ [last list + last (init list)]) in take 10 $ fibs [0,1]
02:14:18 <lambdabot>   <no location info>: parse error on input `in'
02:14:37 <merijn> > let fibs list = list : drop (length list) (fibs (list ++ [last list + last (init list)])) in take 10 $ fibs [0,1]
02:14:43 <lambdabot>   mueval: ExitFailure 1
02:14:43 <lambdabot>  mueval: Prelude.undefined
02:14:55 <obiwahn> > let fibs = 1:1 : \fibs -> ((last fibs) + last (init fibs)) in fibs
02:14:57 <lambdabot>   The lambda expression `\ fibs
02:14:57 <lambdabot>                             -> ((GHC.List.las...
02:15:20 <merijn> obiwahn: The last argument to : is a function in that example, which won't work
02:16:17 <obiwahn> > let fibs = 1:1 : (\fibs -> ((last fibs) + last (init fibs))) fibs in fibs
02:16:18 <lambdabot>   Occurs check: cannot construct the infinite type: t = [t]
02:16:37 <obiwahn> the zipwith returns a list
02:17:00 <merijn> Yes, but your function does not return a list
02:17:18 <obiwahn> > let fibs = 1:1 : [ (last fibs + last (init list) ] in fibs
02:17:19 <lambdabot>   <no location info>: parse error on input `]'
02:17:29 <obiwahn> > let fibs = 1:1 : [ (last fibs + last (init fibs) ] in fibs
02:17:30 <lambdabot>   <no location info>: parse error on input `]'
02:17:41 <Jafet> Programming by guessing
02:17:43 <merijn> obiwahn: fibs will be infinite, so last fibs will never return a result
02:17:58 <merijn> > last [1..]
02:18:01 <lambdabot>   mueval-core: Time limit exceeded
02:18:13 <obiwahn> ok:)
02:19:53 <Jafet> > let gibs xs = uncurry (++) . second gibs $ splitAt 1 (xs ++ [sum xs]) in gibs [0,1]
02:19:55 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
02:21:20 <merijn> Jafet: Probably not so helpful for his understanding ;)
02:22:33 <t7> i really hope no one writes one liners in real code
02:24:50 <Jafet> I do!
02:25:40 <t7> for shame
02:26:27 <Botje> my code is a series of oneliners.
02:26:30 <Jafet> I'm not smart enough to write pearls, so I just write perls
02:26:49 <t7> :)
02:26:53 <quintessence> @hoogle (Monad m) => (a -> m b) -> f a -> m (f b)
02:26:55 <lambdabot> Data.Traversable mapM :: (Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)
02:26:55 <lambdabot> Data.Traversable forM :: (Traversable t, Monad m) => t a -> (a -> m b) -> m (t b)
02:26:55 <lambdabot> Prelude mapM :: Monad m => (a -> m b) -> [a] -> m [b]
02:27:56 <obiwahn> splitAt 1 hello
02:27:59 <obiwahn> > splitAt 1 hello
02:28:00 <lambdabot>   Not in scope: `hello'
02:28:11 <obiwahn> > splitAt 1 "hello"
02:28:12 <lambdabot>   ("h","ello")
02:28:19 <MHD> What's the scope of "where" compared to (pattern) guards?
02:29:21 <t7> i need type level uncurry
02:29:27 <Jafet> > let f x | y = y | otherwise = x where y = not x in f <$> [False, True]
02:29:28 <lambdabot>   [True,True]
02:29:40 <Jafet> I want type level ($)
02:30:08 <quintessence> (I was about to say "for that you'd need type-level tuples" before I remembered we have those now)
02:30:38 <VitamnP> Does anyone know why I get the error "BookShop.hs:4:6: Malformed head of type or class declaration: name" in this? -> http://bpaste.net/show/BNjq0gwUN7iGORtVrQXb/
02:30:54 <t7> types must be uppercase
02:30:58 <t7> or start with uppercase
02:31:18 <VitamnP> oh right lol, how'd I miss that
02:31:21 <VitamnP> thatnks t7
02:31:33 <quintessence> being able to bundle up type parameters into type-level tuples or records would actually be quite nice
02:32:16 <quintessence> especially for things like pipes/conduit where you have a ton of type parameters everywhere
02:35:10 <t7> type classes have their own term language...
02:35:23 <obiwahn> Jafet: how does your line work?
02:36:47 <t7> HALO: Haskell to Logic through Denotational Semantics: Describes how to translate Haskell and user-specified contract specifications into first order logic, and thereby prove that the program satisfies the contract.
02:36:55 <t7> this sounds very very cool
02:37:20 <t7> finally monads must obey teh law!
02:38:10 <Jafet> I can haz semantics for RealWorld?
02:38:59 <Jafet> obiwahn: very well, I think
02:39:29 <obiwahn> yes it does but id like to understand what it does:)
02:39:56 <Jafet> http://bm380.user.srcf.net/cgi-bin/stepeval.cgi?expr=let+fibs+%3D+0+%3A+1+%3A+zipWith+%28%2B%29+fibs+%28tail+fibs%29+in+fibs
02:40:22 <Jafet> Unfortunately benm hasn't made stepeval lazy yet
02:40:47 <Jafet> But it gives a verbose trace
02:41:47 <obiwahn> i have tried your's but not the zipwith function ... but i do not see that much from it
02:42:37 <Jafet> zipWith starts from the head of fibs, which is already defined, so it can continue
02:43:33 <Jafet> It's like a machine that rolls along a road and while rolling it adds new road in front of it
02:44:03 <Jafet> So that it can keep rolling
02:44:16 <Jafet> I should put a meme here but can't remember the right one
02:46:04 <obiwahn> you uncurry the ++ so you feed a tuple to it
02:46:24 <obiwahn> first arg in the tuple is second fibs
02:47:02 <Jafet> second fibs = (\(x, y) -> (x, fibs y))
02:47:35 <Jafet> uncurry (++) . second fibs = \(x, y) -> x ++ fibs y
02:48:06 <Jafet> Actually it would have been shorter to write it this way..
02:48:36 <obiwahn> ah ok that helps a lot:)
02:49:10 <t7> this HALO stuff is like liquid types
03:01:36 <sopvop> you know what would be cool? If haskell-mode had a function to "UNDEFINED EVERYTHING!!111", like comment out all functions in file and add same names = undefined.
03:02:38 <quintessence> sopvop: ghc 7.6 will have -fdefer-type-errors, which would work similarly
03:03:51 <sopvop> That's awesome
03:05:35 <ion> quintessence: Interesting
03:06:19 <SoleSoul> Hello. I think I need either to add items to a list from the right efficiently or map on the list from right to left. Is one of these possible? Thanks
03:06:28 * hackagebot distributed-process 0.2.2.0 - Cloud Haskell: Erlang-style concurrency in Haskell (EdskoDeVries)
03:09:15 <fmap> SoleSoul: no
03:09:22 <fmap> well, not with lists
03:09:37 <SoleSoul> Isn't it a common need?
03:09:53 <quintessence> SoleSoul: assuming you mean mapM (since order is irrelevant for pure map), you may as well mapM f (reverse xs) -- it's O(n) already
03:10:58 <SoleSoul> quintessence: order is relevant in map because I do "all $ map ..." so if the leftmost item has a high probability to fail the computation will end sooner. Am I wrong?
03:11:03 <ion> solesoul: Use Data.Sequence
03:11:16 <mauke> SoleSoul: you could just use reverse
03:11:41 <SoleSoul> what is the complexity of reverse?
03:11:48 <osa1> GHC syntax and type system extensions are not standard, right? I'm writing a blog post about some extensions I use and I want to specify this detail
03:12:03 <SoleSoul> quintessence: sorry, not "all $ map..." but "all ..."
03:12:37 <SoleSoul> quintessence: so my question should have been if it is possible to evaluate "all" from the right
03:14:19 <quintessence> SoleSoul: it takes O(n) time to get to the end of a linked list no matter how you do it
03:17:04 <quintessence> you're better off with Data.Sequence if you care about traversal order, though (in the spirit of the channel) I'd suggest you use whatever makes it easy to get it correct before trying to make it fast
03:17:56 <shachaf> It might clear things up if you think of lists as loops instead of as data structures. :-)
03:18:10 <SoleSoul> quintessence: it is correct. I tried it with numbers up to 100000 and it works. The trouble starts when it's up to millions.
03:21:20 <allsystemsarego> @src max
03:21:20 <lambdabot> max x y = if x <= y then y else x
03:21:54 <quintessence> shachaf: is there any formalization of that intuition beyond "stream fusion produces loops when it works"?
03:22:17 <allsystemsarego> @src product
03:22:17 <lambdabot> product = foldl (*) 1
03:22:51 <shachaf> quintessence: Fusion or not, lists behave a lot like loops.
03:22:55 <shachaf> Lazy lists, that is.
03:23:04 <shachaf> I don't know about formalization of it.
03:23:26 <shachaf> "data structures act as control structures" is one of the nice things about Haskell, though.
03:23:45 <shachaf> Tell me if you find a place that has a concise explanation of it. :-)
03:24:02 <SoleSoul> maybe I don't need what I'm looking for and I'm just not thinking correctly. I'm trying to find out if a number is dividable by a list of numbers. I do it like that: [code] all (\x -> (mod num x) /= 0) numbers [/code] . The lowest number is on the left of the list because I want to test from the lowest to highest.
03:24:37 <bartavelle> SoleSoul, there are a few number theoritic packages that will do this fast
03:24:57 <merijn> SoleSoul: Blind stab in the dark, you're doing Project Euler challenges? :p
03:25:05 <bartavelle> merijn, ;)
03:25:13 <SoleSoul> Of course :)
03:25:20 <bartavelle> http://www.haskell.org/haskellwiki/Prime_numbers
03:25:25 <merijn> I hate Project Euler, the challenges are completely useless for learning new programming languages...
03:25:51 <bartavelle> yeah well, they are useful for figuring you need to learn math
03:25:55 <merijn> And as a result a lot of people come here with bizarre problems with their code that they wouldn't have in normal programs and get confused about why this is the case
03:26:08 <SoleSoul> Math is my weakest side so I want to come to terms with it!
03:26:30 <Jafet> project euler problems are great for learning how to solve project euler problems
03:26:36 <Jafet> Don't dis them
03:26:39 <merijn> Jafet++
03:26:42 <bartavelle> true
03:26:44 <MasseR> merijn: Which is why I'm glad haskell has the 99 problems. I don't think I've seen similar with other languages
03:26:56 <SoleSoul> it's like these riddles in the newspaper. They are fun.
03:27:26 <Jafet> You can use rem instead of mod, for whatever difference it makes
03:27:29 <quintessence> shachaf: I guess the direct correspondence is to coroutines, with (:) corresponding to yield (and the tail of the list being the coroutine's continuation)
03:27:58 <merijn> SoleSoul: Sure, but when people don't know the language they're working in well enough, solving those puzzles damages your understanding of the language
03:27:59 <Jafet> You could in theory do a binary search on gcd, but Prelude.gcd doesn't call mpz
03:28:22 <SoleSoul> MasseR: but the 99 problems don't give you credit on solving and don't record your progress :)
03:28:39 <mauke> which euler problem is this?
03:28:45 <Jafet> Yeah we should totally make an achievement unlocked picture for those
03:28:51 <Jafet> That will work
03:29:00 <MasseR> SoleSoul: Well "somebody" could make a similar thing to 4clojure, but with the 99 problems :D
03:29:08 <MasseR> Actually, not a bad idea
03:29:09 <SoleSoul> merijn: how trying to solve problems damages your understanding of the language?
03:29:36 <Jafet> You end up writing c++ in haskell
03:30:27 <SoleSoul> It is problem number 10!
03:30:41 <SoleSoul> sum of primes up to 2M
03:31:01 <Jafet> > nubBy (((>1).).gcd) [2..] -- trololo
03:31:03 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
03:31:05 <merijn> MasseR: Get coding!
03:31:12 <mauke> Jafet: needs more .:
03:31:29 <shachaf> > nubBy((>1).:gcd)[2..]
03:31:31 <hpaste> SoleSoul pasted “euler 10” at http://hpaste.org/72378
03:31:31 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
03:31:56 <MasseR> merijn: sure, after I finish this transdimensional time-making machine
03:32:14 <SoleSoul> this is my naive solution which surprisingly works quite well for numbers up to 100000
03:32:25 <mauke> if you're going to do it the stupid way, why not http://hpaste.org/72379 ?
03:32:36 <merijn> > sum . takeWhile (<=2000000) . nubBy ((>1).:gcd) $ [2..]
03:32:40 <lambdabot>   mueval-core: Time limit exceeded
03:32:41 <SoleSoul> Is it thinking in C++?
03:32:43 <merijn> aww
03:32:47 <Jafet> @src nubBy
03:32:47 <lambdabot> nubBy eq []             =  []
03:32:47 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
03:33:33 <SoleSoul> mauke: who wrote this?
03:33:38 <mauke> SoleSoul: me
03:33:43 <SoleSoul> now?/
03:33:48 <SoleSoul> 0.o
03:33:51 <mauke> no, it's an old file I had lying around
03:34:38 <mauke> SoleSoul: optimized: http://hpaste.org/72380
03:36:07 <SoleSoul> mauke: where is the prime generation? this is the only hard part
03:36:33 <Jafet> It's named "primes"
03:36:49 <mauke> SoleSoul: http://mauke.hopto.org/tmp/primes.txt
03:36:55 <mauke> my favorite prime generator is wget
03:37:28 <mauke> I also have a file with all primes up to 1000000000
03:37:44 <mauke> (480 MB but it's worth it)
03:37:45 <SoleSoul> mauke: did you download that also?
03:37:47 <mauke> yes
03:37:53 <SoleSoul> :)
03:37:54 <SoleSoul> ...
03:37:55 <SoleSoul> where is the fun?
03:38:21 <mauke> the fun is in solving euler problems by brute force
03:39:29 <SoleSoul> So, you all say leave euler and move to 99 Haskell problems?
03:39:48 <mauke> no, to http://spoj.pl/ of course
03:41:21 <MHD> Hmm... My continuation arrow parser is turning out to be rather elegant
03:41:50 <hpaste> marcot pasted “Strictness doubt” at http://hpaste.org/72381
03:42:28 <marcot> Hi.  I'm having trouble understanding strictness and $!!.  The commented version (-- return $! fromList c) works, but the uncommented gives too many open file exception.
03:42:47 <SoleSoul> mauke: were you serious about spoj?
03:42:50 <marcot> If I change to strict readFile, I get a memory leak in the uncommented version, and the commented version keeps working.
03:42:54 <mauke> SoleSoul: sort of
03:43:42 <marcot> I thought that using return $ fromList $!! c would be as strict as (or more than) return $! fromList c.
03:43:57 <SoleSoul> mauke: then between the three spoj is your recommendation? :/
03:44:57 <Jafet> return isn't strict
03:44:59 <quintessence> marcot: the (fromList $!! c) is never demanded because the outer (return $ ...) is lazy
03:45:59 <Jafet> $! isn't very strict either, the magic is that M.fromList is strict
03:46:09 <Jafet> Or S.fromList
03:47:28 <marcot> I see, thanks.
03:49:13 <Jafet> readFile' f = last s `seq` s where s = readFile f
03:49:32 <qnikst> another question about FFI and types I have enum in c code typedef enum { a = 0, b =1} foo; and I want to use it in haskell code
03:50:15 <qnikst> so I'm making newtype Foo = Foo {unFoo :: (?what type here?)} and #{enum Foo, Foo, a = a, b=b} ?
03:50:34 <qnikst> and I don't know what type should be used when I'm unwrapping
03:50:44 <Jafet> Int?
03:50:52 <bitonic> qnikst: just define a datatype and then a function DataType -> CInt, using the const thing of hsc2hs
03:51:28 <qnikst> so I do, thanks
03:51:36 <qnikst> so it will be CInt?
03:51:40 <bitonic> qnikst: yes
03:51:57 <qnikst> thanks
03:52:33 <qnikst> and one more question, can I check if I'm building app on arm? to use different types
03:52:44 <int-e> both hsc2hs and c2hs have enum support, I think.
03:53:21 <Skola> does anyone have experience with a good html tempting package other than heist and hamlet?
03:53:32 <Skola> templating
03:53:40 <qnikst> I've used example from RWH, but there was an issue that I should define type myself
03:53:46 <qnikst> (in newtype)
04:00:18 <hpaste> marcot annotated “Strictness doubt” with “Strictness doubt (annotation)” at http://hpaste.org/72381#a72382
04:01:06 <marcot> Now if this is the situation, how can I change the functions to make it strict?
04:01:18 <marcot> Without removing the call to readf and process?
04:02:19 <marcot> I thought about "process l = id $! fromList l", but it didn't work.
04:04:40 <Jafet> Nice, a hlint error
04:04:48 <Jafet> Two hlint errors
04:05:59 <Jafet> Also, (id $!) is id
04:06:19 <Jafet> Perhaps you don't really understand what seq means
04:06:34 * hackagebot fay 0.4.0.4 - A compiler for Fay, a Haskell subset that compiles to JavaScript. (ChrisDone)
04:07:21 <Jafet> (seq x y) means when y is evaluated, evaluate a little bit of x
04:07:32 <Jafet> Note the condition
04:08:39 <gspr> Suppose I have a pointer to data given to me from C using FFI. How should I, unsafely and in O(1) time, with myself being the only safeguard of referential transparency, turn it into a ByteString?
04:08:44 <MHD> what's the warning pragma look like?
04:08:54 <marcot> Jafet: Ok, I understand that id $! is the same of id now, but how can I change the code to make the read strict?
04:09:17 <gspr> I can think of several ways, but I'd also like it to be managed by Haskell's GC... is that possible, without manually setting a finalizer for the underlying C data?
04:09:18 <Jafet> gspr: I don't think you can
04:09:26 <sopvop> How does one convert Int to Pico?
04:09:32 <Jafet> Doesn't ByteString have a maximum chunk size?
04:09:45 <MHD> sopvop: fromIntegral?
04:09:49 <gspr> Jafet: Hmm, what do you mean?
04:09:54 <sopvop> oh
04:10:10 <Jafet> Well, you might be talking about the strict ByteString
04:10:16 <MHD> Jafet: Bytestring uses Int internally
04:10:28 <MHD> Jafet: Bytestring.Lazy uses Int64
04:10:47 <gspr> Jafet: Yes, sorry, strict bytestring
04:10:47 <marcot> Jafet: I changed process <$> readf i to do {f <- readf i; return $! process f} and it worked.  Thank you for your help.
04:11:08 <jedai> gspr: http://www.haskell.org/ghc/docs/latest/html/libraries/bytestring-0.9.2.1/Data-ByteString-Unsafe.html#g:4
04:11:33 <gspr> jedai: Right.. good, that's what I've been thinking
04:11:42 <Jafet> process <$> readf i looks strict
04:11:58 <gspr> jedai: but there is a notice there about the BS not having any finalizer associated with it
04:12:11 <gspr> jedai: and it not being managed by the haskell GC
04:12:20 <gspr> jedai: Does that mean I have to associate a finalizer to the underlying c data myself?
04:13:03 <Adrian_> chat
04:13:08 <Jafet> unsafePackCStringFinalizer looks promising
04:13:14 <marcot> Jafet: Well, making this single change made the code work.
04:13:37 <gspr> Jafet: I... I must be blind
04:13:45 <Jafet> Perhaps IO.<$> isn't strict enough
04:13:45 <gspr> Jafet: Thanks for seeing for me ;)
04:13:57 <gspr> and sorry to waste your time :)
04:14:02 <gspr> it's exactly what I need -- great!
04:14:09 <Jafet> gspr: C does that to people
04:14:31 <gspr> Jafet: :)
04:14:33 <jedai> gspr: I think most of them have finalizer (in particular the unsafePackAdress
04:15:04 <gspr> jedai: Heh, I've actually ignored all the functions that take Addr#, since I didn't know what it was...
04:15:17 <gspr> jedai: But now I see... it's essentially just a pointer from the outside world, right?
04:15:27 <gspr> *to the outside world
04:18:03 <jedai> gspr: By reading the source, it seems there is no finalizer either so, your first solution is probably the best
04:19:00 <Jafet> unsafePackAddress is for static data
04:19:08 <gspr> jedai: What Jafet suggested looks good. unsafePackCStringFinalizer
04:19:16 <Jafet> Obviously you don't finalize something in .text or whatever
04:19:22 <gspr> right
04:19:27 <donri> isn't there a <$!>
04:19:58 <Jafet> donri: in the platonic sense?
04:22:59 <Jafet> Well f <$!> x = x >>= (return $!) . f
04:23:09 <Jafet> But I don't see a definition for Functor
04:24:36 <Jafet> marcot: you might find evaluate useful
04:24:37 <Jafet> @type evaluate
04:24:38 <lambdabot> Not in scope: `evaluate'
04:24:43 <Jafet> @type Control.Exception.evaluate
04:24:44 <lambdabot> forall a. a -> IO a
04:25:21 <marcot> Jafet: Indeed, I'll remember it when I have another problem with strictness, thanks.
04:25:37 <Jafet> Heh, there's now a .Safe of everything
04:30:22 <cocon> Hi! The following seems to consume too much memory, but only when compiled with -O:
04:30:27 <cocon> main :: IO ()
04:30:27 <cocon> main = print (f 100000, f 100001) where
04:30:27 <cocon>   f :: Int -> Double
04:30:27 <cocon>   f n = foldl' (+) 0 $ [1..fromIntegral n]
04:30:30 <cocon>  
04:31:14 <cocon> By "too much" I mean that it runs out of memory when run with +RTS -M1M.
04:31:34 <qnikst> another FFI question I have a type that can be either double or float depending on arch and some constants
04:32:04 <qnikst> how can I make a proper binding on haskell side, assuming I use hsc2hs
04:32:32 <cocon> Removing the "f 100000", removing the "-O", and replacing the "Double" with "Int" all make it work miraculously...
04:33:02 <quintessence> cocon: try -fno-full-laziness
04:33:22 <Jafet> Does ghc do cse on that?
04:34:30 <cocon> qunintessence: that did it! I suspected something like this (as the heap profile shows a list being maintained)... can you explain what's going on?
04:35:13 <cocon> also, why is it fine when "Double" is replaced with "Int"?
04:36:05 <quintessence> it's floating out some intermediate value from inside `f` (the let-floating transform), which makes it unable to collect the list as it's produced
04:36:35 <quintessence> (I have no idea exactly *what* is being shared, but that's one of the very few optimizations that can make space usage blow up like that)
04:36:53 <cocon> I see. Probably time to read some core...
04:36:56 <cocon> Thanks!
04:37:37 <Jafet> I have no idea what it could possibly share
04:41:47 <Jafet> Does UArray i Bool use bit packing?
04:44:49 <Athas> Jafet: yes.
04:45:10 <Jafet> Ok, thanks
04:45:50 <Jafet> Actually, I realized that this isn't very useful for a sparse matrix of Bool
04:45:54 <Jafet> Because it would be all ones
04:48:14 <b52> does anyone use hbro and tell me where i find the default key bindings? ;:D
04:49:13 <quintessence> @src enumFromTo @Int
04:49:13 <lambdabot> Source not found. Maybe you made a typo?
04:51:35 * hackagebot socks 0.4.2 - Socks proxy (version 5) implementation. (VincentHanquez)
04:52:13 <confusing> http-conduit uses strings to find headers, as in «lookup "content-length" hs». it has constants like "hContentLength :: HeaderName" imported, but doesn't use them. any ideas why?
04:52:26 <confusing> it seems less safe to me in the sense of ghc catching typos for you, etc.
04:52:50 <Jafet> @src Int enumFromTo
04:52:50 <lambdabot> Source not found. Just what do you think you're doing Dave?
04:53:01 <Jafet> @src Integer enumFromTo
04:53:01 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
04:59:02 <qnikst> hm hsc2hs fails to create a small constant
05:02:44 <quintessence> Jafet, cocon: aha!  enumFromTo for Double (which is numericEnumFromTo in GHC.Real) is defined in terms of takeWhile and (numeric)EnumFrom
05:03:48 <quintessence> so with just the right amount of inlining that infinite list can get floated out of f
05:44:01 <t7> I sent an email to SPJ :3
05:44:30 <ciaranm> you should just talk to him in person. it's easier.
05:44:54 <t7> Cambridge is like 100 miles away
05:45:07 <confusing> t7: did you get an email auto-response with a type error?
05:45:24 <t7> yes :(
05:45:44 <t7> holiday until 13th august
05:50:06 <confusing> No instance for (Reader SPJ) arising from a use of `readEMail'. Possible fix: wait until 13 August ...
05:51:02 <t7> first time i have seen a github repo linked in a paper
05:51:05 <t7> :)
05:51:37 * hackagebot srcloc 0.2.1 - Data types for managing source code locations. (GeoffreyMainland)
05:52:55 <t7> danr
05:53:13 <t7> im all up in your paper
06:06:36 <lamefun> hi
06:07:37 <mekeor> hi lamefun
06:07:56 <lamefun> How to use FRP?
06:19:17 <merijn> lamefun: Which library?
06:19:26 <lamefun> IDK
06:20:07 <donri> lamefun: maybe http://www.haskell.org/haskellwiki/FRP_explanation_using_reactive-banana is a place to start
06:23:00 <merijn> The reactive banana tutorial was pretty readable, IMO
06:27:26 <lamefun> That look simple, but what about FRP games? For example, player position depends on the entire previous history of the game. Should I keep it all in memory?
06:28:26 <t7> params@Params{..} <- cmdArgs defParams
06:28:33 <t7> does that unpack into current scope?
06:30:06 <quintessence> t7: yes (with RecordWildCards)
06:38:17 <triyo> I'm trying to create an instance of Ord for something like (Key k, v) whereby `k' should be comparable and `v' excluded from the comparator all together.
06:39:19 <opqdonut> "data Keyed k a = Keyed k a; instance Ord k => Ord (Keyed k a) where compare (Keyed k _) (Keyed k' _) = compare k k'"
06:39:21 <sipa> how do you mean 'excluded' ?
06:40:04 <opqdonut> oh right, needs an Eq instance too
06:40:07 <opqdonut> but that's similar
06:40:15 <triyo> Should not form part of the comparing process.
06:41:04 <opqdonut> triyo: do you understand the code I just wrote?
06:41:13 <opqdonut> it's slightly neater to use a full datatype instead of a tuple
06:41:30 <opqdonut> firstly, now you don't need any extensions to the language
06:41:54 <opqdonut> secondly, it's clearer
06:43:00 <triyo> I'm trying to understand the Keyed... It contains the ket and value. I need to be able to have  a separate Key value too
06:43:08 <triyo> *ket=key
06:43:29 <int-e> triyo: then replace 'k' by 'Key k'.
06:43:36 <opqdonut> yeah
06:43:42 <opqdonut> or it can just be k
06:43:59 <triyo> I see what you mean... You need the Keyed for the Ord to make sense in the header part.
06:44:01 <opqdonut> if the keys are something like DatabaseKey, RowNumber
06:44:02 <int-e> triyo: In opqdonut's code, k is the key value's type.
06:44:06 <mm_freak> Lens (Keyed k a) k
06:44:19 <opqdonut> triyo: exactly
06:44:33 <int-e> If you really have to use tuples, you can toy with  newtype Ignore v = Ignore v; instance Eq (Ignore v) where _ == _ = True; instance Ord (Ignore v) where _ `compare` _ = Eq. Then you can use (k, Ignore v).
06:44:50 <opqdonut> that's nifty too, yes
06:44:51 <mm_freak> or more traditionally:  data Keyed k a = Keyed { keyedKey :: k, keyedValue a }
06:45:06 <int-e> But a separate tuple type as in opqdonut's code is neater.
06:45:13 <triyo> nice
06:45:26 <int-e> hmm. record type.
06:45:39 <opqdonut> you could make a "Ord (Key a, b)" instance with OverlappingInstances, though
06:45:47 <opqdonut> if you really wanted
06:45:52 <opqdonut> but Ignore is better
06:45:56 <mm_freak> when 'k' is a monoid, then Keyed k is a monad
06:47:31 <opqdonut> the Writer monad, to be exact
06:47:52 <int-e> mm_freak: is that meaingful? k is not acting like a key then.
06:48:31 <mm_freak> int-e: it does…  the Applicative and Monad turn two individual keys to a compound key
06:48:53 <mm_freak> consider k = Last Int
06:48:55 <int-e> mm_freak: oh if you're accessing trees. ok
06:48:55 <mm_freak> or something like that
06:49:39 <mm_freak> yeah, with [Int] you get tree indices for free
06:51:01 <mm_freak> but i have a feeling we're getting way ahead of triyo =)
06:52:31 <Simplyy> hello you spasticated autistic cunts
06:52:40 <int-e> mm_freak: that's perfectly normal #haskell behaviour. :)
06:52:50 <Simplyy> do i give a fuck
06:52:54 --- mode: ChanServ set +o quicksilver
06:52:55 <confusing> @where ops
06:52:56 <lambdabot> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
06:52:59 --- mode: quicksilver set +b *!*Simplyy@*.as13285.net
06:52:59 --- kick: Simplyy was kicked by quicksilver (byebye)
06:53:00 <mm_freak> Skola: there is also HSP, which is the primary templating engine of happstack…  i have no experience with that one though and heist and hamlet are pretty nice
06:53:12 --- mode: ChanServ set +o dcoutts
06:53:19 <confusing> thanks quicksilver
06:53:40 <copumpkin> quicksilver is quick on the draw
06:53:45 <cleantc> What is going on here...GHC 7.4 compiles this with -XRankNTypes:    c ::  (forall a. whatever a -> a  ) -> String      c x =  "1"
06:54:43 <mm_freak> cleantc: that's a higher rank type…  it basically means that the function you pass to 'c' /must/ be polymorphic in 'a'
06:55:36 <mm_freak> you could pass it a "(Int, a) -> a", but you couldn't pass it a "(Int, Double) -> Double"
06:56:01 <cleantc> mm_freak: "whatever" is a name  out of the scope (not even a type constructor)
06:56:11 <mm_freak> cleantc: 'whatever' is a type variable
06:56:21 <mm_freak> you could call it 'b' or 'f' or 'm' instead
06:57:15 <cleantc> oh then it would be : c :: forall whatever. (forall a. whatever a -> a  ) -> String
06:57:22 <mm_freak> exactly
06:58:09 <lamefun> what are extensibility approaches? for example, in my game engine, InputEvent = KeyPress | KeyRelease. Is it possible to make event structures extensible with plugins (for example joystick plugin)?
06:58:48 <mm_freak> lamefun: if you couple the operations with the data type, then yes
06:59:09 <mm_freak> but this will require an existential type at the game loop level
06:59:24 <mm_freak> say you're using SDL
06:59:38 <lamefun> Are programs usually written all-static in Haskell?
07:00:04 <int-e> mm_freak: hmm can we somehow pass an  Int -> a  function? Semantically, 'whatever' could be a constant function, but that's beyond ghc's pattern matching or unification on types.
07:00:18 <mm_freak> data InputEvent = forall a. InputEvent (SDL.Event -> Maybe a) (GameState -> a -> IO ())
07:00:22 <mm_freak> something like that
07:00:29 <mm_freak> lamefun: not just usually, but always
07:01:06 <mm_freak> int-e: it's actually not…  GHC can actually handle the identity function on types
07:01:09 <mm_freak> type Id x = x
07:01:22 <quicksilver> int-e: in plain GHC, the only type-terms of kind * -> * are type-constructors.
07:01:54 <quicksilver> mm_freak: type aliases like that won't unify with * -> * variables though
07:02:10 <quicksilver> int-e: when you add type families you get other type-terms of kind * -> * - but you still can't directly quantify over them.
07:02:29 <t7> @hoofle IO a -> IO ()
07:02:29 <lambdabot> Foreign.Marshal.Error void :: IO a -> IO ()
07:02:29 <lambdabot> Control.Exception.Base block :: IO a -> IO a
07:02:29 <lambdabot> Control.Exception block :: IO a -> IO a
07:02:37 <mm_freak> quicksilver: it worked when i implemented the "lambda expressions as a nested data type" stuff
07:03:15 <int-e> http://hpaste.org/72386 is what I'd try, but it doesn't work. (I don't have a use for this so it's not important. Instead, the type signature should be eta contracted to  c :: (forall a. b -> a) -> String )
07:03:17 <quicksilver> mm_freak: code or it didn't happen :-) I'm moderately sure that you can't unify a type alias Id to "whatever a"
07:03:55 <mm_freak> > let f :: (forall a. w a -> a) -> Int;  f g = g 3 in f id
07:03:57 <lambdabot>   Occurs check: cannot construct the infinite type: a = w a
07:04:01 <mm_freak> hmm
07:04:25 <mm_freak> uh
07:04:48 <aristid> mm_freak: what's the w supposed to be?
07:04:51 <mm_freak> > let f :: (forall a. w a -> a) -> (forall a. a -> w a) -> Int;  f g h = g (h 3) in f id
07:04:52 <lambdabot>   Occurs check: cannot construct the infinite type: a = w a
07:04:57 <parcs`> int-e: you need a newtype
07:05:00 <confusing> lamefun: if you know all the possible values to start with, you can define e.g. "data Event = KeyEvent | MouseEvent | Whatever". if you anticipate that you later want to extend this list without changing the code in that place, you could use typeclasses. they allow you to add instances independently of the place where the class is defined
07:05:05 <int-e> (To keep things sane, and maybe for deeper reasons, ghc refuses to partially apply type aliases.)
07:05:20 <t7> boo
07:05:21 <mm_freak> aristid: well, that's the comonadic 'extract' operation, so i just borrowed the upside down 'm' from Comonad =)
07:08:25 <mm_freak> quicksilver: you're right…  i must have misunderstood something then
07:08:39 <mm_freak> the gfold combinator from that paper is a bit confusing
07:09:42 <mm_freak> confusing: i wouldn't use type classes for that
07:09:57 <aristid> mm_freak: i'm pretty sure id is not a valid extract.
07:10:13 <mm_freak> aristid: yeah, i figured
07:11:34 <mm_freak> aristid: well, of course it's not a valid 'extract' in the context of the Comonad /class/
07:11:50 <quintessence> lamefun: one approach is to add a type parameter for the extension -- data Event a = Keyboard Key | Mouse Button | Other a -- and have functions of type Event a -> (a -> Result) -> Result.  You fill the parameters with Void (or absurd) for the baseline type (or value) but can extend them later.
07:11:50 <aristid> mm_freak: nor in the type signature you gave...
07:11:56 <mm_freak> but apparently GHC indeed can't unify 'w a' with 'a'
07:12:12 <aristid> of course not?
07:12:56 <aristid> mm_freak: the w has to stand for a type constructor, does it not?
07:12:59 <mm_freak> aristid: it's not that obvious…  it's basically the lack of dependent types that makes this fail
07:13:06 <mm_freak> yes, it does
07:13:41 <mm_freak> lamefun: one further approach to extend is to use a data family
07:13:47 <parcs`> :t (undefined :: f a) :: Maybe Int
07:13:48 <lambdabot> Maybe Int
07:13:51 <mm_freak> data MainGame
07:14:08 <mm_freak> data family Event :: * -> *
07:14:31 <mm_freak> but that doesn't get rid of the existential in the main loop
07:15:03 <triyo> Ok so I took the route that int-e suggested. Here is what I have and it works but I have a related question. https://gist.github.com/3217304
07:15:52 <int-e> mm_freak: I guess it boils down to the fact that you can encode combinatory logic in type synonyms. (type K a b = a; type S a b c = a b (c d) -- and you can produce these for whatever kinds you need). So matching modulo type synonyms is undecidable, while matching syntactically (w a with Id a where Id is a type synonym) is unreliable when type synonyms may be expanded during typechecking.)
07:16:10 <int-e> mm_freak: arg. type S a b c = a c (b c).
07:16:21 <triyo> The question is, could the signature on the bindM function look prettier? Instead of having all the (Key k) (Val v) wrappers?
07:16:56 <int-e> mm_freak: data type constructors are not expanded, so matching with those is robust.
07:17:32 <mm_freak> triyo: you could remove some unneceesary parentheses
07:17:51 <mm_freak> Key k -> Val v -> Map (Key k) (Val v) -> Map (Key k) (Val v)
07:17:54 <triyo> yup I srr
07:17:56 <triyo> *see
07:18:11 <cleantc> Is it possible to have higher ranked types in constraints?
07:18:15 <mm_freak> triyo: you can also put the Key and Val types as part of Map
07:19:25 <mm_freak> int-e: i get why it doesn't work…  it just surprised me, because it seemed to work, but apparently i misunderstood my own code when first approaching the mentioned paper =)
07:19:41 <d-old> holy shit ReinH you are kicking ass out there :D
07:19:43 <mm_freak> int-e: i'm almost glad that there is no magic going on here =)
07:19:52 <d-old> loving the haskellive screencast :D
07:20:05 <deytao> Hi there
07:20:15 <cleantc> ex: Show ( (forall a. a -> a) -> Int)?
07:21:28 <applicative> hi deytao
07:21:28 <donri> mm_freak: hey eta on nw4 is soonish, yea?
07:21:29 <n-dolio> cleantc: No.
07:21:35 <mm_freak> cleantc: well, you can't write instances like that, so i assume no
07:21:42 <n-dolio> cleantc: Wait, yes, you can have that.
07:21:54 <confusing> deytao: hello
07:22:11 <qnikst> is it possible to use MonadResource inside MonadCatchIO?
07:22:25 <cleantc> n-dolio: how?!
07:22:27 <applicative> show f = show (f id)
07:22:43 <parcs`> int-e: read this as to why partially applied type synonyms (ie type-level lambdas) are not permitted http://www.reddit.com/r/haskell/comments/urc75/complicating_conduit/c4xyqiz
07:22:46 <mm_freak> donri: this week, if i don't find any major stumbling blocks
07:23:07 <donri> cool! looking forward to it
07:23:17 <triyo> Its pretty cool how the `insert' as a generalized function that operates on the BSTree can apply to my Set or Map types...
07:23:23 <donri> mm_freak: planning any blog posts or tutorials to go with it?
07:23:45 <triyo> Not surprised, just really admiring a bit :)
07:23:48 <mm_freak> donri: yes, but they will come later…  i'll have to rewrite the whole Netwire wiki page for the new version
07:24:16 <n-dolio> cleantc: Oh, I guess you can't. Never mind.
07:24:29 <n-dolio> You can do it by wrapping the polymorphic type, though.
07:25:02 <applicative> it looks like it needs to be wrapped
07:25:30 <cleantc> what about  b ~ ((forall a. a - > a ) -> Int)  ?
07:26:04 <n-dolio> Not sure.
07:26:30 <hpaste> “Ertugrul Söylemez” pasted “Instances with quantified components” at http://hpaste.org/72389
07:26:40 <mm_freak> n-dolio, cleantc: see the paste
07:26:50 <n-dolio> cleantc: No, that doesn't work.
07:27:20 <triyo> mm_freak: how do I include the Key and Value in my Map type?
07:27:45 <otters> oh jesus this looks bad
07:28:19 <n-dolio> cleantc: At first, I thought you meant something like 'forall a. Monoid [a]' which you can't put in a context by any means.
07:28:28 <hpaste> otters pasted “has this happened to anyone else before?” at http://hpaste.org/72390
07:29:03 <mm_freak> triyo: type Mak k v = BSTree … (Key k) … (Val v) …
07:29:59 <cleantc>  not the impredicative form... I guess the constraint solver in GHC can only handle rank1 types (Tau)
07:30:33 <triyo> mm_freak: Oh I see, on the type constructor side.
07:31:07 <confusing> otters: it seems to be only a warning that ld is ignoring this one file. so if you don't need that that library ...
07:31:20 <n-dolio> cleantc: Dispatching based on polymorphism doesn't make a lot of sense.
07:31:25 <otters> confusing: zeromq won't build without it
07:31:33 <otters> I don't think
07:31:50 <n-dolio> Fundamentally.
07:32:28 <geekosaur> otters, somehow that dylib has become corrupted, you need to reinstall it from wherever you got it
07:32:35 <otters> nuts
07:32:37 <n-dolio> Then again, neither does dispatching on application, but GHC allows you to do it.
07:32:38 <otters> I got it from homebrew
07:32:40 <otters> that's a bad sign
07:33:03 <confusing> otters: what does "file blah.dylib" say?
07:33:11 <otters> well hang on, I uninstalled it
07:33:22 <quintessence> n-dolio: real (type function) application or just injective type constructor application?
07:33:27 <otters> I'll reinstall it
07:33:45 <n-dolio> quintessence: I mean you can write instances for 'a b' where a and b are both variables.
07:33:54 <n-dolio> With flexible instances or something.
07:34:00 <otters> my concern is less the fact that it doesn't like the dylib and more the fact that the "architecture" is a list of numbers in hex
07:34:18 <n-dolio> That rules out the former, because type functions aren't first class.
07:34:34 <quintessence> n-dolio: oh, yeah, that's pretty strange semantics-wise
07:34:48 <applicative> otters: zeromq.rb has a couple remarks
07:35:19 <otters> I'll check it
07:36:27 <otters> all of this came about because I was trying to install hbro
07:37:28 <otters> but now it can't find cairo-pdf with pkgconfig, and I have no idea where that is
07:37:29 <applicative> otters, you  have gtk set up?
07:37:36 <otters> pretty sure, yeah
07:37:51 <otters> oh wait, maybe not
07:38:17 <applicative> oh I wasn't suggesting that was the problem, I was just marvelling...
07:39:00 <otters> well cabal hasn't gotten as far as complaining about having no GTK yet
07:39:01 <Qtr> So anyone have an idea of what app to write in haskell for linux?
07:39:02 <otters> it still wants cairo-pdf
07:39:14 <otters> but I have no idea what cairo-pdf is and the "cairo" package doesn't appear to have it
07:39:28 <dcoutts> otters: it's referring to the C package
07:39:38 <t7> Qtr: write a tutorial for adding type classes to damas milner
07:39:49 <t7> or implementing algorithm M
07:39:51 * confusing is wondering what the hbro browser thing has to do with a messaging queue and a pdf thing ...
07:39:54 <dcoutts> otterdam: the error message I think mentions the "pkg-config" package called cairo-pdf
07:40:00 <otters> yeah, it does
07:40:08 <dcoutts> pkg-config is a C package system (sort-of)
07:40:19 <applicative> dcoutts: we're looking at our package manager though
07:40:24 <applicative> such as it is
07:40:34 <otters> well, cairo-pdf in google appears to turn up results for just cairo
07:40:40 <otters> I'd think cairo-pdf would be included in the cairo package
07:41:00 <dcoutts> right, cairo-pdf should be included in your distro's cairo package
07:41:08 <otters> yeah, agreed
07:41:45 <dcoutts> if it's not, then it should be in a separate package
07:42:02 <dcoutts> or in something like Gentoo, there'll be a pdf "use" flag
07:42:57 <Qtr> t7: A real useful program
07:43:53 <t7> that would be incredibly useful
07:44:28 <Qtr> t7: german?
07:44:48 <t7> nope
07:45:47 <tdammers> confusing: my guess would be that it relies on webkit, which uses cairo, which includes a pdf renderer which relies on, well, some pdf library
07:47:00 <confusing> tdammers: interesting
07:48:25 <otters> somebody should propose an extension to haskell that allows the __END__ directive
07:48:28 * applicative curses homebrew, no doubt unjustly
07:51:03 <applicative> "Unexpected performance observed in repa-algorithms function" -- maybe he thought it should be slower?
07:51:54 <fmap> otters: and built-in file handle to read what follows __END__?
07:52:22 <otters> yeah
07:52:23 <mauke> fmap: no, that's __DATA__
07:52:30 <otters> it would remove the need for those damn Paths_* modules
07:52:35 <t7> looks like python
07:52:35 <otters> that you can't test without cabal-dev
07:52:53 <fmap> mauke: aren't they synonyms?
07:53:42 <xplat> speaking of __END__, is there something like 'perl -e' for haskell?
07:54:05 <t7> ghc -e
07:54:37 <otters> oh, I just had to brew link cairo
07:54:39 <otters> to get cairo-pdf
07:54:51 <mauke> fmap: no
07:57:14 <otters> now it wants freetype, which comes with OSX, but it can't use the system freetype for no real reason
07:57:45 <xplat> t7: awesome!  can i import modules for it?
07:57:56 <t7> try it
07:58:31 <quintessence> @hoogle Flip
07:58:32 <lambdabot> Prelude flip :: (a -> b -> c) -> b -> a -> c
07:58:32 <lambdabot> Data.Function flip :: (a -> b -> c) -> b -> a -> c
07:58:32 <lambdabot> package Flippi
07:59:25 <quintessence> is there a Flip newtype somewhere, and is StandaloneDeriving awesome enough to derive Functor/Traversable/Foldable through it?
07:59:58 <fmap> xplat: you can, and also it reads ~/.ghci
08:00:59 <otters> cabal disregards the PKG_CONFIG_PATH environment variable
08:01:03 <otters> spectacular
08:01:19 <dcoutts> I don't think it does
08:01:40 <dcoutts> it'll be passed through automagically without cabal doing anything
08:02:02 <Franciman> hi all guys, where can a papare about self-optimizing parsers be found?
08:02:08 <allsystemsarego> @hoogle nubBy
08:02:08 <lambdabot> Data.List nubBy :: (a -> a -> Bool) -> [a] -> [a]
08:02:10 <Franciman> *paper
08:02:33 <dcoutts> otterdam: currently cabal doesn't touch env vars at all, so they're all just propagated
08:02:44 <dcoutts> oops, otters ^^
08:02:49 <otters> pkg-config can find libpng if I use it
08:03:09 <otters> but whatever setup script this package has can't find it
08:03:21 <otters> only if I symlink it into /usr/lib/pkgconfig
08:03:27 <otters> which is why I'm suspicious
08:03:56 <gspr> I'm currently in a situation where C code calls a Haskell function
08:04:05 <gspr> oops, that sentence ended prematurely, let me try again :)
08:04:23 <dcoutts> otters: you mean some cabal package can't find libpng, or can't find a pkg-config package? need more details
08:04:36 <otters> dcoutts: it can't find the pkg-config package "libpng"
08:04:54 <otters> if I symlink /usr/X11/lib/pkgconfig/libpng.pc into /usr/lib/pkgconfig, then it runs successfully
08:05:17 <otters> oh wait
08:05:24 <otters> okay, yeah, fixed it
08:05:30 <dcoutts> what was the problem?
08:05:37 <otters> I'd set PKG_CONFIG_PATH to /usr/lib/X11/..., not /usr/X11/lib/...
08:05:42 <otters> how confusing
08:05:45 <dcoutts> ah
08:05:57 <dcoutts> easy to do
08:06:14 <gspr> I'm currently in a situation where C code calls a Haskell function, passing a pointer to short-lived, variable-length data. The Haskell function needs to do some impure stuff with this data (calling C functions to do that), which produces some more variable-length data. This data is then to be placed in a TChan for consumption by another haskell thread
08:06:17 <otters> okay, confusing, I'm back where I started
08:06:23 <otters> libpangocairo-1.0.dylib: Mach-O 64-bit dynamically linked shared library x86_64
08:06:38 <otters> and ld is trying to link for i386
08:07:32 <otters> ahh, but cairo has a --universal flag to build with, I'll try that
08:07:34 <quicksilver> otters: probably because at least one of the libraries involved in whatever you're buildin is i386 only
08:07:43 <quicksilver> (the copy on your machine, at any rate)
08:07:50 <otters> so many ops here today
08:07:52 <gspr> The (Haskell-side, but impure) manipulation of the C data currently causes new data to be allocated on each call. I can't have this in the long run, so now I'm looking at allocating memory once and having Haskell dole out some data referencingchunks of this memory... but it all feels a bit contrived. Does this smell of a common pattern to anybody?
08:08:36 <quicksilver> otters: we've had a lot of spam the last few weeks so I'm less quick to remove op.
08:08:39 --- mode: quicksilver set -o quintessence
08:08:41 --- mode: quicksilver set -o quicksilver
08:08:51 <otters> I see
08:14:23 <otters> bizarre that cairo --universal doesn't install pixman --universal because if it doesn't it won't build
08:27:20 <qnikst> how to use hsc2hs in cabal file?
08:27:34 <dcoutts> qnikst: just list your module as usual
08:27:39 <mauke> ... why in a cabal file?
08:28:15 <qnikst> i.e. how can I automate a build
08:28:56 <qnikst> I'm adding Build-tools: hsc2hs
08:30:11 <dcoutts> qnikst: that's good practice too (though not currently enforced)
08:31:44 <qnikst> and than add modules to other-modules, (if I don't wand to export them)?
08:33:08 <jfischoff> dcoutts: what's your take on extending the cabal init to also make test suites and benchmarks?
08:33:21 <dcoutts> jfischoff: patches gladly accepted
08:33:56 <Igloo> I'd leave testsuites until the recommended interface has settled down
08:34:08 <dcoutts> qnikst: yes, all modules must always be listed in the exposed/other-modules fields
08:34:30 <jfischoff> dcoutts: How do you feel about it asking the user if they want a blank test-framework and criterion setup?
08:34:55 <qnikst> dcoutts: even if they are reexported by others?
08:35:16 <dcoutts> qnikst: the modules actually in your package
08:36:00 <dcoutts> jfischoff: ah so not just the stuff in the .cabal file, but generate some module template too?
08:36:12 <qnikst> ok
08:36:13 <jfischoff> dcoutts: yeah, optionally
08:36:55 <dcoutts> jfischoff: sounds plausible, if you want feedback, try posting your design to the cabal mailing list
08:37:08 <jfischoff> dcoutts: okay thanks!
08:37:35 <EvanR> anyone know of a haskell lib sort of like this http://shoesrb.com/manual/Art.html
08:38:33 <quicksilver> EvanR: diagrams? drawing-combinators?
08:38:37 <mekeor> EvanR: diagrams!
08:38:41 <mekeor> EvanR: #diagrams
08:38:50 <EvanR> ok
08:39:11 <mekeor> diagrams is awesome. it's by byorgey.
08:39:22 <Qtr> Wouldnt you all like a program that lets you play dice with your life? You call the program, it creates a list of six options and then rolls a dice and you have to do what it says.
08:39:26 <EvanR> including events?
08:40:06 <otters> you could just roll an actual die
08:40:07 <mekeor> Qtr: omg.
08:40:09 <otters> like, in real life
08:40:27 <EvanR> thats what i do
08:40:33 <mauke> preflex: 8ball is Qtr's program a good idea?
08:40:33 <preflex>  my sources say no
08:40:55 <EvanR> diagrams has text boxes? buttons?
08:41:38 <EvanR> or is it just output
08:41:51 <mekeor> maybe ask in #diagrams…? :/
08:42:27 <mekeor> EvanR: diagrams is for creating images.
08:43:03 <mekeor> EvanR: there are no buttons…
08:43:40 <marcot> What's the recommended regex library for using with String?
08:44:05 <aristid> marcot: Parsec
08:44:59 <EvanR> mekeor: yeah this looks good but it doesnt have like box flow, text input, etc
08:45:04 <jfischoff> Parsec is not a regex library
08:45:16 <otters> Not only that, it can't even do left-recursive parsing
08:45:20 <marcot> aristid: You mean rewritting the regex in parsec?
08:45:31 <Clint> people around here hate regex
08:45:35 <EvanR> you might not need regex
08:45:39 <otters> because haskell doesn't have regex
08:45:41 <EvanR> hopefully you dont need regex ;)
08:45:42 <otters> they're bitter
08:45:52 <EvanR> regex considered harmful
08:45:59 <Clint> see
08:46:05 <hughfdjackson> hehe
08:46:06 <maurer> otters: ...http://www.haskell.org/haskellwiki/Regular_expressions
08:46:11 <hughfdjackson> a justified hate :p
08:46:17 <Qtr> how does haskell have dynamic typing?
08:46:20 <otters> oh yeah
08:46:21 <EvanR> hopefully new technology is not designed thinking everyone likes regex so will be ok using it
08:46:30 <aristid> marcot: if you already have a regex, there are libraries for that. but generally it's better to write a small parser in Parsec or so
08:46:35 <EvanR> Qtr: Data.Dynamic
08:46:36 <maurer> otters: In other words, yes, we can regex, it's just not necessarily a good idea
08:46:42 <marcot> maurer: I was looking to this page, but just thought of asking before trying all the alternatives.
08:46:44 <Qtr> nothing to do with typeclasses?
08:46:48 <jfischoff> aristid: agreed
08:47:10 <confusing> qtr: haskell is not a dynamically typed language
08:47:19 <marcot> aristid: I have some regexes, but not many.  I'll try to do it in parsec then.
08:47:19 <confusing> (no, nothing with typeclasses :) )
08:47:35 <mauke> @hoogle fromDynamic
08:47:35 <lambdabot> Data.Dynamic fromDynamic :: Typeable a => Dynamic -> Maybe a
08:47:41 <EvanR> Dynamic is based on Typeable, which is a class ;)
08:47:44 <otters> are there any LALR parsing libraries in wide usage?
08:49:19 <Clint> does Happy count as a library?
08:50:06 <conal> another stackoverflow answer from uday reddy on referential transparency: http://stackoverflow.com/a/11740176/127335 . i highly recommend, together with his previous answer on that page.
08:51:28 <conal> he makes a crucial point that "value" in RT is not generally values within the language, but rather denotations.
08:52:48 <otters> do I have any control over the target architecture for cabal packages
08:52:50 <phil__> is there a way to get the field data types of a constructor using Data.Data?
08:53:04 <confusing> conal: is the answer meant to be a joke? «Whereas the philosophers/logicians use terms like "reference", "denotation", "designatum" and "bedeutung" (Frege's German term), functional programmers use the term "value".»
08:54:25 <conal> confusing: i don't think so. uday is getting at the two meanings of "value", suggesting that it misleads modern functional programmers.
08:54:39 <EvanR> this is ... pretty amazing for stack overflow
08:54:48 <EvanR> how do i tweet this comment
08:55:44 <conal> and he points out that the wikipedia definition makes no sense, once one clears up the confusion between these two notions of "value".
08:56:40 <dcoutts> otters: there's no cross-compilation support if that's what you mean
08:57:17 <otters> I just want to make the package match the arch of the shared libraries I have
08:57:23 <otters> and not the other way around
08:57:29 <otters> but I guess that's not an option
08:58:07 <jfischoff> conal: the two notions being a subexpression and a denotation?
08:58:45 <EvanR> retweeted from conal
08:59:43 <conal> jfischoff: no. between a denotation and the sort of values yielded and passed around in a language.
09:00:38 <conal> jfischoff: though the subexpression/value or subexpression/denotation distinction is enough to rule out that popular definition of RT.
09:01:20 <confusing> EvanR: if you liked that, you probably will love http://www.elsewhere.org/pomo/ :)
09:02:05 <conal> jfischoff: in either case, to replace a subexpression by "its value" is a type error. the definition isn't even wrong. it doesn't type-check.
09:03:31 <jfischoff> conal: because the values/denotations are outside the language?
09:04:10 <Qtr> Making a haskell ide would be a terrible idea right?
09:04:14 <conal> jfischoff: yes. because semantics /= syntax
09:04:25 <Qtr> well i dont want to do it anyway
09:04:49 <Cale> conal: The "confusion" arises because reduction produces normal forms.
09:04:56 <Cale> (at least, most of the time)
09:05:25 <applicative> this seems a little unfair to the 'functional programmers'.  the first bit anyway. he is saddling everyone with a wikipedia quote...
09:05:27 <Cale> and we design the languages such that each value in our semantics usually has a canonical form
09:05:34 <conal> Cale: i think so as well: some of the confusion comes from an operational model.
09:05:56 <phil__> can somebody paste the link to the stack overflow answer?
09:06:13 <nand`> can somebody provide an illustrative example of a problem best solved using the continuation monad?
09:06:18 <conal> http://stackoverflow.com/questions/210835/what-is-referential-transparency/11740176#11740176
09:06:18 <Cale> e.g. values of an algebraic type will have canonical expression forms entirely composed of data constructors
09:06:21 <conal> phil__: ^^
09:06:27 <phil__> conal: thx!
09:06:56 <lysgaard> How do I debug strictness problems in Haskell?
09:06:56 <lambdabot> lysgaard: You have 1 new message. '/msg lambdabot @messages' to read it.
09:07:21 <Cale> nand`: The only time I've ever used it in a really practical way was to compose withFoo-style functions which bracket the allocation of a resource
09:07:26 <EvanR> nand`: you could use it to exit from a computation early, though theres easier ways
09:07:34 <conal> Cale: i think those normal forms resemble what Uday was calling the value *within* the language, as opposed to what the philosophers/logicians meant in defining referentially transparency.
09:07:46 <nand`> EvanR: to me, MaybeT serves that purpose best
09:07:51 <Cale> nand`: For example, let's suppose you have a list of Strings and you want to locally turn them into CStrings using withCString
09:08:00 <EvanR> confusing: thanks fro that link
09:08:00 <applicative> referential transparency in Quine's sense is more remote from what functional programmers mean than he thinks.  In any case it modifies 'context', some transparent some opaque.
09:08:12 <conal> Cale: so there are two layers of confusion: external-vs-internal "values", and syntax vs semantics.
09:08:19 <EvanR> confusing: before i start reading, is it satirical because i really cant tell
09:08:20 <Cale> nand`: You can use Cont to put them all together:
09:08:28 <Cale> :t Foreign.C.withCString
09:08:29 <lambdabot> forall a. String -> (Foreign.C.String.CString -> IO a) -> IO a
09:08:38 <applicative> that is, a) he isn't any closer to Quine than we are; and b) he hasn't shown it matters.
09:08:39 <nand`> applicative: “referential transparency in functional languages” meaning ”all contexts are referentially transparent”, then, I guess
09:08:46 <Cale> :t Cont (Foreign.C.withCString "foo")
09:08:47 <lambdabot> Not in scope: data constructor `Cont'
09:08:51 <Cale> :t cont (Foreign.C.withCString "foo")
09:08:52 <lambdabot> forall a. Cont (IO a) Foreign.C.String.CString
09:09:12 <int-e> Qtr: it's a great idea but a ton of work. There are some existing projects, e.g. Leksah (written in Haskell) or EclipseFP (extending eclipse). Yi may also be going in that direction, but afaik it's "just" a customizable editor at the moment.
09:09:22 <Cale> :t map (cont . Foreign.C.withCString) ["foo", "bar", "baz"]
09:09:23 <lambdabot> forall a. [Cont (IO a) Foreign.C.String.CString]
09:09:27 <confusing> EvanR: yes, it's a program that has a list of phrases of philosophy babble and combines them in a random way
09:09:30 <Cale> :t sequence (map (cont . Foreign.C.withCString) ["foo", "bar", "baz"])
09:09:31 <lambdabot> forall a. ContT (IO a) Identity [Foreign.C.String.CString]
09:09:39 <applicative> nand`: that's right, only, Quine's only genuinely 'opaque' contexts are made by the intentional verbs, and more controversially the modal operators
09:09:42 <EvanR> confusing: oh its not even time independent :(
09:09:47 <EvanR> turing test passed
09:09:51 <Cale> :t mapM (cont . Foreign.C.withCString) ["foo", "bar", "baz"]
09:09:53 <lambdabot> forall a. ContT (IO a) Identity [Foreign.C.String.CString]
09:09:53 <confusing> EvanR: i there's some way to get stable links
09:09:56 <phil__> nand`: can't it be used for composing web request type functions, where each function depends on the result of the previous ones?
09:10:03 <Cale> :t runCont (mapM (cont . Foreign.C.withCString) ["foo", "bar", "baz"])
09:10:04 <lambdabot> forall a. ([Foreign.C.String.CString] -> IO a) -> IO a
09:10:09 <nand`> applicative: also, not all contexts in Haskell are referentially transparent - function definitions aren't
09:10:16 <Cale> nand`: See how that works? :)
09:10:17 <applicative> Quine didnt want to repair these, but to destroy them completely.  Tense examples like Udays, are not Quinean
09:10:24 <nand`> Cale: I did
09:10:35 <phil__> nand`: at least i've seen continuations used like this in other languages
09:10:38 <EvanR> confusing: this is awesome
09:11:18 <nand`> phil__: I'm having a hard time envisioning that, “each function depends on the result of the previous ones” sounds awfully like a monad
09:11:19 <Cale> That's actually a kinda tricky function to write recursively, probably just because continuations are a bit mindbending at times.
09:11:34 <mauke> Cale: that example makes me feel uneasy because I don't know when the deallocation happens
09:11:49 <confusing> EvanR: there's also this http://pdos.csail.mit.edu/scigen/
09:12:09 <EvanR> hahahahahha
09:12:23 <applicative> the problem about 'the population of Berlin = x' and the problem about "the babylonians believed that the morning star = the evening star' are both discussed by Frege and by Quine, but never in the same chapter.
09:12:31 <Cale> mauke: It happens after the inner action runs.
09:12:45 <Cale> mauke: in the reverse order of the allocation
09:13:14 <mauke> I know it must be deeply nested but I can't feel it
09:14:45 <bitrust> Hello! Anyone on OS X 10.8 (Mountain Lion) here? Does the upgrade bother my Haskell setup in any way?
09:16:09 <mauke> wait, this is plain Cont so I suppose it must be constructing an IO action in a pure way
09:16:14 <mauke> is this safe by construction?
09:16:42 <otters> bitrust: it does not
09:16:50 <otters> although you'll have to reinstall gcc and stuff
09:16:56 <EvanR> confusing: im sort of frightened that im reading this whole paper
09:17:03 <EvanR> http://apps.pdos.lcs.mit.edu/scicache/376/scimakelatex.95213.Evan+Rinehart.Luke+Ledet.Caleb+Albritton.html
09:17:11 <bitrust> otters: Is there a new version of Command Line Utils to download?
09:17:21 <otters> I don't think so
09:17:30 <applicative> bitrust: it is supposed to be unproblematic
09:17:36 <geekosaur> actually, yes there is
09:17:44 <mauke> EvanR: http://apps.pdos.lcs.mit.edu/scicache/376/dia0.png beautiful
09:17:54 <bitrust> geekosaur: Right, I'll check.
09:17:55 <geekosaur> you need both Xcode 4.4 and its corresponding Command Line Utilities package
09:18:14 <geekosaur> the earlier versions will fail ("C compiler cannot create executables") on ML
09:18:16 <EvanR> mauke: yes i particularly liked that result
09:18:20 <bitrust> geekosaur: Not just the command line tools? Apple allows you to download the separate package right.
09:18:29 <confusing> "OBIT, our new heuristic for web browsers, is the solution to all of these grand challenges."
09:18:57 <int-e> mauke: air gap security is cool and pretty effective :)
09:19:01 <nand`> Cale: I also still have no clue what call/cc is supposed to do, despite somehow barely managing to understand some trivial examples of CPS (eg. facCps)
09:19:13 <geekosaur> bitrust, it may be enough to use just the command line utils package, I use enough stuff that behaves better with full Xcode (or even just requires it outright) that I don't bother to check any mroe
09:19:26 <Cale> nand`: Do you understand how 'return' works in most imperative languages?
09:19:36 <mauke> nand`: oh, call/cc is simple
09:19:47 <EvanR> CPS is 'too simple'
09:19:50 <nand`> I can read dozens of sentences like “oh sure, call/cc is just calling a something with the current continuation as argument” but I have zero clue what that's supposed to actually boil down to
09:19:54 <mauke> I'm just afraid of continuations in practice
09:19:55 <EvanR> theres nothing to understand ;)
09:19:59 <nand`> Cale: yeah
09:20:10 <Cale> nand`: Most imperative languages have an implicit call/cc wrapped around every function.
09:20:18 <applicative> geekosaur: the C compiler error occurs on Snow Leopard
09:20:18 <mauke> nand`: call/cc calls a function with a custom 'return' procedure
09:20:28 <bitrust> geekosaur: Right. Well I'll download the new cmdline tools before upgrade as I have slow internet and can't really deal with a break in my setup.
09:20:30 <int-e> call/cc becomes fun when the continuation leaves the context of the call/cc :-)
09:20:47 <Cale> nand`: and 'return' just refers to that continuation
09:20:52 <mauke> nand`: i.e. when you do call/cc f, f has now two ways to return a result: either normally, or by calling its argument
09:21:00 <int-e> (that's also where the throw/catch analogy breaks down)
09:21:12 <geekosaur> applicative, um, the context is that if you have the CLU for Lion installed and upgrade to Mountain Lion, the old CLU will fail to operate until upgraded
09:21:12 <mauke> second course: spaghetti stacks
09:21:32 <Cale> but yeah, the mindbending part is that call/cc gives you a name for that continuation, so you can pass it around and do other things with it
09:21:39 <geekosaur> behavior on SL, or Xcode-minus-CLU behavior, is not the question
09:21:50 <applicative> geekosaur: yes I'm just surprised you count the error about the c-compiler as 'not working'
09:22:01 <applicative> or 'failing to operate'
09:22:14 <geekosaur> applicative, because that is what you see when you have the Lion CLU installed on ML and try to compile something
09:22:16 <mauke> call/cc (\ret -> ret 42) ==> 42
09:22:24 <mauke> call/cc (\ret -> ret 42; "hello") ==> 42
09:22:32 <geekosaur> maybe I should just say some vague "will fail" instead of noting the actual symptom?
09:22:41 <otters> that seems simple so far
09:23:04 <phil__> i'm wondering, what happens when you call the passed continuation twice?
09:23:07 <nand`> is call/cc (\ret -> ret 42) distinguished from call/cc (\_ -> 42) ?
09:23:11 <applicative> geekosaur: im surprised you haven't seen it on earlier os x;s though.  I have never been able to build with the gcc except by calling it myself or adjusting privileges, thats all
09:23:28 <otters> @pl \r -> r 42
09:23:28 <lambdabot> ($ 42)
09:23:35 <otters> yes
09:23:38 <geekosaur> sigh
09:23:43 <Qtr> Is there some programming tool you need?
09:24:03 <applicative> geekosaur: right, I was distracted by the symptom, though your experience is clearly different ... that's what interested me
09:24:05 <mauke> call/cc (\ret -> ret) 42 ==> error: you're trying to call 42
09:24:47 <geekosaur> where did I say I han't seen it?
09:24:57 <phil__> call/cc (\k -> k 5) (+6) ==> 11 right?
09:25:10 <nand`> mauke: how would something like that even typecheck?
09:25:15 <mauke> phil__: looks like a type error to me
09:25:19 <mauke> nand`: it wouldn't
09:25:47 <geekosaur> in fact I said "is not relevant" above specifically because the failure symptom is not in fact solely specific to this one case... but it, not some other error, is what you get in this specific case
09:25:47 <phil__> isnt k supposed to be (+6) in that case?
09:25:55 <applicative> geekosaur: it doesn't matter, it does seem that if I do it right, on Mountain Lion I wouldn't have to contend with whatever rule blocks making exectuables with gcc ...
09:26:02 <mauke> phil__: no, it's ($ (+6))
09:26:09 <nand`> > runCont (callCC (\k -> k 5)) (+6)
09:26:10 <lambdabot>   11
09:26:18 * geekosaur feels like he walked into a mirror or something, does not at all see why this is such an issue
09:26:38 <otters> :t runCont (callCC ($ 5))
09:26:39 <lambdabot> forall r b. (Num b) => (b -> r) -> r
09:27:04 <mauke> (\f -> f f) (call/cc (\ret -> ret))  -- is this an infinite loop?
09:27:09 <MostAwesomeDude> edwardk: Hm. Okay, so if I switch a codebase over to using the parsers package, I've gotta declare an orphan instance for Parsec or whatever I want to parse with? I'm noticing that Trifecta doesn't appear to have a Parsing instance. :c
09:27:13 <applicative> geekosaur: it isn't an issue.  I was distracted by my three year problem with some irritating rule about calling gcc
09:27:29 <applicative> on os x, with whatever xcode i've been using
09:27:31 <phil__> mauke: shouldnt be?
09:27:34 <edwardk> MostAwesomeDude: trifecta 0.90 has the parsers plumbing but isn't released
09:27:44 <mauke> phil__: why not?
09:27:47 <edwardk> i need to package up a parsers-parsec and parsers-attoparsec package as well
09:27:50 <phil__> mauke: it shouldnt do anything in fact
09:27:54 <MostAwesomeDude> edwardk: Okay. I'll hold off on transitioning until you've got them released.
09:27:59 <edwardk> kk
09:28:01 <otters> it should in fact not typecheck
09:28:06 <mauke> otters: ignore types
09:28:09 <otters> oh
09:28:31 <nand`> mauke: I still have no idea what (callCC id) would work like
09:28:37 <phil__> mauke: just call the continuation that is "now", i.e. the current continuation
09:28:38 <nand`> even if you ignore types
09:28:45 <phil__> mauke: so it shouldnt affect the program at all?
09:28:50 <mauke> phil__: huh?
09:29:17 <mdittmer> Can anyone tell me what function+type to use to get cross-platform system clock time with precision better than seconds?
09:29:40 <phil__> mauke: well the function that is passed to call/cc gets the current continuation, i..e "the rest of the program", so if you just call it, the program will go on as normall
09:29:42 <mauke> phil__: I tested it in scheme. it's an infinite loop
09:29:43 <phil__> *normal
09:29:59 <phil__> mauke: hm
09:30:05 <mauke> phil__: I don't think of it that way
09:30:30 <phil__> mauke: how then?
09:30:39 <mauke> the function that is passed to call/cc gets a "get out of this call free" card
09:30:40 <confusing> mdittmer: getZonedTime gives you the current time, from which you can extract the seconds (which will be something like "16.982374000000")
09:30:41 * applicative doesn't approve of this Uday R. nonsense. Even the first charge, that functional programmers that 'values' are completely reduced expressions is nonsense
09:31:00 <applicative> that  they think that rather
09:31:13 <quintessence> of note: the Cont monad is *delimited* continuations (without answer type polymorphism or any such fancy stuff), which are different beasts than scheme's undelimited call/cc
09:31:19 <phil__> mauke: isn't this the same? i.e. get out of here = go on with the rest of the program?
09:31:27 <mauke> phil__: yes
09:31:31 <mdittmer> confusing: thanks. Does it include the date, or will it cause problems around midnight if I need it to be ordinal?
09:31:58 <quintessence> (Oleg has a... series of pontifications... on this: http://okmij.org/ftp/continuations/undelimited.html )
09:32:01 <confusing> mdittmer: oh, and if unix time is enough, try the function from Data.Time.Clock.POSIX. there's another function in System.Posix.Time but that has only whole seconds
09:32:30 <confusing> mdittmer: getZonedTime on my system gives "2012-07-31 18:31:57.822828 CEST"
09:32:41 <phil__> mauke: then \ret -> ret going into an infinite loop is confusing to me :/ it should just go on and execute the rest of the programe (once)
09:32:51 <mauke> phil__: \ret -> ret isn't going into an infinite loop
09:33:02 <mdittmer> confusing: Thanks.
09:33:04 <mauke> the rest of the program is an infinite loop
09:33:08 <applicative> it is hard to believe that Uday R's heros are unfamiliar with quotation marks, since they exhaust themselves talking about them, yet they are supposed to affirm that "The referents/denotations themselves [ie in all cases] do not exist within the language. "
09:33:32 <confusing> mdittmer: you're welcome
09:33:56 <mauke> phil__: the continuation is ((\f -> f f) …)
09:34:54 <mauke> ok, that almost makes sense. it sort of expands to ((\f -> f f) (\f -> f f))
09:34:56 <applicative> the attack of Uday R is more than moronic.  The confusion he accused them of could never be made by a haskell user,  since it doesn't typecheck.
09:35:10 <xplat> is there something like blaze-builders for xml?
09:35:10 <mdittmer> confusing: will I get the same precision regardless of whether I use UTCTime or ZonedTime?
09:35:15 <applicative> the confusion he accuses 'functional programmers' of is thinking x = show x
09:36:14 <confusing> mdittmer: i think so. getZonedTime and getCurrentTime are closely related. of course you'll have lost the timezone with utc
09:36:50 <mdittmer> confusing: all I need is correct ordering of timestamps, so UTCTime is probably enough.
09:36:51 <confusing> quintessence: "series of pontifications"? very nicely put. i lol'd when i saw that the page has very large headings like "Undelimited continuations are not functions" and "Vast difference between delimited and undelimited continuations"
09:37:08 <phil__> mauke: i think i understand now - since call/cc is repaced with what you call the continuation with, it calls the continuation again and again and again
09:37:52 <phil__> but need to sit down and write it down to fully make sense of it :)
09:38:09 <mauke> we're doing (\f -> f f) ret, which calls ret ret, which sends ret "back" to be returned from the call/cc thing
09:38:20 <mauke> which is exactly what it returned the first time around anyway
09:38:25 <mauke> so we're stuck in a cycle
09:39:01 <Taneb> Does \f -> f f type?
09:39:11 <phil__> in scheme :)
09:39:17 <Taneb> Aaah
09:39:17 <mauke> Taneb: yes
09:39:27 <quintessence> with appropriate newtype wrappers
09:39:28 <mauke> its type is a@(a -> a)
09:39:32 <Qtr> Anyone have "write yourself a scheme in 48hours" complete source? I feel I know Haskell well enough to learn by reading the code directly
09:39:57 <Taneb> mauke, you can do that?
09:40:33 <nand`> I see lots of mentions of using continuations to provide concurrency constructs. Can continuations do something here that free monads can't?
09:40:34 <int-e> Taneb: not directly, but with some newtype wrapping, yes, you can.
09:40:37 <mauke> Taneb: no, but that doesn't stop me
09:40:43 <quintessence> not in Haskell, but in isorecursive type systems (e.g. O'Caml) you can write it directly
09:40:59 <EvanR> confusing: the elsewhere.org thing seed link doesnt work
09:40:59 <Taneb> I'd throw unsafeCoerces at it until it types
09:41:07 <otters> monad special is only $9.95
09:41:08 <EvanR> confusing: its randomly generating even if i provide a link
09:41:44 <mauke> OCaml says it's ('a -> 'b as 'a) -> 'b = <fun>
09:41:53 <mauke> which makes sense
09:42:09 <mauke> a@(a -> b) -> b
09:42:39 <confusing> EvanR: hm, i don't know about that, it's not my domain or program. i just came across it years ago and found it funny :) maybe drop the domain owner a mail
09:42:41 <phil__> Qtr: i think there's a github repo somewhere, google around a bit
09:42:48 <lysgaard> I have a program that blows up in memory usage. I suspect it's because of some strictness issues. Does anyone have experience debugging such issues? I'm really lost on what to do.
09:42:52 <Qtr> msum=monadsum?
09:43:07 <mauke> :t msum
09:43:07 <Qtr> > msum [Nothing,Nothing]
09:43:08 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => [m a] -> m a
09:43:08 <lambdabot>   Nothing
09:43:08 * applicative now affirms that this Uday R character is throwing around big names for purely obfuscatory purposes; C is just as much a zone of 'referential transparency' as Haskell etc/
09:43:22 <Qtr> > msum [Nothing,Nothing,Just "mauke"]
09:43:24 <lambdabot>   Just "mauke"
09:43:30 <EvanR> confusing: haha Social Text Affair, where a physics professor submitted and got accepted a hoax article on cultural criticism
09:44:14 <nand`> > msum [Just "a", Just "b"]
09:44:15 <lambdabot>   Just "a"
09:44:27 <EvanR> Uday piped one of these generators into stack overflow lol
09:44:43 <applicative> maybe
09:44:48 <applicative> "Strachey interpreted variables in imperative programming languages as L-values, as mentioned in my March 25 answer, which is a sophisticated conceptual object that does not have a direct representation within the syntax of a programming language."
09:44:53 <quintessence> nand`: no, they're equivalent -- you can use Cont to get call/cc in your monadic program, and you can use continuations to turn imperative code into its monad representation
09:45:01 <applicative> well, why don't they have direct representation?
09:45:15 <alpounet> > msum ["a", "b"]
09:45:15 <lambdabot>   "ab"
09:45:25 <xplat> ah, xmlhtml
09:45:28 <allsystemsarego> @src msum
09:45:28 <lambdabot> msum =  foldr mplus mzero
09:47:59 <xplat> @src mconcat
09:48:00 <lambdabot> Source not found. Do you think like you type?
09:48:09 <xplat> er
09:48:40 <xplat> what was the other one again?
09:48:50 <nand`> quintessence: If they're equal in expressive power then I'll go for one I actually understand
09:49:06 <mauke> @src Monoid
09:49:07 <lambdabot> class Monoid a where
09:49:07 <lambdabot>     mempty  :: a
09:49:07 <lambdabot>     mappend :: a -> a -> a
09:49:07 <lambdabot>     mconcat :: [a] -> a
09:50:39 * applicative begins nibbling at Uday Rs toes in the comments....
09:51:00 <xplat> oh, it is mconcat, lambdabot just wasn't sourcing it, presumably because it's a class method ... or not in the prelude ...
09:51:31 <mauke> don't assume @src is sane
09:51:39 <nand`> mconcat is just foldr mappend mempty right?
09:51:39 <xplat> applicative: that sounds kind of dirty
09:51:46 <Emmycakes> reading the info on foldr is twisting my brain a little
09:51:49 <applicative> okay,
09:51:57 <otters> @src MonadPlus
09:51:57 <lambdabot> Source not found. There are some things that I just don't know.
09:51:59 * applicative begins his tirade against Uday R
09:52:22 <nand`> applicative: link to this Uday R post?
09:52:37 <applicative> http://stackoverflow.com/questions/210835/what-is-referential-transparency/11740176#11740176
09:52:45 <nand`> ah, that one
09:53:14 <applicative> everyone seems to think it's good nand` .
09:53:21 <mauke> Emmycakes: http://upload.wikimedia.org/wikipedia/en/3/3f/Fold-diagrams.svg
09:53:22 <otters> :t putStrLn . getLine
09:53:23 <lambdabot> IO (IO ())
09:53:32 <applicative> but his secret aim is to say that Haskell has nothing on C
09:53:35 <nand`> oh, it seems I was remembering a different one
09:53:50 <nand`> I'll have to read it first
09:54:14 <Qtr> > msum [Nothing,Nothing,Just "mauke"]
09:54:16 <lambdabot>   Just "mauke"
09:54:20 <Qtr> > msum [Nothing,Nothing]
09:54:21 <lambdabot>   Nothing
09:54:28 <xplat> gah, what is requiring text-0.11.2.2 when i install heist?
09:54:48 <otters> > msum [Just 1, Just 2]
09:54:49 <lambdabot>   Just 1
09:54:53 <otters> nonsense
09:55:11 <Taneb> > mconcat [Just 1, Just 2]
09:55:12 <lambdabot>   Ambiguous type variable `t' in the constraints:
09:55:13 <lambdabot>    `Data.Monoid.Monoid t'
09:55:13 <lambdabot>  ...
09:55:22 <Taneb> > mconcat [Just $ Sum 1, Just $ Sum 2]
09:55:24 <lambdabot>   Just (Sum {getSum = 3})
09:55:25 <otters> :t mconcat
09:55:26 <lambdabot> forall a. (Monoid a) => [a] -> a
09:55:38 <otters> :instances Monoid
09:55:42 <otters> oh
09:55:44 <otters> whoops
09:56:41 <Qtr> > msum [Just 7, Nothing,Nothing, Just 9]
09:56:42 <lambdabot>   Just 7
09:56:46 * hackagebot optparse-applicative 0.3.2 - Utilities and combinators for parsing command line options (PaoloCapriotti)
09:57:33 <marcot> What's the simple way to parse the x=y's in "asdfasdfasx=yadsfasdfasdfx=yasdfasdf" using parsec?
09:58:56 <marcot> I've tried many $ manyTill anyChar (string "x=y") >> return "x=y", but it only works if there's nothing after the last x=y.
09:59:17 <confusing> marcot: not sure about parsec, but maybe you can get by with a simple split function. package missingh offers one, also package split
09:59:19 <MostAwesomeDude> Hm. Is there a way, in ghci, to see the definition of an instance?
09:59:33 <Cale> MostAwesomeDude: no
09:59:35 <MostAwesomeDude>  :i only shows me that there *is* an instance, not its definition.
09:59:38 <MostAwesomeDude> Cale: Aw. :c
09:59:48 <nand`> applicative: I think his accusation of functional programmers misusing the term “value” are entirely unsound. Isn't one of the underlying concepts of functional programming that functions (certainly mathematical concepts more advanced than, say, a number) are values themselves?
09:59:52 <Cale> MostAwesomeDude: In general, ghci can't show you source code for most things.
09:59:53 <Taneb> It throws away the actual instance once it compiles, I think
10:00:12 <applicative> nand`: yes, it is totally thoughtless
10:00:23 <nand`> if anything, I'd say functional programmers are more willing to call mathematical objects “values” than others; the notion of a ‘value’ being a ‘reduced expression’ is not one I would agree with either
10:00:29 <Qtr> > let mfish = msum in mfish [Left 1, Right 4]
10:00:31 <lambdabot>   Ambiguous type variable `t' in the constraints:
10:00:31 <lambdabot>    `Control.Monad.Trans.Err...
10:00:31 <applicative> nand`: functions are a good example
10:00:32 <marcot> confusing: I mean something for replacing "asdfasdfasx=yadsfasdfasdfx=yasdfasdf" =~ "x=y" :: [[String]]
10:00:43 <marcot> confusing: I don't think split would work.
10:00:48 <mauke> marcot: how is that a useful thing to do?
10:01:08 <Cale> But there is a sense in which he's right. We often intentionally confuse values with expressions that are in normal form.
10:01:26 <Cale> But it's not like anyone involved in the discussion is unaware of what is meant.
10:01:34 <nand`> applicative: that's the only real thing I don't like about his post after a quick first glance; he seems to introduce this “functional programmers do this and that” stereotype that I simply don't think applies
10:01:36 <Cale> So it's totally silly to be complaining about it
10:01:38 <confusing> MostAwesomeDude: however, ghci tells you the package and module that defines the instance. you can then go to hackage.haskell.org/package/whatever and on the module's page click "source" on the right hand side
10:01:38 <roconnor> aren't values also expression when using a term-model denotation?
10:01:40 <applicative> nand`: maybe it would be better if we praised haskell for being unrelentingly 'denotative' rather than 'referentially transparent', then he would have to concede everythiing
10:01:45 <Cale> roconnor: yes
10:01:56 <marcot> mauke: In the real case, "asdfa..." is an html file, and the regexp is "<option value=\"([A-Z][A-Z])\">"
10:02:28 <roconnor> ... maybe an quotient of terms is needed for a term-model ...
10:02:32 <confusing> marcot, you might try parsec's function "between"
10:02:39 <Cale> marcot: Why not use an HTML parser, or at least something like tagsoup
10:02:51 <confusing> marcot: and yes, what cale says :)
10:02:54 <mauke> marcot: stop trying to parse html with a regex. it doesn't work.
10:02:55 <applicative> Cale, yes, but there is also the question whether we are particularly confused; the reduced expressions in data Nat = Z |  S Nat are isomorphic to Nat
10:03:03 <applicative> isomorphic to N
10:03:10 <Cale> applicative: right
10:03:16 <SegFaultAX|work2> Does Cabal support multiple isolated sets of libs? Something like virtualenv, rvm or rbenv?
10:03:29 <confusing> cale: could you give an example of a value that people confuse for an expression in normal form?
10:03:45 <Cale> confusing: S (S (S Z)) with its denotation
10:03:48 <SegFaultAX|work2> Or perhaps more generally, how does cabal handle multiple versions of the same library installed on the system?
10:04:02 <nand`> applicative: it looks like a matter of terminology to me; what we are arguing about is indeed what we are arguing about: replacing an expression by an evaluated form of that expression doesn't change its denotation; seems to me he is just bitter about the usage of ‘referential transparency’ for this
10:04:16 <xplat> mauke: it actually kind of depends.  some html is built with simplistic string substitution, in which case a regex can be better than a parser at recovering the data that went into constructing it.
10:04:46 <confusing> SegFaultAX|work2: check out the cabal-dev package. iirc it's a pretty simple wrapper that calls cabal with some arguments to make the directories point to other places. it works well in practice
10:04:47 <mauke> xplat: [citation needed]
10:04:48 <alpounet> SegFaultAX|work2, there's cabal-dev, virthualenv and hsenv, and there's a Google Summer Of Code about writing code that supports sandboxing directly into cabal itself
10:04:50 <Cale> confusing: People will speak of "the value" Branch 4 (Branch 3 Tip Tip) Tip
10:05:04 <applicative> nand`: yes, but 'referential transparency' should be dropped any; it's just fancy jargon that keeps one from saying what one wants.  What one wants, Landin grasped
10:05:11 <applicative> dropped anyway
10:05:39 <roconnor> applicative: we want equational reasoning?
10:06:10 <xplat> mauke: i used to have citations, but i don't feel like finding them right now.  anyway, if you don't know how the html is produced a parser is a better idea
10:06:10 <applicative> roconnor, equational doesnt come up.  just our unrelenting use/mention confusion.
10:06:13 <nand`> applicative: I think Stoy's formulation is good; it captures two essences: repeating the value does not change its meaning, and replacing a value by an equivalent value doesn't change the meaning either
10:06:18 <applicative> > 3 == "3"
10:06:19 <lambdabot>   No instance for (GHC.Num.Num [GHC.Types.Char])
10:06:19 <lambdabot>    arising from the literal ...
10:06:45 <SegFaultAX|work2> confusing, alpounet: Thanks! I'll look into those!
10:06:49 <nand`> I'm not sure if (==) is entirely appropriate when talking about equational reasoning, consider functions
10:07:16 <roconnor> applicative: what do we want taht Landin grasped?
10:07:21 <conal> nand`: when uday criticizes functional programmers' use of "value" in the context of RT, i think he mainly means the way we apply it to imperative languages, not functional ones. because in imperative languages, there's a bigger gap between those "values" and denotations.
10:07:23 <SegFaultAX|work2> Is having multiple versions of the same library installed as much of a problem in Haskell as it is in other languages?
10:07:31 <Cale> This whole discussion of whether people are confusing things or not is a waste of time, imo.
10:07:55 <roconnor> SegFaultAX|work2: I think so.
10:08:23 <roconnor> SegFaultAX|work2: cabal makes is slightly less bad, but not enough less bad
10:08:25 <confusing> cale: well didn't you see the stackoverflow tag "theory"? ;-)
10:08:27 <applicative> nand`: it isn't but the fact that the language doesn't permit us to express identity, is another way of showing how irrelevant this is.  I wasnt discussing equational reasoning any more than he was
10:08:40 <applicative> > even "3"
10:08:41 <lambdabot>   No instance for (GHC.Real.Integral [GHC.Types.Char])
10:08:41 <lambdabot>    arising from a use ...
10:09:03 <applicative> he is literally accusing us of not knowing that that doesnt type check
10:09:32 <Cale> I secretly loathe all the stackoverflow-like sites. I'm not sure why.
10:10:08 <applicative> Cale: this is an abuse, I'd think
10:10:08 <Cale> Initially it was because stackoverflow fragmented our existing communities.
10:10:15 <Clint> people shouldn't communicate through websites
10:10:57 <EvanR> they are just really poorly implemented bullitin boards
10:11:01 <confusing> in soviet russia, websites communicate through people
10:11:18 <Cale> At the time it started out, there was already a very active Haskell wiki where people would ask questions and have them answered (before we moved to MediaWiki and everyone started thinking of it as an extension of wikipedia)
10:11:24 <Cale> as well as the mailing lists
10:11:29 <Clint> byorgey: how strict is this registration requirement for Hac φ?
10:11:55 <byorgey> Clint: not very, feel free to just show up
10:12:12 * Clint might do that.
10:12:27 <confusing> EvanR: i feel that most forums online are pretty low-quality. for some reason, SO works better. probably the voting encourages people to give better answers
10:12:30 <Cale> and it just seemed a bit rude for this awkward-to-use website to come along and start stealing users
10:12:36 <conal> applicative: i just left a comment on uday's latest, continuing from one of your comments. i think uday just picked an unfortunate term with "in the language". http://stackoverflow.com/questions/210835/what-is-referential-transparency/9859966#comment15582297_9859966
10:12:39 <Cale> It's a bit irrational of me to think that way, I suppose.
10:12:56 <Cale> I hate SO's karma system
10:13:11 <Cale> and that I can't just do everything the moment I sign up
10:14:01 <roconnor> @quote roconnor pure
10:14:01 <lambdabot> roconnor says: An arrow (category) is pure if (f &&& f) = f >>> (id &&& id). When people say Haskell is pure they mean that (->) is pure. When people say IO isn't pure they mean that (Kleisli IO)
10:14:01 <lambdabot> isn't pure.
10:14:03 <Cale> I much prefer a wiki format for question/answer where everyone can edit everything, and there's version control.
10:14:41 <Cale> Or IRC, of course :)
10:14:46 <mekeor> :)
10:14:54 <confusing> cale: that's really a good point. i do dislike that SO answers are immutable
10:15:30 <Cale> If I see a typo in your answer, I should be able to fix it, and vice-versa
10:16:33 <xplat> i think the functional programmer's idea of referential transparency is the same as Quine's, except that the functional programmer insists also that evaluation of an expression does not change its referent
10:16:40 <quintessence> roconnor: I like that definition, it's simple and non-evil
10:17:21 <nand`> it captures how I usually explain ‘purity’, but in a nice existing mathematical domain
10:17:26 <nand`> (re: roconnor's definition)
10:17:36 <roconnor> quintessence: it's also incomplete
10:17:44 <nand`> unfortunately, explaining this to an imperative programmer who's never heard of CT likely isn't going to work
10:17:48 <MHD> Hmm... I have a polymorphic function with a... non-occuring type parameter? that is none-the-less important for a class function; ghc is giving me shit about Abigous types
10:17:55 <roconnor> quintessence: also needs to add (f &&& g) >>> first = f
10:18:06 <MHD> even thoug the type sig is afaict well formed
10:18:08 <Cale> MHD: you need to choose a fixed type for that thing
10:18:17 <gertc> http://stackoverflow.com/questions/11731941/haskell-facebook-exceptions
10:18:18 <Cale> MHD: It needs to know what instance to use
10:18:22 <MHD> Cale: Damn
10:18:35 <Cale> MHD: Well, what are you trying to do?
10:18:42 <nand`> Cale: I think editing others' posts like that would be too easy to abuse
10:18:56 <Cale> nand`: And yet wikis work.
10:19:15 <MHD> Cale: Building a parser with type-agnostic input, and a type-agnostic end-of-input combinator
10:19:34 <mekeor> what does a monad have to do with a monoid? (german wikipedia states they have a formal similarity.)
10:19:49 <Cale> mekeor: This takes a bit of explanation, do you have some time?
10:19:54 <nand`> mekeor: “a monad is just a monoid in the category of endofunctors”
10:20:03 <mekeor> Cale: Yes =)
10:20:06 <xplat> 'what's the problem?'
10:20:07 <Cale> mekeor: Well, okay, you know what a plain monoid is, yeah?
10:20:13 <mekeor> Yes.
10:20:42 <MHD> meekeor: Monoids require associativity, identity element and totality. Monads have return and bind satisfying the associativity and identity bits
10:20:49 <mekeor> meekeor :D
10:20:53 <Cale> It's a set M together with an element 1 in M (the identity), and a function M x M -> M (the multiplication) satisfying associativity and identity laws
10:21:01 <MHD> mekor: ^
10:21:02 <xplat> (so is an operad just an operoid in the category of endofunctors?  and if so what's an operoid?'
10:21:05 <mekeor> mekor :D
10:21:07 <MHD> mekeor: ^
10:21:09 <mekeor> :D
10:21:28 <mekeor> Cale: yep.
10:21:46 <EvanR> truoid and falsoid inhabitoids of the type booleoid
10:21:47 * hackagebot cyclotomic 0.3.1 - A subfield of the complex numbers for exact calculation. (ScottWalck)
10:21:47 <Cale> In order to categorify this, I'm going to replace that "element of" with another function  1 -> M
10:21:49 <MHD> mauke: what?
10:22:09 <mauke> MHD: what?
10:22:12 <nand`> return >=> x  =  x  =  x >=> return;  (a >=> b) >=> c = a >=> (b >=> c)
10:22:13 <mekeor> Cale: okay…
10:22:34 <nand`> look, identity and associativity :D
10:22:47 <MHD> mauke: The chat told me your client did a thing with some CTCP version form Me.
10:22:56 <mauke> MHD: ok?
10:23:08 <MHD> so I just wanted to know if that was intentional
10:23:19 <mauke> it was
10:23:23 <MHD> k
10:23:33 <Cale> mekeor: Now, do you know what a monoidal category is?
10:23:35 <nand`> he was probably seeing which client you used that doesn't tab complete
10:24:14 <nand`> Cale: by ‘monoidal category’ does one mean one-object category or something more complex?
10:24:27 <mekeor> Cale: no…?
10:24:29 <nand`> oh, nvm; I looked it up
10:24:34 <mekeor> Cale: not sure…
10:24:42 <Cale> mekeor: It's basically a category which has a monoidal (up to isomorphism) operation on its objects
10:25:00 <Cale> (Sorry if I'm a little bit slow, I'm trying to talk to too many people at once)
10:25:38 <Cale> Set can be made a monoidal category with Cartesian product on its objects
10:25:45 <Cale> and a one-element set for the "identity" of that operation
10:26:04 <Cale> Since 1 x M and M x 1 are isomorphic to M
10:26:11 <mekeor> yea.
10:26:16 <mekeor> okay.
10:26:16 <Cale> and (A x B) x C is isomorphic to A x (B x C)
10:26:23 <Cale> (canonically, in all cases)
10:26:25 <mekeor> *nod*
10:26:27 <Cale> okay
10:27:10 <Cale> so, suppose we have a monoidal category C. A monoid object in C will be an object M of C together with arrows: η: 1 -> M and μ: M * M -> M
10:27:11 <MHD> Oooh... Forgot a functional dependency
10:27:12 <xplat> the category of endofunctors on C is also monoidal with composition of endofunctors as the operation
10:27:22 <Cale> satisfying some laws analogous to the laws for monoids in Set
10:27:31 <applicative> conal I saw your remark
10:27:42 <Cale> specifically... (let's see if I can do this off the top of my head :D)
10:28:52 <mekeor> :/
10:29:59 <Cale> Basically, we want it to be true that if we take η * id : 1 * M -> M * M
10:30:16 <Cale> and then multiply, μ . (η * id) : 1 * M -> M
10:30:27 <Cale> then that's got to be the same as the canonical isomorphism 1 * M -> M
10:30:36 <Cale> and similarly if we do it on the other side
10:30:48 <Cale> so μ . (id * η) : M * 1 -> M
10:30:56 <Cale> needs to be the same as that isomorphism
10:31:04 <Cale> and then we need associativity
10:31:30 <conal> applicative: i just added another: "I think it's worth emphasizing that confusing these two notions of "value" (evaluations vs denotations) misleads functional programmers in their criticism of *imperative* languages, where the gap between notions is large."
10:31:43 <Cale> So if we start out at (M * M) * M, and we multiply the left two using μ * id to get to M * M
10:32:03 <Cale> and then we multiply again μ . (μ * id) : (M * M) * M -> M
10:32:22 <Cale> then that should be the same as if we use the isomorphism to reassociate first:
10:32:33 <Cale> a: (M * M) * M -> M * (M * M)
10:32:43 <Cale> and then multiply on the right
10:32:57 <applicative> the gap between evaluated terms and denotations is larger in imperative languages? (I'm trying to figure it out)
10:32:59 <Cale> (id * μ) . a: (M * M) * M -> M * M
10:33:04 <Cale> and then multiply again
10:33:09 <Cale> μ . (id * μ) . a: (M * M) * M -> M
10:33:18 <EvanR> are the names monoid and monad at all related, all this category theoretical facts nonwithstanding
10:33:24 <Cale> i.e. μ . (μ * id) = μ . (id * μ) . a
10:33:26 <Cale> yeah?
10:33:37 <Cale> this is a bit hard to see without drawing the diagrams
10:33:45 <Cale> http://en.wikipedia.org/wiki/Monoid_(category_theory)
10:33:47 <conal> i.e., the evaluation notion leads to the conclusion that imperative languages are not RT, while the denotation notion does not.
10:33:49 <Cale> has the diagrams
10:34:00 <EvanR> i always figured it was coinsidentally similar
10:34:02 <SegFaultAX|work2> RT?
10:34:10 <xplat> applicative: in (typical semantics for) imperative languages evaluation of an expression does not preserve its denotation
10:34:21 <byorgey> SegFaultAX|work2: referentially transparent
10:34:21 <Cale> EvanR: Monad is a portmanteau of monoid and triad
10:34:28 <SegFaultAX|work2> byorgey: Ah.
10:34:33 <EvanR> really?
10:34:41 <Cale> EvanR: triad and triple were early names for monads
10:34:49 <mekeor> Cale: Okay. I'll try to live with what I understood for now… :]
10:34:51 <Cale> (T,η,μ)
10:34:54 <Cale> mekeor: okay
10:35:04 <Cale> So without much more getting bogged down in details
10:35:10 <applicative> conal: if you assign what is called a semantics to a language, you implicitly put a reading on it as 'referentially transparent'
10:35:17 <Cale> We can look at the monoidal category of endofunctors C -> C
10:35:32 <Cale> The objects in this category are functors C -> C
10:35:40 <Cale> and the arrows are natural transformations
10:36:00 <Cale> the monoidal operation on objects is composition
10:36:06 <Cale> and the identity of that is the identity functor
10:36:07 <conal> applicative: a strachey-style semantics, anyway. i think that's what he was getting at.
10:36:16 <Cale> and now what's a monoid in this category?
10:36:26 <Cale> Well, it's some endofunctor M: C -> C
10:36:32 <SegFaultAX|work2> Cale: Is category theory still something actively researched?
10:36:38 <Cale> with natural transformations η: 1 -> M
10:36:46 <Cale> and μ: M . M -> M
10:36:56 <Cale> satisfying appropriate identity and associativity laws
10:37:01 <Cale> Now in Haskell, we have
10:37:03 <byorgey> SegFaultAX|work2: yes
10:37:06 <Cale> return :: a -> M a
10:37:09 <marcot> Using tagsoup is better than regexp indeed, thanks.
10:37:12 <Cale> and join :: M (M a) -> M a
10:37:12 <applicative> yes. but this but shows its irrelevant, no.  the real ideal of Haskell is of a language for which a semantics is unnecessary, since it is entirely 'homophonic' as Quine would say.
10:37:32 <Cale> we use polymorphic functions to capture natural transformations
10:37:47 <conal> applicative: what i meant by the larger gap between evaluations and denotations: denotations of expressions in imperative languages are too complex to have corresponding syntactic literals.
10:37:47 <Cale> and of course, our endofunctor is a functor Hask -> Hask
10:37:56 <conal> hm.
10:37:59 <conal> applicative: what i meant by the larger gap between evaluations and denotations: denotations of expressions in imperative languages are too complex to have corresponding syntactic literals.
10:38:11 <conal> my irc client is acting oddly.
10:38:24 <conal> i see.
10:38:25 <Cale> SegFaultAX|work2: From what I understand, it's mostly active in the area of higher-dimensional categories.
10:38:27 <conal> applicative: what i meant by the larger gap between evaluations and denotations: denotations of expressions in imperative languages are too complex to have corresponding syntactic literals.
10:38:49 <Cale> I don't know whether there are still a lot of people studying plain ol' categories at this point, but I wouldn't be too surprised.
10:38:56 <SegFaultAX|work2> Cale: But most of the lower level aspects of category theory are, for lack of a batter term, fully explored?
10:38:57 <applicative> conal: yes, isn't this a decisive objection?
10:39:00 <nand`> Cale: thanks for the explanation, the bit about monoidal categories cleared up some things for me
10:39:03 <quintessence> conal: is that mostly just because they're all functions?
10:39:37 <Cale> SegFaultAX|work2: Well, they're *well* explored
10:39:42 <applicative> conal, professors must struggle for years to find a 'semantics' for C. If we were writing in Turner's imagined language, any child could write.
10:39:46 <applicative> the semantics
10:39:47 <Cale> SegFaultAX|work2: I would never say fully explored
10:39:54 <conal> quintessence: in part, and because they're functions of "the store", which also doesn't have corresponding syntax.
10:40:05 <Cale> SegFaultAX|work2: Someone could always come along and find something new and fundamental
10:40:23 <EvanR> Cale: i missed the parrt where you defined what Hask was
10:40:28 <Cale> EvanR: ;)
10:40:28 <SegFaultAX|work2> Cale: Sure, but those types of break throughs are pretty far and few between these days it seems like.
10:40:40 <quintessence> conal: that's true.  (Amusingly, more so in SML than in C... but I suppose C has trouble with the "functions" part.)
10:40:42 <conal> applicative: yes. an enormous objection to imperative programming is its denotational complexity. decisive for me.
10:40:42 <applicative> in C no human being can actually mean what the learned have assigned to the terms as their denotations. there fore it is not actually a language
10:40:44 <Cale> EvanR: It's the putative category of Haskell types and Haskell-definable functions between them
10:41:06 <xplat> in imperative languages the expressions nominally of type 'a' denote something more like a value of type 'IO a' in hasekll
10:41:29 <Qtr> denotional complexity?
10:41:42 <Cale> SegFaultAX|work2: But there is a lot of room up in higher-dimensional category theory to find new things, and so that's where the subject is headed.
10:41:50 <conal> Qtr: denotational complexity. complexity of meanings.
10:41:53 <xplat> the denotations of C values can involve store effects, nondeterminism and other nuisances
10:41:56 <applicative> in Haskell or rather in Turner, each expression actually  means what it seems to mean; you can use the expressions of the programming language in a scientific essay or a letter to your mother
10:41:59 <SegFaultAX|work2> Cale: Is that your area of expertise?
10:42:11 <SegFaultAX|work2> Cale: Are you a researcher/scientist?
10:42:16 <Cale> SegFaultAX|work2: I wouldn't say so. It's an interest of mine.
10:42:26 <Cale> I just have a BMath in pure mathematics from Waterloo
10:42:32 <Cale> and I've been working as a programmer
10:43:01 <SegFaultAX|work2> Cale: Do you use haskell or other functional languages at work?
10:43:10 <Cale> I have, on more than one occasion :)
10:43:19 <conal> for me, denotational semantics gives the clearest demonstration that imperative programming is doomed. the models are too complex to reason with effectively.
10:43:38 <Qtr> Is there some boring program in Linux that you think could be done better?
10:43:48 <Cale> I was working for a company called iPwn Studios, and we were working on an FRP game engine in Haskell for iPhones. Almost have it done too, but the company sadly ran out of money.
10:44:05 <Cale> So we'll probably revive that at some point.
10:44:07 <applicative> yes of course, but it also means,that no one has actually thought anything using such a language
10:44:19 <applicative> it's physically impossible.
10:44:21 <Cale> (because it's very close to being able to start producing money)
10:44:26 <applicative> so they arent  languages
10:44:28 <luite> aw that's sad :(
10:44:30 <byorgey> Cale: oh, sad, I hadn't heard that.
10:44:31 <SegFaultAX|work2> Cale: That's awesome!
10:44:47 <SegFaultAX|work2> Cale: Except, can haskell really run on performantly on such a limited platform?
10:44:53 <Cale> SegFaultAX|work2: It can
10:44:55 <nand`> applicative: what exactly is a ‘reduced expression’ anyhow? An expression only containing data constructors?
10:45:07 <Cale> SegFaultAX|work2: Well... there are some challenges, of course :)
10:45:16 <luite> recent iphones aren't terribly limited either :)
10:45:17 <conal> (too complex to reason with effectively.) including, of course, haskell's version of imperative programming (IO), since it doesn't address semantic issues.
10:45:35 <SegFaultAX|work2> Cale: Is the language usage drastically different when working with Haskell in an embedded context?
10:45:47 <quintessence> conal: I'd be interested in hearing your take on Eff, if you've looked at it.
10:45:52 <slack1256> I'm afraid to ask
10:45:53 <ReinH> d-old: omg I am so surprised
10:45:58 <nand`> Cale: good luck, getting FP into the game industry would be something I'd like to see, see also haskell-arcade :)
10:45:59 <slack1256> do CoArrows exist?
10:46:08 <applicative> conal: that's true but it does have the advantage that no one assimilates getChar to 'a'
10:46:24 <ReinH> Is there an easy way to derive or write an instance of Arbitrary for algebraic data types composed entirely of nullary constructors?
10:46:39 <ReinH> a.k.a. data Thing = This | That deriving (Arbitrary)
10:46:42 <applicative> Eff, Eff? I thought we used Frank in here....
10:46:52 <mauke> ReinH: Enum, Bounded
10:46:56 <conal> applicative: indeed! haskell's approach makes clearer when we've left denotative programming.
10:46:57 <mauke> generate Int, convert
10:47:07 <Cale> SegFaultAX|work2: Well, hmm... I suppose we have had to be quite aggressive about how our FRP system optimises the things it's doing.
10:47:09 <conal> quintessence: eff? url?
10:47:21 <ReinH> mauke: with Enum I can just do arbitrary = elements [ This .. That ] as well right?
10:47:30 <quintessence> http://math.andrej.com/category/programming/eff/
10:47:41 <mauke> ReinH: sorry, I don't know Arbitrary
10:47:43 <applicative> http://math.andrej.com/2010/09/27/programming-with-effects-i-theory/
10:47:47 <ReinH> mauke: for QuickCheck :)
10:47:47 <byorgey> ReinH: yes
10:47:52 <ReinH> byorgey: is that the simplest?
10:47:56 <ReinH> it seems like it should be derivable
10:48:01 <Cale> SegFaultAX|work2: We have an Arrow based FRP system -- not quite Control.Arrow, but a new Arrow library which does a better job of avoiding the need for 'arr' everywhere.
10:48:03 <byorgey> I can't think of anything simpler.
10:48:07 <ReinH> byorgey: thanks :)
10:48:24 <ReinH> I wonder why it isn't derivable for instances of Enum
10:48:28 <applicative> conor quintessence  contrast https://personal.cis.strath.ac.uk/conor.mcbride/pub/Frank/
10:48:28 <SegFaultAX|work2> Cale: I'm assuming that reduces the overall number of allocations?
10:48:43 <Cale> SegFaultAX|work2: and it does a lot of things to the Arrow computation you give it to reduce the amount of work which needs doing, yeah
10:48:44 <byorgey> ReinH: if you want to derive it you may be able to use some library like derive
10:48:49 <conal> quintessence: thx.
10:48:51 <byorgey> @package derive
10:48:52 <lambdabot> http://hackage.haskell.org/package/derive
10:48:57 <Gurragchaa> what's the haskell equivalent of the idea of "keeping a running tally" without using state variables?
10:49:03 <ReinH> byorgey: thanks, I guess I'm mainly just curious
10:49:04 <byorgey> ReinH: but that seems like overkill
10:49:06 <ReinH> byorgey: I'll take the one liner
10:49:07 <Cale> SegFaultAX|work2: Well, the problem with 'arr' is that it's essentially a black box
10:49:07 <SegFaultAX|work2> Cale: I'm an Python/Erlang hacker. Haskell is still quite new to me so I don't fully understand Arrows. Yet.
10:49:09 <quintessence> applicative: I looked at Frank when it was first announced, they seemed pretty similar
10:49:13 <c_wraith> Gurragchaa: foldl, more or less
10:49:24 <c_wraith> Gurragchaa: more specifically, recursion with an accumulator
10:49:26 <Cale> SegFaultAX|work2: oh, okay. Do you understand monads?
10:49:27 <jfischoff> Gurragchaa: also scanl
10:49:28 <Gurragchaa> foldl combined with lazy evaluation?
10:49:28 <ReinH> byorgey: who knows how many lines of derive to derive a one liner? yes it does ;)
10:49:29 <quintessence> I do approve of effects appearing in types, but I think Bauer/Pretnar are working on that too
10:49:32 <SegFaultAX|work2> Cale: Yes.
10:49:36 <luite> ReinH: Enum isn't enough, for example Integer is Enum but you can't write a proper Arbitrary
10:49:42 <c_wraith> Gurragchaa: actually, no.  foldl isn't meaningfully lazy
10:49:45 <byorgey> ReinH: the point is, it IS derivable, but only certain very standard things are actually built into GHC
10:49:50 <ReinH> luite: you need bounded, yes
10:49:54 <c_wraith> Gurragchaa: scanl is lazy, though, if you want the intermediate results
10:49:55 <ReinH> byorgey: ok thanks
10:49:59 <applicative> quintessence: yes, I  didn't get to the bottom of it.  Inevitably Frank seemed much more beautiful to me which is maybe not the best criterion
10:50:03 <Gurragchaa> hmm, I'll read up on those, thanks
10:50:10 <xplat> gah, i have to go all the way back to heist 0.6.0.1 just to get a version that won't fuck all my existing installs because of attoparsec 0.10's dependency on non-platform text
10:50:10 <Cale> SegFaultAX|work2: Okay, so when you're composing monadic actions, there are a lot of functions: whenever you have x >>= f  the f is a black box which you have no way of knowing what it is before you apply it.
10:50:12 <ReinH> luite: but an algebraic type of nullary types is bounded
10:50:12 <applicative> though it has a lot to be said for it
10:50:14 <hy[er]> Are there any decently sized programs/libraries that make use of the state monad that I can look at to get some ideas for good practice?
10:50:18 <ReinH> luite: right?
10:50:18 <c_wraith> > scanl (+) 0 [1..] -- Gurragchaa
10:50:19 <lambdabot>   [0,1,3,6,10,15,21,28,36,45,55,66,78,91,105,120,136,153,171,190,210,231,253,...
10:50:33 <ReinH> s/0/1 and you have fibs :)
10:50:41 <Cale> SegFaultAX|work2: So even if x is something which might somehow "fuse" with that f, there's no way for the function which is running your monadic action to be clever
10:50:53 <byorgey> ReinH: actually, it looks like with the 'derive' library you would need... one line =)
10:50:53 <ReinH> my favorite infinite fibonacci list constructor
10:50:57 <ReinH> byorgey: lmao :D
10:51:01 <ReinH> forget that
10:51:09 <xplat> is there some way i can get around this?
10:51:13 <applicative> quintessence: moreover I could sort of follow the implementation ...
10:51:14 <DMcGill> hey, can anybody here tell me that the "-B" option in haddock does? The docs just say "Tell GHC that that its lib directory is dir. Can be used to override the default path."
10:51:17 <Cale> SegFaultAX|work2: Arrow provides an interface to things which abstracts over both the input and output, so that instead of working with functions A -> M B
10:51:22 <ReinH> byorgey: I'm totes happy with the elements one liner, I was just curious
10:51:23 <xplat> (and don't say cabal-dev, that won't work)
10:51:23 <ReinH> byorgey: thanks
10:51:34 <byorgey> ReinH: sure =)
10:51:44 <Cale> you work with arrow values F A B
10:51:51 <DMcGill> does that mean a package-db? It crashes if there isn't a "settings" file in the directory, which isn't a requirement of a package-db
10:52:03 <Cale> and you compose them:
10:52:06 <Cale> :t (>>>)
10:52:07 <lambdabot> forall (cat :: * -> * -> *) a b c. (Control.Category.Category cat) => cat a b -> cat b c -> cat a c
10:52:15 <Cale> oh, heh, Control.Category, okay :)
10:52:49 <SegFaultAX|work2> So how do you define a category?
10:52:49 <applicative> conal, it is certainly a problem dealing with the topic and remarks like Uday R.'s that Haskell isn't adequate to the ideal you get reading e.g. Landin
10:52:50 <Cale> but yeah, that's the idea, the type constructor 'cat' there is something you control, and so you can have values in there which are not just black boxes
10:53:06 <mightybyte> xplat: Why is non-platform text a problem?
10:53:59 <Cale> Control.Category is a sort of a weird take on what categories are (an odd internalisation that I'm not sure has a name in category theory)
10:54:07 <byorgey> xplat: what? attoparsec 0.10 depends on text >= 0.11.1.5.  the latest HP has text-0.11.2.0.  what's the problem?
10:54:08 <Cale> (but perhaps it ought to)
10:54:50 <callen> I'm trying to get my freshly init'd yesod project to build
10:55:02 <callen> it says it is rejecting over various conflicts when I cabal install
10:55:09 <callen> I googled but couldn't find anything coherent.
10:55:10 <Cale> SegFaultAX|work2: A category is a collection of objects (in the case of Haskell, types), and arrows between them, together with a composition which composes arrows whose head and tail line up
10:55:12 <callen> halp?
10:55:40 <Cale> SegFaultAX|work2: and there are identity arrows at every object which act as identities for composition
10:55:57 <Qtr> Cale: what are you working with now?
10:56:03 <jfischoff> Cale: odd internalizaion because they are also subcategories of Hask?
10:56:20 <Cale> jfischoff: and because (.) and id are some kind of natural transformations
10:56:24 <byorgey> callen: (1) you will have to give much more detail (e.g. paste the output showing the conflicts to hpaste.org), and (2) you may want to try #yesod
10:56:32 <applicative> grr callen  I could be compllicated.  Note #yesod
10:56:36 <applicative> as byorgey says
10:56:47 <Cale> jfischoff: They'
10:56:55 <Cale> jfischoff: They're not necessarily subcategories
10:57:02 <Cale> But they're built on the same objects as Hask
10:58:03 <applicative> callen: it might be easy, though, post the complaints maybe ?
10:58:15 <Cale> but they have different arrows, and the composition is required to act in a polymorphic way which can probably be generalised somehow in terms of natural transformations
10:59:10 <xplat> mightybyte: because i already have some libraries installed with platform text (like hashable) and heist depends on the same libraries, same versions
10:59:11 <applicative> callen: and maybe the result of ghc-pkg list ...?
10:59:38 <Cale> Qtr: I'm working for the same guy, but at a different company, working on a scheduling web application, somewhat amusingly written in the trainwreck of a language that is Groovy.
10:59:41 <xplat> so they will get reinstalled and break whatever already is in that depends on *those* libs
10:59:58 <applicative> Groovy, wow.
10:59:59 <mightybyte> xplat: In that case, I just try to build the package with the most dependencies first.
11:00:03 <callen> http://dpaste.de/MxMOn/ what gives?
11:00:13 <Cale> Qtr: The original programmers that we inherited this codebase from were really really bad at programming.
11:00:25 <mightybyte> xplat: That way everything gets built with the right dependencies.
11:00:36 <callen> applicative: http://dpaste.de/mm1ON/
11:00:43 <xplat> byorgey: hm, i have text 0.11.0.6
11:01:10 <applicative> callen hmm
11:01:10 <mightybyte> If there are incompatible dependencies in there, then it would seem like some form of a sandboxed build will be required until Cabal gets much more sophisticated support for dependencies.
11:01:12 <byorgey> xplat: where did you get it from?
11:01:20 <Cale> But at the end of August or so, I'm going to talk with Edward Kmett about coming to work for him -- apparently he's doing stuff in Scala and a Haskell-like internal language writing software for financial analysts.
11:01:34 <xplat> i guess i don't have the latest platform anymore ...
11:02:12 * applicative wonders what this internal language is like. 
11:02:18 <SegFaultAX|work2> Cale: So arrows are like a more generic function or something?
11:02:20 <byorgey> xplat: 0.11.0.6 was released in march 2011
11:02:57 <Taneb> SegFaultAX, yeah
11:03:09 <applicative> callen: can you post the output of ghc-pkg list?
11:03:47 <jfischoff> Cale: After programming in Haskell with good code or awhile, you forget how bad things can get.
11:04:21 <Cale> SegFaultAX|work2: yeah, like an abstraction of functions
11:04:26 <applicative> callen  I take it yesod-platform-1.0.6 is the one installed
11:04:28 <Cale> SegFaultAX|work2: (->) has an Arrow instance too
11:04:36 <Cale> SegFaultAX|work2: which does simple, but often useful things
11:04:37 <SegFaultAX|work2> So this is probably way off, but are arrows kind of similiar to multimethods in the sense of being able to provide a collection of functions for a collection of types?
11:04:53 <SegFaultAX|work2> Cale: I need to step away for a meeting.
11:04:56 <SegFaultAX|work2> Cale: Bbs.
11:05:02 <Cale> SegFaultAX|work2: Just like Monad, it's a "shape" that some library APIs can fit into
11:05:24 <Cale> jfischoff: lol, yeah
11:06:27 <applicative> callen: this is a little speculative, but it looks like your yesod-auth is not in tune with your yesod-platform you might do ghc-pkg unregister yesod-auth so it isn't distracted by the old one that is almost right
11:07:26 <xplat> Cale: groovy?  my condolences
11:07:36 <Cale> jfischoff: Though a lot of it actually has nothing to do with the language, and is more about people who didn't know how to program doing insane things. People who aren't at least 90% as smart as Ashley Yakeley should not be allowed anywhere near code which involves times and dates.
11:08:27 <xplat> byorgey: i don't have platform 2012.2 on this machine, it seems
11:09:01 <bitonic> is groovy that bad?
11:09:05 <applicative> man yesod-platform has so many dependencies. too much to go wrong!
11:09:43 <xplat> bitonic: well, it's still better than PHP
11:09:55 <bitonic> xplat: that does not tell me much
11:09:55 <applicative> 122 explicit dependencies
11:10:18 <merijn> Cale: If it's any consolation, the minute I become ruler of Earth I will replace all notions of time with a universal and regular metric :p
11:10:33 <Cale> There's a significant amount of code which is doing arithmetic on base 100 encoded times. (e.g. using 1630 to represent the time 16:30 in god-knows-what timezone)
11:10:34 <Cale> (I'm going to fix that though)
11:10:46 <xplat> bitonic: you know how objective C is half C, half smalltalk?  this is half java, half ruby
11:11:01 <bitonic> xplat: uh, OK.
11:11:34 <RichyB> merijn, we already have one, it's called TAI.
11:11:54 <xplat> bitonic: the halves are a little more equal, though
11:12:05 <RichyB> Fortunately, all you need to do is force everyone to use TAI instead of UTC as their time base, and proper conversion routines from TAI to local times.
11:12:07 <bitonic> xplat: while Obj-C is more C?
11:12:21 <applicative> can small children be taught this TAI representation?
11:12:32 <xplat> Cale: decimal-coded sexagesimal?
11:12:41 <Cale> xplat: indeed!
11:12:43 <merijn> RichyB: Sufficiently obscure that apparently duckduckgo doesn't list it among the wikipedia entries for TAI
11:12:56 <merijn> RichyB: Oh, that's not good enough
11:12:56 <RichyB> Even better, TAI is about 30 seconds out from UTC, so it's kind of obvious when you have them misconfigured.
11:13:10 <merijn> RichyB: I meant all months being the same length, that sorta thing
11:13:24 <RichyB> Ah I see.
11:13:36 <merijn> None of this 1000 milli seconds in a second, but 60 seconds in a minute business
11:14:00 <xplat> > 365/12
11:14:01 <lambdabot>   30.416666666666668
11:14:15 <RichyB> Properly, TAI is just "seconds since (nominally) 1970."
11:14:23 <Cale> Groovy is like if some guys who didn't know much about writing compilers got together and decided to make a Ruby-like language on the JVM, and ended up making something which was significantly slower than Ruby and which makes Ruby appear semantically nice.
11:14:48 <c_wraith> Cale: I've never been more terrified by a language description.  Not even Intercal's language description
11:14:55 <xplat> heh, yes, it got slow from both sides of the family
11:15:19 <xplat> no regression to the mean here
11:15:20 <RichyB> TAI ignores leap seconds. Since UTC has leap seconds, there are individual UTC timestamps which correspond to more than one real second.
11:15:28 <Cale> From what I understand, it does a String lookup for every function call, on both the name of function, and the types of its arguments.
11:15:47 <hy[er]> is there a simple way of altering the state monad so that it returns nothing if the state is empty before running the computation
11:16:13 <xplat> Cale: last i heard it's not just a string lookup, it's a java reflection lookup, which was never meant to be fast
11:16:31 <RichyB> merijn, my point is that (TAI seconds since 1970) → (actual seconds of physical time that we on Earth experience) is a bijective function, whereas (UTC seconds since 1970) → (actual seconds of physical time that we on Earth experience) is actually a one-to-many relation. :)
11:16:38 <mapreduce> Cale: Wait, what?  Groovy is slower than Ruby?
11:16:49 * hackagebot wai-lite 0.1.0.0 - A minimalist web framework for WAI web applications (AmitLevy)
11:16:55 <zomg> Cale: it must be very wrong for it to be slower than Ruby...
11:17:32 <Qtr> Anyone have "write yourself a scheme in 48hours" complete source? I feel I know Haskell well enough to learn by reading the code directly.
11:17:35 <xplat> (or maybe it was a string lookup for groovy function calls and reflection for calls into java?)
11:17:36 <cleantc_> data T a where T1 :: (forall b. b -> b) -> (forall a. Int -> T a)
11:17:44 <Cale> xplat: that sounds right
11:17:52 <Taneb> hy[er], it's not possible for the state to be empty
11:17:57 <cleantc_> why doesn't it typecheck?
11:18:29 <hy[er]> Taneb, oh I mean that it is of the form []
11:18:38 <hy[er]> if I use a list as my state
11:18:42 <Cale> mapreduce: It's possible that it's gotten better in newer versions, I don't know. The version we're using is extremely wasteful and slow though :)
11:18:54 <Taneb> hy[er], oh, hmm
11:19:12 <xplat> zomg: it is one of the few cases where the creator of the language recanted from creating it and recommended people use a different language instead
11:19:27 <jfischoff> I have a design question about expression parsing and GADTs. If you have a type safe GADT does it make sense to also have a type unsafe AST so you can separate out parsing and type checking?
11:19:35 <bitonic> according to the nefarious shootout ruby is faster than python and perl
11:19:35 <mapreduce> Cale: I often get into silly discussions starting somewhere near "Why does int i = "hello" compile in Groovy?" :)
11:19:37 <merijn> Cale: In other words it has no redeeming feature whatsoever?
11:20:00 <merijn> bitonic: That sounds like filthy lies
11:20:03 <Veinor> 14:19:15          <mapreduce> Cale: I often get into silly discussions starting somewhere near "Why does int i = "hello" compile in Groovy?" :)
11:20:04 <Veinor> ... wat
11:20:13 <bitonic> merijn: well, you can check...
11:20:16 <xplat> jfischoff: generally speaking, yes
11:20:38 <bitonic> merijn: I'd safely say that is not that different from python/perl/php in terms of performance.
11:20:43 <Cale> merijn: Almost true. It does at least try to have something akin to first class procedures.
11:20:55 <Cale> merijn: But that doesn't really save it.
11:21:22 <hpaste> cleantc pasted “RankN Existentials” at http://hpaste.org/72398
11:21:45 <Cale> I wouldn't use it for any new project. Then again, that's true for most languages for me, because I would probably just pick Haskell 99% of the time.
11:22:00 <mauke> cleantc_: what if you remove "forall a."?
11:22:08 <RichyB> merijn, oh that reminds me! We already have a reasonably regular calendar too: the Erisian calendar. Instead of twelve irregular seasons, it has five seasons (Chaos, Discord, Confusion, Bureaucracy and The Aftermath) of 73 days apiece.
11:22:14 <jfischoff> xplat: thanks
11:22:36 <Qtr> @Cale: what do you do now that the gaming company ran out of money?
11:22:36 <lambdabot> Unknown command, try @list
11:22:39 <merijn> Cale: Well, C has some nice niches and if I need to work with mere mortal programmers I'll just settle for python out of convenience
11:22:41 <RichyB> merijn, I know 73 is prime and all but what the Hell, it kinda (ish) matches up with solar motion.
11:23:00 <Cale> Qtr: I've just spent the last while discussing that :)
11:23:12 <cleantc_> mauke: it works but what is wrong with the having an explicit forall ?
11:23:33 <Qtr> ive been kicked on and off sorry
11:23:39 <Cale> Oh I see
11:25:01 <Cale> Qtr: I'm working for a company which is making a scheduling web application in Groovy, which is a laughably bad programming language, and the codebase we've inherited is even worse. The application does (mostly) do what it's intended to do though, and they have customers and lots of money to pay me with.
11:25:55 <RichyB> Cale, "laughably bad" sounds unfairly harsh, given that it coexists in the same universe as PHP.
11:26:06 <Cale> Qtr: and at the end of August, I'm going to talk with Edward Kmett about coming to work for him writing code in Scala and a Haskell-like language they've developed internally, writing software for financial analysts, apparently.
11:26:11 <cleantc_> :t (undefined::(forall b. b -> b) -> (forall a. Int -> Maybe a))::(forall b. b -> b) -> (Int -> Maybe a)
11:26:11 <mapreduce> Cale: fwiw, the newest versions have @TypeChecked, an annotation that enables static type checking.
11:26:12 <lambdabot> forall a. (forall b. b -> b) -> Int -> Maybe a
11:26:21 <quintessence> RichyB: I think the universe has plenty of room for humor
11:26:32 <Cale> mapreduce: Does the 'static' keyword do anything in new versions?
11:26:46 <Taneb> Is FunctionalDependencies pretty much part of Haskell proper now?
11:26:51 <Cale> er, sorry I mean 'private'
11:27:11 <mapreduce> No idea, I've never used Groovy.
11:27:29 <Cale> It lets you label things as private and public, but everything is public anyway
11:27:30 <Taneb> Wow, our hugs is the first google result for "hugs"
11:27:54 <c_wraith> Taneb: did you try that from a browser with no google cookies?
11:28:03 <Cale> Taneb: In a way... at the same time it's also nearing obsolescence
11:28:07 <Taneb> c_wraith, ah, that might explain it
11:28:30 <Taneb> Cale, might I ask what's replacing it?
11:28:34 <Cale> Taneb: (because of associated types and type families)
11:28:38 <Taneb> Okay
11:28:44 <Taneb> I need to learn how they work at some point
11:28:55 <Cale> There are still some things which I prefer the FD notation for
11:28:57 <Qtr> Cale: oh, sounds nice, good luck to you. You have a PhD in "Haskell" right?
11:29:11 <Cale> Qtr: I just have a BMath in pure mathematics.
11:29:20 <Cale> I don't have any degrees beyond that.
11:29:28 <Cale> But yeah, I know Haskell well.
11:30:05 <Taneb> You know you can get a Bachelor of Arts in Maths?
11:30:11 <Cale> hah, yeah
11:30:23 * merijn facepalms
11:30:31 <Taneb> And a Master of Science in the subject, FROM THE SAME ESTABLISHMENT
11:30:33 <Cale> Bachelor of Science in Maths seems more ironic to me
11:30:47 <Cale> (Mathematics is not a science, sorry)
11:30:51 <Taneb> (St Andrews is the one I'm thinking of)
11:31:00 <hayashi> Anyone here know how to get yi to stop (seemingly) changing some Haskell combinators to non-ASCII glyphs?  Either it's doing that or something else's causing it to replace certain symbols with broken garble (yay seemingly indiagnosable terminal encoding mismatches)
11:31:28 <merijn> Taneb: Oh...Scotland...must be all the whisky
11:31:35 <luite> does the arts/science distinction actually affect the program itself, or is it just a name?
11:31:57 <c_wraith> luite: at the school I went to, the only difference was a year of foreign language classes vs a year of math classes.
11:31:57 <Taneb> luite, it affects what modules from other subjects you can take to boost your degree
11:31:58 <Cale> luite: It's an organisational issue. It's which faculty/building you're in.
11:32:06 <Taneb> They also offer MMaths
11:32:18 <xplat> luite: it often affects which college it's in at the university, and, yeah, general education requirements
11:32:42 <RichyB> hayashi, that sounds like it's trying to turn -> into →
11:32:52 <hayashi> Yeah, that sort of thing
11:32:58 <hayashi> No idea at the moment how to tell it not to~
11:32:59 <mapreduce> Cale: Ok, that private/public thing will be my next argument keeping Groovy out of my day job, thank you!  It looks like they plan to fix it in either 2.0 or 3.0
11:33:10 <luite> ah thanks for all the answers :D
11:33:43 <xplat> i thought the private/public thing was never intended to actually work, it was just to enable you to compile java code as groovy?
11:33:53 <merijn> Someone working on Yi must really like UnicodeSyntax :p
11:33:58 <xplat> (presumably as a first step in porting)
11:34:04 <nand`> merijn: I got that impression :)
11:34:10 <nand`> merijn: I couldn't even figure out how to disable the silly :: glyph
11:34:22 <xplat> merijn: either that or they like showing off how powerful their syntax highlighter is
11:34:29 <Qtr> Cale: oh, sounds nice, good luck to you. You have a PhD in "Haskell" right? #dont know if that posted, my connection is poor today
11:34:54 <Cale> Qtr: I said I know Haskell well, but I only have a BMath in pure mathematics.
11:35:12 <Cale> YOUR INTERNET CONNECTION IS BAD AND YOU SHOULD FEEL BAD
11:35:22 <Cale> ;)
11:35:23 <nand`> Cale: I do feel bad :(
11:35:56 <luite> oh no another good haskeller moving to scala ;)
11:36:09 <nand`> why not frege
11:36:16 <nand`> or other Haskell subsets for the JVM
11:36:29 <luite> nand`: hehe nah i meant Cale, i missed that part of the discussion earlier
11:36:38 <Cale> luite: I wouldn't say "moving to". It's not like I've "moved to" groovy here :P
11:36:48 <Qtr> So you have any use for your education? Maybe will have in financial programming?
11:36:56 <merijn> Cale: Sure, that's what you say *now*
11:37:13 <Cale> merijn: I've seen what Scala looks like
11:37:48 <xplat> the scala at the place Cale is thinking of going is for historical reasons
11:37:53 <mcstar> i have a question that might sounds stupid
11:38:13 <Qtr> go ahead I will beat you at being stupid soon enough anyway
11:38:23 <mcstar> Qtr: oh, thanks
11:38:45 <mcstar> lets say i have a recursive data structure
11:38:47 <xplat> the company started out heavily Java, and someone introduced functional programming by using scala and achieving silver-bullety productivity on something
11:38:51 <Cale> Qtr: Mathematics shapes the way that I think about structure, so in some sense I'm using it constantly.
11:38:53 <mcstar> something like a tree
11:39:33 <merijn> So I recently saw someone use Guard to automatically reload a haskell file in GHCi everytime its saved. Anyone know of a similar program that doesn't require me to figure out how to install ruby + required dependencies or should I just suck it up?
11:39:33 <mcstar> now, if i build a tree in c for example, i use pointers, travel the nodes, update the pointers
11:39:35 <xplat> so everything has to interoperate with java and scala.  and frege is not as good at either as scala is, i think
11:39:37 <Cale> Qtr: The FRP library we wrote for that game was heavily inspired by braided/symmetric monoidal categories.
11:40:03 <mcstar> bot to expand the tree, i only have to travel from the root to a leaf once
11:40:10 <tgeeky> hm. can someone show me / lead me on to teach me how I would get this function: -- >>>  map (\n -> (invertsu3 (0) n)) [81,64,35,35,27,10,10,8]
11:40:13 <tgeeky> [[(2,5),(5,2)],[(3,3)],[(1,4),(4,1)],[(1,4),(4,1)],[(2,2)],[(0,3),(3,0)],[(0,3),(3,0)],[(1,1)]]
11:40:20 <merijn> Cale: If the game is off the table is there any chance of useful code/libraries being open sourced or is that never happening?
11:40:22 <tgeeky> to return a flat, sorted list without removing any duplicates
11:40:23 <xplat> asking 'when do you use your math degree in real life' is like asking 'when do you use your black belt in real life'
11:40:28 <Cale> Qtr: But even if I don't have the chance to pull mathematical structures off the shelf and apply them to library design, it still greatly influences the way that I think about problems.
11:40:46 <mcstar> but, if i don something similar in haskell, i first deconstruct the tree, change or add something, and build it up, on the way back
11:40:56 <Cale> merijn: It's not quite off the table, and we've always wanted to open source at least some of the code and libraries.
11:41:10 <xplat> you use a black belt every time you move and every time your heart beats.  you use your math degree every time you think or perceive something
11:41:37 <mcstar> im just wondering, if this somehow can be made more effective
11:41:44 <Qtr> Cale: ok thanks
11:42:17 <merijn> mcstar: Remember that you only need to reconstruct the part from the change to the root. All the other leaves/branches can be reused due to referential transparency
11:42:19 <luite> Cale: are you going to move to the boston/cambridge area?
11:42:37 <mcstar> merijn: yes, that i understand
11:43:16 <merijn> mcstar: Well, alternatively generate the tree lazily and don't even create it until you need it in the first place. That saves you the updating
11:43:23 <frerich_> hi
11:44:57 <mcstar> merijn: ill start with something simpler. lets imagine, i have a list, i want to change the last element, i do something like a fold, i travel the list, but i somehow want to 'zip up' the list right as i go
11:45:11 <mcstar> so, i dont build up another list as i go
11:45:24 <mcstar> i use the old one, zip it up, right behind me
11:46:03 <Qtr> How can I open sound in haskell? like play an mp3?
11:46:10 <Qtr> @hoogle mp3
11:46:10 <lambdabot> package mp3decoder
11:46:10 <lambdabot> package hmp3
11:46:15 <Qtr> @hoogle sound
11:46:15 <lambdabot> package bindings-EsounD
11:46:15 <lambdabot> package csound-expression
11:46:15 <lambdabot> package EsounD
11:47:06 <mcstar> merijn: does that sound totally lunatic?
11:47:09 <RichyB> Qtr, a terrible way to do this (that I have implemented) is to use System.Process to invoke mplayer.
11:47:26 <Saizan> mcstar: it's just impossible to not build another list for that
11:47:33 <RichyB> I really wouldn't recommend that course of action though.
11:48:12 <Saizan> mcstar: but it's good to have read a bit about zippers when thinking of such things
11:48:24 <mcstar> Saizan: yeah, it occurred to me, but as a second question, cant this procedure be made possible, with a primitive, and implementd as i said in the imperative runtime?
11:49:00 <quintessence> mcstar: it's only permissible if there are no other references to any of the lists you touch
11:49:05 <Saizan> mcstar: not without having some mechanism to make sure noone has a reference to the old list
11:49:24 <mcstar> i see
11:50:32 <Saizan> uniqueness types can be used for this, but i've never tried them
11:53:58 <cleantc_> doesn't GHC remove unnecessary "forall"s before typechecking? is there any reason that f ::   (forall b. b -> b) -> (forall a. Int -> Maybe a)   == f :: (forall b. b -> b) -> Int -> Maybe a     , while same thing fails in GADTs http://hpaste.org/72398 ?
11:55:09 <quintessence> cleantc_: it's probably a purely syntactic check on the constructor signatures
11:55:55 <quintessence> #ghc would probably know
11:56:18 <cleantc_> Thanks, I will ask them
11:56:25 <Saizan> that's arguably a bug
11:56:36 <cleantc_> yep I think so
11:59:04 <Qtr> Sigh, I dont want to code another game and not a webapp and not a compiler.
11:59:38 <MostAwesomeDude> But that's all of computer science! :3
12:00:29 <mekeor> i actually find it bad that nullary constructors (i mean constructors with arity zero… like True or False or []) have to beginning with a capital, too.
12:00:30 <earthy> qtr: storage engine?
12:00:52 <earthy> qtr: database? operating system?
12:00:54 <quintessence> qtr: SAT solver?
12:01:07 <mekeor> Qtr: org-mode reader for pandoc?
12:01:27 <RichyB> An IRC client for yi so that I can stop using ERC in Emacs?
12:01:41 <jfischoff> Qtr: blind source separation
12:01:46 * mekeor uses ERC, too =)
12:01:55 <mekeor> RichyB: is yi nice?
12:02:09 <RichyB> I don't know, it's been a few years since I tried it.
12:02:34 <RichyB> I tried using it in vi mode ages ago and got stuck because I had some vim-isms in my muscle memory and couldn't be bothered to figure out how to customise it.
12:02:47 <mcstar> a code analyzer, that helps with strictness anotations?
12:03:07 <mekeor> lol.
12:03:27 <RichyB> I might try it again. TBH, the actual solution to my issue there was to give up on vim-isms and learn vi properly, which I since have, because of real vi shipping with FreeBSD.
12:03:28 <mcstar> a ghci, that compiles to machine code on the fly?
12:03:41 <mcstar> a slime like environment for haskell-mode?
12:03:53 <RichyB> <script type="text/haskell"> for browsers?
12:03:54 <mekeor> i just got this error when i tried to open a file which contains the char π: find file: /path/to/file/Concal.hsyi-linux-x86_64: thread blocked indefinitely in an MVar operation yi-linux-x86_64: lexical error around π"]
12:03:59 <mekeor> … with yi.
12:04:24 <mcstar> mekeor: yeah, a bug, it should have provided the numerical value of pi
12:04:29 <RichyB> As both a Netscape API and an ActiveX plugin, so that it'll work in all of the Webkit browsers, all of the IE line, all of the Gecko browsers.
12:04:32 <mcstar> for debuggingn purposes
12:04:52 <RichyB> and a pure-javascript implementation too for places where installing a plugin is impossible.
12:06:39 <luite> RichyB: you can already compile a subset of haskell to javascript in the browser
12:07:02 <Qtr> earty: did RTOS in C in course. database is a good idea though problem is i hardly know how to use them.
12:07:15 <Qtr> jfischoff: whats that?
12:07:35 <Qtr> earthy: what is a storage engine? (something using concurrency would be great)
12:07:38 <RichyB> luite, not by any means that's actually fast, like an NPAPI or ActiveX plugin embedding an interpreter like ghci. :)
12:09:10 <jfischoff> Qtr: its an attempt to take a signal, like a piece of music and decompose it into the elements of signal for instance the instruments.
12:09:30 <Qtr> mcstar: to hard for me?
12:09:39 <luite> RichyB: hmm, but that has other disadvantages, even with safe haskell, i doubt it'd be secure enough for actual web use
12:10:06 <mcstar>  Qtr which one? (probably it is)
12:10:27 <Qtr> mctar: now ghci compiles to byecode? you want it to compiel to machine code, why? isnt that what ghc is for? i dont get it
12:10:51 <mcstar> Qtr: oh, well, learn common lisp, use it with sbcl+slime
12:10:57 <mcstar> after that you will know
12:11:06 <Qtr> jfischoff: interesting, i had signals and systems but never actually applied it
12:12:53 <Qtr> But writing a storage engine would be really hard?
12:12:57 <frerich_> Is there an existing function \(a, b) (c, d) -> (a+b, c+d) ? I thought I saw this somewhen but can't seem to find it in Hoogle...
12:13:02 <frerich_> err
12:13:10 <frerich_> \(a, b) (c, d) -> (a+c, b+d)
12:13:31 <mcstar> > (1,2) +(3,4)
12:13:32 <lambdabot>   (4,6)
12:13:46 <mcstar> it is in a package that i dont remember
12:13:47 <frerich_> Hm, I thought so, why doesn't that work here...
12:13:50 <Qtr> It is just that I hardly ever used a database so what do I know about adapting for new/better uses
12:13:56 <ion> @hackage NumInstances
12:13:56 <lambdabot> http://hackage.haskell.org/package/NumInstances
12:13:59 <mcstar> ah
12:14:02 <mcstar> numinstances
12:14:11 <frerich_> Aah...
12:14:15 <frerich_> mcstar, ion: Thanks!
12:14:21 <mcstar> ion: thanks :)
12:14:23 <merijn> :t join (***) $ uncurry (+)
12:14:24 <lambdabot> forall a. (Num a) => ((a, a), (a, a)) -> (a, a)
12:14:30 <Qtr> An app using concurrency, what could that be?
12:14:57 <mcstar> Qtr: write a little websever
12:15:02 <Clint> an irc server
12:15:11 <mcstar> or gopher?
12:15:18 <merijn> :t (***) `on` uncurry (+)
12:15:19 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a, Num (a b c)) => (a b c, a b c) -> (a b c, a b c) -> a (b, b) (c, c)
12:15:30 <Qtr> know what? i kind of know common lisp and dont like it compared to haskell
12:15:31 <merijn> hmm, not what I planned :p
12:16:23 <mcstar> Qtr: not a problem, i still think its a great language and i wold like to use it in practice
12:16:30 <mcstar> it has its place
12:16:53 <Taneb> What day does the Haskell Weekly News come out on?
12:17:56 <geekosaur> it floats, as far as I can tell
12:18:55 <johnw> can I use cabal to just upgrade everything I cabal installed?
12:19:41 * applicative continues to be enraged by the windbag professorial troll Uday Reddy
12:20:04 <applicative> johnw fortunately, there is no longera command to do this....
12:20:14 <johnw> that seems like something one would want to do
12:20:21 <xplat> good old yak shaving
12:20:45 <xplat> one sets out to write a script to parse sql insert statements and emit xml
12:20:57 <xplat> one actually ends up upgrading the haskell platform
12:21:18 <applicative> good work xplat
12:21:24 <mmos> I'm using the c preprocessor, and some #include. Is there a gcc option for specifying the "include directory" or the root of the include tree (so I don't have to give an absolute path to #include)?
12:21:27 <byorgey> johnw: it actually isn't.  there's no guarantee that all the latest versions of the packages you installed will be compatible.
12:21:33 <applicative> johnw: why do you want this
12:23:08 <abustin> Hi all.  I've been learning Haskell in my spare time, reading and writing small code snippets.  I have a strong JS background and I'm loving the functional freedom of Haskell.  As part of my ongoing understand I've starting trying to express Haskell as JavaScript as an exercise.  I was wondering how wrong my current assumptions of Haskell were … https://gist.github.com/3219252
12:24:36 <Qtr> @hoogle Distributed
12:24:36 <lambdabot> No results found
12:25:06 <mroman> abustin: Looks fine to me.
12:25:23 <nand`> I don't think that captures the concept of laziness
12:25:35 <Qtr> Whats wrong with uday reddy?
12:25:37 <mroman> at least the currying part.
12:25:38 <frerich_> abustin: I think the innermost function in 'Point' is not correct.
12:26:11 <luite> abustin: it's not quite correct, for example it forces both fields of the Point thing when multiplying
12:26:13 <abustin> frerich_: yes I wonder wondering what to return at that point
12:26:15 <johnw> applicative: because it's been about 2 years since I installed a bunch of stuff through cabal; I don't remember which were the "root" things I installed; and I want to get onto whatever is current
12:26:25 <abustin> frerich_: was wondering*
12:26:35 <mroman> return function(y) { return [x,y]; } would probably be better.
12:26:35 <frerich_> abustin: It should be 'var Point = function(x) { return function(y) { return [x, y]; } }'
12:27:13 <applicative> johnw: this might be trouble on account of the compiler, what version of ghc is it?
12:27:39 <applicative> johnw: I just mean a little delicate not impossible
12:27:40 <frerich_> abustin: (same with 'mult')
12:27:51 <johnw> applicative: I'm using 7.4.2
12:28:02 <abustin> frerich_: would that way I have it now be more like a monad value?
12:28:03 <johnw> back when I installed all this stuff, I think it was 6.10
12:28:20 <frerich_> abustin: In a sense more like an IO value, yes.
12:28:27 <abustin> frerich_: cool
12:28:29 <applicative> oh wait, then the old things are irrelevant.  cabal wont be confused
12:28:58 <luite> abustin: you might want to look at the code that fay spits out for this
12:29:39 <applicative> johnw: cabal will know not to link new things with whatever  there was before.  Does "ghc-pkg list" show anything as locally installed
12:29:56 <johnw> yes, it says 57 things are installed
12:30:00 <abustin> luite: yeah I watched the video on fay .. never got to the source though
12:30:06 <abustin> luite: looks interesting
12:30:12 <johnw> i've installed a few with "cabal install" since I upgraded to 7.4.2
12:30:17 <nand`> abustin: you could perhaps look at the output of uhc -tjs
12:30:18 <frerich_> abustin: One thing which the JavaScript flavor doesn't emulate correctly is lazy evaluation. In your "result = mult(foo)(bar)", 'foo' and 'bar' are (in your JavaScript version) evaluated before 'mult' is evaluated. That's not the case in Haskell though - the arguments are not evaluated before calling the function.
12:30:28 <nand`> to get a feel for how to translate Haskell to JavaScript
12:30:48 <luite> abustin: you can also look at ghcjs if you want something that also supports exceptions, threading and a whole lot more, but the code it produces is rather intimidating :p
12:30:59 <abustin> nand`: i did that but the boilerplate scared me a little
12:31:21 <applicative> johnw: interesting but have you installed things with your new ghc?
12:31:56 <applicative> oh I see you say you did
12:31:57 <johnw> yes
12:32:05 <nand`> abustin: http://bpaste.net/show/37804/
12:32:07 <nand`> haha, yeah
12:32:29 <abustin> nand`:lol
12:32:29 <nand`> at any rate, it's not a simple problem
12:32:35 <latro`a> ...wow
12:32:37 <latro`a> that's
12:32:38 <latro`a> wtf
12:32:39 <nand`> because javascript is neither lazy nor pure
12:32:42 <applicative> johnw:  so all  the things ghc-pkg list shows, are things you recently installed with your new ghc
12:32:51 <johnw> ah, ok
12:32:59 <luite> nand`: hm, purity doesn't really matter here?
12:33:18 <nand`> it doesn't no
12:33:35 <frerich_> abustin: I think a first shot at emulating lazyness in your JavaScript version would be to never pass raw values to functions but always nullary functions which return the value.
12:33:59 <nand`> that's how laziness is done in C#, using Func<Foo> to represent a lazy Foo
12:34:00 <luite> a bigger problem is that javascript is too high level for doing a lot of haskell efficiently
12:34:05 <nand`> it could work
12:34:15 <sipa> you'd need a thunk data structure which either contains a nullary function or a value
12:34:15 <applicative> johnw, the old things might still be there in ~/.cabal/  but they will be separate one way or another.
12:34:19 <luite> and it has no proper ints
12:34:22 <abustin> frerich_: ah, so functions for the Floats
12:34:29 <abustin> frerich_: ?
12:34:36 <luite> and no tail calls :(
12:34:45 <frerich_> abustin: For intsance, but also functions as arguments to 'mult'.
12:35:16 <applicative> johnw: you can delete them if you arent using the old ghc, but this might be a little delicate, now that you also have new things; I can't remember if the directory structure is the same as before
12:35:24 <sipa> abustin: also, the string is a lazy list of chars
12:35:27 <sipa> ;)
12:35:36 <abustin> frerich_: well mult does take functions in my example.  maybe i'm not following well .. never mind
12:35:36 <mroman> Fun thing about writing interpreters in haskell, they become lazy too :)
12:35:41 <frerich_> abustin: In that sense, your original shot which had the nullary function on the innermost level is correct - but for the wrong reason ;-)
12:35:55 <abustin> i gotta get more lazy
12:36:03 * applicative declares, if it's behind a pay wall, it isn't science
12:36:42 <johnw> applicative: thanks for your help
12:37:28 <applicative> johnw: good, come back if something else comes up.
12:37:30 <abustin> sipa:  haha yes, good point .. I didn't get far in my example
12:40:01 <nand`> abustin: for extra ‘fun’ convert Maybe to JavaScript
12:41:35 <abustin> nand`:   here's my first attempt …. "Cannot call method of undefined" … ;)
12:42:27 <nand`> the trick here is figuring out sum types and pattern matching on their constructors
12:44:22 <mmos> I'm using the c preprocessor, and some #include. Is there a gcc option for specifying the "include directory" or the root of the include tree (so I don't have to give an absolute path to #include)?
12:44:58 <fmap> -I ?
12:45:28 <fmap> -Iincludedir if i got you right
12:46:12 <toki78> hi
12:46:22 <toki78> can you help me with reinforcement learning ?
12:47:42 <mcstar> @faq can haskell help me with reinforcement learning ?
12:47:43 <lambdabot> The answer is: Yes! Haskell can do that.
12:47:48 <mmos> fmap: thanks. I'll check the manual and see if -I looks right
12:48:54 <toki78> ok is anyone good with Q(lambda ) ?
12:49:10 <toki78> the guys from #ai cant help
12:49:28 <toki78> I want to open a #rl channel, how can I do that ?
12:49:39 <latro`a> same way you'd join it
12:49:52 <latro`a> making it more official is a little more work, however
12:50:01 <toki78> how do i set admin privileges ?
12:50:05 <mmos> fmap: yeah -I will do it. My problem when I first checked the manual is that there were so many options I didn't know where to look. However I just discovered another place where the documentation of options is categorized, and one category is the c pre-proc. Easy to find it there.
12:50:35 <toki78> latro`a, the official way please
12:50:46 <latro`a> you go through chanserv
12:51:00 <latro`a> register it, set a founder password, etc.
12:51:08 <nobdraisentone> Is there some method to add `Maybe α' to `Seq α' (only if argument isJust)?
12:55:08 <fmap> @type \x t -> fromMaybe x ((x Data.Sequence.|>) <$> t)
12:55:09 <lambdabot> forall a. Seq.Seq a -> Maybe a -> Seq.Seq a
12:55:40 <toki78> #reinforcementlearning is already registered, but not open, is that possible ?
12:57:21 <geekosaur> toki78, a channel can be registered but abandoned, yes.  it being over a year old and apparently not used (Registered vs. Last used), you can ask in #freenode to get it released
12:58:43 <Qtr> why use operatos like (&&&), couldnt it have a name?
12:58:54 <Qtr> @hoogle (&&&)
12:58:54 <lambdabot> Control.Arrow (&&&) :: Arrow a => a b c -> a b c' -> a b (c, c')
12:58:59 <parcs`> why use operations like (+), couldn't it have a name
12:59:04 <latro`a> that one's name at least makes sense
12:59:19 <Qtr> > (head &&& tail) [1..5]
12:59:20 <lambdabot>   (1,[2,3,4,5])
13:00:29 <xplat> toki78: i can help you with reinforcement learning.  would you like positive or negative reinforcement?
13:00:46 <toki78> xplat, ??
13:01:29 <toki78> xplat, are you good with reinforcement learning ?
13:01:30 <noteventime> @hoogle Arrow arr => (b -> b' -> c) -> arr a b -> arr a b' -> arr a c
13:01:30 <lambdabot> Data.Map intersectionWith :: Ord k => (a -> b -> c) -> Map k a -> Map k b -> Map k c
13:01:30 <lambdabot> Data.Map unionWith :: Ord k => (a -> a -> a) -> Map k a -> Map k a -> Map k a
13:01:30 <lambdabot> Data.Array.IArray accum :: (IArray a e, Ix i) => (e -> e' -> e) -> a i e -> [(i, e')] -> a i e
13:01:34 <geekosaur> (I think that was intended to be a joke...)
13:01:43 <Qtr> > ((+1) &&& (*3)) 5
13:01:44 <lambdabot>   (6,15)
13:01:55 <Qtr> toki78: i think he means violence
13:03:09 <KirinDave> TwoFixt: ToQuit?
13:03:16 <TwoFixt> :O
13:03:33 <Qtr> > ((+1) &&& (*3)) 5
13:03:35 <lambdabot>   (6,15)
13:03:55 <Qtr> > ((*3) &&& (*3)) 5
13:03:56 <lambdabot>   (15,15)
13:04:03 <Qtr> > (id &&& id) 5
13:04:05 <lambdabot>   (5,5)
13:04:15 <Qtr> @src id
13:04:16 <lambdabot> id x = x
13:04:40 <Qtr> @type id
13:04:41 <lambdabot> forall a. a -> a
13:05:23 <noteventime> Why is Arrow called Arrow anyway?
13:05:47 <Ralith> what would you call it?
13:05:54 <shachaf> #haskell flies like an Arrow.
13:06:04 <noteventime> Ralith: Dunno, it looks something like a monoidal category
13:06:08 <geekosaur> noteventime, I believe because it;s a generalization of the function arrow (as in a -> b) ?
13:06:13 <Qtr> > id [1,2,3]
13:06:14 <lambdabot>   [1,2,3]
13:06:19 <noteventime> geekosaur: Wouldn't that be Category?
13:06:43 <jfischoff> > (1, 2) + (2, 3)
13:06:44 <lambdabot>   (3,5)
13:06:53 <geekosaur> that would be why there has recetnly been discussion of unifying Arrow with Category, from what I've seen here of late...
13:06:55 <jfischoff> > (1, 2) * 3
13:06:55 <lambdabot>   (3,6)
13:07:06 <shachaf> geekosaur: Huh?
13:07:14 <shachaf> Why would you do that?
13:07:15 <otters> :t ((1, 2) *)
13:07:16 <lambdabot> forall t t1. (Num t, Num t1) => (t, t1) -> (t, t1)
13:07:25 <geekosaur> maybe I;ve been seeing things.  was mixed in with a discussion of lenses yesterda
13:07:26 <latro`a> uh
13:07:28 <latro`a> wtf
13:07:31 <otters> :instances Num
13:07:31 <latro`a> that thing otters :t'd
13:07:33 <latro`a> wtf is that
13:07:34 <otters> @instances Num
13:07:36 <lambdabot> Double, Float, Int, Integer
13:07:43 <otters> latro`a: lambdabot has crazy Num instances
13:07:53 <otters> 3 is probably an instance of (Num t, Num t1) => (t, t1)
13:08:01 <latro`a> ......
13:08:07 <Qtr> So is there some linux distro where scripting is done in haskell and no dynamic langs?
13:08:13 <Qtr> hmm, idea!
13:08:14 <otters> or something like that
13:08:15 <jfischoff> otters: what package is that in?
13:08:22 <otters> @hoogle num-instances
13:08:23 <lambdabot> No results found
13:08:24 <latro`a> probably internal to lambdabot
13:08:24 <otters> huh
13:08:27 <otters> yeah
13:08:28 <Qtr> how about a haskell to bytecode interpreter?
13:08:44 <noteventime> Qtr: What do you mean by "scripting being done", things like the package manager?
13:08:46 <Qtr> so you can run haskell programs without compiling and ghci and just execute them on the fly
13:08:46 <fmap> @hackage NumInstances
13:08:47 <lambdabot> http://hackage.haskell.org/package/NumInstances
13:08:54 <geekosaur> runhaskell
13:09:05 <jfischoff> Qtr: ^
13:10:14 <xplat> yes, just use runhaskell
13:10:14 <noteventime> Qtr: If you wanted to take it reasonably far you'd have to write an init replacement and a couple of things like that
13:10:24 <xplat> or ghc -e for oneliners
13:11:04 <xplat> noteventime: initscripts can already use an interpreter, you could just use runhaskell for that :)
13:11:12 <thetallguy> yhc had a machine independent bytecode interpreter, I think.  Probably bit-rotted.
13:11:24 <mcstar> there is perl for scripts i heard
13:12:08 <mcstar> Qtr: btw, iirc you explicitely said, you dont want to write compilers
13:12:59 <xplat> the main part of making a linux distro that's scripted with haskell is writing the actual scripts
13:13:00 <noteventime> xplat: Good point
13:13:33 <stephenjudkins> linux distro scripted in haskell? say more
13:13:44 <noteventime> xplat: Though it would be somewhat limited
13:14:01 <stephenjudkins> does this exist or is it a pipe dream?
13:14:25 <noteventime> Or conduit dream, if you're of that persuation
13:14:42 <geekosaur> dream although there is NixOS
13:14:48 <geekosaur> which is not quite the same thing
13:15:13 <Qtr> ok there is runhaskell yeah then no point
13:16:11 <noteventime> I suspect that anyone who started such a project would just end up trying to rewrite the kernel in Haskell
13:16:18 <mcstar> runhaskell is ghc, just like ghci is ghc
13:16:21 <stephenjudkins> nixos is a great idea, but in practice it's flaky and broken. for linux distros it's largely the details that matter
13:16:54 <latro`a> oh god
13:16:57 <jfischoff> Qtr: Here are some things that would be useful. A cabal init addition that adds test suites and benchmark sections
13:16:57 <latro`a> writing a kernel in haskell
13:17:01 * latro`a shudders
13:17:31 <xplat> it could be nice to write the kernel in a DSL for writing kernels
13:17:35 <latro`a> hm, is gcc bigger than the kernel?
13:17:39 <jfischoff> Qtr: a smartcheck provider for test-framework
13:17:55 <thetallguy> http://web.cecs.pdx.edu/~rebekah/os/
13:17:59 <latro`a> (ghc would probably be bigger than the resulting kernel; not sure about gcc)
13:18:10 <mcstar> Linus Curry wrote a kernel is Haskell, in 2013, didnt he?
13:18:12 <jfischoff> Qtr: I can keep going ...
13:18:20 <noteventime> latro`a: It has been done at least twice
13:18:28 <latro`a> what has
13:18:30 <Qtr> latro: i just wrote a RTOS in C so operating systems isnt on top of my list
13:18:35 <noteventime> latro`a: Kernel in Haskell
13:18:39 <latro`a> huh
13:18:40 <latro`a> k
13:19:01 <Qtr> whats conduit?
13:19:25 <noteventime> One of the new iteratee-kinda-replacing libraries
13:19:37 <MostAwesomeDude> It's pretty cool.
13:20:18 <Qtr> How do you mean a smartcheck provider?
13:20:28 <Peaker> pretty controversial too
13:20:35 <Qtr> jfischoff: the cabal addons seems like a good idea
13:20:51 <xplat> allllllmost done installing
13:21:58 * hackagebot rpc-framework 0.2.0.0 - a remote procedure call framework (MatthewMirman)
13:22:00 * hackagebot split-channel 0.1.2.1 - Control.Concurrent.Chan split into sending and receiving halves. (LeonSmith)
13:23:36 <Qtr> jfischoff: more ideas?
13:23:46 <Qtr> could you elaborate on the cabal addons?
13:23:54 <jfischoff> Qtr: it would be used a lot (definitely by me) and dcoutts was game. He recommended that I should pitch a design to the cabal mailing list, I would recommend you do that also if you want to tackle it.
13:23:58 <otters> conduit or pipes?
13:23:58 <Qtr> And how would I proceed to merge my addons with cabal?
13:24:00 <otters> which is preferable
13:24:50 <jfischoff> Qtr: I would start by familarizing yourself with `cabal init` if your not already. Then I would make a cabal project and add tests and benchmarks to it.
13:26:04 <noteventime> otters: Are you trying to start a flame war? :)
13:26:37 <jfischoff> Qtr: another useful things, would be to modify the output of quickcheck failures from test-framework, so that they can be copied and pasted as is, for HUnit tests.
13:26:37 <otters> noteventime: I didn't even know those could happen here
13:26:59 <otters> The problem I have with doing anything really advanced in Haskell is that you start getting type constructors with like six arguments
13:27:37 <Qtr> otters: what are you doing?
13:28:12 <mcstar> may i recommend records?
13:28:22 <noteventime> otters: The way I've understood it it's something like Pipes being nicer and more minimal, but not doing any/as much resource management, making it slightly more complicated to use for IO with complex resource management (you need to use an orthogonal system such as regions).
13:28:31 <otters> I see
13:28:34 <latro`a> records help a lot, yeah
13:28:42 <latro`a> and the sugar for "updating" records is great
13:28:51 <mcstar> rec{field=newval}
13:29:35 <mcstar> i wrote a ternary search tree today in haskell and ocaml
13:29:51 <mcstar> the haskell one was a bit faster
13:30:06 <mcstar> (after i solved the ocaml stack overflow issue)
13:30:12 <otters> ach, ocaml
13:30:15 <mcstar> (with help from #ocaml)
13:30:49 <mcstar> data TST = Empty | Node { nodeVal :: !Char, isEnd :: !Bool, loNode :: !TST, eqNode :: !TST, hiNode :: !TST }
13:31:19 <Qtr> i did ternary search in discrete math
13:32:27 <Qtr> #ocaml doesnt have the same strong foundation as haskell?
13:32:36 <Qtr> the language not nthe channel :)
13:32:45 <mcstar> why not?
13:33:09 <mcstar> it is similar, but it is strict be default, has more quirks overall, and isnt developed in the pace of haskell
13:33:24 <mcstar> and there are some things that are mutable
13:33:46 <mcstar> and you cant see the code from the 'let's
13:34:35 <mcstar> be->by
13:37:36 <xplat> @hoogle ByteString -> Text
13:37:37 <lambdabot> Data.Text.Encoding decodeASCII :: ByteString -> Text
13:37:37 <lambdabot> Data.Text.Lazy.Encoding decodeASCII :: ByteString -> Text
13:37:37 <lambdabot> Data.Text.Encoding decodeUtf16BE :: ByteString -> Text
13:43:34 <parcs`> is the way that Enum gets auto-derived precisely defined in the haskell report?
13:44:13 <MostAwesomeDude> parcs`: I don't think so, but it's pretty simple.
13:44:58 <MostAwesomeDude> parcs`: f9049c69
13:45:00 <MostAwesomeDude> Er.
13:45:05 <MostAwesomeDude> http://www.haskell.org/onlinereport/haskell2010/haskellch11.html#x18-18400011.2
13:45:09 <MostAwesomeDude> parcs`: ^^ Nevermind, yes it is.
13:45:50 <parcs`> right, thanks
13:46:30 <Qtr> jfischoff: i actually made a haskell program to do some of the cabal init stuff for me. didnt know about cabal init before. great addition
13:47:29 <ParahSailin_> anyone here a wxhaskell developer?
13:47:40 <jfischoff> Qtr: Yeah, it will also throw in your dependencies if you have code already written. I would be partial to a mungerer that could keep them updated.
13:52:00 * hackagebot couchdb-conduit 0.10.2 - Couch DB client library using http-conduit and aeson (AlexanderDorofeev)
14:00:59 <Qtr> so i played a lil with cabal init
14:02:54 <jfischoff> Qtr: cool
14:03:05 <Qtr> damn it i should go to bed
14:03:14 <jfischoff> Qtr: where are you?
14:03:17 <Qtr> and breaking bad finished loading
14:03:22 <Qtr> where?
14:03:29 <jfischoff> yeah
14:03:37 <Qtr> Sweden, umeå
14:03:53 <jfischoff> ah
14:12:35 <Qtr> so basically how should it add test suites?
14:12:45 <Qtr> and benchmark sections?
14:13:15 <noteventime> I'm not the only Swedish Haskell user not in Gothenburg \o/
14:14:11 <donri> I'm in Ringarum, imagine that
14:14:40 <Qtr> cabal is still using darcs?
14:14:50 <noteventime> Qtr: http://www.haskell.org/haskellwiki/How_to_write_a_Haskell_program#Add_some_automated_testing:_QuickCheck ?
14:15:08 <donri> cabal is on github IIRC, duno if it's just a mirror or not
14:16:01 <noteventime> Qtr: Never mind, I thought it had a section of combining it with Cabal, but it was on combining it with Darcs
14:16:04 <donri> Qtr: https://github.com/haskell/cabal/
14:16:08 <donri> seems to be the official repo
14:16:42 <jfischoff> Qtr: have you added test suites and benchmarks manually to a cabal file yet?
14:17:29 <Qtr> well actually no i forgot that. ill do that tomorrow, now i go to bed.
14:18:12 <donri> Qtr: did you read http://www.haskell.org/cabal/users-guide/developing-packages.html#test-suites
14:19:16 <Qtr> doing now
14:19:21 <Qtr> gnight
14:24:08 <hy[er]> is there a way to search hoogle by what each of the libraries import?
14:38:37 <Dustin> hello?
14:41:10 <hiptobecubic> Dustin, hi
14:41:43 <Dustin> Is this a bot or a real person?
14:42:14 <hiptobecubic> Dustin, there are entire competitions about answering that question.
14:42:32 <nand`> turing would like to have a word
14:43:42 <hpc> is this the real life?
14:44:05 <ahkurtz> no, but it is forever
14:45:09 <jfischoff> Is this just fantasy?
14:47:05 * hackagebot rpc-framework 0.3.0.0 - a remote procedure call framework (MatthewMirman)
14:48:01 <earthy> caught in a landslide...
14:49:10 <Dustin> Hello again? (I think it froze)
14:49:36 <confusing> Dustin: hello, we are still here
14:50:11 <Dustin> Ok, I'll cut to the chase. The web version of Haskell doesn't seem to work the same way as the version I downloaded
14:50:34 <Saizan> how so?
14:50:47 * BMeph hums, no escape from reality....
14:51:04 <confusing> you mean tryhaskell? yes, there's going to be some differences
14:51:12 <Dustin> There are many things which seem to work on the web version that don't work on the downloaded GHCi
14:52:28 <Saizan> oh well, there can be many reasons for that, they are both based around ghc's internals but they are not the same
14:52:41 <Dustin> I am a PhD student studying Haskell and functional programming from an academic perspective.
14:53:15 <hpc> Dustin: in general, tryhaskell /= ghci /= ghc /= lambdabot
14:53:16 <Saizan> pick a book/tutorial and stick to ghci :)
14:53:18 <hpc> what are you trying to do?
14:53:34 <confusing> Dustin: i bet that your ghci doesn't import all the modules that tryhaskell imports. which functions in particular give you trouble? you can use hayoo to find which module offers a function
14:53:38 <confusing> @where hayoo
14:53:38 <lambdabot> http://holumbus.fh-wedel.de/hayoo/hayoo.html
14:53:54 <mekeor> Is (("a"++) . (++"z")) or ((++"z") . ("a"++)) more efficient?
14:53:57 <c_wraith> doesn't tryhaskell support graphics output? ghci just isn't going to do that.
14:54:26 <Dustin> Confusing, yeah, that's probably the problem
14:54:40 <c_wraith> mekeor: if either is better after the optimizer is done, it'll be the one that appends to the end of the list first
14:54:55 <latro`a> mekeor--(++) with long first argument is slow, so the former should be just a hair faster, I think
14:56:25 <madjestic> it is, e.g. via gloss
14:56:28 <mekeor> c_wraith: so the latter.
14:56:37 <mekeor> i mean, the former.
14:56:42 <flourat> is there a way to 'rename' a set of class constraint? i.e. (Serialize a, Typeable a) => SerializeAndTypeable a
14:56:45 <c_wraith> mekeor: former, yes
14:56:48 <mekeor> i mean, ((++"z") . ("a"++)). :D
14:57:00 <c_wraith> mekeor: no, that appends to the front before the back
14:57:11 <mekeor> oh, right – omg :D
14:57:23 <mekeor> (("a"++) . (++"z")) …
14:57:31 * mekeor reads (.) as "after".
14:58:02 <c_wraith> read it as "of" and you end up in a better place :)
14:59:48 <flourat> (e.g. if i'm using the class constraints in a bunch of places and don't want to keep typing them out)
15:03:24 <BMeph> flourat: not yet. ;)
15:03:47 * nand` reads (.) as “after” too
15:03:54 <nand`> that still works with your example
15:03:58 <nand`> “prepend a after appending z”
15:04:08 <mekeor> *nod*.
15:05:55 <flourat> BMeph: : ) something in the works? and would {-# LANGUAGE CPP #-} be the only answer or is it too gross
15:07:02 <nand`> flourat: -XConstraintKinds allows type SerializeAndTypable a => (Serialize a, Typeable a)
15:07:26 <nand`> err, ‘=’ not ‘=>’
15:07:56 <nand`> see http://www.haskell.org/ghc/docs/7.4.1/html/users_guide/constraint-kind.html
15:08:27 <flourat> nand`: awesome! thanks : )
15:18:04 <timthelion> I remember seeing this function somewhere: splitBy :: (a->Bool) -> [a] ->[[a]] such that splitBy (\x->1==x) [2,1,3,4,1] = [[2],[1,3,4],[1]].  Now I cannot find it :(  Where is it?  Did I simply mistakenly remember the name?
15:18:19 <dmwit> ?hackage split
15:18:19 <lambdabot> http://hackage.haskell.org/package/split
15:19:10 <geekosaur> :t groupBy
15:19:11 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [[a]]
15:19:23 <timthelion> dmwit: thanks, I guess it's splitWhen
15:19:49 <timthelion> geekosaur: why (a->a->Bool)? and not (a->Bool)?
15:20:04 <geekosaur> it's not quite the same thing (I wasn't sure)
15:20:41 <geekosaur> splitBy presumably splits at a single element matching a predicate; groupBy splits based on how consecutive elements compare accoridng to a predicate
15:20:52 <geekosaur> and group is groupBy (==)
15:21:12 <geekosaur> @src group -- or I got that backwards?
15:21:12 <lambdabot> Source not found.
15:21:15 <geekosaur> bah
15:21:24 <timthelion> Unfortunately the splitWhen drops the elements which are matched, which is not what I want.
15:22:04 <coppro> timthelion: you want to split at each element matching a predicate?
15:22:19 <coppro> > groupBy (/= 1) [2, 1, 3, 4, 1]
15:22:24 <lambdabot>   Couldn't match expected type `a -> GHC.Bool.Bool'
15:22:25 <lambdabot>         against inferred ...
15:22:33 <coppro> hmm
15:22:37 <coppro> > groupBy (const . (/= 1)) [2, 1, 3, 4, 1]
15:22:40 <lambdabot>   [[2,1,3,4,1]]
15:22:46 <coppro> > groupBy (flip const . (/= 1)) [2, 1, 3, 4, 1]
15:22:47 <lambdabot>   No instance for (GHC.Num.Num GHC.Bool.Bool)
15:22:47 <lambdabot>    arising from the literal `1'...
15:22:52 <coppro> bah
15:23:00 * coppro is too lazy to continue
15:23:47 <geekosaur> funny, I started thinking along those lines too, decided it wasn;t worth the effort
15:23:57 <parcs`> > groupBy (const (/= 1)) [2,1,3,4,1,1]
15:23:58 <lambdabot>   [[2],[1,3,4],[1],[1]]
15:24:00 <latro`a> um
15:24:05 <evancz> hi! Is it impossible to get download stats on a project?
15:24:06 <latro`a> if you read the documentation for splitWhen
15:24:07 <gertc> http://stackoverflow.com/questions/11731941/haskell-facebook-exceptions
15:24:19 <latro`a> you can see what it is equivalent to
15:24:22 * edwardk waves hello.
15:24:22 <latro`a> and hence what you want to remove
15:24:23 <confusing> timthelion: you could roll your own using span or break
15:24:26 <evancz> from Hackage in specific
15:24:52 <latro`a> splitWhen = split . dropDelims . whenElt, sounsd like you really just need to replace dropDelims
15:25:07 <timthelion> confusing: it looks like parcs` has already solved this :)
15:25:13 <latro`a> with something that picks either the first or second list to put the delim in
15:25:33 <latro`a> oh
15:25:34 <latro`a> nm
15:25:40 <latro`a> groupBy with const, cute
15:26:10 <dmwit> I always squint at code that hands groupBy something that isn't an equivalence relation.
15:26:16 <dmwit> Asking for trouble if you ask me.
15:26:17 <parcs`> wait what did i solve?
15:26:21 <edwardk> dmwit: more lenses going up in a sec ;)
15:26:26 <dmwit> Nice!
15:27:13 <edwardk> got isomorphisms to work directly as lenses
15:27:19 <edwardk> it really cleans code up a lot
15:27:53 <edwardk> anyOf text (=='c') $ packed ^$ "hello"
15:28:01 <edwardk> text :: Simple Iso String Text
15:28:24 <edwardk> text = from packed . traverse
15:28:33 <edwardk> er
15:28:36 <edwardk> er
15:28:38 <MagneticDuck> so.. I'm trying to set up EclipseFP
15:28:45 <edwardk> text :: Simple Traversal Text Char
15:28:51 <edwardk> packed :: Simple Iso String Text
15:29:08 <edwardk> "hello"^.packed gives the text, from packed gives the string back
15:29:53 <MagneticDuck> I need to somehow get a BuildWrapper and Scion Browser executable onto my machine
15:29:56 <MagneticDuck> which is Linux
15:30:08 <MagneticDuck> so wait one sec, when you install a cabal, where's the executable if there is one?
15:30:10 <parcs`> edwardk: what does Iso look like?
15:30:40 <edwardk> type Iso a b c d = forall k f. (Isomorphic k, Functor f) => k (c -> f d) (a -> f b)
15:30:51 <edwardk> k gets instantiated to (->) to use it as a Lens
15:30:52 <dmwit> whoa
15:30:57 <dmwit> That needs a bit of parsing.
15:31:13 <parcs`> edwardk: what else is an instance of Isomorphic?
15:31:20 <dmwit> MagneticDuck: When you install the package cabal-install, the executable is cabal.
15:31:26 <edwardk> parcs: data Isomorphism a b = Isomorphism (a -> b) (b -> a)
15:31:41 <edwardk> from :: Isomorphic k => Isomorphism a b -> k b a
15:31:41 <parcs`> ah, cool
15:31:43 <MagneticDuck> dmwit: Where is it?
15:31:44 <latro`a> I think MagneticDuck means where does the executable for the *package* go
15:31:47 <parcs`> that's really awesome!
15:31:49 <MagneticDuck> yes
15:31:50 <latro`a> which is, by default, in ~/.cabal
15:31:54 <MagneticDuck> okay
15:32:01 <latro`a> (which I think cabal actually prints on completion)
15:32:02 <edwardk> if you need to put an isomorphism in a container use 'Isomorphism'
15:32:09 <MagneticDuck> alright, ty
15:32:09 <edwardk> and then use 'via' to make it live as a function again
15:32:09 * hackagebot lens 1.2 - Lenses, Folds and Traversals (EdwardKmett)
15:32:19 <latro`a> precisely, ~/.cabal/bin, iirc
15:32:22 <edwardk> via :: Isomorphic k => Isomorphism a b -> k a b
15:32:48 <Digit> does anyone here use yi?  i tried installing it through cabal (not something i use often at all), and got an error (or more, idk)  http://pastebin.ca/2176270 ... not sure if this is something i can remedy from within cabal, or.... ....  thnx for any tips n help. :)
15:33:06 <edwardk> parcs: took me quite a while to work out, but now many of the combinators that convert to and from lenses themselves are build using isomorphic, so you can run them backwards
15:33:50 <edwardk> e.g. adjust :: Setter a b c d -> (c -> d) -> a -> b     has been generalized to
15:33:56 <latro`a> Digit, my hackish-as-hell solution suggests you print the output to a file and then search for haskell-src-exts
15:33:59 <latro`a> erm
15:34:02 <latro`a> s/solution/idea
15:34:08 <edwardk> adjust :: Isomorphic k => k (Setter a b c d) ((c -> d) -> a -> b)
15:34:28 <edwardk> so you can use "from adjust fmap" to make a setter if you want
15:34:40 <latro`a> (though if someone else has seen haskell-src-exts fail to install, they may be able to help you more)
15:35:23 <edwardk> bytes = from packedBytes . traverse -- to traverse the bytes of a bytestring is kind of nice, it really reduces the amount of pressure to make paired up names for things
15:35:39 <MagneticDuck> I'm trying to install scion
15:35:46 <edwardk> and because you can use it directly as a function i have no reason not to make anything an isomorphism that i can
15:35:48 <MagneticDuck> cabal install scion doesn't work
15:35:54 <MagneticDuck> should I paste the error?
15:35:58 <MagneticDuck> something about dependencies
15:36:12 <Digit> thnx latro`a... i'll tee it out n have a look
15:36:25 <geekosaur> MagneticDuck, the cabal/hackage version is out of date, doesn;t work with any ghc7
15:36:33 <geekosaur> install it from github
15:36:34 <Digit> if i still fail at finding a solution, i'll come back here demanding my money back.
15:36:34 <edwardk> class Isomorphic k where isomorphic :: (a -> b) -> (b -> a) -> k a b; instance Isomorphic (->) where isomorphic = const; instance Isomorphic Isomorphism where isomorphic = Isomorphism
15:36:44 <edwardk> disturbingly easy to define
15:36:59 <confusing> buffalo buffalo buffalo
15:37:03 <geekosaur> if I read the commit messages on the repo correctly, it supports through at least 7.4.1
15:37:05 <edwardk> and its even haskell 98 until you want to pass around isomorphisms as polymorphic funtions
15:37:35 <edwardk> i refuse to buffalo buffalo buffalo. i'm no where near buffalo
15:37:55 <parcs`> edwardk: so you can use adjust to perform use apply setter _and_ create a setter?
15:38:01 <edwardk> parcs`: yep
15:38:02 <DrSyzygy> edwardk: But would you buffalo buffalo as long as they're not buffalo buffalo?
15:38:17 <edwardk> DrSyzygy: i'd definitely buffalo boston buffalo
15:38:22 <parcs`> edwardk: hah, awesome
15:38:48 <Digit> http://pastebin.ca/2176271 much shorter output than first time around (which was so long i couldnt get it all to paste).  still not sure how to get past this.
15:38:56 <edwardk> i'd buffalo buffalo to get them out of the road, but be careful with your interpretation, because buffalo'd buffalo isn't actually as tasty as it sounds.
15:39:01 <Digit> i dont even know if "yi" is worth the effort.
15:39:27 <monochrom> interesting, you need happy
15:39:31 <edwardk> parcs`: i can _almost_ make it so you can define a fold using 'from foldrOf' it doesn't quite work though ;)
15:39:40 <parcs`> edwardk: can Gettings be composed to be able to fetch multiple fields at once? (like &&&)
15:39:43 <latro`a> happy is failing to install
15:39:55 <edwardk> parcs`: you can use to (..  &&&  ..)
15:39:57 <monochrom> happy is not automatically installed
15:40:15 <edwardk> the problem what do you do when its a Fold?
15:40:21 <edwardk> is it a cross product?
15:40:36 <edwardk> or are you doing each reduction separately?
15:41:05 <latro`a> Digit, try cabal install happy then try installing yi again
15:41:09 <latro`a> (if it works)
15:41:38 <edwardk> parcs`: there is a bothLenses combinator in 1.2, but it only works on full lenses.
15:42:40 <mm_freak> edwardk: would you recommend the 'lens' library for production?
15:42:58 <edwardk> mm_freak: i'm more and more happy with it
15:43:07 <edwardk> i like it far better than any of the other lens libraries now
15:43:13 <edwardk> but i'm a perfectionist ;)
15:43:15 <mm_freak> would you recommend it unconditionally over data-lens…  or are there cases where data-lens is really more suitable?
15:43:19 <edwardk> at least until i get bored
15:43:29 <edwardk> i'd recommend it unconditionally over data-lens
15:43:37 <mm_freak> ok, thanks =)
15:44:09 <edwardk> i'm going to try to get the snap guys to switch over at hac phi, we'll see how well that floats ;)
15:44:43 <edwardk> so pretty much by the end of hac phi i expect the design of lens will be more or less set in stone
15:44:56 <mm_freak> that was my next question =)
15:45:02 <confusing> or glass, rather
15:45:04 <mm_freak> not a question actually, but more like a note
15:45:10 <edwardk> since one i have users i tend not to let the design fluctuate wildly
15:45:33 <mm_freak> currently i'm still with data-lens, mostly because i'm used to it =)
15:45:50 <edwardk> 1.0 -> 1.1 was breaking up the Control.Lens module into something more sane. 1.1 -> 1.2 was abusing the power of isomorphism lenses _everywhere_
15:45:59 <edwardk> sure
15:46:38 <edwardk> i figure i need to make the case for people to convert and i still haven't done the full writeup on how to derive these lenses, etc. as a natural consequence of the functor laws.
15:46:59 <osa1> this haskell.vim doesn't change anythink on my vim https://raw.github.com/urso/dotrc/master/vim/syntax/haskell.vim do I need to do something other than copying it to .vim/syntax/haskell.vim ?
15:47:10 <jfischoff> is the Isomorphic class new?
15:47:13 <edwardk> yeah
15:47:21 <edwardk> lens 1.2
15:47:33 <edwardk> i'd build something like it before as a one-off trick
15:47:40 <edwardk> but this is the first time i've used it in anger
15:47:45 <jfischoff> haha
15:48:10 <edwardk> i used it to answer a stack overflow question or something
15:48:11 <edwardk> ;)
15:48:14 * jfischoff grabs len 1.2 instead of waiting for the docs to load
15:48:35 <Digit> couldnt cabal install happy, still complains about haskell-src-exts-1.13.3 failed during the configure step. The exception was: ExitFailure 1
15:49:22 <Digit> i knew there was a reason i rarely touch cabal
15:49:23 <mm_freak> i wonder what still depends on comonad 1 here
15:50:05 <edwardk> jfischoff: example: ghci> 50000^.from modifiedJulianDay.gregorian.year      ==> 1995
15:50:25 <edwardk> ghci> 50000^.from modifiedJulianDay.julianYearAndDay.to (view year &&& view day)    ==> (1995,270)
15:50:36 <jfischoff> ah
15:50:39 <jfischoff> cool
15:50:47 <edwardk> modifiedJulianDay is an isomorphism
15:51:22 <confusing> Digit: try making cabal more verbose and re-running. if you get stuck, put cabal's output on hpaste and ask in here
15:51:29 <mm_freak> i just had a minor epiphany…  some wires form a comonad
15:51:39 <edwardk> mm_freak: wire?
15:51:47 <edwardk> oh
15:51:49 <confusing> edwardk: where do those functions year, gregorian and so on live?
15:51:51 <mm_freak> edwardk: netwire wires
15:52:02 <edwardk> confusing: ghci> :m + Data.Time.Calendar.Lens Control.Lens
15:52:17 <edwardk> most are in Data.Time.Calendar.Lens
15:52:22 <confusing> ah, so your package
15:52:25 <edwardk> yeah
15:52:47 <mm_freak> netwire 4 already depends on two edwardk packages, and likely more will follow =)
15:53:12 <edwardk> =)
15:53:16 <hpaste> digit pasted “cabal -v install yi fails” at http://hpaste.org/72405
15:53:22 <confusing> do you have any critique of the time-lens package that you are remedying with your Calendar.Lens implementation?
15:53:30 <edwardk> i never even saw it
15:54:03 <confusing> allright :)
15:54:21 <edwardk> confusing: in part its using data-lens, in another part it uses triples for gregorian dates, etc. so you have no safety
15:54:26 <mm_freak> edwardk: would you have been able to come up with all those packages without understanding category theory so well?
15:54:30 <confusing> just saw it the other day and it looked useful (more than the basic Data.Time stuff). haven't used it myself yet
15:54:54 <parcs`> edwardk: you said you want to avoid name clashes but you have 'set' in there
15:54:55 <edwardk> i don't understand category theory for squat, i mostly understand a few bits and pieces that apply to haskell and i understand haskell really really well now ;)
15:55:05 <Digit> trying happy with verbose output too....
15:55:07 <edwardk> parcs`: set doesn't collide with put/get
15:55:24 <parcs`> oh right, put
15:56:54 <mm_freak> edwardk: i'm glad that i understand haskell so well, because i can understand your libraries by looking at the type signatures…  otherwise i'd be pretty much lost =)
15:57:03 <edwardk> =)
15:57:17 <hpaste> digit pasted “cabal -v install happy fails too” at http://hpaste.org/72406
15:57:26 <alpounet> yeah, having a pure deep understand of kan extensions from a category theoretic point of view only is... hmm, hard, i think
15:57:30 <edwardk> run through the haddocks of lens 1.2 for a minute and let me know what you think
15:57:34 <alpounet> understanding*
15:57:55 <mm_freak> edwardk: who?
15:57:56 <edwardk> i'm more than willing to fill in gaps in the documentation
15:58:11 <edwardk> mm_freak: i was aiming that mostly at you, but i'll take anyone who wants to shoot me advice ;)
15:59:05 * Digit suspects he wouldnt have these problems if he tried this on his gentoo box, instead of his debian sid.... and gives that a try
15:59:07 <mm_freak> edwardk: i'll certainly do that, but right now i want to focus on releasing netwire 4
15:59:14 <edwardk> mm_freak: np
15:59:18 <Doctor_DOOM> Python is better tha haskell fucking faggots.
15:59:26 <confusing> @where ops
15:59:27 <lambdabot> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
15:59:31 <Doctor_DOOM> Functional for homos.
15:59:34 --- mode: ChanServ set +o edwardk
15:59:39 --- mode: edwardk set +b *!~Doctor_DO@02df1fa2.bb.sky.com
15:59:39 --- kick: Doctor_DOOM was kicked by edwardk (Your behavior is not conducive to the desired environment.)
15:59:42 <copumpkin> lol
15:59:46 <luite> hehe
16:00:00 <copumpkin> some of these trolls are so good at trolling
16:00:08 <confusing> Digit: could you run /home/digit/.cabal/bin/happy? i'm wondering if cabal failed to build the binary or if it is present
16:00:09 <copumpkin> really subtle time-wasters
16:00:18 <mm_freak> #haskell can't be trolled in traditional ways =)
16:00:34 <mm_freak> you need to be smart to troll a smart channel =)
16:00:53 --- mode: edwardk set -o edwardk
16:01:56 <edwardk> i think the instance that made me happiest was giving you the ability to traverse an array
16:01:57 <confusing> mm_freak: for wasting a lot of time, it seems to be sufficient to ask what what referential transparency "really is" =)
16:01:59 <Cale> @keal
16:01:59 <lambdabot> are you saying i am MegaMonad?
16:02:09 <Cale> LOL
16:02:11 <edwardk> er s/instance/method
16:02:56 <MostAwesomeDude> For somebody so opinionated, he wasn't in #python. Curious. :3
16:03:02 <mm_freak> confusing: exactly =)
16:07:17 <mekeor> monads are pure… – how does indeterminism work actually, in haskell? how does IO work, e.g.?
16:08:13 <ozataman> is there any way to get cabal modular solver to consider reinstalls of any necessary packages to satisfy dependencies? Every now and then over the course of a project, it hits a wall and then it's fine again once I remove/reinstall the cabal-dev sandbox...
16:08:36 <geekosaur> mekeor, http://www.haskell.org/haskellwiki/IO_inside might be of interest
16:09:32 <mekeor> geekosaur: hm, okay.
16:10:43 <edwardk> confusing: hrmm, i like roman's design a little better in some areas and a little less in others. adopting the parts i like ;)
16:10:45 <jrajav> confusing: So what is it? ;D
16:11:23 <Cale> mekeor: You can have pure descriptions of impure stuff
16:11:31 <mmirman> rpc-framework now can send functions across the wire, and gc them when they are no longer needed - it is now potentially usable
16:11:39 <Digit> heh.  screw debian.  gentoo even has yi in portage.  no need for cabal.  :)  thnx for the help anyways.  always good to stretch the ol' neuropathways.   ... but wow, what a serious buttload of dependancies!
16:11:49 <Cale> mekeor: In the case of IO, you manipulate pure values which describe I/O to be done, and main becomes one of these descriptions.
16:12:31 <mekeor> Cale: ah!.. okay..
16:14:27 <mm_freak> Digit: even in arch and gentoo, where hackage packages are available, i tend to prefer 'cabal'
16:14:37 <mm_freak> i only install GHC and cabal-install through my package manager
16:16:36 <nand`> I tend to prefer my packages through the package manager; I don't even have cabal-install
16:18:37 <nand`> @protontorpedo
16:18:37 <lambdabot> how abut vs APL
16:18:38 <confusing> edwardk is assimilating ... i wonder if he wears a seven of nine outfit too
16:18:57 <edwardk> you don't want to see me in a 7 of 9 outfit
16:19:16 <edwardk> it'd be more of a 13 or 14 of 9
16:19:16 <mekeor> nand`: don't you miss some packages sometimes?
16:19:29 <nand`> mekeor: can't say that I have
16:19:47 <mekeor> cool.
16:19:55 <nand`> mekeor: I sometimes have to make my own, but that's for packages only available via git or darcs (as opposed to hackage)
16:20:33 <confusing> jrajav: i have no idea, i haven't followed that discussion :) i didn't get what they were trying to establish *shrug*
16:20:36 <Digit> i've had more joy outside of cabal, so i try to avoid it if i can.   still, either way, yi is wanting me to get my haskell stuff up'd to testing.  so... that's a big chunk of compiling to happen while i sleep, since the likes of ghc is included in there.  :)  god bless keywords.
16:22:22 <bytter> o/
16:24:02 <nand`> I tend to wear a 9/9 outfit
16:27:11 * hackagebot cypher 0.8.1 - Haskell bindings for the neo4j "cypher" query language (SamAnklesaria)
16:29:07 <latro`a> assuming the case statement is pretty small, is it preferred to case on a pair, or have two cases on its members?
16:29:56 <hpaste> latro`a pasted “pair case” at http://hpaste.org/72408
16:30:01 <nand`> if you need to test for every product I'd do the former
16:30:03 <latro`a> ^example for context
16:30:21 <nand`> but if it introduces redundancy, I'd do the latter
16:30:54 <mm_freak> i almost always pattern-match on the pair
16:31:26 <nand`> note that nesting in this case means you need to add ‘retry’ multiple times too
16:31:49 <nand`> so this is the more succint of the two
16:32:10 <nand`> succinct*
16:32:47 <mm_freak> latro`a: to answer your question, use the style that is most readable
16:33:02 <hpaste> mekeor annotated “pair case” with “pair case (fun annotation)” at http://hpaste.org/72408#a72410
16:33:26 <MostAwesomeDude> edwardk: So, I like your punchline.
16:33:28 <latro`a> cute
16:33:41 <nand`> mekeor: I'd say it is
16:33:48 <MostAwesomeDude> (%%~) = id
16:33:50 <MostAwesomeDude> Hilarious.
16:34:04 <edwardk> =)
16:34:37 <nand`> (%%~)? What's that from?
16:34:41 <MostAwesomeDude> edwardk: Anyway, your docs are solid, although I'm struggling to figure out exactly what I'd do with these. In particular, the new generalized focus function seems really hard to grasp, even though I'm sure it's gonna be obvious.
16:34:46 <latro`a> actually
16:35:01 <edwardk> MostAwesomeDude: use it like the old focus
16:35:03 <latro`a> mekeor--that makes me want to flip the order of the fields now
16:35:17 <edwardk> then when you get a handle on traversal the generalization will kick in
16:35:27 <edwardk> nand`: Control.Lens in lens 1.2
16:35:34 <MostAwesomeDude> edwardk: I'd usually have it in do blocks, with something like: focus someOfMyStateLens $ do
16:35:50 <edwardk> *nods*
16:35:55 <edwardk> that should still work
16:36:00 <MostAwesomeDude> And so now I could do this in things that are not necessarily MonadState.
16:36:08 <edwardk> it just now works regardless of if you use it on ReaderT, or either version of StateT
16:36:18 <edwardk> without using different imports
16:36:31 <MostAwesomeDude> Waaait. So, like, this replaces the "local" function in Reader?
16:36:37 <edwardk> and it can to accumulate a monoidal result if you use it on traversal instead of fold
16:36:42 <edwardk> yes =)
16:37:08 <edwardk> it only works on the outermost ReaderT, but it can change the type
16:37:09 <MostAwesomeDude> Oh man.
16:37:19 <MostAwesomeDude> Also, I dig the combinators. "to" is adorable.
16:37:23 <edwardk> =)
16:37:31 <edwardk> i spent a whole day hunting for prepositions i could use
16:37:54 <edwardk> did you see from yet?
16:39:03 <nand`> hackage doc for 1.2 is not up yet, does it differ a huge amount from 1.1.1?
16:39:08 <edwardk> yeah
16:39:21 <edwardk> the (%%~) combinator is the same
16:39:49 <latro`a> oh wait, mekeor, that breaks in the retry case
16:39:56 <latro`a> forgot about that
16:40:35 <mekeor> okay...
16:40:56 <latro`a> you get Right $ flip (Move ind) word $ retry, which doesn't typecheck
16:41:25 <MostAwesomeDude> Hm. You replaced Traversable entirely?
16:41:59 <edwardk> yes
16:42:07 <edwardk> basically you can use it to traverse more or less anything
16:42:12 <edwardk> like say, Data.Text
16:42:37 <edwardk> > anyOf text (=='o') $ "hello"^.packed
16:42:38 <lambdabot>   Not in scope: `anyOf'Not in scope: `packed'Not in scope: `^.'
16:42:42 <edwardk> er
16:42:50 <edwardk> not on lambdabot obviously =)
16:42:55 <MostAwesomeDude> Not yet, at least.
16:43:29 <edwardk> so you can pass anyOf, foldMapOf, etc. any Fold or Traversal or Getter or Lens or Iso and it just owrks
16:43:54 <edwardk> and they pick up the minimum number of requirements
16:44:15 <edwardk> so, say, sumOf _2 doesn't require Num, because its just wrapping and unwrapping with the Monoid
16:44:42 <MostAwesomeDude> Ah, so you'd have to stick Sum or Product in there if you wanted that particular monoid?
16:44:47 <edwardk> no
16:45:27 <edwardk> ighci> sumOf traverse [1,2,3]
16:45:27 <edwardk> 6
16:45:32 <edwardk> ghci> sumOf _2 (0,"hello")
16:45:33 <edwardk> "hello"
16:46:16 <MostAwesomeDude> Huh.
16:46:18 <edwardk> When you use traverseOf_, if you pass it a Lens it only requires you to use a Functor.
16:46:33 <edwardk> its a trick based on how specific the argument type is. the constraint comes from the lens itself
16:46:37 <edwardk> not from the combinator
16:46:47 <nand`> is there some TH magic, extension or other wizardry that will give record field names their van laarhoven definitions automagically?
16:46:55 <edwardk> nand`: yes
16:47:02 <edwardk> Control.Lens.TH.makeLenses ''Foo
16:47:08 <nand`> neat
16:47:13 <MostAwesomeDude> Very cool stuff.
16:47:28 <edwardk> i'll probably enhance it to actually make the isomorphism lens for newtypes
16:47:38 <edwardk> i forgot to do that before pushing 1.2
16:47:45 <RylandAlmanza> Anyone tried to compile jhc? I keep getting "Ambiguous module name `Prelude':       it was found in multiple packages: base haskell98-2.0.0.1" when I run make, and I can't seem to fix it
16:48:12 <RylandAlmanza> I'm trying to use jhc as I would like to try out some android development with haskell
16:48:38 <edwardk> RylandAlmanza: basically you probably need to edit the package description in cabal and rip out haskell98 and patch up some crufty old references
16:50:21 <RylandAlmanza> edwardk: It's not a cabal package (Unless I'm misunderstanding what that is.) I just downloaded and extracted the tarbal from here: http://repetae.net/dist/jhc-0.8.0.tar.gz and then I ran "./configure && make"
16:50:22 <edwardk> I may pull Control.Isomorphic out into a tiny package
16:50:37 <edwardk> ghc-pkg hide haskell98 and try again
16:51:21 <edwardk> beyond that though i probably won't be much help
16:51:45 <c_wraith> If you're using jhc, I don't even know.  I don't think jhc even *uses* base
16:51:46 <RylandAlmanza> Didn't work. Thanks for your help, though. I appreciate it. :)
16:53:16 <RylandAlmanza> Well, anyone know any other relatively easy way to play with the android ndk with haskell?
16:53:21 <hpaste> “Ertugrul Söylemez” pasted “Clock semigroup” at http://hpaste.org/72413
16:53:34 <mm_freak> edwardk: do you see any way to write this more nicely with 'lens'?
16:53:39 <mm_freak> without losing efficiency
16:54:22 <edwardk> not really
16:54:31 <mm_freak> alright
16:54:46 <edwardk> if it was a polymorphic container that held more than the one field, then yes ;)
16:54:47 <d-old> ReinH: what are you surprised? it looks like you put a lot of effort into it
16:55:17 <edwardk> MostAwesomeDude: another rather nice feature of lens is Control.Lens.Representable
16:55:24 <edwardk> I use that a _lot_
16:55:28 <mm_freak> edwardk: only one field is polymorphic
16:55:35 <edwardk> mm_freak: yeah =)
16:56:05 <mm_freak> well, i just changed it to:  s `seq` dt `seq` gt `seq` t0 `seq` t `seq` Clock s dt gt t0 t
16:56:11 <edwardk> oooh
16:56:27 <edwardk> i can change the definition of Control.Lens.Representable to use an isomorphism =)
16:57:08 <edwardk> class Functor f => Representable f where rep :: Isomorphic k => k (Rep f -> a) (f a) -- or something
16:57:47 <edwardk> rep = isomorphic (…) adjust  instead of he old definition, then you can use 'from rep'
16:58:04 <edwardk> we s/adjust/view
16:58:18 <latro`a> alright, seeing that makes me wonder something
16:58:40 <edwardk> ?
16:58:41 <latro`a> when exactly do you want to put class constraints on classes, type declarations, and functions only, respectively?
16:59:00 <latro`a> when I was first learning I was basically told "functions only, all the time", and never *fully* told why
16:59:26 <mm_freak> latro`a: class constraints can make sense
16:59:32 <edwardk> i put them on the class when you want it to be a logical superclass., you put them on the data type pretty much never (thats removed) unless you need it inside a GADT in a local context on some constructor
16:59:43 <edwardk> and you put it on instances when you need them for the instance
17:00:03 <edwardk> instance (Monoid m, Monoid n) => Monoid (m, n) -- you need the monoid for m and n to proceed
17:00:05 <mm_freak> latro`a: for example if Monad had a constraint on Functor, then we wouldn't need 'liftM' and you could just use fmap without "(Functor f, Monad f) =>"
17:00:12 <latro`a> the instance thing is necessary to even get it to compile
17:00:20 <mm_freak> latro`a: constraints on types never make sense
17:00:29 <edwardk> if monad had a constraint on Functor we'd need liftM -- as a default definition for fmap someone can plug in
17:00:38 <edwardk> since it won't fill in the body automatically
17:01:06 <mm_freak> in all other cases, well, only functions are left =)
17:01:32 <latro`a> anyway, that seems to more or less formalize the intuition I had
17:01:44 <mm_freak> hmm, i actually need Monoid instead of Semigroup =/
17:01:46 <mm_freak> that's bad
17:21:56 <danharaj> edwardk: are the new isos in lens-1.2? Hackage hasn't built the docs yet.
17:22:05 <edwardk> yep!
17:22:11 <danharaj> sweet!
17:22:20 <edwardk> and they are dead sexy to use
17:23:49 <edwardk> basically the main things i'm looking to fix up for 1.3 or so is to get better lenses for time, and to get functionality closer to deriveLenses, and to make deriveLenses do automatic generation of the isomorphism lens for newtypes
17:23:53 <shachaf> New isos?
17:24:11 <edwardk> lens 1.2 features isomorphism lenses that compose with other lenses
17:24:37 <edwardk> so you can apply them directly as a function and use a combinator 'from' to turn them around
17:25:00 <shachaf> Hmm, neat.
17:26:08 <edwardk> "hello"^.packed.from packed etc
17:27:02 <edwardk> but also many of the combinators are actually implemented in a way that you can run them backwards with 'from'
17:29:11 <danharaj> edwardk: do lenses in particular traversals fuse?
17:29:29 <danharaj> It's just function composition after all.
17:29:45 <edwardk> danharaj: well, many of them just vanish when optimized
17:30:01 <edwardk> they almost all inline away at the use site to almost nothing
17:30:41 <edwardk> but traverse.traverse still has to walk into both structures. now, fusion would be that the operations that use them fuse
17:31:00 <edwardk> e.g. mapOf l f . mapOf l g = mapOf l (f . g)
17:31:02 <danharaj> yeah
17:31:30 <edwardk> i wonder if there is a nice yoneda-ish data structure for that
17:33:22 <edwardk> newtype Yonedaish a c = Yonedaish { forall b d. Setter a b c d -> (c -> d) -> b }
17:33:33 <edwardk> should permit mapOf  fusion
17:33:55 <edwardk> or something like it
17:34:46 <edwardk> now, there is a state monad that i think snap uses that has a baked in partial focus through a lens
17:34:57 <edwardk> that proides a notion of fusion when working in the state
18:00:24 <Hermit> I've been digging google for a while now but nothing relevant yet regarding how to get the size of a block device (some /dev/disk*). I need the size of the disk/partition. So far I've found GHC.IO.Device but that doesn't seem to be what I'm looking for. Any hint?
18:01:04 <jules2> what is the relation between type families and GADTs? what is the overlap (if any) and what are the differences?
18:02:11 <shachaf> Hermit: That sounds like a system-specific-API sort of thing.
18:02:22 <Hermit> indeed
18:02:36 <shachaf> Probably involving ioctl()
18:02:48 <shachaf> I doubt there are bindings for it in the standard library.
18:03:32 <Hermit> I'll try to seek until eof and query the position, but I was looking for something less-bizarre/more-specific
18:05:51 <shachaf> Hermit: strace fdisk to see what it does. :-)
18:06:05 <shachaf> Looks like ioctl(BLKSSZGET) and such.
18:07:16 <Hermit> unfortunately I'm on OSX and don't have strace. I'm sure it'd be different anyways..
18:07:26 <shachaf> Ah. Yes.
18:07:36 <shachaf> dtruss will do something similar, probably. :-)
18:08:32 <Hermit> hSeek handle SeekFromEnd 0  then  hTell handle  seem to be the way to go in this case
18:08:39 <Hermit> seems*
18:09:33 <edwardk> jules2: you can make a data family that is also a GADT, you can make GADTs and you can make data families, they are pretty much orthogonal concepts
18:10:13 <edwardk> jules2: the main area of overlap is that ghc uses the type equality coercions from the type family plumbing to implement GADTs internally
18:14:51 <jules2> edwardk, perhaps I'm thinking too naively here, but they seem somehow similar. Type families allow you to have F a where the resulting type depends non-parametrically on a. GADTs seem to be the same, but for data constructors instead of types. Is this correct?
18:17:19 <edwardk> well, ultimately GADTs are just sugar on a bunch of type equality coercions.   data Equal a b where Refl :: Equal a b   -- Refl :: (a ~ b) => Equal a b -- is just a constructor carrying a witness of type equality. we use type equality at the type level to implement type families too, so you can fish around and come up with analogies where they are similar, but they have different purposes =)
18:19:27 <Hermit> heh... there's no such thing as SeekFromEnd for block devices...
18:41:20 <jules2> edwardk: thanks, i'll have to think about this more to fully understand it
18:54:27 <nand`> edwardk: any post about the various equivalent formulations of lenses? You mentioned ‘data Store’ in mirrored-lenses, but what are the “other lens types” mentioned in the same post?
18:54:38 <edwardk> nand`; one sec
18:54:50 <edwardk> http://stackoverflow.com/questions/5767129/lenses-fclabels-data-accessor-which-library-for-structure-access-and-mutatio/5769285#5769285
18:55:05 <edwardk> i gave a pretty long winded explanation there
18:55:50 <nand`> oh hey, I remember that answer. Thanks, I'll re-read it
18:56:26 <edwardk> twanvl wrote up something on his blog that was a pretty good overview/comparison as well
19:04:25 <nand`> edwardk: how is the forall c. Iso a (b,c) example supposed to be understood? The forward transformation, ie. a -> (b,c) splitting the a into the focused field + the rest; and the reverse transformation (b,c) -> a taking a new focused field and the same context (as protected by the quantification) and produces a new a?
19:05:44 <edwardk> yep!
19:06:12 <edwardk> you don't know anything else about 'c' so you can't use it for anything but putting it back together with a b
19:06:15 <nand`> [re van laarhoven] “you can validate for yourself that function application is lens composition” <- should be fixed to function compisition?
19:06:18 <nand`> composition*
19:06:24 <edwardk> yep
19:07:09 <edwardk> fixed
19:07:35 <nand`> :)
19:07:56 <edwardk> basically what the store was doing was the same thing as the isomorphism lens, it just was doing it implicitly
19:08:16 <edwardk> the lens laws conspire to make you effectively do the same thing in a van laarhoven lens as well
19:09:35 <nand`> I thought of the store approach being conceptually simpler to ((a -> b), (a -> b -> a)) just with the a -> factored out
19:09:41 <nand`> conceptually closer to*
19:10:29 <edwardk> in practice it is
19:11:01 <nand`> but I guess the ‘Store’ captures the essence of ‘not being able to access the rest’; since it's wrapped inside a closure somewhere
19:11:03 <edwardk> since we're polymorphic in the functor in a van laarhoven lens we can't do many things
19:11:29 <edwardk> but the nice thing is that functor provides a nice place to hang additional functionality
19:11:42 <edwardk> e.g. we can enrich it to an Applicative and you get something that behaves more like 'traverse'
19:12:12 <edwardk> or we can refine it to a 'Const m' for some Monoid m, then it behaves like foldMap
19:12:20 <edwardk> etc.
19:12:29 <edwardk> Identity gives us fmap
19:12:41 <edwardk> Const r. for all r's gives us a function
19:12:51 <nand`> edwardk: the implementation of the lens has to be different for this too?
19:13:34 <edwardk> nand`: well, you can make a Traversal.. that isn't a lens. and give it extra powers by using
19:13:47 <nand`> of the function, rather
19:13:53 <edwardk> type Traversal a b c d = forall f. Applicative f => (c -> f d) -> a -> f b  -- an applicative instead of functor
19:14:11 <edwardk> now the power lies with the lens, not with the thing that uses it
19:14:18 <hin> hello all
19:14:52 <edwardk> so, for instance, foldMapOf :: ((c -> Const m d) -> a -> Const m b) -> (c -> m) -> a -> m
19:15:01 <edwardk> that doesn't need anything about m
19:15:07 <edwardk> the lens will require it if it needs it
19:15:15 <edwardk> just to be able to be passed as the argument
19:15:29 <edwardk> so if you pass it a traversal it'll demand a monoid  for m
19:15:44 <edwardk> if you pass it a lens, however, Const m is a Functor for all m already, so it doesn't need anything else
19:15:55 <edwardk> if you pass it a Fold it'll demand a monoid for m, etc.
19:16:03 <edwardk> rather the lens itself will demand the monoid
19:16:55 <edwardk> foldMapOf l f = getConst . l (Const . f)
19:17:09 <edwardk> doesn't use any monoids, etc. itself
19:17:22 <edwardk> just calls a function and passes it a couple wrappers
19:18:22 <edwardk> thats the secret to how lens works, I move all that logic out of the combinators and push it back on whoever is supplying me a lens-like construction
19:18:29 <nand`> edwardk: right
19:18:34 <nand`> edwardk: that's neat
19:18:53 <edwardk> i like it a heck of a lot better than all my old hacks =)
19:19:04 <edwardk> because i don't need to write all new combinators for each new lens type
19:19:07 <edwardk> there are some rough edges
19:19:19 <edwardk> but they mostly come from the class hierarchy sucking
19:19:46 <edwardk> if we had Apply and Pointed as superclasses of Applicative for instance, we could make safer versions of maximumOf and model embedding/projection pairs faithfully
19:20:01 <edwardk> because then you could have
19:20:03 <danharaj> It is clever to move the class constraint onto a continuation argument.
19:20:28 <edwardk> type NonEmptyTraversal a b c d = forall f. Apply f => (c -> f d) -> a -> f b
19:20:57 <edwardk> and maximumOf :: Getting (Max c) a b c d -> a -> Maybe c  -- can then use the Semigroup
19:21:17 <nand`> Max?
19:21:28 <edwardk> er sorry. it can become maximumOf :: Getting (Max c) a b c d -> a -> c
19:21:32 <ddarius> @hoogle Max
19:21:32 <lambdabot> Prelude max :: Ord a => a -> a -> a
19:21:33 <lambdabot> Data.Ord max :: Ord a => a -> a -> a
19:21:33 <lambdabot> Prelude maxBound :: Bounded a => a
19:21:41 <otters> Does anybody know in what form exactly hbro requires webkit?
19:22:03 <edwardk> newtype Max a = Max a; instance Ord a => Semigroup (Max a) where Max a <> Max b = Max (max a b)
19:22:22 <nand`> ah
19:22:32 <edwardk> currently it uses a monoidal variant
19:22:57 <nand`> (Ord a, Bounded a) ?
19:23:07 <edwardk> type NonEmptyFold a b c d = forall m. Semigroup m => (c -> Const m d) -> a -> Const m b
19:23:37 <edwardk> well that is a less satisfying result =)
19:24:12 <edwardk> it uses a Maybe clone using the Nothing to represent no value
19:24:22 <nand`> oh
19:24:36 <edwardk> but if i had Apply/Semigroup i could make non-empty traversals and folds
19:24:49 <edwardk> and if i had pointed i could make traversals that traverse at most one element
19:24:51 <nand`> yeah
19:25:08 <edwardk> and with default you get the same for partial getter
19:25:28 <edwardk> but then to be compatible with these you need more of your traversals
19:25:57 <edwardk> since type Traversal a b c d = forall f. (Apply f, Applicative f, Pointed f) => (c -> f d) -> a -> f b
19:26:04 <edwardk> becomes quite a bit heavier
19:26:22 <edwardk> then refined notions rip those constraints off like wings off a fly
19:26:57 <edwardk> but i don't want those dependencies for lens
19:27:06 <nand`> type Applicative a = (Apply a, Pointed a) -- how well would this work?
19:27:25 <nand`> (assuming a reformed Prelude)
19:27:27 <edwardk> so i'll probably make a partial lens package with those
19:27:33 <edwardk> its problematic
19:27:39 <edwardk> because those aren't enough
19:27:44 <edwardk> you need laws relating them
19:27:57 <nand`> oh, right; you've mentioned this before
19:28:00 <edwardk> Apply a, just gives you a method for (<*>)
19:28:13 <edwardk> doesnt give you any laws relating that to pure at all
19:28:28 <edwardk> this is the problem with the scalaz approach of building instances out of whole cloth given their parts
19:29:08 <edwardk> pure :: a -> [a]; pure = repeat;  now my >>= is broken ;)
19:30:37 <edwardk> been trying to find other fundamental operations i can use to stitch together lenses. we have things for monoid-like structures, but nothing for ring-like structures, that pushes you towards alternative-like lenses
19:32:00 <danharaj> What is the point of the "fooOf" functions?
19:32:30 <edwardk> danharaj: anyOf text (=='c')
19:32:41 <edwardk> takes a traversal for data.text and lets you use any with it
19:33:07 <edwardk> now given just something like 'traverse' you immediately get access to 50 or so combinators
19:33:10 <danharaj> feels like there should be an 'of' combinator
19:33:20 <edwardk> doesn't generalize sadly
19:33:27 <danharaj> :[
19:33:55 <ddarius> of2'
19:33:59 <edwardk> most of them take the list or whatever in a late position
19:34:10 <edwardk> also of is a keyword
19:34:22 <danharaj> oof
19:34:25 <edwardk> otherwise you might be able to use it for fold like combinators
19:34:50 <edwardk> any (=='c') (of text "foo")
19:35:05 <nand`> what's the type of anyOf?
19:35:05 <edwardk> by renaming toListOf to of
19:35:21 <danharaj> anyOf :: Getting Any a b c d -> (c -> Bool) -> a -> Bool
19:35:32 <edwardk> anyOf :: ((c -> Const Any d) -> a -> Const Any b)) -> (c -> Bool) -> a -> Bool
19:35:49 <edwardk> Any is just Bool in a newtype wrapper
19:35:54 <ddarius> > let οf = id in sum `οf` [1,2,3]
19:35:55 <lambdabot>   6
19:35:56 <edwardk> to get the right monoid when used with a fold
19:36:01 <Veinor> ddarius: :O
19:36:04 <edwardk> hrmm
19:36:14 <edwardk> of works?
19:36:21 <ddarius> edwardk: Of course not.
19:36:35 <Veinor> > let of = id in of 3
19:36:36 <edwardk> > let of = id in case of of x -> x
19:36:36 <lambdabot>   <no location info>: parse error on input `of'
19:36:37 <lambdabot>   <no location info>: parse error on input `of'
19:36:41 <shachaf> > "let οf = id in sum `οf` [1,2,3]"
19:36:42 <Veinor> haha
19:36:42 <edwardk> whew =)
19:36:42 <lambdabot>   "let \959f = id in sum `\959f` [1,2,3]"
19:36:43 <nand`> edwardk: I see. I was confused because I've seen the name used in an entirely unrelated context
19:36:44 <edwardk> unicode?
19:37:39 <edwardk> nice
19:37:57 <nand`> do I see an implementation strategy here? ;)
19:38:07 <shachaf> > let οf = True in case οf of οf | οf -> οf | otherwise -> οf
19:38:07 <lambdabot>   True
19:38:26 <edwardk> nand`: basically all the combinators for folds just involve picking the right monoid
19:42:16 <edwardk> then they work for getters because all they do is wrap values in the monoid, or generate the default monoidal value and then never put them together
19:42:34 <edwardk> so nullOf anyGetter a = False ;)
19:43:08 <edwardk> lengthOf anyGetter a = 1
19:44:07 <edwardk> danharaj: re 'of' you could make a combinator that let you use the existing foldable combinators.. thats 'toListOf', but it makes you use a pretty crappy container
19:45:13 <danharaj> oh well
19:45:28 <danharaj> I will get a feel for that part of the api when I come to a use for it.
19:48:03 <ddarius> danharaj: You can use it for all your daily needs like removing tarnish from silver, whitening your teeth, eliminating body odors.
19:48:22 <danharaj> Convenient!
19:49:58 <nand`> ah yes, the golf syntax I've always wished for: _1%%~((>>)<$>print<*>return)
19:50:45 <danharaj> It has a certain beauty to it.
19:51:17 <beefcube> when doing a "putStr $ show tup", with tup :: (type1, Set type2) i'm getting a "Ambiguous infix expression", I'm sorry I can't produce a paste or be more specific, this is buried in my codebase, how do I solve this?
19:51:37 <beefcube> (ghc  7.4.1)
19:56:01 <edwardk> nand`: hahaha
19:56:20 <edwardk> you can drop the %%~
19:56:32 <edwardk> _1((>>)<$>print<*>return)
19:56:37 <edwardk> should work too
19:56:54 <sinelaw> i want to parse xmls using a known dtd
19:56:58 <sinelaw> type safely
19:57:04 <edwardk> %%~ = id
19:57:09 <sinelaw> such a thing, does it exist?
19:58:01 <nand`> edwardk: yeah, but that defeats the point somewhat
19:58:06 <edwardk> =)
19:58:22 <edwardk> well, i find it handy that you can view each lens as if it were 'traverse' in its own right
19:58:37 <edwardk> since i have great intuition for how to abuse traverse
19:59:05 <nand`> my ‘traverse’ knowledge tends to come from IRC one-liners
19:59:47 <ddarius> beefcube: Sorry, your problem is due to the context of the expression, so I can't produce an answer or be more specific.
20:01:17 <nand`> in your haddock you have “fmap = adjust mappend” but adjust mappend doesn't type-check here
20:01:30 <nand`> ..
20:01:33 <nand`> I'm silly
20:01:35 <nand`> never mind me
20:01:37 <danharaj> not mappend, mapped.
20:02:11 <sinelaw> I guess HaXml's dtdToHaskell should do what I want
20:02:36 <sinelaw> is HaXml alive and a good idea to use?
20:02:50 <nand`> danharaj: serves me right for going through Control.Lens at 5:02 am
20:02:58 <edwardk> nand`: =)
20:03:01 <danharaj> edwardk: is `adjust' essentially just id modulo newtypes?
20:03:09 <edwardk> yep
20:03:15 <edwardk> most of these are ;)
20:03:24 <danharaj> you know you have the right abstraction when your combinators are id.
20:03:30 <edwardk> adjust is an isomorphism
20:03:43 <edwardk> from adjust map gives you a setter ;)
20:04:06 <nand`> am I the only one who thinks Lens a a' b b' is much easier to follow along than Lens a b c d, especially since the whole point of a lens family is that they aren't arbitrarily polymorphic?
20:04:17 <edwardk> i tried to make as many of the combinators that were actual isomorphisms run both ways as i could
20:04:34 <edwardk> 2 characters x1400 lines adds up ;)
20:04:59 <ddarius> edwardk's hard drives can't take another 3kb.
20:05:04 <edwardk> also its easier on me when i have  two lenses to put together
20:05:06 <edwardk> help
20:05:12 <edwardk> i'm out of space ;)
20:05:45 <sinelaw> is there a reason why cabal is using only one of my two cpu cores?
20:05:55 <sinelaw> for building
20:06:17 <danharaj> iirc someone did implement parallel builds for cabal but it isn't in.
20:06:23 <danharaj> (yet? ever?)
20:06:26 <applicative> because it hasn't been made parallel?
20:06:27 <danharaj> (hackage 2.0?)
20:06:32 <edwardk> danharaj: actually almost all of the lens combinators there are just newtype noise on id
20:06:37 <edwardk> there is the occasional flip, but thats about it
20:06:39 <sinelaw> :(
20:06:44 <edwardk> and some noise for isomorphisms
20:06:53 <ddarius> flip is an isomorphism
20:07:01 <nand`> danharaj: there's https://github.com/23Skidoo/ghc-parmake but not sure how related that is
20:07:02 <edwardk> yeah
20:07:03 <nand`> also see the description
20:07:07 <applicative> sinelaw: I think as danharaj says it is ... planned.
20:07:09 <ddarius> sinelaw: You need that other core for IRC anyway.
20:07:22 <edwardk> forOf :: Isomorphic k => k (LensLike f a b c d) (a -> (c -> f d) -> f b)
20:07:27 <edwardk> forOf = isomorphic flip flip
20:07:28 <edwardk> ;)
20:07:31 <sinelaw> ddarius, heh, i need it mainly for ALT+TAB
20:07:52 <danharaj> I should get two more monitors so that I have one monitor per core.
20:08:30 * ddarius doesn't think he can put two monitors on his phone.
20:08:42 <ddarius> (Actually, that isn't true.  It has a mini HDMI output.)
20:08:46 <edwardk> yeah. the phones small. monitors are big. how would they fit?
20:08:47 <scooty-puff> can you imagine a situation where a general map is desired, or either strict or lazy values, with Int keys, where IntMap would not be the correct choice?
20:08:53 <scooty-puff> *or -> of
20:09:09 <applicative> sinelaw: I think I have actually  calling cabal in distinct instances of the console simultaneously without catastrophe, but maybe also with catastrophe....
20:09:15 <applicative> called cabal
20:09:24 <scooty-puff> with a finite number of entries
20:09:28 <danharaj> `cat`astrophe
20:09:31 <edwardk> scooty-puff: sure. call size a lot ;)
20:09:31 <edwardk> scooty-puff: size on IntMap is O(n) size on Map is O(1)
20:10:07 <danharaj> Why is size O(n) for IntMap
20:10:08 <edwardk> apparently 2-3% performance is worth completely screwing random users who don't expect to be blindsided by an O(n) size :)
20:10:21 <ddarius> Who uses size?
20:10:38 <edwardk> anyone maintaining an LRU cache with a map?
20:10:55 <applicative> hey sinelaw an update from last month here http://stackoverflow.com/questions/7238147/can-i-get-cabal-install-to-use-multiple-cores says it will be in the next cabal
20:11:12 <sinelaw> cool
20:11:51 * applicative upvotes Mikhail Glushenkov for the heck of it
20:13:03 * applicative upvotes Mikhail Glushenkov lacking any authentic method of expressing appreciation, rather.
20:13:35 <scooty-puff> edwardk, yeah, that is kind of strange - i guess a data wrapper might help, but definitely does mean possibly many choices
20:14:09 <edwardk> scooty-puff: yeah but you can't effectively recompute it after an intersection/union without help from the structure
20:14:13 <ddarius> Trade-offs in data structure choice?  Not in my house!
20:14:16 <edwardk> so you're basically dead in the water then
20:14:20 <scooty-puff> right now, for a library, i need map and set operations, for some unknown key type, and was trying to decide how to manage it
20:14:34 <edwardk> scooty-puff: just use HashMap
20:14:42 <edwardk> good all around performance
20:14:55 <scooty-puff> and op for the simpler Hashable constraint?
20:15:00 <edwardk> HashMaps tend to outperform IntMaps even for Int keys
20:15:04 <scooty-puff> k
20:15:07 <scooty-puff> *opt
20:15:23 <edwardk> mostly because the keys don't get all clustered down at one end of the space
20:15:37 <scooty-puff> k - so not a matter of attention
20:16:05 <scooty-puff> (no intention to imply such a situation)
20:18:12 <edwardk> anyways, id gun for hashmaps unless you need to get the keys out quickly in a canonical order
20:18:52 <scooty-puff> definitely do not
20:18:55 <scooty-puff> k
20:19:35 <scooty-puff> that really helps - had been using a special Key with assoc type Map and Elem with Set in a submodule just to not consume a general namespace, etc., etc.
20:24:27 <applicative> hm 'osxmonad' sort of works...
20:25:31 <klfwip> sorry to come in here just to ask about a problem, but you guys might be able to help me figure this out
20:25:34 <hpaste> klfwip pasted “simple problem” at http://hpaste.org/72418
20:25:59 <klfwip> er, thats cut off isn't it
20:26:45 <klfwip> but to summarize the issue: I want to write to the console after using a gloss window
20:27:03 <klfwip> it works fine before caling the window, but I don't know why
20:27:15 <klfwip> is this some weird quirk with monads?
20:27:28 <sinelaw> can anyone recommend a xml lib? dunno which is latest-and-greatest of all the multitude
20:28:11 <sinelaw> hxt seems to be alive
20:28:36 <tylerkahn> sinelaw probably hxt
20:28:56 <edwardk> klfwip: is display not returning to main?
20:29:10 <skynet-2000> loardy this is for programs i see
20:29:15 <skynet-2000> yes?
20:29:33 <edwardk> klfwip: if display never returned then this wouldn't print in any language no?
20:29:39 <sinelaw> tylerkahn, do you know if it can generate haskell types from a DTD?
20:29:53 <klfwip> edward, the display function is not something I wrote
20:29:55 <klfwip> built into gloss
20:30:04 * applicative is trying to figure out Gloss.display.
20:30:07 <edwardk> yes, what i mean is, is the window still open when you want to print?
20:30:07 <klfwip> so you have to end the window and call it again?
20:30:14 <klfwip> edward, yeah
20:30:27 <edwardk> then its probably hasn't returned to main ;)
20:30:30 <klfwip> I am a c++ programmer who made games in irrlicht and sfml, pity me :p
20:30:39 <edwardk> and so your code is probably blocked waiting for the window to go away
20:30:51 <klfwip> I thought that might be the case
20:30:52 <edwardk> no worries, just think of display as the whole event loop and everything
20:30:53 <tylerkahn> sinelaw: i don't know. that seems like a meta thing
20:31:01 <klfwip> but making a new window all the time does not seem very effective
20:31:10 <tylerkahn> cuz you're generating static types
20:31:11 <edwardk> i'm not sure i'd advocate for that either
20:31:18 <klfwip> well, I will find out how it should return then
20:31:31 <klfwip> haskell libs do not seem to ever have good documentation
20:31:35 <klfwip> how do you learn to use them>
20:31:46 <klfwip> reading the source is fine, if you already know the language
20:31:52 <edwardk> are you generating a single frame or an animation, etc?
20:32:02 <edwardk> well, gloss is kinda awkward to use
20:32:12 <klfwip> edward, a constant animation, with console output while it is still running
20:32:21 <sinelaw> tylerkahn, haxml has a tool for that
20:32:37 <beekur> yeaaah klfwip, that's a beginners question that I kinda have too.  i'm getting better at reading the types
20:32:47 <tylerkahn> sinelaw: ah that's cool
20:32:57 <edwardk> i don't recall if it actually _has_ any way to interact with the user beyond what it supplies out of the box
20:33:14 <klfwip> c++ and java are both really newbie friendly; there are so many bad programmers using them that a tutorial has been written for literally everything
20:33:50 <klfwip> but I want to use haskell, it appears more elegant. Getting proficient seems hard right now unfortunately
20:33:57 <tylerkahn> sinelaw: yeah idk. i am fairly certain that hxt, parsing xml with arrows, is the cutting edge
20:34:14 <sinelaw> tylerkahn, ok
20:34:16 <sinelaw> thanks
20:34:17 <edwardk> ah, the api has evolved since i last looked
20:34:22 <edwardk> you can probably use playIO or something
20:34:26 <tylerkahn> sinelaw: np good luck
20:35:30 <klfwip> I was looking at irrhaskell as well, since I have used the library before
20:35:53 <edwardk> playIO provides you with a feedback function that you use to update the world every iteration
20:36:03 <edwardk> that can hold the io action to print to the user
20:36:51 <klfwip> found it in google now
20:37:02 <edwardk> klfwip: i'll say this your chosen starting example is hardly indicative of the difficulties of haskell as a whole ;)
20:37:02 <klfwip> but for the sake of my future sanity, how did you find that information?
20:37:05 <klfwip> on hackage?
20:37:07 <edwardk> we just generally suck at graphics ;)
20:37:12 <edwardk> hackage
20:37:13 <klfwip> I really like graphics
20:37:17 <klfwip> that is the problem
20:37:22 <edwardk> googled graphics gloss, found the package, searched the current version
20:37:35 <edwardk> went looking for functions that can take an IO action somewhere
20:37:55 <edwardk> so do i. i used to do a lot with them. now i mostly fiddle with math ;)
20:38:19 <klfwip> I understand then, and yes haskell is very conducive to math
20:38:34 <ddarius> Math is very conducive to graphics.
20:38:40 <edwardk> that too =)
20:38:49 <klfwip> not if you cannot figure out how to make an irrlicht window using haskell ;P
20:39:05 <klfwip> actually, I probably just need to edit the config files in the source
20:39:08 <klfwip> which I found today
20:39:15 <klfwip> they were linked to the wrong place before
20:39:28 * ddarius is pretty sure he produced computer graphics long before irrlicht existed.
20:39:38 <klfwip> ddarius, open GL is fine
20:39:44 <applicative> it seems that before you get to putStrLn "hello world" you have done System.exitWith System.ExitSuccess
20:39:52 <klfwip> but a game engine massively improves productivity for me
20:40:14 <klfwip> applicative, the window closes my program when it ends, huh
20:40:22 <edwardk> klfwip: sure. the problem for the most part is there is a huge impedence mismatch between the haskell parts of your code and the monolithic game engine outside
20:40:23 * klfwip shall find out what to do about this
20:40:38 <klfwip> edwardk, of course
20:40:40 <applicative> klfwip: it looks like it, i was looking to see what could impede this
20:40:52 <klfwip> once I can get past the interface to openGL and irrlicht the rest will be more natural
20:41:01 <edwardk> i have some rigid body physics code i've been working on explicitly to avoid that impedence mismatch as much as possible
20:41:17 <edwardk> the interface to opengl and sdl is pretty easy to get up and running with
20:41:30 * klfwip would rather avoid SDL
20:41:36 <danharaj> enjoy your unsafeCoercion between GLFloats and Floats.
20:41:37 <edwardk> i never looked at the irrlicht bindings, but they look rather … messy
20:41:39 <klfwip> unless its the only option
20:41:44 <edwardk> danharaj: *cry*
20:41:54 <edwardk> fortunately for 7.6.1 they'll have to fix that!
20:42:21 <ddarius> :t realFrac
20:42:21 <klfwip> edward, well- I don't expect a binding someone threw together and never used in a real game to match up with the native version
20:42:22 <lambdabot> Not in scope: `realFrac'
20:42:25 <edwardk> you won't be able to ffi to a type you don't know the constructor for
20:43:11 <klfwip> how about this for a theory: I abandon game engines in haskell for now
20:43:17 <edwardk> klfwip: i've mostly used hand-rolled cuda bindings, the opengl bindings, and a few lines of sdl in haskell
20:43:20 <danharaj> edwardk: what's coming up in 7.6.1?
20:43:23 <klfwip> until I know the language better and then I can face the madness like a man
20:43:40 <edwardk> danharaj: ffi currently warns if you use a type you don't have the constructor for
20:43:46 <klfwip> and if I die then, at least I can make it a death that will be rememebered
20:43:54 <edwardk> heh
20:44:10 * ddarius is pretty sure klfwip won't remember his death.
20:44:10 <edwardk> klfwip: fyi there is a #haskell-game channel
20:44:27 <klfwip> ddarius, no, but I could livestream it on blip.tv
20:44:49 <klfwip> edward, excellent
20:44:56 * ddarius doesn't think dead people watch livestreams on blip.tv.
20:45:05 <ddarius> But I could easily be wrong about that.
20:45:21 <klfwip> never said I would remember
20:45:51 <klfwip> but if you had to fall to a bad graphics binding, wouldn't you rather leave a legacy in the process?
20:45:56 <klfwip> so others can learn from your folly?
20:46:27 <ddarius> No.
20:47:12 <klfwip> thats cool. thanks for the conversation everyone, perhaps when I return I will be more enlightened
20:48:23 <applicative> klfwip: I cant see where gloss is leaving it open to you to do something like this, but it's too complicated to be sure...
20:48:40 <klfwip> applicative, me neither
20:48:42 <Vulpyne> Hi. I have a somewhat dumb question regarding the hashtables package (mutable hashtables in ST, and an IO version that uses stToIO). If I use it in a concurrent situation, do I have to protect it with a mutex or something?
20:48:48 <notdan> Hi! Would I be right to say that Haskell kinds are like dependent types, but they depend on other types, rather than values?
20:48:52 <klfwip> going through the docs in the package but I will keep looking
20:49:20 <ddarius> notdan: Only in an insane round about way.
20:49:25 <applicative> klfwip: I'm not sure how to characterize its purpose, but gloss does have a rather restricted purpose, I suppose this is part of the reason its so easy to use...
20:49:43 <klfwip> applicative, its excellent for drawing lines and circles!
20:50:01 <klfwip> which was mostly what I hoped to do right now, but I need console access at the same time
20:50:04 <applicative> indeed even children do it, if I remember
20:50:17 <notdan> danharaj: but that's what they are! Haskell types cannot depend on type values, only on other types
20:50:22 <notdan> isn't that the case?
20:50:36 <ddarius> notdan: I didn't say you were wrong.
20:51:22 <ddarius> Haskell kinds are also like cats, only minus the cat-like parts, and plus type-like things.
20:52:05 <ddarius> notdan: Anyway, you may want to look at either the lambda cube and/or pure type systems.
20:52:07 <Vulpyne> Does anyone have any idea regarding my question? I think it would be generic to stuff that's mutable in ST. I couldn't find any information about how it works with concurrency.
20:52:12 <applicative> klfwip: http://cdsmith.wordpress.com/2011/09/28/haskell-for-kids-week-7/  -- the square rotates!
20:53:14 <notdan> ddarius: hm, can you give me some references perhaps?
20:53:21 <klfwip> applicative, potentially useful
20:53:24 <ddarius> @google "lambda cube"
20:53:25 <lambdabot> http://en.wikipedia.org/wiki/Lambda_cube
20:53:25 <lambdabot> Title: Lambda cube - Wikipedia, the free encyclopedia
20:53:35 <ddarius> @google "pure type systems"
20:53:36 <lambdabot> http://en.wikipedia.org/wiki/Pure_type_system
20:53:36 <lambdabot> Title: Pure type system - Wikipedia, the free encyclopedia
20:53:48 <klfwip> if you can call the animation function you could also call some IO function
20:53:52 * klfwip will think about that later
20:53:56 <ddarius> Wikipedia has gamed Google.
20:54:08 <notdan> true
20:54:27 <Jafet> Google is an accomplice
21:00:06 <dibblego> @type lift . MaybeT . return
21:00:06 <lambdabot> Not in scope: data constructor `MaybeT'
21:00:36 <dibblego> is there some type-class that gives me :: Monad f => Maybe a -> MaybeT f a ?
21:01:40 <mm_freak> dibblego: you can borrow the LiftFunctor class from contstuff
21:01:50 <mm_freak> i don't recommend depending on the library, but you can copy the code
21:02:07 <dibblego> oh? I'm more interested in the best way to solve it, so LiftFunctor sound ok
21:02:22 <mm_freak> it's an ad hoc way, but it should be sound
21:02:27 <dibblego> what is the package name?
21:02:34 <mm_freak> @hackage contstuff
21:02:34 <lambdabot> http://hackage.haskell.org/package/contstuff
21:02:39 <dibblego> oh ta
21:03:34 <mm_freak> for MaybeT it gives you:  liftF :: (Monad m) => m (Maybe a) -> MaybeT m a
21:04:18 <mm_freak> or in the case of contstuff's MaybeT:  liftF :: (Monad m) => m (Maybe a) -> MaybeT r m a
21:04:21 <dibblego> so liftF . return then?
21:04:31 <mm_freak> if you have a Maybe, then yeah
21:04:33 <dibblego> trying to find the MaybeT instance
21:04:52 <mm_freak> it's in the .Trans module
21:05:57 <dibblego> sweet thanks mate
21:06:41 <avpx> Anyone here used Shelly? Is there a way to do lazy pipes with it?
21:07:12 <avpx> run "/bin/cat" ["/dev/urandom"] -- This hangs and never yields a Text value
21:07:29 <avpx> run "/bin/cat" ["/proc/cpuinfo"] -- This yields a Text value
21:13:59 <avpx> Is seems like this library is unnecessarily strict. For instance, find searches the entire directory tree before giving any resulting FilePaths
21:14:03 <dibblego> mm_freak: do you know a way to encode LiftFunctor without type-families or fundeps?
21:14:04 <danharaj> edwardk: you should know how awesome lenses and isos are for dealing with arrays. traversals for accessing subregions, isos for coordinate transformations, it's awesome.
21:14:11 <avpx> (I'm using 0.13.3, for the record)
21:14:16 <danharaj> (did I mention it's awesome)
21:14:16 <edwardk> =)
21:14:34 <edwardk> you use ixmapped yet?
21:15:09 <danharaj> ixmapped? I didn't see that.
21:15:24 <danharaj> oh. it's right there. heh.
21:15:55 <edwardk> danharaj: as an aside i'm currently rewriting all the template haskell code so i can get it to generate isomorphisms for newtypes, and proper polymorphic lenses with signatures
21:16:14 <danharaj> great!
21:16:21 <edwardk> it currently leaves off sigs which make -Wall whine
21:16:43 <edwardk> and i want it to handle multiple constructors more gracefully
21:16:54 <danharaj> mm signatures. If only I could get GHC to pretty print type errors. :P
21:17:32 <edwardk> when you -Wall at least it shows the type =)
21:18:09 * ddarius has the attention span of a gnat right now.
21:18:45 <johnw> a gnat with add
21:19:14 <edwardk> its funny, all this TH stuff i need to go read a bunch of variables, alpha rename them, substitute them back into TH, its like i never left the office ;)
21:19:40 <otters> TH needs to be less cumbersome
21:20:21 <ddarius> edwardk: Make th-bound
21:20:35 <edwardk>  ddarius : heh, tempting
21:22:03 <danharaj> Is TH cumbersome? I thought it was just mostly obscure.
21:22:13 <edwardk> its both
21:22:40 <avpx> It doesn't strike me as really obscure. It is the primary metaprogramming tool for Haskell, right?
21:22:48 <danharaj> metaprogramming tool for GHC
21:22:53 <avpx> Yeah, that.
21:23:14 <otters> Quasi-quotation only works for simple and usually pretty useless cases
21:23:47 <otters> you can't just give an arbitrary name a type signature and a definition because then the compiler will complain
21:23:55 <otters> even if you just want to bind that sig and that definition to the name
21:25:29 <danharaj> edwardk: I love the variance on ixmapped.
21:25:41 <edwardk> it followed ixmap
21:26:53 <ddarius> :t ixmap
21:26:55 <lambdabot> forall i j e. (Ix i, Ix j) => (i, i) -> (i -> j) -> Array j e -> Array i e
21:27:33 <edwardk> the other fun one is that you can map a set and change the number of elements of the set without violating the functor laws, but sadly the members setter can't be legally made traversable
21:27:36 <ddarius> Modulo the bounds, it's just precomposition of function.
21:27:53 <edwardk> yep
21:28:08 <otters> has anybody here tried to install haskell-platform with homebrew?
21:28:26 <danharaj> I just find it cute because the 'intuitive' idea of substructure that is lensed is usually something covariant.
21:28:34 <edwardk> *nods*
21:29:00 <ddarius> You can look through a telescope both ways.
21:29:08 <edwardk> ddarius++
21:29:31 <danharaj> Be warned. One can take a metaphor too far :P
21:29:41 <danharaj> c.f. oop
21:29:50 <edwardk> no, when i had bifocal lenses -- that was taking it too far ;)
21:29:58 <danharaj> I saw that commit on the repository.
21:30:15 <danharaj> Lucky I didn't see it before that because I might have passed over lens completely.
21:30:20 <otters> How do I uninstall cabal itself?
21:30:25 <edwardk> =P
21:30:30 <danharaj> cabal is just a binary
21:30:55 <otters> oh, so I can just rm it
21:32:25 <edwardk> ddarius: anyways i'm more likely to make a couple Simple Traversal a a -> Simple Traversal a a   combinators for recursively applying a self-similar traversal and use that sort of thing for something like compos/multiplate
21:32:37 <edwardk> than build th-bound ;)
21:32:54 <latro`a> wait, what's the first argument to ixmap
21:33:08 <edwardk> the bounds
21:33:13 <latro`a> the bounds of the new array?
21:33:16 <edwardk> yeh
21:33:24 <edwardk> then it uses the function to look back into the old one for values
21:33:24 <latro`a> is there any reason that can't be computed in advance?
21:33:27 <latro`a> I guess that'd be slow
21:33:31 <edwardk> yeah
21:33:38 <edwardk> lets run the entire operation twice!
21:33:39 <edwardk> =)
21:33:41 <latro`a> but you could write an ixmap' without that right?
21:33:44 <latro`a> if you wanted
21:33:46 <edwardk> not sure
21:33:47 <latro`a> to be lazy
21:33:52 <edwardk> keep in mind its backwards
21:33:54 <edwardk> not forwards
21:34:05 <edwardk> we're saying 'for everything in these bounds' look things up
21:34:14 <latro`a> oh oh
21:34:24 <danharaj> it's a pullback!
21:34:32 <danharaj> not a pushforward.
21:34:36 <latro`a> nvm, I was thinking of ... what was I thinking of
21:34:42 <edwardk> if you think about it it makes sense, its a lot easier for me to ask for each position
21:34:45 <latro`a> I thought there was an element-map and an index-map
21:34:54 <edwardk> there is
21:35:03 <latro`a> oh in IArray
21:35:03 <latro`a> nm
21:35:05 <edwardk> amapped and ixmapped are the amap and ixmap analogues
21:35:37 <latro`a> somehow I thought there was a way to basically twiddle pointers
21:35:46 <latro`a> with an ixmap that goes the other way
21:35:51 <latro`a> but that would be pretty terrible
21:35:55 <latro`a> no way to guarantee contiguity and so on
21:36:19 <latro`a> anyway, good catch--I'm not sure that's obvious in the documentation for that function
21:36:36 <latro`a> it's the only thing that type could do, but it's not hard to read the type backwards
21:36:49 <edwardk> i'll happily take a documentation patch for ixmapped ;)
21:37:04 <latro`a> not sure how to express it better, though
21:37:43 <latro`a> "ixmap bounds f arr is an array whose bounds are bounds and whose entry at i is arr's entry at f i"
21:37:48 <latro`a> something like that
21:39:03 <latro`a> ...hell, why bother:
21:39:23 <latro`a> ixmap bounds f arr ! i = arr ! (f i)
21:39:31 <latro`a> easier to read than the sentence
21:39:40 <edwardk> =)
21:40:10 <edwardk> no need for the parens either
21:40:16 <latro`a> touche
21:41:53 <ddarius> ixmap b f arr ! i = arr ! f i  and  bounds (ixmap b f arr) = b
21:41:58 <latro`a> yup
21:42:09 <latro`a> though the latter is obvious
21:42:16 <latro`a> (at least it seems that way to me?)
21:42:43 <ddarius> The point was to uniquely characterize ixmap.
21:43:23 <latro`a> ah true
21:43:35 <latro`a> without any other documentation whatsoever those two are sufficient
21:43:44 <latro`a> with just the former not so much
21:45:28 <ddarius> It'd be nice if more documentation included laws, particularly comprehensive sets of laws.
21:46:31 <danharaj> edwardk: it occurs to me that the elegance of lens really comes from the fact that (->) is way more privileged that user defined type constructors.
21:46:35 <danharaj> than*
21:46:58 <edwardk> w.r.t. impredicativity?
21:47:19 <danharaj> yes, and prelude (.)
21:47:23 <edwardk> hah
21:47:24 <edwardk> yeah
21:48:04 <danharaj> and ` '
21:48:21 <edwardk> btw- i had't realized quite how alien the contravariance made reasoning about that setter ;)
21:49:23 <mm_freak> dibblego: i don't think that's possible
21:50:57 <johnw> I am dispairing at finding an article on free monads that makes any sense whatsoever
21:51:13 <ddarius> johnw: Why do you need an article?
21:51:13 <edwardk> johnw: ohe sec
21:51:14 <johnw> they are all vocabulary rich, but explanation poor
21:51:16 <edwardk> er one sec
21:51:30 <johnw> i just want to know what they are for, why they are useful
21:51:42 <ddarius> johnw: Why?
21:51:48 <johnw> i've read like 4 articles now where people get super excited about... and then I can't even find out why they are excited at all
21:51:51 <johnw> dunno, just curious
21:52:05 <edwardk> johnw: in reply to https://plus.google.com/106871002817915335660/posts/g9LASrMjeFS i described what the heck free means
21:52:33 <edwardk> but ultimately a free monad is just the monad you get for free using
21:52:51 <edwardk> data Free f a = Pure a | Free (f (Free f a))  and a Functor f
21:53:05 <edwardk> instance Functor f => Monad (Free f) where return = Pure
21:53:08 <ddarius> The definition of a forgetful functor is trivial!
21:53:14 <johnw> the closest I came to grokking it was haskell-for-all's explanation of creating a DSL you can create proofs for independent of its being used
21:53:21 <edwardk> Pure a >>= f = f a
21:53:30 <johnw> yeah, I ran into that web page too
21:53:36 <edwardk> then all you need to do is figure out how to get into the free constructor
21:53:37 <johnw> well, I'll come back to this in a while
21:54:20 <edwardk> Free as >>= f = Free (fmap (>>= f) as)   -- you need to use fmap because thats all you can do to get into the functor to hunt down the 'a's stored in its children
21:54:20 <danharaj> free monads are all about trees and substituting trees into trees.
21:54:33 <johnw> danharaj: now there is a statement that begins to make some sense!
21:54:38 <avpx> I've seen people here define Natural and List as applications of Free
21:54:42 <ddarius> johnw: Several common monads are free monads.  If you can recognize this, you immediately get all the benefits of a monad (functor, applicative) as well as any operations defined for arbitrary free monads.
21:54:43 <edwardk> johnw: how comfortable are you at writing monads?
21:55:03 <edwardk> johnw: data Tree a = Tip a | Bin (Tree a) (Tree a)
21:55:08 <ddarius> avpx: That's a different free.
21:55:14 <avpx> ddarius: Oh?
21:55:18 <edwardk> johnw: what does the monad for that look like?
21:55:20 <johnw> edwardk: not very
21:55:40 <johnw> do you mean Leaf a?
21:55:46 <edwardk> johnw: once you can write the monad for that, the monad for free comes pretty quickly as a generalization
21:55:48 <danharaj> Tip a, Leaf a, it's all the same.
21:55:53 <johnw> ok, just making sure
21:55:54 <edwardk> call it what you will
21:55:57 <danharaj> Ponies a
21:56:02 <otters> heh
21:56:05 <edwardk> i'll get you started
21:56:11 <edwardk> instance Monad Tree where return = Tip
21:56:11 <otters> I am amazed that the current version of HUnit was shipped yet doesn't compile
21:56:28 <edwardk> then the first part of >>= follows from a monad law
21:56:28 <ddarius> Since left adjoints are continuous, coproducts of free monads are just coproducts of the underlying functors.
21:56:31 * ddarius adds to the problem.
21:56:32 <edwardk> Tip a >>= f = f a
21:56:39 <edwardk> ddarius: =P
21:56:45 <johnw> edwardk: you are way past me already
21:56:57 <edwardk> return a >>= f = f a
21:57:08 <johnw> why would I want a Monad for your Tree structure?
21:57:09 <edwardk> there are three laws for a monad
21:57:19 <edwardk> johnw: lets say your tree is a syntax tree
21:57:27 <edwardk> then you can use variables as place holders
21:57:32 <johnw> oh, wait, for the same reason I'd want a List Monad, right?
21:57:36 <edwardk> and use >>= to go replace them with definitions
21:57:37 <edwardk> yes
21:57:44 <edwardk> Tree is just a list with two tails
21:57:48 <Jafet> Why wouldn't you want a monad
21:57:48 <edwardk> for every node
21:57:51 <johnw> yeah, yeah, that makes sense
21:57:59 <Jafet> Tip a >>= f = f a
21:58:08 <avpx> Jafet: I try to make all of my types Monads, personally
21:58:11 <avpx> I can't get enough of them.
21:58:22 <johnw> avpx: why?
21:58:23 <danharaj> I like having privileged syntax too
21:58:30 <avpx> johnw: I'm just kidding.
21:59:36 <Jafet> Bin left right >>= f = error "bah, who needs monads"
21:59:37 <edwardk> johnw: basically having a monad is about being able to smash two structures together in a nice way join :: Monad f => f (f a) -> f a   -- when f = [], thats join :: [[a]] -> [a]  -- we call it concat. it takes a list of lists and makes a list
21:59:52 <edwardk> here join would take a tree of trees and make a tree out of it
22:00:14 <johnw> could i say then that having a monad is about being able to provide your data type to the rest of Haskell with a more abstract "interface"?
22:00:40 <johnw> i mean, once you have a monad for your tree, I can now just fmap a function over all the leaves in the tree, right?
22:00:56 <edwardk> johnw: monad is a very useful interface. we have a ton of combinators you get to use for free the moment you know you have a monad.
22:01:00 <danharaj> That's just Functor. Monad gives you more.
22:01:26 <johnw> what more?
22:01:35 <edwardk> the monad lets me know i can make a tree with one element (return), it lets me know i can substitute trees into trees with >>=
22:01:47 <edwardk> (>>=) :: Tree a -> (a -> Tree b) -> Tree b
22:01:56 <edwardk> thats saying walk down my tree to the tips
22:02:05 <edwardk> find the 'a's there, use it to call my function, and graft a new tree on
22:02:08 <edwardk> at each a
22:02:17 <edwardk> the new extended tree is the result
22:02:17 <johnw> ah, cool
22:02:42 <edwardk> this is what folks have been saying when they said 'monads are about substitution'
22:02:47 <johnw> so monads turn any data type into a more abstract entity, which allows for certain types of transformations?
22:02:55 <edwardk> in the case of the list monad there was a bit of renormalization going on afterwards
22:03:10 <edwardk> (>>=) :: [a] -> (a -> [b]) -> [b]
22:03:28 <edwardk> that takes a list, for each element it builds a list, then it grafts the lists together, but in the process it had to concatenate lists
22:03:43 <latro`a> doesn't work for just *any* data type
22:03:51 <edwardk> so the list monad is doing substitution, and then renormalizing the structure somewhat
22:03:59 <edwardk> a 'free' monad has no such renormalizing step
22:04:15 <latro`a> wait...what?
22:04:31 <latro`a> a free monad still has to make the types line up, right?
22:04:32 <edwardk> monads are sufficiently abstract that you can make monads for many, but not all data types.
22:04:46 <coppro> a free monad has a fun UMP
22:04:46 <latro`a> I think the word is "generic"
22:04:52 <latro`a> not "abstract"
22:05:02 <latro`a> are you saying a free monad's join is basically trivial?
22:05:03 <latro`a> or what
22:05:09 <edwardk> latro`a: yes
22:05:17 <edwardk> latro`a: its 'free' ;)
22:05:42 <latro`a> I guess I need to look at a concrete example and plug in id
22:05:51 <latro`a> into >>=
22:05:52 <edwardk> the free monad does the least it can do to be a monad with the signature it has
22:06:31 <coppro> the same is true for the free X for any X
22:06:38 <edwardk> yep
22:07:03 <coppro> edwardk: so I have not actually studied this far in category theory. But I assume you can formalize free structures?
22:07:15 <latro`a> that much I knew
22:07:16 <edwardk> coppro: yes they are left adjoint to a forgetful functor
22:07:26 <latro`a> about how free is used in math in general
22:07:26 <ddarius> edwardk: Which leads to the next question.
22:07:47 <latro`a> I think the question of "what is a left adjoint, intuitively?" is harder than "what is a forgetful functor, intuitively?"
22:07:48 <ddarius> For the special case of universal algebra, though, there is a fairly clear answer.
22:08:00 <latro`a> but that if you s/intuitively/rigorously, the reverse becomes true
22:08:01 <ddarius> latro`a: You'd either be wrong or right depending.
22:08:31 <edwardk> f is left adjoint to g when (f a -> b) is isomorphic to (a -> g b)
22:08:40 <ddarius> natural in a and b
22:08:52 <edwardk> *nods*
22:08:58 <sinelaw> what's List1?
22:09:03 <edwardk> lets take an example
22:09:05 <sinelaw> @hoogle List1
22:09:05 <lambdabot> No results found
22:09:08 <sinelaw> :(
22:09:14 <latro`a> edwardk, I've seen the definition before
22:09:15 <edwardk> (,) e  and (->) e
22:09:18 <latro`a> I still haven't really grokked it
22:09:23 <edwardk> hence the example
22:09:26 <ddarius> latro`a: You're thinking too much.
22:09:35 <coppro> latro`a: I suggest working your way through a book on category theory
22:09:38 <latro`a> I have
22:09:48 <edwardk> actually what i want to do is use (,e) which isn't legal haskell
22:09:51 <latro`a> not all the way through, but I've read about a third or so of categories for the working mathematician
22:09:52 <edwardk> ut makes a nicer example
22:10:03 <ddarius> That said, thinking in terms of Skolemization helps, at least with connecting the universal arrow approach to the isomorphism of hom-sets appoarch.
22:10:09 <edwardk> so we want to check (a,e) -> b     is isomorphic to a -> e -> b
22:10:14 <edwardk> those should look familiar
22:10:18 <latro`a> never fully internalized naturality or adjoints
22:10:34 <latro`a> yeah that's plenty familiar
22:10:36 <ddarius> latro`a: You really need to internalize naturality.  Adjoints follow from representability.
22:11:14 <edwardk> especially in categories like haskell types
22:11:15 <avpx> I learned category theory up until natural transformations and then went oh god what am I looking at
22:11:21 <ddarius> Mac Lane defined categories so he could define functors so he could define natural transformations.
22:11:24 <avpx> I should probably go get a book
22:11:40 <ddarius> Naturality should be pretty natural to a Haskell programmer.
22:11:41 <edwardk> natural transformations: forall a. [a] -> Maybe a     is a natural transformation.
22:11:50 <latro`a> I am familiar with naturality in the context of Hask
22:11:51 <edwardk> we use it all the time
22:12:16 <avpx> I'm sure we do
22:12:18 <latro`a> a natural transformation in Hask is basically a function that is too polymorphic to use anything beyond the structure of the types in its signature
22:12:25 <edwardk> yep
22:12:36 <ddarius> latro`a: A natural transformation is any (covariantly) parametrically polymorphic function.
22:12:41 <mm_freak> i know what a natural transformation is, but what is "naturality"?
22:12:43 <latro`a> I know
22:12:55 <ddarius> latro`a: There is no "too polymorphic" about it.
22:12:56 <latro`a> my definition is less dense, dd
22:12:58 <latro`a> *ddarius
22:13:02 <edwardk> in category theory it just means you can slide the use of the functor over it for the same reason
22:13:07 <latro`a> it's more handwavy but less dense
22:14:04 <ddarius> latro`a: Other than some qualifications I added, I only removed words from your statement and used a slightly less ambiguous term.
22:14:28 <ddarius> Parametrically polymorphic functions in Haskell are dinatural transformations generally.
22:14:34 <latro`a> I think the main thing that isn't obvious from yours that is more obvious from me is that you can't force a constraint on a
22:14:36 <latro`a> erm
22:14:39 <latro`a> the types involved
22:14:45 <latro`a> s/me/mine
22:15:02 <latro`a> if you do, you get "more structure" than just the signature without the constraint, and can do more stuff
22:15:29 <ddarius> latro`a: What makes you think that makes it not a natural transformation?
22:15:52 <latro`a> not a given function; I'm going the other way
22:16:03 <latro`a> *everything* that is polymorphic enough is natural
22:16:23 <ddarius> I'm saying you can drop the "too" and the "enough".
22:16:44 <latro`a> not quite, because there's stuff you can do with, say
22:16:51 <latro`a> Ord a,Bounded a => [a]->Maybe a
22:16:58 <latro`a> that you can't do with just [a]->Maybe a
22:17:03 <latro`a> (missed parens, w/e)
22:17:14 <ddarius> Yes, that doesn't mean the former aren't natural transformations.
22:17:15 <latro`a> for example, you might take the first argument only if it's smaller than maxBound
22:17:44 <latro`a> erm
22:17:46 <latro`a> s/argument/element
22:17:50 <latro`a> is that natural?
22:18:09 <ddarius> They simply aren't natural transformations between [] and Maybe, or, alternatively, they aren't natural transformations in Hask.
22:18:12 <latro`a> that is: f [] = Nothing; f (x:_) = if x < maxBound then Just x else Nothing
22:18:35 <latro`a> what is that transformation natural between, if anything?
22:19:13 <edwardk> everything, no matter how unnatural, is natural to someone ;)
22:19:26 <latro`a> >.>
22:19:28 <ddarius> latro`a: You could, for example, explicitly add the dictionary arguments reducing to a normal parametrically polymorphic function.
22:19:29 <latro`a> to a category theorist
22:19:52 <latro`a> now you've gotten to an implementation detail I'm not actually familiar with
22:20:49 <danil> latro`a: you can pretend that => is -> and constraints are a record ("dictionary") of all the extra methods you get
22:21:10 <latro`a> hrm, k, interesting
22:23:01 <edwardk> latro`a: my constraints package gives you tools for manipulating those dictionaries
22:23:18 <latro`a> *blink*
22:23:37 <edwardk> mostly just using them to discharge obligations, etc.
22:23:48 <ddarius> Representability is the core idea of (1-)category theory.  To define it, you need categories, functors, natural transformations, and isomorphism, and only those.
22:24:22 <edwardk> it even comes up in my lens library ;)
22:24:41 <edwardk> Control.Lens.Representable
22:25:06 <ddarius> We should really talk about k-posets though rather than n-categories.
22:25:08 <edwardk> using the lenses into a structure as its representation
22:25:12 <latro`a> ....hm
22:25:17 <latro`a> I think...just reading
22:25:31 <latro`a> "the theory of representable functors generalize cayley's theorem"
22:25:36 <latro`a> helps an absurd amount
22:25:55 <edwardk> latro`a: sarcastically or actually?
22:25:59 <latro`a> actually
22:26:03 <edwardk> good =)
22:26:51 <edwardk> heya roconnor
22:27:04 <avpx> Oh, that's neat.
22:27:13 <edwardk> you missed all the shiny new lens goodness
22:27:15 <avpx> I can actually wrap my head around Cayley's theorem :-\
22:27:19 <roconnor> edwardk: hi
22:27:22 <roconnor> edwardk: I'm at SFO
22:27:32 <edwardk> pull 1.2 ;)
22:27:42 <roconnor> edwardk: I've been following the IRC logs
22:27:52 <edwardk> ah
22:27:56 <edwardk> fair nuff
22:28:06 <edwardk> getting iso to work made me giddy
22:28:13 <roconnor> I should download them before boarding
22:28:25 <djahandarie> lens goodness? Does that means we have a lens package that will actually be adopted by people?
22:28:31 <roconnor> it's pretty cute ... or scary
22:28:33 <latro`a> avpx--cayley's theorem is basically just currying
22:28:34 <edwardk> djahandarie: thas the plan
22:28:35 <latro`a> if you think about it
22:28:42 <roconnor> I think I'll add some lenses to colour
22:28:49 <roconnor> if I cannot sleep
22:29:04 <edwardk> that reminds me i need to ship colorimetry
22:29:08 <avpx> latro`a: Apparently I'm not thinking about it the right way.
22:29:15 <ddarius> latro`a: Now look at the type of the Yoneda functor.
22:29:18 <edwardk> djahandarie: http://hackage.haskell.org/package/lens
22:29:23 <roconnor> edwardk: you mean colourimetry
22:29:31 <edwardk> roconnor: =P
22:29:45 <avpx> latro`a: In what way is Cayley's theorem related to currying?
22:29:58 <edwardk> http://en.wikipedia.org/wiki/Colorimetry wikipedia wins ;)
22:30:24 <latro`a> if you think of * as G->G->G instead of G x G -> G, then the subgroup of the symmetric group in question is {g* : g in G}
22:30:50 <edwardk> they used to have a blurb with citation needed next to something that said it was sometimes called colourimetry in british spelling, etc =P
22:30:59 <latro`a> (the underlying set of the subgroup in question, that is)
22:31:51 <latro`a> does that help, avpx?
22:32:19 <djahandarie> edwardk, that looks nice.
22:32:30 <avpx> latro`a: Somewhat?
22:33:01 <edwardk> djahandarie: basically you get lenses, folds, traversals, getters, setters and isomorphisms that you can mash together with . and which can all use the same combinators
22:33:21 <latro`a> basically cayley's theorem is "if G is a group with operation *, then G is isomorphic to {g* : g in G} with operation ."
22:33:23 <edwardk> djahandarie: what it needs is you to write a combinator for newtype ;)
22:33:30 <edwardk> because there is a common pattern of
22:33:40 <edwardk> foo l = getConst . l Const      etc
22:33:40 <avpx> latro`a: Yeah
22:34:03 <djahandarie> Got a name?
22:34:16 <edwardk> i can't add newtype as a dependency for this -- its limited to base, but you can write that combinator in newtype very easily if its not already one of them
22:35:21 <djahandarie> It's not directly a combinator. You can probably twist one of the others into doing it though, but that wouldn't make much sense
22:35:21 <avpx> latro`a: I guess I get it, {g* : g in G} is for each g a bijective function where g is applied
22:35:23 <edwardk> djahandarie: not sure
22:35:26 <ddarius> djahandarie: I think he was trying to fob off the naming onto you.
22:35:27 <edwardk> transposeOf l = getZipList . l ZipList
22:35:40 <edwardk> sequenceOf l = unwrapMonad . l WrapMonad
22:35:43 <hpaste> applicative pasted “increment” at http://hpaste.org/72420
22:36:11 <avpx> latro`a: And those bijective functions form a subgroup of the symmetric group... Okay, I got it.l
22:36:15 <avpx> It took some squinting, but thanks :D
22:36:30 <edwardk> adjust l f = runIdentity . l (Identity . f)
22:36:38 <edwardk> all of these are newtype after newtype
22:36:44 <ddarius> avpx: Now take a category with one object and all arrows isomorphisms and curry the Hom functor
22:37:35 <avpx> ddarius: That's less familiar to me
22:38:23 <djahandarie> I'll think I'll release a new version of the newtype package during hac phi
22:38:34 <djahandarie> I can also probably do that unsafe stuff you want
22:38:42 <edwardk> they are very close to underF and overF, etc.
22:38:47 <edwardk> yay!
22:38:56 <ddarius> Incidentally, as an exercise, for functors between groups represented as categories, what are natural transformations?
22:39:17 <djahandarie> The thing that has been blocking me this entire time is deciding if I want to switch to type families or not. I don't think I do.
22:39:27 <latro`a> I'll throw a blind guess: group homomorphisms?
22:39:32 <djahandarie> Not worth the breakage
22:39:33 <avpx> I'm going to throw another guess
22:39:36 <edwardk> meh, its fine as is
22:39:38 <avpx> Cosets?
22:39:49 * djahandarie nodes
22:39:52 <djahandarie> nods*
22:39:55 <latro`a> pretty sure those have the wrong type, avpx
22:39:58 <avpx> :p
22:40:02 <djahandarie> Off for the night
22:40:08 <edwardk> likewise
22:40:15 <edwardk> having trouble keeping my eyes open
22:40:18 <edwardk> later all
22:41:06 <avpx> latro`a: That's why it's a blind guess
22:41:12 <latro`a> hah
22:41:23 <latro`a> I guess I could've said educated
22:42:53 <avpx> Now to sound outrageously uneducated about category theory: aren't functors themselves sort of like homomorphisms?
22:42:57 <avpx> They're structure-preserving maps
22:43:04 <latro`a> functors are category-homomorphisms
22:43:19 <latro`a> it's not even "sort of", it's exact
22:43:22 <avpx> Okay
22:43:49 <latro`a> note though that they don't have to preserve all the structure, only id and .
22:44:02 <avpx> And when you say "groups represented as categories," what exactly do you mean? The objects are group elements, and the morphisms are {g* : g in G} ?
22:44:59 <danil> avpx: a group can be seen as (exactly) a one-element category where all arrows are isomorphisms (i.e. have inverses)
22:45:04 <latro`a> I'm not sure if he meant that, or the more common category-theory way of looking at them, which is a category with one object (G) and all arrows isomorphisms
22:45:05 <latro`a> bah
22:45:09 <latro`a> ninja'd
22:46:09 <avpx> Once again, hopelessly naive, but how can there be interesting arrows with but one object?
22:46:35 <latro`a> think of the symmetric group
22:46:39 <latro`a> :p
22:46:45 <latro`a> erm, its elements
22:46:54 <latro`a> actually, the whole thing, yeah
22:47:07 <avpx> *sigh* I'm so confused. The arrows are the permutations, right?
22:47:23 <latro`a> yeah, which are functions from G to *itself*
22:47:29 <latro`a> of which there may be many
22:47:31 <avpx> I see.
22:47:47 <avpx> So the object is S_n, and the arrows are, well, elements of S_n
22:47:58 <latro`a> no
22:48:06 <avpx> :(
22:48:17 <latro`a> the object is whatever group we're talking about
22:48:21 <latro`a> the arrows come from S_n
22:48:36 <latro`a> the elements of S_n don't map from S_n to itself
22:48:43 <latro`a> they map from {0,1,...,n-1} to itself
22:48:44 <avpx> Right, okay.
22:48:56 <randomclown> why is it when I run "cabal configure" I get "Configuring test-0.1.0.0... cabal: At least the following dependencies are missing: parsec ==3.1.*", but "cabal install --user 'parsec == 3.1.3'" works fine?
22:49:02 <ddarius> Or the object is a pony.
22:49:08 <latro`a> true
22:49:24 <latro`a> but, staying in the-structure-comes-from-somewhere-land
22:49:32 <avpx> (please be right) the object is G and the arrows are from S_n (by Cayley's theorem)
22:49:33 <latro`a> as opposed to the-structure-is-its-own-thing-land
22:49:39 <latro`a> yes
22:49:57 <avpx> Now can I have my Category Theorist badge?
22:50:02 <latro`a> haha
22:50:11 <latro`a> gotta learn kan extensions first :p
22:50:18 <latro`a> (still no idea what those are even about)
22:50:26 <latro`a> but representability makes sense to me
22:50:35 <slack1256> lambdabot does give badges for learning some Cat.
22:50:36 <lambdabot> slack1256: You have 1 new message. '/msg lambdabot @messages' to read it.
22:50:37 <avpx> I think the part of category theory that's confusing to me is that I have trouble thinking on that level of abstraction.
22:50:51 <avpx> I've conditioned myself to think about groups and group homomorphisms but abstracting that further gets kind of fuzzy for me
22:50:51 <latro`a> this is why hearing "generalizes cayley's theorem" helped me a ton
22:50:57 <latro`a> "what's the concrete example?"
22:51:04 <latro`a> "and what from it is important?"
22:51:08 <latro`a> ^that's how I abstract things
22:51:27 <avpx> It still bothers me that there is a category Cat
22:51:39 <latro`a> that recurses, by the way
22:51:44 <latro`a> indefinitely
22:51:48 <avpx> Yeah, I figured as much
22:51:50 <ddarius> There is a group of groups as much as theory is a category of categories.
22:51:52 <latro`a> (iirc it can even recurse transfinitely)
22:52:03 <latro`a> um
22:52:05 <ddarius> (Which is to say, by size arguments, they don't exist.)
22:52:12 <latro`a> oh
22:52:16 <latro`a> that's what you meant to say in the first place
22:52:18 <latro`a> also
22:52:25 <latro`a> that depends on what you mean by "exist"
22:52:37 <ddarius> How the fuck did I replace "there is" with "theory"?
22:52:43 <latro`a> no idea
22:52:55 <Jafet> Ex. x => False
22:53:05 <Jafet> isGroup x rather
22:53:06 <ddarius> Oh, just "there" with "theory".  That's slightly less bad.
22:53:22 <latro`a> pretty slight, though
22:53:35 <danil> ddarius: (back from the whiteboard)... natural transformations are automorphisms of the target group of the two homomorphisms?
22:53:36 <latro`a> two of those letters are on the wrong hand, lol
22:53:54 <latro`a> wait, *automorphisms*?
22:54:01 <latro`a> they definitely needn't be automorphisms
22:54:16 <latro`a> natural transformations can definitely map between different objects
22:54:24 <ddarius> latro`a: I type Dvorak.
22:54:30 <latro`a> ah
22:54:32 <latro`a> (I do too)
22:54:37 <latro`a> (I tend to assume others don't >.>)
22:54:50 <latro`a> still doesn't explain the "y", though
22:55:29 <danil> latro`a: in the case of groups it seems like a bunch of stuff collapses because there's only one object per category, but I'm not sure
22:55:40 <ddarius> danil: What are the arrows in the categories?
22:55:54 <latro`a> I'm still not sure which category-representation was intended
22:55:58 <latro`a> as there are two
22:56:05 <latro`a> one of which is more insightful than the other
22:56:11 <latro`a> ....sorta
22:56:34 <latro`a> it's the difference between the category representation of a poset, and a poset as it lives in the category of posets
22:56:47 <latro`a> (easier example, as here the former morphisms have no meaning themselves)
22:57:25 * hackagebot egison 2.3.9 - An Interpreter for the Programming Language Egison (SatoshiEgi)
22:57:30 <johnw> ok, so I'm trying to write a tree Monad now as an example
22:57:44 <ddarius> The latter would not typically be described as a "poset as a category".
22:57:45 <johnw> is this right for bind: t >>= f = fmap f t
22:57:52 <latro`a> no
22:57:53 <danil> ddarius: elements of the group right?
22:57:58 <latro`a> that will not have the right type
22:57:59 <ddarius> johnw: Does the type checker say it's right?
22:58:06 <ddarius> danil: Yes.
22:58:36 <ddarius> So, if a natural transformation is an object-indexed family of arrows, what must a natural transformation be?
22:58:39 <latro`a> >>= :: m a -> (a->m b) -> m b; fmap :: (a->b)->m a->m b. so if m,f can be the args to >>=, fmap f t :: m (m b)
22:58:42 <latro`a> != m b
22:59:19 <latro`a> wait, indexed by a collection of objects, or by (the members of) a single object?
22:59:24 <latro`a> oh wait nvm
22:59:33 <latro`a> we're doing the former thing, not with one object
23:00:19 <latro`a> johnw: there is actually a law, m >>= f = join $ fmap f m, where join :: m (m a) -> m a
23:00:31 <latro`a> this is an alternate definition of a monad, in which >>= is not primitive
23:00:44 <randomclown> oh jesus I'm retarded. I didn't run cabal install
23:03:25 <johnw> ok, it dies on this: Node l k r >>= f = Node (l >>= f) (f k) (r >>= f)
23:03:30 <johnw> perhaps my Tree is not Monadable
23:03:38 <johnw> data Tree a = Empty | Leaf a | Node (Tree a) a (Tree a)
23:03:58 <ddarius> johnw: That's isomorphic to a free monad.
23:04:12 <johnw> what does that mean?
23:04:20 <ddarius> It means it's definitely a monad.
23:04:54 <latro`a> johnw: why does that die?
23:04:57 <latro`a> it looks like it should type check
23:05:07 <latro`a> oh wait...I see
23:05:07 <johnw> can't match b with Tree b for the (f k) parameter
23:05:08 <ddarius> Actually I'm not right.
23:05:12 <latro`a> f k is a tree
23:05:13 <johnw> which I *think* makes sense
23:05:18 <latro`a> yes
23:05:19 <latro`a> it does
23:05:23 <latro`a> f k is a Tree b, not a b
23:05:24 <ddarius> If a were b it would be fine.
23:05:28 <johnw> oh, I'm sure it makes sense
23:05:33 <johnw> I'm just wondering if it makes sense to me :)
23:05:50 <ddarius> Wait, wait, I'm being retarded.  I stand by my initial statement.
23:06:04 <johnw> ddarius: so how would you write bind?
23:06:24 <Cale> Better to ask about join, perhaps
23:06:32 <avpx> Maybe it would help to think about join/fmap/return?
23:06:43 <latro`a> join actually looks very much like what you just wrote
23:07:15 <latro`a> (I think)
23:07:16 <Cale> You need  join :: Tree (Tree a) -> Tree a
23:07:24 <johnw> I don't get why Leaf a >>= f = f a type checks, but Node l k r >>= f = Node (l >>= f) (f k) (r >>= f) does not
23:07:25 * hackagebot xml-conduit 1.0.3 - Pure-Haskell utilities for dealing with XML with the conduit package. (MichaelSnoyman)
23:07:36 <Cale> which is going to somehow glue all the trees together in a way which corresponds to the outer Tree structure
23:07:56 <latro`a> johnw: the second arg to Node is an a, not a Tree a
23:08:03 <avpx> So for learning about category theory starting with about a semester of abstract algebra (we covered groups through all the isomorphism theorems, rings through maximal / prime ideals), should I start with the Mac Lane text?
23:08:04 <johnw> ahh
23:08:06 <johnw> that is right
23:08:09 <latro`a> by contrast, "f a" needn't be a new Leaf
23:08:15 <latro`a> that is, leaves could make a new tree
23:08:21 <latro`a> because they're a->Tree b
23:08:25 <ddarius> johnw: That's generally the source of your problems.
23:08:30 <johnw> Should the type constructor be "Node (Tree a) (Leaf a) (Tree a)"?
23:09:09 <latro`a> if it's that, then you can actually >>= everywhere (like you did with left and right), if I understand correctly
23:09:32 <ddarius> But I need to amend my initial statement to this is not a free monad, but it is a monad.
23:09:43 <ddarius> Leaf isn't a type constructor.
23:09:54 <latro`a> ah right
23:10:11 <johnw> oh, so that wouldn't work
23:10:14 <latro`a> wait, do you want elements at every node, or just the leaves?
23:10:24 <johnw> I want values at every node, plus every leaf
23:10:39 <johnw> my sample tree is: Node (Node (Leaf 2) 3 (Leaf 4)) 5 (Leaf 8)
23:12:02 <latro`a> not sure how to fix the data at every node problem; the other case is (as you'd expect) much simpler
23:12:10 <johnw> so, the fact that the middle value of Node is not a Tree, breaks the uniformity needed by Monad
23:12:28 <johnw> since f in that definition is going to return a Tree
23:12:35 <latro`a> Empty >>= _ = Empty; Leaf x >>= f = f x; Node l r >>= f = Node (l >>= f) (r >>= f)
23:12:40 <latro`a> (I think)
23:12:58 <johnw> I guess I can do Node (Tree a) (Tree a) (Tree a), and enforce that the middle Tree is always a Leaf?
23:13:22 <shachaf> What?
23:13:28 <applicative> yipe no!
23:13:41 <johnw> heh, that got it to compile at least
23:13:55 <latro`a> that will typecheck but have the wrong semantics :/
23:13:59 <johnw> yeah
23:14:03 <johnw> i'm not feeling good about it either
23:14:10 <johnw> so what do I do?  Fix the type, or fix >>=?
23:14:12 <ddarius> johnw: Your type is still a monad, it's just not a free monad, so you will need a "renormalization" step just like list which also has that "extra" element.
23:14:21 <johnw> ahh
23:14:24 <latro`a> wait, do you want to apply the function to the node elements?
23:14:27 <nand`> ddarius: Free Tree a would be a monad though; or is that not what you meant?
23:14:31 <latro`a> because...it has the wrong type to be able to do that
23:15:06 <ddarius> nand`: Free Tree would be a different monad.  The question is whether Tree = Free TreeF for some TreeF which is does not.
23:15:53 <ddarius> The first question is: If in Node l x r >>= f = ..., if f x = Empty what should the result be?
23:16:06 <latro`a> Empty, presumably
23:16:13 <latro`a> giving you a way to prune the tree
23:16:29 <latro`a> (sorry, guess it doesn't help if I give answers -_-)
23:16:38 <johnw> i want to make a Tree Monad so I can exemplify what edwardk said, that "monads are about substitution"
23:16:39 <latro`a> (gonna shut up now)
23:17:09 <applicative> cant he distribute the business in the middle of Node l  x r between the left and right?
23:17:12 <Jafet> I thought fmap was about substitutionn
23:17:17 <johnw> I _get_ what having a Tree Functor buys me.  I don't yet get what having a Tree Monad buys me.  I'm trying to get there
23:18:04 <danil> ddarius: ... an element r in D such that forall g in C, F(g) = r G(g) r^{-1}?  (Probably a thing with a name, but my algebra is not really up to snuff)
23:18:22 <ddarius> danil: Yep.
23:18:24 <latro`a> johnw: when you're at a Node, the thing with the right type to pass to f is the value at the node
23:18:38 <latro`a> so try passing x to f, and go through the cases of what patterns you can get from doing so
23:18:47 <johnw> ok
23:18:47 <latro`a> that is:
23:18:50 <latro`a> eh
23:18:57 <latro`a> s/that is://
23:19:10 <ddarius> danil: Yeah, it probably has a name but I'm not sure what it is.  It's no doubt useful.  Now consider, for example, the set of all natural transformations Id -> Id.
23:20:23 <johnw> latro`a: that did it!
23:20:25 <johnw> makeNode l Empty r = Empty
23:20:26 <johnw> makeNode l (Leaf x) r = Node l x r
23:20:26 <latro`a> :)
23:20:30 <johnw> Node l k r >>= f = makeNode (l >>= f) (f k) (r >>= f)
23:20:31 <Jafet> applicative: you can do it in a bunch of ways, but none corresponds to a use of Free (according to darius)
23:20:40 <latro`a> um
23:21:00 <Jafet> I can probably make up some >>= that throws away the result if it doesn't look right
23:21:07 <latro`a> the inner value is a tree?
23:21:11 <Jafet> As long as (>>=return.id) = id
23:21:15 <johnw> the inner value is an a
23:21:24 <johnw> l and r are trees
23:21:26 <latro`a> oh wait
23:21:29 <latro`a> I see what you're doing
23:21:33 <applicative> Jafet: I see why that is now, but there shouldn't be a million available monad instances.
23:21:33 <nand`> johnw: what about makeNode l Node{} r ?
23:21:39 <latro`a> indeed, that
23:21:40 <johnw> i'm stripping away the treeness of the middle value
23:21:50 <latro`a> there is no guarantee that f k is Empty or Leaf
23:21:53 <johnw> What does Node{} do?  I've never seen that syntax
23:21:54 <latro`a> it could be a new Node
23:22:02 <latro`a> what happens then?
23:22:07 <nand`> johnw: Node{} is just (Node _ _ _)
23:22:08 <johnw> latro`a: the universe goes wrong
23:22:21 <latro`a> are you sure you shouldn't be able to fork like that, though?
23:22:24 <johnw> i should throw an error then
23:22:30 <latro`a> what you're saying is that the only thing you can do with your >>= is prune
23:22:31 <latro`a> never expand
23:22:41 <johnw> oh, I see what you mean
23:22:42 <johnw> hmmmmmm
23:22:44 <johnw> let me think on that
23:23:06 <johnw> for l Node{} r, I want l and r to become children of the l and r inside the Node{}
23:23:23 <ddarius> johnw: In general, any solution involving "throwing an error" is wrong.
23:23:25 <johnw> so I need to do tree surgery in that case
23:24:11 <johnw> thanks guys, I'm actually getting this!
23:24:23 <latro`a> I think we've agreed on: Empty >>= _ = Empty; Leaf x >>= f = f x (the latter is actually a monad law)
23:24:25 <johnw> now I need an interesting/compelling use of this monad
23:24:48 <latro`a> (incidentally, without Node, you have Maybe :p)
23:26:01 <johnw> so how's this:
23:26:02 <johnw> makeNode l (Node l' x r') r = Node (makeNode l l' Empty) x (makeNode Empty r' r)
23:26:51 <johnw> now you can insert a new node into the tree
23:27:11 <johnw> maybe it should end with (makeNode r' r Empty)
23:29:26 <johnw> yes, it needs to be (makeNode r r' Empty)
23:29:54 <johnw> or I may need to do value tests to ensure proper structure
23:29:57 <latro`a> ddarius (or others): am I correct in observing that there are quite a few non-isomorphic "tree monads"?
23:30:09 <latro`a> (given the Tree constructors johnw presented)
23:31:00 <applicative> latro`a: do  you mean, different implementations of (>>=) and return, for this type?
23:31:01 <ddarius> latro`a: You also need to consider the laws.
23:31:26 <latro`a> the return >>= relation only affects Leaf
23:31:27 <latro`a> afaict
23:31:33 <latro`a> *relations
23:31:40 <latro`a> oh wait
23:31:53 <latro`a> Node l x r >>= Leaf = Node l x r
23:31:57 <latro`a> *that's* interesting
23:32:44 <latro`a> johnw: that equation may interest you
23:33:07 <danil> ddarius: for groups that's the center (elements conjugation by which is the identity); I don't see what it is in general categories.  A brief wikipedia refresher course seems to indicate that the last thing is (equivalent to) an inner automorphism H on D such that H compose F = G.
23:33:47 <ddarius> danil: I wasn't trying to make a statement about category theory in general.
23:34:47 <applicative> is there a compact formulation of 'the monad laws' with join fmap and return?
23:35:00 <latro`a> it isn't compact, afaik, but it exists
23:35:13 <ddarius> join . return = id, return . join = id, join . join = join . fmap join
23:35:14 <latro`a> the key one is join . return . return = return
23:35:33 <latro`a> join . return is type-constrained id, which is why I wrote it this way
23:35:35 <johnw> latro`a: why would that interest me?
23:36:02 <latro`a> it's a restriction on your >>=
23:36:15 <johnw> why would apply a tree to a tree?
23:36:20 <johnw> s/apply/bind
23:36:21 <latro`a> Leaf is not a tree
23:36:24 <latro`a> it is a function
23:36:29 <johnw> ohh
23:36:46 <johnw> i see, so substituting a node for a leaf simply yields the node
23:36:48 <applicative> wow the wiki page on monad laws ends with a haiku formulation
23:37:18 <johnw> it doesn't type check tho
23:37:25 <latro`a> what doesn't
23:37:32 <johnw> Node l x r >>= Leaf = makeNode l x r, or Node l x r >>= Leaf = Node l x r
23:37:48 <latro`a> that equation won't compile
23:37:53 <latro`a> because you can't pattern match on functions
23:38:18 <ddarius> latro`a: Was stating a law, not providing a definition.
23:38:21 <latro`a> I was saying that if you are binding to Leaf (which will be your return, which is why I noticed it), you will have to not change anything
23:38:25 <johnw> ah, ok
23:38:46 <latro`a> ah I see what you mean I think
23:38:54 <applicative> its just a constraint, your definition must make Node l x r >>= (\x -> Leaf x)  = Node l x r
23:39:05 <ddarius> In the typical formulation of the laws in Haskell, you still need to show (m >>= f) >>= g === m >>= (\x -> f x >>= g)
23:39:34 <latro`a> ime that one sorta falls out
23:39:43 <johnw> oh, I have this rule don't I?
23:39:44 <johnw> makeNode l (Leaf x) r = Node l x r
23:39:45 <ddarius> This is the one that will really constrain/drive your definition.  The other two laws are made true directly with what you have already.
23:39:56 <latro`a> oh, so you do
23:42:03 <latro`a> it occurs to me that that law is where the "substitution" johnw wanted to see in action lives
23:42:41 <johnw> yes, I can see that my f can return any Tree, and the tree it's being bound to will self-transform properly
23:43:44 <ddarius> You haven't proven all of the laws.  Two hold pretty obviously.  The hard one doesn't obviously hold.  I'm pretty sure it won't hold for the definition you currently have.
23:47:21 <johnw> what is the thing before => called in a type declaration?
23:47:52 <latro`a> a constraint
23:47:58 <zzing_> I am creating a C library with the intention of binding it to Haskell. Are there any interface design decisions that I should take note of? (a list would be great here)
23:48:02 <ketil>     Warning: The -fvia-C flag does nothing; it will be removed in a future GHC release
23:48:02 <latro`a> class constraint, to be specific
23:48:10 <ketil> Uh, is this no longer an option?
23:48:47 <ddarius> zzing_: Not any other than the usual ones.  Don't take or return structs by value.  Avoid global mutable state.
23:49:15 <zzing_> ddarius, global state of any kind is not needed. So use pointers for structs always?
23:49:39 <zzing_> My main object is a structure representing an image with a width, height, and pointer to pixel data
23:49:44 <ddarius> ketil: Yep.  It was decomissioned.  Presumably the LLVM backend produces comparable or better floating point code and code in general than the via-C backend.
23:50:04 <ddarius> zzing_: Even for interfacing C with C, you don't want to take or return structs by values.
23:50:06 <ddarius> -s
23:50:34 <zzing_> ddarius tell that to apple :P
23:51:54 <ddarius> zzing_: Is there some reason not to do this in Haskell itself?
23:52:34 <zzing_> ddarius, I am dealing with libpng directly, and expanding into some freetype stuff. I also want to have the C library for future use. Other than that, not explicitly
23:52:45 <ketil> ddarius, but -fasm is the default, so that, too, does nothing?
23:53:18 <ddarius> ketil: Probably if you don't have a conflict flag earlier.
23:53:19 <zzing_> For the image part, is it ideal to have all functions maintain immutable use patterns, so that the 'images' are never actually modified?
23:53:52 <ddarius> zzing_: If you do that you can import the functions as pure functions in Haskell.
23:53:59 <applicative> johnw: I  guess you noted this would be a piece of cake if it were data Tree b a = Empty | Leaf a | Node (Tree b a) b (Tree b a)
23:54:14 <zzing_> ddarius, how can I deal with the clean up of the images when I import them into haskell?
23:54:14 <ddarius> -That- would be a free monad.
23:54:22 <applicative> or the undecorated data Tree b a = Empty | Leaf a | Node (Tree b a)  (Tree b a)
23:54:23 <latro`a> ...
23:54:34 <latro`a> thanks applicative + ddarius, I get free monads now
23:55:02 <zzing_> "free monad" - the thing that has been on /r/haskell for about a week now that I have tried to ignore… :P
23:55:04 <danil> ketil: -fasm is the native code generator, which is the other option aside from -fllvm (and was the other option aside from -fvia-c back when the C backend existed and the LLVM backend didn't)
23:55:10 <latro`a> because now all that bind does is solve the monad law equations
23:55:12 <latro`a> it's like fix
23:56:02 <Nereid> what about
23:56:04 <Nereid> the free monad monad
23:56:06 <ddarius> zzing_: In general, you should just try to write an API that is pleasant to use directly, then it will probably be pleasant to use in Haskell (albeit not as pleasant as a native library.)
23:56:08 <applicative> or the undecorated data Tree a = Empty | Leaf a | Node (Tree a)  (Tree a)  -- rather
23:56:39 <zzing_> ddarius, I will come up with something and then deal with it directly when the haskell bindings are to be written. Thank you much.
23:57:01 <ddarius> zzing_: You can certainly export functions to create and destroy your images which would need to be in IO, but have the operations that operate on the images be pure.
23:57:17 <zzing_> ddarius, that sounds reasonable
23:57:39 <zzing_> I am sure somebody will be around when the binding time comes up
23:57:42 <Nereid> I recently read/realized that monads can be defined for any 2-category (usual monads being monads in Cat).
23:58:10 <ddarius> Nereid: There is also -the- free (2-)monad.
23:58:34 <Nereid> 2-monad?
23:58:45 <ddarius> Monads are an inherently 2-categorical concept.
23:58:51 <Nereid> yes, I know that now.
23:59:00 <Nereid> I don't know why you put 2- on that though.
23:59:04 <zzing_> ddarius, are there certain data types I should use with regards to integers and floating points? So far I am using float, unsigned, size_t, and uint32_t (this last one is for the pixels so has to be that size)
23:59:52 <ddarius> zzing_: You can look in Foreign.C.Types (I think that's the module name), but I believe all C99 types are supported directly.
