00:02:32 <Jafet> Could still write: askyn' k n y = askyn (err >> askyn' (k+1) n y) (return (k, n)) (return (k, y))
00:09:25 <uuytjhgfj> First or best nigger joke you ever heard.
00:09:25 <uuytjhgfj>     How many chimpers remember the first nigger joke you ever heard? If you don't remember the first one, how about the best one.
00:09:25 <uuytjhgfj>     The first one I ever heard...
00:09:25 <uuytjhgfj>     Q: Why is it that so many niggers were killed in Vietnam?
00:09:25 <uuytjhgfj>     A: Because when somebody yelled "Get Down!" the coons all got up and started dancing.
00:09:30 --- mode: ChanServ set +o mauke
00:09:30 --- mode: mauke set +b *!*@teweco-sk.cust.sloane.cz
00:09:35 --- kick: uuytjhgfj was kicked by mauke (uuytjhgfj)
00:10:17 <copumpkin> fun times
00:11:17 <startling> ugh
00:11:34 --- mode: mauke set -o mauke
00:12:02 <mapreduce> Hi.  I'm trying to install cabal-install and so I've run its ./bootstrap.sh
00:13:51 <mapreduce> It's stumbled on zlib because zlib-dev iis not installed.  I have now installed it to ~/lib and ~/include but can't see how to get that down to the scripts for zlib (the Haskell package).  Any ideas?
00:14:25 <sdfhsdgsd>  Cambodians are part nigger?
00:14:26 <sdfhsdgsd>     My colleague at work is Cambodian and every time I say ,"nigga, nig, nigger" or anything stereo typical of a nigger, he gets offended, and states, that he is part Nigger. This guy is Cambodian, born in Cambodia. I tell him shut the fuck up nigger lover. I have to spend 12 hours a day with this fucking nigger lover. Is this true are Cambodians part nigger ?
00:14:33 <sdfhsdgsd> Cambodia was Indo-China. I've met Cambodians before and as a rule they're not niggers. Maybe your coworker is in fact only part Cambodian and one of his parents is guilty of bedding down with an ape?
00:14:33 <sdfhsdgsd> Try asking him.
00:14:34 --- mode: ChanServ set +o mauke
00:14:34 --- mode: mauke set +b *!*@60.13.167.30
00:14:34 --- mode: ChanServ set +o copumpkin
00:14:37 --- mode: copumpkin set -o copumpkin
00:14:47 <Sgeo_> Why are they spamming here?
00:15:20 --- mode: ChanServ set +o copumpkin
00:15:26 <Ralith> boredom
00:15:35 <latro`a> supposedly somebody in ##philosophy upset the guy, but I doubt it
00:15:37 <Ralith> that's usually the reason behind that sort of thing
00:15:50 <mapreduce> Should I repeat my question in this post-spam era?
00:16:02 <copumpkin> probably pre-spam too :)
00:16:34 --- mode: mauke set -o mauke
00:18:08 <ffdfdfdfd> Crackhead NIGGER encounter
00:18:08 <ffdfdfdfd>     one of the misfortunes of working in a fuxated part of town near nigger drive is if you want to go out for lunch.....you are in for exposure to nigger.
00:18:08 <ffdfdfdfd>     Tonight was beyond the normal encounter.
00:18:08 <ffdfdfdfd>     Jack in the box. I go inside. I noticed all I saw was a probable coal burner waiting for food and no bums outside which was quite abnormal.
00:18:08 <ffdfdfdfd>     Well, then the crackhead bum emerges from the bathroom. The usual jigaboo at that store too.
00:18:08 <ffdfdfdfd>     I'm trying to order but all I hear behind me is some crackhead talking non fucking stop to no one right fucking behind me.
00:18:08 <ffdfdfdfd>     I keep stopping and looking at him a few times he backs the fuck up. Fine. The 5th time I just snap on this 6ft tall fecal matter and lose it. I SCREAM. top of my lungs.
00:18:09 --- mode: copumpkin set +b *!~dfgdfgdf@71-12-251-87.dhcp.slid.la.charter.com
00:18:10 --- kick: ffdfdfdfd was kicked by copumpkin (go away)
00:18:36 <barrucadu> At least their nicks are easy to quickly recognise…
00:18:40 --- mode: copumpkin set +s
00:18:44 --- mode: copumpkin set -s
00:19:00 <Ralith> pop AI challenge: Write a bot to heuristically detect them
00:19:07 <copumpkin> I'd do it if I cared more :)
00:19:14 <copumpkin> they don't do this very often
00:19:16 <Jafet> 1) is its IP address american
00:19:27 <copumpkin> Jafet: relays?
00:19:28 <Ralith> mostly it'd be an interesting exercise
00:19:30 <copumpkin> the other one was .cz
00:20:06 <barrucadu> Ralith: Could use a metric of "If the first message doesn't contain a type signature, kickban" :D
00:20:14 <Ralith> hah
00:20:15 <DexterLB> lol
00:20:20 * copumpkin stares at epicmonkey 
00:20:23 <Hermit> Ralith: the keymap should also be considered
00:20:37 <ghorn> i'd be very satisfied if lambdabot kicked these guys
00:21:18 <latro`a> I would actually be entirely OK with a thing in the topic that says "your first message must be the type signature of map or you will be kickbanned by lambdabot" :p
00:21:27 <copumpkin> that'd work if anyone ever read topics
00:21:30 <copumpkin> but they don't
00:21:33 <latro`a> true
00:21:38 <latro`a> well I read topics
00:21:40 <latro`a> >.>
00:21:48 <latro`a> maybe more people should read topics
00:21:52 <startling> I read like the first 100 characters of topics
00:22:05 <Ralith> their first message reliably includes 'nigger' so it's a bit unnecessary anyway
00:22:10 <latro`a> true
00:22:12 <barrucadu> copumpkin: Even better - it'd stop people coming in and asking if Hackage is down when it's in the topic!
00:22:19 <copumpkin> :D
00:22:20 <latro`a> lol
00:22:20 <mauke> Ralith: you dodged a bullet there
00:22:21 <dax> Ralith: way to set off my highlight :P
00:22:22 <DexterLB> lol
00:22:22 --- mode: ChanServ set +o mauke
00:22:22 --- mode: mauke set -b *!*@46.19.226.126
00:22:28 --- mode: copumpkin set +b *!~dfsgsdfgs@8.22.204.138
00:22:28 --- kick: ffdfdfdfd was kicked by copumpkin (No.)
00:22:34 <Nereid> lol
00:22:41 <latro`a> well played sir
00:22:43 <Ralith> nice
00:22:47 <latro`a> 3 seconds
00:23:02 <Hermit> how about making the channel moderated, then when somebody joins, they get +v if they answer some random question from a pool (of course, through PM with lambdabot)
00:23:21 <Ralith> have lambdabot PM them with ':t id'
00:23:22 <Ralith> :D
00:23:28 <mauke> lambdabot doesn't know about channel moderation
00:23:29 <Hermit> yeah, something like that
00:23:37 <latro`a> it could, though, no?
00:23:44 <mauke> patches welcome
00:24:04 <mapreduce> +r (require auth'd users) seems to work for ##java.
00:24:17 <Hermit> moderated is +m
00:24:18 <Ralith> that is the usual solution, come to think of it
00:24:22 --- mode: mauke set -o mauke
00:24:33 <Jafet> I like turtles
00:24:34 <Ralith> freenode even gives you a helpful message if you aren't authed
00:24:39 <copumpkin> we usually consider it too limiting
00:24:44 <copumpkin> but maybe for now
00:24:45 --- mode: copumpkin set +r
00:24:48 <Hermit> Jafet: really!? :3
00:24:51 <mauke> copumpkin: I don't like it
00:25:00 --- mode: copumpkin set -r
00:25:12 <gsdgdsfg> Dumb sow chimps out near me at Sonic (hamburger joint)
00:25:12 <gsdgdsfg>     For those of you who don't know what Sonic is, it's a restaurant chain where you pull up to a stall in your car, order your food through a speaker, and some girl on rollerskates brings it out to you.
00:25:12 <gsdgdsfg>     So I stop in there for lunch today and some dumb negro bitch is about 3 stalls over from me. Her 6 year old niglet is dancing around outside the car (I was really hoping to see her get run over).
00:25:12 <gsdgdsfg>     She was already there when I pulled up. I ordered, and a few minutes later I had my food delivered.
00:25:12 <gsdgdsfg>     I was sitting there enjoying the meal and I notice her little shitskin is still running around outside and the obama-worshipping bitch has a fucking puss on her face and is getting quite agitated.
00:25:12 <gsdgdsfg>     I ordered desert, and several minutes go by before some chick skates up to me with an ice cream sundae.
00:25:13 <gsdgdsfg>     Black whore starts honking her car and yelling to the girl on skates. Girl on skates goes to see what's wrong. I can't hear them but I see some animated conversation (on the part of the human - the ape was flailing her arms). The only word I could make out was "raciss!"
00:25:13 <gsdgdsfg>     As the server skates on by I got out to ask her what the commotion was about. Turns out the dumb jiggaboo never pushed the button on the stall to place an order. She was expecting someone to magically know she was there waiting to order, and convinced no one was helping her because she was black.
00:25:14 <gsdgdsfg>     Fucking CUNT. I would have SHIT in her food if I worked there.
00:25:15 --- mode: copumpkin set +b *!~dfgdfgdsf@pta27-1-88-178-25-84.fbx.proxad.net
00:25:15 --- mode: ChanServ set +o mauke
00:25:15 --- mode: mauke set +b *!*@pta27-1-88-178-25-84.fbx.proxad.net
00:25:16 --- kick: gsdgdsfg was kicked by copumpkin (No.)
00:25:17 <Hermit> ugh
00:25:29 <copumpkin> (brushing teeth)
00:26:27 * dax waves at mauke 
00:26:42 * mauke surfs dax
00:26:44 <Hermit> this is why unreal based irc networks are so much better. It has flood limit modes and default action
00:26:56 <mauke> hah
00:26:59 <mapreduce> Hi.  I'm trying to install cabal-install and so I've run its ./bootstrap.sh
00:27:06 <mapreduce> It's stumbled on zlib because zlib-dev iis not installed.  I have now installed it to ~/lib and ~/include but can't see how to get that down to the scripts for zlib (the Haskell package).  Any ideas?
00:27:15 --- mode: mauke set -o mauke
00:27:30 <mapreduce> That was a repeat because last time was just before a spam.
00:27:56 <Hermit> would have helped if you re-formulated it for those of us who actually read the previous one
00:28:30 --- mode: copumpkin set +m
00:28:32 --- mode: ChanServ set +o mauke
00:28:32 --- mode: mauke set -b *!*@109.121.229.2
00:28:38 --- mode: copumpkin set +b *!~i515i@mail.kreditor.se
00:28:38 --- kick: ftrvxmtrx was kicked by copumpkin (No.)
00:28:40 --- mode: copumpkin set -m
00:28:48 <copumpkin> :P
00:28:54 * Hermit thumbs up
00:28:54 <mauke> copumpkin: probably false positive
00:28:59 <copumpkin> you think?
00:29:01 <dax> agreed
00:29:09 <copumpkin> true
00:29:12 <copumpkin> dammit
00:29:13 <latro`a> judging by the hostname, yeah, looks like it
00:29:22 <latro`a> unban and send a pm?
00:29:27 <dax> plus they're identified, which isn't normal for the recent ones
00:29:27 <mauke> copumpkin: they had a real realname and identified
00:29:31 <copumpkin> boo, I fail
00:29:44 <latro`a> weird name, but still
00:29:45 <mikeplus64> copumpkin: yeah they've been here many times before too
00:29:50 <Nereid> idea
00:29:51 <mauke> well, they only identified after joining
00:29:55 <Nereid> set +r and voice everyone?
00:29:55 --- mode: copumpkin set -b *!~i515i@mail.kreditor.se
00:29:58 <mauke> Nereid: no
00:30:01 <Nereid> k
00:30:01 <mauke> never +r
00:30:06 <Hermit> <hag> is it pointless to apologize?  <V> never...
00:30:08 <Nereid> but voice everyone, so non-authed people can talk too
00:30:14 <dax> Nereid: perhaps you meant +q $~a?
00:30:14 <Nereid> eh
00:30:17 <dax> since +r is ban, not quiet
00:30:20 <copumpkin> ftrvxmtrx: sorry about that
00:30:20 <Nereid> oh ok
00:30:23 <Nereid> that's what I meant then.
00:30:24 <ftrvxmtrx> no problem :)
00:30:29 <valentin> I wonder how the returned function uses the argument as result in Monad ((->) r) where  return x = \_ -> x
00:30:30 <copumpkin> ftrvxmtrx: we have a slew of chimpout people joining with random-looking nicks :P
00:30:31 <ski> ftrvxmtrx : sorry, we thought you were a spammer (having spam problems atm)
00:30:32 --- mode: mauke set -o mauke
00:30:54 <Nereid> valentin: it doesn't
00:31:13 <mikeplus64> valentin: it consumes an argument and ignores it
00:31:23 --- mode: copumpkin set +q $~a
00:31:29 --- mode: copumpkin set -o copumpkin
00:31:34 <valentin> so, x stands for a type?
00:31:48 <Nereid> no, x is a value
00:31:50 <latro`a> no, x is a value there
00:32:04 <ski> valentin : no, `x' is a value of type `a' in `return :: a -> ((->) r a)'
00:32:07 <valentin> ok, thanks
00:32:13 <barrucadu> valentin: eg `return 5` gives the function `\_ -> 5`
00:32:23 <mapreduce> valentin: return x gives a function that always gives x no matter the input.
00:32:30 <valentin> ok, ok, I understand
00:33:42 --- mode: ChanServ set +o mauke
00:33:42 --- topic: set to '["Identify with NickServ to speak","Haskell Platform 2012.2: http://bit.ly/Clv5r","Paste code/errors: http://hpaste.org/new/haskell","GHC 7.4.2: http://is.gd/EllZnn","Haskell News: http://reddit.com/r/haskell","The Haskell programming language http://haskell.org","Logs: http://bit.ly/5mwtRQ"]' by mauke
00:34:08 <latro`a> wait, what are you using to enforce identification?
00:34:12 <frerich> barrucadu: I'm still a beginner, but wouldn't "return 5" give "Monad m, Int x => m x' or so?
00:34:17 <Nereid> latro`a: +q $~a
00:34:23 <ski> latro`a : `+q $~a' apparently
00:34:28 <latro`a> that's not in the channel mode though??
00:34:29 <Nereid> mutes everyone who isn't auth'd
00:34:31 <Nereid> it is
00:34:35 <frerich> barrucadu: And 'const 5' would be basically '\_ -> 5'?
00:34:40 <latro`a> apparently that doesn't get printed by xchat
00:34:45 <Nereid> it's one of the list modes, so you won't see it
00:34:46 <latro`a> because xchat thinks the channel mode is +CLcnpt
00:34:48 <latro`a> ah
00:34:48 <Nereid> analogous to the ban list
00:35:10 <Nereid> /mode #haskell q to see it
00:35:20 <frerich> barrucadu, mapreduce: I think 'return x' doesn't give a function at all
00:35:35 --- mode: ChanServ set +o mauke
00:35:37 <latro`a> in the context of the ((->) r) monad, it does
00:35:38 --- mode: mauke set +z
00:35:53 <latro`a> because the "monadic values" in that monad are functions
00:35:54 <mikeplus64> frerich: they were talking about the ((->) a) monad, which would, but you're quite right just that expression could be any monad
00:36:00 <JoeyA> mauke: Is there enough room for a space after each hyperlink in the topic?
00:36:02 <mikeplus64> and any Num a => a
00:36:11 <copumpkin> mauke: ooh, clever
00:36:14 <mauke> argh, who removed the spaces
00:36:16 <frerich> latro`a, mikeplus64: Aah, oops, that's what I get for trying to be clever just once.
00:36:33 <frerich> latro`a, mikeplus64: I missed that piece of context :-}
00:36:34 --- topic: set to '["Identify with NickServ to speak","Haskell Platform 2012.2: http://bit.ly/Clv5r ","Paste code/errors: http://hpaste.org/new/haskell ","GHC 7.4.2: http://is.gd/EllZnn ","Haskell News: http://reddit.com/r/haskell ","The Haskell programming language http://haskell.org ","Logs: http://bit.ly/5mwtRQ "]' by mauke
00:37:07 <Nereid> oh, +z sounds cool.
00:37:09 --- mode: ChanServ set +o copumpkin
00:37:32 <latro`a> incidentally, cute thing on the note of "function monads": State's >=> is actually basically .
00:37:56 <latro`a> (modulo currying issues)
00:38:18 <latro`a> maybe this is obvious, idk
00:38:34 --- mode: mauke set -o mauke
00:38:36 <Nereid> latro`a: <=< is always composition in the Kleisly category of the monad
00:38:40 <Nereid> Kleisli.
00:38:42 <Nereid> ii.
00:38:48 <latro`a> it is composition in that category, but it's literally composition
00:38:52 <latro`a> in the function category
00:39:00 <latro`a> well, a restricted subset of it
00:39:06 <Nereid> eh.
00:39:08 <latro`a> the (a,s)->(b,s) functions
00:39:34 <Nereid> eh.
00:39:42 <latro`a> (again, after uncurrying and removing constructors)
00:40:04 <Nereid> I'm not sure what you mean, so I'm going to bed.
00:40:12 <latro`a> bah, not function category, meant Hask itself
00:40:36 --- mode: copumpkin set +b *!~ffdgdfg@93.93.199.220
00:40:37 --- kick: fghfdgfds was kicked by copumpkin (No.)
00:40:42 <copumpkin> did anyone else see that?
00:40:44 <Nereid> no
00:40:48 <copumpkin> cool :)
00:40:54 <latro`a> see what
00:41:02 <Nereid> I don't know if the +b is necessary though.
00:41:02 <copumpkin> then I guess +z is working :P
00:41:24 <mikeplus64> copumpkin: see fghfdgfds get kicked?
00:41:26 <mikeplus64> (i did)
00:41:40 <copumpkin> mikeplus64: see the reason he got kicked :P
00:41:42 <Nereid> presumably he spammed the channel, but +z means the spam only was seen by ops.
00:41:46 <copumpkin> yeah
00:41:52 <Nereid> (+z in combination with +q)
00:41:57 <Hermit> copumpkin: what is it anyway?
00:42:04 <mikeplus64> Nereid: oh that's neat
00:42:16 <copumpkin> Hermit: things that are normally silenced by +q are only seen by ops
00:42:49 --- mode: ChanServ set +o mauke
00:43:00 <Hermit> copumpkin: I meant the... aww, I'm tired, mistook your kick line for xzx's quit message. I was wondering what it meant
00:43:48 <Hermit> (they were next to each other and when the screen scrolled I didn't notice and kept reading)
00:44:20 * Hermit is off to bed
00:44:32 <Nereid> I mean it might be sufficient to just kick if the spammer doesn't rejoin instead of quitting
00:44:43 <Nereid> so would produce a bit less noise
00:46:07 <Nereid> right, bed.
00:54:17 --- mode: mauke set -b *!*@111.179.36.166
01:06:11 --- mode: mauke set +b *!*@115.124.64.25
01:06:43 --- kick: fghfdgfds was kicked by mauke (fghfdgfds)
01:08:54 <mauke> hello
01:09:30 --- mode: mauke set -b *!*@teweco-sk.cust.sloane.cz
01:10:32 <mauke> moon1: ?
01:11:24 <mauke> you keep saying "hi"
01:12:30 <ciaranm> and no-one can hear him scream!
01:12:48 --- mode: mauke set +v moon1
01:12:57 <moon1> hhhhhhhhhhhhh
01:13:05 <moon1>  :)
01:14:18 --- mode: mauke set +b *!*@82.201.209.195
01:14:21 --- kick: dfvegdsfg was kicked by mauke (dfvegdsfg)
01:14:33 --- mode: mauke set -b *!*@60.13.167.30
01:14:45 <Sgeo_> What's +z exactly?
01:14:50 <silver> oh a bot attack?
01:14:54 <latro`a> requires identification
01:14:57 <latro`a> not sure what it does if you don't identify
01:15:09 <ciaranm> who did #haskell annoy? i've not seen this elsewhere for once
01:15:12 <silver> looks like only ops can see messages
01:15:18 <dax> Sgeo_: +z allows people who are opped up to read messages that are otherwise blocked by +q, +b, +m, etc.
01:15:19 <mauke> Sgeo_: http://freenode.net/using_the_network.shtml
01:15:34 <ciaranm> kloeri: ^^ we need a hero!
01:16:28 <dax> wat
01:16:54 <ciaranm> nannannan?
01:18:48 -ChanServ(ChanServ@services.)- ski added *!T@* to the AKICK list.
01:18:48 --- mode: ChanServ set -v moon1
01:19:31 -ChanServ(ChanServ@services.)- ski removed *!T@* from the AKICK list.
01:19:41 <ski> (oops)
01:20:47 --- mode: ChanServ set +v moon1
01:21:32 <gspr> With QuickCheck one can, using quantifiers, make tests valid for (say) two input lists of equal length. I'm wondering, though: if I have a type T a that is built from (say) [[a]], where all the [a] lists must be of equal length -- how can I make T a an instance of Arbitrary?
01:22:12 <ciaranm> by using better types
01:22:12 <latro`a> doesn't that actually amount to a Nat-indexed family of types?
01:22:26 <gspr> latro`a: On the type level, yes
01:22:37 <latro`a> so...do it that way instead?
01:22:42 <gspr> latro`a: But my type sadly doesn't encode that presently..
01:22:49 <gspr> so I was hoping I could still enforce it in quickcheck
01:23:42 <gspr> sure, that will be done, but that means there's a lot of code to change, and I don't really have time to attack that right now, so I was hoping for a runtime ("check-time") fix for the purpose of running quickcheck
01:24:05 --- kick: gfhjrhtr was kicked by mauke (gfhjrhtr)
01:24:05 --- mode: mauke set +b *!*@93.99.16.254
01:24:21 <latro`a> out of curiosity--is that automated, mauke?
01:24:35 <ciaranm> mauke is a machine
01:24:39 <mauke> latro`a: yes
01:24:40 <latro`a> erm
01:24:49 <latro`a> I know (s)he is not fully automated :p
01:24:58 <latro`a> might be running a bot in the same client, however
01:25:21 <barrucadu> When you use Haskell enough, you develop cyborg-like speed and powers
01:25:35 <iulian> Heh.
01:25:37 <ciaranm> but only if you have a very large memory
01:26:11 <silver> s/ory/ber
01:26:34 <hpaste> sopvop pasted “patch datatype, can it be done better?” at http://hpaste.org/72053
01:26:44 <sopvop> So, the title says it
01:27:59 <sopvop> I don't like what I have to declare same fields twice.
01:32:06 --- kick: gfhjrhtr was kicked by mauke (gfhjrhtr)
01:32:06 --- mode: mauke set +b *!*@fw.netline.cl
01:33:56 <triyo> Anyone here been using the distributed-process package?
01:34:16 <triyo> I'm trying to use the `call` function but it just seems to hang.
01:40:05 <Lamen> > liftM2 (&&) (/= 'a') (/= 'b') $ 'c'
01:40:06 <lambdabot>   True
01:41:02 <Lamen> why GHCi gave me 'No instance for (Monad ((->) Char))' :(
01:41:30 <quicksilver> Lamen: becuase you don't have the instance visible
01:41:34 <quicksilver> it's in Control.Monad.Instances
01:41:37 <quicksilver> (among other places)
01:43:15 <Lamen> quicksilver: so, it means I don't have Monad instance for function like (/= 'a'), right?
01:43:55 <latro`a> the instance isn't in scope, because the Prelude (and whatever you've imported) doesn't export it
01:44:42 <Lamen> Thank you guys, that solved the problem.
01:45:00 <ski> gspr : you could try first generating two natural numbers, and then generate a "rectangle" from those
01:45:05 <ski> @type \m n -> replicateM m . replicateM n
01:45:07 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> Int -> m a -> m [[a]]
01:46:44 <ski> sopvop : would it be ok if `UserId' could also be patched ?
01:54:00 <gspr> ski: Great, that's an excellent idea! Thanks :)
01:54:37 <ski> (:
01:56:53 <mikeplus64> triyo: i haven't, but you are using the threaded runtime, right?
02:00:20 <triyo> mikeplus64: here is my source if you don't mind have a quick look at: https://gist.github.com/3168948
02:01:07 <ski> sopvop : hm, i think your `getLast $! ...' is the same as `getLast (...)'
02:01:11 <triyo> The source of the startSalve function is in the package: https://github.com/haskell-distributed/distributed-process/blob/master/distributed-process-simplelocalnet/src/Control/Distributed/Process/Backend/SimpleLocalnet.hs
02:02:03 <triyo> The idea is to be able to send the factorial function to the remote slave process.
02:03:40 <triyo> `expect` in the remote slave process waits for the call from the master
02:04:51 <sopvop> ski: Sorry, stopped paying attention to chat :). No, userId shoud not be patched. And that getLast thing I've got from some other place
02:06:41 <merijn> Question: If I run a threaded program (2 forkIO threads) making the runtime spawn more worker threads will slow down performance, why?
02:11:21 <hpaste> sopvop pasted “diff datatype, take 2” at http://hpaste.org/72054
02:14:52 <ski> gspr : hm, perhaps something like `arbitrary = sized $ \n -> do [a,b] <- replicateM 2 (choose (0,n)); liftM MkT ((replicateM a . replicateM b) arbitrary)' ?
02:15:57 <latro`a> what's choose from?
02:16:54 <ski> sopvop : yes, i was pondering something in that vein (except i made `uId' patchable as well) -- instead of `Concrete' you *could* reuse `Control.Monad.Identity.Identity'
02:17:00 <ski> @index choose
02:17:00 <lambdabot> Test.QuickCheck, Debug.QuickCheck
02:17:07 <latro`a> ah
02:17:23 <ski> @type Debug.QuickCheck.choose
02:17:25 <lambdabot> Couldn't find qualified module.
02:17:29 <ski> bah
02:17:37 <ski> @type Test.QuickCheck.choose
02:17:39 <lambdabot> forall a. (Random a) => (a, a) -> Gen a
02:17:48 * ski shrugs
02:17:49 <latro`a> ah
02:18:18 <ski> @type state . randomR
02:18:20 <lambdabot> forall s a. (Random a, RandomGen s) => (a, a) -> State s a
02:18:30 <Nereid> :t state
02:18:32 <lambdabot> forall s a. (s -> (a, s)) -> State s a
02:18:36 <Nereid> duh
02:18:46 <latro`a> why is it lowercase
02:19:04 <Nereid> to hide the State constructor maybe
02:19:04 <ski> because it's not (any longer) a data constructor
02:19:13 <latro`a> well yeah, but it is precisely the constructor
02:19:19 <mauke> there is no constructor
02:19:23 <latro`a> oh?
02:19:31 <mauke> it's a 'type'
02:19:33 <ski> it's `type State s a = StateT s Identity a' now, instead of `newtype State s a = State {runState :: s -> (a,s)}'
02:19:41 <latro`a> didn't know that
02:19:44 <latro`a> I guess that makes sense
02:19:50 <ski> (and we still have `newtype StateT s m a = StateT {runStateT :: s -> m (a,s)}')
02:19:58 <latro`a> right
02:20:27 <sopvop> ski: so, thats what Identity is for! :) Thanks
02:20:29 <mauke> does Data.List have tests?
02:20:48 <Nereid> identities are always a useful thing to have around
02:21:07 --- mode: mauke set +b *!*@99.198.101.10
02:21:10 --- kick: wewarnedyou was kicked by mauke (wewarnedyou)
02:21:28 <Nereid> spammer is still at it?
02:22:41 <ski> sopvop : btw, i would probably rename `a' in `UserData a' to `f' or something :)
02:22:56 <Nereid> huh well, in mtl we have state :: MonadState s m => (s -> (a,s)) -> m a
02:23:14 <Nereid> maybe that's a new thing though
02:23:52 <Nereid> ah, it is.
02:24:55 <ski> so `state . runState :: MonadState s m => State s a -> m a' is an inclusion from `State s' to any `m' in `MonadState s'
02:25:14 <valentin> why do you say that monads are good for stateful computation if any function converts one value into another, which can be similarly considered as transformation of state?
02:25:33 <ski> (hm, no, not `runState', the other way around ..)
02:26:07 <latro`a> focusing on State (and StateT) in particular, they encapsulate the state parameter threading
02:26:27 <ski> (.. or, no, it was right the first time)
02:26:31 <Nereid> it was
02:26:37 <latro`a> yes, it was
02:26:47 <valentin> is it because monads change only part of state?
02:27:03 <Nereid> monads are an abstraction
02:27:11 <Nereid> with convenient notation
02:27:20 * ski still thinks it would be more natural to have `s -> (s,a)' in `State' (and the `randomX' operations) -- and `(w,a)' for the output monad stuff
02:27:32 <valentin> Nereid: so are functions
02:27:46 <Nereid> so are a lot of things
02:28:00 <Nereid> you can't really ask what a monad does in general, I think
02:28:09 <Nereid> but it makes sense to ask what the State monad does
02:28:12 <Nereid> for instance
02:28:23 <ski> valentin : the state monad hides the threading of an implicit piece of state, which isn't (normally) mentioned if you just use the ordinary monadic plumbing operations
02:29:06 <ski> valentin : if you're *just* threading a state, a composition "pipeline" `foo . bar . baz' would work just fine -- but commonly we have more complicated passing of data than that
02:29:40 <latro`a> a state with intermediate "results" which differ from the state
02:29:58 <latro`a> er, a stateful computation with*
02:30:54 <latro`a> the simplest nontrivial example being deterministic random number generation: you have a generator that gets returned every time you call the function, and a number that you get from that call as well
02:30:56 <ski> valentin : consider e.g. the state example at "What the hell are Monads?" by Noel Winstanley in 1999 at <http://web.cecs.pdx.edu/~antoy/Courses/TPFLP/lectures/MONADS/Noel/research/monads.html>
02:31:03 <latro`a> *simplest nontrivial example I can think of
02:31:44 <Nereid> latro`a: I see what you meant by <=< actually being composition for the state monad.
02:32:21 <Nereid> pretty clear. a -> State s b ~= (s,a) -> (s,b).
02:32:35 <valentin> I understand what is meant by "state with intermediate "results" which differ from the state". I just read http://learnyouahaskell.com/for-a-few-monads-more which but it was presented like stateful computation is not possible in functional programming and monads enable this.
02:32:55 <ski>   a -> Cont o b  ~=  (b -> o) -> (a -> o)
02:33:05 <latro`a> State doesn't do anything you can't do in functional programming
02:33:20 <latro`a> (State, the monad, that is)
02:33:28 <ski>   Store s a -> b  ~=  (s -> a) -> (s -> b)
02:33:30 <latro`a> it's awkward, however
02:34:34 <latro`a> because whatever state you're threading, and there might be a lot of it, has to be an argument to every function, even if it doesn't ever get modified
02:34:47 <Nereid> ok, here's my take on this.
02:34:49 <latro`a> er, doesn't get modified by a given function
02:35:05 <Nereid> so say we have regular, pure computations without any mention of state.
02:35:11 <ski> valentin : it is possible. what the state monad does i hide the boiler-plate so you can avoid looking at the boring state-threading/passing details (which are also easy to typo)
02:35:11 <mauke> there can't be a lot of it. there's only one s
02:35:13 <Nereid> so, functions, with types that look like a -> b
02:35:28 <Nereid> now, we want to introduce a state here
02:35:38 <Nereid> so instead of a function a -> b, we want something that does this:
02:35:40 <latro`a> there can't be a lot of variety of it, but you can access previous states
02:35:47 <Nereid> given a state (of type s), and a value of type a,
02:35:53 <latro`a> because of lambda scope and get
02:36:01 <Nereid> we want to be able to produce a value of type b, depending on a as well as the state
02:36:05 <Nereid> and we might change the state as well.
02:36:17 <Nereid> so to me, this looks like a function (s,a) -> (s,b)
02:36:34 <Nereid> right?
02:36:39 <mauke> yes
02:36:44 * latro`a anticipates his point about >=> surfacing shortly :p
02:36:46 * ski looks at valentin
02:36:51 <Nereid> latro`a: I've already noted it.
02:36:51 <Nereid> :P
02:36:58 <Nereid> valentin: right?
02:36:59 <latro`a> I saw, but I mean surfacing in this explanation
02:37:37 <hpaste> killy9999 pasted “Avoiding do notation” at http://hpaste.org/72055
02:37:54 <killy9999> how can I rewrite this code without the do-notation?
02:37:59 <mauke> killy9999: fmap = liftM
02:38:17 <latro`a> lambdabot actually has an @undo
02:38:21 <latro`a> iirc
02:38:21 <killy9999> i tried "fmap f action = action >>= f" but that's not the same..
02:38:21 <Nereid> killy9999: or, desugar the do notation
02:38:31 <latro`a> action >>= return . f
02:38:33 <Nereid> do { x <- f; g } = f >>= (\x -> g)
02:39:06 <Nereid> (hmm, not the same f)
02:39:22 <Nereid> anyway, I don't know where I was going with that state stuff.
02:39:24 <killy9999> latro`a: thanks, that's it!
02:39:30 <Nereid> I guess you can uncurry that to obtain a function a -> s -> (s,b)
02:39:43 <mauke> s/un//
02:39:47 <Nereid> oops.
02:39:55 <killy9999> mauke: thanks, I didn't thought about lifting f
02:40:10 <latro`a> if you want to motivate State via >=>, you can continue without currying
02:40:20 <latro`a> not sure you want to do that, however
02:40:24 <Nereid> indeed.
02:40:45 <Nereid> I really don't know where to proceed from here so I'll stop.
02:40:51 <hpaste> рпп pasted “ии” at http://hpaste.org/72056
02:41:12 <Nereid> cool paste.
02:42:05 <dzhus> how are you gentlemen
02:42:11 <dzhus> is there something like Debug.Trace.trace that can leave marks on .eventlog which I can then see in mah Threadscope?
02:42:19 <Nereid> aw, I was expecting something funnier.
02:42:54 <dzhus> aybabtu?
02:43:01 <Nereid> something like that.
02:43:22 <dzhus> still that greeting never grows old
02:43:33 <latro`a> it's actually kinda hard to motivate making a Monad out of State when (a,s) -> (b,s) and (b,s) -> (c,s) can be composed with just .
02:43:42 <Nereid> latro`a: yeah, that's where I got stuck.
02:44:15 <Nereid> maybe one would have to talk about promoting pure values to stateful things
02:44:34 <Nereid> to get somewhere
02:44:45 <latro`a> you also would have to curry
02:44:50 <Nereid> you would
02:44:51 <latro`a> to back-define >>
02:44:53 <latro`a> *>>=
02:45:42 <Nereid> the answer is probably obvious, but can a monad be recovered from its kleisli category?
02:46:11 <latro`a> yes
02:46:14 <latro`a> er
02:46:18 <latro`a> well
02:46:20 <latro`a> >>= can
02:46:28 <latro`a> I'm not sure if return is built into its kleisli category?
02:46:32 <latro`a> oh wait duh
02:46:33 <latro`a> ofc it is
02:46:34 <latro`a> so yes
02:46:35 <latro`a> it can
02:46:37 <Nereid> return comes from the identity
02:46:47 <latro`a> (or vice versa)
02:46:52 <Nereid> yeah
02:47:00 <latro`a> but yes, I actually asked this earlier
02:47:00 <Nereid> ok, I'm satisfied
02:47:47 <latro`a> m >>= f = f >=> (const m) ()
02:47:49 <latro`a> iirc
02:48:00 <latro`a> I think I have that backwards
02:48:04 <latro`a> yeah I do
02:48:11 <Nereid> whatever it is, it's the obvious thing.
02:48:27 <latro`a> it's that with <=<, I'm fairly sure
02:48:31 <latro`a> the () is superfluous
02:48:32 <Eduard_Munteanu> Oh, that's what you mean by Kleisli category, for a moment I thought it was C_M.
02:48:45 <Nereid> I meant C_M.
02:48:46 <latro`a> er, well, not superfluous, but its value is irrelevant
02:49:21 <Eduard_Munteanu> Mm, are those the same thing?
02:49:34 <Eduard_Munteanu> Wait, yeah, they are.
02:50:52 <latro`a> :t \m f -> f <=< (const m) ()
02:50:54 <lambdabot> forall b (m :: * -> *) c a. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
02:51:00 <Nereid> lol
02:51:01 <latro`a> must have been the other one
02:51:05 <latro`a> :t \m f -> f >=> (const m) ()
02:51:07 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (b -> m c) -> (a -> m b) -> a -> m c
02:51:11 <latro`a> uh
02:51:12 <Nereid> lol
02:51:14 <latro`a> huh
02:51:24 <latro`a> oh
02:51:31 <Nereid> :t \m f -> const m >=> f
02:51:33 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => m b -> (b -> m c) -> a -> m c
02:51:34 <latro`a> :t \m f -> (f <=< (const m)) ()
02:51:35 <lambdabot> forall b (m :: * -> *) c. (Monad m) => m b -> (b -> m c) -> m c
02:51:39 <Nereid> still not quite right.
02:51:40 <Nereid> ok.
02:51:44 <latro`a> parens, derp
02:52:07 <latro`a> the point was, apply (const m >=> f) to anything
02:52:14 <latro`a> and you get m >>= f
02:52:15 <Eduard_Munteanu> return is just 'id' there.
02:52:33 <Nereid> anyway, where was I going.
02:53:06 <Eduard_Munteanu> :t Control.Category.id
02:53:08 <lambdabot> forall (cat :: * -> * -> *) a. (Control.Category.Category cat) => cat a a
02:53:09 <latro`a> I guess the catch is motivating taking an a and getting an s->(a,s) out
02:53:25 <Nereid> well
02:53:28 <latro`a> which isn't a thing that (a,s)->(b,s) do, in the ordinary sense
02:53:37 <ski> killy9999 : `return . f =<< action' looks nicer than `action >>= return . f', imo
02:53:37 <Nereid> so you want to be able to put pure values into a state computation.
02:53:39 <Nereid> this is fine:
02:53:56 <Nereid> a  ~=  () -> a  ---> (s,()) -> (s,a)  ~=  s -> (s,a)
02:54:26 <Nereid> (go via () -> s -> (s,a) if you like)
02:55:38 <Eduard_Munteanu> Or via parametricity.
02:56:07 <Eduard_Munteanu> (you can argue that just adds an identity there, I mean)
02:57:07 <ski> latro`a : "it's actually kinda hard to motivate making a Monad out of State when (a,s) -> (b,s) and (b,s) -> (c,s) can be composed with just ." -- except when you want to name, access, manipulate and pass around the `a',`b',`c', without having to explicitly mention the `s' states
02:57:22 <latro`a> right, there's a motivation out there, definitely
02:57:28 <latro`a> but when you start from (a,s)->(b,s)
02:57:33 <latro`a> it's hard to get to that motivation
02:57:56 <latro`a> whereas starting the traditional way, I found at least you get bogged down in notation
02:58:26 <latro`a> as in, the first legit roadblock I hit when I was starting out wasn't monads in general, it was just being able to *READ* State's >>=
02:58:55 <Eduard_Munteanu> latro`a: don't try reading it, try writing it ;)   (yourself)
02:59:27 <latro`a> I think if I had had to write it I would probably have come up with the join fmap approach, or just threaded state by hand
02:59:35 <Nereid> a question that came up in my mind recently:
02:59:45 <Nereid> a lot of monads are constructed like this:
02:59:49 <Nereid> we write the types we want for return and bind
02:59:59 <Nereid> it turns out djinn can give us unique definitions for those
03:00:14 <Nereid> does it not follow from uniqueness that the monad laws are automatically satisfied?
03:00:28 <Eduard_Munteanu> What uniqueness?
03:00:31 <ski> latro`a : except that it's tedious to have to thread the states as in
03:00:40 <Nereid> Eduard_Munteanu:  unique definitions for the monad operations
03:00:43 <latro`a> I know ski, my point wasn't that I'd do it best
03:00:45 <ski>   newDB db = let (bool1,db1) = addRec rec1 db
03:00:48 <latro`a> it's that I'd have trouble doing it better
03:00:57 <latro`a> erm
03:01:00 <ski>                  (bool2,db2) = addRec rec2 db1
03:01:00 <latro`a> better than my threading state by hand
03:01:02 <latro`a> without a reference
03:01:09 <ski>                  (bool3,db3) = delRec rec3 db2
03:01:21 <Nereid> I should probably think this through a little better.
03:01:21 <Eduard_Munteanu> Nereid: mm, I think they're only unique up to isomorphism, no?
03:01:26 <ski>               in (bool1 && bool2 && bool3,db3)
03:01:30 <Nereid> Eduard_Munteanu: I mean actually unique.
03:01:32 <latro`a> Ithat distinction's unimportant
03:01:35 <latro`a> *that
03:01:38 <Nereid> up to equality.
03:02:06 <ski> latro`a : and i think that could give you the motivation
03:02:21 <latro`a> maybe so, yeah
03:02:32 <latro`a> I think the stronger motivation for me came just recently
03:02:35 <Nereid> @djinn a -> (r -> (a -> r))
03:02:35 <lambdabot> f _ a _ = a
03:02:51 <Nereid> @djinn (r -> (a -> r)) -> (a -> (r -> (b -> r))) -> (r -> (b -> r))
03:02:51 <lambdabot> f _ _ a _ = a
03:02:54 <Nereid> ehh
03:02:55 <latro`a> when I realized how you could build up a little universe inside a state monad computation
03:03:04 <ski> Nereid : note that `djinn' doesn't always give unique results
03:03:08 <Nereid> sure.
03:03:10 <Nereid> but sometimes it does.
03:03:32 <Nereid> and I mean in those situations.
03:03:36 <Eduard_Munteanu> Nereid: consider   data Reader r a = FirstTake (r -> a) | SecondTake (r -> a)
03:03:48 <Nereid> I'm not talking about situations where it's not unique.
03:03:54 <Nereid> like that one.
03:04:23 <ski> @djinn a -> ((a -> r) -> a)
03:04:24 <lambdabot> f a _ = a
03:04:29 <ski> @djinn ((a -> r) -> a) -> (a -> ((b -> r) -> b)) -> ((b -> r) -> b)
03:04:29 <lambdabot> f a b c = b (a (\ d -> c (b d c))) c
03:04:37 <Nereid> oh oops I got all my types wrong.
03:04:44 <Nereid> @djinn a -> ((a -> r) -> r)
03:04:44 <lambdabot> f a b = b a
03:05:02 <Nereid> @djinn ((a -> r) -> r) -> (a -> ((b -> r) -> r)) -> ((b -> r) -> r)
03:05:02 <lambdabot> f a b c = a (\ d -> b d c)
03:05:08 <ski> ok, CPS
03:05:14 <Nereid> that's the one I meant to write.
03:05:50 <Nereid> @djinn (a,a) -> a
03:05:51 <lambdabot> f (a, _) = a
03:06:04 <Nereid> wouldn't actual djinn tell us all the possible definitions?
03:06:05 <Nereid> not just one?
03:06:15 * ski is not sure
03:06:32 <ski> could be (modulo incompleteness)
03:06:56 <Nereid> I'm installing djinn to find out.
03:07:10 <Eduard_Munteanu> You can query lambdabot privately.
03:07:23 <Nereid> it still does the same thing.
03:08:06 <Eduard_Munteanu> Nereid: still, I presume there could be functors where you could fit some return and bind, but that functor isn't a monad.
03:08:30 <Nereid> of course. I'm asking about the situation where there's only one possible definition for return and bind, given the type.
03:08:48 <Nereid> ah
03:08:54 <Nereid> djinn with :set +multi will show them all.
03:08:58 <Eduard_Munteanu> So perhaps you're asking what happens if you have a functor that's a known monad and the definition for those two is unique.
03:09:06 <Nereid> it gives me two possible definitions for (a,a) -> a.
03:09:14 <Nereid> Eduard_Munteanu: I don't know that it's a monad.
03:09:18 <Nereid> if it's a monad then it's obvious.
03:09:28 <ski> Nereid : how about `(a,a) -> (a,a)' ?
03:09:38 <Nereid> ski: that gives 4.
03:10:03 <Nereid> ah.
03:10:06 <ski> ok, so it generates the irrelevant ones, even if there are relevant ones
03:10:11 <Eduard_Munteanu> Though proving uniqueness sounds just as difficult too.
03:10:23 <Nereid> asking djinn for >>= for the continuation monad gives me 6 possible things.
03:10:30 <latro`a> ...huh
03:10:37 <latro`a> that...disagrees with another thing I read, actually
03:10:44 <Nereid> things like
03:10:54 <latro`a> which was that while Cont is complicated, everything about it can be inferred from the signatures
03:10:55 <Nereid> f a b c = a (\d -> b d (\e -> b d (\_ -> c e)))
03:11:17 <latro`a> including the definitions of return, >>=, and callCC
03:11:20 <Eduard_Munteanu> Nereid: what sort of equality do you expect? Functional?
03:11:35 <Nereid> what sorts of equality are there, anyway
03:12:22 <Eduard_Munteanu> Definitional, propositional, functional...
03:12:47 <Nereid> equality as mathematical functions?
03:13:04 <Nereid> (aside from bottom issues?)
03:13:07 <latro`a> equality as mathematical functions isn't computable
03:13:18 <Nereid> who asked for computable
03:13:22 <latro`a> djinn did
03:13:24 <latro`a> presumably
03:13:34 <Eduard_Munteanu> IOW, does it suffice that f a = g a  forall a  implies f == g?
03:13:39 <latro`a> (don't actually know much about djinn)
03:13:40 <Nereid> yes
03:13:54 <Nereid> extensionally equal, then?
03:14:14 <Eduard_Munteanu> Yeah, or functional. Same thing, IIRC, in that context.
03:14:18 <Nereid> k
03:14:40 <Eduard_Munteanu> Extensional can also mean modulo an equivalence, though, but here it's extensional as in extensionality.
03:14:49 <Eduard_Munteanu> *functional extensionality.
03:15:01 <Nereid> duck equality.
03:15:08 <Eduard_Munteanu> Heh.
03:15:13 <merijn> Can anyone with some understanding of the GHC runtime help me figure out why running code with two threads on more worker threads actually slows the code down?
03:16:29 <mikeplus64> merijn: could simply be a matter of resource/cpu time allocation in your OS
03:16:42 <mikeplus64> or hardware limitations
03:17:12 <merijn> ls
03:17:25 <Nereid> I don't know anything, but I thought the RTS was smart enough that you didn't need more worker threads than CPUs.
03:17:48 <merijn> mikeplus64: No, I have two threads and running with 4 runtime workers on a 48 core machine slows me down
03:18:05 <Nereid> that's a lot of cores.
03:18:17 <mikeplus64> merijn: oh, that's odd (maybe ask #ghc?)
03:18:19 <Eduard_Munteanu> Sounds like lock contention perhaps?
03:18:51 <mikeplus64> or a mailing list
03:19:02 <merijn> Eduard_Munteanu: why would there be lock contention? I only have 2 forkIO threads, I would expect performance to remain approximately the same when having idle workers
03:19:35 <merijn> 1 thread is fastest, 2 threads, slightly slower, more slows down even further
03:20:07 <triyo> I have the following... (join . unClosure $ factorialClosure 4) :: Process Int ... how do I putStrLn the Int within the Process?
03:20:11 <quicksilver> merijn: are you talking about capabilities or threads?
03:20:36 <quicksilver> merijn: adding new capabilities does impose a GC overhead - all capabilities have to be active and synchronise to start a GC.
03:20:38 <merijn> quicksilver: I'm talking about running my program with "+RTS -n4"
03:20:39 <triyo> I've plaid with lieftIO
03:20:43 <mikeplus64> triyo: if process is an instance of monadio, then liftIO
03:20:52 <quicksilver> merijn: the '4' in -N4 is capabilities. yes.
03:20:56 <quicksilver> my guess would be GC overhead then
03:21:06 <quicksilver> GC *synchronisation* overhead in particular.
03:21:20 <mikeplus64> triyo: you might be getting bitten by buffering, try hSetBuffering stdout LineBuffering or hSetBuffering stdout NoBuffering
03:21:37 <merijn> quicksilver: That's what I figured, but a slowdown of factor 4 by going from 2 to 4 threads?
03:21:46 <Nereid> triyo: well, what's the problem you're having?
03:21:54 <triyo> Yes it actually derivies MonadIO looking at the source
03:21:55 <quicksilver> merijn: factor of four is surprising, yes.
03:22:44 <triyo> I want to take (join . unClosure $ factorialClosure 4) which is of type Process Int and somehow see whats inside this process.... print the Int part
03:22:58 <triyo> Process is a MonadIO
03:23:11 <triyo> so I tried liftIO but got issues
03:23:16 <Nereid> what issues
03:23:23 <Nereid> what code
03:24:09 <mikeplus64> triyo: if you don't want to use liftIO you can look at Debug.Trace.trace
03:24:32 <Nereid> your_thing >>= \x -> liftIO $ print x
03:24:38 <Nereid> should do it, no?
03:24:44 <triyo> do { r <- (join . unClosure $ factorialClosure 4); liftIO . putStrLn (show r); return r}
03:25:34 <Nereid> well yeah, that'd be a type error
03:25:39 <triyo> Thats what I had... then from there I brute forced 10 different things and nothing worked.
03:25:40 <Nereid> liftIO $ putStrLn (show r)
03:26:21 <mikeplus64> triyo: (or just liftIO (print r) / liftIO $ print r)
03:26:25 <triyo> Sorry type... tried that too
03:26:32 <Nereid> so what goes wrong?
03:26:36 <Nereid> what's the error message?
03:26:36 <triyo> do { r <- (join . unClosure $ factorialClosure 4); liftIO $ putStrLn (show r); return r}
03:26:43 <triyo> => No instance for (Show (Process Int))
03:27:02 <Nereid> ok, so the thing which you thought had type Process Int didn't actually.
03:27:12 <mikeplus64> triyo: try liftIO . print =<< r
03:27:14 <triyo> I don't understand why the <- is not pulling out the int then
03:27:24 <Nereid> double-check the type of (join . unClosure $ factorialClosure 4)
03:27:49 <triyo> => (join . unClosure $ factorialClosure 4) :: Process Int
03:28:01 <triyo> I'm confused
03:28:03 <Nereid> me too.
03:28:20 <Nereid> and you're sure the error is in that code.
03:28:23 <Nereid> and not elsewhere.
03:28:39 <mikeplus64> triyo: can you paste this code somewhere
03:28:44 <Nereid> ^
03:29:48 <triyo> https://gist.github.com/3168948
03:30:17 <triyo> So then in the ghci session, I just run { r <- (join . unClosure $ factorialClosure 4); liftIO $ putStrLn (show r); return r}
03:30:44 <triyo> Unless the monad implementation of Process is broken?? (>>=)!
03:31:13 <mikeplus64> could be
03:31:25 <Nereid> why would that give a type error though?
03:31:26 <triyo> The implementation of Process: http://hackage.haskell.org/packages/archive/distributed-process/0.2.1.4/doc/html/src/Control-Distributed-Process-Internal-Types.html#Process
03:31:39 <merijn> quicksilver: ok, I guess I will just have to profile and see then :\
03:32:02 <triyo> Because the unwrap from the Monad to get the inner value is not happening... or could that even happen
03:32:06 <quicksilver> no.
03:32:08 <Nereid> no.
03:32:14 <quicksilver> >>= cannot have any type other than the type it has
03:32:21 <quicksilver> the implementation can't break the type-checking
03:32:48 <triyo> Process seem to just derive all the types including the MonadIO
03:33:11 <quicksilver> triyo: can you make a paste with what works, and what doesn't work and the exact error you get?
03:33:26 <quicksilver> triyo: I can't reconstruct clearly from the conversation in this channel
03:33:44 <quicksilver> No instance for (Show (Process Int))
03:33:48 <quicksilver> doesn't look like a problem.
03:33:51 <mikeplus64> triyo: i'm trying to compile the code, what package did you get Control.Distributed.Process.Backend.SimpleLocalnet from?
03:33:52 <quicksilver> that looks like correct code
03:34:05 <quicksilver> (but you can't show a "Process Int" in ghci, so that's what you'll get if you type it at the prompt)
03:34:39 <Nereid> but the way it looks, r has type Int
03:34:41 <triyo> mikeplus64: https://github.com/haskell-distributed/distributed-process
03:34:50 <mikeplus64> triyo: i installed distrubted-process
03:35:01 <triyo> Packages are in hackage
03:35:01 <mikeplus64> it doesn't export that
03:35:13 <Nereid> get distributed-process-simplelocalnet too
03:35:20 <mikeplus64> ok
03:35:32 <triyo> Install network-transport + network-transport-tcp
03:35:39 <triyo> too
03:35:55 <Nereid> oaehstdhsj
03:35:56 <Nereid> hahaha
03:35:59 <Nereid> here's the problem.
03:36:08 <Nereid> your whole do {  .... } thing
03:36:10 <Nereid> has type Process Int
03:36:14 <Nereid> ghci doesn't know what to do with that
03:36:23 <quicksilver> you mean, like I said 2 minutes ago?
03:36:40 <quicksilver> that looks like correct code ... (but you can't show a "Process Int" in ghci, so that's what you'll get if you type it at the prompt)
03:36:42 <triyo> Oh no signature so it can't infer?
03:36:50 <Nereid> it infers correctly that it has type Process Int
03:36:54 <quicksilver> no, it's not a failure to infer.
03:36:55 <quicksilver> it's fine.
03:36:57 <Nereid> so it computes a value of type Process Int
03:37:02 <Nereid> ghci can't show it to you
03:37:09 <quicksilver> it's just you can't do anything with a Process Int at the ghci prompt
03:37:14 <Nereid> ^
03:37:21 <quicksilver> ghci can't run it, and can't display it
03:37:24 <triyo> Sure, but I want to pull out the Int part and Show Int
03:37:30 <quicksilver> there is no Int part.
03:37:43 <Nereid> triyo: in ghci?
03:37:54 <Nereid> then you need some way of getting out of the Process monad, into IO.
03:38:04 <triyo> liftIO?
03:38:08 <quicksilver> Process Int doesn't "have an Int part" any more than IO Int "has an Int part"
03:38:08 <Nereid> *no*
03:38:17 <Nereid> triyo: the problem is not inside the do {}
03:38:33 <Nereid> the problem is that the whole do { ... } thing is not an IO action or a Showable value
03:38:36 <Nereid> so ghci can't do anything with it
03:39:00 <triyo> Unless I implement Show Process ...
03:39:05 <Nereid> probably a bad idea
03:39:30 <quicksilver> you won't  be able to implement it usefully.
03:39:39 <quicksilver> you have to 'run' the process to see what the result is
03:40:10 <Nereid> and at that point, there's not much reason to have the print statement inside there
03:40:59 <triyo> I see what you mean
03:41:28 <quicksilver> ultimately you will have to call runProcess
03:41:29 <quicksilver> from http://hackage.haskell.org/packages/archive/distributed-process/0.2.1.4/doc/html/Control-Distributed-Process-Node.html
03:41:31 <triyo> If you want to test the pure factorial function, then just test it ricectly..
03:41:44 <quicksilver> this blog post might help : http://www.well-typed.com/blog/68
03:41:55 <triyo> *directly
03:42:34 <triyo> quicksilver: thanks I've read that post. It was useful.
03:42:37 <quicksilver> :)
03:42:48 <quicksilver> well it shows an example of calling runProcess
03:43:07 <triyo> I don't have issues with calling processes
03:43:09 <triyo> :)
03:43:38 <triyo> I was trying to extract a value for some stupitd reason without running the run... don't ask.
03:44:26 <triyo> So I have working examples of running process. But my issues is that they all are running on a same local node.
03:44:55 <triyo> Now I wish to send my factorial closure, over the network and run the process on the remote node.
03:45:15 <triyo> Haven't seen much on this so having a bit of a hard time.
03:45:35 <triyo> https://gist.github.com/3168948 -> the line 32 just hangs
03:46:05 <triyo> Or rather `waits` for the remote process response.
03:48:50 <mauke> > foldl1 (\x y -> (x + y) / 2) [1, 2, 3]
03:48:52 <lambdabot>   2.25
03:49:53 <Nereid> > foldl1 (\x y -> (x + y) / 2) [1, 1, 1, 1, 1]
03:49:54 <lambdabot>   1.0
03:50:03 <Nereid> duh
03:50:42 <Nereid> > scanl1 (\x y -> (x + y) / 2) [1..]
03:50:43 <lambdabot>   [1.0,1.5,2.25,3.125,4.0625,5.03125,6.015625,7.0078125,8.00390625,9.00195312...
03:51:40 <Nereid> > scanl (\x y -> (x + y) / 2) 0 [1..]
03:51:42 <lambdabot>   [0.0,0.5,1.25,2.125,3.0625,4.03125,5.015625,6.0078125,7.00390625,8.00195312...
03:56:02 <mauke> > foldr (\x z -> x + z * 10) 0 [1,2,3]
03:56:03 <lambdabot>   321
03:58:11 <Nereid> > sum . zipWith (*) (map (10^) [0..]) $ [1,2,3]
03:58:14 <lambdabot>   321
03:58:27 <Nereid> not as efficient.
03:58:58 <Nereid> > foldr (\y z -> y + z * x) 0 [1,1,2,3]
03:59:00 <lambdabot>   1 + (1 + (2 + (3 + 0 * x) * x) * x) * x
03:59:11 <Nereid> > sum . zipWith (*) (map (x^) [0..]) $ [1,1,2,3]
03:59:14 <lambdabot>   0 + 1 * 1 + x * 1 + x * x * 2 + x * x * x * 3
03:59:17 <mauke> > foldr1 (\x y -> (x + y) / 2) [1, 2, 3]
03:59:18 <lambdabot>   1.75
03:59:41 <Nereid> > scanr1 (\x y -> (x + y) / 2) [1..]
03:59:43 <lambdabot>   [*Exception: stack overflow
03:59:45 <Nereid> oop
03:59:52 <Nereid> of course.
04:04:21 <mroman> Is there some sort of shell library/readline library which supports history and such?
04:04:40 <srhb> Haskeline? I think..
04:05:13 <Nereid> I think so too
04:05:16 <mroman> Or should I just use the gnu readline binding?
04:05:22 <Nereid> there's that too
04:05:28 <MasseR> I like haskeline myself
04:05:30 <Nereid> but why not haskeline?
04:07:38 <mroman> Don't know.
04:07:45 <mroman> What's the advantage of using haskeline?
04:09:59 <Cale> Well, for one it's BSD licensed
04:10:09 <merijn> It's written in haskell? Maybe BSD? (Don't know that, but its common for haskell packages)
04:10:39 <Cale> and yeah, it's written in Haskell, so you can hope it's more natural to use than the readline binding
04:11:17 <Cale> I remember having all sorts of issues with it when it was first introduced though.
04:11:33 <Cale> (but that was nearly a decade ago :P)
04:12:02 <Cale> (okay, maybe not, I forget exactly when that was)
04:12:21 <mroman> http://hackage.haskell.org/packages/archive/readline/1.0.1.0/doc/html/System-Console-Readline.html <- looks less complicated than the haskeline example
04:14:17 <mroman> although the functions itself are not documented :(
04:15:51 <Cale> The main difference between that and the Haskeline example is the introduction of a monad transformer for keeping track of the history and settings so you don't have to call addHistory explicitly.
04:16:26 <cads> Hey guys, I'm getting some ominous messages trying to install the orc package.
04:16:27 <hpaste> maxsu pasted “Don't trust the Orcs” at http://hpaste.org/72061
04:16:28 <mroman> It would be cool if I could hook the autocompletion
04:17:19 <cads> it's going to downgrade filepath, and it's telling me some packages are likely to be broken
04:20:00 <cads> I'm tempted to interpret the "likely to be broken" as "naaaah, you're probably good."
04:20:39 <cads> couldn't I just install both versions of filepath?
04:20:43 <Cale> Why are you sudo cabal installing things?
04:21:06 <mroman> hm.
04:21:08 <Cale> It works much better if you only install things as user
04:21:17 <mroman> Haskeline seems to support that very good @auto-completion
04:21:30 <cads> cale, oops
04:22:01 <cads> force of habit from apt-get :P
04:22:26 <cads> I usually install as user
04:23:11 <hpaste> maxsu annotated “Don't trust the Orcs” with “Don't trust the Orcs (annotation)” at http://hpaste.org/72061#a72062
04:23:40 <cads> this is the result of plain cabal install orc
04:24:03 <Cale> hmm... I don't see how it can really break ghc-7.4.1
04:24:10 <Cale> once you're installing as user :P
04:24:19 <Cale> unless you have that installed locally
04:24:42 <Cale> But wait, why does it want to install a new version of array and containers?
04:26:08 <Cale> orc has weird version constraints
04:26:15 <Cale> which are closed at the top end :P
04:26:27 <Cale> (though I doubt it affects anything much)
04:26:42 <Cale> base >= 4.2.0.0 & <= 5.0
04:26:55 <Cale> (so it'd be okay with base 5.0, but not 5.0.1)
04:27:12 <cads> it's some newfangled process / workflow description language from galois
04:27:38 <cads> but it might not be very well maintained?
04:28:15 <Cale> I bet this has something to do with deepseq
04:29:09 <cads> will I plunge deep into dependency hell if I just force reinstall?
04:29:15 <Cale> I don't know why, but that package always has problems
04:29:26 <Cale> You can try it, but I'm going to say "probably"
04:29:36 <cads> eep
04:29:38 <mroman> oh.
04:29:40 <Cale> however, it's only your user-installed packages if you install locally
04:29:48 <mroman> Ok. Haskeline tab completion doesn't kick in after one character :(
04:29:59 <Cale> so at worst you can always just delete your .ghc
04:30:07 <cads> Cale - that's everything
04:30:32 <Cale> Well, you'll still have the global packages, and an installation of GHC which you don't have to repeat
04:30:41 <mroman> Hm it does.
04:30:58 <mroman> Ah. Perfect.
04:31:04 <mroman> Thanks for the haskeline hint.
04:31:57 <Cale> cads: Out of interest, what do you see when you try  cabal install cabal-install ?
04:32:10 <Cale> (Because I currently get a similar warning)
04:32:46 <cads> cale, insteresting
04:32:52 <cads> I see holy hell
04:33:23 <hpaste> maxsu pasted “hell of the holy variety” at http://hpaste.org/72064
04:34:12 <hpaste> Cale annotated “hell of the holy variety” with “hell of the holy variety (annotation)” at http://hpaste.org/72064#a72065
04:35:02 <cads> that doesn't look inviting
04:35:14 <cads> something to do with the recent attack on hackage?
04:35:27 <Cale> There was an attack?
04:35:52 <quicksilver> "array-0.3.0.3 (new version)"
04:36:05 <Cale> yeah, that's the problem, but what's causing it?
04:36:29 <kuribas> Are there any must-have books on haskell?  (I have already read Real World Haskell)
04:36:59 <cads> kuribas, I recommend Mac Lane's categories for the working mathematician
04:37:03 <quicksilver> Cale: I would guess, trying to install cabal-install 0.10.2 or older
04:37:10 <Cale> kuribas: At that point, I would usually just recommend diving into papers by SPJ :)
04:37:11 <quicksilver> which depend on array <4
04:37:23 <quicksilver> kuribas: I would absolutely not recommend Mac Lane.
04:37:28 <Cale> cads: I would recommend Awodey's Category Theory before that :)
04:37:34 <kuribas> ok...
04:38:00 <cads> kuribas, I agree with cale's suggestion re Awodey :)
04:38:20 <cads> quicksilver, mac lane is guten
04:38:24 <Cale> quicksilver: oh, hah
04:38:28 <Cale> quicksilver: that's interesting
04:38:33 <quicksilver> cads: it's fine if you want a reference book on category theory
04:38:43 <quicksilver> it's utterly useless it you want a book on haskell
04:38:51 <kuribas> I am more interested in the practical programming side.
04:38:54 <quicksilver> unless perhaps you also need firewood
04:39:08 <Cale> kuribas: yeah, I think that was a joke suggestion to begin with :)
04:39:16 <quicksilver> kuribas: Hutton, perhaps
04:39:18 <kuribas> ah :-)
04:39:20 <quicksilver> or one of Bird's books.
04:39:25 <mikeplus64> kuribas: lyah has a book, there is also the craft of functional programming
04:39:44 <Cale> http://research.microsoft.com/en-us/people/simonpj/
04:39:53 <quicksilver> very expensive, though, as textbooks tend to be :-(
04:40:28 <kuribas> "Pearls of Functional Algorithm Design" looks very interesting
04:40:29 <Cale> Even just reading the introductory sections to these papers can be quite enlightening :)
04:40:54 <merijn> Cale: Awodey is a better intro than Mac Lane?
04:41:05 <kuribas> I first understood Monads by SPJ's paper on it.
04:41:09 <Cale> merijn: yes
04:41:20 <Cale> http://research.microsoft.com/en-us/um/people/simonpj/papers/stm/stm.pdf -- a rather good one
04:41:29 <mikeplus64> kuribas: but for "practical haskell" usually be best documentation is just library documentation
04:41:47 <kuribas> I want to know how I can organise a complicated program (music notation).
04:42:05 <quicksilver> merijn: Mac Lane isn't an intro, it's a reference.
04:42:29 <[mth]> What, if anything, do people use to do "migrations" or generally manage schema chages when they are using {mysql,postgres}-simple libraries?
04:42:48 <Cale> MacLane is a reasonable intro if you have at least an undergraduate degree in mathematics.
04:42:56 <Ornedan> How do I get the cabal haddock --hyperlink-source to apply when doing cabal install?
04:43:33 <kuribas> Many papers and books show how you can solve a small defined problem, but not how to solve something large and complicated as music notation...
04:43:38 <Cale> But it was written well before Awodey's book, and so things were not as clearly understood at the time, I think.
04:43:46 <cads> awodey aims to be a mathematically self contained intro for an audience of compsci, philosophy, and math undergrads
04:43:59 <Cale> kuribas: Have you read the papers on Haskore?
04:44:11 <quicksilver> kuribas: the general issue of how to organise large programs is not somethign that I have read good books about, to be honest.
04:44:23 <quicksilver> kuribas: (that does not mean such books do not exist - I have not read everything ;)
04:44:44 <Cale> http://haskell.cs.yale.edu/?post_type=publication&p=106
04:44:51 <Cale> http://haskell.cs.yale.edu/wp-content/uploads/2011/01/PTMPaper.pdf
04:44:57 <kuribas> Cale: yes
04:45:21 <kuribas> Cale: It's nice, but for layout you need a lot more information.
04:45:35 <Cale> ah, true :)
04:46:04 <kuribas> For example A flat is not the same as G sharp, and than wether or not you need an accidental depends on the signature, and previous notes in the bar.
04:46:07 <Cale> Typesetting music is a notoriously subtle task
04:46:28 <Cale> (and not just for representational issues like that)
04:46:32 <kuribas> True.  But I think haskell can make it easier to implement the rules.
04:47:27 <kuribas> I think the graphical side is some form of visual constraint solving, but with additional difficulties (such as line and page breaking).
04:47:52 <mauke> has anyone mentioned lilypond yet?
04:47:55 <Cale> quicksilver: Okay, so here's my question: why does cabal-install want to install such an old version of cabal-install which won't even build without breaking packages, when the latest version, 0.14.0, would build and install fine?
04:48:38 <Cale> mauke: I was thinking about it :)
04:49:38 <kuribas> mauke: I once rewrote a part of lilypond because I needed it (the part-combiner).  It was not accepted by lilypond because it was written in a functional style...
04:49:38 <quicksilver> Cale: I don't know but luite's answer has the ring of truth.
04:51:16 <kuribas> I wonder if there is previous work done with graphical constraint solving techniques in haskell.
04:51:40 <kuribas> mauke: lilypond is nice when it works.
04:51:54 <Cale> quicksilver: luite's answer?
04:51:59 <Cale> I don't see his name here...
04:52:08 --- mode: quicksilver set +v luite
04:52:09 <hpc> preflex: seen luite
04:52:10 <preflex>  luite was last seen on #haskell-blah 9 minutes and 48 seconds ago, saying: @tell shapr if you want to install the yesod branch, you need a diagrams-lib that works with data-default 0.4, do this: cabal install cabal-src; cabal unpack diagrams-lib; cd diagrams-lib-0.5; [edit diagrams-lib.cabal, bump version to 0.5.0.1 (from 0.5), constraint on data-default to < 0.5 (from < 0.4)]; cabal-src-install
04:52:11 <preflex>  --src-only; [now install the yesod branch as usual]
04:52:14 <hpc> oh
04:52:17 <luite> pref-ver: cabal-install <0.14
04:52:20 <quicksilver> 12:48 < luite> Cale: the older version is still the preferred one since the  newer hasn't been tested well enough with older ghc versions
04:52:25 <quicksilver> 12:48 < luite> i forgot where preferred versions are specified though
04:52:31 <luite> oh sorry i forgot to identify
04:52:37 <quicksilver> apparently you did :)
04:52:44 <quicksilver> did you get a message about it?
04:52:50 <luite> pref-ver: cabal-install <0.14 <- this is in ~/.cabal/packages/hackage.haskell.org/00-index.cache
04:53:41 <luite> quicksilver: hmm, i don't see one
04:53:58 <quicksilver> maybe +q $~a doesn't give one
04:54:17 --- mode: mauke set -zq $~a
04:54:56 <quicksilver> So in summary: cabal-install 0.14 hasn't been tested with older GHC versions so it's not preferred. As a consequence, newer GHCs cannot install it either without knowing how to manually override that stuff.
04:55:41 <quicksilver> so that advice to maxsu shoudl be, install 0.14 explicitly
04:55:44 <quicksilver> but he's not here any more.
04:56:47 <kuribas> mauke: I want a program that does optimal line/page breaking for music, using hints from the user, and also automatic collision detection, both of which lilypond doesn't do.
04:57:30 * hackagebot cabal-rpm 0.6.0 - RPM package creator for Haskell Cabal-based packages (JensPetersen)
04:58:03 <kuribas> mauke: And different defaults and music font.
05:03:54 <cads> quicksilver, I'm maxsu.. cabal install cabal-install-0.14.0 worked.
05:04:01 --- mode: ChanServ set -v luite
05:05:07 <cads> hrm, this doesn't fix the issue with installing orc
05:05:07 <quicksilver> cads: ah, good :)
05:05:20 <quicksilver> what is the issue with orc?
05:07:29 <quicksilver> I would guess you have deepseq 1.3
05:07:40 <quicksilver> and orc requires deepseq 1.1 or 1.2
05:08:10 <hpaste> maxsu pasted “orc issues” at http://hpaste.org/72066
05:08:14 <cads> quicksilver, it looks a lot like the cabal-install problem
05:09:04 <cads> yeah, it requires deepseq in [1.1.0.0,  1.2]
05:09:41 <quicksilver> yes, so it chooses deepseq 1.1.0.2
05:09:58 <quicksilver> but unfortunately deepseq 1.1.0.2 requires container <0.5
05:10:15 <quicksilver> and array <0.4
05:10:21 <quicksilver> and neither of those is a good idea
05:10:32 <quicksilver> I think if you install deepseq 1.2 first
05:10:35 <quicksilver> and then try orc again?
05:10:49 <quicksilver> (or 1.2.0.1 even)
05:12:58 <hpaste> maxsu annotated “orc issues” with “orc issues (annotation)” at http://hpaste.org/72066#a72068
05:13:48 <cads> what does it mean when a module itself isn't safe??
05:14:17 <quicksilver> that's not really relevant to yoru issues, cads
05:14:28 <quicksilver> I'm afraid I misread the dependencies on deepseq.
05:14:39 <quicksilver> basically, orc won't install on ghc 7.4 without some hackery
05:14:57 <quicksilver> because it depends on a range of deepseq versions which all, effectively, only work on pre-7.4 ghcs
05:14:59 <statusfailed> Hmm, does Text.JSON.Generic not work with "Text"?
05:15:03 <statusfailed> Data.Text that is
05:15:14 <quicksilver> although you got deepseq 1.2 installed it brought in an old array package which I believe ends in tears
05:15:18 <quicksilver> maybe I'm too pessimistic.
05:15:46 <quicksilver> cads: (as to what 'safe' means : http://www.haskell.org/ghc/docs/latest/html/users_guide/safe-haskell.html )
05:17:11 <hpaste> statusfailed pasted “Data.Text and Text.JSON.Generic” at http://hpaste.org/72070
05:17:26 <statusfailed> ^ There's the code i'm using
05:18:20 <luite> just bumping the orc versions bounds is not enough to get it to build with ghc 7.4
05:18:39 <luite> (you need to bump at least deepseq and process)
05:19:09 <quicksilver> luite: can't you use deepseq 1.3?
05:19:16 <quicksilver> (having bumped orcs bounds)
05:19:39 <luite> quicksilver: yeah, but there's still another problem
05:20:01 <quicksilver> oh I misparsed what you were saying
05:20:18 <quicksilver> you were explaining which orcs bounds you bumped, but then saying there was still a problem.
05:22:16 <luite> ok got it installed, here's how: cabal install cabal-src; cabal unpack orc; cd orc-1.2.1.1; [edit orc.cabal, bump version and deepseq+process bounds]; [edit src/Orc/Combinators.hs, add Show a constraint to line 104]; cabal-src-install --src-only; cabal install orc
05:22:59 <killy9999> type a = Int
05:23:10 <killy9999> "a" is called type synonym
05:23:16 <killy9999> what is "Int" called?
05:23:21 <quicksilver> a type?
05:23:21 <Cale> killy9999: It needs to be capitalised
05:23:34 <quicksilver> Cale: maybe it was a metavariable :)
05:23:35 <Cale> type A = Int  would be valid
05:23:44 <killy9999> Cale: yes, but that's not important in that case ;)
05:23:50 <quicksilver> cads: ^^ see luite's answer.
05:24:18 <killy9999> so just a type? no special name for that?
05:24:37 <silver> killy9999, synonimity is commutative in a sense
05:24:50 <silver> I think
05:24:52 <Cale> luite: you forgot the step where you upload your new version of orc to hackage by abusing the infinite power of no permissions restrictions on packages
05:25:01 <quicksilver> in a sense, but it would be strange to call Int a type synonym
05:25:33 <silver> synonymee and synonymer then? :-)
05:26:18 <Cale> Actually, in Haskell 98, the distinction between synonyms and proper datatypes is real
05:26:40 <Cale> In that you can't use type synonyms in instance heads.
05:27:18 <luite> has this been changed in Haskell 2010?
05:28:24 <Cale> I doubt it, let me check
05:28:48 <quicksilver> good point Cale
05:28:57 <cads> thanks guys
05:29:02 <Cale> An instance declaration introduces an instance of a class. Let class cx => C u where { cbody } be a class declaration. The general form of the corresponding instance declaration is: instance cx′ => C (T u1 … uk) where { d } where k ≥ 0. The type (T u1 … uk) must take the form of a type constructor T applied to simple type variables u1, … uk; furthermore, T must not be a type synonym, and the ui must all be di
05:29:02 <Cale> stinct.
05:29:08 <Cale> It's the same
05:29:20 <cads> luite, quicksilver, cale, thanks for the help
05:33:55 <cads> luite, it built
05:33:57 <luite> cads: the cabal-src step isn't really necessary for programs that just build a binary, it registers teh source tarball in a local package repository. but it's very useful if you have to patch some library
05:34:07 <luite> binary -> executable
05:34:34 <quicksilver> cabal preferred versions is a hack
05:34:39 <quicksilver> (not that it was the only problem here)
05:34:54 <quicksilver> since it's hack anyway maybe we should make it an even clunkier hack
05:35:03 <quicksilver> and have it a map of GHC-version => preferred module version
05:35:15 <quicksilver> so that we can agree cabal-install 0.14 is preferred for 7.4.x
05:36:33 <fmap> Is there a way to know if iniGUI was already called in gtk?
05:36:39 <fmap> initGUI*
05:55:25 <qwandor|quassel> what is the equivalent to findIndex for an Array?
05:56:00 <qwandor|quassel> I think I want something like (a -> Bool) -> Array b a -> Maybe b
05:56:37 <Botje> apply findIndex on "indices arr" ?
05:56:40 <tew88> If anyone finds themselves with a few moments to spare, I've posted my questions/misunderstandings relating to Real World Haskell (chapter 9) as comments attached to the following source paste: http://hpaste.org/72071
05:56:55 <Botje> qwandor|quassel: or maybe find + elems arr
05:58:20 <Botje> tew88: look at the type definition of InfoP
05:58:38 <Botje> an InfoP a is a function of four parameters that returns something of type a
05:58:53 <Botje> so if you want to create/return a value of type InfoP a, you need to construct such a beast
05:59:09 <tew88> With you so far!
05:59:12 <Botje> one way to do it i by simply creating a lambda that takes four parameters
05:59:50 <Botje> so \w x y z -> ... == ... "fits" into the InfoP type
05:59:58 <Botje> and since the body is an ==, you return a Bool
06:00:31 <qwandor|quassel> so there is no already defined function to do that? that seems surprising
06:01:12 <Botje> qwandor|quassel: it's confusing in the beginning, but you often have big-enough building blocks that you can just stick together
06:01:42 <Botje> similarly, sometimes people complain about the lack of an uppercase :: String -> String
06:01:49 <Botje> until you point out that's just map toUpper
06:02:19 <Cale> (well, in English it's that simple anyway :)
06:02:36 <Botje> tew88: on line 43, w will be of type FilePath, x :: Permissions, and so on
06:03:51 <Cale> tew88: As for the exception thing,  (\(SomeException x) -> return Nothing)  should work I think
06:04:01 <tew88> Botje: Thank you. I'm tabbing between your analysis and the source -- need to let this sink in :)
06:04:14 <Cale> tew88: If you want to understand the new exception library better
06:04:28 <mroman> Prelude> import Data.SomeModuleWhichDoesNotExist
06:04:29 <mroman> Prelude>
06:04:40 <mroman> ^- Didn't give that an error message in previous ghci versions?
06:04:51 <geekosaur> mroman, known bug fixed in GHC HEAD
06:04:51 <otters> yes it did
06:04:51 <mroman> *that result in
06:04:55 <otters> I've been wondering about that too
06:04:56 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/base-4.5.1.0/Control-Exception.html
06:04:57 <geekosaur> (noted here yesterday)
06:05:06 <tew88> Cale: tyvm :)
06:06:08 * frerich reads C++ code doing 'if (!variant.type() == Variant::String)' and longs for a stronger type system. :-(
06:06:47 <Botje> frerich: the guy who teaches C++ prefers manual typechecks over dynamic_cast. hate.
06:08:19 <sopvop> Noone uses RTTI and dynamic_cast anymore.
06:08:31 <Botje> I do :[
06:08:38 <Botje> manual typechecks are so 1980.
06:09:02 <Botje> what else do you use?
06:09:02 <Guest77595> or 2011 if you wrote javascript seriously
06:09:07 <Botje> boost metaclass or something?
06:10:43 <sopvop> boost::variant, almost ADT with checking for partial pattern matches
06:11:28 <mroman> Can one convert back from a DecimalRaw (Data.Decimal) to where it came from?
06:13:07 <Botje> sopvop: ah, cool.
06:13:39 <qwandor|quassel> Botje: so I have firstMatch f array = case findIndex f (elems array) of; Just i -> Just (indices array !! i); Nothing -> Nothing
06:13:46 <qwandor|quassel> but that looks likely to be inefficient
06:15:35 <byorgey> @tell conal just to be clear, *I'm* the one who originally wrote the project function!  So to the extent that I merit praise for the recent patch, I also deserve blame for the original implementation =)
06:15:35 <lambdabot> Consider it noted.
06:16:07 <otters> can hoogle search for more than packages and functions?
06:16:36 <otters> because if I try to search for a module like Data.ByteString.Char8 it says the query resolves to "Char8 +Data.ByteString"
06:17:07 <Botje> qwandor|quassel: oh, i didn't mean elems then.
06:17:17 <Botje> qwandor|quassel: there's one where you get a list of (i,e) pairs
06:17:22 <Botje> assocs! right.
06:17:34 * hackagebot diagrams-lib 0.5.0.1 - Embedded domain-specific language for declarative graphics (BrentYorgey)
06:17:49 <geekosaur> you might want to look at hayoo instead for that.  http://holumbus.fh-wedel.de/hayoo/hayoo.html
06:17:54 <qwandor|quassel> okay, it still seems like converting the array to a list every time I want to search in it is likely to be inefficient though
06:17:57 <Botje> find (\(i,e) -> ...)
06:18:06 <Botje> qwandor|quassel: well, don't do linear searches in an array then ;)
06:18:18 <Botje> qwandor|quassel: also, haskell will probably fuse that intermediate list away
06:19:05 <Cale> Think of lists as being representations of iteration
06:19:14 <tew88> Botje: Thanks, it's clicked.  Seems like such a silly misunderstanding in hindsight!
06:19:24 <qwandor|quassel> hmmkay, I will try it and see how it works
06:19:36 <Cale> Just as you'd use a loop to iterate over an array in some imperative language, you might use a list to to it in Haskell.
06:19:44 <Cale> do*
06:20:06 <qwandor|quassel> what I am actually trying to do is write a sudoku solver; I started off using lists for everything but it was really slow so I am trying to do it with arrays instead
06:20:18 <qwandor|quassel> in the hope that that might be more efficient
06:20:34 <HugoDaniel> :)
06:20:47 <Cale> Yeah, lists are okay for the iterative parts of that. Using arrays for the boards is probably better. Especially if they're UArrays
06:22:39 <Cale> A loop either doesn't occur, or it consists of a single iteration followed by another loop. A list is either the empty list or it consists of a single element followed by another list.
06:27:46 <Botje> tew88: lots of small clicks make one big click :)
06:28:25 <tew88> Botje: Indeed!
06:30:37 <statusfailed> Does anyone know why Text.JSON.Generic can't serialize Data.Text? Example code: http://hpaste.org/72070
06:30:59 <statusfailed> (I asked before but got no responses so i'm trying again :))
06:32:42 <Saizan> statusfailed: it seems to expect an algebraic datatype rather than an abstract one like Text is
06:33:41 <Saizan> maybe if you make an explicit JSON (or whatever) instance for Text it'll use that instead
06:34:01 <donri> statusfailed: it works with aeson though
06:34:14 <statusfailed> donri: Is that a competing library?
06:34:15 <donri> statusfailed: aeson is generally better if you don't have to use json
06:34:26 <donri> @hackage aeson
06:34:27 <lambdabot> http://hackage.haskell.org/package/aeson
06:34:34 <statusfailed> oh
06:34:37 <statusfailed> no i was just experimenting
06:34:41 <statusfailed> cool, i'll switch
06:34:42 <statusfailed> cheers!
06:36:41 <donri> statusfailed: also you might want to use Data.Aeson.TH instead of generics; TH is compile-time, generics partly runtime (as you just experienced)
06:37:35 * hackagebot fft 0.1.7.1 - Bindings to the FFTW library. (HenningThielemann)
06:39:17 <Qtr> don stewart is making the $$ these days i presume? Is there anywhere else but finance that haskell is used professionally?
06:39:36 <byorgey> Qtr: yes, many places
06:39:39 <ben> there's an up-and-coming monad tutorial industry
06:39:43 <statusfailed> hahaha
06:39:45 <hiptobecubic> :D
06:40:08 <hiptobecubic> I thought don was doing generally "high-reliability" software. Not necessarily all finance?
06:40:17 <donri> to fill the great shortage we're currently experiencing, i presume?
06:40:22 <hiptobecubic> But then again, I don't remember much of anything about it so I don't know.
06:40:29 <byorgey> Qtr: see http://www.haskell.org/haskellwiki/Haskell_in_industry
06:40:32 <quicksilver> Qtr: there is http://www.well-typed.com/ also
06:40:48 <HugoDaniel> cabal: Codec.Compression.Zlib: premature end of compressed stream
06:40:51 <HugoDaniel> :/
06:40:55 <statusfailed> donri: Is that just a factor of generics in general? I'm not familiar with either under the hood
06:40:56 <HugoDaniel> when doing a cabal update
06:41:13 <hiptobecubic> I think there are some startup kind of things in Utrecht here in the netherlands, but then again, they are big on Haskell over there.
06:41:17 <byorgey> Qtr: https://scrive.com/ is a Haskell shop
06:41:33 <donri> http://corp.galois.com/ is this finance?
06:41:38 <byorgey> donri: nope
06:41:51 <donri> http://www.silkapp.com/ these folk use haskell
06:41:54 <statusfailed> galois do embedded stuff
06:45:27 <Qtr> some french gaming company building gameworlds announced for C/Python/haskell dev once
06:46:37 * frerich also had the impression that Haskell is often used among "Quants"
06:46:52 <quicksilver> I suspect so, but quants never talk :)
06:47:19 <frerich> Yeah... :-]
06:49:06 <statusfailed> I know there's lots of F# getting used
06:49:09 <statusfailed> and Ocaml
06:49:32 <Qtr> and arc-lisp! oh wait no that was not correct.
06:50:33 <covi> Can someone point me to the "typeclass encyclopedia" entry that contains a nice little diagram?
06:50:41 <bitonic> Erlang is quite popular, but that's quite different from Haskell/OCaml/F#
06:50:49 <Qtr> So I might buy a raspberry and get some linux going on it. How is the support for different linux distros? Like what does ghc need to be able to compile ? what must be there in linux?
06:50:53 <byorgey> @where typeclassopedia
06:50:53 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
06:50:56 <byorgey> covi: ^^^ that?
06:50:58 <bitonic> @google haskell typeclass hierarchy
06:51:00 <lambdabot> http://stackoverflow.com/questions/6528770/haskell-typeclass-hierarchy-issue
06:51:00 <lambdabot> Title: Haskell typeclass hierarchy issue - Stack Overflow
06:51:12 <bitonic> ops.  no.
06:51:16 <silver> Qtr, support varries
06:52:08 <bitonic> byorgey: I think that covi is referring to the graph with the numeric typeclasses
06:52:31 <byorgey> covi: which diagram are you referring to?
06:52:47 <bitonic> ah no, the typeclassopedia has a diagram as well.
06:52:56 <bitonic> so he's probably referring to that.
06:52:56 <byorgey> right, but a different one
06:53:43 <Qtr> silver: but lets say i want to do linux from scratch , what do i have to include to be able to compile haskell?
06:53:47 <bitonic> I've personally never seen all the std typeclasses in one disconnected graph.  maybe it exists somewhere.
06:54:11 <byorgey> not that I know of.
06:54:31 <silver> Qtr, http://hackage.haskell.org/trac/ghc/wiki/Building/Preparation/Linux
06:54:52 <covi> byorgey: yeah!
06:55:07 <covi> byorgey: thank you for your lin
06:55:07 <silver> Qtr, http://hackage.haskell.org/trac/ghc/wiki/Building/Preparation/Tools
06:55:09 <covi> *link
06:55:40 <silver> and for more general questions: http://hackage.haskell.org/trac/ghc/wiki/Building
06:59:02 <Cale> Qtr: In order to compile GHC, you basically need a GHC binary, unless you're up for bootstrapping. So I wouldn't recommend compiling it yourself unless you have a good reason to.
07:00:21 <Qtr> but if i have ghc binary why would i want to compile ghc?
07:00:52 <Cale> exactly
07:01:08 <Cale> You'd only want to compile it if you were hacking on it
07:01:28 <Cale> So, there's no point in compiling GHC yourself if that is not the case.
07:02:15 <Qtr> how big is ghc?
07:02:23 <Qtr> MB
07:02:34 <jfischoff> src?
07:02:45 <Cale> http://www.haskell.org/ghc/download_ghc_7_4_2#x86linux
07:03:14 <Qtr> compiled
07:03:40 <Cale> (It says on that page) 117MB compressed
07:04:39 <kaol> https://buildd.debian.org/status/logs.php?pkg=ghc&ver=7.4.1-4&arch=i386 says that it took 3GB to build it for Debian unstable. Something like that.
07:05:24 <Cale> I'll unpack the binary distribution now
07:05:24 <covi> @src (<-)
07:05:25 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
07:05:38 <Cale> (<-) isn't an operator, but it's part of the syntax in a couple of places
07:05:48 <covi> Is (<-) a function or a part of the special Monad syntax?
07:06:00 <Cale> It's part of do-notation
07:06:02 <covi> Cale: ah,
07:06:08 <Cale> as well as part of the syntax of list comprehensions
07:06:40 <Qtr> but i guess it doesnt matter. im gonna buy a raspberry pi or beagleboard (embedded starter kit) but i guess i could compile programs perhaps on ubuntu and then transfer via sdcard to the raspberry, i dont have to run ghc on the raspberry, just some basic linux veersion
07:06:46 <Cale> (It can't be a function because it binds a pattern)
07:07:22 <donri> and view patterns!
07:07:37 <donri> or was it pattern guards
07:07:39 <Cale> The 117 MB tarball of GHC uncompresses to 716 MB. I'm not sure what the installed size is exactly.
07:07:46 <Cale> oh yes
07:07:57 <donri> and monad comprehensions ;)
07:07:59 <Cale> <- is also part of the syntax of pattern guards
07:08:15 <Cale> I think view patterns have the other arrow though
07:08:49 <jfischoff> never seen view patterns in the wild
07:08:58 <Cale> me neither
07:09:30 <t7> how do i reverse factorial?
07:09:35 <t7> is there a quick way?
07:09:53 <jfischoff> it would be cool to see a syntax usage distribution chart based on hackage
07:09:53 <byorgey> > reverse "factorial"
07:09:54 <lambdabot>   "lairotcaf"
07:10:16 <jfischoff> ba-dum-ching
07:10:34 <Cale> t7: Probably the easiest thing is just to compute factorials until you find one which is larger or equal to the number you have.
07:10:55 <Cale> because factorial grows quickly, the likelihood is good that you won't have to compute too many
07:11:12 <byorgey> and if you're computing consecutive factorials, you can even do better than just calling the 'factorial' function repeatedly
07:11:17 <byorgey> just multiply each factorial by the next integer
07:11:17 <Cale> Indeed
07:11:26 <Cale> > scanl (*) 1 [1..]
07:11:27 <lambdabot>   [1,1,2,6,24,120,720,5040,40320,362880,3628800,39916800,479001600,6227020800...
07:11:32 <jhance> Is there a simple way to get the Status of a HTTP response with http-conduit? I can't find it somehow but I feel like it should be there...
07:11:46 <byorgey> then  zip [1..]  and takeWhile, and voila!
07:11:56 <byorgey> zip [0..] of course
07:11:59 <byorgey> something like that =)
07:11:59 <t7> @hoogle find
07:12:00 <lambdabot> Data.List find :: (a -> Bool) -> [a] -> Maybe a
07:12:00 <lambdabot> Data.Foldable find :: Foldable t => (a -> Bool) -> t a -> Maybe a
07:12:00 <lambdabot> Data.List findIndex :: (a -> Bool) -> [a] -> Maybe Int
07:12:09 <byorgey> oh, or just findIndex
07:12:32 <Cale> > findIndex (>= 10000000) (scanl (*) 1 [1..])
07:12:34 <lambdabot>   Just 11
07:13:03 <Cale> You could also use findIndex with == if you want to know whether or not the number in question is a factorial.
07:13:26 <Cale> oh, er, no you couldn't :P
07:13:38 <Cale> Of course, findIndex doesn't know that the list is monotone :P
07:13:40 <t7> > find ((115792089237316195423570985008687907853269984665640564039457584007913129639936 <=) . fact) [1..]
07:13:41 <lambdabot>   Not in scope: `fact'
07:14:07 <t7> @let fact n = if n == 1 then 1 else n + fact (pred n)
07:14:09 <lambdabot>  Defined.
07:14:10 <Cale> > findIndex (>= 115792089237316195423570985008687907853269984665640564039457584007913129639936) (scanl (*) 1 [1..])
07:14:11 <t7> > find ((115792089237316195423570985008687907853269984665640564039457584007913129639936 <=) . fact) [1..]
07:14:11 <lambdabot>   Just 58
07:14:15 <lambdabot>   mueval-core: Time limit exceeded
07:14:57 <Cale> (but you could use dropWhile to do that)
07:15:03 <t7> fact 58
07:15:06 <t7> > fact 58
07:15:08 <lambdabot>   1711
07:15:12 <Cale> ...
07:15:20 <Cale> > product [1..58]
07:15:22 <lambdabot>   235056133128287857182947491051507468382886231818114292442069991424000000000...
07:15:55 <t7> i dont mean fact i mean 1 + 2 + 3 .. n
07:15:57 <t7> whats that called
07:16:08 <t7> > findIndex (>= 115792089237316195423570985008687907853269984665640564039457584007913129639936) (scanl (+) 1 [1..])
07:16:10 <statusfailed> arithmetic series?
07:16:10 <Cale> The nth triangular number
07:16:12 <lambdabot>   mueval-core: Time limit exceeded
07:16:49 <Cale> which is also written (n;2)
07:16:59 <quicksilver> well triangular numbers have a simple algebraic formula which is quite simple to invert
07:17:01 <Cale> The binomial coefficient n choose 2 :)
07:17:04 <t7> that should be how many different inputs before a sha256 collision on average, right?
07:17:21 <Cale> wat
07:17:35 <Cale> uh, I sure hope not!
07:17:52 <t7> assuming its random
07:17:54 <Cale> Unless n is very large
07:19:13 <t7> i think i mean half 2 ^ 256 rather than 2 ^ 256
07:20:37 <Taneb> Am I the only person who loves playing with Cofree and Free?
07:20:58 <Cale> Taneb: I'm pretty sure you're not alone.
07:21:01 <Taneb> AND KNOW I'VE JUST HEARD OF TAGGED UNION FUNCTORS AND PRODUCT FUNCTORS
07:22:59 <trem> can I somehow use "+RTS -N" with ghci or even "runhaskell"?
07:24:27 <Cale> trem: yes
07:24:57 <trem> Cale, cool, can you tell me how? I just keep getting that the program must be compiled with "-threaded"
07:25:11 <Cale> Uh, was your ghci not compiled with -threaded?
07:25:18 <Cale> Mine was
07:25:23 <t7> @binarySearch
07:25:24 <lambdabot> Unknown command, try @list
07:25:35 <trem> Cale, don't really know, I'm using haskell platform from fedora 17
07:26:38 <donri> works for me with ghci from fedora 18
07:26:51 <jhance> trem: If it says it must be compiled with -threaded then it probably wasn't compiled with -threaded
07:27:43 <trem> jhance, makes sense. so i'll just stick with the extra compile step
07:29:26 <Cale> Super Mario World has such amusing bugs :) http://www.youtube.com/watch?v=9U8skOGekgo
07:33:50 <covi> @src foldr
07:33:50 <lambdabot> foldr f z []     = z
07:33:50 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
07:34:00 <t7> > (2 :: Integer) ^ 3
07:34:01 <lambdabot>   8
07:34:17 <Cale> > 2^256
07:34:19 <lambdabot>   115792089237316195423570985008687907853269984665640564039457584007913129639...
07:34:20 <_kostya> let x y = sort (map (toUpper y)) in x "HellO"
07:34:24 <t7> what type class is that?
07:34:34 <Cale> typeclass?
07:34:37 <Cale> :t (^)
07:34:38 <lambdabot> forall a b. (Num a, Integral b) => a -> b -> a
07:34:43 <_kostya> Couldn't match expected type `a -> b' against inferred type `GHC.Types.Char'
07:34:56 <covi> Does foldr mean 'fold from right' or 'fold to the right'
07:35:06 <Cale> _kostya: surely you mean sort (map toUpper y)
07:35:20 <_kostya> oh
07:35:21 <_kostya> ok
07:35:26 <_kostya> I guess I do, heh
07:35:28 <Cale> covi: It means right associative fold
07:35:59 <Cale> foldr (*) z [1,2,3,4] = 1 * (2 * (3 * (4 * z)))
07:36:38 <covi> Cale: I see. That's what I meant by 'fold from right'
07:36:58 <Cale> foldr is the more natural of the two
07:37:08 <Cale> because lists are already right associated
07:37:29 <Cale> [1,2,3,4] is just syntax for 1 : (2 : (3 : (4 : [])))
07:37:52 <Cale> So you can think of foldr f z as being the function which replaces each (:) in the list with f and the [] at the end (if any) with z
07:39:11 <covi> Cale: I see. Thanks
07:40:47 <shapr> Good Morning #haskell!
07:40:47 <lambdabot> shapr: You have 3 new messages. '/msg lambdabot @messages' to read them.
07:40:50 <shapr> Whoa
07:41:01 <byorgey> good morning shapr!
07:41:08 <byorgey> shapr: I uploaded a new diagrams-lib for you
07:41:10 <shapr> Good morning byorgey!
07:41:13 <shapr> Whoa, really? yay!
07:41:17 * shapr bounces cheerfully
07:41:19 <donri> trem: my first blog post, written just now, just for you: http://dag.github.com/blog/2012/07/24/latest-haskell-platform-on-fedora-17/
07:41:21 * shapr downloads
07:41:51 <byorgey> shapr: all I did was bump the data-default upper bound, since luite said you were having issues with that
07:41:59 <shapr> Thanks!
07:42:04 <byorgey> sure!
07:45:33 <trem> donri, great! I've already asked for this here some days ago. :-)
07:46:27 <trem> donri, that's surprisingly few commands
07:46:28 <covi>  > pure []
07:46:46 <covi> pure []
07:46:50 <covi> > pure []
07:46:51 <lambdabot>   No instance for (GHC.Show.Show (f [a]))
07:46:52 <lambdabot>    arising from a use of `M61610742...
07:47:05 <covi> > pure [] :: [a]
07:47:07 <lambdabot>   Couldn't match expected type `a1' against inferred type `[a]'
07:47:07 <lambdabot>    `a1' is a ...
07:47:14 <covi> > pure [] :: [Int]
07:47:16 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
07:47:16 <lambdabot>         against inferred type ...
07:47:26 <donri> trem: :)
07:47:30 <covi> My question is, is pure [] just [[]]?
07:48:08 <donri> covi: for [a], yes
07:48:21 <_kostya> how to use lambda bot?
07:48:26 <BMeph_>  > pure []==[[]]
07:48:30 <_kostya> > let a = 10 in a * 2
07:48:30 <lambdabot>   20
07:48:31 <donri> well, for []
07:48:36 <_kostya> cool
07:49:02 <_kostya> > let x y = sort (map toUpper y) in x "Tony"
07:49:03 <lambdabot>   "NOTY"
07:49:05 <covi> donri: thanks
07:49:14 <donri> @check \x -> pure [x] == [[x]]
07:49:16 <lambdabot>   "OK, passed 500 tests."
07:49:39 <donri> @check \x -> (pure . pure) x == [[x]]
07:49:42 <lambdabot>   "OK, passed 500 tests."
07:49:59 <trem> donri, event better, it actually works. thanks again. :-)
07:50:04 <donri> \o/
07:50:26 <_kostya> > 4 * 4
07:50:27 <lambdabot>   16
07:51:06 <_kostya> let (a:b:c:[]) = "xyz" in a
07:51:07 <covi> :t sequenceA [(+1),(*2)]
07:51:08 <lambdabot> Not in scope: `sequenceA'
07:51:11 <_kostya> > let (a:b:c:[]) = "xyz" in a
07:51:12 <lambdabot>   'x'
07:51:23 <covi> :t Control.Applicative.sequenceA [(+1),(*2)]
07:51:24 <lambdabot> Not in scope: `Control.Applicative.sequenceA'
07:51:32 <covi> :l Control.Applicative
07:51:39 <covi> :m +Control.Applicative
07:52:31 <quicksilver> :t Data.Traversable.sequenceA
07:52:32 <lambdabot> forall (t :: * -> *) (f :: * -> *) a. (Data.Traversable.Traversable t, Applicative f) => t (f a) -> f (t a)
07:52:50 <covi> quicksilver: so sequenceA is in the Data.Traversable module?
07:53:19 <quicksilver> as far as I recall
07:53:24 <quicksilver> @hoogle sequenceA
07:53:24 <lambdabot> Data.Traversable sequenceA :: (Traversable t, Applicative f) => t (f a) -> f (t a)
07:53:24 <lambdabot> Data.Foldable sequenceA_ :: (Foldable t, Applicative f) => t (f a) -> f ()
07:58:03 <covi> So why :t sequenceA [(+1),(-2)] is a -> [a]?
07:58:30 <covi> Isn't it 'a list of functions', instead of a function that takes a value and returns a list of values
07:59:14 <quicksilver> [(+1),(-2)] is a list of functions, yes.
07:59:26 <quicksilver> what did you expect 'sequenceA' to do to it?
07:59:51 <covi> Isee. Combine them into a single function
08:00:07 <nart> hi
08:00:12 <quicksilver> well, sequenceA takes [r -> x] into r -> [x]
08:00:24 <covi> In confusing moments like this, should I think intuitively or rationally
08:00:24 <Eduard_Munteanu> nart: hi
08:00:30 <quicksilver> in general sequence A "pushes" a traversable down through an applicative
08:00:41 <quicksilver> in this instance it "pushes" the list "through" the function arrow
08:00:44 <nart> i'm trying to understand when it's better ot use strict and when it's better to use lazy bytestring but i'm stuck .. any tips ? :)
08:00:51 <Eduard_Munteanu> :t strength
08:00:52 <lambdabot> Not in scope: `strength'
08:01:04 <Eduard_Munteanu> Grr.
08:01:32 <Eduard_Munteanu> nart: strict bytestrings are always loaded entirely in memory
08:01:58 <Eduard_Munteanu> nart: when processing files of arbitrary size, you probably want the lazy ones
08:02:29 <nart> ok, but if i have small stuff it's better strict ?
08:02:33 <donri> if your bytestring is larger than 64kb, lazy might be a good idea
08:03:00 <nart> mmm ok
08:03:06 <Eduard_Munteanu> It's not necessarily better.
08:03:06 <donri> if your bytestring is smaller than that, strict might have less overhead
08:03:13 <quicksilver> as a general rule if in double, use lazy
08:03:20 <jhance> Are .haddock files for the core libraries supposed to be bzipped? I think this is the reason my system can't find them when it generates haddock
08:03:21 <quicksilver> the extra overhead for lazy is pretty small.
08:03:28 <Eduard_Munteanu> Lazy bytestrings are just collections of strict bytestrings.
08:03:30 <quicksilver> if in doubt :)
08:03:33 <drdo> Until you get in trouble and go looking for iteratees and friends
08:03:47 <Eduard_Munteanu> Yeah, and what quicksilver says.
08:03:47 <donri> also have a look at blaze-builder / bytestring 0.10
08:04:11 <nart> ok thanks :)
08:06:51 <_kostya> > let (a:(b:(c:(_)))) = "Hello" in  a:b:c:[]
08:06:52 <lambdabot>   "Hel"
08:07:20 <_kostya> > let (a:(b:(c:(d:(_))))) = "Hello" in  a:b:c:d:[]
08:07:21 <lambdabot>   "Hell"
08:07:33 <donri> _kostya: note that you can use lambdabot in PM and that you can do those things in ghci
08:07:45 <_kostya> how do I do PM?
08:07:51 <donri> /query lambdabot
08:07:59 <_kostya> and I am using my mom's laptop right now, so I don't have ghci or hugs
08:08:02 <_kostya> ok
08:08:03 <_kostya> thank you
08:08:04 <Clint> /msg lambdabot i miss you
08:08:16 <donri> _kostya: also http://tryhaskell.org/
08:08:53 <_kostya> ok
08:09:00 <hashpuppy> I posted this in here late last night and got a few responses.  I thought I'd try again once more, this morning.  If you could, I've created a very brief productivity poll that aims to query members of the Scala, Haskell, and Clojure community:  https://docs.google.com/spreadsheet/viewform?pli=1&formkey=dGZpbHExdHZteXY4VkpaRnBQUzRPRHc6MQ#gid=0
08:09:33 <donri> hashpuppy: do you realize the irony of that poll?
08:09:44 <shapr> hashpuppy: This is not what I was expecting...
08:09:45 <hashpuppy> haha.  i do.
08:10:00 <Clint> google docs is always ironic
08:10:01 <donri> people who would answer in certain ways to those questions are likely to not answer at all in the first place
08:14:21 <hashpuppy> that's why i was trying to catch the west coast as soon as they woke up and before they began their day
08:14:21 <jhance> The caffeine I drink isn't coffee so I said I drink no coffee.
08:14:22 <hashpuppy> jhance: yes, i assumed most people would take that to be "the equivalence of"
08:14:22 <hashpuppy> but i will add that if it is not clear?
08:14:22 <donri> I might've answered the poll if i took ADHD meds; alas, i'm yet to receive any! :P
08:14:22 <donri> also, changing a poll while it's running isn't exactly good statistical practices
08:14:22 <covi> @src sequenceA
08:14:22 <lambdabot> Source not found. There are some things that I just don't know.
08:14:22 <_kostya> My ADHD meds weren't on the list
08:14:22 <_kostya> notice that there is not winky face (  ;)  ) so it's not anything illegal :)
08:14:22 <srhb> _kostya: Unless of course you wanted to avoid suspicion by leaving out the winky face...
08:14:22 <srhb> Foiled!
08:14:22 <_kostya> you should have made a field for "other"
08:14:22 <_kostya> srhb you caught me ;)
08:18:54 <trem> i expected (parMap rdeepseq) when used without "+RTS -N" to behave just like map, but as it seems it first evaluates the entire list and then returns it as a whole
08:19:14 <trem> can i somehow tune it to give back what's ready yet?
08:19:45 <trem> parListChuck seems to go in that direction, but how do I know the chunk size?
08:20:33 <trem> basically I want to map over the list, evaluating the next N elements in parallel, where N is the number of cores
08:21:28 <trem> can this be done with parallel strategies and the like?
08:24:43 <covi> Why sequenceA [[1,2,3],[4,5,6],[3,4,4],[]]  equals []
08:25:10 <quicksilver> because that's how the [] monad (or the [] applicative) works
08:25:41 <covi> quicksilver: mind explaining a bit?
08:25:48 <ciaranm> > liftA2 (+) [1, 2, 3] []
08:25:49 <lambdabot>   []
08:25:52 <ciaranm> > liftA2 (+) [1, 2, 3] [1]
08:25:53 <lambdabot>   [2,3,4]
08:26:34 <covi>     fs <*> xs = [f x | f <- fs, x <- xs]
08:27:07 <bitrust> trem: Control.Parallel.Strategies (parListN) and GHC.Conc (numCapabilities)
08:27:22 <covi> Still don't understand the innermost source of the behavior.
08:28:59 <quicksilver> covi: do you understand why [1,2,3] >> [] give the result it does?
08:29:05 <quicksilver> > [1,2,3] >> []
08:29:06 <lambdabot>   []
08:29:17 <covi> @src (>>)
08:29:17 <lambdabot> m >> k      = m >>= \_ -> k
08:29:58 <covi> Yeah, because m >> k always returns k?
08:30:04 <quicksilver> no, certainly not.
08:30:10 <quicksilver> > [1,2] >> [3,4]
08:30:11 <lambdabot>   [3,4,3,4]
08:30:25 <covi> @src (>>=)
08:30:25 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
08:30:40 <quicksilver> the key here is in the specific behaviour of the [] monad
08:30:55 <trem> bitrust, parListN sounds good, but N should be chosen to be the number of cores. or maybe I just use the length of the list? hm
08:31:34 <bitrust> trem: If use use numCapabilities from GHC.Conc that is the number set with +RTS -N
08:31:48 <covi>     instance Monad [] where
08:31:49 <covi>         return x = [x]
08:31:49 <covi>         xs >>= f = concat (map f xs)
08:31:50 <covi>         fail _ = []
08:32:03 <trem> bitrust, oh, ok, sorry... should have read the whole message. :-) thanks!
08:32:10 <bitrust> trem: Ideally you'd do a couple of runs of "typical" data and profile with ThreadScope
08:32:33 <bitrust> trem: Or even just with the +RTS -s
08:32:45 <bitrust> trem: Then you can tell if youre granularity is right
08:32:49 <covi> quicksilver: giv me a sec
08:33:52 <trem> bitrust, every element takes several seconds, so it should be easy to keep them busy. but I'll have a look with threadscope, never done that before.
08:34:08 <ion> > [ (a,b) | a <- ['a'], b <- [0,1] ]
08:34:09 <lambdabot>   [('a',0),('a',1)]
08:34:10 <ion> > [ (a,b) | a <- ['a'], b <- [0] ]
08:34:11 <lambdabot>   [('a',0)]
08:34:13 <ion> > [ (a,b) | a <- ['a'], b <- [] ]
08:34:14 <lambdabot>   []
08:34:21 <bitrust> trem: What OS you on? ThreadScope is a bit of a bitch to get running on OS X.
08:34:38 <bitrust> trem: I've tried, and failed many times.
08:34:49 <trem> bitrust, i'm on fedora
08:35:53 <bitrust> trem: Then no sweat; you could also see if parListN vs simple parMap with rdeepseq *actually* makes a difference
08:36:06 <Axman6> trem: i think the N in parListN is the chunk size
08:36:27 <bitrust> Axman6: trem: Yes
08:36:48 <bitrust> trem: If each item 'takes a couple of seconds' just using parMap rdeepseq should be fine
08:37:09 <covi> quicksilver: you're right, it all depends on the implimentation of (>>=) of the [] Monad.
08:37:17 <bitrust> Axman6: trem: Sorry not chunking, it evaluates the first 'N' in parallel
08:37:29 <Axman6> i don't think that'
08:37:33 <Axman6> that's the case...
08:37:41 <covi> quicksilver: Now I understand you >> example. What does that have to do with sequenceA?
08:37:41 <quicksilver> covi: exactly. sequence (and sequenceA, which is the same, in the case you were looking at) is a compound combinator it's probably easier to understand thesimple ones.
08:37:44 <bitrust> Axman6: trem: As opposed to chunking into pieces each of size N
08:37:59 <quicksilver> covi: sequence for lists picks every possible path through a set of possibilities.
08:38:08 <Axman6> bitrust: do you have anything to back that up? because that sounds not very useful
08:38:10 <quicksilver> > sequence [[1],[2,3],[4]]
08:38:11 <lambdabot>   [[1,2,4],[1,3,4]]
08:38:17 <trem> bitrust, i get the expected speedup, that's not the problem. it's just the parMap seems the evaluate the list as a whole (in parallel), and then gives me the full list
08:38:18 <quicksilver> covi: (two possible paths)
08:38:26 <quicksilver> covi: if any of your lists is [] there are 0 possible paths.
08:38:28 <bitrust> Axman6: http://hackage.haskell.org/packages/archive/parallel/3.2.0.3/doc/html/Control-Parallel-Strategies.html#v:parListN
08:38:40 <quicksilver> it is "the same thing" as [1,2,3] >> [] being [].
08:38:45 <trem> bitrust, but i'm trying to update an UI as i'm going through the list, like a progress indicator
08:39:07 <Axman6> ah, parListChunk is what I was thinking of
08:39:13 <otters> @src sequence
08:39:14 <lambdabot> sequence []     = return []
08:39:14 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
08:39:14 <lambdabot> -- OR: sequence = foldr (liftM2 (:)) (return [])
08:39:34 <bitrust> trem: But you're operating on each item in the list in parallel? What is your UI update doing?
08:39:34 <covi> quicksilver: by 'the same thing', you mean the actual implimentation ?
08:39:35 <trem> bitrust, basically it's stuck at 0% and the loooong time nothing, then all the progress flies by and it's done
08:39:43 <quicksilver> covi: no, I mean "for the same reason"
08:40:01 <covi> otters: got it
08:40:02 <quicksilver> covi: the list monad is all about non-deterministic programming, things which return more than one result.
08:40:14 <trem> bitrust, when just using "map" instead of "parMap" i going through the list as it gets ready
08:40:17 <quicksilver> covi: it works by combining all possible results from all the steps
08:40:21 <bitrust> trem: Well yes... each core goes of and does its own thing until the unevaluated thunk is evaluated
08:40:24 <quicksilver> covi: if any step has 0 results the answer is [].
08:40:28 <Axman6> quicksilver: well, things that return any natural number of results
08:40:38 <quicksilver> much like 3*4*0*5 = 0
08:40:47 <quicksilver> Axman6: yes, sorry, that was a slightly inaccurate 'intuitive' description.
08:40:49 <covi> quicksilver: Okay. Like Maybe Monad which fails when there's Nothing
08:40:58 <quicksilver> covi: precisely like it.
08:41:11 <quicksilver> covi: the Maybe monad is isomorphic to the list monad where all lists have length at most 1
08:41:12 <Axman6> quicksilver: heh, it's not often I get to correct you :P
08:41:28 <quicksilver> Axman6: as long as you don't make a habit of it :P
08:41:44 <Axman6> I won't if you don't make a habit of being wrong :P
08:41:48 <quicksilver> covi: that is, "Nothing" corresponds to [] and "Just 1" corresponds to [1]
08:42:03 <quicksilver> > listToMaybe [1]
08:42:04 <lambdabot>   Just 1
08:42:05 <bitrust> trem: If you want to get each part back as it's evaluated you're looking at some form of parallel stream
08:42:30 <astory> Is there a good way to get all the pairs of a list?  For example, if I had [1, 2, 3], I'd want [(1, 2), (1, 3), (2, 3)] in some order
08:42:43 <astory> I'm sure this involves zipping with some kind of trickery
08:42:47 <covi> > listToMaybe [1,2]
08:42:48 <lambdabot>   Just 1
08:42:55 <covi> @src listToMaybe
08:42:56 <lambdabot> listToMaybe []        =  Nothing
08:42:56 <lambdabot> listToMaybe (a:_)     =  Just a
08:42:58 <quicksilver> astory: why don't you want (2,1) ?
08:43:15 <donri> or (3,1) etc for that matter
08:43:16 <astory> quicksilver: in my particular case, the thing I want to do to the pairs is symmetric
08:43:17 <Axman6> > join (liftM2 (,)) [1,2,3]
08:43:19 <lambdabot>   [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3)]
08:43:36 <Qtr> > perms [1,2,3]
08:43:37 <lambdabot>   Not in scope: `perms'
08:43:42 <quicksilver> > [ (x,y) | x <- [1,2,3], y <- [1,2,3], x < y]
08:43:43 <lambdabot>   [(1,2),(1,3),(2,3)]
08:43:48 <quicksilver> astory: ^^ perhaps
08:43:57 <Qtr> > permutations [1,2,3]
08:43:58 <lambdabot>   [[1,2,3],[2,1,3],[3,2,1],[2,3,1],[3,1,2],[1,3,2]]
08:44:04 <astory> brilliant, thanks quicksilver
08:44:07 <quicksilver> not strictly speaking the most efficient, but not asymptotically bad.
08:44:11 <astory> I completely forgot about comprehensions
08:44:17 <astory> quicksilver: it's for testing anyway, it doesn't need to be fast
08:44:36 <Axman6> > [ (x,y) | (x:xs) <- tails [1,2,3], y <- xs]
08:44:38 <lambdabot>   [(1,2),(1,3),(2,3)]
08:44:43 * Axman6 wins!
08:44:47 <astory> :t tails
08:44:48 <trem> bitrust, actually I don't care if I get back my results in order, and parMap can not take advantage of that because it just doesn't know
08:44:49 <lambdabot> forall a. [a] -> [[a]]
08:45:32 <Qtr> > let genPairs xs = map (\x -> map (\y -> (x,y)) xs) xs
08:45:32 <astory> Axman6: even better.  That's actually about what the (python) code I'm porting did, but it did it with nested loops and I have a hard time converting those into good Haskell
08:45:33 <lambdabot>   not an expression: `let genPairs xs = map (\x -> map (\y -> (x,y)) xs) xs'
08:45:39 <Qtr> > let genPairs xs = map (\x -> map (\y -> (x,y)) xs) xs in genPairs [1,2,3]
08:45:40 <lambdabot>   [[(1,1),(1,2),(1,3)],[(2,1),(2,2),(2,3)],[(3,1),(3,2),(3,3)]]
08:45:57 <Axman6> astory: right, because loops are awful =)
08:46:05 <astory> Axman6: well, when in Rome
08:46:21 <quicksilver> list comprehensions are nested loops
08:46:25 <Axman6> teach them functional programming and imp[rove society :P
08:46:36 <quicksilver> forM_ can be useful if the nested loop does IO
08:46:41 <astory> Axman6: we were using Python for other reasons, and pure functional code in python is clunky
08:46:47 <quicksilver> (but you can just sequence_ a list comprehension)
08:47:00 <astory> although it's telling that my bottleneck was isInstance because I was trying to shoehorn abstract data types into the language
08:47:23 <astory> quicksilver: yeah, sequence_ is awesome, fortunately I don't think I need that right now
08:49:05 <trem> bitrust, oh my! parBuffer is what I needed, this looks beautifully! :-)
08:49:14 <monochrom> use http://www.vex.net/~trebla/humour/Nightmare.java to shoehorn algebraic data types into java
08:49:59 <monochrom> Hmm, I think I can improve it a bit
08:51:01 <Qtr> > let genPairs xs = map (\x -> map (\y -> (x,y)) xs) xs in genPairs [1,2,3]
08:51:02 <lambdabot>   [[(1,1),(1,2),(1,3)],[(2,1),(2,2),(2,3)],[(3,1),(3,2),(3,3)]]
08:51:14 <Qtr> > let genPairs xs = concat $ map (\x -> map (\y -> (x,y)) xs) xs in genPairs [1,2,3]
08:51:15 <lambdabot>   [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3)]
08:51:42 <Qtr> O(n^2), can it be improved?
08:51:52 <astory> monochrom: I really wish every language had ADTs.  I think if given the choice I'd take them over first class functions even
08:51:54 <Qtr> you want both (1,2) and (2,1)`?
08:52:04 <astory> Qtr: I don't in this instanec
08:52:11 <astory> speed isn't important, the list is short
08:52:17 <t7> actually cons and nil should implement list
08:52:20 <t7> or extend list
08:52:22 <t7> right?
08:52:37 <monochrom> yes, that's the improvement I have in mind
08:53:03 <astory> monochrom: you should also use generics rather than having it hold an object
08:53:07 <astory> er, Object
08:53:10 <astory> god, Java is awful
08:53:26 <astory> you can't even talk about it without getting confused.
08:53:31 <monochrom> ah, it was written in Java 2 or something
08:53:33 <quicksilver> Qtr: you'd just written out the list comprehension longhand ;)
08:53:46 <quicksilver> (and missed out the "x>y" that I had)
08:54:32 <astory> monochrom: I figured.  Java's "advanced" since then
08:55:15 <Axman6> astory: was there anything wrong with the code I gave?
08:56:37 * ksf_ decides that uuagc's --sepsemmods is quite useless
08:56:40 <astory> Axman6: that was exactly what I was looking for
08:56:45 <edwardk> has anyone bothered to package up the OS-specific file format registration stuff? e.g. to register it so your particular haskell app handles files with a given extension/mime-type? e.g. using EAWT on a mac, the various incantations in linux, the registry in windows?
08:56:52 <Axman6> good :)
09:01:17 <_xvilka> hi! Trying to install leksah on Windows 7 x64, installed grep, installed leksah, and it show me "FileUtils>>getInstalledPackageIds failed" instead of start
09:03:11 <_xvilka> ghc-pkg here and valid (running from cmdline)
09:08:55 <Qtr> > [(x,y) | x <- [1,2,3], y <- [1,2,3]]
09:08:56 <lambdabot>   [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3)]
09:09:05 <Qtr> is there some unique function?
09:09:10 <Qtr> like remove all duplicates?
09:09:42 <Saizan> nub
09:09:46 <Qtr> prerty innnefiicient like O(2*N^2+NlogN) or something but it works
09:09:52 <Qtr> > nub [(1,2),(1,2)]
09:09:53 <lambdabot>   [(1,2)]
09:11:48 <edwardk> does anyone know of a websocket client? snap and yesod have websocket servers, but i don't know of a websocket client library in haskell
09:12:30 <joeyh> I tend to use Data.Set for larger nub needs S.toList . S.fromList -- O(n*log n + n)
09:12:36 <conal> byorgey: i'd forgotten that you wrote 'project' originally.
09:12:36 <lambdabot> conal: You have 1 new message. '/msg lambdabot @messages' to read it.
09:13:08 <byorgey> conal: yep, I found myself wanting it in diagrams
09:13:26 <Cale> What's with people including dominated terms inside big O notation?
09:13:40 <_xvilka> hm, just checked - ghc-pkg in path
09:13:40 <joeyh> sillyness :)
09:13:53 <coppro> Cale: I enjoy O(sin x)
09:14:04 <Qtr> nub $ map (\(x,y) -> if x > y then (y,x) else (x,y)) $
09:14:05 <Qtr>        	 [(x,y) | x <- xs, y <- xs]
09:14:14 <Cale> O(2*N^2 + N log N) = O(N^2) and O(n log n + n) = O(n log n)
09:14:40 <coppro> Cale: Do you prefer to think of big-O as a set or a relation?
09:14:45 <Cale> set
09:14:53 <coppro> good, you're right then :P
09:14:59 <Qtr> > let getPairs xs = nub $ map (\(x,y) -> if x > y then (y,x) else (x,y)) $ [(x,y) | x <- xs, y <- xs] in getPairs [1,2,3]
09:15:00 <lambdabot>   [(1,1),(1,2),(1,3),(2,2),(2,3),(3,3)]
09:15:04 <Qtr> ok?
09:15:11 <Qtr> terribale for big lists though
09:15:18 <Cale> What are you trying to do?
09:15:29 <conal> byorgey: Nereid suggested ((v <.> u) / magnitudeSq u) ^* u , which looks a bit simpler & more efficient as well.
09:15:47 <conal> byorgey: (shifting to scalar division)
09:15:55 <Qtr> it is for astory
09:16:00 <quicksilver> Qtr: still simpler to write [(x,y) | x <- xs, y <- xs, x<y] though
09:16:03 <coppro> conal: what is ^* ?
09:16:17 <Qtr> @src nub
09:16:17 <lambdabot> nub = nubBy (==)
09:16:22 <edwardk> coppro: vector/scalar multiplication
09:16:28 <coppro> edwardk: thanks
09:16:28 <Qtr> nub is O(N^2) right?
09:16:35 <coppro> edwardk: what library is that?
09:16:37 <coppro> Qtr: yeah
09:16:38 <conal> coppro: yes, and i think Nereid meant "*^" instead
09:16:42 <edwardk> coppro: probably his vector-space
09:16:49 <edwardk> but i adopt the same convention in my libs as well
09:17:02 <Cale> > let pairs xs = [(u,v) | vs@(u:_) <- tails xs, v <- vs] in pairs [1..3]
09:17:03 <conal> i often use "^/" and "*^"
09:17:03 <lambdabot>   [(1,1),(1,2),(1,3),(2,2),(2,3),(3,3)]
09:17:04 <byorgey> conal: oh, nice
09:17:10 <Cale> ^^ why not just do that?
09:17:12 <edwardk> yeah
09:17:24 <byorgey> conal: yes, that does look even better
09:17:39 <edwardk> ^/ is much more convenient, even if its less correct if you want to support more exotic num types
09:17:47 <Cale> Unless you really want to compare things
09:18:01 <Cale> > let pairs xs = [(u,v) | vs@(u:_) <- tails xs, v <- vs] in pairs [1,1,1,1]
09:18:02 <lambdabot>   [(1,1),(1,1),(1,1),(1,1),(1,1),(1,1),(1,1),(1,1),(1,1),(1,1)]
09:18:29 <coppro> hmm
09:18:38 <Qtr> > nubBy (<) [1,1,2,3,4,5]
09:18:39 <lambdabot>   [1,1,2,3,4,5]
09:18:44 <Cale> (this is correct behaviour, in my mind)
09:19:06 <Cale> nubBy is unfortunately screwed up half the time
09:19:23 <Cale> because it was standardised incorrectly imo
09:19:49 <Cale> The Report implementation of nubBy has extra useful behaviour which the Report explicitly denies.
09:19:57 <coppro> which is?
09:19:58 <_xvilka> stupid windows, it wont run. :(
09:20:36 <monochrom> I only believe in documented behaviour. If you want your favourite behaviour guaranteed, get it into the documentation first.
09:23:07 <Qtr> > nubBy (<) [5,1,1,2,3,4,5]
09:23:08 <lambdabot>   [5,5]
09:23:15 <Qtr> i see
09:23:50 <Qtr> Cale: what is the complexity of your 'pairs'? it is a bit unreadable, what is the @ operator here?
09:24:20 <Qtr> > nubBy (<) [5,1,1,2,3,4,5,6,4]
09:24:21 <lambdabot>   [5,5,6]
09:24:37 <Cale> var@pat where pat is any pattern and var is a variable is a pattern which matches pat, but also binds the entire matched thing to var
09:24:54 <Cale> > let xxs@(x:xs) = [1,2,3,4] in (xxs,x,xs)
09:24:55 <lambdabot>   ([1,2,3,4],1,[2,3,4])
09:26:29 <monochrom> if you hold that implementation details can be relied upon, that opens a can of worms. for example, in Haskell 98, "sortBy cmp = foldr (insertBy cmp) []", now some people will say that only quadratic running time is correct in their opinion
09:28:03 <ksf_> when does ghc rebuild modules with --make?
09:28:14 <ksf_> It's always rebuilding everything heer, that's annoying.
09:28:28 <monochrom> it doesn't rebuild everything here
09:28:42 <dmwit> ksf_: When a file changes or you use different command-line options.
09:28:51 <monochrom> but there is a section on this in the GHC user guide
09:28:55 <ksf_> I'm doing neither.
09:29:00 <ksf_> also, what does "change" mean?
09:29:11 <danr> ksf_: also make sure you don't compile with -fforce-recomp :)
09:29:13 <Clint> timestamp becomes newer
09:29:23 <ksf_> they clearly have earlier mod times than .o and.hi
09:29:32 <ksf_> ...on an import path, though.
09:29:43 <monochrom> maybe two sections. Orphaned instances affect it too, so there is something in the orphaned instance section
09:30:02 <Clint> what about the dependent files?
09:30:40 <monochrom> oh, actually, same section. 4.7. in particular 4.7.8 and 4.7.12. but read the whole thing anyway
09:31:11 <ksf_> yep, that's it. one early file is updated (though it shouldn't)
09:31:42 <covi> @hoogle fromZipList
09:31:42 <lambdabot> No results found
09:31:58 <covi> @hoogle getZipList
09:31:59 <lambdabot> Control.Applicative getZipList :: ZipList a -> [a]
09:32:20 <ksf_> argh. uuagc really isn't easy on build systems.
09:32:58 <ksf_> shake to the rescue!
09:33:09 <ksf_> let's generate yet another file.
09:33:55 <covi> How to do sth like sequenceA $ ZipList [[1,2],[3]]
09:59:29 <Qtr> so how hard would it be to fix darcs exponential merges?
10:00:26 <Qtr> so how hard would it be to fix darcs exponential merges?
10:02:38 <Qtr> There is no difference in code at all between linux and windows right? just code some haskell and compile to diff platforms?
10:03:08 <edwardk> for 90% of what you want to do, yes. there are a few different modules for talking to linux and windows-specifics
10:03:17 <Qtr> How do I install haskell-mode for emacs on ubuntu? can i apt-get modes?
10:03:29 <edwardk> there i can't help
10:03:49 <Qtr> How do I install haskell-mode for emacs on ubuntu? can i apt-get modes?
10:04:07 <kostya> I don't think you can apt-get modes
10:04:50 <kostya> check this out:
10:04:50 <kostya> http://www.haskell.org/haskellwiki/Haskell_mode_for_Emacs
10:05:06 <geekosaur> actually it was available as a separate package at one point at least, for debian/ubuntu
10:05:39 <kostya> maybe I was mistaken
10:05:46 <dmwit> covi: What's wrong with that code?
10:06:06 <kostya> Actually, I was mistaken :)
10:06:11 <kostya> sudo apt-get install ghc-mod
10:06:12 <geekosaur> it's in universe
10:07:01 <dmwit> > sequenceA $ ZipList [[1,2],[3]]
10:07:02 <lambdabot>   Couldn't match expected type `[f a]'
10:07:02 <lambdabot>         against inferred type `Control...
10:07:09 <dmwit> Ah.
10:07:16 <dmwit> > sequenceA $ map ZipList [[1,2],[3]]
10:07:17 <lambdabot>   No instance for (GHC.Show.Show (Control.Applicative.ZipList [a]))
10:07:17 <lambdabot>    arisin...
10:07:28 <dmwit> > getZipList . sequenceA $ map ZipList [[1,2],[3]]
10:07:30 <lambdabot>   [[1,3]]
10:07:38 <dmwit> covi: there you go =)
10:08:29 <dmwit> You might also like
10:08:34 <dmwit> > transpose [[1,2],[3]]
10:08:35 <lambdabot>   [[1,3],[2]]
10:09:31 * lispy waves
10:09:33 <lispy> vin 6
10:09:35 <lispy> oops
10:18:17 <Qtr> oh please so git rm -r removes files from disk and not from git? wtf?
10:18:26 <Qtr> and not to reyccle bin but completely!?
10:18:48 <mauke> what's a recycle bin?
10:18:49 <Qtr> goodbye tictactoe
10:18:52 --- mode: mauke set -o mauke
10:18:56 <Qtr> all files gone
10:18:58 <jhance> Qtr: git rm --cached is what you want
10:19:08 <Qtr> doesnt matter now git removed my project
10:19:18 <jhance> Qtr: git reset --hard HEAD^
10:19:21 <mauke> Qtr: if they're not removed from git, what's the problem?
10:19:30 * geekosaur notes that if you committed regfularly you could easily revert...
10:19:32 <jhance> Qtr: NEVERMIND
10:19:38 <jhance> Qtr: git reset --hard HEAD
10:19:49 <Qtr> ok phew
10:20:02 <jhance> I don't know why I placed the carot. That would lose you one commit.
10:21:03 <jhance> Qtr: But any file you 'rm --cached' ought to be regeneratable by anyone who has the repository. Why are you removing source code from the repositroy?
10:21:22 <jhance> Qtr: But any file you 'rm --cached' ought to be regeneratable by anyone who has the repository. Why are you removing source code from the repositroy?
10:22:59 <kostya> > words "There's jam in my pants."
10:23:00 <lambdabot>   ["There's","jam","in","my","pants."]
10:23:55 <kostya> don't judge me, it's on tryhaskell.org tutorial...
10:24:31 <byorgey> =)
10:24:56 <Ralith> maybe you were walking past the gorcery store and needed some condiments
10:25:29 <kostya> maybe
10:25:32 <kostya> you will never know :)
10:25:46 <kostya> how to set an editor in hugs?
10:25:53 <mauke> why are you using hugs?
10:25:59 <kostya> for example in ghci I typed set editor vim
10:26:39 <kostya> just to see what's the difference is between ghci and hugs
10:26:48 <jhance> kostya: Hugs is bad and ghci is good.
10:26:52 <mauke> well, one difference is that no one uses hugs
10:26:54 <byorgey> the difference is that hugs is very old and not maintained anymore.
10:26:58 <mauke> and it hasn't been maintained since 2006
10:27:15 <kostya> but I didn't see any real difference so far
10:27:18 <Qtr> ambiguous module Prelude it was found in several modules haskell98 and base, what do i do about that?
10:27:37 <mauke> Qtr: don't depend on haskell98
10:27:43 <jhance> kostya: Error messages? Advanced features? Haskell extensions? Ability to use the libraries that only build with GHC?
10:28:04 <kostya> jhance: Error messages?
10:28:18 <jhance> kostya: GHC error messages are more descriptive and helpful
10:28:37 <kostya> I think they are both pretty crappy
10:28:52 <kostya> g++ template errors are easier to figure out :)
10:29:02 <mauke> kostya: that is provably wrong
10:29:10 <kostya> take 'a' [1,3,2,4]
10:29:18 <Qtr> could not find module System, it recommends adding haskell 98, instead i guess i should add something else, what?
10:29:19 <mauke> > take 'a' [1,3,2,4]
10:29:20 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
10:29:20 <lambdabot>         against inferred type ...
10:29:27 <kostya> ctrl + paste in the wrong place
10:29:29 <kostya> sorry
10:29:52 <jhance> Qtr: ghc-pkg hide haskell98
10:30:09 <mauke> Qtr: what do you need from System?
10:30:11 <jhance> Qtr: And what function are you using from haskell98 System?
10:30:16 <byorgey> Qtr: you should change  'import System' to something else
10:30:19 <Qtr> Prelude from haskell 98
10:30:25 <byorgey> which depends on what is being imported from System
10:30:27 <mauke> Qtr: what
10:30:32 <mauke> Qtr: the Prelude is not in System
10:30:40 <Qtr> System.Random
10:30:46 <mauke> System.Random isn't in System either
10:30:58 <Qtr> system is in haskell 98
10:31:06 <Qtr> which gives then conflict on prelude
10:31:09 <jhance> @hoogle Random
10:31:09 <lambdabot> System.Random class Random a
10:31:09 <lambdabot> System.Random random :: (Random a, RandomGen g) => g -> (a, g)
10:31:09 <lambdabot> package random
10:31:21 <mauke> Qtr: WHAT
10:31:21 <Qtr> it buoidls on windows
10:31:25 <byorgey> Qtr: System is a name of an old package which is not part of the standard anymore.
10:31:36 <mauke> Qtr: EXPLAIN WTF YOU'RE DOING AND ANSWER MY QUESTIONS
10:31:49 <byorgey> mauke, calm down =)
10:31:58 <jhance> It sounds to me like he wants System.Random (Random) but is importing System (Random)
10:32:08 <mauke> byorgey: no need to get angry
10:32:34 <kostya> Haskell community is sometimes too nice to n00bs like me
10:32:50 <kostya> sometimes we need to be yelled at, and told to google it by ourselves
10:33:21 <mauke> I'm reluctant to send people to google because of my experience with Perl
10:33:45 <Cale> Sometimes it's easier for us to find the documentation for you than it would be for you to find it yourself.
10:33:56 <mauke> google tends to dig up crappy 10-year-old tutorials written by clueless coders
10:34:09 <byorgey> and Haddock documentation for five-year-old versions of packages
10:34:36 <kostya> in other programming-language communities it's kinda opposite of that
10:34:38 <srhb`> Yes, someone should take zvon.org offline, or whatever it is called...
10:34:57 <mauke> byorgey: still better than pre-2000 PERL code :-(
10:35:01 <srhb`> Er, and by someone I mean "the owner" <_<
10:35:11 <jhance> Always use local docs :)
10:35:47 <Qtr> ok it works i removed the import System
10:36:20 <jhance> Qtr: Seriously do "ghc-pkg hide haskell98" so that it never again tries to pollute your system with 14 year old out of date modules
10:36:43 <Qtr> ok
10:36:47 <kostya> ok, I agree that ghci errors are better then hugs, which are also in turn better than C++ template errors :)
10:36:49 <Qtr> just on commandline?
10:36:56 <jhance> kostya: Clang's errors are ok
10:37:34 <kostya> well, I use g++
10:37:55 <mauke> the nice thing about haskell is that I've never gotten a 1 MB error message blob for a simple problem
10:39:02 <kostya> <templace <class std::<vector<boost::>, long_namespace_name;
10:39:32 <Cale> C++ errors are unreadable in large part because C++ is though.
10:39:51 <kostya> I shall disagree with you on that
10:39:57 <kostya> it can be really beatiful
10:40:01 <Cale> The angle brackets are so terrible
10:40:06 <srhb`> Anything can be readable with enough practice. :P
10:40:16 <kostya> the libraries are really ugly
10:40:46 <kostya> but with their ugliness they can make user-code look nice
10:42:32 <mauke> kostya: I don't believe that either, but I'm switching to #haskell-blah now
10:43:13 <jhance> Whats the difference between #haskell and #haskell-blah?
10:43:29 <srhb`> jhance: #haskell should stay on topic mostly. :-)
10:43:37 <mauke> #haskell is about Haskell
10:44:30 <kostya> and haskell-blah?
10:44:36 <srhb`> is about haskell and blah blah blah
10:44:47 <kostya> ok
10:45:02 <mauke> no, Haskell is off-topic in #haskell-blah
10:45:13 <srhb`> Really. :P
10:47:24 <Qtr> i can play tictactoe in ubuntu! wow yeah(well not really).
10:47:33 <Qtr> and now for some open gl perhaps
10:47:40 <kostya> from what I understand, I would summarize it as a place for Haskell programmers to talk about other stuff
10:48:24 <kostya> Nexuiz, Assault-cube and teeworlds are pretty good Ubuntu games
10:48:49 <kostya> Nexuiz has pretty good graphics for an open-source game
10:48:56 <kostya> teeworld is 2d, but looks good
10:49:05 <kostya> and I made my own aimbot for assault cube :)
10:49:12 * Cale plays lots of stuff under Wine
10:49:45 <kostya> I couldn't play any games under wine
10:49:49 <kostya> except half-life 2
10:49:54 <kostya> it ran perfect
10:51:37 <Cale> Morrowind, Oblivion, Skyrim, SC2, Diablo 3, Path of Exile, Portal 2, Fallout 3, Deus Ex 3, Trine,... a bunch of other stuff
10:52:20 <Cale> A lot of stuff takes a little fiddling to make it work, but if you look on the appdb, it's usually pretty easy to find settings/tricks to get things to run well.
10:55:31 <Skola> would it be possible technically to convert a function which uses >>, >>= etc into applicative style programmatically?
10:55:48 <Skola> I mean consistently
10:57:53 <jhance> Skola: Well not all Monads are Applicative Functors...
10:58:04 <jhance> Skola: Or I should say the other way around
10:58:37 <jhance> Skola: Since not all Applicatives are Monads, if you build a function that uses Monad-based functions it won't necessarily be possible to write it with Applicative-based functions all the way through
10:58:54 <dmwit> Skola: No, not all uses of (>>=) can be translated. All uses of (>>) can.
11:04:20 <Qtr> @type (&&&)
11:04:21 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
11:04:28 <Qtr> does it have a name?
11:04:33 <Qtr> what are arrows?
11:04:43 <Qtr> (&&&) [1,2,3]
11:04:58 <Qtr> head (&&&) tail $ [1,2,3]
11:05:05 <Qtr> > head (&&&) tail $ [1,2,3]
11:05:06 <lambdabot>   Couldn't match expected type `[a]'
11:05:06 <lambdabot>         against inferred type `a1 b c ->...
11:05:10 <Qtr> > (&&&) [1,2,3]
11:05:11 <lambdabot>   Couldn't match expected type `a b c' against inferred type `[a1]'
11:05:17 <frerich> Qtr: I call it the 'two-at-once' function.
11:05:23 <Qtr> > head &&& tail $ [1,2,3]
11:05:24 <lambdabot>   (1,[2,3])
11:05:31 <frerich> > head &&& length $ "Hello"
11:05:32 <lambdabot>   ('H',5)
11:05:47 <Qtr> frerich: but it just combines 2 functions, obv performance-wise there is no diff?
11:06:03 <ski> > runKleisli (Kleisli (\x -> [x,x+1]) &&& Kleisli (\x -> [x/2,x,x*2])) 6
11:06:04 <Qtr> > (head [1,2,3], tail [1,2,3])
11:06:04 <lambdabot>   [(6.0,3.0),(6.0,6.0),(6.0,12.0),(7.0,3.0),(7.0,6.0),(7.0,12.0)]
11:06:04 <lambdabot>   can't find file: L.hs
11:06:29 <Cale> Qtr: that's what it does for the instance of Arrow for (->)
11:07:02 <srhb`> Qtr: http://en.wikibooks.org/wiki/Haskell/Understanding_arrows -- decent introduction
11:07:02 <unit3> I'm very new to Haskell, so I'm not sure if this is possible... is there a way to dynamically generate a record data type from an externally defined schema at runtime?
11:07:15 <srhb`> you'll have to live with the metaphor though :-)
11:07:36 <frerich> Qtr: I find it a bit mind bending, but my understanding is that arrows are a generalization of functions.
11:07:48 <Cale> unit3: Types are compile-time information
11:08:13 <Cale> (they don't exist at runtime to be created)
11:08:19 <Qtr> how do i get haskell-mode for linux/ubuntu? can i apt-get it?
11:08:38 <Clint> yes
11:08:46 <Clint> did you try?
11:10:06 <Cale> unit3: It's also very unclear how you'd interact with values of a type you know nothing about. It would be impossible to write code to extract fields of that datatype because you don't know what fields will be there.
11:10:06 <kostya> sudo apt-get install
11:10:09 <kostya> ghc-mod
11:10:25 <Cale> unit3: (or if there are fields at all)
11:10:52 <ski> > ((`runState` 10) . (`runKleisli` 6)) (Kleisli (\x -> state (\s -> (x * s,s + 1))) &&& Kleisli (\x -> state (\s -> (x + s,s * 2))))
11:10:55 <lambdabot>   ((60,17),22)
11:11:11 <dmwit> unit3: You can write a datatype that represents data types. =)
11:11:11 <ski> > ((`runState` 10) . (`runKleisli` 6)) (Kleisli (\x -> state (\s -> (x * s,s + 1))) &&& Kleisli (\x -> state (\s -> (x + s,s * 2)))) :: ((Expr,Expr),Expr)
11:11:13 <nand`> you could perhaps generalize it and define a data type for schema definitions. I'm still now sure how you'd interact with it though
11:11:14 <lambdabot>   ((6 * 10,6 + (10 + 1)),(10 + 1) * 2)
11:11:59 <jhance> Data.Dynamic could come in handy
11:12:00 <dmwit> In other words, if you want reflection, you have to write it yourself (but it's easy to write).
11:12:21 <Cale> Well, "easy"
11:12:22 <dmwit> (and, as jhance points out, provided to some extent as a library)
11:12:33 <Qtr> do I have to include in .emacs or is that done automatically?
11:12:40 <Cale> Depends on exactly what you want from it
11:13:18 <jhance> Qtr: Probably should include in .emacs unless it added it to some sort of global config. <--- doesn't use emacs
11:13:37 <ski> Qtr : how about those examples of `(&&&)' above ?
11:14:18 <Cale> tbh, that's the worst Arrow instance ever
11:14:38 <Veinor> worst as in...
11:15:11 <Cale> Well, okay,  Kleisli IO  is worse :P
11:15:31 * frerich ponders a round of Diablo 3 but then leans back to his editor, remembering the pain that is Inferno...
11:15:47 <Cale> frerich: Played Path of Exile at all? :)
11:15:50 <Qtr> Diablo3 bored me after 1 round
11:16:04 <frerich> Cale: Doesn't ring a bell, no.
11:16:08 <Qtr> demonhunter level 31 since then i havent played
11:16:10 <Skola> chance, dimwit, thanks for your comments earlier
11:16:38 <Cale> Next weekend they're having another open beta, but it's $5 to get closed beta access anyway
11:16:50 * frerich googles...
11:17:06 <frerich> Qtr: Diablo is rather dull, but I find it relaxing in some sense. You don't have to think very much. :-)
11:17:18 <Cale> I've had more fun playing it than I have D3 somehow.
11:18:01 <Cale> Veinor: It doesn't satisfy (f *** g) >>> (h *** k) = (f >>> h) *** (g >>> k)
11:18:20 <Cale> Veinor: which ends up breaking a lot of expectations about how arrow diagrams work
11:18:37 <ski> because of non-commutativity
11:18:39 <Cale> (basically, the state "leaks" in a non-local fashion)
11:19:18 <ski> (fwiw, `Kleisli []' has the same problem, maybe to a milder extend)
11:19:36 <Ornedan> Is it possible to get the message out of an exception? show adds some extra bits that I'd prefer to not have
11:19:41 <Cale> It's kind of like trying to design a circuit and having the PCB layout adversely affect the way that your components operate, breaking the lumped circuit abstraction.
11:19:48 <Veinor> Cale: ah
11:20:34 <nart> hi
11:21:29 <monochrom> depends on the exception type
11:21:33 <nart> is there a reverse of "lift" ?
11:21:45 <monochrom> no
11:21:47 <ski> not really
11:22:18 <nart> gosh
11:22:54 <monochrom> yeah why is computing so bloody iirevesible
11:23:16 <monochrom> in imperative languages, I want the reverse of "x:=0", too
11:23:17 <Skola> anyone know why one would get invited for stack overflow careers?
11:23:20 <byorgey> there can't be.  You can always *add* an extra monad transformer layer, by specifying that no effects happen in that layer.
11:23:41 <shapr> Skola: I got an invite after I'd had an account for a  few months.
11:23:42 <Veinor> monochrom: reversible computers!
11:23:42 <byorgey> but given a computation with more than one transformer layer, there may be arbitrary effects happening in the topmost layer, so you can't get rid of it.
11:23:55 <Taneb> monochrom, "Make x not zero anymore! That sucks!"?
11:23:56 <nart> byorgey: ah ok, now i see
11:24:01 <monochrom> yeah, reversible computers don't have "x:=0" iirc
11:24:07 <guest_3908> Haha !
11:24:32 <ksf_> there *must* be something else but direct file modification times that ghc checks.
11:24:32 <dmwit> nart++ for "gosh"
11:24:32 <Veinor> Taneb: 'make x equal to anything other than 0'
11:25:55 <Ornedan> monochrom: From user or IO exceptions?
11:27:17 * ksf_ can't detect any difference in any timestamp of any hs file between when ghc rebuilds and when it does not.
11:27:36 <ksf_> the only difference is whether uuagc ran before, not touching its output files.
11:28:42 <monochrom> then look into System.IO.Error for various accessors of IOException
11:28:44 <ski> Taneb,Veinor : nobody said it was nonzero before ..
11:28:55 <ksf_> well, the *directory* timestamp differs.
11:29:11 <twanvl> ksf_: maybe some .o or .hi files were deleted?
11:29:23 <ksf_> I don't delete anything.
11:29:46 <ksf_> it also doesn't rebuild everything, but only most things.
11:30:04 <ski> nand` : ooc, what was the monad transformer, and the monad, in your case ?
11:30:15 <ski> oh, nart left
11:38:58 <Ondra> Hello, please why can't I use array (http://zvon.org/other/haskell/Outputarray/array_f.html), saying "Not in scope: `array'" and I cannot import Array, saying "Could not find module `Array'. It is a member of the hidden package `haskell98-2.0.0.1'."? Thanks.
11:39:35 <geekosaur> because short names like Array have been obsolete for close to 10 years now.  it's Data.Array these days
11:39:58 <ski> @index array
11:39:58 <lambdabot> Data.Array.IArray, Data.Array.Unboxed, Data.Array.Diff, Data.Array
11:40:04 <Ondra> Thank you very much, now it works. :-)
11:41:19 <ski> Ondra : basic libraries : <http://www.haskell.org/ghc/docs/latest/html/libraries/index.html>
11:42:12 <warrenharris> anyone have experience porting from conduit-0.4 to 0.5 ?
11:42:27 <byorgey> Ondra: don't use zvon.org, it's quite outdated.  I don't know why it still exists.
11:42:29 <Clint> not yet
11:43:19 <Ondra> Ok, thanks.
11:43:23 <Skola> byorgey: it got SEO right, perhaps accidentally, because it turns up in Google results all the time
11:44:18 <byorgey> Skola: I guess so, I don't know.  I never use Google to search for Haskell information.  I use Hoogle or Hayoo, or look on the haskell wiki
11:44:36 <jhance> warrenharris: I'm waiting for Yesod to support 0.5 before updating anything to 0.5. Its just not that useful to at the moment. I think the main change is the connect-and-resume having its own ResumableSource type, though.
11:44:47 <Skola> byorgey: me too usually, except when I want examples
11:45:05 <byorgey> Skola: true, examples are more difficult
11:45:35 <Skola> I wish hackage docs included more examples
11:45:46 <Skola> usually it's useful to have just enough to get going
11:45:54 <Skola> and THEN use the usual docs
11:47:00 <warrenharris> jhance: I was curious about the constructors I was using (e.g. PipeM) moving to the Internal sub-package
11:47:00 <monochrom> yes
11:47:22 <jhance> warrenharris: I think the docs say that you shouldn't have to use those anymore at all
11:47:22 <__bob__> how to compare lists?
11:47:28 <__bob__> like [] == []
11:47:39 <warrenharris> jhance: but what do I use instead?
11:47:42 <monochrom> yes you can use == for most lists
11:47:52 <__bob__> what about does not equal operator?
11:48:04 <jhance> warrenharris: I'm not sure. I usually use one of the sourceState, etc functions to make them. Check to see if theres a post on Michael's blog?
11:48:05 <monochrom> /=
11:48:24 <__bob__> thank you
11:48:28 <Cale> __bob__: If your goal is to test whether a list is empty though, you're better off pattern matching
11:48:35 <byorgey> Skola: agreed.  Writing good documentation is Hard.
11:48:37 <Cale> Or at the very least using the null function
11:48:39 <ski> __bob__ : if you just want to check whether a list is empty, use `null myList'
11:48:39 <Cale> > null [1,2,3]
11:48:41 <lambdabot>   False
11:48:41 <warrenharris> jhance: didn't see one that detailed the change - I'll ask on the yesod channel
11:48:43 <Cale> > null []
11:48:44 <lambdabot>   True
11:48:58 <__bob__> ok
11:49:14 <ski> or use pattern-matching ..
11:49:24 <monochrom> use foldr
11:49:43 <Cale> > case [1,2,3] of [] -> "wat"; (x:xs) -> concat [show x, " is the first element and ", show xs, " is the rest of the list"]
11:49:44 <lambdabot>   "1 is the first element and [2,3] is the rest of the list"
11:49:46 <Ondra> And please, how can I transform an array into an unboxed array?
11:50:04 <ski> > case [] of [] -> "wat"; (x:xs) -> concat [show x, " is the first element and ", show xs, " is the rest of the list"]
11:50:06 <lambdabot>   "wat"
11:50:25 <monochrom> "customers who used == also liked: foldr, map, Ord, continuation passing style"
11:50:32 <Skola> byorgey: it is hard indeed, but too often it is simply a case of library authors not being able to assess the knowledge of the API user
11:50:34 <Eduard_Munteanu> Heh.
11:50:38 <Cale> monochrom: ahaha
11:50:54 <Skola> byorgey: and a fetish for "clean/minimal" docs
11:50:59 <byorgey> Skola: yes, that's part of what makes it hard
11:51:02 <ski> @remember monochrom "customers who used == also liked: foldr, map, Ord, continuation passing style"
11:51:03 <lambdabot> Done.
11:51:04 <Skola> which I fully understand btw
11:51:17 <Skola> "why state the obvious?"
11:51:26 <davorak> Quick survey, is a explosion in the number of packages registered to GHC worth it to avoid dependency hell?
11:51:39 <monochrom> there is a fetish for "just read the source code"
11:51:39 <Skola> dabradley: I vote yes
11:51:45 <Skola> monochrom: yes
11:51:52 <byorgey> davorak: I don't understand the question.
11:51:58 <Eduard_Munteanu> Ondra: you can rebuild the array. But don't you want to start with an unboxed array to begin with?
11:52:21 <Eduard_Munteanu> @hoogle elems
11:52:21 <lambdabot> Data.IntMap elems :: IntMap a -> [a]
11:52:22 <lambdabot> Data.IntSet elems :: IntSet -> [Int]
11:52:22 <lambdabot> Data.Map elems :: Map k a -> [a]
11:52:28 <Eduard_Munteanu> @hoogle+
11:52:28 <lambdabot> Data.Set elems :: Set a -> [a]
11:52:28 <lambdabot> Data.Array.IArray elems :: (IArray a e, Ix i) => a i e -> [e]
11:52:28 <lambdabot> Data.Array elems :: Ix i => Array i e -> [e]
11:53:56 <davorak> byorgey: One method I read about to avoid dependency hell was to keep as many different compiled versions of a package nesscessary to meet the dependency requirements of the insstalled packages. Which then takes a considerable amount of HD space, or at least that is what was implied.
11:53:56 <matthiasgorgens> I want to parse a hexadecimal number with attoparsec.  normally I'd use the built-in hexadecimal for that.  But I want to restrict the parsing to 2 digits.  any ideas?
11:55:09 <byorgey> davorak: that might be worth it, if it actually solved dependency hell.
11:55:14 <monochrom> "keep different compiled versions of a package" is exponential
11:55:36 <byorgey> but I am quite skeptical.
11:56:39 <davorak> byorgey: I ask because created an install script for the nix packagemanagment system at least gets around the packaging problems that I was having.  Like right now I have the latest snap and yesod installed. Is there any famous case of dependency hell that I can test my script out on?
11:57:41 <monochrom> see my http://www.vex.net/~trebla/haskell/sicp.xhtml#pigeon . in fact, read the whole article
11:57:51 <Qtr> lets say i ahve a list [Nothing, Nothing, Just 5, Just 7] and i want the first Just, ie Just 5, how can i do that? msum maybe somehow i was told before
11:57:59 <Qtr> > msum maybe [Nothing]
11:58:00 <lambdabot>   Couldn't match expected type `[m a]'
11:58:00 <lambdabot>         against inferred type `b -> (a...
11:58:07 <Qtr> > maybe msum [Nothing]
11:58:08 <lambdabot>   Couldn't match expected type `a -> [m a1] -> m a1'
11:58:08 <lambdabot>         against inferred...
11:58:13 <monochrom> if x depends on y, and you change y's version, then you will rebuild x too, even if you don't change x's version
11:58:15 <Qtr> @type (maybe msum)
11:58:16 <lambdabot> forall (m :: * -> *) a a1. (MonadPlus m) => (a1 -> [m a] -> m a) -> Maybe a1 -> [m a] -> m a
11:58:21 <Saizan> it doesn't quite solve the problem of when you need to use the packages together, but that's not always solvable
11:58:27 <Qtr> @type (msum maybe)
11:58:28 <lambdabot>     Couldn't match expected type `[m a]'
11:58:28 <lambdabot>            against inferred type `b -> (a1 -> b) -> Maybe a1 -> b'
11:58:28 <lambdabot>     In the first argument of `msum', namely `maybe'
11:58:31 <Qtr> @type (maybe msum)
11:58:32 <lambdabot> forall (m :: * -> *) a a1. (MonadPlus m) => (a1 -> [m a] -> m a) -> Maybe a1 -> [m a] -> m a
11:58:47 <Qtr> :t maybe
11:58:48 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
11:59:00 <monochrom> if x depends on y depends on z, and you just change z's version, then you will rebuild x and y too
11:59:19 <Qtr> > maybe msum [Nothing, Just 5]
11:59:20 <lambdabot>   Couldn't match expected type `a -> [m a1] -> m a1'
11:59:20 <lambdabot>         against inferred...
11:59:20 <ozataman> anyone know a  good library for persistent hashing of common data types? I'm looking to implement a load-balancing strategy based on it, so it needs to be fast, evenly distributed and persistent across program runs.
11:59:25 <Qtr> > maybe msum Nothing [Nothing, Just 5]
11:59:26 <lambdabot>   Couldn't match expected type `a -> [m a1] -> m a1'
11:59:27 <lambdabot>         against inferred...
11:59:34 <Qtr> > msum [Nothing]
11:59:35 <lambdabot>   Nothing
11:59:38 <Qtr> :t msum
11:59:39 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => [m a] -> m a
11:59:53 <Qtr> > msum [Nothing, Just 5, Just 7]
11:59:54 <lambdabot>   Just 5
11:59:57 <Qtr> oh
12:00:04 <ozataman> (sorry, I meant consistent hashing)
12:02:03 <davorak> Does anyone have a set of libraries that are a good example for dependency hell stopping and install?
12:03:05 <Ondra> Yes, I'd like to learn how to work with http://hackage.haskell.org/packages/archive/HCodecs/0.0.3/doc/html/Codec-Wav.html. Right now I'm stuck with importing http://hackage.haskell.org/packages/archive/array/0.2.0.0/doc/html/Data-Array-Diff.html.
12:03:31 <monochrom> I think you can make one? X wants Y0 and Y1, Y0 wants containers == 0.4.0.0, Y1 wants containers == 0.5.0.0
12:05:09 <davorak> monochrom: Thanks
12:07:30 <Ondra> I have installed array-0.4.0.0 and I cannot import Data.Array.Diff. The help on web is for array-0.2.0.0.
12:09:40 <Saizan> Ondra: use a newer version of HCodecs which doesn't need Data.Array.Diff
12:12:34 <Cale> I'm not 100% sure why Data.Array.Diff was removed.
12:12:59 <Cale> The overheads in it were large, but there were cases where it was an improvement over plain immutable arrays.
12:13:45 <Cale> I guess it was also not threadsafe, which is pretty evil.
12:14:39 <Ondra> Saizan: thanks. But now I have a problem with "Predicate `IArray UArray Int' used as a type     In the type signature for `arr': arr :: IArray UArray Int". Could you help with this too?
12:15:16 <Saizan> Ondra: is that in your code?
12:15:34 <Saizan> Ondra: the problem is that IArray is not a type
12:15:46 <Ondra> I have "arr :: IArray UArray Int\narr = array (1, 100) [(i, 0) | i <- [1..100]]"
12:15:48 <Saizan> Ondra: it's a typeclass
12:16:04 <Cale> arr :: UArray Int Int
12:16:49 <Cale> (The first Int being the index type, and the second Int being the element type)
12:17:47 <Ondra> Thank you very much, now I have the array.
12:17:48 <Raynos> Is this a good place to ask language agnostic functional programming questions or is there a better room for that?
12:18:47 <srhb`> Raynos: This is probably a decent place to start out with, at least.
12:19:08 <srhb`> (I don't actually think there is a better channel on Freenode for that)
12:19:26 <Raynos> The notion of ncurry, where ncurry(4) returns a curry function that only curries upto 4 invocations. Does that have a more "popular" / "correct" name ?
12:19:33 <Ondra> It's a pitty HCodecs don't have an example page... now exportFile is having a problem with that type (although I believe it's what it needs).
12:21:05 <hape01> @help
12:21:06 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
12:21:07 <Qtr> Anyone here have opinions about syntactic abstraction?
12:21:14 <Qtr> Does haskell have c-style macros?
12:21:37 <jfischoff> Qtr: yes it can
12:21:46 <srhb`> Raynos: I think that's a clear name for it.
12:21:51 <Cale> Qtr: You can get ghc to run a cpp variant over your code
12:21:52 <Raynos> I got the name ncurry from here ( http://extralogical.net/projects/udon/#api-ncurry )
12:21:59 <Cale> using {-# LANGUAGE CPP #-}
12:22:15 <Cale> Qtr: It also has a proper macro system called Template Haskell
12:22:21 <hape01> @type flip
12:22:21 <Cale> fsvo proper
12:22:24 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
12:22:42 <__bob__> #haskellbla
12:22:45 <jfischoff> Qtr: If you use CPP I would recommend http://projects.haskell.org/cpphs/
12:22:48 <Qtr> But when would you need it? All code is platform independent isnt it? I guess you could system specific things that you interact with? And cabal takes care of building
12:23:05 <srhb`> Raynos: Mind I'm not sure what a functional language would actually need to support an ncurry function. I don't think that Haskell could, for instance.
12:23:15 <MagneticDuck> yo, is there any shorter way to write (length . elemIndicies)?
12:23:20 <srhb`> (Not without boilerplate for each n)
12:23:26 <MagneticDuck> @pl length . elemIndicies
12:23:26 <lambdabot> length . elemIndicies
12:23:30 <hape01> (+) flip 3 4       is wrong how could i write this?
12:23:41 <MagneticDuck> (+4)
12:23:50 <jfischoff> Qtr: its useful for different compilers different versions of a compiler.
12:23:52 <Raynos> srhb`: it's useful for n-ary functions. Of course whether I should use an n-ary function or accept a list as a parameter is a different question
12:23:54 <Ornedan> handle (\(ErrorCall err) -> print err) $ (let foo :: Int = read "arg" in print foo) -> "Prelude.read: no parse"
12:23:58 <azaq23> hm, I stumbled upon the book 'Algorithms: A functional programming' approach by Guy Lapalme / Fethi Rabhi in a library and borrowed it, it is also mentioned in the haskell wiki, looks nice
12:24:09 <Ornedan> However, handle (\(ErrorCall err) -> return 0) (let foo :: Int = read "arg" in return foo) >>= print  does not catch the exception
12:24:23 <MagneticDuck> hape01: or... flip (+) $ 3 $ 4
12:24:24 <Ornedan> What am I doing wrong in the latter case?
12:24:26 <srhb`> Raynos: Yes, of course.
12:24:34 <MagneticDuck> > flip (+) $ 3 $ 4
12:24:35 <lambdabot>   Overlapping instances for GHC.Show.Show (b -> b)
12:24:35 <lambdabot>    arising from a use of `...
12:24:37 <MagneticDuck> rr
12:24:43 <MagneticDuck> > flip (+) 3 4
12:24:45 <lambdabot>   7
12:24:50 <MagneticDuck> which is the same as
12:24:54 <Raynos> Is there actually a good article on n-ary functions vs just take a list as a parameter
12:24:54 <MagneticDuck> > (+) 3 4
12:24:55 <lambdabot>   7
12:24:59 <srhb`> MagneticDuck: Isn't length . elemIndices a type error to begin with? Why do you need a shorter version of a type error?
12:25:15 --- mode: ChanServ set +o mauke
12:25:15 --- mode: mauke set -b *!*@pta27-1-88-178-25-84.fbx.proxad.net
12:25:20 <geekosaur> > (+) `flip` 3 4 -- being weird
12:25:22 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
12:25:22 <lambdabot>    arising from a use of `...
12:25:33 <MagneticDuck> srhb`: No..
12:25:50 <MagneticDuck> (\list elem -> length $ elemIndicies elem list)
12:26:06 <hape01> MsgneticDuck: thank you
12:26:11 <MagneticDuck> hape01: np
12:26:24 <hape01> MagneticDuck: thank you
12:26:26 <srhb`> MagneticDuck: Oh, right, I misremembered what elemIndices did.
12:26:41 <__bob__> > [[[[[[[[[[[[[[[[[[[[[[[[[[[[[[42]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]
12:26:42 <lambdabot>   Context reduction stack overflow; size = 20
12:26:42 <lambdabot>  Use -fcontext-stack=N to incre...
12:26:47 <MagneticDuck> !!
12:26:54 <MagneticDuck> > [[[[[[[[[[13]]]]]]]]]]
12:26:55 <lambdabot>   [[[[[[[[[[13]]]]]]]]]]
12:27:06 <srhb`> MagneticDuck: But still, it would be clearer with length . elemIndices elem
12:27:07 <MagneticDuck> 20 eh
12:27:10 <__bob__> I was just trying to find the meaning of life
12:27:15 --- mode: mauke set -o mauke
12:27:40 <MagneticDuck> srhb`: Okay, my question was just if there's a function that counts the number of instances of an element in a list
12:27:40 <__bob__> yep
12:27:54 <MagneticDuck> obviously, there's not any shorter way to write f . g
12:27:58 <__bob__> length
12:28:02 <__bob__> f . g
12:28:08 <MagneticDuck> yes?
12:28:27 <MagneticDuck> length . filter (== element)
12:28:29 <MagneticDuck> if you prefer
12:28:35 <srhb`> MagneticDuck: I think it would be clearer with length . filter (==elem) but that's not shorter, just clearer
12:28:52 <MagneticDuck> ..my question is, is there any function that takes the place of it?
12:28:58 <MagneticDuck> in prelude or further out?
12:29:05 <MagneticDuck> doesn't seem to be in prelude
12:29:09 <srhb`> @hoogle [a] -> a -> Int
12:29:10 <lambdabot> Data.List elemIndex :: Eq a => a -> [a] -> Maybe Int
12:29:10 <lambdabot> Data.List elemIndices :: Eq a => a -> [a] -> [Int]
12:29:10 <lambdabot> Network.BufferType buf_concat :: BufferOp a -> [a] -> a
12:29:14 <srhb`> Nope.
12:29:24 <MagneticDuck> I'm surprised, as it's an important function
12:29:26 <MagneticDuck> ah well
12:29:43 <MagneticDuck> > 1 2 3
12:29:44 <srhb`> The combinators for that problem are strong and clear.
12:29:45 <lambdabot>   1
12:30:02 <MagneticDuck> I hate that functionality
12:30:07 <MagneticDuck> '1' is a function
12:30:09 <MagneticDuck> .___.
12:30:15 <MagneticDuck> why is that useful?
12:30:20 <MagneticDuck> @type 1
12:30:22 <lambdabot> forall t. (Num t) => t
12:30:24 <mauke> > (sin + cos) 1
12:30:26 <lambdabot>   1.3817732906760363
12:30:30 <srhb`> Yes, that instance is a bit quirky. At least it's not in Prelude :P
12:30:31 <mauke> > deriv (sin + cos) x
12:30:31 <MagneticDuck> !!
12:30:32 <lambdabot>   1 * cos x + 1 * negate (sin x)
12:30:43 <MagneticDuck> weird
12:30:49 <mauke> > deriv (sin + cos) 1
12:30:51 <lambdabot>   -0.30116867893975674
12:30:51 <MagneticDuck> how is it defined??
12:31:06 <MagneticDuck> @type sin + cos
12:31:08 <lambdabot> forall a. (Floating a) => a -> a
12:31:10 <mauke> MagneticDuck: you can define a Num instance for all Applicatives
12:31:13 <MagneticDuck> oh
12:31:18 <geekosaur> MagneticDuck, numeric literals are transparently turned into applications of fromIntegral
12:31:25 <MagneticDuck> @pl (\x -> sin x + cos x)
12:31:26 <lambdabot> liftM2 (+) sin cos
12:31:41 <geekosaur> if there's a function which has a num instance, numeric literals suddenly can be functions
12:31:41 <MagneticDuck> @type +
12:31:42 <lambdabot> parse error on input `+'
12:31:47 <geekosaur> Num instance
12:31:52 <MagneticDuck> @hoogle (+)
12:31:53 <lambdabot> Prelude (+) :: Num a => a -> a -> a
12:31:53 <lambdabot> Prelude (++) :: [a] -> [a] -> [a]
12:31:53 <lambdabot> Data.List (++) :: [a] -> [a] -> [a]
12:31:58 <MagneticDuck> ..
12:31:59 <Taneb> :t (+)
12:32:00 <lambdabot> forall a. (Num a) => a -> a -> a
12:32:05 <MagneticDuck> it makes me very confused
12:32:14 <MagneticDuck> + ISN'T just that
12:32:15 <srhb`> MagneticDuck: Your ghci won't do that to you. :)
12:32:19 <MagneticDuck> phew
12:32:20 <MagneticDuck> :P
12:32:29 <mauke> > sin cos pi
12:32:29 <MagneticDuck> what package is that from?
12:32:30 <lambdabot>   -0.8414709848078965
12:32:31 <Ondra> I've found the solution – I had to use SampleData Int16, Codec.Wav can work only with few AudibleInWav types.
12:32:37 <mauke> MagneticDuck: NumInstances IIRC
12:32:41 <MagneticDuck> ah yes
12:32:58 <mauke> > (sin cos) pi == sin (cos pi)
12:32:59 <lambdabot>   True
12:33:13 <ski> Ornedan : use `evaluate', not `return', there
12:33:28 <ski> Ornedan : or better, `readIO'
12:33:53 <ski> @type Control.Exception.evaluate
12:33:55 <lambdabot> forall a. a -> IO a
12:34:02 <ski> @type System.IO.readIO
12:34:03 <lambdabot> forall a. (Read a) => String -> IO a
12:34:14 <ski> Ornedan : or you can even use `reads'
12:34:24 <ski> (and don't much with exceptions at all)
12:34:25 <HairyDude> @hoogle Exception e => Either SomeException a -> (e -> a) -> a
12:34:26 <lambdabot> Prelude either :: (a -> c) -> (b -> c) -> Either a b -> c
12:34:26 <lambdabot> Data.Either either :: (a -> c) -> (b -> c) -> Either a b -> c
12:34:34 <hape01> length $ filter ...  ?
12:34:49 <Qtr> Traversable gives you map?
12:35:05 <roconnor_> > cos 355
12:35:07 <lambdabot>   -0.999999999545659
12:35:23 <HairyDude> I don't suppose this "pure catch" function exists? would make handling Either-type SomeExceptions a bit more convenient
12:35:32 <srhb`> Qtr: Yes, well, mapM
12:35:50 <__bob__> > let s = 1:s
12:35:53 <lambdabot>   not an expression: `let s = 1:s'
12:35:58 <__bob__> let s = 1:s in s
12:36:14 <__bob__> > let s = 1:s in s
12:36:15 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
12:36:15 <srhb`> __bob__: Cruelty to bots!
12:36:22 <roconnor_> > cos 22
12:36:23 <__bob__> sorry bot
12:36:24 <lambdabot>   -0.9999608263946371
12:36:36 <__bob__> Had to test it
12:36:47 <srhb`> __bob__: She doesn't mind too much... :-)
12:36:49 <Qtr> So Traversable gives you map right?
12:37:05 <ski> HairyDude : maybe you meant something like `Either SomeException a -> (forall e. Exception e => e -> a) -> a' ?
12:37:05 <__bob__> it's a she?
12:37:07 <srhb`> Qtr: So your irc client should have hilighting of your name :P
12:37:31 <HairyDude> ski: no, I just meant a pure version of catch
12:37:41 <HairyDude> :t Control.Exception.catch
12:37:42 <lambdabot> forall a e. (GHC.Exception.Exception e) => IO a -> (e -> IO a) -> IO a
12:38:07 <HairyDude> ^like this, but working on Either SomeExceptoin instead of IO
12:38:10 <ski> HairyDude : i don't see how `Exception e => Either SomeException a -> (e -> a) -> a' would be a "pure version of catch"
12:38:23 <__bob__> is it possible to do something like s = 1:s, in which s is a previous value of s
12:38:39 <__bob__> lazy evaluation is fun :)
12:38:43 <ski> HairyDude : what should happen if the `SomeException' doesn't contain an exception of type `e' ?
12:38:44 <srhb`> __bob__: Your pattern could include previous values
12:38:55 <ski> > let s = 1:s in s
12:38:56 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
12:38:57 <HairyDude> ski: ... point.
12:39:34 <Qtr> TicTacToeBoard { board :: [Mark] } --how should I define instance Traversable for that?
12:39:34 <__bob__> no, if I do let s = 1:s in s, it uses it recursively
12:39:37 <ski> HairyDude : so, either i think you want to handle every exception, in which case you possibly want something like i said, or you don't and then you want something different
12:40:01 <mauke> __bob__: what's the difference?
12:40:07 <ski> > let s0 = repeat 0 in let s1 = 1 : s0 in s1
12:40:08 <lambdabot>   [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
12:40:31 <roconnor_> > cos 103993
12:40:33 <lambdabot>   0.9999999998170342
12:40:36 <roconnor_> :(
12:40:45 <monochrom> why not just write "snew = 1:s" ?
12:40:45 <hape01> let s=1:2:zipWith (+) s (tail s) in take 5 s
12:40:49 <__bob__> The difference is if it uses previous value, it adds 1 to the list, and if it doesn't , it goes into a recursive loop
12:40:56 <HairyDude> ski: what I want is to use syntax like Control.Exception.catch where you supply it with successive types of handler and it transparently applies fromException
12:41:00 <roconnor_> > cos 104348
12:41:01 <lambdabot>   -0.9999999999393346
12:41:04 <ski> > (do s <- return (repeat 0); s <- return (1:s); return s) ()
12:41:05 <lambdabot>   [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
12:41:07 <roconnor_> bah
12:41:14 <HairyDude> ski: rather than using a guard and explicitly calling someException n times
12:41:20 <HairyDude> *fromException
12:41:32 <ski> > [s | s <- [repeat 0] , s <- [1:s]]
12:41:33 <lambdabot>   [[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0...
12:41:34 <srhb`> __bob__: Then no, those values of s are gone.
12:41:54 <ski> __bob__ : any of those work for you ?
12:42:09 <__bob__> yet another thing Haskell does differently from other languages
12:42:16 <monochrom> I'm pretty sure __bob__ means: how to have mutable variable
12:42:30 <monochrom> and my answer is: don't bother. yet.
12:42:32 <srhb`> That's how I read it too.
12:42:48 <monochrom> just write "let snew = 1:s in ..." and use snew
12:42:49 <mauke> __bob__: huh?
12:43:05 <Qtr> TicTacToeBoard { board :: [Mark] } --how should I define instance Traversable for that?
12:43:17 <ski> HairyDude : so, something like `Exception e => Either SomeException a -> (e -> a) -> Either SomeException a' ?
12:43:36 <__bob__> in C one can write let s=s
12:43:42 <monochrom> Exception e => Either e a -> (e -> a) -> a
12:43:47 <hape01> > [x|x <- [1..10], odd x]
12:43:48 <__bob__> or let s=s+1
12:43:49 <lambdabot>   [1,3,5,7,9]
12:43:53 <__bob__> in haskell it freezes
12:44:03 <ski> HairyDude : where `SomeException' in the output is for those exceptions which aren't caught (those not of type `e')
12:44:04 <srhb> __bob__: c has mutable state.
12:44:18 <srhb> __bob__: Haskell is pure.
12:44:20 <Qtr> Also, TicTacToeBoard { board :: [Mark] } isnt just TicTacToeBoard [Mark] better unless you have a lot of identifiers perhaps, why use the function in there?
12:44:44 <mauke> __bob__: 1) no, you can't  2) int x = x; has undefined behavior
12:44:48 <srhb> __bob__: You can make infinite lists etc. like that, but not, say addition.
12:44:51 * geekosaur thinks let being recursive by default is not quite the same thing though (and is surprising initially)
12:44:53 <monochrom> see my http://hpaste.org/52480 example program that seems to have state but doesn't
12:45:13 <monochrom> (or maybe seems to have no state but does have state?)
12:45:14 <mauke> __bob__: you can write struct node s = { 1, &s }; though. that's a cyclic list
12:45:16 <ski> __bob__ : `s = s + 1' in Haskell is a recursive binding. `s = s + 1;' in C isn't even a binding, it's an assignment
12:45:42 <__bob__> yeah
12:45:44 <HairyDude> ski: I guess that works, since you could finish it with something like "Either SomeException a -> (SomeException -> a) -> a" to make the Either go away in the end
12:45:47 <monochrom> and yes I hate basic and c use "=" for assignment. x=x+1, therefore 0=1?
12:46:20 <__bob__> if you write int x = x+1 it is undefined
12:46:24 <mroman> Error: Invalid lvalue
12:46:30 <HairyDude> (that would obviously be implemented as "flip either id")
12:46:34 <hape01> @type (=)
12:46:35 <lambdabot> parse error on input `='
12:46:44 <ski> HairyDude : however, with these kind of things, i think it's good to have the more general `Exception e => Either SomeException a -> (e -> b) -> (a -> b) -> Either SomeException b'
12:46:50 <monochrom> I had marked a student's proof of a forall-m statement. "let m be a given natural number. if m is even, let m=m-1"
12:47:39 <HairyDude> ski: that type would make it hard to apply with infix syntax.
12:47:43 <monochrom> total loss victim of modern programming languages
12:47:49 <srhb> monochrom: Cute though :P
12:47:53 <hape01> @type (==)
12:47:54 <__bob__> because x contains garbage until it is initialized
12:47:54 <lambdabot> forall a. (Eq a) => a -> a -> Bool
12:48:11 <Qtr> invert X = O; invert O = X; invert E = error, hiw would you do that? Maybe?
12:48:41 <ski> HairyDude : possibly, but quite often you really want an "otherwise (no exception)" branch at the same time (which the handler does not extend over)
12:48:44 <mauke> Qtr: like that
12:49:00 <ski> HairyDude : not saying you always want it, but often, ime
12:49:17 <nand`> monochrom: why didn't he just write “let m be an odd natural number” ?
12:49:31 <ski> nand` : .. or minus one
12:49:50 <mauke> let m be a given natural number times 2
12:50:26 <monochrom> "let m be given" is to satisfy "for all m"
12:50:52 <monochrom> but the rest of the statement to be proved wants an odd number related to m
12:51:09 <nand`> then that doesn't seem very consistent, since m≠m-1, ¬(m is even)
12:51:31 <monochrom> yeah, read "m = m - 1" as a piece of C code, that's what's in the student's mind
12:51:59 <ski> __bob__ : well, unless `x' was already in scope, wouldn't `int x = x + 1;' be a scope error ?
12:52:00 <monochrom> you see why I hate abusing "="?
12:52:13 <monochrom> you see why I hate all modern programming languages?
12:52:21 <mauke> monochrom: I think of it as shadowing
12:52:25 <mauke> implied m'
12:52:29 <nand`> monochrom: that seems like an awfully weird system of logic
12:52:49 <monochrom> well it's a student's logic, not mine
12:53:03 <__bob__> int c= c+1 would compile in C
12:53:07 <monochrom> call it System Python-C or something
12:53:12 <__bob__> but it would not work correctly
12:53:16 <__bob__> it would probably crasah the system
12:53:33 <__bob__> but int c = 0;
12:53:34 <__bob__> c = c+1 is correct
12:53:42 <__bob__> there's even a shorthand for that
12:53:45 <__bob__> c += 1
12:53:53 <__bob__> or increment operator c++;
12:53:57 <srhb> __bob__: Most of us know some basic C at least. ;) Why are you telling us this.
12:53:58 <__bob__> xD
12:54:25 <__bob__> because someone said that c = c+1 is incorrect in C
12:54:32 <nand`> __bob__: drat, I was well on my way to forgetting C. Now you reminded me, it's like a psychological avoidance game :(
12:54:34 <monochrom> no one said that.
12:54:35 <srhb> That was not what was said.
12:54:40 <HairyDude> pattern guards help a lot when you're using fromException.
12:54:49 <monochrom> I said C is incorret. if you read me correctly.
12:54:50 <__bob__> nand`: lol sorry
12:54:56 <gwern> @quote incorrect
12:54:57 <lambdabot> gFunk says: [the main advantage of functional programs are that they're] incorrect the first 1000 times you try to compile it!
12:55:20 <daniel_-> is there any good resources for learning more in-depth about type classes? i've read the chapters on RWH and LYAH and the haskellwiki
12:55:21 <Qtr> C is great
12:55:26 <__bob__> no, different quote
12:55:34 <zachk> daniel_-: look up the typeclassopedia
12:55:34 <srhb> Stop talking about C. :-(
12:55:36 <__bob__> I had to restart computer
12:55:41 <Eduard_Munteanu> @where typeclassopedia
12:55:42 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
12:55:44 <__bob__> so I probably didn't read that
12:55:47 <HairyDude> monochrom: wait, did you imply you hate Haskell?
12:56:04 <monochrom> a little bit
12:56:18 <Taneb> @where my computer
12:56:18 <lambdabot> I know nothing about my.
12:56:20 <nand`> Does Haskell classify as ‘modern’?
12:56:20 <Taneb> :(
12:56:25 <monochrom> yes
12:56:36 <Taneb> @where+ my Under your bed!
12:56:36 <lambdabot> Good to know.
12:56:40 <Taneb> @where my computer
12:56:40 <lambdabot> Under your bed!
12:56:44 <Taneb> Prefect
12:56:52 <Taneb> @where my hat
12:56:52 <lambdabot> Under your bed!
12:56:54 <HairyDude> nand`: define modern
12:57:13 <__bob__> @where that dead prostitute?
12:57:13 <lambdabot> I know nothing about that.
12:57:14 <monochrom> well, I brought up "modern" so you would ask me
12:57:14 <k0001> @where my modern language
12:57:15 <lambdabot> Under your bed!
12:57:17 <nand`> HairyDude: I don't know exactly what ‘modern’ means either
12:57:32 <monochrom> but I already answered yes
12:57:42 <nand`> monochrom: that is a good idea, since language perception is inherently subjective it's best to ask the one who used the word what he meant
12:57:45 <__bob__> why it didn't answer my question?
12:58:02 <__bob__> @where stuff
12:58:02 <lambdabot> I know nothing about stuff.
12:58:10 <nand`> __bob__: because it doesn't start with ‘my’
12:58:14 <__bob__> oh
12:58:18 <__bob__> silly me
12:58:25 <__bob__> @where my stuff
12:58:25 <lambdabot> Under your bed!
12:58:28 <monochrom> it's a good idea, but it's sad that you have to say that it's a good idea. isn't it like obvious?
12:58:32 <nand`> @where my bed
12:58:32 <lambdabot> Under your bed!
12:58:35 <nand`> recursion!
12:58:41 <__bob__> horray!
12:59:00 <Eduard_Munteanu> > fix ("my bed " ++)
12:59:02 <lambdabot>   "my bed my bed my bed my bed my bed my bed my bed my bed my bed my bed my b...
12:59:38 <monochrom> we have no end of questions in #haskell and math channels saying "my teacher said 'comodify', what does it mean?"  well why don't you ask that teacher? random strangers on the internet wouldn't know
12:59:59 <jfischoff> @src fix
12:59:59 <lambdabot> fix f = let x = f x in x
13:00:09 <BMeph_> monochrom: Eh? It's a good idea to say that you hate Haskell?
13:00:12 <srhb> monochrom: Eh, bad teachers are a dime a dozen
13:00:20 <Eduard_Munteanu> monochrom: maybe because it's 1am and the assignment is due next morning? :)
13:00:30 <monochrom> no, it's a good idea to ask the speaker, not a random stranger, what the speaker means.
13:00:44 <HairyDude> Eduard_Munteanu: but in that case, it would be a good idea to have asked the teacher earlier :)
13:00:48 <srhb> In my experience, the teachers has been asked and is still horrible at conveying the meaning.
13:00:48 <__bob__> what if the speaker is per 1000 students?
13:00:54 <monochrom> and no, the teacher has already defined comodify in the course material
13:00:58 <srhb> I wouldn't judge people that fast.
13:01:20 <nand`> monochrom: I guess I'm just used to nitpicking over (in)correct word usage that the concept of subjective words has escaped my intuition
13:01:23 <HairyDude> __bob__: then the student should get a better institution.
13:01:27 <Eduard_Munteanu> monochrom: did you ever catch your students around #haskell?
13:01:46 <Eduard_Munteanu> If you taught such a course.
13:02:03 <Eduard_Munteanu> *you ever
13:02:04 <monochrom> no, I have witnessed a few cases where I challenged the student to upload some course material, and it contained good definitions
13:02:06 <BMeph_> monochrom: Oh, so hating Haskell isn't a good idea?:-)
13:02:49 <nand`> BMeph_: saying you hate Haskell isn't
13:02:49 <__bob__> why is everyone talking about hating Haskell?
13:03:00 <coppro> I hate hating haskell
13:03:01 <nand`> __bob__: BMeph_ asked monochrom, and it seemed like monochrom replied with ‘no’
13:03:27 <nand`> but that might have been an implicit ‘you mis(heard|understood)’
13:03:32 <monochrom> anyway if you harp "don't judge so quickly", I would say the teacher is the one you would judge most slowly. you haven't even heard the teacher's side of the story
13:03:50 * BMeph_ believes monochrom was answering another question
13:04:08 <monochrom> I answered yes I hate haskell a little bit
13:04:17 <monochrom> and yes haskell is a modern language
13:04:24 <__bob__> how to do *someone thinks something
13:04:31 <monochrom> /me
13:04:40 * __bob__ me
13:04:50 * __bob__ thinks that this is awesome
13:05:01 <monochrom> I haven't seen my students in #haskell
13:05:11 <HairyDude> __bob__: welcome to IRC
13:05:16 * ski stares intently at __bob__ 
13:05:17 <nand`> BMeph_: also possible. I personally don't think it's a bad idea, since expressions opinions shouldn't be considered wrong
13:05:33 * Eduard_Munteanu
13:06:02 * ski . o O ( "Utu" <http://www.savingtheinternetwithhate.com/> )
13:06:11 --- mode: ChanServ set +o mauke
13:06:11 --- mode: mauke set -b *!*@115.124.64.25
13:06:11 --- mode: mauke set -b *!*@115.124.64.25
13:06:19 <mauke> ｆｏｎｔ ｔｅｓｔ ʇsǝʇ ʇuoɟ fᴏɴᴛ ᴛᴇsᴛ ᶠᵒⁿᵗ ᵗᵉˢᵗ
13:06:22 <monochrom> well, it is not just students. numerous times on usenet, I posted things, and then there would be long threads arguing over what I mean. no one asked me.
13:07:01 <monochrom> if you say horrible teachers, students, and usenet people are a dime a dozen, I will agree :)
13:07:02 <Eduard_Munteanu> monochrom: they either have a weird sense of what's right and wrong, or they don't deserve to pass if they never stop by :P
13:07:14 <nand`> mauke: is that third one lower case blackboard bold?
13:07:22 <srhb> monochrom: All of this is true, but I put more value in good teachers than good students. :P
13:07:22 <__bob__> monochrom: if they asked you, there would be no point in discussing it in a long thread
13:07:39 <nand`> or does that ℕ just looks conspicuously similar? (in my rendering)
13:07:40 <HairyDude> monochrom: Sturgeon's law. Horrible everything is a dime a dozen.
13:07:48 <ski> mauke : is the wide charaters at the front just different unicode characters, or did you use some kind of escape codes ?
13:07:49 <monochrom> __bob__ nails it, hahaha
13:08:11 --- mode: mauke set -o mauke
13:08:17 <__bob__> λ
13:08:28 <HairyDude> I see boxes containing FF46, FF4F, FF4E, FF54 etc.
13:08:34 <HairyDude> so I'm guessing unicode.
13:08:42 <mauke> nand`: no, small caps
13:08:45 <__bob__> 
13:08:48 <monochrom> the wide characters are different unicode characters. and you have just known their codepoint numbers
13:08:56 <__bob__> I don't get why  is so small when it appears on the screen
13:08:57 <HairyDude> indeed
13:09:03 <__bob__> when I type , it is actually pretty bitg
13:09:16 <mauke> __bob__: what is that? I only see an empty square
13:09:34 <__bob__> on my computer, it apears as ubuntu sign
13:09:45 <nand`> mauke: ah. In that case, 𝔽𝕆ℕ𝕋 𝕋𝔼𝕊𝕋 𝕗𝕠𝕟𝕥 𝕥𝕖𝕤𝕥
13:09:48 <__bob__> but that may be only because I use ubuntu
13:09:52 <nand`> my font only gets ℕ :(
13:10:00 <mauke> nice
13:10:10 <Eduard_Munteanu> nand`: DejaVu Sans Mono, by chance?
13:10:21 <Eduard_Munteanu> Same here.
13:10:32 <Eduard_Munteanu> Unless those really are boxes :D
13:10:36 <mauke> nand`: I can see all of them (using Mincho (except for ℕ, which is DejaVu Sans Mono))
13:10:36 <nand`> Eduard_Munteanu: mixture of terminus and ‘Fixed’, whatever that is
13:10:53 <__bob__> ￯Ͽμ｟
13:11:00 <__bob__> fun
13:11:10 <nand`> ⟨ ⟩ <- does anybody else see this properly?
13:11:14 <mauke> nand`: yes
13:11:14 <srhb> nand`: Yes
13:11:20 <ski> aye
13:11:23 <nand`> awesome
13:11:23 <__bob__> square brackets?
13:11:25 <__bob__> yeah
13:11:26 <srhb> Assuming that they are angled brackets with a space between
13:11:28 <nand`> __bob__: no, angled
13:11:41 <nand`> srhb: correct. I've used them for tuple notation on occasion
13:11:42 <__bob__> that's what I meant
13:11:48 * __bob__ thinks that unicode is really fun
13:11:56 <monochrom> angle brackets
13:12:10 <chrisdone> evening, squire
13:12:27 <monochrom> how about a release?
13:12:45 <Eduard_Munteanu> chrisdone: evening
13:14:23 --- mode: ChanServ set +o mauke
13:14:23 --- mode: mauke set -b *!*@82.201.209.195
13:14:50 <chrisdone> @vixen give me a cookie
13:14:51 <lambdabot> Scrubbing floors and emptying bedpans has as much dignity as the Presidency.
13:15:01 <monochrom> vixen is down
13:15:30 <monochrom> http://www.vex.net/~trebla/vixen.txt is a log of why
13:15:31 <chrisdone> did she go to clean the windows?
13:15:57 <Eduard_Munteanu> You haven't been in here lately, have you? (FSVO lately)
13:15:59 <triyo> Anyone know of any books or publications on the subject matter of `Distributed computing', geared towards `Asynchronous messaging and purity'?
13:16:05 <triyo> I've read the `Toward the Haskell Cloud' which I'm really following closely now.
13:16:23 --- mode: mauke set -o mauke
13:17:19 <chrisdone> fair enough
13:18:28 <chrisdone> Eduard_Munteanu: nah, try to limit my irc'ing down to a minimumBy . comparing
13:18:35 <Eduard_Munteanu> It autocorrects to @nixon now, which can be just as bad at times, FWIW.
13:18:47 <Eduard_Munteanu> Heh.
13:19:03 <chrisdone> it would be fun to use Text.MarkovChain + the #haskell IRC logs to make a @haskeller command :p
13:19:28 <monochrom> the most funny part is <byorgey> what have I done.
13:19:39 <chrisdone> lol
13:22:19 <hpaste> Sofi pasted “Sofi” at http://hpaste.org/72089
13:24:05 --- mode: ChanServ set +o mauke
13:24:05 --- mode: mauke set -b *!*@93.99.16.254
13:24:05 --- mode: mauke set -b *!*@93.99.16.254
13:24:31 <Eduard_Munteanu> Um, why "mauke, mauke"?
13:24:36 <latro`a> is there a class for functors where the starting category isn't necessarily Hask
13:24:36 <latro`a> ?
13:24:53 <Eduard_Munteanu> latro`a: not standard stuff, no
13:24:56 <latro`a> k
13:25:14 <mauke> Eduard_Munteanu: good question. there must be a bug in my script(s) that cause two timers to be started
13:26:04 <Eduard_Munteanu> latro`a: you can define one, though
13:26:05 --- mode: mauke set -o mauke
13:26:34 <hpaste> Sofi pasted “Sofi” at http://hpaste.org/72090
13:26:57 <Eduard_Munteanu> latro`a: there might be one in edwardk's stuff as well
13:26:59 * Eduard_Munteanu looks
13:27:27 <edwardk> latro`a: check 'categories'
13:27:33 <edwardk> latro`a: i have Control.Categorical.Functor in there
13:27:42 <latro`a> thanks
13:27:49 <edwardk> which can be used for Functors between two categories that aren't necessarily Hask
13:27:54 <edwardk> i have more limited cases in other packages
13:28:06 <edwardk> e.g. contravariant exposes Contravariant for functors from Hask^Op
13:28:21 <edwardk> and there are some semifunctor types lying around in semigroupoids
13:28:36 <latro`a> hm, maybe I misunderstand--why 3 type variables?
13:28:45 <Eduard_Munteanu> edwardk: what's that, a functor-like thing for semigroupoids?
13:29:43 <edwardk> Eduard_Munteanu: yeah
13:29:47 <Eduard_Munteanu> latro`a: it's parametrized by the source and target categories
13:29:55 <edwardk> latro`a: the functor and the source and destination category
13:29:59 <edwardk> [] (->) (->)
13:30:27 <latro`a> hm...
13:32:06 --- mode: ChanServ set +o mauke
13:32:06 --- mode: mauke set -b *!*@fw.netline.cl
13:32:27 <latro`a> can you give an example of what the parameters would look like in a case where one isn't Hask?
13:33:10 <ski> possibly latro`a was looking for something like `class Functor1 t where tmap :: (Functor f,Functor g) => (forall a. f a -> g a) -> (t f -> t g)' ?
13:33:17 <latro`a> I was expecting that, yeah
13:33:30 <latro`a> er, no, not that, actually
13:33:51 <ski>   tmap :: (Functor f,Functor g) => (forall a. f a -> g a) -> (forall a. t f -> t g a)  -- ?
13:34:06 --- mode: mauke set -o mauke
13:34:15 <latro`a> why the t g?
13:34:27 <ski> (er, that should of course be `... -> (forall a. t f a -> t g a)')
13:34:31 <latro`a> I was expecting (f a -> f b) -> (g a -> g b)
13:35:14 <ski> latro`a : what would be the functor in that case ?
13:35:21 <latro`a> so for example instance Functor (Either a) Maybe where fmap f = fmap f . eitherToMaybe; eitherToMaybe Left _ = Nothing; eitherToMaybe (Just x) = Right x
13:35:50 <Eduard_Munteanu> latro`a: you could have Functor M (->) (Kleisli M) for some monad M.
13:36:01 <ski> latro`a : again, what would be the functor in that case ?
13:36:12 <gtmanfred> hh ok
13:36:14 <gtmanfred> ...
13:36:27 <ocharles> :t extend
13:36:28 <lambdabot> Not in scope: `extend'
13:36:31 <ocharles> @index extend
13:36:31 <lambdabot> bzzt
13:36:39 <gtmanfred> how... how did my buffer change :-/
13:36:49 <latro`a> I'm not following what you mean by "the functor"
13:36:53 <Eduard_Munteanu> Erm, no.
13:37:26 <Eduard_Munteanu> But you could decompose a monad into an adjoint pair of functors and get a functor on those categories.
13:37:48 <__bob__> @protontorpedo
13:37:48 <lambdabot> how does haskell compare to c++?
13:37:57 <monochrom> heh
13:38:01 <__bob__> @protontorpedo
13:38:02 <lambdabot> how is haskell different than java?
13:38:07 <__bob__> @protontorpedo
13:38:07 <lambdabot> how does j2ee compare to haskell?
13:38:17 <Eduard_Munteanu> @yarr
13:38:17 <lambdabot> Splice the Mainbrace!
13:38:20 <latro`a> eduard--iirc you can't actually always do that with monads in haskell's sense
13:38:53 <latro`a> because doing that requires the comonad, which categorically always exists but afaict doesn't always exist in the haskell sense
13:39:15 <startling> is there something somewhere for pretty-printing tree-like structures?
13:39:41 <latro`a> ski--what do you mean by "the functor"
13:39:53 <Eduard_Munteanu> latro`a: you do get a comonad too, just not on a useful category
13:39:56 <ski> latro`a : a functor should be a "map"/"function" from the source category, to the target category
13:40:12 <latro`a> correct; I've presented one
13:40:26 <ski> latro`a : in case of `Functor Maybe', `Maybe' is the functor, it maps types in `*' to types in `*' (iow `Maybe :: * -> *')
13:40:51 <Eduard_Munteanu> latro`a: if you get F -| U, M = UF : Hask -> Hask, then W = FU : Hask_M -> Hask_M
13:40:51 <startling> ski: oh wut
13:40:53 <startling> that's beautiful
13:41:02 <ski> latro`a : if you've presented a functor, surely you can tell me what it is ?
13:41:09 <ski> startling : huh ?
13:41:14 <Eduard_Munteanu> (say, through the Kleisli construction)
13:41:25 <latro`a> I think I'm seeing what you're saying; the actual parameter of the functor isn't there in my presentation
13:41:39 <startling> ski: never thought of functors like that, and haven't gotten there in my algebra book yet. :)
13:41:47 <ski> latro`a : i.e., which part of `instance Functor (Either a) Maybe where fmap f = fmap f . eitherToMaybe; eitherToMaybe Left _ = Nothing; eitherToMaybe (Just x) = Right x' (if any) would be the functor ?
13:42:34 <latro`a> fmap maps arrows in the category Either a to the category Maybe
13:42:39 <ski> latro`a : `Maybe' maps types `a' to `Maybe a', so we could say `Maybe' is the same as `a |-> Maybe a' (or `\a -> Maybe a', in Haskell notation)
13:43:13 <latro`a> so you're saying the problem is that I don't have a constructor present for the functor
13:43:18 <latro`a> which is why we need a third parameter
13:43:24 <latro`a> *type constructor
13:43:27 <ski> latro`a : you might try with `Either a b |-> Maybe b' in your case, but that's not a total function : it only maps types of shape `Either a b' to something
13:43:46 <latro`a> wait, what, how is that not total?
13:43:47 <ski> latro`a : s/type constructor/type function/
13:43:54 <Eduard_Munteanu> The type constructor *is* the functor (more precisely, the part that maps objects).
13:44:05 <latro`a> right
13:44:08 <Eduard_Munteanu> And fmap is what maps the arrows.
13:44:13 <latro`a> right
13:44:13 <ski> latro`a : in Haskell, to declare an instance of `Functor', you have to have a type constructor, but conceptually, any type function would do
13:44:39 <latro`a> what would that be, for this case?
13:44:50 <latro`a> as in, how would I write one down in Haskell notation
13:45:11 <Eduard_Munteanu> Well, you can see type synonym instances as a way around that, for example, but not really useful.
13:45:21 <ski> latro`a : "wait, what, how is that not total?", given the type `IORef', what type would your presumed functor `Either a b |-> Maybe b' map it to ?
13:45:24 <Eduard_Munteanu> Or type families.
13:45:34 <latro`a> it's not total over Hask, ski
13:45:40 <latro`a> that's irrelevant
13:45:40 <ski> right
13:45:49 <latro`a> I'm mapping between subcategories of Hask
13:46:17 <ski> oh, so you're talking about a subcategory which contains objects/types of shape `Either a b' ?
13:46:21 <latro`a> yes
13:46:53 <lewis1711> can you use recursive datatypes to describe formal languages? (assuming the language itself can be described recursively). they look very similar but I may be drawing false links
13:48:05 <latro`a> there is a category consisting of types Either a b and morphisms (Either a b -> Either c d). there is then a functor which takes types of the form Either a b into types of the form Maybe b. it is accompanied by a value function eitherToMaybe :: Either a b -> Maybe b and an arrow function (Either a b -> Either c d) -> (Maybe b -> Maybe d)
13:48:24 <latro`a> the latter is what I'd be inclined to call fmap
13:48:25 <ski> latro`a : i think you'd need to declare a kind of pairs of objects `a' and `b', `Pair a b', and then your morphism arrow `EitherFun' would map `Pair a b' to `Either a b'
13:49:04 <latro`a> why does that help?
13:49:28 <ski> your objects here really are pairs of Haskell types
13:49:46 <latro`a> right, but Either already is that, minus its having additional structure imparted from the standard library
13:49:55 <latro`a> which can be hidden anyway
13:50:16 <ski> no, `Either a b' has kind `*', not kind "pair of two types, each of kind `*'"
13:50:19 <Eduard_Munteanu> Unfortunately you can't quite restrict functors' domains in Haskell.
13:51:05 <latro`a> not with a single parameter Functor class, no, but I don't see how what I wrote down is a problem
13:51:34 <latro`a> in effect the standard Functor class is what I wrote down with the first parameter being Identity
13:51:35 <ski> to be able to specify your category, each object must be a pair of types of kind `*'
13:51:36 <Eduard_Munteanu> It is if you expect to define the functor's type function.
13:52:11 <latro`a> oh I see the problem; you can't "type level pattern match"
13:52:15 <latro`a> to get at the b
13:52:34 <ski> latro`a : yes. i'm not saying what you defined is bad. i'm only saying that if you want to call it a functor, it must be a functor from a category whose objects are pairs of types from `*'
13:52:59 <ski> (otherwise, it might still be useful, but it won't be a functor)
13:53:01 <latro`a> er, you have two "from"s
13:53:32 <ski> replace the latter "from" with "in", if you please
13:53:41 <latro`a> ah
13:53:42 <latro`a> k
13:54:03 <Eduard_Munteanu> You can do it somewhat using type families AFAIU.
13:54:09 <latro`a> you see the functor mathematically, though, I assume
13:54:27 <ski> yeah, it might be possible to do partial tricks with type families
13:54:35 <ski> latro`a : yes
13:57:03 <dzhus> I forgot, is it nice to pack libs and executables into separate packages? Seems like no.
13:57:04 <ski> something like `data kind Prod k0 k1 = Pair k0 k1', and then defining `EitherFun :: Prod * * -> Prod * * -> *', such that `EitherFun (Pair a0 a1) (Pair b0 b1) = Either a0 a1 -> Either b0 b1', i think
13:57:32 <ski> (maybe you need type/data families to even state the definition of `EitherFun', not sure)
13:58:02 <Eduard_Munteanu> Maybe there's more fun to be had with the new kinds recent GHCs added.
13:58:36 <Eduard_Munteanu> Like type-level nats and such things.
14:00:51 <ski> (note that `EitherFun' above really is not partial, since the kind `Prod k0 k1' is closed)
14:02:32 <ski> latro`a : "so you're saying the problem is that I don't have a type constructor present for the functor","which is why we need a third parameter" -- roughly, yes, i think
14:03:14 <latro`a> this is actually a bit surprising, especially since I can write down the value-function
14:03:20 <latro`a> (which you don't always have, obviously)
14:03:45 <edwardk> latro`a: the category you want for values that look like Either a b -- is the sum category of two categories.
14:03:54 <latro`a> indeed
14:04:04 <edwardk> latro`a: this is defineable -- using some painful extensions that are only just now becoming available
14:04:18 <edwardk> it requires that Control.Category be polykinded
14:04:34 <ski> edwardk : well, latro`a said morphisms should look like `Either a0 a1 -> Either b0 b1'
14:04:55 <ski> (iiuc)
14:05:38 <edwardk> oh
14:05:52 * ski would say s/polykinded/polymorphic/
14:06:17 <Eduard_Munteanu> Kind polymorphism maybe?
14:06:17 <edwardk> thats a little off
14:06:26 <edwardk> since those arrows are too general
14:06:46 <edwardk> the arrows in the sum category are effectively Either (a -> b) (c -> d)
14:06:57 <edwardk> they are arrows in one category or the other
14:07:08 <ski> (saying "polykinded" to me sounds related to "polymorphic kinds", which we don't have in Haskell, even with recent extensions (what those extensions add is polymorphic *types* (and classes), not polymorphic kinds))
14:07:14 <edwardk> the type he gave can have arrows that 'cross' categories
14:07:15 <latro`a> ah hm, then you're right, I'm fishing for something a little stronger
14:07:20 <Eduard_Munteanu> edwardk: erm, wouldn't that be a category over Either?
14:07:31 <Eduard_Munteanu> edwardk: um, enriched over Either
14:07:49 <c_wraith> ski: the PolyKinds extension doesn't introduce polymorphic kinds?
14:08:05 <edwardk> the coproduct semigroupoid of two semigroupoids is in http://hackage.haskell.org/packages/archive/semigroupoid-extras/3.0/doc/html/Data-Semigroupoid-Coproduct.html
14:08:22 <c_wraith> ski: I seem to remember it lets you specify kind variables in kind signatures - doesn't that imply they're polymorphic?
14:08:34 <edwardk> (i did semigroupoids rather than categories because at the type PolyKinds didn't exist
14:08:40 <Eduard_Munteanu> c_wraith: it doesn't? I haven't read much about it, but you get stuff like * :: BOX etc.
14:08:43 <ski> c_wraith : not to my knowledge. note that if `newtype O f g a = MkO (f (g a))' gives `O :: forall k0 k1. (k1 -> *) -> (k0 -> k1) -> (k0 -> *)', then `O' is a polymorphic *kind*
14:09:03 <edwardk> thats what we get with polykinds ;)
14:09:13 <ski> c_wraith : cf. how `length :: forall a. [a] -> Int' says that `length' is a polymorphic *value* (not a polymorphic type)
14:09:23 <ski> edwardk : *nod*
14:09:39 <ski> (which is why i feel they're sortof a misnomer)
14:10:07 <c_wraith> but length isn't polymorphically typed?
14:10:12 <ski> c_wraith : also, `forall a. [a] -> Int' is of course not a polymorphic type, it's a universal type (`O' above would be a polymorphic type) :)
14:10:38 <ski> c_wraith : you could perhaps say so, as long as you're aware that it's `length', not its type, which is polymorphic
14:10:43 <Eduard_Munteanu> I guess one could add a fourth type parameter to that Functor and pretend they're functors on enriched categories no?
14:11:07 <ski> (also, `Maybe' is not a "polymorphic type", it's a parametric type, or a type function)
14:11:14 <edwardk> Category :: forall k. (k -> k -> *) -> Constraint. Category is a type that uses polymorphic kinds, k is a polymorphic kind ;)
14:11:19 <edwardk> so in that sense i agree
14:11:44 <ski> `Category' is a polymorphic class (which is a kind of polymorphic type), yes
14:11:54 <ski> `k' there is a kind variable, it's not polymorphic
14:12:19 <ski> (if `k' was polymorphic, we would have something like `k :: forall_sort s. ..s..')
14:12:33 <Eduard_Munteanu> class (Category r, Category t, Category u) => Functor f r t | f r -> t, f t -> r, r t -> u where fmap :: u (r a b) (t (f a) (f b))
14:12:39 <Eduard_Munteanu> Or something like that.
14:13:25 <Eduard_Munteanu> *Functor f r t u
14:13:25 <ski> (but of course we don't have that, we have `k :: *2', or however you want to write it)
14:13:38 <scooty-puff> i am using STRefs (really an arbirary * -> * using a MonadRef type class) and need to store them in a map - to act as kind of a first cache before looking at what they point too (not really accurate, but close enough) - since it could be any arbirary "ref a" (IORef a, etc.), i need a general map or type class for maps/sets
14:13:41 <scooty-puff> any advice?
14:14:00 <scooty-puff> i am currently using a data family and type class
14:14:21 <scooty-puff> but am wondering if a Hashable constraint would be too horrible, or something anyways
14:14:50 <ski> Eduard_Munteanu : hm, how useful is it there to have `u' be different from `(->)' ?
14:15:24 <Eduard_Munteanu> I'm not sure it's particularly useful.
14:15:48 <ski> not having it be `(->)' sounds like internal or enriched categories, or something
14:15:52 <Eduard_Munteanu> But it looks like it gets you enriched categories and functors, no?
14:16:00 <Eduard_Munteanu> Yeah.
14:16:26 <Eduard_Munteanu> You also need a different definition for Category too, though.
14:16:43 * latro`a boggles at this being as complicated as it is
14:16:44 <Eduard_Munteanu> :t Control.Category..
14:16:45 <lambdabot> parse error on input `Control.Category..'
14:16:50 <Eduard_Munteanu> :t (Control.Category..)
14:16:52 <lambdabot> forall (cat :: * -> * -> *) b c a. (Control.Category.Category cat) => cat b c -> cat a b -> cat a c
14:17:02 <ski> (i'd place `f' as the last argument of `Functor', so that you can say `deriving Functor Foo Bar')
14:17:59 <ski> lambdabot : if you just want to write you function, you could define it on its own, or define another class for it -- however it appears having it be a functor is more complicated
14:18:03 <ski> latro`a ^
14:18:15 <latro`a> yeah, I can see that
14:18:28 <latro`a> this was mostly just on a whim, though; I just wrote down eitherToMaybe after realizing I wasn't using a Left
14:18:40 <latro`a> and thought "oh hey that's a functor isn't it"
14:18:44 <latro`a> then this happened
14:19:49 <latro`a> I do see that there is a problem with trying to allow the first argument to Either to vary, though
14:19:49 <ski> defining `class Functorish f g where blah :: (f a -> f b) -> (g a -> g b)' would be fine, i think
14:20:01 <ski> maybe `NaturalTransformationish' would be a better name, not sure
14:20:20 <latro`a> right; that doesn't actually allow for (Either a b -> Either c d) -> (Maybe b -> Maybe d), though
14:20:29 <latro`a> it gives (Either a b -> Either a c) -> (Maybe b -> Maybe c)
14:20:36 <latro`a> which is pretty good, admittedly
14:20:38 <ski> latro`a : anyway, you should probably also try to formulate what laws you want the operation to satisfy, and then check them for your instances
14:21:07 --- mode: ChanServ set +o mauke
14:21:07 --- mode: mauke set -b *!*@99.198.101.10
14:21:23 <ski> e.g. i assume you want `blah id = id' and `blah (g . f) = blah g . blah f'
14:21:28 <latro`a> right
14:22:11 <ski> hm, this reminds me of someone else who defined something like `class ReverseFunctor f where revfmap :: (f a -> f b) -> (a -> b)'
14:22:26 <ski> (and i suggested some laws for it)
14:23:07 --- mode: mauke set -o mauke
14:23:15 <coderarity> haskell has classes?
14:23:27 <ski> it has *type* classes
14:23:28 <coderarity> i was almost hoping it didn't
14:23:28 <stepcut> coderarity: yes, but not like OO language classes
14:23:29 <MostAwesomeDude> Type classes. They are *not* object-oriented classes.
14:23:40 <coderarity> oh akay
14:23:45 <coderarity> okay*
14:24:07 <Peaker> I really really want a warning: "Type is not generalized" unless something is used to indicate I want the specialized type
14:24:31 <latro`a> huh...this might actually just not work
14:24:47 <mikeplus64> Peaker: or a warning: "type may be too generalized for optimization" ;)
14:25:12 <latro`a> the value-function is there, but how does one lift a function that always returns the Left type
14:25:52 <ski> have it return `Nothing' ?
14:26:26 <startling> coderarity, they're a lot nicer than OO classes. they're a bit like interfaces
14:26:34 <latro`a> oh, oh, duh, nvm, it's just simpler than I was making it
14:26:36 <ski> however, if your input is `Nothing', then you need to conjure up an `e' so that you can pass `Left e' to the argument function, iiuc
14:26:45 <latro`a> no
14:26:49 <latro`a> then you can just return Nothing
14:27:01 <latro`a> similar to Maybe's usual fmap
14:27:08 <ski>   blah :: (Either e a -> Either e b) -> (Maybe a -> Maybe b)  -- no ?
14:27:12 <latro`a> yeah
14:27:15 <latro`a> er
14:27:16 <latro`a> well
14:27:16 <ski> oh, right
14:27:19 <latro`a> I'm not sure if the e can be fixed
14:27:25 <ski> just skip calling the function in that case :)
14:27:26 <latro`a> without making this somewhat useless
14:27:29 <latro`a> but yeah, exactly
14:28:01 <latro`a> yeah here we go
14:28:07 <latro`a> eitherFunToMaybeFun :: (Either a b -> Either c d) -> Maybe b -> Maybe d
14:28:07 <latro`a> eitherFunToMaybeFun _ Nothing = Nothing
14:28:07 <latro`a> eitherFunToMaybeFun f (Just x) = f (Right x)
14:28:09 <Peaker> mikeplus64, it could be nice in "optimization mode"
14:28:13 <latro`a> (ugly long name, but whatever)
14:29:05 <ski>   eitherFunToMaybeFun f (Just x) = either (const Nothing) Just (f (Right x))  -- no ?
14:31:51 <latro`a> ...oh, hm
14:34:13 <ocharles> i'd use hush from 'errors'
14:34:34 <latro`a> yeah it's that
14:34:43 <latro`a> though this is beginning to resemble Maybe's >>=
14:34:51 <latro`a> with a separate case for Nothing and Just Nothing
14:35:12 <ocharles> :t join
14:35:13 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
14:35:31 <latro`a> ah, yeah, that's cleaner
14:35:41 <ocharles> hm
14:35:48 <latro`a> eitherFunToMaybeFun = theThingIWrote . join
14:35:58 <latro`a> ...wait
14:35:58 <latro`a> no
14:36:22 <latro`a> doesn't do the right thing with Just b's
14:36:32 <ocharles> you want something like eitherFunToMaybeFun f x = x >>= join . hush f . return
14:36:36 <ocharles> but that join is in the wrong place
14:36:39 <ocharles> i guess ski's is cleaner
14:37:05 <latro`a> oh wait
14:37:09 <latro`a> m >>= Just . Right
14:37:10 <ocharles> oh wait, x >>= hush f . return
14:37:16 <latro`a> er
14:37:19 <latro`a> with an f, ofc
14:37:25 <latro`a> m >>= Just . Right . f
14:37:29 <latro`a> ehm...
14:37:33 <latro`a> Just . f . Right
14:37:34 <latro`a> finally
14:37:44 <ocharles> no
14:37:56 <latro`a> ah no, not that either, gah
14:37:57 <ocharles> that will give you an Maybe (Either e a)
14:38:00 <latro`a> yeah
14:38:01 <ocharles> hence the call to 'hush'
14:38:07 <ocharles> @hoogle hush
14:38:07 <lambdabot> No results found
14:38:07 <latro`a> just realized the thing I wrote wasn't quite right
14:38:10 <ocharles> ffffuu
14:38:14 <latro`a> yeah I have never seen hush
14:38:17 <ocharles> hush :: Either e a -> Maybe a
14:38:21 <ocharles> it's in the 'errors' library
14:38:33 * ocharles has become a big fan of it
14:38:35 <latro`a> that is the eitherToMaybe I wrote earlier, I assume
14:38:48 <ocharles> yes probably, a lot of people end up re-inventing it
14:38:50 <latro`a> Left _ -> Nothing; Right x -> Just x
14:39:11 <latro`a> neat name, at least for Either String
14:39:14 <latro`a> sorta weird for anything else
14:39:14 <ocharles> yes, that's hush
14:39:20 <ocharles> there is also 'note' for going Maybe -> Either
14:41:18 <ocharles> x >>= hush . f . return, even. heh
14:41:39 <latro`a> uh
14:41:44 <latro`a> doesn't that use Either's return?
14:41:57 <ocharles> yes, that's what you want
14:42:09 <ocharles> you want to get into either, pass either into f, and then hush that down to maybe
14:42:12 <latro`a> yeah
14:44:43 <latro`a> heh
14:44:56 <latro`a> "hushmap"
14:47:38 <HairyDude> weird. whenever I run "cabal haddock", I get "parse error on input `import'"
14:51:51 <startling> is there a way to do multiline string literals in ghci?
14:52:09 <dzhus> HairyDude: note that haddock recently broke its (previously accidental) support for unicode characters, perhaps that's the issue
14:52:26 <HairyDude> dzhus: there's no unicode in it, though there is CPP
14:53:51 <HairyDude> dzhus: when I say "no unicode" of course I mean "no non-ASCII"
14:54:04 <fryguybob> startling: It may not be quite what you want, but: http://www.haskell.org/pipermail/haskell-cafe/2006-January/013911.html
14:54:25 <HairyDude> startling: you could try shakespeare-text
15:00:18 <yairchu> ghci -XTemplateHaskell -XQuasiQuotes; import Text.Shakespeare.Text; %{; [stext|; Hello; World!; |]; :}
15:02:04 <startling> hm
15:02:28 <startling> yeah, I cand eal with unlines whatever for now, but it's weird that there's not a language-level construct for this
15:02:41 <startling> what's the difference between Int and Integer? I forget
15:03:21 <JoeyA> Integer is arbitrary-sized integers.
15:03:28 <geekosaur> Int is a machine word, Integer is indefinite precision
15:03:33 <JoeyA> While Int is smaller, usually 32-bit or 64-bit.
15:03:41 <startling> oh, understood
15:03:43 <startling> thanks!
15:03:43 <nand`> it's at least 30 bit or so
15:03:49 <MostAwesomeDude> ^^
15:05:53 <JoeyA> Fun fact: OCaml uses 31/63-bit wide integers.  I think the other bit is reserved for the garbage collector.
15:06:27 <BMeph_> ^^ By Decree of the Executive Committee. :-)
15:06:49 <JoeyA> I think that's the same the reason the Haskell standard says 30 bit instead of 32 bit, so Haskell implementations have the option of doing the same.
15:06:52 <JoeyA> [citation needed]
15:07:21 <henux> haskell < erlang? Discuss.
15:07:23 <MostAwesomeDude> Probably. I mean, this is why X11 has 29-bit ints; the other bits were used by Lisps.
15:07:52 <MostAwesomeDude> henux: Mangoes < passionfruit? Discuss.
15:08:05 <startling> how do you all feel about erlang? I've been meaning to try it
15:08:13 <MostAwesomeDude> It's nifty.
15:08:14 <henux> im pretty OK with it
15:11:13 <startling> interesting
15:11:32 <Lutin`> So I've been toying around with a lot of command line haskell and I want to start getting some graphical outputs. What's the easiest way to get pixel data output to the screen
15:12:22 <BMeph_> Butterflies. :-)
15:12:28 <hape01> @type fixf (+1)
15:12:30 <lambdabot> Not in scope: `fixf'
15:13:16 <hape01> @type fix (+1)
15:13:17 <lambdabot> forall a. (Num a) => a
15:13:25 <Lutin`> Cairo kind of looks like the direction I want to go
15:14:15 <hape01> > fix (+2) 5
15:14:17 <lambdabot>   *Exception: stack overflow
15:14:31 <monochrom> 30-bit gives you the option to use 1 bit for "is this a thunk", 1 bit for GC bookkeeping
15:14:41 <hape01> @where fix
15:14:42 <lambdabot> I know nothing about fix.
15:15:13 <Philippa> posing "snappy" discuss questions < actually talking? Don't bother discussing.
15:15:31 <Philippa> I keep meaning to look into OTP (the library/framework that comes with Erlang)
15:15:33 <monochrom> but GHC decides to use 32 bits for constructor and "is this a thunk" and GC bookkeeping and... :)
15:15:58 <Philippa> Lutin`: I hear Cairo + the gtk2hs bindings works nicely, yeah
15:16:17 <MostAwesomeDude> @src fix
15:16:17 <lambdabot> fix f = let x = f x in x
15:16:21 <MostAwesomeDude> hape01: ^^
15:19:29 <Lutin`> also I'm kind of interested in viewing the compiled assembly of my code so I can see how it translates
15:19:34 <Lutin`> Is that possible?
15:20:14 <startling> k, quickcheck is a little to weird for me at the moment and I'm feeling the pain of not having unit tests. any recommendations for a normal-ish unit testing library?
15:20:20 <startling> *too
15:20:35 <ion> QuickCheck.
15:21:04 <ion> (Seriously, it’s not that weird.)
15:21:58 <monochrom> "ghc -ddump-asm" outputs assembly code, but not to a file
15:22:20 <Lutin`> I'm trying to figure if I can get it to output to a Leksah pane
15:23:06 <monochrom> "ghc -S" outputs to *.s file
15:23:42 <startling> meh
15:23:59 <JoeyA> You can also do ghc --ddump-core to dump the intermediate representation.
15:24:12 <Lutin`> Hehe
15:24:12 <JoeyA> (I think that's the right switch)
15:24:20 <Lutin`> Awesome, I'll check up on that
15:24:39 <startling> so I have a parser that I want to test. should I write Gens for my concrete syntax tree, write a function that turns them into code, and then check that it gets turned into the same concrete syntax tree?
15:24:57 <monochrom> -ddump-simpl
15:24:59 <startling> that seems like there's a lot of points of possible failure, there
15:25:07 <Lutin`> Eh?
15:25:20 <Lutin`> Just use the Either monad
15:26:18 <JoeyA> startling: Doing that won't cover ambiguity and error handling, will it?
15:26:41 <JoeyA> E.g. if your output function produces (a + b) + c, but a + b + c is also valid, that case won't get tested.
15:26:42 <startling> JoeyA: correct
15:27:04 <Lutin`> I need to remove the word 'just' from my vocabulary
15:27:07 <JoeyA> startling: Might be a good way to test your output function, though.
15:27:17 <ion> startling: For the few things QuickCheck is not appropriate for i use HUnit. But a few things like that existing is not a reason to throw away QuickCheck altogether.
15:27:36 <JoeyA> E.g. to make sure you don't generate "a + b + c" for "a + (b + c)", where + is supposed to be left associative.
15:27:56 <startling> makes sense
15:28:00 <Lutin`> monochrom: "The previously-undocumented flag -ddump-to-file causes the output from the other -ddump-* flags to be put in appropriately-named files, rather than printed on stdout. "
15:28:11 <JoeyA> (there are multiple JavaScript code generation libraries on Hackage that do that...)
15:28:11 <monochrom> nice
15:28:24 <startling> having Arbitrary instances for everything could be cool though, regardless
15:28:41 <startling> JoeyA: hehe
15:31:16 * hackagebot thumbnail 0.6 - generate thumbnail image (KatsutoshiItoh)
15:33:00 <ion> startling: test-framework will nicely run both QuickCheck properties and HUnit test cases.
15:33:48 <startling> ion: was going to be my next question. thanks!
15:33:52 <jhance> Using Data.Map.fromList on a list that can be lazily generated and consumed is efficient and will never produce the whole list, correct?
15:35:14 <coppro> > Data.Map.fromList $ repeat 3
15:35:16 <lambdabot>   Not in scope: `Data.Map.fromList'
15:35:23 <c_wraith> jhance: in some sense..  but it's only a constant-factor improvement. Data.Map is spine-strict
15:35:48 <startling> I don't see how it could be
15:36:08 <startling> since fromList [("a", 12), ("a", 13)] would want the second "a", right?
15:36:43 <jhance> startling: Oh, you are right I suppose. Okay, then I need to avoid the intermediate list... Darn, I was hoping to get by without explicit recursion
15:37:18 <jhance> My issue is that I have a Vector (k, v) as input and need to get a Map k v as output
15:37:31 <jhance> I guess I should just do a fold then.
15:38:06 <startling> would be cool if there were a standard typeclass for lookup-able things
15:38:36 <startling> lookup :: k -> whatever k v -> Maybe v
15:38:44 <jhance> startling: It would require constraint kinds
15:39:13 <startling> jhance, oh, I see
15:40:25 <ion> jhance: Look at the source. It seems to do essentially foldl' (… insert …) empty xs
15:40:28 <noteventime> jhance: Aren't constraint kinds in GHC now though?
15:40:56 <ion> jhance: I.e. it seems to iterate over the items in the list one by one.
15:41:17 * hackagebot free-functors 0.1 - Provides free functors that are adjoint to functors that forget class constraints. (SjoerdVisscher)
15:41:38 <jhance> noteventime: Yes, but it would limit everyone to either GHC 7.4 or 7.2 (can't remember which). Its probably a bit too early to do that...
15:42:37 <geekosaur> I thinkit limits you to HEAD due to bugs in the released one
15:42:59 <noteventime> To include it in any haskell-platform library sure, but no reason not to have a class like that yourself, or make it a package (with some standard instances)
15:43:17 <jhance> I'm a monad too so this gets even more hard to reason about... I guess I should probably just use Foldable (foldlM) or something to generate it?
15:44:05 <ion> What’s the implementation of join :: Jhance (Jhance a) -> Jhance a?
15:45:16 <jhance> ion: Its actually the Parser monad so I could probably escape it if I want to in order to parse the inner part but I don't want to... Let me look up the definition of join
15:45:32 <jhance> By Parser I mean Aeson Parser
15:46:00 <jhance> It doesn't explicitly define join (Are you even allowed to?)
15:46:44 <avpx> jhance: The definition of join should follow from >>=
15:47:08 <noteventime> Is join even part of the monad type class?
15:47:08 <ion> jhance: You said you are a monad. I was curious about how your personal monad instance works.
15:47:22 <jhance> ion: Its not personal. Its Data.Aeson.Parser
15:47:41 <ski> noteventime : it's not, but it might as well be
15:47:47 <jhance> noteventime: I don't believe so, I think >>, >>=, return, and (ugh) fail are only 4
15:48:09 <noteventime> That's what I seem to remember too
15:48:29 <noteventime> and ghci confirms it :)
15:48:29 <ski> (iow, sometimes it would be nicer to define `join' for a monad, and then define `(>>=)' in terms of it)
15:48:37 <avpx> For Haskell Monads, fmap / join are implemented in terms of >>=, not the other way around. But they're obviously equivalent definitions and it can help to see a Monad in terms of fmap / join.
15:49:02 <ski> avpx : `fmap',`join' and *`return'* :)
15:49:03 <noteventime> avpx: What do you men fmap is implemented in terms of >>=?
15:49:09 <startling> is there a way to create a list of all possibilities from an enum type?
15:49:29 <avpx> noteventime: Well... It's really a part of Functor, but there's a bug in the definition of the types that makes Monads not all Functors...
15:49:32 <ski> noteventime : `liftM f act = do val <- act; return (f val)'
15:49:39 <noteventime> startling: I don't think they have to be finite
15:49:54 <ion> startling: Is it Bounded? [minBound..]
15:50:04 <ski> noteventime : you can define `instance Monad Foo where ...' and then `instance Functor Foo where fmap = liftM'
15:50:12 <noteventime> ski: I know you can define it in terms of >>=, and that you have to give a semantically equivalent version of liftM
15:50:33 <noteventime> But fmap is still part of the type class, which isn't the case of join, no?
15:50:39 <ski> yes
15:50:42 <avpx> fmap is part of the Functor type class.
15:50:58 <noteventime> Sure, part by transitivity then :P
15:51:10 <avpx> @info Monad
15:51:10 <lambdabot> Monad
15:51:17 <noteventime> Great information
15:51:17 <ski> unfortunately, it's possible to have a `Monad Foo' instance without also having a `Functor Foo' instance
15:51:17 <avpx> Err, how can you do :i with lambdabot?
15:51:29 <ski> avpx : sorry, no
15:51:29 <avpx> ^^ yeah, that's what I was referring to
15:51:32 <startling> noteventime: well, they can be infinite, just not uncountably infinite, right?
15:51:50 <ski> @info liftM f act = do val <- act; return (f val)
15:51:51 <lambdabot> liftM f act = act >>= \ val -> return (f val)
15:51:54 <ski> @undo liftM f act = do val <- act; return (f val)
15:51:54 <lambdabot> liftM f act = act >>= \ val -> return (f val)
15:52:06 <ski> `info' gets spell-corrected to `undo'
15:52:15 <startling> ion, huh, interesting
15:52:16 <avpx> Durr.
15:52:44 <noteventime> Starfire: Sure, but then it's just a matter of using any enumeration of the integers
15:53:44 <noteventime> I didn't realise there wasn't a functor constraint on monad (I knew the applicative constraint was missing)
15:54:57 <avpx> Yeah :-\
15:55:01 <jhance> noteventime: Yeah, Monad is a pretty messed up ancient typeclass
15:58:36 <Lutin`> Isn't there a project to rewrite prelude?
15:58:51 <noteventime> Aren't there at least 10? :P
15:59:00 <c_wraith> many more than 10
15:59:06 <Lutin`> True
16:00:00 <noteventime> I've seen at least two just for a sane collection of algebra type classes to replace Num/Fractional/Floating
16:00:50 <startling> is (liftM2 someFn) a b the best way to do that, or is there some better, more idiomatic way?
16:01:12 <noteventime> Starfire: You can do someFn <$> a <*> b
16:01:29 <startling> oh, that's true
16:01:35 <startling> nice
16:01:36 <avpx> noteventime: Yeah, well, having floating types implement Num is pretty bad.
16:01:53 <avpx> I'd like my Nums to be rings, please :p
16:02:06 <noteventime> startling: or fmap a `ap` b if you don't have an applicative instance and can't be bothered to write one
16:03:47 <noteventime> avpx: Has anyone come up with a good solution for (not sure about the terminology here) assymetric binary operators? (scalar multiplication, algebra actions, tensorings e.t.c.)
16:03:50 <startling> noteventime, yeah. fortunately I do. :)
16:04:10 <noteventime> At least scalar multiplication should be common enough to warrant a standard notation
16:05:30 <noteventime> I've seen <*>, *^ and *.
16:05:55 <noteventime> The first one is taken by applicative though, and I find the others look too much like OCaml :P
16:07:50 <jhance> I wouldn't mind :*: but I think its taken by generics
16:08:38 <jhance> Not nearly as bad as colliding with applicative, though
16:08:55 <noteventime> :*: doesn't look too bad
16:09:10 <avpx> noteventime: I'm not sure, I could look into it later, but I haven't seen anything like that in the wild.
16:09:15 <avpx> Then again, I haven't really looked.
16:09:29 <jhance> I haven't either. That would just be my suggestion on what to use
16:09:37 <davorak> monochrom: The example you gave me of dependency hell was X depends on (y depends on p == 1.0) (z depends on p==2.0). Is it enough to just import both y and z into ghci to show you have overcome dependency hell?  I have vector-static-0.3.0.1 (dpending on vector 0.5.*) and snap-0.9.1.1: (depending on vector (≥0.7.1 & <0.10)) both imported into ghci. Or is there something more I should check?
16:10:01 <noteventime> avpx: Don't worry, I was just curious
16:12:11 -StaffAlert(~MsgServ@199.68.198.115)- Offical Freenode Memo - Snardbafulator has been reported missing since yesterday, and the FBI has opened an investigation related to the barage of cyberbullying that has been taking place over the last two weeks. His manner of speaking in channels may be different that what you are used to, but Freenode staff asks that you act like everything is normal so that the FBI investigation is not impeded. : Christel - Freenode Staff
16:12:36 <parcs`> is that spam or what?
16:12:42 <mauke> ...
16:12:53 <jfischoff> what do they mean by "different"?
16:13:07 <kloeri> of course it's spam
16:13:14 <mauke> please don't comment on spam in here
16:13:52 --- mode: ChanServ set +o mauke
16:13:53 --- mode: mauke set +b $a:StaffAlert
16:13:59 <Raynos> o/
16:15:52 --- mode: mauke set -o mauke
16:21:34 <jhance> Is it currently possible to actually obtain bytestring-0.10? Or is this going to be part of 7.6?
16:27:08 * upgrayeddd acts like everything is normal
16:30:19 <davorak> So earlier I was giving an example of  dependency hell.  X depends on (y depends on p == 1.0) (z depends on p==2.0). Is it enough to just import both y and z into ghci to show you have overcome dependency hell?  I have vector-static-0.3.0.1 (dpending on vector 0.5.*) and snap-0.9.1.1: (depending on vector (≥0.7.1 & <0.10)) both imported into ghci. Or is there something more I should check?
16:31:03 <davorak> They imported and have conflicting dependencies what else should I check to see if they are wroking?
16:34:23 <jhance> I wish the Aeson errors would be a bit more descriptive... All it tells me is that it got an object when expecting text...
16:36:13 <startling> is there some tool that can type-annotate all of my functions?
16:36:42 <m3ga> startling: compile with -Wall and ghc will tell you the type sigs
16:36:47 <Saizan> davorak: even if they both imported doesn't mean that a program using both would build, because if they expose types from vector in their APIs they will be different types
16:36:53 <startling> I mean, take a file of source code and output source code with type annotations
16:37:31 <m3ga> Starfire: sorry, i don't know of such a tool.
16:37:53 <Saizan> davorak: cabal not having a better way to check if this is relevent or not atm, won't construct an install plan with those two packages
16:37:58 <m3ga> would be useful though
16:38:06 <davorak> Saizan: Sure, but any solution for dependency hell would suffer from that right? You can not expose conflicting types.
16:38:08 <Saizan> davorak: however you can still try with cabal configure
16:38:38 <davorak> Saizan: I Have a script which has them both installed and both imported into ghci
16:38:54 <Saizan> davorak: importing in ghci doesn't prove anything
16:39:13 <Saizan> only that they are currently installed
16:39:34 <davorak> Saizan: Ok, I was not sure but doubted it would.  I am looking for a test that is stronger then importing into ghci.
16:40:07 <davorak> Saizan: I can compile a module that imports both of them would that do the trick?
16:40:18 <Saizan> well, i guess it also shows they won't get automatically shadowed, but that's another matter
16:40:29 <davorak> Saizan: Try to that is. I have not done this.
16:40:49 <monochrom> hmm, interesting question
16:41:01 <jhance> How in the world is haskell going to be able to distinguish between which two versions of vector you want
16:41:06 <jhance> if you expose them both
16:41:12 <startling> is there some template haskell tool that can make my data types all instances of Arbitrary by doing arbitrary for each argument?
16:41:19 * hackagebot z3 0.1.1 - Bindings for the Z3 Theorem Prover (IagoAbal)
16:41:23 <monochrom> I think I did it before. ghci will load everything fine. and also know the difference perfectly
16:41:35 <jhance> startling: Use Generics?
16:41:46 <Saizan> davorak: it depends on what you mean by them working i guess?
16:42:20 <monochrom> the logical conclusion of "know the difference perfectly" then depends on module details
16:43:40 <jhance> startling: Generics-based default instances is cleaner than TH because at the end to define instances you just type "instance ClassName TypeName" like a normal instance (except without a where or body). You might even be able to use deriving (..) but I'm not sure on this one
16:44:16 <monochrom> Y uses P-1.0. Z uses P-2.0. if "use" means internal use only, there is no problem. if "use" means P stuff is re-exported and you start passing P stuff between Y and Z, it's a type error
16:44:42 <Saizan> davorak: i guess in this case, where rebuilding these versions against different deps wouldn't help because of constraints, one can only hope for "manually" building a program that depends on both succeeding, though that also depends on how this program uses their API
16:44:43 <startling> jhance, wouldn't that require QuickCheck implementing that, though?
16:44:46 <monochrom> "type mismatch: P.Type does not match P.Type from P-1.0"
16:45:22 <jhance> startling: Hmm, possibly... I can't remember on the syntax. But there does seem to be something like it available: http://hackage.haskell.org/packages/archive/regular-extras/0.2.2/doc/html/Generics-Regular-Functions-Arbitrary.html
16:45:36 <monochrom> cabal-install plays safe by saying "no no no, only one version of P is allowed" before even trying
16:45:51 <jhance> startling: Looks like it uses ane xternal generics library rather than ghc-generics though
16:46:19 <davorak> Saizan: I am tring to test my build script to see if it solves dependancy hell in general.
16:46:23 <Saizan> it plays safe in the hope that it can circumvent the problem entirely by picking other versions
16:47:06 <m3ga> startling: i've used the derive package to generate Arbitrary instances. only works for non-recursive types.
16:47:10 <davorak> monochrom: Right and I am tring to test if I have actually gotten around that cabal-install restriction.
16:47:46 <startling> m3ga: well that's no good. :(
16:47:46 <jhance> startling: What you can do is define class GArbitrary and implement defaulting for that and then make a data GArbitraryWrapper a = GArbitraryWrapper a and define instance GArbitrary a => Arbitrary (GArbitraryWrapper a) and then go through some wrappers that way
16:47:59 <davorak> monochrom: In the general case
16:48:05 <Saizan> davorak: getting around that restriction is just a matter of "luck", i.e. either the programs are written such that they work anyway or they don't
16:48:23 <m3ga> startling: yeah, its a pity
16:48:32 <monochrom> hrm, "luck"
16:48:35 <jhance> startling: If you want to be "evil" you could even do GArbitrary a => Arbitrary a and then you can avoid wrappers entirely. But you'd need OverloadedInstances I think.
16:48:44 <davorak> Saizan: I have a script doing it automaticlly I think I have removed that matter of luck.
16:48:51 <startling> meh
16:48:58 <Saizan> davorak: your script changes the source code?
16:48:58 <startling> I'll just write it all by hand I guess
16:49:04 <davorak> Saizan: five me another conflicting case for ghc 7.4.1 and I will try to install it.
16:49:09 <monochrom> I now agree it's "luck" or probability after listening to my thesis advisor's view on probability :)
16:50:03 <monochrom> as in, since it depends on situation details, but we are not specifying them now, we start assigning probabilities
16:50:04 <davorak> Saizan: There is some automatic rewriting involved.  I am actually leveraging a considerable amount of prewriten code by  reusing the nix package manager.
16:51:10 <Saizan> i guess what you can do is try to stick to the restriction as much as possible, and just hoping it works for the rest of cases?
16:51:42 <davorak> Saizan: I can install and use libraries that I could never have used with cabal-install alone, I would have had to resort to cabal-dev or a sandboxing method of some sort.
16:52:06 <startling> ugh, why aren't there simple String -> ByteString functions anywhere?
16:52:20 <davorak> Saizan: Could you unpack the meaning of "stick to the restriction as much as possible?"
16:52:23 <jhance> startling: Because you shouldn't do String -> ByteString. And there are. Data.ByteString.Char8
16:52:24 <monochrom> because does not exist
16:52:48 <monochrom> who thinks that unicode -> bytes is "simple"? put up your hands
16:52:48 <jhance> startling: In particular Data.ByteString.Char8.pack or Data.ByteString.Lazy.Char8.pack
16:52:49 <startling> jhance, why not? because it's inefficient? well, yeah
16:53:23 <Saizan> davorak: by picking versions of dependencies that match it when there's a choice available
16:53:28 <jhance> startling: Because [Char] corresponds more to Text than to ByteString
16:54:30 <davorak> Saizan: I still do not understand what you are suggesting. I choose the packages above because they have conflicting dependencies and cabal-install would have failed to install them.
16:54:32 <jhance> startling: If you want UTF8-Bytestrings you can also use utf8-string's Data.ByteString.UTF8.fromString
16:54:44 <Saizan> monochrom: yeah, that was the sense of "luck" i meant :)
16:54:59 <monochrom> well, even startling himself is not putting up his hand. so much for "simple" unicode -> bytes
16:55:10 <startling> edwardk, any particular reason ident someIdentifierStyle outputs a bytestring?
16:55:19 <Saizan> davorak: are you sure?
16:55:29 <edwardk> startling: history? =)
16:55:42 <davorak> Saizan: yeah I will paste them here again one moment
16:55:51 <edwardk> is this in parsers or trifecta?
16:55:57 <startling> trifecta
16:56:04 <Saizan> davorak: if you install them separately cabal doesn't necessarily have a problem with packages dependening on conflicting versions
16:56:08 <edwardk> trifecta can do so with sharing against the source rope
16:56:17 <Saizan> davorak: the problem is when you try to use them together to use something else
16:56:25 <edwardk> normally a parser has to allocate a bunch of memory for all those identifiers
16:56:26 <Saizan> davorak: *to build something else
16:56:34 <edwardk> done this way you can get a lot of extra sharing in memory
16:56:43 <startling> edwardk, doesn't the source type depend on what kind of MonadParser it is, though?
16:56:52 <startling> or do they all turn things into ropes?
16:57:13 <edwardk> right now they all do, but the sharing advantage is definitely parser specific
16:57:23 <edwardk> trifecta was very bytestring focused
16:57:28 <edwardk> its becoming less so
16:57:33 <startling> got it
16:57:33 <edwardk> now that slicing is going away
16:58:01 <edwardk> but it was possible to use slice p to take a parser p and run it, and return the bytestring for the interval it parsed
16:58:04 <Saizan> a guess one could ask why not Text
16:58:18 <startling> edwardk: thanks for your time!
16:58:21 <davorak> Saizan: I have vector-static-0.3.0.1 (dpending on vector 0.5.*) and snap-0.9.1.1: (depending on vector (≥0.7.1 & <0.10)).  So if I build a module with these two packages and the code called from each works, would that be considered a strong test case?
16:58:43 <monochrom> does vector-static cling on vector? :)
16:59:05 <Saizan> davorak: it's not something i couldn't do with cabal-install, i think
17:00:57 <Saizan> i.e. "cabal install vector-static-0.3.0.1 && cabal install snap-0.9.1.1 && ghc --make someprogramusingbothwithoutmixingvectortypes.hs"
17:02:13 <davorak> Saizan: Thands.  Well I was going to test, install one, install the other, compile, with ghc, a program that uses both.
17:02:52 <mmos> for debugging, I'm writing a file inside a call to unsafePerformIO. It doesn't seem to finish writing the file.(on windows 7)  I can't open it until I exit my application and then it is blank, unexpectedly blank
17:02:56 <Saizan> there might be particular reasons why those cabal install fails on a particular installations, but not because cabal forces them both to use the same versions of vector, because it doesn't impose them on separate installations
17:03:00 <Saizan> *impose that
17:03:55 <Saizan> (mixing singular and plural too much, goodnight!)
17:04:21 <jhance> mmos: This probably has to do with the unsafePerformIO not being performed because of lazy evaluation? I mean... its not safe...
17:04:24 <davorak> Saizan: I am pretty sure I have both of my packages using different veersions of vector but still loading, but I need some test.
17:04:27 <davorak> good night
17:04:44 <monochrom> depends on actual code. like, did you close the file?
17:04:45 <geekosaur> mmos: if you're using lazy I/O in there then it's not likely to finish unless you're very careful
17:04:59 <Saizan> davorak: yeah, i'm saying that's not surprising
17:05:24 <donri> i'm trying to imagine what a dynamic pure functional language is like. are there any good examples?
17:05:26 <monochrom> hell, I should not even ask that second question. just bloody show actual code. not interested in playing "20 questions"
17:05:29 <mmos> I am sooo confused by methods of forcing evaluation. this is actually inside a computation that I use 'evaluate' to call so in thereory the whole thing should be strict. anyway what can I do that's practical.
17:05:37 <davorak> monochrom: you talking to me?
17:05:44 <monochrom> no, don't worry
17:05:45 <startling> mmos, why do you want to do that?
17:06:19 <monochrom> the original lambda calculus seems to be a dynamic pure functional language
17:06:34 <davorak> Saizan: Ok, if that is not surprising then I need a better test case for dependency hell.  Do you know where I can find one?
17:06:40 <monochrom> (fun fact: it gave Dana Scott et al. much headache :) )
17:06:44 <mmos> I'm using evaluate so that thrown exceptions are reached during the evaluation of data before the "action" starts (the stuff in the IO Monad)
17:07:13 <Saizan> davorak: maybe you should try defining "dependency hell" more rigorously
17:07:18 <mmos> "evaluate" is in, um.. Control.Exception?
17:07:30 <startling> hmm, Data.ByteString.UTF8.toString is failable, isn't it?
17:07:56 <monochrom> "evaluate" is in Control.Exception because its main purpose is to test for exceptions, not to evaluate
17:08:00 <startling> ah: Invalid characters are replaced with '\xFFFD'.
17:08:05 <Saizan> mmos: evaluate only forces enough to determine the outermost layer of the value
17:08:31 <mmos> Saizan: is that what "head normal order" means?
17:08:32 <Saizan> mmos: it seems in your case you need to add something to force deeper
17:08:59 <Saizan> mmos: weak head normal form, but yes
17:09:05 <monochrom> as with all things else in haskell, you do not reason by names. "class" is not class, "data" is not data, "type" is not type, and "evaluate" is not evaluate
17:10:02 <monochrom> "return" is not return
17:10:18 <mapreduce> do doesn't.
17:10:31 <mmos> I'm imaginging Luke in the trash compactor drowning inside the stragling snake. He calls out "shoot it!" Han Solo says "Where????" Luke says "ANYWHERE!!" I feel like that. Can I just evaluate all of it strcitly? EVERYWHERE says Luke
17:11:10 <davorak> Saizan: I thought I had one, if I add rigorous understanding I would not have to ask for test cases here. It would have provided evidence that I was on the right track and I could have continued to build and research with confidence I was not going done a blind ally.
17:11:40 <covi> dmwit: thanks buddy! I was just experimenting with sequenceA and applicatives.
17:11:46 <monochrom> use ocaml to evaluate all of it strictly
17:13:31 <mmos> if I write each function so it evaluates itself stricitly, then would the depth of evaluation be deeper -- as compared to putting "evaluate" in front of a single hierarchy of function calls?
17:14:03 <latro`a> ...what the
17:14:07 <latro`a> @type m >>= f . return
17:14:09 <lambdabot>     Couldn't match expected type `m a' against inferred type `Expr'
17:14:09 <lambdabot>     In the first argument of `(>>=)', namely `m'
17:14:09 <lambdabot>     In the expression: m >>= f . return
17:14:11 <latro`a> ^what
17:14:13 <monochrom> have you tried Debug.Trace?
17:14:39 <monochrom> I'm thinking operator precedence
17:15:08 <monochrom> @type f
17:15:09 <lambdabot> forall a. (SimpleReflect.FromExpr a) => a
17:15:21 <monochrom> that's why. f is special in lambdabot
17:15:29 <mmos> monochrom: yes I've tried debug trace.. it helps.. in this case I want to produce a fairly large amount of debugging data in the form of a structured table. I could also write my large table to stdout and redirect stdout to a file.
17:15:54 <latro`a> oh
17:16:08 <monochrom> Debug.Trace uses unsafePerformIO, so unsafePerformIO works, or can work
17:16:08 <latro`a> um
17:16:14 <latro`a> is g also special?
17:16:18 <latro`a> I get the same problem with g
17:16:21 <monochrom> yes
17:16:23 <monochrom> @type g
17:16:24 <lambdabot> forall a. (SimpleReflect.FromExpr a) => a
17:16:24 <latro`a> -_-
17:16:33 <monochrom> I think most of the single letters are special
17:16:37 <latro`a> bah
17:16:42 <c_wraith> I think they all are, in lambdabot
17:16:48 <c_wraith> > q - r
17:16:49 <lambdabot>   q - r
17:16:51 <mmos> with debug.trace sometimes you get messages chopped and rearranged and of coure they aren't necessarily in order. That's the challenge.
17:16:59 <latro`a> oh wait derp I needed a lambda
17:17:33 <c_wraith> mmos: actually, they *are* in order. The problem is that you don't understand how many different valid evaluation orders there are for haskell code
17:17:52 <monochrom> not convinced that the "wrong" order is specific to Debug.Trace
17:18:27 <monochrom> I say that all tracing methods are subject to the same phenomenon
17:19:28 <mmos> I think I understand that. they are in the order the expressions are evaluated which is not necessarily any particular order
17:19:44 <mmos> and hard or impossible to predict from a superficial inspection of the code
17:23:29 <monochrom> my http://hpaste.org/69067 surprises many people
17:23:40 <startling> what's the thing that interpolates a single x between each item of an [x] and then concats them?
17:23:55 <monochrom> but do enjoy my lovely title!
17:24:11 <liyang> startling: intercalate or intersperse?
17:24:11 <jhance> startling: interpolate
17:24:31 <jhance> startling: Nevermind, listen to liyang
17:24:52 <liyang> @t (intercalate, intersperse)
17:24:52 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
17:24:57 <liyang> @type (intercalate, intersperse)
17:24:58 <lambdabot> forall a a1. ([a] -> [[a]] -> [a], a1 -> [a1] -> [a1])
17:25:06 <startling> @where intercalate
17:25:06 <lambdabot> I know nothing about intercalate.
17:25:22 <startling> @where intersperse
17:25:22 <lambdabot> I know nothing about intersperse.
17:25:22 <enigmuriatic> when you want to combine different types in a print expression, what do you use? I thought it was (++) but I guess not
17:25:31 <monochrom> > intercalate "->" ["a", "b", "c"]
17:25:32 <lambdabot>   "a->b->c"
17:25:34 <startling> @src intercalate
17:25:34 <lambdabot> intercalate xs xss = concat (intersperse xs xss)
17:25:41 <jhance> enigmuriatic: putStrLn $ show x ++ show y
17:25:43 <startling> where is it defined?
17:25:50 <monochrom> Data.List
17:25:54 <startling> ah
17:26:00 <mmos> in ghci, how do I evaluate a function and send stdout to a file?
17:26:31 <startling> mmos: does it have to stdout?
17:26:35 <startling> can it just be output?
17:26:47 <startling> do you have an IO () or a something -> String, i mean?
17:26:56 <mmos> well, whatever Deubg.Trace sendss output to.
17:27:03 <monochrom> that's stderr
17:27:20 <mmos> okay, on Windows 7, can I tell ghci to send stderr to a file?
17:27:24 <monochrom> not easy to redirect in ghci or ghc
17:27:48 <jhance> mmos: If Windows follows Unix convents (haha yeah right) 2>err should work
17:28:32 <mmos> the windows shell is pretty pathetic. they don't expect anyone to seriously try to use it.
17:29:02 <monochrom> http://hackage.haskell.org/package/system-posix-redirect may or may not help
17:29:22 <mapreduce> 2>err works fine on Windows.
17:29:31 <mapreduce> No idea about with ghci though.
17:30:05 <monochrom> oh, http://hackage.haskell.org/package/io-capture may help better
17:30:41 <mmos> does 2>err put the output in a file called 'err'?
17:30:55 <monochrom> oh God, I see what it's doing. horrible hack
17:31:31 <mmos> good lord, 2>err does work on Windows
17:32:14 <mmos> I got all the ghci messages about compilation too. kindof annoying. I guess they are sent to stderr.
17:32:38 <mmos> well for now I'll try sending my debug information as a structured table to a file via stderr
17:36:42 <startling> if I have an Either where both types are instances of Show, how do I have a function that shows either of them?
17:38:11 <gwern> now that I actually look at how to tag windows in arbtt, it seems ridiculously complex >.<
17:38:27 <gwern> but I have 49M of logs, so it's not like I have any choice about learning it
17:40:58 <gwern> (hah, stack overflow)
17:41:38 <mmos> oh.. as often happens, the reason the debug stuff wasn't doing what I wanted was an unexpected bug I created in the logic of the program proper.
18:04:15 <latro`a> bah, stupid argument order
18:04:19 <latro`a> I just wrote this
18:04:37 <hpaste> latro`a pasted “eitherM” at http://hpaste.org/72095
18:04:50 <latro`a> (I'm also expecting someone to point out that this already exists, but I did @src eitherM beforehand)
18:06:04 <Cale> latro`a: whenever you're using (.) and (>>=) at the same time, consider using (=<<) instead
18:06:10 <latro`a> anyway, yeah, I imagine everyone hates when you make a function, then specialize it and have to pass all the arguments
18:06:16 <latro`a> yeah that might be for the best
18:06:29 <latro`a> this example is fairly small, though
18:06:59 <Cale> (just because it'll keep the data flowing in the same direction)
18:07:03 <latro`a> right
18:07:22 <fragamus> I have a Data.Map and I want to serialize it to binary    Is there a way to do that
18:07:59 <Cale> fragamus: (Ord k, Serialize k, Serialize e) => Serialize (Map k e) -- in the cereal package
18:08:19 <Cale> http://hackage.haskell.org/package/cereal
18:08:41 <Cale> So you can apply encode to it and get a ByteString
18:09:42 <fragamus> Thanks Cale
18:13:39 <fragamus> Cale: I'm a little worried that it works only with strict ByteStrings
18:25:11 <startling> what's the easiest way for me to just get a random int?
18:25:16 <startling> I only need one
18:25:38 <ddarius> 63958538
18:25:47 <latro`a> does it need to change every time the program is run?
18:25:56 <startling> latro`a: yeah
18:26:15 <startling> of, fst (next wgetStdGen
18:26:31 <startling> errrr
18:26:33 <startling> wow typoes
18:26:37 <startling> anyway, figured it out
18:26:46 <latro`a> for just a single one you can just use randomIO :: IO Int
18:26:47 <monochrom> randomRIO (4, 10) gives a random number between 4 and 10 inclusive
18:27:02 <startling> latro`a: oh nice
18:27:30 <latro`a> (note randomIO is actually IO a, so you may need a signature depending on what you do afterwards)
18:27:45 <latro`a> (er, Random a => IO a
18:27:46 <latro`a> )
18:29:15 <startling> yeah, understood
18:29:21 <startling> I'm already in IO
18:36:34 <sinelaw> beep!
18:36:59 <sinelaw> so, does anyone here care about implementing wavelet transforms in haskell?
18:38:13 <sinelaw> I discovered that I have a repository on github with a tiny bit of code for that. i hardly remember writing it
18:39:06 <sinelaw> so, for anyone interested: https://github.com/sinelaw/wavelet
18:39:09 <sinelaw> get to work :)
18:43:33 <coderarity> so i'm really excited to use haskell as a language because so far it is very awesome, i'm just not sure what I can use it for
18:44:16 <sinelaw> whatever you want!
18:44:17 <coppro> everything
18:44:24 <coderarity> I mean, it's not really used for software applications, is it? I couldn't see something like GTK fitting on Haskell
18:45:09 <jmcarthur> @where gtk2hs
18:45:10 <lambdabot> http://haskell.org/gtk2hs/
18:45:15 <jmcarthur> tada!
18:45:45 <latro`a> though to be fair, idiomatic GUI stuff is sorta still in progress
18:46:21 <latro`a> http://www.haskell.org/haskellwiki/Applications_and_libraries/GUI_libraries
18:46:23 <coderarity> i want to make games with it tbh
18:46:38 <coderarity> this looks interesting
18:47:30 <sinelaw> coderarity, this one is overkill but still http://www.haskell.org/haskellwiki/Frag
18:47:37 <jmcarthur> coderarity: #haskell-game is a thing. kind of quiet most of the time, though
18:48:03 <coderarity> alright
18:48:07 <sinelaw> coderarity, for games you would probably use something like SDL http://www.haskell.org/haskellwiki/SDL
18:48:43 <latro`a> depends on the scale of the game really
18:49:18 <coderarity> wow
18:49:34 <coderarity> the Matrix.hs file is amazingly readable
18:49:47 <coderarity> that stuff is way harder in C++
18:49:51 <sinelaw> coderarity, for very nice 2d graphics functional code I recommend this: http://hackage.haskell.org/package/graphics-drawingcombinators
18:50:02 <sinelaw> nice code, not nice graphics :)
18:51:22 <jmcarthur> i look forward to the next lambdacube release. it's all gpipe-ish and stuff now, except more polished (i hope)
18:52:28 <dmwit> ?hackage diagrams is superior to graphics-drawingcombinators =)
18:52:28 <lambdabot> http://hackage.haskell.org/package/diagrams is superior to graphics-drawingcombinators =)
18:54:37 <coderarity> i was just gonna do bitmaps
18:57:23 <sinelaw> dmwit, can diagrams do animations?
18:57:40 <sinelaw> dmwit, i mean does it draw to something like a screen buffer?
18:57:49 <sinelaw> can it use OpenGL?
18:58:02 <dmwit> I am not sure whether it has an OpenGL backend.
18:58:20 <sinelaw> graphics-drawingcombinators does
18:58:38 <dmwit> http://www.haskell.org/haskellwiki/Diagrams/Projects#Backends claims not
18:58:49 <dmwit> Is it important to use OpenGL?
18:58:57 <dmwit> It can use cairo, which is also hardware-accelerated.
18:59:06 <sinelaw> dmwit, fine then
18:59:36 <sinelaw> from the site it looks more like a library for drawing...diagrams
18:59:38 <sinelaw> static ones
18:59:49 <dmwit> I'm not sure of the status of animations. I think there's rudimentary support in the repository.
18:59:58 <dmwit> But yes, it is for drawing static diagrams, mostly.
19:00:56 * ddarius considers applying a Wick rotation to g∇ = δ
19:01:08 * sinelaw segfaults
19:01:18 <sinelaw> _|_
19:01:30 <monochrom> wicked notation? :)
19:01:40 --- mode: ChanServ set +o mauke
19:01:41 --- mode: mauke set +b *!*@static.207.227.4.46.clients.your-server.de
19:01:46 --- kick: Xoloitzcuintles was kicked by mauke (Xoloitzcuintles)
19:03:15 <monochrom> my http://www.vex.net/~trebla/haskell/gtk-interact.xhtml has a GTK example
19:03:46 --- mode: mauke set -o mauke
19:05:27 --- mode: ChanServ set +o copumpkin
19:08:18 <coderarity> so i guess Haskell can interface with C code?
19:08:47 <Nereid> yes
19:08:51 <shachaf> GHC can.
19:08:59 <Nereid> using the FFI
19:09:02 <coderarity> maybe I could do the more imperative sides of game programming in javascript with v8
19:09:05 <shachaf> (And probably most other Haskell implementations.)
19:09:19 <shachaf> coderarity: You could also do it in Haskell. :-)
19:10:15 <coderarity> yeah, i suppose? i guess it doesn't matter too much
19:23:53 <tdwyx> test
19:24:02 <sinelaw> success
19:24:11 <tdwyx> thanks
19:24:38 <sinelaw> welcome
19:25:30 <ddarius> shachaf: The FFI is part of the standard.
19:25:48 <vodik> what is the best way to convert a BinaryString to a Word of possibly differing size? I'm trying to parse some input, i get a length field (typically 32 or 1) denoting the length of following number. I can split this string into multiple ByteStrings but i'm at a loss on how to turn it into a number
19:27:17 <startling> tdwyx, that's not very rigorous
19:30:31 <shachaf> ddarius: Oh, I didn't realize the FFI specified C in particular.
19:30:57 <shachaf> I guess it does require it.
19:35:31 <monochrom> FFI mentioned c, c++, jvm, dotnet. but only the c part is detailed and actually implemented
20:34:09 <coderarity> what does pure code mean?
20:34:55 <shachaf> I don't know. You're the one who's using the word.
20:35:26 <coderarity> from http://www.haskell.org/haskellwiki/How_to_write_a_Haskell_program#Testing: "You can use QuickCheck or SmallCheck to test pure code. To test impure code, use HUnit."
20:35:38 <latro`a> I'd say: 1. pure code performs no side effects--it doesn't change the outside world, or depend on the outside world, and 2. it always produces the same output given the same input
20:35:44 <latro`a> though 2 somewhat follows from 1
20:37:56 <chidy> I'm struggling to get threadscope working on OS X
20:38:08 <chidy> anyone
20:38:10 <shachaf> coderarity: They probably mean "code that doesn't use IO".
20:38:50 <chidy> has anyone managed to get it working? or offer some advice on how to go about it?
20:44:48 <mm_freak> coderarity: there are multiple definitions, but my personal one for haskell is that pure code doesn't introduce IO side effects
20:44:58 <mm_freak> in that sense even replicateM and mapM are pure
20:45:04 <mm_freak> for IO
20:45:27 <latro`a> the monadic functions when applied to IO seem a bit of a grey area to me
20:45:35 <latro`a> under that definition
20:46:06 <mm_freak> well, if you want to be pedantic, there isn't impure stuff in haskell, so the statement should be rewritten:
20:46:26 <mm_freak> use QuickCheck or SmallCheck to test expressions and HUnit to test side effects
20:46:43 <shachaf> Personal definitions are a great path to useless Internet arguments. :-)
20:46:46 <latro`a> indeed
20:46:49 <mm_freak> true
20:46:51 <shachaf> That's why I don't like words like "impure" and "functional".
20:47:11 <latro`a> saying what you mean works better, definitely
20:47:21 <mm_freak> an entirely unrelated note
20:47:34 <latro`a> saying "does your code use the IO monad?" instead of "is your code impure?" has advantages
20:47:39 <mm_freak> i'm writing a library where most functions require random numbers
20:48:14 <mm_freak> my current way of dealing with that (to avoid MonadRandom) is this:  (Monad m) => (forall a. (Random a) => m a) -> Stuff -> m OtherStuff
20:48:18 <mm_freak> what do you think?
20:48:18 --- mode: ChanServ set +o mauke
20:48:18 --- mode: mauke set +b *!*@162.105.248.71
20:48:29 --- kick: rainwomen was kicked by mauke (rainwomen)
20:48:52 <latro`a> still not much accustomed to higher rank stuff
20:49:30 <mm_freak> latro`a: it basically says that you need to pass a function that can deal with arbitrary Random types…  think of the function taking a hidden type argument
20:50:00 <mm_freak> so you can only pass polymorphic functions like 'randomIO', but you couldn't pass a function of type IO Double
20:50:04 <mm_freak> uhm, not a function actually
20:50:20 <latro`a> I know what higher rank stuff *says*, I have trouble understanding what it means in practice
20:50:29 --- mode: mauke set -o mauke
20:50:30 <latro`a> (haven't really figured out why ST is so magical, for example)
20:51:07 <mm_freak> latro`a: myFunc :: (Monad m) => (forall a. (Random a) => m a) -> m Stuff
20:51:18 <mm_freak> now myFunc can use the first argument polymorphically
20:51:25 <mm_freak> it can use it both as m Double and m Integer
20:51:45 <shachaf> It can double as m Double and m Integer!
20:51:51 <latro`a> at what stage, though?
20:52:00 <latro`a> also, can it do *more* or *less* with it
20:52:04 <latro`a> based on the value being forced to be polymorphic
20:52:09 <latro`a> I'm expecting less
20:52:15 <mm_freak> getTwoRandoms :: (forall a. (Random a) => IO a) -> IO (Int, Double)
20:52:26 <latro`a> huh
20:52:27 <mm_freak> getTwoRandoms getRandom = liftA2 (,) getRandom getRandom
20:52:29 <mm_freak> valid
20:52:35 <mm_freak> without forall invalid
20:52:41 <latro`a> right
20:53:08 <mm_freak> when there is quantification, the caller can do less and the callee can do more
20:53:16 <mm_freak> otherwise it's the other way around…  it's a matter of who chooses the type
20:53:43 <mm_freak> it's easier to understand, when you translate this to a language with explicit type arguments like agda
20:54:19 <mm_freak> wrongGetTwoRandoms : (A : Set) -> IO A -> IO (Int \times Integer)
20:54:34 <mm_freak> correctGetTwoRandoms : ((A : Set) -> IO A) -> IO (Int \times Integer)
20:55:35 <mm_freak> in the first case the caller passes the type argument, in the second case the callee passes it
20:56:10 <latro`a> not seeing how, sorry
20:56:24 <latro`a> I may not get my head around that for a long time :p
20:56:51 <mm_freak> wrongGetTwoRandoms A c = …
20:57:02 <ddarius> @google "What is a purely functional language"
20:57:03 <lambdabot> https://www.cs.indiana.edu/~sabry/papers/purelyFunctional.ps
20:57:04 <mm_freak> c doesn't take a type argument…  its result type is already specified as A by the caller
20:57:26 <mm_freak> correctGetTwoRandoms f = … f Int … f Integer …
20:57:41 <ddarius> g(r) = e_0 r e_0 / |r|^n  where e_0^2 = -1 and e_i^2 = 1.
20:58:28 <mm_freak> latro`a: that's really all there is to it =)
21:00:24 <latro`a> this caller/callee distinction is already a bit much for me
21:01:50 <startling> hi, how do I quickcheck the results of a specific Gen x ?
21:02:34 <Guest31397> is explicit recursion a code smell?
21:03:06 <mm_freak> Guest31397: for non-monadic code you would normally prefer combinators
21:03:15 <applicative> Guest31397: no
21:03:16 <mm_freak> for monadic code recursion is sometimes nice
21:03:44 <Guest31397> k
21:05:19 <Guest31397> in this case its monadic, and involves at some point mapM using one function that is mutually recursive with another one level lower in the structure (mapM of Traversable)
21:05:50 <Veinor> recursion is great
21:07:30 <hpaste> Guest31397 pasted “Explicit recursion” at http://hpaste.org/72096
21:07:43 <latro`a> ...wow
21:08:15 <Guest31397> loop, loop', and match are the strongly connected functions
21:08:36 <latro`a> oh that is less monolithic than it looks
21:08:44 <latro`a> your indentation throws me off for some reason
21:09:04 <Guest31397> unify' doesn't really need to exist except to not shadow variable names..
21:09:26 <Veinor> what's the recommended random number generation approach if i don't really care that much about cryptographic security?
21:09:58 <latro`a> uh, depends how many things you're generating I think
21:10:35 <Veinor> how so
21:10:54 <latro`a> well for example if you only need one, randomIO is convenient, but if you may need many, randomRs is convenient
21:11:00 <Veinor> oh
21:11:03 <Veinor> yeah i'm going to need many
21:11:10 <latro`a> randomRs can get you an infinite list
21:11:40 <Veinor> i think i want Control.Monad.Random though
21:11:56 <latro`a> do gen <- getStdGen; randomRs (whatevermin,whatevermax) gen
21:12:13 <latro`a> that randomRs isn't an action, but you'd do stuff with it
21:12:21 <Veinor> so i don't have to explicitly thread the RNG around
21:12:38 <latro`a> randomRs doesn't require threading it, it just returns an infinite list
21:12:43 <latro`a> but it is pseudorandom
21:12:54 <Veinor> i mean, i still have to pass the list around
21:13:19 <latro`a> true
21:13:24 <Veinor> whereas with MonadRandom i can just do getRandomR
21:13:24 <startling> Veinor: randomIO :: IO Int -- or whatever
21:13:40 <latro`a> kinda depends where your code lives, too
21:13:46 <startling> that too
21:13:48 <latro`a> and how irregular your queries are
21:15:54 <latro`a> in the little game I made recently, I used randomRs, but it only gets used directly in one function, so it's not a big deal
21:16:27 <Veinor> yeah, i'm making a sizeable game, so
21:17:14 <latro`a> if the queries are irregular then MonadRandom is the way to go, yes
21:17:20 <mm_freak> Veinor: i almost always use cprng-aes
21:17:33 <mm_freak> it has a System.Random interface as well as a Crypto-API interface
21:17:34 <latro`a> (I should say, in my example the irregularity is still present but wrapped up in laziness)
21:18:02 <mm_freak> Veinor: if you need very high speed i suggest mersenne-random instead
21:18:32 <Veinor> nah, speed isn't important
21:18:32 <mm_freak> if both quality and speed don't matter, using StdGen is probably fine
21:18:58 <latro`a> incidentally, any reason why the magic number in stdSplit is maxInt-86?
21:19:18 <latro`a> eh, *maxBound :: Int
21:41:48 <fragamus> binary-0.4.1: Binary serialization for Haskell values using lazy ByteStrings   ---OR---   cereal-0.3.5.2: A binary serialization library  ?
22:17:20 <mmirman`> https://github.com/mmirman/rpc-framework
22:42:11 <yitz> mmirman`: looks interesting. but why isn't it on hackage?
22:44:30 <pqmodn> @pl \x -> x == read (show x)
22:44:30 <lambdabot> ap (==) (read . show)
22:47:50 <yitz> @check ap (==) (read . show)
22:47:52 <lambdabot>   "OK, passed 500 tests."
22:48:15 <Axman6> @check ap (==) (read . show) :: Int -> Bool
22:48:16 <lambdabot>   Couldn't match expected type `GHC.Types.Int -> GHC.Bool.Bool'
22:48:32 <Axman6> @type ap (==) (read . show)
22:48:34 <lambdabot> forall a. (Eq a, Read a, Show a) => a -> Bool
22:48:45 <yitz> Axman6: better define Read and Show instances for that type first :)
22:48:55 <yitz> Axman6: it defaulted to Integer
22:49:07 <Axman6> it shotld be defaulting to ()
22:49:15 <yitz> Axman6: oh maybe
22:49:40 <pqmodn> @type (==) <*> (read . show)
22:49:41 <lambdabot> forall a. (Eq a, Read a, Show a) => a -> Bool
22:50:10 <pqmodn> is ap more idiomatic in this case?
22:50:20 <yitz> pqmodn: nope
22:50:41 <yitz> pqmodn: just what @pl decided to use. not sure if knows about <*>.
22:51:06 <yitz> pqmodn: @pl obviously makes no attempt at being idiomatic
22:52:07 <startling> what does @pl stand for?
22:52:12 <yitz> pqmodn: personally, i use whichever is more clear. i prefer <*> over `ap` and ap over (<*>).
22:52:12 <pqmodn> ah, just curious. i've also seen liftA2 and friends used instead of <*> now and then
22:52:13 <Axman6> pointless
22:52:32 <Axman6> a play on the phrase point free
22:52:44 <startling> ha
22:53:34 <yitz> pqmodn: liftA2 looks better when you are also using liftA3, liftA4, ..., which occasionally come out nicer than ..<$>..<*>..<*>...
22:53:46 <whittle> How does one figure out the kind a class expects in its type variable?
22:54:41 <yitz> whittle: you can use a type of any kind
22:54:49 <pqmodn> whittle: the compiler will tell you if you get it wrong :)
22:55:09 <Axman6> whittle: you can usually figure it out from the type of its functions:
22:55:13 <Axman6> :t return
22:55:14 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
22:55:26 <pqmodn> eg "instance Monad String where ..." will cause "Kind mis-match: first argument of Monad should have kind * -> *"
22:55:26 <Axman6> obviously m has to have kind * -> *
22:57:48 <whittle> Axman6: The haddock for prelude doesn’t show the forall portion. Is lambdabot deriving it?
22:58:02 <Axman6> it's unnecessary really
22:59:03 <whittle> pqmodn: While I’m fine with letting the compiler catch my mistakes, I’m really uncomfortable with depending on the compiler to determine what’s possible for me.
23:00:22 <mmirman`> yitz: There are a couple things I would like to iron out first, and I also need to write documentation.
23:00:39 <whittle> Axman6: Why do you say it’s unneccessary?
23:00:55 <Ralith> whittle: it makes explicit what is normally implicit
23:01:20 <Axman6> because in this case it's implied. const has type forall a b. a -> b -> a, but they're redundant here
23:01:46 <startling> quickcheck question: how do I run a test on a specific Gen something?
23:01:58 <Axman6> forAll i think
23:02:15 <Axman6> @hoogle Gen a -> Property a
23:02:16 <lambdabot> Did you mean: Gen a -> Property
23:02:16 <lambdabot> No results found
23:02:20 <Axman6> @hoogle Gen a -> Property
23:02:21 <lambdabot> Test.QuickCheck.Property forAll :: (Show a, Testable prop) => Gen a -> (a -> prop) -> Property
23:02:21 <lambdabot> Test.QuickCheck forAll :: (Show a, Testable prop) => Gen a -> (a -> prop) -> Property
23:02:21 <lambdabot> Test.QuickCheck.Gen variant :: Integral n => n -> Gen a -> Gen a
23:02:25 <yitz> mmirman`: so you don't want anyone to try it in the meantime? the purpose of hackage is to make it easy and convenient to install packages - not only as a way to publish them in release form
23:02:42 <startling> Axman6: oh nice. thanks
23:03:26 <whittle> Axman6, Ralith: What do I look at to figure out what kind is implied?
23:03:37 <yitz> whittle: what could be better than the compiler determining what's possible?
23:03:37 <Axman6> how it's used
23:03:45 <Ralith> the spec describes the kind inference algorithm
23:04:20 <yitz> whittle: if you want to be pedantic and limit yourself to a published standard, then read the standard. most people use GHC extensions, in which case GHC itself is the best source of information.
23:04:21 <whittle> yitz: Knowing a priori what’s possible and using the compiler to check my decisions?
23:05:16 <yitz> whittle: the GHC documentation is pretty good.
23:06:21 <whittle> Axman6, Ralith, yitz: Thank you. I’ll read the GHC documentation.
23:07:36 <whittle> Whoah. Infix type constructors? I’m learning already.
23:07:40 <yitz> whittle: i've learned more from playing around in ghci than from reading the docs. but it is true there are some things that are hard to get without reading the docs.
23:21:48 <thetallguy1> is there a  better pretty printer around for data structures than show?
23:22:19 <thetallguy1> I remember seeing something that was Data a => prettyPrint a or something
23:23:45 <shachaf> There's "groom", which uses Show.
23:24:26 <shachaf> (By parsing the result of "show" and then pretty-printing it.)
23:24:57 <thetallguy1> that looks like just the ticket.
23:24:58 <thetallguy1> thanks
23:27:22 <mmirman`> yitz:  I'll have a version up by tomorrow.
