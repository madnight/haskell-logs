00:21:25 <kizzo> How do you convert a Float to a GLfloat?
00:21:57 <ion> realToFrac probably.
00:22:08 <kizzo> I am first doing "(x::Float,_,_) <- Body.getBodyPosition b"
00:22:19 <kizzo> And then "glTranslatef (x::GLfloat) 0 0"
00:22:20 <b52> how is the performance about such sort of recursion: let f a = if a > 1000000 then 0 else a + f (a+1)
00:22:24 <kizzo> Alrighty I'll try that thanks.
00:22:33 <zzing_> :t (Data.Text.pack)
00:22:36 <lambdabot> String -> Data.Text.Internal.Text
00:22:58 <zzing_> :t (Data.Text.Encoding.encodeUtf8) . (Data.Text.pack)
00:23:00 <lambdabot> String -> BSC.ByteString
00:23:37 <BluePeppers> looking at the documentation for Foreign.Marshal.unsafeLocalState, it says to use Foreign.Marshal.Unsafe instead. However, Foreign.Marshal.Unsafe doesn't seem to exist, or at least, I can't find any documentation on it.
00:26:26 <Eduard_Munteanu> b52: not really good
00:26:50 <b52> y?
00:26:57 <Eduard_Munteanu> b52: you probably want a strict accumulator for that stuff (or rewriting it in terms of a foldl')
00:27:04 <fmap> kizzo: note that `∷ a' is not a cast but a type annotation to help inference, you can't _change_ type with it
00:27:39 <Eduard_Munteanu> fmap: somebody's been Agda-ing too much? :)
00:28:01 <hpaste> b52 pasted “euler002” at http://hpaste.org/71181
00:28:22 <b52> not sure what i should use else
00:29:40 <Eduard_Munteanu> b52: the first one seems ok if you enable optimizations
00:29:59 <fmap> Eduard_Munteanu: i wish i could understand agda :(
00:30:13 <b52> i benchmarked both with -O2 but the first one is about 10 times slower then the second one
00:30:52 <Eduard_Munteanu> fmap: /j #agda and your dream can come true! :P
00:31:00 <Eduard_Munteanu> </sales pitch>
00:32:48 <Eduard_Munteanu> b52: what if you replace sum by a foldl'?
00:34:09 <b52> Eduard_Munteanu: how may i?
00:34:39 <Eduard_Munteanu> :t foldl' (+) 0
00:34:41 <lambdabot> forall a. (Num a) => [a] -> a
00:34:46 <Eduard_Munteanu> :t foldl' (+) (0 :: Int)
00:34:48 <lambdabot> [Int] -> Int
00:39:35 <WraithM> ) <== 1)
00:40:51 <b52> Eduard_Munteanu: thats 5 times slower
00:41:32 <b52> i mean what is bad about my explicit recursion while arguing about performance
00:41:40 <b52> not about reasoning or readability
00:44:14 <Eduard_Munteanu> b52: same reason foldl (+) 0 [1..50000] isn't great
00:44:57 <Eduard_Munteanu> (+) is strict, but you're building a large computation
00:47:02 <mroman> groupBy is freaking me out right now.
00:47:17 <mroman> > groupBy (>) [1,2,3]
00:47:19 <lambdabot>   [[1],[2],[3]]
00:47:23 <mroman> > groupBy (>) [1,2,3,4]
00:47:25 <lambdabot>   [[1],[2],[3],[4]]
00:47:28 <mroman> > groupBy (<) [1,2,3,4]
00:47:29 <lambdabot>   [[1,2,3,4]]
00:47:45 <mroman> I would have expected [[1,2,3],[4]]
00:48:28 * hackagebot http-conduit 1.5.0.3 - HTTP client package with conduit interface and HTTPS support. (MichaelSnoyman)
00:48:58 <Eduard_Munteanu> mroman: 3 < 4 so 4 is in the same group
00:49:35 <Eduard_Munteanu> > groupBy (<) [1,2,3,2]
00:49:37 <lambdabot>   [[1,2,3,2]]
00:49:38 <mroman> hm
00:49:45 <pqmodn> > groupBy (==) [1,2,3,1,2,3]
00:49:47 <lambdabot>   [[1],[2],[3],[1],[2],[3]]
00:49:51 <mroman> > groupBy (flip(>)) [1,2,3,4,0]
00:49:55 <lambdabot>   mueval-core: Time limit exceeded
00:50:02 <mroman> > groupBy (flip(>)) [1,2,3,4,0]
00:50:04 <Eduard_Munteanu> Erm.
00:50:05 <lambdabot>   [[1,2,3,4],[0]]
00:50:09 <mroman> ah.
00:50:10 <mroman> perfect
00:52:25 <mroman> wtf.
00:52:41 <mroman> > groupBy (flip (>)) [1,2,3,4,50,40,30]
00:52:43 <lambdabot>  Terminated
00:52:58 <mroman> groupBy is probably not working as I would have expected.
00:53:03 <ion> @src groupBy
00:53:04 <lambdabot> groupBy _  []       =  []
00:53:04 <lambdabot> groupBy eq (x:xs)   =  (x:ys) : groupBy eq zs
00:53:04 <lambdabot>     where (ys,zs) = span (eq x) xs
00:53:42 <mroman> > groupBy (flip (>)) [1,2,3,4,50,40]
00:53:45 <lambdabot>   [[1,2,3,4,50,40]]
00:54:07 <mroman> Why doesn't it do [[1,2,3,4,50],[40]] like with [1,2,3,4,0]
00:54:10 <pqmodn> it's compared everything to 1
00:54:44 <mroman> huh.
00:54:46 <ion> > groupBy (flip (>)) [1,2,3,4,0,50,40,-1,30,20]
00:54:49 <lambdabot>   [[1,2,3,4],[0,50,40],[-1,30,20]]
00:55:02 <mroman> That's disappointing.
00:55:02 <pqmodn> > span (< 1) [1,2,3,4,0]
00:55:04 <lambdabot>   ([],[1,2,3,4,0])
00:55:32 <pqmodn> > span (< 1) [2,3,4,0]
00:55:35 <lambdabot>   ([],[2,3,4,0])
00:56:21 <sqrt> Hi! How do I map over two lists? I have two lists of the same length and a function which takes a tuple as input.
00:56:31 <mroman> zipWith?
00:56:34 <opqdonut> or zip+map
00:56:44 <mroman> > zipWith (+) [1..10] [2..11]
00:56:46 <lambdabot>   [3,5,7,9,11,13,15,17,19,21]
00:56:53 <LK4D4> @help span
00:56:53 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
00:56:57 <opqdonut> > map (\(x,y) -> x+y) $ zip [1,2,3] [4,5,6]
00:56:59 <lambdabot>   [5,7,9]
00:57:07 <opqdonut> :t zip
00:57:09 <lambdabot> forall a b. [a] -> [b] -> [(a, b)]
00:57:26 <mroman> Probably zip if you take a tupel as input, yes.
00:57:43 <sqrt> Thank you very much! I'll try that.
00:58:05 <ion> > getZipList ((+) <$> pure [1..10] <*> pure [2..11])
00:58:06 <lambdabot>   No instance for (GHC.Num.Num [t])
00:58:06 <lambdabot>    arising from a use of `e_1110211' at <...
00:58:12 <mroman> > map (uncurry(
00:58:14 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
00:58:23 <mroman> > map (uncurry(+)) $ zip [1,2] [3,4]
00:58:25 <lambdabot>   [4,6]
00:58:28 <ion> whoops
00:58:37 <ion> > getZipList ((+) <$> ZipList [1..10] <*> ZipList [2..11])
00:58:38 <lambdabot>   [3,5,7,9,11,13,15,17,19,21]
00:59:06 <LK4D4> >[x+y | (x,y) <- zip [1,2] [3,4]]
00:59:13 <LK4D4> :E
00:59:58 <sqrt> What does the $ mean?
01:00:00 <LK4D4> > [x+y | (x,y) <- zip [1,2] [3,4]]
01:00:01 <lambdabot>   [4,6]
01:00:18 <mroman> sqrt: It's sort of an operator that puts parantheses around stuff.
01:00:39 <mroman> a . b $ f c -> (a . b) (f c)
01:00:48 <pqmodn> and if you mean <$>, that's equivalent to fmap
01:01:29 <ion> ($) has a very low precedence, whereas normal function application has the highest precedence of all.
01:01:32 <b52> how can i meassure a constant which involves a lot of computation without letting ghc getting in my way by remebering the value?
01:01:39 <b52> *using criterion
01:02:10 <sqrt> Thanks!
01:02:39 <sqrt> Wow, it worked. :)
01:02:54 <ion> You could e.g. change “a :: Foo” to “a :: () -> Foo” and call it with “a ()”, i think.
01:04:27 <fmap> isn't ($) just identity functor's fmap?
01:05:28 <ion> That would be (.)
01:05:35 <b52> ion: doesnt work
01:05:35 <ion> ($) = id
01:06:29 <fmap> :t ($)
01:06:31 <lambdabot> forall a b. (a -> b) -> a -> b
01:06:32 <fmap> :t fmap
01:06:35 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
01:07:07 <optimight> sqrt: groupBy comes in what package?
01:07:36 <optimight> Which?
01:07:43 <frerich> @hoogle groupBy
01:07:44 <lambdabot> Data.List groupBy :: (a -> a -> Bool) -> [a] -> [[a]]
01:07:44 <lambdabot> Data.ByteString.Char8 groupBy :: (Char -> Char -> Bool) -> ByteString -> [ByteString]
01:07:44 <lambdabot> Data.ByteString.Lazy.Char8 groupBy :: (Char -> Char -> Bool) -> ByteString -> [ByteString]
01:07:53 <sqrt> optimight: I'm sorry?
01:08:00 <sqrt> I'm completely new to all this.
01:08:12 <tdammers> there is more than one groupBy function
01:08:50 <mroman> I would want a groupBy which compares consecutive elements.
01:08:51 <optimight> freiksenet: I did Hoogle ..but could not get the "List Function Suggestions"
01:08:53 <ion> b52: Ok. How about “a :: Int -> Foo” and use “bench … (whnf a 100)”?
01:09:27 <optimight> frerich: I did Hoogle ..but could not get the "List Function Suggestions"
01:09:41 <pqmodn> optimight: Data.List
01:10:07 <optimight> tdammers: I want to understand groupBy for list
01:10:13 <frerich> mroman: So consecutive elements which are equal end up in one gruop - then you simply want "group". :-)
01:10:21 <optimight> pqmodn: I will refer Data.List
01:11:18 <mroman> frerich: I want to groupBy ascending order ;)
01:11:32 <mroman> Basically finding sorted subsequences.
01:11:51 <optimight> frerich: Is it possible to get all the elements equal end up in one group  - using GroupBy?
01:13:00 <LK4D4> optimight, equal elems may not following each other?
01:13:07 <frerich> optimight: You could use 'groupBy (==)' (which is the same as just 'group') to get all equal *consecutive* elements into one group. If you want to get all elements into one gruop, theny ou could first sort and then group
01:13:22 <optimight> LK4D4: yes ... not following each other
01:13:51 <frerich> > group . sort $ "Banana"
01:13:55 <lambdabot>   ["B","aaa","nn"]
01:14:19 <optimight> frerich: yes ..got it
01:25:45 <hpaste> b52 pasted “criterion constant” at http://hpaste.org/71183
01:27:18 <b52> any idea whats the problem?
01:31:59 <solrize> how common is it for a single threaded program to run 2x slower with -N2 ?
01:36:35 <Rc43> Is there any standard function for searching substring?
01:38:18 <ion> isInfixOf or something like that
01:38:22 <Rc43> Hm, it is possible for ByteStrings.
01:38:52 <ion> @hoogle [a] -> [a] -> Bool
01:38:53 <lambdabot> Data.List isInfixOf :: Eq a => [a] -> [a] -> Bool
01:38:53 <lambdabot> Data.List isPrefixOf :: Eq a => [a] -> [a] -> Bool
01:38:53 <lambdabot> Data.List isSuffixOf :: Eq a => [a] -> [a] -> Bool
01:41:02 <Rc43> ion, thanks; i have searchhed `isInfix` (without `of`).
01:51:56 <a> hi
01:52:34 <Guest37399> heyyy brother?
01:52:49 <Botje> hallo.
02:09:10 <optimight> I am using IRC client smuxi and many a times when I want to join #haskell , I fall somewhere written #haskell but only one member found <msf>, what is wrong?
02:11:25 <johnleo> Hello all. Yesterday a colleague showed me a Haskell puzzle. "loop n = 1 + loop n", which can be rearranged (equational reasoning, optimisation, graph reduction...) to be "0 = 1". He's buggered off now, and I'm still stumped by this. Can anyone enlighten me?
02:11:57 <companion_cube> bottom = bottom + 1, no problem
02:12:07 <companion_cube> loop n is undefined
02:12:52 <johnleo> companion_cube: but we can reduce (call it an optimisation) out "loop n" can't we, so there is no bottom in the expression anymore
02:14:18 <companion_cube> johnleo: so what's in the left part of the equation?
02:14:35 <companion_cube> I mean, 0 is already defined
02:15:20 <johnleo> companion_cube: "loop n = 1 + loop n" is undefined, but if we rearrange we get "0 = 1", is that defined?
02:15:53 <johnleo> companion_cube: i dont' know if a definition can be "undefined" on its own, or if just values are undefined
02:16:21 <johnleo> companion_cube: perhaps the answer is that rearranging anything with bottom in it is incorrect
02:17:16 <companion_cube> well I don't know about when you can use optimizations, but I don't think you can change the semantic
02:17:27 <companion_cube> and here, it's clear that loop n has no normal form
02:20:20 <Rc43> Is there a function for checking FilePath on directory?
02:20:39 <Rc43> I have list of paths and I want read all files from it.
02:23:50 <Rc43> I can use `isFileExist` or `isDirctoryExist`, but it seems to be not very good.
02:24:15 <Rc43> *does
02:24:49 <Eduard_Munteanu> joni6128: ex falso quod libet
02:24:54 <Eduard_Munteanu> erm.
02:24:59 <Eduard_Munteanu> Sorry, he quit.
02:26:37 <LK4D4> filenames <- getDirectoryContents "/home/"
02:27:04 <LK4D4> *import System.Directory
02:29:03 <Rc43> LK4D4, it is with directories
02:29:18 <Rc43> LK4D4, and I already have list of files
02:31:58 <LK4D4> oh, sorry
02:32:27 <LK4D4> it seems, that doesDirectoryExist only way to do that
02:37:53 <mm_freak> Rc43: if you have a list of files already, then just read them
02:38:10 <mm_freak> mapM_ (readFile >=> putStr) files
02:38:20 <mm_freak> that's 'cat' for a list of files
02:39:15 <mm_freak> if you want to actually accumulate the results somehow, then use mapM or foldM
02:39:20 <Rc43> mm_freak, list contains files and direcories
02:39:34 <Rc43> mm_freak, I already decided to use doesFileExist, it's fine
02:39:45 <mm_freak> Rc43: one way is to read anyway and handle the exception thrown
02:40:02 <Rc43> mm_freak, don't like handle haskell exceptions
02:40:41 <Rc43> mm_freak, (because lazy to get accustomed to it :)
02:41:10 <mm_freak> uhm…  out of curiosity…  what's wrong with haskell exceptions?
02:41:30 <mm_freak> that 'catch' is a regular function instead of something builtin? ;)
02:42:12 <companion_cube> it requires to be in IO, and does not show up in types
02:42:47 <mm_freak> companion_cube: that's not relevant here, because doesDirectoryExist has the same problem
02:44:24 <hpaste> b52 pasted “dunno whats wrong” at http://hpaste.org/71187
02:44:35 <b52> someone?
02:45:26 <mm_freak> b52: 'fs' claims that it can handle a polymorphic type, but it in fact can only handle Int
02:46:13 <mm_freak> on the type level "a == Int" is expressed as "a ~ Int"
02:46:43 <srhb> But that's not the only problem
02:47:03 <mm_freak> i don't see another problem there
02:47:03 <srhb> [f] does not take an argument ()
02:47:09 <srhb> Oh
02:47:13 <srhb> No, you're right
02:47:21 <srhb> I forgot the [] in the annotation
02:47:30 <b52> well, i would like to create a list of functions which get a unit and return an isntance of Num
02:47:59 <mm_freak> b52: you could make the type of 'f' polymorphic here
02:48:16 <sipa> you need to either change f to return Num a => a, or fs to return [Int]
02:48:25 <mm_freak> but all the functions in the list will have the same result type
02:49:51 <mm_freak> > let x :: (Num a) => () -> a; x = const 3; xs :: (Num a) => [() -> a]; xs = [x] in "that works"
02:49:52 <lambdabot>   "that works"
02:50:40 <srhb> Why const 3 and not just 3?
02:50:50 <mm_freak> because it's a function
02:50:54 <dmwit> Because he didn't explicitly mention the argument.
02:50:59 <srhb> Ah, yes.
02:51:22 <srhb> pointlessness :-)
02:51:31 <mm_freak> yeah, totally pointless code =)
02:52:02 <sipa> in several meanings
02:53:19 <mm_freak> b52: btw, you said that you actually /want/ the function to take a unit…  why?  do you want to prevent sharing?
02:53:29 <Rc43> mm_freak, exceptions are fine, but i need to additionally look in documentation for exceptions, which are thrown by function, because they don't affect types, etc
02:53:36 <dmwit> Rc43: Just so you know, calling doesFileExist and then munging the file is a race condition. Just munging the file and handling exceptions isn't.
02:53:44 <b52> mm_freak: yes
02:54:15 <mm_freak> b52: then better have () -> [a] instead of [() -> a]
02:54:26 <b52> ?
02:54:27 <Rc43> dmwit, will know now, thanks
02:54:44 <b52> i dont want the list to get shared
02:54:51 <mm_freak> b52: it won't
02:55:10 <mm_freak> sharing only happens when you refer to something multiple times
02:55:24 <b52> its a list of constants which i would like to benchmark using criterion, thats why i extended them to functions taking a unit
02:55:29 <srhb> About the exceptions on, say, readFile, why isn't it just Either SomeFileException (IO String) ? That the exceptions don't show up in the type system seems a valid complaint.
02:55:54 <mm_freak> b52: sharing only happens, when you actually have multiple references to the same thing
02:56:30 <mm_freak> b52: unless it's a CAF, but then the list is shared anyway, only the values aren't shared, so you gained nothing
02:56:57 <b52> its no about the list
02:57:41 <mm_freak> b52: you may be misunderstanding sharing =)
02:58:05 <b52> that may be the case
02:58:12 <b52> but the result i want to accomplish looks good
02:59:24 <fmap> srhb: do you mean `IO (Either SomeFileException String)'?
02:59:34 <srhb> fmap: Uh, yes.
03:00:02 * srhb is not quite awake, it seems.
03:00:27 <fmap> yeah, that would be a nice alternative to IO String + exceptions
03:00:36 <fmap> not quite newbie-friendly though
03:00:57 <srhb> I don't know, the lack of type annotations for things that may fail seems a serious shortcoming that ought to be fixed.
03:03:11 <b52> is there a function which gets me the name of a function as string? Oo
03:03:45 <mauke> b52: functions don't have names
03:05:29 <fmap> b52: you can do this with TH
03:05:39 <b52> TH ?
03:05:45 <fmap> well, probably
03:05:46 <dmwit> Um, really?
03:05:49 <mauke> fmap: how?
03:05:51 <dmwit> I think that's a bit unlikely.
03:06:28 <dmwit> foo f = $[nameOf| f |] -- what is this supposed to do? surely nothing can be done statically, here, so TH is out
03:07:46 <fmap> well, it's impossible to get arbitary function name via TH, but it's possible to generate a function with a name given in string
03:08:16 <fmap> quite different from what was asked though
03:09:05 <dmwit> srhb: The paper "A semantics for imprecise exceptions" discusses weaknesses of treating exceptions as values in section 2.2.
03:09:47 <srhb> dmwit: Thanks.
03:09:48 <fmap> b52: TH is Template Haskell extension
03:10:21 <dmwit> TH can only make annoying code less annoying. It can't do magic.
03:10:42 <kopi> I just watched "A History of Haskell: being lazy with class"
03:10:46 <kopi> from 2007
03:10:59 <kopi> is there any new updated
03:11:19 <kopi> desdescribing history of haskell 2010
03:11:30 <kopi> new standart
03:11:54 <srhb> There are not that many news really.
03:12:13 <kopi> :/
03:12:24 <srhb> Were you hoping for something specific?
03:13:06 <kopi> Just the development history
03:13:17 <kopi> http://www.haskell.org/pipermail/haskell/2009-November/021750.html
03:13:24 <kopi> reading this now.:)
03:21:01 <mm_freak> fmap: IO (Either e a) would be very inconvenient
03:21:18 <mm_freak> rather EitherT e IO a, but then everything would be basically in that monad
03:21:27 <mm_freak> so you could just as well shorten it and have IO a
03:21:30 <mm_freak> which is what we have =)
03:22:29 <ion> I wrote this for someone on IRC in a bit hasty manner. Any errors i’m not noticing? “Typeclass desugaring” https://gist.github.com/3082411
03:23:33 <mm_freak> ion: that's correct
03:23:44 <ion> Thanks
03:24:41 <mm_freak> but there is a talk about that by SPJ, which is very nice
03:24:44 <barrucadu> ion: Check your last two code lines, you turn a 42 into a 24
03:25:02 <mm_freak> i don't remember its name though, but it's very great and goes into exactly that detail
03:25:02 <ion> Hah! Thanks.
03:29:04 <hpaste> dmwit annotated “www.pastebin.com/TL4sRpMm” with “cleaned up” at http://hpaste.org/71188#a71189
03:29:04 <mauke> The paste TL4sRpMm has been copied to http://hpaste.org/71188
03:29:26 <mauke> ah, and that's probably why I didn't have that "feature" before
03:30:08 <ion> hah
03:37:12 <Saizan> ion: inc takes 1 argument
03:37:30 <ion> saizan: Duh. Thanks
03:37:40 <mm_freak> GHC still does static linking by default for haskell libraries?
03:53:37 * hackagebot alsa-gui 0.1 - Some simple interactive programs for sending MIDI control messages via ALSA (HenningThielemann)
03:53:45 <HugoDaniel> hi
03:53:58 <srhb> HugoDaniel: Hi
03:54:09 <hepek> howdy
04:07:31 <cesip> soooo guys. i am dealing with overloading. the example of a user-defined class in thompson's book is
04:07:42 <cesip> class Visible a where
04:07:42 <cesip>   toString :: a -> String
04:07:42 <cesip>   size :: a -> Int
04:08:02 <cesip> one of the exercises is to define an instance Visible Int
04:08:05 <cesip> so i write
04:08:14 <cesip> instance Visible Int where
04:08:14 <cesip>     toString = show
04:08:14 <cesip>     size x = x
04:08:43 <cesip> ghci recompiles the module fine, but then throws an error when I try toString with an Int
04:09:06 <mauke> cesip: what error?
04:09:14 <cesip>     Ambiguous type variable `a0' in the constraints:
04:09:15 <cesip>       (Num a0) arising from the literal `4' at <interactive>:4:10
04:09:15 <cesip>       (Visible a0)
04:09:15 <cesip>         arising from a use of `toString' at <interactive>:4:1-8
04:09:23 <mauke> you didn't try toString with an Int
04:09:35 <mauke> 4 is not an Int
04:10:07 <cesip> ah, toString (4::Int) works
04:10:29 <fmap> :t 4
04:10:31 <lambdabot> forall t. (Num t) => t
04:10:37 <mauke> since Visible is not one of the "special" classes, defaulting doesn't kick in
04:10:43 <mauke> and you get an ambiguous type error
04:11:01 <mauke> > complement 4
04:11:03 <lambdabot>   Ambiguous type variable `a' in the constraint:
04:11:03 <lambdabot>    `Data.Bits.Bits a'
04:11:03 <lambdabot>      a...
04:11:07 <mauke> > complement (4 :: Int)
04:11:09 <lambdabot>   -5
04:11:28 <mauke> (here the class is Bits. same problem.)
04:11:36 <scopedTV> yes 4 is really "fromInteger 4"
04:11:44 <scopedTV> which has type Num a => a
04:11:52 <scopedTV> so the compiler doesn't know which instance to choose.
04:11:58 <cesip> i see, time to dig into the numerical types then
04:12:00 <scopedTV> the reason something like 4 + 5 works is defaulting
04:12:28 <scopedTV> because 4 + 5 has type Num a => a as well
04:13:05 <scopedTV> however, if you type 4 + 5 in ghci it will select Integer for you, in a somewhat evil manner imo. GHC will warn you if you select -Wall
04:13:19 <scopedTV> s/select/specify/
04:14:18 <sipa> saying that "4" is really "fromInteger 4" is kind of a recursive definition :)
04:14:40 <scopedTV> yes. but fromInteger :: Num a => Integer -> a
04:14:58 <scopedTV> so the second 4 is of monomorphic type :)
04:14:59 <ion> “fromInteger anIntegerValueFor4”
04:15:05 <sipa> i'd say 4 is (fromInteger TheInteger4)
04:15:15 <scopedTV> Fine. That's a good way to think about it.
04:15:16 <sipa> </pedantic>
04:17:31 <scopedTV> :t 2.0
04:17:32 <lambdabot> forall t. (Fractional t) => t
04:17:55 <scopedTV> ^ you see here that "fractional values" have a similar property, they're also polymorphic.
04:18:56 <ion> 2.0 stands for fromRational (TheInteger2 % TheInteger1)
04:23:25 <Barret> hi
04:23:50 <tdammers> fromNumericLiteral TheNumericLiteral4
04:29:05 <dmwit> ion: Technically, it probably stands for fromRational (TheInteger20 % TheInteger10).
04:34:42 <ion> Yeah, sounds likely.
04:41:04 <Zugzwang> help
04:41:15 <Zugzwang> nm, looking for the ./help
04:44:12 <nominolo> copumpkin: you were looking for me?
04:52:25 * gienah tries building dev-haskell/vty
04:52:36 <gienah> wrong channel sorry
04:58:57 <\rs> is vty-4.7.0.14 really built on ghc-7.4? http://hackage.haskell.org/package/vty
04:59:40 <\rs> this was the message when i tried to build it with ghc-7.4.1 http://bpaste.net/show/34272/
05:03:21 <fmap> hm, builds for me on 7.4.1
05:03:46 <gienah> \rs yes, that vty error message is from where I fixed the build for ghc 7.5, but broke it for ghc 7.4 :-/
05:04:19 * gienah is working on a more portable patch
05:04:57 <\rs> gienah: sorry, but i do not catch on
05:05:36 <fmap> i guess that's not hackage's vty
05:05:37 <fmap> ?
05:06:44 <gienah> fmap almost except for my broken patch, to fix a build error with ghc 7.5, I
05:07:09 <gienah> I'm tweakin the vty patch for build with ghc 7.4 as well as 7.5
05:08:54 <fmap> ah, i see, probably \rs should have specified that he's trying to install from gentoo-haskell or something
05:12:24 <LUEshi> sup
05:12:38 <LUEshi> can I ask for xmonad help here?
05:12:52 <scopedTV> is there no #xmonad, LUEshi?
05:13:14 <scopedTV> if you encounter a type error or something, we might be able to help you.
05:13:21 <LUEshi> yeah but people are unavailable and I feel like my question is prety general
05:13:36 <scopedTV> more xmonad-specific things we might not be able to answer.
05:13:37 <mauke> LUEshi: you're a liar
05:13:59 <eikke> I must be doing something wrong :( getting memory corruption :-/
05:14:01 <LUEshi> well  the one person available decided to be a douche and wasted most of my night
05:14:11 <mauke> that is also a lie
05:14:19 <scopedTV> eikke: "memory corruption" ?
05:14:35 <LUEshi> why didnt you help me out instead of wasting my time?
05:15:05 <mauke> this is off-topic here
05:15:19 <`jpi> :)
05:15:20 <eikke> scopedTV: memory changing behind my back, I guess I'm not playing nice with the GC or something alike (doing GHC.Prim/Exts/... based stuff, so easy to burn myself)
05:15:30 <scopedTV> ah yeah then you're on your own :)
05:15:33 <`jpi> i am liking haskell more and more
05:15:40 <scopedTV> good to hear, `jpi :)
05:18:08 <LUEshi> anyone else can help me out ? I just need to know to start xterm on another workspace from xmonad.hs
05:18:28 --- mode: ChanServ set +o mauke
05:18:28 --- mode: mauke set +q *!*@modemcable064.222-177-173.mc.videotron.ca
05:20:28 --- mode: mauke set -o mauke
05:24:47 --- mode: ChanServ set +o mauke
05:24:47 --- mode: mauke set -q *!*@modemcable064.222-177-173.mc.videotron.ca
05:26:47 --- mode: mauke set -o mauke
05:40:32 <kopi> Can you use UML diagrams of Haskell
05:40:38 <kopi> Does something like that exist
05:41:42 <kopi> also about functional programming paradigm is there any guide that is recommended to read
05:41:44 <kopi> :)
05:41:50 <tgeeky> @where LYAH
05:41:50 <lambdabot> http://www.learnyouahaskell.com/
05:41:59 <tgeeky> kopi: UML is sort of tied to object-orientedness
05:42:01 <tgeeky> ... sort of.
05:42:11 <tgeeky> But you could use it to understand a functional program
05:42:50 <kopi> explain a little bit more :)
05:43:20 <kopi> what do you mean with "undestand"
05:43:53 <tgeeky> kopi: well, the point of a UML diagram (unless you're one of those who uses the diagrams directly to produce programs), is to understand and visualize your program and its behavior
05:44:13 <kopi> yes when i writte huge programms this helps a lot
05:44:16 <kopi> *alot
05:44:42 <tgeeky> for instance, class diagrams may not be useful as "class" has a different meaning in Haskell. Object diagrams (arguably the meat of UML) would be different in Haskell.
05:45:14 <kopi> is there an alternative then :)
05:45:30 <kopi> to display it visually or via diagrams
05:45:45 <tgeeky> I don't think there is a well established one. We have some beginning tools which visualize types
05:46:05 <kopi> link please.Thanks.:)
05:46:20 <tgeeky> kopi: http://www.mgsloan.com/panopti2.png
05:46:30 <barrucadu> kopi: "a lot" is correct ;)
05:46:32 <tgeeky> kopi: it's really a different thing
05:47:17 <kopi> interesting thanks you tgekky i like it.:)
05:47:47 <tgeeky> kopi: this: http://hackage.haskell.org/package/flow2dot
05:47:58 <tgeeky> creates diagram that reminds me why I don't like UML
05:48:38 <kopi> nice and it supports the latest version.:D
05:48:46 <kopi> :P
05:49:17 <srhb> I think simply visualizing data flow can be fine.
05:49:29 <srhb> No standard needed though, it's trivially simple to draw.
05:49:54 <kopi> What do you mean srhb?
05:50:55 <srhb> If you're looking to visualize your (big) program, you can just draw the way the data flows.
05:51:31 <srhb> Or did I misunderstand your intention?
05:51:49 <kopi> yes of course you are right.Thanks.:)
05:53:08 <srhb> I think the reason it seems hard to name the right way to model functional programs is because the functional programs are very close to the model itself.
05:54:08 <srhb> "So we want to map another 100 dollars to each client's account".. Well, okay. There you go.
05:54:15 <akamaus> What's the easiest way of running several IO actions in parallel and collect the results? They're IO-bound so green threads are perfectly ok.
05:54:22 <kopi> Yes but its a start I research more on it.:)
05:55:34 <mauke> akamaus: create an MVar, forkIO N threads that putMVar their results, then takeMVar N times
05:56:47 <srhb> Or Chans maybe?
05:57:10 * tgeeky bets 1.02 internet doolars on mauke's answer
05:57:21 <srhb> tgeeky: :<
05:57:24 <akamaus> maybe.. I thought about some readily available solution. I found parallel-io, but looks like it for cpu-bound computations
05:57:25 <srhb> No one trusts me.
06:15:53 <davesq> hi all. has anyone used zip-archive package before? i'm a n00b and a bit stuck with it.
06:16:33 <srhb> davesq: A while ago.
06:17:01 <davesq> i have an Archive that i've updated, but can't figure out how to write that back to the file system
06:17:10 <davesq> (api here: http://hackage.haskell.org/packages/archive/zip-archive/0.1.1.8/doc/html/Codec-Archive-Zip.html)
06:18:02 <srhb> fromArchive and write the ByteString
06:18:24 <srhb> http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#v:writeFile
06:18:48 <srhb> writeFile "pathgoeshere.zip" . fromArchive $ yourArchive
06:19:05 <davesq> srhb: ah thanks! i was staring at the IO fns down the bottom, and missed fromArchive.
06:19:13 <srhb> :)
06:19:24 <srhb> I didn;t see those. you can use those too.
06:19:36 <srhb> Or can you...
06:20:24 <srhb> You can, but the other way around is simpler, really.
06:22:03 <davesq> srhb: they way you suggested is just what i was after. i can't figure out how to use the IO ones without doing a lot of filesystem interactions.
06:22:21 <srhb> davesq: Cool. :)
06:24:13 <srhb> the other way I think would be writeEntry [] (toEntry "yourPathGoesHere.zip" modifiedTime (fromArchive yourArchive))
06:24:18 <srhb> So yeah.
06:25:59 <davesq> srhb: i got the impression writeEntry decompresses the entry and writes it to file?
06:26:39 <srhb> I don't think so.
06:27:36 <davesq> srhb: i'll try it out once i get the neat way working :)
06:28:05 <srhb> But I think writing an entry can only be a single file in the compressed archive.
06:28:20 <srhb> Not sure though, actually you may be right in your interpretation.
06:29:03 <`jpi> UML is ridiculous
06:29:05 <davesq> that's cool, you've given me more than enough info to get unstuck. cheers :)
06:29:08 <`jpi> i never need it
06:29:35 <`jpi> anyway consider me one of those haskell fanbois
06:30:19 <srhb> `jpi: I agree. On all three accounts. :-)
06:33:24 <Penetrator> how would I make an Integer out of:  ceiling $ sqrt 1000
06:33:41 <mauke> that already is an integer
06:33:42 * hackagebot conduit 0.5.1 - Streaming data processing library. (MichaelSnoyman)
06:33:50 <Penetrator> ah...
06:33:57 <Cale> Just make sure the result is used as one
06:34:06 <Cale> (and not an Int or something)
06:34:17 <Cale> You can add an explicit type annotation to be sure
06:34:19 <Penetrator> I see, apply a function that take an integer
06:34:35 <Penetrator> Cale: thanks
06:42:35 <b52> how do I convert an Integer to Int ?
06:42:41 <Cale> fromIntegral
06:42:52 <Cale> (or fromInteger will do in this case)
06:43:01 <Cale> Int to Integer would be fromIntegral
06:43:31 <Cale> fromIntegral will turn any integer-like type of value into any sort of numeric value at all
06:43:49 <frerich> Is there some "wrapper" API for parsec which creates parsers having names, and then a function which prints EBNF-like output representing the grammar parsed by a given parser?
06:44:11 <mauke> no, and I strongly suspect that's impossible to implement
06:44:11 <frerich> So that you could generate the grammar straight from the sources (instead of going the other way round).
06:44:28 <t7> someone should make C with modules and type-classes
06:44:46 <mauke> go?
06:44:53 <t7> i would write them a supportive email
06:45:23 <t7> like go without garbage collection and a sensible type system
06:46:12 <t7> with a sensible type system*
06:47:15 <Cale> Sensible type system + no GC can be weird.
06:47:49 <t7> well you would still need to clean up after yourself
06:47:59 <t7> but think of the speed.
06:48:03 <t7> the blistering speed
06:48:25 <mauke> manual memory management is slow
06:48:34 <illissius-> t7: Rust is sort of like that, but it does have garbage collection
06:48:53 <t7> mauke: no... the blistering part...
06:48:55 <illissius-> but otherwise it's like C with type classes, ADTs, closures, and other nice things
06:52:25 <Cale> I think on average, humans do a worse job of memory management than GCs do. It's possible to do better than a GC in domain specific settings, and nothing is going to help you if you do too much allocation to begin with. But decent garbage collectors are quite good at their jobs.
06:52:50 <illissius-> t7: see f.ex. http://dl.rust-lang.org/doc/rust.html#interfaces
06:53:43 * hackagebot SHA 1.5.1 - Implementations of the SHA suite of message digest functions (AdamWick)
06:53:44 <`jpi> go syntax is ridiculous
06:54:07 <`jpi> i gave up on go
06:54:16 <mps4> Can I use template haskell to create constructors for a record generically?
06:54:16 <mps4> e.g.
06:54:16 <mps4> data Rec = Rec{i::Int, f::Float}
06:54:16 <mps4> constrParse = Rec <$> pInt <*> pFloat
06:55:05 <t7> illissius-: looks cool, does it infer the types too?
06:55:36 <illissius-> t7: I haven't used it, but it does have some kind of type inference. I'm not sure how powerful
06:55:39 <illissius-> maybe grep for it :)
06:58:40 <nobdraisentone>  Warning: orphan instance: instance Monoid Bool <- what does it mean?
07:00:40 <ClaudiusMaximus> nobdraisentone: perhaps see http://www.haskell.org/haskellwiki/Orphan_instance
07:01:12 <byorgey> nobdraisentone: did you make that instance?  or it is in a package you are compiling?
07:02:16 <nobdraisentone> byorgey: i wanna use Bool as Monoid like instance Monoid Bool where mempty = False; mappend = (||)
07:03:28 <nobdraisentone> Actually it not a Monoid, I know
07:03:33 <nobdraisentone> it's*
07:03:44 * hackagebot bindings-libzip 0.10.1 - Low level bindings to libzip. (SergeyAstanin)
07:05:28 <fmap> not a monoid?
07:05:37 <byorgey> nobdraisentone: that instance is already in Data.Monoid, it's called Any
07:06:21 <nobdraisentone> fmap: monoid, sorry
07:06:30 <nobdraisentone> byorgey: great
07:07:03 <byorgey> it is a monoid.  And a Monoid.
07:08:44 * hackagebot LibZip 0.10.1 - Bindings to libzip, a library for manipulating zip archives. (SergeyAstanin)
07:18:08 <ique> can someone explain to me why (1-1.1) in Haskell equals  -0.10000000000000009 and not -0.1?
07:18:35 <amiddelk> ique: that's related to floating points
07:18:40 <EvanR> ique: thats not a haskell specific thing
07:18:46 <EvanR> try it in python or whatever
07:18:51 <mauke> > 1 - 1.1 == (-0.1)
07:18:52 <lambdabot>   False
07:19:08 <mauke> preflex: calc '2 1 - 1.1
07:19:09 <preflex>  -0.000110011001100110011001100110011001100110011001101
07:19:18 <ddfreyne> ique: read up on how floating point numbers are stored, and you'll know why
07:19:23 <ique> But how do I fix it? It obviously introduces errors in numerical code?
07:19:24 <sipa> ique: the reason is that 0.1 and 1.1 cannot be represented exactly
07:19:30 <EvanR> stored / compute
07:19:37 <ion> > 1-1.1 :: CReal
07:19:38 <lambdabot>   -0.1
07:19:39 <mauke> ique: 0.1 is already an error
07:19:52 <ion> > 1-1.1 :: Rational
07:19:53 <lambdabot>   (-1) % 10
07:19:55 <sipa> the solution is that you should never test for exact equality between floating point numbers
07:20:06 <sipa> and always assume small errors will occur
07:20:37 <EvanR> ideally your threshold for noticing the error is greater than the actual errors in the simulation
07:20:50 <ion> If the errors are a problem, simply avoid floats. For instance, amounts of money should never be stored as floats.
07:21:21 <sipa> neither does it make sense to use floats for money; you're not interested in relative accuracy
07:21:55 <EvanR> you could use Data.Fixed Centi for dollars and cents...
07:23:18 <ion> Rational is another possibility if you want arbitrary precision (and assuming you don’t want irrational amounts of money :-P).
07:23:56 <sipa> > (sqrt 2)*(sqrt 2) :: CReal
07:23:57 <lambdabot>   2.0
07:24:10 <sipa> > ((sqrt 2)*(sqrt 2) - 2) :: CReal
07:24:11 <lambdabot>   0.0
07:24:13 <cdupont>  hi everybody!
07:24:29 <cdupont> sorry to disturb, I'm having a problem with ghc-pkg that I cannot solve:
07:24:30 <ion> > exp (pi * sqrt (-1)) + 1 :: Complex CReal
07:24:31 <ique> I'm thinking of where it could introduce problems. I'm trying to calculate the correlation between two vectors of numbers, and I get different results depending on the content of the vector, which I never should..
07:24:31 <cdupont> whenever I launch a ghc-pkg command it says ghc-pkg: too few bytes. Failed reading at byte position 65519
07:24:32 <lambdabot>   0.0 :+ 0.0
07:24:34 <cdupont> the file /usr/lib/ghc-6.12.1/package.conf seems to have disappeared from my system
07:24:43 <cdupont> is there a way to regenerate it?
07:24:58 <ion> Reinstall the package that contains it.
07:25:07 <ique> I.E. correlation (fromList [1,2,3,4,5,6,7,8,9,1000000000]) (fromList [1,2,3,4,5,6,7,8,9,1000000000]) yield 1.0
07:25:07 <ique> and correlation (fromList [1,2,3,4,5,6,7,8,9,0.001]) (fromList [1,2,3,4,5,6,7,8,9,0.001]) yields 0.9999999999999998
07:25:15 <cdupont> ion: ok
07:25:27 <cdupont> that should be ghc6 :)
07:29:21 <EvanR> how does sqrt 2 sqrt 2 == 2  with CReal?
07:29:45 <EvanR> i guess == doesnt work... but you know
07:29:53 <mauke> > sqrt 2 sqrt 2
07:29:54 <lambdabot>   1.4142135623730951
07:30:18 <Cale> hehehe :)
07:30:39 <Cale> > sqrt 2 * sqrt 2 :: CReal
07:30:41 <lambdabot>   2.0
07:30:47 <EvanR> > (sqrt 2)*(sqrt 2) :: CReal == 2
07:30:48 <lambdabot>   Only unit numeric type pattern is valid
07:31:07 <EvanR> > ((sqrt 2)*(sqrt 2) :: CReal) == 2
07:31:08 <lambdabot>   True
07:31:11 <EvanR> o_O
07:31:14 <Cale> EvanR: note that when it prints the number or uses == it's computing an approximation to an arbitrary number of digits
07:31:19 <Cale> I think it was 200 digits or so
07:31:23 <dmwit> 50ish
07:31:28 <EvanR> so its 50 zeros
07:31:28 <dmwit> > 1e-51 == 0
07:31:29 <lambdabot>   False
07:31:34 <ciaranm> 200 isn't very arbitrary
07:31:34 <codolio> > (1 :: CReal) == (1 + 1e-70)
07:31:35 <dmwit> > 1e-100 == 0
07:31:35 <lambdabot>   True
07:31:37 <lambdabot>   False
07:31:40 <dmwit> Oh, right, CReal.
07:31:43 <codolio> > (1 :: CReal) == (1 + 1e-70)
07:31:45 <lambdabot>   True
07:31:46 <dmwit> > 1e-51 == (0 :: CReal)
07:31:48 <lambdabot>   True
07:31:54 <Cale> oh, just 50
07:31:57 <dmwit> > 1e-50 == (0 :: CReal)
07:31:58 <lambdabot>   True
07:32:00 <akamaus> can anyone explain why evaluating the following expression (hxt) outputs nothing? runX $  selem "html" [selem "head" [selem "title" [txt "aaa"]]] >>> writeDocument [] "-"
07:32:03 <ciaranm> 50 is even less arbitrary than 200
07:32:07 <dmwit> > 1e-25 == (0 :: CReal)
07:32:08 <lambdabot>   False
07:32:16 <dmwit> Okay, I'll stop spamming.
07:33:09 <EvanR> Cale: wouldnt it be more correct to say that CReal is no in Eq
07:33:23 <Cale> EvanR: yes
07:33:28 <Cale> EvanR: but also less convenient
07:33:34 <EvanR> and Double isnt in Enum ;)
07:33:44 <Cale> Enum doesn't have any laws
07:34:00 <EvanR> shouldnt it?
07:34:06 <ciaranm> enumerating doubles is easy
07:34:32 <Cale> I think of it as defining what [a,b..c] and related syntaxes do
07:35:02 <Cale> I guess you could have laws for it
07:35:19 <Cale> but [a..b] wouldn't have to contain everything between a and b
07:35:45 <Cale> akamaus: looking...
07:35:59 <akamaus> Cale, have just found the reason
07:36:05 <akamaus> root element was absent
07:36:07 <codolio> It can't define [a,b..c].
07:36:14 <codolio> Only [a..b] and [a..].
07:36:24 <dmwit> codolio: eh?
07:36:31 <dmwit> [a,b..c] is enumFromThenTo a b c
07:36:32 <codolio> [a,b..c] uses arithmetic.
07:36:36 <codolio> Oh, it is?
07:36:36 <dmwit> no?
07:36:44 <codolio> Yeah, I guess you're right.
07:36:52 <codolio> :t enumFromThenTo
07:36:54 <lambdabot> forall a. (Enum a) => a -> a -> a -> [a]
07:37:01 <dmwit> :t \a b c -> [a,b..c]
07:37:03 <lambdabot> forall t. (Enum t) => t -> t -> t -> [t]
07:37:09 <dmwit> phew, it checks out =)
07:37:16 <codolio> I'm out of my mind, I guess.
07:37:32 <b__> oh lol, somehow I get highlighted on irc when someone types b..
07:38:00 <dmwit> I'm actually surprised it took this long to annoy you. =)
07:38:24 <codolio> Nobody uses that letter. Only a, x, y, z, f, g and h.
07:38:30 <codolio> Also i, j, k.
07:39:08 <b__> no wait wtf, not b..
07:39:14 <b__> 16:36 < dmwit> [a,b..c] is enumFromThenTo a b c
07:39:16 <b__> 16:36 < codolio> [a,b..c] uses arithmetic.
07:39:17 <b__> these yes
07:39:28 <Cale> b..
07:39:30 <b__> 16:35 < codolio> It can't define [a,b..c].
07:39:31 <nand`> given cata :: (f r -> r) -> Mu f -> r; any better way to implement cataM f = cata ((=<<) f . Traversable.sequence); cataM :: (Monad m, Traversable f) => (f r -> m r) -> Mu f -> m r
07:39:31 <b__> this no
07:39:31 <Cale> b..c
07:39:49 <b__> yes Cale that works >_>
07:41:27 <ClaudiusMaximus> arrgh, floatihg point.  overnight's rendering rendered useless because 1/0 = inf for Double, but 1/0 = nan for DoubleDouble, and nan comparisons are always False.  maybe next time i update the qd package i should add a note in the documentation that it breaks IEEE expectations :(
07:41:58 <EvanR> DoubleDouble?
07:42:12 <dmwit> I wonder if the Eq and Ord instances for Double really ought to just be removed.
07:42:12 <Cale> It's an order at Tim Hortons
07:42:39 * mcstar orders an IEEE DoubleDouble Double
07:42:40 <ClaudiusMaximus> EvanR: http://hackage.haskell.org/packages/archive/qd/1.0/doc/html/Numeric-QD-DoubleDouble.html
07:42:46 <nand`> “rendering rendered useless” hehe
07:42:49 <dmwit> (And replaced with functions of saner type, like equal :: Double -> Double -> Maybe Bool and compare :: Double -> Double -> Maybe Ordering)
07:43:06 <EvanR> "educated stupid"
07:43:33 <illissius-> dmwit: right. perhaps those should methods of separate classes
07:43:35 <EvanR> nand`: operators would be nice
07:43:41 <ClaudiusMaximus> and it should be (+) :: Double -> DOuble -> IO Double, due to FPU flags ?
07:43:49 <illissius-> (the second is a partial order right? not sure what the first is called)
07:44:05 <Cale> Did everyone see that thing about javascript  parseInt(1/0,19) == 18?
07:44:07 <thoughtpolice> i'm sort of wary of the Double Eq/Ord thing too. given that they don't really abide by the laws, i'm hesitent to think what would happen putting say, x :: Double as a map key
07:44:10 <mauke> Double -> Double -> Reader FPU Double
07:44:41 <thoughtpolice> it's likely that's been a bad idea forever, but i want the compiler to say so :(
07:45:07 <quicksilver> whether it's a bad idea depends on yoru Double impl, abstractly speaking, but it's definitely a bad idea in GHC.
07:45:07 <hpaste> mkramer pasted “how bad is transpose?” at http://hpaste.org/71200
07:45:18 <Cale> and parseInt(1/0,24) == 151176378
07:45:24 <quicksilver> using Double at all is quite often a bad idea.
07:45:27 <ClaudiusMaximus> > let nan = 0/0 :: Double in Data.Set.size . Data.Set.fromList . replicate 5 $ nan
07:45:30 <lambdabot>   Not in scope: `Data.Set.size'Not in scope: `Data.Set.fromList'
07:45:30 <illissius-> like everything there was a really long -cafe discussion about this at one point, but I don't remember what the resolution was (maybe there wasn't one)
07:45:31 <mauke> preflex: calc 24'nan
07:45:31 <preflex>  13511
07:45:32 <geekosaur> quicksilver, with IEEE doubles it's bad always.  see NaN
07:45:49 <geekosaur> (...and run away screaming)
07:45:50 <mauke> preflex: calc 24'inf
07:45:50 <preflex>  10935
07:46:10 <nand`> I'm not sure what's worse: data Double = NaN | ...  or data Bool = True | False | FileNotFound
07:46:12 <sipa> mauke: what is that?
07:46:19 <mauke> sipa: what
07:46:20 <EvanR> what should 0/0 floating point be then?
07:46:24 <sipa> 24'inf
07:46:24 <EvanR> > 0.0/0
07:46:26 <lambdabot>   NaN
07:46:34 <mauke> sipa: the number inf in base 24
07:46:35 <nand`> EvanR: ⊥
07:46:55 <dmwit> Double has the advantage of much better hardware support than Rational.
07:47:01 <EvanR> nand`: like, throws an exception or causes the simulation to halt?
07:47:10 <Cale> preflex: calc 24'infini
07:47:11 <preflex>  151176378
07:47:11 <thoughtpolice> i've seen the double-as-part-of-map thing in C++ code at least, which unsurprisingly required SSE2 codegen support for the necessary precision etc. otherwise it would just break. it's still broken though, because those values don't abide by strict weak ordering, due to NaN :(
07:47:15 <geekosaur> (the real problem with NaN is that you are technically supposed to preserve the invalid bit sequence, so a single NaN is actually incorrect)
07:47:15 <thoughtpolice> people should just not do that
07:47:31 <geekosaur> yet they all compare not equal to each other (regardles of bit sequence) or anything else
07:47:32 <ClaudiusMaximus> i don't know if exceptions are better than NaN for pure code with lazy evaluation :(
07:47:39 <geekosaur> it's just ... wtf
07:47:48 <nand`> EvanR: I figure an appropriate action would be something like whatever the hardware equivalent of an exception is (interrupt?)
07:47:56 <nand`> but in Haskell, it may very well be = undefined
07:48:24 <EvanR> nand`: well getting a huge array of NaN (due to a bug or bad model) in matlab is certainly useless
07:48:36 <EvanR> but seems better than crashing
07:49:25 <dmwit> If you're going to use infix operators, why would you always use them prefix like that?
07:49:38 <dmwit> (•) m $ (...) -- just, why?
07:49:51 <dmwit> m • ... -- so much clearer
07:50:04 <dmwit> Also, protip: you can use them infix to the left of an equals sign, too.
07:50:11 <dmwit> e.g. m • 1 = m
07:50:12 <nand`> EvanR: doesn't something similar happen when you divide an integer register by zero? I mean, most languages/programs trap these kind of things and fail gracefully
07:50:12 <EvanR> a + b + c + d ...
07:50:20 <EvanR> + [a,b,c,d,...]
07:50:30 <EvanR> nand`: right
07:50:32 <nand`> dmwit: ($) ((•) m) (...) -- clearly
07:50:43 <nand`> dmwit: otherwise it's inconsistent, too!
07:50:46 <dmwit> mkramer: Anyway, you should look into "repeated squaring" as an implementation technique.
07:50:47 <illissius-> class PartialEq a where (?==) :: a -> a -> Maybe Bool; class PartialEq a => PartialOrd a where (?<=>) :: a -> a -> Maybe Ord; class PartialEq a => Eq a where (==); class (Eq a, PartialOrd a) => Ord a where (<=>) etc.
07:51:04 <mkramer> dmwit: in an earlier incarnation, I was playing around with $! in the definition of ••
07:51:24 <illissius-> though that would make defining instances more annoying. maybe use DefaultSignatures in the partial ones (so you get the methods for free if you have an actual Eq/Ord)
07:51:25 <mkramer> so I moved the call to be prefix instead of infix
07:51:38 <mkramer> you're right
07:51:41 <EvanR> nand`: but dividing by zero is something you literally have to do stuff to avoid completely because theres no way to deal with it. with floating point you might end up operating very close to zero
07:51:42 <mkramer> now it should be infix, otherwise why bother
07:52:54 <EvanR> nand`: what about infinities?
07:53:07 <choi> i am a newbie and my question is whether it is easier to work with association lists, maps, or records when you're dealing with some like a typical `user` record in a web application
07:53:40 <dmwit> Association lists will never be the right choice in production code.
07:53:41 <nand`> EvanR: I figure infinities / NaNs due to near-zero should trigger some kind of floating point overflow exception
07:53:55 <nand`> that's what my intuition says
07:54:01 <dmwit> The choice between maps and records depends on whether you know statically what keys there will be and whether you need heterogeneous data.
07:54:03 <choi> dmwit: is that because of type safety benefits of the other alternatives?
07:54:08 <dmwit> No, speed.
07:54:17 <EvanR> nand`: interesting
07:54:21 <choi> dmwit: ok thank you that is  helpful
07:54:24 <mcstar> alist is lisp heritage
07:54:36 <nand`> EvanR: I'm pretty ignorant of hardware things though
07:54:41 <nand`> EvanR: like speed or efficiency
07:54:56 <dmwit> Association lists have the same type safety properties as Map.
07:55:01 <choi> dmwit: so you would use haskell records to represent records in a database?
07:55:09 <dmwit> yes
07:55:16 <choi> dmwit: thank you
07:55:17 <EvanR> nand`: well if your code probably crashes due to a condition doesnt matter how long it takes to do an interrupt
07:55:35 <nand`> EvanR: yeah, but I'm thinking about when it *doesn't* crash
07:55:48 <mcstar> it matters how often you check the fail-bits of float operations
07:55:51 <nand`> whether the constant bounds / overflow checking can slow down speed
07:56:17 <EvanR> nah that can be done with extra wires ;)
07:57:21 <mcstar> the runtime doesnt tell you if NaN happened
07:57:29 <mcstar> you have to compare it to itself
07:57:44 <EvanR> yeah were talking about hardware and interrupts to signal to the OS what happened
07:57:47 <mcstar> dvision by zero interrupts the problem, i think
07:57:57 <mcstar> but i never had that kind of error, only on purpose
07:58:02 <mcstar> but i cant remember what happened..
07:58:26 <mcstar> ofc, im talking about C, what a VM does, is irrelevant
07:59:29 <BluePeppers> I'm writing haskell bindings for a C library, using the FFI, and one of the types I am wrapping has a destructor. Is there any typeclass or something that I can implement to alert the haskell GC that this type is special?
08:00:02 <quicksilver> you can add finalizers to ForeignPtrs, BluePeppers
08:00:39 <BluePeppers> quicksilver, thanks, that's what I was looking for
08:04:28 <shirt> BluePeppers: also make sure to expose the destructor so that the programmer can free the resource early if he chooses
08:05:48 <ksf> is there a Text-based pretty printing library?
08:06:05 <BluePeppers> shirt, mightn't that cause problems as the destructor would then be run twice, once by the programmer, once by the haskell storage manager?
08:06:08 <mcstar> shirt: ah, seems strange hearing this, what if the code tried to access something that was freed?
08:06:44 <BluePeppers> I guess making destructors idempotent wouldn't be a bad thing though
08:06:44 <ksf> wlprint...
08:06:50 <shirt> BluePeppers: you need to rig it so that if the destructor is called manually then it deregisters from the "haskell storage manager"
08:07:47 <EvanR> idempotent...
08:07:49 <EvanR> idempotent...
08:08:17 <BluePeppers> EvanR, f(f(x)) = f(x)
08:08:21 <shirt> mcstar: then bad stuff will potentially happen, but then it's the programmers fault
08:08:33 <ksf> ...the one word you absolutely shouldn't use while having a discussion in a bar.
08:08:42 <shirt> here is how SDL does it: http://hackage.haskell.org/packages/archive/SDL/0.6.3/doc/html/src/Graphics-UI-SDL-Video.html#freeSurface
08:08:45 <EvanR> lol
08:09:10 <BluePeppers> That's quite reasonable
08:09:23 <EvanR> i have a jargon question which seems similar to idempotence
08:09:54 <ksf> destructuors start to get painful once you have nested destructors.
08:10:05 <EvanR> what about the situation where when you apply the operation multiple times, the state of the system either stays the same or advances toward its final correct state
08:10:15 <ksf> freetype is such a library.
08:10:24 <quicksilver> EvanR: monotonic
08:10:27 <ksf> you can free individual fonts, and you can free whole freetype instances.
08:10:37 <ksf> if you free a font after the instance has been collected, you crash.
08:10:44 <optimight> tgeeky: Which is the tool used to produce this?
08:10:59 <optimight> http://www.mgsloan.com/panopti2.png
08:11:06 <ksf> you can, however, free an instance whether or not you collected the font.
08:11:12 <quicksilver> EvanR: or, in related logical contexts "confluent" or "normalizing"
08:11:12 <EvanR> quicksilver: k its (not strictly) monotonic
08:11:26 <EvanR> k more words
08:11:33 <quicksilver> monotonic normally means non-strict monotonic, yes.
08:11:39 <quicksilver> but check for local definitions :)
08:11:45 <EvanR> there might be something like 'normalizing' floating around with regard to system programming
08:11:46 <quicksilver> you may also see "weakly monotonic"
08:12:13 <quicksilver> the original cfengine paper had lots of theory about systems programming and fixed points
08:12:16 <quicksilver> (I haven't read it, though)
08:12:44 <EvanR> if your setup script crashes half way through, running it again could either royally bork, or work, or do nothing
08:13:04 <EvanR> working / doing nothing would be ideal ;)
08:13:23 <quicksilver> looks like Burgess called it 'convergent', EvanR
08:13:27 <quicksilver> http://www.iu.hio.no/~mark/papers/feedback.pdf
08:13:29 <EvanR> ok
08:22:01 <EvanR> so for my mud, im thinking of having two programs, one handles the network connections, and one simulates the world and communicates with the first program. this way you can reload the world after editting the code without disconnecting anyone?
08:23:11 <mcstar> super
08:23:25 <EvanR> is there a saner way to do that? ;)
08:23:49 <EvanR> erlang? lol
08:24:59 <mcstar> damn, 'erlang' is alredy in use, otherwise erland would have answered that...
08:26:52 <quicksilver> EvanR: most MUDs just write all their FDs to a text file, reboot, and reload the text file.
08:27:00 <quicksilver> (most MUDs which support hot-reloads)
08:27:06 <zzzzzbogus> Is it discouraged to use Read typeclass in new code?
08:27:44 <geekosaur> not discouraged to use it at all, just discouraged to use it when a proper parser would be more appropriate
08:28:35 <zzzzzbogus> what about hGetContents and lazy IO in general?
08:28:48 <geekosaur> that's... harder
08:29:17 <geekosaur> lazy I/O can bite you, but it's standard and in some ways "baked in" to the standard libraries
08:29:40 <Nereid> use conduits :>
08:29:47 <geekosaur> use it but be aware of its shortcomings; if you need to worry about errors, for example, you may be better off using enumerator-style I/O
08:29:56 <geekosaur> (enumerators, conduits, pipes, ...)
08:30:25 <EvanR> quicksilver: yeah but im talking about changes to the server code, new feature, new etc
08:30:47 <EvanR> like a new spell or something
08:30:51 <geekosaur> given how most programmers don't bother to check for errors even in languages which make it possible (you can never see a read error with lazy I/O), you may well not care
08:31:34 <quicksilver> EvanR: yes. all of that.
08:31:50 <EvanR> whats an FD then
08:32:15 <quicksilver> EvanR: write FD numbers + what is connected to them to a file. re-exec yourself (which preserves FDs for the new binary). Load that file and remind yourself who is connected to which FD.
08:32:19 <quicksilver> file descriptor.
08:32:21 <quicksilver> (socket, in this case)
08:32:42 <EvanR> oh
08:32:50 <EvanR> i did not know that was possible
08:32:59 <Taneb> I think I've found a bug in GHC
08:33:02 <EvanR> when you exit the program seems like it auto disconnects everything
08:33:03 <quicksilver> I'm not really saying that your idea of two processes is *bad* per se- there are reasons to separate the network layer. However, the re-exec() method is slightly simpler, given unix semantics.
08:33:07 <mcstar> quicksilver: what does re-exec mean?
08:33:13 <Taneb> But I've only encountered it in a program that's already horrendously obfuscated
08:33:19 <quicksilver> mcstar: call exec() on your own binary
08:33:48 <quicksilver> EvanR: you need to turn off the CLOSE_ON_EXEC attribute (or whatever the correct name for that is)
08:33:54 <mcstar> quicksilver: like: if(halt) return exec(argv[0]) ?
08:34:06 <mauke> mcstar: without return
08:34:08 <geekosaur> FD_CLOEXEC in C parlance
08:34:20 <Taneb> Nevermind, it's a bug in my brain?
08:34:27 <mcstar> mauke: i was illustrating that the first instance will quite after the new returns
08:34:36 <mcstar> quit*
08:34:39 <mauke> mcstar: there is no "first instance"
08:34:45 <quicksilver> FD_CLOEXEC in http://pubs.opengroup.org/onlinepubs/009695399/functions/fcntl.html
08:34:53 <geekosaur> exec() overlays
08:35:00 <mcstar> oh
08:35:03 <geekosaur> it does not start a new process, it *replaces* the current one
08:35:13 <mcstar> i see didint know
08:35:36 <geekosaur> you keep all the resources you have (except memory which is reinitialized from the new executable, and any file descriptors marked close-on-exec)
08:35:50 <mauke> also, signal handlers
08:36:11 <mcstar> geekosaur: so you could save the data you want to keep in a struct too?
08:36:22 <geekosaur> mcstar, that's in memory so is reinitialized
08:36:33 <BluePeppers> Why does creating a ForeignPtr from a plain Ptr have to be in the IO monad? Because it modified the GC? it seems odd to me
08:36:55 <geekosaur> sgnal handlers:  if you set an actual function it wil be lost, because it's in memory.  if its SIG_IGN or SIG_DFL, its setting will be retained
08:36:56 <Peaker> BluePeppers, it makes a registration point
08:36:59 <mcstar> geekosaur: ah ok, i thought you can mark some memory too, similar to an dFS
08:37:01 <mcstar> FD*
08:37:32 <geekosaur> no, the entire memory map is reinitialized
08:39:07 <Peaker> all those that complained about bottle fonts being too large, you can now just Ctrl minus/plus
08:39:59 * mcstar admits he was one of those whiners
08:40:48 <Peaker> mcstar, it's ok, feedback is good otherwise I wouldn't show off here :)
08:41:18 <Nafai> Peaker: Do you have a screencast demonstrating how you use Bottle?
08:41:38 <Peaker> Nafai, not yet
08:42:35 <Peaker> Nafai, the threshold for a video is having type-driven editing and type-based completions, and we aren't there yet
08:43:39 * Nafai nods
08:45:00 <mcstar> Graphics.Gloss.Raster.Array seems to me very limited, you can provide a function that takes a float(time) and gives back an array to display
08:51:24 <nand`> Is there a term for converting a recursive ADT to a fixed point functor version using Mu?
08:53:02 <byorgey> nand`: that style is sometimes called "open recursion" or "two-level recursion/two-level types"
08:53:30 <quicksilver> also called "a nice idea in theory but a pain in practice"
08:53:31 <quicksilver> :-)
08:53:43 <byorgey> hehe, that too =)
08:54:17 <nand`> byorgey: I see
08:54:18 <ClaudiusMaximus> is that something like data FMaybe f a = FNothing | FJust (f a)  ?
08:55:11 <shachaf> ClaudiusMaximus: I don't think there's much point to the "a" there.
08:56:02 <ClaudiusMaximus> shachaf: probably a bad example, i'm not even sure what i mean
08:56:17 <byorgey> ClaudiusMaximus: Maybe isn't recursive to begin with so
08:56:49 <byorgey> ClaudiusMaximus: an example would be   data FList f a = Empty | Cons a (f a)
08:57:00 <Jesin> hmm
08:57:23 <shachaf> byorgey: Wouldn't it normally just be "data FList a f = Empty | Cons a f"?
08:57:24 <Jesin> could someone remind me why the convention is to put type constraints in instance declarations but keep them out of data/newtype declarations?
08:57:42 <MostAwesomeDude> Is it just me, or do these look like MaybeT and ListT?
08:57:51 <shachaf> Jesin: Because you ened them in the place they're used anyway.
08:57:53 <byorgey> oh, sure, shachaf's way is easier since you don't need a higher-order Mu
08:58:11 <Jesin> (for example, WrappedMonad does not have a Monad constraint in its declaration; why not?  :p )
08:58:12 <byorgey> but you can do List either way since it's parametric in the a.
08:58:27 <shachaf> Jesin: Because it doesn't do you any good.
08:58:49 <dmwit> Because constraints on types don't do what they oughta.
08:58:54 <dmwit> um
08:59:02 <dmwit> s/types/data declarations/
08:59:13 <shachaf> type List a f = Maybe (a,f)
08:59:25 <shachaf> Well, that doesn't actually work. :-)
08:59:35 <nand`> shachaf: why not?
08:59:57 <shachaf> Can't partially apply "type"s.
09:00:01 <nand`> oh
09:00:14 <Jesin> type List a = Maybe (a,List a)
09:00:14 <Jesin> does that work?
09:00:21 <nand`> Jesin: ‘type’s can't recurse either
09:00:23 <nand`> can they?
09:00:25 <Jesin> k
09:00:26 <Jesin> hmm
09:01:41 <nand`> I like my constructor name for rose trees: ‘Bud’
09:08:49 <EvanR> for a thread that just reads a socket, what exceptions should i handle in order to log an error then die
09:13:29 <optimight> whois /tgeeky
09:17:47 <Jesin> misplaced you the '/'
09:18:50 <mcstar> tipical hacker mistake
09:21:06 <dmwit_> wait
09:23:56 <optimight> Jesin: Are you pointing out to my mistake "/"?
09:24:18 <Jesin> yeps
09:24:56 <Jesin> probably was unnecessary but oops, didn't realize until later.
09:25:01 <optimight> Jesin:  "/" how does this related to hacking?
09:25:06 <mcstar> "misplaced you the '/' have" sounds like yoda
09:25:35 <optimight> mcstar: And what is yoda?
09:25:49 <mcstar> its a bio-yoghurt
09:25:53 <mcstar> similar to swartz
09:26:01 <mcstar> where the power comes..
09:26:13 <EvanR>  / is important to hackers because it leads to slashdot
09:26:23 <Jesin> optimight: it was mcstar who said "tipical hacker mistake"
09:26:34 <optimight> yes
09:26:46 <EvanR> i see your swartz is as big as mine
09:26:50 <mcstar> EvanR: which is ofc, a type, since hackers type ./ most frequently
09:27:02 <mcstar> typo
09:27:02 <optimight> mcstar: I am totally new to the field
09:27:16 <EvanR> lol @ typo of typo
09:27:27 <mcstar> optimight: these are the first lessons to Functional Programming, so pay close attention
09:27:58 <optimight> just was trying to know something about tgeeky ... because he has given some info about diagramming for Functional Programming
09:28:12 <optimight> mcstar:  I will definitely take care
09:28:27 <mcstar> i didnt say you should take care
09:28:38 <mcstar> im not your insurance agent
09:28:49 * hackagebot hps-kmeans 0.1.0.0 - A nice implementation of the k-Means algorithm. (RodrigoGadea)
09:28:59 <mcstar> but, keep low, the police might get you sooner than you think, with this public hacking of yours
09:29:10 <optimight> mcstar: yes ...but I don't want to be look a like a hacker
09:29:39 <mcstar> optimight: you could start with changing your nick to something less suspicious
09:30:04 <fmap> no links from hackagebot anymore?
09:30:24 <mcstar> guys, is it clear im joking?
09:30:37 <optimight> mcstar:  How does "optimight" seems suspicious?
09:30:47 <dmwit> To a native English speaker and somebody familiar with English cultural references, yes.
09:30:55 <dmwit> To optimight, probably not.
09:31:29 <mcstar> optimight: i could go on and on, but dont want to confuse you any more
09:31:59 <optimight> For me English is a third language
09:32:24 <optimight> mcstar: I think I will learn something ..if you please to interact further
09:32:26 <geekosaur> this is less about English the language than about English language geek culture
09:33:01 <EvanR> i dont get optimight
09:33:30 <mcstar> optimight: no, i cant go along with that, i might make an enemy of you, and im worried that you will hack my system some day
09:34:27 <optimight> mcstar: I'll never be a hacker ... not interested to become ..never  .. Just want to a good programmer
09:34:48 <mcstar> optimight: actually, you want to be a hacker
09:34:51 <EvanR> WOOSH
09:35:02 <mcstar> but not a black hat hacker
09:35:17 <mcstar> most of the folks here would call themselves a hacker
09:35:23 <mauke> that's racist, why should only white people hack hats?
09:35:53 <optimight> mcstar: I think ..good programmer has synonym "hacker"
09:35:56 <EvanR> any reference to anyones race who isnt white is racist
09:36:42 <mcstar> ok, so lets call the bad hackers, brown hat hackers, ok?
09:37:08 <mcstar> and the good hackers, egg-white hackers?
09:37:42 <optimight> mcstar:  classification of anything ... is really interesting to me
09:37:47 <mcstar> (ofc, we could simply call them bad/good hackers, but then, that is totally boring)
09:38:17 <dmwit> "bad" and "good" aren't precise.
09:38:29 <mcstar> dmwit: as opposed to black and white?
09:38:37 <EvanR> they are red team, we are blue team
09:38:39 <optimight> dmwit:  yes
09:38:41 <dmwit> It's not clear that they aren't referring to the skill of the hacker rather than the morality of the hacker.
09:38:49 <mcstar> dmwit: thats true
09:39:00 <optimight> dmwit: correct
09:39:02 <mcstar> dmwit: just like black or white could refer to their skin color
09:39:21 <dmwit> No, it's referring to the color of their hat.
09:39:32 <EvanR> its about honor
09:39:43 <mcstar> dmwit: no, its about black and white skin colored hat-hackers
09:39:43 <dmwit> And "white clothes" and "black clothes" have a much stronger cultural association with morality than "good" and "bad" do.
09:40:12 <mcstar> anyway, i agree, color makes it more evident
09:40:18 <EvanR> white clothes easily show stains and spills ;)
09:40:28 <mcstar> who came up with this racist interpretation anyway?
09:40:41 * mauke
09:41:02 <mcstar> mauke: you, purple!
09:41:33 <mcstar> (thats the color of your nick, in my client...)
09:42:03 <Jesin> build_freq_map = foldl' (\mp x -> Map.insertWith (+) x 1 mp) Map.empty
09:42:33 <dmwit> fromListWith (+) . flip zip (repeat 1)
09:43:06 <dmwit> fromListWith (+) . (`zip` repeat 1)
09:43:20 <Jesin> :t fromListWith (+) . flip zip (repeat 1)
09:43:22 <lambdabot> Not in scope: `fromListWith'
09:43:33 <Jesin> dimwit what is fromListWith?
09:43:34 <dmwit> :t M.fromListWith (+) . (`zip` repeat 1)
09:43:35 <lambdabot> forall a a1. (Num a, Ord a1) => [a1] -> M.Map a1 a
09:43:48 <Jesin> :t M.fromListWith
09:43:49 <lambdabot> forall a k. (Ord k) => (a -> a -> a) -> [(k, a)] -> M.Map k a
09:52:11 <optimight> Guide me how to get all desired modules installed in EMACS? Not able to understand: "Assuming you have placed the basic mode haskell-mode.el and the modules you want to use in the directory ~/lib/emacs/haskell-mode/, add the following command to your init file (~/.emacs): "
09:53:10 <optimight> I am using Ubuntu 12.04 LTS ... have installed EMACS and able to open .hs file with syntax highlighted
09:53:28 <SegFaultAX|work2> ?t liftM
09:53:29 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
09:53:35 <SegFaultAX|work2> :t liftM
09:53:37 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
09:58:17 <HugoDaniel> im trying to learn c2hs
10:00:40 <SegFaultAX|work2> Are there any books I can get that cover Hindley-Milner type inference?
10:01:00 <nand`> SK is just an Ω-algebra equipped with a set of equivalence rules, right?
10:01:08 <ksf> the state of haskell code generation is disappointing.
10:01:27 <nand`> (this alg having three operators: S, K of arity 0 and application of arity 2)
10:02:59 <HugoDaniel> ksf: code generation ?
10:03:34 <ksf> as in generate haskell code.
10:03:48 <ksf> there's not a single library that supports generating comments.
10:04:10 <nand`> Is there a term for a pair of operations f, g such that (f∘g) ≅ id; but not = ?
10:04:12 <ksf> (well, except from the quick-and-dirty one I improvised)
10:04:25 <nand`> in other words, ∀x f (g x) is isomorphic to x itself
10:04:34 <nand`> but not exactly equal
10:04:59 <ksf> well, possibly programmatica. But I can't be arsed to try and get that thing to compile.
10:05:07 <nand`> ’isomorphic up to isomorphism’ sounds a bit clunky
10:05:51 <codolio> nand`: That's 'equivalence' in an n-category, for an appropriate n.
10:06:20 <codolio> Equivalence of categories is isomorphic up to isomorphism, for instance.
10:06:28 <codolio> Which is equivalence in the 2-category of categories.
10:08:10 <Palmik> Hi gyus, is it possible to make ghc --make use local (cretaed by cabal-dev) environment or to use cabal-dev in a similar fashion to ghc --make?
10:10:21 <raphie> hey, do you guys think that Haskell could be run in Google's Native Client by calling their Pepper API with the FFI?
10:10:56 <MostAwesomeDude> Yes, but why would you wanna do NaCl? :c
10:11:17 <raphie> well I love haskell and I love webapps, so why not try both?
10:11:33 <MostAwesomeDude> Why do you have to have webapps do any work on the client?
10:12:00 <raphie> I don't know, it'd just be an experiment
10:12:32 <raphie> I'm going to be building my own distributed MapReduce just for funsies, and it'd be super cool if the workers could run in a browser
10:12:47 <Pete_> say
10:12:52 <Pete_> Hello?
10:13:00 <raphie> hi
10:13:30 <Guest22851> -help
10:13:33 <Guest22851> Hmmm
10:14:05 <MostAwesomeDude> raphie: Well, doing work in a browser sucks because you can't verify the correctness of the work unless you're doing specific work that is far quicker to verify than to compute.
10:14:20 <SegFaultAX|work2> MostAwesomeDude: Are you still working on your mc server?
10:14:41 <MostAwesomeDude> SegFaultAX|work2: Yes. :c
10:14:48 <MostAwesomeDude> raphie: In particular, you can't *trust* browsers.
10:14:57 <SegFaultAX|work2> MostAwesomeDude: Have you decided to rewrite it all in Haskell yet? :D
10:14:57 <raphie> MostAwesomeDude: I know it'd suck, I just wanna do it for shits and giggles
10:15:10 <MostAwesomeDude> SegFaultAX|work2: github.com/mostawesomedude/baskerville
10:15:20 <MostAwesomeDude> raphie: You have a strange definition of S&G. :3
10:16:37 <SegFaultAX|work2> MostAwesomeDude: I should have known. Awesome! Does it work with any recent releases of the client? (Do you even track the weekly releases?)
10:17:49 <MostAwesomeDude> SegFaultAX|work2: Bravo only ever tracks full releases. Baskerville's just a port of Bravo, same policies.
10:18:33 <MostAwesomeDude> Also no, we're still working on getting actual networking to be stable. Haskell lacks a strong general-purpose networking library, so it's slow going. Also I'm busy with Real Work. :c
10:19:02 <SegFaultAX|work2> MostAwesomeDude: Still, it's impressive how small this is.
10:19:38 <MostAwesomeDude> SegFaultAX|work2: Sure. Small code is small. It doesn't have all of Bravo's features, but it's certainly a lot smaller than everybody else.
10:21:32 <SegFaultAX|work2> MostAwesomeDude: I'm pleased to see that Mojang is unifying the server and client code at least.
10:21:49 <MostAwesomeDude> SegFaultAX|work2: Meh. I can't bring myself to be pleased with their code when it still sucks so hard.
10:22:43 <SegFaultAX|work2> MostAwesomeDude: So how did you learn the protocol exactly? Wireshark + decompiled bytecode?
10:23:30 <MostAwesomeDude> SegFaultAX|work2: Wireshark and patience; the original Bravo code was totally clean-roomed. I later cleaned it up based on the wiki.vg work and contributed to that.
10:23:45 <MostAwesomeDude> (If you wanna continue this, #mcdevs is a better channel.)
10:23:56 <SegFaultAX|work2> Oh yea, good point.
10:24:01 <MostAwesomeDude> So, question: Is there a way to construct Ada-style bounded integers?
10:24:15 <MostAwesomeDude> Preferably without data OneHundred = Zero | One |
10:24:17 <MostAwesomeDude> etc.
10:25:23 <byorgey> No. Because it's very difficult to statically check such things.
10:25:39 <byorgey> My understanding is that Ada implements those with various runtime checks.
10:25:46 <MostAwesomeDude> Largely.
10:26:09 <stepkut> doing it with runtime checks in Haskell is pretty easy
10:26:21 <byorgey> you can certainly make a newtype wrapper around Integer with "smart" constructors that do runtime checks.
10:26:54 <stepkut> newtype OneHundredInt = OneHundredInt { toInt :: Int }, and then implement all the number classes with bounds checking
10:27:08 <MostAwesomeDude> I think I'll just specify them as Word8 and then rolleyes.
10:27:45 <dmwit> Other options: type-level hackery can make an inefficient peano numeral plausible; TH can spit out the code for data OneHundred = Zero | One | ... and instances for you.
10:34:09 <saep> Is there an easy/short way to retrieve the precedence of an infix function at run-time? (like the last entry of :info in ghci)
10:34:12 <ion> data Nat = Zero | One | … | Infinity
10:34:45 <ion> saep: Why do you want that at runtime?
10:34:47 <dmwit> saep: At runtime? It's known statically, you can just write down the number...
10:36:43 <saep> I'm generating code and would have saved me some work. :D
10:37:22 <geekosaur> ghc is not a dynamic environment, so no, there are no convenient ways to do that kind of thing.  you can probably get it from the ghc api but convenient is not one of the design constraints on that
10:37:38 <ksf> if I don't process a bit of my data, I see mixed "Just" and "Nothing" values. when I replace all Nothings with Just 1 and all Just with Just 2 I only get Just 2's.
10:37:50 <ksf> veryly, something's bugged.
10:38:40 <saep> ksf: do you first replace the Nothings and THEN replace the justs? :)
10:38:52 <ksf> I do it in a single map.
10:38:53 * hackagebot cypher 0.4 - Haskell bindings for the neo4j "cypher" query language (SamAnklesaria)
10:38:55 * hackagebot cypher 0.5 - Haskell bindings for the neo4j "cypher" query language (SamAnklesaria)
10:39:31 <geekosaur> ksf: order still matters... if you do it exactly as you said then the Just 1 you created from the Nothing is immediately replaced with Just 2.  think about it
10:39:52 <geekosaur> ...better yet, show actual code since English descriptions are ambiguous
10:40:01 <ksf> yeah, I know. it's just that it's happening if it's the only processing I do.
10:40:38 <ksf> a minimal example would still be gigantonormic.
10:41:00 <ksf> well. SYB could be doing nasty things behind my back.
10:41:19 <ksf> ...I'm using everywhere
10:42:09 <geekosaur> it really isn't clear to me that this is some kind of behind your back thing.  what you described, if taken literally, would have exactly that result
10:42:41 <ksf> ...I don't think everywhere should or would process the same list twice.
10:42:55 <ksf> my data is a simple tree, it can't even get confused by cycles.
10:45:51 <latro`a> hello
10:46:11 <byorgey> hi latro`a
10:46:24 <latro`a> I'm new to guis in haskell, and attempting to make a scrabble-like program
10:46:29 <ksf> geekosaur, the literal interpretation of what I said is "I map a function once over the stuff". that means that every Maybe gets looked at once, which means the bug can't arise.
10:46:46 <latro`a> the gui bits could probably be used for a crossword program as well
10:46:47 <ksf> It's not like that hasn't crossed my mind, I first thought I was invoking the processing step twice.
10:46:50 <latro`a> and I'm wondering what gui lib to try
10:47:17 <applicative> saep: theres always something like:   run "ghci" ("-v0" : "-cpp" : "-w" :[]) (":i + ")
10:47:54 <byorgey> ksf: does 'everywhere' work top-down or bottom-up?
10:48:06 <ksf> There. I changed the type from working directly on lists on working on the list container and things work.
10:48:10 <ksf> byorgey, can do both.
10:48:18 <ksf> and didn't make a difference.
10:49:20 <byorgey> ksf: oh, yeah, I've been bitten by giving a list-processing function to a generic traversal before.  The problem is it applies it to ALL lists which are substructures, which includes all tails
10:49:42 <byorgey> so given the list [1,2,3,4] it will first transform that, then it will transform [2,3,4], then [3,4] etc.
10:49:54 <ksf> oh. yeah, that does make sense, in a perverted way.
10:50:02 <byorgey> indeed.
10:50:14 <saep> applicative: thanks, but i think i'll just "tuple it up"
10:50:24 <applicative> yes :)
10:50:38 <byorgey> there ought to be a way to say "don't apply to recursive substructures" or something
10:51:31 <Cale> You could always make it look for a newtype, I guess.
10:51:58 <Cale> latro`a: Maybe gtk2hs
10:52:09 <latro`a> I was trying to avoid direct contact with gtk2hs
10:52:17 <latro`a> was thinking of one of the wrappers around t
10:52:18 <latro`a> *it
10:52:21 <latro`a> but there are several
10:52:25 <ksf>     f (Enum n xs doc) = Enum n (h xs) doc
10:52:26 <ksf>     f x = x    <-- the whole wrapper function
10:52:31 <byorgey> there are wrappers around gtk2hs?
10:52:36 <latro`a> many
10:52:46 <Cale> There are a lot of little research projects and things
10:52:59 <ksf> or bigger research projects, like grapefruit.
10:53:15 <latro`a> "wrapper" may be giving them a little too much credit
10:53:18 <ksf> I find it still annoying that people are wasting time on binding to foreign toolkits.
10:53:28 <ksf> *valuable* time.
10:53:33 <latro`a> but they make haskell GTK code look less like C
10:53:34 <ksf> not just someone toying around.
10:53:48 <ksf> you can't hide the C in GTK.
10:53:53 <latro`a> not fully, no
10:54:01 <ksf> it's tailored towards C, it uses C kind of abstractions, therefore, it won't work out.
10:54:05 <latro`a> but they look a hell of a lot less C-y than native gtk2hs
10:54:16 <ksf> http://www.haskell.org/pipermail/haskell-cafe/2009-January/054434.html  have a rant
10:54:24 <ksf> wait, wrong link.
10:54:25 <byorgey> latro`a: can you give some examples of what wrappers you're talking about?
10:54:34 <ksf> http://www.haskell.org/pipermail/haskell-cafe/2009-January/054421.html   that one.
10:54:34 <geekosaur> so you wnt someone to do a Haskell GUI toolkit from the ground up?  that's one reeally big, hairy, smelly pony
10:54:47 <ksf> geekosaur, read my rant above.
10:55:05 <geekosaur> ksf, I could write such a rant.
10:55:08 <ksf> it's about drawing and layouting. the wrappers have to do composition etc, too.
10:55:42 <geekosaur> what I couldn't do is build the perfect Haskell GUI from the ground up avoiding all C libraries.  it's *possible*, but it's a whole lot of work that nobody is ever likely to do
10:55:46 <geekosaur> or maintain
10:55:57 <latro`a> I'm looking around and making sure I didn't misunderstand what I read before
10:56:03 <geekosaur> which is why you wrap a library that *is* being maintained by someone; it's a lot less work
10:56:10 <zachk> if it was haskell98 why would it need to be maintained :-/
10:56:15 <latro`a> I may have misunderstood, though
10:56:30 <ksf> it's a lot more work for the *users* to write custom widgets in C than to implement a layout engine in haskell.
10:56:36 <ksf> heck, use xmonad, done.
10:56:53 <latro`a> uh
10:57:16 <geekosaur> zachk, users evidently upgrade neither their language nor their hardware nor the widgets they use, etc., forever?
10:57:34 <latro`a> maybe I haven't looked over xmonad enough, but can xmonad even have buttons internal to windows?
10:57:36 <geekosaur> or fix bugs?  (becuase types are not going to be enough)
10:57:40 <ksf> the reason it's not been done yet is that the design space is *vast*. and that frp isn't ready for prime time yet, not to mention records.
10:57:56 <byorgey> latro`a: xmonad is a window manager, not a GUI library
10:57:59 <latro`a> yeah
10:58:00 <latro`a> I know
10:58:02 <latro`a> that's why I asked
10:58:13 <latro`a> (I'm on xmonad right now)
10:58:22 <byorgey> latro`a: I don't understand your question then.
10:58:22 <zachk> geekosaur: well I am just saying you would need to do much maintaining after awhile
10:58:23 <ksf> xmonad has a pure layouting core, that's why I mentioned it.
10:58:32 <latro`a> oh for just layout
10:58:34 <latro`a> k
10:58:45 <geekosaur> zachk, and I'm saying that is true only if your world never changes
10:59:00 <ksf> zachk, at least you're not dependent on upstream.
10:59:04 <zachk> people still use tk a bit
11:00:00 <geekosaur> whereas, in the world most of us live in, you don't need to make changes only if you want to stay right where you are forever.  no new GUI elements.  no new looks.  your world is frozen and increasingly *looks* like you stayed in the ancient past
11:00:06 <geekosaur> and feels like it
11:00:08 <geekosaur> and works like it
11:00:39 <geekosaur> "it works" but if nobody wants to use it it doesn't matter how well it works
11:01:00 <Rickasaurus> the idea of making gui structure inside of a programming language is the wrong way anyhow.  It's legacy.
11:01:01 <ksf> a proper GUI toolkit is flexible enough to allow users to implement widgets.
11:01:27 <geekosaur> sure, up to a point
11:01:28 <ksf> gtk can do that. do try it in gtk2hs.
11:01:54 <geekosaur> gtk2 is already deprecated, because there are things it is not flexible enough to do
11:02:04 <ksf> gtk is a monolithic toolkit, like most C ones... because C lacks the compositing power to support microlithic ones.
11:06:52 <Jesin> [14:01:22]	geekosaur	gtk2 is already deprecated, because there are things it is not flexible enough to do
11:06:54 <Jesin> huh.
11:07:14 <Jesin> I hadn't heard about that.
11:08:20 <geekosaur> gtk3 and gnome3 exist in large part because, while you can use them with wayland, they can't take advanatge of things wayland can do
11:09:09 <Cale> gtk 2 and gnome 2 are deprecated for working too well
11:09:10 <MostAwesomeDude> Are you sure they don't exist because toolkit and DE authors are fond of wankery?
11:10:07 <however> geekosaur: is there any truth to my vague impression that the gtk project is more steady and sensible than the wild-eyed, pie-in-the-sky gnome people?
11:14:38 <geekosaur> however, not really.  they have different focuses, certainly; gtk+ focuses on gimp development, which can be just as wild-eyed in different directions
11:15:43 <however> sad to hear ...
11:17:43 <shirt> what's the best way to write a function that lists all coordinates between two points, like this:
11:17:44 <shirt> ((1,0), (2,3)) => [(1,0),(1,1),(1,2),(1,3),(2,0),(2,1),(2,2),(2,3)]
11:18:00 <MostAwesomeDude> @hoogle range
11:18:00 <lambdabot> Data.Ix range :: Ix a => (a, a) -> [a]
11:18:00 <lambdabot> Data.Ix rangeSize :: Ix a => (a, a) -> Int
11:18:00 <lambdabot> Language.Haskell.TH.Syntax data Range
11:18:03 <kkyqqp> when I used to load ghc and my files it would say Main>, and now it says Prelude Main>
11:18:08 <kkyqqp> is there a reason it changed?
11:18:12 <MostAwesomeDude> :i Ix
11:18:14 <Cale> shirt: yeah, that already exists as part of the array library
11:18:26 <Cale> > range ((1,0),(2,3))
11:18:29 <lambdabot>   [(1,0),(1,1),(1,2),(1,3),(2,0),(2,1),(2,2),(2,3)]
11:18:32 <MostAwesomeDude> > range ((1, 0), (2, 3))
11:18:34 <lambdabot>   [(1,0),(1,1),(1,2),(1,3),(2,0),(2,1),(2,2),(2,3)]
11:18:38 <MostAwesomeDude> Agh, sniped.
11:18:59 <shirt> > range ((2,3),(1,0))
11:19:00 <lambdabot>   []
11:19:16 <shirt> what do i do if i need the reverse to work?
11:19:17 <ion> > (,) <$> [1..2] <*> [0..3]
11:19:18 <MostAwesomeDude> shirt: Ix is a type class for coordinates/indices.
11:19:18 <lambdabot>   [(1,0),(1,1),(1,2),(1,3),(2,0),(2,1),(2,2),(2,3)]
11:19:37 <MostAwesomeDude> So you should presumably sort your coordinates first.
11:19:39 <geekosaur> kkyqqp, sounds like it's being more accurate about what's in scope, or at least more closely reflecting what is in the source file's scope
11:20:11 <bgamari> How does one easily compile conduit Pipes returning (Maybe a)?
11:20:13 <geekosaur> (you want Prelude to be in scope, lots of things don't work if it isn't.  including things like numeric literals)
11:20:20 <MostAwesomeDude> > let l = [(1, 0), (2, 3), (2, 0)] in range (min l, max l)
11:20:21 <lambdabot>   No instance for (GHC.Arr.Ix ([(t, t1)] -> [(t, t1)]))
11:20:21 <lambdabot>    arising from a use...
11:20:50 <MostAwesomeDude> > let l = [(1, 0), (2, 3), (2, 0)] in range (minimum l, maximum l)
11:20:52 <lambdabot>   [(1,0),(1,1),(1,2),(1,3),(2,0),(2,1),(2,2),(2,3)]
11:20:58 <bgamari> e.g. Pipe ... (Maybe a) -> Pipe ... (Maybe a) -> Pipe ... (Maybe a)
11:21:02 <MostAwesomeDude> Derp, was still in Python-land.
11:21:33 <ion> ’Tis a dark and hostile place.
11:22:15 <bgamari> correction: How does one easily compose conduit Pipes returning (Maybe a)?
11:22:29 <however> kkyqqp: it shows you what modules are imported, more or less. it's just FYI. if you get tired of it, you can do ":set prompt something". if you put it a file called ~/.ghci, the set prompt command will be run every time ghci starts
11:22:29 <tgeeky> @tell optimight mgsloan's panopti (on github)
11:22:30 <lambdabot> Consider it noted.
11:23:09 <MostAwesomeDude> bgamari: You could use MaybeT IO a as your monad base.
11:23:38 <kkyqqp> cool, thanks!
11:23:43 <bgamari> MostAwesomeDude: I feel like there really should be a combinator to do this
11:23:56 <MostAwesomeDude> bgamari: I feel like there really should be a Real Networking Library. :3
11:23:57 * hackagebot digestive-functors 0.5.0.1 - A practical formlet library (JasperVanDerJeugt)
11:24:01 <MostAwesomeDude> But there isn't, so whatever.
11:24:04 <bgamari> MostAwesomeDude: Using xml-conduit this is an incredibly common need
11:24:06 <bgamari> heh
11:24:06 <bgamari> alright
11:31:08 <mcstar> how am i supposed to make a bitmap for gloss form a foreign pointer?
11:32:03 <optimight> tgeeky: thanks
11:32:03 <lambdabot> optimight: You have 1 new message. '/msg lambdabot @messages' to read it.
11:32:16 <optimight> @message
11:32:17 <lambdabot> Maybe you meant: messages messages?
11:32:29 <optimight> @messages
11:32:30 <lambdabot> tgeeky said 10m ago: mgsloan's panopti (on github)
11:34:37 <mcstar> wth
11:34:49 <mcstar> disregard my question, its right there
11:35:03 <however> is this correct? -- to extract the decimals after the "." in a Data.Fixed, the clearest way is to do (x `Data.Fixed.mod'` 1)
11:35:17 <hpaste> tgeeky pasted “trying to (finally) get zeroth to compile again -- segfault” at http://hpaste.org/71211
11:35:47 <tgeeky> can someone tell me what to do with this segfault?
11:35:52 <tgeeky> it's in a TH run :/
11:37:03 <geekosaur> you got derive to blow up?  fancy
11:37:16 <tgeeky> geekosaur: I know, right?
11:37:34 <tgeeky> Also, the head build of GHC comes with template-haskell 2.6.0.0, and not 2.7.0.0 ... which is weird
11:38:28 <tgeeky> even haskell-platform has 2.7
11:39:29 <pv2b> In the process of learning haskell, I've written myself a very simple prime sieve. (Boring, I know. But it's one of those "standard programs" I like to write when learning new languages.) I'd like to know if there's anything I've overcomplicated or could have done better or if it in general seems like a fairly sound design.
11:39:32 <hpaste> pv2b pasted “Prime sieve” at http://hpaste.org/71212
11:39:55 <pv2b> Oh, that's handy. hpaste shows me redundant brackets.
11:40:06 <pv2b> Is that a flag that's available to ghc or something?
11:40:15 <mcstar> "Yield the underlying ForeignPtr together with the offset to the data and its length."
11:40:16 <tgeeky> pv2b: it's from the package 'hlint' I think
11:40:31 <however> pv2b: it's a tool called hlint. you can get it via "cabal install hlint"
11:40:44 <mcstar> i dont get the offset here, if its a pointer already to the data, what kind of offset is this talking about?
11:41:09 <however> mcstar: what is that from?
11:41:22 <mcstar> ah, forgot, Data.Vector.Storable
11:41:28 <mcstar> .Mutable
11:41:29 <pv2b> I guess I'm kinda trying to write lisp - I studied that in an abortive attempt to actually try to "get" functional languages
11:41:37 <pv2b> so the parens look "natural" to me :P
11:42:14 <however> pv2b: don't worry, any excess parens don't hurt. if anything, they make the evaluation order absolutely clear
11:42:19 <mcstar> however: i want to pass that pointer as a pointer to a bitmap for gloss
11:42:31 <hpaste> pv2b pasted “Prime sieve - now with fewer parens!” at http://hpaste.org/71213
11:43:36 <pv2b> yeah, always a pair of parens too many than a pair too few
11:43:41 <pv2b> although too many can impede readability
11:44:02 <pv2b> this is actually more readable without the redundant parents
11:44:04 <pv2b> parens*
11:45:25 <mcstar> Parensal Control
11:46:44 <pv2b> Anyway. Is there anything there that I'm doing in an unneccessarilly roundabout way? Or some way I'm doing something that's not quite "good style"? I already know about the lack of type annotations.
11:49:46 <however> mcstar: i haven't worked with that library, but my guess is, you give it the base pointer (start of array/vector) and the index (offset) of which element you want. i'm no c expert, but i guess the equivalent would be basePointer[42], i.e. *(basePointer + 42)
11:49:49 <dmwit> It's not the most efficient algorithm ever, but looks fine.
11:50:24 <dmwit> Oh, I misread.
11:50:33 <dmwit> It should actually be fairly efficient, as these things go.
11:50:38 <mcstar> however: no, it gives me BACK the offset
11:50:49 <mcstar> as well as the pointer
11:50:54 <mcstar> and the length of the data
11:51:09 <pv2b> dmwit: yeah I tried to exploit lazyness in evaluation as far as I could :-) and try to put expensive calculations in "inner loops"
11:51:29 <dmwit> You might like to do something like takeWhile (\x -> x*x < n) instead of this current thing.
11:51:46 <however> mcstar: oh right. well i don't know. unsafeToForeignPtr and ...From... seem exactly symmetrical to me, as far as their types are concerned
11:51:53 <pv2b> i'll try it. see which one runs quicker.
11:52:24 <dmwit> I guess <= instead of <.
11:52:33 <mcstar> however: you imply, if i didnt make that vector from a pointer, the offset will be 0?
11:52:36 <mcstar> makes sense
11:52:51 <mcstar> (why am i pressing TAB on random words????)
11:53:46 <dmwit> pv2b: primeFactors can be improved a lot.
11:54:13 <dmwit> Though it doesn't matter, since you don't call it anywhere. =)
11:54:17 <alech> hi, can someone tell me where the "findWithDefault" function in the hoauth Twitter example comes from? If I tried to import it from the containers cabal Data.Map(.Lazy|Strict), I get a type error :(
11:54:44 <alech> (cf. https://github.com/dgvncsz0f/hoauth)
11:55:02 <pv2b> dmwit: it seems to run slightly quicker with the sqrt
11:55:03 <pv2b> w
11:55:03 <pv2b> hic
11:55:03 <pv2b> h
11:55:03 <pv2b> ma
11:55:04 <pv2b> ke
11:55:13 <pv2b> wait. what just happened there.
11:55:40 <pv2b> ah. I put my drink over on the enter key on the far side of the keyboard. oops.
11:55:44 <pv2b> anyway
11:56:17 <pv2b> it seems to run quicker with the sqrt than with the one you suggested. which makes sense. since you only have to compute (<= floor (sqrt (fromIntegral n))) once
11:56:37 <however> pv2b: looks pretty good to me :) congratulations. a small thing is that you can replace 'head' with pattern matching. it might be a good idea to even form a habit of doing that, because for empty lists, head gives a very inadequate error message without even a line number
11:56:37 <pv2b> compared to having to multiply in your inner "loop"
11:57:36 <pv2b> however: pattern matching. not sure I know what you mean just yet.... but I'll see if I can figure it out. hang on.
11:59:26 <dgvncsz0f> alech: https://github.com/dgvncsz0f/hoauth/blob/master/src/main/haskell/Network/OAuth/Http/Request.hs#L47
12:00:21 <NemesisD> i can't quite figure out the difference between catch and try
12:00:34 <nand`> I want an alarm clock that presents me with the type of a Haskell function (eg. that of various folds or other simple things) that I have to implement to disable the alarm clock
12:00:35 <however> pv2b: it'd be "where (factor:_) = primeDivisors n". "(x:xs) = thelist" destructs the list into first element x and the remaining list xs. "_" indicates "don't care about this"
12:00:47 <applicative> alech: http://hpaste.org/71215 <-- doesn't this work?
12:01:28 <applicative> oh i see dgvncsz0f alech wants theirs...
12:01:54 <hpaste> NemesisD pasted “Exception Handling” at http://hpaste.org/71216
12:02:17 <NemesisD> could someone take a look at that, i seem to be unable to catch mysql exceptions
12:02:18 <however> alech: try hayoo, it searches much of hackage (hoogle is more limited). http://holumbus.fh-wedel.de/hayoo/hayoo.html
12:02:21 <alech> dgvncsz0f: thanks :)
12:02:36 <alech> however: aw, good, didn't find it on hoogle
12:03:20 <applicative> hoogle gave him the more familiar one...
12:03:21 <monochrom> "catch" wants your exception handler. "try" gives you either exception or answer
12:03:53 <NemesisD> monochrom: so it seems like catch is what i want in this case, but it doesn't work. my program still crashes with  ConnectionError {errFunction = "query", errNumber = 1213, errMessage = "Deadlock found when trying to get lock; try restarting transaction"}
12:03:59 <dgvncsz0f> alech: your welcome.
12:04:05 <dgvncsz0f> you're
12:04:09 <fmap> alech: http://www.haskell.org/hoogle/?hoogle=findWithDefault+%2Bhoauth
12:04:24 <monochrom> are you importing Control.Exception?
12:04:38 <NemesisD> monochrom: yep. imported it as E
12:04:43 <fmap> you can use +package syntax to search in given package
12:04:52 <monochrom> what is the type of errNumber?
12:06:02 <NemesisD> monochrom: Int. the library i use doesn't actually export the constructor Connectionerror, just a few of the functions on it, one of which is errNumber :: Int
12:06:47 <NemesisD> http://hackage.haskell.org/packages/archive/mysql/0.1.1.4/doc/html/src/Database-MySQL-Base.html#MySQLError it looks like that function applies to 2 different constructors for the MySQLError type, but they are both int so i don't imagine thats an issue
12:06:48 <monochrom> I do not mean "errNumber e". I mean "errNumber" by "errNumber"
12:06:52 <mcstar> however: well, muy program didnt segfault... :)
12:07:10 <monochrom> surely the type has a "->"
12:07:32 <NemesisD> monochrom: it should be errNumber :: MySQLError -> Int
12:08:26 <NemesisD> yep, ghci confirms that
12:08:58 <monochrom> "retry _ = action" suppose action throws an exception, who catches it?
12:09:19 <however> NemesisD: you could perhaps try :load'ing that in ghci and doing "retriable $ ConnectionError { ... what you pasted above ... })" to check if it really gives "Just ()" (requires to make retriable toplevel)
12:09:48 <monochrom> "who watches the Watchmen?"
12:09:54 <NemesisD> monochrom: oh shoot. i think i need that to be retry _ = retryMysqlRecoverable action
12:10:13 <NemesisD> otherwise it will catch once and only once
12:11:03 <monochrom> that will catch all the exceptions you care. that will also create a lot of nesting and funny businesses about blocking exceptions. use tryJust
12:12:37 <monochrom> carefully read the section "Catching Exceptions"
12:12:55 <mcstar> i had to endure a rorschach test
12:14:08 <NemesisD> monochrom: won't i recurse anyways? i fail to see how that just doesn't make it worst
12:14:14 <monochrom> indeed, you are exactly going to "Furthermore it is possible to accidentally stay inside the implicit block by tail-calling"
12:14:28 <however> mcstar: "the problem is to calculate fibonacci numbers; what monads do you see in this?"
12:14:46 <monochrom> there is a big difference between "recurse while you're inside the handler" and "recurse while you're outside the handler"
12:14:47 <mcstar> Cont
12:15:20 <monochrom> tryJust gets you out of the handler asap. the handler is simply "return (Left e)"
12:15:39 <monochrom> anyway carefully read the section
12:15:55 * applicative feels somehow the @monochrom is some sort of ventriloquist imitating monochrom
12:16:11 <monochrom> oh! was forgetting that
12:16:15 --- mode: monochrom set -o monochrom
12:16:32 <pv2b> dmwit: what is it that's inefficient about primeFactor by the way? (i'll paste my current version in a minute)
12:16:39 <monochrom> but IMO only severely broken IRC software tells you all about my @monochrom
12:16:55 <dmwit> pv2b: Each time it tries to compute another divisor, it looks through the whole list.
12:17:15 <applicative> I would expect that the browser interface webchat.freenode is pretty broken
12:17:27 <dmwit> You can improve that by parameterizing the function on the list of primes; once you've found that a particular prime isn't a divisor, take it out of the list.
12:17:35 <monochrom> yes, and basically all text-mode IRC software under the sun
12:17:41 <dmwit> (Then have a top-level function that just passes the whole list of primes to the parameterized version.)
12:17:56 <hpaste> NemesisD annotated “Exception Handling” with “Exception Handling (annotation)” at http://hpaste.org/71216#a71217
12:17:57 <pv2b> dmwit: oh. I understand. is there a best practice for making a function "non-public" so to speak?
12:18:07 <dmwit> pv2b: Yes, use "where". =)
12:18:14 <NemesisD> monochrom: how about that?
12:18:36 <pv2b> dmwit: ah. and then set up an anomymous function just like the (\x -> x*x) you showed me earlier
12:18:38 <dmwit> And the convention in Haskell for naming the internal function is to call it either "go" or the same thing as the top-level one, but with a prime.
12:18:53 <dmwit> pv2b: What's the anonymous function for?
12:18:59 <monochrom> not sure about the indentation, but yes
12:19:00 <pv2b> in the where clause?
12:19:13 <mroman> where is something like function local scope
12:19:25 <mroman> foo x = bar x where bar x = x * x
12:19:25 <dmwit> pv2b: ?
12:19:34 <pv2b> oooh, i see how
12:19:38 <NemesisD> monochrom: thanks! i'll give it a *try* *badump-tss*
12:19:48 <pv2b> I was thinking something like foo x = bar x where bar = (\x -> x*x)
12:19:52 <pv2b> but that's a bit overcomplicated
12:19:55 <dmwit> topLevel = go primes where go (p:ps) n | n `mod` p == 0 = ... | otherwise = go ps n
12:20:00 <mroman> foo x = bar x where bar (x:xs) = xs
12:20:14 <mroman> where allows you to define functions like you would do on top level.
12:20:35 <mroman> foo x = bar x where bar 0 = 1; bar x = x / x; and such.
12:20:42 <mroman> (watch indentation)
12:20:54 <pv2b> okay, got it. thanks :)
12:23:51 <mightybyte> Is there a Lift instance for ByteString anywhere?
12:24:06 * hackagebot cypher 0.6 - Haskell bindings for the neo4j "cypher" query language (SamAnklesaria)
12:25:26 <Cale> mightybyte: You'd just unpack the ByteString
12:25:52 <mightybyte> And then convert Word8 to Int?
12:26:09 <Cale> mm... or Integer, I guess.
12:26:43 <Cale> There's no source representation of ByteStrings, so that's likely the best you can do.
12:26:48 <Taneb> I think http://hpaste.org/71201 is as finished as far as it'll go now
12:27:04 <Cale> Taneb: nice
12:27:10 <Taneb> :)
12:27:25 <Taneb> I've linked an earlier version of it before
12:28:18 <Taneb> When unsafeCoerce has the same type of id, is there any difference in performance?
12:29:47 <however> > let x = (1.12345 :: Fixed E6) in floor((x `mod'` 1) * (fromIntegral $ resolution x)) -- so, is this the most straightforward way ...?
12:29:49 <lambdabot>   123450
12:32:39 <jfischoff> If I have am using RWS monad transformer and my inner monad is Identity, can I achieve the same functionality using composed applicative functors?
12:32:54 <Cale> Taneb: I'm going to say no
12:33:14 <Taneb> Cale, I think you may be right
12:33:29 <Cale> Taneb: however unsafeCoerce is faster than map id
12:33:44 <pv2b> does x:xs match [1] as x=1 xs=[]?
12:33:46 <pv2b> or no?
12:33:53 <Cale> pv2b: yes
12:33:57 <pv2b> okay. thanks.
12:34:55 <mauke> > case [1] of x : xs -> (x, xs)
12:34:56 <lambdabot>   (1,[])
12:35:02 <mcstar> (xs/2)x(xs/2)
12:35:13 <however> > let (x:xs) = [] in 42 -- pv2b but be aware of this
12:35:13 <lambdabot>   42
12:35:25 <however> > let (x:xs) = [] in x -- sorry :-/
12:35:28 <lambdabot>   *Exception: <interactive>:3:4-14: Irrefutable pattern failed for pattern (x...
12:35:36 <however> ^^ that exception is what i wanted
12:35:43 <pv2b> okays. thanks.
12:36:10 <Taneb> Cale, thanks
12:38:18 <zachk> > "hey lambdabot are you there"
12:38:20 <lambdabot>   "hey lambdabot are you there"
12:39:54 <Cale> yeah, pattern bindings are irrefutable pattern matches, which means that they generate runtime errors when variables bound by non-matching patterns are evaluated
12:43:22 <dagano> hello...i am pretty new to haskell...and have a question.  is this a place for it?
12:43:26 <Taneb> Yes
12:43:36 <EvanR> thats your one allowed question
12:43:39 <EvanR> good day
12:43:42 <dagano> hahaa
12:43:43 <dagano> ok bye
12:44:07 * hackagebot plugins 1.5.2.2 - Dynamic linking for Haskell and C objects (JeremyShaw)
12:44:59 <monochrom> you are allowed a question every minute
12:45:04 <dagano> somefcn = xs = [x | x <- xs, y < [2..x-1], not ((x `mod` y) == 0)]
12:45:10 <dagano> why is this not a prime number finder?
12:45:16 <dagano> functional programming is HAAAARD
12:45:32 <monochrom> any programming is hard actually
12:45:48 <dagano> sure .. but oop is more intuitive for me maybe
12:45:51 <applicative> @type somefcn  xs = [x | x <- xs, y < [2..x-1], not ((x `mod` y) == 0)]
12:45:52 <lambdabot> parse error on input `='
12:45:59 <mauke> dagano: because it's a syntax error
12:46:09 <applicative> @type let somefcn  xs = [x | x <- xs, y <- [2..x-1], not ((x `mod` y) == 0)] in somefcn
12:46:10 <lambdabot> forall t. (Integral t) => [t] -> [t]
12:46:29 <dagano> i plug a list into it and get a messy list back
12:46:32 <dagano> in ghci
12:46:32 <applicative> > let somefcn  xs = [x | x <- xs, y <- [2..x-1], not ((x `mod` y) == 0)] in somefcn [1..20]
12:46:33 <lambdabot>   [3,4,5,5,5,6,6,7,7,7,7,7,8,8,8,8,9,9,9,9,9,9,10,10,10,10,10,10,11,11,11,11,...
12:46:52 <dagano> right.
12:47:05 <mauke> dagano: you can think of it as nested foreach loops
12:47:21 <monochrom> I am tired of prime finders. why are we perpetually stuck with the first 10 PE questions?
12:47:55 <dagano> this isn't an assignment or anything .. i guess that would be a common problem
12:48:06 <mauke> > let somefcn xs = do { x <- xs; y <- [2 .. x-1]; guard $ x `mod` y /= 0; return x } in somefcn [1 .. 10]
12:48:07 <lambdabot>   [3,4,5,5,5,6,6,7,7,7,7,7,8,8,8,8,9,9,9,9,9,9,10,10,10,10,10,10]
12:48:09 <codolio> People should start learning to program exclusively with programs that are novel to monochrom.
12:48:20 <mauke> > let somefcn xs = do { x <- xs; y <- [2 .. x-1]; guard $ x `mod` y /= 0; return (x, y) } in somefcn [1 .. 10]
12:48:22 <lambdabot>   [(3,2),(4,3),(5,2),(5,3),(5,4),(6,4),(6,5),(7,2),(7,3),(7,4),(7,5),(7,6),(8...
12:49:09 <mcstar> monochrom: obviously, ppl give up too soon, before they reach the more intersting ones
12:49:52 <dagano> or the beginning phase is the time to ask questions. . because you don't really have the tools to figure it out yourself
12:49:55 <mcstar> btw, saying functinal programming is hard cause your prime finder doesnt work is quite absurd
12:49:58 <dagano> i don't go to c++ forums
12:50:15 <dagano> btw i wasn't saying that BECAUSE it doesn't work .. .i was saying that because it is hard
12:50:19 <mcstar> why would that task be any bit easier in oop? in fact would be harder, and would mask the algoritm
12:50:22 <dagano> conceptually
12:50:45 <mcstar> dagano: quite wrong
12:50:52 <mauke> dagano: do you understand what my latest version is doing?
12:51:18 <dagano> mauke .. no .. i will take a look and try and unpack it
12:51:21 <dagano> thanks for the nelp
12:51:26 <dagano> (h)
12:51:32 <mauke> heh
12:51:33 <mauke> nen
12:51:42 <applicative> > let somefcn  x = [y| y <- [2..x-1],  ((x `mod` y) == 0)] ;  primes = filter (null . somefcn) in primes [1..100]
12:51:44 <lambdabot>   [1,2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97]
12:51:50 <mauke> 1!
12:51:56 <monochrom> a fair comparison: you rollback yourself to when you first learned oop or whatever it was you first learned, do the same PE back then
12:52:22 <applicative> mauke, sorry
12:52:28 <monochrom> (yes I'm pretty sure you knew of PE long after you have mastered oop, so it's an unfair comparison)
12:52:47 * nand` feels like going through PE but representing all of the numbers and structures using generalized two-level morphisms
12:52:51 <nand`> might as well be a good exercise
12:52:59 <nand`> isPrime :: Mu N -> Bool
12:53:28 <mcstar> nand`: im having the feeling, you had a substantial Aha! moment recently, correct?
12:53:42 <nand`> mcstar: yesterday iirc
12:53:50 <mcstar> :)
12:54:01 <applicative> shouldn't it be Mu Maybe -> Bool ?
12:54:03 <nand`> mcstar: the ‘Aha!’ moment was figuring out how ‘Mu’ was used to generalize catamorphisms/anamorphisms/etc.
12:54:04 <shirt> how can i drop the last two elements of a list, while still keeping everything lazy?
12:54:07 <dagano> thanks everyone for the help .. i will copy and paste the last 100 lines and read carefully..i can't think that quickly
12:54:18 <nand`> applicative: ‘N’ here is data N f = Z | S f; so yeah, Maybe works :)
12:54:39 <monochrom> I have been TA of 1st year programming students. I know for a fact that "sum up all the numbers in this array" is hard, in any paradigm.
12:55:10 <mauke> :t ap (zipWith const) (drop 2)
12:55:12 <lambdabot> forall b. [b] -> [b]
12:55:13 <dagano> master of empathy
12:55:24 <mauke> > ap (zipWith const) (drop 2) [1 .. 10]
12:55:26 <lambdabot>   [1,2,3,4,5,6,7,8]
12:55:30 <mauke> > ap (zipWith const) (drop 2) [1 .. ]
12:55:32 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
12:55:37 <nand`> mcstar: the inspiration was http://www.willamette.edu/~fruehr/haskell/evolution.html proving that haskell humor is useful for more than just laughs :P
12:55:44 <applicative> > let sm [] = 0; sm x xs = x + sm xs in sm [2,3,4,5]
12:55:45 <lambdabot>   Equations for `sm' have different numbers of arguments
12:55:45 <lambdabot>    <interactive>:1:4...
12:55:46 <EvanR> > sum [1,2,3,3,4,5,65,8,6,0,5,4,3,3]
12:55:47 <lambdabot>   112
12:55:51 <EvanR> easy in haskell ;)
12:55:55 <applicative> > let sm [] = 0; sm (x :xs) = x + sm xs in sm [2,3,4,5]
12:55:56 <lambdabot>   14
12:55:58 <mauke> EvanR: that's not an array
12:56:50 <EvanR>  > sum . toList
12:56:53 <EvanR> \o/
12:57:03 <mcstar> where the array?
12:57:07 <mcstar> s
12:57:11 <EvanR> you provide it
12:57:15 <mcstar> you do
12:57:17 <mcstar> :)
12:57:25 <Taneb> monochrom, re: summing arrays, Data.Foldable.sum
12:57:59 <monochrom> of course, replace "array" by "list" if you like. doesn't change the essence of your loss of virginity. inventing your first loop or recursion is hard
12:58:03 <nand`> sum0 = 0; sum1 = id; sum2 = uncurry (+); sum3 (x,y,z) = x+y+z
12:58:15 <nand`> fixed length arrays
12:58:24 <mauke> monochrom: not for me
12:58:26 * jfischoff remembers how confusing his first for loop was
12:58:36 <Taneb> monochrom, I see what you're saying
12:58:37 <EvanR> monochrom: i havent written a loop or a recursion in months
12:58:39 <mauke> monochrom: I wrote fibonacci programs before I had my first computer
12:58:41 <EvanR> to do my job
12:58:57 <mauke> ok, I didn't understand loops
12:59:00 * nand` remembers his first iterative summing function w/ TCR
12:59:02 <mauke> but I understood GOTO
12:59:13 <monochrom> hahaha
12:59:18 <EvanR> i remember only having goto and inventing subroutines
12:59:32 <Taneb> I don't remember my first loop
12:59:36 <mauke> also, the $@#!* book didn't mention ELSE
12:59:37 <Taneb> I can tell you what language it was in
12:59:45 <nand`> I remember losing my algorithmic virginity to QBASIC as a kid. It was messy, but I succeeded in getting addicted for life.
12:59:46 <Taneb> Visual Basic 2005.
12:59:49 <Taneb> I've came a long way
12:59:57 <Taneb> Since... 2006? 2007?
13:00:05 <mauke> I read a book about BASIC
13:00:13 <mauke> the computer it described didn't have an OS
13:00:17 <nand`> must've been in 2003 or so for me
13:00:19 <mauke> or a hard drive
13:00:20 <monochrom> some inferior versions of BASIC did not have "else"
13:00:48 <mauke> ah, ok
13:00:54 <nand`> who needs else? just negate the conditions :P
13:00:57 <mauke> it had FOR/NEXT and WHILE/WEND, though
13:01:04 <mauke> nand`: no, you just need more GOTOs
13:01:11 <nand`> good point
13:01:30 <mcstar> monochrom: you know what was hard? wo programming experience writing my first program that drew pixels in a window, using the windows api
13:01:47 <nand`> I don't remember much about GOTOs. That knowledge has effectively been blacked out in my brain. Maybe that's why I'm finding CPS so confusing?
13:02:06 <mcstar> or, trying to make debian recognize my videocard in 2004, wo knowing wtf X was
13:02:07 <monochrom> anyway, I don't think there is a conflict between "1st-year homework makes you write loop/recursion" and "your job doesn't". you can lament on the deviation between education and industry without end, 1st-year homework is hardly the only example...
13:03:05 <applicative> > let sumarray  = sm . elems ; sm [] = 0; sm (x :xs) = x + sm xs ; arr = listArray (1,20) [1..20] in sumarray arr
13:03:07 <lambdabot>   210
13:03:08 * twanvl last used a goto 8 days ago
13:03:11 <mcstar> ok, i read back, those are hard also..
13:04:16 <applicative> summing an array is easy, you just need to translate the array to a more appropriate data structure
13:04:37 <mcstar> i remember, reading the Delphi documentation, object pascal, my english was pretty bad at those days, left a scar somewhere...
13:05:06 <hbT_> I just started learning Haskell. I can't figure out what's wrong with this:  mylength [] = 0 mylength (x:_) =( mylength x ) + 1. I can get similar constructions to work, but for some reason this doesn't.
13:05:17 <Nimatek> Delphi is still popular in some Russian universities, or so I hear.
13:05:23 <mauke> > let summa(i, xs) = case compare (length xs) i of GT -> (xs !! i) + summa(i + 1, tail(xs)); _ -> 0 in summa(0, [2, 2, 3])
13:05:26 <lambdabot>   5
13:05:39 <shachaf> hbT_: x isn't a list.
13:05:45 <applicative> > let mylength [] = 0; mylength (_:x) =( mylength x ) + 1
13:05:46 <lambdabot>   not an expression: `let mylength [] = 0; mylength (_:x) =( mylength x ) + 1'
13:05:57 <mcstar> Nimatek: it was at the end of highschool, i was just interested in computers
13:05:57 <applicative> > let mylength [] = 0; mylength (_:x) =( mylength x ) + 1 in myLength "hi"
13:05:59 <lambdabot>   Not in scope: `myLength'
13:06:05 <applicative> > let mylength [] = 0; mylength (_:x) =( mylength x ) + 1 in mylength "hi"
13:06:07 <lambdabot>   2
13:06:15 <applicative> pardon moronic spam.
13:06:19 <monochrom> your camel case habit got in the way
13:06:20 <mauke> > ((sum .) . 1) "hi"
13:06:22 <lambdabot>   No instance for (GHC.Show.Show (f a))
13:06:22 <lambdabot>    arising from a use of `M7327637187...
13:06:22 <hpaste> pv2b pasted “Prime sieve with better(?) factorizer” at http://hpaste.org/71220
13:06:26 <hbT_> shachaf: but things like elementat (x:_) 1 = x;   elementat (_:xs) k = elementat xs (k -1) work for me.
13:06:33 <pv2b> dmwit: there we go. was that something like that you had in mind?
13:06:35 <applicative> hbT_: you reversed the _:x
13:06:47 <shachaf> hbT_: OK, but that thing is not like the other thing.
13:06:52 <applicative> hbT_: or _:xs as textbooks write
13:06:55 <hbT_> Oh, indeed.
13:06:57 <shachaf> hbT_: mylength's argument is a list.
13:07:04 <mauke> > (sum . (1 .)) "hi"
13:07:06 <shachaf> hbT_: You're not passing it a list, you're passing it an x.
13:07:07 <lambdabot>   2
13:07:11 <applicative> hbT_: otherwise it is good
13:07:37 <hbT_> Where can I find detail on using arguments of the form (x:_) and (_;x)?
13:07:45 <mcstar> ; nono
13:07:46 <nand`> mauke: times like these makes me wish :. = flip (.:)
13:07:50 <shachaf> > fmap fmap fmap sum fmap 1 "hello"
13:07:51 <lambdabot>   5
13:07:52 <nand`> wait
13:07:56 <nand`> that's not what I wanted
13:07:56 <hbT_> I just picked it up from an example I saw, and I'd like to learn some more.
13:07:59 <shachaf> hbT_: The definition of [], in that case.
13:08:06 <monochrom> good haskell tutorials cover x:_ and _:x and x:y
13:08:08 <shachaf> hbT_: But really you should read an introduction to Haskell. :-)
13:08:16 <nand`> f :. g = f . (g .)
13:08:24 <applicative> hbT_: just right (first,rest) and figure out which you didn't need on the right hand side later
13:08:34 <mauke> applicative: double fail :-(
13:08:35 <nand`> you mean (first:rest)
13:08:37 <applicative> just write that
13:08:38 <mauke> and write
13:08:50 <applicative> man, yes.
13:08:59 <hbT_> "Learn you a haskell" hasn't covered this kind of argument yet. Will it get there eventually?
13:09:13 <shachaf> hbT_: Probably, yes. It's an important part of Haskell.
13:09:25 <applicative> hbT_: I will write nonsense to assist you, this will attract others to give correct assistance. It's a rather indirect form of explanation
13:09:48 <coppro> :t fmap fmap
13:09:49 <EvanR> hbT_: youre talking about pattern matching, not necessarily arguments
13:09:49 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f, Functor f1) => f1 (a -> b) -> f1 (f a -> f b)
13:09:53 <applicative> hbT_: its the same as (x:xs)
13:09:58 <coppro> :t fmap fmap fmap sum
13:10:00 <lambdabot> forall (f :: * -> *) b (f1 :: * -> *). (Functor f, Functor f1, Num b) => f (f1 [b]) -> f (f1 b)
13:10:01 <mcstar> @let fap = fmap
13:10:02 <lambdabot>  Defined.
13:10:07 <mcstar> for your convinience ^^
13:10:10 <shachaf> applicative: Even more indirect is just not to write the nonsense in the first place. :-)
13:10:13 <mcstar> e
13:10:26 <monochrom> x:_ and _:y are special cases of x:y
13:10:28 <shachaf> That way people can write the nonsense more efficiently.
13:10:44 <EvanR> (a,b) (_,b) (a,_) (_,_) ;)
13:10:48 <shachaf> The non-nonsense, that is.
13:10:50 <shachaf> @undefine -- mcstar: Come on.
13:10:55 <applicative> shachaf: it wasn't really nonsense just a mass of typing errors, you  try doing without a space bar
13:11:14 <mauke> @let a ==== b = reads (show a) == [(b,"")] || reads (show b) == [(a,"")]
13:11:14 * applicative torched his spacebar in the middle east
13:11:14 <hbT_> I see. So you can write something like: myfunction (x:y), and then do stuff with the x and y, where x is the first element in the list and y is a list. But if you never actually use y, you can just use the underscore?
13:11:16 <lambdabot>  Defined.
13:11:24 <EvanR> Nothing    Just _    Just x
13:11:27 <mauke> hbT_: right
13:11:37 <hbT_> Excellent, thank you.
13:11:43 <monochrom> you can use tab instead of space bar
13:11:51 <shachaf> hbT_: Yes, _ just means you're not giving it a name.
13:11:59 <applicative> hm, monochrom good idea
13:12:53 <applicative> no that wont work
13:12:54 <nand`> note that (x:y) is just a special case of (F x y), here ((:) x y)
13:13:05 <nand`> but this is probably uninteresting to you
13:13:25 <applicative> >  let f ((:) x y) = x in f "hi"
13:13:27 <lambdabot>   'h'
13:13:35 <nand`> it just find comments like these motivating because they show that “no, this doesn't just work for lists”
13:13:40 <nand`> that's the beauty of haskell - everything is generalized
13:13:43 <applicative> >  let f ((:) x _) = x in f "hi"
13:13:43 <nand`> or generalizable
13:13:44 <lambdabot>   'h'
13:13:50 <nand`> I just find*
13:14:30 <applicative> >  let  f ((:) _ _) = "Not empty" in f "hi"
13:14:32 <lambdabot>   "Not empty"
13:14:56 <applicative> >  let  f ((:) _ _) = "Not empty" in f ""
13:14:58 <lambdabot>   "*Exception: <interactive>:3:5-29: Non-exhaustive patterns in function f
13:15:30 <hbT_> So it's true Haskell has no variables, right? Anything you set stays fixed. So how would someone do something like (and this is a stupid example, just to illustrate my point) keep score in a video game?
13:15:33 <monochrom> hmm, so how are you entering spaces?
13:16:04 <Botje> hbT_: you constantly pass it around
13:16:13 <monochrom> see my http://hpaste.org/52480 example for a small stateful game
13:16:17 <nand`> hbT_: haskell has ‘variables’, though the meaning of that term is overloaded and its usage disputed
13:16:20 <mcstar> hah, at last, someone agrees with me on 'no variables'
13:16:21 <mauke> hbT_: it has variables. they just don't change
13:16:42 <monochrom> we will spend the next hour debating the definition of "variable"
13:16:53 <nand`> hbT_: for example f x = x -- arguably x here is a variable; every time you apply something to f the ‘x’ takes on a different meaning in that context
13:16:55 <nand`> yes
13:16:57 <nand`> we will
13:17:01 <nand`> but, more to the point; what Botje said
13:17:03 <Cale> Haskell has variables
13:17:17 <monochrom> well I also posted an example
13:17:26 <EvanR> > (\x -> x + 1) 5
13:17:26 <hbT_> Thanks monochrome.
13:17:27 <lambdabot>   6
13:17:30 <nand`> f score x = f score' x' where score' = ...; x' = ...; -- the “simplest” way to pass around score
13:17:33 <EvanR> variables ;)
13:17:36 <peteretep> Java's strings are also immutable
13:17:41 <Cale> It's just that not every variable is always referring to a mutable cell
13:17:49 <nand`> for your convenience, your ‘mylength’ function rewritten using iterative style like this:
13:18:06 <EvanR> hbT_: writeIORef ;)
13:18:06 <Cale> > map (\x -> x + 1) [1..10]
13:18:07 <lambdabot>   [2,3,4,5,6,7,8,9,10,11]
13:18:20 <Cale> x seems to be varying quite nicely
13:18:36 <nand`> > let myLength' (n,[]) = n; myLength' (n,_:xs) = myLength' (n+1, xs); myLength xs = myLength' (0, xs) in myLength "hi"
13:18:38 <lambdabot>   2
13:18:44 <nand`> --^ hbT_
13:18:50 <EvanR> Cale: variable as in 'global variable' ?
13:19:06 <monochrom> that x is local. I don't consider it varying. in fact I don't consider it existent to begin with
13:19:13 <nand`> hbT_: replace ‘n’ in my example by ‘score’ in your example
13:19:26 <hbT_> I se.
13:19:28 <hbT_> *see
13:19:55 <nand`> hbT_: mind that this is very primitive and; as you'll find to be a trend in Haskell, has been abstracted, generalized, taken care of and repackaged for your convenience
13:20:18 <monochrom> local stuff is hidden implementation detail. I thought we long learned that hidden implementation detail is to be relied upon
13:21:30 <EvanR> > sum [1,2,3,4]
13:21:32 <lambdabot>   10
13:21:33 <monochrom> err, is not to be relied upon
13:21:34 <EvanR> more magic
13:22:11 <shachaf> Cale: Point-free Haskell doesn't have variables!
13:22:21 <Cale> shachaf: That we can agree on
13:22:33 <Cale> monochrom: Clearly x exists, syntactically
13:23:14 <faen> I'm wondering why LYAH uses the name xxs for a nested list. xss would make more sense to me
13:23:15 <monochrom> you can't even call it x
13:23:18 <faen> what is commonly used?
13:23:28 <shachaf> faen: "xss" is more common, I think.
13:23:32 <nand`> I use ‘xss’
13:23:40 <nand`> the rule is: ‘s’ for plurals
13:23:48 <nand`> ‘xxs’ for me would be [(x,x)]
13:23:49 <faen> that's what I thought
13:24:03 <monochrom> perhaps it was a typo
13:24:03 <Cale> faen: yeah, I'd use xss for a nested list, and xxs@(x:xs) occasionally when I want to name the whole list in addition to the first element and tail
13:24:32 <Cale> > let xxs@(x:xs) = [1,2,3,4] in (xxs, x, xs)
13:24:34 <lambdabot>   ([1,2,3,4],1,[2,3,4])
13:24:40 <nand`> I tend to use very different names for as-patterns to avoid confusion
13:24:44 <nand`> like l@(x:xs)
13:24:47 <nand`> l for ‘list’
13:25:13 <nand`> but usually I won't use as-patterns when I have fields named too, so it's something like x@(Just _)
13:25:42 <faen> Cale: I see
13:26:07 <faen> I just figured any typo on the second page of LYAH would have been corrected by now
13:26:59 <nand`> well, it hardly qualifies as a typo
13:27:18 <nand`> since it's still α-equivalent to the “correct” version
13:27:24 <parcs`> xss, xxs, does it matter? :)
13:27:27 <nand`> and it's not an english word or anything that's obviously incorrect
13:27:47 <hpaste> pv2b pasted “Prime sieve - broken type signatures” at http://hpaste.org/71223
13:28:18 <faen> fair enough. I just found it confusing because it made me question what xs is supposed to mean in the first place
13:28:26 <pv2b> What I just pasted won't build for me. Something about "illegal overloaded type signatures". But I don't see myself overloading any types?
13:28:53 <nand`> maybe ‘xxs’ refers to ‘nested Xs’
13:29:14 <monochrom> which line?
13:29:47 <pv2b> hang on. I'll add the compile-time error message.
13:29:48 <nand`> (since they can obviously be flattened to a single plural, but the ‘xx’ emphasizes that they have nested structure)
13:29:53 <pv2b> to the paste.
13:31:08 <hpaste> pv2b annotated “Prime sieve - broken type signatures” with “Prime sieve - broken type signatures (annotation)” at http://hpaste.org/71223#a71224
13:31:11 <pv2b> Done.
13:31:34 <pv2b> Oops. I put the comment in the wrong place.
13:31:41 <ocharles> :t (<=<)
13:31:43 <pv2b> but it's in there :)
13:31:43 <lambdabot> forall b (m :: * -> *) c a. (Monad m) => (b -> m c) -> (a -> m b) -> a -> m c
13:31:46 <hbT_> How does this look? palindrome [] = True; palindrome a = if length a ==1 then True else if (head a == last a) then palindrome ( tail(init a) ) else False.
13:32:09 <hbT_> It seems to run ok.
13:32:27 <Saizan> pv2b: add a signature to primes
13:32:51 <pv2b> something like primes :: (Integral i) => [i]  -- right?
13:33:03 <Saizan> yeah
13:33:10 <monochrom> oh! I see. give primes a type sig too. primes :: (Integral i) => [i]
13:33:23 <pv2b> that works better. thanks :)
13:33:46 <hpaste> pv2b annotated “Prime sieve - broken type signatures” with “Prime sieve - broken type signatures (annotation)” at http://hpaste.org/71223#a71225
13:34:21 <pv2b> i made a rewrite of primeFactors by the way. should be more efficient than my last attempt.
13:35:46 <dfjkdfjlka> -
13:36:51 <pv2b> is there a built in function like mul' a b = a*b ?
13:36:56 <mauke> yes
13:36:57 <nand`> pv2b: yes
13:36:58 <mauke> (*)
13:36:59 <nand`> pv2b: *
13:37:22 <dmwit> pv2b: That was just what I had in mind.
13:37:34 <monochrom> > let f = (*) 4 in [f 1, f 2, f 3]
13:37:35 <lambdabot>   [4,8,12]
13:37:42 <geekosaur> pv2b, any infix can be used as a prefix by wrapping in parentheses and any prefix can be used as infix by wrapping in backticks
13:37:47 <pv2b> i see.
13:37:55 <pv2b> > foldr (*) [2,2]
13:37:57 <lambdabot>   Overlapping instances for GHC.Show.Show ([[t]] -> [t])
13:37:57 <lambdabot>    arising from a us...
13:37:59 <monochrom> > 33 `div` 3
13:38:01 <lambdabot>   11
13:38:07 <dmwit> > foldr (*) 1 [2,2]
13:38:08 <lambdabot>   4
13:38:08 <geekosaur> (but this does not nest:  `(*)` is illegal, not a fancy way to write *)
13:38:22 <pv2b> hm. what does the 1 do?
13:38:23 <dmwit> > foldl' (*) 1 [2,2] -- probably what you want most of the time
13:38:25 <lambdabot>   4
13:38:27 <dmwit> pv2b: base case
13:38:31 <nand`> pv2b: starting value
13:38:34 <pv2b> ah.
13:38:35 <dmwit> > foldr f z [w,x,y]
13:38:36 <lambdabot>   f w (f x (f y z))
13:38:42 <monochrom> look for foldr1 too
13:38:43 <nand`> > foldr1 (*) [2,2]
13:38:45 <lambdabot>   4
13:38:47 <mauke> > foldr (*) 1 [2,2] :: Expr
13:38:48 <lambdabot>   2 * (2 * 1)
13:39:07 <pv2b> i see. :-) thank you.
13:39:08 <dmwit> Don't use foldr1 with functions that have a unit, that's just... dirty.
13:39:12 <daniel_-> dear god why doesnt this regexp pattern work! GAH "(?<=a).+$"
13:39:24 <shapr> dmwit: We need a dirty Haskell contest :-)
13:39:26 <mauke> daniel_-: because it's disgusting
13:39:39 <mauke> daniel_-: what are you trying to do?
13:39:39 <pv2b> is there any way to do unit testing in haskell by the way? seems like the language would be well suited for it
13:39:47 <geekosaur> regexp pattern where?  which module are you using?
13:39:54 <shapr> pv2b: Yes! HUnit exists, but QuickCheck is better than unit testing.
13:39:54 <daniel_-> i need to catch the text that matches after "-> "
13:40:01 <nand`> hmm
13:40:02 <monochrom> I love foldr1
13:40:03 <daniel_-> ?<= doesnt seem to work :(
13:40:03 <lambdabot> Maybe you meant: . ? @ bf do ft id pl rc v wn
13:40:06 <geekosaur> (that will only work with one of the pcre regex packages)
13:40:07 <pv2b> QuickCheck. i'll take a look. is it in the standard libraries?
13:40:09 <dmwit> pv2b: You might like QuickCheck if you're open to new ideas, or hunit if you literally want unit testing.
13:40:12 * nand` wonders why Num n => Product n/Sum n don't have num instances
13:40:16 <dmwit> not standard, I think
13:40:22 <dmwit> but "cabal install QuickCheck" =)
13:40:27 <shapr> pv2b: On the good side, you can combine both of those with one of the hackages .... test-framework I think?
13:40:34 <dmwit> nand`: Really dumb, isn't it??
13:40:42 <nand`> so much noise associated with those
13:40:51 <nand`> that the “inelegant” versions are often more concise and clear than the monoidal ones
13:40:53 <shapr> pv2b: QuickCheck is generative testing.. you code up a property that should always hold true, when it fails it gives you back the value that failed.
13:40:58 <monochrom> the only legitimate objection IMO is "what about the empty list", but even that objection is illegitimate IMO. if I use it, I really give it a non-empty list
13:41:00 <daniel_-> im using text.regex.posix
13:41:01 <geekosaur> also that seems like it might not be the best way to phrase your regex; what exacty are you trying to match?
13:41:13 <geekosaur> posix REs don;t support that syntax
13:41:15 <geekosaur> it's PCRE only
13:41:16 <shapr> pv2b: So, it's like principled fuzzing of your own code every time you run tests.
13:41:25 <daniel_-> "hello -> /home/daniel" i want to extract the string /home/daniel"
13:41:27 <pv2b> oh, i'm trying to keep my mind open to other ways of doing things, including other ways of doing tests.
13:41:32 <dmwit> What made you think that any (?...) stuff would work in *posix* regexen?
13:41:41 <pv2b> which is why i'm learning functional programming specifically
13:41:42 <mauke> daniel_-: so why don't you just grab everything after " -> "?
13:41:48 <nand`> what year is this? I must have fallen into a timesink
13:41:57 <nand`> people still use regex? :P
13:42:05 <geekosaur> dmwit, most people don;t understand the difference between the various regex types
13:42:07 <daniel_-> mauke without regex?
13:42:10 <Cale> Unit testing is a special case of using QuickCheck on properties with no parameters
13:42:11 <daniel_-> didnt even think of that >_>
13:42:13 <mauke> daniel_-: with or without
13:42:17 <shapr> Cale: Yes!
13:42:20 <pv2b> cabal, is that part of the "haskell platform"? I'm just using the ghc/ghci that comes with OS X.
13:42:22 <mauke> daniel_-: " -> (.*)" would be the regex for it
13:42:36 <geekosaur> pv2b, os x doesn't come with ghc
13:42:38 <shapr> pv2b: Yes, cabal is part of the Platform.
13:42:43 <dmwit> There's also SmallCheck, but it's useful less often because programming is more fun with infinite types.
13:42:53 <pv2b> geekosaur: odd. then why do I have it on my system.
13:43:01 <pv2b> (that's a rhethorical question btw.)
13:43:09 <daniel_-> mauke it matches the "-> " aswell?
13:43:14 <mauke> daniel_-: ... and?
13:43:25 <nand`> dmwit: SmallCheck? What does it do? Based on your description, does it exhaustively test?
13:43:28 <pv2b> indeed. my ghc is from /opt. i just assumed...
13:43:37 <daniel_-> that is what i wanted to avoid
13:43:38 <geekosaur> daniel_-, the -> is matched but the stuff after is in the capture groups
13:43:40 <dmwit> nand`: Got it on the first guess!
13:43:48 <monochrom> the point is \1 will have /home/daniel
13:43:52 <nand`> dmwit: the name gave a hint :)
13:44:09 * hackagebot not-gloss 0.4.1 - Painless 3D graphics, no affiliation with gloss (GregHorn)
13:44:11 * hackagebot not-gloss-examples 0.2.1 - examples for not-gloss (GregHorn)
13:44:17 <daniel_-> hmmm groups
13:45:35 <nand`> you know you read too much into abstract nonsense when you first have to figure out what groups have to do with regex matches
13:46:59 <dmwit> Oh, the "hmmm groups" was about regexen.
13:47:34 <dmwit> nand`: It could also be a comment on how little you use regexen.
13:47:41 <geekosaur> actually, may I interject, this looks like parsing "ls -l" output.  Don;t do that.  What are you really trying to do?
13:48:03 <applicative> If my operating system reports 1638896 as the size then of course its  1.6 mb, or am I hallucinating
13:48:16 <geekosaur> (ls output is for humans and cannot be unambiguously parsed in all circumstances.  '-> ' is perfectly valid sequence of characters in a filename...)
13:48:18 <dmwit> Depends. What units is it reporting in?
13:48:24 <dmwit> > 1638896 / 1024 / 1024
13:48:26 <lambdabot>   1.5629730224609375
13:48:35 <nand`> dmwit: I consider that a good thing
13:48:44 <alech> dgvncsz0f: one more question about hoauth, if I may? I want to use it with POST, how would I do that. I could create a Request using ReqHttp in theory, but the constructor is not in scope :(
13:48:45 <dmwit> applicative: Could be 1.6gb
13:48:49 <geekosaur> applicative, if that's blocks then it could be /1024 from what you expect.  or, in POSIX mode, blocks are 512 bytes instead of 1024
13:49:12 <applicative> it's writeFile "list.txt" (show  [1..250000])
13:49:32 <dmwit> > length (show [1..250000])
13:49:34 <lambdabot>   1638896
13:49:43 <dmwit> applicative: Looks like it's reporting in bytes, then. =)
13:49:56 <daniel_-> what i'm trying to do: im starting subprocesses with System.Process.createProcess and i want to monitor the cpu usage for these processes so i pgrep the binary and check all returned PID for if the path set in CreateProcess == /proc/pid/cwd symlink
13:50:04 <dmwit> applicative: (What motivated these questions?)
13:50:11 <applicative> I'm just wondering how someone can think it takes two seconds to write a string that takes up 1.5 mb
13:50:31 <daniel_-> its just the regex left and im 99% sure it will work
13:50:32 <applicative> dmwit: you already saw, I think: http://stackoverflow.com/questions/11420508/haskell-write-large-string
13:50:50 <dmwit> Haven't been on SO in a bit.
13:50:56 <dgvncsz0f> alech: that is odd, it should be available to you: https://github.com/dgvncsz0f/hoauth/blob/master/src/main/haskell/Network/OAuth/Http/Request.hs#L32
13:51:12 <dmwit> Likely they're doing computation and timing that, and thinking they're timing the write because they put the timing functions "after" the computation.
13:51:13 <geekosaur> daniel_-, then I suggest using http://www.haskell.org/ghc/docs/latest/html/libraries/unix-2.5.1.1/System-Posix-Files.html#v:readSymbolicLink
13:51:14 * dmwit opens the link
13:51:26 <dgvncsz0f> alech: also, you could use the method function, to change the method of the request
13:51:34 <daniel_-> ahhhhhhhh
13:51:37 <daniel_-> thank you geekosaur
13:52:06 <geekosaur> no regexes, no worries about ambiguous output
13:52:11 <applicative> dmwit, it's clear theres something else going on; is my comment irrelevant?  It was the snide "use python" that irked  me
13:52:29 <dmwit> Your comment is not irrelevant; I voted for it.
13:52:48 <applicative> hah, thanks
13:53:00 <dmwit> No idea what that Python comment is about.
13:53:21 <mauke> wow
13:53:21 <applicative> I'm not sure the bytestring / text advice is that great; at some point they become slow for writing too.
13:53:24 * nand` wonders if getting rid of the String type alias will help emphasize that [Char] is often not a very good representation of texts
13:53:33 <dgvncsz0f> alech: if you want, i could create a simple example using POST, just let me know.
13:53:55 <mauke> did someone just seriously try to read a symlink by parsing ls output? with a regex? with negative lookbehind in it? IN HASKELL!?
13:53:56 * geekosaur notes username who posted the use python comment, senses a troll
13:54:01 <dmwit> nand`: Maybe if you called it LinkedList Char instead.
13:54:10 <alech> dgvncsz0f: I'll give it a try first, thanks
13:54:16 <hpaste> cesc pasted “n00b question” at http://hpaste.org/71226
13:54:24 <nand`> dmwit: I'll pass
13:54:51 <mauke> cesc: String ->
13:55:00 <cesc> can anybody tell me what I'm doing wrong in this example? http://hpaste.org/71226   I just wanted to get a line from a file
13:55:09 <nand`> cesc: what mauke said, line 9 seems incorrect
13:56:01 <geekosaur> what's the additional String parameter supposed to be?
13:56:07 <cesc> ah! I'm stupid.  Thanks a bunch, I just deleted that string parameter
13:56:21 * nand` ponders suggesting  fmap (head . lines) (hGetContents ...)
13:56:31 <cesc> damn it, why can't I have time for Haskell during the day?  ;)
13:56:51 <nand`> uh, not hGetContents
13:56:57 <nand`> I meant readFile
13:57:46 <hpaste> “Jonathan Fischoff” annotated “n00b question” with “n00b question (annotation)” at http://hpaste.org/71226#a71227
13:58:23 <jfischoff> nand`: still could use an fmap
13:58:42 <nand`> but I believe the two have diverging semantics for files containing no newline characters
13:58:49 <alech> dgvncsz0f: If I explicitly mention RegHttp in the import line, I do have the constructor, but get a lot of "... is not a (visible) field of constructor". Hmmm... In other words, a POST example would be much appreciated ;)
13:58:51 <nand`> sorry, a file containing nothing
13:59:39 <jfischoff> could be, but the second is more probably what cesc was looking for
14:00:44 <nand`> oh, no
14:00:50 <nand`> hGetLine on an empty file is “Exception: EOF”
14:01:00 <nand`> so they both fail in the same situation
14:01:53 <dgvncsz0f> alech: ok, give me a second
14:02:06 <alech> dgvncsz0f: awesome, take your time :)
14:04:42 <mien> Hi guys! i would like to learn haskell and have done some tutourials and so on and feel like i get a hang of the syntax and idioms. Now im looking for a project that i can build as a part of the learing. What kind of applications is good to start with? games? cli-apps? web-apps?
14:04:46 <daniel_-> wohooo it works :)
14:05:07 <nand`> type checker for a simply typed lambda calculus?
14:06:33 <nand`> mien: I've heard of at least one joker that thought a good way to learn Haskell is to write a Haskell compiler. (freely paraphrased) “It doubles the learning pace since you learn both the implementation details and the semantics involved at the same time”
14:06:58 <tdammers> joking aside, writing parsers *is* something haskell is pretty good at
14:07:22 <nand`> I don't think said person was joking either, the compiler exists today. I just forgot the name
14:07:36 <monochrom> jhc?
14:07:43 <nand`> might've been that
14:07:51 <mien> ok. so parsing utils of some kind?
14:08:05 <nand`> I'd start with something you can relate to
14:08:19 <Cale> Yeah, that sounds like JHC
14:08:19 <mien> Just wondering, what kind of stuff do you use the language for?
14:08:42 <nand`> perhaps something that could be useful to you, or maybe something you've implemented in other languages (be careful here though because you may be tempted to attempt recreating the same algorithms)
14:08:57 <tdammers> something that uses a DSL maybe
14:08:59 <nand`> mien: anything and everything
14:09:10 <tdammers> or something that needs to parse messages or input of some sort
14:09:20 <Cale> mien: If possible, start with things that are algorithmically interesting, because that's where Haskell is going to be able to show off a bit.
14:09:31 <nand`> mien: sorting algos!
14:09:35 <Cale> Or anything involving concurrency or parallelism.
14:09:39 <nand`> look at the “quicksort” example :P
14:09:43 <Cale> hehe :)
14:09:50 <tdammers> or anything involving tree structures
14:09:53 <mien> yeah ive done that in my tutourial :)
14:09:57 <nand`> or anything involving recursive data types*
14:10:04 <Cale> Yeah, I didn't really understand quicksort until I'd seen it written in Haskell.
14:10:12 <nand`> mien: generalize fold to rose trees
14:10:20 <otters> The quicksort written in Haskell isn't quicksort, though
14:10:23 <Cale> and then the imperative and in-place algorithm suddenly made sense.
14:10:27 <Cale> It is quicksort
14:10:27 <otters> oh
14:10:29 <otters> okay
14:10:29 <nand`> “quicksort” is a family of algorithms
14:10:36 <c_wraith> it's not in-place
14:10:41 <c_wraith> but at least it's O(n log n)
14:10:49 <Cale> O(n log n) average
14:10:49 <nand`> c_wraith: that's not what he meant, unless you were not replying to Cale
14:10:52 <Cale> O(n^2) worst
14:10:56 <c_wraith> right
14:11:12 <nand`> “in-place” has no meaning for linked lists, mind
14:11:16 <Cale> right
14:11:26 <Cale> Merge sort is better anyway :P
14:11:29 <saep> mien: I enjoyed reading 'Real World Haskell'. It covers a lot of topics and may give you an idea on what to program.
14:11:32 <nand`> yes
14:11:33 <otters> heap sort is better
14:11:52 <nand`> merge sort and heap sort are my favorites. (I'm not very imaginative)
14:11:54 <mm_freak> it's really pointless to say "X sort is better"
14:12:07 <hpaste> dgvncsz0f pasted “hoauth-example” at http://hpaste.org/71228
14:12:08 <Cale> The Data.List.sort in GHC is a bottom-up merge sort
14:12:15 <mien> saep, yeah, iv read that, and the learn you a haskell as well.
14:12:19 <nand`> mm_freak: BogoSort is better at wasting your time
14:12:19 <dgvncsz0f> alech: http://hpaste.org/71228
14:12:36 <mm_freak> nand`: now you're adding types, which was my point =)
14:12:37 <MostAwesomeDude> mm_freak: Sleep sort is better at trolling Reddit.
14:12:38 <dgvncsz0f> alech: it is kind of useless, but it compiles so you could start from there
14:12:47 <nand`> mm_freak: I figured :)
14:13:01 <mm_freak> MostAwesomeDude: if that's an insider, i don't get it…  i'm not on reddit =)
14:13:14 <nand`> does “sleep” sort mean what I think it means?
14:13:18 <MostAwesomeDude> mm_freak: are you acquainted with sleep sort yet? :3
14:13:23 <daniel_-> @pl let lines' = (\l -> return $ lines l)
14:13:23 <lambdabot> (line 1, column 38):
14:13:23 <lambdabot> unexpected end of input
14:13:23 <lambdabot> expecting variable, "(", operator, ";" or "in"
14:13:26 <mien> Well thank you guys. i got some ideas :)
14:13:35 <mm_freak> MostAwesomeDude: nope
14:13:45 <nand`> (aka any other sorting algorithm but insert some sleep(n) for n > 0 in between operations)
14:13:54 <MostAwesomeDude> nand`: No, no it isn't.
14:13:56 <nand`> I see
14:14:15 * hackagebot plugins 1.5.2.3 - Dynamic linking for Haskell and C objects (JeremyShaw)
14:14:16 <MostAwesomeDude> Sleep sort: fork for each item in the list, and sleep(item) then print the item.
14:14:30 <nand`> MostAwesomeDude: awesome
14:14:32 <daniel_-> @pl lines' = (\l -> return $ lines l)
14:14:32 <lambdabot> lines' = return . lines
14:14:33 <monochrom> hahaha
14:14:42 <mm_freak> lol
14:14:46 <nand`> MostAwesomeDude: O(max[n])
14:14:48 <nand`> perfect
14:14:55 <pv2b> a better rational for a realtime operating system i have rarely heard
14:15:01 <mm_freak> that's actually a valid sorting algorithm, if you don't mind some nondeterminism =)
14:15:20 <scopedTV> works for positive integers only
14:15:20 <alech> dgvncsz0f: thanks, I'll give it a try
14:15:29 <pv2b> tbh writing an O(max[n]) sort isn't hard.
14:15:31 <scopedTV> but still, awesome lol
14:15:31 <nand`> mm_freak: it immediately reminds me of another brilliant sorting algo: a physical one based on dropping boxes
14:15:41 <mm_freak> scopedTV: works for negative integers as well according to einstein =)
14:16:09 <pv2b> just iterate through all possible values.
14:16:23 <pv2b> actually more properly it's not O(max_m)
14:16:30 <pv2b> it's more like O(n*max_n)
14:16:43 <Cale> Priority queue sort
14:16:51 <pv2b> no. O(n + max_n).
14:16:57 <otters> bogosort is encouragingly difficult to do in haskell
14:17:00 <mm_freak> pv2b: that's also something you can't say in general
14:17:01 <pv2b> cale: you just invented the heapsort.
14:17:03 <scopedTV> head . filter (all (uncurry (<=)) . zip `ap` tail) . permutations
14:17:04 <scopedTV> or something
14:17:20 <Cale> pv2b: Or generalised it
14:17:21 <mm_freak> the asymptotic speed of a sorting algorithm depends on the data structure you're sorting
14:17:27 <nand`> hmm
14:17:32 <mm_freak> for example i can easily write an O(1) sorting algorithm for Set
14:17:36 <nand`> @hoogle (a -> Bool) -> (a -> m a) -> a -> m a
14:17:37 <lambdabot> Control.Parallel.Strategies ($|) :: (a -> b) -> Strategy a -> a -> b
14:17:37 <lambdabot> Control.Parallel.Strategies ($||) :: (a -> b) -> Strategy a -> a -> b
14:17:37 <lambdabot> Control.Parallel.Strategies (.|) :: (b -> c) -> Strategy b -> (a -> b) -> (a -> c)
14:17:37 <mm_freak> its code has only two characters
14:17:45 <nand`> no untilM?
14:17:46 <mm_freak> and doesn't even depend on Ord
14:18:19 <mm_freak> blitzSort :: Set a -> Set a
14:18:32 <Cale> Of course, I would use a finger-tree based priority queue, just for the sake of being fancy :)
14:19:17 <Cale> Ugh, why are there not any tools to adjust the basic colours of things in Gnome anymore?
14:19:18 <applicative_> blitzSort :: Set a -> Set a; blitzSort = id ; I know that one
14:19:23 * kallisti sips some delicious kool-aid he received from the Church of the Least Fixed Point.
14:19:28 <pv2b> i always liked storing things in trees when I was starting out learning programming. in C. makes it O(n) to iterate thorough them sorted.
14:19:58 <pv2b> the fact that adding an item was log(n) and thus the entire exercise was still n*log(n) escaped me at the time.
14:20:02 <mm_freak> i always found trees in C to be really inconvenient
14:20:07 <nand`> I tend to store things in trees too, using a sufficiently broad definition of ‘tree’ to cover anything from [] to RoseTree
14:20:10 <Cale> > Set.toList . Set.fromList $ "mississippi"
14:20:12 <lambdabot>   Not in scope: `Set.toList'Not in scope: `Set.fromList'
14:20:35 <kallisti> shapr: so I might be borrowing some design from xml-conduit for filesystem-trees
14:20:36 <pv2b> mm_freak: just encapsulate your tree operations. because rewriting an implementation of a tree in every program was my idea of fun back then.
14:20:43 <shapr> kallisti: How so? Sounds interesting!
14:20:56 <nand`> :t S.fromList
14:20:58 <lambdabot> forall a. (Ord a) => [a] -> S.Set a
14:21:04 <mm_freak> pv2b: sure, but my main issue with trees in C is that you can't really make them immutable
14:21:04 <Cale> Right
14:21:06 <nand`> > S.toList . S.fromList $ "mississippi"
14:21:09 <lambdabot>   "imps"
14:21:13 <mm_freak> lol
14:21:14 <nand`> haha
14:21:19 <pv2b> youc an't make anything in C immutable though
14:21:22 <MostAwesomeDude> Looks sorted to me.
14:21:28 <pv2b> void *p = &whatever;
14:21:29 <kallisti> shapr: I'll keep a similar interface to the one that currently exists (though heavily modified to remove the need for IO queries)
14:21:41 <Cale> sorted and nubbed
14:21:53 <kallisti> shapr: but I like the idea of having an xpath-like syntax using combinators to filter lists of files
14:22:37 <Cale> > map fst . S.toList . S.fromList . flip zip [0..] $ "mississippi"
14:22:37 <shapr> That does sound nifty.
14:22:38 <mm_freak> pv2b: well, you can, sort of…  C actually allows CPS, and if you use GCC you also get TCO
14:22:41 <lambdabot>   "iiiimppssss"
14:23:32 <nand`> why ‘map fst’ and ‘flip zip’ instead of ‘map snd’ and just ‘zip’? Is this some instance issue?
14:23:39 <pv2b> mm_freak: what are CPS and TCO?
14:23:43 <MostAwesomeDude> nand`: Doesn't sort right otherwise.
14:23:44 <Cale> > map snd . S.toList . S.fromList . zip [0..] $ "mississippi"
14:23:47 <lambdabot>   "mississippi"
14:23:50 <nand`> oh, yes
14:23:50 <mm_freak> pv2b: continuation passing style, tail call optimization
14:23:57 <MostAwesomeDude> Cale: Looks like you've invented heapsort again.
14:23:58 <kallisti> shapr: I might be able to use Text.XML.Cursor.Generic verbatim.
14:24:14 <nand`> MostAwesomeDude: I thought sets were based on BSTs
14:24:24 <nand`> and LTR walking
14:24:34 <Cale> I'm not sure whether it counts as heapsort unless you're actually building a proper heap
14:24:53 <kallisti> shapr: since it parameterizes the node type, I can just use a "filesystem Node" and get the zipper structure for free.
14:25:12 <mm_freak> pv2b: withInsertInt(DataStructure *x, int val, void (*k)(DataStructure *))
14:25:15 <c_wraith> traditional heap sorts use an array-based implementation of a complete binary heap - they skip the links
14:25:46 <hbt_> Suppose I have a list that contains a bunch of lists, which in turn contain a bunch of lists, and so on for some arbitrary number of iterations, where the bottom level of lists contains numbers.
14:25:49 <mm_freak> of course CPS isn't convenient either, but at least it's possible…  you can still do in-place updates, if you never refer to the "outer" data structure
14:26:09 <hbt_> I'm trying to write a "flatten" function that will remove all the nesting and just give a list of the numbers.
14:26:17 <nand`> c_wraith: they're still there; just not explicit - in-place heapsorts use a specially crafted indexing function to get from tree coords to array coords and back
14:26:32 <mm_freak> hbt_: that function will be written specifically for the nesting level you have
14:26:43 <c_wraith> nand`: yeah, that's just an array implementation of a complete binary tree. Nothing special.
14:26:49 <hbt_> mm_freak Is there any way to make it independent of nesting level?
14:26:56 <applicative> concat . concat . concat
14:26:58 <nand`> c_wraith: oh, I see what you're saying now
14:27:01 <applicative> hbt_: yes
14:27:08 <mm_freak> hbt_: yes…  using lightweight dependent types =)
14:27:13 <hbt_> :(
14:27:19 <nand`> c_wraith: I didn't see “array-based implementation” for some reason
14:27:24 <hbt_> but no beginner way?
14:27:27 <mm_freak> hbt_: nope
14:27:29 <applicative> http://www.haskell.org/pipermail/haskell-cafe/2010-December/087842.html
14:27:34 <applicative> oleg to the rescue
14:27:45 <danr> hbt_: try with a datatype data Nest a = Pure a | Nest [Nest a]
14:27:54 <nand`> hbt_: earlier you asked about your palindrome function, I never got a chance to reply :(
14:27:59 <applicative> hbt_: check out those language extensions :)
14:28:01 <danr> and then flatten :: Nest a -> [a]
14:28:38 <nand`> danr: I have a feeling this might be related to free monads
14:28:45 <danr> nand`: ;)
14:28:59 <mel-> hi
14:29:17 <mm_freak> hi there mel-
14:29:28 <applicative> hi mel-
14:29:36 <foo__> Does anybody know how efficient nested record access is, for example: getC . getB . getA . Is this linear in the depth of the record or does the compiler do some clever optimization?
14:29:40 <daniel_-> > fromJust Nothing
14:29:41 <lambdabot>   *Exception: Maybe.fromJust: Nothing
14:29:58 <mm_freak> danr: although i like your answer, it actually answers a different question =)
14:30:36 <mm_freak> you can't write an arbitrary-depth flatten function for lists without some heavy trickery
14:30:49 <danr> mm_freak: well the original wording only said "[..] write a `flatten' function that will remove all the nesting and give a list [..]", so it wasn't very precise from the start
14:31:01 <mm_freak> true
14:31:10 <hbt_> mm_freak: That's pretty sad.
14:31:12 <twanvl> foo__: it will be linear in the depth, but in practice the depth doesn't get that high
14:31:21 <mm_freak> hbt_: no, actually it's fortunate =)
14:31:27 <applicative> hbt_: what's sad??
14:31:27 <hbt_> Why?
14:31:38 <mm_freak> hbt_: beginners always hate this at first, but you will learn to love it
14:31:55 <hbt_> applicative: That it's impossible to write arbitrary-depth flatten functions.
14:32:09 <parcs`> it's not impossible
14:32:13 <mm_freak> hbt_: it's not impossible…  it's just impossible for []
14:32:13 <hbt_> mm_freak: But what if I come across a situation where I need one?
14:32:14 <foo__> twanvl: oke, thanks!
14:32:19 <mm_freak> hbt_: you won't
14:32:26 <applicative> hbt_: it's possible but it would make for a lot of errors
14:32:33 <monochrom> first you have to ask yourself what is one single type that stands for arbitrary-depth lists
14:32:43 <ciaranm> free monad!
14:32:44 <applicative> hbt_: why not let lists be lists?
14:32:48 <parcs`> it's not impossible for [], at least not for ghc haskell
14:33:01 <hbt_> mm_freak: Could I get around it by defining a new data type to represent my deep lists?
14:33:09 <mm_freak> hbt_: yes
14:33:15 <hbt_> Ok, sweet.
14:33:18 <mm_freak> and you don't "get around" it
14:33:25 <applicative> hbt_: oleg's solution is pretty simple,  just obnoxious  http://www.haskell.org/pipermail/haskell-cafe/2010-December/087842.html
14:33:26 <mm_freak> you actually realize that what you're handling is not a list =)
14:33:33 <hbt_> Haha, ok.
14:33:44 <ciaranm> you don't need to define a new data type. you can have one for free!
14:33:49 <ciaranm> (first learn category theory)
14:34:01 <applicative> you need a new datatype
14:34:02 <hbt_> I actually know some category theory.
14:34:21 <hbt_> Ok.
14:34:24 <mm_freak> hbt_: i'm being dishonest…  it's possible, but i wouldn't bother for now…  and later when you understand how it's possible you will likely have realized that you will never need it in haskell
14:34:28 <ciaranm> well you want the free monad on the list functor. or something.
14:34:31 <ciaranm> probably.
14:34:36 <nand`> ‘retract $ Free [Free [Free [Pure 1, Pure 2, ....”
14:34:36 <hbt_> mm_freak: ok.
14:34:53 <mm_freak> ciaranm: that's exactly what you want, but the result is a tree, not a list, which is exactly my point
14:35:06 <mm_freak> arbitraryDepthFlatten is a function for trees, not lists
14:36:07 <BenC> Anyone familiar with the ppc ghci crash: http://hackage.haskell.org/trac/ghc/ticket/2972 ?
14:38:08 <jfischoff> BenC: just wondering, are you on a ps3?
14:38:19 <BenC> No, freescale e500mc
14:38:48 <jfischoff> also you might want to try #ghc
14:39:30 <BenC> Thanks
14:39:46 <jfischoff> good luck!
14:40:08 <mikeplus64> what does a ~ mean in a type constraint?
14:40:11 <EvanR> hbt_: sounds like you want a tree instead
14:40:12 <frerich_> Hi, I'm currently tinkering a little bit and at one point wrote my own "length" function as "foldr (\_ acc -> acc + 1) 0". I just noticed that this runs quite a bit faster when using a foldl isntead. Does anybody know why that is?
14:40:32 <frerich_> Maybe because foldr has to "walk to the end" first and then folds "backwards"?
14:40:34 <EvanR> arbitrary nest lists doesnt sound like a list
14:40:41 <dmwit> frerich_: Exactly right.
14:40:44 <danr> mm_freak: yeah I guess you were right, you needed some type machinery for flatten (http://hpaste.org/71230)
14:40:45 <EvanR> it sounds like lisp lol
14:41:05 <daniel_-> is {-# OPTIONS_GHC -O2 #-} needed in every module or just main?
14:41:07 <dmwit> frerich_: You'll probably like the speed of foldl' even better than foldl.
14:41:20 <theadmin> daniel_-: I'd think just Main.
14:41:38 <frerich_> dmwit: Hmm cool, it's the third time in a row in which my intuition is confirmed by the #haskell hive intelligence. I'm on to something!
14:41:40 <mikeplus64> daniel_-: probably best to compile with -O2 as an argument to ghc
14:41:54 <EvanR> #haskell hive intelligence
14:42:15 <daniel_-> yeah i guess it wont be that hard when i integrate with cabal later
14:42:36 <shachaf> I think it's needed in every module.
14:42:46 <nart> hi guys
14:42:47 <shachaf> But you probably oughtn't put it in the file at all.
14:43:19 <nand`> > foldl (1+) 0 "foo"
14:43:21 <lambdabot>   Occurs check: cannot construct the infinite type: t = b -> t
14:44:30 <EvanR> > (:[]) 'a'
14:44:32 <lambdabot>   "a"
14:44:35 <parcs`> mikeplus64: a ~ b means a and b are the same type. it's useful when working with type families
14:44:37 <dmwit> > foldl (const (1+)) 0 "foo"
14:44:39 <lambdabot>   No instance for (GHC.Num.Num GHC.Types.Char)
14:44:39 <lambdabot>    arising from the literal `1...
14:44:51 <nand`> > foldl (const . (1+)) 0 "foo"
14:44:54 <dmwit> um
14:44:55 <lambdabot>  Terminated
14:45:02 <nand`> wut
14:45:03 <dmwit> :t foldl
14:45:05 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
14:45:06 <nand`> > foldl (const . (1+)) 0 "foo"
14:45:10 <lambdabot>   3
14:45:20 <frerich_> dmwit: Hm indeed. I guess foldl' is faster because... it's less lazy so the GC has less work to do?
14:45:29 <shachaf> frerich_: It's not about the GC.
14:45:34 <shachaf> @google haskell foldr foldl foldl'
14:45:36 <lambdabot> http://www.haskell.org/haskellwiki/Foldr_Foldl_Foldl'
14:45:36 <frerich_> dmwit: I saw that the prelude length uses unboxed values. Is there a way to use unboxed values with a fold?
14:45:36 <lambdabot> Title: Foldr Foldl Foldl' - HaskellWiki
14:45:39 <zachk> is it about the evaluation?
14:45:40 <mikeplus64> parcs`: ah
14:45:43 <nand`> I would have expected (const . (1+)) to reduce itself to (1+) via NumInstances magic
14:45:44 <dmwit> frerich_: foldl' is faster because it doesn't make a really deeply-nested thunk.
14:45:50 <nand`> I guess I didn't think it through properly :(
14:46:18 <frerich_> shachaf: fold' uses less thunks, right? Doesn't that mean the GC has less work to do?
14:46:24 <frerich_> foldl' even
14:46:29 <nand`> frerich_: yes but that's not the reason you see a huge difference
14:46:29 <dmwit> Again, not a GC thing.
14:46:33 <shachaf> It's not about the GC.
14:46:41 <nart> anything new worth noticing in the haskell world ? it's a pretty boring evening here
14:46:51 <dmwit> I don't even think the GC has less work to do with foldl' than with foldl.
14:46:57 <shachaf> I mean, it affects the GC, but there's a bigger issue before GC ever happens.
14:47:08 <frerich_> So it's *creating* the thunks which makes the difference as opposed to cleaning up?
14:47:27 <dmwit> frerich_: The issue is that foldl makes a thunk as deeply nested as the list is long, then has to muck about evaluating that damn thing.
14:47:59 <nand`> frerich_: the difference is that you have to do a lot of memory allocation for the lazy version, since it creates a huge thunk. And then evaluates it, as opposed to doing it all in-place
14:48:05 <Cale> You can see this without referring to or thinking about thunks
14:48:05 <applicative> foldl is a complete chamber of horrors
14:48:15 <Cale> Just think at the level of expressions
14:48:30 <Cale> (thunks are the runtime representations of expressions)
14:48:40 <applicative> > foldl (+) x [1..10]
14:48:42 <lambdabot>   x + 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10
14:48:49 <applicative> not too helpful
14:49:05 <applicative> > foldr (+) x [1..10]
14:49:06 <lambdabot>   1 + (2 + (3 + (4 + (5 + (6 + (7 + (8 + (9 + (10 + x)))))))))
14:49:14 <Cale> foldl (+) 0 [1,2,3] -> foldl (+) (0+1) [2,3] -> foldl (+) ((0+1)+2) [3] -> foldl (+) (((0+1)+2)+3) [] -> (((0+1)+2)+3)
14:49:37 <nand`> going by applicative's example, foldl' starts off the same way (x + 1) but then instantly reduces this, call it x'; and then continues (x' + 2), instantly reduces this (x''); (x'' + 3) and so forth
14:49:59 <Cale> This is where we start putting things on the stack, because (+) needs to pattern match both its arguments to evaluate.
14:50:24 <ciaranm> clearly haskell should stop being lazy and introduce a lazy functor instead
14:50:39 <Cale> So (...)+3 gets put on the stack, and then (...)+2 and then 0+1 is able to evaluate.
14:50:58 <Cale> (really, it's the underlying case expressions which are on the stack)
14:51:16 <Cale> (and even that's a mental model :D)
14:51:33 <Cale> ciaranm: d i s a g r e e
14:51:57 <nand`> ciaranm: Haskell would have stopped being lazy a long time ago, but it's too lazy to do so
14:52:09 <applicative> one laziness goes out the window, everyones IQ falls 50 pts. That's my experience
14:52:12 <Cale> nonstrict semantics are really good
14:52:41 <applicative> Once laziness...
14:53:18 <Cale> Once nonstrictness isn't the default, it becomes hard to compose things which are non-strict from the components you have lying around
14:53:49 <Cale> and it pretty much completely defeats the purpose of it
14:54:13 <Cale> The whole reason we like nonstrict semantics (and lazy evaluation) is that it makes things more compositional
14:54:16 <nand`> wait
14:54:21 <Cale> but that's only true if you have parts to compose things from
14:54:23 <nand`> has it ocurred to you that ciaranm might have been joking?
14:54:30 <Cale> He might have been
14:54:37 <Cale> but this is a common thing to think anyway
14:54:41 <frerich_> Cale: Ok so with foldl, you have about... n-1 values pushed and popped to/from the stack for a list of length 'n' - did I get that right? And foldl' is faster since it somehow makes '+' less lazy (this part I don't get) so, 0+1 is evaluated earlier, so foldl actually has constant stack usage (kinda like foldr, but from the other side :-) - does that make sense, or am I totally off now? :-}
14:54:43 <nand`> he earlier suggested using free monads for arbitrary nested lists
14:54:43 <applicative> http://augustss.blogspot.com/2011/05/more-points-for-lazy-evaluation-in.html ciaranm see the last objection which Prof Harper totally  concedes, in favor or moronism
14:54:45 <Cale> I've seen that opinion expressed a lot
14:54:56 <nand`> I think he might have been joking :P
14:55:07 <dada_cetacean> does anyone here have experience with mathematica as well? Is it similar to haskell?
14:55:16 <Cale> dada_cetacean: I do, and no.
14:55:29 <scopedTV> dada_cetacean: not really.
14:55:34 <Cale> You can do some functional programming in it, but it's much more similar to lisp.
14:55:44 <applicative> pretty pictures are harder to come by in Haskell :)
14:55:46 <nand`> frerich_: it makes ‘+’ less lazy using magic, quite literally
14:55:55 <nand`> frerich_: so don't worry too much about it
14:56:04 <frerich_> nand`: Does "seq" have something to do with it?
14:56:07 <nand`> frerich_: yes
14:56:08 <ciaranm> i like laziness right up to the point where it makes my code horribly slow and i have to make it ugly to fix it
14:56:11 <Cale> Its notation is even how lisp was originally meant to look (m-expressions), before everyone in the lisp community got caught up in s-expressions :)
14:56:21 <nand`> frerich_: ‘seq’ is a magic primitive that is semantically identical to const id
14:56:57 <applicative> " I must say that I envy this in Haskell. As you know, in the eager world we tend to write out our own recursive functions, rather than use combinators." - Prof Robert Harper, favoring mindless boilerplate
14:56:59 <Cale> ciaranm: But sometimes it makes your code much much faster :)
14:57:31 <Cale> Writing recursion explicitly is admission of defeat
14:57:38 <applicative> Yes
14:57:51 <frerich_> FWIW, I saw that the Prelude.length function uses explicit recursion. Ahem.
14:57:58 <frerich_> There must be a time and place for it.
14:58:02 <dmwit> frerich_: nand` is defeating you. seq isn't magic: it's a pattern match on its first argument in which every branch results in its second argument.
14:58:09 <scopedTV> frerich_: instructive value, perhaps.
14:58:12 <nand`> I always start my haskell programs with the basic bird fold
14:58:13 <dmwit> frerich_: (Even when you aren't allowed to write the pattern match yourself.)
14:58:20 <applicative> frerich_: I think scopedTV is  right
14:58:22 <nand`> (my jokes are not very imaginative)
14:58:27 <jfischoff> Cale: defeat? Is it really that bad?
14:58:36 <Cale> frerich_: There is, when you're defeated in some way -- either by performance demands or by inability to understand the recursive process you're using.
14:58:44 <frerich_> scopedTV, applicative: I rather thought it had something to do with the unboxed accumulator value.
14:58:59 <nand`> dmwit: by ‘magic’ I meant ‘can't be defined from within Haskell’ (or can it?)
14:59:08 <codolio> Prelude.length only uses explicit recursion in its reference implementation in the report.
14:59:13 <nand`> it obviously can for specific data types, but polymorphically?
14:59:17 <codolio> Unless I'm greatly mistaken.
14:59:20 <dmwit> nand`: The only "magic" is its type.
14:59:24 <applicative> frerich_: it isn't that its unboxed it is crucial that (+) is strict in both args; or am I putting that right
14:59:27 <ciaranm> clearly there should be a strict functor so i don't have to shove !s everywhere
14:59:39 <dmwit> nand`: As I mentioned in my parenthetical after the explanation of what it does. =)
14:59:59 <Cale> jfischoff: If you can write something in terms of higher order functions, you generally should, because it expresses an understanding of how the thing works in a way that explicit recursion doesn't, and may make certain transformations on the code easier to apply.
15:00:19 <ciaranm> clearly higher order functions should be replaced by strangely shaped brackets
15:00:21 <dmwit> frerich_: Anyway, the way foldl' works is by first evaluating the non-recursive function call before making its recursive call.
15:00:43 <mikeplus64> is there a way to "delete" an instance in ghci?
15:00:45 <dmwit> frerich_: So instead of building up (((0+1)+2)+3)+...), it evaluates (0+1) before moving on to element 2 of the list.
15:00:49 <codolio> And I think the reference implementation is terrible. Right fold equivalent or something.
15:00:58 <dmwit> mikeplus64: No, instances are global.
15:01:05 <applicative> codolio:     len :: [a] -> Int# -> Int;    len []     a# = I# a#;    len (_:xs) a# = len xs (a# +# 1#)  is the explicit recursion though
15:01:07 <frerich_> dmwit: So it eventually builds e.g. (0+1)+2 but it evaluates the lhs of the outer + first, so it gets 1+2 ?
15:01:08 <Cale> mikeplus64: Only by not importing it
15:01:33 <nand`> Cale: it also makes your code more compact which can be a good thing and a bad thing: it can be good by increasing readability and managability. it can be bad by decreasing readability and clarity
15:01:37 <Cale> mikeplus64: Generally if you want to write multiple instances for something, it's time to define a newtype (or build records of functions)
15:01:39 <dmwit> frerich_: No, it builds (0+1), then evaluates that to get 1, then builds (1+2), then evaluates that to get 3, etc.
15:01:53 <dmwit> ?src foldl'
15:01:53 <lambdabot> foldl' f a []     = a
15:01:54 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
15:02:03 <nand`> (it can also be good by increasing clarity, mind)
15:02:13 <dmwit> frerich_: For the type Int, read that second line as
15:02:29 <frerich_> Ah I see, `seq` causes "f a x" to be evaluated before even recursing...
15:02:35 <dmwit> foldl' f a (x:xs) = let a' = f a x in case a' of 0 -> foldl' f a' xs; 1 -> foldl' f a' xs; ...
15:02:41 <dmwit> right
15:02:58 <codolio> applicative: They actually do that? That's probably pretty unnecessary these days.
15:03:03 <applicative> ciaranm: I agree it would be nice to have a wacky brackets extension
15:03:11 <dmwit> So before deciding which branch to take (and hence before being able to recurse), it must evaluate the summands and do the addition.
15:03:22 <codolio> Then again, it was probably written a long time ago.
15:03:27 <applicative> codolio: thats what made me think I was wrong that it was just for show
15:03:59 <nand`> mikeplus64: I think you can redefine the type, but the old instance will still be around (And all your definitions involving that type will be void)
15:04:09 <nand`> they'll have funny type errors too
15:04:14 <Cale> applicative: There were a bunch of optimisations which weren't built into GHC at the time that a lot of the base code was written, and which were done by hand. I'm not sure what the status of all of them are today.
15:05:03 <frerich_> dmwit: Now, that makes me wonder - assuming you have an algorithm which is equally easy to implement with a left fold as with a right fold (say: length) - foldr has to walk the list first but then doesn't build such deeply nested thungs. foldl doesn't need to walk the list, but builds deeply nested thunks. foldl' appears to be the best of both because it doesn't build deeply nested thunks and yet doens't need to walk the entire list. What would have the funct
15:05:03 <frerich_> passed to fold be like in order for 'foldl' to be harmful (because you don't want eager evaluation)?
15:05:46 <dmwit> foldl is almost never the right choice. foldl' or foldr are correct depending on whether you want a lazy answer or not.
15:05:46 <shirt> i'm trying to write a unit test that checks that a value is fully evaluated (no lazy thunks). any suggestions? i tried using the vacuum package with its 'dumpLazy' function but i'm having trouble working with it
15:05:50 <nand`> in general you want either foldl' (for strict evaluation) or foldr (for lazy recursion)
15:05:51 <Cale> frerich_: foldr results in large expressions in memory too...
15:06:14 <Cale> frerich_: assuming the function you're passing to it is strict in its second argument
15:06:27 <dmwit> frerich_: Also, your question got cut off... it went straight from "What would have the funct" to "passed to fold be like".
15:06:44 <frerich_> oh
15:06:57 <frerich_> dmwit: My last sentence was: " What would have the function passed to fold be like in order for 'foldl' to be harmful (because you don't want eager evaluation)?"
15:07:01 <Cale> However, in another sense, foldr is O(1) :)
15:07:06 <Cale> @src foldr
15:07:07 <lambdabot> foldr f z []     = z
15:07:07 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
15:07:20 <mikeplus64> @src foldl
15:07:21 <lambdabot> foldl f z []     = z
15:07:21 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
15:07:25 <Cale> Under outermost-first evaluation, foldr is going to pass control to f immediately.
15:07:36 <Cale> and f can choose whether or not to recurse
15:07:36 <dmwit> frerich_: Oh, that's easy. Imagine writing the length function on Peano numerals, where you want a lazy numeral out.
15:07:37 <gwillen> @src foldl'
15:07:37 <lambdabot> foldl' f a []     = a
15:07:38 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
15:07:49 <mikeplus64> @src foldr'
15:07:50 <lambdabot> Source not found. Sorry.
15:08:01 <dmwit> frerich_: For example, this is handy for checking whether the length of a list is bigger than (say) 10 -- since it works even with infinite lists.
15:08:10 <dmwit> frerich_: Then you surely wouldn't want a strict fold.
15:08:32 <codolio> applicative: Anyhow, it's impossible to rewrite that to use foldl' because of the manual unboxing.
15:08:43 <codolio> But the manual unboxing is probably unnecessary today.
15:08:47 <frerich_> dmwit: Ok it's embarrasing to admit this at my age, but I don't even know what "length on Peano numerals" means (maybe being self-taught is an excuse...) :-}
15:08:57 <dmwit> frerich_: Sure, no problem.
15:09:18 <dmwit> frerich_: The simplest way to explain it is that a Peano numeral is a value of type [()]. =)
15:09:18 <nand`> frerich_: peano numerals: data Nat = Zero | Succ Nat; ie. a representation of numbers as 1+1+1+1+1+1+1...+1+0
15:09:20 <Cale> frerich_:  data Nat = Zero | Succ Nat
15:09:24 <applicative> codolio: that's what I was thinking
15:09:32 <dmwit> frerich_: The interesting thing about them is that you can write *lazy* addition, multiplication, and comparison.
15:09:38 <applicative> "[In the eager world we use explicit recursion because] deforestation and related transformations are not valid, at least not in the presence of effects." -- Prof. Robert Harper
15:09:38 <frerich_> But I love this channel for having so many people with different degrees of Haskell expertise, and yet the "Oh this is easy, just do the Quantumfluxcomonad functor in the blah" effect happens very rarely! :-)
15:09:58 <nand`> frerich_: as you can probably see, Nat can be infinite: infinite = fix Succ; and comparison can be done recursively without evaluating the whole thing: Zero on either side is the terminating base case
15:10:07 <nand`> otherwise compare (Succ n) (Succ m) = compare n m
15:10:10 <dmwit> > (genericLength [1..] :: Natural) > 5
15:10:11 <lambdabot>   Not in scope: type constructor or class `Natural'
15:10:13 <frerich_> Oh, *that* is called Peano numerals, I see.
15:10:30 <applicative> data Quantumfluxcomonad x = Quantumfluxcomonad x
15:10:32 <dmwit> You might also know them as "unary". =)
15:10:46 <nand`> frerich_: also don't worry, I'm self-taught too and I learned of these terms over time
15:10:46 * frerich_ thinks the problem with not having proper educatin is that you discover stuff on the way but never know what other people call them
15:11:09 <nand`> frerich_: my main source has been Wikipedia, if it helps. :(
15:11:15 <dmwit> frerich_: Doesn't matter, terminology is the easy part.
15:11:17 <frerich_> I used this way of representing numbers in type-level arithmetic in C++
15:11:31 * frerich_ assumes the same works just as well in Haskell
15:11:31 <dmwit> Tell me what you call them and that's what I'll call them for the rest of the discussion. =)
15:11:34 <frerich_> hah
15:12:02 <applicative> frerich_: Have you read http://blog.johantibell.com/2010/09/slides-from-my-high-performance-haskell.html ?  Maybe you're past that though
15:15:10 <mrsolo> man 'perals of functional algorithm design' is a difficult read :-<
15:15:57 <monochrom> yes
15:16:13 <frerich_> applicative: I just browsed through it, and the stuff which is new to me starts at page 21/99 - ahem. So thanks for the link. :-)
15:16:22 <monochrom> I survived his Algebra of Programming :)
15:16:49 <monochrom> your typo is an inspiring one. the perils of functional algorithm design... :)
15:16:58 <mrsolo> monochrom, $140 bucks!
15:17:14 <hiptobecubic> damn
15:17:19 <nand`> monochrom: fund it
15:17:32 <monochrom> you mean $140 for Algebra of Programming? yeah it's out-of-print and stuff
15:17:42 <hiptobecubic> Is that the same Bird that gave us > tracks?
15:17:54 <monochrom> I think i got it for $100 many years ago
15:18:10 <Botje> =z é&
15:18:12 <Botje> oops
15:18:15 <monochrom> http://www.vex.net/~trebla/weblog/fpbooks.xhtml hehe
15:18:33 <mrsolo> monochrom, i just finished ch 7
15:18:35 <mrsolo> and i keep thinking
15:18:39 <codolio> hiptobecubic: Yes.
15:18:48 <mrsolo> the solutions are pretty much not maintainable
15:18:50 <codolio> Er, or is it....
15:18:50 <mrsolo> in real life
15:19:05 <mrsolo> basically create and forget..and hopefully it won't have bugs..hah
15:19:17 <monochrom> don't maintain the solutions (as in, final code). maintain the whole derivation
15:19:21 <codolio> If it's named after someone, then yes. But > might just look like real bird tracks.
15:19:49 <frerich_> dmwit, nand`: Sorry for the sudden silence, I'm just tinkering with a "lazyLength" function, thanks for all the inspiring and patient feedback so far :-)
15:19:52 <monochrom> and here maintain means "if you change the specification because you want to solve a slightly different problem..."
15:20:05 <dmwit> frerich_: Enjoy!
15:20:06 <monochrom> which I'm sure Bird did sometimes, too
15:20:21 <nand`> frerich_: ‘lazyLength’? as in, peano?
15:20:24 <mrsolo> monochrom, correct
15:20:41 <mrsolo> monochrom, which means need to understand the original solution in the first place
15:20:44 <frerich_> nand`: Yes (the name is not very pretty, I know)
15:21:13 <hiptobecubic> For the people who have actually worked through Haskell Road to Logic... was it really a decent book or just kind of novel?
15:21:16 <monochrom> maintain the whole derivation. not just code.
15:21:46 <monochrom> well the derivation is pretty understandable. in fact no harder than just the code. the code alone is mysterious and meaningless
15:21:48 <nand`> frerich_: the built in genericLength should work if you define a Num instance for peano integers, fyi
15:22:05 <nand`> (though that's going to be ugly because of no negatives)
15:22:05 <monochrom> think of the derivation as internal documentation. "why does the code look like this?"
15:22:32 <nand`> monochrom: an excellent strategy, doubles as teaching reference too
15:22:36 <monochrom> "here is why: because at step 5 you can use the banana-split rule"
15:22:49 <nand`> teach your coworkers haskell and document the code at the same time
15:22:56 <nand`> .lhs anyone?
15:23:23 <monochrom> for this reason I disagree with a large extent of "self-documenting code"
15:24:32 <monochrom> you can do self-documenting for the most boring and naïve algorithms, yes. that's the end of it
15:33:35 <applicative> frerich_: there's also this, sort of a case study.  For some reason I find him very intelligible on these themes http://www.scs.stanford.edu/11au-cs240h/notes/performance.html#(1)
15:34:46 * applicative somehow has a djvu file of algebra of programming, wonder where that came from
15:39:17 <frerich_> applicative: That looks interesting, too - thanks! The discussion of strictness makes me wonder whether I wrote functions in the past which could've been less strict (so far my rule of thumb is to be as lazy as possible and as strict as necessary) if I had written them differently
15:45:51 <shapr> I'm using chrisdone's latest version of haskell-mode, and C-c C-v doesn't run hlint, but it does work if I run hlint in my src directory. Does anyone know why that is?
15:46:00 <shapr> Is there #haskell-emacs ? :_)
15:46:53 <applicative> @quote proving -- found this looking for something about laziness
15:46:53 <lambdabot> No quotes for this person. Just what do you think you're doing Dave?
15:47:06 <applicative> @quote proving
15:47:06 <lambdabot> <JohnMeacham> says: of course any minute now oleg is going to come along and actually express the second law of thermodynamics via functional dependencies as a purely incidental part of improving
15:47:06 <lambdabot> HList syntax or something.
15:47:09 <applicative> @quote proving
15:47:09 <lambdabot> <JohnMeacham> says: of course any minute now oleg is going to come along and actually express the second law of thermodynamics via functional dependencies as a purely incidental part of improving
15:47:09 <lambdabot> HList syntax or something.
15:47:14 <applicative> forget  it!
15:47:30 <shachaf> @quote \bproving\b
15:47:30 <lambdabot> kmc says: "Haskell is great, because Curry-Howard!  Proving things in the type system.  We can prove that, uh, Ints exist, unless they're ⊥."
15:47:41 <applicative> in my separate conversation with lambdabot she is more forthcoming
15:47:51 <shapr> applicative: Which proving quote?
15:48:01 <shachaf> @quote \bproving\b
15:48:02 <lambdabot> roconnor says: wow, I suck at making test cases.  Too much time spent proving programs correct I guess...
15:48:14 <shachaf> @quote \bproving\b
15:48:15 <lambdabot> kmc says: "Haskell is great, because Curry-Howard!  Proving things in the type system.  We can prove that, uh, Ints exist, unless they're ⊥."
15:48:16 <shachaf> @quote \bproving\b
15:48:16 <lambdabot> kmc says: "Haskell is great, because Curry-Howard!  Proving things in the type system.  We can prove that, uh, Ints exist, unless they're ⊥."
15:48:21 <shachaf> Anyway, there are more.
15:49:12 <applicative> roconnor says: wow, I suck at making test cases.  Too much time spent proving programs correct I guess...
15:49:30 <applicative> ^^^ he's always been like that it seems
15:53:25 <monochrom> I am superb in both proving correctness and making test cases. in programming contests, my test cases stumble the best contestants
15:54:52 <shapr> If you don't use chrisdone's Hackage Enhancement Script, check it out! http://chrisdone.com/hes/
15:55:46 <monochrom> dislike disqus
15:55:55 <shapr> monochrom: Why so?
15:56:57 <monochrom> because I first encountered it on wired.com, and it was dog slow
15:58:00 <frerich_> dmwit, nand`: I have been playing around with peano numbers a bit (just "data PeanoNumber = Zero | Succ PeanoNumber") and just noticed that the type of "Succ undefined" is actually "PeanoNumber". I don't know what that should be, but I wouldn't say it's a number. I guess this is caused by "undefined" having any type you like. Is this a "bug" in the type system or so?
15:58:03 <frerich_> It confuses me a bit.
15:58:39 <eikke> frerich_: 'undefined' is of any type
15:58:47 <eikke> so yes, 'undefined' is als a PeanoNumber
15:58:55 <tgeeky> @type undefined :: Monad
15:58:55 <lambdabot>     Class `Monad' used as a type
15:58:56 <lambdabot>     In an expression type signature: Monad
15:58:56 <lambdabot>     In the expression: undefined :: Monad
15:58:56 <monochrom> Robert Harper certainly thinks it is a problem. I don't
15:59:03 <applicative> chrome wont let me install the Hackage Enhancement Script :(
15:59:14 <eikke> tgeeky: Monad is not a type, it's a type class
15:59:19 <ion> @type undefined :: Maybe (IO (Complex (Either String a)))
15:59:20 <lambdabot> forall a. Maybe (IO (Complex (Either String a)))
15:59:22 <tgeeky> eikke: yeah yeah :o
15:59:33 <tgeeky> eikke: sometimes I type faster than I think
16:00:01 * eikke considers that a bad habbit of programmers ;-) (might be related to the fact he only types with 3-4 fingers himself)
16:00:24 <monochrom> "Succ undefined" is no worse than "let x = Succ x in x"
16:00:26 <applicative> inf = Succ inf is what you'd expect frerich_
16:01:00 <monochrom> haskell is just a programming language, not a sound theorem prover
16:01:15 <monochrom> @quote kmc proving
16:01:15 <lambdabot> kmc says: "Haskell is great, because Curry-Howard!  Proving things in the type system.  We can prove that, uh, Ints exist, unless they're ⊥."
16:01:23 <monochrom> that is relevant
16:01:26 <shachaf> monochrom: Sure that's worse!
16:01:26 <eikke> although it can prove quite some things :) (been reading some Oleg lately...)
16:01:35 <shachaf> Oh, worse for CH. Right, no worse.
16:01:36 <applicative> there's nothing wrong with inf = Succ inf  one would however like another section of the language where it was forbidden
16:01:44 <ion> “fix Succ > 42” should work fine given the correct implementation, for instance.
16:01:44 <danr> frerich_: yeah, it's not very mathematical. Haskell Nats are riddled with bottoms. Maybe you want to try a language with only total values like Agda or Coq
16:02:58 <applicative> danr inf = Succ inf is not unmathematical in any sense; one would just like a few more equally mathematical options...
16:03:02 <danr> frerich_: you can, however, limit them to only one bottom by making data Nat = Succ !Nat | Zero
16:03:17 <danr> applicative: ok, sloppy of me, it's not very PA
16:03:55 <frerich_> Maybe I should just accept that "PEanoNumber" can represent all natural numbers - and then an infinite number of other values (since you could have any number of "Succ" calls nested and "undefined" in the middle)
16:03:58 <danr> of course there are mathematical objects such that fix Succ, but I was talking about models of Peano Arithmetic
16:04:43 <danr> frerich_: sounds like a pragmatic choice indeed
16:05:08 <kallisti> frerich_: the other values just represent non-terminating programs.
16:05:13 <monochrom> you may like "data P = Z | S !P". but it doesn't err at compile time
16:05:14 <zzing_> Anyone know when the next monad reader is coming out?
16:05:16 <ArtyomKazak> Haskell, schmaskell I think we should all move to Pascal, where such ridiculous problems just *cant* arise.
16:05:28 <kallisti> I'm not sure how it works in total languages, but in most languages you can't avoid non-termination.
16:05:30 <applicative> all nonstandard models of peano arithmetic first depart from the standard model by the addition of inf = Succ inf
16:06:11 <monochrom> non-strictness requires a lot of bottoms
16:06:38 <danr> applicative: no, forall x . x /= s(x) is provable in PA, so something with fix Succ is not a (non)standard model of PA
16:07:13 <kallisti> monochrom: no more than a strict language.
16:07:19 <frerich_> I don't get sleepless nights over this, but just out of curiousity (and I'm saying this as somebody who likes "undefined" a lot) - would it be a "defect" in the language if you didn't have such an odd value which always typechecks?
16:07:35 <ion> …likes undefined a lot?
16:07:39 <applicative> wait, danr let me think
16:07:50 <shachaf> ion: No, the value
16:07:53 <shachaf> "undefined" :: String
16:07:55 <monochrom> a strict language doesn't have 'x':⊥
16:07:59 <kallisti> frerich_: it's a useful property. for example it allows you to have "polymorphic loops"
16:08:00 <ion> Ah, of course.
16:08:08 <kallisti> monochrom: sure it does.
16:08:33 <kallisti> it just so happens that 'x':⊥ = ⊥
16:09:32 <kallisti> (modulo side-effects. let's assume we're talking about a pure, strict language)
16:09:49 <ion> Assume the horse is perfectly spherical.
16:10:10 <applicative> danr yes a muddle, i was thinking of something else, ... 3 2 1 is the crucial element in non standard models
16:10:39 <tromp> 'x':⊥ /= ⊥
16:10:41 <danr> applicative: what do you mean by "... 3 2 1"?
16:10:53 <kallisti> tromp: in what context? we were talking about strict languages.
16:11:29 <tromp> in a lazy context:)
16:11:53 <applicative> something isomorphic to the numbers backward, if i glue that on the regular numbers, and then glue a copy of the regular numbers onto that, for example
16:12:15 <applicative> 1,2,3... ... 3
16:12:17 <d-snp> I have to write a short introduction to haskell for the readers of my paper who are not familiar with it.. how to start :|
16:12:39 <kallisti> d-snp: maybe try similar approaches to existing papers?
16:12:44 <ion> d-snp: With a monad tutorial.
16:12:47 <applicative> 0, 1,2,3... ... 3',2',1',0' ,  1'', 2'' ...
16:12:52 <kallisti> d-snp: SPJ gives a lot of cursory introductions to Haskell in his papers.
16:13:00 <frerich_> I think such a "one size fits all" value as undefined "weakens" the compiler a bit because you can whip up expressions which clearly make no sense in a context (say "length undefined") and yet typecheck. I suppose the advantages of having such a value (I would have called it "morph" because it can morph into anything you like) outweigh this "disadvantage"
16:13:45 <danr> applicative: a very constructive approach. yes. but also notice that none of your primed elements have themselves as predecessor
16:13:48 <shachaf> frerich_: _|_ is unavoidable in a Turing-complete language.
16:13:50 <frerich_> Hm OTOH "someFunction = undefined" is neat, too.
16:14:11 <shachaf> As such, people made a convenient value that errors rather than looping (but is denotationally the same).
16:14:25 <kallisti> frerich_: it's a necessary concession for any language that allows non-termination at any point, which is a powerful capability.
16:14:28 <shachaf> If people could do without _|_, they definitely would. :-)
16:14:43 <shachaf> There's no "advantage" to undefined on its own, though.
16:14:58 <kallisti> :t forever
16:14:59 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b
16:15:23 <shachaf> forever' :: m a -> m ()
16:15:41 <kallisti> frerich_: here's another place where bottom crops up. this one can do useful things.
16:15:50 <ion> Well, it *can* be convenient for stubbing functions you’re about to implement for some nearby code to typecheck, but those shouldn’t appear in finished code. :-)
16:16:00 <applicative> danr, I was thinking they all did, I'm thinking  of a sequence, map Right [1..] ++ map (Left.Right) (reverse [1...]) ++ map (Left.Left) [1..]  ... so to speak
16:16:02 * kallisti uses undefined for stubs frequently.
16:16:37 <shachaf> There are better mechanisms for stubs than that.
16:16:47 * frerich_ assumes "bottom" and "_|_" and "undefined" are different names for the same thing.
16:17:01 <shachaf> No, undefined is a specific _|_
16:17:15 <shachaf> Another one is "let x = x in x"
16:17:22 <kallisti> they're all bottom. GHC lets you distinguish undefined from non-termination via asynchronous exceptions, but this doesn't affect pure code.
16:17:24 <shachaf> @google what is bottom undefined haskell
16:17:26 <lambdabot> http://www.haskell.org/haskellwiki/Bottom
16:17:26 <lambdabot> Title: Bottom - HaskellWiki
16:17:30 <shachaf> You should read that. :-)
16:17:34 <zzing_> If I wanted to work with a versioning file store, is filestore-0.5 good enough to work with or is there a better one?
16:18:23 <ion> > floatDigits (undefined :: Double)  -- Although this should use a Proxy instead
16:18:24 <lambdabot>   53
16:18:24 <kallisti> zzing_: I don't know of any others.
16:19:38 <kallisti> frerich_: so there's a useful practical distinction between undefined (an exception) and non-termination, but in terms of pure computations they're equivalent semantically (both produce undefined results).
16:20:11 <kallisti> @hoogle spoon
16:20:12 <ion> floatDigitsP et al. https://gist.github.com/1188115#L47
16:20:12 <lambdabot> package spoon
16:20:12 <lambdabot> package spoonutil
16:20:17 <kallisti> @hackage spoon
16:20:18 <lambdabot> http://hackage.haskell.org/package/spoon
16:20:47 <kallisti> for example this library will take some kinds of exceptions and wrap them in a Maybe.
16:21:09 <kallisti> which allows you to things like derive safeHead :: [a] -> Maybe a   from head :: [a] -> a
16:21:22 <applicative> danr so the predecessor of Left (Right 2) is Left (Right 3) , in the second copy.
16:21:59 <shachaf> kallisti: I think it's a bad idea to tell people about spoon who don't know what _|_ is.
16:22:17 <applicative> danr but I need more points, I'm a couple uh decades out of practice
16:22:30 * kallisti inserts "WARNING DANGER unsafePerformIO WARNING DANGER breaks standard semantics" boilerplate
16:22:48 <bitonic> kallisti: especially if you said that non-termination and `undefined' are the same in terms of "pure computation", since spoon works with one of the two only  :P
16:22:52 <ion> That’s why i always use safePerformIO :: IO a -> a
16:23:57 <applicative> danr ooh ick more trouble than I thought indeed "Any countable nonstandard model of arithmetic has order type ω + (ω* + ω) · η, where ω is the order type of the standard natural numbers, ω* is the dual order (an infinite decreasing sequence) and η is the order type of the rational numbers."
16:24:22 <frerich_> kallisti: I'm not a computer scientist, so I wonder - is there any use of knowing that non-termination and an error are the same in terms of "pure computation" even though they have very obvious differences in a Haskell program?
16:24:25 * applicative at least had a decreasing sequence
16:24:41 <kallisti> spoon is an example of using the practical distinction between undefined and non-termination to break the rules and define safe functions from partial ones. it's not an example of how they're both bottom.
16:25:20 * applicative wonders, maybe it can haskellized
16:25:23 <kallisti> frerich_: it's not possible to define an algorithm that can, in general, determine that any given program will halt.
16:25:33 <kallisti> you can catch special cases though.
16:25:35 <bitonic> frerich_: it is useful when reasoning about the meaning of a program, and also in making peace with why they let something like `undefined' exist at all
16:26:45 <frerich_> Oh I'm simple minded, I can sleep very well with just knowing that "undefined" is important and here to stay, and it helps to be aware of it. :)
16:26:46 <ion> halts :: a -> Bool
16:27:09 <shachaf> halts !x = True
16:27:26 <ion> Indeed
16:27:33 <frerich_> I've been programming for so many years and enjoyed it a lot without even being aware of something called "bottom" so as far as I'm concerned, I can have a happy live without understanding it fully ;-)
16:27:47 <mikeplus64> but that can only ever possibly return True
16:27:57 <kallisti> frerich_: bottom is useful for reasoning about laziness.
16:28:09 <bitonic> shachaf: genius
16:28:19 <ion> mikeplus64: halts !x = True; halts _ = False
16:28:29 <bitonic> better, `halts x = deepseq x True
16:28:30 <bitonic> frerich_: it's really not hard. people love to make up names for simple things
16:28:30 <mikeplus64> :|
16:28:33 <danr> applicative: yeah I guess omega* + omega is the ordering of Z
16:28:39 <kallisti> frerich_: a function that's strict in its argument will obey this rule:  f _|_ = _|_
16:28:47 <kallisti> frerich_: this is true for both "undefined" and "let x = x in x"
16:28:47 <danr> applicative: anyway, I need some sleep :) let's talk about nonstandard models of PA later
16:30:08 <kallisti> frerich_: for example  (True&&) is strict in its argument because True && _|_ = _|_; but (False&&) is not because False && _|_ = False
16:30:50 <kallisti> you can test this out yourself:
16:31:10 <kallisti> > (False && undefined, let x = x in False && x)
16:31:11 <lambdabot>   (False,False)
16:31:18 <kallisti> > True && undefined
16:31:20 <lambdabot>   *Exception: Prelude.undefined
16:31:28 <frerich_> Hm ah well, my little one will get up in about four hours, so I'll better call this a night (at this point I have to resist the urge to come up with silly puns involving babies, bottoms, wifes and strict)
16:31:29 <kallisti> > let x = x in True && x
16:31:33 <lambdabot>   mueval-core: Time limit exceeded
16:31:53 <eikke> > let x = x in True || x
16:31:55 <lambdabot>   True
16:32:00 <eikke> > let x = x in x || True
16:32:04 <lambdabot>   mueval-core: Time limit exceeded
16:32:08 <frerich_> Thanks y'all for the interesting (to me) chat :-)
16:32:41 <bitonic> frerich_: night
16:34:20 <d-snp> thanks kallisti I'll search for one
16:35:06 <d-snp> ion: since the paper is about IO in Haskell, I actually explain the io monad in detail in the next chapter
16:35:48 <kallisti> d-snp: I don't remember what I did. but no problem!
16:36:46 <kallisti> d-snp: oh right. you could read the papers on STM as an example.
16:37:38 <Cale> What's your paper about overall d-snp?
16:40:13 <d-snp> Cale: I explore implementing a transport layer protocol in 3 different I/O styles, monadic, streams and continuation passing
16:40:32 <shachaf> Monadic *is* "continuation-passing". :-)
16:40:57 <d-snp> I meant the asynchronous way, like javascript does
16:41:17 <d-snp> and haskell also did, some time long ago
16:41:18 <mauke> 'm a' and 'a -> m b' looks like a continuation/async callback to me
16:41:59 <d-snp> you could also see an io monad like a stream if you look at it sideways
16:42:05 <d-snp> they are all a model of the same thing
16:42:31 <shachaf> I don't really see it as a stream...
16:42:54 <Cale> shachaf: Have you seen how I/O worked in early Haskells?
16:43:04 <mauke> I like to explain IO in terms of javascript
16:43:04 <shachaf> Cale: Sure, but that's a different thing.
16:43:23 <mikeplus64> mauke: "evil, avoid at all costs"
16:43:26 <mikeplus64> ;)
16:43:33 <mauke> what?
16:43:43 <shachaf> Cale: I mean, [Response] -> [Request] is almost like lazy I/O
16:44:05 <shachaf> Whereas a simplified version of IO can be modeled without anything evil like that.
16:45:37 <Cale> The weird thing about monadic style vs. continuation passing is that you're not passing the continuation to the actions that are being run, you're passing it to another combinator, and it's gluing things together for you.
16:46:04 <zachk> isn't the beauty of it as well?.
16:46:07 <Cale> yes
16:46:39 <d-snp> I've been thinking about the continuation passing style a bit, and it might be the most awkward style of the three
16:47:10 <d-snp> streambased actually has some nice advantages over monadic style when it comes to concurrency
16:47:41 <d-snp> you'll hear all about when my report takes the academic world by storm
16:47:43 <d-snp> :P
16:47:48 <d-snp> (undergraduate speaking ;))
17:02:13 <zzing_> Can anyone think of a good name for something that serves markdown files into a template? I am thinking of it almost like a webserver who's public_html is filled with markdown files and you choose a template theme. Meant to be fairly basic.
17:03:47 <AfC> zzing_: I inevitably use "render" for that.
17:04:27 <AfC> zzing_: ie render.php, or the render Snap action, or...
17:05:43 <zzing_> hmm, render sounds too generic
17:05:47 <zzing_> But it might be on the right course
17:09:24 * hackagebot seqloc 0.5.1.0 - Handle sequence locations for bioinformatics (NicholasIngolia)
17:11:24 <dmwit> zzing_: One standard word for that is "interpolation", as unlikely as it sounds.
17:11:37 <applicative> Isn't there some thought of 'automatic deriving' of 'singleton types' associated with the new fancy kinds
17:12:00 <zzing_> "Insert (something) between fixed points."
17:12:07 <zzing_> That about right
17:19:30 <tomprince> :t >=>
17:19:31 <lambdabot> parse error on input `>=>'
17:19:37 <tomprince> :t (>=>)
17:19:38 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
17:20:41 <Cale> :t (<=<)
17:20:44 <lambdabot> forall b (m :: * -> *) c a. (Monad m) => (b -> m c) -> (a -> m b) -> a -> m c
17:20:59 <Cale> It's like composition (.) :: (b -> c) -> (a -> b) -> (a -> c)
17:21:17 <applicative> :t show >=> show
17:21:19 <lambdabot> forall a. (Show a) => a -> [Char]
17:21:33 <applicative> > (show >=> show) 33
17:21:34 <lambdabot>   "'3''3'"
17:22:20 <applicative> > (show >=> show >=> show) 33
17:22:22 <lambdabot>   "'\\'''3''\\'''\\'''3''\\''"
17:27:30 <Cale> > fix show
17:27:32 <lambdabot>   "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\...
17:28:11 <Cale> > text $ fix show
17:28:17 <lambdabot>   mueval: ExitFailure 1
17:28:17 <lambdabot>  mueval: Prelude.undefined
17:28:22 <Cale> heh
17:28:27 <dada_cetacean> is there a special reason why there are n-tuples for every natural n but 1?
17:28:38 <Cale> dada_cetacean: because 1-tuples are just values
17:29:09 <Cale> (basically -- I suppose they're lifted so they have an extra bottom value)
17:29:25 * hackagebot unification-fd 0.8.0 - Simple generic unification algorithms. (WrenThornton)
17:30:00 <Cale> also, what would the notation look like?
17:30:06 <c_wraith> dada_cetacean: an important factor is that there is *no* relationship between different tuple sizes in haskell.  They're different types with nothing in common.
17:30:29 <c_wraith> dada_cetacean: because of that, there's no real gain in generalizing to 1-tuples
17:30:35 <Axman6> we do have 1-tuples
17:30:41 <Axman6> > (1)
17:30:43 <Cale> There is the Identity functor
17:30:45 <lambdabot>   1
17:30:46 <Axman6> but they get optimised away
17:30:50 <Cale> ;)
17:30:56 <applicative> http://hackage.haskell.org/package/OneTuple-0.2.1
17:32:11 <dmwit> I sometimes wonder.
17:32:21 <dmwit> Just how much do newtypes get optimized away?
17:32:45 <c_wraith> I'm pretty sure map Foo doesn't get optimized to id
17:32:56 <applicative> "OneTuple fills the *tuple gap* with a singleton tuple." -- "with the expected laziness properties" ...
17:33:44 <applicative> it seems impossible with recursive newtypes
17:34:01 <applicative> e.g. newtype Void = Void Void
17:35:07 <shachaf> c_wraith: But unsafeCoerce does!
17:35:41 <shachaf> Of course, unsafeCoerce :: Set (Newtype a) -> Set a is broken.
17:35:43 <c_wraith> shachaf: yes.  and once upon I time, I observed with some amusement that fmap unsafeCoerce and unsafeCoerce are the same operation (for correct fmap implementations)
17:36:35 <shachaf> c_wraith: Not for FunctorWithConstraintKind!
17:36:56 <shachaf> I guess regular Functors are always completely polymorphic so it works.
17:37:18 <c_wraith> yeah, it depends on parametricity
17:42:13 <SegFaultAX|work2> With regard to the monomorphism restriction, I don't understand why len is evaluated twice in the example given here: http://www.haskell.org/haskellwiki/Monomorphism_restriction
17:42:50 <Cale> another fun thing to do with unsafeCoerce is to add a bunch of RULES pragmas which replace fromIntegral with unsafeCoerce when you know that the types have the same representation.
17:43:25 <Cale> SegFaultAX|work2: because the two occurrences of len *might* be different types
17:43:39 <Cale> SegFaultAX|work2: len is secretly a function of the typeclass dictionary
17:43:53 <dolio> > fromIntegral (fromIntegral (2^10) :: Word8) :: Word32
17:43:55 <lambdabot>   0
17:44:08 <mauke> another fun thing to do with unsafeCoerce is unsafeCoerce (Magic k) (const a) Proxy
17:44:20 <SegFaultAX|work2> Cale: But how could they be if the type of xs is known?
17:44:20 <lusche> SeqFaultAX|work2: consider (x::Int, y::Dounle) = len [1,2,3]
17:44:36 <Cale> SegFaultAX|work2: for example, one might be Integer, and the other Double
17:44:43 <mauke> SegFaultAX|work2: why would the type of xs matter?
17:44:52 <SegFaultAX|work2> mauke: It wouldn't disregard that.
17:44:55 <mauke> ?
17:45:03 <SegFaultAX|work2> mauke: :D I derp'd.
17:45:54 <SegFaultAX|work2> Cale: Oh, because I might call the `f xs :: (Int, Double)`?
17:46:07 <Cale> SegFaultAX|work2: right
17:46:17 <SegFaultAX|work2> Cale: Oh, that makes sense.
17:46:20 <SegFaultAX|work2> Thanks :)
17:47:11 <SegFaultAX|work2> Cale: But genericLength wouldn't be evaluated twice if called like `f xs` or even `f xs :: (Int, Int)`, right?
17:47:21 <Cale> no, it still would
17:47:31 <SegFaultAX|work2> Even in the latter case?
17:47:35 <mauke> yes
17:47:38 <Cale> because the compiled code for f won't check that the two dictionaries are identical
17:47:49 <dolio> Even if f's return type is specifically (Int, Int).
17:48:10 <Cale> It just gets two implementations of the Num operations as a hidden parameter
17:48:16 <Cale> and uses them in the appropriate place
17:48:25 <SegFaultAX|work2> Understood.
17:48:32 <SegFaultAX|work2> Thanks everyone!
17:48:48 <Cale> also, common subexpression elimination tends not to be done
17:48:55 <Cale> except in some trivial and unlikely cases
17:49:07 <Cale> (nested case expressions with the same scrutinee)
17:49:33 <Cale> So generally if you write  (length [1,2,3], length [1,2,3]) it'll compute it twice anyway
17:49:43 <SegFaultAX|work2> As an unrelated side note, is it important that I read the Haskell report at some point?
17:49:51 <Cale> It's probably not a bad idea
17:50:05 * shachaf has never read it.
17:50:11 <shachaf> Well, it may be that I've read all of it.
17:50:14 <shachaf> But not beginning-to-end.
17:50:22 <SegFaultAX|work2> Not in one sitting.
17:50:27 <shachaf> No, I probably haven't read all of it. :-)
17:50:37 <SegFaultAX|work2> :D
17:51:06 <Cale> It explains stuff like how numeric defaulting works, which you're unlikely to learn from most tutorials.
17:51:36 <shachaf> But you're likely to learn it from being in #haskell.
17:51:46 <Cale> true :)
17:52:31 <shachaf> And also how ghci defaulting works.
17:52:45 <Cale> yeah, the GHC user's guide is full of good stuff too
17:53:02 <lusche> megamonad, are you still there?
17:53:29 <Cale> Wow, when was the last time megamonad was here?
17:53:41 <mauke> preflex: seen megamonad
17:53:41 <preflex>  Sorry, I haven't seen megamonad
17:53:49 <Cale> I was going to say I'd ask preflex, but I think it predates preflex...
17:53:52 <mauke> yep
17:54:54 <Cale> I remember when this channel had only a couple dozen people in it :)
17:54:56 <lusche> sorry, just wasted time on the quotes page
18:27:11 <copumpkin> in cereal, should isolate <len> <get action> be equivalent to bs <- getByteString len; runGet <get action> bs
18:27:11 <copumpkin> assuming types match up and such
18:28:50 <hpaste> mkramer pasted “run length encoding: more stumbling in the dark” at http://hpaste.org/71242
18:29:12 <mkramer> guys, what is a monomorphism restriction? (error shown in paste)
18:29:26 <mkramer> I'm trying to do run length encoding, and this function looks perfectly sensible to me
18:29:33 <shachaf> @google what is a monomorphism restriction?
18:29:34 <lambdabot> http://www.haskell.org/haskellwiki/Monomorphism_restriction
18:29:35 <lambdabot> Title: Monomorphism restriction - HaskellWiki
18:30:20 <shachaf> The short answer is "add a type signature".
18:30:47 <shachaf> There are other answers, but if you don't know what the monomorphism restriction is you should probably have type signatures for all top-level functions. :-)
18:33:15 <ultrabang> IS ANYBODY OUT THERE!?!
18:33:32 <ultrabang> HELLO!?!
18:33:44 <ultrabang> IS ANYBODY HERE!?!
18:33:51 <copumpkin> ultrabang: please calm down
18:33:58 <copumpkin> there are over 850 people here
18:34:04 <hpaste> mkramer pasted “What's wrong with this type?” at http://hpaste.org/71243
18:35:14 <ultrabang> THANK GOD, I AM CALM!!!
18:35:14 <copumpkin> please don't write in all-caps then
18:35:14 <copumpkin> that's generally interpreted as yelling in a text-only environment
18:35:14 <mkramer> shachaf: Alright, I tried to add a type signature, but now ghc is giving me a different, equally cryptic type error :)
18:35:14 <zephyrtronium> you can continue using three punctuation marks though!!!
18:35:14 <copumpkin> ultrabang: do you have a question about haskell?
18:35:14 <mauke> :t map (\x -> ((length x), (head x))) . group
18:35:14 <ultrabang> yes
18:35:14 <lambdabot> forall a. (Eq a) => [a] -> [(Int, a)]
18:38:43 <ultrabang> i do have a question about haskell
18:38:43 <mauke> mkramer: your type signature is wrong
18:38:43 <mkramer> oh…right
18:38:43 <mkramer> I'm heading it
18:38:43 <ultrabang> i program in python for gis applications and was wondering about how haskell compares to python
18:38:43 <zephyrtronium> they compare not equal
18:38:43 <ultrabang> duh
18:38:43 <ultrabang> let me rephrase
18:38:43 <copumpkin> they are very different
18:38:43 <copumpkin> not even sure where to start comparing them
18:38:43 <ultrabang> how would learning haskell improve my abilities in python
18:38:43 <ultrabang> ?
18:38:43 <mauke> it could make you hate python
18:38:43 <zephyrtronium> by increasing your ability to learn new things
18:38:43 <nohonor> what mauke said
18:38:47 <nohonor> also, it could improve your ability to approach problems in a structured manner
18:38:57 <ultrabang> ^^^ this
18:38:59 <ultrabang> why?
18:40:00 <ultrabang> TELL ME NOW!!!
18:40:24 <copumpkin> ultrabang: people here don't exist to satisfy you. Please calm down and be civil
18:40:25 <nohonor> let me think...
18:40:37 <ultrabang> ok ok ok
18:40:47 <mauke> ultrabang: ＳＵＰＥＲ ＧＲＥＥＮ
18:41:08 <ultrabang> hwah?
18:41:14 <nohonor> haskell code tends to be vastly more structured than that written in procedural languages
18:41:53 <nohonor> it forces you to think and conceptualize
18:41:56 <copumpkin> anyone know why I'm getting different results from getByteString + runGet than I would with isolate?
18:41:59 <copumpkin> in cereal
18:42:31 <ultrabang> i think and conceptualize in python already, homie
18:42:48 <nohonor> right
18:43:05 <ultrabang> why is a functional language like haskell more structured?
18:43:13 <dada_cetacean> does anyone here know a website (not project euler) that has good general programming exercises not specific to any language?
18:43:23 <mauke> dada_cetacean: spoj.pl?
18:43:29 <blackdog> ultrabang: you have to be explicit about what your program might do
18:44:15 <blackdog> ultrabang: so, if i have a function foo with the type ([a] -> [a]), I know it takes a list of an arbitrary type, and returns a list of that type
18:44:15 <ultrabang> lets say i'm running a porn server and i want my jimmies to go all wahoo!!!
18:44:35 <blackdog> whereas foo :: [a] -> IO [a] might delete your hard drive before returning the list, like you could in python.
18:44:46 <nohonor> dada_cetacean, http://codekata.pragprog.com/
18:45:14 <copumpkin> heh
18:45:17 <copumpkin> so just a troll
18:48:02 <blackdog> copumpkin: better to be hopeful and disappointed than cynical :)
18:48:40 <copumpkin> :)
19:12:25 <CSWookie> HHM
19:14:02 <CSWookie> Are y'all seeing these things?
19:14:34 <solrize> ultragreen http://wiki.python.org/moin/PythonVsHaskell
19:15:07 <solrize> http://www.reddit.com/r/haskell/comments/w2jiv/how_pythoners_view_haskell_compared_with_python/
19:15:08 <Cale> ...
19:15:22 <Cale> I wonder what things CSWookie was seeing
19:17:51 <solrize> dada_cetacean, i like rubyquiz.com even though i don't use ruby.  i've done some of the exercises in haskell.
19:19:28 * hackagebot split-channel 0.1.1.0 - Control.Concurrent.Chan split into sending and receiving halves. (LeonSmith)
19:20:32 <copumpkin> type SHAT m a = ReaderT SHACtx m a
19:26:04 <Cale> copumpkin: name the library Shatner
19:26:10 <copumpkin> lol that's not mine :)
19:26:14 <copumpkin> it's in SHA2
19:26:14 <copumpkin> :)
19:27:30 <copumpkin> cereal doesn't have the combinator I want!
19:29:29 * hackagebot seqloc 0.5.1.1 - Handle sequence locations for bioinformatics (NicholasIngolia)
19:30:36 <copumpkin> I'd like a combinator that does Get a -> Get (a, Int) or Get a -> Get (a, ByteString)
19:30:50 <copumpkin> showing me the (length of the) chunk that was consumed by the given action
19:33:23 <parcs`> doesn't it have something like getRemaining :: Get Int?
19:33:58 <copumpkin> how does that help me? I can find out getRemaining before and getRemaining later, but I need the bytestring in between
19:34:06 <copumpkin> oh, I think I can do it in a roundabout way
19:36:35 <parcs`> you said (a,Int) or (a,ByteString)
19:36:57 <copumpkin> yeah, if (a, Int) I need it not to consume the input
19:37:01 <copumpkin> but this looks like it'll work
19:39:33 <copumpkin> hmm, maybe not
19:41:17 <copumpkin> oh, gah
19:43:49 <hpaste> copumpkin pasted “cereal” at http://hpaste.org/71244
19:47:37 <copumpkin> any ideas?
19:50:56 <copumpkin> I need this because I need to parse a binary structure and hash its data
19:51:48 <lars-> hello. is there a way to refer to the last value in the repl
19:51:53 <copumpkin> it
19:52:02 <lars-> thanks
19:52:40 <lars-> is it a variable or what?
19:53:17 <lars-> (it can't be, since variables can't be mutated?)
19:53:27 <copumpkin> bindings can be changed
19:53:48 <shachaf> ghci puts an implicit "let it =" or "it <-" in front of expressions/IO actions.
19:53:55 <shachaf> Or you can think of it as doing that.
19:59:43 <siracusa> > it
19:59:45 <lambdabot>   Not in scope: `it'
20:08:31 <augur> http://www.reddit.com/r/haskell/comments/wd5rb/deriving_the_y_combinator_from_first_principles/
20:08:36 <augur> everyone should totally comment
20:08:52 <copumpkin> http://stackoverflow.com/questions/11424961/having-my-cereal-and-parsing-it-too
20:08:55 <copumpkin> everyone should totally answer
20:09:25 * augur parses copumpkin's cereal
20:09:26 <augur> ;o ;o ;o
20:09:44 * copumpkin wonders if someone will edit his title to make it more informative
20:10:30 <augur> i would reply to that, if i knew anyting about it
20:10:43 <copumpkin> it's the thought that counts! thankee
20:11:34 <augur> HINT HINT
20:16:01 <dolio> copumpkin: I have a theory.
20:16:37 <dolio> remaining uses moreLength. moreLength looks at More. More contains a Maybe Int. If it's Nothing, it uses 0.
20:17:21 <dolio> So you could ask for remaining, it could return 5, because it doesn't know anything about the next chunk. Then you parse and get to the next chunk, and it's bigger than 5. So your remaining is now bigger than 5.
20:18:59 <parcs`> what about doing lookAhead twice?
20:21:38 <zzing_> It seems the haskell-cabal mode in emacs likes tabs when cabal doesn't
20:43:13 <newsham> copumpkin: i believe I added a hack to data.binary.get to do that once
20:53:12 <newsham> hmm i take that back i think i just added code to track the position
21:20:13 <zzing_> Is it possible to specify a data structure that is defined in and is locally available only in a function?
21:20:30 <adu> oOo local data
21:20:34 <adu> zzing: no
21:20:39 <zachk> yo mean like  a Data?
21:20:48 <zachk> use a seperate module and do exports to do something like that
21:21:04 <zzing_> not really necessary, just curious
21:21:08 <zzing_> :t fromMaybe
21:21:11 <lambdabot> forall a. a -> Maybe a -> a
21:21:33 <zzing_> :t intercalate
21:21:35 <lambdabot> forall a. [a] -> [[a]] -> [a]
21:22:17 <zzing_> :t error
21:22:18 <lambdabot> forall a. [Char] -> a
21:24:18 <zzing_> What does it look like this does?    (mci,errs) <- runWriterT $ do …. return … ;;         let ci = fromMaybe (error $ intercalate "\n" errs) mci     I am not sure precisely
21:24:49 <shachaf> "error" has nothing to do with "WriterT".
21:24:55 <shachaf> Please don't use "error".
21:24:59 <zzing_> I am just showing where this come from
21:25:54 <zzing_> What does error do
21:26:23 <shachaf> Crashes your program.
21:26:28 <shachaf> (Really.)
21:26:43 <zzing_> So it is guarantees termination :P
21:26:51 <otters> if evaluated
21:26:59 <shachaf> Some people would say it gurantees nontermination. :-)
21:27:01 <shachaf> But yes.
21:27:12 <zzing_> That is used in snaplet-postgresqlsimple
21:27:29 <zzing_> I wonder what is the best way to fail then
21:27:56 <copumpkin> dolio: hmm, that would make sense, but it makes remaining pretty useless
21:28:03 <dolio> Yep.
21:28:20 <shachaf> dolio: Your evil twin was here the other day.
21:28:31 <dolio> Oh yeah?
21:28:34 <copumpkin> anyone have any other ideas for how to do it, without modifying the underlying library as newsham did? :)
21:28:36 <dolio> Did he have a goatee?
21:28:42 <shachaf> He was reversing a bunch of arrows and all sorts of crazy things before we finally caught and executed him.
21:28:46 * copumpkin tries to imagine dolio with a goatee
21:29:00 <isomorphic> shachaf: executed or evaluated?
21:29:05 <shachaf> Executed.
21:29:34 <otters> "Hang on, son. We'll need to evaluate you before you're executed."
21:32:07 <Nereid> oh you. -> <shachaf> Some people would say it gurantees nontermination. :-)
21:32:25 <otters> define termination
21:32:36 <shachaf> otters: No thanks.
21:32:55 <otters> :P
21:33:09 <drbean> What's the right way to do this: all (\x -> fst x == snd x ) $ zip "was" "wasn't"
21:33:25 <shachaf> Is that way wrong?
21:33:34 <otters> :t uncurry (==)
21:33:36 <lambdabot> forall a. (Eq a) => (a, a) -> Bool
21:33:40 <otters> that'll do it!
21:33:49 <shachaf> Oh, that.
21:34:06 <otters> > all (uncurry (==)) $ zip "was" "wasn't"
21:34:07 <lambdabot>   True
21:34:11 <shachaf> You can also and .: zipWith (==) or something.
21:34:24 <otters> > zipWith (==) "was" "wasn't"
21:34:26 <lambdabot>   [True,True,True]
21:34:29 <zzing_> :t fromMaybe
21:34:31 <lambdabot> forall a. a -> Maybe a -> a
21:34:33 <otters> :t (and .:)
21:34:34 <lambdabot> forall (f :: * -> *) (g :: * -> *). (Functor f, Functor g) => f (g [Bool]) -> f (g Bool)
21:34:48 <shachaf> otters: Confuse people somewhere else, man.
21:35:02 <otters> But this is #haskell.
21:35:20 <otters> It's finally the day when I get to be the confusER instead of the confusEE
21:35:23 <shachaf> Good point, I guess.
21:35:25 <shachaf> > (\x y -> zipWith const x y == zipWith const y x) "was" "wasn't"
21:35:26 <lambdabot>   True
21:37:02 <dolio> @type uncurry . unzip . zip
21:37:03 <lambdabot>     Couldn't match expected type `a -> b -> c'
21:37:03 <lambdabot>            against inferred type `([a1], [b1])'
21:37:03 <lambdabot>     In the first argument of `(.)', namely `unzip'
21:37:10 <dolio> @type uncurry . unzip .: zip
21:37:12 <lambdabot>     Couldn't match expected type `b -> c'
21:37:12 <lambdabot>            against inferred type `([a], [b1])'
21:37:12 <lambdabot>     In the first argument of `(.:)', namely `unzip'
21:37:31 <shachaf> @ty (uncurry (==) . unzip) .: zip
21:37:33 <lambdabot> forall b. (Eq b) => [b] -> [b] -> Bool
21:37:55 <thetallguy1> @type .:
21:37:56 <lambdabot> parse error on input `.:'
21:38:03 <thetallguy1> @type (.:)
21:38:05 <lambdabot> forall a b (f :: * -> *) (g :: * -> *). (Functor f, Functor g) => (a -> b) -> f (g a) -> f (g b)
21:38:12 <shachaf> thetallguy1: It's just (.) . (.)
21:38:26 <thetallguy1> roger
21:38:28 <thetallguy1> thx
21:39:22 <thetallguy1> you mean fmap . fmap?
21:39:43 <shachaf> I mean (.) . (.)
21:39:55 <shachaf> It happens that (.) = fmap but that's not relevant here.
21:41:36 <thetallguy1> okay, I don't follow that
21:41:52 <Nereid> blame cale
21:41:54 <thetallguy1> the type signature given by lambdabot matches fmap . fmap
21:42:05 <Nereid> lambdabot has (.) = fmap
21:42:09 <Nereid> instead of the usual prelude (.)
21:42:15 <shachaf> @let realdotcolon f g x y = f (g x y)
21:42:17 <lambdabot>  Defined.
21:42:18 <shachaf> @ty realdotcolon
21:42:19 <lambdabot> forall t2 t3 t t1. (t2 -> t3) -> (t -> t1 -> t2) -> t -> t1 -> t3
21:42:41 <shachaf> @ty \f x g y z -> f x (g y z)
21:42:43 <lambdabot> forall t t1 t2 t3 t4. (t -> t3 -> t4) -> t -> (t1 -> t2 -> t3) -> t1 -> t2 -> t4
21:42:46 <shachaf> @pl \f x g y z -> f x (g y z)
21:42:46 <lambdabot> (((.) . (.)) .)
21:42:51 <thetallguy1> Yeah, okay, (->)
21:42:59 <shachaf> @pl \f x g y z -> f (g x y z)
21:42:59 <lambdabot> (. flip id) . (.) . (.) . (.)
21:45:49 <copumpkin> I'm starting to think I can't write this without looking at the internals of cereal
21:45:54 <copumpkin> and they don't expose them
21:45:55 * copumpkin sighs
21:46:58 <newbiehs> Hello
21:47:03 <pesciolino> !list
21:47:08 <pesciolino> ciao a tt
21:47:11 <pesciolino> !lòist
21:47:14 <pesciolino> !list
21:47:57 <newbiehs> I'm using the "try Haskell" and cant seem to get to the lesson after step9 in lesson 2
21:48:37 <shachaf> newbiehs: What are you doing?
21:49:39 <newbiehs> i just did the example let villain = (28,"chirs") in fst villain
21:49:52 <newbiehs> but nothing happens after i get the value of 28
21:49:59 <shachaf> Strange. Works for me
21:50:13 <zzing_> let villain = (28, "chirs") in fst villain   works fine for me in firefox
21:50:14 <copumpkin> omg haskell is a buggy shit language
21:50:16 <zzing_> what browser you using
21:50:16 <shachaf> You can just type "step10" to go on.
21:50:16 <copumpkin> use php n00b
21:50:43 * zzing_ hugs copumpkin to death
21:50:53 <newbiehs> schachaf step10 woked thanks :)
21:50:55 <copumpkin> :)
21:51:16 <newbiehs> *worked
21:51:44 <zzing_> muevel looks nice
21:52:47 <zzing_> How this for an idea - implement nano in a jquery-console :-)
21:59:13 <zzing_> If I end up using filestore what backend should I use? There is git and darcs, I don't know enough to be sure which to use.
22:01:33 <zzing_> @hoogle Maybe a -> b -> Either b a
22:01:35 <lambdabot> Text.ParserCombinators.Parsec.Prim runParser :: GenParser tok st a -> st -> SourceName -> [tok] -> Either ParseError a
22:01:35 <lambdabot> Text.Parsec.Prim runP :: Stream s Identity t => Parsec s u a -> u -> SourceName -> s -> Either ParseError a
22:01:35 <lambdabot> Text.Parsec.Prim runParser :: Stream s Identity t => Parsec s u a -> u -> SourceName -> s -> Either ParseError a
22:03:17 <copumpkin> :t (`maybe` Right) . Left
22:03:18 <lambdabot> forall a a1. a1 -> Maybe a -> Either a1 a
22:04:13 <isomorphic> Has anybody recently attempted to use the package paypal-api (or alternatively, recommend a good way to interface with the Paypal API?)
22:04:38 <zzing_> copumpkin, I want something to take Maybe a and a b and if it is Nothing, then do a Left b, and if it is Just a, do a Right a - does that do it?
22:04:45 <copumpkin> zzing_: try it!
22:04:53 <copumpkin> zzing_: but looking at the types, it doesn't really have much other choice :)
22:05:10 <otters> > data Foo = forall a. Foo a
22:05:11 <lambdabot>   <no location info>: parse error on input `data'
22:05:14 <otters> nuts
22:05:56 <zzing_> ∀a. Foo a :P
22:07:35 <otters> existential quantification is so weird...
22:07:48 <otters> data HeteroList = Nil | forall a. Cons a HeteroList
22:07:55 <otters> a list that can hold ANYTHING
22:08:21 <copumpkin> i.e., a natural number :)
22:08:40 <copumpkin> (ignoring strictness)
22:08:46 <zzing_> Is there a way to make a function that does not default to forall?
22:08:58 <shachaf> copumpkin: Pft. unsafeCoerce makes this way more useful.
22:08:59 <copumpkin> zzing_: what would you want instead?
22:09:18 <copumpkin> shachaf: pfft indeed! I was thinking of using unsafeCoerce to write the function I need in cereal :(
22:09:35 <shachaf> What function do you need?
22:09:36 <zzing_> copumpkin, well - what would be the opposite of forall?
22:09:38 * shachaf doesn't know cereal.
22:09:44 <shachaf> zzing_: fornone, naturally.
22:09:47 <otters> fornone
22:10:05 <zzing_> I was thinking ∃
22:10:16 <shachaf> Haskell doesn't have it.
22:10:23 <shachaf> Well, Haskell doesn't have forall either.
22:10:27 <shachaf> But GHC doesn't have it.
22:10:49 <zzing_> Haskell doesn't but ghc doesn't? wierd way of saying that
22:10:53 <copumpkin> zzing_: there is exists, but you need to wrap it
22:11:05 <zzing_> What exactly does it mean?
22:11:13 <copumpkin> you could write
22:11:19 <shachaf> @google haskell existential quantification
22:11:21 <lambdabot> http://hackage.haskell.org/trac/haskell-prime/wiki/ExistentialQuantification
22:11:21 <lambdabot> Title: ExistentialQuantification – Haskell Prime
22:11:25 <copumpkin> x :: Bool; x = True or x :: exists a. a; x = True
22:11:26 <otters> no, Haskell doesn't have forall, but GHC doesn't have exists
22:11:55 <copumpkin> or x :: exists a. Show a *> x; x = True
22:12:21 <copumpkin> where *> is ski's existential counterpart to =>
22:12:32 <shachaf> Why do you need a counterpart?
22:12:49 <zzing_> The example given    data Foo = Foo (exists a . a -> a)  doesn't realy see what this does
22:13:03 <copumpkin> zzing_: that doesn't actually work anywhere
22:13:08 <dolio> Because Show a => ... means "given Show a, ..." not "Show a and ..."
22:13:25 <shachaf> Ah, I suppose.
22:13:36 <shachaf> When you do the forall thing in Haskell, the => goes on the outside, with the forall.
22:15:05 <zzing_> @src maybe
22:15:05 <lambdabot> maybe n _ Nothing  = n
22:15:06 <lambdabot> maybe _ f (Just x) = f x
22:15:32 <otters> @src Data.List.sort
22:15:33 <lambdabot> Source not found.
22:15:43 <zzing_> :t  (`maybe` Right) . Left
22:15:45 <lambdabot> forall a a1. a1 -> Maybe a -> Either a1 a
22:16:15 <zzing_> making me write out types to figure this out now
22:16:40 <zzing_> :t maybe
22:16:42 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
22:17:28 <zzing_> :t Right
22:17:30 <lambdabot> forall b a. b -> Either a b
22:17:48 <otters> zzing_: ghci
22:18:30 <zzing_> ghci is not as useful
22:18:45 <otters> it is if you install GOA
22:20:22 <zzing_> It doesn't build because it depends on a process that doesn't build
22:20:37 <copumpkin> dolio: I think I might have an ugly solution
22:22:15 <zzing_> :t (`maybe` Right)
22:22:16 <lambdabot> forall a a1. Either a1 a -> Maybe a -> Either a1 a
22:23:54 <Axman6> :t fromMaybe . Left
22:23:56 <lambdabot> forall a b. a -> Maybe (Either a b) -> Either a b
22:24:07 <Axman6> hmm
22:25:01 <zzing_> I think I am screwing up the substitution here
22:25:28 <zzing_> (`maybe` Right) just uses Right to fill in the second parameter, making a new function with the first, and third parameters right?
22:26:49 <zzing_> oh maybe I did it right
22:26:57 <zzing_> :t (Prelude..)
22:26:59 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
22:28:16 <zzing_> @src (Prelude..)
22:28:16 <lambdabot> Source not found. :(
22:28:41 <Axman6> > flip maybe Right . Left
22:28:43 <lambdabot>   Overlapping instances for GHC.Show.Show
22:28:43 <lambdabot>                              (a -> ...
22:28:46 <Axman6> :t flip maybe Right . Left
22:28:47 <lambdabot> forall a a1. a1 -> Maybe a -> Either a1 a
22:30:15 <zzing_> How can an a -> b -> a  be used with (.) if it wants (x -> y)?
22:30:57 <zzing_> :t (.) (`maybe` Right)
22:30:59 <lambdabot> forall a a1 (f :: * -> *). (Functor f) => f (Either a1 a) -> f (Maybe a -> Either a1 a)
22:31:05 <Axman6> well, a -> b -> a is just a -> c where c is b -> a
22:31:11 <zzing_> :t (Prelude..) (`maybe` Right)
22:31:13 <lambdabot> forall a a1 a2. (a2 -> Either a1 a) -> a2 -> Maybe a -> Either a1 a
22:32:25 <zzing_> ok, I think I worked it out then
22:32:34 <diego_diego> Hi all. First off, haskell newbie here, so still learning a lot. The question: I am handling a fastcgi request, and I want to make an http call to another address while handling the request. I can't seem to get the following demo program running (any help is appreciated)
22:32:35 <zzing_> have to convince myself sometimes
22:32:50 <hpaste> diego_diego pasted “fastcgi, httprequest” at http://hpaste.org/71247
22:33:00 <diego_diego> http://hpaste.org/71247
22:33:42 <Axman6> diego_diego: what problem are you actually having?
22:33:57 <diego_diego> when I try to load on ghci I get the following
22:34:35 <hpaste> diego_diego pasted “ghci error” at http://hpaste.org/71248
22:34:46 <Axman6> also, please please please change your editor to insert spaces instead of tabs
22:35:00 <Axman6> it'll save you so much heartache as you learn haskell
22:35:09 <Cale> those are spaces, just a lot of spaces...
22:35:27 * Axman6 just managed to accidentally kill his browser so can't check...
22:35:50 <diego_diego> sorry, I'm still learning where things should line up
22:36:20 <Axman6> i just saw indentation > 4 spaces and assumed tabs here being used
22:37:37 <liyang> diego_diego: 4 spaces for each level of indentation; use as few levels as possible. Don't line your do block up to the do keyword.
22:38:00 <Cale> There isn't really a fixed number of correct spaces, but generally just making things line up is good
22:38:09 <Cale> I usually line things up like:
22:38:20 <liyang> diego_diego: https://github.com/tibbe/haskell-style-guide/blob/master/haskell-style.md
22:38:22 <Cale>   do testingRequest <- ...
22:38:28 <Cale>      output ...
22:38:33 <liyang> Cale: nooooo!!!
22:38:54 * liyang always takes a new line after do.
22:39:04 <liyang> (Unless it's a one-liner.)
22:39:05 <Cale> I'll usually put one before
22:39:54 <liyang> diego_diego: as you can see there are different preferences.
22:40:07 <Cale> I hate to break the rule that the children of some expression form should start in a deeper column.
22:40:20 <diego_diego> liyang: haha indeed, but thanks for the github style link, it's a start
22:40:54 <Cale> oh, I missed that you actually posted the error
22:41:15 <Cale> right, it looks like you're not actually running the CGI computation that you built, instead using it as main
22:41:24 <Cale> errr
22:41:33 <Cale> nope
22:41:34 <Cale> heh
22:42:42 <hbt_> Consider the function iterate :: (a -> a) -> a -> a; iterate f x = f (f x). This iterates something twice. Is there a way to make a function that takes an integer n, a function, a some datathingy  as parameters, and iterates the function n times on the data? (so a variable number of iterations)
22:42:42 <Cale> oh
22:43:15 <Cale> diego_diego: The problem is that NH.simpleHTTP (...) is an IO action
22:43:19 <Cale> not a CGI action
22:43:34 <Axman6> hbt_: foo f x n = iterate f x !! n
22:44:02 <diego_diego> ok, but I thought that doing <- got the string from the action
22:44:42 <Cale> it does, but all the actions in a do-block have to be in the same monad
22:44:50 <Axman6> not just any action. it had to be in the monad you're using
22:45:00 <Axman6> s*
22:45:08 <diego_diego> Cale: I thought that in doing testingRequest <- ..., that testingRequest would then be of String type
22:45:10 <Cale> In this case, the solution is actually easy, because CGIT is a monad transformer
22:45:15 <hbt_> Axman6: I thought !! picked out elements of a list?
22:45:21 <Cale> and we're writing an action in the CGIT IO monad
22:45:27 <Axman6> it does...
22:45:36 <Cale> what that means is that we can take IO actions and turn them into CGIT IO actions
22:45:45 <zzing_> Is ∃ allowed as an identifier?
22:45:52 <Cale> using lift from Control.Monad.Trans
22:45:56 <Axman6> hbt_: thats exactly what you want no? you wanted the nth iteration
22:45:59 <Cale> So import Control.Monad.Trans
22:46:15 <Cale> and then  testingRequest <- lift $ ... what you currently have ...
22:46:34 <diego_diego> Cale: ok I'll give that a shot
22:46:40 <hbt_> Axman6: I want the function to be called n times. So if n is 4, we get f(f(f(f(x))))
22:46:56 <Axman6> hbt_: thats exactly what I gave you
22:47:00 <Axman6> try it
22:47:07 <Cale> ... it happens that I get a runtime error now, but I have no idea why that is :)
22:47:30 <Cale> *** Exception: user error (FCGX_Accept failed with error code: -88)
22:47:41 <Cale> Hopefully you won't get the same...
22:47:59 <Axman6> > iterate show 1
22:48:01 <lambdabot>   No instance for (GHC.Num.Num GHC.Base.String)
22:48:01 <lambdabot>    arising from the literal `...
22:48:08 <Axman6> bleh
22:48:11 <Axman6> > iterate show ""
22:48:11 <hbt_> So iterate f x gets called, which applies f twice.
22:48:12 <lambdabot>   ["","\"\"","\"\\\"\\\"\"","\"\\\"\\\\\\\"\\\\\\\"\\\"\"","\"\\\"\\\\\\\"\\\...
22:48:23 <Axman6> > iterate (+1) 1
22:48:24 <diego_diego> Cale: I guess this is kind of hittting the boundary of my understanding of haskell so far, so is there a reason why the actions in a do block have to be in the same monad? Also, hmm it's kind of unclear to me what that means
22:48:25 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
22:48:33 <Axman6> > iterate f x
22:48:34 <lambdabot>   [x,f x,f (f x),f (f (f x)),f (f (f (f x))),f (f (f (f (f x)))),f (f (f (f (...
22:48:42 <Cale> diego_diego: Well, yes...
22:48:50 <Cale> diego_diego: Let's look at some more examples of monads
22:48:51 <hbt_> oh, you used a different iterate function, haha.
22:48:58 <hbt_> oh wait
22:48:58 <hpaste> isomorphic pasted “API build fail” at http://hpaste.org/71249
22:49:00 <hbt_> err
22:49:13 <Cale> > do x <- [1,2,3]; y <- [4,5]; z <- [6,7,8]; return (x,y,z)
22:49:15 <lambdabot>   [(1,4,6),(1,4,7),(1,4,8),(1,5,6),(1,5,7),(1,5,8),(2,4,6),(2,4,7),(2,4,8),(2...
22:49:19 <Axman6> no, I didn't, that's what iterate does, it applies 0 to infinite times
22:49:22 <Cale> There's the list monad in action :)
22:49:31 <Axman6> applies a function to an argument*
22:49:41 <isomorphic> I'm trying to build paypal-api in Cabal - I've pasted relevant code with line numbers on hpaste
22:49:44 <hbt_> Ok but in my example I defined another function called iterate, hence my confusion.
22:49:47 <hbt_> Thanks for the help.
22:49:49 <isomorphic> Can somebody explain the GHC error?
22:49:59 <isomorphic> `PayPalResponse' is not a (visible) associated type of class `PayPalRequest' ?
22:50:04 <Axman6> hbt_: well you'd have to tell us that. I can't read your mind :\
22:50:06 <diego_diego> Cale: ok, I think so far so good
22:50:14 <zzing_> :t Data.Text.intercalate
22:50:16 <lambdabot> Data.Text.Internal.Text -> [Data.Text.Internal.Text] -> Data.Text.Internal.Text
22:50:26 <Cale> > let dict = [(1,2),(2,3),(3,4)] in do x <- lookup 1 dict; y <- lookup x dict; return y
22:50:28 <lambdabot>   Just 3
22:50:40 <Cale> There's the Maybe monad being used to chain some lookups which might fail
22:50:56 <Cale> It doesn't really make sense to mix the two directly
22:51:23 <Cale> do-notation translates in terms of >>=
22:51:30 <Cale> are you familiar with that already?
22:51:33 <Cale> :t (>>=)
22:51:35 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
22:51:47 <Cale> There's only one monad m involved in the type of >>=
22:52:15 <Lemon> I've been writing a typechecker
22:52:17 <diego_diego> Cale: I understand that to mean that the output is passed to the next function?
22:52:20 <Cale> and the idea of a generalisation where more than one m would appear frequently doesn't make sense to even consider
22:52:24 <Guest10268> Guys,  can somebody explain maybe , what does this code  means actually ...Monaden Instanz?
22:52:25 <Guest10268> [1,2,3] >>= (nx -> return (2*x))
22:52:46 <Lemon> and at multiple times I wished for a function unifySub where two substitutions are merged into one by unifying the mapped types
22:53:04 <Guest10268> [1,2,3] >>= (\x -> return (2*x))
22:53:12 <Guest10268> thats the tru version
22:53:14 <Lemon> how come all the literature about type inference only talk about using composition on substitutions,
22:53:19 <XexonixXexillion> Guest10268: if I rephrase it as concatMap (\x -> [2*x]) [1,2,3] do you know what it does?
22:53:26 <Cale> > [1,2,3] >>= (\x -> return (2*x))
22:53:28 <lambdabot>   [2,4,6]
22:53:31 <Lemon> instead of treating them as globs of "mergeable" constraint information?
22:53:50 <diego_diego> Cale: ah ok, so it has to do with what the stuff in a do block gets translated to
22:53:51 <Cale> diego_diego: okay, so in the list monad, we have  xs >>= f = concat (map f xs)
22:54:05 <Cale> diego_diego: well, that's one way to understand it better
22:54:30 <Cale> Translating the do-notation away makes it clearer why you can't just mix and match monads randomly
22:54:35 <Guest10268> XexonixXexillion: not so good my friend, i know what concat is ok...but not Concat map
22:54:49 <Cale> by taking away some of the magic, I guess :)
22:55:43 <Cale> diego_diego: If you wanted to mix and match, you'd need there to be operations  m a -> (a -> n b) -> l b, or something, where m and n and l are monads, and possibly l depends in some way on m and n
22:56:02 <Cale> and it would get hairy -- for some m and n it's not clear that a suitable l even exists
22:56:38 <XexonixXexillion> Guest10268:  concatMap = concat . map, so we get concat (map (\x -> [2*x]) [1,2,3])
22:56:56 <shachaf> concatMap /= concat . map, but yes.
22:57:01 <diego_diego> Cale: gotcha, this makes sense. I'm copy pasting your comments to save while I read up a bit more on monads (and lifting them). As for the runtime error, I think it has to do with how it's being run. I'm going to go try again now (brb). Thanks for the insights.
22:57:14 <copumpkin> dolio: I updated the question with a new (failed) attempt, if you're curious :P
22:57:37 <Cale> diego_diego: Right, so the gist of what monad transformers are about is that they're like functions at the type level which turn one monad into another
22:57:44 <zzing_> coolest operator ever: ⨳  "smash product"
22:57:46 <Cale> diego_diego: usually by adding some extra structure
22:57:51 <Nereid> concatMap = concat .: map ?
22:57:52 <XexonixXexillion> Guest10268: which then reduces to concat [[2],[4],[6]]
22:57:55 <copumpkin> http://stackoverflow.com/questions/11424961/having-my-cereal-and-parsing-it-too or if anyone else wants to take a look
22:57:56 <Nereid> :t concat .: map
22:57:58 <lambdabot> forall a a1. (a1 -> [a]) -> [a1] -> [a]
22:58:07 <Nereid> :t concatMap
22:58:09 <lambdabot> forall a b. (a -> [b]) -> [a] -> [b]
22:58:12 <Nereid> good enough
22:58:35 <Cale> diego_diego: actually, if you'd like I can give a bit of a tutorial in #haskell-overflow
22:58:45 <Guest10268> XexonixXexillion: thx so mujch for expanation
22:58:45 <Nereid> zzing_: I see a box
22:58:48 <XexonixXexillion> derp... I'm half asleep.... concatMap f x = concat (map f x)
22:58:57 <Guest10268> :D
22:58:58 <zzing_> Nereid, it is a UTF8 character
22:59:04 <zzing_> # rotated 45º
22:59:05 <Nereid> yes, my font doesn't have it
22:59:08 <Nereid> oh
22:59:10 <shachaf> Cale: After that, you should give a second bit of a tutorial and put it on the wiki. :-)
22:59:14 <Nereid> that's not the smash product I know
22:59:30 <zzing_> Its in the character viewer on the mac
22:59:41 <zzing_> Nereid do you see this? "∆"
22:59:45 <Nereid> yes
22:59:52 <zzing_> (∆) = flip $ (`maybe` Right) . Left
22:59:53 <Cale> diego_diego: still here? :)
23:00:01 <Nereid> copying it to somewhere else worked
23:00:06 <zzing_> case config' ∆ errs of
23:00:06 <Nereid> it's still not the smash product I know
23:00:09 <diego_diego> Cale: hey, still here
23:00:27 <Nereid> @type flip $ (`maybe` Right) . Left
23:00:29 <lambdabot> forall a a1. Maybe a -> a1 -> Either a1 a
23:00:29 <zzing_> My evil use of operators
23:00:55 <Cale> diego_diego: if you'd like, I can explain, say, how the State monad works, and how we can make a monad transformer out of it, which should give some idea of what this CGIT thing might look like
23:01:51 <zzing_> I came up with something instead of using 'error'
23:01:57 <Cale> Or I can just let you get back to trying to hack on your program, if that sounds like more fun :)
23:02:23 <diego_diego> Cale: crap, I think that'd be very useful! however, I'm short on time and sleep (running on EST here). thanks so much!
23:02:25 <Nereid> anything's better than using "error"
23:02:47 <Cale> diego_diego: well, if you're interested at some point, send me a message
23:03:03 <Cale> I'm often around, even if I'm not talking (or watching the channel)
23:03:05 <diego_diego> Cale: if I can pull this little program off for work I will definitely be hanging out here!
23:03:18 <zzing_> ok, this is annoying… cabal: dependencies conflict: ghc-7.4.2 requires filepath ==1.2.0.1 however   filepath-1.2.0.1 was excluded because filepath-1.3.0.0 was selected instead       filepath-1.2.0.1 was excluded because snaplet-fetch-0.2.0 requires filepath>=1.3
23:03:23 <Nereid> Cale: how many times have you explained to someone how the State monad works? ;)
23:03:24 <zzing_> This all worked before
23:03:32 <Cale> Nereid: dozens at least :)
23:03:41 <isomorphic> Can somebody please point me to a simple example of an associated type of a class?   I'm trying to debug a build, but struggling with the syntax of associated types
23:04:31 <shachaf> @google associated types
23:04:34 <lambdabot> http://www.haskell.org/haskellwiki/GHC/Type_families
23:04:34 <lambdabot> Title: GHC/Type families - HaskellWiki
23:04:37 <shachaf> isomorphic: That page has a bunch of examples.
23:05:07 <zzing_> Was the much change between filepath 1.2 and 1.3?
23:05:22 <Cale> isomorphic: What are you trying to build?
23:05:24 <zzing_> I apparently was using filepath-1.3 when I made this module
23:06:34 <tgeeky> Data\Text\IO\Internal.hs:35:24:
23:06:34 <tgeeky>     Module `Prelude' does not export `catch'
23:06:36 <tgeeky> !!
23:06:43 <isomorphic> cale: paypal-api - Hpaste is here: http://hpaste.org/71249 - I am guessing the syntax accepted by ghc must have changed because PaypalRequest class seems to (correctly) refer to PayPalResponse.
23:07:37 <kfish> zzing_, is snaplet-fetch your module?
23:07:41 <zzing_> yes
23:07:49 <zzing_> I just lowered the version required
23:07:58 <zzing_> and it still gives me ghc-7.4.2 requires filepath ==1.3.0.0 however filepath-1.3.0.0 was excluded because ghc-7.4.2 requires filepath ==1.2.0.1
23:08:06 <zzing_> Which looks bizare
23:08:41 <zzing_> I did just try to install goa (which failed), I wonder if that could be it
23:20:35 <stj> what's the name of the tool that generates function definition simply based on type signature?
23:20:44 <isomorphic> stj: djinn?
23:21:59 <stj> isomorphic: thx
23:22:48 <isomorphic> shachaf: This link is simpler - the page on associated types on the wiki is mixed up with a very specific example from a paper by Hinze - I found this more helpful - http://nattermorphisms.blogspot.com.au/2008/10/2-minute-intro-to-associated-types-type.html
23:23:30 <shachaf> isomorphic: Anyway, is it just that those things aren't in the same file or something?
23:24:04 <shachaf> Usual debugging procedure: Take the code, put it on its own, make it as simple as possible, and slowly add bits to make it closer to your example until it breaks.
23:24:11 <isomorphic> shachaf:  They're in different files, but one imports the other.
23:24:39 <shachaf> Well, does it work if you put the two in the same file? If so, the problem's probably not with your syntax!
23:24:53 <shachaf> Does one module actually import everything from the other?
23:26:18 <isomorphic> Yes - it should be reproducible by just doing cabal install paypal-api - actually - that would be really handy if somebody could reproduce! :P
23:29:42 <shachaf> Oh, that's not your module?
23:29:49 <shachaf> Never mind, then. :-)
23:29:51 <isomorphic> No - it's from cabal  ;)
23:30:55 <isomorphic> shachaf:  That might explain why I was having trouble building the simple version ;)
23:33:06 <bobry> Anyone using Travis-CI for Haskell projects here?
23:37:57 <zzing_> My god it takes a while to build everything for my snaplet-fetch
23:39:07 <isomorphic> Shachaf:  Thanks for the suggestions - problem solved based on your suggestions :)
23:39:19 <shachaf> isomorphic: Oh! Good to know.
23:39:20 <shachaf> What was it?
23:41:23 <isomorphic> PayPalRequest was exposed as   PayPalRequest(decodeResponse).  This does not include, apparently, lines 860-861 from this hpaste http://hpaste.org/71249
23:41:46 <isomorphic> Fix was to modify so that  PayPalRequest(..)
23:41:54 <isomorphic> Mystery to me is how it ever compiled
23:42:29 <shachaf> Maybe it *was* a change in GHC.
23:42:35 <shachaf> Though not a syntactic one, really.
23:43:13 <isomorphic> Suggestion to check the imports was the key though - so thanks.  If you look at my hpaste, it's the imports that I'd figured were already there - incorrectly. :/
23:45:02 <zzing_> Is there any way to simplify this definition? fetchInit :: (HasHeist b, (MonadSnap ((->) Fetch))) => SnapletInit b Fetch
23:51:13 <Nereid> zzing_: what definition
23:51:58 <zzing_> one sec, I am getting some bizarre snap type error
23:53:45 <zzing_> on line 48 of this: https://github.com/iaefai/snaplet-fetch/blob/master/src/Snap/Snaplet/Fetch.hs
23:54:28 <zzing_> When I load the module up in ghci (using :load) and then do a :t on fetchInit it says No instance for (MonadSnap ((->) Fetch))      arising from a use of `fetchInit'
23:54:33 <zzing_> But there is that definition right there
23:54:38 <zzing_> on line 48
23:56:24 <zzing_> Then when I go to call that very function else where, I get No instance for (snap-core-0.9.0:Snap.Internal.Types.MonadSnap                       ((->) Fetch))    which I am obviously not supposed to be able to see because it is internal
